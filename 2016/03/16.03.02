00:00:01 <shanemikel> is that a real question?
00:00:13 <opqdonut> I don't think there is a fundamental reason for equivalent programs to have nonequivalent performance :)
00:00:29 <tero-> well with a relaxed interpretation for program equivalence..
00:01:19 <tero-> maybe a slightly better formulation would be that is there other things than laziness hindering Haskell's performance?
00:02:41 <saurabhnanda> are there any speed benchmarks out there between haskell and ocaml?
00:03:29 <tero-> saurabhnanda: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=ghc&lang2=ocaml
00:03:54 <shanemikel> the biggest issue with haskell performance, is style.. it's cleaner and more idiomatic to write things in the functional idiom; though lower level programming is possible, people will avoid it until necessary.. that's really a philosophy difference, clarity, readability, and elegance are seen as more important than performance, until absolutely necessary
00:04:26 <KKK4LIFE> why are you voting for president trump?
00:04:38 <saurabhnanda> what does kb mean there? on the benchmarks game?
00:05:28 --- mode: ChanServ set +o mauke
00:05:28 --- mode: mauke set +b *!*@172.58.17.26
00:06:35 <echo-area> mniip: Perhaps one can also use calculations like in http://lpaste.net/153848
00:06:37 <cocreature> probably kilobytes or kibibytes
00:07:28 --- mode: mauke set -o mauke
00:07:34 <shanemikel> honestly, I think it would be more useful for you to approach this from a different angle.. why not decide it's worthwhile to learn both, and choose the one to use now based on domain alone.. that is, if you're going to use Mirage or do some systems programming, maybe go OCaml.. or if it's a web app, compare frameworks and libraries
00:09:04 <shanemikel> see what clicks.. if you do chose haskell, If your design is right, I don't think performance is gonna be a problem
00:10:32 <shanemikel> also, take a look at the community.. see if the OCaml irc people are friendly enough to sell you their web frameworks
00:10:57 <tero-> which language has bigger user base?
00:15:23 <shanemikel> tero-: that's a good question
00:16:02 <shanemikel> probably get a good indication by number of libraries in opam vs hackage
00:16:07 <shanemikel> err packages
00:16:54 <tero-> http://www.googlefight.com/haskell-vs-ocaml.php Haskell 200 Ocaml 32 :)
00:18:04 <tero-> this is also interesting https://www.google.com/trends/explore#q=haskell%2C%20ocaml&cmpt=q&tz=Etc%2FGMT-2
00:18:31 <tero-> although the results are a bit biased towards haskell because it's a last name
00:19:15 <shanemikel> first name?
00:19:35 <shanemikel> it's also the name of a street near me
00:19:46 <tero-> it seems it can be last name or first name
00:19:53 <shanemikel> I was pretty happy to discover that
00:27:47 <ggVGc> this is one of the first things I saw when I visited my friend in LA a few weeks ago, https://scontent-sin1-1.xx.fbcdn.net/hphotos-xpf1/v/t35.0-12/12695585_10204274761148075_1220847815_o.jpg?oh=3c5cf94a56de268b5cc14548ab09e835&oe=56D832C9
00:28:06 <shanemikel> I'm trying to figure out control flow with pipes.. how about splitting (or forking) the input of a single Pipe into two transformations that join, yielding a tuple stream?
00:28:13 <tero-> they better teach it too
00:28:43 <monkeyiq> seems I get a compile error on getGuest from the hxt simple1 example, not sure what I've done wrong. https://wiki.haskell.org/HXT/Practical/Simple1
00:31:03 <monkeyiq> ok, that seemed to be that I missed the Arrows pragma
00:31:54 <Hafydd> Haskell is notably the first name of Haskell Curry.
00:32:12 <nymacro> speaking of curry. I might go get some
00:32:23 <nymacro> no pun intended
00:32:52 <Hafydd> I don't think that's possible.
00:32:54 <shanemikel> dont flatter yourself :)
00:37:04 <parsecChar> how do I tell "stack ghci" give me -Wall, but not the "module XYZ is redundant type warnings"
00:38:22 <Hafydd> I've never seen a message of the form "module XYZ is redundant type warnings".
00:38:27 <kaman> hello
00:38:48 <parsecChar>     The import of ‘Database.Groundhog.Core’ is redundant       except perhaps to import instances from ‘Database.Groundhog.Core’     To import instances alone, use: import Database.Groundhog.Core()
00:39:11 <parsecChar> these are the warnings I'm trying to suppress; modules which are imported but not used (happens quite frequent during development process)
00:39:23 * hvr points out that in GHC8 the warning will be prefixed by [-Wredundant-imports]
00:39:40 <parsecChar> I'm in 7.10.x
00:39:49 <hvr> or rather [-Wunused-imports]
00:39:56 <hvr> parsecChar: try to pass it -fno-warn-unused-imports
00:40:25 <hvr> parsecChar: if everything fails, you set add :set -fno-warn-unused-imports to your ~/.ghci
00:40:27 <Hafydd> I'm not familiar with stack, but this sounds unrelated to stack, in fact, and could be solved by putting {-# OPTIONS_GHC -fno-warn-unused-imports #-} in the file in question.
00:41:44 <parsecChar> hvr: I like :set -fno-warn-uused-imports
00:41:49 <parsecChar> it lets me toggle it on/off inside of ghci
00:42:04 <Hafydd> Except... that will cause you to ignore any future redundant imports. I'd rather just remove the redundant imports and add them when needed.
00:43:18 <jle`> shanemikel: you might be looking for tee
01:02:51 <saurabhnanda> back. got pulled in a meeting. Where were we... Haskell vs Ocaml performance
01:03:15 <hopp_> B^A = Powerset(A x B)?
01:04:34 <hopp_> i guess subset actually, to be left total
01:04:46 <hopp_> or right unique
01:05:07 <shanemikel> saurabhnanda: can you look at the history of what was said after you left?
01:05:45 <saurabhnanda> shanemikel: done that
01:05:56 <saurabhnanda> shanemikel: compare frameworks and libraries instead of language features
01:07:18 <shanemikel> well, not exactly.. the difference in language is bigger than features, it's design
01:09:13 <saurabhnanda> so, what's the recommended SQL/ORM library in OCaml? Recommended library to build web-apps?
01:09:47 * hackagebot yesod-auth-oauth 1.4.1 - OAuth Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-oauth-1.4.1 (MichaelSnoyman)
01:10:22 <shanemikel> especially if you're worried about behavior, you should look through syntactic sugar.  probably the biggest performance consideration is whether you want to design for laziness or strictness
01:11:00 <shanemikel> as far as libraries go, yesod and snap seem to be the haskell contenders.. for ocaml you'd proably have better luck on their channel
01:11:25 <kaman> What do you know about functional languages and Haskell in particular? How could I answer this question
01:11:44 <saurabhnanda> kaman: is that for me?
01:11:48 <shanemikel> sql and orm, not as straightforward
01:12:32 <tdammers> ORM means *object*-relational mapper
01:12:41 <tdammers> that doesn't even make sense in a language that isn't object-oriented
01:12:50 <saurabhnanda> shanemikel: yup. Haskell's storey in SQL & ORM is not that great. But I'm making do with Yesod/Persistent.
01:13:07 <saurabhnanda> s/ORM/RRM (Record-Relational mapper)
01:13:29 <tdammers> mapping between records and SQL result sets / INSERT params is fairly trivial though
01:13:59 <tdammers> the hard part about ORMs is typically the part where you abstract further, e.g. implementing something like ActiveRecords
01:14:05 <tdammers> (which, IMO, is a dead end)
01:14:58 <saurabhnanda> tdammers: you're proclaiming the death of ActiveRecord to someone who's dealing with 150,000 lines of code in Ruby on Rails. Most of it dealing with ActiveRecord. Pushing & Pulling stuff from an SQL database.
01:15:35 <tdammers> not the death
01:15:50 <tdammers> I just think that it is flawed, conceptuall
01:15:51 <tdammers> y
01:16:34 <shanemikel> well, in a language with laziness, it's not necessary
01:16:43 <kaman> I mean, what does Haskell mainly used for ? developing DSL?
01:16:55 <tdammers> Haskell is a general-purpose language
01:17:04 <saurabhnanda> tdammers: conceptually, probably. Practically, probably not. I agree that ORM is a fairly leaky abstraction. But if you stop thinking about it as a pure mathematical idea (which needs to hold up to incredible scrutiny) and start thinking of it as a DSL, which help you write less code, you'll start seeing its value.
01:17:29 <tdammers> I see its value, I just happen to think that it's not ultimately worth it
01:17:43 <saurabhnanda> kaman: for having abstract discussions about functors, applicatives, monoids, monads, and monad transformed :-)
01:17:48 <tdammers> "thou shalt not lie about thy data"
01:19:13 <tdammers> db.insert(row) is honest and truthful: we ask the database to insert a row (figuring out the correct table from the row's type)
01:19:32 <tdammers> row.insert() is wrong - we ask the row to insert itself into an implicit database
01:19:56 <tdammers> which means that we have to either make the database global, or store a reference to it in the row itself
01:20:09 <tdammers> it's convenient, but you're lying about your data
01:20:13 <opqdonut> yeah it's nice if row can be just data
01:20:14 <bernalex> kaman: it's general purpose. it is frequently used for programming languages, compilers, various forms of parsers, and things that need to be (verifiably) correct. it has plenty of desirable features for programming in general (especially in how simple it is to refactor large software projects), but big companies, as you probably know, will only jump on a shiny new toy where it is *the most* beneficial, or
01:20:16 <bernalex> where it is the simplest to employ. and haskell is arguably the most beneficial when you need correctness, as well as the simplest choice if you are writing parsers or programs based on mathematical models.
01:21:05 <saurabhnanda> tdammers: your argument about row.insert() is actually not an argument against ORM at all.
01:21:08 <bernalex> kaman: but again -- it is nice in general for any programming, and is frequently used for e.g. backend web projects.
01:21:16 <tdammers> saurabhnanda: it's against a certain kind of ORM
01:21:35 <tdammers> saurabhnanda: there's nothing wrong with writing abstractions that map result sets onto data types
01:21:48 <tdammers> saurabhnanda: but "ORM" is usually taken to mean more than that
01:22:15 <saurabhnanda> tdammers: I mean, what if the backend were Redis. It's actually an argument FOR the Reader monad, I guess. Nothing to do with the de-merits of o<=>r mapping.
01:22:38 <shanemikel> there seems to be https://hackage.haskell.org/package/postgresql-orm
01:23:37 <shanemikel> why not use a caching layer? seems like the IPC domain to me
01:23:46 <tdammers> my main gripe with ORM is that it tries to make relational data behave like objects
01:23:53 <saurabhnanda> actually wrt libraries (ocaml vs haskell) -- I think I got my answer - https://github.com/rizo/awesome-ocaml/#databases
01:24:32 <tdammers> anyway, if you want database access, there's HDBC, as well as libraries for individual DBMSes
01:24:49 <saurabhnanda> tdammers: start thinking of it as a way to write LESS sql queries. Avoid SQL **boilerplate** Not avoid SQL altogether. Just do that and you'll hit the sweet spot.
01:24:53 <tdammers> on top of that, there's Persistent, and you can throw Esqueleto on top for more expressivity
01:25:23 <tdammers> saurabhnanda: that's exactly what I do - but I wouldn't call it ORM, because it doesn't actually involve object-like semantics
01:26:00 <saurabhnanda> sometimes I wonder why we can't write SQL queries in an AST and send it over the wire
01:26:06 <tdammers> saurabhnanda: we can
01:26:06 <saurabhnanda> why the need for an Query Language
01:26:23 <shanemikel> uhh.. you don't sql over the wire?
01:26:30 <saurabhnanda> wouldn't an AST be more composable, type-safe, and programmatically accessible?
01:26:49 <saurabhnanda> shanemikel: say what?
01:27:01 <tdammers> or rather, we can build libraries that provide an AST which gets serialized to SQL when we send it to the database server
01:27:31 <tdammers> but the way networking works, you have to serialize your queries at some point, one way or antoher
01:28:01 <saurabhnanda> serialize the AST in s-exprs
01:28:08 <saurabhnanda> s/in/into
01:28:13 <tdammers> sure
01:28:16 <LordBrain> i think SQL should really be obsoleted by something better tho
01:28:19 <tdammers> but then you'd just replace one standard for another
01:28:24 <LordBrain> even for the servers themselves
01:28:29 <tdammers> LordBrain: like what?
01:28:46 <saurabhnanda> and actually use the database's internal query parser to ensure that ASTs are type-safe (or well-formed) during compile-time, if possible.
01:29:30 <tdammers> in my experience, trying to make the interfaces between independent programs type-safe is a huge pain and not generally worth it
01:29:34 <tdammers> (cf. SOAP)
01:30:24 <saurabhnanda> the world where I come from, DBs are such an integral part of your stack (your code and DB are HIGHLY correlated) that NOT having type-safety at the interface seems like a bummer.
01:30:51 <LordBrain> hmmm, i am quite sure there have already been better things out there, its just that there were licensing issues and stuff, i think oracle had something cool... anyway, i think individual langauges should speak their own tongue and have some standard serializing technique for the go between, like protocol buffers, and just have an untyped database like lmdb that plops the wire bits down.
01:30:51 <shanemikel> I'd think a well designed combinator library could do that
01:31:19 <tdammers> the problem with type-safe cross-process interfaces is that you need to somehow interface the type checkers on both sides
01:31:39 <tdammers> i.e., the type checker on the client side needs to know everything about the type checker on the server side
01:31:53 <tdammers> and there needs to be a way to guarantee, at runtime, the versions on either side match
01:32:09 <tdammers> otherwise, you'll essentially be using runtime type checks after all
01:32:37 <shanemikel> is SQL really that complex that haskell types couldn't express it?
01:32:37 <tdammers> (guarantee at *compile time*, I meant)
01:32:43 <tdammers> shanemikel: they can
01:32:57 <tdammers> shanemikel: Esqueleto does pretty much exactly that
01:33:07 <shanemikel> interfacing more sophisticated languages with each other is another matter
01:34:13 <tdammers> there are some details that are hard to capture in a type system like Haskell's though, such as making sure that a SELECT query with a GROUP BY selects only columns that are in the GROUP BY or aggregate functions over other columns
01:34:32 <tdammers> it can be done, but it makes the resulting EDSL rather unwieldy
01:36:53 <shanemikel> oh, I see, you're talking about static verification of the actual schema, not the syntax itself
01:37:34 <LordBrain> there must be systems out there that require xml scheme
01:37:35 <tdammers> both
01:37:38 <LordBrain> schema
01:37:45 <tdammers> LordBrain: SOAP
01:37:57 <shanemikel> which, i guess, is required if you want to type functions over columns
01:38:06 <shanemikel> or aggregates
01:38:48 <tdammers> no, you just have to type over queries
01:39:06 <tdammers> SELECT a, b FROM c GROUP BY a; -- is wrong regardless of schema
01:39:09 <hopp_> is \Pi(a:A),B(a) \subset \Sigma(a:A),B(a)?
01:39:55 <LordBrain> try #typetheory
01:40:14 <hopp_> there is only 1 person there :'(
01:40:29 <tdammers> that's because in order to join you need to type-check
01:40:39 <shanemikel> lol
01:40:43 <tdammers> also
01:40:45 <tdammers> :t join
01:40:46 <lambdabot> Monad m => m (m a) -> m a
01:41:10 <shanemikel> why don't I have latex in my irc client :(
01:41:17 <tdammers> which tells us that in order to join (Type Theory), you need a Type (Type Theory)
01:45:53 <Jinxit> how would you pronounce ⊞ ?
01:46:18 <shanemikel> four-square
01:46:32 <LordBrain> http://graphemica.com/%E2%8A%9E
01:46:39 <LordBrain> "squared plus"
01:46:48 <CindyLinz> It looks like Tian (田) in Chinese.. XD
01:49:06 <Jinxit> LordBrain: yeah I know unicode has it as squared plus
01:49:17 <Jinxit> and latex (amssymb) has it as \boxplus
01:49:48 * hackagebot network-fancy 0.2.4 - Networking support with a cleaner API  https://hackage.haskell.org/package/network-fancy-0.2.4 (TaruKarttunen)
01:54:37 <LordBrain> squared as analogous to circled, it makes sense, nice english description
02:26:54 <meditans> chominist: hey
02:28:00 <meditans> so, let's consider this signature (I'm using the vinyl library):
02:28:22 <meditans> c :: (ps ≅ ('Foo ': rs), RecAll Attr rs Default) => Rec Attr ps
02:28:54 <meditans> this yields the error Could not deduce (RecAll Attr rs0 Default) … from the context (ps ≅ ('PitchValue : rs), RecAll Attr rs Default)
02:30:05 <meditans> and I suspect that the problem is the use of rs, but I'd like to understand all the details
02:33:30 <tototutu> lens noob here: if I have data Q = {myString :: String} and data P = P {myList :: [Q]} how, do I retrieve the nth element from myList using lens?
02:36:17 <meditans> well, if you have data P = P {_myList :: [Q]} and use makeLenses ''P to generate the lens myList
02:38:00 <tototutu> meditans: I'd like to write something like view (myList . (get 0) . myString) (undefined :: P) to get the 0-th element from P and then its unwrapped value
02:38:06 <meditans> it should suffice p ^? myList . ix (n-1)
02:38:59 <meditans> p ^? myList . ix 0 . myString
02:39:21 <meditans> should retrieve just the unwrapped value, or nothing if there isn't a first element
02:39:23 <puregreen> is there something like http://ctford.github.io/klangmeister/ for Haskell?
02:40:07 <meditans> puregreen: I'm only aware of the FPComplete center
02:40:20 <tototutu> meditans: thanks!
02:40:24 <meditans> oh, specific for music?
02:40:33 <puregreen> yep, preferably not in browser
02:40:47 <meditans> tototutu: np!
02:41:19 <meditans> well, for music you should check tidal, I think that's the closest thing
02:42:03 <meditans> otherwise, for a general approach, you might try music-suite
02:43:25 <puregreen> okay, thanks
02:44:43 <tototutu> meditans: btw, if ^? is used to get, which operator should I use to set?
02:46:17 <meditans> tototutu: in your case, (myList . ix 0 . myString .~ value) is the function that sets the value you got before
02:47:06 <tototutu> meditans: thanks! That stuff is hard
02:47:35 <meditans> tototutu: it's not that ^? is used to get, in lens there are many things used to "get": ^. when you want to get a value, ^.. when you want to get multiple values, ^? when you want to get a value that may not exist, ^?! when you just don't care (unsafe)
02:48:01 <meditans> if you check the types for these operators, you'll notice the similarities
03:00:16 <saurabhnanda> tdammers: "and there needs to be a way to guarantee, at runtime, the versions on either side match" >> I don't see that as a problem. Compilers do that every time they link with dynamic libraries. You **assume** that the target system has version-so-and-so of x, y, & z libraries and build your binary. That's the same thing you can do with the hypothetical SQL AST-magic.
03:05:21 <tdammers> saurabhnanda: yes, that's kind of my point - it's the same thing as the SQL AST magic, so overloading the API with type information has zero practical benefit
03:05:30 <tdammers> but the cost is enormous
03:05:36 <tdammers> just look at SOAP to get an impression
03:06:17 <tdammers> SOAP aimed to provide type-safe web services, but because of the nature of web services (neither side controls the other), the best you can get is runtime type checks
03:07:07 <tdammers> but if you check at runtime anyway, there's not a lot of merit to adding all that schema overhead, because then you can just send your message and validate the response as you receive it
03:07:26 <tdammers> and agree on a schema through out-of-band methods
03:07:35 <parsecChar> https://gist.github.com/43d6f19c3aaa62132808 <-- I'm using groundhog. What I am doing wrong? I am trying to make 'title' a DefaultKey, and I suddenly get a 20 line ghc error
03:07:37 <tdammers> documentation, standards, conventions, what have your
03:09:26 <saurabhnanda> tdammers: right, but here the context is different. The DB and the application code are NOT loosely coupled.
03:10:00 <saurabhnanda> tdammers: which might be the case with web-services across the public internet. It actually might not be the case with web-services within the same enterprise. I'm not sure if most micro-services are really losely coupled.
03:10:20 <saurabhnanda> anyways, back to my original Reader & ReaderT voyage.
03:11:12 <selckin> code generation part of soap is very valuable imo
03:13:03 <saurabhnanda> does the following type signature mean this: "this function/value needs to be evaluated inside a Reader/ReaderT monad, which wraps a 'backend' monad, which is somehow linked with the 'val' being fetched, which wraps over a an IO-type monad, which will wrap over the Key of the val that has just been inserted' // insert :: (MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => val -> ReaderT backend m (Key val)
03:13:33 <saurabhnanda> what does 'backend ~ PersistEntityBackend' val mean? what's the tilde (~) for?
03:13:54 <puregreen> tilde is type equality
03:14:13 <puregreen> and PersistEntityBackend' is probably a type family (i.e. a type function)
03:16:12 <saurabhnanda> so, the function signature basically follows this patterns: a -> m b, and can be "executed" using the >>= operator like so: m a -> (a -> n b) -> m b. Which means 'm a' needs to be what type? ReaderT ____ (what)?
03:17:02 <saurabhnanda> myId <- (xx >>= (insert myObj))
03:17:15 <saurabhnanda> what should be the type of 'xx' and what will be the type of myId?
03:17:43 <pavonia> xx :: ReaderT backend m val
03:17:54 <pavonia> myId :: Key val
03:18:08 <pavonia> (plus the contraints)
03:18:45 <pavonia> No wait, what is myObj?
03:18:53 <saurabhnanda> hang, de-sugaring that: (xx >>= (insert myObj)) >>= (\myId -> putStrLn $ show myId)
03:19:22 <pavonia> You can't use insert after >>= if you already give it an argument
03:20:31 <saurabhnanda> pacak: myObj could be say 'Person "Jane Doe" 35' (an object which is set-up to be ORM-enabled, however Persistent library defines it)
03:20:47 <pacak> o_o
03:21:23 <saurabhnanda> "You can't use insert after >>= if you already give it an argument" -- didn't understand
03:21:23 <pavonia> saurabhnanda: Then you need to use \val -> insert myObj
03:21:25 <pacak> saurabhnanda: (ಠ_ಠ)
03:22:20 <pavonia> Look at the type of (>>=), it takes a function with one argument yielding a monadic action
03:22:38 <pavonia> If you use insert with an argument, you don't have a function anymore
03:22:41 <saurabhnanda> :t (>>=)
03:22:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:23:30 <saurabhnanda> pavonia: right. So if I do (insert myObj) the type becomes only (m b) NOT (a -> m b). Got that. in that case, how do I run 'insert' WITHOUT any do-sugared syntax
03:24:03 <silky-nvds> 
03:24:04 <pavonia> What does that mean?
03:24:49 <pavonia> The code above isn't do-syntax
03:25:50 <saurabhnanda> pavonia: yes, it's not. I'm trying to understand how 'insert' is working WITHOUT using the do-syntax. Without simply copy-pasted the persistent tutorials. I want to understand exactly how the underlying functions and types are being composed.
03:26:10 <saurabhnanda> pavonia: but the code that I suggested // (xx >>= (insert myObj)) >>= (\myId -> putStrLn $ show myId) // is clearly wrong. 
03:26:24 <saurabhnanda> *copy-pasting
03:28:41 <pavonia> saurabhnanda: You have to put a function as the second parameter of >>=, so "xx >>= \val -> insert myObj >>= ..." would do
03:29:32 <saurabhnanda> pavonia: is that correct? Shouldn't I be doing something with the 'val', else what's the use?
03:29:47 <hpc> not always
03:29:55 <hpc> if you never use val, it's like using (>>)
03:30:00 <pavonia> That depends on what xx exactly is
03:30:23 <saurabhnanda> hpc: but it doesn't feel like that's the case here. The function needs some external context to run via a ReaderT (it's the DB connection).
03:30:44 <hpc> saurabhnanda: and that gets carried over by (>>=)
03:30:53 <hpc> it's in that definition so you don't have to
03:32:04 <hpc> so like
03:32:23 <saurabhnanda> in this // xx >>= \foo -> insert myObj // what would the type of foo be? What's the best way to inspect its type?
03:32:28 <hpc> at a very rough level of detail, xx = (val :: X, db :: Connection)
03:33:12 <hpc> or rather, xx = \db -> val
03:33:51 <saurabhnanda> so, does this sound right? // (xx >>= (\_ -> insert myObj)) >>= (\myId -> putStrLn $ show myId)
03:34:04 <hpc> yes
03:34:12 <saurabhnanda> ^^ in that, what "monad" would the second lambda be running inside?
03:34:26 <saurabhnanda> 'backend m (Key val)' OR 'm (Key val)'
03:34:28 <hpc> er, ish
03:34:53 <pavonia> They are all running in IO in that example
03:35:25 <hpc> if you're wanting to run the whole thing in some ReaderT IO thingy, the end needs to be
03:35:27 <saurabhnanda> pavonia: that's the innermost monad right? Aren't they running inside a bunch of monad transformers?
03:35:35 <hpc> \myId -> liftIO (print myId)
03:35:43 <hpc> print = putStrLn . show
03:35:55 <pavonia> saurabhnanda: The monad is the same for the whol chain of >>='s
03:35:57 <saurabhnanda> hpc: ah okay, didn't know about 'print'
03:36:32 <saurabhnanda> actually shouldn't it be 'penetrateIO' and not 'liftIO'? because IO is the innermost monad, right?
03:36:41 <hpc> :t liftIO
03:36:42 <lambdabot> MonadIO m => IO a -> m a
03:37:19 <saurabhnanda> that was just a comment about naming. 'lift' makes it sound like it's going outside/up. penetrate makes it sound like it's going to the innermost onion ring.
03:37:31 <opqdonut> it's a matter of perspective
03:37:33 <hpc> it is going up
03:37:38 <hpc> from the right perspective, yeah
03:37:44 <opqdonut> you're taking a "IO a" and you're lifting it to the more general type
03:37:50 <hpc> liftIO takes an action of the inner type and makes it the outer type
03:38:20 <saurabhnanda> opqdonut:  hpc: okay, if you think about it that way, liftIO makes sense.
03:38:30 <saurabhnanda> hang on
03:38:41 <saurabhnanda> so shouldn't that be (liftIO print) myId?
03:38:57 <parsecChar> anyone here using groundhog?
03:38:57 <merijn> saurabhnanda: No, because print is a function, not an IO value
03:39:03 <saurabhnanda> if 'liftIO (print myId)' was possible, then I'm not sure it's really required in the first place.
03:39:03 <parsecChar> how do I make my primary key a Text, instead of an auto created Int ?
03:39:04 <merijn> :t print
03:39:05 <lambdabot> Show a => a -> IO ()
03:39:14 <merijn> :t print "foo"
03:39:15 <lambdabot> IO ()
03:39:18 <merijn> :t liftIO
03:39:19 <lambdabot> MonadIO m => IO a -> m a
03:39:39 <saurabhnanda> hang on
03:39:47 <saurabhnanda> let me try a bunch of these things on my ghci and come back
03:39:47 <hpc> saurabhnanda: (print myId) doesn't print it right away
03:39:50 <saurabhnanda> I'm getting lost again
03:39:56 <hpc> :t print "some value"
03:39:57 <lambdabot> IO ()
03:40:18 <hpc> it's a tiny lump of valueness that represents "print out the thing"
03:40:31 <hpc> when you liftIO it into something else
03:40:40 <saurabhnanda> hpc: okay, I just don't get this, it's a value, not a function, concept. I thought (print myId) would print it rightaway.
03:41:06 <hpc> that represents a slightly larger lump of valueness that says "print this out and also do some other light bookkeepping"
03:41:26 <merijn> saurabhnanda: "print myId" evaluates to an IO action that, when executed, prints myId
03:41:30 <saurabhnanda> hpc: but would (liftIO print) myId be right
03:41:33 <merijn> saurabhnanda: Try running the following in ghci
03:41:36 <saurabhnanda> or would the compiler refuse to accept that
03:41:40 <hpc> :t liftIO
03:41:41 <lambdabot> MonadIO m => IO a -> m a
03:41:41 <hpc> :t print
03:41:42 <lambdabot> Show a => a -> IO ()
03:41:44 <merijn> "map print [1..10] !! 3"
03:41:55 <hpc> the root element of print's type is (->)
03:42:02 <hpc> the root element of liftIO's parameter's type is IO
03:42:06 <hpc> they are incompatible
03:42:23 <saurabhnanda> shouldn't the type-sig for liftIO be: IO a -> m (IO a) ?
03:42:41 <hpc> it works just fine like this
03:42:52 <merijn> saurabhnanda: No, that's something else entirely
03:42:53 <hpc> for ReaderT, there's an instance MonadIO (ReaderT IO s)
03:43:11 <pavonia> parsecChar: Looks like you need an instance of PersistentEntity with AutoKey = Text
03:43:24 <hpc> ReaderT IO s :: * -> * (if you want to get into kinds later, but it's probably too much for right now)
03:43:42 <hpc> ^ in that case it takes IO as a type parameter
03:43:49 <parsecChar> pavonia: can I PM you? I think it'll take a bit longer to explain what I need to do
03:43:51 <hpc> but there's other cases where the IO is built in and non-optional
03:44:01 <saurabhnanda> okay, let me try to run 'insert' "manually", without copy-pasting from the tutorial
03:44:02 <hpc> like acid-state's database query types
03:44:05 <saurabhnanda> brb
03:44:05 <parsecChar> pavonia: in fact ,can you tell me how to change  https://gist.github.com/anonymous/43d6f19c3aaa62132808 ?
03:44:09 <hpc> actually not those
03:44:21 <hpc> like... template haskell :(
03:44:27 <pavonia> parsecChar: You can, but note that I'm not familiar with groundhog at all
03:44:29 * hpc needs to find a better example lol
03:45:58 <pavonia> parsecChar: What is the difference between the first and the second definition?
03:46:33 <parsecChar> pavonia: there is a typo, the second should say: "title :: DefaultKey Text"
03:46:46 <parsecChar> in the first one, it creates a table with 3 columns, an extra column = auto incrementing int ID field
03:46:52 <parsecChar> however, I want to use the Title :: Text as my primary key
03:47:03 <parsecChar> which I try do via "title :: DefaultKey Text" ... and then get all types of errors in result
03:49:52 <pavonia> parsecChar: Is mkPersist supposed to define a PersistField instance?
03:50:18 <parsecChar> pavonia: I acutally don't know. I started reading https://www.schoolofhaskell.com/user/lykahb/groundhog 24 hrs ago
03:50:56 <pavonia> So the problem is you can only use DefaultKey on types that have such an instance
03:51:01 <lyxia> parsecChar: what's the definition of defaultkey
03:51:24 <parsecChar> lyxia: https://hackage.haskell.org/package/groundhog-0.7.0.3/docs/Database-Groundhog-Core.html#t:DefaultKey
03:51:24 <pavonia> parsecChar: Either you define one yourself or you find a way to derive one
04:06:01 <parsecChar> in case anyone else was wondering, this is how you create a primaryKey in groundhog
04:06:07 <parsecChar> https://gist.github.com/9536d4c492007a666f66
04:08:09 <saurabhnanda> parsecChar: is groundhound related to persistent or yesod. data-types look similar.
04:10:45 <saurabhnanda> (newbie question) how do I load an entire app into the ghci?
04:10:45 <parsecChar> it's groundhog, not groundhound, and I don't know if it's related to yesod
04:10:54 <saurabhnanda> app=multiple files with multiple modules?
04:12:04 <bergmark> saurabhnanda: with a cabal sandbox do `cabal repl', with stack do `stack ghci'
04:12:05 <pavonia> saurabhnanda: There's usually a Main module which imports all the other relevant modules, load this one
04:12:17 <saurabhnanda> bergmark: pavonia: thanks
04:13:12 <saurabhnanda> (another newbie question) quickest way to get now() in UTCTime?
04:13:35 <bergmark> getCurrentTime
04:15:35 <saurabhnanda> Couldn't match expected type ‘UTCTime’ with actual type ‘IO UTCTime’
04:15:38 <mpickering> Is there some general guidance about using superclass constraints?
04:15:53 <saurabhnanda> so my record-type expected UTCTime and getCurrentTime gives me IO UTCTime
04:15:58 <saurabhnanda> *expects
04:16:11 <bartavelle> saurabhnanda, given that subsequent calls to getCurrenTime should return distinct values, this is not a "pure" function
04:16:16 <mpickering> ie, if you define a class such as `class A p => B p where ...` should you be able to implement the methods of `A` with the methods of `B`
04:16:31 <lpaste> wahrsagevogel pasted “Equality on GADTs” at http://lpaste.net/153866
04:16:41 <bartavelle> the IO type hints at the fact that there are side effects, and you can only use this function in other that also has "IO" in its type
04:16:53 <bartavelle> (or a MonadIO constraint)
04:16:53 <lyxia> mpickering: that's not necessary
04:17:27 <mpickering> lyxia: I know in the sense that ghc won't enforce such a relationship
04:17:36 <mpickering> is that what you mean?
04:18:08 <wahrsagevogel> hey, I am playing around with this code here http://lpaste.net/153866 and the equality instance is not working because it doesn't hold because of  forall 
04:18:13 <lyxia> mpickering: For instance, Monoid should be a Semigroup (there are plans to do that I think, or at least many people would like it that way), and it would only need a mempty class method.
04:18:20 <saurabhnanda> okay, this is getting irritating but
04:18:37 <saurabhnanda> i wanted to try the 'insert' function and need to unwrap another layer of complexity now
04:18:44 <cocreature> mpickering: removing return from Monad (not sure if that’s still planned, I lost track of it) would be another example where you can’t do that
04:18:46 <lyxia> mpickering: and you can also define Group on top of Monoid, with only an inverse method.
04:18:58 <lyxia> oh yeah
04:19:26 <bartavelle> saurabhnanda, OTOH, if you want to insert now() in SQL parlance, then you just need to write NOW() in your SQL query, right ?
04:19:47 <cocreature> as long as there is some relationship (preferably in the form of laws) you should probably use a superclass
04:19:58 <saurabhnanda> bartavelle: I'm doing it through the Persistent library, so have to do it through the Haskell API it exposes
04:20:04 <pavonia> wahrsagevogel: Is that link still working for you?
04:20:11 <mpickering> yes that is useful thanks
04:20:20 <wahrsagevogel> pavonia: yes
04:20:42 <pavonia> Hhm, works now :S
04:21:04 <saurabhnanda> why isn't this working? // :t (getCurrentTime >>= (\time -> User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time))
04:21:28 <bartavelle> User .... is of type user
04:21:28 <saurabhnanda> need to use return
04:21:32 <bartavelle> yep
04:21:44 <saurabhnanda> works now
04:22:00 <saurabhnanda> now it gets more complex
04:22:17 <saurabhnanda> I have a value of type (IO User) and need to pass it to the 'insert' function
04:22:45 <bartavelle> saurabhnanda, what's the type of the function calling the insert function ?
04:22:53 <bartavelle> or are you trying to write insert directly in ghci ?
04:23:05 <saurabhnanda> bartavelle: nothing. I'm trying to do ':t insert $ blah' on the repl
04:23:12 <bartavelle> alright
04:23:18 <lyxia> >>= return ... is just fmap BTW
04:23:20 <bartavelle> as you can see here : https://hackage.haskell.org/package/persistent-2.2.4/docs/Database-Persist-Class.html#v:insert
04:23:29 <bartavelle> there is a MonadIO constraint
04:23:34 <bartavelle> which means you can do something like
04:23:56 <bartavelle> liftIO getCurrentTime >>= \time -> insert (User (Just "dqsqsdqsd") "qsdqsd" time time)
04:24:51 <deko-pyon> Out of curiosity, is unboxed data in Haskell somehow “less lazy” than boxed data?
04:25:07 <bartavelle> deko-pyon, yes
04:25:16 <deko-pyon> Makes sense, thanks!
04:25:32 <saurabhnanda> bartavelle: what's liftIO doing there?
04:25:49 <bartavelle> it transforms a function of type "IO a" into "m a", where "m" is the monad you are working in
04:26:00 <bartavelle> only if there is a "MonadIO m" constraint
04:26:17 <saurabhnanda> :t (getCurrentTime >>= (\time -> insert $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time))
04:26:18 <lambdabot> Not in scope: ‘getCurrentTime’
04:26:18 <lambdabot> Not in scope: data constructor ‘User’
04:26:45 <saurabhnanda> Couldn't match type ‘Control.Monad.Trans.Reader.ReaderT SqlBackend m0’ with ‘IO’
04:26:54 <bartavelle> yeah, that's why you need liftIO
04:27:09 <bartavelle> try
04:27:16 <bartavelle> :t liftIO getCurrentTime
04:27:17 <lambdabot> Not in scope: ‘getCurrentTime’
04:27:37 <saurabhnanda> :t (liftIO getCurrentTime)
04:27:39 <lambdabot> Not in scope: ‘getCurrentTime’
04:27:47 <saurabhnanda> (liftIO getCurrentTime) :: Control.Monad.IO.Class.MonadIO m => m UTCTime
04:28:22 <saurabhnanda> that still shouldn't work, right?
04:28:37 <saurabhnanda> MonadIO is the innermost monad in the type-sig of insert?
04:28:44 <bartavelle> true!
04:28:47 <saurabhnanda> I need something that can give me a ReaderT
04:28:53 <bartavelle> but look at ReaderT https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#t:ReaderT
04:29:11 <bartavelle> it says that "MonadIO m => MonadIO (ReaderT r m)"
04:29:27 <saurabhnanda> ah ReaderT itself is a MonadIO
04:29:34 <bartavelle> only if the underlying monad is
04:29:54 <bartavelle> that will be the case of most monad transformers
04:30:02 <saurabhnanda> it BEHAVES as a MonadIO if the underlying monad is a MonadIO
04:30:15 <saurabhnanda> wow, who even thought of all this complexity
04:30:23 <tdammers> it actually *is* a MonadIO if the underlying monad is
04:30:34 <bartavelle> what tdammers said
04:30:57 <bartavelle> yeah learning about monad transformers seems overkill when you just want to insert something in the damn database
04:31:17 <tdammers> ReaderT is almost superfluous anyway
04:31:21 <saurabhnanda> :t ((liftIO . getCurrentTime) >>= (\time -> return $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time))
04:31:23 <lambdabot> Not in scope: ‘getCurrentTime’
04:31:23 <lambdabot> Not in scope: data constructor ‘User’
04:31:36 <saurabhnanda>     Couldn't match type ‘m0 a0’ with ‘UTCTime’
04:31:36 <saurabhnanda>     Expected type: a -> UTCTime
04:31:36 <saurabhnanda>       Actual type: a -> m0 a0
04:31:38 <saurabhnanda>     In the first argument of ‘(>>=)’, namely
04:31:40 <saurabhnanda>       ‘(liftIO . getCurrentTime)’
04:31:42 <saurabhnanda>     In the expression:
04:31:44 <saurabhnanda>       ((liftIO . getCurrentTime)
04:31:44 <bartavelle> getCurrentTime doesn't take an argument
04:31:46 <saurabhnanda>        >>=
04:31:48 <saurabhnanda>          (\ time
04:31:50 <saurabhnanda>             -> return
04:31:52 <bartavelle> it's "liftIO getCurrentTime"
04:31:52 <saurabhnanda>                $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time))
04:31:56 <saurabhnanda> oh, IRC doesn't support multi-line pastes. Sorry abotu that.
04:32:00 <bartavelle> also you shouldn't paste multi line error messages :/
04:32:10 <tdammers> you want liftIO getCurrentTime, not liftIO . getCurrentTime
04:32:10 <saurabhnanda> wow
04:32:24 <saurabhnanda> I don't understand what that '.' does in the middle. Aparranently not what I think
04:32:31 <tdammers> . is function composition
04:32:32 <bernalex> :t (.)
04:32:33 <tdammers> :t (.)
04:32:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:32:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:32:43 <bernalex> @src (.)
04:32:43 <lambdabot> (f . g) x = f (g x)
04:33:01 <bartavelle> :t (liftIO . undefined)
04:33:02 <lambdabot> MonadIO m => a -> m a1
04:33:11 <merijn> I generally prefer explaining it as "f . g = \x -> f (g x)", no magic third parameter
04:33:12 <tdammers> the type signature tells you that for liftIO . getCurrentTime to typecheck, both these functions need to have a signature that matches (a -> b)
04:33:13 <bernalex> > ((+1) . (+2)) 3 == ((+1) (+2) 3)
04:33:14 <saurabhnanda> so, basically does that mean you can't compose functions that don't take any value?
04:33:14 <lambdabot>      No instance for (Num a0) arising from a use of ‘+’
04:33:15 <lambdabot>      The type variable ‘a0’ is ambiguous
04:33:15 <lambdabot>      Note: there are several potential instances:
04:33:21 <saurabhnanda> compose with '.'
04:33:23 <merijn> saurabhnanda: There's no such thing
04:33:31 <merijn> saurabhnanda: Functions ALWAYS take an argument
04:33:36 <bernalex> > ((+1) . (+2)) 3 == ((+1) ((+2) 3)) 
04:33:37 <lambdabot>  True
04:33:38 <tdammers> "functions that don't take any value" are called "values"
04:34:18 <bernalex> saurabhnanda: a function is a mapping from a domain to a range. a -> b is a function that when applied to a value :: a, returns a value :: b.
04:34:22 <merijn> Functions that take values are also called values, so that's a bit odd to say
04:34:29 <saurabhnanda> :t ((liftIO getCurrentTime) >>= (\time -> return $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time)) :: Control.Monad.IO.Class.MonadIO m => m User
04:34:30 <lambdabot> Not in scope: ‘getCurrentTime’
04:34:31 <lambdabot> Not in scope: data constructor ‘User’
04:34:31 <lambdabot> Not in scope: type constructor or class ‘User’
04:34:59 <saurabhnanda> that's strange. where did ReaderT go?
04:35:00 <tdammers> merijn: true
04:35:38 <tdammers> saurabhnanda: GHC's type inference always tries to find the most general type that meets the constraints
04:35:51 <saurabhnanda> shouldn't the type of that expression be ReaderT backend IO (Key User)
04:35:57 <Grisha> hi everyone, I need your help again: I am parsing a binary format using the Get parser from Data.Binary and need to jump at a random place in my file/ByteString and back again
04:35:59 <tdammers> saurabhnanda: in this case, you haven't used anything that suggests ReaderT, so GHC doesn't infer it
04:36:07 <Grisha> is there an idiomatic solution for that?
04:36:24 <tdammers> saurabhnanda: your code, as written, will work for *any* instance of MonadIO
04:36:34 <tdammers> saurabhnanda: not just ReaderT backend IO
04:36:38 <bartavelle> Grisha, no, basically binary isn't meant for that
04:36:57 <saurabhnanda> tdammers: but I'm sure the Persistent library has a type-signature on top of the 'insert' function. That will give all these constraints to the Haskell type-inference engine.
04:37:13 <bartavelle> saurabhnanda, but you didn't use insert here
04:37:24 <saurabhnanda> ah okay
04:37:31 <tdammers> saurabhnanda: yes. as soon as you throw in anything that requires a less general type, the inferred type will change
04:37:36 <Grisha> bartavelle, that's exactly my problem, since I use binary to read out everything else from the file
04:37:44 <tdammers> saurabhnanda: alternatively, you can insert type hints in strategic places to narrow down the type
04:38:09 <tdammers> saurabhnanda: e.g., if you hint any of the actions in that expression as :: ReaderT backend IO, then the whole expression will follow suit
04:38:11 <bartavelle> Grisha, you'll need to load it as a bytestring and slice it, but you might use binary to read each small part
04:38:25 <saurabhnanda> ((liftIO getCurrentTime) >>= (\time -> return $ insert $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time)) :: (Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO m1) => m (Control.Monad.Trans.Reader.ReaderT SqlBackend m1 (Key User))
04:38:25 <Grisha> bartavelle, I'm fine with Get for reading the file header and some meta-information, but to read out data blocks, I need to jump at a specific offset
04:38:52 <bartavelle> Grisha, yeah, and you can't really use binary for that *if* you need to go back
04:38:59 <bartavelle> you can "drop" data with binary
04:39:00 <fractalsea> Is there any way of getting information about which STM transaction is blocked indefinitely? Something that I can use in production (i.e. no profiling)
04:39:05 <saurabhnanda> why is the whole value wrapped in yet another monad?
04:39:25 <bartavelle> :t insert undefined
04:39:26 <lambdabot> Ord a => [a] -> [a]
04:39:29 <bartavelle> oh :)
04:39:35 <Grisha> bartavelle, I was thinking about passing the original ByteString around, but not sure whether I understand it to the extent I could add this functionality to Get
04:39:48 <bartavelle> saurabhnanda, short answer, you shouldn't use return. Long answer, look up the type of insert
04:40:20 <bartavelle> Grisha, why not just parse the headers with binary, then run other parsers on the original bytestring to parse each block?
04:40:38 <saurabhnanda> ((liftIO getCurrentTime) >>= (\time -> insert $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time)) :: Control.Monad.IO.Class.MonadIO m => Control.Monad.Trans.Reader.ReaderT SqlBackend m (Key User)
04:40:54 <saurabhnanda> bartavelle: tdammers: merijn: thanks for helping me get this far
04:41:21 <merijn> saurabhnanda: I think the best way to understand monad transformers is to start with a non-transformer and implement the transformer version yourself
04:41:39 <Grisha> bartavelle, great idea - to read out first all offsets and then slurp in the data chunks
04:41:46 <merijn> And since I say that god knows how many times, I've already got the exercise written out for you: https://gist.github.com/merijn/098106abd45c940dab09 ;)
04:41:54 <bartavelle> Grisha, I don't think you can do it a lot more efficiently than that :/
04:42:00 <saurabhnanda> backend :: SqlBackend. Wonder what other backends are there in Persisten?
04:42:13 <Grisha> bartavelle, thanks a lot for the idea
04:43:05 <bartavelle> saurabhnanda, only one is the base package : https://hackage.haskell.org/package/persistent-2.2.4/docs/Database-Persist-Class.html#t:HasPersistBackend
04:55:05 <saurabhnanda> bartavelle: check out the constructor for SqlBackend. It seems like every DB will instantiate a different SqlBackend. Sqlite. PG. etc
05:02:43 <saurabhnanda> now, finally 'Control.Monad.Trans.Reader.ReaderT SqlBackend m (Key User)' means that I have a value that needs to be evaluated inside a ReaderT context. The ReaderT encapsulates an environment of type SqlBackend and ______ what does 'm (Key User)' mean?
05:03:19 <merijn> saurabhnanda: Both 'm' and '(Key User)' are arguments to ReaderT
05:04:10 <saurabhnanda> merijn: how do I explain this type to myself in plain English?
05:04:17 <saurabhnanda> merijn: or as "plain" as it can be
05:04:54 * hackagebot ansi-pretty 0.1.2.0 - AnsiPretty for ansi-wl-pprint  https://hackage.haskell.org/package/ansi-pretty-0.1.2.0 (phadej)
05:05:29 <merijn> saurabhnanda: Lets start with a simpler type that is, in some sense similar
05:05:41 <merijn> "data Foo f a = MkFoo (f a)"
05:06:06 <merijn> This defines 1) a type constructor Foo, that takes two arguments and 2) a value constructor that takes one argument
05:06:55 <merijn> Foo is a "higher-kinded" type constructor. "Normally" (for some value of normal) type constructors take types of kind * as argument, like generic in Java do. But in Haskell we are not restricted to this
05:07:45 <merijn> saurabhnanda: For example "Maybe :: * -> *", i.e. it takes a type of kind * and returns a new type of kind *. In constrast "Foo :: (* -> *) -> * -> *" that, is Foo, takes a type of kind "* -> *" as argument and one of type *
05:07:48 <saurabhnanda> merijn: ok
05:08:15 <merijn> saurabhnanda: So a valid use of Foo might be "Foo Maybe Int"
05:08:43 <merijn> Since MkFoo has type "MkFoo :: f a -> Foo f a" this would result in MkFoo wanting a "Maybe Int" argument
05:09:17 <saurabhnanda> merijn: ok
05:09:40 <merijn> saurabhnanda: Similarly, "data ReaderT r m a = ReaderT { runReaderT :: r -> m a }" (in reality it's a newtype, but that's not very relevant)
05:09:48 <merijn> :k ReaderT
05:09:49 <lambdabot> * -> (* -> *) -> * -> *
05:10:29 <merijn> saurabhnanda: So ReaderT takes 3 arguments: 1) a type of kind * (the reader state), 2) a type of kind "* -> *" (i.e., the monad we're transforming) and 3) a type of kind * (the result type)
05:11:02 <merijn> So if we take your definition and rip out the definition of ReaderT we'd get: "SqlBackend -> m (Key User)"
05:11:10 <saurabhnanda> :k Monad
05:11:11 <lambdabot> (* -> *) -> Constraint
05:11:54 <saurabhnanda> merijn: or will it be SqlBackend -> m -> (Key User)
05:12:15 <saurabhnanda> 'm' is the Monad being transformed by the ReaderT
05:12:17 <merijn> saurabhnanda: Monad instances always have kind "* -> *" (just like Functors) because else the types make no sense, consider: "class Functor f where fmap :: (a -> b) -> f a -> f b" <- f always gets a type as argument there, so must have kind "* -> *"
05:12:36 <merijn> saurabhnanda: Look to my data definition of "ReaderT" a few lines back
05:12:54 <tdammers> note the similarity in notation between * -> * and a -> b
05:12:55 <saurabhnanda> "So ReaderT takes 3 arguments: ...." ?
05:13:00 <tdammers> it's not a coincidence
05:13:14 <merijn> "SqlBackend -> m -> (Key User)" doesn't match that definition, and is also impossible, because 'm' has kind "* -> *" (and functions can't have arguments with types other than *)
05:13:19 <merijn> saurabhnanda: Yes
05:13:21 <asthasr> This may be a crazy question, but I'm thinking about the composability of slow operations (like remote calls) and I'm wondering if there is a standard structure for it. Let's consider a set of services, {s1, s2, s3...}. Each of the services is essentially typed a -> b, with some text transformation to build the request and parse the response.
05:13:25 <merijn> saurabhnanda: ReaderT has 3 arguments
05:14:02 <merijn> asthasr: The usual way of composing slow calls would be to basically treat them as blocking IO (via something like the async library) and use one thread per chain of calls
05:14:05 <asthasr> is there some monoidal structure or something like that which would make it possible to compose all the calls to s1, s2, s3... into one object that has "a" a priori
05:14:21 <saurabhnanda> merijn: 3 args. which is why I'm saying SqlBackend is the Reader context / 'm' is the monad being transformed / and (Key User) is the resultant value. Is that incorrect?
05:14:22 <tdammers> a -> b is a function that takes a value of type a and returns a value of type b; * -> * is a function that takes a type of kind * and returns a type of kind *
05:14:39 <merijn> saurabhnanda: That's right
05:14:49 <saurabhnanda> asthasr: you may want to look at Haxl by Facebook. They had something to do with this.
05:15:08 <merijn> asthasr: I'm 80% sure you'll find what you need in the async library, if that's too low-level look at Haxl
05:15:10 <asthasr> merijn: Understood. I'm thinking at a higher level of abstraction, where the threads are baked into the behavior of the (a -> b) call rather than being at the call site
05:15:25 <asthasr> also note that this isn't something I need, it's something I'm thinking about :p
05:16:02 <merijn> asthasr: You'll either want async for IO-like operations, or sparks for pure computation
05:16:05 <tdammers> asthasr: if you want to actually compose them in the traditional sense (i.e., (.) or (>>=)), then you will have to run them sequentially one way or another
05:17:33 <saurabhnanda> merijn: tdammers: again, what does this MEAN --> ReaderT SqlBackend m (Key User)? Here's a "thing" that needs to be evaluated inside a (Reader SqlBackend) context (which means it basically needs a DB connection and an API to talk to the DB), Along with that, I will play nice with whatever other Monad you're wrestling with, and, hey, at the end of it all, I'll give you a (Key User). Is that correct?
05:18:06 <tdammers> no, not really
05:18:30 <saurabhnanda> merijn: tdammers: does it mean I'll give you a (Key User) or does it mean I'll give you an (m (Key User))
05:18:52 <merijn> saurabhnanda: In the context of >>= it means
05:18:54 <merijn> :t (>>=)
05:18:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:19:05 <merijn> You'll get a (Key User)
05:19:22 <merijn> saurabhnanda: Note the "instance Monad m => Monad (ReaderT r m)"
05:19:41 <merijn> So "ReaderT r m a -> (a -> ReaderT r m b) -> ReaderT r m b"
05:19:54 <saurabhnanda> so, if I take (insert blah) >>= (\x -> blah2), what will be the type of 'x' ?
05:20:03 <merijn> saurabhnanda: (Key User)
05:20:15 <merijn> Assuming "insert blah :: ReaderT r m (Key User)"
05:20:23 <saurabhnanda> how will >>= know that it needs to unwrap TWO layers of monads?
05:21:02 <saurabhnanda> shouldn't the value of 'x' be 'm (Key User)'
05:21:08 <merijn> saurabhnanda: No
05:21:13 <saurabhnanda> unless I use liftIO magic
05:21:34 <merijn> saurabhnanda: And how it knows is because: "instance Monad m => Monad (ReaderT r m)" defines it to be that way
05:21:49 <merijn> saurabhnanda: I strongly recommend trying to implement StateT for yourself as I linked earlier
05:21:57 <merijn> That way things will (hopefully) make a lot more sense
05:22:00 <saurabhnanda> you mean ReaderT?
05:22:24 <saurabhnanda> merijn: but, my explanation of this type above, does not make sense?
05:23:07 <tdammers> the type itself, on its own, doesn't fully describe the semantics
05:23:28 <tdammers> it just says "parametrize ReaderT with the types SqlBackend, m, and (Key, User)
05:23:30 <tdammers> "
05:24:40 <saurabhnanda> tdammers: I understand that the type does not mean any semantics. But given this context, and how values of that type are going to be used?
05:24:50 <saurabhnanda> tdammers: in that context also, it doesn't make sense?
05:25:20 <tdammers> if you combine the type with the relevant instances and functions, you can infer more about the semantics
05:26:02 <tdammers> e.g., the MonadReader instance tells you what `ask` does for this particular type
05:26:04 <tdammers> :t ask
05:26:05 <lambdabot> MonadReader r m => m r
05:29:59 <saurabhnanda> tdammers: right. So this ReaderT value will be evaluated by a runSqlite (which will internally call runReader), etc.
05:32:47 <tdammers> think of it in terms of transforming values between domains
05:32:54 <tdammers> :t runSqlite
05:32:55 <lambdabot> Not in scope: ‘runSqlite’
05:33:40 <saurabhnanda> tdammers: 'it' being?
05:33:51 <tdammers> everything, actually :D
05:34:03 <tdammers> :t runReaderT
05:34:05 <lambdabot> ReaderT r m a -> r -> m a
05:34:29 <tdammers> you have a ReaderT r m a, and an r; runReaderT gives you an m a
05:35:08 <tdammers> so if you substitute the types according to your example, runReaderT on a ReaderT SqlBackend IO (Key, User) and a SqlBackend gives you IO (Key, User)
05:38:13 <saurabhnanda> hmm
05:38:26 <saurabhnanda> okay let me go to the next level boss now. figuring out runSqlite
05:41:21 <saurabhnanda> but seriously, there needs to be a better way than monad transformers.
05:42:27 <bernalex> yeah it's called idris
05:43:11 <tdammers> frankly, most transformers over IO are kind of unnecessary
05:43:27 <tdammers> if you're writing ReaderT x IO a, might as well just use x -> IO a
05:43:55 <tdammers> and instead of StateT x IO a, why not IORef x -> IO a, or MVar x -> IO a, or TVar x -> IO a
05:52:39 <merijn> tdammers: I disagree, explicit passing of 'x' parameters is really cumbersome
05:52:52 <bartavelle> well, with StateT you guarantee that only this thread will access the state
05:52:56 <merijn> tdammers: And IORef/MVar introduces possible concurrency
05:53:11 <bartavelle> also what you say about ReaderT is true of Reader generally
05:55:34 <tdammers> valid points
05:56:15 <bartavelle> I don't think I ever used StateT s IO though ;)
05:57:17 <unit73e> hey
05:57:45 <unit73e> does sdl + haskell support android?
05:58:07 <dominik> hey, could anyone explain to me what the intuition of a pattern synonym's type is? I particularly don't understand the two different sets of constraints
05:58:33 <unit73e> hum wait already checked, it does
06:00:26 <unit73e> how come the commercial game magic cookies using haskell only takes 8MB? don't you need ghc to run in android?
06:01:02 <geekosaur> dominik, iirc one set of constraints is what the pattern requires; the other is what the pattern brings into scope when matched
06:01:22 <bartavelle> unit73e, why would you need ghc? AFAIK it's a plain binary
06:01:43 <unit73e> bartavelle: so you don't need any haskell library?
06:01:58 <bartavelle> well, it's like regular ghc-generated programs
06:02:59 <unit73e> yeah I don't what happens when you compile something in haskell
06:03:12 <unit73e> but not having dependencies seems great to me
06:03:24 <bartavelle> by default it creates a plain binary with all haskell libraries statically linked in it
06:03:27 <boj__> unit73e: if you are familiar with c/c++ the end result is the same, just a binary
06:03:54 <bartavelle> you can compile with -dynamic, and you'll need to have the corresponding dynamic libraries on the target system if you want to distribute the program
06:05:09 <unit73e> in practice that means I don't have to program in C at all to use SDL. I was afraid of some caveat like bigger binary.
06:05:41 <bartavelle> yes the binary will be noticeably larger with an equivalent Haskell program, compared to most other compiled languages I know of
06:05:44 <unit73e> maybe I'm too use to java bs :p
06:05:52 <dominik> geekosaur: hmm, ok.
06:05:56 <bartavelle> I routinely produce 40MB binaries :/
06:06:24 <tdammers> "just buy better servers"
06:06:39 <dominik> geekosaur: why would it make sense to list the provided constraints explicitly?
06:06:47 <unit73e> but that kind of depends right? those from magic cookies guys did it in 8MB
06:06:55 <unit73e> seems fine to me
06:07:03 <bartavelle> yes of course, a 40MB program is pulling a *lot* of dependencies
06:08:40 <unit73e> I just don't see that much :P
06:08:46 <unit73e> like C
06:08:59 <unit73e> god that phrase was all mixed up with what I was thinking
06:11:10 <unit73e> haskell seems to me like it will take much less time to create games than C if the engine is correctly designed but I guess I'll find out
06:11:30 <unit73e> or at least he potential is there
06:12:22 <unit73e> anyway thanks
06:13:44 <liste> is there something like `unscanl' ?
06:14:36 <liste> e.g. unscanl (-) [100,99,98,97,96] == [1,1,1,1,1]
06:15:32 <pavonia> Isn't that just a zipWith on xs and tail xs?
06:16:02 <bartavelle> "drop 1 xs" is safer, but yes
06:17:59 <liste> pavonia: yes, wondered if it had a name
06:18:14 <liste> and if it can be really be called unscanl
06:21:47 <pavonia> Hhm, unscanl should somehow take accumulation into account
06:25:49 <purelazy> In my code I define onePointSeven = 1.7  ... then in ghci I find it has been lifted to a Behaviour. Is there a name for what Haskell is doing here?
06:26:39 <purelazy> I guess its part of type inference
06:26:51 <dramforever> the monomorphism restriction I suppose
06:27:10 <MarcelineVQ> what is a Behaviour
06:27:32 <dramforever> if you don't want it specialized just give it a type sig like :: (Num a) => a
06:27:36 <tdammers> MarcelineVQ: one of the fundamental FRP concepts
06:27:57 <tdammers> MarcelineVQ: a signal over a continuous domain
06:28:10 <tdammers> MarcelineVQ: as opposed to a Event, which is discrete
06:28:10 <purelazy> newtype Behavior a = Behavior (([Maybe UserAction],[Time]) -> [a])
06:28:35 <liste> purelazy: you have a Num instance for it?
06:29:56 <purelazy> It not actually a problem ... its just then when I use 1.7 (or any float) in the code (instead of a name) ... its just 1.7
06:30:05 <purelazy> give it a name, and it get lifted :)
06:30:33 <dramforever> purelazy: does a type signature change anything
06:30:36 <dramforever> ?
06:31:07 <dramforever> like foo :: Num a => a; foo = 1.7
06:32:58 <purelazy> If I write onePointSeven :: Float, I get     Couldn't match expected type `Behavior Float'
06:32:59 <purelazy>                 with actual type `Float'
06:33:52 <purelazy> Like I said, its kinda cool - and unexpected  
06:33:53 <mniip> purelazy, can you paste the entire code and the entire error?
06:34:01 <dramforever> kinda makes sense, if you are using it as a Behaviour
06:34:15 <purelazy> indeed
06:34:56 <purelazy> it's like implicit types in Scala
06:35:37 <geekosaur> [02 14:32] <purelazy> If I write onePointSeven :: Float, I get     Couldn't match expected type `Behavior Float'
06:35:38 <dramforever> hmm
06:35:42 <geekosaur> that makes me think it is not promoting
06:35:50 <geekosaur> you gavce it a Float, it wanted a Behavior Float
06:35:58 <dramforever> purelazy: do check out the monomorphism restriction
06:37:16 <dramforever> wait, *lifted*, NO-O-O!! that's definitely NOT what it is!
06:38:28 <dramforever> If you think that the number is magically converted to a Behaviour, you are thinking the wrong way.
06:39:06 <dramforever> It's not about lifting. It's just like Behaviour happens to implement the decimal number syntax
06:40:08 * dramforever thought he meant that the type was monomorphized to Behaviour... so disregard all those about the monomorphism restriction
06:40:21 <dramforever> (where he = purelazy)
06:40:41 <lpaste> purelazy pasted “Hmmmm” at http://lpaste.net/153871
06:41:03 <purelazy> I did
06:41:14 <dramforever> oh that!
06:41:25 * dramforever takes back the take-back on the MR
06:41:54 <liste> purelazy: what's Fal ?
06:42:18 <purelazy> Functional Animation Language
06:42:21 <dramforever> @let data F = F String
06:42:23 <lambdabot>  Defined.
06:42:44 <dramforever> @let instance Num F where fromInteger x = F "yoho"
06:42:45 <lambdabot>  .L.hs:177:10: Warning:
06:42:46 <lambdabot>      No explicit implementation for
06:42:46 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
06:43:08 <purelazy> rec x y = shape (lift2 Rectangle x y)
06:43:16 <dramforever> > case 255 of F x -> x
06:43:18 <lambdabot>      No instance for (Num F) arising from the literal ‘255’
06:43:18 <lambdabot>      In the expression: 255
06:43:18 <lambdabot>      In the expression: case 255 of { F x -> x }
06:43:28 <dramforever> brainfart...
06:43:41 <dramforever> @undefine
06:43:41 <lambdabot> Undefined.
06:43:45 <dramforever> sorry
06:44:25 <purelazy> dramforever: I don't know about 
06:44:31 <purelazy>  monomorphism restriction
06:44:57 <dramforever> Why don't you look it up?
06:45:09 <dramforever> also, actually we have two things going on here
06:45:28 <purelazy> Computer saya, "a counter-intuitive rule in Haskell type inference"
06:45:53 <geekosaur> ok, I see it, there is a Num instance for Behavior so numeric constants get fromInteger-ed implicitly to Behavior-s, and fourPointFour is similarly being inferred as Behavior
06:46:02 <dramforever> the MR is one, Behaviour implementing "pointful" number syntax is another
06:46:46 <dramforever> geekosaur: Yes that's also what I thought. Very good description
06:47:03 <geekosaur> actually fromRational, whoops
06:47:19 <gromak> Given two lenses `Getter s a` and `Getter s b` how can I have `Getter s (a, b)`?
06:47:21 <dramforever> geekosaur: While we are at it, is it the MR that fixed the type of that?
06:47:39 <geekosaur> no
06:47:41 <dramforever> *the type of the variable
06:48:01 <dramforever> arrgh
06:48:20 <dramforever> wait what is it then?
06:48:26 <geekosaur> MR would come in if it had to pick a Num instance. this is just ordinary type inference, rec takes two Behavior-s and fourPointFour is used as a parameter so its type is inferred as Behavior
06:49:27 <geekosaur> the other oddness is Num and Fractional instances for Behavior so that a numeric literal can be inferred to be of type Behavior via the implicit application of fromInteger or fromRational, respectively
06:49:46 <dramforever> oh, I thought top-level bindings are type-checked separately...
06:50:09 <mniip> gromak, does the obvious solution, 'to (\x -> (view l1 x, view l2 x))' not satisfy you?
06:52:47 <gromak> mniip, it's ok, but I'm just wondering whether there already exists such function which does it
06:54:02 <geekosaur> not typechecked separately, no. the monomorphism restriction applies to any binding without parameters which would otherwise be polymorphic. although it's hard to tell these days if you use one of the extensions that turns on MonoLocalBinds (the monomorphism restriction but applying only to let bindings)
06:54:53 <mniip> gromak, no because I don't think there's a fancy universality-preserving way to do it
06:55:42 <dramforever> @let f = 1
06:55:44 <lambdabot>  Defined.
06:55:57 <dramforever> > (f, f) :: (Int, Double)
06:55:59 <lambdabot>      Ambiguous occurrence ‘f’
06:55:59 <lambdabot>      It could refer to either ‘L.f’,
06:55:59 <lambdabot>                               defined at /tmp/mueval21139038817684930.hs:145:1
06:56:17 <geekosaur> use a longer name
06:56:26 <dramforever> > (L.f, L.f) :: (Double, Int)
06:56:27 <lambdabot>  (1.0,1)
06:56:34 <geekosaur> all the single-letter names are taken by the simple-reflect package
06:56:40 <tdammers> :t L.f
06:56:41 <lambdabot> Num a => a
06:56:51 <dramforever> yeah, I keep forgeting that :P
06:56:58 <dramforever> *forgetting
06:57:31 <mniip> you have (forall f. Phantom f => (a -> f a) -> s -> f s)) -> (forall f. Phantom f => (b -> f b) -> s -> f s) -> forall f. Phantom f => ((a, b) -> f (a, b)) -> s -> f s
06:57:33 <tdammers> hmm, weird... why does stack hang while downloading hashable-1.2.3.3?
06:57:36 <dramforever> geekosaur: So this L.f has been inferred a polymorphic type
06:58:03 <mniip> I don't see a good way to implement such a function without falling back to forcing a specific f and then generalizing back on it
06:58:12 <geekosaur> I don't know whether lambdabot has the MR turned on or not. quite possibly not, for consistency with recent versions of ghci
06:58:39 <dramforever> why is it not the case with purelazy's code
06:58:50 <mniip> > join (,) L.f :: (Double, Int)
06:58:51 <lambdabot>      Couldn't match type ‘Int’ with ‘Double’
06:58:51 <lambdabot>      Expected type: Int -> Int -> (Double, Int)
06:58:51 <lambdabot>        Actual type: Double -> Int -> (Double, Int)
06:58:55 <mniip> aw
06:58:56 <dramforever> wait, hey!
06:59:41 <dramforever> he just typed in the variable name, i.e., show-ed it
06:59:45 <geekosaur> what does purelazy's code have to do with it? MR not applying there, the type inferred for fourPointFour is monomorphic because it is used in a place that requires type Behavior
07:00:31 * dramforever is trying to understand it...
07:00:59 <geekosaur> otherwise just remember that since it is bound to a numeric literal, the compiler has implicitly rewritten the binding to (fourPointFour = fromRational (4.4 :: Rational))
07:01:23 * dramforever does not exactly understand this, but is somewhat satisfied with the explaination
07:03:31 <geekosaur> then the inferred type Behavior from its use site causes the Fractional instance of Behavior to be chosen so that fromRational will typecheck
07:04:47 <purelazy> rec :: Behavior Float -> Behavior Float -> Behavior Region
07:04:54 <purelazy> rec x y = shape (lift2 Rectangle x y)
07:04:57 <geekosaur> yep
07:05:13 <geekosaur> which is what forces fourPointFour's type to be inferred as Behavior Floart
07:05:18 <geekosaur> *Float
07:06:13 <geekosaur> and then there's `instance Num n => Num (Behavior n) where` and `instance Fractional n => Fractional (Behavior n) where` in scope
07:06:49 <dramforever> @let aa = (undefined :: Int -> Int) tt; tt = 1
07:06:51 <lambdabot>  Defined.
07:06:59 <dramforever> :t tt
07:07:00 <lambdabot> Num a => a
07:07:22 <geekosaur> so numeric literals can be used directly as Behavior n for some numeric type n with a Fractional instance, and fourPointFour not having an explicit type is inferred from use as a parameter of rec to be Behavior Float
07:07:59 <dramforever> geekosaur: But this one... it stayed polymorphic, I suppose
07:08:10 <geekosaur> no?
07:08:11 <dramforever> (I mean the aa and tt)
07:08:14 <geekosaur> oh
07:08:24 <geekosaur> yours, not purelazy;s
07:09:03 <purelazy> I'm still here BTW
07:09:13 <dramforever> Why the difference?
07:09:13 <geekosaur> I didn't dig into lambdabot to see what extensions it has turned on
07:09:24 <purelazy> Interesting 
07:09:56 <dramforever> and I sort of assumed that it was the MR
07:10:04 * dramforever goes to check
07:10:33 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1 for how numeric literals work btw
07:11:53 <dramforever> confirmed, ghci foo.hs, :t showed Int
07:12:18 <dramforever> ghci -XNoMonomorphismRestriction foo.hs, :t showed polymorphic type
07:13:13 <geekosaur> the Pristine.hs in the lambdabot repo doesn't show NoMonomorphismRestriction, sigh
07:14:57 <dramforever> so I was right?
07:18:51 <geekosaur> dramforever, I don't know. the repo doesn't always reflect the current state of the bot; you'd have to ask int-e what the bot's current State/Pristine.hs has in it, and possibly also what extensions mueval is configured to use for @run
07:38:57 <purelazy> > case 255 of F x -> x
07:38:58 <lambdabot>  Not in scope: data constructor ‘F’
07:39:59 * hackagebot xml-conduit 1.3.4 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.4 (MichaelSnoyman)
07:49:59 * hackagebot not-gloss 0.7.6.5 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.5 (GregHorn)
07:57:45 <pavonia> How do you find a free local port for inter-process communication?
07:59:39 <tdammers> trial and error
08:00:16 <tdammers> at least that's what I'm using, and it's good enough
08:01:06 <xnyhps> Binding port 0 gives you an unused one instead.
08:01:11 <purelazy> geekosaur, dramforever: Thanks for your investigation. Did you reach a conclusion, or is there a loose end based on Pristine.hs?
08:01:26 <tdammers> xnyhps: TIL :D
08:01:46 <pavonia> tdammers: So I connectTo a random port and how do I check if it is already in use?
08:02:00 <pavonia> xnyhps: Do you know if this works on Windows too?
08:02:04 <tdammers> pavonia: depends on the API, but usually they'll somehow fail or throw an exception
08:03:01 <xnyhps> pavonia: I don't know, I just know it works on Linux and OS X.
08:03:52 <pavonia> Okay
08:04:02 <tdammers> there's also: http://hackage.haskell.org/package/streaming-commons-0.1.15.1/docs/Data-Streaming-Network.html#v:bindRandomPortGen
08:04:26 <xnyhps> https://msdn.microsoft.com/en-us/library/windows/desktop/ms737550.aspx suggests it does.
08:06:38 <pavonia> "Top 10 Largest IANA unassigned port ranges with no unauthorized uses known" this could be useful :)
08:13:31 <lingxiao> hey all
08:14:29 <purelazy> geekosaur, dramforever: Sooo - In ghci, for no MR I get 4.4. For MR, I get Behaviour
08:15:07 <EvanR> im sure this has been asked before, but i still dont know if its been answered
08:17:06 <EvanR> why are storable vectors, and unboxed vectors not foldable
08:17:31 <EvanR> looking at regular vectors, i see they are now foldable, so that answers that
08:19:08 <ggVGc> I find myself going foo -> case foo of ... very often. Is there some way I could change my writing to have less situations like that?
08:19:12 <ggVGc> or some syntax extension?
08:20:04 <EvanR> er, \foo -> case foo of ... ?
08:20:12 <EvanR> theres lambdacase
08:20:16 <ggVGc> no, witin pattern matches
08:20:37 <EvanR> that... doesnt make too much sense?
08:20:55 <EvanR> put the cases of case foo of in the original case
08:21:09 <ggVGc> EvanR: I mean I often pattern match on something, and then instantly use the bound expression to match on
08:21:19 <ggVGc> which is just a repeat of the name of the capture variable
08:21:29 <ggVGc> m, ah yeah
08:21:30 <ggVGc> hah
08:21:35 <EvanR> in the case of 2 nexted cases, thats redundant
08:21:41 <EvanR> however, this happens a lot
08:21:46 <EvanR> foo <- action
08:21:48 <EvanR> case foo of
08:21:51 <EvanR> thats annoying
08:22:24 <ggVGc> yeah, maybe that's more what I mean
08:22:46 <EvanR> in which case, lambdacase may help
08:33:23 <del_> has anybody every attempted to complete the Nand2Tetris curriculum using Haskell?
08:34:24 <bollu> is it possible to issue destructor calls to free memory in a C FFI?
08:34:41 <bollu> as in, if I have an object that expects say, a delete_node(Node *) to be called
08:34:52 <bollu> how do I make sure that this is called on the Haskell side when the object is GC'd?
08:35:16 <EvanR> you can equip a finalizer
08:36:07 <bollu> EvanR: link?
08:36:09 <bollu> please?
08:36:12 <bollu> I'm sort of lost
08:36:37 <MichaelBurge> Text.Blaze defines its types in the Text.Blaze.Internal module. I don't care about the specific implementation, but I would like to use the Attribute type(I'm defining a 'classes' function that works similarly to 'class_').
08:36:45 <EvanR> bollu: https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html
08:36:46 <MichaelBurge> How dangerous is it to use types in internal modules like that?
08:37:24 <bollu> EvanR: thank you!
08:37:53 <Eduard_Munteanu> Is there a quick way to make a cereal-based append log crash-safe?
08:38:47 <bollu> are any of the tools to create C FFI's production quality?
08:38:54 <bollu> are they like, SWIG level good / standardised?
08:39:25 <Eduard_Munteanu> bollu, c2hs seems to have worked fairly well for gtk2hs, for instance.
08:40:02 <bollu> Eduard_Munteanu: hm, thank you :) I'll take a look at it
08:41:38 <MichaelBurge> Eduard_Munte: I'd probably write updates to separate files, and then later merge them. Then crashing would only lose recent updates or interrupt the merging process
08:42:19 <EvanR> every update in a separate file? o_O
08:42:31 <MichaelBurge> I mean, depending on how big these updates are.
08:42:36 <MichaelBurge> IF they're 16MB updates, sure
08:42:50 <MichaelBurge> If they're individual 4-byte records, I'd probably leave a filehandle open and append to it
08:42:51 <Eduard_Munteanu> Small, a few bytes, so it's rather awkard.
08:42:54 <EvanR> what is the problem with using 1 file
08:43:12 <EvanR> let the OS be the OS
08:43:55 <EvanR> by crash safe you mean it auto recovers? what
08:43:56 <Eduard_Munteanu> EvanR, suppose the machine crashes mid-record, then the app reopens the log in append mode and writes other records at the end.
08:44:08 <EvanR> right, ok
08:44:27 <EvanR> yeah acid state has solved this workflow sort of
08:44:29 <Eduard_Munteanu> I kinda have to scan the log to determine the proper end and discard garbage.
08:45:01 <EvanR> basically dont use cereal
08:45:13 <EvanR> or write your own recovery
08:45:20 <Eduard_Munteanu> Should I use acid-state's Log module?
08:45:46 <Eduard_Munteanu> https://hackage.haskell.org/package/acid-state-0.14.0/docs/Data-Acid-Log.html
08:45:48 <EvanR> nice i didnt know it was exposed separately ;)
08:48:39 <bollu> how do I send structs from Haskell to C?
08:48:46 <bollu> are structs as values not permitted?
08:48:52 <bollu> that'd be one hell of a performance hit if true
08:49:06 <EvanR> you use Storable
08:49:23 <EvanR> it lets you write a value, including structs to the location pointed to by a Ptr
08:49:35 <bollu> oh, cool :)
08:49:37 <bollu> thanks!
08:49:56 <Eduard_Munteanu> You want to pass pointers around rather than values anyway.
08:50:23 <EvanR> well, sometimes you really need to fill some buffer or return var
08:50:34 <EvanR> by copying
08:50:54 <EvanR> Storable also lets you peek
08:52:44 <EvanR> but yeah for "performance" you want to pass ptrs when possible
08:58:46 <freinn> Hi! I'm resolving problems in a haskell textbook, but the function groupBy is not working like I want it to work. I want to group all the Jam values by the type of fruit that they are made, but the function has no effect beyond creating a list of list with the same order than the original. Code is here http://lpaste.net/153882
08:59:42 <jle`> freinn: groupBy groups consecutive items
09:00:11 <jle`> freinn: so you probably have to sort by fruit type if you want to use it for that purpose
09:00:36 <jle`> alternatively you can use something like a Map Fruit [Int] instead
09:00:44 <jle`> and group up jars by fruits
09:02:06 <freinn> thanks jle
09:02:13 <jle`> np!
09:20:18 * hackagebot twee 0.1 - An equational theorem prover  https://hackage.haskell.org/package/twee-0.1 (NickSmallbone)
09:20:52 <catsup> >>= is to >=>   as   >> is to  ...what?  right now i'm using '>=> const f'
09:21:23 <EvanR> >=> is for functions, >> isnt so
09:21:34 <crough> catsup: you have it. >=> const fn is the equiv
09:21:54 <catsup> well, is there an operator though?  i just figured i should use it instead if so
09:22:00 <crough> catsup: no
09:22:03 <catsup> k, thanks
09:22:34 <EvanR> too many operators 
09:22:47 <catsup> EvanR: i want _all_ the operators
09:23:04 <catsup> i'm not satisfied until it looks like perl
09:26:04 <mniip> @let (>=>>) = const . (>=>)
09:26:05 <lambdabot>  Defined.
09:26:07 <mniip> \o/
09:43:32 <jle`> :t (>=>>)
09:43:33 <lambdabot> Monad m => (a -> m b1) -> b -> (b1 -> m c) -> a -> m c
09:44:44 <luite> sclv: ah thanks for pointing me to that. i'll try to answer it later today
09:48:08 <lambda-11235> If I have type Foo f a = a, and type Id a = a, is there a ghc extension that allows me to write a type Foo Id Int?
09:49:47 <puregreen> KindSignatures
09:49:57 <puregreen> it lets you write “type Foo (f :: * -> *) a = a”
09:50:12 <crough> puregreen: I think his problem is also partially applied type synonyms
09:50:25 <crough> you'll probably need LiberalTypeSynonyms
09:50:40 <puregreen> I don't know, it works for me
09:50:58 <puregreen> “:k (Foo Id)” returns “* -> *”
09:51:06 <Hrk_> I'm trying to figure out the simplest way to parse Double from String using Text.ParserCombinators.ReadP, but I'm still not satisfied with my solution. Any ideas? http://lpaste.net/153886
09:52:07 <Hrk_> I know I could just read the double. But I have a requirement, that the String representation of the double MUST contain the '.'
09:53:37 <puregreen> Hrk_: I can't think of anything better
09:54:23 <puregreen> well, apart from using gather
09:54:53 <puregreen> you can say “(s, d) <- gather readPrec” and then check whether “s” contains a dot and return “d” if it does
09:56:17 <puregreen> (okay, well, it's slightly more complicated because ReadPrec ≠ ReadP, but something can probably be done about it)
09:56:43 <puregreen> (in particular, you can use readPrec_to_P)
09:57:45 <puregreen> [also, just in case, pinging lambda-11235]
09:59:01 <nrky> hello, I am following `write your own scheme in 48 hours` and I am wondering how to print out a value in a function. How would I have to modify the function signature to allow IO? - https://dpaste.de/u0Cc 
09:59:39 <mniip> depends on what you're trying to do
09:59:51 <mniip> is this printf debugging?
10:00:05 <Cale> nrky: You generally wouldn't want to print from the middle of a Parser. If you just need it for debugging, perhaps try Debug.Trace
10:00:09 <nrky> Yes, I want to see which value will be parsed and how it will be parsed.
10:00:32 <mniip> :t Debug.Trace.traceM
10:00:33 <lambdabot> Monad m => String -> m ()
10:00:38 <mniip> :t Debug.Trace.traceShowM
10:00:40 <lambdabot> (Monad m, Show a) => a -> m ()
10:00:51 <mniip> but beware of the evaluational semantics of GHC
10:01:15 <nrky> Ugh, nice, could you give me a line of explanation of what there mean?
10:01:22 <nrky> these*
10:01:28 <mniip> printf debugging in pure code is a bit more complicated than in IO
10:02:03 <mniip> nrky, traceM displays a string as an action of some monad
10:02:24 <lambda-11235> crough: LiberalTypeSynonyms worked. Thanks.
10:02:40 <Cale> It'll just display the given String when the action is *evaluated* though, not necessarily when the action actually runs.
10:02:54 <mniip> yeah
10:03:19 <Cale> So you have to be a bit careful about what it is that you're seeing, but usually the action will be evaluated at pretty much the same time that it's about to run.
10:05:40 <mniip> might want to do () <- trace "whatever" ()
10:05:41 <mniip> instead
10:05:55 <mniip> er
10:06:04 <mniip> () <- return $ trace "whatever" ()
10:06:20 <mniip> I think that would have semantics that are a bit easier to follow
10:06:34 <jle`> () <- trace "whatever" $ return ()   might be a surer bet?
10:06:42 <nrky> import pdb; pdb.set_trace()
10:07:01 <jle`> the () might not be evaluated, but the `return ()` has to be
10:07:09 <mniip> ah rihgt
10:09:25 <jle`> but, that's actually exactly how traceM is implemented, so might as well just use traceM heh
10:09:33 <jle`> traceM "whatever"
10:10:26 <jle`> hm, i think traceM might actually not work for Identity
10:11:33 <jle`> can confirm, it doesn't work, because the monad instance is weird
10:11:43 <jle`> i wonder if it breaks semantics
10:11:53 <jle`> the Monad instance for Identity, that is
10:12:05 <mniip> is it just a bunch of coerce?
10:12:27 <jle`> iirc
10:12:48 <jle`> ah no, it's not
10:13:12 <jle`> the Applicative instance is using coerce, but the Monad instance uses runidentity explicitly, which should be the same, though
10:13:19 <jle`> i remember a discussion here about the semantics for the Identity monad being broken
10:20:08 <nrky> I can't figure out how to use trace inside the function I want to .. trace. I think I am using it pretty much like how https://en.wikibooks.org/wiki/Haskell/Debugging uses it. Any advice on how to fix the type errors?
10:20:20 <EvanR> i have been writing a helper like this
10:20:28 <EvanR> debug_ :: Show s => s -> s
10:20:38 <EvanR> debug_ x = trace ("DEBUG: "++show x) x
10:20:39 <lyxia> nrky: what are they
10:20:40 <exio4> traceShow?
10:20:46 <nrky> lyxia: they?
10:21:00 <lyxia> nrky: the errors
10:21:12 <nrky> lyxia: mismatch in type signatures
10:22:07 <lyxia> I mean if your program compiled, adding trace is like adding the identity
10:22:18 <lyxia> it shouldn't mess with the types
10:22:46 <nrky> It did compile before I added the trace and after I added it it doesn't compile.
10:22:48 <EvanR> debug :: Show s => String -> s -> s
10:23:07 <EvanR> debug label x = trace (label ++ ": " ++ show x) x
10:23:19 <lyxia> nrky: can you show us what you did
10:23:50 <nrky> Huh weird, I thought I pasted it, sorry. https://dpaste.de/r1MU
10:24:01 <nrky> EvanR: that still breaks the type signature
10:24:09 <EvanR> huh, of what
10:24:20 <nrky> Of my function.
10:24:30 <EvanR> why are you putting it in your functions type signature
10:24:59 <lyxia> nrky: did you erase the return that was there before
10:25:17 <nrky> EvanR: https://dpaste.de/skoP
10:25:51 <nrky> lyxia: yes.
10:25:51 <EvanR> nrky: try changing it to
10:26:01 <EvanR> if debug first == '\\'
10:26:07 <EvanR> debug_
10:26:12 <EvanR> whichever
10:27:01 <EvanR> even if you fix that type error, doing let _ = debug first will never print anything because it wont be evaluated
10:27:26 <EvanR> you have to put trace stuff in the line of fire
10:27:43 <lyxia> nrky: https://dpaste.de/H7QR
10:28:40 <lyxia> nrky: https://dpaste.de/O822
10:30:11 <lyxia> nrky: though to make it simpler if you only used trace, you're not supposed to erase anything, but instead wrap some expression and put trace in front of it.
10:30:11 <nrky> lyxia: Thanks a lot. It doesn't print out anything which might mean that it doesn't go into the function.
10:30:16 <siriusbtx> can I assign a case expression to a variable?
10:30:26 <siriusbtx> e.g: let test = case ... of ...
10:30:31 <jle`> yes :O
10:30:33 <lyxia> nrky: so "return somevalue" becomes "trace "DEBUG" (return somevalue)"
10:30:52 <jle`> siriusbtx: (case .. of ..) goes anywhere a normal expressino would go
10:30:56 <jle`> like 10, or True, or "hello"
10:31:10 <EvanR> and since trace "DEBUG" (return somevalue) will be very boring, except to tell if you something got evaluated at all, the helper functions
10:31:11 <jle`> so let x = case blah of blah -> blah in blah would work
10:31:14 <siriusbtx> jle`: weird I am getting an error
10:31:25 <jle`> siriusbtx: are you using it in a place where an expression would make sense?
10:31:51 <siriusbtx> http://lpaste.net/1901277074413322240
10:32:26 <jle`> siriusbtx: ah, you need to indent past the h
10:32:31 <jle`> otherwise it thinks you're starting a new definition
10:32:37 <jle`> s/definition/declaration
10:32:40 <siriusbtx> k
10:32:56 <siriusbtx> works
10:32:56 <siriusbtx> ty
10:33:00 <jle`> np
10:44:05 <Mark____1> @pl \f g x y -> f (x ++ g x) (g y)
10:44:05 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
10:45:01 <Mark____1> @pl \f x -> product [1..x]
10:45:01 <lambdabot> const (product . enumFromTo 1)
11:01:34 <Vaelatern> Hey folks. How do I tell cabal to install using a specific set of constraints, for example those listed at https://www.stackage.org/lts-5.5/cabal.config ?
11:01:41 <daedalus_> Hey, I was here the other day asking about nested lists in case anybody remembers. We concluded that what I was trying to do would probably benefit from encoding the nesting depth in the type.
11:02:14 <daedalus_> I am trying to get my head around type-level computations and I ran into a bit of a stumbling block...
11:02:37 <daedalus_> Here is what my nested list looks right now:
11:02:39 <daedalus_> http://lpaste.net/6636157606886899712
11:03:14 <daedalus_> I am trying to make it showable, but so far I haven't had any luck... :(
11:03:59 <kadoban> Vaelatern: Have you considered just using stack?
11:04:09 <Vaelatern> How though?
11:04:37 <kadoban> Vaelatern: http://docs.haskellstack.org/en/stable/README/
11:04:55 <Vaelatern> I want to install a set of files (cabal install --only-dependencies <filename>) in a sandbox (cabal sandbox init) with a set of constraints
11:04:56 <kadoban> Vaelatern: If you can't figure something out, feel free to ask, but that should get you going hopefully.
11:05:21 <kadoban> Vaelatern: Well, you can probably do that, I guess … it's pretty tedious though. Are you locked into cabal-install for some reason?
11:05:22 <Vaelatern> I'll give it a whirl
11:05:38 <Vaelatern> I am not if I can replicate the functionality
11:06:18 <daedalus_> I can successfully convert a nested list to my NList type with ":t fromValue [1,2,3] :: NList (S Z) Int" for example.
11:06:53 <daedalus_> And I can also convert it back and show it "toValue (fromValue [1,2,3] :: NList (S Z) Int)".
11:07:02 <aweinstock> daedalus_: does having seperate (Show (NList Z a)) and (Show (NList (S n) a)) instances work?
11:07:15 <daedalus_> Yes, that does work.
11:07:43 <johnw> daedalus_: what about if you enable PolyKinds?
11:08:03 <aweinstock> if that does work, then what's the question?
11:08:12 <johnw> actually, n/m, there is only one kind at work 
11:08:48 <daedalus_> @johnw: No luck with PolyKinds.. :(
11:08:48 <lambdabot> Unknown command, try @list
11:09:12 <johnw> whenever people call me @johnw, I think I've left op privileges enabled
11:09:45 <daedalus_> Hehe, wasn't thinking, habits... :)
11:10:58 <daedalus_> The error goes "Could not deduce (Convertible (NList n a)) arising from a use of `toValue' from the context (Show a) ..." btw.
11:11:32 <aweinstock> daedalus_: what's the error if you replace n with Z?
11:12:00 <aweinstock> (and add a seperate show instance for (S n))
11:12:00 <daedalus_> No, error, for specific instances it works.
11:12:57 <daedalus_> I think I already tried something like that, but I'll give it another go.
11:14:48 <daedalus_> aweinstock: Yes, so the instance for NList Z works perfectly fine, but as soon as I add NList n, it fails again.
11:15:30 <daedalus_> Also, "instance (Show [a]) => Show (NList (S Z) a) where ..." works.
11:15:42 <daedalus_> If I write them out manually they work.
11:16:40 <daedalus_> Perhaps problem is that the requirement changes from (Show a) to (Show [a]) to (Show [[a]]) depending on the level of nesting...
11:17:39 <daedalus_> But I thought if a is showable, then [a], [[a]], ... are automatically also.
11:18:42 <quchen> What's the go-to library for writing performance tests a la "algorithm A should be at least twice as fast as B"? Criterion comes to mind, should I just build on that or is there something more specific?
11:18:59 <Vaelatern> kadoban: Sadly, stack seems to be oriented towards people building their own projects. I am not, I am merely compiling another project (ganeti).
11:20:56 <daedalus_> Alternatively, maybe there is a better way of converting between built-in nested lists and my NList type (http://lpaste.net/6636157606886899712).
11:21:50 <kadoban> Vaelatern: stack can build other projects as well, it's basically the same idea.
11:23:12 <lpaste> aweinstock revised “Nested List”: “No title” at http://lpaste.net/6636157606886899712
11:23:17 <aweinstock> daedalus_: ^
11:23:33 <aweinstock> I got it working, but with UndecidableInstances
11:24:49 <bollu> how do I "take" a function pointer from C to Haskell
11:24:50 <bollu> ?
11:24:53 <bollu> a char*
11:25:02 <bollu> char* is what I want to receive into Haskell
11:25:07 <daedalus_> aweinstock: Awesome, many thanks! UndecidableInstances sounds a bit scary, though.
11:25:19 <EvanR> bollu: you might want to read through all the FFI docs
11:25:28 <daedalus_> Better read up on what it does, I guess.
11:25:28 <EvanR> questions like these are answered pretty well in there
11:25:30 <aweinstock> the error I got with (Show a => Show (NList (S n) a)) was basically that it couldn't figure out some intermediate instances on its own
11:26:12 <bollu> EvanR: ah, cool. I didn't realise that there's a centralised documentation for all this
11:26:19 <aweinstock> because it doesn't automatically know that (ValueType (NList (S n) a)) ~ a, I think
11:26:56 <EvanR> the type for function pointers is FunPtr
11:27:01 <daedalus_> aweinstock: Yes, that was my suspicion, too.
11:27:11 <EvanR> char* is just a regular Ptr CChar though
11:27:17 <daedalus_> Is there any better way of doing this?
11:27:18 <bollu> EvanR: yeah, I saw :) And for strings it's apparently CString
11:27:57 <aweinstock> UndecideableInstances was recommended by an error message about (NList (S n) a) not being guarenteed larger than (ValueType (NList n a))
11:28:19 <aweinstock> so you could get something infinite with a pathological ValueType implementation
11:28:30 <daedalus_> I read something about free functors, but but all of this higher order stuff is making my head spin a bit.
11:28:35 <EvanR> bollu: type CString = Ptr CChar
11:28:47 <aweinstock> and GHC can't prove that what's there is safe (but I think we can manually see that it is, with the present definitions)
11:29:33 <aweinstock> UndecidableInstances means that instead of using GHC's heuristics about what's finite, it just tries it for some number of iterations, and potentially bails out if it recurses too far
11:29:53 <daedalus_> Ok, well, that doesn't seem to bad.
11:29:55 <aweinstock> so it might complain if you try to do 100 layers deep of nested lists or something
11:30:04 <_dcci> Hi, what's the current status of the LLVM backend for ghc ?
11:31:22 <daedalus_> But yeah, essentially, what I am doing so far is creating a type that is in one to one correspondance with lists, but it uses datakinds to keep a count of the nesting depth.
11:31:40 <aweinstock> bollu: https://github.com/aweinstock314/haskell-stuff/blob/master/executemachinecode.hs#L31
11:31:50 <bollu> EvanR: oh, I feel dumb now >_< I assume strings are handled differently because null termination
11:31:53 <daedalus_> I am wondering if there isn't an easier way of mapping back and forth between my type and the builtin one.
11:32:34 <EvanR> bollu: well, they are. in the CString module there are helpers for working with such structures, but you access them via a Ptr CChar anyway, like C
11:32:54 <EvanR> or you can look at the CChars yourself if you feel masochistic
11:33:32 <EvanR> note that messing with all this in haskell can lead to the same security holes and segfaults as C ;)
11:33:34 <bollu> EvanR: oh thanks!
11:33:57 <bollu> EvanR: right :) I'm creating SymEngine bindings to Haskell for GSoC hopefully, so I'm doing my groundwork
11:34:16 <kadoban> Vaelatern: What is it you're trying to build? Is it public?
11:34:24 <bollu> another stupid question: how do I represent a function that takes no parameters? foo :: () -> CString does not work, but foo :: CString is clearly not the right semantics
11:34:27 <bollu> so what do I do?
11:35:04 <mnoonan> bollu: what exactly do you mean by a function that takes no parameters?
11:35:23 <bollu> mnoonan: if there's a c function: char* i_love_side_effects()
11:35:32 <bollu> what's the equivalent marshallable type in Haskell?
11:35:42 <ReinH> IO ()?
11:35:52 <ReinH> or IO CString?
11:36:01 <bollu> ReinH: ahh, I see
11:36:11 <EvanR> bollu: the same as if you would write bindings to such a thing
11:36:13 <bollu> ReinH: I didn't realize that the language extension was smart enough to handle that
11:36:14 <daedalus_> aweinstock: Well, important thing is that it works now. Thanks again, I'll keep tinkering.
11:36:15 <ReinH> If it has side effects, it can't be represented by a pure function.
11:36:20 <EvanR> so IO ()
11:36:31 <bollu> EvanR: IO CString right? since it returns a char*?
11:36:35 <EvanR> yes
11:36:43 <EvanR> IO WhateverSupportedByFFI
11:36:53 <EvanR> which is listed in the docs
11:36:55 <bollu> EvanR: thanks! 
11:37:11 <Vaelatern> https://github.com/voidlinux/void-packages/pull/3745/files 
11:37:15 <Vaelatern> kadoban: ^
11:37:48 <EvanR> "The type a will normally be a foreign type, a function type with zero or more arguments where" <- this is kind of confusing language ;)
11:37:57 <EvanR> haskell doesnt have a function type with zero arguments
11:38:05 <ReinH> Indeed.
11:38:28 <EvanR> oh theres a sequence of three things being mentioned
11:38:36 <EvanR> with only 1 comma, not 2
11:38:57 <EvanR> nope, confused
11:39:04 <EvanR> back to what i was doing
11:39:14 <bollu> I cannot believe that FFI is a language *extension*
11:39:22 <bollu> how is it not part of the haskell standard?
11:39:32 <EvanR> ghc is basically the standard
11:39:39 <bollu> also, wow, GHC is on readthedocs! http://ghc.readthedocs.org/en/latest/ffi-chap.html
11:39:39 <aweinstock> bollu: it's possible to use FFI to implement inline assembly: https://github.com/aweinstock314/haskell-stuff/blob/master/inlineasmtest.hs
11:39:58 <bollu> aweinstock: that is.. awesome
11:40:05 <mauke> bollu: https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
11:40:08 <mauke> it's in the standard
11:40:29 <bollu> mauke: ooh, I guess I was looking at an older version then which mentions it as an extension
11:40:48 <bollu> mauke: also, things that are standard may still need a language extension to be used? that's slightly confusing
11:40:59 <bollu> I thought once it was standard, it was "enabled by default" so to speak
11:41:06 <EvanR> dont be scared by extensions in haskell
11:41:23 <EvanR> they are either completely ok and should be enabled by default, or they are insane and should be ignored completely
11:41:37 <aweinstock> bollu: basically, template haskell to generate (String -> IO a) for an arbitrary a, in this case (a ~ (Int -> Int))
11:42:10 <ReinH> Well, it isn't quite that simple.
11:42:17 <ReinH> Extension interactions can be complex.
11:42:26 <ReinH> But there are commonly used extensions that are totally reasonable
11:42:41 <ReinH> FFI is one of them, and it isn't enabled by default because you don't do FFI by default.
11:43:04 <mauke> bollu: "FFI support is enabled by default, but can be enabled or disabled explicitly with the -XForeignFunctionInterface flag."
11:43:15 <mauke> it is enabled by default
11:43:15 <aweinstock> bollu: with the point being that (f :: IO (Int -> Int)) works out to be something similar to C's (int f(int))
11:43:22 <ReinH> Oh. Oops.
11:43:33 <mauke> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html
11:43:42 <ReinH> Yeah, I can't recall ever adding that pragma, come to think of it. :3
11:44:36 <Ferdiran1> Hello #haskell, I was pondering the curry-howard isomorphism and a strange idea struck me: anyone else feels like function application in lambda calculus is written backwards ?
11:44:36 <aweinstock> bollu: oops, nevermind; the code as-posted promises to ghc that the inline assembly is pure, but (declareExecuteBytes "executeImpureIntToInt" [t| Int -> IO Int |]) should do the right thing in the presence of side effects
11:45:02 <ReinH> Ferdiran1: why?
11:45:04 <bollu> huhh
11:45:10 <bollu> this is super cool
11:45:17 <bollu> Ferdiran1: what makes you say that?
11:45:52 <Ferdiran1> ReinH: because, the first expression is something that assumes some value exists, and produces something out of it, and the second expression is the missing value
11:46:23 <Ferdiran1> wouldn't it be more natural to first have an expression that builds something, and then another that can consume it ?
11:46:26 <bollu> Ferdiran1: so how do you propose it look like? (10)(\x -> x + 1) rather than (\x -> x + 1)(10) ?
11:46:36 <ReinH> Curry howard is about types, not the notation for function application.
11:46:56 <aweinstock> :t Control.Lens.(&)
11:46:57 <lambdabot>     Not in scope: data constructor ‘Control.Lens’
11:46:58 <lambdabot>     Perhaps you meant one of these:
11:46:58 <lambdabot>       variable ‘Control.Lens.op’ (imported from Control.Lens),
11:47:04 <aweinstock> :t (&)
11:47:05 <lambdabot> a -> (a -> b) -> b
11:47:09 <Ferdirand> ReinH: well I had a very brief look at coq
11:47:29 <ReinH> Curry howard has nothing to do with a particular notation for function application.
11:47:38 <Ferdirand> including writing proofs by hand instead of using tactics
11:47:54 <bollu> > let |> = (flip $) in [1, 2, 3] |> map +1
11:47:56 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
11:48:10 <bollu> > let (|>) = flip ($) in [1, 2, 3] |> map +1
11:48:11 <lambdabot>      Couldn't match type ‘[Integer]’ with ‘a -> b’
11:48:11 <lambdabot>      Expected type: [Integer] -> [a] -> [b]
11:48:11 <lambdabot>        Actual type: (a -> b) -> [a] -> [b]
11:48:16 <ReinH> CH is a correspondence between proofs (proof calculi) and type systems.
11:48:16 <joco42> is there a function with type (a-> Maybe Bool)-> [a]-> Maybe [a] already ? like filter (a->Bool)->[a]->[a] just with the added bonus that it can fail ? can i somehow "lift" filter into  (a-> Maybe Bool)-> [a]-> Maybe [a]  ?
11:48:23 <kadoban> Vaelatern: Sorry, I don't really understand what that is or which part you're trying to build :-/
11:48:24 <bollu> > let (|>) = flip ($) in [1, 2, 3] |> map (+ 1)
11:48:25 <lambdabot>  [2,3,4]
11:48:46 <ReinH> It doesn't care what particular notation you use for function application.
11:48:47 <EvanR> f(x) notation, looking for somebody to sue
11:48:47 <Ferdirand> and there function application describes a proof where you first assume something true and prove your target, then provide the proof for the missing piece
11:48:47 <Vaelatern> I am just trying to get the dependencies so I can later allow the makefile to do the actual building
11:48:51 <bollu> :t filterM
11:48:53 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
11:48:54 <ReinH> So I guess I'm not understanding your point.
11:48:54 <EvanR> probably the math teacher
11:49:04 <bollu> joco42: that works I guess for you - filterM
11:49:12 <EvanR> it should obviously be like unix pipes
11:49:16 <joco42> filterM ?
11:49:18 <EvanR> echo 10 | f | g | h
11:49:21 <joco42> really ? cool
11:49:31 <joco42> nice
11:49:32 <bollu> EvanR: hence my example with (|>). That's F#'s operator
11:49:34 <bollu> joco42: yes :)
11:49:49 <bollu> joco42: the weakened version is traverse that uses the applicative level power
11:49:50 <bollu> :t traverse
11:49:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:49:54 <bollu> wait no, ifnore that
11:50:02 <EvanR> bollu: im not supposed to be entirely convincing here ;)
11:50:05 <joco42> many thanks bollu 
11:50:08 <bollu> EvanR: :)
11:50:11 <bollu> joco42: np!
11:50:26 <EvanR> the ordering of applications and composition has become arbitrary to me
11:50:28 <bollu> joco42: if you haven't, maybe take a look at Foldable and Traversable
11:50:37 <ReinH> Let's say we have: f :: a -> a and f x = x.
11:50:41 <joco42> i am trying to do this in Idris..need to see if Idris has filterM if not, then I can extend the library...
11:50:45 <EvanR> but reversing it in one context for really no reason, except its the other way in another context is annoyin
11:51:07 <bollu> EvanR: but you gotta admit, with things like, say, group actions, one is definitely more "natural" than the other 
11:51:16 <EvanR> eh?
11:51:23 <Ferdirand> ReinH: it's just, this order for function application, in the context of using the CH equivalence to build proofs, puts the cause to the right of the consequence, so to speak, which is weird for left-to-right languages
11:51:38 <ReinH> How?
11:51:59 <bollu> EvanR: if you have a group G acting on a set S, then I'd much rather g h s =  (g * h) s rather than (h * g) s
11:52:10 <EvanR> f -> <- x... hmm not really left to right or right to left
11:52:13 <Ferdirand> i'm not saying it is wrong, just wondering how different things would have looked if we were writing it in the other order (and also maybe (x)f or whatever you prefer)
11:52:26 <bollu> Ferdirand: you do that in certain contexts
11:52:27 <EvanR> bollu: its totally abritrary ;)
11:52:40 <bollu> EvanR: yes yes, I know :) but it "feels" nicer as left-to-right. 
11:52:46 <EvanR> bollu: you should be arguing against s (g * h) anyway
11:53:28 <bollu> EvanR: oh, whoops :) weird how humans get comfortable with things like notation after a while
11:53:30 <EvanR> we prefer f x y z because were educated stupid
11:53:48 <Ferdirand> really, comparing me to the timecube guy
11:53:48 <Ferdirand> thanks
11:53:50 <emmanuel_erc> Hello there. This might be a silly question but here goes. I'm often using Haskell to write numerical programs and I use code that uses Storable vectors underneath the hood. Is it normal to see an accumulation of ARR_WORDS when profiling the code? I say this because I am still observing the expected asymptotic behavior. 
11:53:55 <EvanR> i wasnt
11:54:17 <carter_cloud> arrr words is the storable byte arreasys
11:54:19 <Ferdirand> ah, sorry for my badly tuned sarcasm detector then
11:54:19 <carter_cloud> so yes
11:54:26 <carter_cloud> storable === arr_words
11:54:29 <carter_cloud> :)
11:54:33 <bollu> Ferdirand: it's just sytax - it doesn't change the underlying semantics
11:54:37 <carter_cloud> because its heap allocated byte arrays
11:54:54 <bollu> if anything has LISP taught us, it's that it's DSL's all the way down to lambda calculus :P
11:55:26 <emmanuel_erc> Thanks carter_cloud!
11:55:56 <emmanuel_erc> So I should have nothing to worry about?
11:55:56 <EvanR> building your language based on IF made out of lambdas is gross
11:55:58 <bollu> huhh, CString has no "show" instance" bummer
11:55:59 <Ferdirand> well if using both haskell and lisp has taught me anything, it's that syntax matters for humans
11:56:13 <EvanR> bollu: its a pointer
11:56:26 <EvanR> you cant just display the data, it requires IO
11:56:30 <bollu> oh, right. I keep forgetting that it's a type alias and not a newtype
11:57:41 <emmanuel_erc> carter_cloud: I'll just assume yes for now.
11:58:14 <carter_cloud> emmanuel_erc:  i just said yes
11:59:09 <EvanR> bollu: of course you and printf %p all you want ;)
11:59:14 <EvanR> you can*
11:59:37 <bollu> EvanR: um, haskell has varargs?
11:59:42 <EvanR> well, it has printf
12:00:09 <sphinxo> Right so I've basically been using haskells typechecker as my own for my lambda calc interpreter
12:00:11 <bollu> I had no idea
12:00:14 <EvanR> > printf "%d" 3.14 :: String
12:00:16 <lambdabot>  "*Exception: printf: bad formatting char 'd'
12:00:20 <sphinxo> and the time has come to write the parser
12:00:22 <EvanR> > printf "%f" 3.14 :: String
12:00:23 <bollu> where from?
12:00:24 <lambdabot>  "3.14"
12:00:27 <sphinxo> My ast: http://pastie.org/private/95rxrj4mwegbama4emdbzw
12:00:35 <emmanuel_erc> carter_cloud: That's my bad. Thanks again!
12:00:40 <EvanR> Text.Printf
12:01:01 <bollu> "data Expr :: * -> * where" <- this is a thing? (is that a GADT?)
12:01:09 <EvanR> > printf "%f %c" 3.14 'z' :: String
12:01:11 <lambdabot>  "3.14 z"
12:01:16 <EvanR> ^ magic ;)
12:01:28 <bollu> how is that well typed
12:01:30 <EvanR> bollu: its GADT syntax, not necessarily using GADT features
12:01:32 <bollu> :t printf
12:01:33 <lambdabot> PrintfType r => String -> r
12:01:42 <bollu> very enlightening..
12:01:47 <bollu> for printf that is
12:01:54 <sphinxo> and afaik my parser would have to include the entire ast in the fn signature. 
12:01:54 <tdammers> printf is a neat trick
12:02:04 <bollu> EvanR: right, so what does doing that give you in terms of flexibility? (the GADT thing)
12:02:07 <bollu> tdammers: how does it work?
12:02:16 <sphinxo> is there anything I can do or am I basically going to have to get rid of the gadt thing
12:02:17 <EvanR> GADT syntax is just easier to read for a big type
12:02:25 <tdammers> bollu: look at the instances.
12:02:30 <EvanR> and easier to understand higher ranked constructors
12:03:00 <bollu> tdammers: all I can see is the ability to write constructors
12:03:00 <EvanR> proper GADTs let you control the exact type of the resulting data, which can be used for awesomeness
12:03:07 <bollu> oh, of printf
12:03:08 <bollu> I will
12:03:35 <bollu> EvanR: so you can basically write constructors?
12:03:46 <EvanR> you list the constructors explicitly with their types
12:04:07 <EvanR> data Foo = Foo | Bar | Baz is just shorthand
12:04:08 <tdammers> particularly this instance:  (PrintfArg a, PrintfType r) => PrintfType (a -> r)
12:04:28 <liste> bollu: with GADTS you can do somethign like "data Foo a where Bar :: Foo Int; Baz :: Foo String"
12:04:34 <bollu> tdammers: ohh fuck that's elegant
12:04:39 <tdammers> yep
12:04:46 <joco42> can this be generalized for applicatives ? https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Control.Monad.html#filterM
12:04:56 <bollu> joco42: yes, traverse
12:04:59 <bollu> :t traverse
12:05:00 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:05:15 <bollu> it's not exactly what you want, but close I guess
12:05:17 <EvanR> er, i didnt think you could filter
12:05:19 <joco42> bollu:  really ?
12:05:36 * hackagebot Cabal 1.22.8.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.22.8.0 (ryant)
12:05:36 --- mode: ChanServ set +o mauke
12:05:36 --- mode: mauke set -b *!*@172.58.17.26
12:05:36 <bollu> EvanR: oh wait right, you can't change the shape
12:05:39 <bollu> joco42: no, sorry. I'm mistaken :)
12:05:48 <EvanR> filtering doesnt fit well into the traversable worldview
12:06:08 <joco42> sort of like filterA
12:06:12 <joco42> can filterM be implemented in terms of traverse ?
12:06:27 <bollu> joco42: I don't think applicative has enough power to let you "sequence" a filter
12:06:30 <EvanR> joco42: https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
12:06:35 <joco42> hmm
12:06:45 <joco42> interesting bollu 
12:06:51 <bollu> joco42: which is why traverse either succeeds for every element or fails totally
12:07:13 <liste> @hackage witherable -- interesting typeclass for filtering things
12:07:13 <lambdabot> http://hackage.haskell.org/package/witherable -- interesting typeclass for filtering things
12:07:16 <joco42> possibly
12:07:24 <bollu> > traverse [1, 2, 4] (\x -> if x `mod` 2 == 0 then Just x else Nothing)
12:07:25 <lambdabot>      Couldn't match expected type ‘Maybe a -> f b’
12:07:26 <lambdabot>                  with actual type ‘[Integer]’
12:07:26 <lambdabot>      In the first argument of ‘traverse’, namely ‘[1, 2, 4]’
12:07:28 --- mode: mauke set -o mauke
12:07:28 <EvanR> filter is suppose to delete some of your data, but how is it suppose to know how to put the debris back together
12:07:37 <EvanR> in general
12:07:45 <bollu> > traverse (\x -> if x `mod` 2 == 0 then Just x else Nothing) [2, 4, 6]
12:07:46 <joco42> interesting
12:07:47 <lambdabot>  Just [2,4,6]
12:07:52 <bollu> > traverse (\x -> if x `mod` 2 == 0 then Just x else Nothing) [2, 4, 5]
12:07:54 <lambdabot>  Nothing
12:08:27 <joco42> the point is " how is it suppose to know how to put the debris back together" 
12:08:35 <sphinxo> Can anyone give me any hints?
12:08:50 <bollu> sphinxo: for?
12:09:04 <sphinxo> http://pastie.org/private/95rxrj4mwegbama4emdbzw 
12:09:21 <sphinxo> ^^ anyway I can parse into this ast without
12:09:27 <liste> sphinxo: are you familiar with rank-2 types
12:09:33 <EvanR> you can use data structure-specific filters though
12:10:00 <sphinxo> having the parse fn contain the entire signature
12:10:02 <EvanR> they work, but its not too clear what they have in common, like.. what are the laws
12:10:09 <sphinxo> liste: No i'm not
12:11:00 <joco42> EvanR:  interesting
12:11:15 <joco42> how about lenses? do they help?
12:11:29 <EvanR> do lenses filter?
12:11:45 <bollu> joco42: no AFAIK, though I'm no expert. They rely on the same machinery as everything else, but they give you better accessors
12:11:54 <bollu> again, that's what I know (which is very very little)
12:12:09 <joco42> ok
12:13:40 <sphinxo> liste: how could they help?
12:13:43 <joco42> but the effect can be an applicative right?
12:14:23 <joco42> (Applicative f) => (a -> f b) ->  [a] -> f [b]
12:14:51 <bollu> joco42: in which case?
12:14:55 <bollu> joco42: for filter?
12:14:59 <joco42> filter
12:15:04 <joco42> bollu: 
12:15:06 <joco42> ^
12:15:30 <bollu> joco42: try and implement it :) you'd need the power of (>>=) to actually implement that
12:15:32 <liste> sphinxo: you could have something like "parse :: (forall a. Expr a -> b) -> String -> b"
12:15:37 <bollu> joco42: first implement filter on a monad
12:15:40 <joco42> hmm
12:15:42 <bollu> then try and do it for applicative
12:15:47 <joco42> ok
12:16:06 <bollu> you'll see the problem lies in that <*> is f (a -> b) -> f a -> f b. they're all unwrappable
12:16:26 * hackagebot cabal-install 1.22.9.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.22.9.0 (ryant)
12:17:00 <joco42> ahh
12:17:06 <DaveBar> Hello, how can I use a recursive function helper? I mean if i have a function that its type is (Num => a) a->[a] and I want to use a helper that is of type (Num=>b) a->b->[b] how can I do it?
12:17:26 <joco42> yeah, see now bollu 
12:17:32 <joco42> i see now
12:17:46 <joco42> you need the result of the monad to decide what to stick into the list
12:17:55 <liste> EvanR: Witherable has laws
12:18:06 <bollu> joco42: a lot of the time, code is easier to write in "do" notation for this sort of stuff. So when you manage to write it in do notation, then trying to weaken it is fun
12:18:07 <EvanR> heh is Witherable a real thing?
12:18:12 <joco42> so the computation depends on the contents of the monad variable
12:18:13 <bollu> what's Witherable?
12:18:20 <liste> @hackage witherable -- bollu
12:18:20 <lambdabot> http://hackage.haskell.org/package/witherable -- bollu
12:18:28 <liste> it's not very popular, though
12:18:32 <EvanR> i saw that package and was like... who is this guy
12:19:02 <bollu> the fact that its laws ask for Maybe is a red flag?
12:19:16 <bollu> like, the fact that the laws refer to an explicit type? than a class of types?
12:19:20 <liste> well, wither has a Maybe in its types signature
12:19:35 <liste> it could be also scott encoded and make no difference
12:19:54 <bollu> hmm
12:19:59 <bollu> the name is catchy
12:20:07 <EvanR> wither, blight
12:20:38 <bollu> yes, very end-of-times-y
12:21:03 <bollu> I don't know what Peat is though, probably some pun that someone with english as a second language won't get
12:21:16 <bollu> I didn't know what the hell "nub" was until ekemett explained it to me once
12:21:54 <bollu> hm, how do I give the symbols that I need for my FFI to the linker in my cabal file?
12:22:08 <bollu> or do I need to write a makefile and pass compiler flags manually?
12:24:19 <bollu> omg I'm stupid, there's a ghc-options rule in the cabal file
12:25:05 <joco42> this applicative vs monad is like schrodingers cat
12:25:20 <joco42> if you have an applicative then the cat is in a superposition
12:25:31 <DaveBar> Hello, how can I use a recursive function helper? I mean if i have a function that its type is (Num => a) a->[a] and I want to use a helper that is of type (Num=>b) a->b->[b] how can I do it?
12:25:38 <joco42> if you have a monad then there was a measurement
12:25:46 <bollu> wait what, so I can just pass a .c file? "ghc -O2 -Wall -o CallBacker CallBacker.hs callerback.c"
12:26:05 <bollu> DaveBar: what exactly are you trying to accomplish?
12:26:06 <joco42> can the physics crowd here relate to this analogy ?
12:26:15 <bollu> joco42: are you a physicist?
12:26:57 <liste> DaveBar: your type signatures make no sense. do you mean (Num a) => a -> [a] and (Num b) => a -> b -> [b] ?
12:27:23 <DaveBar> bollu: I want to take a number and use the sieve of ertosthenes to find all the prime numbers < x
12:27:30 <DaveBar> and I want to get as argument only x
12:27:39 <DaveBar> so I try to do it with helper function
12:27:43 <liste> @lpaste -- DaveBar: do you have any code? pleast paste it to lpaste
12:27:43 <lambdabot> Haskell pastebin: http://lpaste.net/
12:27:44 <DaveBar> liste ofcours
12:28:04 <joco42> bollu:  yeah, originally, solid state physics, computer simulations...
12:28:27 <bollu> joco42: neat :) I've beens studying QM from Shankar for a while, and I'm enjoying it
12:28:31 <DaveBar> liste, I dont have any code but as I see it currently in my mind ill need a helper function, I will try to figure the function logic myself
12:28:42 <bollu> I think I like the functional analysis more than the actual physics itself :P
12:28:53 <bollu> bounded linear operators as so delightfully well behaved
12:29:38 <bollu> joco42: any recommendations for books / whatever?
12:29:42 <joco42> bollu:  functional analysis... tough beast
12:29:53 <DaveBar> bollu http://lpaste.net/153898
12:29:56 <DaveBar> somthing like this
12:30:22 <liste> DaveBar: remember that if you use type signatures in a let/where block, they can't share type variables with the function itself (unless you use ScopedTypeVariables)
12:30:56 <bollu> DaveBar: there's this delightful pdf about the sieve and haskell, lemme try and find it
12:31:06 <bollu> DaveBar: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
12:31:12 <bollu> read it, it's well written and fun :)
12:31:18 <DaveBar> is there any solution there? I want to figure it alone
12:31:19 <joco42> it seems filterA can be written
12:31:51 <bollu> joco42: .. what? 
12:31:55 <bollu> joco42: link?
12:31:57 <joco42> on #idris it was just pasted http://lpaste.net/153899
12:32:09 <joco42> by some clever hacker 
12:32:18 <joco42> who is not on #haskell
12:32:27 <quchen> Is there a way to generate import declarations in TH?
12:33:01 <liste> joco42: is that Idris code?
12:33:13 <joco42> liste:  yes Idris
12:35:51 <joco42> and that thing type checks in Idris, so i think it does the haskell version too
12:35:55 <mnoonan> joco42: you can always duplicate a monadic value, so I think the QM analogy is pretty lossy here
12:36:27 * hackagebot intricacy 0.6 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.6 (mbays)
12:36:27 <joco42> mnoonan:  hmm true
12:37:20 <lpaste> bollu pasted “applicative-filterA?” at http://lpaste.net/153901
12:37:31 <bollu> ^ can someone, like, proofread that?
12:37:36 <bollu> :t filterM
12:37:37 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
12:39:15 <bollu> what does ghc —make do?
12:39:37 <f-a> I am reading an article where "compositional" and "non compositional transformation" terms are used. Can anyone point me towards a definition of those terms?
12:41:26 <quchen> bollu: It makes GHC compile included modules, not just the source file you explicitly gave it. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/modes.html#make-mode
12:41:39 <bollu> also, how do I actually link to my library?
12:42:09 <quchen> bollu: Note that --make is automatically enabled: "In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified"
12:42:17 <bollu> oh, I see
12:42:24 <bollu> god damn the wiki is frustrating sometimes
12:42:44 <quchen> Not enough supply or demand to improve it :-|
12:44:00 <bollu> EvanR: can I have some help with the linker?
12:45:10 <EvanR> you supply the linker options in the cabal file somewhere
12:46:14 <bollu> EvanR: with what command line params? I can't seem to find the documentation. My google fu is failing me
12:46:34 <EvanR> -lwhatever ?
12:46:58 <bollu> oh, like, C-style linker options?
12:47:04 <bollu> didn't realize that
12:47:13 <bollu> hm, is there a -L as well?
12:47:21 <EvanR> one or more of the options passes those linker options to the linker
12:47:43 <EvanR> which i thought was the gnu linker
12:48:03 <bollu> oh, gold?
12:48:09 <EvanR> ld
12:49:08 <bollu> ah, I see. gold is faster though right?
12:49:30 <EvanR> i know not this gold you speak of
12:49:46 <bollu> https://en.wikipedia.org/wiki/Gold_(linker)
12:49:59 <geekosaur> it uses ld, which may be bfd ld or gold depending on your system
12:50:06 <geekosaur> (or something else if on os x or windows)
12:50:36 <EvanR> i would be surprised if -l and -L dont work on whatever replacement linker has appeared
12:50:38 <bollu> EvanR: so I can use -I to include the header file path?
12:50:47 <bollu> or is there some other way?
12:50:53 <EvanR> -I wouldnt make sense for the linker but theres another place to put those, i think
12:50:55 <bollu> (as in, keep the .c file in the same folder)
12:51:02 <bollu> no, I mean, can I pass it to GHC?
12:51:06 <EvanR> yes
12:51:25 <bollu> 	thanks :) I'm sorry for using IRC as my personal google, but the docs feel quite incomplete
12:51:38 <bollu> I'll take some time out and improve them in areas I think I can help with once I'm done with this
12:51:41 <EvanR> there are no docs on how to use C, its all folklore
12:51:49 <geekosaur> pretty sure all of those are in the ghc users guide
12:51:50 <EvanR> C/unix
12:52:10 <bollu> geekosaur: it's very scattered from what I can see
12:52:31 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html
12:53:20 <geekosaur> of course it's at the end of chapter 4 rather than the beginning >.>
12:53:26 <bollu> geekosaur: I wasn't referring to the flags, I was referring to the entire process of getting FFI to work
12:53:48 <bollu> geekosaur: but that table is freaking huge as well
12:53:50 <geekosaur> oh. that indeed gets you into details of how C tooling works
12:55:05 <jackhill> indeed. I'm currently trying to get a basic understanding of C so I can better to FFI
12:55:12 <EvanR> one does not simply access C from haskell
12:55:23 <EvanR> (without knowing C stuff)
12:59:08 <bollu> fuck, ld is dying on me with template errors
13:00:40 <geekosaur> um
13:00:54 <geekosaur> are you trying to do FFI to C++ instead of C? there be very nasty dragons
13:01:03 <pharaun> good ol c++
13:01:16 <geekosaur> at minimum you will need to include -lstdc++ or -lc++ depending on which C++ compiler was used
13:01:29 <EvanR> make a C bridge to the C++ 
13:01:31 <geekosaur> you also will need to make sure you only FFI to thinks with `extern "C"` linkage
13:01:33 <bollu> geekosaur: well, the exposed header file is a C file, but the entire library is written in C++
13:01:49 <pharaun> i've tried to do c++ binding to haskell and it can be nasty
13:01:57 <geekosaur> then you need -lstdc++ or -lc++ or similar possibly check C++ compiler documentation
13:01:58 <pharaun> i recommend compiling it separately and doing a c bridge
13:02:04 <pharaun> also that ^
13:02:24 <pharaun> i think i had to do some stdc++ bits lemme find my code a sec
13:02:43 <pharaun> https://github.com/pharaun/MegaHAL/blob/master/MegaHAL.cabal
13:02:52 <geekosaur> (in general gcc/g++ uses -lstdc++, clang/clang++ uses -lc++, but can depend on platform. I think it's almost always -lstdc++ for Linux)
13:02:56 <pharaun> yeah i had to d~rag in 'stdc++' under my extra-libraries:
13:02:57 <bollu> pharaun: thanks a freaking ton!
13:03:39 <pharaun> the megahal c bits used t be C but i was slowly converting it to c++ for various reasons
13:03:45 <pharaun> but i stopped that project once i ran over exceptions
13:04:19 <pharaun> https://github.com/pharaun/MegaHAL/blob/master/include/wrapper.h
13:04:22 <pharaun> you can see my externs here
13:04:35 <pharaun> but yeah doing this gets nasty fast
13:04:52 <pharaun> if i had to redo the project i would probably lean toward a c interface and compile it to a library unit and link it in somehow
13:05:11 <joco42> what is an applicative but not a monad ? and kinda still useful ?
13:05:20 <joco42> any good examples?
13:05:26 <mauke> ZipList?
13:08:43 <bollu> joco42: a non-trivial example: https://hackage.haskell.org/package/active-0.2.0.8/docs/Data-Active.html
13:09:52 <bollu> It uses Applicative to let you "lift" boring functions into the Active world, but has no concept of "sequencing" active actions
13:10:59 <dobie_gillis> When fetching a document with Text.XML.HXT.Arrow.ReadDocument I get the error: fatal error: 302 found. How do i tell it to follow redirects?
13:11:04 <joco42> interesting bollu 
13:32:21 <Hamstak> Working on interview prep, but with Haskell, any idea what's making this slowish? http://pastebin.com/kPQbTH3R
13:36:33 <bollu> the linker is not able to find code that's inlined
13:36:40 <bollu> any help as to what could be screwing up?
13:36:45 <bollu> the linker is ld btw
13:39:45 <geekosaur> this is C code? you did not declare it static inline? it's possible that it's getting optimized away by the C compiler; you'll need to pick a source file for the non-inline version to live in and declare it extern inline in only that file
13:41:00 <geekosaur> unlike haskell, c/c++ will remove the extern callable version of something that it believes has been inlined everywhere it is used
13:42:31 <geekosaur> http://stackoverflow.com/questions/6312597/is-inline-without-static-or-extern-ever-useful-in-c99
13:43:26 <geekosaur> (also unlike haskell, "inline" is not a suggestion, it's an order)
13:46:26 <kadoban> geekosaur: Is it? I thought C and C++ compilers could ignore inline if they feel like it
13:46:44 <MarcelineVQ> I thoguht they could too, is it different with external inline or inline in headers?
13:46:45 <geekosaur> well, that was an oversimplification. but it's all or nothing
13:47:26 <geekosaur> because you want the link behavior to be deterministic, so either all uses are inlined, none are, or all are but an "extern inline" declaration can force externally callable code to be emitted in one source file
13:47:46 <geekosaur> otherwise you run into complexities ensuring that only one copy of the code is emitted into the object, etc.
13:48:06 <geekosaur> (C++ has ways to deal with that because templates need it; C does not.)
13:49:00 <MichaelBurge> Is there a good way to do an in-language Bimap? I'd like to associate the constructors of a data type with some strings in a 2-way association. I'm using a Bimap right now, but the compiler doesn't warn you if you miss a case that way.
13:49:19 <MichaelBurge> I'd like a toString and fromString method, but I'd prefer not to duplicate the mapping
13:50:03 <mauke> read/show?
13:50:21 <MichaelBurge> It's not for serialization or debugging, it's for mapping urls to routes.
13:51:04 <MichaelBurge> So PageIndex would map to '/index'. And later, '/index' should be parsed into PageIndex.
13:54:57 <osfameron> any suggestions on libraries to generate HTML?
13:55:08 <MichaelBurge> osfameron: blaze-html
13:55:33 <osfameron> MichaelBurge: ah.  any better tutorial than https://jaspervdj.be/blaze/tutorial.html ?  There's nothing small enough in there to play with in the repl for example
13:55:44 <MichaelBurge> http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
13:56:29 * hackagebot language-c 0.5.0 - Analysis and generation of C code  https://hackage.haskell.org/package/language-c-0.5.0 (BenediktHuber)
13:56:29 <MichaelBurge> I don't know that it's small enough to use in the Repl, but it's what I was using
13:57:20 <osfameron> thanks, that's a bit confusing as it also uses Scotty (which I'm not using)
13:58:02 <puregreen> osfameron: lucid might be nicer than blaze-html (see http://chrisdone.com/posts/lucid)
13:58:28 <MichaelBurge> You should able to render blaze pretty easily by itself. Try this: renderHtml $ h1 ! class_ "example" $ toMarkup "example"
14:00:29 <Hamstak> I'm implementing a trie, and it's filling with data pretty slowly compared to my java equivalent, any tips on building data structures quickly?
14:00:30 <osfameron> MichaelBurge: I don't have renderHtml or class_
14:00:36 <puregreen> (there are also examples at https://github.com/chrisdone/lucid)
14:00:59 <osfameron> puregreen: thanks, I read that post a while back (didn't understand details, but seemed well argued)
14:01:00 <MichaelBurge> osfameron: Import these modules: Text.Blaze Text.Blaze.Html.Renderer.Text Data.Text
14:02:41 <osfameron> I get a Could not find module "It is a member of the hidden package 'blaze-markup-0.7.0.3@blaze_0GHhaMWFHoQLer0aTKr3fi'." warning when I try that in my stack repl
14:02:56 <MichaelBurge> You'll want to add blaze-markup to your .cabal file, and then run stack build
14:03:29 <osfameron> ah.  so ghci knows about the file but refuses to load it because reasons?
14:04:07 <MichaelBurge> Yeah. blaze-markup is needed for something else(maybe you're using Yesod and it depends on it?), but in order for you to use it it should be in the dependencies.
14:04:29 <zoug> hey guys. Can you help me figure out whats wrong with this? "map (`take` (repeat '*')) (map length $ group $ sort a" with a a list of integers. It doesn't compile and all the tests I run on ghci work. It should turn something like [1,1,2,3,3] in ["**","*","**"]... thanks a lot...
14:04:35 <MarcelineVQ> If it did things on its own you could't trust it to only do what you want when you only want it to do things you want
14:04:49 <osfameron> MichaelBurge: puregreen: thanks for suggestions
14:05:08 * osfameron realises he is too full of snot to take more in now, going to bed, will play more tomorrow
14:05:33 <mauke> zoug: doesn't compile how?
14:06:10 <zoug> it says "Couldn't match [Char] with Integer" in (`take` (repeat '*'))
14:06:13 <zoug> mauke: 
14:06:30 * hackagebot overloaded-records 0.3.0.0 - Overloaded Records based on current GHC proposal.  https://hackage.haskell.org/package/overloaded-records-0.3.0.0 (PeterTrsko)
14:06:32 <mauke> zoug: where's the rest of the program and the rest of the error?
14:07:14 <bollu> thanks a ton, all. I got it working! https://github.com/bollu/symengine.hs
14:07:14 <zoug> thats my program for now, i want to do a histogram. I actually can't copy paste the error because it's on tmux on a remote machine
14:07:28 <mauke> zoug: that's a syntax error
14:07:49 <zoug> yes but I have no idea where. I tried every step on ghci and it works
14:07:50 <mauke> also, why does that prevent you from copying the error?
14:08:02 <bollu> EvanR, geekosaur, pharaun, quchen, liste: thanks for all the help with the FFI :)
14:08:10 <bollu> now I gotta get this onto Hackage
14:08:28 <mauke> zoug: no, I'm saying you're not telling me the truth. you're saying you're getting a type error with your code. if that really was your code, you'd be getting a syntax error
14:08:28 <zoug> mauke: because when you have different panels on tmux, if you copy a line it copies the lines of the other panels too so unusable
14:08:53 <mauke> ... so stop using split windows?
14:08:53 <zoug> mauke: well no i'm not lying to you
14:09:07 <mauke> or use rectangular selection if your terminal supports it
14:09:11 <zoug> ok please help me if you want
14:09:21 <zoug> but stop doing what you're doing
14:09:32 <mauke> I can't help you without the actual code/error
14:10:08 <zoug> my whole code is : "histogram :: [Integer] -> String" then "histogram a = draw $ map (`take` (repeat '*')) (map length $ group $ sort a)"
14:10:28 <zoug> with draw another function that i havent done yet
14:10:46 <zoug> when i try to load the script it gives the error i wrote above
14:11:02 <zoug> but when i do the statements one by one on ghci it does work
14:11:21 <zoug> the whole statement fails with the same error
14:11:29 <mauke> zoug: irc.hs:3:15: Not in scope: ‘draw’
14:12:14 <zoug> i just wrote above that draw isn't written yet, for now i have a placeholder ("where draw ls = show ls")
14:12:25 <mauke> sigh
14:12:27 <zoug> remove it if you want
14:12:31 <mauke> again not telling the truth about your code
14:12:41 <zoug> please stop helping me
14:12:45 <zoug> thanks
14:12:49 <lyxia> lol
14:12:49 <puregreen> zoug: http://lpaste.net/153903
14:12:52 <mauke> zoug: irc.hs:2:62: Not in scope: ‘group’
14:12:59 <puregreen> I load this exact code into GHCi, it works
14:13:06 <puregreen> can you check whether it works for you or not?
14:13:12 <lyxia> just put your full code on lpaste it saves everyone time and frustration
14:13:18 <mauke> can confirm, works after importing Data.List
14:13:42 <puregreen> zoug: also, if it does work, can you say how your code is different from the code I pasted?
14:13:50 <zoug> puregreen: thats the exact code i have
14:13:50 <lyxia> the whole error is also nice
14:13:52 <zoug> to the letter
14:13:57 <geekosaur> wasn't the statement that it's what got typed into ghci?
14:14:07 <geekosaur> so te answer is that ghci, but not ghc, needs "let"
14:14:16 <geekosaur> (this is expected to change in ghc8 iirc)
14:14:17 <mauke> geekosaur: again, that would be a syntax error
14:14:37 <geekosaur> well, not just jamming let on the front of both lines, yes
14:14:44 <mauke> zoug: btw, you could show us a screenshot
14:14:54 <geekosaur> are we being pedantic to avoid the point, or to make an irrelevant other point?
14:14:59 <mauke> not as good as text, but better than retyping errors
14:15:04 <geekosaur> the point is that ghci prompt is not a filer
14:15:06 <geekosaur> *file
14:15:13 <geekosaur> and the syntax you need to use differs
14:15:16 <shachaf> I think what mauke is asking is pretty reasonable.
14:15:26 <mauke> geekosaur: I don't understand what you're going on about
14:15:31 <puregreen> geekosaur: this is irrelevant, I guess, because zoug said that it does work in GHCi
14:15:33 <mauke> the problem is a type error when loading the file into ghci
14:15:46 <Zekka|Sigfig> zoug: FWIW I think there’s a little beating-around-the-bush going on here: the reason I think mauke wants more info is because there isn’t something obviously wrong with the one-liner you posted here
14:15:53 <shachaf> zoug: If the problem was where you think it is, you would probably be able to solve it yourself.
14:16:05 <Zekka|Sigfig> so mauke is suspecting there is something else wrong not obvious from the oneliner you’re giving us
14:16:17 <puregreen> guys, let's just wait for the screenshot/additional explanations
14:16:18 <shachaf> zoug: So you should show people the actual full code that you're using -- every line -- and the actual error message you actually get.
14:16:20 <zoug> heres a screenshot http://imgur.com/swAAbv9
14:16:25 <mauke> I'm not suspecting, I know something is wrong. otherwise there would be no error
14:16:36 <mauke> I don't know what that error is if you don't tell me the error message
14:16:47 <mauke> and I can't tell you how to fix it without seeing the code that produces the error
14:17:37 <puregreen> zoug: this doesn't seem to be the right screenshot, it doesn't mention “histogram” at all
14:17:58 <zoug> ok I messed up sorry
14:18:04 <bollu> that's a sexy vim theme
14:18:06 <bollu> which one is it?
14:18:09 <jle`> :w
14:18:51 <zoug> heres the actual screenshot http://imgur.com/kVtC6uB
14:19:07 <puregreen> thanks
14:19:14 <zoug> thank you guys for your patience..
14:19:33 <puregreen> your signature for “draw” is wrong
14:20:02 <mauke> <zoug> puregreen: thats the exact code i have
14:20:11 <mauke> riiiiiight
14:20:12 <puregreen> mauke: please stop
14:20:23 <mauke> puregreen: no, thanks
14:20:40 <zoug> omg i removed it it works now
14:20:43 <zoug> pfiiiew
14:20:46 <zoug> thanks a lot
14:21:05 <puregreen> zoug: do you know what the correct signature should be?
14:21:39 <zoug> puregreen: not really no
14:21:45 <zoug> I thought that was it
14:22:13 <MarcelineVQ> :t repeat '*'
14:22:14 <lambdabot> [Char]
14:22:27 <mauke> > map (`take` (repeat '*')) (map length $ group $ sort [1,2,3,2,1)
14:22:28 <lambdabot>  <hint>:1:64: parse error on input ‘)’
14:22:29 <zoug> ooooh yeah
14:22:32 <mauke> aw
14:22:34 <zoug> okkkk
14:22:43 <zoug> got it!! thank you guys
14:24:00 <MarcelineVQ> np, people here are happy to help, just be sure to meet us halfway by providing what you actually have so we can say what's actually wrong :>
14:24:42 <puregreen> yep, sometimes you think that something is irrelevant to the problem but it turns out not to be, so giving more context never hurts
14:25:05 <zoug> MarcelineVQ: yeah I could have been more explicit indeed, will do next time
14:25:18 <Zekka|Sigfig> Don’t worry about it too much, I’ve done the same in other channels
14:25:22 <zoug> you guys are impressively patient for people on IRC.. thanks a lot
14:25:50 <mauke> if you do omit something, say so. don't claim "this is exactly what I have!" or "that's the whole program!" when it isn't
14:26:28 <mauke> also, if you think something is irrelevant to the problem, first try cutting it out yourself
14:26:42 <EvanR> minimal test case
14:26:43 <mauke> i.e. make a new file containing only the code you think you need, and try to reproduce the problem there
14:26:46 <geekosaur> it's often better to use a pastebin, there are command line things you can feed a file to, or you can use something like xclip (although that one is pretty horrid to use...)
14:27:03 <mauke> if the problem is still there, you've narrowed it down and removed irrelevant detail
14:27:07 <EvanR> pbcopy < myfile.hs
14:27:10 <mauke> if the problem disappears, that's an important clue
14:27:16 <geekosaur> on a mac, yes, pbcopy
14:27:44 <mauke> because it means the problem is somewhere else than you thought it was
14:30:53 <puregreen> (mauke: I'm sorry for saying “please stop”, that wasn't nice of me either)
14:31:17 <EvanR> im sure you meant "oh stop you"
14:37:20 <spoing> hello! I started redoing a rust project I've done in haskell. what I'm aiming to do is procedurally generate a world. I just started, and i managed to generate random location names, but I want to put the generated word into a data type called Landmark
14:38:06 <spoing> the Landmark type is defined as data Landmark = Mountain String | Forest String etc.
14:39:11 <spoing> where the String is the name. however, since I randomly generated the name, I somehow need to use IO String here, but that becomes problematic when I try to implement Show for Landmark. Does anyone have any ideas as to how I can solve that?
14:39:43 <spoing> or more generally, how you work with creating instances for data types that contain IO?
14:39:50 <EvanR> this is a more general issue with trying to put IO-using-code just any old place
14:39:56 <mauke> don't put IO into your types
14:40:25 <EvanR> well you can put IO into your types, data MyIOs = MyIOs (IO ()) (IO Int)
14:40:32 <lyxia> the fact that it's randomly generated doesn't justify it
14:40:36 <EvanR> you just should be expecting it to execute at arbitrary times
14:40:44 <mauke> the key function to use here is (>>=) :: IO a -> (a -> IO b) -> IO b
14:40:44 <EvanR> should not be expecting *
14:40:59 <mauke> welcome to IO
14:41:24 <EvanR> spoing: so you can create a random stream of names that you take from in your construction algorithm
14:41:25 <Cale> spoing: A value of type IO String is very much not like a String at all. It's a procedure which if you were to run it, would produce a String each time (along with doing potentially anything else that a program running on your computer could do)
14:41:31 * hackagebot ghcid 0.5.1 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.5.1 (NeilMitchell)
14:41:52 <Cale> spoing: So, you don't want to store IO String values there -- you want to store actual Strings, which are the results of running IO actions.
14:42:21 <Cale> (Unless you really do want the ability to regenerate the name randomly multiple times, and don't care about storing the result.)
14:42:26 <Zekka|Sigfig> IO String : String  ::  ls : “. .. project.cabal src/“
14:43:32 <puregreen> spoing: “IO String” doesn't mean “a String that is tagged with impurity”, it's more like “a program that generates a String when you run it”. So, if you write “data Landmark = Mountain (IO String) | Forest (IO String) | ...”, it means that your Landmark contains not a name, but a generator of names
14:44:22 <spoing> okay, that makes sense. then the question becomes how I would get my procedurally generated name into the data type
14:44:27 <puregreen> spoing: if you want to generate a random Forest, for instance, you want to do something like this: “do name <- getRandomName; return (Forest name)”, which can be shortened to “Forest <$> getRandomName”
14:44:40 <spoing> oh ok
14:44:51 <Zekka|Sigfig> What puregreen’s describing you would get you a value of type IO Landmark
14:44:55 <EvanR> spoing: you can always generate the name in IO, and then use the string in your construction
14:44:59 <montanonic> spoing: so, basically, when you write your main loop, it will be in IO, from that, you'll use (>>=) to do: IO (String) -> (String -> IO b) -> IO b, where the middle part is whatever function or functions you apply to your Landmark data type
14:45:07 <Axman6> better yet, make an infinite list of random names and pass that around, taking names off the front
14:45:18 <Cale> montanonic: Or just do-notation.
14:45:32 <montanonic> spoing: what EvanR just said is what I'm trying to say; you don't need to have IO in your types there, your code can work just fine without it
14:45:49 <mauke> Cale: do-notation was harder to understand for me
14:45:51 <Zekka|Sigfig> So you start with IO String and use String -> Landmark to get you an IO Landmark — then you later might have [Landmark] -> World, which you can use to get an IO World
14:45:55 <montanonic> Cale: yeah I was just piggybacking off of what mauke said
14:46:00 <Zekka|Sigfig> Landmark and World don’t have to know they’re goign to be used with IO
14:47:57 <madhadron> spoing, In general, stay outside of IO as long as you can, and then bind it all together in the main function or just below it.
14:48:02 <montanonic> spoing: you might want to check out http://haskellbook.com, that can really help with getting a feel for IO and other core Haskell concepts
14:48:56 <EvanR> infinite list generators for stuff are ok until you need to save and restore it somehow
14:49:11 <EvanR> and then its bittersweet
14:49:42 <Zekka|Sigfig> Usually you only put an IO *in* your type if your type is some way of doing IO
14:50:23 <Zekka|Sigfig> data IOEndo a = IOEndo (a -> IO a)
14:50:38 <EvanR> oh hell naw
14:50:45 <EvanR> IOEnd (IO a -> IO a) ;)
14:51:03 <johnw> that's just Endo (IO a)
14:51:16 <EvanR> EndIO
14:52:55 <Zekka|Sigfig> data InstantMessenger = InstantMessenger { send :: String -> IO (), subscribe :: (String -> IO ()) -> IO () }
14:53:03 <Zekka|Sigfig> there’s a less abstract type that might have an IO in it!
14:53:22 <dmwit> Kleisli IO a a, Endo (IO a), and IO (Endo a) are all subtly different ways to put the IO in.
14:53:45 <spoing> allright guys, I got it to work! thanks a lot
14:57:26 <dmwit> :t (\ioatoioa a -> ioatoioa (return a), \atoioa ioa -> ioa >>= atoioa)
14:57:27 <lambdabot> (Monad m, Monad m1) => ((m a -> t) -> a -> t, (a1 -> m1 b) -> m1 a1 -> m1 b)
14:58:17 <EvanR> dont cross the monads!
14:59:30 <dmwit> I guess they're not quite an isomorphism, huh? The second one always executes the `ioa` action exactly once.
15:00:41 <spoing> montamonic: I have the haskellbook :). read the version that was available a couple of months ago, and had a lot of fun! havent had the chance to re-read the newer version yet though
15:04:48 <montanonic> spoing: oh, awesome! Glad to hear it. I'm working through the newer versions right now.
15:11:25 <lambda-11235> How much of the lambda cube does Haskell fill without GHC extensions? It definitely is a λ2, and not a λΠ, but is it a λ2ω
15:11:32 * hackagebot haste-compiler 0.5.4.1 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.4.1 (AntonEkblad)
15:14:33 <lambda-11235> Sorry, that's λω, without the 2.
15:16:44 <levi> lambda-11235: I'm pretty sure λω is it; at least GHC desugars everything to it.
15:33:22 <gigglypuff> what will a programming neophyte learn from reading SICP? will it teach one how to approach a problem such as game programming -- how to construct and organize code bases? what does one stand to gain from it?
15:36:41 <EvanR> how to write a scheme within a scheme with scheme
15:37:15 <Cale> gigglypuff: It's mostly a little bit more medium to small scale with respect to what it teaches you about structuring computation.
15:38:44 <EvanR> i enjoyed it, though it does nothing for the wonderful world of static types
15:39:42 <Cale> You can see some of the things it teaches you encoded into Haskell as language features directly.
15:40:03 <Hamstak> So I'm attempting to use Data.Trie, and the type declaration for fromList isn't what hackage says it is. It should be [(ByteString, a)] -> Trie a, but in the interpretter it's saying the type declaration is [(ByteString.Internal.ByteString, a)] -> Trie a
15:40:47 <shachaf> I don't know what Data.Trie is, but those look like the same type to me.
15:40:48 <Cale> Hamstak: That is the same thing
15:41:07 <Cale> Hamstak: It's just in one case, you have a module qualifier saying which module the type was defined in.
15:41:19 <lambda-11235> levi: I'm not sure. Without LiberalTypeSynonyms, passing higher order type functions may be impossible.
15:42:15 <Cale> It should be impossible even with LiberalTypeSynonyms
15:42:44 <Cale> Well, type synonyms shouldn't change what you can accomplish, in any case.
15:44:16 <lambda-11235> Cale: type Z f x = Const x (f x); type S n f x = f (n f x) -- This is what I'm talking about
15:45:08 <Hamstak> thanks, Cale
15:45:29 <lambda-11235> It would allow you to write Just (Just 0) :: (S (S Z)) Maybe Int, but only with LiberalTypeSynonyms.
15:47:56 <lambda-11235> Also, type Const x y = x was the only way I could get kind types without KindSignatures.
15:48:29 <Cale> Oh, that is interesting.
15:56:06 <levi> I'm not sure how much of λω you can do in the surface language of Haskell, but IIRC it's required for desugaring some Haskell type class features.
15:58:46 <levi> Without some restriction on even plain System F, you don't have decidable type inference/checking.
16:01:36 <levi> As I understand it, a lot of the type system extensions available now are designed to expose more of the expressiveness of the underlying typed intermediate language of GHC while retaining as much useful type inference as possible, but it gets to be a difficult series of trade-offs.
16:06:35 <sbrg> @ pl \a b -> a:[b]
16:06:39 <sbrg> @pl \a b -> a:[b]
16:06:39 <lambdabot> (. return) . (:)
16:06:44 <sbrg> eh
16:07:20 <EvanR> @unpl (:) . (:[])
16:07:20 <lambdabot> (\ d -> ((:)) (d : []))
16:09:38 <EvanR> \a b -> [a,b] ;)
16:11:33 * hackagebot hjsonschema 0.9.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.9.0.0 (seagreen)
17:20:02 <refefer> any particular comments about whether to use something like conduits or wreq for http access?
17:20:29 <ReinH> refefer: do you need to stream a very large amount of data in constant space?
17:21:10 <refefer> ReinH: not likely.  mostly grabbing small json snippets
17:21:16 <ReinH> Then probably wreq.
17:40:08 <jle`> ReinH: ironic considering our conversation a few weeks ago that i now run into a situation where a particular IO do block vs. ghci difference is making everything more difficult v.v
17:43:43 <parsecChar> in https://hackage.haskell.org/package/groundhog-sqlite-0.7.0.1/docs/Database-Groundhog-Sqlite.html how do I use a "Pool Sqlite" ?
17:43:48 <parsecChar> what is this Pool ?
18:01:00 <mattn> what are some good ways to go about profiling performance, specifically for multithreaded applications?
18:01:27 <mattn> I’m seeing some counterintuitive stuff that I assume has to do with lock contention, but I’d like to have more confidence.
18:12:57 <lethjakman> So, I'm not sure how to goodle this, but I want to confirm. reusing an abstract variable in a type signature doesn't mean it has to be the same type, right?
18:13:29 <kadoban> lethjakman: Example?
18:13:49 <lethjakman> kadoban: login :: (Route Auth -> Route master) -> WidgetT master IO ()
18:14:22 <lethjakman> I just remember seeing something about it, but I'm not suer how to google it. 
18:14:25 <kadoban> lethjakman: Yeah, the two 'master's there are the same type
18:14:31 <lethjakman> Oh
18:14:34 <lethjakman> Is that enforced?
18:15:02 <mattn> it better be, or id :: a -> a becomes a bit too useful..
18:15:10 <kadoban> lethjakman: Yep.
18:15:21 <lethjakman> K.
18:15:25 <lethjakman> That makes sense!
18:15:31 <lethjakman> I could have swore I saw that somewhere. 
18:15:43 <lethjakman> Thank you for confirming that dumb question. 
18:16:07 <mattn> lethjakman: you can reuse the type variable name as a regular variable within the function’s body, which is a bit confusing. That might be what you remembered.
18:16:21 <lethjakman> That would make sense. 
18:16:23 <Eduard_Munteanu> lethjakman, it can only be different if you quantify explicitly, like   (forall a. a) -> (forall a. a)
18:16:25 <kadoban> lethjakman: You might be thinking of something like ScopedTypeVariables I think it's called, the behavior that that extension modifies.
18:17:04 <lethjakman> kadoban: I'll look that up, thanks!
18:17:07 * hackagebot fn 0.3.0.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.3.0.0 (DanielPatterson)
18:17:11 <lethjakman> Eduard_Munteanu: What do you mean quantify?
18:17:30 <Eduard_Munteanu> lethjakman, if you don't know about higher-rank types, don't mind my remark then
18:17:38 <lethjakman> I don't...but I will. 
18:17:39 <lethjakman> Thanks
18:17:42 <lethjakman> Or...maybe I don't know them by that name. 
18:20:44 <mattn> Another question in the “multithreading is hard” category: I’m working on a port to Haskell of a program I wrote to analyze dynamical systems (the original is Objective C).  For a simple testcase where its drawing a Mandelbrot set, a bunch of workers are writing to different parts of a big buffer.
18:21:21 <mattn> When a worker finishes, they use an MVar to signal to the wxHaskell viewer that a redraw is needed.
18:21:34 <dmwit> re: profiling: look into threadscope, I think
18:22:26 <mattn> I was trying to make it so that the viewer (1) blocks new workers from beginning (2) waits until current workers are complete (3) renders the buffer, then (4) unblocks workers.
18:22:50 <mattn> so that it would never render the buffer while a worker was filling it’s subtile.
18:23:34 <mattn> but using “with buf” (for the workers) and “synchedWith buf” (for the viewer) from here, I get weird glitches: https://github.com/matt-noonan/FractalStream/blob/master/src/Utils/Concurrent.hs
18:23:42 <dmwit> Threading+foreign GUI libraries is often a tough combination.
18:23:55 <mattn> here are the glitches: http://imgur.com/g7Z9vUJ
18:23:59 <dmwit> Often they have their own idea of thread management that you have to work with.
18:24:20 <dmwit> According to the wxhaskell wiki page, Haskell threading isn't supported at all: https://wiki.haskell.org/WxHaskell/FAQ
18:24:31 <dmwit> Though who knows how up-to-date that is; it mentions GHC 6.0!
18:24:38 <mattn> dmwit: yeah :)
18:25:06 <mattn> It seems to actually be ok, as long as you don’t have random threads doing wx stuff.  All the workers just signal the main wx loop.
18:25:28 <mattn> also, thanks for the threadscope trick. I failed to build it on the first try; guess I should give it another shot.
18:25:35 <mattn> er, pointer
18:26:15 <Eduard_Munteanu> It wouldn't be the first UI toolkit to disallow multithreaded access to GUI stuff.
18:27:21 <Eduard_Munteanu> It's the case on Android too, for example.
18:28:04 <kadoban> I can't remember one of them I've ever used being okay with multithreaded access.
18:28:40 <mattn> I’m pretty sure wx+threads isn’t the problem here, though. For example, if I just use a single MVar () as a mutes around both reads and writes to the buffer, no glitching.
18:28:42 <dmwit> I mean, the wxhaskell FAQ seems to go even farther than the usual "do all GUI stuff from one thread" thing to say "don't use Haskell threads and the GUI in the same program".
18:28:58 <mattn> *mutex
18:29:10 <Eduard_Munteanu> Hm.
18:30:54 <dmwit> kadoban: Also, gtk supports multithreading (though only one thread at a time; there is a "grand GTK lock"). gtk2hs supports this if you're using the threaded runtime.
18:31:42 <Eduard_Munteanu> Multithreaded GUIs are a bit of a research problem currently.
18:32:11 <monochrom> gtk also requires single-threading
18:32:13 <mattn> actually, what does “thread” even mean here? presumably not Haskell green threads.. OS threads?
18:32:26 <monochrom> yes, single OS thread
18:32:32 <kadoban> dmwit: Hmm, interesting.
18:33:08 <mattn> is there a myOSThreadId :: IO OSThread out there? I only found myThreadId, which seems to be green threads. 
18:33:25 <dmwit> monochrom: I believe that is not correct. They have explicit sections of their API dedicated to supporting multiple threads.
18:33:34 <monochrom> I'm outdated
18:33:55 <monochrom> last time I used gtk2hs, gtk 3 did not exist
18:34:14 <dmwit> monochrom: gtk2hs has supported multiple threads since long before gtk3 existed.
18:34:39 <dmwit> mattn: threadCapability :: ThreadId -> IO (Int, Bool) -- not quite the same as OS thread
18:35:16 <dmwit> mattn: What will you do with the OS thread ID, out of curiosity?
18:35:41 <mattn> dmwit: verify that all of my wx code is indeed running on the same OS thread.
18:35:43 <monochrom> I don't think a library function has it, but you can add your own FFI call to find out
18:36:07 <Axman6> ./foo +RTS -N1 =)
18:36:20 <dmwit> mattn: Ah, right, yeah. But presumably you actually want all your wx code to in fact run on the same green, bound thread (probably the `main` thread).
18:36:34 <dmwit> mattn: Which you should be able to check just using `ThreadId`s.
18:36:48 <dmwit> Axman6: This does not prevent GHC from creating more than one OS thread.
18:36:54 <dmwit> Axman6: (Surprise!)
18:36:59 <mattn> dmwit: oh, maybe! if that is the case, I *do* have a problem.  Every redraw request seems to get serviced by a different ThreadId.
18:37:07 * hackagebot Gifcurry 0.1.0.6 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-0.1.0.6 (lettier)
18:37:10 <monochrom> but then, the extra OS threads don't really run your code
18:37:40 <dmwit> monochrom: Depends which code qualifies as yours, I guess.
18:38:01 <monochrom> you can always compile (really link) without -threaded. then there is a strong guarantee
18:38:15 <dmwit> mattn: Yeah, I wouldn't be surprised if that was Not OK.
18:38:39 <dmwit> monochrom: ...but maybe not the guarantee you want after all. Since there are still green threads and GHC can switch between them during callbacks.
18:38:56 <monochrom> they are all on the same OS thread
18:38:58 <dmwit> monochrom: It was fun tracking down *that* curious bug in my gtk app.
18:38:59 <Axman6> dmwit: yeah, I thought that probably wouldn't work :)
18:39:31 <dmwit> monochrom: That is certainly true. =)
18:43:11 <monochrom> oh, right, if -threaded, then -N1 does not save you from two FFI calls using two OS threads
18:43:21 <dmwit> right
18:44:16 <dmwit> mattn: So, you may or may not like dmwit.com/gtk2hs which is a dump of what I knew about threading+gtk2hs back when I had looked into it carefully.
18:44:33 <dmwit> mattn: I don't really know how applicable it is to wx, but I would bet many of the principles are carried over.
18:44:47 <dmwit> mattn: Certainly not the names of which library functions to call to do various things, of course.
18:46:01 <mattn> dmwit: awesome, thanks!
18:46:24 <dmwit> Also, did you know that green threads are named after "the Green Team" at Sun that designed Java's threading system, and not to how environmentally friendly they are?
18:47:04 <hamishmack> We use -threaded for leksah and evey time there is a threading issue it seems to be something running in a forkIO thread we overlooked that needs a postGUISync or Async
18:47:49 <monochrom> but then why were they called the Green Team?
18:48:14 <dmwit> ...maybe because of how environmentally friendly they were!
18:48:18 <hamishmack> Either GHC is not switching the OS thread on us or perhaps Gtk does not mind to much as long as the calls on different OS threads are not concurrent
18:48:32 <dmwit> Or perhaps you are on Linux where it doesn't matter anyway.
18:49:13 <hamishmack> BTW haskell-gi is looking really good these days
18:49:13 <dmwit> Well. "it doesn't matter" just means the second part of what you said, that it's okay to use different OS threads as long as the calls are not concurrent.
18:49:38 <geekosaur> hamishmack, it's actually xcb not gtk that has thread issues, and yes as long as there are no concurrent calls you are fairly safe
18:50:29 <geekosaur> xlib even had a call you could make that caused it to grab a global mutex on every call, which slowed everything down a bit but made xlib threadsafe. I don't know if xcb also supports that mode offhand
18:50:56 <geekosaur> (slowed a number of things down a lot, actually, because xlib isn't very smart)
18:51:11 <dmwit> I think I may have proposed making that call in xmonad once before I understood how broken my proposal was.
18:51:33 <hamishmack> I am wondering if someone could add a sort of “debug mode” to haskell-gi to check for threading issues
18:51:48 <hamishmack> Since all the bindings are generated
19:14:17 <echo-area> Which one do you prefer: either f g =<< h or do { v <- h; case v of { Left l -> f l; Right r -> g r; }; }
19:17:57 <dmwit> I guess it depends on f, g, and h.
19:20:18 <echo-area> Hmm
19:23:53 <gigglypuff> Guys, what is mutability in programming? I'm reading up the CIS 194 lecture notes and it just popped up.
19:24:09 <gigglypuff> Looked it up on SO and was met with an answer I couldn't swallow.
19:24:38 <ggVGc> gigglypuff: mutability just means that you change values of variables after they are initialised
19:24:44 <ggVGc> which is most imperative programming languages
19:24:51 <ggVGc> or most languages at all really
19:25:04 <ggVGc> in haskell you can't do this
19:25:07 <gigglypuff> Okay, so this is something that can't be done
19:25:20 <gigglypuff> Okay, nvm. That's what I was going to ask.
19:25:51 <ggVGc> gigglypuff: in haskell, and a few other languages, mutability is impossible because it usually leads to much less buggy code. It's much easier to reason about code when variables can only be assigned a value once
19:27:06 <ggVGc> gigglypuff: but that design has some tradeoffs like needing a much better compiler to reduce runtime cost(because of too much copying of data otherwise), and sometimes writing an algorithm becomes more difficult. THis is why you CAN actually do mutation in haskell, but only inside IO, and your idea in general should be that mutability is impossible in haskell as a design
19:27:08 * hackagebot fn-extra 0.3.0.0 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.3.0.0 (DanielPatterson)
19:27:11 <ggVGc> damn, what happened
19:27:42 <monochrom> network instability
19:27:59 <monochrom> it has been like this for days
19:28:00 <gigglypuff> Ikr? The feed is being flooded
19:28:07 <ggVGc> gigglypuff: anyway, in for example javascript you can do: var a=10; and then a=20; and after that point the value of a is changed. While in haskell you can only do: let a=10 once, and if you want somethign that's 20, you have to name it something else
19:28:36 <gigglypuff> and that's really all mutability is?
19:28:46 <ggVGc> gigglypuff: yep, that's entirely it
19:29:17 <aerialB> `let powersOf2 = 2 : [x * 2 | x <- powersOf2]` as a Pythoner, that is so cool! I like how natural recursion is for certain things.
19:29:18 <ggVGc> gigglypuff: but not having it has a lot of consequences, that are generally considered good.
19:29:46 <ggVGc> gigglypuff: when you ave no mutability in the language, it's very easy to look at some code and see just what happens, because you know the value of some name can only ever be whatever it was assigned
19:29:53 <ggVGc> it makes things much more clear
19:30:13 <dmwit> > let a=10 in let a=20 in a -- where is your god now
19:30:14 <lambdabot>  20
19:30:36 <gigglypuff> ggVGc: and what of these side effects?
19:30:47 <monochrom> my god is in "name it something else, such as a again"
19:30:51 <dmwit> > let a=10; f x = a*x in let a=20 in f 3 -- but a isn't really changing
19:30:53 <lambdabot>  30
19:30:54 <ggVGc> dmwit: yeah, scoping is a bit of a pain, but that's still not mutability
19:30:59 <ggVGc> and there would usually be indentation
19:31:22 <johnchen902> @pl (\x y z -> (x == y) && (x == z))
19:31:22 <lambdabot> ap (flip . (((.) . (&&)) .) . (==)) (==)
19:31:51 <monochrom> but I sometimes question people who believe in mutability by asking "change 5 to 6? so you mean changing 5+2=7 to 6+2=7?"
19:32:05 <ggVGc> gigglypuff: side effects means that in most other languages any function can do anything no matter what it returns. In haskell a function can generally only return a value, and not do anything else outside of that. And only within `IO` can you call a function such as `putStrLn` which does something to the outside world
19:32:26 <Sornaensis> :info RealWorld
19:32:32 <dmwit> aerialB: http://stackoverflow.com/q/12659951/791604
19:32:32 <Sornaensis> :t RealWorld
19:32:33 <lambdabot> Not in scope: data constructor ‘RealWorld’
19:32:33 <dmwit> aerialB: so readable
19:32:48 <ggVGc> sometimes I wish we had a syntax extension that prevented re-use of names in nested let bindings
19:32:53 <ggVGc> but maybe I'm jsut being dumb
19:33:37 <aerialB> dmwit: o.o
19:33:49 <kadoban> ggVGc: There's a warning for that in GHC
19:33:58 <ggVGc> ah, nice, how do I turn it on?
19:33:58 <dmwit> ?pl (\x y z -> all (x==) [y,z])
19:33:58 <lambdabot> (. ((. return) . (:))) . (.) . all . (==)
19:34:19 <kadoban> ggVGc: Not sure what it's called, I'm almost positive it's part of -Wall though
19:34:27 <kadoban> Something about shadowing?
19:34:35 <ggVGc> ah, yeah, I've seen this around
19:34:35 <ggVGc> thanks
19:34:36 <ggVGc> will dig
19:34:57 <monochrom> yes, shadowing
19:35:43 <monochrom> dmwit could have been much more successful if he used: do { a <- return 10; a <- return (a+10); ... }
19:37:01 <dmwit> Wouldn't you have said basically the exact same thing to that, namely, "ah nah mate, that's just shadowing"?
19:37:48 <aerialB> dmwit: huh, in that link the top answer gives this alternative definition: `let x = 2 : map (* 2) x` how is that possible? Isn't that using map on an Int instead of a list?
19:37:50 <ggVGc> either way, shadowing is not mutability, and disallowing shadowing in general I reckon would be a good thing
19:38:19 <dmwit> aerialB: No, since `:` is the constructor for lists.
19:38:24 <dmwit> > 2 : []
19:38:25 <lambdabot>  [2]
19:39:21 <aerialB> but there's no list yet D: this is mind boggling. Cons expects a list from map, map expects x to be a list and so on.
19:39:33 <aerialB> where does the list 'come into being' so to speak?
19:39:47 <dmwit> aerialB: It's the exact same code as your `powersOf2`, except that it writes `[x * 2 | x <- powersOf2]` as `map (2*) powersOf2`.
19:40:09 <dmwit> aerialB: Or, to draw the analog even more closely, you could write that `map (\x -> x * 2) powersOf2`.
19:40:51 <mattn> aerialB: it’s parenthesized like “let x = (2 : map (* 2) x)”
19:41:14 <aerialB> oh
19:41:31 <monochrom> dmwit: the thing is that by the time we get to "a <- return (a+10)" (which is not recursion) we lose the distinction between shadowing, single-assignment something, and state variable.
19:41:52 <geekosaur> this is laziness in action, aerialB. x is bound to an expression (2 : _) where _ is something not yet evaluated. this is sufficient for the thing in the _ to *use* x, provided it uses one value at a time, since there is an initial value
19:42:13 <aerialB> oh!
19:42:39 <ggVGc> hrm.. -Wall doesn't catch "let a=10 in let a=20 in a"
19:42:42 <ggVGc> :((
19:42:45 <ggVGc> that's disturbing
19:42:47 <dmwit> aerialB: Given that geekosaur's explanation seemed to help, I can't help but wonder: how did you think the original `powersOf2` code was working, if not that way?
19:43:15 <geekosaur> then `map (* 2) x` produces the next value in the list, so x is (2 : 4 : _) which gives another value for the _ expression to work on, and so on
19:43:32 <geekosaur> it starts with a seed value, and each iteration generates the input to the next iteration
19:44:01 <aerialB> dmwit: I don't think I had it thought through entirely. I guess I was thinking of the use of `[]` in the list comp as representing the creation of a list.
19:44:18 <aerialB> But now I realise that these data aren't as atomic as in other languages, I suppose
19:44:40 <dmwit> `:` also signals the creation of a list.
19:45:22 <geekosaur> aerialB, the expression [] is the only primitive list that uses []/ all other uses of [] are syntactic sugar; a liust is actually composed of expressions chained together with :
19:45:35 <geekosaur> sigh, typos
19:45:50 <aerialB> I see
19:46:12 <aerialB> that explains why pattern matching with cons works so well then :)
19:46:32 <geekosaur> [1,3] is sugar for (1:3:[]), [1..] is sugar for (enumFrom 1), list comprensions are sugar for more complex expressions I don't recall off the top of my head this late in my day
19:47:06 <aerialB> This goes back to what I've read, that Haskell's core is pretty small
19:47:48 <shachaf> geekosaur: more like list incomprehensions
19:48:13 <shachaf> aerialB: GHC compiles Haskell to an intermediate language called Core which is pretty small. But that's an implementation detail of GHC.
19:48:58 <dmwit> There is a specified kernel, though, and the kernel is indeed quite small. Not simple, but small.
19:49:08 <dmwit> GHC Core is both simple *and* small.
19:49:12 <scshunt> geekosaur: [] is kind of weird, especially if you have overloaded strings enabled
19:49:17 <scshunt> *lists
19:49:37 <johnchen902> @pl (\x -> x:[])
19:49:37 <lambdabot> return
19:49:37 <geekosaur> you can ask ghc to output "desugared" Haskell during compilation (-ddump-ds iirc)
19:50:06 <johnchen902> @pl (\x -> x:[])
19:50:07 <lambdabot> return
19:50:14 <johnchen902> **** monad
19:50:42 <geekosaur> @quote monkey
19:50:42 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
19:50:46 <geekosaur> bah
19:50:58 <geekosaur> @quote robot.monkey
19:50:58 <lambdabot> byorgey says: now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
19:54:42 <scshunt> geekosaur: list comprehensions desugar to monadic expressions
19:54:54 <geekosaur> scshunt, only with MonadComprehensions enabled
19:55:16 <scshunt> geekosaur: even in the case of lists, they do
19:55:19 <scshunt> err
19:55:24 <scshunt> even without, in the case of lists, they do
19:55:57 <dmwit> What is a "monadic expression"?
19:56:44 <scshunt> [ exp | pat <- val , cond ] desugars to do { pat <- val; guard (cond); return exp } which of course further desugars
19:56:52 <geekosaur> possibly gh translates them that way these days. that wasn't always true
19:57:03 <geekosaur> and the Report specifies in https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11 a non-monadic translation
19:58:29 <dmwit> scshunt: Interesting; I was under the impression that an essentially custom translation was done (and I have witnessed in older GHCs list comprehensions being faster than the obvious do-notation analog). When did this change?
19:59:00 <scshunt> sorry; I wasn't talking about how it's actually implemented
19:59:20 <scshunt> and geekosaur is right that that's not how the Report specifies it (for some reason I thought it did specify it in terms of do-notation)
19:59:37 <scshunt> Even with general monadic comprehensions enabled I would expect it to use a separate optimized version
19:59:48 <scshunt> but ultimately, the two expressions are isomorphic which is what really matters
20:01:33 <geekosaur> dmwit, I have a vague recollection that they redid how list comprehensions were translated when they (re)added MonadComprehensions
20:01:53 <ggVGc> what do I need to do to make ghc happy here? https://gist.github.com/ae3b58f6bcf9acce9750
20:02:03 <geekosaur> but I thought they still used the custom translation if you didn't enable the extension; it appears that that changed at some point
20:02:17 <monochrom> GHC is the happiest if your file is empty...
20:02:26 <ggVGc> true
20:02:38 <ggVGc> monochrom: I just don't understand what I can do to not have that warning
20:02:49 <ggVGc> I don't know any way to write it that would be "good"
20:03:21 <geekosaur> ggVGc, it's the definition of Color that is leading to that. how is Color defined?
20:03:26 <dmwit> ggVGc: Give a concrete type for `getRedGreenFromColor` in the case scrutinee.
20:03:29 <monochrom> the basic idea is that pattern-matching against 0, 1, etc requires Eq, not just Num
20:03:31 <geekosaur> oh, no
20:03:41 <geekosaur> getRedGreenFromColor
20:03:53 <geekosaur> hm
20:03:54 <dmwit> ggVGc: e.g. `case (getRedGreenFromColor col :: (Integer, Integer)) of`
20:03:55 <ggVGc> https://gist.github.com/3e2cd901d79473b79c6b
20:04:07 <geekosaur> what dmwit said, yes
20:04:13 <ggVGc> dmwit: thanks
20:05:07 <dmwit> ggVGc: Possibly turn on `ScopedTypeVariables` and make it `(a, a)`, though it really depends what you want to happen here.
20:05:36 <dmwit> ggVGc: I might do the latter just as a forward-compatibility thing for when I later change it to return one of the values from the tuple and spend another five minutes scratching my head.
20:05:36 <ggVGc> I'm just trying to learn what ghc is telling me
20:05:49 <geekosaur> also unless you actually need getRedGreenFromColor to be polymorphic I'd just have it use concrete types
20:05:53 <dmwit> ggVGc: Okay. Do you know now, or should we try to explain some more?
20:06:00 <ggVGc> I think I do :)
20:06:01 <ggVGc> thanks[5~
20:06:14 <ggVGc> it needed me to specifically say "Yes, I know I made it less polymorphic"
20:06:18 <ggVGc> which is a good thing to tell me
20:06:25 <dmwit> right
20:06:45 <dmwit> But also, it needed you to specifically say, "Yes, it's okay to use the behavior associated with this particular instance".
20:07:02 <geekosaur> the default warnings warn about any time it needs to infer a specific type for something, including in the middle of some other expression. many programmers consider this noise though
20:07:37 <geekosaur> (that said, it can warn you that you made a thinko that the compiler will accept but won't do what you intended)
20:13:04 <gigglypuff> ggVGc: What is polymorphism? Sorry for these questions I shoud probably know the answers to.
20:13:51 <ggVGc> gigglypuff: any time you write a function that can act on different values within the same "group". Such as "Any number, regardless of if it's an integer, double, or something else"
20:14:04 <ggVGc> My wife is telling me I have to go eat now though, so others can probably explain better
20:16:22 <monochrom> polymorphism is when you see type variables
20:17:40 <geekosaur> except when you don't. like a numeric literal is quietly polymorphic, it can take on any type for which there is a Num instance (for literals without a decimal point) or Fractional instance (for ones that do)
20:20:02 <nitrix> :t 1
20:20:03 <lambdabot> Num a => a
20:20:10 <nitrix> I see type variables :)
20:20:19 <geekosaur> in :t, yes. in code, usually not
20:20:33 <nitrix> What does that even mean?
20:20:37 <geekosaur> > 1 + 1 -- look ma, no type variables
20:20:38 <lambdabot>  2
20:20:57 <geekosaur> but it's polymorphic and if you have -Wall enabled it'll warn you it's defaulting to Integer
20:21:00 <nitrix> That's because the type is inferred, I don't see your point.
20:21:40 <geekosaur> I cxould assemble an example where it retains the polymorphism. must I do so to satisfy you?
20:21:51 <geekosaur> it *does* come up
20:22:04 <nitrix> What's up with the attitude.
20:22:21 <nitrix> I thought this channel was friendly.
20:23:06 <geekosaur> Iam trying to figure out why *you* jumped on me for pointing out that polymorphism is a thing in general, not just when type variables are visible
20:23:16 <levi> nitrix: As an observer, I thought that your questioning seemed a little aggressive; being a bit defensive is a natural reaction to that.
20:23:22 <geekosaur> should I have let them find out the hard way?
20:24:27 <nitrix> Is the argument about monochrom's definition of "seeing" a type variable?
20:25:43 <levi> I don't think there is any need for an argument.
20:27:16 <gigglypuff> nitrix, what language do you personally fancy the most?
20:27:44 <nitrix> No preference.
20:28:12 <gigglypuff> What language do you use the most?
20:28:17 <gigglypuff> Just checking.
20:28:17 <nitrix> The ones I find elegant are typically unusable.
20:28:31 <hiptobecubic> How is that elegant?
20:28:45 <nitrix> Define "that" ?
20:28:52 <hiptobecubic> being unusable
20:29:12 <nitrix> Being unusable isn't a requirement but being elegant. You might have misread me.
20:29:25 <nitrix> *for
20:29:27 <exio4> he's asking how something unusable can be elegant
20:29:31 <levi> The pure lambda calculus is very elegant, but is not particularly usable for writing practical programs.
20:29:39 <hiptobecubic> It's like saying, "I have an elegant proof technique here, you just can't use it to prove things."
20:29:50 <nitrix> exio4: I have no idea how something unusable can be elegant; but I have seen elegant things being unusable.
20:30:01 <geekosaur> prolog can be quite elegant, but you wouldn't want to use it for most coding tasks
20:30:17 <nitrix> exio4: I have observed one, not the other.
20:30:19 <geekosaur> (that said I have used it in production in a business environment >.> )
20:30:47 <gigglypuff> ^
20:31:12 <nitrix> gigglypuff: Is there any agenda behind those questions?
20:32:14 <gigglypuff> No, just curious is all.
20:32:24 <levi> gigglypuff: Regarding polymorphism, the term itself can mean different things depending on the context, and it's often broken into several types.
20:32:53 <nitrix> gigglypuff: Curiosity killed the cat (:
20:34:38 <levi> gigglypuff: Object-oriented programmers often mean something different than Haskell programmers when they talk about polymorphism.
20:41:13 <opengl-curse> hello
20:41:44 <levi> Hello
20:41:57 <opengl-curse> can anyone help me with this question [http://stackoverflow.com/questions/35763178/how-to-resolve-ghc-error-with-opengl-libraries-parse-error-on-input-main]
20:42:10 * hackagebot yesod-pnotify 1.1.3 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.3 (KatsutoshiItoh)
20:42:33 <opengl-curse> OpenGL is cursed on every language i try to do anything with it
20:48:45 <opengl-curse> peace
21:02:11 * hackagebot hipchat-hs 0.0.2 - Hipchat API bindings in Haskell  https://hackage.haskell.org/package/hipchat-hs-0.0.2 (oswynb)
21:13:21 <gigglypuff> Is Haskell good for learning code design/structure/approach?
21:13:55 <gigglypuff> Because, as of now, I suck at figuring out how to approach program ideas.
21:17:28 <johnw> gigglypuff: I wouldn't call it a magic bullet, but it does place important on being able to think about what code means
21:19:54 <XexonixXexillion> Hi. This might seem like a weird and arcane question, but there a way to copy a value in Haskell (even if it's only GHC specific) so I can evaluate a copy of something without causing it the original to be updated?
21:20:57 <XexonixXexillion> i.e "let foo = iterate someFunc someVal in ((magicCopy foo)!!1000,foo)" doesn't keep the first 1000 elements of foo
21:21:25 <XexonixXexillion> or am I stuck writing (iterate someFunc someVal !! 1000, iterate someFunc someVal) ?
21:27:25 * hackagebot arx 0.2.2 - Archive execution tool.  https://hackage.haskell.org/package/arx-0.2.2 (JasonDusek)
21:29:32 <mrkgnao> anybody here familiar with hakyll?
21:29:32 <kadoban> mrkgnao: You should usually just assume someone is and ask your followup question.
21:29:32 <mrkgnao> okay, noted.
21:29:32 <mrkgnao> I just cloned @liamoc's hakyll repo from GitHub.
21:29:32 <mrkgnao> I wanted to run it locally and learn from it, etc.
21:29:56 <mrkgnao> So he has a lot of code dedicated to handling Agda, which he talks a lot about on his blog.
21:30:03 <mrkgnao> https://github.com/liamoc/liamoc.net/blob/master/site.hs#L112
21:30:40 <mrkgnao> I ham-handedly removed everything to do with Agda as a first try, including line 113.
21:31:10 <mrkgnao> now it complains about `defaultFileType` (which is from Hakyll.Contrib.Agda) being out of scope. 
21:31:26 <mrkgnao> removing that line gives me a type error
21:32:01 <mrkgnao> it says it got a Pandoc -> Compiler Pandoc instead of a String -> Compiler Pandoc
21:32:24 <mrkgnao> I essentially just want to remove the intermediate Agda handling business. Any ideas?
21:32:25 * hackagebot yesod-pnotify 1.1.3.1 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.3.1 (KatsutoshiItoh)
21:32:28 <mrkgnao> I'm stuck
21:32:34 <kadoban> mrkgnao: Well, did you remove the import that was providing that function?
21:32:39 <mrkgnao> Yes
21:33:02 <mrkgnao> I just need something "transparent" to stand in there and make it all typecheck
21:33:11 <mrkgnao> Hoogle was of no help.
21:33:24 <mrkgnao> "Unknown type FileType" and all that.
21:34:43 <kadoban> mrkgnao: I guess the problem is that I'm not sure what that is supposed to do, and which parts you left in and want to happen and not.
21:35:12 <mrkgnao> I removed line 113.
21:35:34 <mrkgnao> (and the import of Hakyll.Contrib.Agda)
21:36:00 <mrkgnao> I just want to remove the Agda compiler bits from the site.hs. That's all.
21:36:15 <kadoban> mrkgnao: That's all you removed?
21:36:43 <mrkgnao> Yes.
21:40:24 <kadoban> mrkgnao: Can't really tell without doing more research into what's going on with the rest of that, sorry.
21:40:51 <mrkgnao> what do you think defaultFileType does?
21:40:51 <mrkgnao> https://github.com/liamoc/agda-snippets/blob/605fc08f1d7576a4eb9474ea0622789061b1deab/agda-snippets-hakyll/src/Hakyll/Contrib/Agda.hs#L79
21:41:23 <mrkgnao> Is there a Hakyll function that I can replace it with?
21:44:07 <mrkgnao> okay, I think I figured it out
21:44:15 <mrkgnao> I just copied defaultFileType into my site.hs
21:44:24 <mrkgnao> and it compiles for now
21:49:19 <julianleviston> is (->) a semigroupoid?
21:50:40 <julianleviston> or rather, is a function a semigroupoid?
21:50:55 <johnw> a semigroupoid is a category without identities
21:51:15 <johnw> so (->) could easily be the morphism of some semigroupoid, but I don't understand what you mean by asking if it is itself a semigroupoid
21:52:10 <julianleviston> johnw: I was just looking at the function composition operator in purescript, and it’s defined as this: forall a b c d. (Semigroupoid a) => a c d -> a b c -> a b d
21:52:20 <johnw> ahh
21:52:23 <julianleviston> which when compared to this:
21:52:24 <julianleviston> :t (.)
21:52:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:52:30 <johnw> then yes, (->) should be an instance of Semigroupoid
21:52:34 <julianleviston> ah ok
21:52:36 <julianleviston> sweet
21:52:41 <julianleviston> should it in Haskell?
21:52:47 <johnw> now I know you're talking about the category of Purescript types and functions
21:52:49 <johnw> yeah, in Haskell too
21:52:49 <julianleviston> we seem to have this: https://hackage.haskell.org/package/semigroupoids
21:53:17 <johnw> note that (->) is a pretty boring semigroupoid; the idea here is to abstract the notion of morphisms without requiring identity
21:53:27 <julianleviston> sure
21:54:09 <julianleviston> johnw: I have a feeling identity is a deep deep subject I only really understand the surface of :)
21:54:22 <johnw> yeah, read a book on HoTT and your mind will spin
21:54:33 <julianleviston> johnw: homotopy type theory?
21:54:35 <johnw> yes
21:54:40 <julianleviston> ok
21:54:43 <johnw> it goes _deep_ into the concept of identity
21:54:48 <julianleviston> hehe :) sounds fun :)
21:55:09 <johnw> I was in a HoTT lecture that spent an hour on identity, and I felt like I'd never understood it before in my life
21:55:28 <johnw> funny how such basic notions can have profound implications
21:55:29 <julianleviston> aw I love it when that happens
21:56:00 <barrucadu> What's a good book to get on HoTT?
21:56:16 <julianleviston> johnw: Haskell did that to me when I first encountered it… I was like… I have never understood what a function is.
21:56:23 <johnw> haha, yeah
21:56:26 <johnw> same
21:56:55 <johnw> I spent a long time getting excited about typeclasses and monads before realizing that higher-order functions is where I should have been spending my time
21:57:12 <johnw> that and functors
21:58:03 <julianleviston> barrucadu: maybe ? http://homotopytypetheory.org/book/
21:58:15 <julianleviston> barrucadu: bodil seems to endore it on her twitter photo ;-)
21:58:24 <julianleviston> https://avatars2.githubusercontent.com/u/17880?v=3&s=400
21:58:37 <johnw> barrucadu: I'd start here: http://www.sandiego.edu/~shulman/papers/synhott.pdf
21:59:08 <julianleviston> johnw: ooh thanks :)
21:59:18 <julianleviston> endore = endorse
22:00:04 <julianleviston> how do you say ∞-groupoids ?
22:00:12 <julianleviston> infinity-groupoids?
22:00:16 <johnw> yes
22:00:23 <johnw> and not "infinite groupoids"
22:01:21 <julianleviston> Is Haskell generally still interested in destroying itself for correctness’ sake?
22:01:42 <julianleviston> I get the impression it’s sort of… settling a little…. or at least trying to draw a compromise between legacy and adjustment.
22:04:37 <johnw> "destroying itself"?
22:04:39 <kadoban> julianleviston: Sounds like a pretty trolly start to a conversation …
22:04:46 <johnw> if Haskell is no longer a research language, I haven't received the memo
22:04:50 <julianleviston> oh really?
22:04:56 <julianleviston> it was actually just a legitimate query
22:05:05 <julianleviston> apologies if it seemed trollish
22:05:23 <kadoban> julianleviston: I have a feeling you're asking a real question, I'm just not sure what it is.
22:05:33 <johnw> several groups of people have decided to settle on Haskell for various reasons, and so progress impairs their goals; but to my knowledge there is no one group that gets to decide what its future should be
22:05:59 <johnw> that would be a job for the new Haskell Prime committee, should it be formed soon
22:06:44 <julianleviston> Well purescript seems to be more on the “let’s do category theory… lots” vein. I was wondering about how Haskell fits into this, and why there even *needs* to be purescript, if Haskell was doing a good job of destroying itself enough (ie reinventing itself constantly)
22:06:54 <bitemyapp> What evidence is there for a self-destructive bent on correctness in Haskell?
22:06:57 <julianleviston> It was just a curiosity that popped into my mind.
22:07:09 <bitemyapp> there's all sorts of hilariously unsafe stuff in Haskell if I want to reach for it.
22:07:26 <bitemyapp> I can make a Haskell program segfault or shoot your iguana with a crossbow unexpectedly if I wanted.
22:07:36 <bitemyapp> I can do it without performing any apparent IO too
22:07:52 <bitemyapp> having nice defaults and not knowing the escape hatches doesn't mean you're in a straitjacket.
22:08:10 <bitemyapp> Now if you slap SafeHaskell on that module...yeah the Marshall's baton is aloft.
22:08:21 <julianleviston> bitemyapp: not too sure - are you talking to me?
22:08:32 <bitemyapp> idc i'm not really in the mood for conversation.
22:08:45 <julianleviston> bitemyapp: why are you talking?
22:08:48 <bitemyapp> twitter is being slow so I'm trying out sub-IRC'ing instead of sub-tweeting to see how it works
22:08:50 <julianleviston> bitemyapp: no offense! :)
22:09:06 <julianleviston> ah ok
22:09:14 <bitemyapp> taking offense requires more attachment than I am capable of
22:09:21 <julianleviston> sweet :) my kind of person :)
22:09:28 <bitemyapp> but yeah sure, you can take it as a reply to your weird comment
22:09:40 <julianleviston> ok… then I don’t understand
22:09:50 <julianleviston> my comment was actually a question.
22:09:50 <bitemyapp> Point is, I don't how to construe the original comment as being in good faith.
22:09:58 <julianleviston> in good faith of what?
22:10:03 <bitemyapp> so the only productive thing to do is to figure out where it comes from
22:10:26 <julianleviston> I’m wondering why there is so much category theory in purescript but not in Haskell “by default"
22:10:28 <julianleviston> I guess?
22:10:29 <kadoban> julianleviston: What exactly do you mean by "destroying itself"?
22:10:30 <bitemyapp> julianleviston: is there a specific feature, design decision, or aspect of the community that makes you think Haskell is (destructively?) bent on correctness at all costs?
22:10:52 <julianleviston> kadoban:  oh.. destroying itself as in… allowing massive change… not caring about backwards compatibility
22:10:56 <bitemyapp> looks like kadoban and I split the baby. kadoban gets destructiveness, I get correctness.
22:11:03 <kadoban> Haha
22:11:08 <julianleviston> bitemyapp: I think maybe you kinda misunderstood me… 
22:11:12 <johnw> fwiw, I think I understood julianleviston's original purpose in asking
22:11:26 <julianleviston> bitemyapp: I would PREFER if Haskell was destroying itself more.
22:11:29 <bitemyapp> julianleviston: in what way does GHC Haskell's change management communicate to you that it doesn't care about backwards compatibility?
22:11:31 <dinnu93_> moz.mkv
22:11:37 <johnw> he wants to know for how long we'll continue to be somewhat fearless in the name of progress
22:11:44 <julianleviston> bitemyapp: no you’re thinking the opposite. I mean that it *DOES*
22:11:48 <bitemyapp> there must be a negation I missed here
22:11:50 * bitemyapp scrolls up
22:11:53 <kadoban> julianleviston: Ah. Well I haven't been around forever, but the non-backwards-compatible changes I know of are really pretty minor. There's clearly some major focus on not breaking old things without some consideration.
22:11:56 <julianleviston> johnw: no no the opposite.
22:12:05 <johnw> julianleviston: oh?  haha
22:12:07 <julianleviston> kadoban: I would prefer there were MORE :)
22:12:08 <bitemyapp> fuckin' 'ell
22:12:10 <johnw> gotta love English over IRC
22:12:19 <bitemyapp> English sucks, lojban/esperanto pls
22:12:25 <bitemyapp> no no, Klingon
22:12:35 <bitemyapp> #MakeKlingonGreatAgain
22:12:45 <julianleviston> Eston… mi estas en progressivo en...
22:12:46 <julianleviston> jokes.
22:12:59 <bitemyapp> mi queso queso
22:13:16 <bitemyapp> julianleviston: what do you want to know? (preferably without oblique circumlocutions)
22:14:09 <julianleviston> bitemyapp: does Haskell want to keep reinventing itself, because it seems that it is more concerned with maintaining legacy stuff than reinventing itself.
22:14:15 <bitemyapp> julianleviston: I think John's answer about the Haskell Prime committee addresses incorporating pre-existing improvements and making room for new ones as they arise.
22:14:28 <johnw> yeah
22:14:29 <julianleviston> bitemyapp: obviously I’ve got some personification going on there, though.
22:14:34 <bitemyapp> julianleviston: I don't think there are good reasons for believing that at all.
22:14:41 <johnw> we've been lacking the concept of a formalish group to think about the language's future
22:14:50 <bitemyapp> julianleviston: 4/5 of the community that voted in the FTP poll supported FTP.
22:14:55 <julianleviston> bitemyapp: I didn’t understand your sentence… it seemed to have been missing a verb.
22:14:57 <johnw> right now we have various researchers contributing to GHC, without anyone making the claim that "GHC is Haskell"
22:15:15 <bitemyapp> julianleviston: the conversation post-FTP around better change management was with the implicit assumption of "more change, but how?"
22:15:24 <julianleviston> ah ok.
22:15:30 <julianleviston> cool :)
22:15:32 <bitemyapp> julianleviston: GHC 8.0 has some fairly radical changes, not all of them beneficial IMO, but they're happening anyway.
22:15:37 <julianleviston> I didn’t know this stuff.
22:15:39 <bitemyapp> johnw: can we talk about CallStack for a moment?
22:15:48 <julianleviston> bitemyapp: thanks :)
22:15:49 <johnw> sure; but what is CallStack?
22:15:51 <bitemyapp> johnw: I'd like to make sure Seidel's patch doesn't get abandoned
22:15:52 <julianleviston> johnw: and thanks :)
22:15:57 <bitemyapp> johnw: aw frick. Okay, you're gonna love this.
22:15:58 <bitemyapp> julianleviston: np
22:16:33 <bitemyapp> julianleviston: in general, the people actually contributing and driving the process are interested in a healthy balance of "keep improving and taking advantage of research" and "don't ruin industrial users' day"
22:16:54 <bitemyapp> julianleviston: even if I complain a lot about specific decisions, I genuinely believe this is the case.
22:16:58 <julianleviston> it’s a pity there’s not a place for “ruin everything”
22:17:03 <bitemyapp> well
22:17:10 <bitemyapp> julianleviston: that's pretty much Idris right now >:P
22:17:11 <julianleviston> and then the main haskell could pull the cool mature things into it
22:17:14 <julianleviston> ahhh
22:17:29 <bitemyapp> julianleviston: the ML got Edwin to change the syntax for overloading from class/instance, which I thought was hilarious/awesome
22:17:30 <julianleviston> I guess it’s a continual tug… between “use” and “innovation” :)
22:17:35 <bitemyapp> like, recently. after he started on the book
22:17:47 <julianleviston> what’s the ML?
22:17:50 <julianleviston> I thought ML was a language
22:17:52 <bitemyapp> julianleviston: not necessarily? Haskell does some fairly radical things compared to languages like C++
22:17:56 <bitemyapp> julianleviston: mailing list, apologies.
22:17:59 <julianleviston> bitemyapp: no doubt.
22:18:01 <julianleviston> ahhh cool
22:18:15 <bitemyapp> PureScript changes reasonably important things frequently'ish
22:18:21 <julianleviston> yeah
22:18:26 <julianleviston> I’d noticed :)
22:18:46 <bitemyapp> OCaml is focused on compiler improvements lately for the most part, which I'd actually like for 8.0 -> 8.4 but I don't know that anyone cares what I think :)
22:18:55 <bitemyapp> (GHC 8.0 -> 8.4 that is)
22:18:57 <julianleviston> poor OCaml.
22:19:03 <bitemyapp> it's not really a bad thing
22:19:04 <johnw> bitemyapp: tell me about CallStack :)
22:19:13 <julianleviston> yes, CallStack! :)
22:19:14 <bitemyapp> I think they're happy with their raft of features and just want faster/more capable RTS.
22:19:55 <bitemyapp> johnw: forwarded you two emails about it
22:20:35 <bitemyapp> johnw: I lied, three.
22:20:51 <johnw> got them
22:20:52 <bitemyapp> johnw: so the issue is that this is a bizarre thing to let the language infer at the top-level with no pragmas turned on, including implicit params.
22:21:34 <bitemyapp> johnw: further, this has the same asymptotic caveats as what the Monomorphism Restriction was designed to prevent AFAIK
22:22:05 <bitemyapp> johnw: ...and on top of all that, only error calls appear to benefit, implicitly encouraging users to use bottoms where exceptions or Maybe/Either would be better.
22:22:24 <johnw> "the same asymptotic caveats as what the Monomorphism Restriction was designed to prevent" -- what do you mean by that?
22:22:40 <bitemyapp> are implicit params not riding on the same dict passing mechanism as typeclasses?
22:22:48 <bitemyapp> As far as I knew they were, so you lose sharing.
22:22:54 <johnw> ah, I see
22:23:13 <johnw> Maybe wouldn't ever need a call stack though
22:23:21 <bitemyapp> I know, that's not my point.
22:23:27 <bitemyapp> My point is defaults and what we guide new users towards.
22:23:30 <johnw> true
22:23:49 <bitemyapp> error/undefined is not my ideal direction to point them in and ez-mode callstacks _will_ do that once they see it.
22:23:57 <johnw> you're suggesting that this way of implementing CallStack feels like a hack, and what's worse is that you have to teach around its existence now
22:24:05 <bitemyapp> johnw: it would be disastrous if new users were even more encouraged to use bottoms than is presently the case.
22:24:08 <mgsloan_> bitemyapp: Another usecase is logging
22:24:25 <mgsloan_> I am actually writing a library that makes uses of ?callStack right nwo
22:24:26 <bitemyapp> johnw: I think the implications/consequences are worse than that, but that's the near-to-hand immediate 'oh my god' reaction (hacky + I have to teach this?!)
22:24:38 <bitemyapp> mgsloan_: that's fine, but you need to ask for it w/ ImplicitParams.
22:24:47 <bitemyapp> mgsloan_: don't infer it without flags/pragmas at a minimum.
22:25:10 <mgsloan_> Right, is there a patch that would cause it to go everywhere?
22:25:22 <mgsloan_> TBH I wouldn't mind {-# LANGUAGE AutoCallStack #-}
22:25:26 <johnw> I am a bit surprised this isn't opt-in; but since I don't have a teaching burden, I'm not as concerned about it existing.  It's the sort of thing that one release might try, and another release might hide under a pragma if it doesn't work out.
22:25:30 <mgsloan_> Infact it'd make life a lot easier
22:25:45 <bitemyapp> it's not just about teaching
22:25:52 <mgsloan_> bitemyapp: I'm missing context.  Where's Eric's patch?
22:26:14 <bitemyapp> mgsloan_: https://phabricator.haskell.org/D1912
22:26:59 <bitemyapp> mgsloan_: the status quo in RC2 is not releaseable.
22:27:05 <bitemyapp> johnw: did y'all get my email to committee@ ?
22:27:17 <mgsloan_> I don't think making bottoms more debuggable will encourage them
22:27:58 <johnw> bitemyapp: we did!  thank you
22:28:43 <bitemyapp> part of what irritates me about this is that it doesn't work at all for exceptions out of the box.
22:28:47 <mgsloan_> bitemyapp: Oh dear, I had no idea the CallStack-as-typeclass had gotten this far
22:28:52 <mgsloan_> I thought it was only in discussion
22:28:55 <bitemyapp> mgsloan_: SEE
22:29:25 <bitemyapp> so no provision was made for the users doing the right thing _and_ it leaked into zero-pragma uses of bottoms in GHCi.
22:29:44 <mgsloan_> Oh wait, nvm. Is "HasCallStack" a constraint synonym for (?callStack :: CallStack) ?
22:31:01 <mgsloan_> I saw some mention of an idea that we'd have some magic "AppendsCallStack" typeclass
22:31:06 <mgsloan_> And ditch implicit parameters
22:32:11 <mgsloan_> However, this idea introduces a subtle issue.  Implicit params are actually a good fit, because they can't be used as superclass constraints
22:32:29 <mgsloan_> Things go real wonky if AppendsCallStack can be a superclass constraint
22:32:56 <johnw> mgsloan_: and thus accessible as a Constraint kind :)
22:33:04 <johnw> implicits do have the right amount of dumbness
22:33:32 <bitemyapp> Not caring about teaching is not exactly an encouraging stance to take on something like this.
22:33:51 <bitemyapp> People complain about not having enough contributors for GHC, libraries, documentation. Labor doesn't grow on trees.
22:33:56 <johnw> bitemyapp: I guess #ghc might be a better place to ask why this is headed into release without more vetting
22:34:03 <bitemyapp> johnw: please.
22:34:28 <johnw> I meant that in a constructive way, actually
22:34:47 <mgsloan_> johnw: I thought implicit parameters did inhabit the Constraint kind!  You can put them in constraint synonyms: https://ghc.haskell.org/trac/ghc/ticket/11466
22:34:53 <johnw> I don't want to see your complaints go unheard here
22:34:56 <julianleviston> johnw: as in… you might get more feedback from people who care there?
22:35:01 <johnw> yeah, precisely
22:35:05 <bitemyapp> johnw: no disagreement here, I'm glad we're moving it.
22:35:14 <johnw> ah, that meaning of "please."
22:35:16 <johnw> IRC again
22:35:51 <johnw> there is "please.", as in, why are you talking crazy, and "please.", as in, yes, let's!
22:36:16 <bitemyapp> johnw: latter
22:40:10 <julianleviston> I actually wonder why we still use English to talk with precision.
22:40:46 <julianleviston> or attempt to.
22:41:36 <bitemyapp> expressive vocabulary
22:42:32 <julianleviston> Still, it doesn’t seem to be very precise.
22:43:07 <johnw> look at how hard we try to make Haskell more precise
22:43:25 <julianleviston> johnw: isn’t Haskell pretty precise?
22:43:29 <johnw> hah
22:43:54 <julianleviston> I guess not then? :)
22:43:55 <julianleviston> lol
22:43:55 <johnw> Haskell beauty somewhat lies in its imprecision, actually
22:44:18 <julianleviston> johnw: can you help me to see the imprecision? 
22:44:34 <julianleviston> johnw: sorry, I just don’t see it yet.
22:44:40 <Cale> julianleviston: Use Coq or Agda
22:44:58 <julianleviston> Cale: you can’t just explain to me why Haskell is not precise easily?
22:45:10 <Cale> In Haskell, it's never a type error to swap the branches of an if expression.
22:45:27 <julianleviston> Cale: like… [1,2,3] means [1,2,3], doesn’t it? That’s reasonably precise, isn’t it?
22:45:49 <Cale> Haskell's type system can't be used as a foundations for mathematics
22:46:06 <julianleviston> Cale: no but it’s vastly more precise than English isn’t it? :)
22:46:14 <johnw> julianleviston: for example, in Haskell Mu and Nu are isomorphic, something that is not true in Coq
22:46:31 <johnw> yeah, it's way more precise than English :)
22:46:56 <julianleviston> johnw: although, I guess the lexicon depends on the reader! :)
22:47:31 <julianleviston> johnw: I mean that differenly named things cojur different semantics to different readers… but invariably the same semantics to the computer… I suppose.
22:47:39 <johnw> also, in Haskell inductive and coinductive types are expressed by the same type system, thanks to laziness
22:48:18 <bitemyapp> johnw: may want to tie this into turing completeness and proofs that can be verified
22:48:33 <johnw> yeah, Cale said it wasn't a formal logic
22:48:36 <bitemyapp> johnw: most people won't know the implications of what you're saying until they already know the point
22:48:45 <bitemyapp> johnw: yes but they don't know why it isn't suitable as one
22:49:02 <johnw> it's nice that in Haskell you don't have to convince the type checker of termination
22:49:03 <Cale> Well, it is a formal logic, it's just... not a very good one if you want to talk about what is true.
22:49:15 <Cale> (because the answer is that everything is true)
22:49:23 <johnw> formally vacuous
22:49:27 <julianleviston> Cale: do we actually have a formal logic that *can* express waht is true?
22:49:31 <johnw> but still practical
22:49:32 <julianleviston> Cale: anywhere?
22:49:38 <Cale> julianleviston: Yeah, anything consistent
22:49:38 <bitemyapp> johnw: and mention of Mu/Nu or inductive/coinductive types won't reach the other side of the lacuna unless they already know most of what you're talking about and you're trying to evoke a memory recall rather than convey something new.
22:49:50 <johnw> Coq, Agda, Isabelle, ACL2, etc.
22:49:59 <Cale> julianleviston: I mean, every logic gives you some kind of an answer to that
22:50:05 <bitemyapp> johnw: for most people you'd have to start with bottom/falsum
22:50:15 <johnw> bitemyapp: I'm hoping for follow-on questions when I hit a subject of interest
22:50:15 <bitemyapp> and its relationship to logics/proofs
22:50:18 <Cale> julianleviston: It's just that the answer that you get from interpreting Haskell's type system as a logic is not a very interesting one.
22:50:41 <bitemyapp> johnw: they wouldn't know what to ask.
22:50:50 <johnw> bitemyapp: like, "what is Mu"?
22:51:19 <julianleviston> they might actually just look things up on the internet if they needed to know. :)
22:51:27 <bitemyapp> johnw: roundabout way of getting there, most will sniff that it's far'ish from the part that would begin to click up to the rest of what they're thinking about and not bother to ask at all.
22:51:44 <bitemyapp> looking up Mu on Google won't naturally lead to any points about turing completeness.
22:51:47 <tdammers> we have plenty of formal logics that can express truth in a meaningful way; we just don't have one that can express *all* truths in a meaningful (i.e., consistent) way
22:52:17 <bitemyapp> You can see it as sort of a path compactness optimization.
22:52:27 <Cale> When I say "truth", I really just mean "the statements that the logic determines to be true"
22:52:42 <tdammers> fair enough
22:52:43 <Cale> I'm not really talking about interpretation.
22:52:45 <julianleviston> I guess the assumptive cases are the problem there.
22:52:50 <bitemyapp> it's generally more efficient to start with something nearer-to-hand and expand if they show interest. Then if they weren't _that_ interested they get something rather than nothing.
22:53:03 <julianleviston> bitemyapp: I don’t really agree with that.
22:53:08 <johnw> bitemyapp: we each interact on IRC the way we wish to
22:53:29 <bitemyapp> johnw: oh for sure, but if anyone else picks up on my point, all the better.
22:53:36 <johnw> fair
22:53:48 <julianleviston> everyone has something different nearer-to-hand.
22:53:49 <bitemyapp> johnw: your approach is very common in the Haskell community among experienced folk
22:54:10 <tdammers> and I guess the thing with a general-purpose programming language is that it is more convenient to make it slightly wrong in order to make it more useful
22:54:45 <julianleviston> tdammers: yeah, convenience is usually more wrong because it’s easier to do it that way… a bit ironic :)
22:54:54 <johnw> tdammers: yes, Haskell allows for some elegant flexibility that would break the proof-oriented nature of more formal systems
22:55:27 <bitemyapp> Having fought a few different termination checkers before, I can say that I'm grateful there isn't one on by default in Haskell but I wouldn't mind having an optional one.
22:55:40 <bitemyapp> strict positivity would break a fair few idioms in Haskell as well, I think.
22:55:40 <johnw> Idris has a nice optional system for termination checking
22:55:43 <ReinH> johnw: it turns out that absurdity is actually kind of useful in practice...
22:55:50 <bitemyapp> ReinH: cf. Dadaism
22:55:52 <johnw> and even in Coq, you can "admit" the termination proof
22:55:57 <ReinH> bitemyapp: heh
22:56:11 <Cale> julianleviston: Okay, so by way of example of what dependent types give you, we can define what's called an identity type, for each type A and each x and y of type A, we have a type Id A x y (which is also sometimes written x = y, leaving A implicit)
22:56:14 <bitemyapp> Dadaist Type Theory
22:56:19 <julianleviston> ReinH: is recursion a bit absurd?
22:56:33 <johnw> night all
22:56:37 <bitemyapp> night
22:56:46 <Cale> julianleviston: and there is a single data constructor,  Refl : forall (A : Type), forall (x : A), Id A x x
22:57:10 <julianleviston> Cale: what are we doing now?
22:57:20 <julianleviston> Cale: haha sorry, I didn’t realise I’d asked about dependent types.
22:57:45 <Cale> julianleviston: Basically, I want to show you an example of something that some other existing systems give you which makes Haskell look fuzzy around the edges :)
22:58:21 <julianleviston> Cale: ah. Yeah, I’m aware that Haskell is less precise than Idris and Coq.
22:58:27 <julianleviston> Cale: no need to spend your effort.
22:58:40 <Cale> julianleviston: The idea here is that using these identity types, we can express proofs that things are equal, and have our typechecker actually check that the proofs are correct :)
22:58:48 <julianleviston> Cale: My argument was about English and wondering why we don’t use a slighly more precise communication medium :)
22:59:20 <Cale> If you're sufficiently careful about your use of English, you can be precise with it too.
22:59:34 <julianleviston> Cale: yes, but there’s no TELLING what the other folk will do with it ;-)
22:59:42 <julianleviston> Cale: (when they hear it)
23:00:05 <julianleviston> but it might not be a problem with English ;-) as you allude to.
23:00:06 <Cale> It isn't very well-specified what English consists of.
23:01:19 <Cale> But when mathematicians communicate in funny-mathematician-English, it can be precise *enough* that the ability to formalise something completely has been transmitted from one person to the other (without it necessarily being the case that either of them has actually done that work)
23:02:18 <julianleviston> indeed.
23:16:45 <[AN]onymous> SellingBusiness Credit Cards Minimum $1000 Balance $50/card, 5+ Cards for $25each #CVV or PM ME Accepting BTC Only
23:17:23 <Hijiri> mega illegal
23:17:26 <Hijiri> @where ops
23:17:26 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
23:18:45 <julianleviston> Cale: is here.
23:19:01 --- mode: ChanServ set +o dibblego
23:19:12 --- mode: ChanServ set +o Cale
23:19:24 <Cale> oh, already gone
23:19:59 <Cale> I don't know if there's a point to banning even, that'll probably get a K-line soon enough.
23:20:04 --- mode: Cale set -o Cale
23:36:21 <xtreak> Hi I was reading about monads with the code from http://lpaste.net/153920 at https://wiki.haskell.org/All_About_Monads. I couldn't understand how the infix function `comb` works.
23:38:59 <xtreak> (Just s) `comb` mother. So when s is Nothing. will it be passed as `Just Nothing` to comb. I tried replacing mother and father with (+2) and (+4) and passed (Just 5) but it causes an error. will be happy to know how it works when `s` is Nothing
23:39:36 <lyxia> s can't be nothing, it's a sheep
23:40:52 <lyxia> and comb only matches on the outer constructor, which here is Just
23:41:36 <lyxia> so the second rule of comb applies, and comb (Just s) mother reduces to mother s.
23:42:07 <julianleviston> Cale: man… Idris natural numbers. How cool! :) Using Peano arithmetic. 
23:42:34 <pavonia> xtreak: Also, the second parameter of com must be of type (a -> Maybe b). Neither (+2) nor (Just 5) satisfy this type requirement
23:44:12 <xtreak> It seems the definition for sheep is missing and hence I am lost there. it will be helpful to see the definition/example with the type defined
23:45:24 <pavonia> The definition doesn't matter here, it could be any data type
23:49:25 --- mode: dibblego set -o dibblego
23:50:02 <xtreak> a code example will be helpful with the type
23:52:44 <pavonia> You could use "type Sheep = Int" as an example
