00:04:13 <cocreature> MarcelineVQ: I suppose curl -s rawurl > /tmp/tmp.hs && ghci /tmp/tmp.hs doesn’t count? :)
00:06:27 <MarcelineVQ> I did arrive at that route shortly after asking, thank you very much for your answer though. I was hoping I could pipe without an intermediate file but it seems to send the lines to ghci individually which it's not impressed by
00:08:42 <dominik> Hey¸ could anyone explain to me the difference between universal and existential types?
00:09:01 <dominik> I believe universal types are the ones id :: forall a. a -> a
00:09:13 <dominik> meaning that the id function has to work on _all_ a
00:09:19 <dominik> or on any a
00:09:45 <dominik> and thus (by parametricity) _must_ implement the id function
00:09:53 <dominik> but what do existential types do?
00:10:03 <dominik> and why do we also use forall to use them?
00:10:38 <mniip> existential types are the opposite
00:12:15 <dominik> hmm, ok. But why do we use forall to introduce them?
00:12:31 <mniip> because the two are related
00:12:39 <mniip> in fact they are kind of the opposite of each other
00:16:48 * hackagebot hflags 0.4.1 - Command line flag parser, very similar to Google's gflags  https://hackage.haskell.org/package/hflags-0.4.1 (MihalyBarasz)
00:16:52 <mniip> uh
00:17:03 <mniip> my knowledge in this area is wonky
00:19:26 <jle`> dominik: you know, i really don't understand why the 'forall' keyword is used for the ExistentialTypes extension
00:19:44 <jle`> a part of me thinks it's just because they didn't want to reserve another keyword
00:19:52 <mniip> jle`, you mean the data F = forall a. F a thing?
00:19:56 <jle`> but, you can implement existential types with universal quantification
00:19:58 <jle`> yes, that
00:19:59 <mniip> or is that something else
00:20:08 <jle`> yes, that's what i mean; the choice of the 'forall' keyword there
00:20:14 <mniip> idunno, that makes perfect sense to me
00:20:50 <cocreature> it makes somewhat sense. it is used on the constructor so since the constructor has to work over any a you only know that there is some a when you pattern match it
00:20:52 <mniip> you're probably looking at it from the contravariant aspect of *constructing* the value
00:20:54 <cocreature> *on it
00:21:01 <mniip> as opposed to the covariant aspect of pattern matching it
00:21:20 <jle`> ah yeah. i guess that is a nicer perspective
00:21:50 <mniip> "exists" is just a contravariant "forall"
00:21:50 * hackagebot persistent-template 2.1.6 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.6 (MichaelSnoyman)
00:21:52 * hackagebot persistent 2.2.4.1 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.4.1 (MichaelSnoyman)
00:21:53 <jle`> dominik: one of the more common existential types people talk about is (exists a. Show a => a), which is a value that is *some* specific instance of Show, but you don't know which one it is, all you know is that it implements Show
00:21:55 * hackagebot persistent-sqlite 2.2.1 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.2.1 (MichaelSnoyman)
00:22:37 <jle`> so, if you had x :: exists a. Show a => a, the only thing you can really do is, well, use a `forall a. Show a => a -> b` function on it
00:23:13 <jle`> dominik: the only thing you can *use* on an existential type is things that are guarunteed to work over *all* possible types you could have
00:23:32 <mniip> forall a. Show a => a -> b
00:23:33 <mniip> =
00:23:38 <jle`> having naked existential types like that in Haskell makes things wonky, so we don't actually have it implemented
00:23:39 <mniip> (exists a. Show a => a) -> b
00:24:30 <jle`> but we can "simulate" it ... we can simulate an (exists a. Show a => a) as a ((forall a. Show a => a -> r) -> r)
00:25:00 <mniip> needs more forall r I think?
00:25:02 <jle`> so it turns out we don't have to build naked existentials into our language, we can just use the cps transformation
00:25:18 <jle`> which uses RankN types
00:26:36 <jle`> yeah, a top-level forall r, heh, easy to forget ><
00:27:30 <jle`> but, Haskell has a built-in language feature that lets us wrap and extract away existential types in a nice way using existential constructors, which is kind of neat, too
00:27:58 <jle`> data Showable where S :: Show a => a -> Showable
00:28:21 <jle`> or data Showable = forall a. Show a => S a, i think the equivalent non-gadt form is?
00:28:31 <mniip> yes
00:28:34 <cocreature> I mostly use existentials to hide gadt type arguments and then later recover them using pattern matching
00:28:45 <cocreature> and then ghc complains about non exhaustive pattern matches and I’m sad
00:29:14 <jle`> note that when you *pattern match* on `S x`, the only thing you can do with the 'x' are things you can do with *all* Show's, things that you can do define paraemtrically over all Show's
00:29:32 <jle`> cocreature: i hear there were some big improvements in that for ghc 8? :o
00:29:42 <cocreature> jle`: yeah I haven’t yet tried if they work in this case
00:29:50 * cocreature starts building ghc
00:29:59 <mniip> which reminds me
00:30:03 <mniip> I should check my ghc build
00:30:05 <mniip> oh it failed
00:30:17 <jle`> dominik: it might be fun to think about why having a 'Showable' and being able to pattern match on S is equivalent to ahving something of type forall r. ((forall a. Show a => a -> r) -> r)
00:30:43 * mniip whispers: there's an isomorphism!
00:30:45 <jle`> if you're familiar with church encoding or scott encoding, the latter sort of kind of resembles the church encoding of the Showable constructor
00:31:16 <dominik> jle`, cocreature, mniip: wow, thanks for these thorough replies! I have to digest what you've written :D
00:31:59 <jle`> like how `Maybe a` is equivalent to a forall r. (r -> (a -> r) -> r)   -- give it a way to handle the 'Nothing' case (the 'r') and a way to handle the 'Just' case (the (a -> r)), "deconstruct" any given Maybe
00:32:44 <jle`> so a 'Showable' is equivalent to a forall r. ((forall a. Show a => a -> r) -> r) -- give it a way to handle the 'S' case, with the value inside ... but make sure that the function you use has to be able to handle *any* Show instance, parametrically
00:34:23 <jle`> reading over what i just said, there's a good chance it only makes sense if the reader already understands existential types v.v
00:34:38 <jle`> im sory
00:35:24 <dominik> jle`: it's all good, I think it actually quite helps!
00:35:36 <jle`> sweet!
00:35:38 <dominik> thanks :-)
00:35:55 <jle`> np
00:36:52 <jle`> the 'existential constructor' version is nice because it lets you avoid impredicative types
00:37:38 <jle`> if you wanted [exists a. Show a => a], then [(forall a. Show a => r) -> r] is an impredicative type, so that's no good.  [Showable] is perfectly fine, howerver
00:38:05 <jle`> in a lot of libraries with existential types they'll often give you both varities
00:38:17 <jle`> but some don't and it can be frustrating >____________>
00:39:03 * jle` has some unresolved PR's on a few libraries
00:40:14 <jle`> the cps'd version is nicer in a lot of cases because it doesn't force you into the awkward pattern match when you can just do withFoo $ ...
00:40:30 <jle`> and it doesn't pollute the namespace with an extra constructor i guess
00:40:44 <jle`> don't mind me, i'm just ranting at this point :)
00:41:16 <ggVGc> is it possible to bind the match to the name `cell` within the pattern match here? https://gist.github.com/c5cdbe647f32b20e1cd3
00:41:21 <ggVGc> scala has some functionaloty for this
00:41:34 <dmwit> InDown cell@(GridXY x y) ->
00:41:57 <ggVGc> I want to refer to the matched content, but also to the whole, but don't want to introduce another match for a default case
00:42:02 <dmwit> Generally `name@pat` matches when `pat` does and binds `name` to the entire value matched by `pat`.
00:42:14 <ggVGc> thanks
00:42:23 <ggVGc> that's what I was looking for :)
00:43:04 <dmwit> You might need more parentheses, I always find myself getting surprised by the quirks of parenthesization with `@`.
00:43:26 <dmwit> One day I should just sit down and really learn the rules, but it's such an infrequently-used feature that it hardly seems worth the effort.
00:44:46 <cocreature> oh no lpaste is down
00:46:35 <tdammers> the end is nigh
00:46:51 * hackagebot werewolf 0.4.6.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.6.1 (hjwylde)
00:50:08 <tdammers> LambdaCase for monadic code is awesome
00:50:14 <tdammers> I just discovered this pattern:
00:50:21 <tdammers> doSomeStuff >>= \case
00:50:57 <tdammers> i.e., run an action, then pattern-match on the result
00:51:31 <parsecChar> where is the official code associated with https://web.cecs.pdx.edu/~mpj/thih/ ? I have found a few on Github, but none seems to be by the author Mark JOnes
00:51:38 <parsecChar> is there an 'official release' of THIH code ?
00:54:07 <cocreature> parsecChar: there is code linked on the website
00:54:23 <parsecChar> I see a link for the multiparam version
00:54:25 <parsecChar> but not the original version
00:54:31 <nocturne777> do most people create an Import.hs file to import regularly used stuff easily? is this a good practice?
00:54:32 <cocreature> “A gzipped tar file, for use on Unix machines: (thih-Nov23-2000.tar.gz). ”
00:54:36 <parsecChar> oh
00:54:37 <parsecChar> I see it now
00:54:39 <parsecChar> thanks
00:55:50 <merijn> tdammers: That's the main reason LambdaCase exists :p
01:02:48 <dmwit> nocturne777: I don't see that in many packages.
01:03:23 <nocturne777> dmwit: I think being explicit is better
01:03:36 <dmwit> I agree.
01:03:38 <nocturne777> I like the format followed in the cloud haskell project
01:13:51 <haskell521> I have a list of file ids :: FileId and a IO function readNameFromFileById :: FileId -> IO String. What would be the best way to get `IO [(FileId,String)]`?
01:14:09 <Lokathor> http://lpaste.net/154225 is there a code difference between these two ways to lay out the let bindings?
01:14:12 <haskell521> *ids :: [FileId]
01:14:33 <Lokathor> like, does the second form make them all part of "one" let and allow for reordering or anything like that while the first form doesn't?
01:15:36 <lyxia> Lokathor: in the first snippet the second set of definitions can shadow the first
01:16:06 <lyxia> whereas if you try the same in a single let you get a conflict, because definitions there are not ordered
01:16:38 <Lokathor> hmm, but other than that ghc will produce the best version of the code either way?
01:16:45 <Lokathor> or should i marge all my lets into one big let at the start?
01:16:52 * hackagebot werewolf 0.4.7.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.7.1 (hjwylde)
01:17:07 <Lokathor> cause i got like 9 of 'em in this one function
01:17:16 <lyxia> I don't think it has any effect on the compilation result.
01:17:26 <Lokathor> okay
01:20:11 <lyxia> haskell521: mapM (\i -> (,) i <$> readNameFromFileById i) ids
01:20:45 <haskell521> lyxia: thanks
01:21:06 <lyxia> yw
01:24:01 <mniip> lyxia, why <$> and not .
01:24:17 <mniip> actually
01:24:22 <mniip> oh
01:24:24 <mniip> nevermind
01:24:31 <mniip> <$> goes on the IO
01:25:35 <lyxia> :t \f -> (liftA2 . liftA2) (,) pure f
01:25:36 <lambdabot> Applicative f => (a -> f b) -> a -> f (a, b)
01:26:24 <lyxia> oh he's gone. But well there's that ^. Do you find that unreadable?
01:27:28 <ggVGc> How do I call a function a->a on an A, n times?
01:27:49 <ggVGc> passing intermediate values to each invocation
01:28:09 <mniip> :t iterate
01:28:10 <lambdabot> (a -> a) -> a -> [a]
01:29:45 <ggVGc> mniip: is there an iterate that just returns the final value?
01:29:57 <ggVGc> oh, wait
01:29:59 <ggVGc> I misunderstood
01:30:00 <ggVGc> nice
01:30:02 <dmwit> :t \n -> (!!n) . iterate
01:30:03 <lambdabot>     Couldn't match type ‘a -> [a]’ with ‘[c]’
01:30:03 <lambdabot>     Expected type: (a -> a) -> [c]
01:30:03 <lambdabot>       Actual type: (a -> a) -> a -> [a]
01:30:12 <dmwit> :t \f n -> (!!n) . iterate f
01:30:13 <lambdabot> (c -> c) -> Int -> c -> c
01:36:52 * hackagebot werewolf 0.4.8.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.8.0 (hjwylde)
01:38:35 <jle`> unfortunately you can get some unwanted space leaks that way, without a strict iterate or strict !!
01:38:45 <jle`> i often have to define my own every time v.v
01:41:53 * hackagebot ginger 0.1.6.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.6.0 (TobiasDammers)
01:52:24 <Gurkenglas> strict !!? How'd that work on an infinite list? (The index may as well be constant, right?)
01:53:52 <mniip> jle`, by the way
01:54:00 <mniip> the other day I was toying around
01:54:05 <mniip> and then it hit me
01:54:15 <mniip> data N = S N | Z
01:54:21 <mniip> when church-encoded, becomes
01:54:26 <mniip> (r -> r) -> r -> r
01:56:54 <jle`> Gurkenglas: it'd be forcing the elements of the list as it goes along
01:56:59 <jle`> mniip: pretty neat :o
01:57:50 <jle`> the problem with iterate f x !! n is that you build up a big f (f (f (f .. x))) to evaluate and do it all at once, but if you force items as you go along then you avoid that
01:58:15 <Gurkenglas> (Assuming of course that f itself is strict)
01:58:25 <mniip> but the produced list is data-shared, isn't it
01:59:06 <dmwit> mniip: Doesn't matter, you're only accessing one element anyway.
01:59:07 <mniip> so you have like let x1 = f x0; x2 = f x1; x3 = f x2 ... in x0:x1:x2:x3:...
01:59:22 <mniip> sure
01:59:23 <jle`> not sure if f being strict has much to do with it either
01:59:47 <jle`> you need to have a "strict" !! or a strict iterate
02:04:09 <mniip> :t \f n x -> foldr (const f) x [1..n]
02:04:10 <lambdabot> (Enum b1, Num b1) => (b -> b) -> b1 -> b -> b
02:05:41 <Gurkenglas> jle`, a lazy f might not need all the previous results, so you ought not to evaluate them prematurely
02:05:49 <jle`> ah i se what you mean
02:07:57 <Gurkenglas> :t [fmap runIdentity . evalStateT . manyLazy . StateT, unfoldr] -- using http://lpaste.net/150858
02:07:59 <lambdabot> [(s -> Maybe (a, s)) -> s -> [a]]
02:08:16 <Gurkenglas> (That fmap is (.), but people don't like reading (.) for some reason :P)
02:11:37 <merijn> jle`: !! *is* strict
02:11:54 * hackagebot scientific 0.3.4.5 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.5 (BasVanDijk)
02:12:01 <jle`> it's not strict on the elements of the list
02:12:07 <jle`> > [undefined,undefined,10] !! 2
02:12:09 <lambdabot>  10
02:12:21 <merijn> Well, no. That'd be stupid
02:12:41 <jle`> well, strict behavior is useful for things like the iterate f x !! n pattern
02:12:52 <jle`> but yeah, it wouldn't really be called a "strict !!"
02:12:55 <merijn> Then you want strict iterate, not strict !!
02:13:12 <jle`> a "strict !!" works :O but strict iterate is probably what you should want, yeah
02:13:57 <mniip> yeah, you want, iterateN f 0 x = x; iterateN f n !x = iterateN f (n - 1) (f x)
02:13:58 <mniip> I think
02:14:57 <mniip> "It's just a simple functional language"
02:15:09 <dmwit> said nobody ever
02:15:37 <mniip> that's kinda the joke here, yes
02:27:18 * hackagebot ginger 0.1.7.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.7.0 (TobiasDammers)
02:39:43 <Aruro> Is there a database written in Haskell?
02:43:06 <mniip> Aruro, "database" is a bit broad...
02:43:22 <mniip> Bool is a database that fits a single logical value
02:45:04 <average> https://cagesongonearth.wordpress.com/2016/01/29/a-haskell-vs-perl-performance-case/
02:45:13 <average> guy complains about List being immutable in Haskell
02:45:25 <average> which lead him to switch to STUArray instead
02:46:18 <average> he feels like this ruined his entire elegance motivation around using FP
02:46:45 <average> thoughts ?
02:47:50 <dibblego> misguided
02:48:13 <average> ok..
02:48:17 <paolino> hello, looks like 1500 is a stable  population here :-)
02:48:27 <opqdonut> average: see https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
02:49:00 <paolino> does fmap . lmap has a name? 
02:49:10 <opqdonut> average: but yeah, trying to get ultimate performance in haskell often ends up in writing c-like haskell
02:49:31 <opqdonut> average: consider how cool it is that haskell lets you do that _and_ write terse functional code
02:50:25 <opqdonut> average: but as that pdf shows in this case (and many others) there are efficient functional implementations too
02:50:28 <dibblego> paolino: the "composition of functors" and that specific composition of fmap and lmap manifests in TypeCompose
02:51:38 <dibblego> https://hackage.haskell.org/package/TypeCompose-0.9.11/docs/src/Control-Compose.html#contraFmapFC
02:52:24 <paolino> argh
02:55:01 <paolino> it's always like this every time I make a big enlighting step, a new wall step upfront
02:55:03 <average> "But, despite fooling some of us for years, the
02:55:03 <average> algorithm we began with isn’t the real sieve, nor is it even the most efficient one
02:55:04 <average> liner that we can write."
02:55:12 <echo-area> mtl is used to write more abstract functions than transformers, right?
02:55:12 <average> opqdonut: from your article above ^^
02:55:52 <average> I see this as sort-of a debunking of the "magical" powers of FP
02:56:32 <average> which exchange performance & control for brevity & excitement
02:56:47 <average> Haskell has excellent marketing though.. I see it every time I'm on Reddit
02:56:58 <opqdonut> it really is an excellent language
02:57:04 <xa0> are you by any chance subscribed to /r/haskell? :p
02:57:05 <paolino> thanks dibblego, do you use it daily (TypeCompose)?
02:57:12 <average> I could never blame anyone in the Haskell community for scoring low on the Marketing aspect
02:57:17 <opqdonut> but it's not a magic bullet
02:57:18 <mniip> opqdonut, oh wow
02:57:24 <dibblego> paolino: I do not, I'd just use fmap . lmap
02:57:29 <mniip> took a while to understand why that, indeed, is not a sieve
02:57:37 <paolino> :-)
02:57:39 <dibblego> paolino: it is just an observation that this composition itself forms a new functor
02:58:17 <paolino> fmap . lmap deserve a name
02:59:20 <Gurkenglas> Does fmap . rmap too?
02:59:50 <paolino> does it compose ?
02:59:58 <paolino> :t fmap . rmap
02:59:59 <lambdabot> (Functor f, Profunctor p) => (b -> c) -> f (p a b) -> f (p a c)
03:00:31 <Gurkenglas> Not to forget rmap . fmap and lmap . fmap
03:00:42 <paolino> :t fmap . lmap
03:00:43 <lambdabot> (Functor f, Profunctor p) => (a -> b) -> f (p b c) -> f (p a c)
03:00:44 <Gurkenglas> Or lmap . rmap, fmap . fmap, etc.
03:01:09 <average> would you say most people using Haskell like to bench/profile their code to at least informally verify if their Haskell implementation has the complexity they would expect of it ?
03:01:39 <dmwit> No. Would you say most people using other language X like to do that?
03:02:31 <oherrala> average; as with any other language, you'll build the skills and toolset to reason about performance of code
03:03:13 <oherrala> for example writing code with the mindset that "list is immutable" gets you far already :)
03:03:13 <dmwit> Heck, I would be shocked if you could even find *one* person that liked doing that in their favorite language.
03:03:20 <Gurkenglas> > map (intercalate " . ") $ replicateM 3 ["fmap", "lmap", "rmap", "bimap"] -- As long as it's a function, you can plug it into either of them
03:03:23 <lambdabot>  ["fmap . fmap . fmap","fmap . fmap . lmap","fmap . fmap . rmap","fmap . fmap...
03:03:36 <tdammers> depends on what you're writing, I'd wager
03:04:03 <tdammers> if you're building some sort of standard containers library, you better put some work into verifying the algorithmic complexity of your code
03:04:20 <tdammers> but in most other cases, I wouldn't bother
03:04:26 <tdammers> regardless of language
03:05:01 <average> tdammers: I see, the problem is that Haskell prides it self very much on the mathematical aspects
03:05:16 <dmwit> troll detected
03:05:26 <average> tdammers: and coincidentally, this is in the backyard of complexity theory
03:05:33 <tdammers> yes, so?
03:05:48 <average> it's also the difference of getting problems accepted or not in online judges
03:06:06 <xa0> it's also two different ends of maths, really
03:06:15 <tdammers> if anything, that means it should be slightly easier to reason about algorithmic complexity without resorting to simulation tests
03:06:58 <tdammers> and, yes, the kind of mathiness that went into Haskell isn't very related to complexity theory at all
03:07:27 <tdammers> the kind of guarantees and assertions you can get out of Haskell are more closely related to category theory and such
03:07:47 <average> I see, ok
03:07:50 <tdammers> in terms of algorithmic complexity, Haskell is not a terrible lot easier to reason about than other languages
03:07:56 <tdammers> (my $0.02 anyway)
03:08:32 <mniip> 1457434661 [13:57:41] <paolino> does it compose ?
03:09:08 * mniip pictures edwardk holding a Total Composer and asking the audience whether something composes and then turning on the composer and showing that indeed, it does
03:11:15 <average> dmwit: whatever your name-calling/pigeonholing thing is..
03:11:40 <average> dmwit: with an avalanche of new languages up & coming on the market, I think it's important to understand what their communities care about
03:12:31 <paolino> > let sneak = fmap .rmap; filter = fst `sneak` partition in filter odd [1..10]
03:12:33 <lambdabot>  [1,3,5,7,9]
03:13:05 <mniip> :t fmap . rmap
03:13:06 <lambdabot> (Functor f, Profunctor p) => (b -> c) -> f (p a b) -> f (p a c)
03:13:27 <mniip> what sorcery is this
03:13:41 <paolino> there is only one sorcery
03:13:54 <Gurkenglas> just lensing down a function through a functor, then the right side of a profunctor
03:14:02 <mniip> right
03:14:12 <mniip> oh
03:14:14 <xa0> wat
03:14:18 <mniip> I forgot what partition does
03:14:23 <mniip> I was thinking of break/span
03:14:39 <mniip> hence my confusion
03:14:51 <Gurkenglas> (or lifting it up a profunctor, then a functor, to easy xa0s wat i think)
03:15:21 <xa0> yeah
03:15:22 <Gurkenglas> (though i should not say it there, since it refers to another function.)
03:15:40 <paolino> > let sneak f g = (f .) . g; filter = fst `sneak` partition in filter odd [1..10]
03:15:42 <lambdabot>  [1,3,5,7,9]
03:15:55 <mniip> sneak = (.) . (.)
03:16:01 <mniip> sneak = fmap fmap fmap
03:16:31 <Gurkenglas> Ah, I call that (.:). f . g = f $ g x, f .: g = f . g x
03:16:53 <mniip> I prefer spelling (f .) . g
03:18:05 <Gurkenglas> See also yesterdays (?) discussion about polyvariadic compose ($.$), though I can't find it in the logs, weird.
03:18:42 <Gurkenglas> <liste>	https://jaspervdj.be/posts/2014-10-17-generalizing-function-composition.html
03:18:49 <Gurkenglas> Also "<mniip>	liste, woahdude" :D
03:19:17 <mniip> I was wondering about the abundance of type families
03:19:52 <mniip> I haven't tested yet, but I feel like there's no need to have a typeclass mimic a type family like this
03:19:55 <Gurkenglas> Wait shouldn't that be possible using the same trick printf does?
03:20:02 <mniip> no
03:20:48 <paolino> It looks like profunctors can be used in everyday programming, maybe the sneak example is not the right one
03:20:52 <mniip> hmm, I wonder
03:22:05 <mniip> @let type family Composite (x :: k) :: Bool where Composite (f a) = True; Composite x = False
03:22:06 <lambdabot>  .L.hs:297:9:
03:22:06 <lambdabot>      Family instance purports to bind type variable ‘k1’
03:22:06 <lambdabot>        but the real LHS (expanding synonyms) is: Composite (f a) = ...
03:22:37 <mniip> aww, right, kind polymorphism
03:23:20 <Gurkenglas> I often find myself using the pattern "\x -> f . evalState x", and it's nice to be able to use $ before the x when it's a large block
03:24:15 <Gurkenglas> "sneak f evalState $ x", or as I write it "f .: evalState $ x"
03:24:23 <paolino> is (.:) defined somewhere ?
03:24:42 <lpaste> Gurkenglas revised “Gurkenglas's standard library”: “Only here :(” at http://lpaste.net/150727
03:25:42 <Gurkenglas> *hayoo* well and here I guess http://hackage.haskell.org/package/custom-prelude-0.2.2.0/docs/CustomPrelude.html#v:.:
03:25:49 <paolino> yep, lambdas are noisy when there is only one arg
03:27:03 <Gurkenglas> It's not about the lambda, I also transform "foo x = f . evalState (do many newlines)" into "foo = f .: evalState $ do many newlines"
03:34:30 <paolino> pitches = liftA2 ((*12) .: (+)) [0,1..]
03:35:08 <paolino> mhh
03:36:05 <Gurkenglas> This one uses it twice :D http://lpaste.net/1137723792894722048
03:37:20 <Gurkenglas> (Although if I important that PointedAlternative thing with manyLazy, I wouldn't need the fromJustNote, because I could replace evalStateT with evalState)
03:42:20 * hackagebot dockercook 0.5.0.0 - A build tool for multiple docker image layers  https://hackage.haskell.org/package/dockercook-0.5.0.0 (AlexanderThiemann)
03:49:16 <mniip> well
03:49:20 <mniip> Gurkenglas, I think I did it
03:49:43 <lpaste> mniip pasted “multifmap” at http://lpaste.net/154232
03:50:06 <mniip> tagging liste
03:50:46 <Gurkenglas> (Tried that yesterday :D http://lpaste.net/154182 tested it?)
03:51:17 <mniip> Gurkenglas, sounds like you're using overlapping instances
03:51:47 <mniip> hmm, I should factor out undecidables
03:52:27 <Gurkenglas> So that's how you do that sort of overlap, I should put that into http://lpaste.net/151726
03:52:55 <mniip> oh dear
03:57:06 <mniip> hmm yeah I cannot factor out undecidables
03:57:15 <mniip> nevertheless, it's a sane kitchen sink
03:57:54 <mniip> overlapping instances, or let alone, allow ambiguous types, on the other hand, is not
04:10:37 <mniip> Gurkenglas, I have a certain idea though
04:10:52 <mniip> the 'Is' type family can be expanded to provide more friendly typechecking
04:40:35 <merijn> hmmm
04:42:05 <mniip> mmhmm!
04:42:33 <merijn> So if I have an ADT, I end up with constructors that have types like "Cons :: a -> List a -> List a", but I can't figure out an efficient way to "unfold" constructor types for type checking. Suppose I have "e :: List Int", then when type checking "case e of Cons x xs -> foo" I need to "unfold" the "List Int" to figure out that 'x :: Int' and 'xs :: List Int', but I can't figure out how to compute this in a
04:42:39 <merijn>  straightforward manner
04:44:10 <mniip> merijn, by pattern matching a single constructor you're always taking apart a product
04:44:41 <mniip> you know all the parts: the components and the result
04:44:54 <merijn> mniip: My problem is to efficiently compute "List Int -> [Int, List Int]"
04:45:10 <merijn> mniip: You don't necessarily know the components
04:45:28 <mniip> well, how do you represent Cons?
04:45:33 <merijn> "Cons x xs" <- knowing what type 'x' is needs to computed from the type of "Cons x xs" as a whole
04:46:01 <merijn> mniip: Constructor literal
04:46:29 <mniip> no I mean, how do you store the fact that it takes an a and a List a, and produces a List a
04:46:53 <merijn> mniip: By storing it's type "forall a . a -> List a -> List a"
04:47:16 <mniip> I think it would be better to store that in a less GADT-y manner: ([a, List a], List a)
04:47:41 <merijn> mniip: Well, duh, but then I still need to compute that
04:47:45 <merijn> mniip: I'm asking how to do that
04:48:04 <mniip> well, you unify your thing with snd,
04:48:12 <mniip> and then fst is what you asked for
04:48:22 <merijn> I don't know how to turn "forall a . a -> List a -> List a" into "[a, List a]"
04:48:39 <ggole> merijn: it's very similar to type checking application
04:48:58 <mniip> it's better done at the datatype site
04:49:00 <mniip> than at use site
04:49:19 <mniip> I think even GHC represents datas in that way internally, GADT or not
04:49:20 <merijn> mniip: I don't care where. The where doesn't affect how I compute it
04:49:34 <merijn> mniip: I'm saying that I don't know how to compute it...
04:49:46 <merijn> ggole: Oh? In what way?
04:50:34 <ggole> When you type check a term App f x, you do something like unify the type of f with a -> b, unify the type of x and a, and then that gives you a value of type b
04:50:50 <ggole> When you type check a pattern application PApp con x, it's very much the same
04:51:08 <mniip> ungadt d (a -> b) = fmap (a:) $ ungadt d b
04:51:09 <mniip> ungadt d b@(d ...) = ([], b)
04:51:52 <mniip> er
04:51:58 <mniip> I guess that's lmap
04:52:31 <mniip> er
04:52:34 <mniip> first, even
04:52:49 <mniip> since it's a bifunctor not a profunctor
04:53:38 <mniip> anyway, all you have to do is tear apart a structure like  x -> (y -> (z -> (((D a) b) c))
04:53:48 <merijn> ggole: I'm implementing System F_omega, so I don't use unification to typecheck application atm
04:55:44 <ggole> I suppose you'll have an explicit type application then
04:57:08 <ggole> (Cons : List Int) x xs or something
04:58:15 <ggole> (But with the right type, of course.)
04:58:19 <mniip> probably closer to 'case x : List Int of'
04:58:35 <mniip> but wait
04:58:39 <ggole> Depends which typing you want for patterns
04:58:42 <mniip> if you don't unify, how do you do polymorphism?
04:58:43 <merijn> hmmm, I think I just realised an obvious hole in my checker that'd makes this simpler
04:58:59 <merijn> mniip: System F_omega has explicit type application
04:59:12 <ggole> In an inferred system, usually pattern variables are generalised (where sound)
04:59:46 <merijn> mniip: "id :: forall a . a -> a" and to apply it you'd have "id Int 1"
04:59:50 <ggole> Which I think would correspond to an application per constructor in Fw?
05:00:05 <mniip> merijn, then your constructor will contain an extra field
05:00:10 <merijn> mniip: It does
05:00:59 <mniip> so you'd write 'Cons@t x xs' instead
05:02:00 <ggole> Ah, so Cons [Int] :: Int -> List Int -> List Int
05:02:03 <ggole> Yeah, that makes more sense
05:02:07 <merijn> In reality it'd be "Cons t x xs", but that doesn't solve my mapping a type to it's constructor's type issue, but I think how to tackle it
05:02:53 <mniip> I don't see the problem
05:02:58 <ggole> Wait, why do you need to do that?
05:02:59 <mniip> can you restate perhaps?
05:04:22 <merijn> ggole: "case (e :: List Int) of Cons t x xs -> foo" I need to figure out that 't :: *', 'x :: Int', 'xs :: List Int' from the fact that 'e :: List Int' and 'Cons :: forall a . a -> List a -> List a"
05:04:53 <merijn> ggole: But the missing step is that I'm not (I just realised) typechecking my ADT declarations and I can build that mapping there
05:06:31 <mniip> you *should* build it there
05:07:52 <ggole> merijn: you should have an environment mapping from constructor name to a type, eg, Cons :: forall (a :: *) . a -> List a -> List a
05:08:11 <ggole> (And if it is Fw, that should include kind information for any forall bound variable.)
05:08:21 <merijn> ggole: It does
05:08:58 <ggole> That seems like enough info
05:28:00 <jbaiter_> With the Haskell FFI, is there a way to use a "char*" that was allocated on the C-side as a ByteString?
05:28:55 <merijn> jbaiter_: There's an unsafe function somewhere in ByteString's internals, I think
05:29:34 <ClaudiusMaximus> or the safe packCString
05:30:01 <jbaiter_> the problem with packCString is that it copies the buffer and thean manages it on the haskell heap
05:30:11 <merijn> Is there a way to go from "Ptr a" to Addr#?
05:30:27 <jbaiter_> the library I try to write bindings for uses its own allocate and free functions
05:30:31 <merijn> jbaiter_: Hence the unsafe versions in the Unsafe module of bytestring :)
05:30:43 <ClaudiusMaximus> merijn: iirc data Ptr a = Ptr# Addr# or similar
05:30:49 <jbaiter_> yes, thank you for the pointer,r merijn :-)
05:31:09 <merijn> jbaiter_: With all the dangerous caveats they entail
05:31:20 <merijn> like, updating the original allocation breaks everything :)
05:31:49 <ClaudiusMaximus> merijn: http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#t:Ptr
05:38:28 <Ke> btw. is 2010 haskell report still the newest starndard or something?
05:42:03 <EvanR> jbaiter_: ByteString and CString are incompatible, ByteString knows its own length and CStrings dont, and ByteString data isnt null terminated necessarily
05:43:50 <merijn> Ke: Yes
05:43:57 <Ke> =o(
05:44:09 <EvanR> we need a new standard every other year imo
05:44:14 <EvanR> cant have enough of em
05:44:43 <Ke> it would be nice to have some sort of mainstream haskell thta could fit into a standard
05:45:14 <Ke> the biggest flaw in haskell codebase is the widespread use of language extensions
05:45:22 <Ke> in my opinion
05:45:28 <EvanR> why is that a flaw
05:45:43 <merijn> I think that's less of a flaw than the million GCC codebases that accidentally use GCC extensions without knowing it
05:45:51 <merijn> At least haskell extensions are explicit and opt-in only
05:46:00 <geekosaur> ^
05:46:17 <merijn> Except for the 2 or 3 divergences from the standard that GHC has
05:46:29 <Ke> it seems to me that language was never intended to be reasonably used with standard haskell
05:46:42 <EvanR> i thats the flaw Ke is referring to, that you keep having to put the extension flags in 
05:46:59 <EvanR> and some should be standard now
05:47:10 <merijn> EvanR: Well, volunteer for the new revived Haskell Prime committee
05:47:15 <merijn> EvanR: Oh, like which ones?
05:47:22 <EvanR> flexible foos
05:47:40 <merijn> Not gonna happen, too much philosophical objections by some theorists
05:47:45 <EvanR> heh
05:48:17 <merijn> GADTs? Implies ExistentialQuantification, also not gonna happen
05:48:27 <EvanR> yes, GADTs
05:48:34 <EvanR> yes existential quantification
05:48:52 <merijn> EvanR: Existential quantification isn't going in until the underlying theory has been more thoroughly worked out
05:49:02 <merijn> and GADTs can't go in without ExistentialQuantification
05:49:02 <EvanR> what is wrong with the theory?
05:49:14 <merijn> EvanR: The ramification aren't well understood
05:49:22 <merijn> +s
05:49:46 <pavonia> Is there an overview what extensions implicitly enable other extensions?
05:50:07 <EvanR> the new ghc manual is pretty good
05:50:09 <xa0> i've reached the point where i read "codedecay" as "co de-decay" rather than "code decay"
05:50:19 <merijn> RankN types is well understood and not questionable, but they're hard to implement, so requiring RankN for the standard would be tricky for new implementors
05:50:21 <EvanR> co dededede cay
05:50:50 <EvanR> yes RankN types
05:51:13 <EvanR> this is haskell, i didnt think "hard to implement" was an issue with language design ;)
05:51:23 <merijn> EvanR: Requiring RankN will render the standard pointless
05:51:34 <merijn> The idea behind a standard is so that multiple implementations will conform
05:51:51 <EvanR> dont implementation strive to impement rankN anyway?
05:51:58 <EvanR> its just that awesome?
05:52:00 <merijn> The amount of work to implement RankN will put up such a high barrier people might not bother
05:52:04 <geekosaur> rank-2 yes, rank-N not necessarily
05:52:19 <merijn> geekosaur: Once you do Rank2, why bother with not doing RankN?
05:53:22 <paolino> maybeToList is the instance of a natural transformation ?
05:53:58 <EvanR> :t maybeToList
05:53:59 <lambdabot> Maybe a -> [a]
05:54:08 <paolino> is it `classified` ?
05:55:36 <EvanR> > fmap (+1) . maybeToList $ Just 3
05:55:38 <lambdabot>  [4]
05:55:46 <EvanR> > fmap (+1) . maybeToList $ [3,3,3,3]
05:55:48 <lambdabot>      Couldn't match expected type ‘Maybe b’ with actual type ‘[Integer]’
05:55:48 <lambdabot>      In the second argument of ‘($)’, namely ‘[3, 3, 3, 3]’
05:55:48 <lambdabot>      In the expression: fmap (+ 1) . maybeToList $ [3, 3, 3, 3]
05:55:58 <EvanR> > maybeToList . fmap (+1) $ [3,3,3,3]
05:56:00 <lambdabot>      Couldn't match expected type ‘Maybe a’ with actual type ‘[Integer]’
05:56:01 <lambdabot>      In the second argument of ‘($)’, namely ‘[3, 3, 3, 3]’
05:56:01 <lambdabot>      In the expression: maybeToList . fmap (+ 1) $ [3, 3, 3, 3]
05:56:08 <xa0> what on earth are you trying
05:56:29 <EvanR> hrm
05:56:51 <paolino> listToMaybe
05:57:14 <EvanR> well maybeToList and listToMaybe may form a natural isomorphism
05:57:30 <EvanR> but
05:58:30 <EvanR> > maybeToList . fmap (+1) $ Just 3
05:58:32 <lambdabot>  [4]
05:58:45 <EvanR> > fmap (+1) . maybeToList $ Just 3
05:58:47 <lambdabot>  [4]
05:58:56 <EvanR> 1 out of 1 test passed
06:04:05 <sphinxo> Any way I can turn this http://lpaste.net/6419450745589858304 into one match?
06:04:38 <sphinxo> something like eq t t' | t == t' = Just Refl
06:05:18 <EvanR> sure if you can ==
06:06:33 <sphinxo> EvanR: I don't think I can derive Eq for http://lpaste.net/6815574544212819968
06:08:44 <EvanR> getting gnarly
06:09:10 <EvanR> yes == is inappropriate
06:09:40 <sphinxo> what could I use instead?
06:09:48 <sphinxo> I just care about the type
06:10:00 <sphinxo> (value constructor )
06:10:18 <EvanR> maybe you can use a type class for this?
06:10:39 <sphinxo> Instance Eq (Type a) where?
06:10:44 <EvanR> no
06:10:52 <EvanR> instance YepEqual (Type a) (Type a) where
06:11:00 <EvanR>   eq _ _ :: Just Refl
06:11:13 <EvanR> er = 
06:11:48 <xa0> wow, rankNTypes is actually really cool...
06:11:52 <sphinxo> this is my full eq function http://lpaste.net/8166024330656874496
06:12:18 <sphinxo> and these are actually all my types http://lpaste.net/181839582348705792
06:12:23 <EvanR> in which case
06:12:27 <EvanR> also
06:12:42 <EvanR> instance YepEqual a b => YepEqual (Type a) (Type b) where
06:12:51 <EvanR> or something like this
06:13:35 <sphinxo> where YepEqual is? EvanR 
06:14:22 <EvanR> nowhere. class YepEqual a b where
06:14:46 <sphinxo> should i just use == as the fn?
06:15:10 <EvanR> == is for testing value equality and getting a Bool back
06:15:40 <sphinxo> isn't that what i really want?
06:15:58 <EvanR> i dont know
06:16:14 <EvanR> youre trying to compute an equality proof
06:16:35 <sphinxo> I think a bool would be sufficient in this case
06:16:54 <sphinxo> but u :~: v would be cool
06:17:33 <EvanR> Bool will not let you use the equality for anything
06:17:48 <EvanR> theoretically you could use the equality proof to use your arrows for stuff
06:18:10 <cmotoche> Hello everyone. I'm learning about digestive-functors, and I was doing a form validation with it. But, I'm having a problem with the parameters from a response, all the parameters are empty, and I don't know why. I added the ref attribute to the labels in the form, but it's not working. Could you please help me with that?
06:24:06 <sphinxo> EvanR: something like http://lpaste.net/1393402805183578112 ?
06:24:43 <EvanR> no thats just a regular function definition
06:25:00 <EvanR> the typeclass isnt really doing anything
06:25:27 <EvanR> if you were doing this with typeclasses you wouldnt need to compute anything
06:25:36 <EvanR> all the rules would be in the class and instances
06:25:37 <sphinxo> How would I do that?
06:26:47 <EvanR> heres one way to try
06:27:13 <EvanR> class TEq a b where -- nothing
06:27:46 <EvanR> instance TEq (Type Int) (Type Int) where --nothing
06:28:32 <sphinxo> and what about TArrow?
06:29:04 <sphinxo> and then how do I use this?
06:29:20 <EvanR> instance (TEq a b, TEq c d) => TEq (Type (a -> c)) (Type (b -> d)) where
06:29:32 <mniip> EvanR, you don't need the where-clause if it's empty
06:29:45 <EvanR> you dont need the word where?
06:29:59 <mniip> yep
06:30:02 <EvanR> nice
06:30:16 <sphinxo> Nice
06:30:31 <EvanR> sphinxo: and based on this, having Type be its own type might be getting in the way
06:30:42 <sphinxo> EvanR: what would you suggest instead?
06:30:46 <EvanR> TInt, TArrow etc could be their own types
06:30:50 <mniip> having implemented a large portion of prelude in MPTC I know this
06:30:54 <sphinxo> oh ok
06:31:07 <EvanR> mniip: heh
06:31:17 <EvanR> sphinxo: next question is how youd use this
06:31:41 <EvanR> whenever you have a function that only works on two types that are the same you put TEq a b => on the front of the signature
06:31:50 <sphinxo> ooh
06:32:35 <EvanR> an example function like this is the rule for function application, assuming arrows are functions
06:32:58 <EvanR> but this is beyond me right now i need breakfast
06:34:00 <sphinxo> I was originally using it like so http://lpaste.net/9162773037605453824
06:35:13 <EvanR> youre doing error at runtime, but its possible that user code that tries such a substitution cant compile in the first place
06:35:24 <sphinxo> Yes
06:35:46 <EvanR> its a rabbithole that keeps sucking you in
06:35:53 <EvanR> like a blackhole
06:35:58 <sphinxo> errors at runtime?
06:36:10 <EvanR> doing more and more at compiletime
06:36:23 <sphinxo> EvanR: What do you suggest?
06:37:00 <EvanR> it all seems a little nuts to me ;)
06:37:31 <sphinxo> I like to live my life on the edge
06:37:48 <EvanR> then by all means implement the whole language with just types
06:37:59 <sphinxo> What are the other options?
06:38:11 <Shockk> it's fun to leverage the type system
06:39:08 <EvanR> instead of running the code you compile the code
06:39:18 <sphinxo> into?
06:39:19 <EvanR> lol
06:39:22 <EvanR> into nothing
06:39:42 <sphinxo> compile from what into what?
06:39:49 <EvanR> from haskell into nothing
06:39:58 <EvanR> if it works youre good
06:40:01 <EvanR> otherwise you have a bug
06:40:48 <EvanR> code that doesnt run is the purest code of all
06:41:26 <sphinxo> haha
06:41:54 <dimsuz> hello! why 'join (*) 3' works? is Integer a monad? When I type ":i Integer" I do not see it. Another question: is there a way to see which instance of 'join' was picked for this expression, i.e. for what types.
06:42:16 <tdammers> as a compromise, compile your program into a precomputed lookup table that gives you the correct output for all possible inputs
06:42:23 <dimsuz> ah! I think I got it. function application is a monad
06:42:43 <merijn> dimsuz: Functions are a monad, yes. "instance Monad ((->) r)"
06:43:40 <dimsuz> merijn: yes, didn't think of it right away...
06:43:44 <xa0> :t join (*) 3
06:43:46 <lambdabot> Num a => a
06:44:13 <dimsuz> xa0: yeah, but this dosen't tell me anything about which monad instance was used for this expression
06:44:19 <mniip> :t (*)
06:44:22 <lambdabot> Num a => a -> a -> a
06:44:24 <mniip> :t join
06:44:26 <lambdabot> Monad m => m (m a) -> m a
06:44:26 <xa0> oh that wasn't demonstrative, i was just curious
06:44:36 <mniip> unify m (m a') with a -> a -> a
06:44:39 <mniip> and you'll see it
06:45:12 <Shockk> (->) (-> r) ?
06:45:27 <dimsuz> mniip: thanks. so in case of functions the result is basically applying a certain function 2 times
06:45:30 <mniip> Shockk, ?
06:45:35 <Shockk> I don't really know what I was asking
06:46:18 <mniip> dimsuz, that's loose terminology but yes
06:46:23 <merijn> Shockk: "(->) r" = "r ->"
06:46:53 <merijn> "(->) r a" = r -> a" in the same way that "(+) x y" = x + y
06:47:59 <mniip> well, type operator sections aren't allowed though
06:48:01 <Shockk> hmm so,
06:48:03 <Shockk> > join (*) . join (*) . join (*) $ 2
06:48:06 <lambdabot>  256
06:48:10 <Shockk> interesting
06:52:36 <puregreen> what's the right way to use data-files that would work both in REPL and when the executable is installed? if I import the Paths_ module, in REPL it points at the already installed files, not the files “in development”
06:53:25 <merijn> The truly portable (but hacky, according to some know it alls) would be to just put the data files in the binary directly :p
06:53:38 <merijn> Then you never have to worry about where they are
06:53:41 <ClaudiusMaximus> puregreen: maybe have a separate hs-src-dirs with a different (custom) Paths_ module
06:54:07 <ClaudiusMaximus> puregreen: then do  ghci -isrc:custompathsrc
06:54:44 <Shockk> mniip: I did something a bit silly
06:55:07 <Shockk> > foldr (.) id (replicate 4 (join (*))) $ 2
06:55:09 <lambdabot>  65536
06:55:54 <xa0> fancy way of calculating 2^(4^2)
06:58:00 <mniip> Shockk, I think you're looking for iterate
06:58:07 <mniip> > iterate (join (*)) 2 !! 4
06:58:09 <lambdabot>  65536
07:01:17 <Shockk> mniip: today I learned a new function, thanks
07:02:33 <mnoonan> Is there a good reason for not having type operator sections?
07:03:57 <Shockk> would type operator sections be like (-> Int) String? (becoming String -> Int)
07:04:26 <mnoonan> right
07:04:28 <mniip> that's not representable in the typesystem
07:05:13 <mniip> you could have some wired-in type family do the job but it wouldn't get you any further than where ((->) x y) would
07:07:22 <merijn> Shockk: In theory, yes, in practice it's not valid syntax for haskell :)
07:09:10 <Shockk> ah right
07:12:11 <quchen> I thought it was important that we don't have type-level flip or we could write a type-level S and build SKI hence Lambda calculus out of it
07:12:30 <quchen> … and we don't want not necessarily terminating typechecking
07:12:36 <merijn> quchen: Yes
07:12:47 <geekosaur> hm, thought typechecking could already not terminate
07:12:54 <mniip> could it
07:13:00 <merijn> geekosaur: Nope, only with UndecidableInstances
07:13:04 <mniip> ^
07:13:08 <geekosaur> ^ is what I was thinkinhg of, yes
07:13:10 <merijn> geekosaur: HM is strongly terminating without that
07:13:18 <mniip> oops
07:13:30 <mniip> 30 lines above s/type family/type synonym/
07:13:32 <mnoonan> is nontermination that much worse than exponential worst-case behavior? :)
07:13:45 <mniip> mnoonan, yes?
07:13:51 <merijn> mnoonan: Not really, but HM isn't exponential, I think?
07:14:01 <quchen> Worst case.
07:14:49 <mniip> let me tell you a story about a FizzBuzz that can OOM the compiler
07:15:39 <xcombelle> mniip it is a real story ?
07:15:51 <mniip> https://github.com/AbstractBeliefs/BadBuzz/blob/master/Haskell/mniip.hs
07:15:59 <quchen> :t let f x = (x,x); g=f.f; h=g.g in h ()
07:16:00 <lambdabot> (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))
07:16:28 <mniip> xcombelle, ^
07:16:35 <xcombelle> lol mniip
07:16:57 <mniip> I can run it to 70 on my machine
07:17:07 <mniip> someone else with 8GiB of ram got it to 100
07:18:01 <nshepper1> instances would be ambiguous with type operator sections too, or maybe they would have to exclude each other
07:18:08 <quchen>  > instance DecimalMod (S (S (S (S (S (S (S (S (S Z))))))))) (S (S (S (S (S (S (S (S (S Z)))))))))
07:18:10 <quchen> ಠ_ಠ 
07:20:03 <nshepper1> you couldn't have 'instance Functor (a `Either`); instance Functor (`Either` b)' usefully
07:27:07 <quchen> mniip: Got it to 90! :-D
07:28:09 <obadz> Would be nice if in a `f` b, f could be any expression that produces a function a -> b -> c, rather than a symbol..
07:28:22 <obadz> Is there an extension for that?
07:28:31 <EvanR> f cant be a symbol
07:28:39 <EvanR> it has to be 1 word
07:28:48 <obadz> that's what I mean by a symbol
07:28:54 <quchen> There's no such extension, no.
07:29:00 <EvanR> a `+` b doesnt work
07:29:22 <obadz> anyway we know what I mean
07:29:23 <quchen> xs `zipWith (+)` ys -- I think that's the issue.
07:29:26 <ggole> Might screw up the grammar
07:29:32 <obadz> quchen: yes that would be nice
07:29:48 <EvanR> "any expression" literally wont work because
07:30:03 <ggole> How would you tell whether a ` ended a backtick or started a new one?
07:30:10 <EvanR> nested `
07:30:27 <ggole> You really need symmetrical arrows like «»
07:30:37 <pavonia> `(...)` could work
07:30:58 <obadz> ok so any `-free expression. « & » would work as well..
07:31:06 <ggole> pavonia: yeah, possibly
07:31:09 <obadz> or ` and ´
07:31:20 <EvanR> x `whatever i want` y would be great for greatly infurating lisp syntax people ;)
07:31:53 <obadz> x `f z´ y ..
07:32:14 <mniip> x` fz `y
07:34:28 <xa0> If we were to strip everything possible from haskell that can be implemented in haskell, what would be left? by that I mean to ask, how small is the base language?
07:34:46 <xa0> because I understand it to be very small
07:34:55 <obadz> xa0: System F is extremely small
07:35:03 <xa0> oh it has a name, how fancy
07:35:19 <EvanR> well haskell has ADTs
07:36:08 <obadz> oh I guess the question is what are the builtins, not what is core..
07:36:18 <mniip> xa0, it's not that small actuallty
07:36:28 <xa0> ah
07:36:37 <xa0> that's a bit disappointing
07:36:45 <mniip> you can't strip [] or Bool
07:36:48 <mniip> nor the Monad typeclass
07:37:02 <obadz> mniip: why can't you strip Monad ?
07:37:09 <mniip> because it's wired in syntax
07:37:10 <EvanR> is this pedantic or
07:37:17 <obadz> mniip: you mean do- notation?
07:37:20 <mniip> the 'do' block desugars to >>= calls
07:37:49 <EvanR> you also cant strip out a lot of stuff but you would if you were asking about "moral base haskell"
07:37:54 <EvanR> like Int
07:37:58 <EvanR> and Char
07:37:58 <obadz> and why can't you strip []? because of List comprehensions?
07:38:08 <mniip> yeah and because it's not implementable in haskell
07:38:25 <ClaudiusMaximus> due to special syntax
07:38:27 <mniip> : and [] aren't valid constructor names
07:38:40 <mniip> oh and [a,b,c] is special syntax
07:38:40 <EvanR> special syntax and sugar aside
07:38:46 <geekosaur> actually aren't the numeric types wired in because of the desugaring that lets you use numbers as patterns?
07:39:03 <mniip> geekosaur, only their typeclasses I think
07:39:05 <EvanR> the point of sugar is so that we dont actually change the underlying language
07:39:10 <mniip> well and Integer and Rational
07:39:16 <mniip> because fromInteger and fromRational
07:39:24 <ClaudiusMaximus> geekosaur: i think they desugar to (==) so Eq and Bool are hardwired
07:39:40 <geekosaur> (also (==) because `foo 1 = ...` desugars to `foo x | x == 1 = ...`
07:39:46 <xa0> this is really snowballing...
07:39:51 <geekosaur> well, to the case that that desugars to
07:39:55 <mniip> Bool is also wired-in in if
07:40:10 <mniip> and guards
07:40:18 <ski> (and guards (also in list comprehensions) ..)
07:40:44 <obadz> EvanR: agree with you but almost all of Haskell is sugar on top of System F
07:41:01 <EvanR> i think ADTs and pattern matching on ctors isnt in system F
07:41:16 <mniip> ADTs can be embedded into system F
07:41:19 <obadz> EvanR: you've got case in Core
07:41:30 <EvanR> and all of it can be embedded in 7 primitive lisp or untyped LC
07:41:45 <obadz> EvanR: I don't know if that includes ADT constructors
07:41:59 <EvanR> right case in core is where this ends up
07:42:07 <EvanR> way better than if and ==
07:43:19 <EvanR> so there might be a nice place to draw a dividing line in haskell between syntax level conveniences and mechanisms that are translated into core, and core
07:43:34 <EvanR> not sure where typeclasses fit into that
07:44:21 <obadz> for anyone interested in core, this was a fantastic video: https://skillsmatter.com/skillscasts/6495-keynote-from-simon-peyton-jones
07:44:29 <mniip> well you could claim that typeclasses desguar into imlpicit arguments
07:44:39 <EvanR> for execution yeah
07:44:52 <mniip> for core too, ish?
07:45:20 <EvanR> but on the programming level youre thinking about resolution
07:47:55 <ggole> obadz: hmm? Algebraic types have a pretty clear analogue in UTLC
07:48:30 <ggole> You can even write similar encodings in Haskell, although they are quite painful
07:48:46 <obadz> ggole: it was EvanR who was claiming otherwise
07:48:53 <EvanR> i didnt
07:48:57 <ggole> I don't think that's right
07:49:10 <obadz> ⇒ EvanR | i think ADTs and pattern matching on ctors isnt in system F
07:49:24 <ggole> No, system F just has functions
07:49:33 <EvanR> the point wasnt is the core of haskell representable in some turing tarpit
07:49:33 <ggole> You *encode* pattern matching into functions
07:49:54 <obadz> ggole: using case?
07:50:07 <ggole> system F doesn't have case
07:50:11 <obadz> huh?
07:50:12 <EvanR> its how big is haskell with out all the standard library
07:50:37 <mniip> it's all von-neumann machines anyway
07:50:40 <julianleviston> Has anyone ever seen an implementation of OMeta in Haskell?
07:50:45 <simpson> It's big enough, but not much bigger. Just like most other mature languages.
07:51:09 <julianleviston> I couldn’t seem to find one.
07:51:15 <simpson> julianleviston: I got about halfway before remembering that OMeta is terrible. It's not especially hard if you're willing to roll up your sleeves and hack.
07:51:17 <ggole> obadz: traditionally you write projections inl :: a -> a + b and inr :: b -> a + b and then match :: (a + b) -> (a -> c) -> (b -> c) -> c
07:51:23 <Cooler> need some help building a project
07:51:29 <julianleviston> simpson: why is it terrible?
07:51:51 <simpson> julianleviston: Mostly because the algorithm is not especially efficient or simple.
07:51:57 <obadz> ggole: catamorphisms?
07:51:59 <ggole> Where + is a binary type constructor that is like a primitive sum type
07:52:02 <julianleviston> simpson: ah ok… anything else like it?
07:52:15 <ggole> You can build everything up from there (painfully, with garbage efficiency)
07:52:24 <julianleviston> simpson: I pretty much just want to be able to quickly build my own languages by writing tiny language specs… 
07:52:27 <simpson> OMeta's approach to left recursion is novel, and fascinating, but I wouldn't encourage it.
07:52:30 <simpson> julianleviston: Which features do you want? PEG? Left recursion?
07:52:32 <Cooler> can someone help?
07:52:42 <julianleviston> simpson: the thing I’m after is “executable grammars” basically.
07:52:43 <trevorriles> Cooler: what project?
07:52:58 <Cooler> i am following this tutorial https://wiki.haskell.org/How_to_write_a_Haskell_program#Recommended_tools
07:52:59 <obadz> ggole: SPJ has case all over his talk on Core
07:53:02 <julianleviston> simpson: otherwise I’d just look at parser combinators or one of the other parser things.
07:53:14 <ggole> Sure, but Core isn't raw system F
07:53:15 <EvanR> obadz: right, because core is not system F ;)
07:53:24 <Cooler> and when i got to the part where you create a sandbox and build the project it gave an error
07:53:34 <Cooler> failed to build even though it created the sandbox
07:53:36 <ggole> It has additions to make compilation more convenient and efficient
07:53:42 <julianleviston> Cooler: are you using stack?
07:53:43 <Cooler> http://lpaste.net/154239
07:53:53 <Cooler> no the tutorial uses cabal and git
07:53:54 <julianleviston> ah no then
07:54:02 <julianleviston> Cooler: stack is pretty amazingly cool.
07:54:05 <EvanR> case is such an awesome construct, why is it not in these famous formalizations
07:54:28 <simpson> EvanR: Look at how it's implemented in e.g. Scheme.
07:54:31 <julianleviston> simpson: “executable grammars”, pretty much… as in… the code appears next to the grammar rule.
07:54:46 <EvanR> simpson: i mean, taken as a primitive
07:54:48 <obadz> EvanR / ggole - I thought the whole point of that talk was that Core ≈ System F
07:54:51 <ggole> obadz: the reason people talk about Core and system F as being similar is that the way type application is handled in each form is very similar
07:55:00 <simpson> julianleviston: Oh, you want the nice-looking environment that is in all of Warth's presentations?
07:55:13 <trevorriles> Cooler: if you want to use stack, you should be able to do `stack init` then `stack build`
07:55:14 <julianleviston> simpson: no, not the Ometa/JS browser. 
07:55:18 <simpson> julianleviston: 'Cause that's not something that's portable to any of the other OMeta implementations.
07:55:33 <Cooler> trevorriles, what's stack? did you see the link i posted?
07:55:44 <julianleviston> simpson: No, I’m talking about the fact that grammars are symbiotic to their implementation language.
07:55:52 <simpson> EvanR: Why would you take it as a primitive when you can always decompose it into an if-then-else stack?
07:55:53 <julianleviston> simpson: and host their implementation semantics.
07:56:22 <EvanR> simpson: why would you want to take if then else on bools as a primitive?
07:56:25 <julianleviston> simpson: or at least, that the language allows that
07:56:39 <julianleviston> simpson: as can be seen here: (the second example) http://www.tinlizzie.org/ometa-js/#OMeta_Tutorial
07:57:00 <trevorriles> Cooler: http://docs.haskellstack.org/en/stable/README/
07:57:14 <obadz> ggole / EvanR ⇒ see http://pasteboard.co/27cOGF1V.png & http://pasteboard.co/27cQNiWZ.png from SPJ's talk
07:57:15 <trevorriles> Cooler: it really simplifies building haskell projects and handles/caches dependencies for you
07:57:29 <simpson> EvanR: Well, outside of Haskell, languages like E and Scheme already have primitive bools.
07:57:41 <trevorriles> Cooler: `stack init` converts the cabal project to use stack
07:57:50 <Cooler> trevorriles, nvm i figured out the error, it couldn't find the source file
07:57:52 <EvanR> scheme, lisp, x86 comparison flags, ok
07:58:02 <EvanR> my question was about famous formalizations of computation ;)
07:58:10 <simpson> julianleviston: Sure, sure. I hacked on Parsley, the Python OMeta library, for many moons. TBH I wouldn't want to write another parser with it. It *seems* super-fun at first, but maintainability is low.
07:58:14 <Cooler> trevorriles, i don't what you are talking about, what is stack?
07:58:20 <EvanR> not infamous formulations
07:58:35 <Cooler> the site seem to mention cabal as the preferred method for building haskell projects
07:58:35 <julianleviston> simpson: I don’t think it seems fun. It seems a pain in the butt :)
07:58:36 <simpson> EvanR: How do you feel about http://pygmy.utoh.org/3ins4th.html ?
07:58:42 <simpson> julianleviston: It is!
07:58:54 <julianleviston> simpson: however, you *can* build languages very succinctly with it… 
07:59:11 <julianleviston> simpson: and I’d quite like to build some tiny problem-oriented languages with something like it.
07:59:23 <simpson> julianleviston: And then you'll immediately have to write a real parser, so that you can have something approaching speed.
07:59:35 <julianleviston> simpson: not necessarily.
07:59:50 <ggole> obadz: system F doesn't have let, rec, case, or the constructor stuff
07:59:54 <ggole> It's a *tiny* calculus
08:00:04 <simpson> julianleviston: IYSS. Anyway, if you wanted to write an OMeta implementation, I'd recommend using the combinators from `parsers`: http://hackage.haskell.org/package/parsers
08:00:07 <ggole> (Doesn't have constants either, for that matter.)
08:00:17 <julianleviston> simpson: the 4 or 5 times I’ve looked at it I thought the implementation was pretty annoying.
08:00:22 <simpson> And then you can pick any of the parser combinator libraries (Parsec, Trinity, etc.)
08:00:52 <julianleviston> simpson: yeah, that’s what I would do
08:01:09 <julianleviston> not that I’ve looked at them much.
08:01:16 <EvanR> simpson: this forth seems insane. what is the benefit
08:01:27 <simpson> EvanR: Embedded development is hell.
08:01:40 <obadz> ggole: will let you take it up with SPJ ;-)
08:02:19 <EvanR> you can compile pattern matching cases into whatever instruction set
08:02:51 <EvanR> the kinds of data structures youre allowed to build might be constrained though
08:02:58 <mnoonan> EvanR: forth is just the tip of the iceberg: http://www.colorforth.com/cf.htm
08:03:45 <EvanR> are these jokes?
08:05:00 <simpson> EvanR: Which languages do you think are not jokes? Or, put another way, why are you so sure that Haskell is not a joke?
08:07:20 <simpson> To be sure, the Chuck Moore universe is...bizarre. But he's quite serious, and he's produced quite a bit of stuff on his own with his techniques. There are lessons worth learning.
08:07:24 <EvanR> not really talking about haskell, but it seems by saying less explicitly how your decision process is supposed to work, your optimizer is going to have more room to work with
08:07:55 * simpson shrugs
08:07:59 <simpson> Performance is not everything.
08:08:00 <ggole> I doubt Chuck Moore believes in using optmizers
08:08:16 <ggole> He would view them as something that could be removed, therefore should be removed.
08:08:27 <EvanR> i see
08:08:28 <simpson> Yeah, just write tighter words and phrases.
08:09:40 <simpson> On the other side of the rabbit hole, there are languages where performance must not trump security: http://erights.org/
08:11:03 <EvanR> well if we dont care about performance, then ill just go back my original point, that case expressions are alot easier to understand than a nest of ifs, function encoded bools, higher order polymorphism
08:11:16 <EvanR> as a basis of computing
08:11:58 <simpson> IYSS.
08:13:08 <simpson> Personally I think that small Forths are beautiful, and that kernel size requires tradeoffs since a smaller kernel necessarily requires more sugar.
08:13:09 <ggole> If by 'understand' you mean 'prove things about', that isn't clear at all
08:13:31 <EvanR> really?
08:13:41 <ggole> And that's what system F was invented (or discovered) for, after all
08:14:08 <simpson> EvanR: Consider: In E/Monte, I can prove that an object is transitively immutable. You can't do that in Haskell, and it has *nothing* to do with kernel elegance.
08:14:46 <julianleviston> simpson: what does *transitively* immutable mean?
08:15:08 <simpson> julianleviston: The object's immutable and all of its referents are also transitively immutable.
08:15:13 <julianleviston> simpson: the only use of transitive I’m aware of is transitive verbs in natural english.
08:15:16 <simpson> Er, *references.
08:15:30 <julianleviston> simpson: so you just mean immutable?
08:15:31 <simpson> "transitive" is a maths word.
08:15:35 <julianleviston> oh ok
08:15:39 <julianleviston> i’ll look it up
08:15:39 <julianleviston> thanks
08:15:46 <EvanR> if a = b and b = c then a = c
08:15:57 <xa0> if = is transitive
08:16:10 <xa0> (which it must be to be an equivalence relation)
08:16:15 <simpson> julianleviston: Well, yeah, FWIW nobody uses the plain "I'm immutable but maybe I refer to mutable objects" proof. In practice, the transitive "deep" version is what we always use.
08:16:32 <simpson> E has Frozen and DeepFrozen; Monte only has DeepFrozen.
08:16:36 <julianleviston> simpson: yeah, to me that’s just frozen
08:16:40 <julianleviston> simpson: all good
08:22:14 <Gurkenglas> mniip, "| s t -> a b, s a b -> t, t a b -> s" <- shouldn't it be "| s -> a, t -> b, s b -> t, t a -> s"?
08:23:53 <Gurkenglas> Actually why do we have s t -> a b, shouldn't you be able to do both "Polyfmap (f (g a)) (f (g b)) (g a) (g b)" and "Polyfmap (f (g a)) (f (g b)) a b"?
08:37:18 <cmotoche> Can I use digestive-functors with any other template language? or only with heist?
08:42:58 <julianleviston> cmotoche: looks like the tutorial uses blaze, so … probably? :)
08:43:45 <julianleviston> cmotoche: in the readme, it says blaze as well as heist… https://github.com/jaspervdj/digestive-functors
08:46:52 <Gurkenglas> This reminds of Zoom, doesn't it?
08:47:00 <Gurkenglas> (The mniip thing)
08:55:54 <anohigisavay> how do i write unittest for an internal module in a standard stack-based project?
08:57:13 <anohigisavay> i added the library as a build dependency for the test-suite
08:57:50 <anohigisavay> but apparently i can't get to the modules that aren't in the library's exposed-modules  list
09:00:41 <c_wraith> anohigisavay, nothing stack can do about that. hidden modules are hidden. 
09:01:11 <c_wraith> anohigisavay, but most people, including me, find hidden modules to be counterproductive. 
09:01:44 <c_wraith> anohigisavay, I much prefer the .Internal convention. 
09:02:37 <c_wraith> anohigisavay, where you expose all modules, but document that ones named Internal are liable to change without notice and can be used to generate broken code. 
09:03:08 <anohigisavay> c_wraith: i see. pretty much like python conventions
09:03:33 <anohigisavay> you don't prohibit them from importing internal modules, but discourage doing so
09:04:15 <c_wraith> yes. and sometimes users can do cool things with them that they couldn't do otherwise. it's a nice way to learn what users are actually doing. 
09:05:13 <anohigisavay> c_wraith: cool thanks :D
09:05:44 <merijn> @ask edwardk Browsing through lens' Text lenses, I'm wondering, would it be possible to define a lens/prism/iso that let's one take "Ptr CChar/ByteString" as input for "Text -> Foo" functions without copying/duplicating the original data?
09:05:44 <lambdabot> Consider it noted.
09:12:07 <c_wraith> merijn, isn't that wandering into accursedUnutterablePerformIO territory? 
09:12:16 <newsham> > unsafeStackExchangeToIO "how do I sort a list in haskell?"
09:12:18 <lambdabot>  Not in scope: ‘unsafeStackExchangeToIO’
09:12:40 <dmj`> theOneWhoMustNotBeNamedIO :: IO a -> a
09:12:43 <merijn> c_wraith: I don't think it has to be?
09:13:08 <c_wraith> accursedUnutterablePerformIO is the best function. it's not just unsafePerformIO. it's far worse. 
09:13:11 <merijn> c_wraith: ByteString's can be operated on just fine without IO?
09:13:12 <newsham> > onHisFarmHeHadAGoatEIEIO
09:13:15 <lambdabot>  Not in scope: ‘onHisFarmHeHadAGoatEIEIO’
09:13:25 <merijn> c_wraith: I don't see how IO comes into it?
09:13:52 <c_wraith> merijn, well, Ptr requires IO
09:13:53 <merijn> Turning "Ptr CChar" into ByteString is pretty easy and safe with just unsafePerformIO
09:14:12 <merijn> c_wraith: Stuffing a Ptr into a BS as part of allocating it is pretty easy
09:14:42 <newsham> myGlobIORef = unsafePerformIO $ newIORef 0
09:14:57 <merijn> My problem is more of a "going from ByteString to a Text without reallocating" deal
09:16:45 <c_wraith> seriously, https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L527 is the best comment. 
09:19:00 <newsham> that is pretty good
09:19:32 <emmanuel_erc> Hello there. Do you guys mind if I post a paste asking about my usage of the Endo data type?
09:19:34 <pikajude> are there any gtk2hs maintainers in here?
09:20:04 <dcoutts> pikajude: worth asking anyway
09:20:08 <pikajude> yeah
09:20:26 <pikajude> i'm wondering where the contents of the webkit package's hierarchy3.list came from
09:20:42 <pikajude> it says in the header that it was copied "from the GtkObject hierarchy html documentation", but i don't know what that is
09:20:46 <pikajude> i'm trying to port it to work with webkit2gtk
09:21:59 <lpaste> emmanuel_erc pasted “Is my usage of the Endo type misplaced here?” at http://lpaste.net/154243
09:22:57 <newsham> inlining dangerous stuff seems like a great pattern for making a hard to find memory unsafe bugdoor
09:23:15 <lifter> Is there a convention of prefixing binding names for bindings of type Maybe w/ the letter "m"?
09:23:31 <Cale> emmanuel_erc: Maybe... why do you need the Monoid instance here?
09:23:48 <Cale> emmanuel_erc: Could you just as well use (.) and id directly?
09:24:07 <Cale> lifter: I do that quite often.
09:24:46 <lifter> Cale: I just noticed a coworker doing it, and I may have done it myself in the past; was kind of curious if others do it, too. Thanks.
09:25:24 <simpson> lifter: Don't remember who I picked it up from, but things in Maybe or in other Monads are prefixed with m all the time.
09:25:39 <emmanuel_erc> Cale: Which line are you referring to?
09:25:45 <Cale> emmanuel_erc: The whole thing
09:26:05 <Cale> emmanuel_erc: Are you using anything which is abstracted over a choice of monoid?
09:26:10 <Cale> I don't see anything
09:27:05 <emmanuel_erc> I'll explain things at the top level.  The function edgeSet is supposed to provide an edgeSet for each point in the data.
09:27:09 <Cale> You could just delete your use of the Endo data constructor, replace `appEndo` with $ and mempty with id
09:27:20 <Cale> and (<>) with (.)
09:27:33 <emmanuel_erc> It is possible that the edgeset could not exist (by looking at the data type PType)
09:27:44 <emmanuel_erc> oh ok
09:28:16 <Cale> emmanuel_erc: Or is the real question deeper than that? :)
09:29:01 <emmanuel_erc> It is slightly deeper but this is just a small part of my code (well it is the part that is giving me problems) and I want to keep questions sufficiently shallow for wo.
09:29:03 <emmanuel_erc> for now.
09:29:17 <Cale> emmanuel_erc: Endo is more useful as a concept if you already have something which works with an arbitrary choice of monoid m, and you want m = "a -> a" but that doesn't work directly because the lifting instance is in the way, so you use the Endo newtype
09:30:08 <emmanuel_erc> Cale: I understand.
09:30:25 <emmanuel_erc> Cale: Do you mind if describe some of the mechanics in my paste?
09:30:31 <Cale> I don't mind
09:30:54 <emmanuel_erc> Cool.
09:31:07 <mpickering> Does anyone know what happened to the latest reboot of Haskell'?
09:33:03 * hackagebot libvirt-hs 0.1.2 - FFI bindings to libvirt virtualization API (http://libvirt.org)  https://hackage.haskell.org/package/libvirt-hs-0.1.2 (IlyaPortnov)
09:33:26 <emmanuel_erc> Let me start with the edgeSet function. Looking at its signature (in the comments), it could return an edgeSet but that depends on whether the point (PType) is constructor HasATS or Boundary. There is another wrinkle. The computation of the value produced by edgeSet could fail (it is being handled by a C library). That's why the type of edgeSet has a Maybe wrapped in an Either.
09:34:01 <emmanuel_erc> Cale: Is my explanation coherent?
09:34:52 <Cale> Oh, btw, if you use Either to provide an option of failure, the failing case should *always* be Left
09:35:16 <Cale> This is because of how the Monad instance for Either works (and has to work)
09:35:23 <Cale> (and Functor, etc.)
09:35:46 <emmanuel_erc> Yeah, the bindings I am using (provided by someone else, specifically from the library qhull-simple on hackage) did it the other way around for some reason.
09:36:20 <emmanuel_erc> I downloaded the library from hackage. It wouldn't be too much trouble to just rewrite parts of the bindings.
09:36:21 <maerwald> can you export something from a module as a different name?
09:36:54 <maerwald> I'm trying to hide a constructor, but want a PatternSynonym available with the same name... that yields like ~200 type errors in the module
09:36:59 <maerwald> and I am too lazy to fix
09:39:18 <merijn> maerwald: Are you exporting the synonym correctly? Also, I'm not sure if that's allowed
09:39:38 <emmanuel_erc> Cale: Do you want me to keep going with the explanation?
09:40:57 <ggVGc> what's the best way to read a file, process the contents with a function if it exists and return a default value if it doesn't?
09:41:31 <maerwald> I guess I'll just rename the constructor lol
09:41:43 <Cale> emmanuel_erc: Sorry, just being a bit distracted by work
09:42:27 <Cale> emmanuel_erc: I would actually rewrite those parts of the bindings to fix it. :)
09:42:39 <emmanuel_erc> Cale: I changed it already.
09:42:50 <emmanuel_erc> I might also send an e-mail to the maintainer.
09:43:03 * hackagebot mysql-simple-typed 0.1.1.3 - Typed extension to mysql simple  https://hackage.haskell.org/package/mysql-simple-typed-0.1.1.3 (tolysz)
09:43:15 <emmanuel_erc> I understand if you are busy. Thank you for talking the time out of your day to help a stranger.
09:45:00 <maerwald> merijn: that should work fine, the constructor is defined in an internal module, imported from the API modules, but not exported there
09:45:18 <maerwald> just the name clash is annoying, so I renamed the constructor
09:45:44 <maerwald> Mk<type> is clearer anyway
09:45:49 <maerwald> (or a constructor)
09:45:53 <maerwald> *for
09:46:26 <blume> What a wonderful day. All my love to all you haskell devs out there :)
09:52:57 <roelof> just to be curoius : Can this also be build with just cloud haskell or another "framework" ? https://github.com/buckie/juno
10:07:36 <broma0> what do you guys think about using MonadThrow from 'execptions' instead of ExceptT/MonadError from 'mtl' in a "ReaderT/StateT/IO" stack? What's the best way to add exception handling to a stack (don't worry, I'm only using the concrete stack to run all of the typeclass-generalized functions?
10:09:50 <mpickering> maerwald: You can't properly do that until GHC 8.0 is released
10:09:55 <mpickering> and then hopefully you can
10:10:15 <mpickering> because annoyingly until now you have to explicitly import/export pattern synonyms
10:11:14 <roelof> Anyone who has played with cloud haskell ? 
10:15:09 <cocreature> roelof: you might want to ask that question in the reddit thread https://www.reddit.com/r/haskell/comments/49hkgr/juno_byzantine_fault_tolerant_raft_with_smart/ the devs are probably more likely to see it there and can explain why they didn’t simply go with haskell for this project
10:16:00 <roelof> cocreature:  or I can search for a haskell-cloud mailing list and ask there too 
10:16:30 <lpaste> emmanuel_erc annotated “Is my usage of the Endo type misplaced here?” with “Is my usage of the Endo type misplaced here? (annotation)” at http://lpaste.net/154243#a154245
10:20:24 <ironChicken> why would $ cabal test say "cabal: At least the following dependencies are missing: Cabal -any"?
10:20:43 <ironChicken> and this is a package that I've been runnin the test suite on for several weeks
10:21:13 <dcoutts> ironChicken: and if you first run, cabal configure --enable-tests ?
10:22:23 <ironChicken> dcoutts: yes, i've done that
10:22:50 <dcoutts> ironChicken: and that complete's successfully?
10:23:05 <ironChicken> yes
10:23:32 <ironChicken> oh actually, it does "Warning: This package indirectly depends on multiple versions of the same"
10:23:51 <dcoutts> ironChicken: ok, try, cabal install --only-dep --enable-tests
10:23:58 <ironChicken> i've done that
10:24:12 <ironChicken> i even deleted and re-build the sandbox
10:24:36 <ironChicken> oh hang on, i didn't try install --enable-tests
10:24:38 <bitonic> Is there a library capable of just getting JPEG metadatata -- whether a file is indeed a JPEG image, and what its size is
10:24:43 <ironChicken> is that really a thing?
10:24:55 <shapr> GOOD AFTERNOON!
10:25:17 <dcoutts> ironChicken: sure, you need it to be consistent with what you're configuring
10:25:36 * dcoutts notes that this is all automated with the next gen cabal stuff
10:25:59 * kadoban notes that this is all automated with the current gen stack stuff
10:26:38 <ironChicken> dcoutts: ok. i've never done install --enable-tests before and this has been working for several weeks
10:27:18 <ironChicken> it actually now warns me about some re-installs, and lists some likely to break packages
10:27:34 <jle`> emmanuel_erc: not sure if your Endo usage is necessarily constructive because you don't really use any monoid-polymorphic methods
10:27:37 <ironChicken> just to confirm: i'm only trying to build my package in its sandbox
10:27:46 <jle`> emmanuel_erc: instead of 'mempty' you can use 'id' and instead of '<>' you can use '.'
10:27:51 <ironChicken> and run its tests
10:28:29 <dcoutts> ironChicken: enabling a test suite can add extra constraints and change the versions of things that have to be used, so it's quite possible that with and without --enable-tests give different solutions
10:29:05 <ironChicken> dcoutts: ok. but i don't understand why my test suite has been working for several weeks
10:29:11 <dcoutts> ironChicken: luck
10:29:21 <kadoban> ironChicken: Can you lpaste the .cabal file perhaps? There might be something obviously wrong.
10:29:31 * dcoutts notes that the next gen cabal solves with test suites enabled to stop this kind of inconsistency or flip-flopping
10:29:52 * ironChicken keenly awaits the next gen
10:30:07 <dcoutts> ironChicken: if you want to be a beta-tester you're most welcome :-)
10:30:47 * ironChicken tries to look busy
10:30:52 <dcoutts> ;-)
10:30:58 <kadoban> Haha
10:33:14 <lpaste> ironChicken pasted “cabal --enable-tests” at http://lpaste.net/154246
10:34:36 <ironChicken> actually, i need to go
10:34:46 <ironChicken> i'll check the logs later in case anyone has any suggestions
10:35:13 <kadoban> Hmm, I expected version constraints to be the problem, but apparently not.
10:35:54 <puregreen> is there any list of common lenses, traversals, prisms, etc together in one place?
10:36:28 <dmj`> puregreen: https://github.com/ekmett/lens/wiki/Operators ?
10:36:59 <jle`> the lens library documentation has common lenses, traversals, prisms, etc. listed by category, but it does require clicking through to find the one you want
10:37:05 <puregreen> dmj`: no, it has operators and I want lenses themselves
10:37:17 <puregreen> _1, each, lazy, at, ix, etc etc etc
10:37:21 <jle`> i usually just use the lens library documenation, it's often intuitive where things are
10:37:23 <dmj`> puregreen: ah, hm
10:38:18 <jle`> 'each' would be in Control.Lens.Each, _1 in Control.Lens.Tuple, etc
10:38:28 <jle`> ix in Control.Lens.Indexed
10:38:43 <jle`> usually you can find the lens/traversal you want by looking at the module list :)
10:39:05 <puregreen> jle`: I know where things are! I need a cheatsheet for people who don't and haven't ever used lenses
10:39:30 <jle`> ah i see
10:41:33 <puregreen> okay, I guess I'll write one myself
10:42:49 <jle`> puregreen: let me know if you find/make one :)
10:43:27 <dmj`> puregreen: me too
10:44:34 <Jookia> o/ I've done some searching recently and read that Haskell doesn't have good autotools support (as of 2013), is it better nowadays?
10:45:44 <tdammers> autotools? what's the use case?
10:46:11 <Jookia> Instead of using cabal
10:46:25 <tdammers> oh, hmm
10:46:59 <tdammers> I'm not sure if anyone has been working on that front, afaik most of the effort is going towards stack instead
10:47:06 <Jookia> Ah
10:47:20 <Jookia> Is it possible to compile Haskell using makefiles?
10:47:37 <Jookia> I also am interested in FFI between C and Haskell, using makefiles/autotools too
10:47:48 <tdammers> yes, but it's a much rockier path than using cabal
10:48:41 <Jookia> The only thing I'd really like to use cabal for is downloading dependencies and sandboxing, not building
10:53:49 <roelof_> Jookia:  what do you want to achieve then ? 
10:54:51 <Jookia> A mostly language-agnostic build system (combining multiple language code) and GNU build system compatibility
10:55:11 <breadmonster> Any updates on ghc 8?
10:56:49 <jle`> breadmonster: maybe look at https://ghc.haskell.org/trac/ghc/roadmap ?
10:58:12 <Cooler> when you want to build your project
10:58:21 <Hijiri> I didn't know detexify backend was written in haskell
10:58:22 <Cooler> do you have to type cabal install each time?
11:00:00 <shanemikel> I'm thinking I want to play around with ffi and IPC.  So I'm planning on reading Ritchie's c programming book, and I'm guessing in order to work with something like x11, I'm thinking I can use ST or IoRefs to populate an x buffer in Haskell.. Is that a legit use for ST ?
11:00:28 <formaggio> Hi everyone, I'm an High School student who has approached Haskell this morning, wanting to challenge my mind with FP rather than the "usual" OOP. I'm elaborating on one of the examples of TryHaskell.org: reading a list of numbers, a divisor, and showing which of those numbers can be exactly divided by the divisor. I'm having some troubles in reading input and casting to an Integer, can anybody help me?
11:00:30 <formaggio> Here's my code so far: http://pastebin.com/h0kC9CYc
11:00:38 <xa0> what do you guys think of perl 6, out of curiosity?
11:00:47 <formaggio> Whoa, that looked a lot less lengthy as I typed it...
11:01:34 <xa0> formaggio: you can't cast the output of words to [integer] like that
11:01:38 <xa0> it must be [string]
11:01:39 <xa0> er
11:01:46 <xa0> [[char]] i mean
11:02:34 <xa0> or were you trying to cast the read? in which case it's the parsing that's ruining it for you
11:03:43 <formaggio> xa0: I'm not really sure of what's the best way to do so yet, I'm just thinking of reading a single number from the user's input
11:04:47 <formaggio> I managed to get the list through thanks to some code that I fully don't understand yet - but I'm reading the book "Learn Yourself A Haskell" and I'm at the beginning, so I still have a lot to learn
11:05:03 <xa0> what error are you getting?
11:05:41 <Jookia> Also is there a way to avoid compiling C code with GHC when using the FFI?
11:06:38 <shanemikel_> Also, does xmonad actually have an x monad that's useful in regular x applications
11:06:47 <kadoban> formaggio: Just to warn you, LYAH isn't really the best way to learn haskell by itself. http://haskellbook.com/ is well regarded or if it must be free https://github.com/bitemyapp/learnhaskell has good advice
11:06:50 <xa0> formaggio: at a guess, you need to (read divideBy :: Integer) your divideBy variable
11:08:45 <shanemikel_> Lyah isn't gonna hurt you to read through it.  Just know that whatever book you use, you're gonna need to supplement it with a lot of the wiki 
11:09:19 <kadoban> LYAH hurts when people expect it to teach them haskell and it doesn't.
11:10:39 <shanemikel_> I do like haskellbook myself, but I also like lyah supplemented with Stephen deils "what I wish I knew when I was learning Haskell".. Just make sure to read all the wiki links Stephen recommends
11:11:13 <maerwald> kadoban: I found it's rarely useful for anything, except when you come from a bad teaching resource and need it to be a little bit unfolded
11:11:25 <maerwald> because it is so verbose
11:12:55 * roelof_ likes the haskell book very much 
11:13:54 <sleblanc> shanemikel_, you can ask over at #xmonad
11:14:07 <xa0> anyone have an opinion on perl 6?
11:14:09 <formaggio> kadoban: Acknowledged, thanks for the tip
11:14:59 <formaggio> xa0: that snippet works fine! Thanks :)
11:15:26 <xa0> no prob :)
11:17:40 <maerwald> xa0: only about perl in general and it unfortunately involves swear words ;)
11:17:45 <shanemikel_> Yeah, I'll try seblanc but I expect more xmonad users than Haskell programmers over there
11:18:07 <xa0> maerwald: fair enough :p 
11:18:19 <Cooler> what does the -j flag mean when using cabal install -j
11:19:00 <sleblanc> Cooler, the help option says it's to enable concurrent jobs
11:19:48 <Cooler> i setup a cabal sandbox and installed a test project
11:20:02 <Cooler> everytime i change the source code and want to build it
11:20:09 <Cooler> do i have to type cabal install?
11:20:36 <Cooler> or is there something else like cabal build
11:21:26 <xa0> literally cabal build
11:21:29 <irc-ape> burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all 
11:21:29 <irc-ape> jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas 
11:21:30 <irc-ape> oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn 
11:21:31 <irc-ape> all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######
11:22:00 <maerwald> omg
11:22:01 <pilne> nice to see we haven't (as a whole) managed to evolve past willful ignorance....
11:22:05 <irc-ape> DEATH TO INFIDELS
11:22:08 <kadoban> Cooler: In case nobody has mentioned it, 'stack' is a lot easier for most use-cases IMO.
11:22:09 <irc-ape> ONLY MUSLIMS HAVE A RIGHT TO LIVE
11:22:17 <irc-ape> burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all jews in gas oven ######burn all 
11:22:18 <tdammers> @where ops
11:22:18 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
11:22:26 <tdammers> nevermind
11:23:19 --- mode: ChanServ set +o shachaf
11:23:27 --- mode: shachaf set -o shachaf
11:23:58 <shanemikel_> Well that was nice
11:24:15 <maerwald> not
11:24:20 <roelof_> wierd ape. I think everyone has the right to live peacefully 
11:25:51 <shanemikel_> I've never seen irc spam of that nature before
11:26:20 <jbiesnecker> shanemikel_ it's like that old saying, if you sit in a channel for long enough, the entire world passes in front of you.
11:26:24 <maerwald> it's not uncommon, but most of the time they emit random spam and not specific stuff like that
11:29:08 <greg`> simple question but why does :t 1  , give a type of Num and not Integral
11:29:28 <xa0> why can't it be a float? :)
11:29:56 <greg`> i thought floats and fractionals were denoted with a .
11:30:22 <roelof_> nope, a means can be of any type 
11:30:25 <c_wraith> > 1 :: Double 
11:30:28 <lambdabot>  1.0
11:31:00 <greg`> :t 1.0
11:31:01 <lambdabot> Fractional a => a
11:31:07 <greg`> :t 1
11:31:09 <lambdabot> Num a => a
11:31:35 <roelof_> greg`:  and what do you think the a means here 
11:31:54 <greg`> instance of type class
11:32:08 <scshunt> a is just a type variable
11:32:16 <roelof_> and what are the instances of Num ?  greg 
11:32:25 <shanemikel_> Num is a type class.  It's called ad-hoc polymorphism, and the way it works with numbers in Haskell is a little tricky
11:32:33 <greg`> :i Num
11:34:10 <greg`> well anything that declares itself an instance of num fulfilling the typeclass functions is a Num , I get it
11:34:24 <shanemikel_> Types need to be concrete to be used, and numbers that aren't specified will be constrained by context first, and If there isn't enough context to make concrete, there are 'default' instances of fractional and integral
11:34:26 <kadoban> lambdabot doesn't have :i.  But it's Num and not Integral because it's useful to be able to use a numeric literal like 1 as a Float or a Double or whatever too.
11:34:47 <roelof_> greg, and the output of :i Num is this : http://lpaste.net/154249
11:35:15 <roelof_> so 1 can be a int and Int a Float or a Double 
11:35:41 <greg`> I guess im struggling with the idea that anything thats not fractional should be an integral , but i see that is perhaps naive
11:37:31 <kadoban> greg`: It might make more sense if you look at what Integral means. It's about types that have integer division more than anything else.
11:37:36 <shanemikel_> That statement doesn't really make sense.. Try to learn about type classes first, not in context of numbers, and then read about the default instances for numbers, because it's a little unusual in that case
11:38:29 <shanemikel_> Integral and fractional are subclasses of num
11:39:05 <shanemikel_> Look at the num constraint in their definitions
11:39:48 <greg`> shanemikel_:  thanks thats what i need to see the num contraint in integral
11:44:28 <shanemikel_> Actually, you may need to follow the hierarchy a little to see that, because I think there is Real in there somewhere
11:44:53 <greg`> yes ive noticed, it seems more direct with Fractional however
11:46:59 <roelof_> just out of curiosity : can I do things like distributed programming in Haskell So I can use nodes to do for example some math 
11:47:40 <greg`> roelof_: i think there was a haskell api released for spark recently
11:48:08 <Rembane> roelof_: Yes, in a couple of different ways.
11:48:14 <greg`> also you may want to see gabriel's state of haskell update , because i think theres a distributed programming section
11:48:23 <greg`> will help you see how mature the tools are
11:48:34 <Rembane> roelof_: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#numerical-programming
11:48:38 <Rembane> roelof_: And https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#distributed-programming
11:48:53 <greg`> thanks all i understand the Num/Integral inference.... I think it was all due to my own assumptions
11:49:29 <roelof_> Rembane:  thanks for the info  
11:49:49 <Rembane> roelof_: np
11:49:55 <Rembane> roelof_: Good luck! :)
11:50:58 <roelof_> Rembane:  thanks 
11:51:03 <greg`> https://github.com/tweag/sparkle
11:59:23 <roelof_> greg`:  thanks 
12:08:20 <shanemikel> is there a way to specify a dev (but not build) dep like ghc-mod?
12:08:27 <shanemikel> in stack or cabal
12:08:48 <shanemikel> I'm using stack, but cabal to generate the stack.yaml
12:14:48 <mniip> 1457465021 [22:23:41] <shanemikel_> I've never seen irc spam of that nature before
12:14:58 <mniip> good job staying in a very refined set of channels ;)
12:15:13 <mniip> Gurkenglas, no, you can't do s->a
12:15:47 <formaggio> I'm up and running with my new exercise, but the editor is yelling at me for the use of `map round myList` in the last line of this code: http://pastebin.com/6ZiUk5Nu
12:16:19 <kadoban> shanemikel: By that do you just mean you're using ghc-mod in your editor or whatever to analyze the code?
12:16:20 <formaggio> The warning reports: "Defaulting the following constraint(s) to type ‘Integer’" - what am I missing?
12:17:38 <kadoban> formaggio: What's the type of 'map round myList' ?
12:17:59 <formaggio> kadoban: myList is made of Floats
12:18:08 <kadoban> formaggio: That's not really what I asked.
12:18:32 <formaggio> kadoban: forgive me, this basically is my first Haskell exercise...
12:18:53 <shanemikel> kadoban: yeah, but I've been having a strange experience with ghc-mod since I started using cabal sandboxes (and now stack).. to get ghc-mod to resolve my installed packages right for each sandbox, I've been installing it in the sandbox itself.. It seems unneccessary, but I think that's where my editor plugins are looking
12:19:13 <kadoban> formaggio: Ah, right I forgot your name from before. The warning is a bit obscure at the moment, you could probably just ignore it for now. It's not a problem really.
12:19:40 <shanemikel> and I would imagine that it's ugly when you're using different ghc versions on different projects
12:19:49 <shanemikel> so, I just skip that and install it in the sandbox
12:20:16 <formaggio> kadoban: ok, I like hiding things under the carpet - thanks :)
12:20:32 <formaggio> out of curiosity, what should have I answered to your question?
12:20:37 <kadoban> shanemikel: Yeah ghc-mod is kind of a mess right now, heh. I've kind of given up on caring about it until tooling gets better.
12:20:54 <formaggio> I have the feeling that I could find that out through ghci
12:21:39 <kadoban> formaggio: 'map round myList' should be of type something like … :: Integral a => [a]  meaning that for any instance of Integral, it's a list of them.
12:22:40 <kadoban> formaggio: And then all you're doing with that list is using 'show' with it. So the warning comes about because there's *many* types haskell could pick concretely to satisfy the typeclass constraints and it has to just pick one, so it picks Integer by default. Which is … sometimes not what you want so it gives you a warning.
12:23:34 <kadoban> formaggio: (if you didn't understand all of that I wouldn't be surprised, and it's not terribly important right now, just you asked)
12:24:33 <abrar> hi everyone, we've got haskell job openings: https://www.reddit.com/r/haskell/comments/49jjff/haskell_opportunities_at_obsidian_systems/
12:24:35 <formaggio> kadoban: thanks for the explanation, it's basically like multiple constructors in OOP if I got that correctly
12:25:38 <formaggio> reqriting the code in ghci and issuing ':t' reports "myList :: [Float]"
12:25:51 <kadoban> formaggio: Hmm, it's a bit like that, but not exactly if I understand correctly.
12:26:04 <Cale> formaggio: Yeah, try  :t map round myList
12:26:27 <Hijiri> multiple constructors in OOP would all give the same type, but with typeclasses each possible type is distinct
12:26:38 <Hijiri> I think
12:26:41 <Cale> :t map round [1, 2, 3, 4 :: Float]
12:26:42 <lambdabot> Integral b => [b]
12:26:47 <Hijiri> if multiple constructors just means a class has more than one constructor
12:27:23 <EvanR> formaggio: what do you mean multiple ctors in OOP, i was wondering about something with this name myself
12:27:25 <formaggio> Cale: "map round myList :: Integral b => [b]" - so it's a list of Integrals, right?
12:27:26 <EvanR> but never heard of it
12:27:41 <Cale> So the result here could be [Integer] or [Int] or [Word8], or a number of other types
12:28:05 <formaggio> Hijiri: I'm kind of messed up from studying Java in the morning, NodeJS in the afternoon and Haskell in the evening haha
12:28:29 <kadoban> abrar: Neat
12:28:35 <EvanR> do any languages let you have more than one constructor in a class?
12:29:11 <formaggio> EvanR: most OOP languages do, am I wrong?
12:29:18 <EvanR> which one?
12:29:25 <xa0> java does
12:29:27 <formaggio> Java for example
12:29:34 <xa0> not all do
12:29:40 <EvanR> oh. they all have the same name but different "arity" 
12:29:46 <formaggio> And C++ too if I remember correctly
12:29:54 <EvanR> are there any that let you have differently named ctors
12:30:04 <xa0> how would that work
12:30:14 <EvanR> how does Either work?
12:30:26 <xa0> sorcery
12:30:29 <formaggio> different parameters but not names
12:30:33 <formaggio> xa0: hahaha
12:30:39 <mnoonan> it's a common pattern in C++ to use static methods for that.
12:30:43 <EvanR> oh really
12:30:51 <Cale> Scala has "case classes"
12:30:52 <xa0> that makes much more sense
12:31:00 <Cale> http://docs.scala-lang.org/tutorials/tour/case-classes
12:31:26 <mnoonan> but if you can't pattern match on the constructor that was used, it's all a bit silly to compare anyhow.
12:31:37 <EvanR> so in that example Var Fun and App are all Terms?
12:31:42 <EvanR> but also are their own class
12:31:43 <Cale> Yeah
12:33:19 <Cale> (Of course, you also have this kind of thing going on in all cases where subtyping gets used)
12:33:25 <Bruuuuno> So I have this data type from a librairy, which is a newtype over a ReaderT. However, the implementation isn't public and I need to use the readerT, is there a way to get it without changing the librairy source code?
12:34:29 <EvanR> you can import their internal modules
12:34:53 <Cale> (assuming they expose them)
12:35:16 <EvanR> oh, can you hide modules completely?
12:35:23 <Cale> yes
12:35:44 <Bruuuuno> the internal module isn't exposed
12:36:02 <Cale> Also, if the module where the definition is just doesn't export the data constructor, then you're out of luck.
12:36:27 <EvanR> Bruuuuno: how proficient are you with unsafeCoerce ;)
12:36:32 <Cale> The fact that it happens to be implemented with ReaderT is immaterial if you can't see the implementation because you can't pattern match
12:36:35 <Cale> lol
12:36:39 <Cale> Don't unsafeCoerce
12:36:52 <EvanR> will that not work
12:37:23 <Cale> Well, it will screw you over when the library author changes the implementation of their monad (which they left abstract potentially for a reason)
12:37:26 <EvanR> were already talking about breaking all the rules heh
12:37:36 <EvanR> might as well turn it up to 11
12:37:49 <Cale> and you suddenly get arbitrary code execution which just results in a segfault assuming you're lucky
12:38:25 <Cale> Which library is it?
12:38:31 <Bruuuuno> reactive banana
12:38:46 <EvanR> theres probably a better way 
12:38:56 <Cale> And which type? Why do you need access to the ReaderT?
12:39:22 <Bruuuuno> MomentIO
12:39:38 <Cale> MomentIO doesn'
12:39:46 <Cale> doesn't appear to be a ReaderT
12:39:59 <EvanR> good thing you didnt unsafeCoerce then
12:40:10 <Bruuuuno> it is
12:40:37 <Cale> It's kind of slightly the same thing as a Reader
12:40:54 <Cale> But it doesn't actually use ReaderT
12:41:03 <Cale> newtype MomentIO a = MIO { unMIO :: Prim.Moment a }
12:41:14 <Cale> newtype Moment a = M { unM :: Time -> a }
12:41:38 <Bruuuuno> no, it's Prim.Moment
12:42:09 <Bruuuuno> import qualified Reactive.Banana.Internal.Combinators as Prim
12:42:17 <EvanR> so its a Time reader
12:42:28 <Bruuuuno> type Moment     = ReaderT EventNetwork Prim.Build
12:42:36 <EvanR> and whats it gotta do with IO
12:42:56 <Bruuuuno> https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/src/Reactive/Banana/Internal/Combinators.hs
12:42:59 <Cale> Oh, I see
12:43:01 <Cale> yeah
12:43:20 <Cale> Well, if you don't have that MIO constructor, you're basically out of luck.
12:43:58 <EvanR> Bruuuuno: if youre trying to add a feature to reactive banana, why not fork it?
12:45:11 <Bruuuuno> I was trying to avoid doing that lol, but I guess I have no choice
12:45:32 <EvanR> yep
12:45:48 <EvanR> the right way to mess with library code is to mess with the libraries code ;)
12:46:07 <Cale> Well, what would you do with access to the ReaderT anyway?
12:46:41 <Cale> You have an instance of MonadMoment at least...
12:47:02 <Cale> So you can liftMoment :: Moment a -> MomentIO a
12:47:35 <Bruuuuno> basically, I'm trying to bind with another library and I'm having a function to create an event
12:47:50 <Bruuuuno> but it returns (MonadIO m, FromJSON a, MonadState RoutingTable m) =>  m (MomentIO (Event (Socket, a)))
12:48:19 <Bruuuuno> so I have to bind two times to get the event, I'm trying to bind only one time
12:51:13 <Cale> hm, well, you probably want to runStateT, no?
12:52:22 <Cale> Well, no, even so... you'll have to run the IO action...
12:52:44 <Cale> That might be essential though, there might not be a way around that.
12:53:06 <Cale> The action which is creating the MomentIO action for you could be e.g. setting up IORefs and stuff.
12:53:38 <Bruuuuno> I see :(
12:54:09 <Cale> But I dunno what's going on
12:54:40 <Cale> Maybe there's some other way to use the stuff you have to end up with a  MomentIO (Event (Socket, a)) without the other monad
12:55:54 <Cale> I guess MomentIO is itself a MonadIO instance, so you could runStateT to get to IO (MomentIO (Event (Socket, a))) and then join . liftIO
12:56:01 <Cale> yeah
12:56:04 <Cale> that'd do it
12:57:35 <Bruuuuno> i'll try
13:01:47 <Cooler> can anyone help with understand this function? http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.OldList.html#tails
13:01:56 <Cooler> what does build do?
13:02:56 <Cale> Cooler: build is kind of like the "opposite" of foldr
13:03:12 <Cale> build f = f (:) []
13:03:39 <Bruuuuno> I don't think that it will work Cale, I still need the MonadState RoutingTable to create my event :/
13:03:54 <Cale> Bruuuuno: Do you have a RoutingTable you can use?
13:04:07 <Bruuuuno> what do you mean?
13:04:13 <Cale> You could just make the thing a function of a RoutingTable
13:04:24 <Cale> RoutingTable -> MomentIO ...
13:04:37 <Cale> (where you runStateT)
13:05:07 <Cale> I rarely like using MonadState over IO anyway
13:05:37 <Bruuuuno> wouldn't that break the context of which it's used?
13:05:42 <Cooler> Cale what does foldr do?
13:06:00 <Cale> @src foldr
13:06:00 <lambdabot> foldr f z []     = z
13:06:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:06:25 <Cale> foldr f z xs basically replaces each occurrence of (:) in building up the list xs with f, and the [] at the end of the list (if any) with z
13:06:49 <Cale> Bruuuuno: Well, I don't know how you're using this stuff...
13:07:18 <Cale> Bruuuuno: Personally, I tend to prefer parameter passing over StateT
13:07:38 <Cooler> Cale, i am not sure what you mean by "building up the list"
13:08:09 <Bruuuuno> oh sorry I forgot to tell, basically I'm doing a reactive banana binding over socket-io
13:08:23 <Cale> Cooler: well, every list is either the empty list [], or it is a nonempty list formed from a first element x and another list xs as (x:xs)
13:08:41 <Cale> That is, (:) x xs, if we want to write it prefix instead of infix
13:09:09 <Cale> Cooler: So, foldr recursively goes through the structure of the list, and replaces each occurrence of (:) with the function f
13:09:24 <Cale> and replaces the [] (if the list isn't infinite) with z
13:09:30 <Cale> e.g.
13:09:41 <Bruuuuno> the bindings to the socket is used in a StateT RoutingTable (ReaderT Socket m) a, there https://hackage.haskell.org/package/socket-io-1.3.5/docs/Network-SocketIO.html.
13:09:42 <Cale> foldr f z (1 : (2 : (3 : [])))
13:09:50 <Cale> -> f 1 (f 2 (f 3 z))
13:10:44 <Bruuuuno> my function earlier is converting the "on" function to an reactive banana
13:12:51 <Cale> ... what is this... OnArgs?
13:14:30 <Cale> Oh, some stupid hackery to do varargs nonsense rather than just providing an aeson Array...
13:14:43 <Bruuuuno> that part is already binded
13:15:39 <Cooler> Cale, so f is a function of type  Int -> Bool  in that example?
13:16:00 <Cale> Cooler: It needs at least two arguments
13:16:07 <Cale> Cooler: It might be Int -> Bool -> Bool
13:16:16 <Bruuuuno> https://github.com/bruno-cadorette/TheLambdaReactor/blob/master/src/Backend/Reactive.hs my implementation is there
13:16:16 <Cooler> right typo
13:16:32 <Cale> > foldr (\n b -> even n && b) True [2,4,6,8]
13:16:34 <lambdabot>  True
13:16:37 <Cale> > foldr (\n b -> even n && b) True [2,4,7,8]
13:16:38 <Cooler> Cale, can it only be Bool or can it return other types?
13:16:39 <lambdabot>  False
13:16:47 <Cale> It can be any type at all
13:16:53 <cmotoche> Is someone of you using ghcmod-vim? Do you know how can I display the suggestions from hlint or ghcmod in more than 1 line?
13:17:02 <Cale> > foldr (:) [] [2,4,7,8]
13:17:04 <lambdabot>  [2,4,7,8]
13:17:11 <mniip> 1457471669 [00:14:29] <Cooler> Cale, can it only be Bool or can it return other types?
13:17:14 <mniip> consult :t
13:17:15 <Cale> ^^ if we replace each (:) with (:) and [] with [], we get the same list
13:17:18 <mniip> :t foldr
13:17:19 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:17:24 <Cale> ... yeah
13:17:37 <Cale> Pretend that says (a -> b -> b) -> b -> [a] -> b
13:17:52 <Cale> Foldable is just an extra layer of shenanigans
13:18:07 <Cooler> Cale, so what build again?
13:18:16 * mniip . o O (why does prelude use (->), just use arrows and profunctors)
13:18:20 <Cale> Cooler: build f = f (:) []
13:18:52 <greg`> does :: have a high or low precedence?
13:18:55 <mniip> ooh are you explaining list fusion
13:18:56 <xa0> mniip: there are other generalisations besides arrows, aren't there?
13:19:01 <xa0> lol
13:20:08 <Cale> greg`: It's not an operator, but if it were, it would have lower precedence than anything else, including function application
13:20:14 <Cale> er, including ($)
13:20:21 <Cale> function application has really high precedence :P
13:20:39 <blume> wow haskell dev is s ofast
13:20:45 <Cale> greg`: It basically extends over the entire expression, as far as it can
13:20:46 <greg`> thanks Cale, yes I understand its not an operator, didnt really know how else to pose the question however
13:20:47 <blume> hard to have new ideas :P
13:21:09 <Cale> greg`: yeah, fair enough :)
13:21:22 <xa0> :i ($)
13:22:39 <Cale> ($) :: (a -> b) -> a -> b 	-- Defined in ‘GHC.Base’
13:22:39 <Cale> infixr 0 $
13:22:59 <xa0> ty
13:23:03 <Cale>      ^ this should be an l but it's not :(
13:23:12 * hackagebot katip 0.1.1.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.1.1.0 (MichaelXavier)
13:23:13 <xa0> why 1?
13:23:14 * hackagebot katip-elasticsearch 0.1.1.0 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.1.1.0 (MichaelXavier)
13:23:26 <Cale> infixl would make it associate to the left
13:23:37 <Cale> like function application normally does
13:23:59 <dmwit> xa0: l, not 1
13:24:00 <mniip> Cale, FORALL (W :: LEVITY) (B :: TYPE W). (A -> B) -> A -> B
13:24:10 <xa0> right, just realised
13:24:12 <Cale> mniip: :P
13:24:43 <Cale> mniip: I kinda wish we could just dehackify ($) instead
13:25:13 <Cale> mniip: Levity polymorphism can stay if it people need it for some other reason
13:25:26 <Cale> It's fine, but it's not something I'd want to shove into Prelude definitions
13:25:32 <verement> infixl ($) sounds awful
13:25:35 <mniip> Cale, just imagine
13:25:46 <blume> deepdream
13:25:48 <blume> yay
13:25:48 <mniip> (Profunctor p, Profunctor q) => q (p a b) (p a b)
13:26:00 <blume> welcome to the party RNNs
13:26:06 <Cale> verement: Well, pretty much any time that the associativity of ($) presently matters, you can replace all but the last ($) in the chain with (.)
13:26:13 <shachaf> mniip: Why ont Category q?
13:26:20 <mniip> hmm you're right
13:26:38 <mniip> might as well drop the constraint on p
13:26:47 <blume> n-catlab so profound...
13:26:52 <mniip> actually let's just say ($) = id
13:26:56 <Cale> verement: i.e. you can always write  f . g . h $ x  instead of  f $ g $ h $ x  and moreover, you probably should, because (.) is properly associative, making such expressions nicer to manipulate and read.
13:27:00 <mniip> with all the consequences
13:27:14 <mniip> oh wait, that's Control.Category
13:27:16 <mniip> damnit
13:27:29 <blume> why ddamnit?
13:27:31 <blume> mniip: 
13:27:40 <mniip> someone did it before me ;)
13:27:47 <blume> oh too slow to help i see
13:27:48 <blume> hehe
13:27:51 <mniip> and it wasn't even edwardk, which is outrageous
13:27:57 <Cooler> Cale, what exactly does build do?
13:27:59 <blume> who did it
13:28:03 <verement> Cale: fine, but how would infixl ($) be useful?
13:28:08 <Cooler> it builds a list using a function?
13:28:12 * hackagebot present 4.0.0 - Make presentations for data types.  https://hackage.haskell.org/package/present-4.0.0 (ChrisDone)
13:28:25 <mniip> Copyright	(c) Ashley Yakeley 2007
13:28:26 <Cale> Cooler: Yeah. Using a function which is meant to take (:) and [] as arguments.
13:28:31 <dolio> f $ w+x $ y+z
13:28:31 <mniip> that guy apparently
13:28:55 <Cale> Cooler: The thing is that if you have code which looks like  foldr f z (build g)
13:29:15 <Cale> Cooler: You can replace that with  g f z
13:29:24 <Cale> Cooler: which eliminates the construction of an intermediate list
13:29:27 <jle`> infixl $ would be nice
13:29:39 * blume meditates on id
13:29:39 <dmwit> verement: f (g x) (h y) could be completely deparenthesized
13:29:44 <Cale> Cooler: The list library contains a bunch of rewrite rules which look for occurrences of such things after inlining
13:29:45 <Cooler> Cale, can you give an example of build?
13:30:10 <Cale> build (\c n -> c 1 (c 2 (c 3 n)))
13:30:11 <Cale> = [1,2,3]
13:30:12 <mniip> build (\c n -> c 1 (c 2 (c 3 n)))
13:30:13 <mniip> hahah
13:30:33 <blume> :o
13:30:35 <Cale> The #haskell stereo effect
13:30:47 <blume> #memes
13:30:54 <mniip> no memes allowed
13:30:55 <blume> ^.^
13:30:57 <blume> oh
13:30:59 <blume> SORRY
13:31:02 <verement> dmwit: care to elaborate?
13:31:12 <blume> going back to the rules and attitude! wont ever happen ]again
13:31:26 <Cale> verement: It would become f $ g x $ h y
13:31:36 <xa0> without affecting current usage
13:31:52 <xa0> (because pointfree)
13:32:03 <Cale> xa0: Well, it would deeply affect some people's usage of $ unfortunately
13:32:12 <maerwald> hmm, my patternsynonym makes GHC think I have non-exhaustive pattern matching, what to do?
13:32:14 <Cale> This is a change which I expect never to happen
13:32:16 <dmwit> verement: try eliminating parens with current $ and you'll see?
13:32:20 <xa0> true
13:32:59 <Cale> But yeah, I consider the right-associativity of ($) to be a little mistake
13:33:21 <Cale> The other nice thing about having it left-associative
13:33:33 <Cale> is that it would work well together with a left-associative $!
13:33:48 <Cale> So you could write things like  f $ x $! y $ z
13:33:56 <Cale> If you want to strictly apply the second parameter
13:37:30 <verement> yeah that's interesting, but completely destroys my mental model and mnemonic of ($)
13:38:16 <xa0> it's still function application
13:39:52 <verement> (the character $ visually looks like a pair of parentheses wrapping around [the rest of] a line)
13:40:00 <dmwit> verement: you can't improve without changing =)
13:40:11 <xa0> ah, haha
13:40:15 <verement> all change is not improvement
13:40:46 <dmwit> no points for completing the platitude
13:40:54 <dmwit> very few points for starting it, to be fair
13:43:32 <dolio> How do you know it's wrapping the rest of the line and not the first part of the line, other than memorization?
13:43:37 <NemesisD> if you manually upload docs to hackage does it take a while to show up?
13:44:01 <dolio> Of course, it's also not the same as wrapping the rest of the line in parentheses.
13:46:40 <parsecChar> I'm trying to build a haskell->js compiler (sorta like haste/ghcjs, but toy compiler)
13:46:52 <parsecChar> is there way to tell ghc to "desugar entire file, and also resolve type calsses" ?
13:47:11 <parsecChar> so I'd like do { putStrLn "asdf"; putStrLn "hello world"} to get resolved to (bind_IO ... ... ) ?
13:49:43 <scshunt> parsecChar: why not just implement a GHC backend?
13:49:58 <parsecChar> scshunt: no idea; can you point me to documentation?
13:50:00 <dmwit> parsecChar: -ddump-simpl
13:50:03 <parsecChar> I don't know what a ghc backend is
13:50:25 <scshunt> parsecChar: the backend is the part which takes the intermediate representation and turns it into whatever the end result is
13:50:52 <scshunt> (usually machine code, but in, say, the LLVM backend, that result is LLVM bitcode/IR which is further transformed into an end result)
13:51:00 <puregreen> what exactly does <.> do in lens?
13:51:02 <parsecChar> https://gist.github.com/anonymous/2d7ca92decc3170e724d
13:51:05 <parsecChar> am I misusing stack ?
13:51:23 <parsecChar> stack ghc -- ...
13:51:27 <verement> dolio: it's just a mnemonic
13:52:29 <shachaf> puregreen: Composes with both indices.
13:52:37 <dmwit> parsecChar: In IRC you included the `--`, but in the pasted command line, you did not.
13:52:58 <parsecChar> dmwit: yeah, I figure that out after I gisted it
13:52:59 <parsecChar> stack ghc -- -ddump-simpl X/Client/Main.hs -O
13:53:03 <parsecChar> where is the output going to?
13:53:14 <parsecChar> I checked X/Client/Main.hi and X/client/Main.o and they're both object files
13:53:17 <puregreen> shachaf: I've read the docs but I guess I'm too sleepy now and so I don't understand the example there – have you got a simpler example? (or should I just go to sleep...)
13:53:23 <parsecChar> https://downloads.haskell.org/~ghc/0.29/docs/users_guide/user_24.html also doens't specify an output file
13:53:35 <dmwit> parsecChar: ghc puts its dump output to I think either stdout or stderr. No idea where stack forwards it after that.
13:53:40 <shachaf> puregreen: Well, do you know how indexing works in general? And (.>) and (<.)?
13:54:27 <dmwit> parsecChar: stdout, it seems
13:54:39 <Cale> verement: Note that it would still have very low precedence. As it is, if you have only one $, it effectively wraps both what comes before it and what comes after in parens (sort of)
13:54:51 <parsecChar> dmwit: not with 'stack ghc --' need to figure out how to redirect this
13:54:54 <Cale> verement: The altered $ would do the same :)
13:54:57 <parsecChar> (I don't even have a base ghc installed)
13:55:07 <Cale> It only affects how it would work when there's more than one $
13:56:15 <shachaf> > let (==>) = (,); m = M.fromList ['a' ==> M.fromList [1 ==> "one", 2 ==> "two"], 'b' ==> M.fromList [3 ==> "three", 4 ==> "four"]] in itoListOf (traversed .> traversed) m
13:56:16 <lambdabot>  [(0,"one"),(1,"two"),(0,"three"),(1,"four")]
13:56:18 <shachaf> > let (==>) = (,); m = M.fromList ['a' ==> M.fromList [1 ==> "one", 2 ==> "two"], 'b' ==> M.fromList [3 ==> "three", 4 ==> "four"]] in itoListOf (traversed <. traversed) m
13:56:19 <lambdabot>  [(0,"one"),(0,"two"),(1,"three"),(1,"four")]
13:56:21 <shachaf> > let (==>) = (,); m = M.fromList ['a' ==> M.fromList [1 ==> "one", 2 ==> "two"], 'b' ==> M.fromList [3 ==> "three", 4 ==> "four"]] in itoListOf (traversed <.> traversed) m
13:56:23 <lambdabot>  [((0,0),"one"),((0,1),"two"),((1,0),"three"),((1,1),"four")]
13:56:36 <shachaf> Hmm, that's not quite what I intended.
13:57:00 <Cale> In reflex-dom, we define =: to be Map.singleton, and it's great. Kind of wish it was in Data.Map itself so I could always use it.
13:57:24 <Cale> You can <> to combine maps
13:57:40 <shachaf> puregreen: Should've used itraversed.
13:57:41 <Cale> @let (=:) = M.singleton
13:57:42 <lambdabot>  Defined.
13:58:23 <shachaf> > let (==>) = (,); m = M.fromList ['a' ==> M.fromList [1 ==> "one", 2 ==> "two"], 'b' ==> M.fromList [3 ==> "three", 4 ==> "four"]] in itoListOf (itraversed .> itraversed) m
13:58:24 <lambdabot>  [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
13:58:26 <shachaf> > let (==>) = (,); m = M.fromList ['a' ==> M.fromList [1 ==> "one", 2 ==> "two"], 'b' ==> M.fromList [3 ==> "three", 4 ==> "four"]] in itoListOf (itraversed <. itraversed) m
13:58:28 <lambdabot>  [('a',"one"),('a',"two"),('b',"three"),('b',"four")]
13:58:30 <shachaf> > let (==>) = (,); m = M.fromList ['a' ==> M.fromList [1 ==> "one", 2 ==> "two"], 'b' ==> M.fromList [3 ==> "three", 4 ==> "four"]] in itoListOf (itraversed <.> itraversed) m
13:58:32 <lambdabot>  [(('a',1),"one"),(('a',2),"two"),(('b',3),"three"),(('b',4),"four")]
13:58:32 <parsecChar> is there more docs than https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/code-generators.html for writing a new ghc backend?
13:58:35 <shachaf> puregreen: Like that.
13:58:58 <Cale> > 'a' =: (1 =: "one" <> 2 =: "two") <> 'b' =: (3 =: "three" <> 4 =: "four")
13:59:00 <lambdabot>  fromList [('a',fromList [(1,"one"),(2,"two")]),('b',fromList [(3,"three"),(4...
13:59:06 <Cale> such notation
13:59:35 * puregreen copies the examples into a text file to figure them out, and also notices a Indexable (i, j) constraint ne didn't notice before (so that's where (,) comes from, right)
13:59:55 <dmwit> right
14:00:01 <Zekka|Sigfig> Wow! I love punctuation marks!
14:00:07 <dmwit> ?yow!
14:00:07 <lambdabot> I joined scientology at a garage sale!!
14:00:12 <Cale> haha
14:00:19 <Cale> @yow
14:00:19 <lambdabot> I'm ZIPPY the PINHEAD and I'm totally committed to the festive mode.
14:00:21 <dmwit> ?wow!
14:00:21 <lambdabot> ... I want a COLOR T.V. and a VIBRATING BED!!!
14:00:30 <Cale> @how
14:00:31 <lambdabot> Maybe you meant: yow show
14:00:39 <Cale> aww, edit distance pls
14:00:51 <Cale> @pow
14:00:51 <lambdabot> Should I start with the time I SWITCHED personalities with a BEATNIK
14:00:51 <lambdabot> hair stylist or my failure to refer five TEENAGERS to a good OCULIST?
14:02:21 <Darwin226> What would be the best way to turn a function that takes a Ptr into one that instead returns a list (the Ptr is used for returning)?
14:02:34 <mauke> > mk ['a' ~> mk [1 ~> "one", 2 ~> "two"], 'b' ~> mk [3 ~> "three", 4 ~> "four"]]
14:02:36 <lambdabot>  fromList [('a',fromList [(1,"one"),(2,"two")]),('b',fromList [(3,"three"),(4...
14:02:46 <Darwin226> Do I need to manually allocate memory, convert to list and then free it?
14:03:08 <mauke> Darwin226: convert what to list? and how?
14:03:19 <verement> Darwin226: peekArray?
14:03:57 <Darwin226> mauke: The data written to memory
14:04:05 <Darwin226> verement: I don't know. You tell me :D
14:04:21 <mauke> Darwin226: explain how this api actually works
14:04:41 <xa0> :/
14:04:46 <Darwin226> mauke: Like any other C api. It returns stuff via a pointer argument
14:04:56 <mauke> Darwin226: ok, do it yourself then
14:05:00 <verement> Darwin226: probably a combination of allocaArray and peekArray
14:05:37 <Darwin226> verement: Ok. I was just wondering if there's perhaps some built in mechanism for this. Seems like a relatively common thing
14:06:23 <Darwin226> mauke: Concretely, OpenGL. The genBuffers function for example
14:06:35 <Darwin226> mauke: https://www.opengl.org/sdk/docs/man/html/glGenBuffers.xhtml
14:08:56 <EvanR> Darwin226: yes, use allocaArray
14:09:22 <mauke> foo n = allocaArray n (\p -> glGenBuffers (fromIntegral n) p >> peekArray n p)
14:09:35 <mauke> this doesn't seem easily generalizeable
14:10:16 <EvanR> Darwin226: the bracketing pattern of stuff like allocArray takes care of the freeing for you
14:11:12 <Darwin226> EvanR: I see. Thanks
14:11:22 <EvanR> check out the FFI docs
14:12:02 <Darwin226> mauke: I guess you could do that for any function that takes a Ptr as a parameter. Though there would probably be typing issues
14:12:16 <EvanR> not every function returns an array 
14:12:28 <EvanR> you might need to use alloca to get a single value back
14:12:57 <EvanR> or do it slightly different to pass arguments into the function and expect nothing back, or some combination
14:13:11 <EvanR> as low level as all this is, its pretty straight forward
14:13:23 <EvanR> and there are supposedly frameworks to generate all the bindings for you
14:13:32 <EvanR> but
14:20:43 <dmj`> I wish relational-record used libpq and not HDBC
14:25:42 <xa0> guys
14:26:02 <xa0> i am to understand that monad transformers form a monad
14:26:09 <xa0> how exactly?
14:30:41 <kadoban> xa0: Very carefully? Not sure I understand the question.
14:30:45 <scshunt> xa0: a monad transformer is basically a monad that, when run, its end product is itself monadic
14:31:12 <scshunt> most non-IO monads have a runFoo function which "executes" the monad
14:31:14 <mniip> a monad transformer is a type T :: (* -> *) -> * -> *  such that Monad m => Monad (T m)
14:31:38 <Rembane> scshunt: So a monad transformer is for monads what a functor is for functions?
14:31:38 <scshunt> in a transformer, the type FooT is parameterized on the inner monad, so then the runFoo function produces a value in m
14:31:56 <xa0> okay, i sort of get the intuition for it
14:32:10 <scshunt> Rembane: No?
14:32:12 <xa0> what would return and bind be implemented as?
14:32:22 <scshunt> xa0: Depends on the transformer
14:32:31 <enthropy> using hpc, is there an easy way to make arguments that never should get evaluated (like Proxy) not count against coverage?
14:32:34 <Rembane> scshunt: Ach. 
14:32:37 <xa0> ah.
14:32:48 <Rembane> scshunt: Then I've misunderstood things again. :)
14:32:57 <scshunt> xa0: but the laws around lift give you some guarantees
14:33:06 <kadoban> xa0: You'd probably want to look at a specific one at a time and try to understand. NICTA works you through some of this.
14:33:15 <xa0> say i had the maybeT transformer monad?
14:33:25 <xa0> kadoban: nicta?
14:33:39 * enthropy found something in https://wiki.haskell.org/Haskell_program_coverage#Example
14:33:42 <scshunt> xa0: https://hackage.haskell.org/package/transformers-0.4.2.0/docs/src/Control-Monad-Trans-Maybe.html#State
14:33:49 <mniip> xa0, it's a monad transformer, not transformer monad
14:34:03 <scshunt> you see that return = lift . return
14:34:21 <scshunt> this is required by the monad transformer laws
14:34:28 <kadoban> xa0: https://github.com/NICTA/course
14:34:49 <kadoban> It has to reimplement stuff like StateT, I can't remember if there's other transfromers in there.
14:34:51 <xa0> oh, no i understand how monad transformers work, but i was told that "monad transformers form a monad"
14:34:51 <scshunt> the transformer laws also require that lift (m >>= f) = lift m >>= (lift . f)
14:34:54 <kadoban> It has you*
14:35:13 <scshunt> xa0: Each monad transformer, when appropriately instantiated, forms a monad
14:35:37 <mniip> oh I think I see what you mean
14:35:42 <scshunt> "all monad transformers" being a monad doesn't really make sense
14:35:45 <scshunt> wrong category
14:35:50 <mniip> like a categorical monad
14:35:59 <mniip> in the category of transformers
14:36:04 <Cale> uhhh
14:36:07 <xa0> yeah that's more what i meant
14:36:12 <mniip> I'm not sure
14:36:17 <Cale> Yeah, no, what's the functor?
14:36:26 <scshunt> You'd need some adjunction somewhere
14:36:32 <xa0> that's what i've been trying to work out
14:36:35 <Cale> I don't believe there's a functor which creates all monads
14:37:03 <tosun> I'm trying to use alex+happy with stack but the first time I run `stack build` I get "Could not resolve file .../templates/wrappers.hs"
14:37:04 <Cale> (an endofunctor on... presumably the category of endofunctors)
14:37:11 <Cale> er
14:37:19 <mniip> Cale, it doesn't have to be a Hask -> ... functor
14:37:20 <tosun> Can anyone help with this?
14:37:26 <Cale> mniip: sure...
14:37:45 <mniip> but hmm
14:38:20 <Cale> So, wait, for monad transformers to be a monad, are the transformers themselves supposed to be images of this endofunctor on something?
14:38:50 <xa0> i honestly have no idea, i'm trying to make sense of the statement...
14:38:58 <mniip> can you include more context?
14:39:03 <Cale> Who said it?
14:39:05 <mniip> ^
14:39:16 <scshunt> What exactly does it say?
14:39:19 <xa0> https://www.reddit.com/r/programming/comments/cdaha/why_functional_programming_matters_john_hughes/c0rspo6
14:39:41 <mniip> well there's a link to an artcile
14:39:44 <mniip> which explains everything
14:40:18 <xa0> ha, i entirely missed that.
14:40:23 <xa0> my bad
14:40:56 <ralu> isnt supose for monad transformers to obey laws over monads. So as long underlaying functor is monad it works
14:41:23 <Cale> This doesn't talk about monad transformers though.
14:41:40 <johnw> I think we're asking if "StateT s" is a monad itself in some category
14:42:08 <Cale> Oh, that question makes more sense
14:42:23 <parsecChar> is there a way for me to access this layer: http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html#(8) ... and build my own compiler from there?
14:42:42 <scshunt> I think it's being misinterpreted
14:42:48 <Cale> I think so too
14:42:51 <mniip> parsecChar, GHC plugins
14:43:14 <parsecChar> mniip: can you point me to a tutorial ?
14:43:15 <Cale> This blog post is not really talking about monad transformers, which are a very special case of monad homomorphisms
14:43:19 <mniip> I don't think
14:43:19 <scshunt> this result has nothing to do with monad transformers
14:43:22 <mniip> so
14:43:32 <scshunt> it's talking about stuff like State (IO a)
14:43:45 <Cale> uh, it's not doing that either
14:43:51 <scshunt> Cale: is it not?
14:44:01 <scshunt> it's talking about composition of monads like State . IO no?
14:44:35 <Cale> To understand this blog post, you have to know about a generalisation of the definition of monad
14:44:55 <Cale> from being an endofunctor on a category equipped with some natural transformations
14:45:09 <Cale> to a 1-cell in a 2-category equipped with some 2-cells
14:45:13 <scshunt> oh
14:47:02 <Cale> You also need an appropriate notion of what a monad homomorphism is, so that you can make them into first a category, but not only that, the monads in a 2-category themselves form a 2-category, so you can ask about monads *in* that 2-category (rather than ordinary monads which are monads in Cat)
14:47:29 <Lokathor> If folks want to scour a module and try to make it faster, I'm open to ideas: https://github.com/Lokathor/ludolib/blob/master/src/Util/PPFOV.hs
14:47:32 <scshunt> ahh ok
14:47:59 <Lokathor> applied some ST stuff, next plan is to perhaps move to unboxed values for all the intermediate variables (of which there are many)
14:48:01 <scshunt> ohhhhh
14:48:02 <scshunt> I see now
14:48:03 <scshunt> ok
14:48:07 <scshunt> right
14:48:27 <parsecChar> ARGH, why does stack ghc -- suppress all output, including dump-stg ?
14:48:44 <Cale> scshunt: Yeah, it's way higher level than what we're used to expressing in Haskell :)
14:48:51 <Lokathor> parsecChar, the dump outputs should be burried within the .stack-work/ directory
14:49:28 <Lokathor> eg, soemthing like .stack-work\dist\2672c1f3\build\src\Util
14:49:45 <parsecChar> n=hmm, I was checking log
14:49:48 <parsecChar> but I guess dis tmakes more sense
14:50:02 <Cale> Wait, this blog post is self-inconsistent, and now I'm confused about what it's saying
14:50:27 <Lokathor> careful though, if you open ghci with dumping on then ghci will also dump everything, but it'll dump into your main src tree
14:51:36 <Cale> It starts out defining Mnd(C) as the 2-category of monads *in* the 2-category C, which is fair enough, but then it refers to an object of Mnd(Mnd(C)) as a monad in the 2-category of monads *on* C, which is a different thing
14:51:54 <Cale> "in" vs. "on" is very different
14:52:35 <Lokathor> english subtlety creeping into math :/
14:52:59 <Cale> It's not really English subtlety, they're both technical definitions
14:53:14 * hackagebot gore-and-ash 1.2.0.0 - Core of FRP game engine called Gore&Ash  https://hackage.haskell.org/package/gore-and-ash-1.2.0.0 (NCrashed)
14:53:23 <Lokathor> are there any tools that improve the readability of Core beyond what TidyCore puts out?
14:53:49 <Cale> A monad on a category (or 2-category) C is the sort of thing we usually think of as a monad. It consists of an endofunctor T: C -> C, and natural transformations eta: 1 -> T and mu: T^2 -> T
14:53:59 <parsecChar> I have a project on stack 5.4; how do I get it to update to stak 5.6 ?
14:54:00 <Cale> (satisfying certain laws)
14:54:20 <Lokathor> parsecChar, change the stack.yaml file to say 5.6 and rebuild
14:54:33 <Lokathor> "resolver: lts-5.0" the line like that
14:54:37 <Lokathor> but 5.6 obviously
14:55:36 <Cale> A monad *in* a 2-category C consists of a choice of 0-cell X in C (i.e. an object), and a 1-cell in C (i.e. an arrow between objects of C) T : X -> X, and then 2-cells eta: 1 -> T and mu: T^2 -> T satisfying corresponding laws.
14:55:59 <Cale> i.e. A monad on some category X is a monad *in* Cat
14:56:02 <parsecChar> Lokathor: too easy
14:56:16 <Lokathor> i hope everyone goes out to IHOP today
14:56:19 <Lokathor> free pancakes, etc
14:59:58 <Lokathor> hmm
15:00:06 <Lokathor> some things have been unboxed
15:00:10 <Lokathor> but other things haven't been unboxed
15:00:12 <Lokathor> how finnicky
15:00:28 <Cale> But yeah, it's probably just a typo
15:04:06 <Cale> https://golem.ph.utexas.edu/category/2014/01/formal_theory_of_monads_follow.html gives a more complete story regarding that paper of Street's... which is here: https://sci-hub.io/http://www.sciencedirect.com/science/article/pii/0022404972900199
15:05:25 <Cale> (btw, sci-hub.io is pretty great)
15:07:14 <m1dnight_> Is there a good tutorial online for installing a new ghc on ubuntu? Ive pooped my system a few times too many :?
15:07:28 <m1dnight_> I have installed it now using a special ppa but its not the default ghc still
15:07:51 <puregreen> jle`: this isn't ready yet (at all!), but I sort of want to brag anyway: http://guide.aelve.com, click on “show notes/examples” in the entry for lens
15:08:36 <kadoban> m1dnight_: You can just use 'stack' to do it for you, it's much easier that way.
15:08:51 <m1dnight_> Okay ill give it a shot. Never used it before.
15:08:53 <sm> puregreen: looks interesting
15:09:04 <m1dnight_> And am I correct in assuming that I should ghc-mod using Cabal instead of via apt?
15:09:08 <m1dnight_> Its to get emacs working.
15:09:49 <Lokathor> m1dnight_, yes install ghc-mod via cabal or stack rahter than your package manager
15:10:22 <Lokathor> ghc-mod has to be used with the version of ghc and libs that built it
15:10:50 <m1dnight_> okay, time to clean everything once more
15:12:08 <jle`> puregreen: nice!
15:12:55 <parsecChar> does "stack install haste-compiler" work for anyone? After I add the corresponding lines of my *.yaml, it still doesn't build
15:13:57 <puregreen> jle`, sm: I intend to spend about a week documenting various libraries and adding features before it goes into beta, but I'm not going to wipe the database at any point so everyone is welcome to start contributing
15:15:53 <m1dnight_> can I use stack to install ghc globally? From what I can tell it;s like virtualenv for python.
15:16:22 <m1dnight_> But I want to use the newest ghc and ghc-mod globally to make sure it works well with  my emacs. If I'm not mistaken I'd have to start emacs from the path of each project this way?
15:16:52 <blume> elisp... so fun
15:16:58 <blume> emacs too ^^
15:17:19 <blume> its your editor, rather learn to use it :P
15:18:51 <m1dnight_> This has nothing to do with Emacs. I have projects that Ive built with ghc 7.10 and installing that on ubuntu doesn't seem to get me the proper ghc-mod version etc. So Im failing harder at installing ghc than at emac
15:19:24 <Lokathor> tell emacs to run ghc by doing "stack ghc" instead of "ghc"
15:20:43 <m1dnight_> Aja.
15:21:06 <m1dnight_> Aha, global project config, exactly what I needed :) Ill work out, so it seems. Thanks for the tip guys
15:23:56 <parsecChar> There was an error reading the package tarball /home/foo/.stack/indices/Hackage/packages/ghc-core/0.5.6/ghc-core-0.5.6.tar.gz: File in tar archive is not in the expected directory "ghc-core-0.5.6"
15:24:01 <parsecChar> (from "stack install ghc-core")
15:24:04 <parsecChar> what is going on?
15:28:15 * hackagebot fltkhs 0.4.0.7 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.7 (deech)
15:38:45 <parsecChar> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/Outputable.html#t:SDoc how do I print an SDOc ?
15:38:54 <maerwald> http://lpaste.net/154278 is there any way to tell ghc that pattern matching is not exhaustive here?
15:39:00 <maerwald> or did I miss something
15:40:31 <jle`> do you mean exhaustive?
15:40:37 <maerwald> not non-exhaustive
15:41:16 <SPPGuest5771> hi everyone
15:41:20 <mniip> hello
15:41:59 <SPPGuest5771> can anyone with experience tell me if it's feasible to get a job in programming without a degree
15:42:27 <EvanR> i have seen it before
15:42:34 <Enigmagic> the rumors are true
15:42:37 <Zekka|Sigfig> SPPGuest5771: I currently have a job in programming without a degree
15:42:40 <simpson> SPPGuest5771: Hi! I am a professional programmer and a dropout. I studied music before I left school.
15:42:47 <Zekka|Sigfig> I also have an offer from Microsoft without a degree
15:42:56 <Zekka|Sigfig> I’m currently a uni student though so maybe that doesn’t count
15:42:58 <SPPGuest5771> so do you guys have any advice?
15:43:02 <EvanR> i read that as "I studied magic"
15:43:17 <simpson> SPPGuest5771: Find something that you do not enjoy doing. Don't do that.
15:43:20 <mniip> :(
15:43:24 <SPPGuest5771> I'm trying to do treehouse to become a full stack dev 
15:43:48 <johnw> SPPGuest5771: I never received a degree either
15:43:50 <EvanR> dont become a full stack dev
15:44:00 <Zekka|Sigfig> SPPGuest5771: How good are you at data structures questions and stuff? A lot of interviewers will throw that at you and if you can answer them smartly I think it will make you look good, no matter what you’re interviewing for
15:44:05 <Zekka|Sigfig> every interviewer I’ve been at has had some of those questions
15:44:13 <EvanR> become whatever they call full stack devs after the full stack dev market is saturated with people who know that phrase
15:44:26 <Cale> heh
15:44:36 <SPPGuest5771> how do you mean by data structure questions?
15:44:55 <Cale> I guess I'm technically a full stack dev now? My "full stack" consists entirely of Haskell though.
15:45:05 <EvanR> yes Cale, yes you are
15:45:20 <EvanR> welcome to club everyone
15:45:29 <SPPGuest5771> I'm more into ruby/python, but I have experience in pretty much every popular language 
15:45:31 <Zekka|Sigfig> SPPGuest5771: I can’t remember exactly what I was asked, but how about “reverse the sort order of a binary search tree”? That’s kind of an intro-y one, but you are likely to be asked one
15:46:08 <Zekka|Sigfig> Another one I know I was asked, in a similar vein, was “remove the second-to-last element of a binary search tree in log time”
15:46:12 <Cale> SPPGuest5771: My degree is in pure mathematics rather than CS if that counts.
15:46:25 <Cale> SPPGuest5771: and my employers' degrees are both in law
15:46:53 <Cale> Oh, actually I think maybe Ryan has a CS degree too?
15:46:55 <Cale> I forget
15:46:57 <SPPGuest5771> How about with no degree at all rather than an unrelated one
15:47:11 <Zekka|Sigfig> These problems don’t have that much practical connection to actual programming, but you would probably get exposed to this stuff on hard actual programming problems
15:47:14 <Cale> I mean, all that really matters is whether you can get things done effectively
15:47:31 <Cale> I don't think most people care how you learned what you learned, if you can demonstrate ability
15:47:36 <maerwald> Cale: that really depends on the country too
15:47:43 <Zekka|Sigfig> SPPGuest5771: Do you have any good projects? I like playing up data structures, so a programming language implementation or an allocator or a file system would impress me
15:47:53 <Zekka|Sigfig> projects of mine along those lines have always impressed interviewers
15:47:57 <EvanR> having a degree definitely adds some bias
15:48:02 <EvanR> as long as its not a PHD
15:48:05 <Cale> heh
15:48:35 <Zekka|Sigfig> You might write some obfuscated assembly language programs or something, or do something else non-passionate hobbyists are overwhelmingly unlikely to have done
15:49:05 <SPPGuest5771> Not really that far into it atm 
15:49:06 <EvanR> show them your custom CMS
15:49:14 <Zekka|Sigfig> I’m only talking about technical skills, but you should probably be sure your social skills are pretty good too
15:49:29 <zebr> hi all, if i have a type of kind (* -> *) -> *, and a type of kind *, can i not say type Const a b = b and then pass, e.g., Const Int[D[D?
15:49:42 <Zekka|Sigfig> I can’t give great advice on how to brush up on that other than to talk to other people a lot, be honest about the boundaries of your knowledge, and try to be analytical when people say something you don’t know how to respond to
15:49:51 <Cale> zebr: your message got a bit mangled there toward the end...
15:49:51 <zebr> oops, ignore the [D[D there. irc client...
15:49:53 <shachaf> zebr: You can't in most cases.
15:49:54 <Cale> ah
15:50:10 <shanemikel> is there a quick way to replace Data.HashTable from base 4.6
15:50:17 <zebr> shachaf: hrm. that's unfortunate.
15:50:30 <Cale> shachaf: Wait, you understand the question?
15:50:38 <SPPGuest5771> Zekka do you have any resources for projects to improve my portfolio
15:50:53 <Zekka|Sigfig> SPPGuest5771: I don’t have a site you can just go through, but it’s not too hard to come up with stuff
15:51:03 <EvanR> SPPGuest5771: follow your heart
15:51:07 <Zekka|Sigfig> What programming languages do you like? Do a ground up implementation of something like one of those.
15:51:35 <Zekka|Sigfig> you can stick to small stuff like implementing type inference or whatever
15:51:42 <SPPGuest5771> C 
15:51:43 <shanemikel> nfm
15:51:47 <Zekka|Sigfig> (my current offer I got by nitpicking the interviewer’s typechecker)
15:51:48 <shanemikel> err nvm
15:51:50 <SPPGuest5771> or C++
15:51:56 <shachaf> Cale: I think so? I think the question is: If you have newtype Foo f = ..., and type Const a b = b, can you say "Foo (Const Int)"?
15:52:11 <shachaf> The answer to my version of the question is no.
15:52:20 <zebr> that pretty much covers it, yeah
15:52:22 <Zekka|Sigfig> SPPGuest5771: There are parts of C that aren’t that hard to implement — I wouldn’t implement the whole language, but you could probably do easy parts of the type system plus code generation plus part of the parser without that much trouble
15:52:47 <SPPGuest5771> btw, how would I display this in such a way Zekka 
15:52:50 <Zekka|Sigfig> Have you tried implementing malloc and free? That will give you some interesting data structures problems
15:53:08 <Zekka|Sigfig> SPPGuest5771: Most interviewers will ask you to talk about a project you did and explain the choices you made along that project
15:53:32 <shachaf> zebr: There's a special case extension in GHC: If you have type Foo f = ..., and type Const a b = b, you can say "Foo (Const Int)" if the whole thing expands to a type with Const fully applied.
15:53:34 <Zekka|Sigfig> you probably want to talk about those choices in a way that makes it sound like you learned a lot about the topic
15:54:14 <shachaf> But in general you would need a newtype.
15:54:25 <SPPGuest5771> well, is it more lucrative to pursue startups in APIs or what
15:54:47 <Zekka|Sigfig> SOmetimes you’ll get lucky and you’ll happen to know a lot about something your interviewer is interested in — one guy asked me how to implement a garbage collector and I told him a strategy he didn’t know much about; another guy happened to be working on a programming language and I nitpicked his typechecker
15:55:11 <Zekka|Sigfig> SPPGuest5771: “APIs” sounds pretty narrow to me — I suspect the highest paying jobs are in consultancy for specific products, stuff like SalesForce, but I’ve never worked in that field
15:55:23 <Zekka|Sigfig> sounds pretty broad*
15:55:24 <SPPGuest5771> My brother's a consultant in SAP
15:55:25 <zebr> shachaf: yeah, i think in my case i do. no matter, i'll try to shuffle the kinds around a bit so i don't end up needing to
15:55:30 <EvanR> SPPGuest5771: its possible to pick projects that coincide with marketable trending technologies, and i would be annoyed by this as an interviewer probably
15:55:32 <SPPGuest5771> SAp hana
15:55:42 <EvanR> if you pick something not boring as hell, that would be awesome
15:56:01 <Zekka|Sigfig> I would guess that guys who can solve complicated mathy stuff (stuff like what I brought up) will get paid more on average in the long run, but that’s partially my sense of justice
15:56:21 <Zekka|Sigfig> Guys who are really good at software configuration and deployment will probably make lots of cash too, but I think that’s a calling
15:56:36 <mniip> 1457480733 [02:45:33] <Zekka|Sigfig> SPPGuest5771: Do you have any good projects? I like playing up data structures, so a programming language implementation or an allocator or a file system would impress me
15:56:40 <mniip> an allocator in haskell
15:56:45 <EvanR> heh
15:56:48 <josephle> haha
15:56:58 <EvanR> the allocator comonad
15:57:15 <EvanR> as long as it doesnt have to deallocate
15:57:25 <Zekka|Sigfig> If someone wrote a super legit, C-friendly allocator in Haskell I would probably be morbidly impressed
15:57:44 <mniip> to be fair I guess I could actually write that
15:57:58 <EvanR> it would be a nice test of type system fu
15:58:03 <mniip> unsafePerformIO newIORef would store the allocator state
15:59:36 <Zekka|Sigfig> SPPGuest5771: My sense of justice says “if you pick a job because it will make you lots of cash, you’re likely to end up unhappy” but I have a feeling that’s realistically not true
16:00:25 <EvanR> you will feel happy after you quit that job after making a lot of cash
16:00:29 <Zekka|Sigfig> there are probably quite a few easy, high-paying jobs out there thanks to price gouging and management incompetence, but I would not rely on myself being able to find one
16:00:48 <SPPGuest5771> where do you work currently Zekka
16:01:13 <Zekka|Sigfig> SPPGuest5771: SigFig, a personal finance startup. I verify that the data we’re getting from brokerages is accurate and try to come up with rules to fix exceptional cases
16:01:36 <SPPGuest5771> ah, I see
16:02:42 <SPPGuest5771> sigfig is investment planning?
16:02:57 <Zekka|Sigfig> Yeah, you give us some constraints and we generate a portfolio based on them
16:03:11 <Moggle> Incredibly dumb question... I'm trying to figure out how to do a multi-line Control.Exception.finally with `finally` in the middle, but ghc hates indentation. What are the rules for doing two do blocks spanning multiple lines and putting a `finally` between them?
16:03:43 <SPPGuest5771> how well does it work Zekka
16:04:08 <Zekka|Sigfig> SPPGuest5771: We usually don’t lose people more money than they say they’re comfortable losing, but we don’t do better than statistics would predict
16:04:26 <SPPGuest5771> haha
16:05:05 <Zekka|Sigfig> We’re not one of those systems that tries to take risks or work with information everyone else doesn’t have
16:05:32 <SPPGuest5771> that's what they all say xD
16:05:55 <Zekka|Sigfig> Well, there are some systems that make lots of rapid-fire buy/sell orders to see if they end up ahead. (high-frequency traders)
16:06:14 <SPPGuest5771> I have a few js projects, but I don't really know the job market well enough
16:06:20 <Zekka|Sigfig> Those systems can come up pretty high above average, but we don’t do that
16:07:11 <Zekka|Sigfig> They can also lose lots of money very fast. The idea is that for any amount of gain, you usually have an associated amount of risk — if there’s less risk, someone else is probably already capitalizing on the difference between the amount of gain and amount of risk. And in stocks, those guys are the high-frequency traders
16:07:44 <SPPGuest5771> I have a few low-risk,high-yield investments myself
16:08:17 * hackagebot gore-and-ash 1.2.1.0 - Core of FRP game engine called Gore&Ash  https://hackage.haskell.org/package/gore-and-ash-1.2.1.0 (NCrashed)
16:08:26 <Zekka|Sigfig> SPPGuest5771: FWIW, at an interview I have never been seriously asked about skills highly specific to the job, like “can you write Javascript” or “have you written a forms system in PHP” — it’s usually more “are you smart enough to figure out what the job is about?” I suspect this changes for more senior positions, though
16:09:23 <Zekka|Sigfig> er, figure out how to do what this job is about, not figure out what the job is
16:09:48 <Zekka|Sigfig> if your projects reflect well on your ability to learn stuff or deal with limited information I bet they will make you look good
16:10:24 <Zekka|Sigfig> That’s kind of why a lot of interviewers lead with data structures questions — they’re seen as kind of universal even though imho they’re actually pretty specific
16:11:13 <SPPGuest5771> I wouldn't really know how to answer those questions
16:11:28 <SPPGuest5771> or how to articulate them
16:11:49 <Zekka|Sigfig> Well, what were the hard parts of the last projects you worked on?
16:12:05 <Zekka|Sigfig> Maybe we should move to #haskell-blah
16:13:29 <SPPGuest5771> debugging lol
16:13:38 <SPPGuest5771> it took longer than the initial writing
16:14:43 <Zekka|Sigfig> SPPGuest5771: What kind of bugs were you dealing with?
16:16:03 <SPPGuest5771>  Inefficient DOM manip
16:16:14 <Zekka|Sigfig> Was it just slow, or actually broken?
16:16:26 <APic> ,o0(Subdomain)
16:16:36 <SPPGuest5771> broken
16:17:24 <SPPGuest5771> a lot of logic bugs
16:18:01 <SPPGuest5771> it's the worst thing when not even an error console finds it
16:18:26 <Zekka|Sigfig> So at this point as an interviewer I’m probably trying to figure out what your process is like to diagnose this stuff
16:18:53 <Zekka|Sigfig> I don’t really have enough specific details about what was wrong with your project(s) though to do that, so I’d probably hint you in the direction of talking about your favorite one (either the one you’re proudest of or the one you found hardest to write)
16:20:38 <Zekka|Sigfig> I might be back later, but I think I have to disappear for a while atm
16:20:50 <APic> Ok.
16:21:23 <Zekka|Sigfig> SPPGuest5771: project advice: do really intensely low-level stuff like compilers/allocators/etc, or maybe do data structures intensive stuff — stuff that a pure hobbyist would not be too familiar with
16:21:40 <Zekka|Sigfig> That sort of thing will probably distinguish you a lot in the “how do you think about programming” section
16:22:22 <SPPGuest5771> have you used Bizubee?
16:22:28 <Zekka|Sigfig> I’ve never heard of it
16:23:00 <SPPGuest5771> it's ridiculous lol, I contributed to some of the source code
16:23:33 <Zekka|Sigfig> What’s it do/what part did you work on?
16:23:36 <SPPGuest5771> Bizubee aims to preserve JavaScript semantics while simultaneously simplifying and extending JS. Bizubee syntax is largely inspired by CoffeeScript and Dart, though the semantics differ significanty from both. Unlike most compile-to-js languages, the Bizubee compiler targets modern JavaScript (currently ES2015), since transpilers like Traceur can further transpile for support in legacy browsers.
16:23:57 <Zekka|Sigfig> Got it, so it’s an altjs?
16:24:50 <SPPGuest5771> Yeah, really sub-optimal at this point
16:25:08 <Zekka|Sigfig> What sort of stuff were you working on?
16:25:58 <SPPGuest5771> oh everything lol loops were the absolute worst though
16:26:12 <SPPGuest5771> if you go on the github you could see why haha
16:26:32 <Zekka|Sigfig> So, like, parsing, code generation, both, or what sort of stuff?
16:26:42 <SPPGuest5771> parsing mostly
16:27:03 <Zekka|Sigfig> Oh yeah, I can see that being a problem. Did you use a parser generator or did you write it from scratch, or what?
16:27:39 <SPPGuest5771> if only i knew about peg.js
16:29:07 <Zekka|Sigfig> At this point an opportunistic interviewer is thinking “awesome, he thinks parsing is hard and I know a little bit about parsing — time to see if his reasons gel for me!”
16:30:02 <Zekka|Sigfig> I had a situation like this when I was talking about prolog with an interviewer who was into machine learning — we were both into classifying data so she drilled me to see if my views about what’s hard about writing classifiers made sense to her
16:30:55 <Zekka|Sigfig> So as an interviewer I’ll probably try to figure out how your parser works and what parts of it you did
16:31:49 <SPPGuest5771> does it always work like that? >_>
16:32:17 <Zekka|Sigfig> SPPGuest5771: There’s actually a lot of ways to implement parsers. I don’t know how yours was implemented, I haven’t read your code
16:32:36 <SPPGuest5771> no but all the questioning I mean
16:32:55 <Zekka|Sigfig> Most interviewers are eventually going to want to figure out something you did that squares away with something they did, so they can investigate it
16:33:09 <Zekka|Sigfig> it’s hard to interview someone about something they know about and you don’t know about, or something you know about and they don’t know about
16:33:17 <Zekka|Sigfig> and it’s usually not anybody’s fault if one person knows about something and the other person doesn’t
16:33:50 <principia> I joined late but a good parser for an ambiguous grammar is the CKY algorithm
16:34:23 <Zekka|Sigfig> Then they’re going to figure out if your thought process matches what they want to have on their team — so if you say “my parser takes exponential time and that’s totally cool with me” and they’re a speed-is-everything team processing really large amounts of data, they will probably not want you
16:34:44 <Zekka|Sigfig> butif you say “my parser takes exponential time, but the runtime is actually much lower in practice” they might have more respect for you than if you’d just said “my parser takes exponential time"
16:35:08 <principia> No parser should do worse than O(n^3) 
16:35:11 <Zekka|Sigfig> they would probably ask you why you’re so sure the runtime is lower, of course
16:35:30 <Zekka|Sigfig> principia: Yeah, I know, some dude whose name I can’t remember expressed a parser that can handle basically any context-insensitive grammar in O(n^3)
16:35:46 <Zekka|Sigfig> Earley I think? It still can’t handle several cases you can handle with your generic backtracking parser though
16:36:00 <Zekka|Sigfig> But most languages odn’t have that problem.
16:36:47 <principia> Well cky  and early are  n^3 but someone showed it can be done in O(n^2.7?) because he shoed in the linit parsing is equivalent to binary matrix multiplication 
16:37:01 <Zekka|Sigfig> principia: Oh really! That’s super cool.
16:37:57 <principia> right, but its not usedin practice because the overhead is too high 
16:38:00 <Zekka|Sigfig> Of course, most parsers do much better than that, on average, which is what I would say if someone asked me why I did a backtracking parser
16:38:27 <principia> if the grammar is unambigious (like computer code) shift-reduce is better
16:38:48 <Zekka|Sigfig> say my parser never has to backtrack except in one edgecase where it looks ahead about five tokens and tries to parse them to see what it gets — then I’m pretty cool with that performance
16:40:11 <principia> right, thats good. I would look into the LR algorithm for state of the art. Is this for a compiler?
16:40:34 <Zekka|Sigfig> principia: I don’t actually have a parsing problem. I was coaching SPPGuest5771 about interviews and one of his projects was a parser
16:40:38 <Zekka|Sigfig> (which was for a compiler fwiw)
16:41:04 <Zekka|Sigfig> I was trying to help him figure out how interviewers are likely to audit his project by giving him some examples of things he might say and how they would probably be perceived
16:41:30 <Zekka|Sigfig> I actually do have ap arser and it does do backtracking, but it’s just for a personal hack. I wouldn’t show off my parser and say at an interview “this is a great parser, hire me based on it"
16:42:07 <Zekka|Sigfig> I think I will disappear for real now! God bless you!
16:42:46 <principia> Zekka|Sigfig: Oh groovy. I feel you. I've a cky parser myself, but its far from optimized.
16:42:56 <principia> Zekka|Sigfig: you too
16:59:11 <Renard_Chase> I just finished writing a simple Haskell program to test my knowledge, and was wondering if someone would be willing to look at it and see if there are any areas that could be improved (Specifically if anything I did would be considered "improper")
17:02:45 <gigglypuff> Am I retarded for not being able to do exercise 1.11 in SICP? I've since skipped it and had better luck with other exercises, but that one exercise in particular made no sense AT ALL.
17:05:27 <Clint> gigglypuff: what doesn't make sense?
17:05:46 <gigglypuff> Clint: Everything
17:06:30 <Clint> you don't know what a function is?
17:11:45 <geppettodivacin> gigglypuff: Just to clarify, that's the problem with the recursive definition of a function f?
17:13:20 * hackagebot insert-ordered-containers 0.1.0.0 - Associative containers retating insertion order for traversals.  https://hackage.haskell.org/package/insert-ordered-containers-0.1.0.0 (phadej)
17:20:27 <xa0> Renard_Chase: just post it, if someone can they'll take a look
17:20:37 <xa0> don't ask to ask ;)
17:25:06 <gigglypuff> geppettodivacin, Clint: I honestly don't even know how to appraoch this specific problem.
17:26:22 <Clint> gigglypuff: ok
17:28:17 <gigglypuff> Clint: Thanks for the help.
17:33:20 * hackagebot insert-ordered-containers 0.1.0.1 - Associative containers retating insertion order for traversals.  https://hackage.haskell.org/package/insert-ordered-containers-0.1.0.1 (phadej)
17:46:43 <lpaste> GGuy pasted “HtmlT (ScottyM)” at http://lpaste.net/154289
17:48:01 <GGuy> Hi, I'm trying to work out why the Scotty version uses GBs of memory. I assume it has something to do with using Control.Monad.State.Lazy?
17:48:24 <GGuy> it only happens when the HtmlT monad is nested
17:50:29 <shapr> @hoogle sortBy
17:50:30 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
17:50:31 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
17:50:31 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
17:50:33 <shapr> oh right
18:16:32 <daedalus_> Hey, is there any way of writing these typeclass instances without overlapping: http://lpaste.net/141002045455859712 ?
18:16:54 <daedalus_> My brain is kind of stuck.
18:17:22 <daedalus_> I want LEq to only have valid instances if m <= n.
18:18:47 <daedalus_> And I the inductive step should be (LEq m n) => LEq m (Succ n).
18:21:15 <daedalus_> The code I posted works for result Z Z and result Z (S Z), but result (S Z) (S Z) has overlapping instances.
18:22:25 <MichaelBurge> This fragment of Haskell throws an error: renderHtml $ Data.Vector.forM_ (Data.Vector.fromList ["example"]) $ \x -> Text.Blaze.Html5.li $ toMarkup x
18:22:32 <MichaelBurge> I get the error: *** Exception: Text.Blaze.Internal.MarkupM: invalid use of monadic bind
18:22:53 <MichaelBurge> Is what I'm doing meaningful, or is there a bug in blaze-html?
18:26:08 <pavonia> That Html type isn't a real monad, IIRC, it only has a Monad instance for convenient use of do-notation
18:26:11 <luite> MichaelBurge: or blaze is abusing to Monad typeclass to get do notation :)
18:28:24 <MichaelBurge> Is there a theoretical reason Html construction can't be a monad, or did it just end up that way?
18:28:37 * hackagebot yesod-pnotify 1.1.3.2 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.3.2 (KatsutoshiItoh)
18:31:05 <icicled> MichaelBurge: some notes on Blaze (it describes the monad situation with blaze) - http://chrisdone.com/posts/lucid
18:31:26 <geekosaur> it would certainly be possible, but it sounds like in this case they just decided they wanted do
18:31:28 <geekosaur> er
18:31:28 <geekosaur> do
18:31:53 <geekosaur> s desugaring to (>>) and throw an error if (>>=) is used
18:32:02 <icicled> blaze not being a monad - http://chrisdone.com/posts/lucid#the-monad-instance-isnt
18:32:16 <icicled> rather it not implementing it properly
18:36:46 <MichaelBurge> icicled: That's a compelling argument to use lucid. I've run into most of those problems. Thanks for the reference.
18:38:50 <individual> test
18:41:17 <pavonia> Yet another package misusing the Show instance :S
19:01:08 <icicled> I just came across that post this morning - happy to help :)
19:01:27 <zv> anyone else watching the alphago championship tonight?
19:02:46 <Cale> zv: Oh, is that tonight? Where can I watch?
19:04:00 <zv> https://www.youtube.com/watch?v=vFr3K2DORc8
19:04:07 <Cale> thanks!
19:04:14 <zv> 20 minutes
19:04:55 <parsecChar> is the reason we have modules named Ghc, CoreSyn, Name, Module, Literal because there's some bootstrapping process where we don't have nested module names?
19:05:51 <sm> live streaming in youtube.. what next
19:05:58 <Cale> parsecChar: I don't expect that's the case, those modules were probably just written before we had hierarchical module names
19:06:23 <parsecChar> Cale: okay; I was trying to guess why; your theory makes more sense
19:06:26 <sm> zv: thanks. This should be a step up from DOTA 2 :)
19:21:40 <Ralith> are there any qt5 bindings other than hsqml? hsQt seems to be 4-only
20:25:20 <Lokathor> (#!) :: [a] -> Int# -> a
20:25:38 <Lokathor> you might be doing something you shouldn't when you have to rewrite the indexing operator
20:25:48 <Lokathor> and in more than one way too!
20:25:50 <Lokathor> :D
20:44:44 <mniip> Lokathor, Just use MutableArray#
20:45:25 <Lokathor> mniip, but i want it to be resizable
20:45:48 <mniip> list of mutablearrays!
20:45:54 <Lokathor> >_<
20:45:55 <mniip> aka lazy bytestring
20:46:05 <broma0> in template-haskell, how does one generate multi-param typeclasses? i see 'appT :: TypeQ -> TypeQ -> TypeQ', but nothing for types like "MonadBlah m n"
20:46:31 <Lokathor> the list never gets more than 5 or 6 elements anyway, and is usually 3 or less
20:46:53 <mniip> fewer!
20:47:29 <mniip> hm
20:47:51 <mniip> if you have a strict upper bound might create an array that big
20:49:15 <Lokathor> not a strict upper bound, just a usual result sort of deal
20:50:35 <nick99> so THIS is what haskell girls do when they aren't coding? shesh. http://www.cam4premium.com/cam/Lady_Luna/
20:54:29 <mniip> sfw?
20:54:45 <nick99> mniip does the link suggest it is? :P
20:54:50 <nick99> (no it isn't)
20:54:55 <mniip> hence the question
20:55:19 <mniip> also, then, I'd refrain from posting that in here
20:55:29 <nick99> well she isn't doing anything right now except wearing "go ahead poke me" shirt. but that might change in 10 seconds
20:55:32 <mniip> try #haskell-blah instead
21:13:41 <tippeneinn> How can I get optparse-applicative to print help stuff for subparsers?
21:16:24 <Lokathor> my pile of errors is slowly getting smaller rather than larger now!
21:16:28 <tippeneinn> right now it just says COMMAND instead of helps for all the sub-commands
21:32:24 <lpaste> tippenein pasted “bracket - withLocalDatabase” at http://lpaste.net/154306
21:33:15 <dmj`> tippenein: why would you need to avoid do notation
21:34:26 <tippeneinn> that was more aesthetic reasons, but even so I couldn't get it to fit within the acidstate monad (I think that was the problem)
21:34:42 <tippeneinn> package database-migrate
21:34:42 <tippeneinn> package database-study
21:34:42 <tippeneinn> package usb-id-database
21:34:59 <tippeneinn> apologies, wroing paste buffer
21:35:12 <tippeneinn>  bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:37:41 <tippeneinn> oh ziff, that _does_ work. 
21:43:07 <julianleviston> ollef: ping
21:45:22 <julianleviston> Wondering if anyone knows why trying the example in https://github.com/ollef/Earley/blob/master/examples/Expr.hs at GHCi fails with Expecting one more argument to ‘Grammar r (Prod r String String Expr)’ Expected a type, but ‘Grammar r (Prod r String String Expr)’ has kind ‘* -> *’
21:45:52 <julianleviston> The signature of the definition in question is expr :: Grammar r (Prod r String String Expr)
21:46:05 <scshunt> julianleviston: Grammar needs a third parameter
21:46:15 <julianleviston> scshunt: that’s what I thought.
21:46:20 <julianleviston> scshunt: pretty obvious stuff, right?
21:46:28 <julianleviston> scshunt: and yet, it’s the example code.
21:46:32 <scshunt> julianleviston: eh, the error message is not super clear
21:46:39 <echo-area> Is it a convention that primes after function names indicate strictness, and underscores indicate other variants of arguments?
21:47:01 <scshunt> julianleviston: the kind is the "type of type". Kind "* -> *" is the kind of unary functions on types
21:47:15 <julianleviston> echo-area: underscores are matchers that don’t use that value. primes *are* eager, AFAIK
21:47:18 <scshunt> it's a GHC-specific thing for the most part
21:47:27 <julianleviston> scshunt: yeah, I know :)
21:47:34 <scshunt> echo-area: it really depends on what you're doing
21:47:49 <scshunt> for instance, in monadic combinators, underscored versions usually discard their results
21:47:51 <julianleviston> scshunt: but this is the verbatim example code from the Earley library. 
21:47:58 <scshunt> julianleviston: yep, that's not great
21:48:06 <echo-area> julianleviston: No, not underscores separated from names, but following names.  E.g. bracket vs bracket_
21:48:11 <julianleviston> scshunt: so I was assuming I was wrong here, and there was something I didn’t understand.
21:48:20 <julianleviston> echo-area: oh apologies.
21:48:33 <Clint> echo-area: that sometimes means "throw away the result"
21:48:34 <julianleviston> echo-area:  I thought you meant _bracket
21:48:57 <scshunt> leading underscore is usually used for a throw-away argument
21:49:14 <scshunt> because GHC, at least, won't worry about not using bindings beginning with an underscore
21:49:19 <julianleviston> scshunt: so I guess I’ll open an issue. It’s just a bit werid to me that this example is there with a “free type variable” (if that’s what it’s called?)
21:49:53 <julianleviston> The library *does* talk about the r variable.
21:49:57 <scshunt> julianleviston: hmm actually wait
21:50:05 <julianleviston> scshunt: it says this: r for rule: The type of a non-terminal. This plays a role similar to the s in the type ST s a. Since the parser function expects the r to be universally quantified, there is not much to do with this parameter other than leaving it universally quantified.
21:50:09 <scshunt> julianleviston: Grammar has only two type parameters in the source
21:50:12 <echo-area> scshunt: I have a function assert :: (a -> m Bool) -> a -> (a -> e) -> t m (), and I want to provide another function (a -> Bool) -> a -> (a -> e) -> t m (), what would be a good name for the variant?
21:50:52 <julianleviston> scshunt: yep… this is fine for Grammar as defined: Grammar r (Prod r String String Expr)
21:50:53 <scshunt> echo-area: assert . return
21:51:02 <scshunt> julianleviston: not sure what's going on there without looking more, actually
21:51:06 <julianleviston> scshunt:  the only thing is… how can r remain unspecified?
21:51:33 <scshunt> julianleviston: it's implicitly quantified in the function type
21:51:43 <scshunt> julianleviston: no different from head :: [a] -> a
21:51:45 <julianleviston> scshunt: am I missing a language extension?
21:51:54 <scshunt> julianleviston: I have no clue and don't have the time to investigate, sorry
21:52:04 <julianleviston> oh sorry :)
21:52:07 <julianleviston> no worries. thanks for helping
21:53:15 <echo-area> scshunt: It is assert_ f = = assert (return . f), if assert_ is a good name
21:54:26 <Lokathor> mniip, http://lpaste.net/154308
21:55:04 <mniip> I have no idea what that is
21:55:09 <samba1> I'm getting an error with stack docker pull
21:55:16 <samba1> Could not pull Docker image: fpco/stack-build:lts-5.6 There may not be an image on the registry for your resolver's LTS version in your configuration file
21:55:20 <samba1> 5.6 was just published a few hours ago, so I figured I'd decrease that, but I get the same for every version, and when I look at hub.docker.com/r/fpco/stack-build/tags, I do in fact see a tag for lts-5.6 and all the others I'm trying
21:55:24 <samba1> Why can't it pull, then?
21:56:21 <scshunt> echo-area: I wouldn't bother naming it
21:56:26 <scshunt> "assert . return" is fine
21:56:42 <scshunt> if you really need to name it, I'd prefer assert' over assert_
21:57:43 <Lokathor> mniip, benchmarks
21:58:06 <Lokathor> Curr is the normal version, Next is the version full of manual unboxing
21:58:58 <Lokathor> dunno if MutableArray# would still help
22:00:20 <echo-area> scshunt: The point-free version should be "assert . (return .)" instead of "assert . return".  But I see your point, I'm currently naming it "assert'" too.
22:12:36 <HallaSurvivor> just to clarify. all monads are already applicatives, right?
22:12:54 <Lokathor> correct
22:12:59 <HallaSurvivor> good good
22:13:02 <Lokathor> unless you're looking at some rather old code
22:13:06 <HallaSurvivor> *fades back into abstract tears*
22:13:36 <Lokathor> it wasn't made like that until 7.10, so old code should also have all monads as applicatives, but it's potentially possible that it won't
22:13:49 <HallaSurvivor> gotcha
22:13:58 <tippeneinn> Anyone know why an version from Paths_project  somehow changes from stack environment to the installed binary?
22:14:21 <Lokathor> tippeneinn, is it reading the version out of a file or other path related thing?
22:14:35 <lpaste> tippenein pasted “odd environment behavior” at http://lpaste.net/154310
22:14:51 <Lokathor> oh
22:14:55 <Lokathor> stack is eating that --version
22:15:04 <Lokathor> stack exec cmd -- --version
22:15:05 <Lokathor> try that
22:15:40 <tippeneinn> ok, good to know. it was broken for both environments :D
22:15:45 <Lokathor> stack was printing *its own* version
22:16:27 <Lokathor> similarly, you need to use -- if you want to pass RTS options to a program you run through stack, or the RTS options will affect stack itself
22:17:16 <tippeneinn> well, ideally I'd be running the binary version most cases, but the version number was disturbingly close to what I expected (0.1.2 vs 0.2.1)
22:18:03 <tippeneinn> thanks for the stack tips.
22:18:33 <HallaSurvivor> so as far as bind goes, is there a reason (other than m a >>= f asthetics) for the order?
22:18:56 <HallaSurvivor> it seems like functors/applicatives focus on moving functions into different abstractions
22:19:01 <Lokathor> you mean the order of the arguments?
22:19:07 <HallaSurvivor> (a -> b) -> (f a -> f b)
22:19:09 <HallaSurvivor> exactly
22:19:13 <Lokathor> naw it's totally arbitrary
22:19:34 <Lokathor> there was literally a person who was just put in charge of minor things like that during Haskell's design so that people couldn't get distracted with arguing
22:19:37 <Lokathor> and that's what they chose
22:19:44 <HallaSurvivor> it seems like having (a -> m b) -> (m a -> m b) would be more with the theme
22:19:52 <HallaSurvivor> and wait, really?
22:19:56 <HallaSurvivor> that's hysterical and wonderful
22:20:43 <Lokathor> that's what i've been told; they were given final say over all syntax decisions so that people could focus on language semantics
22:20:53 <tippeneinn> makes you wonder if languages need a dictator as opposed to a committee :D
22:21:00 <Lokathor> also keep in mind that some of modern Haskell's core features weren't in the first version of the language
22:21:26 <Lokathor> tippeneinn, well, since haskell was mostly made by a comittee :S
22:21:30 <julianleviston> tippenein: that was why that worked for haskell - there was a dictator for trivialities that distract people. But only those things! :)
22:22:25 <HallaSurvivor> haha
22:22:40 <HallaSurvivor> I can't imagine even helping to make something like haskell
22:22:48 <HallaSurvivor> I can understand making a python-esque language
22:23:01 <HallaSurvivor> but haskell devs must really know things :P
22:23:28 <julianleviston> HallaSurvivor: the core is reasonably tiny.
22:23:36 <Lokathor> it's deeply funny that you say that, because Python was literally made by one guy, and he's still got a huge sway over the language, and so he holds back good features that he happens to not like :/
22:23:49 <Lokathor> Python avoids FP stuff just because he isn't a fan of FP
22:24:22 <julianleviston> Lokathor: “No sir, I don’t like it!” https://www.youtube.com/watch?v=8JNuqEz_GCQ
22:25:17 <Lokathor> about like that
22:28:53 <HallaSurvivor> Lokathor, python was my first. The fact that map/filter/reduce were taken out and lists are mutable infuriates me
22:28:57 <mitchty> ok i give up, ghc-mod i swear is black magique that I just can't control, keeps picking cabal configure even when I told it to use stack, and no, there is no dist directory, and i'm using nix to install ghc-mod so same ghc, i accept defeat
22:29:12 <HallaSurvivor> but it's definitely gotten worse since I met haskell ;)
22:29:13 <levi> If you want to learn how to make a Haskell-like language, Simon Peyton Jones wrote a whole book about it, although it's a bit pre-Haskell.
22:29:21 <Lokathor> HallaSurvivor, I went the Java -> Python -> Java -> Haskell path
22:29:44 <HallaSurvivor> Seems fair enough
22:29:51 <ollef> julianleviston: It seems like you are trying out the examples with an old version of Earley installed. The kind signature of Grammar changed in 0.10.
22:29:56 <HallaSurvivor> levi, name of book for sake of sparing me a google? <3
22:30:04 <levi> When I use Python, I am annoyed when I run across statements that don't also work as expressions.
22:30:22 <julianleviston> ollef:  thanks… I’m actually in the process of updating to Stack LTS 5.6 right now, so I think I’m on the right track :)
22:30:28 <levi> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
22:30:39 <julianleviston> ollef: I didn’t want to quite close the issue until I’d gotten verification that it was my own idiocy :)
22:30:58 <ollef> julianleviston: Either that, or use the examples from the version you're using. :)
22:31:20 <julianleviston> ollef: hehe :) I stupidly didn’t specify the version. I did it all very stupidly. :)
22:31:35 <julianleviston> ollef: thanks very much. So awesome you’ve built this.
22:31:42 <HallaSurvivor> levi: thanks :)
22:32:30 <ollef> julianleviston: No worries! I'm happy if someone finds it useful.
22:32:35 <levi> It starts with Lambda Calculus and works through all sorts of interesting topics on the way to a practical implementation.
22:33:24 <levi> The state of the art has advanced a bit since then, but it builds on the general foundations that are described in the book.
22:33:56 <HallaSurvivor> Definitely going to read that :)
22:34:02 <HallaSurvivor> (with all my free time...)
22:37:02 <Lokathor> HallaSurvivor, have you read Parallel and Concurrent Programming In Haskell?
22:37:10 <lpaste> tippenein pasted “unable to 'trace' version parsing” at http://lpaste.net/154312
22:37:26 <HallaSurvivor> nope, haha. I really just got into haskell around september
22:37:51 <Lokathor> http://chimera.labs.oreilly.com/books/1230000000929/index.html it's my favorite haskell book
22:38:06 <julianleviston> Lokathor: it’s SO good isn’t it! The writing is graet.
22:38:13 <HallaSurvivor> I'll definitely read it!
22:38:26 <julianleviston> Lokathor: (the irony of misspelling “The writing is great.”)
22:39:14 <HallaSurvivor> I love how many books are just online
22:39:36 <HallaSurvivor> I love libraries but boy am I content to lie in bed and have the knowledge spoon fed to me :P
22:39:38 <tippeneinn> I'm pretty confused why that trace isn't being printed
22:40:37 <Lokathor> HallaSurvivor, there's a lot of knowledge available from bed
23:35:04 <adarqui> anyone ever use optparse-generic? i'm having problems with a sum type with more than 3 constructors.. when i use 4, it breaks with all of these generic errors.. anyone ever experience anything like that with this library?
23:39:49 <Cale> woooooow, Google's AlphaGo just beat Lee Sedol, 9 dan professional
23:40:53 <quchen> Woah.
23:43:32 <pavonia> adarqui: Do you have a sample?
23:46:48 <zv> amazing game
23:47:12 <zv> I was blown away by how many moves the announcers declared "weak" only to have them used 20-30 moves down the road by alphago
23:47:31 <zv> shows deep deep insight into the game that is not possible with brute force.
23:47:45 <zv> as a huge go fan, I was absolutely blown away by alphago's strategy
23:48:15 <zv> I declared the game won by Lee Sedol 20 minutes before the round closed, it seemed like he had obviously won it. 
23:48:46 <zv> Alphago was literally creating entirely new seki while the game was going on, this is a historic moment.
23:48:47 <adarqui> pavonia: hey! ya i'm making an issue for it right now i'll link in one sec
23:49:45 <liste> zv: too bad we don't really understand that deep insight
23:50:39 <adarqui> pavonia: https://github.com/Gabriel439/Haskell-Optparse-Generic-Library/issues/12
23:51:44 <echo-area> How many more scores did AlphaGo win?
23:52:00 <zv> liste: computer analysis contributed to (human) chess. I'm sure alphago and programs like it will continue to produce robust literature for years to come on new stragems
23:52:04 <kadoban> lee sedol resigned, but alphago was ahead by about 8 or so in endgame.
23:52:07 <zv> echo-area: the game was conceded
23:52:20 <zv> I would say it was ahead by a dozen
23:52:49 <pavonia> adarqui: No idea, sorry
23:53:49 <adarqui> cool np! seems like a legit issue somewhere in the generic parsing
