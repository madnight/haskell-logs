00:01:47 <EvanR> yes but i see no reason why this functionality must be integrated into editors only
00:07:38 * hackagebot hjsmin 0.2.0.0 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.2.0.0 (ErikDeCastroLopo)
00:07:38 * hackagebot hjsmin 0.2.0.1 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.2.0.1 (ErikDeCastroLopo)
00:31:22 <kogu> whats the point of this group
00:31:35 <malc_> sex
00:32:30 <kogu> there is no haskell question or answers 
00:32:42 <kogu> ım new to irc 
00:32:44 <johnw> ask a haskell question, get a haskell answer
00:36:12 <kogu> ok erlang or haskell
00:36:19 <kogu> which one 
00:36:35 <kogu> ı could starrt
00:39:00 <johnw> that's really beyond our purview
00:39:04 <johnw> but if you pick haskell, we're here
00:58:19 <purelazy> On https://wiki.haskell.org/Newtype is the term "non-total semantics", for which google finds only four references. What does it mean?
00:58:35 <purelazy> Is there a more commonly used term?
00:59:44 <purelazy> Was "non-strict" meant instead?
01:09:30 <parsecChar> does haskell-vim-now work well with nixos, or do I need stack?
01:18:48 <numee> i'm trying to make a nice-looking EDSL. i'd like to write something like do { if blah then "foo" else "bar" } instead of do { if blah then cmd "foo" else cmd "bar" }
01:18:52 <numee> i thought i could do this with OverloadedStrings and FlexibleInstances by writing `instance IsString (M ())`. but ghc won't infer to use this instance saying some type variable is ambiguous
01:19:16 <numee> if i specify types explicitly like "foo" :: M () it works as expected. it seems to be related to the open-world assumption. is there any way to circumvent this limitation?
01:20:09 <johnw> I'd personally advise against being quite that magical
01:20:35 <johnw> it will make your code look strange to a regular Haskeller, who then has to figure out what sort of weird voodoo you're doing to interpret string literals as actions in some monad
01:21:57 <numee> johnw: i'm a hobbyist programmer so i don't take care of other people reading my code
01:22:17 <numee> *i don't need to take care
01:25:10 <malc_> numee: http://www.willamette.edu/~fruehr/haskell/evolution.html
01:30:47 <numee> malc_: the page tells me there's much to learn about Haskell even after having laerned it for several years
01:31:06 <johnw> yeah, that's pretty much true
01:31:08 <malc_> numee: that it does - yeah
01:31:24 <johnw> even after 10 years, there will be whole worlds within Haskell you probably haven't seen yet
01:34:19 <parsecChar> with stack, how do I install 7.10.3 ?
01:37:24 <ania123> does one knows is there chanell to discuss about access control?
01:37:48 <sleblanc> purelazy, total is in contrast to partial, not static
01:38:35 <sleblanc> purelazy, a total function is a function that works for all of its input
01:38:45 <sleblanc> well, not work, but terminates
01:39:31 <purelazy> sleblanc: a partial function is undefined for some of it imput
01:39:33 <purelazy> imput
01:39:38 <ania123> does one knows is there chanell to discuss about access control?
01:39:49 <sleblanc> purelazy, yes
01:40:22 <sleblanc> purelazy, this also includes functions that you cannot prove termination of
01:40:30 <sleblanc> (or non-termination)
01:40:51 <purelazy> sleblanc: I tried Any . getAny $ Any _|_     = Any _|_  
01:41:23 <purelazy>  (Any . getAny $ Any undefined) == Any undefined
01:42:26 <purelazy> sleblanc: According to the page, it is supposed to be OK
01:42:40 <tomboy65> ania123: what kind of access control?
01:43:02 <purelazy> sleblanc: I may have made a mistake somewhere
01:43:27 <purelazy> > data Any = Any { getAny :: Bool } deriving (Show, Eq)
01:43:29 <lambdabot>  <hint>:1:1: parse error on input ‘data’
01:43:41 <purelazy> hmmm
01:43:51 <pavonia> Use @let
01:44:04 <sleblanc> purelazy, the way it's shown might be confusing, but what it means is that bottom values that are embedded inside otherwise valid data constructors are not bottoms until they are actually evaluated
01:44:05 <purelazy> > let data Any = Any { getAny :: Bool } deriving (Show, Eq)
01:44:07 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
01:44:20 <pavonia> @let data Any = Any { getAny :: Bool } deriving (Show, Eq)
01:44:24 <lambdabot>  Defined.
01:44:36 <sleblanc> that is to say, you can pattern match (Any undefined) on (Any _), but you cannot use it
01:44:38 <purelazy> > (Any . getAny $ Any undefined) == Any undefined
01:44:40 <lambdabot>      Ambiguous occurrence ‘Any’
01:44:40 <lambdabot>      It could refer to either ‘L.Any’,
01:44:40 <lambdabot>                               defined at /tmp/mueval20586571991973387981.hs:3...
01:45:04 <sleblanc> hm, should import Data.Monoid instead
01:45:12 <purelazy> hehe - not having much luck today
01:46:01 <sleblanc> > (Data.Monoid.Any . Data.Monoid.getAny $ Data.Monoid.Any undefined) == Any undefined
01:46:03 <lambdabot>      Ambiguous occurrence ‘Any’
01:46:03 <lambdabot>      It could refer to either ‘L.Any’,
01:46:03 <lambdabot>                               defined at /tmp/mueval20586571991973387981.hs:3...
01:46:15 <sleblanc> > help
01:46:17 <lambdabot>  Not in scope: ‘help’
01:47:35 * hackagebot danibot 0.2.0.0 - Basic Slack bot framework.  https://hackage.haskell.org/package/danibot-0.2.0.0 (DanielDiazCarrete)
01:49:40 <pavonia> > (L.Any . L.getAny $ L.Any undefined) == L.Any undefined
01:49:42 <lambdabot>  *Exception: Prelude.undefined
01:51:36 <sleblanc> purelazy, note that this is the expected result, as the language will pattern match (L.Any x) on both sides of the (==) operator, then it will attempt to compare _|_ with _|_
01:53:29 <purelazy> sleblanc: I am still trying to understand this stuff. I am confused as to why the the webpage says its OK and ghci & lambdabot have exception
01:53:57 <sleblanc> purelazy, the page does not say it's okay, it is only illustrating an "oddity" with the bottom value
01:54:15 <sleblanc> and ghci don't say it's bad
01:54:19 <sleblanc> ghci does not
01:54:31 <purelazy> AS in:      Any . getAny $ Any bottom    = Any bottom    -- so far so good
01:54:38 <sleblanc> The step that fails when you type that in GHCI is the showing to the user part
01:55:25 <sleblanc> show is recursively evaluating the expression, to show you the result. When it reaches the bottom value, it blows up because bottom values cannot be evaluated at all
01:55:35 <sleblanc> it's like de-referencing a null pointer
01:56:14 <sleblanc> you can have a pointer set to 0x0, just don't put a star next to it and you will be fine (without involving undefined behaviour)
01:56:50 <sleblanc> likewise, undefined can exist inside a value, but you will not know until you evaluate it
01:59:55 <purelazy> sleblanc: I think I see. The statement is true, yet its result is undefined. 
01:59:57 <sleblanc> purelazy, was this more clear?
02:00:18 <sleblanc> purelazy, the statement is not true, it's undefined
02:00:47 <sleblanc> but it does not fail to compile because there is no way to prove you will actually look at the value
02:01:39 <purelazy> I do feel I am nearer to understanding - rather than further from  :)
02:02:30 <sleblanc> :D
02:02:52 <purelazy> sleblanc: Thank you very much
02:03:12 <sleblanc> there are only a few means of introducing bottom values in Haskell (other than on purpose): non-exhaustive pattern matches, and non-total functions
02:03:57 <purelazy> non-total = partial
02:04:18 <sleblanc> I prefer non-total because "partial" can be confused with partial application
02:04:28 <purelazy> ahhh
02:04:31 <EvanR> sleblanc: bottom can be in a value somewhere and you will be fine even if you DO evaluation it! ;) (to WHNF)
02:04:33 <sleblanc> and partial application is appropriately dealt with using static typing
02:04:40 <purelazy> I am not confused about that
02:04:55 <purelazy> Cos I understand partial application
02:05:19 <EvanR> another name for partial functions is malfunctions
02:05:22 <sleblanc> EvanR, thank you for chiming in; I am also a learner, and there is a lot behind the language
02:05:29 <sleblanc> haha!
02:05:40 <sleblanc> is that an approved term?
02:05:46 <EvanR> i just did
02:05:58 <sleblanc> I like it
02:05:59 <EvanR> not really
02:06:12 <purelazy> I typically don't like things expressed in the negative, especially where there is a perfectly good positive term 
02:06:26 <purelazy> but that's by the by
02:06:35 <EvanR> you can use partial functions as long as you have a proof it is only ever used with values it is defined for
02:06:40 <sleblanc> purelazy, yeah, but we're talking about totality, not partiality
02:06:49 <sleblanc> (pun)
02:07:09 <EvanR> otherwise you are playing russian roulette
02:07:13 <purelazy> i don't care - impartial you might say
02:07:59 <EvanR> and if you can use a total function instead, perhaps with pattern matching, you wont have to worry about this proof 
02:08:31 <EvanR> in most languages this proof is required several times a line!
02:09:18 <purelazy> Even though I know what a total (and non-total, aka partial) function is, I am yet to see the cosmic ramifications
02:09:37 <sleblanc> EvanR, can you show examples of needing that proof in other languages?
02:09:53 <purelazy> apart from the fact that partial functions can crash
02:10:00 <EvanR> or freeze up
02:10:01 <sleblanc> purelazy, and they can hang too
02:10:06 <purelazy> maybe that *IS* the cosmic ramification
02:10:07 <EvanR> which is even worse
02:10:19 <purelazy> inf loop
02:10:24 <purelazy> etc
02:10:38 <sleblanc> purelazy, of which there are many kinds
02:10:47 <sleblanc> https://en.wikipedia.org/wiki/Divergence_%28computer_science%29
02:11:20 <EvanR> sleblanc: x = params[:i][:j][:k].foo
02:11:43 <EvanR> starting with whether params is even defined, which nothing will tell you until runtime. and so on
02:12:16 <EvanR> i used 4 or 5 partial function applications
02:12:22 <EvanR> depending on how you count
02:13:15 <purelazy> params[:i][:j][:k].foo ?? I don't reckognise the syntax
02:13:25 <EvanR> its not haskell
02:13:38 <EvanR> i was responding to sleblanc's question
02:14:06 <purelazy> EvanR: It might be Haskell :)
02:14:09 <sleblanc> Does that apply to most languages, though? Surely, if params was defined in C# or Java semantics, it would be proven that params is defined and it can be indexed at three levels deep
02:14:37 <EvanR> you can prove it
02:14:44 <EvanR> the point is you dont want to have to
02:15:16 <sleblanc> But the semantics of the language guarantee that the value exists...
02:15:34 <EvanR> starting with whether your variable is spelled right, thats just step 0
02:15:50 <EvanR> but is the value in the variable allowed to be used with [ ]
02:16:25 <EvanR> [ ] is a partial operation, taking the universe of dynamic values as the type of its argument
02:21:52 <sleblanc> EvanR, if I understand right, does that mean that we need to not only prove that :i, :j and :k are well defined, but that their order of definition does not affect the outcome either?
02:22:10 <sleblanc> (irrelevant in a pure language)
02:23:08 <sleblanc> i meant evaluation, not definition
02:23:15 <EvanR> they are constants
02:23:39 <EvanR> the brackets is the sticky part, it only works on some data structures
02:25:36 <sleblanc> Well, they are either array or item getter method overloads, so can't they be statically inferred at compile time, unless the item getter is partial?
02:27:07 <sleblanc> although they are not as succinct as other languages more popular with functional paradigms, C++ templates do allow extensive guarantees, and if those proofs are hidden behind public APIs (libraries and headers), they need to be considered as part of the language, so you do not have to type the proofs yourself
02:27:45 <EvanR> i have heard of some crazy stuff you can do with templates
02:27:46 <sleblanc> for instance, iterator APIs allow to encode semantics that preclude wanton indexing of arrays
02:28:22 <EvanR> libraries that have guarantees are fine, but when youre writing the code yourself you have to have all this in your head
02:28:31 <EvanR> unless the compiler can help you somehow
02:29:10 <EvanR> yes there are patterns that can reduce the brainload like iterators
02:30:33 <sleblanc> constexpr, static asserts, class templates, all stuff that help the C++ compiler help you
02:30:36 <nineonine> hey there
02:30:40 <nineonine> aeson question
02:30:53 <nineonine> how can I handle empty object parsing ?
02:31:04 <nineonine> lets say I have nested data structure
02:31:18 <EvanR> handle?
02:31:31 <nineonine> sometimes one of the fields contains some object which should be parsed as well
02:31:32 <sleblanc> nineonine, I have never used Aeson; can't you check if the raw document has no bytes?
02:31:36 <nineonine> but sometimes its just {}
02:31:50 <EvanR> do you want that to be an error or become a value
02:31:54 <nineonine> value
02:32:00 <EvanR> what value? :)
02:32:15 <nineonine> well Nothing will work
02:32:15 <nineonine> :)
02:32:39 <nineonine> i was considering to have another Data Constructor for that case
02:32:52 <nineonine> but Im just wondering if it can be done without it
02:32:53 <EvanR> its probably easier to make a new type
02:33:25 <nineonine> new type ?
02:33:25 <EvanR> ah you want Maybe X
02:33:33 <EvanR> where X is FromJSON
02:33:56 <nineonine> i thought you can use maybe only when there is no field found 
02:34:21 <nineonine> i tried it
02:34:57 <nineonine> aight Ill just use another data constructor for that
02:35:03 <nineonine> thanks anyway !
02:35:27 <EvanR> lookat parseMaybe
02:35:53 <nineonine> okay ! 
02:37:25 <puregreen> nineonine: xObj <- o .: "field"; mbX <- if null xObj then return Nothing else Just (parseJSON (Object xObj))
02:37:43 <nineonine> niiice !
02:37:44 <nineonine> :)
02:37:45 <puregreen> * Just <$> parseJSON (Object xObj)
02:37:57 <nineonine> cool thanks !
02:38:37 <puregreen> or even «if null xObj then return Nothing else Just <$> o .: "field"» 
02:39:06 <sleblanc> puregreen, nice guillemets
02:39:16 <puregreen> aww
02:39:41 <puregreen> (“null xObj” won't work if your GHC isn't recent enough, and then you'll have to import qualified Data.HashMap.Strict as HM and use ‘HM.null’)
02:42:38 <EvanR> parseMaybe seems to be a wrapper over that parseJSON
02:43:50 <EvanR> ah nevermind
03:03:41 <dimsuz> Hello! I am putting what I am learning about applicatives/monads in practise and wrote not very big function which I feel can be improved. If anyone has time, please check out this paste, maybe you'll have advice for me. Thank you! http://lpaste.net/155060
03:04:07 <dimsuz> I am interested about potential performance problems. And elegance could be better I guess...
03:24:51 <lpaste> echo-area pasted “On behavior of signal handlers” at http://lpaste.net/155061
03:24:51 <cocreature> is it safe to unsafePerformIO an ffi binding that uses alloca and peek?
03:25:05 <echo-area> Hi
03:25:11 <cocreature> I only need the alloca and peek because the api returns a struct by value
03:25:21 <cocreature> so I wrap it in a function that writes to a pointer
03:25:32 <cocreature> but apart from that it has no side effects
03:25:43 <echo-area> Could anyone explain what I see in the above program?
03:38:46 <dbe> Is there a de-facto standard as to where tests should be? Do I put the tests in src/Data/BinarySearchTree.hs, or do I create a separate src/Data/BinarySearchTreeTest.hs? Or a test/Data/BinarySearchTree.hs? And is there a standard way of checking the tests? Currently I load the file in ghci, import quickcheck and "quickcheck prop_something"
03:44:42 <puregreen> dbe: put tests in the “tests” folder and define a test suite in your .cabal file (then you'd be able to run tests with “cabal test”)
03:45:47 <dbe> puregreen: all right, thanks
04:02:40 * hackagebot config-manager 0.0.0.1 - Configuration management  https://hackage.haskell.org/package/config-manager-0.0.0.1 (guyonvarch)
04:13:17 <roelof> What data-structure(s) can I use the best for this : http://lpaste.net/155064
04:48:23 <davorb> i'm building a project in slack and getting this error message. any idea of what I can do to solve it? https://gist.github.com/davorb/8d28409cabcc369fe52d
04:49:10 <davorb> a "slack build" works just fine. it's when I try to do "slack test" that everything breaks down.
04:50:30 <davorb> nevermind. i figured it out. needed to add some stuff to exposed-modules in cabal.
04:52:57 <suppi> davorb, do you mean stack?
04:53:10 <davorb> suppi: yes.
04:54:04 <davorb> i wish stack has something like watchman-build or guard built in, that would run my tests for me as soon as I changed some files.
04:54:20 <roelof> What data-structure(s) can I use the best for this : http://lpaste.net/155064
04:55:21 <suppi> davorb, i think there is, sec.
04:56:19 <davorb> suppi: i'd be amazing if you could tell me how to run it. i heard some people talking about it being there, but I haven't been able to find it.
04:56:44 <suppi> davorb, there's a flag --file-watch or something
04:57:38 <davorb> suppi: ah, yeah. that's exactly what I was looking for! thanks!
04:57:47 <suppi> davorb, np :)
05:01:42 <suppi> davorb, http://docs.haskellstack.org/en/stable/build_command/?highlight=watch
05:03:09 <suppi> roelof, a record, perhaps?
05:10:24 <roelof> suppi:  that can be working. I also thought about using newTypes 
05:13:05 <suppi> roelof, why newtype?
05:14:09 <roelof> suppi:  lesser changes that someone uses the wrong types. I thought newtypes could take of that 
05:21:05 <suppi> roelof, newtype is basically used to give a name for an existing type, not building a new data structure
05:25:39 <rfpun> does anyone have a good setup for "interactive" development with haskell? by interactive i mean the style common with lisp (and python) where the program is incrementally developed, loaded into the repl, tested, etc. the key problem with haskell here is that it appears it throws away all defined variables on every file loading. is there a way to send just a function and keep the environment?
05:26:25 <rfpun> this is also a huge obstacle to using haskell to explore a dataset and build a toolstack at the same time. it is very annoying to reload the sample data every time
05:27:43 * hackagebot reqcatcher 0.1.0.0 - A local http server to catch the HTTP redirect  https://hackage.haskell.org/package/reqcatcher-0.1.0.0 (hiratara)
05:29:42 <roelof>    suppi  thanks for the info 
05:30:00 <opqdonut> rfpun: perhaps you should write definitions in the source file
05:30:16 <opqdonut> or perhaps in a separate interactive.hs file which imports the stuff you want
05:30:20 <Rembane> rfpun: I use a scratch-module where I put all the useful variables and functions that I need in the repl and then load that. But it doesn't help yuo with the reloading of the datasets.
05:30:20 <opqdonut> but I don't have a real answer
05:30:38 <opqdonut> oh right, yeah, data reloading
05:31:39 <opqdonut> some hot reloading library might help, e.g. http://hackage.haskell.org/package/dyre
05:32:25 <Rembane> rfpun: This is nukes to shoot a fly, but have you looked into Kronos Haskell? http://www.kronosnotebook.com/haskell
05:32:29 <opqdonut> hmm, no, it uses explicit state saving, see http://hackage.haskell.org/package/dyre-0.8.12/docs/Config-Dyre-Relaunch.html
05:35:13 <rfpun> Thanks! i guess the main issue is that if i am working with a potentially large dataset it can take time to load into memory, if want to explore/play around with it the extra few seconds can get annoying. otherwise putting the definitions into the file is OK
05:35:41 <rfpun> this might be the first annoyance i've come across that haskell doesn't have a neat solution for :)
05:37:11 <rfpun> Rembane: the notebook is a slightly different idea, and doesn't work on windows :(
05:41:16 <Rembane> rfpun: Ach. :)
05:41:47 <suppi> rfpun, best solution I can give you is adding declaration to things in emacs while working on a module :O
05:42:24 <rfpun> suppi: can you explain what you mean?
05:42:55 <suppi> rfpun, in emacs you can open a repl where you work on haskell modules
05:43:00 <suppi> and load modules into that repl
05:43:40 <suppi> if you declare things in that module and load it into the repl you can keep working with those, and then remove them when you finish
05:43:58 <suppi> not ideal, but is a bit closer to what you'd like i think
05:46:54 <magbo> Greetings, people! I wonder if someone has something akin to Erlang's gen_server with `gen_server:call` (syncronous mailbox consumption strategy) implemented on top of Cloud Haskell's `distributed-process` library.
05:47:01 <magbo> If anyone has any pointers, please do share.
06:27:50 * hackagebot Spock-lucid 0.1.0.0 - Lucid support for Spock  https://hackage.haskell.org/package/Spock-lucid-0.1.0.0 (Artyom)
06:59:04 <nitrix> What's the precedence on (::) ?
07:01:46 <puregreen> is there any general “embed :: Embeddable m n => m a -> n a”?
07:02:31 <puregreen> (where m, n are monads)
07:02:51 * hackagebot svg-tree 0.4.2 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.4.2 (VincentBerthoux)
07:04:29 <nitrix> puregreen: I think it could work too with m and n being functors; if the goal of the embed is just to swap the context of the type `a`.
07:04:40 <nitrix> puregreen: Depends on your intentions.
07:05:25 <puregreen> nitrix: okay, more precisely: I want to write a function of type “HtmlT m a -> ActionCtxT cxt n a”
07:06:00 <puregreen> and it should work for e.g. m=Identity and n=anything, or m=IO and n in MonadIO
07:14:16 <sbrg> puregreen: something from C.M.Morph?
07:14:50 <puregreen> sbrg: I've already looked there but if there's a solution there I don't see it
07:14:57 <sbrg> ah
07:15:42 <puregreen> (but I don't have any experience with mmorph so I wouldn't trust myself much)
07:16:20 <xa0> if you can convert from HtmlT to the other one, then yeah you can use mmorph
07:16:32 <xa0> but otherwise you need something special
07:20:51 <puregreen> hm, MonadBase looks like what I need
07:25:18 <puregreen> ...or not
07:51:00 <maybefbi> how does one make a Middleware using servant?
07:51:09 <orion> Hey, I'm faced with an interesting issue: I am interacting with the Facebook API, but its JSON results are paginated. An object typically looks like, "comments": { "data": [ ... ], "paging": { "next": "https://..." } } Is there some magic I can do with Aeson to page through the results and construct one massive data structure in memory?
07:51:29 <davean> orion: no
07:51:40 <davean> orion: you'll have to break it out and process it step-wise
07:51:45 <puregreen> orion: Aeson by itself isn't going to be enough because Aeson has no idea how to download things
07:52:07 <orion> puregreen: Sure, but I was wondering if there was, say, Monadic Black Magic or something I could do.
07:53:11 <orion> You see, things get really interesting when there are nested data sets each with their own paging.
07:53:44 <puregreen> orion: you can probably steal something from   let Identity (render, a) = runHtmlT x
07:53:47 <puregreen> ouch
07:53:50 <davean> orion: the type Aeson parses can be an action to run to generate the expanded result
07:53:50 <puregreen> https://github.com/prowdsponsor/fb/blob/master/src/Facebook/Pager.hs
07:54:10 <davean> orion: you could parse to a "IO TheTypeIActuallyWant"
07:54:27 <davean> Then run that
07:54:33 <orion> Interesting!
07:54:34 <davean> orion: then you'd be done
07:55:43 <davean> orion: of course, inernally, what will happen is at each step, it'll generate that and run it, inside its self.
07:55:55 <davean> unwrapping an additional layer each tiem
07:56:10 <davean> orion: make sense?
07:56:48 <davean> IO is just data, your JSON's data can just be "what are the commands I need to run to get the thing I want?"
07:57:20 <orion> davean: But, the structure is never actually parsed.
07:57:32 <davean> orion: what do you mean?
07:57:38 <orion> I'll get a top level object and I'll need to run the nested monads.
07:57:39 <davean> To generate the IO, it *does* parse the JSON
07:57:52 <davean> but that doesn't run the web requests to fill in the missing data
07:58:05 <davean> the result has commands of how to take its (internally contained) data, and fill in the blanks
07:58:15 <orion> Right, I meant to say I need to run the web requests separately.
07:58:19 <davean> generating the final resuult
07:58:21 <davean> yes
07:58:23 <davean> exactly
07:58:40 <davean> IO is just a list of directions (not really, but basicly, sorta kinda)
08:05:58 <orion> puregreen: Thanks for that link. It's instructive.
08:07:09 <magbo> Is there a separate channel for cloud-haskell? #cloud-haskell is empty :(
08:07:54 * hackagebot Spock-lucid 0.2.0.0 - Lucid support for Spock  https://hackage.haskell.org/package/Spock-lucid-0.2.0.0 (Artyom)
08:07:59 <magbo> I would really love to talk to someone who uses cloud haskell in production / has done a real project with it, outside the scope of examples on the website.
08:08:17 <davean> magbo: I'm curious, what do you wish to use it for?
08:09:11 <magbo> davean: to implement a consensus protocol. First I will need `gen_server:call` functionality from Erlang OTP, but then I might need some other equivalents of OTP to parallelize things.
08:09:37 <magbo> The only distributedness (as opposed to concurrency) I need from the framework is two trusted nodes talking to each other.
08:10:09 <magbo> Basically, I need a nice concurrency framework that mimics OTP for easier learning curve (we're short on time)
08:11:02 <magbo> And I really don't want to do that in Erlang or Elixir because we don't have enough time to debug silly type-level mistakes, even though we're going to be write prop-based tests anyway.
08:11:07 <orion> magbo: Like Raft?
08:11:14 <magbo> Waaay waaay less smart.
08:11:30 <magbo> The one that RSCoin uses, one minute.
08:11:57 <xa0> is variadicity a form of polymorphism? (does it have a nicer name?)
08:12:01 <magbo> orion: the one from this paper: https://eprint.iacr.org/2015/502.pdf
08:12:23 <magbo> xa0: I would say "yes" and "not that I know of".
08:12:49 <magbo> In Haskell, however (again, in my opinion) no polymorphism is better than variadic polymorphism.
08:12:54 * hackagebot idris 0.10.3 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.10.3 (EdwinBrady)
08:14:06 <xa0> magbo: yeah, i know, i'm just working in c++ currently and i don't like the term
08:14:28 <magbo> orion: as you see, the idea is really simple: communication through consumers, majority of responsible nodes must agree, inclusion into lower-level blocks happens synchronously.
08:15:30 <magbo> so, for the synchronicity of the last bit without locking the rest of the system and without dancing with MVar / TVar, we want gen_server behaviour in cloud haskell.
08:16:00 <magbo> xa0: "variadicity" can't miss. Everyone will momentarily understand about which sort of polymorphism you are talking.
08:16:52 <magbo> We could as well call things "a yellow star" or "a bage cucumber", as long as the term is widespread enough, we should just use it, to keep the status quo of terminology.
08:17:20 <magbo> I'm not happy about Jokers and Clowns in Bifunctors, but I stick to those :)
08:18:58 <xa0> magbo: heh, true
08:19:46 <xa0> i was just hoping it was another templating/generics = parametric polymorphism case
08:38:27 * hackagebot servant 0.5 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.5 (SoenkeHahn)
08:38:29 * hackagebot servant-server 0.5 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.5 (SoenkeHahn)
08:38:31 * hackagebot servant-client 0.5 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.5 (SoenkeHahn)
08:43:27 * hackagebot servant-foreign 0.5 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.5 (SoenkeHahn)
08:43:29 * hackagebot servant-cassava 0.5 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.5 (SoenkeHahn)
08:43:31 * hackagebot servant-docs 0.5 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.5 (SoenkeHahn)
08:43:33 * hackagebot servant-js 0.5 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.5 (SoenkeHahn)
08:43:35 * hackagebot servant-blaze 0.5 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.5 (SoenkeHahn)
08:48:37 * hackagebot servant-lucid 0.5 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.5 (SoenkeHahn)
08:48:39 * hackagebot servant-mock 0.5 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.5 (SoenkeHahn)
09:05:50 <dougia> Is there current version of haskell binary available for 32bit macs (using osx 19.9.5).
09:07:47 <geekosaur> er, no version of os x since 10.6 boots on 32 bit
09:08:28 * hackagebot redis-resp 0.4.0 - REdis Serialization Protocol (RESP) implementation.  https://hackage.haskell.org/package/redis-resp-0.4.0 (ToralfWittner)
09:12:35 <cat-o-the-thrill> puregreen you rock
09:16:09 <puregreen> wha
09:16:20 <dougia> geekosaur:  ok, i believe you.  I tried the download from https://www.haskell.org/platform/ and it wouldn't run.  I'll try and download again, see if it works.
09:16:42 <geekosaur> that might well be something else. I don't know if anyone builds for 10.9
09:17:06 <geekosaur> (apple changes lots of things in new versions, a binary build on 10.11 or 10.10 is unlikely to work on 10.9)
09:17:16 <geekosaur> (notably new linker commands that cause dyld to abort)
09:18:01 <puregreen> cat-o-the-thrill: ^
09:18:13 <geekosaur> and if someone tried to do a backward compatibility build on a newer version, it's far too easy to get it wrong and e.g. leak new loader commands into an otherwise compatible binary)
09:18:38 * hackagebot vivid 0.2.0.0 - Sound synthesis with SuperCollider  https://hackage.haskell.org/package/vivid-0.2.0.0 (TomMurphy)
09:20:15 <ania123> is here anyone interested about access control? 
09:20:56 * geekosaur isn;t involved in the haskell platform builds, but for other things keeps around a bunch of VMs going back to 10.8 to do builds because backward compat building is too unreliable. "thanks apple"
09:28:39 * hackagebot config-manager 0.0.0.2 - Configuration management  https://hackage.haskell.org/package/config-manager-0.0.0.2 (guyonvarch)
09:28:59 <purelazy> > :t 1
09:29:01 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:29:59 <dougia> I'll endevour to update my mac and try again.
09:33:17 <marrrk_> Can I avoid repeating my input here: getPlantLinks connection limit offset = map plantPicturePicture_id <$> getPlantPictures connection limit offset ?
09:36:38 <puregreen> marrrk_: not really
09:36:44 <puregreen> you can write “fmap.fmap.fmap” but meh
09:37:23 <xa0> lol.
09:37:28 <marrrk_> woah
09:38:18 <puregreen> and while there's a way to apply something to the last argument of *any* function, it's not in standard library and is a bit magic and fragile
09:38:39 * hackagebot vivid 0.2.0.1 - Sound synthesis with SuperCollider  https://hackage.haskell.org/package/vivid-0.2.0.1 (TomMurphy)
09:39:51 <marrrk_> okay
09:39:57 <marrrk_> maybe I'll just use shorter variable names
09:47:11 <purelazy> $ cabal update
09:47:12 <purelazy> Downloading the latest package list from hackage.haskell.org
09:47:30 <purelazy> then it hangs. What could cause that?
09:47:36 <Hafydd> getPlantLinks = ((fmap (map plantPicturePicture_id) .) .) . getPlantPictures
09:48:06 <MarcelineVQ> Hafydd: :(
09:48:16 <Hafydd> is ther a problem, m8?
09:48:27 <MarcelineVQ> nuffin govnah
09:49:02 <Hafydd> I suppose that, in principle, that could become 5 applications of fmap.
09:49:30 <Hafydd> But it seems more readable to use the specialised versions.
09:50:02 <Hafydd> (And indeed more readable yet to write it in pointful style.)
09:51:42 <Hafydd> marrrk_: if you're passing around "connection limit offset" a lot, it might benefit you to add ReaderT to the functor that <$> is operating on here; then your implementation would become somewhat simpler.
09:52:44 <Hafydd> (Or add some subset of them. "connection" sounds like something globally and statically configured, which ReaderT would suit.)
09:53:16 <marrrk_> The . at the end is confusing to me.
09:53:31 <marrrk_> Yeah connection is everywhere. The other two aren't.
09:54:39 <air`> So I've uploaded a package and the docs aren't building. In the past I've uploaded docs by hand, but then the "source" links are broken. Is there any way to a) trigger a doc build, b) upload docs with the "source" component?
09:56:14 <lpaste> Hafydd pasted “marrrk_” at http://lpaste.net/155174
09:56:33 <Hafydd> marrrk_: consider the above sequence of semantics-preserving transformations.
09:57:19 <marrrk_> okay I will try
09:58:04 <marrrk_> I have trouble with the third one already
09:58:20 <Hafydd> marrrk_: do you not see how 3 follows from 2?
09:58:33 <air`> also: the haddock syntax is very broken on the "front page" of the package -- will uploading docs even fix that?
09:58:44 <air`> the package: hackage.haskell.org/package/vivid
09:59:10 <lpaste> Hafydd annotated “marrrk_” with “marrrk_ (annotation)” at http://lpaste.net/155174#a155175
09:59:26 <Hafydd> It's rewritten there without $, in case that was making its meaning unclear.
09:59:37 <marrrk_> exactly
09:59:42 <marrrk_> I will have a look again
09:59:53 <Sornaensis> hey guys what's the best way to implement backtracking
10:00:16 <monochrom> recursion
10:00:24 <marrrk_> The $ is fine. I'm not sure about the composition.
10:00:50 <Hafydd> marrrk_: perhaps you need to note that getPlantPictures con lim off = (getPlantPictures con lim) off.
10:01:16 <marrrk_> yes, I can agree with that
10:01:55 <Hafydd> Then the function takes off, applies (getPlantPictures con lim) to it, then applies fmap (map plantPicturePicture_id) to the result of that.
10:01:59 <marrrk_> function application still has higher precedence than composition right?
10:02:07 <Hafydd> marrrk_: yes.
10:03:11 <marrrk_> let me look a bit further to see whether I see a pattern
10:03:40 * hackagebot vivid 0.2.0.2 - Sound synthesis with SuperCollider  https://hackage.haskell.org/package/vivid-0.2.0.2 (TomMurphy)
10:05:36 <marrrk_> Okay, I would have to think really hard about the input and output of (map plantPicturePicture_id) and (getPlantPictures con lim)
10:14:10 <marrrk_> Okay I think I got it.
10:16:11 <puregreen> air`: if the docs are broken in the package description, you have to reupload the .cabal file
10:16:48 <puregreen> I don't remember how to do it
10:17:43 <puregreen> ... or maybe this is even impossible in general and you can only edit constraints, I'm not sure
10:18:42 <puregreen> yes, you can do thar
10:18:44 <puregreen> * that
10:20:13 <puregreen> air`: http://hackage.haskell.org/package/vivid-0.2.0.2/vivid.cabal/edit
10:25:22 <dimsuz> Hi! I have a DIM2 repa array which represents NxN 2D pixel bitmap (values are colors). I also have a plain list of ps=[(x,y)] coords which I want to turn to black in repa array. I need some kind of 'map setxy_in_repa ps', but can't find anything in repa library to do this... maybe someone here has an advice...
10:25:58 <air``> puregreen: thanks! I'll look into that
10:26:15 <unsorted> Hello everybody. I am new to haskell and will be finishing up fp101x from edx soon and would like to know if anyone has some reccomendations for good learning sources?
10:28:25 <Gurkenglas> dimsuz, is the list already sorted? Is performance important?
10:33:19 <dimsuz> Gurkenglas: 1. no 2. preferably yes (picture will be rendered by gloss each frame), but maybe I could start simple
10:33:47 <scshunt> unsorted: Real World Haskell is a go-to, although it's a bit dated now
10:34:00 <dimsuz> unsorted: I am subscribed to /r/haskell on reddit, from time to time I find very interesting articles there
10:34:35 <Gurkenglas> Weird that its "traverse" doesn't allow you to have applicative side effects
10:35:07 <dimsuz> unsorted: also recently completed "monad-challenges" which really solidified my understanding of monads/applicatives (http://mightybyte.github.io/monad-challenges/)
10:35:53 <dimsuz> Gurkenglas: i'm a bit noob both in haskell and in repa, so I thought I might have missed something obvious...
10:38:02 <unsorted> dimsuz: Thank you!
10:38:16 <Gurkenglas> I'm looking for an effectful version of "map :: (Shape sh, Source r a) => (a -> b) -> Array r sh a -> Array D sh b", something like "traverse :: (Shape sh, Source r a, Applicative f) => (a -> f b) -> Array r sh a -> f (Array D sh b)", that would allow you to, say, use the "State [(X, Y)]" monad to run over the array in order, checking whether the next pixel to set to black is up yet
10:39:03 <mniip> 1458408852 [20:34:12] <Gurkenglas> Weird that its "traverse" doesn't allow you to have applicative side effects
10:39:19 <dimsuz> oh I see. thanks for a direction at least
10:39:19 <mniip> sounds like an unlawful implementation of Traversable?
10:39:36 <Gurkenglas> mniip, it's not implementing Traversable, it just used the "traverse" name
10:39:46 <Gurkenglas> https://hackage.haskell.org/package/repa-3.4.0.2/docs/Data-Array-Repa.html#v:traverse
10:42:41 <Gurkenglas> okay looks like the library repa is based on, vector, is slightly closer to idiomatic Haskell and at least has a function called "imapM" that looks sufficient to the use case
10:46:49 <dimsuz> Gurkenglas: thank you! I will try to find a way to apply imapM to repa types then
10:47:54 <dimsuz> oh, repa has toVector
10:53:21 <Gurkenglas> setToBlack array pixels = let sh = extent array in fromUnboxed sh . (`evalState` sort pixels) . imapM f . toUnboxed $ array where f i = sequenceA $ do upyet <- gets $ (==[i]) . take 1; if upyet then modify tail >> return (const black) else return id -- Of course, this should not be one line, but I started writing in IRC and by the time I'm writing this I'm in too deep :D
10:53:48 <Gurkenglas> (You'll have to replace "black" with however you make a black pixel)
10:54:25 <dimsuz> wow. thank you!
10:54:39 <dimsuz> will study it and adapt
10:54:57 <Gurkenglas> Oh, and your pixels are 2-dimensional coordinates and the vector ints are indices, you'll need some way to convert that
10:55:28 <dimsuz> yes, I already thought about it too. Will need to find out how exactly it will flatten them to vector (in what order)
10:56:44 <Gurkenglas> the sequenceA part was just me being me, you can instead do "f i color = do upyet <- gets $ (==[i]) . take 1; if upyet then modify tail >> return black else return color"
10:57:21 <Jaume_> /msg nickserv GHOST jaume SDKSsgpqGL7YJ3edcKBi
10:57:21 <Jaume_> /msg NickServ Identify jaume SDKSsgpqGL7YJ3edcKBi
10:57:21 <Jaume_> /nick Jaume
10:57:26 <Jaume_> h
10:57:28 <xa0> ahahah
10:57:36 <Jaume_> xD
10:57:43 <int-e> quite the password
10:57:48 <xa0> ^
10:58:00 <Gurkenglas> I'm not sure I like "(==[i]) . take 1", hmmm
10:58:04 <xa0> you're gonna wanna hurry and change that
10:58:19 <dimsuz> :)
10:58:44 <Gurkenglas> In fact, whoever of us is fastest should change it and tell him so nobody eeeevil gets it
11:00:45 <Jaume_> don't worry, don't try to save the world gurkenglas
11:06:43 <Gurkenglas> :t \i -> sequenceA . fmap (fromMaybe id) . runMaybeT $ state (headMay &&& tail) >>= guard . (==i) >> return (const ?black) -- Better, I think?
11:06:45 <lambdabot> (Eq a1, Traversable t, ?black::a, MonadState [a1] t) => Maybe a1 -> a -> t a
11:07:39 <Gurkenglas> :t \i x -> fmap (fromMaybe x) . runMaybeT $ state (headMay &&& tail) >>= guard . (==i) >> return ?black -- oh that still can be done without sequenceA
11:07:40 <lambdabot> (Eq a, ?black::b, MonadState [a] f) => Maybe a -> b -> f b
11:08:08 <Gurkenglas> "fmap (fromMaybe x) . runMaybeT" there should be fromMaybeT for that, I keep needing it
11:08:56 * hackagebot vivid 0.2.0.3 - Sound synthesis with SuperCollider  https://hackage.haskell.org/package/vivid-0.2.0.3 (TomMurphy)
11:11:51 <dimsuz> yeah, looks prettier!
11:13:02 <Gurkenglas> ...its wrong though, i just realized, that'd remove the head from the pixel list even when it wasnt up yet
11:14:14 * hackagebot github-backup 1.20160319 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20160319 (JoeyHess)
11:14:24 <dimsuz> whenever I'll wrap my head around this, I'll fix it. still need some time to dive in, not a pro yet :)
11:16:50 <bstro9000> hey, big time fp newb... what would the following look like in polish notation?  (*) <$> Just 5 <*> Just 3 
11:18:01 <xa0> bstro9000: liftA2 (*) (just 5) (just 3)
11:18:11 <xa0> with capitals obviously
11:18:11 <Gurkenglas> :t \i -> sequenceA . mapStateT (Identity . fromJustNote "<|> return id") . (<|> return id) $ StateT uncons >>= guard . (==i) >> return (const ?black) -- There, this should work. And now I shall tweak my library to make this better
11:18:13 <lambdabot> (Eq a1, Traversable (StateT [a1] Identity), ?black::a) => a1 -> a -> StateT [a1] Identity a
11:18:34 <bstro9000> xa0: thank you. liftA2 somehow combines the <$> and <*> operators, i take it?
11:18:43 <mniip> 'Traversable (StateT [a1] Identity)'
11:18:45 <mniip> why doesn't that reduce
11:18:48 <Iceland_jack> @src liftA2
11:18:49 <lambdabot> liftA2 f a b = f <$> a <*> b
11:18:52 <xa0> bstro9000: yeah
11:18:53 <xa0> ^
11:18:58 <bstro9000> many thanks
11:18:58 <Iceland_jack> @src liftA3
11:18:59 <lambdabot> Source not found. Just try something else.
11:19:01 <Iceland_jack> nvm
11:19:04 <xa0> lol
11:19:20 <Cale> > (<*>) ((<$>) (*) (Just 5)) (Just 3)
11:19:23 <lambdabot>  Just 15
11:19:33 <Cale> If you were asking about the parsing, then it's that ^^
11:20:09 <bstro9000> Cale also helpful! thank you!
11:20:19 <Cale> :t (*) <$> Just 5
11:20:21 <lambdabot> Num a => Maybe (a -> a)
11:20:23 <dimsuz> Gurkenglas: what library are you talking about? :)
11:20:43 <Cale> :t (*) <$> Just 5 <*> Just 3
11:20:45 <lambdabot> Num b => Maybe b
11:20:48 <lf94> \i -> sequenceA . mapStateT (Identity . fromJustNote "<|> return id") . (<|> return id) $ StateT uncons >>= guard . (==i) >> return (const ?black)
11:20:56 <lf94> Did someone honestly write this first try?
11:20:59 <bstro9000> liftA2 means lift applicative with 2 arguments?
11:21:01 <lf94> That's really frickin' impressive.
11:21:17 <lf94> :t <|>
11:21:19 <lambdabot> parse error on input ‘<|>’
11:21:27 <lf94> :t sequenceA
11:21:29 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:21:37 <lf94> :t Applicative
11:21:39 <lambdabot> Not in scope: data constructor ‘Applicative’
11:22:11 <Gurkenglas> dimsuz, http://lpaste.net/150858
11:22:22 <Gurkenglas> not on hackage yet or anything of the sort :P
11:24:11 <xa0> bstro9000: yeah, it's the applicative lift of a bivalent function, where a lift is an fmap
11:24:35 <xa0> lf94: nice
11:24:55 <bstro9000> xa0: Some of those words made sense. Are you saying liftA is to applicatives as fmap is to functors?
11:25:32 <monochrom> bstro9000: liftA2 means you're tired of writing (*) <$> x <*> y so you write liftA2 (*) x y instead. it gets better when you need liftA2 (*) alone without the parameters.
11:25:35 <Gurkenglas> Are conversions between NonEmpty and [] fused?
11:25:46 <xa0> yes, though because they're the same thing (applicatives derive functor) we don't define liftA
11:26:23 <bstro9000> Word. Thanks xa0 && monochrom 
11:26:24 <jle`> liftA is fmap defined using pure and <*>
11:26:37 <jle`> liftA f x = pure f <*> x
11:27:18 <monochrom> liftA actually lives in Control.Applicative
11:27:52 <xa0> oh, there is one? my bad
11:27:52 <jle`> it's useful if you wrote an Applicative instance but are too lazy to write a Functor instance
11:28:06 <jle`> so you can just write instance Functor Foo where fmap = liftA
11:28:20 <monochrom> I think it's there just for consistency and completeness
11:28:33 <xa0> fair enough
11:28:51 <jle`> well, it exists for the same reason that liftM and ap exist
11:29:20 <Gurkenglas> "<jle`> so you can just write instance Functor Foo where fmap = liftA" <- in that case liftA should be hidden and only accessible via a "derive Functor" clause available when you've defined Applicative but not Functor
11:29:25 <jle`> it has a real use case, other han just consistency and completeness
11:29:44 <bstro9000> what is the relationship between liftA and liftM?
11:30:08 <jle`> bstro9000: liftM is fmap defined using return and >>=
11:30:13 <jle`> liftA is fmap defined using pure and <*>
11:30:15 <xa0> liftM requires Monad, which is stricter than Applicative
11:30:19 <xa0> also that
11:30:22 <bstro9000> Oh interesting.
11:30:28 <bstro9000> Are pure and return somehow related?
11:30:35 <jle`> liftM can also be used in the same way, to give yourself a free Functor instance without writing fmap manually
11:30:51 <jle`> Gurkenglas: not sure what you mean there ... should people not be allowed to write instances like that out by hand?
11:30:54 <xa0> pure is return generalised to applicatives
11:31:12 <bstro9000> What a world. Ok. This is really interesting.
11:31:22 <jle`> pure and return should be equal if return exists for a type
11:31:29 <jle`> the reason return exists is mostly for historical/legacy purposes
11:31:32 <Gurkenglas> jle`, they should not have to write these instances out by hand, and at that point keeping liftA around just to allow to do it manually is superfluous :D
11:31:45 <jle`> i mean, people can't write fmap = liftA themselves?
11:32:09 <jle`> `derive Functor` derives functors using algebraic properties of ADT, it doesn't look for a liftA in scope
11:32:18 <Cale> Yeah, if we started over, we'd probably just have return be defined by Applicative, and Monad then would only need (>>=)
11:32:19 <Gurkenglas> (In fact, that derivation should be automatic, then we'd have compatibility with pre-FAM code :D)
11:32:21 <jle`> it feels a bit weird to merge that functionality into deriveFunctor
11:32:32 <Cale> But that still seems a bit off to me
11:32:43 <Cale> Applicative is markedly less important than Functor and Monad are.
11:33:05 <jle`> Gurkenglas: so are you suggesting that DeriveFunctor should just set fmap = liftA when available?
11:33:21 <Cale> (even if it is pretty nice)
11:33:40 <jle`> it is a bit weird
11:34:28 <monochrom> Monad and Functor came about first. Applicative came about later. so there is substantial overlap.
11:35:34 <Zemyla> DeriveFunctor derives it basically the same way Show is derived.
11:35:59 <xa0> i've seen it split even further by defining things that provide ap and pure separately
11:36:07 <mniip> too bad DeriveFunctor doesn't always work
11:36:11 <xa0> iirc that's done in purescript?
11:36:33 <mniip> xa0, you mean like Functor -> Pointed -> Applicative?
11:36:50 <xa0> i've never heard of pointed
11:36:55 <xa0> but presumably
11:37:00 <geekosaur> it's in the typeclassopedia
11:37:01 <monochrom> Pointed is when you have "pure" alone
11:37:22 <geekosaur> it's not actually very useful, the only law you get is its free theorem
11:37:28 <xa0> i think it went the other way around
11:37:42 <xa0> Functor -> Apply -> Applicative
11:37:50 <xa0> where Apply provides ap
11:37:59 <Gurkenglas> There should be instance Alt Identity where (<!>) = const
11:38:07 <Zemyla> Also, Functor -> Pointed -> Applicative.
11:41:14 <Zemyla> But then again, the reason why Pointed is used much less than Apply is the same reason why a typeclass that only provides mempty would be much less useful than Semigroup.
11:42:32 <xa0> ah yeah, found it http://hackage.haskell.org/package/semigroupoids-5.0.1/docs/Data-Functor-Apply.html#g:2
11:51:45 <nineonine> aeson question: if some fields have arrays, which option is better - going with Data.Aeson.Array or Data.List ?
11:53:31 <monochrom> that Array is Vector from the "vector" library.
11:53:35 <dmj`> nineonine: depends on your application, you're choosing between a packed representation, namely vector which gives you constant random access, or a linked list. Both get turned into a json array at the end of the day... afaik
11:54:37 <monochrom> if you find Vector operations that solve your problem nicely, keep it as Vector. if you find [] operations that solve your problem nicely, turn it into [].
11:54:47 <nineonine> im just making an api wrapper. for me efficient access is not a priority
11:54:55 <nineonine> i think list will suffice then
11:55:16 <nineonine> thanks !
11:55:18 <monochrom> ("nicely" means a balance between elegance code and efficiency. where is the balance point? you decide.)
11:56:01 <nineonine> monochrom: loving the last comment :3
11:56:59 <Gurkenglas> "[a] -> a -> NonEmpty a", pls. By concatenation in that order.
11:58:51 <xa0> :t flip (:|)
11:58:52 <lambdabot>     Not in scope: data constructor ‘:|’
11:58:53 <lambdabot>     Perhaps you meant one of these:
11:58:53 <lambdabot>       ‘NE.:|’ (imported from Data.List.NonEmpty),
11:59:02 <monochrom> Gurkenglas, you may have better luck saying those comments to the libraries mailing list than to here, which is barely better than talking to the dinner table.
11:59:08 <xa0> :t flip NE.(:|)
11:59:10 <lambdabot> Not in scope: data constructor ‘NE’
11:59:10 <lambdabot>     Not in scope: data constructor ‘:|’
11:59:10 <lambdabot>     Perhaps you meant one of these:
11:59:14 <xa0> :t flip (NE.:|)
11:59:16 <lambdabot> [a] -> a -> NE.NonEmpty a
11:59:23 <mniip> that's not it
11:59:26 <xa0> oh
11:59:34 <xa0> ah!
11:59:36 <xa0> my bad
12:00:30 <mniip> :t \xs x -> foldr NE.cons (x NE.:| []) xs
12:00:33 <lambdabot> Foldable t => t a -> a -> NE.NonEmpty a
12:02:32 <Gurkenglas> monochrom, http://lesswrong.com/lw/f1/beware_trivial_inconveniences/ . Maybe we should have a prefix that people can put at the front of their line in IRC, and then monthly (?) those lines are collected and posted to the mailing list? Or would a post to the mailing list need more arguments?
12:04:10 <puregreen> Gurkenglas: you probably won't be able to get anyone use that prefix
12:04:54 <Gurkenglas> enough if i use it, i make lots of suggestions, we'd just need someone to compile them into a mail :P
12:05:08 <monochrom> I predict that you will be the only one. so you may as well mail yourself to the mailing list directly.
12:06:02 <Gurkenglas> I'd call it... shyness? Is there a sort of etiquette to posting to it?
12:06:05 <monochrom> similarly you may try to invent a voice recorder to be installed at your dinner table that makes monthly phone calls to your local politician
12:07:20 <puregreen> Gurkenglas: proposals on the libraries@ mailing list usually require a) a clearly stated proposal, b) a list of pros/cons, and c) a limit on discussion time, and d) I probably forgot something
12:08:23 <puregreen> Gurkenglas: since a compilation of “what people on #haskell thought could be nice to have” looks very differently from a usual libraries@ message, you're just moving the shyness from the person who proposes things on the person who would have to set up automatic posting to libraries@
12:08:59 <puregreen> perhaps posting on r/haskell and letting people there decide what is good enough to be posted to libraries@ manually is a better idea
12:09:30 <Gurkenglas> "moving the shyness" - right, I thought maybe someone from the #haskell channel is brave enough to step forward.
12:10:00 <monochrom> I am certainly brave enough to step forward for my ideas.
12:10:20 <monochrom> but your ideas are your responsibility, not mine.
12:11:59 <puregreen> Gurkenglas: a better idea still could be making an unofficial bug tracker for Haskell (sort of like https://github.com/isaacs/github for Github), where you would have to work on cultivating the right attitude from the start
12:12:21 <puregreen> (where “the right attitude” means “anyone post here any ideas no matter how much half-baked and stuff”)
12:12:42 <puregreen> it would still need someone to choose good ones and post to libraries@, but that's actually the easiest part
12:14:34 <ph88> jle` are you here ?
12:18:42 <ph88> hello
12:20:17 <Iceland_jack> hi ph88
12:20:48 <puregreen> Gurkenglas: a-a-and done
12:20:51 <puregreen> https://github.com/aelve/haskell-issues/
12:21:00 <Gurkenglas> :D
12:21:18 <puregreen> now I hope you won't be shy enough to be author of issue #1
12:21:45 <puregreen> * the author
12:22:23 <Cale> puregreen: Are you offering to fix all the issues that people post there?
12:22:28 <Cale> lol
12:22:53 <puregreen> Cale: nope :)
12:23:08 <puregreen> I'm offering to google for them and occasionally post issues to proper places for them
12:25:41 <puregreen> e.g. it'd be really nice if there was something like a list of popular cabal-install ideas (like “cabal upload docs”) that everyone has once in a while
12:26:51 <monochrom> the cabal github takes feature requests
12:27:10 <Gurkenglas> Let me just look through the irc logs for me saying "should"
12:27:50 <mniip> 20160319.log:[19:26:48] <Gurkenglas> Let me just look through the irc logs for me saying "should"
12:28:07 <Gurkenglas> index only updates once per day.
12:28:43 <puregreen> monochrom: a while ago I wanted to fork cabal-install and implement “cabal upload docs”. Three hours later I found out that there already was an issue dealing with that, buried among issues like “description of the --package-db flag is lacking” and so on
12:29:24 <ph88> hi Iceland_jack 
12:29:39 <puregreen> monochrom: a publicly available issue tracker is very much not a replacement for a manually curated list of common issues/ideas/etc 
12:29:54 <mniip> 20150423.log:[22:34:06] <Gurkenglas> Don't forget people of the distant future browsing the log. Why should Foldable have no law like fold preserving equality?
12:29:55 <mniip> heh
12:29:57 <ph88> hey guys, does anyone know if i have a function that returns a Parser how can i make that Parser into it's own source code ?
12:38:27 <Cale> ph88: I'm not sure what you mean
12:39:17 * hackagebot happstack-authenticate 2.3.4.1 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.1 (JeremyShaw)
12:39:59 <Cale> ph88: You presumably can't factor it out as a constant, because it probably depends on the function parameter.
12:40:07 <ph88> Cale, i would like to make a parser (binary executable) without writing the source code for it myself
12:40:20 <Cale> uhhhh
12:40:23 <Cale> Wait, what?
12:40:35 <mniip> what
12:40:41 <Cale> You said you have a function which returns a Parser
12:40:50 <ph88> eh, hold on :P lets about XY here :P
12:41:46 <ph88> 1. i would like to write a program that reads a grammar (perhaps i end up having a grammar tree) 2. i would like a program that generates a parser for this grammar 3. i would like to compile this parser so i have a binary dedicated to this grammar
12:41:46 <mniip> Cale, I think I see what they meant but that's a raelly odd way to formulate it
12:41:55 <mniip> yeah
12:42:41 <Cale> ph88: Sounds like Happy, plus some code which does something trivial at the end.
12:42:42 <mniip> ph88, generating executable is a hard task
12:42:48 <mniip> do you want an interpreter instead?
12:42:57 <mniip> something that would first read in the grammar and then the text to be parsed
12:43:01 <Cale> Happy is a parser generator for Haskell
12:43:25 <Cale> But what will the resulting executable program *do*?
12:43:44 <Cale> Just parse the input and terminate with an exit code depending on whether the parse was successful?
12:43:58 <Cale> Presumably you want to do more output than that, but what do you want to produce?
12:45:06 <ph88> Cale, i read happy can only read grammars in BNF .. but the grammar i want to read is not in BNF
12:45:13 <Cale> You could construct an abstract syntax tree, and then 'print' it. But then you'd presumably need to parse *that* (even if it only means applying 'read') in order to do anything useful with it.
12:45:34 <ph88> mniip, no that's precisily what i don't want .. first having to read the grammar
12:45:57 <ph88> 1. read grammar 2. compile to dedicated binary for that grammar 3. now use binary to parse text
12:46:14 <Cale> ph88: But the dedicated binary, what does it do?
12:46:18 <mniip> yacc-style?
12:46:28 <mniip> you want to emit haskell code for your parser?
12:46:42 <ph88> Cale, ah yes you are right of course ! the end program does need to do something other than just parse the input string .. i should have mentioned that
12:47:33 <ph88> maybe i can generate haskell source code that describes a parser combinator that i can then use in a program ?
12:47:46 <Cale> ph88: There are good technical reasons for Happy taking its input in the form that it has. If you want to parse other sorts of grammars, you'll have to accept some pretty severe drops in performance.
12:48:13 <Cale> (In the most general case, it might become undecidable whether a given string belongs to the language described by a grammar)
12:49:33 <ph88> what if i can generate attoparsec source code .. with that source code there won't be any performance drop right ?
12:50:01 <Cale> Well, sure, but attoparsec isn't immediately capable of parsing an arbitrary unrestricted grammar
12:51:22 <Cale> You'll have similar restrictions as Happy has.
12:51:45 <Cale> (though perhaps technically a bit different in terms of the type of lookahead allowed)
12:52:42 <ph88> Cale, i will assume that the grammar will be able to be expressed as parser combinator ^^
12:53:02 <Cale> Yeah, so probably it'll be LL[k] or something.
12:53:11 <ph88> ye something like that i guess
12:53:18 <orion> I am having difficulty making a solution to this problem: Given a datatype Comment which has a record field "cparent" and a [(Comment, [ChildrenIds])], how do I transform it to [Comment] such that the cparent value for every Comment points to its parent, given the ChildrenIds?
12:53:27 <ph88> anyway after i parsed the grammar itself .. how can i generate a dedicated parser for it ?
12:53:46 <Cale> ph88: I dunno, you want to write Haskell source code?
12:53:55 <Cale> ph88: Perhaps use haskell-src-exts?
12:54:27 <ph88> yes it would be a way to do it
12:54:36 <Cale> ph88: I'm not entirely certain why you'd want to do this rather than just using attoparsec directly.
12:55:04 <ph88> so i could do: 1. parse the grammar file 2. get grammar tree 3. output haskell parser (dedicated for that grammar) 4. now use the source code in another program
12:55:30 <ph88> because there are a lot of grammars .. once i can translate the grammars automatically i won't have to craft a parser by hand for each grammar
12:55:48 <ph88> you understand what i would like to do now ?
12:55:55 <Cale> Why not just write a function which parses the grammar and produces an attoparsec Parser?
12:55:59 <Cale> and then just use that?
12:56:54 <Cale> I mean, yes, there's some amount of work involved in applying that function, but it's constant in the eventual size of the input.
12:57:01 <ph88> because i would have to read the original grammar file each time i want to use the parser
12:57:15 <Cale> You can just bake the grammar into the code
12:57:31 <ph88> you mean the actual textual file as string ?
12:57:41 <Cale> http://hackage.haskell.org/package/file-embed
12:57:47 <ph88> yes right :P
12:58:08 <ph88> ideally i don't parse the original grammar each time i want to parse some text
12:58:18 <Cale> Of course, there's a middle ground here
12:58:20 <ph88> but it would be a very workable intermediate solution ^^
12:58:24 <Cale> You could use TH
12:58:44 <Cale> and turn the grammar into attoparsec-using code with TH at compile time
12:58:47 <ph88> what are the trade-offs between using haskell-src-exts or template haskell ?
12:59:46 <Cale> Well, haskell-src-exts will get you a separate bunch of source code when you run the program.
12:59:57 <Cale> which will then have to be compiled as an extra step
13:00:19 <Cale> Template Haskell will just immediately run as you compile, producing code that becomes part of the program you're compiling.
13:00:42 <ph88> so i'm writing code that will be executed at compile time ?
13:00:46 <Cale> yeah
13:01:00 <ph88> ok i understand what each is .. just what are the tradeoffs between them ?
13:01:05 <ph88> both seem workable
13:01:30 <ph88> maybe in term of how easy it would be to write and read and maintain such source code
13:01:35 <Cale> Well, haskell-src-exts is maintained separately from GHC
13:01:52 <Cale> Both are going to be ugly
13:02:24 <Cale> Personally, I would prefer the file-embed route if I was going to have to maintain it :P
13:02:32 <ph88> right :P
13:02:41 <ph88> i think realistically i would have to start with that anyway
13:02:48 <ph88> i just would like to know my options down the road
13:03:47 <ph88> maybe if i first to the file-embed ... read the grammar ... and return a Parser (all at runtime)  .. once i have that. Would it be easier from there to move into TH or haskell-src-exts ?
13:08:47 <ph88> Cale ?
13:11:43 <ph88> Cale, sorry i got disconnected .. i think i might have missed a few lines
13:12:23 <ph88> last i saw: [21:02:01] <Cale> Personally, I would prefer the file-embed route if I was going to have to maintain it :P
13:14:18 * hackagebot diagrams-builder 0.7.2.3 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.7.2.3 (bergey)
13:14:28 <scshunt> why is there no documentation for transformers on hackage?
13:15:39 <puregreen> scshunt: it hasn't built yet
13:19:27 <Cale> ph88: It would be just about the same -- you'd have to write code which writes the code for the parser you wrote instead.
13:19:35 <Cale> (in either case)
13:19:35 <Zemyla> Hmm, there's a way to reify Integers to Nats, but is there a way to reify constraints on them, like for an Integer n >= 5, could you somehow produce a Proxy (p :: Nat) such that not only is KnownNat p, but also 5 <= p?
13:19:51 <Cale> Maybe in the case of TH, you'd have the option of using some expression quotes, which would be a little nicer
13:20:10 <parsecChar> with current haskell extensions, is it possible to say "dotProduct :: forall n, [Int of length n] -> [Int of length n] -> [Int of length n] ?
13:20:33 <ph88> ok thanks very much Cale 
13:21:15 <Cale> parsecChar: If I understand what you mean and you want to constrain the length of the list and not the length of the Int, yes.
13:21:23 <parsecChar> Cale: yes
13:21:31 <Cale> Well, "yes"
13:21:32 <parsecChar> Cale: I want to say it's do product, it multiples two lists of length n
13:21:35 <parsecChar> and gets another list of length n
13:21:41 <parsecChar> okay, can you point me at the extension + a tutorial for doing this?
13:21:52 <Cale> parsecChar: Though, that's not what a dot product does.
13:22:07 <parsecChar> oh sorry, I meant "vectorAdd"
13:22:17 <Cale> and I would have huge reservations about actually using the techniques involved, because they only get you so far
13:22:20 <parsecChar> I have no idea what I was thinking
13:22:33 <parsecChar> well let me know how to shoot my own leg, and I'll decide if I want to actually do it
13:22:38 <Cale> Pretty soon, you might want to have types of functions which compute something involving the indices
13:22:52 <parsecChar> and I'll end up using Agda/Coq
13:22:55 <parsecChar> or Idris
13:22:57 <Cale> e.g. a function for appending lists would have to sum the lengths
13:23:04 <Cale> and then you get into all sorts of hair-pulling
13:23:13 <Cale> because it kind of sort of works, but not quite
13:23:28 <Cale> and it's generally going to be infuriating :P
13:23:44 <scshunt> puregreen: it's been like this for weeks
13:23:59 <Cale> So it's like "yes", but from a practical standpoint, "no"
13:25:21 <puregreen> scshunt: well, look at the previous version
13:25:22 <puregreen> https://hackage.haskell.org/package/transformers-0.5.1.0
13:25:39 <puregreen> uploaded— no, wait, that was only 3 days
13:25:47 <puregreen> nevermind
13:26:38 <xa0> > succ True
13:26:40 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
13:26:46 <Cale> parsecChar: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-level-literals.html
13:26:52 <xa0> > succ False
13:26:53 <lambdabot>  True
13:27:01 <Cale> parsecChar: See also DataKinds
13:27:26 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
13:27:52 <Cale> (in fact, that last link includes another way to do it, without type level literals
13:27:54 <Cale> )
13:31:25 <scshunt> puregreen: sure
13:31:27 <nitrix> @let succCycle x = (enumFrom x ++ [minBound]) !! 1
13:31:30 <lambdabot>  Defined.
13:31:31 <scshunt> puregreen: but 0.5.2.0 has been up for over a month
13:31:36 <nitrix> > succCycle True
13:31:37 <scshunt> docs should be done by now!
13:31:40 <lambdabot>  mueval-core: Time limit exceeded
13:31:42 <nitrix> > succCycle False
13:31:46 <lambdabot>  True
13:31:49 <nitrix> > succCycle True
13:31:51 <lambdabot>  False
13:31:54 <scshunt> see, lambdabot agrees with me
13:31:58 <nitrix> xa0: how it helps :D
13:32:01 <nitrix> *hope
13:32:18 <puregreen> scshunt: I thought that 0.5.1.0 had its docs built after ~1 month but it turned out that I misread the “Uploaded” field
13:35:28 <numee> does anyone know how to get ghc infer types for this code? http://pastebin.com/3ugXE8Wx
13:36:43 <Iceland_jack> numee: try
13:36:43 <Iceland_jack>     instance (() ~ ty) => IsString (IO ty) where
13:37:35 <rotty> what's up with hackage docs? some are (intermittently?) missing, e.g, https://hackage.haskell.org/package/transformers
13:37:57 <Sornaensis> Iceland_jack: neat
13:38:29 <Zemyla> numee: There's a way to do it in Haskell 98 as well.
13:38:53 <numee> Iceland_jack: oh it worked like a charm, thanks! but how does it work? i thought it was hopeless because of the open-world assumption
13:39:17 <Iceland_jack> numee: It matches against the head first (IO _) and then attempts to solve the constraints
13:40:42 <Zemyla> You want class IsUnit a where { fromUnit :: f () -> f a; toUnit :: f a -> f () }; instance IsUnit () where { fromUnit = id; toUnit = id }; instance (IsUnit ty) => IsString (IO ty) where fromString str = fromUnit . putStrLn;
13:41:52 <Zemyla> Basically, a type equality can be represented as a function of type forall f. f a -> f b.
13:45:30 <eyepatch_> This seems to closely match the examples I've read, but it still doesn't work, and I don't understand why. https://ideone.com/1lTjU7
13:45:56 <eyepatch_> Note that only the first four lines aren't commented out.
13:49:05 <a3gis> Hello! I have an algorithmic question regarding unification; would anyone have basic knowledge of how it works to discuss it? I'm not posting it right up since it's not really the topic of the channel :)
13:49:10 <numee> Iceland_jack, Zemyla: it seems like i don't know what i need to know in order to understand them. maybe i should start reading TaPL ...?
13:49:41 <Iceland_jack> numee: It's not deep, it's more of a type system hack
13:49:43 <Iceland_jack> wait a bit
13:49:46 <triliyn> eyepatch_: variable names can't begin with an uppercase letter
13:50:01 <Iceland_jack> numee: https://www.reddit.com/r/haskelltil/comments/3bc73n/xpost_rhaskell_the_constraint_trick_for_instances/
13:50:13 <eyepatch_> duh... I should have remembered that.
13:50:16 <triliyn> That's reserved for type and data constructors
13:50:41 <xa0> nitrix: haha, i was just messing about. but nicely done :D
13:52:20 <nitrix> Could also be written succCycle = (: mindBound) . enumFrom
13:52:22 <nitrix> I think :/
13:52:54 <fluvian> Is there a Set data structure which implements Generic?
13:53:00 <numee> Iceland_jack: thank you for giving me a pointer. i'm going to read the article
13:53:05 <nitrix> > let succCycle' = (: minBound) . enumFrom in succCycle' False
13:53:07 <lambdabot>      No instance for (Bounded [[Bool]])
13:53:07 <lambdabot>        arising from a use of ‘succCycle'’
13:53:07 <lambdabot>      In the expression: succCycle' False
13:53:10 <nitrix> Ouch.
13:53:27 <fluvian> I'd like to build a hash-table using Sets as keys.
13:54:44 <nitrix> fluvian: Ord a => Ord (Set a)
13:54:45 <acertain> https://hackage.haskell.org/package/unordered-containers-0.2.7.0/docs/Data-HashSet.html implements Hashable
13:55:25 <fluvian> nitrix: does `Ord a` imply `Generic a`?
13:56:02 <nitrix> If Ord implies Generic? What ._.
13:56:34 <byorgey> fluvian: no, it doesn't
13:56:37 <fluvian> acertain: Thanks, exactly what I needed!
14:09:25 <brian_> What's a good place to post haskell snippets for sharing on this IRC?
14:09:31 <Iceland_jack> @where lpaste
14:09:31 <lambdabot> http://lpaste.net/
14:09:35 <brian_> thx
14:14:20 * hackagebot network-uri 2.6.1.0 - URI manipulation  https://hackage.haskell.org/package/network-uri-2.6.1.0 (EzraCooper)
14:39:21 * hackagebot texmath 0.8.5 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.5 (JohnMacFarlane)
14:41:03 <cbopt> Hi! I was wondering if there is a CoreNLP implementation for Haskell. I'm looking for something like "processors" which is a library made for Scala.
14:54:21 * hackagebot pandoc-citeproc 0.9.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.9.1 (JohnMacFarlane)
14:54:56 <zugzwanged> should instances of Data.Binary.Binary derived using DeriveGeneric be considered stable, or is it likely that the derived instance will change in future versions of ghc?
14:59:21 * hackagebot pandoc-citeproc 0.9.1.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.9.1.1 (JohnMacFarlane)
15:04:21 * hackagebot cipher-rc5 0.1.0.2 - Pure RC5 implementation  https://hackage.haskell.org/package/cipher-rc5-0.1.0.2 (FinnEspenGundersen)
15:04:45 <nolraiU> So ghc is telling me to use "MultiParamTypeClasses" even though I already have it in my LANGUAGE pragma?
15:05:08 <nolraiU> Anyone have a clue whats going on?
15:07:50 <monochrom> how do I reproduce it?
15:09:29 <nolraiU> Well I can investigate, was hoping it was a known issue.
15:10:58 <monochrom> approximately the only guess I make is "typo".
15:11:51 <monochrom> but I positively want to distant myself from spin doctors, and identify myself with scientists.
15:12:09 <monochrom> this means I want to talk about reproducible experiments not telepathic guesses.
15:12:13 <nolraiU> I don't really need the class..on the other hand weirdness with ghc is probably more important then what I am working on..hmm.
15:12:37 <nolraiU> Hah. Yeah, I was being overly..something.
15:20:55 <zardozb> where do you guy download pirated version of photoshop? looking through torrents but they are all cracked and tempered with instead of having a keygen that works with files from adobe site, which is what i prefer
15:20:58 <zardozb> guys*
15:21:25 <puregreen> zardozb: wrong channel
15:21:31 <hpc> this is not even remotely the right channel
15:22:04 <zardozb> you're right.. my bad. still, a lot of people in here, so if someone wants to help feel free to PM me :P
15:22:19 <xa0> wow
15:22:36 <xa0> just wow
15:22:58 * zardozb throws a monad at xa0
15:23:29 <xa0> the warez monad?
15:23:46 <zardozb> could be
15:24:29 --- mode: ChanServ set +o shapr
15:24:36 <shapr> zardozb: do you want to learn Haskell?
15:24:51 <shapr> zardozb: I can offer you a FREE copy of GHC, the best Haskell compiler!
15:25:35 <shapr> zardozb: there's a really great Haskell User's Group in Boston, you might enjoy it.
15:25:58 <orion> shapr: Where?
15:26:14 <shapr> orion: the user's group or the copy of GHC?
15:26:25 <orion> The former.
15:26:47 <shapr> orion: lately I've been using http://docs.haskellstack.org/en/stable/README/
15:26:57 <shapr> orion: are you learning Haskell?
15:27:11 <orion> I said the former, not the latter.
15:27:13 --- kick: zardozb was kicked by shapr (Kicked by shapr)
15:27:30 --- kick: zardozb was kicked by shapr (Kicked by shapr)
15:28:06 <shapr> orion: perhaps https://www.haskell.org/downloads#minimal ?
15:28:30 <mauke> shapr: what does that have to do with boston?
15:28:41 <zardozb> shapr did you know that moralistic fuckheads like you are 50% more likely to molest and murder children?
15:28:43 --- kick: zardozb was kicked by shapr (Kicked by shapr)
15:28:54 <shapr> this is fun.
15:28:59 <shapr> but probably not constructive
15:28:59 <Rotaerk> can't you just ban?
15:29:05 <shapr> yeah, I could
15:29:16 --- mode: ChanServ set +o mauke
15:29:16 --- mode: mauke set +b *!*@static-71-174-73-11.bstnma.fios.verizon.net
15:29:18 --- kick: zardozb was kicked by shapr (Kicked by shapr)
15:29:21 * shapr grins
15:29:24 <shapr> mauke: thanks
15:29:35 <Rotaerk> weebles wobble but they don't fall down
15:29:59 <puregreen> what's the standard name for “Maybe b -> MaybeT m b”? I found hoistMaybe, but it feels like there was something simpler
15:30:01 <shapr> orion: Are you learning Haskell?
15:30:18 <orion> I'm always learning Haskell.
15:30:29 <shapr> me too, have you learned anything interesting lately?
15:30:39 <orion> Free Monads
15:31:11 <shapr> neat, I've been learning about the OverloadedStrings pragma for ByteString and Data.Text
15:31:16 --- mode: mauke set -o mauke
15:31:23 --- mode: shapr set -o shapr
15:32:06 <shapr> orion: is there a good intro to free monads?
15:32:34 <orion> No.
15:32:39 <shapr> oh, too bad
15:32:40 <xa0> haha
15:32:44 <shapr> orion: want to write one?
15:33:00 <xa0> or can you summarise them, at least?
15:33:01 <orion> I'm not qualified.
15:33:14 <mauke> https://github.com/mauke/poly.poly/blob/master/poly.poly#L76-L87
15:33:16 <shapr> perhaps if you started an intro, others would contribute?
15:33:58 <shapr> I've had success with that in the past.
15:34:03 <orion> I don't want people's contributions to be a bunch of reasons why I'm subtly wrong.
15:34:19 <shapr> maybe their contributions could be why you're subtly right instead?
15:34:51 <puregreen> orion: you've got a priceless opportunity to write an intro that would be good for beginners (since you have learned free monads recently and so you still remember what was unclear to you)
15:35:00 <zugzwanged> puregreen: MaybeT . return?
15:35:15 <puregreen> zugzwanged: yeah, but that's cumbersome, so nah
15:36:21 <orion> puregreen: I don't think you understand how my mind works. I have a phobia of teaching people wrong information.
15:36:34 <orion> So, I never open my mouth unless I am sure I am right.
15:36:37 <shapr> perhaps you could instead compile a list of resources you used to learn free monads?
15:36:51 <puregreen> orion: ah, okay then, nevermind
15:37:17 <zugzwanged> puregreen: I see I've defined "liftMaybe = MaybeT . return" in a util library before, so I guess I couldn't find it in standard libs
15:44:26 <ph88> anyone know the license for stuff posted on https://www.schoolofhaskell.com ?
15:45:50 <puregreen> ph88: I think it's https://www.fpcomplete.com/business/terms-of-use/
15:46:06 <ph88> oki
15:46:09 <puregreen> judging by https://www.fpcomplete.com/blog/2015/05/school-of-haskell-2
15:46:17 <demize> There's no license.
15:46:22 <demize> All content is copyrighted.
15:46:38 <ph88> they open sourced stuff though 
15:46:46 <ph88> https://github.com/fpco/schoolofhaskell
15:48:05 <demize> Ah, seems the ToU essentially say that you grant FPComplete a license to do whatever they want with it, and license non-code to others under CC, and code under BSD-3.
15:49:01 <ph88> eh ok
15:49:05 <ph88> so blog posts are CC ?
16:02:14 <macalimlim> any haskell developers here from the philippines?
16:13:10 <parsecChar> i have my own code for generating a string representing an svg element. Is there a nice way to just dump that file right into lucid ?
16:14:29 <puregreen> parsecChar: I think you'll have to construct HtmlT manually
16:15:46 <parsecChar> is there a nice function for String -> HtmlT ?
16:15:52 <puregreen> toHtml
16:15:55 <puregreen> no
16:15:58 <puregreen> toHtmlRaw
16:16:24 <puregreen> just in case: you've seen lucid-svg, right?
16:16:28 <puregreen> @hackage lucid-svg
16:16:28 <lambdabot> http://hackage.haskell.org/package/lucid-svg
16:16:30 <parsecChar> oh, there's quite a few in https://hackage.haskell.org/package/lucid-2.9.5/src/src/Lucid/Base.hs
16:17:31 <puregreen> if your SVG is a ByteString, then you can use toHtmlRaw as well, by the way
16:18:16 <parsecChar> hmm
16:18:20 <parsecChar> I think I'm just going to use lucid-svg instead
16:19:07 <orion> Anyone know how to make this code more elegant? I feel like I am doing this in the absolute worst way: http://lpaste.net/6368747312335814656
16:19:18 <parsecChar> I'm not going to be afraid of AlphaGo until it can suggest stuff I didn't even think to ask
16:19:28 <orion> My goal is to rewrite f.
16:20:00 <parsecChar> perhaps use 'let'
16:20:03 <parsecChar> to make it not be one long line ?
16:20:04 <reygoch> Hi
16:20:13 <parsecChar> I have trouble keeping track of what's going on
16:20:38 <reygoch> Is anyone here perhaps using Haskell on Windows?
16:21:06 <orion> Essentially, I have a list of children for a Comment, and the Comments themselves are only capable of knowing who their parent is. So my goal is to go through the HashMap and assign parents to children.
16:22:23 <orion> I feel like "there has got to be a better way"
16:22:51 <reygoch> for what?
16:23:04 <orion> reygoch: http://lpaste.net/6368747312335814656
16:24:00 <reygoch> seems decent to me.
16:24:25 <reygoch> I'd just break that long where expression into several lines
16:24:52 <reygoch> does anyone have any experience with haskell on windows?
16:25:19 <reygoch> I made a switch recently and I have no idea what I'm doing
16:25:34 <reygoch> I can't get yi to work and I can't get mysql to work
16:25:38 <reygoch> and I want to cry
16:28:18 <reygoch> can anyone help with setting up mysql on windows?
16:29:45 <parsecChar> what is the point of 'with' in lucid? http://chrisdone.com/posts/lucid2
16:30:15 <drk_lrd_777_> mysql setup in windows was pretty straight forward as far as i recall...
16:30:30 <drk_lrd_777_> what seems to be the problem?
16:31:39 <reygoch> I can't install pcre
16:32:28 <reygoch> And install can't find mysql_config
16:32:53 <reygoch> I just uninstaled msys2 because I made a mess :D
16:42:02 <lpaste> scshunt pasted “Ugh” at http://lpaste.net/155388
16:42:50 <lpaste> scshunt revised “Ugh”: “No title” at http://lpaste.net/155388
16:42:57 <scshunt> ^
16:43:05 <scshunt> Anyone able to explain this error?
16:43:20 <scshunt> if I write FocusFree so that it doesn't take m as a parameter, it works
16:43:27 <scshunt> I can't understand why that matters
16:44:45 <scshunt> I'm guessing it's running into an error constructing the type signature for zoom [LensLike' (Zoomed m c) t s -> m c -> n c] but can't see why this would be
16:45:21 <johnw> term
16:45:26 <scshunt> johnw: ?
16:45:35 <johnw> sorry, app disappear and focus shifted to this window before I releazide it
16:46:15 <Cale> Prelude Data.Aeson> encode (Just Nothing :: Maybe (Maybe Integer))
16:46:16 <Cale> "null"
16:46:16 <Cale> Prelude Data.Aeson> encode (Nothing :: Maybe (Maybe Integer))
16:46:16 <Cale> "null"
16:46:28 <Cale> I am so tilted right now
16:46:33 <Cale> this just cost me hours
16:46:46 <Cale> WHY AESON PLS
16:47:12 <geekosaur> doesn't aeson still have that thing where it thinks a top level needs to be a container (array or dictionary)?
16:47:20 <puregreen> it doesn't
16:47:48 <reygoch> anyone on windows right now?
16:48:05 <bergey> Looks like a typical JS API to me :\
16:48:07 <Cale> Even so, that instance is screwed up -- Nothing and Just Nothing are *very* different values.
16:48:23 <reygoch> I'm having trouble with installing mysql-simple
16:48:44 <geekosaur> other than that I'd guess there's no sensible way to encode a Maybe other than null, so no way to distinguish those two
16:48:57 <Cale> There are plenty of other sensible things to do
16:49:00 <puregreen> geekosaur: could be [x] vs []
16:49:14 <Cale> If it had the TH-written instance, it would be just fine.
16:49:19 <geekosaur> depends on what it needs to interop with
16:49:32 <geekosaur> which is the real problem, JSON's not designed for *Haskell* values
16:49:33 <Cale> We're talking about the default instance for Maybe
16:50:20 <Cale> Prelude Data.Aeson> encode (Right Nothing :: Either String (Maybe Integer))
16:50:20 <reygoch> so... noone on windows right now?
16:50:20 <Cale> "{\"right\":null}"
16:51:06 <scshunt> Cale: ugh, that's awful
16:51:23 <geekosaur> right, aeson treats Maybe as "nullable" because that's maximal interoperability with js. I could imagine a "preserve Haskell values" mode but itd need to be flagged "will not interoperate with most javascript api endpoints"
16:51:34 <scshunt> any chance you want to take a break and look at my code? ;)
16:52:03 <reygoch> give it :D
16:52:05 * puregreen opens an issue about changing the instance for Maybe in nir Aeson fork
16:52:10 <geekosaur> ...alternately "use something sane if you're ging haskell-to-haskell, this stuff is for js's buggy "type" system"
16:53:05 <reygoch> can anyone give me a little help with mysql-simple on windows?
16:53:39 <reygoch> am I visible here?
16:54:03 <reygoch> anyone?
16:54:08 <Cale> geekosaur: Honestly I think it's just Aeson's fault here. JSON is fine here.
16:54:32 <Cale> geekosaur: For now, I'll just use Either () as a substitute for Maybe, and everything will be okay
16:54:38 <reygoch> seriousl, can I get some response?
16:54:45 <puregreen> reygoch: I see you
16:54:46 <Cale> reygoch: I'm not on windows....
16:54:50 <scshunt> yeah, this is Aeson's fault
16:54:52 <reygoch> oh
16:54:57 <reygoch> :D
16:55:18 <reygoch> I had to switch recently so everything is new. I wasn't sure if this was some kind of bug.
16:55:19 <scshunt> but it's sort of obvious why it happens when you think about it
16:55:21 <Cale> reygoch: If you have a specific question, it's probably best just to ask about it directly
16:55:32 <puregreen> geekosaur: it kinda happens that we have only one JSON library, but it has to serve several different goals – a) interop with web/Javascript/other languages, and b) using JSON as a data format that everyone else (possibly even humans!) can read if they *want* to (but not trying to make it easy for them)
16:56:07 <puregreen> and I imagine it's not easy to design something that would satisfy everybody
16:57:32 <reygoch> does anyone know how to set up mysql-simple on windows?
16:59:40 <Cale> Aeson normally serves all these purposes just fine. The FromJSON and ToJSON instances just provide a *default* parser and prettyprinter to use when you don't want to worry about the precise encoding for the type. The fact that the default here skips having an explicit tag for Nothing/Just and thereby crushes Just Nothing and Nothing to the same representation is a pretty poor default.
17:00:18 <Cale> reygoch: Well... what happens when you cabal-install it?
17:01:44 <reygoch> it can't configure pcre-light 
17:02:01 <Cale> hmm
17:02:04 <reygoch> and pcre light cant install because it can't find pcre libs on my pc
17:02:09 <Cale> https://github.com/bos/mysql/issues/3 -- see also, there's apparently this problem
17:02:44 <reygoch> ye, I tried that
17:02:50 <reygoch> but it doesn't work
17:02:54 <Cale> Everything is tricky on windows when it comes to stuff that involves library bindings, because a lot of stuff simply doesn't exist.
17:03:28 <reygoch> I know... tired it with msys2 but with no success
17:03:53 <reygoch> but damn, postgre-simple installed flawlessly
17:05:47 <macalimlim> is there a way to build windows binaries from linux?
17:06:45 <reygoch> I don't think so
17:07:09 <reygoch> unless you use wine :D
17:07:31 <reygoch> actually, I don't think even that would work
17:08:19 <MichaelBurge> macalimlim: The term for that is 'cross compiler'. I think GHC supports it, but you might have to build your own copy from source.
17:08:58 <Cale> I don't think it supports cross compiling from Linux to Windows at all at the moment though.
17:09:01 <macalimlim> ok thanks :)
17:09:47 <reygoch> well, bb
17:24:33 <fr33domlover> Is it possible to make a monad transformer a MonadTrans instance, but only for some condition? i.e. make "lift action" work only if action is of, e.g. a monad that's a MonadIO instance
17:24:56 <fr33domlover> this doesn't work of course: class MonadIO m => MonadTrans MyTransformerT where
17:25:17 <Cale> nope
17:25:42 <fr33domlover> if it's not possible i can define my own liftX etc.
17:25:48 <fr33domlover> and just tell users to use that
17:25:51 <Cale> yeah, you'll probably have to
17:26:04 <jle`> yeah, same thing is set up for Set.map
17:26:05 <Cale> But what is your transformer?
17:26:33 <Cale> It's a little surprising that there would be something that was a monad transformer, but only for monads in MonadIO
17:29:39 <fr33domlover> Cale, that's because my monad transformer runs all the actions with a timeout (unless specified otherwise) and the timeout impl requires MonadIO and MonadCatch
17:29:59 <Cale> Are you sure that results in a valid Monad?
17:30:03 <fr33domlover> so I wrote custom MonadIO and MonadTrans instances
17:30:14 <fr33domlover> Cale, valid Monad, well it seems so
17:30:23 <fr33domlover> i just get errors for the MonadTrans
17:30:33 <Cale> I mean, does it satisfy the laws?
17:30:37 <fr33domlover> which i'll solve by using liftX instead
17:30:41 <fr33domlover> Cale, dunno
17:30:58 <fr33domlover> Cale, it's a newtype wrapper of another transformer
17:31:14 <fr33domlover> and the wrapped one doesn't have such tricks :P
17:31:42 <Cale> Ah wait, so it's just a property of the function you're using to run the monad?
17:31:56 <fr33domlover> irony: i want to call the liftX function liftTimeout but it also means "remove timeout" while it really adds one... :P
17:33:09 <fr33domlover> Cale, the only unusual thing is that liftIO and lift don't to the usual thing (not the default trivial instances)
17:33:29 <fr33domlover> otherwise it's like any other MT i wrote :P
17:33:58 <fr33domlover> it's not critical to have this MT, just an interesting and potentially useful experiment
17:34:25 <fr33domlover> you implement a network protocol and everything is timed out by default
17:35:12 <fr33domlover> ah wait, oops :P indeed there is a hole here
17:35:33 <fr33domlover> liftIO x >> liftIO y is not the same as liftIO (x >> y)
17:35:56 <fr33domlover> the former gives each operation e.g. 5 seconds, the latter gives both 5 seconds in total
17:36:04 <fr33domlover> i suppose my MT isn't that smart :P
17:47:05 <jle`> yeah, sounds useful, but not a MonadTrans
17:47:30 <jle`> that'd be like having a Functor instance for [] that doubles the length of lists during the mapping process
17:47:41 <jle`> as in...maybe useful, but definitely not a Functor
17:49:19 * mniip . o O ( instance MonadIO TimeMachine is unlawful )
17:52:46 <fr33domlover> Since it requires liftTimeout or individual liftIOs there, I'm just canceling that MT, and leaving just the MT where actions aren't timed by default. I don't remember monad laws but I have a feeling they don't hold there :P
17:53:13 <fr33domlover> e.g. "liftIO(x>>y)" is not the same as "liftIO x >> liftIO y" which is super confusing
17:53:25 <fr33domlover> dunno about laws but it's horrible :P
17:53:27 <jle`> yeah, that's a consequence of the MonadTrans laws
17:53:35 <parsecChar> what's a nice haskell library for parsing non-Aeson json files? I.e. the data is NOT serialized haskell datatypes -- it's just raw, untyped, unformated json data that I need to parse and manipulate
17:53:38 <jle`> well, the more obvious one that it breaks is return x is not lift (return x)
17:53:46 <jle`> which is actually a MonadTrans law
17:54:09 <jle`> people still use aeson for parsing arbitrary json files in the real world
17:54:27 * hackagebot dotenv 0.2.0.0 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.2.0.0 (jsl)
17:54:44 <fr33domlover> parsecChar, the aeson docs give an example
17:54:52 <fr33domlover> you don't have to parse into your custom type
17:54:57 <parsecChar> https://hackage.haskell.org/package/aeson ?
17:55:02 <fr33domlover> yep
17:55:08 <fr33domlover> inside Data.Aeson
17:55:24 <parsecChar> where are the 'docs' 
17:55:28 <parsecChar> where are the aeson docs?
17:55:40 <parsecChar> https://artyom.me/aeson <- first hit on google
17:55:44 <fr33domlover> parsecChar, browse Data.Aeson on hackage :P
17:55:50 <jle`> the hackage link you gave is the aeson docs
17:55:51 <fr33domlover> just read there
17:56:20 <parsecChar> https://hackage.haskell.org/package/aeson-0.11.1.1/src/Data/Aeson.hs
17:56:28 <fr33domlover> yes
17:56:39 <parsecChar> Data.Aeson is not clickable
17:56:45 <parsecChar> so I can read the raw *.hs file, but I can't read a nice color coded html file
17:56:50 <parsecChar> am I doing something wrong?
17:56:53 <fr33domlover> parsecChar, go one version backwards
17:57:05 <parsecChar> https://hackage.haskell.org/package/aeson-0.11.1.0/docs/Data-Aeson.html
17:57:07 <parsecChar> I am happy now
17:57:08 <parsecChar> thanks :-)
18:29:16 --- mode: ChanServ set +o mauke
18:29:16 --- mode: mauke set -b *!*@static-71-174-73-11.bstnma.fios.verizon.net
18:31:16 --- mode: mauke set -o mauke
18:33:48 <orion> How on Earth do people debug parsers in Haskell?
18:36:22 <MichaelBurge> orion: I usually use a test suite to catch regressions, and for specific cases reduce the problem to a smaller and smaller case while inspecting the parser state
18:38:08 <MichaelBurge> orion: Or if you're using Data.Binary, use isolate and label.
18:39:08 <orion> Aeson
18:40:02 <orion> How do you inspect the parser state?
18:41:37 <MichaelBurge> I haven't usually had to debug other people's parsers, but it looks like Aeson uses Attoparsec
18:44:08 <MichaelBurge> JSON is simple enough I'd probably just delete sections of the JSON until it works, and then stare at the minimal example for a while
18:46:58 <pavonia> orion: I haven't tried it yet but there's the aeson-better-errors package which aims for better error messages in aeson parsers
18:50:39 <Cale> orion: Writing an instance of QuickCheck's Arbitrary for your datatype and trying to round-trip is probably the best way to find failing cases.
18:51:13 <Cale> (i.e. encode and then decode again and check that you get back what you started with)
18:52:44 <orion> I have a massive JS blob from Facebook here that's failing.
18:56:43 <pavonia> orion: JS or JSON?
18:57:19 <orion> JSON*
18:57:44 <parsecChar> waht's a synonym for 'excuse' ?
18:57:54 <parsecChar> wrong channel; sorry
19:03:04 <jle`> is there a maintained pgp library somewhere in the haskell ecosystem? hOpenPGP can't seem to build because i can't get one of the deps to build :|
19:55:40 <lethjakman-l> So...I'm looking at wreq and I'm trying to figure out how to use multiple different options. I don't see any examples. Would anyone know how to do that?
19:56:31 <lethjakman-l> I see you can do: defaults & param "foo" .~ ["bar", "baz"]
19:56:46 <lethjakman-l> Howeevr that comes out to ?foo=bar&foo=baz
19:56:59 <lethjakman-l> Where I want ?foo=bar&baz=biz
20:02:30 * geekosaur would guess: defaults & param "foo" .~ ["bar"] & param "baz" .~ ["biz"
20:02:38 <geekosaur> er with closing ] because derp
20:06:06 <lethjakman-l> geekosaur: you're totally right...
20:06:09 <lethjakman-l> I actually tried something like that
20:06:14 <lethjakman-l> I missed the second []
20:06:20 <lethjakman-l> Thank you!
20:06:26 <lethjakman-l> Sorry, I should have payed more attention. 
20:25:36 <parsecChar> https://hackage.haskell.org/package/aeson-0.11.1.0/docs/Data-Aeson.html#v:.: <-- how do I pull elements out of an array ?
20:25:51 <parsecChar> data Foo = Foo Double Double Double
20:26:09 <parsecChar> and I have "[1, 2, 3]" ==> how do I write a FromJSON to make this into a Foo ?
20:26:25 <parsecChar> fromJSON (Object v) = ... somehow generate a Foo .... but I need a way to pull elements out of the array/list v
20:26:44 <pm1> Hey
20:27:20 <pm1> What does ANN mean in the context of packages? I see new package announcements prepended with "ANN: ".
20:39:41 <Gurkenglas> ann is for announcement, pretty sure
20:43:07 <EvanR> parsecChar: use the json parser support to get a list, then inspect the elements to decide to fail or produce some other thing
20:48:14 <eyepatch_> I'm getting a parse error on http://lpaste.net/155396 I can't figure out why.
20:49:06 <EvanR> eyepatch_: on line 4
20:49:19 <EvanR> ... \x = (fst x) ...
20:49:32 <eyepatch_> oops. ->
20:49:53 <eyepatch_> works!
20:50:10 <EvanR> maybe no compiler error is good enough in some cases ;)
20:50:39 <eyepatch_> In hindsight, that error should have been really insightful. I believe that python uses and = in its lambda
20:50:45 <eyepatch_> Hmm... nope.
20:50:47 <eyepatch_> idk.
20:51:20 <eyepatch_> I guess good errors can't fix stupid.
20:58:36 <EvanR> its haskell which has weird syntax
20:58:45 <haskell954> Is there a way of merging multiple Behaviors in reactive banana? I'm looking at something like [Behavior a] -> Behavior a
20:58:46 <EvanR> \x . x x
20:58:48 <EvanR> is the one true syntax
20:59:07 <EvanR> haskell954: is Behavior an Applicative?
20:59:31 <haskell954> ya
20:59:48 <rcyr> EvanR: How would you represent (.) then? Remove it and use fmap?
20:59:53 <EvanR> haha
21:02:28 <EvanR> haskell954: and how do you want to combine them
21:02:42 <EvanR> monoid <> ?
21:03:07 <haskell954> nah, I just want it to combine, elm does it http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#mergeMany
21:03:14 <EvanR> "just combine" ?
21:03:22 <EvanR> oh are you talking about events?
21:04:02 <EvanR> [Event a] -> Event a
21:04:07 <haskell954> I'm at the state that I'm deciding if I want to use an event or a behavior
21:04:22 <EvanR> if Event a is a monoid, then mconcat :: [Event a] -> Event a
21:04:52 <haskell954> does this works with behavior too?
21:05:05 <EvanR> no because there are many ways to combine a list of behaviors
21:05:11 <EvanR> its not a union of events
21:05:34 <haskell954> what do you means by many ways?
21:06:07 <EvanR> if a behavior is a thing with a value at any time, then if you have two such things, say Behavior a and Behavior b then you can combine them using any a -> b -> c to get a Behavior c
21:06:11 <EvanR> thats Applicative
21:06:35 <EvanR> and you can use it to combine a list, you just need to decide how
21:06:54 <EvanR> maximum, moncat, etc
21:07:43 <EvanR> unless you meant [Behavior a] -> Behavior [a]
21:08:06 <haskell954> mmm, maybe that would be usefull
21:09:10 <EvanR> which would be a fold with pure (:) and pure []
21:09:34 <haskell954> my problem is that I have one event (or behavior) that will output many kind of actions, sometimes like data Action = Connect String | Disconnect | Move Position ...
21:09:35 <EvanR> (pure (:) <*>)
21:09:36 <lethjakman-l> Does anyone have a simple example of (<$)
21:09:45 <EvanR> which probably has a better abbreiation
21:09:48 <Cale> EvanR: do you mean liftA2 (:)?
21:09:53 <lethjakman-l> I'm looking at the type signature and the description, and it's just not quite clicking. 
21:09:58 <EvanR> yes
21:10:22 <Cale> :t foldr (liftA2 (:)) (pure [])
21:10:24 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
21:10:33 <haskell954> that's sequenceA
21:10:41 <Cale> It's basically sequenceA for lists
21:10:48 <EvanR> nice
21:11:04 <EvanR> haskell954: so.. those look like events to me
21:11:34 <haskell954> EvanR: I can't really have a monoid instance of that
21:11:41 <EvanR> no
21:11:50 <EvanR> Event Action would be a monoid, not Action
21:12:39 <haskell954> but event isn't a monoid according to the docs
21:12:46 * EvanR facepalm
21:12:56 <EvanR> well theres probably something that does mconcat
21:13:01 <EvanR> its just called something else
21:16:35 <Gurkenglas> Will ghc turn "uncurry (NE.:|) . fromJust . uncons . NE.toList" into id?
21:16:36 <haskell954> there's unionWith :: (a -> a -> a) -> Event a -> Event a -> Event a, but the problems is that I don't know how to use the first argument, since I can't just combine two Action
21:17:01 <EvanR> oh god
21:17:37 <EvanR> that looks like the output event isdelayed somehow until one event happens on each side
21:17:45 <EvanR> which is really zipWith
21:17:56 <EvanR> and also probably breaking some laws of events
21:18:10 <EvanR> if you were looking for just merging
21:19:00 <haskell954> no, the f is used in case that both event are in the same time
21:19:11 <EvanR> looks like its a terminology issue, i dont know what Event is
21:19:14 <EvanR> but merge : Signal a -> Signal a -> Signal a
21:19:40 <EvanR> "both event are in the same time" ... eh?
21:19:47 <haskell954> yes, I know, this isn't available in reactive-banana, that's why I'm asking that question
21:19:56 <EvanR> oh i thought you were asking about elm
21:20:38 <haskell954> oh, that would explain the confusion haha
21:20:41 <EvanR> what on earth is Event not a monoid?
21:20:51 <EvanR> type Event = [(Time, a)]
21:20:56 <EvanR> (literally in reactive banana)
21:21:06 <EvanR> oh ... what, that means it is
21:21:12 <EvanR> lists are monoids
21:21:33 <EvanR> but in the wrong way
21:21:53 <EvanR> uhg cant read newtype Event a = E { unE :: Prim.Event a }
21:22:39 <EvanR> haskell954: ok. so unionWith only uses that function if they are simultaneous
21:22:56 <EvanR> so you either lose information, or you need to replace a with [a]
21:23:45 <EvanR> i guess thats what you meant ;)
21:24:37 <EvanR> unionWith (\x y -> [x,y])
21:25:26 <haskell954> yeah, but the problem now is that I can't get from Event [a] to Event a
21:25:31 <EvanR> unionWith (++)
21:25:57 <EvanR> well whereever you handle events, youll just have to handle it with forM instead of one by one
21:26:44 <EvanR> or somehow, example using a Set. you basically have to decide how simultaneous events should work
21:27:54 <haskell954> that could work I think, thanks!
21:41:14 <Romefeller> hi
21:49:48 * hackagebot tagged-timers 0.1.0.0 - Simple wrappers for timing IO actions (single-threaded)  https://hackage.haskell.org/package/tagged-timers-0.1.0.0 (ranjitjhala)
21:49:53 <tippenein> question about parsers, maybe a code-clarity question. getting unexpected end of input - http://lpaste.net/155395
21:59:49 * hackagebot dotenv 0.3.0.0 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.3.0.0 (jsl)
22:21:40 <pavonia> tippenein: What is the pase result if you only parse a single anySingnal without eof
22:22:06 <tippenein> figure out it was a matter of manyTill anyToken (signalParser *> return () <|> eof)
22:23:41 <tippenein> pavonia: I'm using char '\n' *> return () <|> eof instead of a plain eof
22:24:22 <tippenein> previously it would parse correctly if I put another Signal at the end of the parse input, but would barf on end of input. 
22:24:30 <tippenein> makes a lot of sense why it was failing in hindsight
22:25:55 <pavonia> So manyTill fails if it parses up the the end of input?
22:26:00 <pavonia> *to the
22:26:55 <tippenein> yeah. There's probably a more succinct way of doing it, because if feels like using lookAhead is a hack
22:27:20 <tippenein> I'm basically chopping a string into portions starting with a Signal
22:28:52 <tippenein> I found tests extremely useful to this process tho. stack test --file-watch is a lifesaver
22:29:13 <montanonic> I've heard that I should use ExceptT over ErrorT. Why is this the case? More strongly typed because it uses ADT exceptions?
22:30:08 <montanonic> I'm finding that I'm using a whole lot of MaybeT code, and so it seemed wise to upgrade to actually having some information about what's causing a failure, instead of just saying that there *was* a failure.
22:31:12 <montanonic> Actually, sorry, I think I answered it for myself by reading the intro to http://haddock.stackage.org/lts-5.8/transformers-0.4.2.0/Control-Monad-Trans-Except.html#v:ExceptT
22:31:36 <montanonic> It says basically to use this over MaybeT if you want more detailed errors, so this is exactly what I wanted 
22:36:31 <acertain> do you expect that
22:36:32 <acertain> (((a <?> x) <|> (b <?> y)) <?> z) == (a <?> z) <|> (b <?> z)
22:36:32 <acertain> ?
22:36:42 <acertain> with parser combinators
22:43:36 <montanonic> So, I have a better question than I asked earlier. Would someone be able to give me some advice on error-handling toolkits? I haven't spent too much time in IO-land in my Haskell career, but now that I'm building a bigger and bigger project, I need to get comfortable with it.
22:43:45 <acertain> or (((a <?> x) <|> (b <?> y)) <?> z) == (a <?> x) <|> (b <?> y)   ?
22:43:50 <montanonic> So far, these are the three tools I'm looking at: https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html
22:44:21 <montanonic> http://haddock.stackage.org/lts-5.8/mtl-2.2.1/Control-Monad-Except.html#t:MonadError, and https://hackage.haskell.org/package/errors by GabrielG
22:44:40 <montanonic> My lack of experience with error-handling makes it hard to discern when I should be using which.
22:45:34 <montanonic> Instinctively, I'm drawn to the mtl implementation, and GabrielG's over the one in base. And of those two, Gabriel's looks a bit more user-oriented in its design, and the mtl one appears more general.
22:46:12 <acertain> montanonic, errors is just utility functions for ExceptT, Maybe and Either
22:46:58 <montanonic> acertain: so the question is, when might ExceptT not go far enough? Should I have much of a reason to be using the Control.Exception library in base?
22:47:13 <acertain> montanonic, usually, you should use Control.Exception with IO functions, and ExceptT when you're working in a big mtl stack
22:47:37 <montanonic> acertain: I'm working with a Yesod project, if that helps to identify what I'm more likely to need
22:47:58 <montanonic> acertain: basically everything is done is some Transformer built atop IO in Yesod
22:48:38 <acertain> it depends if you have a natural thing to put in ExceptT for your app
22:48:41 <montanonic> acertain: in any case, thank you for pointing out those aspects of the libraries. It gives me a fair idea of when to use them. 
22:48:49 <acertain> i think with webapps probably not
22:49:24 <acertain> in general you should try to deep error handling "local", using Maybe/Either and COntrol.Exception when you need it for IO
22:50:12 <montanonic> acertain: yeah, so far I haven't had a case where the error shouldn't be dealt with in the same function
22:56:17 <acertain> using ExceptT in an app-wide mtl stack is the wrong way to go probably, but it might sometimes be useful on it's own (`ExceptT MyStack a` instead of `newtype MyStack a = ... ExceptT ...`)
22:58:18 <acertain> depends on how much of your app is serious logic vs simple CRUD stuff
22:59:32 <acertain> if <|> is symmetric, do you expect that ((a <?> x) <|> (b <?> y)) <?> z =?= (a <?> z) <|> (b <?> z)   or   (((a <?> x) <|> (b <?> y)) <?> z) == (a <?> x) <|> (b <?> y)   ?
23:00:30 <acertain>  also, ((a <*> (b <?> x)) <|> c) <?> y == ((a <*> b) <|> c) <?> y  or not?
23:03:29 <acertain> so, I'm implementing GLL, and it has symmetric <|> that runs both
23:03:40 <Cale> In Parsec: The parser p <?> msg behaves as parser p, but whenever the parser p fails without consuming any input, it replaces expect error messages with the expect error message msg.
23:03:41 <acertain> so the question is how to handle errors
23:04:08 <acertain> since there's not a natural "input location" as much with <|> any more
23:04:51 <Cale> Well, p <|> q still starts parsing at some location in its input...
23:05:35 <acertain> sure, but both could fail at separate locations
23:05:41 <acertain> s/both/each/
23:06:11 <acertain> with backtracking it
23:06:19 <acertain> is obvious, but GLL doesn
23:06:25 <acertain> t do backtracking
23:06:49 <acertain> GLL runs both *in parallel*
23:06:54 <Cale> I think you fail at the point at which the <|> began, if all of its constituents fail.
23:07:29 <acertain> that works
23:08:03 <Cale> Because, even though the reason that each of the disjuncts failed might be at different individual positions, that doesn't really matter, because none of those disjuncts really ended up describing what is there anyway
23:08:58 <Cale> Though, I suppose with Parsec, you might expect in many cases to commit to some parser once it successfully consumes some input and you can no longer take any other branch
23:09:44 <Cale> So it *might* make sense there to give an error related to the parser you committed to, but that might be confusing as well, especially if it only consumed a few characters or something.
23:09:46 <acertain> but at this point, <|> is throwing info away, and you could also give a trace tree of the failure
23:09:53 * hackagebot sleep 0.1.0.0 - zZzzZz  https://hackage.haskell.org/package/sleep-0.1.0.0 (AlanHawkins)
23:10:34 <Cale> Yeah, I suppose you could
23:41:33 <MichaelBurge> I'm trying to define a typeclass for models in my web app. As for as I can tell, GHC is having trouble corresponding the typeclass constraint variable with its use in the body.
23:41:43 <MichaelBurge> Anyone mind taking a look? http://hastebin.com/vinuhugida.coffee
23:44:04 <EvanR> what is the error?
23:44:20 <MichaelBurge> Could not deduce (Queryable a0) arising from a use of ‘table’ from the context (Queryable a)
23:44:29 <MichaelBurge> on the line where table is being used
23:44:40 <EvanR> let t = table (undefined :: a) :: Table
23:44:47 <EvanR> that a is not the same a as in the type sig
23:45:05 <EvanR> unless you use ScopedTypeVariables
23:45:23 <EvanR> but you dont really need it since it will be inferred
23:46:03 <MichaelBurge> If I remove the :: a, I get the same error.
23:46:38 <MichaelBurge> That makes sense though, since there's nothing to infer it against in that example.
23:47:05 <MichaelBurge> Since there won't be any a value in scope, it should be impossible to infer right?
23:47:11 <EvanR> let t = table undefined in return Nothing seems like it should work, since its never used
23:47:30 <EvanR> its inferred if you ever use find somewhere
23:48:29 <EvanR> let me backtrack and just mention BTW that class Queryable a where table :: a -> Table is really a lot better by just using the type Table instead
23:50:47 <MichaelBurge> EvanR: How would you access the type's constant 'table' value without a phantom a variable to disambiguate?
23:51:18 <EvanR> if youre asking about what i just said, then the type already is Table
23:52:04 <EvanR> youre right about the original point i think, you really need to use undefined :: a (correct a using scoped type vars) or the proxy trick
23:52:12 <EvanR> which also involves scoped type vars
23:52:27 <MichaelBurge> Okay, I'll try those. Thanks for the hint about scoped type variables.
23:52:32 <EvanR> but none of these shenanigas is needed if you replace a -> Table with Table
23:53:40 <MichaelBurge> EvanR: If I have a 'data City = City { ... }' and define 'instance Queryable City where table = Table {... }', how would one access the Table value that corresponds to the City type?
23:54:18 <EvanR> if you did that
23:54:29 <EvanR> you obviously use find
23:54:39 <EvanR> i cant tell if youre responding to my point about not needing the typeclass or not
23:55:37 <MichaelBurge> EvanR: I was responding to the point about changing the type of 'table' to 'Table' rather than 'a -> Table' inside the typeclass.
23:55:49 <EvanR> no
23:56:24 <EvanR> by putting Tablable a => on all your functions that will use table, you are basically implicitly asking for an a -> Table as an argument
23:56:35 <EvanR> instead you can take Table as an argument, and no constraint
23:58:11 <EvanR> since the first thing youd do is apply table to a proxy to get a Table, might as well save a step and simplify the api and implementation
23:59:32 <MichaelBurge> EvanR: Oh, that's actually how the code already is. I wanted to save an argument off of the invocation 'find citiesTable connection 0', since the 'citiesTable' should be implicit given a result type of City.
23:59:43 <MichaelBurge> But maybe it's better to keep it simple
