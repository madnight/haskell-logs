00:07:40 * hackagebot optparse-generic 1.1.0 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.1.0 (GabrielGonzalez)
00:07:40 * hackagebot sensei 0.0.0 - Automatically run Hspec tests on file modifications  https://hackage.haskell.org/package/sensei-0.0.0 (SimonHengel)
00:23:15 <joco42> is there a way to add a run time assertion that the depth of `subDirs` should be depth+1 when creating a DirTrNode ? like a function that runs every time the constructor `DirTrNode` runs ? https://www.irccloud.com/pastebin/ioiOUOej/
00:26:17 <joco42> this seems to be the solution https://wiki.haskell.org/Smart_constructors
00:51:37 <Cale> ontop: Did you figure out how to write your loop?
00:51:49 <ontop> Yeah, I stole some code from someone :(
00:51:51 <Cale> ontop: forM / forM_ are perhaps useful
00:51:52 <ontop> It made me sad.
00:51:59 <ontop> Yeah I used for_ from applicative
00:52:02 <ontop> Er, foldable
00:52:08 <Cale> Yeah, that's another option
01:37:37 * hackagebot task-distribution 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/task-distribution-0.1.0.1 (axm)
03:14:15 <przembot> why many libraries are shipped without any -O flag in ghc-options?
03:14:44 <puregreen_> has anybody got an example of how to use spans when reporting error messages in trifecta?
03:22:27 <puregreen_> przembot: cabal enables -O by default, I think
03:54:06 <Wizek_> Hey! Is it true that "+RTS -p -RTS" only outputs profiling info if the app exits willingly? If so, how could I get such profiling info for a persistent app? Tried running it + ^C after some time, but I didn't see any .prof file created.
04:22:51 * hackagebot vector-binary-instances 0.2.3.1 - Instances of Data.Binary and Data.Serialize for vector  https://hackage.haskell.org/package/vector-binary-instances-0.2.3.1 (BenGamari)
04:52:40 <fizbin> I feel like I'm missing something obvious; I have a function myCombiner: [MyType] -> [[MyType]] that is currently written in terms of two MyType constructors, one of which has the type [MyType] -> MyType and the other has the type [MyType] -> MyType -> MyType.
04:53:18 <fizbin> I feel like I ought to be able to write this as a fold of some sort, but that's not working easily:
04:54:10 <fizbin> myCombiner rs [] = Sequence rs ;   myCombiner rs (o:os) = And rs (combineAnd o os)
04:54:41 <fizbin> That's almost a foldr, but not quite.
04:55:32 <fizbin> Sorry, myCombiner has type myCombiner :: [MyType] -> [[MyType]] -> MyType
04:57:03 <fizbin> The closest I've come up with involves reversing the second arg and applying foldl' to it.
05:10:10 <sternenseemann> 13:08 < midzer> eben weil ich deine genannten dienste (zumindest übers inet) selten nutze
05:10:13 <sternenseemann> 13:09 < midzer> wenns dich nervt, dann akzeptier ich das natürlich! :)
05:10:15 <sternenseemann> 13:08 < midzer> eben weil ich deine genannten dienste (zumindest übers inet) selten nutze
05:10:18 <sternenseemann> 13:09 < midzer> wenns dich nervt, dann akzeptier ich das natürlich! :)
05:10:21 <sternenseemann> oh, sorry
05:10:25 <sternenseemann> I hate the middle mouse button
05:11:21 <cocreature> I remember vagly that GHC 8 was going to bundle LLVM but at least in the rcs it’s not the case as far as I can see. am I missremembering? I can’t find any information on what happened to that plan
05:12:43 <srhb> cocreature: This? https://ghc.haskell.org/trac/ghc/wiki/ImprovedLLVMBackend
05:12:52 * hackagebot hpack 0.11.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.11.0 (SimonHengel)
05:13:28 <cocreature> srhb: ah yes, thx
05:14:28 <srhb> cocreature: Not sure the status helps much, but perhaps it can help finding more info. :)
05:15:47 <cocreature> https://ghc.haskell.org/trac/ghc/ticket/10074 “It seems that this likely won't happen for 8.0.” :(
05:22:54 * hackagebot sensei 0.1.0 - Automatically run Hspec tests on file modifications  https://hackage.haskell.org/package/sensei-0.1.0 (SimonHengel)
05:25:52 <breadmonster> Any news on ghc 8.0 release dates?
05:44:21 <volhovm> Hey
05:44:42 <volhovm> Does anybody here use flycheck-stack-ghc?
05:44:56 <volhovm> I've spent like 3h already to make it work
05:44:58 <volhovm> and nothing :|
05:46:05 <volhovm> I'd be really grateful if somebody shares config or something
05:47:24 <volhovm> Do I also need ghc-mod or something?
05:49:13 <unit73e> hey
05:49:42 <unit73e> I have a 'sdl2.cabal' file. How do I run 'executable lazyfoo-lesson-09'?
05:59:00 <srhb> unit73e: cabal run lazyfoo-lesson-09 iirc
06:00:40 <unit73e> srhb, thx. I guess I have to build first. I don't get how to specify flags though and apparently you need the 'examples' flag
06:07:01 <srhb> unit73e: cabal configure -f examples?
06:07:03 <srhb> I think.
06:07:56 <unit73e> srhb, yeah I figured it out right before you answered, seems Makefile inspired. thanks.
06:08:22 <unit73e> I guess I'm too used to gradle and friends
06:08:46 <int-e> mniip: the Free question devolved quickly into a "can I trust profunctors" question, and that's not so easy.
06:10:26 <Gurkenglas> Why isn't there telescoped for Free, using prisms?
06:10:53 <unit73e> success, the examples run. thanks srhb.
06:20:05 <maybefbi> How much would you charge to build a authenticated todo list REST endpoints in Servant and Database.MongoDB? 
06:23:17 <maybefbi> anybody here?
06:38:30 <srhb> maybefbi: Plenty of people here, probably none at the moment have an opinion on the question. :)
06:38:41 <maybefbi> ok
06:45:59 <slack1256> I've heard that GADTs are useful of type-equality. I've never found myself on a situation where that is something I am looking for nor understand
06:46:05 <slack1256> what is a good introduction to the topic?
06:47:00 <fnord__> Hi, I'm looking for a paper containing type rules for algebraic data types. Any ideas?
06:48:09 <fnord__> I know that they are basically a combination of product, sum, and recursive types, but I think it would help to see it all together :)
06:48:40 <slack1256> fnord__: I would look for them in books not papers
06:49:09 <slack1256> those of that robert harper seems to the be the go to resource for it
06:50:43 <mettekou> fnord__: Types and Programming Languages by Benjamin Pierce touches on sum, product, and recursive types.
06:51:32 <fnord__> slack1256: mettekou: I've checked the summaries of both Harper's "Practical Foundations for Programming Language's" and Pierce's "Types and Prog. Lang."
06:51:56 <fnord__> but both only show sum, product, and recursive types, but not the whole thing with name resolution etc.
06:52:24 <fnord__> guess I'll try to work it out as an exercise :)
06:54:48 <ggole> I don't think ML-style data types don't need any particular treatment for recursive types.
06:55:16 <ggole> The reason is that they are nominal types, so you only need equality of type constructors
06:55:40 <ggole> Oops, extra "don't" in there.
06:55:57 <fnord__> ggole: brain autocorrect took care of it ;)
06:56:38 <ggole> It's probably still a good exercise.
06:56:38 <fnord__> ggole: thanks for the info.
06:57:27 <mettekou> Does anyone know if there exists a tool for implementing quotation/macros in an interpreter/compiler such as Camlp5 for Haskell?
07:21:23 <mniip> int-e, I see
07:24:05 <mniip> int-e, what if you disallow Data.Profunctor.Unsafe?
07:24:12 <mniip> or are there other places where Coercible comes up?
07:26:18 <mniip> seems like not
07:34:29 <int-e> :t Data.Profunctor.Types.Star
07:34:30 <lambdabot>     Not in scope: data constructor ‘Data.Profunctor.Types.Star’
07:35:39 <mniip> :t Data.Profunctor.Star
07:35:40 <lambdabot> (d -> f c) -> Data.Profunctor.Star f d c
07:36:03 <mniip> Data.Profunctor.Types isn't much harmful though, is it? it doesn't export anything bad
07:36:34 <int-e> yeah, I'm more worried about uses of #. and .# now.
07:36:44 <mniip> yeah
07:36:54 <mniip> it exports the instances that implement #. and .#
07:37:11 <mniip> but it exports the class without those
07:37:58 * hackagebot dotnet-timespan 0.0.1.0 - .NET TimeSpan  https://hackage.haskell.org/package/dotnet-timespan-0.0.1.0 (YorickLaupa)
07:41:33 <mniip> #. and .# are never exported explicitly, and the Profunctor class is exported as follows
07:41:35 <mniip> src/Data/Profunctor.hs:    Profunctor(dimap,lmap,rmap)
07:41:35 <mniip> src/Data/Profunctor/Unsafe.hs:    Profunctor(..)
07:41:35 <mniip> src/Data/Profunctor/Types.hs:  ( Profunctor(dimap, lmap, rmap)
07:47:27 <oskarkv> Is there a way to easily find out type synonyms, for example that a FilePath is a String?
07:49:18 <pavonia> oskarkv: :k! in GHCi, IIRC
07:50:26 <oskarkv> it says FilePath :: *; = FilePath
07:51:29 <pavonia> Uh, too bad
07:51:29 <mniip> oskarkv, :info FilePath
07:51:43 <oskarkv> ah, thanks
07:52:01 <int-e> mniip: Anyway, yes, marking that module unsafe should be enough.
08:00:54 <sphinxo> What would something like https://bpaste.net/show/fc184d9f253b look like in haskell?
08:02:49 <pavonia> Looks like a fold or foldM
08:03:57 <sphinxo> pavonia: over what?
08:04:21 <pavonia> A list of objects
08:04:32 <sphinxo> ahh ok
08:04:41 <pavonia> where intersect is the accumulator
08:06:53 <sphinxo> and the fold function sig would be?
08:08:42 <pavonia> That depends on the types of the functions used in this sample
08:10:37 <sphinxo> I was thinking something like https://bpaste.net/show/502ef35799d0
08:11:37 <sphinxo> and the function would be the comparison pavonia ?
08:12:01 <pavonia> What comparison?
08:12:16 <pavonia> Ah, yes
08:12:34 <pavonia> plus the intersection
08:12:44 <sphinxo> ahh yes
08:13:52 <pavonia> Or, as ray doesn't seem to depend on prior calculations, you could also map ($ ray) over the list
08:14:02 <sphinxo> cool
08:15:57 <pavonia> And then you have "foldr (\current intersect -> ...) 1 mappedObjects" I guess
08:16:48 <sphinxo> 1?
08:17:30 <pavonia> The initial value of intersect
08:17:55 <sphinxo> ahh 
08:26:20 <sphinxo> How can I do if 0 < current < intersect ? 
08:27:16 <mniip> just like you would in any other programming langauge
08:28:28 <sphinxo> (0 < current) and (current < intersect) ?
08:28:39 <mniip> &&
08:28:43 <mniip> and is something else
08:28:54 <sphinxo> oh yes
08:39:30 <volhovm> Did someone succeeded in installing emacs + (flycheck | ghc-mod) on nixos?
08:55:47 <tomus> cabal test coplains about my own module (couldn't find). how come?
08:56:18 <hexagoxel> tomus: details?
08:56:58 <tomus> hexagoxel: http://pastebin.com/EbrWuNRZ
08:57:10 <tomus> (I don't know what should I add to .cabal to make it go away)
08:57:30 <puregreen> tomus: if it's not exported, you won't be able to test it
08:59:17 <tomus> puregreen: not sure how I export it...
08:59:22 <hexagoxel> there are two way of testing modules from the lib: add the lib's hs-source-dirs to the test's hs-source-dirs or add a build-depends on the same package to the testsuite.
08:59:42 <puregreen> interesting, I haven't ever used the 1st way
08:59:47 <puregreen> hexagoxel, thanks
08:59:56 <hexagoxel> tomus: if you can't get it to work, post .cabal file
09:00:11 <hexagoxel> (pastebin ofc)
09:00:47 <hexagoxel> puregreen: yeah the first way is bad in that the tests will need all the build-depends of the library.
09:01:13 <hexagoxel> but you get around the "see-only-exposed-modules" restriction
09:01:52 <tomus> http://pastebin.com/0wAZFLVc
09:02:00 <tomus> ^^ my cabal
09:05:07 <hexagoxel> tomus: ah, you have no library. either refactor the package and put any modules other than main in a library, so you can expose them to the test-suite, or put "hs-source-dirs: ., tests"
09:05:19 <hexagoxel> i think the latter works..
09:11:48 <whald> hi! can someone please explain to me, how and why this: https://github.com/silkapp/rest/blob/master/rest-example/example-api/Api/Post.hs#L62 works, given that...
09:12:29 <tomus> hexagoxel: added a Library, same problem
09:12:59 <whald> ...the mkResourceReader function returns a "Resource m s sid Void Void", but the linked function returns a "Resource BlogApi WithPost Identifier () Void"
09:13:11 <tomus> http://pastebin.com/0afTYPyX
09:13:50 <whald> i don't understand how that () <-> Void change is possible, is that some language extension I don't know? the documentation for mkResourceReader is at https://hackage.haskell.org/package/rest-core-0.38/docs/Rest-Resource.html
09:14:21 <thewormkill> whald: where does said Void come from?
09:14:43 <whald> thewormkill, here: https://hackage.haskell.org/package/rest-types-1.14.0.1/docs/Rest-Types-Void.html
09:14:57 <bxx2>  /msg bxx2 register bb18021984 burclaf@gmail.com
09:15:11 <whald> it looks to me like something akin to "ScopedTypeVariables"
09:15:56 <puregreen> does anybody know why trifecta reports 2 errors here and how to rid of the 1st one? (also, is there a better way to do what I'm doing?) http://lpaste.net/154612
09:16:07 <whald> it compiled the rest package(s) and the example, and it acutally works, but i cannot reprocude it. this is driving me nuts. :-)
09:16:52 <the_2nd> I have a function which returns a maybe double and a list I want to map this function over in such a way that:
09:17:07 <thewormkill> whald: hm, tbh, my knowledge of the more complicated type system features ends here, but my intuition tells me that this is possible because of the quantification in the type, as well as the fact that it holds no value except possibly bottom. The docs mention it, so I guess go from there :)
09:17:07 <the_2nd> if it's nothing, throw away the result, else add it to result list
09:17:18 <the_2nd> so length result <= length inputList
09:17:56 <thewormkill> the_2nd: I'd use catMaybes . map
09:17:58 <ClaudiusMaximus> :t mapMaybe
09:17:59 <lambdabot> (a -> Maybe b) -> [a] -> [b]
09:18:06 <thewormkill> or that
09:18:10 <thewormkill> even shorter
09:19:18 <the_2nd> ClaudiusMaximus, thewormkill thanks, working
09:19:26 <the_2nd> I used mapM and got an empty list
09:19:35 <the_2nd> mapMaybe works as I wanted it
09:19:46 <hexagoxel> tomus: put "haskell-parser" in your test's build-depends
09:19:59 <tomus> hexagoxel: ah cheers
09:20:01 <tomus> works
09:20:30 <whald> thewormkill, my understanding so far is that Resource is a parameterized record "Resource m s sid mid aid", and the only field that depends on "mid" is "schema :: Schema sid mid aid" -- so by plugging something there with a different type for "mid", I actually change the type of the record. just, Haskell does not allow that. :-/
09:25:12 <whald> thewormkill, oh my, actually "Resource.list" also depends on "mid", and updating that field too makes it compile. Haskell does allow that and i'm an idiot. sorry. :-)
09:25:22 <thewormkill> whald: np
09:28:39 <tomus> Cases: 2  Tried: 2  Errors: 0  Failures: 2
09:28:40 <tomus> Test suite test-SQLTester: PASS
09:28:44 <tomus> why PASS?
09:30:49 <Gurkenglas> the_2nd, here's the behavior of mapM (well actually sequence but its morally the same thing): http://sketchtoy.com/66039859
09:31:50 <mniip> is the circle Just and the zigzag arrow a Nothing?
09:32:10 <Gurkenglas> Yes. I have to say that part out loud? :c
09:32:23 <mniip> took me a moment
09:32:30 <tomus> had to copy the solution from SE http://stackoverflow.com/questions/31492666/running-cabal-test-passes-although-there-are-test-failures
09:33:00 <Gurkenglas> (also State s and StateT s Maybe: http://sketchtoy.com/66039843 http://sketchtoy.com/66462297 )
09:33:20 * tomus HUnit and cabal appears to lack "sensible" defaults :/
09:35:24 <mniip> Gurkenglas, interesting concept
09:35:55 <mniip> I mean animated sketches with pictographic representations of monads
09:36:14 <mniip> time for a yet another monad tutorial?
09:41:22 <Gurkenglas> This seems more useful for (some) monads than Monad. You could draw something like this for yoctoparsec though :P
09:43:02 * hackagebot eventstore 0.12.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.12.0.0 (YorickLaupa)
09:44:53 <supki> tomus: I'd guess few people use HUnit directly, so the poor state of its API is understandable.
09:53:13 <the_2nd> Gurkenglas, thanks for the animation
09:57:23 <tomus> supki: didn't realise that....
09:58:04 <tomus> ok, I am using test-framework and defaultMain, so I guess it's not so bad
09:58:15 <tomus> I don't really know what HUnit is for anywmore
10:02:31 <Myrl-chan> I'm so confused; how do I install stack on Arch Linux ARM?
10:02:54 <thewormkill> Myrl-chan: it should be in the repos... lemme look
10:03:24 <Myrl-chan> thewormkill: I don't think it is.
10:03:37 <thewormkill> yeah, it's only there for x86_64 and i686
10:03:50 <Myrl-chan> thewormkill: Got any idea how to build stack?
10:03:56 <Myrl-chan> I think I need cabal
10:04:07 <thewormkill> yes, it's in the ABS, so you can build that from source on your machine.
10:04:09 <Myrl-chan> So this means I need to build cabal..
10:04:22 <Myrl-chan> thewormkill: ABS?
10:04:25 <thewormkill> it's the same procedure as on a normal (non-ARM) arch installation
10:04:29 <thewormkill> Arch Build System
10:04:55 <Myrl-chan> TIL ABS.
10:05:00 <Myrl-chan> How does it work
10:05:01 <thewormkill> However, I suppose there are no guarantees that it will work, as the scripts might be reliant on architecture specific details
10:05:13 <thewormkill> well, the Arch wiki is a good source ;)
10:05:32 <thewormkill> however, why do you need stack on an ARM device?
10:05:33 <Myrl-chan> True.
10:05:48 <thewormkill> because compilation will take a while
10:10:12 <black0range> Hello! Do you know if theres any performance differences between using ST or IO? 
10:10:35 <Myrl-chan> This will be hell.
10:10:41 <Myrl-chan> You know what I plan on doing?
10:10:46 <darkf> black0range: pretty sure that in GHC at least, they use the exact same mechanisms, so there shouldn't be
10:11:05 <Myrl-chan> Install related packages through pacman, build stack, uninstall every related package and ghc.
10:11:09 <Myrl-chan> <.<
10:12:04 <black0range> darkf: Oki :)
10:12:11 <thewormkill> wait... if you uninstall ghc, you probably won't develop on that system. So why do you need stack, Myrl-chan?
10:12:29 <thewormkill> don't walk through hell if you can use a bridge over it's pits
10:12:30 <Myrl-chan> thewormkill: I'll uninstall ghc so that I can install it through stack.
10:12:35 <thewormkill> oh
10:13:17 <Myrl-chan> This sounds so roundabout..
10:13:21 <mniip> ah the good old "my distro is a jerk" problem with language specific packages
10:13:35 <Myrl-chan> mniip: :P
10:13:56 <Myrl-chan> To be fair, AL is the least jerk out of every OS I used.
10:14:04 <Myrl-chan> Not including NixOS of course; that's cheating.
10:15:12 <mniip> I'd say install gentoo, but that has a high entry barrier that I, myself, haven't passed yet I believe
10:15:21 <orion> Why can't Data.Text be a Monoid?
10:15:45 <Myrl-chan> mniip: I used to use gentoo, without ~amd64, all your libs a shit.
10:15:56 <mniip> haha
10:16:09 <Myrl-chan> mniip: Not so funny when it's so true. :P
10:16:11 <mniip> doing anything serious without ~
10:16:24 <mniip> bruh I have a few masked packages
10:16:44 <Myrl-chan> mniip: Really though, NixOS does everything I want with Gentoo.
10:16:57 <liste> orion: it is?
10:17:16 <liste> (pack "hello ") <> (pack "world") --> "hello world" on my GHCi
10:18:03 <Gurkenglas> Take care, fold takes quadratic time.
10:18:25 <black0range> orion: It prettly clearely said monoid? http://hackage.haskell.org/package/text-0.11.2.0/docs/Data-Text.html
10:18:33 <dford> Hello All!
10:18:38 <Gurkenglas> (Unless O2 is absolutely magic. mconcat should be linear.)
10:18:43 <dford> With the ghc's -threaded option, the runtime tries to compute things in parallel (even though I have no explicit 'par' used)
10:18:43 <amf> can i have a mapping function that works inside `mapWithKey :: (k -> v1 -> v2) -> HashMap k v1 -> HashMap k v2` and does IO?
10:18:52 <orion> liste / black0range: https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text.html#t:Text <-- I don't see Monoid there
10:18:59 <dford> But the performance of -threaded is much worse than single threaded. So is there a way to force the execution in single thread?
10:20:16 <Myrl-chan> dford: lol
10:20:42 <black0range> orion: How curious, you're right :) 
10:20:48 <adam789654123> i think there might be a technical problem with that dford 
10:21:36 <Gurkenglas> amf, you would compose "traverse :: ((k, v1) -> IO v2) -> HashMap k (k, v1) -> IO (HashMap k v2)" and "mapWithKey (,) :: HashMap k v1 -> HasMap k (k, v1)".
10:22:02 <dford> technical problem? My code is very numerical and uses lots of vectors. But it is essentially a serial algorithm
10:22:41 <dford> I want to run this algorithm in single thread, but want to use concurrency to run multiple algorithms at once. So need to use -threaded option
10:22:47 <carter_cloud> Dford -N 1
10:22:50 <carter_cloud> Oh.
10:22:51 <adam789654123> well..... i guess you want to know if you can run as if in one thread for certain processes
10:22:56 <carter_cloud> You can do single threaded run time
10:23:15 <carter_cloud> If you just wanna do concurrenc that's not parallel
10:23:16 <Gurkenglas> (traverse is generalized mapM. mapM would be enough here, but I think the modern sentiment is to just use the general names always.)
10:23:17 <adam789654123> that i have no idea
10:23:20 <liste> orion: it's not in the docs, but see https://hackage.haskell.org/package/text-1.2.2.0/docs/src/Data-Text.html#line-343
10:23:21 <carter_cloud> Or mess with rts options
10:23:29 <carter_cloud> To reduce migrations
10:23:46 <dford> No, I need to use multiple cores. but force the algorithm to use only one context
10:23:51 <carter_cloud> Like -qa and a few others
10:24:20 <carter_cloud> Dford : look at the rts flags that make ghc thread capabilities have cpu affinity
10:24:31 <carter_cloud> How many physical cores do you have?
10:24:47 <carter_cloud> And what sort of parallel commutation is it?
10:25:02 <carter_cloud> Is it allocation heavy or memory traffics heavy or what ?
10:26:20 <dford> I have about 28 cores, and lots of memory. So I can do processing of a number of vectors in parallel. But the processing algorithm performs best in single-threaded mode.
10:26:21 <geekosaur> orion, black0range, I think haddock does not understand the CPP extension and so is tripping over the #if MIN_VERSION_base(...)
10:27:10 <adam789654123> management of threading itself takes resources
10:27:26 <geekosaur> (more precisely it's all getting stripped out because those are not being defined and so acting always false?)
10:27:59 <dford>  With '-N2 -qa -s'  'MUT     time   17.211s  ( 15.751s elapsed)' , With ' -N1 -qa -s' ' MUT     time    4.234s  (  4.260s elapsed)'
10:28:23 <amf> Gurkenglas: ah ha!! thanks!!
10:28:33 <dford> GC is ok, MUT is taking a lot more time
10:30:38 <adam789654123> dford: taking alot of resources i guess is that case
10:30:46 <adam789654123> that it can be greedy is not suprising to me
10:31:39 <Gurkenglas> amf, let me also nudge you towards uncurry to be used in traverse's first argument, esp if you define the rest of it in a let/where
10:32:07 <dford> But I don't get why it is using resources, when I have not specified any parallel strategy, etc.
10:32:28 <Gurkenglas> amf, if you're familiar with lens, indexed traversals will do this directly btw
10:33:24 <amf> Gurkenglas: lens is getting easier. ill check that out
10:34:19 <adam789654123> dford: my thinking is, if its going to be parallel, its going to be parallel from the ground up
10:34:29 <adam789654123> im no specialist, but this is my understanding
10:34:30 <Gurkenglas> :t itraverse -- actually looking it up, this is pretty much immediately what you wanted :D amf
10:34:31 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
10:35:53 <adam789654123> it might be useful to understand how the parallelization is managed though
10:35:54 <Gurkenglas> https://hackage.haskell.org/package/lens-4.13.2.1/docs/src/Control.Lens.Indexed.html#local-1627565161 <- "itraverse = HashMap.traverseWithKey" <.< amf
10:36:08 <adam789654123> but for that, i think one might need a deep understanding of the implementation
10:36:34 <adam789654123> for example, why not merge evergthing, when nothing else is in use?
10:36:37 <amf> Gurkenglas: youre the best!! i never would have thought to look there
10:36:38 <adam789654123> idk
10:38:10 <adam789654123> im *might* simply be the case that this is much more difficult to do within the framework than to extend the framework to do it
10:39:09 <Gurkenglas> https://hackage.haskell.org/package/unordered-containers-0.2.7.0/docs/Data-HashMap-Lazy.html#v:traverseWithKey
10:40:32 <Gurkenglas> (that took surprisingly long to find from the name and google, though retrying with hayoo its pretty instant)
10:41:19 <amf> Gurkenglas: and in the traverseWithKey IO can be that f?
10:41:50 <Gurkenglas> IO is a monad, every monad is an applicative
10:42:26 <amf> so many things just clicked in my head
10:42:55 <mniip> happens every so often
10:43:38 <thewormkill> yes, it's a common disease ;)
10:43:54 <dford> adam789654123: ok, then I guess its better to stick with N1
10:44:20 <adam789654123> dford: that seems like a good idea for now
10:44:40 <mniip> you never stop learning things
10:45:12 <Gurkenglas> Now go find some more questions, we're on a roll
10:45:57 <mniip> Gurkenglas, did you know, TypeInType lets you write a KindOf family
10:46:49 <mniip> and apparently, kind level arrows are no different from function arrows
10:47:07 <Gurkenglas> Never heard of TypeInType, what would KindOf do?
10:47:31 <mniip> KindOf :: (a :: k) -> k
10:47:42 <mniip> er
10:48:01 <mniip> KindOf (a :: k) = k
10:48:18 <mniip> that made no sense as a type signature
10:48:27 <Gurkenglas> Could you even put (a :: k) as a top-level type it, rather than as a parameter for a type constructor?
10:48:36 <Gurkenglas> -it
10:48:48 <mniip> ?
10:49:14 <Gurkenglas> Your "that made no sense as a type signature" answers the question I was trying to ask with no :P
10:49:49 <mniip> anyway
10:50:00 <Gurkenglas> Could you do ArgumentOf (t a) = a?
10:50:50 <benzrf> the kind system is dependently kinded right
10:50:55 <mniip> you can do that even now
10:50:59 <Gurkenglas> Which would be ((k -> *) k) -> k
10:51:08 <benzrf> Gurkenglas: what no
10:51:12 <Gurkenglas> (effectively * -> k)
10:51:20 <benzrf> (k -> *) :: Type
10:51:24 <benzrf> so you can't apply it
10:51:25 <mniip> k -> l actually
10:51:51 <benzrf> what happens if you apply it to something that wasn't an application
10:51:53 <benzrf> ArgumentOf Int
10:52:03 <mniip> it doesn't
10:52:17 <benzrf> what
10:52:20 <mniip> the type family never inlines
10:52:34 <benzrf> what a shitty type system tbh
10:52:37 <Gurkenglas> benzrf, bottom out
10:52:51 <mniip> @let type family F a where
10:52:51 <lambdabot>  Parse failed: Parse error: EOF
10:53:05 <Gurkenglas> * -> * is a "subkind" of *, right?
10:53:06 <mniip> @let type family F a where F () = ()
10:53:07 <lambdabot>  Defined.
10:53:13 <benzrf> Gurkenglas: no
10:53:22 <mniip> :t undefined :: F Int
10:53:23 <lambdabot> F Int
10:53:36 <mniip> same as this case benzrf
10:53:42 <Gurkenglas> Okay so ArgumentOf would be ((k -> l) k) -> k, effectively l -> k?
10:54:02 <mniip> Gurkenglas kind-of
10:54:04 <benzrf> Gurkenglas: the first thing there is not a well-kinded expression
10:54:10 <mniip> pun intended
10:54:43 <Gurkenglas> How do you say what I tried to say there well-kindedly?
10:54:43 <benzrf> Gurkenglas: (k -> l) is not a function, you cannot apply it
10:54:48 <benzrf> you don't
10:54:54 <benzrf> the idea you have is not one that makes sense
10:54:59 <benzrf> i know what it is, and it doesn't make sense
10:55:30 <Gurkenglas> Why not?
10:55:33 <benzrf> (Maybe Int) :: *
10:55:34 <mniip> I think they mean ($) :: (k -> l) -> k -> l
10:55:44 <benzrf> therefore, if you can apply ArgumentOf to Maybe Int
10:55:50 <benzrf> the input type of ArgumentOf must be *
10:56:02 <mniip> and ((k -> l) $ k) -> k
10:56:21 <mniip> oh wait that still makes none
10:56:32 <benzrf> Gurkenglas: what you're trying to do is find a type for (t a) that indicates that (t a) is an application
10:56:36 <benzrf> but that just can't work
10:56:42 <benzrf> not without fundamentally reworking the type system
10:56:54 <Gurkenglas> I don't need that, it's okay if ArgumentOf is partial, that's what I expected
10:57:51 <benzrf> basically the mistake you're making is
10:57:56 <benzrf> it's like if i did this:
10:58:03 <benzrf> argOf (f x) = x
10:58:11 <benzrf> argOf :: ((a -> b) a) -> a
10:58:15 <Gurkenglas> ("((k -> *) k) -> k" was expected to immedaitely reduce to "* -> k" without preserving the information that it's applied)
10:58:45 <benzrf> no, "((k -> *) k)" doesn't make sense in the first place
10:58:52 <mniip> Gurkenglas, if a :: t and b :: s
10:59:00 <Gurkenglas> It makes as much sense as (a -> b) a
10:59:02 <mniip> then a b :/: t s
10:59:04 <benzrf> Gurkenglas: exactly
10:59:09 <benzrf> that is to say: none at all
10:59:19 <Gurkenglas> And it was to supposed to, as much sense as pseudocode
10:59:40 <benzrf> ehh
11:00:02 <Gurkenglas> argOf (f x) = x
11:00:08 <Gurkenglas> argOf :: f a -> a
11:00:13 <Gurkenglas> *F
11:00:20 <Gurkenglas> "argOf :: F a -> a"
11:00:36 <benzrf> wat
11:00:39 <mniip> ($) :: * -> * -> *; (k -> l) $ k = l
11:00:41 <Gurkenglas> Where F is a data type that has at least one constructor named f (oh wait they need to be capital right)
11:00:50 <mniip> there I formulated what you are tying to say
11:00:51 <Gurkenglas> Let me rewind all my lines since your ehh. Now:
11:01:19 <Gurkenglas> Let me do to your example what I want someone to do to my example
11:01:30 <Gurkenglas> argOf (Just x) = x
11:01:34 <Gurkenglas> argOf :: Maybe a -> a
11:01:48 <Gurkenglas> Only with any constructor in palce of Maybe.
11:02:10 <benzrf> but maybe has the special proprety that it includes the type of its argument in its output type
11:02:20 <benzrf> not all constructors do that
11:02:27 <Gurkenglas> ArgumentOf only needs to work for those that do that
11:02:33 <mniip> no
11:03:04 <mniip> ArgumentOf works on kind monomorphic types
11:03:15 <Gurkenglas> kind monomorphic types?
11:03:40 <mniip> :k Maybe
11:03:41 <lambdabot> * -> *
11:03:51 <mniip> as opposed to say
11:03:57 <mniip> :k Proxy
11:03:58 <lambdabot> k -> *
11:04:07 <benzrf> i cant wait for when i can write nonterminating programs in my type signatures~
11:04:15 <mniip> you can
11:04:17 <benzrf> now THAT will annoy people trying to compile my code
11:04:24 <benzrf> woo hoo
11:04:26 <parsecChar> can anyone familiar with TH tell me how to genererate the bottom part from the top part ?
11:04:31 <parsecChar> https://gist.github.com/anonymous/082813b48ccd70563737
11:04:54 <mniip> type family F a where F a = [F a]
11:05:19 <Gurkenglas> Why is Proxy not * -> *?
11:05:23 <roelof> Is there anyone who can confirm that I can install ghc-mod on a Windows box  ? 
11:05:25 <benzrf> mniip:     Application is no smaller than the instance head
11:05:26 <mniip> benzrf, have you seen my fizzbuzz
11:05:31 <benzrf> probably not =3
11:05:46 <mniip> needs 5 gb of ram to count to 100
11:05:52 <glguy> parsecChar: You'll use "reify" to turn the Name ''GlobalState into an Info, extract the Dec from that, and then produce a new Dec based on the orgiinal
11:06:08 <orion> https://hackage.haskell.org/package/postgresql-simple-0.5.1.2/docs/Database-PostgreSQL-Simple-ToField.html#t:ToField <-- Are all of these instances considered orphans?
11:06:30 <roelof> mniip:  what sort of computer did you use ? 
11:06:30 <mniip> https://github.com/AbstractBeliefs/BadBuzz/blob/master/Haskell/mniip.hs
11:06:50 <liste> orion: no, they're defined in the same module as the class
11:07:03 <nshepperd> Gurkenglas: so you can do Proxy 4 or Proxy Monad or Proxy '[Int, Char]
11:07:20 <benzrf> mniip: dear god
11:07:38 <orion> liste: Ah, yes.
11:08:04 * hackagebot implicit-logging 0.1.0.0 - A logging framework built around implicit parameters.  https://hackage.haskell.org/package/implicit-logging-0.1.0.0 (rev_null)
11:08:06 * hackagebot meep 0.1.2.1 - A silly container  https://hackage.haskell.org/package/meep-0.1.2.1 (DmitryMalikov)
11:08:31 <Gurkenglas> Dang, was still thinking * is the superkind to all others
11:09:53 <Gurkenglas> Why would ArgumentOf not work on k -> *, turning Proxy Monad back into Monad?
11:11:54 <mniip> it would
11:13:12 <Gurkenglas> "<mniip> ArgumentOf works on kind monomorphic types" - oh, that wasn't "works only", looked a lower bound for what it works on because it was after "no" after "Gurkenglas> ArgumentOf only needs to work for those that do that"
11:13:25 <nshepperd> are we still at the value level or what?
11:13:26 <Gurkenglas> *looked like
11:14:51 <mniip> oh I just realized
11:15:07 <Gurkenglas> Okay I think we got lost somewhere (so much for the roll), let's try again: Could you do ArgumentOf :: l -> k, which would turn StateT s Maybe into s and Proxy Monad into Monad?
11:15:26 <mniip> the reason dependently kinded families don't apply in such cases
11:15:29 <roelof> Is there anyone who can confirm that I can install ghc-mod on a Windows box  ?  
11:15:35 <mniip> is because they are partial...
11:15:40 <mniip> ... in the kind
11:15:50 <mniip> in the hidden kind arguments
11:16:27 <mniip> Gurkenglas, it would turn StateT s Maybe into Maybe
11:16:40 <Gurkenglas> Hmm, makes sense
11:16:47 <mniip> f ~ StateT s
11:17:29 <Gurkenglas> Of course we also want ConstructorOf :: k -> k, turning them into StateT s and Proxy
11:17:41 <Gurkenglas> *l -> k i meant to say
11:17:54 <Gurkenglas> Although actually it would be l -> (k -> l)
11:18:03 <mniip> yes
11:18:07 <mniip> exactly
11:18:07 <nshepperd> type family ArgumentOf (x :: k1) :: k2 where { ArgumentOf (Proxy x) = x }
11:18:23 <nshepperd> that actually compiles
11:18:35 <mniip> and if you try F (f a) = f a
11:18:49 <mniip> you hit a ghc bug
11:19:54 <nshepperd> 'No instance for (Monad (ArgumentOf (Proxy Monad)))' :(
11:20:08 <nshepperd> oh wait, that's just me being dumb
11:20:10 <Gurkenglas> Well yea Monad isn't a monad
11:20:29 <nshepperd> 'return 3 :: ArgumentOf (Proxy Monad) m => m Int' :D
11:21:23 <nshepperd> Gurkenglas: I think it is actually, in some kind of crazy higher order way. but it's not a Monad, that's for sure
11:24:02 <Gurkenglas> Is the thing of things that are not instances of themselves in a kind of crazy higher order way an instance of itself in a kind of crazy higher order kind of way?
11:24:36 <Gurkenglas> -the last "kind of"
11:25:28 <nshepperd> i think the proper answer to that is the empty set
11:25:59 <Gurkenglas> you mean the set of proper answers to that is empty
11:29:14 <geekosaur> crazy higher order way? surely it's the empty category... :p
11:29:36 <the_2nd> I have a function in a lib which takes another func as argument as callback
11:29:52 <the_2nd> the user may pass a pure or IO function there, which I will then call
11:30:14 <the_2nd> is there some way to define my function that I wont have to implement it for both cases?
11:30:45 <the_2nd> (a -> b) -> c   vs (a -> IO(b) ) -> IO (c)
11:31:05 <Gurkenglas> Implement it for all Applicatives (or failing that for all Monads) like on the right side
11:31:18 <Gurkenglas> Then you can put in IO or Identity.
11:31:47 <the_2nd> but then the function user has to be within IO?
11:31:48 <EvanR> make a (a -> b) -> c version and a (a -> IO b) -> IO c version and name it slighly different, if it doesnt make sense for all monads
11:31:54 <Gurkenglas> That's how mtl does it - though you'll probably still want to define aliases for the Identity stuff, so the user doesn't have to put Identity and runIdentity everywhere (or just coerce)
11:31:55 <Moggle> Hey there, I'm playing around with lenses, and I'm wondering if there's a more elegant way to formulate the idea of applying a bunch of lenses, one after another. I've got something like foldr (\(lens, data) acc -> acc & lens .~ data) origData [(someLens, val1), (someLens2, val2), ... and so on]
11:32:13 <EvanR> dont try to overload too much different stuff on 1 name
11:32:28 <the_2nd> coolFunc && coolFuncIO
11:32:42 <Gurkenglas> Moggle, lenses compose as functions do
11:32:52 <EvanR> if IO is not actually involved then
11:32:54 <EvanR> coolFuncM
11:33:01 <Gurkenglas> Ever did something like "first . liftM . fmap"? You've been composing lenses in your head
11:33:13 <Moggle> Gurkenglas, so you'd recommend rewriting it as origData & someLens .~ val1 . someLens2 .~ val2
11:33:16 <Moggle> and so on?
11:33:27 <the_2nd> EvanR, I want to enable the user to e.g. run other programs to prduce a callback result
11:33:42 <EvanR> i dont understand
11:33:44 <Gurkenglas> Oh wait shoot I misread, sorry
11:33:54 <Moggle> basically I'm trying to replicate record syntax, since I am a fan of it
11:34:09 <Moggle> so I might be like origData {some1=val1, some2=val2}
11:34:11 <Gurkenglas> Moggle, (\(lens, data) acc -> acc & lens .~ data) is (\(lens, data) -> lens .~ data)
11:34:12 <Moggle> but doing it through lenses
11:34:25 <tomus> http://pastebin.com/722NZtyX <- struggling with T.Text and JSON
11:34:26 <Moggle> ahhh, okay that's right
11:34:27 <LysergicDreams> How can I abstract this code out: http://sleepanarchy.com/p/gaCOj4
11:34:28 <Gurkenglas> ((&) just applies the argument on the left to the function on the right)
11:34:40 <Gurkenglas> and (\(lens, data) -> lens .~ data) is just uncurry set
11:35:43 <LysergicDreams> tomus: "deriving (Show, Generic)"
11:35:46 <Moggle> thanks Gurkenglas, I read like three tutorials last night so I'm still relatively uncomfortable with this. But using a fold is the right approach in this situation?
11:35:55 <Moggle> there's nothing super recordy i can do?
11:36:40 <EvanR> the_2nd: a function of type literally (a -> b) -> c seems hard to implement 
11:36:44 <Gurkenglas> "origData & someLens .~ val1 . someLens2 .~ val2" sounds pretty good, and remember to eta-reduce the origData out if it's also the single argument to your function
11:37:07 <Gurkenglas> But if it's just records you're accessing, there sure is something super recordy you can do
11:37:12 <Moggle> use them :P
11:37:19 <Moggle> in this case, i can't because the data type isn't a record
11:37:35 <Moggle> i blame Persistent for not having an option to generate it that way
11:37:40 <the_2nd> EvanR, it's actually (manyParams -> a) -> a
11:38:06 <Moggle> but thank you Gurkenglas, I appreciate the feedback there. The last solution there seems most elegant, I suppose, though it's still a little ugly in my opinion :P
11:38:17 <the_2nd> or : (manyParams, manyParams) -> (manyParams -> a) -> a
11:38:22 <EvanR> (P1 -> P2 -> P3 -> ... -> a) -> a ?
11:38:35 <Gurkenglas> -single argument +last argument
11:38:42 <the_2nd> where manyParams might be a list or dict, dunno yet
11:38:56 <EvanR> hrm, sounds like you could stand to do some currying
11:39:06 <EvanR> or another way to be more flexible with the params than a list or map
11:39:08 <mniip> the_2nd, dict?
11:39:26 <the_2nd> dictionary in case haskell has one
11:39:34 <Gurkenglas> the_2nd, https://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html
11:39:47 <parsecChar> is there a MVar functino which is "MVar a -> (a -> a) -> Maybe a"; so (1) if the MVar is empty, it returns with Nothing, (2) if the MVar has a value, apply the function and return (Just $ f a)
11:39:48 <mniip> haskell has no built-in "dict" type
11:39:48 <EvanR> a Map can be cumbersome, perhaps you want the monoid configurator pattern
11:39:52 <mniip> there's Data.Map
11:40:16 <the_2nd> yeah, that's all fine I think
11:40:23 <EvanR> the_2nd: you cant write that function without IO
11:40:24 <the_2nd> the issue was the non IO and IO versions
11:40:40 <EvanR> checking MVars requires IO
11:41:05 <the_2nd> EvanR, I guess you mean parsecChar 
11:41:18 <EvanR> oh
11:41:26 <parsecChar> is there a MVar functino which is "MVar a -> (a -> a) -> IO (Maybe a)"; so (1) if the MVar is empty, it returns with Nothing, (2) if the MVar has a value, apply the function and return (Just $ f a)
11:41:29 <parsecChar> I'm okay with the IO
11:41:39 <parsecChar> I just want a "tryModify -- but don't block"
11:42:10 <nshepperd> Moggle: you could have a function like `(!*!) :: Lens' s a -> Lens' s b -> Lens' s (a,b)` and do `(lens1 !*! lens2 !*! lens3) .~ (val1, (val2, val3))`?
11:42:13 <nshepperd> or something like that
11:42:19 <nshepperd> seems possible
11:42:26 <the_2nd> EvanR, it's an optimisation function, which takes many min/max values, a way to calculate a result from the parameters and returns the best result
11:42:36 <Gurkenglas> Is there something like PrismT that puts whether the prism succeeds into monadic context?
11:42:49 <EvanR> the_2nd: oh so its a bunch of numbers
11:43:05 <EvanR> carrry on
11:43:19 <the_2nd> carried it all the way :D
11:43:20 <tomus> LysergicDreams: Main.hs|33 col 19 error| Expected kind ‘(* -> *) -> ghc-prim-0.4.0.0:GHC.Prim.Constraint’, but ‘Generic’ h ...? 
11:43:46 <Moggle> nshepperd: that could be interesting too, though i'm hesitant to go with it. ideally, you keep the lens and the data value you want to set with each lens close to each other, so the solution with origData & (lens .~ 1) . (lens2 .~ "hi") seems much more pleasant in that regard to me 
11:43:53 <the_2nd> EvanR, like so in Haskell https://github.com/i3ck/cppOpt
11:43:59 <Moggle> just trying to do a recordy sort of thing where none exist.
11:48:03 <sphinxo> So I have a couple of data types that are connected in a grid like structure
11:48:25 <mniip> grid like structure?
11:48:27 <sphinxo> in another languages I might have a pointer to the other data types in the data type
11:48:51 <sphinxo> Have you seen the game TIS-100?
11:48:56 <EvanR> struct foo { foo* dirs[4]; }
11:49:05 <sphinxo> I would like to write an emulator 
11:49:34 <mniip> you said you have multiple data *types* connected in a grid
11:49:36 <EvanR> in haskell you would probably not do it this way but use a Map
11:49:37 <mniip> so I was confused
11:49:45 <liste> sphinxo: related: https://github.com/quchen/articles/blob/master/loeb-moeb.md
11:49:46 <sphinxo> ahh ok
11:49:55 <EvanR> youre implementing a Graph, so one way is a map of connections
11:50:30 <Gurkenglas> LysergicDreams, http://sleepanarchy.com/p/XSXWVG
11:50:31 <lpaste> tomus pasted “Expected kind ‘(* -> *) -> ghc-prim-0.4.0.0:GHC.Prim.Constraint’, but ‘Generic’ has kind ‘(* -> *) -> *’” at http://lpaste.net/4395566768785981440
11:50:59 <Gurkenglas> LysergicDreams, I mean http://sleepanarchy.com/p/TZsXCK
11:51:36 <sphinxo> liste: that's really interesting
11:51:39 <Gurkenglas> Also dammit that can't work because overlapping instances, nevermind ._.
11:51:56 <EvanR> loeb eh...
11:52:20 <liste> that's one way to approach the problem
11:52:31 <EvanR> recursive data is cool but you cant updated it or save/restore it easily
11:53:59 <hexagoxel> tomus: Data.Generics.Generic /= GHC.Generics.Generic
11:55:04 <tomus> hexagoxel: thank you!
11:55:11 <the_2nd> liste
11:55:13 <ocfx> ha i knew unsymbol would be here
11:55:15 <EvanR> liste: what does loeb and moeb stand for?
11:55:34 <Gurkenglas> LysergicDreams, http://sleepanarchy.com/p/uhU6RE
11:55:43 <the_2nd> could loeb be used to implement this in haskell? => https://github.com/i3ck/cppautosolve
11:56:06 <the_2nd> in there you define a graph of functions, their outputs and inputs
11:56:15 <the_2nd> runtime decides which variables are known
11:56:23 <the_2nd> and then tries to solve as much as possible
11:56:44 <the_2nd> loeb seems to be capable to do something similar
11:57:37 <LysergicDreams> Gurkenglas: ooh, thank you :)
11:58:06 <EvanR> head explode
11:58:51 <Gurkenglas> (Of course it should say named rather than category in lines 30 and 31)
11:59:22 <liste> EvanR: I don't know. I guess they come from Hofstadter's books, that I haven't read (but I really should). I think Löb is someone's name
11:59:33 <EvanR> ah
11:59:48 <Gurkenglas> (Also all List should be replaced by "JSONList" <.<)
11:59:49 <liste> the post is from quchen who seems to hang out here too
11:59:56 <Gurkenglas> Use lpaste, you can edit on there. Mostly.
12:00:58 <the_2nd> liste ^
12:01:14 <Gurkenglas> Hang out where?
12:01:21 <mniip> liste, hey
12:01:40 <mniip> did you see my position-polymorphic functors
12:02:00 <liste> the_2nd: it could be used in some solutions, but not sure if they'd be the most readable/flexible ones
12:02:04 <liste> mniip: no, show me!
12:02:09 <liste> Gurkenglas: #haskell
12:02:33 <Gurkenglas> Gah, I read your "here" as "there" :(
12:02:42 <EvanR> everywhere
12:02:51 <mniip> liste, http://lpaste.net/154525
12:03:00 <the_2nd> liste, wondering whether this could be implemented in haskell
12:03:27 <liste> the_2nd: yes it can
12:03:51 <the_2nd> liste, what would you use / do ? any similar projects yet?
12:04:05 <mniip> liste, just one problem, it hits a GHC bug that is only fixed in ghc head https://ghc.haskell.org/trac/ghc/ticket/11699
12:04:38 <EvanR> mniip: oh god
12:04:45 <EvanR> what stage of evolution of a haskell programmer are you
12:04:51 <mniip> I don't know
12:05:02 <mniip> it's pretty weird considering I don't know any advanced TT or CT
12:06:27 <EvanR> mniip: how does this mess work?
12:06:40 <the_2nd> EvanR, it doesn't
12:06:44 <the_2nd> he kills the compiler
12:06:45 <the_2nd> :D
12:06:52 <mniip> EvanR, SubsFam is a type family that substitutes nth argument in a constructor
12:07:04 <mniip> so like
12:07:24 <mniip> SubsFam 2 (Foo a b c d e f) x = Foo a b c x e f
12:07:45 <mniip> except, to ensure fundeps, since d is lost anyway, we ensure that d ~ HOLE
12:07:47 <liste> mniip: awesome! I wonder if there's something similar in Agda/Idris
12:07:53 <liste> type-level naturals are wieldy
12:07:54 <EvanR> ok
12:08:43 <mniip> then we say that contravariant mapping has the signature  n -> (a -> b) -> SubsFam n a s -> SubsFam n b s
12:09:00 <mniip> n is of the wrong kind so we wrap it in an arbitrary proxy
12:09:04 <benzrf> ok, controversial statement here:
12:09:13 <benzrf> why should haskell programmers give a crap about CT
12:09:16 <mniip> and for better type inference, we add a typeclass with fundeps
12:09:17 <quchen> Loeb? I have no affiliation with that ;-)
12:10:39 <Gurkenglas> mniip, wouldn't that be covariant
12:10:46 <mniip> er
12:10:47 <mniip> yes
12:10:51 <mniip> that's covariant
12:11:50 <Gurkenglas> Can you elaborate on "n is of the wrong kind"?
12:11:52 <mniip> EvanR, it's weird, I have a haskeller mind so I just combine the simple tools I've got to achieve what I need
12:12:00 <mniip> even if that's typesystem wizardy
12:12:04 <mniip> Gurkenglas, n :: N
12:12:09 <EvanR> benzrf: why should any programmer give a crap really, and i think theres some books which try to argue why
12:12:14 <mniip> to appear on the left side of a -> it needs to be *
12:12:38 <EvanR> http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
12:13:04 <mniip> EvanR, jej 503
12:13:09 <benzrf> i know a little category theory, and i know a bit of math, and im pretty ok at haskell
12:13:14 <benzrf> and i dont really see much of a connection
12:13:31 <EvanR> mniip: 503?
12:13:40 <mniip> Service unavailable
12:13:48 <EvanR> i can see it
12:14:42 <mniip> yeah it was a one time error
12:14:44 <benzrf> hmmmmmmmm
12:14:51 <benzrf> i guess.... maybe if
12:14:54 <benzrf> ah, i see
12:14:57 <EvanR> benzrf: this blog post seems to be the LYAH of why programmers should generally understand categorical stuff, i havent read the whole thing but it has cool pictures ;)
12:15:06 <EvanR> er blog not just 1 post
12:15:25 <benzrf> so the argument is that programmers deal with enough categories that CT provides abstractions that are useful for them?
12:15:30 <EvanR> if anything it will at least explain why some people THINK categories matter
12:15:33 <benzrf> that's pretty fair
12:17:25 <xa0> possible to implement unzip using applicatives/functors/bifunctors?
12:17:42 <desophos> interesting link EvanR 
12:17:45 <xa0> [(a, b)] -> ([a], [b])
12:17:48 <LysergicDreams> Gurkenglas: I'm getting "The class method 'name' mentions none of the type or kind variables of the class 'Named a'"
12:18:25 <desophos> i liked the first chapter (lambda calculus) of the haskell book, will i like type and category theory? :o 
12:19:18 <simpson> desophos: Hard to say.
12:19:45 <Cooler> whats a good gui library?
12:19:49 <simpson> desophos: Some people really like the universal and abstract nature of category theory; some people detest it, too.
12:20:28 <desophos> well i at least enjoyed learning very basic lambda calculus -- would it be useful to explore it more? that is, would learning more of the lambda calculus make me a better (Haskell) programmer?
12:21:19 <shachaf> Lambda calculus is so simple that there isn't much to learn about it.
12:21:54 <simpson> desophos: Yeah, but both type theory and category theory are very orthogonal to the lambda calculus.
12:21:57 <benzrf> i'd advise that learning category theory outside of the scope of "CT for haskellers" is almost completely pointless if you don't already know *at least* some topology and algebra
12:21:58 <shachaf> So, sure, you should probably learn everything there is to learn about it. Most of it you'd learn automatically as part of learning Haskell.
12:22:03 <Gurkenglas> LysergicDreams, aww, that's stupid. Try this http://sleepanarchy.com/p/xZL1L9
12:22:24 <desophos> hmm okay
12:22:37 <Cooler> anyone?
12:22:44 <shachaf> I don't think you need to know much topology.
12:22:51 <desophos> well i'll go through more of the haskell book first :) i know very little math
12:23:00 <desophos> (relatively)
12:23:12 <shachaf> Of course you should know some algebra because a category is an algebraic structure.
12:23:17 <Gurkenglas> LysergicDreams, gah again missed the JSONList thing. http://sleepanarchy.com/p/X1vM0O
12:23:38 <mniip> xa0, yes
12:23:51 <benzrf> shachaf: i'm not saying you can't learn the definitions without them
12:23:57 <xa0> mniip: might i ask how? :p
12:24:03 <mniip> :t foldr (\(x, y) -> bimap (x:) (y:)) ([], [])
12:24:04 <lambdabot> Foldable t => t (a, a1) -> ([a], [a1])
12:24:10 <xa0> ooh
12:24:15 <xa0> very tidy
12:24:16 <benzrf> shachaf: just that that's kind of a baseline amount of background necessary to know enough applications and examples for anything to seem meaningful
12:24:21 <xa0> mniip: thanks!
12:24:30 <Cooler> what a good gui library for haskell?
12:24:38 <Cooler> what's*
12:24:42 <shachaf> Maybe.
12:25:42 <shachaf> Learning category theory is pointless even if you do know topology and algebra.
12:26:05 <mniip> :t bipure
12:26:06 <lambdabot>     Not in scope: ‘bipure’
12:26:06 <lambdabot>     Perhaps you meant one of these:
12:26:06 <lambdabot>       ‘pure’ (imported from Control.Applicative),
12:26:16 <Gurkenglas> good - gui library - haskell: choose two :P
12:26:21 <mniip> not in scope huh
12:26:41 <shachaf> i,i good - gui library: choose one
12:26:53 <Cooler> noone?
12:28:06 <mniip> the problem with CT is that it's a not often traversed field so it's full of things with a rather prerequisitive definition
12:28:24 <benzrf> mniip: huh?
12:28:31 <mniip> along the lines of, monads are monoids in the category of endofunctors
12:28:33 <shiin> I'd like to install the current stable Haskell Platform on Debian Wheezy, but haven't been successful so far.
12:28:43 <benzrf> mniip: nah
12:28:49 <mniip> of course, there are hundreds of other simpler definitions of monads,
12:28:52 <mniip> but in CT that is rarely so
12:29:03 <benzrf> mniip: i can say things like that in any field of math
12:29:05 <benzrf> it's  not a CT thing
12:29:14 <mniip> benzrf, this is not about "can"
12:29:22 <mniip> this is about whether you can say something simpler than that
12:29:28 <benzrf> you can, though
12:29:32 <shiin> First I tried to download the haskell-platform source and compile it. I found out haskell-platform needs cabal-install, so I downloaded the cabal-install source and tried to compile it. I found out cabal-install needs ghc, so I downloaded the ghc source and tried to compile it. I found out ghc wants ghc installed, so I installed ghc using apt-get. But the ghc on Wheezy is too old. What do I do now?
12:29:47 <mniip> well even if you can, it's hard to find a simplified explanation
12:29:58 <simpson> mniip: Perhaps that means that the concept at hand is not simple.
12:29:58 <benzrf> i don't think anybody defines them as monoids in a category of endofunctors
12:30:02 <benzrf> that's a joke phrase
12:30:02 <xa0> i understand why it is the way it is, but i still feel like there could be nicer treatment of tuples in haskell...
12:30:20 <benzrf> xa0: perhaps you want dependent typing
12:30:25 <mniip> xa0, yeah,
12:30:32 <simpson> mniip: It wouldn't be the first time that such a thing has happened; consider the trickery of e.g. refining aluminium, a process that eluded humanity for many centuries.
12:30:32 <mniip> we should throw away triples and anything above that
12:30:33 <xa0> not again...
12:30:34 <mniip> and only use pairs
12:30:41 <xa0> ah!
12:30:44 <xa0> i see your thinking
12:30:46 <xa0> yes
12:30:46 <mniip> that would be nicer treatment
12:30:53 <xa0> yes i agree
12:31:02 <simpson> mniip: While I was out on a walk, I witnessed an isomorphism between (x, (y, z)) and (x, y, z). Halp?
12:31:11 <benzrf> ( ͡° ͜ʖ ͡°)
12:31:14 <xa0> lol
12:31:31 <Gurkenglas> And perhaps there could be syntax sugar to treat (a, b, c) as (a, (b, c))
12:31:42 <LysergicDreams> Gurkenglas: Type mismatch: http://sleepanarchy.com/p/LKbUMC#L
12:31:43 <benzrf> simpson: you should be careful, you might get decomposed into component functions
12:31:52 <mniip> simpson, not sure I'm understanding the joke here
12:32:14 <simpson> mniip: Informally, I can still make triples even if I only have pairs.
12:32:18 <hpc> Gurkenglas: sometimes it's more convenient to have it as ((a, b), c)
12:32:20 <mniip> that's my point
12:32:46 <Gurkenglas> hpc, then you'd have to write it out, like in (a -> b) -> c
12:32:49 <simpson> mniip: And of course, in ZF, we usually don't even have pairs, we just have the convention that {x, {x, y}} is the same as (x, y).
12:33:08 <benzrf> mniip: the problem with category theory is simply that it is an answer to a question that nobody would think to ask until they already know a lot of math
12:33:26 <mniip> benzrf, right
12:33:39 <benzrf> and it's not a "problem", really, any more than it's a problem that typeclasses are an answer to a question no non-programmer would ask
12:33:47 <mniip> it's easy to say that X = Y Z T W if you know what all 5 of those are
12:33:50 <simpson> "All problems are self-inflicted."
12:34:08 <benzrf> mniip: don't see how that connects to what i said
12:34:26 <Gurkenglas> :t (curry . curry . curry, uncurry . uncurry . uncurry) -- then again, this
12:34:27 <lambdabot> (((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c, (a1 -> b5 -> b4 -> b3 -> c1) -> (((a1, b5), b4), b3) -> c1)
12:34:31 <simpson> mniip: Another way to look at it: Informally, I can give you fmap and tell you that it lets you alter all the values in a structure without changing the shape of the structure.
12:34:39 <mniip> what I'm saying is that prerequsites to CT are higher than they could have been
12:35:08 <simpson> mniip: Category theory, AIUI, was invented to formalize that idea of "without changing the shape" and related stuff; MacLane himself said that he wrote about CT because he wanted to study natural transformations.
12:35:09 <EvanR> (a,b,c) =~ (a,(b,c)) but dont ask me to implement them that way 
12:35:49 <EvanR> xa0: meh who ever uses triples anyway ;)
12:35:57 <xa0> lol
12:35:57 <EvanR> pairs is all you need
12:36:08 <mniip> EvanR, I did use triples once in a State-like setup
12:36:25 <Gurkenglas> LysergicDreams, I wrote "usingName $ (o .:) >=> parseJSON", you wrote "usingName (o .:) >=> parseJSON"
12:36:30 <EvanR> hell i use a custom type instead of pairs
12:36:33 <mniip> state-writer specificaly
12:36:37 <EvanR> (for state-like setup)
12:37:37 <benzrf> mniip: what i'm saying is that they're not
12:37:55 <benzrf> mniip: category theory is simply an answer to a question that nobody would think to ask until they already know a lot of math
12:38:04 <xoitx> hello
12:38:04 <xoitx> :D
12:38:29 <EvanR> benzrf: except people come in here all the time asking about CT when they dont know anything
12:38:33 <mniip> benzrf, that's was thought before
12:38:54 <mniip> not so much anymore
12:39:38 <xoitx> anyone use openFoam?
12:39:41 <marrrk> Hey guys. Do you know some tutorial about servant, how I can get started creating a simple server and especially also setting the project up with stack?
12:40:40 <Cooler> need some help with cabal
12:40:53 <Cooler> i am trying to install the gtk package
12:41:10 <Cooler> but its failing when trying to build one of its dependencies
12:41:13 <Cooler> glib
12:41:54 <Cooler> setup.exe: The program 'pkg-config' version >=0.9.0 is required but it could
12:41:54 <Cooler> not be found.
12:41:59 <srhb> Cooler: That's a C dependency, cabal will not install it for you.
12:42:20 <Gurkenglas> What exception does modifyMVar produce when the MVar is empty?
12:42:21 <Cooler> its not listed as a dependency on the glib page on hackage
12:42:37 <Cooler> where can you get that from program srhb ?
12:43:18 <Cooler> the official page for gtk2hs http://projects.haskell.org/gtk2hs/ is not accessible, its giving an error
12:43:21 <srhb> Cooler: Have you followed the guide? http://code.haskell.org/gtk2hs/INSTALL
12:43:27 <Cooler> Error establishing a database connection
12:43:51 <Cooler> oh theres a guide?
12:44:00 <Cooler> where did you find that?
12:44:01 <srhb> Cooler: That said, if you're on Windows, I'm not sure the chances of success are very great. You might want to opt for a simpler gui toolkit.
12:44:11 <benzrf> mniip: nah
12:44:18 <srhb> Cooler: I googled it.
12:44:42 <benzrf> mniip: there are some parts of CT that are relevant, but overall the stuff that applies to programmers is very differently flavored than what CT already is
12:45:04 <mniip> that depends
12:45:31 <mniip> like of course it's hard to write haskell if you aren't familiar with the CT concept of functors,
12:45:39 <mniip> but then you open some edwardk library and see
12:45:44 <mniip> costate comonad coalgebras
12:45:50 <mniip> and you're like, the hell
12:46:51 <benzrf> functors in haskell have little to do with functors in category theory in terms of what you're thinking about imho
12:46:56 <srhb> marrrk: The servant tutorial doesn't cover installation as such, but it should be as simple as any other trivial stack project, so you can just drop the deps in and get going.
12:47:08 <srhb> marrrk: And the tutorial does get you setup with a simple served api.
12:47:08 <benzrf> well
12:47:16 <shachaf> That phrase is deliberately phrased to sound confusing.
12:47:16 <benzrf> i dont really know enough to make statements like that i suppose
12:47:19 <mniip> benzrf, well they're endofunctors on hask
12:47:25 <shachaf> I don't think the name "costate" is even really justified.
12:47:27 <marrrk> srhb: Is there a simple stack tutorial on its own then?
12:47:44 <mniip> shachaf, that talks about the store comonad, right?
12:47:47 <benzrf> mniip: so what?
12:47:49 <shachaf> Yes.
12:48:01 <srhb> marrrk: This should suffice: https://github.com/commercialhaskell/stack/wiki/New-to-Haskell
12:48:05 <xa0> costate == store
12:48:19 <shachaf> xa0: Why call it costate?
12:48:23 <shachaf> In what sense is it dual?
12:48:32 <mniip> in the same sense as coreader and cowriter?
12:48:46 <marrrk> thanks srhb 
12:48:48 <xa0> in the sense that you take the two functions which when composed give state, and swap them 
12:49:18 <shachaf> mniip: Are those names justified?
12:49:38 <shachaf> Usually with F -| G -| H, people say that F and H are dual.
12:49:53 <mniip> huh
12:50:04 <shachaf> I think saying that F and G, or FG and GF, are dual is pretty unusual.
12:50:25 <shachaf> Is Store "State in Hask^op"?
12:50:43 <xa0> state is a -> (s, a), which is a composition of (->) and (,), do it the other way around and you get (s, s -> a)
12:50:49 <LysergicDreams> Gurkenglas: After that, just had to add 'FromJSON a' requirement in Named class to get it to work - Thanks :)
12:50:58 <shachaf> I guess there's a sense in which (e,) and (e->) are dual, since the former is a sum and the latter is a product.
12:51:32 <Lokathor> how does one diable a flag in ghci once it's been set?
12:51:34 <shachaf> Like exists and forall.
12:51:37 <Gurkenglas> LysergicDreams, I would add it in the instance Named a => FromJSON (JSONList a) line instead
12:51:44 <shachaf> Depends on the flag.
12:51:56 <Lokathor> i want to turn off OverloadedStrings in this case
12:52:09 <shachaf> :set -XNoOverloadedStrings
12:52:32 <Lokathor> perf
12:53:42 <mniip> shachaf, that sounds nonsensical
12:53:53 <shachaf> What does?
12:54:17 <mniip> saying that "duality" has a definition and that all other uses of "dual" are unjustified
12:54:41 <shachaf> It does have a common definition in category theory.
12:55:02 <mniip> cube is dual of octahedron, how's that play with the double adjunction you mentioned above
12:55:19 <shachaf> Well, not the category-theoretic dual, I think.
12:55:33 <LysergicDreams> Gurkenglas: good point
12:55:33 <tippeneinn> is there a ghc flag for informing of unused pragmas?
12:55:44 <shachaf> Though maybe you can make it work, I don't know.
12:55:46 <mniip> shachaf, can you provide an example of a CT dual?
12:55:54 <shachaf> Products are dual to coproducts.
12:56:00 <glguy> tippenein: hlint can do that
12:56:05 <mniip> in what way
12:56:15 <shachaf> A coproduct in C is a product in C^op
12:56:32 <mniip> 1457898444 [22:47:24] <shachaf> Usually with F -| G -| H, people say that F and H are dual.
12:56:46 <tippeneinn> hlint is using the ghc flag I'm assuming
12:56:55 <glguy> tippenein: I don't think so, no
12:56:58 <shachaf> Yes.
12:57:11 <shachaf> G is the diagonal functor : C -> (1 + 1)
12:57:20 <tippeneinn> glguy: yeah, looks like you're right
12:57:23 <shachaf> F is the coproduct functor and H is the product functor.
12:57:32 <mniip> "coproduct functor'
12:57:35 <mniip> "
12:57:36 <shachaf> Or something along those lines.
12:57:49 <shachaf> Er, not (1 + 1)
12:57:59 <shachaf> Of course I mean C -> (C x C)
12:58:26 <shachaf> (I was thinking of C -> C^(1 + 1) but that's not important.)
13:00:21 <mniip> shachaf, that's interesting
13:01:27 <mniip> now I just have to remember how adjunctions work
13:03:37 <xa0> i might take this opportunity to learn how they work
13:05:34 <EvanR> adjunctions. how do they work
13:05:41 <EvanR> its a miracle
13:07:07 <cocreature> you take two functors and some weird arrow like symbol and put it in between. then you have an adjunction
13:07:42 <EvanR> thats natural transformations
13:07:47 <benzrf> i dont know adjunctions lol
13:07:57 <benzrf> i've read the definition a few times i think but it never stuck
13:08:16 <cocreature> EvanR: no the other arrow
13:08:29 <cocreature> -| that one
13:08:34 <xa0> i think i get the vague idea
13:09:24 <EvanR> hows that an arrow
13:10:05 <cocreature> if you bend the bar a bit you get an arrow :)
13:10:10 <maerwald> how far away is Erlang for someone who knows haskell?
13:10:49 <Sornaensis> about 600 miles by foot
13:10:58 <benzrf> maerwald: i looked at it once
13:11:00 <benzrf> v. far
13:11:03 <parsecChar> it's like asking: how far away is writing a novel for someone who can scuba dive
13:11:21 <parsecChar> erlang is untyped (it has dialyzer, but 'success typing' is weird) but massively distributed
13:12:13 <parsecChar> erlang vs haskell: is like: commanding a swarm of flies vs commanding a fighter jet
13:12:19 <parsecChar> I guess it's like zerg vs protoss
13:12:53 <EvanR> lol
13:13:05 <EvanR> if programming languages were RTS races
13:13:20 <EvanR> space orcs vs space marines
13:13:46 <benzrf> they're just called orks, EvanR 
13:14:11 <EvanR> its warcraft in space so
13:14:45 <parsecChar> philisophically i find them very different too; haskell is 'make sure bad things don't happen'; erlang is 'shit happens; make sure you can survive stuff breaking
13:14:46 <parsecChar> '
13:15:02 <EvanR> haskell is make sure stupid things dont happen
13:15:52 <NeverDie> LOL
13:15:57 <NeverDie> Erlang is Zerg?
13:16:09 <parsecChar> yeah, processes are larva
13:16:20 <parsecChar> at some point, they mutate into zergs / mutalisks / web servers / ...
13:16:27 <NeverDie> Haha awesome.
13:16:34 <NeverDie> I always hated the Zerg though tbh.
13:16:49 <EvanR> and PHP is terrans
13:16:52 <NeverDie> Terran player <-
13:17:04 <NeverDie> But not PHP.
13:17:22 <NeverDie> EvanR: That's harsh.
13:17:41 <NeverDie> Did the siege tanks get to you?
13:17:58 <EvanR> ok C++ 
13:19:14 <parsecChar> forkIO = haskell thread, cheap ; forkOS = os thread, expensive <-- are both of these correct?
13:20:29 <liste> parsecChar: yes, basically
13:28:23 * hackagebot PrimitiveArray 0.7.0.1 - Efficient multidimensional arrays  https://hackage.haskell.org/package/PrimitiveArray-0.7.0.1 (ChristianHoener)
13:34:15 <quchen> parsecChar: forkOS creates a bound thread, which is guaranteed to run on the same OS thread each time it's scheduled.
13:34:45 <quchen> parsecChar: It's not an OS fork, it's the same kind of thing that forkIO creates.
13:34:48 <quchen> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:forkOS
13:34:52 <marrrk> Is it easy to secure a stack API with oauth?
13:34:58 <parsecChar> hmm
13:35:07 <parsecChar> if a forkOS thread blocks (in a c library), does haskell block ?
13:35:53 <Adeon> in ghc forkOS also creates an OS thread
13:38:04 <xa0> i like the erlang discussion
13:38:22 <Adeon> in general C calls don't block haskell except for the haskell thread it's called in
13:38:22 <mniip> ooh
13:38:32 <xa0> would any erlangers here say it's possible to emulate erlang/actor with haskell
13:38:46 <mniip> I just realized the idea behind the "unique object up to a unique isomorphism"
13:38:48 <Adeon> I'm not sure but I think there might be some special circumstances when it might block more, like unsafe calls with non-threaded RTS or something
13:38:53 <Adeon> but I don't know, don't trust me
13:41:38 <mniip> if we say that X and Y are "isomoprhic" in the sense that they have the same pattern of morphisms around them, that's satisfied by there being a pair of morphisms between them that turns one's pattern of morphisms into the other's via composition
13:41:47 <Cale> yep
13:42:16 <Cale> Isomorphic objects look the same from the perspective of how they interact with the rest of the category.
13:43:38 <shachaf> How do you catch a unique object?
13:43:47 <Cale> hehehh
13:43:57 <shachaf> unique up to unique isomorphism on it
13:47:03 <EvanR> mniip: ok but what does the unique isomorphism part mean
13:47:33 <mniip> that the pair of morphisms between them is unique
13:47:37 <mniip> which is essential
13:47:54 <EvanR> so there are no other isomorphisms
13:48:00 <mniip> for finite-sized patterns at least
13:48:39 <shachaf> Well, it's not unique in general. There could be other isomorphisms. But it's the only isomorphism that makes the particular construction you're talking about work.
13:49:25 <EvanR> so two objects are unique-up-to-isomorphism in some way where the way determines a unique isomorphism
13:49:34 <EvanR> out of the possibilities
13:50:08 <EvanR> i dont make sense right now
13:50:37 <EvanR> so X and Y arent unique at all
13:50:43 <EvanR> er, the same
13:51:54 <mniip> EvanR, in CT Eq is a luxury
13:52:24 <mniip> so not only we don't talk about "equal" objects,
13:52:38 <mniip> but also we can't pick a specific object,
13:52:39 <mniip> only a class of objects that somehow appear identical
13:53:06 <mniip> in the context in which we pick them
13:53:21 <EvanR> but you usually talk about two morphisms being the same
13:53:30 <EvanR> why the asymmetry
13:55:03 <mniip> hm
13:55:03 <mniip> good question
13:56:12 <simpson> EvanR: If you have two morphisms from the same object to the same object, then does it matter which one you picked?
13:56:37 <EvanR> huh, you mean X -> X ?
13:56:44 <EvanR> or X -> Y, X -> Y
13:56:55 <EvanR> in either case yes
13:57:29 <mniip> simpson, yes there's one that stands apart
13:57:33 <mniip> the identity
13:58:01 <simpson> Oh, never mind, I both phrased my question horribly and did not read enough backscroll.
13:58:24 <EvanR> and the identity morphism on X is unique?
13:58:42 <simpson> Up to etc.
13:58:50 <EvanR> thats what im asking
13:58:56 <EvanR> up to what if anything
13:59:39 <EvanR> doesnt the unique identity proof from monoids also work here
13:59:46 <simpson> I'm tempted to say up to unique isomorphism, but I'm not sure.
13:59:49 <EvanR> there can be "no other" identity arrow with its properties
14:01:17 <shachaf> I guess "unique up to unique isomorphism" is more obvious when you think of e.g. the category of cones.
14:01:20 <mniip> EvanR, oh yeah
14:01:20 <mniip> imagine two identity arrows, i and i'
14:02:05 <mniip> i = i . i' = i'
14:02:56 <EvanR> there can be only 1
14:03:25 * hackagebot ForestStructures 0.0.0.1 - Tree- and forest structures  https://hackage.haskell.org/package/ForestStructures-0.0.0.1 (ChristianHoener)
14:03:25 <EvanR> so not up to anything
14:07:05 <simpson> It appears to be just definition; the 
14:07:24 <simpson> Urgh. The morphisms of a category appear to just be a binary relation on the category?
14:08:52 * simpson shrugs
14:08:57 <simpson> I dunno, I'm terrible at maths.
14:09:23 <shachaf> Not a binary relation.
14:09:30 <shachaf> The important thing about morphisms is that you can compose them.
14:11:08 <Cale> simpson: You can define a binary relation on the objects of a category based on whether there exists an arrow between any pair of objects, and this is a useful technique sometimes, but it throws away almost all the information which the category is usually giving you.
14:11:35 <simpson> Cale, shachaf: I see, and it sounds like there is a category "Rel" that is based on exactly this?
14:12:05 <Cale> simpson: It throws away all the differences between parallel arrows -- e.g. it's not usually so interesting for a pair of sets to discuss merely whether there exists an arrow A -> B -- you tend to care about which function you have.
14:12:08 <shachaf> There is a category called Rel whose morphisms are binary relations on sets (not "on the category").
14:13:25 * hackagebot json-autotype 1.0.12 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.12 (MichalGajda)
14:14:22 <Cale> Almost any structure in mathematics, you can form a category of those structures, because we tend to not be content with studying objects in isolation -- we pretty much always generalise over a class of objects of some sort, and define some sort of corresponding structure-preserving mappings between them. The hope is that this lets us decompose problems regarding complicated structures in terms of solutions of related 
14:14:23 <Cale> problems on simpler ones.
14:20:42 <simpson> Makes sense.
14:53:26 * hackagebot ADPfusion 0.5.1.0 - Efficient, high-level dynamic programming.  https://hackage.haskell.org/package/ADPfusion-0.5.1.0 (ChristianHoener)
15:07:01 <EvanR> what does it mean that Data.ByteString and related modules are "SafeHaskell: Trustworthy"
15:07:26 <glguy> It means they do unsafe stuff internally but that you shouldn't be able to do unsafe stuff with the API they expose
15:07:36 <EvanR> shouldnt or cant?
15:07:44 <mniip> shouldn't be able to
15:07:52 <EvanR> er...
15:07:53 <mniip> that's different from both ;)
15:07:54 <glguy> It would be a bug if you found a way to
15:08:05 <glguy> Trustworthy means "trust that I didn't expose any unsafe operations"
15:08:21 <EvanR> so its tracking intention not guarantees
15:08:27 * hackagebot bioinformatics-toolkit 0.2.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.2.0 (kaizhang)
15:17:29 <Gurkenglas> right if it was a gurantee there'd be no need for trust
15:20:53 <Gurkenglas> (hpmor: "The one who receives the Unbreakable Vow must be one who could have come to trust the Vower, but chooses instead to demand the Vow from them, and they sacrifice that possibility of trust. The one who makes the Vow must be someone who could have chosen to do what the Vow demands of them, and they sacrifice that capacity for choice.")
15:25:28 <simpson> ("Capabilities are pretty cool. Capability safety is also pretty cool.")
15:33:57 * hackagebot PrimitiveArray-Pretty 0.0.0.1 - Pretty-printing for primitive arrays  https://hackage.haskell.org/package/PrimitiveArray-Pretty-0.0.0.1 (ChristianHoener)
15:33:59 * hackagebot hint 0.5.0 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.5.0 (mvdan)
15:34:07 <ogre_> hi, noob here. i'm confused about operator precedence. does $$ lose its low precedence if you don't use it an infix operator? ($) sum map sqrt [1..130] isn't a valid expression, but ($) sum (map (^2) [1..10]) is
15:34:52 <shachaf> Yes, ($) with parentheses behaves like any other function name.
15:34:55 <shachaf> It's not an operator.
15:35:52 <ogre_> shachaf: okay, and is it possible to change the precedence of ($) or some random non-infix function i make?
15:36:11 <shachaf> No, and it would be pretty strange if it was possible.
15:36:28 <shachaf> How should I know that that means sum $ map sqrt ... rather than sum map $ sqrt ..., for instance?
15:36:43 <ogre_> true. thanks
15:47:43 <Gurkenglas> What way can you recommend to build a haddock for a hackage project when it's too new to already have one?
15:48:58 * hackagebot servant-haxl-client 0.2.0.0 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-haxl-client-0.2.0.0 (willfancher)
15:50:35 <andromeda-galaxy> Is there any way to get the equivalent of type-C (as the wiki page terms them) injective type familes in the ghc8 rc
15:50:37 <andromeda-galaxy> ?
15:52:19 <andromeda-galaxy> Well actually, I need something more general than that right now:
15:53:19 <andromeda-galaxy> I have type family TF = (a :: *) (b :: *) (c :: TwoValuedType) :: * that selects a or b based on c, and I want to be able to convince GHC that if it knows, for example, a == d and b != d, then it knows c
15:53:29 <andromeda-galaxy> does anyone have an idea of how to achieve that?
15:53:40 <andromeda-galaxy> (other than switching to Idris)
15:58:16 <mniip> andromeda-galaxy, seems impossible
15:58:34 <mniip> type inequality is ugh in haskell
15:58:55 <mniip> you could try writing an inverse type family
15:58:58 <andromeda-galaxy> mniip: ugh, I was worried that that would happen...
15:59:12 <enthropy> andromeda-galaxy: possibly look at https://ghc.haskell.org/trac/ghc/ticket/10009
16:00:16 <mniip> 1457909301 [01:48:21] <andromeda-galaxy> Is there any way to get the equivalent of type-C (as the wiki page terms them) injective type familes in the ghc8 rc
16:00:40 <mniip> yes, include the dependent inputs in the output
16:00:58 <andromeda-galaxy> mniip: ooh that's a good idea...
16:01:13 <andromeda-galaxy> enthropy: thanks, I'm looking at it now...
16:01:20 <mniip> haven't tested that myself yet though
16:01:28 <andromeda-galaxy> mniip: let me try it out and see quickly
16:02:09 <andromeda-galaxy> I've since realized that even the type-C stuff might not be good enough, though, because it's only really injective if a and b are different
16:02:42 <enthropy> as in you can define:  type family GetC a b c d where GetC a b c b = (); GetC a b c a = (SomethingThatFindsC a b ~ c)
16:03:05 <andromeda-galaxy> More generally, I'm using the type family in a place to use another type to select one of two other types, but the first type isn't necessarily concretely specified, but another function later on will make the result type known, so I was hoping that I could get GHC to infer the first type after all
16:03:12 <mniip> andromeda-galaxy, partial inverses are your friend then
16:03:22 <davidthomas> anyone know good resources for advice on writing QuickCheck shrinking functions?
16:03:44 <andromeda-galaxy> mniip: can I use those to get the inference to work as well, though?
16:04:00 <mniip> andromeda-galaxy, when appropriate, yes, probably
16:04:10 <andromeda-galaxy> mniip: okay, thanks, I'll try it out
16:04:28 <andromeda-galaxy> (I mean to say, try to try it out)
16:04:42 <andromeda-galaxy> I know just enough Idris to know that everything that I want to do would be so much easier in it...
16:05:15 <mniip> beware of the awkward type signatures
16:05:23 <andromeda-galaxy> mniip: where?
16:05:28 <mniip> everywhere
16:05:39 <mniip> every 'a -> b -> F a b' will turn into
16:06:02 <mniip> (F a b ~ c, F1 a c ~ b, F2 b c ~ a) => a -> b -> c
16:06:21 <wingsuit> hi! i've been wanting to make a roguelike/rpg type game with simple 2d graphics (no animations or anything fancy like that). I'm a fan of haskell and have been trying it out for some time now, mostly following 'haskell programming from first principles' up until the monad transformers chapter, but whenever I've tried looking at game programming or FRP i feel like nothing I've learned applies, and that everything suddenly becomes me
16:06:25 <parsecChar> for a with typeclass Ord, is there a [a] -> [a] which is like the unix 'uniq' ?
16:06:32 <andromeda-galaxy> so for partial inverses to work I need to switch to fundeps?
16:07:24 <parsecChar> basically I want a linear time nub, for an already sorted list
16:08:01 <wingsuit> are there any really gentle introductions to subjects such as FRP and/or graphics? or should I stay clear of graphics stuff in haskell and just build my game in something like rust or c++?
16:08:03 <enthropy> > map head $ group [1,1,1,4,5,6,6,6
16:08:04 <lambdabot>  <hint>:1:34:
16:08:05 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:08:06 <enthropy> > map head $ group [1,1,1,4,5,6,6,6]
16:08:08 <lambdabot>  [1,4,5,6]
16:08:11 <andromeda-galaxy> mniip: never mind, I see what you're getting at there
16:08:29 <enthropy> > map head $ group [1,1,1,4,5,6,6,6,1,1]
16:08:31 <lambdabot>  [1,4,5,6,1]
16:08:42 <mniip> enthropy, /query lambdabot ?
16:08:55 <andromeda-galaxy> mniip: that was for parsecCharr
16:09:02 <mniip> oh er
16:09:05 <mniip> okay
16:09:12 * hackagebot reedsolomon 0.0.4.0 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.4.0 (NicolasTrangez)
16:12:23 <andromeda-galaxy> mniip: thanks for the suggestion of partial inverses, I'm trying it out now
16:12:34 <marrrk> Is there a convention for the naming of Maybe typed arguments?
16:12:40 <marrrk> Something like limitMaybe
16:12:49 <mniip> prepend an m?
16:12:52 <marrrk> I would like limit? but that doesn't seem to be allowed
16:12:54 <marrrk> okay
16:13:05 <marrrk> limitm?
16:13:06 <mniip> that's how I name nearly all monadic variables though
16:13:10 <mniip> prepend, not append
16:13:12 <marrrk> oh prepend
16:13:14 <marrrk> sorry
16:13:30 <marrrk> Yeah that's what I thought that that was already for Monads
16:13:48 <mniip> well, Maybe is a monad, and it also begins with m
16:14:01 <marrrk> okay good
16:16:52 <davidthomas> wingsuit: for a turn-based game with no animations, FRP might well be overkill
16:18:26 <d-snp> oO
16:18:34 <d-snp> why would frp be overkill for that?
16:21:42 <adas> when using the datakinds extension, if the data constructors are promoted to types, then in functions that accept these promoted types as arguments what valid values can be passed to them?
16:22:56 <wingsuit> davidthomas: so instead I'd just pass around state?
16:23:09 <parsecChar> in groundhog, is there a way to say: "if the schema does not match, then nuke the db; else keep the db"
16:24:33 <andromeda-galaxy> adas: you can't do that, (->) :: * -> *
16:24:38 * hackagebot BiobaseNewick 0.0.0.1 - Newick file format parser.  https://hackage.haskell.org/package/BiobaseNewick-0.0.0.1 (ChristianHoener)
16:25:27 <arkeet> hi shachaf
16:26:27 <adas> andromeda-galaxy: so we can only promote existing value constructors to types but once they are promoted to types we can't create values of the promoted types?
16:26:39 <d-snp> wingsuit: are you familiar with Haskell?
16:27:23 <andromeda-galaxy> adas: wait, I'm slightly confused
16:27:30 <mniip> andromeda-galaxy, adas, (->) :: * -> * -> *
16:27:41 <andromeda-galaxy> mniip: that's what I meant to say, thanks
16:27:44 <mniip> adas, that is correct
16:27:50 <andromeda-galaxy> ads: if we have data X = X1 | X2, say,
16:27:51 <mniip> only types of kind * are inhabited
16:28:00 <andromeda-galaxy> mniip: that's what I was getting at...
16:28:01 <davidthomas> wingsuit: broadly speaking, yes, although there are a variety of ways of organizing that
16:28:02 <mniip> (let's forget about # now)
16:28:06 <andromeda-galaxy> (indeed, let's)
16:28:27 <mniip> although the story is better in GHC 8.1!
16:28:33 <andromeda-galaxy> well, to be accurate, if I remember correctly, types of kinds that are subkinds of BOX are inhabited, right?
16:28:44 <andromeda-galaxy> ghc 8.1 (not 8.0)? what changed?
16:28:48 <mniip> you can say that only the types of kind 'TYPE r' are inhabited
16:28:49 <wingsuit> d-snp: yes, to a certain degree. I've read most of the haskell programming from first principles book (though not extremely thoroughly), and I did some small tests where I generated an ascii world map procedurally by passing around a list of points 
16:28:58 <geekosaur> andromeda-galaxy, .0 is a prerelease
16:29:18 <mniip> andromeda-galaxy, no?
16:29:19 <andromeda-galaxy> geekosaur: I thought it was that 8.0.0 was a prelease and 8.0.1 would be the first release
16:29:25 <mniip> Maybe is not inhabited
16:29:37 <mniip> yet *->* :: BOX
16:29:54 <EvanR> adas: you mean value ctors -> type ctors
16:30:07 <andromeda-galaxy> mniip: I thought I finally understood the whole subkinding situation, oh well..
16:30:18 <EvanR> adas: and yeah there no values of these promoted types
16:30:19 <mniip> subkinding?
16:30:21 <geekosaur> odd numbered 2nd component is a dev version
16:30:33 <d-snp> wingsuit: ok, do you have any experience building 2d games?
16:30:36 <mniip> that's nothing to do with subkinding
16:30:36 <wingsuit> d-snp: it was incrediby slow, and I was unsure how to expand it (or even move it out of a terminal window)
16:30:44 <EvanR> adas: the only "promoted type" with values is *
16:30:49 <geekosaur> so 8.0.x denotes the next version that is in release engineering currently, and 8.1 is the current development (git HEAD)
16:30:54 <mniip> the "subkinding situation" is about OpenKind and polymorphism between * and #
16:30:58 <geekosaur> that will become 8.2
16:31:09 <adas> EvanR: which means, those promoted types are only used for doing computation at the type level
16:31:21 <wingsuit> d-snp: yes, both 2d and 3d, but only in stuff like unity and unreal engine
16:31:24 <geekosaur> I dont think there's a lot of activity on there currently because of 8.0 release work, but there is some
16:31:28 <mniip> and that has been addressed in 8.0
16:31:29 <d-snp> right
16:31:34 <EvanR> adas: right, youre supposed to think of the ctors as the values and the new kind as the type, move everything up a level
16:31:35 <mniip> and addressed even better in 8.1
16:31:40 <andromeda-galaxy> geekosaur: okay,that's what I was trying to get at
16:32:02 <d-snp> so what I would do is think of what tech I would want/need my game to use, and go through the popular haskell game libraries to see what matches
16:32:10 <geekosaur> I know some stuff that was conjectured for 8.0.x got bumped to 8.2 (so is on 8.1 right now)
16:32:19 <adas> EvanR: you mean im supposed to think of the new type constructors as values and the new kind as the type?
16:32:21 <andromeda-galaxy> mniip:oh I see never mind.  I meant to say that only subkinds of OpenKind are inhabited, is that more correct?
16:32:35 <mniip> yeah that sounds closer to reality
16:32:37 <adas> or rather the new promoted types as the values
16:32:42 <EvanR> adas: well new type ctors would be "functions" on the level one up
16:32:43 <adas> and the new kind as the type
16:32:49 <adas> yup
16:32:51 <d-snp> I think FRP is a nice idea, so I looked up the haskell frp libraries to see if any of them already integrate with a nice 2d graphics lib like libsdl or directly opengl
16:32:52 <EvanR> nullary ctors are "values"
16:33:32 <Rotaerk> I just installed haskell-vim and vim-hdevtools... is there anything else I should install?
16:33:42 <Rotaerk> perhaps something that would tell me where something is defined?
16:34:05 <Rotaerk> "I don't recognize this function; what package is it coming from?"
16:34:14 <adas> EvanR: you mean nullary promoted type ctors are values
16:34:35 <EvanR> they arent values
16:34:36 <d-snp> wingsuit: this one has a release in january, and bindings to libsdl https://wiki.haskell.org/Reactive-banana no idea if it's any good
16:34:38 <Rotaerk> maybe something that's compatible with Stack
16:34:54 <adas> like values
16:34:57 <andromeda-galaxy> by the way, why is type inequality so badly supported overall?
16:35:03 <adas> meaning values at the higher level
16:35:12 <mniip> andromeda-galaxy, categorical implications
16:35:48 <d-snp> wingsuit: you've run into a a classic Haskell situation though, there's a whole bunch of FRP libraries/frameworks out there, and they most likely all would sort of match what you need with varying degrees of handwork required, and it's unclear which one is favoured by the community
16:35:57 <EvanR> adas: promoted Nothing :: promoted (Maybe a)
16:36:19 <d-snp> maybe a good idea is make a post on /r/haskell, asking what the community would choose if they were to start a 2d game in haskell right now, and were looking for a idiomatic way to do so
16:36:47 <EvanR> d-snp: youve summed up the situation precisely
16:37:16 <EvanR> maybe look at Helm
16:40:32 <wingsuit> i'll look around some, and check out reactive-banana and helm :) if I still havent figured out which way to go in a couple of days I'll go the reddit route and ask there. thanks for your help!
16:41:39 <andromeda-galaxy> mniip: ah, okay.
16:42:21 <Rotaerk> if not vim plugins, then what in general is popular to help aid in the development process?
16:43:00 <Rotaerk> it's easy to check types of things in ghci, but there's not exactly a ghci context while you're editing
16:43:28 <cjay> wingsuit: I'm in the same situation, tried to take part in the 7drl challenge.. I picked helm (mostly because the examples looked nice). If you want to compile helm with newer libs see https://github.com/switchface/helm/pull/100
16:43:58 <cjay> however I'm not quite satisfied with helm. it exposes only a small part of elera's functionality.
16:44:27 <cjay> no way to re-wire the frp network at runtime as far as I can see.
16:44:43 * hackagebot FormalGrammars 0.3.0.0 - (Context-free) grammars in formal language theory  https://hackage.haskell.org/package/FormalGrammars-0.3.0.0 (ChristianHoener)
16:44:45 <desophos> d-snp, reactive-banana is probably the best, as the authors of "the" book on FRP deprecated their own Sodium library in favor of reactive-banana
16:44:58 <desophos> (for Haskell only)
16:45:14 <Rotaerk> reactive banana and not reflex?
16:45:42 <EvanR> er reactive banana for games?
16:45:49 <desophos> ¯\_(ツ)_/¯ 
16:45:58 <cjay> I read some claims about time- and space-leaks in some frp libs, the whole frp situation is quite confusing
16:46:06 <EvanR> and reflex the library itself is usable for something besides reflex dom?
16:46:15 <desophos> http://blog.reactiveprogramming.org/?p=258
16:46:34 <desophos> https://www.manning.com/books/functional-reactive-programming
16:46:42 <Rotaerk> EvanR, apparently so, but I'm not sure how much comes out of the box
16:47:09 <EvanR> cjay: yes ive been studying all the papers, older implementations, and attempting to grok offshoots like sodium, elm, and javascript weird frameworks
16:47:39 <EvanR> people tendency to put up websites claiming to understand it all, and to dump incomprehensible sales pitches doesnt help
16:47:47 <Rotaerk> just looked up helm... does that do anything beyond basic 2D drawing?
16:47:58 <EvanR> dunno, i just know its a game engine
16:48:05 <Rotaerk> http://helm-engine.org/guide/
16:48:11 <Rotaerk> doesn't have much on it
16:48:31 <EvanR> Rotaerk: http://helm-engine.org/ well case in point ;)
16:48:47 <EvanR> this one is filed under elerea
16:48:47 <wingsuit> since I'm really really new to the whole FRP thing (and relatively new to haskell as well) i deregarded reflex, since there isn't a lot of information if your'e not looking to do stuff in the browser
16:49:26 <EvanR> i think nothing classifiable as FRP exists
16:49:29 <cjay> Rotaerk: yeah it seems unfinished, and is stagnant or dead. maintainer hasn't replied to my PR yet.
16:50:36 <desophos> wow, last helm update 9 months ago
16:50:37 <desophos> :/
16:51:02 <Rotaerk> I intend to try using reflex to make a game
16:51:11 <Rotaerk> but it may require a lot of wiring up...
16:51:54 <cjay> EvanR: do you have any conclusions after studying all that stuff?
16:52:32 <cjay> especially about the space/time-leaks
16:52:46 <Rotaerk> the reflex one supposedly addresses that problem, cjay
16:52:59 <desophos> wingsuit, have you seen https://github.com/gelisam/frp-zoo ?
16:53:06 <Rotaerk> cjay, https://www.youtube.com/watch?v=mYvkcskJbc4
16:53:35 <cjay> thanks
16:53:52 <Twey> EvanR: Why not Banana for games?
16:54:07 <Rotaerk> however, there's no reflex-game or anything like that; it's JUST an FRP thing.  not an engine
16:54:41 <cjay> writing a simple 2d engine with sdl2 shouldn't be too hard though
16:54:55 <wingsuit> desophos: no, didn't see that! thanks
16:55:03 <EvanR> Twey: ive only seen it used for desktop gui apps
16:55:10 <EvanR> cjay: you say that now ;)
16:55:48 <Rotaerk> https://github.com/tejon/Fundament
16:55:57 <desophos> reactive-banana-sdl bindings last updated over 2 years ago
16:56:04 <Rotaerk> looks like a lot of progress has been made on that >_>
16:56:10 <Rotaerk> I think he's just run stack new
16:56:14 <Rotaerk> llol
16:56:52 <EvanR> cjay: spacetime leaks at least refers to the switcher combinator in classic frp, fran, reactive
16:57:11 <Rotaerk> spacetime leaks lead to relativistic side-effects
16:57:16 <Twey> EvanR: I used reactive-banana for 3D games a couple of years ago (it's presumably significantly more mature now)
16:57:23 <EvanR> interesting
16:57:40 <Twey> Well, it wasn't the fastest and they weren't terribly demanding, but it worked
16:57:46 <wingsuit> is sdl the easiest backend to get started with/is it more idiomatic? i've only done haskell stuff in the terminal so far
16:57:58 <cjay> hmm
16:58:18 <Twey> But notably I had no dynamic switching, because that leaked in Banana at the time — I presume that's fixed now, since Heinrich has been saying he knows how to fix it for at least four versions :þ
16:58:30 <cjay> snl2 is pretty close to the C lib from my experience with the helm internals
16:59:16 <Twey> Ah, yes, fixed in 0.9
16:59:43 * hackagebot phone-numbers 0.0.4 - Haskell bindings to the libphonenumber library  https://hackage.haskell.org/package/phone-numbers-0.0.4 (ChristianMarie)
16:59:47 <EvanR> wingsuit: i like glfw-b
17:00:32 <cjay> oops s/snl/sdl/
17:00:45 <cjay> hmm good to know banana is fixed now
17:01:13 <wingsuit> okay. i've been looking at gloss and diagrams as well, but they seem to be limited (plus, gloss didn't want to build on my laptop). figured I might as well go all out and pick one of the more low level backends
17:05:20 <desophos> is gloss very limited?
17:06:25 <wingsuit> isn't it vector graphics only?
17:06:47 <desophos> also, wingsuit, the FRP book i linked might be a good intro to FRP; i haven't read much of it yet though :| need to get back into it once i'm a decent amount through the haskell book
17:07:03 <wingsuit> a quick search tells me i'm wrong. might have to take another look at gloss then
17:08:26 <wingsuit> okay, i'll consider buying it if I don't manage to figure out how it works from online tutorials :)
17:08:44 <desophos> i haven't found any online tutorials that are really good
17:08:49 <desophos> mostly ones for specific libraries
17:09:17 <desophos> and mostly not "real" FRP, i.e. just reactive like microsoft's ReactiveX or react.js
17:09:44 * hackagebot phone-numbers 0.0.5 - Haskell bindings to the libphonenumber library  https://hackage.haskell.org/package/phone-numbers-0.0.5 (ChristianMarie)
17:09:58 <desophos> but if you do find a good one please let me know!
17:11:19 <wingsuit> i will! 
17:14:36 <Gurkenglas> These a should have the Alt instance "That b <!> This a = These a b; That b <!> These a _ = These a b; x <!> _ = x"
17:19:56 <Twey> EvanR: In a similar vein, I'm interested to know why you consider reactive-banana (or Sodium, for that matter) to be not FRP (‘nothing classifiable as FRP exists’)
17:20:21 <Gurkenglas> (That way, you could use many to get These a [b] with a list of bs until the first a, and the a that allows you to supply the reason for abort!)
17:20:38 <jarvi> what's the proper way to create a new ghcjs project with stack? `stack new helloworld ghcjs` gives me "ghcjs-base not found"
17:21:41 <parsecChar> if I have a large amount of data; is there any reason to believe that it's better to query the data from haskell than to stick it inside a postgresql db and query it from there?
17:25:33 <Gurkenglas> (Although a flaw of that is that you can't access the list of bs without knowing whether the end result is That or These, requiring you to evaluate all of it immediately... but if it's That, the list will be infinite, so we'll diverge in that case anyway, so we may as well assume it'll be These... wtf)
17:26:29 <Rotaerk> is that poetry?
17:27:19 <Gurkenglas> worse, it's library design
17:27:34 <Cale> desophos: It's not much, but have you checked out the little reflex-platform tutorial?
17:28:10 <desophos> Cale, i have not
17:28:17 <Cale> https://github.com/reflex-frp/reflex-platform (scroll down)
17:28:37 <Cale> I don't know if it can count as "good", but it's a tutorial anyway
17:29:03 <Gurkenglas> "data These' a b = This a | Thatse b (Maybe a)" would not have that problem.
17:29:22 <Gurkenglas> *This' because collision
17:37:13 <benzrf> is it possible to get an old version of base in a sandbox?
17:37:14 <benzrf> no?
17:38:17 <desophos> Cale, tutorials are nice but i haven't found that they really help me get a deep enough understanding to actually use FRP in my applications in a meaningful way
17:39:57 * hackagebot GrammarProducts 0.1.1.2 - Grammar products and higher-dimensional grammars  https://hackage.haskell.org/package/GrammarProducts-0.1.1.2 (ChristianHoener)
17:39:59 * hackagebot digit 0.2.0 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.0 (TonyMorris)
17:40:25 <benzrf> i wish the word problem for finitely presented groups was computable
17:40:33 <benzrf> i wish i could have finite group presentations as type declarations
17:43:42 <benzrf> ^pop quiz
17:43:47 <benzrf> er,wrong channel
17:46:35 <EvanR> hot shot
17:47:05 <Cale> I wish that too, lots of stuff would be way better for us. In particular, I'm pretty sure the halting problem would be solvable too.
17:47:39 <Gurkenglas> Not sure the world would last long after someone got hold of a halting oracle
17:47:46 <Rotaerk> pfft, my *grandma* could solve the halting problem
17:50:55 <andromeda-galaxy> well *technically* the Halting problem is solvable for LBAs, just really, really, really, really, *really* hard
17:51:48 <benzrf> andromeda-galaxy: LBA?
17:51:55 <desophos> Legally Blonde Attorneys
17:52:02 <tippeneinn> log-based architectures?
17:52:49 <Gurkenglas> A turing machine that's not allowed to move past the input
18:01:03 <andromeda-galaxy> benzrf, desophos, tippeneinn, Gurkenglas: linear bounded automaton
18:01:11 <benzrf> ty
18:01:30 <Cale> benzrf: Usually the restriction is that the machine has an amount of memory bounded by a linear function of the size of the input, but I suppose it doesn't change much if you just force it to be the same as the size of the input.
18:04:41 <andromeda-galaxy> since LBAs have a finite/bounded amount of memory, you can find out if an algorithm terminates by watching for a sequence of repeating states.  When you have literally a few billion memory locations, though, that becomes a *lot* of states, so even though the problem is technically decidable, it would take orders of magnitude more time than the current age of the universe to compute it exhaustively over
18:04:42 <andromeda-galaxy> modern machines
18:19:57 <andromeda-galaxy> mniip: I've been taking your suggestion of using partial inverses, but managed to deal with them using only typefamiles (one for the function and one for the inverse).  Now I need to deal with the special case where the two types are equal, essentially I want the type to be left ambiguous in that case so that I can disambiguate it separately (using visible type applications).  The inverse type family,
18:20:00 <andromeda-galaxy> however, ends up matching e e e to the e n e case and returning one of the actual values, which break everything; do you have any more suggestions on how to avoid that?
18:26:10 <enthropy> andromeda-galaxy: you're cut off after "The inverse type family" which probably should be put in http://lpaste.net
18:43:06 <andromeda-galaxy> enthropy:the rest of it didn't get split into another message?
18:44:32 <bros> Anybody have any experience with PostgREST?
18:44:38 <andromeda-galaxy> enthropy, mniip: http://lpaste.net/154649
18:47:24 <enthropy> andromeda-galaxy: does adding an equation before the other ones "UnX e e e = 'T2" fix it?
18:48:22 <andromeda-galaxy> enthropy: the thing is, UnX e e e needs to be neither T1 nor T2 but "this isn't really a constraint"---it's used like 't ~ unX a b c'
18:48:48 <andromeda-galaxy> enthropy: the thing is, UnX e e e needs to be neither T1 nor T2 but "this isn't really a constraint"---it's used like 't ~ unX a b Constraint kind, though
18:49:07 <andromeda-galaxy> (but can't test it right now)
18:50:20 <enthropy> and you don't want to make (UnXEq a b t) do what (t ~ UnX a b) is supposed to do?
19:09:18 <bros> Anybody have any experience with PostgREST?
19:12:27 <timbod7> How can I compose two prisms to run in parallel, ie something like : Prism' s a -> Prism' s b -> Prism' s (a,b)
19:12:49 <andromeda-galaxy> enthropy: oops, sorry I missed you.  That is what I ended up doing
19:16:01 <Rotaerk> anyone around with haskell-distributed experience?  I'm seeing seemingly buggy behavior from it
19:31:56 <Rotaerk> nevermind, figured it out; the example is flawed, not the library
19:44:41 <infandum> How can I map Strings to Integers? Obviously not all of them, but of length 3 to maybe 10 or so
19:45:06 <EvanR> :t chr
19:45:07 <lambdabot> Int -> Char
19:45:10 <EvanR> :t ord 
19:45:11 <lambdabot> Char -> Int
19:45:32 <EvanR> > ord $ maxBound Char
19:45:34 <lambdabot>      Not in scope: data constructor ‘Char’
19:45:34 <lambdabot>      Perhaps you meant one of these:
19:45:34 <lambdabot>        ‘Chr’ (imported from Text.PrettyPrint.HughesPJ),
19:45:36 <infandum> One idea I had was to do ((maxBound :: Int) + fromEnum character) for each one, show them, concatenate them, then read :: Int
19:45:38 <EvanR> > ord $ maxBound :: Char
19:45:39 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Int’
19:45:39 <lambdabot>      In the expression: ord $ maxBound :: Char
19:45:50 <EvanR> wallg
19:45:55 <infandum> but that can't work for over 3 length strings
19:46:04 <EvanR> huh why not
19:46:12 <infandum> because:
19:46:19 <infandum> > maxBound :: Char
19:46:21 <lambdabot>  '\1114111'
19:46:25 <simpson> infandum: What's the goal?
19:46:28 <EvanR> ah you mean Int, not Integer
19:46:44 <infandum> (maxBound :: Int)
19:46:47 <infandum> > (maxBound :: Int)
19:46:49 <lambdabot>  9223372036854775807
19:46:50 <Cale> Integer is arbitrary size
19:46:55 <infandum> the number of digits
19:47:04 <infandum> can only do 111411111141111114111 then no more
19:47:12 <Rotaerk> > read "123512365" :: Int
19:47:14 <lambdabot>  123512365
19:47:26 <infandum> (and it would be 1114111 * 2 for the max per character, but that doesn't matter)
19:47:36 <EvanR> well, use Integer?
19:47:52 <infandum> no, I mean "AGGH" to an int, etc, not "102" to an int
19:48:06 <Rotaerk> infandum, what int would "AGGH" be?
19:48:39 <infandum> EvanR: I was thinking about that, but these ints are the indices for a sparse matrix. If it's too big, I don't know how the multiplication etc would suffer (even if the number of elements is the same)
19:48:51 <infandum> Rotaerk: Doesn't matter, as long as it's unique to that string
19:49:04 <EvanR> String is hashable
19:49:06 <infandum> oh, and it needs to be unique FOR THAT LENGTH
19:49:11 <EvanR> hash :: String -> Int
19:49:21 <Cale> :t Data.Text.pack
19:49:22 <infandum> EvanR: I was looking at that too, but it would give negative numbers
19:49:23 <lambdabot> String -> Data.Text.Internal.Text
19:49:35 <EvanR> map the Int to Word
19:49:36 <Cale> :t Data.Text.Encoding.encodeUtf8 . Data.Text.pack
19:49:37 <lambdabot> String -> BSC.ByteString
19:49:44 <infandum> ?
19:49:45 <Cale> :t Data.ByteString.unpack . Data.Text.Encoding.encodeUtf8 . Data.Text.pack
19:49:46 <lambdabot> String -> [Word8]
19:49:57 <EvanR> Word is unsigned Int
19:50:03 <Cale> ^^ convert a string to a list of numbers
19:50:31 <infandum> would that be positive?
19:50:36 <EvanR> or zero
19:50:47 <EvanR> for 64 bit numbers, youd hope the collision is unlikely
19:50:52 <infandum> would it give zeroes at the beginning?
19:51:00 <EvanR> huh?
19:51:04 <infandum> because as an index that wouldn't count
19:51:10 <infandum> like 001 and 01 would be identical
19:51:17 <EvanR> there are no zeros at the beginning of anything
19:51:21 <infandum> ok
19:51:26 <EvanR> Int and Word are numbers, not strings
19:52:14 <EvanR> > (-123) :: Word
19:52:15 <lambdabot>  18446744073709551493
19:52:23 <infandum> but you said it would be a list of "Word"
19:52:33 <EvanR> i didnt say anything about a list
19:52:39 <infandum> or Cale did
19:53:15 <Cale> You can do stuff with that list of Word8 values to make a single number of possibly another kind
19:54:02 <infandum> do you think it would matter if the index of a sparse matrix is 199283741928374912873498127349812734 or whatever? Would that be too big for svd and multiplication and the like?
19:54:18 <infandum> Even if there were, say, 50 values, just in big rows and columns?
19:54:54 <Cale> As long as it's sparse-sparse, and you're using integer entries, there shouldn't be a technical problem, but I don't really understand what you're trying to do.
19:55:00 <Rotaerk> why are you trying to map strings to ints anyway?
19:55:31 <Cale> There are probably much better ways to index your strings
19:56:46 <desophos> > foldr (++) "" (map show $ map ord "AGGH")
19:56:46 <desophos>  -- could you do this?
19:56:48 <lambdabot>  "65717172"
19:57:05 <Rotaerk> mapping the string to a number can be a fold; mapping the number back would be an unfold... fun
19:57:08 <desophos> erm then back to int i mean
19:57:13 <infandum> Cale: Well, the idea is that each string (of ONE length, like all possible 4 length strings) is a column in a sparse matrix. I can't just nub all strings and zip [1..] because there might be way too many, so I wanted to do it as I went
19:57:51 <Cale> desophos: That's ambiguous
19:58:08 <Cale> It's not clear where the number boundaries are
19:58:09 <infandum> desophos: No, because there might be a chance that one is 11 111 and another is 11 111 and they would be identical (but aren't)
19:58:16 <desophos> ahh true 
19:58:46 <Rotaerk> a string can be thought of as a number expressed in base N, where N is the number of values in Char
19:59:11 <shachaf> You also need the length.
19:59:16 <shachaf> Otherwise 1 = 0001
19:59:21 <Rotaerk> yea
19:59:32 <Cale> another good point
20:00:00 <Cale> But it's not necessarily a good idea to do this encoding
20:00:26 <Cale> I mean, for the purposes of actually treating it as a number.
20:01:05 <Cale> It would probably make more sense to just use a data structure which was indexed by strings or Text or whatever.
20:01:09 <infandum> yeah, but to represent it in a sparse matrix I need to do that
20:01:13 <shachaf> What are some algebraic structures that freely generate the integers/naturals/positive naturals?
20:01:42 <Cale> Just define a sparse matrix indexed by Text
20:01:50 <Cale> It'll make more sense
20:02:20 <shachaf> The positive naturals are a free commutative monoid generated by the primes, and the naturals are a free semilattice generated by the powers of 2.
20:02:38 <Rotaerk> yea, a Map or Bimap from String to Int makes sense to me, instead of trying to *encode* the strings in numbers
20:02:40 <shachaf> Are there other characterizations like that?
20:03:56 <Cale> You can even use Ed's http://hackage.haskell.org/package/linear
20:04:09 <Cale> It already has appropriate instances for Maps
20:04:50 <infandum> does that have sparse svd?
20:05:29 <infandum> I think the only package I found using sparse svd is an hmatrix one, and that converts from dense matrices (which I can't fit in memory)
20:09:29 <cjay> desophos: “< desophos> reactive-banana-sdl bindings last updated over 2 years ago” <- you overlooked http://hackage.haskell.org/package/reactive-banana-sdl2 :)
20:11:13 <desophos> cjay, aha! nice find
20:11:28 <Cale> infandum: Yeah, I think you're likely going to have to write something, or develop a binding to a lower level library. Once you know what the values are which index your matrix, you can simply number those (in a dense way) and compute the SVD of the resulting dense matrix, and map back to your text basis at the end
20:13:48 <infandum> yeah, that's not possible haha
20:13:56 <infandum> the dense matrix is just too large
20:14:27 <infandum> I guess the best I can do is just make a map from string to int from what is observed
20:14:32 <infandum> even though that will be slow
20:14:40 <Cale> Well, you could again make a sparse matrix that way
20:14:42 <infandum> nlogn, n memory
20:14:47 <infandum> "slow"
20:14:59 <infandum> (if n is 20^10 power)
20:15:21 <infandum> is Set.fromList still the fastest way to nub?
20:16:07 <Cale> 20^10, really?
20:16:28 <Cale> That's like 10 trillion
20:16:32 <infandum> And what is faster, nlogn divided among many tiny groups or nlogn on all of them together?
20:16:41 <infandum> yup, which is totally possible
20:16:55 <infandum> but many zeroes are there
20:17:13 <infandum> although I'll mostly be using 20^3 or 20^4, but you know...
20:17:15 <Cale> Oh, well, I'm saying you don't include those
20:17:24 <Cale> You don't need to work in that vector space
20:17:33 <Cale> The subspace you're actually working in is far lower dimensional
20:17:40 <infandum> yeah
20:18:00 <Cale> How many columns and rows actually contain a nonzero entry?
20:18:15 <Cale> If every column has a nonzero entry, then you're still probably screwed
20:18:26 <infandum> why?
20:18:32 <Cale> 20^10 columns?
20:18:39 <infandum> yeah, good point
20:19:03 <infandum> That would explain why my previous attempt was super slow for 20^6 and up
20:19:34 <infandum> hmmm, okay, I think I'll try it another way
20:19:49 <infandum> that observed data way to lessen the potential columns
20:20:22 <infandum> the sorting and keeping in memory will be bad, but with pipes I can iteratively get rid of duplicates so it won't be super bad
20:20:27 <infandum> that you for your help!
20:20:38 <Cale> Yeah, you want to work in the subspace of the domain and codomain of your linear map corresponding to the observed data only.
20:21:06 <infandum> it's just that looking at all the data was slower than just mathematically labeling a string
20:21:44 <infandum> but it in the long run it might be better due to weird svd storage or whatever
20:22:06 <Cale> Ideally, you'd just have an implementation of SVD which worked for things like Map a (Map b c), suitably constrained by type classes
20:22:07 <infandum> most programs use int, so it wouldn't even be able to load the index
20:22:17 <infandum> yeah, that would be best
20:22:34 <Cale> It's probably not impossible to write that yourself, but annoying :)
20:22:48 <infandum> yeah it would be impossible
20:22:53 <infandum> I only have so much time haha
20:24:16 <infandum> anyway, thanks for the help!
20:25:03 * hackagebot digit 0.2.1 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.1 (TonyMorris)
20:50:14 <Moggle> Hey there, I'm having a problem with scotty... the monad transformer doesn't have an instance of MonadTrans? https://hackage.haskell.org/package/scotty-0.10.2/docs/Web-Scotty-Trans.html#t:ScottyT
20:50:24 <Moggle> does anyone have any clue why this would be when old versions of the package *did* have such an instance?
20:57:53 <glguy> Moggle: It's mentioned in the changelog: https://hackage.haskell.org/package/scotty-0.11.0/changelog
20:59:49 <Moggle> glguy, i don''t understand? what does transformers-compat mean?
21:00:02 <Moggle> does it define lift etc. for arbitrary instances?
21:00:08 <Moggle> can i just snap it in and import it to get lift etc.?
21:03:47 <glguy> No, that's something else
21:03:56 <glguy> ScottyT just isn't a MonadTrans instance anymore
21:04:27 <Moggle> so how can I use lift inside of it?
21:04:53 <Moggle> glguy: This seems extremely confusing, did he *break* it? what's the point of a transformer if you can't lift inside of it
21:05:35 <glguy> Moggle: Looking over the haddocks it doesn't look like you use lift inside of it, the 'm' parameter is for the ActionT stuff
21:05:42 <andromeda-galaxy> hmm, is it possible to write pattern synonyms that depend on types?
21:05:54 <glguy> Moggle: and ActionT *is* a MonadTrans
21:07:38 <EvanR> i have a question about using functions as data in an application, i naturally wrote `tuning :: Note -> Double' as a field of the data for a song, great. but now i cant serialize it or restore it. i can replace it with a finite list of preset tunings, but thats not as flexible. i could invent a tuning DSL. any other ideas?
21:09:48 <jle`> EvanR: you can find a representation for your function
21:09:55 <jle`> using normal data
21:10:00 <Moggle> glguy: I guess that means I can only use lift inside actionTs now... that makes this tutorial wrong now. :/. I think I can adapt all the same, thanks for your help.
21:10:15 <EvanR> representation representation ...
21:10:15 <Moggle> this is still all so strange...
21:10:44 <jle`> EvanR: yeah, i've done things like this.  can you describe more abotu the type of function tuning would be?
21:12:19 <EvanR> i guess you would start from either equal temperament or some nice rational tuning, and then adjust the answer for one or more notes up or down slightly
21:12:31 <Moggle> Hackage seems like it's not generating documentation anymore, anyone know what's up with that?
21:12:35 <Moggle> for new packages, i mean
21:13:31 <dmj`> EvanR: wonder if the function could be expressed in a free monad grammer somehow, that was serializeable
21:13:32 <EvanR> so a GUI for such a function would be a knob for every note
21:13:43 <dmj`> grammar*
21:13:51 <jle`> you could save the knob positions maybe
21:14:25 <EvanR> so the starting position and the knobs positions that were moved
21:14:38 <EvanR> i guess that is more flexible
21:14:45 <EvanR> and coveres everything?
21:15:21 <EvanR> you can reproduce functions from this
21:15:37 <jle`> yeah, if you can get the function from your data thing, then it works :o
21:16:39 <EvanR> and to extend it for more ways to define tunings, you have to extend the source data and editor
21:16:48 <EvanR> and "to function" driver
21:17:41 <EvanR> interested to hear how free monads could help ;)
21:26:14 <lethjakman-l> Is there anything like buildpal for haskell?
21:27:49 <dmj`> lethjakman-l: depends on what buildpal is
21:28:01 <lethjakman-l> dmj`: Distributed compilation for C++
21:29:52 <dmj`> lethjakman-l: http://stackoverflow.com/questions/10323419/is-there-a-distcc-like-tool-for-ghc
22:05:06 * hackagebot digit 0.2.2 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.2 (TonyMorris)
22:20:15 <haskell153> hello
22:24:40 <haskell786> hi
22:29:56 <haskell786> anyone familiar with attoparsec?
22:31:03 <Clint> many people are
22:34:49 <haskell786> why is takeWhile _ much faster than many anyWord9
22:37:53 <EvanR> Word9? implementing UTF-9 ?
22:40:09 <pavonia> haskell786: takeWhile is trimmed for performance and yields a complete chunk of data at once; many anyChar yields one byte after the other as a list
22:43:13 <haskell786> sorry i meant word8
22:43:48 <haskell786> why do the attoparsec docs talk about takeWhile being much faster than many anyWord8; don't they both go byte by byte in a bytestring
22:44:13 <haskell786> what is a chunk
22:44:51 <pavonia> Interanlly yes, but you get a ByteString result vs. [Word8]
22:45:38 <haskell786> so you're doing foreignptr word8 arithmetic for takeWhile, but only wind up with a [word8] for many?
22:45:50 <haskell786> and how does "chunking" help speed?
22:47:20 <EvanR> reading an array of bytes is faster than following list pointers
22:47:28 <EvanR> among other issues
22:48:15 <pavonia> I think the time cost here is removing the first element from the ByteString and process with the tail
22:48:49 <haskell786> can't you remove the first byte from a bytestring (unsafely) in O(1)?
22:49:14 <EvanR> or safely, just allocate a new slice
22:50:13 <haskell786> i still don't have intuition for why many would be "100x" slower than takeWhile; there may be some inefficiencies with lists, but how are they that large?
22:51:04 <pavonia> Is it 100 times slower for a single char too?
22:51:18 <pavonia> *byte
22:51:26 <haskell786> i haven't tested this out, i just read it in the docs
23:12:25 <guest18743> Hi, I'm brand new to Haskell and I'm having a bit of trouble figuring out this error. Here's my code snippet with the error I'm getting
23:12:26 <guest18743> http://pastebin.com/raw/x9ecYpwC
23:12:42 <guest18743> There's something I'm not understanding about how the type system works, I think
23:13:33 <dmj`> guest18743: main = print $ myGcd 12 8
23:13:56 <dmj`> guest18743: main is takes an 'IO ()' action
23:14:03 <kadoban> guest18743: In the definition of myGcd, you're calling it with too few arguments like it says.
23:14:33 <kadoban> guest18743: myGcd takes 2 arguments in order to end up with an Int. You're only giving it one, on line … 7
23:14:36 <dmj`> ah, otherwise = myGcd (q (mod p q))
23:14:49 <dmj`> myGcd q (mod p q), maybe...
23:16:25 <guest18743> Hey thanks! Both of those suggestions fixed it. I guess I was wrong that myGcd (q (mod p q)) would pass q and then the result of mod p q
23:17:41 <kadoban> f (a (stuff))  means 'f' gets one argument. That argument is the result of passing the function 'a' one argument, which is 'stuff'. In case that helps.
23:19:14 <guest18743> Oh, so the brackets did set precedence. Just not in the way I wanted
23:20:32 <guest18743> Thank you very much!
