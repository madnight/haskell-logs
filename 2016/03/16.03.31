00:00:05 <liste> I'd call it a nullary type constructor
00:00:12 <liste> or a concrete type for short
00:00:15 <Rotaerk> according to the haskell wiki, "A type constructor may have zero or more arguments."
00:01:13 <Rotaerk> so I guess "type constructor" just refers to type-level names?
00:01:23 <Maxdamantus> Yeah, "type constructor" refers to something fairly specific.
00:01:38 <Cale> It depends on whether "type constructor" refers to the type level things introduced directly by data and newtype, and which the instance selection mechanism matches against (i.e. the things which have uppercase names)
00:01:49 <Maxdamantus> I don't think people would be inclined to call `State Int` or the `m` in `Monad m` "type constructors".
00:02:00 <Cale> Or whether it refers to "something of kind k1 -> k2"
00:02:45 <Maxdamantus> (because otherwise every type is also a type constructor)
00:03:00 <Cale> It probably should be reserved for the first, though I think in casual conversation if you refer to something as a type constructor, people will expect a parameter.
00:03:17 <Cale> Maxdamantus: no, look at my second definition :)
00:04:44 <Rotaerk> the terminology could use some refinement...
00:04:59 <Rotaerk> doesn't seem to easily allow the distinctions people would like to make
00:05:23 <Maxdamantus> Cale: but something of kind `k1 -> k2` doesn't necessarily produce a type (something of kind `*`)
00:05:40 <jle`> i guess in the sense of the haskell wiki definition, type constructors are constructors in the sense that string literals are string constructors.  they let you specify types literally in source code?
00:05:54 <jle`> or type-level things
00:05:59 <Cale> Maxdamantus: Yeah, in modern Haskell, that's also true
00:06:07 <Maxdamantus> I think in Haskell they just call things declared with `data` or `newtype` "type constructors".
00:06:29 <Cale> So perhaps "where k2 is either a type constructor (recursively) or *"
00:06:45 <Cale> Maxdamantus: Yeah, that's definition 1 :)
00:06:52 <Maxdamantus> so `Int`, `Maybe` are type constructors, `Maybe Int` is not, neither is `m` in `Monad m` or `t` in `IO t`
00:06:57 <srhb> If type constructors don't behave like value constructors, I don't think we should even use the name.
00:06:58 <Cale> right
00:07:32 <srhb> ie. if Nothing is a value constructor, surely Int is a type constructor too. Otherwise it's completely confusing.
00:07:39 * hackagebot google-search 0.2.0.0 - EDSL for Google and GMail search expressions  https://hackage.haskell.org/package/google-search-0.2.0.0 (LiyangHu)
00:07:39 * hackagebot vector-th-unbox 0.2.1.5 - Deriver for Data.Vector.Unboxed using Template Haskell  https://hackage.haskell.org/package/vector-th-unbox-0.2.1.5 (LiyangHu)
00:07:43 <Rotaerk> is "type function" an established term for anything?
00:07:49 <srhb> Yes.
00:08:16 <srhb> Or type level function at least. Usually type family stuff.
00:08:27 <jle`> it looks like the report defines type constructors as things analogous to value constructors, Just, Nothing, etc.
00:09:11 <Cale> Properly, Either String and that m should be referred to as type level functions as well.
00:09:26 <srhb> Well they certainly _are_ that, among other things.
00:09:44 <Rotaerk> I've always found the use of the word "type" to describe anything that isn't kind * to be unintuitive/weird
00:10:09 <Rotaerk> they're certainly type level things, but "type" seems like it should be reserved for something that can have values
00:10:21 <Cale> If we're going to be prescriptive about it, type constructor should almost surely be reserved for the type level entities introduced by data and newtype declarations whose names begin with uppercase letters.
00:10:33 <Rotaerk> and those are just type level ... terms
00:12:34 <jle`> so according to the report, things like Either String are not type constructors in the sense that, say, (1,) is not a data constructor
00:12:42 <jle`> Rotaerk: yeah, but what do you call instances of typeclasses?
00:12:48 <Cale> Rotaerk: most of the time, that is sensible... sometimes it gets a little awkward not having a better name for "things admissible at the type level". Once we're all using dependently typed languages, we can just go back to calling that stuff "values"
00:12:51 <jle`> instances of typeclasses are types, right?
00:13:27 <Rotaerk> Cale, interesting; didn't occur to me that dependent typing could ... collapse the terminology like that
00:14:04 <Maxdamantus> Maybe : Type -> Type
00:14:07 <Maxdamantus> succ : Nat -> Nat
00:14:14 <Maxdamantus> This is what you get in Idris.
00:14:17 <Cale> yeah
00:14:22 <Rotaerk> jle`, isn't an "instance" just a relationship between a type and a typeclass?  it's not a type, itself
00:14:31 <Maxdamantus> both things are just functions. Functions are values that you can pass values to and get values back from.
00:14:43 <jle`> Rotaerk: that's what i mean, you write typeclass instances for types
00:15:10 <Rotaerk> hmm or for type-level things in general :P
00:15:12 <jle`> the Haskell report makes the terminology pretty clear
00:15:44 <Maxdamantus> even Monad?
00:15:57 <jle`> "An instance declaration declares that a type is an instance of a class ... "
00:16:07 <Cale> Yeah, it's not like in Haskell where the "::" in  Maybe :: * -> *  is not really the same relation as the "::" in  succ :: Nat -> Nat
00:16:09 <jle`> so yeah, Maybe is an instance of the Monad typeclass
00:16:16 <jle`> but Maybe :: * -> *
00:16:31 <jle`> `Maybe` is an instance of the Monad typeclass, and so `Maybe` is something that the Report refers to as a type
00:16:35 <Cale> heh
00:17:10 <Cale> jle`: But were those words written before "constructor classes" were a thing and merely carried forward? :)
00:17:13 <Rotaerk> jle`, yea, I'm mostly suggesting that that use of the word is kind of an awkward decision
00:17:58 <Maxdamantus> “If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.”
00:18:16 <Maxdamantus> (something else from the Haskell report)
00:18:16 <Cale> jle`: There was a bit of time where classes only abstracted over types of kind *
00:18:23 <jle`> yeah, just realized that
00:18:37 <jle`> but Maxdamantus's quote makes it clear that k1 -> k2-kinded types are ... types
00:18:40 <Cale> Maxdamantus: Yeah, that's clearer :)
00:18:48 <jle`> definitely better than mine heh
00:18:59 * Maxdamantus doesn't like it.
00:19:00 <Cale> At least, the Report is consistent with itself
00:19:03 <Maxdamantus> Boo the Haskell report.
00:19:09 <jle`> besides, the statement "types have kinds" would make no sense unless types could have non-* kinds
00:19:31 <jle`> the very statement "kinds are the type of types", "types have kinds" implies that "type" refers to non-* things
00:19:33 <Cale> jle`: You end up saying things like "type-level things have kinds"
00:19:46 <Rotaerk> well, I suppose that the awkwardness of calling State a type is equivalent to the awkwardness of calling (+) a value 
00:19:59 <jle`> Cale: yes, that would be a suitable substitution
00:20:22 <Maxdamantus> (+) is a value .. for all `t` where `Num t`
00:20:49 <Rotaerk> well I could use any function there :P
00:20:52 <Maxdamantus> I don't think the awkwardness is equivalent. The latter can only really be awkward because of polymorphism.
00:20:53 <merijn> (+) *is* a value
00:21:19 <jle`> functions are all normal values in haskell, there isn't any controversy about that
00:21:29 <merijn> I don't see why "State being a type" is awkward?
00:21:43 <merijn> If data constructors (i.e. Just) are values
00:21:53 <merijn> I don't see why type constructors (i.e. State) wouldn't be types
00:21:59 <Maxdamantus> because you can't declare a binding as having type `State`.
00:22:12 <Maxdamantus> a :: State; a = ..
00:22:13 <jle`> well, that's because values can only have types of kind *
00:22:30 <merijn> That's becayse bindings always reference values and values MUST have types that have kind *
00:22:36 <jle`> not because all types have values-of-that-type
00:22:53 <jle`> "all values have types" doesn't mean "all types have values of that type"
00:22:57 <Maxdamantus> and that use of the word "type" directly conflicts with its meaning in languages like Idris.
00:23:07 <merijn> Maxdamantus: It doesn't?
00:23:13 <merijn> Well, not sure about Idris per se
00:23:26 <merijn> But this is perfectly consistent with all existing type theory and languages like Coq/Agda
00:23:27 <Maxdamantus> `Maybe` is definitely not a "type" in Idris.
00:23:36 <merijn> I'd be very confused if Idris did something different
00:23:39 <jle`> it will be awkward a bit in GHC 8.0, which will offer a kind synonym TYPE = *
00:23:53 <jle`> Maxdamantus: Maybe doesn't have type Type
00:23:53 <Rotaerk> merijn, I haven't studied type theory, but as I see it types originated to classify values... it seems "wrong" to call something a type when it doesn't make sense to have values in it
00:24:16 <jle`> er, Type = *
00:24:18 <Maxdamantus> jle`: indeed, it has type Type -> Type
00:24:25 <Rotaerk> but that's just intuition speaking...
00:24:50 <Maxdamantus> id can also have type `Type -> Type` .. is the identity function a type too?
00:24:53 <jle`> so in a post-8.0 world, we'll have to distinguish our language btween "types" and "Type"s in Haskell
00:25:14 <fr33domlover> there's type as in "type of values" and as in "type of something, i.e. a set things can be belong or not belong to which repreents some characteritics (a.k.a a class, like in RDF)
00:25:15 <jle`> but we already distinguish between monoid and Monoid, so I guess that's okay
00:25:16 <merijn> Type /= type, in haskell and Idris
00:25:36 <Cale> Yeah, in dependently typed settings, you have the luxury of reserving the word "type" for "just those values which are admitted on the right side of the colon"
00:26:14 <Cale> Even if you don't have universes
00:26:28 <Cale> Well... I dunno
00:26:41 <Maxdamantus> Idris> the (the (Type -> Type) id Int) 4
00:26:41 <Maxdamantus> 4 : Int
00:26:42 <jle`> before 8.0, Type would just mean type, where someone was a bit over-eager on their Shift key.  now Type is a thing, and it's not the same as types.  oh well
00:26:52 <Cale> Maybe if you didn't have universes it would affect what you'd want to call things again
00:26:56 <merijn> Rotaerk: Counter example: "data Void" <- is Void not a type? It doesn't have values in it (well it does in non-total languages, but let's ignore that for now)
00:27:19 <Maxdamantus> Idris> the (the (Type -> Type) Maybe Int) (Just 4)
00:27:19 <Maxdamantus> Just 4 : Maybe Int
00:27:20 <Cale> merijn: It is a valid question to ask whether a value has type Void regardless.
00:27:38 <Cale> merijn: in nonempty contexts, something may have type Void
00:28:03 <Cale> (even in total languages)
00:28:46 <Rotaerk> Void at least can be described as having a carrier set (one that's empty)
00:29:04 <Rotaerk> but State isn't even an empty set of values
00:29:37 <merijn> Rotaerk: I guess it boils down to, I think it's more confusing that types/type signatures could have non-types in them
00:29:43 <merijn> What would you even call them if not types?
00:30:30 <Maxdamantus> vands.
00:30:42 <Rotaerk> yea I think that question is what started this conversation
00:31:22 <Cale> Consider for example, (((a -> Void) -> Void) -> Void) -> a -> Void -- while writing this, you might produce something of type Void in a nonempty context :)
00:31:35 <Cale> (It is possible to write that function)
00:32:38 <Maxdamantus> You just can't actually call it in a total language.
00:32:53 <Cale> You can call it...
00:32:59 <Maxdamantus> You can of course continue postulating about calling it by writing additional functions around it that will never be called.
00:33:22 <Maxdamantus> Oh right, yes.
00:33:41 <Maxdamantus> wait, no.
00:33:55 * Maxdamantus thinks some more.
00:34:22 <Rotaerk> in any function-application expression, like f a b c, is there a word that refers to each of f, a, b, and c?
00:34:25 <Rotaerk> "term" or something?
00:35:01 <Rotaerk> eh nevermind...
00:35:05 <Cale> Maxdamantus: Well, it depends on what you mean by "call"
00:35:14 <Maxdamantus> Yeah, I don't think you can.
00:35:18 <Cale> Maxdamantus: You can certainly apply it in other expressions
00:35:30 <Maxdamantus> Cale: yes. But it's never going to actually be called.
00:35:36 <Maxdamantus> as part of evaluation of the program.
00:36:06 <Cale> It might however be essential to the definition of things which will be evaluated, even if it won't exactly be the focus of the evaluator.
00:36:20 <Maxdamantus> All you're doing otherwise is writing more functions that will never be called.
00:36:31 <Cale> You sometimes have to give a proof that some case cannot happen.
00:36:44 <Cale> Before the type checker will admit that your pattern match is complete.
00:36:55 <Cale> So such a thing can certainly be useful.
00:38:06 <Maxdamantus> Yes. Things can be useful even if they're not part of program evaluation.
00:38:56 <Cale> Actually, heh, such a function might end up being the focus of the evaluator as well...
00:40:15 <Cale> I'm trying to think if I can come up with any sort of reasonable example...
00:40:49 <Cale> where the typechecker has to reduce an expression of type Void with free variables in it
00:41:14 <Cale> I guess such things are ultimately going to be stuck terms, but perhaps unification can happen anyway in some cases?
00:41:56 <scshunt> man, seq is magical
00:43:43 <Cale> seq x y basically just means "ensure that x is evaluated before resulting in y" (but be careful, the compiler may still choose to evaluate y first, it's just that the result of the seq won't be available to pattern match on until x has been evaluated to WHNF)
00:44:59 <kryft> Cale: Huh, maybe that explains some problems I had with my first haskell project some years ago. :)
00:47:02 <Cale> GHC will tend to only make that swap if it would be beneficial, but yeah,  x `seq` y `seq` z  and  y `seq` x `seq` z  really mean the same thing.
00:47:28 <Cale> and   x `seq` x means the same as  x
00:59:27 <Rotaerk> is seq a primitive? its source doesn't seem to be here:  http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:seq
01:01:02 <merijn> Rotaerk: Yes
01:01:08 <merijn> seq is compiler magic
01:01:15 <Rotaerk> k
01:01:20 <Cale> It can be implemented for most types directly
01:01:21 <merijn> It can't be implemented in haskell
01:01:25 <Cale> But not for functions
01:01:40 <Cale> It used to be a type class method
01:02:01 <scshunt> of what class?
01:02:02 <Cale> class Eval a where seq :: a -> b -> b
01:02:14 <Cale> (roughly)
01:02:26 <Cale> and you'd have stuff like
01:03:08 <Cale> instance Eval (Maybe a) where seq m x = case m of Nothing -> x; Just _ -> x
01:05:08 <Cale> But yeah, the instance for functions is magic
01:06:43 <Rotaerk> interesting
01:06:43 <Cale> But not really *that* magic... you could also say that it's a bit magic that case expressions can avoid forcing evaluation of their scrutinee, in cases where the pattern is a simple variable.
01:07:22 <shachaf> Cale: Why?
01:07:57 <Cale> shachaf: Well, it's just a little bit non-uniform -- case down at the level of core always evaluates.
01:08:15 <shachaf> If you have case x :: Maybe (Maybe t) of { Nothing -> ...; Just x -> ... }, should it force x?
01:08:26 <Cale> shachaf: well, no :)
01:08:40 <shachaf> If you're talking about Core case, which is a different construct, then sure, nested expressions like that aren't allowed.
01:08:50 <Cale> right
01:08:52 <shachaf> But then I'd say you shouldn't be able to case a function in the first place.
01:09:00 <Cale> I believe you can
01:09:04 <shachaf> In Core you can, yes.
01:09:21 <Cale> If case always evaluated its scrutinee at least to WHNF, we could have  instance Eval (a -> b) where seq f x = case f of g -> x
01:09:48 <shachaf> Right.
01:10:22 <Cale> (I'd intended to write that earlier, but it got pushed on the stack ;)
01:10:26 <shachaf> But that seems like an odd thing to want just to justify being able to write seq for functions.
01:10:52 <shachaf> Especially since const undefined *should* be indistinguishable from undefined anyway.
01:11:18 <Cale> Remember that the whole idea here was to explain that seq for functions isn't *that* magical
01:11:49 <shachaf> Right. And I'm saying it's not a good explanation. Or maybe I'm saying there is no good explanation, because seq for functions is that magical.
01:11:52 <shachaf> Maybe I'm not helping here.
01:12:19 <shachaf> "scrutinee" is a good word, though.
01:12:35 <Cale> It's about as magical as what prevents case from evaluating its scrutinee all the time... which is not very magical.
01:33:36 <merijn> If I have a StateT with some state 's' and now find myself needing to track another piece of state, there's no realy elegant way to add that in without lots of ugly changes, is there? :\
01:34:00 <Athas> Why not just layer two StateTs?
01:34:16 <merijn> Athas: That means ugly lifting of get operators :\
01:34:28 <cocreature> merijn: zoom?
01:34:36 <Athas> I'd just define two specialised getInner and getOuter functions.
01:35:16 <jle`> merijn: you can use zoom _1
01:35:24 <jle`> zoom _1 :: State s a -> State (s, t) a
01:35:30 <jle`> zoom _2 :: State s a -> State (t, s) a
01:35:42 <jle`> monad morphisms to the rescue
01:36:03 <merijn> I thought about lens, but not sure if there's a nice way to have accessor lens for those
01:36:11 <merijn> jle`: That doesn't work if access is interleaved, no?
01:36:20 <jle`> what do you mean?
01:37:17 <jle`> if you have a chunk of your do block that only uses one state element, you can do
01:37:20 <jle`> zoom _1 $ do ...
01:37:25 <merijn> Adding "zoom _1" in front of every use isn't much nicer than changing it into "gets fst"
01:37:41 <jle`> yeah, but zoom _1 associates like liftIO does
01:38:04 <jle`> the point is to zoom entire blocks or large actions at a time :3
01:39:10 <merijn> jle`: Yes, but I don't have entire blocks or large actions, just interleaved small ones
01:40:07 <jle`> `do x; y; z` can be do (zoom _1 $ do x; y); z
01:40:12 <jle`> if x and y are in the old state
01:40:23 <jle`> but yeah, if you don't really have any nice contiguous blocks you can zoom, it's less useful
01:40:53 <jle`> well, if your only access is with 'gets'
01:41:07 <jle`> zoom is about taking your perfectly good `State s a` actions, and using them in `State (s, t) a` contexts
01:42:35 <jle`> merijn: and you can't replace it all with 'gets', becuase your State actions might modify state
01:43:38 <jle`> a "State s a" might modify the s, and zoom _1 to make  it a (State (s, t) a) changes the first value in the tuple according to how the original (State s a) did
01:57:04 <Cale> merijn: Well, what would be elegant? Usually if I'm going to use StateT at all, it'll involve a record type to begin with, so I'll just add the new piece of state to the record type.
01:59:04 <merijn> Cale: Yeah, I think I have to introduce that and move some code around
01:59:05 <Cale> I try pretty hard to avoid StateT in general though -- particularly over IO, the payout in terms of cleaning up a function parameter is usually not worth the cost in terms of lifting.
02:00:18 <merijn> Cale: Explicitly managing parameters all the time is rather annoying, though
02:00:41 <Cale> Yeah, but it's not like StateT is a silver bullet for that design problem :)
02:01:30 <merijn> Cale: It's a lot nicer than explicitly passing stuff around
02:01:46 <dysfun> is there somewhere with really detailed documentation on writing FFI bindings?
02:01:53 <dysfun> in particular, i'm trying to write storable instances
02:02:28 <Cale> Figuring out which building blocks you really want to carve things into, and what the means of combination ought to be is tricky, and sometimes leaving the function parameters in a bit longer helps identify what's really going on
02:02:34 <dysfun> i'm currently struggling along between my paper copy of RWH and some github repo i found with a few examples of hsc2hs
02:04:47 <merijn> Cale: I'm rewriting some existing code, so I'm already pretty sure what I want
02:05:01 <Cale> dysfun: Have you read http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html ?
02:05:50 <Cale> dysfun: It's significantly less dry than the Haskell Report generally is
02:06:25 <dysfun> it looks interesting, and no i hadn't come across it
02:06:31 <dysfun> i'll give that a read. thanks
02:07:40 <Cale> dysfun: It might not answer your question about how to write Storable instances... but it'll at least tell you exactly what the Storable type class is and what its methods are supposed to do.
02:10:30 <jle`> merijn: you can absorb State over parts of your record into a larger record with zoom too
02:10:57 <jle`> merijn: if you have data Foo = F { _thing :: Int, _other :: Bool }, then zoom thing :: State Int a -> State Foo a
02:11:38 <jle`> turns a state action working with an Int state into a State action working on a Foo state, that only ever can see/modify the _thing field
02:11:52 <jle`> it's a nice way of simulating encapsulation and data hiding sorta
02:12:31 <angerman> what
02:12:37 * hackagebot safe-access 0.2.1.2 - A simple environment to control access to data  https://hackage.haskell.org/package/safe-access-0.2.1.2 (thoferon)
02:13:18 <angerman> what's the suggested FTP backwards compat switch? Say I want to use traversable, but still allow to compile with 7.6?
02:14:38 <dysfun> Cale: well my problem is figuring out how to marshal between C and haskell, so it looks good for answering my question
02:18:57 <cocreature> angerman: you can use the base-compat package
02:19:51 <angerman> cocreature, alright, let me have a look. Thanks!
02:42:38 * hackagebot google-mail-filters 0.0.1.2 - Write GMail filters and output to importable XML  https://hackage.haskell.org/package/google-mail-filters-0.0.1.2 (LiyangHu)
02:42:40 * hackagebot yate 0.1.0.1 - Yet Another Template Engine  https://hackage.haskell.org/package/yate-0.1.0.1 (thoferon)
02:44:26 <montanonic> If I wanted to use an Unordered Set with Persistent, how...might I do it? I'm trying to speed up a field that basically amounts to "who liked this post", and currently I just use a list, adding the Id of any user who likes it, and then doing a filter to remove their Id if they unlike it.
02:45:01 <montanonic> But as a minor challenge, I wanted to try to *not* use lists to solve this problem, but it doesn't seem like Persistent is compatible with anything other than very basic data types
02:46:07 <montanonic> The other solution would be to create a separate entity that references to a post and keeps track of the users who liked it, so that would put the lookup burden on my PSQL database, but being a noob to this stuff, this seemed like kind of a heavyweight solution compared to just using a list.
02:46:44 <montanonic> Heavyweight in the sense of: it seems like it would be even slower than using a List.
02:48:20 <cocreature> montanonic: Set from Data.Set should work with persistent if I’m reading the docs correctly
02:48:47 <montanonic> cocreature: can you like the docs? I was relying on the Persistent Entity Syntax guide, and it didn't list that (or List, either)
02:48:53 <montanonic> err, Link* the docs
02:49:08 <cocreature> montanonic: https://hackage.haskell.org/package/persistent-2.2.4/docs/Database-Persist-Class.html#t:PersistField there is an instance for PersistField
02:49:35 <montanonic> cocreature: oh...duh, I never thought of figuring it out that way. Thank you cocreature 
02:49:55 <cocreature> montanonic: I might be wrong, I never really used persistent :)
02:50:12 <montanonic> cocreature: but you directed me to a good spot, so thanks in any case :)
02:52:39 * hackagebot Hish 0.1.2.4 -   https://hackage.haskell.org/package/Hish-0.1.2.4 (jaiyalas)
02:53:01 <rtur> Hi guys. Why does the fooF function here http://paste.debian.net/hidden/2b9c6704/ work ? As I see it it should give a "Couldn't match expected type .." error since fooF gets itself and a "n" as arguments but in order for "fix" to use it it needs to be (t->t), not (t->t)->t . I kinda understand why it works, I just can't articulate it clearly :), could you give me a hint ?
02:53:33 <rtur> oh, the call would look like "fix fooF 101"
02:55:35 <liste> rtur: hint: what's `t' in "fix fooF 101" ?
02:55:42 <liste> for fix
02:55:52 <rtur> anything it needs to be
02:55:56 <liste> but in that case
02:56:10 <rtur> oh, then it's t::(integer -> integer) -> integer
02:56:48 <rtur> right, thank you.
02:57:02 <liste> rtur: no
02:57:39 <liste> rtur: try again
02:57:39 <rtur> in "fix fooF 101" it is the whole fooF, so (Integer -> Integer) -> (Integer -> integer)
02:57:52 <rtur> and ten fooF gets the n
02:57:59 <rtur> then
03:00:10 <rtur> so it's t::(Integer->Integer) -> (Integer ->Integer) , and then after fix returns it all the n is passed to fooF, right liste ?
03:00:11 <liste> so, in this case "fix :: ((Integer -> Integer) -> (Integer -> Integer)) -> (Integer -> Integer)"
03:00:23 <liste> so "fix fooF :: Integer -> Integer"
03:01:54 <rtur> liste, thanks again, I think I got it.
03:02:58 <kosc> Hello.
03:03:57 <liste> hello kosc 
03:37:59 <aristid> angerman: maybe more efficient to continue the discussion about Data.Traversable vs Prelude.Compat here
03:38:01 <rtur> Yey, just figured out the Answer to a question I've been typing for the last 3 minutes :). A shame I can't take a keyboard into exams, seems typing helps :D.
03:38:21 <liste> rtur: it's known as rubber duck debugging
03:39:00 <angerman> aristid sure :) tbqh, i have no preference to either. Hence, just wanted to point out that cocreature pointed me towards base-compat.
03:39:26 <aristid> cocreature: why did you prefer base-compat's Prelude.Compat over Data.Traversable? :)
03:40:27 <cocreature> aristid: I don’t I thought the question was generally about backwards compatibility and traversable was just an example
03:41:26 <cocreature> and if you care about -Wall it might make sense to use backe-compat to avoid the redundant import warnings
03:42:14 <rtur> liste, I think it also helps that since the channel was my rubber duck for that question I thought it better through since the duck would have the chance to talk back :), it's a higher level of rubber duck debugging I think.
03:43:27 <merijn> Bleh, there's no "modify" that returns the new state?
03:43:40 <solirc> aristid: I'm not in the context of the discussion, but I think if you want to have -Wall sane code for GHC 7.8 and 7.10 you either need CPP or some compatibility shim.
03:44:05 <angerman> oh my god. what did I start :D
03:45:52 <aristid> cocreature, solirc: makes sense, i guess. for now i prefer to live with the warnings, though.
03:46:02 <aristid> angerman: can you please use Data.Traversable? :)
03:46:40 <aristid> i believe i also have such warnings about Control.Applicative already :D
03:46:58 <angerman> aristid did some blind change to the patch, waiting for travis to confirm I did it right :D
03:47:30 <aristid> angerman: because you only have ghc 8? :)
03:47:50 <angerman> aristid because I'm lazy and github allows to "edit" :D
03:48:25 <angerman> aristid green :-)
03:48:41 <angerman> aristid should we discuss #193 as well?
03:48:41 <aristid> travis will not test with ghc 8 tho :D
03:50:34 <aristid> angerman: ok, now i'm finding another problem with your patch: the V.Vector instance is too different from the [] instance. not sure if the same criticism also applies to the M.Map instance
04:25:17 <j0llyr0tten> if you search for TaPL and Haskell you get at least five implementations
04:25:59 <j0llyr0tten> that's just from the first two pages of Google search hits
04:27:35 <j0llyr0tten> i presume that is because Haskell is used as least as much as the MLs with, I guess, OCaml being the most used?
04:37:43 * hackagebot alarmclock 0.2.0.9 - Wake up and perform an action at a certain time.  https://hackage.haskell.org/package/alarmclock-0.2.0.9 (dcturner)
04:52:18 <ij> How are types that use another type called? IO/[] both require a type argument thus IO/[] is a ?
04:53:17 <tdammers> polymorphic type? * -> *? higher-kinded?
04:54:40 <ij> polymorphic sounds best!
04:55:27 <bernalex> ij: type constructor.
04:55:39 <bernalex> a polymorphic type is the a in
04:55:42 <bernalex> :t id
04:55:43 <lambdabot> a -> a
04:56:24 <bernalex> so Maybe is a type constructor which you can give a type, like Int, and get Maybe Int as a concrete type.
04:57:10 <tdammers> right, the IO alone is a type constructor
04:57:25 <ij> But it's a type too, no?
04:59:03 <pavonia> ij: Opinions differ, some won't call it a type
04:59:04 <ski> ij : "polymorphic" is (imho) wrong
05:00:30 <ski> afaik, there's two main variants. according to the first, `IO',`[]',`Either',`Either String' are all "type constructors" (hence the older terminology "constructor classes" for type classes like `Functor',`Monad', as opposed to ones like `Eq',`Show',`Num')
05:01:27 <ski> according to the second, `IO',`[]',`Either' would be "type constructors", but `Either String' wouldn't. however, all of these are types (in fact, type functions, as opposed to `IO Int',`Bool',&c.)
05:01:53 <sdx23> :k Maybe
05:01:55 <lambdabot> * -> *
05:01:57 <sdx23> :k Maybe Int
05:01:58 <lambdabot> *
05:02:28 <ski> (according to the first, (plain) "type" is reserved for type expressions which are capable of being inhabited, of having values. those which have kind `*')
05:03:59 <ski> i'd say things like `id',`length',`Nothing' are all polymorphic (values). their respective types, however, are all monomorphic types
05:04:41 <ski> in any case, the `a' in `id :: a -> a' can not be said to be polymorphic. `a' is a type variable
05:05:33 <Ferdirand> if you reserve the word "type" for type expressions of kind "*", shouldn't you also reserve the word "value" for expressions that are not function types ?
05:06:08 <ski> you'd have to ask the people who do the former
05:06:46 <Ferdirand> or, to spin it a little bit: if we are proud of our functions being first-class values, shouldn't we also have our type functions be first-class types ?
05:06:52 <Ferdirand> class struggle !
05:07:29 <ski> (in some papers, i've seen the term "family" used more generally for "type expressions" of arbitrary kind. iow including ones of kind `*' as well as ones of kind `... -> ...')
05:07:58 <ski> Ferdirand : that's my standpoint as well, i suppose
05:08:41 <ski> ij : makes sense ?
05:09:31 * tdammers mumbles something about dependent types and the type of all types that do not inhabit themselves
05:13:49 <ij> it makes sense.
05:15:14 <ij> There should be consensus.
05:15:47 <ski> `length' is polymorphic because it can operate on list inputs of many diverse types. each of these uses correspond to a specialized type signature for `length', involving no type variables
05:16:35 <ij> Use of «polymorphic» based on intuituition seems to be.
05:16:45 <ski> or, let's take `take', instead
05:16:52 <ski>   take :: Int -> [a] -> [a]
05:17:11 <ski> monomorphic instances of this include
05:17:18 <ski>   take :: Int -> [String] -> [String]
05:17:41 <ski>   take :: Int -> [(IO String,String -> Bool)] -> [(IO String,String -> Bool)]
05:17:41 <ij> Okay, that's all clear.
05:17:43 <ski>   ...
05:18:04 <ski> (each time consistently replacing each type variable, here only `a', with a single concrete type)
05:18:20 <ski> note that the signature `take :: Int -> [a] -> [a]' is really short for
05:18:26 <ski>   take :: forall a. Int -> [a] -> [a]
05:18:52 <ski> and it's really the presence of this (top-level) `forall' in the type that indicates that `take' is a polymorphic value (function, in this case)
05:19:22 <ski> otoh, `forall a. Int -> [a] -> [a]' has kind `*', which involves no `forall' at all. therefore `forall a. Int -> [a] -> [a]' is a *monomorphic* type
05:19:24 <ij> The initial problem is that I was explaining fmap and I want to say what "f a" was. I guess it's a type function?
05:19:50 <ski> i would say `f' is a type function. `f a' is an application of that type function to the type `a'
05:21:17 <ski> one could think of a type function as an "incomplete type". you can't say `x :: []' (`x' is a list of *what* ?), you have to say `x :: [] Int' (which is sugared into `x : [Int]')
05:22:01 <ski> and then `*' is the kind of complete/concrete types. `[] :: * -> *' meaning that `[]' is a type function that when given a concrete type, will yield/specify a concrete type
05:22:33 <merijn> I would say "f" is a type
05:22:39 <merijn> Type function has a more specific meaning
05:22:47 <merijn> And haskell without extensions does not have type functions
05:23:09 * ski includes those extensions in the term "type function"
05:23:22 <merijn> Also, insert usual objection to the use of the ambiguous term "concrete type"
05:23:31 * ski nods
05:26:32 <ij> merijn, But so is Int and that's not what I mean to say.
05:27:45 <merijn> ij: Int is a type of kind *
05:28:03 <merijn> ij: 'f' is a type of kind (in this case) * -> *
05:28:13 <merijn> 'f a' is a type of kind *, just like Int is
05:28:26 <ij> So why isn't it a type function?
05:28:44 <merijn> ij: A type function implies more power than 'f' can have in Haskell without extensions
05:28:47 * ski considers `Just' to be a (value) function
05:29:25 <merijn> ij: That is, if 'f' is a type function, it could inspect it's argument type and return different things depending on that argument type
05:30:16 <merijn> ij: The TypeFamilies extensions introduce actual type functions, which lets you write, e.g. "type family Foo a where Foo Int = Char; Foo Bool = Int; Foo x = ()"
05:31:10 <ski> i think that argument is similar to not considering yourself to be your own sibling. iow an "exclusive" view, rather than an "inclusive" view. i tend to prefer the latter, unless there's a more compelling reason not to
05:31:25 <merijn> ij: In which case "Foo a -> String" would be equivalent to "Char -> String" if 'a = Int', or equivalent to "() -> String" if 'a /= Int && a /= Bool'
05:32:47 <merijn> ij: Contrast with, say, Maybe, which can't return a different type depending on it's argument (it being a type constructor, rather than a function)
05:32:55 <ski> (cf. with how squares are usually also considered to be rectangles, &c.)
05:33:12 <merijn> ij: Essentially, type constructors are similar to type functions in the way that value constructors are similar to functions
05:35:03 <ski> `Maybe' is clearly in some sense a "uniform/parametric" type function (in my terminology). i don't see why one should exclude these from type functions which *actually* does nontrivial case-matching on their inputs
05:36:21 <fr33domlover> ski, indeed 'Maybe' (the type) is a "simple" type function like 'Maybe' (the ctor) is a simple value function :
05:36:22 <ski> (in a similar sense as how `Just' is a "uniform/parametric" value function. or if you prefer (to avoid parametric types), take `MkPerson' instead, given `data Person = MkPerson Name Age')
05:36:24 <fr33domlover> :P
05:36:33 <fr33domlover> oops yeah
05:36:36 <fr33domlover> i meant 'Just' there
05:36:47 <fr33domlover> what ski said :P
05:36:53 <ij> merijn, So it's weaker, but you can stretch it a bit and call it a function too.
05:38:24 <ski> (and i definitely consider `Just' to be a value function (and also more). i can pass `Just' as an argument to another function just fine, e.g. (in OCaml, you'd have to eta-expand it))
05:39:16 <ij> Funny how you talk in parentheses.
05:48:29 <merijn> I agree that Just has a function type, similar to how Maybe has a "type function kind"
05:49:00 <merijn> Whether I consider them constructors functions depends on context, but I think it's important to understand the pedantic version before becoming sloppy with terminology
05:51:20 <ski> i agree with that
05:52:57 <ski> (so i guess we differ here on what we consider sloppy terminology)
05:59:51 <Vijfhoek> What's a neat way of converting a Linear.V2 Float to a Linear.V2 CInt?
06:00:10 <Vijfhoek> Just a new function?
06:04:04 <Vijfhoek> "v2ToCInt (V2 x y) = V2 (round x) (round y)" is my current solution
06:04:28 <maerwald> any1 knows if there is a solution for the false "Pattern match(es) are non-exhaustive" warning when using PatternSynonyms?
06:05:45 <ski> Vijfhoek : if `Functor Linear.V2', then `v2ToCInt =  fmap round' should work, i think ?
06:06:35 <maerwald> I basically want to expose a constructor for pattern matching, but without allowing to use it for constructing the type... that's what PatternSynonyms let me do with uni-directional pattern. But they cause these "Pattern match(es) are non-exhaustive" warning bugs in GHC
06:06:53 <Vijfhoek> That's better, ski
06:07:09 <Vijfhoek> Short enough to kill the function
06:38:53 <dsub> Does anyone have a suggestion for a package/library to work with a sql-db? In real-world-haskell they mention Database.HDBC. Is this still valid (the book is quite old)?
06:40:54 <spartakos87a> hello
06:41:09 <ski> hello spartakos87a
06:42:01 <rydgel> dsub: there are postgresql-simple and mysql-simple
06:43:13 <dsub> rydgel: does mysql-simple work with mariaDB as well?
06:43:18 <Spartakos87a> Hello I am a new in Haskell and I want some additional info
06:43:58 <rydgel> dsub: I heard so
06:44:12 <ski> what do you want additional info on, Spartakos87a ?
06:44:28 <rydgel> dsub: those lib are "simple" library in a sense that they don't have tons of functionality.
06:44:51 <rydgel> dsub: You can check Persistence if you want something with more stuff
06:45:09 <dsub> rydgel: Thanks, will look into it.
06:45:14 <ski> Spartakos87a : do you have access to a tutorial or a book ? a course ?
06:46:01 <apsod> quick question: Is the polykind syntax documented somewhere? Why, do the instance specifications look like  "Monad (Proxy *)", or  "Monoid (Proxy k s)" in hackage?
06:46:40 <Spartakos87a> First of all I want to recommend me a good book for begin,  now I have starting to read the book real world haskell
06:47:03 <Spartakos87a> Is good for begin? 
06:47:24 <ski> depending, it might be a bit fastpaced (i've heard)
06:47:34 <Spartakos87a> Yeap
06:47:34 <ski> do you know any other programming languages ?
06:47:43 <Spartakos87a> Python mostly 
06:48:21 <rydgel> Spartakos87a: I like this book a lot http://haskellbook.com/
06:48:29 <ski> i've read "Haskell: The Craft of Functional Programming", by Thompson, and i think it was good
06:48:38 <Itkovian> Spartakos87a I heard that the new haskellbook is pretty good, but I have not read it yet.
06:48:56 <ski> you can also try the one rydgel suggested. there's a channel #haskell-beginners for it. however beginner questions are also welcome in this channel
06:49:00 <Itkovian> You can get some free chapters (basic stuff mostly) http://haskellbook.com
06:49:14 <Itkovian> LYAH is also nice
06:49:19 <ski> @where LYAH
06:49:19 <lambdabot> http://www.learnyouahaskell.com/
06:50:27 <ski> some seem to think LYAH is a bit too "silly" to their tastes, and perhaps a bit unstructured and basic. however, it might work as an initial exposure
06:52:55 <Spartakos87a> Thanks a lot guys!!! 
06:52:59 <ski> Spartakos87a : also, assuming you haven't seen functional programming before, i recommend not expecting many things to be similar to how Python does it. learning a new programming paradigm will be a bit like learning to program from scratch, all over again. obviously some things *do* carry over, but it's good to approach it with an open mind, and try to leave comparisions with other approaches to programming you know for later
06:53:43 <Spartakos87a> I keep that in my mind 
06:55:00 <ski> Spartakos87a : lastly, feel free to ask the channel about stuff you find unclear/confusing, when you're learning
06:55:09 <ski> we're here to help !
06:55:43 <rydgel> You can ask here or in #haskell-beginners
06:56:18 * ski nods
06:57:58 <Spartakos87a> Ok
06:59:05 <ski> sometimes the channel is a bit slow .. it may take some while (perhaps even half an hour or more) for someone to attempt to answer your channel
06:59:20 <ski> other times the channel is very active
06:59:29 <ski> this is normal
06:59:50 <ski> (er. to attempt to answer your *question*, that is)
07:00:40 * ski is assuming Spartakos87a is new to IRC
07:12:48 * hackagebot t3-game 0.1.0.0 - tic-tac-toe core  https://hackage.haskell.org/package/t3-game-0.1.0.0 (jxv)
07:32:48 * hackagebot t3-game 0.1.0 - tic-tac-toe core  https://hackage.haskell.org/package/t3-game-0.1.0 (jxv)
07:45:09 <Xandaros> Haven't heard of that haskell book yet. I shall have a look at that.
07:45:15 <Xandaros> Personally, I learned quite a bit from LYAH
07:52:06 <ggVGc> I never understood learning programming from reading
07:52:21 <ggVGc> I made a few attempts during the years, but it doesn't make sense to me
07:52:32 <icicled> learning varies from person to person
07:52:38 <icicled> everyone learns differently
07:52:42 <ggVGc> right, that's why I said it doesn'tmake sense for me
07:53:18 <icicled> On another note, what do folks here use for managing SQL schema changes (migrations)?
07:53:26 <ggVGc> programming is such an exploratory thing to me, that it's weird to have someone say "If you do this, then you can see how you can do this" before you've come across the situation where this concept applies
07:53:57 <ggVGc> haha.. the little SQL migration stuff I've done, I've just written manual SQL scripts..
07:54:16 <icicled> yes, but then having the changes applied to separate environments?
07:54:22 <icicled> e.g. dev, test, prod
07:54:29 <icicled> and making sure its all in sync
07:55:09 <icicled> right now I'm using scripts but it's a PITA to remember to have to do it
07:55:25 <icicled> esp when I'm experimenting
07:56:56 <ggVGc> icicled: do you mean if you change the SQL schema during development and then want to push it to your production server, without messing up your data tere?
07:57:12 <ggVGc> isn't this why you version your SQL schemas?
07:57:13 <EvanR> ggVGc: im not sure anyone learns from the programming book genre, but it does make sales nonetheless
07:57:19 <icicled> in a nutshell, yes
07:57:49 * hackagebot t3-game 1.1.0 - tic-tac-toe core  https://hackage.haskell.org/package/t3-game-1.1.0 (jxv)
07:57:51 * hackagebot t3-server 0.1.0 - tic-tac-toe server  https://hackage.haskell.org/package/t3-server-0.1.0 (jxv)
07:58:59 <ggVGc> that seems like a really weird package to have on hackage
07:59:23 <icicled> yep that does seem odd
07:59:57 <EvanR> its like the one a few days about which was a package dedicated to testing if a number was positive
08:00:09 <icicled> I'm hoping that as haskell gets more popular hackage doesn't turn into a dumping ground like pypi or npm
08:00:25 <ggVGc> icicled: it kind of already is..
08:00:26 <ggVGc> a but
08:00:34 <rydgel> EvanR: I guess that was a "trolly" package about what happend recently with npm and node
08:00:42 <ggVGc> I found that one of the bigger issues when getting into haskell. that hackage is such a mess
08:00:48 <EvanR> rydgel: huh?
08:00:49 <ski> iirc, in french, `0' is both positive and negative
08:01:01 <ggVGc> ski: yeah, but to be fair french counting is a special little kid
08:01:12 <ski> (but not strictly positive nor strictly negative)
08:01:17 <EvanR> the french invented math so
08:01:30 <danza> ggVGc, icicled i agree that Hackage is already quite messy :(
08:01:55 <EvanR> hackage is a dumping ground in that stuff goes in but does not leave
08:02:04 <danza> exactly
08:02:05 <EvanR> because theres no such option
08:02:37 <icicled> I wonder how it can be managed
08:02:39 <danza> i use Github to look for relevant Haskell packages, with Hackage i can't sort
08:02:52 <rydgel> EvanR: basically a dude removed a package that only contained a one-line function to do string_padding and the whole node ecostystem broke since a lot of stuff had this package as dependencies. So people digged up a bit and found there were packages like testing if a number is positive and so on
08:03:13 <icicled> in ocaml land w/opam, their package manager, you have to submit a PR to the pkg database in order to get your package listed
08:03:14 <EvanR> lol
08:03:29 <danza> icicled, not sure that it solves the problem
08:03:44 <ggVGc> danza: but a lot of hackage code isn't on github
08:03:48 <icicled> it won't but at least someone will have to manually take a look
08:03:55 <danza> ggVGc, yeah, unfortunately ...
08:03:56 <danza> i would say that having metrics is the only way to get sense out of the multitude
08:04:18 <EvanR> im ok with not everything ever being on github
08:04:26 <icicled> likewise
08:04:27 <danza> sure, it is okay
08:04:38 <rydgel> As long as github is still there :p
08:04:45 <ggVGc> icicled: I think requiring a readme and some other basic metadata around the package, and generated docs would be a huge initial benefit
08:04:52 <ggVGc> especially the generated docs part
08:05:22 <icicled> that would cut off the cruft
08:06:13 <icicled> rather, it would create a barrier to entry for people who want to upload trivial things
08:06:52 <ggVGc> that, and also make what is submitted actually useful
08:07:21 <ggVGc> a lot of the time I end up on hackage pages and go "Okay, this seems like somethign I'd liek to use, but I have no idea if it's even doing what it's supposed to
08:07:51 <EvanR> i dont browse hackage
08:08:11 <EvanR> if i know a lib is good, or if google leads me to one, thats one thing
08:08:25 <EvanR> but perusing 1000 packages one after the other seems like asking for trouble
08:08:38 <danza> :)
08:08:51 <danza> well browsing packages can lead to interesting discoveries
08:08:58 <icicled> I like having hackage - it's been invaluable to me as I've picked up haskell
08:08:59 <danza> if one has the right browsing tools
08:09:22 <EvanR> right browsing tool unfortunately = google
08:09:41 <danza> searching /= browsing
08:09:50 <icicled> what if...bear with me here...you could use a scm as a repo based on some identifier - for e.g. tags
08:10:14 <ggVGc> EvanR: I meant that I end up on those through google
08:10:32 <icicled> e.g. in cabal you would specify say my personal github project & said grab v1.0.2 which would correspond to a tag
08:10:46 <puregreen> can't stack do that?
08:10:53 <icicled> I don't know
08:10:55 <merijn> cabal can do that, even
08:10:55 <danza> yeah it can
08:11:00 <merijn> Well, not github
08:11:02 <rydgel> sure it can
08:11:11 <icicled> lets just say git
08:11:14 <merijn> But you can point cabal at local unpublished packages and it just works
08:11:30 <icicled> and mercurial, darcs, fossil, svn, etc.
08:11:53 <danza> that was one of the first things i asked when they started working on Stack :D https://github.com/commercialhaskell/stack/issues/597
08:12:01 <rydgel> icicled: something like that https://github.com/Rydgel/flappy-haskell/blob/master/stack.yaml
08:12:22 <icicled> ah nice
08:12:51 <rydgel> also working with local packages
08:14:47 <icicled> ok, so if this is possible already with Cabal & Stack then perhaps there should be some sort of documentation on Hackage that tells people to use this feature for private projects
08:15:41 <icicled> superfluous projects rather
08:16:47 <rydgel> icicled: Stack does: https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
08:17:43 <icicled> that's good
08:17:48 <icicled> but what about hackage?
08:18:18 <rydgel> icicled: what do you mean about hackage?
08:20:04 <anax> Does anyone have problems with ghci in Windows? It crashes frequently when I run QuickCheck tests
08:20:34 <icicled> It'd be nice if hackage had a notice or blurb saying: please don't upload personal packages to hackage - if you would like to have others use them here are some docs showing how to do that
08:20:45 <icicled> something to that effect
08:21:28 <icicled> there are 9 tic tac toe packages on hackage...
08:21:47 <rydgel> icicled: Oh, well. I really don't know how we can prevent that easily. I guess it's the same problem everywhere when there is no human checks.
08:22:05 <icicled> or at least upload them to a Personal category or soemthing
08:22:20 * ski notes that there's someone else using the `ndm' nick atm
08:23:15 <rydgel> I understand that those packages don't belong there. But in practice they never were problematic for me.
08:23:44 <icicled> it will make it harder to find things in the future
08:24:12 <icicled> e.g. have a look at the python package index: https://pypi.python.org/pypi
08:24:31 <rydgel> icicled: I don't brow Hackage honestly, I search stuff on Google and find what I need
08:25:36 <rydgel> there are tic tac toes too :p
08:26:37 <rydgel> Maybe a list of trusted packages curated by the community would be what we need
08:28:06 <Gurkenglas> Perhaps Pagerank on the dependency list
08:28:13 <Gurkenglas> *graph
08:29:02 <rydgel> Do we have metrics on Hackage, like number of downloads and stuff?
08:29:20 <Gurkenglas> Yep https://hackage.haskell.org/package/base "Downloads	15558 total (145 in last 30 days)"
08:30:35 <danza> yup, there are interesting metrics already
08:31:12 <icicled> dependency graph + metrics could yield some interesting visualizations
08:31:52 <rydgel> indeed
08:32:04 <danza> unfortunately Haskell is not the most suitable tool to produce such visualisations :D
08:32:28 <rydgel> Hackage might need a visual revamp too, something with more usability
08:32:35 <icicled> that's ok - could just be some javascript
08:32:53 <merijn> rydgel: Pretty sure patches to hackage are welcome :)
08:33:16 <merijn> rydgel: See #hackage :)
08:33:22 <rydgel> merijn: I know :)
08:33:42 <rydgel> I would gladly help if I was a good designer
08:33:48 <maerwald> https://downloads.haskell.org/~ghc/7.0-latest/docs/html/users_guide/options-sanity.html doesn't indicate that there is a "-Wextra" or "-Wall-and-I-mean-all" flag
08:35:01 <hjulle> Is there a shorter way to write Proxy :: Proxy 5? (or some alternative)
08:38:13 <Gurkenglas> http://lpaste.net/5526670316270518272 top 100 packages by reverse dependency count
08:38:36 <merijn> maerwald: 7.0-latest seems to imply that's a rather old builds
08:39:08 <maerwald> merijn: https://downloads.haskell.org/~ghc/7.8-latest/docs/html/users_guide/options-sanity.html nothing too different here
08:39:14 <puregreen> does anyone know why ‘munch’ (from ReadP) is not the same as ‘many (satisfy p)’? documentation doesn't help
08:39:17 <puregreen> https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:munch
08:39:31 <merijn> hjulle: Not really, unless you write some scary TH voodoo?
08:40:32 <maerwald> it's already quite annoying and misleading in C that -Wall does _not_ mean "all warnings"
08:40:34 <hjulle> Ok, it just felt so cumbersome for every time I want a type level number, but I guess I'll cope. thx.
08:40:46 <maerwald> but now I can't even say "-Wextra"
08:40:54 <Gurkenglas> > (`evalStateT` "abc") $ many $ mapStateT maybeToList $ StateT uncons -- puregreen, here's why
08:40:56 <lambdabot>  ["abc","ab","a",""]
08:41:54 <icicled> Gurkenglas: where'd you grab those stats from?
08:42:46 <Gurkenglas> icicled, pasted http://packdeps.haskellers.com/reverse into a text file and used ghci. The process was remarkably frustrating, while the haskell part was trivial
08:42:47 <monochrom> puregreen: ReadP provides nondeterminism usually (list of all parses). many p is maximally nondeterministic in how many times p happens. munch p deterministically does longest match, no choice.
08:43:41 <icicled> Gurkenglas: I've never seen thave site before - thanks
08:44:28 <puregreen> Gurkenglas, monochrom: thanks (I missed that ReadP was nondeterministic)
08:45:07 <GLM> How can I get around parse errors when I have a . in the package name for a build-depends in a cabal file?
08:47:25 <monochrom> it is simplest to simply not have a .
08:47:51 <GLM> How do I do that for something like Data.List then?
08:48:04 <monochrom> Data.List is not a package name. it's a module name.
08:48:12 <maerwald> :o
08:48:27 <monochrom> all confusions are caused by wrong assumptions.
08:48:39 <GLM> How do I get that module then?
08:48:44 <monochrom> debug your mind, not your cabal file
08:48:54 <byorgey> GLM: Data.List is in the 'base' package
08:49:10 <maerwald> yeah, you can just import it straight away
08:49:24 <byorgey> well, you do still have to list 'base' in the build-depends field
08:49:51 <GLM> I have base in my build depends and it is failing
08:50:00 <maerwald> byorgey: default cabal file already includes that or not?
08:50:05 <monochrom> then the cause is elsewhere
08:50:22 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html
08:50:59 <maerwald> yes, seems "cabal init" does
08:50:59 <jameseb> GLM: how is it failing? is there an error message?
08:51:34 <Gurkenglas> Can I make stack automatically add missing entries to the extre-deps list?
08:51:38 <byorgey> maerwald: yes, though I don't remember whether it always includes 'base' or if it only does so when you have some starter code which imports something from base
08:52:48 <GLM> jameseb:      Could not find module ‘Data.Csv.Streaming’
08:52:51 * hackagebot t3-client 0.1.0.0 - tic-tac-toe Rexports for client  https://hackage.haskell.org/package/t3-client-0.1.0.0 (jxv)
08:53:09 <monochrom> it adds "base >=4.8 && <4.9" in an empty directory
08:53:19 <monochrom> that is not Data.List
08:53:30 <byorgey> so it does
08:53:36 <MarcelineVQ> Gurkenglas: stack solver --update-config
08:53:53 <jameseb> GLM: well, then you need the package Data.Csv.Streaming is in
08:53:55 <monochrom> I think it's enough moving-goal-post for a day
08:54:19 <byorgey> GLM: Is that from cassava?  Then you need to add cassava to your build-depends
08:54:32 <MarcelineVQ> Gurkenglas: It used to be called --modify-yaml I think
08:54:47 <Gurkenglas> used to? I must have an old version
08:55:00 <Gurkenglas> Does stack have a command to update itself?
08:55:02 <maerwald> byorgey: yep, but it also adds Setup.hs for me which imports Distribution.Simple... which could be the reason it adds base
08:55:04 <GLM> How can I tell what package it should be in it it isn't in the package import name?
08:55:26 <byorgey> maerwald: Distribution.Simple is from the Cabal package though, isn't it?
08:55:33 <maerwald> yes and that needs base
08:55:43 <byorgey> right, fair enough
08:55:46 <MarcelineVQ> stack upgrade if your version is recentish
08:55:56 <monochrom> Setup.hs is not compiled under the build-depends restriction.
08:56:05 <maerwald> hmm
08:56:07 <byorgey> well, except you don't have to list all transitive dependencies in your .cabal file
08:56:12 <monochrom> so for example Cabal is unlisted but nothing goes wrong
08:56:23 <byorgey> I suspect I just made it always add base as a special case, but it was so long ago I don't remember =)
08:57:31 <byorgey> GLM: you can search for the module name on Hackage, using e.g.  hayoo
08:57:34 <byorgey> @where hayoo
08:57:34 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
08:58:09 <bartavelle> "@where hayoo"
08:59:07 <maerwald> would be nice if that functionality (searching for packages that have module named "Foo.Bar") was in cabal
08:59:34 <monochrom> old hackage used to be able to search by module name
09:00:35 <monochrom> ghc called by cabal has that functionality if you have the package but forgot to name it. you get the error message "can't import Data.List, it's in hidden package base"
09:01:19 <monochrom> to be fair, it is entirely lost if you don't have that package
09:02:56 <maerwald> and then make it a vim plugin that automatically adds that stuff to your cabal file once you write an import in your Modules :D
09:05:06 <monochrom> I fear vim plugins
09:05:52 <mauke> timeo plugines et dona ferentes
09:07:03 <maerwald> monochrom: yi is not there yet to compete with something like vim/emacs, is it?
09:07:56 <monochrom> I don't know. I fear vim plugins because I use emacs and I heard that some vim plugins have bugs or limitations. it's irrational.
09:08:10 <maerwald> inb4 editor war
09:08:38 <fool> Why does the author of "Learn You A Haskell" call him/herself "Bonus"?
09:08:53 <hpc> i fear vim plugins because i got to watch my coworker struggle with a heavily tweaked vim for months
09:09:08 <monochrom> I don't know. probably the same reason why the author of the lazy evaluation article calls himself monochrom
09:09:15 <hpc> fool: it's BONUS, him, and it's the same reason you call yourself fool
09:09:16 <hpc> ;)
09:09:34 <maerwald> welcome to the internet
09:09:36 <ski> preflex: xseen BONUS
09:09:41 <aristid> woah, ghc 8.0 is _even_ slower than 7.12
09:09:48 <hpc> preflex: xseen preflex
09:09:50 <fool> hpc: k
09:10:20 <hpc> his real name is somewhere on the LYAH site as well
09:10:37 <fool> hpc His real name is Miran something. Something Polish, I guess.
09:10:47 <hpc> something like that
09:10:50 <ski> (afaiac, BONUS is his real name)
09:10:52 * hpc is too lazy to check
09:11:05 <hpc> my full name is haskell program coverage
09:11:26 <puregreen> Miran Lipovača
09:11:32 * ski thought it was something with "czar" ..
09:12:25 <fool> Does anyone use XMonad here?
09:12:43 <Clint> yes, many people do
09:15:05 <ski> fool : there's even a channel #xmonad
09:15:40 <aristid> puregreen: hm that doesn't sound polish to me (and i'm a total expert because a lot of colleagues of mine are polish :D)
09:15:53 <puregreen> it's not Polish, yep
09:16:00 <puregreen> it's Slovenian
09:17:02 <puregreen> http://learnyouahaskell.com/faq (the last section)
09:17:38 <aristid> so the polish version would be something like Mrzirej Lipolacz i guess :D
09:20:34 <danza> hi all, i am having some troubles writing a client which needs OAuth 1 authentication
09:20:43 <jophish> Am I asking too much of GHC: https://gist.github.com/4e2abd91599afde1633df0c989c87131
09:21:30 <danza> i opted for this package http://hackage.haskell.org/package/oauthenticated-0.1.3.4, but it requires an old base, and i wasn't able to install it with Cabal or Stack
09:22:20 <danza> i am currently trying with Stack ... it gives me "oauthenticated not found" for all possible build plans ...
09:22:46 <danza> maybe oauthenticated never made it to lts, which seems to be what Stack is referring to
09:23:05 <danza> so i am trying to install oauthenticated directly from the Git repo
09:23:42 <danza> i added a YAML file like in http://docs.haskellstack.org/en/stable/yaml_configuration/, but `stack init` still can't find oauthenticated
09:23:46 <danza> any hint?
09:24:11 <cocreature> danza: add it to extra-deps?
09:24:40 <danza> thanks, i will look for doc about `extra-deps` ... never had to use it until now
09:29:40 <danza> oh well, i guess that i will have to study how Stack works... :P
09:29:57 <danza> i had a problem on Cabal, and i hoped that Stack could automagically fix it
09:30:14 <danza> but looks like now i have a Cabal and Stack problem :D
09:30:23 <cocreature> everything that is not in your snapshot has to be in extra-deps
09:30:58 <danza> i added an `extra-deps: oauthenticated` in stack.yml but `stack init` seems still not to find it
09:32:56 <cocreature> you need to add oauthenticated-exact-version
09:33:00 <danza> maybe i should use `packages` instead
09:33:48 <cocreature> or read the docs :)
09:33:56 <danza> err...
09:34:06 <danza> yup :P
09:37:57 * hackagebot t3-client 0.1.0.1 - tic-tac-toe Rexports for client  https://hackage.haskell.org/package/t3-client-0.1.0.1 (jxv)
09:37:59 * hackagebot t3-client 0.1.0.2 - tic-tac-toe Rexports for client  https://hackage.haskell.org/package/t3-client-0.1.0.2 (jxv)
09:38:53 <danza> but then... maybe i should instead read Cabal's docs ... using `cabal install`, i get rejecting: base-4.8.2. ... 3.0.3.1 (global constraint requires installed instance)
09:39:18 <geekosaur> you can't install a new base, it comes with the compiler
09:39:23 <danza> oh
09:39:31 <geekosaur> cabal does have --allow-newer=base so you can see if it's really broken
09:40:04 <danza> i see.. than i would better read Stack's docs
09:40:16 <danza> i guess that Stack wins for sure if i need a specific compiler/base
09:40:24 <danza> thanks! :)
09:40:47 <geekosaur> ...do I understand that it's looking for base 3.x? stack may not be able to install a ghc that old
09:41:16 <danza> no worries, oauthenticated needs base < 4.8, that's all
09:43:09 <Nimi> is there some place where I can ask specifically about the FFI
09:43:11 <Nimi> ?
09:44:10 <mauke> I don't think so but a few people here have used the FFI
09:44:58 <Nimi> well... the thing is I'm trying to learn about the FFI and have created some ccall to a library
09:45:12 <Nimi> it returns a struct
09:45:18 <mauke> can't do that
09:45:28 <Nimi> wh=
09:45:30 <Nimi> ?
09:45:31 <mauke> the FFI doesn't do struct values, only pointers
09:45:53 <Nimi> well yeah I wrote a storable insatance for the struct
09:46:14 <Nimi> and the struct contains an array
09:46:37 <Nimi> and a field which indicates its type (eg. CUChar or CInt)
09:46:58 <Nimi> so I have to decide dynamically at runtime which type it has
09:47:05 <mauke> doesn't matter, you still can't return a struct from a function
09:47:11 <mauke> (if you want to FFI import it)
09:47:28 <bartavelle> Nimi, it can always be same same type, except it would be a sum type
09:48:12 <Nimi> mauke: it's a pointer to a struct for which I wrote a storable instance
09:48:28 <Nimi> bartavelle: excuse me? I don't understand
09:48:34 <emmanuel_erc> Nimi: https://wiki.haskell.org/FFI
09:48:53 <emmanuel_erc> Have you taken a look at this page already?
09:49:15 <bartavelle> I don't think nimi has an FFI problem at all :)
09:49:26 <emmanuel_erc> ok
09:49:40 <bartavelle> Nimi, data MyArray = CharArray (V.Vector Word8) | DoubleArray (V.Vector Double) | ...
09:52:58 * hackagebot flow 1.0.6 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.6 (fozworth)
09:54:44 <Nimi> bartavelle: I already tried something similar. I'm not sure if I have done it correctly, but it boils down to the same problem
09:55:01 <Nimi> bartavelle: I do not know the type of the array at compile time
09:55:59 <Nimi> resulting from the fact that I use a C function.
09:56:16 <bartavelle> well in the example I wrote you do know its type, it's "MyArray" ?
09:56:36 <bartavelle> or do you mean there is no tag in the struct that tells you which kind of data is stored in the array ?
09:57:55 <Nimi> well I do something like -> peekArray 'length' ptr
09:58:13 <Nimi> which gives me the array
09:58:29 <Nimi> and 'array' could be of multiple types
09:58:42 <bartavelle> how would you know the type with the C API ?
09:59:02 <Nimi> well there is a field in the struct called type
09:59:07 <Nimi> it's just an int
09:59:23 <Nimi> from which I can deduce its type
09:59:29 <bartavelle> then you need to peek that first and "case tag of"
09:59:44 <Nimi> ya I did that
09:59:54 <Nimi> but I can't coerce 'array' to multiple types
09:59:58 <bartavelle> you don't
10:00:03 <bartavelle> you write a sum type
10:00:22 <Nimi> and how do I insert the array into the sum type?
10:00:26 <bartavelle> data MyArray = ArrayWord8 (V.Vector Word8) | ArrayWord16 (V.Vector Word16)
10:01:14 <bartavelle> then something like
10:01:17 <bartavelle> case tag of
10:01:41 <bartavelle>     4 -> ArrayWord8 . V.fromList <$> peekArray size ptr
10:02:03 <Nimi> ya
10:02:24 <Nimi> hm
10:02:37 <Nimi> hmmmmm
10:02:41 <Nimi> give me a Sec
10:05:04 <{AS}> What version of Haskell has Strict?
10:05:46 <bartavelle> {AS} if you are referring to the pragma, it will be 8 if I am not mistaken
10:05:54 <johnw> lol
10:05:56 <{AS}> bartavelle: Yeah, thanks
10:05:59 <johnw> (wrong window)
10:08:11 <Moggle> Is there a common way to write string-agnostic code?
10:08:19 <Moggle> For example do some libraries do some sort of 
10:08:27 <Nimi> bartvelle: what's that <$> operator. I can't seem to use it
10:08:32 <Moggle> (IsString s) => Yhing -> Thing -> s
10:08:40 <bartavelle> it is fmap, if you are not used to it you can write that :
10:08:50 <Moggle> i imagine to do it properly you'd also require s to be a monoid?
10:09:05 <bartavelle> do;  arrayContent <- peekArray size ptr; return (ArrayWord8 (V.fromList arrayContent))
10:09:14 <Moggle> or is it more common to just split a library into a String, Text, ByteString etc.
10:09:39 <bartavelle> Moggle, there is an IsString typeclass
10:09:46 <bartavelle> but I am not sure it does what you want
10:09:47 <geekosaur> Nimi, <$> is in the Prelude in ghc 7.10; in older versions, import Control.Applicative to get it
10:09:54 <ski> @index <$>
10:09:54 <lambdabot> Data.Functor, Control.Applicative, Prelude
10:10:19 <bartavelle> Nimi, equivalent code would be "fmap (ArrayWord8 . V.fromList) (peekArray size ptr)"
10:10:23 <Nimi> GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help 
10:10:33 <Nimi> hm how come i cant use it 
10:10:42 <bartavelle> yeah you should, what is the error exactly ?
10:10:42 <Moggle> bartavelle: I'm trying to abstract out some IRC bot rolling code I made, essentially I'd like to make functions in the style of parseRoll :: (IsString s) => s -> RandomGen -> Either s s
10:10:48 <Moggle> (not exactly that but similar)
10:11:02 <Moggle> so in the code itself I might have
10:11:11 <Nimi> parse error
10:11:24 <Moggle> Right ("You rolled: " `mconcat` result)
10:11:35 <Moggle> is that a common sort of thing for a library to do?
10:11:36 <bartavelle> Nimi, can you paste your code on http://lpaste.net/new/haskell ?
10:11:41 <Nimi> na i have
10:11:48 <geekosaur> Nimi, show the actual code (and is this in a .hs file or in ghci?)
10:11:48 <Moggle> or am I approaching this the wrong way and should I make a bunch of modules for String/Text/etc.
10:12:11 <Nimi> sry my mistake
10:12:13 <Nimi> it does work
10:12:14 <bartavelle> Moggle, I would only do a module for Text :)
10:12:41 <Moggle> You would call Text the standard then and it would not be normal for others to make other things?
10:12:45 <danza> cocreature, i restarted the project from scratch. Now i have `base-4.7.0.2` in my `extra-deps`, but `stack build` still can't find it. Probably i can't specify base as i specify a common package. Should i use an older lts as the resolver? Any hint for finding which version of lts has a base < 4.8?
10:13:00 * hackagebot t3-server 0.1.1 - tic-tac-toe server  https://hackage.haskell.org/package/t3-server-0.1.1 (jxv)
10:13:27 <bartavelle> Moggle, I would expect so. IRC is text-based, so it makes sense to have a Text interface
10:13:36 <Moggle> bartavelle: I'm just not familiar with the Haskell ecosystem here, its a bit confusing because i've been using Strings for everything but apparently I shouldn't?
10:14:15 <bartavelle> Moggle, if you are happy with them just use String. They are generally not as efficient, and the text package has more handy functions
10:14:20 <geekosaur> danza, yes you need to use the appropriate resolver. An LTS release specifies a compiler version, and the base available will be determined by that compiler version
10:14:53 <danza> thanks
10:15:26 <danza> any hint about going from base version -> ghc version -> lts version numbers?
10:15:35 <Moggle> bartavelle: I'm approaching this from the idea of making it a library I can put on hackage or something, I'm interested mainly in what's common now/what would be wanted in libraries dealing with strings/text. Text-only is the standard?
10:15:48 <bartavelle> Moggle, yes
10:16:24 <Moggle> Alright, thank you, I'll go for that then
10:16:31 <Moggle> ... uh, is lazy or strict text
10:16:33 <Moggle> the standard
10:16:37 <Moggle> or can I support both easily
10:16:41 <Moggle> I recall having issues
10:16:42 <Moggle> with that.
10:16:47 <bartavelle> Moggle, XMPP for example https://hackage.haskell.org/package/pontarius-xmpp-0.5.0/docs/Network-Xmpp-IM.html
10:17:03 <bartavelle> I think everybody uses strict text unless there is a specific need
10:18:00 * hackagebot bibdb 0.3.0 - A database based bibliography manager for BibTeX  https://hackage.haskell.org/package/bibdb-0.3.0 (cacay)
10:18:05 <bartavelle> Moggle, however you might notice there are tons of IRC bot libraries on hackage :)
10:18:05 <Moggle> alright, thanks again 
10:18:10 <Moggle> though I am curious if it would be mostly painless
10:18:18 <Moggle> to do an (IsString s) thing everywhere
10:18:42 <geekosaur> the problem with IsString is that it only has one operation. fromString :: IsString s => String -> s
10:18:44 <bartavelle> Moggle, I don't think it would be too useful, it is widely accepted that textual data should be represented as Text
10:18:59 <Moggle> alright, thanks again
10:19:15 <geekosaur> you can't use it to be polymorphic except by doing everything as String and then using fromString to promote to the desired string-like type
10:19:20 <bartavelle> there is also the "Textual" typeclass that is a bit more flexible
10:19:35 <Moggle> but that's probably not very common?
10:19:35 <bartavelle> but I don't think it would be too useful
10:19:39 <bartavelle> no it's not
10:20:22 <geekosaur> afaik the mono-traversable package is the one normally used to get string polymorphism. it comes at a cost since if things fuse, well and good, but if they don't then you pay a heavy performance penalty
10:20:53 <geekosaur> (due to constant conversions between String and the string-like type)
10:26:11 <danza> geekosaur, i managed to install oauthenticated using lts-2.22! thanks for the help :)
10:26:28 <danza> also, Stack is pretty awesome :)
10:28:06 <ggVGc> fairly hilarious, https://github.com/search?q=This+should+never+happen&type=Code
10:29:07 * ski . o O ( <https://github.com/search?q=The+impossible+happened&type=Code> )
10:30:19 <danza> ggVGc, oh well, a code version of "asking for forgiveness is easier than permission" :)
10:31:10 <danza> that code is hopefully not about robotics :D
10:31:54 <ski> @quote impossible.just
10:31:54 <lambdabot> autrijus says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
10:32:27 <ski> @where impossible
10:32:27 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
10:33:00 * hackagebot constrained-categories 0.2.5.1 - Constrained clones of the category-theory type classes, using ConstraintKinds.  https://hackage.haskell.org/package/constrained-categories-0.2.5.1 (leftaroundabout)
10:41:41 <thumbthumb> hi! 
10:42:27 <dmj> hi
10:42:30 * ski nods to thumbthumb
10:42:52 <Cale> hello there
10:43:59 <moar> hello
10:46:41 <moar> Can someone help me with a code ?
10:47:22 <dmj> moar: paste teh code
10:47:25 <dmj> @where paste
10:47:25 <lambdabot> Haskell pastebin: http://lpaste.net/
10:47:42 <moar> http://lpaste.net/157879
10:47:44 <moar> there it is 
10:47:54 <moar> I wrote a description of the problem there
10:49:53 <liste> moar: the association is wrong
10:50:18 <liste> (Bt (node*2) double(left) double(right)) = (Bt (node*2) double left double right)
10:50:32 <dmj> also haskell doesn't need to terminate lines w/ semi colons
10:50:47 <cocreature> except for ghc :)
10:51:14 <moar> so how can i fix this :D ?
10:51:43 <moar> the input isn't multiplied by 2 
10:52:37 <dmj> @def data Tr = Nil' | Bt Int Tr Tr 
10:52:38 <lambdabot>  Defined.
10:53:03 <dmj> @def double (Bt n l r) = double $ Bt (n*2) (double l) (double r)
10:53:05 <lambdabot>  .L.hs:163:21:
10:53:05 <lambdabot>      Ambiguous occurrence ‘double’
10:53:05 <lambdabot>      It could refer to either ‘L.double’, defined at .L.hs:163:1
10:53:14 <dmj> @def double' (Bt n l r) = double' $ Bt (n*2) (double' l) (double' r)
10:53:15 <lambdabot>  Defined.
10:53:29 <dmj> > double' $ Bt 1 Nil' Nil'
10:53:31 <lambdabot>      No instance for (Show Tr)
10:53:31 <lambdabot>        arising from a use of ‘show_M103528152288218883921052’
10:53:31 <lambdabot>      In the expression:
10:53:40 <dmj> @def data Tr = Nil' | Bt Int Tr Tr deriving Show
10:53:41 <lambdabot>  .L.hs:160:1:
10:53:41 <lambdabot>      Multiple declarations of ‘Tr’
10:53:41 <lambdabot>      Declared at: .L.hs:157:1
10:53:52 <dmj> @def data Tr' = Nil'' | Bt' Int Tr' Tr' deriving Show
10:53:53 <lambdabot>  Defined.
10:54:12 <dmj> @def double'' (Bt' n l r) = double'' $ Bt' (n*2) (double'' l) (double'' r)
10:54:14 <lambdabot>  Defined.
10:54:22 <moar> ok i'll give that a try
10:54:23 <dmj> > double'' $ Bt' 1 Nil'' Nil''
10:54:31 <lambdabot>  mueval-core: Time limit exceeded
10:54:31 <lambdabot>  mueval: ExitFailure 1
10:54:42 <dmj> oh, I forgot the base case 
10:55:05 <dmj> moar: http://lpaste.net/157880
10:58:29 <moar> dmj : ok so my problem was only the brackets ?
10:58:31 <aristid> does anyone know if there's a base-compat module with Proxy or something alike?
10:59:06 <dmj> moar: yes, and the semicolon
10:59:47 <dmj> well, the semi colon didn't matter actually
10:59:59 <moar> dmj : Ok but why did the bracket matter if it was surrounding the tree structure?
11:00:17 <moar> dmj: I am still new to Haskell so I don't really understand how things work yet :D 
11:00:32 <dmj> moar: that's ok, you're doing great
11:01:09 <moar> dmj: Anyway , thank you very much :) 
11:01:16 <aristid> ah, it's in tagged
11:03:14 * hackagebot exact-real 0.12.1 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.12.1 (jophish)
11:03:48 <dmj> moar: to answer your previous question, ghci was confused since it though Bt was being applied to 5 arguments
11:04:21 <dmj> Bt (node*2) double (left) double (right) 
11:04:23 <dmj> vs
11:04:31 <dmj> Bt (node*2) (double left) (double right)
11:05:16 <moar> dmj: Oh okay that makes sense 
11:05:55 <moar> dmj: Thanks again ;)
11:06:44 <samba1_> Is there a guide for using ghc-mod with stack and have the binary available for ghc-mod vim? Everything I find is old. Different projects might have different ghc versions, so how can I make the right binary available?
11:07:04 <samba1_> This is what comes up https://www.reddit.com/r/haskell/comments/3cf5yd/stack_ghcmod_work_in_progress/
11:07:43 <mgsloan> samba1_: Yeah, I haven't quite gotten my ghc-mod + stack stuff dialed, myself
11:08:08 <mgsloan> However, something that does help a lot is to just do "stack build ghc-mod", within the project you want to use it with
11:08:14 * hackagebot irc-dcc 1.1.0 - A DCC message parsing and helper library for IRC clients  https://hackage.haskell.org/package/irc-dcc-1.1.0 (JanGerlinger)
11:08:39 <mgsloan> then if ghc-mod gets invoked via "stack exec -- ghc-mod", the correct version will get run (the right ghc version).  
11:09:00 <mgsloan> Or you can just do "stack exec emacs", and then subprocesses of emacs will have the correct PATH, to select the right ghc-mod
11:09:23 <mgsloan> Pretty sure ghc-mod needs to be fixed in order for things to "just work"
11:09:32 <mgsloan> It definitely needs to be fixed to have decent error messages...
11:09:47 <maerwald> ghc-mod is often broken in various ways when it comes to editor integration
11:10:15 <maerwald> wrt vim/syntastic also see https://github.com/scrooloose/syntastic/issues/1576
11:10:28 <maerwald> various issues with version numbers and working directory
11:10:41 <samba1_> I see, maybe I can modify ghc-mod-vim to call stack exec -- ghc-mod instead of just ghc-mod
11:11:04 <maerwald> you also have to open files from the base dir of the project in order for ghc-mod to work
11:11:11 <maerwald> which is pretty annoying
11:11:44 <samba1_> maerwald: before stack I was using this vim plugin to help with that - https://github.com/timmytofu/vim-cabal-context
11:11:56 <samba1_> maybe it's useful with stack, too, I don't know
11:13:10 <ggVGc> I'd like to write make a language that's a very minimal subset of haskell, for use as an embedded language. does anyone know of anything like this, or what I could use as building blocks to reimplement as little as possible?
11:13:33 <puregreen> ooh I want this too
11:13:57 <ggVGc> My main concerns are immutability, static typing, type inference. I don't really care about strict or lazy, and I don't care much about optimizations
11:13:58 <Profpatsch> I’ve created a little “command line option” code that uses environment variables.
11:14:00 <Profpatsch> http://lpaste.net/157881
11:14:17 <Profpatsch> But I’m not sure how to make it so that it doesn’t need bang patterns.
11:14:24 <ggVGc> the compiler and the generated code needs to run on the same target, and be as wide as possible
11:14:28 <Profpatsch> On the top level.
11:14:32 <samba1_> my project right now wants a new stack-full docker image, and I don't think I have room on my computer for another, before I can stack build ghc-mod. sigh
11:14:42 <ggVGc> I'm thinkin of using Lua as the runtime
11:15:10 <Profpatsch> It is a bit crude to use error, I know, but it’s the „good enough“ approach.
11:15:15 <ggVGc> but I've bever written a type checked or type inferer before...
11:15:23 <ggVGc> checker*
11:15:30 <ggVGc> are there any other efforts like this currently?
11:15:39 <Profpatsch> Probably my punishment for relying on partial functions.
11:15:45 <ggVGc> I thought I could use purescript as a start, but it's much too large compared to what I envision
11:16:00 <ggVGc> I basically want a Lua with static types and type inference, and immutability by default
11:21:36 <EvanR> ggVGc: is it going to be a lua coffeescript? ;)
11:21:44 <EvanR> thatd be halfway there
11:24:03 <ggVGc> EvanR: no, there's moonscript for that, which is actually great
11:24:10 <ggVGc> probably the best dynamic language I[ve used
11:24:31 <ggVGc> but coffeescript is still just a preprocessor for a dynamic labguage
11:24:35 <ggVGc> and it's itself dynamic
11:28:15 * hackagebot hxt-css 0.1.0.2 - CSS selectors for HXT  https://hackage.haskell.org/package/hxt-css-0.1.0.2 (MariosTitas)
11:33:39 <Blogle> Sorry my irc client was being wonky, I am not sure if my question about stack went through?
11:34:28 <Blogle> Is there a way to have stack build a dll?
11:37:39 <mgsloan> Blogle: Not sure.  It's probably very similar to building a dll via Cabal
11:38:03 <mgsloan> (Stack uses Cabal to do the build - not to be confused with the "cabal-install" commandline tool)
11:39:35 <robertmc_> Can cabal be passed an argument, the path to the .cabal directory to build in?
11:39:50 <Blogle> mgsloan: forgive my ignorance... How do I do it with cabal? I was previously just using a makefile.
11:42:20 <ggVGc> wonder if haskell itself or cabal is more confusing
11:42:25 <ggVGc> to a newbie
11:42:27 <ggVGc> I tink equally
11:42:45 <amf> how can i get the -M RTS flag value from code. GHC.RTS.Flags doesnt seem to have it
11:44:35 <hexagoxel> amf: isn't it maxHeapSize . gcFlags ?
11:45:07 <mgsloan> Blogle: I'm not sure, sorry, I don't use windows much
11:46:06 <mgsloan> I'm not sure, but I think doing something like "--ghc-options -dynamic" orso could do the trick.  Might need other falgs like -shared and -fPIC
11:46:35 <Blogle> mgsloan: no problem, I will continue Google sleuthing for answers
11:47:04 <osa1> Blogle: make sure to read Cabal docs first, it has some --enable-shared etc. flags that may be related
11:47:16 <amf> hexagoxel: its not
11:57:56 <Squarism> Can u declare and define a variable with both type and value in the same statement? Like "let a :: Double = 2.3" doesnt seem to work
11:58:58 <caconym> let a = 2.3 :: Double
11:59:00 <Cale> You can write  a = 2.3 :: Double, but that doesn't quite mean the same thing
11:59:35 <lyxia> let a :: Double ; a = 2.3
12:00:12 <lyxia> Squarism: you can write what you wrote with ScopedTypeVariables
12:00:13 <drdo> Cale: What's the difference?
12:01:10 <Cale> If you write  a = 2.3 :: Fractional a => a   for example, and you have the monomorphism restriction enabled (which is the default), the binding for a still doesn't count as having a type signature, and so the MR still applies, and you're likely to end up with a :: Double by defaulting
12:01:43 <Cale> You've really only given a type signature to the expression on the right hand side of the equation, and not really declared a's type.
12:02:25 <drdo> Cale: ah yes, of course
12:02:44 <drdo> But if you do that with a monomorphic type I don't see how it could differ
12:03:01 <Cale> Yeah if the type is monomorphic, it'll be okay
12:03:08 <ggVGc> Cale: intersting, didn't even know that was valid syntax
12:03:31 <Cale> ggVGc: Yeah, you can apply a type annotation to any expression
12:04:52 <ertes> haskell-(interactive-)mode question: i'd like to bind the ":main" interactive command for the current session to a key…  is that possible?
12:05:32 <ertes> deluxe variant: i'd like to `bring` the current session, send ":main", wait for it to finish, then get rid of the session window again
12:05:51 <Cale> `bring`?
12:06:08 <ertes> Cale: haskell-interactive-bring
12:06:24 <Cale> oh, some emacs thing, okay
12:07:15 <Cale> I'm sure it's possible, but I have no idea how to do it :)
12:07:30 <Cale> johnw might have an idea though ;)
12:07:50 <ertes> i'd love to use yi, but haskell-mode is about the most awesome language mode i've seen so far =)
12:08:10 <ggVGc> Cale: sorry, that was meant for caconym. I meant his use of semicolon
12:08:21 <ggVGc> I've never written a semicolon in haskell
12:08:33 <ggVGc> and I didn't know you could have a let binding with a later assignment
12:08:56 <Cale> ertes: I technically use vim, but I might as well use gedit for all I get out of it :P
12:09:16 <Cale> ggVGc: ah, yeah
12:09:21 <caconym> the semicolon wasn't me!
12:09:35 <caconym> i've never written one in Haskell either iirc
12:09:36 <ertes> Cale: used to be the same for me with emacs…  haskell-mode in its vanilla form is pretty much like any other language mode
12:09:48 <hexagoxel> amf: heapSizeSuggestion seems to be some constant factor (256 ?) of
12:10:22 <Cale> ggVGc: You can use semicolons or braces and semicolons, anywhere that you'd otherwise use vertical alignment to determine where blocks begin and end
12:11:03 <ertes> Cale: but i discovered haskell-interactive-mode about a year ago, and i don't think i can write code without anymore =)
12:12:57 <ertes> semicolons are mostly a GHCi thing for me, and heavily used there
12:14:10 <ertes> IMO it should be called semicola: not quite the real cola, like cola without identity
12:27:15 <kim0> I'm trying to work on NICTA course .. is it possible to use "stack" command to work through the course .. or should I leave stack behind and install cabal ?
12:27:46 <jle`> stack works fine :)
12:27:59 <jle`> just do stack ghci, stack runghc, stack install, etc.
12:28:08 <orion> NICTA? You mean the National Insurance Crime Training Academy?
12:28:27 <kim0> jle`: how do I run tests .. add my code .. run tests again ... rinse & repeat :)
12:28:32 <kim0> I'm still lost 
12:28:53 <jle`> ah, i've never used nicta.  but how would you run the tests normally with cabal?
12:29:02 <kim0> cabal test they say
12:29:11 <jle`> should 'stack test' still work?
12:30:23 <kim0> I did "stack init" .. it generated a template stack.yaml
12:30:30 <kim0> trying "stack test"
12:30:32 <kim0> Warning: module not listed in course.cabal for 'doctests' component (add to other-modules): Build_doctests
12:38:50 <johnw> Cale: sure, writing some Elisp would probably make that possible
12:50:18 <ertes> Cale, johnw: i've done the first part of it: http://lpaste.net/157885
12:51:27 <ertes> haskell-interactive-mode-do-expr's assumption that the interactive buffer is current is pretty nasty, but it works
12:52:21 <ertes> johnw: do you see an easy way to get the "deluxe" variant i mentioned above?  bring the interactive buffer, run :main until it completes, then delete-window the buffer again?
12:52:56 <ertes> i don't mind writing it myself, but i could use a pointer into the right direction on how to do it =)
12:58:17 * hackagebot werewolf 0.4.11.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.4.11.0 (hjwylde)
12:59:34 <Shou> Is there an opposite to (<|>), i.e. (f >|< empty) == (empty >|< f) == empty?
13:00:11 <puregreen> Shou: what should f >|< g do?
13:00:26 <puregreen> you could use *> or <* maybe
13:01:17 <ertes> Shou: Alternative gives you monoids…  sounds like you need semirings with annihilators, but there is nothing predefined
13:01:42 <jle`> i guess mzero is meant to be a zero over the semiring formed by mplus and >>
13:01:59 <jle`> so *>/<* might work
13:02:22 <jle`> > Just 10 *> Nothing
13:02:24 <lambdabot>  Nothing
13:02:49 <Gurkenglas> :t (liftA2 (,), liftA2 (<>)) -- One of these?
13:02:50 <lambdabot> (Applicative f, Applicative f1, Monoid c) => (f a -> f b -> f (a, b), f1 c -> f1 c -> f1 c)
13:02:59 <jle`> the MonadPlus laws state that mzero >> f = mzero, but `f >> mzero` isn't a law
13:03:16 <jle`> it's true for specific instances, though
13:03:32 <jle`> er, f >> mzero = mzero isn't a MonadPlus law, but mzero >> f = mzero is
13:04:18 <jle`> so that might kind of do what you want
13:04:57 <simony> :t (*>)
13:04:58 <lambdabot> Applicative f => f a -> f b -> f b
13:05:16 <simony> :t (>>)
13:05:17 <lambdabot> Monad m => m a -> m b -> m b
13:05:22 <jle`> curiously enough the Alternative laws don't specify anything about `empty *> f`
13:05:26 <jle`> although they definitely could
13:05:41 <jle`> `empty *> f = empty` would be a reasonable Alternative law, I think
13:06:27 <shachaf> There are no laws relating Alternative and Applicative.
13:06:30 <ertes> yeah, Alternative seems rather separate from Applicative
13:06:43 <jle`> there aren't any laws, but i feel like that would be a reasonable one
13:06:57 <jle`> hm
13:06:59 <jle`> oh, it's not
13:07:13 <jle`> er, yeah, i feel like it should be.  it's satisfied for all of the instances in base, at least
13:07:20 <jle`> > [] *> [1,2,3]
13:07:22 <lambdabot>  []
13:07:54 <ertes> jle`: alone that law seems rather arbitrary…  if anything it should be tied to another law like distributivity
13:08:03 <ertes> but not all Alternative instances are distributive
13:09:10 <jle`> fair enough
13:10:27 <jle`> well, in that case, mzero and >> might be the *closest* to what Shou is asking about, but it's likely that they might get a more meaningful answer if they ask about specific types they are trying to use
13:11:42 <ertes> it seems like they want (<|>) semantics with annihilators though, and nothing is predefined in that regard
13:11:56 <Shou> I'm doing it for Maybe so (>>), (<<), (*>), and (<*) all work for that, thanks for the help.
13:12:02 <jle`> np!
13:12:13 <jle`> yeah, for questions like this, asking about specific types usually gets you a more useful answer :)
13:12:23 <shachaf> Well, if Applicative/Alternative behaves like a ring or something, it probably makes more sense for (<*>).
13:12:28 <shachaf> But of course it doesn't really.
13:13:22 <ertes> semiring, if anything…  i'm not aware of any Alternative instance that is a commutative group
13:13:45 <dolio> jle`: You can't sensibly have that law for Applicative/Alternative, because for every Applicative, there's an Applicative where (<*>) = (<**>).
13:13:45 <shachaf> Yes, semiring.
13:13:55 <ertes> well…  data Unit a = Unit
13:14:07 <jle`> dolio: good point
13:14:19 <dolio> And if (empty <*> f) = empty in the original one, then (f <*> empty) = empty in the opposite one.
13:14:53 <jle`> i think you mean to say that (empty <*> f) is only empty in the second one if f is empty
13:15:22 <jle`> because the law would still hold (f <*> empty) = empty in the second one
13:15:30 <jle`> s/hold/hold if
13:15:32 <dolio> I mean if the original satisfies one law only, the opposite one satisfies the opposite law.
13:15:44 <jle`> ah, yeah
13:16:02 <Gurkenglas> In fact, if I'm not mistaken about the laws, every function of type "Applicative f => f a -> f a -> f a" should have empty as a multiplicative zero (if Alternative, and thus empty, is defined)
13:17:21 <jle`> Gurkenglas: const id ?
13:17:32 <ggVGc> idles in #haskell, hears mentiones of semirings and annihilators, has no idea what this related to, ends up here at 4am.. https://en.wikipedia.org/wiki/Module_(mathematics)
13:17:33 <Gurkenglas> Oh wait that was wrong on multiple levels. You need to execute both effects (which does happen using const or const id), and if a must be that general there are only those two functions of that type and two more ._.
13:17:49 <jle`> > const id Nothing (Just 10)
13:17:51 <lambdabot>  Just 10
13:17:58 <Gurkenglas> And, I guess, those that execute the effects in other orders or even multiple times. Huh.
13:18:05 <jle`> you don't even need to sequence any effects
13:18:12 <Gurkenglas> *which does not happen
13:18:31 <ggVGc> ertes: what education background do you have?
13:20:45 <ertes> ggVGc: formally i have a pretty low degree in germany…  it's mostly self-education in my case
13:21:04 <ertes> why?
13:21:50 <ggVGc> ertes: was just curious. I don't know how I'd end yp learning about rings and annihilators
13:22:39 <ertes> ggVGc: interest in cryptography got me there, and i'm also generally interested in algebra, so i learn a lot just for fun
13:22:56 <ggVGc> ertes: have any good book to recommend?
13:23:21 <ertes> about what?
13:23:39 <ggVGc> abstract algebra
13:24:57 <Gurkenglas> (Okay, let me try again: "The functions Shou is looking for are exactly those in the image of liftA2.")
13:25:22 <Cale> ggVGc: Dummit and Foote
13:25:32 <ertes> ggVGc: good question…  a german book called "mathematik für informatiker" (ISBN 3-8273-7109-0) gave me the basics, and everything else i picked up here and there online
13:26:00 <ggVGc> my german is at the level of a 6-yearold unfortunately :(
13:26:06 <ggVGc> Cale: thanks, will check it
13:26:12 <ggVGc> wonder if I can find a kindle version
13:26:18 <nomotif> ggVGc: What is your background and goal, do you have any formal training in Mathematics?  Are you specifically interested in the cryptography applications?
13:26:25 <Cale> Michael Artin's book is also good.
13:26:28 <ggVGc> a lot of books I'd like to read in math don'e seem to be available on amazon
13:26:48 <Asuran> ggVGc, if needed i can help you translate
13:28:14 <ggVGc> nomotif: no, I just want to learn more math, mainly in the interest of studying physics and probably doing some computer science research in the coming years
13:28:24 <jle`> i really enjoyed Pinter
13:28:32 <jle`> it's more of a story/journey than a traditional textbook
13:28:36 <ggVGc> I have a few months of physics and calculus in uni, but I had to drop out of that, a few years ago
13:29:19 <ertes> ggVGc: sorry…  i've got used to learning bits and pieces from many different sources, but learning basic group theory will be useful almost everywhere, from haskell over physics to cryptography
13:29:57 <ggVGc> yeah, same, but I feel I want to go through some good books to get some more serious fundamentals
13:30:37 <cpa> guys, what's the semantic difference between FreeT on top of State and StateT on top of Free? I can make sense of the latter but not of the former.
13:36:13 <ertes> cpa: the former allows you to build the expression statefully
13:36:32 <ertes> in other words: you can use state effects *between* each layer of the functor
13:37:26 <ertes> cpa: StateT s (Free f) a ≃ s -> Free f (a, s) ≃ s -> Either (f (Free f (a, s))) (a, s)  -- that one does not…  once you have decided on an expression, that one will be stateless
13:38:59 <cpa> ertes: thanks, I'll need a few minutes :)
13:40:25 <ertes> cpa: do you see how FreeT ((,) Int) M () is an M-effectful list?  basically a list producer
13:40:30 <nomotif> ertes: I've been digging through my collection, I can't find anything that would be appropriate for a straight shot self guided from Calculus -> Non-Commutative Ring Theory (And Modules) -> Annihalators.  Are you comfortable with proofs?
13:40:48 <ertes> nomotif: yeah
13:41:15 <ertes> nomotif: but you probably meant to address that at ggVGc =)
13:41:23 <ertes> s/at/to/
13:41:27 <nomotif> ertes: Woopsy daisy.
13:41:31 <cpa> ertes: indeed
13:41:41 <nomotif> ggVGc: I've been digging through my collection, I can't find anything that would be appropriate for a straight shot self guided from Calculus -> Non-Commutative Ring Theory (And Modules) -> Annihalators.  Are you comfortable with proofs?
13:42:01 <ertes> cpa: you can have M-effects *between* list elements with that one
13:42:10 <ggVGc> nomotif: somewhat, but I'm going through my calculus book again now to get into it again
13:42:11 <ertes> now let M be a state monad
13:42:31 <nomotif> ggVGc:  How's your number theory?
13:42:34 <ertes> cpa: does that help?
13:43:00 <ggVGc> nomotif: all my math is pretty weak atm. I'm just trying to build a small list of books that I will go through the coming year
13:43:10 <ggVGc> so I wouldn't start on abstract algebra books right now
13:43:14 <ggVGc> but in a few months maybe
13:43:28 <cpa> ertes: I think so, thanks!
13:43:31 * hackagebot rei 0.3.5 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.5 (kerkomen)
13:43:40 <nomotif> ggVGc: Ohhh.
13:43:44 <ggVGc> it's been years since I did any serious math, and my education only goes up to basic calculus so far
13:43:47 <nomotif> ggVGc: That makes a lot more sense.
13:44:23 <ggVGc> nomotif: I'm basically preparing for getting into physics and/or computer science research in 1-2 years when I'll be moving to a palce with a good uni again
13:44:41 <ertes> cpa: if you would like an interesting exercise, write a list of random numbers:  freeRandoms :: (Random a, RandomGen g) => FreeT ((,) a) (State g) r
13:45:01 <ertes> cpa: it makes perfect sense once you see how the types line up…  let the types guide you =)
13:45:27 <cpa> ertes: I'll try this, thanks!
13:53:31 * hackagebot rei 0.3.5.1 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.5.1 (kerkomen)
13:56:39 <tcnewb> besides "all about monads" and "typeclassopedia" , what else should I be reading?
14:02:56 <tcnewb> Thtatic Compilathionth <-- is this available anywhere?
14:08:22 <XoitX> Hello
14:08:36 <XoitX> What is meant by propositions?
14:08:55 <Rembane> XoitX: Do you have a context they show up in?
14:09:11 <XoitX> Propositions as types
14:09:23 <XoitX> I'm trying to understand that statement
14:09:40 <EvanR> statements to be proved, or disproved, or shrugged at
14:10:29 <XoitX> How does that translate to proofs as programs if the programs are built on types
14:10:35 <jle`> things like "if P implies Q, and P is true, then Q is true"
14:10:54 <jle`> translates to the type (p -> q, p) -> q
14:11:10 <jle`> the proposition is true if there that type has an inhabitant
14:11:21 <jle`> in this case, it does --- foo (f, x) = f x
14:12:27 <XoitX> what is p and q exactly?
14:12:31 <jle`> statements
14:12:32 <XoitX> a set of statements?
14:12:41 <EvanR> p and q are also propositions
14:12:43 <XoitX> a single statement
14:12:46 <jle`> ah, yeah
14:12:47 <XoitX> a value?
14:12:56 <jle`> do you mean in the type signature?
14:12:58 <jle`> they're type variables
14:13:10 <jle`> :t \(f, x) -> f x
14:13:12 <lambdabot> (t -> r, t) -> r
14:13:17 <XoitX> how is character different form an integer?
14:13:27 <XoitX> Regarding the computer I mean
14:13:42 <maerwald> wat?
14:13:55 <EvanR> what manner of homework...
14:15:34 <XoitX> In c++ I remember using characters as numbers cause that's how they are stored
14:15:50 <EvanR> Char and Integer are two different abstract data types
14:15:56 <EvanR> so you dont get to know the representation
14:16:19 <maerwald> haskell is not a weakly typed language, so the question does barely make sense
14:16:31 <EvanR> whats important is the operations Char and Integer support
14:16:56 <EvanR> > succ 'A'
14:16:57 <lambdabot>  'B'
14:17:04 <EvanR> > succ 10
14:17:05 <lambdabot>  11
14:17:35 <XoitX> so wouldn't one type only be able to interact with it's own type only?
14:17:48 <EvanR> perhaps not even, it depends on the operations
14:17:50 <Zekka|Sigfig> You can define operations that interact with both types if you want
14:17:53 <jle`> what do you mean 'interact' ?
14:17:54 <Zekka|Sigfig> :t ord
14:17:54 <XoitX> it seems at some point the abstractions break down
14:17:55 <lambdabot> Char -> Int
14:18:11 <EvanR> it would be nice if they didn't break down
14:18:17 <Zekka|Sigfig> @let difference c1 c2 = ord c1 - ord c2
14:18:18 <jle`> `'c' + 10` isn't allowed, if that's what you mean
14:18:18 <lambdabot>  Defined.
14:18:30 <jle`> but some functions can take both Char's and Integer's as inputs
14:18:37 <Zekka|Sigfig> > difference ‘z’ ‘a’
14:18:39 <lambdabot>  <hint>:1:12: lexical error at character '\8216'
14:18:45 <jle`> @let charAndInt c i = repeat i c
14:18:46 <lambdabot>  .L.hs:169:18:
14:18:46 <lambdabot>      Couldn't match expected type ‘t1 -> t’ with actual type ‘[a]’
14:18:46 <lambdabot>      Relevant bindings include
14:18:46 <Zekka|Sigfig> oh smart quotes
14:18:49 <jle`> > charAndInt 'c' 10
14:18:50 <lambdabot>  Not in scope: ‘charAndInt’
14:18:52 <maerwald> XoitX: you should stop thinking in terms of C or C++... it will just make it harder to learn haskell
14:18:59 * EvanR gets washed away by the flood of errors
14:19:21 <jle`> @let charAndInt c i = replicate i c
14:19:22 <lambdabot>  Defined.
14:19:25 <maerwald> don't try to find similarities
14:19:26 <jle`> > charAndInt 'c' 10
14:19:27 <lambdabot>  "cccccccccc"
14:19:49 <EvanR> especially C++, there basically nothing in common with Haskell
14:19:50 <jle`> but yeah, Char and Integer don't have anything in similar except for the fact that they're both types
14:19:58 <jle`> like Bool, Lists, Strings, etc.
14:20:29 <maerwald> and we don't do type casting and hope the stuff you just casted to still makes sense on value level
14:20:51 * fr33domlover recommends the Haskell wikibook, read at least all the intro chapters... will quickly remove all such confusion
14:20:57 <maerwald> type casting is an undefined operation, basically
14:21:16 <XoitX> I guess I need to learn the basics
14:21:25 <fr33domlover> I came from C++ too and instantly fell in love with Haskell
14:21:31 <XoitX> I'm trying a logical approach so far
14:21:41 <jle`> yeah, there's almost nothing from C++ you can learn that will be useful in Haskell
14:21:52 <jle`> except for the fact that you probably used a text editor when you write C++
14:21:57 <XoitX> but it seems I need a strong abstract basis
14:21:58 <jle`> and you can use text editors to write haskell, too :)
14:21:59 <maerwald> C++ templates maybe, but only a bit
14:22:07 <XoitX> but it seems I need a strong abstract basis
14:22:08 <jle`> XoitX: you don't need a strong abstract basis
14:22:08 <XoitX> it seems to have it's own logic
14:22:11 <EvanR> XoitX: i think youll learn this along the way
14:22:14 <jle`> a strong concrete basis is fine, too :)
14:22:38 <EvanR> C++ has its own lore that youre expected to learn
14:22:41 <jle`> most people learn haskell in a concrete, non-abstract way
14:22:45 <fr33domlover> XoitX, Haskell books and tutorials are enough, no need for extra math basics or anything
14:22:47 <EvanR> So time to do the Haskell lore
14:22:49 <jle`> learning haskell abstractly is a road to failure
14:23:00 <maerwald> I think that goes for any language
14:23:03 <fr33domlover> except some tutorials assume knowledge of functional programming
14:23:04 <maerwald> including non-programming ones
14:23:07 <johnw> jle`: like, "Haskell is a thing to do stuff"?
14:23:22 <jle`> hah
14:23:25 <EvanR> haha... thats vagueness not abstraction?
14:23:41 <johnw> i can mean lots by "thing" and "stuff" :)
14:23:50 <jle`> XoitX: but yeah, don't go looking for an "abstract basis" when learning haskell
14:23:52 <jle`> XoitX: just learn haskell
14:23:57 <jle`> concretely
14:23:58 <fr33domlover> Haskell :: Language
14:24:08 <johnw> in fact, some of the best Haskell is just picking the right data types and the right functions to go with them
14:24:19 <XoitX> the statement proofs as programs , simplification as evaluation ... just blows my mind away!! Or am I getting it wrong
14:24:32 <jle`> it is definitely crazy :)
14:24:35 <EvanR> your head will be exploding for a while
14:24:41 <maerwald> johnw: I sometimes spend weeks thinking about the right data structure before I even start any programming :P
14:24:49 <jle`> but that's not really a part of using haskell/learning haskell, for the most part
14:24:53 <Zekka|Sigfig> XoitX: Don’t let your mind get too blown! It’s just another programming language
14:25:15 <maerwald> and then I still pick the wrong one... luckily, refactoring is easy in haskell
14:25:21 <jle`> XoitX: that'd be like watching stunt drivers do crazy tricks when driving a car, and think that driving cars is about doing crazy tricks and jumps and drifting
14:25:28 <XoitX> What amazes me is that ... well.. it's the functioning of truth.. WHAT!!
14:25:29 <ertes> XoitX: you will come back to that one at least once in your haskell history…  everybody does…  but that's mostly peer pressure =)
14:25:31 <dmj> maerwald: sometimes I think so much that I never end up programming
14:25:34 <jle`> XoitX: it's not ... for the most part, you're just driving back and forth
14:25:40 <jle`> from work or school
14:25:50 <jle`> but watching stunt drivers can blow my mind
14:25:50 <EvanR> XoitX: well youll learn a different kind of truth
14:25:57 <EvanR> thats not just Bool = True | False
14:26:09 <ertes> the only absolute truth is ()
14:26:17 <XoitX> how can truth be abstract?
14:26:18 <jle`> () is unity
14:26:20 <ertes> (up to isomorphism)
14:26:22 <XoitX> ouch .. my head
14:26:31 <jle`> become one with ()
14:26:36 <Zekka|Sigfig> Remember that in actual programming imho your proofs are going to be uninteresting and you will probably need to think about whether your program does things in the right order!
14:26:36 <jle`> (i'm probably not helping :) )
14:26:59 <Zekka|Sigfig> (this is not always true, but it  was probably true in the other languages you worked in and it’s still frequently true in Haskell)
14:27:04 <EvanR> XoitX: you already saw one way, the proposition about p -> q and p implying q, true by virtue of being able to write the proof
14:27:18 <johnw> also, proofs often have the property that any proof of X is as good as another, whereas programs definitely don't have this (one function Int -> Int is *not* as good as any other)
14:27:51 <EvanR> is Int really a proposition ;)
14:27:55 <johnw> why not
14:28:01 <johnw> Int proposes that numbers exist
14:28:09 <jle`> it can be thought of as an axiom
14:28:10 <EvanR> ehr...
14:28:15 <ertes> XoitX: ultimately practical haskell is software engineering, just the tools are different…  for example where most people use OOP we use algebra
14:28:22 <johnw> there just happen to be tons of proofs of it, and they are relevant in a computational context
14:28:23 <Zekka|Sigfig> it’s tempting to say a lot of interesting math things about haskell but it’s basically Java with laziness by default, a more efficient representation for union types and a much more powerful type system
14:28:48 <danza___> Zekka|Sigfig, ugh ...
14:28:48 <jle`> basically java except for everything about java
14:28:54 <EvanR> i feel like thats going back to the "container" fallacy
14:29:05 <johnw> Zekka|Sigfig: Um, no JVM, no arbitrary runtime reflection by default, no emphasis on everything being an object, ....
14:29:12 <EvanR> the program `ls' is a container that when opened spews forth directory listings
14:29:14 <johnw> I would never start a sentence about Haskell with "it's basically Java"
14:29:20 <danza___> :D
14:29:37 <EvanR> i.e. a trick of language rather than a good explanation
14:29:39 <jle`> haskell has almost nothing in common with java, heh
14:29:47 <danza___> Zekka|Sigfig, what about object oriented programming encouraging local state everywhere?
14:29:54 <maerwald> dmj: I sometimes like to think... if I can't come up with a satisfying way to tackle a problem, I'd rather not try programming a solution... until some later day maybe
14:30:03 <Zekka|Sigfig> johnw: I’m not trying to say Java is absolute or anything, I’m saying that it doesn’t radically change how you can architect your program, and a lot of Haskell features have pretty compact representations in terms of lower-level abstractions
14:30:06 <monochrom> people go out of their ways to oversimplify reality
14:30:07 <maerwald> but that's not how industry works :P
14:30:29 <Zekka|Sigfig> danza___: I throw that in with differences in the type system, but maybe it’s not fair for me to do that.
14:30:48 <dmj> maerwald: once you get the type system in your head, you can do most of your haskell programming there (in your head).
14:30:53 <maerwald> Zekka|Sigfig: wut? java is pretty radical in the way it forces OOP on you
14:31:17 <ertes> "it's really a teddybaer, except that it's large, hard, needs electricity, and you can build a house with it"
14:31:23 <danza___> :D
14:31:34 <EvanR> ^ another container-like rhetoric
14:31:39 <jle`> EvanR: "All humans are mortal.  Aristotle is a human.  Therefore, Aristotle is mortal" can be translated as (Human -> Mortal) -> Mortal, where you pass in Aristotle as your Human
14:32:04 <jle`> EvanR: "Aristotle is a human" is considered an axiom, like Human as a type
14:32:06 <Zekka|Sigfig> maerwald: You can write lazy, non side-effectful code in it pretty easily and you don’t have to do much to the structure of your whole program
14:32:21 <Zekka|Sigfig> You probably wouldn’t want to, but it’s not like you couldn’t make a computer do it for you
14:32:24 <EvanR> jle`: huh... what is Mortal
14:32:25 <maerwald> dmj: not sure I can follow... programming always happens in my head :o
14:32:47 <ertes> jle`: (∀ x. Human x -> Mortal x) -> Human Aristotle -> Mortal Aristotle
14:32:56 <EvanR> shouldnt Mortal be a dependent type...
14:33:01 <monochrom> jle`: wait a second, I wonder if it should be (Human -> Mortal) -> (Human -> Mortal) and you pass in <proof of human is mortal> and then Aristotle
14:33:13 <XoitX> So haskell just makes abstractions more obvious?
14:33:24 <johnw> XoitX: more explicit
14:33:31 <jle`> okay, maybe a bad example.  But `(Int -> a) -> a` is inhabited
14:33:31 <Zekka|Sigfig> XoitX: It’s a lot easier to write really abstract code in haskell than in most other languages
14:33:33 <ertes> XoitX: haskell makes abstractions very cheap
14:33:35 <johnw> EvanR: what would it depend on?
14:33:37 <jle`> because Int is inhabited
14:33:52 <ertes> XoitX: both in run-time and in code size
14:34:02 <EvanR> johnw: good question
14:34:04 <jle`> so the proposition corresponding to `(Bool -> a) -> a` is true
14:34:07 <EvanR> its used two ways there
14:34:08 <jle`> becuase Bool is an axiom
14:34:14 <EvanR> johnw: oh... Human
14:34:25 <Zekka|Sigfig> you could write the same really abstract code in nearly anything without changing much about its high-level architecture — and without getting much for free from the Haskell environment — but in Haskell a lot of ways of writing abstract code are way shorter
14:34:30 <monochrom> clearly, Mortal depends on Kombat :)
14:34:53 <Rembane> And beautiful typeclasses that make abstractions much easier!
14:35:20 <jle`> `(Human -> a) -> a` is true, because you have an inhabitant of Human to use the implication on
14:35:36 <Zekka|Sigfig> Rembane: Yeah, I think the most radical advantage Haskell actually has over languages like Java is that it can do a lot of code generation for free
14:35:52 <EvanR> jle`: i feel like this proposition leads to some sort of "gotcha" fake paradox
14:35:53 <jle`> `(Int -> a) -> a` is true; foo f = f 10
14:35:54 <EvanR> with a name
14:35:59 <ertes> jle`: yeah, except that it doesn't look anything like your proposition with aristotle =)
14:36:02 <jle`> this is the common interpretation, though
14:36:06 <jle`> ertes: yeah, that was a bad example
14:36:18 <Rembane> Zekka|Sigfig: Yes! import generic stuff and all code is written for you!
14:36:32 <XoitX> man I need to learn types
14:36:34 <XoitX> I must
14:36:35 <XoitX> !!
14:36:57 <XoitX> I'm getting too excited
14:37:02 <ertes> XoitX: you know types, don't you?  IIRC you're coming with a C++ background
14:37:07 <monochrom> to understand types, you just need to understand logic.
14:37:08 <XoitX> yea
14:37:21 <XoitX> but it was never filled witha bunch of arrows
14:37:21 <ertes> XoitX: haskell just gives *everything* a type
14:37:29 <XoitX> and monads
14:37:33 <XoitX> or whatever
14:37:37 <EvanR> dont try to compare types in haskell with types in c++
14:37:43 <EvanR> youll hurt yourself
14:37:51 <XoitX> That's what I'm trying not to do
14:37:57 <ertes> (f :: X -> Y) roughly translates to Y (*f)(X) in C++
14:37:59 <Zekka|Sigfig> The Haskell type system isn’t that different from the type system in lots of other languages with types, but you might not understand why it’s similar until you’ve learned about it
14:38:01 <XoitX> That's what I'm trying not to do
14:38:17 <ertes> but the arrow makes it more obvious that something is going in and coming out =)
14:38:18 <EvanR> ertes: incredibly rough
14:38:20 <jle`> EvanR: or, you can turn Bool into a normal polymorphic function, and then it'll probably make more sense
14:38:29 <monochrom> learn Haskell. it will have the side effect of learning types.
14:38:51 <jle`> EvanR: Bool is the same as an (r, r) -> r
14:38:57 <monochrom> OTOH if you learn SML instead, that also works.
14:38:59 <jle`> EvanR: so that's still a proposition in the original sense we were talking about it :)
14:39:12 <EvanR> jle`: "is the same as"
14:39:30 <EvanR> time to break out the category theory
14:39:31 <jle`> so `(Bool -> a) -> a` can be said to be a shorthand for ((forall r. (r, r) -> r) -> a) -> a
14:39:47 <ertes> the point is that someone coming from python or ruby needs to learn static types from the very beginning, but to someone with a C++ background usually has an understanding of them, except that they act more like a restriction in C++
14:39:52 <XoitX> what is lambda then?
14:40:03 <monochrom> anonymous function
14:40:03 <jle`> and of course, you can pull (forall r. (r, r) -> r)'s out of your pockets
14:40:04 <XoitX> how is it related to incompleteness theorem ?
14:40:38 <monochrom> by providing unlimited recursion
14:40:56 <EvanR> jle`: theyre isomorphic in some way
14:41:26 <ertes> lambda doesn't actually
14:41:31 <monochrom> but IRC is not a good place to carry out a 2-hour lecture and 1-hour Q&A on this subject
14:41:39 <jle`> we can say that when we write `(Bool -> a) -> a`, we really mean ((forall r. (r, r) -> r) -> a) -> a, so i think it's safe to say that Bool is a proposition
14:41:59 <jle`> Bool is really just the proposition (forall r. (r, r) -> r)
14:42:08 <monochrom> ertes: if I'm allowed the untyped lambda calculus, i.e., the original first one, then it has recursion. the Y combinator.
14:42:09 <jle`> which is a tautology anyways
14:42:22 <EvanR> or perhaps Bool "really is" a set of {} and {{}}
14:42:35 <jle`> sure, but we're talking about encoding types as propositions
14:42:53 <EvanR> you mean encoding propositions as types?
14:43:10 <jle`> so Bool is the forall r. (r, r) -> r, is the proposition "If P and P, then P"
14:43:27 <EvanR> there is a mapping between the two
14:43:34 <ertes> XoitX: in the "programs as proofs" concept there are some restrictions as to what programs are actually allowed…  infinitely looping programs are not proofs…  since you can have infinite loops everywhere in haskell, it's not a proper proof assistant, and i would highly recommend to view it as a programming language
14:43:49 <EvanR> but i dont see how theyre "the same" since they seem completely different in substance
14:44:10 <EvanR> False :: Bool, True :: Bool
14:44:15 <EvanR> vs If P and P, then P
14:44:30 <EvanR> for some P
14:44:30 <jle`> (Bool -> r) -> r corresponds to the proposition "If (P and P implies P) implies Q, then Q"
14:44:33 <ertes> XoitX: haskell gives you a playground for very formal stuff, but it's primarily a programming language for writing code that runs on metal
14:45:07 <jle`> just like `(a, b) -> a` corresponds to the proposition "If A and B, then A"
14:45:11 <ertes> and to be honest i strongly recommend approaching it as such
14:45:19 <EvanR> jle`: where a b and a are props
14:45:20 <XoitX> is that the p vs np you're refering to?
14:45:56 <jle`> yeah, and a can be the prop (forall r. (r, r) -> r)
14:46:01 <ertes> the P=NP question is something entirely different
14:46:08 <EvanR> where r is a prop ;)
14:46:21 <Zekka|Sigfig> XoitX: I think he’s hinting at the halting problem — you can’t say “a program that loops forever isn’t a proof” because you can’t check ifa  program in Haskell will loop forever
14:46:29 <jle`> Bool gets directly translated to the proposition "If P and P, then P"
14:46:31 <Zekka|Sigfig> if you took away Haskell’s turing completeness powers maybe you could
14:46:46 <XoitX> So the starting point is always a primitive type
14:46:48 <jle`> jsut like (a, b) -> a translated to the proposition "if A and B, then A"
14:47:02 <jle`> the point is to talk about what types correspond to what propositions :)
14:47:09 <XoitX> then abstractions are built with expressions
14:47:20 <XoitX> then these expressions are types
14:47:25 <EvanR> so you have your mapping but, what law does that mapping satisfy?
14:47:37 <XoitX> these types are used in more expressions as proofs
14:47:39 <jle`> if the type is inhabited, then the proposition is true
14:47:46 <XoitX> and the proofs are simplified
14:47:49 <XoitX> am i right?
14:47:56 <ertes> XoitX: "expression" is very vague in haskell…  you have values and types, and you have "expressions" for each
14:48:01 <EvanR> this seems rather empty... i can map True and False to all kinds of things
14:48:02 <ertes> 1 + 1 is a value expression
14:48:06 <jle`> If x :: Bool is inhabited, then (if P and P then P) is true.  if x :: (a, b) -> a is inhabited, then "if P and Q, then P" is true
14:48:07 <ertes> Maybe Int is a type expression
14:48:45 <jle`> EvanR: yes, but this mapping preserves the whole "point" of the types as propositions thing
14:49:19 <EvanR> i think i just missed what the curry howard isomorphism is actually preserving besides cardnality
14:49:40 <jle`> the big deal i think is that, if the type is inhabited, then the proposition it corresponds to is true
14:50:10 <monochrom> it preserves deduction trees (call it proof tree or type-checking tree)
14:50:12 <jle`> so if ((Either (a -> (b, c)) (a, c)) -> b) -> c is inhabited, then the proposition it corresponds to is true
14:51:13 <EvanR> and vice versa?
14:51:21 <jle`> yea :O
14:51:27 <EvanR> and each proof corresponds to a different value?
14:51:40 <jle`> well, types can have more than one inhabitant
14:51:44 <EvanR> 1 to 1 correspondense
14:51:46 <jle`> so propositions can have more than one proof
14:52:16 <EvanR> yes so its interesting that theres a limited number of proofs
14:52:31 <ertes> somehow most "interesting" propositions have only one proof though
14:52:42 <XoitX> If I create a type that returns true for any statement .. what type is that
14:52:55 <EvanR> a broken logic?
14:52:59 <dmj> :t const True
14:53:01 <lambdabot> b -> Bool
14:53:07 <ertes> XoitX: you mean a function that returns True for any statement?
14:53:14 <jle`> EvanR: (if P and P then P) has two proofs -- "(P & Q) -> P" can be used, and "(P & Q) -> Q" can also be used
14:53:25 <XoitX> broken logic?
14:53:31 <ertes> XoitX: because a type doesn't "return" anything…  a type "contains", similar to a set
14:53:35 <XoitX> broken logic?
14:53:46 <EvanR> you shouldnt be able to proof 1 = 2
14:53:55 <XoitX> that means logic is constructed?
14:54:14 <monochrom> yeah, what does "returns True for any statement" mean?
14:54:28 <jle`> EvanR: state 1 == 2 using implication, conjunction, and disjunction
14:54:43 <ertes> XoitX: propositions and proofs have almost nothing to do with boolean logic
14:54:44 <jle`> and it shouldn't be inhabited
14:54:48 <EvanR> right
14:54:57 <XoitX> universality i guess.. I don't know.. I'm trying to get a hold of types.. completely
14:55:03 <EvanR> i managed to convince idris to confirm that one for me
14:55:14 <monochrom> you can't understand over an IRC conversation
14:55:38 <ertes> XoitX: i agree with monochrom…  learn haskell, and take your time
14:55:43 * EvanR puts XoitX into the super-barclay machine from the TNG episode where he becomes a genius
14:56:24 <XoitX> propositions and proofs have almost nothing to do with boolean logic----- That's what I was looking for
14:56:35 <Lokathor> anyone familiar with inline-c? I'm getting a "warning: return discards ‘const’ qualifier from pointer target type"
14:56:41 <XoitX> but it just leaves more questions!!
14:56:41 <Lokathor> but i'm not sure if i should care about such things or not
14:57:35 <ertes> XoitX: you should learn the basics of haskell, so when we talk about "types" and "values" and state something like "x :: A -> B C", you know what that means
14:57:48 <ertes> XoitX: then you can start building the foundations for propositions as types
14:58:31 <XoitX> hmmm
14:58:53 <XoitX> I'm gonna read wadler's book tomorrow 
14:59:06 <XoitX> I'll be back
14:59:08 <EvanR> which book
14:59:17 <XoitX> thanks for the help
14:59:20 <XoitX> wait
14:59:24 <XoitX> I just downloaded it
14:59:53 <XoitX> Intro to functional programing
15:00:04 <XoitX> I must solve this!!!
15:02:40 <ertes> XoitX: the road to type theory (i.e. using types to do formal mathematics rather than (or in addition to) programming) is actually pretty long…  that shouldn't discourage you though, because you'll pick up countless interesting things along the way…  just don't expect that the quick-n-dirty way will work, because it won't =)
15:03:09 <ertes> however, you can learn haskell *programming* rather fast compared to that
15:04:24 <lyxia> funny, GHC.Generics.M1's type parameters spell out icfp
15:05:01 <EvanR> ertes: actually i thought that was a book title, i was disappoint
15:05:44 <ertes> lyxia: don't look at the lens type parameters…
15:06:07 <lyxia> :D
15:06:13 <monochrom> haha lyxia
15:06:33 <xa0> Lol
15:06:48 <xa0> Is lens the one that spells out fmap?
15:07:04 <xa0> Or was that something in recursive-schemes
15:07:06 <ertes> xa0: not quite so nice…  Lens s t a b…
15:07:09 <dmj> stab
15:07:10 <xa0> Ahaha
15:08:00 <EvanR> its bats backwards
15:09:29 <EvanR> ertes: but while searching google suggested instead Labyrinth of Thought: A History of Set Theory and Its Role in Modern Mathematics
15:09:44 <ski> @where boolean-blindness
15:09:44 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
15:09:53 <ski> XoitX : that ^ might perhaps be interesting
15:11:50 <EvanR> it seems that "type theory" was a thing before set theory
15:11:56 <ertes> EvanR: interesting…  if "the road to type theory" would exist as a book title, it would probably be an anecdotal short story or something…  or should i say an intotal short story?
15:13:17 <EvanR> woosh
15:15:48 <monochrom> the road to type theory is a one-way road of no return. you can only go forward. if you see Buddha, kill Buddha. if you see Fraenkel, kill Fraenkel.
15:16:31 <Rembane> Is Pai Mei involved in this?
15:16:36 <Rembane> Or Tyler Durden?
15:16:40 <monochrom> probably
15:16:49 <Rembane> Good
15:16:50 <monochrom> Pai Mei I mean.
15:17:00 <ski> (jle` : (nitpick) .. actually, `Bool' would be "For every proposition `P', if `P' and `P', then `P'.")
15:17:27 <ertes> "wanna prove a theorem?  wanna prove it convincingly?  understand equality?  got 10 years?  open to revisiting your answer to the third question?  got another 10 years?  learn type theory!"
15:17:55 * ski is stuck on the third one
15:18:08 <monochrom> I want to understand equality, too.
15:18:16 <EvanR> what does buddha or fraenkel have to do with type theory
15:18:59 <geekosaur> the former is a reference to a zen kōan
15:19:20 <ski> (also a declarative debugger. probably not intended, though)
15:19:22 <eldon> i'm watching a pluralsight video on haskell and the speaker states that "haskell programs very rarely crash, unless they run out of memory" - what does he mean by that?
15:19:38 <ertes> eldon: exactly that
15:19:44 <eldon> are there traits in haskell/functional programming that make crashes less likely? e.g. immutability or something?
15:19:55 <EvanR> if they run out of memory, they have a chance of crashing
15:19:58 <EvanR> a good chance
15:20:00 <XoitX> There is no falseness ... there is only truth..... 
15:20:17 <monochrom> types forbid a lot of crashes
15:20:19 <Cale> eldon: There are, to be fair, plenty of other ways for Haskell programs to fail.
15:20:20 <XoitX> I have found my answer
15:20:21 <geekosaur> the majority of crashes in non-haskell progrms are either (a) poor type systems not preventing you from illegal memory accesses, or (b) type mismatches in dynamically typed languages
15:20:30 <XoitX> :D
15:20:31 <geekosaur> with Haskell (a) can only happen with FFI calls
15:20:36 <maerwald> eldon: I disagree on that statement, especially since the exception system in haskell is not very nice
15:20:49 <maerwald> so people often don't even know there are uncatched exceptions
15:21:03 <alexashka> hey guys, first time here: can somebody shed some light on the significance of the third law of monads: m >>= (x -> k x >>= h)  =  (m >>= k) >>= h. What is that saying in plain english?
15:21:09 <eldon> oh, interesting
15:21:12 <EvanR> maerwald: that they care about
15:21:14 <Cale> eldon: However, the fact that the type system is quite expressive, and we can restrict what things our programs are allowed to do, often to the point that the first thing which typechecks will also work, gives us a fair amount of justified confidence.
15:21:24 <geekosaur> and the latter is only going to happen with things that go around the typesystem --- exceptions, Data.Typeable, etc.
15:21:34 <ertes> eldon: in haskell you don't touch the bare metal as much as in other languages…  you don't buffer-overflow, because in most cases you use no explicit indexing in the first place, so there is simply no opportunity to go beyond the buffer
15:21:45 <eldon> ah i see
15:21:49 <maerwald> EvanR: hm?
15:21:50 <eldon> that makes a lot of sense
15:21:54 <maerwald> yeah
15:21:57 <ski> alexashka : it's saying that grouping order of commands doesn't matter
15:22:05 <EvanR> you dont really want to catch every exception
15:22:17 <EvanR> but would be nice what is possible
15:22:19 <EvanR> to know
15:22:56 <ertes> eldon: it's basically functional programming in a nutshell, but haskell gives you more opportunities to program in that style than most other functional languages
15:23:04 <ski> alexashka : `do y <- (do x <- foo; bar x); baz y' means the same as `do x <- foo; (do y <- bar x; baz y)' (which can be shortened to `do x <- foo; y <- bar x; baz y')
15:23:28 <eldon> the only other functional language i've used is erlang, there are a lot of similarities so far
15:23:55 <ski> alexashka : in practice this means that you can factor out a subsequence of commands in a `do'-expression into a separate definition (making sure to pass parameters needed), or the reverse .. in the way that you'd expect to be able to
15:24:08 <Cale> eldon: I've completed large refactorings which touched hundreds of lines of code (e.g. there was one which took a few hours to complete, making changes throughout about 8k lines of code), basically by starting out making a change to something which affects its type, or changing the definition of a type somewhere, and then iteratively fixing what the compiler errors tell me to fix. This has resulted in a working program
15:24:08 <Cale>  after the compiler stops complaining often enough not to be a coincidence :)
15:24:20 <monochrom> erlang is the opposite, where you get to say: crashing rarely affects availability :)
15:24:56 <monochrom> in fact, how about: crashing rarely affects availability, unless you run out of electricity :)
15:25:05 <Cale> eldon: In something dynamically typed like Python for example, such a change would basically involve a full rewrite.
15:25:06 <ertes> eldon: they are very similar, even in the way they handle concurrency…  but the idioms are actually very different…  and another factor that keeps haskell programs from crashing is what Cale said
15:25:21 <ertes> eldon: not just the type safety, but that you can *refactor* safely
15:26:12 <Cale> Because you'd make that first change, and then everything would be broken, and there'd be no systematic way to find it all -- you might have introduced many subtle bugs which would only appear at runtime much later.
15:26:26 <ski> ability to refactor is part of "reasonability", ability to reason effectively in and about the language
15:26:57 <Cale> and sure -- there are lots of bugs which the Haskell type system doesn't try to catch for you, but it's enough to be very useful
15:27:05 <eldon> yeah i guess everything being a pure function really helps with that to
15:27:08 <eldon> too*
15:27:10 <Cale> yeah
15:27:16 <ski> programming languages shouldn't be judged only on their expressivity, but also on their "reasonability". attempting to raise the level of one usually causes the other to be lowered
15:27:28 <monochrom> anyway, it has long been observed that decidable type systems are a special case of invariants. (and a sufficiently general type system is equivalent to invariants.)
15:27:35 <Cale> The fact that you can test a pure function in isolation, and then have a guarantee that it will work the same way in the full program is huge.
15:27:50 <Cale> It mostly eliminates the need for sophisticated debuggers.
15:28:09 * ski would still like Buddha to be resurrected
15:28:17 <monochrom> ski: I call that cavalier power vs predictive power
15:28:46 <ski> monochrom : personal terms, or have you seen someone else use them ?
15:28:57 <Cale> Because it means that you can break things down into parts which are understandable and you don't need to create a complicated context surrounding them to account for all the unknown things which might affect their behaviour.
15:29:01 <Cale> Same arguments, same result.
15:29:04 <monochrom> personal. but we can all help make it universal
15:29:21 <alexashka> ski: what about in `do y <- (do x <- foo; bar x); baz y' - I can't call baz x there. I can only do baz y. Isn't that significant? In other words x is unavailable in the first example outside of y but it is available in the last example you gave where you did 'do x <-, y <-?
15:29:22 <monochrom> and then, of course, "predictive power" comes straight from science.
15:29:23 <ski> i'll consider them as an alternative
15:30:03 <monochrom> the important point is to use "cavalier" to deride the desire to write arbitrary programs :)
15:30:37 <ski> alexashka : obviously the rewrite only applies in case `x' isn't used in the rest (otherwise, make sure to include `x' in `y')
15:30:59 * ski nods
15:31:28 <ertes> eldon: one interesting aspect of haskell is that abstractions are very cheap, so we tend to use them: from the small scale ("you don't loop, you fold") to the large scale ("you don't write an special procedure, you write a special language and an interpreter for it")
15:31:53 <ertes> all of that reduces the "crashability" of your program
15:33:17 <maerwald> abstraction reduces the crashability? uh
15:34:06 <eldon> interesting, not got that far in yet, learning about guards now, it's a bit of a mind bender :)
15:34:12 <Cale> maerwald: It can -- in that when writing things that operate in an abstract way, you have fewer opportunities to let irrelevant details cause misbehaviour. You *have* to be more uniform.
15:34:34 <Cale> maerwald: as a simple example...
15:35:05 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c) -- there's essentially one reasonable way to implement a function of this type
15:35:30 <Cale> composeString :: (String -> String) -> (String -> String) -> (String -> String)
15:35:39 <monochrom> ski: this is where I first nailed "what does powerful mean?" and said it in public: http://lambda-the-ultimate.org/node/4816#comment-77080
15:35:41 <Cale> -- but there are lots of ways to screw this one up
15:35:42 <ertes> even simpler example: a fold will never cross data structure boundaries
15:35:53 <maerwald> Cale: in non-abstract languages you can just use a well tested library, same effect
15:36:12 <Cale> maerwald: Somebody has to write and test that library
15:36:24 <EvanR> make sure youre talking about the same kind of abstractions
15:36:40 <EvanR> giving somebody an IO () isnt... very good abstraction
15:36:41 <Cale> maerwald: You can do the same thing with Haskell -- breaking things into libraries doesn't absolve us of the responsibility of checking that we're doing the right thing.
15:36:57 <ertes> note that library ≠ abstraction
15:37:08 <ski> monochrom : ty
15:37:09 <maerwald> I don't think that this is something unique to haskell or abstraction
15:37:25 <Cale> maerwald: This happens with abstraction in mathematics as well
15:37:30 <ertes> what is unique to haskell and similar languages is that it makes these abstractions *cheap*
15:37:38 <ertes> to define, to use, to *run*, …
15:37:50 <ski> (i don't recall when i first talked about "reasonability". i also remember someone in #scheme made the same observation. perhaps i could find it ..)
15:37:51 <maerwald> Cale: mathematics does not crash? xD
15:38:10 <Cale> Yeah, but there's still potential for bugs
15:38:10 <ski> maerwald : buggy math does
15:38:52 <hpc> hooray for new math, new-hoo-hoo math
15:39:26 <maerwald> bugs != crash bugs
15:39:35 <maerwald> there are a lot of ways to reduce crash bugs
15:39:43 <monochrom> set theory almost crashed
15:39:43 <EvanR> yep, like php's way
15:39:45 <EvanR> a white screen
15:40:02 <Cale> maerwald: One thing which I realised when I took Real Analysis 1 was that many of the theorems once generalised to metric spaces were much easier to prove than they had been when we proved them for real numbers or R^n, basically for the sole reason that if you start thinking of |a - b| as "the absolute value of a minus b" rather than "the distance between a and b", there are lots more operations you have available to y
15:40:03 <Cale> ou, and so searching for the right thing to do gets harder.
15:40:06 <monochrom> and geometry almost clashed
15:40:09 <ski> Frege tried to patch set theory
15:40:10 <fabian__> Im trying to combine Data.Dynamic and STRefs. I have a data type (Door s) where s is the ST state thread type. Whenever I try to do fromDynamic to get a Maybe (Door s), GHC complains that there is no instance (Typeable s). I can't constrain s ofc, is there any other solution?
15:40:38 <maerwald> Cale: I'm unable to follow how that relates to crash bugs or how that shows that abstraction reduces them considerably
15:41:06 <EvanR> maerwald: i think in the presence of bugs, crash bugs are more preferrable than continue and be completely wrong bugs
15:41:21 <EvanR> so if youre trading one for the other i pass
15:41:53 <maerwald> EvanR: but abstraction can barely safe you from that, especially when you deal with IO, you always end up with exceptions
15:42:03 <Cale> maerwald: I'm lumping all bugs together here -- crash bugs are not really separable from other sorts, as mistakes in reasoning can mean you can end up in branches of the code which ought never to happen.
15:42:07 <ertes> fabian__: Typeable used to be restricted to concrete types, but i'm not sure that's still the case…  you might need PolyKinds though
15:42:15 <EvanR> well thats not the "abstraction" people are talking about here
15:42:18 <Cale> (and so perhaps an exception just gets thrown and kills the program)
15:42:27 <EvanR> IO () isnt a good abstraction
15:42:28 <ertes> fabian__: but whether Dynamic can handle them is another question
15:42:28 <FAuUiDkld> guys
15:42:49 <shachaf> ertes: It wouldn't be good for runST's choice of s to be Typeable.
15:43:03 <ertes> oh, it's *that* s
15:43:43 <ertes> fabian__: ignore what i said (though it's still slightly relevant) =)
15:44:05 * ski . o O ( `runST :: forall a. (forall k. forall (s :: k). ST s a) -> a' )
15:44:19 <fabian__> ertes: :)
15:44:35 <Cale> ski: hah
15:45:12 <Cale> s was a Constraint all along!
15:45:28 <ski> or something else, unutterable
15:45:42 <ski> (perhaps of a dynamically generated kind ?)
15:46:07 <fabian__> shachaf: no, it has to be unconstrained
15:46:29 <shachaf> fabian__: Right.
15:46:40 <maerwald> Cale: branches of code that ought never to happen... that's a problem about type safety and compiler strictness, not abstraction
15:47:02 <shachaf> This is an interesting question with no obvious answer, I think.
15:47:14 <EvanR> maerwald: you know the quote about abstraction giving you the power to be absolutely precise
15:47:25 <Cale> maerwald: The point is that by abstracting, you limit the operations available to you, and limit the number of ways that your program can do something which you didn't intend.
15:47:30 <EvanR> this is how you can stop bugs with abstraction
15:47:39 <EvanR> (not vagueness like IO)
15:47:47 <Cale> maerwald: Something which has to work for all monads has a lot less options available to it than something which works with IO
15:47:50 <ertes> runST :: forall a. (… (forall (s5 :: …). (forall (s4 :: s5). (forall (s3 :: s4). (forall (s2 :: s3). (forall (s1 :: s2). (forall (s :: s1). ST s a))))))) -> a
15:47:58 <maerwald> I simply disagree. Rust takes a different approach that has barely anything to do with abstraction and yet it considerably decreases random crashes.
15:48:02 <EvanR> for loops were a better abstraction than goto (for what they were being used for)
15:48:06 <Cale> maerwald: There are fewer ways that highly polymorphic things can go wrong.
15:48:23 <EvanR> map is a better abstraction than for loops for when loops are used to do a map
15:48:40 <maerwald> EvanR: can you show me a for loop in rust that crashes?
15:48:41 <EvanR> and fold is a better abstraction than for loops when loops are used to do a fold
15:48:46 <Cale> maerwald: I'm not saying this is the only way you can avoid bugs
15:49:03 <Cale> maerwald: But just that abstraction is a powerful tool for limiting the scope of bugs
15:49:09 <ski> ertes : yes .. i was wondering how to express that succinctly :)
15:49:13 <EvanR> maerwald: were talking about doing it correctly, not just not crashing
15:49:19 <monochrom> ski:  I think we're pretty close to being able to say: forall (Type :: Type) . forall s :: Type . ST s a
15:49:35 <ertes> ski: there you go, i just both saved and wasted your time =)
15:49:52 <EvanR> like i said, you can not crash just by designing your language to reduce to () if something unexpected comes up
15:49:58 <EvanR> (PHP)
15:50:09 <EvanR> but thats terrible
15:50:11 <Cale> maerwald: I feel like you have a weird definition of crash which is not the one everyone else here is using.
15:50:21 <Cale> maerwald: resulting in () is basically crashing
15:50:34 <Cale> (when you were meant to produce something entirely different from that)
15:51:01 <fr33domlover> reduction of the number of details and helps see problems, since you see only high level concepts and less small technical distractions
15:51:05 <EvanR> or freeze up like phantomjs
15:51:08 <ertes> rust does have one feature i envy it for, but mostly for convenience and speed rather than avoiding bugs:  affine types
15:51:09 <fr33domlover> *also helps
15:51:13 * ski has sometimes wanted to be able to use an identifier in its own type signature
15:51:14 <ertes> i really want those in haskell
15:51:15 <Cale> fr33domlover: yeah
15:51:41 <Cale> fabian__: hmm... can you use something other than Dynamic?
15:51:54 <Cale> fabian__: which is still parameterised on the s?
15:52:06 <EvanR> i dont especially want to write for loops for each fold, even if there exists a type system that makes sure i do it right
15:52:11 <fabian__> Cale: I can tell you my "problem" its common and short
15:52:12 <maerwald> Cale: you can write polymorphic functions that crash too. I don't think that's the real reason here. It's the types, the compiler knowing about non-exhaustive patterns and the ecosystem. You can have these things in other non-abstract languages too
15:52:25 <ski> ertes : is it affine types, or uniqueness types ?
15:52:36 <ertes> ski: the former IIRC
15:52:48 <maerwald> it's just that in haskell people tend to know what a partial function is
15:52:50 <maerwald> and try to avoid it
15:53:09 <EvanR> youre fixating on crashing, but really crashing is your best bet when theres a bug
15:53:17 <EvanR> so you dont want to avoid it
15:53:22 <EvanR> you want to avoid the bugs
15:53:27 <maerwald> no, I'm not just focussing on crashing
15:53:45 * fr33domlover just loves functional programming since he discovered it 1-2 years ago with Scheme, and isn't planning to move to anything else but FP for primary use (in particular Haskell)
15:53:52 <maerwald> I think it's about the strictness of the type system, not the abstraction patterns
15:53:59 <ski> ertes : a value of an affine type can't be duplicated in the future. a value of a uniqueness type hasn't been duplicated in the past. the latter is what you want for pure update-in-place
15:54:01 <Cale> maerwald: When you say "it's the types", you're often talking about polymorphism, i.e. abstraction
15:54:06 <EvanR> abstraction is a way to be strict
15:54:11 <maerwald> Cale: often, not always
15:54:15 <ertes> EvanR: there are two sorts of crashes:  safe crashes (exceptions) and the type of crashes that makes your heart bleed…
15:54:23 <maerwald> Cale: and that's why I think you are confusing it
15:54:25 * ski idly wonders what "non-abstract languages" mean
15:54:31 <Cale> I'm not confusing anything here.
15:54:33 <ertes> though i'm not sure i believe that the discussion started with the latter type
15:54:45 <EvanR> yes, C is fairly abstract
15:55:05 <ertes> ski: and linear types is basically both, isn't it?
15:55:09 <ski> EvanR : "crashing is your best bet when theres a bug" -- apart from a static error
15:55:25 <maerwald> I guess Erlang disagrees there :P
15:55:29 <fabian__> I have a class Entity s e, a list [EntityRef s] with data EntityRef s = forall e. Entity s e => EntityRef (Entity s e), and a data type data Door s with a Entity instance. I want to filter the list to get a list [Door s]
15:55:33 <Cale> fabian__: data SomeS s = forall f. (Typeable f) => MkSomeS (f s) -- perhaps something like this?
15:55:41 <ski> ertes : nope. linear types are line affine types. except that you can't refrain from using the value either, you can't drop garbage on the floor
15:55:44 <EvanR> erlang doesnt not have static errors because they think its bad
15:55:47 <ski> s/line/like/
15:55:56 <ertes> ah, i see
15:55:57 <Cale> hmm
15:56:00 <EvanR> erlang doesnt have static errors because they dont have that feature
15:56:08 <EvanR> because its a lot of work for language implementors
15:56:12 <ertes> ski: really i'd like to have all of them
15:56:47 <EvanR> dynamic systems are easier to implement at the expense of nice features
15:56:58 <EvanR> (being omitted)
15:57:34 <maerwald> EvanR: uhm, I'm pretty sure Erlang does it on purpose this way
15:57:43 <fabian__> Cale: how would I use that?
15:58:09 <EvanR> maerwald: youre still talking about crashing right
15:58:10 <ertes> EvanR: are they?  unless you use very weak typing, i'm pretty sure that at least *compiling* a dynamic language is pretty complicated
15:58:11 <Cale> maerwald: It's similar even down at the level of electronics -- the digital abstraction makes things much simpler to design -- once you have to start caring about the analog signals involved, things get harder, and if you have to care about the actual electric field and can't use your circuit abstraction, they get harder again.
15:58:17 <EvanR> i was talking about static errors
15:58:40 <EvanR> ertes: compilation is another feature that doesnt get implementation because its hard, i think its orthogonal to static checking
15:58:57 <ertes> interpreting perhaps not that much…  you can just compare names of types
15:58:58 <maerwald> Cale: except when you use buggy abstraction :P
15:59:08 <EvanR> yeah avoid those
15:59:11 <maerwald> ...
15:59:14 <maerwald> avoid IO?
15:59:16 <EvanR> for example, for loops
15:59:20 <EvanR> and goto
15:59:27 <EvanR> and IO
15:59:29 <maerwald> ...
15:59:44 <maerwald> except I can't
15:59:46 <Cale> fabian__: can I see more of your code?
15:59:49 <ertes> is there a sensible way to keep "languages" and "abstractions" separate?
15:59:53 <EvanR> holdOnToYourSeat :: IO ()
15:59:57 <ertes> because i think of IO as a language more than an abstraction
15:59:58 <EvanR> ^ not abstraction
16:00:04 <Cale> fabian__: (Ideally enough that I can stick it into a compiler/typechecker)
16:00:35 <Cale> IO is an abstraction itself, but there are other abstractions built over it
16:00:40 <EvanR> youre better off using an abstraction that does more precise IO than directly writing the IO out yourself
16:00:44 <ertes> to me mapM_ is an abstraction, and concurrency is an abstraction
16:00:45 <maerwald> EvanR: please tell me how I can write my filemanager without IO and delete, create, move files that way :P
16:00:56 <EvanR> you need a file manager abstract obv
16:00:59 <EvanR> ion
16:01:17 <fabian__> Cale: http://lpaste.net/630545682029084672
16:01:20 <maerwald> EvanR: a lot of haskell librararies that provide that so called "abstraction" on file operations like the directory package are _horribly_ buggy
16:01:28 <EvanR> sure
16:01:30 <maerwald> so you will end up using the low-level unix bindings
16:01:35 <maerwald> which is the only safe way
16:01:42 <EvanR> yeah
16:01:47 <Cale> maerwald: Perhaps you're in an arbitrary monad but where you have specific actions which accomplish filesystem-related things available to you.
16:01:50 <ertes> buggy?  error-prone, sure, but buggy?
16:02:04 <EvanR> as in a leaky abstraction
16:02:09 <maerwald> ertes: semi-defined behavior if you will, including laziness
16:02:13 <Cale> maerwald: and you have no way of knowing whether everything that's happening is happening to the real filesystem or a simulated one for debugging.
16:02:44 <maerwald> especially since some of this "abstract" libararies want to be cross-platform very hard
16:02:48 <maerwald> except that doesn't work nicely
16:03:12 <maerwald> so you end up removing abstraction to be safer
16:03:22 <Cale> fabian__: thanks, having a look
16:03:34 <EvanR> maerwald: your thesis has been, haskell is not the only language that has (good) abstractions. how do you propose to do this file manager thing is a better way? (in whatever language)
16:05:19 <maerwald> EvanR: my point is that a) I believe that haskell improves bugginess mainly through the type system and compiler strictness, maybe abstraction does it's part, but it's not the primary one IMO
16:05:19 <maerwald> and b) that languages like Rust solve this too in a similar way, but allow far less abstraction, which is an indication to me that it's definitely about types and not allowing people to operate on memory directly or in silly ways
16:05:53 <ertes> i disagree with a)
16:06:04 <EvanR> segfaulting sure does get in the way of doing the right thing but
16:06:25 <EvanR> simply making segfaulting impossible doesnt make it nice to implement things
16:06:48 <maerwald> I can't follow that argument
16:06:53 <ertes> but how much abstraction you use is really up to you…  i use abstraction a lot, and it does both reduce error-proneness and refactorability
16:07:10 <ski> (s//improve /)
16:07:15 <dmj> ertes: reduces refactorability ?
16:07:25 <ertes> improves…
16:07:33 <koz_> Yeah, was about to say...
16:07:34 <maerwald> EvanR: I don't think you choose rust if you want really strong high-level abstract solutions anyway. It's a system programming language.
16:07:39 <maerwald> not sure that's worth debating over
16:08:08 <EvanR> i wasnt really asking about rust
16:08:23 <maerwald> but what it has in common with haskell is strict and strong types and a very strict compiler and that you have less control over memory
16:08:30 <EvanR> just what improves over haskell's "not the primary thing that is helping" abstractions
16:08:39 <dmj> maerwald: why use multiple languages if you don't have to
16:09:11 <maerwald> dmj: why use one for everything?
16:09:12 <EvanR> (rather, haskells ability to let you design abstractions how you want)
16:09:17 <ertes> in a sense rust actually has stricter types than haskell…  they went very far to ensure memory/resource safety in the type system
16:09:19 <dmj> maerwald: less complexity
16:10:12 <maerwald> that's a different discussion and I don't think it's useful :P
16:10:19 <icicled> Is it possible to make this a one-liner: http://lpaste.net/4864875199520047104
16:10:47 <maerwald> ertes: interestingly, they once had an IO type...
16:10:52 <maerwald> unfortunately they dropped it
16:11:02 <icicled> r :: IO a
16:11:06 <EvanR> rust was pure?
16:11:09 <maerwald> people didn't have the mindest to deal with it
16:11:10 <maerwald> yes
16:11:13 <ertes> icicled: (do x <- action; f x) = action >>= f
16:11:20 <maerwald> *mindset
16:11:24 <icicled> ah!
16:11:25 <maerwald> they were complaining and so on
16:11:44 <maerwald> and so they decided... the domain of rust is IO anyway, so let's just not care :o
16:11:44 <ski>   execSql q = liftIO =<< (flip withResource q <$> reader envDBPool)  -- fwiw
16:12:03 <icicled> of course, why didn't I see that!
16:12:07 <icicled> thanks ertes
16:12:10 <EvanR> thats unfortunate that people thought the domain was "IO" specifically ;)
16:12:11 <ertes> maerwald: probably because IO comes with a huuuuuge bag of complexity of its own
16:12:15 <EvanR> because IO isnt very specific
16:12:27 <EvanR> from what i gathered the domain is memory management
16:12:31 <EvanR> which isnt IO at all
16:12:37 <ertes> for example you can't actually have IO without non-strict semantics
16:13:07 <fabian__> Cale: it might be pure crap, idk
16:13:19 <ski>   (`withResource` q) <$> ...
16:14:01 <ertes> but if you choose to have IO, you get a lovely imperative DSL…  the mere lack of first class actions makes it a pain for me to program in a language that lacks IO
16:14:29 <ski> icicled : .. i'm wondering about the nested `IO'
16:15:17 <int-e> icicled: also  (f <$> g) >>= h  can be rewritten as  g >>= h . f  (some people will prefer  h . f =<< g)
16:15:51 * ski is some people
16:16:11 <ertes> ski: looks sensible to me…  it's the fmap/join idiom instead of naming the database connection
16:16:24 <ertes> s/sensible/reasonable/
16:16:55 <ertes> except that liftIO takes the role of 'join' here
16:17:19 <FAuUiDkld> are databases sold ? if so where?
16:17:59 <EvanR> microsoft
16:18:15 <amalloy> is there a function like this? f x y = if null x then y else x  -- it seems kinda like it belongs in Alternative or something, but of course <|> is just ++ for lists
16:18:18 <int-e> ertes: more precisely, (>>= liftIO) (instead of join = (>>= id))
16:20:59 <Cale> fabian__: got it... I think
16:22:08 <lpaste> Cale pasted “Fabian's code, refactored a bit.” at http://lpaste.net/157901
16:23:01 <lpaste> Cale revised “Fabian's code, refactored a bit.”: “No title” at http://lpaste.net/157901
16:23:53 <Cale> interesting that the linter doesn't mention the redundant 'where's in empty instance declarations
16:24:13 <Cale> fabian__: ^^ anyway check it out
16:24:20 <icicled> int-e thanks for pointing that out - will have a look
16:24:50 <Cale> fabian__: If you want, maybe the fundeps can go back into the classes...
16:24:52 <icicled> ski: that's another neat way - I like `withResource`
16:25:02 <Cale> fabian__: I removed them in a bit of haste
16:30:06 <fabian__> Cale: Ill have a look, thanks
16:39:39 <Cale> fabian__: Basically, I reimplemented Dynamic, only with an s type parameter.
16:40:05 <Cale> (Dynamic is a pretty trivial layer on top of Typeable)
16:41:14 <Cale> fabian__: Oh, also, you might want to write fromDoor again, just defining it as a special case of fromEntity
16:41:29 <Cale> fromDoor :: SomeEntity s -> Door s
16:41:33 <Cale> fromDoor = fromEntity
16:41:47 <Cale> Then we wouldn't need the ScopedTypeVariables usage there
16:46:35 <Cale> fabian__: Also worth pointing out, this is implicitly a very flexible system of subtypes (maybe too flexible even) -- by writing instances of Entity that aren't the default one, especially overriding the implementation of fromEntity, you can use other instances of fromEntity to try to cast the thing as perhaps multiple other types, or place extra conditions where you can treat one sort of Entity as a special case of an
16:46:35 <Cale> other.
16:47:21 <Cale> So you basically have arbitrary unions and refinements
16:48:20 <Cale> (even intersections if you had enough cases where it would be relevant to want them)
16:48:24 <amalloy> is there a function like this? f x y = if null x then y else x  -- it seems kinda like it belongs in Alternative or something, but of course <|> is just ++ for lists
16:48:39 <Cale> amalloy: I've seen that called orElse
16:48:53 <Cale> amalloy: But as far as I know, it's not in a convenient library
16:49:54 <Cale> https://wiki.haskell.org/MonadPlus_reform_proposal
16:49:57 <Cale> ^^ very old :)
16:51:39 <Cale> fabian__: Oh, probably EntityRef could become just  STRef s (SomeEntity s)
16:52:45 <Cale> fabian__: Also, you'll want an instance of Entity for SomeEntity, in which both toEntity and fromEntity are id
16:53:16 <Cale> er, fromEntity is Just :)
16:57:51 <fabian__> Cale: This is really nice!
16:58:10 <fabian__> any reason you removed the Sentient Human instance? and made it a separate function
16:58:53 <Cale> fabian__: That was a silly reason -- I was moving fast and wanted to give an explicit forall on the s so that I could use it in the type signature for d
16:59:14 <fabian__> Cale: cool, got it all compiling now!
16:59:20 <Cale> fabian__: If you write fromDoor :: SomeEntity s -> Maybe (Door s), then you don't need to separate out that function
17:00:35 <Cale> I'm not certain the "to" and "from" are the right way around everywhere :D
17:00:51 <Cale> That should probably be toDoor? I dunno :)
17:02:14 <fabian__> Cale: oh. One more thing. Is it possible to interleave IO and ST? Right now the ST action returns an IO action for Main to run, but to do cooler stuff a Monad stack is needed
17:03:01 <ski> Cale : `= True' ?
17:03:11 <Cale> ski: ?
17:03:20 <ski> your `Eq' instances
17:03:36 <Cale> ski: uh, I didn't look at the Eq instances
17:03:43 <Cale> Were there Eq instances in that code?
17:03:58 <ski> oh, they're fabian__'s instances (?)
17:04:04 <Cale> yeah
17:04:05 <fabian__> Like the humanSentientAct method can return the IO action to print something. But it doesn't support interleaved actions
17:04:28 <fabian__> I didn't have time to implement them :)
17:04:36 <ski> @hoogle stToIO
17:04:36 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
17:04:36 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
17:04:36 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
17:04:43 <ski> fabian__ : ^ might be useful
17:05:13 <ski> (don't use the last one, unless you know what you're doing)
17:05:25 <fabian__> that was the one that looked interesting!
17:05:36 * ski grins
17:05:39 <Cale> fabian__: You should always be able to use stToIO
17:05:50 <Cale> unless you're being sneaky
17:07:31 <zRecursive> What is the step(s) used by GHC to find/load a package ?
17:08:07 <Cale> zRecursive: There are a small number of package databases which you can see a listing of using  ghc-pkg list
17:08:24 <Cale> zRecursive: When packages are installed, information about them is written to one of those.
17:09:25 <fabian__> Cale: Not its time for sleep, thanks for the help!
17:09:30 <zRecursive> Cale: `ghc-pkg list|grep -i win32`\n    Win32-2.3.1.0  \n `$ ghc-pkg list|grep -i time\n   time-1.5.0.1`, but win32 loaded successful and time cannot be found when staring ghci
17:09:31 <Cale> fabian__: cheers!
17:09:39 <fabian__> does the code show some kind of hope?
17:09:57 <Cale> zRecursive: btw,  ghc-pkg list <packagename>   will show you all the entries for that package
17:11:14 <Cale> fabian__: I think it'll work...
17:11:20 <zRecursive> Cale: `ghc-pkg list time` => WARNING: cache is out of date: c:/haskell/ghc-7.10.3\lib\package.conf.d\package.cache\n ghc will see an old view of this package db. Use 'ghc-pkg recache' to fix.\n c:/haskell/ghc-7.10.3\lib\package.conf.d:\n    time-1.5.0.1   \nc:/z\Application Data\ghc\i386-mingw32-7.10.3\package.conf.d:\n    (no packages)
17:12:38 <Cale> zRecursive: That's an interesting warning, I don't think I've ever seen that one
17:12:48 <Cale> zRecursive: did you try running the command it recommended?
17:13:19 <zRecursive> After `ghc-pkg recache`, those warning disappear now
17:14:30 <Cale> zRecursive: does it find the time package?
17:15:11 <Cale> (try  :m + Data.Time.Clock  or something from ghci)
17:15:21 <zRecursive> Weird! `ghc-pkg list win32` => c:/haskell/ghc-7.10.3\lib\package.conf.d:
17:15:21 <zRecursive>     (no packages)\n  c:/z\Application Data\ghc\i386-mingw32-7.10.3\package.conf.d:    (no packages), but where does `ghci` load win32 ?   And `ghc-pkg list time` => c:/haskell/ghc-7.10.3\lib\package.conf.d:  time-1.5.0.1
17:16:25 <zRecursive> Cale: `Prelude> :m + Data.Time.Clock` => Prelude Data.Time.Clock
17:16:32 <Cale> cool, so it's finding time now
17:16:40 <Cale> Does it still find win32 stuff?
17:17:04 <Cale> See if you can :m + Graphics.Win32
17:17:33 <zRecursive> yeah, but `:m + Foo` => Prelude Data.Time.Clock Foo> func1 => ghc.exe: unable to load package `time-1.5.0.1'
17:17:39 <Cale> I've never ever had to ghc-pkg recache before
17:18:15 <zRecursive> `:m + Graphics.Win32` is ok too.
17:18:28 <Cale> zRecursive: did you see it load that version of the time package?
17:18:48 <Cale> maybe you have to try to use something from Data.Time.Clock...
17:19:07 <Cale> Try  getCurrentTime
17:19:50 <zRecursive> getCurrentTime => ghc.exe: unable to load package `array-0.5.1.0'
17:20:00 <Cale> oh, that's... really bad
17:20:31 <zRecursive> I cannot figured out for several days 
17:20:33 <Cale> How did you install GHC?
17:20:47 <Cale> Maybe just reinstall it from scratch
17:20:57 <zRecursive> from ghc-7.10.3-i386-unknown-mingw32.tar.xz and cabal-1.22.0.0-i386-unknown-mingw32.exe
17:21:32 <zRecursive> Cale: i have tried using stack which reports the same ODD error!
17:21:47 <zRecursive> for ghc-7.10.3
17:22:17 <zRecursive> on windows XP
17:22:31 <EvanR> monochrom: that thread on LtU... i dont understand what a lot of people are even doing on there i mean its *lambda* in the title of the site
17:23:07 <Cale> zRecursive: shot in the dark, is it 32 or 64 bit WinXP?
17:23:16 <EvanR> almost everyone in that thread, including xkcd, seem to be dissing FP
17:23:28 <zRecursive> Cale: 32 bit XP
17:23:53 <Cale> EvanR: lol
17:24:03 <maerwald> EvanR: is it because of the date?
17:24:21 <EvanR> 2013-09?
17:24:45 <maerwald> I thought you're talking about a recent thread
17:24:49 <EvanR> nah
17:25:14 <maerwald> can't trust anyone today... not even haskellers :P
17:25:29 <maerwald> and I'm not going to update my cabal
17:25:37 <zRecursive> Cale: I will try `https://haskell.org/platform/download/7.10.3/HaskellPlatform-7.10.3-i386-setup.exe` later.
17:25:53 <Cale> zRecursive: Yeah, I'm really confused
17:26:10 <monochrom> EvanR: I think they're just dissing "minimize mutation"
17:26:36 <Cale> zRecursive: Depending on what you're trying to use the compiler for, you might also want to look into getting a Linux partition ;)
17:26:46 <monochrom> more generally they're interested in all sorts of programming language research
17:27:21 <Cale> which thread?
17:27:57 <EvanR> Functional programming combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics.
17:28:08 <maerwald> :D
17:28:10 <EvanR> it took me a few minutes to realize this was supposed to be a joke
17:28:15 <EvanR> i think
17:28:35 <Cale> also the runtime performance of abstract mathematics?
17:28:37 <maerwald> "intuitive clarity of abstract mathematics" -- I think you can't joke more obviously :P
17:28:40 <monochrom> Cale: http://lambda-the-ultimate.org/node/4816
17:28:50 <EvanR> :S
17:28:56 <EvanR> i thought thats what we were doing here
17:29:45 <EvanR> and LtU's encodings must be messed up
17:30:34 <bitbystring> Hi, I recently switched from using String to creating a Builder, and I'm running into an encoding issue.
17:31:25 <bitbystring> The issue is that the character © is now represented as \169
17:32:03 <bitbystring> I'm not sure how to set things such that it prints out the human readable way
17:32:05 <EvanR> > '\169'
17:32:06 <lambdabot>  '\169'
17:32:08 <bitbystring> Does anyone have experience with this kind of thing?
17:32:22 <EvanR> > text "\169"
17:32:23 <lambdabot>  ©
17:32:56 <EvanR> as long as the data is right youre ok, be sure youre data is literally "\\169"
17:33:04 <EvanR> is NOT literally \\ 
17:33:45 <bitbystring> It comes up for "no-break space" as well
17:33:52 <bitbystring> that shows up as \160
17:34:02 <bitbystring> when you go look at the file that gets written
17:34:04 <EvanR> \169 is just how © is `show'n for debugging
17:34:17 <EvanR> ah
17:34:33 <EvanR> you must have used a show somewhere then
17:34:47 <bitbystring> Interesting!
17:34:48 <EvanR> > show "\169"
17:34:49 <lambdabot>  "\"\\169\""
17:34:57 <bitbystring> huh
17:34:58 <EvanR> > text $ show "\169"
17:34:59 <lambdabot>  "\169"
17:35:05 <EvanR> confused? ;)
17:35:17 <bitbystring> No, I see it now
17:35:42 <bitbystring> But I do need to turn Haskell strings into JS strings
17:35:57 <EvanR> ghcjs?
17:35:59 <bitbystring> so I was doing (stringUtf8 (show string))
17:36:06 <bitbystring> no
17:36:18 <bitbystring> I mean, it can be any strings
17:36:39 <bitbystring> I just need to escape \" I guess
17:36:51 <bitbystring> And I was calling show as a proxy for this
17:37:01 <EvanR> what library are you using to send data to js?
17:37:09 <bitbystring> I'm just making files
17:37:19 <bitbystring> so I make the Builder and then put it in a js file
17:37:26 <EvanR> ah then you just need to escape "
17:37:49 <bitbystring> Thanks a ton! :D
17:37:50 <bitbystring> cool!
17:37:52 <bitbystring> I have no idea how I'd have figured this out on my own :)
17:38:15 <EvanR> there might be a package for encoding stuff as js source code
17:38:27 <bitbystring> I actually use language-ecmascript for the AST
17:38:35 <bitbystring> bet their pretty printer is not so good IMO
17:38:37 <EvanR> (... theres also literally using json)
17:38:47 <bitbystring> but*
17:38:52 <bitbystring> Anyway, thanks again!
17:38:56 <EvanR> but its not pretty either
17:39:04 <EvanR> (aeson)
17:39:05 <bitbystring> haha, I agree ;)
17:45:08 <quazimodo> given a collection of collections such as [[1, "Australia"],[1, "Mexico"],[2,"USA"]] i'd like to create a hash collection like {1: ["Australia", "Mexico"], 2: ["USA"]}. It's not really a haskell question, more of a question of approach
17:45:26 <quazimodo> there's surely a nice way to do this using fold or something
17:45:37 <monochrom> [1, "Australia"] is a type error. please choose a better example.
17:46:36 <ski> looks like you may want some kind of "group by" operation
17:46:41 <ertes> quazimodo: given [(k, a)] you can go to Map k (Set a)
17:46:46 <ertes> that's one way
17:46:50 <maerwald> monochrom: if the type is: Show a => [a] ?
17:47:02 <quazimodo> ski: a "group by" suonds right
17:47:15 <ski> (which is what ertes suggested as well)
17:47:28 <quazimodo> ski <3
17:47:46 <quazimodo> I'm not sure how Set works
17:48:07 <EvanR> > let x = [1,"USA"] :: Show a => [a] in x
17:48:07 <ski> `Set a' is iso to `Map a ()', i think
17:48:08 <lambdabot>      Couldn't match expected type ‘a2’ with actual type ‘[Char]’
17:48:08 <lambdabot>        ‘a2’ is a rigid type variable bound by
17:48:08 <lambdabot>             an expression type signature: Show a2 => [a2] at <interactive>:1:9
17:48:14 <ertes> M.fromListWith S.union . map (\(k, x) -> (k, S.singleton x))
17:48:16 <EvanR> nope
17:48:31 <maerwald> EvanR: I meant sth like https://wiki.haskell.org/Heterogenous_collections#Existential_types 
17:48:37 <ertes> :t M.fromListWith S.union . map (\(k, x) -> (k, S.singleton x))
17:48:38 <lambdabot> (Ord k, Ord a) => [(k, a)] -> M.Map k (S.Set a)
17:48:50 <ski> maerwald : then you meant `[exists a. Show a *> a]'
17:48:54 <andromeda-galaxy> Does anyone know why adding a '_property = map id _property' when _property is known to be ']
17:49:06 <andromeda-galaxy> '[]' would have a significant performance impact?
17:49:13 <monochrom> if you go existential-Show, then you find that you can't even ask about ==
17:49:23 <monochrom> and without ==, you can't even group
17:49:51 <monochrom> and if you say you can fix that by (Eq a, Show a)...
17:49:59 <andromeda-galaxy> (a computation running in a state monad which increments another value and inserts something into an IntMap has a 1.5x performance decrease when a line is added that maps any function over a list part of the record which happens to be known to be [] in a few of my benchmarks)
17:50:07 <monochrom> well 10 hours ago I already said "enough moving-goal-post for a day"
17:50:31 <monochrom> besides, even if I entertained it, it would be too much of piling higher and deeper of more XY problems
17:50:42 <EvanR> Eq a... then you cant put ints and strings together
17:50:58 <ski> EvanR : well, you can. but it doesn't help
17:51:10 <monochrom> by the time you reach (Num a, Eq a, Ord a, Typeable a, Show a), it's an XYZABCDE problem
17:51:33 <maerwald> I think we have confused the guy asking the question now :D
17:51:43 <monochrom> it was a confused question to begin with
17:51:44 <ertes> isn't withFile a proper bracket?  i seem to be getting a resource leak on this one:  log fp msg = withFile fp AppendMode (`hPutStrLn` msg)
17:52:04 <monochrom> well, that's unfair. but there is no benefit in bringing up existential types
17:53:56 <EvanR> really you can put string and in together in an existential list with Eq a constraint?
17:54:12 <EvanR> i thought since (==) :: a -> a -> a it would fail
17:54:37 * ski . o O ( `withInputFile :: FilePath -> ((?stdin :: Handle) => IO r) -> IO r' )
17:55:04 <ski> EvanR : you can put them together. but you still can't compare them with `(==)'
17:55:23 <ski> ("binary method" problem, i suppose)
17:55:53 <EvanR> oh because the exists is inside the []
17:56:00 <ski> EvanR : you get one `(==)' for each element, neither of which could be used with any of the other elements
17:56:16 <ski> so you can only do `x == x', for each element `x'
17:56:19 <maerwald> I wonder what the ghc errors would look like
17:56:21 <EvanR> at least it can compare equal to itself!
17:56:25 <EvanR> unless
17:56:33 <EvanR> > (0/0) == (0/0)
17:56:35 <lambdabot>  False
17:56:36 <ertes> ski: if that was for me: i'd like to append a string to a file without -XImplicitParams =)
17:57:02 <ski> ertes : just a random thought apropos what you said
17:57:21 <monochrom> this is why "by the time you reach" ... "Typeable" :)
17:57:34 <ski> (Scheme has `with-input-file' that dynamically redirects the current input source that various procedures use)
17:57:44 <ertes> ah
17:58:04 <andromeda-galaxy> I assume that the 'map' only has to get the first consrtuctor of the list by following one pointer and will immediately return since it seems to be a Nil, any idea why this could be adding such a significant performance impact? doing it 100000 times adds about 1 second to my execution times
17:58:28 <ski> (another variant would be to dynamically redirect (by mutation, presumably) `stdin :: Handle' itself)
17:58:52 <ski> ertes : it helps to avoid the `hFoo' proliferation
17:58:54 <ertes> another variant is to just pass the handle =)
17:59:08 <ertes> ah…  well i don't mind the extra h there
17:59:20 <ertes> maybe we need appendFile alongside readFile and writeFile…
17:59:30 <ski> obviously :)
17:59:51 <EvanR> i support you writing appendFile and uploading it for me to use
18:01:14 <ertes> see above =)
18:01:29 <ertes> though replace hPutStrLn by hPutStr
18:01:54 <monochrom> I think appendFile is already in System.IO
18:02:23 * ski stares at quazimodo
18:02:32 <ertes> :t appendFile
18:02:33 <lambdabot> FilePath -> String -> ()
18:02:35 <ertes> indeed
18:02:41 <ertes> thanks
18:03:06 <monochrom> but you need write-permission of that file
18:04:08 * ski was (apropos grouping) pondering how to prove `AB = (ab : AB) * (p ab = a)', given `p : AB -> A', the other day
18:04:14 <monochrom> these two weeks I have been TAing about logspace, so I'm super sensitive to where you aren't supposed to write, where you aren't supposed to read, etc
18:05:29 <ski> er, that should be `AB = (a : A) * B a', where `B a' is defined as `(ab : AB) * (p ab = a)'
18:06:54 <ertes> monochrom: in most cases i'd just write to stderr and let some dedicated program do the file-writing, but in this case i'm writing a lot of files
18:07:02 <ski> (iow, to prove `AB = (a : A) * (ab : AB) * (p ab = a)'. in case `A' is a set, this is trivial)
18:07:11 <ertes> that's why i'm not keeping them open
18:09:33 <ski> (so the problem reduces to how to prove `eq : p ab = a' is equal to `refl (p ab) : p ab = p ab')
18:13:12 <quazimodo> ski: what's wrong?
18:13:43 <quazimodo> ski: i was thinking of the nice way to do these sorts of operations on collections, rather than hacky loops
18:13:58 <ski> nothing wrong, that i know of
18:14:03 <quazimodo> the best place I thought to ask would be here rather than #javascript
18:14:16 <ski> just wondering whether you got anywhere with your question/problem
18:14:20 <quazimodo> oh
18:14:22 <quazimodo> sure
18:14:40 <quazimodo> I observed how lodash project in JS is implementing their groupBy (turns out they had one)
18:15:06 <ski> i think the nice way to do it would be some kind of monoid-based fold thing
18:15:09 <quazimodo> by looking at that, now i need to find a function that iterates over a collection, holding onto an accumulator and using a setter function
18:15:51 <quazimodo> foldl can do this no?
18:16:02 <ertes> > appendFile "blah.txt" "test"
18:16:04 <lambdabot>  *Exception: blah.txt: openFile: does not exist
18:16:22 <andromeda-galaxy> okay, now I'm really confused.  'map id []' performs differently from 'map <small function defined in a where clause> []', even though neither actually executes the function, and both functions should be inlinable!
18:16:52 <Cale> ski: is p just supposed to be an arbitrary function there?
18:17:01 <ski> it can, but if your collection is represented as a tree, then it may be more efficient to allow the traversal to follow that internal structure
18:17:06 <ski> Cale : yes
18:21:21 <andromeda-galaxy> any HS performance wizards around?
18:23:27 <Cale> andromeda-galaxy: How are you measuring?
18:34:51 <andromeda-galaxy> Cale: criterion
18:35:46 <andromeda-galaxy> specifically, criterion running on a linux machine on a dedicated cpu core without almost anything else running (excluding kworkers, ~26 processes)
18:35:57 <Cale> hm
18:36:12 <Cale> Have you looked at the core for the programs you're comparing?
18:36:50 <andromeda-galaxy> Hmm, I haven't yet
18:37:23 <andromeda-galaxy> (the benchmarkign setup is my main workstation rebooted into a relatively stripped down environment, which makes doing that sort of thing somewhat annoying)
18:38:12 <andromeda-galaxy> Cale: what method of getting core would you suggest?
18:38:20 <Cale> -ddump-simpl ?
18:38:34 <Cale> There are some options for writing it to files instead
18:38:38 <andromeda-galaxy> IIRC -ddump-simple just gave me the application of map, with all type variables explicitly applied, last time I tried it
18:38:59 <andromeda-galaxy> Let me reboot my computer and try again quickly.  thanks for looking into this!
18:43:27 <andromeda-galaxy> Cale: the core is looking kind of incomprehensible to me...
18:43:58 <andromeda-galaxy> (I've used Core before, but never on anything this large)
18:44:00 <Cale> but the important thing is how similar it is between the program implemented one way vs. the other.
18:44:04 <andromeda-galaxy> record updates sare producing something...interesting
18:44:34 <andromeda-galaxy> Cale: the important bit seems to be this:
18:45:54 <andromeda-galaxy> (map @ (Type1 e1 n1) @ (Type1 e1 n1) (updateIndex_aeTK newID_aeTQ) (case wild_X6i of _ [Occ=Dead] { <data structure> -> value }))
18:46:16 <andromeda-galaxy> Cale: wild_X6i is the same thing that followed the 'of' in the original case that is generated from the record update
18:46:37 <andromeda-galaxy> Cale: any idea what that means for performance and/or how to make it faster?
18:47:58 <Cale> andromeda-galaxy: Wait, didn't you say the list was a simple empty list?
18:48:12 <Cale> What's that case expression?
18:50:02 <andromeda-galaxy> Cale: the list is an empty list
18:50:16 <Cale> ah, once it's evaluated?
18:50:27 <andromeda-galaxy> Cale: it is part of the record that the record update is updating (the source looks like _property = _property rcd)
18:50:44 <andromeda-galaxy> I think that's right
18:50:54 <andromeda-galaxy> the case is, as far as I can tell, how it gets the value out of the record
18:50:59 <Cale> ah, so it's a record selector yeah
18:51:19 <andromeda-galaxy> (in core, the record update seems to generate a case as well, by the way, do you know why it generates a case for each property access and a case at the beginning o fthe update?)
18:51:40 <andromeda-galaxy> Cale: right
18:51:41 <Cale> case is fundamentally what controls evaluation in core
18:52:08 <Cale> You'll get a case whenever anything is evaluated or pattern matched on
18:52:22 <andromeda-galaxy> ahh, right that begins to make sense.
18:52:47 <andromeda-galaxy> thanks for the explanation! any ideas about the performance problems?
18:53:16 <andromeda-galaxy> the rest of the ufnctoin consists of a large record update that includes an IntMap.insert and a bunch of other values that were taken out of the record earlier; the resulting record is then put into a state monad.
18:53:31 <andromeda-galaxy> that seems to me like it should be a lot more than 2x as much work as mapping over a (at runtime) empty list
18:53:38 <Cale> I dunno, how do the two bits of code differ?
18:53:59 <andromeda-galaxy> it's literally that one of them has the '_attr = map id _attr' line and the other doesn't
18:54:23 <andromeda-galaxy> (in fact, the performance measurements were made by commenting out the update line and uncommenting it)
18:54:53 <andromeda-galaxy> I'm not seeing anything that points to a nother difference in the genreated Core either
18:54:56 <Cale> and that field is later evaluated?
18:55:22 <Cale> map id isn't entirely free (it should be very cheap if the list turns out to be empty...)
18:55:24 <andromeda-galaxy> It should be eventually, since I 'm using criterion's 'nf' to evalulate everything to normal form
18:55:39 <andromeda-galaxy> I know it's not free, I'd just expect it to be a lot cheaper than that...
18:56:08 <Cale> How much does it appear to cost?
18:56:31 <andromeda-galaxy> ~1s for ~200000 invocations
18:56:43 <benjic> Is there a resource that explains the reason for namespacing module names with Data, ie Data.List?
18:57:15 <Cale> andromeda-galaxy: That's 5 microseconds
18:58:06 <andromeda-galaxy> that's true, it is (absolutely) very little.  I'm just confused because an intmap.insert + a whole lot more memory accesses only takes ~1.8 seconds for th esame number
18:58:10 <Cale> benjic: Basically people lost their damn minds when Haskell gained the ability to put '.' in module names.
18:58:27 <Cale> benjic: and then other people copied the convention
18:59:20 <Adeon> next...I want to use / in module names
18:59:55 <sleblanc> benjic, tongue-in-cheek answer: because everything is data; it's data all the way down.
19:00:06 <andromeda-galaxy> Cale: also, and more confusingly: map id attr is faster than map <other function> attr
19:00:28 * ski . o O ( `RULES' ? )
19:00:29 <Cale> andromeda-galaxy: Yeah, that's what I actually wanted to hear more about ;)
19:00:40 <Cale> Oh, yeah, maybe RULES?
19:00:44 <andromeda-galaxy> Cale: the Core bear out that the only difference between the two is (id @<type>) versus <function>
19:00:53 <andromeda-galaxy> that's the one that was  really puzzling me
19:00:58 <Cale> huh...
19:03:07 <Cale> andromeda-galaxy: oh, what's the type of the other function?
19:03:24 <Cale> Is it polymorphic?
19:04:11 <andromeda-galaxy> Cale: Int -> <thing in list> -> <thing in list>
19:04:21 <Cale> Well, I guess it couldn't be type class polymorphic in a way that would matter -- that difference would be apparent
19:04:25 <andromeda-galaxy> it is actually partially applied, I just realized that, tha tmight explain it
19:04:57 <Cale> and you're definitely not, e.g. case-evaluating the function beforehand or something funny like that?
19:05:08 <monochrom> yes, creating a thunk for a partial application costs a little bit
19:05:18 <andromeda-galaxy> case-evaluating?
19:05:36 <Cale> Well, every case in Core evaluates its scrutinee
19:05:43 <monochrom> you may want to get down to Cmm
19:05:55 <andromeda-galaxy> ah, right.  no, I don't think so
19:06:01 <Cale> Yeah, perhaps that would be clearer if there are no big differences in the core
19:06:48 <andromeda-galaxy> ...
19:07:23 <jdt> newb question: if I want just a "TimeZone", but a function returns "IO TimeZone", how do I reconcile that?
19:07:32 <andromeda-galaxy> okay, that's a good idea, I forgot all about Cmm.  I can't do that right now (I'm slightly away from my main workstation), would you mind if I bring it up again in a little while?
19:07:46 <monochrom> http://www.formisimo.com/blog/wp-content/uploads/2013/05/We-need-to-go-deeper.jpg :)
19:07:47 <jdt> I see that pattern a lot - where I just want "X" but a function returns "IO X" and I can't make it work.
19:08:22 <Cale> jdt: IO String is to String what /bin/ls is to a list of files
19:08:52 <jdt> that makes sense. so I need to execute that function somehow?
19:09:10 <Cale> jdt: An "action" of type IO t, is a program which when executed, will have arbitrary effects before producing a result of type t if it completes normally
19:09:28 <Cale> do-blocks can be used to piece more complicated IO actions together from simpler ones
19:09:51 <Cale> inside a do-block, you can write  v <- x  which if x :: IO t, then v :: t, and it means "execute the action x, and name its result v"
19:10:25 <Cale> v will be available for the rest of the block, and you can pass it off to some function, e.g. for processing before doing some output or something based on the result
19:11:32 <jdt> okay - thanks Cale. That helps.
19:12:21 <Cale> jdt: In a compiled program, the IO action called main is what gets executed initially.
19:12:47 <Cale> At the GHCi prompt, if you give an IO action, it will also detect that, and execute it automatically
19:13:38 <Cale> But evaluation (the process of reducing expressions to values) never causes this execution to occur (at least, not normally, there are some low-level hooks which exist for the situation where you'd otherwise modify the compiler to get around that)
19:19:11 <danilo2> Hello guys! Will it be possible in GHC8 to inverse injective TF? So I can use it as "opposite" TF to the original one ?
19:24:23 <Enigmagic> danilo2: https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies
19:25:49 <danilo2> Enigmagic: I've read it already, but didnt found what I was asking about. (Or I missread it, but I think its just not stated there)
19:26:54 <Enigmagic> danilo2: try it out :-)
19:29:00 <danilo2> Enigmagic: I think what I've written what I want not clear enough. I cannot try it, because it will need a special kind of syntax. LEts say I want a TF like "Focus t a" where `t` determines a type of what I want to focus on type a. I would like to use it like type-lenses, so I could not only access the result, but also modify it. Example:
19:30:30 <danilo2> Enigmagic: data Cover l a = Cover l a; data Covered; type instance Focus Covered (Cover l a) = a;   and now I would like to do something like   `Inv Covered` which would allow me to update the `a` type variable on `given `Cover l a` to something else
19:30:48 <danilo2> Enigmagic: I think the example is much more clear thean eny previous description
19:30:54 <geekosaur> isn't the whole point of injective type families that ghc can infer the reverse relationship?
19:31:23 <danilo2> geekosaur: I don't want it only to be inferred! I want to use this information to update some type variables using some inverted TF
19:33:48 <ski> danilo2 : what should the kind of `Inv Covered' be ? `*' ?
19:34:47 <ski> given `t', which is being passed as `Cover l a', do you want to be able to return `Cover l (f a)', for a given `f' ?
19:35:14 <danilo2> ski: I dont know to be honest with you. I see few potential solutions here, I'm just asking if somebody was thinking about it
19:35:37 <danilo2> ski: exactly thats what I want
19:35:40 <shergill> so i've only ever had single test modules for my haskell packages. what's the standard way to break down your test suite into modules?
19:37:19 <danilo2> ski: that would give us some amazin g features, consider this:  `type instance View Covered  (Cover c a) = a; type instance Set Covered v (Cover c a) = Cover c v; class Covers c b where covered :: Lens c (Set Covered a c) (View Covered c) a` - This emulates the behavior I want using View and Set type families - look how greatly type inference works when you use the covered function
19:37:28 <ski> danilo2 : which is the TF that would be injective here ?
19:37:51 <danilo2> ski: the `Focus t a`
19:38:21 <ski> injective in which argument ? jointly injective ?
19:40:47 <danilo2> ski: it has following injectivity rules (if we name the result "out"): t a -> out
19:40:50 * ski idly wonders how injectivity interacts with currying here
19:41:46 <ski> `t a -> out' makes no sense to me in this context
19:42:22 <ski> (is `t :: * -> *' here the case ? where did `out' come from ?)
19:45:09 <danilo2> ski: no, `t :: *` it's a phantom type which together with another type gives us information what type variable we want to access. Like above, the example `t` was `Covered` declared as `data Covered`. Then `type instance Focus Covered (Cover c a) = a`
19:46:59 <danilo2> ski: then we could use the inverse version to update the `a` parameter. Something like :  `Focus Covered (Cover Int String) .~ Char` using lens-like type syntax
19:47:26 <danilo2> which will give us `Cover Int Char`
19:47:57 <danilo2> ski: think about `Focus t` like about type-level lens
19:50:19 <haskell939> Hi, I am a newbie for haskell. I could not find a proper way of writing functions is it possible if I write a simple method in Java and someone can tell me it's equivalent for Haskell?
19:51:26 <danilo2> haskell939: go ahead
19:51:34 <haskell939> public List<Integer> dropFirst(List<Integer> intList, Integer numToDrop) {
19:51:59 <danilo2> haskell939: and read the book : learn you haskell for great god
19:52:55 <haskell939> for (int i= 0; i < intList.length; i++) { if (intList.at(i) == numToDrop) { intList.remove(i); break;} }
19:52:59 <haskell939> return intList; }
19:53:30 <haskell939> that's it
19:53:40 <andromeda-galaxy> haskell939: dropFirst = flip take?
19:53:54 <haskell939> huh?
19:54:06 <andromeda-galaxy> wait never mind, sorry
19:54:10 <andromeda-galaxy> I misunderstood a bit of your method
19:55:40 <ggVGc> is it more difficult implementing a lazy than a strict language?
19:55:48 <ski> danilo2 : then `t a' is a kind error
19:55:48 <ggVGc> i.e is the runtime system more complicated?
19:56:11 <andromeda-galaxy> haskell939: dropFirst = flip delete should do what you want if I'm understanding properly here
19:56:13 <danilo2> ski: I've written `t a` in the notion of functional dependencies
19:56:26 <haskell939> but I want to make it a function
19:56:35 <haskell939> how do I wrap it around a function
19:56:39 <danilo2> ski: so if you've got both `t` and `a` you infer `out`
19:56:53 <haskell939> I found that remo :: Eq a => a -> [a] -> [a] can do
19:56:54 <andromeda-galaxy> haskell939: in Haskell, functions are first-class values, and are curried by default, so 'flip delete' is a function which is delete with the arguments reversed, and 'dropFirst =' assigns the name 'dropFirst' to that
19:57:08 <haskell939> but if I put that in my hugs then I get an error
19:57:22 <haskell939> ERROR - Syntax error in expression (unexpected end of input)
19:57:22 <ski> andromeda-galaxy : `delete'
19:57:23 <andromeda-galaxy> haskell939: I am not aware of that function defined in the standard libraries...
19:57:37 <haskell939> no no I meant that function to wrap the library function
19:57:42 <andromeda-galaxy> ski: sorry?
19:57:44 <haskell939> I define that function
19:57:55 <andromeda-galaxy> haskell939: okay, what do you have as the definition?
19:57:55 <Tehnix> haskell939: okay, what do you have as the definition?
19:57:55 <Tehnix_> haskell939: okay, what do you have as the definition?
19:57:56 <Tehnix> haskell939: okay, what do you have as the definition?
19:57:57 <Tehnix_> haskell939: okay, what do you have as the definition?
19:57:57 <Tehnix> haskell939: okay, what do you have as the definition?
19:57:57 <Tehnix_> haskell939: okay, what do you have as the definition?
19:57:57 <Tehnix_> haskell939: okay, what do you have as the definition?
19:58:08 <ski> > delete 5 [2,3,5,7]
19:58:10 <lambdabot>  [2,3,7]
19:58:23 <ski> > delete 'b' "abacabad"
19:58:25 <lambdabot>  "aacabad"
19:58:27 <danilo2> haskell939: you want something like dropFirst lst num = fmap fst $ filter snd $ zip lst $ (== num) <$> lst
19:59:11 <danilo2> haskell939: ah, my version deletes all numbers, ski's one the first one
19:59:19 <ski> danilo2 : oh, functional dependencies. that's something else
19:59:28 <haskell939> Hugs> let dropFirst lst num = fmap fst $ filter snd $ zip lst $ (== num) <$> lst ERROR - Syntax error in expression (unexpected end of input)
19:59:41 <danilo2> ski: doesnt injective type families havve the same syntax as fundeps?
20:00:11 <danilo2> haskell939: use ghc, not hugs if you can
20:00:41 <ski> haskell939 : "but if I put that in my hugs then I get an error" -- define things in a source file, then load that into your interactor
20:00:50 <andromeda-galaxy> ski: he's using let
20:01:02 <sekrit> andromeda-galaxy: sorry about that, bot seemed to include you in that
20:01:10 <ski> andromeda-galaxy : they're using HuGS, which doesn't have that `let' thing
20:01:15 <andromeda-galaxy> haskell939: hugs is old and unmaintained and doesn't support a bunch of syntax, it might be a good idea to try GHCi instead
20:01:21 <andromeda-galaxy> (ski: hence the next suggestion to use GHCi)
20:01:38 <andromeda-galaxy> sekrit: what happened?
20:01:52 <andromeda-galaxy> I wasn't sure if it was a client failure on my side...
20:02:05 <sekrit> andromeda-galaxy: some user named Tehnix parroted what you said several times
20:02:27 <sekrit> and the bot added it as a pattern and got all 3 nicks
20:02:31 <ski> danilo2 : "doesnt injective type families havve the same syntax as fundeps?" -- i don't see why they should
20:02:47 <haskell939> Prelude> let dropFirst lst num = fmap fst $ filter snd $ zip lst $ (== num) <$> lst  <interactive>:2:68: Not in scope: ‘<$>’
20:02:59 <andromeda-galaxy> sekrit: which bot? I saw the replies from Tehnix and then suddenly wasn't in the channel...
20:03:04 <danilo2> ski: https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies  -> type C families
20:03:10 <andromeda-galaxy> haskell939: ghci version?
20:03:21 <andromeda-galaxy> sorry, I only have 7.10.2 available to test on
20:03:27 <sekrit> andromeda-galaxy: our network utility bot :)
20:03:34 <danilo2> haskell939: please read this book on the begining
20:03:38 <andromeda-galaxy> sekrit: ah, okay. thanks for the explanation
20:03:41 <danilo2> haskell939: import Control.Applicative
20:04:00 <andromeda-galaxy> danilo2: on 7.10 at least, you don't need Applicative for the fmap alias
20:04:12 <haskell939> 7.8.4
20:04:19 <danilo2> andromeda-galaxy: heh ^^^
20:04:41 <haskell939> can I do without any library?
20:05:18 <andromeda-galaxy> haskell939: Control.Applicative is part of the base package, so it's not exactly an external library. it defines the infix alias.  if fmap is in scope, you can use that instead: <$> = fmap
20:05:46 <ski> danilo2 : i see. interesting. (cf. mode declarations in Mercury)
20:06:46 <haskell939> okay thanks
20:06:57 <haskell939> I also want to do value assignment
20:07:10 <haskell939> but haskell doesn't support that is that right?
20:07:14 <ski>   infixl 3 <$>
20:07:16 <ski>   (<$>) = fmap
20:07:17 <ski> rather
20:07:35 <haskell939> like val something = splitAt num lst
20:07:40 <haskell939> in the function
20:07:40 <ski> (probably also with a type signature, because DMR)
20:07:50 <ski> (er, s/3/4/)
20:08:19 <ski> haskell939 : have you used SML previously ?
20:08:28 <haskell939> no
20:08:36 <danilo2> ski: I dont know the mode delcarations in mercury, I'ld love to read about them. Anyway I'm wondering if somebody was thinking here about the inverse injective tfs, thay would be very nice
20:08:37 <haskell939> what is it?
20:08:39 <ski> there is no `val' keyword in Haskell
20:09:17 <ski> in a source file, you can say just `something = splitAt num lst'
20:09:48 <ski> (also, `=' is not assignment in Haskell. it is definition (/binding))
20:10:19 <haskell939> So I don't have to use where?
20:11:53 <ski> danilo2 : in Mercury, you can declare `:- func add(int,int) = int.' and then `:- mode add(in,in) = out is det.', and in addition `:- mode add(in,out) = in is det.'. the two mode declarations here would correspond to `x y -> z' and `x z -> y', given `Add x y = z'
20:12:22 <shergill> hm so tasty has discovery
20:12:31 <ski> haskell939 : if you want to make this definition inside the scope of some larger definition, then the usual way to do that would be to use `where' or `let'-`in'
20:13:19 <ski> danilo2 : in fact, the FDs only specify that there's at most one solution (`semidet'), while the mode declarations promise more (that there's in fact exactly one solution)
20:13:28 <danilo2> ski: oh, thats cool. I'm implementin something similar in our lang at the moment (luna-lang.org). I dont know mercury but I think I have to learn it - I just love langs with nice features :)
20:13:29 <ski> (`det')
20:14:33 <ski> danilo2 : Mercury is a very interesting language. type-wise it is quite close to Haskell,SML and the crowd. it has type classes (even multiple argument ones. but arguments must have kind `*', so no `monad' class is possible)
20:14:41 <ski> danilo2 : have you seen Prolog ?
20:15:06 <danilo2> ski: thanks for the info! Of course, I knwo Prolog, not so good as Haskell but still
20:15:38 <ski> good. there's not much resources for learning basic LP ideas, in terms of Mercury syntax, so it helps to know Prolog before
20:16:19 <ski> also knowing Prolog (especially common pitfalls) will help you understand what things the static mode and determinism system in Mercury is complaining about
20:17:44 <ski> danilo2 : there's a channel #mercury (also there's ##prolog, in case you didn't know)
20:18:52 <ski> danilo2 : "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-{09,10} at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> might also be interesting
20:18:55 <haskell939> Can someone tell me why this is wrong
20:19:07 <haskell939> remo num list = res[0]+res[1]         where         res = splitAt num list
20:20:04 <danilo2_> ski: I was suspecting that someting like #mercury exist :)
20:20:29 <andromeda-galaxy> hmm, I wonder which is cheaper, executing a map with a thunk over a record parameter that turn sout to be an empty list, or using a typeclass dispatch to switch to a version of the function that doesn't do that....
20:21:45 <ski> haskell939 : `res[0]' and `res[1]' is nonsense syntax in Haskell. use instead `(res0,res1) = splitAt num list', using `res0' and `res1' instead (or, if you must, use `res = splitAt num list' with `fst res' and `snd res')
20:22:12 <ski> haskell939 : however, `+' can't be used to join lists in Haskell. use `++'
20:23:02 <danilo2> ski: hmm, something is wrong with my internet connection at the moment. I get your link - thank you! :) I'm going get some sleep, thanks for the conversation! :)
20:23:02 <haskell939> ERROR "simple.hs":4 - Cannot infer instance
20:23:16 <ski> haskell939 : oh, and if you do that, you get basically a (partial) identity function. not much use. presumably you also wanted to *discard* the element at position `num' in `list' ?
20:23:22 <haskell939> remo num list = res0+res1         where         (res0, res1) = splitAt num list
20:23:24 <haskell939> I did this
20:23:35 <ski> haskell939 : read my second comment above
20:23:41 <haskell939> yeah I want to discard as well
20:23:54 <haskell939> but I'm just getting started
20:24:08 <ski> haskell939 : what if there is no position `num' in `list' ?
20:24:20 <ski> danilo2 : ok. have fun
20:24:43 <haskell939> actually I don't want to use splitAt anyway
20:24:52 <haskell939> I figured it's wrong thing for me
20:24:54 * ski suspected so
20:25:45 <ski> > break even [3,9,13,18,23,32,75]
20:25:47 <lambdabot>  ([3,9,13],[18,23,32,75])
20:25:47 <haskell939> what I need is dropWhile except it should not keep dropping after the first match
20:26:23 <ski> (like that ?)
20:26:32 <jdt> Cale: thanks for the advice. I'm trying to make this block render just the date (i.e., 2016-01-01) and can't seem to make sense of it: https://gist.github.com/justindthomas/cde3f0cf8036050f04e69a8197658867#file-gistfile1-txt-L19
20:26:48 <jdt> I think all the necessary context is there in that little snippet
20:27:23 <jdt> I've been trying a variety of different placements of terms and whatnot. I just haven't wrapped my head around it yet.
20:27:35 <haskell939> No like this
20:28:07 <haskell939> dropWhile 3 [4,9,5,3,2,6,4,7,3,5,2] = [4,9,5,2,6,4,7,3,5,2]
20:28:18 <haskell939> dropWhile 3 [4,9,5,3,2,6,4,7,3,5,2]
20:28:18 <Cale> jdt: Your definition of presentTime is an IO action
20:28:33 <ski> haskell939 : i thought that was what `remo' was supposed to do ?
20:28:45 <Cale> jdt: So its type is more like  presentTime :: LocalTime -> IO T.Text
20:28:54 <haskell939> yeah I know
20:29:08 <haskell939> but I want to do something that I understand
20:29:09 * ski still thinks the `break' example was relevant
20:29:19 <haskell939> that large example is too complex for me
20:29:20 <jdt> interesting. okay.
20:29:26 <ski> > break (3 ==) [4,9,5,3,2,6,4,7,3,5,2]
20:29:27 <lambdabot>  ([4,9,5],[3,2,6,4,7,3,5,2])
20:29:29 <Cale> jdt: You may wish to make the timezone an argument to presentTime rather than making it into an IO action
20:29:40 <ski> haskell939 : do you see how that could help ?
20:29:43 <haskell939> I wish I could recurse through but I think it's not that suggested for haskell
20:29:45 <Cale> jdt: Depending on where in the code you'd rather execute getCurrentTimeZone
20:29:48 <haskell939> yeah it works great
20:30:26 <ski> haskell939 : using direct recursion would also be possible, and fine (unless you're asked specifically not to do that)
20:30:39 <jdt> I did try that at first. but placing it in the 'do' block of mapV is wrong (cause I'm not mapping those actions) and placing it above that, tz didn't seem to be available where it was needed.
20:30:47 <haskell939> honestly it's like homework
20:30:53 <haskell939> not marked tho
20:31:24 <Cale> jdt: What's the type of manyWithSplices?
20:32:02 <Cale> Oh, right, that's from Heist, yeah?
20:32:11 <jdt> yep: https://hackage.haskell.org/package/heist-0.14.1.2/docs/Heist-Compiled.html
20:33:18 <haskell939> (a1,a2) = break (==3) [4,9,5,3,2,6,4,7,3,5,2]
20:33:22 <haskell939> Sorry this doesn't work
20:33:40 <ski> you need to do one more thing
20:33:44 * hackagebot GLFW 0.5.2.5 - A Haskell binding for GLFW  https://hackage.haskell.org/package/GLFW-0.5.2.5 (PaulLiu)
20:33:51 <haskell939> what is it?
20:33:52 <ski> (actually remove the item)
20:34:00 <haskell939> yeah but I get the syntax error
20:34:12 <Cale> jdt: Okay, so I think the thing to do is to go up farther in the program, and just pass the timezone down as an argument. There are some other options, but that seems like the first one to try.
20:34:15 <haskell939> ERROR - Syntax error in input (unexpected `=')
20:34:20 <ski> still
20:34:22 <ski> <ski> haskell939 : what if there is no position `num' in `list' ?
20:34:28 <ski> applies in this case as well
20:34:32 <jdt> Cale: Okay, I'll try that.
20:34:37 <ski> (if you s/position/element/)
20:34:49 <haskell939> then 2nd array is empty
20:35:04 <haskell939> it's ok because I'll be removing 1st item
20:35:07 <ski> haskell939 : to try it in HuGS, just say `break (==3) [4,9,5,3,2,6,4,7,3,5,2]'
20:35:07 <haskell939> from 2nd array
20:35:24 <haskell939> if length is 0 then I won't remove anything from 2nd list
20:35:33 <ski> or say `let (a1,a2) = break (==3) [4,9,5,3,2,6,4,7,3,5,2] in ..a1..a2..', where `..a1..a2..' should be some expression that may make use of `a1' and `a2'
20:36:32 <ski> haskell939 : if length is `0', what should happen ? (a) you don't care (b) return original list (c) something else ?
20:36:42 <haskell939> ah gotcha
20:36:44 <haskell939> let (a1,a2) = break (==3) [4,9,5,3,2,6,4,7,3,5,2] in a1++a2
20:36:45 <haskell939> this works
20:36:53 <Cale> jdt: So what's the next level up? Where does splice get used?
20:37:03 <haskell939> I don't care if length is 0
20:37:04 <ski> haskell939 : well, that just returns the input list
20:37:10 <ski> the `3' isn't removed there
20:37:29 <haskell939> I meant it works syntax wise
20:37:37 <ski> yes, right
20:38:01 <jdt> Cale: here's the full file (not updated with the time stuff I'm working on yet): https://github.com/justindthomas/blog/blob/master/src/Site.hs
20:38:16 <jdt> you can at least see the structure from that
20:38:19 <ski> haskell939 : btw, these are (single-linked) lists, they are no arrays
20:38:25 <ski> (there are also arrays in Haskell)
20:38:28 <haskell939> so I need to assign another value now to a2 that should remove the first element if lenght is >0 otherwise just assign a2
20:38:36 <jdt> I'm thinking I might need to getCurrentTimeZone in "app" ?
20:38:46 <haskell939> ok
20:38:48 <ski> haskell939 : that sounds like a plan
20:39:24 <ggVGc> is there any resource on common ways to define data to avoid using many records and/or nested records?
20:40:41 <haskell939> again just to test the syntax
20:40:43 <haskell939>  let (a1,a2) = break (==3) [4,9,5,3,2,6,4,7,3,5,2] in a3 where a3 = if(length a2 >0 ) a2 else a2 ERROR - Syntax error in expression (unexpected keyword "else")
20:41:27 <ski> haskell939 : `let (a1,a2) = break (==3) [4,9,5,3,2,6,4,7,3,5,2]; a3 = if not (null a2) then a2 else a2 in a3'
20:42:24 <haskell939> why should that be null?
20:42:31 <haskell939> it always returns a list right?
20:43:03 <Cale> jdt: Okay, so this is a little fancy -- Snap uses lots of different monads with various properties to give special access to various resources... but the last parameter to makeSnaplet is a computation of type Initializer b v v (and I guess we won't worry about what the types b and v are). The important thing is that Initializer, which you can see in the docs here: https://hackage.haskell.org/package/snap-0.14.0.6/docs/
20:43:04 <Cale> Snap-Snaplet.html#t:Initializer
20:43:06 <Cale> oops
20:43:10 <Cale> https://hackage.haskell.org/package/snap-0.14.0.6/docs/Snap-Snaplet.html#t:Initializer
20:43:24 <Cale> is an instance of a bunch of things including MonadIO
20:44:08 <Axman6> haskell939: null in haskell means the list is empty or not
20:44:09 <ski> haskell939 : `a2' (and `a1') here is always a list. `null' checks whether a list is the empty list
20:44:10 <Axman6> > null []
20:44:12 <lambdabot>  True
20:44:12 <Axman6> > null [1]
20:44:13 <lambdabot>  False
20:44:18 <Cale> jdt: So an Initializer b v a is something which is sort of like IO a, but with some extra capabilities of some sort related to initialising Snap
20:44:30 <ski> haskell939 : using `null' is more efficient than computing `length' of the list and then checking that
20:44:41 <haskell939> ok
20:44:50 <Cale> and MonadIO is a type class:   class Monad m => MonadIO m where liftIO :: IO a -> m a
20:45:07 <ski> haskell939 : .. however, i'd probably use `case' instead of `if' and `null' here
20:45:23 <Cale> jdt: So what this means is that we can turn any IO-action into an (Initializer b v)-action by applying liftIO to it
20:45:41 <jdt> oh, okay...
20:46:03 <Cale> jdt: So what will work is, just before the let there where hc gets defined, we can do something like   tz <- liftIO getCurrentTimeZone
20:46:58 <jdt> hot damn
20:47:12 <Cale> and that'll give us the timezone, which we can pass along to allCompiledSplices as an argument, and then we can pass it down from there
20:47:26 <jdt> yep - I already added in the stuff to pass it down.
20:47:38 <jdt> it was just the liftIO that I was missing there at the end.
20:47:40 <Cale> I don't know a whole lot about this Splice type -- there might be some fancier way to accomplish this
20:47:58 <haskell939> So if I use drop
20:47:58 <haskell939> drop 3 [] == []
20:48:04 <haskell939> I don't need to do nullcheck at all?
20:48:32 <jdt> thanks for taking a look - it compiled, so so far so good. I'll keep plugging away at it.
20:48:56 <haskell939> Main> let (a1,a2) = break (==3) [4,9,5,3,2,6,4,7,3,5,2] in a1++drop 1 a2 [4,9,5,2,6,4,7,3,5,2] Main> let (a1,a2) = break (==32) [4,9,5,3,2,6,4,7,3,5,2] in a1++drop 1 a2 [4,9,5,3,2,6,4,7,3,5,2]
20:48:59 <jdt> Is there someone named so in here? they must get a lot of pings.
20:49:05 <Cale> But yeah, that's the straightforward way that I can see without knowing much about this side of Snap (I actually use Snap all the time, but I use only a trivial part of it, because our applications are single page and the frontend is Haskell compiled to Javascript which manipulates the DOM into whatever shape we want)
20:49:39 <Cale> haha, there is
20:49:41 <jdt> It's all very new to me. I got my first bit of Snap running this week and I've been stumbling through it each evening.
20:50:05 <jdt> so far I have: https://ser.endipito.us
20:50:13 <jdt> I'm making slow progress.
20:51:24 <Cale> Interesting error
20:51:35 <jdt> ha
20:51:38 <jdt> yeah.
20:51:49 <jdt> I added the time in the database, but haven't updated the code.
20:51:51 <Cale> Looks like possibly a mismatch between what's really in your DB and what you're trying to pull out of it?
20:51:55 <Cale> ah, yeah
20:51:58 <jdt> yeah, lemme update that.
20:53:08 <jdt> I wish halcyon worked on Mac OS X
20:53:28 <jdt> that's one thing that I keep bumping in to - I get stack working right locally, but halcyon pukes when I push it to the ubuntu server.
20:53:41 <jdt> that extra "constraints" file is annoying.
20:55:14 <ski> haskell939 : yes
20:56:34 <haskell939> okay
20:56:38 <haskell939> so my function is like this now
20:56:50 <haskell939> remo num list = res0++drop 1 res1         where         (res0, res1) = break (num ==) list
20:57:07 <mightybyte> jdt: I have one side note to your conversation here about passing the time zone into your splices...
20:57:08 <haskell939> However I want to use remo :: Eq a => a -> [a] -> [a] instead of remo num list
20:57:23 <jdt> hi mightybyte 
20:57:37 <haskell939> (beccause question is asking me to write the function that way)
20:57:42 <mightybyte> jdt: Imagine for a moment that the time zone is something that the user supplies.
20:57:46 <ski> haskell939 : i don't understand the last thing you said
20:57:53 <haskell939> So the question is this
20:58:04 <haskell939> Write a function remo :: Eq a => a -> [a] -> [a] that removes from a list (second argument) the first item that matches the value of the first argument.
20:58:19 <mightybyte> jdt: That would throw a hitch in the implementation that you have now.
20:58:24 <haskell939> but my function is not declared like that
20:58:27 <jdt> true
20:58:49 <ski>   remo :: Eq a => a -> [a] -> [a]
20:58:52 <ski>   remo num list = res0 ++ drop 1 res1
20:58:56 <ski>     where
20:58:57 <ski>     (res0,res1) = break (num ==) list
20:59:03 <ski> haskell939 : where's the problem ?
20:59:12 <haskell939> hmm
20:59:20 <haskell939> I did like this
20:59:40 <haskell939> remo :: Eq a => a -> [a] -> [a] =  res0 ++ drop 1 res1 where (res0,res1) = break (num ==) list
20:59:42 <haskell939> didn't work
20:59:46 <mightybyte> jdt: Snap makes it easy for you to do that though.  All you have to do is add the time zone to the App data structure here.  https://github.com/justindthomas/blog/blob/master/src/Application.hs#L23
21:00:32 <ski> you need to name the parameters `num' and `list' in a separate "defining equation head", like `remo num list = ..num..list..'
21:00:42 <jdt> okay, cool. thanks mightybyte - I'll dig in to that.
21:00:44 <mightybyte> jdt: Then, in your initializer, instead of passing the time zone to the splice function, you would add it to the App type that is returned.
21:01:04 <jdt> that makes sense
21:01:27 <haskell939> okay
21:01:28 <jdt> Cale: that site's unbroken now. it really does work. :)
21:01:47 <mightybyte> jdt: The App can then be modified during the course of processing the request to fill in the user's time zone.
21:02:12 <jdt> so it can be taken from the user's browser or something along those lines?
21:02:34 <jdt> or maybe from a setting in a user object, I suppose.
21:02:45 <mightybyte> jdt: Your splices also have access to the App.  You'll have to change the type signature though from "C.Splice n" to "C.Splice (Handler App App)"
21:02:50 <jdt> or user record, or whatever it's called in haskell.
21:02:55 <mightybyte> jdt: Yes
21:03:07 <mightybyte> There are a variety of ways it could be obtained.
21:03:09 <jdt> nice. that makes sense.
21:03:37 <mightybyte> The key point here is that your splices have access to all the same stuff that your handlers have access to.
21:04:38 <jdt> okay, cool. I'm going to try moving that to the App data structure and see where I get.
21:04:43 <jdt> thanks for the advice!
21:05:23 <haskell939> okay
21:05:26 <mightybyte> Doing that requires changing some things around a bit.  You might have a tough time figuring it out, but I just wanted to point out that it's possibl.
21:05:27 <haskell939> so a bit more advanced question
21:05:54 <haskell939> how do I recurse through the list and then remove or add bits as I want to
21:05:56 <mightybyte> ...because that's kind of the main point of splices...to be able to get data only known at runtime into your templates.
21:05:59 <jdt> I'll muddle my way in to it and see where I und up.
21:05:59 <haskell939> I don't want to use fold or map
21:06:03 <jdt> *end
21:06:10 <tippenein> If I'm writing a scraper and I want to wait 1 second between hits, how would I accomplish this with threadDelay? is there a common looping mechanism?
21:07:00 <mightybyte> jdt: Just be warned that this in particular is pretty tricky, so don't be discouraged if you don't get it right away.
21:07:24 <jdt> oh heck, if I was easily discouraged I would have run back to the banality of Rails.
21:07:27 <pavonia> haskell939: Do you know about pattern matching?
21:07:35 <haskell939> regex?
21:07:53 <mightybyte> jdt: Web development in Haskell is generally a bit more difficult than web development in other languages because there are a lot more concepts you need to be familiar with.
21:08:01 <jdt> (no offense to Rails; it's a fine framework. :) )
21:08:11 <pavonia> haskell939: No, pattern matching in Haskell is different
21:09:03 <ski> haskell939 : depends on what you want to do specifically. however, recursion in general
21:09:09 <haskell939> No I don't
21:09:18 <ski> you don't what ?
21:09:27 <haskell939> like for instance iterate through list
21:09:29 <mightybyte> jdt: lol
21:09:39 <ski> haskell939 : doing what in each iteration ?
21:09:42 <haskell939> and if the index is between 3 to 10 (not the element itself) then remove
21:09:45 <haskell939> from the list
21:09:56 <haskell939> or not add (more functional lol)
21:11:03 <ski> > let foo lst = front ++ drop (10 - 3) back where (front,back) = splitAt 3 lst in foo "abcdefghijklmnop"
21:11:05 <lambdabot>  "abcklmnop"
21:11:33 <haskell939> but that doesn't iterate
21:11:35 <ski> haskell939 : with explicit recursion, keep a counter, and increment it
21:11:52 <haskell939> *recurse I meant
21:12:28 <pavonia> It does, but it's hidden in the definitions of splitAt/drop
21:12:47 <haskell939> yeah I want to do it on my own though
21:12:53 <haskell939> like have two functions
21:13:01 <haskell939> one wraps the other one
21:13:10 <haskell939> and the other one becomes recursive (calls itself)
21:13:51 <ski> > let foo = go 0 where go _ [] = []; go i (x:xs) | i < 3 = x : go (i+1) xs | i < 10 = go (i+1) xs | otherwise = x:xs in foo "abcdefghijklmnop"
21:13:53 <lambdabot>  "abcklmnop"
21:15:11 <haskell939> wow
21:15:17 <ski> you could also do it with two separate loops (would probably be slightly more efficient)
21:15:40 <pavonia> ski: He's obviously learning the language, why do you present the complete solution?
21:15:54 <ski> (now you check `i < 3' each time, even when `i' is greater than `4')
21:16:09 <haskell939> this looks really long
21:16:23 <haskell939> (like compared to scala)
21:17:58 <haskell939> like is it not possible to declare another function with 4 parameters, indStart, indEnd, list, currentInd
21:18:03 <ski> pavonia : they seemed to require seeing an example of what was meant by incrementing a counter, this particular example not being that important. in hindsight, perhaps i shouldn't have (i'm not sure)
21:18:19 <ski> haskell939 : it is possible
21:21:11 <haskell939> then in the function all we do is return if (currentInd > indStart && currentInd < indEnd) list[currentInd]++thisFunction(indStart,indEnd,list, currentInd++) else thisFunction(indStart,indEnd,list, currentInd++)
21:21:51 <ski> you can do it like that, yes
21:21:51 <haskell939> obviously we also need to check if currentInd < length list
21:22:16 <haskell939> okay
21:22:23 <haskell939> how do I declare a function inside of a function?
21:22:33 <ski> with `where', or `let'-`in'
21:22:50 <Cale> > (\xs -> [x | (k,x) <- zip [0..] xs, k < 3 || k > 10]) ['a'..'z']
21:22:52 <lambdabot>  "abclmnopqrstuvwxyz"
21:23:18 <Cale> If you want to operate on the indices, you should pair the elements with them first :)
21:23:35 <Cale> zip [0..] is a really handy function for doing that
21:23:55 <ski> Cale is showing the more "functional" version :)
21:24:01 <haskell939> oh
21:24:08 <haskell939> but I don't understand that stuff
21:24:14 <haskell939> like what is that \xs thing
21:24:20 <Cale> Oh, that's just a lambda
21:24:37 <Cale> > let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a'..'z']
21:24:39 <lambdabot>  "abclmnopqrstuvwxyz"
21:25:08 <haskell939> sorry I only did lambda stuff in java
21:25:10 <Cale> (\x -> y) means the function which when given x, produces y as its result
21:25:13 <haskell939> doesn't look nowhere near this
21:25:23 <Cale> e.g.
21:25:26 <Cale> > (\x -> x*x) 5
21:25:28 <lambdabot>  25
21:25:34 <haskell939> ok
21:25:35 <Cale> map (\x -> x*x) [1..10]
21:25:40 <Cale> > map (\x -> x*x) [1..10]
21:25:41 <haskell939> \xs means two vals?
21:25:42 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:25:50 <Cale> xs is just a variable name
21:25:53 <haskell939> ok
21:26:02 <ski> > map (\x -> x*x) [1 .. 10]    :: [Expr]
21:26:04 <lambdabot>  [1 * 1,2 * 2,3 * 3,4 * 4,5 * 5,6 * 6,7 * 7,8 * 8,9 * 9,10 * 10]
21:26:05 <Cale> It's conventional to give lists names which are "plural"
21:26:15 <Cale> So it's pronounced "eckses"
21:26:15 <haskell939> what's that [x | ... bit?
21:26:20 <Cale> That's a list comprehension
21:26:21 <orb> haskell939: You can declare a function inside a function like this: f x y = ... [This declares a function taking y inside a function taking x.]
21:26:51 <Cale> It says, give me the list of x such that (k,x) is an element of the list zip [0..] xs, and where k is less than 3 or k is greater than 10
21:27:04 <ski> `[x | (k,x) <- zip [0..] xs, k < 3 || k > 10]' is a list comprehension. it means : the list of all `x's, where `(k,x)' is drawn from the list `zip [0..] xs', and where `k < 3 || k > 10' holds
21:27:14 <Cale> > ['a'..'z']
21:27:17 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
21:27:21 <Cale> > zip [0..] ['a'..'z']
21:27:23 <haskell939> how do we know k is the index?
21:27:24 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h'),(8,'i'),(9,...
21:27:57 <ski> `zip' pairs together corresponding elements from two lists (stopping as soon as one of the lists stop)
21:28:02 <Cale> Because we're zipping the list [0..] of nonnegative integers, with the list of elements of our input list xs, and so each element of xs is getting paired up with its position.
21:28:12 <Cale> > [0..]
21:28:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:28:22 <Cale> Handy infinite list
21:28:27 <haskell939> ok
21:29:00 <haskell939> let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a',
21:29:21 <haskell939> let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a','z', 'b', 'c']
21:29:33 <haskell939> how come bot doesn't do my stuff
21:29:35 <ski> you need to prefix with `> ', to make lambdabot try to evaluate it
21:29:48 <haskell939> >let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a','z', 'b', 'c']
21:29:55 <Cale> the space is not optional
21:29:55 <ski> (`> ', or `@run ')
21:29:58 <Xnuk> > 1
21:30:00 <lambdabot>  1
21:30:10 <Cale> > let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a','z', 'b', 'c']
21:30:11 <lambdabot>  "azb"
21:30:22 <haskell939> >let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a','z','b','c']
21:30:35 <ski> you're still missing the space after the initial `>'
21:30:43 <haskell939> > let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a','z','b','c']
21:30:45 <lambdabot>  "azb"
21:30:46 <ski> yes
21:30:57 <haskell939> > let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ['a','z','b','c', "nonexisting", "dont show"]
21:30:58 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
21:30:59 <lambdabot>      In the expression: "nonexisting"
21:30:59 <lambdabot>      In the first argument of ‘foo’, namely ‘['a', 'z', 'b', 'c', ....]’
21:31:18 <ski> `Char's are not `String's. all elements of a list has to have the same type
21:31:26 <haskell939> > let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10] in foo ["a","z","b","c", "nonexisting", "dont show"]
21:31:28 <lambdabot>  ["a","z","b"]
21:31:40 <Xnuk> @let foo xs = [x | (k,x) <- zip [0..] xs, k < 3 || k > 10]
21:31:42 <lambdabot>  Defined.
21:31:54 <haskell939> can't I do like Object in java?
21:31:55 <Xnuk> > foo "azbc"
21:31:57 <lambdabot>  "azb"
21:32:07 <haskell939> it doesn't use the type in the list?
21:32:23 <ski> "can't I do like Object in java?" -- nope
21:32:54 <Cale> haskell939: All the elements of a list must have the same type.
21:33:02 <ski> (normally, there's no need either. if you want it, there's `Dynamic'. also existentials)
21:33:08 <haskell939> ok
21:33:40 <haskell939> Is it possible to do this
21:33:44 <haskell939> without specifying x?
21:33:54 <Cale> sure
21:34:17 <haskell939> > let foo xs = [(k) <- zip [0..] xs, k < 3 || k > 10] in foo ["a","z","b","c", "nonexisting", "dont show"]
21:34:18 <lambdabot>  <hint>:1:19:
21:34:18 <lambdabot>      parse error on input ‘<-’
21:34:18 <lambdabot>      Perhaps this statement should be within a 'do' block?
21:34:31 <haskell939> > let foo xs = [k <- zip [0..] xs, k < 3 || k > 10] in foo ["a","z","b","c", "nonexisting", "dont show"]
21:34:33 <lambdabot>  <hint>:1:17:
21:34:33 <lambdabot>      parse error on input ‘<-’
21:34:33 <lambdabot>      Perhaps this statement should be within a 'do' block?
21:34:54 <Cale> > let foo = map snd . filter ((\k -> k < 3 || k > 10) . fst) . zip [0..] in foo "abcdefghijklmnop"
21:34:55 <lambdabot>  "abclmnop"
21:35:08 <Xnuk> > let foo xs = [snd z | z <- zip [0..] xs, k<3 || k>10] in foo "AZBC"
21:35:10 <lambdabot>  "AZBC"
21:35:16 <Cale> I could also eliminate the k...
21:35:18 <haskell939> what's snd?
21:35:22 <haskell939> and fst?
21:35:23 * ski smiles at Xnuk's version
21:35:27 <ski> @src fst
21:35:27 <lambdabot> fst (x,_) = x
21:35:28 <ski> @src snd
21:35:28 <lambdabot> snd (_,y) = y
21:35:37 <Cale> fst and snd give the first and second parts of a pair
21:35:53 <haskell939> but fst is x
21:36:01 <Cale> well, sure
21:36:08 <Cale> It's what *was* x
21:36:16 <ski> that `x' is a different variable to the (previous) `x' in `foo'
21:36:18 <Cale> But I didn't give a name to x
21:36:42 <Cale> > let foo = map snd . filter (liftA2 (||) (<3) (>10) . fst) . zip [0..] in foo "abcdefghijklmnop"
21:36:43 <lambdabot>  "abclmnop"
21:36:51 <ski> (`fst' could just as well have been defined as `fst (a,b) = a')
21:36:51 <Cale> I can get rid of all the variables :)
21:37:04 <Cale> (though that's just showing off, pretty much)
21:37:33 <Cale> But roughly, that says, this foo is a composite of three functions
21:37:54 <Cale> The first to be applied to our list is zip [0..] which will pair up each element with its index
21:38:23 <Cale> then we filter the result, keeping the pairs whose first component is less than 3 or greater than 10
21:38:33 <Cale> and then we apply the function snd to all the elements of the resulting list
21:38:43 <haskell939> let foo xs = [snd z | z <- zip [0..] xs, k<3 || k>10] in foo "AZBC"
21:38:44 <haskell939> this one
21:38:46 <ski> (stripping out the index)
21:38:46 <Cale> which drops the indices, leaving only the original values
21:38:46 * hackagebot luis-client 0.0.1 - An unofficial client for the LUIS NLP service.  https://hackage.haskell.org/package/luis-client-0.0.1 (MicxjoFunkcio)
21:38:47 <haskell939> we didn't specify k
21:38:59 <Xnuk> :t k
21:39:00 <lambdabot> Expr
21:39:00 <haskell939> how does it know it's related to z
21:39:18 <ski> haskell939 : type by Xnuk
21:39:21 <ski> typo
21:39:25 <Cale> That one would be an error in anything but lambdabot -- lambdabot just happens to have a definition for k in scope
21:39:51 <Cale> (it shouldn't work)
21:39:54 <Cale> But you could write:
21:40:21 <Cale> > let foo xs = [snd z | z <- zip [0..] xs, fst z < 3 || fst z > 10] in foo "abcdefghijklmnop"
21:40:23 <lambdabot>  "abclmnop"
21:40:32 <Cale> if you really wanted to
21:40:38 <Cale> pattern matching on the pair is prettier
21:40:47 <ski> (which i assume is what Xnuk intended)
21:41:31 <lessless> Hello guys! I just started immersing into FP, just have a couple of months with Elixir and also reading about Haskell, which developers seems to be most seasoned in terms of CS (at least according to the conference talks) :) So I want to ask your opinion about  https://codewords.recurse.com/issues/six/immutability-is-not-enough 
21:43:14 <lessless> I understand that JS is not even close to functional language as it lacks pattern matching and guard closes. But in general do you think expressed concerns are happen to be or it's just a limitation of the author? Shouldn't he be able to deal with the problem with help of maybe monad? :\
21:43:30 <Cale> lessless: Well, I haven't read that, but it seems to be discussing the ways that pure functional programming on its own fails to address programs which model things which change over time. There's actually a very involved story we have about that.
21:46:45 <Cale> lessless: There are actually a large number of various libraries which help to model and describe things which change over time in various ways -- giving you operations which act on either streams of values of some sort, or time-varying values, or event streams, or many other notions -- all of which provide various sorts of pure "immutable" interfaces to things that evolve over time.
21:47:03 <Cale> One of the most successful approaches has been what's called functional reactive programming
21:47:56 <Cale> There are two basic foundational concepts of FRP for "things which change over time":
21:49:01 <Cale> You have things which always have a value, whenever you care to look at them: things like the current location of the mouse pointer, the current hitpoints of a monster, or location of the player in a world, or the current scene to be displayed on the screen.
21:49:10 <Cale> These are called behaviours.
21:49:28 <haskell939> sorry if I were to access list's element each time then it's O(n) ?
21:49:54 <Cale> Secondly, you have things which occur at particular points in time and only have a value at those times, things like the sequence of keystrokes or mouse clicks, the sequence of attacks made by a monster AI, or the sequence of sound files to play.
21:50:08 <Cale> Those are called events.
21:50:29 <ski> haskell939 : yes. don't do that
21:50:34 <ski> lessless : state is still state, even if expressed via explicit state-passing (or similar). what does helps in (e.g.) Haskell is that we're making the state-dependance *explicit*, so that it's harder to forget that something depends on the state
21:50:58 <haskell939> > [1,3,5,6,7](2)
21:50:59 <lambdabot>      Couldn't match expected type ‘Integer -> t’
21:50:59 <lambdabot>                  with actual type ‘[Integer]’
21:50:59 <lambdabot>      The function ‘[1, 3, 5, 6, ....]’ is applied to one argument,
21:51:20 <Cale> lessless: So, an FRP system will typically define events and behaviours and give you ways to stick them together to make new events and behaviours, and the library then takes care of making sure that everything is updated in a timely fashion.
21:51:48 <Cale> > [1,3..7] !! 2
21:51:49 <lambdabot>  5
21:52:01 <Cale> heh, that's not actually the same list
21:52:09 <Cale> > [1,3,5,6,7] !! 2
21:52:10 <lambdabot>  5
21:52:16 <haskell939> how do I make this array
21:52:20 <haskell939> so it's O(1) ?
21:52:21 <ski> lessless : "we are modelling a mutable object" is exactly right
21:52:35 <Cale> haskell939: There are a bunch of different array types you can use...
21:52:57 <ski> > listArray (0,4) [1,3,5,6,7] ! 2
21:52:59 <lambdabot>  5
21:53:06 <Cale> I don't know if lambdabot imports one, but you'd probably do something like  listArray (0,4) [1,3,5,6,7]
21:53:11 <Cale> ah, it does
21:53:19 <haskell939> what's 0,4 ?
21:53:25 <haskell939> is it size?
21:53:25 <ski> the index bounds
21:53:28 <Cale> The min and max index
21:53:30 <haskell939> what if I don't know that?
21:53:37 <ski> then you find out
21:53:41 <haskell939> ok
21:53:49 <Cale> You can compute the length of the list if you must
21:53:54 <haskell939> ok I see
21:53:56 <Cale> (but that's O(n) of course)
21:56:01 <mauke> constructing the array is O(n) anyway
21:56:18 <Cale> right
21:57:13 <lessless> Cale, ski thank you guys! Explicitness is one of the beautiful aspects of FP. I wish I was taught Haskell in the high school :) 
21:58:13 <Cale> lessless: So I don't know if my spiel about FRP helps at all, but we're using these ideas in reflex in production, designing the frontends of web applications in Haskell. (Haskell code which builds and manipulates the DOM is compiled to Javascript with GHCJS)
22:00:22 <Cale> lessless: I don't think effect systems really deal with the problem that this article describes, but they are an interesting take on some other problems.
22:02:22 <lessless> Cale, it's just an interesting dilemma that I want to  understand. For example - why he applying input on already created world instead of creating world with new input? 
22:02:24 <Cale> Though maybe a sufficiently sophisticated effect system could be put to work to similar ends... there's stuff like session types, which describe the communication protocol which is to occur between communicating processes, or over the network, in such a way that it becomes a type error to not send a message of the appropriate type in the right sequence.
22:03:50 <Cale> lessless: Well, you are fundamentally faced with the problem of: given the state of everything from just a moment ago, and some new user input, or a time delta, describe exactly what happens to everything to produce a new world state.
22:05:14 <Cale> Breaking that giant problem down into smaller parts can be a challenge when the state is very complicated and contains many things which are supposed to simulate interacting components.
22:05:43 <Cale> So, the key question is what should the building blocks look like, and how are we allowed to fit them together?
22:06:39 <Cale> You also get into almost philosophical discussions with questions such as "what exactly *is* time in my system, and what are its key properties?"
22:07:50 <Cale> What are the fundamental ways that we can remember things over time, so that our system is not an entirely stateless function of the present inputs?
22:08:58 * ski wonders whether there's any use for anticausality
22:09:19 <Cale> Well, surely in some systems...
22:09:54 <Cale> It's not usually a great thing to have around in systems which are meant to be vaguely real time.
22:10:12 <ski> istr some AD code which used a backwards-state monad
22:10:24 <geppettodivacin> haskell939: Have you looked at Sequence yet?
22:10:41 <ski> (geppettodivacin, probably not)
22:11:07 <geppettodivacin> If you don't know the size at the beginning, but still need O(1) access, that's a good structure.
22:13:06 <Cale> It's already easy to have definitional loops by accident -- the main remaining "I wish it were somehow possible for this to be a type error" problem we run into are places where you lose causality just for a single moment in a recursive definition and the system gets stuck.
22:13:35 <Cale> Though, I think it's something that with experience, you learn to avoid pretty quickly.
22:13:36 <geppettodivacin> haskell939: Actually, scratch that, sequence doesn't have O(1) access. My memory has failed me.
22:14:30 <Cale> (of course, it's really the halting problem in disguise in the limiting case, but we can try hard to make it difficult for you to write acausal loops)
22:15:08 <Cale> geppettodivacin: It has log access though, which is usually good enough. The main problem is that the constant factors for Sequence are a bit high.
22:15:11 <haskell939> So this is my code now
22:15:12 <haskell939> http://lpaste.net/8130743794250285056
22:15:29 <haskell939> I didn't do the array bit yet
22:15:36 <haskell939> but I get a syntax error at the if
22:15:51 <haskell939> it says unexpected
22:16:00 <Cale> yeah, return is not a keyword in Haskell, and every if expression requires a 'then' and 'else'
22:16:20 <Cale> also, ! is an infix operator, not prefix
22:16:33 <haskell939> so remove return?
22:16:38 <haskell939> and by default it returns
22:16:40 <Cale> for one...
22:16:43 <Cale> null is a function
22:16:45 <Cale> :t null
22:16:46 <lambdabot> Foldable t => t a -> Bool
22:17:00 <haskell939> oh
22:17:05 <Cale> It tests whether a list (or other Foldable data structure) is empty
22:17:14 <haskell939> what do I return then?
22:17:25 <Cale> I don't know
22:17:25 <haskell939> void?
22:17:28 <Cale> good question
22:17:43 <Cale> Apparently you want to produce a list?
22:17:48 <haskell939> yes
22:17:53 <Cale> Maybe the empty list?
22:18:05 <haskell939> but wouldn't that be
22:18:10 <haskell939> an empty list inside of a list?
22:18:34 <Cale> Well, this... I don't even know what the goal of this function is
22:18:48 <haskell939> well if index is between 1 5 then add it
22:19:45 <ski> haskell939 : there is no magic `null' value of every type in Haskell
22:19:52 <Cale> So for example,  alt "abcdefgh" = "bcdef"?
22:20:11 <haskell939> yes
22:20:22 <ski> you need brackets around `currentInt+1'
22:20:39 <Cale> and... you probably wanted to make list into an array?
22:20:47 <haskell939> yeah
22:20:51 <haskell939> I didn't do that yet
22:20:55 <ski> <haskell939> I didn't do the array bit yet
22:20:56 <haskell939> as I'm trying to get the syntax right
22:21:16 <ski> `!!' is list indexing. `!' is indexing into (immutable) arrays
22:22:00 <ski> an array solution would probably use a different approach
22:22:13 <haskell939> http://lpaste.net/8130743794250285056
22:22:20 <haskell939> okay modified like this
22:22:24 <haskell939> still it says if is unexpected
22:22:47 <haskell939> 2nd if (line 6)
22:23:05 <Cale> Yeah, because your if didn't have a then, and you're still writing the conditional for the first if
22:23:20 <haskell939> I don't want then
22:23:22 <Cale> and you put if in a place where it's not allowed...
22:23:27 <ski> you're still missing `then' and `else' for your `if's
22:23:28 <Cale> huh?
22:23:35 <Cale> Every if must have both a then and an else
22:23:38 <haskell939> I don't have else condition
22:23:45 <ski> you have
22:23:46 <pavonia> haskell939: Note that the result of a function is an expression, not a block of commands
22:23:48 <haskell939> else is to continue
22:23:50 <Cale> if expressions are expressions
22:23:56 <Cale> They have a value
22:24:09 <haskell939> so empty else?
22:24:16 <ski>   if not (length list > currentInt) then []
22:24:18 <Cale> > if 4 > 5 then "what?" else "okay"
22:24:20 <lambdabot>  "okay"
22:24:31 <ski>     else if currentInt > startInd && currentInt < endInt then list !! currentInt ++ ...
22:24:32 <Cale> You can't have an empty 'then' or 'else', both are essential.
22:24:37 <ski>       else ...
22:24:41 <haskell939> okay
22:24:51 <Cale> It doesn't make sense to have an empty 'then' or 'else'
22:24:51 <ski> haskell939 : alternatively, you can here use guards
22:24:57 <ski>   recursiveResult startInd endInd list currentInt
22:24:57 <Cale> you're constructing a value, it must be something
22:25:03 <geppettodivacin> haskell939: If you want it to fall through, put the second if in the else part.
22:25:13 <ski>     | not (length list > currentInt) = []
22:25:25 <ski>     | currentInt > startInd && currentInt < endInt = list !! currentInt ++ ...
22:25:30 <ski>     | otherwise = ...
22:25:44 <geppettodivacin> Guards are probably a better solution in this case because you can see the fall-through structure easier.
22:26:15 <Cale> Note that computing the length of the list on every iteration is extremely painful
22:26:24 <Cale> and you probably don't want to do that
22:26:45 <Cale> another problem is that list !! currentInt will be a value of type a, and not a list, so (++) is not appropriate
22:27:00 <ski> Cale : though if they're migrating to lists ..
22:27:03 <ski> er, to arrays
22:27:25 <Cale> Yeah, if you're changing to arrays, you can get easily get the bounds of an array
22:27:35 <ski> (still, `++' isn't appropriate for arrays)
22:27:37 <Cale> and test if something is in the range
22:27:44 <ski> @type inRange
22:27:45 <lambdabot> Ix a => (a, a) -> a -> Bool
22:28:05 <ski> @type inRange . bounds
22:28:06 <lambdabot> Ix a => Array a e -> a -> Bool
22:28:21 <geppettodivacin> haskell939: What do you need O(1) indexing for?
22:28:28 <haskell939> sorry now I get ! issue
22:28:37 <haskell939> it says if(!... not recognised
22:28:39 <haskell939> that !
22:28:45 <Cale> He doesn't... not for this... but I guess he wants to use indexing anyway.
22:28:56 <ski> <Cale> also, ! is an infix operator, not prefix
22:29:04 <haskell939> how do I make if not in haskell
22:29:06 <Cale> ! is array lookup
22:29:09 <haskell939> I googled there is not solution
22:29:10 <Cale> not (...)
22:29:18 <dmj> vector > array
22:29:20 <ski> "not" in Haskell is spelled `not' (surprisingly ?)
22:29:43 <haskell939> Undefined variable "endInt"
22:29:51 <Cale> You have endInd
22:29:55 <ski> haskell939 : or you could swap the `if' branches .. or invert the condition (if applicable)
22:30:03 <haskell939> oh
22:30:05 <haskell939> sorry
22:30:07 <haskell939> my bad
22:31:05 <haskell939> Type error in explicitly typed binding *** Term           : alt *** Type           : [[a]] -> [a] *** Does not match : [[a]] -> [[a]] *** Because        : unification would give infinite type
22:31:29 <ski> haskell939 : yes, because
22:31:31 <ski> <Cale> another problem is that list !! currentInt will be a value of type a, and not a list, so (++) is not appropriate
22:31:55 <Cale> Oh, you're using hugs?
22:31:58 <ski> yes
22:32:00 <haskell939> yes
22:32:07 <mniip> oh dear
22:32:15 <Cale> That's like, ancient :)
22:32:22 * ski shines
22:32:33 <haskell939> sorry my university mandates it :(
22:34:37 <haskell939> I deleted the beginning
22:34:38 <Cale> "Let's convince all our students that Haskell runs slowly by forcing them to use an interpreter whose last release was a decade ago, and which was limping along for years prior to that"
22:34:40 <haskell939> now I try this
22:34:52 <haskell939> alt [1,2,3,4,5,6,7,8]
22:34:56 <haskell939> it compiles fine
22:34:59 <haskell939> but running this
22:35:08 <haskell939> ERROR - Cannot infer instance *** Instance   : Num [a] *** Expression : alt [1,2,3,4,5,6,7,8]
22:35:31 <Cale> You deleted the type signature?
22:35:43 <Cale> What type did hugs infer for alt?
22:36:03 <ski> `alt :: [[a]] -> [[a]]', presumably ?
22:36:03 <haskell939> http://lpaste.net/8130743794250285056
22:36:10 <haskell939> it's like that now
22:36:18 <Cale> yeah, put the type signature back
22:36:25 <ski> hm, no, `[[a]] -> [a]', rather, i think
22:36:54 <ski> (effectively `concat'ing the result)
22:37:24 <Cale> Well, I think the (++) was always supposed to have been a (:)
22:37:37 <haskell939> no it doesn't work ith [[a]] -> [a]
22:37:41 <haskell939> does the same thing
22:37:54 <saurabhnanda> any stack users here who can help me with uninstalling ghci-ng? Apparently it doesn't play well with spacemacs and https://github.com/commercialhaskell/stack/issues/361 says that I can't really uninstall anything using stack. How can I get rid of ghci-ng?
22:37:59 <ski> yes, of course you get the same error when you try `alt [1,2,3,4,5,6,7,8]'
22:38:07 <haskell939> yes
22:38:16 <ski> so .. fix the problem ?
22:38:20 <haskell939> no
22:38:26 * ski blinks
22:38:27 <Cale> haskell939: [[a]] -> [a] means that it takes a list of lists of values of any type a
22:38:33 <Cale> and produces a list of values of type a
22:38:44 <haskell939> hmm
22:38:50 <Cale> because that's what the code you wrote does
22:38:54 <haskell939> no I want list as an input and a list as an output
22:38:56 <haskell939> not list of list
22:38:59 <Cale> Yeah, then tell it that
22:39:06 <ski> so don't use `++' like that, then
22:39:11 <geppettodivacin> > let f xs startInd endInd = drop startInd . take (endInd - startInd) $ xs in [0..]
22:39:12 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:39:13 <Cale> don't comment out your type signature just because it gives you a type error
22:39:13 <haskell939> okay
22:39:16 <Cale> it's trying to help you
22:39:16 <geppettodivacin> > let f xs startInd endInd = drop startInd . take (endInd - startInd) $ xs in f [0..]
22:39:18 <lambdabot>  <Int -> Int -> [Integer]>
22:39:22 <ski> again :
22:39:23 <ski> <Cale> another problem is that list !! currentInt will be a value of type a, and not a list, so (++) is not appropriate
22:39:34 <geppettodivacin> > let f xs startInd endInd = drop startInd . take (endInd - startInd) $ xs in f [0..] 1 5
22:39:35 <lambdabot>  [1,2,3]
22:39:38 <Cale> by pointing out that the code that you wrote is not a function of the type you told it that you wanted to write
22:39:41 <haskell939> okay so replacing ++ with :
22:39:43 <geppettodivacin> Meh.
22:39:59 <Cale> yeah, there are *many* *much* better ways to write this function :)
22:40:12 <tzh> haskell939: you don't happen to be going to portland state, do you? (evidently a former hugs dev teaches there)
22:40:25 <haskell939> no
22:40:41 <haskell939> it's a university in australia
22:40:50 <tzh> oh okay
22:41:20 <Axman6> haskell939: which uni?
22:41:27 <Axman6> Also, G'day
22:41:28 <haskell939> USQ
22:42:35 <haskell939> alt [1,2,3,4,5,6,7,8,9,10] [3,4,5]
22:42:38 <haskell939> ok works now!
22:42:52 <haskell939> isn't : ternary operator?
22:43:07 <ski> there is no ternary operator in Haskell
22:43:19 <haskell939> ok
22:43:20 <geppettodivacin> Not in Haskell. (:) is the list constructor.
22:43:23 <ski> or, if you like `if ... then ... else ...', is your ternary
22:43:35 <haskell939> what's the difference between ++ and : ?
22:43:45 <ski> `++' concatenates two lists together
22:43:48 <geppettodivacin> @type (++)
22:43:49 <lambdabot> [a] -> [a] -> [a]
22:43:52 <geppettodivacin> @type (:)
22:43:54 <lambdabot> a -> [a] -> [a]
22:43:54 <ski> `:' sticks a single element in front of a list
22:44:05 <haskell939> aah
22:44:10 <haskell939> I see
22:44:19 <ski> `:' is more "basic"
22:44:29 <haskell939> Okay I need to make this more efficent by using array now
22:44:34 <ski> you can "pattern-match" on `:', but not on `++'
22:44:38 <geppettodivacin> One of the nice things about type signatures is that they tell you a lot about a function before you even know what it does.
22:44:44 <ski> `++' is defined by pattern-matching on `:'
22:45:00 <ski> @src (++)
22:45:00 <lambdabot> []     ++ ys = ys
22:45:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:45:00 <lambdabot> -- OR
22:45:00 <lambdabot> xs ++ ys = foldr (:) ys xs
22:45:14 <geppettodivacin> haskell939: The function you are currently making would be no more efficient (actually less efficient) with an array.
22:45:21 <haskell939> why?
22:45:23 <geppettodivacin> Unless you need O(1) indexing later.
22:45:32 <haskell939> array index lookups are constant I thoguht?
22:45:35 <geppettodivacin> Because Haskell works very well with lists.
22:45:39 <ski> this defines `++' by two cases : (a) what to do if the first list is empty; (b) what to do if the first list is non-empty
22:45:58 <haskell939> aren't list lookups O(n) each time?
22:45:59 <mniip> yes but constructing the array is still O(n)
22:46:03 <ski> `x:xs' is a non-empty list starting with the element `x' and continuing with the list of remaining elements `xs'
22:46:07 <geppettodivacin> haskell939: To delete things from an array takes O(n) time.
22:46:16 <geppettodivacin> You've got to do this several times.
22:46:20 <haskell939> but I'm not deleting things?
22:46:32 <geppettodivacin> I thought the point was to remove certain elements.
22:46:43 <haskell939> I'm constructing a new array
22:46:44 <haskell939> and adding it
22:46:45 <Cale> geppettodivacin: He just wants to use an intermediate array to be able to index, which is insane, but okay
22:46:46 <haskell939> no?
22:47:16 <haskell939> so what's this functions runtime complexity?
22:47:17 <Cale> at least, that's what I took from it
22:47:21 <haskell939> I thought it would be O(n)
22:47:29 <haskell939> but according to you it's O(n^2)?
22:47:31 <Cale> if you're computing the length of the list on each iteration like that, it's O(n^2)
22:47:50 <geppettodivacin> I don't think you ever gave us the final version.
22:48:04 <Cale> and yeah, looking things up in a list rather than an array on each iteration will result in O(n^2) as well
22:48:23 <haskell939> http://lpaste.net/8130743794250285056
22:48:25 <haskell939> final version
22:48:48 <Cale> length tends to only be used when you don't care what the elements of a list are
22:49:08 <Cale> !! tends to only be used when the list represents an iterative process of some sort, usually when it's infinite
22:49:31 <haskell939> wouldn't the compiler think that it's the same everytime therefore would not run more than once?
22:50:01 <Cale> nope, it runs each time, the way you have it there. It doesn't just keep all the results of every function application in memory because that would mean nothing would ever be garbage collected
22:50:15 <haskell939> okay I'll extract it out
22:50:21 <haskell939> then it's linear?
22:50:36 <Cale> As long as there's a !! inside the loop, it's quadratic
22:50:51 <Cale> but if you make that a ! by converting the list to an array, it'll be linear
22:50:51 <haskell939> yeah that one
22:50:58 <Cale> Though extremely convoluted...
22:51:05 <haskell939> I thought if I make this entirely array it would be faster
22:51:09 <haskell939> someone said it will be slower
22:51:17 <Cale> Well, building the array is work too...
22:51:41 <Cale> It's probably simpler just to drop as many elements as you need to drop and then take as many elements as you need to take
22:52:11 <haskell939> sorry what do you mean by that?
22:52:18 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
22:52:20 <lambdabot>  Defined.
22:52:25 <ski> > let f startInd endInd arr = tabulate (startInd+1,endInd-1) (arr !) in f 1 5 (listArray (0,9) [1,2,3,4,5,6,7,8,9,10])
22:52:26 <lambdabot>  array (2,4) [(2,3),(3,4),(4,5)]
22:52:34 <Cale> I mean  alt list = take 5 (drop 1 list)
22:52:58 <Cale> > take 5 (drop 1 "abcdefghijklmn")
22:52:59 <lambdabot>  "bcdef"
22:53:29 <geppettodivacin> ^ That works in O(n) time, which is at least as fast as the array version would work.
22:53:41 <Cale> That's linear time as well, and doesn't involve allocating an array for the entire input
22:53:53 <Cale> Consider a case where the input list is 10000000 elements long
22:53:58 <Cale> this will still work quickly
22:54:09 <Cale> > take 5 (drop 1 [1..10000000])
22:54:11 <lambdabot>  [2,3,4,5,6]
22:54:20 <geppettodivacin> It only considers the first six elements because that's all it needs to consider.
22:54:20 <Cale> > take 5 (drop 1 [1..]) -- the list could even be infinite
22:54:22 <lambdabot>  [2,3,4,5,6]
22:54:33 <haskell939> okay
22:54:43 <Cale> Making the entire input list into an array wastes a whole bunch of memory and time
22:54:50 <ski> (a few offby1's)
22:54:56 <haskell939> I see
22:56:24 <Cale> Of course, you could be smarter about that too, and only make the part of the input list you care about into an array
22:56:40 <Cale> But if you're going to that trouble, you might as well just build a list instead of an array :P
22:57:01 <Cale> But if you were computing something else, it could definitely be worth using an intermediate array to some end.
22:57:18 <Cale> If you had to do a lot of random indexing which was relatively unpredictable
22:57:26 <Cale> then an array is great for that
22:57:39 <Cale> If you're traversing the elements in the order in which they occur, that's what lists are made for
22:58:04 <Cale> (lists are practically loops that have been frozen in time)
22:58:24 <mniip> time is a questionable concept in a lazy language
22:59:07 <Cale> Just as a loop might have zero iterations because its precondition isn't met, or might consist of a single iteration followed by another loop, a list is either empty, i.e. [], or consists of a single element followed by another list, i.e. (x:xs)
23:00:24 <Cale> You might notice a heavy emphasis placed on lists in Haskell, it's not because we necessarily use them to store much in the way of what you'd normally think of as lists (at least, if we care about performance)
23:00:43 <Cale> so much as they're an important way of structuring *control* flow
23:02:10 <Cale> Lists are popular in Haskell for much the same reason that loops are popular in imperative programs -- the underlying sort of recursion is commonly needed.
23:02:19 <geppettodivacin> haskell939: Are you using Haskell for a class or learning for fun?
23:02:43 <Cale> He's using it for a class, and they're forcing him to use hugs :S
23:03:03 <scshunt> aww :(
23:03:06 * scshunt hugs haskell939
23:03:12 <mniip> forcible hugs are no fun
23:04:07 <geppettodivacin> I had a class last semester where we had to use Haskell for one project in the entire semester to learn about pure functional languages.
23:04:35 <geppettodivacin> Most people struggled with learning it that quickly. It's weird when you've got to switch paradigms quickly and for a short time.
23:04:58 <geppettodivacin> I was fortunate enough to have already had some experience with it.
23:05:14 * quchen is puzzled by how the introduction of new language extensions makes people go back to Hugs
23:07:33 <geppettodivacin> haskell939: You might want to do some reading on the basics of Haskell, because it'll help you to write code that looks like what you mean for it to do.
23:08:18 <geppettodivacin> I've been told that Learn You a Haskell for Great Good isn't great, but it's not intimidating and it's got some good examples of how to use a lot of the standard functionality.
23:08:29 <geppettodivacin> The earlier chapters are better than the later ones, though.
23:08:48 <geppettodivacin> And I'm sure that other people could probably suggest better resources.
23:11:46 <geppettodivacin> Just don't get scared by Haskell. It can do lots of very useful things in very short, descriptive, and elegant ways.
23:12:27 <geppettodivacin> And with that, I bid you all good night! (Or good afternoon, to those in Australia.)
23:40:26 <haskell939> hey
23:40:28 <haskell939> maxList :: Ord a => [a] -> a maxList list = findMaxNumInList list 1 5
23:40:39 <haskell939> this gives me Inferred type is not general enough
23:40:47 <haskell939> how do I make it specific?
23:41:00 <haskell939> or the other way around
23:43:36 <oherrala> what's the type of findMaxNumInList?
23:44:30 <oherrala> you return Ord a => a where a is the type what findMaxNumInList returns
23:45:45 <haskell939> what do you mean
23:45:59 <haskell939> it returns integer
23:46:06 <haskell939> like this
23:46:15 <haskell939> 		if (currentInd == length list) then maxValSoFar
23:47:58 <haskell939> Anyway it seems like working fine
23:52:04 <haskell939> I have a function like this
23:52:05 <haskell939> http://lpaste.net/8515638946338701312
23:52:11 <haskell939> but I want to simplify the else bit
23:52:16 <haskell939> http://lpaste.net/7733534326679142400
23:52:20 <haskell939> so I did like this 
23:52:25 <haskell939> but that gives an error
23:52:34 <scshunt> haskell939: what's the error?
23:52:37 <haskell939> *** Term           : findMaxNumInList *** Type           : [a -> b] -> Int -> a -> a *** Does not match : [a -> b] -> Int -> (c -> c -> c) -> b -> a *** Because        : unification would give infinite type
23:53:05 <mniip> well that's an awful way to iterate a list
23:53:19 <haskell939> oh
23:53:33 <haskell939> it's a homework and specifically asks to write a recursive function
23:53:40 <mniip> right
23:53:53 <haskell939> I'm not marked for the beauty of code but I still wanna make it read better
23:54:09 <mniip> the awful way is that you're iterating over the index
23:54:15 <scshunt> haskell939: ok so the first issue is simple: you need brackets around getMaxVal ((list !! currentInd) maxValSoFar). 
23:54:43 <scshunt> the way you have it written, both getMaxVal and ((list !! currentInd) maxValSoFar) are arguments to findMaxNumInList
23:54:57 <scshunt> the bigger issue is that you should be recursing structurally on the list
23:55:35 <haskell939> scshunt: that gives *** Term           : findMaxNumInList *** Type           : [a -> b] -> Int -> a -> a *** Does not match : [a -> b] -> Int -> (c -> c -> c) -> b -> a *** Because        : unification would give infinite type 
23:56:44 <haskell939> I changed it like this else findMaxNumInList list (currentInd+1) (getMaxVal((list !! currentInd) maxValSoFar)) FYI
23:57:14 <zRecursive> erikd: After using "ghci -lmsvcr100", `:m + System.Time` => Could not find module System.Time\n     Perhaps you meant\n   System.CPUTime (from base-4.8.2.0)\n System.Cmd (from process-1.2.3.0@proce_Ajz0vYuNBfwAXXdL8w1ZF3)\n  System.Mem (from base-4.8.2.0) ?
23:59:05 <cocreature> where do people usually put their arbitrary instances? I currently have them as orphans in my test suite but I don’t really like orphans. on the other hand I also don’t want to make my main package depend on quickcheck
23:59:53 <Clint> i also do orphans in the testsuite
