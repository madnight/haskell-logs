00:19:32 <martinvlk> > 1 + 1
00:19:34 <lambdabot>  2
01:35:39 * hackagebot jukebox 0.2.6 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.6 (NickSmallbone)
01:40:39 * hackagebot cpphs 1.20.1 - A liberalised re-implementation of cpp, the C pre-processor.  https://hackage.haskell.org/package/cpphs-1.20.1 (MalcolmWallace)
01:48:50 <inerkick> Hi.. Trying to learn basics of Haskell and had a small question. In the code here http://lpaste.net/153997 I am not able to get how to output all the putStrLn expressions I wrote.. I only know how to get one statement. How to get all? Please help . Correct me if I'm doing anything wrong in the code
01:51:37 <lpaste> quicksilver annotated “Testing Haskell” with “Testing Haskell (annotation)” at http://lpaste.net/153997#a153999
01:51:47 <quicksilver> inerkick: annotated your paste with an example
01:52:09 <quicksilver> b asically use "do" and put one statement per line
01:52:11 <quicksilver> is the answer
01:53:41 <inerkick> ok
01:54:26 <inerkick> Thank you so much quicksilver .. You guys are amazing ..
01:55:23 <inerkick> Just one quick question. How much should be the spacing between two constructs/code branch
01:55:35 <dramforever> inerkick: anything
01:55:56 <dramforever> as long as they line up, and they are indented past the definition
01:56:01 <inerkick> ok. I used to get "Warning: Tab character" so was wondering
01:56:06 <dramforever> (or whatever...)
01:56:15 * dramforever takes it back
01:57:13 <dramforever> inerkick: different people have different tabstops. Haskell requires code to line up.
01:57:37 <inerkick> ok. Thank you dramforever 
01:58:12 <dramforever> FYI https://en.wikibooks.org/wiki/Haskell/Indentation
01:58:38 <dramforever> also FYI do notation is just syntax sugar. It desugars into stuffs that you will learn later
01:58:43 <inerkick> thank you
01:59:41 <dramforever> So the sequencing is not a language feature; it's a library function
02:00:30 <inerkick> I'm just learning now, not so well aware of every technical terminologies. Just tried "happylearnhaskelltutorial" while I flip back and forth LYHGG and RWH. So thanks for sharing this source, dramforever 
02:01:11 <dramforever> :) you're welcome
02:01:14 <quchen> Is there (Word32, Word32) -> Word64 somewhere?
02:01:34 <quchen> Other than a + shiftL 32 b
02:04:22 * dramforever Found this, maybe copy it? http://haddock.stackage.org/lts-5.5/random-source-0.3.0.6/src/Data-Random-Internal-Words.html#buildWord64%27%27
02:20:40 * hackagebot webapi 0.2.0.0 - WAI based library for web api  https://hackage.haskell.org/package/webapi-0.2.0.0 (ersran9)
02:25:41 * hackagebot jukebox 0.2.7 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.7 (NickSmallbone)
02:28:52 <asd1> anyone here knows how to use llvm-general?
02:29:08 <asd1> http://lpaste.net/665222419048300544
02:29:49 <asd1> basically the code that I'm trying to generate gets reduced...
02:30:39 <asd1> Is there a way to prevent that?
02:40:31 <eigen_> Can someone suggest me a computationally stable method for calculating the inverse of a matrix.
02:40:48 <eigen_> PS: Not specific to haskell, a general numerical method
02:41:24 <eigen_> The stability is in terms of precision
02:45:23 <lieven> eigen_: are you sure you need the inverse? it's not a common problem in numerics since solving systems even for a few right hand sides simultaneously is faster than inverting
02:46:47 <eigen_> lieven: Yes lieven, I do not need to solve a linear system. I explicitly need the inverse of the matrix 
02:48:05 <lieven> numerically solve for each of the n vectors e_i=(\delta_ij) simultaneously
02:50:04 <eigen_> lieven: Got it, but the problem is the norm of the matrix is quite large, and the matrix is nowhere close to a sparse matrix. I am not much worried of the  time taken by the method, just the results should be precise.
02:51:23 <lieven> if the condition number is high, the problem is inherently ill posed
02:51:53 <eigen_> Oh yes sorry for framing it wrong.
02:52:09 <lieven> If you do this by a reasonable method like Gauss with pivoting you're ok re stability
02:53:10 <eigen_> lieven: Thanks, then I would go ahead with it. Gaussian method with pivoting.
02:55:31 <asd1> I'm not even sure if the problem is at the haskell bindings level or in the llvm api ;P
02:55:56 <asd1> But am i wierd to expect that to just generate the code?
02:56:05 <asd1> Without any optimizations?
03:19:28 <Forgetaboutit> hi #haskell, how would I do efficient custom escaping on Data.Text?
03:20:06 <Forgetaboutit> I need to replace certain chars in Text with one or two chars
03:20:07 <seishun> what's the most maintained package that provides perl-style regexes?
03:26:14 <Maxdamantus> Maintained as in correct enough that the only maintenance required is minimal, or maintained as in full of bugs that are constantly being fixed?
03:28:59 <seishun> either is better than unmaintained as in full of bugs that aren't being fixed
03:31:03 <asd1> seishun: http://conscientiousprogrammer.com/blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/
03:31:12 <asd1> this may be of interest to you.
03:32:07 <seishun> pcre-heavy doesn't seem to work on windows
03:33:08 <asd1> I guess "don't use windows" is not a solution for you?
03:33:19 <seishun> of course not
03:33:38 <seishun> regex-pcre-builtin seems to work fine
03:37:07 <pavonia> Forgetaboutit: You probably can't get more efficient than the functions provided by the text package because of the internal encoding
03:39:33 <Forgetaboutit> pavonia: That's what I thought too.  I'd love to use Data.Text.map to just swap the escaped chars.  Unfortunately, `map' only allows to swap single chars.  In my case, I have to swap single chars with two.  I couldn't find a function to do arbitrary replacements yet.
03:39:43 <puregreen> Forgetaboutit: use concatMap
03:39:59 <puregreen> concatMap :: (Char -> Text) -> Text -> Text
03:40:17 <Forgetaboutit> puregreen: Thank you! I must have been blind
04:12:20 <zoran119> hi all
04:12:42 <zoran119> was wondering if someone can tell me how can i instantiate a self-referencing type
04:12:58 <zoran119> i have a type Stream
04:13:15 <zoran119> data Stream a = Cons a (Stream a)
04:13:55 <srhb> zoran119: What does instantiate mean here?
04:14:02 <zoran119> so basically Stream is an infinite list (some of you might recongnies cis194 course here)
04:14:14 <srhb> zoran119: Create a value of that type?
04:14:20 <zoran119> srhb: yes
04:14:33 <zoran119> srhb: sorry for wrong terminology (learning haskell)
04:14:48 <srhb> zoran119: Sure, was just making sure. :) You just use the right hand side constructors, ie. the value constructors
04:14:54 <srhb> Also, confusingly, called data constructors.
04:16:00 <srhb> zoran119: For instance, b = Cons 4 b -- an infinite stream of 4
04:16:06 <zoran119> srhb: the only way i can see how to do that is this: Cons 1 (Cons 1 (Cons 1 (... infinity here ...)))
04:16:46 <srhb> zoran119: There's no requirement that the value is the same. a = Cons 4 b; b = Cons 2 a -- etc.
04:17:45 <zoran119> srhb: i'm missing the point here
04:18:09 <ent> you could also use a function to create the stream
04:18:14 <ahihi> intsFrom i = Cons i : intsFrom (i+1)
04:18:14 <ent> like normals = increasing 0; increasing n = Cons n (increasing n+1)
04:18:35 <zoran119> srhb: so one i have loaded the type into ghci, what can i type in to create a Stream value?
04:18:47 <srhb> zoran119: let b = Cons 2 b
04:19:07 <srhb> zoran119: For instance. :)
04:19:24 <zoran119> srhb: far out, that's some cool stuff
04:20:11 <zoran119> srhb: so that's like a self-referencing value ???
04:20:13 <ahihi> since it's an infinite structure, constructing any value will involve some sort of recursion
04:20:39 <zoran119> ahihi: was just thinking that...
04:21:13 <srhb> Or bottom.
04:21:29 <srhb> But then you can evaluate it. :)
04:22:13 <srhb> @let data Stream a = Cons a (Stream a)
04:22:14 <lambdabot>  .L.hs:158:1:
04:22:14 <lambdabot>      Multiple declarations of ‘Stream’
04:22:14 <lambdabot>      Declared at: .L.hs:156:1
04:22:17 <srhb> Oh, great
04:22:55 <zoran119> srhb: why didn't that work?
04:24:00 <pavonia> :t Stream
04:24:02 <lambdabot> Not in scope: data constructor ‘Stream’
04:24:30 <geekosaur> :k Stream
04:24:31 <lambdabot> * -> *
04:25:15 <pavonia> lambdabot needs :i
04:26:52 <geekosaur> or just a way to dump the current Pristine.hs to lpaste
04:27:03 <srhb> :t Cons
04:27:04 <lambdabot> a -> Stream a -> Stream a
04:27:08 <ahihi> > let f a b = Cons a (f b (a+b)); fibs = f 0 1 in fibs
04:27:10 <lambdabot>      No instance for (Show (Stream a0))
04:27:10 <lambdabot>        arising from a use of ‘show_M886142225507849392025351’
04:27:10 <lambdabot>      In the expression:
04:27:10 <srhb> zoran119: It was already defined :)
04:27:16 <ahihi> pfft
04:27:38 <EvanR> practically an infinite structure needs to be constructed with recursion but
04:27:53 <EvanR> that doesnt mean recursion is required in principle.... right
04:40:56 <shlomo> Is there a shorter way to write (\x -> \y -> x + y), (i.e. lambda expression with multiple arguments)
04:42:40 <xnyhps> > (\x y -> x + y) 1 2
04:42:41 <lambdabot>  3
04:45:33 <kev> how can I start about building a parser for core typed Lua?
04:45:57 <kev> I need an AST to perform the type checking for me.
04:46:06 <kev> How should I go about this?
04:46:56 <shlomo> xnyhps thanks
05:00:45 * hackagebot htaglib 1.0.2 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-1.0.2 (mrkkrp)
05:25:00 <pavonia> kev: If you want to build it from scratch, start with an ADT for that language
05:25:47 <pavonia> Then write a parser that build a value of that type from a string
05:33:53 <hoot> Hello all
05:45:47 * hackagebot path 0.5.4 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.5.4 (ChrisDone)
05:54:30 <roelof>  Can anyone help me improve my code : http://lpaste.net/154014
05:54:34 <roelof> Right now I use a map to convert it but in the calling function I use the whole list again to destruct it again 
05:54:37 <roelof> THat looks not right to me 
05:55:47 * hackagebot path 0.5.5 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.5.5 (ChrisDone)
05:56:58 <scshunt> roelof: what do you mean by "use the whole list again"?
05:58:29 <roelof> scshunt: at line 28 I use a map for buttons. At line 22 I use it again as variable where I destruct it on line 23
05:58:39 <pavonia> roelof: Why not converting that mapping to a Map Char Int? Then you can just map over your input string using a lookup function and concat the results
05:59:26 <scshunt> roelof: Don't think about "destructing" a variable
05:59:42 <roelof> pavonia:  Can I then also check for lower and capital letters 
06:00:04 <scshunt> In a functional programming language like Haskell, the runtime hides aspects of memory management from you
06:00:20 <osense> hello
06:00:21 <roelof> scshunt:  I have to . I have to check if a char is in the second part of the tuple 
06:00:34 <scshunt> In general, this is a good thing, because it lets you focus on the logic of your program
06:00:49 <pavonia> roelof: That check should come before the lookup
06:01:00 <scshunt> the compiler might, for instance, optimize your function in such a way that it isn't duplicating effort
06:01:16 <scshunt> I highly recommend only focusing on performance if you observe it actually being a problem
06:01:37 <scshunt> especially as you're just starting out; don't let performance concerns get in the way of writing clean code
06:02:12 <roelof> pavonia:  oke, I still do not see how your way of working must be in code, sorry 
06:04:17 <roelof> pavonia:  how does buttons look like when I do it your way ? 
06:06:22 <pavonia> roelof: You could first build a Map Char (String, Int), then for each character you do a lookup in the table which results in a Maybe (String, [Int]). If it's an uppdercase letter you prepend ("*", 1) and lookup the lowercase letter
06:06:23 <mnoonan> roelof: it sounds like you might be mixing up the ideas of deconstructing a variable (via pattern matching) vs freeing the memory associated with a variable; they don't have anything to do with one another.
06:06:45 <osense> I want to 'fold' over a foldable structure using a monoid, but I don't know how to specify which monoid instance to be use
06:07:10 <osense> (it can't be inferred, as there are multiple monoids that 'fit')
06:07:34 <pavonia> roelof: But that propably only make sense if performance matters here
06:08:08 <pavonia> osense: Lists would be a monoid that can be folded
06:08:45 <roelof> pavonia:  nope, for me it's no important to write good clean code. and my feeling says this is not good clean code 
06:09:07 <roelof> IM doing challenges from the haskell book written by bitemyapp 
06:09:17 <osense> pavonia: yes, lists are my Foldable, that is fine
06:09:32 <osense> pavonia: but I also need a monoid that will do the folding
06:09:47 <osense> pavonia: like sum or product
06:10:04 <pavonia> osense: What would you like to fold to?
06:10:47 <osense> pavonia: integers
06:11:02 <roelof> mnoonan:  nope, I try to find a good way to solve a challenge. I never learned anything about freeing memory so far 
06:11:34 <pavonia> osense: There are different monoids on integer, could you explain a bit more?
06:12:03 <osense> pavonia: exactly, there are multiple, and I don't know how to tell haskell which one it should use
06:12:53 <pavonia> > getSum $ foldr (<>) (Sum 0) $ map Sum [1,2,3]  -- as an example
06:12:55 <lambdabot>  6
06:13:21 <osense> pavonia: ah, so I can't use fold if the monoid can't be inferred?
06:13:46 <pavonia> You cannot evaluate the expressen then, no
06:14:12 <pavonia> :t foldr (<>) mempty
06:14:13 <lambdabot> (Foldable t, Monoid b) => t b -> b
06:14:50 <osense> I guess that makes sense
06:14:55 <osense> pavonia: thanks a lot :)
06:15:13 <pavonia> No problem
06:15:48 * hackagebot path 0.5.6 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.5.6 (ChrisDone)
06:16:53 <CounterPillow> zsh is the Haskell of shells in that people who use it always seem smugly superior but never get anything done.
06:19:46 <lokien> CounterPillow: what about optimizing fibonacci algorithms? are zsh people as good as we are in this?
06:19:53 <MichaelBurge> CounterPillow: And then I guess Perl is the bash of shells?
06:21:31 <srhb> I'm sure there's a much more illegible shell variant.
06:22:02 <srhb> Also: Haskell is the Haskell of shells: https://hackage.haskell.org/package/turtle :3
06:22:18 <CounterPillow> Damn it you guys don't get mad at trolls at all =(
06:24:28 <MichaelBurge> I prefer my shell to be really boring, since I have to use the same one on so many different systems. How do people work around that with shell replacements?
06:24:52 <MichaelBurge> Turtle looks especially tricky, since you'd have to install Haskell on e.g. some ancient CentOS 4 machine that you might log into
06:26:13 <srhb> MichaelBurge: Well, you obviously start by deploying nix everywhere!
06:26:21 <CounterPillow> People who use turtle probably don't log into ancient machines that they can't upgrade themselves. (Because they don't have jobs)
06:26:23 <srhb> Woops, I veered off topic.
06:28:39 <sm> anybody using Turtle, shelly or similar ?
06:29:01 <sm> turtle, I mean
06:29:10 <srhb> sm: I've used shelly once.
06:30:05 <sm> srhb: did you like it ?
06:30:42 <srhb> sm: I'm afraid to say it, but it go the thing done :-)
06:30:44 <srhb> got*
06:30:49 <srhb> I'd like to try turtle at some point.
06:30:54 <sm> that's nothing to be ashamed of !
06:31:14 <sm> we like getting things done
06:31:34 <srhb> Well, it didn't fit with the spirit of the "haskellers don't get anything done" joke :-)
06:32:30 <sm> that joke feels a bit dangerous :)
06:34:06 <sm> if we tell it enough it probably affects our thinking and we become desensitised to places where we kind of suck for getting things done
06:36:15 <djbeau> I am playing a bit with process-streaming but not as an interactive shell per se
06:36:20 <CounterPillow> https://a.uguu.se/fsdmhy.jpeg
06:37:58 <MichaelBurge> CounterPillow: I think the author of that book sold his company to Facebook shortly after
06:39:02 * sm might be able to justify adding a bit of haskell instead of php & make scripts soon.. shake and turtle seem the best candidates
06:41:05 <sbrg> lokien: lol @ fibonacci
06:41:06 <quchen> sm: Watch Neil Mitchell's talk about Shake from Haskell Exchange :-D
06:41:44 <sbrg> MichaelBurge: you could do a static build instead of installing haskell
06:41:48 <sbrg> and just transfer the binary
06:42:24 <sm> quchen: thanks
06:43:18 <MichaelBurge> sbrg: Tried it. glibc can't be truly statically compiled, although just about everything else can be.
06:43:37 <sbrg> really? huh
06:44:53 <quchen> MichaelBurge: He didn't sell the company, he sold his workforce. I don't think Facebook did anything with his product.
06:45:21 <quchen> I don't have a source though, I vaguely remember him mentioning it in a talk.
06:45:23 <sm> there's commercial tools that will make such a binary truly portable, but I forget the name
06:45:56 <MichaelBurge> quchen: That's a good point to be careful of. Facebook in particular actually does use Haskell though, so it isn't too misleading.
06:46:51 <Eduard_Munteanu> Did anyone look at setDefaultSSLOpts in curl? https://hackage.haskell.org/package/curl-1.3.8/docs/src/Network-Curl.html#curlGet
06:47:36 <Eduard_Munteanu> "the default options are pretty dire, really -- turn off the peer verification checks!"
06:48:01 * Eduard_Munteanu *clap* *clap* *clap* <slowly>
06:49:04 <MichaelBurge> sm: I'd love to know of this tool if you can remember it. I sometimes avoid recommending Haskell in favor of C for the sole reason that it's hard to deploy a binary to an older system.
06:49:28 <geekosaur> the glibc issue would bite you in C as well, or any other lnguage
06:49:43 <sm> MichaelBurge: ok, let me dig.. is was used by the darcs project at one point
06:49:44 <MichaelBurge> Yeah, but you can be assured that there's a C compileravailable  on the target machine.
06:49:54 <geekosaur> haskell by default builds and links its libraries statically, so only non-Haskell dependencies should matter
06:50:06 <geekosaur> (I should say ghc does)
06:50:10 <MichaelBurge> geekosaur: It's just glibc that's the problem.
06:50:55 <geekosaur> if you have such a hard glibc dependency that you cant link it dynamically, you may have bigger problems
06:51:14 <MichaelBurge> It's an older machine, so a newer glibc won't run on the older kernel.
06:51:42 <MichaelBurge> And it's not really me having the dependency, but ghc.
06:54:24 <MichaelBurge> geekosaur: Let me rephrase it like this. If you can get a recent(say GHC 7.8 or higher) Haskell executable running on CentOS 4 using any method at all(Docker, Nix, static linking, etc.), I'd be very interested in it
06:55:00 <geekosaur> static linking would certainly not work, for exactly the reason you said (newer glibc vs. older kernel)
06:55:09 <geekosaur> that's exactly why dynamic linking glibc
06:55:44 <Eduard_Munteanu> Submitted a bug at https://github.com/GaloisInc/curl/issues/14 but dunno if anyone still cares about that package.
06:56:16 <geekosaur> if it's relying on newer APIs not present in an older glibc, might be worth figuring out which ones. I feel like the only time I've seen issues is when glibc is linked statically though, since it will expect syscalls that may differ on the target
06:57:31 <MichaelBurge> geekosaur: You know, statically linking everything but glibc and then dynamically linking that was what worked eventually. Maybe my bad memories of the whole affair are clouding my perception of how difficult it is.
06:58:30 <geekosaur> probably. the only screw case Im aware of there is statically linking all nmon-haskell deps except glibc... which gnu ld does not want to do
06:58:52 <geekosaur> kinda hard for the haskell tooling to do what the system toolchain doesn't support
06:59:07 <MichaelBurge> I thought ghc had its own linker implementation?
06:59:19 <geekosaur> "had". because that is a nightmare
06:59:33 <geekosaur> also it was only used for ghci and TH
07:00:09 <geekosaur> seriously if you think the static lib situation was bad, you have not tried providing your own custom linker that works anywhere
07:00:20 <geekosaur> (ghc's never did, this is why ARM support has always lagged)
07:01:33 <MichaelBurge> I'm guessing it was written at a time when linkers were much simpler?
07:01:49 <MichaelBurge> Today, I'd find it hard to believe it'd even be considered an option over, say, patching an existing linker.
07:02:08 <geekosaur> well, it handles most unixy cases. it has always had odd issues on Windows, and ARM introduces all sorts of weird stuff
07:02:42 <geekosaur> and "patching an existing linker" runs into the same "for which platform?" problem. the same linker does not work reliably on linux x86, linux arm, os x, windows
07:03:22 <geekosaur> (gnu ld is a little strange on windows and often unable to handle newer dynamic link opcodes on OS X)
07:03:37 <geekosaur> (and gnu ld is not trivially patched)
07:03:44 <MichaelBurge> geekosaur: Maybe, but I would imagine you could do the work once, provide some testcases, and then the ld maintainers would do the maintenance for you.
07:04:30 <geekosaur> sure, fi they actually did. ghc devs have had a bug report WITH PATCH about table sizes open against gnu ld for several years
07:04:47 <Eduard_Munteanu> Is "gold" or any of the alternatives better in those regards?
07:04:50 <sm> MichaelBurge: Ermine was the tool. I see there's a free alternative too. http://superuser.com/questions/593332/which-tools-can-wrapper-up-a-linux-binary-with-all-its-dependencies-to-be-used-o/593564#593564
07:05:20 <geekosaur> gold is ELF only, so useless on Windows or OS X
07:05:49 * hackagebot language-c-quote 0.11.4.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.4.1 (GeoffreyMainland)
07:07:57 <MichaelBurge> geekosaur: That linker situation does sound pretty gnarly. I'm glad I don't have to work with it.
07:14:26 <sbrg> anyone happen to know if the ghcjs template for stack is broken? it's not able to find ghcjs-base as a dependency
07:50:56 <adamCS> anyone around with any generics-sop experience?
07:51:30 <iliastsi> w
07:54:59 <spaceships> is there a clever way to simulate algebraic data types in c?
07:55:47 <xa0> make a language in it, for one
07:55:51 * hackagebot fit 0.5.2 - FIT file decoder  https://hackage.haskell.org/package/fit-0.5.2 (mgiles)
07:57:59 <aweinstock> spaceships: structs correspond to products, and unions correspond to sums
07:58:00 <xa0> by that i mean, structs as product types and unions as sum types, with each "value" in a product with a type var
07:58:11 <xa0> yeah that
07:59:52 <aweinstock> spaceships: enum either_tag { Left, Right }; struct either_string_int { enum either_tag tag; union { char* left, int right}; };
08:00:34 <spaceships> aweinstock: cool. thanks
08:00:47 <spaceships> xa0: thanks
08:01:48 <WarDaft> If I unsafeCoerce a String into an Int, and have no other references to the String aside from the one that's now an Int, does the rest of the string get GC'd?
08:02:33 <aweinstock> struct either_string_int bind_either_string_int(struct either_string_int x, struct either_string_int (*f)(int)) { switch(x.tag) { case Left: return x; case Right: return (*f)(x.right); } } // this should work, maybe?
08:03:18 <aweinstock> much less elegant than: {Left x >>= _ = Left x; Right x >>= f = f x}
08:03:35 <aweinstock> and specialized to (Either String Int) at that
08:03:51 <spaceships> aweinstock: yeah definitely, but still probably cleaner than a mess of an array with special indexer functions
08:04:39 <aweinstock> WarDaft: Int is still boxed, so I'd guess it'd still be kept (I'm not a ghc innards expert)
08:06:01 <ski> sum types correspond to disjoint/discriminated union / variant record types. so in C, a tag (probably an `enum') together with a `union'. possibly bundled inside a `struct'
08:06:32 <spaceships> i have a bunch of values that have indices with different numbers of parameters. in haskell it was easy to make a ADT to represent the index, and use it as a key to a map. not sure how im going to do it in c, but i think i'll try the struct/enum trick first.
08:06:33 <ski> ("variant record" is the name used in Pascal and Ada)
08:08:07 <aweinstock> WarDaft: in GHC.Types, Int is defined as (I# Int#), and strings are (data [] a = [] | a : [a]), so if you have a non-empty string, the first cell would still be kept, but the GC probably won't traverse the tail
08:08:20 <aweinstock> so the first element won't be collected, but the rest might be?
08:09:44 <aweinstock> WarDaft: if I'm right, I'd expect that {creating a long string >> coercing it to int >> creating a ton of objects >> coercing it back to a string >> printing it} would get the first letter right, and segfault/print garbage part of the way into the thing
08:10:10 <aweinstock> (so if you want, you could write that program and run it with a few different parameters to see what happens)
08:15:42 <craptalk> hey people
08:15:59 <craptalk> whats the topic down here?
08:19:54 <EvanR> Haskell craptalk 
08:22:49 <saml> f :: AllUpperCaseString -> String       how can I define type AllUpperCaseString so that it is String but when user constructs it, it's guaranteed that it is all uppercase?
08:23:57 <mauke> newtype AllUpperCaseString = AUC String
08:24:05 <mauke> in a separate module, and don't export AUC
08:24:28 <mauke> instead export a function ("smart constructor") that checks its input for lowercase letters
08:24:46 <saml> ah nice  thanks
08:25:45 <saml> how would I use AllUpperCaseString when i'm defining f  outside the module?
08:25:54 <saml> let me actually try and  see
08:26:31 <EvanR> export AllUpperCaseString but not AUC
08:30:35 <lpaste> saml pasted “phantom type ” at http://lpaste.net/154027
08:31:08 <saml> I can't really use AllUpperCasedString as String
08:31:10 <lyxia> it's not phantom
08:31:32 <lyxia> you can give two functions, one smart constructor and a destructor
08:31:54 <saml> you know waht i'm trying to do? like tagging String with AllUpperCased     
08:32:06 <saml> so there's no way just to "tag" String
08:32:13 <mauke> there is
08:32:15 <mauke> AUC is a tag
08:32:46 <saml> i mean, for implementers of f,  x is String (that happens to be all upper case due to type signature)
08:32:51 <pavonia> saml: You wrap it into AUC but you don't unwrap to get the inner string back
08:33:08 <saml> yah. trying to see if haskell could do. but looks not
08:33:20 <mauke> toString :: AllUpperCaseString -> String; toString (AUC x) = x
08:33:34 <saml> yah need to explicitly unwrap
08:34:34 <lyxia> you can give a combinator to turn String -> _ functions into AllUpperCasedString -> _ functions
08:34:44 <lyxia> well it's just (. unwrap)
08:35:52 <lyxia> saml: refinement types might be what you're looking for, but haskell doesn't have this feature.
08:36:46 <lyxia> the overhead of . unwrap just for strings seems quite minor though
08:37:41 <lyxia> saml: it doesn't cost anything at runtime BTW
08:38:23 <saml> i see
08:42:32 <zebr> in terms of logic, is there a word for, if you have (x :: a) and (f :: a -> b), how in f x the a in the type of x 'fulfils' the a in type type of f?
08:42:40 <zebr> *the
08:44:06 <zebr> one might say 'proves', but in a way the a in the type of x also 'proves' the b in the type of f as well as the a
08:44:13 <zebr> (i'm not a mathematician :p)
08:51:51 <broma0> Anyone know of more literature on the "classy-mtl with lenses" approach outlined by george wilson's talk from a while back?
08:52:52 <Zekka|Sigfig> zebr: Well, the process of taking two types, figuring out where each one fits and then making the necessary substitutions to make that work, is called substitution
08:52:57 <Zekka|Sigfig> er, called unification*
08:53:21 <Zekka|Sigfig> so I would say f x unifies with a — although I’d caution that that doesn’t necessarily say anything about b
08:54:35 <zebr> Zekka|Sigfig: mm. it's sort of a directional thing though, whereas unification isn't. and unification isn't necessary if they're polymorphic types
08:54:59 <earldouglas> Newbie Scotty/WAI question: how can I suspend a response until a later event occurs?
08:54:59 <zebr> rather, you'd need to unify an instantiation of the polytype
08:55:39 <earldouglas> I need to do: (1) request comes in, (2) trigger async process, (3) async process completes, (4) response is written
08:55:44 <Zekka|Sigfig> zebr: Hm, I’m not really clear what you’re getting at — also sounds like you’re deeper than me in the type-relevant stuff since I got into this through logic programming and it sounds like you got into this through type inference. Are you talking about what to call rules like f :: a -> b; x :: a => f x :: b?
08:55:59 * hackagebot brick 0.5 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.5 (JonathanDaugherty)
08:56:51 <Zekka|Sigfig> I’m not exactly sure why you’re saying unification isn’t necessary if they’re polymorphic fwiw — unless you’re getting into constraints, unifying a variable with another variable is totally legal afaik, and IIRC the unification stage occurs before constraint checking anyways. (*please* don’t quote me, I did not work on Haskell and don’t know that much about it)
08:57:32 <Zekka|Sigfig> I’ve got to go for a few minutes, but I’ll be back in less than half an hour
08:57:54 <zebr> Zekka|Sigfig: more specifically the way that the a in x::a is used to 'fulfil' f::(a->b)'s 'need' for a. in f::a->b, a is a 'negative' occurrence, and in x::a it is 'positive'; the latter 'fulfils' the former.
08:58:00 <zebr> Zekka|Sigfig: sure
08:58:53 <codedmart> If I have a aeson Value how can I set a key on that? ie I have {a = 1} :: Value and I want to set 'b' as [1,2] to end up with {a = 1, b = [1,2]} :: Value
08:59:46 <puregreen> codedmart: if you use lens, it's simple: http://hackage.haskell.org/package/lens-aeson
09:01:44 <puregreen> codedmart: f you don't use lens, do something like “case v of Object o -> object ["b" .= [1,2]] <> o; _ -> v”
09:01:57 <puregreen> no, uh
09:01:57 <zebr> another way of looking at it might be that (A -> B) is the same as (~A \/ B), and in (A /\ (~A \/ B)), A 'disqualifies' ~A so we get B... i don't know, there just has to be a word for this.
09:02:59 <puregreen> case v of Object o -> Object (HM.insert "b" (toJson [1,2]) o); _ -> v
09:03:09 <puregreen> (and import qualified Data.HashMap.Strict as HM)
09:04:28 <codedmart> puregreen:  I am not sure I understand how to do it with lens-aeson.
09:04:41 <codedmart> I already looked at that, but am missing something.
09:06:39 <puregreen> I think it's going to be “v & _Object . at "b" .~ Just (toJson [1,2])”
09:07:59 <John[Lisbeth]> could you say haskell is a restful language?
09:09:09 <puregreen> or, without Just, “v & _Object . at "b" ?~ toJson [1,2]”
09:09:52 <barrucadu> John[Lisbeth]: It's stateless (unless you use unsafe hacks), but the rest of REST doesn't really seem to fit
09:10:34 <Zekka|Sigfig> Haskell isn’t a particular kind of API implemented over HTTP and it doesn’t have any builtins targeted towards that kind of api
09:10:43 <Zekka|Sigfig> based on that I don’t think I would call it RESTful
09:10:46 <barrucadu> I suppose you could saylazy (ie: demand-driven) evaluation is kind of like a client-server model the "server" is the library code and the "client" is the executing binary... but that's really stretching it
09:11:36 <EvanR> John[Lisbeth]: no
09:12:12 <barrucadu> What would it mean for a language to be RESTful anyway?
09:12:16 <EvanR> Representation State Transfer
09:12:24 <EvanR> what this means anyway, who knows
09:12:28 <barrucadu> Standard library functions like a REST API? Good for programming RESTful client/servers in?
09:12:30 <EvanR> but its reserved for HTTP apis
09:13:30 <EvanR> three words that are pretty meaningful that combine to be a big huh
09:14:28 <codedmart> puregreen: Thanks!
09:14:51 <codedmart> I was missing the '_Object . at'
09:15:12 <John[Lisbeth]> What I mean is that things are not needing to run in the back ground when they are not in use
09:16:25 <EvanR> im not sure thats what REST is
09:16:51 <EvanR> whats an example of something that is not like what youre describing?
09:17:07 <broma0> earldouglas: did you get your question answered yet?
09:17:28 <earldouglas> broma0: Not yet.  I'm poking around ContT, but not sure how to make the types fit.
09:18:07 <obadz> I've heard that someone had a presentation explaining how using Haskell rewrite rules could transform an O(n^3) algo to O(n). Anyone knows what that might refer to?
09:18:16 <earldouglas> I'm coming from an imperative background, so I'm used to having a `response` instance that I can stick on the heap somewhere until I'm ready to run the continuation.
09:19:33 <EvanR> earldouglas: so you can do what you asked with haskell's concurrency stuff, and it would probably be easy
09:19:42 <EvanR> you can read about threads and MVars
09:20:06 <EvanR> also you can check out the library `async' which gives you a nice combinator for doing this sort of async request
09:20:37 <earldouglas> EvanR: Thanks a lot.
09:24:33 <runeks> Is do-notation a substitute for using the State monad? As far as I can figure out, I can just use do-notation to keep state in a variable using the <- operation, it's only if I don't use do-notation that I need to use the State monad. Is this correct?
09:25:01 <Zekka|Sigfig> runeks: Not really, sorry
09:25:35 <Zekka|Sigfig> it sounds like you sort of get what <- does, but not exactly
09:25:42 <EvanR> assigning values to a variable with let x =  and x <- is not state
09:25:48 <EvanR> its variable binding
09:26:00 <djbeau> earldouglas: conceit in another similar library
09:26:02 <Zekka|Sigfig> Do notation is an alternate syntax that translates to the >>= and >> operations
09:26:06 <djbeau> s/in/is
09:26:26 <runeks> Zekka|Sigfig: Hmm. Isn't do { a <- readSomething; let b = computeSomething a; return (a,b) } a form of keeping state?
09:26:32 <geekosaur> and more to the point the <- converts to a lambda
09:26:38 <earldouglas> djbeau: Cool, thanks.
09:26:57 <geekosaur> @undo do { a <- readSomething; let {b = computeSomething a}; return (a,b) }
09:26:57 <lambdabot> readSomething >>= \ a -> let { b = computeSomething a} in return (a, b)
09:27:00 <Zekka|Sigfig> runeks: You could probably describe it as “keeping state” if you wanted, but that’s not really “keeping state” in the sense of the State monad or in the sense of pure vs not pure
09:27:05 <geekosaur> do function parameters count as state?
09:27:18 <Zekka|Sigfig> you’re just taking an intermediate value and giving it a name
09:27:55 <Zekka|Sigfig> If you assign each intermediate value a new name, you can do the same thing you do with the State monad, but you’re doing the bookkeeping manually
09:27:56 <geekosaur> let does not desugar into function parameters, but in theory it could
09:28:34 <runeks> Zekka|Sigfig: Right. I guess it's a less explicit form of state-keeping.
09:28:37 <Zekka|Sigfig> state monad is analogous to a series of let (s, a) = statefulComputation1 in let (s, b) = statefulComputation2 a in let (s, c) = statefulComputation2 b…
09:28:39 <EvanR> its not stateful at all
09:28:48 <EvanR> its just names of expressions
09:29:09 <runeks> It implements state. It isn't state.
09:29:28 <merijn> Zekka|Sigfig: No, because you're forgetting to pass state into the computations as argument
09:29:35 <EvanR> var x = 3; var x = 5; var x = 9; console.log(x); x isnt a state var
09:29:35 <Zekka|Sigfig> merijn: Oh, whoops! You’re right
09:29:52 <EvanR> its just the name of 9
09:30:17 <Zekka|Sigfig> let (s0, b) = statefulComputation1 s in let (s1, b) = statefulComputation2 s0 a in let (s2, c) = statefulComputation2 s1 b in…
09:30:49 <EvanR> runeks: statefulness relates to the idea that when you do the same thing multiple times, you get different results each time
09:31:04 <EvanR> so calling a pure function with the same arguments never does that, in haskell
09:31:06 <Zekka|Sigfig> runeks: You can do that bookkeeping with no State at all, and no do notation at all — but State gives you a way to compose functions that silently does that bookkeeping for you
09:31:17 <EvanR> but executing a State action (the same action) multiple times, can
09:31:27 <EvanR> binding a value to a variable, cannot
09:36:03 <EvanR> when you restart a video game from the beginning and play exactly the same way, you get the same game. so in this case there is no state
09:36:33 <EvanR> when you restart the stanley parable, it could be the same, but sometimes its slightly different. so there is some hidden state
09:39:08 <EvanR> if you buy a new hard drive and install the stanley parable, and play the same way, including using the same number and timing of restarts, you get the same global experience as the first set of runthroughs
09:39:12 <EvanR> thats the State monad
09:40:52 <EvanR> and IO is like quantum physics, state doesnt apply and its never the same
09:40:57 <merijn> EvanR: I would argue you don
09:41:04 <merijn> *don't get the same global experience
09:41:17 <merijn> The magic is let out by the first runthrough!
09:41:38 <EvanR> are you talking about the users personal state
09:41:40 <Sornaensis> only because your state
09:41:42 <Sornaensis> yea
09:42:18 <EvanR> surely a state of confusion after playing that game
10:12:22 <craptalk> anyone is here?
10:12:51 <Cale> There are over 1500 IRC clients connected, would be pretty surprising if nobody was home ;)
10:13:14 <Cale> (It is awfully quiet though)
10:15:04 <gigglypuff> Okay, so I'm new to Haskell, with some novice experience in C and Python. 
10:15:59 <gigglypuff> I want to make a Haskell copy of Super Mario Bros. in 4 months.
10:16:32 <gigglypuff> Can you Haskellers help a lad out?
10:16:37 <Cale> Working every day for at least 8 hours?
10:17:28 <gigglypuff> I've roughly 7 hours of free time per day.
10:17:50 <gigglypuff> 24 during weekends.
10:18:03 <Cale> Writing a game engine is not the most trivial thing to do in any language, let alone one that you just started with :)
10:18:53 <Cale> Even if you have a really clear idea of how it's going to work, there's typically quite a lot to do.
10:19:22 <Cale> But yeah, go for it :)
10:19:45 <gigglypuff> I want to do this, though. I've been told #Haskell is ideal for assistance.
10:20:05 <Cale> There are lots of people here who are always happy to answer questions
10:20:05 <gigglypuff> With projects and problems.
10:21:30 <gigglypuff> And I've never done anything like this in the imperative paradigm.
10:21:36 <C_minus> Maybe off topic but beginner to functional here. Can someone check why my MIRANDA function to return x^y gives bad results... http://pastebin.com/J0ErcKMX 
10:22:10 <lokien> gigglypuff: professional dev or a hobbyist? just curious, you don't have to answer
10:22:17 <C_minus> d'oh i seen it should be  tothepower x y = (tothepower x (y-1) ) * x
10:22:18 <C_minus> sorry
10:22:31 <Zekka|Sigfig> C_minus: MIRANDA? Blast from the past! Yes, I believe you’re right
10:22:56 <C_minus> i'm taking a class, this is what we're being taught with, sorry i realised just a sec after i posted
10:24:41 <osfameron> gigglypuff: I found this interesting recently, on becoming a game dev: http://galaxykate0.tumblr.com/post/140095071426/10-mostly-easy-steps-to-become-an-indie-dev
10:32:03 <geekosaur> 4 monthis is a very short time to figure out functional programming and non-strict/graph reduction evaluation
10:35:20 <Cale> It took me about 2 months just to get to the point with Haskell where I was like "hey, I can actually do useful things with this", and about a year to actually be comfortable, but probably more than that to really have a good feel for what might be causing performance problems.
10:35:59 <sm> you can totally do it if you reuse existing libs
10:36:17 <sm> there are game engines, and elm has a super mario example, eg
10:36:17 <augur> is there a nice, convenient, reasonable way to (temporarily) make a computation stateful over more things?
10:36:28 <Cale> Yeah, there are a lot of libraries now which didn't exist when I was starting.
10:36:49 <Cale> augur: add function parameters?
10:37:13 <augur> that is to say, i have basically a   State s a   and some   State s' a  and i want to cheaply use both the s and s' states as   State (s,s') a
10:37:28 <osfameron> sm: learning how to reuse libs takes time in itself :-)
10:37:31 <Cale> Ah, well, it's possible to write such a function.
10:38:06 <osfameron> when you're starting to program, you have such a steep learning curve that it often feels simpler to "just" reimplement code than figure out how it pieces together with X other libraries...
10:38:11 <augur> Cale: yeah, im sure it's not impossible to write some kind of thing like...   leftState :: State s a -> State (s,s') a
10:38:11 <geekosaur> one the one hand, it's something of a pity State doesn't have something liek Reader's local; on the other hand, I think this is only the second time I've heard of someone actually needing it
10:38:34 <sm> osfameron: that's a nice article
10:38:37 <mnoonan> seems lens-y?
10:38:40 <Cale> augur: Yeah, there also is probably something in lens
10:38:42 <augur> Cale: or probably something more generic like   substate :: Lens s s' -> State s' a -> State s a
10:38:46 <augur> Cale: :)
10:38:54 <bollu> hm, how in the world do I type a void*?
10:38:57 <merijn> augur: lens already has that xD
10:39:02 <augur> merijn: :D
10:39:04 <augur> tell me more!
10:39:10 <merijn> bollu: "Ptr Void" or "Ptr ()"?
10:39:19 <geekosaur> bollu, in the FFI? use Ptr () usually
10:39:24 <merijn> augur: I thought, at least?
10:39:28 <bollu> merijn: I'm not sure if either would fit semantics
10:39:34 <bollu> geekosaur: oh cool :) thanks!
10:39:36 <merijn> augur: I thought there where weird MonadState instances you could use
10:39:36 <augur> merijn: lens frightens me, so i dont know much about it :)
10:40:02 <geekosaur> Ptr Char if you actually need to access it, but note that (void *) doesn't give you a lot to go on for actually using it correctly
10:40:13 <merijn> augur: it has stuff like "zoom :: Lens s r -> State r a -> State s a" <- grossly simplified 
10:40:18 <osfameron> sm: yeah, I really like the "learning to play guitar" metaphor.  It makes it seem less mysterious and more approachable *but also* emphasizes just how much work it's going to be :D
10:40:24 <augur> merijn: zoom zoom
10:40:35 <geekosaur> generally I'd use Ptr () in the FFI call and if it's actually something else then castPtr to the more appropriate type
10:40:40 <saurabhnanda> researching ill-effects of lazy computation on Haskell. Reading https://wiki.haskell.org/Memory_leak -- 1.1 isn't really a memory leak, right? Actually they solution is to **make your code more lazy**, if anything.
10:41:09 <bollu> geekosaur: thanks!
10:41:27 <merijn> saurabhnanda: It can happen if you don't think clearly
10:41:38 <malc_> saurabhnanda: Neil Mitchel's blog contained some illustrative examples of _space_ leaks in haskell
10:41:55 <merijn> saurabhnanda: Example: "average xs = sum xs / length xs" <- Leak!
10:42:25 <saurabhnanda> merijn: how?
10:42:31 <merijn> saurabhnanda: Well, maybe not a leak in the traditional sense
10:42:56 <saurabhnanda> merijn: actually, how is "leak" defined in this context? Isn't a "leak" allocating memory and never freeing it even when it is not being used at all.
10:43:13 <merijn> saurabhnanda: Consider the following input: "[1..1000000000]" <- normally sum should be able to handle that fine, we're generating in place and immediately consuming, yay, laziness!
10:43:42 <merijn> saurabhnanda: In garbage collected languages, e.g. python, java, haskell, memory leaks are usually "keeping memory alive longer than strictly necessary/possible"
10:43:57 <merijn> saurabhnanda: i.e. we want it to GC sooner, because we're running out!
10:44:34 <saurabhnanda> merijn: can't the GC be tuned to be more aggressive?
10:44:39 <merijn> saurabhnanda: Like my "average" bailing on [1..1000000000000], because you can never have a list that big in memory (well, on the average machine anyway
10:44:57 <merijn> saurabhnanda: Not in my average example, because the problem is that it isn't garbage yet
10:45:17 <saurabhnanda> merijn: and won't it do a collection when it runs out of heap, or something? It'll just get triggered more often, and introduce more GC pauses, but the program won't get killed by the kernel with an OOM error, right?
10:45:18 <merijn> saurabhnanda: While evaluating "sum" on that list, we need to KEEP the entire list, because length will be run on it later
10:45:31 <merijn> saurabhnanda: What will it collect?
10:45:43 <merijn> saurabhnanda: If you have a list longer than memory, how can GC help you keep it?
10:45:58 <saurabhnanda> merijn: how will clojure solve this problem?
10:46:00 <merijn> saurabhnanda: The only solution is to make sure the list isn't kept alive, i.e. you never keep the entire thing in memory
10:46:02 * hackagebot dbmigrations 1.1.1 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-1.1.1 (JonathanDaugherty)
10:46:03 <merijn> saurabhnanda: It doesn't
10:46:22 <merijn> saurabhnanda: It can't, neither can any other language. Writing stupid code in GCed languages can still run you OOM
10:46:39 <saurabhnanda> merijn: I'm assuming that this will be a problem with every language out there. Does it really have anything to do with laziness?
10:46:49 <merijn> saurabhnanda: Well, laziness makes things non-obvious
10:47:11 <merijn> saurabhnanda: Let's define "crazyBigInt" to be a number so large that we can't keep a list of that many elements in memory
10:47:17 <djbeau> merijn: is your point that in this example, there is an opportunity to avoid the "leak" by combining the sum and length operations to execute simultaneously (i.e., in lock-step)
10:47:21 <saurabhnanda> merijn: this particular example doesn't have anything to do with GC-ed langs as well, right? You can very easily write this kind of code in C as well. It's about space-efficient algo vs not.
10:47:39 <merijn> saurabhnanda: Now "sum [1..crazyBigInt]" should be fine, because we never keep that actual list in memory (we consume and GC it as we go)
10:47:51 <merijn> djbeau: Yes
10:48:06 <merijn> djbeau: That would avoid the leak, by not keeping the "beginning of list" pointer alive
10:48:17 <merijn> djbeau: So we can incrementally GC the list as we generate it
10:48:48 <merijn> saurabhnanda: You can do the same in C, yes. But in C you have even more ways to leak memory :p
10:48:50 <djbeau> merijn: ok - I think generally speaking, there might be some cases where such an optimization is just not possible, correct?
10:49:06 <merijn> djbeau: Magic 8ball says: Maybe
10:49:14 <djbeau> merijn: :)
10:49:15 <merijn> djbeau: I'm not confident to make a claim in either direction :)
10:49:32 <saurabhnanda> merijn: what about Java? Even Java will have the same problem.
10:49:56 <djbeau> saurabhnanda: I think it is important to note that only in a lazy language can one "construct" a large or infinite list with immediately incurring a runtime error/hang
10:50:03 <merijn> saurabhnanda: Anyway, to get back to your original question. The notion of a memory leak tends to be generalised from "never freeing" (in C), to "causing the program to fail due to insufficient memory available"
10:50:08 <saurabhnanda> merijn: not sure if this is a good example to demonstrate laze<=>space-leak problem.
10:50:10 <djbeau> in a strict language, such a construction would fail immediately
10:50:15 <merijn> djbeau++
10:50:30 <bollu> so, in the FFI, do you handle arrays as pointers?
10:50:46 <bollu> because there's a type that's like this: typedef basic_struct basic[1];
10:50:49 <merijn> saurabhnanda: The laziness part is indeed that such constructions IMMEDIATELY fail in strict languages, but might (confusingly) fail only in some small corner cases
10:50:54 <bollu> that strikes me as a very odd thing fo typedef
10:50:55 <djbeau> s/with/without in previous comment
10:50:57 <merijn> saurabhnanda: This makes it harder to find them
10:50:59 <bollu> but I gotta deal with it
10:51:00 <merijn> Anyway, dinner time
10:51:15 <saurabhnanda> didn't understand this // I think it is important to note that only in a lazy language can one "construct" a large or infinite list with immediately incurring a runtime error/hang
10:51:28 <djbeau> yeah, I meant "without" there, not "with"
10:51:44 <saurabhnanda> merijn: okay, later, thanks.
10:51:51 <djbeau> I can declare a list [0..] and the runtime is fine with it
10:52:15 <djbeau> until I try to traverse the entire list or keep so much of it in memory that I run out of space
10:52:35 <djbeau> but if the program never does that, then no problem
10:52:42 <djbeau> one cannot do that in a strict language
10:53:20 <saurabhnanda> actually, why would one use a list for something like this? Isn't a lazy-stream a better choice?
10:53:36 <djbeau> sure, I am just try to give a simple example
10:53:46 <saurabhnanda> If it is something that can be constructed numerically, aren't lazy streams encouraged in Haskell?
10:54:11 <djbeau> I am not sure what you mean by "construted numerically"
10:54:19 <djbeau> *constructed even
10:56:32 <saurabhnanda> constructed functionally, constructed by a function
10:56:32 <djbeau> saurabhnanda: lazy streams are certainly encouraged - the point is that if you are not careful with it, it can eat up your memory
10:57:02 <djbeau> and it is not always obvious from cursory source code inspection
10:57:03 <saurabhnanda> hmm
10:58:59 <djbeau> another way to say it: the stream is actually constructed in memory at runtime piecewise as it is needed, not at the place of definition (which is a better-defined term in an imperitive language)
10:59:22 <levi> Due to the nature of Haskell, there is little difference between a list and a lazy stream. In most other languages, you would have to construct the two things in a very different way.
10:59:33 <djbeau> and once any of those pieces are determined to be dead, the runtime system is free to garbage collect them - piecewise
10:59:46 <djbeau> levi: good point
11:00:32 * djbeau apologizes if he is unintentionally redundant
11:01:56 <saurabhnanda> actually, I'm not sure if it's easy to construct a lazy-stream in haskell. In schema/lisp it's easier because you can mix types in conses
11:02:24 <obadz> I've heard that someone had a presentation explaining how using Haskell rewrite rules could transform an O(n^3) algo to O(n). Anyone knows what that might paper/presentation/blog post this might refer to?
11:03:31 <levi> saurabhnanda: If you could explain a bit further what precisely you mean by lazy-stream, maybe we could see how this translates (or which parts don't) to Haskell.
11:04:46 <saurabhnanda> levi: are you familiar with SICP? https://mitpress.mit.edu/sicp/full-text/sicp/book/node70.html#sec:delayed-lists
11:07:21 <levi> saurabhnanda: In Haskell, there's no need for a 'delay' form because all evaluation is delayed by default.
11:08:42 <saurabhnanda> levi: hang on, I'm writing a minimal implementation in scheme
11:09:07 <levi> The Haskell list type is the same as a polymorphically-typed SICP stream.
11:10:36 <Oejet> saurabhnanda: `ones = 1 : ones` would be an example of a lazy stream.
11:11:03 * hackagebot tracy 0.1.3.0 - Convenience wrappers for non-intrusive debug tracing  https://hackage.haskell.org/package/tracy-0.1.3.0 (dredozubov)
11:11:07 <levi> There's no need for you to write one in Scheme; I'm familiar with SICP.
11:11:50 <saurabhnanda> little rusty, but this is what I mean, I hope it's correct.
11:11:51 <saurabhnanda> (define stream (x) (cons x (lambda () (stream (+ 1 x))))) 
11:11:54 <saurabhnanda> (define stream-car (s) (car s)) 
11:11:56 <saurabhnanda> (define stream-cdr (s) ((cdr s))) 
11:15:41 <levi> Any expression bound to a name in Haskell (aside from a few exceptions) is delayed in the sense that 'stream' delays its cdr. It is only evaluated when the binding is inspected (or "scrutinized") by a case analysis of some sort, and then only to the point of reaching the next data constructor.
11:17:36 <levi> Because this is the default evaluation model of Haskell, the standard Haskell list construction is *the same thing* (aside from typing differences, of course) in an operational sense as what you defined in Scheme.
11:18:26 <saurabhnanda> levi: thanks, got that.
11:18:34 <Cale> (it also delays the car of course)
11:19:12 <levi> Right; it's easy to forget that part.  So they're not quite exactly the same.
11:19:42 <saurabhnanda> so, are thunks actually a thing? Isn't all this stuff abstracted away at compile-time?
11:20:04 <saurabhnanda> s/abstracted/optimized
11:20:26 <levi> Thunks are an implementation technique to suspend evaluation of an expression.
11:20:42 <Hafydd> saurabhnanda: of course thunks still exist in a compiled program. Otherwise, how would you represent the infinite list [1..]?
11:21:04 <earldouglas> EvanR, djbeau: I solved my async problem with MVar -- thanks again!
11:21:07 <saurabhnanda> Hafydd: apart from that. Is every function argument thunked?
11:21:14 <Hafydd> saurabhnanda: apart from what?
11:21:27 <saurabhnanda> Hafydd: stuff like [1..10000]
11:21:32 <Sornaensis> > [1..]
11:21:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:21:36 <levi> Haskell doesn't guarantee it'll suspend evaluation until it's demanded, but it does guarantee that it'll produce the same result (aside from a few exceptions) as if evaluations were delayed until scrutinized.
11:22:00 <Hafydd> saurabhnanda: there are many cases in which computations are performed strictly, without suspension, as an optimisation.
11:22:20 <Athas> How can I specify a specific GHC version to use when running 'stack init --solver'?
11:22:29 <Hafydd> And it's also possible to provide annotations in a Haskell program to the same effect (which may also change its semantics).
11:22:51 <malc_> levi: what are the exceptions?
11:23:51 <obadz> malc_: maybe unsafePerformIO ?
11:24:13 <malc_> obadz: unsafePerformIO is an exception to anything methinks
11:24:18 <levi> Strict data fields, strictness annotations, etc.
11:24:46 <mmaroti> Hi guys, just a quick question: I have a Functor and Foldable instance f, and need a function of type "f (Maybe a) -> Maybe (f a)". Is there a standard typeclass for this?
11:25:05 <shachaf> mmaroti: Traversable
11:25:27 <obadz> levi: you said lazy eval vs strictness-for-optimization lazy eval sometimes don't match?
11:25:32 <obadz> :t sequence -- mmaroti 
11:25:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:26:06 <luigy> Athas init also takes into account the --resolver
11:26:26 <luigy> stack --resolver snapshot|ghc-blah|etc init --solver
11:27:09 <mmaroti> Oh, so sequenceA is the right function?
11:27:17 <obadz> mmaroti: yes
11:27:24 <mmaroti> Cool, thanks. 
11:27:29 <Athas> luigy: oh, thanks.  Peripherally related, is there a way to make it write the YAML to a specific file?
11:27:47 <Athas> I am going to generate several stack.yaml files for different GHC versions.  Is that the right way to do it?
11:28:03 <EvanR> earldouglas: nice
11:28:13 <levi> obadz: That's not quite what I meant; I meant the general rule that 'evaluation only happens in case-analysis' has some exceptions.
11:29:02 <obadz> levi: I see the exception part applied to the first part of the statement then
11:29:06 <levi> obadz: Normal optimization doesn't change the semantics of non-strict evaluation order, but strictness annotations and the like can.
11:29:07 <aerialB> > take 20 creases where creases = [2^fold - 1 | fold <- [1..]]
11:29:09 <lambdabot>  <hint>:1:17: parse error on input ‘where’
11:29:12 <aerialB> woops
11:29:33 <saurabhn_> how is this even possible? http://stackoverflow.com/questions/9406463/withfile-vs-openfile
11:32:07 <oherrala> saurabhn_: what's that you don't understand?
11:32:10 <djbeau> saurabhn_: If I understand your question correctly, I think it has to do with the special quality of getlines
11:32:21 <levi> obadz: The language definition doesn't actually define evaluation order, it defines a semantic mapping between expressions and values. The compiler is free to rearrange things as it sees fit as long as the semantic mapping is preserved, but this means that expressions can't always be eagerly evaluated.
11:32:55 <saurabhn_> This means the file will be closed as soon as the withFile function returns.
11:32:58 <saurabhn_> how is this possible? // The handle will be closed on exit from withFile. 
11:32:58 <luigy> Athas oh I see what you're going for
11:33:03 <luigy> yeah should work fine
11:33:08 <saurabhn_> Because hGetContents and friends are lazy, it won't try to read the file until it is forced with putStrLn, but by then, withFile would have closed the file already.
11:33:14 <luigy> stack --resolver lts-3 init --solver
11:33:21 <saurabhn_> that's from the first answer to that SO question
11:33:22 <luigy> for the latest 3ish snaphsot
11:33:34 <djbeau> oops, I meant hGetContents (which getlines uses)
11:33:43 <jle`> saurabhn_: why isn't it possible?
11:33:48 <jle`> it's just implemented that way
11:34:13 <oherrala> saurabhn_: withFile uses bracket https://wiki.haskell.org/Bracket_pattern
11:34:14 <obadz> levi: I understand, was just curious about potential exceptions. I assume unsafePerformIO will break these guarantees of semantic equivalent.
11:34:19 <EvanR> saurabhn_: hGetContents + withFile seems like a voltaile combination
11:34:37 <jle`> saurabhn_: withFile is implemented so that the handle is closed once it's done
11:34:38 <saurabhn_> what's the bracket pattern? Reading it...
11:34:41 <jle`> that's just how it's implemented
11:34:58 <jle`> what part are you finding hard to believe is possible? :)
11:35:03 <EvanR> and hGetContents makes the file "half closed"
11:35:15 <levi> obadz: It *can*, but it's supposed to be used in places where its use won't make a semantic difference.
11:35:24 <oherrala> Some strictness inside withFile and things are usually fixed
11:35:49 <EvanR> obadz: primitive arithmetic is strict and so is IO
11:36:12 <EvanR> in addition to bang patterns and case analysis
11:36:40 <saurabhn_> not sure why it's called a bracket pattern. Isn't is a regular use-case of passing around lambdas and abstracting out processes into higher-order functions? with-open-file first opens a file, runs the lambda you pass it (passing it the open file handle) and ensures the file handle is closed at the end of your lambda.
11:36:57 <cmotoche> Hello everyone. I'm using Text.Hamlet for a project and I'm not sure where the files with the template code should be. I always get "file does not exist". Do you know where the templates should be?
11:37:23 <EvanR> saurabhn_: well its only ensured by using bracket
11:37:26 <saurabhn_> which is why I'm unable to understand how this can fail
11:37:28 <johnw> saurabhn_: in fact, a function like withFile is just CPS transformation
11:37:37 <saurabhn_> johnw: CPS=?
11:37:43 <cmotoche> I'm using renderHtml ( $(shamletFile "file.hamlet"))
11:37:45 <johnw> continuation-passing style
11:37:55 <johnw> going from String -> Handle to String -> (Handle -> r) -> r
11:37:57 <obadz> EvanR: what does it mean for primitive arithmetic to be strict?
11:38:19 <jle`> saurabhn_: ah, the reason it fails is that hGetContents doesn't start doing any IO until you begin to evaluate its result, and it does it on a by-need basis, incrementally
11:38:22 <EvanR> obadz: the same thing it does for anything to be strict... _|_ + n = _|_, n + _|_ = _|_
11:38:35 <geekosaur> hGetContents is evil
11:38:38 <jle`> saurabhn_: it's actually a rather nasty implementation choice for hGetContents
11:38:40 <geekosaur> (as is getContents)
11:38:49 <djbeau> saurabhn_: I think Jedai's answer on that page it actually good - lazy I/O has its problems
11:38:53 <obadz> EvanR: what would n + ⊥ be = to if + wasn't strict?
11:38:57 <saurabhn_> EvanR: what I meant to confirm was, that "bracket pattern" doesn't seem Haskell-specific. It's used all-over in Common Lisp (and even Ruby).
11:39:01 <djbeau> it sort of violates Haskell's semantics in some sense
11:39:08 <EvanR> obadz: it *could* be not _|_, if it wasnt strict
11:39:11 <jle`> saurabhn_: so, when you close withFile, you close the handle.  no IO is ever done
11:39:14 <EvanR> saurabhn_: sure
11:39:31 <johnw> for those decrying lazy I/O, do read http://comonad.com/reader/2015/on-the-unsafety-of-interleaved-io/
11:39:41 <geekosaur> obadz, it could be unevaluated until forced, instead of being strictly (in effect immediately) evaluated
11:39:45 <jle`> saurabhn_: it's not done until you start to evaluate the contents of the result of hGetContents, so IO doesn't start until after withFile ends
11:39:58 <EvanR> obadz: example non-strictness, if True then 'x' else _|_, the result here is not _|_
11:40:08 <EvanR> you dont have to evaluate the arguments 
11:40:10 <obadz> EvanR: I don't see how, given that for all primitives, (+) needs both of its arguments to produce a result
11:40:17 <EvanR> with primitive + you have to
11:40:23 <EvanR> obadz: thats exactly the point
11:40:33 <EvanR> so its strict
11:40:34 <djbeau> jle': or even more precisely, it is not guaranteed to finish before withFile ends
11:40:59 <djbeau> (it being hGetContents)
11:41:11 <saurabhn_> jle`: exactly. How is that possible? How can withFile end BEFORE hGetContents? hGetcontents would NEED withFile to pass it the file handle, right?
11:41:32 <EvanR> obadz: its a case where you cant be lazy, but its not a case analysis
11:41:36 <jle`> saurabhn_: hGetContents returns/finishes executing immediately
11:41:52 <jle`> it doesn't do any IO before finishing/pasisng on control
11:41:55 <jle`> it's "non-blocking", you can say
11:42:15 <jle`> so withFile executes getContents, finishes executing it, closes the handle, and things move on
11:42:19 <djbeau> saurabhn_: I think that hGetContents stashes away the file handle "for later" when it is needed
11:42:27 <levi> obadz: What it means in the context of GHC is that primitives force the evaluation of their arguments before they're invoked, rather than afterward.
11:42:33 <obadz> EvanR: so (+) x y = x `seq` y `seq` x Lazy.+ y ?
11:42:43 <djbeau> but when it tries to use it, the handle has already been marked closed by the runtime/OS
11:42:54 <EvanR> obadz: nope, + is a primitive for primitive types
11:42:59 <obadz> (if there was such a thing as Lazy.+ ..
11:43:01 <djbeau> after all, a file handle is just an integer in the end
11:43:03 <EvanR> but you can make + lazy for your own type
11:43:03 <jle`> saurabhn_: the file handler is just a value, it doesn't self-destruct...but hGetContents is just nwo holding on to a closed handler
11:43:08 <saurabhn_> jle`: but it isn't executed right? it would be thunked away. So, if withFile is actually being un-thunked/executed, wouldn't hGetcontents also get "unthunked/executed" at pretty much the same time?
11:43:13 <jle`> saurabhn_: it is executed
11:43:20 <jle`> the execution of hGetContents is completed immediately
11:43:37 <jle`> but its execution doesn't involve any IO
11:43:43 <EvanR> obadz: example lazy + would be addition of naturals defined as data N = Z | S N
11:43:46 <obadz> levi: I can imagine that the cpu isn't goint to accept a thunk as an argument to add, but I'm not sure how that's relevant..
11:44:09 <geekosaur> saurabhn_, do you understand the difference between seq and deepseq?
11:44:31 <saurabhn_> from the S.O answer: This is lazy IO (implemented with the unsafeInterleaveIO, guess what the "unsafe" part means...).
11:44:39 <saurabhn_> geekosaur: no.
11:44:57 <EvanR> obadz: you asked what it meant for something to be strict. and before that you asked for exceptions to the case rule
11:45:06 <geekosaur> when you "force" a Haskell evaluation, it goes to the first constructor. no deeper.
11:45:08 <saurabhn_> is hGetContents doing something stupid, which is known to be un-Haskelly
11:45:25 <obadz> EvanR: I don't know what the case rule is :)
11:45:37 <levi> obadz: Well, it's just one of those exceptions to the operational rule of where evaluation occurs in the GHC operational semantics. It's not a huge difference.
11:45:51 <geekosaur> as it turns out, hGetContents doesn't even go that far as it just sets up a thunk initially to do lazy I/O. but if you force it to produce something, it produces the first character of the file.
11:45:54 <EvanR> obadz: the operation of case analyzing something to get a result is strict (by default, you can change it)
11:46:00 <jle`> saurabhn_: its behavior is often unexpected, yes.  it does 'lazy io'
11:46:09 <geekosaur> like any lazy list where seq-ing gets you the first element, not the whole list
11:46:34 <jle`> saurabhn_: for example, in do x; y; z, you'd execute x, then when x is done executing, you'd do y, then z, etc. 
11:46:51 <jle`> hGetContents's "execution" doesn't actaully involve doing any IO or reading from any contents
11:46:58 <refefer> is there an equivalent of scala's collect with a partial function?
11:47:13 <jle`> so withFile exeutes hGetContents, which doesn't involve doing any IO or reading
11:47:16 <jle`> and then things move on their merry way
11:47:19 <geekosaur> now, it turns out that where you might think it reads the whole file, in fact it is doing I/O "in the background". forcing the first character reads a block from the file. if you haven't requested a value from it, it doesn;t even read that first block much less the rest of the file
11:47:34 <obadz> refefer: what's the type signature of collect ?
11:47:59 <geekosaur> (it opens the file, nothing more, when executed. reads happen as data is required from the lazy string it produces)
11:48:05 <refefer> obadz: let's say you have an ADT with Foo and Bar
11:48:39 <refefer> it lets you say things like: collect (\(Foo a) -> a) xs
11:48:50 <refefer> where you don't have to specify a total function
11:49:02 <Zekka|Sigfig> refefer: You can do that with list comprehensions
11:49:10 <obadz> refefer: [ y | y <- Foo x, x <- xs ]
11:49:15 <obadz> something like that
11:49:27 <EvanR> refefer: yeah, theres a monad comprehension that uses Maybe
11:49:36 <EvanR> but more idiomatic i think is to use catMaybes
11:49:38 <jle`> [ x | Foo x <- xs ], you mean
11:49:38 <Zekka|Sigfig> > [x | Just x <- [Just 1, Nothing, Just 2, Just 3]]
11:49:40 <lambdabot>  [1,2,3]
11:49:46 <saurabhn_> no, I'm unable to digest this. Does Haskell expect us to reason around it's implicit laziness? I thought laziness was just a way for the compiler to reason about stuff internally and for optimization tricks. Else it's pretty much like JS callback hell when you're dealing with async stuff. One has to register callback to be notified of when a function was actually run vs when it retuned immediately only to be executed at some time in the 
11:49:46 <saurabhn_> future.
11:49:53 <EvanR> :t catMaybes
11:49:54 <lambdabot> [Maybe a] -> [a]
11:49:57 <refefer> a lovely.  this desugars down into map/bind/filters?
11:50:00 <jle`> saurabhn_: this doesn't have anything to do with haskell laziness
11:50:05 <jle`> it's just how hGetContents is implemented
11:50:07 <EvanR> refefer: no, its the Maybe monad
11:50:09 <jle`> it's not a fundamental property o fhaskell
11:50:19 <jle`> it's just how the person who invented hGetContents decided to implement it
11:50:19 <Zekka|Sigfig> refefer: Desugars to >>= and guard afaik
11:50:32 <refefer> great, exactly what I was looking for
11:50:33 <refefer> thanks
11:50:36 <Zekka|Sigfig> might be >>= and fail if you use pattern matching
11:50:43 <jle`> saurabhn_: you could implement an hGetContents that behaves in the manner you expect in Haskell
11:51:17 <jle`> this is a particular implementation detail of this specific implementation of hGetContents, out of many ways it could have been implemented to behave
11:51:20 <obadz> EvanR: I think it's the list monad, not the Maybe monad
11:51:29 <EvanR> when you do Just x <-
11:51:46 <obadz> EvanR: this works on a data type that's not a monad
11:51:48 <saurabhn_> jle`: no, that's not what I'm getting at. The fact that hGetcontents has actually not been completely run, shouldn't 'bracket' (or the compiler) be able to keep track of that? And hold on to its environment till it's actually run?
11:52:01 <obadz> EvanR: data Blah = Foo Int | Bar Float
11:52:03 <EvanR> oh list
11:52:06 <obadz> EvanR: http://stackoverflow.com/questions/9406463/withfile-vs-openfile
11:52:08 <geekosaur> no, because it's using a dirty trick called unsafeInterleaveIO
11:52:23 <obadz> EvanR: ooops that link wasn't what I wanted to paste
11:52:26 <obadz> EvanR: [ x | Foo x <- [ Foo 3, Bar 2, Foo 4 ] ]
11:52:27 <geekosaur> which hides what it's doing from the compiler
11:52:34 <saurabhn_> so the promise bracket is that the cleanup function will be called if the IO action runs OR if there is an exception. In the case of hGetcontents, neither has happened.
11:52:35 <refefer> final question: any spooky side effects to the MonadComprehensions extension?
11:52:38 <EvanR> obadz: makes sense, fail for list drops the element
11:52:43 <obadz> EvanR: yep
11:52:48 <geekosaur> in the same way that unsafePerformIO hides the fact that you're doing IO in apure context from the compiler
11:52:51 <jle`> if you use unsafe functions, you're telling the compiler to close its eyes, heh
11:53:08 <EvanR> refefer: actually this is just a list comprehension
11:53:12 <EvanR> and no
11:53:55 <obadz> refefer: this is the same as do { Foo x <- [ Foo 3, Bar 2, Foo 4 ]; return x }
11:54:04 <saurabhn_> geekosaur: jle`: right. So hGetcontents is actually doing something un-Haskelly?
11:54:23 <EvanR> its part of haskell so that would be a contradiction ;)
11:54:24 <geekosaur> it's not "un-Haskelly", just unintuitive
11:54:36 <geekosaur> in some sense it is *more* haskelly than strict I/O
11:54:47 <saurabhn_> "unsafeInterleaveIO allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded. This is used to implement lazy file reading, see hGetContents."
11:54:59 <geekosaur> but, just as you have to learn to deal with lazy evaluation, you have to learn to deal with the weirdnesses of lazy I/O
11:55:18 <EvanR> or reject it
11:55:19 <obadz> any cases where list comprehensions and list monad disagree?
11:56:24 <geekosaur> saurabhn_, it is clearly documented in the hGetContents doucmentation that you should not use or close the handle after doing hGetContents on it
11:56:45 <geekosaur> Ideally the handle would be invalidated in some way but I think *that* gets into unHaskelly action-at-a-distance
11:56:55 <refefer> goodness, I didn't even realize I could partial match in for expressions
11:57:05 <refefer> er, do notation
11:57:14 <refefer> time to remove a good amount of boilerplate
11:57:19 <EvanR> the magic of fail
11:58:57 <saurabhn_> same problem here? "The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents."
11:59:22 <geekosaur> it's different in that it never exposes the Handle to you, so you can't prematurely close it
11:59:23 <EvanR> getContents readFile and hGetContents are in the rogues gallery
11:59:51 <saurabhn_> does the entire System.IO package behave this way?
11:59:54 <EvanR> nope
11:59:56 <EvanR> just those
12:00:09 <EvanR> also readFile has a strict version
12:00:47 <EvanR> in the strict package
12:01:27 <EvanR> but you probably want to use the ByteString version in that case
12:01:27 <saurabhn_> what about hGetLine? behaves similarly?
12:01:33 <EvanR> no that is strict
12:01:37 <EvanR> it blocks
12:01:55 <Cale> It probably wouldn't be too bad to just mark the handle as being in some state where it's invalid to call hClose on it when you apply hGetContents, and then throw an exception instead of closing. That would be incompatible with the existing behaviour though, and would mean that you couldn't close the handle in some cases where you know you no longer need the String result.
12:02:21 <saurabhn_> how do I write a one liner which reads a large file one line at a time, passes the line to a function (and the function then calls other functions to process the line) WITHOUT causing this problem?
12:02:24 <EvanR> saurabhn_: note that hGetLine will never return and exhaust memory if you use it on a malicious handle
12:02:38 <dolio> Cale: I've suggested that, but people didn't like it, I think.
12:03:43 <EvanR> saurabhn_: fmap (f . lines) readFile ?
12:04:20 <Cale> saurabhn_: which problem exactly?
12:04:22 <EvanR> fmap (map f . lines) readFile
12:04:33 <Cale> Don't forget to apply readFile
12:04:51 <saurabhn_> Cale: file handle closing before the actual IO has completed.
12:05:19 <Cale> saurabhn_: Just don't close the handle if you use hGetContents. The handle will close when the String is fully evaluated.
12:05:56 <geekosaur> which, again, you can do with readFile instead of trying to use hGetContents with withFile
12:06:00 <Cale> Yeah
12:06:17 <Cale> If you want to use hGetContents, you should use openFile, not withFile
12:06:19 <saurabhn_> so it this the ONLY case where such a problem can manifest>
12:06:21 <saurabhn_> what about other IO?
12:06:37 <saurabhn_> like reading from Redis inside a withRedis function?
12:06:41 <EvanR> this is the only situation like this in the standard lib
12:06:46 <saurabhn_> or reading from DB inside a withDb function?
12:07:00 <EvanR> i hope they dont use lazy IO
12:07:03 <Cale> saurabhn_: Pretty much this is the only case -- there are few other magical functions like hGetContents out in the wild.
12:07:08 <geekosaur> I would not expect them to use lazy IO
12:07:17 <saurabhn_> I'm thinking along here... it this really a standard library problem or is this something that the compiler should be handling?
12:07:18 <bollu> is it possible to install things globally using stack?
12:07:22 <Cale> I believe one of the database libraries had something similar with respect to the rows returned from a query
12:07:47 <saurabhn_> DB cursors are supposed to be lazy
12:07:47 <bollu> Cale: persistent?
12:07:51 <geekosaur> saurabhn_, as has already been answered, this is not something the compiler should be handling, hGetContents is deliberately going behind the compiler's back
12:08:04 <EvanR> saurabhn_: for the mysql lib for example there is a combinator to fold over the results, row by row. it has an IO type and does not return until it is done
12:08:10 <saurabhn_> when you're running a report dealing with 10,000 rows you don't want to fetch them into memory all at once
12:08:32 <saurabhn_> you write a withCursor \row -> doSomething block to deal with it.
12:08:39 <EvanR> see my last message
12:09:58 <geekosaur> saurabhn_, different kind of laziness there
12:10:22 <EvanR> saurabhn_: you dont want to manually manage a db cursor
12:10:30 <EvanR> you do want to fold
12:10:39 <geekosaur> and the level at which that happens is buried inside the db library, you can't affect it from Haskell
12:11:09 <geekosaur> you could stupidly write something that reads all the rows at once and then invokes the block on each row, but tht would be un-Haskelly
12:11:28 <geekosaur> (you'd actually have to go out of your way to get that behavior)
12:11:44 <saurabhn_> network connections are implemented as file handles, right? wouldn't every network library be at risk here?
12:12:13 <EvanR> interpreting network connections is hazardous anywhere
12:12:25 <EvanR> this is the least your problems there
12:13:27 <EvanR> if you arent using a library to speak with the other party, you need to be really careful
12:13:41 <EvanR> assuming the lib isnt broken
12:14:03 <EvanR> still waiting on a glibc fix for my distro :(
12:14:11 <saurabhn_> don't know. Still unable to digest why the compiler can't catch this stuff and refuse to compile it.
12:14:14 <maerwald> EvanR: lolz
12:14:15 <maerwald> wat?
12:14:18 <maerwald> what crap are you using?
12:14:35 <maerwald> that's been fixed since a week 
12:14:38 <EvanR> something with the network cable unplugged
12:15:14 <saurabhn_> btw is `lines` a lazy function?
12:15:23 <EvanR> > lines undefined
12:15:26 <lambdabot>  *Exception: Prelude.undefined
12:15:33 <saurabhn_> If I give it a 1GB string it won't run out of memory right? due to all of that laziness?
12:15:33 <EvanR> nope
12:16:14 <saurabhn_> how do I generate a really big string in the REPL quickly?
12:16:22 <EvanR> String = [Char] will probably be hellish on complex text processing
12:16:30 <EvanR> use Text instead
12:16:34 <maerwald> don't do 1gb with a list :/
12:16:53 <EvanR> > repeat 'a' -- really big string
12:16:55 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
12:17:17 <saurabhn_> EvanR: can I give it a length?
12:17:23 <EvanR> replicate
12:17:25 <saurabhn_> EvanR: take?
12:17:33 <EvanR> :t replicate
12:17:34 <lambdabot> Int -> a -> [a]
12:18:22 <geekosaur> saurabhn_, again, because unsafeInterleaveIO goes behind the compiler's back
12:18:31 <saurabhn_> EvanR: replicate doesn't work for me
12:18:39 <saurabhn_> :t repeat
12:18:40 <lambdabot> a -> [a]
12:18:43 <geekosaur> you seem to be coming out on the side of "kill all possibility of lazy I/O"
12:18:50 <EvanR> > replicate 100000000 'a'
12:18:50 <geekosaur> but it has its uses
12:18:50 <saurabhn_> EvanR: repeat won't work either
12:18:51 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
12:19:01 <EvanR> wont work?
12:19:11 <MitchellSalad> > generate (arbitrary :: Gen String)
12:19:13 <lambdabot>  <IO [Char]>
12:19:17 <saurabhn_> > replicate 100000 "hello\n"
12:19:18 <lambdabot>  ["hello\n","hello\n","hello\n","hello\n","hello\n","hello\n","hello\n","hell...
12:19:27 <saurabhn_> EvanR: I want to pass it to `lines`
12:19:38 <EvanR> > cycle "hello\n"
12:19:39 <lambdabot>  "hello\nhello\nhello\nhello\nhello\nhello\nhello\nhello\nhello\nhello\nhello...
12:19:52 <saurabhn_> EvanR: thanks
12:19:52 <aerialB> :t cycle
12:19:53 <lambdabot> [a] -> [a]
12:20:02 <EvanR> dont worry about it being lazy
12:20:06 <EvanR> er, dont worry about it being infinite
12:20:10 <aerialB> > cycle 1
12:20:11 <lambdabot>      No instance for (Show a0)
12:20:11 <lambdabot>        arising from a use of ‘show_M73470721668140632861214’
12:20:11 <lambdabot>      The type variable ‘a0’ is ambiguous
12:20:15 <EvanR> just keep calk and lines anyway
12:20:20 <EvanR> calm...
12:21:28 <frontendloader> > cycle "around the world..."
12:21:30 <lambdabot>  "around the world...around the world...around the world...around the world.....
12:22:11 <geekosaur> saurabhn_, unsafeInterleaveIo does something that can't be captured by the type system, so the compiler can't detect you using it under withFile when you should be using readFile. that's the main screw case for this kind of thing, though; you won't see it with network stuff because you can't withFile a socket
12:22:25 <dkibi> I have a couple of functions of type a->Bool (lets call them f1, f2,...) now I want to define new such functions by conjunction eg. f' x = f1 x && f2 x. This is ugly so I define: a <&> b = \x→a x && b x. Can this extra definition be avoided by using some kind of magic thing?
12:22:27 <geekosaur> and there is no withSocket host port
12:22:34 <saurabhn_> how do I putStrLn every element of a VERY LARGE list on a separate line?
12:22:43 <saurabhn_> * each on a separate line?
12:22:56 <hiptobecubic> mapM putStrLn largelist ?
12:22:59 <mauke> dkibi: liftA2 (&&)
12:23:09 <hiptobecubic> maybe mapM_  
12:23:19 <saurabhn_> :t mapM
12:23:20 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:23:25 <geekosaur> usually mapM_, nobody needs the IO ()s
12:23:38 <saurabhn_> :t mapM_
12:23:39 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
12:23:52 <geekosaur> er, IO [()] you'd get from mapM
12:24:22 <saurabhn_> > mapM_ putStrLn $ take 5 $ lines $ cycle 10 "hello\n"
12:24:24 <lambdabot>      Couldn't match expected type ‘[Char] -> String’
12:24:24 <lambdabot>                  with actual type ‘[a0]’
12:24:24 <lambdabot>      The function ‘cycle’ is applied to two arguments,
12:24:33 <saurabhn_> > mapM_ putStrLn $ take 5 $ lines $ cycle "hello\n"
12:24:35 <lambdabot>  <IO ()>
12:24:42 <saurabhn_> > putStrLn "hey"
12:24:44 <lambdabot>  <IO ()>
12:24:47 <saurabhn_> ah
12:24:52 <EvanR> looks good
12:25:02 <EvanR> thats a fine IO action you got there
12:25:04 <puregreen> dkibi: either define something like (<&&>) = liftA2 (&&) and use it instead of &&, or write “f = and . sequence [f1, f2, f3, ...]”
12:25:15 <EvanR> youre not thinking about using it are ya!
12:27:09 <saurabhnanda> > mapM_ putStrLn $ take 1000000 $ lines $ cycle "hello\n"
12:27:11 <lambdabot>  <IO ()>
12:27:25 <saurabhnanda> GHC is not increasing memory
12:27:28 <saurabhnanda> all is well
12:27:39 <EvanR> cycle "hello\n" doesnt take up very much space
12:27:46 <saurabhnanda> how do I make it go crazy? "leak" memory?
12:28:12 <EvanR> it is let x = 'h':'e':'l':'l':'o':'\n':x in x
12:28:45 <dkibi> puregreen: the second doesn't look neat in my case, because I have multiple such definitions with only one or two conjunctions in each. The first one however is neat and seems to be equivalent to my lambda expression.
12:29:01 <dkibi> mauke, puregreen: what is f in this case?
12:29:22 <suppi> hi, i'm trying to learn how to implement type inference. i'm pretty much making things up and i'm not sure if i'm in the right direction. this is my code: http://lpaste.net/3618986739789463552
12:29:39 <suppi> specifically i'm not sure if the construct function is supposed to work like that: annotating and returning a list of constraints
12:29:40 <puregreen> dkibi: (Bool ->)
12:29:49 <EvanR> saurabhnanda: mapM_ print [1..]
12:29:56 <suppi> and if it does, what should be the next step?
12:29:56 <EvanR> er, let x = [1..]
12:29:58 <puregreen> ouch, (-> Bool)
12:30:00 <EvanR> mapM_ print x
12:30:09 <puregreen> no, wait
12:30:10 <puregreen> nevermind
12:30:32 <bollu> internal error: RELEASE_LOCK: I do not own this lock:
12:30:40 <bollu> hm, I'm screwing up with FFI?
12:30:44 <bollu> how do I release a pointer?
12:30:54 <mauke> bollu: how did you acquire it?
12:30:56 <bollu> oh wait, it's the library I'm using
12:31:04 <EvanR> not a haskell problem
12:31:09 <bollu> yeah, thought so
12:31:12 <puregreen> dkibi: yeah, the 1st variant was right
12:31:16 <bollu> cool, I gotta read up on finalizers now
12:31:27 <puregreen> I mean— ugh
12:31:38 <puregreen> (&&) :: Bool -> Bool -> Bool
12:31:53 <dkibi> puregreen: now I'm confused
12:32:00 <puregreen> liftA2 :: (Bool -> Bool -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool)
12:32:10 <dkibi> so it's (a ->)?
12:32:13 <puregreen> yeah
12:32:13 <puregreen> sorry
12:32:39 <dkibi> no problem, made me think about it myselfe which is the point of this ^^
12:32:50 <dkibi> -e
12:34:02 <dkibi> do you have any good tips/pointers on how to get a hang on those typeclasses?
12:34:09 <saurabhnanda> okay, too sleepy to think about this stuff now. will get back to it tomorrow. thanks EvanR geekosaur Cale jle` djbeau 
12:34:34 <EvanR> dkibi: try a bunch in the repl
12:34:40 <EvanR> read about them on typeclassopedia
12:34:53 <EvanR> implement them yourself
12:35:05 <djbeau> saurabhnanda: sometimes a good sleep can do wonders for a fresh perspective :)
12:36:05 <dkibi> typclassopedia looks great! thank you
12:36:50 <cocreature> dkibi: there is also nicta which contains a bunch of exercises a lot of them related to implementing certain type classes/instances https://github.com/NICTA/course
12:47:41 <jdmnd> @djinn [[a->b]]->[[a]]->[[b]]
12:47:42 <lambdabot> Error: Undefined type []
12:48:43 <bollu> can I "decay" a foreignPtr into a Ptr?
12:49:18 <jdmnd> @djinn f1(f2(a->b))->f1(f2(a))->f1(f2(b))
12:49:18 <lambdabot> -- f cannot be realized.
12:52:14 <geekosaur> :exf [[a->b]]->[[a]]->[[b]]
12:52:35 <geekosaur> bah. exferenceBot still missing
12:57:51 <bollu> I'm using stack, and I'm modifying stuff in a C library. I need stack to relink on a `stack build` even when my haskell file does not change
12:58:00 <bollu> is there a way to force stack to build / link?
12:58:45 <jle`> wrote some code late at night half-awake and woke up to find "big_bossa-too" as an attempt at a variable
12:58:47 <jle`> name
12:59:19 <jle`> i guess the takeway is that ghc stops you from coding when you're too tired because you start getting worse and worse type errors
13:00:46 <jdmnd> could anybody give me tips on how to construct [[a->b]]->[[a]]->[[b]] or how I'd derive it?
13:01:06 * hackagebot pipes-aeson 0.4.1.6 - Encode and decode JSON streams using Aeson and Pipes.  https://hackage.haskell.org/package/pipes-aeson-0.4.1.6 (RenzoCarbonara)
13:01:27 <jle`> jdmnd: what would you watn it to do?
13:01:36 <jle`> there are a couple of ways to write functions with that type
13:01:55 <jle`> one trivial way is foo _ _ = []
13:02:02 <jdmnd> i have a nested list of functions that i want to apply to a nested list of inegers
13:02:16 <jle`> do you want to 'zip' them together?
13:02:19 <Jinxit> zip, map?
13:02:21 <jle`> or apply them to each
13:02:27 <jle`> like liftA2-style
13:02:47 <jdmnd> apply each function to an individual element
13:02:50 <jle`> > [(+),(-),(*)] <*> [1,2,3] <*> [4,5,6]
13:02:52 <lambdabot>  [5,6,7,6,7,8,7,8,9,-3,-4,-5,-2,-3,-4,-1,-2,-3,4,5,6,8,10,12,12,15,18]
13:02:57 <jle`> can you show a specific example?
13:03:03 <jle`> of what functiosn would be applied to what element?
13:03:10 <jle`> just so there isn't any ambiguity
13:05:00 <bollu> > liftA2 ($) [(+ 1), (- 2), (* 3)] [4, 5]
13:05:02 <lambdabot>      No instance for (Show c0)
13:05:02 <lambdabot>        arising from a use of ‘show_M27736278317635897742130’
13:05:02 <lambdabot>      The type variable ‘c0’ is ambiguous
13:05:11 <jdmnd> like [[(+1),(*2)],[(*3),(+4)]] <??> [[2,3],[4,5]]
13:05:23 <bollu> jdmnd: do you want all combinations?
13:05:24 <jle`> and what would the result be?
13:05:53 <jle`> :t (map . map)
13:05:54 <lambdabot> (a -> b) -> [[a]] -> [[b]]
13:05:55 <jdmnd> [[3,6],[12,9]]
13:06:32 <jle`> :t zipWith (zipWith ($))
13:06:33 <lambdabot> [[a -> c]] -> [[a]] -> [[c]]
13:06:39 <jdmnd> oh i get it
13:06:44 <jdmnd> thanks
13:06:46 <jle`> np
13:06:53 <jdmnd> was confusing myself with <*>
13:07:04 <jle`> yeah, <*> does a every-possible-combination kind of merger
13:07:13 <jle`> zipWith does a n element-by-element zippy merger
13:07:29 <jle`> the two have the same signature, but just different combining strategies
13:07:45 <bollu> :t (zipWith . zipWith) ($)
13:07:46 <lambdabot> [[a -> c]] -> [[a]] -> [[c]]
13:15:03 <lyndon> Hey haskellers!
13:15:38 <puregreen> hi, hi
13:16:03 <cmotoche> Hey, whats up!
13:16:07 * hackagebot casa-abbreviations-and-acronyms 0.0.1 - CASA Abbreviations and Acronyms  https://hackage.haskell.org/package/casa-abbreviations-and-acronyms-0.0.1 (TonyMorris)
13:16:12 <lyndon> Is there any discussion around the planned additions of dependent types to ghc, and how the finite universe highrachy interacts with Russell's paradox, etc?
13:16:21 <lyndon> Just interested!
13:16:38 <lyndon> Couldn't find anything on the mailing list
13:18:33 <geekosaur> not a lot of discussion, but also not a lot of movement. it's not like it's going to suddenly show up full-blwon in some future ghc version
13:19:59 <lyndon> geekosaur: ah I see, I somehow got the impression that it was a definite thing coming "soon"
13:20:32 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell "Disclaimer: Everything below represents a research proposal. While it is my (RAE's) hope that something resembling this all will actually make it into GHC, no one should read anything too strongly into words like "will happen"."
13:20:50 <lyndon> But, I've not really looked into it too much, either haha.
13:20:58 <lyndon> Cheers for the link
13:21:05 <geekosaur> most of what is actually going in is type level programming, with hacks to reflect stuff between value level and type level that do not constitute true dependent types
13:21:07 * hackagebot pinchot 0.14.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.14.0.0 (OmariNorman)
13:21:14 <lyndon> I just thought that there would be some interesting discussion around it.
13:21:22 <lyndon> So I went for a quick search this morning.
13:21:36 <geekosaur> although they are often misunderstood as being dependent types or a lead-up to same
13:21:51 <geekosaur> true dependent types will require a *lot* more, and different, work from the current type level stuff
13:22:11 <lyndon> geekosaur: mm that definitely seems to follow the momentum from the community
13:22:27 <lyndon> type-level stuff being the motivation
13:22:58 <geekosaur> there are other approaches also going on, e.g. the refinement types of Liquid Haskell
13:23:44 <lyndon> Yeah I've been following Liquid Haskell from the periphery
13:23:50 <lyndon> Very interesting stuff.
13:24:16 <lyndon> But I was more intrigued about the proposal to make the kind system circular from what I gathered.
13:24:58 <geekosaur> well. ghc8 has kind and type levels unified. this still is not dependent types, just makes type level programming a bit easier without doing much about the boundary between value and type level
13:25:11 <geekosaur> which is the part that makes dependent types dependent, and also makes them kinda nasty
13:25:35 <lyndon> true
13:26:32 <dolio> I think they don't care much about paradoxes, because Haskell already lets you write false things in easier ways than constructing a paradox.
13:26:47 <dolio> Like 'let a = a in a'
13:27:55 <bollu> is there a default stack travis.yml file?
13:27:57 <lyndon> dolio: yes, that makes sense, and I appreciate the 'throw your hands up in the air' argument, but I think introducing new classes of paradox is still at the very least, interesting.
13:28:04 <bollu> >let 3 + 5 = 0 in 3 + 5
13:28:17 <bollu> > let 3 + 5 = 0 in 3 + 5
13:28:18 <lambdabot>  0
13:28:42 <bollu> https://travis-ci.org/bollu/symengine.hs/jobs/113769087 It's bizzare, it's rejecting "base"
13:29:25 <lyndon> Anyway, theory aside, has anyone had any luck deploying haskell in docker on elastic beanstalk multicontainer?
13:29:57 <lyndon> I'm about to put my first haskell service in "protoduction", and am getting stuck there.
13:30:03 <Zekka|Sigfig> > let 3 + 5 = 0 in 4 + 5
13:30:05 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
13:30:07 <Zekka|Sigfig> HA HA HA!
13:31:11 <aerialB> Zekka|Sigfig: ...what is that?
13:31:31 <Zekka|Sigfig> aerialB: bollu demonstrated one way to humorously define (+)
13:31:31 <sdx23> Exactly what you'd expect, no?
13:31:40 <lyndon> I realize that this is more of an aws question than a haskell one, but at least it's a haskell service :D
13:31:41 <puregreen> bollu: because your GHC version is 7.2.2
13:31:43 <Zekka|Sigfig> I pulled back the curtains on what they did
13:32:05 <puregreen> bollu: and you have a base>=4.7 constraint (and base can't be reinstalled, so you have to use whatever ships with GHC)
13:32:14 <sdx23> > let 0 * _ = 1 in 0*3
13:32:15 <lambdabot>  1
13:32:29 <bollu> puregreen: ohh, I see. I suppose I can relax the base constraint?
13:32:42 <bollu> puregreen: how do people write code that targets multiple GHC versions then?
13:32:48 <puregreen> either that, or don't test on GHC that is like 5 years old
13:32:52 <aerialB> How is that defining (+)? Isn't it defining a (invalid) use of (+)?
13:33:03 <puregreen> you have all versions from 7.0 to 7.10, that's a lot
13:33:07 <Zekka|Sigfig> aerialB: This might help
13:33:13 <puregreen> usually people support 3 last versions
13:33:17 <Zekka|Sigfig> > let g 3 5 = 0 in g 4 5
13:33:19 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function g
13:33:27 <Zekka|Sigfig> > let (+) 3 5 = 0 in g 4 5
13:33:28 <lambdabot>      No instance for (Show a0)
13:33:28 <lambdabot>        arising from a use of ‘show_M40545233900462275682887’
13:33:28 <lambdabot>      The type variable ‘a0’ is ambiguous
13:33:29 <aerialB> oh!
13:33:37 <Zekka|Sigfig> er, that should have been (+) 4 5
13:33:41 <aerialB> that's cool!
13:33:53 <conduit_header> I am using the conduit api and would like to strip off the header from the file.
13:33:59 <conduit_header> How do i do that?
13:34:10 <bollu> puregreen: and which versions are those?
13:34:32 <bollu> puregreen: I'm not sure familiar with the GHC timeline / versions
13:34:41 <bollu> hm, I'm running 7.10
13:35:09 <bollu> so I'm guessing people tell on versions till 7.6.3?
13:37:19 <puregreen> yep
13:37:19 <puregreen> and GHC 7.0 was released in 2010
13:49:36 <dmwit> conduit_header: I'm pretty sure you haven't given enough details yet.
13:49:56 <dmwit> What is "the header"? What does "the file" contain?
13:49:58 <conduit_header> my apologies.
13:50:03 <conduit_header> its a csv file: 
13:50:10 <dmwit> Don't paste here.
13:50:11 <conduit_header> and first line is the header.
13:50:15 <dmwit> ?lpaste
13:50:15 <lambdabot> Haskell pastebin: http://lpaste.net/
13:50:35 <dmwit> I think there are various CSV parsers on Hackage. Probably some of them even support conduit.
13:50:51 <Clint> possibly ones named csv-conduit
13:51:02 <conduit_header> http://lpaste.net/154043
13:51:34 <conduit_header> right now i am processing the first line..and deleting the record from the database. But it is obviously not desirable.
13:51:45 <conduit_header> let me chk csv-conduit.
13:52:26 <dmwit> Data.Conduit.List appears to offer `drop`; perhaps it could help.
13:56:22 <conduit_header> @clint: csv-conduit is quite powerful. Let me try to play with it. I was thinking that I could just change from IO to State..let me also try that so i could get by for now without another dependency.
13:56:22 <lambdabot> Unknown command, try @list
13:57:20 <dmwit> Have you tried just sticking `drop 1` in your conduit...?
13:57:23 <Sonolin> I'm a little confused
13:57:29 <conduit_header> @dmwit: I need to drop a number of bytes before the first line..and take every after that. the way lines function in Data.Conduit.binary work is it puts them back as a bytestring.
13:57:29 <lambdabot> Unknown command, try @list
13:57:49 <Sonolin> using MonadRandom (RandT transformer) - how do I generate random numbers *inside* the monad?
13:57:58 <danilo2> Hello guys! I'd like to ask you about nomenclature (in Haskell and general in functional languages - or in languages in general) - does "patterns" belong to "expressions" ? Can we tell that Patterns are build out of pattern-terms? 
13:58:01 <conduit_header> let me try that, dwit.
13:58:07 <Sonolin> I tried "getRandomR" and that works the first time, but consecutively returns the same random number(s)
13:58:25 <scshunt> Sonolin: can you paste a minimal testcase?
13:58:26 <dmwit> Sonolin: Which `getRandomR` did you try?
13:58:36 <EvanR> danilo2: patterns arent expressions, but they have similar grammar 
13:58:48 <EvanR> they are a separate sort
13:58:51 <Sonolin> sure one sec
13:59:19 <danilo2> EvanR: how would you name the common group of patterns and expressions?
13:59:38 <dmwit> danilo2: I wouldn't.
13:59:40 <EvanR> you wouldnt, where is that group used?
13:59:44 <mpickering> At what stage of compilation do TH splices get spliced in?
14:00:11 <dmwit> mpickering: Right after parsing, I think.
14:00:25 <EvanR> "expression" and "pattern" are used in different places
14:00:40 <EvanR> no need to have a "expression" or "pattern" thing
14:01:02 <danilo2> dmwit, EvanR : it isnt, I'm just trying to improve my naming convention, and every answer to these questions just clarifies things to me :) They could seem stupid, but I just want to be sure I'm using the terms in right context.
14:01:21 <EvanR> the whole program is a bunch of declarations
14:01:30 <danilo2> Ok, so could we tell that patterns are build out of pattern - terms? Like expression are build out of terms ?
14:01:34 <EvanR> f x = x + 1 is a definition
14:01:50 <dmwit> Expression is a synonym for term, I think.
14:01:59 <danilo2> (again - I'm talking about general programing language naming convention, not only Haskell specific, but it should be closely related though)
14:02:14 <Sonolin> here's my code: https://github.com/MichaelMackus/hsrl/blob/dungeon-generator/RL/Setup/Dungeon.hs#L52-L69
14:02:22 <EvanR> theres different kinds of pattern terms, you should name them all
14:02:24 <dmwit> I dunno. Maybe "expression" is more specific than term.
14:02:28 <danilo2> dmwit: in math not, in math term is a single "term" single unit, that you can apply operators etc on and you get expressions
14:02:31 <Sonolin> newbie so be gentle, I'm sure I'm doing plenty wrong :)
14:02:45 <EvanR> math isnt a single language
14:02:51 <haskell513> @free f :: [a] -> [a]
14:02:51 <lambdabot> $map g . f = f . $map g
14:02:59 <Sonolin> here's the roll function using getRandomR: https://github.com/MichaelMackus/hsrl/blob/dungeon-generator/RL/Setup/Dungeon.hs#L146-L150
14:03:03 <danilo2> EvanR: sure, and because of that I'm asking you for help! :D
14:03:09 <mpickering> dmwit: That's right, thanks
14:03:14 <haskell513> @free fmap :: (a -> b) -> F a -> F b
14:03:14 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
14:03:48 <dmwit> danilo2: ...huh?
14:03:53 <dmwit> Sonolin: That's not very minimal...
14:04:16 <danilo2> so how would you name the smallest unit of patterns - like variables? If for examples the common name for variables, literals, constructors is "term" and we buidl expression out of terms (at last these nomenclature I've seen used a lot), how can we name such abstractions in the "pattern world" ?
14:04:30 <EvanR> variable pattern?
14:04:35 <conduit_header> Sonolin: i checked it real quick: dont we need state.get/put somewhere?
14:04:44 <EvanR> literal pattern
14:04:49 <EvanR> ctor pattern
14:04:56 <Sonolin> yea I need the state getter/setters
14:04:59 <EvanR> wildcard pattern
14:05:00 <Sonolin> but it should work as is
14:05:12 <Sonolin> that's just to check whether the cell is touching (just working on rand atm)
14:05:39 <EvanR> danilo2: terms is really general, everything is a term
14:05:39 <conduit_header> though, i have to concur with dmwit.the code is not minimal so we could import and test it.
14:05:45 <Sonolin> I guess I thought since I'm in RandT that "getRandomR" should automatically take care of setting new generators, right?
14:06:04 <dmwit> Sonolin: Right.
14:06:22 <EvanR> danilo2: for atomic expressions not made out of other things you could say atoms
14:06:31 <EvanR> or constants
14:06:34 <danilo2> dmwit: I'm talking about something like this (in fact a lot of websites claim that terms are part of expressions in math - one of the first google-sites: http://www.mathwords.com/t/term.htm )
14:06:51 <EvanR> meh
14:07:00 <EvanR> random math terminology dogma ;)
14:07:14 <EvanR> language is made up do whatever
14:07:31 <dmwit> danilo2: That's the joy of math, I guess. You can make any word mean anything just by telling the reader what you want it to mean.
14:07:44 <dmwit> danilo2: There is a different convention in programming languages than that one, from what I've seen.
14:08:01 <conduit_header> dmwit: i did something like so: lines =$= drop 1 =$= parseEachLine ...drop 1 returned an empty list, i didnt think that drop was meant to drop at limiters.
14:08:03 <shachaf> dmwit: Oh, did you get kicked out of the other channel for not using TLS?
14:08:33 <dmwit> shachaf: I guess.
14:08:46 <danilo2> EvanR, dmwit: heh ;) Ok, so lets assume you write a parser. How would you name the module containing definition of posible "terms" (in the meaning they could build "expressions" (in "normal meaning")) and again - how would you name module with "terms" for "patterns" ? 
14:09:47 <Sonolin> ah this probably just boils down to my misunderstanding of applicative
14:09:48 <dmwit> What's wrong with "expression" and "pattern"?
14:09:49 <Sonolin> evalRandIO (take 5 >$> repeat >$> getRandomR (1,5))
14:09:54 <Sonolin> doesn't quite do what I want
14:10:04 <jle`> what is >$> supposed to do?
14:10:05 <Sonolin> evalRandIO (take 5 <$> repeat <$> getRandomR (1,5))
14:10:12 <Sonolin> (sorry, xmonad paste hates me >.>)
14:10:18 <jle`> ah yeah
14:10:28 <jle`> maybe it'd be easier to see it as (take 5 . repeat) <$> getRandomR (1,5)
14:10:36 <dmwit> conduit_header: I know basically nothing about conduit. But if you give me a tad more code -- enough I can run it myself -- I would be willing to take a look.
14:10:40 <Sonolin> ah!
14:10:42 <jle`> it executes getRandomR once, to get a random number from 1 to 5
14:10:48 <jle`> and then it fmaps (take 5 . repeat) on taht number
14:10:54 <danilo2> dmwit: hah thats a great question. In fact Ive got parts of parser that are used for parsing both "terms" of expressioins as well as "terms" of patterns - and I want to refactor them to common module. I'm justl ooking for appropriate name here
14:11:01 <Sonolin> thank you that makes sense now!
14:11:14 <jle`> you might want something like replicateM 5 (getRandomR (1,5))
14:11:28 <jle`> which executes getRandomR (1,5) five different times to get five random numbers, and aggregates them in a list
14:11:30 <scshunt> or just take 5 <$> getRandomRs (1,5)
14:11:30 <EvanR> danilo2: you name the top level first, so "program"
14:11:38 <EvanR> danilo2: then you name each piece, until youre done
14:11:43 <conduit_header> let me login to a different host and then paste code, my dev host cant talk to the net :).
14:11:50 <EvanR> and you end up not needing to have a name for everything
14:12:07 <Sonolin> thanks guys that's perfect :D
14:12:18 <jle`> np!
14:12:30 <EvanR> danilo2: every grammatical construction rule.. ive heard these called "productions"
14:12:31 <danilo2> EvanR:Ok, I was not clear enoguh. I've got "term" parsers, that are used for parsing BOTH pattern as well as expression "terms" - and I'm just looking for confimartion if word "term" is ok, or I should look for different naming here
14:12:38 <conduit_header> though, it seems to me that this is something i have to handle, passing state to all the parts of the conduit. I will have to look into that. Thanks.
14:13:07 <EvanR> danilo2: why do you heven have expression terms?
14:13:12 <danilo2> EvanR: productions are not semantically connected to expressions. production is everything that derives from production rules, terminals and nonterminals :P
14:13:19 <EvanR> arent the constituents of expressions also expressions?
14:14:32 <danilo2> EvanR: Of course we cna assume that expression consist out of expressions, but as someone above claimed patterns are not expressions and I use the exacts same parsers for parsing "parts" of patterns, I'm looking for common terminology here
14:14:47 <EvanR> well thats kind of silly
14:14:55 <danilo2> :D
14:15:16 <EvanR> if its exactly the same, then whats the difference?
14:15:22 <EvanR> its all expressions
14:15:39 <aerialB> "Couldn't match expected type ‘a1’ with actual type ‘a’" what does this usually indicate? I've used `a` in my type signatures.
14:15:54 <EvanR> otoh if there is a difference, they shouldnt be the same
14:16:14 <exio4> is there any easy way to generate a binary which will work with older glibcs? using GHC
14:16:18 <EvanR> this is a case of "noDRY"
14:16:26 <dmwit> EvanR: I don't know that it's silly. Let's take Haskell: patterns contain variables, literals, and some other stuff; expressions contain variables, literals, and some other stuff. Might as well share the parsers for variables and literals.
14:16:37 <exio4> I don't want to install a compiler in this host, and it has an old version of the libc (and libffi)
14:16:45 <exio4> s/host/machine/
14:16:51 <danilo2> EvanR: ok, so we've got literals right? Literals are also expressions. We've got "indentifier parsers" - identifier can vbe used both as a variable expression as well as pattern. There is a ton of such parsers that can be used both as expressions as well as patterns, but there are also parsers, that combine them, but are just either expressions or patterns (not both of them at the same time). 
14:16:56 <EvanR> dmwit: the lowest level has names, variable, literaly, etc
14:17:10 <danilo2> dmwit: exactly!
14:17:32 <EvanR> im just not seeing the point wehre you need to combine two things that are not the same and given the an identical name
14:18:40 <danilo2> EvanR: so you've got lets say 50 parsers, like literals parsers, variables, constructors, applications etc, tht you use in both patterns as well as expressions. Where you put them? (I'm asking of course about module name)
14:18:40 <EvanR> pattern = [fmap PatLit literal, fmap PatVar var]
14:18:48 <dmwit> danilo2: Okay, so what's the problem? Call literals "literals", and call variables "variables". Why do you need a name that means "the shared parts of expressions and patterns, namely literals and variables"?
14:18:54 <EvanR> expr = [fmap ELit literal, fmap EVar var]
14:19:08 <EvanR> sequence 
14:19:19 <EvanR> choice
14:19:29 <danilo2> dmwit: the problem is that there is so many such aprsers, taht I can create "variables" module, "application" module, etc, but I'll end having 30-50 modules like that
14:19:54 <dmwit> danilo2: I think I would just have one parser module that had all my parsers in it.
14:20:02 <dmwit> What's the benefit of splitting up further than that?
14:20:09 <EvanR> if theres no obvious way to split them up because they are sharing between them, then just dont split them up
14:20:30 <danilo2> dmwit: just to clarify things out. I hate files that are couple of thousands of line long. 
14:20:52 <EvanR> IHateLargeFiles0.hs IHateLargeFiles1.hs.... ;)
14:21:08 <dolio> Do you need thousands of lines to describe your grammar?
14:21:09 <danilo2> EvanR: :D thats definitelly a good solution :D
14:21:13 <EvanR> your IDE should be able to handle either way
14:21:42 <dmwit> aerialB: paste some code
14:22:27 <danilo2> dolio: If you want to partition the grammar well and write all kind of well - matched monadic parsers with all expression ;/ patterns / type /layouting machinery you end up having 1-2k lines. Currently I've got sometihng like that
14:23:01 <aerialB> dmwit: https://gist.github.com/TiredSounds/be676d1485b8372c5831 was just about to :)
14:23:19 <dmwit> I dunno. I wouldn't sweat the naming much. Perhaps "common" for the really small parsers or something.
14:24:01 <dmwit> aerialB: Okay, the problem here is that you probably expect the `a` in the sig for `primeSeive` and the `a` in the sigs for `primeIter`/`multsOf` to be the same `a`.
14:24:04 <dmwit> aerialB: But they're not.
14:24:19 <dmwit> aerialB: ...which is an unfortunate wart.
14:24:34 <aerialB> I see, so I should use b and c as the type variables?
14:24:36 <dmwit> aerialB: You can fix this by turning on ScopedTypeVariables and adding `forall a.` to the front of the signature for `primeSeive`.
14:24:55 <raichoo> Heya. I'm currently refactoring the haskell-vim indentation. Testers welcome but please be aware that I cannot support every style. If you find something you think should be supported please file an issue: https://github.com/raichoo/haskell-vim
14:25:14 <dmwit> aerialB: No, you cannot fix this by renaming those types -- because what I'm telling you is that GHC is already doing that.
14:25:24 <aerialB> dmwit: ah ok.
14:25:31 <aerialB> wow that is strange
14:25:54 <geekosaur> tbh those bindings should just be inferred, not explicitly typed
14:26:02 <dmwit> aerialB: As in, *you* the programmer think they should be the same type and have written your code as if they are the same -- witness `curr > n`, which demands that the `n :: a` where `a` is from `primeSeive` and the `curr :: a` where `a` is from `primeIter` be the same...
14:26:24 <dmwit> aerialB: ... -- but GHC is treating them as if they are *different* type variables.
14:26:40 <aerialB> right
14:27:09 <davean> Honestly, I've generally felt that ScopedTypeVariables should be the default. Its what I want virtually all the time, but it isn't. The requirement for forall is also a wart.
14:27:18 <dmwit> aerialB: Which in some sense they are, right? You've claimed that `primeIter` works for *any* instance of `Integral`, but in fact it only works for specifically the same instance as is being used by `primeSeive`.
14:27:26 <dmwit> aerialB: By the way, it's spelled "sieve". ;-)
14:27:36 <dmwit> davean: Agreed, on both points.
14:28:12 <geekosaur> davean, there are many people who agree with you but the Haskell committee has in the past been afraid of breaking old programs
14:28:25 <davean> geekosaur: Yah, I know, nd that deeply saddens me
14:28:36 <davean> geekosaur: I really wish haskell would move forward more
14:28:39 <geekosaur> I dont think anyone knows how many programs might be broken by unexpectedly enlarging the default scope
14:29:11 <dolio> If the forall weren't required, how would it work? Names are scoped out to their first appearance?
14:29:21 <davean> geekosaur: well, it seems one could make a ghc-api program that figured out for a given package if there was a change
14:29:25 <EvanR> yet old programs are regularly broken anyway
14:29:34 <EvanR> i guess because of libraries
14:29:42 <geekosaur> sure. then you get to deal with the existing code that isn't on hackage
14:29:44 <aerialB> dmwit: thanks!
14:29:48 <davean> EvanR: it does seem a slightly silly distinction
14:30:26 <dmwit> dolio: It would work exactly the way it does now, except the "sense" of forall would be swapped -- with no forall it would behave as it does now when there's a forall, and with a forall it would behave as it does now with no forall.
14:31:18 <dolio> dmwit: When there's a forall where?
14:31:50 <dolio> When you're scoping now, you have to quantify all variables at the place you want them to end up.
14:32:42 <dmwit> I'm not sure I understood your question yet.
14:33:00 <dmwit> Nor what "where you want them to end up" means.
14:33:47 <dolio> Well, if you implement what you wrote literally, the situation is no different than with scoped type variables off, I think.
14:34:01 <dolio> Because your local signatures without foralls behave as if they have foralls, so the types don't match.
14:34:19 <dolio> So local signatures behave differently than top level ones, presumably.
14:34:25 <dmwit> eep
14:34:28 <dmwit> That's a nasty complaint.
14:34:57 <dolio> But if a local signature mentions a variable that isn't in the top level, where does the quantifier go?
14:35:05 <dolio> To the top level, or stay local?
14:35:21 <dmwit> right
14:36:13 <John[Lisbeth]> how are closures different than lambdas?
14:36:49 <dmwit> "Is it a lambda or not" is a syntactic question.
14:37:00 <geekosaur> a lambda that captures bindings from an outer scope can act as a closure
14:37:20 <dmwit> "Is it a closure or not" is an operational question.
14:37:48 <dolio> Closures are an implementation technique for first-class functions. Lambdas are a syntactic notation for functions.
14:37:52 <geekosaur> otherwise, what dmwit said: a lambda is a syntactic form, a closure is a semantic form, the syntax may or may not give rise to the semantics depending on context
14:37:54 <dmwit> `\x -> x` is a lambda that is not a closure. `map (+1)` is a closure that is not a lambda.
14:38:17 <larryba> uhm how is map (+1) a closure?
14:38:54 <c_wraith> larryba, it closes over the function (+1)
14:39:35 <c_wraith> amusingly, (+1) is also a closure. 
14:40:01 <dmwit> Sure, though it's not as clear that `(+1)` is not a lambda. ;-)
14:40:34 <bollu> guys, I'd like to have a pseudo-mentor like person for my GSoC project which is to bind symengine to Haskell. I've started work on this, and I have the backing of SymPy. I'd just like a Haskell contact point that I can ping with questions and stuff once in a while related to FFI/Haskell design / stuff like that - https://github.com/bollu/symengine.hs
14:40:50 <bollu> does anyone on the channel wish to take this up? where can I post this sort of thing?
14:40:50 <larryba> c_wraith by that logic (+) 1 is also a clojure?
14:40:53 <larryba> closure
14:40:56 <bollu> haskell-cafe?
14:42:05 <c_wraith> larryba, yes. it's a function-typed expression that requires holding on to memory to evaluate. 
14:42:33 <larryba> I am pretty sure it has to capture a variable to be called a closure. not a literal value
14:42:37 <dmwit> In Haskell, even values with non-function types are often closures.
14:43:28 <c_wraith> larryba, what's the difference in Haskell? values are values. 
14:43:41 <dmwit> larryba: Okay, no problem. `map f` is a closure that is not a lambda.
14:45:58 <c_wraith> larryba, closures are an implementation technique that consists of packing a pointer to code with values used as implicit arguments to that code. 
14:46:42 <c_wraith> larryba, which is totally independent from lambdas, which are a syntactic method to define a function without naming it. 
14:46:53 <c_wraith> larryba, neither needs the other. 
14:51:33 <larryba> c_wraith i understand the difference between closures and lambdas. just never saw anyone call a function (or a lambda) that uses a literal value a closure. but i guess it could be called a closure
14:52:39 <c_wraith> well, in the absence of advanced in lining optimizations, ghc will implement (+1) as a closure. 
14:53:28 <c_wraith> of course, when compiling with -O2, it often does inline things like that away. 
14:54:37 <EvanR> larryba: variables dont really exist as runtime, so closures (runtime technique) dont really care about them
14:55:44 <EvanR> at runtime*
14:56:10 <larryba> from wiki (not the best source..) "In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions."
14:56:15 <larryba> "name binding"
14:56:25 <larryba> that is the definition i had in mind
14:56:47 <mauke> I disagree with that definition, btw
14:57:17 <c_wraith> (+1) is actually implicitly binding a name.. the name used by the second argument of the (+) function. 
14:57:35 <larryba> 1 is a name?
14:57:56 <c_wraith> no, it's the value being bound to the name. 
14:58:13 <c_wraith> the name is probably something like y
14:58:21 <EvanR> the whole point of anonymous functions is to not care about names
14:59:04 <EvanR> and the point of lexical closure (in a pure context) is to not care about how to wrangle a scope at runtime
14:59:17 <EvanR> so chill out!
14:59:25 <c_wraith> though haskell isn't really big on naming arguments, either. 
15:00:12 <larryba> c_wraith by your definition every single language has closures. because all the languages allow you to use literal values in functions
15:00:40 <c_wraith> larryba, no, only ones that let you pass around partially applied functions. 
15:00:42 <geekosaur> old versions of fortran only did so as a bug
15:00:54 <geekosaur> (that could be exploited in fun ways)
15:01:08 <larryba> not sure what partial application has to do with this
15:01:41 <davean> larryba: its how you reify it
15:01:45 <EvanR> closure and partial application is isomorphic
15:01:57 <c_wraith> larryba, there's no need to implement something with closures if no values are closed over. 
15:02:55 <c_wraith> larryba, if your language prevents closing over values, like C for instance, then there's no need to for the implementation to have closures. 
15:04:26 <maerwald> is there a haskell thing where you can source a shell script in a limited environment?
15:04:48 <maerwald> as in: don't allow stuff like disc access, but variable expansion
15:05:30 <maerwald> probably too specific I guess
15:05:50 <EvanR> shell exec a script starting with chroot?
15:06:42 <maerwald> EvanR: well, I want to source shell scripts that may do weird things, but I'm only interested in the variable expansion, which is 99% of the time static. So I don't want to run actual code, more or less
15:06:59 <EvanR> oh, so you want to shell escape a string
15:07:20 <ReinH> maerwald: run it in a docker container.
15:07:23 <maerwald> haha
15:07:23 <EvanR> or substitute
15:07:35 <ReinH> Doesn't protect you completely, but better than nothing.
15:07:47 <maerwald> yes, I am familiar enough with docker to do that, but was just wondering if something similar to that has been implemented
15:07:52 <EvanR> exec a script that does nothing to get the variables to expand, instead of one that does weird things
15:08:07 <maerwald> limited shell script sourcing or how you'd call that
15:08:57 <c_wraith> sandboxed execution? 
15:09:41 <maerwald> yeah, but stuff like shelly doesn't seem to support that
15:10:19 <c_wraith> it's a hard problem. I'm not sure it's fully solved anywhere. 
15:31:37 <fr33domlover> I downloaded a package from Hackage and made some modifications locally. How can I tell stack to use it instead of the Hackage one?
15:32:05 <fr33domlover> (temporarily until my change gets merged upstream)
15:36:21 <runeks> Can anyone give some pointers on how to create a Reader+Writer monad in which Reader operations recv from a TCP Socket, and Writer operations write (send) messages to the same socket? I'm not sure if this is the right way to go, but it seems sensible to me.
15:36:59 <Clint> it's not
15:38:06 <runeks> Clint: Go on
15:38:13 <marchelzo> reader is for when your state is constant, but you want to share it implicitly
15:38:22 <marchelzo> like a configuration
15:38:28 <runeks> Ah!
15:39:15 <meijigan> it seems like i've broken cabal
15:39:47 <meijigan> while i try to install ghc-mod it says that something failed during the building phase. The exception was: ExitFailure 1
15:39:51 <runeks> Well then. Is there a monad that is especially suitable for modelling Socket recv and send operations?
15:40:04 <EvanR> runeks: perhaps pipes would make sense for that
15:40:14 <marchelzo> the IO monad :P
15:40:49 <EvanR> oh SEND and recv...
15:41:12 <fr33domlover> `stack test` gives me this error: http://paste.rel4tion.org/279
15:41:15 <EvanR> runeks: you probably want to try out threads and mvars, these are easy building blocks
15:41:19 <fr33domlover> what could cause it?
15:42:03 <EvanR> converting fragmentary byte strings from the socket into usable data may not be easy
15:42:19 <EvanR> but there are pipes and conduits
15:42:50 <runeks> EvanR: Only a single thread will be reading from the Socket at a time. Is MVar still useful then?
15:43:06 <EvanR> use the MVar for sending
15:43:29 <EvanR> another single thread (heh) will be blocked taking from that, and then turn around and send it on the socket whenever
15:44:00 <EvanR> or you could write directly 
15:44:47 <EvanR> the reader might need an mvar if there is other stuff going on while he is blocked
15:47:25 <emmanuel_erc> Hello there. So I recently for a review of my code on /r/haskell today. It has been suggested that I tend to use the pointfree style too much. I can understand that it can make Haskell code hard to follow, but is it generally not worthwhile to use the pointfree style if you are trying to write efficient code?
15:48:02 <fr33domlover> emmanuel_erc, are you sure pointfree has anything to do with efficiency?
15:48:25 <EvanR> @pl (\x y z w -> w (2*x + y * z))
15:48:26 <lambdabot> ((flip id .) .) . (. (*)) . (.) . (+) . (2 *)
15:48:32 <fr33domlover> iirc it's just a readability / conciseness thing
15:48:52 <fr33domlover> use it when it helps, don't use it when it harms :P
15:48:55 <EvanR> the more obtuse the code the faster it is
15:49:16 <EvanR> its like the improbability engine
15:49:18 <emmanuel_erc> Why would that be the case EvanR?
15:49:24 <marchelzo> I knew there was a reason J was sos fast
15:49:26 <marchelzo> so*
15:49:46 <EvanR> emmanuel_erc: its not but that is a classic technique in C 
15:50:02 <EvanR> and javascript
15:50:21 <emmanuel_erc> EvanR: I see.
15:50:34 <EvanR> some pointfree is too awkward to be worth it
15:50:48 <EvanR> otoh sometimes you dont need all the variables and they are just noise
15:53:50 <marchelzo> i bet there's an alien race out there that reads pointfree code naturally and thinks pointful code is obtuse
15:53:54 <Hijiri> 0/buffer 20
15:54:38 <maerwald> marchelzo: I think people overuse pointfree code where it is pointless to use
15:56:22 <emmanuel_erc> maerwald: I am probably guilty of that.
15:56:41 <maerwald> it's annoying
15:57:04 <jle`> emmanuel_erc: note that ghc inlines calls to simple functions, so foo = (f . g) x is compiled to literally the same thing as f (g x) for the most part
15:57:05 <maerwald> it depends on the function and the context... whether pointfree or pointful style makes it easier to understand
15:57:11 <jle`> because (f . g) x = f (g x)
15:57:16 <jle`> as per the definition of (.)
15:57:26 <emmanuel_erc> jle`: gotcha
16:08:33 <mniip> jle`, not f . g = \x -> f (g x)
16:08:34 <mniip> ?
16:09:18 <mniip> which would make the most common use, a . b, a fully saturated application
16:09:31 <jle`> hm, i'm not sure :o
16:13:05 <djbeau> runeks: I have to leave, but check out the pipes-network package
16:13:12 <djbeau> not sure if it fits your bill though
16:13:59 <runeks> djbeau: I've looked at that. I don't understand how to "await" a ByteString of fixed length.
16:14:37 <joepym> hey all - struggling with a beginner question. How would I represent an array of int, array as a data type? e.g. [[1,[A,B]],[2,[B,C]]]
16:16:13 * hackagebot wai-middleware-throttle 0.2.1.0 - WAI Middleware for Request Throttling  https://hackage.haskell.org/package/wai-middleware-throttle-0.2.1.0 (ChristopherReichert)
16:19:15 <hoot> Has anyone here used docker for haskell development? If so, how was the experience?
16:19:21 <jle`> joepym: you can create an ADT
16:19:27 <fr33domlover> joepym, (1) read the haskell wikibook or other haskell course/tutorial (2) you want an array of tuples e.g. [(Int, [Bool])]
16:19:41 <jle`> data MyType = MT Int [Stuff]
16:19:46 <mgsloan> hoot: Pretty great, particularly with stack's docker integration
16:20:00 <jle`> or yeah, just a simple tuple would work too :)
16:21:02 * magicman learns that accursedUnutterablePerformIO is a thing.
16:21:18 <magicman> For when unsafe just doesn't cut it.
16:21:38 <joepym> thanks jle, fr33domlover. Am currently working through learnyouahaskell, but couldn't get that bit working. ADT worked fine
16:22:28 <hoot> mgsloan: Awesome. Man, haskell is seeming better and better
16:22:42 <Maxdamantus> git grep '\<unsafe' && echo bad || echo good
16:25:11 <marchelzo> case m realWorld# of (# _, r #) -> r -- what do the #s in here mean?
16:25:36 <scshunt> marchelzo: they're the kind of unboxed types
16:25:39 <magicman> (# a, b #) is unpacked tuple notation, IIRC.
16:25:46 <scshunt> ^
16:25:50 <magicman> *unboxed, oops.
16:25:53 <scshunt> that's a better explanation
16:26:31 <magicman> realWorld# is a variable name. The # suggests it deals with unboxed data, but itself is meaningless in this case.
16:27:27 <marchelzo> do you need an extension for # in identifiers?
16:27:48 <Zemyla> Sigh. Map is *almost* an Applicative.
16:28:55 <scshunt> but it's not one and for a good reason!
16:30:34 <Zemyla> scshunt: Well, the only reason is that I think just on some key types, the <*> function isn't associative.
16:31:14 <scshunt> Zemyla: what is pure
16:31:52 <Zemyla> pure = singleton mempty.
16:32:13 <Zemyla> The key has to be a Monoid as well as an Ord.
16:32:31 <EvanR> marchelzo: MagicHash
16:32:39 <scshunt> that's a complete abuse of monoid
16:33:12 <Zemyla> scshunt: Not really, not if you think of Map k v as analogous to [(k, v)].
16:33:42 <marchelzo> if you never use <>, it's probably a misuse of monoid
16:33:43 <EvanR> Map k v is a monoid anyway right
16:33:49 <Zemyla> marchelzo: I do use <>.
16:33:50 <scshunt> Zemyla: It is, because pure f won't do what you want
16:33:56 <marchelzo> Zemyla: why?
16:34:07 <EvanR> <> is union
16:34:33 <marchelzo> EvanR: on maps, yes, but what is it on the keys?
16:34:42 <scshunt> Zemyla: in particular, you won't satisfy fmap f x = pure f <*> x
16:34:42 <Zemyla> mf <> ma = M.foldMapWithKey (\kf f -> M.fromList $ fmap (\(ka, a) -> (kf <> ka, f a)) $ M.toList ma) mf
16:34:43 <EvanR> why are we using it on keys
16:35:25 <Zemyla> Because Map k a is analogous to [(k, a)], which is WriterT k [] a.
16:37:44 <Zemyla> And I think that it is an Applicative if for all ka kb kc. (ka <> kb) == (ka <> kc) => kb == kc.
16:38:20 <Zemyla> And similiarly (ka <> kc) == (kb <> kc) => ka == kb.
16:39:14 <EvanR> so uh
16:39:25 <marchelzo> is there a name for monoids/semigroups with that property?
16:39:28 <EvanR> the reason Map is not applicative is because it cant be a Functor
16:39:36 <Zemyla> EvanR: You're thinking of Set.
16:39:41 <EvanR> oh.
16:39:43 <Zemyla> Map can be a Functor on its values.
16:40:08 <EvanR> in that case
16:40:18 <EvanR> its a moral applicative, if not actually one
16:40:25 <scshunt> Zemyla: how do you define <*>?
16:40:40 <Zemyla> I already did, but I typoed it as <>.
16:40:44 <EvanR> apply the function to the argument pointwise
16:40:49 <Zemyla> mf <*> ma = M.foldMapWithKey (\kf f -> M.fromList $ fmap (\(ka, a) -> (kf <> ka, f a)) $ M.toList ma) mf
16:40:58 <EvanR> if no argument is found, then nothing
16:41:07 <EvanR> if no function is found, then nothing
16:41:24 <EvanR> so intersection
16:41:42 <scshunt> that violates the Applicative laws then
16:41:55 <EvanR> phooey
16:42:00 <scshunt> fmap f x = pure f <*> x
16:42:12 <scshunt> pure f would have to be a Map with f at every key
16:42:20 <EvanR> pure needs to be an infinite map
16:42:28 <EvanR> so you need Enum ;)
16:42:40 <scshunt> either that
16:42:45 <Zemyla> scshunt: In mine, pure = singleton mempty.
16:42:49 <scshunt> Zemyla: right
16:42:54 <scshunt> which means it violates the law I quoted
16:43:05 <Zemyla> No, because the (<*>) is different.
16:43:07 <scshunt> EvanR: or you just use (k -> v) since that is isomorphic to an infinite map ;)
16:43:30 <scshunt> Zemyla: what is pure f <*> singleton (somethingelse) x
16:43:33 <EvanR> yeah Map is like real world troll version of k -> v
16:44:56 <Zemyla> scshunt: pure f <*> singleton k x = M.fromList $ fmap (\(ka, a) -> (mempty <> ka, f a) [(k, x)] = M.fromList [(k, f x)] = singleton k (f x).
16:45:31 <scshunt> Zemyla: right, now evaluate it for k /= mempty
16:45:33 <scshunt> what do you get?
16:45:51 <Zemyla> The mempty is from pure f = singleton mempty f.
16:45:58 <scshunt> Zemyla: right
16:46:14 <scshunt> but now suppose that k is not mempty
16:46:20 <scshunt> what does the expression reduce to?
16:46:25 <Zemyla> I am supposing k is not mempty.
16:46:29 <scshunt> agreed
16:46:48 <Zemyla> singleton kf f <*> singleton ka a = singleton (kf <> ka) (f a), no matter what kf and ka are.
16:52:54 <scshunt> oh
16:53:02 <scshunt> hmm
16:53:08 <scshunt> I misread what you're doing
16:54:01 <scshunt> that obviously won't work if the monoid isn't commutative
16:54:31 <scshunt> no, wait, what's the monoid on Map
16:54:44 <scshunt> ah, yep
16:54:44 <scshunt> yeah
16:54:51 <Zemyla> scshunt: Sure it will. It'll work for things like [k], for instance.
16:55:07 <scshunt> Zemyla: No, because the traversal order matters
16:55:11 <scshunt> although hmm
16:55:32 <scshunt> you need the monoid on Map to be commutative, which it isn't
16:56:41 <Zemyla> It shouldn't need commutativity.
16:57:16 <scshunt> foldMapWithKey uses the monoid on Map
16:57:21 <scshunt> which is not commutative
16:57:26 <scshunt> so the result depends on the traversal order
16:58:27 <scshunt> unless I'm misreading the docs and the traversal order is defined
16:58:40 <Zemyla> Traversal order is defined. It goes in Ord order.
16:59:14 <Zemyla> It's not like a HashMap, where the order is ill-defined.
16:59:45 <scshunt> hmm
16:59:48 <Zemyla> But yeah, I think the only condition is that it needs to be a cancellative monoid.
16:59:48 <scshunt> ok
16:59:53 <scshunt> cancellative?
17:00:01 <Zemyla> https://en.wikipedia.org/wiki/Cancellative_semigroup
17:00:13 * scshunt looks at the applicative laws again
17:00:28 <scshunt> ah
17:00:42 <Zemyla> Maybe. Or it just needs to not have a zero element.
17:01:15 <scshunt> hrm, will it satisfy interchange though?
17:02:04 <scshunt> it definitely satisfies identity and composition
17:02:24 <scshunt> err
17:02:27 <scshunt> identity and homomorphism
17:02:35 <scshunt> not sure about composition though I've no reason to think it doesn't
17:03:44 <Zemyla> scshunt: It will satisfy interchange. Composition is the reason monoids with zero elements are a problem.
17:04:22 <Zemyla> I should probably ask in the Haskell subreddit.
17:05:44 <scshunt> right
17:05:50 <scshunt> just worked out interchange
17:06:25 <Zemyla> Also, I think that if, for a given Monoid k, Map k is Applicative, then it's also a Monad, with m >>= f = M.foldMapWithKey (\k a -> M.mapKeys (k <>) $ f a).
17:07:15 <scshunt> what does your join end up being, hmm
17:07:49 <scshunt> something ugly I imagine
17:07:56 <scshunt> now that I think about it
17:08:01 <scshunt> while this might be true
17:08:06 <scshunt> I suspect the resulting instances are useless anyway
17:08:56 <Zemyla> scshunt: join m = M.foldMapWithKey (\k a -> M.mapKeys (k <>) a) m.
17:14:58 <Zemyla> Actually, hmm, I can't reproduce the issues I was having with Product.
17:19:15 <scshunt> Zemyla: yeah, ok, that might work
17:19:18 <scshunt> definitely useless though
17:21:10 <scshunt> now if you put a commutative monoid on values and then unionWith that monoid, all's awesome
17:22:33 <nocturne777> I want a scheduler kind of thing that runs stuff in the background periodically. What library would I use for that?
17:26:20 <Mark____1> @pl \ a g -> length $ filter id $ zipWith (==) a g
17:26:20 <lambdabot> ((length . filter id) .) . zipWith (==)
17:26:23 <c_wraith> nocturne777, I'm not sure anything addresses that more directly than ghc's io manager itself. 
17:27:04 <c_wraith> nocturne777, and the easiest way to use it is just forkIO and threadDelay 
17:28:25 <c_wraith> nocturne777, things might get more complex if you want various forms of rate limiting. but if you don't need that, it really is that ways. 
17:28:31 <c_wraith> *easy
17:29:26 <nocturne777> c_wraith: I just want to tell the app during the boot process to run 4 or 5 seperate tasks periodically
17:29:52 <nocturne777> c_wraith: each task might have a different interval 
17:29:57 <nocturne777> they are going to be indepdent tasks
17:30:46 <nocturne777> c_wraith: tasks are going to be like, "hey, every four minutes look at the db and send some emails"
17:31:10 <c_wraith> runPeriodically task period = forever $ do task ; threadDelay period
17:32:03 <c_wraith> just watch out for the unit on threadDelay. it uses something like microseconds. 
17:33:57 <c_wraith> nocturne777, it can grow in complexity if you need to catch and log errors and restart, but it's still less than 10 lines. 
17:35:33 <nocturne777> c_wraith: is there something else to support more advanced cases such as "run this every sunday at 6pm" ?
17:37:20 <c_wraith> at that point, it's sufficient additional complexity that I'd go looking for a library, probably not find one, and just make it a cron task
17:45:07 <broma0> what are some common alternatives to persistent and the XXX-simple sql libraries? i find persistent to be too intrusive (by requiring the library to hijack my type definitions) and the XXX-simple libraries too "simple" (columns are retrieved positionally, not by a name lookup or something equally explicit)
17:47:46 <xendo> Hey there. I am new-ish to programming and definitely new to Haskell. If I made a stack project, will the entire copy of GHC and any packages be automatically deleted if I delete the directory? 
17:48:20 <luigy> xendo not quite
17:48:21 <mgsloan> xendo: Nope, GHC and snapshot dependencies get installed to ~/.stack
17:48:40 <luigy> mgsloan :P
17:49:28 <xendo> Hmm. So I would have to go there and manually delete them?
17:51:13 <luigy> xendo if you're worried about them getting your way with other projects they will not, but if you just don't want to use stack anymore and get your space back it is safe to delete ~/.stack
17:51:57 <xendo> luigy: that's good to know. I think stack will be great, but I feel like I'll be messing around with lots of little projects as I'm learning. I just worried about all that stuff building up
17:53:12 <nocturne777> broma0: when you say "positionally", are you referring to the query parameters ?
17:54:28 <mgsloan> xendo: It's pretty easy to delete individual GHCs out of ~/.stack/programs.  It's a little tricky to correctly delete things from ~/.stack/snapshots
17:54:53 <mgsloan> It's safe to blow away either directory, though (you'll just need to wait for things to rebuild / reinstall when you do need them)
17:55:19 <mgsloan> There are some changes coming soon-ish that will make snapshot garbage collection something that we'll pretty much need to support
17:55:36 <luigy> mgsloan how is that going internally
17:55:50 <broma0> nocturne777: i was referencing the FromRow/etc instances. Where you'd write something like : User <$> field <*> field <*> field
17:55:54 <luigy> like what is blocking gn?
17:55:57 <luigy> rn**
17:56:20 <mgsloan> luigy: Nothiing is blocking, just being busy with work that makes $$$
17:57:02 <mgsloan> The custom snapshots etc stuff got passed from me to borsboom, because I got swamped a couple weeks ago, but then he got swamped too.  I might snag it back at some point
17:57:39 <mgsloan> We'd be happy to pass it off to someone if they want to take a swing at it, but it will be quite a lot of work
17:58:03 <mgsloan> I'd guess at least a solid week of work, touching a lot of different parts of the codebase
17:58:07 <xendo> mgsloan are you one of the creators/maintainers of stack? 
17:58:15 <mgsloan> Yep
17:58:32 <xendo> wow. i guess i lucked out that i asked my question when i did! thanks!
17:58:38 <luigy> mgsloan probably in need of a rebase too :P
17:59:02 <luigy> btw mgsloan I have a simple solution for mgsloan I got a solution for https://github.com/commercialhaskell/stack/issues/1364
17:59:18 <luigy> whoops copy/paste fail
17:59:36 <luigy> it even works for 970 and all the relevants
17:59:57 <mgsloan> Really? That's awesome
18:01:53 <Mark____1> :quit
18:02:01 <broma0> what libraries are you using to interact with postgresql?
18:04:36 <luigy> mgsloan yes, will make a pr soon :)
18:04:58 <mgsloan> Great, thanks for your efforts :D
18:05:26 <luigy> mgsloan for https://github.com/commercialhaskell/stack/issues/1606 I have something to make it less worse :P
18:06:11 <mgsloan> Cool!  Less worse than the hack solution of trimming the file extension and filtering out matching modules?
18:06:21 <mgsloan> Because that solution doesn't seem so bad
18:08:03 <luigy> mgsloan do you think it's fine if we remove the main file from ":load" and instead on next line ":add" it? this way we get warning but have all the modules loaded and in scope
18:12:51 <mgsloan> luigy: Oh, cool, I didn't know about that command
18:13:46 <mgsloan> It might be good to use ":add" for the main loading as well
18:14:00 <mgsloan> This'll make it work better for people's custom ghci scripts
18:14:06 <luigy> mgsloan I think that approach you mentioned still get's confused... like if any of the next modules want to load a module with the same name as the main file loaded we get the same original behavior... the only way around it is avoiding using the file path 
18:14:56 <luigy> I have another hack using `ghc -e` + parsing the output of :show modules :p, but not worth it
18:14:57 <luigy> hehe
18:15:10 <luigy> the :add is the simplest :)
18:15:21 <mgsloan> Right, the approach I mentioned doesn't work in all cases, but does work in most reasonable ones
18:15:36 <mgsloan> I like it!
18:15:48 <luigy> cool so should I submit a pr?
18:17:17 <luigy> wait... which one did you like? xD
18:22:10 <mgsloan> Oh, I like using ":add" for both the normal modules and main module
18:26:34 <luigy> mgsloan on the second bullet on #1364 you mention haddock.. can you expand on that?
18:30:12 <mgsloan> Cabal's 'initialBuildSteps' does code generation stuff (cabal_macros.h, Paths_*, etc), and that step needs to run before running ghc / ghci / haddock
18:30:34 <mgsloan> We don't currently have a way to run initialBuildSteps, and so instead we need to do a full build in order to run haddock
18:30:41 <mgsloan> (similarly for ghci)
18:31:07 <mgsloan> (disableable via "stack ghci --no-build")
18:31:42 <luigy> ah gotcha so that is also covered then :)
18:48:20 <nocturne777> does esquleto get in the way when your queries become advanced?
18:48:43 <nocturne777> does it produce bad queries and such sometimes?
18:52:55 <mgsloan> I think you can get it to produce bad queries, but it's not easy to construct those cases, and in that case the bad query will fail every time
18:53:19 <mgsloan> Whether it gets in the way or not depends on how much of a type system ninja you are ^_^
18:55:22 <nocturne777> mgsloan: do you think it makes queries harder to read ?
18:56:44 <mgsloan> Once you're familiar with it, it's pretty straightforward
18:57:17 <mgsloan> But that's coming from someone who's written most of their DB queries with persistent or esqueleto, and hasn't done much direct SQL
18:57:46 <nocturne777> mgsloan: what additional stuff does it offer over persistent library ?
18:58:47 <mgsloan> Persistent tends to only give you a limited variety of queries.  These queries are sufficient to do anything you want to, but can potentially waste time sending back data you don't need
18:59:03 <mgsloan> esqueleto is good for performing more complicated queries, limiting the data that's sent back
18:59:39 <mgsloan> I would tend to use persistent queries for most things, and then using esqueleto where the performance gains are worth it
19:02:18 <lain_> Howdy, i'm learning me a Haskell and I'm confused by [x*2 | x <- [1..10]] and why it does what it does.
19:02:42 <Clint> what do you expect it to do?
19:03:05 <lain_> Well I expect it to print all the even numbers from 2-10, because the book says that.
19:03:14 <lain_> But why x*2 | ...
19:03:54 <EvanR> > [x*2|x<-[1..10]]
19:03:56 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
19:04:06 <EvanR> well, it surely does not
19:04:28 <lain_> Oh. I'm confused again.
19:04:36 <Clint> lain_: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
19:04:55 <lain_> That's where i'm at Clint.
19:05:03 <luigy> > [x*2 | x <- [1..10], x<=5]
19:05:05 <lambdabot>  [2,4,6,8,10]
19:05:09 <Clint> well, it doesn't say it'll print the even numbers from 2-10
19:05:27 <lain_> Oh.
19:05:38 <lain_> I think I understand.
19:05:43 <lain_> I'm tired ._.
19:05:46 <EvanR> LYAH confuses me too ;)
19:06:13 <lain_> Well it's the first google result so it cant be too bad.
19:06:20 <EvanR> maybe there should be a "learn LYAH for great good" website
19:06:38 <EvanR> lain_: heh. falser words were never uttered
19:06:58 <EvanR> have you noticed w3 schools for anything web related
19:07:06 <lain_> Yeah?
19:07:31 <EvanR> first google result is the direct result of SEO budget
19:08:04 <lain_> Well it's better than duckduckgo..
19:09:16 <lain_> Well is there something better I could be using than LYAH?
19:10:23 <EvanR> there is a haskell wikibook, and there are some recommended courses
19:10:33 <EvanR> @where book
19:10:33 <lambdabot> http://haskellbook.com/
19:10:47 <EvanR> hmm theres also bitemyapp's book
19:10:52 <EvanR> https://en.wikibooks.org/wiki/Haskell
19:11:11 <EvanR> http://www.seas.upenn.edu/~cis194/
19:11:57 <lain_> Ah cool, thanks.
19:23:28 <nineonine> hi there
19:23:45 <nineonine> having concerns with my function
19:23:56 <nineonine> i feel that this chunk really stinks hehe
19:23:59 <nineonine> http://lpaste.net/154060
19:24:10 <EvanR> function function whats your dysfunction
19:24:19 <nineonine> then and else are almost the same except 1 line
19:24:24 <nineonine> :))
19:24:37 <nineonine> is there a way to make it nicier ?
19:25:06 <EvanR> you can probably clean that up a lot
19:25:51 <nineonine> yes i feel that
19:25:54 <nineonine> but dont know how
19:25:56 <nineonine> hehe
19:26:10 <EvanR> first have you tried to use modify to modify the state
19:26:21 <EvanR> rather than get followed by put
19:27:07 <nineonine> i was considering using modify
19:27:16 <nineonine> but its a bit confusing for me at that point
19:27:24 <nineonine> and I wanted to keep get/put just for now
19:27:34 <nineonine> i agree its a good point to use modify
19:27:36 <EvanR> :t modify
19:27:37 <lambdabot> MonadState s m => (s -> s) -> m ()
19:27:48 <EvanR> it first your function signature
19:27:55 <EvanR> m = Battle
19:28:07 <EvanR> it would take a few lines off
19:29:58 <nineonine> is there a way to do rewrite it without if-then-else ?
19:30:07 <nineonine> i was thinking of WHEN
19:30:15 <nineonine> but it doesnt change a lot
19:30:17 <EvanR> when wont work, you have 2 cases
19:30:31 <nineonine> got it
19:30:48 <EvanR> however, efs' is the same in both
19:30:50 <EvanR> so its really 1 case
19:31:04 <nineonine> yeah
19:31:05 <EvanR> so when might work
19:31:10 <nineonine> :)
19:31:51 <nineonine> ok I will keep trying
19:31:53 <nineonine> thanks for help !
19:39:32 <EvanR> oh wow at LYAH image "kid.png"
19:44:34 <lain_> EvanR, http://s3.amazonaws.com/lyah/kermit.png
19:47:28 <EvanR> http://s3.amazonaws.com/lyah/kid.png
19:47:52 <Clint> are y'all citing these as the best part or the worst part of lyah
19:47:55 <mniip> :t scanr
19:47:56 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
19:48:11 <mniip> hmm, this can be generalized to traversables
19:50:38 <EvanR> Clint: haha
19:51:14 <EvanR> mniip: it seems plausible
19:53:44 <mniip> :t \f b xs -> evalState (traverse (\x -> modify (f x) >> get >>= return) xs) b
19:53:45 <lambdabot> Traversable t => (a -> b -> b) -> b -> t a -> t b
19:55:05 <mniip> @let scanverser f b xs = evalState (traverse (\x -> modify (f x) >> get >>= return) xs) b
19:55:06 <lambdabot>  Defined.
19:55:18 <mniip> > scanverser (+) 0 [1..]
19:55:20 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
19:56:26 <mniip> @let scanversel f b xs = evalState (forwards $ traverse (\x -> Backwards $ modify (f x) >> get >>= return) xs) b
19:56:27 <lambdabot>  .L.hs:174:8: Not in scope: ‘forwards’
19:56:27 <lambdabot>  
19:56:27 <lambdabot>  .L.hs:175:27:
19:56:32 <mniip> aww
19:56:46 <mniip> no Control.Applicative.Backwards? :(
19:59:42 <mniip> @let scanversel f b xs = evalState (forwards $ traverse (\x -> Backwards $ modify (f x) >> get >>= return) xs) b
19:59:44 <lambdabot>  Defined.
20:00:19 <mniip> > scanversel (+) 0 [1..5]
20:00:21 <lambdabot>  [15,14,12,9,5]
20:00:32 <mniip> oh wait that's backwards, this is the right and the above one is the left
20:02:07 <mniip> fixed
20:02:42 <mniip> > scanversel (+) 5 (Just 3)
20:02:43 <lambdabot>  Just 8
20:02:44 <mniip> haha
20:16:05 <pm_> hye
20:16:54 <pm_> Anyone here know about using Haskell for machine learning?
20:17:50 <Adeon> what flavor of machine learning
20:18:06 <Adeon> the numerical data story isn't as mature as with python or R and stuff but you can do some interesting things
20:18:07 <adamCS_> pm_: There's https://github.com/mikeizbicki/HLearn, but I haven't tried it.  I'm sure there are others as well.
20:18:29 <pm_> I was thinking of SVM
20:18:29 <Adeon> my favorite is automatic differentiation which isn't directly related to machine learning but being able compute gradients quickly is nice
20:18:49 <pm_> Oh yes. I love ad.
20:24:13 <carter_cloud> Adeon: I think that there's also the fact that no tool kit in any language or framework out there is actually that good.  Some just have more batteries :)
20:25:46 <Adeon> sometimes the batteries are what counts though
20:26:13 <hodapp> pm_: https://github.com/josephmisiti/awesome-machine-learning well, there is this list, and I'm interested in applying some of the Haskell stuff when I can
20:26:30 <hodapp> pm_: I'm in CS7641 now, but my first assignment was done in R and my second is being done in Scala
20:26:58 <hodapp> (though for the latter that's mostly because the most straightforward way was to use a certain Java library)
20:27:05 <hodapp> (and seriously fuck Java)
20:27:34 <ggVGc> scala is a bit of a clusterfuck too
20:27:37 <pm_> nice. I saw a few packages on hackage as well. I guess I was just looking for the scikit-learn equivalent for haskell
20:27:39 <ggVGc> so not sure it's much better
20:27:42 <pm_> doesn't exist yet.
20:27:44 <ggVGc> but at least case classes are okay
20:28:00 <ggVGc> there's so much weirdness in scala though
20:28:34 <k3d3> scala has tons of weirdness to it, but it's still miles better than Java
20:28:38 <hodapp> er, yeah
20:28:49 <carter_cloud> Hblas is due for a new release soon. 
20:29:15 <hodapp> pm_: ping me if you do anything interesting with machine learning in Haskell though, I'd be interested to hear what works
20:29:44 <pm_> hodapp: for sure.
20:30:17 <hodapp> I worked with Scala in 2012 for a couple months, and then didn't really touch it again till now, in between which I learned and worked a lot with Haskell... and what I observe in Scala in that 4-year-hiatus is a lot more push to use the type system in the same sorts of ways as Haskell
20:30:36 <hodapp> even if the Java support, and existing Scala baggage, complicates a lot of that
20:35:37 <lain_> So how would I go about changing a users input to lower case, for example: input <- toLower(getLine)
20:36:02 <Adeon> :t toLower
20:36:03 <lambdabot> Char -> Char
20:36:10 <Adeon> hm
20:36:18 <Adeon> input <- fmap toLower <$> getLine
20:36:19 <Adeon> maybe
20:36:30 <Adeon> perverse double fmap though
20:36:49 <Adeon> :t fmap toLower <$> getLine
20:36:50 <lambdabot> IO [Char]
20:36:55 <Adeon> :t getLine
20:36:56 <lambdabot> IO String
20:40:40 <mniip> Adeon, one of them could be 'map' for clarity
20:43:49 <nitrix>  The (<$.$>) operator!
20:44:46 <thevaliantx> those are some expensive puppies :D
20:45:01 <mniip> nitrix, just straight put <$$>
20:45:12 <nitrix> mniip: <$$> is used by Parsec.
20:46:37 <Adeon> :t <$$>
20:46:39 <lambdabot> parse error on input ‘<$$>’
20:46:47 <Adeon> :t (<$$>)
20:46:48 <lambdabot>     Not in scope: ‘<$$>’
20:46:48 <lambdabot>     Perhaps you meant one of these:
20:46:48 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
20:47:03 <Adeon> :t (<$.$>)
20:47:04 <lambdabot> Not in scope: ‘<$.$>’
20:47:14 <Adeon> what's the most elegant way to put a double fmap down
20:47:28 <nitrix> Personally, I'd use lenses.
20:47:35 <mniip> I wouldn't treat 'fmap (fmap toLower)' is a "double fmap"
20:47:41 <mniip> as a*
20:48:01 <nitrix> But I abuse lenses for everything :/
20:48:11 <mniip> it's not useful to think of it like that
20:48:19 <pm_> \help
20:57:39 <lain_> Would someone mind taking a look at this and telling me what I did wrong? http://pastebin.com/6iMhAdws
21:00:24 <shachaf> Well, it's not clear what the type of use is -- you should include that -- but what were you expecting "object !! 1" to do?
21:01:15 <lain_> Well I have a few tables such as lamp = ["A lamp", "The lamp turns on"]
21:02:27 <lain_> It all compiles correctly
21:03:03 <lain_> But i get http://pastebin.com/RVnYfFC4 when i try to "use lamp" 
21:03:17 <shachaf> You should write a type signature for use.
21:05:56 <lain_> I don't know what type signatures are. I'll do a bit of reading, but it is my first day trying Haskell.
21:17:12 <dmwit> :t (.:)
21:17:13 <lambdabot>     Not in scope: ‘.:’
21:17:13 <lambdabot>     Perhaps you meant one of these:
21:17:13 <lambdabot>       ‘.’ (imported from Data.Function),
21:17:51 <gamegoblin> Is there a library that would allow me to take a screenshot from haskell code?
21:18:07 <dmwit> Whoa, fun question.
21:18:47 <dmwit> It's possible GTK supports that kind of thing, in which case you might look at gtk2hs.
21:19:27 <dmwit> Or go straight to the X11 package if you're on Linux.
21:20:05 <gamegoblin> preferably platform portable, but I’m on Mac in general
21:21:31 <gamegoblin> I guess I could just run some haskell code which executes the mac screencapture program 
21:21:38 <gamegoblin> which is kinda hilarious I guess
21:21:46 <isovector> i have a type that I'm trying to write a monad instance for
21:21:51 <isovector> newtype Signal a = Signal {signalGen :: SignalGen Engine (Elerea.Signal (Sample a))}
21:22:10 <isovector> all the other types are already monads, but i odnt have a constructor for signalgen -- is it possible?
21:23:07 <dmwit> Even if all of `SignalGen Engine`, `Elerea.Signal`, and `Sample` are monads, it may *still* not be possible to make `Signal` a monad.
21:23:28 <isovector> that's my impression, but i'm not sure how to prove it one way or the other
21:24:10 <isovector> without a constructor, i can't get through the signalgen layer, and other creative attempts to pull out the 'a' have failed
21:24:28 <dmwit> http://stackoverflow.com/questions/7040844/applicatives-compose-monads-dont
21:25:21 <dmwit> also http://stackoverflow.com/q/13034229/791604
21:27:07 <isovector> thanks, will investigate
22:55:56 <jektrix> Im new to programming and Haskell. How can I return just the element inside a single element list?
22:57:15 <levi> jektrix: There are a number of ways to do that; the simplest (but not necessarily the best) is probably the head function.
22:57:25 <jektrix> can I show you my function?
22:57:51 <jektrix> Im trying the first kata on codewars (a site which gives you small problems to solve in a given coding language)
22:58:08 <jektrix> next :: Eq a => a -> [a] -> Maybe a
22:58:09 <jektrix> next item xs = tail (take (item + 1) xs)
22:58:33 <jektrix> I need to enter for example 'next 7 [1..100]' and it should return 8
22:59:06 <shachaf> Whatever method you use should handle the case where the list is empty.
22:59:29 <shachaf> A good method is "case l of { (x:xs) -> ...; [] -> ... }"
22:59:35 <jektrix> I get this error "Couldn't match expected type `Maybe a' with actual type `[a]'"
22:59:43 <Cale> jektrix: Are you sure that it's not meant to give you the element which follows an element equal to the given one?
23:00:06 <jektrix> This is the instruction "Given a sequence of items and a specific item in that sequence, return the item immediately following the item specified"
23:00:09 <Cale> yeah, you're producing a list, rather than a Maybe
23:00:18 <jektrix> How can I produce a Maybe?
23:00:20 <Cale> Right, so take doesn't help you
23:00:40 <jektrix> lol someone is called so
23:01:03 <jektrix> So this cannot be solved with 'take'?
23:01:46 <cstrahan> Is there any way to disable TypeHoles?
23:02:01 <cstrahan> GHC is treating my lens like a type hole: _ParamSet
23:02:06 <Cale> Well, take n xs will only truncate a list so that it has at most n elements.
23:02:11 <sleblanc> jektrix, you return a Just x
23:02:15 <Cale> item may not even be an Int
23:02:16 <sleblanc> well, Just a
23:02:17 <shachaf> Why do people call it "TypeHoles"? Where did that come from?
23:02:38 <Cale> cstrahan: I think it only does that if your thing isn't in scope.
23:03:09 <jektrix> what is Just
23:03:10 <Cale> cstrahan: are you sure that's the name of your lens and that it's properly imported?
23:03:28 <Cale> jektrix: Just, along with Nothing, is one of the data constructors of the Maybe type
23:03:35 <Cale> data Maybe a = Nothing | Just a
23:03:53 <cstrahan> Cale: it's possible that it's not properly imported... though I've also tried qualified e.g. L._ParamSet
23:04:08 <Cale> For any type t, a value of type Maybe t is either the value Nothing, or it is of the form Just x where x has type t.
23:04:23 <shachaf> It's not a type hole! It's just a hole!
23:05:08 <Cale> shachaf: Originally the plan was to actually support holes in types, that fell through, but the extension didn't get renamed somehow. :P
23:05:45 <jektrix> oops I meant to use 'last' not 'tail'
23:05:49 <shachaf> Cale: But that extensions was completely different anyway.
23:06:08 <Cale> jektrix: It still doesn't help, because item might not be an Int
23:06:09 <shachaf> It was to support holes that would infer part of a type.
23:06:16 <Cale> jektrix: It might not be a number at all
23:06:19 <shachaf> And there isn't even anything called TypeHoles.
23:06:21 <cstrahan> arg... i did something stupid. should get some sleep...
23:06:24 <jektrix> Cale it is supposed to work on strings as well
23:06:38 <Cale> jektrix: Consider something like  next 'd' "abracadabra"
23:06:49 <Cale> jektrix: Here, 'd' + 1 wouldn't make sense.
23:07:01 <jektrix> ok
23:07:24 <Cale> jektrix: If we zip the list with its tail, we get something useful:
23:07:44 <Cale> > let xs = "abracadabra" in zip xs (tail xs)
23:07:46 <lambdabot>  [('a','b'),('b','r'),('r','a'),('a','c'),('c','a'),('a','d'),('d','a'),('a',...
23:09:11 <Cale> There are a lot of ways to look through this list of pairs for a pair having its first part equal to something in particular, but it turns out this exact thing is already in the Prelude under the name lookup
23:09:13 <Cale> :t lookup
23:09:14 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:09:31 <Cale> > let xs = "abracadabra" in lookup 'd' (zip xs (tail xs))
23:09:32 <lambdabot>  Just 'a'
23:09:43 <jektrix> i see
23:09:44 <Cale> > let xs = "abracadabra" in lookup 'z' (zip xs (tail xs))
23:09:45 <lambdabot>  Nothing
23:10:09 <Cale> > let xs = "cats" in lookup 's' (zip xs (tail xs))
23:10:10 <lambdabot>  Nothing
23:10:25 <Cale> > let xs = "casts" in lookup 's' (zip xs (tail xs))
23:10:27 <lambdabot>  Just 't'
23:13:53 <jektrix> Yeah im in over my head
23:19:04 <Cale> jektrix: anything I can help explain?
23:22:48 <jektrix> Im gonna come back to this one later
23:22:52 <jektrix> and try another problem
23:27:02 <cstrahan> Ok, now and certain _ParamSet is in scope. I can see it in my repl, and ghc-mod also provides it as a completion in the respective file...
23:27:08 <cstrahan> now I'm*
23:29:27 <mniip> > foldr (\x -> mplus $ mfilter ((== 's') . fst) (uncons x) >>= (fmap fst . uncons . snd)) Nothing . tails $ "casts"
23:29:28 <lambdabot>  Just 't'
23:29:32 <mniip> :o
23:30:48 <mniip> hmm should be foldmap
23:42:04 <MarcelineVQ> mniip: That was fun to work through in ghci :D
