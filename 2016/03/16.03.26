00:04:43 <lool`> hm, I'm now looking at `withSNat`. Is the `magicDict` stuff necessary for `SomeVec` too?
00:11:07 <bluezone> well damn...
00:11:32 <bluezone> not crafty enough to come up with this kind of thing yet
00:11:40 <bluezone> > let (_,(a:_)) = (10,"abc") in a 
00:11:41 <lambdabot>  'a'
00:36:37 <Cale> bluezone: Of course, you should typically use 'case' for that particular sort of thing, since your pattern match might fail if the string is empty.
00:37:24 <Cale> > case (10,"abc") of (_,[]) -> Nothing; (_,(a:_)) -> Just a
00:37:26 <lambdabot>  Just 'a'
00:37:31 <Cale> > case (7,"") of (_,[]) -> Nothing; (_,(a:_)) -> Just a
00:37:32 <lambdabot>  Nothing
01:05:16 <johnw> EvanR: yes, dependent types allow the type to say something about how arguments are used in determining the result of a function
01:10:36 <Cale> Dependent types also allow the arguments of a function to be used in determining the type of the result of that function.
01:11:37 <johnw> I had hoped to also mean that, but I guess it wasn't clear
01:29:38 <roelof> Can someone help me with this problem : https://www.reddit.com/r/haskellquestions/comments/4bw4br/improve_quicktest/
01:41:05 <roelof> it looks no server is started when  I do test -p 8081 as the tutorial says to do 
01:41:10 <roelof> Can someone help me with this problem ? https://groups.google.com/forum/#!topic/snap_framework/GZp1Y3YlRgg
01:41:18 <roelof> Can someone help me with this problem : https://www.reddit.com/r/haskellquestions/comments/4bw4br/improve_quicktest/
01:46:33 <tempay> Hey guys! Does anyone know if a Pipes or Conduit enable NCurses library exists?
01:51:22 <prrraveen> .
02:00:27 * hackagebot cplex-hs 0.2.0.2 - high-level CPLEX interface  https://hackage.haskell.org/package/cplex-hs-0.2.0.2 (stefanjhlk)
02:11:31 <gfixler> how do I decide the versions of a package to specify in a cabal file?
02:11:44 <gfixler> do people download each version and try it out until it stops working?
02:14:39 <cocreature> gfixler: usually I just use the newest version with pvp compliant bounds
02:15:28 * hackagebot Hish 0.1.2.3 -   https://hackage.haskell.org/package/Hish-0.1.2.3 (jaiyalas)
02:16:28 <Guest_98765> Allah is doing
02:16:42 <Guest_98765> sun is not doing Allah is doing
02:16:53 <Guest_98765> moon is not doing Allah is doing
02:17:10 <Guest_98765> stars are not doing Allah is doing
02:17:15 <cocreature> @where ops
02:17:15 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
02:17:23 <lazyWriter> is it possible to ahve MULTIPLE readers, and have "ask" do different things depending on the type signature ?
02:17:31 <puregreen> lazyWriter: not with mtl
02:17:38 <gfixler> thanks cocreature
02:17:41 <puregreen> @hackage ether
02:17:41 <lambdabot> http://hackage.haskell.org/package/ether
02:17:46 <lazyWriter> so snap/heist has this weird thing called "HasHeist"
02:17:48 <puregreen> @hackage monad-classes
02:17:48 <lambdabot> http://hackage.haskell.org/package/monad-classes
02:17:58 <lazyWriter> which is sorta like saying "We have this ability to get a Heist object"
02:18:55 <MichaelBurge> I need the equivalent of an 'interface' in my code. My inclination is to use a record of functions, so each implementer of the API would be a value. The other possibility is typeclasses.
02:19:38 <MichaelBurge> I actually don't use typeclasses too much, so I'm not sure what I'd be missing out on later on. Is there a good article or similar describing how to define APIs in Haskell?
02:20:06 <roelof> Can someone help me with this problem : https://www.reddit.com/r/haskellquestions/comments/4bw4br/improve_quicktest/
02:21:45 <MichaelBurge> roelof: One way would be to define an arbitrary instance for 'data AnyFractional = forall a. Fractional a => AnyFractional', and then write all your tests in terms of AnyFractional.
02:22:00 <MichaelBurge> You would have to manually add the fractionals that you'd like to generate, but you'd only have to do it once in the Arbitrary instance.
02:23:47 <roelof> MichaelBurge:  oke, but do I still get arbetrary values like quickcheck normally does 
02:24:04 <roelof> and how doI this adding then 
02:24:42 <roelof> sorry for asking so many questions. IM learnng haskell and try to find a answer to a challenge 
02:29:42 <MichaelBurge> roelof; It looks from your Reddit question like you're doing this for schoolwork. I'd probably use ephrion's suggestion in the Reddit question you linked.
02:29:52 <MichaelBurge> I think you need to add the typeclass constraints to your property too.
02:30:28 * hackagebot svg-tree 0.5 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.5 (VincentBerthoux)
02:30:43 <roelof> This is not school work. Im self study haskell 
02:31:37 <MichaelBurge> roelof: The AnyFractional solution would work, but you'd need to define your own Arbitrary AnyFractional instance for it.
02:31:40 <MichaelBurge> https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck-Arbitrary.html
02:32:00 <roelof> I did add this  (Show a , Fractional a , Eq a) on  both and I see then the error I posted 
02:34:16 <MichaelBurge> roelof: The error is because when you run 'quickCheck prop_fD', it needs a concrete type. So your prop_fD can work with multiple types, but you'll need to call it once for each concrete type you want to instantiate
02:34:47 <MichaelBurge> roelof: Try 'quickCheck (prop_fD :: Double -> Bool)' and 'quickCheck (prop_fD :: Float -> Bool)'
02:34:54 <roelof> oke, but then I could also make two test for floats and doubles as I did 
02:35:25 <MichaelBurge> yes, it does lead to some duplication. You at least don't have to define the separate functions, but you would have to duplicate the calls with that approach.
02:35:37 <MichaelBurge> The AnyFractional approach would avoid that, and you'd just need to define your own instance for it
02:35:39 <roelof> oke, that is a win 
02:35:42 <MichaelBurge> I have some examples of defining instances here:
02:35:45 <MichaelBurge> https://bitbucket.org/MichaelBurge/shogi/src/f2370832b328ae16e56681fe4123d6912299b1b4/tests/Tests/Shogi/Arbitrary.hs?at=master&fileviewer=file-view-default
02:37:52 <roelof> MichaelBurge:  thanks for the info 
02:42:26 <roelof> MichaelBurge:  one question : when I make the two test I see this error :  Couldn't match expected type ‘(prop0 -> IO ())                                   -> (Float -> Bool) -> t’                 with actual type ‘IO ()’
02:42:35 <roelof> with main : IO() 
02:44:38 <MichaelBurge> roelof: Can you repost the code that's generating the error along with the error?
02:46:49 <roelof> MichaelBurge:  here : http://lpaste.net/156928
02:47:28 <MichaelBurge> roelof: Look at the indentation on the second quickCheck
02:47:35 <MichaelBurge> And you're missing the 'do' keyword in main
02:48:15 <roelof> Thanks, it's working 
02:49:05 <roelof> Can I use this "trick" also when I have to test a sorted list.  A list can contains several types like int, float, char, string, tuples 
02:49:56 <MichaelBurge> roelof: Defining functions like Fractional a will work for a list too, but you'd have to duplicate the call for each type. And a list might have many more types.
02:50:24 <roelof> yes, I know, but I cannot test all types 
02:50:39 <roelof> So think to do it with a few types 
02:50:54 <MichaelBurge> roelof: The AnyFractional trick would work better for lists. You'd still have to explicitly list out the types, but your tests would test them all.
02:51:48 <roelof> oke, then I try to figure out how I can make a instance which can take a float and a double 
02:52:11 <roelof> So I try to make this one work with AnyInstance 
02:53:12 <roelof> I try to figure that out with your examples 
02:53:27 <lazyWriter> roelof: do you work for sequoia ?
02:53:58 <roelof> lazyWriter:  nope, im unemployed and never heard of sequoia 
02:54:08 <lazyWriter> sorry, I have the wrong person
02:55:05 <roelof> lazyWriter:  no problem 
02:55:35 <roelof> MichaelBurge:  I think I need a instance Either Double Float  ? 
02:55:57 <MichaelBurge> roelof: Look at the AnyWidget definition in this article: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:57:24 <MichaelBurge> roelof: You could also use Either Double Float, but I'd actually expect that to work out-of-the-box.
02:59:36 <roelof> oke, you mean this idea : http://lpaste.net/156930
03:00:03 <MichaelBurge> roelof: I'm sorry, if you want to keep it simple and only care about Double and Float, it would be easier to say 'newtype AnyFractional = AnyFractional (Either Double Float)'
03:00:21 <MichaelBurge> You could replace it later if you wanted to expand it to other things
03:01:05 <roelof> oke, and then the test would be prop_f :: AnyFractional -> Bool 
03:01:11 <MichaelBurge> yes
03:02:23 <MichaelBurge> roelof: You would also have to define 'instance Fractional AnyFractional where ...', in order to use the Fractional properties in your test.
03:04:12 <roelof> oke, then I have to figure out what must be there. I have a testing function which looks like this : (*2) . halfx
03:12:13 <roelof> MichaelBurge:  or do I have to do something like this Left x -> x  in the instance ? 
03:13:20 <MichaelBurge> roelof: If you use an Either a b to represent this, I believe that you do have to split it into cases for Left and Right.
03:14:26 <MichaelBurge> roelof: If you use a technique similar to AnyWidget in that article I gave, writing 'data AnyFractional = forall a. Fractional a => AnyFractional', I think that you get the typeclass instance for free.
03:14:40 <MichaelBurge> but the downside is it's a little harder to understand what's happening.
03:23:08 <ij> Is it possible to get a data Struct = Struct { a :: Int, b :: Int, ... } as a map [('a', value), ..], automatically?
03:24:10 <MichaelBurge> ij: I think it's possible using either Template Haskell or Generics to automatically create a function f :: Struct -> Data.Map String Value
03:24:23 <MichaelBurge> ij: And there might be a package somewhere to do it.
03:24:47 <MichaelBurge> ij: Would Aeson work for this?
03:24:51 <ij> I know lens does it, so yeah. It's just hard to google.
03:27:36 <ij> But maybe it isn't worth stuffing the function namespace with config file's key names.
03:28:34 <ij> And I could just query with string keys from the map.
03:29:05 <ij> MichaelBurge, Data.Aeson.TH does this, you're right!
03:29:54 <puregreen> ij: see https://artyom.me/lens-over-tea-6#getting-information-about-types
03:31:32 <puregreen> ij: are all your fields of the same type?
03:31:45 <ij> No.
03:31:54 <ij> Why?
03:32:56 <puregreen> ij: well, if they were, it'd be possible to generate Map String Int or something, but otherwise you have to use some common type for them (like Aeson's ‘Value’, yeah)
03:36:12 <puregreen> ij: anyway, if you simply store your config as JSON/YAML then you don't have to write any TH code or even create any ‘Struct’s (and there are also other config libraries that may be suited for the purpose even better, e.g. bos's “configurator”)
03:37:04 <puregreen> https://ocharles.org.uk/blog/posts/2012-12-21-24-days-of-hackage-configurator.html
03:38:30 <Axman6> I've just been looking at https://hackage.haskell.org/package/configuration-tools-0.2.14 for config stuff. missing some nice features of configurator, but has a hell of a lot of other stuff that makes it nice
03:39:27 <Axman6> I don't htink I've ever needed to reread a value after app start, which is probably the main configurator feature missing
03:42:32 <ij> So then a value's not present, it dies whenever it requests it? e.g. in the middle of running?
03:42:42 <EvanR> the idea is not to go through [('a', v),...] in the first place just read directly into your config data type which you have
03:43:22 <Axman6> no you can specify a handler for problems, which by default are logged to stdout I think
03:54:29 <MichaelK> Is there a subtype operator like (~)?
03:59:25 <benneh> I'm playing about with DataKinds and I've written the some natural number (http://lpaste.net/156932) and vector (http://lpaste.net/156933) types, but I've encountered a problem: how to I write 'vUnappend' in Vector.hs? the form of the function varies based on the form of 'n' in a way which confuses me
04:01:13 <EvanR> MichaelK: there are no subtypes
04:01:30 <MichaelK> EvanR: :(
04:01:37 <EvanR> no not :(!
04:01:43 <MichaelK> why?
04:02:32 <EvanR> its instructive to run through what you think subtypes are
04:03:24 <EvanR> theres probably an ok or better way to do each thing you can come up with
04:03:42 <MichaelK> in my vague notion, if we have something like (+) for types, then a, b are subtypes of a + b. 
04:04:04 <Maxdamantus> Variance is hard.
04:04:05 <EvanR> do you mean union types
04:04:37 <MichaelK> yeah. though I'd also expect something like b -> c as a subtype to a -> b -> c
04:04:38 <lyxia> benneh: I think you need a runtime representation of n to match on
04:04:40 <EvanR> these pop up sometimes when you dont have a real type system, but we do
04:05:01 <EvanR> in what way is b -> c a subtype of a -> b -> c ?
04:05:02 <Maxdamantus> if operands of (+) were subtypes of a particular thing you'd be able to do `(5 :: Int) + (5 :: Double)`
04:05:35 <EvanR> and Int isnt really a subtype of Double or vice versa, no matter how you slice it
04:06:07 <EvanR> and if they are subtypes of Number... its not clear how that helps
04:06:22 <EvanR> or how youd implement it
04:06:27 <MichaelK> hmmmm
04:06:56 <benneh> lyxia: so all of my Vectors will need to carry around an additional field of type Natural, containing their size?
04:07:11 <EvanR> automatically promoting numbers from int to bigint or double to bigdouble are also things you get in systems with no type system
04:07:59 <EvanR> i kind of want to compile a report of everything people might use subtyping to mean
04:08:33 <lyxia> benneh: that won't help here. vUnappend can't tell how you intend to split the length of the input vector from just looking at it or its length
04:08:53 <MichaelK> Maxdamantus: that seems less of an issue if you have arbitrary precision types, then Integer could be a Ratio with denominator 1?
04:09:21 <EvanR> now youre talking about an injective mapping into some larger domain
04:09:29 <EvanR> in which case we easily have that
04:09:32 <Maxdamantus> MichaelK: this can all be possible in some other language.
04:09:46 <Maxdamantus> MichaelK: but that's not how it works in Haskell, because Haskell doesn't have subtypes.
04:10:00 <lyxia> benneh: Ideally you want to dispatch the right specialization just based on the type of the result, but you can't do that AFAICT
04:10:45 <EvanR> MichaelK: in this area, haskell decides that implicit conversion is bad, so Integers are integers and Rationals are Rationals and you have to use fromIntegral or realToFrac anywhere a conversion takes place
04:11:02 <EvanR> but the conversion process is trivial
04:11:16 <lyxia> benneh: Using typeclasses can remove some boilerplate for a user of the function, but it still relies on a runtime representation of the length
04:11:57 <EvanR> for a huge domain of convertibles, you can use type classes to wrangle it sort of, but in the microscale just using a conversion routine of your choice is more flexible
04:12:16 <EvanR> and simpler than constraints everywhere
04:12:52 <MichaelK> EvanR: could a constraint represent "Function that returns type X"? Or is that beyond their scope?
04:13:09 <EvanR> (-> X) ?
04:13:42 <benneh> lyxia: damn, I was hoping there would be simpler solution than that; thanks for the help anyway
04:13:43 <EvanR> yeah if you want Show a => everywhere, maybe its simpler to just take a String
04:13:48 <MichaelBurge> MichaelK: You can do something similar with typeclasses. Like if you wanted to say, "A Double is really just a collection of 64 bits, and any collection of 64 bits can be mapped over. So map id someDouble makes sense."
04:13:48 <MichaelK> That gives me a parse error
04:14:02 <MichaelK> (-> Int), for example
04:14:16 <EvanR> type F a = a -> Int
04:14:39 <MichaelBurge> MichaelK: Then you could define an instance Bits Double, an instance Bits a => Foldable a, and then use Foldable's map function to access the bits in a double.
04:15:02 <MichaelBurge> And that is kind of like saying that Doubles are subtypes of collections of bits.
04:15:15 <MichaelK> MichaelBurge: That makes more sense
04:15:27 <EvanR> see what is this usage... its more like "i can convert a double to a list of bits"
04:15:38 <EvanR> but we have a better interface to the bits which is the Bits class
04:16:01 <MichaelK> EvanR: That seems almost too easy.. (the F a type)
04:16:21 <EvanR> i know, thats why subtypes are too complicated / ill defined a lot of the time 
04:16:32 <ggVGc> I've got a number of threads that block, and need to run a timer in another thread and signal all other threads whern the timer finishes. Is the correct way to throw an async exception into each other thread?
04:17:10 <ggVGc> well, that was barely english
04:17:19 <EvanR> if they are blocking and waiting, then why not read from a dupped chan?
04:17:28 <EvanR> insteading of messing with exceptions
04:17:39 <ggVGc> EvanR: what does "reading from the dupped chan" mean?
04:17:59 <EvanR> the timer writes a () to a chan, which has been dupped to have many endpoints, in the blocked threads
04:18:12 <EvanR> if they read from that chan, theyll block until the () comes
04:18:38 <EvanR> its dupped so not just one thread wakes up
04:18:47 <EvanR> "duped"...
04:18:55 <EvanR> :t dupChan
04:18:56 <lambdabot> Not in scope: ‘dupChan’
04:19:08 <ggVGc> I don't think I know what you're talking about. haven't dealt with chans
04:19:12 <ggVGc> will look into it
04:19:17 <EvanR> its pretty simple
04:19:20 <ggVGc> the other threads are blocking on network reads
04:19:37 <EvanR> ah, well then maybe you need to think of it differently
04:19:41 <EvanR> use more threads
04:19:47 <EvanR> let them keep reading
04:20:38 <ggVGc> EvanR: so, if I get this right I should be able to have a "handler" thread that blocks on reading a chan, and one thread per connection blocking on network reads, and one thread doing the timer
04:20:47 <ggVGc> and both the network and timer threads write to the chan
04:21:20 <EvanR> whats the handler thread for?
04:21:28 <EvanR> why does the timer execute that action itself
04:21:30 <EvanR> doesnt*
04:21:40 <ggVGc> EvanR: running the actual logic? Either reacting to the timer event, or handling a network message
04:21:53 <ggVGc> hm, yeah, maybe it could
04:21:55 <EvanR> oh handler of network messages
04:22:10 <EvanR> yeah each reader thread could post its event to a chan
04:22:27 <EvanR> and if there is an out of band message it could be on the same chan (different constructor)
04:22:44 <ggVGc> EvanR: it just makes more seonse for me in this to have one function handling "Timer messages or network events" because they deal with the same logic
04:23:15 <MichaelK> EvanR: does "type F a = a -> Int" only work for unary functions returning Int? what about nary functions?
04:23:32 <EvanR> data ShitsHappening = InMsg Packet | Timer
04:23:45 <ggVGc> EvanR: yeah, that's what I meant
04:23:48 <ggVGc> cool, thanks
04:23:48 <EvanR> MichaelK: all functions take 1 arg. what are you trying to do
04:25:46 <MichaelK> EvanR: make an instance that passes Nothing to a function until its first arg is not (Maybe a). So one instance would be (Maybe a -> b) -> b, another (Maybe a -> Maybe b -> c) -> c, etc. 
04:26:16 <MichaelK> I'm constraining all the types to be num, or int or something to prevent functions being passed and confusing things (at least for now)
04:26:27 <MichaelK> (all the a,b,c's)
04:26:41 <EvanR> how many variables are there?
04:26:50 <MichaelK> >= 1
04:27:10 <EvanR> so passing Maybes in as input is the first unidiomatic thing going on
04:27:31 <EvanR> you can avoid that by using different functions for different things
04:28:06 <EvanR> for a variadic function like printf, its possible to do a typeclass hack but its gross
04:28:42 <EvanR> you might want to use a data type to accumlate what youre trying to do and then pass that into the final function for interpretation
04:29:03 <MichaelBurge> MichaelK: Consider creating a type to store all the parameters, and write a Data.Default instance for it that fills everything with Nothing.
04:29:18 <EvanR> you can use a GADT, rankN or existentials to put together differently typed pieces of your final "input" structure
04:29:44 <EvanR> not sure Default is helpful here
04:30:04 <MichaelBurge> or a mkType function would work too
04:30:49 <MichaelK> EvanR: I'm barely beginning to wrap my head around those
04:31:06 <EvanR> heres an example of a heterotyped input to a function
04:31:37 <MichaelK> MichaelBurge: I thought that side-stepped type checking (somewhat)?
04:32:56 <EvanR> data H :: * -> *
04:33:04 <EvanR>   Nil :: H a
04:33:10 <MichaelBurge> MichaelK: If you're worried somebody won't fill in a parameter, then I'd use a mkType :: Required1 -> Required2-> Required3-> Type that is the only exposed constructor and fills everything else with Nothing.
04:33:15 <EvanR>   Cons :: a -> H b -> H (a,b)
04:33:54 <EvanR> with just this, you probably cant do much, but if you also include at each point in this list some thing that you will eventually use, then you can use it in your final interpretation function to do something useful with the data
04:34:34 <EvanR> then your function would take something like H (A,(B,(C,D)))
04:34:56 <MichaelK> EvanR: Like a polymorphic list?
04:35:07 <EvanR> with DataKinds you can rewrite this to H '[A,B,C,D]
04:35:19 <EvanR> polytypic*
04:35:31 <EvanR> "heterotyped list"
04:35:34 <MichaelK> thanks for the catch
04:36:19 <EvanR> i messed it, with tuples it would end up the weird H (A,(B,(C,(D,a))))
04:37:07 <EvanR> anyway youd only need this if the user is also responsible for the final interface, if you were requiring a static [A,B,C,D] as input, then youd just do a A -> B -> C -> D -> ... directly
04:37:09 <MichaelK> Yeah, that was one of my first ideas, but I paused it to look for a method with a more "natural interface". unless I've missed some easy way to use ($) and (.) with such functions?
04:37:44 <EvanR> yes you can use . and $ to build the final list
04:38:25 <EvanR> when you build the final input structure... like equipFoo x . equipBar y . equipFoo x2 $ Nil
04:38:51 <EvanR> you can get a lot of control over how they build this input
04:39:50 <hjulle> MichaelK: What do you want to use the function for?
04:40:21 <MichaelK> hjulle: recompilable functions
04:40:43 <EvanR> so you have some AST and a compiler
04:40:52 <EvanR> you really need GADTs
04:41:14 <MichaelK> EvanR: do you have a good resource for them?
04:42:05 <jason__> .
04:46:51 <Roelof> How to solve this : data AnyFractional = forall a. Fractional a => AnyFractional . Error message : Not a data constructor: ‘forall’
04:47:17 <Axman6> RankNTypes IIRC
04:47:38 <Roelof> Axman6:  ???
04:47:54 <Axman6> {-# LANGUAGE RankNTypes #-}
04:48:02 <Axman6> but you probably don't want that
04:48:53 <Roelof> Axman6:  oke, Maybe use this :  Perhaps you intended to use ExistentialQuantification
04:49:03 <Axman6> yeah, that one
04:49:23 <Axman6> the error messages will often tell you which extension you probably need
04:54:00 <EvanR> MichaelK: actually no. i should really look for some good references to all these "haskell 2" things
04:54:25 <EvanR> MichaelK: but the GHC manual covers them, maybe try the latest version of the manual
04:54:31 <EvanR> and theres lots of blogs
04:55:18 <EvanR> MichaelK: https://downloads.haskell.org/~ghc/8.0.1-rc2/docs/html/users_guide/glasgow_exts.html?highlight=gadts#ghc-flag--XGADTs
04:55:29 <EvanR> https://downloads.haskell.org/~ghc/8.0.1-rc2/docs/html/users_guide/glasgow_exts.html?highlight=gadts#generalised-algebraic-data-types-gadts
04:56:36 <Roelof> Axman6:  thanks, I think I will revert to seperate test, This is too complex for me right now 
04:58:00 <Roelof> Axman6:  I was thinking how to improve this : https://www.reddit.com/r/haskellquestions/comments/4bw4br/improve_quicktest/  but the right solution is too complex for me now 
04:58:12 <Roelof> but thanks for the help 
05:02:48 <Axman6> Roelof: what's wrong with ephrion's suggestion? just use quickCheck (prop_f :: Double -> Bool); quickCheck (prop_f :: Float -> Bool)
05:03:25 <Roelof> Axman6:  nothing, I will revert to that one 
05:07:09 <MichaelK> EvanR: Thanks. I guess I'll just have to play around with what I can draw from the manual
05:09:42 <Roelof> Which type family can I use the best to test a list of anything ? Just list[a]  ? 
05:30:54 <Gurkenglas> Is there a language extension that puts () around every indentation block where applicable?
05:31:39 <Gurkenglas> (In particular making all () at the ends of exactly one line unneeded)
05:32:02 <MichaelBurge> Gurkenglas: You might be able to do something similar with nested do blocks. The HTML libraries use the do notation for a similar purpose
05:32:25 <MichaelBurge> Gurnkeglas: Otherwise, using the $ operator can often remove parentheses
05:32:40 <Gurkenglas> MichaelBurge, that wouldn't solve passing complex arguments to nary functions
05:34:47 <Zemyla> Is there a name for "flip onException" like how handle is flip catch?
05:34:59 <Gurkenglas> ...or would the nested do blocks one? Something like the identity monad, only without the Identity wrapper? But how would you deal with all the overlap?
05:35:36 * hackagebot hedis 0.7.10 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.10 (k_bx)
05:37:08 <MichaelBurge> Gurkenglas: I know there's a Functor instance for functions. I bet it's possible to write a monad instance where bind is function application
05:39:19 <MichaelBurge> Gurkenglas: And then if there's a way to automatically lift and flatten values to this new type, it should work like nested do blocks.
05:39:33 <Gurkenglas> I'd rather not sacrifice the existing reader monad instance. Why not just bracket every indentation block?
05:40:44 <MichaelBurge> Well, you could use ReaderT instead of Reader. I don't think there's a language extension that does it with parantheses, though.
05:41:07 <MichaelBurge> While we're talking syntax, it'd be nice if there was a way to write 'data X {}' instead of 'data X = X {}'.
05:41:14 <puregreen> Gurkenglas: say when you're finished with comments so that I'd be able to make a commit
05:41:28 <Gurkenglas> puregreen, should be done
05:41:31 <puregreen> okay
05:42:05 <Gurkenglas> (unless there's more where you didn't edit anything? eh whatevz)
05:47:24 <infinity0> i'm reading oleg's essay on open unions and he says "To do better, the type of an open union should be annotated with the set of possible summands."
05:47:30 <infinity0> what then is a "closed" union?
06:07:26 <Kaidelong> you can only tell how many members there are in an open union by looking at absolutely all of the source code and, if you have a dynamic environment, the number can change at runtime
06:07:39 <Kaidelong> class based inheritance is a kind of open union
06:07:56 <Kaidelong> things of a certain type includes all of the subclasses
06:08:47 <Kaidelong> closed union types you can look at the definition and know exactly how many inhabitants it has, parametric polymorphism can make that into a function, but you still know the function statically
06:09:35 <infinity0> i see so Either is a closed union
06:09:39 <Kaidelong> yes
06:09:54 <Kaidelong> Either a b has a + b members
06:10:08 <infinity0> he also writes "data Union (r :: [*])" and this actually works in ghc as i just tried (have to set DataKinds and KindSignatures), what dose [*] mean?
06:10:14 <ggole> ... + 1, in Haskell
06:10:37 <Kaidelong> well, that's if you treat partially defined expressions as values rather than effects
06:10:40 <infinity0> ah including the bottom type i guess?
06:11:51 <ggole> Yeah, there are some questions of definition there
06:13:11 <Kaidelong> also it wouldn't be +1 anyway
06:14:19 <Kaidelong> there are uncountably infinitely many bottoms and due to boxing Either gives you three kinds of non-fully-defined values
06:14:48 <Kaidelong> You can either have bottom, a left of bottom, or a right of bottom, added over all the kinds of partially defined values of a and b
06:16:39 <Kaidelong> well, uncountably infinitely many bottoms for Nat, maybe this doesn't hold for all types
06:16:40 <ggole> I would expect left + right bottoms to be included in the a + b
06:17:12 <ggole> But anyway, let me stop nitpicking and get back to my code.
06:18:10 <infinity0> so what does [*] mean in a kindsignature
06:19:00 <pavonia> List of types
06:23:41 <infinity0> oh ok i see, after using DataKinds you can construct arbitrary kinds out of existing data types
06:23:51 <infinity0> this sounds like it could be abused pretty badly...
06:28:58 <icicled> infinity0: see the servant packaged - it's [ab]used in the best possible way
06:30:36 <infinity0> >>> type MyEndpoint = ReqBody '[JSON, PlainText] Book :> Get '[JSON, PlainText] Book
06:30:39 <infinity0> heh
06:31:06 <infinity0> i guess that one is a closed union and really it should be a set
06:35:42 * hackagebot cryptohash-cryptoapi 0.1.4 - Crypto-api interfaces for cryptohash  https://hackage.haskell.org/package/cryptohash-cryptoapi-0.1.4 (VincentHanquez)
06:46:03 <infinity0> https://hackage.haskell.org/package/type-level-sets oh, interesting
06:46:12 * hackagebot csound-expression-dynamic 0.1.6 - dynamic core for csound-expression library  https://hackage.haskell.org/package/csound-expression-dynamic-0.1.6 (AntonKholomiov)
06:46:14 * hackagebot csound-expression-typed 0.0.9.2 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.9.2 (AntonKholomiov)
06:46:16 * hackagebot csound-expression-opcodes 0.0.3.1 - opcodes for the library csound-expression  https://hackage.haskell.org/package/csound-expression-opcodes-0.0.3.1 (AntonKholomiov)
06:46:18 * hackagebot csound-expression 5.0.0 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-5.0.0 (AntonKholomiov)
06:46:20 * hackagebot csound-sampler 0.0.6.5 - A musical sampler based on Csound  https://hackage.haskell.org/package/csound-sampler-0.0.6.5 (AntonKholomiov)
06:50:03 <ertes> please help a non-native english speaker write correct documentation:  do you say "oblivious toward" or "oblivious about" or …?
06:50:32 <aph> what's the sentence?
06:50:46 <ertes> or perhaps there is a better way to phrase this altogether:  -- These functions are generally oblivious ... leap seconds.
06:50:55 <joachifm> oblivious to?
06:50:55 <aph> i think it's usually 'to'
06:51:11 <ertes> (meaning that when they're supposed to skip one second, they might skip two or none)
06:51:19 <aph> (it's somewhat hard to remember these things in isolation)
06:51:22 * hackagebot csound-catalog 0.5.0 - a gallery of Csound instruments.  https://hackage.haskell.org/package/csound-catalog-0.5.0 (AntonKholomiov)
06:51:35 <ertes> ok, thank you
06:51:51 <benneh_> I'm playing around with DataKinds, and I've run into something I don't understand. If I have a type "data Natural = NZero | NSucc Natural", is there any way to define the obvious induction principle "induction :: f 'NZero -> (forall (k :: Natural). f k -> f ('NSucc k)) -> f n"?
06:52:18 <joachifm> perhaps you could say that they fail to account for leap seconds or something. to me, saying that a function is oblivious to anything is a bit odd
06:52:46 <puregreen> or “ignore the existence of leap seconds”
06:53:09 <benneh_> "ignorant of" sounds a bit more natural to me
06:57:02 <ertes> "These functions ignore leap seconds, unless @t@ specifically has a representation for them (such as TAI).  For example skipping one second with /time/'s @UTCTime@ may skip up to two seconds of physical time."
06:57:03 <ertes>  
06:57:05 <ertes> better?
06:57:44 <nobag> I need a Map k (IORef *), how do I go about this? (A map from a known key type to arbitrary IORefs)
06:57:57 <MichaelBurge> Is there a way to have duplicate constructor names for different types? The example here would be a 'Success' constructor on each of several 'Status' types.
06:58:14 <ertes> nobag: would 'Map k (IORef Dynamic)' be an option?
06:58:22 <joachifm> ertes: I think so (but I'm not a native speaker either, so my ear is not the best)
06:58:45 <MichaelBurge> nobad: I think you could use an existential type there?
06:58:48 <ertes> nobag: downside: the type of an individual IORef may change
06:58:49 <lyxia> MichaelBurge: put them in different modules
06:59:01 <ertes> nobag: if you don't want that, you need an existential
06:59:03 <benneh_> ertes: As a native english speaker, that sounds fine to me.
06:59:15 <ertes> joachifm, benneh_: thanks!
06:59:56 <ertes> nobag: nevermind, it can change even with an existential…  use Dynamic if that's ok, otherwise you need something other than Map, and that will quickly turn into a headache
07:01:15 <nobag> ertes: it can't change and I'll always know which type went into it, but I'll see if Dynamic does the job :)
07:02:07 <nobag> ertes: couldn't I also create a "cast" using something like return << unsafePerformIO << readIORef?
07:02:12 <ertes> nobag: well, you'll get nasty Nothing cases to handle that in principle wouldn't occur, so it's a bit uglier than necessary
07:02:40 <ertes> nobag: Dynamic is just an existential with Typeable, so it gives you a safe cast
07:03:22 <ertes> nobag: if you want an unsafe cast, you would use unsafeCoerce
07:04:01 <ertes> but you need to be careful with that one…  it makes the impossible possible: segfaults in haskell =)
07:05:53 <nobag> ertes: thanks! I might start with Dynamic and change to unsafeCoerce later. Is unsafeCoerce safe to use with IORef? (I.e. is IORef always a pointer or whatever the internal representation is?)
07:06:37 <ertes> IORef contains boxed values, so it's as safe as coercing anything else
07:06:37 <nobag> ertes: this doesn't imply that: In nhc98, the only representation-safe coercions are between Enum types with the same range (e.g. Int, Int32, Char, Word32), or between a newtype and the type that it wraps.
07:07:29 <nobag> ertes: OK, thanks!
07:07:39 <ertes> if you don't mind a bit of overengineering you can create a Dynamic-based wrapper around Map
07:08:08 <ertes> insert :: k a -> a -> MyMap k -> MyMap k
07:08:08 <puregreen> has anybody got any good usecases for (.:)?
07:08:26 <ertes> lookup :: k a -> MyMap k -> Maybe a
07:08:31 <puregreen> (where (.:) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d))
07:08:43 <ertes> nobag: then you can use a GADT as your key type
07:09:00 <ertes> (add missing contexts to the function signature like Ord/Ord1, etc.)
07:09:30 <ertes> nobag: the idea is that each key is indexed by the value type
07:09:58 <ertes> data MyKey :: * -> * where SomeInt :: String -> MyKey Int
07:10:20 <nobag> ertes: since I'm compiling from a GADT that would be super handy indeed!
07:11:19 <ertes> nobag: it's not that much code…  mostly just wrapping and unwrapping Dynamic values within a regular map
07:11:36 <quchen> puregreen: None that make code more readable.
07:12:19 <ertes> nobag: data KeyWrapper k = forall a. (Ord (k a)) => KeyWrapper (k a)  -- something like that
07:12:35 <ertes> and then:  newtype MyMap k = MyMap (Map (KeyWrapper k) Dynamic)
07:12:36 <ertes> that should do it
07:13:01 <ertes> as said: it's a bit overengineered, but the code is pretty small
07:15:42 <orion> Do people ever use GHCJS in conjunction with JS frameworks like Angular?
07:26:13 * hackagebot timelike 0.2.1 - Type classes for types representing time  https://hackage.haskell.org/package/timelike-0.2.1 (esz)
07:31:01 <alikot> hi! can somebody help with reactive-banana?
07:32:00 <ertes> alikot: hi there, just ask
07:33:28 <alikot> wow. it works) well question is that it not works neither in windows with ghc 7.10.3 nor in linux with same version and haskell platform installed, the error message is like this:  Not in scope: type constructor or class `Frameworks'
07:33:47 <alikot> all the axamples give same error
07:47:19 <lyxia> "works"
07:47:25 <lyxia> what are you trying to do actually
07:48:14 <lyxia> alikot: what have you tried
07:48:40 <lyxia> alikot: is it code you have written ? Are you trying to install something ?
07:50:13 <alikot> I've tried all the examples that shipped with reactive banana. but all of them gives same error. Im pretty sure I've installed all the dependencies using cabal install. I even installed wx library fro graphics part. still has same error in linux and windows
07:52:00 <alikot> in ghci when I type ":m +Reactive.Banana.Frameworks" it works ok. so not sure why it complains about type constructor not in scope
07:52:31 <lyxia> well the error you are getting suggests you are trying to use Frameworks as a type
07:52:35 <lyxia> but it is just a module
07:54:23 <lyxia> alikot: what are you trying to compile, with what command
07:55:01 <alikot> but thats how it is used in examples. Im just running examples. it uses Frameworks as typeclass in examples like this: makeNetworkDescription :: Frameworks t => AddHandler Char -> Moment t ()
07:57:16 <lyxia> Do you have a link
07:57:29 <alikot> in each example you can find something like that: "let networkDescription :: forall t. Frameworks t => Moment t ()"
07:58:12 <ertes> Frameworks used to be a class, but apparently in newer versions it isn't anymore
07:58:46 <lyxia> The examples in the reactive-banana repo don't have this constraint anywhere
07:59:11 <ertes> even the time-threading phantom type is gone
07:59:44 <ertes> there used to be a type argument to every type:  Moment t a, Event t a, Behaviour t a
07:59:48 <ertes> it's no longer there
08:00:12 <ertes> from that i infer that old examples will no longer compile
08:00:44 <alikot> yes. checked latest repo its gone. seems like i cloned some forked repo with some old stuff
08:00:44 <seishun> http://lpaste.net/7862579728643784704 I was expecting the pattern match to fail and the do block to return Nothing. But apparently the let bindings aren't executed because of laziness. How do I do this without nested ifs?
08:00:49 <ertes> but the author most likely blogged about the change, so just look up heinrich apfelmus
08:01:58 <lyxia> seishun: use bind
08:02:05 <lyxia> seishun: Just _ <- Nothing
08:02:53 <alikot> thank you guys! the situation was solved so fast)
08:06:06 <seishun> lyxia: you mean _ <- Nothing ?
08:07:22 <lyxia> oh right
08:07:24 <lyxia> yes
08:09:12 <seishun> it still skips the reads line. I want it to return Nothing if the string can't be parsed as int
08:09:43 <seishun> probably gotta use listToMaybe
08:10:39 <lyxia> or maybeToList
08:10:55 <seishun> how would I use maybeToList here?
08:11:05 <lyxia> nvm
08:11:09 <ertes> seishun: note that Text.Read has readMaybe
08:11:14 <ertes> :t readMaybe
08:11:15 <lambdabot> Not in scope: ‘readMaybe’
08:11:23 <ertes> :t Text.Read.readMaybe
08:11:24 <lambdabot> Read a => String -> Maybe a
08:11:52 <ertes> otherwise a simple no-imports way to do it is foldr
08:11:52 <seishun> oh
08:12:08 <ertes> :t foldr (const . Just) Nothing
08:12:09 <lambdabot> Foldable t => t a -> Maybe a
08:12:30 <olpery> hey. when doing infinite lists with comprehensions and I ask for item X, is Haskell smart enough to compute item X or does it always run through the list up to that point, to generate it?
08:13:02 <ertes> olpery: it always runs through the list, but it doesn't necessarily compute the earlier items
08:13:22 <olpery> ertes: ok
08:13:24 <ertes> > map (^1000) (3 :: Word32) !! 1000
08:13:25 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘Word32’
08:13:25 <lambdabot>      In the second argument of ‘map’, namely ‘(3 :: Word32)’
08:13:25 <lambdabot>      In the first argument of ‘(!!)’, namely
08:13:49 <ertes> > map (^1000) (repeat (3 :: Word32)) !! 1000
08:13:51 <lambdabot>  3552074529
08:13:57 <ertes> wow, i'm stupid today
08:14:05 <olpery> but in theory, if the compiler was smart enough, it could sometimes compute it i suppose.
08:14:12 <ertes> > map (^1000) [3 :: Word32, 5 ..] !! 1000
08:14:13 <lambdabot>  2291513505
08:14:22 <seishun> ertes: isn't that foldr snippet just a replacement for listToMaybe?
08:14:46 <ertes> olpery: you could have ad-hoc rewrite rules, but you shouldn't count on them…  traversing a list always takes time
08:14:58 <ertes> seishun: yeah, it is, but you don't need an import =)
08:15:18 <ertes> seishun: also sometimes it's useful to use the slightly more general version
08:15:25 <ertes> :t foldr (const . pure) empty
08:15:26 <lambdabot> (Foldable t, Alternative f) => t a -> f a
08:15:49 <olpery> ertes: i mean, i you generate a list of natural numbers 1.. and ask for the billion'th one, the compiler could figure out "return 1 billion" and be done with it
08:15:53 <seishun> :t const
08:15:54 <lambdabot> a -> b -> a
08:16:32 <olpery> should be possible for simple generators/filters
08:16:40 <olpery> but not in general ofc
08:16:53 <jacksnipe1> hi all, I'm working through 'write yourself a scheme in 48 hours' and I just can't figure out how to install parsec. I ran `stack install parsec` but now I get the following error: http://lpaste.net/156945
08:16:59 <ertes> olpery: it could…  it would be correct to do so, but it's unrealistic
08:17:24 <ertes> olpery: that optimisation corresponds to trying to eliminate for-loops from C-like languages by looking at the computations within the loop
08:17:36 <olpery> right
08:17:39 <ertes> for some simple cases it's possible, but definitely shouldn't count on it
08:17:49 <olpery> no, surely not
08:18:08 <ertes> i believe GHC actually does eliminate some simple cases
08:18:17 <ertes> but only compiled GHC
08:18:20 <lyxia> jacksnipe1: add parsec to the build-depends of your .cabal file
08:19:02 <jacksnipe1> lyxia: what's the syntax for that? My build-depends currently is "build-depends:       base >= 4.7 && < 5"
08:19:46 <jacksnipe1> oh hey got it
08:19:49 <jacksnipe1> thanks lyxia you rock
08:21:39 <jacksnipe1> is there a way to specify it in stack.yaml instead of in my cabal file?
08:22:23 <lyxia> package dependencies go in the .cabal file
08:22:40 <jacksnipe1> oh I see, thanks
08:22:56 <lyxia> yw
08:28:45 <olpery> :t fmap
08:28:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:29:00 <aoeu> do you guys know about Elm?
08:29:04 <olpery> how do you read that? "Functor is a typeclass taking a functino f" ?
08:29:26 <olpery> "and f looks like a->b"?
08:31:32 <geekosaur> given some type "f" which has an instance of "Functor", "fmap" takes a function from a type "a" to a type "b", and a value of type "f a", and produces a value of type "f b"
08:33:32 <olpery> :t (+1) `fmap` [1,2,3]
08:33:33 <lambdabot> Num b => [b]
08:33:58 <olpery> hm, can i show the type of fmap, given a concrete use?
08:35:37 <pavonia> :t fmap `asAppliedTo` head
08:35:39 <lambdabot> Functor f => ([b] -> b) -> f [b] -> f b
08:35:47 <pavonia> olpery: Like that?
08:36:32 <olpery> well, [1,2,3] is a list of ints in my example, i'd like to see that explicitly in the type dump
08:37:47 <ClaudiusMaximus> :t flip (flip fmap `asAppliedTo` Nothing)
08:37:48 <lambdabot> (a -> b) -> Maybe a -> Maybe b
08:39:02 <olpery> no mention of int there
08:39:03 <ClaudiusMaximus> :t flip (flip fmap `asAppliedTo` []) `asAppliedTo` (+ 1)
08:39:04 <lambdabot> Num b => (b -> b) -> [b] -> [b]
08:39:44 <ClaudiusMaximus> :t flip (flip fmap `asAppliedTo` [1,2,3::Int]) `asAppliedTo` (+ 1)
08:39:46 <lambdabot> (Int -> Int) -> [Int] -> [Int]
08:39:55 <lyxia> :t let fmap' = fmap ; _ = flip fmap' ([1,2,3] :: [Int]) in fmap'
08:39:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:40:17 <lyxia> where is my monomorphism restriction
08:42:04 <olpery> :t fmap
08:42:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:42:05 <olpery> :t flip (flip fmap `asAppliedTo` [1,2,3::Int]) `asAppliedTo` (+ 1)
08:42:06 <lambdabot> (Int -> Int) -> [Int] -> [Int]
08:42:16 <olpery> not entirely satisfied
08:46:22 * hackagebot text-show 3.2 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.2 (ryanglscott)
08:47:01 <pavolzetor> how would you implement shading language parser + interpreter? suppose you have rasterizer in haskell and want to read and use shaders
08:47:14 <pavolzetor> would you translate to haskell -> compile with ghc and somehow link?
08:50:36 <pavolzetor> they do have translator to bytecode
08:53:43 <zero_byte> hello, do you know anyone, how to set member of structure ?
08:54:15 <zero_byte> like i have: data Human = Human { age :: Int, name :: String} deriving Show
08:54:46 <zero_byte> Human { age = 10, name = "Foo" }
08:55:09 <zero_byte> and then, I wanna change his name and I have this stored in variable human
08:58:45 <puregreen> zero_byte: improvedHuman = human {name = "April"}
08:58:52 * puregreen likes the name “April”
08:59:12 <zero_byte> ohh, I thought it
08:59:34 <zero_byte> puregreen, thanks
08:59:42 <puregreen> you're also welcome to name your human after SPJ, we need more Simons
09:00:00 <zero_byte> puregreen, hahaha, thanks
09:01:05 <zero_byte> puregreen, actually, it was just example, I have finite automate as data structure
09:01:17 <puregreen> oh
09:03:05 <MichaelBurge> I notice the documentation for HaXml on haskell.org seems to have some broken links
09:03:07 <MichaelBurge> http://projects.haskell.org/HaXml/
09:03:17 <MichaelBurge> Like if you click to the documentation for XsdToHaskell
09:11:23 * hackagebot text-show-instances 3.2 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.2 (ryanglscott)
09:21:27 <broma0> if i have a (m :: Map String (Map String (Map String String))), how can I create a new "branch" using lens? `m & at "a" . at "b" . at "c" .~ Just "d"` doesn't change the map unless the "a" > "b" part already exists. I need the function to create parents.
09:24:36 <puregreen> broma0: see the example here: http://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Iso.html#v:non
09:24:45 <broma0> also, does GHC automatically memoize pure functions? will calling something like `add a b = a + b` with the same inputs multiple time spend the CPU cycles to recompute every time?
09:24:51 <broma0> puregreen: thanks, looking into it now
09:25:10 <puregreen> no, GHC doesn't automatically memoise functions, it only memoises values
09:25:24 <aweinstock> broma0: memoization isn't a pure optimization for functions, it's a spacetime tradeoff
09:25:29 <puregreen> i.e. if you write “fac100 = product [1..100]”, it will only be computed once
09:25:32 <hpc> "memoise" values
09:25:56 <aweinstock> s/a pure/always an/
09:26:16 <broma0> i see, well i have a function "mkFilepath :: SomeTextThing -> SomeOtherTextThing -> FilePath" that hashes it's inputs to determine the filepath, and i dont want to waste time recomputing the hash
09:26:29 <puregreen> hpc: hm?
09:26:58 <broma0> aweinstock: thats a good point..
09:27:03 <broma0> aweinstock: didnt think of that, thanks
09:27:12 <hpc> it's just a funny use of the word, to describe thunks mutating to their result value on evaluation
09:27:13 <broma0> puregreen: non is awesome
09:27:18 <broma0> puregreen: thank you
09:27:47 <puregreen> broma0: there are several packages that provide almost-automatic memoisation (you just need to use the function ‘memo’ or something similar in the right place)
09:28:00 <hpc> broma0: typically the way functions get memoised is by being rewritten as a lookup into a data structure
09:28:19 <hpc> and the data structure is written as an infinite list/tree/whatever of result values
09:29:06 <hpc> as you evaluate deeper into the structure, it becomes more and more evaluated and stays that way
09:29:22 <hpc> the tradeoff being that it can start consuming a huge amount of memory if you are memoising large inputs
09:30:43 <hpc> deciding if there's a time save to be gained by memoisation and what the correct data structure to use is, is not an automatable problem
09:30:56 <ij> Does encoding build very slowly to y'all as well?
09:33:55 <puregreen> ij: currently stuck at the “preprocessing” stage
09:36:11 <aweinstock> broma0: if you're willing to change the last part to (IO FilePath) or possibly (ST s FilePath) you could use an (IORef (Map (SomeTextThing, SomeOtherTextThing) FilePath)) to cache things
09:36:36 <aweinstock> and once you do that, you can probably fake purity with unsafePerformIO and since it's caching, it's probably safe
09:40:27 <puregreen> ij: yeah, 7m already and it's still processing whatever it's processing
09:40:47 <ij> Odd.
09:41:03 <ij> I guess I'll just keep waiting.
09:45:09 <puregreen> ij: done processing for me
09:45:24 <broma0> aweinstock: if the need arises, that sounds totally cool
09:45:26 <broma0> thanks again
09:45:53 <ij> puregreen, Still running on my ancient box.
09:46:05 <puregreen> (it was a 800kB GB18030.xml file, and the result of the processing is a 1MB .hs file)
09:47:57 <ij> It's got no issue tracker, so all I can do is whine to dev's email, which doesn't guarantee anything'll change.
09:51:50 <MichaelBurge> ij: I think I remember installing one of those encoding libraries before, and it take a very long time. It did eventually succeed, but I ended up using a different library.
09:52:30 <Philonous> I wonder, when I have a bunch of functions that take large records as parameters, is it better to document the records directly next to the respective functions or to put them somewhere else to keep a clear overview for the functions 
09:52:48 <ij> Are there other packages that translate a strict/lazy bytestring containing utf-8 into a proper String?
09:53:13 <MichaelBurge> ij: Yeah, text
09:53:30 <MichaelBurge> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
09:53:32 <Cale> ij: Data.Text.Encoding is what everyone uses for this.
09:54:30 <ij> It works on both without needing to do manual function call renaming?
09:54:49 <MichaelBurge> ij: There's also Data.Text.Lazy.Encoding
09:54:54 <ij> ah.
10:01:33 * hackagebot csound-expression-typed 0.0.9.3 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.9.3 (AntonKholomiov)
10:01:35 * hackagebot csound-expression 5.0.1 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-5.0.1 (AntonKholomiov)
10:04:30 <bluezone> Hey folks, I am back :) Time to dive in!
10:18:08 <tippenein>  Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
10:18:31 <monochrom> yes, you are not supposed to do that
10:18:52 <monochrom> for example "many (many spaces)" is troublesome
10:19:20 <tippenein> ohh, ok. I have a `string " "`
10:19:39 <monochrom> many (string " ") is ok
10:20:57 <lpaste> tippenein pasted “many context ^” at http://lpaste.net/156947
10:21:46 <monochrom> then it's eof
10:22:09 <pantsman_> with stack, is there a command like 'stack repl' but for working with files in a test suite?
10:22:29 <monochrom> well, I haven't tested that, but that's my Sherlock-Holmes-style guess (i.e., everything else is readily eliminated)
10:23:40 <tippenein> monochrom: I think you're right, so I removed it. now it's 'unexpected end of input'. Is that different than eof?
10:24:44 <monochrom> you should test for eof outside manyTill, not inside
10:26:25 <monochrom> no, that doesn't explain anything. "manyTill anyToken eof" should be ok
10:35:18 <monochrom> tippenein: what is eol?
10:37:07 <tzaeru> monochrom, end of line?
10:37:31 <monochrom> unfortunately your answer is context-free
10:41:11 <roelof> How to solve this : http://lpaste.net/156948  , I did add QuickCheck on the test part of the cabal file. This error message I only see when I do stack ghci , :l Spec.hs 
10:41:43 * hackagebot rasterific-svg 0.3.1 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.3.1 (VincentBerthoux)
10:45:10 <hsk3> Why does    pure "asdf"   print out    "asdf"    in GHCi? Is this some GHCi special case magic?
10:45:48 <xa0> it is assumed to be IO [char], which is then evaluated back to [char]
10:45:51 <xa0> so yes
10:45:59 <xa0> GHCi can automatically unwrap IO values
10:46:24 <hsk3> xa0: so GHCi has a "default applicative", or "default monad", of IO?
10:46:32 <hsk3> If it's a generic applicative/monad, it becomes IO?
10:46:43 * hackagebot radium 0.6 - Chemistry  https://hackage.haskell.org/package/radium-0.6 (klangner)
10:47:21 <xa0> in this case yeah (i think) because it evaluates either "a" or "IO a"
10:47:34 <xa0> in the same way that main has type "a" or "IO a"
10:47:39 <xa0> for some a
10:48:11 <noteventime> I had no idea main could have a non IO type
10:48:33 <xa0> don't see why not :p
10:49:00 <noteventime> '' Couldn't match expected type ‘IO t0’ with actual type ‘Int’ '' ?
10:49:24 <xa0> wait, does it not work?
10:49:31 <xa0> I'm sure i've done that before
10:49:33 <noteventime> xa0: Not for me
10:49:58 <xa0> bizarre. okay I take it back
10:50:03 <xa0> but at least ghci functions that way
10:50:31 <noteventime> xa0: Apparently it works as long as the type can be specialised to IO t
10:50:41 <xa0> ah
10:50:43 <noteventime> so "main :: a; main = undefined" is ok
10:50:50 <xa0> fair enough
10:55:30 <roelof_> Anyone who knows how to solve this :http://lpaste.net/156952 . QuickCheck is added to the cabal file. I see this when I do stack ghci ; :l Spec.hs 
10:56:43 * hackagebot rasterific-svg 0.3.1.1 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.3.1.1 (VincentBerthoux)
11:02:59 <tippenein> i defined eol = char '\n'
11:06:20 <lyxia> roelof_: is your package available somewhere?
11:08:44 <roelof_> At this moment not, but I can make it avaible by putting it on github, But first dinner 
11:14:41 <monochrom> tippenein: I can't reproduce the error message "combinator 'many' is applied to a parser that accepts an empty string". I tried the input string "xx$$yy:zz". the cause is elsewhere.
11:21:44 * hackagebot giphy-api 0.2.3.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.2.3.0 (passy)
11:21:46 * hackagebot asciidiagram 1.3 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.3 (VincentBerthoux)
11:35:28 <Guest91888> http://cur.lv/wo54f
11:36:04 <MichaelBurge> > length (1,2,3)
11:36:05 <lambdabot>      No instance for (Foldable ((,,) t0 t1))
11:36:05 <lambdabot>        arising from a use of ‘length’
11:36:05 <lambdabot>      In the expression: length (1, 2, 3)    No instance for (Num t0) arising ...
11:36:15 <MichaelBurge> > length (1,2)
11:36:17 <lambdabot>  1
11:37:10 <MichaelBurge> Why is there apparently a Foldable instance for (a,b)?
11:42:51 <Aleksejs> Hi, in the context of code effectiveness, which way is better? http://vpaste.net/YMUNW
11:43:11 <lethjakman> So, I'm having issues understanding something that's probably really simple and I would appreciate a nudge in the right direction. How does being "inside" of a monad work? 
11:43:23 <lethjakman> I'm looking at "ask" from reader, and I've noticed it doesn't have any input
11:43:25 <Cale> lethjakman: "inside" doesn't really make sense
11:43:28 <lethjakman> But it runs readre id
11:43:46 <lethjakman> Cale: OK, good. That means I'm confused about the right thing. 
11:43:51 <lethjakman> How the heck is "ask" working?
11:43:55 <Cale> ask is a computation whose result is the environment
11:43:56 <MichaelBurge> lethjakman: 'inside' of a monad means 'constructing a value belonging to a type that is an instance of monad'
11:43:59 <lethjakman> It has no input, but it seems to know about the m onad. 
11:44:00 <Cale> when it's executed
11:44:13 <lethjakman> How does it have the environment though? It's a new function with no input. 
11:44:28 <Cale> lethjakman: Internally, Reader computations are functions of the environment
11:44:33 <MichaelBurge> lethjakman: Think of the Reader monad as defining a function State -> Value rather than just a Value.
11:44:37 <roelof_> lyxia:  you can find the code here : https://github.com/rwobben/haskellbook/tree/master/chapter_14/qcExercises
11:44:47 <Cale> The implementation of (>>=) distributes the environment parameter to everything.
11:44:50 <MichaelBurge> when you runReader, it finally applies the built up function to get a value
11:44:59 <roelof_> Anyone who knows how to solve this :http://lpaste.net/156952 . QuickCheck is added to the cabal file. I see this when I do stack ghci ; :l Spec.hs 
11:44:59 <Cale> Let's actually write it step-by-step
11:46:02 <Cale> I'll make some small changes to the usual definition just for the purposes of making it easier to talk about (usually the data constructor is named Reader, I'll call it R to distinguish it from the type constructor)
11:46:13 <lethjakman> MichaelBurge: I'm a bit confused as to how it gets the value though with the type of "ask :: MonadReader r m => m r"
11:46:28 <lethjakman> Cale: OK. 
11:46:43 <Cale> So Reader e a is supposed to be a type of computations which may access an environment of type e while resulting in a value of type a
11:46:47 <MichaelBurge> lethjakman: It doesn't get the value. It helps define a function that depends on that value, and then you plug it in later.
11:47:11 <Cale> Since we're using a functional language, the easiest way to represent such a computation is as a function of type e -> a
11:47:38 <Cale> (We could opt for some kind of abstract syntax, but for various reasons, that would be more complicated)
11:47:50 <Cale> So we define  newtype Reader e a = R (e -> a)
11:48:15 <Cale> and we want a way to take a Reader e a computation, and an environment of type e to use, and get the result of type a
11:48:23 <Cale> runReader :: Reader e a -> e -> a
11:48:38 <Cale> runReader (R f) e = f e
11:48:55 <Cale> We've basically optimised our representation to make this function trivial to write
11:49:11 <Cale> With some other sort of representation, it might be some kind of interpreter instead
11:49:35 <Cale> lethjakman: make sense so far?
11:49:36 <lethjakman> OK
11:49:42 <lethjakman> Ummmm. lemme reread that 
11:50:23 <lethjakman> Yes
11:50:42 <Cale> It might be worth pointing out we could simplify our definition of runReader:
11:50:47 <Cale> runReader (R f) = f
11:51:06 <lethjakman> Yeah, it's normally a newtype, right?
11:51:09 <Cale> and since it's just a field extractor then, we could also have just used record syntax when defining the newtype
11:51:21 <Cale> newtype Reader e a = R { runReader :: e -> a }
11:51:47 <lethjakman> Yeah, that always confuses me a little...
11:51:56 <Cale> Since that gives us a function by that name which extracts the function e -> a from the record
11:52:03 <lethjakman> So you have a type Reader with an e and an a inside of it
11:52:07 <Cale> nope!
11:52:34 <Cale> e -> a means a function from values of type e to values of type a
11:52:40 <Cale> not a pair of an e and an a
11:52:52 <Cale> It's something which if you give it an e, it will result in an a
11:53:27 <Cale> right?
11:53:49 <Cale> Reader is parameterised on the choice of types e and a
11:53:54 <lethjakman> OK
11:53:55 <lethjakman> Shs Mker renre. 
11:53:58 <lethjakman> Whoops
11:54:00 <lethjakman> OK 
11:54:02 <lethjakman> That makes sense
11:54:04 <Cale> okay
11:54:05 <lethjakman> That's colemak hand misplacement. 
11:54:35 <Cale> All right, so let's have a look at (>>=)
11:54:48 <Cale> actually, before (>>=), perhaps lets start with the easy one, return
11:54:54 <Cale> return :: a -> Reader e a
11:55:20 <Cale> return v is supposed to be the action which always produces v as its result
11:55:52 <Cale> return v = R ... -- we don't yet have many ways to build Reader e a actions, so might as well use the data constructor
11:56:12 <Cale> return v = R (\e -> ...) -- it takes a function of type e -> a, so that might as well be a lambda
11:56:32 <Cale> return v = R (\e -> v) -- we ignore the environment, producing v as the result
11:56:46 <Philonous> Is there any particular reason that a library like wreq should use String rather than Text for the URLs ?
11:57:02 <Cale> Philonous: it's pretty arbitrary
11:57:08 <roelof_> Anyone who knows how to solve this :http://lpaste.net/156952 . QuickCheck is added to the cabal file. I see this when I do stack ghci ; :l Spec.hs 
11:57:27 <Philonous> My rule of thumb has been to always replace String with Text unless there's a good reason not to
11:57:36 <Cale> Philonous: Given that URLs are not typically very long, it might be more convenient to use String
11:57:57 <Cale> Saves you having to T.pack
11:57:59 <caconym> Philonous: some might say that String is more convenient than Text and iirc wreq is built for convenience (among other things, presumably)
11:58:14 <Philonous> Cale, When would you have to T.pack when you never have Strings to start with?
11:58:58 <Cale> Well, fair enough, I suppose you can use OverloadedStrings or something
11:58:59 <lethjakman> I don't think I noticed the return in reader examples...
11:59:10 <Philonous> Oh, if you don't have OverloadedStrings, you would.
11:59:15 <MichaelBurge> Are there any plans to replace String with Text in the Prelude?
11:59:15 <Philonous> Right
11:59:29 <Cale> lethjakman: well, it'll be important as soon as we start composing things together
11:59:35 <caconym> it can still be a pain if you're working with libraries that use String or some ByteString
11:59:38 <Cale> lethjakman: So, let's now take a look at (>>=)
11:59:41 <caconym> literals are easy
11:59:55 <Cale> (>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b
12:00:13 <Philonous> caconym, Well, IMO no library should use String. Problem solved.
12:00:24 <caconym> ha, i agree :)
12:00:31 <Cale> This is actually possible to write without understanding anything, just by following what the types tell you to do, so let's do that, and have a look at what we get
12:00:42 <Cale> x >>= f = ...
12:00:55 <caconym> but for the time being... i still find myself having to throw around convertString with reckless abandon
12:01:21 <Cale> So we have x :: Reader e a, and f :: a -> Reader e b, and we want a result of type Reader e b. If we had something of type a, we could just apply f, but we don't.
12:01:37 <undoall_> If you ask me, all library functions should return types of (IsString s) => s
12:01:50 <undoall_> You know, because choice
12:01:52 <Philonous> MichaelBurge, That's a hard change to push through, for hysterical raisins. OTOH we already had a bunring bridges update. 
12:01:58 <Cale> So, let's just use the data constructor in order to build our Reader e b:
12:02:05 <Cale> x >>= f = R ...
12:02:20 <Cale> x >>= f = R (\e -> ...) -- and again, we might as well make this function argument be a lambda
12:02:31 <MichaelBurge> Philonous: I think the only thing you'd have trouble working around would be people pattern-matching on it as a list. For all the list functions, you can also switch to Foldable
12:02:45 <eyepatch> I'm getting a pattern matching error, and I'm not sure how to fix it. http://ideone.com/8WR1LG
12:02:56 <MichaelBurge> I wonder how often people seriously pattern match on Strings as lists of chars.
12:02:58 <eyepatch> Couldn't match expected type `Int' with actual type `[t0]'
12:03:00 <Philonous> undoall_, But what sensible choice is there for Unicode text besides Text?
12:03:01 <Cale> So, now we have e :: e, which will let us run x :: Reader e a in order to get the value of type a that we wanted:
12:03:41 <Cale> x >>= f = R (\e -> let v = runReader e x in ...)
12:03:48 <Philonous> undoall_, I'm all for convenience, but that strikes me as an unnecessary type class 
12:04:15 <Cale> lethjakman: following?
12:04:43 <Cale> lethjakman: We're just taking pretty much the only steps which are available to us
12:04:54 <Cale> (short of going into an infinite loop)
12:05:03 <Cale> So we now have
12:05:07 <Cale> v :: a
12:05:17 <Cale> f :: a -> Reader e b
12:05:21 <Cale> e :: e
12:05:29 <Cale> and we want to produce a result of type b
12:05:31 <lethjakman> Cale: Yes, I have one question though. Is there a way to se the reader version of >>= in ghci?
12:05:39 <Philonous> MichaelBurge, There's T.cons / T.uncons, and if you really want you can Text.pack . frobnicate . Text.unpack 
12:05:43 <Cale> lethjakman: No, the code for it is in the library
12:05:52 <Cale> (it's compiled)
12:06:18 <lethjakman> K. 
12:06:22 <Cale> You'll have to get the source code for transformers or something... the haddock documentation has source links
12:06:34 <Aleksejs> Can someone tell me which way is more effective? http://vpaste.net/YMUNW
12:06:51 <lethjakman> I think I'm getting this. 
12:07:15 <Cale> Okay, so what's the only move we can make? Apply f to v of course:
12:07:16 <Philonous> lethjakman, http://hackage.haskell.org/package/transformers-0.5.1.0/docs/src/Control-Monad-Trans-Reader.html#line-137
12:07:21 <Cale> f v :: Reader e b
12:07:36 <Cale> and then we want to run that, because we're after something of type b
12:07:43 <Cale> runReader (f v) e :: b
12:07:50 <Cale> so putting it together, we have
12:07:50 <lethjakman> Why is that in the transformer version?
12:08:03 <MichaelBurge> Aleksejs: I would probably do 'foo3 a = sqrt $ a * 2'. But I'd pick foo2 over foo1 to avoid a gratuitous use of monad.
12:08:04 <Cale> x >>= f = R (\e -> let v = runReader e x in runReader (f v) e)
12:08:18 <Cale> lethjakman: Oh, right, transformers defines Reader in terms of ReaderT
12:08:53 <lethjakman> So....is Reader just expanding on Reader Trans?
12:08:58 <eyepatch> got it. nvm.
12:09:17 <Cale> lethjakman: Well, Reader e is pretty much the same thing as ReaderT e Identity
12:09:27 <Philonous> Aleksejs, Does that even compile? foo1 should give you a type error 
12:09:36 <Cale> but save the transformers for later
12:09:41 <ij> Philonous, It works.
12:09:41 <Cale> So, ask
12:09:43 <Aleksejs> Philonous: it compiles
12:09:46 <Cale> ask :: Reader e e
12:09:58 <Cale> will be a computation which simply returns the environment as its result
12:10:12 <Cale> ask = R (\e -> ...) -- might as well start like this again
12:10:19 <Cale> ask = R (\e -> e) -- ... and done
12:10:26 <lethjakman> Got it. 
12:10:36 <Aleksejs> MichaelBurge: what I want to know is if they are not the same thing
12:10:57 <Cale> > runReader (do x <- ask; return (x + x)) 6
12:10:58 <lambdabot>  12
12:11:32 <Cale> Of course, that's just a baroque way of writing (\x -> x + x)
12:12:49 <Cale> Reader on its own is not very useful, but it's a good first step to understanding
12:13:16 <lethjakman> So...because it's being returned as a function so that runReader can invoke it on an environment...ask isn't filled in yet. 
12:13:38 <ij> Is it possible to ask a desugared version of source code from haskell?
12:13:41 <lethjakman> I'm still having issues understanding how ask is getting filled in though. 
12:13:44 <Cale> The result of ask is whatever we eventually plug in for the environment when we apply runReader, yeah
12:13:45 <roelof_> Anyone who knows how to solve this :http://lpaste.net/156952 . QuickCheck is added to the cabal file. I see this when I do stack ghci ; :l Spec.hs 
12:13:58 <Cale> Well, let's try just evaluating  runReader ask 5
12:14:11 <Cale> -> runReader (R (\e -> e)) 5
12:14:18 <Cale> -> (\e -> e) 5
12:14:20 <lethjakman> Is it because of the <-? 
12:14:22 <Cale> -> 5
12:14:39 <Cale> Oh, maybe I should have checked that you're familiar with do-notation...
12:14:49 <lethjakman> I am
12:15:11 <MichaelBurge> Aleksejs: I'm actually not sure which monad instance that is. My guess right now is the 'instance Monad ((->) r)' one.
12:15:17 <Cale> do { v <- x; <stmts> } -> x >>= (\v -> do { <stmts> })
12:15:25 <Cale> do { x } = x  -- base case
12:15:29 <Cale> So here
12:15:34 <Cale> do x <- ask; return (x + x)
12:15:35 <chipb> dmwit_: ping?
12:15:48 <Cale> -> ask >>= (\x -> return (x + x))
12:16:09 <Cale> and looking again at what (>>=) does
12:16:15 <Cale> x >>= f = R (\e -> let v = runReader e x in runReader (f v) e)
12:16:26 <Cale> It runs the action to its left, in this case ask
12:16:37 <Cale> oh, oops, I swapped some arguments there
12:16:43 <Cale> x >>= f = R (\e -> let v = runReader x e in runReader (f v) e)
12:16:45 <Cale> much better
12:16:52 * hackagebot texmath 0.8.5.1 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.5.1 (JohnMacFarlane)
12:17:35 <Philonous> MichaelBurge, I can't be any Monad, because the type of the RHS is a, that is, it's of the wrong kind
12:18:07 <MichaelBurge> Philonous: The other possibility is that you can use do notation with pure values as long as you don't use <- anywhere. I didn't know that
12:18:24 <Philonous> MichaelBurge, My guess of that's going on is that do { let b = a * 2; sqrt b} is just desugared to let b = a*2 in sqrt b, and no Monad instance is needed
12:18:25 <MichaelBurge> Running it with -ddump-ds doesn't show a Monad anywhere
12:18:57 <Philonous> MichaelBurge, Yes, that's why I was surprised it type checked. TIL.
12:19:36 <Cale> lethjakman: So, we'll have  v = runReader ask e  which as we determined above, means that v = e
12:19:38 <lyxia> roelof_: ah that might be because test dependencies aren't taken into account in most commands
12:20:04 <MichaelBurge> Aleksejs: So, to answer your question, they compile down to the exact same thing. But foo1 is much more likely to confuse people.
12:20:20 <Cale> lethjakman: and then the rest is  runReader (f v) e, which is  runReader ((\x -> return (x+x)) e) e  in this case
12:20:29 <roelof_> oke, so when I do :l Spec.hs  the QuickCheck is not used ? lyxia  
12:20:48 <Aleksejs> MichaelBurge: thanks!
12:20:49 <Cale> -> runReader (return (e+e)) e
12:21:11 <Cale> -> runReader (R (\k -> (e+e))) e
12:21:23 <Cale> -> (\k -> (e+e)) e
12:21:27 <Cale> -> (e+e)
12:22:32 <Cale> lethjakman: It's perhaps good to step through this once, but eventually you just regard x <- ask as meaning "let x be the result of running ask", which means it's automatically equal to the supplied environment.
12:22:33 <roelof_> lyxia:  but I also cannot do import QuickCheck from ghci 
12:22:33 <ij> MichaelBurge, How about no monads are involved since there's only one line? There are no new lines, thus >> is not introduced. And neither is <-, so no >>=. 
12:22:51 <ij> MichaelBurge, Thus no decision about what kind of monad it is made.
12:23:37 <lethjakman> Yeah, I just really want a good base understanding. I get how to use it, but I was having issues stepping past that.
12:23:51 <lyxia> roelof_: indeed for the same reason
12:24:13 <lpaste> tippenein pasted “optionMaybe parser not acting optional” at http://lpaste.net/156953
12:24:30 <tippenein> trying to use optionMaybe here ^ 
12:24:38 <roelof_> lyxia:  oke, I hope there is a way around it. I need to bring spec.hs to ghci to debug it 
12:24:57 <lpaste> Michael pasted “Loop” at http://lpaste.net/2177165883514814464
12:25:47 <lyxia> roelof_: You can turn the test into an executable
12:26:36 <lyxia> roelof_: oh, stqck ghci --test
12:26:36 <Mick_> Hi I'm having problems with some logic I am trying to
12:26:37 <Mick_> I
12:26:47 <Mick_> Implement
12:26:53 <roelof_> lyxia:  thanks, I will try it 
12:26:55 <roelof_> moment
12:26:58 <Mick_> The code is here: http://lpaste.net/2177165883514814464
12:27:03 <tippenein> oh, I just needed a `try`
12:27:08 <lyxia> roelof_: http://stackoverflow.com/questions/34558002/haskell-stack-ghci-test-suite
12:27:37 <Cale> lethjakman: The overall plan is to eventually make monads which are more interesting than Reader, which might have somewhat more complicated notions of what it means to run an action, and actions to run which do more things. Regardless, this general pattern that the implementation of x >>= f is likely to contain two instances of whatever function we use to run the actions of the monad, one to run x, obtaining some resu
12:27:37 <Cale> lt or results v (often along with some other stuff), and then again to run (f v) (possibly involving that other stuff somehow), is quite common. You'll see it again immediately if we implement the State s monad.
12:27:47 <lyxia> Mick_: what's the problem
12:28:19 <Mick_> Basically I have function which when first called has one parameter set with an initial value. When the function is evaluated thAt parameter should take the next value
12:28:37 <Mick_> It's the priceJump function 
12:28:52 <Mick_> I'm a noob so I'm probably doing this all wrong
12:29:06 <lyxia> Mick_: in the last line, subistitute ") <$> (" with " <$> "
12:29:06 <MichaelBurge> Mick_: The rnd parameter is the one that you want to differ every time the function is called?
12:29:21 <Cale> Mick_: You probably want to run the action priceJump, and put its result in that place
12:29:25 <lyxia> damn that's not right
12:29:29 <Mick_> Thanks
12:29:35 <lpaste> chipb pasted “X11/Xrandr binding fix” at http://lpaste.net/156954
12:29:50 <seishun> is there a significant difference between using MaybeT with Writer, and using WriterT with Maybe?
12:30:01 <Cale> do price' <- priceJump price rate vol ts <$> normal 0 1 gen
12:30:14 <Cale>    loop gen (turns - 1) price' rate vol ts
12:30:36 <lyxia> seishun: one writes even if the action failed, the other doesn't
12:30:51 <chipb> I was trying to fix a problem in X11 bindings, but I'm not really sure how this particular case should be restructured. ^^^
12:30:57 <MichaelBurge> seishun: The second one usually makes more sense
12:31:03 <lethjakman> OK....I think I get that
12:31:07 <chipb> anyone mind taking a look?
12:31:12 <lethjakman> Cale: Thank you so much for explaining this to me. 
12:31:13 <Cale> Mick_: In a do-block for the monad m, if you have  v <- x  with x :: m t, then you'll have v :: t
12:31:25 <lyxia> seishun: compare Maybe (w, a) and (w, Maybe a)
12:31:30 <Mick_> Yes the rnd value changes but also the price after each evaluation of priceJump
12:31:39 <roelof_> lyxia:  thanks, that solved the problem
12:31:53 <Cale> Mick_: You should think of something of type m Double here as being a computation which each time you'd run it, will give you a Double, probabilistically.
12:31:56 <roelof_> Anyone who can give me feedback on these solutions ; http://lpaste.net/156955
12:32:00 <lyxia> roelof_: you're welcome
12:32:04 <Cale> Mick_: So, it's like a random variable of Doubles
12:32:45 <Mick_> Yes
12:32:51 <lyxia> chipb: What's the problem
12:32:55 <Mick_> The price is randomly generated
12:33:20 <Mick_> Following a guassian distribution
12:33:26 <Cale> Mick_: and there are various shortcut notations, but do-notation gives you an easy way to build such random variables by describing how they "run" other random variables to obtain results and combine those together, or use them to determine what to run next.
12:33:32 <chipb> I've marked the problematic line with a "!!!" (excess XFree call), but being novice, I don't see an obvious solution.
12:34:04 <Mick_> Ok Cale - I'll look into it
12:34:06 <chipb> I suspect I'm just being stupid though.
12:34:15 <lyxia> roelof_: your listOrdered function only keeps track of the last comparison
12:34:37 <chipb> lyxia: in case you missed it earlier http://lpaste.net/156954
12:34:40 <roelof_> lyxia:  ??? 
12:34:45 <Cale> chipb: There are a couple options: you can either case again, or you can just add  " >> xFree ptr" to the end of the requisite branches
12:35:07 <Cale> oh, right, but you want the dat result
12:35:15 <Cale> So, yeah, use do-notation instead
12:35:33 <chipb> Cale: wouldn't ">> xFree ptr" unconditionally execute the xFree in any case?
12:35:33 <roelof_> lyxia:  what is the problem. Here I do the same : propHalfx x = halfIdentity x == x
12:35:48 <Cale> chipb: not if it was inside a branch of the case
12:36:16 <chipb> oh, of course. that's pretty blindly obvious in retrospect. heh.
12:36:16 <Cale> 8 -> do xs <- peekArray nitems ptr; xFree ptr; return (map fromIntegral xs)
12:36:50 <chipb> that seems pretty reasonable.
12:37:07 <chipb> won't win a beauty contest, I imagine, but it should work.
12:37:09 <lyxia> roelof_: listOrdered [1,2,1] ?
12:37:30 <roelof_> that schould be false  
12:37:36 <seishun> lyxia: well I want to stop writing if the action failed
12:37:46 <chipb> library bindings probably never win beauty contests, now, do they?
12:37:48 <seishun> do I use the first one in that case?
12:37:54 <Cale> (or you can keep the fmap, but I figured since we're going to use return anyway...)
12:38:07 <chipb> Cale: thanks for the help.
12:38:14 <Cale> no problem
12:38:35 <lyxia> roelof_: Ah somehow I didn't see the first line of go
12:39:50 <lyxia> roelof_: == True is id
12:40:43 <roelof_> lyxia:  according to hlint that part could be deleted 
12:41:36 <lyxia> I prefer listOrdered either using explicit recursion or zip . tail
12:42:13 <ij> MichaelBurge, I am right: http://sprunge.us/ZIWH
12:42:35 <roelof_> lyxia:  listOrdered is a given function in the haskell book for this exercise 
12:42:55 <lyxia> fine
12:43:09 <roelof_> the challenge for me was to write a test which is using it , so I can prove that sort is working 
12:49:47 <seishun> "MonadWriter w m => MonadWriter w (MaybeT m) " how do I read this? given a MonadWriter instance m, MaybeT m is also a MonadWriter instance?
12:50:27 <roelof_> last question : How can I see which values quickCheck uses on my code. Or how can I see a sample with my two prop-* functions ? 
12:50:57 <chipb> Cale: is there a function 'xxxxx' that passes through a value, but could order the xFree operation? something like "15:35 < Cale> 8 -> do xs <- peekArray nitems ptr; xFree ptr; return (map fromIntegral xs)
12:51:07 <MichaelBurge> seishun: Yeah. I'd probably read it as "If m is monad that can be written in, then MaybeT m is also a monad that can be written in.'
12:51:09 <chipb> (whoops. sorry.)
12:51:45 <chipb> Cale: something like "peekArray nitems ptr >>= xxxxx xFree ptr >>= fromIntegral"?
12:51:53 * hackagebot config-manager 0.2.0.0 - Configuration management  https://hackage.haskell.org/package/config-manager-0.2.0.0 (guyonvarch)
12:51:57 <chipb> or am I just being silly?
12:53:09 <chipb> er. I guess "map fromIntegral" on that last one.
12:53:42 <lyxia> roelof_: there's some stuff with label
13:01:23 <roelof_> lyxia:  label, I only learned to use sample or sample' 
13:01:30 <roelof_> can you give a example
13:08:32 <lyxia> roelof_: oh there's just verboseCheck
13:11:31 <roelof_> lyxia:  thanks , I will look at that one 
13:11:45 <roelof_> have all a good day/night 
13:15:03 <lyxia> :t (<$)
13:15:04 <lambdabot> Functor f => a -> f b -> f a
13:15:07 <lyxia> chipb: ^
13:25:48 <adas1> in classy prelude, what is the purpose of the mono-typeclasses?
13:26:44 <chipb> lyxia: huh. that...huh. thank you.
13:28:49 <aconz2> does anybody know the current status of henk (the typed IL)?
13:30:25 <lyxia> adas1: to use Text as traversable
13:30:55 <adas1> lyxia: whats wrong with the non-mono traversable typeclass?
13:31:06 <lyxia> adas1: you can't define Traversable on Text
13:31:15 <adas1> lyxia: oh. why is that?
13:31:27 <lyxia> Functor, Traversable, etc expect a type constructor of kind * -> *
13:31:51 <lyxia> Text has kind *, and is indeed not polymorphic in the contained type
13:32:11 <utdemir> Hey. Does any of you happen know a typeclass based command line argument parsing library? Like a "FromArgs" typeclass?
13:32:53 <adas1> ah yes. got it. so even though text is perfectly a traversable it cannot be made an instance of Traversable due to the kind problem?
13:37:27 <lyxia> Text is not Traversable in the sense chosen by base
13:37:45 <Cale> adas1: Well, it's only sort of kind of like a Traversable, in a very limited sense.
13:37:56 <Cale> and so they formalised what that limited sense was
13:49:41 <adas1> other than bytestrings and text are there any other types that are kind * and therefore cannot use the non-mono Traversable class
13:50:23 <hjulle> Have I understood correctly if I say that "Free monads are free as in free speech, not as in free beer?"
13:51:55 * hackagebot purescript 0.8.3.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.3.0 (PhilFreeman)
13:51:59 <shachaf> No.
13:55:09 <hjulle> shachaf: Are they free as the beer or is there a third meaning of the word that I haven't thought about? (Assuming that it was me you answered)
13:59:18 <aph> they're free as in left adjoint to forgetful functor
14:01:17 <lyxia> adas1: they're the only examples implemented by mono-traversable
14:01:50 <lyxia> adas1: oh, no there's IntSet
14:11:17 <mettekou> Does anyone know whether there is a Haskell library which facilitates syntax transformations/macros, whether it be using parser combinators or something else? I need something which does a job similar to Camlp5 for OCaml.
14:13:45 <hjulle> aph: Yes, but etymologically, why are such things called free?
14:15:08 <orion> Is there a way to lock a file (POSIX) in Haskell only using the unix module?
14:15:40 <orion> Err, I mean not using the filelock module.
14:16:58 * hackagebot socket 0.6.0.0 - An extensible socket library.  https://hackage.haskell.org/package/socket-0.6.0.0 (LarsPetersen)
14:24:33 <geekosaur> orion, System.Posix.IO, section "Locking"
14:25:04 <geekosaur> (we have again reached the time of day when my main network connection no longer talks to various places, like irc --- or my employer's machines...)
14:25:33 <orion> geekosaur: What package?
14:25:53 <orion> Oh, unix.
14:26:59 * hackagebot cmark 0.5.2 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.2 (JohnMacFarlane)
14:32:29 <mathu> i often find myself resorting to $ because my first guess for how a series of .s is going to work proves to be wrong. how does, for instance, `sum . filter even` work out to be `sum . (filter even)` instead of `(sum . filter) even`?
14:33:04 <Cale> mathu: Function application binds more tightly than *any* infix operator
14:34:04 <Cale> If there's only one thing about precedence to memorise, it would be that, and it's not even technically about precedence :)
14:34:17 <puregreen> mathu: ‘.’ separates the “stages” of the pipeline
14:34:34 <Cale> mathu: If you find yourself writing  f $ g $ h $ x  try replacing it with  f . g . h $ x
14:35:00 <puregreen> mathu: there are some cases when it's not obvious that something can even be a stage (e.g. “map . map”), but that's a separate issue :)
14:35:34 <Cale> Well, it composes functions to produce other functions
14:35:35 <mathu> Cale: ah, i didn't realize there'd be anything special about infix application
14:36:35 <Cale> mathu: Well, application is not even technically an infix operator
14:37:05 <mathu> Cale: er, i mean application of a function with infix notation
14:37:23 <mathu> Cale: i assume infix . holds the same properties as infix `div`
14:37:38 <Cale> yeah, pretty much apart from the precedence level being set differently
14:37:59 <mathu> perhaps i should choose something other than ` to denote code in #haskell haha. just realized the possibility of ambiguity
14:37:59 <Cale> infixl 7 `div`
14:38:03 <Cale> infixr 9 .
14:38:35 <mathu> wait, huh? the precedence level is different between them?
14:38:58 <mathu> how do you distinguish between operators and functions?
14:39:02 <Cale> yeah, composition is right associating and has precedence 9, which is the highest possible
14:39:15 <Cale> `div` is set to be left associating with precedence level 7
14:39:26 <Cale> infixr 0 $
14:39:49 <Cale> $ associates to the right (somewhat unfortunately, if you ask me), and has the lowest possible precedence, 0
14:40:29 <Cale> Whitespace function application isn't really an infix operator, but it behaves as if it were infixl 10 (i.e. higher precedence than any other infix operator could be, and associating to the left)
14:41:59 <tippenein> can anyone recommend a library for converting a Map -> Sparse Matrix library?
14:43:07 <Cale> tippenein: If I was using some FFI binding to a low-level matrix library, I might half-expect to have to write something like that myself.
14:43:23 <mathu> Cale: interesting. thanks for explaining! i'll poke around for more; probably about time i learn haskell a little deeper
14:43:29 <hjulle> mathu: I don't think you do. AFAIK "operator" is just another name for "function".
14:43:41 <Cale> mathu: try  :info (.)  in ghci
14:43:47 <mathu> hjulle: yeah, Cale's explanation cleared that up. it's just about precedence and associativity
14:44:30 <mathu> which is apparently a set-able thing, using language elements i've not touched
14:44:51 <Cale> mathu: Also, try that thing I suggested -- whenever you find yourself writing f $ g $ h $ x, just mindlessly replace it by f . g . h $ x
14:45:27 <Cale> This second form has some advantages: (.) is an honestly associative operator: f . (g . h) = (f . g) . h for any functions where that'll typecheck
14:45:38 <Cale> So this makes it easier to break the expression into pieces
14:45:43 <tippenein> Cale: not something like this? https://hackage.haskell.org/package/sparse-0.9.2/docs/Sparse-Matrix.html
14:46:06 <mathu> Cale: any particular reason the final one is a $? just because x may be an expression?
14:46:22 <Cale> mathu: Well, you're composing the functions and then applying them to an argument
14:46:28 <mathu> er, yeah
14:46:33 <Cale> rather than doing nested applications
14:46:35 <mathu> got that right after posting
14:46:41 <kamog> Cale: compiler can't find associativity of function applications from (f (g (h x)))?
14:46:53 <mathu> the reason it confused me is because the function i have here that made me wonder about this in the first place is written point-free
14:47:10 <Cale> Well, f g h x would mean something quite different: it means ((f g) h) x by convention.
14:47:14 <monochrom> kamog: function application is simply not associative. there is nothing to find
14:48:38 <Cale> mathu: So yeah, if you do this, you'll get into the mindset of writing function compositions gradually.
14:49:12 <mathu> got it. thanks again1
14:49:16 <hjulle> I kind of like using the form `(f . g . h) x`, despite the extra parens. 
14:51:32 <kamog> monochrom: yes, you're correct, but (f (g (h x))) is ((f . g) (h x)) by the main idea and ((f . g) (h x)) is (f . g . h) x. So, the question is whether the compiler can to reach the last composition form for which associativity is explicitly stated. (I'm new to haskell, so correct me if I'm wrong.)
14:51:52 <mathu> next i have to get a feel for how to break up long lines :v everything i do looks awkward
14:51:55 <Cale> kamog: I'm not sure what you mean by "reach" there
14:52:02 <Cale> kamog: what do you want the compiler to do?
14:52:31 <Cale> kamog: The compiler will typically inline the definition of (.) and ($) and simplify things a bit.
14:52:37 <Cale> (when it can)
14:52:54 <Cale> mathu: just press enter, and make sure the following line starts in a deeper column
14:53:07 <Cale> and it'll be a continuation of the previous one
14:53:25 <kamog> Cale: hmm, I don't know. But if it can prove that something is associative, can't it generate a better code?
14:53:57 <mathu> Cale: i can get it to work without issue, it just looks very uncomfortable haha
14:54:27 <mathu> right now i break and then indent to two spaces after the start of the current expression
14:54:42 <mathu> or just the start. but then i can wind up with huge indents
14:54:56 <monochrom> you can break a line into two. some positions are better than others.
14:55:40 <Cale> kamog: Well, associating to the right is pretty much the best thing that you can do with respect to (.)
14:55:44 <monochrom> if that is not good enough, you can also factor out a subexpression into a variable and a definition
14:56:03 <Cale> kamog: I suppose it might use the associativity to do that, but that's the associativity you get if you leave the parens out
14:56:09 <Cale> kamog: But more often, it's just going to inline
14:56:21 <monochrom> for example if you feel "(x + y) * z" to be too long, there is always "v * z <a few lines later> where v = x + y"
15:12:44 <kxl> do you specify compiler optimization levels in a project's cabal file or the stack file?
15:12:52 <kxl> (stack yaml i mean)
15:15:52 <maerwald> you shouldn't assume people use stack
15:16:28 <kxl> maerwald are you talking to me? i'm asking for my own use...
15:20:27 <seishun> is there a standard function to convert a list of tuples to a tuple of lists?
15:20:57 <seishun> :t unzip
15:20:58 <lambdabot> [(a, b)] -> ([a], [b])
15:21:02 <seishun> seems to be what I need
15:21:18 <hjulle> not really
15:22:06 <hjulle> oh, wait, I read your question wrong. Yes that is what you want.
15:29:40 <sydneyhacker_> Hi I have a question about the fix function. I am messing around with ghci and I seem to be able to define it as: fix' f = f (fix' f)
15:30:02 <sydneyhacker_> so how come a let binding is used in the source code of the fix function
15:30:19 <sydneyhacker_> i.e. fix f = let x = f x in x
15:31:37 <seishun> is there a simple way to convert `MaybeT m a` to `m ()`, discarding the result?
15:32:40 * seishun is looking at mapMaybeT 
15:33:17 <Lokathor> if anyone would care to sanity check a module: https://github.com/Lokathor/ireniko/blob/master/src/Data/IRC.hs
15:36:54 <seishun> I think I'm just looking for a shortcut for `something >>= return ()`
15:37:22 <seishun> I mean >>
15:37:31 <Lokathor> unitify a = a >> return ()
15:37:34 <Lokathor> :3c
15:37:35 <xa0> ^
15:38:15 <seishun> that's not standard, right?
15:38:54 <monochrom> sydneyhacker_: both ways give the same answer. but the "let" way builds the thing just once.
15:39:10 <Lokathor> seishun, nope, just throw it on a line where you need it
15:39:51 <monochrom> for example compare "fix' (0 :) = 0 : fix' (0 :)" vs "fix (0 :) = let x = 0 : x in x"
15:39:53 <sydneyhacker_> monochrom thanks - I am going to try running ghc with desugar to see if the compiled code looks any different
15:39:56 <Lokathor> untifty :: Monad m => m a -> m (), so it's pretty broad. You could put it into a utils module.
15:40:38 <seishun> :t (<<)
15:40:39 <lambdabot>     Not in scope: ‘<<’
15:40:39 <lambdabot>     Perhaps you meant one of these:
15:40:39 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
15:41:01 <xa0> :<
15:41:26 <Lokathor> :t unitify getLine
15:41:27 <lambdabot> IO ()
15:41:42 <seishun> :t return () :< getLine
15:41:43 <lambdabot>     Not in scope: data constructor ‘:<’
15:41:43 <lambdabot>     Perhaps you meant one of these:
15:41:43 <lambdabot>       ‘Seq.:<’ (imported from Data.Sequence),
15:41:54 <xa0> :t Control.Monad.(<<)
15:41:55 <lambdabot>     Not in scope: data constructor ‘Control.Monad’
15:41:55 <lambdabot>     Perhaps you meant variable ‘Control.Monad.ap’ (imported from Control.Monad)
15:41:55 <lambdabot>     Not in scope: ‘<<’
15:42:02 <xa0> :t Control.Monad.<<
15:42:03 <lambdabot> parse error on input ‘Control.Monad.<<’
15:42:31 <Lokathor> with this sort of stuff you should usually send PMs to lambda bot until you find the right answer
15:42:38 <Lokathor> and then repeat the command that does work in the channel
15:43:38 <seishun> hm, there's a flipped version of >>=, why isn't there a flipped version of >>?
15:43:57 <seishun> oh wait
15:43:59 <seishun> :t void
15:44:00 <lambdabot> Functor f => f a -> f ()
15:44:07 <seishun> isn't this our unitify?
15:45:16 <seishun> :t void getLine
15:45:18 <lambdabot> IO ()
15:46:07 <lpaste> tippenein pasted “how to clean this parser up?” at http://lpaste.net/156966
15:46:09 <MarcelineVQ> :t (<*) -- does the job of a flipped >> since monads are appliactive
15:46:10 <lambdabot> Applicative f => f a -> f b -> f a
15:46:20 <Cale> It's not really flip (>>) though
15:46:21 <Lokathor> void seems to be it
15:46:39 <seishun> so just `void $ runMaybeT $ do ...`, simple enough
15:46:56 <Cale> It still runs the actions in the same order, it just produces the result of the first instead
15:47:11 <Lokathor> a critical difference i'd say
15:48:51 <monochrom> tippenein: return (Feature row col value desc)
15:52:31 <tippenein> monochrom: *facepalm*  thanks
16:01:52 <seishun> there's no reason to depend on both mtl and transformers, right?
16:02:29 <seishun> I started with mtl but it doesn't have MaybeT, so might as well switch completely to transformers
16:02:58 <lyxia> I think that's one reason to depend on both
16:03:11 <sydneyhacker_> monochrom: ok so the fix with let seems to optimise to something simpler
16:03:17 <seishun> does mtl have anything that transformers doesn't?
16:03:25 <lyxia> classes
16:03:53 <sydneyhacker_> i.e. it doesn't "look" recursive
16:04:12 <sydneyhacker_> but I am not familiar with the syntax of the core syntax
16:04:20 <lyxia> seishun: The typeclass interface of MTL is very nice and allows you to write code that is oblivious of the exact stack you are using
16:07:02 * hackagebot redis-io 0.6.0 - Yet another redis client.  https://hackage.haskell.org/package/redis-io-0.6.0 (ToralfWittner)
16:07:36 <seishun> oh, without a MonadWriter I can't use tell inside MaybeT Writer without lifting
16:07:44 <seishun> so I guess I'll use mtl after all
16:09:16 <puregreen> seishun: mtl is for classes, transformers is for transformers themselves – mtl doesn't actually provide StateT, WriterT, etc, it just reexports them from transformers
16:10:25 <puregreen> seishun: so, for MaybeT you use transformers, and for overloaded functions like “tell”, “ask”, etc that can work in *arbitrary transformer stacks* you use mtl
16:11:10 <seishun> that seems like quite a mess
16:12:26 <seishun> is there any initiative to simplify this?
16:12:43 <aph> hjulle: re etymology of 'free': fair question... i read it as 'unconstrained', so i guess that is indeed more like speech than beer
16:14:10 <puregreen> seishun: the problem is that mtl is not the only way to implement overloaded “tell” and so on
16:14:30 <puregreen> seishun: there are lots of other libraries providing classes for transformer stacks
16:14:54 <hjulle> aph: Yes, that was my point. But yes, I should probably have expressed it as "more like free speech than..".
16:14:58 <puregreen> seishun: but they all use the same transformer types (WriterT/ReaderT/etc)
16:15:19 <puregreen> seishun: so, you can't just unify mtl and transformers
16:19:03 <seishun> puregreen: is there any case where you would want to import Control.Monad.Trans.Foo when Control.Monad.Foo is available?
16:19:21 <johnw> if you need the FooT version
16:20:03 <seishun> mtl reexports FooT anyway
16:20:13 <johnw> yeah?
16:20:26 <puregreen> https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Reader.html
16:20:27 <puregreen> yep
16:21:05 <johnw> huh
16:22:17 <aph> hjulle: fair enough. my point was supposed to be that the mathematical sense of a word might have little to do with the non-mathematical sense of the word. eg hylomorphism...
16:25:43 <hjulle> My other point was to make a joke, because both freedom in the literal sense and free as in beer are quite absurd when talking about mathematical concepts. ;)
16:25:43 <johnw> which is the sense that Haskellers use?
16:26:26 <hjulle> https://en.wikipedia.org/wiki/Free_object
16:27:03 * hackagebot haskellscrabble 2.2.2 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-2.2.2 (happy0)
16:38:54 <dalcde> hjulle: free as in without restriction?
16:40:53 <hjulle> It is kind of the same. Free speech is speech without restriction.
16:41:13 <maerwald> I don't think so
16:41:53 <hjulle> maerwald: How would you define free speech?
16:42:04 * hackagebot morte 1.5.1 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.5.1 (GabrielGonzalez)
16:42:43 <maerwald> hjulle: pretty offtopic isn't it? But it usually involves restrictions.
16:42:54 <dalcde> And a free group is a group without restriction?
16:45:30 <athan> So here's a hard question - what's the best way to generate a feasible region for linear programming? I was thinking about generating a convex polytope, then extracting the linear equations from the planes, but I'm not sure if this is correct
16:45:41 <athan> s/correct/the "best"
16:46:15 <nitrix> Hi, does anyone has a library recommendation over :: M.Map a (S.Set b) ?
16:46:28 <nitrix> It feels very dirty to use.
16:47:29 <nitrix> I just want to allow multiple values (the unique isn't even necessary) per key.
16:48:01 <Lokathor> the type signature i want to write is, "multiDecode :: ByteString -> Maybe Text", but the details of "keeps trying them all until one of the various decodings doesn't error" seems perhaps complicated
16:48:05 <hjulle> athan: That seems more like a mathematics question than a haskell question.
16:48:18 <puregreen> nitrix: have you seen the multimap package? (not sure how good it is, tho)
16:48:23 <puregreen> @hackage multimap
16:48:23 <lambdabot> http://hackage.haskell.org/package/multimap
16:48:41 <johnw> when talking to open source people, I should say, "Free as in free object"
16:49:29 <puregreen> Lokathor: there's charsetdetect-ae
16:49:32 <puregreen> @hackage charsetdetect-ae
16:49:32 <lambdabot> http://hackage.haskell.org/package/charsetdetect-ae
16:49:42 <Lokathor> but we've got free as in beer, free as in liberty, and ALSO free as in monadic
16:49:53 <nitrix> puregreen: Gah, it doesn't have `split`. Oh well. I'll just implement my own :) 
16:50:00 <nitrix> puregreen: Thanks still, appreciated :)
16:50:46 <Lokathor> puregreen, oooh, and it's in stackage
16:50:50 <dalcde> Lokathor: to be fair, I haven't seen any monadic free functors
16:50:55 <athan> nitrix: There's multimap!
16:50:58 <Gurkenglas> multiDecode, sounds like you want to use <|>/asum
16:50:59 <dalcde> monadic forgetful functors are a bit more common
16:51:05 <Gurkenglas> *Lokathor
16:51:06 <athan> hjulle: Yeah.... maybe :|
16:51:43 <puregreen> Lokathor: one of these days I should really add a “convert this automatically” function there, but for now... uh, a sec, I had a usage example somewhere
16:51:54 <athan> nitrix: Last I remember there's a few different implementations. I usually just build my own using a newtype over that exact type you suggested
16:51:54 <nitrix> athan: Multimap doesn't seem to have a `split` operation, it's critical for what I'm doing :/
16:52:03 <athan> nitrix: yeah exactly ._.
16:52:14 <Gurkenglas> Why aren't MonadState, Alternative etc. lifted through -> as they are through MonadReader?
16:52:15 <athan> Map does, though, because it's ordered!
16:52:16 <nitrix> athan: Yeah I'll do that.
16:52:37 <athan> Gurkenglas: Probably type inference convolution :\
16:53:00 <nitrix> athan: I'm bulding this monstruosity because the one on hackage is isn't type safe:   data Bimap a b = MkBimap (M.Map a [b]) (M.Map b [a])
16:53:02 <athan> like it would be easy to bork `MonadState s m => Foo -> m a`
16:53:13 <athan> (at least I think it would be)
16:53:36 <athan> nitrix: :O!! Good find!
16:54:07 <Gurkenglas> Can we easily check whether anything would break?
16:54:55 <Lokathor> puregreen, yeah i'm gonna wait on your example because i'm not clear on how i'd use this. I'm not familiar with working with the TextEncoding type
16:54:56 <athan> Gurkenglas: Wait, shit. Is -> an instance of MonadReader? I thought that's what `Reader` was for :s
16:55:04 <puregreen> Lokathor: I think you'll have to use http://hackage.haskell.org/package/text-locale-encoding-0.1.0.2/docs/Data-Text-Encoding-Locale.html
16:55:26 <Gurkenglas> athan, it is :D that's why views can work on MonadReader
16:55:28 <athan> Gurkenglas: Try `MonadState Foo m => Foo -> m a`
16:55:28 <Gurkenglas> :t views
16:55:29 <lambdabot> (MonadReader s m, Profunctor p) => Over' p (Const r) s a -> p a r -> m r
16:55:40 <athan> :O damn...
16:56:21 <athan> that's all I can think of :s
16:56:45 <puregreen> Lokathor: specifically you need decodeLocale' and for NewlineMode you can use universalNewlineMode from GHC.IO.Handle
16:56:53 <Gurkenglas> athan, what would break in there?
16:57:22 <Lokathor> puregreen, well in this case all the bytestrings will be inside of IRC privmsg commands, so there will be no newlines, so i can use noNewlineTranslation i think
16:57:28 <Lokathor> i guess it doesn't matter what mode
16:59:55 <Lokathor> honestly, it seems like it'd be expensive to do that for every privmsg seen though :/
17:01:40 <athan> Gurkenglas: Which monad is the MonadState? :)
17:01:57 <athan> specifically, if you used `get`, most likely the outside one would be chosen
17:02:13 <athan> specifically `Foo ->`, not `m a`
17:02:17 <Gurkenglas> m, of course. (->) doesn't have MonadState. I said (->) is supposed to *lift* MonadState
17:02:35 <athan> unless you used `get` inside a lambda abstraction, which would care for the parameter
17:02:44 <athan> er... wait shit
17:02:49 <athan> yeah I'm misunderstanding
17:03:01 <Lokathor> i will do the lazy thing
17:03:17 <Lokathor> and try utf8, and if that fails then default to latin1, which (as i understand it) cannot possibly fail
17:03:38 <athan> Gurkenglas: You mean that `foo :: MonadState s m => a -> m b; foo = get` should still affect `m` automatically?
17:03:47 <Gurkenglas> yup
17:03:48 <athan> in that `->` is an inherient monad transformer? :S
17:03:53 <athan> shiza
17:03:57 <athan> yeah I don't know about that
17:04:01 <puregreen> Lokathor: Russian users will hate you :)
17:04:13 <Lokathor> do russians not use utf8?
17:04:23 <athan> is `->` a MonadTrans? :S
17:05:15 <puregreen> Lokathor: CP1251 is still used in lots and lots of places and this causes all sorts of problems (???s instead of letters when you try to run old software, etc, etc)
17:05:57 <puregreen> Lokathor: https://github.com/gitterHQ/irc-bridge/issues/27
17:06:16 <puregreen> “in client all bad and it not understand”, y'see
17:06:21 <Lokathor> "but in client all bad and it not understand" <3
17:06:46 <nitrix> athan: I think the kinds do not match.
17:06:57 <nitrix> athan: class MonadTrans (t :: (* -> *) -> * -> *)
17:07:05 <nitrix> athan: (->) :: * -> * -> *
17:08:53 <puregreen> Lokathor: maybe you could go with the lazy thing for now and tomorrow I'll benchmark charsetdetect-ae and ping you
17:08:54 <athan> herp, thanks nitrix 
17:09:44 <athan> maybe... `newtype Foo m a b = a -> m b` :D
17:10:08 <athan> inb4 not syntactically correct :x
17:10:27 <athan> derp, this is a ReaderT ><
17:10:36 <athan> Gurkenglas: You're on your own, sorry :\
17:12:05 <Lokathor> puregreen, okay. I'm not too concerned with supporting languages other than english and esperanto in the first place, both of which can be shoved into ASCII if necessary
17:12:08 <Gurkenglas> Ah, the problem is that we can only give MonadState/Alternative to a whole monad, not the "r -> m _" part. How would you even write the instance? Alternative f => Alternative r -> f? No.
17:12:27 <Lokathor> though esperanto admitedly looks better in unicode
17:13:44 <Gurkenglas> Would work for Monoid though. And is already implemented.
17:15:13 <athan> cyclic adjacency ftw
17:15:29 * athan throws a stick in people's spokes >:D
17:18:01 <meoblast001> has anyone here experienced memory usage of 1GB by GHC when compiling pandoc?
17:18:19 <puregreen> meoblast001: known issue, caused by some particular version of Aeson
17:18:34 <meoblast001> that.... is painful
17:18:42 <meoblast001> i have almost no swap space left on my server
17:18:55 <puregreen> meoblast001: it should be fixed in 1.16.0.1, tho
17:19:07 <puregreen> (released on January 10, 2016)
17:19:25 <meoblast001> i'm installing gitit.. i need to check what version they use
17:19:56 <puregreen> meoblast001: they have a pretty wide range, apparently
17:19:57 <puregreen> >=1.12.4 && <1.18
17:20:40 <meoblast001> i'm going to force install of a higher pandoc
17:21:41 <fr33domlover> meoblast001, or force higher aeson version and see what happens? :P
17:22:12 <fr33domlover> I installed Gitit very recently using `stack`
17:22:18 <fr33domlover> and LTS 5.8, iirc
17:22:22 <fr33domlover> should be fine
17:55:06 <Lokathor> puregreen, http://lpaste.net/156970
17:59:53 <kadoban> Is FlexibleInstances one of the … fairly sane ones, or one of the OMGwhy ones?
18:00:18 <geekosaur> generally sane
18:02:02 <kadoban> Thanks
18:02:07 * hackagebot language-javascript 0.6.0.4 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.4 (ErikDeCastroLopo)
18:06:40 <anastiel> what is error ? *Main> doubleSmallNumber' x = (if x > 100 then x else x*2) + 1 
18:06:41 <anastiel> <interactive>:13:22: parse error on input ‘=’
18:06:41 <anastiel> *Main> 
18:07:07 * hackagebot language-javascript 0.5.14.7 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.7 (ErikDeCastroLopo)
18:07:32 <geekosaur> anastiel, ghci prompt is not like the haskell top level, more like the inside of a do ...
18:07:47 <geekosaur> so you need "let doubleSmallNumber' x ..."
18:07:58 <anastiel> hum not recommend prompt?
18:08:11 <geekosaur> ?
18:08:54 <geekosaur> it's a prompt. you wouldn't like it if it were like a file; you would have to (for example) do all your imports before anything else, instead of being able to import on the fly
18:09:06 <anastiel> huum
18:11:09 <anastiel> I have some good IDE with a similar PyCharm to prompt for python or would have to apply using the atom?
18:13:29 * geekosaur is not quite able to work out what that is asking
18:13:54 <maerwald> +1
18:14:13 <Cale> anastiel: Put definitions into .hs files, and load them with ghci to try out expressions.
18:15:10 <geekosaur> the point here is that a language like python tends to be more lax than one like C or Java or Haskell, where things generally need to be inside functions/methods and there's a distinct function "main" that is the entry point
18:15:30 <anastiel> IDE for haskell?
18:16:04 <geekosaur> there aren't many IDEs as such. generally we use Haskell support in emacs/vim/atom and similar
18:16:05 <Cale> anastiel: There's leksah, but most people just use a text editor and ghci
18:16:14 <geekosaur> there is leksah, I don't know how good it is
18:16:16 <geekosaur> or how useful
18:16:34 <anastiel> hum  nice leksah not running in my archlinux
18:16:39 <geekosaur> anyway ghci should be thought of as mistly doing expressions, while a file contains definitions
18:17:07 * hackagebot atndapi 0.1.0.0 - An interface of ATND API  https://hackage.haskell.org/package/atndapi-0.1.0.0 (ynishi)
18:17:33 <anastiel> thanks geekosaur
18:19:07 <hjulle> Is there a way to save the definitions made in ghci?
18:19:35 <anastiel> SublimeHaskell: hsdev executable couldn't be found!
18:19:36 <anastiel> It's used in most features of SublimeHaskell
18:19:36 <anastiel> Check if it's installed and in PATH
18:19:36 <anastiel> If it's not installed, run 'cabal install hsdev' to install hsdev
18:19:36 <anastiel> You may also want to adjust 'add_to_PATH' setting
18:20:32 <geekosaur> it didn't tell you to install some things?
18:20:36 <geekosaur> cabal install hsdev
18:20:55 <geekosaur> I haven't done much with sublime text but I recall it telling me to install a couple of helpers for best results
18:22:00 <anastiel> oh thanks you have twitter? our sites projets?
18:23:24 <geekosaur> not on twitter, no
18:23:38 <anastiel> github?
18:23:43 * geekosaur is a bit too autistic to handle twitter. (lasted longer than facebook though...)
18:24:29 <anastiel> oh yes not use facebook in atuall days i use boards,reddit,twitter and github
18:27:37 <anastiel> geeksaur you is teacher? doctor?
18:31:50 <geekosaur> (barely here atm sorry)
18:32:18 <t7> geekosaur: twitter is an autists dream, no? 
18:32:47 <geekosaur> have been a lot of things, currently providing top tier support for an enterprise network filesystem
18:33:23 <geekosaur> t7, that can depend on severity and particular quirks...
18:42:11 <anastiel> ooow ;=; informantions masters geeksaur
18:42:26 <Lokathor> t7, as an autistic person, i've never understood the point of twitter. so there's one data point
18:44:23 <Lokathor> Like, it doesn't present information in a useful way, and you can't really talk to anyone that usefully. It's just kinda strictly worse than facebook/reddit/phpbb/google-docs for most stuff
18:46:49 <anastiel> huum o-o nice my life is /github/tracker/docs/aur.arch/
18:47:42 <Lokathor> oh there's another form of communication that's better than twitter: github issues.
18:47:49 <Lokathor> when you're beat out by github issues you're in trouble
18:49:32 <anastiel> how to install Leksah?
18:50:30 <Lokathor> https://github.com/leksah/leksah/wiki/Leksah-0.15.2.0 appears to be the newest releases
18:50:56 <anastiel> └─[$] <> cabal install regex-tdfa-text --ghc-options=-XFlexibleContexts
18:50:57 <anastiel> Resolving dependencies...
18:50:58 <anastiel> All the requested packages are already installed:
18:50:58 <anastiel> regex-tdfa-text-1.0.0.3
18:50:58 <anastiel> Use --reinstall if you want to reinstall anyway.
18:51:13 <anastiel> reinstall cabal? and tools?
18:51:26 <Lokathor> no it means if you want to reinstall that package
18:51:56 <Lokathor> in my experience, usually you don't want to, you just want to remake the whole sandbox
18:52:01 <Lokathor> or use stack instead
18:52:18 <anastiel> cabal: The following packages are likely to be broken by the reinstalls:
18:52:19 <anastiel> leksah-0.15.2.0
18:52:20 <anastiel> Use --force-reinstalls if you want to install anyway.
18:52:27 <anastiel> burn
18:52:45 <Lokathor> yeah, stack helps manage this sort of trouble
18:58:33 <anastiel> how to install all packages Hackage using cabal?
19:00:57 <maerwald> anastiel: cabal has a manpage
19:01:16 <anastiel> o-o oh sorry i am newbie in haskell
19:01:43 <maerwald> leksah has a README: https://github.com/leksah/leksah#building-on-linux
19:02:07 <anastiel> thanks i readme
19:02:35 <Job316> Is there a way to get a 1:1 mapping, such that Map can be reversed?
19:02:48 <Job316> there's gotta be a thing that does this
19:03:00 <maerwald> anastiel: cabal hase a user guide https://www.haskell.org/cabal/users-guide/
19:03:28 <anastiel> thanks maerwald
19:04:38 <anastiel> i am use is tutorial http://haskell.tailorfontela.com.br/starting-out
19:05:59 <maerwald> anastiel: https://github.com/bitemyapp/learnhaskell#how-to-learn-haskell
19:06:53 <anastiel> thanks maerwald
19:09:07 <lpaste> Forgetaboutit pasted “How do I escape `forever'?” at http://lpaste.net/156972
19:09:33 <geekosaur> throw an exception. better, use something that allows you to escape
19:09:48 <Forgetaboutit> hi #haskell, as shown in the lpaste just now, I'm wondering how to escape the `forever` loop
19:11:23 <Forgetaboutit> geekosaur: I'm wondering how precisely I'd escape the loop.  I saw some examples using runMaybeT and mzero.  But I honestly couldn't wrap my head around it.  Especially using runMaybeT in combination with evalStateT confuses me a lot.
19:12:25 <shachaf> The best answer is probably not to use forever if you don't want to do something forever.
19:12:43 <maerwald> :D
19:14:54 <Forgetaboutit> shachaf: I'd love to use something different :D
19:15:14 <Forgetaboutit> shachaf: What would you recommend?
19:15:37 <shachaf> Maybe recursion?
19:16:41 <Forgetaboutit> hm, but wouldn't that make using StateT more difficult?
19:16:57 <shachaf> I don't think it'd be more difficult than forever.
19:17:19 <shachaf> You can also make your own variant of forever that lets you break, if you want.
19:20:40 <MarcelineVQ> is exitWith ExitSuccess or exitSuccess frowned upon for some reason? http://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:exitWith
19:22:16 <geekosaur> pedanticism, likely, since it isn't exiting "properly" (by returning from main)
19:28:55 <Job316> I'm looking for a thing where given a set of (a,b) where a,b are unique yields ((a->b),(b->a))
19:29:00 <Job316> basically a reversable map
19:29:07 <Forgetab`> shachaf: Ok, so rewriting it using recursion worked, even much easier than I imagined it to be
19:29:08 <Job316> is there a thing that does this?
19:29:19 <Job316> you could build one with two maps
19:30:01 <Forgetab`> shachaf: So thanks for the pointer =)
19:30:20 <mathu> i'm looking at how to rewrite foldl as a foldr. it works with   myFoldl f base = foldr (flip f) base   but https://wiki.haskell.org/Foldl_as_foldr lists quite a different definition that i can't parse. the lambda now takes id as its first argument, and the foldl's function f now takes id as its second? what?
19:34:47 <HoloIRCUser5> I'm writing a do-block inside the IO Monad. Inside it I need to call funcA:: Maybe a, if it returns Just a, then I need to call funcB::IO(Maybe b), if it returns Just b, then I need to call a bunch of functions which need 'b'. What's the best way to compose this?
19:35:13 <mtncoder> what's the ampersand in the first code sample here? https://nikita-volkov.github.io/refined/
19:36:01 <Forgetab`> mtncoder: I assume it's from Lens
19:36:17 <Forgetab`> https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Lens.html#v:-38-
19:36:24 <Forgetab`> It's the reverse of ($)
19:36:55 <mtncoder> thanks
19:38:29 <MarcelineVQ> lens re-exports that but it's from Data.Function in case you just want &
19:39:32 <Forgetab`> MarcelineVQ: Wow, it's in base even!  I didn't know that
19:42:35 <Lokathor> Job316, https://hackage.haskell.org/package/bimap-0.3.2/docs/Data-Bimap.html ?
19:43:01 <Job316> aha! there it is
19:43:36 <Job316> thanks
19:45:11 <Lokathor> MarcelineVQ, i'm not sure, but exitWith maybe terminates the program without unraveling the IO stack properly.. which for things like file handles is fine (the OS closes them anyway) but for other "finally" effects might be v bad
19:45:49 <Lokathor> for example, an action that writes a footer to a file at the end of a "bracket" block might die before it can write the footer to the file proerply
19:47:20 <Lokathor> in the case of a websocket, it's a violation of the protocol to just cut the connection suddenly. pending writes to the DB might not get committed, etc
19:47:21 <MarcelineVQ> bracket (and probably by extension finally) still run if you use exitWith
19:47:56 <Lokathor> oh wow i'm dumb
19:48:01 <Lokathor> i read two lines but not the third
19:49:13 <Lokathor> still, i can save my whole explanation by saying "also they might not have used bracket" :P
19:49:14 <MarcelineVQ> I agree that using exitWith without bracket or finally isn't a great idea if you're using resources though
19:49:41 <Lokathor> -- TODO: this is an ugly hack, we should shut down properly in the future.
19:49:47 <Lokathor> just put helpful comments like that in the source
19:50:39 <MarcelineVQ> alternatively, -- FIXME: I'm broken but someone put me in anyway and I'm not sure why I exist, I didn't choose to be born into this madhouse.
19:51:24 <Lokathor> i stick to just TODO
19:53:37 <Lokathor> -- ... So all our data types have to hold ByteString values and you just have to kinda pray a lot. Bonsancon.
19:53:46 <Lokathor> Bonŝancon*
19:56:29 <Lokathor> not sure anything will ever beat "no statistical foundation for this!" though
20:37:12 <nymacro> Hi ladies and gentelmen. I'm at whits end at trying to figure out why my code generates a ECDH shared secret slightly differently to the values provided in the HTTP Encrypted Content-Encoding draft (http://httpwg.org/http-extensions/draft-ietf-httpbis-encryption-encoding.html)
20:37:40 <nymacro> https://github.com/nymacro/http-ece/blob/master/src/Network/HTTP/ECE/DH.hs#L36
20:38:11 <nymacro> is my code.. I am generating a shared secret like: 44d8c2f8d556e011896f158f5bb1b69a8c2c2de0dae772d82989b8f8d390e9
20:38:25 <nymacro> compared to expected: 44d8c2f8d556e011896f158f5bb1b69a8c2c2de0dae772d82989b8fbe34e43a6
20:38:38 <nymacro> (actually, i got it around the wrong way. First is expected, second is what is generated)
20:39:15 <nymacro> the last 4/5 bytes are different
20:41:44 <nymacro> any crypto experts? :)
20:53:06 <o`connor> what is (->)? I always see it in tutorials but :t (->) doesn't work
20:53:27 <shachaf> A type.
20:53:50 <o`connor> shachaf: what sort of type? I can't look at it or do anything with it?
20:54:02 <lambda-11235> :info (->)
20:54:15 <shachaf> :t (->) doesn't work for the same reason :t Int doesn't work.
20:54:32 <shachaf> It's the type constructor for functions, as in Int -> Int.
20:54:43 <shachaf> "Int -> Int" is the same as "(->) Int Int"
20:55:07 <o`connor> oh
20:56:27 <adelbertc> has anyone used http://hackage.haskell.org/package/regexpr-symbolic and/or know of a lib/resources that makes checking a single string against multiple regex's efficient
20:58:13 <Lokathor> o`connor, you can use :k with (->) to get a little information, as well as :info
20:59:46 <Lokathor> but yeah, :t gives the type of a value expressions, it can't give you the type of a type. Kinds (with :k) are sorta like a type of types in some sense though
21:00:49 <o`connor> so when "lens over tea" asks: "here's a question for you: is (->) a bifunctor?" -- the answer is: no, they have a different kind?
21:02:03 <o`connor> Bifunctor :: (* -> * -> *) -> ghc-prim-0.4.0.0:GHC.Prim.Constraint vs. (->) :: * -> * -> *
21:02:54 <adelbertc> (->) has the right kind for Bifunctor
21:02:55 <Cale> o`connor: It has the correct kind
21:02:58 <adelbertc> :k (->)
21:02:59 <lambdabot> * -> * -> *
21:03:06 <Cale> :k Bifunctor
21:03:07 <lambdabot> (* -> * -> *) -> Constraint
21:03:09 <Cale> :k Bifunctor (->)
21:03:10 <lambdabot> Constraint
21:03:17 <o`connor> Cale: but what about the Constraint bit?
21:03:48 <adelbertc> because it's a type class it's treated differently (by default) as plain 'types'
21:03:58 <adelbertc> thats what the Constraint bit is saying
21:04:40 <o`connor> adelbertc: ok, that makes sense
21:04:54 <adelbertc> e.g. you see Bifunctor f => (a -> c) -> (b -> d) -> f a b -> f c d - Bifunctor never appears on the right side of the => with all the other types
21:04:54 <nek0> Hi folks, sorry to barge in, but I have a problem I need help with. I am trying to write Haskell bindings to a C library using hsc2hs, but when compiling I always get the error "invalid use of incomplete typedef".
21:05:09 <adelbertc> there is a GHC extension called ConstraintKinds that let you mess with Constraints as you might expect with types
21:05:15 <o`connor> adelbertc: so then (->) could be an instance of bifunctor?
21:05:27 <Cale> o`connor: It could, if you can implement the methods...
21:05:38 <Cale> o`connor: However, there is an obstruction to doing so ;)
21:05:43 <adelbertc> it has the right kind
21:05:47 <adelbertc> but youll have trouble implementing hte methods
21:05:50 <adelbertc> what Cale said
21:06:14 <Lokathor> nek0, have you tried just using the inline-c package instead?
21:06:20 <o`connor> Cale: other than "that sounds hard", what is the obstruction? 
21:06:41 <adelbertc> fundamentally it is the "variance" of (->)
21:07:16 <adelbertc> the left hand side of (->) is contravariant, the right hand side is covariant
21:07:21 <nek0> Lokathor, no, not yet. I am new to writing bindings, so i don't know what's out there.
21:07:27 <adelbertc> whereas both type params of `f` for Bifunctor f are expected to be covariant
21:07:43 <adelbertc> you'll hit this issue when trying to implement bimap
21:08:07 <Lokathor> nek0, well i tried to use hsc2c and all that a while back, and it was pretty tough. more recently i've gotten a good deal of progresss with inline-c, which does most of the magic for you
21:08:08 <adelbertc> bimap fixed to (->) would have type: (a -> b) -> (c -> d) -> (a -> c) -> (b -> d)
21:08:44 <Lokathor> marshalling complex types across the FFI barrier is still tricky of course, but it can do the basics automatically via template haskell
21:09:09 <Lokathor> your code ends up pretty easy to follow, https://github.com/Lokathor/hexes/blob/master/src/UI/Hexes/Raw.hs
21:09:41 <Cale> o`connor: right, so following up adelbertc's type there, let's imagine writing this:
21:09:51 <Cale> bimap f g h x = ...
21:09:57 <Cale> So we have
21:10:01 <Cale> f :: a -> b
21:10:03 <Cale> g :: c -> d
21:10:09 <Cale> h :: a -> c
21:10:13 <Cale> x :: b
21:10:18 <Cale> and we want to get something of type d
21:10:40 <nek0> Lokathor: Thanks for the hint. I will try this.
21:10:47 <Cale> The only way we can get something of type d from the things we have is by applying g, so, let's do that:
21:10:54 <Cale> bimap f g h x = g (...)
21:11:01 <Cale> now we need something of type c
21:11:13 <Cale> and the only way to get something of type c is by applying h
21:11:19 <Cale> bimap f g h x = g (h (...))
21:11:26 <Cale> and now we need something of type a
21:11:35 <Cale> but there's no way to get something of type a with the things we have
21:11:51 <Cale> So we're done, this function is impossible to write.
21:12:35 <o`connor> Cale: got it. I think I need to read more about covariant and contravariant to understand how we got here, but it's clear that (a -> b) -> (c -> d) -> (a -> c) -> (b -> d) is impossible
21:12:35 <Cale> (without doing something recursive which would basically result in an infinite loop, that is...)
21:13:08 <Lokathor> the dictionary said that covariant kinda just means "normally properly composable"
21:13:23 <Lokathor> but it was sorta vague about it
21:13:38 <Cale> A covariant functor is just the usual sort of functor: it preserves the direction of arrows
21:13:52 <Cale> :t fmap
21:13:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:14:05 <Cale> This is taking an arrow (a -> b) and giving you an arrow (f a -> f b)
21:14:20 <Cale> A contravariant functor by contrast flips the direction
21:14:25 <Cale> :t cofmap
21:14:26 <lambdabot>     Not in scope: ‘cofmap’
21:14:27 <lambdabot>     Perhaps you meant one of these:
21:14:27 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
21:14:31 <o`connor> ok
21:14:40 <Cale> I guess we don't have enough category-extras in scope :)
21:14:51 <Cale> anyway, it would have type  (a -> b) -> (f b -> f a)
21:15:21 <o`connor> Cale: but my intuition would be then that contravariant is impossible
21:15:29 <o`connor> Cale: so why talk about it?
21:15:38 <Cale> Consider for example, f t = t -> Bool
21:15:59 <Cale> (a -> b) -> ((b -> Bool) -> (a -> Bool))
21:16:03 <Cale> is that possible?
21:16:34 <o`connor> Cale: yeah, I think so
21:16:37 <Cale> yeah
21:16:55 <Cale> So, if we were to define  newtype Pred t = P (t -> Bool)
21:17:24 <Cale> Then we could have an instance of Contravariant (a type class for contravariant functors on Hask) for Pred
21:17:41 <Cale> class Contravariant f where cofmap :: (a -> b) -> (f b -> f a)
21:18:16 <Cale> instance Contravariant Pred where cofmap f (Pred p) = Pred (p . f)
21:18:26 <o`connor> yeah
21:18:31 <adelbertc> on a related note, how does Haskell define Contravariant for (->) ? iirc you can't say Contarvariant (-> a)
21:18:43 <Cale> adelbertc: You need a newtype like I'm suggesting
21:18:49 <adelbertc> ah right yes
21:18:53 <Cale> adelbertc: You could generalise it over the Bool there :)
21:18:59 <Cale> But put that argument *first* :)
21:19:05 <adelbertc> gotcha
21:19:59 <Cale> o`connor: The fact that we can do this is what we mean by "(->) is contravariant in its first argument"
21:20:24 <Cale> o`connor: i.e. if you fix some type to go in the second argument, what you end up with is a contravariant functor
21:20:49 <Cale> Bifunctor is a class for things which are covariant (ordinary) functors in *both* arguments
21:21:27 <o`connor> Cale: thanks, I understand now
21:21:46 <Cale> There's a class Profunctor for things similar to (->) which are contravariant in the first argument and covariant in the second
21:22:53 <adelbertc> Either and (,) are the usual Bifunctor examples i see
21:22:55 <Cale> (which come up reasonably often, given that we're in the business of computing stuff, and so a lot of our abstractions end up looking a bit like functions somehow)
21:23:30 <Cale> Yeah, Either and (,) are the two most important Bifunctors
21:23:31 <adelbertc> <insert comment about lens here>
21:24:30 <Cale> They're far from arbitrary, they're the coproduct and product (...modulo some technicalities regarding partially-defined values...)
21:43:41 <nek0> Lokathor: I have a question about inline-c: Can I translate C structs into Haskell with this library and make them Storable without the old hsc2hs way?
21:44:15 <Lokathor> I think that's what the Context stuff is all about, but I haven't really done any of that myself
21:44:40 <Lokathor> when I needed to save a WINDOW* at the haskell level, I just fudged it and called it an int* and then newtyped it
21:45:19 <sgronblo> Does anyone know of any easy to understand articles about how the haskell runtime executes an IO value?
21:48:46 <nek0> Lokathor: I don't think, that this approach is applicable in my case...
21:49:26 <Lokathor> maybe not :(  with curses the user can't ever modify what the WINDOW* points to, they only just pass it around like an ID value
21:49:50 <Lokathor> if you want to be able to use the struct any other way at the Haskell level you'll probably need to make a storable instance i guess
21:52:19 <nek0> Lokathor: That's exactly the point I'm failing at right now. I suspect it's not even my fault. The struct is a bit obscure and only partially exposed from the Library.
21:52:41 <Lokathor> if it's only partly exposed... D:
21:56:21 <nek0> Lokathor: "typedef struct _GeglNode  GeglNode;" This is the line defining the struct. _GeglNode is defined in another header, which is only present in the source files of the library.
21:57:54 <Lokathor> if you can't see all the data in the struct, i'm not sure how you'd read it all to marshal it out of C
21:57:58 <Lokathor> but, i'm no expert
22:00:05 <nek0> Lokathor: Me neither. looks like I need to include the source files of the library to make this work. In any way, thanks for your time. 
22:04:11 <ontop> Someone play haskell golf with me. Initialize a (Data.Map.Map String Int) with a list of keys [String] with a single value (0 in this case).
22:04:23 <ontop> I think I did it a not terrible way but I don't know :(
22:06:55 <Lokathor> ontop, 
22:06:55 <Lokathor> :t foldr (\k m -> M.insert k 0 m) M.empty ["a","b"]
22:06:56 <lambdabot> Num a => M.Map [Char] a
22:07:04 <undoall_> If I understand you correctly, I'd probably do that with: Data.Map.fromList (zip keys (repeat 0))
22:07:05 <ontop> That's what I did :D
22:07:14 <ontop> Oh shit. undoall_ wins I think.
22:07:28 <ontop> I also had this one, but it's basically reduced to zip
22:07:53 <ontop> > M.fromList $ map (flip (,) $ 0) ["rofl", "there"]
22:07:55 <lambdabot>  fromList [("rofl",0),("there",0)]
22:11:27 <undoall_> Ooooh, that's cool
22:11:33 <undoall_> I'm new here, I didn't realize lambdabot was a thing
22:11:46 <ontop> Why are you new here, but Haskell golf better than me?!
22:11:49 <ontop> We'll have to duel to the death.
22:11:51 <undoall_> > M.fromList (zip ["this", "that"] (repeat 0))
22:11:52 <lambdabot>  fromList [("that",0),("this",0)]
22:11:55 <undoall_> Yay!
22:12:07 <ontop> I tried compiling Lambdabot myself the other day.
22:12:09 <ontop> Cabal install barfed.
22:12:14 <ontop> Guess this is the only lambdabot I can ever use.
22:12:17 <undoall_> ontop: Because despite programming in Haskell for quite some time, I've only recently started visiting the IRC channel
22:12:25 <ontop> Oh, well welcome.
22:12:30 <Lokathor> lambdabot is very finnicky to run yourself
22:12:32 <undoall_> Thanks :)
22:12:48 <ontop> Lokathor: Seems super undocumented and hard to figure out even if I were to compile it.
22:12:58 <Lokathor> so the question becomes, which form is faster? Hmm
22:13:01 <ontop> Like how the heck do you even configure it? There's like 3 README's, all equally worthless. lol.
22:13:14 <ontop> Lokathor: How do we benchmark?
22:13:36 <Lokathor> Criterion
22:13:47 <undoall_> To criterion!
22:14:05 <ontop> I don't know how to do that :D
22:14:19 <ontop> Holy crap
22:14:20 <ontop> OMG
22:14:22 <ontop> HOLY SHIT
22:14:22 <ontop> Guys.
22:14:24 <undoall_> ?
22:14:25 <Lokathor> here's a sample file, https://github.com/Lokathor/ludolib/blob/master/test/LudoBench.hs
22:14:32 <Lokathor> you don't have to make your own NFData instances though
22:14:34 <ontop> A haskell package with a tutorial: http://www.serpentine.com/criterion/tutorial.html
22:14:40 <ontop> That's UNBELIEVABLE
22:14:53 <ontop> Who is this author? I'm going to send him $5,000
22:14:54 <Lokathor> incidentally, inline-c has a mini tutorial
22:15:21 <Lokathor> and i have a sample program with hexes
22:16:39 <ontop> Ok. Time to go back to trying to code Djikstra's
22:18:45 <undoall_> Oh no, I don't have criterion installed already
22:18:53 <undoall_> This performance test has just been delayed by 4000 years
22:19:10 <ontop> undoall_: Is it a slow one to compile?
22:19:15 <undoall_> Yep
22:19:23 <undoall_> It's ~big~ and ~complicated~
22:19:24 <ontop> I've been poisoned by all the GHC hate on reddit.
22:19:30 <ontop> I also now hate GHC's compile times
22:19:33 * ontop gets his pitchfork out
22:19:39 <undoall_> GHC's performance... definitely could be better
22:19:44 <luigy> ontop ghcid is your friend
22:19:50 <ontop> ghcid?
22:19:54 <ontop> ghci daemon?
22:19:58 <luigy> pretty much
22:20:02 <ontop> Interesting...
22:20:29 <Lokathor> use stack
22:20:37 <ontop> I do use Stack :D
22:20:42 <ontop> It broke Atom there for a while.
22:20:43 <Lokathor> then you're mostly set already
22:20:45 <ontop> But now it's all fixed.
22:20:59 <undoall_> Starting to use stack is one of those things I've been putting off forever
22:21:12 <ontop> I've read "what's the difference" posts like 8 times.
22:21:35 <ontop> Still don't understand what Stack does that much differently other than make a "sandbox" by default and have less ugly command line commands.
22:25:48 <MichaelBurge> ontop: I'm not sure either, but I recently came back to Haskell and found it was much more convenient than using cabal.
22:25:58 <ontop> lol.
22:25:59 <ontop> Neat.
22:26:01 <MichaelBurge> I remember cabal sandboxes would take forever to recompile everything
22:26:09 <ontop> Well
22:26:17 <luigy> reddit/hacker news/news thingie connoisseurs... I don't think I've ever seen a link to a GH comment, but I kind of want to do that... what is the norm here? should I be turning my long comment into a post?
22:26:21 <MichaelBurge> I haven't needed to profile anything with stack yet, but I'm hoping it conveniently does that
22:26:25 <ontop> I guess the idea is also that Stack will see if it can "borrow" compiled things from other sandboxes.
22:27:20 <MichaelBurge> ontop: I think you're right - it starts a new project much faster than if you use a cabal sandbox, so it's probably caching them somewhere.
22:27:41 <ontop> That sneaky coyote
22:28:06 <MichaelBurge> ontop: The other thing it does is that Snoyman's company keeps a collection of package versions known to work with each other.
22:28:20 <Lokathor> ontop, stack isn't different from cabal sandboxes
22:28:22 <ontop> Snoyman's company?
22:28:24 <MichaelBurge> It used to be that things could easily break if you weren't on-top of your versions
22:28:36 <Lokathor> but stack is like 100x smarter at tracking and mixing all the sandboxes that it has going on
22:28:46 <ontop> The enterprisefunctorpeople or whoever they are?
22:28:50 <ontop> industrial haskell?
22:28:50 <Lokathor> compared to trying to wrangle each sandbox yourself
22:28:57 <ontop> Lokathor: Hm. That sounds nice.
22:29:16 <Lokathor> stack also uses stackage rather than hackage by default
22:29:31 <Lokathor> so you get better results when you have to add new packages into a project partway though
22:30:14 <ontop> Why so? What's better about stackage?
22:30:22 <MichaelBurge> Yeah, I remember that too. It used to be that cabal would use the system-installed package by default, and if it happened to be an old version of transformers that Ubuntu came with
22:30:32 <MichaelBurge> then you'd have to rebuild *everything* when you update the version
22:30:40 <MichaelBurge> and it wouldn't even do a good job at determining what to rebuild
22:30:53 <MichaelBurge> and sometimes it'd get stuck and you'd have to manually sort out the dependencies
22:30:57 <MichaelBurge> I haven't had that happen with stack yet
22:31:02 <ontop> Gross.
22:31:06 <ontop> Sounds like old versions of apt.
22:31:09 <undoall_> Hi guys I finally did the performance test, even though it's no longer relevant to the current conversation
22:31:18 <ontop> undoall_: It's still totally relevant.
22:31:20 <ontop> I'm itching to know!
22:31:35 <undoall_> The M.fromList (zip keys (repeat 0)) is almost twice as fast as the foldr one
22:31:42 <ontop> Wow. Weird.
22:31:49 <undoall_> Yeah, I don't really get it either
22:31:53 <ontop> undoall_: I think we have to write a foldl
22:31:55 <ontop> To see what happens :D
22:31:57 <undoall_> And then if you use foldl instead, it's 4 TIMES AS SLOW!
22:32:01 <ontop> WHAT?
22:32:03 <MichaelBurge> ontop: If you want to suffer a bit so you know what benefits you're getting, just write any kind of real package and switch on profiling once you're nearly done
22:32:18 <undoall_> Maybe it'll be faster if we use foldl'
22:32:30 <ontop> :t foldl'
22:32:32 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
22:32:37 * ontop shrugs.
22:32:54 <undoall_> It's strict in the accumulator, so it prevents lots of thunks from building up and slowing stuff down
22:33:05 <ontop> Ah yeah.
22:33:12 <undoall_> And the moment of truth
22:33:34 <ontop> What about my map with the flip!
22:33:43 <undoall_> Ohhh, can you send that one?
22:33:52 <ontop> M.fromList $ map (flip (,) $ 0) ["rofl", "there"]
22:33:59 <undoall_> Also, foldl' performs slightly better than foldr, but still worse than the zip solution
22:34:05 <ontop> Interesting.
22:34:09 <ontop> What makes zip so amazing!?
22:34:17 <undoall_> Who knows?!
22:34:21 <ontop> Hm
22:35:08 <undoall_> Alright, benchmarking...
22:35:39 <Lokathor> I hope you're building that with -O2 as well
22:35:44 <undoall_> Lokathor: Of course
22:35:47 <MichaelBurge> undoall_: Alot of those functions have rewrite rules to collapse them into simpler expressions. I think there's a way to make GHC print those out
22:35:51 <undoall_> ontop: Congrats! Your implementation is the FASTEST ONE!
22:36:07 <ontop> LOL
22:36:07 <undoall_> ...by 1.24 ms
22:36:15 <ontop> flip and map bitches!
22:36:16 <ontop> Yea!
22:36:18 <Lokathor> > (,0) 3
22:36:19 <lambdabot>  (3,0)
22:36:37 <Lokathor> > M.fromList $ map (,0) ["rofl", "there"]
22:36:39 <lambdabot>  fromList [("rofl",0),("there",0)]
22:36:39 <ontop> undoall_: I still used yours because good god is that flip ugly lol.
22:36:48 <Lokathor> ontop, ^
22:36:50 <ontop> Omg.
22:36:55 <ontop> I didn't even think to..
22:37:00 <ontop> undoall_: Bench that one!
22:37:13 <Lokathor> i expect it's the same
22:37:18 <undoall_> ontop: That one should have the exact same performance as yours.
22:37:24 <undoall_> ...like, literally the exact same
22:37:39 <ontop> Neat.
22:37:44 <ontop> Compiler probably compiles away flips
22:37:44 <ontop> lol.
22:38:24 <undoall_> ...weird
22:38:40 <undoall_> There's a lot of weird variance
22:38:52 <undoall_> I ran the benchmark again, and this time the zip solution was faster by 5 ms
22:38:59 <undoall_> ~~~I guess we'll never know~~~
22:39:25 <Lokathor> when that happens, i just increase the problem size until the small noise becomes less important
22:39:42 <ontop> ^
22:39:55 <undoall_> I guess I'll just use /usr/share/dict/words repeated 10 times
22:40:02 <Lokathor> you got it
22:40:08 <ontop> Now you're thinking with fire!
22:40:09 <Lokathor> wait
22:40:17 <Lokathor> no that won't work
22:40:24 <undoall_> ?
22:40:35 <Lokathor> you can't insert a word more than once
22:40:40 <Lokathor> well, i mean not usefullt
22:40:43 <Lokathor> useflly*
22:40:50 <Lokathor> imagine i spelled that right
22:41:08 <undoall_> Hmm... I guess I could generate a really long list of random strings
22:41:17 <Lokathor> oh, well
22:41:19 <ontop> You can insert a word more than once
22:41:20 <ontop> No?
22:41:21 <ontop> I mean
22:41:24 <undoall_> You can
22:41:25 <ontop> It'll just be replaced
22:41:27 <Lokathor> for the 2nd pass, just use each word concatinated with itself
22:41:35 <ontop> Also a good idea.
22:41:44 <undoall_> ...complicates things
22:42:24 <Lokathor> with FOV i just added a 0 to the maximum radius and that was all the extra stress i needed
22:42:32 <Lokathor> yay quadratic space operations
22:43:09 <johnw> take two copies of /usr/share/dict/words,  randomly reorder each, zip the two into pairs, and repeat that 10 times
22:43:25 <undoall_> ...I think I'll just randomly generate some strings of length 10
22:43:33 <johnw> what is this for?
22:43:55 <undoall_> Performance testing on a few different ways to generate a map where all values are 0
22:44:00 <johnw> ah, ok
22:44:39 <ontop> Rofl
22:44:58 <Lokathor> after a while the memory taken can outweigh the cpu taken
22:45:05 <ontop> undoall_: When you describe it seems so pointless. But it's indeed great fun, right? Science and all.
22:45:18 <undoall_> The greatest fun
22:48:18 <ontop> Djikstra's an asshole.
22:48:21 * ontop throws his program on the ground
22:50:07 <Lokathor> computePath :: (Ord a) => MoveCostInfo a -> a -> a -> Maybe (Path a); computePath = undefined
22:50:11 <Lokathor> a perfectly good program
22:51:37 <undoall_> Okay, I did a test on 500,000 random strings of length 10
22:51:41 <undoall_> zip seems to be faster
22:51:53 <Lokathor> hmm
22:52:02 <undoall_> By ~0.2 seconds
22:52:47 <undoall_> Just to be thorough, I'll do 1,000,000 random strings of length 25
22:53:02 <ontop> Zip wins :D
22:53:15 <undoall_> Bigger numbers = more accurate!
22:53:18 <Lokathor> M.fromList (zip keys (repeat 0)) =VS= M.fromList $ map (,0) keys =VS= foldr (\k m -> M.insert k 0 m) M.empty keys
22:53:24 <Lokathor> ~title match of the century~
22:54:01 <ontop> lol.
22:54:07 <undoall_> foldr is definitely slower than the other two, so in this ~~ULTIMATE BENCHMARK~~, I'm only comparing the first two
22:54:15 <johnw> I say 1,000,000,000 of strings of length 255
22:54:29 <undoall_> johnw: I have no supercomputer
22:54:33 <Lokathor> i bet fromList does some sort of magic internally
22:54:38 <johnw> someone, get this man a supercomputer
22:56:43 <undoall_> zip solution took 10.27 seconds, awaiting map solution...
22:59:05 <undoall_> The results are in!
22:59:21 <undoall_> In an amazing comeback victory, the map solution clocked in at a mere 9.408 seconds!
22:59:30 <ontop> OOH YAHH
22:59:39 <Lokathor> hmm
22:59:52 <Lokathor> i'd run it a second and third time
22:59:55 <Lokathor> just to make sure :3
23:00:00 <undoall_> Oh come on that took foreeever
23:00:40 <Lokathor> it was like, a few minutes
23:00:41 <undoall_> Let's just conclude that the speed difference is small enough that it doesn't really matter in practice and you should probably just go with what you find the most aesthetically pleasing
23:00:43 <Lokathor> you don't even have to watch the screen the whoel time
23:00:50 <Lokathor> start it and go get some chips
23:00:55 <undoall_> lol
23:03:10 <undoall_> https://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Map.Base.html#fromList Here's the magic that fromList uses
23:03:47 <undoall_> It's... pretty magical
23:08:43 <undoall_> Upon repeated testing, the map solution remains slightly faster, by 0.3 seconds
23:08:47 <undoall_> ...good enough for me!
23:11:08 <MichaelBurge> When's GHC 8 coming out?
23:14:40 <Cale> MichaelBurge: https://ghc.haskell.org/trac/ghc/report/1 -- hopefully when the red stuff there is gone?
23:16:02 <undoall_> "'Strict' extension is incompatible with 'deriving' mechanism"
23:16:17 <undoall_> An almost hilariously extension-breaking bug right there
23:42:16 <amovah> Hi, I have problem with running haskell on my terminal
23:42:55 <amovah> I've installed from this page https://ghcformacosx.github.io/
23:49:08 <YellowOnion> Anyone using stack & llvm on windows?
23:51:02 <YellowOnion> I couldn't get my app to compile properly with plain ghc llvm, (probably wrong version of llvm)
