00:02:51 <Joe> hello
00:05:16 <oherrala> hi
00:06:39 * hackagebot repa-linear-algebra 0.3.0.1 - HMatrix operations for Repa.  https://hackage.haskell.org/package/repa-linear-algebra-0.3.0.1 (mjmrotek)
00:07:39 * hackagebot GPipe-GLFW 1.2.2 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.2.2 (plredmond)
00:07:39 * hackagebot repa-linear-algebra 0.3.0.1 - HMatrix operations for Repa.  https://hackage.haskell.org/package/repa-linear-algebra-0.3.0.1 (mjmrotek)
00:08:12 <Niamkik_> Hi everyone
00:08:45 <Niamkik_> I have a question about haskell... Do you have a feature/module like proplist in erlang (simple list + tuple)?
00:10:06 <kadoban> :t lookup
00:10:07 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
00:10:10 <cocreature> Niamkik_: I don‚Äôt know erlang but you can just use [(Key,Value)], e.g. [(1,"hello"),(2,"world")]. but a Map might be more appropriate
00:10:12 <kadoban> Niamkik_: Like that?
00:10:26 <Niamkik_> yep
00:10:32 <Niamkik_> :)
00:10:47 <Niamkik_> but erlang has a lot of nice function to get one element of proplist
00:10:58 <Niamkik_> http://erlang.org/doc/man/proplists.html
00:11:14 <hiptobecubic> lookup?
00:11:33 <hiptobecubic> > lookup 2 [(1, "hello"), (2, "world")]
00:11:35 <lambdabot>  Just "world"
00:11:37 <kadoban> Niamkik_: You'd just use filters for most of those really
00:11:51 <kadoban> filters and foldrs and whatever
00:12:00 <Niamkik_> ok!
00:12:22 <Niamkik_> really cool! thanks for these answers :D
00:12:23 <kadoban> Though for anything serious you'd probably use a Data.Map or whatever instead like cocreature mentioned.
00:12:49 <cocreature> at least as long as the order of the list doesn‚Äôt matter
00:13:03 <kadoban> Hmm, right.
00:25:19 <fr33domlover> I want to generate a list by starting with an empty list and appending. Method 1: Use a Haskell list, prepend instead of appending, and finally reverse the list. Method 2: Use a DList. Is method 2 better than 1 in any way?
00:26:56 <Walther> fr33domlover: Data.Sequence is almost like a list but has O(1) append to either end
00:27:03 <Walther> based on finger trees
00:28:14 <fr33domlover> Walther, I'm aware but it's just a temporary value I generate, then fold over it to generate some HTML and done with it
00:29:04 <shanemikel> Or use a so-called difference list
00:29:17 <Walther> Ok, then I don't know if dlist or list is any better, sorry
00:30:24 <parsecChar_> besides the file system, what's the simplest kv store for haskell ?
00:30:44 <fr33domlover> parsecChar_, persistent or just in-memory?
00:30:58 <parsecChar_> persistent -- I am trying to write a simple wiki with snap
00:31:01 <liste> parsecChar_: concurrent or single-use?
00:31:08 <liste> single-user*
00:31:21 <parsecChar_> there's only one haskell program which will be writing to the kv store
00:31:22 <liste> parsecChar_: Data.Map with acid-state
00:31:39 <liste> if it's a web app, it'll need concurrency
00:31:57 <parsecChar_> yeah, but there's not multiple apps hitting the db
00:32:10 <parsecChar_> so even though there's multipe users, ther'es "only one user writing to the db"
00:32:16 <fr33domlover> parsecChar_, each request is handled in its own thread most likely
00:32:24 <fr33domlover> so that's concurrecy there
00:32:34 <parsecChar_> hmm
00:32:48 <liste> acid-state does concurrency extremely well
00:32:51 <fr33domlover> you can also use one of the Redis packages
00:32:56 <parsecChar_> its fine, even if there is concurrency, I can serialize it all in haskell land
00:33:00 <fr33domlover> but that requires Redis :P
00:33:07 <liste> @hackage acid-state
00:33:07 <lambdabot> http://hackage.haskell.org/package/acid-state
00:33:26 <liste> it's persistent, but requires the dataset to fit in memory
00:34:11 <parsecChar_> hmm, I was previously considering leveldb / sqlite3
00:34:17 <parsecChar_> but acid-state is an interesting option
00:34:53 <fr33domlover> shanemikel, by DList i meant a difference list :P
00:35:04 <shanemikel> oh, is that what that is?
00:35:20 <fr33domlover> @hackage dlist
00:35:20 <lambdabot> http://hackage.haskell.org/package/dlist
00:35:21 <shanemikel> haven't used the one in the libs yet
00:36:52 <fr33domlover> but is a DList better there? List prepend is O(1) and list reverse is O(n). DList append is O(1) and DList.toList is O(n)
00:37:09 <fr33domlover> and the latter function is used for DList folds anyway
00:39:55 <shanemikel> fr33domlover: it seems like both approaches have a similar disadvantage.. that is, if you need to do appends and use the data intermittently, you will have to reverse multiple times for the first case.. in the case of dlist, once you finally apply the DList, there's no going back
00:43:24 <fr33domlover> shanemikel, i need to build the list and fold over it exactly once
00:43:38 <fr33domlover> so with a haskell list, it will be a single reverse
00:44:26 <shanemikel> Then you're probably fine with either case.. Though the reverse might take a little more memory, but I'm not sure
00:45:13 <shanemikel> actually, you might want to test this, but I bet the DList is a lot better on memory
00:46:01 <fr33domlover> i have no idea yet how to test such a thing :P
00:46:15 * fr33domlover needs to learn
00:47:29 <shanemikel> I wouldn't know how to do it scientifically, either, but you can try and perform it with a really big list and (while you're not doing other things at the same time) look at a system monitor type thign
00:56:02 <shanemikel> don't take that statement for anything more than speculation, I haven't read the report yet
01:28:36 <jophish> Ralith: DuplicateRecordFields is serving pretty much the same function as a (more complex) typeclass solution would do
01:29:34 <Ralith> jophish: otoh, typeclasses would work with ghc 7
01:29:54 <Ralith> also, isn't DuplicateRecordFields only statically polymorphic?
01:31:14 <jophish> Ralith: it is, (perhaps not with the next ghc I think). But I can't think of many places where that would be useful for the vulkan bindings (perhaps the pType member...)
01:32:06 <jophish> My thinking for only going with ghc 8 is that not many people are going to be bothered about this in a couple of months
01:32:13 <Ralith> fair enough
01:32:50 <Ralith> exciting work, anyway!
01:33:03 <parsecChar> how does safecopy work?
01:33:05 <parsecChar> it seems like balck magic
01:33:13 <jophish> thanks! It's still a little "under construction" but it can be used!
01:37:36 * hackagebot haskellscrabble 2.1.1 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-2.1.1 (happy0)
01:37:38 * hackagebot haskellscrabble 2.2.1 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-2.2.1 (happy0)
02:19:44 <hc> I'm running a few long-running daemons written in haskell... is it possible that a memory leak exists only with -O0, but not with -O1 or -O2?
02:20:11 <hc> And if so, could you point me to the concrete optimisations that may prevent these leaks?
02:37:38 * hackagebot lambdacube-compiler 0.5.0.1 - LambdaCube 3D is a DSL to program GPUs  https://hackage.haskell.org/package/lambdacube-compiler-0.5.0.1 (CsabaHruska)
02:40:46 <fr33domlover> Is there an existing newtype wrapper for reverse Ord? e.g. RevOrd 5 < RevOrd 4 ==> True
02:41:00 <dogcat> flip?
02:41:10 <fr33domlover> (i can write my own, just prefer to reuse if it exists)
02:41:22 <dogcat> > flip (-) 4 5
02:41:23 <lambdabot>  1
02:41:37 <dogcat> ohhh, yea, not sure 
02:41:53 <mpickering> It's called "Dual"
02:41:57 <mpickering> in Data.Monoid
02:42:37 <mpickering> hc: That is far too vague, you need to provide code if you expect any reasonable answer
02:43:28 <fr33domlover> mpickering, but Dual auto-derives Ord
02:43:34 <fr33domlover> so i'd get the same order
02:43:46 <fr33domlover> as the wrapped type
02:43:52 <dogcat> :mpickering, any advice on a preferred web server? Servant/Scotty? for micro-services?
02:43:53 <ozgura> was it not called Down?
02:44:24 <mpickering> ah yes sorry, ozgura is right
02:44:57 <mpickering> https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ord.html#t:Down
02:45:12 <mpickering> dogcat: I don't know 
02:45:27 <dogcat> I'm trying to convince a business partner that micro-services can create a language agnostic architecture for a start-up, anyone have any advice?
02:45:57 <tdammers> why do you think you need microservices?
02:46:02 <fr33domlover> ozgura, mpickering, thanks. exactly what i waneted :)
02:46:11 <dogcat> so you can integrate multiple programming languages
02:46:27 <tdammers> you don't necessarily need microservices for that
02:46:30 <tdammers> there are other options
02:46:38 <dogcat> for applications like ethereum
02:46:46 <tdammers> what's that
02:47:05 <dogcat> its a block chain technology where the proof of work is turing complete
02:47:31 <dogcat> I"m really just trying to show how Haskell can kick ass for start-ups
02:47:41 <dogcat> or be worth the trouble of integrating
02:47:51 <dogcat> u know, get us all some jobs
02:49:19 <tdammers> I guess the way to show how Haskell can kick ass in a startup is to use Haskell in a startup
02:49:22 <dogcat> :tdammers, what would an alternative be that could integrate say, python and haskell webservices?
02:49:43 <tdammers> you didn't mention you need things to be web services
02:49:47 <dogcat> oh, sorry
02:50:04 <tdammers> generally speaking, if you want to interface between languages, you can do several things
02:50:14 <tdammers> one is to compile to a common binary format, but that's not possible with Python
02:50:19 <dogcat> yea, I'm familiar with DSLs via work
02:50:44 <tdammers> another option is "shelling out", running one program as a subprocess of another, and communicating via environment variables, arguments, and pipes
02:50:45 <fr33domlover> dogcat, integrate how tightly? you can pass binary data over unix socket or give them both JSON APIs over HTTP
02:50:54 <parsecChar> I've used opaleye in the past. I'm currently looking at groundhog. How do the two differ in terms of functionality ?
02:51:02 <dogcat> I would like to make the integration on the level of APIs
02:51:15 <dogcat> that way you can easily define and deploy small services
02:51:15 <tdammers> those are also APIs
02:51:28 <dogcat> and use json formatted messages
02:51:38 <tdammers> json is an implementation detail
02:51:50 <dogcat> yea, specifically with great Haskell support
02:51:56 <tdammers> but anyway, if that's how you want to do things, then Haskell is certainly up to it
02:52:19 <dogcat> but if its not the most effective way to do things, the point is sort of mute
02:52:31 <tdammers> the obvious libraries for this are Warp, WAI, maybe Scotty, for the HTTP part; Aeson for JSON support
02:52:45 <tdammers> "most effective" is a matter of priorities
02:52:49 <dogcat> okay, we use Scotty at work, I was wondering if Servant would be that much better
02:53:04 <tdammers> I don't know, haven't tried Servant myself yet
02:53:06 <oddasat> Servant does the trick for us
02:53:21 <oddasat> quite well
02:53:39 <dogcat> well, I think the gains Haskell has in type system, immutability, and abstraction can be shown to be superior to something like Python
02:53:47 <dogcat> and generally OO
02:53:55 <dogcat> :oddasat, thanks!
02:54:25 <oddasat> if nothing else, we get by with a lot less code
02:54:34 <tdammers> dogcat: yes, but that's completely orthogonal to the microservices concern
02:55:45 <dogcat> yea, the architecture would serve to put languages on an equal footing
02:56:17 <dogcat> so you could show someone, specifically, how the Haskell solution is more effective, elagant, requires less tests, etc
02:56:47 <tdammers> eh
02:56:50 <tdammers> doubt that'd convince anyone
02:57:14 <tdammers> if you want to kick ass, pump out an amazing application in a week that runs fast and without observable bugs
02:57:27 <dogcat> yea, i've seen haskell do that
02:57:34 <tdammers> and then keep making it more amazing without sacrificing quality, for years on end
02:58:20 <dogcat> i was thinking high profile hackathon 
02:58:38 <tdammers> because during the first week, Haskell and, say, Python are roughly on par, but with Haskell you can almost maintain that momentum whereas in Python you end up in a complexity tarpit most of the time
02:58:56 <dogcat> good point, I've seen that first hand
02:59:07 <dogcat> the flexibility and OO cause huge debt in python
02:59:11 <tdammers> yes
02:59:14 <dogcat> but the cost of writing the minimal service about the same
02:59:28 <tdammers> Python is optimized for the first six hours on a project and the first two weeks of learning the language
02:59:37 <dogcat> love it for data analysis
02:59:49 <tdammers> yeah, but that's mostly because it has amazing libraries for that
03:00:02 <dogcat> yea, R has some great libs too
03:00:21 <dogcat> Haskell really isn't even in the same league as R for stats, hopefully I can work on that problem someday!
03:01:03 <dogcat> but then you have to ask: what's the advantage to using haskell for this? it may not really be there, except for analysis or machine learning projects that need to be scaled up quickly
03:01:28 <tdammers> if you need to do heavy data analysis, I'd stick with R or Python
03:01:41 <tdammers> but that doesn't mean you have to do *all* of it in R or Python
03:01:47 <dogcat> yea, we do a ton of analysis in Haskell at work, it's sort of a mess!
03:01:55 <tdammers> you can still use Haskell to build a robust application around a core written in R
03:02:02 <dogcat> you dont' have things like data.frame, split/apply/combine, indexing
03:02:33 <dogcat> HaskelR is really cool
03:02:41 <dogcat> but R is so f'ing slow
03:03:18 <dogcat> i'm convinced its best used when you aren't sharing your R code, just your results
03:03:44 <tdammers> well, yeah
03:04:08 <tdammers> I think what I'd do is isolate the R code, and run it as a subprocess in a Haskell parent application
03:04:32 <dogcat> i would just assume make Haskell better than try that
03:04:43 <tdammers> well, we're talking startups right
03:04:54 <dogcat> yea, good point
03:05:12 <dogcat> I've written fast R code, it's not actually that bad to do in C++
03:05:15 <tdammers> and your core product is not "a data analysis library for Haskell", it's "data analysis"
03:05:33 <dogcat> yea, really though, its probably some data set you got
03:05:56 <Jinxit> just to be clear, we don't really have any extensive haskell libraries for machine learning right?
03:06:03 <dogcat> HLearn
03:06:11 <dogcat> we need better linear algebra support
03:06:50 <dogcat> haskell also needs an implementation of ggplot2
03:07:06 <dogcat> lol, we can use HaskellR to inline R in the meantime...
03:07:21 <Jinxit> HLearn looks very barebones to me
03:07:41 <dogcat> i would agree, it's only supported one or two academic publications
03:07:50 <dogcat> it shows promise though
03:08:33 <dogcat> you can implement most models yourself, even something like boosting is possible to do, the problem comes in when you don't have good numerical optimization routines
03:08:42 <dogcat> like BGFS
03:09:35 <peddie> dogcat: there are several packages available that implement BFGS or something nicer
03:11:08 <dogcat> yea, I just talked to Stephen Diehl, I think he's working on a better linear algebra library
03:11:25 <dogcat> one that could do stuff like Cholesky Decomposition well
03:11:26 <dogcat> https://en.wikipedia.org/wiki/Cholesky_decomposition
03:11:39 <peddie> dogcat: hmatrix-gsl provides a binding to GSL's BFGS routine.  ipopt-hs provides bindings for IPOPT and NLOpt, both of which are free and have SQP solvers.  the casadi bindings or dynobud package let you interface to IPOPT and SNOPT.
03:11:51 <dogcat> nice!
03:12:04 <peddie> dogcat: hmatrix lets you call the GSL routines for cholesky decomposition
03:12:33 <dogcat> yea, that's nice
03:12:40 <dogcat> that shit is so hard to code right...
03:13:30 <dogcat> the promise haskell brings to machine learning is that you could really deploy a model quickly
03:13:54 <dogcat> like quickly test a couple algorithms, find one that works, and boom! into production it goes
03:14:00 <Jinxit> eh
03:14:13 <dogcat> that's just my opinion for a killer app I would use...
03:14:14 <Jinxit> it's probably faster in a language which has them established and ready out of the box
03:14:43 <dogcat> yea, this stuff only needs to be explored once, I've done this in R and piggy backed on a ton of great algorithms for classification
03:14:53 <dogcat> just to explore decision space
03:15:32 <dogcat> but deploying that R code would be a mess, it wasn't that reliable, very memory/CPU intensive
03:16:43 <dogcat> Haskell's type system, immutability, and abstraction make it a lot better for deploying production code that works
03:17:40 <dogcat> idk, it will be the day when statistician publish Haskell code in their trade magazines...
03:18:31 <dogcat> not to rail on haskell though, there is room for some great projects in the next 5-10 years
03:24:48 <liste> a big part of Haskell usage is financial modeling; most of it is proprietary though
03:26:34 <Jinxit> do we have a reasonable BLAS-accelerated matrix library?
03:26:46 <dogcat> :list
03:26:56 <Jinxit> and by reasonable I mean I don't want to call gemm manually
03:26:57 <dogcat> :liste that's how I get paid
03:27:18 <dogcat> its sort of too bad, we try to open source what we can
03:28:40 <dogcat> but the reality is: when you can control the data, you will also be able to control the analysis. For those applications, Haskell makes some pretty toys...
03:29:30 <dogcat> that process, may be applied to other domains. Nothing is really finance specific
03:31:08 <dogcat> :Jinxit, the only reasonable thing I can really find is Repa
03:32:06 <pavonia> liste: Do you know of any open source projects in the financial sector?
03:33:10 <dogcat> https://hackage.haskell.org/packages/#cat:Finance
03:33:17 <dogcat> is about everything available open source
03:33:45 <dogcat> is a list of companies: https://www.fpcomplete.com/business/haskell-financial-analysis/
03:33:52 <liste> pavonia: no, apart from what dogcat said
03:35:04 <dogcat> I would definitely dig a nice portfolio optimization library
03:35:27 <dogcat> maybe some PCA analysis in there too!
03:36:13 <pavonia> I heard Haskell is being used for high frequency trading. It would be interesting to have a look at some of this code
03:36:34 <dogcat> yea, that would be great! 
03:36:42 <dogcat> i wonder if its just a DSL
03:36:55 <dogcat> and translates to C
03:36:59 <Jinxit> dogcat: repa doesn't list a blas dependency
03:37:47 <dogcat> :Jinxit, would it be possible to add support in repa for blas?
03:37:59 <dogcat> repa is so nice for define matrix computations
03:38:22 <Jinxit> I'm the wrong person to ask :)
03:38:30 <dogcat> me too!
03:38:46 <dogcat> i studied this enough to know it's very important to get right!
03:44:24 <dogcat> :Jinxit, best Repa examples I can find: https://github.com/DDCSF/repa/tree/master/repa-examples/examples
03:44:59 <dogcat> so PageRank requires EigenVectors, that's good!
03:45:21 <dogcat> FFT support, pretty good
03:47:57 <Ashy> is anoyone successfully using ghc-mod with stack?
03:48:03 <MasseR> o/
03:48:06 <liste> o/
03:48:16 <MasseR> stack exec nvim
03:48:21 <dogcat> yea
03:48:27 <MasseR> by extension it calls ghc-mod with correct pkg
03:48:32 <dogcat> i needed to add ~/.local/bin whatever to my path
03:48:43 <MasseR> I did initially, but it didn't work properly
03:48:50 <MasseR> then I started doing stack exec nvim
03:48:57 <MasseR> No problems since
03:48:59 <dogcat> i installed ghc-mod from my home directory
03:49:08 <MasseR> I installed ghc-mod with stack
03:49:11 <MasseR> stack install ghc-mod
03:49:17 <dogcat> do you have ghc-mod as a system package?
03:49:21 <dogcat> that was messing me up
03:49:25 <MasseR> no
03:49:33 <MasseR> Only as stack-installed app
03:49:55 <MasseR> Must say, stack is really magnificent (except for when it comes to ghcjs)
03:50:13 <liste> stack install ghc-mod worked for me out of the box, even with vim started from outside stack
03:50:33 <dogcat> okay, is $USER/.local/bin/ghc-mod in your path?
03:50:58 <dogcat> that was the trick that got it to work for me
03:51:16 <dogcat> sorry, $HOME/.local/bin/ghc-mod
03:51:36 <dogcat> yea, it's nice to have vim + ghc-mod
03:51:36 <free_beard> if you're using stack executables from the global project, how are you managing upgrades?
03:52:04 <dogcat> requiring each project to have a specific version
03:52:05 <liste> syntastic's ghc-mod plugin doesn't work with recent ghc-mods though
03:52:05 <free_beard> for example if you're running xmonad from the global project, you just change the resolver for the global project and then...
03:52:16 <MasseR> I really recommend doing 'stack exec nvim', handles even project specific ghc-mods
03:52:17 <peddie> Jinxit: hmatrix calls BLAS under the hood for gemm
03:52:57 <dogcat> :peddie, can hmatrix do things like cholesky decompositions?
03:52:58 <peddie> Jinxit: it doesn't make much sense to call BLAS from repa code in most cases, because most BLAS software is not parallel
03:53:07 <peddie> dogcat: I believe I mentioned to you above that it can
03:53:12 <dogcat> word
03:53:18 <peddie> dogcat: https://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html
03:54:23 <dogcat> i think we found my linear algebra library!!!
03:55:36 <dogcat> hmatrix is great!
03:55:55 <peddie> dogcat: hmatrix is not perfect; in particular, if you write code that calls LAPACK and BLAS in e.g. C, you'll probably do a better job at allocation and so on.  but I would use hmatrix until/unless you run into a specific problem with it
03:56:25 <dogcat> okay, thanks! I just need some basic support for SVD
03:56:30 <peddie> you should be fine
03:56:38 <dogcat> and correlation/covariance matrixes
03:57:14 <peddie> hmatrix, hmatrix-gsl and hmatrix-gsl-stats cover most of GSL; if there's something in GSL that you need but isn't brought out in haskell yet, please ping me
03:57:22 <dogcat> thanks!
03:57:44 <dogcat> I just would like some quick eigenvalue decomposition for some stats functions I need to implement!
03:58:09 <Ashy> hmm, still getting issues when i run stack exec vim (when syntastic tries to run ghc-mod)
03:58:11 <peddie> good luck
03:58:16 <Ashy> i'll have to try again later
03:58:38 <dogcat> haha, yea, you never know how long it will take to implement something like PCA
03:58:54 <liste> Ashy: see my line about syntastic+ghc-mod
03:58:58 <liste> they don't work together
03:59:11 <liste> I use hdevtools with syntastic
04:00:55 <MasseR> hdevtools wasn't available from stack :/
04:01:07 <Jinxit> peddie: thanks, I'll take a look at hmatrix
04:01:22 <liste> MasseR: you can add it to global-project/stack.yaml
04:01:45 <MasseR> ah, I didn't know about the global-project
04:01:59 <dogcat> does hmatrix have a test suite for demonstrating numerical stability?
04:03:33 <peddie> dogcat: it has a test suite which you could lookat
04:04:10 <dogcat> thanks, I had to ask!
04:04:26 <peddie> dogcat: it's mainly just calling out to GSL under the hood
04:05:06 <dogcat> okay, I trust those implementations
04:29:08 <takle> What is more idiomatic `mapM_` or `traverse_` when writing haskell
04:29:15 <Ashy> liste: ah thanks
04:29:42 <Gurkenglas__> compare liftM and liftA and fmap
04:33:27 <takle> Well "`mapM_` As of base 4.8.0.0, mapM_ is just traverse_, specialized to Monad.". So its the same but more specialised. Also hlint "#132, don't ever suggest liftM". So I was just wondering if one should stop using some fns in general
04:47:15 <MasseR> Does it mention only liftM, or liftM2 and the like`
04:47:39 <MasseR> I find, depending on the situation lift{A,M}{2,3} to be more readable than <$> <*>
04:47:48 <MasseR> Especially when using with infix functions
04:47:59 <MasseR> @type liftA2 (+)
04:48:00 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
04:48:02 <MasseR> vs
04:48:18 <MasseR> @type \a b -> (+) <$> a <*> b
04:48:19 <lambdabot> (Num b, Applicative f) => f b -> f b -> f b
04:48:38 <liste> @pl \a b -> (+) <$> a <*> b
04:48:38 <lambdabot> (((+) <$>) .) . (<*>)
04:48:41 <liste> :D
04:49:04 <MasseR> ... yeah 
04:51:32 <asthasr> Is there ever a practical use for the Sum a and Product a types in Data.Monoid?
04:51:54 <lpaste> liste pasted ‚Äúsomething quite non-DRY‚Äù at http://lpaste.net/153804
04:52:02 <liste> should I DRY that up?
04:54:46 <liste> asthasr: you can use them in anywhere a Monoid is required, e.g. Writer
04:56:12 <liste> > runWriter (do {tell (Sum 7); tell (Sum 12); tell (Sum 14)}
04:56:14 <lambdabot>  <hint>:1:59:
04:56:14 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:56:20 <liste> > runWriter (do {tell (Sum 7); tell (Sum 12); tell (Sum 14)})
04:56:22 <lambdabot>  ((),Sum {getSum = 33})
04:56:24 <Thul> hello
04:57:26 <liste> hello Thul! (:
04:57:40 <Thul> i thought i eventually understood the monad transformation thing, but I struggle with something.
04:57:59 <liste> Thul: go on (:
04:59:58 <Thul> liste: yep, hadn't prepared the paste. :D here it comes: http://lpaste.net/6119002862518272000
05:00:23 <Thul> the problem is within the clientOnSocket function
05:00:48 <liste> :t liftIO -- Thul
05:00:49 <lambdabot> MonadIO m => IO a -> m a
05:00:57 <Thul> I guess, I'm looking for liftIO to get the Handle liftet inside my monad
05:01:12 <Thul> but in which packe is it defined?
05:01:27 <Thul> hoogle just links to some dead hackage pages
05:01:51 <liste> Thul: transformers
05:01:59 <liste> (which mtl wraps)
05:02:11 <Thul> so mtl suffices?
05:02:12 <liste> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-IO-Class.html
05:02:22 <liste> you need to add transformers to your .cabal too
05:02:29 <Thul> ok
05:02:53 <liste> but it is already used by mtl, so no new downloads
05:03:22 <liste> :k MonadBase -- this is more general variant of the same thing
05:03:23 <lambdabot>     Not in scope: type constructor or class ‚ÄòMonadBase‚Äô
05:03:24 <Thul> and what's broken with the hoogle index? :D I'm not confident enough, to solve this such circumstances by myself. :D
05:03:46 <Thul> but thanks for your kind help, liste. :)
05:04:21 <liste> Thul: you're welcome (:
05:05:33 <lyxia> Thul: If you search liftIO on hoogle, the documentation for the module doesn't exist but the link to the package transformers works
05:05:54 <lyxia> from there you can try going back a couple of versions to find docs
05:07:11 <Thul> lyxia: i get a 404, if i click on the function definition in the results after having clicked on the package 'transformers'.
05:07:25 <Thul> links there: http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-IO-Class.html#v:liftIO
05:08:30 <Thul> ah, i see
05:08:34 <lyxia> :)
05:08:36 <liste> Thul: not all hackage versions have haddocks; the process for uploading them is not optimal. stackage has all docs: https://www.stackage.org/
05:08:48 <lyxia> oh yeah, or use stackage
05:08:50 <Thul> i had thought too straight, i guess... :D
05:08:50 <liste> Thul: it doesn't have all packages though, but quite a lot
05:09:10 <liste> the top right textbox is hoogle
05:10:20 <Thul> it's a shame to get stuck on such simple things... meh.
05:10:40 <cocreature> I wish cabal and stack just built docs locally and uploaded them by default
05:11:10 <tdammers> cocreature: I think that'd make for a very reasonable feature request for stack at least
05:11:35 <cocreature> tdammers: there is already an issue for it, but nobody (me included) has gotten around to implementing it
05:11:43 <tdammers> I see
05:11:59 <tdammers> you could hire me to do it for you
05:12:00 <tdammers> :P
05:12:47 <cocreature> here‚Äôs the issue https://github.com/commercialhaskell/stack/issues/737
05:13:32 <cocreature> tdammers: how about you hire me? :)
05:13:48 <tdammers> lol, just got laid off myself, so not gonna happen :D
05:14:59 <bernalex> how about we start a company? any other laid of haskeller in here? ;)
05:16:06 <dcoutts> cocreature: cabal has a mode to generate docs
05:16:25 <dcoutts> or more specifically, a flag to generate the right format
05:16:30 <cocreature> dcoutts: yes, but it doesn‚Äôt upload them by default
05:28:11 * hackagebot order-statistic-tree 0.1.0.1 - Order statistic trees based on weight-balanced trees  https://hackage.haskell.org/package/order-statistic-tree-0.1.0.1 (MZiatdinov)
05:28:14 <vlastachu> hello. I am writing function which express next operation: 
05:28:15 <vlastachu> -- X / Y ï Y => X (>)
05:28:38 <vlastachu> So my code is
05:28:38 <vlastachu> forwardApplication  (x :/ y)  y'  | y == y' = Just x
05:29:27 <vlastachu> Is there any extension which provide next form of function:
05:29:47 <vlastachu> forwardApplication  (x :/ y)  y = Just x
05:30:20 <liste> vlastachu: no (afaik)
05:30:50 <parsecChar> in groundhog, how do I drop an entire table?
05:30:55 <parsecChar> I'm aware of https://hackage.haskell.org/package/groundhog-0.7.0.3/docs/Database-Groundhog.html
05:31:01 <parsecChar> but it's not clear how to remove an entire table
05:31:43 <bollu> hey everyone
05:32:15 <bollu> I'm planning on submitting a proposal to SymPy engine on creating Haskell bindings to SymPy for GSoC 2016
05:32:40 <bollu> so, well, I'd like someone to "mentor" me so to speak, so I can ask for help with Haskell's FFI
05:32:42 <bollu> since I've never used it before
05:33:02 <vlastachu> It is not important for this case or for more complicated cases, but I feel that something similiar should be and possibly I am not first who think about it
05:33:14 * hackagebot distributed-process-tests 0.4.5 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.5 (FacundoDominguez)
05:33:47 <bollu> here is a link to the mailing list discussion: https://groups.google.com/forum/#!topic/symengine/MntlZjfME_o
05:33:58 <bollu> I could really use some help from someone who's used to writing Haskell bindings
05:35:08 <cocreature> bollu: haskell is not a gsoc project, however there are some alternative plans, see https://www.reddit.com/r/haskell/comments/48eurt/haskell_summer_of_code/
05:35:29 <liste> vlastachu: you certainly aren't, but IMO that would be confusing (a secret Eq constraint) with little benefit
05:36:17 <bollu> cocreature: yes, I know. But I'm applying under SymPy
05:36:28 <bollu> cocreature: I was planning to work on diagrams on the summer for GSoC :(
05:37:32 <cocreature> ah ok
05:39:14 <Darwin226> Hey guys, quick question. If we think of Identity as the 'Just' functor. What's the 'Nothing' functor? 
05:40:05 <cocreature> Darwin226: I don‚Äôt think of Identity as the 'Just' functor but if you want to do so, Const () is probably close to Nothing
05:40:42 <Darwin226> cocreature: That's a good idea. Probably better than Proxy
05:41:02 <cocreature> proxy is just as good
05:41:23 <Darwin226> cocreature: But I'd kind of feel dirty using it like that
05:41:32 <cocreature> what are you trying to do anyway?
05:42:18 <Darwin226> I have a datatype that has a Maybe Something field. I'd like to expose that information at the type level
05:42:46 <Darwin226> So I was thinking of something like data Type f = Type (f Something)
05:46:58 <mpickering> Seems fine
05:47:43 <Darwin226> mpickering: So what would you go for, Const () or Proxy?
05:48:23 <mpickering> I don't really understand to be honest what you are trying to do
05:49:26 <mpickering> I thought you wanted `Type Maybe`
05:49:42 <cocreature> I would just create a tag type like data Tag = TJust | TNothing and then make a gadt
06:23:21 <sphinxo> So i've defined my types like so https://dpaste.de/v7mZ/raw
06:23:50 <sphinxo> and i'm having an issue with String and [t] overlapping
06:24:40 <geekosaur> that would be expected, yes. you generally don't want to do that
06:24:53 <sphinxo> What should I do?
06:24:53 <aweinstock> String is [Char]
06:25:17 <sphinxo> Just work with chars and remove strings entirely?
06:25:17 <thevaliantx> is there any reason for someone new to programming (having been learning Python through books for 3 months or so) and starting to learn JavaScript?  I tend to look at things, in general, from a perspective of everyday life being like a collection of functions :)
06:25:18 <xnil> sphinxo: you *technically* could use Data.Text for TString
06:25:50 <xnil> and use TLists of TChars when you needed strings
06:25:54 <xnil> err, charstrings
06:25:54 <tdammers> thevaliantx: why are you asking this on a Haskell channel?
06:26:05 <thevaliantx> i meant to ask, is there any good reason for someone like me (or my 9 year old son who I am homeschooling) to learn Haskell?
06:26:16 <xnil> thevaliantx: yes
06:26:17 <sphinxo> thevaliantx: yes and yes
06:26:20 <bernalex> thevaliantx: you could s/Haskell/anything/
06:26:40 <tdammers> ^ yes
06:26:43 <tdammers> except PHP
06:26:58 <sphinxo> even if you never use haskell in prod, the things you will learn will make you a far better programmer
06:26:59 <xnil> thevaliantx: i'm going to give you a pretty straightforward set of answers: one for you, one for your son
06:27:27 <thevaliantx> xnil --> shoot.  i'm open-minded, my son enjoys programming
06:27:41 <sphinxo> thevaliantx: I like this answer on stack overflow http://stackoverflow.com/questions/2573135/python-progression-path-from-apprentice-to-guru/2576240#2576240
06:28:06 <sphinxo> although I'd recommend "learn you a haskell" instead of "real world haskell"
06:28:09 <xnil> for you: haskell is incredibly expressive and good for production development. It's fast, it's relatively safe (type-checking is phenomenal, only dependent typing beats it out on safety), and it's damn fun. the community has grown recently a lot too, just look at the number of people in this channel.
06:28:16 * hackagebot hlint 1.9.31 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.31 (NeilMitchell)
06:29:40 <xnil> thevaliantx: for your son: Haskell introduces a wealth of knowledge about computer science, cat theory, and software engineering that your son will greatly benefit from; it encourages separation of purity and statefulness, good module organization, and clever problem-solving skills to express algorithms and data structures succinctly.
06:29:53 <xnil> your son will potentially struggle with haskell. it will be good for him.
06:30:01 <thevaliantx> sphinxo: i just started reading "learn you a haskell" about five minutes before coming in here.  i seriously LOL'd at the picture of the sun saying "holy shit!" :D
06:30:10 <malc_> xnil: good module organization? are you kidding?
06:30:29 <xnil> malc_: yes because if you don't then you get a crap project layout
06:30:40 <thevaliantx> let me throw a little more fuel on the fire :D
06:30:43 <xnil> i'm trying to be helpful ;)
06:30:51 <xnil> thevaliantx: but "Learn You a Haskell" is not going to be the end-all solution.
06:31:00 <xnil> read both books. Real World Haskell AND LYAH.
06:31:15 <thevaliantx> okay, noted.  
06:31:17 <xnil> read more books. watch videos on youtube. experiment. read others' code.
06:31:28 <xnil> make learning a daily habit for both yourself and your son
06:31:34 <xnil> not just in haskell but in all areas of life
06:31:39 <xnil> steady progress beats out binging.
06:31:42 <malc_> yeah, start with the Lens stuff, easy parts should come first
06:31:43 <xnil> bingeing*
06:31:53 <xnil> malc_: don't troll
06:31:59 <xnil> thevaliantx: LYAH comes first
06:32:07 <xnil> work through it at a steady pace
06:32:17 <xnil> set a time for yourself that you'll always practice just a little bit at least
06:32:32 <xnil> 5 minutes may be a good starting point for a minimum
06:32:43 <malc_> edwardk: see... haskellers are mean...
06:32:44 <thevaliantx> i don't know how in the hell i ended up wondering about haskell.  looked at one youtube video of something, that led to another and before i knew it i was watching some professor with a straw hat trying to explain about something called Monads.  whatever hair was on the front of my head is gone.
06:32:53 <ent> how do you think haskell programming from first principles compares to lyah?
06:33:02 <xnil> ent: link?
06:33:07 <ent> http://haskellbook.com/
06:33:11 <xnil> thevaliantx: use willpower to build up habits, and suddenly you don't need willpower anymore
06:33:15 <ent> it's not quite finished yet
06:33:18 <malc_> thevaliantx: b[ae]ckman?
06:33:19 <ent> and it's not very cheap
06:33:32 <ent> but at least the beginning looks _very_ beginner friendly
06:33:39 <xnil> ent: i'm checking it out right now
06:33:54 <sphinxo> thevaliantx: as a relatively young person who left school at a very young age to work full time,  can I just commend you for wanting to teach your child to code.
06:33:55 <xnil> malc_: b[ae]ckman is not exactly the best teacher in the world
06:34:19 <malc_> xnil: was just inquiring who the strawhatman was
06:34:51 <xnil> thevaliantx: as a psych/neurology enthusiast, i also commend you for encouraging independent STEM study in your kids
06:34:58 <xnil> you're making the world a better place
06:35:54 <sphinxo> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html is a great guide for understanding some of the core concepts behind fp
06:35:55 <thevaliantx> oh, thank  you sphinxo :D  i am not young (43), but my parents were too busy making money and maintaining their 'goody two shoes' public image as realtors to really give a crap about my education.  as long as i got C's or above.  my wife grew up in a religious cult, had to jump out of a first-story window to escape that.  we decided that if we couldn't meet or exceed what the public schools provide in the way of education, t
06:35:56 <thevaliantx> hen we wouldn't homeschool.  
06:37:11 <xnil> ent: this is awesome.
06:37:19 <thevaliantx> thank you xnil.  i won't pretend to know what 'STEM' is, but i do constantly tell him to 'push yourself, see if you can make this code work in less lines' or 'draw out on the whiteboard what you're trying to solve'
06:37:20 <xnil> i love that it introduces lambda calculus to the reader early on
06:37:30 <ent> yeah, I liked that too
06:37:33 <xnil> thevaliantx: STEM = science, technology, engineering, mathematics
06:37:45 <xnil> thevaliantx: whiteboarding...
06:37:46 <xnil> oh my god
06:37:48 <xnil> i love you
06:37:52 <xnil> be my dad please
06:38:05 <xnil> do more of that kind of thing
06:38:27 <thevaliantx> malc, yes :D  I would have loved to have him as a professor!  => http://stackoverflow.com/questions/2573135/python-progression-path-from-apprentice-to-guru/2576240#2576240
06:38:54 <xnil> also i don't mean to steer your parenting nor your self-development process but quite frankly habitually reading books is the single best way to stir on mental development in both children and adults
06:39:08 <xnil> make amazon/goodreads your best friends and you'll not regret it
06:39:19 <malc_> thevaliantx: he made a whole bunch of appearances on channel9, most haskell related
06:42:05 <sphinxo> xnil: so what apart from using Data.Text what would you recommend?
06:43:05 <geekosaur> [01 14:24] <xnil> sphinxo: you *technically* could use Data.Text for TString
06:43:05 <geekosaur> [01 14:25] <xnil> and use TLists of TChars when you needed strings
06:43:05 <xnil> sphinxo: crying into a bucket of noodles
06:43:17 <thevaliantx> xnil on my side of the schoolwork i teach logic, compsci, music and art.  currently i am using art (The Thinking Toolbox & The Fallacy Detective), music (recorder using The Recorder Guide), math (Saxon 5/4), art (The Art of Perspective) and compsci (The Easy Way To Learn JavaScript, Python Programming For The Absolute Beginner, 46 Function Exercises => http://www.ling.gu.se/~lager/python_exercises.html) and architecture (Bui
06:43:18 <thevaliantx> lt To Last)
06:43:26 <sphinxo> Ahh ok
06:43:26 <MichielDC> Question considering profiling: Does inlining a function help to speed up that function? It currently uses 15%+ of computation time
06:43:29 <geekosaur> you can't do magic to resolve the conflict because a String *is* a list of Char
06:43:46 <sphinxo> thevaliantx: please never stop
06:43:46 <xnil> geekosaur: who was that in response to
06:43:56 <sphinxo> xnil: me
06:44:08 <geekosaur> you could tell the compiler to accept the overlap and it will try to handle the specific befpre the general, but it will also have a decent chance of getting you in trouble later
06:44:10 <xnil> thevaliantx: we love you and if i was a woman i would probably let you impregnate me solely for the parenting aptitude
06:44:17 <xnil> sphinxo: o ok
06:44:54 <sphinxo> thanks all
06:45:11 <xnil> thevaliantx: your son will be proud to have had you as a father.
06:45:39 <xnil> thevaliantx: also, don't forget to mix in some human/social learning in there somewhere
06:45:57 <MichielDC> Question considering profiling: Does inlining a function help to speed up that function? It currently uses 15%+ of computation tim
06:45:58 <xnil> learning sales is nice and cool and applies to pretty much anything you end up doing
06:46:03 <xnil> psychology as well
06:46:50 <thevaliantx> sphinxo: well ... wife and i have been talking about doing this at least up to high school.  we're just afraid that at that point we won't be able to match the skill level in math, science, music, etc.  who knows what will happen?  and i have health issues (diabetes, hearing impaired) and suffer from social anxiety and depression....often leaving me fatigued....so it's been an adventure, but i am glad he's gotten to be face-
06:46:50 <thevaliantx> to-face with all of this.  
06:47:52 <thevaliantx> xnil, he goes to church often, belongs to a homeschool group in another city that he attends each monday, has friends from the homeschool group.  he's also pretty darn good at minecraft (i know, i know)
06:48:43 <thevaliantx> but we all have problems.  if we stand around waiting for our problems to go away, a whole line of new ones will be stacked up outside the door.  everyone else will seem to have resolved their's :D
06:49:11 <xnil> oof
06:49:37 <xnil> i sincerely think if the son is learning haskell at age 9 he won't have any problem with high-school courses...
06:50:20 <xnil> hope he comes back. social anxiety and depression are sad ailments (literally!)
06:50:32 <ARM9> is there any succinct way to make enums with associated integer constants like C enums? bonus points for constant folding
06:52:16 <MichielDC> Question considering profiling: Does inlining a function help to speed up that function? It currently uses 15%+ of computation tim
06:52:19 <thevaliantx> i just wanted to say thanks to everyone for the kind words, and for the sources of material for my son and i chomp on.  what a nice channel, i'll be back around soon :)
06:52:38 <oherrala> xnil: or then the son is in huge problems because he's too much ahead of everyone else :)
06:53:04 <liste> ARM9: pattern synonyms
06:54:43 <johnw> MichielDC: not necessarily
06:54:56 <johnw> MichielDC: the best way to know is to inline it, profile and compare the results
06:54:56 <mauke> ARM9: user-defined integers or autogenerated?
06:55:30 <MichielDC> Well, I inlined it and it now uses 20% ....
06:55:45 <ARM9> liste: thanks, I'm reading through the proposal
06:56:01 <ARM9> mauke: autogenerated how? compile time? TH?
06:56:17 <johnw> MichielDC: if you inlined it, how is it still in the profiling report?
06:56:33 <mauke> ARM9: 0, 1, 2, 3 ..
06:56:48 <ARM9> sorry I don't see what that has to do with being auto generated
06:56:56 <xnil> oherrala: no
06:56:58 <ARM9> but yes a pattern like that, sure, or any arbitrary set of integers
06:56:58 <xnil> oherrala: not really
06:57:10 <MichielDC> johnw: No clue, never profiled before.. 
06:57:16 <xnil> oherrala: that's not a problem; what you're thinking of is social ineptitude / nonconformance
06:57:43 <MichielDC> johnw: Maybe GHC refuses to inline it. It's the bind of the codensity monad FYI
06:58:23 <mauke> ARM9: data T = Foo | Bar | Baz deriving (Enum) ?
06:58:24 <johnw> MichielDC: I see
06:58:55 <MichielDC> johnw: Codensity should be the magic that speeds up my program, but right now it's a limiting factor
06:59:21 <johnw> it's the magic that fixes the asymptotic problem with binding Free monadic constructions
06:59:26 <johnw> it's not a universal magic
06:59:53 <MichielDC> Well, I'm using some form of Free monads, so it's my magic :)
07:00:02 <johnw> are you using the 'free' package?
07:00:11 <ARM9> mauke: the important part is the corresponding integer, arbitrary sets (ie 1,2,4,8.. or 1,42,85.. etc.) and being able to use it in a numeric expression, so pretty much C enums
07:00:26 <mauke> so user-defined integers
07:00:27 <MichielDC> No, but I'm not explicitly using the Free monad
07:01:01 <oherrala> xnil: true
07:01:02 <ARM9> Yes, but with a type so you can't pass an invalid integer
07:01:10 <MichielDC> I've seen the Codensity implementation in kan-extensions, my implementation is the same
07:01:59 <johnw> I ask because maybe using Control.Monad.Free.Church is a good comparison point
07:02:56 <MichielDC> Just on a side note, in my profiling report, the most heavy-weight function is ">>=.\.\" and not ">>=". What does that mean?
07:02:58 <mauke> ARM9: those sound like conflicting goals
07:03:09 <ARM9> feel free to elaborate
07:03:21 <johnw> MichielDC: I've never seen that...
07:04:30 <MichielDC> Me neither.. And I can't inline ">>=.\.\" as it says that it's no method of the monad class
07:08:23 <pavonia> Why is IncoherentInstances required for the instances of the aeson package?
07:21:53 <geekosaur> MichielDC, my recollection is that the .\ appendages indicate lambdas invoked from within the function/operator
07:22:13 <geekosaur> since the lambdas have no names, they're reported as part of the thing invoking them
07:23:28 <MichielDC> geekosaur: Makes sense, my bind function uses 2 lambdas
07:29:06 <simpson> Hi! I'm looking for a data structure suitable for representing a (portion of) a poset. The literature is scarce but suggests that the two traditional structures are a DAG or an interval tree. Is there anything more appropriate for representing a poset?
07:30:13 <mniip> a lem function?
07:30:33 <mniip> er, lcm that is
07:31:50 <mniip> no wait
07:31:58 <mniip> I'm confusing names
07:33:15 <mniip> least upper bound / greatest lower bound
07:33:32 <c_wraith> hyperfunctions are hard.  I've just finally (after a week of trying during train rides to work) figured out how to write zip as a composition of hyperfolds on the input lists.
07:34:15 <mniip> c_wraith, hyperfolds? :o
07:34:49 <c_wraith> mniip: right folds on lists that result in a hyperfunction.
07:35:08 <mniip> ah
07:35:08 <c_wraith> mniip: hfold :: [a] -> (a -> b -> c) -> c -> H b c
07:35:21 <mniip> wait what
07:35:29 <mniip> what's H?
07:35:46 <c_wraith> newtype H a b = H (H b a -> b)
07:35:49 <johnw> a hyperfold should really have "melange" as one of its argument names
07:36:36 <MichielDC> is H inhabited? Or does it just loop forever?
07:36:52 <mniip> well it has some const inhabitants at least
07:36:57 <c_wraith> MichielDC: it has infinitely many perfectly well-defined inhabitants
07:37:03 <c_wraith> And not just the const ones. :)
07:37:38 * mniip . o O ( Can GHC derive Functor (H a) )
07:37:52 <c_wraith> arxiv.org/pdf/1309.5135.pdf has lots of information, including the thing I just struggled through writing from scratch.  I'm trying to reproduce the lines of thought involved, not just the result.
07:39:02 <c_wraith> though it really just calls them folds, rather than hyperfolds.  I just like throwing that prefix on everything.
07:40:18 <bengt_> hypermagic
07:45:29 <sphinxo> What kinds kinds of things can you do with hyperfunctions?
07:45:38 <sphinxo> s/kinds kinds/kinds
07:46:12 <johnw> one reason they were researched was to allow for fusion in the presence of zip functions
07:46:53 <sphinxo> johnw: "fusion" ?
07:48:18 <johnw> as in "list fusion"
07:49:08 <sphinxo> to avoid gc/thunk manipulation?
07:49:25 <johnw> to "fuse out" cons cell constructions
07:49:38 <c_wraith> For the record, GHC can't derive the Functor instance there.
07:49:46 <johnw> so that sum [1..10] is just a pure iteration, no memory used
07:50:01 <sphinxo> ooh
07:50:53 <sphinxo> this is a whole bunch of stuff I had no idea existed
08:04:25 <johnw> sphinxo: I have that experience often :)
08:16:11 <lingxiao> hey all
08:16:27 <johnw> hi lingxiao 
08:16:28 <lingxiao> has anyone played with purescript 
08:16:42 <lingxiao> i am wondering what your impression is of it
08:16:47 <lingxiao> and the community if any, around it
08:27:39 <bails> hey
08:27:57 <lingxiao> hey
08:28:22 <oherrala> Is there easy way to convert (Maybe a, Maybe b) into Maybe (a, b)?
08:29:19 <geekosaur> sequence, in ghc 7.10?
08:30:15 <oherrala> > sequence (Just 1, Just 2)
08:30:16 <lambdabot>  Just (Just 1,2)
08:30:29 <oherrala> hmm, not quite, but close
08:30:42 <geekosaur> just saw that, yeh
08:31:43 <bails> I'm just starting to hack and i was wondering what software should i start with
08:33:19 <dramforever> bails: Haskell? And what do you mean by "software"
08:33:36 <lyxia> oherrala: http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Sequence.html
08:33:47 <lyxia> it's quite ad-hoc
08:39:02 <bennofs> :t uncurry (liftA2 (,)) -- oherrala
08:39:03 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
08:39:59 <bennofs> Alternatively, if you're using the lens package (doesn't make sense to pull in that package just for this, but if you're already using it you might as well use functions from it):
08:40:14 <bennofs> :t both id `asAppliedTo` (undefined, undefined)
08:40:16 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
08:41:03 <bennofs> (both is from lens here, the `asAppliedTo` ... part if just to make it specialize the type sig for prettier output in lambdabot, not needed when using it)
08:45:45 <oherrala> bennofs: that's it. thanks!
08:49:51 <dramforever> :t both -- wait what?
08:49:52 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
08:49:58 <dramforever> oh
09:29:10 <Profpatsch> I am kind of afraid to use System.Directory.
09:29:34 <Profpatsch> Is there a nicer alternative? Or isn‚Äôt it as bad as the documentation makes it look?
09:31:00 <lyxia> does it look that bad to you?
09:31:08 <lyxia> (I'm honestly asking)
09:32:05 <opqdonut> there's also http://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-Directory.html
09:34:03 <Profpatsch> lyxia: Well, it looks like there are more exception cases than actual functionality.
09:34:23 <Profpatsch> Of course, that‚Äôs because of the hillariously bad POSIX API, but still.
09:38:03 <daedalus__> Anybody here to answer a noob question?
09:38:19 <lyxia> yes
09:38:23 <geekosaur> usually it's best to just ask the question
09:38:51 <daedalus__> Cool, thanks.
09:39:24 <daedalus__> I am making a nested list as a bit of an excercise.
09:41:27 <daedalus__> And this is my nested list so far: http://lpaste.net/153815 
09:41:47 <daedalus__> As far as I can tell, that works pretty well.
09:42:31 <daedalus__> But now I would like a function that folds only the lowest level of the nested list.
09:44:08 <lyxia> this zipWith doesn't look very law abiding
09:44:46 <daedalus__> Well, I need some specific semantics.
09:44:53 <daedalus__> But maybe it is wrong.
09:44:56 <mnoonan> daedalus__: something like foldOuter :: (a -> b -> b) -> ([NList a] -> b -> b) -> NList a -> b -> b?
09:45:23 <lyxia> daedalus__: and what do you mean by "lowest level"? Do you assume that the nesting is uniform?
09:45:30 <daedalus__> Let me think about that. :D
09:45:37 <daedalus__> Yes.
09:45:49 <xa0> what's the <|> operator called?
09:45:49 <daedalus__> In practice, the nesting will be uniform.
09:46:02 <lyxia> in which case 10 and 11 are useless
09:46:02 <xa0> awfully hard to google
09:46:12 <daedalus__> I am aware that that isnt enforced in the type so far.
09:46:32 <byorgey> xa0: it doesn't really have a name.  Maybe "orelse"?
09:46:39 <lyxia> well it's not as much a problem as something that needs to be said :)
09:46:45 <daedalus__> Ah, yes.
09:46:49 <xa0> byorgey: hm okay, where is it defined?
09:47:18 <daedalus__> Well, I want Values to be "broadcast" across nested lists.
09:47:41 <lyxia> uhm... I'll need an example. A couple even.
09:47:41 <byorgey> xa0: instead of using Google, you can search for it on haskell.org/hoogle
09:47:48 <daedalus__> You can think of it like numpy arrays if you happen to be familiar with those.
09:48:02 <byorgey> xa0: it is defined in Control.Applicative
09:48:17 <xa0> oh of course. thanks byorgey :)
09:48:25 <byorgey> sure
09:49:30 <daedalus__> Ok, here is an example List [Value 1, Value 2, Value 3] + Value 1 == List [Value 2, Value 3, Value 4] 
09:49:44 <lyxia> daedalus__: Ah I think I understand how this Applicative works, a Value behaves just like an NList matching the structure of the other argument.
09:49:47 <daedalus__> (Pseudocode)
09:49:59 <daedalus__> Yes!
09:50:27 <daedalus__> That's what I meant by "broadcasting", but that is numpy terminology.
09:50:47 <daedalus__> Not sure if there is any better name for it.
09:51:06 <daedalus__> But basically, values are special, because they can match any shape.
09:52:56 <Cale> daedalus__: That looks like something that your instance of Num might take care of (if there is a sensible one), or else perhaps you'd rather use some name other than (+) for that operation.
09:53:10 <daedalus__> And what I want now is a magic function f that will take sum and List [List [Value 1, Value 2], List [Value 3, Value 4]] to List[Value 3, Value 7]
09:54:34 <daedalus__> Cale: Thanks, that makes sense, maybe I should make it an instance of Num.
09:54:36 <sphinxo> Which parsing library has the output similar to clang? I remember someone mentioning one?
09:56:50 <quchen> sphinxo: trifecta?
09:56:52 <daedalus__> The only solutions that come to my mind for this foldOuter function seem pretty messy.
09:57:30 <sphinxo> daedalus__: that's it thanks
09:58:04 <mnoonan> the example you gave there looks more like a map than a fold
09:58:04 <daedalus__> sphinxo: I think quchen deserves credit for that. :)
09:58:23 * hackagebot aeson 0.11.1.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.1.0 (AdamBergmark)
09:58:35 <sphinxo> oops :) +1 quchen 
09:58:36 <monochrom> I cannot explain why the answer is List [Value 3, Value 7].
09:58:56 <daedalus__> The sum was applied to the innermost lists.
09:59:01 <daedalus__> Does that make sense?
09:59:16 <monochrom> yes and no. 1+3=3?
09:59:41 <monochrom> ok nevermind
09:59:58 <daedalus__> Phew, I thought my math was already that bad...
09:59:59 <daedalus__> :D
10:00:28 <mnoonan> oh, you want foldOuter :: ([a] -> b) -> NList a -> NList b?
10:00:52 <daedalus__> Yes, that would be a valid signature!
10:01:36 <mnoonan> I think part of the problem is your invariant about shapes isn't reflected in the data structure in any way
10:01:42 <daedalus__> But I feel like the types do not capture everything.
10:01:49 <daedalus__> Yes.
10:01:59 <daedalus__> That seems to be the problem.
10:02:28 <quchen> Using stack to generate a HPC report is quite impressively simple. The only thing missing is providing a clickable link to the generated files, so that I can do something like `firefox $(stack path coverage)` or something.
10:02:29 <mnoonan> can you use type-level Nats, maybe?
10:02:32 <daedalus__> So basically, I have to have some conditional checking whether the list only contains values.
10:03:10 <daedalus__> And even then I am not sure how exactly it would work.
10:03:43 <daedalus__> So, yes, some type-level computations would be required, I feel.
10:04:09 <daedalus__> Like making the depth of the nesting part of the type.
10:04:18 <mnoonan> right
10:04:38 <daedalus__> I just wanted to check whether that was the best solution, or whether there was anything simpler.
10:05:09 <mnoonan> well, you could keep it as an Int instead
10:05:22 <mnoonan> and only export smart constructors for your type to make sure the invariant is maintained
10:05:45 <daedalus__> Cool, that sounds good.
10:08:40 <harwiltz> Hello. I'm making a program that uses hscurses and I want Control-C to clean up hscurses before just shutting off. So I used installHandler to handle the keyboardSignal, which is working. Inside my handler, I'm calling endWin (which closes hscurses and restores the terminal) and then exitWith ExitSuccess. But when I press Control-C, the program outputs ExitSuccess but it doesn't stop running
10:09:42 <hpc> perhaps you need to end curses inside the right thread?
10:10:06 <monochrom> what does "outputs ExitSuccess" mean?
10:10:07 <harwiltz> hpc, Maybe, but I'm not managing threads at all
10:10:18 <harwiltz> monochrom, in my terminal, it says ExitSuccess
10:10:30 <monochrom> does it say anything else?
10:10:46 <daedalus__> Alright, I'll look into making the depth of the nesting part of the type, since that sounds like the most ideomatic solution.
10:10:49 <harwiltz> It says ProgramName: ExitSuccess
10:10:51 <daedalus__> But just out of curiosity. There is nothing already out there in haskell that would take sum and [[1,2,3],[4,5]] to [6,9]?
10:11:00 <harwiltz> reset
10:11:14 <harwiltz> ^sorry I mean to type that in my terminal
10:12:21 <harwiltz> Actually, more precisely, the curses display shuts off and the terminal is restored, which says ExitSuccess, and then the program starts back up
10:12:22 <MarcelineVQ> daedalus__: map/fmap does that
10:12:51 <daedalus__> Hm, yes.
10:13:31 <monochrom> where did you obtain "installHandler" from?
10:13:47 <daedalus__> But also [[[1,2],[3]],[[4,5]]] to [[3,3],[9]] for example.
10:13:51 <harwiltz> System.Posix.Signals
10:14:16 <daedalus__> Maybe fmap does that, too, though. I need to think about that.
10:14:21 <MarcelineVQ> just crank up the fmap :>
10:14:24 <MarcelineVQ> > (fmap . fmap) sum [[[1,2],[3]],[[4,5]]]
10:14:26 <lambdabot>  [[3,3],[9]]
10:14:30 <daedalus__> :D
10:14:39 <monochrom> did you see its doc contains the phrase "new thread"?
10:15:01 <daedalus__> Cool, that puts me on the right, path I think.
10:15:04 <harwiltz> monochrom, nope. I should read that carefully
10:15:39 <harwiltz> monochrom, ok, so how else should I handle the signal?
10:16:06 <monochrom> main thread does nothing other than waiting for other threads to tell it "please exit"
10:16:19 <Teijawe> Question about stack. How do I make it not download the 120mb of ghc every time I start a new project?
10:16:26 <monochrom> and a signal handler tells the main thread "please exit"
10:16:29 <mnoonan> daedalus__: you might want to check out the "shape" parameter for the arrays used by Accelerate
10:16:32 <harwiltz> I see. I guess thats why it keeps resuming
10:16:37 <Teijawe> (slowly download from a slow site)
10:17:07 <harwiltz> But how else can I safely close the program then?
10:17:22 <geekosaur> it's worth noting that hscurses does not handle threads sanely (because curses itself doesn't)
10:17:33 <daedalus__> Yes, if the shape/depth was available in the type, it would tell me the number of repetitions of fmap I need to get to the lowest level.
10:17:41 <harwiltz> geekosaur, I know, but I'm not using hscurses to handle the signals
10:17:44 <daedalus__> So that is the way to go, I suppose.
10:18:06 <monochrom> I would not use ncurses to begin with. it's self-inconsistent, second to PHP only. I would completely circumvent it and use vty.
10:18:30 <harwiltz> monochrom, I guess I'll look into that. But I'm already done writing my program
10:19:22 <daedalus__> Many thanks mnoonon and MarcelineVQ, I should be able to take it from here.
10:19:26 <harwiltz> Is there a way to stop the main thread? 
10:19:37 <geekosaur> harwiltz, that;s less relevant than that hscurses can misbehave badly (a) when used with multiple threads (b) less commonly, when it is not being used in the main thread
10:20:36 <harwiltz> Ok. I never knew ncurses was to be avoided
10:20:55 <harwiltz> But for my program, should I manually create a thread to run my hscurses in and the close it somehow?
10:21:42 <geekosaur> and I should not have said hscurses there because the problem is with the curses library itself (and not even specific implementations, much less specific bindings)
10:23:10 <harwiltz> I fixed it (I think)! I just used exitImmediately from System.Posix.Process rather than exitWith
10:24:08 <quchen> There was a nice trick to add type annotations for Quickcheck. For example, if I want to test that `sort xs == sort xs`, I'll have to specify with Ord instance xs should satisfy.
10:24:20 <quchen> It was some clever 'let' binding I think.
10:24:37 <harwiltz> Thanks for the help/info everyone
10:24:43 <quchen> Does anyone know what I mean?
10:27:01 <kadoban> quchen: Talking about for use in lambdabot, or in actual code?
10:27:07 <quchen> kadoban: Actual code.
10:27:32 <quchen> Lambdabot would be nice too, but I've written quite a few "explicit sub-definitions" now for the sole purpose of specifying a type sig.
10:27:38 <quchen> I remember there was a better way.
10:28:19 <kadoban> quchen: I just give them a type annotation: propWhatever :: [Int] -> Bool   (or Property instead of Bool if I use ==>)
10:29:20 <kadoban> Oh I use that weird test framework nobody uses, "test-framework", but I would think you could do the same thing in bare quickcheck as well.
10:30:54 <quchen> Bytestring uses that :-)
10:31:26 <kadoban> Heh. I keep meaning to switch to tasty or whatever is actually supported now-a-days, but I haven't gotten around to it.
10:31:58 <bennofs> quchen: you could make a let binding asIntList :: [Int] -> [Int]; asIntList = id; and then write sort (asIntList xs), although that is not particular clever
10:32:40 <lyxia> quchen: can you give an example of problematic code?
10:32:50 <bennofs> quchen: you could also have `let _ = head xs `asTypeOf` (undefined :: Int)` to specify that xs should be an Int-List
10:33:24 * hackagebot lol 0.2.0.1 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.2.0.1 (crockeea)
10:33:50 <quchen> bennofs: Hm, sounds like the right direction. I think maybe "let _ = xs :: [Int] in (... xs)" might be what I want.  The problem with specifying the full signature of the test case is that I have to, well, do that. Sometimes it's enough to specify the type of certain ambiguous parameters.
10:36:48 <quchen> lyxia: Example code, http://lpaste.net/153824
10:37:00 <quchen> Where slowsort and heapsort are, you guessed it, Vector sorting algos.
10:37:19 <quchen> (Preparing a talk, I'm not really using Slowsort in production) ;-)
10:39:16 <ReinH> quchen: but bogosort is best sort
10:39:48 <lyxia> I see. I don't have any better idea that what you have currently :)
10:40:45 <kadoban> The best sort is that variant of bogosort that uses the many-worlds interpretation of quantum mechanics: 1) Randomly permute the input array. 2) If it's not sorted, destroy the universe.
10:40:54 <quchen> ReinH: No! I firmly believe it's not. Let me explain. Slowsort has all the properties you want from a sorting algorithm: it's easily parallelizable. It's in-place(eable). It doesn't do any comparisons twice. It's easy to explain. (!) it is guaranteed to terminate.
10:41:00 <ReinH> kadoban: heh
10:41:08 <ReinH> quchen: slowsort is bogosort.
10:41:13 <ReinH> bogosort is slowsort.
10:41:25 <quchen> ReinH: Nooo! Nononononooooo. Slowsort is much geater.
10:41:28 <quchen> ?google simplexity analysis
10:41:34 <ReinH> They are the same thing.
10:41:56 <ReinH> https://en.wikipedia.org/wiki/Bogosort
10:42:06 <quchen> No, there is a famous (and hilarious) paper that has an algorithm called slowsort as well. That's the one I'm talking about.
10:42:26 <quchen> ReinH: Prepare manial laughter once you understand the algorihtm. http://www.mipmip.org/tidbits/pasa.pdf
10:42:31 <quchen> It's an engineering marvel.
10:42:54 <statusfailed> I'm sad that sleepsort isn't mentioned here :[
10:43:06 <quchen> The whole paper is great, make sure to check the references when they are given ;-)
10:43:32 <statusfailed> quchen: "Pessimal algorithms and the simplexity of computations" ?
10:43:50 <quchen> statusfailed: "Pessimal algorithms and simplexity analysis"
10:44:00 <statusfailed> pdf: http://www.mipmip.org/tidbits/pasa.pdf
10:44:13 <statusfailed> thanks :-)
10:44:13 <quchen> I linked it above already
10:45:05 <statusfailed> oh sorry! I didn't see
10:45:05 <quchen> But yeah, that one. It's only 6 pages, and very understandable.
10:45:05 <ReinH> quchen: This paper is amazing.
10:45:05 <quchen> ReinH: Yes!
10:45:05 <quchen> And slowsort is its masterpiece.
12:47:25 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
12:47:25 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
12:47:25 --- names: list (clog funkshun alexa_ johnzorn afcondon csabahruska sz0 hsk3 circ-user-Qrq8e terrelln jakutis djapo mizu_no_oto vilislacis nkaretnikov erikd shanemikel i-amd3 veeberz pkkm Jaxan warc kritzcreek_ t0by chaosmasttter conal dm3 bluish kalail clynamen isocliff SCHAAP137 seishun bollu mceier JagaJaga tlevine uncle-j_j onegeek sword_smith andreas303 derdon fnurglewitz tgeeky nurupo Cassiopaya Discovery sphinxo zygentoma PanicSkittle eacameron wraithm mr_yogurt2)
12:47:25 --- names: list (BartAdv ddellacosta `^_^v AleXoundOS cpup mj12` python476 cstrahan haasn YP-Cloud_ demize circ-user-jWbRf Zekka geekosaur tim_s007 t7 daniel-s defanor nek0 keteim Dykam cbaines anders0 minad impure_hate chrzyki tortal raid SuperTux88 stass rbocquet divVerent zpconn__________ sewilton fall_ gothos ixian bazzle Blkt icicled whoops psacrifice harmchop mindos_cloud____ vikram_______ nolrai2 killtheliterate alanz lexi-lambda rom1504 BrianHV brezel Ferdirand)
12:47:25 --- names: list (integral Geekingfrog Kaini_ theolaurent cin dxtr teqwve lambdabot niteria bjs rjeli DigitalKiwi noexcept_ Guest62564 bananagram psftw hiratara trevorriles runeks rossberg yminsky fboyer nbouscal kipd aristid lieven tazjin Guest56576 SenpaiSilver_ mdtusz puregreen majoh Belgarion0 rcosta `0660 slaytaner doofin aarvar saruta quaestor3 sarlalia1 zariuq truncate NeverDie ChocoBar ozgura pdxleif_ doomlord proteusguy Hugehead_ oisdk__ MotoNyan hiptobecubic)
12:47:25 --- names: list (aartamonau william-s BlueRavenGT cereal_killer_ laar m4lvin tomboy65 joshc biglama adek ralu jlang0 eazar001 IMHOHOsanta fengshaun djellemah jbalint zos_ armyriad CosmicRay zxtx tag centrica firstdayonthejob nisstyre_ eddsteel statusfailed ziman mtncoder agent008 felixsch2 AntiSpamMeta shanemikel_ gnusosa garphy`aw unsymbol MitchW adlan byorgey xinming kp666 swhalen CoconutCrab zq wanderleyguima numberten juri_ jtobin marko_ verement dedgrant pranzor Wuzzy)
12:47:25 --- names: list (david_koontz Lokathor_ sm drink_soy_be addison_ sarfraz lritter altphi L8D_ Aruro happahappa Guest34101 sepp2k lancetw andreypopp__ schlicht jroesch_ SethTisue dkua aleks1 milessabin banjiewen jlyndon jjardon magically codehero carter_cloud bigs butts_butts alexlord rstone joedevivo _klm sea-gull- qguv andirc8000_ nadirs yaknyasn frelux jinblack smwangi DiabolikFreenode slaterr xivix osa1 theorbtwo Swizec rejuvyesh dsantiago danthemyth kattak kadoban valdyn)
12:47:25 --- names: list (elementalest aaronj dadaro mistermetaphor Sixmsj kgadek mattyw hackebeilchen rik316 oherrala aznashwan Thulsadum crough thimoteus djbeau Excureo nilg` Noldorin Don_John phyrex1an jle` trism jonmorehouse plutoniix _sjs magicman kurnevsky cdg dmiles mmachenry linduxed ChristopherBurg micmus raichoo disgrntld alunduil groscoe dbeacham cbm80 fizruk erkin bfcf1169b30cad5f T0BI avn Tobisl dhil kazagistar lpsmith tristero tennix jholtom tristanp_ cfricke benjamincrom)
12:47:25 --- names: list (shashwat jomg OrangeShark safrol Guest64232 rodlogic lodin- thetallguy tromp_ Xack v_g oddasat Icewing croyd darkbolt freekevin Bjarki abra0 Meow-J tzaeru statusbot simukis_ astrofog algae ksj jerin asmyers adamCS fehrenbach rui ics sku1d xnil boskone jophish tusj dgpratt YP-HW7 Philonous dsh jorr eun CurryWurst_ Elish bjobjo ziocroc sdothum PennyNeko proteusguy_ deko-pyon jrp6 MarcelineVQ wage Gurkenglas Polarina Maerten_ dented42 KeelOfSteel cic rogorido`)
12:47:25 --- names: list (mountaingoat xplat silver lyuha bjz_ mada sgflt m1dnight_ nilg robogoat IlanGodik thc202 ixti kfpratt castlelore a3Dman Yuras Walther Paks hackagebot thunderrd nathanic koz_ mach PlasmaStar badon knyppeldynan andyo l3dx slomo hackerfoo takuan srenatus lonokhov jhny SLi ent abrar vic_ zxq9 kakos pacak danvet jorj Uakh sjl_ Tehnix Rizy FreeFull heurist Ravana otto_s gfixler ahungry boj_ helozjisky John[Lisbeth] justanotheruser brotknust hucksy humanbsd Baughn)
12:47:25 --- names: list (FledRebel juhp Nivim phileas squimmy vili_ vmeson AustinMatherne bergey Ranhir nakal_ Jesin markus1189 predator117 Vorpal LnL radix lukky513 ario anoe bengt_ Brando753 bool_ gauthier_ fsvehla cdidd guampa Pokinawa keevil_ Maxdamantus prkc Nimatek garrett_1 Fullma ljhms bkolera al-damiri drmoob monochrom dexterph josephle Eiam araujo eL_Bart0- dunj3 cnr Eliel zhulikas_ sLite_ Xe kishar arw neshmi ttuegel S3bast1 jo_____ saml icedev liszt pydave6367 tippenein)
12:47:25 --- names: list (kepler1 Myrl-saki mvr_ JRHaigh asthasr jgertm fkurkowski Bez_ lpaste ircbrowse keemyb luite obiwahn case39 noctux zopsi pdgwien Schrostfutz hrnz shteou_ xou_ max-m abbe_ reem nottc cchalmers nuuit M-davidar M-Quora jix yakutori Plastefuchs m0rphism alpounet teeteewhy absence Caelum cgfbee Internet13 Cerise bencryption earthy meretrix bsermons frontendloader oberstein bsmt Guest26166 DenSchub LoganG tippeneinn kungp synthmeat Freundlich MrWoohoo undoall greeny)
12:47:25 --- names: list (dario` dextertzu amiller cceckman jmct jibi fr33domlover TommyC emmanuel_erc mauke Cetusx ThreeOfEight shesek wookiehangover Adeon Athas shadowdao brixen Amnez777 mxf qnikst c0ld- gws mjo goldfire1 liyang DANtheBEASTman Maerten tek0 bithijacker Elision fiddlerwoaroof bounb owa dicioccio Jinxit geal aerialB gipp amiri osfameron Twey Guest59455 Yaiyan tjbp Factionwars wto Tehnix` pieter tekacs Desoxy liste M-ou-se Bashmetim dustinm aaron7 shelling__ tswett)
12:47:25 --- names: list (zymurgy moop hamishmack {AS} k3d3 igniting dibblego xxpor bogdanteleaga robertk mudfog_ Shockk Liskni_si SHODAN XMunkki martintrojer jgornick Hijiri kwantam seagreen cosban Cathy koala_man agjohnst grol justin_smith _6a68 spicydonuts MelodyKH3 solidsnack Cale alang mt kaste Ulrar pchiusano prooftechnique Sigyn themagician bitemyapp Oxyd d6e OutlawStar ches negatratoron lispy leftylink tomh- mrd fmapE jre2 bitonic edwardk karshan1 Proteus1 chris2 Reyu newsham)
12:47:25 --- names: list (chaptastic joehillen arkeet mendez Fylwind dreamdust _janne rtur leather arnihermann pootler_ przembot Sorella askarpo Majiir fuziontech wizonesolutions monokqr edwtjo saiam johtso urdh squisher fergusnoble uwap japesinator ggVGc Sgeo ahihi zyla Matajon FUZxxl neobrain` JPohlmann Guest4877 cfloare cow-orker spacebug Lord_of_Life lohkey nwf tjpeden Taneb Erebe Xorlev razi1 ndeine dpower Guest12896_ chishiki Guest46433 dh lokien katymoe stasku___ mmaruseacph2)
12:47:25 --- names: list (Voldenet chelfi timrs2991 stephe xacktm SolarAquarion Guest44471 Vbitz anachrome _flow_ sisir OliPicard kjnilsson movedx carlw2 Guest33283 Enigmagic cjwelborn codebam clion ocharles_ codedmart micxjo paf31 mietek dfranke sclv bgyss dstockwell pkogan_ marcel aloiscochard TDJACR shans_ wyvern Guest34040 mankyKitty mlhmwglt kyagrd louispan Scorchin t0mb0_ alem0lars chriswk etcinit takeey vikraman avdi puzza007 KorriX TimWolla fabianvf georgew fnordbert radens Cr8)
12:47:25 --- names: list (amingoia minsky Tiktalik mirsal SegFaultAX felixsch_ Anhedonia jcreekmore sohum Raynos clahey_ mimi_vx incomprehensibly ortmage Levex rikkus jessicah` benonsoftware SoupEvil spinda radge_ sgronblo capicue esssing itscaleb si14 friden gratimax hbar_ pmade zmanian__ martingale zaquest asm89 ReinH vpetro coddinkn bernalex kqr myme dcoutts lyxia yamadapc Sonderblade gsingh93 exio4 karls barrucadu Vivek Ptival gienah jrslepak spwhitt sternenseemann __name__ kennyp)
12:47:25 --- names: list (jonrh giraffe nathyong lahwran lyddonb darthdeus thorkilnaur_ simony vigs cmn aweinstock Moyst __main__ amontez omilu Shapeshifter nore quicksilver larsen hyPiRion phaazon Jonno_FTW fryguybob lnx chattered apo_ sdx23 horatioh1 plog99 koomi svp solirc PHO keix dixie_ joachifm kier niko nopf kmicu Black-Wolf catsup Forkk ggherdov luxbock Ankhers Pamelloes Elsi jstolarek davidthomas wrengr_away t0m0 sephiap Intensity alevy Guest3764 capisce spaceships whiteline)
12:47:25 --- names: list (jamiis TallerGhostWalt sleepynate davesilva tokik zyoung sanitypassing mikeplus64 Oejet acfoltzer Tinchos RaceCondition mpark1 Guest47317 e darxun dogui gpampara cocreature MindlessDrone pm51 fractalcat sys9mm ollef folsen mitchty sivs bartavelle S11001001 cjay_ mbrcknl antoniy staffehn jzl kipras seliopou hydraz avocado jfokkan__ etrepum magbo cjh` watersoul hive-mind fold4 sokoll Tritlo noteventime Adios wagle myfreeweb cynick crank1988_ KaneTW wolfcore)
12:47:25 --- names: list (andjjj23 rofer ironChicken low-profile Lutin` jackhill isomorphismes obadz pfeyz otterdam Ewout taruti opqdonut alkabetz jimki Zemyla richi235 gdsx quuxman serutsubi donwilli1m Bane^ funrep ElderFain spill4 kosorith dschoepe ibid bergmark MasseR tumdum kvieta Johannes13 tinco nchambers dmwit _zxq9_ DrCode corne Kahva iliastsi horlicks_ maerwald Benzi-Junior Marqin zerokarmaleft Pucilowski s_e descender lamilami dan64 FireFly fionnan phuu rvncerr Fubar^ scshunt)
12:47:25 --- names: list (lf94 marens_ xanadu_ AppleJacks24 narendraj9 marienz Rembane dtulig LeaChim_ orion infinity0 klarrt pelegreno tg sajith tuple_cat dwn Ralith Tene zv yarou ahf surtn kshannon tessier reynir froztbyte Irrationality heath hongminhee levi tych0 msloma siddhu tedkornish bshelden honkfestival ckw dolio Boreeas brainpro1 cansis gniourf Guest85605 vifon imalsogreg sbjorn Dtgr Rodya stux|RC-only lokydor Xandaros Kneiva davl nicola1 benzrf peddie jb55 arianvp chirpsalot)
12:47:25 --- names: list (abh nitrix petercommand rkk eyck [swift] jnes supki mjrosenb Clint asjo huonw Drezil cyberlard hausdorff mrlase dju codebje wting julienXX pleiosaur bbee2 nikola opios kjanosz wedify rwiggins Ongy johnw zerowidth Watcher7 StoneToad tolt indiffernet code_crimes aatxe geppettodivacin majjoha otulp lassulus DustyDingo happy0 callumacrae tumdedum leino coeus irishsultan marmalodak yeltzooo albel727 stelleg catern slick dilinger tomjaguarpaw ManiacTwister Gothmog_)
12:47:25 --- names: list (Starfire Hafydd martinbjeldbak subleq ppnkk dkibi ion hanDerPeder aparent Ornedan bd_ arkarth vodkaInferno lenstr mephx ChongLi siloxid` ido dzack fingerzam ski Wamanuz2 spion Chousuke condy brolin_empey_ pnutus pharaun lstrano_ Sornaensis mrshoe nshepperd __rlp shennyg Ariadeno pi___ julmac zenzike spock kini niklasb yusukesuzuki gbarboza luzie c_wraith sevas pikajude swistak35 octo dredozubov irclogger_com joeytwiddle psyq d3lxa shwouchk maartenpi deni)
12:47:25 --- names: list (CindyLinz mpereira_ chu pyrtsa andrewsw unknownln honza_ padre_angolano pkmx besenwesen ebird tomku|two telmich inr z-nexx_ eagleflo cods M2tias stvc mads- stomp archaic joeyh_ RazorX| obcode_ syntacticNaCl mw jud nekomune int-e Madars acro Edoxile Ov3rload saurik sleblanc notdan shachaf Khisanth Deewiant skrio elgot duairc mechairo` kalloc_ Kavec orbital davean biscarch Eric1 bind woffy raek sekrit srhb Xnuk lpvb jokester ali_bush jlouis ernst topi kaol)
12:47:25 --- names: list (Profpatsch APic hsyl20 dxld tismith mnoonan tomaw tdammers ephess_ dasmith91 julm qz wedens lattenwald RouxTheDay edofic platz RageD ps-auxw Axman6 Shandy posco nexsja bgamari kloeri rootzlevel atomi rieper|net Saizan mokus bydo mtesseract2 Mandus_ Soft brisbin cross _guios Igloo_ taksuyu luis` metaf5_ ploopkazoo acommino- sujeet whaletechno mshenrick DDR vincenz thebnq da-x_ hodapp bcoppens lhynes lurker6_ naudiz burp cdk ec\ adarqui jameseb s4msung_ korayal)
12:47:25 --- names: list (jaaket pfoetche1 hemite sellout pgiarrusso eyenx xintron andromeda-galaxy d-q-d wayne hvr gseitz_ sleezd dhrosa_ ThePhoeron Ke kosmikus Laney hpc tsani_ jcurbo BigEndia1 ClaudiusMaximus luigy WhoA3 jotrk toredl Speed Natch hiredman brennie_ ddude dlundy vqrs jlewis_ mrowe xaimus_ zomg optocoup1er tnks Excedrin srcerer dakrone cheater z16 sdboyer Boney glckr kyren_ lachenmayer tero- gridaphobe suppi EvanR zeroskil1or mattp__ WzC Mr0rris0 tv Tourist rcsgns ft)
12:47:25 --- names: list (Ring0` comboy ]OLI[ wamaral niluje k1 ephemeron Akii mgaare_ selckin gargawel_ l3france xeno BillyIII Vq noplamodo aulambda jnoah fyolnish averagehat beckyconning_ jokleinn phaskell jaj RayNbow`TU H3ku hc agrif ackthet cantstanya buoto Quintasan SaidinWoT Chobbes Nik05 amatecha so caasih alphonse23_ sparr mpickering caw PotatoGim jorendorff hansihe jcp seanparsons betawaffle eikke nrw_ kaictl grandy skarn orcus @ChanServ carc kristjansson nyuszika7h borkdude_)
12:47:25 --- names: list (epitron monty mniip mero troydm shapr wtw mak` LordDeath moredhel thomas relrod zudov Reiser cursork GGMethos robtaylor zimp2 Atlanis iross xa0 Nadrieril klugez Eagle_Erwin toon Jello_Raptor danieli ricardo82 Sagi kriztw gcollins m1stermag1c nille Guest98597 andreass phadej MK_FG mudfog Simson-san hegge Klumben iphy idupree solatis xplat|work danza-cloud ajp flux Jaak Niamkik_ sbrg canta wolf_mozart carter danclien drdo nemesit|znc dpn` cschneid zph Frankablu)
12:47:25 --- names: list (stqism mikeizbicki greymalkin wjm CARAM__ mno2 TabAtkins trig-ger dmoon1221 nkpart brt1 dsop thoughtpolice drewdavis placer14 thalleralexander yorick thomie poga Bigcheese pikhq tarcwynne_ sbauman xnyhps Saimeidae ddima Ashy xaotuk stoned gabiruh ajmccluskey AlainODea NemesisD sunfun)
12:48:51 <seishun> am I missing something obvious?
12:49:18 <ReinH> seishun: where's the exercise?
12:49:31 <seishun> ReinH: http://learnyouahaskell.com/for-a-few-monads-more#making-monads at the end here
12:50:18 <hsk3> geekosaur: thanks
12:51:01 <ReinH> seishun: I don't see any exercises.
12:51:10 <ReinH> I see where it just tells you how to do some things.
12:51:12 <seishun> >We see that our monad doesn't know how to join all of the False outcomes where all coins don't land tails into one outcome. That's not a big problem, since writing a function to put all the same outcomes into one outcome is pretty easy and is left as an exercise to the reader (you!) 
12:51:19 <ReinH> Ah.
12:52:01 <ReinH> Well, the least you can get away with is an Eq constraint on the keys, since you have to be able to compare them.
12:52:16 <Cale> seishun: Any efficient way to do it will put an Ord constraint on the keys.
12:52:17 <ReinH> this means that this normalization step can't be used as a part of the monad's join or bind
12:52:37 <Cale> (Well, or something at least as difficult to satisfy...)
12:52:45 <ReinH> basically the algorithm with Eq is to compare each item from list a with each item from list b, combining the probabilities of like keys
12:52:55 <ReinH> This is obviously inefficient
12:53:26 <ReinH> the efficient way is similar to what you already suggested, which is why it requires an Ord constraint.
12:53:55 <seishun> I see, thanks
12:54:22 <ReinH> I wouldn't necessarily call this exercise "pretty easy", and I strongly dislike it when teaching materials do so
12:54:36 <ReinH> because then anyone who struggles with it will think that they are deficient
12:54:41 <ReinH> when really it's just not a very easy problem at all
12:55:07 <ReinH> certainly it isn't easy to solve efficiently
12:55:11 <geekosaur> more reasons to be annoyed about lyah...
12:55:16 <ReinH> geekosaur: yep
12:56:48 <ReinH> seishun: And yes, in a professional setting I would immediately reach for Map.unionWith, so you are not wrong.
12:58:04 <seishun> <ReinH> this means that this normalization step can't be used as a part of the monad's join or bind <-- you mean if I don't introduce a constraint?
12:58:30 * hackagebot overloaded-records 0.2.0.0 - Overloaded Records based on current GHC proposal.  https://hackage.haskell.org/package/overloaded-records-0.2.0.0 (PeterTrsko)
12:59:28 <ReinH> seishun: I mean that you *can't* introduce the constraint into the Monad interface.
12:59:29 <Cale> seishun: There is no constraint in the type of (>>=)
13:00:01 <Cale> There's nothing you can do about that, short of redefining the Monad type class, and breaking compatibility with everything that already works with the existing Monad class.
13:00:21 <ReinH> see: http://stackoverflow.com/questions/379546/restricting-a-monad-to-a-type-class
13:00:59 <seishun> so is this exercise impossible then?
13:01:05 <ReinH> No, it is possible to write the function.
13:01:17 <seishun> oh
13:01:18 <ReinH> It is not possible to use the function in the definitions of the Monad type class methods.
13:01:25 <seishun> I see
13:01:27 <ReinH> e.g. you can't make join more efficient in this way
13:01:41 <ReinH> rather, you can't make join normalize
13:02:00 <ReinH> you can normalize as a separate step, outside of the Monad interface, but it cannot be done automatically by join or bind.
13:02:21 <ReinH> precisely because you can't make join or bind take on the necessary constraint.
13:03:07 <ReinH> There are some workarounds presented in the SO answers, but they are well outside the scope of the "exercise"
13:03:20 <ReinH> (And if you wanted a probability monad, you would just use one of the existing ones)
13:05:28 <ReinH> I use scare quotes because exercises should further the understanding of the subject matter at hand, and this exercise has nothing to do with monads per se.
13:05:48 <seishun> indeed
13:05:52 <ReinH> So to the extent that LYAH has exercises, they are bad exercises, which modifies my original "LYAH doesn't have exercises" statement.
13:06:19 <ReinH> seishun: If you want a better introduction to Haskell and you are willing to pay for it, I highly recommend http://haskellbook.com.
13:06:59 <ReinH> If not, I recommend the resources recommended by https://github.com/bitemyapp/learnhaskell (bitemyapp is the author of the book as well)
13:07:51 <ReinH> (coauthor)
13:13:00 <isd> Hey. So I'm playing around with template haskell & quasi quotes for the first time. Can anyone tell me (or point me to documentation) how quoteFile decides where to look for the named file?
13:14:05 <sphinxo> How can I parse strings into a gadt that has a kind signature like * -> * ?
13:14:48 <sphinxo> do I have do to like expr :: Parser (Expr a)
13:15:56 <johnw> Parsing will be rather tricky
13:16:14 <sphinxo> for reference my ast looks like http://lpaste.net/7266188738949021696
13:16:27 <johnw> the index has to be sufficient to "decribe" the possible outcomes of "expr"; it can't just be abstract
13:17:00 <johnw> for example: Parser (Expr (Either One Two))
13:17:17 <seishun> ReinH: thanks, will take a look (although I generally prefer to figure out stuff on my own once I'm comfortable with the fundamentals)
13:17:24 <johnw> this would be a parser that might return either an Expr One or an Expr Two; and you'll need the accompanying constructions and projections
13:17:34 <ReinH> seishun: Well, how do you plan on becoming comfortable with the fundamentals? :)
13:18:14 <geekosaur> isd, per the source it just uses readFile, so the pathname will be relative to the directory you are in when you run ghc. (if using cabal/stack you'll need to find out what directory they run ghc from)
13:18:15 <johnw> sphinxo: effectively what you're asking to do is to lift runtime knowledge into something that can be reasoned about at compile-time, before runtime occurs; thus, you'll need to exhaustively describe the possibilities in order for things to type check
13:18:23 <sphinxo> ooh
13:19:22 <seishun> ReinH: I think lyah covers them, doesn't it?
13:19:51 <ReinH> seishun: Not very well, as you've seen.
13:20:05 <ReinH> Most people seem to finish LYAH and then wonder how they would learn how to write real Haskell programs.
13:20:20 <ReinH> But if it's working for you, great.
13:20:20 <sphinxo> so say something to return Lit True if it finds "True" and Lit False if it finds "False"?
13:20:23 <ReinH> Just want you to have options.
13:20:27 <sphinxo> How would I implement that?
13:20:35 <tdammers> that's where I'd recommend Real World Haskell, and also stephen diehl's "what"
13:20:43 <tdammers> @where what
13:20:43 <lambdabot> I know nothing about what.
13:20:47 <tdammers> pity
13:21:07 <johnw> sphinxo: you'd write the parser as normal, matching on the input; but your type index will need to express the match by using an Either
13:21:13 <tdammers> http://dev.stephendiehl.com/hask/
13:21:23 <ReinH> +1 for Diehl's thing.
13:22:17 <sphinxo> johnw: so just like Parser (Expr Bool) ?
13:22:38 <johnw> yeah, exactly
13:22:42 <sphinxo> Great thanks
13:22:59 <johnw> the "Bool" communicates to the type checker that there are two possible paths the parser might have taken
13:23:03 <johnw> but Expr a communicates no information at all
13:23:43 <isd> geekosaur: thanks.
13:24:43 <hsk3> Why doesn't this compile? https://pastee.org/fsq6u
13:24:43 <hsk3> But this does compile? https://pastee.org/6cv5m
13:24:44 <hsk3> The only difference is the spacing of the last two lines.
13:24:45 <hsk3> What's wrong with the spacing in the first example?
13:24:55 <hsk3> Haskell spacing confuses me. Any good rule of thumb that's always going to work?
13:25:15 <benzrf> hsk3: i'll take a look
13:25:16 <ReinH> hsk3: the end of the where introduces a new scope
13:25:23 <benzrf> uh, nvm :)
13:25:31 <ReinH> hsk3: The indentation of the function definition must exceed that of the surrounding scope
13:25:36 <ReinH> so it must be indented past the where
13:25:41 <ReinH> @google haskell wiki layout
13:25:43 <lambdabot> https://wiki.haskell.org/Template_Haskell
13:25:47 <ReinH> Uh no.
13:25:54 <sm> it must be indented past "gameLength"
13:25:55 <ReinH> @google haskell wiki indentation
13:25:56 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
13:26:16 <hsk3> ReinH ah of course. gameLength is the function!
13:26:17 <ReinH> Past the beginning of gameLength, to be the most specific. :)
13:26:31 <ReinH> Of course the haskell wiki page on layout isn't titled layout.
13:26:51 <ReinH> I guess indentation is more commonly searched for
13:27:02 <geekosaur> so the general rule is that the continuation of something must be indented beyond the start of that something.
13:27:02 <ReinH> and that people who already know about layout probably already know about layout.
13:27:15 <ReinH> yeah that's a good way to say it
13:27:23 <sm> +1
13:27:26 <geekosaur> there are specific exceptions (notably the contents of a "do" don't have to be indented past the "do")
13:28:17 <sm> true, I'd like to see a list of those exceptions
13:28:51 <sm> if they're not called out, I think they probably contribute to this confusion
13:28:56 <geekosaur> indentation of do bodies, and DoAndIfThenElse iirc
13:29:43 <geekosaur> the former they considered making it an extension and then decided it wasn't worth it because all existing compilers at the time also supported it without an extension, and DoAndIfThenElse is an extension but turned on by default
13:30:06 <geekosaur> (without DoAndIfThenElse you would need to indent "then" and "else" relative to the "if")
13:30:58 <geekosaur> (when the do body thing was discussed, nhc98 was on the way out, hugs was still current, and uhc and yhc were both still somewhat active iirc)
13:31:05 <sm> I thought you did! I have been!
13:31:17 * sm glares at DoAndIfThenElse
13:32:14 <Cale> Well, the actual rule is that there are a handful of layout keywords (the ones in standard Haskell are "let", "do", "of" and "where"). The first non-whitespace character following a layout keyword sets the indentation level for the block. Subsequent lines which start in a column shallower than that will close the block. Lines which start in the same column have semicolons inserted between them. Lines which start in a d
13:32:14 <Cale> eeper column do not (and so act as a continuation of the previous line).
13:32:37 <sm> does then/else need to be more indented than if when not following a do keyword ?
13:32:40 <Cale> DoAndIfThenElse is an abomination designed to let people not learn how to indent things correctly :P
13:33:22 <geekosaur> sm, only needed when inside something controlled by one of the layout keywords Cale mentioned
13:33:31 * hackagebot orgmode-parse 0.1.1.3 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  https://hackage.haskell.org/package/orgmode-parse-0.1.1.3 (ParnellSpringmeyer)
13:33:34 <geekosaur> that saids, *most* things will be inside one of those...
13:33:36 <Cale> It's just that if an if/then/else expression is occurring in a do-block, then it needs to occur on a single line of the do-block.
13:33:53 <sphinxo> johnw: So i'm struggling to parse a my list type http://lpaste.net/5458849741829832704
13:34:04 <sm> I'm looking at https://prime.haskell.org/wiki/DoAndIfThenElse
13:34:08 <sphinxo> Couldn't match type ‚Äòt‚Äô with ‚Äò[t2]‚Äô
13:34:24 <Cale> So, you can't put the 'then' or the 'else' at the same column as the 'if' typically, because that will mean that a semicolon goes in the middle of your if-expression.
13:34:26 <sm> where if and else are aligned.. will that work in a pure function too ?
13:34:29 <geekosaur> but it's in a `do` that you are most likely to be trying to use it in `procedural statement style` instead of as an expression
13:34:32 <sm> ughh
13:34:42 <johnw> sphinxo: one sec, on the phone
13:34:52 <Cale> sm: It will work, but it's awful.
13:34:53 <geekosaur> in a pure expression, you can indent them any way you want
13:35:06 <ReinH> well, not quite ANY way
13:35:07 <geekosaur> (well, provided you don;t go outside the expression into any containing layout)
13:35:22 <ReinH> sorry
13:35:25 <Cale> Basically, you *ought* to align the 'then' and 'else' with each other and start them in a deeper column than the 'if' *anyway*
13:35:26 <geekosaur> heh
13:35:32 <geekosaur> I knew that complaint was coming :)
13:35:49 <ReinH> geekosaur: Well Actually as a Service
13:35:56 <Cale> So DoAndIfThenElse only exists to help people write things sloppily.
13:36:28 <hsk3> Cale: how to disable DoAndIfThenElse?
13:36:41 <geekosaur> LANGUAGE NoDoAndIfThenElse
13:37:00 <geekosaur> in pragma braces of course {-# #-}
13:37:44 <purelazy> Is the \ a typo in "bang \<- readIORef test" near the top of https://downloads.haskell.org/~ghc/5.04.2/docs/html/base/System.IO.Unsafe.html
13:37:44 <Profpatsch> I‚Äôve got a simple HTTP server with WAI, which shells out render a static folder on every request.
13:38:20 <Profpatsch> I‚Äôd like to create some kind of cache, so that the shellout is only done once a minute or so.
13:39:20 <Profpatsch> Enough to always display the newest file when I need it, but not for every file one pageload needs.
13:39:21 <Cale> purelazy: You're looking at some very old documentation, and yeah, that's a typo.
13:39:46 <Profpatsch> What should I use to implement that?
13:39:50 <sphinxo> johnw: any ideas what i'm doing wrong?
13:40:14 <sm> how about https://hackage.haskell.org/package/wai-middleware-cache-0.3.6
13:40:29 <hsk3> Cale:    {-# NoDoAndIfThenElse #-}     is something you recommend in every source file to avoid sloppy code?
13:40:39 <purelazy> Cale: Why is it old? I googled Data.IORef and it came top
13:40:54 <johnw> sphinxo: on phone
13:40:59 <Cale> GHC 5.04.2 is from December 2002
13:41:24 <geekosaur> hsk3 {-# LANGUAGE NoDoAndIfThenElse #-}
13:41:34 <hsk3> yeah that, sorry
13:41:37 <geekosaur> wooooow
13:41:42 <Cale> purelazy: whaaaat
13:41:45 * geekosaur just got that haddock loaded
13:42:06 <geekosaur> purelazy, don;t use google to find programming language documentation
13:42:10 <Cale> purelazy: If I google Data.IORef, I get a bunch of results, but the top one is https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html
13:42:26 <Cale> which is indeed, that package in the latest base
13:42:36 <Cale> er, that *module* in the latest base
13:42:38 <geekosaur> google will show you by default things that have lots of links --- which usually means osmething that has been around long enough to gather that many links
13:42:56 <geekosaur> (and Cale, if you are logged into google, it's tailoring your search results :)
13:43:05 <Cale> Yes, that's true, but still...
13:43:14 <Cale> https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html
13:43:21 <geekosaur> anyway googlimng stuff in haskell or perl or python invariably gets me ancient cruft
13:43:35 <geekosaur> (but that;s usually good enough for me to find the modern one...)
13:43:42 <purelazy> Cale: Sorry, just a figure of speech - I actually duckducked Haskell IORef 
13:43:55 <Cale> ah, well, there you go ;)
13:44:17 <purelazy> Cale: I should be using Hoogle then?
13:44:34 <geekosaur> purelazy, for comparison, the current ghc is 7.10.3 with 8.0.1 due in the next month or so, and its base is 4.8.2.0
13:44:41 <geekosaur> 5.04 is o.O
13:44:43 <sm> "Hackell IORef" at duckduckgo.com got me the same up to date link
13:44:51 <Cale> You could. I actually don't mind google very much for looking for Haskell documentation, but you do have to be careful about which version of things you get though.
13:44:55 <sm> er, "Haskell IORef"
13:45:35 <Cale> Usually it'll get you to the right package, and then you'll want something like this Chrome extension to tell you when there's a newer one https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf?utm_source=chrome-app-launcher-info-dialog
13:45:41 * sm wishes hackage magically boosted the search juice of latest haddocks and vice cersa
13:45:43 <hsk3> Cale, ?
13:45:48 <geekosaur> (ghc 6.6 was current literally 10 years ago when I started learning Haskell)
13:46:01 <Cale> hsk3: ?
13:46:12 <geekosaur> sm, they try, google documents a bunch of things and many of them have been tried and don't work
13:46:19 <Cale> I started on 5.02.x
13:46:23 <sm> ah, good to hear
13:46:24 <hsk3> Cale, i was just wondering whether you think
13:46:24 <hsk3> {-# LANGUAGE NoDoAndIfThenElse #-}
13:46:25 <hsk3> is a good idea in every Haskell source file, to avoid sloppy coding.
13:46:25 <geekosaur> I think the one that has been found to work is hard to do with the way haskell documentation is built?
13:46:27 <Cale> (can't remember which)
13:46:35 <Cale> hsk3: Nah, just don't do it.
13:46:38 <hsk3> heh ok
13:50:13 <tinco> I'm getting a bit stuck with stack on ubuntu
13:50:37 <tinco> it keeps saying this: GHC version mismatched, found 7.8.4 (x86_64), but expected version 7.10.3 (x86_64) (based on resolver setting in /home/phusion/Source/nanc/stack.yaml). Try running stack setup
13:50:48 <tinco> but running stack setup doesn't fix it
13:53:02 <Cale> tinco: Not that I know much about stack, but what command did you run to get that message?
13:53:07 <tinco> if I run stack setup it says it's downloading and installing a ghc, but stack build afterwards still doesn't do anything
13:53:15 <Cale> Are you trying to start ghci, or build?
13:53:16 <tinco> just `stack build`
13:53:21 <hsk3> Cale: you think "in" after a "let" should also not match with the "let"? (In a similar way as you say "then" and "else" should not match with "if"?
13:53:30 <sm> tinco: you probably need to check your $PATH
13:53:41 <hsk3> s/not match/have more indentation
13:53:58 <sm> run ghc --version, type -a ghc, etc.
13:54:07 <Cale> hsk3: I admit that sometimes I will line those up. I think indenting the 'in' by a single additional space looks nice.
13:54:14 <mniip> ew
13:54:22 <Cale> let u = v
13:54:25 <geekosaur> hsk3, on the one hand it should be indented, on the other hand in many cases when it would matter you are in a `do` and can just leave off the `in` entirely
13:54:27 <Cale>  in u * u
13:54:32 <geekosaur> (because `let` is already special in `do`)
13:54:37 <mniip> let introduces 2 layout blocks
13:54:45 <luigy> tinco what version are you on?
13:54:50 <Cale> mniip: It doesn't really.
13:54:51 <geekosaur> but I indent let/in the same way Cale does in practice
13:55:04 <tinco> sm: what should be in my path?
13:55:04 <mniip> let
13:55:04 <mniip>         u = v
13:55:04 <mniip>     in
13:55:04 <mniip>         u * u
13:55:10 <luigy> I feel like those kind of issues were resolved after > 1.0
13:55:11 <Cale> mniip: wtf?
13:55:23 <tinco> there's a reference to /opt/ghc/7.8.4
13:55:38 <hsk3> Cale: not sure about the one space. isn't it better to standardize one's code at something like 4 spaces
13:55:40 <hsk3> keep it consistent
13:55:50 <tinco> if I move that one so I don't have a ghc anymore it says: No GHC found, expected version 7.10.3
13:55:53 <mniip> Cale, I'm one of those people who use tabs ;)
13:55:54 <sphinxo> johnw: so like the lambda parse would be something like lam :: TypeOf t => Parser (Expr (String -> t -> Expr (t -> t)))
13:55:56 <Zekka|Sigfig> hsk3: Haskell code is more commonly indented to 2 spaces or ‚Äúhowever many spaces it takes to line up"
13:56:03 <tinco> even though it says it just installed a new one, so yeah I think I'm definitely missing something in my path :P
13:56:07 <sm> tinco: ideally, "ghc --version" will report 7.10.3
13:56:21 <Cale> hsk3: I have my tab key insert 2 spaces, but I don't really care what column things line up in so long as it's the right one ;)
13:56:33 <Cale> Being a multiple of 4 or whatever isn't important.
13:56:46 <tinco> sm: but stack should install that for me right?
13:56:49 <hsk3> heh ok
13:56:52 <sm> or if not that, at least stack exec -- ghc --version should
13:56:58 <Cale> mniip: You really shouldn't.
13:57:01 <johnw> sphinxo: TypeOf t => t isn't informative enough
13:57:03 <Cale> mniip: (use tabs)
13:57:19 <sm> also after removing something that was in your path, you need to do "hash ghc" - that might reveal the correct one
13:57:32 <sm> (if both were in the path)
13:57:32 <tinco> mniip: I'm with you bro :) -Fno-warn-tabs ;)
13:57:56 <sphinxo> johnw: ohh :( so I have to write different varients for the different types?
13:58:03 <Cale> I honestly think we should just make tab characters in source code a lexical error, just like vertical tabs
13:58:09 <sphinxo> s/varients/variants
13:58:17 <ReinH> I'd be happy with -Fno-warn-tabs, as long as it isn't the default. People who want to use tabs should be allowed to do so. Caveat implementor, etc. People who don't know any better should be helped.
13:58:37 <Zekka|Sigfig> Tabs are fine as long as you don‚Äôt use them by accident!
13:58:41 <Zekka|Sigfig> Then they‚Äôre Satan
13:58:56 <johnw> sphinxo: yes, it's needs to be an expressive type
13:59:02 <Cale> Tabs are fine so long as nobody else has to see your code.
13:59:12 <Cale> and then they're evil
13:59:37 <tinco> the whole idea of using is tabs is that your code is as pretty as whoever looks at your code wants it to be
13:59:43 <tinco> but ok :P
13:59:53 <ReinH> heh
14:00:07 <ReinH> Which is a problem in Haskell.
14:00:10 <Cale> tinco: In Haskell, it matters which column things start in.
14:00:22 <ReinH> Which, on that reasoning, means that tabs are bad in Haskell by design.
14:00:36 <tinco> that makes no sense at all
14:00:45 <tinco> what does that have to do with tabs?
14:00:45 <ReinH> Adjusting the tab stop causes problems in Haskell
14:00:46 <Cale> You can make code which looks like it does one thing when viewed with 4 space tabs, but does something else when compiled (because the compiler assumes that tabs align to the next multiple of 8)
14:00:52 <ReinH> That's why the warning exists
14:01:06 <ReinH> So the goal of letting people adjust tab stops is in direct opposition to the goal of using tabs correcly in Haskell
14:01:30 <tinco> can you give me an example of such a program?
14:01:40 <ReinH> Yes.
14:02:02 <sphinxo> johnw: but i'm probably going to need some generalized parseExpr fn that'll do like lit <|> var <|> lam
14:02:49 <Cale> If your Haskell source files contain tabs, your editor should be set to have tabstops at multiples of 8
14:03:15 <sphinxo> right?
14:03:32 <hsk3> tab space flamewar lulz
14:03:33 <sphinxo> or some like partial function
14:03:33 <tinco> Cale: my tabstops are at 2
14:03:46 <tinco> I've never experienced any unexpected behavior..
14:03:51 <Zekka|Sigfig> tinco: el diablo!!!!!
14:03:55 <Cale> tinco: So are mine, but my editor is set to expand tabs to spaces automatically.
14:04:01 <tinco> yeah mine isn't :P
14:04:32 <sphinxo> This is the consequence of rigorous typing 
14:04:39 <ReinH> tinco: absense of evidence is not evidence of absense or something
14:05:03 <Cale> tinco: Well, you'd *probably* have to be malicious to get compiling programs with weird behaviour, but it's easy to get into a position where the program looks fine but won't compile.
14:05:10 <ReinH> I generally find that the consequence of rigorous typing is rigorous thinking.
14:05:23 <sphinxo> Boys n girls don't use an ast with which is a gadt and has a  kind sig if ya want to parse it
14:05:27 <johnw> sphinxo: what you should end up with is that for parse :: Parser (Expr ?A), your ?A is going to end up being the parse tree that you parsed
14:05:30 <tinco> Cale: if it were easy to get it into a state where it won't compile wouldn't that have happened by now?
14:05:48 <Zekka|Sigfig> tinco: I‚Äôve had it happen but only in projects that intermixed spaces
14:05:54 <sphinxo> template haskell? :)
14:05:54 <johnw> sphinxo: where the *type* that goes into ?A must be capable of describing any parsable tree
14:05:54 <tinco> yeah of course
14:05:56 <Cale> tinco: I don't know -- there are ways that you can awkwardly adjust the style in which you write code to try to avoid problems.
14:06:05 <tinco> but mixing spaces and tabs is the most evil thing in the world :P
14:06:08 <mniip> 1456869489 [00:58:09] <Cale> tinco: In Haskell, it matters which column things start in.
14:06:11 <Cale> tinco: But it's generally awkward.
14:06:14 <Zekka|Sigfig> the theoretical case is that you indented your whole file with tabs and accidentally indented one line with spaces
14:06:17 <mniip> that's not a problem if you do tabs right
14:06:19 <Zekka|Sigfig> then Haskell will parse that line as a dedent
14:06:34 <Cale> mniip: Yeah, to "do tabs right" you have to make your code look awful :P
14:06:38 <mniip> no?
14:06:44 <Zekka|Sigfig> If your editor never ever does spaces then that won‚Äôt be a problem for you!
14:06:53 <Cale> Putting newline after 'let' is pretty bad.
14:07:04 <mniip> not really?
14:07:05 <sphinxo> johnw: so how on earth do I do this?
14:07:07 <tinco> :D
14:07:10 <johnw> sphinxo: you shouldn't
14:07:24 <tinco> this is where I admit I never have more than 1 assignment in a let...
14:07:35 <sphinxo> oh, i guess my language will stay unparsed
14:07:48 <johnw> just don't use a GADT here
14:07:50 <sphinxo> any changes I can make to simplify things?
14:08:02 <johnw> I mentioned GADTs to answer someone else's question
14:08:08 <Cale> tinco: anyway, it's super easy to make just about any worthwhile text editor expand tabs to spaces
14:08:16 <sphinxo> yeah :\
14:08:19 <Cale> tinco: So just turn that option on, and people won't hate you
14:09:20 <Cale> (you can generally get it to treat multiple spaces as if they were a tab as well)
14:10:02 <Cale> So the only difference is that people see your code like you intended it to be seen (which is probably best).
14:10:14 <tinco> Cale: if I'd conform so easily to peoples preferences I wouldn't be using Haskell at all ;)
14:10:56 <Cale> Having the tabs look different from how they looked for you is not going to make anyone else happy.
14:11:19 <Cale> and it's not like the "data compression" of representing multiple spaces by a tab is significant
14:11:40 <sphinxo> johnw: would it help if I used a parser generator instead?
14:11:43 <Cale> So there's pretty much no good reason to use tabs, and if they get mixed up with spaces, they can cause all sorts of issues.
14:11:57 <Cale> (as they generally will, given enough editing)
14:12:23 <sphinxo> or am I just throwing things at things hoping it'll fix things
14:14:28 <sphinxo> i'll take that as a yes
14:16:03 <johnw> (still on phone)
14:16:46 <sphinxo> ahh ok
14:18:33 <jacereda> hi... let's say I have a GLUT replacement and I want to put a wrapper on top of that to turn a callback-based API (where the user provides a callback to handle the different event types) into something friendlier. What would that wrapper look like? would it be something returning a lazy [Event] or something like that? 
14:18:47 * hackagebot vulkan 1.5.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.5.0.0 (jophish)
14:21:00 <jacereda> well, to be more concrete, this is what the current API looks like: https://github.com/jacereda/hglcv/blob/master/src/Graphics/UI/GLCV.hs and a silly example https://github.com/jacereda/hglcv/blob/master/app/Main.hs
14:21:42 <tinco> ok turns out my problems with stack were because I was using an old version
14:21:57 <tinco> that was incompatible with the lts-5
14:22:12 <luigy> exactly ;) [16:54:47]  <luigy>	I feel like those kind of issues were resolved after > 1.0
14:23:30 <tinco> oh sorry luigy I guess I missed that one :P
14:23:45 <johnw> sphinxo: ok, I'm back now for real
14:23:52 <tinco> I got distracted by the lure of tab space wars :P
14:24:00 <johnw> sphinxo: are you just wanting to represent and parse an untyped lambda calculus?
14:24:03 <luigy> lol :)
14:24:27 <sphinxo> johnw: a typed lambda calculus
14:24:50 <sphinxo> I've got the eval part nailed
14:24:56 <johnw> so, the fact that the lambda calculus is typed doesn't mean you have to use Haskell's types to represent them
14:25:07 <sphinxo> That's very true
14:25:14 <johnw> data Type = TBool | TNat | ...
14:25:22 <sphinxo> I have a gadt
14:25:31 <sphinxo> http://lpaste.net/3690668532778926080
14:25:54 <johnw> even that is more complicated than you need
14:26:05 <johnw> your GADT is provided a denotation for your types into Haskell types
14:26:15 <johnw> but only the type checker needs to care about your types
14:26:33 <johnw> as long as a lambda wanting TBool gets a TBool, all is fine
14:26:45 <sphinxo> Well I was using haskells typechecker as my own :)
14:26:49 <johnw> what a TBool *means* is internal to your language
14:26:51 <johnw> ah, I see
14:27:11 <johnw> I'd suggest writing your own typechecker
14:27:18 <sphinxo> johnw: ahh ok
14:27:26 <sphinxo> that sounds fun
14:27:41 <johnw> first do it without type variables (polymorphism)
14:27:58 <sphinxo> oh ok
14:28:25 <johnw> then add them after :)
14:28:33 <johnw> dealing only in concrete types will make it all very easy
14:28:51 <sphinxo> johnw: yes I imagine so
14:28:54 <johnw> unification is basically then just Eq on your Type type :)
14:29:18 <sphinxo> this is how I was doing it before http://lpaste.net/8922734565336809472
14:29:37 <johnw> yeah, that looks good
14:30:00 <johnw> props for using Maybe's fail in a clever way :)
14:30:07 <sphinxo> thanks :)
14:30:23 <johnw> I keep meaning to write a blog article on dumb Maybe parsers based on fail...
14:30:54 <sphinxo> that sounds interesting
14:31:16 <sphinxo> How would that work?
14:31:35 <johnw> you'd use <|> and pattern matching
14:31:50 <johnw> for simple inputs, it's a pretty economical
14:32:37 <sphinxo> and like the "Parser" ?
14:32:48 <johnw> kind of
14:32:49 <johnw> example:
14:33:29 <johnw> oops, don't have my example, it was written for a client and is gone now
14:34:19 <sphinxo> you do haskell consulting? awesome
14:34:40 <shanemikel> I'm having a problem understanding lazy IO
14:35:06 <shanemikel> specifically.. when I do `stuff <- readFile myfile`
14:35:12 <shanemikel> and `putStrLn stuff`
14:35:23 <geekosaur> putStrLn is the easy one. readFile is downright nasty
14:35:55 <johnw> shanemikel: it helps to think of it like asynchronicity
14:36:04 <johnw> readFile returns immediately, but the work hasn't been done yet
14:36:07 <shanemikel> yeah, I don't understand how this works when the type for putStrLn is String -> IO (), not some sort of string buffer
14:36:34 <johnw> putStrLn "demands" the work be done
14:36:40 <shanemikel> and I'm half expecting it to invoke putStrLn once for each line, or whatever the buffer size is
14:37:04 <johnw> @src putStrLn
14:37:04 <lambdabot> putStrLn s = do putStr s; putChar '\n'
14:37:10 <johnw> @src putStr
14:37:10 <lambdabot> putStr s = hPutStr stdout s
14:37:14 <johnw> @src hPutStr
14:37:14 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
14:37:18 <geekosaur> putStrLn is an IO action. it doesn't actually do anything, you can think of it as an opcode for the Haskell runtime. you chain these opcodes together to produce a sequence of type IO () which is the result of main; the runtime then gets the opcodes and executes them
14:37:30 <johnw> well, one of these is recursive at some point, demanding each character from the input before it is printed
14:38:09 <johnw> but yeah, geekosaur is right, there's a difference between the value resulting from the Haskell function, and what the runtime does with that value
14:38:47 <hefesto> hi :) Ive been trying to solve a problem on my code for like 2 hrs now and I havent been able to solve it :( http://lpaste.net/8521249320383545344
14:38:51 <geekosaur> so the action is "hidden" inside the IO () and you can't see it or do anything with it except hook it into another IO action, and hook that into another IO action, and ultimately hook that into main :: IO a
14:39:46 <hefesto> my main way to Try to solve it is using a where clause and trying to take just the things that I whant from "getBy" 
14:39:47 <ReinH> shanemikel: I recommend http://www.vex.net/~trebla/haskell/IO.xhtml and https://www.haskell.org/tutorial/io.html
14:40:24 <dmwit> shanemikel: `String` *is* some sort of string buffer.
14:40:47 <ReinH> Well, String *is* [Char]. If that's a string buffer then sure.
14:40:51 <geekosaur> hefesto, I don;t think anyone can help without knowing what those things you are calling are
14:41:21 <dmwit> shanemikel: Inasmuch as laziness means that later parts of a `String` are not "computed" until they're needed.
14:41:48 <jacereda> geekosaur: does that mean IO is a free monad? and does that mean I can write an alternative interpreter? 
14:41:50 <dmwit> shanemikel: However, in this particular case things are being complicated by `readFile` doing some sneaky things under the covers to make it look like you're computing later parts of the `String` later.
14:42:31 <sphinxo> johnw: just to say thanks
14:42:34 <hefesto> geekosaur: sorry. my complete code would be https://github.com/hhefesto/communis-api/blob/master/src/Model.hs
14:42:35 <sphinxo> i'm going to bed now
14:42:40 <shanemikel> I guess my bigger issue is, with the laziness.. the execution of the IO function that gets data will literally get interleaved with the execution of whatever function used the value.. so If my IO -> String function is computationally expensive.. and I'm using the result in a timing-sensitive function or IO action, I should actually think about the execution of both functions as being interleaved, and if I want it to simplify the reasoning about
14:42:40 <shanemikel> execution, i should do something like `fmap id result` before use?
14:42:53 <geekosaur> jacereda, if you could replace the runtime then yes.
14:43:06 <jacereda> geekosaur: oh, I see...
14:43:08 <shanemikel> does this strangeness become a bigger problem for you people often when you're stringing together separate monadic computations?
14:43:16 <geekosaur> however the runtime is kinda deeply tied into ghc, so in practice not (and the ghc folks rather wish it were less tight)
14:43:19 <dmwit> shanemikel: Correct. And that interleaving nastiness is why people often use conduits or pipes instead of the standard "bad" lazy IO.
14:43:25 <dmwit> shanemikel: `fmap id result` is not helpful.
14:43:55 <dmwit> shanemikel: However, you may like the `strict` package:
14:43:57 <dmwit> ?hackage strict
14:43:57 <lambdabot> http://hackage.haskell.org/package/strict
14:44:22 <ReinH> A fair amount of machinery has been employed in the pursuit of non-lazy IO
14:44:28 <ReinH> @hackage pipes
14:44:28 <lambdabot> http://hackage.haskell.org/package/pipes
14:44:29 <ReinH> and etc
14:44:35 <ReinH> Often you don't need this. Sometimes you do.
14:44:56 <AlphaAtom> okay so im very new to haskell, why do my variables seemingly get re-evaluated everytime I use them?
14:45:08 <ReinH> AlphaAtom: Can you give an example?
14:45:13 <AlphaAtom> ya one sec
14:45:18 <dmwit> shanemikel: Of course the other approach is to just avoid the lazy IO functions like `readFile`, `writeFile`, `getContents`, etc.
14:45:21 <ReinH> @where lpaste -- AlphaAtom
14:45:21 <lambdabot> http://lpaste.net/
14:46:02 <AlphaAtom> http://lpaste.net/4886925063401504768
14:46:09 <ReinH> (You can do strict IO without (something like) pipes, but then you often run into memory use problems, and then you solve them with pipes.)
14:46:26 <jacereda> I guess pipes are also the answer to my previous question on how to provide a good API to a callback-based C library, but can anyone confirm that?
14:46:36 <AlphaAtom> what seems to be happening is for everytime I use arg1, it re-does the evalA
14:46:55 <shanemikel> is pipes built on posix ipc?
14:47:00 <dmwit> jacereda: gtk2hs is a big library that provides a good API to a callback-based C library, and doesn't use anything like pipes.
14:47:09 <shanemikel> or is it haskell native
14:47:09 <ReinH> AlphaAtom: how do you observe that it re-does the evalA?
14:47:17 <dmwit> pipes is not built on IPC at all.
14:47:27 <dmwit> It's all in a single process, no need for IPC.
14:47:32 <shanemikel> oh, great
14:47:38 <jacereda> dmwit: how? cooperative threads?
14:47:44 <AlphaAtom> so, different constructors of evalA consume tokens, and by the end two tokens have been consumed, where only one should have been
14:48:12 <dmwit> jacereda: No, -threaded is fully supported.
14:48:40 <dmwit> jacereda: I wasn't here for the setup to the question, but you may like to look through http://dmwit.com/gtk2hs which discusses threading in GHC and gtk2hs.
14:48:44 <geekosaur> jacereda, the "pipes" are conceptual data flow, not interprocess/thread/whatever communication
14:48:48 <ReinH> AlphaAtom: So this is a question about the behavior of the function, not about the behavior of the haskell runtime when evaluating things?
14:49:27 <jacereda> dmwit: great, thanks
14:49:52 <ReinH> AlphaAtom: Can you give me an example of an input, an expected output, and the actual output? I'm not quite following.
14:50:04 <AlphaAtom> yeah let me get you a proper paste with some more info
14:50:29 <ReinH> AlphaAtom: sounds good thanks
14:50:44 <shanemikel> I usually associate the idea of pipes with laziness.. so are these lazy as well, just in a more explicit way?
14:51:21 <Profpatsch> I wonder why there is no instance (Show a) => PrintfArg a
14:52:20 <jacereda> geekosaur: yes, I think I get that, but I was wondering how to provide a good interface that doesn't require State. For instance, it's quite normal to want to know whether a certain key is pressed from inside the mouse callback, I was wondering if something like FRP or similar would help
14:52:35 <geekosaur> isn't PrintfArg a a function type?
14:53:29 <ReinH> shanemikel: Don't associate them with unix pipes at all and you'll be better off.
14:53:34 <dmwit> Profpatsch: Is "because that would overlap everything" good enough?
14:53:39 <geekosaur> also the typeclass hackery there is pretty fragile and adding in Show gives you a bunch of overlaps and probably a failure to infer types for much of anything
14:53:43 <ReinH> We could talk about conduit instead.
14:53:58 <ReinH> or even machines...
14:54:02 <johnw> or pipes!
14:54:03 <johnw> lol
14:54:19 <dmwit> ?src PrintfArg
14:54:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:54:50 <AlphaAtom> I've decided something else might be at fault, gonna take a closer look actually
14:55:01 <ReinH> AlphaAtom: glhf
14:55:34 <shanemikel> thanks guys, I know this is a common problem for beginners, and I appreciate the helpful patience
14:55:40 <AlphaAtom> thanks anyway :)
14:56:18 <ReinH> shanemikel: we do our best
15:02:24 <tinco> can I put maxBound :: Word64 in an Integer?
15:02:38 <ReinH> Yes.
15:02:56 <ReinH> Integer has infinite size (up to memory limits).
15:03:17 <ReinH> but that's many orders of magnitude above maxBound :: Word64
15:03:24 <AlphaAtom> yea, solved it was a silly mistake
15:03:36 <dmwit> > fromIntegral (maxBound :: Word64) :: Integer
15:03:37 <lambdabot>  18446744073709551615
15:03:45 <dmwit> or:
15:03:51 <johnw> Infinite, for extremely finite values of infinity
15:03:56 <dmwit> > 2^64-1
15:03:57 <lambdabot>  18446744073709551615
15:04:11 <tinco> nice
15:04:35 <dmwit> :t toInteger
15:04:36 <lambdabot> Integral a => a -> Integer
15:04:47 <ReinH> johnw: :) theoretically infinite.
15:04:50 <dmwit> > toInteger (maxBound :: Word64) -- now with 50% less type ascription!
15:04:51 <lambdabot>  18446744073709551615
15:04:58 <ReinH> for extremely theoretic values of theoretically
15:05:06 <johnw> ReinH: infinite in the sense of all you can eat french fries
15:05:10 <tinco> so eh, just to be sure and I'm not an idiot, logical complement is `a xor (maxBound :: Word64)` right?
15:05:14 <tinco> as in, xor with fffff
15:05:16 <ReinH> johnw: yes indeed
15:05:30 <dmwit> tinco: Why not just use the actual complement operation?
15:05:35 <dmwit> ?src Bits
15:05:36 <lambdabot> Source not found. That's something I cannot allow to happen.
15:05:50 <dmwit> :t complement
15:05:51 <tinco> dmwit: I'm making a C compiler, I have to emit the assembly to do that
15:05:52 <lambdabot> Bits a => a -> a
15:06:22 <ReinH> > 0 - 1 :: Word64
15:06:24 <lambdabot>  18446744073709551615
15:06:28 <mauke> what's your target architecture?
15:06:51 <shanemikel> If I'm planning on learning both.. for pedagogical purposes, do you prefer pipes, conduit, or just reading about iteratees and oleg or cs240h material/lectures
15:06:52 <jacereda> dmwit: ok, gtk2hs faces the same problem as my library (mainGUI blocks and everything from then on is callback-based). My worries are not threading at the moment, I'm just wondering how to transfer information acquired in one callback to other callbacks. Libraries like elerea or pipes could be used to do things like transfering the mouse button state to a `mouseButtonSink` and could be read from other callbacks without using a State
15:06:53 <jacereda> monad. I'm a newbie, so maybe this solutions are overkill for the problem at hand...
15:06:57 <tinco> mauke: x86_64, at the moment, and definitely only 64-bit for now
15:06:59 <shanemikel> err all 3
15:07:18 <tinco> mauke: I said assembly but I meant IR, llvms intermediate language
15:07:23 <dmwit> jacereda: gtk2hs doesn't use State.
15:07:37 <dmwit> jacereda: Ah, you mean *clients* of the library would use `State`?
15:07:40 <Lokathor> so a normal string, as a bytestring, is the utf-8 bytes of the string? and a bytestring.char8 is the truncated ASCII bytes of the string? and a text is utf-16?
15:07:52 <jacereda> dmwit: yes
15:08:04 <dmwit> jacereda: In that case, yeah, the state of the art for gtk2hs is to use `IORef` or similar.
15:08:19 <dmwit> jacereda: And yes, I believe FRP and similar approaches were designed to remedy this "weakness".
15:08:21 <ReinH> shanemikel: I think pipes is conceptually the most elegant presentation and it has great documentation.
15:08:37 <shanemikel> awesome
15:08:37 <dcoutts> jacereda: as an example, see ThreadScope for one pattern that solves it
15:08:41 <ReinH> shanemikel: There is definitely value in going back to the original iteratees paper and such though
15:09:07 <ReinH> shanemikel: also Tekmo's blog posts on pipes are very good
15:09:45 <dmwit> Lokathor: I'm not sure what "a normal string, as a bytestring" means. No, the `.Char8` modules use latin-1, not ASCII. Yes, `Text` is UTF-16 under the hood... for now (don't rely on it staying that way).
15:09:50 <ReinH> Lokathor: a byte string is nothing more than an ordered collection of bytes.
15:09:59 <ReinH> Char8 assumes that those bytes are ASCII characters.
15:10:01 <ReinH> That is all.
15:10:03 <Lokathor> dmwit, i mean a String, like "foo" :: String
15:10:22 <mauke> Lokathor: that's not a bytestring, then
15:10:23 <dmwit> Lokathor: A `String` is a linked-list of codepoints.
15:10:44 <ReinH> ByteString is conceptually the same as Vector Word8.
15:10:44 <dmwit> Lokathor: I don't know of any existing implementation that stores codepoints with utf8.
15:10:48 <Lokathor> mauke, i said "if converted"
15:10:50 <dcoutts> jacereda: it's the standard inversion of control problem, there's a few solutions, of which FRP is the most radical and sophisticated
15:10:54 <ReinH> In fact, their storable representations are identical.
15:10:55 <mauke> Lokathor: converted how?
15:11:07 <ReinH> It knows nothing about utf-8 or any other encoding
15:11:08 <Lokathor> well, however OverloadedString does it
15:11:18 <ReinH> (except for Char8, which makes the usually wrong assumption that the types are ASCI)
15:11:38 <dcoutts> jacereda: but a simple one is threads
15:11:47 <dmwit> Lokathor: OverloadedString uses `fromString`; on `ByteString` this truncates to the last byte of each codepoint.
15:11:50 <ReinH> *the bytes are ASCII
15:11:55 <dmwit> ReinH: latin-1, not ASCII
15:12:01 <ReinH> dmwit: Oh ok, thanks
15:12:09 <ReinH> Some encoding you don't want to use.
15:12:13 <dmwit> agreed
15:12:38 <Lokathor> alright, so an OverloadedStrings generated bytestring will be an ASCII truncated version of the literal?
15:12:45 <dmwit> No, latin-1.
15:12:49 <dmwit> For the third time.
15:12:59 <Lokathor> sorry, many people jumping in at once
15:13:00 <ReinH> dmwit: sorry, I missed the first time.
15:13:27 <jacereda> dcoutts: I'm trying to figure out the threadscope thing, looks like it forks an event handler that will be serving a channel created by the main gui thread
15:13:39 <ReinH> dmwit: (I was too busy talking. ;)
15:13:43 <Lokathor> as i recall, ASCII is 7 bits and latin-1 is ASCII + stuff in the 8th bit?
15:13:48 <dmwit> right
15:13:56 <dcoutts> jacereda: right
15:16:52 <dcoutts> jacereda: so note how that thread holds the state of the app as a local value, and just recurses and updates its local value based on events from the gui
15:16:55 <Lokathor> so a bytestring holds utf-8 if and only if it's reading from a utf-8 source (file, socket, etc), and it's effectively totally unsafe to try and mess with it like it's textual while it's in that form because utf-8 can sometimes have multi-byte characters?
15:17:36 <dcoutts> Lokathor: unless you know anything about the utf8 encoding...
15:18:03 <dcoutts> and know that it's valid utf8
15:18:14 <Lokathor> i literally don't know anything about how utf-8 works
15:18:35 <Lokathor> other than, "it matches up with ASCII at the lowest end of the code point range"
15:18:35 <dcoutts> like, you can search for ascii chars knowing they only appear as themselves, never as bytes in other multi-byte encoded chars
15:19:06 <dcoutts> or, you can order utf8 encoded strings and it's the same as ordering the unicode code points
15:19:38 <dmwit> Lokathor: If you want to mess with your object as if it were text, `ByteString` is a suspicious choice of type these days. Usually you want `Text` instead.
15:19:45 <jacereda> dcoutts: ok, got it
15:20:01 <jacereda> dcoutts: in any case, for the intended users of my libraries (single-window opengl apps ~= toy apps) wouldn't FRP be a better fit?
15:20:19 <jacereda> dcoutts: or maybe the answer is to not write a wrapper at all and let the user decide...
15:20:37 <ReinH> Lokathor: would you expect to be able to work with a Vector Word8 as if it contained UTF-8?
15:20:48 <Lokathor> dmwit, that's roughly what i've been told in the past as well. I'm just trying to refresh mostly, and everyone besides me always seems to know more about the details of this stuff
15:21:16 <shanemikel> @src id
15:21:16 <lambdabot> id x = x
15:21:23 <dcoutts> jacereda: I don't know your use case or users well enough to say, sorry. When I wrote the threadscope code, FRP libs were very immature.
15:21:41 <Lokathor> ReinH, fair point.
15:21:47 <ReinH> A bytestring is an undifferentiated sequence of numbers between 0 and 255. That's it.
15:22:00 <dmwit> jacereda: I suspect you will need a traditional API as a stepping stone to your FRP API anyway.
15:22:06 <ReinH> The fact that the name contains the word "String" is, at best, unfortunate.
15:22:13 <Lokathor> so let's ask from another angle: when does one prefer a ByteString over a Vector Word8?
15:22:22 * Axman6 always wants to rewrite the definition of id to be `id =` to make it point free
15:22:24 <shanemikel> somebody mentioned recent cultural developments in strict IO? is there a good intro reading on design concern and idioms in haskell world?
15:22:46 <dmwit> Lokathor: When communicating with C, I think; `ByteString` uses pinned memory (doesn't move during garbage collection) so is cheaper to send across the FFI barrier.
15:23:01 <Lokathor> hmm. interesting
15:23:04 <ReinH> Lokathor: Well, many protocols use byte strings without a specified encoding.
15:23:12 <Cale> shanemikel: How recent? I dunno if you could really say there have been cultural developments. There are some libraries which do streaming IO which exist if you need them.
15:23:26 <jacereda> dmwit: yeah, the traditional api is already there, I was wondering if I should go on and write a 'nice' wrapper, but given that there're too many 'nices' maybe the best thing is to just stop there
15:23:39 <Cale> (but they are heavyweight tools that you wouldn't really want to use unless you really had to)
15:23:41 <Lokathor> inline-c lets you use ByteString or IOVector. I think I went with the IOVector route because sometimes the pointer you pass down to C has its data mutated, and I figured that'd be a Bad Thing (tm) to do with a ByteString
15:23:49 <ReinH> dmwit: iirc, bytestring actually does extra work there
15:23:57 <ReinH> For example it keeps a copy
15:24:16 <shanemikel> oh, so the streaming libs are 'strict'.. in what sense?
15:24:20 <Lokathor> whereas, with an IOVector it's more... expected? kosher? I'm not sure the word I'm looking for
15:24:29 <dmwit> ReinH: Huh. What's the point of using pinned memory, then?
15:24:48 <Cale> Well, I guess they use strict IO for you under the covers while in some way getting the effect of lazy IO
15:24:51 <ReinH> dmwit: I dunno. bos talks about disabling that to improve performance in http://dl.acm.org/citation.cfm?id=1506070
15:25:45 <dcoutts> ReinH, dmwit: pinning is not obviously such a win.
15:25:49 <Cale> One difference being that by doing strict IO in chunks explicitly, they have an opportunity to deal with exceptions better.
15:25:51 <DRW_> has anyone experience in generating an emacs org-mode table (with a header) from a haskell code block?
15:25:59 <ReinH> Lokathor: generally speaking ByteString is heavily optimized to be a sequence of bytes. Vector is a generic container.
15:26:21 <ReinH> If you have exactly a sequence of bytes and you want to treat it as a sequence of bytes (e.g., you are doing TCP or IRC or something) you generally want ByteString.
15:26:37 <Cale> and by not getting any dependency on evaluation into the mix, they make it easier to manage resources
15:27:04 <Lokathor> ReinH, in the case of the particular FFI lib i'm talking about it's for curses, so it'll be much much more bound simply by the terminal's refresh rate
15:27:23 <ReinH> Lokathor: I think at that point it comes down to which one's interface do you like more
15:27:34 <dmj`> DRW_: I'd check out pandoc, it can read/write to/from org-mode
15:27:38 <Cale> shanemikel: But unless that counts, not really a whole lot has happened with respect to strict IO recently. There are libraries which provide it, such as the strict ByteString and Text libraries.
15:28:07 <Cale> Perhaps there ought to be something for String, but it's not like it's a big deal to do some Text IO and then unpack if you want.
15:28:29 <Lokathor> ReinH, well in the C version you're passing in a char* and then it's fiddling the bits to give you some data, so in that case... wouldn't IOVector be better? the contents of that are mutable and realworld connected and stuff, whereas bytestring should be immutable at all times, right?
15:30:23 <davean> Lokathor: you might want to look at the implimentation of bytestring
15:30:27 <ReinH> You can use ByteString for that too. Unsafe actions are tagged with IO per usual.
15:30:41 <Lokathor> cool
15:30:44 <ReinH> (strict) ByteStrings are literally arrays of bytes with a foreign pointer in the underlying representation.
15:30:56 <ReinH> they are perfectly suitable for FFI
15:30:59 <davean> note the plural
15:31:04 <davean> ?
15:31:12 <Lokathor> huh, so it'd be "safe" for C to modify the data being pointed to? Well alright then
15:32:15 <ReinH> Lokathor: whether it's safe depends on how you handle it on the Haskell side.
15:32:39 <Lokathor> and then.. the next time the user uses the bytestring in something they automatically get the new value? (like an IORef) or do you have to return them the new bytestring as a separate value?
15:33:11 <ReinH> davean: let me rephrase. *a* strict ByteString is a foreign pointer to *an* array of bytes (and an offset and length).
15:33:26 <ReinH> A lazy bytestring is essentially a list of strict bytestrings.
15:34:38 <Lokathor> hmm
15:34:42 <Lokathor> this is all food for thought
15:36:17 <ReinH> So is a storable Vector Word8 (but the layout is different so you can't just unsafeCoerce).
15:36:31 <ReinH> However, you *can* construct either directly via mmap, which is nice.
15:38:40 <Lokathor> ReinH, so a ByteSting and a ByteString.Char8 are effectively the same, it's just that the operations take Word8 or Char depending on which one?
15:38:57 <ReinH> ByteString.Char8 is just a broken way of treating ByteStrings as if they contained text.
15:39:14 <ReinH> .Char8 is just a (shitty) interface on top of ByteString.
15:39:47 <ReinH> It is not a separate data structure, it is just a set of bad functions for working with ByteString in a bad way.
15:39:52 <ReinH> Did I mention that it is bad?
15:40:06 <Lokathor> you did a little
15:40:11 <dmwit> Lokathor: Data.ByteString.ByteString is not just effectively the same type as Data.ByteString.Char8.ByteString. It *is* the same type, and your compiler will agree with me.
15:40:13 <ReinH> I want to be clear on this point.
15:40:16 <davean> He's wrong, its terrible
15:40:28 <ReinH> Who is wrong?
15:40:37 <ReinH> Oh, was I not emphatic enough?
15:40:58 <ReinH> Char8 is basically ByteString plus runtime errors.
15:41:03 <Lokathor> dmwit, ah. i've never imported both at the same time, so i've never had the chance to check
15:41:17 <Lokathor> i do love me some runtime errors
15:41:32 <dmj`> .Char8 is when you know you're just working with ASCII, so only things like http headers
15:41:32 <ReinH> Or no runtime errors and garbled data instead.
15:41:48 <ReinH> dmj`: latin-1 :)
15:41:52 <dmwit> hehehe
15:41:55 <Lokathor> i guess it's suitable to CChar too
15:41:55 <ReinH> dmwit: :D
15:42:15 <ReinH> dmwit: I'm spreading the gospel.
15:42:32 <Lokathor> ReinH, i may ask you more on this gospel at a later time
15:42:40 <Lokathor> but i've got this important ramen to eat
15:42:45 <dmj`> ReinH: preach
15:42:46 <ReinH> I just meant the gospel of "Char8 is for latin-1, not ASCII"
15:42:50 <ReinH> But yes, you can do that too.
15:43:05 <ReinH> dmj`: dmwit had to correct me on that 3 times but I get it nowq
15:43:09 <ReinH> *now
15:44:13 <Lokathor> maybe i really want to only support latin-1, and i hate all unicode, and so i have to use exclusively char8
15:44:40 <ReinH> pls
15:44:42 <ReinH> pls no
15:46:20 <Lokathor> so unicode is ascii compatible, but is it also latin-1 compatible? if it's also latin-1 compatible, how does one know when they're part of a multi-byte sequence?
15:46:26 <Lokathor> these are the things i end up wondering
15:46:41 <Lokathor> so much to wikipedia
15:47:22 <Profpatsch> dmwit: Concerning (Show a) => PrintfArg a: So if a Type then would implement PrintfArg and Show it would cause an OverlappingInstances error?
15:47:43 <Profpatsch> I thought maybe the compiler choses the most specific instance?
15:47:54 <Profpatsch> aka the one with the least indirection steps?
15:48:17 <dmwit> Profpatsch: Not in vanilla Haskell, no.
15:48:32 <dmwit> Profpatsch: And it's even worse than you're saying.
15:48:36 <koala_man> Lokathor: unicode is a character set, not an encoding. you can't encode anything in unicode. however, you can encode unicode in UTF-8, UTF-16, UCS-4 and a variety of other encodings
15:48:51 <dmwit> Profpatsch: If you had another instance for `PrintfArg` at all it would overlap, whether that other instance was also an instance of `Show` or not.
15:48:58 <mauke> Lokathor: you have to distinguish between the character/number mapping (not sure what that's called) and the number/bytes mapping ("encoding")
15:49:10 <Profpatsch> dmwit: Why?
15:49:51 <dmwit> Lokathor: latin-1 and utf-8 are not compatible; all utf-8 bytestrings are valid latin-1 bytestrings and may be interpreted differently in the two encodings
15:50:33 <dmwit> Profpatsch: Instance contexts are ignored when choosing an instance. Only the instance head matters. This is done so that instance selection can be done without backtracking search (hence it is an efficiency concern).
15:50:34 <Lokathor> dmwit, i take from your phrasing that the reverse is not true, that not all latin-1 strings are valid utf-8 strings
15:50:56 <dmwit> Lokathor: Correct. All sequences of bytes are valid latin-1 strings. Some sequences of bytes are not valid utf-8 strings.
15:51:02 <Lokathor> koala_man, a solid point, i'll try to keep it in mind
15:51:27 <Lokathor> mauke, i think "code point", is what people have used so far
15:51:37 <Lokathor> a haskell Char is a "code point" i guess
15:51:46 <ReinH> Lokathor: TL;DR: UTF-8 includes ASCII code points (0x00 to 0x7F) as single bytes (with a leading 0). Bytes with a leading 1 signal the start of a multi-byte code point.
15:51:57 <ReinH> Lokathor: UTF-8 is not latin-1 compatible.
15:52:17 <Lokathor> back in java we only ever had utf-8 strings and utf-8 characters and life was simple
15:52:28 <scshunt> just use Text and Char
15:52:30 <scshunt> and everything is as simple
15:52:31 <Zekka|Sigfig> Isn‚Äôt Java utf-16, not supporting characters above a certain width?
15:52:38 <halogenandtoast> Anyone familiar with Yesod who can tell me where to start digging in to this issue? `devel.hs: Prelude.init: empty list`
15:52:41 <Lokathor> it could be 16 instead of 8, yes
15:53:00 <scshunt> Java is indeed UTF-16
15:53:09 <dmwit> I thought Java was ucs-2
15:53:33 <Lokathor> scshunt, that's very reductive and when you're talking about network related programs it's important to know if, for example, the overhead of encoding/decoding is worth the time or if you can safely tamper with a bytestring
15:53:36 <koala_man> Lokathor: in Java we had UCS-2 strings and UCS-2 characters and life was awfully complicated after Unicode 3 when it was retrofitted with UTF-16 and methods like .charAt now sometimes return half code points instead of full ones
15:54:01 <Lokathor> koala_man, wow am i glad that i only ever used beginner level java :P
15:54:10 <ReinH> Lokathor: For example, 0xE0 is "√†" in latin-1. In UTF-8 it is the start of a particular set of 3-byte code points.
15:54:15 <dmwit> koala_man++
15:54:46 <Lokathor> @karma koala_man 
15:54:46 <lambdabot> koala_man has a karma of 2
15:54:50 <Lokathor> @karma+ koala_man 
15:54:50 <lambdabot> koala_man's karma raised to 3.
15:55:59 <Lokathor> one time my IRC bot had a decoding error while connected to IRC
15:56:14 <Lokathor> but i think it's cause the socket got cut off during a netsplit or something
15:56:22 <Lokathor> so i didn't get too worried
15:57:02 <dmwit> Also, I deny "life was simple" even if everyone agrees on utf-8, because Unicode is not simple even without any of the encoding issues.
15:57:10 <ReinH> Lokathor: 0xC0 is "√Ä" in latin-1. In UTF-8, it is invalid... except in Modified UTF-8, where it is not invalid and 0xC0 0x80 encodes the null character. Encodings are weird.
15:58:00 <Lokathor> Cannot decode byte '\xbf': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
15:58:07 <Lokathor> was the error i got at the tme
15:58:07 <dmj`> ReinH: that's interesting, probably too late to remove .Char8, wonder what the reasons were for including it
15:58:17 <dmwit> There's byte-order marks and combining characters and zero-width characters and control characters and bidirectional text and hey did you know that there aren't left and right parentheses, but rather open and close parentheses and...
15:58:23 <ReinH> There is also a version of UTF-8 called WTF-8 (seriously) that deals with Windows filenames which are invalid UTF-16.
15:58:27 <Zekka|Sigfig> I don‚Äôt know if that‚Äôs valid in the middle of a utf-8 stream, but that‚Äôs certainly not valid at the end of one
15:58:32 <ReinH> In fact, many systems that deal with UTF-8 actually accept WTF-8.
15:58:53 <Zekka|Sigfig> (er, valid as the start of a character at the end of one)
15:59:09 <ReinH> Did I mention that encodings are weird?
15:59:52 <Zekka|Sigfig> Ideally you should just write your program around accepting the subset of 6-bit ascii that contains the letters and sometimes the numbers
16:00:08 <Zekka|Sigfig> The rest of the range is pretty irrelevant, your users can cope
16:00:09 <ReinH> Lokathor, Zekka|Sigfig: 0xBF is a continuation byte.
16:00:24 <pdxleif_> @djinn Monad m => m (m b) -> m b
16:00:25 <lambdabot> -- f cannot be realized.
16:00:39 <pdxleif_> Why does djinn say join is impossible?
16:00:53 <ReinH> Which means that it isn't valid at the beginning of a code point.
16:00:59 <shachaf> Because it doesn't know how to handle type classes, or rank-2 types.
16:01:00 <dmwit> Because it doesn't do rank-2 polymorphism, and typeclasses are essentially rank-2 polymorphism.
16:01:25 <pdxleif_> @djinn Monad m => m a -> (a -> m b) -> m b
16:01:25 <lambdabot> f = (>>=)
16:01:36 <geekosaur> treating IRC as UTF-8 is risky anway, many clients still send ISO8859-1 and it's often necessary to attempt decode as UTF-8 and on failurwe re-decode as ISO8859-1
16:01:45 <shachaf> @djinn Monad m => m c -> (c -> m d) -> m d
16:01:46 <lambdabot> -- f cannot be realized.
16:01:53 <pdxleif_> @djinn Monad m => a -> m a
16:01:53 <lambdabot> f = return
16:02:03 <Lokathor> Zekka|Sigfig, https://github.com/Lokathor/haizod/blob/master/src/Haizod/Network.hs#L54 i was just decoding all the stuff as if it was uft8. class IRC problem: the protocol specifies no format, so you have to guess
16:02:03 <geekosaur> ..and if a client is used to cut and paste between the two then you can get some "interesting" mangled combinations within a single message
16:02:09 <dmwit> ?djinn Monad m => b -> m b
16:02:09 <lambdabot> -- f cannot be realized.
16:02:14 <Zekka|Sigfig> I‚Äôm a little skeptical that you should try to validate IRC input *too* much!
16:02:26 <Zekka|Sigfig> just take the important bytes yourself and send the rest back as you got it
16:02:54 <pdxleif_> dmwit: Wow, just using a different variable name is enough to throw it off on that?
16:03:26 <Zekka|Sigfig> ?djinn Monad m => a -> m (m a)
16:03:27 <lambdabot> -- f cannot be realized.
16:03:43 <dmwit> pdxleif_: Just about any stupid change you make to the type signature will confuse it, yes.
16:03:54 <geekosaur> :exf Monad m => m c -> (c -> m d) -> m d
16:04:04 <pdxleif_> Kind of wondering why those two typeclass defs are loaded if they're mostly useless.
16:04:15 <ReinH> > binary # 0xBF
16:04:16 <lambdabot>  "10111111"
16:04:58 <geekosaur> oh. exferenceBot fell out of the channel earlier :(
16:04:58 <ReinH> You can tell that 0xBF is a continuation byte because of the high-order leading 1.
16:05:13 <ReinH> leading 10, rather
16:05:36 <ReinH> I also wanted an excuse to demonstrate the numeric prisms.
16:06:00 <Zekka|Sigfig> > 0xBF & binary %~ reverse
16:06:01 <lambdabot>      No instance for (Num String) arising from the literal ‚Äò191‚Äô
16:06:02 <lambdabot>      In the first argument of ‚Äò(&)‚Äô, namely ‚Äò191‚Äô
16:06:02 <lambdabot>      In the expression: 191 & binary %~ reverse    No instance for (Integral ...
16:06:37 <geekosaur> so https://github.com/lspitzner/exference is a smarter djinn, you might want to look at it
16:06:59 <ReinH> Zekka|Sigfig: you've got it backwards, and it's a prism.
16:07:25 <Lokathor> ReinH, so we can guess that the socket *was* cut off? or should we suppose that someone just said something in a channel using latin-1?
16:07:46 <dmwit> You shouldn't suppose anything, really. IRC is a byte-based protocol.
16:07:50 <ReinH> Lokathor: IRC doesn't have a standard encoding
16:07:54 <dmwit> It only pretends to transfer text.
16:07:54 <ReinH> So you can't really guess anything.
16:07:59 <Zekka|Sigfig> > "01110111" & binary
16:08:01 <lambdabot>      Couldn't match type ‚Äò[]‚Äô with ‚Äòp Integer‚Äô
16:08:01 <lambdabot>      Expected type: [Char] -> p String (f String)
16:08:01 <lambdabot>        Actual type: p Integer (f Integer) -> p String (f String)
16:08:01 * dmwit high fives ReinH
16:08:04 <Zekka|Sigfig> er, whoops
16:08:10 <ReinH> dmwit: ?
16:08:15 <ReinH> oh right
16:08:17 <ReinH> yes
16:08:19 <ReinH> good work
16:08:20 <Zekka|Sigfig> "01110111" & binary %~ (+1)
16:08:28 <Zekka|Sigfig> > "01110111" & binary %~ (+1)
16:08:30 <lambdabot>  "1111000"
16:08:30 <pdxleif_> geekosaur: Thanks!
16:08:35 <Zekka|Sigfig> There! That is what I wanted. I am good!
16:08:39 <ReinH> Zekka|Sigfig: :)
16:09:13 <ReinH> Lokathor: IRC's official encoding is "Maybe UTF-8? Who knows?"
16:09:27 <Lokathor> well i just looked at it one time and the bot had crashed and that was the last thing it had printed out :P
16:09:39 <dmwit> "Maybe somebody is going to send you some terminal control bytes! Isn't that fun!"
16:09:46 <Zekka|Sigfig> Just remember that \r\n is probably a newline! Or maybe it‚Äôs \n! Don‚Äôt ask me.
16:10:03 <Zekka|Sigfig> If you just assume IRC is about transmitting binary data things get easier.
16:10:07 <ReinH> An actual problem with sending UTF-8 over IRC is the message size limit.
16:10:08 <Lokathor> Zekka|Sigfig, actually, by the IRC spec you separate IRC message with \r\n specifically
16:10:22 <Lokathor> messages*
16:10:23 <ReinH> dmwit: and indeed people often do.
16:10:31 <Zekka|Sigfig> Lokathor: Yeah, although a while ago I played with an IRC server that *accepted* \n, which it probably shouldn‚Äôt have
16:10:38 <Zekka|Sigfig> Be liberal about what you accept, I guess
16:10:45 <Lokathor> fair
16:10:51 <ReinH> Which is terrible advice, but here we are.
16:10:57 <mauke> I think many (most?) servers accept \n and lowercase commands
16:11:09 <Lokathor> I also know that MarceleneVQ often is able to do italic text in IRC, or rather it shows up to me as italic
16:11:17 <geekosaur> it's all much easier when you realize that, standards be damned, it's all ad hoc >.>
16:11:37 <Zekka|Sigfig> ReinH: Be liberal about what you accept iff no one else is aware your iplementation exists
16:11:43 <Zekka|Sigfig> otherwise you might accidentaly create a standard
16:12:03 <geekosaur> italic isn't quite normal but I could see a client choosing to translate the mIRC underline code as italic
16:12:10 <dmwit> I blame the standard for not saying exactly how to behave in error conditions.
16:12:37 <geekosaur> (mIRC colors/attributes being a de facto standard you won't find in an RFC)
16:12:42 <shachaf> dmwit: You would like the HTML 5 standard.
16:12:47 <mauke> plain bold underline reverse italics
16:12:48 <Zekka|Sigfig> The business I work for has written probably the most liberal, helpful, error-correcting OFX implementation there has ever been
16:12:50 <dmwit> I do like the HTML5 standard, yeah.
16:12:59 <dmwit> For pretty much exactly that reason.
16:13:01 <Zekka|Sigfig> But there‚Äôs no way in hell we‚Äôre releasing it! Making this stuff acceptable would be inexcusable
16:13:22 <geekosaur> huh, it does try to do italic?
16:13:26 <mauke> plain *bold* _underline_ /italics/
16:13:45 <Zekka|Sigfig> Better that everyone who produces broken horrific OFX just have to deal with only two companies in the world being able to interpret it correctly
16:13:47 <geekosaur> my client didn't translate that but my script to decode unsupported control sequences showed it to me
16:14:23 <ReinH> Zekka|Sigfig: did you know that the OFC Consortium "welcomes input from all interested parties to extend the open standard"? Surely this will end well.
16:14:24 <Lokathor> they all showed up to me
16:14:30 <Lokathor> i'm using hexchat
16:14:34 <Zekka|Sigfig> ReinH: Life is good.
16:14:47 <ReinH> Honestly I don't understand how Haskell ended up such a good language after being designed by committee. It's an aberation.
16:15:00 <mauke> ÔΩóÔΩâÔΩÑÔΩÖ À¢·µò·µñ·µâ ≥ p«ùddƒ±Ã£◊ü…ü
16:15:02 <geekosaur> I'm using hexchat also but it's an older version (ubuntu lts)
16:15:04 <Zekka|Sigfig> I‚Äôm not that into Haskell but it doesn‚Äôt make most of the design-by-committee errors
16:15:16 <Zekka|Sigfig> the stuff I‚Äôm not into about it is stuff the designers wouldn‚Äôt have been able to foresee, not bad compromises is stuff
16:15:20 <Zekka|Sigfig> bad compromises and stuff*
16:15:29 <hpc> it helps when the whole committee cares
16:15:38 <ReinH> Zekka|Sigfig: And yet here you are. ;)
16:15:50 <Zekka|Sigfig> ReinH: There are not that many technologies I would say I like
16:16:06 <ReinH> fair enough
16:16:13 <Zekka|Sigfig> My favorite programming languages aren‚Äôt very fast or widely used though so Haskell will do
16:16:19 <ReinH> Zekka|Sigfig: I see you've... used technologies.
16:16:38 <mauke> <blink>airssia</blink>
16:16:50 <Zekka|Sigfig> ReinH: Wow! You‚Äôre reading just about as much into my comments as I threw into them
16:17:08 <Zekka|Sigfig> Honestly I was a pretty big Prolog fan for a while but it‚Äôs just really hard to write code that‚Äôs declarative when it‚Äôs so order dependent
16:17:28 <Zekka|Sigfig> I like CHR a lot but it‚Äôs not really targeted at general purpose code, even though imho it‚Äôs pretty suitable for it
16:18:25 <Zekka|Sigfig> Inform has some of the makings of a good general-purpose language but its designers wisely decided to stick to stuff they were familiar with and not to bite off more than they could chew. (Syntax sucks though.)
16:20:02 <ReinH> Inform is interesting.
16:21:06 <Zekka|Sigfig> I guess the pattern here is that these are all global state-centric languages with good support for error handling and really simple control flow assumptions
16:22:34 <Zekka|Sigfig> Haskell‚Äôs not really about global state, makes tricky control flow assumptions (it can basically express anything), and the error handling support is based on monads so it doesn‚Äôt compose that well
16:23:08 <Zekka|Sigfig> it‚Äôs also just awfully complicated a lot of the time ‚Äî I pretty much understand what I‚Äôm doing now but I wouldn‚Äôt want to subject a beginner to it
16:23:50 <jle`> i wonder why data A f a b = A (f (a -> b)) is not in Control.Category or Control.Arrow
16:24:27 <Zekka|Sigfig> Maybe I should hack up Postgres and just write all my programs inside the database. SQL is like the one logic programming language everyone tolerates, and it‚Äôs not too hard to write it in a terser notation
16:26:51 <dmwit> jle`: I guess most of the interesting operations are already available using the type `Compose f (a ->)`.
16:27:09 <dmwit> Not quite all, though.
16:27:21 <Lokathor> ReinH, maybe haskell *didn't* end up as such a good language. And the lone wolf star programmer simply has yet to reveal their custom super haskell>>= language
16:27:47 <jle`> hm sure, but the Category instance is what makes it useful.  but i guess i haven't needed it ever
16:27:57 <jle`> it's just funny that it's defined here http://hackage.haskell.org/package/optparse-applicative-0.12.1.0/docs/Options-Applicative-Arrows.html
16:28:00 <jle`> and useful here
16:28:05 <jle`> but seems general enough to be in base
16:28:07 <jle`> h well
16:28:16 <Zekka|Sigfig> I would hate to think what the people would come up with who htink both (a) there are problems with Haskell and (b) you can fix Haskell by writing Haskell++
16:28:29 <Zekka|Sigfig> I certainly don‚Äôt think the solution to Haskell is Haskell with more things!
16:28:35 <Zekka|Sigfig> (succHaskell?)
16:28:54 <Lokathor> Zekka|Sigfig, Inform like.. the text adventure language?
16:29:03 <Zekka|Sigfig> Lokathor: Yeah
16:29:11 <Profpatsch> Zekka|Sigfig: Haskell is certainly a pretty good global optimum atm.
16:29:37 <Zekka|Sigfig> Profpatsch: Local or global? I‚Äôd dispute global but local might be OK
16:29:55 <Profpatsch> A good compromise between power, type-safety and libraries.
16:30:03 <Zekka|Sigfig> if someone were to write a new pure FP language, there are a lot of things I‚Äôd like to see idfferent, but not a lot of *individual* changes
16:30:09 <ReinH> I assume the only reason Category is in Control.Category rather than Data.Category is alliteration?
16:30:11 <Profpatsch> Zekka|Sigfig: What do you think the global optimum is atm?
16:30:35 <Lokathor> Profpatsch, we could do with many more libraries that were much better
16:30:42 <Profpatsch> Certainly not scala :)
16:30:43 <dmwit> ReinH: The whole Control vs. Data thing is a bit handwavy.
16:30:48 <Lokathor> and it wouldn't affect our power or safety one bit
16:30:59 <Zekka|Sigfig> Profpatsch: I don‚Äôt think we have a language that even comes very close to meeting *everyone‚Äôs* needs, but my favorite prototyping language is probably Haskell, my favorite inference system is probably CHR, and if I wanted to write a big program I would be tempted to do it in Java because anyone can write Java
16:31:00 <Profpatsch> Lokathor: But have you seen a language with better libraries? I haven‚Äôt.
16:31:16 <Lokathor> Profpatsch, define "better"
16:31:28 <Zekka|Sigfig> If I want to process strings I probably do it in Haskell, occasionally in Python just because of inertia and because the builtins are a little easier to use
16:31:51 <Profpatsch> Lokathor: Composability, Interfaces, Type Safety.
16:31:56 <Lokathor> Zekka|Sigfig, consider Fregge instead of java perhaps?
16:32:01 <Zekka|Sigfig> If I want to store a bunch of data I probably use postgres or sqlite
16:32:10 <Lokathor> Frege*
16:32:23 <ReinH> dmwit: yep.
16:32:32 <Zekka|Sigfig> Lokathor: I don‚Äôt know how mature it is, but if it‚Äôs mature enough someone could probably convince me. But I doubt it would be as easy for new devs as Java
16:32:39 <Lokathor> Profpatsch, i dunno man there's a whole lot of java libs
16:33:03 <Profpatsch> Lokathor: The ones I‚Äôve seen are not very composable or even nice to use.
16:33:18 <Lokathor> Zekka|Sigfig, it's essentially haskell on the JVM, with a few tweaks to the standard lib to be more JVM friendly
16:33:20 <Profpatsch> But to be honest I‚Äôve not seen too many. I just hate Java too much.
16:33:24 <pdxleif_> exference looks 7.8 only :(
16:33:31 <Zekka|Sigfig> I think Haskell libraries have a real problem with ‚Äúif you want to interoperate with X, you must require X‚Äù ‚Äî it seems less of a problem in Java because there are fewer Java libraries dedicated to making all other Java libraries better
16:33:48 <Lokathor> but it compiles into files that can interop with other java files like all the JVM languages do so... mix and match your JVM on a module by module basis i guess
16:33:54 <Zekka|Sigfig> I should probably be clear by the way, I really don‚Äôt like Java
16:34:15 <Zekka|Sigfig> recently I‚Äôve been rewriting a Java project into Haskell and I‚Äôm pretty close to the ‚ÄúHate Java, tolerate Haskell‚Äù pole of my hate cycle
16:34:27 <Lokathor> oh that's where i live
16:34:33 <Zekka|Sigfig> (in 20kloc of Haskell I‚Äôll probably be back on ‚Äútolerate Java, hate Haskell")
16:35:28 <kamog> dmwit: what does that Compose thing mean?
16:35:36 <Profpatsch> Zekka|Sigfig: 20k lines of Haskell is an awful lot.
16:35:50 <Zekka|Sigfig> Profpatsch: Well, it took me about 20kloc of Java to get sour on Java again
16:36:03 <Zekka|Sigfig> and before that I wrote all my programs in Haskell for like a year, which was probably 20-30kloc
16:36:42 <Lokathor> but 20k lines of java and 20k lines of haskell take wildly different amounts of time to write, is perhaps the point
16:36:52 <Zekka|Sigfig> Lokathor: Yeah, it was honestly probably less thna that
16:37:11 <Profpatsch> 20k Java is basically bootstrapping the classes from your UML diagram :P
16:37:13 <Zekka|Sigfig> most of the Java was for a big project of mine that took ~8mo and most of the Haskell was for much smaller projects too
16:38:03 <Zekka|Sigfig> I don‚Äôt think Haskell is quite as terse as people seem to think it is (state management is a pain point, composing monads is a pain point, error handling is a pain point), but it‚Äôs certainly much less verbose than Java
16:38:57 <Zekka|Sigfig> I‚Äôve reimplemented about half of a 2kloc Java program and it took about 400loc of Haskell, so on that metric alone it‚Äôs about twice as terse.
16:39:13 <Zekka|Sigfig> (using one benchmark to measure an entire facet of performance is a great idea!)
16:54:35 <m-r-r> Hello
16:55:18 <Renard_Chase> Is there a way to do pattern matching based on the type of the variables passed into a function?
16:55:29 <geekosaur> Renard_Chase, no
16:56:26 <Lokathor> Renard_Chase, intentionally no, but you can wrap your data up in something that tags them if you like
16:56:43 <Lokathor> then pattern match on the tag
16:57:10 <geekosaur> however it's worth considering if that is a good idea. often people looking for typecase are trying to write OOP in Haskell.. which can be done, but not like that
16:57:45 <Lokathor> yeah don't do OOP with type classes. Show is not quite a good example in that regard
16:58:24 <ReinH> I think the best response to that question is to ask why you want to do that in the first place.
16:58:34 <ReinH> It's almost certainly an XY Problem.
16:58:58 <m-r-r> How does one calls two lists which has the same elements, but not in the same order ?
16:59:04 <Renard_Chase> I want a simple function that gives me the string representation of a variable, show seems to work for anything that isn't itself a string
16:59:12 <ReinH> m-r-r: Are you looking for a term? "permutations".
16:59:53 <Lokathor> correct, show doesn't *quite* work how you'd want for a string
17:00:13 <geekosaur> well, it does, for its idea which is debugging not prettyprinting
17:00:19 <geekosaur> there are prettyprinting libraries out there
17:00:19 <ReinH> Renard_Chase: The only option is to use or write a typeclass.
17:00:21 <Lokathor> because for String, as with many data types, show and read are inverse funcitons
17:00:22 <m-r-r> ReinH: Yes, that's what I was looking for :-) Thanks !
17:01:30 <Renard_Chase> I don't want to directly print the variable though, since I want to concatanate multiple variables together, recursively
17:01:59 <ReinH> show doesn't directly print anything.
17:02:23 <ReinH> But if you want to do pretty-printing, you don't want show.
17:02:37 <Renard_Chase> Show does almost what I want
17:03:04 <geekosaur> but you cannot coopt or modify it to do what you want
17:03:35 <Lokathor> this is sadly the case
17:03:47 <Renard_Chase> What I want is to basically take a list [1, 2, 3] and then build the string "Items: 1 - 2 - 3" from it
17:04:33 <ReinH> @hackage pretty
17:04:33 <lambdabot> http://hackage.haskell.org/package/pretty
17:10:59 <Renard_Chase> @RainH, I have the library, but it seems to contain no documentation on how to use it
17:10:59 <lambdabot> Unknown command, try @list
17:11:29 <Lokathor> Renard_Chase, http://hackage.haskell.org/package/pretty-1.1.3.2 try this version that's slightly older
17:11:46 <Renard_Chase> Thank you
17:11:48 <Lokathor> the docs should be close enough for most things
17:15:03 <slacktest> Am I crazy in seeing parallels between the relationship in tcp/ip and monad transformers?
17:15:23 <slacktest> as each layer add a guarrantee in the same way a extra layer adds an effect?
17:16:49 <ReinH> I think the main similarity is that they can both be seen as consisting of layers.
17:17:30 <Lokathor> like an ogre
17:17:58 <ReinH> Exactly.
17:18:48 <shachaf> I like the networking analogy with substructural types -- https://en.wikipedia.org/wiki/Substructural_type_system
17:19:46 <dedgrant> Renard_Chase: (concat . intersperse " - " . map show)?
17:19:48 <shachaf> Substructural type systems discard the rules of exchange (out-of-order variables), weakening (discarding variables), and contraction (duplicating variables).
17:20:07 <shachaf> Whereas if you're writing a network protocol you might worry about out-of-order packets, dropped packets, and duplicated packets.
17:20:18 <slacktest> !!!
17:21:29 <ReinH> "I want to receive this packet at most once."
17:22:03 <ReinH> "I want to receive this packet at least once" is actually one of the hardest problems in computer science.
17:22:28 <ReinH> Only slightly less hard than "exactly once".
17:22:51 <TheKing444> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:22:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:22:56 <ReinH> Well, I think "exactly once" is unsolvable, so maybe not "slightly less".
17:23:31 <TheKing444> @quote
17:23:31 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
17:23:40 <Renard_Chase> degrant : I am kind of new to Haskell... so that function isn't very readable to me
17:24:09 <ReinH> That was a surprisingly relevant quote.
17:24:58 <dedgrant> Renard_Chase: Ah my apologies. Can expand iut out and break it down with you elsewhere if interested.
17:25:04 <slacktest> In my mind, that quote has in the background playing "iron maiden - bring your daughter... to the slaughter"
17:25:25 <Renard_Chase> dedgrant: Sure, what do you have in mind?
17:27:05 <dedgrant> Renard_Chase: Just describing what it produces and how. Does it all look confusing, or are you familiar with one or two of the function names?
17:27:46 <Renard_Chase> dedgrant: I mean, did you want to talk it out in a private message or using another service?
17:27:52 <slacktest> @let ones = 1 : ones
17:27:54 <lambdabot>  Defined.
17:28:01 <slacktest> > take 5 ones
17:28:03 <lambdabot>  [1,1,1,1,1]
17:29:53 <dedgrant> Renard_Chase: I was thinking private message just to avoid the cross-talk for now
17:32:20 <shapr> Ok, what's a Fin type?
17:34:06 <Cale> shapr: Type of natural numbers less than n?
17:43:30 <shanemikel> wow.. this pipes library is a lot to take in
17:43:49 <shanemikel> so far, every adventure in haskell has been quite intimidating
17:46:08 <Cale> shanemikel: Yeah, pipes and conduit are scary
17:46:38 <Cale> shanemikel: I wouldn't just use them casually. It's possible to do some pretty effective things with them, but the types are kind of nuts.
17:47:00 <jb55> shanemikel, Cale: the streaming library is much simpler and faster
17:47:18 <jb55> but those signatures in Pipes sure come in handy in real world use
17:48:32 <Cale> Depending on what you're doing, lazy IO might just be fine too, so long as you're aware of the caveats.
17:49:26 <Lokathor> so eta reducing a top level function can make it become a constant applicative form, which has runtime considerations
17:49:33 <Lokathor> all of life is a lie now
18:01:37 <maerwald> lazy IO is horrible
18:04:02 <nineonine> greetings !
18:04:12 <nineonine> question about types/kinds
18:04:20 <nineonine> lets say i want to have 
18:04:35 <nineonine> data Dt = A C | B C
18:04:46 <nineonine> C is another type
18:05:03 <nineonine> and now i want to make a function of type
18:05:12 <nineonine> B C -> Bool
18:05:16 <geekosaur> you can't
18:05:22 <geekosaur> B is a constructor, not a type
18:05:25 <nineonine> here is the question
18:05:26 <nineonine> why ?
18:05:32 <nineonine> oh
18:05:50 <nineonine> but B C is a type ?
18:05:53 <geekosaur> no
18:06:02 <Clint> Dt is a type
18:06:02 <c_wraith> Nope.  The type and value levels are totally independent.
18:06:13 <ReinH> Dt is a type. B is a function of type C -> Dt.
18:06:18 <geekosaur> B is a data constructor which takes a value of type C and produces a value of type Dt
18:06:44 <nineonine> ok
18:07:03 <nineonine> then whad does that eror mean ?
18:07:09 <ReinH> What error?
18:07:10 <nineonine> Data constructor ‚Äò...‚Äô comes from an un-promotable type '...'
18:07:30 <nineonine> this is when im enabling DataKinds
18:07:32 <geekosaur> you have DataKinds turned on so it's trying to generate a kind-level thing
18:07:32 <ReinH> It means that B is not a type.
18:07:48 <geekosaur> but it cannot because a data conbstructor with parameters can't be promoted to kind level
18:08:47 <nineonine> so that means that parameterized types cannot be promoted ?
18:08:57 <nineonine> oh
18:08:59 <ReinH> If you haven't fully understood the difference between values and types, adding in DataKinds will not make things easier to understand.
18:09:04 <geekosaur> ^
18:09:06 <nineonine> thats not a type
18:09:08 <nineonine> :D
18:09:09 <nineonine> sorry
18:09:29 <geekosaur> you can't make it promote B to a type, just as you cannot make it promote Just to a type
18:09:57 <geekosaur> it's trying to promote to a *kind* (the "type" of a type), and if it had succeeded then you would have gotten even stranger errors from trying to use a data constructor as a type
18:10:05 <nineonine> i added that extension because compiler suggested so and its a good way to learn its behavior
18:10:19 <geekosaur> it's a little too willing to suggest that extension, sadly
18:10:43 <geekosaur> if you're not familiar with type level programming then you probably want to avoid DataKinds unless some library you are using requires it
18:12:09 <nineonine> thanks everyone !
18:17:32 <c_wraith> I finally figured out how to write the Functor instance for hyperfunctions. turns out it's easy when you pretend they're funny functions, instead of paying attention to their representation. 
18:26:05 <shachaf> c_wraith: Hmm, Functor instances usually reflect the structure of a type, even for non-regular types. Is it different for Hyper?
18:27:02 <c_wraith> shachaf, mostly that I was getting tangled up in the nesting of the irregular recursion
18:27:34 <c_wraith> shachaf, things got way better when I just used hyperfunction composition.
18:29:12 <c_wraith> "if these were functions, I'd just compose them. ok, do the same thing, but I need to lift the first argument to a hyperfunction first." 
18:30:35 <Lokathor> :t map (+1)
18:30:36 <lambdabot> Num b => [b] -> [b]
18:32:23 <shachaf> c_wraith: Well, lifting a function to a hyperfunction is a dubious operation, if you ask me.
18:33:23 <LordBrain> i have a perplexing issue. i used withSystemTempDirectory to create a temporary directory that it reports as /tmp/checkLMDBXXXX15110. Inside the program i can see the directory as existing, i can create new files in there, and list its files. However when i look for it under /tmp there is nothing, no directory there even starting with ch. So where is it?
18:34:28 <shachaf> c_wraith: If you mean (a -> b) -> Hyper a b
18:34:39 <c_wraith> shachaf, eh. I was following along with the Launchbury/Krstic/Saurwein paper in spirit, and it spent a fair amount of time justifying that operation first. 
18:34:49 <c_wraith> shachaf, and yes, that's the one. 
18:35:00 <LordBrain> if i use runCommand and waitForProcess to run an external file manager on the provided path, the external file manager says it can't find it too.
18:35:06 <macalimlim> hello all :) would anyone mind sharing their .ghci config?
18:35:33 <LordBrain> its as if the /tmp i see inside haskell is not the real /tmp
18:35:34 <c_wraith> macalimlim, mine's empty, and I'm pretty sure that's the most common config. 
18:35:40 <LordBrain> how can this happen?
18:35:45 <macalimlim> some useful defs you might want to share...
18:36:00 <LordBrain> is this a "feature" ?
18:36:11 <geekosaur> LordBrain, that could be a systemd "feature"
18:36:22 <LordBrain> oh my holy ...
18:38:43 <django_> anyone need a haskell job i found this online: https://frontrow.workable.com/jobs/156061
18:39:46 <shachaf> My .ghci is >150 lines long.
18:40:13 <shachaf> c_wraith: So do you understand how Nat ~~ (Nat -> Bool) -> Bool?
18:41:42 <c_wraith> shachaf, hmm. What's ~~? 
18:41:47 <shachaf> Isomorphic.
18:42:09 <shachaf> c_wraith: Without newtype noise, fmap f = (f .) . (. (. fmap f))
18:42:32 <shachaf> Which is noisier than I hoped but reasonable structural, I guess.
18:43:21 <c_wraith> then.. not offhand. I see how Nat is isomorphic to forall a. (Nat -> a) -> a, but it seems like adding the concrete type makes more inhabitants possible. 
18:43:25 <geekosaur> LordBrain, if you have any /tmp/systemd-private-* directories, look inside those. also check under /run
18:43:50 <shachaf> c_wraith: Apparently Hyper Bool Bool = Nat
18:44:05 <shachaf> Unless I'm misremembering. It was just mentioned offhand half a year ago.
18:44:43 <c_wraith> it's possible there's a more clever isomorphism that I'm missing.
18:45:50 <shachaf> Let's see. As a fixed point of F a = (a -> Bool) -> Bool, you can represent it as (exists x. (x, x -> F x))
18:46:08 <shachaf> I.e. (exists x. (x, x -> (x -> Bool) -> Bool))
18:46:20 <shachaf> Or (exists x. (x, (x -> Bool) -> (x -> Bool)))
18:46:54 <shachaf> Assuming it's the greatest fixed point, because maybe this isomorphism is only true in a more careful world than Haskell.
18:47:31 <c_wraith> bottoms ruin most potential isomorphisms in Haskell 
18:47:33 <shachaf> So it's some value of some type, along with a function that takes a set of values of that type and returns another set of values of that type.
18:48:07 <shachaf> Sort of.
18:52:08 <shachaf> Ah, https://github.com/ekmett/hyperfunctions/blob/master/examples/Cantor.hs
18:56:19 <macalimlim> @shachaf would you mind sharing some of your useful defs?
18:56:20 <lambdabot> Unknown command, try @list
18:56:40 <shachaf> It's mostly imports and language extensions.
18:58:57 <macalimlim> anyone mind sharing their .ghci? some useful defs...
19:00:52 <silky-nvds> macalimlim: https://github.com/search?l=haskell&q=.ghci+in%3Apath&ref=searchresults&type=Code&utf8=%E2%9C%93
19:01:37 <macalimlim> oh thats very nice thanks :)
19:01:44 <peddie> macalimlim: https://wiki.haskell.org/GHC/GHCi
19:01:50 <AlphaAtom> if I have a function generating an infinite list, is there a way to "pipe" that list as an arg of a function?
19:02:23 <Axman6> I don't understand the question
19:02:37 <Axman6> just pass list to the function as an argument
19:03:26 <AlphaAtom> i tried that, didn't seem to work, but perhaps im doing something else wrong
19:04:13 <geekosaur> it ownt work if the function is not ex pecting a list, no. but it is unclear what you mnean by piping here
19:04:15 <Axman6> we'll need some more information from you to be able to answer, what are the types of the functions involved?
19:04:50 <xshay> you know how with parsec you have user state? I want to do the same thing in a FromJSON instance
19:05:15 <xshay> but I don't think I can "stack" a ReaderT on top of the Parser monad in a way that works like that?
19:05:47 <Axman6> you can always explicitly pass around the state
19:06:05 <xshay> how do I get it into `parseJSON` though? Since that's called via `decode`?
19:06:19 <xshay> I guess maybe I need to implement my own `parseJSONwithState` or something, outside of FromJSON instance
19:06:53 <Axman6> you probably can't use encode if the state  eeds to be different for each parse, you'll need to use the functions which work directly on Parsers, and you won'y be able to use FromJSON
19:07:26 <xshay> ok, that's what I suspected - wanted to check I wasn't missing something :) Thanks!
19:13:41 <AlphaAtom> nvm there is some funky stuff going on with my factorial thing again
19:27:09 <aerialB> When I do "let foo = 13", am I creating a variable or a function with no arguments? Or is it the same thing?
19:27:25 <shachaf> There's no such thing as a function with no arguments.
19:27:30 <aerialB> oh
19:27:49 <shachaf> Whether foo is a function or not can depend on how it's used. But most likely it's not.
19:28:06 <shachaf> (In some cases numbers can be functions, but none that are relevant here.)
19:28:45 <geekosaur> it's also not a variable, since you can't change it. it's a binding to a constant applicative form
19:30:01 <aerialB> I've no idea what that means :) But I will probably need to learn lots of other things first.
19:30:47 <shachaf> "constant applicative form" is an implementation detail for the most part.
19:30:57 <shachaf> I'd say that it's a variable but that's a silly argument about words.
19:31:56 <silky-nvds> aerialB: haskell people get excited about thinking about the number of arguments functions have
19:32:10 <silky-nvds> aerialB: and in some sense i think it's fair to think of foo as both being a variable, and being a function of no arguments
19:32:30 <silky-nvds> aerialB: but maybe another way is just to think of it in the algebra sense; whenever you see "foo" you can replace it with "13"
19:33:27 <jle`> silky-nvds: i don't think you can honestly say that it's a function with zero arguments, because functions in haskell are things whose type have (->) in them
19:33:32 <shachaf> @google conal everything function
19:33:34 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
19:33:34 <lambdabot> Title: Conal Elliott ¬ª ‚ÄúEverything is a function‚Äù in Haskell?
19:33:41 <shachaf> That URL is pretty misleading.
19:33:45 <jle`> hah
19:34:26 <geekosaur> the problem with calling it a variable is that it's not something you can assign to; you can't change foo to be something else later, except by creating a new distinct foo in an inner scope (you'd get an error if you tried to do it in the same scope)
19:34:43 <jle`> aerialB: i'd call it a definition
19:34:52 <silky-nvds> jle`: i didn't say it strictly is, but i said it can help to think about it that way when coming from other languages.
19:35:03 <jle`> in what ways does it help?
19:35:25 <silky-nvds> jle`: insofaras when i talk to people in real life it helps them to understand what is happening
19:35:53 <jle`> i'm not sure how calling it a 0-ary function adds anything
19:36:06 <silky-nvds> jle`: that's okay
19:36:37 <shachaf> If people hear that and then think they understand, then I think it's actively harmful.
19:36:51 <jle`> i can't imagine how it can help, but i can think of several ways that it would be harmful and hinder learning/understanding
19:36:52 <ZelteHonor> Hi!
19:37:10 <jle`> hi! :D
19:37:22 <ZelteHonor> Can I ask some question?
19:37:30 <verement> you just did
19:37:38 <kadoban> ZelteHonor: Of course
19:37:41 <ZelteHonor> Hehehe! Classic.
19:37:46 <jle`> better to ask than to ask to ask :)
19:38:09 <aerialB> Hm.
19:38:13 <ZelteHonor> DO you know Leksah?
19:38:33 <ZelteHonor> Is it something that can be realisticaly use?
19:38:46 <kadoban> I know of it ‚Ä¶ I don't hear a lot of people using it really.
19:39:16 <ZelteHonor> I was reading this: https://pay.reddit.com/r/haskell/comments/48jcy8/what_features_would_you_like_to_find_in_a_haskell/
19:39:24 <ZelteHonor> Someone talk about Leksah.
19:39:26 <aerialB> I don't know what to think now.
19:39:30 <kadoban> I personally favor just a good programmers' text editor and optionally a couple of minor plugins, and GHCi in a separate window. Good editors are: vim, emacs, atom, sublime, maybe gedit or kate in a pinch.
19:39:35 <aerialB> But I'm having fun nonetheless
19:39:45 <ZelteHonor> Yeah. I use Atom myself.
19:40:04 <ZelteHonor> I was thinking about introducing Haskell with people who are use to IDE.
19:43:42 <ZelteHonor> Another question. I might have to write a Haskell program wich use graph without cycle. Wich graph library should I use?
19:45:36 <dcoutts> ZelteHonor: Data.Graph in the containers package is sufficient for many applications
19:47:22 <ZelteHonor> Thanks.
19:50:19 <ZelteHonor> The vertex definition is: type Vertex = Int : Can I put something else than a Int in the graph?
19:51:28 <Axman6> there's also fgl, which is on the other end of the spectrum of complexity
19:51:31 <Axman6> https://hackage.haskell.org/package/fgl
19:51:33 <geekosaur> generally you use the Int as a label and keep a Map to whatever else you want; that makes it easier to share values if you need to (granted, you said you didn't)
19:51:49 <geekosaur> (hm, no you didn't actually)
19:53:38 <ZelteHonor> Well I'll use it for some variation of the LZSS compression algorithm.
19:54:33 <ZelteHonor> I was also thinking of using a Map.
19:55:17 <geekosaur> (IntMap actually, more efficient when the key is an Int)
19:55:25 <ZelteHonor> So I could put the text in Data.Text
19:55:38 <ZelteHonor> The int would be index.
19:55:42 <shachaf> Differently efficient.
19:56:13 <ZelteHonor> shachaf: Excuse me I am not sure I understand?
19:56:51 <shachaf> IntMap, I mean.
19:58:07 <ZelteHonor> I was thinking of using Data.Text since the value is text itself.
19:58:35 <geekosaur> sigh, I think all I did was confuse them...
20:00:07 <ZelteHonor> If I work on a large text I should use Data.Text right? Because String is slow?
20:00:27 <ZelteHonor> I am pretty much a beginner.
20:01:45 <geekosaur> yes. the discussion was about Map vs. IntMap, not about Text; Text is largely preferred over String these days
20:02:33 <ZelteHonor> Yeah. If I use a map with Int as key I should use IntMap. Is that right?
20:02:53 <geekosaur> usually
20:03:00 <kadoban> ZelteHonor: Probably, though often it doesn't matter.
20:05:30 <ZelteHonor> About fgl I am afraid that it would be overkill. I'll work only with directionnal acycle graph.
20:09:37 <jle`> ZelteHonor: have you considered using a tree instead?
20:10:04 <ZelteHonor> I don't really know.
20:10:30 <ZelteHonor> The Thing is that in the graph there is more than one way to reach a vertex.
20:14:00 * hackagebot json-autotype 1.0.11 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.11 (MichalGajda)
20:14:02 * hackagebot homplexity 0.4.3.1 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.3.1 (MichalGajda)
20:18:56 <meditans> hi, I have a question on vinyl usage: I'd like to write a signature like
20:18:58 <meditans> c :: (ps ‚âÖ ('PitchValue ': rs), RecAll Attr rs Default) => Rec Attr ps
20:20:02 <meditans> meaning that I'd like to produce a value of type `Rec Attr ps` if ps happens to contain 'PitchValue and the other elements have a Default instance
20:21:35 <meditans> however, the code doesn't compile this way. Suspecting the high impredicativity of rs, I also tried
20:21:55 <meditans> c :: (ps ~ ('PitchValue ': rs), ps' ‚âÖ ps, RecAll Attr rs Default) => Rec Attr ps'
20:22:31 <meditans> but still, I get the error "Could not deduce ..."
20:24:14 <meditans> Now, this simpler form:
20:24:21 <meditans> c :: (ps ~ ('PitchValue ': rs), RecAll Attr rs Default) => Rec Attr ps
20:24:30 <meditans> is ok, but doesn't do what I want
20:37:11 <montanonic> Can someone link me to a post that explains how Applicatives allow for static analysis whereas Monads do not?
20:42:38 <athan> montanonic: The key is in join
20:42:44 <athan> Monads are just applicatives + join
20:42:49 <athan> :t Control.Monad.join
20:42:51 <lambdabot> Monad m => m (m a) -> m a
20:43:06 <athan> montanonic: Join lets us hot-swap, in a sense
20:43:11 <athan> if `m` was IO, for instance
20:43:16 <jle`> montanonic: note that the structure of an Applicative is completely pre-determined before anything is ever run
20:43:22 <athan> elm forces it's IO system to be applicative only
20:43:46 <jle`> montanonic: for example, if you know the length of xs and ys, then `liftA2 f xs ys`'s length is already known
20:44:03 <athan> jle`: Woah...
20:44:16 <jle`> if you know if x and y are Just or None, then `liftA2 f x y` can be known to be Just or Nothing before 'f' is applied or inspected
20:44:53 <jle`> if you know the structure of the things you are composing/applying applicatively, the structure of the result is known before any evaluation needs to take place
20:45:44 <jle`> this is not the case with Monad... if you know the length of xs, you don't know the length of `xs >>= f` until after you evaluate f
20:46:27 <jle`> (unless the length of xs is 0, but, the point is that in general, f has the power)
20:46:51 <shachaf> I wonder whether you can express that property as a sort of naturality.
20:54:51 <montanonic> sorry I've been afk for a bit and going to be for a bit longer; thank you for your responses jle` and athan, I'll take a look at them shortly
20:55:23 <sclv> luite: this is pretty neat, but idk how to answer the questions as such :-) http://stackoverflow.com/questions/35715256/running-the-haskell-compiled-to-javascript-on-the-jvm
21:08:56 <montanonic> jle`: okay, that helps a lot. Monadic bind can create new structures, so that does indeed lend the power to f. Thank you.
21:29:03 * hackagebot neat-interpolation 0.3.2 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.3.2 (NikitaVolkov)
22:15:36 <shanemikel> hmm, I wonder how one would go about building an application with stream processing libs like pipes, that required some level of readahead or backtracking.. or variable sized buffers
22:17:50 <geekosaur> not sure about current pipes but I recall a pipes vs. conduit comparison that cited those kinds of things as what pipes did not handle but conduit did (sort of; conduit was being redesigned to do it better at the time iirc)
22:18:09 <geekosaur> lomng enough ago that probably both have improved since then
22:24:19 * hackagebot order-statistic-tree 0.1.1.0 - Order statistic trees based on weight-balanced trees  https://hackage.haskell.org/package/order-statistic-tree-0.1.1.0 (MZiatdinov)
22:28:47 <shanemikel> thanks
22:31:16 <mniip> is there any meaningful logic behind the implementation of <*> for Cont? So far I only managed to get it by looking at the type signature for ages and by using parametricity
22:32:54 <jle`> well, if you see the logic behind >>=, you can kind of go from there, i guess
22:33:34 <mniip> :t ?f . (?x .) . (.)
22:33:36 <lambdabot> (?f::((a -> b) -> c1) -> c, ?x::(a -> c2) -> c1) => (b -> c2) -> c
22:40:25 <mniip> jle`, nope
22:41:00 <mniip> it only makes sense due to parametricity
22:42:52 <jle`> i like to think of it in terms of the continuation-passing-style that it is meant to abstract/replace
22:42:59 <jle`> withX $ \x ->
22:43:09 <jle`>   withY $ \y -> ..
22:43:18 <jle`> is the same as: do x <- cont withX; y <- cont withY; ...
22:44:34 <jle`> so <*> in that sense would be something like withF $ \f -> withX $ \x -> callback (f x)
22:45:28 <jle`> which would be cont withF <*> cont withX
22:50:35 <lpaste> jle` pasted ‚ÄúCont Applicative‚Äù at http://lpaste.net/153845
22:50:42 <jle`> ^ mniip 
22:54:02 <lpaste> jle` revised ‚ÄúCont Applicative‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/153845
22:54:10 <jle`> oops
22:55:21 <mniip> hmm
22:58:13 <lpaste> jle` revised ‚ÄúCont Applicative‚Äù: ‚ÄúRevised with do block translations (mniip)‚Äù at http://lpaste.net/153845
22:59:14 <jle`> if only there was a way to get Cont to work with exsistentials somehow
22:59:19 <jle`> that'd be the life
23:00:53 <mniip> still doesn't make sense :(
23:02:02 <jle`> :(
23:03:57 <jle`> `withFoo :: (Foo -> IO a) -> IO a` is a common callback pattern.  if you've ever used Node, many library functions are given in this form
23:04:06 <mniip> like, I understand that it's a functor because a is contra-contravatiant, but that's as far as it goes
23:04:20 * hackagebot criterion 1.1.1.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.1.1.0 (BryanOSullivan)
23:04:24 <jle`> Cont lets you can withFoo $ \x -> withFoo y -> ..., nested callbacks, and lets you write them as do notation
23:04:43 <jle`> ( withFoo $ \x -> withFoo $ \y -> ...)
23:05:28 <jle`> the nested callback style of the first 'foo' style in the lpaste is a node-callback-hell-esque nested callback style
23:05:41 <jle`> but the Monad instance for Cont lets us write that as a nice clean do block
23:06:24 <jle`> Cont is one of those weird monads to me where the Monad instance makes more sense than the Applicative or Functor instance :|
23:07:12 <Cale> Functor should make good sense at least
23:07:18 <jle`> but you can sort of understand the Functor instance in that light.  normally you have withFoo $ \x -> ..., but if you "fmap" withFoo, instead of getting \x -> to work with, you get \fx -> ..., f applied to x
23:15:25 <saurabhnanda> is this a good place to start a Haskell vs OCaml holy war?
23:16:21 <jle`> a lot of people here use both ocaml and haskell ... it's not a bitter rivalry :)
23:16:51 <erikd> yeah, ocaml really is a rather nice language. and i'm a little jealous of MirageOS
23:20:41 <saurabhnanda> so, I've spent 2 months with Haskell, and here's a list of my pet-peeves. Does OCaml solve them: (a) Lack of optional function arguments (b) Lack of keyword arguments to functions (c) Functions randomly throwing errors WITHOUT any documentation OR compiler support (how am I supposed to know which errors to handle?) (d) Why can't two data-types have record accessors with same names? (e) Monad transformers -- who even thought of that? 
23:20:42 <saurabhnanda> Aren't they a maintenance nightmare for a large program? (f) Haskell compiler being unable to detect obviously incorrect/incomplete code (http://stackoverflow.com/questions/35266143/ghc-compiler-not-complaining-about-incorrect-code-paths/35268192)
23:21:12 * saurabhnanda wonders if IRC has a line length. How did my message auto-split?
23:24:29 <seishun> I'm not sure how optional function arguments could fit into haskell's type system
23:25:23 <shanemikel> you can get ghc to warn you about partial functions.. optional function arguments? you can curry.. I agree I would like to somehow get ghc to warn me about possibly uncaught exceptions.. maybe a language extension requiring `throws` annotations similar to java
23:27:41 <mgsloan> saurabhnanda: Yeah, records are kindofa wart in an otherwise lovely language.  They don't mix well with sum types, so just "don't do that".  It's bad style, and experienced haskellers don't write much code with them   
23:28:33 <ReinH> "optional function arguments? you can curry" how?
23:28:41 <mgsloan> If you have complicated records that you want in your sum, just put them in a separate datatype, and use that as the single field of the constructor
23:29:02 <shanemikel> oh.. I assumed he meant default function args
23:29:15 <shanemikel> not variable arity
23:29:20 <opqdonut> saurabhnanda: at least QuickCheck uses a model where there is a record type QuickCheckArgs, and then you can do something like "stdArgs{size=3}" to override some args
23:30:07 <opqdonut> saurabhnanda: of course that doesn't really work for one-off keyword and optional args, but for functions which would take like 10 kw args in another language it's a pretty good option
23:30:15 <saurabhnanda> optional functional arguments usually go hand-in-hand with default values
23:30:34 <mgsloan> (a) and (b) are usually resolved by having a record datatype.  In practice this works quite well, and has the benefit of being able to pass around the args for a function, unapplied
23:30:51 <mgsloan> (c) is solved by using good libraries.  I agree that more statica analysis here would be nice
23:30:53 <opqdonut> as for errors, nobody likes them
23:31:25 <mgsloan> continuing with (f), many cases of such errors *are* caught by warnings
23:31:46 <ReinH>  (e) smart people, and no they are not.
23:32:06 <saurabhnanda> mgsloan: you mean crete a data-type for every function that needs to take optional arguments? btw how does provide default values for fields in a record data-type?
23:32:11 <opqdonut> I guess ocaml "solves" monad transformers by having unlimited side effects
23:32:28 <ReinH> Maybe a is an optional a. It isn't hard.
23:32:43 <saurabhnanda> ReinH: :-)
23:33:25 <mgsloan> saurabhnanda: Yeah, or use Maybe as ReinH suggests.  If your function takes so many arguments, this is a good idea anyway, to keep them organized (records are actually pretty awesome for this)
23:33:45 <mgsloan> As much as its easy to rag on records, they are super handy for this
23:33:59 <mgsloan> For default values, you just declare a Default instance for your param type
23:34:10 <opqdonut> oh there's a Default type class
23:34:27 <mgsloan> Yeah, though not everyone thinks it's a good idea:)
23:34:28 <saurabhnanda> mgsloan: and then the function has to pattern-match against all the Maybe's and default to something? That's like Ruby in the 1.9.x days when it didn't have kwargs. Passing around an opts-hash and doing all this stuff manually in each function.
23:34:51 <mgsloan> saurabhnanda: Use ViewPatterns and fromMaybe. Very concise
23:34:56 <saurabhnanda> mgsloan: Default instance?
23:35:08 <mgsloan> f (fromMaybe "I'm a default!" -> x) = x
23:35:26 <shanemikel> I'm still new, but it's clear the monad transformers are essential, and, for what it's worth, they're not as frightening as they seem as first glance.. just work through https://en.wikibooks.org/wiki/Haskell/Monad_transformers with MaybeT IO and MaybeT [] (NOT ListT.. and try to separate your exploration of Monad Transformers from your conception of the scarier monads.. just work with the simple ones)
23:35:57 <opqdonut> yeah and often you don't need to use monad transformers your self
23:36:07 <opqdonut> a library has defined a monad M and you can consider it to be opaque
23:36:10 <mgsloan> Yeah, transformers are handy.  IMHO they're most useful for defining new monads though.  I hate "monad transformer stacks" with a passion
23:36:14 <opqdonut> even though it might be built up from transfoermers
23:36:17 <mgsloan> But that's just me
23:36:20 <ReinH> I'll take knowing whether a parameter exists or not and having to write a couple extra words over options hashes in Ruby any day
23:36:51 <saurabhnanda> ReinH: exactly. Ruby 1.9 style opts-hashes are really bad.
23:37:09 <saurabhnanda> I'm not clear how to solve the keyword AND optional arguments problem in Haskell. What's the recommended approach
23:37:11 <saurabhnanda> ?
23:37:17 <ReinH> It depends.
23:37:25 <ReinH> You can look at the solution diagrams uses.
23:37:28 <ReinH> It's rather nice.
23:37:33 <mgsloan> saurabhnanda: You'll find that Haskell tends to keep the language features simple and composable.  Adding special stuff for defaults would really complexify functions, screw up currying
23:37:41 <ReinH> It uses records and default values and lenses.
23:37:57 <ReinH> Well, the lenses are optional, but nice
23:39:52 <mgsloan> Ok maybe saying that all the language features are simple is a stretch.  But composable, yes!  (except perhaps ImpredicativeTypes eheh)
23:40:58 <ReinH> mgsloan: scheme has simple language features...
23:41:19 <ReinH> well, less and less simple every yeaer it seems
23:41:57 <ReinH> Sugar-free Haskell is a pretty simple language though.
23:41:59 <cocreature> mgsloan: you can compose it in arbitrary ways and get the same results: it doesn‚Äôt work
23:42:18 <mgsloan> cocreature: Talking about ImpredicativeTypes?
23:42:20 <cocreature> yep
23:42:21 <ReinH> cocreature: Yes, it is composable in the same sense that Void is a monoid.
23:42:27 <mgsloan> Hah yea
23:42:33 <saurabhnanda> re optional/kwards is this the recommended approach? http://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html#v:createProcess
23:42:50 <cocreature> ReinH: nice analogy :)
23:43:04 <ReinH> saurabhnanda: I don't see any optional or keyword arguments there.
23:43:23 <saurabhnanda> ReinH: look at the first argument - CreateProcess
23:43:26 <ReinH> Oh, you mean the CreateProcess structure?
23:43:28 <saurabhnanda> http://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html#t:CreateProcess
23:43:58 <saurabhnanda> ReinH: Record data-type which represents a bunch of optional arguments that *may* be required to tweak your process creation
23:44:39 <ReinH> saurabhnanda: I like the approach taken by diagrams
23:44:44 <ReinH> e.g., http://projects.haskell.org/diagrams/doc/quickstart.html#attributes
23:44:54 <ReinH> Which is basically the same thing, but with nicer access.
23:45:05 <ReinH> Although had that interface been written today, it would probably use lenses.
23:46:08 <saurabhnanda> lenses -- another concept to learn.
23:46:17 <saurabhnanda> haven't reached there yet
23:46:20 <ReinH> @google SPJ lenses
23:46:22 <lambdabot> https://skillsmatter.com/podcast/home/lenses-compositional-data-access-and-manipulation
23:46:33 <ReinH> You can have an entire Haskell career without learning lenses. Probably.
23:46:49 <ReinH> At least a few years ago you definitely could.
23:47:57 <saurabhnanda> anyways, to my original question -- how is Ocaml different in the aspects I pointed out?
23:49:08 <shanemikel> isn't it impossible (and more or less unneccessary) to even type a monad in ocaml?
23:49:45 * hackagebot Chart 1.6 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.6 (TimDocker)
23:49:47 * hackagebot Chart-cairo 1.6 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.6 (TimDocker)
23:49:49 * hackagebot Chart-gtk 1.6 - Utility functions for using the chart library with GTK  https://hackage.haskell.org/package/Chart-gtk-1.6 (TimDocker)
23:51:02 <shanemikel> in any case, the compositional properties of pure functional haskell seem to be the magic of haskell EDSLs, how is ocaml on the edsl front?
23:52:36 <shanemikel> saurabhnanda: are you trying to pick a language to learn first? or to learn exclusively?
23:53:57 <saurabhnanda> shanemikel: I've already learnt Haskell to some extent. And I've come up with this list of irritants/issues. Now, I'm trying to see if OCaml is the silver-bullet or if I'm going to spend time in learning OCaml and them come up with a different set of issues/irritants.
23:54:15 <saurabhnanda> And secondly, which of these two languages can be introduced to a team of 10 devs building web-apps. Which is more "practical"
23:54:45 * hackagebot Chart-diagrams 1.6 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.6 (TimDocker)
23:55:15 <saurabhnanda> Working under the assumption, that the OCaml is not going to introduce any new programming concepts. I've already been introduced to new programming concepts in Haskell. 
23:56:23 <cocreature> saurabhnanda: there is no silver bullet :)
23:57:28 <saurabhnanda> However, the biggest advantage that ocaml has over haskell is that for most applications, an ocaml program will run faster, perhaps a lot faster, than an equivalent haskell program (although the haskell program may be much smaller, have fewer bugs, be prettier, etc.).  That's because lazy evaluation in haskell requires the system to wrap closures around unevaluated code and evaluate it later.  This has a cost, and it simply isn't the
23:57:28 <saurabhnanda> re in ocaml.
23:57:41 <saurabhnanda> that's a quote from https://mail.haskell.org/pipermail/haskell-cafe/2005-May/009850.html
23:57:45 <saurabhnanda> about 11 years old now.
23:57:51 <saurabhnanda> Does it still hold true? Any benchmarks?
23:58:10 <opqdonut> well ghc has gotten a lot better at optimizing code
23:58:33 <opqdonut> re: new concepts in ocaml, ocamls module system is pretty unique
23:58:49 <lyxia> it deals with namespacing quite nicely
23:59:08 <shanemikel> well, without marshalling stateful computation, a lot of the programming concepts you've learnt in haskell depend on referential transparency.. and AFAICT, though I'm a haskell newbie and never written a line of OCaml.. Also, it seems like haskell has evolved in the area of mutation with the ST monad, though I havnen't used it yet
23:59:39 <tero-> if all laziness is eliminated from a Haskell program, is there a fundamental reason for it to be slower than the equivalent OCaml program?
