00:00:07 <EvanR> because screw all the munging
00:00:19 <julianleviston> EvanR: why are we using hash(maps) as typed data structures, when they’re not? :)
00:00:24 <julianleviston> EvanR: lol ok :)
00:00:49 <julianleviston> EvanR: it’s all a bit of a strange comparison.
00:00:58 <julianleviston> EvanR: and really, why bother...
00:01:14 <julianleviston> EvanR: my apologies for stoking that particular fire.
00:01:36 <EvanR> i know people gripe about haskell records but off hand i cant think of a language which did it nicer, elm really?
00:01:44 <EvanR> the PHP array style is just no
00:01:54 <EvanR> (unrelated to elm)
00:02:49 <julianleviston> EvanR: depends on your definition of nice.
00:03:27 <codebje> EvanR, the row polymorphism of purescript is something I like
00:03:39 <dmj`> EvanR: ghc 8 will at least let us define the same field name across records in the same module... right
00:04:22 <ggVGc> EvanR: wouldn't it have been nice to, at a language level, be able to do something like `map {foo.bar.baz = 10} objects` 
00:04:33 <cocreature> is 'return f `ap` x `ap` y' a common style? I’m working with a codebase right now that uses this pretty much exclusively, but I’ve never seen it before
00:04:35 <ggVGc> without name clashes for foo, bar and baz
00:05:03 <liste> cocreature: is the code base old?
00:05:21 <cocreature> liste: probably yes (llvm-general)
00:05:25 <julianleviston> ggVGc: yeah, namespaces is something that Haskell is a bit lacking in if you like them.
00:05:45 <dmj`> :t \foo bar baz objects -> map (foo & bar & baz .~ 10) objects
00:05:45 <liste> cocreature: it's what eventually led to Applicative AFAIK
00:05:46 <lambdabot> Num b1 => a2 -> (a2 -> a1) -> ASetter a1 (a -> b) a3 b1 -> [a] -> [b]
00:06:01 <cocreature> liste: ah that makes sense, thanks!
00:07:12 <EvanR> ggVGc: yeah you have to use lens or something
00:07:23 * hackagebot language-javascript 0.5.14.4 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.4 (ErikDeCastroLopo)
00:07:24 <EvanR> but i dont think stuff that should exist should always exist at the languag elevel
00:07:32 <EvanR> unless its a domain specific language!
00:07:36 * hackagebot werewolf 0.4.9.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.9.0 (hjwylde)
00:07:36 * hackagebot language-javascript 0.5.14.4 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.4 (ErikDeCastroLopo)
00:08:33 <EvanR> ggVGc: and honestly ive never had to do that, since i never have used nested records like that
00:09:10 <EvanR> heavily nested record gets to me like oop
00:09:33 <EvanR> dmj`: benchmarks?
00:09:47 <ggVGc> EvanR: how do you avoid record nesting?
00:10:08 <EvanR> for application data it doesnt need to be deeply nested
00:10:16 <EvanR> like SQL databases arent nested
00:10:24 <dmj`> EvanR: of?
00:10:32 <EvanR> thread performance
00:10:40 <dmj`> there was a pdf, still looking
00:11:19 <ggVGc> EvanR: this is the model for my current haskell project, https://gist.github.com/53a23b6cc7096909470a
00:11:22 <ggVGc> it's fairly nested
00:11:24 <ggVGc> but it makes sense to me
00:11:27 <ggVGc> how could I improve it?
00:11:55 <EvanR> i dunno, whenever i have deeply nested stuff in the past, i end up having done it wrong, but if i nest it another way its wrong in another way
00:12:49 <EvanR> this is funny i was just working on a sequencer
00:13:47 <julianleviston> ggVGc: I tend not to use records much in Haskell
00:14:05 <ggVGc> julianleviston: how would you represent what I've got?
00:14:16 <julianleviston> ggVGc: as normal types.
00:14:35 <EvanR> ggVGc: ive been extracting how the "pure structure" of what im doing as much as possible, and its often not really a record anymore. but also for raw data it can be flattened out and organized differently at the top level
00:14:39 <julianleviston> ggVGc: I use records if I need to get at each bit often… but even then, I’m more likely to just write my own accessors.
00:15:18 <julianleviston> ggVGc: Haskell lets you compose types beautifully… so when you get at the core of the types that you’re trying to create, you don’t usually end up with recrods, IMHO.
00:15:57 <EvanR> ggVGc: check this structure out i have for the data stored between joints and on strokes of a glyph: http://lpaste.net/154835
00:15:59 <julianleviston> ggVGc: look at Conal Elliott’s work, and you’ll see what I mean. 
00:16:14 <ggVGc> yeah this makes sense to me, but I don't think my mental model of actually working is up to speed yet
00:16:19 <ggVGc> but I'll try to move away from records
00:16:22 <ggVGc> thanks
00:16:27 <julianleviston> ggVGc: it’s not a rule to follow!
00:16:33 <ggVGc> I know
00:16:40 <ggVGc> but I've been thinking in the same patterns
00:16:52 <ggVGc> I just end up with records because it's the most straightforward for me currently
00:16:54 <julianleviston> ggVGc: yes… that’s something to watch out for.
00:16:56 <ggVGc> but it als oirks me
00:16:58 <ggVGc> irks*
00:17:00 <EvanR> ggVGc: im working on a new sequencer right now... and im going to store the notes in a tree, where each branch is a subdivision of time
00:17:22 <julianleviston> EvanR:  that’s pretty fascinating (long time MIDI guy here)
00:17:45 <julianleviston> EvanR:  is it so you can get a flexible idea of time?
00:17:58 <EvanR> its really so i can do triplets without thinking
00:18:15 <ggVGc> EvanR: sounds good. My core model of this sequncer is a bit strange, since it's about mapping different seuqnces to each other. Hard to explain clerarly. Basically I don't have a "sequence of notes" I have sequqnces of triggers and interpretations of sequences of note values
00:18:22 <ggVGc> so they can be layers in sequences
00:18:23 <julianleviston> EvanR: I still love the idea of FRP Behaviors being mathematically pure functions that are uncollapsed into any resolution until you need them to be.
00:18:34 <julianleviston> ggVGc: that’s cool...
00:18:35 <EvanR> yes thats sort of where this is coming from
00:18:41 <julianleviston> ggVGc: I hate the way current sequencers work
00:18:56 <EvanR> you want pure structure and then materialize it as something "unclean" when reality hits
00:19:00 <ggVGc> julianleviston: same, hence why I'm finally building this. It's been in my mind for almost a decade now
00:19:02 <julianleviston> ggVGc: they’re intensely inflexible. Even Kyma has issues like this… 
00:19:07 <julianleviston> ggVGc: nice.
00:19:24 <ggVGc> julianleviston: right, which is why I'm working on the idea of sequencers sequencing eachother. It's called `metaseq`
00:19:27 <ggVGc> heh
00:19:32 <ggVGc> actualy already works quite well
00:19:41 <ggVGc> got a few things to add before I can make a tune with it
00:19:43 <EvanR> ggVGc: maybe youre dealing with graphs then
00:19:45 <julianleviston> ggVGc: though to be fair, Kyma allows you to buid meta sequencers.
00:19:58 <ggVGc> julianleviston: yeah, but it's all about the interface of how you do it
00:20:07 <ggVGc> you can metasequence in any DAW basically, but the workflow is too shit
00:20:08 <ggVGc> so you don't
00:20:08 <julianleviston> ggVGc: Kyma has a very nice interface.
00:20:26 <julianleviston> ggVGc: you can’t really metasequence any DAW.
00:20:38 <julianleviston> ggVGc: I like the idea of the “control” aspect connecting seamlessly to the “waveform” aspect.
00:21:15 <ggVGc> julianleviston: haven't actually used kyma myself. Might have a look. My sequencer is specifically built around the launchpad and apc40 mini though. I'm not making a computer GUI for it
00:21:15 <EvanR> yeah its two different things in C sound
00:21:20 <julianleviston> ggVGc: MaxMSP lets you do things along these lines… build your own whatevers, and connect them to other whatevers.
00:21:22 <ggVGc> so it's very much focused on the workflow
00:21:28 <ggVGc> and I haven't completely figured it out yet
00:21:28 <julianleviston> ggVGc: Kyma is quite expensive.
00:21:36 <EvanR> julianleviston: now that you mention it, i guess thats where people are coming from with the events = behavior thing in frp
00:21:47 <julianleviston> EvanR:  yep.
00:21:53 <EvanR> waveforms are just really fast events
00:21:56 <julianleviston> EvanR: the crossover is the problem though.
00:22:11 <julianleviston> EvanR: yeah, but they should be mathematical functions instead! (is fourier transforms the way back?)
00:22:14 <EvanR> and in all implementations, you cant treat it that way
00:22:29 <EvanR> DSP is too fast and events are too seldom
00:22:34 <EvanR> they dont jive
00:22:37 <julianleviston> EvanR: “control” is “event” and “sound” is “behaviour”
00:22:44 <julianleviston> EvanR:  but FRP lets you control sounds with sounds.
00:22:51 <EvanR> heh if we could do exact fourier that would be interesting
00:23:03 <EvanR> yes FM synth
00:23:07 <julianleviston> :)
00:24:29 <julianleviston> EvanR: I’m still pretty annoyed that events need to be there.
00:25:06 <EvanR> in DAW-like things?
00:25:27 <julianleviston> EvanR: oh, sorry. in FRP.
00:25:44 <EvanR> actual events like sustain pedal down really cant/shouldnt be a "waveform"
00:25:44 <julianleviston> EvanR: I spent a good two solid days thinking about this last week.
00:25:53 <EvanR> only two? lol
00:26:15 <julianleviston> EvanR: I’m not convinced… discrete events don’t exist in reality.
00:26:27 <julianleviston> EvanR: only in “sampled reality”
00:26:36 <EvanR> well you can model events with a travelling wave packet, but why ;)
00:26:52 <julianleviston> EvanR: so, there needs to be an approximated “this is the best data we have at the moment” type of thing, sure… is that all an event is?
00:26:58 <EvanR> its simpler if keydown is a thing that happened at a point in time, with 1 key
00:27:10 <EvanR> no thats not what events are at all
00:27:20 <EvanR> youre thinking of an update to a variable or something
00:27:23 <julianleviston> EvanR:  no, but it should be.
00:27:28 <EvanR> ... no
00:27:30 <julianleviston> EvanR:  yes.
00:27:37 <julianleviston> EvanR: an event doesn’t exist in reality.
00:27:39 <EvanR> keydown isnt an update to a variable
00:27:44 <julianleviston> EvanR: any more than a single point in time does.
00:27:49 <julianleviston> EvanR: plank, etc.
00:27:57 <ggVGc> would you say the big bang was an event or a behaviour?
00:28:11 <EvanR> the computer interacts in various ways with the world, 1 way is events
00:28:12 <julianleviston> ggVGc: that’s a bit of a crappy question to ask.
00:28:28 <julianleviston> ggVGc: given that none of us have a true understanding of what that is.
00:28:42 <EvanR> dont be lulled into thinking that events really updates to a state
00:28:45 <julianleviston> EvanR: what’s your definition of event?
00:28:53 <julianleviston> EvanR:  it’s a stream of data.
00:28:55 <EvanR> and you want notifications of the change
00:29:00 <julianleviston> EvanR:  right? :) a time-varying piece of data.
00:29:00 <EvanR> no youre thinking of behaviors
00:29:06 <julianleviston> EvanR: no I’m not.
00:29:10 <EvanR> yeah you are
00:29:12 <julianleviston> no.
00:29:19 <julianleviston> a behaviour is a mathematically pure function of time
00:29:24 <ggVGc> EvanR: aren't events actually updates to the state of the world?
00:29:29 <EvanR> there are events where theres no state that is changing
00:29:33 <EvanR> ... no
00:29:45 <EvanR> youre mixing it all up in your head
00:29:53 <julianleviston> EvanR: ok. enlighten me...
00:30:24 <EvanR> let me get my slides 
00:30:26 <julianleviston> EvanR: I *have* spent a huge amount of time researching this…
00:30:37 <julianleviston> EvanR:  but I’m happy to be wrong :) it’s an adventure.
00:31:30 <EvanR> so i have a list of examples which are really events
00:31:44 <liste> julianleviston: I approached the problem in terms of frequency vs. complex frequency (in engineering)
00:32:45 <julianleviston> liste: sure.
00:32:46 <EvanR> when a process gets a SIGHUP, it immediately must handle the signal and then resume what it was doing. the "occurrence" of the sighup, or the possibility of these occurrences is an event, not a behavior
00:33:03 <liste> frequency only describes the steady state of the system - the output is a function of time, but doesn't depend on external stimuli
00:33:21 <liste> complex frequency also describes how the system responds to signals from the outside
00:33:24 <EvanR> when a cron decides that a command needs to be run, it does so. the occurrence of a cron-task at some point in time, or the list of cron-scheduled commands is an event
00:33:25 <julianleviston> liste: sure.
00:33:50 <EvanR> when a server has a listening socket, there are connections from the outside world that must be handled right now, this is an event
00:34:40 <julianleviston> EvanR: so far you’re confirming what I said.
00:37:14 <EvanR> what youre trying to assert is that in each of these cases there is some state which is set to A and then setting it to B "is an event" (perhaps with the value (A,B))
00:37:14 <EvanR> but there isnt
00:37:14 <julianleviston> no, that’s my description of the model of the record of it.
00:37:14 <julianleviston> nothing to do with the actual thing.
00:37:14 <EvanR> theres no record for this stuff
00:37:14 <julianleviston> and… if you’re going to “type” it, then you have to do that
00:37:14 <julianleviston> EvanR: well, the moment there’s a type, then there’s a record.
00:37:14 <EvanR> huh
00:37:14 <julianleviston> EvanR: as in… the capacity to “keep” data of this.
00:37:14 <julianleviston> If I tell you hey… String.
00:37:14 <julianleviston> String implies the capacity to store or work with a certain shape...
00:37:14 <julianleviston> you don’t *have to* store it.
00:37:14 <julianleviston> but you can.
00:37:14 <EvanR> you dont have to keep the string to handle the event
00:37:14 <julianleviston> in fact you have to “store” it to use it in the computer.
00:37:14 <EvanR> yes you can save it
00:37:17 <julianleviston> EvanR: yet. We’re saying the same thing.
00:37:21 <julianleviston> yep*
00:37:31 <EvanR> mutable storage is actually the natural transformation from the event functor to the behavior functor ;)
00:37:58 <julianleviston> EvanR: that’s not relevant for what we’re talking about.
00:38:10 <EvanR> its relevant if you want to see why they are different things
00:38:15 <julianleviston> EvanR: (sigh)
00:38:26 <EvanR> events dont have anything to do with storage
00:38:34 <julianleviston> EvanR: any time something has type it does.
00:38:40 <EvanR> in some frameworks though, they have mixed all three into 1 type
00:38:43 <julianleviston> EvanR: otherwise you don’t need type.
00:38:45 <EvanR> "has type"
00:38:49 <EvanR> yes you do
00:38:56 <julianleviston> EvanR: why?
00:39:02 <EvanR> so you can handle events
00:39:05 <julianleviston> EvanR: this is a silly conversation.
00:39:13 <julianleviston> EvanR:  you’re saying the same thing as me.
00:39:19 <EvanR> not really
00:39:22 <julianleviston> yes
00:39:23 <julianleviston> really
00:39:23 <julianleviston> :)
00:39:33 <julianleviston> you use different words, is all
00:39:40 <EvanR> im using the same words
00:39:44 <julianleviston> god
00:40:26 <EvanR> here is the full description of an event-only algebra
00:41:12 <EvanR> assume that you have 2 kinds of hardware, 1 kind emits events of a certain type a, and 1 kind accepts values at any time and causes some effects, such as a hard drive or NIC cards
00:41:33 <EvanR> and that value accepted is type b
00:42:01 <EvanR> now you can write programs to process events and control the accepting hardware using various languages, heres the simplest one
00:42:17 <EvanR> E is a functor, so fmap :: (a -> b) -> E a -> E b
00:42:55 <EvanR> so if you are given the E A representing the emitting hardware, then you can create an E B to control the accepting hardware by using fmap and a pure function
00:43:23 <julianleviston> EvanR: No doubt.
00:44:14 <EvanR> now when you go to run this program, the emitter will simply control the acceptor hardware without anyone ever considering storage, continuity, or even time
00:44:33 <julianleviston> EvanR: yep.
00:44:57 <EvanR> the key to events, in this model, is that the emitter is doing the driving
00:45:03 <julianleviston> EvanR:  yep.
00:45:10 <EvanR> it decides when and what value to emit
00:45:29 <EvanR> so that distinguishes it from a behavior-like system, which i didnt describe, but i can
00:45:37 <EvanR> in that case it is the opposite situation
00:45:50 <julianleviston> EvanR: it’s cool. You didn’t really understand what I was saying, but that’s no doubt my fault.
00:46:09 <julianleviston> EvanR: so, sorry about that.
00:46:38 <EvanR> if you have polling hardware or OS functionality, such as the audio output thread, then it will want to query the state of a DSP system at random times
00:47:00 <EvanR> and this DSP system is really a behavior because you can check its state anytime
00:47:15 <julianleviston> EvanR: yup.
00:47:28 <julianleviston> EvanR: one might call it continuous :-P
00:47:41 <julianleviston> EvanR: or time-independant...
00:47:48 <EvanR> you can form polling programs by having an assortment of behaviors to compose, but its the polling demon which is driving the action, and in this case it is asking for a value not injecting its own value
00:48:02 <julianleviston> EvanR: even though a function that asked said system what its “state” is might be called dependant on time ;-) (or a funciton of time)
00:48:05 <EvanR> well the clock is one of these pollable resources
00:48:16 <EvanR> so thats where time CAN come in if you want
00:48:30 <julianleviston> EvanR: yep.
00:48:33 <EvanR> but other than that, the polling / emitting demons are really symmetric
00:49:15 <julianleviston> EvanR: anyway, thanks for that. It’s exactly how I saw it before.
00:49:32 <julianleviston> EvanR: the thing that I was interested in discussing was whether events are actually behaviors.
00:49:35 <EvanR> event systems and polling systems can only interact in one way!
00:49:39 <julianleviston> EvanR: and I’m still feeling like they are.
00:49:48 <julianleviston> EvanR: though not in the Conal-described FRP system obviously.
00:49:51 <EvanR> through something that acts precisely like a mutable variable that saves the last occurrence of an event
00:50:23 <EvanR> uhm... i just describe how they are exactly opposite, not the same
00:50:33 <julianleviston> EvanR: in order to grok what I’m proposing, though, you’ll have to jettison your current understanding of things.
00:50:45 <EvanR> you just agreed with everything i said
00:50:54 <julianleviston> EvanR:  yeah, you did. And in that model, I appreciate what you’re saying. 
00:50:58 <julianleviston> EvanR: yep.
00:51:08 <julianleviston> EvanR: FRP is *one* way of modeling the universe.
00:51:18 <EvanR> none of this is frp
00:51:26 <julianleviston> what is it? “truth"?
00:51:27 <julianleviston> lol
00:51:45 <julianleviston> EvanR: it’s totally the way FRP models the universe.
00:52:12 <EvanR> maybe some lib called frp but no
00:52:35 <julianleviston> EvanR: seems remarkably similar to Conal’s model he calls FRP to me.
00:52:38 <EvanR> my description had nothing to do with time or continuity
00:52:45 <julianleviston> EvanR: sure it did.
00:52:46 <EvanR> no it isnt
00:52:59 <julianleviston> EvanR:  you mentioned time a lot. Events happen at points in time, for example, in that model you described.
00:53:01 <EvanR> he chimes in here periodically to say so ;)
00:53:34 <EvanR> events happen, and polls happen, they are symmetric, but they arent organized into any time continuum
00:53:52 <EvanR> no "current time" is attached to anything
00:54:00 <julianleviston> EvanR: what “space” can something “happen” in? if not spacetime?
00:54:03 <EvanR> and values dont change with time
00:54:19 <EvanR> its abstract
00:54:24 <julianleviston> EvanR: riiight
00:54:30 <EvanR> like quantum particle interactions
00:54:36 <julianleviston> EvanR: I’m not entirely sure what you’re talking about then.
00:54:44 <julianleviston> EvanR: or how it’s useful to anything or anyone.
00:54:45 <EvanR> ... i know!
00:55:07 <EvanR> you misunderstood me the entire time and didnt know it 
00:55:18 <julianleviston> EvanR: pretty sure I didn’t misunderstand you at all.
00:55:54 <julianleviston> EvanR: that was me saying you can’t have events outside of time.
00:56:04 <EvanR> you can
00:56:11 <julianleviston> EvanR: give me an example?
00:56:34 <EvanR> ill go through the event example again and point out how time is not involved
00:57:04 <julianleviston> righto
00:59:31 <EvanR> first we define what events we are given. emitter :: E a. thats it. next we define the operations we can do on events: fmap :: (a -> b) -> E a -> E b. ok. and what is an event program? it is a value of type (E a -> E b). finally what is the meaning of such a program. it is...
00:59:53 <julianleviston> EvanR: in order to program though you have to have change… right?
01:00:04 <julianleviston> EvanR: so one of the base assumptions of that algebra is difference, isn’t it?
01:00:26 <julianleviston> EvanR:  I mean, aside from the fact that you’re using the entirity of Haskell to express this.
01:00:38 <julianleviston> entirety*
01:00:56 <EvanR> given a demon of type ((a -> IO ()) -> IO ()) who needs an event handler, then by providing an IO b, i can get an a -> IO () for the demon, who can now run. 
01:01:17 <EvanR> (a and b were swapped when i went to the operational semantics)
01:01:33 <julianleviston> EvanR: hang on.
01:01:39 <julianleviston> EvanR: That’s all written in Haskell.
01:01:50 <julianleviston> EvanR: which implies a universe of change.
01:01:54 <EvanR> its coincidentally like haskell
01:02:23 <EvanR> i will remove the ambiguity on IO by describing what the meaning of this demon is
01:02:33 <julianleviston> EvanR: all of your code is predicated on something more than just peano arithmetic.
01:02:41 <julianleviston> EvanR:  isn’t it?
01:03:05 <julianleviston> EvanR: even peano arithmetic implies change.
01:03:08 <julianleviston> EvanR: which implies time.
01:03:13 <julianleviston> EvanR: have I missed something?
01:03:25 <EvanR> the demon is a source of arbitrary values of type a, for each such value he assigns a value of type IO (). so he consists of a universe of (a, IO ()) pairs
01:03:35 <EvanR> and thats it
01:03:43 <julianleviston> EvanR: all of that implies time.
01:03:49 <EvanR> none of it does
01:03:50 <julianleviston> EvanR: it’s implicit.
01:03:53 <EvanR> its just types
01:06:04 <julianleviston> EvanR: types imply time.
01:06:04 <julianleviston> EvanR: let alone IO.
01:06:04 <EvanR> you could include time in this discussion by going to behaviors and assuming there is a clock that can be polled
01:06:04 <EvanR> types imply time?
01:06:04 <julianleviston> sure
01:06:04 <julianleviston> types imply not types.
01:06:04 <EvanR> dunno about that
01:06:04 <julianleviston> ergo change
01:06:04 <julianleviston> which implies time
01:06:04 <EvanR> types imply not types?
01:06:04 <julianleviston> it seems so.
01:06:04 <julianleviston> the type Int implies the existence of things that are *not* Int.
01:06:04 <EvanR> i dont think thats the case
01:06:04 <julianleviston> ah ok.
01:06:04 <julianleviston> That’s fine.
01:06:07 <EvanR> there are languages with 1 type
01:06:17 <julianleviston> I’m not entirely sure what you’re attempting to explain.
01:06:24 <Xe> EvanR: C is a great example!
01:06:26 <julianleviston> that is to say… I haven’t seen anything new yet.
01:09:06 <julianleviston> EvanR: generally, if you can express something in a language, then there has to be someone or something expressing the thing, which implies time. 
01:09:39 <julianleviston> EvanR:  it might not be in the language’s primitives, but that’s largely irrelevant - it just means it’s part of the assumptions made in order for the language to exist.
01:10:44 <julianleviston> EvanR: if your langauge includes time, then it can start to talk about its own development and processes that are included in its creation… if not, I guess that it just can’t talk about that. That doesn’t mean they’re not *there* though!
01:11:35 <rydgel> julianleviston: hi, I did try to make a new gloss/glfw-b project and did encounter the same ghci error than you
01:11:38 <rydgel> just FYI
01:12:16 <julianleviston> rydgel:  oh thanks :) I went to tell you last night but you’d disappeared that SDL2 worked flawlessly as you anticipated (with a few tiny issues that were easily rectifyable)
01:12:19 <EvanR> thats very philosophical, but when i solve a triangle using law of cosines there is no time involved
01:12:27 <EvanR> its just a triangle
01:12:32 <EvanR> always was always will be
01:12:33 * hackagebot yeshql 0.2.0.1 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-0.2.0.1 (TobiasDammers)
01:12:55 <julianleviston> EvanR: only in your mind.
01:13:04 <EvanR> or nowhere!
01:13:12 <julianleviston> EvanR: for the trangle to have existence, or the problem to exist, there has to be space, and time.
01:13:24 <EvanR> its doesnt really exist obv
01:13:26 <julianleviston> EvanR: the mathematical model doesn’t include it because it’s not relevant.
01:13:47 <julianleviston> EvanR: but the mathematical model isn’t concerned with its own predicated existence, obviously.
01:13:58 <julianleviston> EvanR: that’s to say… it doesn’t care what “machine” its “running” on.
01:13:59 <EvanR> yes so why are you?
01:14:13 <julianleviston> EvanR: because you’re talking about computable models.
01:14:31 <EvanR> i think its coincidence that anything i said has anything to do with computers
01:14:31 <julianleviston> EvanR: and the concept of events implies a movement of something in time.
01:14:43 <julianleviston> EvanR: computers in the sense of something that undergoes a process
01:14:52 <rydgel> julianleviston: Yeah sorry I had to go very quickly, but when I was back you were not here
01:15:07 <julianleviston> EvanR: for there to be an “event” “emitted” there has to be “emitting”. That is a process. That implies time
01:15:20 <EvanR> there is all quite vague, i did my best to say stuff that had substance but this is about as far as i can go with philosophy of time and existence of the abstract
01:15:22 <julianleviston> EvanR: if we don’t include it in the model because it’s not important, that’s fine… but it has to still be there
01:15:55 <julianleviston> EvanR: this reminds me of imperative languages not being aware of their implicit sequencing operations (the “invisible ;”)
01:16:11 <julianleviston> they can be unaware of it… that’s fine… but it still impacts things
01:16:46 <EvanR> the very nature of models is that there are things not included in it
01:16:51 <julianleviston> EvanR: sure.
01:17:01 <julianleviston> EvanR: so let’s get back to what you were talking about.
01:17:03 <julianleviston> EvanR: events.
01:17:06 <EvanR> lets not
01:17:06 <julianleviston> EvanR:  without time.
01:17:14 <julianleviston> EvanR: oh?
01:17:17 <julianleviston> EvanR:  have I annoyed you?
01:17:22 <julianleviston> EvanR: apologies.
01:17:33 * hackagebot yaml-config 0.4.0 - Configuration management  https://hackage.haskell.org/package/yaml-config-0.4.0 (FedorGogolev)
01:17:46 <julianleviston> EvanR: I was actually quite interested in what you were saying.
01:17:52 <rydgel> are you guys talking about events in FRP?
01:18:00 <julianleviston> rydgel: not exactly.
01:18:07 <rydgel> oh ok
01:18:08 <rydgel> :)
01:18:16 <julianleviston> rydgel: it’s a different model of things… as far as I can understand.
01:18:27 <julianleviston> rydgel: one that elides time.
01:20:24 <julianleviston> rydgel: I still find using SDL pretty crappy at GHCi… It might be because it keeps a handle to the window open until the GHCi session is quit. Probably just my lack of understanding of what’s transpiring.
01:22:37 <julianleviston> rydgel: it’s all good for now, though. Still have to work on a better way to rebuild the tutorial before I can get to adding anything new to it anyway :)
01:22:40 <rydgel> julianleviston: yeah, it's not that great. Yesterday I was looking for a way to develop a game "as the game runs". But it appears the way Haskell's runtime is, it's pretty much difficult.
01:23:12 <rydgel> julianleviston: What was the URL of your website already?
01:23:13 <julianleviston> rydgel: oh yeah, there’s a really nice way to do that in ClojureScript I was looking for in Haskell but nothing similar springs to mind. There have been *some* works done in that space...
01:23:23 <julianleviston> rydgel: http://happylearnhaskelltutorial.com
01:23:41 <rydgel> julianleviston: thanks
01:24:21 <julianleviston> rydgel: there’s a tool called figwheel in CLJS that works really well for that. It’s really cool… and Elm has some kind of stuff around that, but doesn’t let you keep the current state “in memory” while it refreshes… only the CLJS one I’ve seen does it so far.
01:24:44 <julianleviston> rydgel: of course, this is just for browser-based stuff.
01:25:10 <rydgel> julianleviston: having a JVM helps a lot. I saw similar things used by Notch (the guy who mades Minecraft) while developing
01:25:49 <julianleviston> rydgel: yeah, there are *some* dynamic code-reloading type things in Haskell… but the one I saw uses a pretty hacky thing where things can get quite messy.
01:25:51 <julianleviston> See if I can find it
01:26:12 <julianleviston> rydgel:  oh yeah this is it… http://chrisdone.com/posts/ghci-reload
01:26:42 <julianleviston> rydgel: he’s made some progress in having bindings stay around while reloading.
01:27:17 <rydgel> julianleviston: interesting
01:27:40 <julianleviston> rydgel: Wish it was more readily “first class” supported by GHCi
01:30:14 <julianleviston> rydgel: let alone how smalltalk works :) 
01:32:22 <rydgel> julianleviston: yeah :)
01:33:02 <rydgel> damn I just want to make another game with Haskell now
01:35:03 <julianleviston> rydgel: haha :)
01:35:09 <julianleviston> rydgel: programming is so fun :)
01:37:05 <rydgel> julianleviston: yeah, I just need to find an idea. That's always the problem ;)
01:38:12 <julianleviston> rydgel: laser reflection puzzler with mirrors?
01:38:53 <kuznero> Hi All!
01:38:55 <julianleviston> rydgel: squad based adventure game where the members have different traits and have chance to disobey and follow their own whims? :)
01:40:01 <rydgel> julianleviston: haha awesome :)
01:40:22 <rydgel> julianleviston: I was thinking about making a game like the first doom/wolfenstein
01:40:30 <rydgel> julianleviston: the rendering would be interesting
01:40:35 <julianleviston> rydgel: I always wanted a game like bomberman, but with the ability to switch between 3D FPS and 2D top-down.
01:40:40 <julianleviston> rydgel: yeah! :)
01:40:48 <ggVGc> compiling ghcjs froze my computer and ran out of memory :(
01:40:55 <julianleviston> ggVGc: aw :(
01:40:59 <julianleviston> kuznero: heya :)
01:41:30 <ggVGc> second try, this time with chromium closed
01:42:19 <julianleviston> ggVGc: I think ryan trinkle’s reflex-dom repo has some kinda magic already-compiled ones or something? https://github.com/reflex-frp/reflex-platform
01:42:39 <julianleviston> ggVGc: sorry, just a vague recollection. Nothing concrete, I’m afraid.
01:42:47 <ggVGc> julianleviston: trying to use it with stak
01:42:49 <ggVGc> stack*
01:44:22 <ggVGc> I have to say, compiling software isn't the most fun
01:44:26 <rydgel> ggVGc: maybe try to add "--jobs=1" to do less compilation in parallel. That might help.
01:44:33 <ggVGc> I remember what it was like being a C++ dev now..
01:44:44 <ggVGc> rydgel: yeah if it fails this time I'll try that
01:44:53 <ggVGc> seems okay ow
01:45:00 <ggVGc> I think chromium was using a gig at least
01:45:09 <rydgel> ggVGc: yeah cause bunch of lib has already been compiled :)
01:45:34 <ggVGc> true
01:45:58 <ggVGc> I used to think watching scrolling compilation output was cool, like a decade ago
01:46:01 <ggVGc> not so much anymore
01:47:50 <rydgel> ggVGc: When I was on gentoo, compilation was like a screensaver
01:48:10 <anohigisavay> hi
01:48:31 <liste> hi anohigisavay!
01:48:33 <anohigisavay> i'm not sure i understand the fixpoint definition: fix f = let x = f x in f
01:48:41 <anohigisavay> let x = f x in x
01:49:01 <anohigisavay> what if its fix2 f = let x = f x in x + 3
01:49:04 <liste> anohigisavay: what doubts do you have?
01:49:10 <anohigisavay> what does fix2 (+2) expand to?
01:50:25 <lyxia> well you're not supposed to pass strict functions to fix
01:50:48 <lyxia> though depending on the Num type (+2) might not be
01:51:03 <anohigisavay> lyxia: yea i know that, and i can see how fix2 (const 4) gives 7
01:51:12 <liste> anohigisavay: let's do it manually: let x = (+2) x in x + 3 -> ((((+2) (+2)) (+2)) (+2) ...) + 3
01:52:40 <anohigisavay> _(:з」∠)_ 
01:53:53 <liste> otoh, let x = (2+) x in x + 3 would be (2+2+2+2+2+...) + 3
01:54:03 <lyxia> you mean ((((...) + 2) + 2) + 2) + 3
01:54:09 <liste> lyxia: yeah
01:54:50 <anohigisavay> i actually don't quite get how the expansion works
01:55:05 <anohigisavay> what do all the `x`s really stand for?
01:55:31 <lyxia> the least fixed point of f
01:57:01 <anohigisavay> say for one iteratino
01:57:05 <anohigisavay> *iteration
01:57:15 <lyxia> operationally it is constructed by starting with a black hole, apply f to it, and put the result in the black hole.
01:58:18 <rydgel> In real usage tho, I never actually really uses fix.
01:58:26 <lyxia> you start with x = f x, and because x = f x you can replace x with f x (in the LHS), so x = f (f x). Repeat.
01:58:33 <rydgel> Fix on the other part is more useful..
01:59:09 <anohigisavay> in the second iteration, why does the `f` function get a blackhole instead of a blackhole + 3?
01:59:10 <lyxia> RHS
01:59:40 <verement> > fix (\fac n -> if n == 1 then 1 else n * fac (n - 1)) 5
01:59:42 <lambdabot>  120
02:00:33 <liste> anohigisavay: "fix2 f" is equivalent to "(fix f) + 3"
02:02:25 <liste> you can replace the "let x = f x in x" with "fix f" in the definition of fix2 
02:02:29 <anohigisavay> liste: so the second in `let x = f x in x` doesn't really mean the third x in the past iteration?
02:03:01 <anohigisavay> wait. did i get the operator precedence right?
02:03:09 <anohigisavay> i really meant let x = f x in (x + 3)
02:03:34 <liste> anohigisavay: there's no +3 before "in"
02:03:52 <liste> so x already is fix f
02:05:27 <liste> let x = f x + 3 in x otoh would be different
02:06:42 <anohigisavay> ahhhhhhhhh i see
02:06:43 <anohigisavay> xD
02:07:51 <anohigisavay> well but then i believe fix f does not really mean f (fix f) but f (f (f ...)
02:08:04 <lyxia> how's that different
02:08:07 <liste> anohigisavay: they're the same thing
02:08:35 <anohigisavay> if the first, then, there must be more `+3`s in the expansion
02:08:37 <liste> fix f -> f (fix f) -> f (f (fix f)) -> f (f (f ...))
02:10:02 <dramforever> anohigisavay: This might be confusing, but in Haskell, regular variable bindings can recurse, meaning that in let x = ... x ... in ..., the two x's are the same variable
02:10:31 <dramforever> just like in map f (x:xs) = f x : map f xs, where the two map's are the same function
02:10:41 <dramforever> (well, I do hope you get the idea)
02:11:08 <rydgel> fix (2+) = 2 + (fix (2+)) = 2 + (2 + fix (2+)) and so on
02:12:27 <anohigisavay> dramforever: _(:з」∠)_ i think i get the idea
02:12:49 <anohigisavay> i got the idea
02:13:34 <dramforever> good for you :)
02:15:26 <anohigisavay> cool!!!!!!
02:15:30 <anohigisavay> haha, thank you guys :D
02:52:41 <mettekou> Is there an idiomatic way to specify typeclass instances for lists of certain types which behave differently than the general instance for lists? For example, Show does this by providing showList to allow [Char] to be shown as a string. But is there a better way?
02:56:41 <lyxia> create a newtype
03:12:39 * hackagebot array-primops 0.2.0.0 - Extra foreign primops for primitive arrays  https://hackage.haskell.org/package/array-primops-0.2.0.0 (AndrasKovacs)
03:27:39 * hackagebot immortal 0.2.2 - Spawn threads that never die (unless told to do so)  https://hackage.haskell.org/package/immortal-0.2.2 (RomanCheplyaka)
03:29:06 <EvanR> there can be only one
03:52:08 <jlm> :q
03:52:41 * hackagebot werewolf 0.4.10.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.10.0 (hjwylde)
03:53:14 <Xandaros> https://hackage.haskell.org/package/servant-client-0.4.4.6/docs/Servant-Client.html - in the first code block: Can somebody explain to me what magic is happening in the last two lines? (Esp. the syntax)
03:54:27 <liste> > let (f, g) = ((+1), (*2)) in f (g 6)
03:54:29 <lambdabot>  13
03:57:52 <Xandaros> liste: Ah! Took me a minute, but I got there. I did not realise you can do that sort of thing on the top-level - interesting
04:00:21 <hexagoxel> (:<|>) is both a type constructor and a data constructor; the code block does not seem to make that clear.
04:02:41 * hackagebot yeshql 0.3.0.0 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-0.3.0.0 (TobiasDammers)
04:03:30 <Xandaros> hexagoxel: Funnily enough, that was immediately obvious to me. I struggled with understanding the pattern matching on top level... go figure
04:04:33 <Xandaros> (To be perfectly honest, I do actually think it makes it pretty clear)
04:06:30 <hexagoxel> (in the source, there is `type Client (a :<|> b) = Client a :<|> Client b`, which i find more clear.)
04:07:41 <hexagoxel> but yeah, pattern-matching definitions at top level are not too common.
04:08:43 <hexagoxel> (hmm, is the full syntax allowed? can you do lazy/bangpattern on those?)
04:12:41 * hackagebot yeshql 0.3.0.2 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-0.3.0.2 (TobiasDammers)
04:18:02 <fr33domlover> How do I derive a trivial exception type these days? Why does GHC let "instance Exception X" build if I didn't declare X as a Typeable instance? Do I need XDeriveTypeable here?
04:26:05 <liste> hexagoel: RecordWildCards at leat works: http://www.haskellforall.com/2012/07/first-class-modules-without-defaults.html
04:30:51 <fr33domlover> alternatively, how to i -ddump-deriv with stack build? it doesn't show me the output
04:37:42 * hackagebot task-distribution 0.1.0.3 - Distributed processing of changing tasks  https://hackage.haskell.org/package/task-distribution-0.1.0.3 (axm)
04:44:39 <MarcelineVQ> fr33domlover: you can use -ddump-to-file in your ghc-options, you may need to use --force-dirty when you'd want -fforce-recomp since I'm not sure the latter works, dump flags can cause a bit of a file mess if you run ghci with them on so be careful
04:47:14 <saurabhnanda> hey, was reading through Facebook's Haxl post and checked the bugs, etc they've fixed in GHC eg. https://phabricator.haskell.org/rGHCa11f71eff15ba2706cbb2ee29aaf7350909e0d2f
04:47:38 <saurabhnanda> Surprised to see C/C++ in GHC. Isn't GHC written in Haskell itself?
04:47:58 <cocreature> the runtime is written in C
04:48:03 <quchen> There's no C++ in GHC.
04:48:52 <fr33domlover> MarcelineVQ, still doesn't work :-/ but what i really want is to know why some packages which define Exception classes use "deriving Typeable" and "LANGUAGE DeriveDataTypeable" while my code somehow builds with neither
04:49:12 <fr33domlover> *Exception instances
04:49:28 <bergmark> fr33domlover: typeable instances are implicit as of ghc 7.10
04:49:33 <MarcelineVQ> Doesn't work?
04:50:10 <fr33domlover> MarcelineVQ, maybe i'm using it wrong, dunno :P
04:50:21 <fr33domlover> bergmark, thanks
04:50:31 <fr33domlover> bergmark, what about the extension though?
04:50:43 <fr33domlover> any reason they use it while it seems i don't need to?
04:52:02 <MarcelineVQ> Where are you looking for the dumped files? they should be in .stack_work/dist/blah/Cabalblah/build/
04:53:08 <bergmark> fr33domlover: same with the extension, you only need it if you want to compile with ghc < 7.10
04:53:37 <bergmark> ... or if you want do derive Data
04:53:52 <quchen> saurabhnanda: FWIW here's the cloc of the GHC folder http://lpaste.net/154853
04:54:18 <quchen> saurabhnanda: Might be inaccurate because the dir is dirty though, but it gives you a rough overview
04:54:40 <cocreature> that’s a scary amount of C
04:54:57 <quchen> It's cloc output, so take it with a grain of salt
04:55:04 <cocreature> ofc
04:55:09 <quchen> There certainly isn't Fortran 77 in GHC :_D
04:55:54 <cocreature> I didn’t even know objective c++ was a thing
04:58:03 <quchen> It's also interesting that you could fit all of the productive C code into the blank lines of the Haskell code ;-)
05:05:27 <seishun> what should my next step be after finishing lyah (and seemingly with a clear understanding of the concepts described there)?
05:08:56 <MarcelineVQ> seishun: Try writing something small for yourself, https://wiki.haskell.org/Roll_your_own_IRC_bot maybe, and/or try out the nicta exercises https://github.com/NICTA/course
05:09:30 <MarcelineVQ> actually I read that wrong, I'd reccomend http://www.seas.upenn.edu/~cis194/spring13/ first, then those
05:11:11 <seishun> the cis thing has just the basics
05:11:34 <MarcelineVQ> It has tasks, which lyah doesn't
05:20:13 <saurabhnanda> seishun: why are you learning haskell? To do ninja-level stuff in type-theory or do regular business apps? If the latter, try writing a regular business web-app which is more than just CRUD. Throw in DB access, Redis caching, logging, and oAuth. You'll learn a lot about where Haskell shines, and where it doesn't.
05:22:19 <ondrejj> Hello. I create new Data.Vector.Storable.Mutable vector of a size of an image, write to it, freeze (or unsafeFreeze) it and then call unsafeWith to create an image using Xlib. However when I have 3 or more images they get mangled due to some memory problems. Should I use something else than freeze or unsafeWith or is there other problem with this approach?
05:23:39 <ondrejj> * and by mangled I mean that the last two are usually (90 % of runs) ok, while the first one is just noise in the colors of the third picture or the second picture is copied over it
05:24:22 <ondrejj> and to write to the mutable vector I am using the ST monad
05:24:28 <saurabhnanda> why is so much C required in Haskell code? Especially for the garbage collector? Can't that stuff be written in Haskell itself?
05:29:05 <rydgel> saurabhnanda: It's easier to do nasty things with memory in C I think.
05:29:20 <ggVGc> does anyone have a working stack.yaml for building a project with ghcjs?
05:30:20 <rydgel> ggVGc: try https://github.com/tolysz/ghcjs-stack/blob/master/stack.yaml
05:30:55 <ironChicken> my ghc-compiled program (which uses a foreign library) is randomly segfaulting
05:31:17 <ironChicken> when i run it with lots of Debug.Trace.trace calls and letting stdout and stderr go to the terminal it runs without the segfault
05:31:33 <ironChicken> but then if i redirect stdout and stderr to a file, it segfaults
05:31:47 <ironChicken> any ideas what might be going on here?
05:31:57 <ironChicken> could it be a GC issue?
05:32:55 <ironChicken> e.g., perhaps the additional running time needed to write to the terminal might be allowing resources to be freed? or something?
05:35:47 <ondrejj> ironChicken: I've recently came across a function which could maybe help you if you have the pointer http://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:touchForeignPtr
05:36:46 <ironChicken> ondrejj: oh yes, i've noticed that before but never really thought about using it
05:36:57 <ironChicken> and yes, i do have the pointer
05:47:45 <deni> what's the policy is you want to change the namespace of your library that's already on hackage (provided the new namespace isn't taken)
05:48:08 <deni> I mean I kinda get that it's not nice but if the lib was marked as experimental is that kinda ok atleast?
05:50:58 <ondrejj> ironChicken: did it help you? The function helped with my question I asked here earlier :-)
05:51:09 <ondrejj> ironChicken: so thank you for asking
05:52:45 * hackagebot lackey 0.1.1 - Generate Ruby consumers of Servant APIs.  https://hackage.haskell.org/package/lackey-0.1.1 (fozworth)
05:54:46 <ironChicken> ondrejj: i'm looking at a different thing right now, but i'll try soon and let you know
06:07:45 * hackagebot hdocs 0.4.4.1 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.4.4.1 (AlexandrRuchkin)
06:12:34 <Rumly> @unmtl
06:12:35 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
06:12:46 <Rumly> @unmtl StateT s Monad a
06:12:46 <lambdabot> s -> Monad (a, s)
06:12:56 <Rumly> @help
06:12:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:13:02 <Rumly> @list
06:13:03 <lambdabot> What module?  Try @listmodules for some ideas.
06:13:08 <Rumly> @listmodules
06:13:08 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
06:14:06 <Rumly> @help unmtl
06:14:06 <lambdabot> unroll mtl monads
06:14:16 <Rumly> @help hoogle
06:14:16 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
06:14:25 <Rumly> @hoogle fmap
06:14:26 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:14:27 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
06:14:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:14:43 <dramforever> Rumly: /query lambdabot
06:15:00 <Rumly> oh sry :)
06:15:11 <dramforever> and talk in PM, rather than spamming the channel :) Thanks for being nice
06:43:47 * hackagebot servant 0.4.4.7 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4.7 (SoenkeHahn)
06:43:49 * hackagebot servant-server 0.4.4.7 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.7 (SoenkeHahn)
06:43:51 * hackagebot servant-client 0.4.4.7 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4.7 (SoenkeHahn)
06:43:53 * hackagebot shortcut-links 0.4.2.0 - Link shortcuts for use in text markup  https://hackage.haskell.org/package/shortcut-links-0.4.2.0 (Artyom)
06:43:55 * hackagebot servant-cassava 0.4.4.7 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.4.4.7 (SoenkeHahn)
06:47:30 <jgornick> Hey folks, I'm trying to set my ghc-options in my cabal file as ghc-options: -O -threaded -with-rtsopts="-V0". However, I keep getting "unexpected RTS argument: "-V0"" when trying to run my application. Thoughts?
06:48:56 <bergmark> i think you want to quote the whole flag, "-with-rtsopts=-V0"
06:48:57 * hackagebot servant-jquery 0.4.4.7 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4.7 (SoenkeHahn)
06:48:59 * hackagebot servant-blaze 0.4.4.7 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4.7 (SoenkeHahn)
06:49:01 * hackagebot servant-lucid 0.4.4.7 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4.7 (SoenkeHahn)
06:49:03 * hackagebot servant-mock 0.4.4.7 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.4.4.7 (SoenkeHahn)
06:49:05 * hackagebot servant-examples 0.4.4.7 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4.7 (SoenkeHahn)
06:50:22 <jgornick> bergmark: Let me give that a shot.
06:53:11 <jgornick> bergmark: That seemed to have worked! Is there any way that I can verify my running process has that flag set?
06:54:07 * hackagebot servant-docs 0.4.4.7 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4.7 (SoenkeHahn)
06:54:21 <bergmark> jgornick: i don't know
06:54:30 <jgornick> bergmark: No worries, thanks again!
06:55:57 <dramforever> hackagebot: So. It has come to this.
07:15:00 <vani> LambdaBot
07:48:20 <TaTo> hi all guys
07:53:59 <ggVGc> should I be using System.Random or Data.Random?
07:55:03 * hackagebot hesh 1.5.0 - the Haskell Extensible Shell: Haskell for Bash-style scripts  https://hackage.haskell.org/package/hesh-1.5.0 (ChrisForno)
07:55:05 * hackagebot webdriver 0.8.2 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.2 (AdamCurtis)
07:59:44 <shapr> johnw: have you tried to build the samples in the github library lately?
08:03:44 <byorgey> ggVGc: what is Data.Random? from the random-fu package?
08:03:52 <marrrk> I am trying to save a ByteString (an image) in a postgres database with persistent. But it doesn't seem to like my ByteString in the TH.
08:04:59 <marrrk> No instance for (aeson-0.9.0.1:Data.Aeson.Types.Class.FromJSON  ByteString)
08:05:20 <byorgey> ggVGc: they are very different, it depends on what you are trying to do.  System.Random gives you very basic random number generation.  random-fu gives you all sorts of nice things built on top
08:06:01 <marrrk> I don't think I'm even telling it to do any JSON with it.
08:08:49 <purelazy> hi
08:12:41 <xa0> :t lift
08:12:42 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
08:15:07 <purelazy> :t lift lift
08:15:08 <lambdabot> (Monad m, MonadTrans t, MonadTrans t1) => t ((->) (m a)) (t1 m a)
08:15:30 <purelazy> :t lift lift lift
08:15:32 <lambdabot>     Couldn't match kind ‘* -> *’ with ‘*’
08:15:32 <lambdabot>     When matching types
08:15:32 <lambdabot>       t0 :: (* -> *) -> * -> *
08:16:19 <xa0> :(
08:16:34 <purelazy> why the long face
08:17:56 <meoblast001> hi. i hope at least one of you is a triple M (monad making machine), because i have questions regarding monad making.... i'm working on a paypal client and i was originally having every request immediately operate in IO.... then i realised i don't want to give the user that much control because i would like to execute the requests in a context in which i can check that the access token is still valid, and if not renew it..
08:17:57 <meoblast001> . this sounds like a monad could help but i'm not reallly sure how to start
08:18:09 <meoblast001> i have this sort of "draft" idea which won't even compile... https://gist.github.com/meoblast001/fdc26efd8b4076453c5e
08:18:44 <meoblast001> but even if that would compile, i have no way of handling the scenario in which a return is executed
08:19:13 <meoblast001> and anything i can think of to return would not keep the monad lawful , since m >>= return  =  m
08:21:39 <purelazy> meoblast001 I only know the IO should be separated from pure code
08:22:27 <purelazy> the = that
08:22:30 <meoblast001> yeah in this case i'm trying to put the stuff necessary to make the request in the data type... then another "executer" function so to speak, will take this monad, and execute all functions in the chain in the IO context
08:23:22 <ski> (s/will take this monad/will take this monadic action/)
08:23:22 <meoblast001> take the first 4 parameters in the type, create the request, fire it, get response, pass it to the handler response... you then get another operation... repeat
08:23:56 <meoblast001> ski: hm true. i guess it's not a monad until i can make it one
08:23:58 <ski> the "user" here is a user of a module/library you want to write ?
08:24:36 <meoblast001> yes, correct
08:24:38 <ski> monads aren't values. `PayPalOperation' itself could perhaps be made into a monad. a value of type `PayPalOperation T' for some type `T' would then be a monadic action (a `PayPalOperation'-action)
08:25:01 <ski> (perhaps the "user" is just another part of your program. or perhaps one could attach plugins in some way)
08:25:38 <meoblast001> my idea was that for safety i would have the library automate the process of refreshing the access token and checking that the existing one is valid
08:25:53 <ski> i'm not sure what your worries about `return' was
08:26:02 <ski> (also i'm not sure what an "access token" would be here)
08:26:33 <meoblast001> oh sorry. access token is something the paypal API gives you which has an expiration date.. when that date passes, you need to perform a request to get a new one before doing any other activity with their API
08:27:03 <ski> ok
08:27:09 <meoblast001> my issue with return here is that if i just say "return 5" for my PayPalOperation Integer... then i really don't have a way to fill in anything in the structure
08:27:16 <meoblast001> because there is no request occurring here
08:28:03 <ski> and what kind of operations do you want your "user" to be able to perform ? only ones built out of some restricted set of primitive ones ? or perhaps (more or less) any `IO'-operations ?
08:28:10 <Akii> meoblast001: isn't that just OAuth2? https://hackage.haskell.org/package/hoauth2-0.2.2/docs/Network-OAuth2-OAuth2.html
08:28:36 <Gurkenglas> Given a directory of lpastes, how do I add the imports they're missing without too much work?
08:29:04 <ski> meoblast001 : well, for that matter, if you have more than one request, how would you know what to fill in into the structure ? the monadic framework presupposes that you can compose smaller actions into larger ones
08:29:27 <meoblast001> Akii: i tried that oauth2 library and there were some missing or extra parameters the library had which PayPal kept rejecting
08:29:37 <Akii> ah ok
08:29:55 <meoblast001> i don't know if the library is wrong or if paypal implements oauth 2 incorrectly
08:30:45 <meoblast001> ski: during a bind, the function would then be stored... hm.. i'm not really sure
08:30:50 <ski> meoblast001 : anyway, you could possibly try making more than one alternative in your data structure. e.g. `Return a' could be another one
08:30:54 <Akii> everyone implements oauth differently unfortunately
08:30:55 <meoblast001> are there any libraries which do something similar to this which i could use as an example?
08:31:45 <ski> meoblast001 : probably this would look nicer to write, using the GADT syntax. and perhaps your record there should then be pulled into a separate (helper) type
08:32:02 <meoblast001> GADT syntax?
08:32:10 <ski> writing like
08:32:22 <ski>   data PayPalOperation :: * -> *
08:32:23 <ski>     where
08:32:32 <ski>     Return :: a -> PayPalOperation a
08:32:41 <ski>     Bind :: PayPalOperation a -> (a -> PayPalOperation b) -> PayPalOperation b
08:33:00 <ski>     PayPalOperation {ppoReqType :: RequestType,...} -> PayPalOperation b
08:33:07 <ski> or something like that
08:33:21 <ski> (er, s/->/::/, iirc, for the last one)
08:33:52 <ski> iow, in GADT syntax, you explicitly give the type signatures of the data constructors, instead of just writing the data constructor followed by the argument types
08:34:18 <meoblast001> aah okay
08:34:40 <ski> (the `:: * -> *' part above is strictly speaking not necessary. you could write `a' there instead. i just prefer using that syntax, when the type parameter isn't the same in all the return types of the data constructors)
08:34:47 <Gurkenglas> I've put "module Control.Monad.Trans.Traversable between language pragmas and imports of a file, and now want to import it in another file in the same folder. It can't find the module.
08:34:56 <meoblast001> okay this helps a bit with syntax but... i'm still sort of unsure on the concept here
08:35:11 <meoblast001> even having something like "ppoHandleResponse :: a -> PayPalOperation b" does not work
08:35:15 <Gurkenglas> (also put a where after that module line)
08:35:18 <meoblast001> the compiler complains it doesn't know what a b is
08:35:25 <ski> i'm not entirely sure what the idea with `ppoHandleResponse :: a -> PayPalOperation b' is, though
08:35:26 <meoblast001> a `b`
08:35:28 <ski> yes
08:36:11 <meoblast001> the idea is that i'd be storing the bound function.. in some form of a promise... once the other four parameters are converted into a request and executed, the response would then be passed to this function
08:36:40 <meoblast001> it would then return another PayPalOperation, which would be executed in a similar fashion, until some constructor of the type indicates a stop
08:36:48 <ski> is the idea that a primitive `PayPalOperation' will produce some result `a', which then would be handled and further processed by a callback function of type `a -> PayPalOperation b' ?
08:37:07 <ski> (for clarity, s/result/result of type/)
08:37:46 <meoblast001> the primitive itself no, but execution of the primitive (constructing a request and executing it in IO), will do exactly that
08:38:09 <ski> yes, that's what i meant :)
08:38:39 <ski> (the primitive, as seen from the POV of its performed effects, when executed)
08:39:30 <ski> so in what i sketched above, `Bind' would allow one to attach callback, in which case one wouldn't need to to that with your primitive operation
08:39:57 <ski> or, one could do it the other way around instead. matter of style,taste,convenience,&c.
08:40:32 <ski> "until some constructor of the type indicates a stop" -- that would be the `Return' constructor :)
08:41:05 <ski> (at least a "temporary" stop. not necessarily a final one, since the current action could be part of a larger `Bind' action)
08:41:35 <meoblast001> ah yes, true
08:41:35 <ski> so, that (factoring out the callback) would give
08:41:43 <meoblast001> but in this case is the final constructor still necessary?
08:41:53 <meoblast001> i mean... something needs to contain the request details.. but how would this be used?
08:42:09 <ski>   PayPalOperation :: { ppoReqType :: RequestType,ppoUrl :: String,ppoOptions :: Wreq.Options,ppoPayload :: LBS.ByteString) -> PayPalOperation a
08:42:33 <meoblast001> i guess some function returns something using the final constructor... some bind wraps it in a Bind constructor?
08:42:38 <ski> (looked up syntax to be sure. this is apparently the currently blessed one. it was different before, for combining record syntax with GADT-style declarations)
08:42:39 <meoblast001> sort of making a tree
08:42:45 <ski> yes, a tree
08:42:54 <marrrk> I am confused. I use this ClassyPrelude thing. I am trying putStrLn $ "Something" ++ show somethingElse
08:43:02 <marrrk> I don't know what I need to pack or unpack into what.
08:43:06 <meoblast001> i like trees
08:43:26 <meoblast001> although if the tree is small i suggest we call it a broccoli
08:43:35 <ski> so, you could have a tree `Bind (PayPalOperation {....}) (\x -> Return (x^2))' or something, to postprocess the result (assuming it was a number, for this example)
08:43:59 <meoblast001> ooh :)
08:44:02 <meoblast001> thanks
08:44:05 <ski> anyway, the one problem i still see with the above constructor signature is that `a' is unconstrained
08:44:34 <ski> presumably you'd want to have different specific types instead of `a', depending on the particular kind of request you make ?
08:44:49 <meoblast001> i have different response types too, which will be given
08:45:29 <ski> one way to do that would be to replace `a' there by `String' or `ByteString' or whatever, and then make auxilary operations that parse that into a more appropriate type
08:46:06 <meoblast001> you mean the first parameter in bind?
08:46:18 <ski> a variant would be to *annotate* the data constructors of `RequestType' with the actual type you want to return, and then use `ppoReqType :: RequestType a' with the same `a' as in the return type, in the above signature
08:46:21 <meoblast001> or in the final constructor, PayPalOperation?
08:46:34 <ski> no, i'm talking about the `PayPalOperation' data constructor above
08:46:38 <ski> yes
08:47:41 <ski> `Bind' should be unchanged (unless you want to merge it back in with `Bind'. iow merging the callback back in. this might be more efficient, but should express the same behaviour (assuming you hide the implementation details inside your module/library))
08:47:53 <shapr> Has anyone tried to build the samples from the github library on Hackage?
08:48:10 <shapr> Bah, I guess I'll just fix them.
08:48:44 <ski> with `Return' and `Bind' as given above, the `Monad' instance is trivial (and then also the required `Functor' and `Applicative' instances, using `liftM' for the former, and `return',`ap' for the latter)
08:50:00 <meoblast001> yeah, the monad seems a lot more trivial with this tree approach
08:50:00 <ski> if you merge primitive operation(s) with `Bind', you'll have to define a (slightly) more involved `(>>=)' in `Monad PayPalOperation' (which basically will just traverse into the callbacks in the first argument until it reaches the `Return x' end, and there replace it with the second argument applied to that `x')
08:51:04 <meoblast001> ski: this should require XKindSignatures, right?
08:51:38 <ski> with the explicit `Return' and `Bind', you have to make sure to hide the data constructor, so that noone can notice the difference between `Bind m Return' and `m' (and obviously make sure no exported operation can tell the difference), in order to satisfy the monad laws (satisfied behaviourally/observationally, if not "in internal structure")
08:51:49 <meoblast001> i mean. this syntax
08:52:01 <ski> with `Bind' merged with primitive operation(s), you get that more or less for free
08:52:25 <ski> meoblast001 : `KindSignatures' for the (optional) `PayPalOperation :: * -> *' part on top. `GADTs' for the main thing
08:52:42 <meoblast001> ah okay. thanks
08:52:46 <ski> (optional in that you can replace it with `PayPalOperation x' or whatever)
08:53:31 <ski> meoblast001 : in your case, you could actually use the earlier `ExistentialQuantification' syntax .. but possibly you'd think it's not as readable
08:53:35 <ski> it'd look like
08:54:04 <meoblast001> sometimes i wonder why more of these extensions aren't just part of the language standard now?
08:54:20 <meoblast001> you open up any haskell file these days and you have to scroll through the list of language extensions first lol
08:54:37 <ski>   data PayPalOperation a = Return a
08:54:42 <ski>                          | forall b. Bind (PayPalOperation b) (b -> PayPalOperation a)
08:54:45 <ski>                          | PayPalOperation { ..as in your paste, though without the callback.. }
08:55:30 <meoblast001> hm. that also looks nice
08:55:54 <ski> (note that i had to swap `b' and `a' in `Bind' here, since i had to use `a' for the result type of the callback, since the result type of the constructors are `PayPalOperation a' with an `a'. with GADT syntax, the parameter names you use after the `data PayPalOperation' doesn't matter. which is another reason i prefer kind signatures there)
08:56:34 <ski> despite the name `forall' here, we say that `Bind' is an "existential data constructor" (or, even sloppier, that `PayPalOperation' is an "existential data type")
08:57:05 <ski> the point is that `Bind' is polymorphic in `b' (and in `a'), works for *all* types `b'
08:57:22 <ski> with explicit `forall's, we'd have
08:57:44 <ski>   Bind :: forall a. forall b. PayPalOperation b -> (b -> PayPalOperation a) -> PayPalOperation a
08:58:00 <ski> (or `forall a b.' instead of `forall a. forall b.', for short)
08:58:23 <ski> (one can use explicit `forall's in the data constructor signatures in GADT syntax, if one prefers)
08:58:38 <meoblast001> hmm
08:58:43 <ski> anyway, this constructor signature is basically the same as the following "uncurried" version
08:58:50 <meoblast001> you mean in GADT, each constructor is sort of defined independently of each other?
08:58:53 <ski>   UncurriedBind :: forall a. forall b. (PayPalOperation b,b -> PayPalOperation a) -> PayPalOperation a
08:59:02 <ski> and, this is logically equivalent to
08:59:10 <ski>   UncurriedBind :: forall a. (exists b. (PayPalOperation b,b -> PayPalOperation a)) -> PayPalOperation a
08:59:45 <ski> (by a logical law/equivalence that says that `forall a. (..a.. -> ...)' is equivalent to `(exists a. ..a..) -> ...' (assuming `a' doesn't occur (freely) in `...'))
09:00:02 <ski> meoblast001 : "... defined independently of each other?" -- yes
09:00:20 <ski> anyway, the above is the reason we use the term "existential" here
09:00:40 <ski> some people get confused because the syntax uses `forall' in `| forall b. Bind (PayPalOperation b) (b -> PayPalOperation a)' above ..
09:01:31 <ski> the data constructor `Bind' is polmorphic (so `forall'). however, the values/components collected by it "acts existentially in `b'" (because `b' doesn't occur in the result type of the data constructor)
09:01:44 <ski> `Bind' *hides* the type `b', when applied
09:02:10 <meoblast001> so much to soak in :D
09:02:29 <ski> if you have `m :: PayPalOperation String' and `k :: String -> PayPalOperation Int', then `Bind m k :: PayPalOperation Int', *hiding* the fact that `b' in this case was `String'
09:03:13 <ski> and because of this, when you look inside the data structure (using pattern-matching) you can't know that the type of the first component was `PayPalOperation String' .. no way to (in general) recover types at run-time
09:04:33 <ski> if you match `Bind m k' (of type `PayPalOperation Int') here with a pattern `Bind tree callback', then you only know that `tree :: PayPalOperation x' and that `k :: x -> PayPalOperation Int', for some (unknown) type `x', the same type for `tree' and `callback'
09:05:17 <ski> so the only thing you can do here is to (somehow) get an `x' from `PayPalOperation x', and pass it as an argument to `callback'. you can't yourself look inside the value of type `x', it's opaque
09:05:23 <meoblast001> hmm
09:06:13 <meoblast001> so you would completely lose that type information about the string
09:06:36 <ski> (this is similar to polymorphic functions like `map :: (a -> b) -> [a] -> [b]' e.g. not being able to look inside the elements of the input list, it can only pass them to the callback function, and then only store the result values in the list to return (hopefully in the same order, and with no elements dropped or duplicated, if we're assuming that `map' is to do what we expect it to))
09:06:42 <ski> meoblast001 : yes
09:08:09 <ski> however, the declaration of the constructor `Bind' records the "correlation" between the `tree' and the `callback' components, so you can still write an "executer" function that can traverse these trees and fit stuff together, as long as you can do it for the primitive operations
09:08:48 <ski> meoblast001 : oh, and this is where i think you possibly may need to use the GADT syntax anyway .. the primitive operations
09:09:20 <ski> either because you want to say something like
09:09:35 <meoblast001> i'm trying to figure out how one fmaps a Bind o_O
09:09:55 <ski>   PayPalOperation { ppoReqType :: RequestType,ppoUrl :: String,ppoOptions :: Wreq.Options,ppoPayload :: LBS.ByteString } -> PayPalOperation LBS.ByteString
09:10:11 <ski> where you don't even have a type variable `a' or `b' in the return type
09:10:19 <ski> or, if you try the alternative
09:10:26 <ski>   PayPalOperation { ppoReqType :: RequestType a,ppoUrl :: String,ppoOptions :: Wreq.Options,ppoPayload :: LBS.ByteString } -> PayPalOperation a
09:10:40 <ski> you could express this with the more traditional alternative
09:10:47 <meoblast001> i guess function composition on the function in there would work...
09:10:48 <ski>   | PayPalOperation { ppoReqType :: RequestType a,ppoUrl :: String,ppoOptions :: Wreq.Options,ppoPayload :: LBS.ByteString }
09:10:51 <ski> instead
09:11:08 <ski> but then i think `RequestType' will have to be declared using GADT syntax, for it to be useful
09:11:20 <ski> @src liftM
09:11:20 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:11:27 <ski> @undo do { x1 <- m1; return (f x1) }
09:11:27 <lambdabot> m1 >>= \ x1 -> return (f x1)
09:11:32 <ski> so
09:11:48 <ski>   fmap f m = Bind m (\x -> Return (f m))
09:11:53 <ski> is how you write `fmap'
09:11:58 <ski> or, just write
09:12:00 <ski>   fmap = liftM
09:12:09 <ski> after you have written the `Monad' instance, :)
09:12:42 <ski> (er, s/f m/f x/)
09:12:55 <ski>   fmap f m = Bind m (Return . f)  -- as you say
09:13:57 <meoblast001> why does RequestType need to be in GADT?
09:14:00 <meoblast001> it's a very simple type
09:15:04 <ski> because presumably you'll construct a result of a specific type (or small set of specific types), when parsing the response from a request
09:15:23 <glguy> Anyone able to verify that executing the gtk3/demo/treelist demo results in a segmentation fault? It is for me (on OS X) just wondering if it's happening for anyone else
09:16:01 <ski> as opposed to promising to be able to conjure up a value of *any* type `a' the user wants (which is what it would mean, if you use `PayPalOperation a', with no further mention of `a' in that constructor's argument types)
09:16:28 <ski> meoblast001 : obviously i'm guessing about the "presumably" here
09:16:46 <meoblast001> RequestType here simply specifies if it's a GET or POST request. nothign more
09:16:53 <meoblast001> two empty constructors
09:17:26 <ski> whether they have arguments or not doesn't matter here. they could well have been declared using GADT syntax, for good effect
09:18:19 <ski> the question is what kind of value you want to return (from executing the request, getting back a response) in the `GET' case, and what kind of value you want to return in the `POST' case ?
09:18:34 <ski> perhaps a `String'/`ByteString' in both cases ?
09:18:45 <ski> or perhaps nothing (iow `()') in one of those cases ?
09:19:28 <meoblast001> yeah but the response has nothing to do with the requesttype
09:19:50 <ski> if you want to be able to have (a few) different cases, with different types, then perhaps it would be nice to add (/specialize) more alternatives in `RequestType', to reflect this
09:20:18 <ski> how do you determine which kind of response, which type, you'll want to use ?
09:20:52 <ski> i was assuming that the `ppoReqType' determined the type of value returned to the user using such a primitive operation
09:21:01 <ski> (s/determined/field determined/)
09:22:15 <ski> perhaps you want a separate field for this. or perhaps you want to pull that into separate code, which all underneath employ the same basic `PayPalOperation' data constructor which would then presumably be set to return `String'/`ByteString'/whatever
09:24:52 <meoblast001> oooh
09:25:24 <meoblast001> now i see what you mean. this is a good point
09:26:05 <ski> meoblast001 : anyway, in either of those two cases, you'd need GADTs
09:26:24 <meoblast001> yeah, i'm staing with GADTs
09:26:46 <ski> well, in case you merge `Bind' with the primitive operation(s), then you can avoid using GADTs. but i think it would be considered a complicate to only do it for that reason
09:28:07 <ski> (because, then you could say `| PayPalOperation { ppoReqType :: RequestType a,ppoUrl :: String,ppoOptions :: Wreq.Options,ppoPayload :: LBS.ByteString,ppoHandleResponse :: String -> PayPalOperation a }' where you have fixed the callback input to `String', while using `PayPalOperation a' as callback return type, which is also the overall return type of the data constructor here)
09:28:20 <ski> (s/complicate/complication/)
09:29:21 <ski> GADT syntax allows you to use specific ior different parameters to the type constructor, in the result types of the data constructors
09:30:10 * hackagebot time-out 0.1 - Execute a computation with a timeout  https://hackage.haskell.org/package/time-out-0.1 (akrasner)
09:30:19 <ski> with the usual (BNF-inspired) syntax, the return types of all the data constructors is written just once, at the top, like `T a b c', where all the parameters must be (distinct) type variables
09:31:56 <ski> (however, if you want to, you can still use different arguments in "recursive calls" to the data type. that is called "irregular" datatypes. e.g. `data Tree a = Elems a | Double (Tree (a,a))' is a type of perfectly balanced binary trees, always containing a power of two number of elements. e.g. element `(Double . Double . Elems) ((0,1),(2,3)) :: Tree Integer')
09:37:21 <meoblast001> hmm. why would i want different arguments in recursive calls here?
09:39:17 <meoblast001> ski: doesn't this type hiding from the Bind constructor make fmap impossible?
09:43:07 <meoblast001> the type will be considered to be a PayPalOperation b, and the function must then take b -> c, despite the fact that the constructor contains PayPalOperation a
09:45:36 <ski> meoblast001 : it doesn't make `fmap' impossible
09:46:13 <rydgel> What graphics library should I use for line rendering for a raycasting renderer?
09:46:17 <rydgel> SDL2?
09:47:02 <ski> meoblast001 : so, you get `f :: a -> b' and `ppo :: PayPalOperation a'. composing with `Return' you get `Return . f :: a -> PayPalOperation b', then `Bind' gives `Bind ppo (Return . f) :: PayPalOperation b'
09:47:27 <ski> meoblast001 : alternatively, if you merge `Bind' with the primitive operation(s), you'd have to traverse the tree, but it also works
09:48:21 <meoblast001> ah so we don't change the first parameter at all, and simply do a return on the function for the second parameter.. all of this in a new bind
09:48:22 <meoblast001> hmm
09:49:20 <ski> meoblast001 : given `f :: a -> b' and `PayPalOperation rt url opts pl hr :: PayPalOperation a', you know (say) `hr :: String -> PayPalOperation a', so you compose this `hr' now with `fmap f' to get `fmap f . hr :: String -> PayPalOperation b', which you place back inside
09:50:03 <ski> meoblast001 : .. or, going back to the version with a separate `Bind', you can traverse there as well, if you like to, when you `fmap f' on `Return a', you give `Return (f a)' (obviously ?)
09:50:45 <meoblast001> lol.. funny thing is i was defining fmap for all three cases separately.. i already had your solution written down but was only using it for once case lol
09:50:57 <ski> meoblast001 : when you do it on `Bind m k :: PayPalOperation a', you know `m :: PayPalOperation x' and `k :: x -> PayPalOperation a', so you now compose `k' with `fmap f' as in the above case, replacing `k' with `fmap f . k'
09:51:38 <ski> it's good to know that you can traverse just fine into "existential data structures" .. but in this case it's simpler to not traverse at all
09:52:52 <meoblast001> yeah. so far i'm doing almost no traversal
09:53:09 <ski> the fact that the same `b' is used twice (once "positively", and once "negatively") in `| forall b. Bind (PayPalOperation b) (b -> PayPalOperation a)' means that the language checks that the first argument "coheres" with the second. when executed, the first is required to result in a value appropriate for passing into the second (the callback). it doesn't matter that you don't know what this type is, when traversing
09:53:12 <meoblast001> fmap on Return is the only case where i actually replace the data "in place"
09:53:23 <ski> the only thing that matters is that you know that they types will match each other
09:53:37 <ski> meoblast001 : as you please
09:54:37 <meoblast001> is it normal to have a lot more cases for <*> than fmap?
09:54:54 <ThugNasty> :t <*>
09:54:56 <lambdabot> parse error on input ‘<*>’
09:55:10 <eacameron> :t (<*>)
09:55:11 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:55:14 <ThugNasty> woops
09:55:24 <ski> well, it as two arguments, so if you're matching, you'll often get more cases, because you get more or less the square of the number of data constructors
09:55:44 <ski> however, i would just say `(<*>) = ap' inside `instance Applicative PayPalOperation where ...'
09:55:47 <ski> @src ap
09:55:48 <lambdabot> ap = liftM2 id
09:55:50 <ski> @type ap
09:55:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:55:52 <ski> @type (<*>)
09:55:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:56:08 <ski> `ap' is basically `(<*>)', built out of the `Monad' primitives
09:56:32 <ski> it's a good candidate for default implementation of `(<*>)' (in case you've got a monad, which is often the case)
09:57:06 <ski> similarly, of course you'll say `pure = return' (though `pure = Return' is just as fine here, not even slightly longer)
09:57:54 <ski> as i said before, `liftM' (or `liftA', if you've only got an `Applicative', or you believe that that one is more efficient) is a good candidate implementation for `fmap'
10:27:31 <meoblast001> hm... <*> is proving to be a bit confusing to me because i don't really know how to handle the first parameter in every scenario
10:27:43 <meoblast001> is there any way to rewrite <*> as >>=?
10:27:55 <Cale> When the Applicative is a monad,
10:27:55 <meoblast001> sort of like with fmap: fmap f x = x >>= return .f
10:28:07 <Cale> mf <*> mx = do f <- mf; x <- mx; return (f x)
10:28:26 <Cale> Or in other words,  liftM2 ($)
10:28:41 <ertes> meoblast001: sometimes it helps to desugar what Cale wrote manually
10:28:53 <meoblast001> yeah
10:29:37 <meoblast001> so.. mf <*> mx = mf >>= (\f -> mx >>= \x -> return (f x))... hmmm
10:29:42 <meoblast001> this should be interesting :D
10:30:29 <Jaak> @type liftM2 id
10:30:31 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
10:30:45 <ertes> note:  (\f -> mx >>= x -> return (f x)) = (\f -> fmap f mx)
10:31:14 <ertes> won't make the desugaring much easier, but may help getting a better understanding of how to implement (<*>)
10:32:49 <meoblast001> okay.. magic.. it worked o_O
10:33:14 <meoblast001> Cale: ertes: ski: thank you very much for the help :3
10:33:25 <meoblast001> as Ash Ketchup once said, i'm on my way to be a monad master
10:34:07 <ertes> great…  just…  don't write a tutorial, when that happens =)
10:36:29 <meoblast001> ertes: don't write a tutorial when i'm a monad master?
10:38:41 <xa0> there are far too many as is
10:38:48 <ertes> meoblast001: i'm just joking (with a serious overtone: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)
10:39:02 <ertes> (and yes, i'm guilty myself)
10:42:25 <runeks> Is there a TCP "connect" function I can use that will block and wait rather than return the error "socket: resource exhausted (Too many open files)"? I'm using Network.Simple.TCP's "connect" in a lot of "forkIO" threads.
10:42:57 <runeks> Here's some code: http://lpaste.net/154867
10:43:31 <meoblast001> ertes: i think one of my colleagues suffers from this
10:43:50 <meoblast001> i have a colleague who only uses the expression "this is easy" to explain the most complicated things we have at work
10:43:55 <ClaudiusMaximus> runeks: you can wrap it in a semaphore, i think the spawn package has a pool thing
10:44:27 <ClaudiusMaximus> runeks: but that would require guessing what the limit is
10:44:49 <runeks> ClaudiusMaximus: But then I would be doing forkIO's work, wouldn't I?
10:44:49 <ertes> runeks: none that i know of, but i'm working on a library for smarter error handling
10:45:19 <ertes> it will understand the difference between certain exception types, like transient errors vs. fatal errors
10:45:44 <ski> meoblast001 : cheers :)
10:45:55 <ertes> meoblast001: in my workshops i no longer make such judgements
10:46:09 <meoblast001> ertes: about what is easy and what is difficult?
10:46:15 <ertes> they don't help and ultimately make some people feel stupid, if it turns out to be *not* so easy
10:46:20 <ertes> meoblast001: yeah
10:46:24 <runeks> ertes: Good! But I'm more interested in a solution now. What are you building your library on? I assume there's no way to catch this error in question?
10:46:33 <meoblast001> ski: now i just need to write the function that traverses this tree :D. i hopefully shouldn't have as much of an issue with that since it's more concrete
10:46:48 <ClaudiusMaximus> runeks: http://hackage.haskell.org/package/spawn-0.3/docs/Control-Concurrent-Spawn.html#v:pool   something like  wrap <- pool 100 ; forM_ [1..10000] $ \n -> forkIO . wrap $ do connect ...
10:47:29 <ski> meoblast001 : as i mentioned above, `(<*>) = ap', iow `(<*>) = liftM2 id' is a candidate default implementation
10:47:32 <ertes> runeks: IO errors are a bit opaque unfortunately…  if there is no other way, you'll have to resort to string matching
10:47:36 <runeks> ClaudiusMaximus: Thanks! I was thinking about how to implement that earlier, but I'm glad I don't have to.
10:48:07 <ski> meoblast001 : if you want to figure out what it does / how it works exactly, in your case, feel free to do so
10:48:24 <ertes> runeks: technically it's an application of catchJust/handleJust…  wait a short delay, then try again
10:48:40 <meoblast001> ski: i need to traverse this tree, otherwise the monad is useless :D
10:48:48 <ski> yes, of course :)
10:49:03 <ski> (i was referring to what Cale and ertes said before)
10:49:41 <runeks> ertes: I was hoping for a less hackish solution :) no offense!
10:49:59 <ertes> runeks: there is none, as far as i know
10:50:06 <runeks> ertes: Is it an OS level error?
10:50:09 <ski> meoblast001 : the only perhaps unusual part of this tree is that the subtree in the `Bind' case is "behind" a function, so can only be reached when you get an `a' from the first `PayPalOperation a' argument to `Bind'
10:50:56 <ski> meoblast001 : if you want to, you can think of this as your `Bind' node having one branch for each possible value of `a' here (compare how `Bool -> a' is basically the same as `(a,a)', so the `Bool' here expresses a choice of which `a' you want to reach)
10:51:02 <ertes> runeks: unless you're up for reimplementing the network library and using error return values, but IMO that's even more hackish (and can actually be achieved with tryJust, but i strongly recommend not doing that!)
10:51:41 <ertes> runeks: the error comes from your OS and is communicated to you as an exception
10:51:43 <ski> meoblast001 : .. this "behind a function" part can also be a drawback to using a monadic approach. because it means that you can't analyze (the whole) of your tree, without executing it (perhaps in a mock environment, though)
10:51:57 <ertes> (linux for example doesn't allow more than 1024 open file descriptors per process per default)
10:53:01 <runeks> ertes: OK. Thanks. I guess wrapping it in a semaphore is the way to go then.
10:53:43 <ertes> runeks: perhaps you can simply find a way to reduce the number of file descriptors?
10:53:44 <ski> meoblast001 : one advantage to using a "purely" applicative approach (so with `Pure' and `Ap' constructors, instead of `Return' and `Bind') would be that you can traverse the whole tree statically .. ("arrows" also have this property. i think the motivating example of arrows was a parser where you could statically compute NULLABLE, FIRST, FOLLOW, for better performance, before commencing parsing)
10:54:04 <ertes> runeks: most applications should never reach that limit, unless they are serving network clients
10:54:24 <ertes> it's mostly P2P applications that suffer from this
10:54:48 <runeks> ClaudiusMaximus: Is there even any reason to mess with MVars using the Control.Concurrent.Spawn library? I hadn't seen that library before. It seems to do everything I want (concurrency with a thread limit).
10:54:55 <ski> (well .. the "existential" aspect to your tree (and perhaps GADT aspect, for the primitive operation(s)) would probably also be unusual to you, so far)
10:55:21 * hackagebot text 1.2.2.1 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.2.1 (BryanOSullivan)
10:55:31 <runeks> ertes: It's a test application. I just want to get as many requests out as possible.
10:55:52 <runeks> It's for benchmarking a server application
10:56:38 <ski> runeks : .. i suppose semaphore's would seem to be the right way to do it
10:56:52 <ertes> runeks: in that case use a resource pool (e.g. a semaphore or more a sophisticated solution like the resource-pool library), but allow the user to specify the limit
10:56:54 <meoblast001> ski: ah thanks. hmmm. although in every case that "a" should be the response of a previous function
10:56:56 <ertes> https://hackage.haskell.org/package/resource-pool
10:57:51 <ski> meoblast001 : yes. the point being that you can't get a hold of such an `a' without actually executing your action (maybe also possible with some kind of mock execution, for testing/whatever)
10:58:52 <meoblast001> ah you mean i need a response before i can ever make a request
10:59:14 <ski> meoblast001 : e.g., you can't write a function that counts the number of primitive operations performed by a given action (unless you can set up such a mock execution .. and then we have to remember that the later parts of the execution may depend on the values yielded for earlier primitive operations)
10:59:36 <runeks> ertes: Control.Concurrent.Spawn seems a lot simpler. Is it less effective?
10:59:49 <ertes> runeks: i'm not familiar with that one
10:59:59 <ertes> if it fits your use case, go ahead
11:00:05 <runeks> I'm gonna try that out and see where it gets me.
11:00:38 <ertes> last, but not least, the stm library provides TBQueue
11:00:53 <ertes> it's like Chan, but transactional and bounded…  writers block, if the queue is full
11:00:55 <ski> meoblast001 : so, if we think of the `a -> PayPalOperation b' callback part as specifying one subtree per value of `a', when you've computed an `a', by interacting with the environment, you're really then only exploring *one* path in the tree at this point. you're not traversing the "whole tree", in some sense
11:01:37 <ski> meoblast001 : and this matters, because, while the "shape/structure" of the tree you get from the callback *could* be the same, regardless of what `a' value you provide, it *could* just as well be different, depending on the particular `a'
11:02:21 <ski> meoblast001 : this is the power given by monads (over applicatives) : that (the structure/shape of) later execution may *depend* on run-time values computed by earlier execution
11:02:26 <meoblast001> ski: in order to traverse the right path of the tree you mean, i must also traverse the left hand side
11:02:37 <meoblast001> because without actually executing something, the entire tree is unknown
11:02:39 <ski> yes, of course. but that is not a problem
11:02:49 <ertes> (where "later" can mean "further down the tree")
11:02:57 <ski> the problem is that the left hand side of type `PayPalOperation a' need not contain a value of type `a' at all
11:03:09 <ski> it could be `Return x' with `x :: a', and then you get an `a'
11:04:08 <ski> but it could just as well be a primitive operation node in the tree, and then the result of that isn't contained in the tree, but is only determined in interaction with the environment (iow in your "executor" function that performs I/O, or perhaps also in some mock executor function that you use for testing)
11:05:14 <ski> meoblast001 : if you only have access to applicative operations, but not monadic ones, then in some sense the shape/structure of the computation is already determined, and doesn't depend on run-time values computed during the execution of the computation/action
11:05:54 <ski> and, as hinted, it can sometimes be useful to use a *less* powerful language, in order to be able to (in this case, automatically) *reason* about the (programs in the) language
11:06:12 <meoblast001> but in my case is that really very necessary?
11:06:15 <ski> in this case, the language would be the EDSL of your `PayPalOperation' stuff
11:06:31 <ski> meoblast001 : probably not, but it's a useful thing to be aware of
11:06:36 <meoblast001> aah okay
11:06:41 <ski> "more powerful language" isn't always better
11:07:04 <meoblast001> do you know of what kinds of cases would make it more beneficial to use the less powerful language?
11:07:12 <ertes> seems like a good quote:
11:07:16 <ertes> use the least powerful language that does the job
11:07:23 <ski> since "more powerful/expressive" often (usually) means "less reasonable", in the sense of ability (by human and computer) to reason about the program (including refactoring, checking invariants, &c.)
11:08:07 <ski> ertes : <https://en.wikipedia.org/wiki/Rule_of_least_power>
11:08:37 <ski> btw, this is a reason why SQL is so useful
11:09:10 <ertes> thanks, didn't know that was a thing
11:09:46 <ertes> meoblast001: we like to avoid IO, not because side effects are bad or that it's a monad, but because it's in a sense the most powerful language in haskell
11:10:04 <ertes> IO gives you the ultimate power, and at the same time the least amount of reasoning
11:10:09 <ski> (even though it has atrocious syntax, and several design flaws. also sadly common implementations typically implement only part of the standard (at least in a reasonably efficient way), leaving the programming to do more of what ought to have been the implementation's work, leaving to lots of woe)
11:12:00 <ski> meoblast001 : parsers is an obvious example. if you don't need the extra power of monadic parsing, it makes sense to use an applicative parser, because then it can be implemented more efficiently (the implementation can make use of more static guarantees in order to optimize, and derive useful extra information, expecially before commencing parsing)
11:12:07 <Zekka|Sigfig> Compare sql to prolog: you can optimize sql a lot with indexing, but can’t optimize Prolog very much because Prolog guarantees a result order that’s not just sorted order
11:12:24 <meoblast001> aahh
11:12:25 <Zekka|Sigfig> you can give Prolog an arbitrary order for results to be returned in and it’s required to guarantee it
11:12:46 <ski> btw <http://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> is an example that further explains the difference in power here between applicatives and monads
11:12:53 <meoblast001> ski: okay that makes sense :)
11:13:01 <ski> (what i have called "static sequencing" vs. "dynamic sequencing")
11:13:26 <ski> meoblast001 : but it's good to be aware of this issue, in order to be able to spot opportunities for using the knowledge
11:14:58 <ski> Zekka|Sigfig : fwiw, Mercury doesn't guarantee solution order (unless you tell it to)
11:15:26 <Zekka|Sigfig> ski: I haven’t really worked with mercury but that doesn’t surprise me give the giant modes system
11:16:22 <Zekka|Sigfig> (giant is an exaggeration, but compared to not having one it’s big)
11:17:05 <ski> Zekka|Sigfig : *nod*, since while `p,( q0 ; q1 )' gives (assuming say that `p' has no side-effects) the same solution order as `( p,q0 ; p,q1 )', `( p0 ; p1 ),q' doesn't (in general) give the same solution order as `( p0,q ; p1,q )'
11:17:38 <ski> Zekka|Sigfig : and Mercury likes to reorder conjuncts, to satisfy mode dependencies, which more or less forces being able to do such transformations
11:18:56 <ski> (obviously add some arguments to those predicate calls, in order to make the goals interesting enough to be able to yield nontrivial solutions)
11:19:07 <Zekka|Sigfig> Yeah, I get you
11:19:48 <meoblast001> ski: yup.
11:19:50 <meoblast001> thanks
11:19:53 <ski> yw
11:19:59 <Zekka|Sigfig> Although I didn’t realize the modes system actually implied it would be necessary — I just figured that, while you have a modes system, why not throw in other stuff like “no guaranteed order” that might be occasionally useful but isn’t possible in Prolog?
11:20:43 <ski> well, i didn't realize the strength of the connection here until i started to express it above
11:21:04 <Zekka|Sigfig> I definitely saw it as an optimization thing, just not as a potentially necessary one
11:21:42 <ski> the thing is that we want to write a predicate once in Mercury. not possibly several times, in order to support disparate enough modes
11:24:11 <ski> (ftr, `,' above is conjunction ("and"), while `;' is disjunction ("or"). the transformation is that of conjunction distributing over / factoring out of disjunction)
11:35:24 * hackagebot language-fortran 0.5.1 - Fortran lexer and parser, language support, and extensions.  https://hackage.haskell.org/package/language-fortran-0.5.1 (DominicOrchard)
11:36:59 <runeks> Wow! The Control.Concurrent.Spawn package works like magic. 2000 request per second without a hiccup in 5 lines of code.
11:39:29 <hackrilege> Why does choose = asum?
11:40:02 <hackrilege> That does not seem to choose an element but rather fold the list...
11:40:34 <hackrilege> Since asum = fold
11:40:54 <ertes> runeks: great…  on most systems the raw throughput should be even higher though
11:41:02 <danza> runeks, cool... i would be curious to see those five lines :)
11:41:04 <Cale> runeks: Given how simple the implementation is in terms of the concurrency primitives, I would not be surprised to find it could handle way way more than that
11:41:54 <hackrilege> :t [choose,asum,fold]
11:41:56 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ Gen a
11:41:56 <lambdabot>     Expected type: (Gen a, Gen a) -> Gen (Gen a)
11:41:56 <lambdabot>       Actual type: (Gen a, Gen a) -> Gen a
11:41:56 <Cale> (though of course, you're probably spawning threads that actually *do* things
11:42:58 <hackrilege> :t choose
11:42:59 <runeks> The server is the limiting factor, no doubt. It can only handle ~2000 requests/s
11:43:00 <lambdabot> Random a => (a, a) -> Gen a
11:43:36 <hackrilege> :t Data.Unfold.choose
11:43:37 <lambdabot> Not in scope: ‘Data.Unfold.choose’
11:45:38 <hackrilege> http://hackage.haskell.org/package/unfoldable-0.8.3/docs/Data-Unfolder.html#v:choose
11:48:09 <runeks> Hmm. Now I get an occasional error saying "connect: unsupported operation (Can't assign requested address)"
11:48:29 <hackrilege> Oh, asum is just the default. I guess my question is, how can I understand the instances which are written in terms of choose
11:50:13 <johnw> shapr: no
11:51:29 <hackrilege> Such as the one here; http://hackage.haskell.org/package/unfoldable-0.8.3/docs/Data-Unfoldable.html
11:51:40 <geekosaur> runeks, are you stopping and restarting the server?
11:51:55 <geekosaur> probably need to set one of the reuse options
11:52:10 <runeks> danza: I've managed to reduce it to only 3 lines: http://lpaste.net/154869
11:52:11 <hackrilege> instance Unfoldable Tree where unfold fa = choose [ pure Empty , Leaf <$> fa , Node <$> unfold fa <*> fa <*> unfold fa ]
11:52:29 <runeks> geekosaur: The server has been running all along
11:52:49 <ertes> runeks: it may be a good idea to write a raw benchmark for the server, i.e. the response rate without any network I/O
11:52:59 <ertes> runeks: then you have a value to compare against
11:53:02 <geekosaur> oh, on connect. out of ephemeral ports?
11:53:20 <hackrilege> I can't see how to implement choose for Tree so that this definition makes sense
11:53:26 <johnw> hackrilege: isn't that sort of thing just what Arbitrary does?
11:53:45 <runeks> geekosaur: The server is bound to a socket and I use "accept" in an infinite loop.
11:54:37 <hackrilege> I don't know johnw
11:54:38 <ski> hackrilege> :t Data.Unfold.unfold
11:54:46 <geekosaur> never mind the server. (that error is usually in bind() on a server, Ididn't notice that it was connect throwing it)
11:54:59 <geekosaur> [17 18:52] <geekosaur> oh, on connect. out of ephemeral ports?
11:56:01 <geekosaur> might check syslog (linux) / Console.app (os x) / event viewer (windows) to see if something is logged about not enough ports
11:56:07 <runeks> geekosaur: Yeah, it's the test app that is throwing errors on "connect".
11:56:11 <hackrilege> I can't find that package ski
11:56:18 <johnw> hackrilege: it generates random generate, can generate into a list, etc.
11:56:23 <johnw> s/generate/data
11:57:33 <ski> hackrilege : oh, i thought you were trying to make (or read about ?) an instance for this `Unfoldable Tree' ?
11:57:59 <hackrilege> It's more a question of directing, like in a binary tree extending the leftmost branch first...
11:58:07 <hackrilege> Maybe I need zippers?
11:58:42 <hackrilege> I was ski, however I couldn't glean anything from your post
11:59:16 <hackrilege> :t Data.Unfold.unfold
11:59:17 <lambdabot> Not in scope: ‘Data.Unfold.unfold’
12:00:25 <runeks> geekosaur: Nothing is logged in the Console app on OSX when the error occurs, unfortunately.
12:01:24 <geekosaur> hm. I'd expect a message if it were out of ephemeral ports to use for new client connections, which is the normal reason you'd get that
12:02:26 <geekosaur> (in theory also using an ipv6 address on an ipv4 socket but that'd be program bug)
12:06:34 <hackrilege> Can I use zippers to direct the growth?
12:07:22 <marrrk> How do I do this: a -> Maybe b -> Either a b ?
12:08:15 <tzh> `\a mb -> case mb of { Just b -> Right b; Nothing -> Left a }`?
12:08:49 <geekosaur> :t fromMaybe
12:08:51 <lambdabot> a -> Maybe a -> a
12:08:57 <geekosaur> mm, no
12:09:30 <HallaSurvivor> tzh, I didn't know you could use {} to one line things in haskell O.o
12:09:30 <geekosaur> :t maybe (Left ?a) Right ?b
12:09:32 <lambdabot> (?a::a, ?b::Maybe b) => Either a b
12:10:06 <dolio> The braces are unnecessary there.
12:10:19 <tzh> HallaSurvivor: yeah, there's an explicit-brace notation you can use instead of trusting whitespace
12:10:23 <marrrk> Oh yeah, I meant is there a ready made function for this already?
12:10:35 <kadoban> The 'errors' package has stuff like this
12:10:43 <kadoban> Specifically the function 'note'
12:10:54 <ski> hackrilege : oh, i was assuming you knew what package `Unfoldable' was from, and perhaps had docs for it up ..
12:11:16 <kadoban> marrrk: ^
12:11:40 <iphy> what's the best data structure for a Word8 -> a map?
12:11:41 <marrrk> Okay, thanks!
12:11:48 <ski> (.. and now that i look at the backlog, i see a link you provided to docs. so the answer to my question is then `unfold :: (Unfoldable t,Unfolder f) => f a -> f (t a)')
12:12:01 <iphy> IntMap is possible, but I can specifically limit to 256 possible values for the key
12:12:23 <ski> (s/I can/can I/ ?)
12:12:57 <ski> i suppose you could try to use an array ..
12:12:58 <iphy> and I'm almost certainly not going to have more than a few (10?) values, starting with 0, not exceeding 9
12:13:11 <kadoban> iphy: A list?
12:13:26 <kadoban> :t lookup
12:13:27 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:13:32 <iphy> hmm
12:13:44 <iphy> alright, maybe list is the best one
12:13:53 <ertes> iphy: most likely a Vector would work best
12:14:06 <ertes> unless you need to change values
12:14:18 <iphy> I do need to change values
12:14:44 <iphy> it's a map where I update the values regularly, but the keys are always small and mostly very small
12:15:01 <ertes> then IntMap (or HashMap, which is just IntMap, but allows Word8)
12:15:11 <kadoban> You could also just use a Map really, whichever one is easier really. Basically *anything* will be performant unless you're doing a ridiculous number of updates and lookups.
12:15:48 <kadoban> It doesn't tend to matter what you use when you're using it for tiny instances of problems.
12:15:52 <ertes> IntMap, HashMap and Map all have very similar interfaces, so none of them is really easier (unless you need ordered keys)
12:15:55 <iphy> yeah, I'm not really interested in performance
12:16:04 <ertes> out of those three Map is likely going to be the slowest one
12:16:11 <ertes> so i recommend IntMap or HashMap
12:16:11 <iphy> I'm interested in a semantically nice interface
12:16:45 <iphy> [(Word8, a)] is not ideal for that
12:17:11 <iphy> as a data structure, it doesn't keep the invariant that keys are unique
12:18:25 <iphy> I see, HashMap is in fact IntMap and for Word8 it would basically just do fromIntegral
12:18:50 <ertes> with the current Hashable implementation, pretty much
12:19:02 <iphy> instance Hashable Word8 where hash = fromIntegral
12:19:04 <iphy> yes
12:19:13 <iphy> that's fine for me
12:19:21 <iphy> ok, HashMap it is, thanks
12:19:31 <ertes> it might change due to security concerns, but it won't make a terrible difference
12:20:10 <ertes> my philosophy is that, all other things being equal, you should always use the most efficient solution…  anything else is a waste of CPU time, power (think batteries!) and ultimately money
12:20:50 <iphy> ertes: I'm writing a reference implementation as part of a specification
12:21:10 <iphy> making it correct is #1, and making it easy to understand is #2
12:21:20 <iphy> making it fast is #N with large N
12:22:01 <ertes> iphy: sure…  note: all other things being equal (in this case: same interface, almost same memory footprint)…  also it's just *my* philosophy, and a lot of people disagree =)
12:22:08 <iphy> right
12:29:39 <meoblast001> ski: i'm guessing it's a bad idea if i put a FromJSON requirement on the "a" in my constructors, right?
12:30:15 <davean> meoblast001: thats not really where it belongs, unless its a forall
12:30:17 <meoblast001> because generally in the bind... PayPalOperation a -> (a -> PayPalOperation b) -> PayPalOperation b, that a is going to have to be read from JSON
12:30:27 <davean> meoblast001: you shuld put it on the functions that actually require it
12:30:48 <meoblast001> yeah. i tried that. one moment and i'll get the error message i got
12:32:02 <meoblast001> https://gist.github.com/meoblast001/97ba434e352b59120ddf https://gist.github.com/meoblast001/c7a513383a501ced9268
12:32:25 <hackrilege> ski, you wrote Data.Unfold, not Data.Unfoldable
12:33:57 <davean> meoblast001: you didn't put the requirement on everything that used it
12:34:04 <hackrilege> How do I force lazy evaluation to unfold in a particular direction?
12:34:09 <davean> meoblast001: specificly, I expect you define a subfunction, and gave it a type
12:34:23 <hackrilege> It seems like they are using choose, but I doubt see how that works
12:34:29 <davean> meoblast001: but you don't have ScopedTypeVariables on, because haskell is fucked up
12:34:30 <hackrilege> Don't*
12:34:30 <ski> hackrilege : oh, so i did
12:34:38 <hackrilege> It's ok
12:34:56 <hackrilege> I thought you had found a magic package
12:34:58 <davean> meoblast001: you can fix it by removing the type on the subfucntion, adding FromJSON to it, or enabling ScopedTypeVars for that a
12:35:02 <meoblast001> davean: i use it somewhere where that's not mentioned?
12:35:21 <davean> meoblast001: the "a" in any other type signature is not the same "a" as has the FromJSON
12:35:22 <meoblast001> wait which subfunction?
12:35:35 <davean> meoblast001: execOpers
12:35:44 <hackrilege> It seems that ask that is to be specified is what constructor to use to extend the datatype
12:35:52 <meoblast001> but that does have a FromJSON
12:36:15 <davean> meoblast001: sorry, I don't have your code to look at
12:36:29 <meoblast001> the first link: https://gist.github.com/meoblast001/97ba434e352b59120ddf
12:36:35 <hackrilege> But I suspect to track the growing end of a tree I should use a zipper...
12:36:39 <meoblast001> line 59
12:36:48 <hackrilege> Is that nearly right?
12:37:26 <davean> meoblast001: Hum, PPOBind
12:37:54 <davean> meoblast001: consider PPOBind and its b
12:38:53 <davean> meoblast001: Do you see?
12:38:59 <meoblast001> davean: it doesn't have to do with me swapping the b and a, right?
12:39:06 <meoblast001> because iirc, in this syntax that shouldn't play a role
12:39:16 <meoblast001> as each constructor's type variables are independent of each other
12:40:36 <davean> meoblast001: but what gives it FromJSON?
12:40:38 <ski> meoblast001 : what are the types of `getWith',`postWith',`decode' ?
12:40:51 <ski> i'm guessing `decode' requires `FromJSON' (?)
12:40:54 <davean> meoblast001: well, what gives its 'a' FromJOSN
12:40:58 <davean> ski: yes it does
12:41:01 <meoblast001> ski: they return IO (Response ByteString)
12:41:10 <davean> meoblast001: so like 62
12:41:12 <davean> er, line
12:41:15 <ski> meoblast001 : in that case, add `FromJSON a =>' to `PayPalOperation' (and remove it from `execOpers')
12:41:31 <ski> perhaps also remove it from `execPayPal' (not sure)
12:42:34 <meoblast001> davean: what about line 62?
12:43:01 <meoblast001> i mean.. i guess that would mean that the "a" needs to be FromJSON
12:43:15 <davean> meoblast001: exactly
12:43:29 <davean> hence the 'a1' in the error
12:43:30 <ski> meoblast001 : you don't want to require `FromJSON' everywhere inside `PayPalOperation' (as would be required for the recursive call of `execOpers' on `PPOBind' to work), since restricting `PPOBind' (and `PPOPure') to only work on `a's that are in `FromJSON' would break the `Monad' (and `Applicative' and `Functor') interfaces, which requires `pure'/`return',`(>>=)' and `fmap' to work for *any* type `a', not merely types `a' in `FromJSON'
12:43:35 <meoblast001> yes but that type is hidden in the type declaration so to speak
12:43:47 <meoblast001> so in this function i can't really specify that must be FromJSON
12:43:53 <ski> (er, possible cut off at the end : ".., which requires `pure'/`return',`(>>=)' and `fmap' to work for *any* type `a', not merely types `a' in `FromJSON'")
12:45:00 <meoblast001> ski: so if i don't have an execOpers for PayPalOperation, where does the call actually go?
12:45:00 <davean> meoblast001: you might want a different encoding for your Monad
12:45:03 <ski> meoblast001 : however, by adding on constraint `FromJSON a' on the specific (GADT-style) data constructor that needs it, pattern-matching on `PPOBind' in `execOpers' will (for this case) recover the fact that `FromJSON a' holds, so that you can use `decode' there
12:45:09 <meoblast001> and PPOBind's execOpers must be recursive, right?
12:45:53 <ski> meoblast001 : "in this function i can't really specify that must be FromJSON" -- right, which is why you specify it on the data constructor that needs it, instead
12:46:10 <ski> it must be recursive, in order to traverse the whole tree, yes
12:46:25 <ski> (either directly, or indirectly through some recursor combinator)
12:46:54 <ski> meoblast001 : anyway, this is typical of the kind of issues you sometimes get with existentials
12:47:04 <meoblast001> ski: you are magical
12:47:11 <meoblast001> that worked but now i need to figure out why
12:47:42 <ski> meoblast001 : anyway, i earlier suggested restricting the result type of the data constructor `PayPalOperation' from `PayPalOperation a' to `PayPalOperation String' (or `PayPalOperation ByteString' or something)
12:48:13 <ski> meoblast001 : however, since (i think) `FromJSON a' allows you to conjure up an `a' from a string/bytestring/something, this works as well
12:48:38 <meoblast001> yeah, this would be not very restrictive
12:49:06 <meoblast001> ah, i guess since i'm doing the decoding in the handling of that constructor, it makes sense to add that constraint to that constructor
12:49:10 <ski> meoblast001 : incidentally, this would also mean that you *could* use the alternate (non-GADT) syntax here, iow `... | FromJSON a => PayPalOperation {...}'. whether you want to do that, or keep the GADT-style is up to you
12:49:32 <meoblast001> i'm going to stay GADT
12:49:48 <EvanR> GADT is where its at
12:50:15 <ski> meoblast001 : the only thing one have to think of here is that by putting this `FromJSON a' constraint into the data type itself, you're coupling that requirement much tighter than if you would just add it as a constraint on an operation using the type
12:50:38 <ski> (which is what davean was getting at, earlier)
12:50:59 <ski> if you think you're ok with that, then you can use the above approach
12:51:35 <ski> meoblast001 : for the "why" : remember what i said before about
12:51:54 <meoblast001> ski: yeah. i was thinking that too.. i didn't want to add it at that level but i starting thinking "if i don't do this, am i leaving a logical hole open?"
12:51:54 <ski>    Bind :: forall a b. PayPalOperation b -> (b -> PayPalOperation a) -> PayPalOperation a
12:52:43 <ski> because `b' doesn't appear in the result type here, this data constructor is *hiding* `b', as would be shown more explicitly in the (for conceptual use) refactoring
12:52:52 <ski>   UncurriedBind :: forall a b. (PayPalOperation b,b -> PayPalOperation a) -> PayPalOperation a
12:52:56 <ski> aka
12:53:11 <ski>   UncurriedBind :: forall a. (exists b. (PayPalOperation b,b -> PayPalOperation a)) -> PayPalOperation a  -- this syntax actually not supported by GHC
12:53:47 <ski> (the `exists' here signifies that there *exists* some type `b' (but we don't know what it is, we've forgotten it. it's hidden))
12:53:51 <ski> now consider
12:54:26 <ski>   PayPalOperation :: forall a. {...} -> PayPalOperations a  -- explicit `forall' for emphasis
12:54:29 <ski> which we changed into
12:54:36 <ski>   PayPalOperation :: forall a. FromJSON a => {...} -> PayPalOperations a
12:55:10 <ski> when we apply this data constructor, `a' must actually be a type that is in the `FromJSON' type class
12:55:20 <meoblast001> ski: but wouldn't that leave open the theoretical possibility that we fmap that to something which is not FromJSON and then try to bind it?
12:55:37 <meoblast001> or wait..... in that case it's fine as long as it's not PayPalOperation
12:55:55 <ski> but as before, the data constructor *hides* this fact (in implementation terms, it stores the evidence, the method dictionary for `a', inside the constructor node)
12:57:25 <ski> now, even if you have `execOpers :: PayPalOperation a -> ..a..', with no `FromJSON a' constraint on `a' here, when we pattern-match on the `PayPalOperation' data constructor case, the type system will *recover* the fact that `a' was in fact an instance of `FromJSON', which is why you can use `decode' in that defining equation of `execOpers'
12:58:29 <meoblast001> aaah okay
12:58:42 <meoblast001> and we accomplish this by limiting this only to the one constructor
12:59:43 <ski> "i didn't want to add it at that level" -- yeah, that's a good initial reaction. however i don't see a way around it (perhaps there's some other way to do it). also afaiui, it would be conceptually ok to add the `FromJSON' constraint on that constructor (only), because it's conceptually related to computing a result from a JSON representation
13:00:23 <ski> if the user wants to get an overall result of a type not in `FromJSON', then they should add some post-processing on top of that (with `Bind', or `(>>=)' or `do'-notation, or whatever you provide)
13:00:34 <ski> meoblast001 : *nod*
13:01:01 <xa0> Is there any general function of the form (Maybe a, b) -> Maybe (a, b) or similar in any libraries?
13:01:43 <davean> xa0: you can just fmap (, b)
13:02:05 <xa0> Oh
13:02:22 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength = uncurry (fmap . (,))
13:02:25 <lambdabot>  Defined.
13:02:32 <enthropy> > _1 id (Just 'a', "b")
13:02:35 <lambdabot>  Just ('a',"b")
13:02:58 <Luke> anyone here use Warp and know if `run` blocks?
13:03:20 <davean> Luke: it blocks
13:03:24 <Luke> thanks
13:03:32 <Luke> that was way faster than trying it =D
13:03:38 <ski> @let strengthB :: Functor f => f (a -> b) -> (a -> f b); strengthB = flip (fmap . flip ($))
13:03:40 <lambdabot>  Defined.
13:03:54 <ski> at one point, this `strengthB' was named `flip' in lambdabot
13:05:19 <ski> so you could write `flip [(+2),(*2),(^2)] 3'
13:05:53 <ski> > [(+2),(*2),(^2)] `strengthB` 3
13:05:55 <lambdabot>  [5,6,9]
13:06:13 <hackrilege> Can anyone talk me through how to use the Unfoldable class?
13:07:50 <hackrilege> The example at http://hackage.haskell.org/package/unfoldable-0.8.3/docs/Data-Unfoldable.html uses the Unfolder instance of list, which I think is fold (is this correct?)
13:08:33 <hackrilege> To construct a recursive call to the Tree constructor
13:11:03 <hackrilege> However this does not seem to capture the full utility, as it is not clear how to direct the growth
13:12:09 <hackrilege> For instance, perhaps I would like to unfold the Tree so that the length of each branch is less than half as long as the branch to it's right
13:12:56 <hackrilege> Does anyone know how to use the Unfoldable class to control the unfold in this way?
13:12:59 <hackrilege> Over
13:23:45 <ski> hackrilege : hm, sounds like it'd require some use of state (if you want every tree satisfying your requirement to be a possible result)
13:24:42 <ski> looks like there's an instance `(MonadPlus m,Unfolder m) => Unfolder (StateT s m)'
13:27:24 <ski> iiuc, `WithRec' there is used to keep track of the current depth, incrementing on calls to `choose'
13:27:37 <hackrilege> I don't understand why that instance is relevant...
13:27:56 <ski> it's only relevant as inspiration
13:28:10 <ski> it keeps track of an environment, while you want a state (i think)
13:28:29 <ski> er, sorry. i mean `WithRec' is only relevant as inspiration
13:28:44 <hackrilege> http://hackage.haskell.org/package/unfoldable-0.8.3/docs/src/Data-Unfoldable.html#allToDepth
13:29:04 <ski> if you do need state, to be able to check current depth with max depth of the neighbour to the left/right, then i think `StateT' could be useful, no ?
13:29:14 <ski> it needs to be an instance of `Unfolder'
13:30:10 <ski> hackrilege : yes, that uses `limitDepth', which uses `WithRec'
13:30:18 <hackrilege> Can you see how that works?
13:30:30 <ski> which ? `allToDepth' ?
13:30:40 <hackrilege> Oh, what's WithRec?
13:30:45 <hackrilege> Ski, yes
13:31:25 <ski> `WithRec' is a helper type, defined in `Data.Unfolder'
13:31:44 <hackrilege> Cool thanks I'll look at that now
13:32:25 <ski> the point is apparently to allow an unfolding to apply a custom depth-depending function at each node where `choose' is called
13:32:35 * ski hasn't seen this library before
13:33:11 <hackrilege> Seems runReaderT at use, so that's TVar right? That's similar to state?
13:33:19 <ski> `WithRec f a' expresses just `f a', but (possibly) depending on such a user-provided depth-depending function
13:33:45 <ski> `TVar' is for `STM' (concurrency transactional) stuff
13:33:56 <ski> `Reader' is a bit similar to `State', but simpler
13:34:12 <hackrilege> TVar nothing to do with ReaderT?
13:34:13 <meoblast001> ski: are you sure this type of monad could be considered lawful?
13:34:16 <ski> `Reader rho a' is just `rho -> a', wrapped up
13:34:19 <geekosaur> noope
13:34:25 <geekosaur> the T there means "transformer"
13:34:26 <hackrilege> Kk
13:34:26 <ski> then `ReaderT rho m a' is `rho -> m a'
13:34:29 <geekosaur> Reader vs. ReaderT
13:34:31 <meoblast001> you get certain scenarios where things "mean" the same thing, but have different representations
13:34:35 <ski> @unmtl ReaderT rho m a
13:34:35 <lambdabot> rho -> m a
13:34:43 <geekosaur> Reader is standalone, ReaderT transforms another monad
13:34:46 <geekosaur> nothing to do with STM
13:34:52 <meoblast001> for example: m >>= return  =  m
13:35:09 <hackrilege> Omg I am now confused
13:35:11 <geekosaur> (in modern Haskell Reader r a is ReaderT r Identity a)
13:35:15 <ski> meoblast001 : "are you sure this type of monad could be considered lawful?" -- try arguing for the laws ?
13:35:29 <meoblast001> arguing for the laws?
13:35:39 <geekosaur> hackrilege, why would that be confusing?
13:35:56 <zv> does the law truly have a philosophical justification?
13:36:06 <geekosaur> I don;t see where you got STM / TVars involved with this at all, so maybe you confused yourself beforehand
13:36:25 <ski> meoblast001 : since you're using `Return' and `Bind' as building blocks, `Bind m Return' will not be identical to `m', but as long as no exported operation allows you to tell the difference, you should be ok
13:36:37 <hackrilege> So ReaderT is function returning a parameterized type?
13:36:55 <ski> meoblast001 : typical things which would not be ok is counting the number of `Return's, or `Bind's, which are executed, e.g. .. that kind of thing
13:37:01 <meoblast001> so it's considered "lawful" if the structures in the end mean the same thing, and is therefore not necessary that they actually be the same thing?
13:37:08 <hackrilege> While Reader is just a function returning a type
13:37:12 <hackrilege> ??
13:37:22 <geekosaur> ReaderT is a function taking a fixed parameter type and producing a result in a monad. Reader just produces a result, not in a monad
13:37:27 <ski> zv : which law ?
13:37:44 <hackrilege> What is I'm to?
13:37:53 <hackrilege> unmtl*
13:38:09 <hackrilege> What is unmtl?
13:38:15 <ski> zv : oh, that monadic law. yes `do x <- m; return x' should be the same as just `m' because `return x' is supposed to "do nothing at all, except yield `x' as a result"
13:38:44 <ski> hackrilege : a lambdabot command unfolding (some) monad and monad transformer definitions, so you can "see through the trees"
13:38:47 <geekosaur> hackrilege, the basic monads (Reader, Writerm State) are all just wrappers for particular kinds of functions. @unmtl shows you what those functions are
13:39:06 <hackrilege> The monad laws are that return is the associative identity of the kliesli arrow
13:39:20 <geekosaur> * (Reader, Writer, State)
13:40:13 <hackrilege> Thanks geekoasaur
13:40:14 <Cale> hackrilege: Yeah, though that's also sort of an awkward description if you want to actually prove anything.
13:40:22 <ski> e.g. if you've forgotten which of `StateT s (EitherT e m) a' and `EitherT e (StateT s m) a' does what
13:40:28 <Cale> It does imply the monad laws
13:40:55 <ski> (in one of them, the state survives an exception, in the other it doesn't)
13:41:54 <ski> meoblast001 : "arguing for the laws?" -- meaning arguing to yourself (to whatever degree in informality you prefer) why you think the laws would be satisfied
13:42:11 <ski> (s/in /of /)
13:43:13 <ski> hackrilege : `State s a' represents computations that'll eventually compute an answer of type `a', and which may read and modify a (single) value of type `s' (the state) along the way
13:43:51 <hackrilege> Nice!
13:44:03 <ski> hackrilege : `Reader r a' represents computations that'll eventually compute an answer of type `a', and which may read and *locally* "overshadow" a (single) value of type `r' (the environment)
13:44:59 <ski> (you may think here of environment variables which are transferred (inherited) from an OS process to child processes (but not vice versa), and which can be locally changed (which is then inherited by the children of that process))
13:45:20 <ski> `Reader' is typically used to push implicit information "down" into a computation
13:45:53 <ski> while with `State' you both push it down "branches", and get back a new value up it again, before going down the next branch. so the state is threaded through the computation
13:46:24 <ski> (there's also `Writer w a', which will collect implicit outputs of type `w' from each branch, and "concatenate" them together. can be used for logging, summarizing, &c.)
13:46:34 <ski> (also called the output monad)
13:47:40 <hackrilege> Wow wow one sec that's a lot to process
13:48:04 <ski> zv : similarly, `do y <- return x; k y' should be equal to `k x' for similar reasons as the previous law
13:49:30 <hackrilege> Hmm, I'm struggling with the geometric analogies you are drawing
13:49:59 <hackrilege> How can you infer so much just from the types?
13:50:03 <ski> zv : finally, `do y <- (do x <- m; k0 x); k1 y' should be equal to `do x <- m; (do y <- k0 x; k1 y)' (which we can "flatten" into the nicer-looking `do x <- m; y <- k0 x; k1 y'), because the *grouping* of the sequenced operations shouldn't matter. only the operations performed, and (in the general case) the *order* of the operations should matter
13:51:28 <zv> ski: your prior laws seem like reformulations of arithmetical identities -- where can I read about 'monadic' identity
13:53:46 <ski> zv : see <http://blog.sigfpe.com/2006/10/monads-field-guide.html> (and possibly also <http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html> (the pdf) ?) for some more info on visualization
13:54:01 <ski> (the paper also seems to mention rationale for the monad laws as well)
13:54:20 <ski> oh, sorry, hackrilege was the one asking about geometric analogies
13:54:26 <hackrilege> I'm studying hylomorphisms, unfold being an anamorphism. I'm interested in the language your using as it invokes the notions of folding and unfolding which are key
13:55:18 <hackrilege> Can I construct a hylomorphism just from Reader Writer etc?
13:56:58 <ski> zv : anyway, in practice, one probably relies on the monadic laws quite often, when refactoring monadic code. if you have `do x <- m; y <- k0 x; z <- k1 y; k2 z', and want to refactor out the `y <- k0 x; z <- k1 y' (sans the `z <-' bit) into a separate function, you need to invoke the monadic laws. also if you want to unfold a definition back into its use side in the other direction
13:58:13 <ski> zv : and if you unfold a definition of `foo', ending with `return (...)' into a call site `x <- foo', you probably don't want to write `x <- return (...)', but you either replace later `x's with `...', or add an `let x = ...' there
13:58:35 <ski> that's using one of the unit laws
13:59:01 <ski> hackrilege : in case it wasn't clear, the above two links could perhaps be interesting for you as well
14:00:01 <ski> (those posts are by dpiponi. has shown up here, but possibly not in the last couple of years ?)
14:00:18 <ertes> version "1" is equivalent to "1.0", "1.0.0" and "1.0.0.0", right?
14:00:28 <ertes> (in cabal's view)
14:00:33 <hackrilege> Do you have any terms I could use to search? Could you indicate if my suspicion is rational?
14:01:51 <ski> (btw, note that the pics at the first link there presupposes you've "flattened" out your computation tree of primitive operations into a sequence of them. given an original tree (from recursion, usually), `Writer',`Reader',`State' there would look like traversing a tree, not a list)
14:02:16 <ski> (though traversing `ListT (Blah b)' is like adding another "dimension" of tree to the whole thing)
14:02:19 <ertes> more generally: are all unspecified version number components zero?
14:03:43 <ski> hackrilege : i don't recall offhand whether hylo is "seed >-> structure >-> summary" (iow, build-then-destroy), or "structure >-> intermediate >-> another-structure" (translation) ?
14:04:32 <hackrilege> It's the former
14:04:54 <ski> what would be the structure, in your "Can I construct a hylomorphism just from Reader Writer etc?", then ?
14:04:59 <hackrilege> Unfold builds a structure, fold summarises it
14:05:04 <ski> yes
14:05:23 <ski> some custom data structure ? or `Reader'/`Writer'/&c. itself ?
14:05:49 <hackrilege> The structure would be eg a cycamore, or Data.Map
14:06:02 <ski> @wn cycamore
14:06:03 <lambdabot> No match for "cycamore".
14:06:29 <hackrilege> Oooo I'll find the cycamore paper one sec
14:06:59 <ski> i'm not seeing along which lines you were thinking when you connected what was said about monads like `Writer w',`Reader r',`State s' above to *-morphisms
14:08:40 <ski> if we're talking about an `runX :: X a -> ..a..' of some kind, for `X' being one such monad, then this would presumably be a fold/cata of the structure describing the monadic computation
14:09:13 <ski> perhaps you're wondering about examples of where you build up some intermediate `X'-action, only to tear it down soon after ?
14:10:44 <hackrilege> http://cs.wellesley.edu/~fturbak/pubs/ppdp01.pdf
14:10:44 <hackrilege> [1] Cycle Therapy: A Prescription for Fold and Unfold on Regular Trees, F. Turbak and J.B. Wells
14:10:55 <hexagoxel> ertes: nope
14:10:58 <hexagoxel> > compare (Version [1] []) (Version [1,0] [])
14:11:00 <lambdabot>  Not in scope: data constructor ‘Version’Not in scope: data constructor ‘Vers...
14:11:25 <hexagoxel> (welp; import Data.Version) the output is LT
14:13:02 <hexagoxel> "Version number ordering is already defined by Cabal as the lexicographic ordering of the components."
14:13:04 <hexagoxel> @where pvp
14:13:04 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
14:13:12 <ski> hackrilege : hm, looks interesting
14:13:53 <hackrilege> Ski, you talked about pushing computations down branches and gathering the results
14:14:57 <ski> hackrilege : well, rather pushing extra (implicit) *information* down (and theading back up, for state, or only collecting up for output) computation branches
14:15:36 <hackrilege> Sounds like Applicative
14:16:55 <ski> well, the specific nature of the computation (in this case applicative or monadic) is a distinct thing. that relates to whether later (sub)actions can depend ("structurally") on values computed by earlier ones, or not
14:17:16 <ski> s/values computed/monadic result values computed/
14:17:18 <hackrilege> > ( sum . ( take 5 ) . repeat ) 1
14:17:20 <lambdabot>  5
14:17:45 <ski> i was talking about implicit values (not the monadic result), that are passed around (and perhaps also processed along the way) in some fashion
14:17:50 <xa0> aka (*5) :p
14:18:13 * ski is attempting to get on the same page as hackrilege, probably not succeeding yet
14:19:06 <hackrilege> :t scan
14:19:07 <lambdabot>     Not in scope: ‘scan’
14:19:07 <lambdabot>     Perhaps you meant one of these:
14:19:07 <lambdabot>       ‘scanl’ (imported from Data.List),
14:19:16 <hackrilege> :t scanl
14:19:18 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:20:26 <hackrilege> (hackrilege) > ( sum . ( scanl (+) 0 ) . repeat ) 1
14:20:40 <hackrilege> > ( sum . ( scanl (+) 0 ) . repeat ) 1
14:20:45 <lambdabot>  mueval-core: Time limit exceeded
14:20:57 <hackrilege> Outch
14:21:05 <hackrilege> Nvm
14:21:36 <hackrilege> So that pushes values down the list, it's that not the same?
14:21:47 <hackrilege> is*
14:22:04 <ski> anyway, `ST' is often used internally, building some structure, doing some mutation, then reading off the answer into a result structure
14:22:47 <ski> (sometimes `State s' or `Writer w' is used like this as well, &c.)
14:23:13 <ski> hackrilege : same as what ? `Reader' ?
14:23:33 <hackrilege> How would I write scan using state writer and reader?
14:23:42 <ski> `scanl' ?
14:23:52 <hackrilege> Yeh
14:24:44 <hackrilege> Firstly, is that the correct sort of "pushing down" through List
14:25:04 <hackrilege> That you used earlier
14:26:07 <hackrilege> (ski) `Reader' is typically used to push implicit information "down" into a computation (ski) while with `State' you both push it down "branches", and get back a new value up it again, before going down the next branch. so the state is threaded through the computation
14:26:10 <hackrilege> (ski) (there's also `Writer w a', which will collect implicit outputs of type `w' from each branch, and "concatenate" them together. can be used for logging, summarizing, &c.)
14:27:11 * MichaelK waves
14:27:13 <hackrilege> Writer here sounds like fold
14:27:33 <hackrilege> Reader like map
14:28:01 <hackrilege> State is like traversal, or fold again
14:29:03 <raidenfreeman> I'm really confused with indentation/blocks. How can I make sure that I've indented something correctly if the editor doesn't have a monospace font (one with similar size for every character including space)? Also is there a way to bulk add spaces? (some editors support changing tab to add spaces, but is there some general way to avoid typing space
14:29:04 <raidenfreeman>  too much?)
14:29:33 <hackrilege> Use the correct font
14:30:28 <raidenfreeman> So if I don't have a font setting (f.e. I'm writing in a terminal with GHCi) I'm screwed?
14:30:43 <ski> @let scanlState :: (b -> a -> b) -> b -> [a] -> [b]; scanlState f q ls = loop ls `evalState` q where loop as = do {q <- get; (q :) `liftM` go as}; go [    ] = return []; go (a:as) = do modify (`f` a); go as
14:30:47 <lambdabot>  Defined.
14:30:50 <hackrilege> Type :e in ghci
14:30:55 <ski> hackrilege ^ i think
14:31:13 <hackrilege> Omg!
14:31:38 <ski> however, you could just as well use `Reader' here, since you never need to get the state "back up" again from the recursive calls
14:31:53 <ski> (as you e.g. would, if there were more than one recursive call, siblings)
14:32:03 <hackrilege> Oh nice
14:32:16 <hackrilege> So reader is restricted to list in some way?
14:32:38 <ski> you'd use `ask' instead of `get', and `local (`f` a) (go as)' insyead of `do modify (`f` a); go as'
14:32:51 <hexagoxel> "There is no documentation for transformers-0.5.2.0."
14:33:04 <ski> reader/environment/input is restricted to passing the implicit information "down"
14:33:39 <ski> (possibly changing it locally for some computation subtrees)
14:33:52 <hackrilege> So can use of writer replace sum in my example?
14:34:15 <hackrilege> "Getting the information out" via fold
14:34:16 <ski> writer/output is restricted to passing the implicit information "up" (combining using a monoid, when you get several outputs from "sibling" subcomputations)
14:34:49 <hackrilege> Like fold
14:34:54 <hackrilege> ?
14:35:29 <MichaelK> General question: does anyone know of good resources for getting from lower-intermediate level experience with Haskell to job ready?
14:35:58 <ski> (the former doesn't order the siblings, apart from what is implied by your data dependencies in your monadic action. the latter also doesn't order, apart from ditto, except that obviously the ordering matters for the "concatenation" of output (except when it doesn't, e.g. when you're summarizing a number (or a couple of them) as output. addition is commutative)
14:36:58 <ski> state/threading passes the current state value up and down branches, doing a depth-first traversal of the computation tree. each node which recieves it can potentially change the state. later nodes, either further down, or higher up, can see that change
14:37:12 <ski> here obviously the ordering is more important
14:37:17 <hackrilege> MichaelK, write a nice piece for your portfolio
14:37:19 <LysergicDreams> MichaelK: https://stackoverflow.com/questions/1012573/getting-started-with-haskell
14:37:31 <ertesx> hexagoxel: so "1" is actually lower than "1.0"
14:37:38 <ertesx> .nick ertes
14:37:40 <LysergicDreams> MichaelK: and +1 to personl projects
14:37:45 <ertes> sorry
14:37:58 <hexagoxel> ertes: yes
14:38:07 <ski> generally, it's better to use output or environment, than state, if you can help it (without complicating stuff too much, whatever that means in your specific circumstance)
14:38:18 <ertes> thanks
14:38:34 <ski> if you're traversing (an infinite part of) an infinite structure, then state will give you no final state value
14:39:02 <ski> however, if you only need output, then `Writer w' can still give you an (infinite) "log"/output/summary
14:39:02 <hackrilege> Only finite data here
14:39:08 <Luke> is there a function like isInfinite to test for the difference between positive and negative infinity?
14:39:19 <ski> that's a case where output is strictly better than state
14:40:40 <ski> @hoogle isInfinite
14:40:41 <lambdabot> Prelude isInfinite :: RealFloat a => a -> Bool
14:41:01 <verement> Luke: (> 0) ?
14:41:06 <sphinxo> What's the difference between hprint and hputstrln?
14:41:20 <daakr> is there a limit to the number of types ghc can represent?
14:41:30 <MichaelK> LysergicDreams, that's a good qa on stackexchange (I'm in intermediate). I'm in the middle of working through the libraries noted, but not sure how to work towards more specific job-related things. 
14:41:34 * ski doesn't recall whether there are distinct positive (resp. negative) infinites in floating-point
14:41:36 <Welkin> putStrLn applies show and adds a newline
14:41:37 <MichaelK> Should I just start looking at jobs?
14:41:39 <daakr> (i'm thinking 32/64 bits worth of types)
14:41:43 <ski> @src putStrLn
14:41:43 <lambdabot> putStrLn s = do putStr s; putChar '\n'
14:41:48 <xa0> ski: there are
14:41:55 <hackrilege> So are you saying that deep down all Haskell functions like map are represented in terms of these crazy state things?
14:41:59 <Welkin> LysergicDreams: lol, love the name
14:42:04 <sphinxo> ooh ok
14:42:55 <daakr> Welkin: you might be thinking about "print"
14:43:00 <LysergicDreams> Welkin: :)
14:43:38 <Welkin> daakr: the "h" functions are the same, except they send the result to standard out instead of another handle
14:45:18 <sphinxo> LiftM vs fmap?
14:45:32 <Welkin> sphinxo: they are the same
14:45:36 <ski> hackrilege : hm, i'm not following "Writer here sounds like fold","Reader like map","State is like traversal, or fold again"
14:45:37 <hackrilege> :t liftM
14:45:37 <Welkin> liftM is fmap for Monads
14:45:38 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:45:51 <sphinxo> Aahh ok
14:45:52 <ski> hackrilege : hmm "So can use of writer replace sum in my example?","\"Getting the information out\" via fold" ..
14:45:53 <sphinxo> thanks
14:46:06 <LysergicDreams> MichaelK: At that point I'd just start on a project related to your job. Use it to learn how to structure applications & tackle problems in bite-size pieces.
14:47:12 <LysergicDreams> MichaelK: And don't expect to finish it or for it to be awesome.
14:47:56 <hackrilege> It all sounds like a traversal
14:48:02 <ski> raidenfreeman : you have a proportional font in your terminal ?
14:48:54 <MichaelK> LysergicDreams: I'm currently a student so I have a couple projects of that kind, but am unsure how applicable they are to what I should expect for a job.
14:49:03 <hackrilege> Can you explain how you could alter a list using Reader? Perhaps implementing map?
14:49:46 <Welkin> MichaelK: what is this obsession with jobs?
14:49:53 <ski> hackrilege : "So reader is restricted to list in some way?" -- the point here was that since there's at most one sublist of a list, which the recursion traverses, and because we don't need to refer to the state after the recursive call (nor do we desire the final state after the top call), we can therefore replace the use of state with environment/input/reader in that case. but reader can be used gainfully on branching structures as well, it's just that the
14:49:55 <Welkin> Just do something you enjoy
14:49:58 <LysergicDreams> MichaelK: Depends 
14:50:01 <Welkin> don't worry about trying to impress anyone
14:50:17 <Welkin> you will have to learn how to do everything in the moment anyway
14:50:33 <Welkin> there is no amount of preparation that will prepare you for any job
14:51:05 <Welkin> it's all based on the fundamentals, which you probably already know
14:51:24 <ski> sphinxo : `liftM' (or `liftA') is sometimes useful as a default implementation for `fmap', if you already have written a `Monad' instance (similarly you can define `pure = return; (<*>) = ap' for `Applicative', given `Monad')
14:51:26 <LysergicDreams> practice versatility
14:51:29 <Welkin> just have fun with it
14:51:31 <MichaelK> Welkin: I'm doing what I enjoy, programming Haskell and working on random projects. I just want to make sure I cover my bases for when I graduate.
14:51:40 <sphinxo> ski: good to know, thanks
14:51:59 <ski> @type ap
14:52:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:52:39 <Welkin> MichaelK: you will never cover your bases, because it is impossible to learn everything
14:52:52 <ski> xa0, ty
14:53:15 <Welkin> do you want to work on physics engines for video games? Do you want to build microservices for the web?
14:54:13 <zomg> Welkin: but.. but.. I've done both
14:54:15 <zomg> :p
14:54:29 <zomg> (granted, the physics engine I made was utter shit, but still!)
14:54:33 <ski> hackrilege : so writer is typically used when you have some (not that varying) kind of summary/logging/output you want to collect for a specific given monad. so you have actions of type `M T', for various different monadic result types `T', for a single fixed monad `M', which determines the type of the implicit output
14:54:33 <Shockk> I'm in a similar position to you MichaelK but just a little bit closer to wanting to look for a job somewhere; I was at a conference yesterday to do with getting employed in the computing and creative industries, and one point that almost all the speakers hit on during the talks was to try and end up in something you really enjoy doing and feel passionate about
14:54:53 <ski> @tell hackrilege so writer is typically used when you have some (not that varying) kind of summary/logging/output you want to collect for a specific given monad. so you have actions of type `M T', for various different monadic result types `T', for a single fixed monad `M', which determines the type of the implicit output
14:54:53 <lambdabot> Consider it noted.
14:55:04 <Shockk> and if you focus on that, the projects you do anyway during your spare time will most likely be relevant to the jobs you're searching for
14:55:08 <Shockk> (I'm probably off-topic)
14:55:11 <Welkin> Shockk: haha, passion is a meaningless word these days. Its literal meaning is "suffering"
14:55:14 <MichaelK> Welkin: fair point. I'd be happy to work on basically anything performance centric and backend
14:55:22 <Welkin> if someone uses the word "passion", you know they are bullshitting you
14:55:31 <caconym> ha
14:55:39 <ski> @tell hackrilege obviously one can imagine parameterizing `M' on the type of output, possibly adding some class constraints to restrict it a bit. however let's not consider that generaliy atm
14:55:39 <lambdabot> Consider it noted.
14:56:11 <Welkin> if you enjoy doing something, and you have the motivation to learn and get better at it, then do it
14:56:14 <Welkin> forget about passion
14:56:14 <sphinxo> isJust vs /= Nothing ?
14:56:35 <caconym> MichaelK: I've always worked on random crap that I found interesting and it has not been directly relevant to anything i ended up doing in the professional world but the exploration has been extremely valuable
14:56:38 <Shockk> that was really the definition I was going for, for "passion", though
14:56:53 <jle`> Shockk: (/= Nothing) requires an Eq constraint
14:56:57 <ski> @tell hackrilege in your case, there didn't seem to be any other result to speak of than the sum of the list itself. i suppose you could use `Writer (Sum Integer) ()' still, but it doesn't make that much sense for that small example. perhaps for a more involved example ?
14:56:57 <lambdabot> Consider it noted.
14:56:58 <jle`> er, sphinxo *
14:57:21 <caconym> and if you are stoked about your personal projects then you'll be more likely to spend more time with them
14:57:37 <sphinxo> ahh ok
14:57:51 <jle`> isJust is probably preferred
14:57:57 <jle`> like null over (/= [])
14:58:01 <ski> @remember Welkin haha, passion is a meaningless word these days. Its literal meaning is "suffering". if someone uses the word "passion", you know they are bullshitting you
14:58:01 <lambdabot> Good to know.
14:58:02 <jle`> um (== [])
14:58:10 <jle`> and in most cases, you could probably just pattern match anyways
14:58:42 <Welkin> your technical skills are not what will get your hired anyway; your ability to position yourself as the right person for the job is what matters
14:58:53 <MichaelK> caconym: That's exactly what got me from math to programming, I found projects I loved and they tended strongly to be programming centric (basically the same case with Haskell)
14:58:54 <Welkin> companies universally suck at hiring, and it is just a social game, like dating
14:59:08 <ski> jle` : yep and yep
14:59:35 <iphy> https://github.com/TokTok/hstox/blob/master/src/Network/Tox/ExternalTest/Test.hs#L32-L62 <- is there a way to have a default Construct instance for types that don't have a special Deconstruct type, so Deconstruct a = a?
14:59:55 <MichaelK> Welkin: yeah, I've been doing some programming interview stuff but I keep seeing more and more that it's not skill based.
15:00:45 <Welkin> MichaelK: it isn't, and "technical interviews" are an insult to everyone
15:01:09 <Welkin> no one else is asked to perform circus tricks like programmers are in recent years
15:01:19 <iphy> hmm, default construct :: a -> a seems to work
15:01:29 <caconym> it really depends on the company whether they'll be more likely to ask you some stupid questions about manhole covers on the spot or whether they'll ask you to implement red-black trees on a whiteboard haha
15:01:42 <caconym> the latter, of course, is an exaggeration... barely
15:02:11 <caconym> maybe things are skewing toward the former these days, i haven't had an interview in a while :/
15:02:22 <monochrom> on the other hand, many candidates petrify when asked to merely code up fizz-buzz
15:02:25 <jle`> iphy: for something like that i'd probably use associated types with the typeclass instead
15:02:41 <jle`> iphy: unless you plan on using Deconstruct for things that aren't Construct instances
15:02:59 <iphy> I don't
15:03:17 <iphy> makes sense
15:03:21 <jle`> class Construct a where
15:03:25 <jle`>     type Desonstruct a
15:03:25 <MichaelK> monochrom: so "here's fizzbuzz in 15 ways, hire me"?
15:03:33 <jle`>     construct :: Deconstruct a -> a , etc.
15:04:38 <caconym> the fizzbuzz thing is pretty astonishing
15:05:36 <monochrom> the blog I read it from says that fizzbuzz weeds out 90% of his candidates already. so I'm pretty sure that if you can do fizzbuzz a few ways, he would take you seriously.
15:05:36 <Welkin> they could be great programmers, but they get stage fright
15:05:38 <Welkin> it happens
15:06:51 <MichaelK> Welkin: I could see that. I imagine that if I were asked to write fizzbuzz, I'd pause to wonder whether to write a "dumb" implementation or show off a bit more
15:07:37 <Welkin> the real problem is that these questions are asked at all
15:07:42 <caconym> oh i have no doubt that there are interviewers out there who will give you a no-hire because they didn't like your perfectly functional fizzbuzz
15:07:43 <Welkin> it is insulting
15:07:57 <monochrom> stage fright happens across all interview activities across all work sectors. by invoking stage fright you're pretty much ruling out interviewing altogether
15:08:03 <Welkin> yes
15:08:05 <Welkin> I am
15:08:09 <Welkin> interviewing is broken
15:08:25 <Enigmagic> best to not work
15:08:39 <Welkin> but in particular, programmers tend to be terrible at social abilities
15:09:02 <MichaelK> is one allowed to ask for context? i.e. "ok so you want X implemented. do you want it implemented for speed, quickfix, or ___?"
15:09:24 <monochrom> except that "show some red-black tree code" or "show some fizzbuzz code" is not a social ability
15:09:36 <Welkin> you can easily find out is a candidate knows how to program by just talking with them
15:09:37 <monochrom> "let's chat" is
15:09:39 <Welkin> have a conversation
15:09:42 <Welkin> don't make it into an examination
15:10:15 <Welkin> monochrom: it is, because you are performing in front of an audience who is judging you
15:10:36 <caconym> i've never done one but i like the idea of take-home problems
15:10:45 <Welkin> that is not good either
15:10:50 <caconym> they allow you to set pretty hard challenges without the amygdala getting in the way
15:10:55 <Welkin> experienced programmers don't want to waste their time with it
15:11:07 <caconym> well if they want the job...?
15:11:09 <monochrom> hmm why am I talking about this in #haskell?!  <duck>
15:11:14 <Welkin> they have many years of experience that they can talk about
15:11:26 <caconym> it's pretty easy to spot whether a company's just trying to get you to work for free IMO
15:11:30 <Welkin> why focus on a made-up homework problem that they spent 2 hours on?
15:11:34 <bshelden> MichaelK: Do ask those questions.  It's not a bad thing to ask questions that would have you filtered out by those you couldn't successfully work with.  (Yes, of course there are limits to this)
15:11:58 <bshelden> I get nervous about candidates who don't ask that kind of question of me.
15:11:58 <caconym> because it's a demonstration of their programming skills? surely relevant for a softwre engineering job... and surely you want to see at least some code from them
15:12:17 <Welkin> caconym: you see, interviewing goes both ways. Not only is the company interviewing *you*, but you are interviewing *them* as well
15:12:27 <caconym> that's exactly right
15:12:58 <MichaelK> bshelden: Do you mean common sense limits or something more particular?
15:13:14 <diamat> socializing is a learned ability
15:13:16 <bshelden> Common sense.  It's an interview and negotiation, not a perfect world wishlist.
15:13:31 <Welkin> diamat: that is true, but some are ahead of others
15:13:40 <diamat> yes, and some also happen to be programmers
15:14:13 <bshelden> I'm not going to find my perfect candidate.  The candidate isn't going to find their perfect job.  That said, maybe we can both find something we're happy with, and the only way to get a sense of that is to ask questions.
15:14:26 <diamat> the frequency with which one puts oneself in another's shoes is a good proxy imo for socializability
15:14:54 <caconym> if I interview at company X honestly i'm going to question the skill of the engineers I'll be working with if they don't ask me to demonstrate any code
15:15:07 <Welkin> caconym: why is that?
15:15:10 <Welkin> skills don't matter
15:15:19 <bshelden> O.o
15:15:21 <Welkin> anyone who is smart can learn a new language in a couple weeks
15:15:27 <Welkin> or learn a new framework in a few days
15:15:28 <bshelden> Oh boy...
15:15:34 <caconym> skills matter hugely
15:15:41 <caconym> language X can be learned in a few weeks usually
15:15:43 <Welkin> skills are the cheapest thing to gain
15:15:47 <bshelden> Programming skill.  Not specific knwoledge of syntax.
15:15:53 <bshelden> You're confusing these things.
15:15:57 <bshelden> And it's critical to not do that.
15:15:57 <MichaelK> caconym: what about see a sample of their code? or do most places not do that?
15:16:02 <Welkin> evaluating someone based on what they did in the past makes no sense
15:16:16 <Welkin> right now they may not know your specific framework, but next wekk they will
15:16:23 <Welkin> next week*
15:16:34 <caconym> Welkin: I would never ask someone to e.g. implement a rails controller
15:16:37 <caconym> that's stupid
15:16:50 <bshelden> I'll give short programming questions, but I'm pretty open to what syntax they decide to use.  And I don't give a damn about silly things like syntax when on a whiteboard.  We have computers to check that.
15:17:07 <caconym> bshelden: exactly
15:17:17 <monochrom> yeah I would accept pseudocode or perfect Haskell
15:17:26 <caconym> MichaelK: I think some places ask for samples, not always though
15:17:38 <bshelden> What I care about is a demonstration of programming /skill/.  Ability to reason.  Understanding of logic.  Critical thinking.
15:17:46 <caconym> some places also ask you to code in e.g. google docs as part of a "phone screen"
15:17:56 <caconym> which is the worst
15:18:05 <caconym> because you can never hear the *#($& guy on the other end
15:18:08 <MichaelK> caconym: I mean the candidate asking for samples
15:18:17 <Welkin> caconym: I have had many phone screens
15:18:19 <diamat> i wonder if there's a no-free-lunch theorem applicable to candidate interview optimization
15:18:22 <caconym> oh, i've actually never heard of that
15:18:23 <Welkin> they were all universally terrible
15:18:53 <caconym> Welkin: i think we have some common ground here, at least ;)
15:18:57 <bshelden> Phone screens are, as the name implies, a tool used to reduce the number of choices the employer needs to deal with.
15:19:01 * MichaelK will be right back
15:19:49 <bshelden> Finding the best candidate is not a linear algorithm, sadly.
15:20:16 <diamat> the phrase "an infinite dimensional orange is all skin" comes to mind.. lol
15:20:21 <Welkin> I have also had in-person interviews with some HR drone who didn't know anything about programming, so when she learned that I did now know Ruby on Rails, she declined, after only asking me some really naive HR questions
15:20:51 <bshelden> And that should have been a warning of the kind of person you'd be working with had you got the job.
15:20:55 <caconym> Welkin: a very similar thing happened to me, i was not too sad to lose that "opportunity" :)
15:20:57 <bshelden> There are better places to apply to
15:21:30 <diamat> how much coffee do y'all drink
15:21:38 <Welkin> diamat: zero
15:21:44 <bshelden> Too much.  Need to cut back again.
15:21:52 <caconym> i like the idea of the take-home question (i've never done one or set one) because it potentially tests design skills, which are IMO the place where a crappy co-worker is going to screw you
15:21:55 <bshelden> I don't even need it.  This place has decent hours.
15:22:05 <caconym> coding tree algos on a whiteboard doesn't really do that
15:22:22 <Welkin> I have done a take-home project *after* the phone screen, and got *no response*
15:22:35 <diamat> Welkin: :(
15:22:36 <Welkin> so that was a huge waste of my time
15:22:37 <caconym> wow, that's awful
15:22:41 <bshelden> I do try not to ask more than a couple "circus trick" questions.  Damned if I could write a tree balancing algo.  I use libraries for that.
15:23:19 <bshelden> The real point of those is to double check that I'm speaking to a programmer and not someone who paid for help getting past the screens.
15:23:25 <caconym> yup
15:23:31 <Welkin> what's the point of that?
15:23:36 <Welkin> you'll be discovered on day one
15:23:42 <caconym> but then you're already hired
15:23:46 <Welkin> so?
15:23:46 <bshelden> I'd rather discover them /before/ making an offer.
15:23:50 <caconym> so hard to get rid of you if you make it that far
15:23:51 <Welkin> you can be fired immediately
15:23:57 <caconym> so expensive
15:24:07 <bshelden> Far cheaper to refuse to offer than fire on day 1.
15:24:08 <diamat> how about a hunger games style bracket? ;)
15:24:17 <caconym> diamat: code to the death?
15:24:23 <diamat> maybe
15:24:33 <diamat> at the minimum let interviewers' programs duke it out
15:24:33 <bshelden> By the time a candidate is talking to me, they're being pretty seriously considered.  That /is/ the day 1.
15:24:42 <diamat> *interviewee's
15:24:54 <caconym> how about like that movie "cube" except the candidates must modify the cube's control program collaboratively to escape
15:25:03 <caconym> but if more than one of them escape, nobody gets the job
15:25:07 <diamat> lol
15:25:27 <monochrom> "there will be blood"
15:26:22 <Welkin> the funny thing is that companies are so afraid of hiring the wrong person that they sabotage themselves by hiring no one at all and spending 10 times as long to find someone who is just as good as someone they could have found many months earlier and trained during that time
15:26:28 <Welkin> short-term thinking
15:26:56 <diamat> "alright everyone, your programs must be capable of sexual reproduction w/ other candidates' programs. the testing environment will subject them to grisly shocks. may the divine triump.."
15:26:59 <bshelden> You should try management, then find out how well that actually goes for you.
15:27:08 <caconym> diamat: hahaha
15:28:04 <Welkin> bshelden: how many people do you pass on because someone in the hiring committee doesn't like the way they look, or talk, or something else?
15:28:15 <Welkin> or they feel threatened by them
15:29:16 <bshelden> Not a problem on my team.  But then, I give a damn about finding a good new team member.
15:29:29 <bshelden> Note that how they talk /is/ important criteria
15:29:48 <bshelden> If the person rubs the team the wrong way, that just isn't gonna work
15:30:09 <bshelden> We're going to be spending much of our lives interacting with the person.
15:30:20 <Welkin> really?
15:30:29 <Welkin> most people don't stay at any given company for more than 2 years
15:30:30 <Eduard_Munteanu> Well, you shouldn't really base that decision on a few minutes' conversation then.
15:30:32 <Welkin> 1 year even
15:30:54 <bshelden> Yeah, not on my team.  I've been with this group for 6? now.  I think 6 years.
15:30:56 <Welkin> you aren't marrying them
15:31:25 <bshelden> Eduard_Munteanu: No argument there, and the 'fit' decision definitely carries on into the first month or so of working with a person.
15:31:39 <caconym> even a month of a problem person sabotaging a team is a major bummer
15:31:50 <bshelden> During the interview, I don't try to find a mythical "perfect fit".  I'm more checking for "Oh my god I can't stand this person".
15:34:11 <iphy> jle`: https://github.com/TokTok/hstox/blob/master/src/Network/Tox/ExternalTest/Test.hs#L90-L92
15:34:17 <iphy> jle`: is there a way to default the type?
15:34:26 <iphy> with "type family", I can do that
15:35:54 <iphy> oh, I can just write type Deconstruct a = a below it
15:35:54 * hackagebot prometheus 0.1.0.3 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.1.0.3 (LukeHoersten)
15:37:10 <iphy> finally, is there a way to write this shorter: https://github.com/TokTok/hstox/blob/master/src/Network/Tox/ExternalTest/Test.hs#L35-L40
15:38:53 <Iceland_jack> iphy: At a quick glance you could write
15:38:54 <Iceland_jack>     type Foo c a = (c a, c (Deconstruct a))
15:40:07 <Eduard_Munteanu> iphy, do you really need the constraints in the class context?
15:40:26 <iphy> Eduard_Munteanu: what do you mean?
15:41:13 <iphy> ah
15:41:15 <Eduard_Munteanu> iphy, do you specifically need (Binary a, Binary ...) in the class declaration as opposed to putting those constraints in the instances?
15:41:26 <iphy> Eduard_Munteanu: no I don't, but then I need them where they are used
15:41:56 <iphy> for example
15:42:11 <iphy> https://github.com/TokTok/hstox/blob/master/src/Network/Tox/ExternalEncodingSpec.hs#L17
15:42:15 <Eduard_Munteanu> iphy, you should probably use a constraint synonym for brevity and put the constraints where they really belong
15:42:21 <iphy> here, I would need all those constraints
15:42:36 <iphy> Eduard_Munteanu: hmm
15:43:12 <Eduard_Munteanu> type Foo a = (Binary a, Binary (Construct a), ...)
15:46:18 <iphy> yeah, that's much better
15:46:19 <iphy> thanks
16:03:39 <nineonine> hi there
16:03:48 <nineonine> im having some issues with aeson
16:04:05 <nineonine> when im trying to derive necessary instances using Generic
16:04:15 <nineonine> of my data which contains Text fields
16:04:35 <nineonine> im getting this error
16:04:47 <nineonine> No instance for (ToJSON Text)
16:04:47 <nineonine>       arising from the second field of ‘Video’ (type ‘Text’)
16:05:13 <nineonine> same for FromJSON
16:05:35 <nineonine> then im trying to give instances of ToJSON / FromJSON manually
16:05:39 <Squarism> Im gonna do a demo of haskell for "statiscs people" tomorrow. Anyone know where i could find some code to convince them of haskells beuty.. they are sql type statistics people so rather list/map cooolness than some mathy statistics
16:05:42 <nineonine> and still having this issue
16:05:51 <nineonine> No instance for (FromJSON Text) arising from a use of ‘.:’
16:06:02 <nineonine> No instance for (ToJSON Text) arising from a use of ‘.=’
16:06:10 <Squarism> really.. just a nice demo of map/list manipulation would be nice. not to many lines
16:10:38 <nineonine> @Squarism http://learnyouahaskell.com/higher-order-functions
16:10:39 <lambdabot> Unknown command, try @list
16:10:53 <nineonine> Squarism https://en.wikibooks.org/wiki/Haskell/Higher-order_functions
16:11:06 <nineonine> Squarism https://wiki.haskell.org/How_to_work_on_lists
16:13:57 <eitanChatav_> nineonine: that's strange, both strict and lazy Text have To/FromJSON instances
16:14:08 <nineonine> yeah i know
16:14:23 <nineonine> and they live in Data.Aeson.Types.Instances
16:14:34 <puregreen> is there any reason to choose scotty over spock?
16:14:34 <eitanChatav_> yup
16:14:50 <iphy> What's the advantage of Int over Int32 or Int64?
16:14:52 <nineonine> when im trying to import them explicitly im getting complaints that its is hidden
16:15:58 <eitanChatav_> you should only need to import Data.Aeson
16:16:06 <eitanChatav_> and Data.Text
16:16:10 <nineonine> and that is what I do !
16:16:36 <eitanChatav_> do you know if you're using the latest versions?
16:16:54 <nineonine> yup
16:16:59 <nineonine> text >=1.2 && <1.3, aeson >=0.11 && <0.12
16:17:13 <nineonine> interesting thing : im using Atom TE
16:17:29 <nineonine> and when I save the source, ghc-mod gives me no errors
16:17:38 <eitanChatav_> can you post a link to your code snippet on a code snippet site?
16:17:51 <nineonine> however when Im trying to :l into ghci, that is when im getting this error
16:17:53 <nineonine> sure
16:18:44 <nineonine> http://lpaste.net/154883
16:19:41 <hae> Hey everybody, I have a project I'd like to share with you.
16:19:52 <hae> https://gitgud.io/hae/ptcpd
16:20:19 <hae> It's kind of like netcat if netcat could handle multiple connections at once.
16:20:41 <eitanChatav_> lemme see if it works for me, just a minute
16:20:44 <puregreen> nineonine: weird, I'm not getting any errors (while doing :l in ghci)
16:20:49 <puregreen> it's mysterious
16:20:56 <nineonine> so true :\
16:21:36 <nineonine> does it matter if im entering ghci via cabal repl or usual ghci ?
16:21:45 <puregreen> nineonine: can you paste the exact error? full output
16:21:56 <puregreen> nineonine: if you're in a sandbox, then yes, it matters
16:22:03 <nineonine> yup, 1 sec
16:22:10 <puregreen> cabal repl will use packages from the sandbox, ghci will use global packages
16:22:57 <eitanChatav_> yeah, it worked for me, using stack ghci
16:23:11 <eitanChatav_> albeit with an older version of aeson
16:23:17 <nineonine> http://lpaste.net/154884
16:23:34 <nineonine> second part is with Generics
16:23:44 <nineonine> first upper one - when im giving instances manually
16:24:14 <eitanChatav_> you can try using unpack though you shouldn't have to
16:24:15 <puregreen> nineonine: I googled the error message and found this
16:24:15 <puregreen> No instance for (ToJSON Text) arising from a use of
16:24:18 <puregreen> ouch
16:24:20 <puregreen> http://stackoverflow.com/questions/26488684/how-to-create-tojson-fromjson-instances-for-text
16:24:32 <nineonine> I saw that
16:24:53 <nineonine> ok im going to give instances now ...
16:25:05 <puregreen> are you using cabal repl or ghci? or does it give the error in both?
16:25:24 <nineonine> after giving instances manually im getting this
16:25:25 <nineonine>   instance ToJSON Text
16:25:26 <nineonine>     -- Defined at src/Discogs/Types/Release/Video.hs:16:10
16:25:27 <nineonine>   instance ToJSON Text
16:25:27 <nineonine>     -- Defined in ‘aeson-0.11.1.1:Data.Aeson.Types.Instances’
16:25:54 <nineonine> will try both : cabal repl and ghci now
16:27:03 <nineonine> well you were right !
16:27:10 <nineonine> cabal repl gave me this
16:27:35 <nineonine> http://lpaste.net/154886
16:27:45 <nineonine> same thing as in stackoverflow
16:28:53 <nineonine> what should I do here ? 8) 
16:29:19 <puregreen> if I were you I'd just delete the sandbox and recreate it, but there are probably people here who know better
16:29:53 <puregreen> I kinda hope that “reset everything” isn't the optimal solution in this case
16:29:55 <sbrg> I am getting linking errors after refactoring my code from an executable to a lib + exe. googling makes me suspect this is because I have nothing in other-modules.. is that possible? 
16:30:03 <nineonine> ok will do it now. thanks for help !!!
16:30:12 <hae> *sigh*
16:32:57 <puregreen> sbrg: I think it's possible, I was getting linking errors several times and it was pretty much always because of forgetting to list a module in other-modules
16:33:04 <puregreen> I wish cabal warned about this
16:33:49 <sbrg> it sometimes warns me, but sometimes doesn't.. I'm using stack. but yes, I can confirm that missing other-modules was it.
16:33:59 <sbrg> I can't get it to produce a warning currently
16:34:28 <sbrg> I wish I could because I have a lot of modules and its output lists them all ready for copy-paste
16:34:48 <puregreen> hae: maybe you should announce it on r/haskell instead, because the chances of getting feedback about anything on #haskell are pretty random (as long as you're not explicitly saying “review my code please”)
16:35:20 <puregreen> e.g. I've never had to use netcat and so I don't even know what it's going to be useful for, etc
16:36:43 <hae> Okay thanks for the advice.
16:40:20 <sm> hae: is that a protocol you invented ? I see http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1181383&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1181383 ?
16:41:11 <hae> It's not that, sm.
16:41:23 <sm> ok
16:41:58 <sm> with a little more docs and motivation, you'll get more feedback
16:42:17 <hae> Yeah I just finished getting it into a working stat
16:42:19 <sm> why would I use, example session etc.
16:42:21 <hae> *state
16:42:22 <sm> sounds nifty
16:43:09 <hae> Thanks for the feedback.
16:43:31 <hae> I'm going to work on documentation soon.
16:52:49 <ertesx> i found that writing documentation at the same time as code helps me to keep track of the bigger picture
16:53:38 <aricz> documentation.. :( always feel it's a waste of time on smaller projects
16:53:50 <aricz> maybe I'm missing something..
16:55:18 <ertes> aricz: documentation should not repeat in prose what names and types already communicate…  allow yourself to be unfamiliar with your own code, and ask yourself what those two do *not* convey
16:56:19 <ertes> the former is the job of a short introduction with examples, which you can indeed write post-hoc
17:00:40 <aricz> yeah, I just might be too inexperienced with programming to see the wonders of documentation
17:01:03 <aricz> I can understand it if the systems are big and/or complex.. and need different groups of experts.. with many modules etc
17:02:45 <Drezil> is there a good library where i can load images and access the raw-data and define functions in a co-monadic way?
17:03:02 <puregreen> aricz: for me, the value of documentation is that it stops me from being frustrated when I see the code for the first time (and if it's not my job to look at that code, it will make the difference between looking at it and *never* looking at it)
17:03:14 <aricz> hehe
17:03:18 <aricz> good point
17:03:22 <Drezil> i want to implement some custom-filters on images (i.e. gauss, sobel, laplace, custom stuff, ..) and doing that comonadically is the easiest way..
17:04:26 <aricz> but I do agree on making a manual/document on how the code flows.. but that's something that's mostly made at the very end or the end of the software development
17:04:27 <Drezil> juicy-pixels can get me a raw vector of pixels iirc.. but there is not yet a comonad defined on them..
17:05:09 <puregreen> aricz: of course, documentation can be replaced by a person standing over my shoulder and telling stuff like “this function accepts data, then it goes here and here blah blah blah” – and since I like explaining stuff, it's easy for me to write a few paragraphs (or pages) of explanations as documentation, but I think I like explaining stuff more than most people (and more than I should)
17:05:15 <puregreen> aricz: agreed about that
17:07:08 <aricz> hehe puregreen.. I see that one
17:07:22 <caconym> I like generating haddocks for my Haskell projects so that I can see all my modules, functions, types etc. listed clearly on a nice html page
17:07:42 <caconym> sometimes i notice dumbness that was not clear to me from down in the code
17:07:51 <puregreen> aricz: I've also found that notes (as used by GHC) are useful and I sometimes write them during writing code (i.e. when I know that I'm going to hate myself in a couple of months if I don't describe it now), but I'm not sure whether they even count as proper documentation
17:08:08 <aricz> haha
17:08:15 <aricz> nice.. :)
17:08:46 <puregreen> caconym: can you generate haddocks for an executable?
17:09:12 <caconym> puregreen: i've been able to... not sure how it works, i just do `cabal haddock` or `stack haddock` (i think that's a thing?)
17:09:19 <caconym> oh oh
17:09:27 <aricz> I'm new to Haskell, I think the main reason I'm here is Straustrop said in one interview "learn a functional language, just to make your head spin" .. hehe
17:09:28 <caconym> you have to give it an option, --executables i think
17:09:35 * puregreen rubs hands
17:09:35 <aricz> might be taken bad by some of you, but that's the fact :P
17:09:37 <puregreen> excellent
17:09:58 <caconym> yep, that is the right flag
17:10:05 * puregreen is going to generate haddocks for all nir projects from now on
17:10:07 <puregreen> thanks
17:10:32 <caconym> np, and it's infinitely better than doing it e.g. in ruby with rdoc because the types tie it all together
17:10:47 <ertes> Drezil: it's pretty straightforward to build a Store/StoreT around the raw vector that JuicyPixels gives you
17:10:57 <puregreen> aricz: how's it going so far? or have you not started learning it yet?
17:11:21 <aricz> but I also read somewhere Haskell is the language of academic peeps.. the elite.. so-called elite.. hehe
17:11:30 <monochrom> my head did not spin when learning functional programming.
17:11:32 <aricz> that's how one of the articles put it :)
17:11:38 <Drezil> ertes: ye.. i could do that .. but would be nicer if there was an already optimized library for that. ... as i suck at optimizing for performance .. :/
17:11:39 <aricz> I have no problem with it though
17:11:43 <ertes> Drezil: i've started working on such a library, but due to lack of use cases it hasn't evolved into a useful package
17:11:45 <caconym> aricz: it made my head spin and i took it as a challenge :)
17:11:53 <aricz> caconym, exactly :)
17:12:06 <monochrom> instead, my head did spin when reading Stroustrup's rules on how C++ disambiguates multiple inheritance etc
17:12:12 <aricz> haha mono
17:12:21 <ertes> Drezil: you can't really make too many efficiency mistakes when going from vector to StoreT…  it's the other direction that is difficult to get fast
17:13:04 <caconym> i've never asked this channel what it thinks about OOP
17:13:21 <aricz> it's gonna implode
17:13:26 <aricz> jk..
17:13:55 <ertes> caconym: take the number of people in this channel, take the least common multiple with a large prime of your choice
17:14:02 <ertes> that's the number of different responses you will get
17:14:20 <aricz> I also watched a youtube-video about programming languages.. and Haskell scored zero on usefull.. and a lot on safe..
17:14:24 <aricz> :)
17:14:24 <caconym> heh
17:14:34 <xa0> :i even
17:14:39 <monochrom> there are two kinds of programmers. one kind look at "x = x + 1" and have a head spin. the other kind look at "f(x) = x + 1" and have a head spin.
17:15:00 <ertes> all programmers think in binary…  just the symbols they use differ
17:15:20 <ertes> for example haskell programmers think in ∃ and ∀
17:15:26 <aricz> haha
17:16:00 <aricz> here's the video I watched btw.. quite fun.. https://www.youtube.com/watch?v=iSmkqocn0oQ
17:16:28 <aricz> and here I am..
17:18:27 <hae> Who cares about YouTube anyway
17:18:33 <hae> MediaGoblin ftw.
17:19:00 <aricz> never heard of it until now
17:19:54 <ertes> Drezil: i can bring my library into a usable state during the weekend, if you're patient
17:20:52 <ertes> such that it goes from vectors to StoreT and back, the latter with parallelism, and that it supports some basic operations like linear filtering (Int -> Double), rasterization (Double -> Int) and matrix transforms
17:20:53 <Drezil> ertes: no need to hurry. i am generally interested in that and maybe use it later in the year for my master-thesis.
17:20:59 <Drezil> but only maybe if things go well.
17:21:35 <Drezil> basically i just need a comonad-instance on it ..
17:21:50 <ertes> StoreT is a comonad
17:21:56 <ertes> (family of comonads)
17:22:08 <Drezil> yup.
17:22:34 <ertes> not yet sure if it would be sensible to create a custom image type…  i think not
17:23:46 <Sonderblade> is throwing an exception a side-effect?
17:23:58 <sellout> Sonderblade: Yup.
17:24:11 <ertes> i'm thinking of media as at least Store (F P) A, where F encodes the dimensionality (V1 = audio, V2 = picture, V3 = video/3D space, etc.), P is the coordinate type (Int = raster, Double = continuous), and A is the sample type (RGB, stereo sample, etc.)
17:24:14 <hae> The worst kind of side-effect.
17:24:21 <sellout> Sonderblade: Usually, you treat failures as values using the Either type.
17:24:23 <ertes> Sonderblade: effect, not necessarily "side effect"
17:24:38 <sellout> (but there are other options)
17:24:51 <ertes> Sonderblade: you can interpret Nothing is a computation that throws an exception, and 'maybe' as a catcher function
17:24:58 <ertes> is → as
17:25:10 <Sonderblade> then why is head a pure function? https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:head
17:25:38 <ertes> Sonderblade: a pure computation that throws an exception is semantically indistinguishable from an infinite loop
17:25:43 <ertes> we call such values "bottoms"
17:27:03 <ertes> so 'head []' and 'let x = x in x' are the same value
17:27:18 <ertes> or rather semantically indistinguishable
17:28:05 <Drezil> but mostly the runtime-system tells you with "excption" or "<<< loop >>>" :)
17:28:42 <ertes> surprisingly often indeed…  GHC almost solves the halting problem =)
17:28:43 <Sonderblade> ertes: "a pure computation that throws an exception" this is an oxymoron, if throwing exceptions is a side-effect
17:29:49 <ertes> Sonderblade: it's an instance of a value that cannot be computed
17:30:19 <ertes> if you try to evaluate it, you will never get a result…  "something else" happens
17:30:31 <puregreen> Sonderblade: there is no consensus on what is and isn't a side effect (e.g. is allocating memory a side effect? what if you allocate too much and the kernel kills your process?)
17:30:51 <ertes> like the CPU being infinitely busy or some IO action observing the failure to compute as a side effect
17:30:58 <caconym> where does the term "partial function" fit into this discussion?
17:31:03 <puregreen> so arguments about whether a loop is semantically the same as an undefined aren't particularly illuminating
17:31:09 <Sonderblade> ernst: i.e sellout was wrong and throwing exceptions isn't counted as a side-effect in haskell
17:31:31 <ertes> Sonderblade: depends on how you throw it…  if you use throwIO, then it's an IO effect
17:31:40 <ertes> if you use 'error' or 'undefined', then it's a bottom
17:32:00 <ertes> the "exception" nature of it is only noticed in IO
17:32:29 <emmanuel_erc> Does make it sense to try to write code in an applicative style if, let's say, you're updating the values of a matrix and the actual order of the writes doesn't matter?
17:32:44 <Drezil> emmanuel_erc: yes.
17:32:48 <caconym> isn't it said that 'bottom inhabits every type'?
17:32:57 <ertes> caconym: right
17:33:01 <Drezil> Haxl uses that for example to automatically parallelize.
17:33:17 <emmanuel_erc> oh wow... my thinking is on the right track.
17:33:36 <Drezil> monad "enforces" sequential evaluation... so you cannot use parallelism..
17:33:43 <Drezil> applicative allows for it.
17:33:51 <xa0> monad-par ;)
17:33:54 <caconym> so could you think of partial functions as always returning a value of the specified type, but the runtime notices that the value is bottom and does something special with it?
17:33:56 <Drezil> IF those things don't throw exceptions..
17:34:02 <ertes> Drezil: actually you can, but only during execution
17:34:05 <emmanuel_erc> they shouldn't in my case.
17:34:21 <ertes> Applicative can parallelise before execution
17:34:33 <Drezil> xa0: monad-par is more for concurrency, not parallelism.. in my view..
17:34:40 <caconym> and same with functions that throw "pure exceptions"
17:34:53 <emmanuel_erc> What if the action that needs to take place happens in the ST Monad? Can than actions still be executed in an applicative context?
17:35:18 <ertes> caconym: well, you could say that there are no partial functions in haskell, and that bottom is just another value with the property that you can never observe it
17:35:23 <Drezil> emmanuel_erc: yes - BUT. :)
17:35:41 <Drezil> the applicative-instance defines if that is possible.
17:35:56 <Drezil> <*> for State is sequential (iirc.)
17:36:23 <Drezil> <*> for Parsers can be parallel if im not mixing it up with <|>...
17:36:43 <puregreen> emmanuel_erc: I think Haxl is pretty much the only library that has <*> that is automatically parallelised (and there are also some parsing libraries that have <*> that is more efficient than =<<, probably), so there won't be a difference whether you use applicative or monadic
17:36:45 <ertes> Drezil: actually monad-par is for parallelism, just expressed using concurrent code…  it doesn't allow your code to *behave* like concurrent code
17:37:02 <emmanuel_erc> That would make sense. The library I am using, hmatrix, doesn't have an applicative instance defined for mutable reads and writes.
17:37:16 <aricz> anything must-have for haskell using vim?
17:37:21 <emmanuel_erc> I'll have to sink my teeth into that.
17:37:28 <Drezil> aricz: use neovim :p
17:37:39 <aricz> hehe drezil, cutting edge! 
17:37:48 <Drezil> i had a good youtube-vid showcasing it..
17:38:02 <puregreen> aricz: this might be helpful: http://www.stephendiehl.com/posts/vim_2016.html
17:38:22 <aricz> ty all
17:38:30 <Drezil> neovim is better .. doing hlint/code-check in background without freezing UI, having a real terminal in a tab .. sending selected code to that terminal (i.e. ghci)
17:38:43 <Drezil> i can look it up quickly if you want..
17:38:52 <emmanuel_erc> I would like a link to that video Drezil.
17:38:55 <emmanuel_erc> if you can dig it up it.
17:39:06 <aricz> yeah I heard neovim is better nowadays.. #vim doesn't like it too much though
17:39:08 <aricz> :)
17:39:23 <Drezil> aricz: https://www.youtube.com/watch?v=xZTkrB_tEoY - pretty much inspired me for my vim-setup.
17:39:32 <aricz> thank you
17:39:42 <Drezil> he uses it for javascript/rails/python...
17:39:56 <Drezil> but including ghc-mod and haskell-vim is straightforward..
17:40:14 <aricz> yeah, I'm using vim for asm/c/c++
17:40:22 <aricz> but I want to have a look at haskel
17:40:26 <aricz> haskell..
17:40:43 <Drezil> i have <leader> mapped to space... and some bindings like <leader><leader> to "shutup" (i.e. close hlint-suggestions, clear search-highlight, close nerdtree, ...)
17:40:47 <aricz> heard many bad things about it but.. hehe.. it seem so different it makes it interesting
17:40:50 <aricz> :)
17:40:55 <Drezil> ghc-mod allows for code-completion.
17:40:59 <aricz> it seem/it seems
17:41:09 <emmanuel_erc> Thanks a lot for your help Drezil! I feel as if I am finally starting to hit my stride with Haskell.
17:41:12 <OhTrueful> @pl \x -> [x]
17:41:12 <lambdabot> return
17:41:14 <Drezil> like automatic pattern-matching, showing types of highlighted code, etc.
17:42:10 <aricz> but what's the deal with Haskell? control?
17:42:34 <aricz> it might be a far fetch..but is it like OpenBSD is to the world of Linux?
17:42:39 <Squarism> how do i find an element in a list of ints?
17:43:09 <Drezil> https://www.youtube.com/watch?v=k4BzN_VM8ds - do pattern-matching, typed holes with nearly instand feedback, ...
17:43:29 <Drezil> (that was over 1 yoar ago .. now they are even better :) )
17:44:05 <Drezil> also: tabularize - http://vimcasts.org/episodes/aligning-text-with-tabular-vim/
17:44:07 <Drezil> :)
17:44:30 <Drezil> <leader>/= aligns on = for me, <leader>/: aligns on :: for me .. etc :)
17:44:33 <Iceland_jack> Squarism: If you want to check if an element is in a list, you can use
17:44:33 <Iceland_jack> :t elem :: Int -> [Int] -> Bool
17:44:34 <lambdabot> Int -> [Int] -> Bool
17:44:54 <Iceland_jack> if you want to find an element based on some predicate, use:
17:44:54 <Iceland_jack> :t find :: (Int -> Bool) -> [Int] -> Maybe Int
17:44:56 <lambdabot> (Int -> Bool) -> [Int] -> Maybe Int
17:45:31 <OhTrueful> @Squarism or elemIndex to find the index within the list
17:45:32 <lambdabot> Unknown command, try @list
17:46:12 <newbie|8> @list
17:46:12 <lambdabot> What module?  Try @listmodules for some ideas.
17:46:20 <newbie|8> @listmodules
17:46:21 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
17:46:55 <newbie|8> @list eval
17:46:55 <lambdabot> eval provides: run let define letlpaste undefine
17:48:02 <Drezil> emmanuel_erc: aricz - its idris-features that we strive for. Raichoo presented it at 31c3: https://youtu.be/uFwh3Uv8Nrw?t=25m15s
17:48:03 <Squarism> Iceland_jack, OhTrueful thanx
17:48:17 <Squarism> so : find (==2) listOfInts 
17:48:21 <Squarism> ...should work?p
17:49:53 <emmanuel_erc> Drezil: cool
17:50:20 <Drezil> raichoo is a cool guy :) i'm happy he lives in the same city i study in :)
17:50:26 <Drezil> learned a lot of things from him..
17:50:28 <Drezil> :)
17:51:12 <ski> @tell puregreen ,Sonderblade : partiality (from pattern-matching/guard failure or uses of `error',`throwError',&c.) (aborting the program or throwing an exception with no means to catch it in pure code), as well as non-termination are strictly speaking *side* effects, since they deviate from the pattern of evaluation of an expression simply computing a value, with nothing happening "on the side", ..
17:51:12 <lambdabot> Consider it noted.
17:51:22 <OhTrueful> Squarism: If you just want to know if there is a 2 in the list I would use elem 2 listOfInts
17:51:39 <aricz> ok, I used ~15 mins on quitting tintin++ (#end) .. what's the magical string for ghci.. 
17:51:50 <stoopkid> hello, is there a good place to ask questions pertaining to type theory?
17:52:28 <Squarism> OhTrueful, ok.. well i if i want arbitrary predidicate then? 
17:52:31 <hexagoxel> aricz: :q
17:52:40 <Enigmagic> aricz: ctrl-d quits many things on unix like operating systems
17:52:51 <aricz> hexagoxel: ty
17:53:09 <ski> @tell puregreen ,Sonderblade : .. no implicit dependencies with the rest of the computation (at the level of abstraction of the language itself, ignoring implementation details that can't be observed from within the language (in some reasonable sense)). a nonterminating computation doesn't (eventually, assuming enough time and memory) yield any result at all, and neither does a partial computation
17:53:09 <lambdabot> Consider it noted.
17:53:23 <Squarism> OhTrueful, like (x * 2 > 5)
17:53:25 <aricz> and yeah enigmagic, that also did it
17:53:26 <aricz> ty all
17:53:43 <Squarism> OhTrueful, how would i write that?
17:53:45 <Enigmagic> aricz: it has the advantage of working in many things
17:53:56 <OhTrueful> Squarism: There is "any" which returns a Bool: any (==2) listOfInts
17:54:15 <pavonia> stoopkid: ##categorytheory perhaps, but asking here is mostly fine too
17:54:20 <Squarism> :t any
17:54:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:55:19 <stoopkid> well, i've been looking at Notation3 for expressing logic in RDF, and i'm trying to figure out how MLTT corresponds to it
17:57:10 <ski> @tell puregreen ,Sonderblade : however, both of these are in some sense relatively benign side-effects. if a nonterminating subcomputation is forced, the whole program fails to terminate. similarly with partiality aborting the program. however, exceptions can be caught in I/O *execution* of actions (though not in *evaluation* of expressions)
17:57:10 <lambdabot> Consider it noted.
17:57:11 <aricz> well.. my first Haskell program.. \o/
17:57:24 <aricz> it printed "Hello motherfucker" .. :)
17:57:39 <aricz> waiting for kb
17:58:36 <xa0> lol
17:59:15 <ski> @tell puregreen ,Sonderblade : conceptually, I/O execution (together with memory allocation, GC, thread scheduling, &c.) belongs to the run-time system, as opposed to the evaluation model of the language, in which we tend to do the majority of our reasoning, ..
17:59:15 <lambdabot> Consider it noted.
18:00:29 <ski> @tell puregreen ,Sonderblade : .. and so we can try to argue that from the POV of evaluation (and in general, equalities and other declarative properties derived about the program), partiality can't be caught (similarly with GHC detecting *some* infinite loops and throwing an exception)
18:00:29 <lambdabot> Consider it noted.
18:03:15 <shapr> Is there a style guide for Data.Text? I converted a broken example from the github library that was using (++) to build strings, to using Data.Text, but I'm sure there's a better way to do this: http://lpaste.net/154897
18:03:55 <ski> @tell puregreen ,Sonderblade : we decided to treat partiality and nontermination as the same thing, denotationally (/declaratively), because we usually don't care much about whether a program fails to terminate, or terminates with an exception/failure (and in that case, which kind of failure)
18:03:55 <lambdabot> Consider it noted.
18:05:41 <ski> @tell puregreen ,Sonderblade : (btw, asychronous exceptions are thrown by the run-time system, and should be treated differently, conceptually, from other ones. they may depend on how much memory is available, and other such considerations which we're normally abstracting away from, for convenience. all other things being equal, there being no nondeterminism in the program, you can still get asynchronous exceptions at different times. ..
18:05:41 <lambdabot> Consider it noted.
18:06:08 <Sonderblade> so there is no way to catch head [] in haskell? because if there is, even if it is an escape hatch, then it is observable
18:07:16 <geekosaur> only in IO
18:07:26 <geekosaur> where the rules about observability don't apply
18:09:05 <ski> @tell puregreen ,Sonderblade : .. conceptually, it's not an error in the program, it's a fault of the implementation) (btw, note that `mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a' could maybe be viewed as a partial refutation to the claim that evaluation of expressions can't catch exceptions. though this operation always rethrows it, and doesn't allow the value from evaluation to depend on the exception)
18:09:05 <lambdabot> Consider it noted.
18:12:47 <ski> caconym ^
18:13:11 <ski> Sonderblade : execution (of actions) is different from evaluation (of expression)
18:14:04 <Squarism> how do i create a list (ie something with the Data.List api)
18:14:12 <ski> @tell puregreen ,Sonderblade : oh, btw, lexical/static scoping of variables could in some sense be viewed as a "lexical" side-effect ("executing" when the program is parsed & statically analyzed, before execution)
18:14:12 <lambdabot> Consider it noted.
18:14:26 <Squarism> let a = [1,2,3] 
18:14:32 <Squarism> doesnt seem to create a list
18:15:07 <nick98> Squarism what makes you think that?
18:15:15 <ertes> Sonderblade: some bottoms are observable, but only as a side effect (you cannot observe all bottoms due to the halting problem)
18:15:22 <nick98> :t let a = [1,2,3]  in a
18:15:24 <lambdabot> Num t => [t]
18:15:33 <Squarism> i try to do : find (==2) [1,2,3]
18:15:39 <Squarism> says "find" not in scope
18:15:44 <ertes> Squarism: what do you mean by "create"?  in your code 'a' *is* a list
18:16:00 <ertes> Squarism: for 'find' you need to import Data.List
18:16:03 <ertes> i think
18:16:06 <Squarism> oh ok
18:16:25 <ski> Sonderblade : there is no way to write a context (expression with a hole in it) `C', so that `C[...]' returns `Nothing' if `...' tries to take the `head' of the empty list (or, if you like, any class of exceptions), and `Just x' in case `...' evaluates to `x'
18:16:38 <ertes> yeah, you need Data.List
18:17:19 <ski> Squarism : `:m + Data.List', in GHCi. alternatively `import Data.List' (latter also works in a source file)
18:17:25 <ertes> though in modern GHC you should probably import Data.Foldable instead of Data.List
18:19:24 <Squarism> worked by importing Data.List
18:20:38 <ski> @tell puregreen ,Sonderblade : anyway, since partiality and nontermination are relatively benign effects, we've allowed them in Haskell, for practicality (to avoid partiality, you need to disallow "pure code exceptions", and check exhaustiveness of matching. the latter can be annoying in case preconditions tell you some case won't happen. the former means we have to use `Maybe' or similar to express partiality even when we don't care to catch it
18:20:38 <lambdabot> Consider it noted.
18:22:49 <ski> @tell puregreen ,Sonderblade : (".. to express partiality even when we don't care to catch it"). avoiding nontermination means only allowing provably total/productive programs (unless in a nontermination monad, say), which is also harder to use (a few systems attempt this, "total functional programming". one variant is to statically keep track of which values are proved total/productive, Agda does that)
18:22:49 <lambdabot> Consider it noted.
18:26:26 <Squarism> what am i doing wrong here:
18:26:27 <Squarism> find (x -> x == 2) [1,5,3,2,1,6,4,3,2,1]  
18:26:40 <ertes> Squarism: you're missing a backslash
18:26:47 <ertes> (\x -> x == 2)
18:26:49 <ski> @tell puregreen ,Sonderblade : ). debugging logging/tracing is another example of a relatively benign side effect (not detectable from within the program). one could perhaps also argue that environment/input/reader/configuration (see implicit parameters / dynamic scope^Wextent) is relatively benign (though less so that the previous ?) .. at least if we disallow local shadowing
18:26:49 <lambdabot> Consider it noted.
18:28:01 <ski> @tell puregreen ,Sonderblade : i recall reading someone (in the ML world, i think) arguing that exception throwing and catching (but not dynamically generating a new exception) should be considered benign, but i don't think i buy this :)
18:28:01 <lambdabot> Consider it noted.
18:29:20 <ertes> dynamic scope…  one of the reasons i do not enjoy writing elisp (and yes, i'm aware that it supports lexical scope)
18:29:41 <ertes> s/scope/scoping/g
18:30:25 <ski> @tell puregreen ,Sonderblade : in any case, the main point is that we don't want to distinguish between nontermination, and different kinds of failure, because doing so would hinder (programmer or implementation) optimizations/improvements that would transform the program into another one that in that case would have to be considered semantically distinct. we want to allow such transformations, and so we consider those cases semantically equal
18:30:26 <lambdabot> Consider it noted.
18:31:00 <ski> @tell puregreen ,Sonderblade : (".. and so we consider those cases semantically equal")
18:31:00 <lambdabot> Consider it noted.
18:31:28 <ski> ertes : yes, dynamic scope by default is a mistake
18:32:29 <ski> (Common Lisp,Scheme,Dylan all use static scoping by default. and probably CLISP,XLISP,AUTO-LISP as well ?)
18:33:53 <ertes> elisp is the only language i know that has dynamic scoping by default…  although one could probably classify "duck typing" as a form of dynamic scoping
18:35:08 <Squarism> anyone know what i can be doing wrong if my code hangs as soon im using lambdas?
18:35:37 <ertes> Squarism: feel free to paste your code on http://lpaste.net/
18:36:21 <ertes> (if it's a one-liner, you can just paste it here)
18:37:49 <Squarism> ertes, http://lpaste.net/154899
18:38:15 <nick99> > find (\x -> x == 2) [1,5,3,2,1,6,4,3,2,1]
18:38:16 <ertes> that code seems fine to me
18:38:17 <lambdabot>  Just 2
18:38:26 <nick99> > find (== 2) [1,5,3,2,1,6,4,3,2,1]
18:38:28 <lambdabot>  Just 2
18:38:42 <nick99> yeah it is fine
18:38:51 <Squarism> maybe its this env im using
18:39:09 <nick99> try pasting it to ghci
18:39:17 <ertes> Squarism: 'find' can hang, if the list is infinite and a satisfying element is not found
18:39:20 <Squarism> http://tweag.github.io/HaskellR/
18:39:33 <ertes> > find even [1, 3 ..]
18:39:38 <lambdabot>  mueval-core: Time limit exceeded
18:41:06 <Squarism> are lamdas considered hacks in haskell land?
18:41:20 <ertes> Squarism: not at all
18:41:25 <Squarism> that paste site said "Warning: Avoid using lambdas"
18:41:27 <nick99> no but they aren't needed as often as in other languages
18:41:42 <ertes> Squarism: in your particular case you can write it shorter
18:41:50 <ertes> (\x -> x == 2) is the same as (== 2)
18:41:52 <nick99> Squarism because (==2) is nicer to write and read than (\x -> x == 2) 
18:41:56 <Squarism> i know
18:41:58 <ertes> that's why you're getting the warning
18:42:03 <Squarism> just wanted to get a handle of the variable
18:42:22 <Squarism> ...value
18:42:41 <ertes> you can ignore the lpaste warnings…  they are just style warnings
18:43:04 <Axman6> Squarism: do you mean you wanted the index?
18:43:13 <ertes> Squarism: "variable" is fine…  x is a variable =)
18:46:10 * hackagebot highlighting-kate 0.6.2 - Syntax highlighting  https://hackage.haskell.org/package/highlighting-kate-0.6.2 (JohnMacFarlane)
18:46:12 * hackagebot prometheus 0.1.1 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.1.1 (LukeHoersten)
18:47:46 <OhTrueful> anyone know how to repeat a function n times? As in: "f . f . ... . f . f" (n times)?
18:48:21 <shachaf> No great way in base.
18:48:42 <shachaf> Sometimes you can iterate f z !! n
18:49:02 <ski> OhTrueful : given `compose = foldr (.) id = \xs x -> foldr ($) x xs', you can do `compose . replicate n f'
18:49:05 <ski> or what shachaf said
18:49:22 <shachaf> Or foldr (.) id -- what ski said.
18:49:41 * ski sometimes defines `composeMap f = compose . map f'
18:50:25 <shachaf> compose obviously wants to take a free category thing, not a list.
18:50:37 <shachaf> What's composeMap in that situation?
18:50:52 <ski> free category thing ?
18:51:26 <shachaf> Free category on a graph, I mean.
18:51:40 <shachaf> I don't remember what it's called.
18:52:35 <ski> oh, i suppose you mean `data ReflTransClosure ((~>) :: k -> k -> *) :: k -> k -> * where Nil :: ReflTransClosure (~>) a a; Cons :: a ~> b -> ReflTransClosure (~>) b c -> ReflTransClosure (~>) a c'
18:52:45 * ski can't recall a better name, either
18:53:34 <shachaf> Yes, that.
18:53:35 <ski> (perhaps one should add a parameter class, to constrain `b' with, as well)
18:53:56 <shachaf> I'm typing this on a phone, hard to get too detailed.
18:54:00 * ski nods
18:54:30 <OhTrueful> shachaf, ski: Thanks. Is "iterate" efficient? Does it define the nth element in terms of f (n-1) or does it start from the beginning each time?
18:54:37 <nitrix> Is there such thing as foldrM ? I'd like to forM then foldr.
18:54:48 <ski> @src iterate
18:54:48 <lambdabot> iterate f x = x : iterate f (f x)
18:54:59 <ski> OhTrueful : it ought to reuse the previous result, as indicated by that ^
18:55:08 <shachaf> Those are two different questions, though.
18:55:26 <shachaf> There can be done issues with iterate and laziness.
18:55:29 <shachaf> some
18:55:51 <ski> (an alternative definition would be `iterate f x = xs where xs = x : map f xs')
18:56:40 <ski> nitrix : not that i can recall seeing. `foldM' is conceptually more like `foldl'
18:56:59 * ski ponders the difference between these two `iterate's
18:57:16 <ertesx> ski: sharing
18:57:22 <shachaf> Foldable has foldrM
18:57:25 <ertesx> oh, no, i misread
18:57:35 <shachaf> But I don't think it makes sense for lists?
18:57:37 <ski> hm, ok
18:57:52 <ertesx> iterate f = go where go x = x : go (f x)
18:58:14 <ski> ertesx : that's the former one, yes
18:58:27 <ertesx> the former one with sharing
18:58:50 <ski> the former one with not passing `f' around, referring to it nonlocally instead
18:59:22 <ski> (which might be (slightly) less efficient, depending on implementation strategy)
18:59:51 <ertesx> i think GHC has a transformation pass that makes those two equivalent, at least with -O
18:59:59 <ski> possibly
19:00:06 <ertesx> i tend to write it explicitly to be sure
19:00:42 <ski> if you have a static link for nonlocals, then it might be slightly more expensive to access that, than to access a (stack or register allocated) local parameter
19:00:56 <ski> though maybe laziness would complicate this comparision here, not sure
19:01:02 <shachaf> You should look at the STG anyway.
19:01:10 * ski nods
19:01:42 <shachaf> Where these things have two arguments, one for captured variables. Or something along those lines.
19:02:05 <ski> yes, the static link thing
19:03:36 <shachaf> Oh, now I remember.
19:03:59 <shachaf> The advantage is that the version with go can be inlined.
19:04:26 <ski> hm .. i suppose maybe my `iterate' would naively refer to the last cons cell, while the given one would naively refer only to the last element ? so perhaps a very slight GC difference ?
19:04:43 <ski> shachaf : ok. but for the original two, above ?
19:05:22 <shachaf> GHC won't inline the recursive version, I think.
19:05:40 <ertesx> if map isn't inlined, then the second version may be noticably slower
19:05:45 * shachaf needs to go
19:05:56 <ski> can you tell it to automatically convert the recursion to an internal one, with a pragma ?
19:06:14 * ski nods to ertesx
19:06:21 <ski> later, shachaf
19:07:29 <ertesx> ski: i don't think you can control it at the definition level, but for module-wide control there should be a command-line switch
19:08:06 <ertesx> you should find it among the individual -O flags
19:08:46 <ertesx> but i have no idea what it might be called
19:10:17 <ski> ok
19:11:20 * ski ponders how one would prove the two versions equivalent
19:24:56 <ertesx> ski: let ≡ be propositional equality, let ∀ f g x. f x ≡ g x → f ≡ g
19:25:12 <ertesx> then it's a simple inductive proof (try it in agda)
19:25:47 <ertesx> i think you need to assume the latter, because of intensionality
19:26:07 <ertesx> oh, and because it's iterate, you need coinduction rather than induction
19:28:28 <ski> ok (itym ⌜∀ f g. (∀ x. f x ≡ g x) → f ≡ g⌝)
19:28:40 <ski> mhm
19:30:14 <Welkin> neonentrails
19:32:45 <slacktest> what is the state of the art on error reporting eDSL?
19:34:59 <Gurkenglas> Why wouldn't "iterate f x = xs where xs = x : map f xs" be inlined? As in replacing occurences of "iterate f x" with "let xs = x : map f xs in xs"?
19:36:59 <aweinstock> @src map
19:36:59 <lambdabot> map _ []     = []
19:36:59 <lambdabot> map f (x:xs) = f x : map f xs
19:37:16 <Welkin> @src fap
19:37:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:38:48 <aweinstock> Gurkenglas: I think the discussion was that (map f = go where {go [] = []; go (x:xs) = f x : go xs}) would get inlined -> specialized for f -> significant perf gains
19:39:04 <aweinstock> but that plain recursive map wouldn't, because haltingproblem
19:39:38 <Gurkenglas> Then why wouldn't the compiler automatically convert everything to that form?
19:40:42 <aweinstock> with what rules? automatically creating a helper and eta-reducing doesn't intuitively seem like it'd always be a win
19:43:57 <aweinstock> err, and automatically creating the helper seems like it might be non-trivial too
19:44:08 <Gurkenglas> when would it not be? (i mean the rule "whenever replacing all occurences of (the defined word followed by its first argument) with go would compile, do it")
19:47:00 <aweinstock> (($) f x = f x) -> (($) f = go where go x = f x), then ($) wouldn't be inlined in (g $ y), since it's not fully applied (if I understand the inlining rules right, which I probably don't)?
19:47:57 <aweinstock> basically, that changing the arity of the function blindly might mess with other optimizations, depending on how robust they are w.r.t. arity
19:50:04 <Gurkenglas> "($) f = go where go x = f x" should be inlined into "g $ y", producing "let go x = g x in go y", right? ($) is fully applied, since it has one argument after the transform
19:50:34 <Gurkenglas> (presumably, that go in the last "" would then also be inlined, because there's no recursion)
19:51:21 <Gurkenglas> (in fact, go x = f x would already be inlined into ($) f = go :P)
19:52:03 <Gurkenglas> (oh right it wouldnt cause its not fully applied. everything but the last line should be right tho)
19:52:20 <aweinstock> so your argument is that reducing the number of parameters will never cause a fully-applied expression to become not-fully-applied, and hence can't possibly hurt inlining in that dimension?
19:53:00 <Gurkenglas> Now that you say it, that sounds pretty good.
19:54:23 <aweinstock> I still have the vague feeling that there's probably some optimization it could interfere with in some pathological case, but it can't hurt to try implementing it as a GHC pass and benchmarking some stuff
19:54:32 <aweinstock> (modulo time consumption)
19:54:56 <aweinstock> is "recursion elimination" the general name of what it's trying to accomplish?
19:55:33 <Gurkenglas> You have the power to do that easily? While you're at it, could you replace >>'s type signature with "Monad m => m () -> m a -> m a" and see how much breaks?
19:55:41 <aweinstock> eh, trying to search for that just gives a bunch of stuff on TCE
19:56:05 <aweinstock> I've never compiled GHC, I have no idea how nontrivial it is
19:56:09 <Gurkenglas> "wrapper/worker transform automatization" I'd call it
19:56:32 <Gurkenglas> worker/wrapper i mean
19:57:27 <ski> Gurkenglas : i thought it was the recursive definition `iterate f x = x : iterate f (f x)' (as opposed to the two others mentioned) that wouldn't be inlined .. ?
19:57:42 <Gurkenglas> Ah, that makes more sense.
19:58:06 <ski> (the two others not being directly recursive, though locally making recursive bindings)
19:58:17 <aweinstock> git clone https://git.haskell.org/ghc.git # I'm giving it a try
19:58:45 <aweinstock> clones pretty slowly over a spotty hotel wifi :(
19:59:28 <Welkin> you are cloning!
19:59:54 <Welkin> my wifi doesn't even work on my other laptop recently at random times
20:00:02 <Welkin> something about the DNS being broken
20:00:18 <Welkin> which doesn't make sense, since my other devices connect to the same wifi perfectly fine
20:00:38 <aweinstock> the main wifi card on my machine doesn't work (well), so I got some usb widgets that help with that
20:00:54 <aweinstock> driver issues or something
20:04:05 <aweinstock> clone completed, there's some perl scripts and some autoconf, idk which to try first
20:04:47 <aweinstock> oh, according to MAKEHELP.md I can just try the makefile
20:05:52 <aweinstock> nope, still need to do autoconf/configure
20:07:40 <aweinstock> at least most of the scripts tell me what the previous step I'm missing is
20:08:39 <aweinstock> Gurkenglas: are you following along too? I'm not sure I'll end up having enough time to poke ghc that much (I'm supposed to be attending a crypto conference the next 2 days)
20:09:02 <Gurkenglas> I've read along, but I'll go to sleep soon
20:09:29 <Gurkenglas> (I'm planning to read up on the logs what I missed)
20:09:49 <ij> What does wreq do that http-client doesn't?
20:10:22 * ski caught up on logs, years ago. didn't work out, as the channel grew larger
20:10:31 <ij> higher level API?
20:11:08 <ski> (now i only occasionally look back further than a day)
20:11:47 <aweinstock> "perl boot" gave a warning about this being default:  http://ghc.haskell.org/trac/ghc/wiki/Building/Using#Buildconfiguration
20:13:18 <aweinstock> "autoconf && ./configure" says I need GHC 7.10 or newer (I was doing this on a machine that has debian 7's ancient copy of GHC, 7.4.1)
20:14:49 <aweinstock> I guess that's all for tonight
20:18:40 <bba> anyone here familiar with any of the curses modules?
20:19:00 <bba> i'm currently fiddling with hscurses, but i just can't get it to print any output
20:19:21 <bba> returns an error every time i call move or wMove
20:19:43 <orion> What's the benefit of Vector over [] ?
20:20:06 <Welkin> orion: constant time access
20:20:22 <Welkin> Vector is a wrapper around Array
20:20:27 <Welkin> [] is a singly-linked list
20:21:27 <pavonia> bba: What error?
20:21:45 <bba> user error (Curses[-1]:wmove)
20:21:50 <bba> that's all it gives me
20:21:59 <orion> My goal is to use a REST API to fetch hundreds of thousands of non-numerical identifiers. I then need to fetch hundreds of thousands of non-numerical identifiers from a SQL database and print out which IDs exist from the REST API that aren't in the database and vice versa. What data structures would be most efficient in this case?
20:22:15 <Welkin> orion: a Map
20:22:29 <orion> Welkin: There are no values, only keys. Maybe a Set?
20:22:41 <Welkin> ah yes
20:22:43 <Welkin> a Set
20:22:53 <Welkin> Set is a Map with the values set to 90
20:22:54 <Welkin> er
20:22:55 <Welkin> ()
20:23:47 <orion> This?: http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Set.html
20:23:58 <Welkin> I have used a Set like this before when finding the intersection between a massive chinese dictionary and all of the words in a chinese book
20:24:05 <Welkin> it was very effective
20:24:41 <Welkin> yes, Data.Set
20:24:44 <orion> Is there nothing in Prelude?
20:24:50 <Welkin> no
20:24:53 <Welkin> ignore Prelude anyway
20:25:04 <Welkin> PRelude just imports from many different modules
20:25:19 <Welkin> Prelude is not its own module
20:27:13 <orion> s/Prelude/base
20:28:08 <Welkin> don't be afraid to import other modules
20:28:16 <Welkin> containers is extremely useful
20:28:28 <pavonia> bba: I'm not familiar with that package but looking at the code the error isn't teling much. Maybe you could paste a code sample that yields the error
20:29:33 <bba> yeah, that's the problem, i know there's also a package called ncurses
20:29:46 <bba> maybe i'll try that instead
20:47:50 <orion> Could Data.Set be a Monoid?
20:49:19 <nitrix> It is.
20:50:07 <nitrix> https://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Set.Base.html#line-249
20:50:37 <orion> Oh, why isn't it listed here?: http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Set.html#t:Set
20:51:16 <nitrix> I see it there.
20:51:27 <nitrix> Ord a => Monoid (Set a)
20:52:06 <orion> Ah, oops.
20:52:10 * ski incidentally thinks it would have been better if that had been written as `Monoid (Set a) <= Ord a'
20:52:47 <ski> (easier to grep (visually or otherwise). i think Mercury uses that ordering)
20:52:50 <nitrix> Maybe formatted as a table with the first column being the constraints.
20:53:11 <nitrix> Just alignment in itself would help.
20:53:24 <ski> yes
20:54:24 <ski> (generally it's nicer to read with the "defined thing" being first. which is why i think it's `f(x)' rather than `(x)f'. also on use sites, `f' more seldomly tends to be a large expression than `x')
20:55:01 <ski> (the other ordering would also make it look more like Prolog :)
20:57:47 <ski> (.. oh, and i'd also prefer it if "less than or equal" was written `=<' (like Prolog,Erlang,Mercury) instead of like `<=' :)
21:02:30 <ski> (and while we're at it, it ought to be ⌜λ x ↦ ⋯x⋯⌝, not ⌜λ x → ⋯x⋯⌝, with `UnicodeSyntax')
21:04:42 <acertain> is there any way to see how much sharing is going on?
21:06:58 <acertain> i have a structure with STRefs in it that I want to freeze, but copying into a version without the STRefs is killing sharing, what do?
21:07:46 <ski> acertain : are all the `STRef's referencing items of a single common type ?
21:08:28 <acertain> no, it's in a GADT with `Star :: F s (a -> b) -> F s a -> F s b`
21:08:48 <ski> in that case, you could possibly use a `Map (STRef s T) T' (using `mfix' or the `do rec' extension to build it)
21:08:52 <ski> hm
21:09:08 <lpaste> acertain pasted “No title” at http://lpaste.net/154900
21:09:11 <ski> what's `F' here ? how does it relate to the `STRef's ?
21:09:43 <acertain> thats F
21:10:25 <ski> mhm
21:11:28 <ski> i'd still try to figure out a way to use something map-like to associate the `STRef's to the current contents, using the "tying the knot" idea
21:12:35 <ski> well, i would work even without "tying the knot" i think, though then you'd have to traverse the structure twice (unless you "stage" the knot-tying, returning a function that should be passed the final map)
21:12:42 <ski> s/i would/it would/
21:13:10 <ski> the main problem i see is that you'd need some kind of heterogenous map
21:14:02 <acertain> probably just unsafeCoerce would work? but STRef doesn't have Hashable or Ord
21:14:12 <ski> hm, point
21:14:31 <ski> it has `Eq', which is what would make the idea work at all
21:15:02 <ski> so i suppose just an association list, then ?
21:15:17 * ski wonders how to avoid the list
21:15:48 <ski> hm, i suppose you could generate distinct `Integer's (say), and use those for ordering
21:16:34 <ski> specifically, i think you want something equivalent to `type Map1 k v = [exists i. (k i,v i)]' (but more efficient)
21:17:15 <ski> so that you can have one key of type `STRef s Foo', and another of type `STRef s Bar', associated to values of types `Foo' and `Bar' in the map
21:17:40 <ski> or, `OrderedSTRef' instead of `STRef', which would be a wrapper also containing that `Integer'
21:17:44 <orion> Would it make sense for Data.Set to have a mapM function?
21:18:34 <ski> acertain : so, i suppose main problem now is lack of `Map1' (i've wanted this thing before, perhaps you can tell)
21:18:55 <ski> i suppose `unsafeCoerce' might work, though i don't like using it if i can help it
21:19:47 <ski> hmm
21:21:39 <ski> acertain : so, sketch of the simplest version : traverse with an initially empty map (or association list. if map, also set up an `Integer' counter). if an `STRef' isn't seen yet, add it (with counter) to map, with current element, and continue traversing that element. otherwise skip traversing it
21:22:35 <ski> acertain : one problem would be if you had any `STRef's behind functions in your data structure .. but i don't see that in the paste
21:23:16 <acertain> not that I need to freeze
21:23:28 <ski> you do have `PartialResult s a -> ST s ()', but that is `PartialResult s a' as an input, so i don't think this counts
21:23:38 <acertain> that gets thrown away
21:24:07 <ski> it returns an `ST s ()', which i suppose might internally reference some `PartialResult' in a closure, but this can't count, you can't hope to access any such, and probably wouldn't want to count them even if you could
21:24:13 <ski> acertain : *nod*
21:24:47 <pavonia> orion: You could convert the Set to a list and use the standard mapM on this
21:26:02 <ski> acertain : anyway, after having computed this map, in the simplest version you traverse again, using the map (instead of `ST') to access the values behind `STRef's
21:27:07 <ski> acertain : in a more advanced version you make the original traversal build a function that when passed the final map will build the frozen tree for you, with no extra traversal
21:28:10 <ski> acertain : and, then you should probably be able to "tie the knot" there, using `mfix' (or `DoRec'), to pass the "final map" back as an extra argument to the original traversal (also not needing another traversal)
21:28:28 <ski> i hope the rough idea is clear enough
21:28:41 <acertain> yeah
21:29:57 <ski> @wiki Tying the knot
21:29:57 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_knot
21:30:12 <ski> for some more info on the knot-tying idea, if you need it
21:37:42 <orion> pavonia: Is that expensive?
21:38:12 <ski> @wiki MonadFix
21:38:13 <lambdabot> http://www.haskell.org/haskellwiki/MonadFix
21:40:05 <pavonia> orion: It's O(n), so not more than a mapM would be
21:41:06 <orion> Alright.
21:43:09 <ski> (another example is the `repmin' one. i can't find a better reference than "A Recursive do for Haskell" by Levent Erkök,John Launchbury in 2002-10-03 at <https://www.researchgate.net/publication/2840442_A_Recursive_do_for_Haskell> atm ..)
21:59:09 <orion> foo <- concat <$> forM ... -- the forM returns a [[Text]]. My goal is to have foo be a [Text]. Will this code not do what I expect?
22:01:54 <ski> orion : assuming you mean the `forM' here has type `[T] -> (T -> M [Text]) -> M [[Text]]', for some type `T' and some monad `M', i think that code snippet would do the desired transformation
22:03:48 <orion> ski: Correct, but it doesn't typecheck.
22:03:55 <ski> however, note that you can't type `concat <$> forM ts $ \t -> ..t..', you have to use `concat <$> forM ts (\t -> ..t..)' or `concat <$> (forM ts $ \t -> ..t..)' then
22:04:22 <ski> because `<$>' binds tighter than `$'
22:04:36 <orion> Oh, that could be a problem.
22:04:48 * ski is of course just guessing out of the blue, here :)
22:05:26 <orion> That was it, thank you.
22:06:50 <ski> np
22:26:24 <ReinH> orion: is Data.Set Traversable? 
22:26:28 <ReinH> If not, why not?
22:26:57 <johnw> Set is Foldable, but not Traversable
22:27:02 <ReinH> johnw: I know.
22:27:16 <johnw> it's also not Applicative, and so...
22:27:23 <ReinH> johnw: I'm asking orion.
22:27:30 * johnw shuts up
22:27:35 <ReinH> Because orion asked if there was a mapM for Set.
22:28:28 <ReinH> And if you know why Data.Set isn't Traversable, you will know why it does not have a mapM.
22:29:53 <jdt> you folks have probably heard this question before, so I'm hoping there's a quick answer. I'm following a tutorial that says to "import Snap (get)" but getting an error that: "Module ‘Snap’ does not export ‘get’" is there a quick fix that doesn't involve me downgrading my snap version?
22:31:42 <dmj`> jdt: what is the type of get? 
22:31:59 <dmj`> can't remember if Snap was re-exporting mtl 
22:32:28 <jdt> this is the tutorial: http://janrain.com/blog/tutorial-building-a-sample-application-with-haskell-snap-postgresql-and-the-postgresql-simple-snaplet/
22:32:33 <ReinH> I wonder if it's one of the 50 functions in Snap that begin with "get". https://hackage.haskell.org/package/snap-0.14.0.6/docs/doc-index-G.html
22:33:23 <dmj`> jdt: try import Control.Monad.State
22:35:05 <dmj`> ReinH: heh
22:35:08 <dmj`> too much get
22:35:43 <jdt> https://gist.github.com/justindthomas/f5ef8f232763811bd1a9
22:35:49 <jdt> :-/ maybe the type is 'Snaplet?
22:36:11 <jdt> I'm very very new to Haskell. trying to get something basic running so that I can iterate and learn more.
22:40:39 <dmj`> jdt: can you paste all of your code
22:40:43 <dmj`> @where paste
22:40:43 <lambdabot> Haskell pastebin: http://lpaste.net/
22:41:20 <dmj`> jdt: are you using stack?
22:41:47 <jdt> dmj`: yep
22:41:52 <jdt> https://gist.github.com/justindthomas/1ebe4d5f29c82efc89a0
22:42:03 <jdt> (yes stack and yes to pasting)
22:42:28 <jdt> that's the full Application.hs file at this point.
22:42:52 <dmj`> replace line 11 with 'import Control.Monad.State'
22:43:12 <jdt> I did try that - gave a different error. I'll redo it.
22:43:16 <dmj`> hmmm
22:44:17 <jdt> https://gist.github.com/justindthomas/590b8490426dc460e9f7
22:45:24 <jdt> I was hoping it was just some littly quirky difference in import semantics or something like that that would be obvious to experienced folks.
22:45:58 <dmj`> jdt: well that blog post is a bit old
22:46:12 <dmj`> API may have changed
22:46:16 <jdt> yeah - I hadn't checked the date until just now.
22:46:19 <jdt> hmm.
22:47:19 <dmj`> jdt: this compiles for me, https://gist.github.com/dmjio/05f898b6f7d7b64e065f
22:47:37 <dmj`> stack is having issues w/ the postgresql snaplet, so give me a sec
22:48:02 <jdt> yeah, that essentially drops everything that I added to the base template. that def. works for me too.
22:48:22 <jdt> it's the pg part that I'm trying to get working now.
22:49:50 <jdt> this looks like promising info: https://github.com/mightybyte/snaplet-postgresql-simple/blob/master/example/Site.hs
22:55:46 <orion> ReinH: The definition of Traversable is "Functors representing data structures that can be traversed from left to right." Sets don't have rightness or leftness.
22:56:19 <orion> However, Data.Set is ordered. So one could arbitrarily set left as the minimum and right as the maximum.
22:56:30 <dmj`> jdt: there is also #snapframework
22:56:40 <jdt> oh, nice. thanks.
22:56:58 <orion> ReinH: Functors are structures that can be mapped over, and Sets can be mapped over.
22:57:09 <orion> So, it's not clear to me why Data.Set can't be Traversable.
23:00:30 <pavonia> orion: Set isn't a Functor because you'd need a Ord constraint for fmap
23:00:45 <johnw> even that isn't enough
23:01:40 <pavonia> johnw: What do you mean?
23:04:55 <johnw> even if you have Ord a and Ord b, there's no guarantee that equal a's map to equal b's, so you can trivially create an example that inverts the meaning of equality, breaking the functor laws
23:05:28 <johnw> so you need both the constraint, and a law about equalities
23:05:49 <shachaf> The laws come with the constraint.
23:08:35 <johnw> Set.map has the constraint, but it's not enough; what did you mean exactly?
23:09:25 <shachaf> The Eq laws are part of the class Eq.
23:10:38 <johnw> where do you see that?
23:11:17 <johnw> the Haskell Report 6.3.1 (The Eq Class) makes no mention of laws
23:16:13 <ggole_> I don't see what Eq laws have to do with it anyway, since the function argument to fmap can make use of information that the Eq instance does not consider even if the Eq instance is consistent
23:18:35 <ggole_> eg, data Foo = Foo Int Int and an Eq instance that compares by the first argument, and then fmap (\ (Foo _ x) -> x)
23:34:17 <johnw> ggole_: https://github.com/jwiegley/notes/blob/master/SetF.hs
23:36:42 <ggole_> Ah, I see
23:37:25 <ggole_> Hmm, this is like ignoring part of the structure, except you are ignoring all of it.
23:37:54 <johnw> and if the Eq laws said, "No, you can't write that instance for AlwaysEqual", we'd be good, except that they don't
23:38:02 <johnw> as discussed here: https://www.reddit.com/r/haskell/comments/1njlqr/laws_for_the_eq_class/
23:39:52 <johnw> and more discussion: http://stackoverflow.com/questions/14861379/what-laws-are-the-standard-haskell-type-classes-expected-to-uphold
23:40:59 <johnw> good night
