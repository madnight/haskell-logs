01:04:58 <joe9> I cannot figure out how to do (using Generic) an instance of IntMap?
01:06:11 <joe9> error http://codepad.org/Dnc1X0h9 and Icannot figure out how to derive Pretty for an IntMap. Do I have to write the instance manually. I guess there must be a better option.
01:09:57 <lyxia> convert to list
01:14:47 <Squarism> many functions takes functions like (a -> a -> b). Say "a" is a tuple. Is there some nice composition i can make to apply "fst" to both arguments and them pass both of them to "compare"?
01:15:08 <Squarism> ...takes function arguments like ...
01:16:30 <geekosaur> :t comparing
01:16:32 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:16:37 <geekosaur> :t on
01:16:38 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:18:53 <Squarism> geekosaur, nice thanks
01:38:32 * hackagebot rebindable 0.1.0 - A library to facilitate rebinding of Haskell syntax  https://hackage.haskell.org/package/rebindable-0.1.0 (sleexyz)
01:48:33 * hackagebot rebindable 0.1.1 - A library to facilitate rebinding of Haskell syntax  https://hackage.haskell.org/package/rebindable-0.1.1 (sleexyz)
01:51:03 <pavonia> Given the following types <http://lpaste.net/343677>, I'm trying to write the function mapError but I can't see a way without also giving the inverse of the mapping function. Is there a way to define it without that?
01:53:33 * hackagebot rebindable 0.1.2 - A library to facilitate rebinding of Haskell syntax  https://hackage.haskell.org/package/rebindable-0.1.2 (sleexyz)
01:56:14 <lyxia> pavonia: yes Lexer is invariant in e
01:57:04 <pavonia> So how would I do that?
01:57:20 <lyxia> I mean there is no way to have a mapLexer
01:57:31 <lyxia> mapError with just (e -> e')
01:57:45 <pavonia> Oh
01:59:19 <lyxia> LexerResult e a is covariant in e (i.e. a Haskell Functor in e), so in the type of Lexer it appears once positively (as the result type), and twice negatively (as argument type).
01:59:41 <lyxia> more precisely the result type of two arguments
02:01:04 <pavonia> invariant means it has to be a functor and cofunctor?
02:01:32 <lyxia> no it means it is neither
02:02:44 <lyxia> pavonia: https://www.schoolofhaskell.com/user/commercial/content/covariance-contravariance
02:04:20 <felko> why doesn't the STM monad have a transformer ?
02:04:44 <felko> like STMT :: (* -> *) -> * -> *
02:04:56 <felko> to embed other monadic actions
02:05:39 <felko> such as STMT (Writer Config) Int for example
02:07:17 <lyxia> How would you run it
02:08:34 * hackagebot sproxy 0.9.9 - HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy-0.9.9 (ip1981)
02:09:24 <felko> I don't know, I guess there would be a function atomically :: Monad m => STMT m a -> IO (m a)
02:09:37 <felko> lyxia: atomicallyT*
02:11:14 <felko> of course we couldn't write it in pure Haskell, we would have to change GHC i think, but why has GHC decided to implement it this way ?
02:11:32 <felko> because the transformer seems to give more flexibility
02:12:03 <felko> also, why doesn't IO have a transformer ?
02:12:19 <erisco> IO is special sauce
02:12:38 <felko> STM too I guess, would that be for the same reason ?
02:13:02 <erisco> I think STM is a library
02:13:41 <pavonia> lyxia: I'm slightly confised. If you're able to give a function that maps Lexer u e a to Lexer u e' a given functions (e -> e') and (e' -> e), doesn't that make Lexer a covariant and contravariant functor in e?
02:13:49 <pavonia> *confused
02:14:07 <erisco> answer this: is it a functor?
02:14:40 <erisco> if it isn't a functor, it cannot be a functor and something else
02:14:52 <pavonia> Right, it's not
02:15:54 <pavonia> So the reason it's neither is that you need both functions, not only either of them?
02:16:28 <lyxia> pavonia: a covariant functor is given by a mapping (e -> e') -> f e -> f e', which you don't have here.
02:16:41 <erisco> it is that, logically, you cannot construct "A and B is true" if you don't have "A is true"
02:18:05 <erisco> so it makes it a profunctor
02:18:06 <felko> lets say I have a newtype Server a = Server { unwrapServer :: StateT ServerState STM a } type, how would I write a similar type that would allow me to perform IO actions inside ? (or any monad, not necessarily IO)
02:18:49 <felko> mmmh, there is a problem, shouldn't ServerState be stored as a TVar ?
02:18:50 <lyxia> uh, a profunctor has kind * -> * -> *
02:19:14 <lyxia> erisco: or are you referring to another kind of profunctor
02:19:23 <pavonia> erisco: Why? Doesn't a profunctor require a contravariant functor in e?
02:20:24 <lyxia> felko: you're not supposed to execute arbitrary IO in STM
02:21:18 <erisco> lyxia, yes you're right
02:22:43 <lyxia> felko: use STM to define concurrency primitives relevant to your application, your application shouldn't run in STM.
02:26:47 <circ-user-QJY8M> They say "apply runState to get a function" http://www.adit.io/posts/2013-06-10-three-useful-monads.html. Apply to what?
02:27:46 <lyxia> pavonia: the notion of functor is actually more general than Haskell's Functor. you can consider a function that takes a bijective mapping and its inverse as defining a functor from another category.
02:28:08 <lyxia> circ-user-QJY8M: to a value of type State s a
02:28:54 <lyxia> circ-user-QJY8M: runState greeter $ "adit"   <- runState applied to greeter yields a function, that is then applied to "adit"
02:35:16 <circ-user-QJY8M> lyxia: But what does runState :: s -> (a, s) mean? Doesn't it mean that runState must take a state s rather than Monad State s a?
02:35:55 <lyxia> you must read the type declaration as a whole
02:36:29 <lyxia> State s a = State { runState :: s -> (a, s) }     means the type State s a has a constructor State with one field, named runState, of type s -> (a, s)
02:37:01 <lyxia> but for the rest of the program, runState refers to the field accessor of type runState :: State s a -> s -> (a, s)
02:37:56 <lyxia> it may be more precise to say "field getter"
02:39:42 <circ-user-QJY8M> and what does that definition of field getter tell us? I do not see that it takes any state to spit out a function as the text says.
02:39:59 <lyxia> the state type is the s parameter
02:40:25 <lyxia> "State s a" means "a stateful computation, with state s, and result a"
02:40:28 <circ-user-QJY8M> "spply runState to get a function". I see that given s, it will produce a pair (a,s) rather than a function.
02:41:04 <lyxia> no here they mean runState :: State s a -> s -> (a, s)
02:41:43 <lyxia> if you have a value m :: State s a, then runState m has type s -> (a, s)
02:42:27 <circ-user-QJY8M> ok, the field expects the object
02:42:39 <lyxia> that's why I call it the field getter instead
02:43:14 <circ-user-QJY8M> it makes sense. I could not understand how do you have field without object before that.
02:44:17 <lyxia> I agree the record notation is unintuitive.
02:54:18 <circ-user-QJY8M> It looks unintuitive but functional and uniform. You have everything a function in Haskell and access to the object fields is also a function.
02:58:08 <lyxia> right
02:59:16 <circ-user-QJY8M> The only problem is probably a scope. In ordinary langauges, the fields are enclosed into parent object scope where they seem to float around in global space in Haskell for good or bad.
03:06:08 <circ-user-QJY8M> What is the point of $ in half . half $ 8? You have double application of half. Why cannot you apply the composition immediately to the numeric argument?
03:06:23 <circ-user-QJY8M> why extra mapping is necessary?
03:07:00 <lyxia> half . half 8   parses as   half . (half 8)
03:07:16 <lyxia> function application binds tighter than operators.
03:07:46 <lyxia> half . half $ 8   parses as (half . half) $ 8, because . has higher precedence than $
03:08:03 <circ-user-QJY8M> thanks
03:18:36 * hackagebot dmenu 0.2.0.0 - Complete bindings to the dmenu and dmenu2 command line tools.  https://hackage.haskell.org/package/dmenu-0.2.0.0 (m0rphism)
03:32:04 <Xyliton> ertesx: https://asciinema.org/a/93451 Here's a demo of my current Hangman program. is there anything missing?
03:32:28 <Xyliton> (i still have to add a limited amount of tries though)
03:32:41 <circ-user-QJY8M> How do yo return both string and num in half :: Int -> Writer String Int half x = do         tell ("I just halved " ++ (show x) ++ "!")         return (x `div` 2)?
03:32:47 <circ-user-QJY8M> Writer demo http://www.adit.io/posts/2013-06-10-three-useful-monads.html
03:33:06 <circ-user-QJY8M> I see that return returns only x div 2 which is supposedly a number
03:33:17 <circ-user-QJY8M> I do not see any string in return
03:33:37 * hackagebot dmenu 0.3.0.0 - Complete bindings to the dmenu and dmenu2 command line tools.  https://hackage.haskell.org/package/dmenu-0.3.0.0 (m0rphism)
03:34:34 <circ-user-QJY8M> how is tell(string) conjuncted with return int?
03:36:36 <lounge-user11> circ-user-QJY8M: what do you mean?
03:38:55 <granomoly> I've really been trying to push haskell at my university. People are generally open to hearing about it, but the same exact retorts emerge upon mentioning that it can effectively be used in Emacs. Does anyone have a brochure I can print out on the general precepts of Haskell/GHC? (Silly question)
03:39:26 <AndreasK> There is haskell-vim-now and Atom works well enough on Windows
03:40:47 <AndreasK> circ-user-QJY8M: The String part of the result is kept inside the writer Monad
03:42:01 <AndreasK> circ-user-QJY8M: return does not only give us its argument but also the Monad which happens to contain the string
03:52:54 <circ-user-QJY8M> AndreasK: You  speak in set phrases. I wanted you to show me where does return returns the string in particular example.
03:53:19 <stalk> jedai: hello
03:53:28 <advoc237> hi
03:53:34 <circ-user-QJY8M> Ok, I see
03:53:47 <stalk> So, I'm trying to adapt this "filestore" library to remote repositories
03:53:56 <stalk> but have some open questions
03:54:04 <circ-user-QJY8M> return val = Writer (val, "") makes the
03:54:19 <maerwald> granomoly: brochure about what exactly?
03:54:58 <advoc237> hi
03:55:04 <granomoly> "Haskell for EVERYONE! :D" or something related. [non-serious but welcoming]
03:55:58 <maerwald> I still don't know what that means
03:56:10 <maerwald> tooling?
03:56:15 <AndreasK> circ-user-QJY8M: How familiar are you with how Monads are actually implemented/desugared?
03:57:20 <stalk> For instance, I'm not sure how authentication should be done
04:01:44 <AndreasK> circ-user-QJY8M: Sadly for beginners the monad instances can be confusing because of the use of CPS
04:03:10 <jedai> stalk: Well that's really a general question for these kind of services
04:04:11 <jedai> stalk: you have the key approach or the login and password.
04:04:47 <jedai> stalk: for the login and password approach at least you can delegate the storage and retrieval headache to your user
04:07:27 <AndreasK> circ-user-QJY8M: For me it helped at the begining to think about values of type (Monad m) => m a as a pair of something hidden in the Monad and the actual value a. For IO thats the state, for Writer it's whatever you have written using tell and so on.
04:08:20 <maerwald> people often use the term "effect" for that
04:08:29 <maerwald> I think that's clearer than "something hidden"
04:08:51 <ph88> how to change the source code of a package on haddock ?
04:09:17 <AndreasK> For me at the beginning it just added the confusion. It's clear once you understood it but thinking of Monads as Containers was more intuitive for me at the start.
04:09:47 <maerwald> the most general term would be "context" then
04:10:02 <maerwald> which is still better than "container", which actually causes confusion
04:10:11 <ph88> i like container best
04:10:18 <AndreasK> I can only go with what helped me.
04:11:41 <maerwald> I usually go with that helps most people, judging from the confusion I can observe different things cause
04:11:59 <stalk> jedai: As gitit already supports auth via github, I think I could use that to get a key at user login and do the push with the user infos, right?
04:13:41 <AndreasK> In the end it really clicked for me when I mulled over the definitions of >>= and consorts for a bit. I don't think there really is a way around that if one wants to understand them and not just use them.
04:13:41 <stalk> but my problem is that in filestore, you generate a "filestore object" by giving it the path to where to have the store folder. So, what I did is make a function which takes not only the path, but also the url of the remote
04:14:29 <jedai> stalk: that seems reasonable but don't forget you're modifying filestore that is not just used by gitit so keep it open (it's fine if you're only using it yourself but for your pullrequest to be accepted it can't be tied exclusively to one user of filestore)
04:14:50 <stalk> what works for now is to include user:login in the remote url, but that's really not ideal, because it means gitit would: 1. have to store an auth token in clear, and; 2. use an auth token for itself rather than the one of the users
04:15:04 <stalk> jedai: right
04:15:52 <stalk> so, you see, the typical code using filestore would look like `fs = gitInit "path"; save fs <newfile>`
04:16:17 <maerwald> AndreasK: Yes, haskell is hard to teach, which the regular meta-discussions about how to teach concept XY show. You don't see that many of them in say, C, python or whatnot.
04:16:37 <stalk> but now I would have to change the interface to make it `fs = gitInit "path"; save fs <newfile> <authentication>`, which breaks the "API" of filestore
04:16:50 <stalk> so I'm not sure how to proceed
04:17:05 <stalk> And then there is how it should semantically work
04:17:57 <jedai> stalk: I'm pretty sure the authentication should be stored by the Filestore object
04:18:15 <stalk> mmh, I don't like that much
04:18:19 <jedai> stalk: you should only need to pass it at the initialization
04:19:07 <stalk> b/c it would be better if: given some user wanting to do a modification, the push is made with the user authentication, so if the user wants to do something he/she is not allowed to, then it will give an error then
04:19:52 <stalk> jedai: https://gist.github.com/kestal/bb67d0b17707e95bb0fee999b050c0dd
04:20:20 <stalk> That's my idea of the code so far, with some uglyness b/c I'm not familiar with haskell; just consider the "pseudocode"
04:21:21 <stalk> jedai: So, I just modified the init by replacing `git init` by `git clone` and the rest is: "if it's a read, first pull then read, if it's a write, first write then push"
04:22:00 <zwild> :q
04:22:21 <AndreasK> Is there a better way to get the minimum of [Maybe Int] then folding over it? filtering out the Nothings and using minimum might trip over the empty list and special casing the empty list seems ugly.
04:22:41 <stalk> jedai: Also, as I said, there is no error managing now, I haven't taken care of that
04:22:56 <pticochon> good morning
04:23:45 <jedai> AndreasK: foldMap (fmap Min) ?
04:24:28 <stalk> jedai: Do you see my point about not having authentication done at init time?
04:25:04 <stalk> maybe I should write about that on the issue discussion, but I don't want to make noise if it's not gonna yield something useful
04:25:53 <jedai> stalk: I see it but I'm not sure I agree.. I was hoping that the use of this GitRemote would be transparent and similar to Git
04:26:15 <jedai> stalk: I'm pretty sure this is worthy of asking in the issue
04:26:22 <stalk> Ok
04:26:24 <pavonia> pticochon: Hallo :)
04:26:37 <pticochon> oh servus pavonia :)
04:26:43 <stalk> And what do you think of the "pull then read"/"write then push" strategy?
04:28:23 <jedai> AndreasK: Hmmm what do you want to happen if there is a Nothing in there ?
04:28:41 <AndreasK> Nothing is good enough
04:28:55 <jedai> AndreasK: then minimum works
04:29:12 <jedai> > minimum [Just 5, Just 6, Nothing]
04:29:15 <lambdabot>  Nothing
04:29:22 <AndreasK> yeah thats the issue
04:29:26 <jedai> > minimum [Just 5, Just 6]
04:29:28 <lambdabot>  Just 5
04:29:45 <AndreasK> minimum also fails on the empty list case if i filter out the nothings
04:29:55 <AndreasK> I know the list can't be empty but it might be all Nothings
04:30:05 <jedai> AndreasK: So you basically want Nothing to be bigger than Just ... ?
04:30:38 <AndreasK> Yes
04:30:54 <Xandaros> I think what you really want is a total minimum function...
04:30:56 <jedai> AndreasK: you could just write a newtype but is that really better than a fold ?
04:31:14 <Xandaros> Then you could just do minimum . catMaybes and be done with it
04:31:51 <AndreasK> I think i will just use let vals = catMaybes ... and then use if null vals then ... else
04:32:18 <Xandaros> If you're not opposed to the dependency, safe has a "minimumMay" function
04:32:39 <jedai> AndreasK: but is that really any better than a fold ?
04:33:16 <MarcelineVQ> maybe I'm misunderstanding the requirements but what about fmap minimum . sequence
04:34:08 <AndreasK> fmap minimum . sequence $ [Just 1, Nothing]
04:34:11 <jedai> > let myMinimum = fold myMin where myMin Nothing b = b; myMin a Nothing = a; myMin a b = min a b in myMinimum [Just 5, Just 6, Nothing]
04:34:13 <lambdabot>  error:
04:34:14 <lambdabot>      • Couldn't match expected type ‘Maybe t’
04:34:14 <lambdabot>                    with actual type ‘[Maybe Integer]’
04:34:27 <Xandaros> > sequence [Just 5, Nothing] -- MarcelineVQ
04:34:29 <lambdabot>  Nothing
04:34:36 <jedai> > let myMinimum = foldl1' myMin where myMin Nothing b = b; myMin a Nothing = a; myMin a b = min a b in myMinimum [Just 5, Just 6, Nothing]
04:34:38 <lambdabot>  Just 5
04:35:26 <jedai> AndreasK: I think that express the intent nicely and isn't too long either.
04:35:28 <stalk> Also, If I do a local save, then push, and the push gives me an error, should I just pull, or  revert one commit back?
04:35:46 <MarcelineVQ> hmm I thought they wanted a Nothing if there's a Nothing
04:35:59 <AndreasK> No a nothing when there are only nothings
04:36:08 <Xandaros> Then plain minimum would work
04:36:27 <jedai> stalk: Absent any indications of the user (who would need an advanced interface), you should just throw an exception and let the user decide
04:36:50 <jedai> stalk: and probably cancel your commit...
04:37:19 <Xandaros> AndreasK: I still think `minimumMay . catMaybes` is the cleanest. Either by depending on safe or rolling your own
04:38:01 <jedai> stalk: basically you should rollback the situation to just before the function was executed and fail with an exception
04:38:12 <stalk> riht
04:39:01 <stalk> and by the user, do you mean the program using filestore, or the guy at his browser using gitit?
04:39:33 <AndreasK> As someone with a lot more experience with imperative language I also find it easier to parse if/else distinctions than folds at a first glance
04:39:39 <jedai> stalk: the program. though I guess gitit should have some feedback and option after that
04:40:44 <stalk> jedai: I tested gitit, if two users try to modify the same resource, the latter to commit will get an error, and his text field will be updated with a diff of his version and the new one
04:41:37 <jedai> stalk: that seems sane in most case
04:43:19 <jedai> AndreasK: I think this fold with a comment would be perfectly alright but if you prefer if/then/else that's fine too. Xandaros suggestion is pretty nice too
04:43:40 * hackagebot haskelisp 0.1.0.3 - Write Emacs module in Haskell, using Emacs 25's Dynamic Module feature  https://hackage.haskell.org/package/haskelisp-0.1.0.3 (shintak)
04:51:10 <pticochon> so, I'm currently looking for a decent haskell ide. May I ask for recommendations?
04:51:41 <sm> emacs or IDEA
04:51:47 <jedai> pticochon: emacs with intero ? atom with ghc-mod ? vim with ... (I don't know vim)
04:51:48 <pticochon> what about Leksah
04:52:05 <stalk> jedai: OK, I'll try and write those questions up nicely, and hope for some decisive answer. Thanks for your counsels!
04:52:09 <pticochon> the wiki says it's an IDE for haskell written in haskell
04:52:24 <sm> if it works, then sure
04:52:57 <pticochon> I'm currently fiddling with eclipse and sublime text and their respective haskell plugins
04:53:00 <Xandaros> jedai: There's intero for vim, too, though I haven't tried it
04:58:40 * hackagebot haskell-src-exts-simple 1.19.0.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.19.0.0 (BertramFelgenhauer)
04:58:57 <onintza> How should I handle quickcheck and recursive data types? Quickcheck seems to produce very large input samples, even when I defined the cases where the data type doesn't recurse as more frequent
05:03:01 <AndreasK> onintza: I think you need to implement shrink methods for your types but I haven't used that yet myself
05:03:40 * hackagebot haskelisp 0.1.0.4 - Write Emacs module in Haskell, using Emacs 25's Dynamic Module feature  https://hackage.haskell.org/package/haskelisp-0.1.0.4 (shintak)
05:05:30 <AndreasK> At least that should work when the large sample can be shrunk while still being invalid
05:07:08 <MarcelineVQ> in case you haven't seen them you can affect generation with the combinators here http://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#g:6
05:09:03 <lyxia> onintza: http://hackage.haskell.org/package/testing-feat and http://hackage.haskell.org/package/generic-random are two libraries to generate random data of recursive types (I wrote the second one)
05:11:34 <lyxia> the first one uses the fact that you can enumerate and index the set of values of a certain size. the second one calculates weights and uses rejection sampling to define a recursive generator that doesn't explode in size.
05:13:15 <jedai> onintza: isn't this one of the case where you should use "sized" (I think) to stop generating too big objects
05:13:21 <onintza> MarcelineVQ: I already do use frequency
05:14:05 <onintza> jedai: I do, but in itself it doesn't work without using frequency with a ridiculously high bias (200:1)
05:14:24 <onintza> lyxia: i'll check it out
05:14:59 <lyxia> these fancy algorithms are so that you get a uniform distribution
05:15:18 <lyxia> much simpler solutions are to bound the depth or size of your structures yourself
05:15:34 <onintza> lyxia: yes, i thought of bounding the depth
05:24:05 <vitamin-q> Hello, I've just started learning Haskell and I'm struggling with a compilation error. After googling, I haven't been managed to fix it. Is it ok to paste in my code + compiler errors and for someone to tell me what's going on?
05:24:27 <Rembane> vitamin-q: Pastebin it, then we help you
05:24:35 <vitamin-q> Rembane: Sure
05:26:38 <lyxia> lpaste.net has better highlighting
05:28:21 <sm> @quote details:
05:28:22 <lambdabot> FAQ says: details: When asking for help, give details such as platform, GHC version, cabal or stack, exact command line, source code, full output, urls. If it's long, paste at http://lpaste.net
05:29:45 <Rembane> lyxia: Indeed, I'll change my verb.
05:33:33 <vitamin-q> http://lpaste.net/2817739893273264128
05:33:36 <lyxia> :)
05:33:44 <vitamin-q> Hopefully I've provided you guys with enough
05:33:49 <vitamin-q> info
05:33:51 <int-e> ugh when did haskell-cafe start munging from addresses? that "via Haskell-Cafe" part is annoying.
05:36:12 <sm> @remember FAQ paste: Paste long things at a paste site. http://lpaste.net highlights and lints haskell and announces to this channel.
05:36:12 <lambdabot> Nice!
05:36:43 <int-e> or is that a gmail feature, mumble
05:37:04 <hvr> int-e: seems very recent
05:37:16 <jedai> vitamin-q: BrainfuckSource is not a type constructor
05:37:33 <jedai> data BrainfuckSource = <- look, no type variables
05:38:09 <jedai> Show (BrainfuckSource [a]) <- but in your instance you're doing like BrainfuckSource needed a type parameter
05:38:45 <jedai> vitamin-q: so your instance should be of BrainfuckSource, not BrainfuckSource [a]
05:38:54 <hsk3> How can I convert a   Map ByteString ByteString   to a JSON ByteString?
05:39:28 <jedai> vitamin-q: and in fact that is what the error was saying to you (BrainfuckSource is a type, not a type constructor, you can't apply it to [a] )
05:40:14 <lyxia> vitamin-q: also show BrainfuckSource []  defines a function of two separate arguments (BrainfuckSource and []), but what you really mean is show (BrainfuckSource [])  (one single argument)
05:41:07 <hsk3> nm
05:41:35 <vitamin-q> jedai, lyxia: I see, thank you very much :)
05:45:49 <absence> i was watching bartosz milewski's videos on category theory, and i remember one of them talked about what makes something "strong", but i've forgotten which video it was, and what was said. anyone know?
06:18:43 * hackagebot plots 0.1.0.0 - Diagrams based plotting library.  https://hackage.haskell.org/package/plots-0.1.0.0 (cchalmers)
06:18:45 * hackagebot ombra 0.2.1.0 - Render engine.  https://hackage.haskell.org/package/ombra-0.2.1.0 (ZioCrocifisso)
06:19:24 <MarcelineVQ> absence: https://en.wikipedia.org/wiki/List_of_mathematical_jargon it has all the meanings listed for strong here but most often I see it used to say: x is stronger than y if you can get y from x but you can't easily get x from y
06:19:58 <MarcelineVQ> as a direct example to things we use here, Monad is stronger than Applicative or Functor because they can both be defined in terms of it
06:21:35 <MarcelineVQ> I think :>
06:21:56 <praveen> .
06:27:07 <joe9> where are the Show instances of Data.Map.Strict (of the containers package) defined?
06:28:01 <praveen> Hi, I would like to try web scraping in haskell. I have red 'Learn you a haskell' and I think I finally understand Monads. I have wrote around 1000 lines of haskell code.
06:28:37 <joe9> i cannot seem to find any show metheds heer https://github.com/haskell/containers/search?p=1&q=show&utf8=%E2%9C%93 . I presume that they are just derived. Any suggestions on how I can find what the deriving Show does?
06:28:46 <praveen> Would this much of learning will enought to take up web scraping task in haskell
06:29:00 <joe9> praveen: I think so.
06:29:21 <joe9> praveen: one thing that stuck me with haskell is that the lines of code do not matter.
06:29:41 <praveen> would you recommand library or some tutorial to get started. that will be great help
06:29:57 <joe9> praveen: there is an article about various people writing code and the best code ends up being the simplest or easily understandable.
06:30:11 <joe9> praveen: I use http-conduit
06:30:18 <praveen> thats a good pointer
06:31:14 <praveen> The reason I concerned is, I don't understand Monad Tranform yet. 
06:31:23 <athan> wreq is also fun
06:31:50 <MarcelineVQ> joe9: http://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Map.Base.html#Map    instance (Show k, Show a) => Show (Map k a) where
06:31:56 <joe9> praveen: don't need to. just stick with using IO () with explicit type signatures. It is actually cleaner than using Monad transforms.
06:32:26 <joe9> MarcelineVQ:  Thanks
06:32:35 <praveen> okay :). thats a relief 
06:34:08 <joe9> MarcelineVQ: How did you get that? For me, the Data.Map.Base module url is just text (not clickable)
06:35:36 <MarcelineVQ> I scanned through the source like a cheater starting at http://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Map.html
06:36:55 <MarcelineVQ> it has links for the different things so you can clikc on Data.Map.Strict there to look at that source, which imports Data.Map.Strict.Internal so I clicked on that which had Data.Map.Base etc
06:37:28 <MarcelineVQ> alternatively you can download the source and just grep for it, stack and cabal can both download sources for you iirc
06:38:31 <MarcelineVQ> stack unpack containers, cabal something something
06:39:33 <ocramz> Is anyone aware of an efficient `groupBy` for Vector ?
06:40:59 <MarcelineVQ> ocramz: What would it result in?
06:41:28 <ocramz> (a -> a -> Bool) -> Vector a -> Vector (Vector a)
06:41:34 <nut> any good library to edit json? i want to batch insert a field into a json
06:42:28 <ocramz> nut : aeson?
06:48:06 <joe9> MarcelineVQ: Thansk.
06:48:16 <joe9> s/Thansk/Thanks/
06:48:21 <MarcelineVQ> `cabal get` appearantly
06:48:30 <joe9> nut, aeson is good and can be derived generically too.
06:54:39 <actionshrimp> Hey, I'm trying to learn about RankNTypes from this blog post https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html, and am struggling somewhat with the exercise at the end of the 'Church Encoding' section. So far I've got this https://gist.github.com/actionshrimp/65801c2c8de601d1e299177fdc276b2a but have no idea what to put in the type hole!
06:55:29 <athan> actionshrimp: Do you understand Rank2?
06:55:37 <athan> it's pretty easy once you get it :)
06:56:02 <actionshrimp> I think I understand what it means (from reading that post) but wouldnt say I had decent intuition about it yet
06:56:06 <athan> Haskell natively is Rank-1: all the `forall`s are implicit because all type variables are at the top level
06:56:13 <athan> it's crazy
06:56:53 <actionshrimp> Ah yeah, I think I got that part. And Rank2 meaning forall 'nested one level deep'?
06:56:54 <athan> `id :: a -> a` is really `id :: forall a. a -> a`, but we don't usually explicitly say that unless we wanted more universal polymorphism
06:57:02 <actionshrimp> ah yep
06:57:05 <athan> exactly, it's weird to see first-hand though
06:57:09 <athan> take this for instance:
06:57:26 <athan> foo :: (forall a. a -> Int) -> (String, Bar) -> (Int, Int)
06:57:47 <athan> foo would be able to apply its first argument to each (String, Bar)
06:58:05 <circ-user-QJY8M> I do not get what return a = State $ \s -> (a, s) means for State s a = State { runState :: s -> (a, s) }.
06:58:15 <athan> because it works "for all a at that scope"
06:58:33 <circ-user-QJY8M> What are the a s in  $ \s -> (a, s)?
06:58:45 * hackagebot Rasterific 0.7.1 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7.1 (VincentBerthoux)
06:58:47 * hackagebot haskelisp 0.1.0.5 - Write Emacs module in Haskell, using Emacs 25's Dynamic Module feature  https://hackage.haskell.org/package/haskelisp-0.1.0.5 (shintak)
06:58:49 <athan> circ-user-QJY8M: `return` is supposed to represent a pure value lifted into the monad, where no effects are made
06:59:22 <athan> in this case, you're embedding the `a` into a "no-op"
06:59:58 <circ-user-QJY8M> This is a set phrase. I am asking to explain in concrete example.
07:00:13 <actionshrimp> athan: so in that example signature, a doesnt get locked down until the first arg is applied somewhere where the a needs to be realised
07:00:21 <actionshrimp> ?
07:00:28 <athan> :) yep
07:00:43 <athan> in normal haskell, all the `forall`s can be raised to the top-level
07:00:52 <athan> it's a property of prenex polymorphism
07:01:21 <athan> But `foo` is Rank-2
07:01:27 <absence> MarcelineVQ: thanks for the link! i don't think it was "strong" as in your example (monad vs applicative), but rather strong vs "non-strong" version of the same idea
07:01:31 <athan> and if you go deeper than that, it's rank-N :)
07:01:58 <actionshrimp> ok, I think I get that part then :) In the gist I posted, I'm getting an r can't be equated with an r1 in one of my attempts so I'm guessing the constraints arent lining up quite how I want
07:02:14 <athan> circ-user-QJY8M: `s` is the state value represented in the monad
07:02:36 <circ-user-QJY8M> That is even a more general phrase.
07:02:38 <athan> it's basically a bunch of `s -> s` functions composed :)
07:02:55 <athan> word on lol
07:03:29 <athan> actionshrimp: That's a hard thing to work around, but you'll get the hang of it
07:04:10 <athan> skolem variables / ambiguous variables can never really be "known" at a level more global than whence they were used
07:05:08 <athan> take this for example:
07:05:35 <athan> cantCompose :: (forall a b. a -> b) -> (forall b c. b -> c) -> a -> c
07:05:40 <athan> can you write this? :)
07:05:53 <athan> can the two `b`s ever really unify?
07:06:54 <actionshrimp> ah because you're only locking down the a and the c and the compiler has no way of knowing?
07:07:11 <actionshrimp> hmm yeah I think that's similar to what I'm battling now actually
07:08:06 <danilo2> Hello! :) I've got a performance question. Let's imageine we've got something like `MVector s (MVector s Int)`. I'm evaluating eerything in some PrimMonad m. I've got indexes (i, is) :: (Int, [Int]).
07:08:36 <athan> actionshrimp: even then, the global `a` and the `(forall a. a ...)` won't unify!
07:08:45 * hackagebot heterocephalus 1.0.0 - A flexible and type safe template engine for Haskell.  https://hackage.haskell.org/package/heterocephalus-1.0.0 (arowM)
07:09:05 <danilo2> Does it matter if I do `v' <- read v i; vals <- mapM (read v) is` or use a function which will each time index the first vector too, but will be inlined? Will GHC optimize it the same way?
07:09:21 <athan> because the second one is saying "no! even if it's that `a` on the left, it still needs to work with every `a` possible!"
07:09:29 <actionshrimp> ahhh
07:09:44 <danilo2> Is there any way to be sure it will be optimized / wont be optimized if its run in some monadic stack ?
07:09:53 <actionshrimp> then I guess I'm missing a forall somewhere
07:10:33 <actionshrimp> if RankNTypes is turned on are there no longer the Rank 1 implicit foralls in that module?
07:10:46 <athan> it's still implicit
07:11:32 <actionshrimp> kk, ill have another go - thanks for your tips :)
07:12:07 <athan> np happy to help :)
07:12:59 <athan> Anyone here cross-compile to raspberry pis?
07:13:31 <athan> I'm trying to get a decent system working. I've tried to run GHC on the pi, but it's detrimentally slow :\
07:13:45 * hackagebot xml-conduit 1.4.0.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.4.0.2 (MichaelSnoyman)
07:23:46 * hackagebot wai-frontend-monadcgi 3.0.0.3 - Run CGI apps on WAI.  https://hackage.haskell.org/package/wai-frontend-monadcgi-3.0.0.3 (MichaelSnoyman)
07:26:01 <kirillow_> Can somebody explain this to me? http://lpaste.net/343978
07:32:37 <athan> kirillow_: Do you just want the answer?
07:32:45 <athan> or do you need to understand the problem?
07:32:56 <kirillow_> I do want to understand it
07:33:12 <kirillow_> I dont get it at all
07:33:56 <athan> hmm
07:34:04 <athan> I don't want to spoil anything for you
07:34:12 <athan> functors are really good topics
07:34:24 <athan> but this question isn't posed well for someone who doesn't understand them
07:34:58 <athan> kirillow: Do you have other questions you can look at? This one doesn't look very enlightening
07:35:11 <kirillow> Im not sure what you mean
07:35:24 <athan> it seems like an advanced question
07:35:38 <athan> and wouldn't teach you something if you're new to the concept
07:36:29 <athan> well, here's a start
07:36:38 <athan> notice "assume the following is correct"
07:37:01 <kirillow> ?
07:37:05 <kirillow> thats what i wrote
07:37:27 <kirillow> i replaced the (.) signature with the functor signatures
07:37:52 <kirillow> calling :t (fmap . fmap) returned this other signature at the very end
07:37:56 <athan> that third argument in line 16 is weird
07:38:10 <athan> er line 19
07:38:28 <athan> i can see the two fmaps being passed in
07:38:30 <athan> idk :s
07:38:33 <athan> that's a weird one lol
07:38:50 <athan> but I think they're asking you to do typechecking or something
07:38:53 <athan> type reductions :s
07:40:28 <Shockk> hello, I have a really quick question,
07:41:33 <Shockk> when I'm specifying build-depends in a cabal file, if I want to require specifically base 4.9, but I don't mind if it's something like base 4.9.2.0, what's the best way to do that
07:41:48 <Shockk> should I do something like base >= 4.9 && < 4.10?
07:42:52 <maerwald> >= 4.9 is more sane unless you know it doesn't work 4.10. However, "cabal check" idiotically complains about it
07:43:37 <Shockk> I mean, there isn't a 4.10 yet and I'd want to resolve such a case manually, to ensure it actually work
07:43:38 <Shockk> works*
07:44:10 <maerwald> yes, last base-switch upper bounds were particularly annoying since most packages just built fine with it
07:44:51 <joe9> any kind suggestions on this code, please? https://github.com/joe9/GenericPretty/blob/master/src/Text/PrettyPrint/GenericPretty.hs
07:46:33 <o_pax> @krillow: I think athan did not understand your question. I assume you derived lines 16 - 20 from the types of (.) and fmap, and can't match the result with what haskell tells you the type of (fmap . fmap) is. Correct?
07:46:33 <lambdabot> Unknown command, try @list
07:48:04 <kirillow> o_pax: yes
07:50:17 <o_pax> krillow: your derivation is not correct. first, you have to assert matching types for the (b)-position in the type of (.), i.e. the result type of the second parameter must match the input type of the first parameter in (fmap . fmap)
07:53:15 <o_pax> krillow: (fmap . fmap) is the same as (.) fmap fmap . This should help you in finding the correct type derivation.
07:53:27 <ashishnegi> hi.. while moving over a matrix's row, if we need previous and next rows, what is the right pattern in haskell to do it.. `zip matrix (drop 1 matrix) (drop 2 matxi)` ??
07:54:30 <ashishnegi> This makes one last row to miss.. because of first and last row to miss.. putting a dummy list on top is easier.. but for last row.. at the end of list is costly..
07:54:34 <ashishnegi> Any suggestions ?
07:55:41 <kang0> Who can offer me laptop (and work)
07:55:55 <ashishnegi> `zip ((repeatedly numCol 0) : matrix)) matrix ((drop 1 matrix) ++ (repeatedly numCol 0))`.. the last `++` is costly..
07:57:59 <Boomerang> ashishnegi: what does repeatedly do? Is it just replicate?
07:58:37 <ashishnegi> Boomerang: yes.. it is replicate only.. my mistake
07:59:06 <ashishnegi> `zip ((replicate numCol 0) : matrix)) matrix ((drop 1 matrix) ++ (replicate numCol 0))`.. the last `++` is costly..
08:00:39 <sm> what's the shortest way to get the first Just of a list of Maybes ?
08:00:55 <lpaste> kirillow annotated “Composing functors” with “Composing functors (annotation)” at http://lpaste.net/343978#a343996
08:00:55 <sm> can it be done with the Monad instance ?
08:01:34 <Boomerang> > msum [Nothing, Just 2, Just 3]
08:01:37 <lambdabot>  Just 2
08:01:48 <sm> nice! thank you
08:02:27 <sm> that works because.. Maybe's MonadPlus instance works differently from its Monad instance ?
08:02:35 <kirillow> o_pax: how do you do that?
08:05:12 <o_pax> krillow: you should read (x->y) -> g x -> gy as (x -> y) -> (g x -> g y)
08:05:55 <Boomerang> sm: I actually have no idea, I would like to know more about this too. mplus for Maybe seems to make sense but I don't know what the theory is behind it implementation
08:06:30 <kirillow> o_pax: how do I know that?
08:06:34 <ggVGc> I find myself often wanting to encode functions as ADT constructors together with an evaluator function processing that ADT. Is there any TH library that would generate this for me?
08:08:48 * hackagebot rasterific-svg 0.3.2.1 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.3.2.1 (VincentBerthoux)
08:09:02 <ggVGc> like, if I have functions `foo :: Int -> Int -> a` and `bar :: String -> a`, I'd like to generate something like `data Func = Foo Int Int | Bar String` and a function `runFunc :: Func -> a`
08:11:50 <o_pax> krillow: ok, I may have been misleading. You derive the type by simply subsituting the parameters by their types. But the fmaps are _applied_ to (.). Try deriving the type of ((.) fmap) first!
08:14:35 <kirillow> aaaaaaaaahh
08:15:05 <kirillow> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahhhhhhhhh!
08:15:28 <kirillow> Thank you!
08:15:33 <o_pax> :)
08:37:44 <abdulsattar> Hello, people, can anyone help me why I am getting an error here: http://lpaste.net/344016#line5
08:38:11 <abdulsattar> functor.hs:5:24: error:     • Couldn't match type ‘a1’ with ‘b’       ‘a1’ is a rigid type variable bound by         the type signature for:           fmap :: forall a1 b. (a1 -> b) -> EEither a a1 -> EEither a b         at functor.hs:5:3
08:38:31 <abdulsattar> otoh, if I just remove the @pattern, it works
08:40:08 <pavonia> y still has the "old" type for b, but you want to have the mapped type on the right-hand side
08:41:29 <geekosaur> the EEither value is tagged with both types even though it is only using one of them. so you can't just reuse it, you have to "remake" it with the correct EEither type
08:43:14 <maerwald> fmap :: (a1 -> b) -> EEither a a1 -> EEither a b -- those Eithers are not the same
08:43:48 <maerwald> the compiler error is pretty clear actually
08:45:12 <abdulsattar> thanks guys, now it's clear. It felt weird when @patterns are supposed to be the same value
08:45:25 <geekosaur> all values are typed, though
08:46:04 <geekosaur> Nothing :: Maybe Int is not the same value as Nothing :: Maybe Char. Left 5 :: Either Int String is not the same value as Left 5 :: Either Int Bool.
08:46:13 <geekosaur> etc.
08:47:11 <geekosaur> this looks like it's just an annoyance to you now, but as you continue you will learn about phantom types and, more generally, using type level "tags" on values to distinguish things that look the same but shouldn't be treated the same
08:47:22 <AdituV> Hi.  I'm trying to write a parser with megaparsec but having trouble getting the backtracking correct for it to actually work.  The bit I'm struggling on is something like try (many (symbol ";" <|> eol)) *> eol  but I haven't figured out how to backtrack once the first part has consumed all the eols
08:47:28 <AdituV> Is there a different approach I should be trying?
08:47:48 <maerwald> not sure I want more people to use phantom types
08:48:24 <abdulsattar> geekosaur: I don't think it's an annoyance. I just couldn't understand it. But it's more clear now.
08:48:32 <geekosaur> I added the "more generally" part to point toward things like Proxy
08:49:21 <geekosaur> and DataKinds etc.
08:50:30 <maerwald> or you just use what you actually need :P
08:53:29 <ertesx> sm: msum is wrong
08:53:54 <ertesx> sm: ah, no, i confused something
08:53:58 <ertesx> nevermind
08:58:50 * hackagebot mmorph 1.0.8 - Monad morphisms  https://hackage.haskell.org/package/mmorph-1.0.8 (GabrielGonzalez)
09:00:57 <saurabhnanda> anyone here who has worked with any DB library in Haskell? Would you be kind enough to give me feedback on this tutorial: https://github.com/vacationlabs/haskell-webapps/blob/docs/doc/db-mappings.md
09:13:50 * hackagebot opencog-atomspace 0.1.0.7 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.7 (romanT)
09:15:58 <praveen> in this code `randomRs (1,512) <$> getStdGen` what is `<$>`? what is it called? 
09:16:33 <alx741> praveen: it's fmap alias
09:16:50 <alx741> *fmap infix version actually
09:17:19 <praveen> @alx741 okay. thanks
09:17:19 <lambdabot> Unknown command, try @list
09:17:43 <juri_> um. <<loop>>?
09:18:51 <grantwu> @src (<$>)
09:18:52 <lambdabot> f <$> a = fmap f a
09:19:05 <srhb> juri_: Is that a question? It's what it says on the tin, looping endlessly and unproductively. :)
09:19:11 <geekosaur> it re-entered something while trying to evaluate it because of left recursion
09:19:51 <juri_> srhb: i changed two lines in my monad definition, not my program dies as soon as in's done parsing it's input file.
09:19:52 <geekosaur> usually means you forgot that in let x = {- something using x -}, the x is the same on both sides --- it will not use an outer binding for x on the right, it uses the new one
09:20:06 <juri_> time to read up on monads for a while..
09:20:19 <srhb> juri_: It has nothing to do with monads in particular.
09:20:54 <pavonia> > let x = x in x
09:21:00 <lambdabot>  mueval-core: Time limit exceeded
09:25:05 <AdituV> I'm trying to write a parser with megaparsec but having trouble getting the backtracking correct for it to actually work.  The bit I'm struggling on is something like try (many (symbol ";" <|> eol)) *> eol  but I haven't figured out how to backtrack once the first part has consumed all the eols.  Is it possible with try, or should I be using a different approach?
09:26:37 <AdituV> semicolons are an optional line terminator in the language I'm parsing, but block constructs like if have to start on a new line
09:28:29 <pavonia> It won't backtrack if the first branch was completely successfull
09:29:52 <AdituV> yeah, that's the problem.  oh, I could split it into two stages or something
09:31:15 <pavonia> Could you paste an actual example? It's not very clear to me what you are trying to achieve
09:31:17 <AdituV> like many (many semicolon *> eol)
09:31:52 <AdituV> yeah sure, I'll put an invented snippet of the language up on lpaste
09:32:50 <juri_> ok, fxed it. :)
09:33:47 <lpaste> AdituV pasted “example_weirdparse.qbscript” at http://lpaste.net/344055
09:35:32 <AdituV> I'm trying to write the section of the parser that skips empty instructions between two instructions or between an instruction and a block construct
09:37:04 <AdituV> I guess I could add an "empty instruction" case to the AST but it seems like a weird thing to include
09:39:35 <pavonia> Maybe something like (eol *> notFollowedBy pElse)
09:39:54 <pavonia> Such that the eol can backtrack in case the else part is found
09:43:10 <pavonia> Could also be easier to just have an additional lexer phase that checks for significant whitespace around tokens and feeds the parser with a list of annotated tokens
09:43:45 <AdituV> yeah, I have a lexer for spaces and tabs, but found I had to take end of line out of it because it had some relevance to the grammar
09:43:51 * hackagebot plots 0.1.0.1 - Diagrams based plotting library.  https://hackage.haskell.org/package/plots-0.1.0.1 (cchalmers)
09:44:03 <xcmw> Is there a way to specify that a closed type family must be defined for all values of a certain kind
09:44:20 <AdituV> but the notFollowedBy is a good idea.  Maybe something like notFollowedBy blockKeyword will work well.  Thanks!
09:55:47 <ggVGc> how would something like `StateT Int (Writer String) Foo` look without monad transformers?
09:57:11 <pavonia> @unmtl StateT Int (Writer String) Foo
09:57:11 <lambdabot> Int -> (Foo, Int, String)
09:58:26 <ggVGc> pavonia: well, yes, but if I wanted to use the State and Writer monads
09:58:29 <ggVGc> but not the transformers
09:58:43 <ggVGc> I mean, these monads existed before transformers right?
09:59:19 <pavonia> Not sure what you mean
09:59:51 <geekosaur> ggVGc, RWS
10:00:06 <geekosaur> and you'd ignore the Reader part
10:00:50 <ggVGc> rws?
10:01:39 <geekosaur> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-RWS.html
10:01:55 <ggVGc> ah, yeah, thanks. I just googled it :)
10:03:49 <saurabhnanda> does anyone know Hakyll? would the following in the middle of a post markdown work? $partial("includes/db-mappings/schema.sql")$ 
10:17:32 <saurabhnanda> any help with https://github.com/jaspervdj/hakyll/issues/486 please?
10:28:52 <pavonia> Is there a parser library that doesn't use a built-in error type?
10:32:14 <grantwu> Hrm... I have an expression of type State FooState [[BarType]]
10:32:39 <grantwu> I should be able to concatMap <$> over this expression to get [BarType], right?
10:33:10 <grantwu> ugh, I forgot, I need concat.
10:33:22 <ertesx> pavonia: megaparsec lets you choose the error type, if you use the more general ParsecT type
10:33:26 <grantwu> Is there an idiom for concat <$> traverse ?
10:33:45 <grantwu> @pl concat <$> traverse
10:33:45 <lambdabot> join <$> traverse
10:34:10 <grantwu> wat, that seems... I guess that works...
10:34:34 <zipper> Hey is there no easy way to create maps like there is to create lists using `[]`?
10:35:23 <ertesx> zipper: M.fromList [(k1, x1), (k2, x2), …]?
10:35:23 <grantwu> Isn't there fromList?
10:35:55 <zipper> That isn't easy and convenient like say {k1 v1, k2 v2}
10:36:18 <ertesx> zipper: well, there is -XOverloadedLists, which probably works with Map
10:36:30 <ertesx> but i haven't seen anyone use it, and i don't use it myself
10:36:59 <zipper> ertesx: Well I'm not like pissed out about it :D so I'll just use what everyone is using and keep wondering why it is so.
10:37:31 <grantwu> I don't think construction of maps from literal values happens too often
10:37:31 <ertesx> zipper: we don't have special syntax for, let's call them, "association list literals"
10:37:52 <ertesx> i guess mostly because what grantwu said
10:38:08 <zipper> Valid reason
10:38:36 <shlevy> What's the appropriate way to enable a particular test conditional on running on a specific OS?
10:38:44 <ertesx> zipper: my guess is that it's because we have record types for many of the use cases where you would use maps in other languages
10:38:53 <shlevy> Putting a top-level 'if os(freebsd)' gives me If-blocks are not allowed in between stanzas
10:39:10 <pavonia> ertesx: The Haddock documentation says so, but looking at the code that e parameter seems to be missing http://hackage.haskell.org/package/megaparsec-5.1.2/docs/src/Text-Megaparsec-Prim.html#ParsecT
10:40:00 <ertesx> pavonia: indeed, that's interesting
10:40:18 <ertesx> pavonia: i'd say that's bug-report-worthy
10:41:05 <geekosaur> yes, someone hit that yesterday as well. my guess was that someone built the docs manually... incorrectly or against the wrong thing
10:42:44 <ertesx> pavonia: what about parsec?  perhaps it's some parsec artifact
10:43:30 <pavonia> No, parsec doesn't have that
10:43:53 <xT1ger> Hi, why doesn't this code snippet compile and how can i fix it? http://pastebin.com/DbZY4yuR (ghci output: http://pastebin.com/k8zqVYVr)
10:43:58 <ertesx> then you're probably on your own…  trifecta doesn't have it either
10:44:11 <ertesx> and attoparsec has only one error mode: "your input sucks"
10:44:41 <m`> when would one use a tuple inside of an data constructor? I'm struggleing between data Color = Color Int Int Int VS. data Color = (Int, Int, Int)
10:45:00 <pavonia> ertesx: I'm also only interested in the implementation, and the megaparsec sources have that e, so all good :)
10:45:03 <monochrom> Didn't you get an answer from #haskell-beginner already?
10:45:04 <grantwu> m`: As a matter of convention, you don't
10:45:08 <ertesx> m`: only below other type constructors
10:45:17 <jedai> m`: I answered on haskell-beginers
10:45:20 <grantwu> ertesx: Wait, what does that mean
10:46:01 <ertesx> something like that: data Colors f = Colors { _foreground :: f (Double, Double, Double), _background :: f (Double, Double, Double) }
10:46:27 <grantwu> Oh, okay, yea
10:46:35 <m`> monochrom: sorry for the re-posting, I was kicked out
10:47:05 <ertesx> xT1ger: the error message is gone
10:47:22 <ertesx> xT1ger: also please use lpaste.net or gists for haskell code, because pastebin.com messes up the formatting a lot
10:47:23 <jedai> m`: Anyway don't do that, that's just adding an useless layer of indirection 
10:48:04 <jedai> m`: ertesx exemple is different since the tuple is not directly behind the constructor
10:48:24 <xT1ger> Here is the error again: http://pastebin.com/Bpfr01U6
10:48:35 <xT1ger> ertesx: noted
10:48:54 * hackagebot snaplet-sqlite-simple-jwt-auth 0.1.0.0 - Snaplet for JWT authentication with snaplet-sqlite-simple  https://hackage.haskell.org/package/snaplet-sqlite-simple-jwt-auth-0.1.0.0 (JanneHellsten)
10:50:58 <ertesx> xT1ger: arr!len-1  -- you're defining an array with index type (Int, Int), but then do this; also note the unexpectedly high precedence of (!)
10:51:34 <m`> ertex: how would you do it for a color type, which contains only one rgb value (e.g. only a foreground)?
10:52:21 <ertesx> m`: if you're an early beginner:  data Color = Color Int Int Int
10:52:38 <ertesx> if you have some basic experience with types:  data Color a = Color a a a
10:53:26 <xT1ger> ertesx: thanks, that fixed that, now i have to figure out a parse error on the first | of line 8
10:54:15 <m`> alright, the second one would make it more generic, not only working with Doubles. Ok, I was considering this, so it looks like wrapping the 3 values inside of a tuple does not make sense
10:54:30 <ertesx> m`: right
10:55:55 <ertesx> m`: consider tuples to be ad-hoc/on-demand records…  you use them only when you need them
10:56:12 <pikajude> can I invoke stack to only have it show me what it resolved the versions of packages to be?
10:56:46 <monochrom> I don't know stack, but cabal has --dry-run, maybe stack has it too
10:57:33 <jedai> pikajude: stack has --dry-run too
10:58:12 <monochrom> then again --dry-run tells what could happen in the future, but you're probably asking about what already happened in the past.
10:58:41 <geekosaur> stack list-dependencies
10:59:55 <pikajude> nah this package has a stack.yml and I'm trying to nixify it so I need to know what dependencies it would properly install with
11:01:59 <ertesx> that reminds me of a question:  is roconnor's colour package <https://hackage.haskell.org/package/colour> still maintained?  the last release (2012) still builds and works, so i'm not sure it's unmaintained or simply just "didn't need an update in four years"
11:02:50 <jedai> ertesx: inspecting its reverse-dependencies maybe ?
11:03:58 <ertesx> there should be a link on hackage, because i can't remember how to do it
11:05:44 <xcmw> Is there a way to specify that a closed type family must be defined for all types of a certain kind?
11:06:15 <monochrom> meanwhile, esqueleto has been unmaintained for only a few months, and people on haskell-cafe are already bloodthirsty enough to want to devour^W take over it :)
11:08:00 <ertesx> … while i'm still trying to figure out what's so great about it
11:09:09 <ertesx> seems like persistent went: "SQL sucks, and we want to be database-agnostic, so let's abstract both away"
11:09:29 <ertesx> then esqueleto went:  "persistent is too abstract and idealised, let's bring back SQL a bit"
11:13:46 <geekosaur> ertesx, some of that is normal hunting around for the right balance, some is developer preference (and never discount "I'll take the devil I know" as a motivation)
11:16:49 <maerwald> depends how you look at it
11:25:39 <shapr> GOOD MORNING!
11:25:46 <shapr> Anyone writing cool code?
11:29:11 <ertesx> geekosaur: sure, i understand why it happens…  just makes me think that i should write about some of the alternative methods i've encountered
11:30:23 <ertesx> with the general motto: don't model "databases", model your application
11:31:43 <lordcirth> shapr, I'm having fun writing Haskell, at least.
11:33:29 <geekosaur> sure. although one of the complications there is that your application might need to function as part of a suite where you don't get to specify how the other parts work
11:34:40 <shapr> lordcirth: cool, what are you writing?
11:34:57 <lordcirth> shapr, a roguelike
11:35:19 <geekosaur> "this thing needs to hook into SAP" great, you are now tied to Oracle database and SAP's ... unique ... view of how the world works
11:35:47 <lordcirth> I have heard horror stories about SAP
11:38:29 <orion> Why do Oracle and SAP suck?
11:39:08 <lordcirth> Why does anything suck?
11:39:17 <kosmikus> shapr!!!
11:39:40 <ggVGc> it takes too long to write a single piece of correct softwre
11:39:44 <ggVGc> so no one has doneit yet
11:39:58 <geekosaur> a great many commercial packages started out as someone's hacked-up in-house thing that worked well enough for their specific use case
11:40:03 <shapr> howdy kosmikus! How you doin?
11:40:36 <geekosaur> and then got twisted into pretzels when they decided to commercialize it and found out not everyone does, or can, work the exact same way
11:40:54 <kosmikus> shapr: all good. and you?
11:41:25 <geekosaur> SAP is one example in accounting, Cadence is an example in engineering.
11:42:10 <shapr> kosmikus: life is good! I'm right now teaching Haskell to a newly hired coworker in an airport.
11:43:00 <lordcirth> shapr, that's cool
11:43:42 <kosmikus> shapr: nice.
11:44:21 <sm> go shapr, apostle of haskell!
11:45:10 <lordcirth> shapr, does your company use Haskell?
11:46:46 <hodapp> orion: Oracle database, for one thing, is full of rather perverse corner-cases and definitions of things like "schema" that it keeps for historical reasons but which are completely at odds with basically all other databases
11:46:58 <hodapp> orion: Oracle the company is also just really scummy.
11:47:16 <geekosaur> and always has been
11:47:23 <lordcirth> Yeah
11:47:58 <hodapp> Oracle DB also smells like dusty punch-cards
11:49:13 <geekosaur> for its design domain (high throughput financial transactions) it really is the best thing out there. but the further you get from that domain, the worse it gets.
11:49:20 <geekosaur> s/throughput/volume/
11:50:12 <maerwald> sounds offtopic
11:58:13 <shapr> lordcirth: sadly not, my company is 90% python
11:58:22 <shapr> but I do write small utility scripts in Haskell
11:58:53 <lordcirth> sounds like you got it backwards :P
11:58:58 * hackagebot snaplet-sqlite-simple-jwt-auth 0.1.1.0 - Snaplet for JWT authentication with snaplet-sqlite-simple  https://hackage.haskell.org/package/snaplet-sqlite-simple-jwt-auth-0.1.1.0 (JanneHellsten)
11:59:23 <lordcirth> shapr, how is your co-worker liking the lesson?
12:02:35 <shapr> lordcirth: she had zero problem understanding my Haskell tutorial and now wants to have it installed on her macbook
12:03:02 <shapr> She was able to explain this to me about 20 minutes after the start of the tutorial: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
12:03:15 <lordcirth> shapr, that's cool.  I just convinced a friend of mine to start learning, he's having trouble getting an Xubuntu VM to boot, though.
12:03:29 <grantwu> I'm unconvinced that explaining that is useful at all
12:03:33 <lordcirth> shapr, that's impressive
12:03:40 <shapr> lordcirth: pointed your friend to https://tryhaskell.org/ ?
12:03:52 <grantwu> I've written half a working compiler and I only have the foggiest of ideas what that does
12:04:02 <shapr> grantwu: it meant that she understood lazy evaluation thoroughly
12:04:18 <grantwu> I don't think there's a single recursive binding in the 4k lines of code we have
12:04:25 <lordcirth> shapr, maybe I should.  Personally I'm using ghci and Learn You a Haskell
12:04:34 <Cale> It's funny how far you can get without really understanding lazy evaluation properly
12:05:00 <shapr> I'm going through Haskell from First Principles, but I'm stuck on part of the Functor homework :-(
12:05:02 <jedai> grantwu: That's seriously strange and/or inneficient for a compiler that's supposed to do symbolic manipulation...
12:05:17 <grantwu> jedai: What is strange in it?
12:05:44 <shapr> grantwu: I'd rather say that Haskell allows many different approaches to writing code.
12:06:05 <grantwu> I don't see a single place where we would have any desire to use laziness like that
12:06:19 <jedai> grantwu: compilers tend to manipulate AST, structures that are naturally recursive and thus are more naturally manipulated with recursive functions
12:06:36 <grantwu> jedai: We have plenty of recursive functions
12:06:52 <grantwu> hrm, I see what you mean
12:06:55 <jedai> grantwu: Are you familiar with the blub paradox ?
12:07:31 <shapr> grantwu: to me, the recursive list definition is roughly the same as a recursive function definition
12:07:40 <grantwu> yes, but I am also familiar with many experienced Haskell programmers who believe that laziness by default was a mistake
12:08:58 <jedai> grantwu: that's generally not because they think lazyness is useless though, they just think that it was not the right default :)
12:09:13 <shapr> grantwu: Yup, I feel that way myself sometimes, but I really enjoy using laziness to simplify logic
12:09:35 <grantwu> Sure.  In any case, I don't really see the value in introducing neat tricks like fibs
12:10:33 <shapr> grantwu: what do you think would be a more useful or informative thing to teach to people new to Haskell?
12:11:46 <grantwu> idk tbh
12:12:03 <shapr> grantwu: what are overarching patterns that helped you structure your compiler?
12:12:17 <shapr> like, lots of typeclasses, many monad transformers, or what?
12:12:21 <circ-user-QJY8M> I read here http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf that to make evaluation lazy your function must produce at least one result. Why?
12:12:49 <grantwu> Uh... we have like, 1 place where we use a monad transformer stack, out of pain.  We have like 3 typeclasses we use for convenience
12:13:32 <shapr> grantwu: lots of interesting data type definitions? maybe GADTs?
12:13:40 <circ-user-QJY8M> They also tell "before any parsing of the input string is attempted the result of the parser is immediately forced to take on the form (⊥,⊥):⊥, where ⊥ represents a presently undefined value" and I wonder: why does your parser need to take intermediate parse result for laziness if it was not called yet?
12:13:40 <grantwu> The biggest wins of FP imo are at the level of "oh, we can pattern match on things" and "oh, everything is an expression" and "oh, equational reasoning"
12:13:52 <grantwu> We tried GADTs in one place then threw them out because we ran into too many difficulties
12:13:54 <berndl> What is the best alternative for monad transformer stacks?
12:14:16 <jedai> Well equational reasoning is big... 
12:14:32 <grantwu> I find you run into diminishing returns very quickly when it comes to abstraction past what you get with like, plain SML
12:15:03 <grantwu> (minor footnote - I do appreciate laziness by default because it allows us to just concatenate lists everywhere ahhaa)
12:15:42 <shapr> circ-user-QJY8M: I'd say you can't do laziness unless you are able to produce a partial result that lets you "stop"
12:16:25 <grantwu> I wonder if it makes sense to distinguish "value recursion" vs "function recursion" this is somewhat problematic because functions are values
12:16:27 <shapr> circ-user-QJY8M: for example, scanl vs foldl
12:17:16 <grantwu> googling seems to imply that the former is called "recursive let"
12:17:25 <vctr> hello
12:17:51 <alx741> vctr: hi
12:18:16 <grantwu> shapr: I'm not saying all of the tools that Haskell has aren't useful; they are useful and it's nice to have them available when you need them
12:19:33 <grantwu> shapr: But like... you said you explained the fibs thing in 10 minutes, did you manage to fit the things common to both ML descendants and Haskell in that 10 minutes as well?  or did you skip those
12:20:24 <grantwu> Because to me just regular function recursion, let... in... case, destructuring, parameterized types, data/newtype/type are the bread and butter of statically typed FP
12:21:39 <grantwu> I supposed fibs is useful because it is a cool feature of Haskell that might make you want to learn more about it
12:23:07 <jedai> grantwu: but in Haskell, does it make sense to differentiate between recursive functions and recursion on other values ? Introducing the distinction is unnecessary, don't you think ?
12:24:06 <grantwu> Maybe if you're teaching Haskell as a first language, but other languages are far more likely to have recursive functions than recursion on other values
12:24:13 <lgstate> justin_smith: in that on-focus add on-keypress handler one, doesn't the 'this' refer to the window object?
12:24:32 <lgstate> so what it's really saying is: on this svg elem being focused, register a keypress handler ON THE WINDOW OBJECT -- which then gets routed to the svg element
12:24:51 <lgstate> justin_smith: so even in that example, it never registers a keypress handler on the svg -- it just reroutes things
12:31:32 <grantwu> In general, laziness is one of the biggest things that makes Haskell "out of mainstream" with respect to PL design, right?  Wouldn't I want to teach a newcomer how the concepts they're already familar with are expressed in Haskell, not how a new concept they likely haven't dealt with before is expressed?
12:32:17 <jedai> grantwu: but why would they learn Haskell if they think it's the same as any other language ?
12:34:36 <mettekou> Oh, so we can know whether it is Numberwang in Haskell! https://hackage.haskell.org/package/acme-colosson
12:34:56 <vctr> grantwu: laziness is one thing but i don't think it's the biggest
12:35:10 <vctr> grantwu look at purescript, it's about as 'out of the mainstream' as haskell and it's strict
12:36:25 <lordcirth> vctr, naturally, since it's compiled to js
12:36:28 <grantwu> jedai: I think it's definitely possible to make an argument for Haskell without mentioning purity
12:36:34 <grantwu> er
12:36:43 <grantwu> Without mentioning laziness.
12:37:05 <vctr> grantwu sure there's almost too many ways to make a case for haskell :P
12:37:15 <vctr> that's the curse of deep work
12:37:40 <grantwu> I chose Haskell over Ocaml for this compiler because of its emphasis on purity, the larger community, and the threading support in the runtime
12:38:06 <vctr> when you solve problems at a deep level, any it's hard to communicate all the virtues in a concrete way without selling other aspects short
12:38:15 <berndl> I like Haskell over Ocaml because of its syntax.
12:38:26 <berndl> Also, type classes.
12:39:00 <grantwu> Like, someone from Facebook's Hack team came and described their compiler infra as a guest lecture, and they resorted to extremely frumious hacks to deal with the lack of multithread support
12:39:25 <grantwu> They used the FFI to shell out to some lockfree hashmap they wrote in C.
12:39:37 <grantwu> And serialized Ocaml closures through that.
12:39:41 <vctr> anyone else using haskell for shell glue code?
12:39:55 <vctr> i'm using turtle but wondering if anyone prefers an alternative to that.
12:40:13 <berndl> grantu: Why would they need to serialize ocaml closures to begin with?
12:40:25 <grantwu> berndl: Something something multiprocessing
12:40:30 <berndl> I've been meaning to try Haskell for glue code.
12:40:37 <berndl> But zsh is just so comfy.
12:40:59 <grantwu> Basically each closure was a job, they'd fork out worker processes which would accept closures from this hashmap, deserialize them and execute them
12:41:20 <berndl> I see.
12:41:40 <grantwu> Sooooo I'm not exactly an expert but this seems unwieldly, complex, and fragile...
12:42:27 <grantwu> So yeah laziness was pretty far down the list of why I picked Haskell
12:43:49 <vctr> berndl zsh is confy!? turtle has been pretty good
12:43:55 <grantwu> vctr: Hrm, having strict evaluation still makes it a lot closer to ML derivatives, doesn't it?
12:44:31 <jedai> grantwu: it has typeclass, monads, applicatives, functors and so on
12:44:37 <berndl> vctr: For the kind of crazy shell voodoo that I do, yes.
12:45:02 <grantwu> You can accomplish most of those things, awkwardly, in ML derivatives
12:45:18 <grantwu> Plus, those aren't really part of the language itself, more part of stdlib?
12:45:29 <grantwu> (well, I dunno how awkward it is in ML derivatives)
12:45:50 <jedai> grantwu: right but it's not awkward in Purescript, it's integral to the concept (and no, typeclasses are a feature of the language not of the stdlib)
12:46:17 <grantwu> Bob Harper had a paper about deriving typeclasses from ML modules
12:46:35 <grantwu> But yes, they are part of the language, you're right
12:47:14 <younder> grantwu, If you are used to ocaml why aren't you just writing it in ocaml? To me,the uninitiated, is seems like mixing the language woud only complicate things.
12:47:21 <jedai> grantwu: frankly you have been arguing for a while that lazyness wasn't such a major part of Haskell and now you're going to judge based on that ? ;)
12:47:32 <grantwu> I'm not actually familiar with OCaml.
12:47:38 <grantwu> I'm not sure why you thought that
12:47:54 <grantwu> I was taught SML first and had the choice of choosing Ocaml or Haskell
12:48:03 <jedai> grantwu: Purescript is definitely closer to Haskell (thought strict) than to other derivative of ML
12:48:50 <grantwu> I never said that laziness wasn't a big part of Haskell - it is - but for some people (at least me) it's not why we chose Haskell
12:49:47 <hodapp> isn't there a pragma that one can use in GHC to force strictness anyhow?
12:50:05 <grantwu> jedai: Sure
12:50:06 <jedai> grantwu: I'm just joking... Still purescript is closer to Haskell, really. (Also GHC now has an extension to make a whole module Strict by default)
12:50:06 <maerwald> laziness should be on type level, otherwise you can't properly reason about it
12:50:44 <grantwu> So perhaps "laziness is the main thing that differentiates Haskell from the mainstream" isn't really correct
12:51:23 <younder> grantwu, I would have to say monads are it's most distincitive feature
12:51:24 <jedai> grantwu: I'm pretty sure the main point is purity
12:51:40 <jedai> grantwu: and monads are a consequence as a solution to that
12:51:45 <berndl> younder: monads are not inherent to haskell
12:51:56 <maerwald> jedai: nah, monads are just a convenience pattern
12:52:21 <xcmw> Any ways to make this better? It works fine. http://lpaste.net/344137
12:52:48 <younder> grantwu, I think initially lazy eval was more important
12:52:49 <jedai> maerwald: I know there were other ways to do IO before but you can't say that the main motivation of Monad inclusion in Haskell didn't come from the problem of doing IO in a pure language
12:53:05 <maerwald> jedai: yes, I'd say that's orthogonal
12:53:15 <maerwald> and it wasn't the intention when it was discovered I'm pretty sure
12:53:30 <Rembane> xcmw: Nice code! What does it do?
12:54:03 <jedai> maerwald: read the first papers by Wadler and it seems a pretty big deal (so it was a rediscovery but this was what prompted their inclusion in Haskell)
12:54:43 <younder> berndl, I never said tmonads were invented for Haskell, nor that they are unique to Haskell, merly that they are one of the most distinctive features of Haskell.
12:54:49 <maerwald> jedai: I was talking about the discovery for programming.
12:54:56 <xcmw> Rembane: Hard to explain in words look at the g function definition
12:55:01 <berndl> younder: they are not a feature.
12:55:04 <maerwald> and yes, haskellers realized they can use it to improve IO, but it's not inherent
12:55:37 <jedai> maerwald: me too :) (yes I know Monad were discovered before but as an important tool for programming this definitely date back to Wadler papers)
12:55:59 <younder> berndl, Than what would you call them?
12:56:21 <grantwu> I wonder what my ideal programming language would be.
12:56:26 <xcmw> Rembane: Basically d3.prop = (d2.prop) (d3.prop)
12:56:43 <xcmw> Rembane: Basically d3.prop = (d2.prop) (d1.prop)
12:56:50 <berndl> younder: monads is a mathematical concept, independent of its implementation.
12:57:00 <xcmw> The second message correct
12:57:06 <maerwald> grantwu: proof system of F*, type system of Idris, ecosystem of python
12:57:13 <clmg> Which construct should I use to turn one list into another?
12:57:14 <grantwu> I think it would need to somehow have benign effects.
12:57:23 <grantwu> maerwald: What is F*
12:57:33 <clmg> e.g. [1,2,3,4] -> [10, 20, 40]
12:57:43 <grantwu> oh, never mind, I googled it
12:57:43 <maerwald> grantwu: https://www.fstar-lang.org/
12:57:53 <berndl> maerwald: are you talking about the semi-automated proving features of F*
12:57:57 <younder> grantwu, I don't know, but your ideal language probably wouldn't work in the real world. In my experience 'real' code is messy and contradicts the elegance programmers desire.
12:57:59 <clmg> the length of the result is different from the start, so I assume scanl won't work
12:58:08 <maerwald> berndl: that too
12:58:24 <maerwald> but you can also do extrinsic proofs
12:58:32 <Rembane> xcmw: Cool!
12:58:37 <grantwu> younder: Sure, but that doesn't mean we can't improve existing languages
12:58:43 <berndl> maerwald: extrinsic? Like with auto in Idris?
12:58:56 <xcmw> clmg: What is the pattern?
12:59:02 <younder> grantwu, I am working on one right now :)
12:59:14 <grantwu> younder: cool
12:59:27 <clmg> xcmw: getting the sum of proper divisors from a prime factorization
12:59:38 <clmg> xcmw: the example I gave had little to do with it
13:00:04 <clmg> xcmw: I'm just wondering what to do, since scanl will return a list of the same length as the starting list every time, right?
13:00:09 <maerwald> berndl: https://www.fstar-lang.org/tutorial/tutorial.html#sec-to-type-intrinsically-or-to-prove-lemmas
13:00:54 <maerwald> it's less like Idris, but more like liquidhaskell
13:01:02 <maerwald> except part of the language
13:01:22 <maerwald> as in: you have refinement types
13:01:48 <berndl> Yes, that's one feature in F* that I like.
13:02:25 <maerwald> ofc the usual annoyances of dealing with an SMT solver hold... things are not as high-level as they seem once you get weird SMT solver errors
13:02:52 <maerwald> probably not that easy to close the gap
13:03:59 * hackagebot socket-sctp 0.2.0.0 - STCP socket extensions library.  https://hackage.haskell.org/package/socket-sctp-0.2.0.0 (LarsPetersen)
13:07:28 <ggVGc> I feel pretty dumb. I'm trying to imagine things that would be monads that can't be constructed by combining State, Reader and Writer
13:07:32 <ggVGc> and I can't
13:07:48 <jedai> ggVGc: Maybe ?
13:08:02 <geekosaur> ggVGc, IO :)
13:08:08 <berndl> Continuation
13:08:13 <younder> berndl, Well haskells moads are no exactly the same as mathematical moads. The seem to be limited to linear transforms on ordered sets.
13:08:42 <ggVGc> have to say I've only really heard about Continuation
13:08:47 <ggVGc> will read about it
13:08:54 <geekosaur> Haskell monads are a pattern that is widely applicable, but it can take some work to understand that pattern and even more to begin to recognize it
13:09:00 <geekosaur> @google you could have invented monads
13:09:01 <berndl> younder: of course they're not the same, one is an implemention of the concept.
13:09:02 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
13:09:02 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
13:09:32 <geekosaur> which will get you started on the idea, but won't necessarily help you learn to recognize them; that is only possible with experience
13:09:32 <ggVGc> geekosaur: this is what I'm trying to get into. I don't think I am able to recognize monads outside of what I've come in contact with through the ones implemented in haskell
13:09:40 <geekosaur> (like pretty much anything else, really)
13:10:00 <berndl> Continuation is probably the strangest monad out there in the wild.
13:10:10 <maerwald> and probably not that useful
13:10:15 <geekosaur> I don't think anyone's found a quick trick for it. You just have to keep working with them, and hopefully at some point it suddenly "clicks"
13:10:17 <grantwu> Isn't there a tardis monad :P
13:10:33 <hpc> there is
13:10:43 <hpc> it's a combined state and reverse state
13:10:49 <maerwald> geekosaur: with "click" you mean starting to create weird transformer stacks?
13:10:53 <hpc> reverse state takes advantage of how let-in works in both directions
13:10:54 <maerwald> I hope it's not clicking for me :P
13:10:57 <hpc> so you can send state "backwards"
13:11:16 <joncol> Does anyone know of a library for creating a REPL, where you can browse in the command history with the arrow keys?
13:11:20 <geekosaur> no, I mean some relationship between concepts in your brain suddenly becomes clear / makes sense
13:11:27 <hpc> though really it's just a rather indirect form of knot tying
13:11:32 <geekosaur> and you can suddenly see what's going on
13:11:35 <jedai> joncol: haskeline ?
13:11:37 <grantwu> joncol: Is readline sufficient?
13:11:44 <grantwu> (the C program readline)
13:11:52 <grantwu> er, no, hold on
13:11:58 <Tuplanolla> You can use `rlwrap` as a first approximation, joncol.
13:11:58 <joncol> grantwu: I don't know what that does.
13:12:00 <grantwu> rlwrap
13:12:06 <geekosaur> mathematical intuition is the same way. so is chess, for that matter
13:12:07 <joncol> jedai: I'll look into that.
13:12:15 <hpc> also Cont is an excellent type
13:12:20 <joncol> Tuplanolla: OK... Many suggestions.
13:12:27 <hpc> i haven't had occasion to use it myself but i remember seeing it used to great effect
13:12:31 <joncol> How's rlwrap compared to haskeline?
13:12:35 <grantwu> rlwrap wraps a "dumb" REPL and provides history, history search, etc.
13:12:45 <grantwu> rlwrap is an external binary written in C
13:12:56 <Tuplanolla> It has some fundamental problems with races and limitations.
13:12:58 <hpc> or its "forall" version, which i forget the name of
13:13:10 <geekosaur> rlwrap is kinda different, it's an external program that retrofits those things. if you are doing it inside the program, you use libreadline (or libedit or haskeline or linenoise or ...) directly
13:13:17 <hpc> it's a good type for learning just how far you can go with storing functions in data
13:14:15 <geekosaur> importantly, rlwrap does not have access to what the program is actually doing, only to its outputs and your inputs; it has to guess a lot, and can guess wrong
13:14:58 <geekosaur> which is why programs actually use readline or etc. directly so they can e.g. tell it what completions make sense at any given prompt
13:15:54 <joncol> Are you talking about the GNU Readline library?
13:19:00 * hackagebot mmorph 1.0.9 - Monad morphisms  https://hackage.haskell.org/package/mmorph-1.0.9 (GabrielGonzalez)
13:19:39 <c821> anyone knows about the caesar cipher in haskell?
13:19:57 <Tuplanolla> What is there to know, c821?
13:20:45 <c821> i have a homework about it, now it works with lowercase letter only, but i don't know how to make it work with uppercase letter
13:21:29 <lordcirth> c821, well how are you doing it now?
13:21:45 <c821> http://pastebin.com/j8bnb5vk can you take a look at it
13:23:02 <grantwu> Please use lpaste or gists in the future
13:23:20 <hpc> does pastebin still have those fullscreen ads and stuff?
13:23:26 * hpc noscripts and can't see it
13:23:35 <jedai> c821: That doesn't seem to be a problem...
13:23:48 <diogotito> @pl (\(a,_) (b,_) -> a == b)
13:23:48 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
13:23:49 <hpc> someone here had an autoresponder in their client that repasted on lpaste, it was so bad
13:23:51 <lordcirth> I have adblock.  But it does screw up the syntax highlighting completely
13:24:13 <jedai> c821: your let2bin should be called lcLetter2Int, that's all... :(
13:24:42 <jedai> c821: also you need another case in your shift
13:24:52 <Stuart> Hi
13:25:04 <Stuart> I want to install package Text.Trifecta
13:25:12 <MarcelineVQ> :t (==)`on`fst -- diogotito
13:25:12 <Stuart> how do I do it
13:25:14 <lambdabot> Eq a => (a, b) -> (a, b) -> Bool
13:25:15 <hpc> that's a module, the package is trifecta
13:25:21 <fnurglewitz> Stuart, do you use stack?
13:25:30 <Stuart> Not a lot
13:25:37 <c821> what should i add to make it work with uppercase?
13:25:48 <Stuart> stack is on my computer
13:25:53 <fnurglewitz> Stuart, with stack it's simple as "stack install trifecta"
13:26:58 <Stuart> Thanks for that
13:27:06 <fnurglewitz> Stuart, are you reading bitemyapp's haskellbook?
13:28:40 <sm> @quote paste:
13:28:41 <lambdabot> FAQ says: paste: Paste long things at a paste site. http://lpaste.net highlights and lints haskell and announces to this channel.
13:28:44 <Stuart> Yes fnurglewitz
13:28:47 <Stuart> Compiler version mismatched, found ghc-8.0.1 (x86_64), but expected minor versio
13:28:48 <Stuart> n match with ghc-7.10.3 (x86_64) (based on resolver setting in C:\Users\stuart\A
13:28:51 <Stuart> I am getting this
13:28:54 * sm added this earlier ^
13:28:57 <diogotito> Oh, thank you for pointing me out the `on` function, @MarcelineVQ (first time writing on a IRC chat ever)
13:29:00 * hackagebot socket-sctp 0.2.0.1 - STCP socket extensions library.  https://hackage.haskell.org/package/socket-sctp-0.2.0.1 (shlevy)
13:29:11 <fnurglewitz> hm
13:29:40 <Stuart> fnurglewitz seems it was built under a older version
13:29:50 <MarcelineVQ> diogotito: it's in Data.Function if you're looking for it
13:30:11 <fnurglewitz> Stuart, I had many problems with the haskell platform and stack on windows too
13:30:31 <fnurglewitz> Stuart, I'm a newbie too and couldn't resolve them :/
13:30:48 <fnurglewitz> Stuart, I found out that on linux everything worked better
13:31:13 <jedai> fnurglewitz: Note that you're not supposed to be using those two together (you can but that's not a good idea)
13:31:41 <fnurglewitz> jedai, understood, probably that was my error
13:31:47 <hvr> fnurglewitz: to be fair, majority of Haskell hackers work on Linux and OSX
13:31:49 <jedai> You should just use stack, it will install the version(s) of GHC necessary
13:32:06 <fnurglewitz> jedai, so this could be Stuart's problem?
13:32:21 <hvr> fnurglewitz: so there's less users contributing fixes to Windows-specific issues
13:32:44 <jedai> fnurglewitz: I still ran into some problems in the past with funky paths (with non ASCII characters) but outside of that, it's working really well
13:32:51 <jedai> fnurglewitz: Maybe
13:33:27 <Stuart> Hmmm, ok, the error message says it's the wrong verson of gchi
13:34:00 * hackagebot plots 0.1.0.2 - Diagrams based plotting library.  https://hackage.haskell.org/package/plots-0.1.0.2 (cchalmers)
13:34:30 <jedai> Stuart: if you're installing things with stack, use "stack ghci" rather than just ghci
13:34:46 <MarcelineVQ> also run `stack setup` if you haven't ever done that
13:34:56 <Stuart> I am running stack setup 
13:35:00 <younder> Should't stack install the right ghc version?
13:35:06 <Stuart> whata does stack gchi do?
13:35:38 <Stuart> How does Haskell deal with versions. 
13:35:52 <jedai> Stuart: it run the right ghci for your installation of stack (more precisely the resolver in the "global-project" of stack)
13:36:58 <Stuart> Can you have different packages build under different ghci versions running the in the same program
13:37:26 <jedai> Stuart: No
13:37:58 <jedai> Stuart: at least not with different major versions of ghc
13:39:00 <jedai> Stuart: stack take care of this by using a subset of all packages and versions that is known to work together well (you chose the exact subset by using different resolver)
13:40:39 <Stuart> ok cheers, hopefully this works
13:49:01 * hackagebot dhall 1.0.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.0.0 (GabrielGonzalez)
13:53:16 <clmg> why is (a*a) faster than (a^2)?
13:53:57 <lordcirth> clmg, I would guess because ^ is a function that does general exponents, and * is multiplication
13:53:57 <Tuplanolla> Do you have optimizations turned off, clmg?
13:54:04 <lordcirth> But I'd bet that -O2 would fix that
13:54:06 <clmg> Tuplanolla: nope
13:54:11 <clmg> lordcirth: -O2 is on
13:54:27 <Tuplanolla> Does `2` default to `Integer`, clmg?
13:54:46 <lordcirth> oh yeah, is there only 1 type it can be?
13:55:14 <clmg> Tuplanolla: it does
13:55:17 <Tuplanolla> Change it to `Int` and try again, clmg.
13:55:43 <clmg> Tuplanolla: slightly faster, but nowhere as fast as a*a
13:55:43 <geekosaur> what type is `a`? if it's Int, that compiles to a hardware level multiplication. if it's Integer, everything goes through libgmp and the multiplication path is probably faster than the exponentiation path (and in any case we may be doing the exponentiation at Haskell level, potentially adding overhead)
13:56:27 <clmg> geekosaur: a is an Integer, yeah. that makes sense, I guess
13:56:31 <clmg> seems a little odd to me
13:56:49 <lordcirth> unbounded numbers are a bit odd
13:56:51 <clmg> it's about 3x slower in my code
13:57:08 <Tuplanolla> I would've expected there to be some addition chain rewrite rules for this.
13:57:29 <geekosaur> in theory the compiler could detect it's the same thing and substitute the faster code. C compilers often do this. Haskell compilers generally don't, because there are so many extra complications introduced by polymorphism etc.
13:57:43 <clmg> geekosaur: ah
13:58:30 <geekosaur> but someone probably could introduce RULES pragmas specifically for e.g. Int that would do it, they just haven't because nobody's really felt the need or etc. (I mean, if you want ultimate speed, a higher level language like Haskell is not going to be someone's first choice)
14:00:41 <clmg> something about "ultimate speed" remains compelling to people despite all pragmatic implications
14:01:39 <lordcirth> All else being equal, more speed is obviously good.  it's just a matter of how much it's worth to you.
14:02:52 <ertesx> i noticed (x^2) being slower than (x*x) in the past and suspect that it's because (^) is complicated enough that it may not be inlined
14:03:08 <ertesx> if it's inlined, all kinds of rewrite rules should kick in and optimise it to x*x
14:03:31 <ertesx> therefore i would try something like forced inlining or -funfolding-use-threshold=1000
14:04:52 <Tuplanolla> Squaring is so common I usually define `sq` for it.
14:05:08 <clmg> lordcirth: not always. if it takes you 100x longer to simplement something 2x faster, is it worth it?
14:05:15 <lordcirth> I suspect a specific rule for x :: Int x^2 = x*x might be worthwhile, but you couldn't just do it in a preprocessor, you'd need to understand types
14:05:15 <clmg> lordcirth: I guess if you're making video games
14:05:28 <grantwu> clmg: That's not all else being equal
14:06:08 <clmg> grantwu: ha ha you're right. but can implementation time ever be equal?
14:06:22 <lordcirth> clmg, if you take 100 hours instead of 1 to write a thing (extreme example btw) and it runs on $100M worth of hardware instead of $200M for 5 years, yes.
14:06:50 <younder> I find that for just doing simple calulations Mathematica is faster. For using something like Haskell it has be be a compliated task.
14:07:01 <lordcirth> you write code once, you run it many times
14:07:36 <ertesx> actually i just tested the following piece of code:
14:07:44 <ertesx> main = map read <$> getArgs >>= mapM_ (\x -> print (x*x :: Integer))
14:07:50 <ertesx> whoops
14:07:58 <ertesx> main = map read <$> getArgs >>= mapM_ (\x -> print (x^2 :: Integer))  -- this one
14:08:04 <ertesx> it does get turned into x*x
14:08:08 <ertesx> according to core
14:08:15 <lordcirth> Interesting
14:08:23 <ertesx> $w$cshowsPrec3 0# (timesInteger x_a4Tv x_a4Tv) []
14:08:52 <clmg> ertesx: interesting. maybe different haskell version?
14:08:53 <ertesx> same thing with Int
14:08:59 <clmg> ghc*
14:09:03 <ertesx> clmg: GHC 8.0.1 with -O
14:09:18 <ertesx> Int version: $wshowSignedInt 0# (*# x1_a5pM x1_a5pM) []
14:09:19 <clmg> hmmm same
14:09:25 <lordcirth> is -O = -O1 ?
14:09:38 <ertesx> lordcirth: yeah, the usual optimisation level of GHC
14:09:47 <grantwu> When does it make sense to pick LLVM vs the C-- backend?
14:10:01 <grantwu> er, the C backend
14:10:13 <ertesx> grantwu: you mean the native backend (the C backend isn't really in use anymore)
14:10:19 <clmg> is GHCi -fobject-code -O2 different from ghc -O2 ?
14:10:39 <ertesx> grantwu: LLVM handles arrays very well, so if you're doing a lot of mutable array stuff, LLVM is worth trying
14:10:44 <ertesx> clmg: yes
14:10:51 <Lokathor> :t (<*)
14:10:53 <lambdabot> Applicative f => f a -> f b -> f a
14:10:55 <grantwu> The native backend, sorry
14:11:17 <clmg> ertesx: that's gotta be it then
14:12:13 <grantwu> Hrm... I guess I could always just benchmark
14:12:58 <younder> Any good way to set up emacs for litterate haskell?
14:14:52 <ertesx> another interesting observation:  if you do this:  (let pow = (^); {-# NOINLINE pow #-} in …) and use 'pow' instead of (^), then it uses the exponentiation algorithm instead of just multiplication
14:15:12 <ertesx> so inlining is important
14:15:41 <ertesx> younder: haskell-mode has a literate mode that is used automatically for *.lhs files
14:17:21 <younder> ertesx, Not with my setup it seems to default to tex.
14:19:19 <younder> ertesx, Mayby I should setup mmm-mode. Well later, it is getting late here
14:19:37 <ertesx> younder: well, do you want to use tex-mode for the non-haskell part?
14:19:51 <ertesx> (i'm assuming AUCTeX
14:20:12 <younder> ertesx, That get the syntax highlighting right (yes AUCTEX)
14:21:41 <ertesx> younder: mmm could work, yeah (i tried it once, but didn't really like it)…  alternatively you could switch workflows: use markdown and pandoc it to tex/latex
14:22:14 <ertesx> (pandoc even supports markdown straight to PDF)
14:23:19 <Koterpillar> ertesx: "straight" is not an accurate description of that Pandoc part
14:24:41 <younder> ertesx, Ok, Just installed pandoc via MELBA , so I'll see how that works.
14:24:59 <ertesx> younder: huh?  pandoc is a command line utility
14:25:45 <ertesx> https://pandoc.org/
14:26:15 <younder> well it comes with a pandoc and pandoc-mode
14:26:31 <younder> anyhow installed the command line utillity as well
14:28:17 <ertesx> younder: i don't know what pandoc-mode is…  the workflow i had in mind is:  use literate-haskell-mode for editing and perhaps write a Makefile to turn *.lhs into *.tex (or let pandoc do the plumbing and tell it to give you a PDF)
14:30:30 <ertesx> younder: https://pandoc.org/MANUAL.html#literate-haskell-support
14:38:18 <kuribas> > sum [a, b, c, d]
14:38:20 <lambdabot>  0 + a + b + c + d
14:38:31 <kuribas> what's the library again that supplies these symbols?
14:38:35 <Koterpillar> :t a
14:38:37 <lambdabot> Expr
14:38:51 <Koterpillar> a :: Int
14:38:53 <Koterpillar> > a :: Int
14:38:56 <lambdabot>  error:
14:38:56 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Expr’
14:38:56 <lambdabot>      • In the expression: a :: Int
14:39:04 * hackagebot semiring-num 0.4.0.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.4.0.0 (oisdk)
14:39:04 <Koterpillar> sorry, I thought that'd give the qualified name
14:39:06 <Koterpillar> @src a
14:39:06 <lambdabot> Source not found. Just try something else.
14:39:12 <Lokathor> ertesx, you can write a .tex file directly, and then put your haskell in \begin{code} and \end{code} blocks, as i recall, and then ghc can read it that way
14:39:46 <MarcelineVQ> Koterpillar: https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect.html
14:39:49 <Lokathor> or, perhaps that should go to younder 
14:39:57 <MarcelineVQ> *also kuribas
14:40:04 <Koterpillar> thank you
14:40:49 <kuribas> MarcelineVQ: thanks
14:51:28 <mniip> ugh
14:51:48 <mniip> how am I supposed to setrlimit ghci if it maps 1 terabyte of virtual memory
14:52:13 <ertesx> is there a variant of -ignore-dot-ghci that only ignores the user-wide .ghci?
14:54:10 <Tuplanolla> Pass `+RTS -M512M -RTS`, mniip.
14:56:44 <mniip> well
14:58:04 <mniip> even if I ask for a 256M heap it still allocates 450M virtual memory
14:59:00 <geekosaur> mniip, it doesn't map that
14:59:05 <geekosaur> it allocates page tables for it
14:59:12 <geekosaur> almost none of it maps to actual pages
14:59:25 <dxtr> Yeah, isn't this a Linux thing?
14:59:56 <geekosaur> this is something that both linux and windows know how to do, but most programs don't manage their memory that way
15:00:05 <grantwu> There was RLIMIT_RSS, but it seems like that doesn't work anymore....
15:00:08 <dxtr> Like.. Virtual memory on Linux is just imaginary mumbo jumbo?
15:00:41 <ogkloo> 57
15:00:46 <ogkloo> oop sorry
15:00:57 <grantwu> *blinks*
15:01:03 <grantwu> Virtual memory is definitely a thing.
15:01:06 <geekosaur> dxtr, http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#runtime-system
15:01:06 <mniip> mmap(0x200000000, 1099512676352, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0) = 0x200000000
15:01:09 <mniip> it totally maps that
15:01:21 <geekosaur> this is not the same as basic linux virtual memory
15:01:39 <mniip> sure thing
15:01:44 <dxtr> mniip: I think the key here is MAP_NORESERVE
15:01:49 <geekosaur> MAP_NORESERVE says don't actually map it
15:02:23 <geekosaur> if you continue the trace you will see it actually mapping and releasing individual pages within that address space
15:02:23 <mniip> well it reserves a place in the virtual address space
15:02:39 <mniip> so that pages can appear of thin air when you read or write a location in there
15:02:47 <geekosaur> ok, please everyone pay no attention whatsoever to the release notes I just pointed to
15:02:55 * grantwu clicks release notes
15:03:06 <dxtr> "Do not reserve swap space for this mapping.  When swap space is reserved, one has  the  guarantee that it is possible to modify the mapping.  When swap space is not reserved one might get SIGSEGV upon a write if  no  physical  memory  is  available."
15:03:27 <grantwu> geekosaur: hrm.... what is wrong with them?
15:03:47 <mniip> if only there was an rlimit that let me limit the memory actually used by ghci
15:04:31 <dxtr> mniip: What about RLIMIT_DATA?
15:04:56 <dxtr> The  maximum size of the process's data segment (initialized data, uninitialized data, and heap).
15:05:17 <mniip> that sounds like it would only affect the program break
15:05:39 <mniip> (is the program break even used nowadays?)
15:06:02 <dxtr> program.. break?
15:06:56 <dxtr> Also, is it *actually* ghci that mmaps that memory and not glibc or something?
15:07:26 <dxtr> I don't know enough Linux to give a definitive answer here - I'm just brainstorming
15:07:46 <dxtr> Have you actually tried RLIMIT_AS?
15:07:49 <mniip> yes
15:08:17 <dxtr> Why are you so concerned about the virtual memory, by the way?
15:08:21 <mniip> oh
15:08:30 <mniip> I tried it with 256M, with 512M it appears to work?
15:08:50 <mniip> dxtr, running other people's code on my machine
15:08:56 <mniip> would be a shame if something happened to it
15:09:41 <ertesx> mniip: which rlimit do you want to set?
15:09:55 <mniip> ?
15:10:10 <mniip> that's kind of the question I am asking
15:10:17 <dxtr> I'm still not sure I understand why you are so concerned about the virtual memory
15:10:28 <lordcirth> mniip, LXC container with memory limit, if you're running other people's code.  VMs, if you don't trust them.
15:10:47 <dxtr> To me RLIMIT_DATA sounds like what you want
15:11:14 <mniip> dxtr, reading the manpage suggests that RLIMIT_DATA doesn't affect mmap at all
15:11:37 <mniip> "The maximum size of the process's data segment (initialized data, uninitialized data, and heap). This limit affects calls to brk(2) and sbrk(2), which fail with the error ENOMEM upon encountering the soft limit of this resource."
15:11:59 <geekosaur> it doesn't, and it shouldn't. do you really want it to apply to every shared library too?
15:13:13 <grantwu> What is the "proper" way to limit the amount of committed memory for a ghci process?
15:14:02 <dxtr> ulimit?
15:15:17 <ertesx> grantwu: the *modern* proper way on linux?  cgroups
15:15:42 <ertesx> maybe i'm blind to something, but i consider rlimits legacy
15:15:50 <dxtr> Oh yeah. Or cgroups if you wanna be fancy :P
15:16:02 <ertesx> not fancy, just modern
15:16:08 <dxtr> "modern"
15:16:29 <geekosaur> rlimits largely are legacy; they don't really handle things like shared objects that map r/o and sometimes r/w segments above the heap
15:17:02 <lpaste> byorgey pasted “multirec error: empty list with foldr1” at http://lpaste.net/344184
15:17:31 <byorgey> if anyone has experience using multirec, can you see anything I'm doing wrong in the example linked above?
15:18:17 <dxtr> ertesx: Why does everything that's "modern" have to be such a hassle? :/
15:19:05 * hackagebot semiring-num 0.5.0.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.5.0.0 (oisdk)
15:19:11 <lordcirth> dxtr, because modern means more features
15:19:40 <dxtr> and "more features" equals "Make it practically unusable"?
15:20:13 <dxtr> This seems to be mainly a Linux issue
15:20:24 <lordcirth> dxtr, no, more features means more buttons, inevitably
15:20:29 <ertesx> dxtr: mostly because distributions don't handle them properly, and systemd's "one thing to rule them all" power complex doesn't exactly help either
15:20:40 <lordcirth> Also, cgroups aren't exactly intended for the end user to see
15:20:41 <ertesx> yes, systemd wants to rule over cgroups, too
15:21:03 <ertesx> cgroups are actually super-simple, if you ignore all that non-sense people have built around them
15:21:12 <Tuplanolla> How about XKB?
15:21:33 <dxtr> lordcirth: And therefore configuration has to be a nightmare?
15:21:47 <grantwu> dxtr: I think it might be a Linux issue.
15:21:49 <dxtr> ertesx: Right
15:22:02 <lordcirth> I've never needed to work with cgroups directly.  'lxc launch'
15:22:06 <dolio> It doesn't look significantly more difficult to configure than limits.
15:22:24 <grantwu> ZFS is more featureful than many Linux filesystems.  But it's also easier, at least for me, to use.
15:22:36 <ertesx> lordcirth: that's already cgroups in the context of isolation…  cgroups work pretty much exactly like rlimits
15:22:54 <grantwu> Solaris zones were a thing for a long time as well.
15:23:38 <lordcirth> ZFS, while excellent, breaks a ton of conventions and does it's own thing, because it wasn't made for Linux.
15:24:00 <ertesx> btrfs does that, too, and i'm glad it does
15:24:00 <lordcirth> Obviously you need to break some rules to handle multiple layers, though
15:24:07 <ertesx> nix does that, too, and i'm glad it does
15:24:08 <ertesx> =)
15:24:34 <lordcirth> In general yes, but btrfs mounts properly in fstab rather than automounting in /
15:24:54 <ertesx> ah, yeah, i don't have any experience with ZFS
15:25:06 <lordcirth> ertesx, do you use Nix a lot?
15:25:24 <ertesx> lordcirth: yeah
15:25:42 <lordcirth> ertesx, what for, and on what distro?
15:26:10 <dxtr> I am a HUGE proponent of the unix philosophy but I am secretly jerking off to the volume management in both zfs and btrfs
15:26:45 <lordcirth> dxtr, I don't think that btrfs really breaks the unix philosophy, just conventions
15:26:56 <ertesx> lordcirth: as a package manager, deployment system, for building containers and for what cabal new-build/stack do
15:27:04 <lordcirth> It does one thing - provides a filesystem to store data on.  And it does it well.
15:27:07 <ertesx> lordcirth: in other words: it's pretty much everywhere
15:27:26 <lordcirth> ertesx, I did not realize it was so flexible
15:27:29 <dxtr> lordcirth: It doesn't do one thing, though
15:27:37 <ertesx> lordcirth: well, btrfs has "RAID" support, too =)
15:27:42 <ertesx> so it does violate unix
15:27:54 <larryba> @hoogle Int -> [a] -> [[a]]
15:27:55 <lambdabot> Data.List.Split chunksOf :: Int -> [e] -> [[e]]
15:27:55 <lambdabot> Data.List.Split.Internals chunksOf :: Int -> [e] -> [[e]]
15:27:55 <lambdabot> Data.List.HT sliceHorizontal :: Int -> [a] -> [[a]]
15:28:00 <dxtr> ertesx: To be fair btrfs doesn't to raid well :p 
15:28:09 <larryba> wasn't there a function like chunksOf in prelude?
15:28:10 <dxtr> It's horribly broken and it even says on the btrfs to not use it
15:28:15 <ertesx> dxtr: that was a nice way to put it
15:28:19 <ertesx> i would say: it sucks at RAID
15:28:36 <dxtr> on the btrfs wiki*
15:28:42 <geekosaur> you can do raid without the filesystem knowing about it. the result will perform worse than when the filesystem does know about it and can work with instead of against it
15:28:46 <lordcirth> ertesx, I think that's a matter of interpretation.  Every tool does multiple "things", in some sense.
15:28:50 <systemfault> I don't know ZFS much... but isn't saying that it violates unix (ZFS comes from Solaris which is a unix while Linux isn't) a bit weird :/
15:28:55 <geekosaur> which is the theory behind zfs (and where btrfs might be if it ever grows up)
15:29:10 <grantwu> So uh, getting back to haskell
15:29:12 <ertesx> the thing is: linux does RAID so well that i can't imagine when i would even go for filesystem-level RAID
15:29:13 <systemfault> I'm clueless so what I just said might sound stupid.
15:29:13 <lordcirth> geekosaur, tools can be made on Unix which defy Unix philosophy
15:29:27 <lordcirth> systemfault, *
15:29:34 <systemfault> Ah ok
15:29:53 <lordcirth> ertesx, the filesystem being aware of RAID makes things more efficient
15:30:17 <ertesx> lordcirth: there is a difference between being aware of RAID and *doing* RAID
15:30:42 <ertesx> and again: check out linux MD-RAID, and you will never need/want anything else
15:30:45 <grantwu> Never mind, I forgot something
15:30:57 <grantwu> ertesx: ZFS RAID rebuilds are far faster than mdraid
15:30:58 <lordcirth> ertesx, MD-RAID checksums every block like ZFS does? when?
15:31:04 <grantwu> And they avoid the write hole problem.
15:31:10 <ertesx> grantwu: i'd challenge that
15:31:18 <ertesx> grantwu: you probably just forgot to add a bitmap =)
15:31:35 <lordcirth> mdraid, like hardware raid, protects against whole drives failing politely
15:31:42 <grantwu> ertesx: ...?  I've rebuilt a 4 disk raid in 2 minutes.
15:31:44 <ertesx> lordcirth: that's not a thing RAID is supposed to do…  btrfs does that
15:32:06 <ertesx> grantwu: ah, you mean with new disks…  then yeah
15:32:09 <grantwu> Because ZFS rebuilds are O(allocated memory) not O(disk)
15:32:17 <lordcirth> ertesx, btrfs checksumming everything doesn't help if the data is only in one place
15:32:43 <grantwu> Anyways, does anyone know what triggers GHC emitting stuff from -ddump-deriv in errors with deriving?
15:32:45 <lordcirth> ertesx, it only tells you that it's broken, it can retry and hope it works, but btrfs storing it raid1 lets it autofix
15:33:16 <grantwu> Seems to be when it recurses more than once wrt deriving?
15:33:22 <grantwu> The error messages are certainly unfriendly
15:34:05 * hackagebot semiring-num 0.5.1.1 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.5.1.1 (oisdk)
15:34:08 <grantwu> http://lpaste.net/4021700358274285568 I guess I ought to be able to tell just from the first line of each error
15:34:25 <ertesx> lordcirth: i'd generally go for a setup where btrfs never has to see that happening, but yeah, let's return to haskell
15:34:51 <sm> epic digression!
15:35:01 <kuribas> > over reversed tail "abcde"
15:35:05 <lambdabot>  "abcd"
15:35:27 <ertesx> "over reversed"?  so reversed that it's itself again? =)
15:35:38 <mniip> dammit lens
15:35:50 <monochrom> that is philosophically deep :)
15:35:55 <mniip> doing magic and whatnot
15:37:28 <kuribas> :t reversed
15:37:30 <lambdabot> (Reversing a, Profunctor p, Functor f) => p a (f a) -> p a (f a)
15:40:03 <_d0t> hi. Is there a way to disable redundant constraint warning for a specific function in ghc-8?
15:41:24 <dxtr> How would I merge two XML trees using xml-conduit?
15:42:29 <dxtr> I still haven't gotten into the functional mindset regarding complicated data structures
15:43:18 <ocramz> hullo all
15:43:44 <ocramz> is anybody aware of a fast intersection operation for sorted Vector ?
15:44:07 <suzu> ocramz: mergesort?
15:44:24 <larryba> is there a preferred style? func :: Class a => a -> a  or  func :: (Class a) => a -> a
15:45:47 <Tuplanolla> :t 2
15:45:48 <lambdabot> Num t => t
15:45:56 <Tuplanolla> There's your answer, larryba.
15:46:19 <ocramz> suzu : I don't understand, isn't mergesort a sorting algorithm for a single array? I'm looking for the intersection of two arrays
15:46:27 <suzu> right
15:46:28 <monochrom> there are two preferred styles. :)
15:46:32 <suzu> now if you have two sorted lists
15:46:47 <suzu> there exists an algorithm for finding the intersection, by doing a very mergesort-like operation
15:47:00 <larryba> parens are redundant, but then again it seems easier to spot them than =>
15:47:41 <mniip> if you use ghci you should have learned to look for the =>
15:47:48 <mniip> see Tuplanolla's point above
15:49:06 * hackagebot semiring-num 0.5.2.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.5.2.0 (oisdk)
15:49:19 <ocramz> suzu : I'm specifically looking for one that minimizes consing. I am considering writing into a MVector, but I don't know what's worse, to preallocate conservatively and then trim at the end, or to cons for O(N) at every iteration
15:49:47 <ertesx> ocramz: use 'create'
15:50:24 <joe9> can anyone please help? I cannot figure out this error message: source https://github.com/joe9/GenericPretty/blob/master/src/Text/PrettyPrint/GenericPretty.hs#112 error message: http://codepad.org/KNmge7Ay
15:50:36 <ertesx> ocramz: alternatively you can use generateM with a state monad
15:51:30 <ertesx> ocramz: actually the latter is equivalent to using unfoldrN
15:51:36 <ertesx> that may be the best option
15:51:59 <ocramz> ertesx: thanks for the tips
15:52:43 <ocramz> but both generateM and unfoldrN require the vector size, IIUC
15:53:03 <ocramz> which, in the case of a set operation, is not known until the end
15:53:04 <ertesx> ocramz: the source vector lengths are known
15:54:03 <ertesx> V.unfoldrN (V.length xs + V.length ys) _merge (0, 0)  -- either like this
15:54:26 <ertesx> V.unfoldrN (V.length xs + V.length ys) _merge (xs, ys)  -- or like this (V.tail instead of incrementing indices)
15:55:51 <ertesx> ocramz: oh, you want no duplicates
15:56:19 <ertesx> i'd still do conservative allocation, potentially with a V.force at the end
15:57:46 <ocramz> ertesx: yep, understood. Thanks a lot!
15:57:47 <kuribas> > review (base 36) 6611117533019309029324227868328374036
15:57:49 <lambdabot>  "allyourbasearebelongtous"
15:58:08 <larryba> is MonadRandom the way to go for random numbers in haskell
15:58:11 <ocramz> kuribas: wat
15:58:24 <kuribas> lol
15:58:31 <suzu> :t review
15:58:32 <lambdabot> MonadReader b m => AReview t b -> m t
15:58:53 <Axman6> larryba: that might depend on what sort of randomness you wanty, if you want cryptographicly random numbers, then no, but otherwise it should be fine
15:58:53 <ocramz> larryba : not necessarily, look at mwc-random
15:59:32 <kuribas> ocramz: it's a base 36 number
15:59:47 <larryba> dang, just as i learned how to use MonadRandom i find out about mwc-random
16:00:06 <ertesx> larryba: there is no universally agreed upon way to go, and MonadRandom is mostly useful in case you have other state in your monad stack
16:00:35 <larryba> I don't need crypto-safe random numbers. i like how in MonadRandom i can use same random code to generate random numbers in IO and non-IO
16:00:40 <ertesx> and mwc-random, potentially the fastest generator on hackage, is incompatible with it, because it uses mutability
16:00:57 <larryba> I see
16:01:56 <hexagoxel> _d0t: no, according to https://ghc.haskell.org/trac/ghc/ticket/10635#comment:6
16:01:57 <larryba> can mwc-random do the same? re reusing same code for non-IO and IO random numbers
16:02:24 <ertesx> larryba: mwc-random needs IO or ST to be the base monad, but it uses the 'primitive' library, so there is no lifting necessary
16:02:34 <ocramz> larryba yes it works in PrimMonad
16:03:10 <_d0t> hexagoxel: well, this is bad
16:04:07 * hackagebot semiring-num 0.5.3.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.5.3.0 (oisdk)
16:05:27 <joe9> Can anyone please help with this error message: http://codepad.org/Us9GYdas source is http://dpaste.com/0SCTDBH line 112 is the definition
16:09:07 * hackagebot semiring-num 0.5.3.1 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.5.3.1 (oisdk)
16:09:13 <hexagoxel> _d0t: not much worse than the warning being in -Wall in the first place..
16:10:14 <younder> Wouldn't  you just use piccle to save/load objects?
16:10:25 <MarcelineVQ> byorgey: It's a library bug, their own example TH code from http://hackage.haskell.org/package/multirec-0.7.6/src/examples/ does not compile with the same error you have
16:10:48 <MarcelineVQ> *and has the same error
16:10:49 <byorgey> MarcelineVQ: thanks for confirming
16:11:17 <byorgey> my own experiments seem to show it is specific to GHC 8.0.  My code works with 7.10.3.
16:11:35 <byorgey> or perhaps it's really specific to whatever version of template-haskell comes with GHC 8.0.
16:11:39 <MarcelineVQ> Possibly a change in the TH AST types then
16:11:55 <_d0t> hexagoxel: well, i got old code that doesn't build with -Wall now
16:12:00 <_d0t> because of that warning
16:12:11 <MarcelineVQ> While experimenting I also had a non-exhaustive pattern error which would most likely have been caused by such a change
16:12:31 <hexagoxel> _d0t: so disable per-module, guarded behind ghc version check
16:12:58 <_d0t> thats what i did
16:13:07 <hexagoxel> or per package if CPP is to be avoided
16:13:32 <_d0t> but imagine i have multiple definitions in a single module some of which could benifit from this warning
16:16:58 <hexagoxel> _d0t: yes i agree; in general i assume this downside is well-known to those involved.
16:17:31 <hexagoxel> the only constructive path is to work on the referenced issue for more localized warning suppression.
16:18:54 <larryba> i have two lists of 4 numbers, a desired sum, and I need to exchange one or more numbers from one list to another so that the sum of both lists is as close to the desired sum as possible. any help on the possible algorithm i can use for this? i could generate all possible lists, and then pick the closest one, but maybe there's a more intelligent way?
16:20:45 <spaceghost> I have a message for you clint.
16:20:47 <spaceghost> Be ready.
16:24:20 <Axman6> that's not a very descriptive message spaceghost, it is the nature of being human to be ready for lots of things
16:24:39 <spaceghost> Not clint that looks that have his queries closed.
16:24:45 <spaceghost> That he has.
16:25:50 <larryba> actually i don't even know how to use list monad to generate all the possible list combinations. hmm. can it be even used for this? intuitively i thought it could
16:27:12 <hexagoxel> larryba: how does the sum of sum change when you exchange elements?
16:27:15 <larryba> given [1,2,3,4] and [5,6,7,8], how to generate all the possible two lists where one or more elements is swapped between them?
16:28:18 <hexagoxel> or are those lists to represent digits of a (decimal?) number?
16:28:18 <larryba> hexagoxel i probably didn't explain it well, because there is no sum of sum
16:29:44 <larryba> I need to rearrange elements in such a way that the difference between desired sum and sum of each list is the smallest possible
16:30:05 <larryba> and each list has its own sum
16:30:28 <larryba> does that make sense?
16:31:23 <larryba> so if sum is 5, i need to rearrange those lists that, ideally, they both result in 5 when summed. or, if that can't be done, to have the smallest possible difference between 5 and sum that is further away from 5
16:32:10 <hexagoxel> so you need either sum become as close as possible to the other
16:32:22 <larryba> yes
16:33:49 <hexagoxel> well then calculate current delta and possible deltas
16:34:07 <larryba> can list monad be used to generate all possible two lists, given their elements?
16:34:43 <jval> how do you use a value wrapped in an EitherT, I know that you use runEitherT but I can't figure out how to pattern match on it w/o getting type errors
16:36:16 <larryba> hexagoxel i need to generate all possible list pairs for that?
16:36:56 <hexagoxel> larryba: my suggestion is not necessary the easiest solution. generating all lists seems possible too. i probably would start with defining a simple recursive function that does the job, especially if you are unsure what abstraction are applicable.
16:37:07 <hexagoxel> and i am not sure myself if list monad can be used.
16:37:31 <alexknvl> Does anyone know if there is a standard name for Monad m => m a -> (a -> m b) -> m a? Hoogle doesn't find anything similar.
16:37:59 <larryba> hexagoxel how many possible lists are there?
16:38:26 <hexagoxel> jval: like you "use" a value in any monad, probably (?)
16:38:28 <larryba> now that i think about it, there are way to many, and considering that this is just part of the algorithm maybe brute forcing it will be inefficient
16:39:49 <larryba> i actually have a list of arbitrary number of 4 elements, and i need to swap elements from any list, to any list, to get all lists as close as possible. the way i was thinking was to sort by sum, then use the largest sum difference (which would be first and last element), and then get that one as close as possible. and repeat, until the generated largest delta is greater than the average compared to the last generated one
16:39:55 <larryba> way too inefficient?
16:41:50 <alexknvl> jval once you runEitherT, you get m (Either e a) back, so in order to pattern match on it you would have to either a) match m b) fmap c) >>=
16:43:01 <larryba> hmm, maybe i should just flatten the list, sort it, and then make a group of 4 by picking two smallest numbers and two largest numbers.. should be a close enough aproximitation
16:43:23 <larryba> approximation(
16:44:09 <alexknvl> jval you can also bimap as long as you just need to transform "both sides" of your Either
16:49:09 * hackagebot tabl 0.1.0.0 - Table layout  https://hackage.haskell.org/package/tabl-0.1.0.0 (lovasko)
16:50:06 <jval> alexknvl: ok. Also I should probably back up an explain I'm using a library that uses the pipes library (sdr), and there is a Producer-like function (sdrStream) I am trying to connect together with a Pipe using >->, but it returns an EitherT String IO (Producer blah blah) and I'm not sure how to use pipes related functions that are wrapped up in an EitherT
16:51:33 <jval> alexknvl: I get that the idea is that the EitherT models failure for the Producer/Consumer/Pipe/etc
16:54:53 <larryba> did I lose everyone? :). i will try explaining it again. I have a list of numbers and I need to group them in a group of 4 so that the difference between the smallest and the largest sum of all the groups is as small as possible
16:55:06 <hexagoxel> jval: maybe you need combineInitTrans?
16:55:53 <hexagoxel> larryba: it seemed like you had a sufficient solution. we cannot tell if it is sufficient though :p
17:01:54 <alexknvl> jval hexagoxel that would push the failure (and IO) inside the pipe, which might not be ideal.
17:10:36 <joe9> Can anyone please help me with this error message: http://codepad.org/RnFMR3nR . source http://dpaste.com/3TSZVPA , I cannot figure it out and is driving me crazy.
17:12:58 <lordcirth> joe9, I think that means you have infinite recursion or something?
17:13:29 <joe9> lordcirth: I think it is the representation of the Generics. I am trying to write a simple fold function
17:13:48 <larryba> i think it means you have infinitely recursive type
17:14:00 <suzu> yes
17:14:10 <suzu> joe9 write a type signature for `prettyArgument`
17:14:14 <joe9> http://codepad.org/DgKsDyPU is what I want to do
17:14:31 <joe9> prettyArgument :: (GPretty a) => a -> [Doc]
17:14:38 <suzu> ok, put that into the source
17:14:40 <suzu> and recompile
17:14:43 <suzu> and you should get a better error this time
17:14:43 <joe9> is what I want it to be. but, I cannot get it to compile
17:14:56 <joe9> http://codepad.org/Hw0UU0RM
17:15:20 <joe9> I am not sure if a should be Rep a or some such thing.
17:15:55 <suzu> a is of kind * -> *
17:16:07 <suzu> it's not a concrete type
17:17:26 <joe9> http://codepad.org/l5CMbly0 suzu, When the type is :*:, I want to make a list of the arguments
17:17:57 <joe9> for example  1 :*: (5 :*: (4 :*: 3))
17:18:05 <joe9> I want to make it to [1,5,4,3]
17:18:40 <suzu> i think a Proxy might be what you need here at the type level
17:18:43 <alexknvl> data    (:*:) f g p = (f p) :*: (g p)
17:18:44 <joe9> and I cannot figure out the type signature to do that.
17:18:57 <alexknvl> joe9 it's not a product of *
17:19:01 <suzu> i dont know type-level programming very well
17:19:09 <alexknvl> :*: is a product of * -> *
17:19:24 <alexknvl> e.g. a product of two functor
17:19:28 <alexknvl> s
17:21:17 <alexknvl> 1 :*: (5 :*: (4 :*: 3)) this won't compile, but this (Just 1) :*: [2] should
17:21:58 <alexknvl> the resulting type will be (Maybe :*: []) Integer
17:23:22 <alexknvl> or something like that. might need to define an alias for List a = [a], I don't think [] as *->* would work
17:24:39 <joe9> alexknvl: Thanks. What should the type signature be for this, please? http://codepad.org/092XjS4d
17:24:53 <joe9> I have instances for Maybe x and [x] to Doc
17:26:49 <joe9> alexknvl: I think the Integer in this is Rec0 or Rec1 or some such, correct? "(Maybe :*: []) Integer"
17:27:09 <joe9> alexknvl: when using Generics, correct?
17:31:29 <alexknvl> consider your current signature prettyArgument :: (Generic a, GPretty (Rep a)) => a -> [Doc]
17:31:58 <alexknvl> here you know that a has to have instances for Generic and GPretty but the type itself can be anything
17:32:15 <alexknvl> i.e. if somebody came up with those 2 instances for Int, it should still work
17:32:42 <alexknvl> that means that you can not pattern match on it like this - prettyArgument (x :*: y)
17:33:33 <alexknvl> because you don't know that `a` is necessarily some `(:*:) b c p`
17:33:51 <joe9> alexknvl: How about ? prettyArgument (x p :*: y p) =
17:34:49 <alexknvl> that won't work because you can not pattern match on arbitrary x and y 
17:34:52 <surina> Combining higher order functions to do stuff is fricking hard. o_o
17:35:01 <alexknvl> I think you should define your prettyArgument inside a type class
17:35:21 <alexknvl> just like you already have gpretty
17:35:56 <hpc> surina: it's a way of thinking that definitely takes a bit of forcing yourself to use
17:36:00 <joe9> alexknvl:  I want to do it in the typeclass ideally. http://codepad.org/izM75jGp but, cannot figure out how to use fold in the type class instance.
17:36:28 <lgstate> is there any good guide on doing Backus Style Function *Level* Programming in Haskell?
17:36:28 <alexknvl> if it is outside a typeclass you can not assume anything about a, so you have to implement it in terms of what you know from your constraints (Generic a, GPretty (Rep a))
17:36:34 <hpc> surina: haskell's various language features and libraries approach it from enough directions that you can often learn some other neat thing and make things that much easier
17:36:36 <lgstate> I'm convinced this will make me  a better programmer,
17:36:41 <lgstate> but I can't seem to find any tutorials/guides on it
17:37:12 <joe9> alexknvl: was I clear on what I am trying to do? From the other examples, I see on the web, they are using other arguments to pass on the state.
17:37:24 <surina> hpc: True. I'm trying do this one exercise where you are required to use higher order functions and recursion is not preferable.
17:37:33 <joe9> alexknvl: Does that make sense?
17:37:51 <hpc> surina: ah yeah
17:38:00 <surina> I guess higher order functions make your life easier when you know how to use them
17:38:46 <hpc> a combination of knowing what is available in the standard library, how to use those, and how to write your own, yeah
17:39:09 <hpc> surina: if you know the type of the higher-order functions you need, check out hoogle
17:39:15 <hpc> @hoogle (a -> b) -> f a -> f b
17:39:18 <surina> hpc: Yeah, I have to use the ones from the standard library
17:39:19 <lambdabot> Control.Lens.Getter contramap :: (a -> b) -> f b -> f a
17:39:19 <lambdabot> Data.Functor.Compat fmap :: (a -> b) -> f a -> f b
17:39:19 <lambdabot> Data.Functor.Apply fmap :: (a -> b) -> f a -> f b
17:40:06 <alexknvl> joe9: I don't know much about Generics, so I am not entirely sure what you mean.
17:40:10 <hpc> unfortunately the standard library isn't something you can math out on your own, you actually have to remember what's in it ;)
17:41:21 <hpc> feel free to ask for help here if you get entirely stuck, and what it is for so we don't give any useless-for-learning spoilery answers
17:41:32 <surina> hpc: Yup. :D I remember many of the functions already but combining them is the most difficult part
17:42:03 <surina> Well I guess you could give me a hint
17:42:31 <surina> I'm doing the CIS 194 course, hm4 exercise 1
17:42:38 <surina> http://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
17:43:13 <surina> I guess I have to use filter there, maybe replicate
17:43:15 <hpc> the skips one?
17:43:19 <surina> yeah
17:45:08 <hpc> that looks like it's going to break down into a thing that doesn't really have a name, but "go functions" is as good of one as any
17:45:15 <hpc> which is where you do something like
17:45:27 <hpc> foo n = go "bananas" n 0
17:45:42 <hpc>   where go s n v = ...
17:46:05 <hpc> basically turning a simpler function into one with parameters that you need to write an easier function
17:46:17 <hpc> and that simpler function provides the initial values
17:46:21 <surina> but I don't have to use recursion?
17:46:33 <hpc> you'll definitely have to do a bit of it on your own
17:46:50 <hpc> but you can write it out as multiple functions
17:47:12 <surina> Yeah, I want to do this by myself
17:47:22 <hpc> it says in the problem that you're skipping every 'n' elements for n in [0 .. something]
17:47:35 <hpc> so perhaps start with a skipn that takes some 'n' and does stuff
17:47:43 <hpc> you'll probably have to repeat that technique a few times
17:47:43 <surina> True
17:48:18 <hpc> don't bother putting them in 'where' for this, but be aware when you're reading code on hackage that it often appears in that form
17:48:27 <julianleviston> What is ^ in haskell? The docs for lens are riddled with it, yet it doesn’t seem to be any kind of operator… 
17:48:31 <julianleviston> https://github.com/ekmett/lens
17:48:49 <surina> hpc: ok, thanks :)
17:48:57 <julianleviston> For example: :t ("hello","world") ^._2
17:48:58 <LordBrain> its a convention of lens
17:49:03 <julianleviston> yeah but what is it.
17:49:04 <dibblego> julianleviston: (^.)
17:49:11 <hpc> julianleviston: the operator name there is (^.)
17:49:12 <dibblego> @type (^.) -- <-- that
17:49:13 <julianleviston> Ahhh
17:49:14 <lambdabot> s -> Getting a s a -> a
17:49:14 <julianleviston> right
17:49:20 <julianleviston> thanks!
17:49:23 <hpc> julianleviston: and it's being applied to ("hello", "world") and _2
17:49:29 <lordcirth> julianleviston, it's an alias to 'view'
17:49:33 <julianleviston> yeah I thought it was :t ("hello","world") ^ . _2
17:49:34 <lordcirth> infix
17:49:47 <julianleviston> because there were no spaces, I didn’t know where one operator stopped and the other began… 
17:49:55 <hpc> _2 is its own special brand of weirdness
17:49:58 <lordcirth> x^.y = view x y 
17:50:17 <hpc> i am extremely not a fan of it being written that way in the documentation, fwiw
17:50:23 <julianleviston> yeah, me neither.
17:50:33 <hpc> it makes it hard to tell what the line parses as
17:50:37 <julianleviston> yup
17:50:41 <hpc> which is important for understanding and using
17:50:55 <hpc> anyway you have your answer
17:50:58 <hpc> @quote stereo
17:50:58 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
17:51:05 <hpc> @quote stereo
17:51:05 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
17:51:07 <hpc> :(
17:51:15 <hpc> in majestic stereo, or something
17:51:34 <hpc> did that get removed from the quote db?
17:52:03 <geekosaur> yes, replaced by some more complex then, then replaced by that
17:52:10 <geekosaur> *thing
17:52:41 <hpc> @quote contrapunctual
17:52:41 <lambdabot> No quotes match. You type like i drive.
17:52:49 <hpc> ah, so contrapunctual fugue is gone too
17:52:57 <hpc> shame, those were pretty funny
17:54:08 * geekosaur was failing to remember what it was and was trying to grep old logs... but there's multiple logs now :/
17:54:41 <geekosaur> there was also, perhaps briefly, some diaphonous whatsit
18:09:52 <dusan> Hello! I have uploaded a package to the Hackage - will it generate the docs on its own please?
18:10:56 <Axman6> yes, it can be several hours between haddock docs runs though
18:14:18 <geekosaur> the doc builder got overhauled and is in the process of building missed docs --- but new uploads get precedence so you should see it in a couple hours
18:14:51 <geekosaur> it's already built several months' worth of backlog
18:15:17 <dusan> geekosaur: thank you very much, that is great!
18:25:12 <alexknvl> Does anyone know if there is a standard name for `Monad m => m a -> (a -> m b) -> m a`?
18:27:15 <Koterpillar> alexknvl: how do you get an m a in the end?
18:27:29 <Koterpillar> just ignore that result?
18:27:48 <alexknvl> yes, combine side-effects, ignore the b
18:28:08 <Koterpillar> :t void
18:28:09 <lambdabot> Functor f => f a -> f ()
18:28:26 <Koterpillar> @src void
18:28:26 <lambdabot> void = fmap (const ())
18:28:39 <Koterpillar> :t \a -> fmap (const a)
18:28:41 <lambdabot> Functor f => b -> f b1 -> f b
18:28:52 <Koterpillar> something like this
18:29:09 <alexknvl> yeah but there is no standard function ;(
18:29:25 <Koterpillar> I don't think there are many that ignore results
18:29:45 <systemfault> Looks a lot like (<*) if the function was lifted
18:29:45 <Koterpillar> would be nice in do notation
18:29:47 <suzu> t <$
18:29:49 <suzu> :t <$
18:29:51 <lambdabot> error: parse error on input ‘<$’
18:29:55 <suzu> :t (<$)
18:29:57 <lambdabot> Functor f => a -> f b -> f a
18:30:02 <alexknvl> I have a number of functions like "setText :: Widget -> String -> IO ()"
18:30:03 <suzu> :t (<*)
18:30:06 <lambdabot> Applicative f => f a -> f b -> f a
18:30:32 <alexknvl> I want to chain them together ignoring the results (since they are all units)
18:30:51 <suzu> use `>>`?
18:30:52 <MarcelineVQ> :t (>>)
18:30:57 <lambdabot> Monad m => m a -> m b -> m b
18:31:01 <suzu> ^
18:31:21 <Koterpillar> do you have a result to pass through?
18:31:38 <alexknvl> Yes, I have a Widget
18:32:07 <Koterpillar> the do notation will be nicest anyway
18:33:55 <alexknvl> there is just some noise since one of the arguments has to be passed explicitly and at the end I have to return it
18:34:29 <alexknvl> it's not a big deal, I was just wondering if there was a nice combinator for it :)
18:34:34 <suzu> you could write your own!
18:35:54 <suzu> > let (@>>) a b = a >>= \x -> b x >> return x 
18:35:57 <lambdabot>  <no location info>: error:
18:35:57 <lambdabot>      not an expression: ‘let (@>>) a b = a >>= \x -> b x >> return x ’
18:36:23 <suzu> :t \a b -> a >>= \x -> b x >> return x
18:36:24 <lambdabot> Monad m => m b -> (b -> m a) -> m b
18:36:29 <Koterpillar> @let a @>> b = a >>= \x -> b x >> return x
18:36:31 <lambdabot>  Defined.
18:38:05 <alexknvl> hmm (@>>) looks okay. I had (</>) before.
18:38:28 <platz> who likes list comprehensions vs do notation for lists?  
18:38:31 <alexknvl> "ice-cream cone operator" :P
18:38:34 <platz> list comp pros: no "return" for 'selector' expression. doesn't need 'guard' keyword. no lexical ambiguity about the monadic context.
18:38:35 <suzu> :D
18:38:49 <platz> list comp cons: more commas. irrefutable pattern errors if not careful.
18:41:20 <platz> another thing I've noticed... usage of `concatMap` indicates a refactoring to listcomp or do notation, because the latter takes care of the final 'concat' step
18:42:05 <Axman6> what do you mean about irrufutable pattern errors?
18:42:23 <Axman6> > [x | Just x <- [Nothing, Just 3, Just 4, Nothing]]
18:42:26 <lambdabot>  [3,4]
18:42:41 <Stuart> Hi
18:42:46 <Axman6> pattern errors just call faill, which for [] is fail _ = []
18:42:59 <Stuart> I am trying to run get Text.Trifecta working
18:43:15 <Stuart> and I am not sure how to install in it stack
18:43:22 <platz> ah, i see... i was seeing them when using let , but i guess that isn't unique to list comps then
18:43:29 <Stuart> I tried stack install trifecta
18:43:47 <Myrl-saki> wtd
18:43:47 <Stuart> No Ghci has two versions
18:44:06 <Axman6> Stuart: are you trying to do this as part od a stack projects?
18:44:12 <Axman6> s//
18:44:13 * hackagebot simple-logger 0.0.2 - A very simple but efficient logging framework  https://hackage.haskell.org/package/simple-logger-0.0.2 (AlexanderThiemann)
18:44:16 <Stuart> I the default is a latter version but the Text.Trifecta requires a lower version
18:44:27 <Stuart> what is od?
18:44:34 <Axman6> of*
18:44:35 <geekosaur> typo for "of"
18:44:42 <Stuart> No this is just at the command level
18:44:48 <Stuart> What does of mean
18:44:59 <Koterpillar> stack repl --package trifecta
18:45:02 <Koterpillar> Stuart: ^
18:45:22 <Koterpillar> for anything beyond this, make a stack.yaml
18:45:31 <Koterpillar> and pin your version in there
18:46:15 <Axman6> you might also have an old LTS version set in your ~/.stack/config.yaml
18:46:50 <Koterpillar> I think that's a different location now, something like ~/.stack/global-project/
18:47:09 <larryba> i have two lists.. [1,2,3,4] and [5,6,7,8]. i can swap one or more elements from one list to another. how can I get all the possible 2-list combinations?
18:47:22 <larryba> i've been trying to use list monad, but it doesn't seem to be possible?
18:48:18 <Koterpillar> > do { l1 <- [1, 2, 3, 4]; l2 <- [5, 6, 7, 8]; return (l1, l2) }
18:48:19 <Axman6> Koterpillar: huh, I wonder how long that's been like that. seems my use of the former has been wokring
18:48:20 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
18:48:25 <Axman6> working*
18:48:54 <Koterpillar> > (,) <$> [1, 2, 3, 4] <*> [5, 6, 7, 8]
18:48:56 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
18:49:03 <qmm> are all type constructors considered to be higher kinded types?
18:49:05 <Koterpillar> Axman6: maybe they transitioned back
18:49:13 * hackagebot simple-logger 0.0.3 - A very simple but efficient logging framework  https://hackage.haskell.org/package/simple-logger-0.0.3 (AlexanderThiemann)
18:49:15 * hackagebot text-utils 0.1.0.0 - Various text utilities  https://hackage.haskell.org/package/text-utils-0.1.0.0 (AlexanderThiemann)
18:49:47 <Koterpillar> larryba: actually, what's an example combination?
18:49:49 <larryba> Koterpillar result should be all the possible 2-list combinations. so [[1,2,3,4],[5,6,7,8]],[[5,2,3,4],[1,6,7,8]]...]
18:49:55 <Koterpillar> ooh
18:50:03 <larryba> 1 or more elements can be swapped
18:50:17 <ertesx> > sequence [[1,5], [2,6], [3,7], [4,8]]
18:50:19 <lambdabot>  [[1,2,3,4],[1,2,3,8],[1,2,7,4],[1,2,7,8],[1,6,3,4],[1,6,3,8],[1,6,7,4],[1,6,...
18:50:22 <Koterpillar> what about the ordering?
18:50:30 <Axman6> nice
18:50:34 <alexknvl> qmm: data N = N Int, here N is not a higher-kinded type
18:50:37 <larryba> ordering is not significant
18:50:48 <Axman6> yeah looks like sequence . transpose is what you want larryba 
18:50:52 <Koterpillar> so can I do [1, 2, 3, 5] ?
18:51:03 <Koterpillar> [1,2,3,5],[4,6,7,8]
18:51:06 <larryba> yes
18:51:10 <Axman6> > sequence . traverse $ [[1,2,3,4],[5,6,7,8]]
18:51:12 <lambdabot>  error:
18:51:12 <lambdabot>      • Couldn't match expected type ‘a -> m b’
18:51:12 <lambdabot>                    with actual type ‘[[Integer]]’
18:51:18 <Koterpillar> ertesx: then that one is wrong...
18:51:22 <Axman6> > sequence . transpose $ [[1,2,3,4],[5,6,7,8]]
18:51:24 <lambdabot>  [[1,2,3,4],[1,2,3,8],[1,2,7,4],[1,2,7,8],[1,6,3,4],[1,6,3,8],[1,6,7,4],[1,6,...
18:51:28 <ertesx> i'm just playing around
18:51:56 <ertesx> but i have an idea how to do larryba's thing using StateT
18:51:57 <Axman6> all it needs is a filter (`elem` xs)
18:52:26 <Koterpillar> let's just generate all the lists and check that there are 3 elements from one list and 1 from the other
18:53:09 <larryba> the result should be [[Int]] not [Int]. lets flatten those two lists and get a single list of 8. I need all the ways to partition a set of size 8 into subsets of size 2
18:53:23 <larryba> into subsets of size 4*
18:53:50 <Koterpillar> we need this: pick :: [a] -> [a, [a]]
18:54:14 * hackagebot primitive 0.6.2.0 - Primitive memory-related operations  https://hackage.haskell.org/package/primitive-0.6.2.0 (DanDoel)
18:54:26 <Koterpillar> then it's do { i1, l1' <- pick l1; i2, l2' <- pick l2; (i1:l2', i2:l1') }
18:55:30 <alexknvl> fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
18:55:46 <Koterpillar> only one element can be swapped
18:55:46 <alexknvl> > fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
18:55:49 <lambdabot>  [([1,2,3,4],[5,6,7,8]),([2,1,3,4],[5,6,7,8]),([3,2,1,4],[5,6,7,8]),([2,3,1,4...
18:55:59 <larryba> Koterpillar no, you can swap more than one element
18:56:04 <Koterpillar> ooh
18:56:14 <Koterpillar> at least one, or zero is fine too?
18:56:59 <alexknvl> > fmap (splitAt 4) . tail $ permutations ([1,2,3,4] ++ [5,6,7,8])
18:56:59 <larryba> zero swaps would be the initial two lists, and that is one valid combination too
18:57:01 <lambdabot>  [([2,1,3,4],[5,6,7,8]),([3,2,1,4],[5,6,7,8]),([2,3,1,4],[5,6,7,8]),([3,1,2,4...
18:57:40 <Koterpillar> then see above
18:58:15 <alexknvl> larryba: fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
18:58:55 <larryba> > length $ fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
18:58:57 <lambdabot>  40320
19:00:20 <larryba> sorry for not being clear, ([2,1,3,4],[5,6,7,8]) and ([3,2,1,4],[5,6,7,8] is the same combination, just changing the order doesn't make it a new combination. I can sort and nub it, but perhaps there's a better way?
19:01:55 <MarcelineVQ> ah unique combinations
19:03:05 <larryba> > length . nub . map sort . fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
19:03:07 <lambdabot>  error:
19:03:07 <lambdabot>      • Couldn't match type ‘([Integer], [Integer])’ with ‘[()]’
19:03:07 <lambdabot>        Expected type: [[Integer]] -> [[()]]
19:03:38 <larryba> > length . nub . map (\(x,y) -> (sort x, sort y)) sort . fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
19:03:40 <lambdabot>  error:
19:03:41 <lambdabot>      • Couldn't match expected type ‘[([Integer], [Integer])] -> [()]’
19:03:41 <lambdabot>                    with actual type ‘[([()], [()])]’
19:04:15 <larryba> > length . nub . map (\(x,y) -> (sort x, sort y)) . fmap (splitAt 4) $ permutations ([1,2,3,4] ++ [5,6,7,8])
19:04:17 <lambdabot>  70
19:05:11 <platz> also a bit surprised i needed to write this: updateListAt xs i x' = take i xs ++ [x'] ++ drop (i + 1) xs
19:06:17 <platz> yeah lens yadayada, but w/ not in prelude afaik
19:07:09 <ertesx> λ> combs "ab" "cd"
19:07:09 <ertesx> [("ab","cd"),("ad","cb"),("ab","dc"),("ac","db"),("ba","cd"),("bd","ca"),("ba","dc"),("bc","da"),("cd","ab"),("cb","ad"),("cd","ba"),("ca","bd"),("dc","ab"),("db","ac"),("dc","ba"),("da","bc")]
19:07:16 <ertesx> larryba: is that such a function?
19:07:55 <alexknvl> no there is (ab cd) and (ab dc)
19:07:57 <larryba> no, there are only two combinations, [("ab", "cd"), ("ac", "bd")]
19:08:34 <alexknvl> larryba: you can think of it as generating an 8-bit number with four 1's
19:08:40 <ertesx> why is ("cb", "ad") not one?
19:09:34 <ertesx> this seems non-uniform…  so the first elements must always be in order, but the second elements not?
19:09:35 <platz> i suppose vectors are better, just a potentially large refactoring 
19:09:59 <alexknvl> ertesx: his lists are unique up to permutations
19:10:00 <larryba> you're right it ("cb", "ad") is also a unique 2-set
19:10:12 <alexknvl> should be*
19:10:49 <ertesx> ah, now i read the problem description
19:10:55 <ertesx> that one is actually fairly easy
19:11:41 <alexknvl> larryba: generate all 8 long [Bool]s with 4 True values (can be done recursively), then apply them as a mask to [1, 2, 3, 4, 5, 6, 7, 8]
19:14:21 <ertesx> λ> perm 2 "abc"
19:14:21 <ertesx> ["ab","ac","ba","bc","ca","cb"]
19:14:25 <ertesx> larryba: like this?
19:16:36 <larryba> ertesx no. perm 2 "abcd"  =>  [["ab", "cd"], ["ac", "bd"], ["cb", "ad"]...]
19:17:06 <larryba> 2-set makes it simpler because you can only swap a single element. in a 4-set you could swap more than one
19:17:30 <larryba> it looks like i am doing a horrible job of explaining this, and confusing everyone (at times, myself too :P)
19:18:06 <platz> i think I like this better: updateListAt xs i' x' = let go (i, x) = if i == i' then x' else x in go <$> zip [0 ..] xs
19:19:04 <ertesx> larryba: couldn't you just split the resulting lists of (permutations "abcd") in half?
19:20:55 <larryba> ertesx how do you mean split in half? chunksOf 2?
19:21:35 <ertesx> > foldr (\x ~(xs, ys) -> (x:ys, xs)) ([], []) "abcdefghi"
19:21:37 <lambdabot>  ("acegi","bdfh")
19:21:43 <ertesx> larryba: like this
19:23:57 <qmm> 21:50 < alexknvl> qmm: data N = N Int, here N is not a higher-kinded type
19:24:00 <qmm> alexknvl: why is that?
19:24:19 <ertesx> > foldr (\x ~(xs, ys) -> (x:ys, xs)) ([], []) <$> permutations "abcd"
19:24:21 <lambdabot>  [("ac","bd"),("bc","ad"),("ca","bd"),("ba","cd"),("cb","ad"),("ab","cd"),("d...
19:25:07 <larryba> that looks good
19:25:28 <larryba> except ("ba","cd")  ("ab","cd")
19:25:52 <larryba> list 1 and list 2 contain same elements in both combinations
19:25:56 <ertesx> to eliminate those use Set instead of []
19:26:12 <larryba> good idea
19:27:04 <larryba> issues is though, with 4-element groups, i am generating a lot of duplicates
19:27:31 <ertesx> i see the problem now…  so you basically want to pick the elements in order
19:27:43 <larryba> > length $ foldr (\x ~(xs, ys) -> (x:ys, xs)) ([], []) <$> permutations "abcdefgh"
19:27:45 <lambdabot>  40320
19:28:55 <ertesx> > S.fromList . map (\(xs, ys) -> (S.fromList xs, S.fromList ys)) $ foldr (\x ~(xs, ys) -> (x:ys, xs)) ([], []) <$> permutations "abcdefgh"
19:28:58 <lambdabot>  fromList [(fromList "abcd",fromList "efgh"),(fromList "abce",fromList "dfgh"...
19:29:05 <ertesx> > S.size . S.fromList . map (\(xs, ys) -> (S.fromList xs, S.fromList ys)) $ foldr (\x ~(xs, ys) -> (x:ys, xs)) ([], []) <$> permutations "abcdefgh"
19:29:08 <lambdabot>  70
19:29:13 <ertesx> ok, i see
19:29:21 <larryba> i think that is good
19:29:28 <larryba> > length $ permutations "abcdefgh"
19:29:30 <lambdabot>  40320
19:29:42 <larryba> this still worries me, can't we do something to avoid creating 40 thousand elements to begin witih?
19:29:54 <ertesx> yeah
19:30:18 <alexknvl> qmm: because it doesn't take type parameters
19:33:57 <alexknvl> > atMost n k | k > 0 = (atMost n (k - 1)) ++ (fmap ((:) True) $ atMost (n - 1) (k - 1)) | otherwise = [replicate n False]
19:33:59 <lambdabot>  <hint>:1:12: error: parse error on input ‘|’
19:34:25 <alexknvl> hmm works in ghci
19:35:32 <MarcelineVQ> lambdabot isn't ghci :> it's especially not ghci 8
19:35:44 <alexknvl> > atMost n k = if k > 0 then (atMost n (k - 1)) ++ (fmap ((:) True) $ atMost (n - 1) (k - 1)) else [replicate n False]
19:35:46 <MarcelineVQ> @let atMost n k | k > 0 = (atMost n (k - 1)) ++ (fmap ((:) True) $ atMost (n - 1) (k - 1)) | otherwise = [replicate n False]
19:35:46 <lambdabot>  <hint>:1:12: error:
19:35:46 <lambdabot>      parse error on input ‘=’
19:35:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:35:47 <lambdabot>  Defined.
19:36:01 <alexknvl> > atMost 8 4
19:36:03 <lambdabot>  [[False,False,False,False,False,False,False,False],[True,False,False,False,F...
19:39:02 <ertesx> larryba: λ> perm2 2 "abcd"
19:39:03 <ertesx> [(fromList "cd",fromList "ab"),(fromList "bd",fromList "ac"),(fromList "ad",fromList "bc"),(fromList "bc",fromList "ad"),(fromList "ac",fromList "bd"),(fromList "ab",fromList "cd")]
19:39:32 <ertesx> λ> length (perm2 4 "abcdefgh")
19:39:33 <ertesx> 70
19:39:45 <ertesx> doesn't generate duplicates in the first place
19:39:45 <larryba> nice, let me try
19:39:52 <larryba> @src perm2
19:39:52 <lambdabot> Source not found. My mind is going. I can feel it.
19:40:22 <larryba> @hoogle perm2
19:40:26 <lambdabot> No results found
19:41:07 <larryba> did you define this function or is it part of some library?
19:41:26 <ertesx> λ> length (perm2 8 (take 16 [0..]))
19:41:26 <ertesx> 12870
19:41:33 <ertesx> i defined it
19:41:47 <ertesx> do you want to try yourself?
19:42:01 <larryba> if you can give me a hint 
19:42:06 <MarcelineVQ> does it work for "abcdefbh"
19:42:42 <MarcelineVQ> *does/should it
19:44:50 <larryba> MarcelineVQ repeated element? it should.
19:45:01 <ertesx> larryba: this is the basic shape of my formula:
19:45:01 <ertesx> perm2 :: (Ord a) => Int -> [a] -> [(S.Set a, S.Set a)]
19:45:01 <ertesx> perm2 n = foldr (\x -> (>>= dist x)) [(mempty, mempty)]
19:46:06 <ertesx> dist x (xs, ys)  -- all the potential possibilities of x included in (xs, ys)
19:47:18 <ertesx> pseudo-example with lists (assuming n = 4):  dist 'd' ("ab", "c") = [("abd", "c"), ("ab", "cd")]
19:47:30 <larryba> i'll give it a try
19:48:12 <ertesx> dist 'h' ("abdg", "cef") = [("abdg", "cefh")]  -- because the first list is already "full"
19:57:27 <alexknvl> larryba: https://gist.github.com/alexknvl/2858571087cd8315d2f28a00ccedad13
19:58:47 <qmm> alexknvl: i see
19:59:07 <qmm> alexknvl: data Maybe a = Nothing = Just a -- is a higher kinded type though, right?
19:59:11 <alexknvl> qmm: yes
19:59:19 <qmm> alexknvl: thanks again
19:59:35 <alexknvl> Maybe itself is * -> *, Maybe Int is *
19:59:41 <qmm> data Maybe a = Nothing | Just a
19:59:56 <alexknvl> :k Maybe
19:59:57 <lambdabot> * -> *
19:59:59 <ertesx> larryba: i have to leave, so here is mine: https://gist.github.com/esoeylemez/a2fd758f08e732c716ff77785f499f19
20:00:02 <alexknvl> :k Maybe Int
20:00:03 <lambdabot> *
20:00:10 <qmm> anything with the kind * -> *
20:00:20 <larryba> ertesx thanks, I'll try to do it on my own first
20:00:28 <ertesx> larryba: i invite you to try it yourself first
20:00:31 <ertesx> yeah =)
20:00:54 <larryba> cya
20:01:31 <alexknvl> qmm: or * -> * -> *, etc
20:01:44 <jchia1> In my codebase, I generally use Text instead of String. I find that it's littered with 'unpack' and 'pack' because I have to use libraries that use String. Is there a better way?
20:02:39 <alexknvl> qmm: actually, I think I am wrong
20:02:58 <alexknvl> qmm: see this https://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala (first answer applies regardless whether you use scala or haskell)
20:04:39 <alexknvl> :k ExceptT
20:04:40 <lambdabot> * -> (* -> *) -> * -> *
20:04:53 <Axman6> jchia1: using lens can make it more bareable in some cases
20:05:51 <Axman6> it provides the IsText class which has instances for String, Text and lazy Text: http://hackage.haskell.org/package/lens-4.15.1/docs/Data-Text-Lens.html
20:06:00 <alexknvl> qmm: ExceptT is a proper "higher-order type constructor", because one of its type parameters is * -> *
20:07:39 <qmm> alexknvl: i saw that link and was confused by the scala syntax which is why i came in here :)
20:07:57 <qmm> i can see all types with kind * -> * being higher order/ higher kinded
20:08:24 <alexknvl> no, they are first-order kinded
20:09:07 <alexknvl> for instance in Rust they don't have HKT so you can't make trait Monad<M<_>>
20:09:16 <qmm> now i'm confused, i thought higher order was a more generic term and higher-kinded referred to higher order abstraction specifically for types
20:09:57 <qmm> oh, you said "first-order kinded"
20:10:34 <qmm> are types with * -> * -> * higher kinded?
20:10:43 <alexknvl> no
20:10:48 <qmm> not really sure how many levels of indirection i need to go here :)
20:10:51 <qmm> okay
20:10:58 <alexknvl> (* -> *) -> * is
20:11:11 <qmm> that looks like fmap
20:12:09 <alexknvl> data M m = N (m Int)
20:12:12 <qmm> oh, that's Functor as show in the stackoverflow link
20:12:15 <qmm> :kind Functor
20:12:25 <qmm> >:k Functor
20:12:41 <alexknvl> :k Functor
20:12:42 <qmm> > :k Functor
20:12:42 <lambdabot> (* -> *) -> Constraint
20:12:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:13:11 <qmm> alexknvl: thanks for the explanation
20:13:17 <alexknvl> > data M m = N (m Int)
20:13:20 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
20:13:53 <nitrix> @let data M m = N (m Int)
20:13:55 <lambdabot>  Defined.
20:14:02 <alexknvl> :k M
20:14:05 <lambdabot> (* -> *) -> *
20:14:07 <ThusSpakeHarambe> https://github.com/rust-lang/rust/issues/28059
20:17:08 <pikajude> :t M (length <$> getLine)
20:17:10 <lambdabot> error:
20:17:10 <lambdabot>     Data constructor not in scope: M :: IO Int -> t
20:17:16 <pikajude> :t N (length <$> getLine)
20:17:18 <lambdabot> M IO
20:17:20 <pikajude> there we go
20:21:21 <jchia1> Axman6: How does lens help with the pack-unpack clutter from converting between String & Text?
20:30:38 <Axman6> jchia1: if you're already using lenses for things, it's easy to put in calls to unpacked when constructing lenses, it often feels a little less awkward
20:32:56 <Stuart> Hi
20:33:07 <Stuart> I am trying to write the a compose function
20:33:24 <Stuart> For the pure
20:33:38 <Stuart> newtype Compose f g a =
20:33:38 <Stuart> Compose { getCompose :: f (g a) }
20:33:38 <Stuart> deriving (Eq, Show)
20:34:32 <Stuart> pure :: a -> Compose f g (a -> b)
20:34:44 <Stuart> compose
20:37:32 <Koterpillar> Stuart: use lpaste.net
20:38:53 <Axman6> Stuart: that doesn't look like the right type for pure
20:39:12 <Axman6> it should probably be: pure :: a -> Compose f g a
20:39:37 <Stuart> that looks ok
20:40:08 <Stuart> woops
20:40:56 <n_blownapart> http://pastie.org/10966501  hi a couple questions about this simple program. I was getting used to having ' : ' indicate a recursion, but here it seems to me there is a recursion without the colon . but indeed  ' x + summa xs ' is recursive, right?
20:41:19 <geekosaur> : means a list is being built
20:41:39 <atondwal> n_blownapart: yes, (:) isn't recursion it's append to the beginning of a list
20:41:45 <Stuart> how do I comple f g a
20:41:47 <geekosaur> it doesn't necessarily mean recursion, although many lists are built recursively. and yes, if that is in a function called summa then it is recursion
20:42:00 <Stuart>  How do I como f g a
20:42:07 <Stuart> I guess f . g
20:42:37 <Stuart> but then I have to pass the parameters f and g somehow in to pure
20:42:38 <n_blownapart> geekosaur, ok so the : is explicitly a constructor for a list, but here it is implicit 
20:42:41 <geekosaur> recursion is when a function calls itself
20:43:00 <geekosaur> no, you are not recursing in (:), you are recursing in (+)
20:43:06 <n_blownapart> well, yes, its not building a list, it is a sort of accumulator ?
20:43:10 <geekosaur> the recursion is not a (:)
20:43:24 <geekosaur> the recursion is calling a function from within itself
20:43:39 <geekosaur> you may be confusing code recursion with recursive data types
20:44:02 <geekosaur> lists are recursive data types, that is a list is defined in terms of itself (data List a = a : List a)
20:44:21 <atondwal> n_blownapart: @type (:)
20:44:24 <geekosaur> similarly a function is recursive if it refers to itself, regardless of how it does so
20:44:29 <atondwal> @type (:)
20:44:30 <lambdabot> a -> [a] -> [a]
20:44:36 <n_blownapart> thanks geekosaur atondwal   ...
20:44:58 <geekosaur> actually data List a = [] | a : List a
20:45:05 <geekosaur> forgot the empty case...
20:45:33 <n_blownapart> right so + summa xs is just a classic recursive call on the cdr 
20:45:48 <Maxdamantus> Who needs finite-length lists anyway?
20:45:57 <geekosaur> summa [] = 0; summa (x:xs) = x + summa xs -- this is recursive, but is not building a recursive data type
20:46:31 <geekosaur> you will often use recursion in code when working with a recursive data type, but that is not the only place you can use recursion
20:46:35 <saurabhnanda> anyone here using hakyll, who can help me with a newbie issue: https://github.com/jaspervdj/hakyll/issues/486
20:46:59 <atondwal> Stuart: pure a = Compose (pure (pure a))
20:47:11 <n_blownapart> right its just an Int . I was confused because all the recursive calls I've seen so far began with a ' : ' 
20:47:24 <n_blownapart> thanks 
20:47:55 <atondwal> n_blownapart: what tutorial are you using? perhaps someone should go through and put in an example that isn't a list :)
20:48:22 <geekosaur> Maxdamantus, I did consider making a joke about NonEmpty, but the one in ghc8 is defined differently...
20:48:58 <n_blownapart> atondwal, that's the first instance but I studied a bit of scheme so I can see it well enough with your help
20:50:45 <n_blownapart> the other thing about it is, in scheme there is trace, so that you get an output of line three. Can I make an alias, say " summa* " so that I can stick that on line three and see the output with trace or what-have-you ?
20:51:17 <geekosaur> Debug.Trace.traceShow, or ghci can step through a computation
20:51:47 <n_blownapart> geekosaur, where would that expression go in the file?
20:52:23 <n_blownapart> just before main  ?
20:53:53 <geekosaur> n_blownapart, you import Debug.Trace at the top and wrap some expression in traceShow if you want to see its value when it is evaluated
20:54:44 <geekosaur> if you want to see the result of every call to summa including the recursive calls, you would write it as: summa [] = traceShow 0; summa (x:xs) = traceShow $ x + summa xs
20:54:55 <geekosaur> (instead of my earlier one)
20:55:05 <atondwal> well, you'd want to use traceShowId
20:55:28 <geekosaur> if you wanted to just show the recursive calls, you'd wrap it around the `summa xs` instead of the whole thing
20:55:36 <atondwal> (traceShow itself takes a second paramter that it returns after priting the first to debug output)
20:57:32 <Stuart> atondwal I tried that and it didn't work
20:57:51 <geekosaur> mm, right, there's more thna that. (I think I've always used a custom traceShow because Debug.Trace used to only have `trace` and nothing else...)
20:58:17 <Stuart> atondwal: Ambiguous occurrence ‘pure’
20:59:17 <n_blownapart> geekosaur kindly edit the pastie with that whole process just this once .. I'll get a lot of mileage , insight and enjoyment from it, thanks : http://pastie.org/10966501
20:59:49 <n_blownapart> its really specific how its used in scheme
21:00:39 <n_blownapart> making an alias is extremely helpful to watch various sorts of processes if you don't want to see the whole thing
21:01:15 <atondwal> Stuart: oops, you're right! I forgot to lift pure itself
21:01:41 <lpaste> geekosaur pasted “n_blownapart: traceShowId” at http://lpaste.net/344297
21:02:10 <n_blownapart> thanks kindly geekosaur
21:02:22 <atondwal> Stuart: pure (Compose a) = Compose $ pure pure <*> pure a
21:02:32 <atondwal> let me actually try this hmm
21:03:24 <Stuart> In the realhaskell book the definition is pure :: a -> Compose f g a
21:03:24 <Stuart> pure = undefined
21:03:38 <Stuart> the haskellbook by callen
21:03:48 <Stuart> not realhaskell
21:04:05 <Stuart> I haven't implemented the <*> yet
21:04:53 <geekosaur> sounds like it gave you a stub and you're supposed to fill in the correct definition
21:06:40 <Stuart> atondwal how do you pass in f g 
21:06:59 <Stuart> or is it a -> f -> g
21:07:07 <Stuart> so you curring
21:07:30 <atondwal> wait, hold on my original answer typechecks for me
21:08:45 <lpaste> atondwal pasted “Applicative Composition pure” at http://lpaste.net/344300
21:09:05 <atondwal> Stuart: this typechecks for me!
21:09:12 <Stuart> Hmmm, I saw some some code and it looks like yours
21:09:56 <Stuart> I am getting this It could refer to either ‘Prelude.pure’,
21:09:56 <Stuart>                              imported from ‘Prelude’ at compose.hs:1:1
21:09:56 <Stuart>                              (and originally defined in ‘GHC.Base’)
21:09:56 <Stuart>                           or ‘Main.pure’, defined at compose.hs:5:1
21:10:27 <atondwal> can you lpaste the file you're working in?
21:10:36 <atondwal> so that the line numbers mean something to me?
21:11:10 <Stuart> atondwal this is what I have newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (Eq, Show)
21:11:11 <Stuart> pure :: a -> Compose f g a
21:11:11 <Stuart> pure x = Compose (pure (pure x))
21:11:42 <atondwal> oh, don't do that!
21:11:57 <atondwal> it'll work if you call your function something other than pure
21:12:34 <geekosaur> note that pure was not in Prelude until ghc 7.10, so books/tutorials based on older versions might have assumed that `pure` would not conflict
21:12:42 <atondwal> but if you want to it to be an implementation of `pure` in the Applicative sense it has to be inside and instance declaration
21:12:49 <geekosaur> (you had to import Control.Applicative)
21:13:03 <lpaste> atondwal revised “Applicative Composition pure”: “Applicative Composition pure” at http://lpaste.net/344300
21:13:36 <n_blownapart> geekosaur, that's a lot cleaner than how scheme trace works. so it takes the zero because it requires an argument or is that like an incrementer ?
21:13:37 <Stuart> atondwal: newtype Compose2 f g a = Compose2 { getCompose2 :: f (g a) } deriving (Eq, Show)
21:13:37 <Stuart> pure3 :: a -> Compose2 f g a
21:13:37 <Stuart> pure3 x = Compose2 (pure3 (pure3 x))
21:13:49 <Stuart> that doesn't work either
21:13:57 <geekosaur> n_blownapart, one of us is really confused
21:14:31 <Stuart> To be honest, what is pure doing in this 
21:14:47 <geekosaur> traceShowId displays whatever you passed it (which must have a Show instance) and then returns it, so you can replace any expression foo with traceShow (foo) to see when the expression is evaluated
21:14:54 <geekosaur> er traceShowId
21:14:55 <Stuart> i.e. (pure (pure x))
21:15:09 <geekosaur> or, are you still asking about the recursion?
21:15:34 <geekosaur> (I added traceShowId to both the base case, which is 0, and the recursive case)
21:15:34 <Stuart> atondwal pure is function which takes an a and returne a compose
21:15:56 <n_blownapart> right, so it shows the case where we have an empty list, even though normally it would proceed to the next line. right?
21:16:09 <lpaste> atondwal revised “Stuart: pure”: “Stuart: pure” at http://lpaste.net/344305
21:16:45 <atondwal> you still want to call the Applicative `pure` for `f` and for `g`
21:17:07 <geekosaur> n_blownapart, you did look at your original, right? line 2
21:17:22 <geekosaur> base case: empty list, result is 0
21:17:48 <atondwal> uh, so maybe it'll be more clear if I put in the types
21:17:53 <geekosaur> recursive case (nonempty list), return the initial value from the list plus (summa rest_of_list)
21:18:36 <n_blownapart> geekosaur yeah I get it. that is way nicer than scheme. in scheme, you can't target it like that right in front of the function . thanks !
21:19:28 <n_blownapart> or in front of the return value
21:20:02 <Stuart> Cool
21:20:23 <Stuart> atondwal: Thanks, what is pure now
21:20:24 <lpaste> atondwal revised “Stuart: pure”: “Stuart: pure” at http://lpaste.net/344305
21:20:41 <atondwal> I put in a type sig for pure2
21:21:05 <Stuart> atondwal:: Ahhhh
21:21:07 <atondwal> I wanted to specify intermediate types for each of the pure, but I'm not quite sure how here
21:21:34 <Axman6> pure is how you inject a value into some applicative type. on lists, pure a = [a], for Maybe pure a = Just a, for State, pure a = State (\s -> (a,s))
21:21:44 <Stuart> now, I trying to remember what pure does in the applicative type
21:21:45 <Axman6> it is the action which has no effect basically
21:21:51 <Axman6> :t pure
21:21:53 <lambdabot> Applicative f => a -> f a
21:23:11 <Stuart> so it takes a and return a functor of a
21:23:23 <Axman6> so, if you have Compose Maybe [] a, then pure a = Compose (pure (pure a)) --> Compose (pure [a]) --> Compose (Just [a])
21:24:00 <Stuart> So how do I use pure for compose?
21:24:42 <Axman6> exactly how I wrote above, Compose (pure (pure a))
21:24:53 <Axman6> that's how it's defined anyway
21:25:20 <Axman6> you need to make sure there is a constraint on f and g that they are both Applicatives too, or they won't have pure defined on them
21:29:01 <Stuart> How do I know in the command line if List and Maybe have applicatives defined
21:30:04 <geekosaur> :info Applicative
21:32:01 <Stuart> Thanks
21:35:50 <Stuart> Now I am little confused
21:36:15 <Stuart> If you have (pure (+1)) <*> Just 10) = 11
21:36:27 <Stuart> What is actually pure (+1) doing 
21:36:36 <Koterpillar> :t pure (+ 1)
21:36:37 <Stuart> it creates a fuction
21:36:38 <lambdabot> (Applicative f, Num a) => f (a -> a)
21:36:41 <Koterpillar> :t (+ 1)
21:36:42 <lambdabot> Num a => a -> a
21:36:46 <Koterpillar> (+ 1) 10
21:36:48 <Koterpillar> > (+ 1) 10
21:36:50 <lambdabot>  11
21:37:05 <Stuart> What is f
21:37:26 <Koterpillar> something that's Applicative
21:37:46 <Stuart> So in this case is f a function
21:38:06 <Stuart> Or it gets turned to Maybe when you use <*>
21:38:31 <atondwal> the latter
21:38:38 <Stuart> Maybe (+1) <*> Just (10)
21:38:58 <Stuart> Woops wrong interative
21:39:02 <Axman6> :t pure (+1) :: Maybe (Int -> Int)
21:39:03 <lambdabot> Maybe (Int -> Int)
21:39:09 <Axman6> :t pure (+1) :: [(Int -> Int)]
21:39:11 <lambdabot> [Int -> Int]
21:39:16 <Axman6> :t pure (+1) :: IO (Int -> Int)
21:39:18 <lambdabot> IO (Int -> Int)
21:40:19 <Stuart> So it is turning it into what ever is on the other side
21:40:33 <Axman6> "the other side"?
21:40:56 <Axman6> so those are all just instances of Applicative, there are many more
21:41:07 <Stuart> i.e pure (+1) <*> Just 10 evaluates to Just (+1)  <*> Just (10)
21:41:07 <Axman6> :t pure ((+1) :: Int -> Int)
21:41:09 <lambdabot> Applicative f => f (Int -> Int)
21:41:20 <Axman6> yes, for Maybe, that's what it does
21:41:33 <Axman6> for list, it evaluates to [(+1)]
21:41:36 <Stuart> Ok, that is blowing my small mind
21:41:49 <Stuart> Ok interest behaviour
21:42:18 <atondwal> Yeah, it uses unification to figure out what type it needs and then uses whatever implementation we have for that types
21:42:25 <atondwal> *for that type
21:42:37 <Stuart> cool anyway
21:43:04 <Axman6> > pure (+1) <*> [1,2,3]
21:43:06 <lambdabot>  [2,3,4]
21:43:13 <Axman6> > pure (+1) <*> Just 3
21:43:15 <lambdabot>  Just 4
21:43:21 <Axman6> > pure (+1) <*> Right 3
21:43:23 <lambdabot>  Right 4
21:43:27 <Stuart> Yes, that is cool
21:43:32 <Axman6> > pure (+1) <*> Left "Oh no, an error!"
21:43:34 <lambdabot>  Left "Oh no, an error!"
21:44:14 <Axman6> note that pure f <*> x === f <$> x (=== fmap f x) as long as the Applicative instance obeys the proper laws
21:44:21 <Axman6> (I think that is actually one of the laws)
21:44:25 <Stuart> so (pure (pure 10)) is going to be evaluated depending on what comes after 
21:44:35 <Stuart> That what was confusing me
21:44:36 <Axman6> what do you mean by "comes after"
21:45:01 <Stuart> back to this http://lpaste.net/344305
21:46:06 <Stuart> Now I have two applicatives
21:47:03 <Stuart> how do I apply this to two functions
21:48:25 <Stuart> So f g goes to one argument
21:49:30 <Stuart> pure (+1) <*> [Just(1)]
21:51:16 <Stuart> So now I have to implement the <*>
21:51:26 <Stuart> in the compsoe
21:51:29 <Stuart> in the compose
21:51:37 <Stuart> to get test it out I suppose
21:55:32 <Stuart> Iam guessing a definition like this <*> :: (Applicative f, Applicative g) => Compose f g (a -> b) -> Compose f g a -> Compose f g b
22:02:04 <Axman6> yep that's exactly the type you need Stuart. 
22:02:31 <Axman6> you should be able to do that using (<*>) only IIRC
22:03:22 <Axman6> oh actually, you might need <$> too
22:08:07 <augur> anyone know how to get line folding using the parsec indents package?
22:10:37 <Stuart> Axman6 and others: the compose is blowing my mind right now. It's really cool. Got to go home. I look forward to try implement the rest of the compose applicative
22:10:55 <Stuart> Will look at tomorrow
22:11:00 <Stuart> ciao ciao
22:14:22 * hackagebot XSaiga 1.5.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.5.0.0 (InBetweenNames)
22:16:25 <Axman6> Stuart: good luck!
22:24:22 * hackagebot markdown 0.1.16 - Convert Markdown to HTML, with XSS protection  https://hackage.haskell.org/package/markdown-0.1.16 (MichaelSnoyman)
22:40:05 <praveen> .
23:26:15 <circ-user-QJY8M> Is it right that whereas bind of Just a converts a into another Just, State splits a into a s such that only s part is supplied to the bind?
23:27:30 <c_wraith> Not completely.
23:28:07 <c_wraith> bind for state chains the actions together, such that the state result from the left hand argument is fed into the state argument of the right-hand argument.
23:29:05 <c_wraith> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s)
23:29:06 <lambdabot> Cannot parse command
23:29:16 <c_wraith> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s))
23:29:16 <lambdabot> f a b c =
23:29:16 <lambdabot>     case a c of
23:29:16 <lambdabot>     (d, e) -> b d e
23:29:36 <c_wraith> That's the type of bind in State, when you strip out all the newtype wrappers
23:33:24 <c_wraith> the important thing is that state values are functions, and bind for state composes the functions together such that the left hand side's state manipulation happens before the right-hand sides.
23:33:28 <c_wraith> *side's
23:35:27 <grantwu> D/quit
23:35:30 <grantwu> sigh
23:59:12 <hololeap> is there a way to simplify this function? https://dpaste.de/ycKA
