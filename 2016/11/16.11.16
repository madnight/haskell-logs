00:03:22 * hackagebot egison 3.6.3 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.6.3 (SatoshiEgi)
00:13:59 <Lokathor> jle`, well, all higher-kinded types too :3
00:21:43 <ongy> we can construct functions that take a variable amount of arguments, an example is Text.Printf.printf But it's not the prettiest and has limitations
00:23:23 * hackagebot tianbar 1.2.3.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.2.3.0 (AlexeyKotlyarov)
00:26:46 <quchen> “ghc-mod lint” ignores my HLint.hs, but the corresponding ticket (https://github.com/DanielG/ghc-mod/issues/826) seems resolved. Is anyone else having issues?
00:26:46 <quchen> Running “hlint” directly respects the file.
00:26:48 <quchen> HLint is 1.9.35, GHC-mod is 5.6.0.0
00:40:48 <jmarciano> I would like to install from source, however, it says I need "ghc bindist". Where do I download it?
00:53:48 <jmarciano> ghc is 100+ MB, why? 
00:54:04 <jmarciano> In Tanzania I cannot just download huge packages
00:55:21 <earthy> 100+ MB is not considered huge these days
00:55:25 <earthy> that's why.
00:55:58 <ventonegro> No, the reason is that GHC links code not used
00:56:01 <ventonegro> https://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
00:56:40 <jmarciano> not huge for you where you have quick connection, there are more countries with bad connection yet.
00:56:42 <ventonegro> If you use one function from a library, the whole library goes in. Unless you play with "-split-objs", which is experimental
00:56:53 <jmarciano> i tried downloading ghc
00:56:58 <earthy> ventonegro: that's the *technical* explanation
00:57:07 <earthy> jmarciano: oh, I know.
00:57:18 <ventonegro> jmarciano: yes, 100MB is still huge, even in Europe.
00:57:21 <jmarciano> yes I understand, it is built with various libraries
00:58:22 <jmarciano> and how to be sure of those binaries, I don't see what is inside
00:58:34 <jmarciano> I am used to download sources and compile.
00:59:06 <ventonegro> (for a compiler)
00:59:45 <jmarciano> is it sponsored by Yale University?
01:03:24 * hackagebot log 0.5.5 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.5 (MikhailGlushenkov)
01:04:35 <ongy> I think bootstrapping ghc these days needs ghc. So you are better of with a binary download, if you have limited internet speed
01:17:02 <jmarciano> ongy: yes, it asks for 101 MB
01:31:33 <juliagoda>  /SET beep_msg_level MSGS HILIGHT DCCMSGS
01:35:27 <wagnerf> hi, I'm a haskell newbie and I'm a little stuck with some errors in my code
01:35:39 <wagnerf> here is the compiler messages with the relevant code snippet
01:35:42 <wagnerf> http://pastebin.com/ZXdF69kD
01:36:11 <wagnerf> i don't really understand why the variable is not in scope here
01:36:55 <ongy> wagnerf: is it not in scope in the where clause? Line numbers don't match in the paste
01:37:16 <wagnerf> line 56 is the commented one
01:37:24 <wagnerf> so line 5 here
01:37:38 <wagnerf> sorry, the code is getting big
01:38:12 <wagnerf> so yes, it is in the where clause
01:39:23 <ongy> Ok. That's normal behaviour. In the where clause the arguments to your function ((height, startingFacets, endingFacets):events) will be in scope, but variables bound in the do block will not. 
01:40:15 <wagnerf> ongy: ok. good.
01:40:23 <wagnerf> so, what are my options here ?
01:40:30 <ongy> you can either make facets an argument and pass it in, or refactor so you use let statements in your code instead of the where to define allFacets with facets in scope
01:41:31 <wagnerf> ok 
01:41:37 <wagnerf> thanks very much
01:42:44 <wagnerf> that leaves a lot of thinking for me
01:43:07 <wagnerf> like : do I really need a state ?
01:43:49 <wagnerf> I'll look at it again. thank you again for your help
01:44:29 <lyxia> You can use a fold here
01:45:42 <wagnerf> lyxia: wow, I was thinking about recursing but maybe even a fold that's right
01:47:09 <lyxia> well that would be good too. a simple recursive function that passes the state explicitly.
01:48:10 <lyxia> I think it takes a while to recognize a fold.
02:08:27 * hackagebot http-proxy 0.1.0.5 - A library for writing HTTP and HTTPS proxies  https://hackage.haskell.org/package/http-proxy-0.1.0.5 (ErikDeCastroLopo)
02:13:51 <user__> guys there is a function that checks if a element is a number?
02:14:38 <pavonia> Element of what?
02:15:35 <user__> like a give list L and it checks if head L is a number
02:16:24 <pavonia> So you want to check if a String parses to an integer?
02:17:05 <user__> like my list will be "0 3 2"
02:17:15 <user__> but i dropped 2
02:17:23 <user__> "3 2" now
02:17:47 <user__> and i want to check if 3 is a number or what 
02:18:03 <user__> oh i know other way to do it 
02:18:31 <pavonia> > reads "3 2" :: ReadS Int
02:18:34 <lambdabot>  error:
02:18:34 <lambdabot>      • Couldn't match type ‘[(a0, String)]’
02:18:34 <lambdabot>                       with ‘String -> [(Int, String)]’
02:18:57 <pavonia> > reads "3 2" :: [(Int, String)]
02:19:00 <lambdabot>  [(3," 2")]
02:19:16 <pavonia> > reads "x 2" :: [(Int, String)]
02:19:18 <lambdabot>  []
02:20:26 <user__> thx
02:22:02 <jle`> user__: there's also isDigit, if you always want to just parse integers
02:22:09 <jle`> > all isDigit "123"
02:22:11 <lambdabot>  True
02:22:28 <jle`> > takeWhile isDigit "123 345"
02:22:30 <lambdabot>  "123"
02:22:45 <jle`> er, i mean, if you just want to check if a string has an integer prefix
02:23:34 <jle`> > null (takeWhile isDigit "123 345")
02:23:36 <lambdabot>  False
02:23:41 <jle`> > null (takeWhile isDigit "hello 345")
02:23:43 <lambdabot>  True
02:24:00 <user__> nah, i just want to get (Int,Int)
02:24:16 <user__> when i give it like "3 2"
02:24:31 <user__> but it seems like im getting type error...
02:25:08 <jle`> are you expecting only ints with one digit?
02:25:33 <user__> nope
02:26:03 <user__> i tried isDigit but it is only with 1 digit
02:26:27 <jle`> you can use words to split up a string with whitespace
02:26:30 <jle`> > words "123 345"
02:26:32 <lambdabot>  ["123","345"]
02:26:37 <jle`> and then you can map readMaybe
02:26:47 <jle`> > map readMaybe (words "123 456")
02:26:49 <lambdabot>  error:
02:26:50 <lambdabot>      Variable not in scope: readMaybe :: String -> b
02:26:56 <jle`> aw
02:27:25 <jle`> @let import Text.Read
02:27:26 <lambdabot>  Defined.
02:27:46 <jle`> > [ x | w <- words "123 456", Just x <- readMaybe w ]
02:27:48 <lambdabot>  error:
02:27:48 <lambdabot>      • Couldn't match expected type ‘[Maybe t]’
02:27:48 <lambdabot>                    with actual type ‘Maybe a0’
02:28:04 <jle`> hm
02:28:07 <jle`> > map readMaybe (words "123 456")
02:28:09 <lambdabot>  [Nothing,Nothing]
02:28:14 <jle`> oh
02:28:20 <jle`> > map readMaybe (words "123 456") :: [Maybe Int]
02:28:22 <lambdabot>  [Just 123,Just 456]
02:28:32 <jle`> > map readMaybe (words "123 456 notanumber 789") :: [Maybe Int]
02:28:34 <lambdabot>  [Just 123,Just 456,Nothing,Just 789]
02:29:23 <jle`> > words "123 456 notanumber 789"
02:29:26 <lambdabot>  ["123","456","notanumber","789"]
02:29:41 <jle`> readMaybe tries to parse the input string into the desired type and returns Nothing if it fails
02:30:17 <jle`> once you have a list of numbers, you can pattern match on the list to construct the tuple
02:42:56 <pavonia> Is there a way to make Parsec show the rest of the input stream if an error occurs?
02:47:07 <ertesx> pavonia: doesn't seem like it…  the lowest level parse function doesn't return the remainder, so any higher-level function won't either
02:47:20 <ertesx> (runParsecT)
02:48:50 <byorgey> ertesx, pavonia: that's not true, runParsecT does return the remainder.
02:48:51 <ertesx> pavonia: it does return the source position
02:49:13 <ertesx> byorgey: on error?
02:49:17 <lpaste> byorgey pasted “getting remainder from parsec” at http://lpaste.net/340005
02:49:45 <byorgey> oh... sorry, you're right, maybe not
02:49:48 <ertesx> byorgey: yes, on success
02:49:48 <sdx23> the question sounds familiar to me. You may be able to use errorPos.
02:50:05 <ertesx> yeah, the source position seems to be the only way
02:50:28 <byorgey> yeah, never mind, I misread the question.
02:52:22 <pavonia> The problem is I'm using a custom token stream and my positon calculation seems to be wrong somehow, it reports an error at a location that token isn't at. So it's really hard to debug this
02:55:03 <ertesx> pavonia: how do you plan to use the remainder of the input?
02:55:15 <sdx23> pavonia: this may be helpful http://ircbrowse.net/day/haskell/2016/07/20?id=23100741&timestamp=1469029822#t1469029822
02:56:11 <pavonia> ertesx: I just want to see a preifx of it to see where the error happens exactly
02:58:32 <ertesx> pavonia: i think megaparsec's error reporting is better, because it lets the Token instance handle source positions explicitly
02:58:53 <ertesx> pavonia: and it's similar to parsec enough that you can most likely just change the library dependency and import lines
03:01:04 <ertesx> i wouldn't be surprised if megaparsec does what you want by itself
03:04:23 <pavonia> Hhm, I'd rather not switch to another parser library dependency. Maybe I could use the user state for storing the last x tokens or so
03:08:29 * hackagebot cassava-conduit 0.3.5.1 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.5.1 (domdere)
03:32:18 <noze> when introducing recursion in an imperative language we often use as an example bool isPalindrome(char word[], int size). then we recurse over the size and the word.
03:32:18 <noze> now, what's a good way of isPalindrome :: [a] -> Bool as an example for recursion in a functional language?
03:32:18 <noze> NB: the imperative / functional here refers to the data structure, there's nothing inherent to haskell here
03:38:10 <EvanR> noze: f xs = reverse xs == xs
03:39:41 <noze> EvanR: that does twice as much work as the imperative version, and is hardly a demonstration of how to use recursion
03:40:07 <EvanR> i would say its the functional versional though
03:40:19 <EvanR> er, functional version
03:41:10 <EvanR> you could emulate the algorithm for isBalindrome(char word[], int size) with an array though
03:42:08 <ertesx> noze: first use a similar data type like Vector
03:42:15 <ertesx> noze: then use O(1) slicing for Vector
03:42:24 <ertesx> you basically get the same algorithm
03:42:38 <ertesx> (don't even need the size argument)
03:43:05 <EvanR> yeah, length :: Vector a -> Int
03:43:34 <EvanR> Text has the same slicing support
03:43:55 <ertesx> not quite…  Text slicing (with indices) is O(n)
03:44:02 <ertesx> it's still O(1) memory though
03:44:53 <ertesx> but actually you only need 'drop' and 'dropEnd', together with 'head' and 'last'
03:45:01 * EvanR is confounded by utf-16
03:45:06 <ertesx> which are all O(1)
03:45:10 <ertesx> (in this case)
03:46:16 <EvanR> but wait, if your implementation had a funny optimization for arrays which remembered if they were forward or backwards, reverse is O(1) and reverse xs = xs would work xD
03:47:41 <Rarrikins> You can probably do it by using the recursion as a stack to reverse a String.
03:47:43 <noze> please don't ignore the premises that (1) I want to use lists and (2) I want this to demonstrate recursion
03:48:44 <EvanR> hmm...
03:49:01 <lpaste> byorgey pasted “isPalindrome” at http://lpaste.net/340027
03:49:06 <byorgey> noze: here's how I would do it ^^^
03:49:18 <Rarrikins> > let isPalindrome :: String -> Bool; isPalindrome xs = fst $ go xs xs where go [] ys = (True, ys); go (x:xs) ys = let (r, (z:zs)) = go xs ys in (r && x == z, zs) in isPalindrome "aba"
03:49:20 <lambdabot>  True
03:49:57 <byorgey> though I think isPalindrome is not a great example with linked lists.  The recursion of isPalindrome doesn't match the recursive structure of a list.
03:50:18 <EvanR> heh Error: Unused LANGUAGE pragma
03:50:39 <byorgey> oh, whoops, I thought I was going to use that and then I didn't =)
03:50:54 <EvanR> error, never put stuff you dont use
03:51:10 <EvanR> dunno about "Error:"
03:51:15 <byorgey> and I *did* use an extension that I *didn't* write at the top (GADTs)
03:51:33 <ertesx> noze: then why don't you demonstrate an algorithm that actually works well on lists?
03:52:02 <ertesx> isPalindrome works great on Seqs and Vectors, but not on lists
03:52:12 <paolino> what is the difference between newtype Y = forall b . Y ((a -> b) -> b) and newtype Y = Y (forall b. (a -> b) -> b) ?
03:52:17 <lpaste> byorgey revised “isPalindrome”: “isPalindrome” at http://lpaste.net/340027
03:52:23 <EvanR> the slicing thing only works well in imperative languages for small sizes
03:52:47 <EvanR> for large strings, the same size we would question list "last" in, it will explode the call stack
03:53:23 <lyxia> paolino: the first one is morally Y (exists b. (a -> b) -> b)
03:57:49 <implementation> noze: common examples for beautiful recursions in haskell include fibonacci, eratosthenes' sieve or quicksort. they're amazingly simple in haskell and much clearer than in imperative programming :)
03:58:11 <paolino> lyxia I could make a functor for both, but not Applicative. Does it make sense ?
03:58:11 <paolino> not Applicative for the first
03:58:34 <ertesx> implementation: i would like to see that "beautiful" sieve or that beautiful "quicksort"
03:59:02 <ertesx> implementation: regarding the former: if it uses "mod" or "rem", it's not a sieve
03:59:18 <ertesx> implementation: regarding the latter: if it works on lists, it's not quicksort
03:59:28 <ertesx> and it most definitely is not "quick"
03:59:46 <ertesx> fibonacci i'm ok with =)
04:01:22 <quchen> Mergesort is a nice recursive algorithm that has relatively good performance on lists.
04:01:35 <ocramz> hi all
04:02:01 <quchen> And you can easily add a couple of shortcuts to make it perform better, which is what Data.List does.
04:02:45 <ertesx> here is an actual sieve of eratosthenes: http://lpaste.net/101980
04:03:16 <quchen> Slowsort is a nice recursive algorithm that has abysmal performance on lists, and one can easily add a couple of shortcuts to make it perform better (but still abysmal). ;-)
04:03:22 <implementation> point taken on the "sieve", it works with mod, but i still think it looks nice and clear and shows common concepts. regarding quicksort: of course it's still quicksort, quicksort essentially just means "grab a pivot, split the list into smaller and larger, and do the same recursively", now matter on what data structure you work or how you choose the pivot.
04:03:29 <ertesx> and here is a completely pure infinite stream version of it (which is of course much slower): https://github.com/esoeylemez/snippets/blob/master/PurePrimeSieve.hs
04:03:58 <grantwu> How do you efficiently grab a pivot from a list
04:04:12 <ertesx> implementation: one characteristic of quicksort is that it runs in O(n^2)
04:04:35 <ertesx> the "quicksort" for haskell lists doesn't do that
04:05:25 <ertesx> and personally i don't see any value in showing it other than giving a false first impression
04:06:03 <ertesx> i remember that it made me go: "wow, this looks nice", 20 minutes later: "wow, this sucks! haskell is useless for real code!"
04:07:29 <quchen> What’s haskellsort’s complexity?
04:07:41 <reygoch> is it possible to use language files in yesod url renderer?
04:07:42 <ertesx> (and then i learned it anyway, using the haskell road to logic of all things) =)
04:07:45 <quchen> Does it come with another factor n for traversing the conses?
04:08:20 <reygoch> I have master page that I define with "withUrlRenderer" function and I can't use i18 language definitions
04:08:29 <reygoch> within that url renderer
04:08:31 * hackagebot shikensu 0.1.0 - A small toolset for building static websites  https://hackage.haskell.org/package/shikensu-0.1.0 (icidasset)
04:08:48 <reygoch> I can use language variables just fine within widgets though
04:09:36 <ertesx> quchen: although i'm not 100% sure it's another full n, it does get an extra factor, but more importantly it doesn't perform like O(n * log n) on average the way quicksort does
04:10:32 <paolino> lists have not enough structure for sorting in n*log n ?
04:10:44 <implementation> you might be right about it not being O(n log n) in average, but it looks very O(n^2) in worst case to me
04:11:21 <quchen> paolino: Sure they do. You can convert a list to a vector in linear time and back, and vectors can be sorted in O(n log n).
04:11:51 <quchen> Unless the list is infinite, of course.
04:12:16 <paolino> that's a vector backend not a list
04:12:45 <quchen> It uses vector internally, so?
04:13:03 <paolino> it has more structure I guess
04:13:14 <ertesx> implementation: you might be right, considering that the first element is done in O(n^2), and at that point i think (!) only one traversal remains
04:14:00 <ertesx> regardless, i really don't like to show this code to beginners…  more to intermediates as a "how not to do it" example
04:14:01 <byorgey> why isn't it O(n log n) on average?
04:14:50 <byorgey> I also don't really like the quicksort example for Haskell, but I don't see why it's not O(n log n).
04:16:10 <byorgey> partitioning takes O(n), whether you have to traverse the list once or twice or whatever.  appending the recursively sorted lists takes another O(n).  And if the list gets split in half every time, you have a recursion tree of depth log n, with O(n) partitioning/appending work done on each level
04:19:58 <byorgey> empirically, it runs almost instantly on random lists of length 100000, so it can't possibly be more than O(n log n).
04:20:30 <paolino> byorgey, correct, so the inefficiency is high multiplicative factor for the n * log n ?
04:20:31 <byorgey> and yes, I forced all the computation to happen =)
04:20:37 <byorgey> paolino: sure
04:20:47 <grantwu> Also the fact that you can't really select a good pivot
04:20:59 <byorgey> grantwu: why not?
04:21:15 <quchen> ertesx: Wait, everything about your profiles says you’re in Germany. Did we meet in Munich, London, Zürich?
04:21:27 <grantwu> Well... what sort of pivot selection strategy do you have in mind?
04:21:32 <grantwu> Random selection is out, at least
04:22:00 <quchen> Median of medians is feasible
04:22:34 <byorgey> grantwu: ok, fair enough re: random.  But yes, you could do median of medians.  Though of course there's no point since this algorithm doesn't fit nicely in Haskell anyway.
04:23:15 <grantwu> Hrm, yes, I forgot about median of medians
04:23:25 <ertesx> byorgey: i think you're right
04:23:44 <ertesx> i take it back, it's just a bad implementation of quicksort then
04:24:12 <ertesx> quchen: more likely in stuttgart
04:24:38 <byorgey> indeed =)  the thing I don't like about it is that it obscures the really clever bit about quicksort, which is that it can be done completely in-place in a mutable array
04:24:55 <ertesx> quchen: but i haven't visited any haskell-specific events
04:25:20 <grantwu> So stackoverflow tells me that in place mergesort exists
04:26:29 <quchen> You still need linearly much extra space to copy things around, but yes
04:26:39 <byorgey> grantwu: wow, I would be interested to know how that works.  Link?
04:27:17 <grantwu> http://stackoverflow.com/questions/2571049/how-to-sort-in-place-using-the-merge-sort-algorithm
04:27:25 <kuribas> The point is that you can use easy but less efficient for most of the code, and safe the ugly performant bits for bottlenecks.
04:27:33 <kuribas> s/safe/save
04:27:41 <ertesx> byorgey: and although it's longer, mergesort in my opinion is still a beautiful example of recursion, and it also shows how to split a list in two cleverly =)
04:27:49 <orion> Why is lambda calculus called a calculus? I thought calculus was about derivatives, integrals, systems of PDEs, etc.
04:27:57 <kuribas> The easier code might be better to understand and less error prone.
04:28:07 <quchen> Differential calculus is about derivatives, integrals, systems of PDEs, etc.
04:28:17 <byorgey> ertesx: agreed!
04:28:18 <quchen> Lambda calculus is about functions and stuff.
04:28:32 * hackagebot shikensu 0.1.1 - A small toolset for building static websites  https://hackage.haskell.org/package/shikensu-0.1.1 (icidasset)
04:28:34 <quchen> SKI calculus is about lots of S K I.
04:28:39 <ertesx> grantwu: "in place" and "lists" never go well together…  there are cases when it works, but you need to rely on the compiler doing smart garbage collection
04:28:40 <grantwu> orion: There are a lot of random calculuses that have nothing to do with "high school calculus"
04:28:52 <orion> So, what is the definition of bare "calculus"?
04:28:53 <grantwu> ertesx: No, not with lists, with mutable arrays
04:29:01 <ertesx> ah
04:29:03 <grantwu> orion: There isn't one, really
04:29:15 <orion> I see.
04:29:27 <ertesx> orion: "calculus" often just refers to symbolic manipulation
04:29:28 <grantwu> Well, it depends on who you're talking to
04:29:33 <quchen> It’s “lambdacalculus”, not “lambda and calculus”. :-)
04:29:50 <ertesx> orion: that's most likely also why differentiation/integration is called calculus: it's completely symbolic
04:30:05 <grantwu> orion: See the last sentence of the intro to https://en.wikipedia.org/wiki/Calculus
04:30:14 <orion> Thanks.
04:30:20 <kuribas> Is there a usecase where lazy foldl is better than foldl'?
04:30:46 <grantwu> In general, for most people calculus = differential/integral calculus
04:30:48 <hpc> it's possible to contrive an example where foldl' produces bottom where foldl doesn't
04:31:06 <ertesx> kuribas: in other words: no =)
04:31:15 <sdx23> kuribas: hardly. Either it's artificial or you'd rather write it as explicit recursion.
04:31:38 <hpc> it's rare when you want a left fold anyway
04:31:47 <kuribas> hpc: I use it all the time...
04:32:03 <kuribas> ertesx: why haven't they changed in the base libraries then?
04:32:11 <kuribas> make foldl == foldl'
04:32:40 <ertesx> kuribas: history
04:32:52 <kuribas> ertesx: would changing it break code?
04:33:00 <ertesx> kuribas: more likely the opposite =)
04:33:09 <kuribas> unbreak code :)
04:33:23 <ertesx> it should be changed
04:34:02 <kuribas> it's annoying having to import Data.List for foldl'
04:35:45 <ertesx> import Data.Foldable instead
04:36:11 <pavonia> In Parsec's Reply type, what does the ParseError part of the Ok constructor denote?
04:36:14 <sdx23> I was honestly suprised it's not changed yet in foundation.
04:37:07 <ertesx> to me the most annoying thing is that i can't rely on things like 'sum' and 'product'
04:37:20 <ertesx> i end up writing (foldl' (+) 0)
04:37:26 <kuribas> ertesx: why not?
04:37:42 <ertesx> kuribas: because they are defined in terms of foldl
04:37:47 <ertesx> by default
04:37:51 <kuribas> @src sum
04:37:51 <lambdabot> sum = foldl (+) 0
04:38:04 <kuribas> ertesx: :-O
04:38:11 <ertesx> that one is outdated
04:38:17 <ertesx> sum is now a member of Foldable
04:38:25 <ertesx> Foldable instances can override it, but i don't want to rely on that
04:38:43 <kuribas> ertesx: well it may make sense for a foldable.
04:39:00 <kuribas> :t sum
04:39:02 <lambdabot> (Foldable t, Num a) => t a -> a
04:39:16 <ertesx> in fact the newer sum is a foldr by default
04:39:22 <ertesx> because it's defined in terms of foldMap
04:39:26 <ertesx> and that one is foldr by default
04:39:46 <kuribas> ertesx: unless Num is always strict...
04:40:05 <ertesx> sum for [] is still foldl though…  it overrides it
04:41:38 <ertesx> short version: to be safe use (foldl' (+) 0)
04:57:35 <drdo> Is there a GHC extension that allows multiple constructors with the same name ?
05:01:59 <amx> I seem to misunderstand how GADTs can provide contexts where the constructed data type is used, because I assumed this would work: http://lpaste.net/340046
05:03:54 <ertesx> amx: that's an ADT using GADT syntx
05:03:56 <ertesx> syntax
05:04:08 <ertesx> ah, no, there is the (Eq k) constraint
05:04:36 <ertesx> amx: to get type refinement you have to pattern-match
05:04:51 <chelfi> wouldn't you need to explicitely pattern match to know which branch (the only one) is selected ?
05:04:58 <amx> ok I see
05:05:11 <ertesx> amx: i.e. try _fsmRead (msg@MemoryStore{}) …
05:05:12 <hpc> that constraint isn't part of GADTs
05:05:58 <ertesx> amx: but this use case seems rather pointless to me
05:06:24 <ertesx> the _fsmRead function should really just have an Ord constraint (Eq is hardly sufficient for anything with Map)
05:07:43 <amx> it was more of academic interest, because I have some far more complicated code where the contexts are provided
05:07:44 <hpc> oh huh, you can get GADT-y benefits from class constraints
05:07:45 <hpc> TIL
05:07:58 <hpc> you do just need to pattern match it then, yes
05:07:59 <amx> and I use RecordWildCards there, so that's why it works
05:08:25 <ertesx> amx: follow this rule of thumb: if your type has only one constructor, you probably don't want GADTs
05:09:01 <ertesx> if your goal is to save typing large constraints, use a type synonym instead
05:09:12 <ertesx> together with -XConstraintKinds
05:10:12 <hpc> i can see wanting that if you're designing your code from the perspective of what API it provides, but that's still getting way deep into the minutia of your type signatures
05:10:42 <ertesx> abusing GADTs to communicate constraints only makes the function types more obscure
05:11:25 <hpc> yeah, it'd be pretty rare to want it anyway
05:13:34 * hackagebot shikensu 0.1.2 - A small toolset for building static websites  https://hackage.haskell.org/package/shikensu-0.1.2 (icidasset)
05:14:58 <hpc> hmm...
05:15:11 <hpc> with constraint kinds, i wonder if it's possible to do GADT matching on class constraints
05:16:13 <hpc> data Foo (a :: * -> Constraint) b where EqFoo :: Eq b => b -> Foo Eq b
05:17:11 <amx> thanks for your help
05:18:26 <hpc> ooh, you can
05:18:34 * hackagebot parsec-extra 0.2.0.0 - Some miscellaneous basic string parsers.  https://hackage.haskell.org/package/parsec-extra-0.2.0.0 (AriePeterson)
05:18:39 <hpc> needs GADTs, ConstraintKinds, KindSignatures
05:18:50 <hpc> and on my version of ghc import GHC.Exts
05:20:05 <ski> @let data IsEq :: (* -> Constraint) -> * where ItsEq :: IsEq Eq
05:20:06 <lambdabot>  Defined.
05:20:08 <ski> @type let foo :: c k => IsEq c -> k -> [(k,v)] -> Maybe v; foo ItsEq = lookup in foo
05:20:09 <lambdabot> c k => IsEq c -> k -> [(k, v)] -> Maybe v
05:21:19 <hpc> @type let foo :: c k => IsEq c -> k -> [(k,v)] -> Maybe v; foo ItsEq = lookup in foo ItsEq
05:21:20 <lambdabot> Eq k => k -> [(k, v)] -> Maybe v
05:21:58 <mpickering> Does anyone know why the list-transformer library is implemented using concrete data types rather than continuations (like the logict library)?
05:22:15 <mpickering> It seems to me that the logict imlementation is better for most uses and much less easy to blow the stack
05:22:28 <hpc> mpickering: historical reasons
05:23:06 <hpc> LogicT hadn't been discovered yet, or its application to "make ListT actually work" wasn't known, would be my guess
05:23:22 <hpc> a similar thing happened with Functor, Applicative, Monad
05:23:34 <hpc> Applicative was the last one to be added to the language
05:23:48 <ski> (library)
05:24:00 <mpickering> there isn't much discovery to be done. logict predates the list-transformer package
05:24:02 <mpickering> https://hackage.haskell.org/package/logict-0.6.0.2/docs/Control-Monad-Logic.html#t:LogicT
05:24:15 <hpc> ski: it's in the language standard ;)
05:24:28 <hpc> unless i am horribly mistaken
05:25:02 <ski> hm, what should one say to indicate the language proper, as opposed to standard library ?
05:25:31 <hpc> mpickering: ListT is also in mtl and transformers
05:25:41 <mpickering> It is wrong though!
05:26:01 <mpickering> Pipes is also implemented in this inefficient style, it would be much more efficient implemented with continuations
05:26:02 <Polymorphism> Is someone able to assist me in adding some simple functionality to this program? I would like it to identify with services upon connection to server: http://hub.darcs.net/simon/rss2irc/browse/Irc.hs
05:26:08 <hpc> mpickering: what i mean is mtl/transformers both predate logict
05:26:24 <mpickering> and I'm specifically talking about the "list-transformer" package 
05:26:32 <mpickering> which I thought was the accepted "right" implementation
05:27:45 <jchia_3> Hi, what's the '|' and '<-' in the code for cpure here? http://hackage.haskell.org/package/distributed-closure-0.3.3.0/docs/src/Control-Distributed-Closure-Internal.html
05:28:34 * hackagebot aeson-value-parser 0.11.4 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.11.4 (NikitaVolkov)
05:28:36 * hackagebot aeson-json-ast 0.1.1 - Integration layer for "json-ast" and "aeson"  https://hackage.haskell.org/package/aeson-json-ast-0.1.1 (NikitaVolkov)
05:28:58 <amx> mpickering: this package claims to be right ;) http://hackage.haskell.org/package/list-t
05:29:21 <mpickering> the implementation looks like the same as list-transformer
05:29:33 <mpickering> jchia_3: It is a pattern guard
05:29:51 <liste> jchia_3: that's a pattern guard https://wiki.haskell.org/Pattern_guard
05:30:26 <liste> jchia_3: it makes the pattern match if "unclosure cdict" is Dict
05:32:05 <jchia_3> Thanks. I only learned old-school guard from LYAH. I'm going to have to learn pattern guards now.
05:33:34 * hackagebot json-pointer-aeson 0.1.1 - Integration layer for "json-pointer" and "aeson"  https://hackage.haskell.org/package/json-pointer-aeson-0.1.1 (NikitaVolkov)
05:34:38 <ski> jchia_3 : it's just matching an arbitrary expression to a pattern in the pattern guard. if the match succeeds, it commits to that branch, otherwise tries next (pattern or vanilla) guard ior defining equation
05:36:01 <jchia_3> OK
05:39:39 <Polymorphism> Is someone able to assist me in adding some simple functionality to this program? I would like it to identify with services upon connection to server: http://hub.darcs.net/simon/rss2irc/browse/Irc.hs
05:41:39 <Polymorphism> any of the 1548 here know how to do this
05:48:15 <orion> Given this definition of Head Normal Form: http://i.imgur.com/S73PRS8.png Why is this equation: http://i.imgur.com/5koVLIs.png considered to be in HNF?
05:49:32 <orion> I would have expected the lone/bound x to be a y if it were in HNF/
05:49:39 <orion> a free y
05:51:50 <sdx23> Polymorphism: Questions to guide you: How do you usually identify? How would the Bot do this? At which point should it do so?
05:52:07 <int-e> orion: there's no distinction between bound and free variables when it comes to head normal forms.
05:53:25 <Polymorphism> sdx23: I identify by sending a message to nickserv, perhaps trhe bot could identify during connection though
05:55:00 <sdx23> Polymorphism: freenode supports supplying the password as server-password. You could figure out how this is done in IRC. Or simply send a privmsg to nickserv.
05:55:19 <danilo2> Hello guys! Which library do oyu recommend to generate xml files? I want just to convert my datatrucutres to some XML format and I want to stay with some well-written lib here
05:55:24 <orion> int-e: Why?
05:55:48 <byorgey> orion: I think in that definition, y can be any variable.  It doesn't have to be different than the bound variables.
05:56:25 <Polymorphism> sdx23: I'll give the former a try
05:57:36 <orion> I see.
05:57:49 <int-e> orion: it's a definition; in fact the usual definition is in terms of head positions (a head normal form is a term that has no beta redex in head position... so now you have to check whether \x.x ((\x.x x) (\x.x x)) or x ((\x.x x) (\x.x x)) are beta redexes, and they are not.
06:05:57 <pavonia> Just for the record, you can print parts of the input stream or the user state in error messages in Parsec if you redefine tokenPrim via mkPT
06:19:43 <haskell114> guys how can i make a function that receive a [String] and we want to produce a pair of Ints, like (Int, Int)?
06:20:27 <ski>   myFunction :: [String] -> (Int,Int)
06:20:33 <ski>   myFunction s = ..s..
06:21:00 <capisce> myFunction = const (0,0)
06:21:27 <ski> haskell114 : do you have some code you'd like suggestions with ?
06:21:37 <ski> haskell114 : what is the function supposed to do ?
06:22:03 <haskell114> but that [String] has ' ' and i want just the Ints not the spaces
06:22:19 <M2tias> he wants: "1 2" -> (1,2)
06:22:33 <M2tias> oh wait, a list of strings?
06:22:39 <haskell114> y
06:22:50 <M2tias> can you explain what the function does?
06:24:58 <haskell114> yeah it is a function that you have a list of strings, like [[! 1 2 3], [+ 4 6 7] and I want just the first 2 Ints 
06:25:19 <haskell114> and remove the spaces too
06:27:35 <haskell114> can you solve this problem?
06:28:07 <lyxia> [[! 1 2 3], [+ 4 6 7]   <- how is that a list of strings
06:28:32 <lyxia> By first two ints, do you mean 1 and 2?
06:28:40 <haskell114> y
06:29:07 <haskell114> and remove the spaces between them
06:29:14 <M2tias> haskell114: do you mean ["! 1 2 3", "+ 4 6 7"]
06:29:30 <haskell114> y
06:29:38 <M2tias> you have to be precise...
06:30:00 <mlehmk> [[! 1 2 3], [+ 4 6 7] looks like a list of lists
06:30:14 <M2tias> mlehmk: it's a list of char lists perhaps
06:30:37 <mlehmk> anyways [! 1 2 3] looks like wrong syntax
06:31:01 <haskell114> sry but i forgot the commas
06:31:10 <mlehmk> if it doesn't start with a lowercase letter or _ then it might just be an infix operator
06:31:35 <mlehmk> even with commas [!, 1, 2, 3] it still doesn't look valid
06:31:46 <haskell114> it is a function that you have a list of strings, like [[!, ,1, ,2, ,3], [+, ,4, ,6, ,7] and I want just the first 2 Ints
06:31:59 <mlehmk> though in that case the match (_:a:b:_) would get you the two integers in a and b
06:32:21 <mlehmk> well, I dunno what [1, ,2] would be
06:32:38 <M2tias> mlehmk: don't be so mean, he's just a kid trying to learn Haskell
06:32:38 <mlehmk> the second element is missing in the list
06:33:02 <younder> Doeas anyone know of any paper of applying linear logic to reasoning over monads?
06:33:47 <ski> applying how ?
06:33:58 <tsahyt> @hoogle m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)
06:34:00 <lambdabot> Data.Tuple.HT mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
06:34:01 <lambdabot> Data.Tuple.Lazy mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
06:34:01 <lambdabot> Data.Tuple.Strict mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
06:34:02 <younder> As in proof construction
06:34:16 <tsahyt> hmm. is there a way to neatly compose functions that return Maybe in a monad?
06:34:29 <ski> iiuc, "why not", `?', is a (particular) monad
06:34:40 * ski isn't sure what younder means, though
06:34:44 <tsahyt> I suppose I can construct something with fmap and bind but is there something that does this for me already?
06:34:53 <drdo> tsahyt: >=> ?
06:34:59 <ski> tsahyt : `(<=<)' or what drdo said ?
06:35:20 <tsahyt> but that won't unwrap the Maybe result of the left/right (first) operand, will it?
06:36:02 <tsahyt> i.e. I'd need foo :: (a -> m (Maybe b)) -> (b -> m (Maybe c)) -> (a -> m (Maybe c))
06:36:21 <tsahyt> which also carries on failure
06:36:34 <mlehmk> Maybe in a Monad?
06:36:39 <mlehmk> Maybe is a Monad
06:36:44 <ski> tsahyt : use `MaybeT' ?
06:36:50 <younder> ski: It is more that  the statewise nature of linear logic seems a good match for monads states. The fact that a variable can be used only once and is then  consumed.
06:36:58 <drdo> tsahyt: That is exactly the type of >=>
06:37:04 <ski> younder : what is "monads states"
06:37:14 <Polymorphism> I can['t figure it out
06:37:16 <drdo> oh, you have this extra monad
06:37:19 <tsahyt> yep
06:37:21 <Polymorphism> anyone already know how to do this?
06:37:32 <younder> ski: ok llike a IO monad. each <-
06:37:53 <ski> younder : sure, you can build a monad over a unique state being threaded .. but that's not about monads in general, it's about state
06:38:10 <ski> (also, it's *unique* state, uniqueness, not linearity)
06:38:12 <tsahyt> this is also for a one-off function, so building up and tearing down MaybeT for it is overkill I think
06:38:37 * hackagebot time-warp 0.1.1.2 - Distributed systems execution emulation  https://hackage.haskell.org/package/time-warp-0.1.1.2 (jagajaga)
06:38:52 <younder> ski: to me more how monads introduce order. Whereas lazy evaluation can happen in any order (sort of)
06:38:55 <tsahyt> unless I'm missing something of course
06:39:19 <Polymorphism> sdx23: do you know how to implement that in haskell?
06:39:23 <ski> younder : hm, ok. but linearity (nor uniqueness) doesn't imply (total) order
06:39:28 <Polymorphism> I've never used this language I'm not sure what lib he is using etc
06:39:45 <Polymorphism> the repair of this broken bot seems like it would benefit many
06:39:48 <ski> tsahyt : i'm not sure it's overkill, if it's the behaviour you want
06:39:59 <tsahyt> I'll try it and see how large it gets
06:40:15 <ski> tsahyt : more like a concise way of specifying that behaviour, in a way that readers will easily grasp (assuming they've seen `MaybeT')
06:41:19 <younder> ski: all reasoning over arrays have total order. At least as far as set theory is concerned.
06:41:25 <Polymorphism> what do you all charge for an hour of labor?
06:41:43 <t0by> depends on the labor, I guess.
06:41:47 <mlehmk> sometimes I wonder why something is even developed in Haskell if most of the functions are like :: ... -> IO ()
06:41:47 <ski> imho, `runMaybeT . ((MaybeT . foo) >=> (MaybeT . bar))' would be reasonable
06:42:29 <ski> younder : yes, but you can easily have multiple arrays, whose accesses aren't (for the most part) ordered wrt to each other
06:42:39 <Polymorphism> http://hub.darcs.net/simon/rss2irc
06:42:44 <ski> e.g. in Clean or Mercury, which have uniqueness
06:42:45 <Polymorphism> I need the bot to identify to services as soon as it connects
06:43:48 <t0by> Polymorphism, sorry, it's not clear to me, are you looking for help or for somebody to actually do it on your behalf?
06:43:49 <tsahyt> this might be a stupid question but how do I embed a function returning a Maybe in a Monad into MaybeT now? i.e. I have something foo :: Monad m => Foo -> m (Maybe Bar). how do I get this into foo' :: Monad m => Foo -> MaybeT m Bar
06:43:50 <mlehmk> Polymorphism, what of that code do you not understand?
06:44:02 <mlehmk> Polymorphism, and what have you tried?
06:44:03 <tsahyt> I just realized that I always avoided MaybeT for some reason
06:44:49 <tsahyt> should I just use the constructor?
06:45:16 <Polymorphism> mlehmk: its just overwhelming as a whole. I'm not even sure what library is being used to connect to the server
06:45:44 <Polymorphism> I've tried going over the code trying to find where I could add the option for a password
06:46:04 <t0by> Polymorphism, have you ever dealt with *any* functional language?
06:46:14 <t0by> I think I could be willing to have a go at it
06:46:24 <t0by> I can't promise anything *right now*
06:46:31 <Polymorphism> t0by: no
06:46:37 <ahihi> the cabal file tells you the library: irc >= 0.6 && < 0.7
06:46:45 <Polymorphism> I have intermediate knowledge of C++/C#
06:46:47 <t0by> Well, that's not a good start.
06:46:54 <Polymorphism> thats my only experience right now
06:47:08 <t0by> I wouldn't start learning haskell by hacking that thing.
06:47:26 <t0by> Polymorphism, if you actually want the job done I could have a go myself.
06:47:27 <younder> ski: As I see it modads (and monoids) in haskell are all over totally ordered sets.  So more restricted than the more general definition of category.
06:47:28 <t0by> PM me.
06:47:39 <tsahyt> @hoogle Monad m => m (Maybe a) -> MaybeT m a
06:47:40 <lambdabot> Control.Monad.Run mayswitch :: (Monad m) => [MaybeT m b] -> m b -> m b
06:47:40 <lambdabot> Control.Monad.Trans.Maybe mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b
06:47:40 <lambdabot> Control.Error.Util hushT :: (Monad m) => ExceptT a m b -> MaybeT m b
06:47:42 <t0by> Polymorphism, if you want to *learn* Haskell, on the other hand...
06:47:59 <tsahyt> hmm, using the constructor like that seems wrong
06:48:05 <tsahyt> it does what I want, but still..
06:48:16 <Polymorphism> it almost seems like I could remake it more easily in C++
06:48:29 <Polymorphism> although I would think it wouldnt be a very complicated change to supply a password during the connection
06:48:33 <Polymorphism> I've been looking at that block of code
06:48:40 <Polymorphism> but I c an't find any docs for whatever library if any is being used
06:48:52 <sm> hi Polymorphism.. +1 for looking at this
06:49:05 <t0by> Polymorphism, I get it, don't worry. I can't look at it *right now* but if you have patience I could have a look tonight
06:49:16 <sm> scan the dependencies at http://hackage.haskell.org/package/rss2irc , you'll the irc lib
06:49:19 <sm> see
06:49:58 <t0by> sm: oh, are you the author?
06:50:00 <sm> so you'd need to add the identification feature to http://hackage.haskell.org/package/irc . Or, update rss2irc to use a better more modern irc library, which probably exists on hackage
06:50:25 <sm> t0by: one of them.. dons created it
06:50:32 <t0by> sm: neat!
06:50:39 <younder> ski: They  thus follow the producer -> consumer pattern in liner logic.
06:51:04 <Polymorphism> ok, I will take a look at this
06:51:09 <Polymorphism> ty
06:52:04 <sm> it may not need any new feature, just to send the right string(s) at the right time..
06:52:13 <younder> ski: I wish to use this to reason, using Isabelle/Haskabelle, over character streams for use in my compiler.
06:52:35 <ski> tsahyt : "should I just use the constructor?" -- yes, as i indicated
06:53:14 <ski> younder : "all over totally ordered sets" doesn't make sense to me
06:53:32 <ski> younder : nor do i know what you mean by "more restricted than the more general definition of category"
06:54:01 <Polymorphism> privmsg :: ByteString -> ByteString -> Message seems to be available
06:54:20 <Polymorphism> I could send the message to nickserv 
06:54:39 <Polymorphism> not seeing much about identifying during connection
06:54:48 <Polymorphism> were you saying thats not a feature supported by this library
06:55:21 <sm> Polymorphism: I was thinking that, but actually no feature is needed
06:55:45 <sm> I'm sure however you would do it as a user or IRC client, rss2irc can do using the irc lib
06:55:56 <ski> younder : you may to some extent be confusing a specific monad (state monad) with monads in general (?)
06:57:16 <younder> ski: Well I have been following "Introduction to lattices and order by  David Priestly" and "A taste of linear logic by Philip Wadler"
06:58:18 <ski> younder : one could say that monads (and monoids, and also applicative functors) in general is about ordering, but it's easy (i think) to misunderstand in what sense
06:58:38 <younder> ski: Perhaps I will just work on it for a while and than I will see wether it is you who is confused or me :)
06:58:39 <ski> (or replace "is about" with "could be viewed as being about", if you prefer)
06:59:34 <ski> consider monoids, you have (in Haskell notation) a binary operation `(<>)', and a neutral element `empty'
07:00:01 <ski> being a neutral element for the binary operation means that `empty <> y = y' and `x = x <> empty', for all `x' and `y'
07:00:30 <ski> also, `(<>)' needs to be associative : forall `x',`y',`z', `(x <> y) <> z = x <> (y <> z)'
07:01:49 <ski> the effect of these requirements is exactly that you can take *any* (finite) (possibly empty) list of elements, and intersperse `<>' inbetween the elements, and bracket/group them to disambiguate *however you like*, and you'll get the same result (if you have the empty list, then you give `empty')
07:01:49 <sm> Polymorphism: yes, privmsg to nickserv sounds good, somewhere after http://hub.darcs.net/simon/rss2irc/browse/Irc.hs#47
07:02:13 <ski> @type mconcat
07:02:14 <lambdabot> Monoid a => [a] -> a
07:03:12 <ski> another way to state the monoid axioms/laws, is that `mconcat [x] = x', for all `x's, and also `mconcat (map mconcat xss) = mconcat (concat xss)', for all lists of lists of elements, `xss'
07:03:30 <Polymorphism> directly before joining the channel would be perfect
07:03:39 <sm> yeah
07:03:41 <ski> (that will perhaps in a clearer way explain why we want `empty' to be the result of "combining" zero elements)
07:04:01 <ski> younder : anyway, the point of this is that the list of elements that we combine is *ordered*
07:04:59 <ski> younder : for any *particular* monoid, the order might be .. "irrelevant", so to speak
07:05:14 <ski> if you're e.g. adding numbers, then it doesn't matter in which order you do that
07:05:41 <ski> but, the monoid laws *allow* depending on the ordering (but *not* on the grouping, that's what associativity says)
07:06:09 <ski> if you take the list monoid, then concatenation of lists isn't commutative, so there the ordering is not just apparent
07:07:17 <ski> younder : in a bit simular way, the concept of being a monad *allows* dependence on and expression of order, but any particular monad might ignore some or most of the ordering
07:07:34 <Polymorphism> privmsg :: ByteString -> ByteString -> Message could someone please explain what this is telling me about how to use this function
07:07:41 <ski> younder : .. is what i'm saying making any sense ? is it helping at all ?
07:07:59 <younder> ski: yes. I can understand it.
07:08:04 <sm> Polymorphism: it's a function taking two bytestring arguments and returning a message value. Look for other uses in the code
07:08:18 <Polymorphism> ok
07:08:39 <sm> you should probably use this wrapper: http://hub.darcs.net/simon/rss2irc/browse/Irc.hs#175
07:08:52 <younder> ski: But I still think I can apply linear logic to it.
07:09:03 <sm> eh.. maybe not
07:09:23 <ski> younder : one could say that monads allow expression of "dynamic sequencing", and idioms (aka applicative functors) of "static sequencing" .. these terms taken in a particular sense
07:09:52 <ski> younder : otoh, i don't really see that much how linear logic is related to ordering
07:09:59 <ski> younder : uniqueness a bit more, perhaps
07:10:15 <ski> but not total ordering (like in monoids, monads, idioms), but partial ordering
07:11:06 <younder> ski: well for a stream a element is consumed when it has been read.
07:11:30 <Polymorphism> Maybe I need to start with at the beginning with haskell. I was going to try to add support for multiple feeds + fix the crash issue next if I was able to add identification
07:11:36 <ski> younder : have you seen the wadler paper about session types and linear logic ?
07:11:48 <ski> younder : might be interesting to you
07:11:51 <younder> ski: no I haven't
07:12:16 * ski forgets the title atm
07:12:43 <sm> Polymorphism: you can do that too, but fixing things you need in a small project is a great way to learn haskell
07:13:15 <sm> did you get a REPL going yet ? stack ghci
07:13:38 * hackagebot lambdacube-compiler 0.6.0.0 - LambdaCube 3D is a DSL to program GPUs  https://hackage.haskell.org/package/lambdacube-compiler-0.6.0.0 (CsabaHruska)
07:13:41 <younder> ski: yes  I have it in the refrencs to the "A taste of linear logic paper"
07:13:53 <younder> ski: I'll take a look
07:13:56 <sm> Polymorphism: and stack comes from http://haskell-lang.org/get-started 
07:14:43 <ski> younder : anyway .. if one wants to be able to use update-in-place on e.g. arrays, but retain purity, then i think one wants uniqueness, not linearity
07:15:37 <ski> younder : uniqueness ensures that a reference (e.g. to an array) hasn't be copied/shared *yet* (in the past). linearity promises that the reference you got won't be shared in the *future* (but may have been in the past)
07:16:02 <ski> s/promises/requires/ rather, i suppose
07:18:06 <sm> Polymorphism: maybe: privmsg (B8.pack "Nickserv") (B8.pack $ "identify " ++ n ++ " " ++ thepassword)
07:20:29 <younder> ski: True. But ring buffers in streams don't require that. For general in-place array manipulations you are probaly right.
07:21:13 <younder> I shall assume no elements are dropped.
07:24:20 <Polymorphism> hmm, it didnt seemt o ike that
07:24:33 <Polymorphism> Irc.hs:46:12: Not in scope: `B8.pack'
07:25:30 <sm> Polymorphism: did you insert it between line 47 & 48 ? line 48 uses B8.pack
07:25:51 <sm> hmm
07:26:09 <Polymorphism> yes
07:26:35 <sm> perhaps you should paste it at http://lpaste.net
07:28:50 <Polymorphism> sm:  http://lpaste.net/7134223867324661760
07:31:27 * sm fights intero to the death
07:32:08 <ertes> does anyone know how much of a constant factor finger trees have compared to binary trees?
07:32:15 <ertes> i would imagine that finger trees are generally a bit more expensive
07:32:21 <ertes> use case: ropes
07:33:24 <ClaudiusMaximus> sm, Polymorphism you probably want to go via Text to encode as UTF-8, in case of non-ascii characters in thepassword...
07:36:05 <sm> Polymorphism: I don't get the error you mentioned, just: error: Variable not in scope: thepassword. Which is expected, you should write your password in double quotes. Also, I believe the first argument is who you're privmsg'ing to, which should be Nickserv not Polymorphism
07:38:39 * hackagebot console-program 0.4.2.0 - Interpret the command line and a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.2.0 (AriePeterson)
07:38:56 <Polymorphism> I was just putting it as my name for testing, I'll try putting the pass in quotes
07:39:35 <Lokathor> https://github.com/jameysharp/corrode/blob/master/src/Language/Rust/Corrode/C.md so this thing is totally wild, and also a literate haskell file that you can read along with.
07:40:55 <wagnerf> how can I know which version of a library i'm using  (Data.Binary.Get) ?
07:41:29 <Lokathor> wagnerf, it's based on the cabal file you're building the project with, or the stack lts you're building against
07:42:40 <wagnerf> Lokathor: I don't use cabal for now ; what does lts mean ?
07:43:11 <Lokathor> with stack, your projects are built with a thing called an lts, which is a big list of packages at specific versions that work well together
07:43:17 <Polymorphism> same error for me
07:43:22 <Polymorphism> must have to do with how I'm trying to compile
07:43:34 <Polymorphism> " debuild -i -us -uc -b"
07:44:00 <wagnerf> Lokathor: actually I'm just using "runhaskell". is it using "stack" ?
07:44:01 <Lokathor> wagnerf, of course, you also have a cabal file for projects built using stack, but then you don't need to specific specific version numbers, stack will figure out the version numbers
07:44:08 <Lokathor> oh i see
07:44:28 <wagnerf> Lokathor: sorry I'm very new to haskell
07:44:43 <Lokathor> no it's okay. you're using a version that's been installed with ghc i guess.
07:44:49 <wagnerf> yes
07:45:24 <sm> Polymorphism: I have no idea what you're doing now :)
07:45:38 <Lokathor> well, you can use "ghc-pkg list" and it will list what packages it has, though i don't know what package Data.Binary.Get is from off the top of my head
07:45:39 <Polymorphism> I was trying to just edit the irc.hs file and then rebuild the debian package
07:45:48 <sm> have to run, be back later. Good luck
07:45:52 <Polymorphism> ok, ty
07:45:56 <Polymorphism> I will be on this eve
07:46:52 <wagnerf> Lokathor: if I understand correctly, using cabal will download another set of libraries ?
07:47:37 <Lokathor> well, i'd suggest following a stack tutorial and using stack, which builds upon the file format that cabal uses, but manages the packages more cleanly in a more automatic way
07:48:15 <Lokathor> if you google "haskell stack tutorial" you can find some written tutorials as well as a youtube video about it
07:48:53 <wagnerf> Lokathor: thanks
07:49:38 <sm> ps thanks ClaudiusMaximus, you're probably right
07:49:52 <wagnerf> Lokathor: also, I found Data.Binary.Get in the binary "package" (of ghc) (and it is too old for me)
07:50:16 <Lokathor> ah
07:50:21 <Polymorphism> I'm still erroring out before that either way
07:50:53 <Lokathor> well stack might be able to safely allow you to use a newer version, but ghc on its own isn't so smart about that sort of thing I'm afraid
07:50:53 <TallerGhostWalt> I can't seem to get any of the arguments to haddock passed through stack.
07:51:10 <TallerGhostWalt> stack haddock --haddock-arguments "-odir=docs"
07:51:14 <TallerGhostWalt> doesn't do anything
07:51:47 <Lokathor> TallerGhostWalt, try "stack exec haddock -- -odir=docs" maybe?
07:52:12 <Polymorphism> do I need to indent something differently
07:52:41 <Polymorphism> dont seem to need semicolons
07:53:39 * hackagebot lambdacube-ir 0.3.0.1 - LambdaCube 3D intermediate representation of 3D graphics pipelines  https://hackage.haskell.org/package/lambdacube-ir-0.3.0.1 (CsabaHruska)
07:53:47 <Welkin> Polymorphism: in what?
07:54:40 <TallerGhostWalt> Lokathor: no luck I guess it just finished immediately
07:54:43 <Polymorphism>  debuild -i -us -uc -b
07:54:43 <Polymorphism> Irc.hs:46:37: Not in scope: `B8.pack'
07:54:43 <Polymorphism> /usr/share/cdbs/1/class/hlibrary.mk:120: recipe for target 'build-ghc-stamp' failed
07:55:01 <Polymorphism> code line 47 Welkin http://lpaste.net/7134223867324661760
07:55:59 <Welkin> Polymorphism: import qualified Data.ByteString.Char8 as B8
07:56:00 <sm> Polymorphism: oh. I was looking at http://hub.darcs.net/simon/rss2irc/browse/Irc.hs , which is newer than what you're building, sorry 
07:56:02 <Polymorphism> line 46 actually
07:56:12 <Welkin> Polymorphism: you never imported the module
07:56:31 <sm> the import is at http://hub.darcs.net/simon/rss2irc/browse/Irc.hs#17
07:56:52 <Polymorphism> aha
07:56:54 <Polymorphism> thank you
07:57:06 <erisco> data IList a b = Cons a (IList b a) | Nil
07:57:52 <Polymorphism> so many errors @_@
07:58:01 <sm> welcome to GHC :)
07:58:05 <Polymorphism> I'll be back later, looks like this is a lot more complicated than I imagined
07:58:06 <erisco> I wonder why I don't see more types like that
07:58:08 <Polymorphism> thx, heh
07:58:16 <Welkin> you can avoid all errors
07:58:20 <sm> thepassword is not defined.
07:58:23 <Welkin> if you carefuly construct your types
07:58:28 <Polymorphism> I put it in quotes sm
07:58:28 <Welkin> I have done it before
07:58:35 <Welkin> I wrote my whole program out on paper and then typed it in
07:58:39 <erisco> and if you sufficiently narrow what you mean by "error"
07:58:40 <Welkin> worked perfectly on the first try
07:58:42 <sm> not in http://lpaste.net/7134223867324661760
07:58:54 <Welkin> that was a fun time
07:59:02 <Welkin> and it was using netwire, too
07:59:06 <Welkin> I was so surprised it worked
07:59:18 * ski . o O ( `SwapList' )
07:59:42 <Polymorphism> http://lpaste.net/6363606352446619648
07:59:44 <Polymorphism> thats my current code
08:00:39 <sm> Polymorphism: ok.. that looks wrong but at least compilable ?
08:01:10 <Polymorphism> Irc.hs:47:3: Couldn't match expected type `IO a0' with actual type `Message'
08:01:11 <Polymorphism> etc
08:01:24 <sm> aiee
08:01:51 <erisco> hm, fascinating... you can use type families in data declarations
08:01:55 <erisco> do you know what this means ski?
08:02:10 <ski> hm ?
08:02:17 <Welkin> sm: was that a squeal?
08:03:05 <erisco> data RList a = Cons (Head a) (RList (Rot a)) | Nil   where Head takes the first of a type list and Rot rotates the elements to the right by 1
08:03:14 <Polymorphism> my message must be in the wrong format
08:03:20 <erisco> is this really going to work out? oO
08:03:40 * hackagebot lambdacube-gl 0.5.1.2 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.5.1.2 (CsabaHruska)
08:03:58 <ski> erisco : try it ?
08:04:20 <erisco> I have implicit confidence
08:06:15 <erisco> it feels like there is something interesting to be had
08:12:49 <wagnerf> so I'm trying stack to compile my code. I get a "plan construction failed" with the following message :  binary-0.8.3.0 must match >=0.8.4.0 (latest applicable is 0.8.4.1)
08:14:57 <lyxia> Your resolver has only binary-0.8.3.0, but your project depends on a newer version.
08:15:05 <sm> Polymorphism: stick this in front of privmsg: ircWrite opts bot $ B8.unpack $ encode $ 
08:15:16 <erisco> oh lambdabot does not have injective type families :(
08:15:34 <wagnerf> lyxia: what is the way to update binary ? I kindof naively thought stack would do that for me
08:16:51 <grantwu> Well, you should probably first figure out why you have a dependency on a newer version, and then try to pick a newer resolver, keeping care to see if you're going to hit any breaking changes
08:17:32 <mmaruseacph2> well, stackage only has binary-0.8.3
08:17:35 <erisco> it most certainly does work though... I made a list with increasingly sized tuples
08:17:46 <wagnerf> grantwu: well : I chose the dependency myself because the feature I want is only in the newer version. what is a resolver ?
08:18:11 <erisco> well, they are nested 2-tuples, but same effect
08:18:41 <lyxia> wagnerf: you can add binary-0.8.4.1 in the extra-deps field of your stack.yaml
08:20:22 <wagnerf> lyxia: hey it works ! thanks
08:22:01 <lyxia> wagnerf: the resolver resolves package versions. The default resolver uses a fixed set of package versions curated by stackage.
08:23:41 <lyxia> Stackage's snapshot evolves slowly to ensure that all packages it includes build together.
08:24:01 <wagnerf> ok that's clear
08:24:03 <erisco> someone is going to figure out something great with this... my mind is drawing blanks
08:25:08 <Boomerang> I like the SwapList example, how about a "FlipTree": data FlipTree a b = Leaf a b | Node (FlipTree a b) (FlipTree b a) deriving Show
08:25:35 <erisco> that is small potatoes in comparison to what you can do with type families
08:25:57 <erisco> any injective functional relation can be used
08:26:15 <Boomerang> I'm still pretty new to type families, any good resources you would recommend to learn more about it?
08:26:31 <erisco> do you know how to write functions?
08:27:33 <Welkin> type families on the wiki
08:27:34 <Boomerang> Yes! In your earlier example where do Head and Rot come from? Are you defining them separately?
08:27:42 <ski> yes
08:27:49 <Welkin> https://wiki.haskell.org/GHC/Type_families
08:28:11 <Boomerang> Thanks! :)
08:28:18 <erisco> type families are just functions, only they're functions on types, and Haskell uses a different syntax for them
08:28:38 * ski . o O ( `data PerfectlyBalancedBinaryTree a = Elems a | Double (PerfectlyBalancedBinaryTree (a,a))' )
08:29:26 <erisco> so you might write a value function  f X = Y   ... to do similarly with type families you write   type family F a where F X = Y   (assuming X and Y's are types in this latter example)
08:29:47 <erisco> this is particularly closed type families
08:30:15 <erisco> you can also have open type families, which means you give the cases ad-hoc
08:30:18 <jophish> Is there a quasiquoter for raw strings which 'deindents' them?
08:30:21 <jophish> I'm sure I've seen this
08:30:43 <erisco> type family F a;  then somewhere else   type instance F X = Y;    I might have the syntax slightly off seeing as I never use these
08:31:20 <erisco> then for injective type families you write   type family F a = b | b -> a where ...    like functional dependencies for type classes
08:33:42 <Boomerang> What are the differences between type families and GADTs? Is one of them a subset of the other?
08:34:19 <ski> a GADT is a new data type you're declaring, with data constructors
08:34:23 <erisco> type families have no value component to them
08:34:45 <ski> a type family is more similar to a type synonym, then
08:34:46 <erisco> also GADT constructors all end with the same type constructor
08:34:52 <erisco> type families are not restricted in this way
08:35:17 <lyxia> jophish: Is the multiline string notation not sufficient?
08:35:41 <erisco> I suppose you can use non-injective type families, you just have to annotate
08:35:46 <erisco> so it is unpleasant but possible
08:37:38 <bombermap> is there any function in haskell like isDigit but for all the numbers?
08:38:15 <bombermap> i mean one that checks if it is a number
08:38:26 <lyxia> if all characters in a string are digits?
08:38:37 <lyxia> all isDigit
08:39:29 <erisco> Boomerang, you can say  data Foo a where Foo :: Int -> Foo String   as a sort of mapping of Int to String but this is unlike  type family Bar a where Bar Int = String
08:39:46 <bombermap> i have a [Char] with always like "30 2"
08:40:23 <erisco> Boomerang, Foo Int ~ String  nor  Foo Int ~ Foo String   is true
08:40:26 <bombermap> i want to turn the type Char into Int so i could get (30,2) 
08:41:13 <erisco> Boomerang, but  Bar Int ~ String    and  Bar Int ~ Bar String  is not defined because Bar has no case for String
08:41:38 <Boomerang> I see, so they're different things and they may complement each other. I need to play around a bit more with this to get my head around it.
08:42:19 <Boomerang> Thanks for the examples erisco!
08:42:32 <erisco> data type constructors are irreducible, they just are what they are
08:42:41 <erisco> so  Maybe Int  is already normalised
08:43:10 <erisco> this is like data constructors as well, also irreducible.  Just 3   is already normal
08:43:57 <erisco> F x  where F is a type family reduces if there is a case that matches x
08:44:04 <jophish> lyxia: it's not quite as nice as raw strings in a qq
08:44:16 <jophish> I've written 'deindent' locally now, so it's not a problem
08:47:08 <erisco> they can work in together, but they are different things, yes
08:48:21 <erisco> also beware that you cannot partially apply type functions
08:49:25 <erisco> the designers didn't think it a good idea to have them be first order
08:49:48 <erisco> inference and termination and suchlike
08:51:54 <Shou> erisco, is there an in-depth resource to read about the decision(s) behind no partially applied type synonyms?
08:52:39 <erisco> I don't know
08:54:37 <Cale> Shou: Having partially applied type synonyms has the same issues as having type level lambda
08:55:40 <Cale> It becomes much more complicated to see if types match and to infer types for things.
08:57:12 <erisco> it is allowed for type constructors though
08:57:58 <glguy> specifically data type constructors
08:58:04 <glguy> and newtype type constructors
08:58:13 <erisco> yes I meant that
08:58:27 <glguy> but not type synonym type constructors
08:59:02 <Shou> Cale, yeah I'm curious about any papers that discuss this in detail so I can wrap my head around the exact limitations.
08:59:14 <erisco> I would call that a function, not a constructor, because it is reducible
08:59:37 <glguy> erisco: type constructor describes the name that defining a type synonym introduces
08:59:41 <glguy> It's not about being a function
09:00:06 <erisco> well I think it is silly to call it a constructor *shrug*
09:00:20 <glguy> Well, Haskell is silly.
09:01:59 <erisco> yeah the report calls it a type constructor
09:02:55 <erisco> you can ask for the kind of partially applied stuff though
09:04:08 <erisco> it may have to do with the perspective... they lead with "A type synonym declaration introduces a new type that is equivalent to an old type."
09:04:09 <glguy> T is a type constructor, t is a type variable. Type synonyms have normal kinds. The sort restricted "arity" of them is some separate property that we can only really inspect with :info I suppose
09:04:17 <erisco> they are viewing it as a new type
09:04:32 <erisco> I was viewing it as a function
09:04:45 <glguy> type synonyms are more general than functions
09:04:50 <glguy> String isn't a function
09:05:08 <glguy> but it's a type and it has a kind, even if it "evaluates" to [Char]
09:07:09 <erisco> yes you're right
09:07:31 <erisco> type constructor then
09:08:42 * hackagebot proteaaudio 0.6.5 - Simple audio library for Windows, Linux, OSX.  https://hackage.haskell.org/package/proteaaudio-0.6.5 (CsabaHruska)
09:09:56 <erisco> I wonder why data type constructors get away with it
09:10:27 <glguy> Get away with not being fully saturated?
09:11:31 <erisco> yes. My guess is something to do with the type forms expressible with aliases versus data types
09:12:45 <glguy> The difference is that they don't reduce to any other type
09:13:25 <glguy> So there's no ambiguity of when you stop reducing them or if they will stop reducing
09:13:36 <erisco> do type synonyms reduce? my thought is they are merely equivalent
09:14:56 <glguy> If you're deciding if two types are equivalent and you support arbitrary type lambdas enabled by unsaturated type synonyms you'd need to reduce them
09:16:22 <ertes> that makes me wonder: in order to allow partial type synonym application the type system would need a termination check, right?
09:16:35 <ertes> i.e. no general recursion on types
09:19:20 <glguy> I think that type synonyms might make more sense if they defined new type variables rather than type constructors. This would be similar to how data declarations introduce new value constructors (e.g. Just) but normal value definitions don't (e.g. isNothing)
09:20:06 <erisco> hm, I see
09:20:06 <glguy> That would conflict with the kind that all type signatures implicitly universally quanify over all the type variables used in them
09:21:02 <glguy> I guess delete "the kind that" from that message to make it make more sense
09:21:44 <erisco> I can see issues with recursive aliases but I haven't thought up issues only with partial application
09:25:36 <erisco> glguy, do you have an example?
09:27:09 <notme> how do i examine Control.Lens.Basic in lamdabot
09:27:11 <notme> ?
09:27:59 <glguy> notme: You don’t, but you can look at the documentation https://hackage.haskell.org/package/basic-lens
09:28:19 <notme> i dont have access to a compiler right now
09:28:35 <notme> so i was hoping to uselambdabot
09:28:53 <notme> but i dont know how to import modules...
09:29:08 <glguy> Don’t worry, it hasn’t changed since its initial release in 2014. It will be there when you get back to a compiler.
09:29:20 <glguy> err 2015
09:29:27 <notme> idk what you means
09:29:43 <glguy> lambdabot since going to help you to explore this package
09:29:46 <glguy> isn't going*
09:30:10 <Tuplanolla> @let import qualified Prelude as NotPrelude
09:30:11 <lambdabot>  .L.hs:146:14: error:
09:30:11 <lambdabot>      Not in scope: type constructor or class ‘Integer’
09:30:11 <lambdabot>      Perhaps you meant ‘NotPrelude.Integer’ (imported from Prelude)
09:30:44 <Tuplanolla> You can usually import like that, notme.
09:30:57 <notme> im recieving conflicting advice
09:31:00 <glguy> Nope
09:31:14 <Tuplanolla> I don't think lambdabot has `:bro`.
09:31:19 <glguy> Yes, that's how imports are added. No, you can't explore the basic-lens package with lambdabot
09:31:24 <thomasd> hi there, is there a way to get record accessor functions as a list for a particular Constructor? I looked in Data.Data but didn't see anything. I can get the field names as a list, but I can't get the functions as a list. 
09:32:09 <glguy> thomasd: In general the field accessors for a record don't have the same type, so you won't be able to get a normal list of them
09:32:12 <notme> they would have different type so wouldnt go in a list surely...
09:32:41 <erisco> type Compose g f x = g (f x)  I cannot think of the issue with   Compose F (Compose G H) X
09:33:02 <thomasd> haha, of course, sorry
09:33:19 <glguy> erisco: To your earlier question, I don't have any examples handy, though I'm interested in exploring that later today
09:34:15 <notme> ericso, this has kind *>* right? idk if thats a problem
09:34:20 <notme> *->*
09:34:33 <erisco> notme, no, it has kind *
09:34:48 <notme> oh yeah
09:35:46 <erisco> maybe it is just to do with ~
09:35:59 <erisco> apparently you can ask  Maybe ~ []   for example
09:36:20 <notme> @let type Compose g f x = g (f x)
09:36:21 <lambdabot>  .L.hs:165:1: error:
09:36:21 <lambdabot>      Multiple declarations of ‘Compose’
09:36:21 <lambdabot>      Declared at: .L.hs:161:1
09:36:29 <notme> @let type A f g h x = Compose f (Compose g h) x
09:36:30 <lambdabot>  .L.hs:165:1: error:
09:36:30 <lambdabot>      Multiple declarations of ‘A’
09:36:30 <lambdabot>      Declared at: .L.hs:163:1
09:36:39 <notme> @let type OtherCompose f g h x = Compose f (Compose g h) x
09:36:40 <lambdabot>  Defined.
09:36:43 <notme> seems fine
09:36:44 <glguy> notme: You can play with lambdabot in /msg
09:37:01 <notme> yeah sure
09:37:08 <erisco> and it is certainly a different beast to ask about equivalence of * -> * kinds
09:37:16 <notme> my one didnt have overlaps...
09:37:28 <erisco> I don't know where this is ever done though
09:37:52 <erisco> and if we just have equivalence of * kinds then I don't see where partial application becomes a problem
09:38:56 <erisco> if we do an occurs check to make sure there is no recursion, then if the kind is * then we can get a normal form trivial to check
09:39:31 <ertes> is there a category-theoretical formulation of semirings and related structures?  not a category of semirings, but semirings themselves, built on top of categories and groupoids instead of monoids and groups
09:39:54 <erisco> this seems plainly obvious... there must be some reason to have * -> * equivalence constraints (and higher arities) that I am not seeing
09:40:04 <ertes> i was trying to come up with a formulation of my own using functors, but it didn't really make sense
09:42:09 <ertes> my initial attempt was this (just a scratch): given two categories C and D and monomorphic functors in both directions, …  unfortunately functors are too strong, because they insist that (+) and (*) are basically the same operation
09:42:54 <erisco> f :: f a -> f a -> f a    x :: F A   y :: G B   f x y    if F and G are aliases, we still reject if either are not * -> *
09:43:15 <erisco> and if they are, we expand them to get the data types, then we can solve the rest normally
09:43:24 <erisco> the aliases don't enter into this problem at all
09:43:55 <erisco> though it might initially look like we're asking F ~ G and A ~ B, this isn't the case
09:44:57 <erisco> glguy, if you puzzle this out I'd be interested to hear
09:57:02 <mmachenry> Does anyone know how to write a Conduit pipeline where I can continually change the parser being used from message to message? I think I might need disconnect conduitParser and reconnect a new one to the same sink repeatedly. 
09:58:15 <johnw> could you write a conduit that takes a conduit as an argument, and does this?
09:58:44 * hackagebot casadi-bindings-internal 0.1.5.0 - low level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-internal-0.1.5.0 (GregHorn)
10:03:44 * hackagebot casadi-bindings-core 3.1.0.0 - autogenerated low level bindings to casadi  https://hackage.haskell.org/package/casadi-bindings-core-3.1.0.0 (GregHorn)
10:03:46 * hackagebot live-sequencer 0.0.5.2 - Live coding of MIDI music  https://hackage.haskell.org/package/live-sequencer-0.0.5.2 (HenningThielemann)
10:08:44 * hackagebot casadi-bindings 3.1.0.0 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.1.0.0 (GregHorn)
10:10:29 <mmachenry> johnw… perhaps. Do you mean call await and yield myself and pass it to a conduit?
10:10:54 <mmachenry> That might be easier to than connecting and reconnection because this is going to be used for reading from a network.
10:10:59 <johnw> sure, that's one way of "feeding" the inner conduit
10:11:12 <johnw> i mean, that's all the parser conduit is doing internally
10:11:20 <lyxia> ertes: a categorical (co)product (+) is commutative in some sense and has a distributive property. (f+g) . h = (f . h) + (g . h)
10:12:21 <mmachenry> johnw: Do you know how to make a source from the await of the conduit I'm currently in?
10:12:51 <johnw> "yield foo" is itself a source, isn't it?
10:14:49 <mmachenry> johnw: yield produces a conduit. It takes a value though. I wonder if I can CL.map yield maybe?
10:14:57 <mmachenry> I'll see if that type checks. 
10:16:59 <ertes> lyxia: that's actually helpful, but i found a different notion, which might be more useful:  2-rigs
10:17:08 <ertes> thanks!
10:20:34 <ania123> x:xs
10:20:57 <ania123> spleats list with head match x and tail xs which is a tail of the input list
10:20:59 <ania123> is not?
10:21:31 <unclechu> hey guys, I'm trying to read from file descriptor: `System.Posix.IO.fdRead fd 16` but I get this error in runtime: "fdReadBuf: invalid argument (Invalid argument)" any ideas why is it happening?
10:21:56 <glguy> presumably 16 in an invalid file descriptor
10:22:01 <glguy> err, fd
10:22:32 <geekosaur> wouldn't that be EBADF not EINVAL?
10:22:34 <tortal> learning haskell. wondering what ppl think about hte different IDEs around. I've been using vim so far, even tried spacemacs. Anyone here that could recommend an IDE that is "pedagogic"? I've seen the wiki at haskell.org but im looking for people's subjective opinion
10:22:47 <geekosaur> ania123, I'm not sure what you are asking there
10:23:10 <glguy> geekosaur: GHC doesn't model all of the different POSIX error codes, so possibly not
10:23:31 <nitrix> tortal: I heard the experience on emacs is fairly good with haskell-mode; personally I'm a vim user and couldn't get any of the plugins to be responsive enough to be usable pratically.
10:23:44 <nitrix> tortal: So I'm sticking to vim as a text editor and GHCi for everything else.
10:24:18 <nitrix> (Reloading, checking type signatures, debugging, so on)
10:24:27 <tortal> nitrix: thanks. how about eclipseFP? tried that? or intellij plugins
10:24:33 <Welkin> nitrix: use emacs
10:24:47 <Welkin> lol
10:25:05 <Welkin> tortal: don't even mention those abominations
10:25:35 <alanz> or spacemacs, has vim key bindings
10:26:08 <glguy> geekosaur:   http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Foreign.C.Error.html#errnoToIOError         | errno == eBADF           = InvalidArgument
10:26:17 <tortal> Welkin: what would you recommend? emacs with haskell-mode? spacemacs? 
10:26:21 <geekosaur> ...how "helpful"
10:26:52 <geekosaur> yes, if I'm working with low level stuff, force me to truss/strace to figure out what's really going on.
10:26:52 <Welkin> tortal: yes
10:27:14 <mlehmk> I couldn't get eclipseFP to work, as it relies on some unmaintained libraries
10:27:15 <glguy> geekosaur: It doesn't throw the errno away, that's still attached to the IOError
10:27:21 <tortal> Welkin: ok thanks
10:27:26 <mlehmk> So far, most success I had with Leksah
10:27:26 <glguy> geekosaur: but the general category that's used isn't the same as all the POSIX errors
10:27:51 <mlehmk> anyways, having a GHCi open for testing is always good
10:28:20 <mlehmk> And about the Haskell plugin for IntelliJ... it doesn't do much for me
10:28:24 <geekosaur> also if the thing in parens is not a representation of the errno (and if it is then it *is* EINVAL not EBADF) then what is its purpose
10:28:39 <lpaste> Sumanth revised “No title”: “No title” at http://lpaste.net/340115
10:29:00 <drdo> Just use emacs with haskell-mode, it's fine
10:29:24 <wayne> drdo: what haskell-mode features am i probably not using?
10:29:32 <wayne> i'm a recent convert to emacs from vim for haskell
10:29:35 <drdo> wayne: I don't know, I don't use that much myself
10:29:39 <wayne> and so far i use the tabs
10:29:40 <Welkin> wayne: I don't use any of them except the syntax highlighting
10:29:42 <geekosaur> Sumanth, *how* did you run that in ghci? what expression did you type?
10:29:49 <wayne> (because it kinda forces me to)
10:29:50 <drdo> Mainly highlighting, indentation and completion
10:29:54 <wayne> ah okay
10:29:59 <Welkin> use the tabs?
10:30:01 <drdo> And of course the ghci thing
10:30:03 <Welkin> what does that mean?
10:30:07 <Welkin> tabs instead of spaces?
10:30:07 <wayne> yes, the indentation mechanism
10:30:11 <wayne> where i press tab and it cycles
10:30:15 <Welkin> oh, haskell-indent
10:30:15 <unclechu> glguy: it happens even in this example: http://pastebin.com/shTJfCLA how could it be invalid file descriptor?
10:30:16 <tortal> problem is that I am really not familiar with emacs bindings.. vim on the other hand.. that is why spacemacs seem so alluring
10:30:16 <Welkin> yes
10:30:18 <drdo> wayne: If you press C-c C-l
10:30:31 <drdo> you get a ghci buffer with that module loaded
10:30:32 <Welkin> tortal: you can use emacs with vim bindgins with evil-mode
10:30:38 <Sumanth> @geekosaur take' -1 [2,3,4]
10:30:38 <lambdabot> Unknown command, try @list
10:30:45 <Welkin> that is what spacemacs uses
10:30:48 <geekosaur> you need parentheses around the -1
10:30:54 <geekosaur> it's a weird edge case in haskell parsing
10:30:59 <wayne> drdo: oh nice! that's nifty
10:31:02 <wayne> thanks
10:31:02 <tortal> so what is so amazing with spacemacs that I wont get with regular emacs
10:31:07 <drdo> wayne: Yeah that's one of the main things I use for sure
10:31:21 <drdo> And it's really nice nowadays
10:31:37 <wayne> gets pretty close to a REPL
10:31:40 <Sumanth> @geekosaur Thank you very much :)
10:31:40 <lambdabot> Unknown command, try @list
10:31:49 <drdo> It's literally a repl
10:32:23 <wayne> my answer still holds! :p
10:33:45 * hackagebot casadi-bindings 3.1.0.1 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.1.0.1 (GregHorn)
10:34:52 <mekeor> Q: lucid or blaze? =)
10:35:21 <Welkin> lucid
10:35:25 <Welkin> lucid is a better blaze
10:35:51 <Welkin> it was created to fix problems with blaze-html
10:35:55 <wayne> mekeor: yeah don't listen to the people who tell you to blaze every day
10:36:00 <wayne> http://chrisdone.com/posts/lucid
10:36:25 <mekeor> yeah, i read that post, but he's the initiator of lucid, so it could have been biased ;)
10:36:40 <wayne> i agree it's biased
10:36:47 <wayne> also some well-founded arguments in there
10:36:50 <JonReed> So, I want to fsync a handle occasionally to ensure that data is written do disk, before I update a log file that says which data was written last. For this I need to call fsync, which takes a file descriptor. handleToFd, which returns the descriptor, closes the handle.
10:36:52 <Cale> reflex-dom :)
10:37:02 <wayne> i think at the end of the day it's whatever your teammates chose
10:37:46 <JonReed> Of course closing and opening a handle on each chunk will be unoptimal. And there does not seem to be any way to convert a handle to descriptor without closing it
10:38:17 <Cale> Does flushing the handle not do it?
10:38:25 <Welkin> mekeor: initially I had never used blaze, but since most of the templates I used were basedo n it, I thought it was the best one
10:38:37 <JonReed> Flushing the handle doesn't call fsync, AFAIK
10:38:41 <Welkin> it wasn't until I read that blog post and took a closer look at lucid that I realized it's better
10:39:26 <JonReed> so data might not end on the physical disk on that file, and I can update the log saying that this data was written there, while in reality it might not be
10:40:03 <mekeor> Welkin: ait thx :·)
10:40:18 <JonReed> The way I understand it is that fdToHandle should just flush the handle. But it also closes it
10:40:21 * mekeor reads about reflex-dom
10:41:02 <JonReed> So, if any haskell operations that use handle are to be performed with occasional fsync, then handle will have to be reopened each time :(
10:48:41 <Cale> JonReed: Ah, you might be able to steal some code from acid-state -- it seems to use its own FHandle type so that it can fsync.
10:49:05 * geekosaur has in the past done this by handleToFd, save fd, fdToHandle, pass the Handle back up
10:49:06 <codedmart> If I have two different Aeson Objects (Values). What is the best way to merge them? As in `object ["a" .= 1]` and `object ["b" .= 2]` and I want to produce `object ["a" .= 1, "b" .= 2]`
10:49:50 <geekosaur> and now both are valid --- but you need to use care with them, as doing the wrong thing with the fd will cause odd behavior in the Handle (the Handle cannot know what you did with the fd)
10:50:01 <cocreature> codedmart: what do you want to do if there are key conflicts?
10:51:12 <cocreature> codedmart: Object is just a typesynonym for a hashmap so you can use the normal hashmap union function https://hackage.haskell.org/package/unordered-containers-0.2.7.1/docs/Data-HashMap-Strict.html#v:union
10:51:29 <codedmart> Ah right
10:51:36 <cocreature> codedmart: if you have Values instead of Objects you need to first pattern match on them and decide what you want to do if it is not an object
10:51:44 <Guest91312> Is it possible to get the output of Debug.Trace.trace from within ghci?
10:51:50 <codedmart> cocreature: Didn't think about conflicts, thanks!
10:52:21 <JonReed> Cale: Thx. I'll look into it. Another option would be to just call kernel's `write` directly. There is "fdWriteBuf", that accepts a buffer. But there are many caveats with this.
10:52:22 <kadoban> Guest91312: You mean as a value or something?
10:52:38 <Guest91312> kadoban: no, just the output printed
10:52:42 <cocreature> codedmart: unionWith allows you to supply a custom merging operation that’s used on conflicts
10:52:51 <kadoban> Doesn't it already do that?
10:52:59 <Guest91312> No
10:53:17 <Guest91312> Oh, wait
10:53:40 <cocreature> seems to work for me
10:53:41 <Guest91312> Yes, it does
10:53:44 <Guest91312> nevermind :)
10:53:47 <cocreature> Guest91312: you need to make sure it is evaluated
10:54:19 <kadoban> Ya, it only does anything if the thing is forced to be evaluated for some reason.
11:04:03 <zipper> Is it that the `main` function in an executable can't not return a monad?
11:04:15 <zipper> Like I can't have `main :: Bool`?
11:04:23 <zipper> stack build compains
11:04:37 <pavonia> It must be of type IO something
11:06:10 <Clint> zipper: just assume that it should always be main :: IO ()
11:09:02 <bombermap> i need some help, i have a [Char] (ex: "1 22 3") and i want to get (Int,Int) (ex: (22,3) the 1 is the player)
11:11:57 <glguy> map read (words "1 22 3") :: [Int]
11:12:05 <pavonia> This is at least the third time this question arises here today O.o
11:12:15 <glguy> You need to decide how you want to split up the string, words splits on spaces. 
11:12:52 <glguy> separately you need to decide what to do if you have a different number of words than you expected
11:13:08 <glguy> and you can parse a number using read or if you want to handle failure, Text.Read.readMaybe
11:13:08 <zipper> pavonia: Clint Not only must it be a monad but it has to be of type IO ?
11:13:14 <zipper> I mean of monad IO ?
11:13:23 <glguy> zipper: Being a monad isn't specifically relevant
11:13:28 <glguy> it just has to have type IO a for some a
11:14:01 <JonReed> Cale: Wow, acid-state's FileIO module is really nice, succinct and copy-pastable. It also should work on both Unix and Windows, using fsync on Unix and flushFileBuffers on Windows. It's as if it was written specifically for me. Thanks Santa :D
11:14:02 <pavonia> zipper: It's the one and only entry point for IO execution, so yes
11:14:51 <bombermap> glguy thx, i'll check that out
11:27:43 <nmattia> linear types
11:28:08 <nmattia> mh, wrong window
11:28:35 <ertes> wayne: if it hasn't already been said: it pays off to configure haskell-interactive-mode (not inferior-haskell)…  it turns haskell development into a very smooth experience
11:28:45 <byorgey> bombermap: is this an assignment for a class?
11:29:21 <byorgey> just curious since several others have asked similar questions
11:29:34 <bombermap> y
11:30:14 <ertes> wayne: among other things it loads your module (in the context of the current cabal sandbox/stack/nix environment, if there is a .cabal file), gives you context-sensitive type signatures and completion
11:30:20 <bombermap> It was me the other times also byorgey
11:30:30 <byorgey> oh, ok
11:30:33 <bombermap> but i didn't get it the aswer clearly
11:31:13 <bombermap> it is a project 1st year 1st semester and haskell is so rigid at types man
11:33:10 <byorgey> we know Haskell can be difficult at first, and we are happy to help
11:33:14 <byorgey> but if you don't get a clear answer, try to ask a different question about the part you don't understand, rather than just asking the same question again
11:33:33 <byorgey> you will learn more that way and it will be a better use of the time of people trying to help you
11:33:47 * hackagebot publicsuffix 0.20161116 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161116 (wereHamster)
11:37:03 <ph88> hello :)
11:37:18 <wayne> ertes: thanks for the tip. i might write about this from a new convert's perspective
11:38:25 <ertes> wayne: if you are writing long-running programs (like web applications or other kinds of servers), have a look at my rapid library, too: https://hackage.haskell.org/package/rapid
11:39:01 <ertes> especially useful, if you use DSLs for templating/styling like blaze-html/lucid and clay
11:39:19 <wayne> nice! i was toying with the idea of something similar, but for production use instead of development
11:39:24 <ertes> change code, hit key, refresh browser =)
11:39:45 <zipper> is there a stack install deps command that does not build?
11:39:47 <wayne> i find that most people tend to re-implement something like RPCs to provide a console-like interface to their long-running daemon
11:40:05 <zipper> that is not `stack build`?
11:40:10 <luigy> ertes how about we start a websocket connection and it reloads for me after an `update`? ;)
11:40:26 <wayne> if you look at some program designs, like systemd or kubernetes, it tends to follow the ${name}ctl style: kubectl, systemctl
11:40:35 <luigy> or inject the html to body
11:40:37 <wayne> and that's dandy, but those clients are pretty high overhead to maintain
11:40:42 <luigy> different startegies to choose from
11:40:50 <danilo2> Hello! Are there any down-sides of setting many HS extensions globally in cabal file? I find it just wrong putting many extension pragmas on top of each file. Especially I made a list of extensions that are usefull and **probably** safe: http://lpaste.net/340142
11:40:55 <kadoban> zipper: stack build --only-dependencies     note that it's not really necessary in the usual workflow though, it's done implicitly
11:41:09 <wayne> maybe there's something that you can leverage ssh for to have a "domain-specific shell"
11:41:10 <ertes> wayne: sounds like you want dynamically pluggable modules
11:41:30 <ertes> luigy: yeah, that would be possible, although that's a lot of engineering to save a C-r =)
11:41:44 <zipper> kadoban: You don't know my heart's desire :P
11:41:46 <ertes> may pay off in some highly dynamic web applications though
11:41:47 <danilo2> Are there any extension on the list that we should avoid setting globally? Moreover - do such setting could negatively impact compilation performance?
11:42:07 <kadoban> zipper: ;)
11:42:25 <wayne> or even, "$ ssh -p 5555 my-prod-server.site.com" "# auth unlock user@example.com"
11:42:30 <ezyang> danilo2: I think the primary object people have is that it moves some information nonlocally. I don't find this that compelling 
11:42:45 <ertes> danilo2: these days i generally set none at all in the cabal fail and set all of them in individual modules, because it makes working with GHCi a lot easier and more consistent with compilation
11:42:53 <ertes> s/fail/file/  (where did that come from…)
11:42:54 <wayne> a sort of maintenance shaft into your running application
11:43:18 <wayne> django shell and rails console are in this vein
11:43:33 <danilo2> ertes: it doesnt matter if you use stack. stack repl cares about it automatically
11:44:06 <danilo2> ezyang: hmm, I don't find this compelling either
11:44:07 <ertes> danilo2: i don't use stack though, and even if i did, i wouldn't want to enforce stack-based development to anyone
11:44:29 <drninjabatman> hello
11:44:31 <stalk> jedai: https://github.com/jgm/filestore/issues/24 >> seems like it would be accepted
11:44:35 <ezyang> danilo2: It's worth noting, though, that some extensions have "consequences". GADTs is the biggy (it implies NoMonoLocalBinds) 
11:44:56 <ertes> danilo2: and there is still the problem that extensions change semantics, so it could matter to a module whether, say, -XOverloadedStrings is on or not
11:45:09 <danilo2> ertes: Ok, I don't feel that writing worse looking code is something that sohuld be caused by just lack of good development tools that community could find obsolete because there are just better alternatives. I understand however your point of view
11:45:21 <dcoutts> danilo2: this is primarily a matter of taste. Most people prefer to list extensions in the .hs files, but listing some defaults in the .cabal file is ok, it works.
11:45:37 <ertes> stack: the systemd of the haskell world =)
11:45:45 <ertes> MAKE EVERYTHING STACK!
11:45:45 <maerwald> haha
11:45:51 <maerwald> ertes++
11:46:05 <ezyang> Well, unlike systemd, init.d didn't roll over and die :P 
11:46:28 <maerwald> that's false, but offtopic anyway
11:46:33 <danilo2> ezyang: I know it and because I was asking about what extensions from that list **COULD** be problematic. I know about GADts and I can mostly live with NoMonoLocalBinds. But I dont know if any other of these could be dangereous
11:46:54 <mettekou> Does anyone know a library useful for generating terms in some (dependently-typed functional) programming language specified as an algebraic data type? Among other things: dealing with generating symbols and transforming terms into other terms.
11:46:55 <ezyang> I think OverloadedStrings is also dangerous 
11:47:05 <ezyang> well, dangerous is too strong a word 
11:47:14 <danilo2> ertes: sure, but these libraries I develop, so I prefer to have OverloadedStrings on by default
11:47:18 <maerwald> it is, because OverloadedStrings is dependent on GHC version
11:47:30 <maerwald> (the behavior, that is)
11:47:46 <drninjabatman> I wannt to use GHC.Generics to creat default implementations of a class for all objects of the form `data X s  = X0 s | X1 O1 (X s) | X2 O2 (X s) (X s) | ...`. Is there a library that does something simiular that I can use as reference?
11:48:07 <danilo2> dcoutts: The question in fact is if there are any dowsnides of putting such big list (http://lpaste.net/340142) in every libraary cabal file I develop. I just like this subset of Haskell and I feel this etension set suits my needs in most cases. Are there any downsides to that?
11:48:39 <danilo2> maerwald: what do you mean ? How is it dependent on ghc v?
11:48:58 <ertes> danilo2: it's a matter of taste, but in general i'd say list them in individual modules, and at least haskell-mode makes it very easy to do so (when compilation fails, and GHC suggests an extension, haskell-mode asks whether you want to add a pragma to the module)
11:49:29 <ezyang> AllowAmbiguousTypes is dangerous 
11:49:40 <danilo2> ertes: hmm
11:49:48 <dcoutts> danilo2: if you've settled on that as your "base language" then that's ok. The risk is mainly in accidentally using extensions you didn't mean to
11:50:11 <ertes> danilo2: as a bonus non-stack-users like me will thank you =)
11:50:33 <ezyang> TemplateHaskell is dangerous 
11:50:36 <danilo2> ezyang: why it is dangerous? Because I cannot spot some error? I just use TypeApplications in many places and ambiguous types are very usefull then
11:50:40 <dcoutts> ertes: hmm? how is it different?
11:50:50 <ertes> dcoutts: "it"?
11:51:02 <ezyang> rest is fine, I guess 
11:51:15 <maerwald> danilo2: it's Unicode 6 vs Unicode 7 afaik and "char is lower" and a few other things behave differently
11:51:25 <danilo2> ezyang: I've heard that TH could be dangereous but didnt find any concrete info - why ? 
11:51:26 <ezyang> danilo2: Yeah, none of the projects I work on can rely on type applications being available 
11:51:28 <kadoban> ertes: I don't understand how stack is related to this conversation, help me out?
11:51:51 <ertes> kadoban: danilo2 pointed out that stack auto-enables global extensions on 'stack repl'
11:52:09 <ezyang> danilo2: Well, there's just some incidental complexity associated with TH, which you should avoid if you can 
11:52:17 <kadoban> ertes: What global extensions?
11:52:18 <dcoutts> ertes: I was wondering what you meant by "non-stack-users will thank you"
11:52:32 <danilo2> ertes: stack is like systemd somehow and I really undrstand your point of view (I'm a gentoo user). But, hmm, its better than cabal in so many ways that I completely switched to it and even dont have time to "care" about obsolete (for me) build systems
11:52:43 <dcoutts> ertes: I mean extensions lited in the .cabal file work with cabal repl too
11:52:58 <kadoban> "stack is like systemd" ... how?
11:53:06 <ezyang> Is it just me or does 'bracket' just not work at all on Windows with control-c 
11:53:10 <dcoutts> danilo2: btw, you might like to try cabal new-build
11:53:12 <ezyang> I can't find anyone mentioning this on the web 
11:53:36 <ertes> ah, i don't use cabal-install either, i use nix with Setup.lhs, which is a similar workflow to stack, but cabal (the library) has no "repl" command
11:53:41 <ph88> does  http://community.haskell.org/~ndm/uniplate/  redirect to  http://ndmitchell.com/  for you guys as well ?
11:53:43 <ertes> or does it?  let me check
11:53:46 <danilo2> kadoban: see the ertes comparison to systemd above
11:53:53 <dcoutts> ertes: it does
11:54:09 <ertes> oh, that's convenient!
11:54:21 <dcoutts> danilo2: I pretty much feel the same about cabal new-build vs cabal, as you do about stack vs cabal
11:54:30 <kadoban> danilo2: "MAKE EVERYTHING STACK" wasn't much of an explanation of the metaphor.
11:54:41 <danilo2> ezyang: what is this "incidental complexity" with TH? Im scratching my head reading this and I dont know what could it be
11:54:48 <zennist> EvanR: a bit confused by your response the previous day... I'm passing my haskell callback to the C code and then triggering a C function that would then call my haskell callback at some point during the execution. Are you saying that the callback would happen in a different thread from the one the C function is run on, which also means that the callback could have immediately returned in the C land and leading to race 
11:55:10 <kadoban> danilo2: I think it makes compilation times longer, but I'm not sure if that applies when it's just turned on and not actually used.
11:55:29 <kadoban> There's TH danger in terms of using code from other people, since it can do arbitrary IO on your system of course, but that's probably not what's being talked about.
11:55:47 <danilo2> kadoban: ok, so systemd integrates "eveything" into one piece of software, simmilar to stack. However I find that what stack does is actually good, a build system **should** integrate everything it could from the environment to provide as easy as possible workflow
11:55:50 <ezyang> danilo2: recompilation avoidance is less accurate, build system needs to do extra work to make sure GHCi-loadable libraries are built, less portable (cross-compiling won't work), can't build with stage1 anymore 
11:56:02 <ertes> (don't take my stack/systemd comparison too seriously)
11:56:33 <danilo2> kadoban: sure, I know it, thanks for pointing this out. I have to make some trests if the compilation times are longer when TH is just on
11:56:50 <kadoban> danilo2: It doesn't even integrate everything. It's not like 'cabal-install' is a modular system somehow compared to stack, it just does things less well, especially the old-build stuff.
11:56:57 <luigy> ertes lol 
11:56:59 <ertes> unbelievable…  the 'repl' command went completely under my radar
11:57:13 <ertes> i thought it was a feature of cabal-install
11:57:17 <dcoutts> danilo2: it's true that Cabal (ie the build system) has to do more work when TH is on, since more stuff has to be built to make it work in some cases.
11:57:30 <danilo2> ezyang: great points, thank you! Anyway I can't escape from TH because I use lens almost everywhere though
11:57:38 <luigy> ertes stacks repl is a bit more beefed up from what cabal-install offers
11:57:39 <ezyang> ok fair :) 
11:57:40 <dcoutts> ertes: the underlying impl is in the build system, hence Cabal lib
11:58:32 <ph88> anyone here use the derive package ?
11:58:57 <ertes> ph88: i use generic-deriving a lot
11:59:08 <ertes> it uses GHC generics instead of syb
12:00:29 <ertes> and yet i have no use for 'repl'…  because of nix just regular ghci behaves like 'repl' =)
12:00:42 <ertes> minus automatically enabling extensions
12:01:16 <ertes> in fact 'repl' seems like it would get in my way, because now i have to 'configure' first
12:01:30 <Xyliton> Is this the right place to ask questions?
12:01:32 <dcoutts> ertes: well, and anything else listed in the .cabal file, like cpp flags, C libs, src dirs, pre-processors etc etc
12:01:52 <dcoutts> ertes: if your lib/exe is really simple then yes you can just use ghci
12:01:52 <ertes> Xyliton: if your questions are about haskell, then yes
12:02:34 <ertes> dcoutts: yeah, that's true…  i have hacks in place right now, so it may pay off after all
12:02:39 <dcoutts> ertes: btw, with cabal new-build with ghc-8.0.2+ then everyone gets that nice nix env style behaviour :-)  but it's still true that it only helps for simple packages
12:03:21 <ertes> dcoutts: well, it's not just about environments…  i'm using nix-specific features like generations and closures
12:03:21 <dcoutts> by which I mean running ghci in the project dir gets the env of the project (but not component-specific info listed in the .cabal file)
12:03:33 <ertes> so even with new-build i'm most likely going to use nix
12:03:42 <Xyliton> Is there an standardized way of storing the used "packages" (idk what they are called) so someone else could just fetch the repo and do something like "cabal install" and it downloads them? 
12:03:45 <dcoutts> ertes: what do those things add?
12:03:46 <ezyang> OK, apparently, msys2 shell handles C-c in a very goofy way 
12:04:29 <kadoban> Xyliton: Yes, though how you do it depends. Are they on hackage?
12:04:36 <dcoutts> ertes: and I'm not saying you should, btw, just that we're stealing that nice idea for everyone, like other nix ideas we've borrowed
12:04:57 <geekosaur> ezyang, I think that's known, yes. differences between windows and posix semantics
12:05:07 <geekosaur> ctrl-c is a very different beast on windows
12:05:14 <ezyang> geekosaur: No, it's like, mintty literally eats the C-c and just hard kills the process 
12:05:20 <Xyliton> kadoban: I think so. I'm new to Haskell and the only way I know how to fetch packages is thorugh "cabal install <name>"
12:05:24 <ezyang> if I run it on cmd.exe, ctrl-c works fine 
12:05:24 <ertes> dcoutts: generations add tree-like atomic update and rollback (think of git branches); closures let me deploy working solutions to other hosts directly, as long as the architecture is the same
12:05:54 <dcoutts> Xyliton: one way is to use cabal freeze and check-in the cabal.config file. Then anyone can "cabal install" within the project dir and get the same versions.
12:05:55 <geekosaur> yes, because it's treating it as a posix-y signal when windows doesn't have such a thing. and the closest thing to a posix signal is TerminateProcess
12:05:56 <ertes> dcoutts: with sharing and garbage collection, so only new stuff is copied, and stuff i no longer need is deleted automatically
12:06:01 <Xyliton> Also, is there any working (and simple) templating lib? I found HSmarty, but I can't install it because it breaks
12:06:18 <geekosaur> which, no. they need to rethink that aspect of signal emulation
12:06:26 <ertes> dcoutts: yeah, new-build is great…  it's just that i have no use for it =)
12:06:38 <ezyang> ugh 
12:06:56 <dcoutts> ertes: we use a nix-like store so we get atomic updates, though we're not yet taking advantage of that for cross-machine deployment. We lack GC as of yet.
12:07:04 <kadoban> Xyliton: If they're things on hackage, it's easy and works automatically, you just set your version bounds sanely in the .cabal file really. You can also use cabal freeze or if you want you can use stack and it lets you do similar things, which is to lock in to a specific set of exact versions that can be used that definitely work, which helps users.
12:07:32 <Xyliton> how do I get "cabal freeze" to work? Just running it inside the repo tells me that it can't find the .cabal file...
12:07:40 <ertes> dcoutts: do you have environments with generations similar to nix-env, too?
12:07:44 <Xyliton> Oh, seems like I just have to read the docs for the .cabal file then
12:07:47 <kadoban> If things aren't on hackage, it gets a bit more interesting. In stack you can set up extra-deps from for example git repos and they'll be used automatically, or you can have them in subdirectories, etc. I'm not sure how much of that is possible in the cabal world.
12:07:51 <ezyang> Maybe the moral of the story is that I shouldn't use mintty, I should use cmd.exe calling the msys bash 
12:08:17 <dcoutts> ertes: we have project local envs so far, thought ghc now supports user-wide envs but we don't yet support managing those
12:08:45 <ertes> dcoutts: nix-env is only user-wide by default…  you can have as many environments as you want
12:08:49 <dcoutts> ertes: the design of the user wide envs was modelled on nix, so that is indeed the goal
12:08:56 <Xyliton> kadoban: I have no idea what I should use and the "guide" I used to install Haskell told me to get cabal first so I'm a bit lost right now, actually
12:09:05 <ertes> dcoutts: try this:  nix-env -p ./my-profile -iA nixos.coreutils
12:09:27 <dcoutts> ertes: right, we just started with project local, but that's not any fundamental limit
12:09:42 <ertes> dcoutts: i like the new design a lot!
12:10:14 <ertes> it's a lot closer to nix now, so these features can become available to people without nix =)
12:10:18 <EvanR> zennist: as i understand it, when a thread makes an ffi call its effectively blocked until it gets a response
12:10:22 <dcoutts> ertes: that's the idea
12:10:34 <EvanR> and cant do anything else until then
12:10:48 <EvanR> such as run code for a call-to-haskell
12:11:06 <ertes> dcoutts: but a nix users will probably just continue to use nix anyway, because it integrates with everything else
12:11:13 <kadoban> Xyliton: I personally would avoid any guide that's not using cabal new-build or stack. The old/current way cabal-install worked was IMO not very good.
12:11:14 <ph88> ertes, what do you use GHC.Generics for? Do you know how i can implement a function similar to transformBi from the uniplate package with GHC.Generics ?
12:11:34 <dcoutts> ertes: sure
12:11:36 <ertes> ph88: i'm not really familiar with syb that much…  i mostly use it to derive Applicative and Monoid
12:11:38 <kadoban> Xyliton: That said, you can probably get by not worrying about it much for quite a while if you just learn what you need to minimally put in .cabal files.
12:11:44 <ezyang> Is there also a known issue where streams (stdout/stderr) don't flush on exit on Windows? 
12:11:46 <ertes> ph88: "it" being GHC.Generics
12:11:53 <kadoban> Both cabal-install and stack use .cabal files, so it's good information to have anyway, it won't be obsolete.
12:12:05 <EvanR> ezyang: or on linux
12:12:17 <Xyliton> Is there anything wrong with using "cabal init"?
12:12:18 <EvanR> yeah
12:12:29 <ezyang> EvanR: Oh, it doesn't flush automatically on Linux either? 
12:12:32 <dcoutts> Xyliton: no, that's a useful way to generate an initial .cabal file
12:12:37 <ph88> ertes, could you take a look at this issue please? i'm kind of disparate :/   https://github.com/ndmitchell/uniplate/issues/9
12:13:00 <EvanR> ezyang: ive heard complaints to the effect
12:13:16 <ezyang> It's generally not a problem for me, esp. if I do stderr which is line buffered by default 
12:13:37 <EvanR> right
12:13:44 <ph88> i still have 1 option left .. derive with template haskell
12:13:56 <Xyliton> I feel like I shouldn't try to write a program as my "first" project in Haskell xD. Functional programming is so different from the stuff I usual use(d). Well... 
12:14:05 <Xyliton> *usually
12:14:11 <ph88> i think i tried that briefly though .. can't remember exactly
12:14:18 <ertes> ph88: i have no experience with uniplate either, sorry…  i only have experience with GHC.Generics
12:14:26 <ezyang> I guess the moral of the story is stderr is not line-buffered by default on Windows 
12:14:51 <EvanR> yeah im not sure what buffering modes are supposed to be default where, if any
12:15:03 <EvanR> ive had to manually set it for stdout before
12:15:04 <ertes> Xyliton: i disagree…  i totally think you should write a program, just not a complicated one
12:15:16 <kadoban> Xyliton: This build stuff is a bit confusing at first, but it's really not that hard. Don't let it discourage you, people can help you work through it.
12:15:23 <ezyang> or, perhaps, the detection is busted in certain situations 
12:15:39 <ertes> Xyliton: start by writing a 'cat' equivalent:  a program that just prints each file named on the command line in order (or stdin if none)
12:15:39 <ezyang> since apparently we try to be clever and either line or block buffer. But it's still confusing, since we should still flush at the end 
12:15:58 <Xyliton> ertes: kadoban: thanks :) I didn't expect a community to be that nice to noobs
12:17:11 <kadoban> Haha, anytime. Yeah, we don't go for the uhm, harsh treatment of noobs around here that some other places seem to delight in.
12:18:00 <ertes> Xyliton: i treat beginners like beginners: "be gentle, but don't patronise" =)
12:20:15 <Xyliton> When doing "cabal init", should I set the source dir to "src" (or some custom one) or leave it as "none"?
12:20:30 <ertes> Xyliton: set it to src just to be safe
12:20:37 <ertes> later you can come up with your own convention
12:23:07 <kadoban> I kinda like the basic directory structure that the default stack template uses, you can do 'stack new blah' somewhere and see if you like it. (you don't have to use stack otherwise, can just use it for inspiration)
12:23:44 <Xyliton> If a function is taking one string as argument and returns "nothing" (the functions handles IO stuff) should the signature be "func :: String -> IO()"?
12:24:03 <Xyliton> or something else as second "part"?
12:24:10 <divVerent> yes (most people write it as IO (), though)
12:24:33 <divVerent> i.e. with a space (IO is a parametrized type, and () - the empty tuple - is the parameter)
12:25:12 <jle`> Xyliton: yes, a String -> IO () can be thought of as an IO action parameterized by a String.  give a different String, get a different IO action
12:25:41 <jle`> `putStrLn "hello"` is an IO action that just prints "hello", `putStrLn "world"` is an IO action hat just prints "world", etc.
12:25:53 <jle`> :t putStrLn
12:25:54 <lambdabot> String -> IO ()
12:27:19 <EvanR> () is the unit type in this case
12:27:26 <ertes> Xyliton: what divVerent said about () is important: () is a type with a single value that is also called ()
12:27:36 <ertes> just like Bool has two values:  False and True
12:27:40 <ertes> () has one value: ()
12:28:05 <davean> ertes: and undefined?
12:28:29 <ertes> it's mainly used for IO actions that have no interesting result, but they still need to have a result
12:28:39 <ertes> davean: i'll hand-wave over that for now =)
12:29:09 <EvanR> its also used as a parameter for user state type where they dont need any state
12:29:13 <ertes> i'll have a fast screw loose
12:29:32 <davean> ertes: ok, but I've always found lies hurt me a lot
12:29:48 <davean> ertes: personally, thats about the most harmful thing you could do for me
12:29:51 <EvanR> undefined isnt really a value
12:29:57 <ertes> davean: i promise that i'll resolve it very soon =)
12:30:20 <divVerent> note that you can't use IO Void that well instead, as performing the IO action would yield undefined :)
12:30:24 <divVerent> but that's a different story
12:30:34 <kadoban> Small, helpful, simplifying lies are really part of the learning process. You can't absorb everything at once.
12:31:00 <divVerent> essentially, returning "nothing" in Haskell is usually achieved by returning a type that only can have a single value, and the typical type used for this purpose is the unit type, ()
12:31:06 <ertes> davean: and yes, i totally agree…  in general no lies to beginners
12:31:09 <EvanR> IO Void would make sense for exitSuccess or killMyThread
12:31:13 <divVerent> nothing stops you from making your own such type though
12:31:39 <divVerent> EvanR: right, this special case
12:31:52 <ertes> davean: if it weren't for "fast and loose" i would have made it explicit immediately
12:31:59 <divVerent> Void is interestingly defined, BTW
12:32:04 <jle`> '()' can be thought of the type that gives you no information.  if you have a value of type (), then...it's ()
12:32:10 <divVerent> as Haskell syntax doesn't really let you define a type with no values
12:32:21 <EvanR> it does
12:32:22 <ertes> divVerent: IO's (>>=) isn't strict in the action's result
12:32:23 <jle`> some extensions do
12:32:31 <divVerent> EvanR: how? :)
12:32:32 <EvanR> enable the proper extension
12:32:43 <EvanR> data Void
12:32:49 <divVerent> Void is usually defined not as having no values, but as having no _possible_ values
12:32:54 <ertes> divVerent: only in the action itself:  pure undefined >>= const (pure ()) = pure ()
12:33:12 <divVerent> EvanR: oh right, that very specific extension :)
12:33:13 <ertes> so in principle you could use Void, but the problem is that you would need to return undefined explicitly
12:33:14 <EvanR> ime you would like to define Void as a type with no constructors
12:33:14 <jle`> is there a difference here between 'no values' and 'no possible values' ?
12:33:40 <ertes> you don't need extensions in H2010
12:33:40 <divVerent> data Void = Void !Void
12:33:40 <kadoban> It has impossible values maybe?
12:33:45 <divVerent> "to make a Void, you need a Void first"
12:33:47 <ertes> data Void  -- valid standard haskell
12:33:47 <divVerent> that's the trick :)
12:34:00 <EvanR> that definition is annoying because you can still seem to construct it 
12:34:18 <jle`> oh oh yeah, EmptyDataDecls is in Haskell 2010
12:34:21 <Cale> Well, because Haskell is an inconsistent logic
12:34:22 <jle`> so it's official haskell w/o extensions
12:34:23 <EvanR> if were trying to ignore bottoms, thats not helping
12:34:27 <Cale> :t fix id
12:34:28 <lambdabot> a
12:34:32 <divVerent> jle`: yes, that fixes the inconsistency :)
12:34:40 <ertes> it's not annoying because you can construct it, but because you can pattern-match on it
12:34:49 <ertes> in other words: you can't use -XEmptyCase
12:34:54 <Xyliton> https://github.com/TheFreakLord/Dog/blob/master/src/Main.hs is this "enough" to implement a cat-like feature? Or do I need to keep track of some weird edge-cases?
12:34:55 <EvanR> that too
12:35:21 <EvanR> EmptyCase gives you the support to define the Void eliminator, which is useful
12:35:32 <ertes> <Cale> :t fix id <divVerent> jle`: yes, that fixes the inconsistency :)
12:35:33 <ertes> =)
12:35:55 <EvanR> absurd :: Void -> a
12:36:27 <haroldcarr> In an HSpec test, how does one check an assertion from Control.Exception.Assert like: `(byEq assert "Bool" False True ())`
12:37:04 <divVerent> BTW, why not just
12:37:09 <divVerent> absurd a = undefined
12:37:23 <ertes> divVerent: because 'absurd' is valid
12:37:35 <divVerent> that's how I read ex-falso-quodlibet, though
12:37:41 <ertes> absurd = \case {}  -- with -XEmptyCase
12:37:45 <ertes> and -XLambdaCase
12:37:59 <divVerent> in other words, given the documentation, I don't see what absurd is good for where one can't just use "const undefined"
12:38:10 <ertes> 'absurd' proves that from non-sense you can deduce anything
12:38:41 <ertes> divVerent: (const undefined) is not logically valid, but 'absurd' is
12:38:59 <ertes> despite its unfortunate name
12:39:09 <divVerent> absurd doesn't seem that valid to me given its definition
12:39:10 <byorgey> divVerent: operationally, there's no difference.  Logically, it's significant that you are *not* required to use 'undefined' to implement 'absurd'.
12:39:18 <divVerent> it looks like the typical induction without starting case
12:39:19 <ertes> divVerent: but it is:  it's the empty function
12:39:45 <divVerent> byorgey: in that sense you mean
12:39:51 <divVerent> but well, then "fix id" says basically the same too
12:39:57 <ertes> divVerent: in category theory 'absurd' is that unique morphism from the initial object Void to any other object
12:40:01 <byorgey> absurd = "if you give me a purple unicorn, I will give you anything you want"  --- this is a logically valid statement
12:40:19 <byorgey> (assuming purple unicorns do not exist)
12:40:26 <ertes> divVerent: 'fix' is not logically valid
12:40:28 <divVerent> (except that "fix id" could also be seen as "anything is a fixpoint of the identity function"
12:40:30 <dolio> Operationally there is a difference.
12:40:42 <dolio> `const undefined` gives you garbage error messages.
12:40:55 <byorgey> dolio: good point =)
12:41:16 <divVerent> absurd doesn't look like it'd give any error messages
12:41:24 <divVerent> more like it waits for the pink unicorn to appear first :)
12:41:30 <divVerent> except that you can'
12:41:38 <ertes> divVerent: of course, since you can't apply absurd
12:41:39 <divVerent> t even call it in the first place on anything other than a bottom
12:42:01 <byorgey> divVerent: exactly.  (although in Haskell "undefined" is a purple unicorn.)
12:42:05 <ertes> you have no Void to apply it to =)
12:42:24 <byorgey> but if we are restricting to logically valid things, we rule out using undefined.
12:42:27 <EvanR> absurd doesnt give an error message because youll never run it
12:42:35 <EvanR> because you cant have a Void
12:42:44 <ertes> Xyliton: welcome to #haskell =)
12:42:48 <Xyliton> I don't want to interrupt this discussion, but could someone give me feedback on my cat implementation, please? It's hard to develop a good foundation if I don't know if what I do is "right" (the code works, but I'm not sure if it follows the "Haskell way" of writing code)
12:43:02 <divVerent> right (well, except as before, undefined is a Void, unfortunately... but then you'll get the same error as with using undefined in the first place)
12:43:27 <ertes> Xyliton: don't worry about the discussion…  support comes first =)
12:43:28 <EvanR> if you evaluate undefined, its an error, youll crash. but thats not what Void and absurd represent
12:43:29 <divVerent> well, looking at this cat
12:43:36 <divVerent> first of all, the return () seems unnecessary
12:43:40 <ertes> Xyliton: feel free to paste your code on lpaste.net
12:43:43 <divVerent> putStrLn already returns () for you
12:44:24 <byorgey> Xyliton: instead of mapM outfile args, use  mapM_ outfile args.  Then you don't need the final return () either.
12:44:36 <byorgey> mapM_ discards the outputs of the actions.
12:44:47 <divVerent> this use of readFile/putStrLn is fun, but there's a bug: you'll add an extra newline to the end
12:44:48 <ertes> huh?  did i miss the paste?
12:45:11 <Xyliton> ertes: https://github.com/TheFreakLord/Dog/blob/master/src/Main.hs
12:45:13 <divVerent> also I assume there's a neat way to combine the two to a one-liner :)
12:45:41 <Xyliton> divVerent: I tried "putStrLn . readFile path" but that didn't work
12:45:49 <divVerent> more like
12:45:51 <ertes> Xyliton: note that (return ()) is literally the action that does nothing
12:45:56 <divVerent> readFile path >>= putStrLn
12:46:05 <ertes> Xyliton: it doesn't "return" like it does in other languages
12:46:14 <mlehmk> putStrLn <=< readFile path?
12:46:15 <divVerent> but for a real unix "cat", just use putStr
12:46:25 <ertes> Xyliton: so you can remove it on line 8, too
12:46:56 <byorgey> getArgs >>= mapM (readFile >=> putStr)
12:46:58 <divVerent> so in the end, we get
12:47:03 <Xyliton> >>= is binding, right?
12:47:05 <byorgey> mapM_ rather
12:47:09 <jedai> mlehmk: outline = putStr <=> readFile
12:47:09 <divVerent> outFile path = readFile path >>= putStrLn
12:47:14 <jedai> mlehmk: outline = putStr <=< readFile
12:47:16 <divVerent> hehe, or even that, when golfing
12:47:24 <divVerent> s/Ln//
12:47:28 <Xyliton> what is >=> doing?
12:47:39 <Xyliton> and <=>?
12:47:46 <ertes> Xyliton: look at its type:  (>>=) :: IO a -> (a -> IO b) -> IO b  -- it composes an action together with a "next" action that depends on the result of the first
12:47:47 <jedai> Xyliton: <=> is an error sorry
12:47:50 <byorgey> Xyliton: <=> is a typo.  >=> is effectful function composition
12:47:54 <divVerent> @pl \ a -> f a >>= g
12:47:54 <lambdabot> (g =<<) . f
12:48:10 <divVerent> our friendly bot is better at generating unreadable nonsense than the golfers here ;)
12:48:17 <ertes> Xyliton: and f (>=>) g = \x -> f x >>= g  -- it's just a convenience in this case to avoid the lambda
12:48:24 <ertes> whoops
12:48:29 <ertes> Xyliton: and f >=> g = \x -> f x >>= g  -- it's just a convenience in this case to avoid the lambda
12:48:59 <Xyliton> Wow. I guess it will take some time for me to get used to that syntax
12:49:03 <divVerent> right, I suppose given the options, I'd now prefer outfile = readFile >=> putStrLn
12:49:07 <divVerent> nice symmetry there :)
12:49:20 <mlehmk> why putStrLn?
12:49:23 <divVerent> argh
12:49:27 <divVerent> because stupid finger memory
12:49:31 <divVerent> putStr, of course
12:49:31 <ertes> Xyliton: here is the equivalent to what byorgey wrote:  main = getArgs >>= (\fp -> readFile fp >>= putStr)
12:49:49 <jedai> At this stage do you even need oufile ? just use : mapM_ (readFile >=> putStr) args
12:49:51 <Xyliton> where's the difference between . and >=>? Isn't . binding too?
12:50:09 <ertes> Xyliton: look at the types (and read "m" as "IO"):
12:50:11 <ertes> :t (.)
12:50:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:50:16 <ertes> :t (>=>)
12:50:17 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:50:22 <jedai> Xyliton: (f . g) x = f (g x)
12:50:25 <mlehmk> well, . works for functions while >=> works for Monad
12:50:41 <Xyliton> oh. that's the problem.
12:50:44 <Xyliton> Thanks :)
12:50:47 <jedai> Xyliton: (f >=> g) x = f x >>= g
12:50:59 <Xyliton> >>= was binding, right?
12:51:09 <jedai> Xyliton: Right
12:51:21 <ertes> Xyliton: it's typically called that, and for IO it's composition of IO actions
12:51:32 <Xyliton> and <- was the syntactic "sugar" for it, right?
12:51:36 <ertes> yes
12:51:46 <divVerent> main = getArgs >>= mapM_ (readFile >=> putStr)
12:51:55 <jedai> Xyliton: "a >>= b" executes action "a" and pass its result to "b" that must return an action that you'll then execute
12:52:15 <Xyliton> jedai: could that be written as b <- a too?
12:52:42 <mlehmk> no, b <- a would be equivalent to a >>= \b -> ...
12:52:43 <jedai> Xyliton: no. more like "do { x <- a; b x }
12:52:51 <Xyliton> oh
12:53:05 <divVerent> but yes, sorry for that... ask a question about your code, and this channel will turn your whole source file into a one-liner. Always happens.
12:53:23 <divVerent> Haskellers are more efficient at this than Perl users :)
12:53:50 <mlehmk> do { x <- a; b x } = a >>= b
12:53:53 <mlehmk> I think
12:53:56 <ertes> Xyliton: read this: https://www.vex.net/~trebla/haskell/IO.xhtml
12:54:06 <divVerent> (it'd be "print for <>" in Perl, but you'd learn nothing from that)
12:54:26 <mlehmk> or with point: do { x <- a; b x } = a >>= \x -> b x
12:54:51 <Xyliton> divVerent: I want  to become efficient too, so that's not a problem. I just have to wrap my head around this"unusual" syntax :P
12:55:26 <divVerent> but anyway, regarding the explanations of . vs >=> etc.
12:55:36 <divVerent> . is only for functions where the argument types match up directly
12:55:43 <divVerent> i.e. (a -> b) -> (b -> c) -> (a -> c)
12:55:45 <mlehmk> >=> combine functions that return monads
12:55:51 <mlehmk> well actually use <=< for .
12:55:54 <divVerent> if you have two operations in a monad, you'll rather have (a -> m b) and (b -> m c)
12:56:07 <divVerent> so you'll need something that turns the "m b" into a "b" first before calling the other function
12:56:07 <mlehmk> <=< works in the same direction as .
12:56:31 <divVerent> inside a monad, the bind operation ">>=" is basically made for that: it takes m a and a -> m b and gives you a m b
12:56:45 <divVerent> and that's what >=> (or <=<) are implemented with
12:57:24 <divVerent> yes, >=> behaves more like a pipeline, <=< behaves more like function binding
12:57:35 <ertes> Xyliton: the link i gave you will answer all of your IO questions quickly and in a streamlined fashion…  if something remains unclear, ask again =)
12:57:47 <volhovm> Hi
12:57:50 <volhovm> My hackage build fails
12:57:54 <divVerent> personally I tend to prefer pipeline-like syntax for IO and function-binding like syntax for computation... but it's up to personal taste, which is why both >=> and <=< exist
12:58:00 <volhovm> but when i do `cabal install package-name` it installs correctly
12:58:09 <volhovm> what can be a difference?
12:58:11 <divVerent> (the former ESPECIALLY when reimplementing a unix tool)
12:58:20 <ertes> volhovm: compiler version perhaps?  hackage uses GHC 8.0.1
12:58:31 <volhovm> 8.0.1 for me too.
12:58:42 <mlehmk> is <> the concatenation of functions for monoids as ++ is the concatenation?
12:58:49 <ertes> volhovm: does 'cabal check' report anything?
12:59:16 <ertes> mlehmk: f <> g = \x -> f x <> g x = liftA2 (<>)
12:59:27 <divVerent> mlehmk: which <>?
12:59:40 <volhovm> ertes: nope, nothing suspicious.
12:59:54 <ertes> volhovm: did you read the build log from hackage?
13:00:37 <mlehmk> so I could have two functions returning a String and combine them using <> to make one function returning the concatenated String of both?
13:00:40 <volhovm> ertes: yes, it's some dependency problem i suppose. But i thought both hackage and cabal install should install same dependencies
13:00:55 <volhovm> is there any way to force the build?
13:00:57 <ertes> volhovm: wait, if you do 'cabal install package-name', you're not installing your local package
13:01:21 <ertes> volhovm: you should do 'cabal install' in the project directory instead
13:01:49 <ertes> mlehmk: yeah
13:02:02 <volhovm> to force the build on hackage*
13:02:25 <ertes> volhovm: which package?
13:02:42 <volhovm> https://hackage.haskell.org/package/serokell-util
13:02:50 <volhovm> >Build status unknown [no reports yet]
13:03:07 <ertes> volhovm: ah, then it didn't fail, but hasn't been built yet
13:03:11 <volhovm> I wasn't one who uploaded it but i need this package to be built
13:03:19 <volhovm> nope, this is different one.
13:03:26 <volhovm> https://hackage.haskell.org/package/time-warp-0.1.1.2/reports/1
13:04:14 <Jello_Raptor> I'd appreciate a bit of naming help. I've got a typeclass for sets of constraints on some type t, and a type family for the type that is being constrained. Right now the typeclass is called `Constraint` and the type family of called `Constraining` so `Constraint t => Constraining t` is the type that the constraint ranges over. but `Constraining t` doesn't scan well. I'd like a type family name that can be easily read as "The type 
13:04:15 <Jello_Raptor> that these constraints apply to"
13:04:51 <ertes> volhovm: does your local aeson version agree with the version hackage used in the build log?
13:05:23 <ertes> volhovm: (aeson got a major update recently)
13:06:40 <volhovm> ertes: i'm in the process of checking it, thank you
13:09:07 <glguy> volhovm: That package doesn't correctly specify its dependency bounds, so building it requires some manual intervention. For hackage to build it the author will need to update the bounds
13:11:01 <Xyliton> I tried some of the examples you gave me earlier and for some reason GHCi says that >=> is not in scope. What am I doing wrong?
13:12:10 <kadoban> Xyliton: You probably have to import it, it should be in Control.Monad:   "import Control.Monad ((>=>))"
13:13:49 <volhovm> https://www.stackage.org/lts-7.4/package/aeson-0.11.2.1
13:13:59 <volhovm> Why is it 0.11.2.1 when it's 1.1.2.1 on hackage? :|
13:14:30 <volhovm> whoops dumb question
13:15:53 <kadoban> volhovm: nightly has aeson 1.0.2.1, if that helps
13:15:56 <geekosaur> because something else hasn't updated so the old version is needed, or you are looking at an older resolver
13:16:13 <glguy> volhovm: This package appears not to support the latest aeson version which is part of the problem
13:16:23 <obadz> is GHC Core fundamentally inappropriate to encode an imperative language?
13:16:32 <jmorris> how can i map eqV over multiple inputs http://lpaste.net/340182
13:16:33 <Xyliton> kadoban: thank you so much! The problem is fixed :)
13:17:52 <volhovm> If i restrict the upper bound of this package to use aeson under 1.0.0.0, will hackage pick the correct version?
13:19:08 <Xyliton> Are there any simple "tasks" I could do to increase my knowledge?
13:20:05 <ertes> Xyliton: yes, 1. read the link i gave you ;) 2. write an interactive program like perhaps a hangman game
13:20:17 <EvanR> write a parser for lisp-like S expressions
13:20:17 <ertes> start by writing a simple number guessing game
13:20:53 <Xyliton> ertes: I can write something like a "main-loop" in haskell? :o
13:21:01 <EvanR> write a Show instance for your S expr type which looks like an S expr
13:21:04 <ertes> Xyliton: sure
13:21:12 <ertes> Xyliton: main = putStrLn "Hello!" >> main
13:21:17 <Xyliton> already read the link. But it's still a bit confusing imo
13:21:39 <sm> +1, everyone should write a number guessing game
13:21:44 <EvanR> goto10 = putStrLn "Hello World" >> goto10
13:22:08 <ertes> Xyliton: write a program that prints the numbers between 0 and 99, but you are not allowed to use lists
13:22:17 <ertes> and no code repetition
13:22:21 <Xyliton> hm...
13:23:16 <ertes> Xyliton: think about it recursively:  what's the first thing that a program does that is supposed to print the numbers from i to 99, where i <= 99?
13:23:17 <EvanR> write a function which merges two sorted lists
13:23:29 * EvanR looks for a book with a ton of exercises like this
13:23:49 <Xyliton> ertes: I thought I weren't allowed to use recursion?
13:23:59 <Xyliton> oh, fail
13:24:04 <Xyliton> you just said "no code repetition"
13:24:18 <ertes> Xyliton: yeah, i don't want you to write:  print 0 >> print 1 >> …
13:26:28 <Welkin> EvanR: calculate the mass of the universe inside a black hole
13:26:52 <Welkin> EvanR: I really hate those stupid "data structures 101" type exercises
13:26:52 <haroldcarr> In an HSpec test, how does one check an assertion from Control.Exception.Assert like: `(byEq assert "Bool" False True ())`
13:27:02 <James123_> I want to represent a graph where each node is an Int and is adjacent to some other nodes. It this correct? data Node = Int; data Graph a = Node a [Node a]
13:27:37 <Welkin> you will almost never encounter those situations and never need to write those programs
13:27:40 <glguy> volhovm: https://hackage.haskell.org/package/time-warp-0.1.1.2
13:27:41 <EvanR> data Node = Int is not right
13:27:52 <JonReed> James123_: type Node = Int
13:28:10 <Welkin> James123_: typically you use a table to represent the adjacency lists of the graph
13:28:10 <Tuplanolla> I must be doing something horribly wrong, because I encounter them a lot, Welkin.
13:28:17 <EvanR> and it is confusing to have a type Node and a constructor called Node, they will be unrelated
13:28:38 <Welkin> type Graph a = Vector [Node a]
13:28:40 <Welkin> something like that
13:29:10 <Welkin> Tuplanolla: in what?
13:29:13 <EvanR> the implementation of Graph depends on what you want to do with it
13:29:33 <JonReed> James123_: This creates a type synonym, making "Node" means the same thing as "Int". Everywhere you would use "Node" in you can use "Int" in because for compiler those things mean the same thing, type ThisType = EqualsToThisType
13:29:35 <James123_> EvanR: I want to find the articulation points of a graph
13:29:48 <Tuplanolla> Physics simulations and such, Welkin.
13:29:52 <Welkin> Tuplanolla: the only time I ever *had* to write a mergesort was for my game in lua, because lua is bare bones
13:29:59 <Welkin> Tuplanolla: I create web apps
13:30:09 <glguy> volhovm: I filed a ticket about the missing dependency bounds after manually uploading that documentation
13:30:11 <Welkin> I access a database, push it into a template, and call it a day
13:30:41 <EvanR> Welkin: the merge thing i mentioned does come up, and its not in the library
13:30:42 <ertes> even if you never need to write a merge-sort algorithm, you should know how to write it
13:30:53 <Welkin> sure
13:30:56 <maerwald> you can look it up
13:30:57 <Welkin> it's my favorite sorting algorithm
13:30:59 <Welkin> nice a simple
13:31:04 <Welkin> and*
13:31:14 <Welkin> I wrote it for fun in haskell a long time ago
13:31:28 <ertes> it doesn't make you good at data structures, it makes you good at pure haskell and recursive DSLs
13:31:36 <EvanR> but its true, in web programming you probably dont need to know very much of anything, its mainly a huge exercise in moving strings from one place to another
13:31:40 <EvanR> its not computer science
13:31:52 <Welkin> programming is not computer science either
13:31:53 <Welkin> :P
13:31:57 <EvanR> i noticed i had no use for anything i ever learned when i started
13:31:58 <maerwald> EvanR: that's largely false
13:32:12 <volhovm> glgys: thank you
13:32:12 <EvanR> database design though, is another story
13:32:14 <ertes> > foldr (flip (foldr (:))) [] ["it makes", " you wri", "te code l", "ike this"]
13:32:15 <lambdabot>  "it makes you write code like this"
13:32:25 <volhovm> Should this commit help? https://github.com/serokell/serokell-util/commit/9332869000fe37c2f321b22ee6716b41ae4d98d1
13:32:35 <volhovm> glguy: ^
13:32:37 <maerwald> if you do facebook-grade web programming, you need to know very much of everything
13:32:43 <maerwald> including haskell
13:33:09 <glguy> volhovm: It might, you should try building that package against those versions to find out
13:33:27 <glguy> volhovm: I don't know if aeson-1.0.0.0 is supported or not
13:34:37 <EvanR> facebook, a pile of APIs and premade javascript to take the strings out of the page, and get more strings from the cloud and insert them page into the page
13:34:54 <maerwald> ok, you don't know much about web programming it seems :)
13:34:57 <EvanR> back into the page. like, theres very little math involves
13:35:32 <EvanR> to the extent numbers show up, its to be formatted with commas
13:36:01 <glguy> volhovm: I uploaded the documentation for serokell-util, too
13:36:09 <maerwald> yeah, and there are no mathematical algorithms involved in the facebook backend... lol
13:36:25 <volhovm> glguy: thank you!
13:36:45 <EvanR> the analytics side of things, yeah. which isnt really web related
13:36:50 <maerwald> sure it is
13:36:52 <Welkin> people with no training in CS and rudimentary programming skills have built entire businesses on websites/software
13:37:03 <glguy> volhovm: You can create a fresh sandbox or with cabal's new-build if you want to see if things will work using a build plan just based on the build-depends constraints you've provided
13:37:04 <Welkin> they built their apps using whatever was laying around
13:37:18 <EvanR> your olap cubes and such works for many things, not HTML and CSS and string stores
13:37:29 <EvanR> not just*
13:37:55 <maerwald> you're trying to divide web programming into things you dislike (frontend) and things you like (analytical stuff, so not web related) which is just false
13:39:40 <EvanR> you might be ignoring most of web apps in your analysis, ecommerce, blogs, restaurant order forms, CMS
13:40:03 <EvanR> front and back, not much math needed or wanted
13:40:05 <Welkin> it's mostly businesses trying to sell something online
13:40:15 <mlehmk> writing a number guess game isn't really functional
13:40:26 <mlehmk> it's more putting statements together with a control structure
13:40:28 <Welkin> mlehmk: lol, sure it can be
13:40:41 <maerwald> EvanR: sorry, I don't have such a narrow concept of what web programming is and requires. I gave you an example where your argument simply does not fit.
13:40:58 <maerwald> and that's a pretty big field these days
13:41:18 <Xyliton> ertes: This is the smalled I could code I could achieve: http://lpaste.net/340196
13:41:19 <Welkin> it is exactly what it says... web programming
13:41:24 <Welkin> programming using http
13:41:28 <mlehmk> Welkin, is there a functional number guessing game example?
13:41:37 <heebo> i want to use the modules from one stack project on my machine in another stack project on my machine
13:41:38 <Xyliton> (for the numbers between 99 and 0 problem)
13:41:46 <Welkin> software that runs on the server completely separate from the web application doesn't qualify as "web programming"
13:41:49 <EvanR> thats pretty broad and might soon encompass almost everything ever, if it just needs to use HTTP somewhere
13:41:50 <heebo> can i just add the project name to build-depends?
13:41:54 <Welkin> sure, you could run some complex analysis on your server
13:41:59 <Welkin> that doesn't make it web programming
13:41:59 <ertes> > fitlerM (\_->[1<0..]) "abcd"
13:42:01 <lambdabot>  Stop code-golfing, it's pizza time!
13:42:16 <maerwald> EvanR: no, it's about the purpose of the system, which (for facebook) is pretty clear: provide a web service
13:43:01 <ertes> Xyliton: ok, i suppose reinventing 'fix' is a way to write it =)
13:43:02 <maerwald> (ignoring political stuff one might come up with)
13:43:08 <EvanR> having an HTTP interface, among others, makes it web programming, fine
13:43:10 <ertes> Xyliton: but i was hoping that you would just write a helper definition
13:43:25 <EvanR> now im wrong somehow without us even ever having talked about the same thing
13:43:44 <ertes> Xyliton: however, i said no lists
13:43:55 <Xyliton> oh, damn
13:44:00 <Xyliton> true, theres an empty list
13:44:23 <maerwald> EvanR: sorry, didn't know you were not talking about web programming then
13:44:26 <Xyliton> does it have to output a list, or just print the numbers?
13:44:28 <ertes> Xyliton: and there is (:), and there is 'show' on a list, etc.
13:44:37 <EvanR> tricky isnt it
13:44:41 <ertes> Xyliton: just print the numbers, one by one
13:45:07 <ertes> Xyliton: essentially the program should do this:  main = print 0 >> print 1 >> … >> print 98 >> print 99
13:45:13 <maerwald> well, maybe use proper terminology then instead of giving false claims on domains you're not describing accurately
13:45:18 <ertes> Xyliton: but without code repetition
13:45:40 <EvanR> you know what im talkinga bout
13:46:12 <maerwald> yes, I think it was a rather poor attempt at trolling ;)
13:46:30 <ertes> Xyliton: write a helper function:  printUpTo99 :: Integer -> IO ()
13:46:35 <maerwald> (not that I mind, since there was a technical side of the discussion)
13:47:03 <Xyliton> ertes: http://lpaste.net/340203
13:47:23 <Welkin> > let g n | n >= 0, n <= 99 = print (show n) >> g (n+1) | otherwise = return () in g 0 -- one way to do it
13:47:26 <lambdabot>  <IO ()>
13:47:29 <Welkin> lol lambdabot 
13:47:31 <Xyliton> unless "between 1 and 99" means "include the boundaries"
13:47:39 <ertes> Xyliton: ok, challenge solved…  good work =)
13:47:49 <ertes> Xyliton: that's fine, the point was to write it recursively
13:48:03 <Tuplanolla> I like the way you first used `fix`, Xyliton.
13:48:18 <Xyliton> Tuplanolla: why? 
13:48:28 <Welkin> lol
13:48:32 <ertes> Xyliton: now write a number guessing game…  the program should choose a secret random number and make you guess it, telling you whether you guessed too low or too high
13:48:36 * mekeor wonders why 'stack build' prints to stderr
13:48:39 <Tuplanolla> It's such a strange way to start.
13:48:56 <Welkin> and it should change the secret number every time you guess
13:48:56 <Welkin> :D
13:49:24 <Welkin> what is the probability you will be able to guess the number in some period of time?
13:49:26 <Xyliton> Tuplanolla: I first laid out a non-'fix' way and tried to reduce the char-count until I couldn't find any optimisations :P
13:49:46 <ertes> Xyliton: main = mapM_ print [0..99]
13:49:47 <ertes> =)
13:49:59 <Xyliton> ertes: but that uses a list :P
13:50:10 <Welkin> you could use a sequence :D
13:50:12 <Welkin> or an array
13:50:14 <Welkin> or a vector
13:50:19 <Tuplanolla> Or `enumFromTo`.
13:50:22 <dolio> Tuplanolla: There's a cool way to write initial value loops with fix.
13:50:23 <Welkin> and you would have answered ertes' riddle
13:50:23 <ertes> Xyliton: you used a list anyway ;)
13:50:31 <dolio> Using (??) = flip from lens.
13:50:44 <Tuplanolla> I've used it, dolio.
13:50:51 <dolio> Oh, okay. :)
13:50:52 <EvanR> dolio: can you show an example of that, i was trying to remember how it went and couldnt
13:51:05 <dolio> fix ?? x0 ?? y0 $ \x y -> ...
13:51:13 <ertes> Xyliton: i'll give you an interesting limitation again for the guessing game:  you may not use (<), (<=), (>) or (>=), but you may use 'compare'
13:51:24 <dolio> Er, \x y loop -> ...
13:51:40 <dolio> I think that's the right order.
13:51:50 <ertes> > (compare 3 4, compare 4 3, compare 3 3)
13:51:53 <lambdabot>  (LT,GT,EQ)
13:51:57 <dolio> loop is either at the beginning or at the end.
13:52:20 <Tuplanolla> This also works up to one argument, dolio: ``fix `flip` 0 $ \ f x -> ...``
13:52:39 <ertes> Xyliton: oh, and you may not use (==) or (/=)
13:53:03 <dolio> Oh, I guess loop is first, yeah.
13:53:05 <ertes> instead you will have to use 'case'
13:53:52 <Welkin> rofl ertes 
13:53:53 <Welkin> wtf is this?
13:54:09 <Welkin> you remind me of this instructor I had for the first programming class in uni
13:54:21 <EvanR> i dont understand not using lists 
13:54:29 <EvanR> isnt that a big deal in haskell to know
13:54:45 <Welkin> he made us do stupid things like "write this function that requires branching without using any control statements (no if-else)"
13:54:57 <Welkin> in c
13:55:10 <Welkin> we had to use *integer division* to do it
13:55:13 <Welkin> it was so ghetto
13:55:14 <tdammers> I was about to say, "that's cool, I'll just pattern-match"
13:55:15 <Tuplanolla> That's actually useful, unlike most other such exercises, Welkin.
13:55:19 <tdammers> but uhm, C
13:55:42 <Tuplanolla> I bring up physics simulations again.
13:56:02 <sabastiaan> Hello, I had a question about function definitions
13:56:28 <kadoban> Welkin: Sounds fairly interesting as an exercise. Could even be useful for optimizing (avoid pipeline stalls, etc.)
13:56:39 <geekosaur> usually you get a faster response by actually asking the question...
13:56:58 <sabastiaan> In one of the examples in LYAH they showed a function that takes another function 
13:56:59 * geekosaur thinks that exercise sounds like doing Stupid Assembler Tricks in C
13:57:19 <sabastiaan> (a -> b -> c) -> [a] -> [b] -> [c]
13:57:24 <Welkin> sabastiaan: it EATS a function!?
13:57:37 <Welkin> do these functions reproduce, too?
13:57:43 <Welkin> how do they control their population?
13:57:52 <geekosaur> *eyeroll(*
13:58:01 <sabastiaan> and called this function with (++ " somestring") somethingElse
13:58:38 <Welkin> would that make a good foundation for a science fiction story?
13:58:47 <mekeor> > zipWith (+) [0..4] [5..9]
13:58:49 <lambdabot>  [5,7,9,11,13]
13:58:54 <Welkin> functions fighting against the garbage collector that has enslaved them
13:58:56 <geekosaur> that sounds not quite right, since (++ " somestring") is not a -> b -> c, it's a -> a
13:59:00 <exio4> Welkin: int r[2]; r[0] = 10; r[1] = 20; return r[!!b]; ?
13:59:11 <kadoban> Welkin: Sounds like a FP version of tron
13:59:12 <Welkin> and they must make an offering at regular intervals, or they will all be destroyed
13:59:18 <geekosaur> Welkin, probably done already. also, sounds like corewars :p
13:59:20 <sabastiaan> edit nvm
13:59:44 <Cale> Welkin: http://worrydream.com/AlligatorEggs/
14:00:00 <geekosaur> also the backstory of TRON for that matter :p
14:00:42 <Welkin> "I've found that a schematic form of alligator calculus is actually rather handy for calculating lambda terms by hand."
14:00:43 <mekeor> Cale: wtf lol. "This game represents the untyped lambda calculus. A hungry alligator is a lambda abstraction, an old alligator is parentheses, and eggs are variables"
14:00:45 <geekosaur> (probably had to read the novelization to get that, much as people who watched the Star Wars movies without reading the novelizations didn't know about Palpatine until late)
14:00:53 <Welkin> alligator calculus?
14:01:16 <Cale> The eating rule corresponds to beta-reduction.
14:01:18 <sabastiaan> Can somebody explain to my why (+ 1) 2 returns 3? 
14:01:28 <geekosaur> :t (+1)
14:01:30 <lambdabot> Num a => a -> a
14:01:35 <Cale> sabastiaan: because 2 + 1 = 3
14:01:35 <Welkin> sabastiaan: (+ 1) is sugar for \a -> a + 1
14:02:07 <geekosaur> that is a section: a function made by partially applying an operator. as Welkin said, it is the same as \x -> x + 1
14:02:24 <mekeor> sabastiaan: (+) is a function, taking two arguments. (+ 1) is the function (+) applied to 1, that's why (+ 1) is a function taking one argument. `(+ 1) 2` applies (+ 1) to 2
14:02:26 <geekosaur> and it behaves as a function, which you can apply to a parameter
14:02:30 <Cale> Yeah, in general, if you have any infix operator (except for an exception involving -), you can apply it to just its left or just its right argument, wrapped in parens
14:02:40 <Cale> and it will give you a function of the other argument
14:02:52 <Cale> > (* 2) 10
14:02:54 <lambdabot>  20
14:03:02 <geekosaur> the (++ "something") earlier was also a section with the right-hand parameter supplied
14:03:05 <Cale> > (++ "world") "hello, "
14:03:08 <lambdabot>  "hello, world"
14:03:12 <geekosaur> \x -> x ++ " something"
14:03:23 <mekeor> Q: any ideas why i can't build structured-haskell-mode? this is the output of `stack build`: http://sprunge.us/fHDN
14:03:28 <Welkin> geekosaur: you seem to like using `x`
14:03:32 <Welkin> I tend to prefer `a`
14:03:38 <Welkin> anyone else?
14:03:50 <Welkin> just something I noticed when choosing variable names
14:03:56 <geekosaur> (the edge case is (-1), because haskell handles unary minus oddly that is a numeric literal. the Prelude provides "subtract" as a workaround)
14:04:04 <younder> Hmm. The Hinley-Milner-Damas typesystem, as used in ML and Haskell was deveoped first by Milner in 1969!
14:04:10 <glguy> mekeor: Ubuntu 16.10?
14:05:14 <mekeor> glguy: debian testing
14:05:35 <sabastiaan> so the parenthesis will create a partial of the body?
14:06:20 <geekosaur> in general, wrapping an infix/operator in parentheses turns it into a prefix/function instead
14:06:24 <geekosaur> :t (+)
14:06:26 <lambdabot> Num a => a -> a -> a
14:06:35 <glguy> mekeor: The new Ubuntu, and perhaps Debian testing, I don't know, have started building Position-independent executables by default
14:07:14 <mekeor> glguy: what does that mean?
14:07:17 <sabastiaan> geekosaur, aahhh ok, does this have any effect on prefix functions?
14:07:21 <geekosaur> sections work by letting you supply either parameter (but not both as that would be a normal application) in that syntax
14:07:27 <geekosaur> nope
14:07:35 <glguy> mekeor: It means you have to use a GHC that knows that it's now necessary to turn that off
14:07:42 <geekosaur> but there is a corresponding syntax to turn a prefix function into an operator
14:07:52 <geekosaur> > 'c' `elem` "abcde"
14:07:54 <lambdabot>  True
14:07:55 * younder is reading "The principal type-scheme of an object in cominatorical Logic bu R. Hidley" as a warm up to algorithm W step by step. An Hinley miller polymorphic type inference algorithm in Haskell. (from 2006)
14:08:52 <Tuplanolla> Yet this doesn't work.
14:08:52 <Tuplanolla> > (`elem`) 'c' "abcde"
14:08:54 <lambdabot>  <hint>:1:8: error: parse error on input ‘)’
14:09:07 <geekosaur> right, can't combine them
14:09:15 <geekosaur> also you can't partially apply with ``
14:09:46 <geekosaur> ...not that you need to, since prefix syntax works fine for that. it's operators that needed special syntax to enable partial application
14:09:48 <EvanR> would be nice
14:10:05 <sabastiaan> aaahhhh 
14:10:11 <sabastiaan> that makes a lot of sense 
14:10:12 <mmaruseacph2> actually
14:10:21 <mmaruseacph2> :t (`elem` [1,3,4])
14:10:22 <lambdabot> (Num a, Eq a) => a -> Bool
14:13:26 <geekosaur> mmaruseacph2, what you can't combine is the non-section forms
14:13:50 <geekosaur> (*) to turn infix * into a prefix, `x` to turn prefix x into an infix
14:14:29 <geekosaur> sections modify the syntax, and in those you can use `` to create an infix, then section that. (the syntax there that I said didn't work was partially applying inside ``)
14:19:59 <Polymorphism> sm: I've returned
14:20:52 <mekeor> glguy: i'd rather guess it's an ghc-8 issue..?
14:21:02 <ertes> EvanR: only in the first exercise lists were not allowed, precisely because you could just use a bunch of predefined functions…  in the second exercise only 'compare' is allowed in order to train pattern-matching
14:21:05 <ertes> Welkin: ^
14:21:50 <sm> Polymorphism: so! I am ready!
14:22:20 <Polymorphism> excellent
14:22:36 <Polymorphism> so when I last tried to build I was getting Irc.hs:47:3:
14:22:36 <Polymorphism>     Couldn't match expected type `IO a0' with actual type `Message'
14:22:36 <Polymorphism>  error
14:25:19 <sm> Polymorphism: yes, the privmsg function just makes a Message but doesn't send it. To do that, you can stick this in front of it: ircWrite opts bot' $ B8.unpack $ encode $ 
14:27:49 <sm> this should get it compiling. After that you'll have to test and debug it. I should tell you I tried it earlier and failed, talking to IRC servers can be a bit tricky
14:29:19 <ezyang> Is there a recommended tutorial for how to use Stack on windows? for example, what is the recommended console to use to interact with Stack? 
14:30:00 <mlehmk> what exactly does $ do?
14:30:06 <ezyang> :t ($) 
14:30:08 <lambdabot> (a -> b) -> a -> b
14:30:48 <Tuplanolla> :t id :: (a -> b) -> a -> b
14:30:49 <lambdabot> (a -> b) -> a -> b
14:31:09 <sbrg> ezyang: I don't know if there's a recommended one, but the built-in cmd.exe is embarassingly horrible. I think powershell might be pretty good if you want a powerful windows shell, but I personally prefer a proper one like bash or zsh
14:32:03 <ezyang> sbrg: But for bash, which bash?! 
14:32:15 <ezyang> AFAICT, msys2 bash handles ctrl-c embarrassingly horribly 
14:32:34 <geekosaur> mlehmk, ($) is just function application at lowest precedence instead of the normal (second highest, after record update syntax)
14:32:57 <jle`> mlehmk: might help to look at the definition of ($), becuase ($) is just a normal function for the most part
14:33:10 <jle`> ($) :: (a -> b) -> a -> b
14:33:12 <jle`> f $ x = f x
14:33:14 <sbrg> mlehmk: ($) doesn't actually do anything except ensure that function application happens in the way that would would like it to happen, because of its precedence. for example: I want to apply the composed function `foo . bar . baz` to the number `3`, but doing `foo . bar . baz 3` will parse as (foo . (bar . (baz 3))) essentially. 
14:33:15 <jle`> ta dah
14:33:21 <geekosaur> infixr 0 $
14:33:27 <mlehmk> jle` it would have helped to actually find the definition
14:33:29 <sbrg> so I can just do: foo . bar . baz $ 3
14:34:06 <jle`> here ya go
14:34:09 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#%24
14:34:15 <jle`> ($)                     :: (a -> b) -> a -> b
14:34:17 <jle`> f $ x                   =  f x
14:34:25 <jle`> pretty much exactly what i wrote heh, except for the whitepsace
14:34:35 <mlehmk> ahh, thanks
14:34:38 <jle`> infixr 0  $
14:34:53 <mlehmk> infixr means right associative?
14:34:54 <jle`> mlehmk: for the record, if you go to the docs, there are links to the source
14:34:55 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html
14:34:55 <amx> ezyang: cygwin shell works well for me (not stack-specific answer)
14:34:57 <sbrg> mlehmk: You never *really* have to use it. you can always get the same effect using parentheses, which some prefer
14:34:59 <grantwu> NOTA BENE: Do NOT use ($) anywhere in this module! The type of ($) is
14:35:02 <grantwu> slightly magical (it can return unlifted types), and it is wired in.
14:35:03 <sbrg> (foo . bar . baz) 3
14:35:04 <grantwu> But, it is also *defined* in this module, with a non-magical type.
14:35:06 <grantwu> GHC gets terribly confused (and *hangs*) if you try to use ($) in this
14:35:08 <grantwu> module, because it has different types in different scenarios.
14:35:10 <grantwu> Oops
14:35:10 <mlehmk> jle` the problem is searching for "$" actually
14:35:12 <grantwu> Did not anticipate it breaking across that many lines
14:35:27 <jle`> mlehmk: yeah, when you search for operators, search for ($)
14:35:39 <jle`> http://hoogle.haskell.org/?hoogle=%28%24%29&scope=set%3Astackage
14:35:50 <mlehmk> thanks
14:36:21 <MarcelineVQ> It woud be nice if the src bundled the fixity with the defintions, weird to have them all elsewhere (at the top)
14:36:41 <jle`> same for most other operators too in haskell in general :) ($) is the actual identifierfor that function, and f $ x is just the syntax to use it as an operator
14:36:48 <ezyang> amx: Are you using the cygwin toolchain? 
14:36:59 <jle`> for exmaple, if you wanted to import the ($) operator, you'd import Prelude ( ($), ... )
14:37:01 <ezyang> I get very afraid about install msys and cygwin at the same time since they really shoudn't be mixed 
14:37:25 <amx> ezyang: yes, I have only cygwin, no msys
14:37:25 <mlehmk> ezyang, no problem if you don't add them to PATH
14:37:27 <chreekat> ezyang: from my perch in the peanut gallery, I have not seen any such sort of recommendation. I suspect that using "native" tools (i.e. not cygwin) are more likely to be the right choice
14:37:29 <sbrg> ezyang: sorry -- I don't really use bash on windows. and never do development on windows. I get by with the bash that comes with git mostly
14:37:49 <JonReed> mlehmk: In Haskell function application happens always first so. `f a b` tries to feed argument `a` to function `f` and then argument `b` to `f a`. However if you use infix operators, then you delay that function application.  So in `f $ a b` first happens `a b`  because it now considers `a` a function since there is space between `a` and `b`. $ is
14:37:49 <JonReed>  basically NOP (do nothing operation) convert things around it to an infix expression,  and infix expressions evaluate after function application.
14:38:01 <mlehmk> what I really hate are things that install themselves in PATH and carry generic dlls with them
14:38:04 <ezyang> amx: Yeah, I need to test against msys built GHC, so that doesn't work too well. I agree that if you are all cygwin you'll have a nice experience 
14:38:22 <ezyang> mlehmk: ...really? I am not sure how well calling msys2 executables from cygwin shell will work 
14:38:28 <ezyang> sbrg: mintty then :) 
14:38:44 <mlehmk> ezyang, don't do it. Either use msys2 or cygwin in a session
14:39:00 <ezyang> yes, so let's assume that I'm trying to be "more native" 
14:39:13 <ezyang> sbrg: At least, that's what I think GitHub bash is 
14:39:15 <mlehmk> msys2 is just a fork of cygwin. So you could use either
14:39:35 <jle`> ezyang: have you tried the ubuntu bridge?
14:39:36 <EvanR> is there a flag to get asm output of ghc
14:39:42 <ezyang> jle`: Haha, you can't run ghc with that 
14:39:44 <sbrg> ezyang: i honestly wouldn't know. I hardly ever use it. but I also have utilities like grep, ls and some friends in PATH so sometimes I just use cmd
14:39:54 <jle`> ezyang: hm, i haven't tried.  does it not work realy? :'(
14:40:20 <mlehmk> ezyang, I have cygwin and msys2 installed and as long as I don't mix them, things work pretty well
14:40:28 <Polymorphism> I'll try that now
14:40:30 <jle`> i haven't tried installing stack because i've just started using a fresh install
14:41:33 <mlehmk> also, I have an msys-git and the msys of haskell installed as well...
14:41:51 <mlehmk> it just works as long as neither of these systems pollute PATH
14:42:03 <ezyang> jle`: Ubuntu bridge still doesn't support timers, which GHC needs 
14:42:21 <mlehmk> ezyang, and then there's Vagrant
14:42:21 <jle`> :(
14:42:49 <jle`> well how do i do haskell on windows then
14:42:54 <jle`> gotta plan for the next time i am on a plane
14:42:58 <ezyang> jle`: Some emulation layer 
14:43:21 <jle`> i used to do everything through cygwin and it worked well. but i got a fresh install recently and decided to go full bridge
14:43:22 <JonReed> EvanR: -ddump-asm ?
14:43:30 <EvanR> yeah just saw that
14:43:33 <JonReed> EvanR: I remember using this for some reason: https://github.com/shachaf/ghc-core
14:43:36 <mlehmk> jle`: install slack and use a batch file to enter the slack system, which sets the PATH locally and gets you started
14:43:39 <jle`> sad to hear that that's not possible at this point
14:43:50 <jle`> yeah, i hd it working before when i had an emulator level
14:43:57 <jle`> but i was hoping to be able to ditch that on this new machine
14:44:06 <JonReed> EvanR:Either output was not pretty or there was something more readable about it when using that util
14:44:07 <jle`> oh well
14:44:22 <xcmw> Why can't ghc figure out that b = Y with out a proxy? http://lpaste.net/340227
14:44:24 <mlehmk> stack* sorry
14:44:25 <JonReed> EvanR: It should work despite being ancient, I've used it recently
14:45:21 <jle`> xcmw: you never use 'b' in any of the arguments
14:45:33 <jle`> or in the return type
14:46:01 <jle`> oh hm
14:46:11 <BartAdv> Hi! I want to debug the segmentation fault I get in the foreign call, the library that's referenced is built with debugging symbols, however, when I run the resulting (haskell) program with gdb, it says the binary does not contain any debugging info..how one can go about this?
14:46:35 <jle`> that's the best i can give you w/o knowing the type of d1/d2
14:46:38 <jle`> but that's my best guess
14:47:19 <xcmw> jle`: b is used in the arguments?
14:47:29 <jle`> xcmw: alternatively you can supply 'b' using type applications syntax, l2 @Y
14:47:30 <Axman6> BartAdv: did you enable debugging symbols for the Haskell program too?
14:47:38 <jle`> xcmw: where?
14:47:57 <xcmw> jle`: (forall r c. K (r b) c => (Lens' (A r) c)) is the argument
14:48:25 <BartAdv> Axman6: I've got "-debug" flag in ghc-options (in stack.yaml)
14:49:02 <jle`> xcmw: yeah, but it's not clear what constraint you are giving when you use it wiht 'yi'
14:49:03 <xcmw> jle`: Or do type contraints not count?
14:49:26 <jle`> it is ambiguous what b is still if you use 'yi'
14:49:46 <jle`> hm, how about this
14:50:00 <jle`> yi :: K (r Y) c => Lens (A r) c
14:50:10 <jle`> but, l2 only gives the continution with a K (r b) c
14:50:19 <jle`> 'b' is chosen externally by the caller of l2
14:50:31 <jle`> so 'yi' can only be used if b ~ Y, so you have the right constraint
14:50:49 <jle`> but, 'b' is chosen and left up to the caller of l2 to decide
14:51:02 <jle`> so you could, say, call l2 yi w/ b as, say, X
14:51:19 <jle`> and then yi wouldn't be able to do its job
14:52:13 <EvanR> in generated asm, any idea how to identify places where allocation is occurring?
14:52:41 <EvanR> is it some sort of call to a standard ghc symbol
14:52:52 <Tuplanolla> Does Valgrind work at all, EvanR?
14:52:56 <xcmw> jle`: Ok, thanks.
14:53:07 <jle`> xcmw: it's not that GHC can't figure out that b ~ Y ... b and Y don't unify
14:53:08 <EvanR> i doubt it
14:53:08 <Polymorphism> so many errors 
14:53:14 <Polymorphism> starting to think this isnt possible
14:53:22 <jle`> xcmw: picking b ~ Y would give you the correct typeclass constraint
14:53:31 <jle`> but that doesn't mean that they unify
14:53:56 <xcmw> jle`: What do you mean by unify?
14:54:05 <jle`> unify as in, they are the same type necessarily
14:54:14 <jle`> like how 'Maybe a' and 'Maybe Int' would unify with a ~ Int
14:54:24 <jle`> a is necessarily Int
14:54:28 <jle`> but in this case, b isn't necessarily Y
14:54:41 <Polymorphism> http://pastebin.com/cbH6uaN1 sm
14:54:44 <xcmw> jle`: What else you it be?
14:54:50 <jle`> it can be anything
14:54:59 <jle`> it can be X, Z ... anyhting well-kinded
14:55:25 <jle`> anything of the same kind that Y is
14:56:05 <xcmw> jle`: Putting X as the proxy gives me an error and X has the same kind as Y
14:56:19 <jle`> xcmw: yes, it's an error because the typeclass constraints wouldn't be satisfied
14:56:31 <jle`> but not because b "can't" be X
14:56:36 <xcmw> jle`: Ok
14:57:01 <jle`> it's like picking a ~ Int for 'Maybe a' and 'Maybe Int' to unify would be necessary, but if Int doesn't satisfy the constraints, the compiler will give you trouble
14:57:49 <jle`> the problem isn't at the unification stage, it's at the typeclass instances stage
14:58:40 <jle`> for a simpler example, try foo :: (c => Int) -> Bool
14:59:09 <jle`> and pass in something that needs a 'Num' constraint
14:59:23 <jle`> the caller of 'foo' has the option of picking what 'c' will be
14:59:32 <jle`> and if it's not something that implies Num, it won't work
14:59:53 <jle`> the thing you're passing in needs a Num constraint, but foo could be called with 'c' to not be Num w/e.
15:01:51 <m`> can using takeWhile and dropWhile with the same predicate and on the same list being short-cutted?
15:02:08 <jle`> use span
15:02:25 <mlehmk> Okay, stack worked nicely
15:02:39 <m`> great, exactly what I was looking for
15:06:28 <BartAdv> hm, stack build --ghc-options="-ogtc-g" <- still the same, "no debugging symbols found"
15:06:53 <Polymorphism> http://pastebin.com/cbH6uaN1
15:07:01 <Polymorphism> can someone tell me whats wrong with line 46 please?
15:07:03 <Clint> BartAdv: opt is not spelled with a g
15:07:17 <heebo> how can i reference one stack project module from another if they both are not uploaded to hackage
15:07:23 <Polymorphism> http://pastebin.com/T3YdBsRg
15:07:25 <Polymorphism> working link
15:07:36 <Polymorphism> line 47]
15:07:38 <BartAdv> Clint: well, unfortunately it's typo only here, the command was ok
15:08:05 <jle`> heebo: you can add them to the extra dependencies
15:08:53 <jle`> heebo: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages
15:10:15 <Clint> BartAdv: oh, what made you think that would work
15:11:08 <geekosaur> Polymorphism, did you get an error message?
15:11:18 <BartAdv> Clint: you mean building with debugging symbols by passing -g to C compiler phase?
15:11:33 <BartAdv> I just hadn't got other ideas;)
15:11:44 <ezyang> amx, jle`, mlehmk, chreekat: I wrote some empirical notes https://gist.github.com/ezyang/ce2767f92ba2c90b7ea53eff5c3965a8 
15:11:51 <Polymorphism> geekosaur: Irc.hs:47:36:
15:11:51 <Polymorphism>     Couldn't match type `[Char]'
15:11:51 <Polymorphism>                   with `Data.ByteString.Internal.ByteString'
15:11:52 <Polymorphism> etc
15:12:43 <heebo> jle`: thanks
15:12:45 <Clint> BartAdv: if you're using ghc that won't do you any good
15:14:07 <Polymorphism> geekosaur: its my first time working with haskell so I'm having a lot of trouble
15:14:09 * geekosaur finally figures out since half the program missing and most of the error messga emissing and of course I can read your mind to figure the rest
15:14:22 <geekosaur> but, why exactly are you using BB.unpack there?
15:15:07 <Polymorphism> the author of the program was helping me, and suggested that
15:15:31 <Polymorphism> I'm hoping to paste a couple lines in and make this work. THen I will go and l earn haskell because I like it. But this I'm just trying to add a fairly simple feature
15:15:32 <geekosaur> oh, it does want a String. but then why do you encode on the other lines when ... right, I have to read your mind fr what exactly encode you are using and how polymorphic it is, too
15:15:35 <sm> Polymorphism is trying to make a small change to some existing code, using the same idioms it uses
15:16:09 <Polymorphism> indeed
15:16:21 <Polymorphism> I'd like to add code for the bot to identify with services upon connection
15:16:39 <sm> and yes, better questions are ones that don't make us work so hard
15:16:43 <Polymorphism> either directly while connecting or via a privmsg to nickserv
15:17:28 <Polymorphism> I'm not sure how to ask them better yet
15:17:36 <Polymorphism> as my haskell is so limited
15:17:47 <lpaste> sm pasted “Irc.hs that compiles” at http://lpaste.net/340254
15:17:51 <geekosaur> this is not a question of haskell
15:18:54 <geekosaur> it is a question of (a) where the parts whose source is not present came from, in what versions; (b) full error messages instead of forcing me to count characters (c) basically, providing examples that do not assume I will hack into your computer to find the missing pieces
15:19:52 <BartAdv> so, the symbols are there in the library .a file (peeking with objdump -g), but they're not there in final executable...am I missing some flag/option to get that?
15:20:11 <Clint> BartAdv: https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
15:20:21 <Polymorphism> whatever version of Irc.hs that is, its not compatible witht he rest of the files I have
15:20:51 <Polymorphism> if I knew what questions to ask I would be able to solve it myself, and I wouldnt be failing out of school. This doesnt come naturally to me
15:20:52 <Polymorphism> I'm forcing it
15:20:56 <Polymorphism> and I've been forcing it for too long
15:20:58 <Polymorphism> its time to call it how it is
15:20:59 <geekosaur> some versions of ghc explicitly strip executables on the theory that the symbols are not useful. (I wish they wouldn't)
15:21:15 <Polymorphism> I'll never be a programmer
15:21:26 <sm> oh come on now
15:22:04 <Polymorphism> its nothing but an exercise in frustration and I'm barely passing my classes, I need to face reality. It hasnt been getting any easier
15:22:12 <Polymorphism> and then people always saying I';m asking wrong questions or not phrasing right
15:22:15 <Polymorphism> I'm not a coder
15:22:22 <Polymorphism> there is some fundamental difference here between my mind and the rest of yours
15:22:32 <Polymorphism> because I dont know what you mean
15:22:52 * Polymorphism takes a deep breath
15:23:11 <sm> you have several of the prime attributes of a programmer. Laziness and hubris! (seriously)
15:23:30 <lordcirth> Dunno, he seems to be having trouble with the hubris part.
15:23:53 <lordcirth> Polymorphism, there are many professional programmers to whom it did not come naturally.
15:24:06 <sm> no, s/he is showing a lot of courage wading into this code with so little knowledge of haskell
15:24:11 <Welkin> it doesn't come naturally until you train yourself
15:24:16 <Welkin> like with anything else
15:24:27 <Welkin> no one is born knowing how to do these things
15:24:32 <sm> Polymorphism: I thought at first you knew more haskell, because you were so willing to rebuild and patch stuff
15:24:45 <Polymorphism> I should have mentioned I've never used it before
15:25:08 <sm> I think this project is a bit too hard for your current level (today, anyway). Note that I tried and failed also :)
15:25:08 <BartAdv> Clint, yeah, this is what I've stumbled upon first, it mentions -debug flag and I'm not sure if it just says the source-level debugging is only possible when crash happen in the runtime itself?
15:25:09 <Welkin> I am often completely lost when it comes to a lot of conversations in here
15:25:21 <lordcirth> Me too
15:25:27 <lordcirth> I still don't understand monads, really
15:25:31 <Welkin> but it's motivation to learn something new
15:25:46 <Clint> BartAdv: you want to have debug symbols from some static C library compiled into your haskell binary and then what?
15:25:53 <Polymorphism> I'm going to start at the beginning with some basic haskell tuts
15:26:12 <sm> Polymorphism: yeah, you even suggested that earlier and I talked you out of it. Blame me :)
15:26:15 <lordcirth> Polymorphism, good!  I recommend "Learn you a Haskell"
15:26:20 <Clint> BartAdv: are you writing FFI bindings yourself?
15:26:20 <sm> http://tryhaskell.org is a great place to start
15:26:51 <Polymorphism> ty
15:27:14 <BartAdv> Clint: maybe better would be to put it in another way: just want to debug the foreign call crash. Yes, I'm not using any inline-c stuff
15:28:20 <sbrg> Polymorphism: I don't recommend LYAH as your sole resource, but it can be handy because it is very .. pedagogical. I think people these days are recommending www.haskellbook.com
15:28:48 <sbrg> https://github.com/bitemyapp/learnhaskell good collection of learning resources here
15:28:50 <hpc> i don't recommend anything as your sole resurce
15:28:58 <sm> and if you want to keep hacking on rss2irc in parallel, since that's a project you care about: best to get set up properly, and check out the latest source
15:29:00 <sbrg> hpc: good point
15:29:06 <hpc> read anything remotely decent until its shortcomings make it hard
15:29:40 <hpc> cis194 is probably the best by that metric
15:29:49 <hpc> LYAH is pretty alright too, though totally lacking in exercises
15:30:01 <Welkin> hpc: what about Party Hard?
15:30:22 <hpc> Welkin: wrong channel?
15:30:23 <Polymorphism> Out of all these suggestions, which should I read first?
15:30:24 <lordcirth> Yeah, exercises would be a good addition, come to think of it
15:30:27 <Polymorphism> I don't want to start off on the wrong foot
15:30:31 <sm> Polymorphism: the one I suggested :)
15:30:33 <Welkin> hpc: except all of the party guests are side effects
15:30:38 <Polymorphism> ok
15:30:54 <yulax> nq
15:31:03 <sm> if you get stuck with that, or when you're done, come back for more
15:35:52 <n_blownapart> "The Haskell Road to Logic, Maths and Programming"  <<  any books worthwhile similar to this but more for novice? I've been working on the sicp book for scheme, but it is over my head.
15:37:16 <jle`> n_blownapart: what is your goal?  learning how to program haskell practically?
15:39:55 <n_blownapart> jle`: thanks alot. I'm self-learning, so the above book seems a bit daunting like sicp. I enjoy math but its hard to ascertain if a cs book is right for someone. I have gone through 23 problems in the sicp book. It has taken months and I'm barely halfway through chapt. 1 
15:40:21 <jle`> i'm asking because it's difficult to recommend a book without knowing what your goal is
15:40:24 <jle`> what are you self-learning to do?
15:40:42 <EvanR> n_blownapart: thanks for the reference
15:42:09 <EvanR> how do you write a function which returns IO Int# ?
15:42:24 <EvanR> return for IO doesnt have the right kind
15:42:28 <n_blownapart> interesting gainful employment eventually, jle`   ..  I am trying to learn math along the way. scheme is interesting but I'm intimidated
15:42:47 <jle`> employment in what industry...mathematics research?
15:43:28 <n_blownapart> no, but I do like the math aspect of FP.. also ...
15:43:44 <glguy> EvanR: You don't; you write one that returns something that contains an Int# but has the correct type, like an Int
15:43:47 <jle`> i have a hard time believing that the first book you mentioned is the best book if your eventual goal is employment.  it's a nice treatise but it's not geared directly towards practical programming i don't believe
15:43:48 <glguy> err, correct kind
15:44:04 <jle`> n_blownapart: so, what industry...?
15:44:27 <jle`> just asking becuase you're saying "recommend a book", but ... a book for what?  learning haskell for practical programming?
15:44:35 <jle`> or just a book that is "like" Haskell Road to Logic?
15:44:59 <EvanR> oh
15:45:03 <jle`> sort of like walking into a supermarket and asking "recommend an item to buy"
15:45:10 <EvanR> i need to box it
15:45:12 <sbrg> i think learning haskell just means learning it for practical programming. 
15:45:30 <jle`> yes, but it isn't clear that n_blownapart really even wants to learn haskell.  especially because the first book is not a haskell-learning book
15:45:35 <n_blownapart> I am fascinated by the programs as proofs idea and that haskell is set up well for math.   the industry is not important at this moment. part of the problem is I'm trying to decide if I should switch over to haskell, given the resources, community, etc
15:46:05 <jle`> n_blownapart: are you just interested in books to expand your mind/interesting proofs/ideas ...?
15:47:03 <n_blownapart> yes books that teach haskell as well. jle`  also ...
15:47:12 <Tuplanolla> If that's your goal, I could even consider skipping Haskell, n_blownapart. After SICP you should be ready for Software Foundations.
15:47:30 <sbrg> n_blownapart: "switch over"? Well, you're not getting married. I think you should learn Haskell, and I think that if you do, you will like it. It has decent tooling, very good libraries for most everything you need(And an easy-to-use C FFI if you not) and excellent for general purpose programming.. but I'm biased
15:47:55 <jle`> i can give you a couple books that teach haskell, like 'haskell from first principles', and LYAH
15:48:00 <n_blownapart> thanks all  .. if I may explain further.
15:48:07 <jle`> but they are nothing like Haskell Road to Logic
15:48:13 <lordcirth> I've no idea if the project I'm trying to write in Haskell will ever work out - but it's sure more fun than C++
15:48:17 <EvanR> how do you box an Int# ?
15:48:30 <Tuplanolla> Just `I#` it, EvanR?
15:48:32 <jle`> how do you catch a cloud and pin it down?
15:48:33 <EvanR> ah
15:49:01 <EvanR> which module is that in
15:49:31 <EvanR> GHC.Types
15:49:43 <n_blownapart> I just don't know what I'm doing. sicp has a problem that uses successive squaring and binary exponenentiation. my background is weak though I have been learning it. Its the *pace* that is sort of killing me and depressing me.
15:50:47 <n_blownapart> I spent six months on 23 problems in sicp. some of it I understand very well, and have hand-written outputs of linear recursion, etc. 
15:51:21 <n_blownapart> at this rate, I'll finish sicp in like 2 years.
15:51:22 * sm can't take the suspense. n_blownapart, http://haskellbook.com is very good and thorough
15:52:02 <n_blownapart> thanks sm
15:52:49 <lordcirth> $60 is a lot
15:52:53 <lgstate> after programming in haskell, how does one ever write an interpreter in a language without moands ?
15:53:23 <sm> yes it is
15:53:25 <geekosaur> with much wailing and gnashing of teeth >.>
15:53:41 <lgstate> yeah; I need an Either monad for handling exceptions
15:53:49 <lgstate> a State monad for handling program stack / dat astack
15:54:01 <lgstate> without monads, all this plumbing gets messed up all over the place
15:54:04 <Koterpillar> lgstate: s/write an interpreter/do _anything_/
15:54:28 <sbrg> I want ADTs everywhere
15:54:30 <Tuplanolla> Just call `abort` whenever something smells funny, like real C programmers, lgstate.
15:54:41 <sbrg> and higher-kinded types
15:58:34 <lgstate> argh, but fighweel, devcards, reagent, and cljs are so awesome
16:19:00 <bombermap> is there any way to share a function here?
16:19:47 <glguy> http://lpaste.net
16:23:01 <lpaste> Bruno pasted “error” at http://lpaste.net/340273
16:25:31 <glguy> bombermap: You should paste the whole code
16:28:10 <erisco> is Bruno bombermap?
16:28:20 <erisco> the paste is missing posJogadorAux
16:46:19 <lambda-11235> > head (map read (words "3 2 2"))
16:46:22 <lambdabot>  *Exception: Prelude.read: no parse
16:47:05 <lambda-11235> > head (map read (words "3 2 2")) :: Int
16:47:08 <lambdabot>  3
16:47:37 <glguy> That wasn't the problem in this case
16:50:13 <lambda-11235> glguy: I'm just going by the post, which incorrectly has `:: [Int]`.
16:50:36 <glguy> It was correct in the code, the :: [Int] was inside the parentheses
16:50:36 <erisco> check your brackets again
16:51:00 <glguy> It would have been a type error otherwise; it was being checked for equality with an Int
16:51:53 <lambda-11235> erisco: Ah, ok. I see it.
16:52:02 <erisco> the problem may be in posJogadorAux or it may be something goofy with non-printable characters
16:54:45 <erisco> maybe it isn't using the same words
17:19:00 * hackagebot octane 0.17.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.17.0 (fozworth)
17:47:46 <Welkin> how can I get hakyll to copy all subdirectories too?
17:47:58 <Welkin> using copyFileCompiler
17:48:22 <erisco> does it do stringy path matching? probably **
17:48:40 <hodapp> erisco is right
17:48:47 <Welkin> let me try
17:48:50 <Welkin> I never knew about that
17:48:57 <Welkin> I would always add the -R flag to `cp`
17:49:33 <Welkin> it's time to finally pimp my hakyll blog
17:49:45 <Welkin> and add tags, share buttons, etc
17:50:25 <Welkin> nope
17:50:27 <Welkin> didn't work 
17:51:11 <Welkin> oh let me try again
17:51:18 <Welkin> I put it on the wrong route
17:51:29 <erisco> base/**/*.hs    all .hs files under base
17:53:03 <Welkin> ナイス！
17:53:08 <Welkin> it works
17:53:11 <hodapp> \o/
17:53:34 <Welkin> has anyone else pimped their hakyll blog?
17:53:48 <Tuplanolla> I plan to do that later this year.
17:54:00 <hodapp> mine uses Hakyll but could really use some CSS love
17:54:48 <Tuplanolla> I currently use webgen, but it gets more and more painful as it grows. I need to step up my game and replace it with Hakyll or something.
17:55:17 <Welkin> the only thing I dislike about hakyll is the template system
17:55:19 <Welkin> it's too basic
17:55:21 <Welkin> and weird
17:55:32 <Welkin> I wonder if I could replace it with lucid or something
17:56:24 <Tuplanolla> I want to unify my projects, publications, teaching materials and version control repositories under one system that takes care of the whole mess.
17:56:31 <kadoban> I have a blog, I'm not really sure I'd call it pimped, but then again I don't really want all that share crap either.
17:56:40 <kadoban> The CSS could use an update though ... should really do that sometime.
17:56:48 <Welkin> kadoban: I just added static icons for sharing
17:56:59 <Welkin> this site is great for that: https://simplesharingbuttons.com
17:57:10 <Tuplanolla> Just thinking about web development makes me nauseous.
17:57:13 <kadoban> Welkin: Might be okay ... pretty sure nobody would use them anyway though, I barely ever post, haha.
17:58:36 <Welkin> and then for comments
17:58:42 <Welkin> that is the only thing missing from hakyll, of course
17:58:43 <ertes> mine is pandoc-only via a simple Makefile
17:58:44 <kadoban> Guess it wouldn't actually hurt to add those, maybe I will next time I do anything to my blog.
17:58:58 <kadoban> Welkin: You can use discuss or whatever that JS thing is, that's what I'd probably do if I actually wanted comments.
17:59:04 <Welkin> I don't like disqus, as I'd like to own my comments and not ad spyware to my site
17:59:16 <ertes> http://ertes.eu/
17:59:18 <Welkin> I thought about making an oss haskell version of disqus
17:59:22 <Welkin> that you run yourself
17:59:22 <kadoban> Ah, then I'm not sure. I guess you could do something similar, yeah.
17:59:36 <Welkin> there is some python project that already does that
17:59:41 <Welkin> but I don't like it too much
17:59:46 <ertes> i thought about using lucid and clay, but ultimately i just wrote a simple Makefile
17:59:57 <Tuplanolla> How about Shake?
18:00:08 <Welkin> yeah, here it is http://posativ.org/isso/
18:00:09 <ertes> too much
18:00:49 <ertes> if i'd use shake, i might as well use hakyll
18:01:07 <Tuplanolla> Your website is indeed quite simple.
18:01:12 <Welkin> I always just write plain css
18:01:20 <Welkin> but I can't stand writing html manually any more
18:01:21 <Welkin> it's too much
18:01:31 <Welkin> and easy to mess up
18:01:44 <hodapp> Welkin: let us know what you find in the way of comments
18:01:51 <ertes> Tuplanolla: i wanted it that way…  i even went without feeds for this one
18:01:55 <hodapp> I know there are some Disqus alternatives and I think I've read of some self-hosted ones
18:01:57 <kadoban> Welkin: Looks pretty nice
18:02:05 <Welkin> lol ertes, "legal information" link at the bottom
18:02:11 <hodapp> hm, Shake would be overkill for most static website content
18:02:12 <Tuplanolla> Oh, simple is good if it's an option, ertes.
18:02:28 <Welkin> hodapp: yeah, like the one I linked, which also talks about other alternatives
18:03:22 <ertes> Welkin: the "german law requires this" part?
18:03:41 <hodapp> Welkin: oh! I misread the context and didn't realize that's what that was
18:04:30 <Welkin> although I don't care to install python on my server
18:04:38 <Welkin> would rather have all the servers/apps be in haskell
18:04:45 <Welkin> and I wonder if I could use that with keter
18:04:49 <ertes> lovely, isn't it?  malicious lawyers are cheating money out of website operators for not putting that non-sense on every stupid page
18:05:02 <Welkin> which requires the server to read the port from the environment variable PORT
18:06:00 <Tuplanolla> Now that you have an address up, you can demand postcards from visitors, ertes.
18:06:57 <ertes> indeed =)
18:12:24 <MarcelineVQ> "german law requires this" that is truly disgusting 
18:12:50 <Tuplanolla> Could you put a dozen other addresses in there as well?
18:14:56 <kadoban> Wait, german law really requires you to have your physical address on your website? That seems ... bizarre. Can you get around it by using whatever the german version of an LLC is?
18:15:38 <Welkin> in the US, you need to provide a mailing address on all emails sent to a mailing list
18:16:18 <kadoban> From a mailing list you mean?
18:18:16 <ertes> Tuplanolla: probably not, although the idea is nice =)
18:18:43 <Koterpillar> interestingly your whois is hidden
18:18:56 <ertes> kadoban: i don't know
18:19:04 <kadoban> At least in whois I can use a PO Box
18:19:52 <ertes> well, nobody would really care, but as i said, unfortunately people are exploiting the law
18:20:38 <Welkin> mine are all hidden
18:20:52 <Welkin> I always pay for the whois protection
18:22:38 <kadoban> Welkin: Tends to be kind of a scam designed to lock you into a place, in that to switch registrars, you have to remove it.
18:23:12 <Welkin> I don't intend on switching though
18:23:51 <ertes> the funny thing is that this is supposed to be for business websites, so lawyers and courts have a way to write letters to the…  you know…  do the Land Der Bürokratie thing
18:24:18 <ertes> but the law says "geschäftsmäßig" (like a business), not "geschäftlich" (business), and doesn't specify what that means
18:24:48 <jle`> i thought english was the only imprecise language
18:25:40 <Tuplanolla> Maybe you should've thought in another language.
18:25:42 <kadoban> Hah, naw, every natural language is imprecise. It's pretty much the defining characteristic.
18:25:51 <MarcelineVQ> english makes up words by verbing proper nouns, germans make up words by cramming a bunch of words together, in the end no one has a good time
18:26:32 <Koterpillar> (plus words borrowed from other languages and then same techniques applied)
18:27:36 <ertes> welcome to the language kindergarten =)
18:28:11 <monochrom> When will English borrow from Haskell and support lambdas?
18:28:31 <Tuplanolla> It's design by committee and everyone's invited.
18:28:32 <MarcelineVQ> idk but I partially apply english all the time
18:29:31 <ertes> unfortunately english has rather bizarre types
18:29:33 <Axman6> it's a comittee of about half a billion people most of which don't know each other and many which don't like each other
18:29:43 <jle`> english needs to enable -XStrict
18:29:55 <jle`> and... -XEmptyDataDecls ?
18:31:00 <jle`> it already has -XOverloadedStrings
18:31:10 <Hafydd> Hahaa.
18:31:15 <jle`> which you can't turn off
18:31:31 <jle`> ok that's all i got
18:31:43 <ertes> it has GADTs
18:31:48 <ertes> and UncountableTypeClasses
18:32:28 <erisco> Uncountable? oO
18:32:39 <jle`> -XIncoherentInstances
18:32:43 <jle`> lots of those
18:34:13 <monochrom> InaccessibleCardinalTypeClasses
18:34:41 <cloudhead> is there something better than a Map for data that is loaded only once, upon initialization?
18:34:56 <jle`> cloudhead: hm, what do you mean?
18:34:59 <ertes> I :: Pronoun
18:35:01 <cloudhead> something in between a record and a map I guess
18:35:02 <ertes> have :: Verb
18:35:03 <ertes> time :: a
18:35:10 <jle`> cloudhead: do you mean with keys that are known at compile-time?
18:35:21 <cloudhead> jle`: yeah actually, they would be
18:35:29 <monochrom> I think it depends more on how you use the data than how many times to load.
18:35:39 <ertes> cloudhead: what type of keys?
18:35:41 <jle`> a record is probably your best bet if the number of fields is not too big
18:35:52 <cloudhead> ertes: could be anything, I'm flexible on that part
18:35:53 <jle`> also there's always just a normal function
18:36:04 <jle`> if *every* key has an inhabitant, then you can just have a function Key -> Val
18:36:25 <cloudhead> jle`: but I need to perform IO to load the Vals
18:36:29 <ertes> cloudhead: Map and HashMap are the most flexible
18:36:45 <jle`> cloudhead: well, you aren't going to avoid IO with a map either if that's the case ...
18:36:54 <monochrom> I teach a data structure course and the first lecture I explain why we have such a wide spectrum of data structures and why we care.
18:36:55 <ertes> cloudhead: you can produce a function in the end (as the API), but you still need an underlying data structure
18:36:55 <jle`> once you do you can pass it as an argument to your functions that use it
18:37:13 <cloudhead> jle`: I mean I can't really define a top-level function with a value that requires IO to materialize
18:37:21 <monochrom> And the answer is each one optimizes for one kind of accesses and gives up on others.
18:37:31 <jle`> cloudhead: you'd load it once and then pass it as an argument to all the functions that need it
18:37:45 <jle`> cloudhead: it looks like this issue doesn't have to do with Map, then, because it's the same issue w/ Map
18:37:50 <monochrom> So if you ask what data structure to use, the point is how you access it rather than how many times to load.
18:38:06 <cloudhead> jle`: ah so as a record for ex
18:38:15 <jle`> even if you use Map, if the values come from IO, you'd have to do IO to populate the map
18:38:17 <cloudhead> monochrom: yeah, I need to access it a lot in a tight loop
18:38:19 <jle`> and then pass it as an rgument
18:38:39 <cloudhead> yes, that's what I'm doing currently
18:38:43 <ertes> cloudhead: be less flexible about the key type
18:39:00 <cloudhead> I just feel like it's "too dynamic"
18:39:13 <cloudhead> since I'm using strings as keys
18:39:40 <jle`> oh, what
18:39:43 <ertes> do you have to?
18:39:47 <cloudhead> I don't
18:39:54 <jle`> use your own defined enumerator as a key if possible
18:40:00 <cloudhead> since the keys are known at compile time
18:40:15 <cloudhead> right, so Map MyEnum Val
18:40:30 <ertes> for tight loops (if performance matters) you should pay attention to cache
18:40:49 <ertes> in general i'd go for something very compact
18:41:07 <cloudhead> a record makes more sense then?
18:41:12 <ertes> like a sorted vector or a hash table (they can be pure, if they are read-only)
18:41:24 <ertes> an unboxed record, too
18:41:34 <cloudhead> I thought of a vector, but not sure what to use for keys then
18:41:40 <cloudhead> perhaps pattern synonyms
18:41:45 <cloudhead> seems a bit messy
18:41:45 <ertes> Int
18:41:57 <ertes> perhaps together with an enumeration type
18:42:07 <cloudhead> right, but I need some kind of wrappers around ints
18:42:27 <cloudhead> is there a way to derive Ints from a sum type?
18:42:35 <ertes> @let data MyEnumType = AA | BB | CC | DD  deriving (Bounded, Enum, Eq, Ord, Show)
18:42:37 <lambdabot>  Defined.
18:42:40 <kadoban> cloudhead: Sounds like Enum
18:42:42 <ertes> > [AA..DD]
18:42:44 <lambdabot>  error:
18:42:44 <lambdabot>      Not in scope: ‘AA..’
18:42:44 <lambdabot>      No module named ‘AA’ is imported.error:
18:42:49 <ertes> > [AA .. DD]
18:42:51 <lambdabot>  [AA,BB,CC,DD]
18:42:57 <cloudhead> ah super
18:42:59 <ertes> > fromEnum [AA .. DD]
18:43:01 <lambdabot>  error:
18:43:01 <lambdabot>      • No instance for (Enum [MyEnumType])
18:43:01 <lambdabot>          arising from a use of ‘fromEnum’
18:43:04 <ertes> > map fromEnum [AA .. DD]
18:43:06 <lambdabot>  [0,1,2,3]
18:43:18 <cloudhead> neat
18:43:32 <cloudhead> yeah that's a nice solution
18:44:40 <ertes> cloudhead: if you can define a record, define a record
18:44:53 <Lokathor> so is atom + stack + ghc-mod in a state where i should try getting them to work together?
18:45:10 <ertes> cloudhead: it's the same thing, if the fields are unboxed (just make them strict)
18:45:20 <cloudhead> ertes: if I do it the record way, I'd essentially be passing getters around
18:45:23 <cloudhead> which I guess is ok
18:45:34 <ertes> cloudhead: why not the record itself?
18:45:40 <cloudhead> ie: the equivalent of passing EnumValue1 would be a function
18:45:48 <cloudhead> well, when selecting one value I mean
18:46:05 <ertes> then pass the value itself, not the index to it
18:46:35 <xcmw> Stupid question: Why does this error? http://lpaste.net/340302
18:46:39 <cloudhead> hmmm
18:46:44 <ertes> unless the index is relevant
18:47:02 <cloudhead> yeah it's part of a high level interface
18:47:42 <cloudhead> so you don't really have access to the actual data structure
18:47:53 <Polymorphism> I'm going to take another crack at this
18:48:15 <cloudhead> thanks though I think I have a few ideas to try out now
18:49:43 <surina> I'm trying to do very basic exercises. Could someone explain why (x - mod x 10) / 10 (where x is Integer)is not a valid expression in Haskell?
18:50:59 <surina> I think (x - mod x 10) should always be an Integer
18:51:03 <erisco> :t \x -> (x - mod x 10) / 10
18:51:05 <lambdabot> (Integral a, Fractional a) => a -> a
18:51:29 <Koterpillar> :t \x -> (x :: Integer - mod x 10)
18:51:30 <lambdabot> error:
18:51:30 <lambdabot>     Not in scope: type constructor or class ‘-’
18:51:37 <Koterpillar> :t \x -> ((x :: Integer) - mod x 10)
18:51:39 <lambdabot> Integer -> Integer
18:51:43 <erisco> it is syntactically valid but there are no types which are both Integral and Fractional
18:51:57 <Koterpillar> it says x is integer anyway
18:52:06 <Koterpillar> (1 :: Integer) / (2 :: Integer)
18:52:10 <Koterpillar> > (1 :: Integer) / (2 :: Integer)
18:52:11 <lambdabot>  error:
18:52:12 <lambdabot>      • No instance for (Fractional Integer) arising from a use of ‘/’
18:52:12 <lambdabot>      • In the expression: (1 :: Integer) / (2 :: Integer)
18:52:25 <LordBrain> use div
18:54:09 <xcmw> works with Factionals and div works with Integrals
18:54:09 <Welkin> divMod
18:54:14 <Welkin> Factionals :D
18:57:14 <EvanR> / works with Fractional*
18:57:55 <winter> https://mail.haskell.org/pipermail/libraries/2016-November/027426.html
18:58:06 <winter> Is there any downside to this request?
18:58:47 <EvanR> :t bool
18:58:48 <lambdabot> a -> a -> Bool -> a
18:58:58 <EvanR> the order of arguments is better this way
18:59:11 <Welkin> EvanR loves arguments
18:59:28 <EvanR> but perhaps the implicit request is to remove if-then-else special syntax from the language?
19:00:21 <EvanR> theres definitely downsides to that
19:00:28 <winter> I'm just thinking (xxx ? yyy $ zzz) is a nice style
19:00:50 <winter> So it's not to ask remove if-then-else special syntax
19:01:15 <EvanR> you can define that function if you want but a -> a -> Bool -> a will be easier to compose
19:01:45 <winter> Yes i'm aware the existence of `bool`
19:02:23 <winter> I'm asking to add (?), and want hear more downside about it
19:02:45 <xcmw> Why does GHC say b is ambiguous? Is there a way to make it not ambiguous? http://lpaste.net/340302
19:03:07 <EvanR> add to what? Prelude? that would clobber existing use of ?
19:03:18 <winter> Data.Bool
19:03:30 <pacak> xcmw: forall in rr1 and rr2 does nothing
19:04:04 * hackagebot ekg-influxdb 0.1.0.0 - An EKG backend to send statistics to influxdb  https://hackage.haskell.org/package/ekg-influxdb-0.1.0.0 (angerman)
19:04:23 <Polymorphism> https://kstars.wordpress.com/2009/09/05/a-python-irc-bot-for-keeping-up-with-arxiv-or-any-rss-feed/ I just got this working and modified for my needs in less than 30 mins... the haskell bot was taking hours and made no sense. Honest question, why learn haskell next and not python?what will I gain or what will it be better for? I write mostly network and scientific applications
19:05:35 <pacak> Polymorphism: Haskell is different from most languages - it takes time to master it, but once you do - it's actually faster to write/modify  stuff in haskell.
19:06:34 <pacak> Polymorphism: strict typing and immutability makes it harder to write programs with bugs. Monads and other typeclasses allows to think about your programs and  write them in a way other than simply moving values around.
19:06:42 <EvanR> i dont find "xxx" ? "yyy" $ "zzz" very compelling 
19:07:26 <dolio> I'd rather have (?) = flip.
19:07:26 <Welkin> ew
19:07:30 <Welkin> looks like the ternary operator
19:07:36 <Welkin> that's the worst
19:07:42 <Welkin> I see people try to golf with that all the time in C
19:07:48 <Welkin> it just makes things impossible to read
19:08:02 <dolio> It's the only way to do branching expressions in C.
19:08:10 <erisco> Polymorphism, learn Python then. Haskell is going to take more time, particularly if you are used to non-functional languages
19:08:21 <dolio> Which is something languages should just have.
19:08:22 <Welkin> erisco: lol python?
19:08:39 <Welkin> if you want to learn a crappy scripting language, learn the least horrible one that has batteries: ruby
19:08:43 <Welkin> or if you like bare bones, lua
19:09:06 <erisco> lua? are you serious? that monstrosity they use for video game scripting?
19:09:13 <Welkin> lol erisco 
19:09:14 <Welkin> yes
19:09:15 <EvanR> multiline ? : stuff in C or whatever is hard for me to take seriously
19:09:20 <xcmw> pacak: Yes, but why is b ambiguous?
19:09:20 <Welkin> it is actually quite fun to use
19:09:30 <erisco> I am pcalling out of this one
19:09:55 <EvanR> try writing a significant amount of code in lua, its novelty will wear off
19:10:38 <Welkin> I started writing a functional utility library in lua
19:10:39 <dolio> The sad part is that Lua has better features than a lot of more popular, similar languages.
19:10:45 <dolio> Like proper tail calls.
19:10:49 <Welkin> I got fold, compose, curry, and some others working
19:10:56 <Welkin> yes, lua has tco
19:10:59 <Welkin> which is nice
19:11:30 <Lokathor> Polymorphism, which haskell bot?
19:11:48 <EvanR> proper tail calls but not proper composable list operations
19:11:51 <erisco> Polymorphism, Haskell lead me to insights about programming that no other language has. I'd learn it again for the knowledge
19:12:33 <EvanR> actually it doesnt have proper lists 
19:12:36 <EvanR> or arrays
19:12:38 <EvanR> like PHP
19:12:41 <Welkin> I haven't seen the 2009 Star Trek reboot in years and just decided to watch it again tonight, soon
19:12:48 <Welkin> EvanR: of course not
19:12:51 <Lokathor> erisco, care to list any of those specifically? I always have trouble articulating it when people ask me "what's special about haskell that I can't just do in another language?"
19:12:52 <Welkin> in lua all you need are tables
19:12:54 <Welkin> and it's true
19:13:12 <EvanR> i dont agree with putting them into the same data structure which is a broken form of both
19:13:39 <Welkin> Lokathor: well technically you can do anything in any language
19:13:42 <Welkin> if you really want to
19:13:45 <Lokathor> yeah yeah :P
19:13:48 <Welkin> disregarding the implementation
19:14:07 <Welkin> but you don't have to worry about runtime errors in haskell
19:14:09 <kadoban> Polymorphism: If you can write in another language in 30 minutes, can you see how that essentially means there's not a lot you even could be learning there? Then at that point, what are you actually gaining?
19:14:09 <Welkin> which is very nice
19:14:11 <EvanR> Lokathor: yes its kind of disheartening to demonstrate some whizbang type safe thing you can do in haskell and they just say "cant dynamic language X already do that"
19:14:13 <Welkin> except when in IO
19:14:21 <erisco> well that isn't really the right question. You can do a lot of functional things in other languages (I've done this). The difference is that other languages neither make it easy nor encourage it
19:14:32 <Welkin> yes
19:14:33 <EvanR> Welkin: runtime errors in haskell unfortunately do happen
19:14:39 <Welkin> most langugaes encourage mutation
19:14:46 <erisco> partly due to language design, partly due to community, partly due to libraries
19:14:46 <Welkin> haskell doesn't
19:14:51 <Polymorphism> good point
19:14:52 <lordcirth> lazy evaluation.  corecursion.  all fascinating
19:15:30 <erisco> so, tell them, you'll learn to write code that will make your coworkers' heads spin
19:15:40 <pacak> Polymorphism: algebraic datatypes are nice.
19:15:42 <kadoban> IMO the only languages worth learning just to gain insight are precisely the ones that don't come easy.
19:15:42 <lordcirth> a function, 'primes', in the standard libraries, returns the list of prime numbers
19:15:42 <Lokathor> EvanR, usually go-lang is the language in question :P
19:15:49 <Welkin> Polymorphism: I was using python before I jumped to haskell, and the difference I felt was huge
19:15:54 <EvanR> erisco: you can write head spinning code in any language heh
19:15:58 <Welkin> python is so broken, especially look back on it now
19:16:20 <Welkin> it's easy to get started, but you will find yourself in a tangled mess of broken apis and hundred-line tracebacks for runtime errors
19:16:24 <lordcirth> I think most languages end up broken by the time they hit stable release
19:16:35 <EvanR> Lokathor: except its totally missing the point since they are loosey goosey, they probably never even thought to do it in those languages
19:16:37 <lordcirth> Making a language is hard.
19:16:39 <kadoban> Practically, I'd also much much rather maintain a haskell codebase than a python one. The type system is so very useful for keeping things correct when changing parts, without having to re-understand every possible small part.
19:16:53 <erisco> tell them they'll be able to solve problems they can't and problems they can better
19:16:57 <lordcirth> Do you guys use 'forall' much?
19:16:57 <grantwu> I got bitten so hard after going back to Python after writing a ton of Haskell
19:17:07 <grantwu> I didn't realize generators were read once
19:17:11 <Welkin> grantwu: you can thank guido!
19:17:21 <Welkin> for all his stupid decisions
19:17:25 <Lokathor> EvanR, to pick a particular example: Today I was saying that STM is a breeze and that it'll basically never screw you up, never deadlock, etc. and they just said "you'll never deadlock in any modern language anyway"
19:17:33 <Welkin> luckily haskell doesn't have a BDFL to fuck it all up
19:17:49 <kadoban> Lokathor: Which languages are considered modern?
19:17:50 <erisco> to list of some mumbo jumbo like purity and laziness and so-forth isn't going to do much for people who don't already understand it
19:17:53 <Lokathor> and i didn't know how to respond to that, since it's pretty much a No True Scotsman
19:17:55 <EvanR> Lokathor: yes well, modern concurrenct is unfortunately "lots of mutexes" still
19:18:05 <kadoban> Lokathor: Ya, seems like it.
19:18:11 <Welkin> (also could be a problem with Elm)
19:18:14 <erisco> how can you live without polymorphic higher kinded types? well, most don't even know what that is
19:18:18 <Welkin> because one person controls the whole language
19:18:21 <Lokathor> kadoban, go-lang at least, possibly others
19:18:34 <EvanR> polymorphism is another one
19:18:50 <kadoban> I don't really know go-lang, probably mostly because the name annoys me.
19:18:55 <EvanR> look at how polymorphic this haskell code is, oh well cant dynamic language foo already just do that out of the box
19:19:06 <Welkin> kadoban: and because it was made by the same trolls from plan 9
19:19:16 <lordcirth> Yeah.  I learned polymorphism a little in OOP, and I thought it was kinda neat but hard.  Then I learned Haskell and said no, this is real polymorphism
19:19:49 <grantwu> I don't think Plan 9 was a troll
19:19:54 <erisco> Lokathor, I can try to explain the virtues of static typing until I am blue in the face and not convince someone who hasn't themselves spent the time to understand it
19:19:55 <EvanR> in some OOP systems they want you to use polymorphism to do the equivalent of a case analysis expression
19:20:05 <Lokathor> i read a few rust guides the other day. The level of IO/mutation that they encouraged you to just spread everywhere into the code made me cringe hard
19:20:13 <EvanR> replace the switch statement with a dynamic dispatch call to an agreed method
19:20:19 <Lokathor> it basically ended up feeling like a python program :/
19:20:32 <pacak> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
19:20:34 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
19:20:36 <pacak> Can python do that?
19:20:38 <EvanR> Lokathor: do they? references "are immutable" by default
19:20:46 <EvanR> (you cant mutate through them)
19:20:53 <grantwu> pacak: that's not really useful though
19:21:12 <Lokathor> EvanR, I'm not sure if all rust guides encourage mutation, but these two authors at least wrote their Rust like it was just Java or Python with funny syntax.
19:21:38 <erisco> Lokathor, if you show confidence and intelligence then it will attract the people who want some of that. You can't win over everyone though
19:21:42 <Lokathor> Rust might be too young to truely have a style of its own that isn't heavily affected by the language of the person coming to it
19:21:51 <EvanR> you might actually want mutation for the target applications of rust
19:21:54 <Welkin> Lokathor: oh yeah, I've seen direct translations of c++ into haskell
19:21:58 <Welkin> it was an abomination
19:21:58 <grantwu> It's a cool illustration of what you could do in Haskell, but I don't think it's a good demonstration of Haskell's utility
19:21:59 <EvanR> like filling in a buffer
19:22:03 <pacak> grantwu: Not by itself but it gets more useful when you combine it with open recursion for example.
19:22:49 <EvanR> Lokathor: the interesting part is the lack of GC, so you have to think about everything differently, maybe more primitively
19:22:55 <grantwu> What is the 'it' here
19:23:03 <erisco> there are people who have painted it as impractical academia and there aint a thing in the world you can do, other than hope someone they *do* listen to says something
19:23:10 <erisco> like when John Carmack lauded Haskell
19:23:23 <Welkin> lol
19:23:36 <Welkin> there are people who point to carmack as a reason they "don't like haskell"
19:23:36 <EvanR> carmack is haskells killer app
19:23:46 <Welkin> "oh, this celebrity said he didn't like it, so I don't either"
19:23:56 <Lokathor> i thought he did like it
19:23:59 <EvanR> no he does like it
19:24:02 <Welkin> he moved away from it
19:24:04 <Welkin> to racket
19:24:27 <Welkin> he likes the ideas in haskell
19:25:46 <surina> toDigitsRev (div (digits - mod digits 10) 10). Is it possible to use the $ here to avoid parantheses?
19:26:15 <Lokathor> once after toDigitsRev
19:26:27 <Lokathor> toDigitsRev $ div (digits - mod digits 10) 10
19:26:38 <EvanR> yeah but... i would just put the parens
19:26:54 <Welkin> toDigitsRev . div . (digits - mod digits 10) $ 10
19:26:56 <Welkin> lol
19:27:00 <kadoban> toDigitsRev $ (digits - digits `mod` 10) `div` 10
19:27:02 <Welkin> oh oops
19:27:04 <EvanR> that wont work
19:27:38 <kadoban> div and mod usually look better infix to me
19:27:51 <Welkin> I always use them infix
19:28:13 <Welkin> same with `elem` and `isPrefixOf`
19:28:23 <kadoban> Ya
19:28:35 <Welkin> that's something other languages lack that annoys me now
19:28:50 <Welkin> well, and of course partial application
19:29:21 <surina> none of those work :O
19:29:39 <surina> could I just post the whole function, 4 lines of code here?
19:29:40 <kadoban> surina: Then I suspect the original didn't either
19:29:47 <kadoban> surina: lpaste.net
19:30:13 <erisco> Lokathor, in other words, tell them they'll improve in whatever language they're currently using
19:30:36 <Lokathor> that is a difficult one
19:31:18 <Welkin> but once you use haskell, you never go back
19:31:27 <erisco> *shrug* if they think you're lying or that what you're saying isn't applicable to them then I can't see what else to do
19:31:32 <EvanR> edwardk did
19:31:40 <Welkin> EvanR: to what?
19:31:42 <EvanR> C++
19:31:43 <erisco> if they aren't going to listen to someone who's been on both sides of the fence then what else
19:32:01 <Welkin> EvanR: what do you mean?
19:32:19 <Welkin> he's on the committee
19:32:20 <EvanR> hes working on fancy 3d graphics in C++ now instead of haskell
19:32:27 <Welkin> well of course
19:32:30 <EvanR> he went back
19:32:36 <Welkin> haskell support for graphics sucks
19:32:43 <lpaste> surina pasted “toDigitsRev” at http://lpaste.net/340310
19:32:46 <EvanR> eh? not really
19:33:27 <surina> at least that one works fine
19:33:28 <kadoban> surina: Yeah, it ends up meaning something different there, since $ is very very low precedence.
19:33:44 <Welkin> $ can bite you
19:33:52 <Welkin> espeically when you are just getting used to it
19:33:57 <kadoban> surina: So it ends up meaning (mod digits 10 : toDigitsRev) (the other stuff), which doesn't make any sense.
19:34:05 <Welkin> but even when you have used it a lot, it can still mess you up
19:34:43 <kadoban> surina: So yeah, skip the $. Though I'd still recommend infix `div` and `mod`, not that it matters a lot.
19:34:54 <Welkin> a typical pattern is `f . g  . h $ 10`
19:35:02 <surina> oh I see it now
19:35:11 <Welkin> create a pipeline of composed functions and then apply is using $ to some parameter
19:35:31 <erisco> I think styles start out as  f (g (h x))  then go to  f . g . h $ x  then go back to  f (g (h x))   ... at least that is what I've done
19:35:46 <Welkin> f . g . h $ 10 is the same as (f . g . h) 10
19:36:02 <erisco> (f . g . h) 10  is also good
19:36:04 <kadoban> Mine are currently at h & g & f $ x, where & = flip (.)
19:36:08 <EvanR> i dont like f . g . h $ foo
19:36:09 <Lokathor> most common use for $ with me is liftIO $ thingy
19:36:11 <kadoban> Which is a poor name, but whatever.
19:36:29 <erisco> f $ g $ h $ x  makes me wince
19:36:31 <lordcirth> What I don't understand is why people call x . y . z 'pointfree' syntax, even though it has dots?
19:36:41 <erisco> lordcirth, lol :P
19:36:42 <EvanR> mixing & and $ when & "usually" means flip ($) is really confusing
19:36:44 <Lokathor> lordcirth, the points are the named inputs
19:37:00 <lordcirth> Lokathor, ?
19:37:02 <kadoban> EvanR: Heh, ya ... but I haven't thought of a better symbol to switch to yet. >>> is too long.
19:37:10 <erisco> that was a joke right?
19:37:11 <Welkin> kadoban: it's not!
19:37:12 <Welkin> o.o
19:37:20 <kadoban> And I think has the wrong precedence too, though I'm not sure.
19:37:25 <Welkin> >>> is easy to recognize
19:37:32 <Welkin> I know instantly what it means
19:37:42 <EvanR> kadoban: sometimes books just use . and its backwards as is
19:37:51 <MarcelineVQ> the subtracting seems out of place, you've alreaded modded digits are you sure you don't just want to div digits before recursing?
19:37:52 <EvanR> but i guess thatd be bad to do in haskell
19:37:56 <MarcelineVQ> > 12345`mod`10
19:37:58 <lambdabot>  5
19:37:59 <kadoban> EvanR: Ya :(
19:38:00 <MarcelineVQ> > 12345`div`10
19:38:02 <Lokathor> lordcirth, "points free" just means that there are no named input values in the funciton's definition.
19:38:02 <lambdabot>  1234
19:38:28 <lordcirth> Lokathor, how are values 'points' ?
19:38:30 <erisco> pointless/pointfree/tacit means there are no variables in the expression
19:38:48 <EvanR> lordcirth: parameters
19:38:51 <EvanR> not values
19:38:58 <kadoban> I think the name comes from some field of math. Is it topology or am I making that up?
19:38:59 <erisco> let x = 10 in x + x  is not pointfree, it isn't to do with inputs/arguments/parameters
19:39:00 <EvanR> @pl \x -> (x,x)
19:39:00 <lambdabot> join (,)
19:39:32 <erisco> join (+) 10   is the pointfree expression
19:39:35 <EvanR> @pl let x = 10 in x + x
19:39:36 <lambdabot> 20
19:39:48 <EvanR> it is pointfree!
19:39:48 <erisco> wow @pl is much smarter than I thought :P
19:40:04 <lordcirth> what's @pl do?
19:40:10 <EvanR> pointless form
19:40:25 <lordcirth> it converts to pointless?
19:40:31 <Lokathor> er, yeah, paramaters is the correct term, sorry
19:40:36 <lordcirth> and it just optimized it to 20, lol
19:40:54 <EvanR> you use it on an expression with parameters, let is a weird side case
19:40:57 <Welkin> cool
19:41:06 <Welkin> let's use @pl from now on as a calculator
19:41:14 <Welkin> @pl 4 + 5
19:41:14 <lambdabot> 9
19:41:15 <erisco> @pl let x = y in x + x
19:41:16 <lambdabot> y + y
19:41:16 <Welkin> :D
19:41:26 <erisco> I don't think it understands
19:41:32 <erisco> @pl \y -> let x = y in x + x
19:41:32 <lambdabot> join (+)
19:41:35 <erisco> there we go
19:41:35 <Welkin> @pl let a = a in a
19:41:35 <lambdabot> fix id
19:41:38 <Welkin> lol!
19:41:49 <erisco> it does understand, just have to indicate y is a variable
19:41:50 <kadoban> Haha
19:42:15 <lordcirth> Oh right, I had a lens question.  I want to fmap over _tiles with a lens.  Is 'traversed' what I'm looking for?
19:43:25 <lordcirth> like, a clean way to reach inside a nested structure, fmap a (Tile -> Tile) function over something, and return the whole structure again
19:43:48 <kadoban> There's really no short operators left to use instead of >>> :-/
19:44:10 <Lokathor> kadoban, make some up :P
19:44:28 <kadoban> Lokathor: Like what though, that's the thing?
19:44:36 <Lokathor> what operation do you want to do?
19:44:48 <kadoban> Lokathor: Something for flip (.)
19:45:11 <kadoban> aka (>>>) (in the (->) instance)
19:45:15 <Welkin> you can use Chinese
19:45:26 <Welkin> use 好
19:45:49 <kadoban> I did consider using some unicode nonsense, but ... that doesn't look so good in my monospace font, and it's annoying to type for other people.
19:45:55 <Welkin> lol
19:45:59 <Welkin> it's fun as a joke
19:46:05 <Lokathor> tough one
19:46:13 <Welkin> like creating a DSL that looks like normal chinese text
19:46:20 <kadoban> Heh
19:46:36 <EvanR> kadoban: i am using >>> 
19:46:42 <Lokathor> flip (.) feels like maybe it should be (*<)
19:46:46 <Koterpillar> Welkin: Lingua::Sinica::PerlYuYan
19:46:53 <EvanR> but agreed its overlong
19:47:22 <Welkin> Koterpillar: oh my god
19:47:23 <Welkin> https://github.com/audreyt/lingua-sinica-perlyuyan
19:47:24 <kadoban> Would .. work, or is that reserved for [a .. b]?
19:47:29 <Welkin> Koterpillar++
19:47:29 <EvanR> flip (.) should really be just . and somehow the system needs to know which way you wanted it by context
19:47:50 <EvanR> its totally symmetric / arbitrary
19:47:53 <kadoban> IMO it should just be (.) to start with and current (.) can go jump off something, but *sigh*
19:48:23 <Welkin> @karma Koterpillar 
19:48:24 <lambdabot> Koterpillar has a karma of 1
19:48:26 <Welkin> Koterpillar++
19:48:27 <Welkin> @karma Koterpillar 
19:48:27 <lambdabot> Koterpillar has a karma of 2
19:48:32 <Welkin> okay, still works
19:49:10 <Koterpillar> O_o
19:49:21 <EvanR> you would have to do `好` because its not an operator
19:49:24 <erisco> how would that work when you got the endo?
19:50:13 <EvanR> the context would have to include more than the types 
19:50:31 <erisco> it is right to left, live with it!
19:50:34 <EvanR> actually lets just go back to regular . and stop trying to do it backwards
19:50:43 <Welkin> lol
19:53:31 <erisco> \x -> g (f x) ≡ g . f    you're asking to reverse it
19:54:01 <EvanR> yes the backwardsness of . is rooted in the prefix function application, blame that
19:54:35 <erisco> do you scroll the mouse wheel up or down to advance a web page?
19:54:53 <kadoban> erisco: clockwise
19:54:56 <EvanR> its backwards on my computer from everyone elses, i know that, but i dont know why
19:55:29 <erisco> kadoban in what direction is your normal?
19:55:49 <EvanR> do you push forward or pull backward to make the plane do a nosedive
19:55:50 <lordcirth> Anyone have a recommendation for the best Lens tutorial for beginners?
19:55:54 <Lokathor> on my mouse, my finger tip moves up to make the window go towards earier text, and down to make the window go towards later text
19:56:01 <kadoban> erisco: Away? I'm not really sure which means which in terms of clockwise/widdershins.
19:56:47 <erisco> I am not sure how you determined clockwise either
19:57:15 <kadoban> By looking at it and imagining it was a clock
19:57:24 <erisco> are you right-handed?
19:57:39 <kadoban> Yes, though I use my left for mouse.
19:57:39 <EvanR> right hand rule
19:58:15 <erisco> kadoban, then you use the mousewheel backwards too
19:59:01 <kadoban> You're likely imagining my mouse different than it is; it's a trackball thing.
19:59:25 <erisco> unlikely
19:59:59 <erisco> you're pushing the page
20:00:00 <kadoban> If you say so
20:00:20 <EvanR> toiletpaper roll mounted toward or away from user
20:00:28 <erisco> I am pushing the viewport/scrollbar
20:00:40 <MarcelineVQ> EvanR: dangle toward or away?
20:00:55 <EvanR> right
20:00:57 <MarcelineVQ> toward unless you have a dumb cat
20:01:07 <erisco> moving the scrollbar down causes the page to go up
20:01:19 <erisco> so it is just a question of how you think about it :)
20:01:45 <EvanR> thats why the mac has up/down as a setting now and its not picking favorites
20:01:56 <EvanR> and its frustrating going to the other way
20:02:29 <Koterpillar> half my coworkers switched; one more obstacle for pair programming
20:02:41 <kadoban> Switched to what?
20:02:53 <Koterpillar> to the other scroll direction
20:03:01 <erisco> EvanR, and obviously you mouse up to make the plane dive ;)
20:03:20 <kadoban> I didn't even know that people changed scroll directions, never bothered configuring it myself.
20:03:34 <EvanR> i think its backwards by default now on osx
20:03:36 <Koterpillar> I think the default on that OS has changed
20:03:50 <EvanR> scroll down causes the page to go down
20:05:06 <erisco> that is what I am used to and is the default on Windows
20:05:32 <EvanR> gross
20:05:33 <erisco> touch devices go with the other way
20:05:35 <Lokathor> yeah, scroll down makes the page go down is what windows does
20:05:43 <MarcelineVQ> pulling with your finger should move the page in the direction of reading because it's easier on your hand over a duration
20:05:48 <EvanR> no its equal to the touch screen way
20:06:03 <erisco> what? oO what touch device is this
20:06:17 <EvanR> scroll down, page goes down, window goes up
20:06:34 <EvanR> all of them
20:07:33 <erisco> no, my windows phone doesn't even do that
20:07:41 <erisco> it moves such that what you place your finger on remains under your finger
20:07:49 <EvanR> thats what i said
20:07:56 <erisco> which means scrolling up makes the page go down
20:08:05 <EvanR> page vs window
20:08:11 <erisco> er, I can see how we're mangling words here
20:08:13 <MarcelineVQ> oooh you're using a different co-ordinate system
20:08:37 <erisco> right, scrolling up makes the window go down
20:09:04 <EvanR> in the end nothing is going anywhere! we like fantasy
20:09:09 <MarcelineVQ> the most amazing topic
20:09:24 <erisco> really it is disappearing and reappearing in a new location
20:09:32 <erisco> let me tell you how animation works
20:09:33 <MarcelineVQ> making a living doing UI's must be a short life for many people
20:23:18 <ab9rf> i hate making UIs
20:24:50 <wespiser> I'm using the "ReaderT (Map Text Value) (ExceptT ErrorType IO) Value" for a programming language. Is this still considered the anti-pattern?
20:25:13 <wespiser> https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices
20:26:01 <wespiser> does anyone have an example of what a better solution would look like? thanks?
20:26:47 <EvanR> a similar route is the free monad transformer
20:27:24 <EvanR> you can also make your own monad from scratch
20:27:39 <wespiser> EvanR: thanks, this is designed to be for a tutorial, write you a scheme, version 2
20:27:49 <EvanR> hrm
20:27:58 <wespiser> I'm aiming for the minimal industrial solution
20:27:58 <EvanR> i dont like the sound of this for a scheme
20:28:05 <wespiser> oh rly
20:28:18 <wespiser> wanna see?
20:28:34 <Axman6> ... am I missing something> ParsecT implements MonadState... but not for its own state parameter. this makes using it in libraries like Ed's parsers pretty hard...
20:28:55 <wespiser> EvanR: https://github.com/write-you-a-scheme-v2/scheme/blob/master/src/Eval.hs#L95
20:29:50 <wespiser> its brutally simple, I'm releasing the first 6 or 7 chapters in the next week, and starting to freak out about some of the design decisions I've made!
20:30:00 <EvanR> instead of a transformer stack on top of IO, you could create a dialog-like monad which evaluates enuogh until it needs you to answer an IO request
20:30:31 <EvanR> Eval literally causing side effects by the action of evaluation is not as flexibl
20:30:49 <EvanR> also the environment youre in can be mutated in scheme
20:31:06 <EvanR> which ReaderT (Map doesnt allow
20:31:18 <wespiser> EvanR: no set!
20:31:32 <EvanR> also for environments, i would just pass teh env in to the recursive eval function
20:32:19 <wespiser> I'm trying to teach monad transformers
20:33:13 <EvanR> a good usecase for this would be an application monad which contains support functions that the app code would use, but the internal implementation would be transformers
20:33:41 <wespiser> yea, it's similar to an App monad i've seen before
20:33:50 <EvanR> or something else if you decide to change it later, such as a free monad, custom monad, nothing at all, or the free-monad-like thing that Cale has mentioned
20:33:50 <bollu> what's the application monad?
20:33:53 <bollu> I haven't seem this?
20:34:15 <EvanR> its a monad which spans your entire app and has specialized actions that your app can do
20:34:31 <EvanR> which are more inspiring than get, put, ask, tel
20:34:40 <bollu> EvanR: so it like a free monad that's specialised for your app?
20:34:46 <bollu> or like, "operation" based?
20:34:48 <EvanR> not really
20:34:51 <wespiser> its close the the Servant mtl stack
20:35:12 <EvanR> its the opposite of a free monad
20:36:35 <EvanR> a specialized monad
20:37:34 <pikajude> expensive monad
20:37:44 <Clint> *rimshot*
20:39:55 <bollu> EvanR: how do you know the laws will work out?
20:40:08 <bollu> EvanR: the point of a free monad (correct me if I'm wrong) is that the laws work "for free"
20:40:13 <bollu> ditto with operational and all
20:40:21 <wespiser> if it compiles, it type checks
20:40:34 <bollu> wespiser: that doesn't mean it's lawful
20:40:41 <bollu> instance fmap [] where fmap f xs = []
20:40:48 <bollu> ^ that typechecks
20:40:51 <bollu> doesn't mean its lawful..
20:40:59 <wespiser> what do you mean, lawful, then?
20:41:12 <wespiser> i just go by what typechecks, and focus on the software engineering aspects of Haskell
20:41:21 <pikajude> logic errors also typecheck
20:41:26 <bollu> wespiser: follows the monad laws: https://wiki.haskell.org/Monad_laws
20:41:27 <pikajude> lawful is "does it abide by the laws" which it doesn't
20:41:30 <erisco> fmap id = id  and  fmap (f . g) = fmap f . fmap g
20:41:34 <EvanR> bollu: when its a combination of features that you know would have worked with transformers, then its right
20:41:52 <EvanR> if its something weird, then you have to think about it
20:42:11 <EvanR> monad laws arent that hard to follow, but you also might want to think about other laws 
20:42:14 <erisco> fmap f xs = []  fails the first law
20:42:26 <pikajude> "when foo bar" and "unless foo bar" both typecheck given appropriate definitions of foo and bar, but you wouldn't want to mix them up
20:42:33 <EvanR> like, if you have a state-modifying operations, you want those operations to follow sane state laws
20:42:52 <bollu> EvanR: hm, I suppose. I don't know, I'm not comfortable with the idea of "winging the laws" though :)
20:43:09 <EvanR> thats haskell for you
20:43:34 <EvanR> im more interested in convenience and ease of implementation
20:44:06 <bollu> hm, I've been playing around with free monads (was using operational). I like the idea
20:44:16 <EvanR> verifying that the monad laws hold is something you can do without typing any code
20:44:36 <EvanR> and further laws are similarly all in your head, its up to you
20:45:38 <wespiser> I have to agree with EvanR, for the most part, the laws will hold, and you will get a very good feel for when they do not hold.  The corner cases do exist, however.
20:46:28 <erisco> implement Monad for Tree and see if you get it right
20:47:54 <bollu> is there a nice way to write the Applicative laws?
20:48:13 <erisco> I do not have them committed to memory
20:48:35 <bollu> ^ neither do I, which is why I wanted a nice formulation of them
20:48:47 <bollu> I show the monad laws using (>=>) since it makes sooo much more sense
20:49:14 <erisco> the ones I have seen seem gnarly
21:01:48 <erisco> glguy, did you resolve the synonym partial application mystery?
21:04:16 <erisco> is there a flip of subtract or are we to use sections?
21:08:40 <tzh> is there a haskell implementation of Fortune's algorithm / voronoi cell calculation anywhere?
21:10:54 <jmcarthur> erisco: Isn't (-) the flip of subtract?
21:11:45 <erisco> oh, that was unexpected
21:11:52 <erisco> > 2 `subtract` 1
21:11:54 <lambdabot>  -1
21:11:55 <erisco> uh huh...
21:12:21 <MarcelineVQ> 'subtract x from y' I guess
21:12:44 <erisco> where's -XMixfix
21:13:05 <benzrf> i wish
21:16:57 <haskell564> Hi, let's say I have a monad transformer stack like "ExceptT err (State st) a", is it possible to call evalState before runExceptT, to get my result?
21:18:09 <Axman6> I think you might be looking for natural transmormations, the mmorph package offers that
21:20:26 <Axman6> it gives you functions with types like: (forall a. m a -> n a) -> ExceptT e m a -> ExceptT e n a. using Identity for n, you just need to provide a function of type (forall a. State s a -> Identity a) which can be done using (identity . flip evalState initialState)
21:20:26 <haskell564> thanks Axman6. I'm wondering, is my situation a code smell?
21:20:29 <stobix> Is there any way I can use → instead of -> in my code?
21:21:04 <Axman6> stobix: yes, you can use UnicodeSyntax, but please don't :P I use a font called Fira Code which provides ligatures for things like that, but don't 'infect' the actual source file
21:21:08 <johnw> stobix: https://wiki.haskell.org/Unicode-symbols
21:21:35 <stobix> Ah, nice. Thank you both. :)
21:21:44 <stobix> Axman6: no worries. Mostly doing it for fun.
21:22:10 <Axman6> stobix: https://github.com/tonsky/FiraCode
21:22:25 <MarcelineVQ> do you want to actually use → or just see → when -> is in the code?
21:27:12 <MarcelineVQ> if you want to see your code with fancy symbols but be able to write them in the common way so it's not weird for other people you can use something like https://github.com/i-tu/Hasklig
21:29:48 <Axman6> right, Fira Code includes most of the ligatures that Hasklig does, but also has them for other languages' common operators etc.
21:30:20 <MarcelineVQ> ah I ​hadn't checked your link
21:34:09 * hackagebot Gifcurry 2.1.0.0 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-2.1.0.0 (lettier)
21:36:49 * stobix likes the idea with using a "ligaturing" font, and puts it on his todo pile
21:46:29 <stobix> I guess no font has been crazy enough to replace "forall" with "∀"… :)
21:50:15 <Axman6> yeah I hope not... particularly not in a fixed width font =)
21:50:20 <Axman6> \-------/
21:53:20 <stobix> Well, it wouldn't be a problem if it's done on font level. Unless of course the font rendering engine is crap. Which sadly happens way too often.
21:54:09 * stobix had a crazy alphabet he made a font of once. Turns out, only firefox had a font rendering engine following the standard enough to actually be able to render it correctly.
21:54:43 <Axman6> well, the problem is that you want the ligature to be as wide as the characters it replaces when using a fixed width font, so alignment is messed up
21:55:19 <Axman6> I'd be exrtremely surprised if OS X didn't handle it properly, its font support is amazing
21:57:05 <stobix> Why would I want the ligature to be as wide as the characters it replaces?
21:57:55 <stobix> Yeah, IIRC, some mac stuff handled it correctly as well. At least in theory; I have no access to macintosh systems.
22:09:38 <ania123> *Main> 1:4:[1] [1,4,1]
22:09:43 <ania123> *Main> 1:4:[1] 
22:09:49 <ania123> [1,4,1]
22:10:11 <ania123>  1:4:[1]:[3]  <interactive>:44:1: error:     • Non type-variable argument in the constraint: Num [t]       (Use FlexibleContexts to permit this)     • When checking the inferred type         it :: forall t. (Num [t], Num t) => [[t]]
22:10:14 <ania123> why?
22:10:31 <Axman6> :t (:)
22:10:33 <lambdabot> a -> [a] -> [a]
22:10:46 <Axman6> :t [1]:[2]
22:10:47 <ania123> Axman6
22:10:48 <lambdabot> (Num [t], Num t) => [[t]]
22:10:55 <ania123> how then this function works
22:10:57 <ania123> inter :: a -> [a] -> [[a]] inter x [] = [[x]] inter x (y:ys) = (x:y:ys): map(y:) (inter x ys)
22:10:58 <ania123> ?
22:11:06 <erisco> 1:4:[1]:[3]  is  1:(4:((1:[]):(3:[]))
22:11:08 <ezyang> ania123: It's returning a list of lists 
22:11:25 <ania123> ah
22:11:37 <ania123> yes but
22:11:40 <Axman6> look at the type of (:), it says it takes an a and a list of a, but you're giving it a list of a and a list of a
22:11:45 <ania123>  (x:y:ys): map(y:) (inter x ys) [10:10] <ania123> ?
22:11:54 <ania123> this construction
22:12:04 <ania123> (x:y:ys) is a list
22:12:11 <ania123> (x:y:ys) : list
22:12:12 <Axman6> yes
22:12:13 <erisco> [10:10] is (10:10):[]
22:12:30 <ania123> assume
22:12:32 <ania123> x=1
22:12:36 <ania123> y=2
22:12:47 <ania123> ys=[3,4]
22:13:00 <Axman6> ania123: please stop hitting enter after every work, it's very annoying. ask full questions
22:13:05 <ania123>  map(y:) (inter x ys) is [4,5]
22:13:05 <Axman6> word*
22:13:15 <ania123> ok
22:13:23 <erisco> x:(y:ys)  [3,4] is 3:(4:[])  therefore  1:(2:(3:(4:[])))
22:14:09 <ania123> erisco: that is clear, 
22:14:35 <ania123> (x:y:ys) : list  this is not clear
22:14:47 <erisco> what is list?
22:14:51 <ania123> how list is joined to (x:y:ys)
22:14:55 <Axman6> so "list" there is a list of lists
22:14:58 <ania123> list is some list
22:15:15 <ania123> s it is here: inter x (y:ys) = (x:y:ys): map(y:) (inter x ys)
22:15:20 <Axman6> > [1,2,3] : [[4,5,6],[7,8,9]]
22:15:23 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
22:15:27 <erisco> okay, what is not clear? [[1]] is (1:[]):[]  are you alright with that?
22:15:54 <stobix> ania123: x:y:ys is the same as x:(y:ys), not as (x:y):ys
22:15:55 <ania123> ah
22:15:59 <ania123> now clear, thx
22:16:34 <erisco> : is right-associative. You can check this in ghci with the :i command
22:33:46 <Axman6> @hoogle f a -> f ()
22:33:48 <lambdabot> Control.Monad.Extra unit :: m () -> m ()
22:33:49 <lambdabot> Extra unit :: m () -> m ()
22:33:49 <lambdabot> Development.Shake unit :: m () -> m ()
22:33:56 <Axman6> @more
22:34:04 <Axman6> :(
22:34:08 <jle`> :t void
22:34:09 <lambdabot> Functor f => f a -> f ()
22:34:19 <Axman6> yeah, was trying to find where it's from
22:34:40 <jle`> lambdabot might use the haskell.org/hoogle, which is kind of broken forever
22:34:59 <MarcelineVQ> it's at least in Control.Monad
22:35:19 <Axman6> yeah I wondered if it was defined in something like Data.Functor, but seems that's it
22:35:19 <MarcelineVQ> Data.Functor too which makes sense
22:35:37 <jle`> it used to be in Control.Monad because it used to be defined for Monad m
22:35:58 <Mibaz> I saw in a github project someone had a file called 'types' where he declared all his types and typeclass instances. Is this good practice?
22:36:07 <jle`> it's common practice
22:36:13 <jle`> it's mostly to prevent cyclic imports
22:36:19 <jle`> and it should probably be a module
22:36:43 <Mibaz> jle`: I think you're correct on the module.
22:36:53 <jle`> usually they also re-export all the types so the user doesn't directly import Types most of the time
22:40:38 <Mibaz> jle`: Thank you
22:41:27 <jle`> sometimes they call it Core
22:41:37 <jle`> but yeah, the main motivation is to prevent cyclic imports i think
22:42:37 <Mibaz> Another, unrelated question: What are the principle reasons for creating a type? When do you think 'Yes I need another type'? Sorry if that's vague.
22:43:54 <Axman6> when you have a new concept you need to model
22:44:20 <jle`> Mibaz: a lot of times, your ideas start from types
22:44:47 <Mibaz> Yeah, so I guess the question becomes: Do you start with types or with something else?
22:44:56 <jle`> you start with types and go, "do i need another function?"
22:45:32 <Mibaz> jle`: haha excellent
22:47:39 <Mibaz> How do you guys make main loops, generally?
22:49:21 <jle`> usually you try to abstract over them if you can
22:49:31 <jle`> don't write loops directly
22:49:45 <bollu> Mibaz: you may enjoy Control.Monad.Loops :)
22:50:42 <Axman6> Mibaz: what sort of main loop do yo have?
22:50:44 <Axman6> you*
22:50:58 <Axman6> often you can get by with forever
22:50:59 <Axman6> :t forever
22:51:01 <lambdabot> Applicative f => f a -> f b
22:51:09 <Axman6> @src forever
22:51:09 <lambdabot> forever a = let a' = a >> a' in a'
22:51:11 <jle`> :t interact
22:51:13 <lambdabot> (String -> String) -> IO ()
22:51:20 <Mibaz> bollu: Would Control.Monad.Loop be preferable to recursion?
22:51:34 <jle`> explicit recursion should always be a last resort
22:51:49 <Mibaz> Axman6: I was trying to make a little physics simulation, so I did a recursive main loop.
22:51:59 <bollu> Mibaz: ^ as jle` said, abstracting out recursion is always "cleaner" IMO
22:52:01 <jle`> recusion in haskell is like goto in imperative languages
22:52:36 <Mibaz> Axman6: Actually, I had an effectual function and a pure function that were mutually recursive (if you will). I thought it was cool, at the very least ;)
22:52:42 <bollu> Mibaz: same reason we use map, filter, fold, etc. it lets you think about what's going on as a "process" I guess, rather than following the recursive structure
22:53:09 <jle`> yeah, thinking about denonative semantics is nicer, but one of the big reasons to avoid recusion is that it's super easy to write bugs
22:53:15 <bollu> vague question: is there a proof that every recursive structure can be "packaged up"? I think you can appeal to Y and say "yes", but it seems like cheating
22:53:19 <jle`> and write yourself into complex spaghetti code
22:53:31 <Mibaz> jle`: Ok, I've been seeing that more and more. It's definitely hard to read.
22:53:40 <jle`> yeah, you can abstract over common patterns
22:53:56 <jle`> and you write once and don't leave yourself vulnerable to bugs
22:54:21 <jle`> the problems are pretty much the same as GOTO in imperative languages
22:54:44 <jle`> quickly leads to spaghetti code that's unmaintainable, and obscures meaning
22:55:10 <Mibaz> So will I generally never have to use explicit recursion? Has there ever been an actual need with you guys?
22:55:18 <Mibaz> In reality, that is.
22:55:30 <jle`> you will have to use explicit recusion in reality
22:55:40 <jle`> it's not avoidable in every case
22:56:02 <jle`> but it should be a last resuort :)
22:56:14 <jle`> especially in a language like Haskell with no termination checking
22:56:25 <bollu> jle`: can't you (always) use some ungodly combinator from recursion-schemes? 
22:56:35 <Mibaz> jle`: got it, thank you. 
22:56:43 <jle`> i don't think it's always possible
22:56:56 <Axman6> explicit recursion is always avoidable, but you do it by using fix, and it looks basically exactly the same
22:57:03 <jle`> but also, sometimes you'll write combinators/higher-order-functions/abstractions using explicit recusion
22:57:13 <jle`> it helps to isolate the bug-prone areas to one place
22:57:32 <Axman6> fun ... = ... fun ... => fix (\fun ... -> ... fun ...)
22:57:58 <jle`> knowing when to pull out something for an abstraction is also a trade-off, too
22:58:10 <jle`> it's tempting to abstract over every little thing
22:58:34 <mmachenry> jle`: Mibaz : I think it's worth pointing out that though I agree with the explicit recursion is the GOTO of FP stance, you must put it into perspective. We're holding FP to a higher standard when we say that. It's not nearly as harmful as GOTO. It's just the next thing that we'd like to push out of normal usage on our journey to the most readable code.
22:59:44 <Mibaz> jle`: I've definitely been stuck in that cycle before; building for a level of scalability that is just unnecessary for the project. 
23:00:47 <jle`> another reason why you'd use a function like 'map' instead of explicit recursion is because everyone knows what 'map' is, and what it does
23:00:57 <Mibaz> mmachenry: That definitely numbs the shame ;) thank you.
23:01:12 <mmachenry> :)
23:01:20 <jle`> if someone saw an explicit-recursion implementation of map f, they wouldn't be able to immediately recognize what it does in the same way was just reading 'map f'
23:01:27 <jle`> so that's a thing about combinators, too
23:01:36 <mmachenry> I'm all about numbing your shame. Go ahead and have that cookie, btw, you worked out today. It's okay.
23:01:50 <jle`> if you have too many random combinators then they become harder to use because they are too unrecognizable
23:01:52 <jle`> so, tradeoffs :)
23:03:17 <Mibaz> mmachenry: You sound like I sounded 15 minutes ago when I decided to get on IRC instead of getting a jump on tomorrow's assignments.
23:03:48 <haskell564> How to add information to every constructor in a datatype? http://lpaste.net/340384
23:04:07 <Mibaz> jle`: I actually don't know anything about combinators in this context. I'll take your word for it and do some research, though.
23:04:19 <jle`> haskell564: you can just do (Foo, Bar)
23:05:07 <jle`> Mibaz: i'm using 'combinators' in the super informal sense of 'higher-order function', heh
23:05:12 <mmachenry> Mibaz: Careful to not that the Haskell community has somewhat reinvented the word combinator to just mean function. It's not the formal meaning of the word. I honestly don't know what we don't just called them functions.
23:05:20 <mmachenry> Yes, like jle` said
23:05:30 <gfixler> ¿Qué es esto? "‘<>’ is not a (visible) method of class ‘Monoid’"
23:05:39 <stobix> Sometimes, I wish people would just write straight code instead of making me read heaps of doctorate level papers to understand what they're trying to do.
23:05:40 <mmachenry> Just don't go to wikipedia and lookup combinator and expect that to mean what it means to a Haskeller. 
23:05:43 <jle`> gfixler: try 'mappend'
23:05:51 <jle`> (<>) might juts be an alias
23:05:56 <gfixler> oh
23:06:01 <haskell564> jle` Foo is recursive, so I'll lose information if I just use (Foo, Bar)
23:06:04 <jle`> (<>) is also in the Semigroups typeclass
23:06:05 <gfixler> yeah, I used mappend, but wondered why <> failed
23:06:23 <Mibaz> jle`: mmachenry: heh, good to know. The wikipedia article, which I've been on before, is definitely no help.
23:06:26 <jle`> gfixler: you should be able to use both ... maybe with an import
23:06:35 <jle`> gfixler: but that's not the error message you'd get if you tried to use (<>)
23:06:43 <gfixler> I can use both, just not in the class instance
23:06:47 <jle`> gfixler: that's the error method you'd get if you tried to, say, define (<>) for a Monoid instance
23:06:50 <Mibaz> mmachenry: 'functions' sounds way less haskelly.
23:06:59 <gfixler> jle`: ah, I think I see now
23:07:04 <gfixler> <> isn't the real deal
23:07:08 <gfixler> so I can't define its impl
23:07:16 <gfixler> that clears that up
23:07:32 <Axman6> @hoogle Applicative f => Int -> f a -> f [a]
23:07:32 <lambdabot> Control.Monad replicateM :: (Applicative m) => Int -> m a -> m [a]
23:07:33 <lambdabot> Text.Parser.Combinators count :: Applicative m => Int -> m a -> m [a]
23:07:33 <lambdabot> Text.Megaparsec count :: Applicative m => Int -> m a -> m [a]
23:14:50 <stobix> Has anyone used ArrowLoop for something useful? I can't think of how I would even use it to begin with.
23:15:25 <jle`> it's useful for recursive bindings in proc-do notation
23:15:56 <jle`> pretty much the only time it's useful is for proc-do notation
23:16:47 <stobix> hehe
23:16:54 <phadej> it's as useful as MonadFix
23:16:58 <stobix> So, basically, it's good when not used directly
23:18:37 <phadej> occassionally you need MonadFix, and not opaque recursion
23:18:40 <stobix> I guess it's kinda like with the reverse state monad: You have to be really careful not to end up in an infinite loop somewhere.
23:19:09 <Axman6> I think generally people have moved on from Arrows, there are better and less confusing alternatives now
23:19:29 <stobix> I guess. I just finally managed to get them. Guess I'll have to do lenses next.
23:19:49 <Axman6> one of the database libraries looks really interesting, but I can't make any sense of how to use it because of its use of arrows
23:20:04 <phadej> profunctors + category ~ arrows
23:20:06 <Axman6> lenses are infinitely more interesting
23:20:10 <Axman6> yeah
23:20:17 <stobix> Right now, I think I understand arrows better than monads. (Probably this means that I still understand neither.)
23:20:44 <Axman6> lens relies strongly on profunctor and category, so this is good timing for you :P
23:20:46 <stobix> profunctors‽ What are those?
23:21:11 <phadej> generalisation of '->' (like an arrow ;))
23:21:45 <stobix> That sure made me understand them. ;p
23:21:49 <Axman6> things which you can write: dimap :: (b -> a) -> (c -> d) -> p a c -> p b d for
23:22:12 <Axman6> so, replace p with (->) and you have composing functions before and after a function
23:22:45 <Axman6> but it's also things like Kliesli, so all monads are profunctors (my language is probably a bit imprecise there...)
23:23:28 <stobix> Well, it's hell of a lot less confusing to have a 'p' abstraction than an 'a' abstraction, I can give you that. 
23:23:40 <stobix> So, is it like arrows, but freeer somehow?
23:23:57 <stobix> s/freeer/more lax/
23:24:02 <Axman6> what do you mean by freer?
23:24:09 <Axman6> right
23:24:12 <stobix> :)
23:24:37 <Axman6> with if you have Category, you get composition of thinge: (.) :: p b c -> p a b -> p a c
23:24:58 <Axman6> which gives you everything Arrow does
23:25:19 <stobix> Well, yes, but how are they not like arrows?
23:25:34 <phadej> they aren't category
23:25:45 <stobix> Oh‽ No (>>>)?
23:26:10 <phadej> no
23:26:20 <stobix> Oh...
23:26:31 <Axman6> (>>>) is equivalent to flip (.) (from Category)
23:26:57 <phadej> yes
23:27:04 <stobix> Well...
23:27:07 <Axman6> Profunctor gives you mapping over one contravariant and one covariant parameter, Category gives you composition
23:27:11 <phadej> every arrow is profunctor, but not every profunctor is an arrow
23:27:11 <stobix> "Oh‽ no (.)?" :)
23:27:33 <stobix> Gotcha
23:27:54 <stobix> So, profunctor could be seen as a superclass of category?
23:27:59 <Axman6> it kind of splits Arrow in two
23:28:06 <Axman6> no
23:28:18 <Axman6> they're orthogonal.. I think
23:28:22 <phadej> they are
23:28:25 <jle`> for the most part, the things that people invented Arrow for and hoped that Arrow would help with are now instead done with Applicative instead
23:28:37 <Axman6> not all things which are Category are Profunctor and vice versa
23:28:38 <jle`> er, a little bit of a late comment
23:28:55 <jle`> Applicative is fairly recent as far as haskell abstractions go
23:29:08 <jle`> when they came to the scene, they changed everyting
23:29:13 * hackagebot persistent-parser 0.1.0.2 - Parse persistent model files  https://hackage.haskell.org/package/persistent-parser-0.1.0.2 (mchaver)
23:29:22 <stobix> jle`: Huh? So having "parallel" flows of data can be done with Applicative?
23:29:34 <phadej> yes
23:29:36 <jle`> one of their accomplishments was relegating Arrow to little more than a footnote
23:29:44 <stobix> ...oh
23:30:02 <jle`> i say little more, because there are some niche situations where Arrow is still more useful
23:30:05 * stobix basically saw Applicative as a neccessary evil to get a Monad
23:30:27 <jle`> oh, no
23:30:31 <jle`> Applicative changed everything
23:30:37 <Axman6> Applicatives are far from evil
23:30:46 <jle`> applicative changed the world
23:30:47 <Axman6> they're the bee's nees
23:30:49 <Axman6> knees*
23:30:57 <jle`> Applicative makes Monad seem like a necessary evil, heh
23:31:03 <Axman6> agreed
23:31:14 <jle`> monad is applicative's ugly older sibling
23:31:20 <jle`> no offense to monad
23:31:20 <Axman6> many many "monadic" functions really only need Applicative
23:31:33 <stobix> huh
23:32:02 <Mibaz> I didn't know applicatives were so popular.
23:32:07 <Axman6> go and watch a video about Facebook's Haxl library to find out why Applicative is so awesome (or at least, one of the reasons)
23:32:30 <stobix> Hm. So, (>>=) + some constraints is what separates Monads from Applicatives, right?
23:32:33 <jle`> well, Applicative as an abstraction gives you so much power in reasoning and and refactoring etc.
23:32:44 <grayhatter> can anyone tell me why these two lines are throwing compile errors Expected String ;; Actual [String] https://github.com/GrayHatter/devbot/blob/master/devbot.hs#L150-L151
23:33:27 <Mibaz> I've asked before but I thought there might be some other people/suggestions now. I have a functional independent study next semester. I get to design the course/project/whatever. Any suggestions or input?
23:33:49 <stobix> I guess I'd better find that video.
23:34:11 <grayhatter> Mibaz what level?
23:34:13 * hackagebot from-sum 0.2.1.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.2.1.0 (cdepillabout)
23:34:23 <jle`> stobix: the practical difference in Haskell is that if you have a function Applicative f => ... f a, the structure of the result is known ahead of time
23:34:27 <jle`> before any effects or any execution
23:34:39 <Mibaz> grayhatter: I'm through Learn You a Haskell and have done a bit afterward. So very new.
23:34:47 <jle`> for IO, it means that all of the effects are know; for State, all of the state flow is known
23:34:50 <jle`> etc.
23:34:59 <grayhatter> I'm going to be evil and suggest something other than haskell
23:35:05 <jle`> for Monad m => ..., you can't know the structure of the result until actually "executing" and evaluating everything
23:35:43 <jle`> grayhatter: why are you using 'return', btw?
23:35:53 <jle`> it looks like you're just returning a string
23:36:05 <jle`> so 'if ... then str else show url' should be fine
23:36:08 <grayhatter> jle` I had to refactor from else where and that came along
23:36:42 <jle`> this is probably where your compile error is coming from
23:37:02 <jle`> also, instead of 'isJust'/'fromJust', you can pattern match
23:37:15 <jle`> case str of Just s -> s; Nothing -> show url
23:37:25 <jle`> or fromMaybe (show url) str
23:38:46 <jle`> Mibaz: LYAH is nice, and there's also that new haskellbook.com thing that everyone likes :)
23:39:03 <jle`> Mibaz: but, if you're goign to design a course, why not use byorgey's course?
23:39:07 <jle`> it alreay has a syllabus and everything :)
23:39:38 <stobix> Is this the video you spoke about, Axman6 : https://www.youtube.com/watch?v=sl2zo7tzrO8
23:39:51 <jle`> it's a famous course
23:40:13 <jle`> Mibaz: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
23:40:33 <Mibaz> jle`: hmm let's take a look
23:40:37 <suppi> Mibaz: http://gilmi.xyz/post/2015/02/25/after-lyah
23:40:51 <Axman6> stobix: it's one of them, I haven't seen that one. https://www.infoq.com/presentations/haxl is probably the one I was thinking of
23:40:57 <Axman6> stobix: watch both :)
23:42:09 <grayhatter> jle` I changed it to fromMaybe ... but now have Expected type: [Maybe String] ;; Actual type: IO (Maybe String)
23:42:26 <Mibaz> jle`: Would you say that this is far enough ahead of LYAH that I won't be repeating subjects unnecessarily? Looking at it, the first half looks familiar.
23:42:35 <Mibaz> jle`: An excellent suggestion.
23:43:00 <grayhatter> I was under the impression that <- would clear the IO, but I seem to be incorrect?
23:43:36 <Mibaz> suppi: that's a great page, thanks.
23:43:53 <Mibaz> keep in mind that this could be a cool project as well. One suggestion from before was to write a parser.
23:44:01 <jle`> Mibaz: it's not far ahead of LYAH, it actually is a course from-scratch
23:44:33 <suppi> Mibaz, sure.
23:44:36 <jle`> grayhatter: x <- ... executes the IO action/sequences the IO and names the result x
23:44:45 <jle`> but it can only be done in a do block returning IO
23:44:59 <jle`> so parseMilestone would return IO String
23:45:25 <jle`> so the return signature should be Milestone -> String -> IO String
23:45:31 <jle`> and then you would use return :: String -> IO String
23:45:46 <jle`> return $ fromMaybe (show url) str
23:46:11 <jle`> but i guess it also depends on the type of 'githubMkShort'
23:46:21 <jle`> what is its type?
23:46:28 <voltz> Are there some good examples of monad transformers somewhere? some github repo I could look through?
23:46:30 <grayhatter> githubMkShort :: String -> String -> IO (Maybe String)
23:48:06 <jle`> ah yeah, that'd work then
23:48:15 <jle`> but you also don't need liftIO in that case
23:48:22 <jle`> for IO, liftIO = id
23:48:40 <jle`> voltz: i always liked that 'monad transformers step by step' tutorial
23:49:28 <voltz> Thanks!
23:50:08 <Mibaz> Thank you all!
23:50:13 <grayhatter> jle` don't need lift IO?
23:50:37 <jle`> liftIO embeds an IO action into whatever monad you're working in
23:50:40 <grayhatter> line 137 ==   Expected type: IO String        Actual type: IO (IO String)
23:50:41 <jle`> but, you're working in IO already
23:50:46 <jle`> so there's no point really
23:50:55 <jle`> it's redundant
23:51:40 <jle`> grayhatter: look at line 137
23:51:45 <jle`> the result should be IO String
23:51:54 <jle`> line 136, the result is indeed IO String
23:51:58 <jle`> because return :: String -> IO String
23:51:59 <grayhatter> ahh
23:52:04 <jle`> but what 137?
23:52:14 <grayhatter> yup, it's already IO
23:52:28 <jle`> yeah, return would take an IO String and turn it into an IO (IO String)
23:52:33 <jle`> so ditch the 'return'
23:53:01 <jle`> grayhatter: you'd use liftIO when you're working in a monad that *isn't* IO, but you want to sequence an IO action into it
23:53:25 <jle`> so like if i'm using a monad 'Foo' and i wanted to use an IO action inside a 'Foo' do block, i'd use liftIO :: IO a -> Foo a
23:53:38 <jle`> but if you're already in IO, liftIO :: IO a -> IO a
23:53:44 <jle`> so it's basically 'id'
23:54:06 <jle`> liftIO (putStrLn "hello") :: Foo ()
23:54:20 <jle`> :t liftIO
23:54:21 <lambdabot> MonadIO m => IO a -> m a
23:54:44 <jle`> the "target monad" has to be an instance of MonadIO ofc, you can't just lift IO willy nilly into everything lol
23:55:28 <jle`> hey everyone, why isn't Proxy an instance of MonadIO
23:55:50 <jle`> anyone know how to submit a patch to 'transformers'
23:57:01 <voltz> oh also perhapse someone has some more information on this, I recall hearing in one of Kmetts talks where he said that lenses could be used to describe tree transformations
23:57:36 <MarcelineVQ> jle`: seems to be darcs based
23:58:08 <jle`> hm
23:58:14 <MarcelineVQ> http://hub.darcs.net/ross/transformers/issues etc
23:58:23 <jle`> oh thanks :)
23:58:56 <jle`> aw gotta sign up
23:59:00 <jle`> i'm just not cut out for ghc dev
