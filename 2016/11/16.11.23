00:07:38 * hackagebot bgmax 0.2.0.1 - Parse BgMax-files  https://hackage.haskell.org/package/bgmax-0.2.0.1 (petterb)
00:07:38 * hackagebot http-client 0.4.31.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.31.2 (MichaelSnoyman)
00:17:56 <magthe> I'm sure I've seen it numerous times, but now I can't find it: I'm looking for simple example of how to have a data type with multiple constructors and operations on that type that have restrictions on a constructor level. Hopefully http://lpaste.net/345007 is a clearer explanation :)
00:23:38 <lpaste> liste annotated “Operations with restrictions on constructors of arguments.” with “Operations with restrictions on constructors of arguments. (annotation)” at http://lpaste.net/345007#a345009
00:23:50 <liste> magthe: ^ I think you're looking for GADTs
00:24:09 <alfredo> snap, was going to say the same thing :D http://rextester.com/DVXH45441
00:24:14 <magthe> liste: yupp, thanks!
00:56:19 <haskell166> using megaparsec, how to parse a string? I mean any char that can be between ". I'm trying between (char '"') (char '"') (some anyChar) but it doesnt work
00:57:30 <liste> haskell166: can the string have escaped characters, like \" ?
00:57:59 <haskell166> no
00:59:16 <liste> haskell166: then you can use (some (noneOf "\""))
00:59:54 <haskell166> oh that's neat thanks!!!!
01:06:59 <Axman6> I think you probably want many, if you want to be able to match ""
01:07:35 * hackagebot pandoc-crossref 0.2.4.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.4.1 (lierdakil)
01:08:49 <wagnerf> hi, I need some design advices
01:09:09 <wagnerf> i'm currently learning haskell by porting some of my python code
01:09:34 <wagnerf> it is some geometry code and I have objects like points, segments, polygons, ...
01:09:49 <haskell166> Axman6, an empty string isnt valid anyway
01:09:50 <wagnerf> I have a very convenient display function
01:10:22 <wagnerf> I can call for example display(point1, point2, segment1, list_of_points)
01:10:35 <wagnerf> it will compute an svg file
01:10:42 <wagnerf> and display it interactively
01:10:54 <wagnerf> each argument will get a different color
01:10:57 <wagnerf> point1 red
01:11:01 <wagnerf> point2 blue
01:11:14 <wagnerf> all points in the list_of_points the same color
01:11:15 <GLaDER> Is it possible to print in a non IO function? My function has type: [Type] -> Env -> Exp -> Err Type, but I would like to add a little print in it for debugging
01:11:40 <wagnerf> how i do it in python is that each object which is displayable implements
01:11:43 <wagnerf> two methods
01:11:55 <wagnerf> a bounding_box method given its size
01:12:07 <wagnerf> a svg_string method converting it to a string
01:12:33 <wagnerf> the last part of it is that in display
01:12:43 <wagnerf> i loop on all arguments and check their types
01:12:59 <wagnerf> in case of lists I loop on the list 
01:13:16 <wagnerf> in case of an immediate displayable i just get its size/string
01:13:26 <wagnerf> so my question is :
01:13:39 <wagnerf> should I implement a displayable typeclass ?
01:13:55 <haskell166> deriving (Show)
01:14:08 <wagnerf> and then how to handle the list of lists ?
01:14:19 <haskell166> a list is an instance of show
01:14:27 <quchen> There is a way to override GHCi’s default "show" function, does anyone remember that?
01:14:41 <wagnerf> haskell166: yes, but I don't want a standard string
01:14:45 <quchen> I’d like to add a custom prettyprinter instead of using Show.
01:14:48 <wagnerf> I want some svg code
01:14:54 <haskell166> oh right
01:15:00 <wagnerf> this code is dependent from the whole image size
01:15:23 <wagnerf> it's a two pass thing : first compute sizes ; the use result to compute strings
01:17:03 <haskell166> well, you do a Class, something like class DisplaySVG a where      svgSize :: a -> Int
01:17:10 <haskell166> class DisplaySVG a where      svgSize :: a -> Int
01:17:53 <wagnerf> haskell166: this is ok for me but what is the type for the display function ?
01:18:13 <haskell166> I mean what do you want it to return?
01:18:23 <wagnerf> just a string
01:18:34 <wagnerf> haskell166: my problem is with the input
01:18:58 <haskell166> what do you need it to be?
01:19:22 <wagnerf> a list of displayable things where list of displayables are themselves displayables
01:19:45 <haskell166> oh I get it
01:19:59 <wagnerf> like : point1, segment1, list_of_points
01:21:45 <haskell166> http://lpaste.net/345020
01:21:49 <haskell166> do you want something like that?
01:22:50 <wagnerf> haskell166: yes, something like that
01:23:14 <wagnerf> haskell166: would this work and is it like a haskelly way to do it ?
01:23:26 <haskell166> yep that's the haskelly way to do it haha
01:23:43 <wagnerf> ok thanks
01:23:50 <wagnerf> i'll give it a try then
01:24:43 <wagnerf> haskell166: thank you very much for all your help
01:24:50 <haskell166> np :)
01:27:36 * hackagebot data-has 0.1.0.0 - Simple extensible product  https://hackage.haskell.org/package/data-has-0.1.0.0 (winterland)
01:38:21 <dramforever> GLaDER: Still there? Try this: https://hackage.haskell.org/package/base-4.9.0.0/docs/Debug-Trace.html
01:38:41 <dramforever> WARNING: Debug only, don't rely on it for 'normal' output
01:39:13 <dramforever> "These can be useful for investigating bugs or performance problems. They should not be used in production code." -- That docs page
01:52:35 <stalk> hi
01:52:39 <stalk> hello jedai 
01:56:00 <haskell594> I have a question
01:57:30 <haskell594> How do you do a reflexive and transitive closure in haskell
01:58:37 <dramforever> haskell594: More specific please
02:00:47 <dramforever> If you mean the one of a spooky thing called a 'graph' there's a library for that: http://hackage.haskell.org/package/fgl-5.5.3.0/docs/Data-Graph-Inductive-Query-TransClos.html
02:01:13 <haskell594> I have Relation set {1,2,3} and i have an ordered pair (0,1)  (1,1) (1,2) (2,0) (2,2) what coding should i use in haskell to get that to show as a reflexive closure and a symmetric closure
02:02:40 <haskell594> I have Relation set {1,2,3} and i have an ordered pair (0,1)  (1,1) (1,2) (2,0) (2,2) (3,0) what coding should i use in haskell to get that to show as a reflexive closure and a symmetric closure
02:04:57 <stalk> I'm trying to modify the `filestore` library to allow using remote repositories
02:05:42 <stalk> I opened an issue here https://github.com/jgm/filestore/issues/24 . I'm not sure how authentication should be done, as explained in the last comment.
02:05:56 <stalk> What do you think?
02:06:23 <stalk> (tell me if the channel is not appropriate for that question)
02:06:33 <Axman6> haskell594: as dramforever said, look at fgl
02:08:55 <taktoa> is foldl' (flip f) the same as foldr f
02:12:37 * hackagebot obdd 0.6.1 - Ordered Reduced Binary Decision Diagrams  https://hackage.haskell.org/package/obdd-0.6.1 (JohannesWaldmann)
02:14:47 <lpaste> dramforever pasted “There you go” at http://lpaste.net/345032
02:15:05 <dramforever> haskell594: ^ Little demo over there
02:15:23 <lpaste> dramforever revised “There you go”: “There you go” at http://lpaste.net/345032
02:16:11 <Axman6> taktoa: no, the difference is that foldl must always traverse the entire list before returning any result, but foldr can produce values immediately
02:16:18 <a1b2c3d4e5f6g7h8>  
02:16:22 <Axman6> > foldl f z [a,b,c,d]
02:16:23 <a1b2c3d4e5f6g7h8> a1b2c3d4e5f6g7h8i9j10k11l12m13n14o15p16q17r18s19t20u21v22w23x24y25z26
02:16:24 <lambdabot>  f (f (f (f z a) b) c) d
02:16:30 <Axman6> > foldr f z [a,b,c,d]
02:16:32 <a1b2c3d4e5f6g7h8> zyxwvutsrqponmlkjihgfedcba
02:16:33 <lambdabot>  f a (f b (f c (f d z)))
02:16:34 <a1b2c3d4e5f6g7h8> z26 y25 x24 w23 v22 u21 t20 s19 r18 q17 p16 o15 n14 m13 l12 k11 j10 i9 h8 g7 f6 e5 d4 c3 b2 a1
02:16:35 <a1b2c3d4e5f6g7h8> a1 b2 c3 d4 e5 f6 g7 h8 i9 j10 k11 l12 m13 n14 o15 p16 q17 r18 s19 t20 u21 v22 w23 x24 y25 z26
02:16:40 <Axman6> @where ops
02:16:40 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
02:17:04 <haskell594> sorry i said transitive when it should have been symmetric closure
02:17:05 <a1b2c3d4e5f6g7h8> @where ops suck dick the whore clit?
02:17:05 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
02:17:16 <a1b2c3d4e5f6g7h8> aye, the nigger
02:17:38 * hackagebot linearmap-category 0.2.0.0 - Native, complete, matrix-free linear algebra.  https://hackage.haskell.org/package/linearmap-category-0.2.0.0 (leftaroundabout)
02:17:45 <a1b2c3d4e5f6g7h8> the other spic eat a good idea to have a great way of getting to 
02:17:47 <dramforever> > foldl (flip f) z [a,b,c,d] -- Let's try
02:17:50 <lambdabot>  f d (f c (f b (f a z)))
02:18:03 <a1b2c3d4e5f6g7h8> on the phone with you. I will have to be able to make it to the next few days ago and have a rsnsjsijddjdjnsjwhvuh gcu uf uf uf,,uyf,uf,yf,u,you are not going to be a little more about the position. 
02:18:05 <Axman6> > scanll f z [a,b,c,d]
02:18:08 <lambdabot>  error:
02:18:08 <lambdabot>      • Variable not in scope: scanll :: t0 -> Expr -> [Expr] -> t
02:18:08 <lambdabot>      • Perhaps you meant one of these:
02:18:10 <Axman6> > scanl f z [a,b,c,d]
02:18:11 <a1b2c3d4e5f6g7h8> the first to see the place . we will need the help and advice on the other day, but the other day, I am not sure what you want to do 
02:18:12 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
02:18:14 <dramforever> > foldl (flip f) z (reverse [a,b,c,d]) -- Let's try
02:18:16 <lambdabot>  f a (f b (f c (f d z)))
02:18:24 <taktoa> yeah that makes sense, just wasn't sure if I was missing something
02:18:27 <dramforever> > foldr f z [a,b,c,d]
02:18:29 <lambdabot>  f a (f b (f c (f d z)))
02:19:29 <dramforever> taktoa: But still foldl will scan through the list before returning useful result
02:20:14 <dramforever>  > foldr (&&) True [False, error "Uh oh"]
02:20:17 <dramforever> > foldr (&&) True [False, error "Uh oh"]
02:20:19 <lambdabot>  False
02:20:20 <a1b2c3d4e5f6g7h8> eine Nazi Hitler and the kids are doing well 
02:20:26 <dramforever> > foldl' (flip (&&)) True (reverse [False, error "Uh oh"])
02:20:28 <a1b2c3d4e5f6g7h8> the other side, and I have been in contact. we will need the help and advice for you, I will have a good idea to have a good time to get it to you. I 
02:20:28 <lambdabot>  *Exception: Uh oh
02:20:37 <a1b2c3d4e5f6g7h8> on Wed, s52gxxtxt . I Fogg the the the the the the the the the the the the the the the 
02:20:47 <a1b2c3d4e5f6g7h8> and then we with your own 
02:22:09 <a1b2c3d4e5f6g7h8> fag the. follow up on a few assuming the. the first to review the attached to a few days, so I can see the attached document and a lot of fun. we have a good time for the delay in getting the best of all the way to do with the same time. I am going on in my head and neck, but I am not going anywhere 
02:22:15 <a1b2c3d4e5f6g7h8> a1 b2 c3 d4 e5 f6 g7 h8 i9 j10 k11 l12 m13 n14 o15 p16 q17 r18 s19 t20 u21 v22 w23 x24 y25 z26z26 y25 x24 w23 v22 u21 t20 s19 r18 q17 p16 o15 n14 m13 l12 k11 j10 i9 h8 g7 f6 e5 d4 c3 b2 a1zyxwvutsrqponmlkjihgfedcbaa1b2c3d4e5f6g7h8i9j10k11l12m13n14o15p16q17r18s19t20u21v22w23x24y25z26
02:22:16 <a1b2c3d4e5f6g7h8> a1b2c3d4e5f6g7h8i9j10k11l12m13n14o15p16q17r18s19t20u21v22w23x24y25z26zyxwvutsrqponmlkjihgfedcbaz26 y25 x24 w23 v22 u21 t20 s19 r18 q17 p16 o15 n14 m13 l12 k11 j10 i9 h8 g7 f6 e5 d4 c3 b2 a1a1 b2 c3 d4 e5 f6 g7 h8 i9 j10 k11 l12 m13 n14 o15 p16 q17 r18 s19 t20 u21 v22 w23 x24 y25 z26
02:22:26 --- mode: ChanServ set +o dcoutts
02:22:30 --- mode: dcoutts set +b *!*a1b2c3d4e@104.254.215.22
02:22:30 --- kick: a1b2c3d4e5f6g7h8 was kicked by dcoutts (a1b2c3d4e5f6g7h8)
02:22:39 <Axman6> Thanks Duncan
02:22:44 <dcoutts> np
02:23:32 <Axman6> some of the strangest spamming i've seen
02:23:59 <dcoutts> mm, pretty weird
02:26:43 --- mode: ChanServ set -o dcoutts
02:26:46 <taktoa> looks like someone made a CNN or RNN bot
02:27:42 <taktoa> err, more likely RNN
02:28:23 <SaggyClit> hi
02:28:32 --- mode: ChanServ set +o dcoutts
02:28:59 <SaggyClit> easy man  no need to op up, its just my nick.  I am not here to troll
02:29:10 <SaggyClit> I have some deep and meaningful questions about haskell
02:29:23 <SaggyClit> firstly, what the fuck is haskell even good for?
02:29:30 <SaggyClit> I mean, in the long term
02:29:39 <SaggyClit> how does it help me get to your mom's clit?
02:29:44 <SaggyClit> and to make it sag less?
02:30:04 <zomg> How disappointing
02:30:09 <zomg> I expected something more imaginative
02:30:12 --- mode: dcoutts set +b *!*labiaclit@104.254.215.84
02:30:12 --- kick: SaggyClit was kicked by dcoutts (SaggyClit)
02:30:38 <zomg> seems you may want to ban that IP address
02:30:40 <wagnerf> haskell166: one last question : i'm wondering how to export the instance for lists of DisplaySVG out of its module 
02:30:44 <zomg> the previous spammer was also from the same IP
02:30:46 * Axman6 feels a ban on 104.254.215.* might be more effective
02:30:58 <zomg> Axman6: ah yeah you're right
02:31:02 <dcoutts> right, it's different IPs in the subnet
02:31:07 <Axman6> not quite the same, guess they know how to unplug a router
02:32:32 <dcoutts> someone may have to help me though, I'm not well versed in the syntax beyond the pre-canned recipes
02:33:29 <zomg> it's probably just /ban *!*@ip.address.goes.here.*
02:33:46 <zomg> or if your client doesn't like that, /mode +b *!*@ip.address.here.*
02:34:06 <zomg> (or possibly #haskell before +b in that invocation, been a while for me as well)
02:34:34 <zomg> the format is basically <nick>!<ident>@<host>
02:35:13 --- mode: dcoutts set +b *!*@104.254.215.*
02:37:28 <dcoutts> zomg: ta
02:37:31 --- mode: ChanServ set -o dcoutts
02:56:17 <quchen> 9 seconds faster and dcoutts could have violated causality
02:57:04 <dcoutts_> will try harder next time
03:21:47 <wagnerf> I have a DisplaySVG typeclass, instancied for Point and Segment
03:21:52 <tdammers> . o O ( violating causality since 2017 )
03:22:08 <wagnerf> i'd like to have a display function taking as argument a list of both points and segments
03:22:14 <wagnerf> is it possible ?
03:22:30 <wagnerf> (since they both instanciate the class)
03:23:54 <lyxia> You could wrap them in an existential type   SomeDisplaySVG where SomeDisplaySVG :: DisplaySVG a => a -> SomeDisplaySVG
03:25:06 <wagnerf> lyxia: but then the calling syntax would be more complex since I would need to manually convert everyone before the call
03:28:01 <lyxia> Okay, do you have some example of code that you would like to refactor
03:28:16 <wagnerf> display [p1, p2, s1]
03:28:53 <lyxia> How about using an HList
03:29:08 <lyxia> it still won't be an ideal syntax but would be pretty close
03:29:29 <wagnerf> lyxia: ok, I don't know about them. will take a look
03:29:47 <lyxia> or you could overload display to have variable arity
03:30:08 <wagnerf> lyxia: is it something like that : http://rosettacode.org/wiki/Variadic_function#Haskell (just found it)
03:30:26 <lyxia> yeah
03:30:38 <wagnerf> lyxia: oh great. i think that will do it fine
03:31:15 <wagnerf> lyxia: and hlists seem interesting too
03:31:40 <wagnerf> thanks
03:32:11 <lyxia> yw
04:10:49 <_temp_> @pl f x = g x $ b x
04:10:49 <lambdabot> f = ap g b
04:14:04 <GLaDER> dramforever: Got that recommended from a friend too, thank you!
05:01:45 <ocramz> hi all
05:02:06 <ocramz> is there a notion of a structure that can be traversed in more than one way? e.g. row-wise and column-wise?
05:03:09 <maerwald> bi-traversable?
05:03:23 <maerwald> (I just came up with that)
05:03:53 <ocramz> that's an interesting and perhaps fitting name, but is there something out there that implements it?
05:04:08 <maerwald> not sure if that's particularly useful as a typeclass
05:04:43 <maerwald> https://hackage.haskell.org/package/bifunctors-5.4.1/docs/Data-Bitraversable.html
05:04:44 <maerwald> sheesh
05:05:08 <maerwald> but I'm not sure if that's what we are lookin for
05:05:27 <maerwald> I think not
05:06:10 <merijn> ocramz: Can you elaborate on "more than one way of traversal"? You just mean the ordering in which elements are encountered?
05:08:12 <ocramz> merijn: indeed; let's use a matrix as an example: its elements can be organized in rows or in columns, and these sets of rows or cols can be traversed in order.
05:08:39 <ocramz> seen another way, it's a structure that allows two distinct types of "nesting"
05:09:35 <merijn> ocramz: That seems like it just has two valid Traversable instances
05:09:49 <merijn> ocramz: Something you'd normally tackle using newtype for other classes with multiple valid instances
05:10:56 <maerwald> ocramz: you could try to come up with your on class
05:11:34 <ocramz> merijn : yep that's a good point thanks 
05:11:45 <ocramz> something like `instance Traversable (Matrix (Rows a))` 
05:14:14 <SrPx> So, the act of programming is basically that of finding a program that satisfies a type... which is the exact same process for finding mathematical proofs... 
05:14:32 <maerwald> SrPx: not particularly
05:14:35 <tdammers> SrPx: dream on :(
05:14:45 <SrPx> How so?
05:14:54 <tdammers> the act of programming is basically that of finding a program that satisfies management
05:14:59 <ocramz> :D
05:15:01 <maerwald> types don't necessarily express the logic of your program
05:15:01 <SrPx> ah haha 
05:15:15 <SrPx> can't you express arbitrary logic with types?
05:15:23 <merijn> SrPx: You sound like you might want to read Conor McBride's thesis :)
05:15:26 <tdammers> "we know it's broken, but it's broken in a useful way"
05:15:26 <maerwald> that's what proof assistants are for
05:15:49 <merijn> SrPx: On deriving code from types: https://www.era.lib.ed.ac.uk/bitstream/handle/1842/374/ECS-LFCS-00-419.pdf?sequence=1&isAllowed=y
05:16:20 <merijn> tdammers: I'm one of those weirdo's who felt optimistic about existentialism :)
05:16:35 <maerwald> merijn: wrong channel xD
05:16:45 <merijn> maerwald: Switching is hard >.>
05:17:19 <merijn> That's what I get for reading notifications mid sentence
05:18:00 <tdammers> merijn: I got there eventually
05:18:56 <SrPx> about that
05:19:53 <merijn> On a completely unrelated note: I have a binary tree (specifically, a decision tree) which splits on N different properties. I want to, somehow, collapse this in a simpler tree of N layers, one multi-way split per property. Anyone aware of any algorithms for this or do I need to invent one?
05:19:55 <SrPx> I wish there was some kind of program, company, ong, site, whatever, that just devoted its existence to reading as much papers as it could, removing duplicate information and building a single source of knowledge /:
05:20:03 <kuribas> > toListOf (traverse.traverse) $ (transposeOf traverse)  [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
05:20:05 <lambdabot>  [1,4,7,2,5,8,3,6,9]
05:20:51 <maerwald> SrPx: you might want to check out wikipedia
05:22:12 <SrPx> maerwald nah Wikipedia will list a ton of duplicated info in the form of different theories that were found out to be the same thing under different names but are still listed separately... it just attempts to append everything, there is no effort to cut it down
05:22:36 <maerwald> SrPx: sure there is, but not enough people are doing it
05:22:48 <maerwald> because it's hard
05:37:12 <kuribas> > ((/) <$> view _1 <*> view _2) (4, 2)
05:37:16 <lambdabot>  2.0
05:37:28 <kuribas> Is there another way to do this?
05:37:34 <maerwald> > 4 / 2
05:37:36 <lambdabot>  2.0
05:38:24 <maerwald> > uncurry (/) (4, 2)
05:38:26 <lambdabot>  2.0
05:38:30 <kuribas> > ((/) <$> view (_1._2 <*> view (_2._2))) (("4", 4) , ("2", 2))
05:38:33 <lambdabot>  error:
05:38:33 <lambdabot>      • Couldn't match type ‘(([Char], t0), ([Char], t1)) -> b1’
05:38:33 <lambdabot>                       with ‘Const a a’
05:38:41 <maerwald> why would you even lens that?
05:38:44 <kuribas> > ((/) <$> view (_1._2) <*> view (_2._2)) (("4", 4) , ("2", 2))
05:38:46 <lambdabot>  2.0
05:38:54 <maerwald> obfuscation contest?
05:38:58 <kuribas> maerwald: curiosity
05:40:16 <paolino> does eta reduction change the performance of a function ?
05:40:42 <merijn> paolino: In reality? Yes
05:40:44 <maerwald> afair it has implications for inlining
05:41:15 <paolino> mh, should I notice it only in ghci ?
05:41:21 <maerwald> https://github.com/quchen/articles/blob/master/fbut.md#--4-is-not-x---x---4
05:41:25 <merijn> paolino: GHC normally only inlines "full applied" functions (i.e., number of arguments equal to the arguments in the equation)
05:41:37 <merijn> paolino: ghci is useless for performance measurements
05:41:53 <maerwald> ah no, it was this https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
05:41:54 <merijn> (Well, unless you're trying to measure the performance of GHCI, I suppose)
05:42:17 <maerwald> you could consider it a GHC bug, but...
05:42:46 <paolino> merijn, I have an eta reducted function which is 3.5 times faster in ghci , should I expect the same in ghc ?
05:43:11 <paolino> 3.5  times faster than its coounterpart
05:43:18 <paolino> unreducted
05:43:57 <merijn> paolino: You should suspect ghci performance to have approximately no correlation whatsoever with the performance when compiled using GHC, especially when considering optimisation flags
05:45:39 <kuribas> > (bool <$> view _1 <*> view _2 <*> view _3) (4, 2, True)
05:45:41 <lambdabot>  2
05:46:19 <kuribas> maerwald: what about this? ^
05:46:29 <maerwald> I don't know what you're doing there
05:46:46 <kuribas> maerwald: applying a function to different lenses.
05:47:55 <paolino> maerwald, I can't the article, it suggest to eta reduct for inlining or the opposite ?
05:49:43 <lpaste> paolino pasted “which is better for performance” at http://lpaste.net/345064
05:51:14 <paolino> is ghci inlining on one of them, or it is something else going on ?
05:53:26 <Tuplanolla> Listen to merijn, paolino.
05:53:44 <kuribas> paolino: it looks the same
05:53:58 <Tuplanolla> You're not measuring anything useful with GHCi.
05:54:32 <kuribas> paolino: benchmark it with criterion, but there isn't going to be any difference.
05:55:44 <wagnerf> i'm trying to instanciate a class on a String and get an error message I do not understand
05:55:53 <wagnerf> http://pastebin.com/S5Z2e7FD
05:55:57 <wagnerf> this is my current code
05:56:06 <paolino> Tuplanolla, got that, ghci is not for measuring, still I'd like to understand what it's doing to make it like that
05:56:30 <merijn> wagnerf: The Report is overly conservative on what instances are allowed to look like (with no particular reason, tbh)
05:57:03 <wagnerf> merijn: so, is it like a strong warning or a real mistake ?
05:57:06 <merijn> wagnerf: As the error mentions it only allows "(T a0 a1 a2...)" where T is a type constructor and a0 and onwards are distinct type variables. String, being [Char] is not that
05:57:20 <wagnerf> merijn: yes but
05:57:36 <merijn> wagnerf: Neither, it's perfectly sensible and for historical reasons no one really knows the Report doesn't allow it, so enable FlexibleInstances as it says and it'll work :)
05:57:53 <wagnerf> merijn: ha ok
05:58:17 <merijn> wagnerf: There's no real reason for the restriction to exist, imo and I expect/hope the new Haskell Prime committee will remove it
05:58:28 <wagnerf> ok
05:58:45 <wagnerf> i'll take a look in the flexible instances
05:58:48 <wagnerf> thanks
06:01:40 <wagnerf> merijn: any pointer on how to enable it ?
06:01:42 <lyxia> The restriction makes the implementation and specification of typeclasses quite simpler I think, since it avoids problems with overlaps.
06:01:42 <paolino> with no optimizations the behavior is reflected in ghc, with -O2 they are the same
06:02:21 <wagnerf> oh this maybe : {-# LANGUAGE FlexibleInstances #-}
06:02:28 <merijn> wagnerf: Add "{-# LANGUAGE FlexibleInstances #-}" as first line in your file or use "ghc -XFlexibleInstances" to compile
06:02:45 <wagnerf> thanks
06:02:53 <merijn> Note the pragma must be before your module declaration ("module Foo where ...")
06:03:50 <merijn> lyxia: Sure, but there's too many useful cases being ruled out and I think the debate on how things should be handled (e.g. in FlexibleInstances) is also pretty much settled
06:04:17 <paolino> thanks all, impressive difference for a coding style (without optimizations)
06:04:47 <lyxia> Right I agree. I just meant that as a potential "historical reason".
06:08:15 <maerwald> paolino: you mean the pointful version is faster with -O0?
06:08:36 <paolino> pointful being ?
06:08:47 <paolino> with the 'l' ?
06:09:44 <paolino> 100x slower in the application
06:10:05 <paolino> the second one
06:10:05 <maerwald> I still don't know what is slower
06:10:30 <paolino> I don't know what pointful means sorry
06:10:52 <paolino> I guess the one with more arguments
06:11:02 <lyxia> can you paste your benchmarking code too
06:12:29 <paolino> lyxia I just ran the program prepending with time
06:13:00 <lyxia> the first one is probably faster because it is more likely to be inlined. I think the rule is that GHC inlines fully applied functions, in the sense that they are applied to as many arguments as they have in the left hand side of their definition.
06:14:22 <lpaste> paolino pasted “anagrams” at http://lpaste.net/345071
06:15:42 <lyxia> here cond is applied to one argument. so it if it is defined as "cond d = ..." then it is inlined, whereas with "cond d l = ..." it is not.
06:16:45 <paolino> lyxia in the call ?
06:17:44 <lyxia> line 43, yes
06:18:01 <SrPx> Is there any difference between `∀(x:*) -> *` and `* -> *` in morte? 
06:18:02 <lyxia> here it's not only a matter of being inlined
06:18:43 <paolino> so if I explicit the l with a lambda I get a different inlining ?
06:18:44 <kuribas> paolino: use criterion for benchmarking.  It will avoid common pitfalls...
06:18:52 <kuribas> paolino: and ghc -O2
06:19:14 <paolino> kuribas with -O2 they are the same
06:21:17 <paolino> kuribas, I've never used criterion, I append it to the must know list, thanks
06:22:17 <lyxia> paolino: with your first version of cond, when you apply it to some d, computes (M.fromList (partitionDict d)) only once, and the resulting Map is shared across subsequent applications to different "l" arguments.
06:22:36 <lyxia> paolino: whereas your second version recomputes the Map for every "l"
06:22:50 <paolino> oh
06:23:00 <lyxia> (that is, with no optimizations)
06:23:35 <paolino> how could you deduce that ?
06:23:53 <paolino> I was trying to spot it
06:26:53 <paolino> for the order of the M.lookup arguments ?
06:26:57 <paolino> I'm puzzled
06:27:33 <lyxia> a naive compiler, when it sees the second version, will assume that anything to the right may depend on l.
06:28:06 <paolino> it misses the sharing even with the l in the end
06:28:09 <lyxia> and so it can not share the computation of the Map.
06:28:26 <lyxia> ?
06:28:34 <paolino> (flip M.lookup ...................) l
06:28:53 <lyxia> yes, that's my point
06:29:30 <paolino> I don't get it , even that flip version is doing bad
06:29:33 <lyxia> cond d l = (...) l  <- it naively assumes (...) depends on all the arguments of cond
06:30:00 <paolino> ok
06:31:02 <lyxia> and so it is recomputed for every l you pass to this function
06:31:08 <paolino> fine, the introduction of an abstraction is interpreted as a condition for recomputation
06:31:35 <lyxia> cond l = (...)  <- here it is clear that (...) does not depend on the argument that is not present.
06:31:51 <paolino> cond d
06:31:55 <lyxia> right
06:32:39 <paolino> very instructive, thanks a bunch
06:33:17 <lyxia> an optimization, which is enabled by -O2 (maybe -O1), is to analyze the expression further to determine the dependencies more precisely
06:33:25 <paolino> -O2 is smarter and make some kind of expression analysis
06:33:36 <paolino> yep
06:33:59 <lyxia> but it takes more time, so it's not enabled by default
06:34:17 <thepreacher> I've installed stack and created a sample project. I opened the Setup.hs file from Emacs and I get the error: Failed to load interface for 'Distribution.Simple'. It goes on to say that it part of hidden package 'Cabal-1.24.0.0'. I think it means I have to install Cabal. Will the command 'stack install cabal' do?
06:35:49 <bartavelle> thepreacher, you should already have cabal, as it comes with the compiler
06:35:51 <lyxia> paolino: it's also a trade-off, it might be preferable to recompute a big value rather than keep it in memory at all times
06:36:22 <bartavelle> thepreacher, it is already installed, and ghc knows about it, as it tells you it's part of a *hidden* package it knows about
06:37:12 <bartavelle> thepreacher, I think the problem is that your plugin doesn't realize that Setup.hs is special, and should not be treated like other files in your project
06:37:25 <bartavelle> as a result, it doesn't include the Cabal dependency
06:37:43 <thepreacher> bartavelle: why then is 'import Distribution.Simple' failing in emacs then? Any ideas?
06:38:45 <bartavelle> as I said, I think the plugin you are using doesn't add the Cabal dependency when type-checking Setup.hs
06:38:58 <bartavelle> as it's implicit when used by cabal itself
06:39:08 <bartavelle> and not documented in the .cabal file
06:39:08 <thepreacher> bartavelle: you answered before I finished typing.
06:39:12 <bartavelle> ah sorry :)
06:41:46 <paolino> lyxia, it sounds strange to control that trade with -O2
06:43:21 <paolino> lyxia, how to force recomputation leaving -O2 (not that I need it here)
06:44:26 <maerwald> imo, one can't properly reason about performance in haskell, because of those gotchas
06:44:51 <maerwald> and I stopped trying... I just test different data structures sometimes to optimize performance, that's all
06:49:21 <lyxia> paolino: I think you can do it with non-inlineable functions to introduce artificial dependencies
06:58:55 <django_> hey
06:59:14 <django_> anyone have project ideas 
06:59:39 <tdammers> django_: sure, thousands
07:00:01 <tdammers> django_: what exactly do you need? what's your situation?
07:00:07 <django_> tdammers, im just bored
07:00:11 <django_> id like to do something
07:00:15 <tdammers> django_: eulerproblems?
07:00:15 <django_> keep a little busy
07:00:23 <tdammers> django_: create a toy HTTP server?
07:00:33 <tdammers> django_: invent a programming language and write an interpreter for it?
07:00:54 <django_> im interested in people
07:01:04 <django_> and i wanna combine social network concept + people
07:01:13 <tdammers> that's kind of vague
07:01:17 <django_> i know
07:01:43 <tdammers> can you be more specific?
07:02:09 <MarcelineVQ> a singularity engine
07:02:17 <tdammers> I mean, social networks are intrinsically about people already
07:02:48 * hackagebot servant-snap 0.7.0.3 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.7.0.3 (imalsogreg)
07:02:53 <wamaral> could be about cats
07:03:21 <tdammers> how about a website where users can upload cat pictures and then other users can comment on them and up/downvote them, and the most upvoted images make it to the front page
07:03:23 <tdammers> oh wait
07:05:46 <django_> lol
07:05:55 <django_> the thing is it would kind of copy stackexchange
07:06:11 <lyxia> When encountering a type error, social GHC would ask about it on SO, and then report back with the top answer.
07:06:12 <django_> i think people have problems and sharing them with others can yield solutions
07:06:21 <django_> imagine SE but only for "life problems"
07:06:27 <django_> and it would be in depth
07:06:30 <django_> not like "should i major in math or CS"
07:08:00 <maerwald> django_: doesn't work... inter-subjectivity is too low
07:09:25 <django_> maerwald, inter-subjectivity?
07:10:14 <maerwald> django_: yes, missing consensus, grounds for arguments etc
07:11:30 <stalk> hi
07:11:33 <stalk> hi jedai
07:17:16 <django_> ah
07:24:03 <grazie> can anyone tell me  what this remapping will do for https://github.com/bitc/vim-hdevtools   https://gist.github.com/26487b2e81a30a1b6e894c1392ade4cc   I'm not sure if it's going to conflict with something I already have setup in vim (for use with another language, for example)
07:25:35 <grazie> I'm guessing it will only be activated for haskell files so I don't have to worry about a conflict?
07:30:12 <tabaqui1> let x = "abc" :: Data.ByteString
07:30:17 <tabaqui1> :t x 
07:30:19 <lambdabot> Expr
07:30:22 <tabaqui1> Data.ByteString.Char8
07:30:24 <tabaqui1> why so?
07:30:34 <tabaqui1> *Data.ByteString.Char8.ByteString
07:30:49 <tabaqui1> *let x = "abc" :: Data.ByteString.ByteString
07:31:03 <c_wraith> tabaqui1: You probably have Data.ByteString.Char8 imported,
07:31:23 <c_wraith> tabaqui1: ghci prefers to show you a name for the type that's imported over a name that isn't imported
07:31:29 <tabaqui1> c_wraith: yes, but why ghc interpret word8 BS as char8 BS?
07:31:37 <c_wraith> tabaqui1: because they're the same type
07:32:07 <tabaqui1> read "ads" :: Data.ByteString.ByteString
07:32:10 <tabaqui1> "*** Exception: Prelude.read: no parse
07:32:22 <tabaqui1> ah, ok
07:32:48 <c_wraith> tabaqui1: yes, that doesn't parse.  Try read "\"ads\"" :: Data.ByteString.ByteString
07:32:57 <tabaqui1> hmm, I thought that Char8 contains 128 symbols, not 256
07:33:25 <tabaqui1> c_wraith: so, Char8 is alias for Word8?
07:33:33 <c_wraith> tabaqui1: .Char8 is a hack for working with ascii more conveniently.  But it does lots of things that are flat-out wrong if you're not using ASCII
07:33:40 <ak5> hi, is there a good tutorial to recommend to web developers for learning haskell? Maybe one centered around yesod or something?
07:33:55 <c_wraith> ak5: there's the entire yesod book.
07:34:02 <ak5> good for beginners?
07:34:09 <ak5> haven't looked at it myself
07:34:14 <c_wraith> Probably.  I think it was intended for beginners.
07:34:18 <c_wraith> I've never read it
07:34:20 <ak5> kk thx
07:34:26 <tabaqui1> c_wraith: they are the same as types, but libraries contain different functions, right?
07:34:34 <c_wraith> tabaqui1: yes
07:34:45 <tabaqui1> that makes sense, thank you
07:34:51 <c_wraith> tabaqui1: most of them just convert Char to Word8 by truncation.
07:35:01 <ak5> c_wraith: just to be clear: http://www.yesodweb.com/book ?
07:35:20 <c_wraith> ak5: that is the one.  I believe it's intended to get people who've never used haskell up and running with Yesod
07:35:40 <ak5> awesome, just what I needed
07:36:06 <ak5> have a good day
07:36:27 <shapr> GOOD MORNING!
07:36:31 <shapr> It's a beautiful day for code!
07:36:41 <maerwald> I think the only justifiable use of Char8 is for network protocols that are designed that way and you don't care about accidential truncation
07:36:46 <c_wraith> Is there such a thing as a good morning?  Morning is when humans are intended to be asleep. :)
07:37:22 <shapr> I read some neat blog posts from fp complete yesterday: https://www.fpcomplete.com/blog/
07:37:22 <c_wraith> maerwald: there are non-network file formats that are defined as ascii only, too.  :)
07:37:35 <c_wraith> Yeah, they posted a bunch in the last couple days
07:37:35 <shapr> c_wraith: there is truth in what you say, I wanted to stay in bed and write Haskell code this morning.
07:39:28 <django_> shapr, what are you doing
07:39:44 <django_> im bored, nothing to do
07:40:09 <shapr> django_: have you written any cool Haskell code lately?
07:40:43 <shapr> django_: if you're bored, I suggest rewritin some of your shell scripts using the Turtle library: https://hackage.haskell.org/package/turtle-1.2.8/docs/Turtle-Tutorial.html
07:41:09 <django_> shapr, lol i actually dont know haskell, just heared it a great IRC community 
07:41:17 <bollu> In path induction, the LHS requires you to give a type family that is (pi (x, y:A) -> a =A y -> U ) -> <induction on x, x, refl_x> -> (pi (x, y : A) -> (pi: a =A y) -> U. Why is it that the LHS is not allowed to be dependant on x =A y while the RHS is?
07:41:25 <django_> i was thinking of learning haskell but then its just another language and i stil dont have any projects to work ob
07:41:26 <django_> on*
07:41:50 <Lokathor> it's a star language
07:43:58 <shapr> django_: I usually start by writing code to automate what I do every day. Do you check your email every day or anything like that?
07:45:36 <shapr> Perhaps django_ will find motivation elsewhere.
07:46:24 <shapr> BUT I DOUBT IT.
07:47:29 <ongy> how would you automate checking your mail?
07:47:30 <berndl> bollu: you seem to be using pi in two different ways. 
07:47:57 <shapr> ongy: perhaps Network.IMAP ?
07:48:23 <ongy> and that would help how? Making your own mua? Have fun
07:48:34 <maerwald> thunderbird (and every major client) already automatically checks my emails
07:48:45 <shapr> ongy: meh, peti wrote postmaster long ago, I used it for awhile: https://hackage.haskell.org/package/postmaster
07:48:55 <maerwald> postmaster is unfinished
07:48:58 <shapr> oh wait, that's an MTA
07:49:20 <shapr> hm, I ran postmaster and it was working at some point
07:49:33 <maerwald> this sounds all weird
07:49:37 <ssarah_> hullo. I'm trying to figure out how detect if an elem e belongs to a dict like structure. Something like belongs e Dict d where d is in the form [(e,[words])]
07:50:04 <ssarah_> i cant use patterns with elem, right? stuff like elem (e,_) dict dont work
07:50:09 <mthek> ssarah_: was about to ask the exact same question
07:50:24 <shapr> Is there a collection of turtle scripts somewhere I'd like to see more examples of replacing various shell tools.
07:51:32 <cloudhead> ssarah_: Data.List has a `lookup` function which should work
07:52:09 <cloudhead> then you can use isJust from Data.Maybe
07:53:29 <cloudhead> alternatively you can do `Map.member k . Map.fromList`
07:53:50 <peddie>  > let isIn n = elem n . map fst in isIn 3 [(2, 'a'), (3, 'b')]  -- ssarah_ 
07:53:57 <guillaum2> http://lpaste.net/345119 I'm trying to teach GHC that if Or a b == 'False, it implies that a and b == 'False (Or is a type family on boolean kind) Is there a way to do that ?
07:53:58 <peddie> > let isIn n = elem n . map fst in isIn 3 [(2, 'a'), (3, 'b')]  -- ssarah_ 
07:54:00 <lambdabot>  True
07:54:04 <ssarah_> cloudhead, dang, i did look throuhgh Data.List :/ failure. Will check again now.
07:55:14 * Extraterrestre good day all!
07:56:02 <mniip> guillaum2, that's a type C injective type family
07:56:09 <mniip> so no, I believe - not yet
07:56:49 <c_wraith> guillaum2: you can write a type checker plugin that will teach GHC that, but it will be painfully ad-hoc.
07:57:29 <guillaum2> mniip: damned ;) Ok. And by any chance, do you know a way of solving my true problem differently. I'm trying to ensure that "eval" can only be called on an Ast which does not contain a "Var".
07:57:40 <guillaum2> c_wraith: this may be fun, but really ad-hoc yes ;)
07:57:50 * hackagebot haxl 0.4.0.2 - A Haskell library for efficient, concurrent,  and concise data access.  https://hackage.haskell.org/package/haxl-0.4.0.2 (niteria)
07:57:57 <mniip> oh hmm, that's not even type-C injective
07:58:15 <mniip> as Or a True = True doesn't determine a
07:58:21 <c_wraith> guillaum2: you can use the phantom universally-quantified type variable trick.
07:58:35 <c_wraith> guillaum2: basically, it's the same idea ST uses
07:59:03 <c_wraith> guillaum2: except that the Var constructor would make it a concrete type, and it has to unify everywhere.  Eval would require it to be polymorphic
07:59:12 <ezyang> guillaum2: Any Var at all, or a free var? 
07:59:17 <c_wraith> guillaum2: and so you couldn't call eval if there's a Var present.
07:59:43 <ssarah_> peddie, that was very insighful ty.
07:59:59 <guillaum2> ezyang: by free, what do you mean exactly ?
08:00:10 <ssarah_> It's hard for me to switch to thinking in haskell from other languages. 
08:00:16 <peddie> ssarah_: you're welcome; I should probably have named it `hasKey` or something more useful :)
08:00:23 <ezyang> (\x -> x) 2 has a Var in it but it should be interpretable 
08:00:41 <peddie> ssarah_: it takes practice -- just keep on hackin' :)
08:01:20 <guillaum2> ezyang: ok ;) My Ast does not yet allows functions, so they are only free var.
08:02:14 <guillaum2> c_wraith: I'll abuse a bit, but can you give me a starting point for this phantom universally quantified type variable ? I know it exists for ST, but never really understood how it works.
08:06:51 <ardu> hi. i created these two average functions: http://lpaste.net/345131 is there a way to make it a single function named 'average'? or is that not even considered a good idea?
08:10:25 <lyxia> how would that single function work
08:11:52 <ardu> lyxia: oh i see it doesn't make sense now, in an earlier version i had average' :: [(Double, Double)] -> Double
08:11:58 <ardu> lyxia: would that be possible then?
08:12:28 <guillaum2> ardu: it may be possible using typeclass, but that is not usually what you want.
08:12:45 <guillaum2> ardu: they are two different function, so name them differently.
08:13:09 <ardu> okay, that seems reasonable
08:13:22 <ardu> just out of curiousity, how would i do this with typeclasses though? i tried and failed for some reason
08:13:38 <guillaum2> ardu: give me a few seconds ;)
08:13:39 <bollu> berndl: "bollu: you seem to be using pi in two different ways." how so?
08:13:46 <ardu> guillaum2: thanks!
08:15:44 <Hi-Angel> Can I force Prelude to co-exist with XOverloadedStrings in peace? For XOverloadedStrings used, ghc can't distinguish Prelude and Text functions with alike names. If I'm using "import qualified Data.Text as T", I getting "Not in scope: type constructor or class ‘Text". The only solution I come up with is to disable XOverloadedString whatsoever, but it's useless then, perhaps do I miss anything obvious?
08:16:18 <berndl> bollu: you're using pi for the dependent product as well as an inhabitant of the equality type. 
08:17:58 <bollu> berndl: oh right, that should have been "p"
08:18:38 <guillaum2> ardu: http://lpaste.net/345136
08:18:43 <lyxia> Hi-Angel: import Data.Text (Text) ; import qualified Data.Text as T  -- imports the Text type unqualified
08:19:09 <bollu> berndl: could you please hop over to #hott
08:19:14 <guillaum2> ardu: the type annotation (::Double) are mandatory because else GHC cannot distinguish between ambiguous instances...
08:19:21 <bollu> berndl: the same question is being discussed there :)
08:19:33 <Hi-Angel> lyxia: whoa, cool, thank you!
08:20:02 <lyxia> Hi-Angel: otherwise you could refer to Text as T.Text
08:21:24 <ardu> guillaum2: much thanks!!
08:21:27 <Hi-Angel> Ah, it was about types, silly me. I thought it was about something internally used by the extension…
08:22:39 <guillaum2> ardu: but don't do this in real life. Most of the time, naming your function with an explict name is better. Since I realised that, I removed all the function overloading I was doing in C++ in favor of function with more explicit names.
08:25:31 <ardu> guillaum2: that does make sense. by the way, the way i tried doing it earlier was different than the code you posted (i did about instance Averagable [Double] and in the class, average::t->Double), but if i remember correctly the compiler error had FlexibleInstances in it, maybe i should try to revive my old code and it'd work too with that?
08:25:40 <Hi-Angel> I'm wondering btw, why does GHCi asking me to enable view patterns, whilst here https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns said nothing that it's an extension
08:28:14 <jedai> Hi-Angel: It would ask you to enable ViewPattern if you used code that looks like ViewPatterns
08:28:42 <guillaum2> ardu: yes, actually you can make average :: [Double] -> t and write instances for Double and [Double] -> t
08:29:02 <jedai> Hi-Angel: Without your code we can't really judge what triggered it (generally it react to patterns that contain a ->)
08:29:22 <guillaum2> ardu: sorry, for Double and [Double] -> Double. This opposite is not possible AFAIK (t -> Double).
08:29:30 <stalk> hi
08:29:34 <Hi-Angel> jedai: yes, I used ViewPatterns, I just can't understand, is that part of the main language, or not, because from the Wiki it seems that it is, i.e. it mentions nothing about extensions.
08:29:59 <jedai> Hi-Angel: No, it's not part of the main language
08:30:42 <guillaum2> Hi-Angel: You'll have to decide is the "main" language is Haskell 98/2010 or "GHC Haskell".
08:31:01 <ardu> guillaum2: i'm guessing there are some smart reasons why FlexibleInstances is not in haskell by default right?
08:31:17 <jedai> Hi-Angel: The wiki for GHC is mainly to discuss about extension propositions, it is *implicit* there that most page you see about new part of the language are talking about extensions
08:31:37 <stalk> jedai: Hey, I didn't get any answer on my issue question. What do you think I should do?
08:32:09 <jedai> Hi-Angel: they're also not a particularly good reference (sometimes there was change between the proposal and the implementation), it's better to look at the GHC manual
08:32:50 <Hi-Angel> Okay, thank you! The wiki just was the first result for my query in Google ☺
08:33:56 <jedai> stalk: implement the way that is less disruptive, send a PR, then implement the way you really want it and send a PR ? But really do what you want if you have no answer by the current maintainer
08:34:08 <guillaum2> ardu: (The discussion with Hi-Angel is about this exact topic ;). Actually there is a standard Haskell and some extensions implemented by GHC and others compilers.
08:35:08 <ardu> guillaum2: i'm going to try out the code. much thanks again
08:36:20 <stalk> jedai: Yeah, that's actually reasonable :)
08:37:45 <jedai> ardu: FlexibleInstances is probably fine as an extension
08:38:40 <jedai> ardu: It is completely decidable and don't introduce any ambiguities. It just complicate a bit the rules on what is acceptable as an instance
08:38:55 <c_wraith> FlexibleInstances is completely harmless. 
08:40:01 <ardu> thanks, good to know that
08:40:02 <jedai> ardu: Mostly it's accepted anywhere, nobody would refuse code because it used FlexibleInstances, there are extensions that are much more disruptive or disputed
08:40:30 <ardu> so you're saying i need to be careful about what extensions i'm using, but this one is a safe one
08:42:06 <jedai> ardu: Well that depends on your objective. Most extensions are safe but those with Undecidable, Overlapping and so on in their name are generally to be handled with cautiousness.
08:42:27 <ardu> oh
08:43:07 <c_wraith> UndecidableInstances is fine, usually, too. it can't break anything unless you have an infinite type anyway. 
08:43:21 <jedai> ardu: also some extensions make pretty radical changes to what is syntactically possible, then if you want to use your code in a maintained project, using them isn't very well regarded. For your own code there is no such problem of course
08:43:50 <c_wraith> OverlappingInstances or IncoherentInstances, on the other hand.. Those can make your code mysteriously broken. 
08:44:23 <jedai> c_wraith: True... Wasn't there some cases where it could add a lot of time to compilation ? I might remember incorrectly or too long ago.
08:44:53 <jedai> c_wraith: and I forgot IncoherentInstances... Well the name is not particularly inviting ! ;)
08:45:12 <c_wraith> jedai, it can add to compilation time, but in the cases where it does, the alternative is not compiling at all. 
08:45:48 <jedai> c_wraith: I guess that's fine. :)
08:48:43 <ssarah_> what is this supposed to mean? TaggedSet a = TS [(a,[String])]  . I don't get what the TS is supposed to do there.
08:49:00 <hvr> ssarah_: it's a constructor
08:49:09 <jedai> ssarah_: there was probably a data before TaggedSet ?
08:49:18 <jedai> or newtype eventually
08:49:24 <ssarah_> yes, sorry data TaggedSet a = TS [(a,[String])]
08:49:28 <Squarism> Im curious, why is it that haskell doesnt have a proper IDE yet? Hard to construct? Community not big enough to summon the force that is needed?
08:49:54 <hvr> Squarism: define "proper"
08:49:56 <MarcelineVQ> varied opinions on the usefulness of one
08:50:03 <ssarah_> so the TS is a constructor? I thought it would be an alias or something.
08:50:11 <jedai> ssarah: TS is a data constructor, that is TS [(1,[]), (2,["a","b"])] :: TaggedSet Int
08:50:28 <James123> I want to write an algorithm in haskell that finds articulation points. Following the algorithm on wikipedia, if I represent nodes as Int's, I need for each node to keep some information (parent, visit time etc.). Then, I image I need a recursive function, that will take as arguments all the maps I am using to store these data, and it will returns new maps etc. Is there anything more elegant, than 
08:50:34 <James123> having a function that many of its arguments are for updating data?
08:50:40 <jedai> ssarah: it construct value of the type TaggedSet a (where a is a concrete type)
08:51:01 <hvr> Squarism: would you consider http://leksah.org/ a proper IDE?
08:51:05 <Squarism> hvr: expression inspection, navigation, compile error decoration... maybe some refactorings like rename
08:51:17 <jedai> ssarah: also can be used in a pattern. it's like Just and Nothing for the type Maybe a
08:51:24 <Squarism> hvr, idk.. im not able to build it cus my cabal deps are broken
08:51:34 <jedai> ssarah_: hmm are you not ssarah ?
08:52:02 <Squarism> hvr, and my linux dist only have a 4 year old version available
08:52:02 <ssarah_at_office> yep
08:52:02 <hvr> Squarism: also one reason may be is that many haskellers are happy w/ emacs or vim
08:52:09 <ssarah_at_office> better, jedai ?
08:52:24 <hvr> Squarism: or their respective favorite generic editor
08:52:25 <jedai> ssarah_at_office: ok, did you see my anwers ?
08:53:23 <hvr> Squarism: did you try following the instructions at https://github.com/leksah/leksah#building-from-source ?
08:54:06 <sm> Squarism: GHC changes fast, so it's hard to maintain a robust interface for IDEs to get code info with
08:54:14 <Squarism> hvr, yep. i know what the problem is. My cabal deps are broken. Somehow there are deps that depend on 2 versions of the same lib.
08:54:23 <ssarah_at_office> jedai, yep. I think I got it. You know which part of the docs/book has this stuff? Was trying to find it.
08:54:23 <guillaum2> c_wraith: do you think about something different than: http://lpaste.net/345151 . This does not work for reasons explained in the comments and I'm stuck...
08:54:44 <sm> also, general complexity and friction in the haskell tooling ecosystem
08:54:47 <Squarism> sm, oh i see
08:55:14 <sm> right now we have many IDEs that work some of the time. Things are improving
08:55:49 <sm> also, lack of commercial funding
08:55:57 <jedai> ssarah_at_office: Well that depends on the book. As for the docs, I guess you could try to read a part of the Report https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
08:56:04 <sm> but I think that's a lesser reason
08:56:14 <Squarism> hvr, i wont say im an authority on dev tools. But id bet a large portion of java devs use intellij or eclipse and are not eager to change. Those tools just improve your productivy ALOT. 
08:56:22 <jedai> ssarah_at_office: Though that's definitely not a gentle introduction...
08:56:54 <hvr> Squarism: well, there was eclipse support in the past, but its author gave up
08:57:11 <hvr> Squarism: http://eclipsefp.github.io/
08:57:20 <ssarah_at_office> ;_;
08:57:37 <jedai> ssarah_at_office: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
08:58:00 <jedai> ssarah_at_office: that's definitely more of an introduction... :-)
08:58:38 <MarcelineVQ> alternatively http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
08:59:44 <ssarah_at_office> Thanks guys
09:01:05 <c_wraith> guillaum2: close..  http://lpaste.net/345152
09:01:46 <c_wraith> guillaum2: The trick doesn't work once you introduce binders, though.  So I'm not sure how useful it is.
09:03:19 <sphinxo> is it possible to compose (+) and (+3) ? 
09:03:41 * hackagebot html-parse 0.2.0.0 - A high-performance HTML tokenizer  https://hackage.haskell.org/package/html-parse-0.2.0.0 (BenGamari)
09:04:22 <c_wraith> sphinxo: sure, but you need to be a bit careful with the types
09:04:33 <c_wraith> @pl \x y -> x + y + 3
09:04:33 <lambdabot> flip flip 3 . ((+) .) . (+)
09:04:47 <kadoban> Haha
09:05:13 <c_wraith> lovely day for pl to live up to it's name, eh?
09:05:35 <kadoban> sphinxo: It goes better if you have another combinator to work with, like (.:), but that's not too common.
09:05:56 <kadoban> With just (.) it's ... probably not worth it.
09:06:02 <jedai> guillaum2: I think I don't understand your types here. Why is Add :: Ast a -> Ast b -> Ast c ? Shouldn't it be Ast Int -> Ast Int -> Ast Int or (Num n) => Ast n -> Ast n -> Ast n ?
09:06:16 <sphinxo> foldl ((+) . (+3)) 0 [1,2,3,4] ; so this seems to work
09:06:40 <c_wraith> jedai: my lpaste shows what I initially described and what guillaum2 was trying to implement from my description
09:09:00 <jedai> c_wraith: Ok, I just don't understand exactly why this is used here. Well this is certainly an interesting trick (the ST trick). :)
09:09:42 <c_wraith> jedai, it prevents eval from being called on any AST that includes a Var constructor. 
09:10:41 <bollu> @pl \x y -> x + y
09:10:41 <lambdabot> (+)
09:10:46 <bollu> @pl \x -> x + 3
09:10:47 <lambdabot> (3 +)
09:10:49 <bollu> hm
09:11:41 <jedai> c_wraith: Right, thank you, I found the thread back up in the channel. Well I guess the trick is generally useful and this is just the beginning in its implementation of his language. :)
09:11:54 <c_wraith> @pl \x y -> x + (y + 3)
09:11:54 <lambdabot> (. (3 +)) . (+)
09:12:04 <c_wraith> hey, that's more sane. 
09:12:15 <bollu> I don't find that intuitive at akk
09:12:17 <bollu> all*
09:12:22 <c_wraith> it's not. 
09:12:33 <c_wraith> I wouldn't include it in code I write. 
09:12:51 <c_wraith> but at least it doesn't start with flip flip 3
09:13:00 <jedai> I would posit that c_wraith's "sane" was a tad ironic...
09:13:21 <c_wraith> not ironic, just relative. 
09:13:39 <jedai> c_wraith: I love the original more though (relatively :)
09:15:44 <sm> Squarism: by the way, if you want to help, alanz's haskell-ide-engine seems a good place
09:18:03 <Squarism> sm, i just might do that. 
09:23:43 <ertes> what's a good short word for "not recursive"?  "flat"?
09:24:32 <ezyang> "nonrecursive" ;) 
09:26:08 <c_wraith> anyone around who understands pi types? I want to see how badly I have simplified them in my head. :) 
09:26:54 <ertes> c_wraith: shoot
09:27:14 <ertes> ezyang: i was hoping for something shorter/catchier =)
09:27:15 <c_wraith> my impression is that they're type variables that the compiler automatically reflects down to values that can be used at runtime. 
09:28:20 <ertes> c_wraith: a "pi type" is actually just a regular function type that binds the *value* at the type level…  haskell's 'forall' is a special case of that
09:28:34 <lyxia> ertes: "boring" :P
09:28:57 <c_wraith> ertes, hmm. I must be thinking of pi-quantified type variables. 
09:29:29 <ertes> forall (a :: Type). …  -- let me assume -XTypeInType, then 'a' is of type Type, and you have access to 'a' on the right hand side of the "."
09:29:36 <ertes> lyxia: "boring folds" =)
09:30:12 <ertes> c_wraith: pi types generalise this to things that are not of type Type, in particular concrete types like Integer
09:30:16 <c_wraith> ertes, though what you described is the opposite direction of what I described. 
09:31:33 <ertes> c_wraith: forall (x :: Integer). F x  -- if haskell were dependent, this would be a "pi type", and in fact (->) would become the same thing as 'forall' semantically
09:31:49 <ertes> c_wraith: did that answer your question?
09:32:58 <c_wraith> I can't tell. I was thinking about the DependentHaskell paper, and trying to figure out what I can and can't do with pi types as described in the paper. 
09:33:47 <ertes> c_wraith: i'm not familiar with the syntax they use, so i'll just make syntax up, and it's up to you to translate it =)
09:34:21 <ertes> f1 :: Bool -> Integer  -- regular haskell type
09:34:52 <ertes> f2 :: (x :: Bool) -> Integer  -- now the function f2 has access to the value 'x' of type Bool as well as everything to the right of (->)
09:35:18 <ertes> f3 :: (x :: Bool) -> if x then Integer else String  -- which in turn would allow something like this
09:35:26 <ertes> f3 True = 15
09:35:31 <ertes> f3 False = "blah"
09:35:55 <ertes> something of the form ((x :: A) -> B x) is a pi type
09:36:45 <c_wraith> not used to thinking with TypeInType enabled. :) 
09:37:20 <c_wraith> so when A = Type, that's just a standard haskell function? 
09:38:06 <ertes> well, it's a bit more complicated in *standard* haskell, because you can't really bind *types* that way
09:38:24 <ertes> you would have to use forall, which is *essentially* the same thing, but does not give the value level access to the thing
09:38:51 <c_wraith> ok, now I think you're saying what I tried to say at the start 
09:39:06 <ertes> forall (x :: Type). B x  -- regular haskell "function" (it's really only a function in core, or if you have -XTypeApplications enabled)
09:39:53 <c_wraith> I think I've got the right intuition, but with no education in the topic to make consequences clear. 
09:40:22 <ertes> i recommend doing a few basic things in a dependently typed language like agda or idris =)
09:41:06 <ertes> example: the identity function in agda might have the following type
09:41:16 <ertes> id : (A : Set) -> A -> A
09:41:35 <ertes> where Set corresponds to standard haskell's "*" or -XTypeInType's "Type"
09:42:09 <ertes> unlike in haskell you can clearly see that 'id' is actually a *family* of functions, one for every type
09:42:25 <c_wraith> does A in that example get inferred in general in dependent languages? 
09:42:40 <ertes> but more interestingly this uses the dependent function arrow to bind 'A' at the type level
09:42:52 <ertes> yeah, as far as possible
09:42:53 * hackagebot soap 0.2.3.2 - SOAP client tools  https://hackage.haskell.org/package/soap-0.2.3.2 (AlexanderBondarenko)
09:43:27 <ertes> if x : ℤ, then (id _ x) works
09:43:52 <ertes> or you can tell agda to make the argument implicit by using special syntax:  id : {A : Set} -> A -> A
09:45:01 <ertes> the interesting part is that the 'A' is available on both the value and the type level:  id A x = x  -- you just ignore the A
09:45:56 <c_wraith> yeah, dependent haskell adds syntax for binding pi-quantified type variables at the value level. 
09:46:36 <ertes> but more importantly those don't have to be *type* variables =)
09:47:10 <c_wraith> hmm. that distinction makes more sense in Agda, I think. 
09:48:00 <c_wraith> dependent haskell is an expansion of DataKinds, where your values can be types, but there is still a distinction between them. 
09:52:18 <ertes> c_wraith: you may be interested in sigma types, too, which are dual to pi types
09:52:32 <ertes> where (->) is a special case of pi types (,) is a special case of sigma types
09:52:50 <ertes> the idea is that the second component's type can depend on the first component's value
09:53:23 <ertes> in logic pi types are universal quantification, and sigma types are existential quantification
10:01:46 <c_wraith> ok, I think I sorted out the first hints of understanding of sigma types.. but I have no idea where I'd use one. 
10:04:24 <berndl> c_wraith: you can use it for subtyping.
10:04:42 <c_wraith> ah. OK, that makes sense. 
10:04:46 <berndl> In fact, you can use sigma types to encode any structure.
10:09:39 <guillaum2> c_wraith: thank you for your code example. I missed the fact that because all Ast (except the Var one) are parametrised by "t", Add can be written as : Add :: Ast a -> Ast a -> Ast a. I thought that it forces the two branch to have the same parameter 'a', and actually it is the case, however we don't care because t can be (). (That's difficult to understand, but, well, you understood it, so I'm just 
10:09:46 <guillaum2> writting this to convince myself that I understood ;)
10:10:15 <c_wraith> guillaum2, yes, it sounds like you do see why it works. 
10:11:08 <c_wraith> guillaum2, I'm not sure it's really useful, though. at least, for your case. it will break down if you ever add a way to bind a variable. 
10:11:39 <guillaum2> c_wraith: what do you mean by bind a variable ?
10:12:07 <c_wraith> guillaum2, if you ever allow functions or let bindings 
10:14:04 <guillaum2> c_wraith: you mean, in my mini language ? I don't see why it will break, but, well, I'll find it soon ;)
10:14:30 <c_wraith> that's definitely the best way to learn 
10:16:39 <ssarah_at_office> I'm trying to figure out a good way to remove a key from  a set map [(a,[String])] without having to rebuild the whole thing. I can use data.list functions. 
10:16:58 <guillaum2> (Todo learning experiment were : what are the uses cases for GADTs. Finally I played with recursion-scheme, GADTs, tagless final representation and existential quantifiers, that's nice..., but I'm still out of interesting application of GADTs for day to day work. It recalls me about metaclass in Python. I was excited when I discovered them, and ten years later, I still finding an interesting use case 
10:17:04 <guillaum2> for them ;)
10:17:06 <ssarah_at_office> Nothing good occurred to me yet.
10:17:21 <c_wraith> ssarah_at_office, haskell data structures are immutable. you always will have to recreate at least some of it. 
10:18:17 <guillaum2> ssarah_at_office: if Set are implemented using tree, you are only rebuilding log n elements.
10:19:32 <guillaum2> ssarah_at_office: I highly encourage you to write your own Set type (using simple binary tree, don't focus on balancing) just to understand the concept involved. Diving into persistant / immutable data structure is really interesting.
10:19:54 <EvanR> log n, with which base!
10:20:33 <ssarah_at_office> guillaum2, can't, school assignment. Type is fixed. Will just go through the set recursively.
10:20:35 <EvanR> its interesting how much of a practical difference the base makes, 2 vs 16
10:21:00 <EvanR> for [(k, [String])] you dont have to rebuild the whole thing either
10:21:07 <c_wraith> EvanR, all bases are the same in big O analysis. for logs. not exponents. :) 
10:21:38 <EvanR> right all bases are the same, and everything weve ever done is O(1) because finite computer
10:22:04 <c_wraith> yep. 
10:22:06 <EvanR> and finite history so far
10:22:56 <byorgey> c_wraith: EvanR did explicitly say "*practical* difference".
10:23:34 <guillaum2> EvanR: the containers library does not say about the base in the documentation. The unordered container says 16 ;)
10:23:58 <EvanR> > logBase 2 1000000000
10:24:00 <lambdabot>  29.897352853986263
10:24:02 <c_wraith> computers are just wastes of time. nothing practical will ever come of them. :) 
10:24:05 <EvanR> > logBase 16 1000000000
10:24:08 <lambdabot>  7.474338213496566
10:24:50 <EvanR> > 29.897352853986263 / 7.474338213496566
10:24:51 <lambdabot>  4.0
10:24:58 <EvanR> 400% !
10:25:12 <c_wraith> only 300% faster 
10:25:15 <guillaum2> EvanR: * O(MemoryAccesPattern Which Sucks Because Pointer Chassing) ;)
10:25:59 <EvanR> when will be awaken from the carefully selected cache usage nightmare
10:26:40 <kadoban> When we start using better models, I guess?
10:27:56 <c_wraith> nah, just switch to processors without cache. fixed! 
10:28:42 <EvanR> yeah then everything always runs at full speed
10:29:09 <EvanR> tallest poppy engineering
10:37:55 * hackagebot retry 0.7.4.2 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.4.2 (MichaelXavier)
10:45:49 <lexi-lambda> Does anyone know if there already exists some package that provides a way to convert between haskell-src-exts types and their template-haskell equivalents?
10:46:26 <lexi-lambda> I’m currently writing some code that will convert haskell-src-exts types to template-haskell ones, and it certainly feels like something that someone must have done before.
10:47:40 <geekosaur> I thought that already existed somewhere
10:47:41 <pavonia> haskell-src-meta, IIRC
10:48:02 <geekosaur> right, that
10:49:09 <lexi-lambda> Oh, perfect, that looks like exactly what I was looking for. :)
10:52:30 <the_2nd> are there any decent machine learning libs? I looked at HLearn, but this seems kinda dead
10:52:56 * hackagebot trifecta 1.6.1 - A modern parser combinator library with convenient diagnostics  https://hackage.haskell.org/package/trifecta-1.6.1 (ryanglscott)
10:57:56 * hackagebot rebase 1.0.4 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.4 (NikitaVolkov)
11:06:04 <michael[m]1> the_2nd: there's nothing nice like scikit-learn, but there is some good stuff useful for machine learning
11:06:20 <ssarah_at_office> Where do you put the instances in a module structure? I'm getting parse error on input instance
11:06:42 <michael[m]1> ad library is a very good automatic differentiation library so enables lots of other good stuff
11:07:02 <michael[m]1> monad-bayes is a good probabilistic programming library (probabilistic programming enables implementation of lots of other good models)
11:09:36 <michael[m]1> there's some other stuff too, neural looks decent but still pretty early
11:10:40 <michael[m]1> basically as usual in haskell, there are lots of very difficult problems with extraordinarily high quality and elegant solutions, but all the packages to just do easy machine learning are immature and unpolished
11:11:05 <the_2nd> michael[m]1, could I use some python lib for the training and use the weights in haskell?
11:11:43 <michael[m]1> the_2nd: what problem specifically do you want to solve
11:12:16 <the_2nd> michael[m]1, currently I want to classify urls with likeliness to being a certain link type
11:12:54 <the_2nd> e.g. how likely is it, that domain.com/funnyCat.bmp is a picture of a cat
11:13:43 <michael[m]1> https://github.com/brunjlar/neural
11:13:56 <michael[m]1> there's some examples there of training simple classifiers
11:14:54 <michael[m]1> for just training a classifier HLearn will probably also work fine
11:16:16 <michael[m]1> personally i wouldn't worry too much about using a dead library. should be possible to design things so you can switch to something else easily
11:16:37 <michael[m]1> this kind of classification is like the classic ml problem so you shouldn't be too locked in
11:17:18 <michael[m]1> https://github.com/tweag/HaskellR seems to be active but i don't know much about it
11:24:51 <needHelpHaskell> hey guys can somebody take a quick look at this: http://pastebin.com/B3eVCyF7 , I have included the error message on the bottom
11:25:44 <the_2nd> michael[m]1, thanks for the help, I'll take a look at those
11:29:10 <Cale> needHelpHaskell: The problem is that some of the cases of that function's definition produce a value of type Stack a (specifically, NoStk), when they should be producing a value of type a (or just an error, it's not possible to produce a legitimate value of type a in those cases)
11:29:10 <monochrom> needHelpHaskell: So your code is basically saying, top (Stk ['x', 'y']) = 'y', but top (Stk []) = NoStk? So 'y' and NoStk are of the same type?
11:31:53 <Cale> Also, that third case is a little bit fishy
11:32:10 <Cale> It's really weird to use last and init like that, rather than having the stack go the other way
11:32:10 <needHelpHaskell> how would I fix that?
11:32:16 <needHelpHaskell> I want to return a NoStk
11:32:20 <monochrom> yeah top (Stk ['x']) is not covered but that's for tomorrow
11:32:21 <Cale> last is an O(n) operation -- it has to walk down the whole list to find the end
11:32:51 <Cale> while you've already pattern matched off the start of the list in that case -- that should be regarded as the top, most likely
11:33:23 <Cale> That'll make all your operations O(1) rather than O(n) like they currently are
11:33:24 <monochrom> If your type sig is "Stack a -> a" there is no way you can return NoStk.
11:33:37 <needHelpHaskell> i cant change the signature :/
11:33:46 <monochrom> You cannot have both. I don't care about want. You have to give up one.
11:34:00 <Cale> Well, you can just give an error in the empty cases
11:34:05 <needHelpHaskell> Cale: I'll ask later but i think the top of the stack is the end of the list
11:34:08 <monochrom> Well, it doesn't matter what I care. But the computer doesn't care about your want either.
11:34:14 <Cale> It's also a little weird that there's a distinction between NoStk and Stk []
11:34:40 <Cale> needHelpHaskell: You can do that, it'll just make everything way slower than it needs to be.
11:34:50 <needHelpHaskell> I get your point
11:34:54 <monochrom> If this is homework, you will have to ask what should top does to empty stacks.
11:35:03 <Cale> (and more annoying to write)
11:35:46 <needHelpHaskell> top returns NoStk if called with an empty stack
11:35:55 <needHelpHaskell> or should return
11:36:05 <monochrom> Again, that is in conflict with "Stack a -> a".
11:36:32 <needHelpHaskell> yup
11:36:37 <monochrom> The homework is wrong or you read it wrong.
11:36:53 <monochrom> Experience shows that the latter has 78% chance.
11:36:58 <needHelpHaskell> i can paste the assignment if you know german
11:37:15 <monochrom> Someone is bound to know German.
11:37:26 <codygman_work> I tried using binary-serialize-cbor for a few gigs of data, but it takes 1m30s. Is there a way to just read the data into memory and say that serialized data is a certain type with no processing?
11:37:46 <needHelpHaskell>  Angewendet auf einen nichtleeren Stack s, liefert die Funktion top den Wert des obersten Eintrags von s; angewendet auf den leeren Stack oder den Fehlerwert NoStk, liefert sie den Wert NoStk.
11:38:48 <codygman_work> It looks like this might be what i want: https://hackage.haskell.org/package/hmatrix-mmap-0.0.5/docs/Data-Packed-Vector-MMap.html
11:38:49 <needHelpHaskell> Tranlsates to: Used on the non empty stack s, the top function returns the uppermost entry in s; used on an empty stack or on the error value NoStk, it returns NoStk
11:39:44 <monochrom> No, the whole assignment please.
11:39:48 <needHelpHaskell> ok^^
11:40:24 <needHelpHaskell> http://www.complang.tuwien.ac.at/knoop/lehre/ws1617/fp185A03/fp_lu06_161123.pdf
11:41:33 <monochrom> It can't be done. Challenge your teacher to solve it.
11:41:44 <monochrom> Tell them "monochrom says so"
11:41:59 <needHelpHaskell> allright ill include a screencap
11:42:05 <needHelpHaskell> : ^)
11:42:15 <needHelpHaskell> thanks anyways
11:42:19 <needHelpHaskell> for the help :)
11:44:11 <GhostedG> Hi there, I tried posting this in haskell-beginners but I had no luck. I am writing some code in order to check whether one node is reachable from another in a digraph. However, I currently run into infinite loops whenever a cycle is present. Is there any way to choose between which node is traversed if a node has more than one node connected to it??
11:44:40 <monochrom> Vienna Techincal University?
11:44:46 * geekosaur wonders if the point of the exercise is to get the student to try, and to work out why it doesn't work
11:45:16 <MarcelineVQ> maybe it's literal: Stack [] or NoStk resulting in `error "NoStk"`
11:45:37 <GhostedG> Different university, but yes this is part of an assignment
11:46:02 <GhostedG> I was thinking of including something to track the nodes that have already been visited, but this doesn't seem to be part of the Haskell ethos.
11:46:44 <ezyang> GhostedG: Definitely a downside of pure graph representations 
11:46:48 <monochrom> Oh I was referring to the tuwien.ac.at URL
11:46:57 <ezyang> if you have a unique label per node, just keep a set of visited ones 
11:47:13 <kadoban> GhostedG: Are you using a particular library, or representation? It's a bit unclear to me.
11:47:15 <needHelpHaskell> yes monochrom  Vienna University of Technology
11:48:12 <GhostedG> we aren't allowed to use any libraries for this assignment, so I represented the Nodes as data: Node = Node Char [Node]
11:48:25 <monochrom> yeah GhostedG it would be great if you could post the complete assignment so no one has to guess.
11:48:58 <GhostedG> Give me a sec, I'll drop it here
11:49:23 <kadoban> GhostedG: And which algorithm are you using to check reachability? You probably should just keep track of which ones you've visited and make sure you don't visit them more than once.
11:51:15 <NatureShade> You could also map a function over all connected nodes removing the node you are on
11:51:40 <GhostedG> https://gyazo.com/f60679671e9dbd9bdba9cdabe6887797
11:52:13 <monochrom> this is so small
11:52:19 <GhostedG> hang on, that didn't scale properly
11:53:37 <EvanR> yes you have to remember which nodes you visted
11:53:46 <EvanR> its not against haskell ethos
11:54:22 <EvanR> also ethos is a strong word
11:55:54 <zipper> Hello, I want to say that a and b are to be of typeclass say Arbitrary but I don't want to write (Arbitraty a, Arbitrary b) how do I shorten this? 
11:56:25 <monochrom> you can turn on 10 extensions and then you can shorten it
11:56:34 <GhostedG> Ok that took a while, https://gyazo.com/9bfd4b1803b2aeba544a0617436a8e07
11:56:56 <EvanR> thats one reason why i dont like using lots of constraints
11:57:58 * hackagebot uri-bytestring 0.2.2.1 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.2.1 (MichaelXavier)
11:58:45 <monochrom> GhostedG: I think you are meant to assume that each node has a different Char field, and therefore you can use that to identify nodes and do your BFS or DFS.
11:59:05 <monochrom> Because the only other alternative is pointer equality, but you don't have it in Haskell
11:59:28 <GhostedG> monochrom: Thank you! I'll most likely make a list of visited nodes then :)
11:59:47 <monochrom> The meta-level comment is that no one really represent a graph this way in Haskell.
12:00:07 <NatureShade> I thnk this whould work?  removeThis x@(Node a _) = removeA a x where removeA a (Node b xs) = Node b . map (removeA a) $ filter (\(Node c _) -> a /= c) xs
12:01:59 <GhostedG> monochrom: I think this assignment is meant for us to learn to use higher-order functions
12:02:59 <GhostedG> NatureShade: Thanks a ton for your response! Let me implement this into what I already have and get back to you 
12:05:44 <EvanR> quick, how do you make an unordered pair type
12:06:13 <sphinxo>  /quit
12:06:18 <sphinxo> oops
12:06:51 <monochrom> what is an unordered pair type? what are its operations and laws?
12:09:53 <EvanR> heres one
12:10:45 <EvanR> if i have an unordered pair containing x and y, then i can get an unordered pair of (x,y) and (y,x), two ordered pairs of the contents
12:11:29 <monochrom> What is the type signature of this operation?
12:12:33 <EvanR> to be descriptive enough, youd have to index this type with an unordered pair of its two elements!
12:13:54 <EvanR> your question is interesting, but i demand to know if you already know the answer
12:14:12 <EvanR> so i have context
12:14:24 <monochrom> I don't know the answer. Because I don't understand the question until you give types and laws.
12:15:07 <EvanR> if the type is UP a, then the haskelly type would be UP a -> UP (a,a), which doesnt really display any laws
12:15:26 <monochrom> you can write laws separately.
12:15:41 <monochrom> Like I don't have to write "x + 0 = x" as a type.
12:16:02 <monochrom> I don't have to write "fst (a,b) = a" as a type.
12:16:08 <monochrom> Who does, actually?
12:16:29 <EvanR> youd put something like that in the dependent record of laws
12:16:43 <EvanR> but in any case, it looks like youre expecting laws to be written in some way
12:16:46 <monochrom> Speak for yourself. I would not.
12:17:11 <EvanR> and everything written down has an explicit ordering
12:17:22 <monochrom> It's OK if you write in dependent types. I could read them even though I wouldn't write them.
12:18:03 <monochrom> It's also OK if you keep writing essays that would get an A+ from an essay teacher. I could simply look away.
12:19:11 <EvanR> is my law bogus? or what
12:20:54 <monochrom> the type "UP a -> UP (a,a)" contradicts with the specification "get an unordered pair of (x,y) and (y,x)"
12:21:26 <EvanR> get an unordered pair whose two elements are (x,y) and (y,x)
12:22:04 <monochrom> Or maybe not. Is x::a true? Is y::a true?
12:22:10 <EvanR> yes
12:22:51 <heath> Joe Armstrong & Alan Kay - Joe Armstrong interviews Alan Kay https://youtu.be/fhOHn9TClXY?t=3687
12:22:59 <heath> Alan Kay: I mentioned the Situations, Actions, and Causal Laws thing, because I think McCarthy was getting at one of the prime cruxes in computing which is that you want to be able to advance state, and you need to do it absolutely safely. So, you'd like to be able to reasonably perfectly about how you're going to advance the state, and you'd like to organize the system so that you get the best of both 
12:23:05 <heath> worlds. Monads is too much of a kludge. That's trying to save functions and missing what McCarthy had already gotten to more than 50 years. That kind of stuff drives me crazy, it really does. It's like, where did you people come from? How blind can you be? Why are you treating this like a religion? Well, Bob Barton, the great computer designer, I had him as a professor, one of the things he used to say is, 
12:23:11 <heath> "systems programmers are a high priest of a low cult."
12:23:17 <monochrom> I still don't understand "if i have an unordered pair containing x and y, then i can get an unordered pair of (x,y) and (y,x), two ordered pairs of the contents"
12:23:41 <heath> i think alan kay may have bashed the haskell ecosystem?
12:23:48 <monochrom> Because I am wonder if "UP a -> UP (UP a)" fits that sentence better
12:24:06 <geekosaur> probably. but then alan kay's preferred ecosystem is not decidable, and can't actually promise safety
12:24:10 <monochrom> You know what, I hate natural language.
12:24:16 <heath> haskell is a tool like any other language and it excels at certain tasks. who's treating it like a religion? 
12:24:17 <MarcelineVQ> you get more people in here daily bashing it than that, I wouldn't make a thing out of it
12:24:32 <heath> i don't understand the bashing, and i'm curious what some of you think
12:24:39 <monochrom> Specify some accessor functions so you can actually write laws like "fst (a,b) = a" (the accessor here being fst)
12:24:41 <EvanR> i put the ordered pairs in there on purpose, since i intuitively thought wed want to recover ordering somehow for practical purposes
12:25:29 <EvanR> that accessor wouldnt make sense... so ill come up with something clever
12:26:22 <monochrom> Sure. You will need some kind of accesor, not necessarily fst but still something. You know that?
12:26:31 <NatureShade> GhostedG: reachable (Node a as) b@(Node b' _) | a == b' = True | null as = False | otherwise = any ((`reachable` b) . removeA a)  as
12:26:46 <monochrom> Because without accessors, "date UP a = Done" does it.
12:26:51 <EvanR> you need an induction principle
12:27:04 <monochrom> Sure. Write one.
12:28:40 <monochrom> I would really love to answer every question on Stack Overflow of the form "how do I represent such-and-such abstract data type?" by "data Foo = Done because you haven't specified any accessor, you have only specified a name"
12:29:15 <EvanR> i see how that satisfies my law as is
12:29:39 <EvanR> so its bogus 
12:30:53 <EvanR> it could be like the IO type, no accessors, just continuing inside the same unordered context
12:31:46 <monochrom> But IO's point is not data, it's effects. So you give effect-system laws rather than dependent types.
12:32:08 <monochrom> Look for Nancy Lynch and I/O automata.
12:32:40 <monochrom> Whereas I doubt that "unordered pair"'s point is effects not data.
12:33:22 <EvanR> what the point is, is an interesting question!
12:35:37 <EvanR> i see ordering has nothing to do with ordered pairs, just that you have two distinct indexes
12:36:22 <monochrom> yes but two indexes, or even just the number "two" itself, is an ordinal, so that's where your "order" comes from
12:36:24 <NatureShade> You want the same index to refer to both values?
12:36:40 <EvanR> no
12:38:01 <monochrom> for a mathematician (set theory) kind of "unordered pair", i.e., a set like {x,y}, you could specify queries like "elem x {x,y} = True", "elem y {x,y} = True", etc
12:39:50 <EvanR> makes sense
12:42:20 <EvanR> so it would be a conceptually a predicate, and so a contrafunctor
12:42:40 <EvanR> and a regular functor
12:44:51 <chpatrick> is there something better than Read that I can get with TH/Generic?
12:44:55 <chpatrick> in terms of error messages
12:49:09 <lyxia> Do you mean an alternative implementation of Read, with better error messages, but same semantics otherwise?
12:49:51 <chpatrick> lyxia: yes
12:52:40 <EvanR> ok. so the law would be, you define a function from UP a -> B by giving a mapping f : a -> a -> B, which satisfies the law f(x,y) = f(y,x)
12:52:55 <lyxia> chpatrick: Never heard of such a thing :/
12:53:07 <EvanR> it respects unordering
12:54:22 <EvanR> which precludes an fst-like accessor, since that clearly doesnt satisfying that
12:54:40 <EvanR> basically you cant use just one of the elements
12:56:05 <EvanR> you also cant get an ordered pair or list of elements, so its not foldable
12:56:28 <EvanR> very nice ;)
12:56:47 <verement_> What could this be useful for?
12:57:00 <EvanR> i think it has actual use
12:57:05 <lyxia> you have a very alien concept of niceness
12:57:38 <EvanR> in web programming you often are in a position where someone gives you a pair, or a record of fields, and they tell you (or forget to tell you) not to depend on the ordering
12:57:58 <EvanR> its possible to actually follow that rule and get work done
12:58:00 * hackagebot bloodhound 0.12.0.0 - ElasticSearch client library for Haskell  https://hackage.haskell.org/package/bloodhound-0.12.0.0 (MichaelXavier)
12:58:21 <EvanR> its also possible to screw up and chew the asphalt when things come crashing down
13:01:12 <EvanR> i dont know if its practical to define it as a datatype though
13:01:16 <verement_> It sounds like a keyless associative array… how do you access the elements?
13:01:30 <EvanR> you have to use the induction principle
13:01:52 <EvanR> you have to use a commutative operation
13:02:02 <byorgey> verement_: you can sum them, you can find the max, you can generate a sorted list of them.
13:02:15 <verement_> OK
13:02:42 <EvanR> nice i didnt think of that! 
13:03:36 <byorgey> EvanR: UP is also known as the species E_2  =)
13:04:10 <EvanR> what arcane subject is that from
13:06:09 <byorgey> From combinatorics.  google "combinatorial species".
13:06:13 <EvanR> ah
13:07:09 <monochrom> you probably end up using (a,a) as implementation
13:08:05 <monochrom> for best results, throw in an "unsafePerformIO randomize order" to really confound any attempt at guessing your internal order.
13:08:27 <EvanR> haha
13:08:38 <EvanR> yes!
13:09:37 <EvanR> stupid tricks you can do when stuff follows laws
13:12:37 <Cale> E is for ensemble I suppose because a lot of the people doing stuff with combinatorial species happen to be French speakers
13:14:38 <cheater> is there a stack with a monadic interface? something that would e.g. have the following monadic actions: push :: a -> Stack (), pop :: Stack a, collapse :: (a -> a -> a) -> Stack (), produce :: ([a] -> a) -> Stack () -- the last two collapse the top two elements of the stack, and produce a new element given the existing stack, but any other APIs are fine too..
13:15:09 <Cale> cheater: You can just use StateT with a list as the state
13:15:15 <Cale> or State itself
13:15:38 <cheater> Cale: i'm looking for something that's got a fairly stack-like interface..
13:16:01 <cheater> you know, the kind of feel you'd get when working in assembler
13:17:49 <cheater> using State or StateT with a list might be a good idea for small things, because it will only ever allocate one more element when mutating, and the rest of the list gets shared from the old version of the state
13:17:49 <EvanR> you would write the push and pop operations on top of that
13:17:56 <cheater> yeah EvanR
13:18:00 <Cale> push v = modify (v:); pop = do { (v:vs) <- get; put vs; return v }; collapse f = do { (u:v:vs) <- get; put (f u v : vs) }
13:18:02 <Cale> etc. etc.
13:18:25 <Cale> Note that this doesn't really cope very well with stack underflow
13:18:47 <cheater> i'm just worried what might happen when you start pushing and popping a whole lot of times, or if you need to efficient access to the stack (e.g. worries about locality etc)
13:18:50 <cheater> sure Cale
13:19:35 <EvanR> this is the most efficient possible use of the immutable boxed data paradigm
13:19:39 <EvanR> i think
13:19:46 <EvanR> drop or allocate a single node
13:19:56 <Cale> I also feel like mentioning my category-printf library, lol: https://hackage.haskell.org/package/category-printf-0.1.1.0/docs/Control-Category-Printf.html
13:20:07 <Cale> which has stack-language-like behaviour
13:20:11 <Cale> See the examples toward the end
13:20:47 <Cale> It's related to the continuation-style stack manipulation that one can do... let me dig something up
13:21:20 <Cale> http://lpaste.net/99230
13:22:33 <Cale> You can write, e.g.  start push 1 push 2 add end
13:22:36 <Cale> and it'll evaluate to 3
13:22:55 <maerwald> types look too weird to me.
13:23:08 <Cale> yeah, the types get really crazh
13:23:11 <Cale> crazy*
13:23:14 <maerwald> for something as simple as printf I don't want to learn CT
13:23:19 <Cale> Oh, the printf thing
13:23:35 <Cale> The types in the printf thing are actually understandable if you take a moment
13:23:49 <monochrom> IIRC this is the kind of examples that pushes type inference to become exponential time.
13:24:13 <maerwald> I'd probably just use unsafe printf instead for simplicity sake
13:24:14 <monochrom> Okasaki came up with this kind of things first and reported "took GHC several minutes"
13:24:19 <Cale> The idea there is that something of type  Format m a b  is something which is going to write a string of type m, while changing the type of printf from a to b
13:24:56 <maerwald> I don't know what a Cokleisli is and the error messages will require me to do so
13:25:05 <maerwald> rattle snake incoming
13:25:26 <Cale> You can mostly ignore the particulars of what Cokleisli is
13:25:39 <maerwald> that's what people say about lens too :P
13:25:44 <Cale> and just understand Cokleisli ((->) m), which is why the synonym
13:25:51 <Cale> I could have made that a newtype
13:30:26 <EvanR> maerwald: theres a funny application of dependent types in idris for printf... if you have a function inputTypes : String -> [Type], which produces types by straight up parsing the format string... then printf is as simple as : (format : String) -> inputTypes format -> String. its sort of the kind of thing youd expect to see is python or ruby!
13:30:48 <James123> In a C version of a program, I would have: int parent[MAX]; int dfs_time[MAX], bool visited[MAX]. In a haskell version, what would you recommend? I was thinking a map of Int keys (each node is represented by an Int) and tuples as values (Int, Int, Bool). Is this ok?
13:31:32 <maerwald> EvanR: I know, I've watched the video
13:31:50 <EvanR> whenever i see something ruby wouldve pulled, i question whether anyone can be against it for being too complex
13:32:16 <EvanR> because if we were against too complex, ruby wouldnt have to exist
13:32:50 <ggVGc> EvanR is too complex, but wer're not against him
13:34:09 <maerwald> EvanR: I think KISS is not a widely accepted concept in haskell, so people probably won't mind to add complexity, as long as it follows very strict rules
13:34:54 <maerwald> and I doubt haskell would be so great if it were otherwise, but there's clearly a conflict at some point
13:35:21 <EvanR> i have my blinders on when haskell gets too complex
13:35:29 <EvanR> nah nah nah not looking
13:35:32 <maerwald> lol
13:50:19 <cheater> damn Cale that's a pretty cool printf like thing
13:50:36 <cheater> but i'm not sure why this is stack-like at all
13:51:28 <Cale> cheater: Well, the stack is the stack of remaining arguments
13:51:42 <monochrom> Surely KISS is widely accepted in the Haskell community. Keep it simple and smart. :)
13:52:11 <maerwald> monochrom: you switched some wording there...
13:52:18 <maerwald> and yes, I _hate_ smart code
13:53:01 <maerwald> smart algorithms? ok. smart language features? if they are properly high-level
13:53:07 <maerwald> smart code? gtfo
13:53:40 <monochrom> there is "simple" there to keep "smart" in check.
13:54:27 <maerwald> that's a misconception imo
13:54:37 <cheater> Cale: gotcha
13:57:24 <monochrom> You probably weren't here when the people in #haskell showed how the "simple" part really kept the "smart" part in check, so much so that a lot of smartness didn't pass.
13:57:58 <maerwald> "smart" as a principle is just wrong on all levels. If a solution requires a high amount of smartness (the solution, not the problem solving), then fine... but it's not something to be proud of, because you were unable to come up with something simpler. Simplicity is the real genius.
13:58:28 <maerwald> and because of that, including smartness as a principle is bad
13:58:40 <maerwald> it's something to _avoid_
13:59:00 <EvanR> and my funny original operation would be definable as ind (\x y -> UP (x,y) (y,x)). and i see how you could defined instance Ord a => Ord (UP a)... so we have Sets of them... huzzah, back to being able to represent a dumb, undirected, (non-multi-)graph
13:59:30 <monochrom> The incident was there was a prof somewhere in California who gave out a very advanced assignment to very beginning students. Many students of that class came here to ask for help, and so we were honoured with a chance of enjoying a dailywtf level assignment design.
14:00:26 <maerwald> if programming becomes intellectual self-indulgence, then we have a problem
14:01:21 <monochrom> The assignment defined the mother of all higher-order functions for list traversals. It had like 5 parameters (for 5 functions you plug in). By plugging in the right 5 things, you can recover all of map, reduce, mapreduce, foldr, foldl, and more.
14:01:33 <EvanR> you had a problem with pythagorases cult?
14:02:08 <monochrom> The assignment question was to have the students think up what to plug in to get map, filter, foldr, etc.
14:02:10 <maerwald> also, I thought we were in -offtopic, so I'm not even sure this discussion is appropriate here
14:02:12 <c_wraith> oh, I remember that. it was like.. 5 years ago, maybe? 
14:02:51 <monochrom> That was what we would call "smart but too smart to be simple". We were all in disgust.
14:03:18 <maerwald> smart is not a virtue in any way in terms of solutions
14:03:49 <maerwald> that's simply something all philosophy of science would agree with
14:04:25 <maerwald> if you can come up with a simpler theory, which is easier to understand, then that will ALWAYS be favored
14:04:35 <maerwald> as such, one can't say that "smartness" is a useful principle
14:04:41 <maerwald> "correctness" is
14:05:06 <c_wraith> I feel like you're conflating smart and complex. usually I think simple is the output of smart
14:05:20 <maerwald> c_wraith: I'm not, I have distinguished solution and problem solving
14:06:07 <maerwald> writing easy to understand code IS harder
14:07:48 <polymer> Hello?
14:07:59 <monochrom> Yes?
14:08:49 <polymer> Is anybody aware of a purely functional language, that has quoting, and evaluation, like a scheme?
14:08:59 <polymer> Or if there is some technical limitation to this?
14:09:36 <monochrom> I don't think there is one. You have to make some concession and then there are some.
14:10:33 <polymer> I was thinking of trying to implement a really simple one.
14:11:10 <k0ral> is there a function in lens of this type: `Functor f => (b -> c) -> Lens' a (f b) -> Lens' a (f c)` ?
14:11:17 <monochrom> The one I know is two ML implementations: Moscow ML and Poly/ML. They have quoting, but not evaluation or the Haskell kind of pure. They have quoting to help the implementers of a theorem prover (HOL98).
14:11:26 <monochrom> err, s/HOL98/HOL4/
14:12:26 <polymer> Cool, I might check that out :)
14:12:27 <monochrom> Oh implementing a simple one yourself is easy. Just implement the pure part of scheme :)
14:12:32 <k0ral> or, better: `Functor f => (b -> c) -> Lens (f a) (f b)` (this is essentially to . fmap)
14:12:42 <polymer> Right ^, that's what I was thinking.
14:12:55 <polymer> Is it possible to drop the environment and stuff.
14:13:26 <polymer> Though scheme isn't as pure as Haskell, which I'm pretty sure is unique in that respect.
14:13:33 <monochrom> "environment" is a very good implementation technique you don't want to lose.
14:13:52 <polymer> Why is that?
14:14:13 <monochrom> it helps you implement lexical scoping and function calls etc
14:14:27 <monochrom> not to say that it's the only way, but it's the easiest way known
14:14:47 <monochrom> and it's your implementation detail, a user doesn't need to know
14:15:09 <polymer> But what if the user is allowed to read eval :o
14:16:06 <monochrom> I think that still doesn't expose your implementation techniques to the user.
14:17:18 <polymer> I'll keep that in mind then if I try...
14:18:28 <polymer> I'm sort of trying to understand how much of Haskell's syntax sugar one can smooth out, I guess.
14:19:17 <polymer> And if there is a way to add a macro system that lets one add sugar in a non ad hoc way.
14:20:09 <polymer> Implementing a scheme with order of operations, and pattern matching, seemed like it could get 90% of the way there.
14:20:27 <polymer> But I wasn't sure if this had been done, or if I'm missing some obvious issues.
14:21:09 <chpatrick> polymer: have you tried template haskell?
14:23:02 <polymer> He left before I could answer >_>
14:27:10 <xcmw> Is it possible to write setters and lens for the X, Y, and Z properties? http://lpaste.net/345264
14:33:03 * hackagebot jsaddle 0.7.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.7.0.0 (HamishMackenzie)
14:33:05 * hackagebot jsaddle-warp 0.7.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-warp-0.7.0.0 (HamishMackenzie)
14:58:04 * hackagebot react-flux-servant 0.1.1 - Allow react-flux stores to send requests to a servant server  https://hackage.haskell.org/package/react-flux-servant-0.1.1 (JohnLenz)
15:02:08 <surina>                         r <- [ i + j + 2*i*j | i <- [1..n], j <- [1..n],
15:02:08 <surina>                                1 <= i && i <= j, (i + j + 2*i*j) <= n ],
15:02:17 <surina> sorry
15:02:30 <surina> tried to copy-paste to lambdabot
15:06:01 <surina> any idea why this function gives multiple odd primes?
15:06:07 <surina> > (\n -> [ 2*x + 1 | x <- [1..n], r <- [ i + j + 2*i*j | i <- [1..n], j <- [1..n], 1 <= i && i <= j, (i + j + 2*i*j) <= n ], x /= r ]) 7
15:06:10 <lambdabot>  [3,3,5,5,7,7,9,11,11,13,13,15]
15:06:38 <surina> This is the last exercise in http://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
15:07:33 <surina> by "multiple odd primes" I mean "same odd primes"
15:15:27 <lyxia> because for these primes there are multiple values of r that satisfy x /= r
15:17:02 <lyxia> > [(x, y) | x <- [1,2,3], y <- "ab"]
15:17:04 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
15:17:56 <monochrom> surina: Is your code actually implementing the Sieve of Sundaram?
15:20:23 <jle`> is there a nice high-level curses library?
15:20:50 <Clint> in no language
15:20:58 <monochrom> there is vty which is high level and not a wrapper of curses (because curses is poorly designed to begin with)
15:21:11 <jle`> oh hm
15:21:19 <jle`> all i want to do is animate a couple of points
15:21:31 <monochrom> I think vty is good
15:21:36 <jle`> neat, thanks!
15:22:35 <jle`> now to figure out how i'm supposed to learn how to use it
15:23:13 <jle`> this "where's the tutorial" game is always fun
15:25:41 <surina> > [(x, y) | x <- [1,2,3,4,5], y <- [1,2,3,4,5], x /= y]
15:25:44 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,1),(2,3),(2,4),(2,5),(3,1),(3,2),(3,4),(3,5),(4,...
15:25:46 <Clint> jle`: you might find https://hackage.haskell.org/package/brick more helpful
15:26:08 <jle`> aw but i already started learning vty
15:26:11 <surina> monochrom: yes
15:26:12 <jle`> but thanks, i'll look into that too :)
15:26:42 <jle`> oh brick is nice too, being lgoss-like
15:28:12 <surina> > [x | x <- [1,2,3,4,5], y <- [1,2,3,4,5], x /= y]
15:28:14 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5]
15:29:10 <surina> oh I see now
15:29:50 <surina> 4 ones because 1 /= 2, 1 /= 3, 1 /= 4 and 1 /= 5?
15:30:43 <monochrom> surina, I am now looking at the wikipedia article as referred to in the assignment, and I cannot see why your code does what it says.
15:30:48 <MarcelineVQ> that's right
15:30:53 <jle`> surina: yes ; if you're aware of 'filter', you can look at [ x | x <- [1..5], y <- [1..5]]
15:30:57 <jle`> er, sorry
15:31:19 <jle`> [ (x,y) | x <- [1..5], y <- [1..5]]
15:31:34 <jle`> and then filter out the tuples where x /= y
15:31:55 <monochrom> I have no reason to believe that the idiom [ whatever | x <- [1..n], r <- stuff, more stuff, x /= r ] means anything close to "remove stuff from [1..n]"
15:32:13 <surina> jle`: yeah you're right
15:47:10 <Welkin> has anyone run into this nix error?
15:47:17 <Welkin> error: Package ‘util-linux-2.28.1’ in ‘/nix/store/vwl64nqpkwavznrrks03wfi04hd9lrc0-nixpkgs-17.03pre91860.124f25b/nixpkgs/pkgs/os-specific/linux/util-linux/default.nix:70’ is not supported on ‘x86_64-darwin’, refusing to evaluate.
15:47:33 <Welkin> trying to use hakyll in nix
15:47:58 <Welkin> (on osx, which seems to be the problem)
15:52:58 <tekemperor> I am new to Haskell. I need resources for a "hello world" RESTful JSON API. Would also appreciate resources for interfacing with git repos (or OS commands for same) from haskell. Future of project could potentially scale to millions of users. Would prefer any suggestions allow for scale.
15:53:57 <grantwu> I heard servant is good for APIs, but that it might not be good for newcomers
15:54:15 <tekemperor> Welkin, I'm not familiar with that particular message, but it looks like you are trying to use resources provided by core-utils on OSX without installing them.
15:54:55 <sm> tekemperor: what grantwu said. Probably Spock is a good alternative
15:55:03 <sm> and there are git libs on hackage
15:57:03 <tekemperor> grantwu: thanks. I'm not too worried about the learning curve, I just wanted to make sure I don't waste effort on a poorly supported/abandoned framework.
15:57:13 <tekemperor> sm: thanks.
15:58:00 <sm> heath: I don't either, but will watch that. Thanks for the link
15:59:27 <n_blownapart> hi on line 19, in ' p : factors '  , how exactly does ' p : ' work ? I realize ' : ' returns a list and factors begins the recursive part. but is p to denote where a block begins?   thanks   http://pastie.org/10968714
16:00:16 <suzu> p is "ld n"
16:00:26 <suzu> the where clause at the end of that line shows that
16:00:38 <suzu> so we're making a list
16:00:46 <suzu> where the first element is ld n, or p
16:00:55 <suzu> and the remainder is factors (div n p)
16:02:18 <n_blownapart> suzu: thank you, oh so that is like a placemarker for the last part?
16:02:41 <suzu> no
16:03:00 <suzu> the `:` function is used to construct lists
16:03:10 <suzu> > 5:[4,3]
16:03:12 <lambdabot>  [5,4,3]
16:03:23 <suzu> or rather, prepend an element to a list
16:03:31 <suzu> > 10 : []
16:03:33 <lambdabot>  [10]
16:03:36 <n_blownapart> oh so that is like cons in scheme?
16:03:40 <suzu> yes, exactly
16:03:41 <suzu> it is cons
16:04:17 <n_blownapart> excellent so the result of p is cons-ed onto the list
16:04:25 <suzu> exactly
16:04:42 <n_blownapart> excellent! thanks suzu , way easier than scheme
16:04:50 <suzu> :)
16:05:46 <n_blownapart> suzu any experience with this example and its book, The Haskell Road to Logic, Maths and Programming ?
16:06:00 <suzu> never heard of that book, sorry
16:06:18 <n_blownapart> thanks, its a math book that teaches basic haskell
16:06:26 <n_blownapart> along the way
16:06:57 <Rumia> Has anyone tried to make a UI with Diagrams? Would it work for something like "connect 4"?
16:07:48 <Welkin> tekemperor: what is core-utils?
16:07:51 <c_wraith> Rumia: I think there are some projects that hook diagrams up to an interactive GUI.  I don't have firsthand knowledge of them, though.  If they exist, they'd certainly work for connect 4
16:08:16 <Rumia> Thanks!
16:08:36 <kuribas> Rumia: you could draw to an offscreen bitmap, then render it in a window.
16:08:37 <Welkin> in reference to web frameworks, I have been using yesod a lot and more recently servant
16:08:47 <kuribas> Rumia: don't expect high FPS though, diagrams isn't optimized for speed.
16:08:49 <Welkin> yesod is definitey the most production ready of all of the available ones
16:09:11 <Welkin> scotty and too low level and so is spock in my opinion
16:09:15 <Welkin> is*
16:09:36 <c_wraith> The low-level ones are good when you're just learning how HTTP works at the same time.
16:09:38 <Welkin> servant is very nice, but doing something that isn't supported by default can be messy
16:09:50 <kuribas> Rumia: something like wxHaskell is more suited.
16:09:56 <Welkin> I would recommend yesod for an ambitious project
16:10:22 <Welkin> unless you only need a simple json api, then servant could work better
16:10:48 <tekemperor> Welkin: coreutils is like the base posix commands provided by GNU. osx decided to use non-GNU for some of them, so you have to install them separately if you want them to work like they do on linux. (or I'm wrong, not sure, going away for a bit to eat dinner). If I am not wrong, check out homebrew to install the missing things in OSX.
16:11:14 <Rumia> Well 5 or 10 fps would be faster then I need, I think, so that should be okay.
16:11:16 <augur> dcoutts: i see we'll be working together to some degree :)
16:11:51 <dcoutts> augur: oh yes? what's the connection?
16:12:00 <augur> iohk :)
16:12:04 <dcoutts> ah cool
16:12:20 <Welkin> tekemperor: okay, I just checked it out using homebrew
16:13:07 <Welkin> it looks like I'd have to add them to my path manually
16:13:48 <kuribas> On the topic of unix: https://www.humblebundle.com/books/unix-book-bundle
16:14:50 <Welkin> wtf?
16:14:51 <Welkin> curl: (51) SSL: certificate verification failed (result: 5)
16:15:00 <kuribas> There's a book on emacs, so not entirely off-topic :-)
16:15:02 <Welkin> for homebrew O.o
16:16:58 <kuribas> Or vim for the heretics
16:17:25 <Rembane> More blood for the blood god!
16:18:43 <lordcirth> Ooh are we restarting the holy wars?  Just got here
16:20:21 <kuribas> lordcirth: nah, nobody uses vim, so we're fine :)
16:20:30 <suzu> i use BOTH
16:20:36 <suzu> i am beyond this meaningless struggle
16:20:39 <suzu> foolish mortals
16:21:12 * kuribas uses vim, but not for programming
16:21:15 <lordcirth> kuribas, I use vim.
16:22:12 <fouric> spacemacs, anyone?
16:23:57 <hpc> for me emacs is exclusively an agda ide
16:24:09 <Koterpillar> fouric: ++
16:24:39 <fouric> o/
16:25:12 <suzu> fouric: ++
16:25:39 <Rumia> I also use vim, and use emacs only for agda, idris, and LEAN.
16:25:54 <suzu> vim when remoting into stuff, spacemacs on local dev
16:26:02 <suzu> bare emacs is too painful
16:26:07 <suzu> gotta have my evil mode
16:26:11 * fouric idly wonders what the haskell layer is like
16:26:16 <suzu> its quiiiite nice
16:26:22 <kuribas> emacs is tricky to setup for haskell, but it's nice once it works.
16:26:29 <suzu> turn the layer on fouric 
16:26:31 <fouric> tricky how?
16:26:33 <suzu> then open a hs file
16:26:39 <suzu> SPC m s iirc
16:26:41 <c_wraith> What's the most pointless thing I could claim..  Oh.  I use nano!
16:26:45 * fouric doesn't have any hs files
16:26:51 <suzu> so open a buffer
16:26:56 <hpc> c_wraith: people use nano, it's sad
16:26:57 <suzu> save it as foo.hs
16:27:26 <fouric> ooh, "support for haskell-mode requires installation of layer haskell, do you want to install it?"
16:27:31 <fouric> that's *super* cool
16:27:38 <fouric> i've never seen spacemacs do *that* before
16:27:41 * fouric hits "y"
16:27:42 <suzu> yeah?
16:27:47 <Welkin> wtf???
16:27:50 <suzu> it'll do it for every language
16:27:52 <suzu> typescript
16:27:54 <suzu> javascript
16:27:55 <Welkin> someone just tried to scam me
16:27:56 <suzu> coffeescript
16:28:05 <suzu> its got a bunch of layer recognizers
16:28:17 <Welkin> I got a text message that said "Uber account diasbled. Please update your credit card <random shortlink>"
16:28:17 <c_wraith> hpc: does anyone ever stand up for nano in the editor wars?  Or do they just use it quietly?
16:28:28 <suzu> fouric do you have ghc-mod
16:28:30 <hpc> (it's actually only one, a regex for /.+script/)
16:28:30 <suzu> and hlint
16:28:47 <suzu> the errors from them will integrate right into flycheck
16:28:56 <kadoban> Welkin: Nice
16:28:56 <xcmw> Any way to add setters to this? Constructors work. Getters work two. http://lpaste.net/345279
16:29:15 <fouric> suzu: no, unfortunately; I haven't actually begun to learn Haskell yet, because I'm a EE student taking 16 credits of junior-level engineering classes
16:29:23 <suzu> ow
16:29:26 <suzu> well
16:29:32 <hpc> c_wraith: the furthest afield i have seen is eclipse for specific languages
16:29:32 <suzu> it'll highlight lines that have errors
16:29:34 * fouric made the decision to learn Haskell well *after* the term started :(
16:29:40 <suzu> and suggest ways to rewrite stuff to be more idiomatic
16:29:49 <suzu> and you can use SPC e l
16:29:52 <suzu> to get a list of all errors
16:30:00 <suzu> (that works for all layers and all languages)
16:30:23 <c_wraith> fouric: beware.  Haskell is a gateway product into type theory and category theory.
16:30:34 <fouric> c_wraith: actually, I was hoping for those things
16:30:53 <fouric> i found someone at uni that's been slowly teaching me category theory, and i've been poking at some online stuff too
16:31:00 <hpc> there's a window in the middle of learning haskell where every other language is ruined for you
16:31:01 <c_wraith> Pulling you pretty far afield from EE, then. :)
16:31:13 <fouric> i'm a hacker at heart, not an engineer
16:31:15 <hpc> because the combination of expressiveness and guarantees you get is just too damn good
16:31:17 <c_wraith> hpc: it ends?  It hasn't ended for me, 8 years later. :)
16:31:28 <hpc> it ended for me, i appreciate perl ;)
16:31:32 <fouric> i chose ee specifically because i didn't want to learn the cs bs that is taught at most places
16:31:45 <hpc> python is irreparably ruined for me though
16:31:53 <suzu> dynamically typed languages make me so unhappy
16:32:03 <suzu> in ruby you can redefine functions during runtime
16:32:05 <suzu> and classes as well
16:32:05 <hpc> but that's for another channel
16:32:09 <suzu> you can add functions to classes
16:32:11 <suzu> during. runtime
16:32:14 <Welkin> tekemperor: I installed coreutils and it didn't help
16:32:23 <c_wraith> I used python once after learning haskell.  Strangely, it wasn't the dynamic typing that got to me.  It was all the special case syntax.
16:32:24 <hpc> suzu: you can more or less do the same thing in haskell
16:32:25 <suzu> so who knows what in the fuck your ruby program is going to do
16:32:28 <suzu> until you run it
16:32:32 <hpc> suzu: IORef (a -> b)
16:32:43 <c_wraith> suzu: I don't even know what it did after I run it.
16:32:44 <suzu> that's just mutation
16:33:01 <tekemperor> Welkin: Sorry then, I don't think I can help.
16:33:08 <hpc> c_wraith: for me it was the strong typing
16:33:10 <suzu> also that's still pure even
16:33:16 <suzu> rails does so much fucking magic
16:33:19 <suzu> to make things work
16:33:22 <hpc> c_wraith: perl is more or less untyped, but it doesn't try to pretend at runtime, it just does mostly what you want
16:33:44 <hpc> in python you don't find out until you're done with some huge no-going-back operation that it returns a double instead of an int
16:34:13 <hpc> and then it has the audacity to throw an exception named "type error"
16:35:05 <fouric> hehe
16:35:16 <hpc> it introduces easily resolvable failure cases
16:35:27 <fouric> my language of choice is currently common lisp, but i don't think that it will scale to the things that i want to build...
16:35:51 <fouric> ...because that is one of the major benefits of Haskell, correct? enforced functional programming that makes it easier to build large applications?
16:35:54 <c_wraith> But in python...  I kept going "Why the heck am I suddenly using 'is not None' instead of using standard syntax, just for this one special case?"
16:36:22 <c_wraith> fouric: my experience with Haskell is that the benefits are the restrictions it allows you to place, yes.
16:36:39 <hpc> the restrictions translate into guarantees
16:36:48 <hpc> "this will never be null" is a big one
16:37:01 <Rembane> I am in love with Data.Maybe.
16:37:06 <Rembane> It has saved me so much grief.
16:37:20 <hpc> java has Option<T> but it's a lie
16:37:30 <fouric> good, good
16:37:38 <c_wraith> "This function's result won't ever depend on the environment" is such a huge change from what I get in the day job.
16:37:44 <fouric> guarantees on function behavior grow more valuable with the size of the program overall
16:37:46 <hpc> oh god, yes
16:38:07 * fouric goes to emag class
16:38:44 <n_blownapart> http://pastie.org/10968731   hey re: trace -- on line 21 I added ' print (ld 99) ' but I'd rather use trace on line 14 somewhere. possible?
16:39:55 <n_blownapart> (trying to learn nuances of trace. .. where are all the legal places I can put it?
16:39:59 <n_blownapart> )
16:40:07 <hpc> ld n = trace n (ldf 2 n)
16:40:10 <hpc> or something like that
16:40:25 <hpc> trace a b = display a, then produce the value of b
16:40:30 <hpc> so you can replace any b with trace a b
16:41:24 <suzu> :t trace
16:41:26 <lambdabot> error: Variable not in scope: trace
16:41:31 <suzu> :m +Debug.Trace
16:41:38 <suzu> @m Debug.Trace
16:41:39 <lambdabot> Maybe you meant: messages messages-loud messages? metar more msg v @ ? .
16:41:42 <suzu> loll
16:41:49 <n_blownapart> thanks hpc suzu yeah this traceShowId   
16:41:59 <suzu> :t traceShowId
16:42:01 <lambdabot> error: Variable not in scope: traceShowId
16:42:19 <n_blownapart> it works on line 19 so far
16:42:26 <suzu> traceShowId :: Show a => a -> a
16:42:30 <Clint> :t Debug.Trace.trace
16:42:30 <suzu> you can put this anywhere
16:42:31 <lambdabot> String -> a -> a
16:42:52 <suzu> with any argument that is Show-able
16:43:02 <n_blownapart> hold on , thanks, its actually somewhat confusing
16:43:24 <suzu> n_blownapart: it's `id` with a sneaky hack that prints the argument as a side-effect
16:43:28 <suzu> basically
16:43:44 <suzu> and i do mean hack
16:43:51 <suzu> it's not really the safest thing to be doing
16:43:54 <suzu> but debugging is debugging!
16:44:16 <ggVGc> haskell code can't have bugs
16:44:24 <suzu> ^
16:44:45 <hodapp> but your desk can
16:44:47 * hodapp dumps a bunch of house centipedes onto ggVGc's desk
16:44:55 <ggVGc> thanks
16:45:06 <hodapp> you're welcome. They'll eat the other bugs, and they'll leave you alone.
16:48:00 <n_blownapart> suzu so it does work on line 14 like this ' ld n = traceShowId (ldf 2 n) '  ..but whats a better way ..safer?
16:48:15 <suzu> if you want to really print it?
16:48:18 <suzu> properly?
16:48:21 <suzu> you need to be in the IO monad
16:48:40 <suzu> so, you could have an IO function call this pure function and then print the result
16:48:46 <nshepperd> using trace isn't really unsafe
16:48:50 <suzu> or you could put this function in the IO monad but then you could only use it in the IO monad
16:49:07 <nshepperd> only a silly person uses stderr for anything but debugging
16:49:08 <suzu> the IO monad is infectious
16:49:16 <suzu> oh i thought it was stdout
16:49:20 <n_blownapart> I'm at the very beginning of a book, but if you feel like adding it to the paste I would appreciate it .. just to see it
16:49:36 <suzu> probably better to not think about it right now tbh
16:49:41 <suzu> the book will get there in time, im sure
16:52:04 <n_blownapart> ok I'll use traceShowId in moderate risk until then thanks. I got used to using trace in scheme with aliases so that I could watch output on particular lines or to alias a primitive that is illegal: (* 2 2)   --> (*@ 2 2)  
16:52:06 <TommyC> Speaking of haskell books, do we have a factoid or topic for beginner books?
16:52:55 <n_blownapart> ie you cant give an alias to a primitive
16:53:23 <Welkin> has anyone used lucid/blaze with hakyll
16:53:23 <Welkin> ?
16:53:29 <Welkin> is ther even a way to do that?
16:53:32 <Welkin> there*
16:57:00 <kadoban> Welkin: Sounds like it'd be hard, especially the hakyll template parts.
16:57:43 <kadoban> I guess you could do it ... somehow. I dunno. Maybe like throw in random text in the blaze/lucid output, get the result as a String, and trick hakyll into using that as a template?
16:58:24 <Welkin> sounds like a mess
16:59:45 <kadoban> Ya. It could probably be made pretty, but it'd take some work. I guess you'd have to like, add some "tags" to blaze/lucid that let you do the special hakyll templating stuff, and etc.
17:00:25 <sm> can't be that hard. hakyll used to support hamlet
17:01:05 <kadoban> I think hakyll changed a lot since then, but I'm not sure. But ya in theory it shouldn't be amazingly hard.
17:03:35 <ggVGc> is there also a mr Jyde?
17:08:26 <napping> hakyll-shakespeare is a very small package
17:08:51 <napping> looks like you just need to define a Compiler value, and use it in your hakyll rules
17:18:09 * hackagebot dns 2.0.10 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.10 (KazuYamamoto)
18:12:24 <Zer000> Data-Hashable.html "Efficient instances for other types can be generated automatically and effortlessly using the generics support in GHC 7.2 and above." -- Are there limits to this? Can it really figure it out for anything?
18:19:22 <jle`> i wonder why mod' is hidden away in Data.Fixed
18:19:33 <jle`> Zer000: it works for types that are sums and products of things that are hashable
18:19:45 <jle`> so any ADT you make where all of the fields are hashable
18:20:48 <lilred> Is there a way to allow duplicate sum type tags? Basically I want to have `data T1 = B int` and `data T2 = B string`... F# allows this via ¨RequireQualifiedAccess¨
18:23:11 * hackagebot jsaddle-dom 0.7.0.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.7.0.0 (HamishMackenzie)
18:26:25 <fubu> xD
18:26:36 <Zer000> jle`, what is an example of an unhashable type?
18:26:49 <jle`> Zer000: (Int -> Bool), presumably
18:27:05 <jle`> that's a guess at one
18:27:22 <jle`> (i haven't checked, but i'm pretty sure there isn't a Hashable instance)
18:27:40 <kadoban> I guess you could make one, it'd just take a while, haha.
18:27:44 <jle`> also, abstract data types like 'Data.Map' might not expose a Hashable instance
18:27:54 <jle`> by choice
18:28:23 <jle`> abstract data types in general may or may not choose to provide a Hashable instance, so there's no "general" way to hash any abstract data type
18:28:39 <jle`> s/any/every
18:37:10 <lilred> Can someone elucidate for me the difference between a term and an expression?
18:37:40 <byorgey> lilred: there's no difference in general.
18:38:16 <byorgey> it's possible some specific book or paper may use them in specific, distinct ways, but I am not aware of any generally accepted distinction.  Basically they are synonymous.
18:41:26 <Zer000> interesting
18:43:12 * hackagebot ghcjs-dom-jsffi 0.7.0.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.7.0.0 (HamishMackenzie)
18:43:50 <Axman6> @pl \f -> ma err (suc . f)
18:43:50 <lambdabot> ma err . (suc .)
18:44:45 <Axman6> @pl \err suc -> m err (suc . f)
18:44:45 <lambdabot> (. (. f)) . m
18:48:36 <MarcelineVQ> what are you doin
19:03:13 * hackagebot ghcjs-dom-jsaddle 0.7.0.0 - DOM library that supports both GHCJS and GHC using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.7.0.0 (HamishMackenzie)
19:08:13 * hackagebot ghcjs-dom 0.7.0.0 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.7.0.0 (HamishMackenzie)
19:08:37 <nameishard__> looking for someone to help with homework :( willing to pay for tutoring , 3 hrs till deadline, needs debugging and explanation for certain part of the code 
19:12:02 <tekemperor> Are there any (free) immensely scalable database servers haskell can talk to?
19:13:49 <sm> would anyone have an idea why fsnotify stops working if I do it in a forked thread (both forkIO and forkOS, compiled with -threaded) ?
19:17:21 <dfeuer> conal, FYI, I stress-tested my MemoTrie generic defaults against the RandomAccessList in Ralf Hinze's "Numerical Representations  as Higher-Order Nested Datatypes". I was just waiting for something to break, but it worked perfectly.
19:17:36 <conal> dfeuer: :)
19:20:51 <tekemperor> nevermind, persistent can talk to postgresql, that will do for now.
19:23:13 <joneshf-laptop> Is there a way to hayoo for kinds?
19:23:19 <joneshf-laptop> Or hoogle I guess.
19:23:48 <codygman> Does anyone understand this "how to use storable vector with cassava": https://github.com/hvr/cassava/issues/104
19:25:39 <joneshf-laptop> codygman, understand what, exactly?
19:26:51 <codygman> joneshf-laptop: I have a vector a and I want to mmap it, but that requires using a vector with a storable instance. I feel like if I understood what was meant by "Making the inner vector (i.e. when we return a Vector (Vector a))) Storable should work" I would have my solution.
19:27:54 <augur> @free f :: [a] -> [a]
19:27:54 <lambdabot> $map g . f = f . $map g
19:28:38 <codygman> joneshf-laptop: My goal is to use cassava to read a csv into memory and then mmap the resulting vector onto disk so I can read it back.
19:29:17 <joneshf-laptop> mmap?
19:30:07 <carter> Variable sized things can't be storables.
19:30:53 <carter> But a size paired with a pointer can be a storable :)
19:31:59 <codygman> carter: Hm, I don't know a ton about the details but I was just trying to use writeVector from http://hackage.haskell.org/package/hmatrix-mmap-0.0.5/docs/Data-Packed-Vector-MMap.html
19:32:12 <codygman> actually yeah, it gets the size first of the vector with storeable instance
19:33:18 <codygman> joneshf-laptop: Yeah, mmap. I need kind of large data in many different checkpoints I can experiment with quickly. Otherwise I have to wait 2min30s for csv format, 1m30s for cbor, so I thought I'd just mmap the result to a file and read it back and see if it was faster.
19:35:35 <codygman> I might just make a cassava-storeable that uses Data.Vector.Storable, lol. I need a solution and can find a better solution later if needed.
19:38:27 <glguy> conal: I was looking at the :->: implementations for GHC.Generics and was wondering if they shouldn't be newtypes instead of data
19:38:32 <glguy> in memotrie
19:38:38 <eacameron> I'm newer to monad transformers and I want to run in a stack A (B (C IO)) but then run something in just B (C IO). Is that possible?
19:39:35 <conal> glguy: probably so
19:40:38 <emmanuel_erc> hello there everyone
19:40:41 <lilred> how are you supposed to use recursion schemes with mutually recursive types?
19:46:21 <glguy> conal: I also found myself wondering if it was correct that "newtype () :->: a = UnitTrie a"
19:46:42 <glguy> Should forcing a   () :->: x   force the x?
19:46:42 <conal> glguy: yeah?
19:46:56 <nameishard__> http://lpaste.net/345299 how do I modify parseLetTLE in the program to allow my calculator to correctly parse "let ... = ... in "  expression?
19:47:17 <Axman6> eacameron: that's just lift
19:47:19 <Axman6> :t lift
19:47:20 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
19:47:48 <glguy> conal: Rather than that being a "data"
19:47:55 <conal> glguy: that example is the iceberg tip. the type isomorphisms underlying memoization are only correct for hyper-strict functions. i think there's a very elegant solution. see http://conal.net/blog/posts/nonstrict-memoization
19:48:03 <eacameron> Axman6: Ah...I wondered if it was lift but I couldn't get my types to line up right. Something else must be afoot.
19:48:04 <conal> glguy: (not practical yet)
19:48:59 <conal> glguy: maybe your question is a different issue, though. forcing the codomain values rather than the domain values
19:49:49 <conal> glguy: also discussed in http://conal.net/papers/type-class-morphisms/
19:51:07 <glguy> conal: yes, I was considering the codomain, but your links are appreciated and I'm planning to continue reading tonight as well
19:51:34 <conal> glguy: enjoy
19:52:33 <conal> glguy: a related fun puzzle is how to make Haskell's if-then-else lazier (and more generally for the 'either' function).
19:52:54 <conal> glguy: so that it's not strict in the condition
19:54:19 <lpaste> emmanuel_erc pasted “The number of partitions of an integer (can this be modified to not "abuse" the GC as much?)” at http://lpaste.net/345300
19:54:41 <emmanuel_erc> Hi!
19:56:16 <glguy> conal: Also, I use a very similar construction in another library like yours, but instead of putting a data family in my typeclass, I put a type family and then wrap that with a newtype
19:56:31 <glguy> It means that I can use DefaultSignatures to provide a complete GHC.Generics implementation
19:57:06 <glguy> rather than calling on the user to follow a pattern with *Generic and newtype a :->: b = ... Reg a :->: b
19:57:15 <defanor> i'd like to parse a list of strings (command-line arguments) with parsec, wrote a `ParsecT s u m a -> ParsecT [s] u m a` function to reuse regular string parsers, but proper position tracking would require more tinkering. what made me to wonder: is there an existing function like that, to invoke parsers on tokens and propagate results?
19:58:02 <conal> glguy: can you point me to the code?
19:58:07 <glguy> https://github.com/glguy/tries/blob/master/src/Data/GenericTrie/Internal.hs#L107
19:58:10 <conal> thx
19:58:44 <byorgey> hi emmanuel_erc, nice program, but note it is not any more efficient than just enumerating the partitions and then finding the length of the resulting list
19:59:08 <byorgey> there are more efficient ways to calculate partition numbers if that's what you want to do.
19:59:38 <emmanuel_erc> Thanks for the comment byorgey!
19:59:43 <Axman6> defanor: any reason to not use a dedicated options parsing library like optparse-applicative?
20:00:11 <conal> glguy: good timing, as i'm about to reconsider MemoTrie: https://github.com/conal/MemoTrie/pull/12
20:01:02 <nameishard__> http://lpaste.net/345299 how do I modify parseLetTLE in the program to allow my calculator to correctly parse "let ... = ... in "  expression?
20:01:04 <defanor> Axman6: yup, i'm writing an options parsing + printing library. haven't found one, and wasn't quite happy with the parsing ones
20:01:51 <defanor> Axman6: reusing existing ones just for parsing would also be tricky here
20:02:17 <glguy> conal: Looks quite similar
20:02:23 <Axman6> what problems do you have with the parsing and printing in optparse-applicative?
20:02:36 <eacameron> Axman6: Ah so I'm trying to "lift" an action that is polymorphic using mtl classes. The mtl constraints actually only work in a subset of my monad stack, hence the lift. But I don't know how to "monomorphize" the action to my stack.
20:02:43 <emmanuel_erc> byorgey: I hadn't considered that line of reasoning. I would like to find more efficient ways to compute partition numbers.
20:03:08 <byorgey> nameishard__: we're not going to do your assignment for you.  If you try writing parseLetTLE yourself and run into a particular error, people will probably be willing to help you debug.
20:03:13 <conal> glguy: and i generally prefer associated functor, which i see that you're using.
20:03:48 <conal> glguy: for tries, that is.
20:05:17 <byorgey> emmanuel_erc: see https://en.wikipedia.org/wiki/Pentagonal_number_theorem
20:05:48 <defanor> Axman6: i'll need to inspect it again to answer thoroughly, but generally the problem with them is that it is pretty hard to print almost-arbitrary types in a way that could be parsed with those, even if there is automatic derivation. i'm trying to use command-line arguments as an interface between programs, generating parsers and printers with TH
20:06:02 <lgstate_> this is way off topic, but asking for advice: anywhere know where there might be an IRC or Slack channel for the J programming language? (the roger hui / ken iversion APL)
20:06:13 <glguy> Yes, that's off topic
20:06:59 <emmanuel_erc> byorgey: thanks!
20:07:11 <lgstate_> glguy: is it impolite to ask here despite someone here might knowing the answer?
20:07:26 <Axman6> it's polite to ask google first
20:07:56 <byorgey> emmanuel_erc: sure! have fun =)  I'm off to bed now but let me know what you come up with
20:07:59 <glguy> Yeah, the topic of #haskell isn't the union of things that everyone knows
20:08:10 <lgstate_> point taken
20:08:15 * hackagebot heterocephalus 1.0.0.2 - A type safe template engine for collaborating with front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.0.2 (arowM)
20:08:25 <Axman6> lgstate_: places like #haskell-blah and #haskell-offtopic would be better
20:08:54 <glguy> conal: I did a version of that module where I only had traverseWithKey and mergeWithKey, and then tried to arrange things such that the generics could compile away
20:09:02 <chreekat> It took me motnhs to realize that #haskell-blah is a real name, and not meta
20:09:25 <glguy> conal: I ran into a few tricky corners and was having to turn the GHC inline up to 11 with extra flags, so I fell back to what I linked earlier
20:09:47 <glguy> but it was mostly working :)
20:14:44 <tmobile> trimethylpurinedione
20:14:47 <tmobile> whoops
21:11:47 <Rumia> So is "testing-feat" the best way to auto generate instances of Arbitrary (from quick-check)?
21:13:27 <dmj`> is there such a thing as co-Cont ?
21:13:41 <dmj`> not to be confused with coconut of course
21:16:22 <Rumia> "Cont r" is "forall k, (k -> r) -> r" , right?
21:17:19 <Axman6> Cont r a = (a -> r) -> r
21:17:27 <Axman6> not forall
21:17:32 <Rumia> Ah.
21:23:05 <Rumia> So flipping the type around just gives r -> r -> a, which isn't a comonad, and I /think/ the only way to make it a monad is just Reader (r,r).
21:24:29 <geekosaur> r -> r -> a with no constraint on a sounds like its only inhabitant is _|_?
21:25:16 <Rumia> both r and a would be concrete.
21:25:20 <geekosaur> although I'm probably thinking about it wrong
21:26:42 <Rumia> Really I meant [Capital Lambda] a r => a->r->r .
21:27:29 <Rumia> or in haskell "newtype Cont a r = r -> r -> a".
21:27:52 <dfeuer> Rumia, you mean   newtype Cont a r = Cont (r -> r -> a) ?
21:28:02 <Rumia> Yes.
21:28:10 <dfeuer> Or even  newtype Cont a r = Cont { runCont :: r -> r -> a }
21:28:38 <Rumia> Yeah, in fact that was what was in the libraries for a long time.
21:28:44 <dfeuer> Or newtype Potato = YukonGold | Fingerling | ....
21:28:51 <Rumia> >.<
21:28:53 <dfeuer> A long time? Or a short time?
21:29:57 <Rumia> I think it took a while for Cont to be defined as ContT Id, but memory is often wrong.
21:30:11 <dfeuer> Well, maybe it was a long time, Rumia, but I think it's been that way at least 16 years.
21:30:27 <geekosaur> all of the Xxx to XxxT was mtl2
21:30:41 <dfeuer> When did that happen?
21:30:47 <geekosaur> 2010
21:31:01 <Rumia> Yeah so only 6 years.
21:31:06 <Rumia> That makes sense.
21:31:20 <geekosaur> and yes, Cont was the simpler one in mtl 1.1.1.1 and changed in mtl 2.0
21:31:39 <geekosaur> oh, don;t trust that date
21:31:45 <Rumia> >.<
21:31:46 <geekosaur> I got it from hackage but hackage got back-populated
21:32:27 <EvilFrog> ok
21:32:31 <EvilFrog> this shit was complicated
21:32:32 <geekosaur> all the 1.1.1 series also claim to be mid 2010
21:33:22 <geekosaur> so I have a feeling the first-upload date represents something other than when it was actually first released, like they had to fill in gaps or something (1.1.0.2 shows a 2008 date though)
21:33:28 <dfeuer> geekosaur, that's in mtl. Cont = ContT Identity has been in transformers since version 0.0.0.0
21:33:38 <dfeuer> Which claims to be ... 2009? 
21:33:41 <geekosaur> but transformers is not a lot older than that iirc
21:33:43 <geekosaur> yes
21:33:58 <dfeuer> This all gets hazy back before there was a package system.
21:34:00 <geekosaur> mtl1 -> transformers + monads-fd -> mtl2
21:34:38 <geekosaur> (the intermediate period being one of experimentation; transformers could be used with monads-fd or monads-tf, which overlapped each other but specifically avoided overlapping mtl)
21:34:59 <dfeuer> But I'm pretty sure things like State were already defined in terms of transformers when I started mucking with Haskell in 2001 or thereabouts.
21:35:20 <dfeuer> Of course, I could also be remembering wrong.
21:35:21 <geekosaur> the outcome of the experiment was mtl2
21:35:30 <geekosaur> no, transformers came in with mtl2
21:36:03 <geekosaur> and was specifically created when they were trying to decide whether mtl would go the type families route or stick with fundeps. transformers was the common portion
21:36:14 <dfeuer> There will have to be an mtl3 to split out the wonky effects that exclude lots of otherwise-lovely instances.
21:36:16 <geekosaur> and previously was part of mtl1
21:36:33 <dfeuer> By transformers, I meant monad transformers.
21:36:48 <dfeuer> You probably did too.
21:36:49 <geekosaur> yeh, monad transformers /per se/ are fairly old
21:37:01 <geekosaur> it's confusing...
21:37:35 <geekosaur> (I was in fact thinking only of the package name; transformers themselves... well, it's called Monad Transformer Library for a reason)
21:38:17 <geekosaur> thought that was already clear
21:42:12 <dfeuer> geekosaur, were things like State in base before there was an mtl?
21:42:44 <dfeuer> Well, before there even was a base?
21:42:54 <dfeuer> Where is the prehistory?
21:43:02 <geekosaur> good question
21:43:57 <Axman6> I remember the says when mtl and transformers were somewhat competing implementations of the same stuff, the merger was IIRC really messy
21:44:02 <Axman6> "merger"
21:44:08 <geekosaur> as of 6.2.1 no mtl and they're in base
21:44:39 <geekosaur> and it has StateT
21:48:00 <geekosaur> ghc5.0 hslibs doesn't have documentation for monads...
21:48:38 <geekosaur> but it does have MPTC, so they must have been around somewhere
21:49:36 <dfeuer> Geekingfrog, ghc 6.2 has State and StateT, and they're separate newtypes.
21:49:56 <geekosaur> wrong geek :p and yes that was implied
21:50:02 <geekosaur> the combination only happened with mtl2
21:50:18 <geekosaur> all mtl1 versions have them separated
21:50:51 <dfeuer> So was that actually 2010? That seems awfully late compared to my vague recollections, but that doesn't make it wrong.
21:51:23 <geekosaur> I can't tell, as I said earlier all the hackage dates for mtl look screwy
21:51:50 <geekosaur> probably have to dig through cafe for discussion of the monads-fd/monads-tf stuff and later mtl2
21:52:10 <geekosaur> hackage claims the last mtl1 release was 2008 though
21:53:07 <geekosaur> er. not the last mtl1 release, the second last major release. the last major release it claims was concurrent with mtl2 (and in fact that version might have been intended as transitional)
21:54:22 <geekosaur> I'm still bemused that the old standard library doesn't seem to have a section on what are now the mtl monads. I would have expected things like State to exist in *some* form...
21:55:07 <geekosaur> since the driving motive for MPTC was monad transformers and 5.00 claims to have had MPTC
21:55:44 <dfeuer> geekosaur, I guess you just had to download it from somewhere, or copy the code from the paper?
21:55:55 <dfeuer> I should start moving toward bed.
21:56:06 <geekosaur> external lib not distributed with ghc, I guess
21:56:28 <geekosaur> feels wrong considering how central they are these days...
21:56:34 <dfeuer> I think that was before Cabal, so I have no idea how that all worked.
22:00:17 <geekosaur> right, Cabal appears to have come in with base in 6.0.1
22:00:32 <geekosaur> also I just realized hslibs was flat namespace
22:00:58 <dfeuer> Before the silly Data/Control split, but also before more useful divisions.
22:01:21 <geekosaur> actually that split semi-existed in hslibs
22:01:33 <geekosaur> the documentation has a "Data" category
22:01:41 <dfeuer> Quite a mistake.
22:01:52 <geekosaur> but since it was flat, it wouldn't have Data.xxx
22:02:29 <dfeuer> Somehow it makes sense to have Data.Functor, Data.Semigroupoid, Control.Monad, Control.Category? Wat.
22:02:35 <geekosaur> and the contents of the Data category roughly match the current Data.*, with the equivalent of Control.* spread over various other categories
22:03:07 <dfeuer> Control.Lens even? Blargh.
22:03:23 <geekosaur> like Exception was part of the "lang" category
22:03:37 <geekosaur> (but so was Array, which is now under Data)
22:03:56 <dfeuer> Look, I have no problem with bona fide *data structures* having a category.
22:04:08 <geekosaur> actually there wasn't Array either, that came about with the hierarchical refactor. *Array for various kinds of arrays
22:04:44 <dfeuer> But it seems most other things are sprayed into Data or Control almost at random.
22:06:08 <geekosaur> in any case you can yell at whoever organized the 6.0.1 "Haskell Hierarchical Libraries" :p
22:06:12 <dfeuer> What I usually say is that we have Data and Control because someone a long time ago got confused and thought they were different. I guess I'm just a broken record now.
22:06:16 <geekosaur> fsvo "organized"
22:07:47 <geekosaur> they thought differently back then :) honestly I suspect there was less of a concept that in a functional language data *is* control
22:08:00 <geekosaur> like lists are in some sense loops
22:08:44 <dfeuer> Or alternatively, lists are free monoids, and monoids represent a certain limited control form.
22:08:53 <geekosaur> it took experience for that notion to really take hold, and they organized the library before that experience was sufficiently widespread
22:09:15 <dfeuer> Yes, that seems likely.
22:11:22 <dfeuer> All right. Good night, all.
22:11:29 <geekosaur> hm, rephrase that slightly: in a strict functional language you don't get nearly as much of a control structure out of data. it takes laziness --- and then the understanding that laziness enables data to be control structure
22:12:08 <dfeuer> geekosaur, even there, a number of Haskell's classes can serve to describe either data structures or control structures.
22:12:41 <geekosaur> even when I started doing Haskell in 2006, there was some understanding of that but the understanding has visibly developed quite a lot since then
22:12:42 <dfeuer> And certain monad transformers can still talk about data or control.
22:13:02 <dfeuer> Anyway, I *really* should get ready for bed. Good night.
22:15:40 <geekosaur> (I seem to have this tendency to start learning something right at around the time other people are just starting to figure out the possibilities --- with the result that it always seems like I am discovering things at around the same time other people are. which feels *odd*)
22:16:15 <geekosaur> s/other people/the people who "already know" whatever it is/
22:18:49 <EvilFrog> asdf
23:25:38 <ali_bush> Hi everyone.  Im using codinggame.com to try reinforce my haskell learnings and have run into a case where my solution doesn't complete quickly enough.
23:26:06 <ali_bush> Im wondering if anyone could give me some pointers on how to speed it up
23:26:19 <ali_bush> This is the implementation I have currently https://github.com/alistair/CodingGame/blob/master/src/MimeTypes.hs
23:27:59 <quchen> What’s the standard package for always-infinite lists, aka streams?
23:28:22 * hackagebot validation 0.5.4 - A data-type like Either but with an accumulating Applicative  https://hackage.haskell.org/package/validation-0.5.4 (TonyMorris)
23:37:43 <ertes> quchen: there are two: Stream and streams
23:38:38 <quchen> Ah, streams!
23:39:05 <quchen> Stream depends on Quickcheck so I’m a bit skeptical about the quality of that lib.
23:39:09 <ertes> quchen: streams, being an edwardk library, provides the full palette of instances, but also has an edwardk-style dependency tree =)
23:39:29 <quchen> s/an/the/
23:39:40 * edwardk shrugs.
23:39:59 <edwardk> you can always use Cofree Identity
23:40:07 <quchen> edwardk: No worries, it means I don’t have to compile much after using any of your libs ;-)
23:40:15 <edwardk> exactly =)
23:40:39 <edwardk> the more modern practice of sandboxing makes that argument a little harder to sell these days. oh well
23:40:50 <ertes> i'd generally go with streams anyway =)
23:41:03 <ertes> just like i generally go with lens (instead of microlens)
23:43:23 * hackagebot data-has 0.2.0.0 - Simple extensible product  https://hackage.haskell.org/package/data-has-0.2.0.0 (winterland)
23:46:18 <kinda> hi, i'm trying to implement a variadic function like here : http://rosettacode.org/wiki/Variadic_function#Haskell
23:46:24 <kinda> this is my code so far
23:46:34 <kinda> http://pastebin.com/5ERSWsL3
23:47:14 <kinda> i've got some messages I dont understand :     No instance for (Num a0) arising from the literal 2
23:47:19 <kinda> also
23:47:33 <kinda> this means somehow I don't understand how the compiler handles classes
23:49:13 <c_wraith> kinda: well, the main thing to get from that error message is that the compiler doesn't know a concrete type
23:49:30 <c_wraith> kinda: also, the fact that it's named a0 suggests it's not a type mentioned in the signature of the function
23:49:46 <kinda> c_wraith: sorry i'm very new to haskell
23:50:08 <kinda> what do you mean by "the compiler doesn't know a concrete type" ?
23:50:23 <kinda> like it doesn't know what is the type of the litteral 2 ?
23:50:23 <c_wraith> Int is a concrete type.  a0 is a type variable that could be any type
23:50:35 <c_wraith> kinda: correct.  Numeric literals are polymorphic in haskell
23:50:37 <c_wraith> :t 2
23:50:38 <lambdabot> Num t => t
23:50:51 <c_wraith> kinda: it can be any type that has a Num instance.
23:51:08 <kinda> ok I get that
23:51:20 <kinda> so the way the type of "2" is resolved is unclear for me
23:51:34 <c_wraith> well, the error message says it's unclear to ghc also
23:51:40 <ertes> kinda: try (2 :: Integer)
23:51:52 <ertes> the error message should become a lot more meaningful
23:51:55 <lyxia> there's also the fact that the compiler doesn't know the type of sumAll 2
23:52:39 <kinda> ertes: it removes the last message but the two previous ones are still here
23:53:54 <ertes> kinda: what lyxia is saying is to add a type signature for (sumAll 2) as well
23:54:01 <kinda> lyxia: I must say I modified the rosetta code but i'm not sure to fully understand it
23:54:58 <ertes> kinda: these kinds of hacks tend to introduce a *lot* of type ambiguity
23:55:43 <kinda> so, you think an instance is missing ?
23:55:59 <kinda> no 
23:56:19 <kinda> I need again a :: ?
23:56:36 <ertes> yeah, that's called a type signature
23:57:24 <kinda> well I guess part of my problem is that I don't understand how the compiler figures out the types 
23:58:04 <ertes> kinda: pretty much the same way you would: it looks at the context and keeps refining, until all types are fully known
23:58:15 <ertes> (or fully polymorphic)
23:58:36 <c_wraith> the root of the compiler's approach is unification.  "Hey, I know these expressions must have the same type.  What extra info does that give me?"
23:58:38 <kinda> http://rosettacode.org/wiki/Variadic_function#Haskell
23:58:41 <kinda> ooops
23:58:43 <kinda> sorry
23:58:53 <kinda> main = do print $ ((sumAll (2::Integer)) :: Integer)
23:58:55 <kinda> this is working
23:59:34 <kinda> sadly it is now too complex
23:59:45 <ertes> kinda: now that it works, i didn't say anything, because i assumed that you're doing this to learn, but:  all of this is essentially just a super-awkward version of 'sum' =)
23:59:57 <kinda> yes I know
