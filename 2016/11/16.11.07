00:00:46 <Axman6> I personally quite like stack and think it is a good tool for both beginners and commercial users of haskell. A lot of the problem was the way in which FP Complete attempted to somewhat force it on the community and get offended when there was some pushback
00:00:48 <saurabhnanda> and what's the problem in having HP = latest stable GHC + core libs + cabal (for compiler workflows) + stack (for project workflows)
00:01:14 <Axman6> (this is just my not particularly well informed view)
00:01:50 <saurabhnanda> Axman6: which is what I wanted to comment on, but it will touch a very raw nerve. From someone reading the history (mailing list archives), arguments in favour of stack seem to be the logical ones.
00:02:57 <hhhhha> How can I check for end-of-file when using hGetChar? I'm trying to right a function that returns Just Chars if it's not reached the end of the file and nothings otherwise
00:03:01 <hhhhha> (this is homework)
00:03:12 <nshepperd1> jle`: why not? Is it because the output type can depend on the gadts value?
00:03:57 <zyla> jle`: then why `foo = case Foo () of Foo () -> ()` works? The difference is in the thing we're matching on, but return type is the same, and doesn't depend on anything.
00:04:01 <hhhhha> (nothing when it has)
00:04:19 <hhhhha> so type :: Handle -> IO (Maybe Char)
00:04:58 <jle`> zyla: oh, i didn't realize that case Foo () of Foo () -> () works, hm.
00:05:33 <nshepperd1> zyla: did Foo (1 :: Int) work?
00:05:36 <hhhhha> Can anyone point me in the right direction? :/
00:06:19 <zyla> nshepperd1: yes
00:06:25 <hhhhha> (please)
00:06:37 <nshepperd1> My intuition says this is some interaction between a polymorphic type of the gadt and exhaustiveness checking
00:07:04 <Rarrikins> hhhhha: Are you allowed to use the various functions in System.IO?
00:07:23 <hhhhha> Rarrikins, I'm allowed to use hGetChar
00:07:38 * hackagebot monad-logger 0.3.20.1 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.20.1 (MichaelSnoyman)
00:07:38 * hackagebot resourcet 1.1.8.1 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.8.1 (MichaelSnoyman)
00:07:38 <hhhhha> Rarrikins, So I think I need to just figure out a way to check if I'm at the end of the file or not
00:08:19 <hhhhha> Rarrikins, And in general, yes to System.IO functions
00:08:25 <Rarrikins> hhhhha: Well, there's a function in there to detect EOF, but hGetChar fails with a certain error on EOF.
00:08:26 <zyla> Hm, `Foo 1` violates another rule: "The type of the scrutinee must be rigid"
00:08:30 <zyla> (from https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts)
00:09:02 <nshepperd1> hhhhha: http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:hGetChar says it throws an exception if eof. So you can just catch the exception
00:09:03 <hhhhha> Rarrikins, What do you mean by fails with a certain error? I think the idea of hMaybeGetChar is to avoid that failure?
00:10:27 <Rarrikins> hhhhha: nshepperd1 pointed out that you can catch the exception.
00:10:59 <lyxia> hhhhha: he's talking about a function that you can use to implement yours.
00:11:15 <hhhhha> Yep, got that. Not sure how to catch the exception though :/
00:12:06 <jle`> hhhhha: see the documentation in the Control.Exception module in base :)
00:12:47 <Rarrikins> hhhhha: There's also a tutorial section that might reveal too much since this is homework.
00:13:31 <hhhhha> This is the first of two exercises. I've gotten a bit lost with monads :/
00:14:24 <jle`> if it's homework then i'm assuming it's meant to be done without learning about exceptions, so this is kinda weird
00:14:47 <zyla> But then, `case Foo [] of Foo [] -> ()` also compiles, but `[]` is not rigid
00:15:23 <zyla> I'm lost
00:17:12 <hhhhha> Oh wait, I think I see what they want
00:17:17 <jle`> i too am puzzled
00:17:41 <jle`> i've had this happen to me before in a couple of situations
00:17:43 <hhhhha> They had implemented it where they performed the eof check outside the function, and it's just a matter of rewriting it inside
00:17:47 <jle`> i usually just suck it up and add a type signature
00:17:48 <Rarrikins> nobody: You sure do run a lot of services.
00:18:06 <hhhhha> Rarrikins, nshepperd1 lyxia jle` Thank you
00:18:11 <Guest42620> Rarrikins, hmmmm?
00:18:13 <Guest42620> whatcha mean
00:18:24 <Guest42620> gheheheh
00:18:35 <Cale> There's a lot of stuff that nobody is taking care of
00:19:30 <zyla> jle`: nshepperd1: Thanks
00:37:33 * hackagebot Spintax 0.2.0.0 - Random text generation based on spintax  https://hackage.haskell.org/package/Spintax-0.2.0.0 (MichelBoucey)
00:38:27 <hvr> Axman6: where does that leave us with cabal development? shall we just give up and leave the stage to stack? :-)
00:39:52 <hvr> saurabhnanda: fwiw, cabal is also providing project-centric workflows w/ nix-local builds
00:40:50 <hvr> saurabhnanda: what arguments in favor of stack are logic ones?
00:41:22 <saurabhnanda> hvr: the detailed emails by snoyman and chris. Do you want me to link to them?
00:41:47 <hvr> saurabhnanda: yes plz
00:42:01 <saurabhnanda> hvr: hang on
00:42:07 <hvr> there was so many things said that I'm not sure which ones specifically you refer to :_)
00:42:26 <saurabhnanda> hvr: https://mail.haskell.org/pipermail/haskell-community/2015-September/000014.html
00:42:33 * hackagebot hquantlib 0.0.3.3 - HQuantLib is a port of essencial parts of QuantLib to Haskell  https://hackage.haskell.org/package/hquantlib-0.0.3.3 (PavelRyzhov)
00:42:57 <saurabhnanda> hvr: https://mail.haskell.org/pipermail/haskell-community/2015-September/000027.html
00:44:31 <hvr> saurabhnanda: ok, those arguments refer to the old-style haskell platform
00:44:50 <hvr> saurabhnanda: the issues have or are being adressed one by one 
00:45:18 <hvr> saurabhnanda: there is no rush to push everyone to use stack, just to have them push back to cabal 1-2 years later
00:45:50 <grantwu> Why would we go back to cabal
00:46:02 <hvr> grantwu: because cabal fixed the issues
00:46:05 <grantwu> So?
00:46:08 <grantwu> Switching has a real cost
00:46:10 <saurabhnanda> hvr: and that brings me to a related question. If 'stack' is available now and works pretty well, why doesn't it supersede cabal.
00:46:21 <hvr> grantwu: exaclty, thaat's why we don't want people to switch to stack in the first place ;-0
00:46:33 <saurabhnanda> hvr: we're anyways running on volunteer time, why do the extra work?
00:46:34 <hvr> </evil-cabal>
00:46:55 <grantwu> ...what, we were all supposed to wait for cabal?
00:47:13 <hvr> grantwu: no, you can of course whatver tool you want
00:47:22 <hvr> grantwu: but don't expect me to endorse stack
00:47:41 <dmj`> 'runhaskell Setup.hs' for life
00:48:02 <ezyang> as for why cabal new-build, the reason I like to give is that Stack is designed with Stackage use primarily in mind 
00:48:09 <saurabhnanda> hvr: that's precisely what I'm looking for. What are the arguments in favor of HP and against tack. Technical arguments. 
00:48:25 <hvr> grantwu: there was also this very interesting other tool https://halcyon.sh/ which almost everybody ignored... :-/
00:48:44 <ezyang> but if you want to be working outside the Stackage regime, I think cabal new-build does a bit better 
00:49:14 <bartavelle> saurabhnanda, stack is mostly useful if you want to use a stackage-based curation model
00:49:19 <bartavelle> I do, and find stack awesome
00:49:22 <bartavelle> if you don't, it will suck
00:49:31 <bartavelle> as you'll just manually pin versions in stack.yaml
00:49:38 <saurabhnanda> stack can be used without the LTS resolver, which makes it practically indistinguishable from Hackage.
00:49:40 <grantwu> Yeah, not wanting to use curated locksteps is a good reason to not use Stack.
00:49:57 <hvr> saurabhnanda: but it's not its natural workflow, and it shows
00:50:08 <bartavelle> saurabhnanda, it can work, but it's not made for that, and it's not a great experience
00:50:08 <saurabhnanda> IMO, **technically alone** stackage is a superior tool and effort should be made to evolve it, rather than stunt it.
00:50:24 <hvr> saurabhnanda: s/stackage/hackage/
00:50:24 <bartavelle> ok, now that's trolling ...
00:50:26 <MarcelineVQ> saurabhnanda: Is that what's happening?
00:50:33 <dmj`> saurabhnanda: nix w/ cabal is a pretty compelling alternative as well
00:50:52 <grantwu> stackage does a certain thing, it's not for everyone
00:50:54 <saurabhnanda> that word again... "trolling"
00:50:56 <hvr> saurabhnanda: point being, neither approach by itself is 100% superiorir to the other one
00:51:12 <hvr> saurabhnanda: I recommedn you read up on https://www.well-typed.com/blog/2015/01/how-we-might-abolish-cabal-hell-part-2/
00:51:17 <cocreature> so let both coexist and everybody can be happy.
00:51:43 <hvr> saurabhnanda: whic tries to make the point that we need both 
00:51:43 <saurabhnanda> aargh... both coexist == not deciding == wasting time & resources IMO. 
00:51:53 <cocreature> I regularly switch between stack and cabal depending on which fits my workflow for a particular project better
00:51:57 <grantwu> saurabhnanda: Both do certain use cases better than the other.
00:51:58 <saurabhnanda> hvr: thanks, will read.
00:52:12 <grantwu> I do think stack is probably better for newcomers.
00:52:26 <bartavelle> saurabhnanda, same thing with vim vs. emacs vs. other editors tooling support
00:52:47 <hvr> grantwu: just because it installs some GHC bindist which doesn't even work for latest Ubuntu releases? ;->
00:52:50 <ventonegro> Stack is awesome. Made things so simple I can't believe it wasn't there from the beginning.
00:52:59 <saurabhnanda> bartavelle: not precisely the same. They are driven by large AND separate communities. Both adjectives being important.
00:53:03 <ezyang> saurabhnanda: For example, if you use Stack without the LTS resolver, it will use a very different caching model than cabal new-build ( described in https://www.fpcomplete.com/blog/2015/09/stack-more-binary-package-sharing ) 
00:53:12 <saurabhnanda> bartavelle: which is not the case with stackage (stack) and hackage (cabal)
00:53:19 <grantwu> hvr: No...
00:53:21 <bartavelle> saurabhnanda, I'm talking about haskell tooling
00:53:26 <bartavelle> those are SMALL communities
00:53:49 <dmj`> saurabhnanda: stack still depends on Cabal, plus I think Cabal is caked into ghc
00:53:52 <hvr> grantwu: ...or because it can use a distributed freeze file (aka stackage snapshots), which cabal can use just as well?
00:54:17 <cocreature> bartavelle: which is why haskell-ide-engine was created but for various reasons that didn’t take off and at this point I doubt it ever will
00:54:18 <grantwu> hvr: Are there distributed freeze files being widely distributed outside of stackage?
00:54:36 <hvr> grantwu: I'm hinting at, that we're closing the gap between cabal & stack, and I that in 2017 we'll be able to announce it
00:54:44 <bartavelle> cocreature, yeah, this is kind of demoralizing, but it's hard to complain about people not doing free work for me
00:54:48 <saurabhnanda> bartavelle: are you referring to vim, emacs Haskell plugins?
00:54:54 <bartavelle> saurabhnanda, yes
00:55:02 <grantwu> hvr: I'm a bit confused... who is doing this?
00:55:13 <bartavelle> cocreature, but there is also the question of editor integration, which seems like a lot of work
00:55:13 <hvr> grantwu: cabal/hackage devs, by working on new-build
00:55:51 <LordBrain> i am just glad they continue developing it
00:55:55 <cocreature> bartavelle: one of the main ideas behind haskell-ide-engine was to move as much as possible in an editor-agnostic backend
00:56:03 <saurabhnanda> bartavelle: that's a necessity because of deeply ingrained preferences of people (and existing market forces). Is that really the case with hackage vs stackage?
00:56:27 <grantwu> There seems to be quite a bit of hostility towards stack among cabal developers
00:56:30 <LordBrain> the cabal api has had a notorious tendency to fluctuate which complicates custom builds
00:56:34 <bartavelle> saurabhnanda, given how heated the "debates" can be, I'd say yes :)
00:56:46 <LordBrain> that's one issue with cabal
00:56:55 <cocreature> there is hostility on both sides and it’s really annoying watching people fight instead of collaborating
00:57:00 <saurabhnanda> IMO, the best way to deal with this is to have a **vision/spec document** and list down very specific features required from a unified build+package management tool. And see what's closed right now. And rally support behind it to close the gaps.
00:57:02 <grantwu> It also seems to me that the release of stack precipitated a lot of the new stack features
00:57:06 <LordBrain> should be some kind of stable, committed api for that kind of thing
00:57:10 <grantwu> er, new cabal features
00:57:44 <saurabhnanda>  s/closed/closest
00:58:00 <grantwu> saurabhnanda: Yes, well, see above - hostility
00:58:39 <grantwu> saurabhnanda: See haskell.org vs haskell-lang.org
00:58:40 <ezyang> LordBrain: Agreed. A lot of the trouble is Cabal library never designed its outward facing API... and no one wants to rip the bandaid off now 
00:58:53 <saurabhnanda> and that could mean merging cabal & stack. Introducing LTS to hackage. etc. etc. whatever is required from the vision/spec document. We have fewer hands. We should work on a common codebase. Not splinter the efforts.
00:58:54 <grantwu> Does having two of these things really make that much sense?  Not really...
00:59:42 <bartavelle> grantwu, stack is more than just the command line tool, it's mostly all the curation process
00:59:44 <grantwu> saurabhnanda: perhaps in an ideal world.  But in this world, people have egos.
00:59:55 <saurabhnanda> quick qn -- how is stackage with nightly resolver different from hackage?
01:00:05 <grantwu> bartavelle: I'm aware.  And hvr seems to be implying that hackage is going to be creating its own curated snapshots
01:00:22 <ezyang> saurabhnanda: Stackage nightlies are still a coherent set of packages. No need to depsolve 
01:00:25 <hvr> grantwu: they're called "package collections" in hackage term
01:00:37 <grantwu> s/curated snapshots/package collections/
01:00:39 <bartavelle> grantwu, really ? I don't think it does. It's more that there will be no need to sandbox if I understand it properly ?
01:00:46 <LordBrain> ezyang, well whats the alternative... sort of wait for the dev to settle down?
01:00:49 <bartavelle> oh really !
01:01:00 <grantwu> bartavelle: Not yet.  But see scrollback.  Apparently hackage wants to do this too.
01:01:11 <ezyang> LordBrain: I mean, if you want to freeze Cabal, as is, for the rest of eternity ;) 
01:01:42 <ezyang> LordBrain: We've kind of made it possible for you to do that now, with setup dependencies :/ (Kind of a pain because you fix bugs but it's still old versions of Cabal and g'ah!) 
01:01:44 <hvr> grantwu: it was on the roadmap for years, but it all takes longer since hackage needs to do it properly from the start; so a lot of time goes into the design phase
01:02:26 <hvr> grantwu: so here 'perfect' is the enemy in some way
01:03:09 <hvr> grantwu: just to hint at the problems, it needs to be integrated w/ the mirror infrastructure (i.e. with hackage-security)
01:03:30 <hvr> as it's no use if the collections are not available on outages
01:03:38 <hvr> if we start relying on them
01:04:30 <saurabhnanda> grantwu: which is one of the places where my "who **owns** haskell" question is coming from. own=ownership. not proprietorship. Who drives consensus? who sets the vision? who takes tough decisions?
01:04:35 <hvr> then there's the issue of how to model their representation, since we want to be more expressive than stackage snapshots
01:05:28 <hvr> saurabhnanda: well, there's multiple parties having somewhat conflicting visions
01:05:41 <hvr> saurabhnanda: we're not a borg collectie with a single vision
01:05:47 <ventonegro> saurabhnanda: Haskell is a programming language, so that would be the Haskell committee.
01:05:51 <LordBrain> hvr, the conflicting visions you have in mind are stack vs cabal ?
01:06:19 <grantwu> Well, regardless of whatever cabal is going to be in the future, any newcomer would prefer something that works now, not something that will work later
01:06:22 <hvr> LordBrain: yeah, that's the biggest one, but there's also others like, which http framework, which streaming api (pipes/conduit/io-streams/lazy/machines/...)
01:06:36 <saurabhnanda> vision = what should the installation + package + build tool for Haskell look like. 
01:06:47 <hvr> LordBrain: or lens+FTP vs classy-prelude etc
01:06:47 <ventonegro> grantwu: exactly
01:06:58 <grantwu> It doesn't matter if cabal will be better in 6 months, if haskell newcomers already have a bad impression of the haskell ecosystem
01:07:01 <MarcelineVQ> hmm, cabal-sandbox works now grantwu
01:07:18 <ezyang> Let me be completely clear. If I am telling a beginner how to use Haskell, if I can, I will start them off on just ghci, and then, I will tell them to use Stack 
01:07:20 <grantwu> MarcelineVQ: Well, I was sort of speaking from the perspective of "when the previous argument happened"
01:07:25 <MarcelineVQ> Both options are working ones, otherwise there wouldn't be a debate :>
01:07:29 <hvr> grantwu: that's a fair point; which is why the situaation is so complicated
01:07:55 <cocreature> I don’t think anybody argues that that the cabal-sandbox ui is very friendly for a newcomer
01:08:15 * hvr even damits that pre-new-build cabal is bad for newcomers
01:08:17 <saurabhnanda> ezyang: can't that be solved within the unified tool? have a global GHC+core libs AND a tool for project-based workflows?
01:08:40 <hvr> saurabhnanda: that's what cabal new-build aims to be
01:08:46 <cocreature> the problem with cabal new-build atm is that you can run into deal breakers that mean that you need to go back to sandboxes anor stack
01:08:58 <saurabhnanda> hvr: is there a design document for "cabal new-build" somewhere?
01:08:59 <cocreature> so I’m fine using it myself but I definitely don’t recommend it to beginners
01:08:59 <hvr> cocreature: that's why it's not ready yet
01:09:06 <LordBrain> so long as the cabal people don't give up, its okay with me if new people use stack
01:09:18 <LordBrain> is there a problem with that?
01:09:30 <grantwu> LordBrain: I think the question is what do we tell new people to use.
01:09:34 <hvr> saurabhnanda: it's not a design doc, but here's the main docs: http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:09:40 <LordBrain> i personally use cabal
01:09:54 <ezyang> saurabhnanda: I mean, Stack makes some pretty big assumptions about your workflow (e.g., only one version of a package in a project). That's fine. It leads to smooth experience and easier implementation. But if you violate the assumption, well... 
01:09:54 <LordBrain> but i don't have an issue with stack
01:09:56 <hvr> saurabhnanda: thre's a few blogposts which explain the motivation/design a bit more, but I wouldn't call them design docs either
01:10:32 <ezyang> cocreature: Wait, what are the deal breakers?! (I think everything that's currently broken in HEAD is work-aroundable) 
01:10:33 <LordBrain> i think cabal's approach has more power long term
01:10:49 <LordBrain> however
01:10:56 <LordBrain> i say that not being intimately familiar with stack
01:10:58 <saurabhnanda> ezyang: is it even possible to have different packages in the same project?
01:11:01 <LordBrain> and i appreciate what stack gives
01:11:35 <ezyang> saurabhnanda: Yes. cabal-install supports it with executable deps and setup deps. And if we ever manage to solve private deps, those will do it too 
01:11:38 <hvr> saurabhnanda: but the basic design philsophy has been borrowed from Nix
01:11:47 <hvr> saurabhnanda: but limited to things cabal is authoriative over
01:11:59 <cocreature> ezyang: well maybe not deal breakers but at least using 1.24 I can’t build docs without some weird workarounds, which means I can’t upload docs which means I need sandboxes for packages because I want to upload docs
01:12:10 <ezyang> cocreature: Oh oh please don't use 1.24 ^^" 
01:12:23 <LordBrain> one issue wiht telling people to use stack, is its easier to adapt a cabal package to run on stack, than a stack package to work in cabal & arbitrary package set
01:12:23 <ezyang> I gave acfoltzer a workaround for the haddock thing 
01:12:50 <hvr> ezyang: that was before the rudimentary new-haddock, wans't it?
01:12:52 <saurabhnanda> I don't know. I strongly feel this is a "lack of unifying vision" problem. Figure out what a good tool looks like. what sensible default should be. What advanced overrides should be possible and rally everyone around this vision. Build one kickass tool. Not 5 half-baked ones.
01:12:53 <cocreature> ezyang: sorry but I tend to stick to released versions for the most part. if master is ready make a release :)
01:13:05 <ezyang> https://github.com/haskell/cabal/issues/3535 
01:13:21 <ezyang> cocreature: Heh 
01:13:24 <hvr> cocreature: at the leatest, cabal 2.0 will hit a relase shortly before ghc 8.2 :-)
01:13:29 <ezyang> saurabhnanda: But this process takes time! 
01:13:40 <ezyang> Meanwhile Stack is solving real problems for Haskell people who actually need to get things done 
01:13:44 <ezyang> What is wrong with that 
01:13:50 <cocreature> ezyang++
01:13:59 <tdammers> one issue that hasn't been mentioned enough, IMO, is the different needs of newcomers vs. academic users vs. industry
01:14:06 <saurabhnanda> ezyang: I'm sure if the people in-charge (would it be Haskell.org committee?) start a structured process, the community will respond positively.
01:15:01 <cocreature> ezyang: tbf I use cabal master most of the timebut I ran into a few problems in the past (not present in 1.24) that have all been fixed relatively quickly but still I’m not willing to depend on it too much
01:15:07 <saurabhnanda> tdammers: yes, that's a good point. It should be handled in the design/vision document.
01:15:18 <ezyang> cocreature: perils of head 
01:15:52 <cocreature> yep
01:15:57 <LordBrain> i atually think we need more diversity not less... i kinda wish there were more compilers
01:16:02 <saurabhnanda> I mean if the RFCs for language extensions can be so well thought-through, why can't the build tools get the same treatment? they're an equal part of the core Haskell ecosystem.
01:16:06 <LordBrain> am i crazy?
01:16:24 <tdammers> LordBrain: no, it's just that the current economics of the Haskell ecosystem aren't favorable for that to happen
01:16:28 <ezyang> While we're on the subject, we need a new version of Cabal library. Like, rewritten from scratch 
01:16:40 <LordBrain> fair enough
01:16:47 <saurabhnanda> LordBrain: different perspectives. I've learnt in life that these are cycles that drive progress. Centralization and decentralization both need to exist in different proportions in different times. The circle of life.
01:17:10 <tdammers> I would really love to see a Cabal (or something else, for that matter) that could "enforce" PVP
01:17:15 <cocreature> ezyang: don’t you finish your phd soon? then you need something to kill all the free time you suddenly have :P
01:17:20 <saurabhnanda> tdammers: what's PVP
01:17:20 <LordBrain> well, part of it is about allocating resources
01:17:25 <LordBrain> i mean
01:17:26 <tdammers> Package Version Policy
01:17:32 <ezyang> "yeah, then I am going to work for $bigcorp and disappear off the earth" 
01:17:54 <tdammers> rules like "if you remove anything from the public API, you have to bump the "major" version"
01:18:11 <saurabhnanda> link for others -- http://pvp.haskell.org
01:18:17 <tdammers> ^ that
01:18:21 <saurabhnanda> tdammers: semantic versioning?
01:18:32 <tdammers> saurabhnanda: similar, but not exactly semver
01:18:36 <cocreature> ezyang: hello don stewart
01:18:41 <tdammers> saurabhnanda: conceptually pretty much the same though
01:18:48 <LordBrain> tdammers, yes, and depending on a particular type signature or something rather than a package and  version
01:18:55 <tdammers> LordBrain: you need both
01:19:23 <tdammers> LordBrain: or rather, I'm fine with using package versions for this, I'd just like a tool that can verify the correctness of a particular package version number
01:19:28 <LordBrain> it would be nice to say i need an api that matches this pattern, any package which does it... i think the backpack project or whatever was trying to get there
01:19:33 <ezyang> tdammers: This is something that I've thought about and it's pretty rough 
01:19:39 <ezyang> LordBrain: Yes, that's Backpack 
01:20:00 <tdammers> ezyang: well, yes, my gut feeling says that it's straightforward in theory, but pretty hairy in practice
01:20:00 <bartavelle> tdammers, it's particularly nice in the Elm world, where the uploaded forces you to bump versions properly
01:20:05 <bartavelle> s/uploaded/uploader/
01:20:06 <ezyang> tdammers: For example, in the situation of a reexport, version number is not good enough 
01:20:24 <ezyang> because you need to also say something about the version choice of your dep 
01:20:54 <tdammers> ezyang: that, or mostly compile the dependency and drill down to figure out whether it's technically the same thing or not
01:21:03 <ezyang> Similarly, PVP doesn't say much about type identity changes 
01:21:16 <tdammers> well yes
01:21:17 <hvr> ezyang: what do you mean by type identity changes?
01:21:42 <saurabhnanda> tdammers: is there a section which describes how PVP is different from SemVer?
01:21:49 <ezyang> tdammers: No, what I'm saying is, even if you had this tool, it would tell you were violating ALWAYS if you had a reexport 
01:22:18 <hvr> ezyang: fwiw, the PVP does say that you must restrict your packages' deps to comply w/ the PVP because of stuff you may reexport or otherwise leak in your API from your deps
01:22:24 <hvr> (including semantics)
01:22:34 * hackagebot declarative 0.3.3 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.3.3 (JaredTobin)
01:22:36 <ezyang> hvr: Right but that's a totally unreasonable restriction 
01:22:48 <hvr> ezyang: w/o it, the PVP breaks down
01:23:18 <ezyang> OK, re type identity changes, say that you have two abstract data types T in module M and N. If M.T and N.T become nominally the same, does that require a version bump? 
01:23:25 <jaziz> hm
01:23:28 <jaziz> How long do bans last?
01:23:40 <ezyang> hvr: I think that is more of an indictment against version numbers 
01:23:59 <hvr> ezyang: yeah, version numbers are a very condensed contract
01:24:09 <hvr> ezyang: but we don't have yet anything better
01:24:18 <hvr> (for Haskell at least)
01:24:46 <hvr> and even if we had API signatures w/ semantic contracts attached
01:24:54 <hvr> you'd have come up wiht a solving mechanism
01:25:13 <ezyang> yeah... 
01:25:13 <hvr> which is definitely a lot harder than constraint solving over version numbers :-)
01:25:27 <ezyang> well, Duncan thought we should just translate it back into version numbers 
01:25:45 <hvr> you'd lose the information
01:25:52 <hvr> and would be back to square one imho
01:25:55 <bartavelle> or have crazy version numbers ?
01:26:08 <bartavelle> (and crazy solving algorithms too)
01:26:56 <hvr> ezyang: i.e. how do you find a homomorphism to version-ish numbers that retains the information that an API signature is compatible to another one?
01:26:56 <ezyang> well, you could handle reexports with version numbers if you add the concept of, "my version is this, BUT I have a public dependency and you better bound that or you haven't bound my API" 
01:27:30 <ezyang> i mean, all version bounds are, are input to the constraint solver s.t. if you satisfy the bounds, it typechecks 
01:28:04 <ezyang> so in principle, it's always doable, because you could always just compute for each config whether or not it works (looking at just the interfaces) 
01:28:27 <hvr> ezyang: you mean running a type-checker as part of the solver? :)
01:29:18 <ezyang> hvr: The point is that you run the typechecker to generate version bounds. You then feed those to the solver 
01:29:24 <hvr> ok
01:29:32 <ezyang> the typechecker gets run before you upload the package 
01:29:36 <hvr> ezyang: but as usual, the typechecker only catches type-cahnges
01:29:58 <hvr> ezyang: so we'd still need some kind of semver :-)
01:30:01 <ezyang> you know what I mean :P 
01:30:11 <saurabhnanda> I just realized there's also this human-centric issues of Hakell wizards trying to think about what would be right for beginners. It's very tough to do that. Most UX designers and product managers fail to do it as well.
01:30:14 <ezyang> this is like, a disclaimer 
01:30:20 <ezyang> SURGEON GENERALS WARNING 
01:30:20 <hvr> ezyang: yeah, but on top of that, we'd still need semver 
01:31:32 <hvr> ezyang: or alternatively, we attach {-# SEMVER x.y.z #-} annotations to functions :-)
01:31:51 <hvr> and then the respective dual thing to use-sites :3
01:32:09 <hvr> then the typechecker can collect that too 
01:32:38 <ezyang> saurabhnanda: Add on to it the fact that we use the tools we build, so we think we know what we need ;) 
01:32:44 <hvr> I mean, whatever we do, we need to somehow capture the semantic contract
01:33:10 <hvr> if we're serious about encoding API compatibility
01:33:59 <hvr> without it we're only encoding compilability
01:34:17 <ezyang> saurabhnanda: In any case, are you interested in helping with the Cabal library (that bit is shared between Stack and cabal-install) 
01:35:47 <ongy> :t ap
01:35:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
01:35:51 <ongy> :t (<*>)
01:35:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:36:04 <ongy> is there a reason ap is on monad? historical?
01:36:28 <bartavelle> it wouldn't be useful on applicative, as you already have (<*>) :)
01:37:17 <saurabhnanda> ezyang: In terms of actual code, not yet. In terms of brainstorming on a design doc -- yes. Wrt actual code, I'm trying to find a project where my current skills can be utilised for the best impact. I was thinking of something along the lines of better documentation sites (better searching, UX, cross-linking, etc) for Hackage/Stackage.
01:37:44 <dmj`> ongy: Applicative wasn't always a super class of Monad
01:38:43 <ezyang> ongy: It incidentally is helpful for letting you define Monad, and then default applicative to the monad impl 
01:38:44 <geekosaur> ongy, ap and liftM* were Applicative before Applicative even existed
01:40:14 <saurabhnanda> ezyang: did you have something specific in mind?
01:40:50 <Koterpillar> Is "1.0T" shown in htop output for my Haskell process going to cause me problems when I want to dump the core of this process?
01:40:57 <bartavelle> anybody knows of a way to display my Haskell data types for consumption by non-programmers ? I have to produce a data model :/
01:41:06 <dmj`> anyone know if there's like an inline-objective-c project? much like inline-c
01:41:26 <ezyang> saurabhnanda: there's been a lot of chatting and it's good to turn this into useful coding ;) 
01:41:37 <geekosaur> Koterpillar, no because most of the pages are not mapped
01:41:53 <ongy> so mostly historical. with a hint of it's useful now?
01:42:11 <ezyang> saurabhnanda: Re cross-linking, a lot of this has to do with lack of infrastructure and process for handling this 
01:42:20 <saurabhnanda> ezyang: please give me some links to do some background reading. Let me understand the technical landscape better.
01:43:17 <ezyang> that's not something that can be solved with a design doc. It is solved by talking to the stakeholders with bits, figuring out what's going on, figuring out why it's hard to make changes, and then implementing solutions to make it easier to do so 
01:43:49 <ezyang> saurabhnanda: Are you specifically interested in website things, or Cabal bits? One of these I'm a lot better equipped to giveinfo 
01:44:36 <saurabhnanda> ezyang: I know I can do a good job on the website things. I need to read-up on the cabal library. I'm just an end-user of the cabal library. so need to do a little more reading on what it does and how.
01:46:11 <ezyang> Like, for example, let's pick an easy website task. Sometimes when people google for GHC they get an old version of the manual. It would be helpful if the page said so and people could get sent to the right version 
01:46:19 <ezyang> "easy" 
01:46:44 <ezyang> OK. In a normal, functional organization, you'd just go ahead and fix it. 
01:46:58 <saurabhnanda> ezyang: https://github.com/haskell/cabal ?
01:47:18 <saurabhnanda> ezyang: I have faced that issue. Wasted a day because of that.
01:47:35 <ezyang> But this is open source infrastructure we're talking about here. There is probably some ridiculous reason why this can't be done easily. It takes patience to keep fixing things until you can actually fix the symptom. But it is much appreciated 
01:47:47 <ezyang> that is the Cabal repo 
01:48:27 <ezyang> (at a guess, the HTML is generated by the build system for the old version of GHC so there isn't actually a convenient way to patch in extra notices without rebuilding the entire docs) 
01:48:59 <geekosaur> ongy, most of the core Monad-s have direct Applicative instances. many others back-form Applicative using return and ap instead of writing direct Applicative instances, because that was the easy way to retrofit an Applicative instance to them; in many of those cases it's not really worth writing direct instances.
01:49:21 <ezyang> (and now you think about what the root cause here is, and maybe it's, the docs are hosted as static html pages rather than something dynamic where you can more easily slap on the "outdated" notice) 
01:49:21 <geekosaur> also much existing code already uses ap, and there's no good reason to rewrite it all using Applicative
01:49:56 <saurabhnanda> ezyang: there's a solution for that as well. Using client side JS.
01:50:20 <saurabhnanda> ezyang: in every page inject a small JSON which has the list of available versions. Write client-side JS to look at that JSON and render the notice on the browser.
01:52:00 <bartavelle> how would you inject that client side js in the first place ?
01:52:18 <ezyang> saurabhnanda: I think that is a fine solution. And now you have to decide how to get the JS onto all the old manual pages 
01:52:35 * hackagebot log 0.5.4 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.4 (MikhailGlushenkov)
01:52:39 <saurabhnanda> bartavelle: when the docs are getting built (static HTML pages are being written)
01:53:07 <ezyang> saurabhnanda: But keep in mind for something like the GHC 7.2 docs it may be a trial to even get the build system to run to build the docs 
01:53:22 <ezyang> we didn't have submodules until 7.10 
01:53:31 <saurabhnanda> ezyang: recompile all docs. OR write a small hackish script which manipulates existing HTML directly.
01:54:04 <ezyang> plus the build system insists on building GHC before the docs and you don't have an early enough version of GHC to bootstrap because GHC can't bootstrap backwards 
01:54:46 <saurabhnanda> so, for version less than X, paste the json+JS directly in the HTML head (Very simple transformation) 
01:55:02 <saurabhnanda> for all package uploads going forward, add it to the doc script.
01:55:15 <saurabhnanda> change the server infra to use simple SSIs (server side includes)
01:55:18 <ezyang> OK right. And now it's probably solved 
01:55:20 <ongy> so what would be the way to get an old ghc? bootstrap all the way through from whatever could be bootstraped by a C compiler?
01:55:31 <ezyang> ongy: Your best bet is to find an old binary 
01:55:39 <dmj`> nix has a lot of old ghc's
01:55:41 <dmj`> http://lpaste.net/329972
01:55:48 <saurabhnanda> rewrite all HTML pages to include respective SSIs. Keep the SSIs up-to-date.
01:55:50 <dmj`> probably prebuilt
01:56:17 <ezyang> saurabhnanda: Nah, I like the JS better 
01:56:33 <saurabhnanda> ezyang: SSIs will still be required.
01:56:46 <saurabhnanda> ezyang: the JSON will keep changing with every new version of package being uploaded
01:57:03 <saurabhnanda> ezyang: do you want to keep running the same HTML transformation script on every package version?
01:57:13 <saurabhnanda> the SSIs will have the latest version of the JSON
01:57:29 <ezyang> isn't the point of the JS to load the JSON from a well-known URL which gets updated as new things get posted? 
01:57:46 <bartavelle> perhaps an easy way is to hint at google that some pages are more up to date ? I have no clue if that's even possible, as google does like to be the one choosing which page is "better"
01:58:08 <bartavelle> (then to hint at the other search engines)
01:58:48 <ezyang> saurabhnanda: OK, and keep in mind, these changes need to be applied to HTML pages which live on the same server as the ones that actually have the source code tarballs on them, and for security reasons only a few people have bits, because a compromise means that the GHC binaries could get backdoored 
01:59:19 <ezyang> (I'm speaking from experience! I wanted Cabal docs to automatically upload to Cabal website and I was told "no can do" for this reason) 
01:59:48 <ongy> that could be considered infrastructure msitake though. Is there a good reason to host the docs with the source tarballs?
02:00:14 <saurabhnanda> bartavelle: good point. Is there an easy way to figure out the package name and version from the URL itself? what you're suggesting, may work
02:00:27 <saurabhnanda> ezyang: which repo should I be looking at? cabal or hackage?
02:00:53 <ezyang> So, for specifically the GHC docs on haskell.org, you should talk to the GHC release manager. 
02:01:03 <ezyang> because I think it's only a few people who have access to that server 
02:01:56 <saurabhnanda> ezyang: I thought we were discussing the hackage docs? for various cabal packages
02:02:24 <ezyang> oh, I was talking about GHC docs 
02:03:01 <ezyang> For Hackage, I guess the hackage repo is a good place to start. But the deploy process for hackage is totally opaque to me, so... 
02:04:11 <grantwu> Urgh, can anyone help me with DeriveFunctor
02:04:15 <saurabhnanda> ezyang: the problem is more pronounced with hackage, btw
02:04:44 <grantwu> http://lpaste.net/329973 I've got this and I want fmap to touch the a's only
02:05:10 <ezyang> saurabhnanda: In this case, you're not even going to have access to the doc generator, because people can upload docs manually 
02:05:12 <grantwu> I've added the bug I encounter
02:05:31 <ezyang> grantwu: If you can, swap the params 
02:05:35 <saurabhnanda> ezyang: they would be generating docs using some tool, right? some standard tool. Patch the tool, I guess.
02:05:37 <ezyang> otherwise it's impossible to define a functor on a 
02:05:58 <ezyang> saurabhnanda: Right but you cannot reasonably expect everyone to reupload docs for things released years ago 
02:06:05 <saurabhnanda> ezyang: gtg for a meeting right now. Will come back to this later in the night.
02:06:11 <ezyang> well I'm going to bed 
02:06:15 <saurabhnanda> ezyang: for that -- the same HTML transformation hack. 
02:06:19 <saurabhnanda> ezyang: tomorrow, in that case.
02:06:22 <grantwu> ezyang: I can.  but I thought functors took the first type variable...
02:06:23 <grantwu> I guess not
02:06:30 <ezyang> grantwu: Other way 
02:06:36 <ezyang> Functor (F a b c) 
02:06:43 <ezyang> functorial in d of F a b c d 
02:07:14 <grantwu> Well that's convenient
02:07:22 <ezyang> saurabhnanda: I'm not the best person to ask about how to fix Hackage, because I had a thing that needs fixing (reexports) and I got sick of trying to figure out how to make Hackage handle it correctly 
02:07:35 <grantwu> I actually swapped them around because I thought it was necessary to get Functor working >_<
02:10:02 <bartavelle> grantwu, this will be the same for all typeclasses. If you need bifunctor that will work on the last two type parameters
02:18:13 <sigrlami_> trying to save long text field with postgresql-simple to db and it gives me `is not a valid hexadecimal digit` , how can I fix this? Docs says that everything is escaped automatically
02:18:44 <sigrlami_> and it shouldn't try to convert to hexedecimal, since it's char
02:19:20 <grantwu> Anyone have a good workaroud for really long pattern matches?
02:19:32 <grantwu> I have a monstrosity that looks like:
02:19:37 <grantwu> isolateStmt (HIR.Asgn (HIR.LvalMem tag (HIR.DotFields fields (HIR.LvalMem innerTag (HIR.ArrayIndex index array)))) exp) = undefined
02:23:16 <lyxia> grantwu: you could define pattern synonyms
02:23:23 <Cale> grantwu: Put some line breaks in it and line things up vertically?
02:23:48 <Cale> oh, I guess that's very nested
02:24:23 <Cale> Any chance you could import that module unqualified, or at least the data constructors?
02:24:41 <grantwu> I could change it from HIR to H, I suppose
02:24:58 <grantwu>  Meh, I think I will just expand my editor and live with it...
02:29:35 <merijn> grantwu: PatternSynonyms?
02:29:53 <merijn> Assuming this is a pattern that occurs multiple times
02:30:00 <grantwu> I'll look into them later
02:49:04 <grantwu> Oh no, I just wished that I had inheritance.
02:49:11 <grantwu> Or refinement types.
02:50:12 <grantwu> I need to convert B to B', I have a function that converts A to A', and all Bs are kind of like As, so I am going to write casting functions that go from B to A and A' to B'
02:50:39 <grantwu> (however not all As are Bs)
02:52:38 <Cale> You could write a lens
02:53:16 <grantwu> I don't know what a lens is!
02:54:07 <grantwu> I mean, I vaguely have heard of them
02:54:28 <grantwu> I am not really sure that it will get me anything other than a lot of syntactic sugar
02:55:18 <grantwu> Yeah, looking at my types, I have one datatype that is basically two constructors out of another datatype.
02:55:33 <Cale> Well, if you're never going to compose your lenses, then yeah, it won't get you much
02:55:56 <Cale> oh, I see
02:56:00 <Cale> then it would be a prism :)
03:13:09 <piyush-kurur> looks like I was a bit late for the cabal vs stack slugfest ;-)
03:13:53 <piyush-kurur> saurabhnanda: cabal does somethign that stack does not. It tries to solve the package constraints
03:14:09 <piyush-kurur> stack is good but we do need something like cabal also
03:15:49 <piyush-kurur> making sure a package works with cabal is a good way to bring discipline in your package (as a developer). 
03:15:56 <piyush-kurur> it makes your package more portable
03:23:12 <lgstate> is there any PL which offers  code that is easier to read than haskell? (as in you're reading a new library for the first time)
03:23:17 <lgstate> I feel like type signatures beats everythihng
03:25:12 <rightfold> easier to read is subjective and depends on your background
03:40:58 <agocorona> I think that easier to read (and write) is related with composability since the mind decompose a problem in pieces and combine them
03:41:34 <agocorona> That's why FP code looks better than OOP
03:43:57 <agocorona> maybe the most readable language can write requirements and run them
03:58:44 <reygoch> hi, did anyone use mustache for templating?
03:58:54 <reygoch> I'm having trouble including partials
04:07:39 * hackagebot diagrams-lib 1.4.0.1 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4.0.1 (BrentYorgey)
04:10:43 <kuribas> xb
04:21:32 <kuribas> is this possible?  do {x | test1 <- action1; test2 <- action2; otherwise <- action3}
04:22:40 * hackagebot asciidiagram 1.3.3 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.3.3 (VincentBerthoux)
04:28:19 <joe9_> Is it wrong to use Data.Default?
04:29:00 <pavonia> kuribas: It should work with square brackets and -XMonadComprehensions
04:30:25 <kuribas> pavonia: I am using multiway if now...
04:31:20 <kuribas> hm I guess I want this: {x | test1 <- action1 | test2 <- action2 | otherwise <- action3}
04:32:08 <kuribas> I am using this now: do {x <- if | test1 <- action1 | test2 <- action2 |
04:32:08 <kuribas> 	    otherwise <- action3}
04:32:14 <pavonia> What do you want that to desugar to?
04:32:40 * hackagebot regex-do 1.3 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.3 (procione)
04:33:32 <kuribas> do {x <- if test1 then action1 else if test2 then action2 else action3}
04:35:16 <kuribas> wait I need '=' not '<-'
04:37:10 <pavonia> Not sure if comprehensions are the right tool for this, your multiway-if is probably fine
04:39:48 <kuribas> IMHO if should have been a function, not syntax
04:48:15 <Shoue> s
04:48:59 <KaneTW> kuribas: try guard and <|>
04:49:34 <KaneTW> it won't desugar to the ifs but it might be a bit prettier
04:49:48 <KaneTW> oh
04:49:52 <KaneTW> never mind missed the x <-
04:50:07 <merijn> uh, what's wrong with let + guards?
04:50:26 <KaneTW> it looks fine
04:50:39 <KaneTW> i'm just thinking of other ideas since he wanted something else
04:50:59 <merijn> kuribas: There's 'bool' the eliminator for Bool that you can use like an if function
04:51:17 <merijn> > bool False 'a' 'b' -- note the "reverse" order, though
04:51:20 <lambdabot>  error:
04:51:20 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘Char’
04:51:20 <lambdabot>      • In the second argument of ‘bool’, namely ‘'a'’
04:51:28 <merijn> oh, duh
04:51:35 <merijn> > bool 'a' 'b' False -- note the "reverse" order, though
04:51:38 <lambdabot>  'a'
04:51:42 <merijn> :t bool
04:51:44 <lambdabot> a -> a -> Bool -> a
04:52:38 <kuribas> merijn: I'll need an extra name with let
04:53:12 <kuribas> merijn: I always liked (?) :: Bool -> a -> a -> a
04:54:55 <kuribas> > let (?) t a b = if t then a else b in x = 4; x == 0 ? "zero" $ x < 0 ? "negative" $ x > 0 ? "positive"
04:54:58 <lambdabot>  <hint>:1:41: error:
04:54:58 <lambdabot>      parse error on input ‘=’
04:54:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:55:17 <kuribas> > let (?) t a b = if t then a else b; x = 4 in x == 0 ? "zero" $ x < 0 ? "negative" $ x > 0 ? "positive"
04:55:20 <lambdabot>  error:
04:55:20 <lambdabot>      • Couldn't match expected type ‘t0 -> t’ with actual type ‘Bool’
04:55:20 <lambdabot>      • The first argument of ($) takes one argument,
04:55:41 <kuribas> > let (?) t a b = if t then a else b; x = 4 in x == 0 ? "zero" $ x < 0 ? "negative" $ "positive"
04:55:44 <lambdabot>  error:
04:55:44 <lambdabot>      • Couldn't match expected type ‘t0 -> t’ with actual type ‘Bool’
04:55:44 <lambdabot>      • The first argument of ($) takes one argument,
05:00:05 <kuribas> hmm
05:02:44 <kuribas> it used to work
05:03:11 <merijn> kuribas: You probably messed up the fixity compared to $
05:03:40 <kuribas> > let infixl 1 ?; (?) t a b = if t then a else b; x = 4 in x == 0 ? "zero" $ x < 0 ? "negative" $ "positive"
05:03:43 <lambdabot>  "positive"
05:03:49 <kuribas> :-)
05:45:13 <andrevdm> quit
05:45:35 <buglebudabey> im trying to use EasyPlot to plot some data points, my code runs but nothing shows up when I run the prgram, any thoughts? http://lpaste.net/330013
05:46:15 <saurabhnanda> ezyang: around?
05:56:11 <kuribas> @hoogle fix
05:56:14 <lambdabot> Data.Function fix :: (a -> a) -> a
05:56:15 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
05:56:15 <lambdabot> Agda.Compiler.JS.Substitution fix :: Exp -> Exp
06:03:47 <kuribas> buglebudabey: do you have the datafile?
06:04:17 <buglebudabey> i do, but i've been working on it and my code has changed a bit, so i'll repost the problem when i come to a point of not knowing what to do kuribas 
06:04:43 <kuribas> buglebudabey: btw you don't need multiple let keywords in a do block
06:05:02 <buglebudabey> kuribas oh i can just indent the rest of the definitions?
06:05:06 <kuribas> yeag
06:05:08 <kuribas> yeah
06:05:53 <kuribas> you can also put the types on their own line if you like.
06:12:44 * hackagebot modbus-tcp 0.2.1.1 - Communicate with Modbus devices over TCP  https://hackage.haskell.org/package/modbus-tcp-0.2.1.1 (RoelVanDijk)
06:17:02 <acarricoish> https://web.archive.org/web/20150112141909/http://www.jlekstrand.net/jason/projects/wayland/language-bindings-guide
06:17:31 <acarricoish> Sorry, please ignore the wayland spam.
06:21:31 <buglebudabey> kuribas here is my new code http://lpaste.net/330013, now the data is being read in properly but i'm getting the following error:
06:21:32 <buglebudabey> gnuplot: rawSystem: runInteractiveProcess: exec: does not exist (No such file or directory)
06:21:43 <buglebudabey> which i think has to do with gnu plot itself and not my code
06:22:39 <buglebudabey> i've never explicitly download gnu plot, i assume EasyPlot did that for me
06:22:40 <kuribas> buglebudabey: yeah, it calls the gnuplot program
06:22:57 <kuribas> buglebudabey: I think you need to put in the path yourself
06:23:22 <buglebudabey> kuribas i'd have to download it first or is it already in there
06:23:37 <kuribas> you have to download it
06:25:36 <buglebudabey> alright, i have it, but it's just a big folder full of files and no executable, so i'm not exactly sure what to do from here
06:27:15 <kuribas> windows?
06:29:37 <buglebudabey> mac, i'm using brew to properly install it atm
06:31:36 <buglebudabey> should homebrew automatically add it to my path?
06:33:44 <buglebudabey> ok so now it plots to a PNG but cannot open a window with the plot points
06:36:53 <kuribas> check if X11 is supported in the gnuplot binary.
06:56:55 <buglebudabey> kuribas eh, i can't get it to work, i'm getting different recommendations when searching for the problem
06:57:45 * hackagebot solga 0.1.0.2 - Simple typesafe web routing  https://hackage.haskell.org/package/solga-0.1.0.2 (PatrickChilton)
06:58:02 <kuribas> buglebudabey: I would try gnuplot interactively, and see if you can get X11 output to work.
06:58:19 <buglebudabey> it has the same error
06:58:37 <kuribas> then the problem is with the binary
06:58:41 <buglebudabey> gnuplot: unable to open display ''
06:58:41 <buglebudabey> gnuplot: X11 aborted.
06:59:33 <kuribas> did you use these: http://ricardo.ecn.wfu.edu/pub/gnuplot/
07:00:23 <buglebudabey> i  ran 'brew install gnuplot --with-x11'
07:00:49 <kuribas> hm, I don't know enough of mac to help you...
07:01:00 <buglebudabey> it's alright, im just glad i can plot to a png
07:01:05 <buglebudabey> thanks for your help
07:01:09 <kuribas> np
07:02:45 * hackagebot solga-swagger 0.1.0.2 - Swagger generation for Solga  https://hackage.haskell.org/package/solga-swagger-0.1.0.2 (PatrickChilton)
07:16:16 <ggVGc> If I ever earn a dollar from writing a line of haskell
07:16:20 <ggVGc> I'll be glad
07:17:21 <capisce> sounds like a low bar
07:17:28 <ggVGc> really?
07:17:30 <ggVGc> I dunno
07:17:35 <ggVGc> capisce: have you earnt a dollar from your haskell?
07:18:10 <capisce> no, although I haven't tried
07:19:02 <capisce> if micropayments were ubiquitous I'm sure someone would show mercy on me and donate $1 for a haskell oneliner
07:19:54 <capisce> so I'd set the monetary threshold a bit higher before calling it a success
07:21:06 <ggVGc> okay
07:21:07 <ggVGc> 100 dollars
07:21:59 <capisce> I'll allow it
07:22:20 <capisce> you're justified in being glad if that happens
07:22:57 <kuribas> what does this mean? "installed package info from too old version of Cabal (key field does not match id field)"
07:22:57 <kuribas>  
07:23:28 <kuribas> capisce: I am hoping to get funding for my haskell project :)
07:24:23 <sm> kuribas: I donI'm thinking
07:24:42 <sm> woah, mind spinning...
07:25:29 <sm> cabal too old ?
07:26:21 <kuribas> sm: I upgraded it...
07:26:46 <kuribas> maybe the sandbox is too old?
07:28:46 <kuribas> Here is the whole error: http://lpaste.net/330026
07:29:50 <byorgey> kuribas: could be, did you try deleting the sandbox and reinstalling in a fresh one?
07:30:05 * byorgey has never seen that specific error before
07:31:07 <nitrix> kuribas: Just to make sure this isn't a misconception, are you expecting to work _on_ haskell-truetype, or just need it as a dependency for a project of yours?
07:31:35 <kuribas> nitrix: I am building my library
07:31:51 <nitrix> haskell-truetype being your library?
07:31:54 <kuribas> yeah
07:31:58 <nitrix> Gotcha.
07:32:21 <nitrix> Is it open-source?
07:33:04 <kuribas> yeah
07:33:14 <nitrix> Found it :D
07:33:36 <kuribas> wait, I haven't pushed all changes.
07:34:28 <kuribas> https://github.com/kuribas/haskell-truetype
07:38:21 <nitrix> kuribas: What is your version of cabal?
07:38:22 <shapr> I'd like to donate random chunks of $100 to various Haskell libraries
07:38:26 <DELB_> if you had a function that computes the average of three numbers like I have done here:
07:38:33 <DELB_> averageOfThree :: Float -> Float -> Float -> Float
07:38:34 <DELB_> averageOfThree  a b c = (a + (b + c)) / 3.0
07:39:08 <DELB_> How do you then take whatever the user inputted for that function and test to see if the numbers that were inputted for the first function are less than the average from the first function?
07:39:15 <DELB_> But you need to call a second function to do that
07:39:17 <kuribas> nitrix: 1.22.2.0
07:39:27 <capisce> shapr: how random?
07:40:05 <nitrix> kuribas: And you're using GHC8 I suppose?
07:40:09 <kuribas> yes
07:40:12 <shapr> I'd totally subscribe to pay $100 a month if I got to choose a list of Haskell libraries to improve.
07:40:15 <lyxia> DELB_: what first function
07:40:24 <nitrix> kuribas: If you update your version of cabal, the error will go away. There's a few incompatibilities with the old cabal and the newer GHC8.
07:40:39 <capisce> it's a shame it's still not trivial to reward people with micropayments for blog posts, good forum posts, or quality IRC replies
07:40:42 <nitrix> Sorry, GHC8's package registration mechanism.
07:40:56 <DELB_> lyxia: kind of confusing I know
07:41:04 <DELB_> the first function I have is averageOfThree
07:41:05 <lyxia> Indeed.
07:41:16 <DELB_> I want to do a second function that gets the inputs of averageOfThree
07:41:28 <DELB_> and then tests to see if those numbers are less than the average outputted from the first function
07:41:30 <DELB_> does that make sense?
07:41:46 <nitrix> kuribas: Your project on cabal 1.24.0.0 builds "without errors" (if I ignore that your stuff is work-in-progress).
07:41:53 <kuribas> nitrix: I upgraded cabal, but it was installed in my sandbox :-0
07:42:08 <nitrix> Oh, delete the sandboxes too :3
07:42:33 <RasmusWL> capisce, true. https://flattr.com/ never really got that popular did it?
07:42:57 <shapr> wow, what just happened?
07:43:07 <kuribas> DELB_: not really
07:43:20 <shapr> capisce: it's free to send bitcoin, yeah?
07:43:39 <lyxia> DELB_: whether a,b,c are larger or smaller than their average? What result are you expecting? Could you work us through some examples
07:43:59 <capisce> most people still don't have bitcoin
07:44:21 <DELB_> lyxia: whether a b and c are smaller than the average outputted from averageOfThree
07:44:54 <DELB_> and this is put into a function, probably to be called as "howManyBelowAverage"
07:45:18 <lyxia> "how many" is quite different from "whether"
07:45:35 <DELB_> Write a Haskell function that computes the average of three numbers. (Note: For simplicity you may use input type Float.) Add another function called howManyBelowAverage that computes how many of these three numbers are below the average.
07:45:40 <DELB_> That's the question I have to do
07:45:47 <DELB_> Done the first bit
07:46:58 <kuribas> > fromEnum (1 < 2) + fromEnum (3 < 2)
07:47:01 <lambdabot>  1
07:47:08 <kuribas> DELB_: ^
07:47:30 <DELB_> wait what
07:48:02 <kuribas> > (fromEnum True, fromEnum False) -- DELB_
07:48:05 <lambdabot>  (1,0)
07:48:46 <DELB_> I'll be back shortly, I gotta go now though :P
07:48:52 <DELB_> thanks
07:52:47 * hackagebot gruff 0.4 - fractal explorer GUI using the ruff library  https://hackage.haskell.org/package/gruff-0.4 (ClaudeHeilandAllen)
07:52:49 * hackagebot gruff-examples 0.4 - Mandelbrot Set examples using ruff and gruff  https://hackage.haskell.org/package/gruff-examples-0.4 (ClaudeHeilandAllen)
07:57:47 * hackagebot ruff 0.4.0.1 - relatively useful fractal functions  https://hackage.haskell.org/package/ruff-0.4.0.1 (ClaudeHeilandAllen)
08:22:48 * hackagebot criterion 1.1.4.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.1.4.0 (BryanOSullivan)
08:37:02 <joe9_> is it considered a bad practice to use Data.Default?
08:37:28 <paolino> :t toListOf (traverse . _2 . _Just) :: [(Int,Maybe a)] -> [a]
08:37:30 <lambdabot> [(Int, Maybe a)] -> [a]
08:37:42 <ertesx> joe9_: depends on who you ask, but even when it's considered bad practice, it's usually a rather innocent kind of bad
08:38:12 <joe9_> ertesx, ok, Thanks.
08:38:27 <paolino> is it possible to filter on second to have [(Int, Maybe a)] -> [(Int,a)] ?
08:39:07 <ertes> joe9_: background: mempty is usually a more well-principled "default value"
08:39:21 <ertes> joe9_: https://hackage.haskell.org/package/acme-default
08:42:00 <Cale> joe9_: So long as you check to see if it makes more sense to have a Monoid instance first, it's absolutely fine.
08:45:43 <joe9_> ertes: Cale, Thanks.
08:50:36 <byorgey> paolino: good question.  That seems like it should be perfectly valid, but I can't think of a good way to do it.  I'm not super familiar with the entire lens library though.
08:50:42 <ph88^> paolino, yes you can write a fold and check for   case snd x of  .. and i'm sure it can be written nicer than that
08:51:03 <byorgey> paolino: did you ask in #haskell-lens?
08:51:15 <paolino> :t toListOf (traverse . _Just) . fmap (\(i,r) -> (,) i <$> r)
08:51:17 <lambdabot> Traversable t => t (a, Maybe b) -> [(a, b)]
08:51:45 <paolino> oh didn't know there was a room for that
08:52:18 <byorgey> ph88^: can you elaborate?  I'm not sure I understand what you are suggesting
08:52:39 <ph88^> byorgey, nvm lens probably better ^^
08:54:58 <byorgey> paolino: I mean, you could probably manually write your own traversal without too much trouble, you just need to write a function of type  Applicative f => ((Int,a) -> f b) -> (Int, Maybe a) -> f (Int, Maybe b)
08:57:01 <paolino> byorgey sure, it's more to see the choices given by lenses
08:57:17 <byorgey> ok, sure
08:59:42 <byorgey> (that should be (Int,a) -> f (Int,b))
09:03:13 <glguy> toListOf ((folded .> ifolded <. folded) . withIndex) :: [(a, Maybe b)] -> [(a,b)]
09:04:06 <glguy> > toListOf ((folded .> ifolded <. folded) . withIndex) [ (1, Just 'a'), (2, Nothing), (3, Just 'b')]
09:04:09 <lambdabot>  [(1,'a'),(3,'b')]
09:04:29 <glguy> > itoListOf (folded .> ifolded <. folded) [ (1, Just 'a'), (2, Nothing), (3, Just 'b')]
09:04:31 <lambdabot>  [(1,'a'),(3,'b')]
09:04:44 <glguy> Tada?
09:05:29 <glguy> and the .> is redundant, I suppose: (folded . ifolded <. folded)
09:08:21 <byorgey> glguy: can you get a Traversal out of that?  e.g. could I apply 'succ' to all the ints paired with a Just?
09:09:49 <glguy> Sure, just traverse instead of fold
09:09:49 <glguy> (traversed . itraversed <. traversed)
09:10:02 <PhsShft> how can I implement a function that takes a handle, returns Nothing at end of file, and Just a for other character?
09:12:15 <quchen> PhsShft: "Other character at end of file"?
09:12:40 <PhsShft> quchen: I mean it it reads a then returns Just a
09:12:51 <PhsShft> **if it
09:12:51 <glguy> hIsEOF :: Handle -> IO Bool
09:13:07 <byorgey> glguy: ah, cool
09:13:22 <PhsShft> oh cool
09:15:53 <byorgey> glguy: hmm, that doesn't quite seem to do what I meant.  That gives a traversal over the things inside the Justs.  I was asking for a traversal over the things *paired with* the Justs.
09:16:08 <glguy> oh, I see
09:16:24 <paolino> glguy, I don't see the dependency on the prism
09:16:31 <byorgey> I wrote one manually and it works, I'm just curious
09:17:11 <glguy> paolino: I don't know where prisms came in
09:17:17 <paolino> _Just
09:17:45 <glguy> _Just isn't being used as a prism in these cases
09:18:08 <paolino>  :t toListOf (traverse . _Just) . fmap (\(i,r) -> (,) i <$> r)
09:18:26 <glguy> paolino: In that code _Just is being used as a fold
09:18:35 <paolino> ok
09:19:45 <paolino> I'm looking for abstracting over it
09:20:02 <glguy> byorgey: I don’t know if it’s possible to build that up from pieces. The method of using the Indexed machinery doesn’t help for that case.
09:20:31 <byorgey> glguy: ok, right.
09:23:53 <kirillow> I know a lot more Haskell than I did just a few weeks ago, but also I feel like I now know now of a lot more possibilities of coming up with really bad design. Is there a book or something on good FP design?
09:26:05 <quchen> Don’t over-abstract.
09:26:39 <quchen> Not everything needs to be maximally parametric. Type families and other type-level extensions are a slippery slope.
09:26:46 <PhsShft> :glguy So how to I use IO Bool as condition to the guards? since it’s not actually Bool  
09:26:47 <glguy> below _Just :: Prism' (a, Maybe b) (a,b)
09:27:18 <glguy> PhsShft: The same way you use any IO r, you sequence it into your larger IO action
09:27:20 <nitrix> Can an stack-based language (that is guanranteed to halt) using a circular buffer run into a problem with non-termination?
09:27:27 <glguy> do eof <- hIsEOF h; stuff with eof
09:27:52 <nitrix> (Currently am doing genetic programming with Haskell)
09:27:56 <PhsShft> ooh thanks im naive 
09:28:40 <glguy> byorgey: over (traverse . below _Just) :: ( (a,b) -> (a,b) ) -> [(a, Maybe b)] -> [(a, Maybe b)]
09:29:18 <glguy> paolino: Does below help your question?
09:31:39 <paolino> aha, that's it, thanks glguy
09:32:19 <paolino> I had some fights with alongside and I gave up
09:35:28 <paolino> can I lift (\(x,y) -> (y,x)) in the lens ?
09:35:40 <glguy> swapped
09:36:50 <byorgey> glguy: ah, below, interesting
09:36:53 <kuribas> kirillow: I'd say, work from the base up.  Create base functions to do the low level work, and work up from that.
09:37:20 <kuribas> kirillow: fortunately there are many good libraries which have good abstractions.
09:38:45 <icefall> taxonomy question: I'm mapping over nodes in a tree, supplying a function that returns (to_children, Maybe to_caller) and all the maybe's are filtered and the just's are returned to the original caller, and to_children is the state passed to that node's children.  does this thing have a name? 
09:39:41 <icefall> it's sort of like a fold but it passes different accumulations to the caller and to children
09:40:09 <byorgey> icefall: sounds like you may be interested in attribute grammars
09:43:51 <mmaruseacph2> that's a good to know concept, thanks
09:44:59 <maerwald> kirillow: imo, that's too unspecific to debate over and ppl have vastly different opinions on that matter
09:45:06 <maerwald> if you can get more specific, you might get better answers
09:46:10 <icefall> byorgey: thanks for the pointer, I'm not sure if this fits the bill or not but I'll read some of the references on the wikipedia page to better understand!
09:47:19 <paolino> glguy, looks like both *aside* and *below* are working
09:47:35 <ertes> kirillow: i don't really follow a lot of principles, except writing instances for known classes when possible and reusing patterns like 'foldr' or 'traverse' when i see them
09:47:59 <ertes> kirillow: there is no underlying grand scheme or anything…  you just train yourself to see patterns
09:48:21 <maerwald> well, following principles is very good, but that's not about specific design
09:48:23 <ertes> kirillow: and naturally you will see more of them as you learn, but the world doesn't end because you don't see all of them right now
09:48:33 <maerwald> e.g. security principles
09:48:42 <byorgey> icefall: I mean, I don't think what you're doing has a specific name.  But it sounds like it would fit within the framework of attribute grammars.
09:49:09 <byorgey> icefall: it's probably not worth using some attribute grammar framework, I just thought you might be interested to read about it.
09:49:25 <icefall> yeah! it seems cool :)
09:50:08 <ertes> maerwald: following principles is certainly a good idea, i just don't do it a lot (or perhaps it's my perception that i don't)
09:50:22 <ertes> my principle is: reuse knowledge
09:51:49 <maerwald> I follow security principles
09:52:19 <kuribas> ertes: or you aren't aware of them?
09:53:48 <ertes> could be, yeah
09:54:15 <maerwald> Following principles seems to be better than trying to follow design patterns anyway, also see https://lirias.kuleuven.be/bitstream/123456789/475853/1/icse15-yskout-cameraready.pdf
09:54:42 <maerwald> which is a study that basically shows ppl can't reasonably follow design patterns
09:55:51 <hansihe> is there a way to both pattern match and get the value itself? say I want to both match it to for example "Right _" and assign the value to a variable?
09:55:53 <ertes> design patterns are usually identified with OO patterns, which i think is a mistake:  type classes with claws could be considered "design patterns", like Monoid
09:55:58 <ertes> s/claws/laws/
09:56:09 <ertes> wow, where did that come from…
09:56:22 <systemfault> I don't know... "Design Patterns" are usually backed by "annecdotes"
09:56:26 <systemfault> Monoid is backed by maths.
09:56:28 <barrucadu> "classes with claws" sounds like it could be an exciting functional pearl-type paper
09:56:43 <ertes> hansihe: like (Right x)?
09:57:15 <ertes> hansihe: you can name any part of the pattern
09:58:37 <jani13> i am haskell
09:58:44 <jani13> xddddddddd getit
09:58:46 <maerwald> ertes: no, the design patterns in that study are not just OO
09:58:50 <jani13> ertes
09:58:53 <jani13> more like sertes
09:58:58 <jani13> l0l
09:59:00 <hansihe> ertes: sorry, probably a badly worded question. say I have a type "Either a b", I want to both match it to Right and get the value itself
09:59:34 <hansihe> i don't know if that is any better
09:59:34 <ertes> hansihe: yeah, say:  f :: Either Integer Integer -> Integer
09:59:38 <ertes> f (Right x) = x^2
09:59:47 <ertes> does that answer your question?
09:59:55 <hansihe> not the value within the either
10:00:00 <hansihe> the either itself
10:00:06 <ertes> ah
10:00:12 <ertes> f r@(Right _) = …
10:00:16 <ertes> like that?
10:00:24 <hansihe> yep, exactly
10:00:26 <hansihe> thanks
10:00:50 <hansihe> how would you have worded the question? i was unable to formulate it properly and therefore didn't find anything on google
10:01:21 <ertes> i don't know…  you didn't word it badly
10:01:32 <ertes> perhaps i would have used "the whole argument" or something
10:01:53 <hansihe> yeah, that might have gotten the point across a bit better
10:02:28 <Squarism> Anyone using spock? I wonder if theres some nice example of routing a path to a certain file?
10:02:31 <ertes> it's just the imprecision of human language at work again =)
10:02:49 <kirillow> well i have to think about that
10:02:51 <hansihe> :)
10:02:57 <kirillow> thanks
10:03:39 <ertes> kirillow: i think the closest to a "grand principle" i follow is abstract algebra
10:04:01 <ertes> together with a few extra-sharp rules for consistency, safety and security
10:04:31 <kirillow> btw is there a consice way to remove the only element from a list so that i get 'c' from ['c']?
10:04:48 <ertes> kirillow: you fold the list
10:04:55 <kirillow> well im reading up on category theory, are there good reads on security?
10:05:03 <jani13> head?
10:05:23 <jani13> .
10:05:40 <maerwald> kirillow: for haskell specifically? no
10:05:43 <kirillow> head!
10:05:47 <kirillow> of course
10:06:09 <ertes> while we're at design principles: try not to use 'head' =)
10:06:21 <maerwald> in fact, security in haskell is largely unchartered territory
10:06:21 <kirillow> but here it fits so damn well :D
10:07:44 <ertes> kirillow: here is the long version of what's wrong with 'head': https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
10:07:55 <ertes> an article, i think, every programmer (haskell or not) should read
10:08:36 <Tuplanolla> What data type should I use to carry statistical uncertainties through numerical computations?
10:08:54 <jani13> oh man
10:09:10 <PhsShft> can someone help me debug this?
10:09:11 <PhsShft> http://lpaste.net/330079
10:09:24 <ertes> (i'm not saying: "never use head!"…  i'm saying: think twice before using it)
10:09:30 <ertes> Tuplanolla: perhaps an interval type?
10:09:43 <Tuplanolla> No, not an interval type, ertes.
10:09:45 <PhsShft> so the control will return nothing if it fails, and mWhileJust uses its first argument as a test to control the iteration of its second argument.
10:09:48 <kirillow> eh?
10:09:53 <kirillow> right article?
10:09:56 <kirillow> doesnt mention head
10:10:10 <Tuplanolla> Distributions are involved here.
10:11:34 <kuribas> PhsShft: if control is a Monad you cannot directly pattern match
10:12:00 <maerwald> kirillow: head can fail and crash your program if you don't know that the list is non-empty. That's all. Nothing more.
10:12:05 <PhsShft> kuribas: so what do I have to do…?
10:12:37 <ertes> kirillow: yeah, right article…  in the context of 'head' it explains why you have assumed the role of the type system
10:12:41 <kuribas> PhsShft: extract the value first, using do notation (<-) or (>>=).
10:12:45 <maerwald> lol
10:13:01 <PhsShft> kuribas: thanks, ill try that
10:13:32 <ertes> kirillow: here is a particularly bad example (although it may seem that it's actually the only *safe* way to use 'head'):  if null xs then putStrLn "Empty." else print (head xs)
10:13:37 <maerwald> I'd rather say: don't bother me unless you give me refinement types.
10:14:08 <kuribas> PhsShft: or the lambda case extension: control >>= \case {Nothing -> ...}
10:14:09 <maerwald> otherwise I'm going to proof stuff manually where I see fit
10:14:12 <maerwald> *prove
10:14:23 <kirillow> ertes: Ahh, okay
10:14:39 <ertes> kirillow: see also Data.List.NonEmpty 
10:15:01 <ertes> kirillow: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List-NonEmpty.html
10:15:23 <ertes> kirillow: however, if you do have a list, you should fold it, not 'head' it
10:15:42 <ertes> :t foldr (\x _ -> print x) (putStrLn "Empty.")
10:15:45 <lambdabot> (Foldable t, Show a) => t a -> IO ()
10:15:49 <PhsShft> :kuribas how does the lambda case extension work?
10:15:56 <EvanR> if you had a list, you could fold it, if you had a fold
10:16:42 <kuribas> PhsShft: it matches the lambda variable against the patterns, you don't have to name it.
10:17:13 <maerwald> PhsShft: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html#lambda-case
10:17:22 <PhsShft> thx..
10:17:45 <EvanR> it works great
10:17:55 <EvanR> i wish it was not an extension
10:18:39 <a6a3uh1> Hi! I have aeson question. In order to use strings with aeson I have to explicitly pack them to Text. While in all the examples out there people just useing normal strings without hassle. What am I doing wrong?
10:19:35 <EvanR> OverloadedStrings extension lets you write string literals for stuff like Text
10:19:53 <EvanR> specifically anything which implements IsString
10:20:36 <maerwald> OverloadedStrings behavior may differ though depending on GHC version
10:20:53 <PhsShft> :kuribas :maerwald sry I still can’t get it to work :( http://lpaste.net/330081
10:21:26 <a6a3uh1> I have 8.0.1 and it not helps me... maybe I have to reload my atoms repl plugin..
10:23:50 <a6a3uh1> maybe I have to add some package for that typeclass to my stack? :k IsString shows me not in scope
10:24:55 <MarcelineVQ> how are you enabling OverloadedStrings ?
10:25:12 <a6a3uh1> {-# LANGUAGE OverloadedStrings #-} I writing this at top of the file
10:25:33 <ertes> a6a3uh1: remember that aeson involves a lot of type classes, and the type you mean may not always be clear
10:25:37 <mmaruseacph2> try :set -XOverloadedStrings in the repl
10:25:40 <MarcelineVQ> if you're in a repl and are having the problem try :set -XOverloadedStrings
10:25:54 <ertes> (use :seti in the REPL)
10:26:03 <ertes> (rather than :set)
10:26:14 <a6a3uh1> :info IsSting gives me Not in Scope error. do I need some package for that?
10:26:24 <kuribas> PhsShft: try this: http://lpaste.net/330083
10:26:30 <ertes> a6a3uh1: it's in Data.String, but you don't need to import it
10:26:50 <ertes> a6a3uh1: try this:  x = "blah" :: Text
10:26:56 <ertes> if it works, you have OverloadedStrings
10:27:42 <PhsShft> kuribas: same error as i got
10:27:52 <PhsShft> Couldn't match type ‘m’ with ‘(->) a’
10:28:04 <mmaruseacph2> cool, just learned about :seti
10:28:34 <kuribas> PhsShft: right, action takes an argument
10:28:39 <a6a3uh1> now it works after manual seti in repl at least. Thanks. will try to figure out whats wrong with LANGUAGE definition
10:29:18 <mmaruseacph2> LANGUAGE definition is when compiling the code or interpretting it, not for the interactive evaluation inside repl
10:29:20 <PhsShft> kuribas: oh i completly missed that
10:29:22 <MarcelineVQ> nothing's wrong, repl's don't load extensions from files for interactive code, otherwise you could load a few files and have all kinds of things on at once
10:29:24 <ertes> a6a3uh1: keep in mind that in particular with aeson there are a lot of type classes involved, so it's not always clear *which* string type your literal should be of, and unlike for example integer literals there is no defaulting…  you may need to spell out the type signature in some cases
10:29:27 <PhsShft> kuribas: fixed :) thank you
10:29:36 <mmaruseacph2> for that you also have to start the repl with -XOverloadedStrings or use :seti -X.. inside
10:30:21 <a6a3uh1> Thanks! good point. I thought repl will notice my LANGUAGE directives)
10:31:07 <a6a3uh1> thank you all friends. your are very kind and helpfull)
10:32:32 <a6a3uh1> is there a way to tell repl to set something automatically loading my file? or I have to always write that manually?
10:33:24 <kadoban> a6a3uh1: There's .ghci file you can put stuff in, if that's what you mean
10:33:53 <kuribas> PhsShft: alternatively: mWhileJust control action = fix (\again -> control >>= (traverse_ ((>> again) . action)))
10:34:02 <ertes> a6a3uh1: and there is also a directory-specific .ghci for projects
10:35:00 <a6a3uh1> nice... I'll try to figure it out. :)
10:35:37 <ertes> a6a3uh1: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files
10:36:32 <a6a3uh1> ertes: thanks! good user guide
10:36:39 <kuribas> PhsShft: or slightly more readable: mWhileJust control action = fix (\again -> control >>= (traverse_ $ \e -> do action e; again))
10:37:15 <ertes> a6a3uh1: (i'd advice against using :set though; always use :seti)
10:37:34 <PhsShft> kuribas: gotta have to chew on that a bit
10:38:54 <neonfuz> So do list fusions work with Map.Map.map?
10:39:07 <Myrl-saki> hai.
10:39:35 <kuribas> :t traverse_
10:39:37 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
10:40:43 <kuribas> PhsShft: traverse_ here is (Monad m) => (a -> m b) -> Maybe a -> m ()
10:42:12 <neonfuz> and if they do work with Map.Map.map, do they work with Map.Map.Strict.map?
10:42:47 <kuribas> PhsShft: http://lpaste.net/330083
10:45:38 <PhsShft> kuribas: got it, thank you !
10:46:54 <sbrg> If I wanted to generate a bitmap image from a function that takes each pixel's position as input, what library should I be using? I'm reviving some old project that does this, and it uses friday + friday-devil, neither of which are on stackage. googling just gets me mostly useless, old results.
10:48:27 <ertes> neonfuz: both fuse for me
10:48:46 <mpickering> Does anyone have any experience using twitter bindings?
10:48:52 <MarcelineVQ> srk: juicypixel should be enough for that
10:49:38 <kuribas> PhsShft: Don't use those though (except maybe the last one).
10:49:54 <mpickering> It looks like the only option is "twitter-conduit"
10:50:22 <MarcelineVQ> sbrg: oop, juicypixel should be enough for that
10:56:49 <reygoch> is anyone doing haskell on windows?
10:56:57 <reygoch> I have trouble building ede templating engine
10:57:04 <nitrix> Myrl-saki: Hi. Long time no see.
11:00:49 <sbrg> MarcelineVQ: ah, thanks! I did know about JP. wonder why I didn't use that back then
11:01:37 <EvanR> juicypixels is usually recommended for loading images, but you can use it to build images
11:01:59 <EvanR> and theres juicypixels-repa
11:02:07 <EvanR> i assume this is supposed to be faster
11:02:29 <EvanR> you might want to try parallelizing your image generator
11:02:33 <ertes> i just read andrej bauer's <http://math.andrej.com/2016/08/06/hask-is-not-a-category/> earlier, followed by roman cheplyaka's response <https://ro-che.info/articles/2016-08-07-hask-category>, and find myself wondering if it would be a good idea to just dispense with the notion of Hask and just use Set…  after all Hask is just an approximation of Set
11:05:07 <barrucadu> Does it matter whether Hask is actually a category or not? It's close enough that we can draw useful ideas from category theory, whether the Haskell implementation corresponds exactly to the pure category theroetical form seems unimportant.
11:05:07 <Phyx-> RevJohnnyHealey: what kind of problems?
11:05:26 <ertes> …, just, just, just, just, …  what was that…
11:05:35 <johnw> barrucadu: it only matters in that we say it's there, not "we're just using a vague approximation in order to stimulate our intuition and provoke new insights"
11:06:37 <ertes> barrucadu: yeah, but for the most part we're pretending that Hask is everything that Set is…  why not just use Set right away and accept that it's just an approximation of haskell?
11:06:54 <ertes> Set is an actual category, and whatever we're doing in Hask, we might as well be doing in Set
11:08:02 <lyxia> The point is that there is no category to be found that models bottoms accurately.
11:08:13 <Phyx-> oh he left
11:08:23 <monochrom> Set has the problem of possessing objects standing for predicate subtypes, even dependent predicate subtypes. Both Haskell and Hask lack them.
11:08:55 <monochrom> Set would be a great model for PVS.
11:09:36 <barrucadu> PVS?
11:09:45 <EvanR> there are lots of set theories and lots of versions of a putative haskell category, but without more details youd think of ZFC sets in Set... what is Hask
11:10:08 <neonfuz> ertes: how do I check if something fuses?
11:10:12 <ertes> monochrom: then what about, let's call it, Types?  for example the agda category
11:10:12 <monochrom> a specification and proof system. http://pvs.csl.sri.com/
11:10:36 <ertes> monochrom: wait, i misunderstood
11:10:56 <ertes> neonfuz: i just use -ddump-simpl to check
11:11:01 <ertes> used
11:11:02 <joe9_> where is HOTT?
11:11:08 <EvanR> i asked in here once how Set and Hask are different, but i think that ended up in more confusion than before the question
11:11:17 <Myrl-saki> putative?
11:11:51 <ertes> that may be because Set depends on the underlying calculus, and Hask is probably not even something formal
11:11:53 <Myrl-saki> Oh.
11:12:36 <ertes> but for example i see merit in doing my reasoning in agda using the agda category (which *is* a category), and then just use the results in haskell
11:12:54 * hackagebot keysafe 0.20161107 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20161107 (JoeyHess)
11:13:10 <ertes> and agda types correspond more closely to haskell types than sets from ZFC
11:13:32 <jle`> ertes: there are some types in Haskell that are well-defined but describe things that don't make sense as sets
11:13:58 <jle`> i think i remember an example of a type that was its own powerset
11:14:01 <roconnor> like types whose powerset of their powerset is isomorphich to themselves.
11:14:04 <EvanR> the domain of a lambda calculus "function"
11:14:11 <jle`> data S = S (S -> Bool) ?
11:14:21 <jle`> that might not be it
11:14:26 <neonfuz> ertes: alright thanks
11:14:38 <dedgrant_> reygoch: I've come across the same sort of stdc++ linker error before. For instance: https://github.com/commercialhaskell/stack/issues/754
11:14:59 <ertes> yeah, i understand that set theory is very different from type theory…  scratch my Set proposal…  what about Agda or any other category of types?
11:15:32 <ertes> agda can have those weird non-set-like things
11:15:40 <monochrom> To be sure, physics has been using continuous time and continuous space all the time. A model that we are actually pretty sure is false, but we stick to it and it has always given overwhelmingly accurate results.
11:16:14 <monochrom> In fact, to add salt to wound, they don't even ask "is the real number line even constructible?!", unlike us.
11:17:05 <EvanR> physics was never about reality
11:17:12 <roconnor> jle`: http://r6research.livejournal.com/22105.html
11:17:23 <ertes> monochrom: yeah, that's what i mean:  let's use continuous time for physics…  we understand that physics is probably not continuous, but let's use a precise mathematical model anyway, even though it doesn't fit
11:17:42 <roconnor> The type is P''
11:17:57 <ertes> instead of inventing the topological space Phys, which…  you know…  is not *really* a topological space…
11:18:05 <monochrom> hehe
11:18:15 <monochrom> Richard Bird uses Set too.
11:18:17 <EvanR> i demand the presence of a physicist
11:18:55 <joe9_> When you have 2 threads using the same data, you need an IORef, correct?
11:19:01 <EvanR> no!
11:19:06 <EvanR> data is immutable
11:19:07 <monochrom> Well, in advanced work he uses Rel (each object is a relation), but it inherits all the features of Set.
11:19:22 <ertes>  /msg ##physics hey, we need one of you in #haskell
11:20:03 <nitrix> joe9_: Data can be shared without risks; as it is immutable. If you want the data to mutate (written to), while it's being shared, then you'll need a mechanism like IO to coordinate the effects.
11:21:58 <monochrom> you know what, I'm pretty sure people's idea of Hask is along the line of what I said earlier. Start with Set but omit the subset objects because they don't happen in Haskell types.
11:22:00 <nitrix> ST is another nice mechanism for mutation but this one has to remain observably pure.
11:22:20 <cstrife> Its nice when your basis is continuously differentiable...
11:22:59 <monochrom> No no. Set is not an O-category.
11:24:55 <cstrife> Is the harmonic basis quantised in an infinite domain?
11:25:23 <joe9_> nitrix, yes the data is being changed by one thread, but, is just being read by the other thread.
11:25:56 <cstrife> Raising operators generate the basis in coinduction from the ground state...
11:26:37 <nitrix> joe9_: Seems like a reference is needed yet. IORef could probably fit easily there.
11:26:43 <nitrix> *yeah
11:27:02 <monochrom> just remember to use atomicModifyIORef
11:27:10 <joe9_> nitrix: sorry, this is my data structure http://codepad.org/BnzND885 . only one thread writes to sMarkets and sMarketsAsOf and another thread writes to sResponsesQueue.
11:27:23 <ertes> side note: TVar is just as fast as IORef when used in isolation
11:27:24 <joe9_> monochrom: ok, Thanks.
11:27:53 <monochrom> that's nice
11:27:54 * hackagebot http-dispatch 0.6.0.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.6.0.0 (owainlewis)
11:27:59 <joe9_> monochrom: atomicModifiyIORef is a very good idea. thanks.
11:28:29 <ertes> and they have the same semantics in that case:  both are lock-free
11:28:45 <nitrix> ertes: But isn't there a risk with TVar not being atomic?
11:28:58 <ertes> nitrix: i'd consider that a bug
11:29:06 <EvanR> TVar not atomic ? O_o
11:29:22 <cstrife> Atoms are the fixed point of a recursive definition of molecules as computational structures, as in krohn rhods theorem
11:29:27 <ertes> nitrix: a funny one, too, if "atomically (writeTVar …)" is not atomic =)
11:29:41 <nitrix> ertes: atomically is, writeTVar wont though.
11:29:55 <ertes> nitrix: you can't use writeTVar outside of 'atomically'
11:29:58 <cstrife> (It's hackrilege here btw, you called out for physics...)
11:30:10 <EvanR> cstrife: real physics plz
11:30:25 <cstrife> Clarify this critique
11:30:35 <nitrix> ertes: That I didn't know o:
11:30:56 <EvanR> writeTVar isn't in the IO monad
11:31:04 <EvanR> so you cant just do it
11:31:15 <EvanR> you cant even unsafePerformIO it heh
11:31:35 <ertes> there are some IO functions for convenience that use 'atomically' implicitly, but most of them are for reading things
11:31:40 <nitrix> What's the benefit of atomically + modifyTVar and convert STM into IO, over just using IORef that already happens in IO ?
11:31:41 <joe9_> is TVar better than IORef? I see a lot more code using IORef than TVar.
11:31:46 <ertes> regardless, everything STM must be atomic
11:31:55 <ertes> that's the very point of STM =)
11:32:07 <EvanR> nitrix: the benefit comes from using more than one TVar at a time
11:32:28 <EvanR> reading or writing, itll be transactional
11:32:30 <ertes> joe9_: there is nothing wrong with IORef, as long as you pay attention to use atomic*
11:32:44 <joe9_> ertes: ok, Thanks.
11:32:46 <ertes> but if you have an stm dependency, you might as well use the safer TVar
11:32:47 <monochrom> IORef has a longer history than TVar
11:33:25 <nitrix> ertes: I was worried because while updating the value is atomic, sometimes you want to guarantee the critical code that transforms the old value into the new value to not interleave one another.
11:33:42 <EvanR> that cant happen with TVars
11:33:43 <nitrix> ertes: But I'm learning that actually nothing in Haskell seems to ever do that.
11:34:11 <ertes> nitrix: that can't even happen with IORef, because it's just a pointer write (at least in GHC)
11:34:16 <nitrix> (Unless you manually disssociate the read operation and the write operation)
11:34:36 <nitrix> ertes: That's not the concern.
11:34:50 <ertes> nitrix: in fact it's a common source for another kind of (non-critical) bug:  you failed to evaluate before writing, so you ended up handing *work* to another thread instead of a value
11:35:09 <nitrix> ertes: Oh, you mean, updating the thunk is just a pointer update?
11:35:35 <EvanR> the contents of the IORef object is just a pointer
11:35:42 <EvanR> it might be a thunk
11:36:23 <EvanR> but i think nitrix was worried about something besides the pointer write not being atomic
11:36:54 <nitrix> do { ref <- newIORef; forkNTimes 2 (foo ref); }
11:36:57 <ertes> nitrix: i don't know all details, but you can safely assume that evaluation is always isolated and atomic, regardless of which thread gets to perform it
11:37:20 <nitrix> Whoops, give newIORef a default value too, sorry.
11:37:29 <ertes> the thing that is not guaranteed to be atomic is IO
11:38:00 <monochrom> writeIORef v [1..n]
11:38:02 <monochrom> err
11:38:04 <monochrom> writeIORef v [1..]
11:38:06 <nitrix> Where foo would do an atomicModifyIORef; I was concerned a couple days ago that it'd be possible for two threads to obtain the old value, and then atomatically updating the ref with the new value.
11:38:12 <monochrom> This is not going to take infinite time
11:38:27 <nitrix> Because, sure the update's atomic, but it doesn't step there. You want the critical section to not interleave too.
11:38:34 <monochrom> well actually that may be an ambiguous example
11:38:36 <joe9_> "Variant of writeIORef with the "barrier to reordering" property that atomicModifyIORef has." -- is it safer to use atomicWriteIORef vs writeIORef ?
11:38:55 <monochrom> writeIORef v (fib 100000000).  now this is an unambigious example and it will still not take infinite time
11:39:22 <monochrom> joe9_, read the example there, and decide for yourself does it affect you or not.
11:39:30 <monochrom> There is no simple rule of thumb.
11:39:53 <ertes> nitrix: atomicModifyIORef runs only once at the same time on an IORef…  that's its guarantee
11:39:55 <monochrom> In fact IMO the example is contrived and artificial. Why would I write code like that?
11:40:09 <joe9_> monochrom:  Thanks.
11:40:10 <ertes> nitrix: but remember that it still does only a pointer update, and nothing else
11:40:13 <monochrom> (And then to my horror, programmers tell me "programmers write code like this all the time")
11:40:40 <nitrix> ertes: That's where I'm going. There's the notion of the result being updated atomically and the critical section to new interleave.
11:40:44 <nitrix> *not
11:40:51 <ertes> nitrix: in particular it does not evaluate, and it doesn't have to either…  evaluation is safe…  forcing just determines which thread gets to evaluate
11:40:52 <nitrix> ertes: Does STM follows the same semantics?
11:41:12 <cstrife> Its not my fault that chemistry requires only iterative coarse graining and that physics is that required by chemistry to describe materials... Atoms were never meant to be divisible, virtual particles are simply redundant
11:41:17 <ertes> nitrix: you might even find yourself in a situation where multiple threads evaluate *the same shared value at the same time*, and it's still safe
11:41:18 <nitrix> Presumably yes because of `atomically`.
11:41:36 <ertes> nitrix: think of an infinite list that gets evaluated progressively
11:41:52 <nitrix> ertes: Let's pause. I'll give a concrete example on lpaste.
11:42:02 <nitrix> Discussion's diverting too much :P
11:42:36 <ertes> nitrix: unless i'm mistaken IORef has the semantics of a single TVar used non-transactionally
11:42:55 * hackagebot text-show 3.4.1.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.4.1.1 (ryanglscott)
11:43:03 <monochrom> cstrife: We have long moved on. Are you done?
11:43:08 <nitrix> ertes: http://lpaste.net/330109
11:43:32 <monochrom> Or do you consider this channel to be your personal blog?
11:44:01 <ertes> nitrix: that looks like a type error
11:44:07 <nitrix> ertes: Fixed
11:44:14 <ertes> ok, scope error
11:44:46 <ertes> in any case, the result will be that as soon as one of the threads has run, the IORef will hold True
11:44:52 <nitrix> ertes: I think it's enough still for what I'm asking. The question is if it's ever possible for the case in both threads to hit the "False" case.
11:45:27 <ertes> it is, but you will never observe it (the evaluation can be aborted in a race for writes)
11:45:35 <nitrix> ertes: Despite the update being atomic, and both threads receiving the old value and producing a new value, you still have to guarantee that they do not interleave one another, otherwise they might both get False as the old value.
11:45:47 <nitrix> ertes: Oh?!
11:46:13 <nitrix> Is it some kind of cooperative compare-and-swap?
11:46:16 <ertes> (that's why atomicModifyIORef needs a pure function…  it just tries to write, and if the write fails, because another thread tried at the same time, it just retries)
11:46:24 <ertes> yeah, that's exactly what it is
11:46:25 <nitrix> I see.
11:46:36 <nitrix> Now the next question
11:46:39 <nitrix> Does STM works the same?
11:46:56 <ertes> it does abort and retry, too
11:47:06 <ertes> not necessarily with compare-and-swap, because transactions can get more complicated
11:47:07 <nitrix> Is there one that has the risk that I mentioned?
11:47:33 <ertes> nope…  the main risk with this approach is that of a live-lock, but there should be no consistency risks
11:48:26 <EvanR> nitrix: the paper on STM is pretty good, it explains how you could implement it (no idea how it's actually implemented)
11:49:49 <ertes> nitrix: the point is that transactions (both IORef and STM) may see inconsistent state, but if they do, they cannot succeed…  races are always resolved by aborting and retrying
11:50:20 <nitrix> That's worrying me a lot for something I'm working on.
11:50:22 <ertes> that's why atomicModifyIORef takes a pure (non-IO) function
11:50:31 <nitrix> MVar is different, right? It behaves like an actual lock?
11:50:35 <ertes> and why you must not use IO within STM
11:50:44 <ertes> MVar is an actual lock, yeah
11:51:16 <nitrix> So, something that has a lot of contigency might benefit from using MVar over IORef then?
11:52:14 <nitrix> (e.g. 1000 threads fighting for the same ref)
11:52:27 <ertes> pro: no live-locks and MVar fairness; con: it's more expensive
11:53:46 <nitrix> I'm guessing MVar requires help from the scheduler too?
11:54:34 <nitrix> (Threads sleeping / waking up)
11:54:49 <johnw> "1000 threads are started, only one will finish! Buy your tickets now."
11:54:56 <Grisha> I’ve got a stupid newbie question about rpar/rseq: why don’t they consider the fourth option of a <- rseq(f x); b <- rseq(f y) in http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-rpar-rseq ?
11:55:17 <Grisha> but do rseq a; rseq b after calling rpars?
11:55:22 <nitrix> Also, sorry for highjacking that discussion and being so verbose, that subject has been bugging me for a while now.
11:55:32 <fryguybob> ertes: In the case of atomicModifyIORef the modification is not speculatively executed.  It is only executed if the value is successfully placed in the IORef.
11:56:00 <nitrix> fryguybob: That makes sense.
11:56:09 <EvanR> nitrix: i heard that STM will underperform compared to MVar when contention gets "high"
11:56:24 <EvanR> but on low contention is faster than MVars
11:56:52 <nitrix> So, needs profiling as usual :P
11:57:25 <EvanR> and youll never get a complex transaction to work out right with a pile of MVars
11:57:36 <EvanR> unless you lock the entire critical section with yet another MVar
11:58:23 <nitrix> I heard you shouldn't do that.
11:58:30 <EvanR> and locking schemes can themselves get complex
11:58:51 <EvanR> transactions cant, because you cant nest them! (hmm...)
11:59:16 <EvanR> i remember wanting to nest them though
11:59:19 <EvanR> wonder if i was insane
11:59:23 <nitrix> ertes: Reading the stm paper, thanks.
12:00:33 <cstrife> You can transfer transactions?
12:01:40 <cstrife> Id call that a functional
12:05:18 <Squarism> anyone used "wai middleware static". Im just curious how i can mount static files on a certain url wo the need of a 1-1 mapping of my filesystem?
12:07:13 <ertes> fryguybob: even when forced?
12:07:55 * hackagebot snaplet-sqlite-simple 1.0.0.1 - sqlite-simple snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-sqlite-simple-1.0.0.1 (JanneHellsten)
12:08:06 <ertes> fryguybob: but yeah, it makes sense indeed
12:08:26 <cstrife> Can anyone think how to extract higher order functions from the fixed point of a neutral network?
12:09:49 <fryguybob> ertes: Yes.  It speculatively reads the value  x, then uses CAS to put the lazy value  f x  in place if  x  hasn't changed.
12:10:27 <shapr> cstrife: are you learning Haskell? Written any cool code lately?
12:10:31 <fryguybob> ertes: If the value has changed to  y, it just loops, swapping  x  for  y.
12:11:25 <ertes> fryguybob: i see, so actually you need another read to make sure the value is actually evaluated
12:11:27 <fryguybob> ertes: The versions that force values still have this same loop, the forcing happens afterward.  There is a chance that the computation will be duplicated.
12:11:56 <cstrife> shapr, I got stuck trying to represent the span of a reduced basis in a Free Free Zipper
12:12:09 <shapr> cstrife: got any code you've written on github?
12:12:35 <cstrife> Published some in the name of hackrilege on lpaste
12:12:54 <fryguybob> ertes: STM on the other hand, executes under the assumption that there are no conflicts and checks at commit for conflicts.
12:12:59 <shapr> cstrife: have you also gone by protontorpedo?
12:13:08 <cstrife> No
12:13:46 <neonfuz> Can you add type constraints, or type variables to type synonyms?
12:14:17 <ertes> neonfuz: type F a = …
12:14:26 <ertes> neonfuz: if you want to add constraints, you need -XRankNTypes
12:14:45 <neonfuz> ohhh right thank you 
12:14:47 <cstrife> Torpedoes fire submarines right?
12:15:11 <shapr> cstrife: Have you read any of the Haskell books?
12:15:24 <ertes> neonfuz: type MyMonad m a = (MonadState S m, MonadBlah m) => m a
12:15:32 <cstrife> Art of functional programming
12:15:37 <ertes> neonfuz: or (what i like to use): type MyMonad a = forall m. (MonadState S m, MonadBlah m) => m a
12:15:44 <cstrife> And some online stuff
12:16:10 <shapr> cstrife: have you written any Haskell code to do everyday automation? Maybe used Turtle for shell scripting?
12:16:40 <cstrife> Link?
12:16:56 <shapr> https://hackage.haskell.org/package/turtle-1.2.8/docs/Turtle-Tutorial.html
12:17:12 <cstrife> s/art/craft
12:19:22 <cstrife> I didn't know about these things
12:20:43 <Guest61983> hey guys, lens question here
12:20:49 <cstrife> I'm looking for a minimal Haskell implementation for a virtual machine capable of running on itself...
12:21:24 <Guest61983> I'd like to apply a function f on the first element that satisfies some predicate in a list or map - like `over (mapped . filtered pred . (insert take 1 here)) f myMap`
12:21:56 <shapr> cstrife: I think you're more likely to be productive with Haskell if you start smaller, with something like shell scripts.
12:22:11 <HelgeS> Trying to learn Haskel, I follow a blog tutorial on Parsec. It's reasonably easy to follow the code from the start, but the first defined, outer, functions require the later defined functions to compile. 
12:22:38 <HelgeS> How can I find out what types the arguments need, when it's a bit complicated?
12:22:39 <Grisha> shapr: you might be feeding a troll ;-)
12:23:24 <Grisha> HelgeS: can you paste the link of the post?
12:23:28 <Grisha> *to the post
12:23:36 <shapr> cstrife: you could  try HaLVM, it's Haskell runtime that runs bare metal on Xen
12:23:36 <shapr> Grisha: I'm trying to diagnose troll-ness
12:23:36 <shapr> If I can convinced hackrilege/cstrife/etc to contribute rather than distract, I won't need to remove cstrife from the channel.
12:23:41 <cstrife> What can I do with them shape? The end goal is a secure portable development environment that can run and run in ghc
12:24:04 <cstrife> shapr*
12:24:26 <Grisha> cstrife: my favourite project to learn a new language is to port Norvig’s sudoku solver to it
12:24:30 <cstrife> I would like to know what this turtle prelude can be used for
12:24:30 <HelgeS> Grisha: http://pastebin.com/icxRYM6L
12:24:47 <shapr> cstrife: turtle is for doing the same thing as shell scripts, but in Haskell
12:24:57 <HelgeS> https://www.barrucadu.co.uk/posts/2013-05-27-a-gentle-introduction-to-parsec.html
12:25:03 <Grisha> HelgeS: what function did you have in mind?
12:25:21 <HelgeS> parseCSV needs csvp to be defined.
12:25:31 <HelgeS> csvp needs line to be defined
12:25:35 <HelgeS> line needs cell
12:25:38 <cstrife> That's not what I was asking for, bit it looks good, thanks for the tip
12:25:38 <Grisha> yes
12:25:40 <shapr> cstrife: I would also recommend what Grisha said, write a very small project in Haskell so you are able to write larger projects in Haskell.
12:26:09 <cstrife> I'm actually working on that slice interaction I described
12:26:14 <shapr> cstrife: This channel is more for teaching Haskell to people who wish to learn the language.
12:26:16 <Grisha> HelgeS: in Haskell it’s ok to use call functions before they’re defined
12:26:46 <HelgeS> Grisha: yes, but the file will not load if only parseCSV is there, and not cell.
12:26:49 <shapr> cstrife: do you have any question about Haskell code you've written?
12:26:58 <cstrife> I have received much help getting as far as I have by describing my progress
12:27:12 <Grisha> HelgeS: sure, you’ll need the definitions of all functions that parseCSV uses
12:27:14 <neonfuz> is there a standard library function that does (\a->[a])?
12:27:30 <kadoban> neonfuz: pure or (:[]), the monkeyface operator
12:27:36 <shapr> beat me to it
12:27:41 <HelgeS> I'd like to take it slowly step by step, which seem to imply bottom-up, rather than top-down. Is there a way around that?
12:27:41 <exio4> or return :P
12:27:48 <systemfault> Haha, first time I hear "monkey face operator"
12:28:25 <kadoban> Can't remember who I got that from, it totally fits though.
12:28:29 <kadoban> I can't unsee it.
12:28:31 <Grisha> HelgeS: I’m afraid you’ll first have to understand how the small parsers (line, cell, etc.) work before you can understand the big one (parseCSV)
12:28:31 <cstrife> :t mappend mempty
12:28:33 <lambdabot> Monoid a => a -> a
12:28:44 <ertes> :[] is the monkey face; (:[]) is a full monkey head
12:28:47 <cstrife> Oh oops
12:28:51 <ertes> and now you will see monkey faces everywhere
12:28:56 <ertes> my pleasure
12:29:00 <monochrom> HelgeS: You can read the article backwards.
12:29:49 <monochrom> Watch the movie Memento a few times to receive training in reading things in the top-down, effect-cause order :)
12:29:56 <kadoban> Haha
12:29:56 <HelgeS> Given parseCSV :: String -> Either ParseError [[String]]
12:29:57 <HelgeS> parseCSV = parse csvp ""
12:30:05 <HelgeS> how can I get a hit that I need 
12:30:06 <HelgeS> csvp :: Parsec String () [[String]]
12:30:26 <Grisha> because csvp appears in the definition of parseCSV
12:30:43 <exio4> monochrom: that movie was extremely good 
12:30:46 <Grisha> or do you mean the type of it?
12:31:01 <HelgeS> yes, the type of it
12:31:05 <cstrife> I can't remember if I saw memento...
12:31:14 <HelgeS> I guess I must understand what parse needs.
12:31:15 <kadoban> cstrife: Can't tell if joke or not ...
12:31:16 <Grisha> HelgeS: write down the type of “parse”
12:31:23 <ertes> cstrife: so the movie had an effect on you
12:31:28 <HelgeS> :t parse
12:31:30 <lambdabot> error: Variable not in scope: parse
12:32:01 <exio4> cstrife: maybe you watched it, just didn't write it down, so you can enjoy it again ;) 
12:32:23 <Grisha> HelgeS: it’s not a part of the standard library, but rather has to be installed extra
12:32:56 * hackagebot elm-export 0.5.0.0 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.5.0.0 (krisajenkins)
12:33:04 <HelgeS> :t Text.Parsec.Prim.parse
12:33:07 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
12:33:08 <cstrife> I have a note on my wall it says "extend and losslessly simplify the most simple plan, this is the most simple effective plan"
12:33:15 <ertes> "hmm…  so i was learning this programming language haskell earlier…  but why did i tattoo that fishbone?"
12:33:30 <cstrife> So much basecase
12:33:44 <shapr> cstrife: feels to me like you're distracting from actual Haskell discussion, do you have any Haskell questions?
12:34:25 <cstrife> I thought we were talking about memento and conductive program growth
12:34:42 <shapr> cstrife: otherwise I'll be forced to punt you because distractions are the opposite of contributions
12:34:47 <cstrife> Coinductive*
12:35:20 <monochrom> HelgeS: For the type and doc of something from the parsec library, see its doc. You can find it on hackage (http://hackage.haskell.org/package/parsec). But in the long run you should configure cabal to build local docs and read docs off your own disk, because version mismatch.
12:35:25 <cstrife> Perhaps you could help me better formulate my query, I think it's just my poor syntax.
12:35:56 <cstrife> I'm trying to grow code, that's the basecase
12:35:58 <javjarfer> Anyone has knowledge about parsec internals?
12:36:11 <ertes> cstrife: the answer to your query hasn't changed from a few weeks ago, when you first asked it:  no, there isn't
12:36:30 --- mode: ChanServ set +o shapr
12:36:52 <shapr> javjarfer: what about parsec internals?
12:37:32 <cstrife> I was hoping a modification on the query may return a better output. I'll work on it. I apologise. plz don't punt me
12:37:32 <Grisha> :q
12:37:35 <Grisha> oops
12:37:38 <Grisha> wrong window
12:37:57 * hackagebot elm-export 0.5.0.1 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.5.0.1 (krisajenkins)
12:38:00 <javjarfer> shapr, about how it handles different Streams, I have take a look at its insides, at it seems like it unfolds all streams to create lists before actually processing them
12:38:07 <shapr> cstrife: I strongly recommend writing code to learn Haskell, I think that will help you most.
12:38:27 <cstrife> Thanks
12:39:11 <shapr> javjarfer: I know aeson is considered much faster than Parsec, are you looking for something more efficient or faster?
12:40:37 <javjarfer> shapr, no I was simply trying to confirm that
12:42:09 <javjarfer> shapr,  have also knew that about aeson, this wasn't a matter of performance I was just learning.
12:42:30 <javjarfer> ***I also knew***
12:42:38 <shapr> javjarfer: I think you're right, but I've not dug into Parsec in years, things may have changed since I last looked
12:43:08 <HelgeS> Is test driven development common with Haskell? If so, is QuickCheck a useful tool, or are there better tools for a beginner?
12:43:37 <shapr> HelgeS: there's HUnit if you prefer explicit unit tests, but I do really love writing a QuickCheck test to get started
12:43:39 <Profpatsch> (Typeable1 s, Typeable a) => Typeable (s a)
12:43:47 <Profpatsch> What is (s a)?
12:43:55 <johnw> it's a type
12:43:57 <javjarfer> shapr, thanks you, now I'm more sure about that
12:44:01 <johnw> 's' is a type-former of kind (* -> *)
12:44:03 <Profpatsch> Ah, s :(* -> *) and then
12:44:06 <Profpatsch> Ok
12:44:06 <shapr> javjarfer: got any other interesting questions?
12:44:14 <shapr> javjarfer: writing some interesting parsers?
12:44:17 <johnw> that's why Typeable1 s
12:45:31 <javjarfer> shapr, well I was just writing a tiny applicative stile parser, as a tiny library to parse git diffs, it have become a necessity for a project
12:46:25 <amx> I assume the MVar deadlock detection is an actual proof and hence gives no false positives, correct?
12:46:47 <javjarfer> shapr, I was thinking in adding support to "generic" streams, but I think right now will be to much complicated, maybe I will think about it next week. But right now I think I will go with lists
12:47:08 <Grisha> bye folks
12:47:19 <shapr> javjarfer: ooh, is your git diff parsing code on github? I could use that!
12:48:07 <javjarfer> shapr, I will be very soon! I hope to make a package for hackage, since I didn't see anyone.
12:49:06 <shapr> I've seen some really amazing things done with Language.C (corrode for Rust) and Language.Java (deduplication) recently, I wonder what I could do with Language.Python at my day job? hmm!
12:49:18 <shapr> javjarfer: cool! I'll try it when you get it out there!
12:50:01 <neonfuz> kadoban: lmao monkeyface operator
12:51:10 <javjarfer> shapr, a monadic parser seemed like to much for me for this task, it wasn't really necessary. So... I went for Applicative, it really hurts me when I need to reinvent the wheel xD but for this I thought it was the only option, sure I was wrong
12:52:03 <javjarfer> shapr, nice! I will advice here if you like when it's ready. Maybe it would take a couple of days more, git "extended headers" are a pain xD
12:52:08 <shapr> javjarfer: I don't know, if you find a better option, I want to hear about it!
12:56:03 <Profpatsch> lol, -> is Typeable
12:56:21 <cstrife> Is it a theorem that all computations can be expressed as hylomorphisms? I guess there could be a proof that is not by induction but I can't think of one
12:57:12 <Profpatsch> TypeableN just means that the types of two values can be compared at runtime, rights
12:57:24 <Profpatsch> s/s$/?/
13:02:20 <ab9rf> cstrife: i think you would first need to formally define what a hylomorphism is
13:02:57 * hackagebot regex-do 1.4 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.4 (procione)
13:03:21 <Tuplanolla> That's at least true for pure computations, cstrife.
13:03:52 <Tuplanolla> Alas that doesn't mean the correspondence is simple.
13:04:22 <cstrife> I think it holds as arguments are supplied one at a time in Haskell...
13:04:25 <cstrife> http://lpaste.net/238398
13:04:34 <cstrife> Hylo^
13:04:47 <ab9rf> ah, somebody hijacked the term into CS somewhere. forgive me for knowing more classical philosophy than is perhaps safe :)
13:05:51 <jle`> Profpatsch: yeah
13:06:02 <cstrife> I guess I'm looking for reference to khrohn rohds theorem with lambda calculus during the programming evolution that led to Haskell
13:11:30 <cstrife> Maybe it's a reflection only made in hindsight..
13:12:55 <iphy> I have a package called semdoc, which depends on a bunch of other packages
13:12:58 * hackagebot simple-effects 0.3.0.2 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.3.0.2 (darwin226)
13:13:29 <iphy> one of them is pandoc
13:13:49 <iphy> if I install all dependencies manually, and then install pandoc, it works, but if I install them all together, cabal fails
13:18:46 <cstrife> Does running cabal install twice work? I have been needing to do that to install some packages recently
13:20:15 <QereweYT> Hello
13:21:03 <QereweYT> Anybody here?
13:21:17 <puregreen> QereweYT: yep
13:21:46 <puregreen> is there any way to suppress warnings produced by TH? I found 'recover' but it only works for errors
13:36:27 <cstrife> puregreen, what about this; https://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/options-sanity.html
13:39:20 <puregreen> cstrife: even if this had an option to turn off TH warnings, I don't want to disable all of them, only ones generated by a specific TH function
13:39:48 <bgamari> Phyx-, windows build finally finished
13:52:59 * hackagebot snaplet-sqlite-simple 1.0.0.2 - sqlite-simple snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-sqlite-simple-1.0.0.2 (JanneHellsten)
13:54:40 <paolino> is it possible to have polymorphic binding for an argument ?
13:55:04 <cstrife> How do you mean?
13:55:06 <paolino> I ended it up passing it twice to make it compile
13:55:57 <paolino> but I call it with the same value in the 2 args
13:56:06 <hexagoxel> paolino: RankNTypes, probably
13:56:07 <glguy> paolino: With the RankNTypes extension you can specify a polymorphic type for an argument. Is this in the context of lens package? Often you can avoid needing that by taking the 'A' version of an optic and using the clone* function on that
13:56:36 <paolino> glguy, it's that yes
13:57:12 <cstrife> Is it something about monomorphism restriction?
13:57:23 <glguy> no
13:58:35 <paolino> > let f g x = (g 1,g 'a') in f show
13:58:38 <lambdabot>  error:
13:58:38 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
13:58:38 <lambdabot>      • In the first argument of ‘g’, namely ‘1’
13:59:08 <paolino> is it that ?
13:59:24 <paolino> > let f g h x = (g 1,h 'a') in f show show
13:59:26 <lambdabot>  error:
13:59:27 <lambdabot>      • No instance for (Typeable t0)
13:59:27 <lambdabot>          arising from a use of ‘show_M887025476444411080532494’
14:00:20 <glguy> > let f :: (forall a. Show a => a -> String) -> (String, String); f g = (g 1, g 'a') in f show
14:00:23 <lambdabot>  ("1","'a'")
14:00:47 <ab9rf> that is indeed the DMR.
14:00:53 <glguy> No, not is not
14:01:00 <ab9rf> seems to be
14:01:03 <geekosaur> it will not (can not, I think?) infer a rank>1 type
14:01:04 <ab9rf> well, no, you're right
14:01:09 <ski> > let f :: (forall a. Show a => a -> b) -> c -> (b,b); f g x = (g 1,g 'a') in f show ()
14:01:12 <lambdabot>  ("1","'a'")
14:01:13 <ab9rf> it's the rank-1 restriction
14:01:45 <ab9rf> geekosaur: i think there's an undeciability issue with rank-N inference, although in practice it rarely arises.
14:03:09 <geekosaur> iirc rank2 is actually decidable, but ghc doesn't do it because it would require a massive redesign of its type inference for what is seen to be very little gain. rank>2 is undecidable
14:04:15 <dfeuer> tomjaguarpaw, did you ever figure out that weird GHCi IO loop space leak?
14:06:36 <paolino> https://kobra.io/#/e/-KW-oF8gAAxc4eRNrcrb
14:06:52 <paolino> I cannot fix it on my own, I give up
14:07:28 <paolino> it's asking for impredicative, too much
14:07:30 <dfeuer> My impression is that rank-2 inference is *barely* decidable. I don't know if it remains decidable in the presence of other type system extensions. Trying to read the error messages from a rank-2-inferring type checker could be difficult. That said, it could be pretty cool.
14:07:30 <glguy> paolino: No, you can't put the polymorphic type inside []
14:07:59 * hackagebot lowgl 0.4.0.0 - Basic gl wrapper and reference  https://hackage.haskell.org/package/lowgl-0.4.0.0 (evanrinehart)
14:08:00 <glguy> paolino: You should try working with APrism instead
14:08:13 <glguy> paolino: or ReifiedPrism
14:10:12 <paolino> glguy you mind write some of it ?
14:11:57 <glguy> You can use the type [APrism' (Concept a) a], and    clonePrism :: APrism' (Concept a) a -> Prism (Concept a) a
14:11:58 <dfeuer> ReifiedPrism is very easy to deal with.
14:12:32 <dfeuer> The AWhatever things always disturb me a bit because they require some thinking about efficiency.
14:12:43 <glguy> They both do
14:12:59 * hackagebot lowgl 0.4.0.1 - Basic gl wrapper and reference  https://hackage.haskell.org/package/lowgl-0.4.0.1 (evanrinehart)
14:13:01 * hackagebot ngx-export 0.2.4.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.4.1 (lyokha)
14:13:44 <paolino> you mean clonePrism t instead of s ?
14:15:35 <dfeuer> glguy, I just mean that if you *have* a full optic already, then you can Reify it without changing anything. To deal with the A-versions, you have to consider the appropriate conversion points.
14:15:45 <paolino>      Expected type: (a -> Const (Endo [a]) a)
14:15:46 <paolino>                      -> Concept a -> Const (Endo [a]) (Concept a)
14:15:46 <paolino>         Actual type: APrism' (Concept a) a
14:17:39 <cstrife> Why does lens use e
14:17:45 <cstrife> Sry
14:18:07 <cstrife> Why does lens use eg _1 instead of an Int argument?
14:18:25 <EvanR> my poor docs, they link between each other OK, but links to Int, String, IO, etc are not there, and links to Functor, Traversable, Monoid are just wrong
14:18:26 <glguy> paolino: read my second to last message about "ypu can use"
14:18:30 <cstrife> Or a type level Int
14:19:44 <lyxia> cstrife: the problem of an Int argument is that then the type of the lens would depend on the value of the parameter.
14:20:02 <cstrife> Ah yeh
14:20:24 <lyxia> A type level int is possiblem just too much hassle
14:21:39 <paolino> glguy, I cloned both but still I have a Text vs a unmatching
14:21:46 <cstrife> Seems like the overhead in defining for large tuples should be abstracted
14:21:54 <enthropy>  class FieldN (n :: Int) s t a b could replace the Field1 through Field9. The code you write would probably end up being the same
14:22:20 <glguy> paolino: then perhaps you have the wrong type signature somewhere
14:22:31 <paolino> glguy, it's [AReview (Concept Text) s]
14:22:48 <paolino> against  [(s -> Const (Endo [s]) s)
14:22:49 <paolino>       -> Concept a -> Const (Endo [s]) (Concept a)]
14:22:58 <cstrife> Its aspects like that which render the documentation opaque
14:23:10 <thoughtpolice> In general if you have Really Large Tuples, you should probably just wrap that in a datatype and use makeLenses, or whatever. I believe lens specifies up-to _9
14:23:39 <thoughtpolice> I rarely even go past "raw" triples, tbh. 9-sized tuples is pretty intense (although it can arise in some cases, I guess)
14:24:06 <thoughtpolice> Maybe if you're doing some awkward type-level stuff.
14:24:47 <cstrife> How do streams and traversables compare?
14:24:57 <paolino> glguy, and querynGood typechecks and even work
14:25:22 <cstrife> Traversals sorry
14:25:49 <soLucien> what would be the best way to implement a regex parser which in haskell ? Can i use any of the well-known monads ?
14:26:03 <soLucien> i mean i should use a monad probably 
14:26:16 <cstrife> What is a prism?
14:26:23 <soLucien> but i don't see what is a "monadic step" in that case
14:26:46 <systemfault> A co-lens </troll>
14:26:55 <systemfault> Seriously, I would like to know too :)
14:27:45 <cstrife> #blinkers
14:28:07 <soLucien> thinking i could use applicative heavily to start "non-deterministic" behavior
14:29:53 <cstrife> I suppose a good start would be understanding what s t a b stands for
14:30:52 <soLucien> if i want to match all patterns of "a*b" in text , how could i do it in haskell ?
14:31:45 <cstrife> > dropWhile (/= 'b') "rocklobster"
14:31:48 <lambdabot>  "bster"
14:32:13 <cstrife> That should help
14:32:18 <EvanR> soLucien:  a regex parser is not really any different from any other parser
14:32:25 <EvanR> nothing special going on
14:32:27 <EvanR> use parsec
14:33:09 <soLucien> was thinking of doing that, yes
14:33:44 <soLucien> but i thaught there should be some other (maybe cleaner/more ingenious) way
14:34:06 <lyxia> cstrife: a lens is a composable getter/setter, a prism is a composable destructor/constructor.
14:34:15 <lyxia> somewhat
14:34:41 <cstrife> Its good practice to define such easy to define functions and observe the higher order function
14:34:49 <EvanR> soLucien: regexes are expressions, so you need to parse them like other expression languages
14:35:15 <EvanR> a tool comes with parsec for making that easy
14:35:18 <ab9rf> soLucien: most regexps can be fairly trivially translated to parsec.
14:35:22 <soLucien> i wrongly formulated my question
14:35:25 <soLucien> i need a regex interpreter
14:35:40 <ab9rf> you want to actually USE regexps? why?
14:35:45 <cstrife> Omg! That's what I have been looking for this whole time! But I thought I had found it with streams, are they isomorphic to prisms?
14:35:47 <ab9rf> regexeps suck
14:35:59 <EvanR> soLucien: we have regex libs already, is this some kind of exercise
14:36:07 <soLucien> yes
14:36:26 <EvanR> to make regex work, you build an automaton
14:36:36 <EvanR> a state machine which scans the string
14:37:09 <lyxia> cstrife: what stream are you talking about
14:37:21 <cstrife> Can anyone give me a good prism reference?
14:37:44 <cstrife> Oh, maybe I mean pipes
14:37:51 <cstrife> The one with proxy
14:38:14 <EvanR> theres a pipes tutorial in the pipes library
14:38:23 <cstrife> No! For prisms
14:38:29 <lyxia> pipes have little to do with prisms
14:38:58 <EvanR> yeah, pipes are round and prisms are rectilinear
14:39:02 <cstrife> And are they the same as stack?
14:39:52 <paolino> they are both from geniuses
14:40:53 <joncol> Any Repa people here? I'm a beginner having some issues with the fromFunction function. The problem is that my renderPixel is of type :: (MonadReader Scene m, MonadIO m) => DIM2 -> m (Double, Double, Double), and I'm not sure that I can (or should) get `fromFunction` to accept this function returning a monadic value?
14:42:11 <cstrife> So as far as I understand it the notion of generators and consumers underpins pipes, which seems very similar to the composable deconstrctor/contructor which is a prism
14:43:12 <EvanR> cstrife: no PM
14:43:57 <cstrife> Stop this hostility please
14:44:05 <shapr> cstrife: huh?
14:44:21 <monochrom> What hostility?
14:45:00 <shapr> The only prisms I know in Haskell are part of the lens library.
14:49:41 <hodapp> I need to learn about pipes... just listened to the Gabriel Gonzalez interview on Functional Geekery
14:55:03 <EvanR> nice reference
14:56:18 <hodapp> hrm?
14:56:57 <EvanR> i havent listened to it yet, but i posted it in the slack for my haskell meetup
14:57:09 <hodapp> I thought it was a good podcast
14:57:09 <EvanR> which is today at 7!
14:57:31 <soLucien> now i understand you :)
14:57:52 <hodapp> I find it interesting that he mentioned the ability to very quickly refactor (for the more extensive definition of 'refactor', not just 'search and replace') a program as being a benefit of Haskell
14:58:00 <hodapp> I noticed the same thing when I started using embedded Haskell at my job
14:58:01 * hackagebot semdoc 0.1.2 - Evaluate code snippets in Literate Haskell.  https://hackage.haskell.org/package/semdoc-0.1.2 (iphydf)
14:58:07 <hodapp> and my boss changed what he wanted multiple times per week
14:58:37 <iphy> my package fails on NixOS, because it uses ghc 8.0.1 or something, and I only support up to 7.10
14:58:41 <hodapp> and after the initial setup I was able to quickly keep refactoring things without extensive copying-and-pasting
14:58:44 <EvanR> agreed
14:58:47 <iphy> ^ that one, semdoc
14:58:59 <hodapp> so that when he decided a week later that the thing I originally wrote was actually what he wanted, it was all still building and running
14:59:39 <jophish_> Is it ok that I'm using this: (.⋮) = (.) . (.) . (.)
14:59:48 <EvanR> wacky
14:59:51 <monochrom> yes
14:59:54 <jophish_> phew
15:00:04 <hodapp> o_O
15:00:05 <monochrom> But you need a 20-pt font
15:00:06 <EvanR> you could also do (.::) then the number of dots will match
15:00:07 * hodapp smacks jophish_
15:00:35 <jophish_> EvanR: I was hoping .:: could be fore (.) . (.) . (.) . (.)
15:00:50 <jophish_> :t (.) . (.) . (.) . (.)
15:00:52 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
15:01:15 <EvanR> thats (.:::)
15:01:22 <jophish_> one argument on the left "." four on the right "::"
15:02:27 <n_blownapart>  hello for marketability, ie gainful employment opportunity, should I drop learning scheme for haskell ? I like math and I'm trying to learn the lambda calculus using the sicp scheme book. It's very hard for me. should I drop it for haskell?
15:02:27 <Tuplanolla> Is braille valid in identifiers?
15:02:39 <hodapp> n_blownapart: learn both.
15:02:59 <hodapp> n_blownapart: be aware though that simply-typed lambda calculus probably leads more into Haskell territory!
15:03:20 <monochrom> scheme and haskell are equally hard
15:03:35 <n_blownapart> what about the whole category theory business hodapp ? monochrom
15:03:37 <EvanR> SICP is a great book
15:03:43 <monochrom> however I don't see the connection between marketability and difficulty
15:03:44 <hodapp> yes, I highly recommend SICP
15:04:08 <mmaruseacph2> and the sister SICM book
15:04:14 <hodapp> SICM?
15:04:14 <mmaruseacph2> (classical mechanics)
15:04:17 <hodapp> huh
15:04:29 <n_blownapart> I rely so much on online solutions for the sicp and chatrooms. I could never write those solutions myself as expected 
15:04:31 <monochrom> for marketability you should get training for construction worker
15:04:32 <soLucien> okay so i want to implement a function (maybe a monad as well) which will be able to interpret regex patterns such as "go*f" and tell me whether some string can match it (ex. goof, golf). Should i use the list monad (look into using applicative on a list of chars), Parsec (write a parser function that supports wildcards) , or would it be better to implement my own monad ?
15:04:32 <Tuplanolla> @let ⠆⠕⠃⠋ = id
15:04:34 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (10246) is outside of bounds (0,255)
15:04:37 <mmaruseacph2> https://mitpress.mit.edu/sites/default/files/titles/content/sicm/book.html
15:04:40 <mmaruseacph2> hodapp: ^
15:05:00 <n_blownapart> monochrom: ugg, used my back my whole life.
15:05:11 <soLucien> from all 3 , the Parsec would be easiest to implement, but it relies on an external lib
15:05:52 <EvanR> Tuplanolla: whut o_O
15:05:54 <monochrom> Sure, but that doesn't change the fact that construction workers are more marketable than programmers.
15:05:57 <n_blownapart> anyone, what about learning category theory?
15:06:02 <monochrom> The market doesn't care.
15:06:06 <mmaruseacph2> @let _⠆⠕⠃⠋ = id
15:06:07 <lambdabot>  Parse failed: Parse error: =
15:06:13 <mmaruseacph2> almost
15:06:21 <Tuplanolla> It's actually valid operator syntax.
15:06:25 <Tuplanolla> Try it in your GHCi.
15:06:46 <Tuplanolla> Like this: `let (⠆⠕⠃⠋) = (+) in 2 ⠆⠕⠃⠋ 3`
15:07:43 <n_blownapart> ok well, so stick with sicp until I'm 80 years old  ?
15:08:00 <xcmw> This is probably impossible but can w be typed?
15:08:01 * hackagebot ngx-export 0.2.4.2 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.4.2 (lyokha)
15:08:10 <xcmw> http://lpaste.net/330151
15:08:31 <jophish_> should braille characters be operators...?
15:08:46 <Tuplanolla> Probably not.
15:09:05 <n_blownapart> jophish_: that will certainly make one go blind
15:09:20 <Tuplanolla> I can use them for atrocities regardless.
15:09:29 <mmaruseacph2> reminds me of te "don't play with monads or you'll go bind" CCC-comic
15:09:30 <geekosaur> unicode for some reason defines them as Symbol :/
15:09:33 <n_blownapart> !!
15:11:00 <monochrom> Something is wrong with wholesalely declaring that all Braille symbols are letters or all Braille symbols are symbols or all Braille symbols are numerals or...
15:11:16 <n_blownapart> hodapp: please explain : be aware though that simply-typed lambda calculus probably leads more into Haskell territory!
15:11:20 <monochrom> Surely some Braille symbols stand for letters, some stand for numerals, some stand for punctuations, etc etc.
15:12:36 <hodapp> n_blownapart: to simplify a lot: untyped lambda calculus leads you more into Lisp territory; typed lambda calculus leads down a sort of different path
15:13:43 <monochrom> actually I think Haskell is harder than Scheme. But only a little bit.
15:14:22 <n_blownapart> thank you hodapp . I realize this is the haskell chat, but if one wants to learn to program well while getting a decent math background along the way, for eventual purposes of gainful employment , where should I spend my time?
15:14:27 <monochrom> but still I maintain that both are laughably unmarketable compared to construction labour and accounting.
15:16:07 <n_blownapart> monochrom: I heard within a few years big data will have half a million unfilled jobs as a field. 
15:16:10 <hodapp> oh, if it's for gainful employment, then I really don't know
15:16:21 <n_blownapart> hmm
15:26:47 <n_blownapart> hodapp: monochrom well, put differently, I feel like I understand new math ideas better when I can see code operating. If one were to study math, category theory, et al , if interesting jobs were some day available... any comment? I'm a bit lost.
15:28:19 <n_blownapart> ie which language is better for (higher) math?
15:30:32 <synapticplastic> Question : Does anyone here have a good resource for understanding the type system?
15:31:02 <synapticplastic> I have been seeing types with operators in them that seem to be part of the language but I cannot find info on. :~> , ~ , etc.
15:31:46 <synapticplastic> I'm always learning when it comes to inferring information from type sigs but I hit a wall when it comes to things like that.
15:31:58 <ongy> ~> is syntax. and iirc infix type constructors can start with :
15:32:45 <hpc> i thought (~>) was an identifier
15:32:47 <dmj`> synapticplastic: are you referring to servant
15:33:02 * hackagebot simple-effects 0.4.0.0 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.4.0.0 (darwin226)
15:33:12 <dmj`> :~> is from servant iirc
15:33:52 <ongy> oh, maybe ~> was only used in the paper and not actually in implementation?
15:34:05 <synapticplastic> I am referring to servant in that case, yeah. And I saw that they use it as an operator for a "natural transformation"
15:34:08 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#equality-constraints is ~
15:34:09 <dgpratt> seems to be defined in a bunch of places http://hayoo.fh-wedel.de/?query=%28%3A%7E%3E%29
15:34:26 <dgpratt> (including servant)
15:35:17 <dmj`> synapticplastic: you'd have to enable TypeOperators to define things infix like that
15:35:29 <dmj`> @def newtype m :~> n = Nat { unNat :: forall a. m a -> n a}
15:35:33 <lambdabot>  Defined.
15:35:39 <dmj`> @info (:~>)
15:35:39 <lambdabot> (:~>)
15:35:47 <geekosaur> no :info here
15:35:55 <synapticplastic> And I guess that's where my question sort of lies; I didn't realize that type operators were a thing at all
15:36:05 <dmj`> :t Either String :~> Maybe
15:36:08 <lambdabot> error:
15:36:08 <lambdabot>     • Data constructor not in scope: Either :: t1 -> t0
15:36:08 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
15:36:28 <synapticplastic> I understand types as more of a documentation and constraint system, are they more than that?
15:37:33 <adimit> synapticplastic: technically, you can use types for computation.
15:37:49 <adimit> also, curry/howard. They're a way to prove invariants about your program.
15:38:18 <dgpratt> synapticplastic: are you familiar with any programming languages that have "generics" (e.g. C# or Java)?
15:38:19 <synapticplastic> That seems to be a lot of what servant is doing under the hood
15:39:09 <EvanR> generics correspond to regular polymorphism in haskell, does it
15:39:13 <EvanR> doesnt it
15:39:20 <adimit> synapticplastic: I've always thought of types as a mini-prolog that runs alongside my program during compile time and nudges everything into the right place. Yes, Servant does a lot of taht.
15:39:22 <synapticplastic> I am not. Most of my experience is web dev / python
15:39:45 <dmj`> synapticplastic: with typeclasses you can reify types as values, so servant recursively calls a typeclass until it has traversed the entirety of the type, reifying different things. In some cases it has an associated type family which turns into a function signature
15:40:04 <adimit> EvanR: roughly, yes. List<T> is like [a]. Somewhat. 
15:40:58 <synapticplastic> @dmj` So, you can use types as a kind of formal logic alongside the program. If type A can be B or C, and B is 2 and C is 2, then A must be 2. Something like that?
15:40:58 <lambdabot> Unknown command, try @list
15:42:20 <dmj`> synapticplastic: you can definitely do type level computation, if you check out the singletons package it has a type level Prelude, and much more
15:42:32 <dmj`> @package singletons
15:42:32 <lambdabot> http://hackage.haskell.org/package/singletons
15:43:15 <ski> @kind Either String :~> Maybe
15:43:17 <lambdabot> *
15:43:32 <synapticplastic> I'll look at it now. Doing computation with types is a really interesting idea.
15:43:49 <adimit> synapticplastic: welcome to the wonderful world of types. Take 45 minutes, sit back and relax: https://www.youtube.com/watch?v=IOiZatlZtGU
15:44:15 * ski didn't follow what synapticplastic meant by "If type A can be B or C, and B is 2 and C is 2, then A must be 2."
15:45:02 <synapticplastic> I was asking whether it was possible to constrain a type to the point where it can only exist as a single concrete value
15:45:26 <ski> (if anything, i'd say `A' would be `4', there)
15:45:37 <adimit> synapticplastic: yes. data Foo = Foo
15:46:18 <synapticplastic> Which looks possible. also, @adimit, watching now :) You guys have given me a lot of stuff to look at, thank you.
15:46:23 <adimit> The type Foo is inhabited by exactly one value, and that happens to be called Foo, too.
15:46:42 <ski> synapticplastic : really still too vague (for me at least) ..
15:47:09 <ski> you might be thinking of subtyping or refinement types ..
15:47:37 <ski> .. or, squinting, singleton types (mentioned by dmj`) could fit the bill, though i doubt it
15:47:58 <synapticplastic> The vagueness is a symptom of me really not knowing enough to talk about these things correctly :\
15:48:00 <ski> or perhaps some variant of what adimit is talking about
15:49:45 <ski> (also, another thing would be "singleton values" (or how you want to call it), where you make sure to only construct and export one value of a type, even though your implementation could make more than one)
15:50:34 <ski> synapticplastic : .. i suppose you can't give or describe an example of what you're trying to talk about ?
15:50:45 <adimit> ski: I don't think what I said is what synapticplastic meant. But it's the trivial case of a type with just one value.
15:51:10 <adimit> so I thought it could serve an educational purpose :-)
15:51:14 <dmj`> type SomeConstraint a b c = ( a ~ b, a ~ c, c ~ 2, b ~ 2 )
15:51:46 <erisco> squiggle
15:52:03 <dmj`> > replicate 5 '~'
15:52:03 <synapticplastic> Well, for example. From servant ||| type UserAPI1 = "users" :> Get '[JSON] [User]
15:52:06 <lambdabot>  "~~~~~"
15:52:47 <synapticplastic> in that type sig, it's not just a data type with one possibility. There is a fixed value, "users", in the type itself. That is intriguing to me, and I don't know how it works
15:53:25 <ski> synapticplastic : oh, that's (more or less) data kinds
15:53:37 <dmj`> synapticplastic: right, so there's some class parameterized by a PolyKinded type k, typeHasServer (api :: k) where type Server a :: *
15:53:48 <dmj`> "HasServer" *
15:53:56 <dmj`> class HasServer*
15:54:12 <soLucien> does anyone know of a way to represent a directed cyclic graph in Haskell ?
15:54:19 <ski> synapticplastic : "values at the type level", so to speak
15:54:39 <synapticplastic> Data Kinds are a way of expressing those?
15:54:41 <ski> synapticplastic : e.g. you can have a list of types
15:54:48 <erisco> soLucien, you can index (possibly using the label)
15:55:53 <erisco> soLucien, one I think is interesting is  type Graph a = Maybe a -> Maybe a
15:56:04 <erisco> sorry, I mean  type Graph a = Maybe a -> [a]
15:56:21 <ski> what's the `Nothing' input for ?
15:56:35 <soLucien> ski when there is no edge between 2 vertices ?
15:56:47 <erisco> ski, the top, topologically
15:56:49 <byorgey> presumably for the vertices with no incoming edges?
15:57:06 <ski> erisco : what's the top in a graph ?
15:57:18 <buttbutter> Is there a single function that encapsulates liftM f $ liftM g x? 
15:57:48 <hpc> liftM = fmap
15:57:51 <erisco> ski, order of the sccs
15:57:51 <ski> buttbutter : `liftM (f . g) x' ?
15:57:53 <hpc> so that's fmap f $ fmap g x
15:57:59 <hpc> which is fmap f . fmap g $ x
15:58:03 * hackagebot multi-trie 0.1 - Trie of sets, as a model for compound names having multiple values  https://hackage.haskell.org/package/multi-trie-0.1 (vadimvinnik)
15:58:13 <hpc> and you can reduce (fmap f . fmap g) to fmap (f . g)
15:58:31 <buttbutter> Ah, right. I'm an idiot. :)
15:58:35 <buttbutter> Thanks, hpc ski. :)
15:59:19 <soLucien> erisco so this has nothing to do with the representation of the adjacency matrix
15:59:24 <erisco> that is slightly wrong... better to say it as byorgey has
16:00:03 <erisco> I am not aware of how you do directed with adjacencies
16:00:10 <ski> synapticplastic : `DataKinds' allows you to define your own custom (data) kinds, specifying a set of data constructors as usual for them, except that now they'll take things at the type level as arguments, and produce a type-level result
16:01:05 <erisco> I guess you pick either vertical or horizontals to be initials?
16:04:19 <erisco> a matrix is a way to do it. You're likely to end up with some indirect way of having cycles
16:05:00 <erisco> you can tie the knot and that makes some algorithms much simpler
16:05:09 <soLucien> erisco for n nodes create a n X n matrix, then if there's a edge from x to y , you place a 1 in row x column y. if there's an edge from y to x, place a 1 in row y column x
16:05:19 <soLucien> the rest 0s
16:05:28 <erisco> and approach is to find the cycles as a last step
16:05:52 <erisco> right, okay
16:06:54 <erisco> wrt knot tying I am saying you can use a rose tree
16:08:43 <soLucien> my task is to 1 ) create the graph given some definition for a node 2 ) topologically sort 3) walk the graph and decide whether i can get from a to b
16:09:06 <soLucien> which one of the approaches do you think would work better in Haskell ?
16:09:17 <erisco> the nice thing with  Maybe a -> [a]  is that composing graphs is as easy as functions
16:09:31 <soLucien> the Maybe a -> [a] or the matrix ?
16:09:39 <erisco> but you do need to know where you want to be looking on the graph, i.e. some starting vertex or vertexes
16:10:19 <erisco> there is no way to answer "all vertexes" or "all edges" with such a representation
16:11:54 <erisco> well I'd just pick up a graph lib which already had the sort function
16:12:12 <soLucien> erisco which monad could best encapsulate this behavior ? Some form of the State monad, right ?
16:13:08 <soLucien> i need to be able to 1) parse nodes and decide where to link them in the graph 2) query the graph (can you get from a to b)?)
16:13:15 <erisco> it looks like, if numbers were functions, 3 . 2 . 1
16:14:47 <erisco> what is the state? the graph? just use function composition to ferry it along
16:15:04 <soLucien> the graph, yes
16:15:19 <soLucien> empty in the beginning, then munching nodes adds stuff to it
16:15:43 <soLucien> so your advice is start writing down the functions
16:15:53 <soLucien> and once i see repetition, write the monad
16:16:27 <erisco> I am not so sure any monad is necessary. I'd type (as in, give types to) your high level steps and try filling them in
16:17:22 <erisco> you'd use State if you had functions which take the graph plus something else
16:18:18 <erisco> and modify the graph, of course, otherwise Reader
16:22:09 <erisco> type Graph a b = Maybe a -> b -> [a]   for labeled edges
16:22:57 <erisco> perhaps a little awkward on Nothing, not sure
16:24:35 <erisco> Maybe (a, b) -> [a]   doesn't look as pretty
16:24:49 <EvanR> accepting Maybe is weird
16:25:56 <erisco> it is for vertexes without any incoming edges
16:26:31 <erisco> if your graph doesn't have those then you don't need it
16:26:58 <Koterpillar> how do enumerate edges here?
16:27:01 <Koterpillar> *to
16:27:17 <erisco> you don't, that is the benefit and weakness
16:27:40 <Koterpillar> Can you change it to -> [(b, a)] ?
16:27:52 <erisco> yes but that has different implications
16:28:02 <Axman6> any reason not use be using fgl for graph stuff?
16:28:04 * hackagebot th-to-exp 0.0.1.0 - Provides a way to persist data from compile-time to runtime.  https://hackage.haskell.org/package/th-to-exp-0.0.1.0 (lexi_lambda)
16:28:12 <Axman6> or is this just for fun?
16:28:40 <erisco> if it is on the right of -> then I'm telling you, so I have to know it all
16:28:49 <erisco> if it is on the left of -> then you tell me and I just check if it works
16:29:11 <erisco> this lets you create graphs with complicated adjacencies
16:29:27 <erisco> at the trade off of the user needing to know where they want to look
16:32:04 <soLucien> erisco it's not fully connected , so there may be no incoming edges for some nodes
16:32:12 <soLucien> it's modeling a task scheduler
16:33:37 <erisco> sufficient but not necessary
16:35:32 <soLucien> the only relationship is dependsOn
16:35:40 <soLucien> so no need to label the edges
16:38:09 <erisco> you have to know even less if you use  Maybe a -> a -> Bool
16:38:30 <erisco> which neatly is equivalent to an adjacency relation
16:40:46 <erisco> you can figure all this out just from the features of your graph and whether you have an algorithm to enumerate
16:43:09 <erisco> (and possibly performance consideration wrt iterating through the enumerations versus indexing exactly what you want)
16:44:04 <EvanR> any idea what this warning is while cabal installing: Unrecognized field abi on line 21
16:44:53 <erisco> well, abi is the application binary interface, likely
16:45:47 <erisco> maybe it is a platform specific problem
16:45:50 <EvanR> uh huh
16:49:12 <soLucien> thanks a lot, erisco !
16:49:43 <monochrom> EvanR: In a "package conf file" (*.conf, this is GHC's metadata format for libraries you have installed), there is an "abi" field, this is new in GHC 8.0.1, it was not there in GHC 7.10 IIRC
17:14:45 <iphy> is there a source code annotator for haskell, something that generates hyperlinked HTML from source code?
17:15:01 <Koterpillar> iphy: haddock?
17:17:39 <iphy> Koterpillar: hyperlinked
17:17:45 <iphy> so I can click on things in the html
17:17:53 <iphy> https://hackage.haskell.org/package/HTTP-4000.3.3/docs/src/Network-Browser.html
17:17:56 <iphy> nothing here is clickable
17:18:17 <Koterpillar> I've seen it clickable too, can't remember where
17:19:00 <MarcelineVQ> one of the first things in that page is clickable ^^; " request $ getRequest "http://www.haskell.org/""
17:20:01 <Koterpillar> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Control.Arrow.html
17:20:23 <Koterpillar> iphy: ^ clickable
17:20:53 <iphy> Koterpillar: oh yes
17:20:55 <iphy> good
17:29:55 <dmj`> anyone have lambdabot integrated with slack
18:11:53 <jle`> is there a Const-like newtype over Applicative instances that just ignores the result
18:13:16 <ertes> jle`: Proxy?
18:13:24 <jle`> it should sequence the effects too
18:13:58 <jle`> is this lawful
18:14:07 <ertes> jle`: yeah, sounds like a monoid to me
18:14:08 <jle`> writing the instance now
18:14:27 <jle`> oh yeah it'd just be like a monoid wrapper over Applicative with (<>) = (*>)
18:14:29 <jle`> is this in base?
18:14:32 <ertes> newtype JustDoIt m = JustDoIt (m ())
18:15:07 <ertes> well, every Applicative *could* be a monoid in that way:  instance (Monoid a) => Monoid (F a)
18:15:09 <jle`> or newtype JustDoIt m a = JustDoIt (m a)
18:15:19 <ertes> then just use a = ()
18:15:20 <jle`> yeah, ofc, but is there already something in base for this?
18:15:27 <ertes> i don't think so
18:16:22 <jle`> well
18:16:25 <jle`> there should be >:(
18:16:27 <ertes> if you need something that works for any Applicative, you'll have to define it yourself, but ideally you would just send a patch to any Applicative author that doesn't have that Monoid instance
18:17:07 <jle`> oh that newtype over Applicative that flips the effects isn't even in base
18:17:18 <jle`> it might be in transformers ...
18:17:27 <jle`> oh hey it is
18:17:45 <jle`> i always forget that transformers has handy Applicative transformers too, and not just monad transformers
18:18:21 <ertes> why don't you just use Applicative itself?  (*>) is monoidal by law when result types are ()
18:18:40 <jle`> oh, Validation is also in transformers
18:18:40 <ertes> and (pure ()) is the identity
18:18:49 <jle`> i always pulled it from the 'either' package
18:19:25 <jle`> ertes: i am using it with monoid-polymorphic hofs
18:19:34 <jle`> like mconcat
18:19:52 <ertes> i see
18:19:56 <jle`> well actually it's a bit of a roundabout hack to use traverseWithKey from Data.Map
18:20:00 <jle`> except i want traverseWithKey_
18:20:12 <jle`> but that's not offered
18:20:22 <jle`> but if i just did void (traverseWithKey .. ..), that builds up the map
18:20:56 <jle`> so i can do traverseWithKey w/ Const m
18:21:01 <jle`> where m is my monoid wrappver over my applicative
18:29:14 <soLucien> what is the cleanest way to perform a replace in an array ? [Foo , Bar "bar", Foo] i want to replace all instances of Foo with Bar "foo"
18:29:43 <Koterpillar> soLucien: map
18:31:11 <jle`> soLucien: do you have an array or a list?
18:31:34 <soLucien> map (\x -> if (x == Foo) then (Bar "foo") else x) 
18:31:34 <soLucien> ?
18:32:05 <Koterpillar> map replaceFoos where replaceFoos Foo = Bar "foo"; replaceFoos x =x 
18:34:09 <agent_sm1th> hello
18:34:53 <Koterpillar> hello
18:35:27 <agent_sm1th> this is the first time I use IRC in my life
18:35:29 <agent_sm1th> pretty sweet
18:35:53 <EvanR> neo just left
18:36:14 <agent_sm1th> guess I'll have to leave to, to hunt him down
18:36:42 <agent_sm1th> I was wondering if anyone knows how to set up 'jump to definition' with vim
18:37:05 <agent_sm1th> or even just to open the source of an import
18:38:08 * hackagebot XSaiga 1.2.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.2.0.0 (InBetweenNames)
18:38:46 <Axman6> agent_sm1th: might find this useful: http://www.stephendiehl.com/posts/vim_2016.html
18:39:15 <Axman6> ghc-mod should give you a lof of what you want
18:39:48 <xcmw> How can I type w? http://lpaste.net/330151
18:40:39 <Koterpillar> xcmw: it's a tuple
18:41:14 <Koterpillar> xcmw: sorry, ignore that... still reading
18:41:22 <soLucien> Koterpillar what if i want to extract foo from Foo "foo" for concatMap ?
18:41:33 <Axman6> that looks like it's breaking the momomorphism restriction
18:41:44 <Koterpillar> soLucien: example?
18:42:11 <soLucien> [Foo "a" , Foo "b", Foo "c"] -> "abc"
18:42:16 <soLucien> with concatMap
18:42:18 <jle`> soLucien: probably wouldn't ocmpare with ==, use pattern matching :)
18:42:26 <jle`> also in that case it might be easier to just use lits comprehensions
18:42:28 <Koterpillar> :t mapMaybe
18:42:30 <lambdabot> (a -> Maybe b) -> [a] -> [b]
18:42:31 <ertes> xcmw: the way you wrote it you would need a rank-2 type
18:42:49 <agent_sm1th> I had my functional programming exam yesterday.
18:42:58 <soLucien> i tried concatMap (\Foo a -> a) 
18:43:00 <jle`> map (\case Foo -> Bar "foo"; Bar x -> Bar x)
18:43:02 <agent_sm1th> Let me know if someone wants me to post it here for the lols.
18:43:02 <Axman6> it might be something like: w :: (forall r. (CCC r b) => Lens (A a) (r b)) -> (RRR b, QQQ b)
18:43:08 <Koterpillar> soLucien: mapMaybe getfoo where getfoo (Foo x) = Just x; getfoo _ = Nothing
18:43:09 <Axman6> xcmw: ^^
18:43:20 <ertes> xcmw: what Axman6 wrote
18:43:20 <soLucien> and (\a -> let a = Foo b in b)
18:43:32 <jle`> concatMap (\case Foo a -> a)
18:43:38 <Axman6> ertes: did I nail it? D:
18:43:39 <jle`> agent_sm1th: congrats :)
18:43:53 <ertes> Axman6: i don't know, but it looks promising =)
18:44:45 <Axman6> xcmw: to use that type, you'll probably need some more extensions, like Rank2Types
18:44:52 <Axman6> (or RanNTypes)
18:44:56 <ertes> agent_sm1th: welcome to the oldest chat after roman forums =)
18:45:02 <Axman6> RankNTypes*
18:45:28 <xcmw> Ok will try
18:45:30 <ertes> (they probably have that extension turned on anyway, because you can't do anything with lenses without it)
18:46:20 <soLucien> jle` parse error on input `case'
18:46:25 <Axman6> you can use them without IIRC
18:46:46 <xcmw> Parse error (line 44, column 15): Illegal symbol '.' in type
18:46:46 <xcmw> Perhaps you intended to use RankNTypes or a similar language
18:47:00 <ertes> yeah, that might work, but you need them even just to use the type aliases
18:47:09 <Koterpillar> > (mapMaybe getfoo where getfoo (Right x) = Just x; getfoo _ = Nothing) [Left "bar", Right "baa", Right "baz", Left "zzz"]
18:47:11 <lambdabot>  <hint>:1:18: error: parse error on input ‘where’
18:47:17 <xcmw> I did enable RankNTypes
18:47:19 <ertes> xcmw: write this at the top of the file:  {-# LANGUAGE RankNTypes #-}
18:47:23 <Koterpillar> soLucien: well, that one
18:47:40 <ertes> (above the first non-comment)
18:47:44 <xcmw> ertes: I added that same error
18:47:55 <xcmw> I updated the lpaste
18:47:58 <Axman6> xcmw: can you update the paste to show all the code please?
18:48:04 <Axman6> nevermind =)
18:48:09 * hackagebot XSaiga 1.3.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.3.0.0 (InBetweenNames)
18:48:21 <ertes> xcmw: and it still complains?
18:48:36 <agent_sm1th> ertes: thanks :)
18:48:49 <xcmw> ertes: Yes same error
18:49:05 <xcmw> I tried it multiple times
18:49:05 <ertes> that's weird
18:49:20 <ertes> did you save?  yeah, i know, stupid question…
18:49:23 <Axman6> I assume "-- How can I type w?" isn't actually in the file?
18:49:35 <xcmw> Does it work for you? I running it in an iHaskell jupyter notebook if that matters.
18:49:40 <ertes> even if it is, comments may be above the language pragma
18:50:43 <ertes> what is that?  is that an actual notebook made specifically for haskell hacking or something?
18:51:08 <Koterpillar> ertes: ihaskell = jupyther (nee ipython) plus haskell kernel
18:51:20 <xcmw> ertes: I am running it in a file now
18:51:24 <ertes> that…  didn't really help =)
18:51:33 <xcmw>  Expecting two more arguments to ‘Lens (A a) (r b)’
18:51:35 <xcmw>   Expected a type, but ‘Lens (A a) (r b)’ has kind ‘* -> * -> *’
18:51:40 <ertes> i'll look it up myself
18:51:48 <Axman6> you need Lens' for one
18:52:50 <xcmw> • Expecting one fewer argument to ‘r’
18:52:51 <xcmw>   Expected kind ‘* -> *’, but ‘r’ has kind ‘*’
18:53:01 <Axman6> oh, um, yeah that's a pretty weird program
18:53:06 <xcmw> I updated the lpaste again
18:53:33 <xcmw> I am working from a normal haskell file now
18:54:13 <Axman6> why exactly do you want to write this anyway? It seems like there could be much easier ways
18:55:45 <xcmw> Axman6: I have a bunch of records with the same property but different types. I need to be able to pass a single lens to a function and be able to ascess that property on any of the records.
18:56:59 <xcmw> I am writing a microdata recipe parser and each recipe has properties like title, author, ingredients, etc
18:57:24 <xcmw> Each of these properties has different types
18:58:09 * hackagebot XSaiga 1.3.0.1 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.3.0.1 (InBetweenNames)
18:58:57 <ertes> i just went to jupyter.org to find out what it is…  the main page was a useless pile of pretty pictures, so i followed my instinct and clicked on 'about' just to see the same useless pretty pictures and no explanation at all…  it's sad that wikipedia generally does a much better job at explaining something than the people behind it
18:59:20 <ertes> i think what people consider to be "modern web design" is actually a disease
18:59:24 <ertes> an epidemic even
19:00:12 <xcmw> I have a bunch of records these properties. One is to convert the HTMLElement to a where is the final type. Another is a list of the microdata properties to query. Another is the actaul recipe record.
19:00:29 <soLucien> can i use a list comprehension synthax to acheive this ? I want to replace all occurences of Foo with "foo" and extract the strings from the Bars ... so if i have [Foo, Bar "b" , Bar "ook is", Bar " a ", Foo] i would get "foobook is a foo"
19:01:39 <xcmw> • Expecting one fewer argument to ‘r’
19:01:40 <xcmw>   Expected kind ‘* -> *’, but ‘r’ has kind ‘*’
19:01:40 <xcmw> • In the second argument of ‘Lens'’, namely ‘r b’
19:01:40 <xcmw>   In the type signature:
19:01:41 <xcmw>     w :: (forall r. (CCC r b) => Lens' (A a) (r b)) -> (RRR b, QQQ b)
19:02:53 <agent_sm1th> is anyone familiar with hasktags? It looks promising, but it doesn't generate tags for packages installed with GHC.
19:04:42 <ertes> agent_sm1th: hasktags only works on source code
19:05:05 <Koterpillar> soLucien: mapConcat [ x | Foo x <- xs ]
19:05:41 <Koterpillar> soLucien: without mapConcat: [ c | Foo x <- xs, c <- x ]
19:05:57 <agent_sm1th> ertes: I see, and the source code of installed packages is not neccesarily available on your computer.
19:06:15 <ertes> agent_sm1th: yeah…  GHC is a compiler (and interpreter)
19:13:35 <agent_sm1th> So if I want to inspect the source code of a package, I'm left with Google?
19:13:44 <agent_sm1th> ertes: I'm guessing you know this website http://motherfuckingwebsite.com/
19:14:01 <Koterpillar> agent_sm1th: hackage -> view source?
19:15:03 <winter_> @undo do { Just y <- x; z }
19:15:03 <lambdabot> x >>= \ a -> case a of { Just y -> z; _ -> fail ""}
19:16:56 <ertes> agent_sm1th: haha, i didn't know that one!
19:20:31 <xcmw> ertes: w :: (forall r. Lens' (A r) (r b)) -> (RRR b, QQQ b) worked
19:23:10 * hackagebot XSaiga 1.4.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.4.0.0 (InBetweenNames)
19:28:46 <hellertime> how can I expose a name from a module for use by my test suite, but leave it hidden to hackage documentation?
19:35:45 <ski> hellertime : perhaps use an `X.Internal' module, and reexport it from `X' ?
19:36:54 <hellertime> yeah that makese sense. Im mostly just trying to keep from cluttering up things with internal names..
19:53:29 <joe9_> I am trying to figure out what "proxy ix" is in the definition of toDescList ? https://hackage.haskell.org/package/ixset-typed-0.3.1/docs/Data-IxSet-Typed.html
19:54:28 <joe9_> http://codepad.org/s0SNHhup are my data structures and I want to the find the maximum fsItemId
19:54:47 <joe9_> in this: http://codepad.org/s0SNHhup
19:54:55 <joe9_>   , cFSItems         :: IxSet FSItemIxs (FSItem (Context u))
19:55:35 <joe9_> I could just do a maximumBy . toList , but, want to know if I can do this using head . toDescList
19:58:11 * hackagebot warp 3.2.9 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.9 (KazuYamamoto)
20:00:24 <erisco> @undo do
20:00:25 <lambdabot> <unknown>.hs: 1: 3:Parse error: Last statement in a do-block must be an expression
20:01:23 <joe9_> toDescList :: forall proxy ix ixs a. IsIndexOf ix ixs => proxy ix -> IxSet ixs a -> [a]
20:01:27 <joe9_> is the function definition
20:03:11 * hackagebot normalization-insensitive 2.0.0.1 - Normalization insensitive string comparison  https://hackage.haskell.org/package/normalization-insensitive-2.0.0.1 (ppelleti)
20:08:00 <jle`> soLucien: you need LambdaCase on
20:08:06 <jle`> for \case Foo a -> ... syntax
20:08:12 * hackagebot nvvm 0.7.5.1 - FFI bindings to NVVM  https://hackage.haskell.org/package/nvvm-0.7.5.1 (TrevorMcDonell)
20:21:58 <EvanR> best way to combine a IO A, IO B, A -> B -> IO C, to get IO C. liftA2 and then join?
20:23:33 <Koterpillar> EvanR: do?
20:23:50 <EvanR> f =<< x =<< y ?
20:23:52 <EvanR> hrm
20:24:13 <EvanR> wouldnt work
20:24:26 <EvanR> Koterpillar: that takes so many lines!
20:24:39 <EvanR> and you have to make up variable names
20:24:45 <Rarrikins> @undo do { a <- f; b <- g; return (h a b) }
20:24:45 <lambdabot> f >>= \ a -> g >>= \ b -> return (h a b)
20:25:07 <Rarrikins> @unpl \f g h -> f >>= \ a -> g >>= \ b -> return (h a b)
20:25:07 <lambdabot> \ f g h -> f >>= \ a -> g >>= \ b -> return (h a b)
20:25:08 <Koterpillar> @undo \a b c -> do { ra <- a; rb <- b; c b a }
20:25:08 <lambdabot> \ a b c -> a >>= \ ra -> b >>= \ rb -> c b a
20:25:23 <EvanR> c <- something f x y
20:25:59 <mniip> there isn't a combinator for that I'm afraid
20:26:09 <EvanR> yeesh
20:26:32 <mniip> fmap (fmap join) . liftA2
20:26:33 <Rarrikins> @type liftM2
20:26:36 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:27:36 <Koterpillar> :t fmap (fmap join) . liftA2
20:27:38 <lambdabot> Monad m => (a1 -> b -> m a) -> m a1 -> m b -> m a
20:28:20 <Rarrikins> @pl \f g h -> f >>= \ a -> g >>= \ b -> return (h a b)
20:28:20 <lambdabot> (. ((. ((return .) .)) . (.) . (>>=))) . (.) . (>>=)
20:28:40 <Rarrikins> @pl \f g h -> f >>= \ a -> g >>= \ b -> h a b
20:28:40 <lambdabot> (. ((.) . (>>=))) . (.) . (>>=)
20:28:54 <soLucien> what's an easy way for checking if all the values in a list are True ?
20:29:01 <Koterpillar> :t all
20:29:01 <soLucien> i am doing smth like foldr [True] (||)
20:29:03 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:29:24 <Koterpillar> @type all
20:29:24 <soLucien> should be &&
20:29:26 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:29:27 <soLucien> okay
20:29:30 <soLucien> all
20:29:32 <Koterpillar> Rarrikins: you broke lambdabot
20:29:32 <soLucien> thanks
20:29:36 <Koterpillar> soLucien: 'all'
20:29:44 <Rarrikins> @botsnack
20:29:44 <lambdabot> :)
20:30:35 <Koterpillar> soLucien: also, did you try a search for [Bool] -> Bool?
20:31:11 <soLucien>  all (== True) [True,False] worked thanks
20:31:20 <Koterpillar> sorry, there's an easier way still
20:31:21 <soLucien> Koterpillar on hoogle 
20:31:26 <Koterpillar> and I don't mean all id ;)
20:31:36 <EvanR> (== True) is also known as id
20:31:37 <soLucien> ?
20:31:41 <Koterpillar> :t and
20:31:43 <lambdabot> Foldable t => t Bool -> Bool
20:31:54 <Koterpillar> http://hayoo.fh-wedel.de/?query=%5BBool%5D+-%3E+Bool
20:32:09 <Rarrikins> foldl' (&&) True [True, True, True]
20:32:12 <Koterpillar> @src and
20:32:12 <lambdabot> and = foldr (&&) True
20:32:13 <Rarrikins> > foldl' (&&) True [True, True, True]
20:32:15 <lambdabot>  True
20:32:28 <Koterpillar> @src all
20:32:29 <lambdabot> all p = and . map p
20:35:15 <EvanR> Rarrikins: i think dont want foldl' here because it can't short circuit
20:35:50 <Rarrikins> EvanR: Yeah, I was just testing that out with lambdabot :)
20:40:47 <mikeplus32> anyone have a favourite regex [to just strip comments from a language without polluting the parser with comment-related stuff] library for Text?
20:41:42 <EvanR> (seems like more work than just putting in a comment parser that produces nothing)
20:46:25 <mikeplus32> EvanR: idk. i'd have to wrap every parser that directly consume characters with e.g. comment :: Parser a -> Parser a
20:47:05 <mikeplus32> i'll try wrap the parsers from the library i'm using with that, that's what megaparsec seems to recommend
20:51:18 <EvanR> hmm, it was easier than that in my exprience, you could replace the whitespace parser with whitespace-or-comment parser
20:51:22 <MarcelineVQ> megaparsec has a comment parser in Lexer
20:53:17 <MarcelineVQ> https://mrkkrp.github.io/megaparsec/tutorials/parsing-simple-imperative-language.html has a nice example of how to set that up for yourself
20:55:53 <mikeplus32> i'm not actually using megaparsec, using trifecta, which doesn't make it so easy to replace the whitespace parser :-(
20:56:09 <mikeplus32> i'll check how idris does it
20:57:20 <Enzyme> Yupp, should turn off that weechat thing which dumps all the people in a channel on join...
20:57:48 <MarcelineVQ> check out the Token module of Trifecta then for some examples of things you might want to use
20:57:50 <EvanR> just never leave!
20:58:13 <MarcelineVQ> er it's in 'parsers' rather
21:00:10 <MarcelineVQ> trifecta re-exports http://hackage.haskell.org/package/parsers-0.12.4/docs/Text-Parser-Token.html I'm not sure what you mean by whitespace parsing not being easy to replace though, I'm curious as to how you're parsing now
21:01:04 <mikeplus32> i always forget about 'parsers' existence despite using it :l
21:02:42 <mikeplus32> MarcelineVQ: i'm just using the trifecta Parser instance of TokenParsing ... which i didn't realise the existence of
21:10:00 <Enzyme> EvanR: well, that's certainly an optin.
21:10:06 <Enzyme> s/optin/option/
21:18:14 * hackagebot normalization-insensitive 2.0.0.1 - Normalization insensitive string comparison  https://hackage.haskell.org/package/normalization-insensitive-2.0.0.1 (ppelleti)
21:18:14 * hackagebot nvvm 0.7.5.1 - FFI bindings to NVVM  https://hackage.haskell.org/package/nvvm-0.7.5.1 (TrevorMcDonell)
21:35:32 <jvanbure> does anyone have any strong opinions on the various smaller lens libraries like microlens or lens-simple?
21:37:44 <kadoban> jvanbure: They strike me as kind of not a great idea. If I'm going to use lens, I just use lens personally.
21:37:50 <kadoban> Wouldn't say it's a very strong opinion though.
21:38:22 <jle`> usually if i only need a couple of things from lens (like 'over', 'view', etc.) then i usually implement them myself
21:38:43 <jle`> i haven't really run into the halfway case yet
21:38:43 <jvanbure> in my case, i pull a dependency that lens isn't compatible with, so i can't really build it with lens
21:39:19 <kadoban> Oh ya? How does that work, some other version of something lens depends on?
21:40:58 <jvanbure> yeah i'm on haskell stack and i pull a newer version of containers than lens is okay with
21:41:23 <kadoban> Ah, that's unfortunate
21:41:29 <jvanbure> indeed :/
21:42:52 <Axman6> 4can you use a newer lens?
21:42:58 <Axman6> or a newer LTS?
21:43:09 * hackagebot dns 2.0.9 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.9 (KazuYamamoto)
21:43:12 <Axman6> why do you need a newer containers anyway?
21:43:31 <jvanbure> it wasn't entirely my decision
21:44:14 <Axman6> there haven't been a whole lot of compelling reasons to use a newer containers for a while, only minor changes have been made to it in the last few years afair
21:44:44 <kadoban> Weren't there a decent amount of moderate changes a couple of months back or so?
21:44:59 <jvanbure> there are a decent number of new functions in 0.5.8
21:45:13 <Axman6> yes, but most of them were (IMO) nice to haves more than amaziong new features
21:45:18 <jvanbure> speicfically the merge interface
21:45:26 <jvanbure> has been super useful
21:45:37 <jvanbure> also the Sequence functions are nice to have
21:58:26 <jle`> ~>jkjk
21:58:28 <jle`> .
23:17:49 <clmg> How can I get a caartesian product of variable dimension?
23:18:28 <clmg> I need [[x,y..] | x <- [1..], y <- [1..] ... etc]
23:19:38 <jle`> sequence is what you want for doing something liek that for arbitrary inputs
23:19:51 <jle`> > sequence ["abc","def","ghi"]
23:19:54 <lambdabot>  ["adg","adh","adi","aeg","aeh","aei","afg","afh","afi","bdg","bdh","bdi","be...
23:20:31 <jle`> if it's the same thing multiple times, you can use replicateM
23:20:38 <jle`> replicateM n xs = sequence (repeat n xs)
23:20:56 <jle`> > replicateM 4 "01"
23:20:59 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
23:21:01 <clmg> jle`: ah that's just what I need
23:21:09 <jle`> > sequence ["01","01","01","01"]
23:21:12 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
23:21:22 <clmg> > sequence (replicate [1,2])
23:21:23 <jle`> yeah, sequence generalizes the liftA2/liftA3/etc. (cartesian product for lists) pattern to N inputs
23:21:25 <lambdabot>  error:
23:21:25 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
23:21:25 <lambdabot>      • In the first argument of ‘replicate’, namely ‘[1, 2]’
23:22:29 <kadoban> Note that if you actually mean "[1..]", you'll have issues.
23:22:40 <clmg> > kadoban: I don't
23:22:43 <lambdabot>  error: Variable not in scope: kadobanerror:
23:22:43 <lambdabot>      Data constructor not in scope: I :: t0 -> [a]error: Variable not in scop...
23:22:44 <kadoban> Okay good
23:22:51 <clmg> whoops
23:24:44 <kadoban> Heh, why is that lambdabot output so weird?
23:25:05 <kadoban> Oh, just missing newlines ... or something. Nevermind.
23:29:21 <clmg> kadoban: this gives me exactly what I want:
23:29:32 <clmg> nub . map nub . map sort $ sequence (replicate len [1..len])
23:29:56 <clmg> but i'd like to do it without having to nub
23:31:21 <MarcelineVQ> do you need it in that specific order?
23:31:38 <clmg> MarcelineVQ: no, the order does not matter
23:31:39 <MarcelineVQ> because that looks like subsequences
23:31:55 <clmg> MarcelineVQ: ? tell me more :-)
23:31:56 <MarcelineVQ> > subsequences [1..3]
23:31:59 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
23:32:16 <clmg> omg that's what I need
23:32:20 <MarcelineVQ> nice
23:32:25 <clmg> !!!!
23:32:30 <EvanR> two nubs are better than one
23:32:31 <clmg> <3 haskell
23:33:40 <EvanR> > subsequences [0..] -- this should be uncountable hehe
23:33:43 <lambdabot>  [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3],[1,3],[0,1,3],[2,3],[0,2...
23:34:20 <clmg> yeah how is it doing that
23:34:32 <EvanR> it doesnt appear to have any infinite subsequences
23:34:32 <clmg> magic
23:34:37 <EvanR> so nevermind
23:55:09 <athan> :O bitcoin transactions form a category
23:55:16 <athan> because it
23:55:33 <athan> transactions are just setwise functions, and elements of the set are bitcoin addresses
23:55:48 <athan> (sparse set functions)
23:56:07 <athan> er bitcoin addresses form objects of the category, and transactions arrows
23:57:13 <kadoban> athan: Bitcoin transactions don't necessarily come from, or go to, an address.
23:59:18 <athan> kadoban: ? can you provide a counterexample?
