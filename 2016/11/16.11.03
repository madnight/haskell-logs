00:00:56 <joe9> why is there no Data.Monoid instance for ByteStringM
00:00:56 <joe9> s/ByteStringM/ByteString/
00:02:34 <EvanR> there is...
00:06:45 <Xnuk> > BSC.singleton 'a' <> BSC.singleton 'b'
00:06:47 <lambdabot>  "ab"
00:06:53 <Xnuk> :t BSC.singleton 'a'
00:06:55 <lambdabot> BSC.ByteString
00:07:41 * hackagebot safecopy 0.9.2 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.9.2 (JeremyShaw)
00:07:41 * hackagebot oidc-client 0.3.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.3.0.0 (ShoKuroda)
01:00:04 <tdammers> question here: using Aeson, is there a straightforward way of carrying source position information into error messages produced in parseJSON?
01:07:54 <dmj`> tdammers: I don't believe so, attoparsec (aeson's parser) doesn't have as helpful error messages as megaparsec / trifecta.
01:11:26 <jaziz> Should I learn lisp or haskell?
01:11:36 <dmj`> jaziz: haskell
01:11:57 <jaziz> dmj`, why's that?
01:12:09 <jaziz> for the record, all I want to do is learn a "good" programming language
01:12:09 <MarcelineVQ> asking that in a channel called haskell is begging the question a little though :>
01:12:21 <jaziz> MarcelineVQ, haha
01:12:32 <jaziz> I mean, where else would I ask?
01:12:49 <mettekou> jaziz: Strong static typing with type inference is reason enough to prefer Haskell.
01:13:56 <mettekou> Well, that and the fact that the type system sports both parametric polymorphism and ad hoc polymorphism as well as higher kinds and dependent types.
01:14:40 <jaziz> hm
01:14:44 <jaziz> Not sure I understood a word of that
01:16:12 <mettekou> jaziz: Parametric polymorphism allows the use of type variables to reduce code duplication, for example, you can express the type of the function which does not change its argument as id :: forall a. a -> a, a being the type variable here.
01:16:58 <mettekou> There are of course more useful examples, such as generic data structures: List a, Map a...
01:17:59 <dmj`> jaziz: equational reasoning gives you refactorability so your future self won't hate you so much
01:22:37 * hackagebot amazonka 1.4.4.2 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.4.2 (BrendanHay)
01:22:39 * hackagebot amazonka-test 1.4.4.2 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.4.2 (BrendanHay)
01:22:41 * hackagebot staversion 0.1.1.0 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.1.1.0 (debugito)
01:23:07 <jaziz> Alriiiiiight, haskell it is, bois
01:23:18 <jaziz> Even the guys at #lisp told me haskell
01:23:53 <tsahyt> When working with a MaybeT m a, what's the preferred method of stopping the computation via Nothing? the MonadFail instance?
01:24:25 <lyxia> I'd say empty
01:24:55 <tsahyt> from Applicative?
01:25:03 <tsahyt> Alternative*
01:25:05 <lyxia> Yeah.
01:25:12 <tsahyt> ok, thanks!
01:27:33 <kirillow> how do I get this `foldr max [] "a couple of strings"` to parse? i repeatedly encounter this problem where my first idea is that i need an empty character?
01:30:35 <jle`> kirillow: what do you want it to parse as?
01:31:10 <jle`> what would you watn the result to be?
01:31:12 <jle`> it's not super clear
01:31:51 <kirillow> wrong wording maybe. i just want foldr to return the greatest character
01:32:01 <jle`> so what would the answer be?
01:32:20 <jle`> > maximum "a couple of strings"   -- ?
01:32:23 <lambdabot>  'u'
01:32:50 <jle`> :t foldr
01:32:51 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:32:55 <bartavelle> kirillow, you should note that the type of the 2nd argument to foldr is also the return type
01:33:03 <jle`> if you want foldr to return a Char, then 'b' has to be Char
01:33:16 <jle`> so it'd be foldr :: (Char -> Char -> Char) -> Char -> [Char] -> Char
01:33:29 <koz_> jle`: All that Char.
01:33:37 <jle`> i'm all about that Char
01:33:56 <jle`> kirillow: but yeah, for foldr, the second parameter is what is returned if the input is an empty list
01:34:01 <jle`> so what would you expect maximum "" to be?
01:34:15 <jle`> for Char's, you can probaby put '\0'
01:34:24 <koz_> > maximum ""
01:34:26 <kirillow> hmmmmmm
01:34:26 <lambdabot>  *Exception: Prelude.maximum: empty list
01:34:31 <koz_> I thought as much...
01:34:37 <jle`> because every other character is greater than \0
01:34:46 <jle`> so if there's any other item in that list, it'll be used instead of \0
01:34:53 <jle`> > foldr max '\0' "hello world"
01:34:56 <lambdabot>  'w'
01:35:02 <jle`> > foldr max '\0' ""
01:35:04 <lambdabot>  '\NUL'
01:35:16 <jle`> not a super satisfying answer though
01:35:35 <kirillow> thank you!
01:35:45 <nesqi> Hi all! running my program with "+RTS -sstderr" I get allot of statistics output. Where Can I read about what all these numbers indicate?
01:36:32 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics
01:36:34 <jle`> kirillow: another thing you can do is have it return 'Nothing' if there is an empty list, and 'Just x' with the maximum if it's not empty
01:37:21 <nesqi> Oh! thanks.. so close to finding it on my own.
01:38:40 <jle`> > foldr (\x -> (<|> Just x) . fmap (max x)) Nothing "hello world"
01:38:43 <lambdabot>  Just 'w'
01:38:46 <jle`> > foldr (\x -> (<|> Just x) . fmap (max x)) Nothing ""
01:38:48 <lambdabot>  Nothing
01:39:46 <koz_> jle`: Couldn't you do a trick with a WrappedMonad for this too?
01:40:02 <jle`> what is WrappedMonad ?
01:40:33 <koz_> Wait, I was thinking of something else.
01:41:08 <koz_> Never mind.
01:45:06 <coleman> gfixler: still here?
01:59:10 <DexterLB> so, I want to make a function which makes a histogram for a vector (e.g. for <0, 3, 2, 3> it should return <1, 0, 1, 2>
01:59:15 <DexterLB> here's my current implementation: https://bpaste.net/show/6f474fd72d23
01:59:45 <DexterLB> but it appears that the incrementPos function copies the vector each time it's called (it performs many allocs)
01:59:57 <DexterLB> that would imply that an old copy is used somewhere
02:00:27 <DexterLB> is there something obviously wrong with my approach, or is there a way to make a hint to the compiler not to copy?
02:03:46 <jaziz> so what are the first steps one takes in learning haskell?
02:05:00 <Cale> jaziz: Well, pick a book or tutorial and start reading, I would guess.
02:05:06 <quchen> Read the first couple of chapters of a book and start being excited
02:05:12 <jaziz> Anything I need to download?
02:05:32 <Cale> GHC in some form or another.
02:06:03 <Cale> https://www.haskell.org/platform/ -- you could get a package from here if you like
02:06:25 <jaziz> we download the latest one?
02:06:27 * quchen votes for Stack for beginners
02:06:39 <Cale> That comes with stack and other stuff
02:06:52 <Cale> jaziz: Yeah, you want the latest
02:07:04 <jaziz> oh, I clicked on GHC
02:07:13 <jaziz> I'm supposed to download the big package thingy
02:07:14 <jaziz> full?
02:07:20 <icosane> Some learning resources: http://learnyouahaskell.com/ http://www.cis.upenn.edu/~cis194/spring13/lectures.html https://en.wikibooks.org/wiki/Haskell/YAHT
02:07:26 <Cale> "minimal" is fine
02:07:26 <jaziz> What's the difference between 64-bit and 32-bit?
02:07:38 <Cale> That just depends on which OS you're running
02:07:50 <jaziz> ookie dokie
02:07:53 <jaziz> goin in
02:08:00 <quchen> jaziz: GHC is only the bare compiler with core libraries and not much tooling. It’s not very convenient for the first steps.
02:08:09 <jaziz> le journey begins
02:08:11 <icosane> If you're computer is 64 bit, choose 64. If you're computer is 32 bit or you don't know, choose 32.
02:08:42 <jaziz> it's 64, I just don't know what advantages it has over 32
02:08:49 <jmorris> jaziz if you're on linux type in the terminal uname -m
02:08:50 <quchen> Are you on Linux? If so, run “uname -a” and see whether it mentions “64”.
02:09:05 <jaziz> nah Win 10
02:09:09 <jaziz> I need a linux thingy, though
02:09:14 <jmorris> jaziz: it is the way your computer's processor handles information
02:09:30 <jaziz> what "ways?"
02:09:35 <icosane> 64 can be some faster and supports more memory (32 bit supports at most 2^32 bytes, 64 bits supports at most 2^64 bytes)
02:09:55 <jaziz> oh, that's a lot more
02:10:09 <jmorris> jaziz: https://support.microsoft.com/en-au/kb/827218
02:10:18 <jaziz> so what does that translate to, being able to do larger calculations?
02:10:47 <quchen> jaziz: Go to   Control Panel -> Security -> System,   it should mention your kind of CPU.
02:11:09 <icosane> Different processor design, sometimes has special instructions that result in faster calculations, programs can use more memory
02:11:22 <jmorris> jaziz: 64 bit handles large amounts of RAM more effectively
02:11:25 <Cale> jaziz: Mainly, being able to have more than 4GB of RAM.
02:11:40 <jaziz> oh, I have 8GB of that
02:11:44 <icosane> rather 17179869184 GB
02:12:02 <jaziz> definitely 64 bit
02:12:16 <jaziz> alright, all installed
02:12:16 <jaziz> now what
02:12:32 <icosane> first test it
02:12:36 <icosane> open a shell
02:12:51 <icosane> and execute the command ghci
02:13:00 <icosane> (note: I never program on Windows)
02:13:02 <jaziz> chillin
02:13:19 <jaziz> How do I do my first hello world
02:13:27 <kirillow> :D
02:13:44 <jaziz> Can't start a language without doing hello world
02:14:01 <icosane> if you started ghci, do print "hello world"
02:14:12 <jaziz> boom
02:14:29 <quchen> In GHCi, you can simply enter "hello world" and hit enter.
02:14:53 <jmorris> or just "hello world"
02:16:32 <quchen> To compile a hello world program, do “echo 'main = putStrLn "Hello World!"' > HelloWorld.hs && ghc HelloWorld.hs && ./HelloWorld”.
02:16:46 <icosane> quchen: does that work on windows?
02:16:53 <quchen> Oh, I forgot. No.
02:17:04 <quchen> icosane: Well, something like that, but not exactly that.
02:17:22 <icosane> open a file named HelloWorld.hs
02:17:40 <MarcelineVQ> ​> ​works in windows
02:18:03 <quchen> 1. Open a new file called "HelloWorld.hs"; 2. edit its contents to say “main = putStrLn "hello world"”; 3. Compile the program by running “ghc HelloWorld.hs”; 4. run the program
02:18:30 <icosane> HelloWorld.hs must be in the directory your shell is pointing at
02:19:55 <jaziz> huhhhh
02:20:04 <jaziz> why can't we just be fine with print "hello world" ?
02:20:51 <icosane> Putting it in a seperate file makes things easier
02:20:55 <icosane> if there is a lot of code
02:21:04 <jaziz> I have much to learn
02:21:09 <jaziz> I'm coming in from python, btw
02:21:10 <quchen> jaziz: You asked for Hello World, we gave you hello worlds. :-)
02:21:25 <Cale> jaziz: Well, you also probably want to be able to make actual runnable programs, and for that you'll need to put code in a file...
02:21:27 <jaziz> Decided to learn a functional programming language to strengthen understanding of recursion and stuff
02:21:52 <jaziz> Any recommended texts/tools?
02:22:16 <Cale> http://www.cis.upenn.edu/~cis194/spring13/lectures.html is pretty decent
02:22:42 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html if you're up for buying a book, I think it's safe to recommend this
02:22:53 <icosane> http://learnyouahaskell.com/ is also a good one, although a bit childish
02:23:01 <jaziz> hahahahahaha
02:24:12 <jaziz> dang, I like this
02:24:18 <jaziz> it's all short
02:24:29 <jaziz> 318 pages for a programming book not bad at all
02:24:45 <Cale> Don't worry, there will still be lots to learn when you're done
02:24:52 <hvr> quchen: unless the beginner is on Ubuntu 16.10... then currently none of platform & stack works out of the box
02:25:02 <jaziz> Oh also
02:25:15 <jaziz> Do any of you have experience with How to Design Programs? The book?
02:25:25 <quchen> hvr: Woah
02:25:26 <jaziz> By Felleisen? 
02:25:31 <quchen> hvr: Didn’t know that
02:25:55 <hvr> quchen: the dreaded PIE linker issue
02:26:01 <quchen> Never heard of that
02:26:03 <quchen> Should I?
02:26:32 <quchen> Oh, the “GCC 2.something breaks stuff” thread?
02:26:33 <hvr> quchen: https://www.reddit.com/r/haskell/comments/5aela8/haskellcafe_psa_gcc620_breaks_linking_in_ghc/
02:26:39 <Cale> jaziz: I haven't read it, but I've heard that it's good.
02:26:55 <hvr> quchen: yeah, Debian 9/testing & Ubuntu 16.10 are affected as examples
02:27:17 <jaziz> ooh also, are haskell programmers employable?
02:27:28 <Cale> jaziz: I'm employed as a Haskell programmer
02:27:35 <jaziz> gooood schtuff
02:27:56 <hvr> quchen: however, you can use the GHCs from my PPA w/ Stack, then it should work even w/ stack
02:28:17 <hvr> (or manually patch the GHC as described in those threads)
02:28:38 <tdammers> jaziz: good programmers are always employable. good programmers have several languages under their belt though, and can pick up new ones as needed.
02:28:52 <jaziz> tdammers, yeah, all I got is python haha
02:29:21 <tdammers> jaziz: well, in that case, haskell is certainly going to expand your horizon for the better, even if you end up sticking with Python
02:29:34 <hvr> tdammers: but what if you learned Haskell and now have lost the ability to enjoy any other language?
02:29:34 <jaziz> ooh nice
02:29:42 <tdammers> hvr: yeah, I was about to mention that
02:29:47 <jaziz> tdammers, what makes you say that?
02:29:51 <jaziz> hahaha really now
02:29:54 <jaziz> is haskell that great?
02:30:03 <tdammers> I like to think so, yes
02:30:06 <hvr> jaziz: for some it is
02:30:11 <Cale> I *can* pick up new ones as needed, but at the moment, Haskell's feature set is around my floor for acceptability, and I don't see many jobs programming in dependently typed functional programming languages. :)
02:30:51 <tdammers> indeed
02:30:54 <jaziz> Nice
02:30:59 <jaziz> what about this will expand my horizons, though?
02:31:04 <jaziz> I wanna know what awesomeness is to come
02:31:17 <tdammers> most mainstream languages are objectively pretty lousy in terms of abstractive power and expressiveness, compared to haskell
02:31:25 <Cale> Well, the big one relative to python is just having a type system which will actually help you.
02:31:29 <hvr> jaziz: well, imho the great thing about Haskell is that you'll learn *a lot* new stuff and keep doing so for years
02:31:30 <kirillow> "Haskell Programming from First Principles" a lot 
02:32:12 <hvr> jaziz: so you'll like not reach the point where you know all there is to know about haskell any time soon once you embark this journey
02:32:28 <jaziz> mmm
02:32:34 <Cale> In Python (or any dynamically typed language), when you want to refactor your code, you need to be really careful, because it's easy to write something that will run and then just die at runtime. Changing something central to your program which will require hundreds of lines of code to change is a huge deal and you tend to avoid it.
02:33:05 <icosane> Haskell's type system catches a lot of bugs at compile time 
02:33:10 <tdammers> ^ this. Haskell is super refactorable
02:33:13 <hvr> jaziz: and you don't need to know all there is to know to get things done in haskell either :-)
02:33:27 <jaziz> Nice
02:33:40 <Cale> In Haskell, the compiler typically helps you find all the things that will need changing -- some central type definition will change first, and then you can just keep running the compiler and fixing type errors, and usually when you're done with that, everything is back in working order (or very close to it).
02:33:42 <tdammers> but the main benefit of the type system to me isn't even catching bugs; it's using the type system as a thinking aid, and the type checker as a tool to do some of the thinking for me
02:34:01 <ania123> I wanto to define linght using foldr
02:34:02 <ania123> so
02:34:05 <Cale> and yeah, *learning libraries* is so much easier once you're used to the type system
02:34:26 <tdammers> bit of a mindset thing, really - rather than thinking, "what are the steps I need to go through to do what I want", I think, "what would the type signature be for a function that solves my problem"
02:34:37 <jaziz> innnteresting
02:34:46 <merijn> Cale: Trigger warnings before you talk about refactoring python, please :(
02:34:46 <jaziz> Yeah, I have no experience with typecasting 
02:34:53 <Cale> merijn: hahahaha
02:34:53 <ania123> length = foldr (\ xy.  1+y) 0
02:35:01 <ania123> is it right?
02:35:16 <tdammers> it's called "type driven design": first, you define a "hole" (the type signature), and then you find things that fit the hole (implementations), possibly producing new holes
02:35:25 <tdammers> repeat the process until all holes have been filled
02:35:27 <merijn> Cale: You laught, but I'm dealing with all these supposedly amazing python libraries and it's all awful all the way down :(
02:35:28 <Cale> ania123: Apart from the syntax...
02:35:42 <jaziz> and how you decide what kinds of holes?
02:35:58 <ania123> Cale: what do you mean?
02:35:59 <tdammers> well, that's where the actual thinking kicks in
02:36:06 <tdammers> but I'll give you an example
02:36:07 <Cale> ania123: (\x y -> 1 + y)
02:36:16 <tdammers> suppose you want to write a program that prints a list of strings
02:36:26 <ania123> should i use x? or just _
02:36:26 <ania123> ?
02:36:31 <tdammers> this means you need a function that takes a list of strings: [String]
02:36:39 <jaziz> mhm
02:36:43 <tdammers> and it needs to do something with IO that doesn't produce any values: IO ()
02:36:50 <tdammers> so your function is [String] -> IO ()
02:37:00 <ania123> Cale:?
02:37:03 <tdammers> and then you go looking for suitable building blocks
02:37:04 <jaziz> what is IO?
02:37:07 <jaziz> Input/Output?
02:37:10 <Cale> ania123: _ is probably a bit better in general. In this specific case, it's not a big deal, but in more complicated situations, it's nice not to introduce variables you know you won't need.
02:37:24 <icosane> IO is a trick haskell has for modelling mutation (input, output, modification) without actually mutating anything
02:37:26 <tdammers> IO is just a type; IO values represent effectful ("real-world") computations
02:37:30 <ania123> ok
02:37:32 <Cale> (especially as they might end up shadowing something from a wider scope, and you might not notice)
02:37:33 <ania123> thx
02:37:56 <jaziz> hmmm
02:37:56 <tdammers> [String] -> IO () means "take a list of strings, and give me an effectful computation"
02:38:11 <tdammers> now, one building block we have is putStrLn
02:38:13 <tdammers> :t putStrLn
02:38:14 <lambdabot> String -> IO ()
02:38:24 <tdammers> another one is mapM_
02:38:26 <tdammers> :t mapM_
02:38:27 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
02:38:38 <jaziz> damn haha this notation
02:38:57 <tdammers> that type signature is maybe a bit abusive at this level, but you can ignore the part left of the =>, substitute [] for t and IO for m, and you get:
02:39:10 <icosane> The notation is not really difficult once you get it
02:39:10 <tdammers> mapM_ :: (a -> IO b) -> [a] -> IO ()
02:39:23 <tdammers> you can further substitute () for b, and String for a, and you get:
02:39:31 <tdammers> mapM_ :: (String -> IO ()) -> [String] -> IO ()
02:39:53 <icosane> Something like A or Integer represents a type, it is unambigious what type it represents
02:39:57 <tdammers> notice how the rightmost part is already what we want, and how the left bit matches the signature for putStrLn?
02:40:07 <jaziz> sure haha
02:40:24 <tdammers> so we can just drop putStrLn into the mapM_ call, and that's our program
02:40:26 <jaziz> Except with parentheses
02:40:33 <icosane> if the function f has type Integer -> String, f takes an Integer and returns a String
02:40:40 <tdammers> :t mapM_ putStrLn
02:40:42 <lambdabot> Foldable t => t String -> IO ()
02:40:43 <Cale> tdammers: It might be worth noting that jaziz is an absolute beginner right now ;)
02:40:53 <jaziz> I suppose it's expected to not be following very well
02:41:00 <tdammers> yes, I know
02:41:12 <tdammers> this is just a super fast guided tour to what the process might look like
02:41:20 <jaziz> Nice
02:41:22 <tdammers> no need to understand it all
02:41:25 <jaziz> There are great things to come
02:41:33 <jaziz> It's 2:40 am and I have a midterm tomorrow fml
02:41:37 <jaziz> I will be back!
02:47:02 <Maxdamantus>  Just wondering .. does anyone know if anyone's discussed a potential crazy extension/TH thing to implement something like JS' async/await, possibly with loops and variable reassignment, and generalised to all monads?
02:47:19 <Maxdamantus> so you could write something like: doo { let x = 0; for(let y = 0; y < 10; y = y + 1) x = x + *[0, y]; return x }
02:47:40 * hackagebot servant-matrix-param 0.3.2 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.3.2 (jkarni)
02:48:20 <merijn> Maxdamantus: You're going to need to be more specific, because as-is that doesn't sound coherent to me
02:48:31 <glaukon> Is it possible to use stack without Internet connection? Is there an option to tell it *not* to try to download the snapshot list? 
02:48:52 <Maxdamantus> (that should evaluate to a list with 2^10 elements in it)
02:49:53 <merijn> Maxdamantus: What kinda thing are you expecting that's different from just regular laziness?
02:50:04 <quchen> Javascript’s async/await is what Marlow’s async lib has been doing for years, no?
02:50:13 <Maxdamantus> It doesn't have much to do with laziness.
02:50:50 <merijn> quchen: Well, that, or just "use threads with blocking operations"
02:51:00 <Cale> I don't understand this generalisation to all monads bit.
02:51:07 <merijn> Cale: Yea, me neither
02:51:12 <Maxdamantus> The point isn't to do with promises/async.
02:51:22 <merijn> Maxdamantus: I don't understand what you envision happening
02:51:28 <merijn> Maxdamantus: What are the semantics you want?
02:51:32 <Maxdamantus> The example above is just using the list monad.
02:52:34 <Maxdamantus> well, in JS you can write something like `function *foo(){ let x = await bar(); let y = await baz(); return (x + y); }`
02:52:48 <quchen> merijn: That blocks though, the purpose of async/await is not doing that I think.
02:52:49 <merijn> I don't know JS, so I have no idea what await means
02:53:10 <Maxdamantus> which I think can be somewhat compared to: `foo = do { x <- bar; y <- baz; return (x + y) }`
02:53:27 <merijn> quchen: Sure, but the point is that the usecases of async/await don't really exist in threaded haskell
02:53:36 <Cale> > forM [0..9] $ \y -> [0,y]
02:53:39 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,9],[0,0,0,0,0,0,0,0,8,0],[0,0,0,0,...
02:53:42 <Maxdamantus> but in JS' case, you can also use variable reassignment and loops.
02:53:44 <Cale> ^^ you mean this?
02:53:46 <merijn> Maxdamantus: In what sense? And how would you possibly generalise it to "all monads"?
02:54:04 <Cale> That should have 2^10 elements in it...
02:54:18 <Maxdamantus> merijn: well, the code I just wrote works for all monads.
02:54:25 <quchen> merijn: Why not? Fork a process that waits for a certain connection to open and react to that sounds like a use case to me
02:54:53 <Cale> Maxdamantus: Actually the code you wrote doesn't work at all, technically speaking ;)
02:55:09 <Cale> (it's not syntactically correct)
02:55:11 <merijn> quchen: The main reason to use async/wait is to unblock the CPU to do computation while waiting
02:55:23 <merijn> quchen: If you simply fork a thread that blocks you already do that
02:55:39 <merijn> quchen: If you ever need the result you can even do that by just reading an MVar
02:55:44 <Maxdamantus> > let bar = return 5; baz = return 6; foo = do { x <- bar; y <- baz; return (x + y) } in foo
02:55:46 <lambdabot>  error:
02:55:47 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M81599...
02:55:47 <lambdabot>        prevents the constraint ‘(Show (m0 b0))’ from being solved.
02:55:48 <merijn> quchen: Incidentally, that's exactly what async does
02:55:54 <Cale> Oh, that code?
02:56:04 <Cale> Well, sure, that code is okay
02:56:17 <Cale> I was referring to the weird thing with the for loop and such
02:56:21 <merijn> Maxdamantus: I don't understand how that relates to async/await. Also, you haven't really explained what exactly async/await does
02:56:22 <quchen> merijn: I think we agree but misunderstood each other.
02:56:36 <Cale> > forM [0..9] $ \y -> [0,y] -- is this thing what you meant to write Maxdamantus?
02:56:38 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,9],[0,0,0,0,0,0,0,0,8,0],[0,0,0,0,...
02:56:53 <Maxdamantus> Cale: no. There's no addition there.
02:56:56 <quchen> merijn: So now we’re both saying that Haskell.async is Javascript’s fancy new async. Plus probably some extras such as parallelism.
02:57:22 <quchen> And types. And no promises because why.
02:57:51 <Maxdamantus> Cale: well, if you map sum over it, yes, I think.
02:58:09 <Cale> Maxdamantus: Well, I didn't understand what it was that you were adding
02:58:26 <Cale> > do xs <- forM [0..9] $ \y -> [0,y]; return (sum xs)
02:58:28 <lambdabot>  [0,9,8,17,7,16,15,24,6,15,14,23,13,22,21,30,5,14,13,22,12,21,20,29,11,20,19,...
02:58:32 <merijn> quchen: Basically, afaict async/await is a hacky workaround to gain a subset of the features provided by proper lightweight threading
02:58:55 <quchen> merijn: Yes, that’s how I understand it as well.
02:59:12 <LordBrain> hmm, even if all async does is a little mvar stuff you could do yourself, its still nice that it does it for ya
02:59:19 <Maxdamantus> Cale: yes, that should be the same result, though the accumulation happens fairly differently.
02:59:24 <Cale> I don't really get what this has to do with async/await
02:59:24 <LordBrain> am i wrong?
02:59:29 <tabaqui1> let I have x = "asd" :: ByteString.Word8
02:59:39 <tabaqui1> and I want y :: String
02:59:43 <Maxdamantus> It doesn't have to do with async/await WRT promises.
02:59:50 <quchen> I’d be interested in learning about GHC’s event loop. I mean it’s not something one needs to know anything about, but still I’ve been wondering for some time now.
02:59:52 <merijn> LordBrain: async does a bit more, like handling errors/cancellation properly
02:59:59 <tabaqui1> if I use y = show x, then I'll get string of 5 symbols
03:00:04 <tabaqui1> with quotes
03:00:07 <merijn> LordBrain: I'd definitely use it over writing it yourself
03:00:13 <LordBrain> yeah
03:00:16 <tabaqui1> how can I convert BS to String without quotes?
03:00:24 <Maxdamantus> Just the fact that async/await can be seen as sort of like a restricted form of `do` notation, just with reassignment and loops.
03:00:28 <LordBrain> i know i've found it useful, tho its been a while and i don't recall all it did for me
03:00:49 <Maxdamantus> (assuming you're willing to pretend that promises are monadic)
03:01:14 <quchen> LordBrain: It allows you to orchestrate hierarchies of threads nicely, and makes it very hard to have silent exceptions.
03:01:30 <Maxdamantus> (restricted in that it doesn't work with other monadic things like arrays/functions)
03:01:38 <merijn> LordBrain: It's mostly useful (to me) for, e.g. "mapConcurrently" which lets you execute a bunch of IO operations in parallel
03:01:38 <Cale> Well, not all monads have a notion of promises... most don't.
03:01:43 <merijn> quchen: I actually found it's fairly bad to actually orchestrate thread hierarchries
03:01:49 <quchen> Really?
03:01:56 <Maxdamantus> It has nothing to do with promises.
03:01:59 <merijn> quchen: It's nice if you have fire and success/fail hierarchies
03:02:05 <Maxdamantus> Promises are just what ES uses it for.
03:02:14 <quchen> merijn: Yes, that’s what I meant.
03:02:16 <merijn> quchen: If you want to isolate/ restart bits on demand you end up with a lot of hackery
03:02:41 * hackagebot google-oauth2-jwt 0.1.2.1 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.1.2.1 (MichelBoucey)
03:02:42 <merijn> quchen: When you say "orchestrate" I think more of Erlang style manager hierarchies which restart/check child threads, etc.
03:02:54 <younder> Isn't the Par monad and a mode dataflow oriented way to go. Let haskell's sparks figure it out.
03:02:56 <quchen> merijn: I never did that, but you’re right, orchestration can mean a whole lot more.
03:03:14 <merijn> younder: That works for pure things, not effectful things :)
03:03:14 <quchen> younder: Par does not use sparks I think, it comes with its own scheduler.
03:03:15 <younder> s/mode/more/
03:03:50 <quchen> Sparks are for par/strategy stuff.
03:04:40 <Maxdamantus> If it were generalised in JS, you might be able to write `function ArrayMonad*foo(){ let x = await [1, 2], y = await [3, 4; return x + y; }`
03:05:07 <Maxdamantus> where ArrayMonad = { unit: .., join: .., map: .. }
03:06:02 <Maxdamantus> (similar to `do{ x <- [1, 2]; y <- [3, 4]; return (x + y) }`)
03:07:00 <merijn> Maxdamantus: You keep coming up with examples without specifying how you expect them to behave or describing what you actually want to accomplish
03:07:30 <Maxdamantus> merijn: Cale pretty much figured out how my first example is meant to behave.
03:07:53 <Maxdamantus> I don't want to accomplish it. I was just curious if someone had thought of this in Haskell.
03:07:57 <Maxdamantus> afk anyway
03:10:17 <jchia1> tabaqui1: unpack
03:11:55 <jchia1> tabaqui1: specifically, you can use Data.ByteString.Char8.unpack
03:13:37 * merijn twitches
03:13:53 <merijn> *insert usual rant about not using Char8*
03:15:00 <jchia1> merijn: What would you use?
03:17:41 * hackagebot servant-matrix-param 0.3.3 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.3.3 (jkarni)
03:19:09 <ongy> where's the quchen gist? I think there's a section about that in it
03:19:17 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
03:19:30 <younder> in ghci when I type type 'DIM1 = DIM0 :. Int' I get Illegal operator ':.'.  What is wrong?
03:19:37 <merijn> jchia1: That depends on what you're doing. i.e. where your bytestring comes from
03:20:08 <merijn> younder: Context?
03:20:34 <merijn> What are DIM1 and DIM0?
03:21:07 <younder> merijn, Chapter 6. GPU Programming with Accelerate http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
03:21:22 <jchia1> merijn: OK, it looks like the the objection is about the assumption that the bytes are just ASCII.
03:21:51 <merijn> younder: Well, did you actually define :. ?
03:22:05 <merijn> jchia1: Not just that, it will silently corrupt any non-ASCII
03:22:07 <geekosaur> that's shown a few lines up
03:22:27 <jchia1> you mean specifically that pack will corrupt non-ascii, right?
03:22:30 <younder> merijn, No merly 'import Data.Array.Repa as Repa'
03:22:33 <geekosaur> but the syntax cited seems kinda wrong, can you correct it? [03 10:19:08] <younder> in ghci when I type type 'DIM1 = DIM0 :. Int' I get Illegal operator ':.'.  What is wrong?
03:25:00 <younder> geekosaur,  Z = Z;a tail :. head = tail :. head
03:25:21 <younder> that shoukd be data
03:25:33 <geekosaur> that was not what I asked
03:26:06 <geekosaur>        when I type type 'DIM1 = DIM0 :. Int'            this is not valid. what did you actually type?
03:26:24 <geekosaur> (if you actually did type that, that's likely your problem)
03:27:25 <byorgey> if you literally type   'DIM1 = DIM0 :. Int'  at the ghci prompt you will get a parse error.
03:28:01 <ongy> can you paste the error?
03:28:04 <byorgey> you could say  'type DIM1 = DIM0 :. Int' , which will give an Illegal operator error.  Just turn on the TypeOperators extension:  :set -XTypeOperators
03:28:14 <byorgey> younder: ^^^
03:28:17 <ongy> oh, I should read more carefully
03:28:56 <merijn> byorgey: That's not true anymore
03:29:05 <merijn> byorgey: Actually, never has been
03:29:30 <merijn> byorgey: TypeOperators if for allowing type level operators that don't start with :
03:29:41 <merijn> byorgey: Since those aren't valid constructors normally
03:30:50 <Maxdamantus> Cale, merijn: btw, a closer version of the first example would be: foldM (\x y -> map (x +) [0, y]) 0 [0..9]
03:31:37 <merijn> Actually, I think I'm getting tripped up by GHCI having TypeOperators by default >.> I coulda sworn types with : were always allowed
03:31:44 <merijn> Maxdamantus: I still don't understand what your plugin/TH is supposed to do?
03:31:44 <younder> byorgey, thx
03:32:08 <tabaqui1> jchia1: unpack will return [Word8]
03:32:12 <byorgey> merijn: =)
03:32:34 <tabaqui1> ok, I've found another way
03:32:38 <jchia1> tabaqui1: Data.ByteString.Char8.unpack, but merijn has a good point about not using unpack
03:32:39 <tabaqui1> but next question
03:32:40 <Maxdamantus> merijn: mechanically translate something similar to `do` notation but with loops/reassignments.
03:32:58 <merijn> Maxdamantus: I don't understand what that means
03:33:06 <tabaqui1> there is some type in library
03:33:20 <tabaqui1> like data Foo = Foo deriving (Show)
03:33:23 <byorgey> Maxdamantus: how is it different from do rec ?
03:33:32 <tabaqui1> can I import it and add another derivation?
03:33:50 <tabaqui1> so I want import Data.Foo (Foo)
03:34:02 <tabaqui1> and data Foo = Foo deriving (Show, Eq)?
03:34:12 <geekosaur> StandaloneDeriving extension
03:34:14 <byorgey> tabaqui1: yes, use  {-# LANGUAGE StandaloneDeriving #-}, then write   deriving instance Show Foo
03:34:34 <geekosaur> actually I think they added Eq there
03:34:41 <byorgey> er, right, sorry
03:34:59 <tabaqui1> and I can add Generic derivation with it?
03:35:16 <geekosaur> yes, remember to enable DerivingGeneric extension as well
03:35:23 <Maxdamantus> merijn: well, you can imagine how `do` notation might be mechanically translated into an expression involving `(>>=)` and `return`, right?
03:35:52 <byorgey> I think it is called 'DeriveGeneric'
03:35:59 <tabaqui1> fine, thanks to all
03:36:01 <geekosaur> whoops, right
03:36:06 <Maxdamantus> merijn: if you had variable assignments and loops, it would just mean that resulting expression would probably have a few functions defined inside it.
03:36:27 <geekosaur> it is worthwhile to read through the chapter in the ghc manual about extensions
03:36:51 <merijn> Maxdamantus: But what is the point, semantically, of "translating to do loops and reassignment"? How does it change the behaviour?
03:37:00 <geekosaur> also there's a 24 Days of GHC Extensions
03:37:24 <Maxdamantus> merijn: how does using `do` notation change the behaviour of anything? It doesn't. I don't understand what you're hung up on.
03:38:01 <byorgey> "imagine" how do notation "might be" translated to >>= and return? =)
03:38:29 <Maxdamantus> Well, `do` notation isn't *actually* translated into uses of the identifiers `(>>=)` and `return`
03:38:52 <Maxdamantus> It always manages to refer to the standard Monad.(>>=) and Monad.return, regardless of how hard you try to shadow them.
03:39:07 <ania123> \xy.y
03:39:10 <Maxdamantus> unless you're using that flexible do extension or whatever it's called in GHC.
03:39:14 <ania123> how can I write it in haskell syntax
03:39:14 <ania123> ?
03:39:45 <byorgey> Maxdamantus: not if you enable RebindableSyntax
03:39:49 <Maxdamantus> Right, that.
03:40:43 <geekosaur> \x y -> y
03:49:05 <Maxdamantus> also, a mechanical translation of the initial example might look like: let main = s1 0 0; s1 x y = if y < 10 then ([0, y] >>= \tmp1 -> let x' = x + tmp1 in let y' = y + 1 in s1 x' y') else s2 x y; s2 x y = return x in main
03:51:40 <kirillow> I'm getting this error ` Failed to load interface for ‘Data.Time’
03:51:41 <kirillow>     It is a member of the hidden package ‘time-1.6.0.1’.yY
03:51:49 <kirillow> when importing `Data.Time`
03:52:23 <younder> Is it the same registers you use for AVX, AES, SSE, and FP?
03:53:10 <tdammers> kirillow: this usually means that you do have the `time` package installed in the current sandbox, but it isn't mentioned explicitly in the .cabal file for that project
03:53:25 <ongy> kirillow: are you using cabal?
03:53:25 <kirillow> uhm...
03:53:26 <kirillow> im loading a file into `stack ghci`
03:55:04 <tdammers> stack will still look at your .cabal file
03:55:41 <tdammers> IIRC you have to either add `time` to the dependencies for the main project inside your .cabal, or explicitly ask stack ghci to use a different subproject from the .cabal file
04:01:39 <younder>   Never mind. I found out that  yes SSE/AVX/x87-FP/integer instructions all use the same execution ports. 
04:04:42 <kirillow> uhm with stack, how do i add a package to the cabal file? do i just manually edit this file?
04:05:40 <tdammers> yes
04:34:41 <maerwald> kirillow: are you on windows?
04:34:57 <kirillow> no debian
04:35:30 * maerwald wonder if he should write up a gtk+ client for lazy cabal file editing
04:35:55 <hvr> maerwald: why not use emacs' cabal-mode? :)
04:36:05 <maerwald> hvr: I use linux
04:37:50 <hvr> well... you can consider Emacs a container running on Linux :3
04:37:51 <hvr> think Docker for Elisp =)
04:38:40 <ongy> emacs containers?
04:38:50 <ongy> does it provide its own pidspace?
04:39:53 <maerwald> hvr: I'll do that if I want RSI
04:40:05 <maerwald> anyway, #no-editor-war lol
04:40:35 <hvr> maerwald: fwiw, vim also has a cabal mode
04:40:41 <ongy> that channel doesn't exist
04:41:11 <hvr> maerwald: my point being... why not use your favorite editor's .cabal editing support?
04:41:26 <maerwald> because that's boring
04:41:36 <ongy> and fits into workflows
04:43:00 <maerwald> might be interesting for windows users as well to have stuff to click on without thinking about valid .cabal syntax etc
04:43:50 <ongy> lol
04:44:08 <ongy> "windows people like clicky things". Not that it's that wrong
04:44:31 <maerwald> wasn't even sarcasm
04:44:39 * hvr wonders if www.cabal-generator.com would be a thing
04:45:04 <maerwald> I hate webapps
04:45:42 <ongy> they work best when I'm on the train
04:51:21 <hpc> we would need to use the UI language of windows people
04:51:24 <hpc> and call it cabal-wizard
04:52:47 <ongy> what's the tool to create wizards then? the wizard-wizard?
04:52:50 <ongy> Archmage?
04:53:07 <quchen> 2-wizard
04:54:25 <maerwald> hpc: gtk apps are portable to windows
04:54:38 <cheater> co-wiz-neda lemma
05:54:59 <timeoff88> join ##wicket
05:57:36 <Squarism> timeoff88, used to love wicket until i met Elm
06:04:53 <timeoff88> Squarism: what are you're top 3 preferences in Elm over Wicket?
06:11:19 <Squarism> timeoff88, 1. Wicket works VERY well. Seldom you feel it doesnt do what you want. But Elm work like allways. Whereas wicket works 99% of the cases. 2. Wicket IS complex. The API has a WHOLE lot of code. Elm is just very simple. 3. 100% client. 4. Prolly most important. Elm (atleast from a language perspective) is functional / immutable. That just makes life so much easier. 
06:12:48 <Squarism> This is offtopic
06:12:48 <Squarism> so lets move to #wicket
06:12:48 <timeoff88> Squarism ##wicket
06:12:48 <timeoff88> Squarism - actually, private is better; don't want a flame war
06:19:39 <haasn`> Is it normal that `cabal update` causes my system to lock up?
06:19:49 <haasn`> I can reproduce it, too
06:20:05 <haasn`> The last thing that I see is `cabal` eating lots of RAM and CPU time and iostat saying my disk is at 100% usage
06:20:15 <haasn`> and then everything just grinds to a standstill
06:20:47 <ph88> why does haskell infer a1 to be Integral here?   https://paste.fedoraproject.org/469549/17918814/
06:22:47 * hackagebot gogol-core 0.1.1 - Core data types and functionality for Gogol libraries.  https://hackage.haskell.org/package/gogol-core-0.1.1 (BrendanHay)
06:22:49 * hackagebot gogol 0.1.1 - Comprehensive Google Services SDK.  https://hackage.haskell.org/package/gogol-0.1.1 (BrendanHay)
06:23:00 <haasn> It's a modest machine with only 1GB of RAM, but in the past I used to be able to `cabal update`, and even install stuff, just fine
06:23:15 <haasn> (Past here meaning GHX 6.x and early 7.x era)
06:23:48 <lyxia> ph88: because you use fromIntegral
06:25:10 <ph88> lyxia, ok but how does that relate to f and stats ?
06:25:42 <ph88> not working how i expect  https://paste.fedoraproject.org/469562/78179504/
06:25:54 <ph88> f was supposed to be a getter function on a tuple
06:26:21 <ph88> aah w8 .. i think i know the bug
06:26:26 <ph88> i should replace  x   with   f x
06:26:27 <ph88> let me try :D
06:26:57 <ph88> hhmm nope still same problem :/
06:30:36 <DexterLB> hello.. I need a function which counts the number of occurances of each integer below N in a vector. Here's my current implementation: https://bpaste.net/show/a00e5c4d9639
06:31:06 <DexterLB> from what I see when testing it, it seems that incrementPos copies the entire vector each time
06:32:00 <DexterLB> why is that? The docs specifically say that Vector.modify is in-place when it is possible (e.g. when no old version is used anywhere)
06:32:14 <DexterLB> also, is lpaste down?
06:32:48 * hackagebot gogol-adsense 0.1.1 - Google AdSense Management SDK.  https://hackage.haskell.org/package/gogol-adsense-0.1.1 (BrendanHay)
06:32:50 * hackagebot gogol-billing 0.1.1 - Google Cloud Billing SDK.  https://hackage.haskell.org/package/gogol-billing-0.1.1 (BrendanHay)
06:32:51 <ph88> hi DexterLB 
06:32:51 <ph88> ya
06:32:52 * hackagebot gogol-classroom 0.1.1 - Google Classroom SDK.  https://hackage.haskell.org/package/gogol-classroom-0.1.1 (BrendanHay)
06:32:54 * hackagebot gogol-affiliates 0.1.1 - Google Affiliate Network SDK.  https://hackage.haskell.org/package/gogol-affiliates-0.1.1 (BrendanHay)
06:32:56 * hackagebot gogol-useraccounts 0.1.1 - Google Cloud User Accounts SDK.  https://hackage.haskell.org/package/gogol-useraccounts-0.1.1 (BrendanHay)
06:33:11 <ph88> how do your two function relate to each other ?
06:33:56 <aphorisme> is there a way to abstract away from the concrete serialization type class one uses?
06:34:02 <ph88> oh i see the second one uses the first one ^^
06:34:07 <hexagoxel> :t foldl
06:34:09 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
06:34:13 <lyxia> ph88: write down the type of foldl, write the type of (\b a -> f b + f a)
06:34:17 <DexterLB> ph88: histogram calls incrementPos
06:34:24 <DexterLB> ph88: actually, the reverse :D
06:34:41 <lyxia> ph88: see that there is a mismatch
06:35:21 <phanimahesh> Hey, any good examples of literate haskell files?
06:35:57 <ph88> DexterLB, why you wrap an unsafeModify in a normal modify ?
06:36:03 <phanimahesh> I'm working on a new idea and proposed doing it in haskell, using literate haskell. Mostly I want to concentrate on the idea, not overly on code.
06:36:39 <phanimahesh> And lhs suits me perfectly. Now to explain the idea of using literate haskell to someone, I need a good example.
06:36:49 <byorgey> haasn: yeah, it sounds like it is just using too much memory which is causing your system to thrash.  The disk being at 100% usage means it is constantly swapping between RAM and disk.
06:36:54 <ph88> lyxia, right i see it now, fix was:   res = foldl' (\b a -> b + f a) (f x) xs
06:36:55 <kuribas> phanimahesh: I don't know if it's a good example, but here is code from my library: https://github.com/kuribas/cubicbezier/blob/master/Geom2D/CubicBezier/Overlap.lhs
06:36:58 <byorgey> haasn: how many cores does your machine have?
06:37:28 <DexterLB> ph88: the "normal modify" is on Data.Vector, and what it does is represent the vector as a monadic Data.Vector.Mutable, which I use in the lambda. The unsafeModify is a mutable vector function which changes the element at position i, and has nothing in common with Vector.modify
06:37:36 <byorgey> haasn: oh, never mind, 'cabal update' is single-threaded anyway (I think)
06:37:56 <phanimahesh> kuribas: Perfect! That's enough for me to demonstrate the idea, thanks!
06:37:58 * hackagebot gogol-storage-transfer 0.1.1 - Google Storage Transfer SDK.  https://hackage.haskell.org/package/gogol-storage-transfer-0.1.1 (BrendanHay)
06:38:00 * hackagebot gogol-fusiontables 0.1.1 - Google Fusion Tables SDK.  https://hackage.haskell.org/package/gogol-fusiontables-0.1.1 (BrendanHay)
06:38:02 * hackagebot gogol-debugger 0.1.1 - Google Stackdriver Debugger SDK.  https://hackage.haskell.org/package/gogol-debugger-0.1.1 (BrendanHay)
06:38:04 * hackagebot gogol-safebrowsing 0.1.1 - Google Safe Browsing APIs SDK.  https://hackage.haskell.org/package/gogol-safebrowsing-0.1.1 (BrendanHay)
06:38:06 * hackagebot gogol-runtimeconfig 0.1.1 - Google Cloud RuntimeConfig SDK.  https://hackage.haskell.org/package/gogol-runtimeconfig-0.1.1 (BrendanHay)
06:38:28 <kuribas> phanimahesh: You can make a html document with pandoc.
06:39:10 <haasn> byorgey: 1, it's a VM
06:39:29 <haasn> 1 GB of RAM on my VM has never been a problem in the past, and the current usage is only at around 300 MB of  those
06:39:34 <haasn> but `cabal update` instantly makes it trash
06:39:51 <haasn> which must indicate a bug, because `wget` works fine no matter how large the file
06:39:56 <haasn> as does `apt update`
06:40:21 <byorgey> yeah, I don't know enough about what 'cabal update' is doing
06:40:26 <ph88> DexterLB, from the manual on Vector.modify:  Apply a destructive operation to a vector. The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise.    ... and then you use unsafeModify inside that so i guess unsafeModify is not safe and it will do a copy of your vector first
06:40:27 <byorgey> haasn: what version of cabal do you have?
06:40:47 <haasn> byorgey: 1.22.6.0 using Cabal version 1.22.5.0
06:40:53 <haasn> (not sure why the mismatch, I got it from ubuntu's packages)
06:41:17 <ph88> DexterLB, can't you use Data.Vector.filter to filter out the Int's that are below N  ???
06:41:18 <byorgey> the versions of cabal-install and Cabal do not necessarily match exactly
06:42:54 <grazie> this is the type for forM http://imgur.com/a/zRjfk  . In this code http://imgur.com/a/0BPMA, which part exactly is the (a -> m b) second argument to forM ?
06:42:55 <grazie> for example, I assume that `name` is the `a` of (a -> m b) but I'm unclear what the m b is
06:43:08 * hackagebot gogol-partners 0.1.1 - Google Partners SDK.  https://hackage.haskell.org/package/gogol-partners-0.1.1 (BrendanHay)
06:43:10 * hackagebot gogol-storage 0.1.1 - Google Cloud Storage JSON SDK.  https://hackage.haskell.org/package/gogol-storage-0.1.1 (BrendanHay)
06:43:12 * hackagebot gogol-taskqueue 0.1.1 - Google TaskQueue SDK.  https://hackage.haskell.org/package/gogol-taskqueue-0.1.1 (BrendanHay)
06:43:14 * hackagebot gogol-apps-calendar 0.1.1 - Google Calendar SDK.  https://hackage.haskell.org/package/gogol-apps-calendar-0.1.1 (BrendanHay)
06:43:16 * hackagebot gogol-container 0.1.1 - Google Container Engine SDK.  https://hackage.haskell.org/package/gogol-container-0.1.1 (BrendanHay)
06:43:29 <opqdonut> grazie: the function \name -> ...
06:43:52 <opqdonut> grazie: so everything that's indented below the forM basically
06:43:59 <grazie> opqdonut so everyhting inside the do block ?
06:44:06 <opqdonut> yeah
06:44:12 <quchen> grazie: forM_ [1..10] (\n -> print n)      Here, the "n" has type Int and is your ting of type "a", and "print n" has type "IO ()", which is your "m b".
06:44:49 <grazie> quchen I understand that simple example, but when it's a for line `do` block, it's unclear to me what the "m b" is
06:44:51 <kuribas> grazie: m b is the do block
06:45:08 <grazie> kuribas so what is the return value of the do block?
06:45:16 <quchen> grazie: forM_ [1..10] (\n -> do { print n; print (n*2) } )
06:45:17 <kuribas> I think [String]
06:45:22 <quchen> Now you have a do block :-)
06:45:33 <kuribas> grazie: [String] probably
06:45:58 <hexagoxel> DexterLB: just fold over a mutable vector and freeze it afterwards. also your unsafeModify usage looks dangerous. consider the results of `histogram 0`.
06:46:03 <grazie> kuribas so is it return [path]
06:46:16 <byorgey> grazie: the return value of the do block in your paste ends up being either [path]  or the return value of getRecursiveContents path
06:46:19 <DexterLB> hexagoxel: thanks!
06:46:21 <kuribas> grazie: erm no, IO [String] more likely...
06:46:46 <grazie> byorgey: ok, thank you
06:46:58 <quchen> grazie: It would help to see that in text form, not as a picture.
06:47:22 <grazie> so return [path] is the "m b" if the "else" condition is true
06:47:35 <grazie> quchen yeah, sorry about that. 
06:48:07 <grazie> https://gist.github.com/34f0252bfc96b0efea72febb3a92e36c
06:48:18 * hackagebot gogol-groups-settings 0.1.1 - Google Groups Settings SDK.  https://hackage.haskell.org/package/gogol-groups-settings-0.1.1 (BrendanHay)
06:48:20 * hackagebot gogol-admin-datatransfer 0.1.1 - Google Admin Data Transfer SDK.  https://hackage.haskell.org/package/gogol-admin-datatransfer-0.1.1 (BrendanHay)
06:48:22 * hackagebot gogol-vision 0.1.1 - Google Cloud Vision SDK.  https://hackage.haskell.org/package/gogol-vision-0.1.1 (BrendanHay)
06:48:24 * hackagebot gogol-doubleclick-bids 0.1.1 - Google DoubleClick Bid Manager SDK.  https://hackage.haskell.org/package/gogol-doubleclick-bids-0.1.1 (BrendanHay)
06:48:26 * hackagebot gogol-plus-domains 0.1.1 - Google + Domains SDK.  https://hackage.haskell.org/package/gogol-plus-domains-0.1.1 (BrendanHay)
06:48:33 <kuribas> grazie: then m b is IO [FilePath]
06:50:52 <byorgey> grazie: well, no, the 'm b' in the type of forM  is the entire  do block.
06:51:12 <kuribas> grazie: the types for both branches are the same.
06:51:27 <byorgey> grazie: but of course something of type 'IO [String]' can be built up out of smaller IO computations, such as  return [path] which also has type  IO [String].
06:52:13 <grazie> byorgey so what is the "m [b]" (i.e. the final return value in the type signature)?.
06:52:30 <kuribas> grazie: "if test then a else b" has the same type as a and b.
06:53:04 <grazie> kuribas I understand that part
06:53:11 <kuribas> good :)
06:53:18 <kuribas> grazie: m [b] is m [[FilePath]]
06:53:28 * hackagebot gogol-proximitybeacon 0.1.1 - Google Proximity Beacon SDK.  https://hackage.haskell.org/package/gogol-proximitybeacon-0.1.1 (BrendanHay)
06:53:30 * hackagebot gogol-civicinfo 0.1.1 - Google Civic Information SDK.  https://hackage.haskell.org/package/gogol-civicinfo-0.1.1 (BrendanHay)
06:53:32 * hackagebot gogol-resourcemanager 0.1.1 - Google Cloud Resource Manager SDK.  https://hackage.haskell.org/package/gogol-resourcemanager-0.1.1 (BrendanHay)
06:53:34 * hackagebot gogol-adsense-host 0.1.1 - Google AdSense Host SDK.  https://hackage.haskell.org/package/gogol-adsense-host-0.1.1 (BrendanHay)
06:53:36 * hackagebot gogol-containerbuilder 0.1.1 - Google Cloud Container Builder SDK.  https://hackage.haskell.org/package/gogol-containerbuilder-0.1.1 (BrendanHay)
06:54:09 <grazie> kuribas but it doesn't say "m [[FilePath]]" anywhere in the code, so what part of the code represents "m [[FilePath]]"
06:54:25 <haasn> byorgey: a twist: `cabal update` on my local machine works fine and consumes almost no memory
06:54:33 <haasn> it only explodes on the VM
06:54:37 <kuribas> grazie: it's inferred.
06:54:53 <grazie> kuribas is the "paths" variable the "[b]" of "m [b]"?
06:55:20 <kuribas> paths is [[b]] or [[FilePath]]
06:55:30 <grazie> ok, thank you
06:56:02 <quchen> grazie: http://lpaste.net/327205
06:56:04 <quchen> Something like that
06:56:29 <quchen> The entire "\.... -> do …" has type "a -> m b" for some a, m, b
06:56:31 <byorgey> haasn: hmm, strange
06:56:52 <kuribas> grazie: is it clear?
06:57:12 <grazie> kuribas: yes
06:57:17 <grazie> thank you
06:57:18 <kuribas> ok :)
06:58:18 <grazie> although I'll probably ask a question later that indicates to you that I don't understand it (I find Haskell very abstract), but I've made a little progress :)
06:58:38 * hackagebot gogol-maps-coordinate 0.1.1 - Google Maps Coordinate SDK.  https://hackage.haskell.org/package/gogol-maps-coordinate-0.1.1 (BrendanHay)
06:58:40 * hackagebot gogol-bigquery 0.1.1 - Google BigQuery SDK.  https://hackage.haskell.org/package/gogol-bigquery-0.1.1 (BrendanHay)
06:58:42 * hackagebot gogol-resourceviews 0.1.1 - Google Compute Engine Instance Groups SDK.  https://hackage.haskell.org/package/gogol-resourceviews-0.1.1 (BrendanHay)
06:58:44 * hackagebot gogol-play-moviespartner 0.1.1 - Google Play Movies Partner SDK.  https://hackage.haskell.org/package/gogol-play-moviespartner-0.1.1 (BrendanHay)
06:58:46 * hackagebot gogol-identity-toolkit 0.1.1 - Google Identity Toolkit SDK.  https://hackage.haskell.org/package/gogol-identity-toolkit-0.1.1 (BrendanHay)
06:59:33 <grazie> kuribas: my book doesn't explain the infix operator in this code: topdir </> name  what is it called?
07:00:47 <kuribas> that's for creating file paths from components.
07:01:45 <grazie> kuribas the use of symbols like that makes Haskell more difficult than other languages (imo) as it's not easy to search them
07:03:08 <kuribas> @hoogle (</>)
07:03:11 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
07:03:11 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
07:03:11 <lambdabot> Filesystem.Path (</>) :: FilePath -> FilePath -> FilePath
07:03:21 <kuribas> grazie: ^
07:03:48 * hackagebot gogol-servicecontrol 0.1.1 - Google Service Control SDK.  https://hackage.haskell.org/package/gogol-servicecontrol-0.1.1 (BrendanHay)
07:03:49 <grazie> ok, thank you
07:03:50 * hackagebot gogol-dataflow 0.1.1 - Google Dataflow SDK.  https://hackage.haskell.org/package/gogol-dataflow-0.1.1 (BrendanHay)
07:03:52 * hackagebot gogol-gmail 0.1.1 - Google Gmail SDK.  https://hackage.haskell.org/package/gogol-gmail-0.1.1 (BrendanHay)
07:03:54 * hackagebot gogol-drive 0.1.1 - Google Drive SDK.  https://hackage.haskell.org/package/gogol-drive-0.1.1 (BrendanHay)
07:03:56 * hackagebot gogol-fitness 0.1.1 - Google Fitness SDK.  https://hackage.haskell.org/package/gogol-fitness-0.1.1 (BrendanHay)
07:06:03 <ph88> i have a list [(Int, Int)]  for each unique first Int, i would like to find the lowest second int  .. which functions would be good to help here ?
07:06:58 <opqdonut> Data.Map.fromListWith
07:07:26 <opqdonut> for ints perhaps this specialized version http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-IntMap-Strict.html#v:fromListWith
07:08:58 * hackagebot gogol-translate 0.1.1 - Google Translate SDK.  https://hackage.haskell.org/package/gogol-translate-0.1.1 (BrendanHay)
07:09:00 * hackagebot gogol-webmaster-tools 0.1.1 - Google Search Console SDK.  https://hackage.haskell.org/package/gogol-webmaster-tools-0.1.1 (BrendanHay)
07:09:02 * hackagebot gogol-appstate 0.1.1 - Google App State SDK.  https://hackage.haskell.org/package/gogol-appstate-0.1.1 (BrendanHay)
07:09:04 * hackagebot gogol-latencytest 0.1.1 - Google Cloud Network Performance Monitoring SDK.  https://hackage.haskell.org/package/gogol-latencytest-0.1.1 (BrendanHay)
07:09:06 * hackagebot gogol-monitoring 0.1.1 - Google Stackdriver Monitoring SDK.  https://hackage.haskell.org/package/gogol-monitoring-0.1.1 (BrendanHay)
07:10:20 <ph88> thx opqdonut 
07:10:54 <quchen> > M.fromListWith min [(1,1), (1,2), (1,3), (2,1), (2,2)]
07:10:57 <lambdabot>  fromList [(1,1),(2,1)]
07:11:39 <kuribas> M is Data.Map?
07:13:32 <byorgey> kuribas: yes
07:14:08 * hackagebot gogol-admin-reports 0.1.1 - Google Admin Reports SDK.  https://hackage.haskell.org/package/gogol-admin-reports-0.1.1 (BrendanHay)
07:14:10 * hackagebot gogol-spectrum 0.1.1 - Google Spectrum Database SDK.  https://hackage.haskell.org/package/gogol-spectrum-0.1.1 (BrendanHay)
07:14:12 * hackagebot gogol-urlshortener 0.1.1 - Google URL Shortener SDK.  https://hackage.haskell.org/package/gogol-urlshortener-0.1.1 (BrendanHay)
07:14:14 * hackagebot gogol-apps-reseller 0.1.1 - Google Enterprise Apps Reseller SDK.  https://hackage.haskell.org/package/gogol-apps-reseller-0.1.1 (BrendanHay)
07:14:16 * hackagebot gogol-admin-directory 0.1.1 - Google Admin Directory SDK.  https://hackage.haskell.org/package/gogol-admin-directory-0.1.1 (BrendanHay)
07:16:30 <grazie> takeExtension (from System.FilePath) type signature is this: takeExtension :: FilePath -> String  
07:16:55 <quchen> kuribas: fromListWith is like fromList, but it uses a function to resolve collisions instead of making some choice (I think it’s right-biased).
07:16:57 <grazie> but I use it by passing a string, like this: takeExtension "foo/bar.c"    why does it interpret that string as a FilePath? (because all FilePaths are strings?)
07:17:19 <grazie> i.e. does it just assume the string I pass it is a FilePath?
07:17:23 <liste> :t FilePath
07:17:25 <lambdabot> error: Data constructor not in scope: FilePath
07:17:29 <quchen> grazie: type FilePath = String
07:17:47 <quchen> They’re *identical*
07:18:00 <quchen> Try :i FilePath in GHCi :-)
07:18:51 <grazie> quchen: ok, thank you. before asking, I first tried to do :t FilePath and it said "error: Data constructor not in scope: FilePath" 
07:19:06 <grazie> (I didn't think to use :i FilePath)
07:19:15 <byorgey> grazie: :t is for asking the *type* of some *value*
07:19:18 * hackagebot gogol-android-publisher 0.1.1 - Google Play Developer SDK.  https://hackage.haskell.org/package/gogol-android-publisher-0.1.1 (BrendanHay)
07:19:20 * hackagebot gogol-adexchange-seller 0.1.1 - Google Ad Exchange Seller SDK.  https://hackage.haskell.org/package/gogol-adexchange-seller-0.1.1 (BrendanHay)
07:19:22 <byorgey> FilePath is not a value, it is a type
07:19:22 * hackagebot gogol-pubsub 0.1.1 - Google Cloud Pub/Sub SDK.  https://hackage.haskell.org/package/gogol-pubsub-0.1.1 (BrendanHay)
07:19:24 * hackagebot gogol-prediction 0.1.1 - Google Prediction SDK.  https://hackage.haskell.org/package/gogol-prediction-0.1.1 (BrendanHay)
07:19:26 * hackagebot gogol-sqladmin 0.1.1 - Google Cloud SQL Administration SDK.  https://hackage.haskell.org/package/gogol-sqladmin-0.1.1 (BrendanHay)
07:19:44 <grazie> ok thank you
07:20:25 <byorgey> grazie: notice it said *data constructor* not in scope.  There is a *type* with that name in scope of course.
07:21:55 <grazie> uh oh, running 'hoogle generate' seems to be installing 1989 different packages? 
07:22:46 <grazie> byorgey: ok, thank you
07:24:28 * hackagebot gogol-firebase-dynamiclinks 0.1.1 - Google Firebase Dynamic Links SDK.  https://hackage.haskell.org/package/gogol-firebase-dynamiclinks-0.1.1 (BrendanHay)
07:24:30 * hackagebot gogol-logging 0.1.1 - Google Stackdriver Logging SDK.  https://hackage.haskell.org/package/gogol-logging-0.1.1 (BrendanHay)
07:24:32 * hackagebot gogol-mirror 0.1.1 - Google Mirror SDK.  https://hackage.haskell.org/package/gogol-mirror-0.1.1 (BrendanHay)
07:24:34 * hackagebot gogol-analytics 0.1.1 - Google Analytics SDK.  https://hackage.haskell.org/package/gogol-analytics-0.1.1 (BrendanHay)
07:24:36 * hackagebot gogol-games-configuration 0.1.1 - Google Play Game Services Publishing SDK.  https://hackage.haskell.org/package/gogol-games-configuration-0.1.1 (BrendanHay)
07:26:42 <grazie> kuribas I have hoogle installed and working but when I try to replicate what you did: hoogle (</>) I get a syntax error near unexpected token '<
07:26:55 <grazie> hoogle (</>) -bash: syntax error near unexpected token `<'
07:27:34 <hexagoxel> grazie: hoogle "(</>)"
07:28:04 <grazie> hexagoxel: thank you
07:29:01 <grazie> hexagoxel will Hoogle only be able to provide information about packages installed on my computer
07:29:20 <hexagoxel> (consider bash syntax in "program > file")
07:29:39 * hackagebot gogol-firebase-rules 0.1.1 - Google Firebase Rules SDK.  https://hackage.haskell.org/package/gogol-firebase-rules-0.1.1 (BrendanHay)
07:29:40 * hackagebot gogol-customsearch 0.1.1 - Google CustomSearch SDK.  https://hackage.haskell.org/package/gogol-customsearch-0.1.1 (BrendanHay)
07:29:42 * hackagebot gogol-servicemanagement 0.1.1 - Google Service Management SDK.  https://hackage.haskell.org/package/gogol-servicemanagement-0.1.1 (BrendanHay)
07:29:44 * hackagebot gogol-dataproc 0.1.1 - Google Cloud Dataproc SDK.  https://hackage.haskell.org/package/gogol-dataproc-0.1.1 (BrendanHay)
07:29:47 * hackagebot gogol-games 0.1.1 - Google Play Game Services SDK.  https://hackage.haskell.org/package/gogol-games-0.1.1 (BrendanHay)
07:32:47 <hexagoxel> grazie: afaik, yes. although i suppose one could download hoogle dicts, it certainly does not do such automatically.
07:34:12 <merijn> No, you can generate hoogle info for all of hackage if you want
07:34:12 <merijn> But I forgot how
07:34:26 <tabaqui1> I have "do" action with "case" inside
07:34:33 <tabaqui1> how can I skip some action
07:34:37 <tabaqui1> like
07:34:40 <tabaqui1> do
07:34:45 <tabaqui1>   case a of
07:34:48 * hackagebot gogol-apps-activity 0.1.1 - Google Apps Activity SDK.  https://hackage.haskell.org/package/gogol-apps-activity-0.1.1 (BrendanHay)
07:34:51 * hackagebot gogol-doubleclick-search 0.1.1 - Google DoubleClick Search SDK.  https://hackage.haskell.org/package/gogol-doubleclick-search-0.1.1 (BrendanHay)
07:34:52 <tabaqui1>     smth -> <skip>
07:34:53 * hackagebot gogol-people 0.1.1 - Google People SDK.  https://hackage.haskell.org/package/gogol-people-0.1.1 (BrendanHay)
07:34:55 * hackagebot gogol-maps-engine 0.1.1 - Google Maps Engine SDK.  https://hackage.haskell.org/package/gogol-maps-engine-0.1.1 (BrendanHay)
07:34:57 * hackagebot gogol-books 0.1.1 - Google Books SDK.  https://hackage.haskell.org/package/gogol-books-0.1.1 (BrendanHay)
07:34:59 <tabaqui1>     other -> dosmth
07:35:18 <quchen> case a of Just x -> print x; Nothing -> pure ()
07:35:24 <quchen> This does nothing in the Nothing case.
07:35:25 <tabaqui1> pure?
07:35:29 <quchen> = return
07:35:35 <tabaqui1> :t pure
07:35:37 <lambdabot> Applicative f => a -> f a
07:35:40 <tabaqui1> ah, return
07:35:43 <quchen> Nothing -> return () works just as well
07:35:55 <tabaqui1> hm, yeah, I've thought about
07:36:08 <tabaqui1> haskell hasn't smth like "pass" in python?
07:36:31 <icosane> You can write one yourself: pass = return ()
07:36:33 <quchen> I don’t know Python.
07:39:03 <tabaqui1> hm, ok, that will do
07:39:59 * hackagebot gogol-qpxexpress 0.1.1 - Google QPX Express SDK.  https://hackage.haskell.org/package/gogol-qpxexpress-0.1.1 (BrendanHay)
07:40:01 * hackagebot gogol-adexchange-buyer 0.1.1 - Google Ad Exchange Buyer SDK.  https://hackage.haskell.org/package/gogol-adexchange-buyer-0.1.1 (BrendanHay)
07:40:03 * hackagebot gogol-games-management 0.1.1 - Google Play Game Services Management SDK.  https://hackage.haskell.org/package/gogol-games-management-0.1.1 (BrendanHay)
07:40:05 * hackagebot gogol-groups-migration 0.1.1 - Google Groups Migration SDK.  https://hackage.haskell.org/package/gogol-groups-migration-0.1.1 (BrendanHay)
07:40:07 * hackagebot gogol-appengine 0.1.1 - Google App Engine Admin SDK.  https://hackage.haskell.org/package/gogol-appengine-0.1.1 (BrendanHay)
07:44:00 <shapr> good morning #haskell?
07:44:05 <shapr> Anyone writing cool code?
07:44:15 <dolio> No.
07:44:33 * shapr hugs dolio 
07:44:36 <shapr> It'll get better.
07:44:37 <dolio> :)
07:44:58 <dolio> No, I'm answering for everyone.
07:45:09 * hackagebot gogol-ml 0.1.1 - Google Cloud Machine Learning SDK.  https://hackage.haskell.org/package/gogol-ml-0.1.1 (BrendanHay)
07:45:11 * hackagebot gogol-sheets 0.1.1 - Google Sheets SDK.  https://hackage.haskell.org/package/gogol-sheets-0.1.1 (BrendanHay)
07:45:13 * hackagebot gogol-script 0.1.1 - Google Apps Script Execution SDK.  https://hackage.haskell.org/package/gogol-script-0.1.1 (BrendanHay)
07:45:15 * hackagebot gogol-compute 0.1.1 - Google Compute Engine SDK.  https://hackage.haskell.org/package/gogol-compute-0.1.1 (BrendanHay)
07:45:17 * hackagebot gogol-shopping-content 0.1.1 - Google Content API for Shopping SDK.  https://hackage.haskell.org/package/gogol-shopping-content-0.1.1 (BrendanHay)
07:45:26 <dolio> Hmm... How many gogol things are there I wonder.
07:45:28 <icosane> seems it is getting better right now (hackagebot)
07:46:05 <icosane> shapr: does writing cool code in C count?
07:46:16 <sbrg> icosane: there is no cool C code
07:46:21 <sbrg> there is only pain
07:46:28 <icosane> true
07:46:48 --- mode: ChanServ set +o dolio
07:46:48 --- mode: dolio set +q hackagebot!*@*
07:47:11 <icosane> I'm writing C right now (actually, C++) and it is not really cool
07:47:21 <merijn> icosane: Word.
07:47:29 <dolio> Oh, I might be too late.
07:48:15 <icosane> I'm getting a lot of problems I never got in haskell
07:48:27 <shapr> funny that
07:48:40 <icosane> better write it in haskell
07:49:12 <merijn> I was writing in C++, that was fine. Not as terse as haskell, but I could do what I wanted albeit in a larger number of lines
07:50:33 <merijn> Now I'm writing loads of python and it's ruining my sanity
07:50:45 <sbrg> lol
07:50:46 <sbrg> yeah
07:50:58 <icosane> writing in scheme can also be hard
07:51:06 <sbrg> when something crashes on type errors during runtime, my mind just can't compute it
07:51:08 <sbrg> it makes no sense.
07:51:40 <icosane> the parentheses aren't the problem, the type errors at *run time* do it 
07:54:47 <merijn> sbrg: I'd be happy if I could even figure out what the types were supposed to be :(
07:55:26 <icosane> haskell-style type signatures in docstrings could be useful
07:55:34 <sbrg> that exists
07:55:46 <sbrg> well, not sure if they are haskell-like
07:55:53 <sbrg> but type annotations for python does exist.
08:08:56 <haasn> sbrg: I wish I had $1 for every time I ran into a runtime type error during my computing
08:09:46 <haasn> (browsing the web would probably make me rich)
08:14:16 <jeltsch> I want to install the cabal-test-quickcheck package. Running cabal install cabal-test-quickcheck gives the following output:
08:14:30 <jeltsch> http://lpaste.net/327273
08:14:55 <jeltsch> Can anyone help me in resolving this problem?
08:15:20 <jeltsch> At the moment, I have a bare GHC 8.0.1 plus a current cabal-install and very few additional packages.
08:15:41 <Schoolmeister> I think it's pretty much what it says
08:16:04 <Schoolmeister> If you install it, that hackage-security package will probably break
08:16:37 <jeltsch> It is not straightforward to understand if you are not deeper into Cabal dependency hell issues.
08:16:45 <tsahyt> Hello! Is there a way to get GHC to output the FFI calls that are being made when debugging some C bindings?
08:16:53 <jeltsch> It says much more than just hackage-security breaking.
08:17:09 <jeltsch> It also does’t say explicitely, why hackage-security would breack.
08:17:46 <jeltsch> For example, it says things about removing binary, which is strange, since I thought that cabal install would never remove packages.
08:18:21 * hvr hopes we can soon recommend new-build to everyone
08:18:39 <jeltsch> And why does it need a newer version of binary for Cabal-1.24.0.0 if the older one had been fine for Cabal-1.24.0.0 so far?
08:19:29 <merijn> tsahyt: In what sense? You wanna check what C functions are called when?
08:19:38 <tsahyt> merijn: yep
08:20:04 <Schoolmeister> I'm sorry, there's people here that can help you out a lot more than me. Maybe this stack overflow post has some use for you? http://stackoverflow.com/questions/27839021/cabal-sandbox-install-still-fails-with-packages-are-likely-to-be-broken-by-the
08:20:06 <merijn> tsahyt: Not sure about that, but realise that if you compile your C library with debug symbols you can just load the binary in gdb/lldb and set breakpoints :)
08:20:13 <hvr> jeltsch: if you don't want to try `cabal new-build` just yet, I'd recommend using `cabal sandbox` to workaround your problem
08:20:26 <tsahyt> I thought rather than rewriting the example in C by hand to see whether it still segfaults, I could start by translating what GHC produced
08:20:51 <jeltsch> hvr: I actually do not want to start using sandboxes.
08:20:57 <merijn> tsahyt: Oh, if you're debugging segfaults then I'd really just see if you can debug using gdb
08:21:00 <jeltsch> I just would like to install a consistent set of packages.
08:21:05 --- mode: dolio set -q hackagebot!*@*
08:21:12 --- mode: dolio set -o dolio
08:21:16 <merijn> tsahyt: Then you can also inspect arguments, etc
08:21:34 <tsahyt> merijn: the problem is it doesn't segfault where I make the call. it segfaults later on
08:21:34 <jeltsch> I am also willing to reinstall some packages, but first I would have to understand what exactly the cabal-install output means and what the deeper reasons behind this problem are.
08:21:34 <hvr> jeltsch: try `--constraint 'Cabal installed'`
08:21:53 <tsahyt> merijn: and I'm not sure whether this is actually my fault. the library isn't production ready yet
08:21:57 <hvr> jeltsch: and see if you can convince cabal to manage to find a different plan which doesn't reinstall Cabal
08:21:59 <merijn> tsahyt: Sure, but you can still set breakpoints and inspect arguments of your FFI functions
08:21:59 <tsahyt> I've found a handful of bugs already
08:22:18 <tsahyt> I think I'll start out with that then
08:22:54 <jeltsch> hvr: This indeed works! I just wonder why cabal-install is not able to figure out that there is actually a plan that works.
08:22:55 <hvr> jeltsch: well, the reason cabal wants to reinstall Cabal is because the install-plan demands a different configuration of Cabal to be used
08:23:16 <hvr> jeltsch: because there is not one single optimal solution
08:23:34 <hvr> jeltsch: there's many potential solutions and there's many local optima in the search-space
08:23:43 <hvr> (in general)
08:24:34 <jeltsch> hvr: Okay, if there are many locally optimal solutions, then cabal-install might not pick the one I want. But in my case, the problem was not that cabal-install found an unwanted solution, but that it found no solution at all.
08:25:03 <jeltsch> hvr: I am not an expert in con
08:25:07 <hvr> jeltsch: yeah, it's indeed unfortunate that it stopped at the --reinstall barrier, rather than trying harder
08:25:36 <jeltsch> hvr: I am not an expert in constraint solving, but I think that a constraint solver should find at least one solution if an solution exists.
08:25:48 <hvr> jeltsch: I can only tell you that with http://blog.ezyang.com/2015/08/help-us-beta-test-no-reinstall-cabal/ those cases won't happen anymore
08:26:15 <jeltsch> hvr: The --reinstall was also not a (proper) solution, since it could have broken haskell-security. It was a solution for the install at hand, but not for the whole setup.
08:26:18 <hvr> jeltsch: or more recent docs @ http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
08:27:22 <jeltsch> hvr: Anyway, thanks a lot for the hint with “--constraint 'Cabal installed'”.
08:28:29 <jeltsch> Why is this actually called “new-build”. At some point, it will be the normal way to build things, and than calling it “new-build” is even more awkward. And even later, we might have “very-new-build”, “absolutely-new-build”, and whatever.
08:28:46 <hvr> jeltsch: new-build will be renamed into 'build' :)
08:28:53 <merijn> jeltsch: Because it doesn't work for all ghc's yet, afaik?
08:29:00 <jeltsch> hvr: This is what I hope for. :-) 
08:29:03 <merijn> jeltsch: And cabal should work with older supported ghc's too
08:29:03 <hvr> merijn: for which one wouldn't it work?
08:29:28 <merijn> hvr: I dunno? I was under the impression it didn't?
08:29:49 <hvr> merijn: here's a new-build powered buildjob: https://travis-ci.org/hvr/cassava/builds/169807732
08:29:52 <merijn> Maybe I'm confusing things in my mind :)
08:30:07 <dolio> It works all the way back to 7.0 or something.
08:30:07 <hvr> merijn: it would also work w/ GHC 7.4 if cassava was compatible w/ it
08:30:49 <dolio> I thought.
08:30:49 <hvr> dolio: it works mostly w/ 7.0
08:30:49 <hvr> dolio: but definitely *not* w/ 6.x
08:30:51 <dolio> Ah. Well, it's hard to get 6.x to test with anyway.
08:31:06 <ronbrz> hey, I'm working through the NICTA course and am having trouble wrapping my mind around this function https://github.com/tonymorris/course/blob/master/src/Course/State.hs#L176 . It looks like lift2 is being applied to "lift2 (,)", I think the type of "lift2 (,)" is "applicative f => f a -> f b -> f c
08:31:13 <pie_> is it possible to use haskell as an embedded scripting language, like how emacs has lisp for example? would that still need a complete ghc (iirc ghc is pretty big?)?
08:31:50 <dolio> emacs is written in lisp.
08:31:56 <ronbrz> so wouldnt applying lift2 to that result in "applicative f => f f a -> f f b -> f f c" ? that seems wrong...
08:31:59 <hvr> merijn: anyway, it works with more GHC versions than Stack :)
08:32:12 <dolio> It's like a lisp compiler/interpreter with an editor (and other stuff) written in it.
08:32:36 <hvr> which appears to say "stack will almost certainly fail with GHC below version 7.8"
08:33:35 <merijn> I still haven't used stack, because I'm a curmudgeony luddite ;)
08:33:40 <pie_> dolio, ah well ok. i want to do this for a program to be written in haskell if that helps
08:34:01 <nitrix> ronbrz: It'd be `f (f b)` not `f f b`.
08:34:03 <merijn> pie_: Can it be done? Sure, in a few ways
08:34:06 <dolio> Well, there is prior art for that, although I don't know how up to date it is.
08:34:10 <glguy> pie_: You might look at "hint" and "mueval" packages
08:34:23 <nitrix> ronbrz: Otherwise the kind of `f` would be simultanously :: * -> * and * -> * -> *
08:34:34 <byorgey> ronbrz: that's the right idea, though (1) that's not quite the right type for  lift2 (,)  and (2) you need more parens:  f (f a) -> f (f b) -> ...
08:34:40 <merijn> pie_: Writing an editing core in haskell and dynamically loading code is possible, albeit not very polished, so it'd require a bunch of work
08:34:57 <byorgey> ronbrz: (,) has type  a -> b -> (a,b),  so what is the type of  lift2 (,) ?
08:35:12 <pie_> merijn, what do you mean by editing core?
08:35:15 <merijn> pie_: You can also dynamically load libraries and I think dons wrote his thesis about plugins for haskell
08:35:38 <merijn> pie_: emacs is basically an API for a bunch of screen displaying/text manipulation functions
08:35:44 <merijn> pie_: And plugins then just script on top of that API
08:36:17 <merijn> pie_: Implementing the core in haskell is certainly doable and not more work than doing so in any other language. Doing said scripting on top of it is also possible, but messier and more complex
08:36:33 <ronbrz> byorgey: lift2 (,) should be "f a -> f b -> f (a,b)" right?
08:36:45 <merijn> pie_: Depending on whether you want to allow dynamically loading/running plugins
08:37:46 <pie_> well the whole point would be to make scripting stuff as easy as possible, so not needing to reload the program and whatever; code'n'run :P REPL and all that jazz
08:39:03 <pie_> thanks for the input bt
08:39:05 <pie_> *btw
08:40:18 <nitrix> ronbrz: `Applicative f => a -> b -> c -> f a -> f b -> f c` applied on `a2 -> b2 -> (a2, b2)` unifies as `a ~ a2`, `b ~ b2`, `c ~ (a2, b2)`.
08:40:18 <merijn> That's possible, but of course, substantially harder :)
08:40:19 <merijn> You might wanna look at what Apfelmus is doing with his Haskell REPL/notebook thing
08:40:19 <nitrix> ronbrz: Thus you get `Applicative f => f a2 -> f b2 -> f (a2, b2)
08:40:52 <pie_> thanks will check it out
08:42:00 <byorgey> ronbrz: right
08:42:00 <merijn> pie_: https://github.com/HeinrichApfelmus/hyper-haskell
08:42:00 <byorgey> nitrix: that should be   `Applicative f => (a -> b -> c) -> f a -> f b -> f c`  of course
08:42:23 <nitrix> Sorry. Thanks for the correction.
08:42:55 * hackagebot formatting 6.2.3 - Combinator-based type-safe formatting (like printf() or FORMAT)  https://hackage.haskell.org/package/formatting-6.2.3 (ChrisDone)
08:44:42 <pie_> merijn, to add to the madness, would embedding multiple scripting languages make things nastier(beyond inherent nastiness in whatever a language uses as a runtime)? what if i want to embed scheme or python as well?
08:45:05 <pie_> those obviously not being bound to functional programmming, would that cause problems?
08:45:45 <merijn> pie_: You'd lose the typing information at the boundaries, but depending on your language that would actually be rather simple
08:46:10 <merijn> pie_: i.e. some scheme implementations and, for example, Lua are very easy to embed, so that would certainly be doable
08:46:16 <pie_> instanceof hacks everywhere!
08:46:19 <tsahyt> after reimplementing the example in plain C I can confirm that it also segfaults there. time for a bug report I guess
08:46:26 <tsahyt> good to know that my haskell code wasn't at fault though
08:46:47 <merijn> pie_: But not all interpreters are designed to accomodate that, so if you want to, for example, embed CPythong, I'm not sure how hard that would be
08:47:10 <pie_> i know some programs embed python with ?great? success, so at the least its possible
08:47:26 <merijn> pie_: Lua was mostly designed to be embedded into other programs, so it works rather well, see for example the World of WarCraft UI, which is a marvelous example
08:47:48 <merijn> pie_: I know people have successfully embedded python (Eve Online, for example), but not sure how much work that was
08:47:55 <pie_> but lua isnt "cool" :P
08:47:59 <phadej>  merijn, pie: lua is quite easy. Check inline-r, you can more ore less copy-paste the code
08:47:59 <pie_> i jest
08:48:12 <phadej> python is tricky as it has globals, last time i checked
08:49:11 <pie_> well i dont know what im talking about but if nothing else one could run python isolated and use some kind of IPC
08:49:25 <pie_> actually...a guess you could do that with ang language at that point
08:49:30 <pie_> *I guesss
08:49:35 <pie_> *any
08:49:44 <phadej> iirc the interpreter state is global, which complicates embedding "as a library"
08:50:22 <pie_> looks like this is oficially supported https://docs.python.org/3/extending/embedding.html
08:51:33 <merijn> pie_: But essentially, what you're asking is rather similar to WoW's UI, they basically have a C++ engine that exposes an API for drawing UI widgets and have an embedded Lua interpreter that has access to that UI so people can write addons that modify/customise the UI
08:51:33 <merijn> eh, access to that API
08:51:38 <phadej> pie_: it is, but the 'Py_Initialize();' is the problematic one
08:51:55 <pie_> phadej, i see
08:51:57 <phadej> it's not "PyState *pys = Py_Initialaize();' you then pass around
08:52:01 <merijn> I would classify it as "possible, but likely too much work for you to ever truly finish, but, hey, you'll learn a lot!"
08:52:53 <phadej> but as I said, inline-r has solved already ~all problems, it's just typing the code in
08:52:56 <phadej> if you want it to happen
08:53:17 <pie_> ok thanks
08:53:24 <pie_> :D
08:55:59 <pie_> https://wiki.haskell.org/Applications_and_libraries/Interfacing_other_languages
09:00:19 <kirillow> Can somebody explain to me how i can do this: https://gist.github.com/anonymous/5e0504c7d321bf696be77e8d53cf6e7d ?
09:00:41 <cheater> there's a ffi for python?
09:00:49 <cheater> when did that happen?
09:00:51 <cheater> is it good?
09:02:03 <glguy> kirillow: someList :: [A]
09:02:17 <kirillow> o_O
09:02:30 <pie_> cheater, as in thats something haskell has or something that python has? python has had an ffi for a long time im pretty sure...
09:02:39 <pie_> buy of course you mean the formr xD
09:02:45 <kirillow> oh yea
09:02:46 <kirillow> sorry
09:02:52 <kirillow> it should've been [A]
09:02:52 <merijn> kirillow: You want all A2 constructors?
09:02:54 <cheater> i meant a way to use python code and libs in a haskell program
09:03:00 <kirillow> ultimately yes
09:03:08 <kirillow> but one would already be a huge step
09:03:10 <cheater> i thought that's what you were describing here, i thought there was a way you were talking about
09:03:16 <cheater> but maybe i'm wrong
09:03:27 <merijn> kirillow: Witness the amazing trick of mixing record syntax patterns with non-records!
09:03:48 <glguy> You can use Python libs from Haskell via the C FFI. That's what the original hpaste did for syntax highlighting via pygments
09:04:00 <merijn> > [x | x@Left{} <- [Left True, Right 'c', Left False, Left False, Right 'a']]
09:04:02 <pie_> cheater, well i dont think anything specific got mentioned but there appear to be things mentioned on the page i jus tlinked
09:04:02 <lambdabot>  [Left True,Left False,Left False]
09:04:19 <merijn> kirillow: Replace Left{} with "A2{}" and done
09:04:31 <kirillow> ...
09:04:36 <kirillow> what is that hahaha
09:04:38 <cheater> pie_: ok, thanks
09:05:09 <merijn> kirillow: {} pattern matches records, but "Foo{}" is just "match Foo constructor ignoring how many arguments it might have"
09:05:22 <cheater> pie_: i have a feeling haskell is becoming a really compelling thing for people using all sorts of langs as a tech used to bring them together..
09:05:41 <merijn> kirillow: Or, just "[x | A2 x <- someList]"
09:05:57 <kirillow> oO
09:05:59 <merijn> kirillow: Pattern match failure in a list comprehension just drops the non-matching element
09:06:09 <pie_> cheater, looks like its a thing https://john-millikin.com/articles/ride-the-snake/ question is how good/buggy is it?
09:08:12 <kirillow> WOW
09:08:15 <ronbrz> so "lift2 (lift2 (,))" should be `Applicative f => f (f a) -> f (f b) -> f (f (a, b))` and... I'm having trouble figuring out what type `State . lift2 (lift2 (,))` is. State is `((s -> (a, s)) -> State s a)`, and the dot operator is `(b -> c) -> (a -> b) -> a -> c`, so... applied on the dot operator type this should unify as `b ~ s -> (a, s)`, `c ~ State s a`, `a ~ f (f a)` ? so how is `f (f b) -> f (f (a,
09:08:17 <ronbrz> b))` the same as `s -> (a, s)`?
09:08:20 <kirillow> this is really cool
09:09:35 <pie_>  meh i wish blog posts without dates on them werent a thing
09:12:14 <pie_> cheater, https://www.reddit.com/r/haskell/comments/3hv6l1/why_is_this_haskellpython_binding_not_more/
09:13:44 <kuribas> :t State
09:13:45 <lambdabot> error:
09:13:45 <lambdabot>     • Data constructor not in scope: State
09:13:45 <lambdabot>     • Perhaps you meant one of these:
09:14:02 <kuribas> :t state . lift2 (lift2 (,))
09:14:04 <lambdabot> error:
09:14:04 <lambdabot>     • Variable not in scope: lift2 :: t0 -> a -> s0 -> (a1, s0)
09:14:04 <lambdabot>     • Perhaps you meant one of these:
09:14:34 <ronbrz> I'm working through the NICTA course, State is a defined type in the State module
09:14:53 <ronbrz> State :: (s -> (a, s)) -> State s a
09:16:15 <ab9rf> State is a type constructor
09:16:33 <ronbrz> yeah
09:18:58 <ronbrz> using `:t State . lift2 (lift2 (,))` in my ghci results in `Applicative ((,) a) => (a, (a, a)) -> State (a, (a, b)) a`, I'm having trouble figuring out that type myself though
09:21:42 <ab9rf> it's a pretty strange type
09:21:58 <pie_> https://hackage.haskell.org/package/cpython "All reported builds failed as of 2015-12-12"
09:22:06 <pie_> :C
09:22:39 <ronbrz> its in the context of this function which I'm trying to understand https://github.com/tonymorris/course/blob/master/src/Course/State.hs#L176
09:23:25 <ronbrz> yeah, the strangeness is making my head hurt haha
09:23:56 <pie_> oh the build failure might just be because of 3rd party stuff on the build serer or what
09:24:00 <pie_> lack of rather
09:25:07 <pie_> thats for calling python from haskell but doesnt have the other direction though
09:25:10 <kuribas> ab9rf: liftM2 (liftM2 (,)) is (,) over two stacked monads
09:25:14 <nitrix> ronbrz: State . lift2 (lift2 (,)) could be a little confusing because it isn't applied to anything yet.
09:25:38 <kuribas> I mean ronbrz 
09:28:13 <nitrix> ronbrz: The idea is still the same, you provide the current state which has type (a, (a, a)) and obtain a stateful computation that
09:29:48 <ronbrz> nitrix: so how do you recommend trying to figure out what a complicated looking function does? I guess I'm trying to understand the smallest units and work my way out, but maybe thats confusing me more? or maybe I haven't fully wrapped my head around the utility of State yet, and haven't used liftM that much
09:30:08 <nitrix> produces a result of type (a, (a, b)) and will mappend the `a`'s of the state into a new `a`.
09:30:24 <kuribas> ronbrz: what does the function do?
09:30:42 <nitrix> ronbrz: State is easier to use than to implement. Also, I can see how that pointfree leads to confusion too. 
09:31:54 <nitrix> Personally, the liftA2 (liftA2 (,)) seems uncalled for.
09:32:22 <kuribas> ronbrz: you can try rewriting it.
09:32:33 <ronbrz> kuribas: hah, thats what I'm trying to understand. It'll be used as a helper function to find the first repeated element in a list and da distinct element in a list
09:32:57 <Apocalisp> is there a more generic version of MonadIO where instead of IO, we can lift into some other monad?
09:32:58 * hackagebot tagged-identity 0.1.1 - Trivial monad transformer that allows identical monad stacks have different types  https://hackage.haskell.org/package/tagged-identity-0.1.1 (mrkkrp)
09:33:23 <glguy> Apocalisp: MonadLib has "BaseM"
09:34:21 <Apocalisp> does mtl have anything like that?
09:35:12 <nitrix> ronbrz: Even your `put` is trying way too hard to be clever:  State . const . (,) ()  by   State $ \x -> ((), x)
09:35:55 <nitrix> ronbrz: If you work with the typical  \s -> (a, s) all along your implementation, things will be much easier.
09:37:23 <ronbrz> hah, thats actually how I implemented it. Those are the 'official' answers to the NICTA course that I look at when I'm stuck. Sometimes I think they are trying to be to clever, but I don't know if its that or I just am not used to reading haskell
09:37:40 <ronbrz> I'm happy to hear its the former
09:37:59 * hackagebot tar-conduit 0.1.0 - Parse tar files using conduit for streaming  https://hackage.haskell.org/package/tar-conduit-0.1.0 (SimonMarechal)
09:38:10 <kuribas> lift2 (lift2 (,)) m S.insert, isn't that a reader monad?
09:38:23 <kuribas> since S.insert is a function.
09:38:46 <kuribas> reader monad always makes things complicated.
09:40:42 <nitrix> Personally, `eval (f (State . lift2 (lift2 (,)) m S.insert) x) S.empty` is very scary. Worse, `listWithState :: Ord a1 => ((a1 -> State (S.Set a1) a2) -> t -> State (S.Set a3) a) -> (a1 -> S.Set a1 -> a2) -> t -> a` makes me think just by the name of the type variables that the person that wrote it doesn't really know either what the type result is and just ended up asking GHC to put that type annotation
09:40:44 <nitrix> there.
09:41:15 <nitrix> That's how confusing that function is :P
09:45:13 <kuribas> yeah the outer monad is a reader monad
09:45:37 <kuribas> I've never seen pointfree with a reader monad that's readable (no pun intended).
09:46:34 <quchen> Well, Reader is closely related to SKI calculus, which is the gold standard in unreadable notation
09:47:02 <ronbrz> hah, glad to hear that it's actually confusing and its not just me being dumb
09:47:09 <quchen> Not that you can’t use Reader in a useful way, it’s just that it’s not suitable for pointfree style
09:47:09 <kuribas> so lift2 (lift2 (,)) m S.insert == (\x -> lift2 (,) (m x) (S.insert x))
09:47:19 <kuribas> quchen: right
09:47:32 <quchen> ronbrz: The code you’ve posted is abysmal.
09:47:55 <quchen> In many respects.
09:48:21 <quchen> Incomprehensible type. No documentation. Too many things going in and out. Useless name.
09:48:35 <quchen> s/name/names/
09:49:43 <quchen> Not sure what lift2 is even.
09:49:59 <quchen> An obfuscated name for liftA2? That is, a non-standard name for something very standard?
09:50:05 <quchen> ಠ_ಠ 
09:50:07 <ronbrz> haha, those are the 'official' answers for the exercises here https://github.com/NICTA/course, good thing I'm checking my code from that
09:50:32 <quchen> put = State . const . (,) ()
09:50:34 <quchen> What the hell.
09:50:40 <nitrix> Yep.
09:50:47 <ronbrz> lift2 was implemented in the applicative section here https://github.com/tonymorris/course/blob/master/src/Course/Applicative.hs#L180
09:50:53 <nitrix> My thought exactly. I'm almost convinced they're obfuscating on purpose.
09:51:10 <nitrix> quchen: Not sure what's wrong with  State $ \x -> ((), x)
09:51:45 <quchen> \x -> State (\_ -> ((), x))
09:51:46 <quchen> But yeah.
09:51:47 <kuribas> ronbrz: The inner one is also a reader monad, so (lift2 (lift2 (,)) m S.insert) ==  (\x y -> (m x y, insert x y))
09:52:13 <quchen> Whoever gave Lambdabot @pl is an evil genius
09:52:58 <nitrix> @let newtype State s a = State { runState :: s -> (a, s) }
09:53:00 <lambdabot>  Defined.
09:53:05 <nitrix> @unpl State . const . (,) ()
09:53:06 <lambdabot> (\ x -> (State) (\ _ -> (,) () x))
09:53:33 <nitrix> quchen: Ah, you had it right. Whao, the mental gymnastics ._.
09:54:25 <kuribas> ronbrz: reader monad is write only (again no pun intended).
09:54:49 <quchen> Not really, you can write good code with it.
09:54:54 <cheater> well nitrix it's fairly easy, the x was an argument to put, so in lambda form it would be before anything, including the State constructor
09:54:54 <nitrix> At least they were kind enough to give us @unpl :P
09:54:59 <quchen> Just like you can use lambdas to write unreadable code, they’re not necessarily bad.
09:55:04 <ronbrz> kuribas: oh wow, that makes a lot more sense than the double lift2, thanks
09:55:20 <cheater> sometimes @pl yields really nice insights
09:55:29 <quchen> Never seen that happen.
09:55:51 <nitrix> It does turn things into liftM2 and similar at times.
09:55:51 <cheater> usually when i'm too lazy to come up with concise code myself
09:55:54 <quchen> I’ve seen conversion to pointful style yielding nice insights (namely what the code is suppose to do)
09:56:24 <cheater> yea doing something like @@ @pl @unpl is good too
09:56:39 <cheater> @@ @pl @unpl foo x = bar . baz $ x
09:56:39 <lambdabot>  (line 1, column 20):
09:56:39 <lambdabot> unexpected ';'
09:56:39 <lambdabot> expecting variable, "(", operator or end of input
09:56:52 <cheater> @@ @pl @unpl let foo x = bar . baz $ x
09:56:52 <lambdabot>  (line 1, column 1):
09:56:53 <lambdabot> unexpected "<"
09:56:53 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:56:56 <cheater> what's going on?
09:57:10 <nitrix> Doesn't work with bindings.
09:57:12 <unclechu> hey guys, why `System.Process` doesn't export `StdStream(NoStream)`? I definitely can see it here http://hackage.haskell.org/package/process-1.4.2.0/docs/src/System.Process.Common.html#NoStream 
09:57:37 <cheater> oh well, you know what i mean anyways
09:58:00 * hackagebot stache 0.1.8 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.8 (mrkkrp)
09:58:24 <unclechu> so it's okay with other value constructors: `import System.Process (StdStream(CreatePipe, Inherit))`
09:58:34 <nitrix> cheater: Use a lambda.
09:58:48 <cheater> yeah, i did
09:58:57 <cheater> in query
09:59:46 <quchen> unclechu: Your link is to System.Process.Common.
09:59:49 <quchen> Not System.Process.
10:01:17 <unclechu> quchen: but `System.Process` exports it all
10:01:53 <unclechu> quchen: look at `StdStream(..),` in http://hackage.haskell.org/package/process-1.4.2.0/docs/src/System.Process.html
10:02:38 <quchen> Oh, I overlooked that.
10:03:00 * hackagebot semiring-num 0.2.0.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.2.0.0 (oisdk)
10:03:02 * hackagebot ngx-export 0.2.3.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.3.1 (lyokha)
10:03:04 <kuribas> ronbrz: eliminating (.) : eval (f (\s -> State (\s y -> (m s y, insert s y)))) S.empty
10:03:06 <glguy> unclechu: System.Process *does* export StdStream
10:03:34 <unclechu> hmm. it looks like a have earlier version, may be it's main reason why it doesn't
10:04:14 <quchen> unclechu: Hackage seems to think it’s exported.
10:05:53 <unclechu> I just don't understand why 'stack' can't install latest version with this error: 'process-1.2.3.0 must match >=1.4 && <1.5 (latest applicable is 1.4.2.0)'
10:07:33 <unclechu> I did it by my bare hands with command `stack install process-1.4.2.0` but it doesn't change anything
10:07:50 <unclechu> any ideas why I have this error?
10:08:37 <kuribas> ronbrz: If I plug in findM and S.member: \x -> eval (findM (State (\s y -> (S.member s y, S.insert s y))) x) S.empty
10:09:17 <geekosaur> unclechu, that means something in your dependencies is requiring that specific version (1.2.3.0)
10:09:31 <geekosaur> or you are pointing at an old resolver that lists that version
10:10:58 <kuribas> ronbrz: \x -> eval (findM (\s -> State (\y -> (S.member s y, S.insert s y))) x) S.empty
10:14:29 <unclechu> geekosaur: I checked dependencies of other packages and none of them require this, what do you mean under 'old resolver'?
10:14:29 <geekosaur> https://docs.haskellstack.org/en/stable/yaml_configuration/
10:14:30 <geekosaur> if you don't have a stack.yaml in that project then it's likely using one it created the first time you installed stack, which will specify the stackage snapshot that was then current.
10:15:20 <unclechu> geekosaur: I just have 'resolver: lts-5.9' in that file
10:16:36 <geekosaur> https://www.stackage.org/lts-5.9 says indeed https://www.stackage.org/lts-5.9/package/process-1.2.3.0
10:16:37 <unclechu> geekosaur: so it means I should use package version from that `lts` available range?
10:16:57 <geekosaur> if you want a newer process, point to a newer lts resolver
10:17:26 <unclechu> geekosaur: okay, thank you!
10:21:32 <econometrician> does anyone know where "stack ghci" looks for a .ghci file? (it's not in ~/.ghci, ~/ghc/ghci.conf or .ghci)
10:25:40 <sbrg> ¯\_(ツ)_/¯ stack ghci does read my ~/.ghci
10:26:57 <asthasr> sbrg: He might be a victim of a distribution. ~/.config/.ghci or some such.
10:26:57 <asthasr> but, he already left, so.
10:27:03 <sbrg> yeah
10:34:44 <ania123> how function compisition is defined?
10:34:57 <ania123> i mena what sign is for function composition
10:35:06 <sbrg> :t (.) -- this is the type
10:35:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:35:09 <Cale> (f . g) x = f (g x)
10:35:20 <Cale> is the definition
10:35:36 <ania123> ok
10:38:02 * hackagebot haskell-tools-ast 0.3.0.0 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-0.3.0.0 (lazac)
10:38:04 * hackagebot haskell-tools-backend-ghc 0.3.0.0 - Creating the Haskell-Tools AST from GHC's representations  https://hackage.haskell.org/package/haskell-tools-backend-ghc-0.3.0.0 (lazac)
10:38:06 * hackagebot haskell-tools-prettyprint 0.3.0.0 - Pretty printing of Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-prettyprint-0.3.0.0 (lazac)
10:38:08 * hackagebot haskell-tools-rewrite 0.3.0.0 - Facilities for generating new parts of the Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-rewrite-0.3.0.0 (lazac)
10:38:10 * hackagebot haskell-tools-refactor 0.3.0.0 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-refactor-0.3.0.0 (lazac)
10:39:26 <pie_> https://wiki.haskell.org/Shooting_your_self_in_the_foot "You aim the gun at your foot, pull the trigger and remove the clip. When you look at your undamaged foot, the hammer clicks on an empty barrel."
10:40:26 <zipper> > :t (->)
10:40:29 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:40:38 <orion> magazine, not clip.
10:40:40 <zipper> Why is this happening?
10:40:50 <geekosaur> :t (->)
10:40:52 <lambdabot> error: parse error on input ‘->’
10:40:59 <geekosaur> oh
10:41:19 <geekosaur> because it doesn't have a type
10:41:19 <zipper> geekosaur: yeah, what's up with this?
10:41:24 <geekosaur> :k (->)
10:41:27 <lambdabot> * -> * -> *
10:41:34 <zipper> Oh it's a type constructor
10:41:37 <zipper> Like maybe
10:41:40 <zipper> *Maybe
10:41:43 <geekosaur> yes
10:43:12 * hackagebot haskell-tools-cli 0.3.0.0 - Command-line frontend for Haskell-tools Refact  https://hackage.haskell.org/package/haskell-tools-cli-0.3.0.0 (lazac)
10:43:14 * hackagebot haskell-tools-demo 0.3.0.0 - A web-based demo for Haskell-tools Refactor.  https://hackage.haskell.org/package/haskell-tools-demo-0.3.0.0 (lazac)
10:44:26 <ronbrz> thanks kuribas! thats easier to understand
10:44:53 <kuribas> ronbrz: I should swap y and s
10:45:00 <kuribas> since s is state
10:49:23 <neonfuz> what do people generally do if they have really long type declarations
10:49:40 <neonfuz> like, do they keep them long? line wrap to a certain column count?
10:49:47 <quchen_> Wrap at ->
10:49:54 <neonfuz> k
10:49:56 <Lokathor> some parts, if repeated often, can be given a type alias
10:49:58 <neonfuz> for every argument?
10:50:09 <neonfuz> Lokathor: yeah I think I might do this
10:50:44 <neonfuz> I'm writing a type declaration for a Data.Map, and I have to repeat the key and value type a lot, I wish I could just say the key and value types and let it fill things in
10:51:29 <kuribas> neonfuz: linewrap and use type synonyms.
10:51:40 <Lokathor> type PMap = Map Location Creature -- something like this maybe
10:51:59 <quchen_> neonfuz: https://github.com/quchen/stgi/blob/master/test/Testsuite/Test/Machine/Evaluate/TestTemplates/MarshalledValue.hs#L124
10:53:35 <EvanR> if its really bad i use 1 rgument type per line
10:56:36 <coleman> Any examples of a keeping history of an exponentially recursive tree in haskell?
10:56:45 <coleman> asked this last night but had to go to dinner
10:56:48 <lyxia> coleman: what's that
10:57:02 <lyxia> how is a tree "exponentially recursive"
10:57:14 <coleman> lyxia: say I have a list [1,2,3], and I want to do something to each element over and over
10:57:29 <coleman> lyxia: so it becomes [[11,22,33], [21,22,23]]
10:57:48 <coleman> lyxia: then [[[111,222,333], [11 ... etc
10:57:59 <coleman> lyxia: I want to keep track of each "step"
10:58:07 <coleman> lyxia: but it's obviously not linear
10:59:21 <lyxia> I don't quite see what you consider to be a step
11:00:58 <orion> Hey, does anyone know why, when I specify __attribute__((visibility ("hidden"))) on some C bits, the function is visible via readelf?
11:01:02 <orion> On GHC 8.0.1
11:01:10 <coleman> lyxia: say that each time it loops it turns the array into an array of arrays, and then an array of arrays of array
11:02:02 <coleman> lyxia: and each time it does that, each item in the array has a name "I am bob" and a number `1`. I want to be able to traverse the tree backwards and see [1 "i am bob", 2 "i am joe"] etc.
11:02:10 <coleman> lyxia: following a branch of the tree back to the root
11:02:46 <ania123> \join latex
11:03:17 <kuribas> coleman: you want a tree datatype
11:03:22 <kuribas> not a list
11:03:46 <coleman> kuribas: yeah. is there a good example of recursively constructing a tree and then tracing it back from a single leaf to the root?
11:04:06 <coleman> not a binary tree btw!
11:04:45 <kuribas> https://en.wikipedia.org/wiki/Rose_tree
11:05:33 <coleman> kuribas: read that last night. didn't find it too helpful unforunately. LYAH has nothing on rose trees it seems
11:07:40 <sbrg> coleman: I think you could get a zipper to work, if the problem is traversing from a leaf to the root
11:08:43 <coleman> sbrg: I need a zipper rose tree example I think
11:08:44 <coleman> seems uncommon ?
11:09:07 <kuribas> coleman: or a comonad
11:14:12 <lyxia> the zipper package might be useful here but the API looks quite nonexpert-unfriendly.
11:14:12 <lyxia> well you can always define your own zipper from scratch
11:20:23 <EvanR> which doesnt imply expert friendly!
11:28:45 <kuribas> is it possible to unhide a package from ghci?
11:28:47 <nitrix> Can I declare multiple type aliases on the same line?
11:28:47 <nitrix> type Row, Column = Int ?
11:28:48 <nitrix> I guess one could suggest to make a tuple type, but I have various fields like that. A more interesting case is type StartOffset, EndOffset = (Row, Column) -- where I'd want both to be that tuple.
11:28:48 <lyxia> type Row = Int ; type Column = Int  is the best you can do
11:28:48 <EvanR> nitrix: nope. i just checked on GHCI :D
11:28:48 <nitrix> lyxia: I see. Thanks.
11:28:48 <lyxia> Or invoke Template Haskell.
11:30:21 <EvanR> didnt know you could do type synonyms in ghci
11:30:25 <EvanR> i wonder what else it can do now
11:30:49 <EvanR> :make-dinner
11:31:53 <kuribas> I want to test my library in ghci, but emacs insists on only loading packages from cabal.
11:33:13 <kuribas> I prefer not to mess up my cabal just to test things.
11:35:27 <lyxia> coleman: Were you looking for soomething like that http://lpaste.net/327696
11:35:29 <kuribas> :m +Hexdump Could not find module ‘Hexdump’ It is a member of the hidden package ‘pretty-hex-1.0@pretty-hex-1.0-BVTw9j72jpaIPNqTZKIvEW’.  Perhaps you need to add ‘pretty-hex’ to the build-depends in your .cabal file.
11:35:48 <kuribas> I don't want to only for testing!
11:39:48 <Cale> kuribas: Add it to the build-depends for your test suite...
11:41:00 <kuribas> Cale: good idea, thanks
11:50:45 <zipper> Does ghci in emacs `haskell-process-load-file` open in a whole new buffer almost like a whole new window?
11:52:12 <zipper> and do you like this instead of it opening in a split screen?
11:57:45 <kuribas> zipper: I use C-c C-l
11:57:58 <kuribas> zipper: it loads the current buffer in a new buffer
11:59:36 <zipper> Yeah I feel that it should split the screen and put the repl there.
11:59:40 <zipper> kuribas: ^
12:00:49 <kuribas> zipper: you can split with C-x 2
12:02:17 <geekosaur> or C-x 3 depending on whether you want vertical or horizontal split
12:03:06 <OccupiedAnon> Yooo
12:03:07 <geekosaur> or split and select buffer is C-x 4 b or C-x 5 b
12:07:13 <zipper> Well I just want it to be automatic which is what I think spacemacs does.
12:07:14 <zipper> No biggie I'll find a way
12:12:52 <kuribas> zipper: define your own in elisp
12:17:29 <zipper> kuribas: Well I will have to.
12:27:48 <EvanR> how do you open a file for reading, and get "socket-like" behavior , some other program is writing to it with append mode, and you are blocked waiting for it at the "end" of the file, like tail -f
12:28:44 <joe9> using a Socket.IO.handle hGet?
12:29:09 <chnli> Is learning Oz from "Concepts, Techniques and models of Computer Programming" worthwhile?
12:30:05 <joe9> I think tail -f uses inotify though.
12:30:06 <EvanR> inotify didnt always exist though
12:30:06 <joe9> EvanR: https://gist.github.com/eb0abb8e4da4dd0b609f5fc72052a975
12:31:08 <geekosaur> joe9, maybe modern takes do. older ones just did sleep(1) and a nonblocking read
12:31:08 <geekosaur> in a loop
12:31:35 <dfeuer> Anyone have an opinion about my proposal to add pattern synonyms and a non-dependent eliminator to Numeric.Natural?
12:31:45 <joe9> geekosaur: I think read blocks waiting for input.
12:32:28 <EvanR> so non-blocking reads have this behavior?
12:32:28 <EvanR> when you get to the end of file, its EOF
12:32:48 <EvanR> not like a socket
12:32:49 <joe9> EvanR: the C code I wrote there is blocking
12:32:52 <geekosaur> by default it does. but see O_NONBLOCK
12:32:56 <geekosaur> EOF is read producing 0. nonblocking read produces -1 with errno == EAGAIN
12:33:04 <geekosaur> if no data is available
12:33:50 <lpsmith> recent versions of tail -f on linux use inotify,  past versions used polling
12:34:23 <geekosaur> sockets are the same, except you usually use select or poll to check for data (ghc's runtime usually does this for you, so you do a "blocking" read in a thread which causes the runtime to deschedule your thread until the file descriptor is flagged as read data available by select/poll/epoll/whatever)
12:34:42 <lpsmith> EvanR, if you read from a file and get an EOF,  you can keep retrying the read every say,  once a second or whatever,  and it'll eventually return more information (assuming the file is appended to.)
12:35:36 <geekosaur> (see threadWaitRead)
12:35:54 <lpsmith> threadWaitRead doesn't really work in this case though.
12:36:01 <lpsmith> You do need inotify or polling
12:36:14 <lpsmith> threadWaitRead works on sockets fine, but not files.
12:36:42 <geekosaur> yeh, that's why tail doesn't use select/poll
12:36:57 <geekosaur> files always return data available
12:37:18 <lpsmith> I wrote this to implement tail -f like functionality in Haskell:  https://hackage.haskell.org/package/linux-inotify
12:37:43 <lpsmith> (And incidentally,  it does use threadWaitReadSTM under the hood,  but on the inotify fd)
12:37:55 <EvanR> nice
12:37:56 <EvanR> do we have O_NONBLOCK in haskell
12:37:56 <EvanR> lpsmith: oh really?
12:37:56 <EvanR> nvm then
12:38:38 <geekosaur> anyway if you don't want to use inotify or etc., I think you want hGetNonBlocking from bytestream
12:40:30 <geekosaur> er bytestring
12:40:46 <EvanR> the blocking version wont work?
12:41:25 <geekosaur> if this is a file, no, because as already mentioned the mechanism the runtime uses to block doesn't work on files, only sockets/pipes
12:41:38 <geekosaur> it always returns "ready" for files
12:41:57 <geekosaur> so you need to do it manually, either with inotify or with a sleep/nonblocking read loop
12:48:42 <EvanR> yeah i really like inotify
12:49:58 * geekosaur really wishes kernels would come up with a way to use polling with ordinary files. useful for (a) network filesystems, where there might well be a delay (b) checking for new data, as here.
12:50:17 <lpsmith> EvanR, this is one thing I did with linux-inotify:  https://gist.github.com/lpsmith/10625b629fbf7dd1afbd
12:50:39 <lpsmith> It's like tail -f,  except it that it keeps watching a file after it's rotated
12:51:19 <lpsmith> It's not guaranteed to fully read everything out of log file after rotation,  depending on the exact rotation mechanism used.  
12:51:49 <geekosaur> (you know about gnu tail -F, right?)
12:51:53 <lpsmith> It worked for me,  because the rotation mechanism being used in it's use case guaranteed that a file wouldn't be written to after it was moved.
12:52:26 <joe9> 9pfs does that I think.
12:53:05 <lpsmith> geekosaur, thanks for pointing that out.  Yeah,  that gist should be roughly comparable to tail -F then
12:53:36 <EvanR> tail -F also on OSX
12:57:32 <EvanR> the context is, theres apparently new craze in "shipping" logs in addition to rotating them locally
12:57:54 <EvanR> logs are uploaded somewhere in semi real time as they are written
12:58:34 <pie_> do you guys know any (non-java) decompilers written in haskell?
13:01:35 <EvanR> heres another related question
13:02:19 <EvanR> youre tail -f or tail -Fing a file, then you ctrl C or crash. you want to restart but dont want to start at the beginning or at the end like tail -f does
13:02:26 <EvanR> but around where you left off
13:02:33 <EvanR> whats the whiz bang way to do that
13:03:04 <geekosaur> you need to track the current file offset, and restart reading there.
13:03:23 <EvanR> ;_;
13:03:31 <geekosaur> tail doesn't track the file offset for you although you can use /proc or lsof to grab it, then use tail -nXXXcF
13:03:46 <geekosaur> erll, probably not combined like that
13:04:03 <geekosaur> tail -nOFFSETc -F
13:04:40 <geekosaur> in Haskell this should be hGetPos / hSetPos
13:04:53 <EvanR> per line should work
13:05:35 <EvanR> saving this number somewhere between runs, uhg, ok
13:05:54 <geekosaur> mrrr. haskell lib is being pedantic about fgetpos :/
13:05:54 <younder> Haskell can compile via C any way to 'hack' it to use openml or openacc? 
13:06:10 <geekosaur> younder, ghc has not compiled to C in years
13:06:27 <HelgeS> Has Haskell changed in the last 8 years or so? I try to run examples in a book from 2008, and it fails in GHCI 7.6.3. The book is "Real World Haskell"
13:06:29 <xa0> does C-- count?
13:06:49 <younder> geekosaur, I doesn't per default or it CANT?
13:06:51 <geekosaur> -fvia-C was accepted but treated as -fasm until recently (( think 7.10)
13:06:52 <monochrom> yes, Haskell change in the last 8 years
13:06:56 <geekosaur> *can't*
13:07:08 <younder> ah
13:07:41 <geekosaur> and even when it "did", it didn't quite actually do so; it could generate C code that did not actually work as it was, you had to use a compiler to produce assembly code and then run a horrible Perl script (the "evil mangler") to patch the assembly code so it would work
13:07:47 <EvanR> 2008 was eight years ago... time is slipping
13:08:03 <tdammers> HelgeS: yes, RWH is considered outdated, in the sense that the examples won't compile on recent GHC
13:08:26 <geekosaur> RWH was outdated when it hit the bookstores, they had already replaced exceptions
13:08:29 <monochrom> soon, 2009 will be nine years old, too
13:08:39 <EvanR> 2010, 10
13:08:40 <HelgeS> tdammers: I like the book, but it's too bad that the exampels don't compile
13:08:47 <EvanR> the pattern continues, quadratically
13:08:52 <geekosaur> haskell moves *fast*
13:08:55 <tdammers> I'd still recommend reading it though, I found it extremely useful
13:09:12 <HelgeS> What is a good book, that can replace RWH?
13:09:43 <younder> tdammers, Actually I found finding out why the examples didn't workaand fixin them educational.
13:10:18 <HelgeS> younder: agree. but it's also frustrating
13:10:22 <younder> tdammers,  At the time though it inspired some harsh language.
13:10:24 <tdammers> helped me make the mental leap between the theory and practical applications
13:10:24 <tdammers> that, too
13:10:24 <tdammers> also, asking questions about the examples here and being told how we do things nowadays
13:10:36 <tdammers> I have no doubts
13:11:02 <tdammers> that's just the nature of a language like Haskell - lots of strong opinions, and I think that's a good thing
13:11:04 <geekosaur> EvanR, anyway apparently you want hSeek and hTell
13:11:34 <geekosaur> this is not entirely portable windows/unix but will work as long as you aren't switching OSes at the same time you restart reading :)
13:11:36 <EvanR> if i was piping tail to haskell stdin... that might not work
13:11:49 <geekosaur> you can't sanely restart in that case anyway
13:11:49 <EvanR> im assuming linux
13:12:04 <EvanR> i cant?
13:12:10 <younder> I do find that having a laguage that changes under you feet is a hassle. Espesially for libraries. Having to use 5 compiler versions to compile a program is a bit perverse.
13:12:32 <tdammers> I don't think it has ever been that bad
13:12:43 <geekosaur> younder, stay away from go then. they ship a program to upgrade your existing source code with each new release :)
13:12:54 <geekosaur> makes haskell change look glacial by comparison
13:13:19 <tdammers> "move things and breakfast" or some such
13:13:38 <younder> geekosaur, Yes, luckelly I found 'Stack' which helps.
13:14:12 <geekosaur> EvanR, depends n what you are doing, but if one end of a pipe goes away you lose what was in the pipe buffer.
13:14:52 <EvanR> if i dont see it, i dont record where i was
13:14:54 <geekosaur> well, if the read end goes away whatever the writer had gotten into the buffer will be lost, and the writer won't easily be able to tell how much that was when it gets the SIGPIPE or EPIPE
13:17:43 <EvanR> i mean, worst case i begin some distance back
13:17:43 <EvanR> idempotency to the rescue
13:17:43 <EvanR> restarting from the beignning would be pretty bad though
13:21:23 <HelgeS> A bit of code from RealWorldHaskell, ch 16, that doesn't compile. Is it because the types have changed since the book was written?
13:21:23 <HelgeS> import Control.Applicative
13:21:24 <HelgeS> import Control.Monad (MonadPlus(..), ap)
13:21:24 <HelgeS> import Text.ParserCombinators.Parsec hiding (many, optional, (<|>))
13:21:24 <HelgeS> instance Applicative (GenParser s a) where
13:21:24 <HelgeS>     pure  = return
13:21:24 <HelgeS>     (<*>) = ap
13:22:26 <HelgeS> It says: Illegal instance declaration for `Applicative (GenParser s a)'
13:22:26 <HelgeS>       (All instance types must be of the form (T t1 ... tn)
13:22:26 <HelgeS>        where T is not a synonym.
13:22:37 <HelgeS> and I'm lost
13:22:50 <glguy> HelgeS: There should be an error message that says why it didn't compile
13:22:50 <dolio> Haskell change is glacial. We're just now getting to fixing `fail` after almost 20 years.
13:22:50 <nitrix> Does Aeson gives us a nice way to do object manipulation, like append a new Pair to an existing Object?
13:23:25 <nitrix> Or do I have to manually insert to their type Object = HashMap Text Value ?
13:23:29 <EvanR> nitrix: Value has operations like that
13:25:03 <glguy> HelgeS: OK, then the problem is that GenParser is a type synonym and you can't make type class instances for type synonyms
13:25:04 <EvanR> (:=) operator maybe
13:25:27 <jedai> HelgeS: GenParser was probably not a synonym when the book was written. This is not a change in Haskell per se but rather in a library. One that shouldn't pose problem to almost every user of it but happens to conflict here
13:25:29 <HelgeS> glguy: I've cited most of the error message. Is it OK to post the whole source file (7 lines) and ghci response here?
13:25:37 <glguy> no, you can use a pastebin for that
13:25:42 <glguy> http://lpaste.net
13:26:33 <jedai> HelgeS: but I thought there was a GHC extension that allowed to define such type class instances, it should be proposed in the error message
13:26:35 <glguy> HelgeS: In this case you can delete those two typeclass instances, they are not necessary
13:26:36 <EvanR> nitrix: hmm, object :: [Pair] -> Value is all i see
13:26:55 <glguy> jedai: Yes, but that's only going to lead to a new error message about the instance already existing
13:27:25 <jedai> HelgeS: Also, most thing now already have an Applicative instance even if they didn't when RWH was written
13:27:26 <HelgeS> jedai: yes, there is a proposal. But maybe it's better to write the code differently. I 
13:27:30 <glguy> Even better is to not try to make the instance of a type synonym and to check what the underlying type is and to add an instance on that , or in this case to learn that it already has one
13:27:34 <jedai> glguy: Right :)
13:28:17 <coleman> lyxia: I think I can just use Data.Map. Instead of following the tree all the way back, I can just create key value pairs and lookup the keys as values.
13:28:17 <coleman> lyxia: I was not thinking properly
13:28:17 <geekosaur> @paste
13:28:17 <geekosaur> HelgeS, the Text.ParserCombinators.Parsec import gives away that it was expecting parsec 2. parsec 3 was generalized to support more than just [Char], and GenParser became a type synonym
13:28:17 <geekosaur> (parsec 3 also uses Text.Parsec as the module root, with the old one supported for backward compatibility)
13:28:17 <lambdabot> Haskell pastebin: http://lpaste.net/
13:28:25 <HelgeS> In this case, making (GenParser s a) an intance of Applicative is not needed?
13:29:06 <HelgeS> parsec 2 and parsec 3, what are they? 
13:29:14 <nitrix> EvanR: That's sad. Imagine how nice it'd be to be able to add/remove fields before sending a response, without having it part of a data type!
13:29:19 <glguy> http://hackage.haskell.org/package/parsec-3.1.11
13:29:51 <EvanR> nitrix: well, HM.insert and HM.delete are pretty easy
13:29:54 <HelgeS> I assume my haskell compiler ghci has one of the two parsec implementations.
13:29:55 <EvanR> aeson lens exists
13:30:35 <EvanR> nitrix: but on the topic of, wouldnt it be nice to mess with intermediate values in a pipe line with adhoc code....
13:30:46 <c_wraith> aeson lens uses enough classes to appear magic in practice. 
13:30:47 <tdammers> HelgeS: don't worry about parsec 2, just use 3. Or megaparsec, even.
13:30:48 <EvanR> ruby is that way ;)
13:32:06 <EvanR> aeson kind of wants you to think of json as the assembly language and do all your work in haskell types
13:32:07 <geekosaur> HelgeS, it didn't throw an error on the import, so you have parsec installed. It will be parsec 3, because parsec 3 replaced parsec 2 (and megaparsec is in the process of replacing parsec 3)
13:33:11 * hackagebot lua-bc 0.1.0.2 - Lua bytecode parser  https://hackage.haskell.org/package/lua-bc-0.1.0.2 (EricMertens)
13:33:14 <geekosaur> we need an updated RWH, with authors who don't ride off into the sunset (or at least don't turn into people who only post sunsets! :p )
13:34:42 <geekosaur> parsec 3 added an ad hoc Applicative instance, among many other things. megaparsec replaced that with a standard instance, among many other things
13:34:49 <ania123> can one tell me an ilustrative application of map, foldr and filter functions?
13:36:07 <jedai> ania123: they're pretty much bog standard functions, serving very basic needs,for instance map allows to produce a new list by applying a function to all elements of an old list :
13:36:21 <jedai> > map (*5) [1..10]
13:36:25 <dolio> What's an ad hoc Applicative instance?
13:36:26 <lambdabot>  [5,10,15,20,25,30,35,40,45,50]
13:37:05 <ania123> jedai: it is clear, but I need some small programs to show usefulness of it...
13:37:28 <jedai> jedai: oh you want complete programs using each function ?
13:40:17 <geekosaur> dolio, speaking very loosely. instead of an actual Applicative instance, it implemented its own versions of the Applicative methods
13:40:17 <geekosaur> one of the more facepalm-y aspects of parsec that led to megaparsec being forked >.>
13:40:19 <EvanR> showing how map is useful is kind of like showing how matrix addition is useful
13:40:20 <EvanR> if its not obvious, what do you say
13:40:20 <c_wraith> map is useful if you have a list of something and want to transform every element in the list. 
13:40:20 <c_wraith> that's like 40% of for loop uses in C
13:40:20 <c_wraith> (folds are about another 40%)
13:40:31 <HelgeS> geekosaur: You say "the Text.ParserCombinators.Parsec import gives away that it was expecting parsec 2". How to you see that?
13:40:52 <geekosaur> because, as I said earlier, parsec 3 prefers Text.Parsec
13:41:02 <HelgeS> geekosaur: Aha!
13:41:02 <geekosaur> the old name is used only for parsec 2 backward compatibility
13:41:55 <ania123> what about foldr
13:42:30 <lyxia> > foldr max 0 [10, 24, 35, 22]
13:42:33 <lambdabot>  35
13:42:46 <c_wraith> foldr is kind of "any generic list processing algorithm that hits every element once" 
13:43:15 <glguy> geekosaur: They probably should have waited to release parsec until after Applicative existed
13:43:20 <ania123> it is clear, but I need an example which I will implement using foldr
13:43:21 <c_wraith> lyxia, that's kind of a bad example. foldl' is much better there. 
13:44:21 <EvanR> foldr is good for producing fold results lazily
13:44:33 <EvanR> for a long list or infinite list
13:44:55 <jedai> Right, canonical examples are or() and and()
13:45:00 <nshepperd1> Does parsec not re-export the applicative / alternative methods now?
13:45:13 <c_wraith> :t \p -> foldr (\c r -> if p c then c : r else []) [] 
13:45:15 <lambdabot> Foldable t => (a -> Bool) -> t a -> [a]
13:45:29 <jedai> > foldr (&&) (False : repeat True)
13:45:30 <c_wraith> that's my favorite demo of lazy foldr
13:45:32 <lambdabot>  error:
13:45:32 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Bool]’
13:45:32 <lambdabot>      • In the second argument of ‘foldr’, namely ‘(False : repeat True)’
13:45:43 <jedai> > foldr (&&) True (False : repeat True)
13:45:45 <lambdabot>  False
13:46:33 <c_wraith> err. oops. type checked, but wasn't what I meant. oh well. 
13:46:38 <jedai> c_wraith: so takeWhile ?
13:48:35 <c_wraith> :t \p -> foldr (\c r -> if p c && null r then [] else c:r) [] 
13:48:35 <lambdabot> Foldable t => (a -> Bool) -> t a -> [a]
13:49:46 <coleman> why would this pattern match be non-exhaustive? http://lpaste.net/327960
13:50:04 <c_wraith> there. reversed the meaning of the predicate, but now it's what I meant. 
13:50:04 <EvanR> folds that produce lists are weird...
13:50:05 <c_wraith> jedai, now it's dropWhileEnd
13:50:24 <glguy> coleman: GHC will give you examples of patterns you forgot to handle
13:50:33 <jle`> coleman: ghc should give you why
13:50:37 <MarcelineVQ> EvanR: prefer to keep your producing to unfolds? :>
13:50:38 <jedai> coleman: go doesn't handle the case where props or rules are empty
13:50:38 <c_wraith> coleman, because dni and dne are different names
13:50:48 <jle`> coleman: post the compiler error and we'll show you where it tells you :)
13:51:17 <glguy> You can turn on the messages with -Wincomplete-patterns in particular or -Wall in general
13:51:20 <coleman> jle`: it compiles, it won't run
13:51:28 <jle`> oh
13:51:32 <jle`> oh yeah, forgot that you need to turn on warnings
13:51:37 <jle`> compile with -Wall :)
13:51:38 <coleman> glguy: whoa cool flag!
13:51:40 <c_wraith> coleman, in other words, you have at least 3 non-exhaustive patterns in there. 
13:51:45 <EvanR> MarcelineVQ: right...
13:52:18 <dmwit> c_wraith: Judging by `rules = [dne, dni]`, I suspect the two different names are intentional.
13:52:57 <jedai> coleman: dne pattern is wery clearly incomplete too (I hope you knew that)
13:53:10 <jle`> but yeah, it's a good habit to develop with -Wall on
13:53:22 <jle`> except now in ghc-8 the redundant constraints warnings are annoying
13:53:24 <coleman> jedai: right
13:53:36 <coleman> I see the problem in dni/dne.
13:53:39 <coleman> don't see the problem in `go`
13:53:51 <jle`> coleman: compile with -Wall :)
13:53:59 <jedai> coleman: (p:ps) and (r:rs) can't match empty lists
13:54:03 <c_wraith> dmwit, I'm not actually sure of that. my read is that those were intended to be two cats of one function - double negation elimination 
13:54:17 <c_wraith> *two cases
13:54:27 <coleman> http://lpaste.net/327971
13:54:37 <dmwit> c_wraith: I bet `dni` is double negation introduction.
13:54:37 <glguy> I'd guess double-elimination elimination and double-negation introduction from dne and dni
13:54:53 <coleman> c_wraith: right
13:54:57 <c_wraith> oh, I see.
13:55:14 <geekosaur> coleman, yes, it is telling you the first and second patterns respectively do not match empty listd
13:55:17 <geekosaur> *lists
13:56:07 <coleman> ah I see
13:56:07 <geekosaur> because you specified them as (p:ps) (r:rs)
13:56:07 <geekosaur> which are nonempty
13:56:43 <coleman> geekosaur: ah
13:56:58 <dmwit> So, I feel like this is a common misconception: that the compiler somehow needs help to know that a pattern is supposed to a match a value whose type is a list. There are many questions on SO that go "I wrote `f [x] = sum x` and it didn't work, why not?". This seems like a variant: you don't need to write `x:xs` for the compiler to know something is a list; that specifically matches lists with at least one element.
14:01:18 <coleman> I guess I don't expect there every to be an empty list here.
14:01:18 <coleman> p and r should alwasy be the case here
14:01:18 <coleman> next can be empty
14:01:18 <coleman> if I never pass an empty list, will it still throw an error?
14:01:39 <jedai> coleman: Also prove (and go) have a fundamental flaw right now : they make no allowance for the fact they may fail to prove... 
14:01:59 <coleman> jedai: that I'm aware of :-)
14:02:21 <jedai> coleman: No it won't but if it doesn't run... it's probably because that does happen
14:02:32 <coleman> jedai: but they'll go infinitely and I'll put a cap on how deep it can get
14:02:48 <dmwit> coleman: If your base case is single-element lists, that's fine. But good style would be to make that apparent in the patterns rather than using guards.
14:02:55 <jedai> coleman: there's also the possibility that simply your dne is the one with a problem
14:03:07 <dmwit> coleman: e.g. `foo [x] ys = ...; foo xs [y] = ...; foo (x:xs) (y:ys) = ...`
14:03:36 <dmwit> coleman: I would offer more careful advice except that I closed the window with your code in it and now lpaste appears to be down for maintenance. =P
14:03:52 <jedai> coleman: or rather your "rules" shouldn't produce an Expr, they should produce a "Maybe Expr" because there are times some (like dne) may fail to match
14:04:28 <coleman> jedai: right, okay
14:04:40 <coleman> Maybe is probably what I was looking for there
14:04:51 <coleman> Right now I'm just trying to get it to recur
14:05:51 <jedai> coleman: it probably does but fail in one of the recursion due to one of the problems pointed
14:06:39 <jedai> coleman: you could add some tracing (see Debug.Trace) to see what it is starting to do (or use the debugger in ghci maybe)
14:07:17 <coleman> jedai: debugging rn
14:12:02 <EvanR> lets say youre writing a haskell program that waits for file system events and reacts somehow... how do you write a test for that behavior?
14:12:53 <EvanR> how it reacts could be isolated and simulated internally, then tested with quickcheck
14:13:09 <EvanR> but the actual functionality of the IO...
14:13:46 <coleman> jedai: know of anything like this which already exists?
14:13:46 <coleman> doing derivations?
14:14:11 <jedai> coleman: Coq ?
14:14:23 <jedai> coleman: in Haskell or generally ?
14:15:43 <coleman> jedai: generally
14:16:15 <jedai> Well then Coq I guess ? I'm not really sure what you want from it though
14:16:54 <coleman> jedai: I guess something programmable rather than a GUI. A library that can do this sort of stuff
14:16:58 <jedai> Coq is the leader in this category I think (though there's a lot of competitors, some dead, some still alive, some zombies, with diverse end goal)
14:16:59 <dmwit> coleman: What is "this"? What does it mean to "do" a derivation?
14:17:38 <coleman> dmwit: proving truth-functional theorems
14:17:55 <dmwit> Yes, there are several theorem provers out there.
14:18:13 <dmwit> Djinn and exference are particularly dear to us Haskell folks.
14:18:21 <dmwit> ?djinn (a -> b) -> a -> b
14:18:22 <lambdabot> f a = a
14:18:40 <dmwit> You might also like searching on the term "program synthesis" which is related but not identical.
14:19:12 <dmwit> "Proof search" is another good search term.
14:19:53 <jedai> coleman: Coq is really good, though not Haskell (its OCaml I think, which is another functional language, pretty interesting but less pure than Haskell)
14:20:00 <dmwit> ?djinn a -> Not (Not a)
14:20:00 <lambdabot> f a b = b a
14:20:56 <dmwit> jedai: Coq is good at checking proofs, but wasn't really designed with generating proofs in mind. (Arguably tactics are a sort of human-directed proof search, perhaps.)
14:21:38 <coleman> dmwit: does djinn have any docs?
14:21:57 <jedai> dmwit: Right, though generating Proofs without indications (tactics), except for trivial cases, is really not feasible right now
14:22:23 <dmwit> ?where djinn
14:22:24 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
14:23:32 <dmwit> Hm.
14:23:44 <coleman> whoops
14:23:48 <dmwit> The full docs appear to be "Djinn uses a decision procedure for intuitionistic
14:23:48 <dmwit> propositional calculus due to Roy Dyckhoff.  It's a variation of
14:23:48 <dmwit> Gentzen's LJ system.  This means that (in theory) Djinn will always
14:23:48 <dmwit> find a function if one exists, and if one doesn't exist Djinn will
14:23:48 <jedai> https://github.com/augustss/djinn/blob/master/src/Help.hs
14:24:04 <dmwit> terminate telling you so." (sorry for the multiline paste, that was unintentional)
14:24:55 <jedai> the easiest is probably to compile the command line and ask its help (because the source I posted is not really nice to read
14:26:25 <jedai> there's also a paper https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf but it's old and not directly relevant to djinn use (but rather how it does its job)
14:31:17 <EvanR> vim #bash
14:31:20 <EvanR> er
14:31:37 * Clint inches away.
14:32:26 <APic> *shrug*
14:32:30 <APic> emacs #zsh
14:33:10 * hexagoxel centimeters the other direction
14:34:53 <dmwit> > vim #bash
14:34:56 <lambdabot>  error:
14:34:56 <lambdabot>      Ambiguous occurrence ‘#’
14:34:56 <lambdabot>      It could refer to either ‘Lens.#’,
14:35:16 <dmwit> So much for that joke.
14:35:29 <jedai> but vim is defined ??!
14:39:13 <tdammers> :t vim
14:39:14 <lambdabot> [Char]
14:39:17 <tdammers> apparently
14:39:24 <pikajude> > vim
14:39:27 <lambdabot>  "good"
14:39:37 <pikajude> ok.
14:39:40 <jedai> > emacs
14:39:42 <lambdabot>  error: Variable not in scope: emacs
14:39:47 <jedai> ...
14:39:48 <Tuplanolla> Those quotes are appropriate.
14:40:00 <dmwit> Huh, this is fun:
14:40:11 <dfeuer> Hi dmwit.
14:40:12 <dmwit> > let x ## y = x + y in 3 ## 4 -- works fine
14:40:14 <yolanda__> Ha! Excellent!
14:40:15 <lambdabot>  7
14:40:22 <dmwit> > let x ## y = x + y in (##) 3 4 -- noooope
14:40:25 <lambdabot>  error:
14:40:26 <lambdabot>      • Couldn't match expected type ‘Integer -> Integer -> t’
14:40:26 <lambdabot>                    with actual type ‘(# #)’
14:40:26 <dmwit> dfeuer: hi!
14:40:29 <yolanda__> Welcome lower than average Police of the world :)
14:40:36 <yolanda__> I'm 'begat' from N.A.
14:41:13 <yolanda__> And, entirely the 'guy' you want to 'marry' your bothersome daughter from Oxford/Harvard/Brown.
14:41:22 <jedai> That's pretty strange... a MagicHash side effect probably (# #) seems to be a hash unit ?
14:41:24 <yolanda__> cause, This is Precisely! how it is going to happen :)
14:41:28 --- mode: ChanServ set +o glguy
14:41:28 --- mode: glguy set +b *!*@86.99.23.247
14:41:28 --- kick: yolanda__ was kicked by glguy (offtopic)
14:41:44 <pikajude> :t (##)
14:41:46 <lambdabot> (# #)
14:41:49 <pikajude> why does that exist
14:41:58 <amalloy> dmwit: works fine outside of lambdabot of course
14:42:01 <glguy> unboxed empty tuple
14:42:11 <dmwit> amalloy: I expect it is as jedai says, a MagicHash thing.
14:42:28 <pikajude> but you could just have an unboxed 1-tuple, containing an unboxed 1-tuple, containing a--wait a minute
14:42:35 <jedai> So all size of unboxed tuple exists , including the size 0 ? And size 1 ?
14:42:47 <jedai> :t (# 2 #)
14:42:48 <lambdabot> Num t => (# t #)
14:42:52 <glguy> No, it's not MagicHash, it's UnboxedTuples
14:47:05 --- mode: glguy set -o glguy
14:49:37 <yhhko> what is a neat way to represent a data type of the following form? its elements always have one Int, optionally a second Int, and if they have a second Int, optionally a third Int. so like x[:y[:z]].
14:49:44 <dfeuer> > case (# 3#, Nothing #) of (# 3#, Nothing #) -> 12
14:49:46 <lambdabot>  12
14:50:35 <sbrg> yhhko: sounds like NonEmpty lists
14:50:51 <jedai> yhhko: data OTT = One Int | Two Int Int | Three Int Int Int
14:51:01 <sbrg> oh, I assumed it continued
14:51:11 <yhhko> jedai: hm, that's not too bad
14:51:30 <yhhko> sbrg: yeah no it's max 3 ints :)
14:51:41 <byorgey> data OT a b = One a | Two a b    type OTT a = OT a (OT a a)
14:51:54 <dfeuer> case undefined of (# #) -> 3
14:51:59 <dfeuer> > case undefined of (# #) -> 3
14:52:01 <lambdabot>  mueval-core: GhcException "Error: bytecode compiler can't handle unboxed tup...
14:52:01 <lambdabot>  CallStack (from HasCallStack):
14:52:01 <lambdabot>    error, called at ./Mueval/Interpreter.hs:149:31 in main:Mueval.Interpreter
14:52:14 <yhhko> byorgey: but that continues right?
14:52:26 <yhhko> byorgey: that's just a nonempty list
14:52:31 <yhhko> ah no it's not :)
14:52:38 <byorgey> nope =)
14:52:48 <dfeuer> That's weird... It handled my unboxed pair but not my unboxed empty tuple?
14:52:59 <yhhko> hm, neat. but i think jedai's solution is better in practice :)
14:53:04 <yhhko> or easier, anyway
14:53:14 <yhhko> nice trick though
14:53:26 <dfeuer> Actually, it works if I use a real (# #) instead of undefined....
14:54:15 <Tuplanolla> Isn't the kind of `undefined`'s type `*`, dfeuer?
14:55:13 <yhhko> oh, you know what, internally i can just store the unspecified Ints as 0s. so I'm overcomplicating things.
14:55:47 <pikajude> what's the best way to take a user-generated string and try to figure out which timezone it represents?
14:56:05 <kadoban> pikajude: Is it in some standard format?
14:56:42 <pikajude> kadoban: no, this would be for a chatbot, basically
14:56:50 <dmwit> yhhko: Here's a bad way: (a, Maybe (a, Maybe a))
14:56:52 <pikajude> so I'd want to recognize "PST", "America/Los Angeles", and numeric inputs
14:57:00 <dfeuer> Tuplanolla, I would expect that these days it's probably polykinded like error. I'm not sure though.
14:57:02 <kadoban> pikajude: Ugh
14:57:03 <yhhko> dmwit: yeah i thought about that for a split second, and then I decided to ask here instead :P
14:57:42 <dmwit> yhhko++
14:57:44 <pikajude> to be honest, this problem is probably outside the scope of my chatbot
14:57:53 <pikajude> I'll just make it a standard format
14:58:15 <kirillow> https://gist.github.com/anonymous/2f7e98310d19ca521f716893e68e8da3 help? please?
14:58:25 <kadoban> pikajude: Seems slightly more sane. I would guess most users aren't going to specify a timezone either, maybe you can tell from their OS or browser capabilities, or whatever interface this has?
14:59:01 <dmwit> kirillow: Ah!
14:59:03 <pikajude> nah, I don't get any metadata from them
14:59:10 <dmwit> kirillow: You've discovered why the type of `myMaximumBy` is a lie.
14:59:20 <pikajude> I'll just have the bot direct them to some timezone calculator online, and then report which one it says
14:59:47 <Tuplanolla> I hope by standard you mean ISO 8601, pikajude.
14:59:51 <pikajude> interestingly, the Show instance for TimeZone shows conventional names a la "PST", but it's just a standard datatype with record fields
14:59:58 <kirillow> dmwit: que?
15:00:00 <kadoban> It'd be nice if timezones were more sane, then you could just ask them what time it currently is ... but that wouldn't work at all.
15:00:07 <pikajude> so does that mean the implementation of "show" is matching on every attribute of TimeZone?
15:00:14 <dmwit> kirillow: There are a couple directions to go from here. One is to change the return type to be, e.g., `Maybe a`. Another is to give an explicit case for empty lists (that throws an error) and use the first element of non-empty lists as the base case.
15:00:25 <pikajude> kadoban: I'm ok with being off for an hour
15:00:30 <dmwit> :t foldr1
15:00:32 <pikajude> off by* an hour
15:00:43 <dmwit> kirillow: There's also the *1 variants of the folds that you could look into.
15:01:15 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
15:01:33 <MarcelineVQ> lambdabot's quite slow today, I wonder if something is spamming it and causing the message queue to throttle
15:02:48 <EvanR> freenode is suffering from some lag i hear
15:02:59 <onintza> How could I do the equivalent to `foldl (>>=) (return ())` but with `>=>`?
15:03:39 <onintza> I mean, in a more compact way
15:03:55 <dmwit> :t foldl (>>=) (return ())
15:03:57 <lambdabot> (Foldable t, Monad m) => t (() -> m ()) -> m ()
15:04:22 <dmwit> Do you just want `sequence` instead? Do you really have `()`-consuming functions?
15:04:30 <onintza> :t foldl (>=>) ()
15:04:32 <lambdabot> error:
15:04:32 <lambdabot>     • Couldn't match expected type ‘a -> m b’ with actual type ‘()’
15:04:32 <lambdabot>     • In the second argument of ‘foldl’, namely ‘()’
15:04:43 <dmwit> :t foldl (>=>)
15:04:43 <onintza> :t foldl (>=>) [] ()
15:04:45 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t (b -> m b) -> a -> m b
15:04:45 <lambdabot> error:
15:04:45 <lambdabot>     • Couldn't match expected type ‘a -> m b’ with actual type ‘[t0]’
15:04:45 <lambdabot>     • In the second argument of ‘foldl’, namely ‘[]’
15:04:49 <pikajude> Maybe they do something different when encountering a very high value of ().
15:05:00 <dmwit> :t foldl (>=>) return
15:05:02 <lambdabot> (Foldable t, Monad m) => t (b -> m b) -> b -> m b
15:05:28 <onintza> Just what I need!
15:05:35 <onintza> Well, I don't really care about the result
15:06:11 <dmwit> pikajude: You can just look at the source... http://hackage.haskell.org/package/time-1.6.0.1/docs/src/Data.Time.LocalTime.TimeZone.html#line-71
15:06:14 <Tuplanolla> :t foldl (.) id -- Compare the previous to this, onintza.
15:06:16 <lambdabot> Foldable t => t (c -> c) -> c -> c
15:06:24 <pikajude> oh right, us haskellers have documentation
15:06:35 <jvanbure> If I use empty typeclasses to constrain the type arguments to things, will I be paying a runtime cost? Or is everything checked statically?
15:06:40 <jvanbure> See: http://pastebin.com/w5cMYYQa 
15:06:52 <pikajude> so it shows the timezone name, LOL
15:06:58 <jvanbure> Also, is there a more idiomatic way to do this...?
15:07:08 <dmwit> jvanbure: It's complicated. But generally empty typeclasses are not particularly useful.
15:08:12 <tangled_z> hi, i asked this on the happstack irc, but it seems to be a general haskell issue rather than happstack specifically
15:08:20 <tangled_z> I am trying to run the example on here: http://www.happstack.com/docs/crashcourse/src/AcidState/IxSet.hs
15:08:23 <dmwit> jvanbure: You might like http://stackoverflow.com/q/12645254/791604
15:08:43 <tangled_z> and it gives me an error when I try to define newtype PostId = PostId { unPostId :: Integer }
15:09:04 <tangled_z> (and if I edit the code to not include that line, it gives me a type error for all the other new type declarations)
15:09:11 <jvanbure> so is there a better way to accomplish what I'm trying to do?
15:09:27 <tangled_z> any suggestions?
15:09:35 <glguy> I'd suggest including the error message
15:10:04 <jvanbure> dmwit: Is it possible to specialize a constructor...?
15:10:06 <dmwit> jvanbure: You haven't said what you're trying to do.
15:10:14 <tangled_z> hs-example2.hs:34:46: error:     • Couldn't match type ‘Integer’ with ‘PostId’         arising from the coercion of the method ‘safecopy-0.9.1:Data.SafeCopy.SafeCopy.kind’           from type ‘safecopy-0.9.1:Data.SafeCopy.SafeCopy.Kind Integer’             to type ‘safecopy-0.9.1:Data.SafeCopy.SafeCopy.Kind PostId’     • When deriving the instance for (SafeCopy PostId)
15:10:21 <tangled_z> Oops, sorry for the garbled emssage. 
15:10:24 <alala> hello fellow humans
15:10:29 <alala> I am a human too
15:10:31 <tangled_z> "Couldn't match type ‘Integer’ with ‘PostId’   "
15:10:45 <alala> Goodbye fellow humans
15:10:45 <jvanbure> dmwit: I'm basicaly trying to constrain the way that I can compose constructors of the type
15:11:18 <jvanbure> my example paste isn't particularly clear about this...
15:11:41 <dmwit> I agree.
15:13:10 <geekosaur> tangled_z, my recollection is that the types in the safecopy package changed around 0.9
15:13:18 <kadoban> pikajude: Well, then depending on how much you care if it's wrong, you could just ask them what time it is. But it could be *very* wrong, especially if you use the value they give you for a long time.
15:13:19 <dfeuer> If Eisenberg has his way with instance chains and fundeps, I wouldn't be surprised to see methodless type classes gain in importance.
15:13:19 <jvanbure> dmwit: oh wait i was getting confused lol. I have two places I'm using this constrain thing and they're slightly different
15:13:26 <mmaruseacph2> I just managed to get criterior to return negative time for a benchmark :o
15:13:29 <tangled_z> geekosaur: ah, that's good insight. 
15:13:41 * dfeuer would love to see instance chains replace overlapping instances.
15:13:41 <pikajude> kadoban: Turns out the userbase doesn't really want this feature anyway
15:13:45 <kadoban> pikajude: But if you do that, keep in mind that not every timezone is off by integral numbers of hours, there's 1/2 hour ones, and probably more bizarre ones too.
15:13:53 <kadoban> Oh ya? Well that works then, haha.
15:14:01 <pikajude> Yeah, I was doing some premature optimization.
15:14:07 <tangled_z> geekosaur: would you by any chance know what I could do to fix this? 
15:14:08 <pikajude> The optimization was assuming the users would want this feature.
15:14:32 <jvanbure> dmwit: http://pastebin.com/sdvyGcwh is like my data type
15:14:37 <kadoban> I'd think a better optimization is assuming that users don't want any features. Then you can just go find the nearest couch and grab a beer on the way.
15:15:16 <pikajude> that's true.
15:15:22 <pikajude> and I can legally drink beer now, which is even better
15:15:37 <tangled_z> kadoban: what do you call this amazing development method? 
15:15:43 <geekosaur> tangled_z, try forcing use of safecopy-0.8.6
15:15:50 <kadoban> tangled_z: Being lazy as hell
15:16:00 <geekosaur> 0.9 has a lot more internals, presumably PostId is one of them
15:16:20 <geekosaur> 0.8's documentation doesn't even have an Internals module, and no mention of PostId that I can see
15:17:53 <tangled_z> geekosaur: thanks! will give it a try
15:18:37 <jvanbure> dmwit: maybe this is more clear? http://pastebin.com/hJuVAP4r
15:19:13 <tangled_z> geekosaur: ah, the happstack tutorial says this about PostId: " It is convenient to assign a unique id to each blog post so that it can be easily referenced in URLs and easily queried in the IxSet. In order to keep ourselves sane, we can create a newtype wrapper around an Integer instead of just using a nameless Integer."
15:19:15 <jvanbure> I'm mostly wondering if I'm paying any horiffic runtime costs anywhere.
15:19:28 <tangled_z> ^that's what it is, just a wrapper
15:19:46 <geekosaur> tangled_z, that makes sense. 0.8 didn't keep track of wrappers
15:20:37 <geekosaur> from what I see of its implementation vs. 0.9, 0.8 would have treated a newtype-d Integer as an Integer. 0.9 has stronger type machinery and would preserve the newtype, leading to your error if the code using it assumed safecopy still lost the newtype
15:20:52 <Zemyla> I was asked a question, and I'm not sure what the answer is: What are the downsides of the CPS StateT as opposed to lazy or strict StateT?
15:21:08 <tangled_z> geekosaur: ah that makes sense, thanks for the explanation! :) 
15:22:57 <kysee> Hello guys :)
15:23:46 <riuzaki> Hello
15:25:08 <kysee> I want to learn haskell, and i was wondering why? is more different than c,java,python?
15:27:35 <herzmeister> very
15:28:23 <riuzaki> haskell in spanish?
15:29:10 <tangled_z> geekosaur: erm, would you know how to use stack to force using an older version of a package?
15:29:52 <Koterpillar> tangled_z: extra_deps?
15:29:57 <geekosaur> tangled_z, https://docs.haskellstack.org/en/stable/yaml_configuration/#packages
15:30:44 <riuzaki> bot in telegram with haskell?
15:31:05 <geekosaur> sorry, yes, extra-dep is probably the part you need
15:31:12 <geekosaur> https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
15:31:17 <tangled_z> Ah thanks guys :) 
15:31:44 <tangled_z> safecopy 0.8.6 depends on older versions of other packages that I have, should I add them to extra-deps too?
15:31:50 <EvanR> read world haskell? https://github.com/evanrinehart/file-chewer-experiment/blob/master/Main.hs
15:59:47 <dmwit> jvanbure: The problem I have with your pastes is that they look like an attempt at describing a solution rather than an attempt at describing a problem.
16:00:39 <dmwit> jvanbure: Like, empty classes smell like an XY problem. I suspect you have a real code need that you're trying to fill, and empty classes were the idea you had about filling that need. But if you tell us more about the need, I suspect we'll suggest something completely different than empty classes.
16:01:12 <dmwit> jvanbure: So asking how to use empty classes sanely is a mistake. Instead, tell us about the program you're trying to write, and why that's hard.
16:03:19 * hackagebot hakyll-sass 0.2.2 - Hakyll SASS compiler over hsass  https://hackage.haskell.org/package/hakyll-sass-0.2.2 (meoblast001)
16:06:12 <dfeuer> jvanbure, much more useful:   data ThingTag a where {Thing1Tag :: ThingTag Thing1; Thing2Tag :: ThingTag Thing2}  class Thing1or2 a where thing1or2 :: ThingTag a     instance Thing1or2 Thing1 where thing1or2 = Thing1Tag     instance Thing1or2 Thing2 where thing1or2 = Thing2Tag    
16:06:29 <dfeuer> But then again, I can't actually say if that makes sense without more context.
16:06:46 <dfeuer> I guess that is probably completely unreadable.
16:06:56 <EvanR> agreed
16:07:51 <EvanR> lpaste ... down for maintance
16:10:19 <EvanR> http://codepad.org/ulnlgojF
16:11:24 <EvanR> and now you cant actually use these classes without proxies
16:11:47 <dfeuer> jvanbure, https://gist.github.com/treeowl/34ced14e67ffb420bd8e4ed8f93484e3
16:12:11 <dmwit> Let me assert once again that suggesting solutions before you know the problem is a mistake.
16:12:15 <dfeuer> EvanR, ah, I was too slow!
16:12:24 <dfeuer> dmwit is correct, of course.
16:12:56 <EvanR> the beauty of the types is its own justification!
16:13:52 <dfeuer> I think this is called the "universe" pattern.
16:14:37 <EvanR> it works much better with dependent types
16:15:41 <dfeuer> EvanR, how so?
16:16:42 <dfeuer> Oh, I guess you can skip the Tag type?
16:16:48 <dfeuer> And just pass the type itself?
16:16:55 <dfeuer> Wait, no, that doesn't work.
16:17:02 <dfeuer> What do you mean?
16:17:02 <EvanR> you dont need a class
16:17:21 <dfeuer> Why don't you need a class?
16:17:40 <dfeuer> (I mean, you don't need one in Haskell either; it's just potentially useful)
16:18:11 <EvanR> well, im now lost about what were actually trying to do
16:18:20 <dfeuer> We never actually knew that.
16:18:55 <EvanR> but you can create a type for labels, and then an assignment of labels to types
16:19:16 <EvanR> the rest would be based on a choice of labels and assignment
16:20:01 <EvanR> its a solution looking for a problem!
16:20:07 <dfeuer> EvanR, I'm not sure what you're getting at. Can you show what it would look like in Agda or Idris?
16:21:21 <dfeuer> BBIAB. Off to vote!
16:21:31 <EvanR> vote for me
16:21:42 <coleman> Got my code working but it's pretty ugly. Any way to clean it up? https://gist.github.com/JacksonGariety/b3ac405b19d5de62d893b161f82234b5
16:21:46 <coleman> (lpaste is down)
16:22:02 <coleman> Is the mixing of guards and pattern matching okay?
16:24:11 <dfeuer> coleman,  [res]++next is just res:next, but I have my doubts about this code actually doing what you want. Maybe you really want next++[res]?
16:24:33 <dfeuer> (I think you could get stuck in loops this way)
16:24:37 * dfeuer really should be gone.
16:24:39 <coleman> dfeuer: the order doesn't matter
16:25:03 <coleman> dfeuer: it will loop until it can find an answer. If there's no answer it will loop forever.
16:25:03 <dfeuer> OK. I may be misreading it. I just skimmed.
16:25:25 <coleman> dfeuer: no prob. I'm just concerned that it's not idiomatic or that I'm abusing pattern matching
16:25:45 <dfeuer> You should definitely use    res:next instead of [res]++next
16:25:53 <dfeuer> Pattern matching is great. 
16:26:04 <hexagoxel> dfeuer, EvanR: what does that construct provide that some simple sumtype definition does not?
16:26:06 <coleman> dfeuer: cool
16:26:25 <dfeuer> hexagoxel, matching on it gives you type information.
16:27:10 <erisco> pattern matching can be done in guards, it is a feature
16:27:28 <EvanR> dfeuer: yes, im writing a gist
16:28:21 <EvanR> hexagoxel: the different cases of a sum type arent different types, thats one thing
16:28:44 <coleman> dfeuer: wait... I pasted an old one
16:28:55 <erisco> this is where sums diverge from, say, variants
16:28:56 <coleman> dfeuer: https://gist.github.com/JacksonGariety/b3ac405b19d5de62d893b161f82234b5
16:29:31 <coleman> dfeuer: see the repetition of the (res:next) and `where res = `?
16:29:41 <coleman> dfeuer: that's gotta be bad style, right?
16:30:48 <erisco> nothing wrong with where blocks
16:31:32 <erisco> I don't see where res:next is repeated
16:32:09 <hexagoxel> well i have `data EitherThing12 = ET1 Thing1 | ET2 Thing2`, now i can require Thing1 or Thing2 or EitherThing12 in my signature. same level of type safety, same expressiveness.
16:32:19 <coleman> erisco: lines 4 and 9
16:32:40 <erisco> res:next does not appear on line 4 on what I am looking at
16:33:02 <coleman> erisco: I revised the gist: https://gist.github.com/JacksonGariety/b3ac405b19d5de62d893b161f82234b5
16:33:04 <erisco> if you want beautiful Haskell code you have to start with the big picture
16:33:16 <coleman> erisco: good point tho :-)
16:33:33 <erisco> ugly code results from solving a big problem in one definition
16:34:15 <coleman> erisco: ah I guess I could have two defs.
16:34:29 <erisco> an experienced Haskeller massages the problem into patterns she's seen before
16:34:38 <OriansJ> Given only a C compiler (like GCC) is there a way to bootstrap haskell to a new hardware platform?
16:35:37 <geekosaur> OriansJ, not currently
16:35:52 <geekosaur> the current recommended way to do it is LLVM
16:36:37 <OriansJ> geekosaur: well haskell didn't exactly spring from nothing, are those early pieces [that had to be written in other languages] available anywhere?
16:37:00 <c_wraith> you can rebuild ghc to produce unregistered C output. 
16:37:23 <geekosaur> build ghc on a similar supported platform with -fllvm -fkeep-llvm-files and copy the llvm ir to the target, then use opt and llc to generate target object code
16:37:36 <geekosaur> -funregisterised is not currently known to work, as I understand it
16:38:02 <geekosaur> (maybe they fixed it; it was broken after they removed the vestiges of -fvia-C)
16:38:07 <c_wraith> I thought that still existed, and it was -fvia-c that was dropped. 
16:38:17 <geekosaur> they used common code
16:38:28 <erisco> go [] x y ⇒ go y x []  let y = [] then  go [] x [] ⇒ go [] x []  where ⇒ is reduction  i.e. you have an infinite loop in your code coleman
16:38:57 <geekosaur> they weren't supposed to, but there was something in common between them
16:39:05 <c_wraith> anyway, there certainly are ways to bootstrap ghc 
16:39:08 <coleman> erisco: yeah it's supposed to loop forever until it finds an answer.
16:39:14 <c_wraith> but it's not a small undertaking. 
16:39:17 <coleman> erisco: in this case there are an infinite number of possibilities
16:39:20 <geekosaur> it won't find an answer with that loop, coleman
16:39:28 <geekosaur> it just repeatedly does the same thing
16:39:31 <erisco> coleman, it is an unproductive loop
16:39:37 <coleman> geekosaur: it does, though
16:39:55 <geekosaur> not if it falls into the cycle erisco pointed out
16:40:11 <erisco> this happens if props is the empty list… give it a try ;)
16:40:19 <geekosaur> it just does go [] x [] which does go [] x [] which does go [] x [] which ...
16:40:22 <coleman> oh I see
16:40:46 <coleman> I didn't catch that
16:41:54 <OriansJ> perhaps more context will assist in why I am looking for such source code, I am currently attempting to create a full trusted path using DDC which literally has started with just a hex monitor writen in under 200 assembly instructions and have thus far fleshed out to a forth interpreter, assembler, linker and various support tools. However since most of my late stage is already in the guix package tree, I was looking for a way to get
16:41:54 <OriansJ> haskell code into that trusted path as well.
16:42:56 <geekosaur> well, you can try -funregisterised and see if it works
16:43:22 <erisco> coleman, certainly when I see (head rules) I crank my head a bit … can you explain what prove does?
16:43:25 <geekosaur> you'd build a ghc with -funregisterised and use it to build itself, which will give you ANSI C
16:43:32 <geekosaur> if it actually works at this point
16:43:43 <geekosaur> if it doesn't, the llvm route is the only way currently
16:43:56 <geekosaur> (but if it doesn't, file a ghc bug so they can fix it)
16:44:03 <c_wraith> OriansJ, the #ghc channel might have more reliable infonabiut this. 
16:44:09 <c_wraith> .. info about 
16:44:24 <coleman> erisco: it takes a set of propositions and applies all logical rules to them. Then it applied all the rules to the results of all the previous rules.
16:44:41 <coleman> It reports "proven" when the application of a rule == the conclusion provided
16:45:01 <erisco> ah, then we can break this problem down
16:45:16 <EvanR> dfeuer: https://gist.github.com/evanrinehart/573181f3f33eb64dabcf3434d08e1cb7
16:45:57 <OriansJ> c_wraith: thanks I'll ask them
16:46:04 <erisco> first, what is the function which applies a logical rule to a proposition?
16:46:49 <coleman> erisco: res = r (head px) and res = r (head rules)
16:47:17 <erisco> so the function is r?
16:47:21 <coleman> erisco: px is the list of rules we're iterating over, and `rules` is the unadultured version that we start from when we move to a new proposition
16:47:37 <coleman> erisco: right, r can be any of the rules (in this case, dni and dne)
16:47:57 <erisco> so rules are functions, and regular application applies a rule to a prop, okay
16:48:12 <erisco> what is the result of this? a new prop?
16:48:16 <EvanR> hexagoxel: it gives you nothing over sum types in that case, i think its a degenerate example
16:48:56 <coleman> erisco: an Expression
16:48:59 <EvanR> vinyl is a library where the tag thing is used for more safety
16:49:02 <coleman> erisco: right, a proposition
16:49:07 <coleman> erisco: i'll post the whole code
16:49:17 <EvanR> field labels are referred to as a universe
16:49:26 <coleman> https://gist.github.com/JacksonGariety/b3ac405b19d5de62d893b161f82234b5
16:49:31 <coleman> same gist, updated
16:50:26 <erisco> okay, so we have a list of rules, and a list of props, and we want to apply all the rules to all the props for a new list of props
16:50:32 <coleman> erisco: righteo
16:50:40 <erisco> that is part of the problem, anyways, if we break it down. What familiar operation is that?
16:51:02 <coleman> erisco: map or list comprehension I guess
16:51:25 <erisco> Cartesian product, which can be done with a list comprehension if you like
16:52:03 <coleman> erisco: but I need to do it recursively so it continues until it finds a solution
16:52:21 <erisco> what happens if a rule does not apply to a prop? i.e. the form of prop does not fit the rule
16:52:21 <coleman> erisco: and I need to keep a map around so I can re-trace my steps when I "pretty print" the result
16:52:30 <erisco> coleman, yes, we'll get there ;) this is part of breaking it down
16:52:33 <coleman> erisco: haven't gotten that far
16:52:34 <erisco> if you can do it once you can repeat it
16:53:40 <erisco> okay, well, my suggestion is  type Rule = Prop -> Maybe Prop
16:54:06 <coleman> erisco: ah
16:55:23 <erisco> (\rules props -> [r p | r <- rules, p <- props]) :: [Rule] -> [Prop] -> [Maybe Prop]
16:55:53 <coleman> erisco: we're on the same page. just wrote something similar
16:56:29 <erisco> now there is a handy function catMaybes :: [Maybe a] -> [a]  which gives you only the Just terms
16:56:59 <coleman> Rule = Prop -> Maybe Prop is a thing"?
16:57:00 <erisco> there is possibly a way to bake this into the comprehension but I don't use them so I don't know the syntax
16:57:23 <erisco> type Rule = Prop -> Maybe Prop   declares that "Rule" is a synonym for "Prop -> Maybe Prop"
16:58:40 <coleman> erisco: gotcha. so my dne and dni need to have a maybe case
16:59:31 <erisco> I am guessing you want  dne (Not (Not p)) = Just p; dne _ = Nothing
17:00:38 <erisco> now we can take one step, lets work out how to repeat it
17:00:46 <coleman> erisco: what about rules that always apply like DNI?
17:00:52 <coleman> erisco: you can always apply DNI
17:01:20 <Axman6> then it will always succeed with Just
17:01:21 <erisco> dni p = Just (Not (Not p))  or   dni = Just . Not . Not
17:02:17 <erisco> personally I first thought about how I want to search for the answer. We have the base case (the initial props) and the inductive case (how to get the next props), so from this it is easy to see we can have a list of props
17:02:54 <erisco> so I can see with any initial props and unfold this list, then search that list for whatever I am interested in
17:03:17 <erisco> so you probably want to use unfoldr
17:04:39 <coleman> erisco: ahhh
17:04:46 <erisco> can seed*
17:05:05 <coleman> erisco: but how do I keep generating the list and unfolding until I find the answer?
17:05:14 <coleman> erisco: the list will be an infinite list
17:05:26 <coleman> erisco: or are we not there yet
17:05:39 <erisco> generating the list and searching the list are different pieces now, they needn't be together
17:06:11 <erisco> first we generate the list, then we can use whatever listy functions we like, such as filter (to find a prop we are interested in)
17:06:32 <erisco> yes, the list will be infinite, this is okay
17:06:42 <coleman> erisco: okay. But I'm getting a type error for the moment.
17:06:51 <erisco> to generate the list look at unfoldr
17:07:04 <coleman> erisco: rather than a list comprehension?
17:07:08 <coleman> erisco: or you mean to search the list?
17:07:19 <erisco> okay, there are three main pieces
17:07:37 <erisco> piece one we did was the product, applying a list of rules to a list of props
17:07:59 <erisco> piece two was to repeat this process recursively, that is unfoldr
17:08:05 <coleman> aha
17:08:05 <erisco> piece three is to search the list, that is filter
17:08:08 <coleman> gotcha
17:08:39 <coleman> question: I guess I felt like, going into this problem, doing things separatelty like this would cause a huge performance decrease
17:09:28 <coleman> erisco: I put everything in a single loop partly out of unknowing and partly out of concern that large derivations would take a long time. Does haskell handle this?
17:10:24 <erisco> we'd both be guessing, but your concern seems somewhat misaligned
17:10:33 <coleman> good :-)
17:11:28 <erisco> the confusion is when you say "doing things separately", particularly the "doing". does "doing" refer to the runtime or does it refer to how we've written the code?
17:11:53 <monochrom> You did get that do-your-own-interleaving habit from other languages because they forced it on you.
17:12:21 <erisco> I don't know the runtime implications but I'd rather start with something conceptually simpler (which we've done by breaking the problem into parts) and work out runtime issues after
17:12:48 <coleman> erisco: i'm all for it :-)
17:13:55 <erisco> I wouldn't expect your algorithm to be particularly quick regardless of how you implemented it
17:14:06 <coleman> erisco: I expected that
17:14:07 <monochrom> The Haskell inventors chose to go lazy lists because they wanted to see what would happen to programming if they gave you this opportunity to separate out the producer from the searcher again.
17:14:13 <erisco> there is an exponential growth in props you are searching through
17:14:20 <coleman> monochrom: ah interesting
17:14:24 <coleman> erisco: right
17:14:32 <coleman> erisco: it's totally dumb and brute-force
17:14:45 <monochrom> John Hughes's "why does functional programming matter" is largely about this.
17:17:29 <erisco> C# has IEnumerable
17:18:07 <EvanR> lua has iterators!
17:18:15 <slack1256> I remember some -fno-object-code for ghc, so it just typechecks. Anything for cabal build/configure?
17:18:24 <erisco> separating the producer from consumer is an example of what I've generally been trying to do lately
17:18:31 <slack1256> maybe I could pass that option to ghc directly
17:18:56 <EvanR> erisco: you could potentially implement lazy lists in c# with exceptions
17:19:13 <erisco> my description is "beta reduce last"
17:19:23 <coleman> erisco: what's the seed for my unfoldr?
17:19:31 <erisco> coleman, your initial propositions
17:20:05 <coleman> erisco: and the unfoldr uses the list comprehension?
17:20:27 <monochrom> slack1256: You can try. But two weeks ago when I did something unrelated to your question, I accidentally discovered that cabal-install checks for existence of output files at various stages. So your -fno-object-code is going to choke cabal-install just because it can't find output files.
17:20:37 <erisco> yes, each step you will be taking a product
17:21:38 <erisco> beta reduction hides details. This is sometimes wonderful and other times a problem
17:22:03 <monochrom> I did "cabal configure" and then "cabal register --gen-pkg-conf".
17:22:13 <erisco> so I see it as something to use with great prudence
17:22:57 <slack1256> I see :-(
17:23:35 <monochrom> No, actually it was probably worse than that, i.e., I didn't even go as far as the "register" stage.
17:24:29 <monochrom> "register" needs the output files because it needs to generate the hash of the output files for the long hexadecimal id.
17:24:58 <monochrom> But I think I didn't even get that far. I tried something that should not need the output files, and still cabal said no.
17:27:54 <coleman> erisco: ? `apply props = unfoldr (\p -> Just applyRules props) props`
17:28:41 <coleman> erisco: that function \p -> returns a list. Type error, though
17:28:52 <monochrom> Oh, now I remember, it was "cabal register --something" alright, which legitimately needs output files.
17:29:11 <erisco> apply = concat . unfoldr (Just . applyRules)
17:30:03 <coleman> erisco: same error: [Maybe Expr] can't be matched with ([a], [Expr])
17:30:12 <coleman> Expr is my structure
17:30:37 <coleman> for (Not (Not (Phrase "foo")
17:30:38 <erisco> what is the type of applyRules? did you use catMaybes?
17:31:00 <coleman> erisco: nope. missed that part
17:32:16 <erisco> and mine is wrong too because unfoldr doesn't have the seed the same type as the output, whoops
17:33:39 <erisco> apply = concat . unfoldr (Just . join (,) . applyRules)
17:33:56 <erisco> join (,) is  \x -> (x, x)
17:34:37 <coleman> erisco: I have an inifnite list!!! hurray
17:35:49 <erisco> now you have "elem" and so on to use on the list
17:36:08 <erisco> that's a program already written for you :)
17:36:30 <coleman> erisco: (c) haskell + erisco
17:37:29 <coleman> erisco: I tried unfoldr when I first started this whole thing but got frustrated. I couldn't find good examples. I need a book reference that's more in depth than LYAH
17:37:34 <coleman> erisco: any good books?
17:37:39 <erisco> so I think, after Rule and Prop are defined, the brute force algorithm is just a couple lines
17:38:41 <polo> hi, can sb help me why am I getting error?  http://lpaste.net/294377
17:38:48 <coleman> erisco: yeah it's pretty simple. thanks mate
17:39:05 <erisco> I haven't read any Haskell books (other than Purely Functional Data Structures as a reference) so I am afraid I have no special recommendations =\
17:39:41 <erisco> I was asking questions on here like you are a few years ago
17:39:45 <pie_> oh neat i want to read that at some point
17:40:15 <erisco> senpai Cale taught me
17:40:39 <pie_> on that note the wiki page for purely functional data structures links a stackoverflow post that gives developments since the book was published (which was a while ago)
17:40:48 <coleman> erisco: ah. he was here last night trying to set in me in a similar direction
17:40:55 <Cale> polo: Well the result of extract should be a list of numbers, right?
17:41:13 <polo> Cale: could be any type.
17:41:36 <polo> Cale: however, a b list should have same types.
17:41:41 <Cale> polo: [] : extract a b xs suggests that the result is (definitely) a list of lists -- the first element is an empty list
17:42:03 <Cale> Also, you should be aware that null (x:xs) is always going to be False
17:42:20 <Cale> (x:xs) is a nonempty list whose first element is x, and where the remainder of the list is xs
17:43:59 <polo> Cale: how do I solve this? I want to compare each list element and return the appropriate list.
17:44:10 <polo> http://lpaste.net/294377
17:44:38 <Cale> polo: Well, if you intend to define it recursively, you should probably handle two cases:
17:44:43 <Cale> extract a b [] = ...
17:44:55 <Cale> extract a b (x:xs) = ... (extract a b xs) ...
17:45:38 <Cale> In the first one, the list is empty, so according to the description of what you want, the result should be empty as well
17:45:41 <Cale> extract a b [] = []
17:47:03 <Cale> In the second one, there are two possibilities: either a <= x and x <= b, in which case, we don't want to keep it, and the result of extract a b (x:xs) should be the same as the result of extract a b xs
17:47:50 <Cale> Or otherwise, it lies outside that range, and we do want to keep it, in which case, the first element of the result is x, and the tail is the result of extract a b xs
17:47:54 <Cale> So:
17:48:00 <Cale> extract a b (x:xs)
17:48:13 <Cale>   | a <= x && x <= b = extract a b xs
17:48:24 <Cale>   | otherwise = x : extract a b xs
17:49:15 <Cale> (Note that we just assume that extract a b xs does the correct thing to the remainder of the list)
17:51:13 <polo> Cale: got it. So my problem was with adding []:.... like this.Also I did not do && but I did ||.Many thanks!
17:52:22 <Cale> polo: It's also possible to write this function using the filter function
17:52:50 <Cale> It's possible to express the logic in terms of || as well, if you negate things, and swap the cases
17:53:12 <Cale> i.e. the elements we want to keep are those which are outside the range, so those x for which x < a or b < x
17:53:51 <Cale> and that helps in expressing it as a filter:  extract a b = filter (\x -> x < a || b < x)
17:58:26 * hackagebot ntrip-client 0.1.4 - NTRIP client.  https://hackage.haskell.org/package/ntrip-client-0.1.4 (markfine)
18:20:45 <jvanbure> dmwit, dfeuer: not sure if y'all are still here, but thanks for the help!
18:22:10 <jvanbure> What i'm really trying to do is construct a datatype for representing types of things in a statically typed language, like C
18:22:37 <jvanbure> so say like Type = Pointer x | Int | Char | etc...
18:22:57 <jvanbure> and structs and arrays
18:24:04 <jvanbure> but we need to be also able to have types of unknown size, for which we're able to have pointers  of it, but not make arrays or structs of it
18:24:14 <jvanbure> and this is seemingly rather hard to capture in a type 
18:25:18 <jvanbure> with a close-to-generic interface that's not just like data Pointer = PointerToArray Array | PointerToStruct Struct | ...
18:27:02 <jvanbure> does anyone have any ideas on how to approach this?
18:28:05 <Rarrikins> jvanbure: You'll need something like Pointer a, where a is the type pointed to.
18:28:19 <Rarrikins> jvanbure: Otherwise, you'll find it difficult to represent char**********.
18:28:49 <Rarrikins> jvanbure: Pointer Type, I mean.
18:30:29 <jvanbure> Rarrikins: hm yes for pointers i guess it's very general, but with our structs of undefined size, we don't want to be able to say like `Array UndefinedStruct` is a valid type
18:30:33 <EvanR> the grammar for C data types should be a good exercise in ADTs
18:30:39 <EvanR> and good documentation for C
18:30:56 <EvanR> for pointers, its not general
18:31:10 <EvanR> its specifically, pointer to some C type (recursive reference to this ADT)
18:31:49 <geekosaur> also a C pointer can be abstract
18:31:49 <Rarrikins> jvanbure: For structs, you'd have something like data Struct = Struct [Type]
18:32:03 <jvanbure> EvanR: It's not strictly C, it's a pseudo-subset of it for a school assignment, which is why i was slightly reluctant to give specifics
18:32:11 <EvanR> in C a structs structure isnt a type, each struct only has a type up to its name
18:32:43 <EvanR> you cant say any struct with fields like {a :: T1, b :: T2}
18:32:47 <geekosaur> (struct foo *) can be used without knowing the definition of (struct foo), and will be a distinct type from (struct bar *) even if (struct bar) is also unknown
18:33:36 <EvanR> jvanbure: still, should be doable, and definitely without the crazy stuff we were suggesting earlier
18:34:10 <jvanbure> geekosaur's remark was where i was running into trouble earlier
18:34:11 <EvanR> dont jump right to typeclasses by default
18:35:28 <jvanbure> how would you approach giving constraints on things like that though...
18:35:57 <EvanR> struct foo and struct bar are types, ignoring their structure. and pointer to _ is a type
18:36:08 <jvanbure> yes
18:37:33 <jvanbure> However the difference between defined and undefined structs becomes important when i need to do things like nest structs
18:38:00 <EvanR> you have a way to put the structure in the type?
18:39:30 <jvanbure> I would use a map or whatnot for fields
18:40:25 <EvanR> in that case... its getting deeper
18:40:35 <EvanR> are you planning to have structs which contain themselves?
18:40:43 <jvanbure> no lol 
18:41:06 <EvanR> are you planning to have polymorphism?
18:41:12 <jvanbure> ooh that would be a good test case though...
18:41:46 <jvanbure> polymorphism only in the sense that we can have pointers to structs whose definitions we don't know yet, as long as we don't use them in a context that requires information about their size/fields
18:42:29 <EvanR> so ... you have structure in the type, or a name if the structure is unknown
18:42:53 <jvanbure> yes
18:43:20 <EvanR> then maybe instead of having those be "two types for the same thing" you could introduce abstract types
18:43:46 <EvanR> either its a structure and heres the structure, or its a name and we dont tell you how its implemented, might not even be a struct
18:43:57 <EvanR> two different types though
18:44:43 <jvanbure> it would be nice if we could do more than promise that we wouldn't "accidentally" construct a type like an array of names
18:45:04 <jvanbure> I'm not sure how tractable that is
18:45:29 <EvanR> when you have abstract types like that, you can only use them through their API
18:45:35 <EvanR> theres no accidentally anything
18:46:17 <geekosaur> technically you need the struct tag even if you know the structure
18:46:18 <EvanR> introducing a cast thing, then you have issues
18:47:10 <EvanR> you need a struct name in the type even if you know the structure? i dont think thats absolutely necessary
18:47:13 <geekosaur> struct a { int i; char c; } and struct b { int i; char c; } are still distinct
18:47:23 <coleman> erisco: how would I modify your `unfoldr (Just . join (,) . apply)` so that `apply` can return a pair (Expr, String)?
18:47:56 <EvanR> yes thats a combination of defining a record type then giving it a newtype
18:48:26 <EvanR> but you could have them be separate in a hypothetical type system
18:48:43 <coleman> erisco: the `Just . join (,)` is the only part of the code I don't fully understand
18:50:58 <jvanbure> I'm a little confused
18:51:10 <jvanbure> er well i guess i see
18:51:13 <jvanbure> hm
18:51:25 <EvanR> have you checked out TAPL
18:52:06 <jle`> > (Just . join (,)) 10
18:52:08 <lambdabot>  Just (10,10)
18:52:44 <neonfuz> so why is the curry function even called that
18:52:46 <coleman> > (Just . join (,)) (1,2)
18:52:47 <lambdabot>  Just ((1,2),(1,2))
18:52:52 <coleman> hmmm
18:52:54 <coleman> interesting
18:53:17 <neonfuz> lol I never realized (,) is a function even
18:53:55 <EvanR> it has a function type, but its really something different in the language
18:54:22 <EvanR> a 2 arg ctor
18:54:36 <neonfuz> ah
18:54:44 <EvanR> once its fully applied, youre in WHNF
18:54:56 <EvanR> it doesnt reduce
19:00:15 <dk007> hi. i need a solution to frequent values
19:10:41 <coleman> EvanR: can you explain why line 6 says the actual type is [Expr]? http://lpaste.net/328252
19:12:04 <EvanR> line 6 is blank
19:12:26 <coleman> EvanR: just changed it. Line 8
19:12:48 <EvanR> :t join (,)
19:12:49 <lambdabot> b -> (b, b)
19:13:00 <EvanR> Actual type: [Expr] -> ([Expr], [Expr])
19:13:05 <coleman> EvanR: it was originally written for apply to reutrn [Expr] but now it returns [(Expr, String)]
19:13:57 <EvanR> im guessing Line is String ?
19:13:59 <EvanR> or
19:14:09 <EvanR> oh well
19:14:09 <coleman> EvanR: line is (Expr, String)
19:14:12 <EvanR> update your paste
19:14:20 <geekosaur> you have to replace the join (,) with something appropriate to the new type
19:15:05 <coleman> geekosaur: EvanR added whole thing with types
19:15:07 <EvanR> apply now returns (?) [(Expr, String)] so thats why the compiler things thats what it is, and its not compatible with join (,)
19:15:22 <coleman> EvanR: yeah
19:15:34 <EvanR> now its totally different but no error message
19:16:01 <jchia1> Is unhandled SIGINT supposed to cause an exception? I have some resource that I need to cleanup (a process to kill) and I'm using finally to do it but it seems that finally is not getting called after an unhandled SIGINT. What's the right way to do this?
19:16:58 <coleman> EvanR: the bottom two defitions are the significant ones. the error is back
19:17:06 <EvanR> ghc doesnt guarantee your finalizers will run if the program ends abruptly
19:17:47 <EvanR> which would happen if SIGINT is unhandled and exits the program, or throws an exception to main which is unhandled
19:18:30 <Rembane> Can you register on a signal in a way that's guaranteed to catch it?
19:18:54 <coleman> geekosaur: join (,) gives you two of whatever you give it. not sure why that would be approproiate to unfoldr in the first place
19:19:04 <EvanR> you be install your own signal handlers
19:19:08 <EvanR> you can*
19:19:17 <jchia1> EvanR: Would it work if I explicitly handled SIGINT and in my handler throw an exception? Do I need to explicitly throw it to the thread that has the resource handle?
19:19:39 <EvanR> coleman: the type of unfoldr i think is disagreeing with the type of your . chain
19:19:51 <EvanR> map out all the types and see if they make sense together
19:20:28 <EvanR> jchia1: to make sure threads run finalizers, they need to be cancelled in a controlled way, prior to the end of the program
19:20:47 <EvanR> so you could catch it in main, or install a custom handler which does that
19:20:56 <coleman> EvanR: you're right. thanks
19:21:14 <EvanR> actually i dont know how to catch async exceptions, install a sig handler
19:21:38 <pikajude> or a sig sauer
19:21:41 <pikajude> just threaten the runtime with it
19:21:48 <pie_> hrhr
19:22:22 <laudiacay> https://www.youtube.com/watch?v=xFSwIw-_-as
19:22:27 <laudiacay> oh wrong channel
19:22:27 <jchia1> EvanR: Do you mean even if I install a SIGINT handler that throws an exception but nobody catches the exception, the finalizers may not get called?
19:22:38 <laudiacay> shoot
19:22:39 <EvanR> that is whats already happening now
19:22:59 <EvanR> install a handler that kills those threads somehow
19:23:07 <geekosaur> jchia1, one issue with signals is that they are delivered to the process, and if multiple threads are running on different cores then one will randomly be picked
19:23:31 * hackagebot rattletrap 0.1.5 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.1.5 (fozworth)
19:23:40 <pie_> laudiacay, toot toot motherucker
19:23:44 <geekosaur> you don't get to control this. if you want to control what happens, you will have to throwTo the thread that should handle it --- good luck if you have several such.
19:24:06 <EvanR> wait... the signal is raised in a random thread?
19:24:14 <geekosaur> yes
19:24:17 <EvanR> wtf
19:24:29 <geekosaur> no guarantees at all. signals are *process* level, they do not know about threads at all
19:24:49 <EvanR> but ... ghc could unambiguously raise it in the main thread
19:24:56 <Rembane> geekosaur: What happens if you installHandler? Will there still be an interesting behaviour?
19:25:15 <laudiacay> pie_: the shame
19:25:49 <geekosaur> the handler runs in whichever thread happened to be running at the time (again, if multiple then the OS will pick only one of them somehow; you get to study kernel source to try to find out which)
19:25:56 <EvanR> i see
19:26:39 <Rembane> Ah, everything boils down to implementing a bad Erlang in Haskell then.
19:26:39 <EvanR> and after installing a handler with the stdlib, does that handler run in its own thread?
19:26:40 <geekosaur> what precisely ghc does depends on which runtime, and I only looked at it in the non-threaded rt
19:26:49 <geekosaur> I have no idea what -threaded does
19:27:06 <geekosaur> check System.Posix.Signal to see if they say anything, I guess
19:27:22 <jchia1> Signals aside, do handlers given to 'finally' run when the program has an unhandled exception, e.g. one that I throw explicitly in the SIGINT handler? If not, what's the use of 'finally'?
19:27:25 <pie_> laudiacay, im on the best part of youtube now.
19:27:56 <laudiacay> pie_: i dunno about that
19:28:06 <laudiacay> this is what i'm studying to 
19:28:06 <geekosaur> jchia1, if the main thread ends up handling the signal, it will exit and all other threads get terminated by the OS with no "finally" handlers run (it has no clue about them)
19:28:41 <EvanR> yes its in a new thread
19:29:04 <geekosaur> if it really matters, I suggest setting up critical sections with signals blocked if they could cause loss of a resource
19:29:13 <pie_> laudiacay, thomas the dank engine, darude tankstorm
19:29:34 <EvanR> jchia1: finally works great... as long as the program never exits
19:29:57 <EvanR> when it exits, its up to you to clean up before actually exitting
19:30:41 <geekosaur> basically you have run headlong into one of the ugly corners of multithreaded programming
19:31:00 <jchia1> Where's a good place to learn the details related to exceptions? The haskell report? Where do I go to learn the difference between the versions of finally and friends in different packages like base, exceptions lifted-base, safe-exceptions?
19:32:24 <dmj``> jchia1: https://github.com/fpco/safe-exceptions#readme
19:32:37 <dmj``> jchia1: then check out enclosed-exceptions too
19:33:16 <jchia1> thanks, all
19:34:02 <EvanR> an interesting parallel here, that no one really talks about, is what pending error callbacks do in javascript when the page unloads
19:34:13 <EvanR> they actually try to run
19:34:16 <EvanR> which is insane
19:34:50 <EvanR> they get a short time to do something meaningful before the next actually unloads, up to ... who knows what it depends on
19:34:59 <EvanR> before the page unloads*
19:35:34 <EvanR> they dont stop the page unloading because thatd be a user denial of service
19:49:00 <polo> Hi, I wrote the following function.My function dos what it should.However, I need to write a one liner function as per the requirement.http://lpaste.net/294377
19:50:48 <Rarrikins> polo: Can you use the standard list functions like filter and so on?
19:51:29 <polo> Hi, I wrote the following function.My function dos what it should.However, I need to write a one liner function as per the requirement.http://lpaste.net/294377
19:51:40 <glguy> polo: look up the functions you're allowed to use
19:51:53 <glguy> and then figure out which one does what you need
20:09:19 <ydl> is there a clean way to express the following thing: given a function a -> a and a list of [a], return a lists of lists [[a]] such that each element has f applied at a different location. so for example [1, 2, 3] -> [[f 1, 2, 3], [1, f 2, 3], [1, 2, f 3]]? i already have what i suspect is a more ugly and inefficient implementation than possible, but for testing purposes this gives the correct result: \f -> snd . foldr (\x (xs, r) -> (x
20:09:19 <ydl> : xs, (f x : xs) : fmap (x:) r)) ([],[])
20:09:34 <ydl> sorry about the linebreak, i mean: \f -> snd . foldr (\x (xs, r) -> (x : xs, (f x : xs) : fmap (x:) r)) ([],[])
20:18:47 <polo> I want to write a one-liner function.I did:superimpose (x:xs) (y:ys) =  if x>y then (((2*x)+y)/3):(superimpose xs ys) else if y> x then (((2*y)+x)/3):(superimpose xs ys) else error "lists are unparied or empty"
20:18:59 <polo> but I'm getting error for empty set case
20:19:40 <polo> How do I address that without pattern matching like : uperimpose [] [] = [] 
20:21:13 <Rarrikins> polo: Reread the instructions.
20:21:20 <Rarrikins> polo: It mentions some functions you might use.
20:22:05 <polo> Rarrikins: but I'm not sure how to do that.
20:22:34 <Rarrikins> polo: Do what?
20:23:41 <polo> Rarrikins: like I know how zip and map works but I'm not getting how to incorporate that in the present question.
20:25:21 <Rarrikins> polo: There are more functions than those.
20:26:26 <polo> Rarrikins: but with my beginner knowledge, I don't know what and that's why I'm asking for help from experts here.
20:27:00 <EvanR> ydl: hmm http://lpaste.net/328385
20:27:14 <Rarrikins> polo: What are the other functions listed in the instructions?
20:28:23 <polo> Rarrikins: The instruction mentions: This should be a single line, using some sort of map/mapWith/zip/zipWith (not including function definition)
20:28:40 <polo> http://lpaste.net/294377
20:28:53 <Rarrikins> polo: Right, so one of those functions will be useful.
20:29:11 <Rarrikins> polo: Go through them one by one.
20:30:03 <polo> :t mapWith
20:30:05 <lambdabot> error:
20:30:05 <lambdabot>     • Variable not in scope: mapWith
20:30:05 <lambdabot>     • Perhaps you meant one of these:
20:30:19 <polo> Rarrikins: 
20:31:09 <Rarrikins> polo: OK, so it's probably not that one.
20:34:55 <ydl> EvanR: i'd like to use some structure of lists/combinators, so mine fits that framework a bit more
20:35:11 <ydl> i.e. avoid explicit recursion
20:35:23 <EvanR> i tried that, it was more complex each way
20:36:20 <EvanR> answer f (x:xs) = (f x : xs) : (map (x:) (answer f xs))
20:36:26 <ydl> i don't think \f -> snd . foldr (\x (xs, r) -> (x:xs, (f x:xs) : fmap (x:) r)) ([], []) is more complex than the solution you gave?
20:36:47 <EvanR> it is if you write it on one line like this, and think about the efficiency
20:36:49 <ydl> EvanR: that fails on empty lists though :)
20:37:06 <EvanR> answer f (x:xs) = (f x : xs) : (map (x:) (answer f xs)); answer f [] = [[]]
20:37:22 <ydl> plus foldr is properly lazy, so in terms of efficiency I actually think they're the same, no?
20:37:23 <EvanR> using tuples at all is a golf failure
20:38:12 <EvanR> you could solve using "answer" as if it were a standard list combinator ;)
20:38:18 <EvanR> answer = answer
20:38:42 <polo> why does takeWhile (> 7) [8,1,9,10] returns 8 only when takeWhile (< 10) [8,1,9,10] returns [8,1,9]? In first case we're comparing only the first element.Why? 
20:38:44 <EvanR> on the same token i dont think it makes sense to implement map using a fold for the sake of it
20:39:21 <Rarrikins> polo: Once it reaches the 1, it's no longer greater than 7, so it stops.
20:39:27 <jle`> polo: it goes down the list until it sees something that doesn't match the predicate
20:39:41 <jle`> and it returns everything up until that point
20:39:47 <ydl> EvanR: it's easier to reason about / (depending on taste) more elegant to use the minimal number of combinators though. also what's wrong with tuples?
20:40:02 <EvanR> i didnt find your fold and tuples to be very illuminating 
20:40:10 <jle`> polo: 8 > 7, but 1 > 7 is not true, so it stops at just 7
20:40:14 <EvanR> tuples in a fold is less efficient
20:40:38 <EvanR> youre the one who asked for a better way
20:42:04 <ydl> EvanR: yep, and thanks for the help! i'm just trying to refine my tastes in what counts as "better" :)
20:43:03 <EvanR> the recursive version says, almost literally, "the answer is to apply the function now, or the value here prepended to all the answers for the rest of the list"
20:43:19 <EvanR> so its one of those "obvious by construction" algorithms
20:44:08 <EvanR> compare the implementation of map using recursion and the implementation of map using a fold
20:47:10 <benzrf> whats the difference? :)
20:48:10 <EvanR> map f (x:xs) = f x : map f xs
20:50:23 <EvanR> map f xs = foldr ((:) . f) [] xs
20:51:50 <EvanR> you can implement anything with a fold, but its not always to most natural
20:51:57 <EvanR> the most natural
20:57:21 <polo> Can sb please take a look and help me?http://lpaste.net/294377
20:58:23 <EvanR> nested if statements crammed onto one line might not count as a one liner
20:58:44 <EvanR> you can write your original function on one line too if you want, use { ; }
20:59:21 <x1f577> Any advice on GUI libraries to build a cross-platform haskell app? I'm working on a cross-platform alternative to windows explorer, finder, nautilus, etc.
21:00:04 <EvanR> polo: since youre mapping each x and y in each list to a function of x and y... thats really a zipWith isnt it
21:00:09 <pavonia> polo: They are asking for a function definition that doesn't call itself recursively, AFAIU
21:01:09 <EvanR> x1f577: one way is to use the main toolkit on the three platforms haskell runs on
21:01:21 <EvanR> abstract the interface your program will use, and implement 3 different drivers
21:01:22 <polo> EvanR: but in zipWith you give a function and two lists, then I will have to make a helper function.But I am not allowed.
21:01:43 <EvanR> are lambda abstractions not allowed?
21:01:46 <polo> zipWith (+) [1,2,3] [4,5,6]
21:01:54 <x1f577> EvanR: Cocoa, GTK, and Windows Views? 
21:02:14 <LordBrain> x1f577, if it were better documented, i'd recomend webkit
21:02:15 <EvanR> x1f577: i... guess
21:02:23 <EvanR> another option is to use a browser
21:02:39 <LordBrain> x1f577, but since its not, GTK is what i would go with as a first option
21:03:08 <EvanR> for the best user experience, i wouldnt recommend GTK on OSX
21:03:14 <EvanR> not sure about windows
21:03:20 <LordBrain> well
21:03:40 <x1f577> I think it'll be between GTK and some webkit thing
21:03:40 <polo> panovia: But I don't know how to do it without calling recursively.Any help/advise/steps?
21:03:46 <LordBrain> if you want it to look native and thats a very higih priority, you could use wxhaskell
21:03:59 <x1f577> is wxhaskell cross platform?
21:04:04 <EvanR> yeesh...
21:04:29 <x1f577> ill look into it.. thanks
21:04:30 <EvanR> if you want it to look godawful on each platform, FLTK2 
21:04:35 <LordBrain> i think so, but i have not used it in a long time, and i think gtk is a safer bet even tho it means non-native looking in windows
21:04:38 <EvanR> or tk
21:05:20 <xpika> is it possible to get optparse-applicative to show all help information ?
21:05:30 <LordBrain> wxhaskell is built on top of wxwidgets library, supposed to be cross platform all the way and native on each of the platforms it supports
21:05:46 <EvanR> yes, supposed to be
21:06:04 <LordBrain> i don't have a lot of experience with it tho
21:06:09 <x1f577> the screenshots on their website look pretty darn crappy
21:06:16 <LordBrain> yeah
21:06:34 <LordBrain> like i said, i tend away from it, even tho i don't recall why
21:07:02 <EvanR> its a pile of C++ like QT
21:07:09 <EvanR> and the results arent all that impressive
21:07:54 <LordBrain> none of our gui options i am aware of are really satisfactory
21:07:58 <EvanR> a browser is probably the best bet, since you do get native stuff
21:08:08 <xpika> also is it possible to have optparse-applicative accept either 1 flag OR another ?
21:08:11 <ab9rf> i remember not liking wxwidgets when i last looked at it, but that was probably a decade ago
21:08:17 <x1f577> yeah slack did a pretty sweet job using webkit (they did use webkit, right?)
21:08:29 <ab9rf> i haven't really found a GUI toolkit i like in any language
21:08:37 <ab9rf> and i helped write GTK
21:08:44 <x1f577> ab9rf: lol
21:08:47 <LordBrain> well try webkit, and when it just gets to be too much trying to decode it, switch to gtk
21:09:03 <EvanR> theres nodewebkit, and ghcjs
21:09:13 <x1f577> LordBrain: ive used reflex/reflex-dom with the webkit stuff quite a bit, but it gets rather unweildly 
21:09:36 <cheater> didn't gtk have like a web backend
21:09:36 <ab9rf> i've never been good at user interfacing
21:09:42 <ab9rf> cheater: not originally
21:09:45 <EvanR> you could write most of the GUI in javascript and use haskell as the application core
21:10:04 <Axman6> xpika: if it has an Alternative instance then yes
21:10:06 <ab9rf> gtk was conceptually a replacement for Motif
21:10:14 <Axman6> though, it'll be left biased
21:10:14 <LordBrain> ghcjs/webkit would be a great option i think, i just wish it were more documented
21:11:31 <cheater> yeah no i mean someone built a thing for one of those toolkits where you could open application windows inside a browser
21:11:33 <ab9rf> my idea of a user interface is a command line
21:11:44 <cheater> i thought it was gtk but it might've been something else
21:12:10 <ab9rf> i'd be impressed if someone wrote a layer that translated gtk into some sort of web interface
21:12:20 <EvanR> ab9rf: more people who invented toolkits feel the same way
21:12:31 <ab9rf> that'd be one hell of a gdk abstraction layer
21:12:35 <EvanR> explaining why they are the way they are
21:12:39 <cheater> yea i was impressed too that's why i remember it from a few years back
21:13:02 <EvanR> except it doesnt explain the win API
21:13:04 <x1f577> if i write most of the application logic in haskell, how can i expose that api to javascript, and subsequently use pure html/css/js to write the ui?
21:13:05 <ab9rf> cheater: i worked on gtk back in the late 90s
21:13:24 <EvanR> through ghcjs js FFI
21:13:31 <ab9rf> gtk was developed to replace motif because motif wasn't widely available on linux platforms
21:13:56 <x1f577> EvanR: that gives me haskell->javascript only right?
21:13:57 <LordBrain> x1f577, this might be an odd suggestion, but another thing to consider is GLUT, its pretty easy to use, gets the job done, tho of course its not really geared toward full on gui apps but more for guis in games.
21:14:02 <EvanR> x1f577: nope
21:14:13 <x1f577> both ways?
21:14:14 <EvanR> FFI lets you go both ways
21:14:23 <LordBrain> but i think its more type safe for exmaple than the GTK bindings
21:14:24 <x1f577> nothing wrong with going both ways :D
21:14:25 <cheater> ab9rf: i know that much. i don't think what i'm talking about was related to the effort you were part of.
21:15:07 <LordBrain> you'll be up and running quickest in GLUT
21:15:08 <x1f577> EvanR: do you know of an example application that does this?
21:15:30 <LordBrain> and its all opengl basically, portable
21:15:41 <Clint> cheater: are you thinking of webkitgtk+ or something?
21:15:46 <x1f577> LordBrain: looking into GLUT now
21:15:50 <EvanR> GLUT D:
21:16:06 <EvanR> is not for production grade programs
21:16:08 <cheater> i don't know, what is it?
21:16:15 <cheater> anyways i shouldn't be talking about it, i got other stuff to do :)
21:16:23 <EvanR> and using opengl raw like this means writing your own toolkit
21:16:28 <LordBrain> its not really geared toward your purpose, but that could be a boon if you expand it... or find some supplementary libraries that extend it.. it makes for the easiest going out of these options
21:16:28 <EvanR> which some apps have done
21:16:49 <Clint> cheater: or maybe https://blogs.gnome.org/alexl/2011/03/15/gtk-html-backend-update/
21:17:16 <EvanR> x1f577: no, but theres bound to be docs on the js ffi
21:17:24 <x1f577> its looking like writing the UI in webstuffs and the application logic in haskell
21:18:05 <LordBrain> gtk bindings need more type safety... its like programming in c basically when you use them
21:18:37 <LordBrain> maybe there is a higher level gui library built on top of it tho somewhere
21:18:38 <Koterpillar> LordBrain: did you see gi-gtk?
21:18:44 <LordBrain> no
21:18:53 <Koterpillar> and gi-*
21:19:22 <Koterpillar> they use GObject introspection to bring all the types to the Haskell side intact
21:21:15 <ezyang> Does 'diagrams' know how to do graph layout ala GraphViz? 
21:21:25 <LordBrain> well, i just remember finding lots of exceptions when i was trying to do some gui programming a while back, and finding it annoying... like things that should be caught compile time arent
21:21:41 <Koterpillar> that's not the experience I had with gi-gtk
21:21:48 <LordBrain> okay
21:22:18 <LordBrain> good then, i'm glad there is something safer, hope its documented well too
21:23:24 <x1f577> calling javascript from haskell seems less than fully-supported as of yet
21:23:31 <x1f577> whoops
21:23:37 <x1f577> calling haskell from javascript**
21:24:02 <EvanR> that seems like a completely necessary thing to do
21:24:15 <Koterpillar> LordBrain: for documentation, you just look up the original Gtk one
21:25:12 <LordBrain> hmm if it is that close to the original then it could probably be made higher level to advantage
21:26:30 <Koterpillar> yes, but gi- is more about automating the binding generation than making the interface better
21:37:34 <C0l3tra1n> How is haskell better that pascal?
21:37:49 <C0l3tra1n> Or at least where is the difference? 
21:40:13 <Axman6> C0l3tra1n: they're basically completely unrelated, except that they are both turing complete programming languages
21:53:29 <piyush-kurur> question of ghc+llvm on debian. Is is just sufficient to install clang to get llvm based compilation for ghc
21:55:02 <grantwu> I thought GHC just comes with LLVM
21:55:34 <Rarrikins> piyush-kurur: On Ubuntu, `apt show ghc` lists `llvm-3.5` under suggested packages. Perhaps there's a suggested package for Debian.
21:56:32 <piyush-kurur> Rarrikins: yes llvm is a suggested package in debian too
21:56:43 <piyush-kurur> So I just install llvm and all is cool?
21:56:55 <Rarrikins> piyush-kurur: I think that package will be what you need, though you can check by trying to compile something via LLVM.
21:57:00 <grantwu> wait, do you need to specify -fllvm?
21:57:10 <grantwu> I thought GHC had started defaulting to LLVM
21:57:59 <Rarrikins> grantwu: I'm not sure what the default is.
21:58:56 <Rarrikins> piyush-kurur: I'd say to try compiling something small using `ghc -fllvm`. If it can't, then install more stuff :)
21:59:58 <piyush-kurur> Rarrikins: I am compiling with stack but it is failing with fllvm
22:00:20 <piyush-kurur> there is also a scarry looking "you are using the new llvm backend and hence .... message"
22:00:21 <Rarrikins> Oh, I'm not sure with regards to stack.
22:00:31 <Rarrikins> I'd recommend just trying to compile a standalone file.
22:00:48 <piyush-kurur> Rarrikins: okey I will get back to you
22:02:11 <l_zzie> Axman6, I've had people (e.g. interviewers) think I'm saying "Pascal" when I'm saying "Haskell"
22:02:22 <l_zzie> so they have that similarity
22:04:07 <nshepperd> Haskell and Pascal are basically the same except that in Pascal the stress is on the second syllable.
22:04:16 <Rotaerk_> l_zzie, I've had people make that same mistake when I mention haskell too
22:04:20 <Lokathor> nshepperd, wait what?
22:04:38 <piyush-kurur> Rarrikins: Not working here is the error http://pastebin.com/dpYjckke
22:04:43 <Lokathor> where do you live?
22:06:04 <Rarrikins> piyush-kurur: Did you install LLVM from Apt?
22:06:11 <piyush-kurur> Rarrikins: yes
22:06:16 <nshepperd> Lokathor: it's true. https://en.wikipedia.org/wiki/Blaise_Pascal
22:06:24 <Rarrikins> piyush-kurur: I'm not sure then.
22:06:28 <nshepperd> Lokathor: australia
22:06:48 <piyush-kurur> In fact now things look bad. I am getting a linker error without -fllvm
22:06:56 <Axman6> pas-carl, has-kell
22:07:16 <Axman6> or even haskul
22:07:20 <Lokathor> oh man i've been saying it wrong for years
22:07:26 <Lokathor> all 20 times!
22:07:27 <Axman6> because 'straya
22:07:55 <nshepperd> hehehe
22:10:03 <Rarrikins> piyush-kurur: After installing Ubuntu's `llvm-3.5` package, `-fllvm` works here.
22:10:50 <seafood> Anyone here had experience with Servant? 
22:10:59 <Axman6> yes
22:11:07 <seafood> Axman6: What do you think of it?
22:11:10 <Clint> piyush-kurur: which ghc version?
22:11:14 <Axman6> it's great
22:11:18 <seafood> Is the type level stuff too much? 
22:12:01 <piyush-kurur> Clint: just a minute I will reinstall ghc and have a go (ghc 7.8 I guess debian testing)
22:12:08 <Axman6> no, the type level stuff is what makes it great
22:12:21 <Clint> piyush-kurur: testing has 7.10, unstable has 8.0.1
22:12:36 <piyush-kurur> okey then 7.10
22:12:48 <piyush-kurur> Clint: I will let you know in a minute
22:14:27 <piyush-kurur> Clint and others: sorry folks I forgot that my last night sudo apt-get upgrade did not go through so let me upgrade and then try
22:20:44 <piyush-kurur> folks: PEBCK ;-) sudo apt-get upgrade and llvm install made everthing work fine
22:25:10 <piyush-kurur> Clint: One more question. For FFI code with LLVm does ghc use clang or gcc
22:51:42 <lispy> piyush-kurur: by default ghc uses gcc but it can use clang
22:51:50 <lispy> except on macos where gcc is secretly clang
22:52:44 <piyush-kurur> lispy: is there a way to set it using stack command line?
22:53:13 <lispy> I can't help with stack issues
22:53:52 <hrqa> I need to implement a version of join (monad) that uses both bind and return. Could I get some guidance?
22:54:13 <lispy> hrqa: is this a homework?
22:54:17 <hrqa> I understand how I could implement it based on the default definition (and you can add a bind and return to the end because of the identity)
22:54:17 <hrqa> Yes
22:54:20 <lispy> cool
22:54:33 <lispy> I'd start by writing down all three types
22:55:15 <hrqa> So what confuses me about return it it's a lifting function, but with join we want to do the opposite
22:55:30 <EvanR> thats the cool part... they do opposite things ;)
22:55:51 <EvanR> a -> m a <- m (m a)
22:56:12 <EvanR> a -> m a <- m (m a) <- m (m (m a)) <- ...
22:56:27 <hrqa> right. but to define join in terms of something that does the opposite...?
22:56:41 <EvanR> i think the magic is in bind really
22:58:03 <unclechu> hey guys, about FFI, what if I have to describe struct's field like this for FFI? `typedef	struct _Foo { unsigned char baz[123] } Bar;` how I do specify this 123 size to `data`?
22:58:15 <hrqa> I understand how it works with id, because you take an a that is really wrapped twice, and so when you return m b you have really unwrapped it. Thinking about return...
22:59:05 <hrqa> I notice that the type of return is the type of the second argument to bind
22:59:18 <EvanR> unclechu: are you implementing a Storable
22:59:51 <EvanR> hrqa: hmm. thats probably just coincidence
22:59:53 <unclechu> EvanR: yep, using `hsc2hs`
23:00:10 <EvanR> good to know
23:00:40 <amalloy> i don't think that's a coincidence at all
23:01:16 <amalloy> hrqa: you might need to use return or bind twice, not just once
23:02:26 <hrqa> amalloy, But I don't need any other functions?
23:02:46 <amalloy> are you sure you want an answer to that?
23:03:32 <hrqa> I'll think it over for a few more minutes first
23:05:01 <unclechu> EvanR: so, did it clarify anything?
23:05:25 <EvanR> yes, i dont know how to use hsc2hs
23:05:38 <EvanR> so ive no idea
23:06:06 <EvanR> but to write Storable yourself, you need to unmarshall an array of exactly 123 things into a Vector or something
23:06:22 <EvanR> which you can do with the marshalling section of the FFI
23:06:55 <hrqa> amalloy, getting nowhere... i'll take the help
23:07:40 <amalloy> hrqa: you can implement join using only partial applications of (>>=) and return
23:10:47 <amalloy> in figuring out how to combine them, it may help to think about (>>=) as "removing" one level of monad-wrapping from the value you have access to, and return as "adding" one level of wrapping
23:17:23 <nshepperd> you don't need return to implement join
23:17:36 <hrqa> I'm aware, this is for homework
23:18:04 <EvanR> you dont need it, somehow figure out how to use it anyway ;)
23:18:15 <EvanR> i love those kind of exercises
23:18:16 <hrqa> is it best to try and solve this by thinking about type signatures? i'm still spinning
23:20:28 <hrqa> amalloy, any guidance you can offer?
23:23:12 <nshepperd> well I guess if you can use return to implement id you can just throw that anywhere. that would be my default strategy to "use" something :)
23:23:44 * hackagebot picedit 0.1.1.1 - simple image manipulation functions  https://hackage.haskell.org/package/picedit-0.1.1.1 (mdibaiee)
23:23:53 <hrqa> by using return to implement id, are you referring to the right identity law? (a >>= return a)?
23:24:36 <nshepperd> that would be a way to do it
23:38:17 <amalloy> (a >>= return a) seems like a very strangeexpression. i think you mean the law that (a >>= return) == a
23:42:48 <cheater> :t a >>= return a
23:42:49 <lambdabot> error:
23:42:49 <lambdabot>     • Couldn't match expected type ‘m a0’ with actual type ‘Expr’
23:42:49 <lambdabot>     • In the first argument of ‘(>>=)’, namely ‘a’
23:42:56 <cheater> :t \a -> a >>= return a
23:42:58 <lambdabot> Monad m => m b -> m b
23:43:26 <Rarrikins> > [1..5] >>= return [1..5]
23:43:28 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5]
23:44:34 <cheater> :t return [1..5]
23:44:36 <lambdabot> (Num t, Monad m, Enum t) => m [t]
23:49:26 <Maxdamantus> :t (\op operand -> let nvm = [1..5] `op` operand in (op, operand)) (>>=) (return [1..5])
23:49:27 <lambdabot> (Num b, Num a, Enum b, Enum a) => ([a] -> (a -> [b]) -> [b], a -> [b])
