00:07:36 <mstruebing> thx this is working
00:14:21 <Xnuk> stack ghci -- filename.hs
00:19:19 <Xnuk> Does anyone know how to get `Compiler` object in Distribution.Simple.Compiler? Can I get one or should I make it myself?
00:21:54 <sdx23> Xnuk: configure from e.g. https://hackage.haskell.org/package/Cabal-1.24.0.0/docs/Distribution-Simple-GHC.html
00:23:37 <Xnuk> sdx23: Thank you
00:25:28 <kirillow> how do i "add-source" in stack?
00:26:12 <sdx23> kirillow: what is add-source?
00:26:24 <liste> kirillow: https://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
00:26:51 <liste> that's a very frequently asked question, I should make a shortcut for that
00:27:04 <kirillow> liste: thank you!
00:29:13 <sdx23> aparrently some cabal feature I've missed out on
00:35:08 <liste> sdx23: it allows sandboxes to use sources from other folders
00:44:52 <hvr> sdx23: if you want a newer ghc on ubuntu/debian, you don't need to "use stack anyways"
00:45:19 <hvr> sdx23: there's e.g. http://downloads.haskell.org/debian/
00:50:04 <sdx23> hvr: right, you don't need. But I'd still recommend to do it.
00:50:22 <hvr> sdx23: well, bad advice on Ubuntu 16.10 though ;-)
00:50:30 <sdx23> hvr: is it broken?
00:50:38 <hvr> sdx23: yep, Stack installs a broken bindist afaik
00:51:06 <hvr> (nor would it upgrade an existing one which doesn't match the current os release)
00:51:22 <hvr> all the stuff you'd get for free with system-packaged ghcs...
00:52:36 <merijn> Ok, one more try: Anyone know about the promptness of finalizers for ForeignPtrs in GHC? The documentation of base says there's "no guarantees" but I vaguely recall GHC being a lot more strict than that, but can't find the details
00:52:57 <hvr> merijn: try on #ghc maybe
00:53:11 <sdx23> hvr: in itself I'm also quite a fan of system wide installations of things. But with cabal hell I gave up at some point and am quite intrigued using stack nowadays.
00:53:27 * hackagebot pandoc-stylefrommeta 0.1.0.0 - Pandoc filter to customize links, images and paragraphs  https://hackage.haskell.org/package/pandoc-stylefrommeta-0.1.0.0 (lyokha)
00:53:40 <hvr> sdx23: you may have missed that "cabal hell" is addressed by http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
00:54:22 <merijn> hvr: Yeah, that was my backup plan :)
00:54:43 <sdx23> hvr: I learned about new-build a few months back. Did it get usable/stable in the meantime?
00:55:27 <hvr> sdx23: not yet for beginners, but I (& others) dogfood it exclusively for all my personal & dayjob projects
00:55:43 <hvr> sdx23: and it's a great improvement over the old-style workflows
00:56:12 <sdx23> hvr: I've like just finished getting used to stack workflows and here's the new thing already :(
00:56:35 <hvr> sdx23: sorry... it takes time to get things done properly...
00:57:04 <hvr> and new-build is more ambitious than stack
00:57:15 <sdx23> hvr: yeah. By the way, thanks for the hint. Looks nicely packaged using the alternatives system *thumbsup*
00:57:55 <hvr> sdx23: also e.g. its good enough for travis and can even be made to use stackage snapshots quite easily: https://travis-ci.org/hvr/cassava/builds/169807732
00:58:27 * hackagebot jason 0.1.0.1 - A fast JASONETTE-iOS JSON combinator library for haskell.  https://hackage.haskell.org/package/jason-0.1.0.1 (Lupino)
00:58:40 <hvr> s/good/stable/
01:33:28 * hackagebot lucid 2.9.7 - Clear to write, read and edit DSL for HTML  https://hackage.haskell.org/package/lucid-2.9.7 (ChrisDone)
01:33:30 * hackagebot yesod-core 1.4.26 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.26 (MichaelSnoyman)
01:38:24 <tdammers> just wondering... is there a flavor of printf that outputs to a String (or Text or Builder or whatever) rather than taking a Handle?
01:39:07 <tdammers> or, alternatively, is there something like C++'s stringstreams where you can produce a handle that acts on a memory buffer rather than an actual file?
01:40:07 <phadej> tdammers: 
01:40:07 <phadej> > printf "%d" (1 :: Int) :: String
01:40:10 <lambdabot>  "1"
01:40:14 <tdammers> seriously
01:40:19 <tdammers> how did I not realize this
01:40:25 <phadej> http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Printf.html#t:PrintfType
01:40:57 <phadej> output is either [Char] or IO ()
01:41:09 <tdammers> again, how did I not realize this
01:41:31 <phadej> :)
01:42:52 <sdx23> its written plainly in the docs - but I didn't know either, and now I'm intrigued how this works.
01:43:21 <tdammers> it is written semi-plainly
01:43:38 <tdammers> no wait, it's as plain as it could possibly be
01:44:45 <tdammers> "The return value is either String or (IO a) (which should be (IO '()'), but Haskell's type system makes this hard)."
01:45:19 <tdammers> > pinrf "%d" (1 :: Int) >>= putStrLn
01:45:22 <lambdabot>  error:
01:45:22 <lambdabot>      Variable not in scope: pinrf :: [Char] -> Int -> IO String
01:45:23 <tdammers> hrrngh
01:45:28 <tdammers> > printf "%d" (1 :: Int) >>= putStrLn
01:45:30 <lambdabot>  error:
01:45:30 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘()’
01:45:30 <lambdabot>          arising from a use of ‘printf’
01:47:08 <tdammers> so it kind of does enforce ()
01:47:57 <bartavelle> I didn't even realize you could use printf in IO :)
01:48:11 <merijn> Yay! Learning!
01:48:13 <sdx23> doesn't the use of putStr in the instance implementation imply IO () ?
01:50:15 <phadej> it's a ~ () => IO a
01:50:28 <phadej> which is a bit different than direct IO a
01:50:31 <phadej> which is a bit different than direct IO ()
01:53:24 <paolino> hello, I'm trying to understand the difference between data family and gadt, I have this example :https://gist.github.com/paolino/0ca78782c975385c28cfa52fec86b9c8
01:54:54 <sdx23> phadej: so a ~ () implies type equality. I'd understand this as "you may substitute the following a by ()". But this must be wrong. What's happening there?
01:55:53 <phadej> sdx23: the instance search doesn't consider contexts, so it matches against IO a, and then tries to satisfy a ~ ()
01:56:19 <phadej> i.e. instance a ~ () => Cls (IO a) , and instance Cls (IO ()) behave different
01:56:36 <phadej> (in latter case you could have in addition, Cls (IO Int) for example)
01:58:02 <sdx23> ah, so the main point is to prevent a missleading error of "no instance for PrintfType IO String" e.g. in tdammers example?
01:59:33 <phadej> .. or someone to write that instance (though it prevented by not re-exporting spr)
01:59:41 <phadej> also no need to FlexibleInstances
01:59:59 <phadej> and "better" instance resolution
02:00:47 <sdx23> I learned something :) thank you
02:01:11 <phadej> see e.g. http://chrisdone.com/posts/haskell-constraint-trick
02:01:52 <amx> what is ~ called? unifies with? types as?
02:03:10 <phadej> is equal
02:03:12 <sdx23> afair I've read this some time ago, but didn't get why it's useful or even what was the point. Understanding it on a realworld example was quite nice.
02:04:11 <sdx23> amx: https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/equality-constraints.html
02:04:19 <phadej> uh, old docs
02:04:23 <phadej> you did google ;)
02:04:43 <sdx23> sure i did
02:05:08 <phadej> http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#equality-constraints
02:05:13 <phadej> let's spread the newer one
02:15:37 <paolino> phadej, is it like, if instance resolution got here in this instance, then the to types around the ~ can be freely exchanged to satisfy the constraints  ?
02:15:55 <paolino> *two
02:23:30 * hackagebot pandoc-stylefrommeta 0.1.0.1 - Pandoc filter to customize links, images and paragraphs  https://hackage.haskell.org/package/pandoc-stylefrommeta-0.1.0.1 (lyokha)
03:01:15 <lolisa> @pl bimap f g (x, y) = (f x, g y)
03:01:16 <lambdabot> bimap = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
03:01:28 <liste> now that looks nasty
03:01:35 <lolisa> Great...
03:01:35 <osfabibisi> woo, my lucid docs whining yesterday is already fixed in head
03:01:41 <osfabibisi> chrisdone++
03:02:34 <reactormonk> lolisa, that autogenerated code?
03:02:55 <lolisa> reactormonk, I dont get what you are asking...
03:03:06 <liste> lolisa: @pl doesn't always produce optimal results though
03:03:20 <liste> you may be able to hand-simplify it
03:03:23 <M2tias> that cannot be the optimal result :D
03:03:24 <reactormonk> So @pl generates code for you based on type signatures.
03:03:41 <liste> reactormonk: no, it transforms pointful code to point-free
03:03:59 <liste> djinn and exference generate code from type signatures
03:04:12 <liste> @djinn a -> b -> a
03:04:12 <lambdabot> f a _ = a
03:04:56 <reactormonk> liste, not sure about the definitions of either, but that code looks like a lot of points to me (?)
03:05:42 <liste> reactormonk: "point" comes from analytical geometry
03:05:46 <M2tias> @djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:05:46 <lambdabot> f a b (c, d) = (a c, b d)
03:05:57 <M2tias> :D
03:06:09 <lolisa> @pl s f x arg = f arg (x arg)
03:06:09 <lambdabot> s = ap
03:07:05 <liste> reactormonk: f x = 2 * x -- f(x) is 2 * x in point x
03:07:17 <lolisa> @help
03:07:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:07:20 <liste> reactormonk: f = (2*) -- we take the point away
03:07:21 <lolisa> @list
03:07:22 <lambdabot> What module?  Try @listmodules for some ideas.
03:07:26 <lolisa> @help list
03:07:26 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:07:29 <liste> lolisa: you can /msg lambdabot
03:07:35 <lolisa> sry
03:07:44 <reactormonk> liste, so the symptom is removing the variable names from the function call?
03:08:28 <liste> reactormonk: yes, basically
03:08:32 * hackagebot regex-do 2.1 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.1 (procione)
03:08:48 <M2tias> !t ap
03:09:00 <liste> reactormonk: https://wiki.haskell.org/Eta_conversion
03:09:01 <reactormonk> liste, cool, thanks.
03:09:59 <reactormonk> liste, "But pointfree has more points!" - so I'm not the first one and won't be the last one.
03:15:09 <ski> lolisa : .. do you see how to derive that pointless expression of `curry' ?
03:15:32 <lolisa> sort of... I dont really get the intuition, but I get it if I see myself as a machine
03:15:41 <ski> reactormonk : "points" here refers to elements/inhabitants of your input (and intermediate and output) types
03:16:02 <ski> @src curry
03:16:03 <lambdabot> curry f x y = f (x, y)
03:16:19 <ski> so
03:16:25 <reactormonk> ski, got it.
03:16:28 <ski>   curry f x y = f (x,y)
03:16:42 <ski>               = f ((,) x y)
03:16:55 <ski>               = (f . (,) x) y
03:17:08 <ski>   curry f x = f . (,) x
03:17:11 <reactormonk> Yeah, I've done that before in other languages (haskells little brother, scala), so I know the idea, I just haven't heard the terminology.
03:17:24 <ski>             = ((f .) . (,)) x
03:17:38 <ski>   curry f = (f .) . (,)
03:18:21 <ski>           = (.) f . (,)
03:18:34 <ski>           = (. (,)) ((.) f)
03:18:42 <ski>           = ((. (,)) . (.)) f
03:18:52 <ski>   curry = (. (,)) . (.)
03:19:09 <ggVGc> I'm gonna cook some curry today
03:19:10 <ggVGc> fwiw
03:19:23 <lolisa> just a sec... you lost me at (f .) . (,) = (.) f . (,) ...
03:19:42 * LKoen finally understands why in some cases it's better to be verbose than to be symbolic
03:19:43 <phadej> (1 +) = (+1) 1
03:19:48 <phadej> (1 +) = (+) 1
03:19:50 <ski> well, `(f .)' means `(.) f', just like `(2 /)' means `(/) 2'
03:20:06 <phadej> ^ :+1:
03:20:18 <lolisa> ooh, I thought you swap the ., now I get it
03:21:07 <lolisa> I usually start from the type and ignore the value, never know I could do it this way... now let me try to do it for bimap...
03:21:18 <ski> in the step from `(.) f . (,)' to `(. (,)) ((.) f)', i swapped the order of the `.'s
03:22:27 <lolisa> bimap f g x = (,) (f $ fst x) (g $ snd x)
03:22:39 <M2tias> lolisa: \o/
03:22:47 <lolisa> =w=
03:22:48 <lolisa> bimap f g x = (,) (f $ fst x) (g $ snd x)
03:22:54 <lolisa> (,) (f $ fst x) (g $ snd x)
03:22:54 <ski> generally, we try to masssage the body into the form `(...) x', `x' being the last parameter to the left of `=', and `x' not occuring in `...'
03:23:23 <ski> in your case, you have `x' in two places, so you need to handle that somehow
03:23:30 <lolisa> w or s?
03:23:48 <ski> possibly by using `S'/`ap', or `liftA2',`liftM2' for `(rho ->)', if you know what i mean
03:24:04 <ski> yeah, `w'/`join' for `(rho ->)' could possibly be used as well
03:24:24 <ski> one could also consider `(&&&)' for `(->)'
03:24:37 <lolisa> sadly I dont have lift in the dsl...
03:25:13 <ski> > (f &&& g) x     :: (Expr,Expr)
03:25:16 <lambdabot>  (f x,g x)
03:25:24 <phadej> @pl join f x = f x x
03:25:25 <lambdabot> join = join
03:25:36 <phadej> @pl jof x = f x x
03:25:36 <lambdabot> jof = join f
03:25:39 <phadej> :(
03:25:45 <ski> or, in this case, `(***)'
03:25:51 <lolisa> the language is simply typed, so I only got SKI, BCKW with me :(
03:25:59 <ski> ok
03:26:27 <phadej> can intepret that that point-free style is intristically linear, and you have to use join to duplicate inputs?
03:26:56 <ski> phadej : or something of equal power, like `S'/`ap'/`(<*>)'
03:27:09 <ski> (or `(&&&)')
03:27:27 <phadej> ski: and const to drop input?
03:27:31 <ski> yep
03:27:34 <phadej> cool
03:27:41 <phadej> didn't realised that
03:27:43 <ski> (aka `K'/`pure'/`return')
03:28:52 * ski tries to recall which was which of `B' and `C' ..
03:29:07 * ski ought to know this by heart
03:29:15 <lolisa> B: compose
03:29:17 <lolisa> C: flip
03:29:46 <ski> yeah, i think the reason i'm constantly confusing them is because `C' makes me think "compose"
03:30:44 <lolisa> same here... get used to it after impling ~10 functions..
03:31:28 <ski> lolisa : should i try to abstract `x' away from `bimap f g x' here, publicly, or do you want to ponder it yourself ?
03:31:59 <lolisa> yeah, i need help, cant figure out how to use w...
03:32:35 <ski> there's probably many ways to do this. the simplest is probably to use `S'. but perhaps the result will look better with `W'
03:32:49 <lolisa> wait I think I am getting it
03:32:56 <lolisa> (,) (f $ fst x) (g $ snd x)
03:35:21 <lolisa> ((,) (g $ snd x)) (f $ fst x)
03:35:42 <ski> (ok, i think i'm done with abstracting away `x')
03:36:01 <lolisa> ((. (,) (g . snd)) x) (f $ fst x)
03:36:42 <lolisa> I think it is a good idea to look at it... I am having some obstacle :( beside I will be compiling HOAS in the future anyway...
03:37:10 <ski> hm, why did you swap around the order of `f' and `g' ?
03:37:50 <lolisa> I dont know, I think I should get x to the outside of both function, and then use S
03:38:28 <ski> exchanging `f' and `g', i think you possibly still meant `(,) . f . fst', not `(. (,) (f . fst))'
03:38:33 * hackagebot carte 0.1.0.0 - Carte: A commandline pastebin server.  https://hackage.haskell.org/package/carte-0.1.0.0 (cdetroye)
03:39:09 <ski> "get x to the outside of both function" is doing it bottom-up. it is also possible to do it top-down, starting with using `S' "on the top"
03:39:22 <ski> (both are of course valid methods)
03:40:10 <ski> (should i show what i mean, for the top-down approach ?)
03:40:42 <m1dnight_> ! 
03:40:44 <m1dnight_> My package! 
03:40:51 <lolisa> yeah, I dont quite know... do you mean splitting it into two lambda andthen recurse on them?
03:41:07 <ski> yes
03:41:53 <ski> (you have seen how to convert lambda calculus to SKI combinators, removing abstractions, right ?)
03:42:17 <lolisa> yep
03:42:35 <ski> well, what i was doing was basically that
03:42:55 <lolisa> S (\x -> (,) (f $ fst x)) (g . snd)
03:43:14 <ski> (but improving the result a little bit by spotting where `C' and `B' can be used in place of `S' (and subseequent `K'))
03:43:21 <lolisa> ooh... I love top down method
03:43:41 <lolisa> S (\x -> (,) ((f . fst) x)) (g . snd)
03:43:53 <lolisa> S ((,) . (f . fst)) (g . snd)
03:44:00 * ski nods .. that's it :)
03:44:20 * ski is curious about why lolisa wants to do this ..
03:44:46 <lolisa> Ooh, I am writing a dsl, and I wanna add some function to the language while keeping the core slow
03:44:52 <lolisa> Ooh, I am writing a dsl, and I wanna add some function to the language while keeping the core minimal*
03:45:23 <lolisa> And my compiling HOAS method is quite inefficent, so I tend to avoid using it unless it seems hopeless
03:45:32 <ski> hm, and i assume you want to be able to traverse the DSL structure
03:45:48 <lolisa> exactly, so I dont want raw HOAS in the AST tree
03:46:53 <ski> hmm .. i wonder whether one could use NbE to compile the HOAS ..
03:46:54 <lolisa> I know the Unembedding domain-specific languages paper, but dont have time to work on it yet... working on core functionality right now, so deciding to eat a bit of debt
03:47:05 <lolisa> NbE?
03:47:12 <ski> Bormalization-by-Evaluation
03:47:14 <ski> er
03:47:16 <ski> Normalization
03:47:46 <lolisa> It has Y... does it hurt?
03:48:28 * ski looks up "Unembedding domain-specific languages" paper
03:49:16 <lolisa> BTW the language is at https://github.com/ThoughtWorksInc/DeepDarkFantasy/, in case anyone is interested :)
03:50:06 <lolisa> S ((,) . (f . fst)) (g . snd)
03:50:24 <lolisa> S ((,) . (f . fst)) (((.) snd) g)
03:50:49 <lolisa> (S ((,) . (f . fst))) . ((.) snd)
03:51:25 <ski> (from what i understand, NbE tends to possibly have problems with recursive stuff. e.g. if you reify `\xs -> [0,1,2] ++ xs', that's fine, but if you try it on `\xs -> xs ++ [0,1,2]', it doesn't work. perhaps there's further work to handle such things ..)
03:52:05 <lolisa> I see... or maybe the best way it to rewrite the whole thing with DBI... Ugly but work very well
03:52:44 <lolisa> (CB) ((.) snd) (S ((,) . (f . fst))) 
03:53:39 <lolisa> (CB) ((.) snd) (S ((,) . (CB fst f))) 
03:53:53 <ski> `CB' ?
03:53:59 <lolisa> C apply with B
03:55:22 <lolisa> (CB) ((.) snd) (S ((.) (,) (CB fst f))) 
03:55:50 <lolisa> (CB) ((.) snd) (S (((.) (,)) (CB fst f))) 
03:56:33 <lolisa> (CB) ((.) snd) (S (((.) (,)) . (CB fst) f)) 
03:57:07 <lolisa> (CB) ((.) snd) (S (((.) (,)) (CB fst) f)
03:57:17 <lolisa> (CB) ((.) snd) (S (((.) (,)) (CB fst))) f)
03:57:36 <lolisa> (CB) ((.) snd) (S . (((.) (,)) (CB fst))))
03:58:12 <ski> hm, i think you made a mistake
03:58:30 <lolisa> oh, where?
03:58:38 <ski> after
03:58:44 <ski>   (C B) ((.) snd) (S (((.) (,)) (C B fst f)))
03:59:49 <ski>   (C B) ((.) snd) (S (((.) (,) . C B fst) f))
03:59:49 <lolisa> oh I see what you mean
04:00:02 <ski>   (C B) ((.) snd) ((S . ((.) (,) . C B fst)) f)
04:01:19 <ski> (after the first line, which i repeated from you, you missed a pair of brackets, and after that you seem to just have forgotten about the `.' you just introduced ?)
04:01:41 <lolisa> yeah, I got that... Now to infer the type in scala :(
04:06:34 <kuribas> Wouldn't it be nice if haskell allows a do block after a function?
04:06:50 <kuribas> like f do {action1; action2}
04:07:01 <ertesx> kuribas: f (do …)
04:07:04 <ski> yes, one should be able to use `fo'
04:07:05 <kuribas> instead of f (do ...)
04:07:11 <ertesx> f $ do …
04:07:19 <ski> yes, one should be able to use `do'/`if'/`let'/`case' there, without `$' or `>>=' or ...
04:07:48 <ski> (oh, and `\' as well, of course)
04:07:50 <ertesx> kuribas: you're literally arguing about a single character there =)
04:08:00 <ski> `$' is ugly
04:08:04 <kuribas> ertesx: no, $ doesn't always work
04:08:15 <ski> (also higher-rank)
04:08:19 <kuribas> for example: a <$> b (do stuff)
04:08:27 <kuribas> a <$> b $ do stuff doesn't work
04:09:02 <ertesx> well, two characters then
04:09:20 <ski> one of them possibly a long way down ..
04:09:36 <kuribas> ertes: resulting in ugly layout
04:10:58 <ertes> yeah, i see what you mean
04:12:14 <ertes> so you want application to do blocks with the same priority as other function application
04:12:24 <kuribas> ertes: yeah
04:12:36 <kuribas> ertes: and if /let/case
04:13:37 <kuribas> we could write a ticket for ghc...
04:13:38 <ski> (and `\')
04:15:56 <kuribas> ski: yeah
04:15:56 <kuribas> I wonder if it would break anything
04:16:17 <ertes> can't think of anything
04:17:27 <kuribas> Would I need to write a patch for the ticket?
04:18:34 <merijn> kuribas: tickets are good, patches are better ;)
04:18:43 <kuribas> ok :)
04:20:46 <ertes> kuribas: think about layout…  maybe you can find a way to make it work for things that aren't to the far right
04:21:28 <kuribas> yes
04:22:05 <ertes> f (do …) <|> g (do …)  -- if the (<|>) is less indented than the first do block
04:23:43 <kuribas> that will translate to f do {actions...} <|> g do {actions}
04:24:33 <kuribas> but f let a in b <|> g let c in d ==> f let {a} in b <|> g let {c} in d
04:25:12 <kuribas> That would be like f let {a} in (b <|> g let {c} in d)
04:25:30 <kuribas> since there is no layout after the "in" keyword.
04:26:36 <ertes>    f let a in b
04:26:42 <ertes> <|> g let c in d
04:26:53 <ertes> ah, there is no layout at all
04:31:14 <kuribas> What would be a good extension name?  FunctionKeywordArguments?
04:31:49 <merijn> kuribas: I'd leave that bikeshed fight until later :p
04:31:55 <merijn> Worry about implementation first :p
04:32:10 <kuribas> right, I've never hacked ghc before...
04:32:54 <merijn> kuribas: I wrote a potentially out of date quickstart guide for when I submitted a patch :)
04:33:08 <merijn> kuribas: https://gist.github.com/merijn/c01405e6c5a78a1c4ccb
04:33:26 <merijn> kuribas: Also, there was a PDF with workflow images on the ghc-devs/haskell-cafe lists like 1 or 2 weeks back
04:33:40 <merijn> kuribas: And of course #ghc
04:33:41 <kuribas> https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/FixingBugs
04:33:59 <kuribas> or better: https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/AddingFeatures
04:34:28 <hexagoxel> kuribas: https://ghc.haskell.org/trac/ghc/wiki/ArgumentDo
04:35:13 <kuribas> that's fast!
04:36:56 <kuribas> "This makes basic do-syntax more approachable to newbies; it is a commonly asked question as to why the $ is necessary. "
04:37:02 <kuribas> meaning it's more intuitive
04:38:35 * hackagebot staversion 0.1.2.0 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.1.2.0 (debugito)
04:39:38 <kuribas> On the mailing list I see roughly 13 people in favor of the proposal and 12 people against it.
04:41:37 <kuribas> Can you vote for extensions?
04:42:59 <tdammers> do is doable, if would break things
04:43:13 <tdammers> maybe
04:43:26 <tdammers> no wait, scratch that
04:45:45 <kuribas> tdammers: you mean wouldn't?
04:45:57 <kuribas> I think it doesn...
04:46:46 <tdammers> I was being confused
04:48:13 <tdammers> what I meant was that "f do { ... }" would work, because it is currently a parser error, so there is no harm in making it work - new code that uses this syntax would just become valid, and old code that uses it doesn't exist
04:48:56 <tdammers> and I thought that "f if cond then something else somethingElse" would break, but on further thinking I guess it won't
04:50:01 <tdammers> however "f if cond then something else somethingElse andMoreArgs" might lead to misleading code
04:50:22 <tdammers> is it "f (if cond then something else somethingElse) andMoreArgs"?
04:50:34 <tdammers> or is it "f if cond then something else (somethingElse andMoreArgs)"?
04:51:02 <tdammers> the way it is now makes disambiguation mandatory
04:52:18 <kuribas> tdammers: the last one
04:53:16 <tdammers> I think it is non-obvious enough to lead to confusion
04:53:47 <tdammers> and actually, in the case of "if", I'd be tempted to support removing it from the language altogether, in favor of a plain old base library function
04:53:58 <tdammers> if :: Bool -> a -> a -> a
04:54:28 <tdammers> (which, incidentally, already exists, but is currently called if', and not in base)
04:55:12 <kuribas> tdammers: yeah, I agree
04:55:37 <kuribas> "if then else" always looks ugly in my code
04:56:25 <tdammers> it *is* ugly
04:56:46 <tdammers> there's no real reason for it to be a special syntax construct when none of the other Prelude functions are
04:56:55 <kuribas> But I doubt it will ever go away, even in haskell 2.0
04:56:55 <tdammers> except maybe unary minus
04:57:07 <tdammers> yeah, the breakage would be too much
04:57:27 <lpaste> milad pasted “question” at http://lpaste.net/334727
04:57:29 <tdammers> I'd love some sort of NoBuiltinIf language extension though
04:57:44 <merijn> :t bool
04:57:46 <lambdabot> a -> a -> Bool -> a
04:58:42 * tdammers headdesks
04:59:01 <miladz89> hello I have question about CIS 194, I copied the question to paste bin. can someone look it up
04:59:08 <merijn> Although do note that that's bool-elimination, not if-then-else
04:59:12 <miladz89> and help me with it
04:59:23 <merijn> Which implies a different argument order
04:59:30 <kuribas> miladz89: it would help if you pasted the url
04:59:37 <kuribas> oh you did...
04:59:43 <miladz89> http://lpaste.net/334727
05:01:01 <kuribas> miladz89: that's "class" with lower case c
05:02:07 <lpaste> milad revised “question”: “question” at http://lpaste.net/334727
05:02:08 <kuribas> And you may need the "FlexibleInstances" extension
05:03:02 <miladz89> kurabis: I mistyped class, in my code it is lower case. and I will look into flexibleInstances !
05:03:54 <miladz89> kurabis: It solved my problem, thank you.
05:07:34 <hexagoxel> tdammers: what about case-of? could be deprecated in favour of lambdacase as well .. :D
05:08:19 <tdammers> pattern matching is too useful and too much of a core feature to remove entirely
05:08:31 <tdammers> and lambdas are mildly ugly, so I'd keep case-of in the language
05:08:43 <kuribas> hexagoxel: lambdacase isn't a core feature
05:08:50 <kuribas> hexagoxel: function application is
05:10:20 <tdammers> lambda case is useful and non-intrusive enough to deserve a spot in the language standard IMO
05:14:00 <kuribas> tdammers: and it would benefit from ArgumentDo
05:15:24 <hexagoxel> if you find lambdas ugly, and ugliness is the basis of removing if-then-else, i am not convinced :p
05:18:25 <danilo2> Hello guys! What differences would be between using Ghc.Prim.Any and custom implementation like data Any where Any :: forall a. a -> Any  ? I'm asking about any differences including performance / optimizations etc
05:20:25 <hexagoxel> and if the special-precedence multiple-argument grammar of if-then-else is what makes it ugly, then case-of is ugly in much the same way, and the translation to lambdacase would be an improvement similar to translating to `bool`
05:21:02 <kuribas> hexagoxel: how would you translate case of?
05:21:04 <lyxia> danilo2: GHC.Prim.Any does not use constructors.
05:22:06 <kuribas> hexagoxel: (\case ...) var?  I find that more ugly than "case var of ..."
05:22:42 <kuribas> hexagoxel: while if a then b else c becomes if a b c
05:23:02 <danilo2> lyxia: so there will be additional overhead because its data and not a newtype then? And cause we cannot define such existential newtype, we cannot implement our own countepart of GHCPrim.Any ?
05:23:28 <lyxia> right
05:23:36 * hackagebot req 0.1.0 - Easy-to-use, type-safe, expandable, high-level HTTP library  https://hackage.haskell.org/package/req-0.1.0 (mrkkrp)
05:24:32 <lyxia> I don't know if not being able to define a GADT with newtype is due to a fundamental limitation, or simply noone ever bothered implementing it.
05:28:34 <danilo2> lyxia: sure, thank you!
05:28:42 <kuribas> hexagoxel: I don't like that the variable is last, and the need for parens
05:37:27 <tdammers> I think it's reasonable to have a straightforward idiom for introducing a pattern matching context such that the match argument precedes the patterns
05:37:33 <lpaste> jarlg pasted “Understanding Conduit” at http://lpaste.net/334752
05:37:35 <tdammers> which is what case-of does
05:37:42 <jarlg> hey :)
05:38:46 <jarlg> Anyone familiar with conduit? I'm failing to implement filterC ^ ...
05:39:16 <hexagoxel> kuribas: var & \case
05:41:09 <kuribas> hexagoxel: anyway, case isn't going anywhere either...
05:42:11 <tdammers> also, I think that with 'case', it is usually such that case/of is invariably followed by a list of cases, and that list is almost always written in layout notation
05:42:42 <hexagoxel> but \case, syntactically, has just one argument (a list of clauses or what they are called)
05:42:54 <tdammers> pseudo-argument, I would argue
05:42:54 <lyxia> jarlg: can you link to the tutorial
05:42:59 <merijn> Is there a quick function to show integers in hex notation?
05:43:16 <kuribas> hexagoxel: you could argue that case is more primitive than \case
05:43:59 <lyxia> jarlg: you return as soon as the predicate is not satisfied, that doesn't sound like what a filter should do.
05:44:22 <jarlg> lyxia: https://github.com/snoyberg/conduit, search for "implementing filterC"
05:45:01 <lyxia> > ({- the difference between -} filter even [1 .. 10], {- and -} takeWhile even [1 .. 10])
05:45:04 <lambdabot>  ([2,4,6,8,10],[])
05:45:11 <jarlg> lyxia: oh, right. I should just disregard it and continue filtering, of course!
05:45:40 <lyxia> jarlg: okay, it's just that the tutorial doesn't include the implementation.
05:46:08 <jarlg> lyxia: Thanks, I got it right :)
05:46:24 <lyxia> Did you mean the one provided by conduit or conduit-extra
05:47:44 <lyxia> oh it's in conduit-combinators
05:48:23 <ania123> t ype Pa i r a = ( a , a )
05:48:31 <ania123> t ype Pair a = ( a , a )
05:48:38 <ania123> type Pair a = ( a , a )
05:48:52 <ania123> Pair is here parametres, is not?
05:49:12 <lyxia> ania123: Can you reformulate your question
05:49:19 <liste> ania123: Pair is a type alias you're defining, `a' is a type parameter
05:51:13 <ania123> liste: is Pair kind of constructor?
05:51:46 <liste> ania123: it's an alias to (,), which is a type constructor
05:52:58 <buglebudabey> would someone be able to help me with my gradient descent algorithm? I am supposed to be updating values and my algorithm is not converging (it's in haskell) http://stackoverflow.com/questions/40527998/gradient-descent-algorithm-not-converging-in-haskell
05:55:26 <djellemah> How do I say fmap read $ Just "99" so it evaluates to 99 :: Int ?
05:56:41 <kuribas> > fmap (read $ Just "99") :: Int
05:56:44 <lambdabot>  error:
05:56:45 <lambdabot>      • Couldn't match expected type ‘Int’
05:56:45 <lambdabot>                    with actual type ‘f0 a0 -> f0 b0’
05:56:58 <ggVGc> djellemah: fromMaybe 0 (read "99")
05:57:09 <ggVGc> hm
05:58:17 <kuribas> > (fmap read (Just "99")) :: Maybe Int
05:58:20 <lambdabot>  Just 99
05:58:23 <ggVGc> ^^^
05:58:48 <ggVGc> (fmap read (Just "hey")) :: Maybe Int
05:58:56 <ggVGc> > (fmap read (Just "hey")) :: Maybe Int
05:58:58 <lambdabot>  Just *Exception: Prelude.read: no parse
05:59:02 <ggVGc> ^ not so good
05:59:25 <djellemah> I think I meant evaluates to Just 99 :-S
05:59:27 <kuribas> djellemah: he didn't really specify it
05:59:50 <ggVGc> djellemah: the issue is that read throws exceptions
06:00:13 <ggVGc> djellemah: you might want to use readMay from https://hackage.haskell.org/package/safe-0.3.10/docs/Safe.html
06:00:58 <djellemah> OK, didn't know it throws exceptions, thanks.
06:02:05 <djellemah> I guess what I'm really asking is this: is there a way (type annotation maybe?) to specify that read should be of type ::Int when passing it to fmap?
06:02:06 <merijn> ggVGc: readMaybe is in base, so a better option
06:02:18 <ggVGc> merijn: ah, yeah, true
06:02:21 <merijn> :t Text.Read.readMaybe
06:02:23 <lambdabot> Read a => String -> Maybe a
06:03:18 <ggVGc> djellemah: (read "99") :: Int
06:03:29 <ggVGc> > (read "99") :: Int
06:03:31 <lambdabot>  99
06:03:42 <djellemah> Exactly, but how do I tell fmap that?
06:04:11 <djellemah> Let me know if I'm barking up the wrong tree here ... ;-)
06:04:52 <ggVGc> djellemah: kuribas gave it, unless you mean something else
06:04:57 <ggVGc> > (fmap read (Just "hey")) :: Maybe Int
06:05:00 <lambdabot>  Just *Exception: Prelude.read: no parse
06:05:00 <ggVGc> sorry
06:05:05 <ggVGc> > (fmap read (Just "99")) :: Maybe Int
06:05:07 <lambdabot>  Just 99
06:05:34 <djellemah> ah, ok, got it. thanks :-D
06:05:36 <ggVGc> djellemah: is that not what you mean?
06:05:38 <ggVGc> ah, alright
06:05:38 <amx> djellemah: fmap (\x -> read x :: Int) f?
06:06:24 <kuribas> > read@Int "90"
06:06:26 <lambdabot>  error:
06:06:29 <lambdabot>      Pattern syntax in expression context: read@Int
06:06:29 <lambdabot>      Did you mean to enable TypeApplications?
06:07:26 <djellemah> yup, that works too.
06:08:05 <djellemah> thanks
06:13:38 * hackagebot log-utils 0.2.2 - Utils for working with logs  https://hackage.haskell.org/package/log-utils-0.2.2 (MikhailGlushenkov)
06:17:01 <ski> tdammers : `f if cond then something else (somethingElse andMoreArgs)', obviously (cf. "dangling else")
06:17:40 <ski> hexagoxel : .. in SML, `case ... of ... => ... | ...' is a derived form for `(fn ... => ... | ...) (...)'
06:23:09 <kuribas> then let is also not primitive
06:23:20 <ski> ?
06:23:54 <merijn> kuribas: How so?
06:25:28 <kuribas> let a = val in b == (\a -> b) val
06:27:17 <ski> doesn't handle recursion, nor polymorphism (without explicit higher-rank signature)
06:27:27 <kuribas> ski: with fix?
06:27:47 <ski> mutual recursion is a little bit trickier
06:28:13 <ski> (not very, but a little)
06:28:38 <ggVGc> don't think I've ever really used mutual recursion
06:28:48 <ggVGc> more than in excecises in the past
06:30:56 <kuribas> maybe "snd (fix (\(a,b) ->  (val,b)))"?
06:32:14 <kuribas> or better "snd (fix (\(a,_) -> (val,b)))"?
06:32:59 <kuribas> > snd (fix (\(a,_) -> (id, a 20)))
06:33:05 <lambdabot>  mueval-core: Time limit exceeded
06:33:42 <quchen> Anyone else using HLint with Atom?
06:33:51 <quchen> It ignores my HLint.hs file for some time now
06:35:46 <ski> > snd (fix (\ ~(a,_) -> (id,a 20)))
06:35:48 <lambdabot>  20
06:35:59 <kuribas> ski: ah, thanks!
06:36:16 <kuribas> :t \b -> snd (fix (\(a,_) -> (id, a b)))
06:36:18 <lambdabot> b -> b
06:38:31 <kuribas> ski: fix doesn't handle polymorphism?
06:39:33 <ski> > snd (fix (\ ~(id,_) -> (\x -> x,(id "20",id False))))
06:39:36 <lambdabot>  error:
06:39:36 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
06:39:38 <lambdabot>      • In the first argument of ‘id’, namely ‘False’
06:41:15 <kuribas> ski: ah I see
06:41:37 <ski> > snd (fix ((\ ~(id,_) -> (\x -> x,(id "20",id False)))) :: (forall a. a -> a,(String,Bool)) -> (forall a. a -> a,(String,Bool)))
06:41:39 <lambdabot>  error:
06:41:39 <lambdabot>      • Illegal polymorphic type: forall a. a -> a
06:41:39 <lambdabot>        GHC doesn't yet support impredicative polymorphism
06:42:39 <kuribas> > snd (fix ((\ ~(id,_) -> ((\x -> x)::forall a. a -> a,(id "20",id False)))))
06:42:40 <lambdabot>  error:
06:42:41 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
06:42:41 <lambdabot>      • In the first argument of ‘id’, namely ‘False’
06:45:36 <kuribas> > snd (fix ((\ ~(id,_) -> (\x -> x,(id "20",id False)))) :: (forall a. a -> a,(String,Bool)))
06:45:38 <lambdabot>  error:
06:45:39 <lambdabot>      • Illegal polymorphic type: forall a. a -> a
06:45:39 <lambdabot>        GHC doesn't yet support impredicative polymorphism
06:46:09 <kuribas> isn't that just existential qualification?
06:48:28 <ski> no ?
06:48:44 <ski> `id' is monomorphic (higher-rank types are not inferred)
06:49:56 <ski> @type fix :: ((forall a. [a] -> [a]) -> (forall a. [a] -> [a])) -> (forall a. [a] -> [a])  -- it would need to use this (higher-rank) type for `fix', if you e.g. wanted to construct `reverse' using `fix' and `(++)' (say)
06:49:57 <lambdabot> error:
06:49:57 <lambdabot>     • Couldn't match type ‘a1’ with ‘a2’
06:49:57 <lambdabot>       ‘a1’ is a rigid type variable bound by
06:50:18 <ski> in your case, it requires impredicative types, because you have a `forall' inside a `(,)'
06:51:28 <kuribas> ah, I see
06:54:33 <ski> of course, sometimes you don't need polymorphism "inside" the recursion (aka "polymorphic recursion"), only "outside"
06:54:55 <ski> but Haskell does support polymorphic recursion (unlike the MLs)
06:58:40 * hackagebot regex-do 2.2 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.2 (procione)
07:12:11 <Bellator> Hi, I am a haskell noob. Could somebody tell me what am doing wrong here? http://pastebin.com/Yb6P1uSa
07:12:57 <bartavelle> Bellator, it's probably Int that you meant
07:13:01 <bartavelle> Bellator, not "int"
07:13:23 <bartavelle> Bellator, "int" is a type variable, not a concrete type. Concrete types start with uppercase letters
07:13:45 <dxtr> Also, wouldn't pattern matching be better here?
07:14:00 <Tuplanolla> Yes.
07:14:03 <bartavelle> oh I stopped at the first line :)
07:14:20 <danilo2> Its not that problem. The problem is caused by using of `do`. You do not need to use it there
07:14:30 <danilo2> `int` vs `Int` is just yet another error
07:14:36 <danilo2> but it didnt caused this message
07:14:43 <Bellator> Yes indeed changing it to Int is not helping
07:15:21 <Bellator> I needed to use two statements thats why I used do
07:15:31 <dxtr> Why do you need that?
07:15:40 <bartavelle> Bellator, you shouldn't use "do" until you are starting to learn/use monads
07:15:52 <ertes> (or IO)
07:16:00 <dxtr> 'head lst' just seems like noise
07:16:16 <DELB_> how do you produce a list of primes that returns as booleans?
07:16:18 <ertes> dxtr: it's a type error
07:16:21 <danilo2> guys, he cames probably form imperative world
07:16:24 <DELB_> primeTest :: [Bool]
07:16:30 <grantwu> What is null supposed to be
07:16:35 <DELB_> that's all I have for the function definition
07:16:46 <ertes> DELB_: what would that list look like?
07:16:54 <dxtr> ertes: what's a type error?
07:16:58 <danilo2> Bellator: why 2 statements? if you do 2 statements in Haskell the first one will be discarded because there are not mutual datatypes here. You should create a new variable and ue it later
07:17:01 <ab9rf> Bellator: haskell doesn't have "statements" the way an imperative language like C or Java does
07:17:08 <ertes> dxtr: (head lst) at that spot
07:17:09 <DELB_> if the list is
07:17:17 <dxtr> Right
07:17:18 <DELB_> 1, 2, 3, 4, 5, 6, 7, 8 up to infinity
07:17:23 <DELB_> then it would be: 
07:17:28 <Tuplanolla> I guess he wants an infinite sieve, ertes.
07:17:30 <ertes> DELB_: "if the list is"…  which list?
07:17:51 <ertes> Tuplanolla: i prefer not to guess =)
07:17:52 <bartavelle> DELB_, do you need something like "map isPrime [1..]", only efficient ?
07:17:56 <Tuplanolla> You need to step up your mind reading.
07:17:59 <DELB_> False, True, True, False, False, True, False, False
07:18:07 <Bellator> Haha, I am so lost
07:18:09 <DELB_> that's what the function would return
07:18:12 <ab9rf> DELB_: map isPrime [1..], although that will be EXTREMELY slow
07:18:31 <dxtr> Like.. infinitely slow? :p
07:18:35 <ertes> DELB_: first don't concern yourself with lists…  what you want is a primality test
07:18:49 <ertes> DELB_: later in an unrelated step you can use it on lists
07:19:36 <Bellator> What I am trying to do with two statements is first output the 'head' of the lst (like car list, as in scheme) then recurse the rest
07:19:53 <ab9rf> Bellator: what do you mean by "output"
07:20:08 <Tuplanolla> I'd use a proper prime number streaming algorithm and then convert the resulting list of primes into a list of truth values, DELB_.
07:20:21 <ertes> Bellator: are you familiar with pattern matching?
07:20:27 <DELB_> right so where do I go from here?
07:20:48 <ertes> DELB_: you write a primality test…  i'm assuming that you're doing this as an exercise, and efficiency is not a concern
07:20:56 <ertes> DELB_: isPrime :: Integer -> Bool
07:20:59 <DELB_> yeah, doesn't matter about efficency
07:21:08 <DELB_> you can't change the function definition
07:21:22 <Tuplanolla> Ignore my advice then, DELB_. It's quite tricky.
07:21:29 <bartavelle> DELB_, isPrime is a building block the function you want to write
07:21:35 <DELB_> ok
07:21:41 <ab9rf> DELB_: if you already have isPrime, then getting a list of booleans from that is a straightforward map
07:22:17 <DELB_> prime :: Integer -> Bool prime n = n > 1 && and [not(divides x n) | x <- [2..(n-1)]]
07:22:20 <DELB_> that will do for isPrime right?
07:22:25 <ertes> DELB_: imagine you want to map the list of natural numbers into a list of booleans that tell whether the number at that position was even
07:22:39 <ertes> DELB_: first you write a predicate that yes True for even numbers
07:22:40 <Bellator> ab9rf, just want to the elements in the list that are not divisble by n
07:22:44 <Bellator> ertes, no sir
07:22:57 <ertes> DELB_: this function happens to be predefined and is called 'even'
07:23:02 <ertes> DELB_: then you map that function over the list
07:23:05 <ertes> > map even [0..]
07:23:07 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
07:23:31 <ertes> DELB_: now apply that same implementation strategy to primality:  first write a primality test
07:23:58 <bartavelle> Bellator, pattern matching would be really handy for writing this function, are you learning on your own or is that some sort of class exercise ?
07:24:03 <DELB_> yes got it now
07:24:04 <DELB_> thank you
07:24:09 <DELB_> primeTest :: [Bool] primeTest = map prime [1..]
07:24:09 <ab9rf> Bellator: yes, but you said "output", does that mean you want to do IO, or do you want the function to return them as (part of) its value?
07:25:21 <Bellator> bartavelle, class exercise - no limitations on how we write the functions however
07:25:27 <Bellator> ab9rf, return them
07:25:57 <ertes> Bellator: you can write haskell functions in multiple clauses actually pattern-matching on each argument, and i suggest you try to do that in this case
07:26:09 <ertes> Bellator: you need two clauses:  one for empty lists, one for non-empty lists
07:26:25 <ertes> indivisible n [] = _fillThisIn
07:27:08 <ertes> what's the result for empty lists?
07:27:42 <Bellator> An empty list?
07:27:50 <ertes> is that a question or an answer?
07:28:07 <Bellator> It was an unsure answer
07:28:14 <bartavelle> :)
07:28:38 <ertes> Bellator: ok, think about the problem this function is solving…  is there reason not to be confident about that answer?
07:29:29 <Bellator> I guess I am unsure because they haven't specified what they want returned if it is an empty list
07:29:56 <ertes> they probably implied it in some form
07:30:03 <Xandaros> If you want all the elements not divisible by n of an empty list - how many such elements are there? That's how many elements you need to return.
07:30:45 <ertes> Bellator: the point is that you need to understand the problem first =)
07:30:58 <DELB_> how do you go about returning a list of primes that gets the output as [2, True], [3, True], [4, False] etc?
07:30:59 <Xandaros> (I just realised how “return” is imperative terminology and doesn't make that much sense here…)
07:31:09 <ab9rf> DELB_: you don't
07:31:19 <ab9rf> DELB_: [2, True] isn't a possible list in haskell
07:31:19 <DELB_> let me give you the question
07:31:27 <ertes> Xandaros: i think "the return statement" is imperative…  not so much the word "return"
07:31:36 <ab9rf> DELB_: you could do [(2, True), (3, True), ...] though
07:31:59 <ab9rf> DELB_: haskell lists are homogenetically typed
07:32:02 <Xandaros> I suppose “evaluates to” would be better, but that just gets confusing. I guess “return” is fine, then
07:32:10 <DELB_> yeah that's it ab9rf
07:32:16 <DELB_> like that
07:32:21 <ertes> in fact i'm pretty sure the person who invented the return statement invented it with mathematical functions in mind
07:32:56 <DELB_> how do you do it?
07:33:02 <ab9rf> DELB_: map (\x -> (x,isPrime x) [1..]
07:33:02 <Bellator> I think I got it to work fellas...
07:33:18 <DELB_> hmm
07:33:19 <ab9rf> DELB_: i think i dropped a paren in that, but you get the point
07:33:25 <DELB_> yeah
07:33:33 <DELB_> what would the function definition be?
07:33:37 <DELB_> primeTest2 :: ??
07:33:46 <ab9rf> DELB_: there are also ways to do it pointlessly, but there's nothing wrong with lambdas
07:33:53 <ertes> Bellator: feel free to paste it for comments =)
07:34:01 <DELB_> [(Int, String)]?
07:34:10 <ab9rf> DELB_: (Int, Boolean)
07:34:14 <DELB_> right, thanks
07:34:20 <ab9rf> DELB_: with [] for the list
07:34:30 <bartavelle> IIRC isPrime :: Integer -> Boolean, so it's [(Integer, Boolean)]
07:34:32 <ertes> oh, and DELB_ and Bellator, better use Integer than Int
07:34:42 <DELB_> why?
07:34:43 <ab9rf> @pl \f -> \x -> (x, f x)
07:34:43 <lambdabot> ap (,)
07:35:09 <ab9rf> @pl \f l -> map (\x -> (x, f x)) l
07:35:09 <lambdabot> map . ap (,)
07:35:11 <bartavelle> DELB_, Integer has an arbitrary size, no overflow
07:35:22 <Bellator> ertes, here it is http://pastebin.com/6HBa0Du4
07:35:25 <ab9rf> so map . ap (,) isPrime [1..]
07:35:27 <Bellator> Gotcha ertes 
07:35:34 <ertes> DELB_: Integer is the type of integers, while Int is something finite
07:35:35 <ab9rf> but don't use that unless you understand it, which you almost certainly don't
07:35:45 <DELB_> thanks
07:36:04 <ab9rf> and i probably left out some parens in that too
07:36:29 <Xandaros> ab9rf: map . ap (,) isPrime $ [1..] ?
07:36:44 <ertes> Bellator: you can write the function like this:
07:36:44 <ertes> indivisible n []       = []
07:36:45 <ertes> indivisible n (x : xs) = if x `mod` n == 0 then x : indivisible n xs else indivisible n xs
07:36:49 <DELB_> ab9rf: map (\x -> (x, prime x) [1..])
07:36:51 * Xandaros doesn't actuall know what ap does
07:36:54 <DELB_> what do I put in place of the x?
07:37:02 <DELB_> there's no input for my function
07:37:32 <ertes> Bellator: and there are even more readable ways using guards
07:37:39 <ab9rf> DELB_: you don't 
07:37:59 <ski> Xandaros : `S' combinator, `ap f g x = (f x) (g x)', in this case
07:38:01 <DELB_> then why's it giving me an error? ;o
07:38:02 <ertes> Xandaros: ap = (<*>)
07:38:02 <ab9rf> DELB_: "\x -> (x, prime x)" is a lambda expression, it defines an anonymous function
07:38:14 <Xandaros> ertes: Ah, thanks
07:38:18 <Bellator> ertes, I need to research guards a bit more!
07:38:22 <Bellator> Thanks :)
07:38:23 <ski> (s/defined/constructs/)
07:38:24 <ab9rf> Xandaros: it's actually (map . ap (,)) isPrime [1..]
07:38:47 <ertes> Bellator: question: have you learned about 'filter' in your class?
07:38:56 <Xandaros> ab9rf: Not something I would personally use... That too complicated for me
07:39:34 <ab9rf> the nice thing about that approach is that it abstracts over all functions that you might apply to the list, not just to this particular use of isPrime
07:40:01 <Bellator> ertes, no in this class they're kind of giving us new languages to learn the basics of, every week. They  pretty much hand out problems and we ahve to figure it out on our own. We had haskell last week.
07:40:23 <Bellator> That's I guess why I am using head/tail (car, cdr)
07:40:35 <ertes> Bellator: because with 'filter' this is a one-liner
07:41:07 <Xandaros> Yeah, you might want to take a look at filter for this. A _very_ handy function
07:41:09 <ab9rf> Bellator: we tend to use pattern matching for that in haskell
07:41:26 <ertes> Bellator: but i guess if they didn't explain 'filter', it would be inappropriate to show you how to use it right now
07:41:36 <ab9rf> Bellator: instaed of explicitly extracting the head, we do a pattern match on x:xs, which has the ffect of binding x to the head and xs to the tail
07:41:42 <kuribas> DELB_: Int is the type of finite signed integer that is convenient for the computer to use (and reasonably large).
07:42:00 <Bellator> Sorry I meant we had Sheme* last week
07:42:05 <Bellator> scheme*, bleh!
07:42:16 <ab9rf> if the list is empty, and thus has no head or tail, then the pattern match fails
07:42:19 <ertes> yeah, scheme has no pattern matching =)
07:42:27 <DELB_> ab9rf what does lambda do again?
07:42:32 <ertes> i'm pretty sure they are building up to 'filter' using this exercise, so nevermind
07:42:41 <ab9rf> DELB_: it defines a function
07:42:58 <kuribas> DELB_: create an anonymous function
07:43:00 <ab9rf> ertes: that would be the usual instructional approach
07:43:04 <Xandaros> ertes: If they get a new language every week - probably not
07:43:18 <DELB_> so basically it's a thing that says the code after the -> will do a function?
07:43:51 <ab9rf> DELB_: the part after the -> is the definition of the function, yes
07:44:00 <DELB_> ok thanks
07:44:04 <ertes> Xandaros: a week is more than enough to cover most list functions
07:44:31 <ertes> i do it in 3-4 hours in my workshops
07:44:58 <Xandaros> Oh right, I didn't consider the possibility of multiple sessions per week.
07:44:59 <ab9rf> "f = \x -> x + 1" and "f x = x + 1" do essentially the same thing (they don't, actually, but that's a lesson for another day)
07:45:05 <infandum> What's the difference between IntMap and Vector?
07:45:10 <Bellator> Thanks for the tips/help fellas. Got to leave. Will read up on maps/filters at home
07:45:21 <ertes> infandum: IntMap can have holes
07:45:28 <ertes> infandum: a vector is an actual array in memory
07:45:39 <infandum> ertes: I mean, vector can be an intmap
07:45:42 <infandum> int to whatever
07:45:51 <DELB_> does anyone know what this question means?
07:46:09 <infandum> ertes: Which implementation is faster for which algorithms?
07:46:09 <DELB_> Add a function that, given n, computes how many prime twins are amongst the first n prime numbers.  
07:46:13 <bartavelle> infandum, you'd need a (very large) Vector (Maybe a) to represent an IntMap a
07:46:15 <DELB_> The hell is a prime twin?
07:46:15 <ertes> infandum: yeah, but Vector can really only do indexing efficiently
07:46:30 <ab9rf> vectors are indexed from 0, sequentially, without skips
07:46:32 <ertes> infandum: with IntMap you can insert, update, etc.
07:46:34 <infandum> bartavelle: Oh yeah, oops
07:46:40 <infandum> silly me
07:46:53 <ab9rf> bartavelle: heh
07:46:58 <bartavelle> infandum, or a Vector (Int, a) and do sequential search :)
07:46:58 <ab9rf> bartavelle: "very large"
07:47:03 <infandum> ertes: But what is the computation complexity of getting a value?
07:47:06 <Xandaros> DELB_: A prime followed by a prime one away. 41 and 43 are a prime twin, for example
07:47:07 <infandum> for an intmap
07:47:07 <bartavelle> yes, "very" :)
07:47:19 <ertes> infandum: it's O(1) for both, but the O(1) of IntMap is a bit misleading
07:47:24 <infandum> hmm
07:47:26 <ertes> it's still a branching algorithm, but it has an upper limit
07:47:31 <infandum> I see
07:47:46 <ertes> in other words: indexing for vectors is *much* faster than lookup for IntMap
07:48:03 <ab9rf> but the difference is constant, rather than scaled by the size of the map
07:48:34 <bartavelle> ab9rf, wait what? larger IntMap don't have slower lookups ?
07:48:37 <ertes> ab9rf: the worst case is constant…  IntMap lookup gets progressively slower as the map grows, but only logarithmically
07:48:37 <ab9rf> well, constantish
07:48:39 <infandum> So if I have no gaps, and I want to compare two vectors or two intmaps index by index, which would be better?
07:48:48 <infandum> It seems like vectors would be
07:48:48 <DELB_> thanks
07:49:00 <infandum> BUT it's actually a matrix
07:49:03 <bartavelle> ah right*
07:49:04 <ertes> infandum: depends on how you build them
07:49:04 <infandum> that was a bit misleading
07:49:12 <ab9rf> ertes: if it scales logarithmcally, then it's not O(1)
07:49:15 <infandum> it's actually a matrix versus intmap of intmap
07:49:23 <ertes> ab9rf: it's O(1) because the worst case is constant
07:49:50 <ab9rf> ertes: it's O(1) because IntMaps have a fixed maximum size
07:50:07 <bartavelle> infandum, if it is a standard (non sparse) matrix, you'd better go with the Vector
07:50:29 <ertes> infandum: if you can construct Vector efficiently, especially unboxed Vector, then go for Vector…  if in doubt, go with IntMap
07:50:33 <ab9rf> (!) on IntMap has O(min(n,W))
07:50:45 <infandum> bartavelle: I think it would be sparse
07:51:09 <infandum> which is why I was considering intmaps in the first place
07:51:10 <ab9rf> which is constant because the map has a theoretical maximum size
07:51:22 <ab9rf> although an IntMap that reaches that size will be HUGE
07:51:42 <infandum> ab9rf: I would have over 10000 entires
07:51:53 <bartavelle> infandum, I would go with something specifically designed then, like https://hackage.haskell.org/package/sparse-0.9.2
07:51:53 <infandum> 10000 by 10000
07:51:55 <infandum> matrix
07:51:57 <infandum> or more
07:51:59 <ertes> ab9rf: that's why i said the O(1) is misleading (and yes, it's O(1) asymptotically)
07:52:15 <infandum> bartavelle: over an intmap?
07:52:29 <ertes> infandum: matrix size or actual non-zero elements?
07:52:32 <ab9rf> it looks like IntMap uses a piss-poor algorithm, if it's O(n) for (!)
07:52:38 <infandum> matrix size
07:52:48 <infandum> so 10000 x 10000
07:52:57 <infandum> at least
07:52:57 <ertes> infandum: how sparse do you expect it to be?
07:52:57 <infandum> sometimes 60000 x 60000
07:53:12 <ab9rf> but that might just be a worst-case situation. the docs state it uses patricia trees
07:53:16 <ertes> infandum: are you by any chance doing relation search in a sieve algorithm?
07:53:17 <infandum> I would assume pretty sparse, so that's why I was deciding to change the implementation
07:53:25 <infandum> no
07:53:45 <ertes> infandum: that really sounds like IntMap would be a good idea
07:53:54 <infandum> over a sparse matrix?
07:53:58 <ertes> but it depends on what you do with the resulting matrix
07:54:18 <infandum> I would be comparing, row by row, the non zero columns
07:54:42 <infandum> not every row to every other row, row 1 in matrix a versus row 1 in matrix b, row 2 in a and row 2 in b, etc
07:54:42 <ab9rf> IntMap is a decent choice for large, sparse maps where the limitation of the the size of Int is not a problem
07:55:04 <DELB_> primeTest3 :: Integer -> [Integer]
07:55:06 <DELB_> areTwoApart (x,y) = y - x == 2
07:55:09 <DELB_> primeTest3 x = take x $ filter areTwoApart (zip allprimes (tail allprimes))
07:55:09 <ertes> infandum: do you need to hold all vectors in memory?  or do you generate the matrix row by row?
07:55:23 <infandum> ertes: all in memory
07:55:25 <DELB_> why isn't areTwoApart working?
07:55:42 <infandum> it's from a result in R (using haskellr, so it's converted back)
07:56:00 <infandum> I'm not worried about memory as much as speed
07:56:45 <infandum> ab9rf: So it can reach O(n)?
07:56:49 <infandum> that's not good
07:56:51 <ertes> infandum: if you really want to get as fast as possible, you should probably go with a custom representation like this:  Vector (Int, Double)
07:57:08 <ertes> that also gives you a fairly compact representation, and that's always good for speed
07:57:21 <ertes> (assuming unboxed Vector)
07:57:25 <infandum> ertes: But matching columns with columns would be horribly slow
07:57:37 <ertes> infandum: no, just make sure the indices are sorted
07:57:47 <infandum> but zeros?
07:57:52 <ertes> then you can just iterate both at the same time
07:57:58 <Xandaros> DELB_: Describe "not working". Also, don't put a different definition between signature and that implementation - that's just confusing
07:58:03 <infandum> but I would need to check that Ints match
07:58:20 <afidegnum> what's the principle behind type annotations? how do it get interwoven in other funcitons...  i don't know if my question is clear, 
07:58:32 <infandum> well hold on, how fast is unionWith for intmap?
07:58:33 <ertes> infandum: you would represent [0, 0, 3, 4, 0, 7, 0, 0] by [(2,3), (3,4), (5,7)]
07:59:06 <ertes> the haddocks for IntMap tell you the complexity of each operation
07:59:08 <infandum> yeah but if I have the other row be [(3,8), (9,1)] it would be slow
07:59:11 <infandum> to compare the two
07:59:15 <infandum> ah, ok
07:59:26 <DELB_> Xandaros 
07:59:27 <ertes> infandum: no, you would just iterate both at the same time
07:59:33 <ertes> one pass over each
07:59:38 <ertes> (up to)
08:00:02 <infandum> hmmm, that sounds good
08:00:22 <ertes> and it's very compact, so you get better cache utilisation
08:00:54 <DELB_> Xandaros well I want to return a list of prime twins
08:01:00 <DELB_> primeTest3 :: Integer -> [Integer]
08:01:04 <DELB_> areTwoApart (x,y) = y - x <= 2
08:01:21 <DELB_> primeTest3 x = take x $ filter areTwoApart (zip allprimes (tail allprimes))
08:01:41 <DELB_> areTwoApart should be somewhere else though
08:02:00 <Xandaros> Yeah, don't put it between there. Just put it above or below
08:02:16 <DELB_> areTwoApart -> Integer -> Integer -> Integer areTwoApart (x,y) = y - x <= 2
08:02:23 <DELB_> areTwoApart -> Integer -> Integer -> Integer
08:02:26 <DELB_> areTwoApart (x,y) = y - x <= 2
08:02:30 <DELB_> does that look okay?
08:02:53 <Xandaros> Your signature makes no sense :P The first -> should be :: and it does not return an Integer
08:03:15 <DELB_> allprimesBetween :: Integer -> Integer -> [Integer]
08:03:18 <DELB_> areTwoApart :: Integer -> Integer -> Integer
08:03:21 <DELB_> areTwoApart (x,y) = y - x <= 2
08:03:23 <DELB_> okay?
08:03:33 <ertes> afidegnum: not sure if this is an answer, but: 1. you can add a type signature to every expression and every value definition, 2. type annotations are *claims*, not *declarations*
08:03:42 * hackagebot docopt 0.7.0.5 - A command-line interface parser that will make you smile  https://hackage.haskell.org/package/docopt-0.7.0.5 (ryanartecona)
08:03:44 * hackagebot github-backup 1.20161110 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20161110 (JoeyHess)
08:03:45 <Xandaros> DELB_: What is the result of areTwoApart (5,7)?
08:04:54 <DELB_> I get an error when compiling it
08:05:05 <Xandaros> Yes. Tell me what the result should be
08:05:42 <DELB_>     Couldn't match expected type `Integer -> Bool'                 with actual type `Bool'     In the expression: y - x == 2     In an equation for `areTwoApart': areTwoApart (x, y) = y - x == 2
08:06:13 <Xandaros> DELB_: If you evaluate `areTwoApart (5,7)` - what result do you expect? Don't try to compile it, just tell me.
08:06:44 <DELB_> True
08:06:52 <Xandaros> Yes :)
08:06:58 <Xandaros> What type does `True` have?
08:07:03 <DELB_> Bool
08:07:11 <Xandaros> So, what is the signature of areTwoApart?
08:07:28 <DELB_> areTwoApart :: Bool
08:07:28 <DELB_> ?
08:07:41 <Xandaros> Not quite - you still have an input
08:07:54 <DELB_> areTwoApart :: Integer -> Integer -> Bool
08:07:57 <DELB_> ?
08:08:22 <Xandaros> We're getting there :)
08:08:22 <Xandaros> However, you only have one input, not two
08:08:45 <implementation> one input, not two
08:08:47 <DELB_> areTwoApart :: Integer -> Bool
08:09:09 <Xandaros> DELB_: Name one possible input for the function
08:09:19 <DELB_> an Integer
08:09:25 <Xandaros> A concrete one
08:09:30 <DELB_> huh?
08:09:39 <Xandaros> "Integer" would be "5", for example
08:09:44 <DELB_> right
08:09:44 <DELB_> 5
08:09:48 <Xandaros> areTwoApart 5. Does that make sense?
08:10:10 <DELB_> uh doesn't the function need two Integers in-order to make a comparison?
08:10:22 <Xandaros> It does. So, what is a possible input?
08:10:31 <DELB_> 5
08:10:31 <DELB_> and
08:10:33 <DELB_> 7
08:10:44 <ski> <Xandaros> However, you only have one input, not two
08:10:48 <Xandaros> What would the function call look like?
08:10:55 <Xandaros> ski: I know. I realise I confused him
08:10:58 <DELB_> areTwoApart :: Integer -> Integer -> Bool
08:11:05 <DELB_> it's gotta be that
08:11:06 <Xandaros> call, not signature
08:11:16 <DELB_> areTwoApart (x,y) = y - x == 2
08:11:17 <DELB_> ?
08:11:32 <Xandaros> That's the implementation :) Something like my "areTwoApart 5" from earlier
08:11:43 <DELB_> areTwoApart 5 7
08:12:12 <Xandaros> Alright, that fits your signature. It does not, however, fix your pattern (in the implementation)
08:12:17 <Xandaros> *fit
08:13:49 <ania123> Shape = Circle Float | Rect Float Float
08:13:52 <Xandaros> DELB_: "areTwoApart 5 7" and "areTwoApart (5, 7)" are two different things
08:13:57 <ania123> data Shape = Circle Float | Rect Float Float
08:14:12 <ania123> square :: Float -> Shape 
08:14:12 <ania123> square n = Rect n n
08:14:17 <DELB_> right I gotta go but I will be back
08:14:19 <DELB_> thanks Xandaros
08:14:35 <ania123> can square n be equal to Circle n?
08:15:02 <ski> no
08:15:17 <implementation> depends on how you define equality
08:16:01 <ania123> Shape is Crcle Float or Rect Float FLoat
08:16:09 <ania123> so, shape can ve Circle Float
08:16:23 <ania123> squate has type Float -> Shape
08:16:56 <ania123> and hence it is not restrected to be square n = Circle n
08:16:59 <ania123> no?
08:17:05 <Xandaros> If you just look at the signature, it could be Cirlce _. However, the definition always gives you a Rect _ _, so it won't happen.
08:17:09 <ski>   forall f,f0,f1. Circle f =/= Rect f0 f1  -- disjointness
08:18:07 <ania123> ski, not clear
08:18:09 <ania123> sorry
08:18:41 <APic> *shrug*
08:18:47 <ski> it's like in Prolog, where `circle(F)' and `rect(F0,F1)' won't unify, regardless of what `F',`F0',`F1' is
08:19:14 <ania123> data Shape = Circle Float | Rect Float Float
08:19:20 <ania123> square :: Float -> Shape
08:19:23 <ania123> if I have this
08:19:31 <ania123> square = ?
08:19:51 <ski> sounds ok
08:20:01 <ania123> square n = ?
08:20:02 <ania123> ?
08:20:25 <ski> just fill in `?' with whatever you want there, perhaps `Rect n n', or something else
08:20:41 <ania123> square n = Circle n
08:20:44 <ania123> can I write it?
08:20:45 <bartavelle> square = Circle -- be a wannabe topologist!
08:20:49 <ski> yes
08:20:50 <bartavelle> yes !
08:20:59 <ania123> it is my question
08:21:00 <ania123> aha
08:21:07 <ania123> then it means type does not preserve
08:21:17 <ania123> square n to be something undesirable 
08:21:21 <bartavelle> the type is "Shape" here !
08:21:34 <ski> the type of `Circle' is `Float -> Square', which is also the declared type of `square', so types are matched
08:21:35 <ahihi> haskell cannot know what your types *mean*
08:21:36 <implementation> Rect n m == Circle r | (n == m) && (n == r) = True
08:21:44 <mmaruseacph2> ania123: for that reason there are GADTs or better types around
08:21:47 <ski> er, `Float -> Shape', rather
08:21:59 <buttbutter> ahihi: feels bad man :(
08:22:28 <ski> implementation : but then you need to do an abstract data type, to simulate that quotient type
08:22:28 <ania123> ok
08:22:29 <ania123> thx
08:22:53 <ski> (also, no need to use a guard there)
08:23:04 <implementation> ski: why? i just need to write my own Eq instance
08:23:38 <bartavelle> implementation, foo | predicate = True is equivalent to foo = predicate
08:23:40 <ski> implementation : it's a good idea that if `x == y = True', then exported operations from the module can't distinguish between `x' and `y'
08:24:02 <bartavelle> or not :)
08:24:10 <implementation> bartavelle: not if there are more clauses
08:24:17 <bartavelle> indeed, sorry for that nonsense
08:24:57 <ski> implementation : if you had more guards, then you'd use `||'
08:25:42 <implementation> ... or just use guards
08:25:54 <mmaruseacph2> depends which is easier to read
08:26:06 <mmaruseacph2> or if you have a ordering of conditions that must be preserved
08:26:26 <implementation> or different patterns in each clause
08:26:45 <mmaruseacph2> for that you can use all, any
08:27:05 <ski> imho, the above (assuming more guards) is similar to writing `if (n == m) && (n == r) then True else ...' .. which is unnecessarily complicated to read
08:27:16 <mmaruseacph2> actually, even and or or
08:27:34 <ski> (different patterns is another case, yes)
08:28:08 <mmaruseacph2> f ... = or [pat1, pat2, pat3]
08:53:44 * hackagebot pandoc-citeproc-preamble 1.2.1 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.2.1 (spwhitton)
08:58:44 * hackagebot ghcjs-promise 0.1.0.0 - Bidirectional bidings to javascript's promise.  https://hackage.haskell.org/package/ghcjs-promise-0.1.0.0 (AlejandroDuranPallares)
08:58:46 * hackagebot ghcjs-promise 0.1.0.1 - Bidirectional bidings to javascript's promise.  https://hackage.haskell.org/package/ghcjs-promise-0.1.0.1 (AlejandroDuranPallares)
09:06:44 <EvilMachine> Hi. Is Leksah generally always lagging behind in updating its dependencies on other libraries to the newest versions? Here on Gentoo that’s the case and I’m wondering if that’s a general problem or Gentoo-specific.
09:08:06 <Welkin> never used leksah
09:14:13 <sbrg> EvilMachine: I don't think leksah sees very heavy development. or rather, I don't think many people are using it => fewer people working on it
09:15:17 <bobajett> noobie question. Im playing with https://code.world but it doesn't recognize "map", "foldl". How do I import these? I guessed at: import GHC.Base (map, foldl) but that gave me an error..
09:15:33 <bobajett> Could not find module GHC.Base
09:15:33 <bobajett>     It is a member of the hidden package base-4.8.0.0.
09:17:35 <Tuplanolla> Use Hoogle or Hayoo to find where they are, bobajett. In this case that's `Data.List` from `base`.
09:18:10 <bobajett> Tuplanolla: ah, right, I should have thought of that. Thanks!
09:19:00 <lyxia> bobajett: code.world uses a simplified custom prelude
09:20:27 <bobajett> lyxia: I figured as much, but at this point in my learning-haskell career, I couldn't figure out where I would import such basic functions as map/foldl :-)
09:21:24 <lyxia> they dont seem to have it. See Help > More information > Prelude
09:22:09 <lyxia> So if you want to experiment with those functions you're better off installing ghc locally.
09:22:50 <Tuplanolla> I think the import chain is actually `Prelude`, `Data.List`, `Data.OldList`, `GHC.List`, `GHC.Base`, bobajett.
09:23:45 * hackagebot ghcjs-promise 0.1.0.2 - Bidirectional bidings to javascript's promise.  https://hackage.haskell.org/package/ghcjs-promise-0.1.0.2 (AlejandroDuranPallares)
09:23:56 <EvilMachine> sbrg: Too bad. A Haskell development environment is a good and important thing to have.
09:23:59 <bobajett> Tuplanolla: "import chain" meaning I would have to import all those package?
09:24:24 <Tuplanolla> No, bobajett. It's just where that stuff comes from.
09:25:10 <lyxia> the error message means code.world doesn't have access to base.
09:25:20 <sbrg> EvilMachine: not sure about the 'important' part, but I would definitely like having an editor that could be programmed in Haskell
09:25:30 <lyxia> so these modules are off-limits
09:25:47 <bobajett> lyxia: ah ok. Thanks!
09:26:21 <sbrg> EvilMachine: but emacs has some good stuff for haskell
09:26:33 <sbrg> and setting it up is very easy if you just get spacemacs
09:26:45 <EvilMachine> sbrg: Well, apart from the compiler and good tutorials, it’s the most important part of making a language live… I think.
09:26:56 <EvilMachine> sbrg: Then again, it is Emacs!
09:27:12 <EvilMachine> sbrg: (I’m no friend of the inner-platform effect)
09:27:29 <sbrg> EvilMachine: well, there are plenty of ways to write haskell with plenty of ide-like support. so the ecosystem is fine in that regard, IMO. though we could use a more "streamlined" experience. 
09:27:40 <sbrg> atom, sublime, vim, emacs, probably some more
09:27:50 <EvilMachine> sbrg: Other-language dependency is a big problem.
09:28:13 <sbrg> not sure what that means
09:28:43 <EvilMachine> sbrg: Also, not everyone is obsessed with removing all joy (e.g. graphics) from his life because he associates it with pointless colorful clickables for dumb people. ;)
09:28:45 * hackagebot wolf 0.2.13 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.13 (markfine)
09:29:07 <sm> atom and intellij are quite useful for haskell
09:29:12 <sm> there's nothing perfect yet
09:29:30 <sbrg> atom is a very "modern" looking editor, and so is sublime, tbh. and there are plenty of languages that have no "standard" IDE that are doing just fine.
09:29:56 <sbrg> my point being: it could be better for haskell, but I wouldn't say we're exactly suffering from lack of choice.
09:30:12 <EvilMachine> sm: I just wish there was a Intellij written completely in Haskell, with zero dependencies on anything in a different language, except for the kernel and ma.
09:30:19 <EvilMachine> ybe one helper library.
09:30:27 <dzdcnfzd> I'm trying to understand Conduit via the README on the git page, but the main combinator he uses -- (.|), I can't find in a library
09:30:28 <EvilMachine> sbrg: Ok, I agree on that.
09:30:39 <sm> you should probably help with Leksah then
09:30:42 <EvilMachine> sbrg: I’m just a bit of an perfectionist idealist, I guess.
09:30:45 <dzdcnfzd> https://github.com/snoyberg/conduit#readme https://www.stackage.org/haddock/lts-6.19/conduit-1.2.8/Data-Conduit.html#v:fuse
09:31:09 <Tuplanolla> I want an editor that I can communicate with, not edit text with.
09:31:31 <Shou> re/lo
09:31:41 <EvilMachine> sm: I am working on a Haskell-only user space for the Linux (or BSD) kernel, so I think I’m good in terms of helping. :)
09:31:54 <EvilMachine> Tuplanolla: how do you mean?
09:32:17 <ertes> EvilMachine: i love my eye candy…  if emacs were that boring, i'd probably get sick of it =)
09:33:03 <younder> The eclipse interface seems OK..
09:33:12 <sbrg> EvilMachine: I'm with you man. I dream of the same things
09:33:25 <Tuplanolla> Instead of manipulating text directly, I'd be writing commands to transform the structure of text, EvilMachine. Vim is an extremely narrow-minded take on this.
09:33:32 <ertes> the only reason i switched away from compiz was that xmonad is easier to work with…  if xmonad had that kind of eye candy, i would definitely enable all of it =)
09:34:07 <sbrg> ertes: I agree. I think my emacs looks pretty pimp to be honest.
09:34:19 <sbrg> and so do the kids I teach haskell to. I've helped 3 install spacemacs so far
09:34:37 <Tuplanolla> It's a bit difficult to explain, because I'm not even sure how it should work exactly.
09:34:48 <EvilMachine> ertes: But there is zero point in restricting graphics to a single font and a few colors. … I am no friend of pointless colorful clickables (let alone tappables), but I liked the sensible parts of Compiz. (And Compiz’s usability functionality beat even KWin out of the water. Too bad it got a bad rep for the also-existing pointless bling and too bad it consisted of spaghetti code.)
09:35:02 <sbrg> Tuplanolla: I understand what you mean, I think. you mean navigation and editing that operates directly on the AST, yes?
09:35:16 <sbrg> similar to some of the editing stuff that exists for lisps
09:35:46 <Tuplanolla> That's one part of it, sbrg. However I should also be able to manipulate the commands I'm using with the same commands.
09:35:47 <EvilMachine> sbrg: I will not use Emacs for the same reason I will never use FirefoxOS. Because if I want an operating system, I get a real one, like GNU/Linux. ;)
09:36:01 <EvilMachine> Not one that runs on top of another one.
09:36:08 <ertes> EvilMachine: i liked the pointless bling…  sometimes i would enable the snow effect with compiz together with the transparent cube and its center aquarium (without fish)…  it's just amazing to look at
09:36:10 <EvilMachine> But this is getting very off-topic.
09:36:19 <Tuplanolla> Again, Vim allows this in a sense, because you can edit macros as text, but it's a mess.
09:36:30 <dzdcnfzd> Is (=$=) the same as (.|)?
09:37:00 <sbrg> EvilMachine: I shared your viewpoint at one point. but I haven't found anything as powerful as emacs, even though it definitely has its warts
09:37:09 <ertes> EvilMachine: never really understood that argument
09:37:10 <EvilMachine> sbrg: Btw: I’m not saying Emacs isn’t nice for the coding itself. It likely is. Not my point though.:)
09:37:40 <sbrg> i'm hopelessly invested in it by now. org-mode for organization and notmuch for email are enough on their own to make me stick with it
09:37:46 <sm> ertes: haha, where do I see this wonderfule thing
09:38:00 <hodapp> sbrg: notmuch?
09:38:05 <hodapp> first I've heard of it
09:38:16 <sbrg> email indexer/tagging program. 
09:38:25 <sbrg> also has an emacs interface
09:38:33 <EvilMachine> ertes: My only pointless bling was making snow fall upwards, make the snow flakes be white flowers, and configure it so it looked like the rose out of a nice and warm summer park meadow, accompanied by Cafe del Mar music. ;)
09:38:36 <hodapp> not a reader or client, just indexer/tagger?
09:38:45 * hackagebot req-conduit 0.1.0 - Conduit helpers for the req HTTP client library  https://hackage.haskell.org/package/req-conduit-0.1.0 (mrkkrp)
09:38:49 <sbrg> yes, but also searching
09:38:57 <younder> EvilMachine, Mose GUI API's have acces to command line tolls like git, compiler, debugger, profiler. This requires access to the OS and Command line from the program.
09:38:57 <sbrg> so the emacs interface uses the program to show data
09:39:23 <hodapp> and you use something else to actually fetch mail?
09:40:00 <sbrg> hodapp: yep, mbsync. and msmtp for sending mail. 
09:40:11 <sbrg> i'm actually working on a blog post for setting all this up
09:40:48 <hodapp> sbrg: point me to it when you do
09:40:54 <EvilMachine> sbrg: I guess the reason I started my user space thingie is, that I realized that applications are harming modularity. The user space should be one single ”application”, and everything else should be libraries/modules, with one generic user interface that they all would adhere to.
09:41:12 <sbrg> hodapp: I will, if I remember. otherwise I will probably post it to r/emacs. 
09:41:21 <ertes> sm: this is a pretty bad video, but it's the best one i could find: https://www.youtube.com/watch?v=Rmz9a9pJR_s
09:41:26 <Tuplanolla> My Lisp Machine sense tingles, EvilMachine.
09:41:36 <ertes> sm: second half shows acquarium
09:41:46 <sbrg> EvilMachine: well, I think that in practice, we often have to deviate far from how things "should be" unfortunately. 
09:41:51 <sm> thanks
09:42:00 <hodapp> Tuplanolla: https://github.com/mntmn/interim
09:42:16 <EvilMachine> Tuplanolla: :D
09:42:28 <Tuplanolla> Neat, hodapp.
09:42:34 <hodapp> Tuplanolla: That is one word.
09:42:54 <EvilMachine> Tuplanolla: (Brace ((your self)!))
09:43:46 * hackagebot clustering 0.3.0 - High performance clustering algorithms  https://hackage.haskell.org/package/clustering-0.3.0 (kaizhang)
09:43:47 <ertes> sm: compiz lets you turn your desktop workspaces into an optionally transparent 3D cube (or other shapes), and the acquarium fills it with water and some other stuff =)
09:44:23 <ertes> it's a complete waste of GPU time, but i loved it =)
09:44:38 <EvilMachine> sbrg: Yes, that’s where I differ. My girlfriend said the same thing. I assume that 1. everything is possible, it is just a matter of effort times time. So 2. if anything is too far off in the future, I just expect myself to think harder and solve it quicker. 
09:44:57 <ertes> make emacs transparent, make desktop cube transparent, enable acquarium, code away =)
09:45:51 <EvilMachine> ertes: Not a complete waste. Only like 99%. (The joy one gets from it was the part not wasted.)
09:46:26 <EvilMachine> ertes: How can you still recognize the letters with everything being half-transparent below? XD
09:46:28 <APic> 90% > 9%
09:46:46 <ertes> EvilMachine: you make it less than half transparent =)
09:46:47 <EvilMachine> NEIN TEA NEIN TEA PER CENT!!
09:47:33 <joe9_> hodapp: I think plan 9 provides the best approach to modularity.
09:48:02 <EvilMachine> ertes: :)
09:49:25 <EvilMachine> joe9_: Yes, plan9 was an inspiraton for my project
09:49:37 <EvilMachine> gotta go now though. Man, I like chatting with you guys!!
09:49:51 <dzdcnfzd> Friends, Haskellers, there must be someone here who's used Conduit. Can anybody just tell me if (.|) is the same as (=$=) ?
09:49:58 <joe9_> EvilMachine: are you the author of interim?
09:52:58 <dzdcnfzd> moreover, all the type signatures seem to require a 'Conduit a m b', but I can only find functions that produce 'ConduitM a c  m r's
09:53:10 <joe9_> interim OS looks cool.
09:57:27 <hodapp> joe9_: let me know if you try running it. I haven't yet.
09:58:06 <joe9_> anyone tried it (interim OS)? it has a lot of stars and forks on github
10:04:46 <mmaruseacph2> dzdcnfzd: are you looking at the docs for the same version?
10:05:32 <dzdcnfzd> I'm looking at the docs on Git vs. those linked to on git
10:05:33 <dzdcnfzd> https://github.com/snoyberg/conduit#readme
10:05:40 <dzdcnfzd> https://www.stackage.org/haddock/lts-6.19/conduit-1.2.8/Data-Conduit.html#v:fuse
10:06:33 <mmaruseacph2> https://hayoo.fh-wedel.de/?query=(.%7C)
10:06:39 <mmaruseacph2> (.|) is not a Conduit operator
10:06:48 <mmaruseacph2> @t (=$=)
10:06:48 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:06:55 <mmaruseacph2> @type (=$=)
10:06:57 <lambdabot> error:
10:06:57 <lambdabot>     • Variable not in scope: =$=
10:06:57 <lambdabot>     • Perhaps you meant one of these:
10:07:04 <mmaruseacph2> @type (.|)
10:07:06 <lambdabot> error:
10:07:06 <lambdabot>     • Variable not in scope: .|
10:07:06 <lambdabot>     • Perhaps you meant one of these:
10:13:47 * hackagebot wolf 0.2.8.1 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.8.1 (markfine)
10:38:41 <mutantmell>  #scala
10:38:46 <mutantmell> oops :P
10:39:48 <grpala> I have a question of type hackery. I have an ADT like this:  data Something = A | B | C | D.   Question is: how can I promote those constructors to the type level so I can guarantee a value to be either A or B, but not the rest of the constructors of Something? I tried DataKinds but haven't figured out how to make this work yet
10:40:46 <mauke> that doesn't sound like promotion
10:41:38 <grpala> must have misused the term, what would promotion be then?
10:42:09 <kuribas> grpala: data Something = SomeAorB AorB | C | D, data AorB = A | B
10:42:56 <mauke> making A, B, C, D types of kind Something
10:43:08 <mauke> which have no associated values, because only types of kind * have values
10:43:31 <grpala> kuribas: yeah, thought to even make different groups, data A, data B, data C, data D, data AorB = ABA A | ABB B .... but it goes out of control pretty soon
10:44:10 <grpala> anyway, it's not like I absolutely must do it this way... but I was wondering if it was possible
10:44:18 <kuribas> grpala: or use phantom types
10:46:03 <tabaqui1> why (a,b) hasn't Applicative instance?
10:46:17 <tabaqui1> it's pretty obvious that fmap f (a,b) = (f a, f b)
10:46:59 <grpala> tabaqui1: then what would be the type of f?
10:47:46 <tabaqui1> grpala: well, "(,) a a" could has Applicative
10:48:12 <grpala> indeed
10:48:24 <younder> I need a new project to test/learn my new eclipse setup. Perhaps a Lambda calculus engine.
10:48:41 <mauke> tabaqui1: no, that's the wrong kind
10:48:53 <mauke> Applicative takes * -> *
10:49:05 <mauke> (a,b) has kind *
10:49:49 <tabaqui1> mauke: and (,) has * -> * -> *
10:49:59 <tabaqui1> yeah, you're right
10:50:31 <Tuplanolla> You could define a `newtype` for `join (,)`. Do we have one yet?
10:50:45 <tabaqui1> well, how can I get smth like "Just <$> (1, 'a', "asd")"?
10:51:00 * geekosaur notes that a Functor (thus fmap) instance exists for ((,) a)
10:51:07 <mauke> that needs at least rank-2 types
10:51:28 <mauke> because that would apply Just at 3 different types
10:51:31 <geekosaur> and: instance Monoid a => Applicative ((,) a) -- Defined in ‘GHC.Base’
10:51:52 <kuribas> > over both (+1) (1, 2)
10:51:55 <lambdabot>  (2,3)
10:52:02 <geekosaur> note that this is (a,*) where only a participates in the instance
10:52:15 <mutantmell> :t over both (+1)
10:52:16 <lambdabot> (Data.Bitraversable.Bitraversable r, Num b) => r b b -> r b b
10:52:31 <mauke> :t over both Just
10:52:33 <lambdabot> Data.Bitraversable.Bitraversable r => r a a -> r (Maybe a) (Maybe a)
10:52:35 <geekosaur> I feel like the other exists but is not "just" Functor
10:52:37 <mutantmell> Looks like all the types in the tuple have to be the same for both
10:52:43 <geekosaur> yes
10:53:19 <tabaqui1> :i over
10:53:21 <tabaqui1> :t over
10:53:23 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
10:53:48 <mutantmell> :t over both
10:53:50 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
10:54:05 <tabaqui1> hm, looks I must to write smth ugly
10:54:20 <tabaqui1> foo :: (a,b,c) -> (Maybe a, Maybe b, Maybe c)
10:54:34 <Tuplanolla> > (+) <$> ("one", 1) <*> ("two", 2) -- There's this too.
10:54:36 <tabaqui1> *must write
10:54:37 <lambdabot>  ("onetwo",3)
10:55:45 <tabaqui1> Tuplanolla: but 
10:55:47 <tabaqui1> Just <$> ("one", 1)
10:55:53 <tabaqui1> ("one",Just 1)
10:55:57 <tabaqui1> why so?
10:56:13 <mauke> because instance Applicative ((,) a)
10:56:18 <mauke> (,) a :: * -> *
10:56:28 <mutantmell> Because Functor/Applicative change 1 type, in this case the right-most one
10:56:36 <Tuplanolla> You'd need `newtype Uniform a = Uniform (a, a)` otherwise, tabaqui1.
10:57:06 <tabaqui1> unary and binary functions have different behavior then
10:57:16 <tabaqui1> *behaviors
10:59:09 <tabaqui1> (==) <$> ("one", 1) <*> ("one", 1)
10:59:14 <tabaqui1> ("oneone",True)
11:07:11 <Clint> tabaqui1: bimap (==) (==) <<$>> ("one", 1) <<*>> ("one", 1) ?
11:09:56 <kuribas> > over each (+1) (1, 2, 3, 4)
11:10:00 <lambdabot>  (2,3,4,5)
11:13:11 <implementation> > over _ (+1) (1,2,3,4)
11:13:14 <lambdabot>  error:
11:13:14 <lambdabot>      • Found hole:
11:13:14 <lambdabot>          _ :: ASetter (Integer, Integer, Integer, Integer) t Integer Integer
11:13:43 <implementation> :t each
11:13:44 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
11:13:49 * hackagebot th-expand-syns 0.4.1.0 - Expands type synonyms in Template Haskell ASTs  https://hackage.haskell.org/package/th-expand-syns-0.4.1.0 (DanielSchuessler)
11:18:52 <KaneTW> :t over
11:18:54 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
11:23:18 <grazie> this function https://gist.github.com/9c7a47e614457e4c5ddeb8729cbb4cb1 is from one of the Sudoku solvers at https://wiki.haskell.org/Sudoku .... question....
11:23:53 <grazie> question...in the function I copied, what happens with the grid (g) after ` do regularGrid g`,  does it become the `g` in: foldM assign allPossibilities (zip squares g)
11:24:25 <grazie> in other words, I don't understand the relationship of the two lines in the do block of https://gist.github.com/9c7a47e614457e4c5ddeb8729cbb4cb1
11:31:16 <monochrom> grazie: consider what happens to "do { Nothing; return True }" given the Maybe Monad.
11:32:16 <grazie> monochrom: thank you, I'm not sure how to test that in ghci, if line 1 of the block is Nothing, does it not proceed to line 2?
11:32:25 <Tuplanolla> That looks like a contrived `guard` to me, grazie.
11:32:38 <monochrom> you can just enter that line at the GHCi prompt verbatim.
11:32:57 <monochrom> My line, I mean.
11:34:35 <grazie> monochrom:  "do { Nothing; return True }" gave me "Nothing" in the prompt, does that mean `return True` was never evaluated?
11:35:01 <monochrom> Tuplanolla: It may be a leftover from a previous version in which the return value was useful
11:35:05 <monochrom> yes
11:35:58 <grazie> monochrom: ok, I think I get it, if there's a Nothing at any point in a chain of Monads the whole thing fails? and in the do block, the chain is represented in imperative style multiple lines
11:36:00 <monochrom> But no, you should not think at the low level of "what is evaluated".
11:36:20 <grazie> monochrom: ok, I'm sure my terminology is off
11:36:46 <monochrom> You should think at the higher level of "what answers I get". You get Nothing, and it amplifies from local to global. A local Nothing causes a global Nothing.
11:37:07 <grazie> monochrom: ok, makes sense, so it's basically a form of validation
11:37:19 <kadoban> It's computations that can fail
11:38:13 <grazie> any thoughts as to why the author would include the "-" (hyphen) in the list of characters? "0.-123456789"  an example sudoku grid/string looks like this ".......2143.......6........2.15..........637...........68...4.....23........7...."
11:38:50 <grazie> kadoban: and in this case it fails if the sudoku grid doesn't have the right characters
11:39:29 <kadoban> . is an empty space or something?
11:39:49 <grazie> kadoban: yes, it's the cells of the sudoku gird without a number
11:40:42 <kadoban> I was thinking maybe for optionally drawing lines to separate the boxes, but then there's no |   Is it a variant with some other designation for cells too, maybe like blocked cells? I dunno.
11:42:35 <grazie> so, back to my first question, without the do syntax would you write `regularGrid g >> foldM assign allPossibilities (zip squares g)` or  ...
11:42:55 <grazie> `regularGrid g >>= foldM assign allPossibilities (zip squares g)` ? or something else?
11:46:15 <monochrom> >>
11:47:18 <grazie> monochrom: and only >>= if the second line needed the return value of regularGrid? 
11:47:31 <monochrom> No, wrong model.
11:47:53 <monochrom> "x <- a; b" is when you use >>= : a >>= \x -> b
11:48:09 <monochrom> OK yes.
12:13:52 * hackagebot pong-server 0.0.2.1 - A simple embedded pingable server that runs in the background.  https://hackage.haskell.org/package/pong-server-0.0.2.1 (RobertFischer)
12:14:16 <DELB_> Xandaros: you there?
12:26:12 <tluble> why can't you do something like 'sort :: [Ord a] -> [Ord a]' in haskell?
12:26:38 <mauke> because Ord is not a type
12:26:59 <tluble> is there a technical reason for having this kind of syntax: 'sort :: Ord a => [a] -> [a]', or is it just a choice that was made?
12:27:03 <sm> you could, using your own types
12:27:20 <tluble> mauke: but can't it be inferred that Ord is a typeclass ?
12:27:29 <kadoban> tluble: Otherwise it's ambiguous what Ord is, a typeclass or a type constructor
12:28:01 <mauke> tluble: what would [a] -> [Ord a] mean then?
12:28:09 <tluble> ah, but you can have type constructors with the same names as typeclasses?
12:28:26 <kadoban> And since they have vastly different semantics, it's probably best to keep them separate. I don't know if there are other reasons.
12:28:53 <tluble> okay, I understand, thanks
12:28:53 * hackagebot crawlchain 0.1.1.4 - Simulation user crawl paths  https://hackage.haskell.org/package/crawlchain-0.1.1.4 (axm)
12:29:04 <mauke> tluble: how would that syntax deal with multiple constraints?
12:29:15 <mauke> e.g. (Eq a, Show a) => a -> a -> String
12:29:32 <tluble> mauke: yeah, I guess the way haskell has it now is pretty good
12:30:46 <kadoban> I'm not sure if you can have same name as type and typeclass actually. Never tried, it doesn't seem to come up.
12:31:20 <jle`> you can, but not in the same module
12:31:43 <Cale> Well, you can have two types of the same name in different modules as well :P
12:31:51 <tluble> you know how haskell has types and 'higher order types/kinds' - are there any languages that have an arbitrary amount of 'type levels'?
12:31:53 <jle`> my point :)
12:32:48 <jle`> tluble: yeah, most dependently typed languages do
12:32:54 <jle`> haskell has them too to an extent in GHC 8
12:32:57 <jle`> with -XTypeInType
12:33:07 <tluble> ah okay cool
12:33:09 <jle`> oh, wait
12:33:19 <jle`> not sure what your question is actually
12:33:21 <johnw> tluble: sure, Agda, Coq, etc.
12:33:21 <Cale> tluble: Most dependently typed languages have an infinite sequence of universes
12:33:22 <Cale> Also, there was a language called Omega a while back which explored that, without being properly dependently typed iirc.
12:33:27 <jle`> because you mentioned" higher order tpye/skinds"
12:33:31 <DELB_> anyone have any idea on how to do a function that lists how many twin primes there are?
12:34:04 <jle`> higher-order types don't have anything to do with 'type levels', like types/kinds/sorts etc.
12:34:11 <jle`> so i'm not sure what you're asking actually :O
12:34:36 <mauke> DELB_: why a function?
12:34:38 <jle`> DELB_: yes.  move to a different universe where such a function is computable :)
12:34:53 <tluble> jle`: isn't a 'kind' a 'higher order type'?
12:35:10 <DELB_> lol xD
12:35:24 <DELB_> I'll give it another shot on my own
12:35:31 <DELB_> then if I'm still stuck I'll copy and paste what I've done
12:35:38 <jle`> tluble: a higher-order function is a function that takes a function as input, like map :: (a -> b) -> [a] -> [b]
12:35:46 <ertes> actually -XTypeInType has only two levels
12:36:01 <ertes> it doesn't do the universe thing
12:36:07 <jle`> tluble: so a higher-order type would be a type function that takes a type function as input, like MaybeT :: (* -> *) -> * -> *
12:36:39 <DELB_> primeTest3 :: Integer -> [Integer] 
12:36:40 <DELB_> primeTest3 n = [ if y - x == 2 then y  else x | x <- [3..n], y <- [2..n],  prime x]
12:36:57 <joe9_> optparse-applicative package is this the recommend package for simple argument handling? a text option and an integer option
12:36:59 <DELB_> it outputs something that is kind of write, so if I do primeTest3 10
12:37:18 <jle`> DELB_: oh, you mean how many twin primes there are within a range
12:37:21 <DELB_> yeah
12:37:23 <jle`> not how many twin primes there are in general?
12:37:25 <jle`> ah
12:37:30 <jle`> then that is probably computable
12:37:39 <DELB_> well, that thing kinda works
12:37:46 <DELB_> but it outputs duplicates and also a "9"
12:37:48 <DELB_> 9 is not a prime
12:37:51 <DELB_> so what's up with my code?
12:38:08 <jle`> DELB_: what does 'prime 9' say?
12:38:16 <DELB_> ?#
12:38:16 <lambdabot> Maybe you meant: v @ ? .
12:38:21 <DELB_> what do you mean?
12:38:24 <jle`> also, why not just y <- [2..n], x <- [y+2 .. n] ?
12:38:28 <jle`> DELB_: you have a function 'prime' there
12:38:32 <jle`> what happens when you call 'prime 9' ?
12:38:43 <DELB_> returns false
12:38:46 <sm> joe9_: maybe, if you find enough docs. docopt makes things pretty simple. There's also Turtle.Options and cmdargs
12:38:55 <Welkin> should be isPrime
12:39:20 <jle`> DELB_: you don't test if 'y' is prime, so y might not be prime
12:39:48 <DELB_> primeTest3 n = [ if y - x == 2 then y  else x | x <- [3..n], y <- [2..n],  prime x, prime y]
12:39:50 <DELB_> that works now
12:39:52 <jle`> DELB_: you can prevent duplicates by just making sure one is bigger than the other
12:39:56 <DELB_> how do I remove duplicate values?
12:40:07 <ertes> [ (x, y) | x <- [3..], isPrime x, let y = x + 2, isPrime y ]
12:40:18 <jle`> like x <- [3 .. n], y <- [x + 2 .. n ]
12:40:35 <mauke> why two loops?
12:40:37 <ertes> replace [3..] by the range you want - 2
12:40:39 <jle`> but ertes 's way is probably better :p
12:40:49 <jle`> wanted to show the step-by-step transformation
12:40:51 <jle`> from what they had earlier
12:41:45 <ertes> also if you make sure the lower bound is odd, you can skip half of the candidates
12:42:50 <DELB_>     Couldn't match expected type `Integer'                 with actual type `(Integer, Integer)'     In the expression: (x, y)     In the expression:       [(x, y) | x <- [3 .. ], prime x, let y = x + 2, prime y]     In an equation for `primeTest3':         primeTest3 x           = [(x, y) | x <- [3 .. ], prime x, let y = x + 2, prime y]
12:42:52 <DELB_> uuuh
12:43:02 <joe9_> sm, Thanks a lot. which do you recommend? docopt vs Turtle.Options vs cmdargs? something simple to parse a text and an integer option and easy to get going.
12:43:08 <joe9_> sm, docopt?
12:43:15 <mauke> DELB_: yes, that function returns tuples
12:44:48 <DELB_> ahh
12:44:56 <mauke> :t \n -> filter (\(x,y) -> x+2 == y) ((zip <*> tail) (filter isPrime [3, 5 .. n]))
12:44:58 <lambdabot> error:
12:44:58 <lambdabot>     • Variable not in scope: isPrime :: a -> Bool
12:44:58 <lambdabot>     • Perhaps you meant ‘isPrint’ (imported from Data.Char)
12:45:02 <mauke> :t \n -> filter (\(x,y) -> x+2 == y) ((zip <*> tail) (filter ?isPrime [3, 5 .. n]))
12:45:04 <lambdabot> (?isPrime::a -> Bool, Num a, Eq a, Enum a) => a -> [(a, a)]
12:45:38 <DELB_> [if y - x == 2 then y  else x | x <- [3..n], y <- [2..n],  prime x, prime y]
12:45:48 <DELB_> jle`, so, how do I remove the duplicates?
12:45:50 <sm> joe9_: I tend to use docopt, because it has the least boilerplate and so is quickest to develop with. It is a little finicky until you know what it wants
12:46:00 <DELB_> I don't want to change my code much from that
12:46:29 <sm> https://github.com/simonmichael/quickbench/blob/master/src/QuickBench.hs#L28 is how I use it
12:46:34 <mauke> DELB_: I don't understand what you're trying to achieve with that code
12:47:11 <maerwald> sm: what is 80?
12:47:27 <DELB_> yeah neither do I
12:47:28 <DELB_> one sec
12:47:34 <sm> maerwald: columns
12:47:44 <maerwald> and there I thought it's your age :P
12:47:58 <sm> not quite there yet :)
12:50:06 <ertes> DELB_: you don't remove them, you don't produce them in the first place
12:50:33 <ertes> DELB_: the first step is: get rid of the second list; you don't need it
12:50:35 <sm> joe9_: I realise even this "low boilerplate" example is still quite a lot of code. It seems to be unavoidable if you want robust CLI handling :/
12:51:02 <DELB_>  Finally, add a function that, given n, computes how many prime twins are amongst the first n prime numbers.
12:51:15 <DELB_> is that even possible?
12:51:23 <ertes> @let isPrime n = all (\x -> mod n x /= 0) [2..n - 1]
12:51:26 <lambdabot>  Defined.
12:51:42 <jle`> DELB_: yes, it is possible
12:51:58 <DELB_> so how?  :P
12:52:04 <ertes> > [ (x, y) | x <- [2..n], isPrime x, let y = x + 2, isPrime y ]
12:52:06 <lambdabot>  *Exception: not an integer: n
12:52:09 <ertes> uhm
12:52:10 <tluble> is there runtime overhead for dependent types?
12:52:19 <mauke> > (\n -> filter (\(x,y) -> x+2 == y) ((zip <*> tail) (filter isPrime [3, 5 .. n]))) 20
12:52:21 <lambdabot>  [(3,5),(5,7),(11,13),(17,19)]
12:52:22 <jle`> tluble: it depends on how they're implemented
12:52:28 <ertes> > [ (x, y) | x <- [3..], isPrime x, let y = x + 2, isPrime y ]
12:52:31 <tluble> jle`: let's say idris
12:52:31 <lambdabot>  [(3,5),(5,7),(11,13),(17,19),(29,31),(41,43),(59,61),(71,73),(101,103),(107,...
12:52:48 <DELB_> but isn't the question asking for an integer?
12:52:55 <DELB_> like a number of how many twin primes there are
12:52:56 <maerwald> tluble: an excellent channel to ask the question would probably be #idris :P
12:53:03 <mauke> > filter (\(x,y) -> x+2 == y) ((zip <*> tail) (filter isPrime [3, 5 .. ]))
12:53:05 <jle`> DELB_: ertes 's function gives you a list of primes
12:53:06 <lambdabot>  [(3,5),(5,7),(11,13),(17,19),(29,31),(41,43),(59,61),(71,73),(101,103),(107,...
12:53:11 <jle`> *twin primes
12:53:12 <ertes> DELB_: you take the list of *all* twin primes, you takeWhile you're below the threshold, then you count the 'length
12:53:28 <jle`> DELB_: so, if you have a list of twin primes within a rnage...how do you get the number of twin primes within a range?
12:53:34 <ertes> oh, sorry…  i don't know if the list i've written is actually the list of all twin primes =)
12:53:37 <sm> joe9_: but working with "dopts" directly may be enough, instead of converting it to a custom type like I did
12:53:50 <jle`> DELB_: let's say i give you a list of all the vowels.  how would the number of vowels from that list?
12:53:53 * hackagebot ieee754 0.7.9 - Utilities for dealing with IEEE floating point numbers  https://hackage.haskell.org/package/ieee754-0.7.9 (PatrickPerry)
12:54:01 <DELB_> 5 isn't it
12:54:17 <jle`> sure, but if i gave you a list of things, how would you get the number of things there are
12:54:27 <DELB_> you'd count them
12:54:30 <jle`> yes
12:54:43 <jle`> > length ['a','e','i','o','u']
12:54:45 <lambdabot>  5
12:55:32 <joe9_> sm, Thanks.
12:55:32 <mauke> btw, my version only checks each number once for primality
12:55:42 <ertes> funny thing: if the twin prime conjecture is false, the twin prime list has a bottom =)
12:55:48 <DELB_> so it's not just as simple as length [(x, y) | x <- [3..], prime x, let y = x + 2, prime y]
12:55:49 <DELB_> is it?
12:55:50 <DELB_> :P
12:56:10 <jle`> DELB_: why wouldn't you think it is?
12:56:19 <jle`> are you looking for a complicated answer?
12:56:28 <DELB_> nah
12:56:52 <ertes> DELB_: conjecture: what you just wrote is just an infinite loop
12:56:58 <ertes> i can't prove that it is, but i'm pretty sure it is
12:57:03 <jle`> lol
12:57:20 <mauke> ertes: I can prove it
12:57:37 <jle`> DELB_: you want the length of the list of all twin primes between 1 and n
12:57:42 <jle`> DELB_: but the list you gave isn't that list
12:57:43 <DELB_> yeah
12:57:44 <jle`> it's a different list
12:57:51 <jle`> it's the list of all twin primes in general
12:57:56 <DELB_> yeah
12:58:26 <DELB_> how do I list the twin primes up to 10 then?
12:58:44 <ertes> mauke: you're right
12:58:55 <mauke> DELB_: takeWhile
12:58:58 <mauke> has been mentioned before
12:59:05 <tluble> Are there any things haskell programmers like better in ocaml?
12:59:16 <jle`> DELB_: you can also x <- [3.. 8]
12:59:18 <mauke> or do it the way I originally had, with .. n
12:59:28 <johnw> tluble: modules
12:59:35 <jle`> or x <- [3 .. (n - 2)]
12:59:36 <grantwu> tluble: extensible variants I think
13:00:12 <jle`> tluble: idris does type erasure in cases where it is possible
13:00:16 <jle`> (referring to your earlier question)
13:00:32 <jle`> and i also think that it erases proofs at runtime
13:00:35 <jle`> something that Haskell doesn't do
13:01:12 <jle`> so those are specific cases where dependently typed programming doesn't havea  runtime cost
13:01:22 <jle`> but i can't promise you that there is no cost in every situation whatsoever in idris
13:02:31 <tluble> jle`: Yeah I think I understand it as : the type signatures of a function will be checked at compile time to be correct for _any_ values in the type expressions
13:02:44 <maerwald> in F*, proofs that cannot be done at compile-time can be converted to exceptions at runtime, so there's definitely overhead there
13:02:49 <DELB_> primeTest3 :: Integer -> Integer 
13:02:50 <DELB_> primeTest3 n = length [(x, y) | x <- [3..n], prime x, let y = x + 2, prime y]
13:02:53 <DELB_> surely that should work?
13:03:13 <maerwald> but I doubt it's a lot
13:03:14 <mauke> no, length returns Int
13:03:14 <jle`> DELB_: it'll also count 'y' if y < n in that case
13:03:21 <jle`> er, y > n
13:04:02 <DELB_> so how do I not make it count y > n
13:04:05 <jle`> DELB_: also, that counts each twin prime pair only once
13:04:17 <jle`> DELB_: look at the list it returns, and tweak it. there are only small tweaks left
13:04:28 <jle`> try edge cases like the list for '41', '43'
13:04:36 <jle`> from looking at the list you can see what needs to be changed
13:04:45 <DELB_>     Couldn't match expected type `Integer' with actual type `Int'     In the expression:       length [(x, y) | x <- [3 .. n], prime x, let y = x + 2, prime y]     In an equation for `primeTest3':         primeTest3 n           = length [(x, y) | x <- [3 .. n], prime x, let y = x + 2, prime y]
13:04:53 <jle`> this is what mauke just said
13:04:57 <jle`> length returns an Int
13:04:58 <jle`> not an Integer
13:05:05 <DELB_> oh
13:05:21 <jle`> tluble: not sure what you are trying to say
13:05:50 <jle`> in relation to runtime overhead
13:06:00 <DELB_> jle`: I don't know what to tweak
13:06:00 <jle`> a naive implementation of dependent types will carry runtime overhead
13:06:40 <jle`> DELB_: what's wrong with it now as it is?  how is it different than what you wanted?
13:06:45 <Tuplanolla> Won't certain constructions always do that, jle`?
13:06:53 <DELB_> [21:04] <jle`> try edge cases like the list for '41', '43' [21:04] <jle`> from looking at the list you can see what needs to be changed
13:06:57 <DELB_> or were you talking to someone else?
13:07:03 <jle`> DELB_: yeah, try seieng what list is returned
13:07:09 <jle`> when you put in n = 41, or n = 43
13:07:18 <jle`> and see if that's what you really want, and how it's different than what you want
13:07:26 <jle`> Tuplanolla: yeah
13:07:29 <DELB_> I just get the number 6
13:07:41 <jle`> is that the answer you want?
13:08:00 <DELB_> uh
13:08:01 <DELB_> yah
13:08:16 <DELB_> or hmm
13:08:17 <DELB_> no
13:08:28 <DELB_> if you type 41 in you get 6 returned
13:08:33 <DELB_> or maybe it is right
13:08:35 <DELB_> I think it is
13:08:49 <mauke> try 3 as input; that's simpler
13:08:58 <DELB_> I get 1
13:09:12 <jle`> oh okay, then it should be right :) i misunderstood twin primes as 2 higher or lower
13:09:18 <jle`> i should retake number theory
13:09:30 <jle`> i thought both numbers in the pair were twin primes :3
13:09:37 <DELB_> no
13:09:41 <Welkin> what is a twin prime?
13:09:44 <DELB_> the (x, y) is the twin prime
13:09:48 <Welkin> 79 and 97?
13:09:55 <mauke> Welkin: no, x and x+2
13:09:55 <DELB_> A twin prime is a prime number that is either 2 less or 2 more than another prime number —for example, the twin prime pair (41, 43).
13:10:04 <Welkin> is 97 even prime?
13:10:13 <jle`> yeah, then you should be good :)
13:10:21 <kadoban> I think so
13:10:23 <DELB_> cool, thank you jle` and everyone else :)
13:10:29 <DELB_> maulke also
13:10:35 <DELB_> mauke*
13:10:36 <mauke> DELB_: you can speed up your code by changing [3 .. n] to [3, 5 .. n]
13:10:57 <mauke> and by only calling isPrime once per number, but that's a bigger change
13:10:58 <DELB_> ok, I changed it, thanks
13:11:12 <DELB_> the speed doesn't matter
13:11:19 <DELB_> as long as I write some code that does what it needs to do
13:13:35 <ertes> > 3 : scanl (+) 5 (cycle [2,4])
13:13:38 <lambdabot>  [3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,...
13:16:15 <Welkin> lol Apocalisp
13:16:17 <Welkin> nice nick
13:16:50 <ertes> > [ (x, y) | [(x, True), (y, True)] <- iterate tail (map (\x -> (x, isPrime x)) (3 : scanl (+) 5 (cycle [2,4]), l)) ]
13:16:52 <lambdabot>  error:
13:16:52 <lambdabot>      • Couldn't match expected type ‘[t]’
13:16:52 <lambdabot>                    with actual type ‘([Integer], Expr)’
13:17:03 <mauke> unbound variable detected
13:17:20 <ahri> hi, when installing haskell-stack on ubuntu 16.10 (or indeed using the fpcomplete repos) i get errors when running "stack setup" - i guess this happens to everyone on 16.10; am i doing something wrong?
13:17:21 <ertes> > [ (x, y) | [(x, True), (y, True)] <- iterate tail (map (\x -> (x, isPrime x)) (3 : scanl (+) 5 (cycle [2,4]))) ]
13:17:28 <lambdabot>  mueval-core: Time limit exceeded
13:17:31 <ertes> weird…  how did that one get there…
13:17:37 <sbrg> ahri: what are the errors?
13:17:40 <ertes> > [ (x, y) | (x, True) : (y, True) : _ <- iterate tail (map (\x -> (x, isPrime x)) (3 : scanl (+) 5 (cycle [2,4]))) ]
13:17:45 <lambdabot>  [(3,5),(5,7),(7,11),(11,13),(13,17),(17,19),(19,23),(29,31),(37,41),(41,43),...
13:17:47 <ertes> finally…
13:18:34 <ertes> and of course it's wron
13:18:38 <ertes> yeah, that
13:19:07 <ertes> > [ (x, y) | (x, True) : (y, p) : _ <- iterate tail (map (\x -> (x, isPrime x)) (3 : scanl (+) 5 (cycle [2,4]))), y == x + 2, p ]
13:19:10 <lambdabot>  [(3,5),(5,7),(11,13),(17,19),(29,31),(41,43),(59,61),(71,73),(101,103),(107,...
13:19:57 <DELB_> the English of my teacher isn't that great, so can someone clarify here to see if I've done this correctly?
13:19:59 <DELB_> Given a list of list of integers produce a list which contains the length of each list in the list. Further compute a list which contains the smallest element of each list. If the list does not have a smallest element, no element at all should be included for that list. Include the most general type (not only integers) of this function as a comment at the end.
13:20:03 <ahri> sbrg: i get gcc linker errors mentioning -fpic
13:20:16 <DELB_> http://pastebin.com/C52qVxhT
13:20:28 <ahri> sbrg: it looks like it's mentioned on https://github.com/commercialhaskell/stack/issues/2542 actually
13:20:29 <sbrg> ahri: aah, I've seen that. are you running arm, by chance?
13:20:49 <ahri> sbrg: no, it's an intel i5, 64bit
13:21:19 <Clint> ahri: gcc -v 2>&1 | grep --color default-pie
13:22:18 <ahri> Clint: it says --enable-default-pie
13:23:33 <Clint> ahri: then you need a workaround
13:23:58 <ahri> heh
13:24:22 <ahri> https://github.com/commercialhaskell/stack/commit/e3aa2388cefc083605091c55e92d9af09e048182 appears to be addressing my issue, but i'm not sure how i can use that patched version of stack
13:24:56 <DELB_> smallestele xss = [x | xs <- xss, x <- map minimum [xs]]
13:25:16 <DELB_> [*** Exception: Prelude.minimum: empty list
13:25:28 <DELB_> that returns when I do [[],[]]
13:25:32 <DELB_> I don't want the exception returned
13:25:52 <DELB_> I just want basically [[], []] that
13:25:59 <mmaruseacph2> > minimum []
13:25:59 <Hafydd> DELB_: "map minimum [xs]" is the same as "[minimum xs]".
13:26:01 <lambdabot>  *Exception: Prelude.minimum: empty list
13:26:05 <mmaruseacph2> > minimum [[]]
13:26:07 <lambdabot>  []
13:26:27 <glguy> [ minimum xs | xs <- xss, not (null xs) ] -- perhaps
13:26:54 <Hafydd> There are lots of non-empty lists that don't have a smallest element.
13:27:06 <dfeuer> edwardk, the documentation for FocusingOn looks wrong. It claims it's used for MaybeT, but it looks like MaybeT actually uses FocusingMay.
13:27:08 <jle`> yeah, that part is a bit weird for a class
13:27:09 <Hafydd> (Presumably the teacher implicitly only requires finite lists to be accepted, though.)
13:27:34 <DELB_> yeah that works glguy
13:27:35 <DELB_> thanks
13:28:07 <DELB_> Include the most general type (not only integers) of this function as a comment at the end.
13:28:17 <DELB_> what does my lecturer mean by this?
13:28:29 <Hafydd> No, it doesn't.
13:28:45 <jle`> DELB_: the type shouldn't be [[Integer]] -> [Integer]
13:28:47 <jle`> but more polymrophic
13:28:52 <dfeuer> In the comment.
13:29:00 <Tuplanolla> Is Ben of Gloss fame here?
13:29:05 <dfeuer> Apparently the code is supposed to have the more specific type for some reason?
13:29:05 <jle`> `[[a]] -> [a]` doesn't work so you might have to constrain it
13:29:23 <dfeuer> What's this function do?
13:29:28 <DELB_> dfeuer yeah my lecturer wants that as a more specific type
13:29:34 <DELB_> the actual function
13:29:41 <DELB_> but just wants a comment at the end for a more general type
13:29:47 <DELB_> so I guess I just do [[a]] -> [a]?
13:30:00 <mmaruseacph2> except that won't work
13:30:03 <Tuplanolla> I guess I'll have to send mail instead.
13:30:20 <Hafydd> Oh... it does for finite lists. I don't know what I was thinking of.
13:30:30 <DELB_> I get an error for [[a]] -> [a]
13:30:36 <DELB_> what else could it be?
13:30:46 <dfeuer> DELB_, what does this function do?
13:30:57 <DELB_> smallestele xss = [minimum xs | xs <- xss, not (null xs)]
13:30:59 <mmaruseacph2> you could do the type inference or let the compiler do it
13:31:11 <DELB_> smallestele returns the smallest element inside a list in a list
13:31:12 <Hafydd> DELB_: look at the type of "minimum" for a hint.
13:31:50 <DELB_> Ord a => [a] -> a
13:31:51 <DELB_> ?
13:32:09 <Hafydd> Yes.
13:32:19 <DELB_> smallestele :: [[a]] -> [a]
13:32:20 <Hafydd> "Ord a" is the context you need to take the minimal element.
13:32:52 <koala_man> I have hundreds of functions and I want to choose some subset to map over thousands of elements. What's a good way to do that? Trivial solutions include having each function guard each time, or having each function actually be :: Parameters -> Maybe (a -> b)
13:32:57 <DELB_> right
13:32:57 <DELB_> thanks
13:33:08 <jle`> koala_man: Map Parameters (a -> b)
13:33:25 <mmaruseacph2> @type this homework = [minimum work | question <- homework, not (null question)]
13:33:27 <lambdabot> error:
13:33:27 <lambdabot>     parse error on input ‘=’
13:33:27 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
13:33:42 <mmaruseacph2> @type \homework -> [minimum work | question <- homework, not (null question)]
13:33:44 <lambdabot> error: Variable not in scope: work :: [t]
13:33:50 <jle`> lol
13:34:04 <mmaruseacph2> @type \homework -> [minimum work | work <- homework, not (null work)]
13:34:06 <lambdabot> (Foldable t1, Ord t) => [t1 t] -> [t]
13:34:10 <mmaruseacph2> yeah, fool of a me
13:34:43 <DELB_> smallestele :: Ord a => [[a]] -> [a]
13:34:46 <DELB_> smallestele xss = [minimum xs | xs <- xss, not (null xs)]
13:34:48 <dfeuer> :t \xss -> xss >>= \xs -> if null xs then empty else pure (minimum xs)
13:34:50 <lambdabot> (Alternative m, Foldable t, Ord b, Monad m) => m (t b) -> m b
13:34:59 <DELB_> if I input a list like so: [[1,1,2,3], [1,2,3,4]]
13:35:01 <koala_man> jle`: there can be many permutations of parameters though. the functions are static analyzers, and some apply for all verbosity levels but only one language, while others apply for all languages but only certain levels
13:35:15 <DELB_> I want the first list in the list to return [] and the second to return [1]
13:35:18 <DELB_> how can I do this?
13:36:06 <dfeuer> DELB_, you need to start by explaining, in detail, what you want.
13:36:22 <DELB_> Include the most general type (not only integers) of this function as a comment at the end.
13:36:26 <DELB_> nope not that
13:36:26 <dfeuer> Examples are useful for building intuition, but you have to make the step from intuition to precise description.
13:36:36 <mmaruseacph2> or just give us the email of the lecturer and we'll ask him for a copy of the asignment
13:36:44 <mmaruseacph2> *assignment
13:36:54 <DELB_> :P
13:36:55 <dfeuer> So saying you want certain results from certain lists is only the beginning.
13:36:59 <DELB_> right
13:37:00 <DELB_> Further compute a list which contains the smallest element of each list. If the list does not have a smallest element, no element at all should be included for that list.
13:37:11 <DELB_> If the list does not have a smallest element, no element at all should be included for that list.
13:37:20 <DELB_> what I have: smallestele xss = [minimum xs | xs <- xss, not (null xs)]
13:37:30 <mmaruseacph2> [1, 1, 2,3] still has a smallest element, although duplicated
13:37:36 <DELB_> yes
13:37:45 <dfeuer> I'd still call 1 the smallest element, yes.
13:37:55 <DELB_> I'm not sure what she means by what she says
13:37:57 <DELB_> what do you think she means?
13:38:37 <dfeuer> If you aren't sure what your teacher means, you should probably ask her. We can only make educated guesses.
13:38:51 <DELB_> yeah, I'll email her 
13:38:52 <DELB_> thanks
13:38:54 <ertes> DELB_: there is at least one list that truly has no smallest element
13:38:55 * hackagebot cassava 0.4.5.1 - A CSV parsing and encoding library  https://hackage.haskell.org/package/cassava-0.4.5.1 (HerbertValerioRiedel)
13:39:00 <DELB_> which is?
13:39:06 <ertes> DELB_: maybe she meant that one?
13:39:09 <ertes> DELB_: figure it out
13:39:16 <ertes> which list doesn't have a smallest element?
13:39:31 <DELB_> an empty list...?
13:39:37 <Koterpillar> > [-1, -2, ...]
13:39:39 <lambdabot>  <hint>:1:13: error: parse error on input ‘]’
13:39:46 <Koterpillar> > [-1, -2...]
13:39:48 <lambdabot>  error:
13:39:48 <lambdabot>      A section must be enclosed in parentheses thus: (- 2 ...)error:
13:39:48 <lambdabot>      The operator ‘...’ [infixr 9] of a section
13:39:53 <ertes> DELB_: yeah
13:40:05 <dfeuer> Koterpillar, yeah, but we don't want to go there, do we?
13:40:07 <ertes> DELB_: but note: i do *not* know if that's what she meant
13:40:10 <Koterpillar> j/k
13:40:26 <ertes> DELB_: in other words: write that e-mail anyway
13:40:45 <DELB_> ok
13:40:48 <DELB_> thanks
13:43:07 <jle`> > [-1, -2 ..]
13:43:10 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
13:43:36 <dfeuer> Koterpillar, to make the joke more Haskelly,  noMinimum = (repeat ()) : map (undefined:) noMinimum
13:44:36 <dfeuer> Oh, I guess there are extra parens.
13:44:46 <jle`> extra parens is very un-haskelly
13:44:55 <dfeuer> noMinimum = repeat () : map (undefined:) noMinimum
13:45:03 <dfeuer> But then of course that's too pointy.
13:45:06 <ertes> that's not haskelly
13:45:26 <ertes> fix ((:) (repeat ()) . map (undefined :))
13:45:33 <dfeuer> I was just getting there.
13:46:25 <dfeuer> ertes, but don't you mean    fix $ (repeat () :) . map (undefined :)  ?
13:46:48 <ertes> partly perhaps
13:47:14 * ertes doesn't like ($)
13:47:30 <ertes> better like this:  fix `id` ((repeat () :) . map (undefined :))
13:47:37 <maerwald> ertes: yeah, make it more obfuscated
13:48:01 <dfeuer> ertes, someone (Cale?) says that the big problem with $ is that it's infixr when it should be infixl. I think I agree.
13:49:09 <ertes> dfeuer: i honestly prefer parentheses in both cases, except for the few layout cases like:  f $ do …
13:50:21 <Hafydd> What is the argument for $ being infixl?
13:50:36 <ertes> Hafydd: f $ arg1 $ arg2 $ arg3
13:51:34 <Hafydd> I find myself needing the infixr case of "f $ g x ..." more often.
13:51:51 <ertes> Hafydd: that's not infix-any-direction
13:51:52 <monochrom> Oh isn't it great, you could argue both ways.
13:52:05 <maerwald> yet another stylistic nitpicking discussion
13:52:07 <Hafydd> ertes: it is if "..." contains $.
13:52:17 <ertes> ok =)
13:52:19 <monochrom> Rationale for infixl: so that it is similar to juxtaposition.
13:52:20 <maerwald> I like how that problem is solved in purescript
13:52:28 <monochrom> Rationale for infixr: so that it is complementary to juxtaposition.
13:52:31 <maerwald> remove the operator, lol
13:53:01 <Hafydd> In the infixl case, you can with less resulting ugliness just introduce parentheses.
13:53:37 <maerwald> while we're arguing about this, a java developer is already unit testing his web application :P
13:53:43 <Hafydd> Hahaha.
13:53:46 <maerwald> in other words: wasted time
13:53:58 <Tuplanolla> Then there's the use case for `x & if p then f else g`.
13:54:00 <Hafydd> If you aren't interested in the argument, you're free to not take part.
13:54:08 <ertes> no worries…  we don't need to unit-test, so we can use that extra time =)
13:54:13 <maerwald> ertes: haha
13:54:25 <monochrom> "compiling"
13:54:41 <maerwald> well, testing a rest API still requires unit testing, even in haskell
13:54:46 <maerwald> property testing makes no sense there
13:55:05 <ertes> no, it does not!  IT TYPE-CHECKS!
13:55:08 <Hafydd> One of the great things about Haskell is that the language designers sat down and thought about things for longer than strictly necessary to make a programming language.
13:55:16 <maerwald> ertes: a rest API? aha.
13:55:17 <Welkin> not for servant APIs
13:55:25 <Welkin> the api is in the types
13:55:35 <maerwald> Welkin: including successful db queries?
13:55:42 <dfeuer> If we want to *really* obfuscate, we need  fix $ (pure (fix (pure () <|>)) <|>) . fmap (pure undefined <|>)
13:55:54 <monochrom> but pretty sure a a java developer would waste time arguing over scala vs haskell
13:56:05 <ertes> dfeuer: except now you need a type signature
13:57:51 <ertes> if you think java developers don't waste time, watch a java dev meeting…  you might think they're talking about the industrial revolution, when in fact they're talking about…  i don't know…  OO stuff
13:57:52 <monochrom> @type fix $ (pure (fix (pure () <|>)) <|>) . fmap (pure undefined <|>)
13:57:54 <lambdabot> (Alternative f1, Alternative f) => f (f1 ())
13:58:07 <Tuplanolla> Syntax is important and it's nice when it's well thought-out. I also find joy in type signatures like `Lens s t a b` or `Gr a b`. They communicate a great attention to detail.
13:58:38 <maerwald> I like simple APIs and hidden complexity, so I don't like lens.
13:58:40 <dfeuer> ertes, you should have type signatures anyway.   type App f x = f x;  noMinimum :: (c ~ Alternative, App c f, App c g) => App f (App f1 ())   should be confusing enough for most purposes.
13:58:55 <maerwald> (note that I'm not in any way saying I can do it better)
14:00:39 <dfeuer> maerwald, I suspect many of the problems are with documentation. But there is that shady instance for traversals to allow ad hoc indexed/non-indexed things to work; that one disturbs me.
14:01:02 <dfeuer> (I don't claim to understand WTF it's about, but I generally don't believe in invalid instances.)
14:01:46 <maerwald> dfeuer: I don't care about random depths of category theory just so I can access my data slightly less awkwardly. The effort is in no way proportional to the benefit, unless you write a compiler ro something like that.
14:02:19 <maerwald> or if you happen to just find CT interesting by itself
14:03:10 <dfeuer> maerwald, the *basics* of lens are pretty cool. But I think it's fair to criticize it for going too far.
14:05:04 <dfeuer> maerwald, the choice to use bare functions seems to have been largely forced (as we see over and over again!) by package dependency issues.
14:05:32 <dfeuer> Bare functions do not make for an easy-to-understand or easy-to-debug lens API.
14:07:06 <ertes> foldr (\x -> (>>= zipWith ((. (x:)) . (++)) <$> inits <*> tails)) [[]] "abc"
14:07:09 <ertes> > foldr (\x -> (>>= zipWith ((. (x:)) . (++)) <$> inits <*> tails)) [[]] "abc"
14:07:12 <lambdabot>  ["abc","bac","bca","acb","cab","cba"]
14:07:43 <kuribas> dfeuer: Edward Kmett said it become so complicated because people wanted to add features.
14:07:51 <ertes> never obfuscate without foldr
14:08:39 <kuribas> dfeuer: that's the reason it became so abstract.
14:08:47 <kuribas> but it's pretty amazing it works at all.
14:09:24 <ertes> > foldM (\xs x -> zipWith ((. (x:)) . (++)) <$> inits <*> tails $ xs) [] "abc"  -- or my older version of it
14:09:25 <kuribas> > over (mapped._2) (+1) [("a", 1), ("c", 2)]
14:09:26 <lambdabot>  ["cba","bca","bac","cab","acb","abc"]
14:09:27 <lambdabot>  [("a",2),("c",3)]
14:10:18 <kuribas> I personally dislike the many operators in lens.
14:10:18 <ertes> > filterM (pure [2<1..]) "abc"  -- here is another lovely gem
14:10:20 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
14:12:08 <kuribas> :t pure [2<1..]
14:12:09 <lambdabot> Applicative f => f [Bool]
14:12:50 <Koterpillar> > [2<1..]
14:12:52 <lambdabot>  [False,True]
14:12:54 <MarcelineVQ> why is that so roundabout :>
14:13:13 <dolio> Optimized for character count, probably.
14:13:27 <monochrom> Oh God
14:14:08 <ertes> dolio: optimised for obfuscation without increasing the character count too much
14:16:24 <joncol> Hi, I'm looking a bit at Data.Tree (rose trees) and I'm confused why there is no data constructor for an empty tree?
14:16:54 <glguy> joncol: Forest is the type you're looking for if you can have zero to many trees
14:17:16 <joncol> glguy: Ah, of course. Thanks
14:21:41 <mmaruseacph2> ertes: that gem is cool for codegolfing
14:23:08 <maerwald> dfeuer: it has it's purpose and it's an extrodinary technological achievement. I just think the _useful_ scope is much smaller than ppl think it is.
14:24:36 <Welkin> cogolfing
14:24:48 <Welkin> bigolfing
14:25:13 <Tuplanolla> Some libraries don't need to be used to be useful. In fact I think Haskell is the only language I've used that has libraries that exist for mere rumination.
14:25:52 <Welkin> Tuplanolla: acme-*
14:25:53 <maerwald> yeah, it has a much more experimentally-oriented community
14:26:07 <Tuplanolla> Some parts of `lens` belong to that group.
14:26:23 <Welkin> I only use lens when I am forced to
14:26:28 <maerwald> Welkin: same
14:26:29 <Welkin> like when using the aws sdk
14:26:35 <ab9rf> i ahve yet to felt compelled to use lens
14:26:50 <ertes> hmm…  the dual to codegolfing is degolfing
14:27:00 * Clint coughs.
14:27:00 <ertes> ab9rf: traversals are quite compelling to me
14:27:22 <ab9rf> ertes: i may yet be compelled, so far not
14:27:24 <ertes> lenses alone not so much, except for nested cases
14:27:30 <ab9rf> nor have i been mpelled.
14:30:44 <jle`> i like the principle of using more general constraints to limit the functionality of your functions
14:31:04 <jle`> so if traversals are useful, so are lenses, by virtue of being "constrained" traversals
14:31:20 <jle`> the general optics pattern is cute
14:31:52 <jle`> the (a -> f b) -> (s -> f t), where the constraints on 'f' tell you about the nature of the optic ... many items, one item?
14:32:03 <jle`> can it change the thing, can it no?
14:32:05 <jle`> *not
14:32:42 <jle`> and generalized to p a (f b) -> p s (f t) to let you say even more.
14:32:56 <jle`> the nice thing is that you actually have a subtype hierarchy because of how they all unify
14:36:14 <ertes> > (blocks 3 . ix 0 . letter +~ 1) "This Is A Test"
14:36:17 <lambdabot>  "Uhit It A Tett"
14:36:18 <dfeuer> kuribas, the abstraction of lens isn't as much a problem as the fact that not all the abstractions are explained well if at all.
14:36:31 <Welkin> lambdabot knows so many languages
14:36:33 <ertes> ab9rf: ^ stuff like that is pretty useful (change the third position in each 3-block of substrings)
14:36:47 <dfeuer> Also, the fact that BazaarT has a "questionable" Contravariant instance that seems to be important for type-directed metaprogramming is sad.
14:36:54 <Welkin> ertes: now do it with unicode symbols for the operators
14:36:57 <kuribas> dfeuer: true, I know only a little of lens, and the rest is black magic for me...
14:37:47 <ertes> ab9rf: all of these are traversals
14:41:19 <ertes> > map (letter +~ 13) "Guhefqnl avtug srire, avtug srire…"
14:41:22 <lambdabot>  "Thursday night fever, night fever\8230"
14:41:58 <tluble> It seems like ML's modules and haskell's typeclasses have significant overlap, does it make sense to have both in a language?
14:45:57 <needHelp> hi guys could some kind soul please look into this code: http://pastebin.com/EduZRL5E specifically at the last 2 functions starting at line 89
14:46:08 <needHelp> 88*
14:46:26 <needHelp> i also pasted the error message at the very last line
14:47:03 <jle`> needHelp: you don't handle the case of (Node _ _ _) []
14:47:20 <jle`> needHelp: also, you don't need to '== Nil'
14:47:23 <jle`> you can just pattern match :)
14:47:34 <needHelp> youre right
14:47:40 <needHelp> ill try that
14:47:43 <jle`> needHelp: if you turn on -Wall, ghc will tell you what patterns are missing
14:47:54 <needHelp> oh 
14:47:54 <needHelp> nice
14:47:59 <needHelp> ill try that
14:48:21 <needHelp> wow thats cool
14:48:21 <needHelp> thanks
14:50:26 <jle`> no problem!
14:53:57 * hackagebot drmaa 0.1.1 - A minimal Haskell bindings to DRMAA C library.  https://hackage.haskell.org/package/drmaa-0.1.1 (kaizhang)
14:55:51 <ahri> i'm trying to install ghc-mod with stack but it fails telling me "Plan construction failed" due to version constraints..... i tried installing the dependency at the version it wanted (optparse-applicative-0.12.1.0) but it says the same thing. i'm new to stack and don't understand what i should do next - can anyone give me a pointer?
14:57:44 <mmaruseacph2> ertes: that gem is cool for codegolfing
14:57:48 <mmaruseacph2> sorry, bad window
14:57:55 <mmaruseacph2> (and uparrow+enter)
14:58:20 <vukovinski> ahri: is this for visual studio code haskell extension?
14:58:39 <vukovinski> I had a similar problem with ghc-mod
14:58:45 <ahri> vukovinski: it's for vim actually, but yeah, same sort of thing!
14:59:58 <ahri> i just don't really understand why it's not picking the version of the dependency it's already told me is the "latest applicable"
15:01:09 <vukovinski> ahri: my problem was fedora 24, I installed ghc globally which was a lower version then the one required for the extension and mod
15:02:05 <ahri> well i ran `stack setup' so it has the latest ghc available
15:02:50 <ahri> ghc-nopie-7.10.3 is the one it installed
15:03:00 <needHelp> jle`: you said earlier i dont have the case:  (Node _ _ _) (_ : (_ : _))
15:03:06 <needHelp> let me try again
15:03:24 <ab9rf> that case has a lot of degrees of freedom
15:03:28 <needHelp> you said earlier i dont conver the case: >inOrder (Node _ _ _) []
15:03:28 <ahri> i'm on ubuntu so i think the nopie is a workaround for something they did at a distro level
15:03:43 <Welkin> nopie?
15:03:45 <Welkin> what is that?
15:03:58 <Tuplanolla> No position independent executable, Welkin.
15:04:00 <ab9rf> the opposete of a yeppie
15:04:02 <Welkin> never install ghc from your package repo
15:04:05 <Tuplanolla> The same thing we hear about every day.
15:04:15 <Welkin> always use either stack, nix, or the binary distribution from the haskell website
15:06:09 <ahri> i installed ghc and cabal-install in order to build the latest stack from the git repo, because neither fpc's repo, or nix could give me a version that wouldn't fall over
15:06:23 <ahri> see: https://github.com/commercialhaskell/stack/issues/2542
15:06:24 <monochrom> recall "no-PIE"
15:06:51 <ahri> so now i have stack, and it installed ghc-nopie-7.10.3, so i should be fine, right?
15:07:16 <dmj`> Is it possible to have a default type synonym?
15:07:17 <ahri> i can run "stack ghc -- --version" and it reports 7.10.3
15:07:27 <Welkin> dmj`: what do you mean?
15:08:06 <dmj`> Welkin: suppose I have a class, class IsString str => ToMyString str where toMyString :: str -> MyString
15:08:22 <ahri> so: with this acceptable version of stack, how can i install ghc-mod, given that `stack install ghc-mod' gives me an error saying it can't construct a build plan?
15:08:28 <dmj`> Welkin: and a function text :: ToMyString str => str -> MyString
15:08:48 <dmj`> if I just do: text "foo", it will be ambiguous, since it doesn't know which IsString instance to choose
15:08:55 <dmj`> I'd like to pick a default one, in this case
15:08:58 <Welkin> okay
15:09:01 <dmj`> as opposed to forcing the user to specify
15:09:04 <Welkin> doesn't ghc pick one for you?
15:09:10 <dmj`> Welkin: how can it?
15:09:23 <Welkin> based on usage
15:09:33 <Unicorn_Princess> how do i make [[]] an instance of Functor? ghc keeps saying that [] wants a kind *, but ofc if I give it like [[a]], then understandably complains that Functor wants kind * -> *
15:09:34 <monochrom> dmj`: Read the GHC User's Guide about "extended defaulting". There maybe something you can control.
15:09:36 <dmj`> Welkin: in this case the usage is ambiguous, since it's looking for some IsString
15:10:02 <jle`> dmj`: maybe you mean default type instance, instead of default type synonym?
15:10:31 <Welkin> well wait, that example will work unless you use OverloadedStrings
15:10:34 <Unicorn_Princess> (i'm trying to make nested functors an instance of Functor, as per the typeclassopedia homework, and thought i'd start with nested lists first)
15:10:50 <ahri> just to make you happy i've uninstalled both ghc and cabal-install, so now i only have stack - and it can't install ghc-mod...... its error message is not helping
15:11:01 <jle`> Unicorn_Princess: you need to give it a newtype wrapper
15:11:21 <jle`> newtype NestedList a = NL [[a]]
15:11:24 <dmj`> Welkin: oh, well that works too, heh
15:11:46 <dmj`> don't mind disabling one extra pragma, hope that doesn't hurt people when they care to use that extension in other places within the module
15:12:03 <ertes> Unicorn_Princess: the kind error is not caused by Functor wanting a * -> *, but by [] wanting a *
15:12:16 <dmj`> monochrom: thanks, I'll check that out
15:12:33 <dmj`> Welkin: that will allocate a String first though :/ as a CAF
15:12:49 <Unicorn_Princess> jle`: i see how that would work. but hw would i build on that to make a generic nested functor?
15:12:56 <ertes> Unicorn_Princess: [] :: * -> *, so it can't be applied to [] :: * -> *, but for example to Integer :: *
15:13:10 <Tuplanolla> Another option is to import or define `Compose` and use that, Unicorn_Princess.
15:13:17 <Tuplanolla> > getCompose (fmap negate (Compose [[1 .. 4]]))
15:13:19 <lambdabot>  error:
15:13:19 <lambdabot>      Variable not in scope: getCompose :: f0 Integer -> terror:
15:13:19 <lambdabot>      • Data constructor not in scope:
15:13:25 <ahri> here's the command and error i'm getting: https://gist.github.com/ahri/13b5aa509edb7becac87be63d742ed41
15:13:32 <dmj`> Welkin: this should work for now, thanks
15:13:50 <Tuplanolla> That would work if lambdabot had its imports straight.
15:15:34 <dfeuer> Ping dcoutts 
15:15:43 <dcoutts_> dfeuer: mm?
15:15:44 <monochrom> haha chapter 17 "Care and feeding of your GHC Users Guide"
15:15:51 <Unicorn_Princess> hm, thanks
15:16:28 <dfeuer> I'm watching your ZuriHac 2015 talk on (de)serialization, and I have a decent guess, I think, about the allocation/time mismatch at 35 min.
15:16:38 <dfeuer> Of course, you may have figured it out already.
15:17:34 <dcoutts_> dfeuer: oh?
15:17:41 <monochrom> dmj`: The way I read it, OverloadedString adds defaulting IsString to String already. I don't know what happens if you throw in your own subclass ToMyString, but there may still be hope.
15:18:42 <dfeuer> dcoutts_, allocating less very-short-lived garbage shouldn't have a big impact on the generational problem. That garbage will rarely trigger a major collection.
15:19:11 <dfeuer> Or it may, but not as often as you imagined.
15:19:24 <dcoutts_> dfeuer: hmm, that ought to be true of all those allocations though (except the ones that remain at the end)
15:20:16 <dfeuer> I'm not sure what you mean by that.
15:20:18 <dcoutts_> and the final size is the same for them all *I think*, though I didn't check that carefully. Perhaps there's something hanging around 'til the deepseq at the end
15:21:09 <dfeuer> It will have *some* effect, because some temporary structure will be evacuated "by mistake". But not huge.
15:21:51 <dmj`> monochrom: seems to be redundant, I'm not referencing any methods from the IsString superclass. Removing it still shows an ambiguity with OverloadedStrings enabled. Default IsString as the type of my choosing would be nice.
15:22:05 <dfeuer> dcoutts_ what do you mean by the final size?
15:22:14 <monochrom> dmj`: It seems that if you turn on both OverloadedStrings (so IsString defaults to String; you can change by a "default" declaration) and ExtendedDefaultRules (so GHC doesn't mind your additional subclasses), it should do it.
15:22:27 <dcoutts_> dfeuer: the size of the deserialised structure remaining at the end
15:23:06 <dmj`> monochrom: hmmmmmmmm, ok let me try that
15:23:27 <dfeuer> dcoutts_, how could that be different? Accidental laziness?
15:24:02 <dcoutts_> dfeuer: yes, deserialisation necessarily reads all the input data, it doesn't necessarily produce normal form results.
15:24:24 <dcoutts_> e.g. consider deserialising something as a list and lazily constructing some other structure
15:25:41 <dfeuer> dcoutts_, yeah, I'm familiar with that sort of matter; I'd say if they do something different it's pretty much a bug. This sort of thing should generally be "as eager as permissible".
15:26:14 <dfeuer> (whatever that means in context)
15:26:31 <dcoutts_> dfeuer: in general I agree (for deserialisation), though it's sometimes useful to be able to explicitly be more lazy
15:27:01 <dfeuer> dcoutts_, some laziness is inherent in a monadic/applicative interface.
15:27:08 <dcoutts_> right
15:27:21 <dcoutts_> one has to fight against that somewhat in deserialisation libs
15:27:57 <jle`> @tell Unicorn_Princess to nest functors generically, you can define newtype NestedFuncs f g a = NF (f (g a)).  this type is actually defined in base in the Data.Functor module as 'Compose'
15:27:57 <lambdabot> Consider it noted.
15:28:14 <dfeuer> That can always be patched around (possibly with some cost) using the monadic interface; I guess you'd probably want to offer stricter "applicative-style" combinators?
15:29:20 <dmj`> monochrom: Nice, but I think it's ok for now, don't want the external interface for this library to require users to do something like this. But yes, it's very cool.
15:29:25 <monochrom> dmj`: oohhh, doesn't seem to work.
15:29:38 <dmj`> monochrom: what error did you get
15:30:58 <monochrom> I am doing "class IsString a => MyClass a where f :: a -> a".  (And I have my own type W, and it's instance of both IsString and MyClass, and I have "default (W)".)
15:31:38 <monochrom> I do "x = f "abc"" and the error is "Ambiguous type variable ‘a0’ arising from a use of ‘f’ prevents the constraint ‘(MyClass a0)’ from being solved."
15:34:09 <Tuplanolla> I already mentioned that, jle`.
15:34:26 <dmj`> monochrom: interesting
15:34:35 <dmj`> think I'll try just removing OverloadedStrings for now
15:34:53 <dmj`> String -> JSString seems efficient (unsafeCoerce)
15:40:29 <n_blownapart> hi the machine is not in front of me, but I was having trouble getting ide-haskell set up in atom. I was getting error messages indicating that the ghc-mod versions were incompatible. sorry this is by memory. any good advice .. or tutorials on how to properly set up this environment/ thanks - this is on debian linux -sorry to those helping me last night
15:41:25 <geekosaur> ghc-mod's something of a pain because it's tied to a specific ghc, but a given project you are working on may use a different ghc --- especially if you are using stack
15:42:56 <geekosaur> (in particular, it's not just a version tie; stack will use its own build of ghc instead of the OS package by default, and a ghc-mod built against the OS package will probably fail)
15:43:48 <drdo> I don't remember exactly what ghc-mod did, but I think haskell-mode does a lot more now
15:44:48 <n_blownapart> thanks my unix skills are quite weak geekosaur  ;  how do I get atom to find the non-native ghc-mod ... haskell-mode ? whats that?
15:45:32 <dmj`> monochrom: already doing enough wonky stuff as it is, Data.JSString and Data.Text have idential interfaces, so based on the compiler, this custom string module will re-export either .JSString or .Text
15:46:57 <geekosaur> n_blownapart, haskell-mode is the emacs support for haskell programming. but it also uses something like ghc-mod, so I think drdo is a bit off course
15:47:42 <monochrom> No, haskell-mode just calls ghci
15:47:52 <geekosaur> anyway you would have to ensure a ghc-mod built against whatever ghc is being used, and probably put it in the same place as that ghc and make sure one built against a different ghc is not found first. how exactly you do this depends on how the other ghc is being found
15:48:00 <geekosaur> but probably involves $PATH
15:48:21 <geekosaur> (the sting in the tail here is that stack probably doesn't want you sticking a ghc-mod in the same place it hides its ghc builds)
15:48:42 <Welkin> this is why you use nix-shell :D
15:49:03 <Welkin> pretty sure you can configure it to choose the ghc version
15:49:06 <Welkin> just give it a path
15:49:49 <n_blownapart>  I put /.local/bin in the path but still got the errors
15:49:50 <dmj`> Welkin: nix-shell --argstr compiler ghc801
15:49:57 <dmj`> if using cabal2nix
15:50:00 <Welkin> lol
15:50:10 <Welkin> those were two separate comments I made
15:50:20 <Welkin> you should be able to configure ghc-mod I meant
15:50:26 <n_blownapart> wait you all talking about atom ? oh ok. 
15:50:31 <Welkin> but yeah, that too
15:51:36 <MarcelineVQ> n_blownapart: build ghc-mod with the same resolver you build your project with, if that doesn't solve it then also start atom with `stack exec atom` to set up pathing
15:51:42 <drdo> geekosaur: What do you mean? I used ghc-mod on emacs for some extra funcionality
15:51:55 <MarcelineVQ> I've had to use stack exec atom recently, but didn't need to in the past so I'm not sure what's up
15:52:04 <drdo> All I'm saying is that I think some of that funcionality is also available in haskell-mode now
15:52:13 <n_blownapart> geekosaur: et al - ok say the ghc-mod and related binaries are in /.local/bin . what would the path look like in .bashrc?
15:52:15 <Welkin> I always start emacs from the terminal to set the path correctly on osx
15:52:23 <Welkin> that's just how it goes with this
15:52:50 <Welkin> although that is for using pdflatex in latex-mode
15:53:35 <n_blownapart> well thats another thing Welkin  .. is emacs better to learn ? in the scheme world some people swear by it. I'm a noob obviously, just trying to set up an ide. drRacket for scheme was easy but the sicp book is *kicking my ass*
15:53:36 <MarcelineVQ> n_blownapart: in a bash file it'd be like: export PATH=/home/youruser/.local/bin:$PATH
15:53:44 <geekosaur> .bashrc instead of .bash_profile can get you in trouble here, but
15:54:00 <Welkin> I like emacs
15:54:15 <geekosaur> MarcelineVQ is correct except I'd use $HOME/.local/bin instead of hardcoding the full path
15:54:53 <geekosaur> (don't use ~, some versions of bash will fail to expand it and then you have a $PATH that works inconsistently because only bash will understand it)
15:55:01 <MarcelineVQ> I've been bitten by expansions before so I use hard pathing more often
15:55:18 <n_blownapart> bloody complicated
15:55:23 <geekosaur> $-expansions will work as long as not single quoted
15:55:26 <monochrom> If you trust $PATH you can trust $HOME too
15:55:59 <Welkin> shell scripts are the opposite of using haskell
15:56:14 <n_blownapart> so if the correct ghc-mod is to be found, wouldn't the path entry be longer ?
15:58:06 <n_blownapart> one other thing. people last night suggested using the plug-in install of ghc-mod in atom, I removed stack and tried it, but got the same error. all I wanted was the feature where a hover-over indicates the type.
15:59:22 <kuribas> dfeuer: you should try microlens.  It's a less bloated lens, with much better explanations.
16:01:01 <Welkin> or lens-family
16:02:06 <dfeuer> dcoutts_, when you're building up a big structure, there's an inherent, high, break-the-generational-hypothesis cost. The big goal of reducing temporary allocation there is reducing the number of accidental evacuations.
16:02:06 <Welkin> no idea why it is namespaced under Lens.Family2
16:02:51 <dfeuer> dcoutts_, so what gets evacuated? Whatever's part of the final structure, and whatever else happens to be live in the nursery when minor collection happens.
16:03:40 <dfeuer> If you build a temporary structure that's relatively large compared to the size of the nursery, you will have trouble.
16:05:07 <dcoutts_> dfeuer: aye, and I'm afraid I don't have anything other than educated guesses at the distribution of allocation lifetimes
16:05:21 <dfeuer> Otherwise, you're just reducing the frequency of minor collections, which has a large *relative* impact on the amount of accidental evacuation,
16:05:33 <dfeuer> but a small *absolute* impact because that amount is already small.
16:05:54 <n_blownapart> Welkin: do you mean the editor (emacs) should be easier to configure than that? " shell scripts are the opposite of using haskell "
16:06:18 <n_blownapart> than atom
16:06:24 <Welkin> no
16:06:28 <Welkin> I was talking about shell scripts
16:06:41 <Welkin> but yeah, emacs configuration is similarly stateful
16:06:56 <Tuplanolla> Did you mean: stressful?
16:07:03 <dfeuer> That could still be enough to matter (in Data.Sequence.fromList it certainly was) but maybe not so dramatic.
16:07:40 <dfeuer> (reduce excess allocation by 75% maybe; make the whole thing maybe 30% faster? I don't remember the details.)
16:07:48 <n_blownapart> I can't get it work. so annoying. I just want the hover-over feature and I have to install stack
16:15:14 <ab9rf> welcome to tool chain grind
16:16:41 <kuribas> > toListOf (traverse.filtered (view (_2.to even))) [("a", 1), ("b", 2), ("c", 3)]
16:16:44 <lambdabot>  [("b",2)]
16:29:01 * hackagebot ghcjs-promise 0.1.0.3 - Bidirectional bidings to javascript's promise.  https://hackage.haskell.org/package/ghcjs-promise-0.1.0.3 (AlejandroDuranPallares)
16:31:27 <johnw> > [("a", 1), ("b", 2), ("c", 3)] ^.. traverse.filtered (has (_2.filtered even))
16:31:29 <lambdabot>  [("b",2)]
16:32:44 <glguy> allOf _2 even
16:33:36 <dfeuer> What are all these things?
16:33:45 <Axman6> what things?
16:34:00 <Welkin> lenses?
16:34:50 <dfeuer> Yeah, I know that.
16:35:04 <dfeuer> But I get lost in all the lens combinators.
16:35:23 <dfeuer> filtered, has, to, toListOf, .....
16:35:31 <johnw> glguy: allOf (traverse._2) even xs only returns a boolean, not the results
16:35:44 <jle`> to be fair, the example kuribas is kind of an exaggeratedly contrived usage of lens
16:35:48 <glguy> johnw: sure, that's why you'd only use it as the filter predicate
16:35:52 <johnw> ahh
16:36:21 <johnw> > [("a", 1), ("b", 2), ("c", 3)] ^.. traverse.filtered (allOf _2 even)
16:36:24 <glguy> dfeuer: Generally you can put your finger over the suffix and figure out what something does
16:36:24 <lambdabot>  [("b",2)]
16:36:25 <johnw> perfect
16:36:28 <glguy> like the -Of or -ed suffix
16:37:30 <johnw> dfeuer: yeah, it just takes getting used to
16:37:55 <dfeuer> glguy, okay, but then that suffix must say something about the thing?
16:38:19 <glguy> Yup
16:38:39 <dfeuer> And then all the operators and functions are a bit dizzying. over, view, set, which match with ... some operators I don't remember....
16:38:52 <dfeuer> IIRC over = id?
16:39:06 <dfeuer> :t over
16:39:07 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
16:39:22 <dfeuer> Oh, it's an upgrade for ASetter.
16:39:26 <kuribas> :t traverseOf
16:39:28 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
16:40:32 <dfeuer> kuribas, is that actually id?
16:40:37 <kuribas> dfeuer: I think so
16:41:53 <Axman6> :t filtered
16:41:55 <lambdabot> (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
16:42:07 <kuribas> dfeuer: I think set, view, preview, over, etc... operate on lenses and traversals, and each, both, _1, etc... are lenses and traversals.
16:42:40 <jle`> there's that handy table on the haddocks that i always look at heh
16:42:55 <Axman6> link?
16:43:03 <jle`> http://hackage.haskell.org/package/lens
16:43:05 <johnw> dfeuer: for example, "mapped" descends into the element of a structure that fmap would have applied to: (1, (3, 4)) & mapped.mapped .~ 5 == (1, (3, 5))
16:43:26 <kuribas> the gigantic UML diagram of DOOM?
16:43:29 <jle`> Axman6: you can use any of the functions on any of the "things" below it
16:43:36 <Axman6> I should probably have that printed out
16:43:42 <jle`> so, 'view' works on a Fold
16:44:03 <jle`> and all Getters, Traversals, Lenses,  Prisms, Iso's, and Equality's are Folds
16:44:06 <jle`> so you can use view on all of them
16:44:22 <dfeuer> :t mapped
16:44:23 <lambdabot> (Settable f1, Functor f) => (a -> f1 b) -> f a -> f1 (f b)
16:44:34 <jle`> 'over' works on Setters,  so you can use them on setters, traversals, lenses, prisms, iso's, and euquality's
16:47:23 <johnw> > (\x -> (1, (3, 4 + x))) & argument .~ 5 $ 10
16:47:25 <lambdabot>  (1,(3,9))
16:47:27 <dfeuer> johnw, so mapped is actually just fmap except with some conversions tossed in?
16:47:40 <johnw> it's a referent to the action of fmap
16:47:50 <johnw> just like "argument" there refers to the argument
16:47:58 <johnw> most things ending in "ed" refer to the object that the action would have applied to
16:48:04 <kuribas> Maybe lenses are designed to keep newbies away?  Since Monads have failed.
16:48:08 <dfeuer> What's the operator version of over?
16:48:36 <johnw> I think it's %~
16:48:56 <dfeuer> johnw, that sounded like a useful description, thanks.
16:49:06 <dfeuer> :t ($~)
16:49:08 <lambdabot> error:
16:49:08 <lambdabot>     • Variable not in scope: $~
16:49:08 <lambdabot>     • Perhaps you meant one of these:
16:49:12 <dfeuer> :t (%~)
16:49:14 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
16:49:22 <dfeuer> :t over
16:49:24 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
16:50:55 <johnw> "a referent to the action of fmap" is too meaningless; what I mean is: imagine what fmap would act upon (the 'a' in 'f a'), and then you can think of mapped as the "address" of that a (or those a's)
16:51:50 <johnw> except that's it's just a Setter, so you can't use it to obtain values, just modify them
16:52:36 <kuribas> https://www.reddit.com/r/haskell/comments/1o6iqs/why_i_dont_like_the_lens_library/
16:53:57 <johnw> traversed, on the other hand, can be used for getting, although it's a traversal and might be empty, so you use ^?:
16:53:58 <johnw> > (1,2) ^? traversed
16:54:00 <lambdabot>  Just 2
16:54:38 <johnw> for setting, you can use either mapped or traversed, the difference being only in the constraints
16:57:44 <johnw> dfeuer: I think a main difference is that we're using to thinking of maps, traversals and folds as functional: applying a function to a value to obtain a new value.  With lens, these concepts become nouns, with the role of verb transferred to whichever lens operator is using them: (^., ^?, ^.., etc)
16:58:35 <johnw> the advantage here being that the same noun can take on multiple meanings, because it can now be combined with many such verbs.  Thus, a traversal becomes a getter when used with view, a mapper when used with over, etc.
16:59:52 <johnw> all while remaining compositional since they are *still just functions*
17:00:14 <sgronblo> Does stack have anything like npm runscript?
17:00:51 <Vandelay> I have a function that consumes one char at a time. blah :: ReadP Char. If I use many1 blah, i get different variations of the parsed thing. I want something more like munch but I can't put all my conditions in a Bool clause (i look ahead on some characters). Help!
17:07:13 <geekosaur> sgronblo, either you mean stack exec, or https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter ? (I don't know node)
17:11:12 <sgronblo> can stack already update your cabal file too btw?
17:12:52 <sgronblo> seems like not yet https://github.com/commercialhaskell/stack/issues/1933
17:15:13 <dibblego> Axman6: that is the day it is deleted from NICTA/course ^^
17:22:26 <whitexmamba> I need some help. I have a data type "data Something = Constr1 SecondType | Constr2 SecondType" and "data SecondType = A" How can I compare if two instances of Something are the same and ignore the SecondType for the comparason? 
17:22:40 <jle`> Vandelay: what is munch?
17:23:28 <ab9rf> whitexmamba: you have to derive your own Eq instanec for Something
17:23:55 <jle`> whitexmamba: you can write getSomething maybe
17:24:17 <jle`> data getSomething :: Something -> SecondType; getSomething (Constr1 x) = x; getSomething (Constr2 x) = x
17:24:19 <jle`> and then compare those
17:24:41 <whitexmamba> jle` Thanks for the response that seems like the perfect solution!
17:25:28 <jle`> whitexmamba: you can also factor Something into something like Something TypeOfSomething SecondType
17:26:07 <jle`> and then it'd be simpler to write a projection function
17:26:24 <jle`> because the type you have now is essentially the same as (Bool, SecondType)
17:27:21 <whitexmamba> jle` wait I want to compare the Something types and ignore the inside type
17:28:23 <Koterpillar> whitexmamba: so anything with Constr1 is equal to anything else with Constr1?
17:29:55 <whitexmamba> To be more accurate these are the types: "data S = <Lots of S's> OtherType" and "OtherType = LineAndCol Int Int" both deriving show and eq. There are dozens of S constructors each with a LineAndCol type, I want to completely ignore the line and col and just compare if two S instances are the same jle`
17:30:59 <whitexmamba> I'm sorry my terminology is terrible I am atrocious with Haskell and functional programming in general
17:31:02 <Koterpillar> whitexmamba: can you parametrize S over OtherType?
17:31:20 <Koterpillar> whitexmamba: data S Location = C1 Location | C2 [Location] | etc.
17:32:04 <jle`> whitexmamba: oh i see
17:32:07 <Koterpillar> whitexmamba: derive Functor for that, and fmap (const ()) over it; then you'll get back an S with all Locations replaced by ()
17:32:09 <jle`> you meant compare the constructors
17:32:17 <jle`> and not the things inside
17:32:19 <jle`> my bad
17:32:35 <whitexmamba> jle` yes! and no worries, I'm not explaining things well
17:32:47 <whitexmamba> Koter I'm not trying to be ignorant but that all goes right over my head
17:34:10 <Koterpillar> > fmap (const ()) (Maybe 1)
17:34:12 <lambdabot>  error:
17:34:12 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> f b0
17:34:12 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
17:34:16 <Koterpillar> > fmap (const ()) (Just 1)
17:34:18 <lambdabot>  Just ()
17:34:33 <Koterpillar> > fmap (const ()) [1, 2, 3, 4, 5] == fmap (const ()) [5, 6, 7, 8, 9]
17:34:36 <lambdabot>  True
17:34:38 <Koterpillar> > fmap (const ()) [1, 2, 3, 4, 5] == fmap (const ()) [5, 6, 7, 8]
17:34:41 <lambdabot>  False
17:35:07 <Koterpillar> whitexmamba: the types involved are (Maybe a) and [a]; if you make your S parametrized over SecondType, you can do the same
17:35:32 <jle`> i think Koterpillar means data S l = C1 l | C2 l | ...
17:35:46 <jle`> and so your original type is S Location
17:36:01 <Koterpillar> jle`: correct
17:36:35 <jle`> fmap (const ()) = (() <$) too fwiw
17:36:46 <Koterpillar> :t (<$)
17:36:48 <lambdabot> Functor f => a -> f b -> f a
17:36:48 <jle`> > () <$ [1,2,3,4,5]
17:36:51 <lambdabot>  [(),(),(),(),()]
17:37:01 <jle`> > () <$ Just 10
17:37:03 <lambdabot>  Just ()
17:37:13 <Welkin> jle` and his duck magic
17:37:35 <Koterpillar> @pl fmap (const ())
17:37:35 <lambdabot> fmap (const ())
17:37:55 <jle`> fmap (const ()) is already point-free
17:38:32 <Koterpillar> @magically_make_it_better fmap (const ())
17:38:32 <lambdabot> Unknown command, try @list
17:39:37 <Welkin> @djinn a -> b -> c
17:39:38 <lambdabot> -- f cannot be realized.
17:39:43 <Welkin> @djinn a -> b -> a
17:39:43 <lambdabot> f a _ = a
17:40:05 <Koterpillar> @djinn fmap (const ())
17:40:05 <lambdabot> -- f cannot be realized.
17:40:12 <Welkin> it takes a type
17:40:28 <Koterpillar> @djinn Functor f => f a -> f ()
17:40:28 <lambdabot> Error: Class not found: Functor
17:40:42 <Welkin> @djinn Functor f => f a -> f b -> f a
17:40:42 <lambdabot> Error: Class not found: Functor
17:40:45 <Welkin> lol
17:40:49 <Koterpillar> @djinn [a] -> [()]
17:40:49 <lambdabot> Error: Undefined type []
17:41:56 <geekosaur> :exf "Functor f => f a -> f b -> f a"
17:42:05 <geekosaur> djinn doesn't do recursive types
17:42:29 <geekosaur> and exferenceBot is lazy :p
17:42:30 <exferenceBot> could not find expression
17:42:36 <geekosaur> bah
17:42:56 <geekosaur> :exf "[a] -> [()]"
17:42:58 <exferenceBot> (Control.Applicative.<*>) (join mempty)
17:43:13 <geekosaur> o.O
17:43:55 <MarcelineVQ> :>
17:44:39 <geekosaur> it's also the new @pl, I see >.>
17:44:50 <dfeuer> Anyone familiar with the type checking issues that led to MonoLocalBinds?
17:46:19 <whitexmamba> jle`: Okay still stuck. Lets say I have "data S l = C1 l | C2 l | ..." and I have a function: f :: ... -> S, if I let the result of that call be some variable t, how can I check that t == <Some S Constructor> and ignore the l type that each constructor has?
17:46:52 <Koterpillar> whitexmamba: case f _ of C1 _ -> True; _ -> False
17:47:03 <jle`> @src null
17:47:03 <lambdabot> null []    = True
17:47:04 <lambdabot> null (_:_) = False
17:47:07 <jle`> :t null
17:47:09 <lambdabot> Foldable t => t a -> Bool
17:47:21 <jle`> null :: [a] -> Bool, heh
17:47:33 <jle`> it checks what constructor [] was used with, and ignores the contents inside
17:47:58 <dfeuer> I noticed that I can write  class a ~ b => Equal a b; instance a ~ b => Equal a b, and use that class in a module that doesn't enable any extensions.
17:48:26 <hexagoxel> :exf "Functor f => f a -> f ()" -u -n "1"
17:48:27 <exferenceBot> fmap (\ e -> mempty)
17:48:27 <dfeuer> On the other hand, if I write   type EqualF a b = a ~ b, I *can't* use that synonym in such a module.
17:49:12 <dfeuer> Now I know that there are some issues with type inference not working right with let generalization + GADTs or type families.
17:49:36 <dfeuer> That would seem to explain why the type synonym doesn't work.
17:49:49 <dfeuer> But doesn't the Equal class lead to the same problems?
17:50:05 <dfeuer> What's the important difference?
17:50:52 <geekosaur> I would argue, and I think the ghc devs would argue, that the first is actually a bug
17:51:11 <xcmw> Why is my type for m not working? http://lpaste.net/335065
17:51:55 <jle`> xcmw: it's impossible to infer what 'a' is
17:52:04 <jle`> just from the arguments you give to 'm'
17:52:09 <jle`> er sorr,y what 'b' is
17:52:54 <jle`> xcmw: and from the return type, either
17:53:39 <jle`> the return type is (String, [Int]), but GHC can't infer that that implies b ~ X
17:53:51 <jle`> s/is/might be
17:54:02 <dfeuer> geekosaur, that sounds likely. I guess type inference probably gets fragile in the presence of the Equal class?
17:54:28 <jle`> xcmw: you can either provide a dummy argument (like Proxy b/p b) to help with type inference, or also use AllowAmbiguousTypes and TypeApplications, m @X
17:54:50 <geekosaur> I think it's more just that they require extensions at use sites as well as definition sites these days. I can't speak to type inference there
17:55:03 <xcmw> jle`: Ok. I will look into those.
17:55:32 <whitexmamba> Koterpillar jle`: the case t of C1_ -> ... C2 _ -> ... C3 _ -> .. seems to work thank you!
17:55:53 <dfeuer> geekosaur, why do they do that? That seems most unfortunate. Don't we have Cabal to tell us what language extensions our compiler needs to support?
17:56:05 <dfeuer> Er...
17:56:10 <dfeuer> Maybe not Cabal.
17:56:12 <dfeuer> Sorry.
17:56:27 <dfeuer> But GHC should be able to figure out what extensions are needed transitively, based on imports.
17:56:57 <dfeuer> It's simply annoying to have to copy great gobs of LANGUAGE lines from dependencies.
17:57:00 <geekosaur> that seems orthogonal to me, as it's a way to tell it what extensions are needed. but currently I don't think extensions required are either inferred or recorded in .hi files
17:57:06 <geekosaur> beyond that you'd need to ask the devs
17:57:38 <davean> dfeuer: Um, if you don't consider what happens when you import something with weird extensions
17:57:40 <geekosaur> but I can see wanting explicit extensions from a "spooky action at a distance" standpoint
17:57:54 <davean> dfeuer: do you want your program behavior to change massively based on a new import?
17:58:07 <geekosaur> (for example, an unexpected ScopedTypeVariables extension could lead to types changing)
17:58:49 <dfeuer> davean, no, no, and no. But why not let me write instances of MPTCs (which classes are defined elsewhere) in a module not requesting MPTC? 
17:59:20 <dfeuer> davean, I definitely don't want extensions imported wholesale.
17:59:37 <dfeuer> I just want to be able to use the bindings I've imported.
18:00:17 <dfeuer> I can accept that sometimes (with GADTy stuff, say) an "invasive" extension will force me to add a LANGUAGE pragma.
18:04:40 <dfeuer> davean, are more language extensions disruptive than I thought? I know that GADTs and TypeFamilies imply MonomorphicLet; are there other ones that would lead to spooky action at a distance?
18:05:03 <dfeuer> (Aside from the horrible type argument order dependence from explicit type application)
18:05:13 <whitexmamba> Whats the best way to track down <<loop>> in a big file?
18:06:15 <dfeuer> whitexmamba, that's a bit hard to say without knowing more about how your code is structured.
18:19:04 * hackagebot mtl-c 0.1.1 - Very strict CPS'd transformers  https://hackage.haskell.org/package/mtl-c-0.1.1 (FumiakiKinoshita)
18:28:17 <benzrf> is there any reasonable way to parse left-associative operators using basic parser combinators
18:28:55 <c_wraith>  benzrf, sure. don't use a parser with an ll(k) core. :) 
18:29:13 <c_wraith> benzrf, for instance, there's the Earley package 
18:29:19 <benzrf> im doing a codewars thign :(
18:29:33 <benzrf> unless im missing something, the only parser combinator package they have installed, that i know of, is "polyparse"
18:29:42 <Cale> Do you have StateT?
18:29:52 <benzrf> ya
18:29:54 <Cale> StateT Text []
18:30:01 <benzrf> :P
18:30:13 <Cale> I'm semi-serious
18:31:02 <benzrf> c_wraith: anyway i dont think its ll(k) - it's https://hackage.haskell.org/package/polyparse-1.12/docs/Text-ParserCombinators-Poly-Plain.html
18:31:17 <Cale> You can write   separate :: (Text -> Maybe (a, Text)) -> Parser a   and then from that get to lots of other things quickly using things like T.span and such.
18:32:25 <c_wraith> benzrf, polyparse is more like ll(ambiguous). it can parse anything decideable, if you don't mind exponential runtime. 
18:33:00 <benzrf> what is span?
18:33:05 <benzrf> o wait
18:33:07 <benzrf> :t span
18:33:08 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:35:09 <Cale> benzrf: See also stripPrefix
18:35:17 <Cale> :t Data.Text.stripPrefix
18:35:19 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> Maybe Data.Text.Internal.Text
18:36:34 <Cale> You can get a semi-respectable parsing library going in 10 lines or so
18:37:01 <Cale> You can newtype derive Alternative and the rest
18:37:09 <benzrf> Cale: 
18:37:09 <pikajude> The path to remove that "semi-" prefix is another 200 lines or so
18:37:19 <benzrf> but like doesnt left-recursion still an issue
18:38:49 <Cale> It should be okay, if inefficient.
18:41:33 <benzrf> but im doing left-recursion in the code im writing and its getting infinite loopy
18:41:47 <benzrf> and polyparse seems to be basically like what youre talking about?
18:41:49 <benzrf> idk
18:48:52 <benzrf> Cale: help :(
18:49:19 <Cale> hmm
18:54:39 <erisco> you cannot write left-recursive grammars in the usual way with applicative-style parsing
18:55:30 <Dacto> you could if you only wanted to parse for detecting left-recursion.
18:55:33 <Dacto> ;)
18:55:43 <benzrf> erisco: thats what i thought ):
18:56:04 <erisco> x = x <*> y <|> z   this is going to keep expanding
18:56:17 <geekosaur> <<loop>>
18:56:33 <Dacto> lazy parsing will get you there
18:56:40 <Dacto> for detection *
18:57:03 <erisco> what detection are you speaking of?
18:57:38 <Fairy> How would I go about iterating over a String until a particular character is found (using some random Char -> Bool function) and then return a string with that single character, or the entire input String
18:57:47 <Dacto> feedback and detection of if a grammar is left-recusive
18:58:23 <erisco> the implementation of <*> runs the first parser and then runs the second parser, roughly
18:58:33 <jle`> Fairy: well, which do you want to return
18:58:40 <erisco> but running the first parser kicks this off again
18:58:44 <jle`> Fairy: the single character, or the entire input string?
18:58:52 <erisco> what <*> implementation is going to overcome this problem?
18:59:03 <Fairy> Entire input String if character is not found, or a String with just that character.
18:59:07 <jle`> > find (== "a") "hello world, how are you today?"
18:59:09 <lambdabot>  error:
18:59:09 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
18:59:09 <lambdabot>        Expected type: [[Char]]
18:59:21 <jle`> > find (== 'a') "hello world, how are you today?"
18:59:23 <lambdabot>  Just 'a'
18:59:25 <jle`> > find (== 'a') "hello world"
18:59:29 <lambdabot>  Nothing
18:59:34 <jle`> alternatively you can just use 'elem'
18:59:38 <benzrf> Fairy: any time you think explicitly about "iterating", you're probably doing it wrong :)
18:59:57 <jle`> > 'a' `elem` "hello world"
19:00:00 <lambdabot>  False
19:00:01 <jle`> > 'a' `elem` "hello world, how are you today"
19:00:04 <lambdabot>  True
19:00:23 <jle`> @let findIt x xs | x `elem` xs = [x] | otherwise = xs
19:00:24 <Fairy> benzrf I've considered that, and you're likely correct - but I'm having a hard time figuring out other ways of thinking of it
19:00:26 <lambdabot>  Defined.
19:00:31 <Dacto> if i have IO (Either a b), how can i get at the Either in bind?
19:00:34 <jle`> > findIt 'a' "hello world"
19:00:35 <erisco> I solved it by requiring some grammar refactoring and additional combinators
19:00:39 <jle`> Dacto: you can pattern match
19:00:39 <Fairy> also, jile`, you're awesome, exactly what I was looking for
19:00:41 <lambdabot>  mueval-core: Time limit exceeded
19:00:58 <jle`> Dacto: with a case statement
19:01:04 <jle`> if you're in a do block then you can directly pattern match after <-
19:01:15 <Dacto> Jle` : how so?
19:01:17 <jle`> but it's probably better to use a case statmeent
19:01:22 <erisco> there is a way to refactor left recursion into right recursion without screwing up the parse tree
19:01:22 <jle`> how to use a case statement?
19:01:30 <jle`> case x of Left e -> ...; Right r -> ....
19:01:44 <Dacto> to i mean pattern match that directly in the bind it in the IO monad?
19:01:57 <jle`> Right r <- ...
19:02:10 <jle`> this will throw an exception at runtime in IO if the pattern match fails
19:02:15 <jle`> which might be want you want sometimes in an IO block
19:02:22 <jle`> the error message wouldn't be very user friendly though
19:02:49 <Dacto> So the use case is that im running the do from with in either. ie: either errMsg id $ do .. IO (Either a b) sutff
19:03:32 <Dacto> errMsg is just a function to print out the Left value and exist with non zero code
19:05:01 <benzrf> Dacto: i think you want <$>, not $
19:05:14 <benzrf> in other news: HOW DO I DO LEFT-ASSOCIATIVITY :(
19:05:35 <pavonia> infixl?
19:07:16 <erisco> :t (<**>)
19:07:18 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
19:07:27 <benzrf> pavonia: in a parser, sorry
19:08:50 <erisco> benzrf, what kind of practicality do you need in the parser? maybe my toy one will work
19:09:01 <benzrf> none :>
19:09:24 <erisco> no error messages or anything, and it is exponential in space and time
19:09:41 <byorgey> benzrf: are you using a parser combinator library?
19:09:42 <erisco> benzrf, *shrug* take a look then https://github.com/erisco/acrid-parser/tree/master/parser
19:10:09 <erisco> here are examples and the undergrad paper I wrote on it https://github.com/erisco/acrid-parser/blob/master/doc
19:10:30 <benzrf> byorgey: yes - this is on codewars, & they dont have fancy ones installed - theres polyparse, it seems
19:10:42 <erisco> I was going to improve it to polynomial time and space but never got around to it
19:10:45 <Dacto> jle`: http://lpaste.net/9108595388125806592
19:11:07 <byorgey> benzrf: use 'chainl'
19:12:27 <benzrf> byorgey: i dont know that that is in polyparse :\
19:16:57 <byorgey> benzrf: it is.
19:17:05 <byorgey> http://hackage.haskell.org/package/polyparse-1.12/docs/Text-ParserCombinators-HuttonMeijer.html#v:chainl
19:17:25 <byorgey> http://hackage.haskell.org/package/polyparse-1.12/docs/Text-ParserCombinators-HuttonMeijerWallace.html#v:chainl
19:17:27 <benzrf> oh dang!
19:17:35 <benzrf> i was using Poly
19:18:01 <benzrf> this section seemed poorly documented
19:18:30 <meditans> hi, I have a weird error: I defined a quasiquoter, which is correctly working in a file
19:18:42 <meditans> but in another file, in the same context, I get the error
19:19:01 <meditans> A section must be enclosed in parentheses
19:19:07 * hackagebot XSaiga 1.4.0.1 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.4.0.1 (InBetweenNames)
19:19:07 <byorgey> benzrf: well, you can also implement it yourself.  Look at the source for chainl.  It is nonobvious but not hard.
19:19:20 <benzrf> oh
19:19:43 <meditans> for some reason the quasiquotation syntax is not recognised, but I enabled QuasiQuotes; What could this be?
19:21:23 <Welkin> did you add TemplateHaskell ?
19:22:49 <MarcelineVQ> possibly you need to import the quasiqutation module import Language.Haskell.TH.Quote iirc
19:23:43 <benzrf> Welkin: you dont need that actually
19:23:45 <benzrf> surprisingly
19:23:47 <benzrf> i think
19:27:04 <geekosaur> meditans, I think it's slightly type based, insofar as [foo| could either be the start of a quasiquote or the start of a list comprehension
19:27:32 <Welkin> meditans sounds like a pokemon
19:27:32 <meditans> Welkin: I added template haskell moved by desperation, but the error remains (and the other file didn't need it)
19:27:35 <Welkin> medicha,?
19:27:39 <meditans> xD
19:27:39 <Welkin> medicham?
19:28:12 <meditans> geekosaur: how could I convince the compiler that this is about a quasiquote?
19:28:14 <geekosaur> and the rest of the expression can't be used to syntactically distinguish because in a quasi it may well not be Haskell
19:28:53 <meditans> the monad in which is used is the same in the two examples, though
19:28:57 <tombert> Howdy, simple question; I want to have a system that streams transcoding stuff from ffmpeg.  First, is the best way of doing that through executing a command-line command doing something like `ffmpeg -i myvideo.mp4 -f matroska pipe:0`
19:29:26 <geekosaur> make sure the function definition has been seen at that point, I think?
19:29:33 * geekosaur is checking the manual
19:29:37 <Welkin> tombert: unless there are haskell bindings to ffmpeg, then proabably
19:30:12 <tombert> Welkin: alright, totally ok with that; what's the best way to handle a stream then?
19:30:16 <tombert> from the command line?
19:30:35 <geekosaur> no spaces in [foo| ; foo cannot be "e", "t", "d", "p" (syntax stolen by TH); must already be a defined binding (presumably of type Q Exp)
19:30:36 <tombert> I'm alright using pipes or conduit or whatever, but I have no idea how to talk to the command line and less of an idea of how to stream stuff from it
19:30:51 <geekosaur> (or Q Pat, etc. depending on its syntactic location)
19:31:57 <Welkin> tombert: http://hackage.haskell.org/package/turtle
19:32:23 <geekosaur> oh, sorry, it's a data value actually, a record with expansions for each of the 4 recognized contexts
19:32:33 <Welkin> tombert: http://hackage.haskell.org/package/turtle-1.2.8/docs/Turtle-Tutorial.html
19:33:03 <geekosaur> in any case I suspect it has to already be defined with the correct type or it will not be recognized, since it's stealing otherwise valid syntax
19:33:22 <geekosaur> (this would normally be Bad, but at compile time the rules can be different)
19:33:52 <tombert> Welkin: I've been looking at turtle, but is there a way to set the size of the stream chunk?
19:34:01 <Welkin> not sure
19:34:08 <geekosaur> oh, huh, no, guess it does not do type directed resolution, it just forces you to add spaces for a list comp
19:34:26 <meditans> geekosaur: solved, thanks for the help
19:34:29 <geekosaur> ok
19:34:43 * geekosaur was about to ask for the quotation that was causing problems
19:34:55 <meditans> I feel a bit ashamed, but I wrote LANUGAGE instead of LANGUAGE, and for some reason I wasn't getting the error back
19:35:08 <meditans> xD
19:35:09 <geekosaur> cute
19:35:18 <geekosaur> I think that's tripped people before
19:35:33 <meditans> now the quotation just fails, but that's merit of the quotation xD
19:36:13 <meditans> oh, no, actually it works! Great!
19:36:25 <meditans> thanks for the help guys!
19:46:44 <benzrf> meditans: eheheh
19:46:47 <benzrf> always the dumbest bugs
19:48:04 <benzrf> omfg what the fuuuuck
19:48:19 <benzrf> i think. i think this kata wants me to do parsing using arity information to inform precedence?!
19:48:26 <benzrf> this is insane
19:52:24 <meditans> xD
20:24:09 * hackagebot rattletrap 0.3.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.3.0 (fozworth)
20:51:01 <mekeor> hello friends. any ideas on how to...
20:51:02 <lpaste> mekeor pasted “how to write this prettier?” at http://lpaste.net/335094
20:52:34 <lpaste> mekeor revised “how to write this prettier?”: “how to write this prettier?” at http://lpaste.net/335094
20:53:01 <Koterpillar> mekeor: should it be max [pos, neg, zero] in the first line?
20:54:00 <mekeor> :t max
20:54:02 <lambdabot> Ord a => a -> a -> a
20:54:11 <Koterpillar> well, yeah, still
20:54:35 <mekeor> how? why?
20:54:36 <Koterpillar> pos `max` neg `max` zero
20:54:50 <mekeor> yeah, that'd be fine, too, yeah
20:54:54 <Koterpillar> I was going to suggest something, but your example isn't that consistent
20:55:15 <Koterpillar> I'm assuming f :: Ord a -> String ?
20:55:22 <mekeor> yes
20:55:23 <kadoban> mekeor: Was going to say you can do: f (fromMaybe zero foo `max` fromMaybe zero bar) -- but ... that doesn't really work with the Nothing, Nothing case.
20:56:09 <Koterpillar> I'd say leave it as is, whatever you can do with catMaybes will be _shorter_ but not _prettier_
20:56:46 <Koterpillar> case catMaybes [foo, bar] of [] -> ""; vals -> f (foldr zero max vals)
20:56:59 <mekeor> ugh, i see
20:57:12 <Koterpillar> (whichever way the arguments to foldr go)
20:57:56 <mekeor> thank you :)
20:58:56 <begriffs> Anybody know if optparse-applicative to make an argument conditionally required? Like you need option foo unless bar is given? But supplying neither of them is an error and should show the usage message.
20:59:43 <ezyang> begriffs: That sounds very... not applicative ;) 
21:00:02 <begriffs> Ha, OK
21:00:15 <ezyang> (I mean, there could be a thing that does what you want) 
21:00:45 <ezyang> TIL that System.Process's algo for finding executables depends on the cwd you plan to execute the process in 
21:00:49 <begriffs> Is there a low level way to turn the flags into a hashmap or something that I can examine?
21:01:04 <begriffs> (an alternative to optparse-applicative)
21:01:22 <ezyang> getArgs but I imagine that's not what you're asking 
21:01:43 <begriffs> Maybe it is, let me look into that
21:01:49 <Dacto> begriffs: maybe a variation on http://stackoverflow.com/a/25233483 - or at least useful?
21:14:35 <piyush-kurur>  cabal sdist problem (I think). I have a module that is conditionally enabled with a flag. While things compile, cabal sdist I think does not include it with tarball if the flags are not given. Is there an easy work around other than enabling this flag when running cabal sdist.
21:16:46 <piyush-kurur> you can see the problem in action on the travis build https://travis-ci.org/raaz-crypto/raaz/jobs/174738364 and https://travis-ci.org/raaz-crypto/raaz/jobs/174738363
21:20:20 <lethjakman-l> So...I'm using yesod, but somehow I'm missing $. 
21:20:28 <lethjakman-l> Is it weird that I'd have to import prelude?
21:20:36 <lethjakman-l> I thought that was included by default. 
21:24:58 <zomg> lethjakman-l: check if you have NoImplicitPrelude enabled
21:40:44 <ania123> Using recursion and the function add, define a function that multiplies two natural numbers.
21:40:59 <ania123> * (Succ Zero)     n = n
21:41:01 <ania123>  * (Succ m) n = add n (* m n)
21:41:06 <ania123> is it correct?
21:43:26 <grayhatter> I'm having a lot of trouble wrapping my head around `IO String -> String`
21:43:53 <pikajude> that's not actually possible
21:43:57 <geekosaur> um. where di dyou find that?
21:43:58 <pikajude> unless you use unsafePerformIO, which you shouldn't be doing
21:43:59 <mekeor> ania123: seems right to me, but why not simply try it out
21:44:17 <geekosaur> unless you mean str <- something_producing_IO_String
21:44:18 <grayhatter> I have a monad function that needs a String, but what I have is an IO String
21:44:44 <piyush-kurur> ania123: does not work when the first argument is zero.
21:45:04 <ania123> aha
21:45:15 <geekosaur> grayhatter, then you might want to look into what I just said
21:45:15 <piyush-kurur> also you might need to wrap * in a bracket or use in infix notation
21:45:15 <grayhatter> full disclosure, I'm not even sure what I'm saying is true, I'm trying to peice together what I've been told from my friend who's knows haskell, and what google is telling me
21:45:52 <pikajude> grayhatter, if you have an IO Foo and you need a Foo, you must use >>=
21:45:53 <grayhatter> geekosaur I didn't find that anywhere, that's what I was told to write.
21:45:59 <jle`> it's possible, foo _ = "hello"
21:46:02 <n_blownapart> cabal Hi version 1.20.0.3 and ghc version 7.6.3 came default with the haskell-platform for my debian 8 system. I'm trying to update the ghc to version 7.8.2, 7.8.3, or 7.8.4, in attempts to configure emacs for haskell. I gave up on trying to configure atom. How do I upgrade the ghc version? thanks
21:46:03 <pikajude> or do notation, which desugars to >>=
21:46:14 <ania123> *  Zero     n = Zero
21:46:25 <ania123>  * (Succ Zero)     n = n 
21:46:26 <ania123> * (Succ m) n = add n (* m n)
21:46:29 <geekosaur> or, the more precise version:  some_action_producing_IO_String >>= \str -> some_operation_using_str_producing_IO_something
21:46:43 <piyush-kurur> ania123: * is an operator so you need to write it as (*) Zero n = Zero ...
21:46:45 <ania123> piyush-kurur: this?
21:46:46 <grayhatter> geekosaur  pikajude I want to learn how to do it correctly
21:46:52 <pikajude> grayhatter, what's the return type of the function that takes a String?
21:46:52 <piyush-kurur> ania123: why not try it out
21:46:57 <piyush-kurur> instead of asking
21:47:04 <n_blownapart> btw I posted this query on emacs-haskell to no avail
21:47:18 <geekosaur> n_blownapart, don't use the debian packages (except on testing/unstable), they are ancient and can't be upgraded
21:47:18 <grayhatter> Net ()
21:47:26 <ania123> piyush-kurur: may I pm u for a second?
21:47:28 <pikajude> what is Net?
21:47:41 <grayhatter> it's a monad I created for a network socket (I think)
21:47:44 <piyush-kurur> ania123: if it is an assignment I am not going to answer
21:47:48 <n_blownapart> oh thanks geekosaur should I try a generic linux package or something?
21:47:54 <pikajude> grayhatter, can you paste your code?
21:48:08 <ania123> piyush-kurur: it is nota ssignment! I am trying to study things!
21:48:21 <piyush-kurur> ania123: why dont you try it out on ghci
21:48:21 <geekosaur> n_blownapart, that may be your best option on debian. for ubuntu/mint there's a PPA with later versions
21:48:24 <grayhatter> piyush-kurur  https://github.com/GrayHatter/devbot/blob/master/devbot.hs
21:48:30 <geekosaur> I don't think there's one that supports debian releases
21:48:59 <piyush-kurur> grayhatter: you mean ania123 is a bot?
21:49:15 <grayhatter> um.... wut
21:49:16 <pikajude> grayhatter: in order to use the thing that returns IO String inside Net, you need a way to transform it from IO String to Net String
21:49:18 <geekosaur> piyush-kurur, that is an unrelated discussion
21:49:19 <n_blownapart> geekosaur thank you. I'll try it
21:49:38 <grayhatter> pikajude okay, how can I do that?
21:49:38 <pikajude> then you could bind it using do { thing <- myIOString; doSomethingWith thing }
21:50:15 <pikajude> grayhatter: I would show you, but apparently the documentation on hackage isn't built
21:50:15 <geekosaur> grayhatter, that code already has io :: IO a -> Net a
21:50:17 <pikajude> one second
21:50:23 <pikajude> oh hey, it does
21:50:24 <pikajude> look at that
21:50:41 <grayhatter> geekosaur I tried that, it didn't work
21:50:48 <pikajude> what did the compiler say?
21:50:57 <geekosaur> not by itself it won't. what exactly did you try, where, and what was the full error?
21:51:14 <grayhatter> ugh... that was so long ago, give me a minute
21:52:09 <piyush-kurur> geekosaur, grayhatter: sorry I got completely confused. Actually the situation is quite funny in retrospect. 
21:53:11 <grayhatter> geekosaur cmdline.org/3.png
21:53:21 <grayhatter> pikajude ^
21:53:38 <geekosaur> grayhatter, that would not be how you use it
21:53:46 <grayhatter> clearly
21:53:50 <pikajude> right, so you first need to bind the result of `io url' to a variable, then use that variable
21:53:52 <geekosaur> it gets you from IO String to Net String, but you still can't use the Net String as a String
21:54:13 <geekosaur> since you are in a do block in Net, this is easy to do with <-
21:55:42 <geekosaur> oh, hm
21:55:48 <grayhatter> is there a good resource that explains <- notation?
21:55:48 <geekosaur> you have a bit of a tangled mess here
21:55:59 <geekosaur> because you are doing the IO elsewhere
21:56:14 <grayhatter> geekosaur very tangled, I'm planning to clean it up, but I want to understand everything and get it working first
21:56:31 <geekosaur> tagSearch delcared as String -> Int -> String calls checkIssue :: String -> Int -> IO String. this will never work
21:57:25 <andreabedini> hello lovely people, when I try to do "cabal install accelerate-examples" I get the following cryptic message "cabal: No executables, libraries, tests, or benchmarks found. Nothing to do." – any idea what that means?
21:57:29 <geekosaur> just as you can't magically make the IO in an IO String go away giving you a String, you can't magic up an IO String in a non-IO context
21:57:40 <grayhatter> geekosaur right, that's what I was trying to do when I was told that I'd need to write a function with a do block
21:59:03 <piyush-kurur> grayhatter: There are multiple ways to handle the case
21:59:12 * hackagebot yesod 1.4.3.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.4.3.1 (MichaelSnoyman)
21:59:29 <piyush-kurur> if it is a simple function why not  fmap foo ioStringAction 
21:59:42 <piyush-kurur> or in applicative notation foo <$> ioStringAction
22:00:05 <geekosaur> and I think the show in tagSearch is not needed; I suspect you stuck it in there to make the `return` work.
22:00:28 <grayhatter> geekosaur that's correct, that's the function I was going to use to turn IO String into a String
22:01:01 <geekosaur> if so, tagSearch is literally just checkIssue, and the let url = .. in eval becomes url <- checkIssue (takeWhile (/= '#') str) (read issnum)
22:01:55 <geekosaur> <- is part of do syntax; you'll want to look up "do blocks"
22:02:26 <geekosaur> spoiler: it turns into a use of the operator >>= which we pronounce "bind"
22:04:40 <geekosaur> secretly, you can never get an actual String from an IO String (except by invoking internals that will bite you badly if abused). instead, you always attach callbacks that will at some point receive a String
22:05:34 <pikajude> that's not a monads thing, by the way, that's just a Haskell's implementation of IO thing
22:06:08 <cads> Hey all
22:06:11 <grayhatter> okay, I jush pushed a new commit with the working code that I have
22:06:12 <geekosaur> if you've done any web programming with javascript, you always have to wrap stuff in (function(){...})
22:06:24 <geekosaur> this is more of less the same kind of thing, except <- hides the function()...
22:09:38 <geekosaur> (in fact Haskell-like languages are becoming surprisingly popular for generating client-side Javascript, because it lets you pretend the callbacks are straight-line code as long as you follow some simple rules; it builds the callback chains for you)
22:10:04 <pikajude> it's more like Promises and then(), actually
22:13:11 <Axman6> Haskell is so full of promise, it just hides it from you
22:14:14 <ab9rf> heh
22:16:25 <piyush-kurur> can any one point out how to make cabal sdist include modules that are only enabled when certain flags are on
22:16:44 <piyush-kurur> I seem to have trouble with sdist not including such files
22:17:01 <johnw> Axman6: good one :)
22:18:15 <grayhatter> so if I understand everything corrcetly, haskell has everything built on promises, and IO means 'sh**s gonna happen' (maybe with side effects)
22:18:36 <grayhatter> so if I have an IO () -> Maybe Thing
22:19:11 <grayhatter> how do I do different things for the error result without without doing things twice?
22:19:22 <pikajude> you couldn't do anything useful in that type signature
22:19:28 <pikajude> it would have to be IO () -> IO (Maybe Thing)
22:19:35 <piyush-kurur> grayhatter: normally you would not have functions of the type IO () -> Maybe Thing
22:20:23 <piyush-kurur> you will only have okey pikajude has answered it
22:20:30 <grayhatter> in the API I'm using, I make an API request, that could results in a not found
22:20:33 <pikajude> grayhatter what would that be fore
22:20:35 <pikajude> be for
22:21:02 <grayhatter> what's the correct way to run that IO funcion once, and then handle the error, or print the information?
22:21:30 <piyush-kurur> grayhatter: how is the error given: as a Maybe or as an exception
22:21:32 <pikajude> what are you using to call the API?
22:23:07 <grayhatter> ... -> IO (Either Error Issue)
22:25:11 <piyush-kurur> do x <- lookupAPi; handle x
22:25:37 <grayhatter> piyush-kurur cool, thanks
22:25:45 <piyush-kurur> handle has type Either Error Issue -> IO SomeThing
22:25:56 <piyush-kurur> but you need to understand what is going on
22:26:12 <piyush-kurur> donot just monkey patch code
22:32:11 <pikajude> handle doesn't have that type, does it?
22:32:37 <pikajude> i think we're looking for this
22:32:38 <pikajude> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception-Base.html#v:try
22:33:47 <geekosaur> pikajude, it does if grayhatter was correct about the type of the API lookup
22:33:57 <geekosaur> (note, handle *not* x)
22:37:30 <piyush-kurur> pikajude: handle was a placeholder name not an actual function
22:38:23 <piyush-kurur> also I would write it as lookupAPi >>= handle in this case
23:20:52 <isd> Is there a way to get cabal gen-bounds to generate bounds for all components in the cabal file, not just the main one? I have a test suite that depends on some extra things, but it isn't generating those for me.
23:26:41 <srhb> isd: Doesn't appear like it. You could work around it by having your separate sections be in separate files and paste them together. Or you could add that functionality, it would be nice :-)
23:29:15 * hackagebot pgdl 10.3 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.3 (sifmelcara)
23:33:45 <grayhatter> piyush-kurur pikajude geekosaur I got everything working, thank you all very much!
23:48:27 <pikajude> 👍 
23:59:16 * hackagebot ginger 0.3.7.1 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.7.1 (TobiasDammers)
