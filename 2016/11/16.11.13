00:07:38 * hackagebot yesod-elements 1.0 - Non template haskell markup building function in the spirit of lucid  https://hackage.haskell.org/package/yesod-elements-1.0 (andrewthad)
00:07:38 * hackagebot snap-core 1.0.1.0 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.1.0 (DougBeardsley)
00:34:30 <xf_> Hi, I am reading a piece of Haskell code, which has this snippet:  halfPlane :: Point -> Point -> Region; halfPlane a b = \p -> zcross (a - p) (b - a) > 0 where zcross (Pt x y) (Pt u v) = x*v - y*u . I am confused by the `zcross`, what is the meaning of this in math/geometry?
00:37:45 <pavonia> xf_: It's the 2x2 determinant, IIRC
00:40:46 <xf_> pavonia: hmmm, thanks for the clue!
00:43:26 <jmorris_> is there a way to print hexToBase64 in IO () https://github.com/joshua-morris/cryptopals/blob/master/Set1/HexToBase64.hs
00:46:06 <jle`> jmorris_: you can use putStrLn in the bytestring module?
00:51:43 <jmorris_> jle` i get this error
00:51:44 <jmorris_> Couldn't match expected type ëByteStringí
00:51:44 <jmorris_>                   with actual type ëf0 ByteStringí
00:54:00 <pavonia> jmorris: What ae the types of unhex and encode?
00:54:16 <jmorris> hex :: Hex t => t -> t
00:54:16 <jle`> jmcintos1: you can bind in a do-block
00:54:24 <jmorris> encode :: ByteString -> ByteString
00:55:04 <jle`> also what is the type of unhex ... seeing a type like Monad f => ByteString -> f ByteString is kinda weird
00:55:31 <jmorris> oops i gave hex
00:55:32 <jmorris> unhex :: (Hex t, Monad m) => t -> m t
00:55:34 * geekosaur is a bit lost as to the question, tbh. unless the point is that you wanted to do I/O in that function, and if so you wanted the constraint to be MonadIO f and use liftIO
00:55:36 <jle`> is the Monad f constraint just for the case of failure?
00:55:57 <jle`> to leverage 'fail'?
00:56:03 <jmorris> I don't understand monad
00:56:06 <jmorris> s
00:56:20 <jle`> yeah, you can use 'unhex' in a do block
00:56:29 <jle`> and bind the result using <-
00:56:33 <pavonia> That functions should be correct then
00:56:37 <pavonia> -s
00:56:47 <jle`> printHexed :: ByteString -> IO ()
00:57:02 <geekosaur> looks like it's from Data.Hex and the doc says it's using Monad for fail
00:57:12 <jle`> printHexted b = do x <- unhex s; B.putStrLn (encode x)
00:57:14 <jle`> oh
00:58:07 <jle`> then if you do this, bad results of unhex will throw IO exceptions
00:58:11 <jle`> if you're ok with that
00:58:13 <geekosaur> (which, yuck. shoulda used at least Either)
00:58:25 <geekosaur> or Except/ExceptT, or whatever
00:58:25 <jle`> i've seen this pattern in other libraries.  i've never been convinced by it
00:58:39 <geekosaur> yes, this is basically "why fail was a mistake"
00:58:45 <jle`> jmorris: you can treat unhex as ByteString -> Maybe Whatever
00:58:55 <jle`> so case unhex s of
00:59:05 <jle`>   Just x -> B.putStrLin (encode x)
00:59:14 <jle`>   Nothing -> putStrLn "it is a faulure."
01:00:42 <jmorris> im getting this error The type signature for ëprintHexedí lacks an accompanying binding
01:00:55 <jmorris> http://lpaste.net/338607
01:01:00 <jle`> yes you have to define printHex if you give it a type signature
01:01:01 <jmorris> this is what i gathered you mean
01:01:08 <geekosaur> "printHexted"
01:01:14 <jle`> the function should be called printHexed, heh
01:01:16 <jle`> my bad
01:01:30 <jmorris> i think that was my typo
01:01:30 <jmorris> it works now
01:01:44 <jmorris> thanks for the help
01:02:22 <jle`> no problem!  unhexed is admittedly a bit weird
01:02:33 <jle`> you can pretend that it's ByteString -> Maybe Whatever
01:02:48 <jle`> er, unhex :: Hex t => t -> Maybe t
01:03:07 <jmorris> ok
01:05:06 * geekosaur kinda feels like ghc 6.6 days when lookup had a Monad constraint so you could use it in list/Either/Maybe to control failure mode and optionally (with list) multiple matches
01:06:03 <jle`> ooh
01:06:39 <jmorris> is there a way to make prelude the default module for putStrLn
01:06:46 <jmorris> so there isn't ambiguous occurenced
01:06:46 <jle`> the 'time' module still offers parse this way
01:06:58 <jle`> jmorris: import qualified Data.ByteString as B
01:07:29 <jmorris> so that i dont have to type Prelude.putStrLn
01:07:53 <jle`> if you import ByteString qualified then you can use prelude functions as normal
01:08:26 <jle`> but you just have to qualify your usage of bytestring functions heh
01:08:46 <jmorris> ok thanks
01:09:16 <Prutheus> Hello! I have a project: HaskellInC, so I compile my haskell script and embed it in C, works fine. But when I wanna use the Script_stub.h and Script.o files with an microcontrolelr project (i just linked them when the c code gets compiled), i get the error ¬ªScript.o: file not recognized: File format not recognized¬´   ... my question: is it possible to realize my idea?
01:22:35 * hackagebot conduit-extra 1.1.15 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.15 (MichaelSnoyman)
01:26:54 <jarlg> Is there an equivalent to ByteString's 'breakSubstring' for conduits? I need to look for a sequence of bytes in a stream, parse N bytes and repeat.
01:35:09 <InferiorCoder> oly cow this lobby is large. How is haskell as large as the math lobby?
01:36:59 <InferiorCoder> anyone here by chance implemented least squares optimization w/ box constraints? 
01:37:54 <InferiorCoder> curious how to go about it... I can freeze variables that hit bounds then re-least square around those but that is super enifficent 
02:02:37 * hackagebot regex-do 2.6 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.6 (procione)
02:02:39 * hackagebot pgdl 10.4 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.4 (sifmelcara)
02:18:58 <pavonia> In Parsec, is there a difference between "try (foo <$> bar)" and "foo <$> try bar"?
02:22:48 <joncol> I would say no.
02:23:04 <joncol> But I don't know how to prove it :/
02:25:16 <jle`> maybe you can say that fmap can't change the structure of the thing
02:25:26 <jle`> fmap doesn't change any effects
02:26:15 <jle`> so try (fmap foo bar) should be the same as fmap foo (try bar) should have the same effects/structure
02:26:55 <jle`> s/should be the same as/and
02:34:40 <Prutheus> Hello! I have a project: HaskellInC, so I compile my haskell script and embed it in C, works fine. But when I wanna use the Script_stub.h and Script.o files with an microcontrolelr project (i just linked them when the c code gets compiled), i get the error ¬ªScript.o: file not recognized: File format not recognized¬´   ... my question: is it possible to realize my idea?
02:36:23 <meditans> dcoutts: I have a question on the simplelocalnet backend for cloud haskell: I have a master on 127.0.1.1 and slaves on 127.0.0.2 and 127.0.0.3. So I would expect the communications to go between this nodes. Instead, I can only disrupt the communication between nodes if I disrupt the communication with 127.0.0.1. Why does that happen?
02:36:58 <pavonia> joncol, jle`: Okay, thanks
02:47:09 <implementation> Prutheus: .o files contain compiled machine code, you cannot share them across different processor architectures. For your microcontroller project, you not only need to use the right C cross compiler for the microcontroller, but also the right Haskell cross compiler - which probably doesn't exist.
02:48:26 <ongy> maybe jhc (or some descendant) can still compile to C, which you could then give to the cross compiler toolchain
02:50:27 <minib00m> Hello! In Stack template called "simple" there is additional folder -- app. What is the purpose of it? How should I use it while developing my app?
02:52:31 <MarcelineVQ> the folders made by templates can be used however you like, simple doesn't make an app folder though, are you sure you used simple if you meant to?
02:54:35 <MarcelineVQ> the default template "new-template" will make an app folder though, which contains Main.hs which is the file that is compiled into your executable
02:54:46 <minib00m> @MarcelineVQ i think i named my folder simple, not chose template simple, woops xD
02:54:46 <lambdabot> Unknown command, try @list
02:55:02 <joncol> jle`: Isn't it dependent on the definition of `try` though? It's not generally true that f (fmap g mx) ‚â° fmap g (f mx), right?
02:56:17 <minib00m> MarcelineVQ: I think I understand now the app folder :) Previously I was always having files that compiled to executeables in /src :)
02:56:19 <minib00m> thanks
02:56:32 <meditans> more generally, I'd like to know how I can test applications using cloud haskell's simplelocalnet by blocking the communication between two nodes
02:57:39 * hackagebot bitx-bitcoin 0.11.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.11.0.0 (tebello_thejane)
02:58:43 <ongy> meditans: how are you trying to disrupt the connection?
02:59:41 <meditans> ongy: using the `tc` tool in linux, for example: http://lpaste.net/338652
03:00:29 <meditans> if you know a better way, please share: I studied all this network shaping stuff only because I wanted to disrupt communication between two nodes, ongy
03:01:19 <ongy> not really, I would have gone with ip tables, but I think that's less flexible
03:01:35 <meditans> (for example, that script causes the messages directed to 127.0.2.3 to be dropped 90% of the time
03:02:03 <Prutheus> implementation: yeah, for C i know. My problem was: is it possible to compile my haskell stuff for arm-eabi? is there something like a haskell compiler which can this?
03:02:22 <meditans> ongy: yes, I didn't use iptables because I want to be able to trickle down traffic, instead of interrupting it
03:02:32 <ongy> I can read it. Have you checked whether the connections originate form the correct nodes? I don't know about cloudhaskell, could be that it only binds the listen socket, then a connection would originate from 127.0.0.1
03:03:03 <meditans> ongy: I fear that may well be the case, because I tested the script with ping and it seems to be working as intended
03:03:27 <meditans> ongy: how can I know if the connections really originate from the correct nodes?
03:03:48 <ongy> meditans: to get a quick overview, create the connections and do 'netstat -tapn' (tcp all something numbers) to check the connections
03:04:41 <meditans> ongy: so, to be clear, the connections are generated in my program, so I start the program and in the meantime run that command, is that correct?
03:05:16 <ongy> you just need to run it, while the connections are up. So start the programm and while it's running, run the command
03:07:27 <meditans> ongy: that's a great command, thanks! In fact, the nodes don't speak to each others, they communicate via 127.0.0.1
03:09:55 <ongy> not that surprised to be honest
03:10:18 <meditans> the question, at this point, is, how can I stop a communication between particular nodes
03:10:28 <ongy> you could check if you can get it to run certain ports
03:11:14 <meditans> ongy: if you want to explain what that's what you expected, I'd find that useful (I just began learning)
03:11:38 <ongy> I'm not familiar with cloudhaskell, so that's general advice. You could also (with more effort) set up multiple interfaces and route them locally in a virtual network and try to get the nodes to be on those
03:13:03 <meditans> so, each node that I spawn is connected to 127.0.0.1 through a specific port, and if I'd be able to know that in advance I could filter traffic that way, is this what you mean?
03:14:23 <ongy> when you say it only works when blocking on 127.0.0.1 I was suspecting that the clients don't bind their connecting socket. So linux will connect from 127.0.0.1. It's a different step to bind outgoing connections and local listen to addresses
03:15:23 <ongy> if the tool you use to disrupt the traffic supports filtering on ports, that's what I'm suggesting, yes. to be honest, I doubt that it's possible, you will most likely only know the port you are connecting to
03:17:25 <meditans> it supports filtering on ports, the problem with that approach is that the ports on 127.0.0.1 seem to be assigned randomly at each run, and I don't know how to extract that information
03:18:52 <meditans> (pinging dcoutts and kosmikus to see if they have any suggestion)
03:29:15 <meditans> ongy: in the meantime thanks for the info, you've been supremely helpful with the netstat command; are there any sources I should read on setting up interfaces and routing them, as you described earlier?
03:30:34 <marcocr> 	Hi! I'm trying to port some functionalities of Intero to Visual Studio Code (it's a project with my Uni) and I am mainly interested in the :complete-at functionality. What I don't understand is how I could make it works with a file that is being typed. In order to use the :complete-at function I first need to load the file, but if the file is being typed it may not be successfully loaded. 
03:30:48 <ongy> check out qemu/xen network tips I guess, I don't know anything better, I've only used it in a vm setting
03:30:56 <marcocr> I have been suggested to use -fdefer-all-errors, but it seems not to be a ghc option
03:33:37 <srhb> marcocr: -fdefer-type-errors ?
03:35:34 <marcocr> srhb: I have tried that, but it doesn't help much, let's say I'm writing: "someFunc = m" this will not compile, but I still need to give some code completion for that (for example map) 
03:36:45 <srhb> marcocr: Okay. Now idea how intero or the others do it.
03:36:47 <srhb> No*
03:39:01 <marcocr> srhc: Thanks for trying, I will wait and see if anyone else knows. Should I post it on the subreddit too? 
03:39:17 <marcocr> * srhb:
03:39:31 <srhb> marcocr: You're welcome to do that, I'm sure. :)
03:42:38 <Prutheus> Hello! I have a project: HaskellInC, so I compile my haskell script and embed it in C, works fine. But when I wanna use the Script_stub.h and Script.o files with an microcontrolelr project (i just linked them when the c code gets compiled), i get the error ¬ªScript.o: file not recognized: File format not recognized¬´   ... my question: is it possible to realize my idea?
03:46:40 <implementation> Prutheus: we already told you why you get that error and ongy gave you the hint that you should have a look at jhc's compilation to c. if you still have a question, please update it instead of repeating the old one.
05:18:23 <Prutheus> implementation: jhc website is down. where can I get it?
05:25:26 <implementation> Prutheus: one of the first google results: https://github.com/jimcrayne/jhc
05:26:02 <implementation> Prutheus: uhc seems to have a C-backend too http://foswiki.cs.uu.nl/foswiki/Ehc/UhcUserDocumentation#LabeLbackendC
05:26:51 <Prutheus> implementation: thanks
05:32:00 <Prutheus> implementation: at building (./configure) i get errors: ¬ª module 'Codec.Compression.Zlib' from package 'zlib'¬´   ... but when I install zlib via cabal, it doesnt disappear
05:36:08 <ongy> @lpase -- prutheus can you give the entire error?
05:36:08 <lambdabot> Maybe you meant: paste leave
05:36:12 <ongy> @lpaste
05:36:13 <lambdabot> Haskell pastebin: http://lpaste.net/
05:36:21 <heebo> is there a monadic equiv to iterate
05:38:30 <Prutheus> http://lpaste.net/338731
05:38:39 <Prutheus> have a look there please ongy 
05:38:47 <ongy> :t iterate
05:38:49 <lambdabot> (a -> a) -> a -> [a]
05:45:48 <Prutheus> So you guys see I need to install the package zlib, so i did ¬ªcabal install zlib¬´ ... but , also in ghci, there I can't import ¬ªCodec.Compression.Zlib¬´ ... what went wrong?
05:47:32 <ongy> I would guess omething with the package database, but I'm not really familiar with what can go wrong. Especially on windows. Can you try the -v, it should output search path iirc
05:48:05 <Prutheus> i am on linux
05:48:36 <Prutheus> ongy: where should i add -v?
05:48:52 <ongy> ghci invocation
05:49:06 <ongy> oh, I misread the mingw stuff in your paste
05:53:21 <Prutheus> ongy: have a look please: http://lpaste.net/338740
05:54:52 <hsk3> For the Maybe monad, guard allows us to, on some condition, disregard everything else and return Nothing.
05:54:53 <hsk3> Is there a more general pattern that I can implement in my own monad, except without a fixed Nothing return value?
05:54:53 <hsk3> For example: "myGuard condition returnValue"
05:59:22 <ongy> hsk3: can you rephrase? I don't quite get your goal
06:01:59 <Prutheus> ongy: can you please keep helping me?
06:02:21 <ongy> if I had a good idea, I would try. at this point I'm as good as you
06:02:41 <hsk3> Within a do-block in a Maybe monad, I can do this: "guard False" to ignore the rest of the do-block and return Nothing immediately.
06:02:41 <hsk3> Is there a more general type class in Haskell that allows me to do something like this (for not just the Maybe monad): "moreGeneralGuard False returnValue" that ignores the rest of the do-block and returns returnValue immediately. 
06:02:45 <hsk3> ongy ^
06:04:44 <implementation> i think MonadPlus allows this
06:05:05 <implementation> at least the aborting part, not the returning
06:05:36 <ongy> there's MonadFail, but I'm not sure how much of a smell that is
06:06:48 <Tuplanolla> How about `Either`?
06:07:46 <Tuplanolla> > do {x <- Right 2; y <- Right 3; z <- Right 4; pure (x + y + z)} :: Either Int Int
06:07:49 <lambdabot>  Right 9
06:07:54 <Tuplanolla> do {x <- Right 2; y <- Left 3; z <- Right 4; pure (x + y + z)} :: Either Int Int
06:08:20 <Ste1892> Hey.  Does anyone know of a simple way to load the contents of a [Float] into a ByteString?  I've had a bit of a look into this and the methods others have used seem a bit convoluted.  It's so I can pass data to certain OpenGL funtions using BS.useAsCString.
06:08:40 <ongy> Tuplanolla: hsk3 asked about a more general thing (typeclasS) not other examples
06:08:55 <Tuplanolla> Oh, I see.
06:09:44 <ClaudiusMaximus> Ste1892: probably you want storable vectors and http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#v:unsafeWith
06:10:51 <Ste1892> OK, I'll have a look at that.  Thanks.
06:11:13 <ongy> or runPut . mapM put $ xs, which may be slow (binary or cereal)
06:17:46 * hackagebot ombra 0.2.0.0 - Render engine.  https://hackage.haskell.org/package/ombra-0.2.0.0 (ZioCrocifisso)
06:36:22 <xcmw> How can I fix this error on line 61 probably caused by line 55? http://lpaste.net/338423
06:42:47 * hackagebot cubicbezier 0.5.0.0 - Efficient manipulating of 2D cubic bezier curves.  https://hackage.haskell.org/package/cubicbezier-0.5.0.0 (KristofBastiaensen)
06:42:50 <Stagnation> hye, anyone know a good channel for google sheet coding help?
06:42:56 <hsk3> ongy, the only general method i see is to wrap my monad in a EitherT, and outside of that check if Left was returned.
06:43:00 <Stagnation> hey*
06:43:09 <hsk3> ongy, a messy way but it's the only way i know
06:43:45 <Stagnation> or, anyone here dabble with google sheets?
06:45:41 <Stagnation> I want to import data from email to a google speadsheet
06:46:42 <xcmw> Stagnation: I don't think anyone here knows google sheets
06:47:12 <Stagnation> anyone know of a good channel to connect to that might?
06:57:40 <RedNifre> Hi. I wrote an unusual function that I'm sure exists already and I was wondering what the name for this is: Say you have some convoluted data structure. You now construct a monad (e.g. a list or a map) where the values are fragments of the original data structure, but they are still of the same type. This means that you can fmap your monad-constructing-function over the monad you got when you did that the
06:57:42 <RedNifre> first time... and then fmap . fmap and fmap . fmap . fmap until you converted it to the desired depth. You invoke it like recursiveFmap f 3 someData. What is this called?
06:57:56 <RedNifre> (I mean I called it recursiveFmap, but I'm not sure that's the official name)
07:02:14 <Tuplanolla> So you have `(fmap . fmap . fmap) h . (fmap . fmap) g . fmap f` or equivalently `fmap (fmap (fmap (fmap id . h) . g) . f)`, RedNifre?
07:03:11 <RedNifre> yes, except that f g h are all the same.
07:03:40 <RedNifre> well, not quite, it misses an `. f` at the right sight
07:03:43 <RedNifre> *site
07:04:10 <RedNifre> e.g. say f :: Stuff -> [Stuff]
07:04:32 <RedNifre> ...and you know that Stuff is actually convertible to a nested list 6 levels deep...
07:05:05 <RedNifre> then you do `deepfmap f 6 stuff` to get [[[[[[Stuff]]]]]].
07:05:33 <RedNifre> I implemented that because I have this really strange input data format and I was wondering if that concept has a common name.
07:06:21 <RedNifre> Now that I think of it it's actually recursive parsing of a custom format. Hm.
07:06:38 <Tuplanolla> This sounds like `iterateM`, although not exactly.
07:06:47 * RedNifre looks that up
07:08:40 <RedNifre> Does that exist or would that just be a good name for it?
07:09:27 <Tuplanolla> @hackage monad-extras
07:09:28 <lambdabot> http://hackage.haskell.org/package/monad-extras
07:09:39 <Tuplanolla> It's in there somewhere.
07:10:05 <RedNifre> ...maybe it's actually a silly way to implement it and f should accept a recursion parameter itself.
07:10:32 <Tuplanolla> The difficulty in your case stems from the fact that the return type depends on the input value.
07:10:48 <RedNifre> Ah, wait a second... I'm actually writing this in Clojure right now (for reasons). How could I even write such a function in Haskell? I mean, the nesting depends on the depth parameter... would I need Idris for this?
07:11:01 <RedNifre> :)
07:11:05 <Tuplanolla> That's a dependent type and Haskell doesn't currently support them completely. You'll need type-level numbers or other such tricks.
07:11:54 <Tuplanolla> Another way would be to collapse the nesting with a type class, a bit like what `printf` does.
07:12:39 <kuribas> Tuplanolla: but it couldn't infer the type from the recursion depth.
07:12:39 <Tuplanolla> I brought up `iterateM`, because there the `join` from the `Monad` instance does the collapsing.
07:14:12 <RedNifre> Out of curiosity, how would the type signature look like? I imagine something like deepmap :: (a -> [a]) -> depth@Integer -> a -> [*depth a ] ?
07:14:48 <RedNifre> e.g. (a -> [a]) -> 3 -> [[[a]]]
07:16:04 <RedNifre> Is it okay to discuss this here or should I ask #idris ? (I'm asking here because I know Haskell but no Idris).
07:16:08 <Tuplanolla> Someone else will have to tell you. I haven't done this in Haskell.
07:17:27 <jmcarthur> I'm not sure I understand the idea here. It sounds like just a free monad to me, not some dependently typed thing.
07:18:42 <jmcarthur> You would just use bind instead of fmap in that case.
07:21:26 <kuribas> RedNifre: maybe Deepmap d :: (a -> [a]) -> [d]
07:22:38 <RedNifre> jmcarthur maybe it is... I'm not an expert.
07:22:52 <RedNifre> Okay, maybe I should give a more concrete example.
07:25:00 <RedNifre> Say you have a large String that you know encodes nested maps 6 levels deep and on the lowest level you have a list of Strings. You wrote a function that parses the first mapping level, :: String -> Map String String. You then want to apply this function 6 levels deep and then apply your :: String -> [String] function at depth 6.
07:26:27 <jmcarthur> data Thing a = Branch (Map String (Thing a)) | Leaf a
07:26:44 <Tuplanolla> This one is easier than the thing you first suggested, RedNifre.
07:29:10 <RedNifre> Yeah, that is clearer.
07:29:20 <xcmw> Why can't I put a type synonym family in an instance?
07:29:35 <RedNifre> I think the parse function should just call itself recursively until a given depth.
07:30:00 <Tuplanolla> You have just invented a recursive descent parser.
07:30:10 <RedNifre> Instead of getting passed to a weirdly typed function that applies it recursively to a given depth.
07:30:20 <RedNifre> Indeed I have!
07:30:48 <Tuplanolla> Now go forth and parse!
07:31:50 <RedNifre> I'm stunned and thinking about Clojure vs Haskell right now intensely.
07:35:52 <kuribas> RedNifre: you probably could do what you want with a typeclass, but I am not sure what you want...
07:36:36 <kuribas> RedNifre: you'd let the type system infer the depth, instead of specifying it.
07:37:14 <RedNifre> I mean, (parse-to-depth 6 parse-one-layer unparsed-stuff-that-I-know-is-6-deep) felt elegant, but data ParsedStuff = Branch (Map String ParsedStuff) | Leaf [String]    and then `justParseItAssumingDepth 6 unparsedStuff` where justParseItAssumingDepth calls itself recursively is actually much clearer.
07:37:19 <kuribas> providing it's decidable
07:38:02 <kuribas> RedNifre: maybe you just want the List Monad?
07:38:37 <RedNifre> It's actually decidable given that the input string should be tokenizable into a [[String]] where the inner list has length 6.
07:38:54 <RedNifre> Is the List Monad something other than a list? I thought lists were already monads?
07:40:12 <kuribas> RedNifre: it operates over all combinations.
07:40:55 <kuribas> > (+) <$> [1, 2] <*> [5, 6, 7]
07:40:58 <lambdabot>  [6,7,8,7,8,9]
07:46:30 <hololeap> i'm trying to come up with a function that will return True as soon as it finds a duplicate, but will work with infinite lists :: Eq a => [a] -> Bool
07:48:45 <hololeap> wait, i think i found it: https://hackage.haskell.org/package/Agda-2.5.1.1/docs/src/Agda-Utils-List.html#distinct
07:48:46 <fodil> hololeap: I guess you can just use foldr ?
07:49:30 <fodil> if you foldr on it
07:49:46 <fodil> you will have a true as soon are there is a duplicate
07:49:51 <fodil> on infinite lists
07:50:02 <fodil> (haskell laziness)
07:50:05 <Tuplanolla> You can do it faster with `Ord` instead of `Eq`, hololeap.
07:50:22 <lyxia> That doesn't sound so useful.
07:50:32 <hololeap> Tuplanolla: can you give an example?
07:51:06 <Tuplanolla> Carry a `Set` of old elements and check each new element for membership, hololeap.
07:51:36 <Tuplanolla> You may want to do it the way fodil suggested.
07:52:06 <kuribas> hololeap: but it will hang if there is no duplicate...
07:52:49 <obadz> if I have f :: Num a => a -> a that calls (+), then g :: Num a => a -> a that calls f, then h :: Int -> Int that calls g, is there a scenario of the world were the code generator generates specialized versions of f & g to avoid the dictionary passing?
07:54:14 <benzrf> obadz: it seems likely
07:54:22 <benzrf> but i dont know myself, so i shouldntve spoken up >.>
07:54:44 <fodil> kuribas: knowing if a list ends is an undefinied behavior, you can't predict it on a computer
07:54:57 <xelxebar> :inoremap
07:55:07 <xelxebar> whoops. sorry about that :P
07:56:22 <Gurkenglas> kuribas, maybe he knows that any infinite list passed to his function will have a duplicate, but some finite lists wont
07:56:23 <fodil> obadz: Int is in Num, so it shouldn't, since g and f are polymorph
07:56:37 <kuribas> Gurkenglas: that's possible
07:57:21 <fodil> kuribas: you can just tell "yes" but can't tell "no" on any infinite lists
07:57:41 <kuribas> fodil: I just wonder how usefull that function would be
07:58:17 <fodil> kuribas: it's a problem, we don't mind if it's usefull, we just care about a solution :D
07:58:43 <kuribas> textbook problem?
07:59:19 <fodil> I don't know his problem, might be from anywhere 
08:03:53 <xcmw> ertes: The dependent map library does not have a away to require a key from the type signature.
08:04:22 <Profpatsch> MonadPlus a forms a Monoid with `mplus` as Operator and `mzero` as 1.
08:05:01 <Profpatsch> With Smallcheck, `mplus` is ‚Äúdisjunction‚Äù and >>= is ‚Äúconjuction‚Äù
08:05:32 <Profpatsch> I wonder if there is an equivalent structure that contains >>= instead of mplus?
08:06:46 <Profpatsch> Hm, >>= and pure form a Monoid as well, right?
08:10:09 <obadz> fodil: well if Int wasn't in Num then we'd have a type error or my typesignatures would be deceiving
08:11:35 <xcmw> Why can't there be a type family application in an instance?
08:11:46 <Tuplanolla> Not exactly as you stated it, Profpatsch, but that's the gist of "a monad is a monoid in the category of endofunctors".
08:12:16 <fodil> obadz: Int is a Num
08:12:28 <obadz> fodil: I know that :)
08:12:41 <fodil> obadz: then what is the issue ? :P
08:13:12 <Profpatsch> Tuplanolla: Hm, but Monad Int should form a Monoid, right?
08:13:14 <obadz> fodil: my question is, does the code generator generate specialize versions of all the functions on the call stack in order to avoid dictionary passing overhead, at least sometimes?
08:13:18 <obadz> or never
08:13:47 <Tuplanolla> What's `Monad Int`, Profpatsch?
08:13:56 <fodil> obadz: It depends on your code generator
08:14:04 <obadz> fodil: ghc
08:14:38 <Profpatsch> Tuplanolla: Right
08:15:04 <fodil> obadz: it creates a version a each call of the function, as far as I understand
08:15:16 <Profpatsch> Tuplanolla: ([Int], >>=, pure) is a Monoid, right?
08:15:25 <fodil> at each call*
08:15:28 <ertes> xcmw: sorry, i don't know what you mean
08:15:33 <obadz> fodil: so it creates specialized version of the entire call stack?
08:15:38 <ertes> xcmw: you mean because DMap is partial?
08:15:57 <ertes> xcmw: i mean:  you mean because DMap denotes partial functions?
08:15:57 <Profpatsch> *forms a Monoid
08:16:50 <Tuplanolla> Not exactly, because `>>=` is not an associative binary operator, Profpatsch.
08:16:52 <xcmw> ertes: If I have a key called Foo, how can a write the type signature of a map that must contain Foo?
08:17:01 <Profpatsch> Tuplanolla: Oh, right.
08:17:06 <Profpatsch> mplus is.
08:17:23 <xcmw> ertes: The type of the map did not change when I added for removed keys
08:18:14 <Profpatsch> What about (>=>);  ((a -> [Int]), (>=>), const.pure) ? 
08:18:53 <fodil> obadz: it might, with some optimisations, but you shouldn't mind it, it's bad practice (you are writting haskell code, not GHC code)
08:19:20 <obadz> actually I'm writing a compiler, so you're not really answering my question..
08:19:22 <ertes> xcmw: yeah, so you want something that denotes total functions‚Ä¶  you can use dependent-sum to construct them
08:20:54 <fodil> obadz: then you do it the way you want, you asked me for ghc, not for your compiler :)
08:20:59 <ertes> xcmw: like this (untested, but should work):  DSum k f -> (forall a. k a -> f a -> r) -> r
08:21:14 <obadz> fodil: I was trying to understand what ghc does as a source of inspiration
08:21:31 <ertes> xcmw: wait, no
08:21:35 <fodil> obadz: it works as redexes
08:21:50 <fodil> obadz: each redex is kept somewhere
08:22:10 <ertes> xcmw: actually it's really just GADTs
08:22:23 <Tuplanolla> Why `const`, Profpatsch?
08:22:33 <fodil> obadz: and when there is a function call, it take the redex, and add it in a tree, with type assignation to it 
08:22:41 <ertes> xcmw: f :: K a -> a  -- this function, given a key of type (K a), will return an a
08:22:41 <fodil> takes*
08:23:14 <ertes> xcmw: the GADT can do type refinement
08:23:38 <Profpatsch> Tuplanolla: I‚Äôm not sure, probably the types fit better with ((Int -> [Int]), (>=>), pure)
08:23:56 <xcmw> ertes: I will look into GADTs.
08:24:07 <Tuplanolla> That sounds more reasonable, Profpatsch.
08:24:21 <obadz> fodil: sorry for my lack of culture, but what's a redex?
08:24:46 <Welkin> a red expression?
08:24:53 <obadz> just an expr it seems?
08:24:57 <mpickering> A subterm where you can do beta reduction
08:26:03 <ertes> xcmw: https://gist.github.com/esoeylemez/30f3c024fa73adc3795654461eac6c7a
08:26:20 <ertes> xcmw: what dependent-sum gives you is the ability to *abstract* over such key types
08:26:33 <ertes> and couple a key with a value of the corresponding type
08:27:09 <mpickering> obadz: is your question about how GHC does specialisation? 
08:27:14 <ertes> DSum K Identity -- holds, for example (K "haha") together with a value of type Int
08:27:17 <obadz> mpickering: yes am curious
08:27:18 <xcmw> ertes: Ok, thanks
08:27:22 <obadz> mpickering: 30000ft view
08:27:41 <mpickering> Specialised versions of the functions are created
08:27:43 <obadz> mpickering: if I compile some (adhoc) polymorphic code in some module,
08:27:59 <obadz> mpickering: is it able, in another module, to specialize the functions?
08:28:38 <obadz> and if so, what's in the .so ? just object code truly? or some serialzied system F ?
08:28:43 <mpickering> I am talking about functions with constraints especially
08:29:26 <obadz> right so f = (+) 5 and g (x :: Int) = f (x * 8)
08:29:39 <mpickering> Yes across modules but you have to mark the overloaded functions as INLINABLE
08:29:41 <obadz> f is polymorphic over Nums, g is specific
08:29:59 <obadz> mpickering: so specialization only happens when inlining happens?
08:30:22 <obadz> in theory it could create a symbol for f :: Int -> Int in the calling module and use that without inlining it..
08:30:36 <Tuplanolla> How is `SPECIALIZE` involved here?
08:30:42 <mpickering> Inlinable means the code is included in the interface files
08:30:49 <obadz> ah
08:31:03 <obadz> the code = original haskell? or core?
08:31:19 <mpickering> The  .hi files maintain info between modules
08:31:19 <c_wraith> Tuplanolla: The SPECIALIZE pragma means "create another copy of this function at this specific type and use it where possible instead of the general version"
08:31:55 <mpickering> If is core but unoptimised
08:32:26 <mpickering> You can see what is in an interface file by using --show-iface
08:32:33 <mpickering> On a hi file
08:32:34 * obadz gonna have a look at https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf
08:32:39 <Tuplanolla> Is that version automatically `INLINABLE`, c_wraith?
08:33:03 <c_wraith> Tuplanolla: No, it's just object code plus a note that it exists in the interface file
08:33:28 <mpickering> obadz the section of the user guide is good for this
08:33:44 <c_wraith> Tuplanolla: unless, I suppose, the original function was INLINABLE on multiple type variables and you only specialized it on one
08:33:49 <obadz> mpickering: I wonder if exporting core for all functions wouldn't be a good idea..
08:33:52 <mpickering> Inlinable just means is in the interface file.. 
08:34:10 <obadz> mpickering: i.e. everything should be inlineable
08:34:39 <mpickering> obadz: I wondered the same. If someone gave me a server to build stackage I would build it and measure the size of the iface files
08:34:39 <obadz> would that really slow down compilation meaningfully?
08:34:55 <obadz> the .sos are bloated as it is
08:34:59 <mpickering> The worry is increasing the size of iface files
08:35:08 <c_wraith> obadz: have you ever seen what happens when ld runs out of memory on ghc output?
08:35:13 <obadz> maybe a serialized version of core rather than text?
08:35:32 <mpickering> It is serialised
08:35:54 <obadz> c_wraith: can't say that I have but ghc probably shouldn't use ld to do its own inlining no?
08:36:01 <mpickering> Look at any hi file  :p
08:36:07 <obadz> mpickering: ha cool
08:36:27 <c_wraith> interface file size isn't the only issue.
08:36:37 <c_wraith> compilation time could also really suffer
08:36:52 <obadz> ld would only be used to link to C .so's
08:36:56 <c_wraith> especially when you depend on a package like vector-algorithms
08:37:28 <mpickering> vector-algorithms already mark all the functions as inlinable
08:37:38 <c_wraith> All the *exported* functions
08:37:40 <obadz> I guess the question is, what %-age of the time is spent parsing+type-checking vs. code-gening
08:37:41 <mpickering> I don't see what the worry is
08:37:56 <obadz> c_wraith: you would dead-code most of that stuff trivially
08:38:06 <obadz> (unless you actually use all of it of course)
08:39:20 <obadz> unrelated question, is system F specifically appropriate to express lazy calcs or is it agnostic of strict vs lazy?
08:39:22 <mpickering> I think people are more suprised when GHC fails to specialise their code
08:39:36 <hsk3> I'm finding myself doing "MaybeT . return $" all over the place in my MaybeT monad do-blocks.
08:39:36 <hsk3> Have you seen this issue before? Is there a way to make it more concise?
08:40:10 <mpickering> No there is no core distinction
08:40:21 <mpickering> Look up StrictCore
08:40:34 <mpickering> Then reducing seq is an operational step
08:40:53 <obadz> cool
08:41:57 <mpickering> hsk, should pure not lift a value into the MaybeT wrapped monad stack? 
08:42:10 <mpickering> What is your full stack? 
08:42:12 <obadz> https://github.com/osa1/StrictCore/blob/master/src/StrictCore/Syntax.hs#L55-L56 ‚áê allocation here could mean stack allocation right?
08:43:03 <mpickering> Let is the only thing which allocates in core anyway 
08:43:08 <skogar> hi, is it possible to write an instance of STUArray with a custom element type?
08:43:31 <mpickering> skogar: I don't know, have you tried :) 
08:43:37 <skogar> yes :(
08:43:47 <mpickering> What went wrong? 
08:43:49 <obadz> mpickering: there's no way around allocating if there's a let?
08:44:02 <skogar> but I can(t see how to implements required methods:
08:44:09 <skogar> like getBounds for instance
08:44:23 <mpickering> skogar Maybe paste some code
08:44:47 <mpickering> obadz yes as far as I know, let means allocate
08:45:40 <skogar> mpickering:newtype Idx s = Idx (STUArray s Nix Int32)
08:46:06 <skogar> instance MArray (STUArray s) Nob (ST s) where getBounds = ???
08:46:40 <skogar> I forgot this : the custom elemnt type : newtype Nob = Nob NobInt
08:47:28 <skogar> how to read getBounds from the "underlying" Int32 array ?
08:48:39 <meditans> hi, I'd like to ask again if someone familiar with cloud haskell could explain if it's possible to have direct connections between nodes when they are all on the same machine, at different ips (without passing by 127.0.0.1)
08:49:40 <mpickering> skogar in lpaste pls
08:51:35 <lpaste> skogar pasted ‚ÄúSTUArray with custom eleemnt type‚Äù at http://lpaste.net/338835
08:55:57 <skogar> I need 2-level indexing: the first array gives the index in the second array
08:56:33 <skogar> and I'd like to use 2 different index types, so the element type of the first array is the index type of the second one
08:56:58 <skogar> problem is: how to define an array with a custom element type that in not in the exiting instance list?
08:59:27 <ertes> skogar: is there an easy mapping to and from Int for both index types?
09:00:37 <kuribas>  :t getBounds
09:00:49 <skogar> ertes: yes, both index types are just newtype for Int32
09:02:09 <ertes> skogar: because i generally recommend the vector library‚Ä¶  it's easy to write (or even TH-derive) instances for Unbox
09:02:22 <ertes> skogar: alternatively you can reuse your Storable instance, if you have one
09:03:03 <ertes> the only drawback: it's not indexed by the index type‚Ä¶  indices are always Int and start at 0
09:04:02 <ertes> (on the other hand it has cheap slicing, so even though indices always start at 0, they can index a slice of a larger vector)
09:06:25 <xcmw> ertes: Sorry, I don't quite understand. How can I represent a record A with two properties X and Y which can have any type? I tried making a XKey and a YKey and got lost. I also tried making IntKey :: Key -> Int but then I could fine more than one value per key.
09:08:02 <ertes> xcmw: what exactly should the record store?  give me an example
09:09:03 <skogar> ertes: has Vector custom index types?
09:09:39 <skogar> ertes: nope, looks like Int
09:09:46 <Welkin> skogar: Array does
09:09:50 <Welkin> it uses Ix
09:10:44 <skogar> Welkin: sure, but not custom element type, not easy ones anyway
09:11:18 <skogar> Welkin: I want an Array whose elements are the Ix instances of another Array
09:11:24 <xcmw> ertes: It should be able to store anything in the X and Y keys. See http://lpaste.net/338851.
09:11:56 <ertes> xcmw: "anything"?
09:12:58 <ertes> skogar: that's why i asked whether you can go to and back from Int easily =)
09:13:17 <ertes> Vector has no built-in abstraction for other index types
09:14:01 <xcmw> ertes: Yes. I want to represent a record with x and y as properties that can have anythhing as keys and have it strongly typed
09:14:27 <skogar> ertes: sure, your solution would be wrapping the native array into a data and implement get and set?
09:14:43 <skogar> ertes: doen not look harder than implementing MArray :)
09:14:47 <xcmw> The lpaste works it is just has a lot of boiler plate and requires a cast arround id
09:15:14 <ertes> xcmw: data A k = A { _x :: DSum k Identity, _y :: DSum k Identity }  -- _x is a key together with a value of the type the key dictates
09:15:17 <ertes> same for _y
09:15:21 <ertes> xcmw: something like that?
09:15:55 <xcmw> ertes: I will try it
09:16:17 <ertes> xcmw: example:  myRec = A { _x = MyIntKey ==> 15, _y = MyStringKey ==> "blah" }
09:16:41 <ertes> the key determines the type of the value
09:17:21 <ertes> skogar: "native array"?
09:17:39 <Welkin> there is no native array
09:17:40 <Welkin> lol
09:17:58 <Welkin> everything is just a plain old `data` declaration
09:18:37 <ertes> well, there is stuff like ByteArray# and MutableByteArray#, but i doubt that that's what skogar means =)
09:18:59 <skogar> ertes: by native array I mean the array of Int32's provided by GHC, that I wrap in a datatype that looks like an array of another type
09:19:20 <ertes> skogar: what's the type of that array?
09:20:30 <skogar> ertes: a newtype of Int32 that derives Ix
09:21:56 <skogar> ertes: the idea is that readArray of the first array should yield the Ix of the other array
09:21:59 <ertes> skogar: no, what the type of that overall array‚Ä¶  you said GHC gives you an array
09:22:50 <skogar> ertes: GHC gives instances of MArray for arrays of Int
09:23:03 <skogar> erters: or Int32
09:23:44 <skogar> ertes: I'd like an MArray of a custom newtype of Int32; surprisingly, it's difficult
09:24:06 <xcmw> ertes: How would I write the type signature of an A that has an Int for x?
09:24:53 <xcmw> ghci just tells me that myRec is of type A K
09:26:29 <ertes> skogar: ah, you're not talking about GHC, but about the array library
09:26:52 <ertes> skogar: 'array' is just a regular library‚Ä¶  it's not something built-in
09:27:07 <skogar> ertes: yes
09:27:19 <ertes> xcmw: i thought you wanted the key to select the type of the value
09:27:23 <skogar> ertes: no bytearray or what
09:27:55 <ertes> skogar: why don't you just explain the problem you're solving?
09:28:13 <skogar> ertes: what I like is that it has custom index and element type, but custom element type are not that easy :(
09:29:51 <skogar> ertes: I have a 2-level index; I read an array with a first index, the value returned is the index in another array 
09:30:42 <skogar> ertes: I could use Int everywhere, but it would be fine to have 2 different index types (instances of Ix), the second index type beeing the element type of the first array
09:31:26 <ertes> skogar: yeah, you're using the first array as a permutation of the second one
09:31:42 <ertes> skogar: (or rather just an arbitrary scrambling, as i don't know if it's a permutation)
09:32:07 <skogar> ertes: yes, kind of, the second array may be larger, but it is often a permutation
09:32:26 <ertes> skogar: do the arrays change after construction?
09:33:20 <skogar> ertes: the second one is constant, the first one changes all the time
09:33:53 <skogar> ertes: I was planning an STUArray for the forst one and a pure Array for the second one
09:34:05 <skogar> ertes:UArray actually
09:35:45 <ertes> skogar: is the first array a permutation?
09:36:16 <ertes> (of the elements it addresses)
09:36:58 <ertes> (i.e. are all indices unique?)
09:37:36 <xcmw> ertes: What I want is a better version of this http://lpaste.net/338863. I can't explain what I want in words. I'm unsure how to implement the t and q functions with your method. What I origionally wanted was to know how to get rid of the cast around id. Then you told me to use DMap, DSum, and GADTs. The code in the lpaste works fine, it just has a lot of boilerplate.
09:38:12 <ertes> skogar: let me just tell you where i'm going:  would it be possible to make the second array mutable and just dispense with the first array altogether?  if the first array is injective, you could just scramble the second array directly
09:38:56 <skogar> ertes: ah, there will be several first arrays for each second array!
09:39:06 <skogar> ertes: multiple indexes for the same data
09:39:55 <xcmw> ertes: Note how you can tell the z, y, and z properties of any A from the data family given as an argument to A
09:41:24 <skogar> ertes: I have already immplemented something similar in C, using typedefs as index types; of course C typedefs gives no security, and I was hoping to cleanly distinguish index types in Haskell
09:42:02 <skogar> ertes: my issue is all about typing, not data structure or algorithm
09:48:46 <xcmw> ertes: Also note how q type checks
09:52:54 * hackagebot show-prettyprint 0.1.0.2 - Robust prettyprinter for output of auto-generated Show  instances  https://hackage.haskell.org/package/show-prettyprint-0.1.0.2 (quchen)
10:17:55 * hackagebot heckle 2.0.1.2 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.1.2 (2016rshah)
10:33:44 <kuribas> Is it good design to return Either from IO?
10:34:09 <Welkin> IO (Either a b) ?
10:34:13 <kuribas> yes
10:34:16 <Welkin> sure
10:34:27 <kuribas> for signalling error.
10:34:29 <Welkin> I usually see that as EitherT IO a b though
10:35:02 <kuribas> Why is that better?
10:35:09 <Welkin> or these days ExceptT
10:36:01 <Welkin> it depends on what you want to do
10:36:31 <kuribas> read a binary file format
10:36:42 <erisco> kuribas, if you want to sequence operations like you would with the Either Monad, but you need to also work in IO, then you use EitherT IO a b
10:37:02 <Welkin> type App a = ExceptT e IO a
10:37:03 <Welkin> for example
10:37:55 * hackagebot regex-do 2.6.1 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.6.1 (procione)
10:39:20 <Welkin> hoogle seems pretty useless to em the more I try to use it
10:39:28 <Welkin> I shouldn't even bother any more
10:39:33 <erisco> Monad transformers are a quagmire though‚Ä¶ I'd prefer to define a new type
10:39:35 <Welkin> I usually juse go straight to hyaoo
10:39:37 <Welkin> hayoo
10:39:49 <Welkin> hoogle doesn't even have ExceptT, which is in transformers
10:40:32 <ertes> kuribas: you could just use IO exceptions‚Ä¶
10:41:06 <kuribas> ertes: yes, the programmer has to catch them anyway
10:41:53 <ertes> yeah‚Ä¶  if you're in IO anyway, might as well use its built-in exception handling
10:42:45 <Welkin> hi bugaboodagoobodaby
11:07:56 * hackagebot warc 0.3.1 - A parser for the Web Archive (WARC) format  https://hackage.haskell.org/package/warc-0.3.1 (BenGamari)
11:10:35 <unclechu> hi there. ho do I describe FFI type for `void` pointer in C?
11:11:53 <Prutheus> Hi.I have installed the package zlib via ¬ªcabal install zlib¬´ but I can't import the ¬ªCodec.Compression.Zlib¬´ Module in my code. what could went wrong?
11:12:51 <geekosaur> unclechu, usually Ptr ()
11:13:31 <unclechu> geekosaur: thanks
11:13:57 <ezyang> Prutheus: How are you buliding your code? 
11:15:01 <Prutheus> ezyang: i just worked in ghci yet, there i can't import it
11:21:22 <Prutheus> ezyang: any idea?
11:24:02 <dxtr> So I'm having weird issues on Debian testing now :p
11:24:45 <dxtr> /usr/bin/ld: dist/build/System/PosixCompat/Extensions_hsc_make.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC
11:24:57 <Rag1212> Guys is there something like play.rust-lang.org for haskell where I can both run code and share my code snippet to others easily ?
11:25:16 <Prutheus> Hi.I have installed the package zlib via ¬ªcabal install zlib¬´ but I can't import the ¬ªCodec.Compression.Zlib¬´ Module in my code. what could went wrong?
11:25:27 <opqdonut> Rag1212: there's https://tryhaskell.org/ which has running
11:25:33 <Tuplanolla> Stop repeating yourself without any details, Prutheus.
11:26:13 <Rag1212> opqdonut: how can I share code that I type into tryhaskell.org
11:26:58 <opqdonut> Rag1212: well there's various pastebin sites like lpaste.net or gist.github.com, but nothing integrated AFAIK
11:28:35 <geekosaur> Rag1212, perhaps you want codepad.org
11:29:11 <opqdonut> oh, neat
11:30:13 <Prutheus> Tuplanolla: then tell me what more details you need
11:30:43 <geekosaur> dxtr, that's the no-pie issue, I'm looking for the quick fix but it involves some tweaks to the ghc settings
11:30:59 <Rag1212> Ah I see. I wanted to share a code snippet to get feedback from others. I wrote a very simple function which implements division(also handles negative and division by zero)
11:31:20 <dxtr> geekosaur: Cool!
11:31:24 <Rag1212> But my function ended up looking pretty hairy. I suspect there is a better way to acomplish the same task.
11:32:18 <Rag1212> http://lpaste.net/338899 -> Can someone do a quick review of this and suggest improvements 
11:32:27 <Tuplanolla> Prutheus: What operating system are you using? What commands did you issue? What did the installation print? How does the import fail?
11:32:40 <dxtr> geekosaur: Are you working on cabal or stack or..? :)
11:33:18 <geekosaur> none of them? xmonad maintainer, it doesn't rely on any tools beyond ghc itself
11:33:26 <dxtr> Also, why doesn't ghc like pie?
11:33:30 <geekosaur> I am not finding any of the quick fixes...
11:33:36 <dxtr> I thought everyone liked pie
11:33:49 <geekosaur> debian testing, and recent ubuntu, enabled position independent executables by default
11:34:12 <dxtr> Yeah I know :)
11:34:25 <geekosaur> ghc doesn't generate PIC relocations on the assumption that it is building for a .o instead of what is really a .so in disguise
11:34:41 <dxtr> right
11:37:01 <dxtr> So where is the issue? Are the packages having wrong options in the cabal file or is it cabal that should be smarter? ghc maybe?
11:37:36 <lpaste> geekosaur pasted ‚Äúghc settings file to disable PIE (untested)‚Äù at http://lpaste.net/338947
11:37:42 <geekosaur> I think I got that right
11:38:13 <geekosaur> somewhere in your ghc installation there is a file called "settings". try moving it out of the way and putting the contents of that paste in its place
11:38:21 <geekosaur> I think I got all the right changes to the right things...
11:38:43 <kuribas> Rag1212: why not use quot?
11:38:59 <geekosaur> one of them might be wrong in which case you will get a weird error, btu that error will tell me what to fix :)
11:39:22 <Tuplanolla> Where will the permanent fix go, geekosaur?
11:39:32 <kuribas> Rag1212: wrap quot around a test for 0.
11:39:36 <Tuplanolla> Somewhere inside GHC?
11:39:42 <kuribas> Rag1212: it will be faster than what you have.
11:39:48 <geekosaur> yes, theey are making it generate the correct relocations
11:39:52 <geekosaur> should be in 8.0.2 I think
11:40:45 <geekosaur> that is, the workaround disables position independent executables, the fix is to make ghc capable of producing them correctly
11:40:47 <Rag1212> kuribas: That kinda defeats the whole purpose doing the exercise :) I'm doing this as a part of an exercise in haskell-book.
11:41:33 <kuribas> Rag1212: is the exercise to subtract until you reach zero?
11:41:57 <Rag1212> exercise was to implement division using repeated subtraction
11:42:14 <Rag1212> while also handling negative numbers and divide by zero
11:44:01 <kuribas> Rag1212: I would test for negative numbers first.  Otherwise it looks fine.
11:44:11 <Rag1212> kuribas: Okay, I got an idea to make the code a little less hairy. I'll share the new snippet in a few.
11:45:56 <geekosaur> Prutheus, what directory were you in when you ran that, and did that directory have a 'cabal.sandbox.config' file in it?
11:46:11 <geekosaur> did you run that under sudo? (that would be wrong)
11:46:58 <Rag1212> kuribas: http://lpaste.net/338981 -> How about this?
11:47:42 <Prutheus> got it working with a force-reinstalls
11:48:04 <Tuplanolla> I have a feeling it could still be compacted, Rag1212.
11:49:34 <Rag1212> Tuplanolla: Can you suggest what can be done to improve on it?
11:50:30 <kuribas> Rag1212: that sign parameter is not necessary
11:50:32 <Tuplanolla> You should be able to merge one or two of the outer guards.
11:51:23 <jophish> tomjaguarpaw: are you about?
11:51:32 <dxtr> geekosaur: Doesn't seem to be working :p 
11:51:47 <Rag1212> kuribas: How else can I handle negative numbers without sign parameter?
11:51:56 <geekosaur> dxtr, what happened with it?
11:52:24 <geekosaur> (if nothing changed, make sure you don't have multiple ghc-s around. note that stack likes to install its own ghc, and you would need to find that and patch its settings file) 
11:53:33 <kuribas> Rag1212: I see
11:53:48 <dxtr> geekosaur: Nevermind me. This is another issue now. http://lpaste.net/2372026595524214784
11:54:33 <geekosaur> sounds like I got one of the options wrong. poking
11:55:15 <dxtr> geekosaur: http://lpaste.net/922695933097934848 <- this is the original settings file I had
11:55:44 <geekosaur> that already has (a slightly different form of) the no-PIE workaround
11:57:09 <geekosaur> but you are using stack, so https://github.com/commercialhaskell/stack/issues/2712 applies --- I think it may be interfering with the workaround?
11:57:32 <dxtr> Oh crap. Oh yeah, I tried to fix this yesterday so I installed a version of stack from git that supposedly was supposed to do that. Quite interesting that I'm still getting the pie issue, though :p 
11:57:44 <geekosaur> anyway put the old settings file back since it already had the correct workaround
11:57:50 <dxtr> Remembering stuff is hard
11:59:05 <dxtr> configure: WARNING: unrecognized options: --with-compiler <- why is it doing that?
11:59:15 <dxtr> It's also quite interesting that I keep getting different errors :p
11:59:20 <dxtr> Earlier I got the pie error
11:59:24 <dxtr> Now I'm getting that error
11:59:30 <dxtr> With the same settings file
12:00:24 <geekosaur> the --with-compiler just seems to be a thing. I suspect it has to do with compatibility and they just accept the warning on platforms/versions where it isn't applicable
12:01:19 <dxtr> Haha, hold on. I'll paste my config.log
12:01:42 <dxtr> http://lpaste.net/6305736362532274176
12:01:57 <dxtr> /usr/bin/ld: /tmp/dxtr/ccqGgHRl.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC
12:02:35 <geekosaur> yeh, -fno-PIE is being ignored for some reason
12:02:58 * hackagebot heckle 2.0.1.3 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.1.3 (2016rshah)
12:04:13 * geekosaur has no clue :(
12:04:35 <geekosaur> hm, that's not even ghc involved there. *really* have no idea
12:04:37 <Clint> geekosaur: no, that's because it's trying to ld -pie when you've gcc'd -fno-PIE
12:05:24 <Clint> if it were -fPIE and -no-pie it wouldn't complain like that
12:05:52 <dxtr> Clint: The command line is /usr/bin/gcc -o conftest -fno-PIE -fno-stack-protector   conftest.c  >&5
12:06:02 <geekosaur> hm. you;d think with -fno-PIE it wouldn't generate that relocation to begin with
12:06:04 <Clint> dxtr: right. add -no-pie to that and see what happens
12:06:15 <dxtr> How? This is configure
12:06:29 <geekosaur> so the settings file is missing an option somewhere
12:07:10 <Clint> dxtr: how are you passing -fno-PIE and -fno-stack-protector?
12:07:11 <dxtr> Or autoconf if you will
12:07:53 <geekosaur> that is from "C compiler flags" in the ghc settings file
12:08:18 <dxtr> Let's see then
12:08:23 <Clint> so you need
12:08:23 <Clint>  ,("C compiler link flags","-no-pie")
12:08:25 <geekosaur> but "C compiler link flags" has "-no-pie". it may however not be being passed to configure properly
12:08:27 <Clint> and
12:08:27 <Clint>  ,("ld flags","-no-pie")
12:08:34 <dxtr> Holy shit, you're right Clint
12:08:36 <geekosaur> http://lpaste.net/922695933097934848
12:08:43 <geekosaur> says both of them are there
12:08:45 <Clint> is Cabal involved here somehow?
12:08:48 <dxtr> geekosaur: My "C compiler flags" didn't have -no-pie
12:08:53 <Clint> because the one that shipped with ghc 8.0.1 is buggy
12:08:59 <dxtr> Yes it is
12:09:11 <geekosaur> ok, theres your answer then
12:09:28 <dxtr> Clint: I owe you a beer
12:09:41 <dxtr> Next time you're here I'll give you a beer or twelve
12:10:06 <Clint> i don't know where "here" is, but okay
12:10:21 <dxtr> Well it's not there, obviously
12:11:08 <dxtr> Sweden, 150km from Stockholm, if it actually matters :P
12:12:59 * hackagebot nanovg 0.5.1.0 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.5.1.0 (cocreature)
12:13:06 <Clint> dxtr: https://git.haskell.org/packages/Cabal.git/commit/c30b179a73d9fd3f6edcdda5e881523cd6edd46a
12:14:04 <lpaste> geekosaur revised ‚Äúghc settings file to disable PIE (untested)‚Äù: ‚Äúghc settings file to disable PIE (fixed, for future reference)‚Äù at http://lpaste.net/338947
12:14:23 <geekosaur> just so I have the damn thing for next time it comes up (later today no doubt >.> )
12:14:52 <dxtr> Clint: Aah
12:22:57 <Vq> dxtr: V√§stervik?
12:23:07 <dxtr> Vq: Norrk√∂ping
12:23:52 <Tuplanolla> Do you also go by the name dxtrslab, dxtr?
12:24:27 <elfeck> Hi, how can I have a function like f :: Int -> IO Int but for any monad instead of IO in particular?
12:24:33 <dxtr> No, but I should hang a sign in my office that says that, Tuplanolla
12:24:41 <Vq> dxtr: ok, I know someone from Link√∂ping in this channel.
12:24:58 <Tuplanolla> Then I know two different Swedish dxtrlikes.
12:25:29 <dxtr> I've been rocking dxtr for >10 years
12:25:29 <roboguy`> elfeck: f :: Monad m => Int -> m Int. Might need some more info to say if that is quite what you're looking for though
12:25:41 <LordBrain> elfeck, f :: Monad m => Int -> m Int
12:26:09 <alei> Hello, I'm trying to do a case statement for the typeOf something, and have something like 'case (typeOf a1) of Int...', but I keep getting the error 'Not in scope: data constructor `Int' '. Do you know what might be the issue?
12:26:23 <roboguy`> alei: why do you have Int there?
12:26:41 <alei> To check if a1 is an Int?
12:27:04 <alei> Kind of like this: https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/5-type-classes
12:27:12 <LordBrain> you need to use the typeRep
12:27:16 <elfeck> roboguy`, LordBrain thanks that works fine
12:27:56 <roboguy`> alei: ahhh, I see. That isn't how that works though. The type that typeOf gives back doesn't have those sorts of data constructors that you're thinking
12:28:00 <LordBrain> "Int" cant be used as a data constructor
12:28:31 <roboguy`> alei: what are you trying to do?
12:28:41 <alei> How do I use the typeRep?
12:29:25 <roboguy`> I suspect that it will help to know what you're doing, because that sort of thing is very rarely the best way to approach problems in Haskell
12:29:36 <Tuplanolla> > typeRep (Proxy :: Proxy Int) -- If you insist, alei.
12:29:42 <lambdabot>  Int
12:30:22 <roboguy`> Tuplanolla: that is slightly misleading unfortunately, since it sort of implies you can match on a constructor called "Int" (which isn't how that works...)
12:31:38 <LordBrain> he's probably just experimenting
12:32:02 <LordBrain> we all learn that way after all
12:32:23 <kuribas> @hoogle Either a b -> Maybe b
12:32:27 <roboguy`> LordBrain: true, but some paths are more confusing and frustrating than others and we could help with that if we have greater context
12:32:27 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
12:32:27 <lambdabot> Music.Theory.Either fromLeft :: Either a b -> Maybe a
12:32:27 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
12:32:29 <alei> roboguy`: Well, I'm actually just trying to take the mean, and had 'mean values = (fromRational $ toRational $ sum values) / (fromIntegral $ length values)', but I was thinking it might not perform as well as taking fromIntegral if Integral, leaving as is if Floating, or doing toRational and then fromRational otherwise.
12:32:31 <LordBrain> you could do typeOf (_::Int)
12:32:54 <roboguy`> alei: the main way in Haskell to do different things depending on the type is through a type class
12:33:00 * hackagebot btrfs 0.1.2.1 - Bindings to the btrfs API  https://hackage.haskell.org/package/btrfs-0.1.2.1 (MariosTitas)
12:33:02 * hackagebot lp-diagrams 2.1.0 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-2.1.0 (JeanPhilippeBernardy)
12:33:45 <kuribas> Is there a function Either a b -> Maybe b ?
12:34:37 <Tuplanolla> Whenever you use `typeOf`, you need to carry the types around with `Typeable` that would otherwise be erased at compile time, alei.
12:35:20 <LordBrain> alei, could do a type class with an associated type for the return type and have mean be a method of the class
12:35:22 <roboguy`> alei: I pretty strongly doubt that would cause a noticeable performance problem... That is the sort of thing I'd suggest profiling before making that kind of change
12:36:50 <roboguy`> especially since the calls you are worried about will probably be eliminated by the compiler if the types make them trivial (if I'm understanding what you mean correctly, IIRC those calls would turn into `id` which then has a decent chance of getting optimized out)
12:36:56 <geekosaur> if it does cause a problem, I'd file a bug on the grounds that someone missed a RULES pragma (again --- that fromRational . toRational construction has historically missed some cases)
12:37:01 <LordBrain> ooooooor just be simple and have meanIntegral and meanRational etc
12:37:34 <alei> Oh, ok, fair enough. I probably just won't bother with it then.
12:38:00 * hackagebot heckle 2.0.1.4 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.1.4 (2016rshah)
12:38:30 <alei> If fromRational . toRational converts something to floating point, why not just have a method that does that in the first place?
12:39:00 <roboguy`> alei: for future reference though, making decisions based on types is generally what type classes are for (although it is somewhat rare that you actually need to make decisions based like that based on types in the first place). typeRep is more for things like serialization, I think
12:39:24 <alei> roboguy`: All right, thanks.
12:40:37 <alei> Oh, I guess I would have realised this if I had read carefully, lol. 'But it turns out there is no way to write this in Haskell.'
12:43:00 * hackagebot heckle 2.0.1.5 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.1.5 (2016rshah)
12:46:28 <juri_> so, a safe alternative for data.cross' cross3?
12:50:17 <kuribas> >  realToFrac (0.2425 :: Double) :: Float -- alei 
12:50:20 <lambdabot>  0.2425
12:50:51 <kuribas> @src realToFrac
12:50:52 <lambdabot> realToFrac = fromRational . toRational
12:51:58 <alei> kuribas: Oh wow, that worked, thanks.
12:58:01 * hackagebot marxup 3.1.0.0 - Markup language preprocessor for Haskell  https://hackage.haskell.org/package/marxup-3.1.0.0 (JeanPhilippeBernardy)
13:03:01 * hackagebot modify-fasta 0.8.2.3 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.2.3 (GregorySchwartz)
13:08:06 <ryantrinkle> any word lately on 8.0.2?
13:09:44 <ryantrinkle> does anyone know when 8.0.2 is likely to drop?
13:14:28 <geekosaur> have not heard and the status page has not been updated
13:15:21 <ryantrinkle> (oh whoops, didn't mean to ask twice :P)
13:15:27 <ryantrinkle> geekosaur: thanks :)
13:15:30 <Cale> "Release candidate by mid-October 2016." :)
13:15:37 <geekosaur> although it shows 12827 as a high priority bug and someone was poking it yesterday
13:15:42 <ryantrinkle> last i heard there were some issues on mac or something
13:16:54 <geekosaur> yes, both the load commands table thing and the no-PIE debian/ubuntu issue, I think both are done? although maybe there's still some final work needed
13:17:29 <geekosaur> they were also waiting on the new hsc2hs, which likewise had the no-PIE issue while probing C struct definitions
13:17:38 <ryantrinkle> ahh
13:19:50 <geekosaur> possibly at this point that's the only blocker for release, they've been somewhat urgently agitating on IRC for the hsc2hs release
13:28:39 <buglebudabey> hey Welkin, just saw what you said earlier
13:29:29 <buglebudabey> how can i quote people?
13:30:35 <LordBrain> cut and paste
13:48:03 * hackagebot QIO 1.3 - The Quantum IO Monad is a library for defining quantum computations in Haskell  https://hackage.haskell.org/package/QIO-1.3 (AlexanderGreen)
13:59:43 <dxtr> What database library would you recommend? For now it's specifically for mysql but if it works with postgresql and/or sqlite too that's preferrable
14:04:17 <bergmark> if postgres and maybe sqlite i'd recommend opaleye, otherwise persistent/esqueleto
14:07:43 <juri_> so, when are we going to get a safe version of parallel strategies?
14:18:04 * hackagebot rattletrap 1.0.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-1.0.0 (fozworth)
14:31:09 <Prutheus> Hi. I wanna build jhc from source, and when I wanna execute ¬ªmake ¬´ after ¬ª./configure¬´, I get the error: ¬ªmake: DrIFT: Command not found¬´    but in which packaage is it? I am on arch linux
14:31:59 <Welkin> Prutheus: is your computer french?
14:32:32 <Clint> Welkin: guillemets the wrong way
14:32:46 <Prutheus> Welkin: what do you mean?
14:32:47 <Koterpillar> Prutheus: https://github.com/ajhc/ajhc/commit/3bdff522b17f6a7d6f3d96e3232ecb832211fed9
14:33:04 * hackagebot socket 0.7.0.0 - An extensible socket library.  https://hackage.haskell.org/package/socket-0.7.0.0 (LarsPetersen)
14:33:17 <Koterpillar> Prutheus: found by following ajhc's build process on Travis
14:33:39 <hodapp> what are you doing with JHC/Ajhc?
14:33:46 <hodapp> I certainly don't hear much about those
14:34:16 <Prutheus> Koterpillar: I can't find drift in the arch linux repo's
14:34:38 <Prutheus> hodapp: compile haskell code to embed it in arm microcontroller stuff
14:35:10 <Welkin> so you can run ghc distributed across multiple android phones
14:35:12 <Welkin> in the cloud
14:35:17 <Welkin> remember that guy?
14:38:04 * hackagebot vector-binary-instances 0.2.3.3 - Instances of Data.Binary and Data.Serialize for vector  https://hackage.haskell.org/package/vector-binary-instances-0.2.3.3 (BenGamari)
14:38:40 <hodapp> Prutheus: drop in to #haskell-embedded perhaps; I've done some stuff like this, albeit not with JHC/Ajhc
14:39:15 <Prutheus> hodapp: with what did you?
14:39:16 <hodapp> Prutheus: are you looking at Ajhc because you read Kiwamu Okabe's work here?
14:40:17 <hodapp> Prutheus: I used Ivory and eventually a homespun library, Ion. This was on GHC but GHC wasn't compiling to ARM, rather, I was targeting an EDSL to ARM
14:40:49 <Prutheus> nono, I  just want to embed haskell code into my c code, like HaskellInC does
14:50:53 <Prutheus> Why is the JHC website down?
14:51:45 <lgstate> JHC? there is a haskell compiler that works on java?
14:52:51 <Koterpillar> Prutheus: install it from cabal
14:53:10 <Koterpillar> Prutheus: well, hackage
14:53:21 <Prutheus> Koterpillar: it isnt in cabal
14:53:27 <ReinH> I don't think anyone here runs the JhC website, so we couldn't tell you why it is down.
14:53:57 <Koterpillar> Prutheus: then I don't know; I'd consider JHC dead
15:02:08 <Prutheus> I get an error at building JHC from source: http://lpaste.net/339076 any idea how I can fix this?
15:08:06 * hackagebot tasty-discover 1.0.1 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-1.0.1 (lwm)
15:08:07 * hackagebot GPipe-GLFW 1.2.3 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.2.3 (plredmond)
15:10:46 <Koterpillar> Prutheus: your compiler is too new
15:11:36 <dxtr> How come intero can't import Options.Applicative?
15:17:38 <dxtr> That's the only issue I have with it right now
15:31:14 <tnks> holy shit. . . hardening flags are getting in the way of GHC compiling... probably fine in Nix, but I lost my dev environment with raw Stack.
15:33:21 <Rembane> tnks: On what distribution?
15:33:30 <Rembane> what=which
15:40:43 <tnks> Rembane: Debian
15:40:53 <tnks> Rembane: I luck out that I use Nix, and --nix seems to "fix" everything.
15:45:55 <Rembane> tnks: Interesting. It worked quite well for me on Debian, but not on Ubuntu.
15:46:05 <Rembane> tnks: It was a couple of weeks ago though.
15:47:24 <tnks> Rembane: this is a known issue for GHC, but it's coming to bite more people, I think, because distributions are enabling more hardening into linkers.
15:47:46 <Welkin> what is hardening?
15:47:49 <tnks> I know very little about this world; it's just what I'm gleaning from the issue tracking and Googling.
15:48:38 <tnks> Welkin: https://wiki.debian.org/Hardening
15:48:55 <tnks> I'm pretty sure that's related, but I could be wrong.
15:49:13 <Tuplanolla> I was hoping for radiation hardening.
15:49:14 <tnks> I believe one of the hardening options involves relocation.
15:49:29 <tnks> which is closer to the issue reported in build failures.
15:49:46 <tnks> either way, this all works in Nix.
15:49:59 <Rembane> tnks: It is indeed.
15:50:23 <tnks> I love Nix, and our production build uses Nix... but I'd rather use Nix by choice, not because Haskell tools force me to.
15:51:25 <tnks> largely because every developer insists on having these Macbooks, and Nix on Mac doesn't cut mustard most of the time.
15:51:43 <tnks> so I guess they'll permanently be in a container or VM.
15:52:12 <Welkin> I'm only on mac right now because linux is a pain to install on this macbook
15:52:22 <Welkin> someday I will get it working on here
15:52:34 <Welkin> because I just started using i3 and love it
15:52:58 <tnks> at our work, two of us knew this might be an issue, and we insisted on getting Dell "project Sputnik" laptops.
15:53:03 <Welkin> developing haskell on a mac sucks
15:53:06 <tnks> thus far, it's worked out pretty well.
15:53:10 <Welkin> because you can't compile for deployment
15:54:15 <tnks> but now even Dells are 4k, 15", and battery lifetime-enough for the work.
15:54:52 <tnks> but Linux is finicky as hell, and the two of us were okay with that.
16:04:47 <yulax> Welkin:  i've been using ghci on openbsd and it worked out okay. you tried anything other than linux?
16:07:25 <Welkin> yulax: my servers run linux, so I need to compile on linux
16:12:05 <johnw_> this is getting a bit off topic
16:12:13 <johnw_> I recommend #haskell-blah
16:15:29 <Cale> Not #haskell-offtopic? :)
16:15:41 <johnw_> oh, hadn't heard of that one
16:16:08 <Cale> I made it a while back, the purpose is the same, but it doesn't require client encryption and it has the same operators as #haskell
16:16:11 <EvanR> its Cale's personal middle finger to -blah's policy
16:16:30 <Tuplanolla> What's wrong with encryption?
16:16:31 <johnw_> ah, right
16:17:22 <Cale> Tuplanolla: It serves no real purpose in what is effectively a public channel, but causes inconvenience to some users.
16:19:07 * EvanR points out the need to address the point that using encryption also hides your authentication with freenode
16:22:12 <EvanR> -blah has seen a decrease in the number of users and oejet has been MIA for a few months so i hope that things change
16:48:09 * hackagebot strips 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/strips-0.1.0.0 (uj)
17:31:06 <dibblego> @djinn (b -> c) -> (a -> b) -> a -> c
17:31:06 <lambdabot> f a b c = a (b c)
17:34:41 <erisco> someone said everything can be computed with a fold and unfold
17:34:59 <erisco> not sure where this result comes from but it is seemingly an interesting place to start looking for solutions
17:35:49 <dxtr> http://lpaste.net/2446634889034858496 <- Is there a way to make that pattern prettier? I have a lot of those things I want to add
17:37:49 <erisco> dxtr, is getBaseDir root "base" the only exceptional case?
17:38:28 <dxtr> yes
17:39:58 <erisco> ignoring that case, everything else is a triple (String, String, String)
17:40:41 <dxtr> Okay?
17:41:37 <erisco> \(a, b, c) root x -> if x == a then Just (getBaseDir root a </> c) else Nothing
17:42:12 <erisco> then you just write a list of the tuples you want
17:43:06 <boxscape> huh, I just realized that you can use MultiWayIf to completely replace case expressions, if you do something like `if | [] <- [] -> 4'. For some reason, that's slightly amusing to me, since you could, before MultiWayIf, use `case () of _ | True -> 4' to emulate MultiWayIf. So we have two constructs with the exact same functions, basically. (Unless I'm missing something)
17:43:36 <erisco> special case is \root x -> if x == "base" then Just root else Nothing
17:43:50 <erisco> fold with <|>
17:44:07 <erisco> :t id <|> id
17:44:08 <lambdabot> Alternative ((->) a) => a -> a
17:44:32 <erisco> const Nothing <|> const (Just 3)
17:44:34 <erisco> > const Nothing <|> const (Just 3)
17:44:36 <lambdabot>  error:
17:44:36 <lambdabot>      ‚Ä¢ No instance for (Typeable b0)
17:44:36 <lambdabot>          arising from a use of ‚Äòshow_M347809697905235483715890‚Äô
17:44:51 <erisco> these errors are weird
17:44:59 <dxtr> :p
17:45:56 <erisco> not sure if <|> is defined for functions in a standard lib
17:46:11 <geekosaur> that just means you're trying to show something polymorphic
17:46:21 <erisco> I am thinking of <>
17:46:56 <EvanR> comprehending the esoteric shapes of compiler error messages, the unacknowledged job requirement / super power of programmer types
17:47:05 <erisco> but Maybe's <> isn't what I want
17:47:11 <erisco> I want the <|> version :P
17:47:54 <erisco> you will have to define that piece yourself then
17:48:16 <athan> D: irc-client might have a memory leak - my process has 1T of virtual memory allocated when the service starts
17:48:30 <EvanR> does anyone know what is up with the terminology "heap", heap is a tree data structure, and theres the heap, part of your runtime environment. are they related? the word doesnt seem to directly relate to either thing
17:48:54 <erisco> it is simple: Nothing <+> x = x; x <+> Nothing = x;
17:49:00 <dxtr> I'm not sure I completely understand, erisco. Pretty new to Haskell after all :p
17:49:23 <erisco> okay, well I gave a sparse explanation, so that is understandable. I will speak with more detail then
17:49:50 <barrucadu> athan: GHC 8 allocates 1TB of virtual memory: https://downloads.haskell.org/~ghc/master/users-guide/8.0.1-notes.html#runtime-system
17:50:09 <erisco> if you look at lines 3-15 there are only 2 or 3 things changing
17:50:26 <dxtr> Yeah yeah. I think I understand all the parts but I'm not quite connecting them
17:51:10 <erisco> is the string you match on always the same thing you append with </> ?
17:51:24 <dxtr> Indeed
17:51:33 <erisco> okay, then two things change
17:52:01 <athan> oh wow, thank you barrucadu
17:52:10 <geekosaur> athan, more precisely it creates the address space but doesn't populate it
17:52:20 <erisco> first thing I am going to do is rewrite the pattern match so we can abstract it
17:52:29 <geekosaur> and allocates and frees pages with madvise() instead of malloc()
17:52:54 <athan> ahh, right on :) thanks geekosaur & barrucadu!!
17:53:23 <dxtr> Right
17:54:05 <erisco> because if I try to abstract it as is Haskell thinks it is something else‚Ä¶ let me show you
17:54:41 <erisco> getBaseDir root x = getBaseDir root y </> x     I have generalised with the variables x and y
17:54:50 <erisco> all I did was stick in variables in the places where stuff changes
17:54:55 <erisco> make some sense?
17:55:09 <dxtr> Definitely
17:55:21 <erisco> the problem is that the x I stuck in on the left of x doesn't mean what was intended‚Ä¶ it means match anything
17:55:45 <erisco> so I can write this differently
17:56:35 <erisco> getBaseDir root p = if p == x then getBaseDir root y </> x     starting with something like this
17:57:05 <dxtr> Alright
17:57:14 <erisco> so now if we substitute, say, "app" for x and "base" for y we get  getBaseDir root p = if p == "app" then getBaseDir root "base" </> "app"
17:57:34 <dxtr> yes
17:58:11 <erisco> which is roughly what we had before. The problem is that we need a case for when p /= "app"
17:58:57 <erisco> so now I say   getBaseDir root p = if p == x then Just (getBaseDir root y </> x) else Nothing
17:59:26 <dxtr> where do we get y from?
17:59:47 <erisco> nowhere yet, it is a free variable
18:01:19 <dxtr> Alright 
18:04:25 <erisco> I am just wondering how to make this simple going forward. I just noticed it is recursive
18:05:41 <erisco> I am confused as to what it does
18:06:23 <dxtr> Haha, it is recursive because I'm a smartass
18:06:39 <dxtr> Everything ends up in getBaseDir root "base"
18:07:00 <erisco> it seems like it maps directory names to absolute paths
18:07:14 <dxtr> it does
18:07:32 <dxtr> It doesn't have to recurse like that, obviously
18:07:53 <erisco> in that case, why not just Map String FilePath or [(String, FilePath)] or String -> FilePath defined more simply?
18:08:12 <erisco> getBaseDir root "app" = root </> "app"
18:08:24 <dxtr> Because I don't have root
18:08:35 <erisco> it is a parameter
18:08:36 <dxtr> Oh
18:08:40 <dxtr> You mean like that :p
18:08:52 <dxtr> Well, my initial idea was that I might want some checks in "base"
18:09:03 <dxtr> Like "Is this an actual valid root?"
18:09:27 <erisco> does that have to be part of this function?
18:09:38 <dxtr> Absolutely not
18:09:39 <erisco> you can test if root is a file or if getBaseDir x y is a file
18:09:58 <dxtr> They will all be directories, though :p
18:10:35 <erisco> directories are files on some systems
18:11:05 <dxtr> That is true
18:12:50 <dxtr> http://lpaste.net/6877824786588762112
18:13:00 <dxtr> That's about as much as it makes sense to me to simplify it
18:13:16 <dxtr> "simplify" == remove some recursion
18:14:00 <erisco> well we can make the recursive version if you want
18:16:48 <dxtr> You're the expert here :p I'm just trying to learn how to make stuff that doesn't look like crap
18:17:59 <erisco> @hoogle (</>)
18:18:02 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
18:18:02 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
18:18:02 <lambdabot> Filesystem.Path (</>) :: FilePath -> FilePath -> FilePath
18:18:12 * hackagebot hmatrix-gsl-stats 0.4.1.5 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.5 (VivianMcPhail)
18:18:14 * hackagebot text-zipper 0.9 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.9 (JonathanDaugherty)
18:18:36 <EvanR> dxtr: your function definition seems pretty specific to a certain set of directories, thats stands out to me as not "too complex" but "too specific"
18:25:23 * geekosaur wonders if this is the person who was working on a specific in-memory filesystem a couple weeks ago
18:26:55 <erisco> I am getting there oO
18:28:00 <dxtr> Who? Me?
18:28:13 * hackagebot hmatrix-gsl-stats 0.4.1.6 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.6 (VivianMcPhail)
18:30:26 <geekosaur> oh wait, I remember who that was now, n/m
18:31:12 <dxtr> http://lpaste.net/5498229442268364800 <- what about this?
18:31:30 <dxtr> Makes it easy to add new stuff too
18:32:10 <erisco> well this is quite ugly but it is on its way http://lpaste.net/339112
18:32:14 <dxtr> not really efficient, though :p
18:34:35 <erisco> well it depends
18:34:52 <erisco> GHC isn't necessarily doing anything other than a linear scan when you do all those string matches
18:35:26 <erisco> if you have lots of strings, say hundreds, then a Map may show improvement
18:35:56 <dxtr> It's around 30
18:36:15 <erisco> well then my money is on linear scan
18:38:06 <erisco> I wish we didn't have to define then_ but the wrong instances were chosen for Monoid
18:38:14 * hackagebot hstatistics 0.2.5.4 - Statistics  https://hackage.haskell.org/package/hstatistics-0.2.5.4 (VivianMcPhail)
18:39:06 <erisco> so the basic premise here is that if we have a piecewise function definition then we can break each case into separate functions which return Maybe
18:39:41 <erisco> so we go from  f *condition* = y to fCase = if *condition* then Just y else Nothing
18:40:40 <EvanR> were you looking for Maybe's <|> operator?
18:40:54 <erisco> we cannot compose Haskell's piecewise function definitions but we can work with this translation
18:41:20 <erisco> the problem EvanR is that -> cannot have a <|> instance
18:42:03 <EvanR> which wrong instance were you referring to
18:42:21 <erisco> the Maybe instance for <>
18:42:31 <EvanR> the Monoid instance for Maybe?
18:42:40 <erisco> yes
18:42:54 <EvanR> were you looking for Maybe's <|> operator?
18:43:18 <erisco> there is a hole in my bucket dear Lisa
18:44:15 <erisco> so the nice thing is that most of the cases have a general pattern, which is getBaseDirCase
18:44:25 <erisco> we can get all the cases back by applying this to the list of pairs
18:44:41 <erisco> now we have a list of cases, which we can fold together, this is getBaseDir
18:44:50 <erisco> then there is additionally the extra case of "base"
18:46:19 <erisco> so there is a consistent general idea to it, but I am not sure it plays out so beautifully in code
18:48:01 <erisco> you could take a completely different approach to it though
18:50:03 <erisco> I think the one you arrived at, which walks through the transitive pairs, it a good one
18:50:33 <erisco> you could also derive this list of pairs from a rose tree which would more succinctly represent the file system
18:52:55 <dxtr> http://lpaste.net/2970173509583503360 <- I took some inspiration from you and return a Maybe instead :p
18:53:33 <dxtr> So I'll get an indication if I type it wrong
18:53:44 <dxtr> Or do it wrong or whatever
18:54:24 <erisco> do d <- lookup dir dirAssoc; b <- getBaseDir root d; return (b </> dir);
18:54:54 <dxtr> Oh yeah that's how you do it
18:55:10 <erisco> or  (</> dir) <$> getBaseDir root <*> lookup dir dirAssoc
18:56:19 <erisco> or  (</> dir) <$> (lookup dir dirAssoc >>= getBaseDir)    may be redundant brackets
18:56:32 <erisco> getBaseDir root   that is
18:56:55 <erisco> one of those is a type error ^.^
18:58:14 * hackagebot hsignal 0.2.7.5 - Signal processing and EEG data analysis  https://hackage.haskell.org/package/hsignal-0.2.7.5 (VivianMcPhail)
19:13:15 * hackagebot diagrams-contrib 1.4.0.1 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.4.0.1 (BrentYorgey)
20:09:04 <lgstate> is there a way to have ghc emit nacl or asm.js directly, w/o usig ghcjs?
20:10:56 <Cale> lgstate: no
20:11:31 <Cale> (well, there's a way, it's just going to be a lot of work...)
20:12:07 <ReinH> Yeah, just write something that does that.
20:12:12 <Cale> heh
20:12:13 <Cale> yeah
20:12:26 <ReinH> And then there will be a way to do that
20:12:40 <Cale> It'll also amount to doing a lot of the same stuff as ghcjs does, so it would be easier to start from ghcjs than ghc.
20:13:19 <Cale> e.g. you'll still need a js implementation of the runtime system, and shims and whatnot
20:17:10 <xenon-> @src nub
20:17:10 <lambdabot> nub = nubBy (==)
20:17:10 <lambdabot> --OR
20:17:10 <lambdabot> nub l = go l []
20:17:10 <lambdabot>   where go []     _       = []
20:17:10 <lambdabot>         go (x:xs) ls
20:17:12 <lambdabot>             | x `elem` ls = go xs ls
20:17:14 <lambdabot>             | otherwise   = x : go xs (x:ls)
20:17:20 <pikajude> :t \ f a b -> liftA2 (\ x y -> liftA2 f x y) a b
20:17:21 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
20:17:34 <xenon-> @src nubBy
20:17:34 <lambdabot> nubBy eq []     = []
20:17:34 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:17:35 <pikajude> see, that's what I thought, but this isn't typechecking
20:17:54 <xenon-> is that an actual implementation for nubBy? it seems like it could be done a lot faster by utilizing Data.Map.Map
20:18:57 <Cale> :t nubBy
20:18:59 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
20:19:04 <Cale> ^^ no Ord constraint
20:19:42 <Cale> But also, how are you going to do it with Data.Map, when you have an arbitrary predicate?
20:20:21 <xenon-> true. then hash table
20:20:29 <Cale> That... doesn't help
20:20:34 <xenon-> how is that
20:20:51 <Cale> How do you compute a hash of, say, a function?
20:21:11 <Cale> The 'a' type occurring in nubBy's type signature could be any type at all
20:21:28 <xenon-> :t nubBy
20:21:30 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
20:22:33 <Axman6> > nubBy (\_ _ -> True) [sum, product, length]
20:22:34 <xenon-> not sure supporting an edge case is worth it to have dog-slow nub
20:22:35 <lambdabot>  [<[Int] -> Int>]
20:22:43 <geekosaur> there is a nubOrd somewhere
20:22:56 <Axman6> there are definitely implementations of nub using more efficient algorithms
20:23:08 <Axman6> @hoogle nubOrd
20:23:08 <lambdabot> Data.List.Extra nubOrd :: Ord a => [a] -> [a]
20:23:08 <lambdabot> Extra nubOrd :: Ord a => [a] -> [a]
20:23:08 <lambdabot> Data.List.Extra nubOrdBy :: (a -> a -> Ordering) -> [a] -> [a]
20:23:20 <Axman6> I thought something got added with GHC 8
20:23:28 <geekosaur> once you add a constraint (Ord, or Hash) you can do a faster nub
20:23:33 <geekosaur> er, Hashable
20:23:47 <geekosaur> although I don't think there's a Hashable nub-oid out there
20:24:20 <Axman6> it's also trivial to implement yourself too
20:30:03 <Cale> > foldr (\x xs s -> if x `S.member` s then xs else x : xs (S.insert x s)) (const []) "abracadabra" S.empty
20:30:05 <lambdabot>  error:
20:30:05 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòS.Set Char -> [Char]‚Äô with ‚Äò[Char]‚Äô
20:30:05 <lambdabot>        Expected type: S.Set Char -> [Char]
20:31:08 <Cale> > foldr (\x xs s -> if x `S.member` s then xs s else x : xs (S.insert x s)) (const []) "abracadabra" S.empty
20:31:10 <lambdabot>  "abrcd"
20:31:13 <Cale> right
20:59:11 <alphonse23_> anyone know anything about getting yesod to work on OpenBSD?
20:59:23 <alphonse23_> I keep trying to run yesod and I keep getting this error: .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod: no closing quote
20:59:37 <xenon-> Cale cool
21:00:01 <Axman6> alphonse23_: how are you running it?
21:03:46 <alphonse23_> $ stack exec -- yesod devel
21:06:03 <Prutheus> I get an error at building JHC from source: http://lpaste.net/339076 any idea how I can fix this?
21:06:25 <xenon-> M.fromAscList
21:06:29 <xenon-> > M.fromAscList
21:06:31 <lambdabot>  error:
21:06:31 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
21:06:31 <lambdabot>          arising from a use of ‚Äòshow_M355289421769312992920098‚Äô
21:06:50 <geekosaur> alphonse23_, your yesod executable is not being recognized as an executable for some reason, so it's being run as a shell script
21:06:57 <xenon-> > M.fromAscList $ map (\x -> (x, x)) "abracadabra"
21:06:59 <lambdabot>  fromList [('a','a'),('b','b'),('r','r'),('a','a'),('c','c'),('a','a'),('d','...
21:07:02 <xenon-> is this expected?
21:07:09 <geekosaur> run this command: file .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod: no closing quote
21:07:12 <geekosaur> er
21:07:16 <geekosaur> run this command: file .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod
21:08:06 <geekosaur> Prutheus, jhc predates the Applicative "superclass" for Monad. either you have to retrofit Applicative instances, or build it with ghc 7.8.4 or older
21:08:24 <alphonse23_> same thing: .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod: no closing quote
21:08:32 <geekosaur> "file" is a command,
21:08:43 <geekosaur> it identifies the kind of file its parameter is
21:08:52 <geekosaur> run this command: file .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod
21:09:00 <geekosaur> the word "file" there is not optional
21:09:23 <alphonse23_> .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod: ELF 64-bit LSB executable, x86-64, version 1
21:09:24 <xenon-> > M.fromAscList [('a',1),('b',1),('a',1)]
21:09:26 <lambdabot>  fromList [('a',1),('b',1),('a',1)]
21:09:27 <xenon-> > M.fromAscList [('a',1),('a',1)]
21:09:29 <lambdabot>  fromList [('a',1)]
21:09:29 <xenon-> wtf?
21:10:08 <Cale> xenon-: What were you expecting?
21:10:11 <geekosaur> xenon-, the keys are the same so they got collapsed into one entry. meanwhile Map has no visible constructors, so its Show instance is a call to fromList
21:10:13 <Prutheus> geekosaur: how can I build it with an older gcc?
21:10:44 <geekosaur> (which is a "smart constructor" for Map-s)
21:10:46 <Cale> Oh, you constructed an invalid Map in the first application of fromAscList
21:10:50 <Axman6> xenon-: you're breaking the contract that the documentation for fromAscList says you need to keep
21:10:59 <Axman6> the keys must be in acending order
21:11:07 <Prutheus> geekosaur: or is it easy to fix the stuff in jhc?
21:11:18 <Axman6> you probably want M.fromList
21:11:26 <xenon-> oh
21:11:56 <geekosaur> Prutheus, you would need to install an older ghc (somewhere other than where whatever you are currently using is)
21:11:58 <Axman6> fromAscList is an optimisation for the (quite common) situation where you know for sure that the keys in the list are already ordered
21:12:06 <Axman6> which can be done in linear time
21:12:18 <Axman6> but fails if you break the contract
21:12:41 <Prutheus> geekosaur: I have also ghc-7.10.3 on my system, but how to tell the ./configure or make of jhc to use it?
21:13:02 <geekosaur> otherwise, the easy way to retrofit Applicative is:  instance Applicative WhateverTheMonadIs where pure = return; <*> = ap
21:13:09 <geekosaur> ghc 7.10.3 is too recent also
21:13:15 <geekosaur> I said 7.8 not 7.10
21:13:44 <Prutheus> geekosaur: would be no problem to paralel-install 7.8 ..... could you explain more detailed please how I can fix it?
21:14:10 <geekosaur> alphonse23_, ok, that is odd. unless it is not marked executable for some reason (ls -l .stack/snapshots/x86_64-openbsd/lts-6.24/7.10.3/bin/yesod) and stack is doing something weird (it should not be running something not executable at all)
21:14:32 <geekosaur> or you are on 32 bit, but then why would stack be using an x86_64 directory
21:14:41 <alphonse23_> -rwxr-xr-x
21:14:51 <alphonse23_> I'm pretty sure it's 64
21:15:20 <geekosaur> Prutheus, if what I said above "instance Applicative ..." was not enough then the only detail good enough for you is for me to upload a fixed copy for you. and no, I am not going to go through and fix it for you
21:17:09 <Prutheus> geekosaur: sorry, i just use haskell since half a year, haven't learned monads yet, here is the code, where e.g. must I change it now? http://lpaste.net/339134
21:17:50 <geekosaur> why are you trying to build jhc, anyway? it hasn't been supported in several years now (which is why it no longer builds)
21:18:05 <geekosaur> ad I guess you are telling me "yes yu should fix this for me"
21:18:41 <eliaslfox> hello
21:18:46 <Prutheus> geekosaur: because I need to compile haskell for arm-eabi, and no, please jsust tell me how to fix it with examples in the file I linked
21:19:07 <lpaste> geekosaur annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/339134#a339135
21:19:08 <eliaslfox> What's up?
21:19:46 <geekosaur> Prutheus, I added lines 19-21, changed nothing else
21:20:08 <geekosaur> and I am not sure that jhc is going to help you with that, to be honest; not enough things build with it
21:20:34 <geekosaur> and it doesn't really support the tooling because it is a whole-program compiler
21:21:14 <Prutheus> geekosaur: it is correct, i want a whole-program compiler, and I can create a rule in it which should work. geekosaur , i see what you did, but I dont know how to apply it on the next monad
21:21:17 <eliaslfox> ping 8.8.8.8
21:21:37 <Prutheus> geekosaur: could you please show on the next monad, too?
21:21:47 <geekosaur> ...
21:21:54 <geekosaur> you really do want me to fix this whole program for you
21:22:33 <geekosaur> you replace (ReaderWriter r w) with whatever is mentioned in the error "    ‚Ä¢ Could not deduce (Applicative ...)"
21:22:43 <geekosaur> which for this file was:     ‚Ä¢ Could not deduce (Applicative (ReaderWriter r w))
21:22:53 <geekosaur> so I made the instance for (ReaderWriter r w)
21:23:19 * hackagebot yesod-form 1.4.9 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.4.9 (MichaelSnoyman)
21:25:48 <Prutheus> geekosaur: ahh ok
21:26:44 <Prutheus> geekosaur: didn't work: src/Util/ReaderWriter.hs:21:9: error: parse error on input ‚Äò<*>‚Äô
21:32:32 <geekosaur> oh sorry
21:32:33 <MarcelineVQ> Prutheus: that's because it's written as an infix operator but it's not between any arguments, you can replace it with (<*>) to make it a prefix operator and have it parse and eta reduce correctly
21:33:11 <MarcelineVQ> allthough a prefix operator is just a function so I'm probably messing up terminology
21:33:16 <lpaste> geekosaur revised ‚ÄúNo title (annotation)‚Äù: ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/339135
21:34:12 * geekosaur thinko, too tired --- actually noticed that before sending it but from the wrong end ("am I missing ``")
21:37:29 <Prutheus> geekosaur: now I get still an error: http://ix.io/1ELu
21:37:30 <MarcelineVQ> there's up to 3 other errors you'll run into after that fix, the compiler should help you figure out what to do though
21:38:16 <Prutheus> I dont know monads yet, so I don't understand :/
21:38:27 <Kaidelong> can anyone recommend an algebra lib?
21:38:38 <Kaidelong> or should I just do it by hand/using wolframalpha?
21:40:14 <Axman6> Prutheus: I'm curious why you're writing this code if you haven't used any of the monadic types you're implementing
21:49:05 <MarcelineVQ> There's a Monoid constraint on w in the Monad instance which is missing from the Applicative instance, which causes ap to not be the same as (<*>) and so ghc complains.
21:54:19 <MarcelineVQ> the compiler does suggest you add the (Monoid w) constraint to the the instance declaration in the error message, though it might not be immediately obvious. the error message in ghc can be big but they're really useful
22:02:14 <Prutheus> Axman6: i dont write any code
22:02:46 <Prutheus> how wto tell the ./compile or make script which version of ghc should be used?
22:34:23 <eliaslfox> Hello
22:37:09 <_cyril_> Hi, I'm using http-conduit and for some https URLs I get this error message: *** Exception: TlsExceptionHostPort (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))) ; I can access said URL with my browser no problem. I'm on OSX. Anyone has a clue about where I should start?
22:39:12 <Sibi__> Any solution to this: http://stackoverflow.com/q/40577150/1651941 ?
22:47:25 <_cyril_> Sibi__: I don't have an exact answer for you, but looking at the strings embedded into a binary I can find *some* of what you're looking for. So it must be at least partially possible
22:47:30 <MarcelineVQ> something like `executable +RTS --info` can get you the ghc version, which can at least inform you about what base version is used.
22:47:36 <ongy> "strings .monky/monky.exe | grep -i base-" works pretty well to find base.  Looks a bit like linker command to me
22:54:10 <qqii> Hello!
22:54:31 <qqii> I'm wondering if anyone can help me with a broken link on a hackage package?
22:55:24 <qqii> I'm looking for a link on dynamorphisms: "Dynamorphisms (http://math.ut.ee/~eugene/kabanov-vene-mpc-06.pdf) are a more general form of histomorphisms for capturing dynaming programming constructions."
22:55:31 <Sibi__> ongy: Thanks, that's very close to what I want.
22:55:35 <qqii> From this package: https://hackage.haskell.org/package/pointless-haskell-0.0.9/docs/Generics-Pointless-RecursionPatterns.html#dyna
22:56:43 <qqii> Sorry, I mean futumorphisms: "Futumorphisms are the dual of histomorphisms and are proposed as 'cocourse-of-argument' coiterators by their creators (http://cs.ioc.ee/~tarmo/papers/inf.ps.gz)."
23:02:05 <qqii> anyone?
23:04:43 <ezyang> I wonder, is there an easy way to see what packages were on Hackage circa 2007 (when ByteString first came out) 
23:04:59 <phadej> qqii: http://www.mii.lt/informatica/pdf/INFO141.pdf
23:05:22 <phadej> qqii: google helped, tarmo = Tarmo Uustalu
23:05:49 <qqii> Thanks a lot phadej!
23:05:55 <phadej> http://cs.ioc.ee/~tarmo/papers/inf99.pdf from the authors page
23:05:58 <phadej> qqii: np
23:06:34 <phadej> qqii: please submit a PR to the package (also citing the title, not just volatile url)
23:07:15 <hololeap> i want to know more about a pattern i have observed in haskell (although it exists in all programming languages). i don't know if it has a name. it has to do with the difference between programming and pure math
23:08:32 <hololeap> it has to do with the idea of breaking out of a recursive function early. i noticed that (&&) will not evaluate the right expression if the left evaluates to false
23:09:17 <ezyang> lazy evaluation? 
23:09:55 <hololeap> ezyang: ok, so then it is nothing special in haskell, just an outliler in other non-lazy languages which use this lazily?
23:10:18 <ezyang> in other languages, the term "short-circuiting evaluation" is generally used 
23:10:44 <hololeap> ok, i'm not very familiar with the terms
23:12:39 <ezyang> I mention it because you can use that as a starting point to do more searching / looking up 
23:14:20 <hololeap> so i guess where i'm going with this is that i am looking for a general way to break out of a iteration of on a list, for instance, if you wanted to know if there were any duplicates in a list, but wanted to break out as soon as a duplicate is found. i have read that foldr will do this, but i don't understand why.
23:14:34 <hololeap> *iteration on a list
23:14:50 <grantwu> @src foldr
23:14:50 <lambdabot> foldr f z []     = z
23:14:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:15:20 <grantwu> If f does not need its second argument, foldr f z (x:xs) can terminate without the second recursive call
23:15:29 <grantwu> Er, s/second//
23:16:56 <hololeap> it looks like f takes two arguments in that example
23:17:15 <hololeap> err source
23:17:37 <grantwu> Right, but suppose we defined f as
23:18:14 <grantwu> f 0 _ = 0
23:18:19 <grantwu> f x y = x + y
23:18:36 <grantwu> Then if we ever encounter a 0, the second argument isn't needed
23:19:28 <hololeap> interesting. so then that's the only way to make foldr exit out early?
23:19:50 <hololeap> using pattern matching and discarding the second argument?
23:22:21 <grantwu> I mean, it doesn't have to necessarily be pattern matching... you can do const <value>
23:22:36 <hololeap> @src const
23:22:37 <lambdabot> const x _ = x
23:22:52 <grantwu> Sure, it ends up being pattern matching
23:23:10 <hololeap> it's just good to know. it seems kind of implementation specific though...
23:23:20 <grantwu> Yeah, it only works with non-strict evaluation
23:24:01 <hololeap> is there another way to "short-circuit" a loop without using foldr?
23:24:45 <nshepperd> ' f x y = if x == 0 then 0 else x + y' also
23:25:05 <nshepperd> hololeap: you can just end early with explicit recursion
23:25:07 <hololeap> like a short-circuiting monoid...
23:25:11 <srhb> Tons, really. But they all boil down to the same technique.
23:25:18 <nshepperd> that also
23:25:44 <nshepperd> > foldMap (First . Just) [1..]
23:25:47 <lambdabot>  First {getFirst = Just 1}
23:26:54 <hololeap> @src foldMap
23:26:54 <lambdabot> Source not found. Do you think like you type?
23:27:45 <hololeap> @src Data.Foldable.foldMap
23:27:45 <lambdabot> Source not found. Where did you learn to type?
23:27:55 <srhb> foldMap f = fold . fmap f, more or less
23:28:08 <srhb> And lambdabot has a fake (and very limited) source database
23:28:12 <srhb> It doesn't correspond to actual sources.
23:28:15 <srhb> (Usually)
23:28:24 <hololeap> ok
23:28:36 <srhb> Probably why it gets so defensive about it when it doesn't know... :-)
23:28:39 <hololeap> does it have to insult my typing :)
23:28:52 <hololeap> lol
23:28:58 <nshepperd> foldMap f = foldr (mappend . f) mempty
23:31:08 <ahri> i want to convert a string of characters into a structure (2d list) but if it has any spurious characters in there i want to return a Nothing; so load :: String -> Maybe [[Tile]] ; i feel like there's probably a correct way to achieve that; is it a fold + maybe monoid i'm looking for? (i'm attempting to improve my intuition!)
23:34:00 <ahri> although, from what little i know about monads, i'd be able to stop processing the string immediately upon hitting a spurious character there, right?
23:34:53 <Cale> ahri: You might want to use the Monad instance for Maybe, which is roughly like list comprehensions restricted to lists of length at most 1
23:34:58 <nshepperd> ahri: you maybe want a traversal?
23:36:02 <Cale> > sequence [Just 1, Just 2, Just 3]
23:36:06 <lambdabot>  Just [1,2,3]
23:36:10 <Cale> > sequence [Just 1, Nothing, Just 3]
23:36:13 <lambdabot>  Nothing
23:36:24 <simukis_> is there a way to ask lambdabot for partial transformation?
23:36:37 <simukis_> for @pl
23:38:12 <Cale> simukis_: partial in what way?
23:38:35 <Cale> Like, just eliminate one argument from a lambda with many?
23:38:40 <simukis_> yeah
23:38:58 <Cale> Usually I just allow those other arguments to be free variables
23:39:08 <Cale> @pl doesn't actually care all that much about whether things are in scope
23:39:08 <lambdabot> (line 1, column 64):
23:39:09 <lambdabot> unexpected reserved word "in"
23:39:09 <lambdabot> expecting variable
23:39:12 <Cale> heh
23:39:17 <simukis_> oh
23:39:20 <simukis_> nice idea
23:39:49 <simukis_> thanks, Cale!
23:39:53 <Cale> no problem
23:40:28 <nshepperd> @let data I a = Bottom | Top | Some a
23:40:29 <lambdabot>  Defined.
23:40:49 <ahri> Cale: huh, that looks like exactly what i want! i really need to figure monads out properly; i feel like i'm missing something despite having a basic understanding of their characteristics
23:41:31 <jle`> anah don't worry about monads
23:41:39 <jle`> *nah
23:41:53 <jle`> ahri: Monad isn't relevant in this case
23:42:01 <jle`> what you really wanted to understand was Maybe
23:42:04 <Mortomes|Work> They're like burritos, man.
23:42:08 <nshepperd> @let instance Monoid a => Monoid (I a) where { Top <> _ = Top; _ <> Top = Top; Bottom <> x = x; x <> Bottom = x; Some x <> Some y = Some (x <> y); mempty = Bottom }
23:42:09 <lambdabot>  .L.hs:167:13: error:
23:42:10 <lambdabot>      ‚Äò<>‚Äô is not a (visible) method of class ‚ÄòMonoid‚Äô
23:42:13 <nshepperd> oh
23:42:51 <Cale> jle`: Well, it's relevant insofar as you have to know that sequence works for Maybe, and be able to tell what it would do
23:42:51 <jle`> . o ( type I = Either Bool )
23:43:07 <Cale> @src sequence
23:43:07 <lambdabot> sequence []     = return []
23:43:07 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:43:07 <lambdabot> --OR
23:43:07 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:43:25 <jle`> yeah, but you wouldn't understand what it does by understanding monads
23:43:27 <Cale> (this is the old sequence for lists, but that's good enough here :)
23:43:33 <jle`> understanding it comes from understanding Maybe
23:43:38 <simukis_> what is the if' that @pl uses?
23:43:45 <simukis_> @type if'
23:43:46 <lambdabot> error:
23:43:47 <lambdabot>     ‚Ä¢ Variable not in scope: if'
23:43:47 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòf'‚Äô (imported from Debug.SimpleReflect)
23:43:51 <Cale> simukis_: \b t e -> if b then t else e
23:43:56 <nshepperd> so anyway is there any common name for the above monoid?
23:44:01 <jle`> if' True x y = x; if' False x y  = y, probably
23:44:03 <nshepperd> like Maybe but with a zero?
23:47:23 <Cale> nshepperd: It might be nicer to weaken the constraint to Semigroup a => Monoid (I a)
23:47:38 <nshepperd> yeah I suppose
23:48:23 <Cale> But I don't know an existing name for it
23:48:58 <nshepperd> there's also related type with instance Eq a => Monoid (I a) where mappend (Some a) (Some b) | if a == b then Some a else Top, which I would call 'The'
23:56:10 <jle`> it's maybe the monoid of Monoid m => Maybe (Maybe m) where mempty = liftA2 (<>) ?
23:56:21 <jle`> s/mempty/mappend
23:57:43 <jle`> if there was that newtype in base that gave all Applicative's monoid instances.  but it doesn't exist yet
23:59:56 <opqdonut> nshepperd: that's nice, so it's like Empty | The x¬†| ManyThings ?
