00:18:25 * hackagebot emailaddress 0.2.0.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.2.0.0 (cdepillabout)
00:47:58 <jmorris_> has anyone here done a raspberry pi project in haskell?
01:20:01 <ski> Rotaerk : light-weight variant types would be nice ..
01:21:08 <ski> Rotaerk : what about `forall e. (X1 -> e) -> (X2 -> e) -> (B -> e) -> (A -> e)', instead of your `forall e. (X1 -> e) -> (X2 -> e) -> (A -> Either e B)' ?
01:26:36 <alpha> I have a data type for an AST and I want to do some optimizations, what's the accepted way to describe tree transformations? 
01:28:17 <bollu> how do I start using "effects"?
01:28:32 <bollu> I've heard a lot about extensible effects and how they're an alternative to mtl
01:28:41 <bollu> but, like, where do I start from?
01:34:19 <alpha> Bollu: How long have you been here? I see your name in my chatlog from July!
01:36:20 <bollu> alpha: for the last two years I suppose
01:36:25 <bollu> alpha: or two and a half :)
01:36:51 <alpha> Neato :0 
01:48:30 * hackagebot simple-effects 0.6.0.1 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.6.0.1 (darwin226)
01:58:31 * hackagebot jsaddle 0.6.0.1 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.6.0.1 (HamishMackenzie)
01:59:49 <mrkgnao> what is the function of ask in the Reader monad?
02:00:08 <mrkgnao> I mean, what's the difference between doing f and ask >>= f?
02:00:20 <mrkgnao> (aside from one typechecking and the other not)
02:03:31 * hackagebot jsaddle-warp 0.6.0.1 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-warp-0.6.0.1 (HamishMackenzie)
02:05:57 <ski> mrkgnao : reading the environment ?
02:09:50 <nmattia> mrkgnao: the reason it typechecks is because f takes an extra argument, namely the "environment" as ski pointed out
02:10:19 <nmattia> on a different topic is it possible to use TypeApplications' '@' with other kinds than Type?
02:10:56 * ski 'd imagine so
02:12:44 <mrkgnao> ski: I'm trying to follow the types, actually
02:12:53 <mrkgnao> I know how to use it, but I don't think I really understand it
02:16:31 <mrkgnao> for the sake of argument ... how would I write ask >>= f without ask?
02:18:17 <nmattia> mrkgnao: the whole runReader "hello" (ask >>= f) can be written as f "hello"
02:18:54 <nmattia> but that's not really showcasing Reader's usefulness :p
02:19:36 <nmattia> mh, I'm missing a 'return' up there
02:21:52 <ski> mrkgnao : instead of `ask >>= f', you could write `f =<< ask', or `asks id >>= f', or `join (asks f)' .. but i suspect neither of these addresses what you're wondering about
02:23:08 <ski> (nmattia : rather `runReader (ask >>= f) "hello"' can be written as `runReader (f "hello") "hello"')
02:24:19 <ski> (hm, perhaps you meant `runReader (ask >>= return . f) "hello"', which can be written as `f "hello"' ?)
02:26:28 <ski> mrkgnao : anyway, the real answer to "how would I write ask >>= f without ask?" is that you wouldn't, in isolation, without abandoning your environment monad (`Reader r',`ReaderT r m',&c.)
02:27:07 <nmattia> ski: as I understand it mrkgnao wants an equivalent of ask >>= f
02:27:27 <ski> (fwiw, some specific uses of `ask', e.g. in conjunction with `local' and `const' as wespiser used them a few hours ago, could be omitted)
02:27:32 <nmattia> ski: and also, GHC doesn't like seem to like Symbol TypeApplication it seems :(
02:27:43 <ski> that's interesting
02:27:52 <ski> i assume they're working on it ?
02:28:03 <ski> (or planning to)
02:28:35 <nmattia> I really have to idea
02:28:43 <ski> nmattia : yes, i was addressing the equivalents of `ask >>= f' question
02:29:15 <nmattia> I assumed it'd come for free with TypeInType, but obviously I have no idea how things work behind the scenes
02:35:40 <Narfinger[m]> ok I have a weird bug, my application just doesn't start with this error: "signalProcess: permission denied (Operation not permitted)" and I have no idea how to debug this, I am not using singalProcess but spock
02:39:12 <ertesx> (perhaps the moral of the story is that Reader is really not that useful)
02:40:53 * ski would have responded with something similar if they had asked about `get >>= f'
02:41:38 <ertesx> nmattia: liftIO @ IO
02:41:48 <ertesx> nmattia: type application with (Type -> Type)
02:41:53 <alpha> Is there some way I can use Parsec with a datatype other than a String? 
02:42:10 <alpha> some generic type dealio 
02:42:32 <ertesx> alpha: parsec abstracts over the chunk type of the input stream
02:42:46 <ggVGc> nonsense, haskell programs don't have bugs
02:42:57 <ertesx> alpha: it supports ByteString, String and Text out of the box
02:43:29 <alpha> the reason I ask is because I'm meaning to write some tree transformations 
02:43:35 <nmattia> ertesx: interesting, maybe I just have a Type where I expect a Symbol
02:43:42 <ggVGc> ertesx: hm, I've always felt I should be using Reader but never actually do it
02:44:00 <ertesx> alpha: parsec only supports stream-like input
02:44:16 <ertesx> ggVGc: that's because you probably shouldn't
02:44:51 <ggVGc> I've always been confused about Reader, and questioned why I shouldn't just pass values
02:44:59 <ggVGc> or a value, rather
02:45:07 <ertesx> what does that mean?
02:45:12 <pikajude> how do I prevent the hoogle server from rendering links to files on my filesystem?
02:45:24 <pikajude> my browser doesn't allow file:// URLs
02:45:27 <alpha> the bits that I'm matching over are lists, but perhapse there's some better way to write tree transforms? 
02:45:36 <nmattia> ertesx: indeed!
02:45:38 <ggVGc> ertesx: well, if I need to carry some data to read from, why don't I just pass that value through at the value level?
02:47:32 <ertesx> ggVGc: Reader ≃ (->)  -- it literally just puts a Reader wrapper around (->), and the ((->) e) family of monads do exactly the same thing: pass the argument around implicitly
02:47:52 <ertesx> but even in the (->) case i have difficulty thinking of legitimate use cases that aren't about writing point-free code
02:48:04 <ertesx> > liftA2 (+) sin cos 15
02:48:07 <lambdabot>  -0.10940007270170449
02:48:29 <ertesx> > runReader (liftA2 (+) (ask sin) (ask cos)) 15
02:48:31 <lambdabot>  error:
02:48:31 <lambdabot>      • Couldn't match type ‘a0 -> a0’ with ‘ReaderT r0 Identity a’
02:48:31 <lambdabot>          arising from a functional dependency between:
02:48:34 <ertesx> > runReader (liftA2 (+) (asks sin) (asks cos)) 15
02:48:37 <lambdabot>  -0.10940007270170449
02:53:33 * hackagebot fbmessenger-api 0.1.2.1 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.2.1 (mseri)
02:54:18 * ski . o O ( `runReader . asks = id',`runReader . local f . asks = (. f)',`local id = id',`local (g . f) = local f . local g',`local f . asks = asks . (. f)' )
03:20:09 <Narfinger[m]> can I load all libraries my stack process needs into the repl? I need to debug an exception in a library
03:28:34 * hackagebot shunya-library 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/shunya-library-0.1.0.0 (penguinshunya)
03:37:33 <mrkgnao> Narfinger[m]: why not stack ghci?
03:38:19 <ski> mrkgnao : any further comment on the responses re `ask >>= f' above ?
03:38:26 <Narfinger[m]> that doesn't seem to give me the library errors
03:39:16 <mrkgnao> ski: I think I'm beginning to get the hang of it, although it'll take me a while to be at peace with it
03:39:25 <mrkgnao> really awesome of you to check in, though!
03:39:25 <Narfinger[m]> perhaps I need to compile with profiling support?
03:40:13 <ski> mrkgnao : but you read the subsequent comments above, yes ?
03:40:56 <ski> (slightly more than an hour ago)
03:46:06 <lwm> What's the right Cabal field to include directories needed for testing in an sdist?
03:48:35 * hackagebot shunya-library 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/shunya-library-0.1.0.1 (penguinshunya)
03:48:37 * hackagebot shunya-library 0.1.0.2 - Initial project template from stack  https://hackage.haskell.org/package/shunya-library-0.1.0.2 (penguinshunya)
03:53:35 * hackagebot ghcjs-dom-jsaddle 0.6.0.0 - DOM library that supports both GHCJS and GHC using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.6.0.0 (HamishMackenzie)
03:58:36 * hackagebot ghcjs-dom-jsffi 0.6.0.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.6.0.0 (HamishMackenzie)
03:58:38 * hackagebot ghcjs-dom 0.6.0.0 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.6.0.0 (HamishMackenzie)
04:18:17 <kuribas> does typing speed matter?  Do you write more haskell code when you type faster?
04:18:55 <chpatrick> kuribas: only if you think faster than you type
04:19:05 <dxtr> It's like speaking faster. You can fit more information in a smaller timeframe and/or make a dope rap song.
04:19:28 <chpatrick> haskell is pretty low on typing though
04:19:43 <chpatrick> it's one of the few languages where I really don't miss an IDE
04:20:05 <kuribas> That's true, but once my thoughts are clear, I want them out quickly.
04:20:24 <kuribas> Maybe it doesn't matter in terms of productivity...
04:20:41 <kuribas> chpatrick: I couldn't code without emacs.
04:21:18 <chpatrick> kuribas: I use sublime without any haskell plugins
04:21:25 <chpatrick> ghcid running in a different window
04:22:11 <kuribas> chpatrick: I like getting errors directly into my buffer as I type.
04:22:29 <kuribas> (Or turn it off with <f5>)
04:22:45 <kuribas> And indentation
04:22:58 <kuribas> and showing the types.
04:25:15 <kuribas> chpatrick: when I press f5 it highlights all the errors, which I can directly.  It safes a lot of time from goin through compile first.
04:25:30 <chpatrick> ghcid auto-compiles every time you save
04:27:42 <kuribas> chpatrick: but you still have to manually search for the error?
04:35:03 <kuribas> are there specific haskell IDEs that people use (not emacs)?
04:35:53 <ski> hm, Yi perhaps ?
04:36:45 <ski> also Peaker is working on Lambdu/Bottles, iirc
04:37:05 <ski> (maybe it was "Lamdu" ?)
04:39:51 <kuribas> There was leksay, does anyone use it?
04:40:47 <kuribas> leksah
04:43:14 <c821> how can i compare 2 bool without using == or /=?
04:43:32 <ski> pattern-matching
04:44:21 <c821> but the exercise said i need to use conditional expressions
04:44:30 <ski> (you could also use `(<)',`(<=)',`(>)',`(>=)',`compare',`&&',`||',`not' ..)
04:44:45 <kuribas> > False < True
04:44:47 <lambdabot>  True
04:44:49 <ski> or `if'-`then'-`else'
04:44:57 <c821> oh ok i'll try
04:44:59 <ski> guards
04:44:59 <c821> tks
04:45:02 <ski> lots of ways
04:45:13 <kuribas> id
04:45:30 <kuribas> > const True False
04:45:33 <lambdabot>  True
04:46:33 <c821> can i use another if within if?
04:47:01 <Rembane> Yes!
04:47:02 <kuribas> c821: use, use parens
04:47:39 <kuribas> c821: although you may be better of with guards in that case.
04:48:50 * ski doesn't see why brackets would be needed just to nest `if's
04:49:49 <c821> but i cant remove the else part right?
04:49:58 <c821> is it mandatory?
04:51:47 <ski> it is mandatory
04:53:25 <ski> (you should only need two `if'-`then'-`else's, to implement `(==)'/`(/=)', btw)
04:54:22 <c821> can u show me how to compare 2 bool using &&, ||, not?
04:55:58 <ski> well, you'd need to clarify what you mean exactly by "compare"
04:56:19 <haskell836> Hi, I can't find how to get the timeZone associated to my LocalTime with the time library
04:56:20 <ski> compare for equality or disequality ?
04:56:22 <haskell836> https://gist.github.com/anonymous/7a1ec4a33bf1aa9197519d01787e0b9c
04:56:24 <c821> when 2 bool are the same, it should return true
04:56:28 <ski> inequality (strict or lax ?) ?
04:56:29 <c821> else False
04:56:31 <haskell836> I exposed my problem on this gist
04:56:41 <c821> nothing complicated
04:56:52 <c821> i've just began to learn haskell for 1 week
04:57:22 <ski> well, one version is `equal b0 b1 = (b0 && b1) || (not b0 && not b1)'
04:57:56 <ski> `equal b0 b1' will be `True' when both `b0' and `b1' is `True', and also when both of them are `False'. otherwise it'll be `False'
04:58:32 <haskell836> Is it possible or am I missing a function that would resolve my need ?
04:59:06 <ski> just `if'-`then'-`else', without any further stuff than `True' and `False', should suffice
04:59:23 <ski> haskell836 : so, probably not
05:00:04 <ski> oh, sorry, for some reason i was confusing c821 with haskell836 for a moment there
05:00:23 <ski> (presumably because both nicks end with three digits ?)
05:00:33 <haskell836> ^^
05:00:56 <c821> thanks, it works
05:01:52 * ski doesn't know that much about `Data.Time'
05:04:01 <c821> if a function uses + and <, is Ord and Num enough?
05:05:07 <tdammers> :t (+)
05:05:09 <lambdabot> Num a => a -> a -> a
05:05:11 <tdammers> :t (<)
05:05:13 <lambdabot> Ord a => a -> a -> Bool
05:05:22 <tdammers> c821: does that answer your question?
05:05:53 <mathk> :t map $ curry (:)
05:05:54 <c821> ok thanks for the help!
05:05:55 <lambdabot> [a] -> [b -> [(a, b)] -> [(a, b)]]
05:06:21 <mathk> :t map $ uncurry (:)
05:06:23 <lambdabot> [(a, [a])] -> [[a]]
05:23:39 * hackagebot regex-do 2.5 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.5 (procione)
05:38:39 * hackagebot show-prettyprint 0.1.0.0 - Robust prettyprinter for output of auto-generated Show  instances  https://hackage.haskell.org/package/show-prettyprint-0.1.0.0 (quchen)
05:43:40 * hackagebot show-prettyprint 0.1.0.1 - Robust prettyprinter for output of auto-generated Show  instances  https://hackage.haskell.org/package/show-prettyprint-0.1.0.1 (quchen)
05:47:51 <delYsid> Is Parsecs user state equiv. to StateT UState Trifecta.Parser, or what exactly do I need to do to get the same (backtracking?) behaviour with a transformer stack?
05:51:01 <tdammers> IIRC parsec's user state is pretty much equivalent to StateT-over-Parser, except that it's baked into the Parsec monad itself
05:51:06 <tdammers> so there's less lifting
05:54:37 <delYsid> good.
06:00:17 <joncol> Is there a semigroup for Maybe where Nothing <> x ≡ x <> Nothing ≡ Nothing (for all x) ?
06:03:40 * hackagebot rattletrap 0.4.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.4.1 (fozworth)
06:13:26 <ongy> joncol: what would Just x <> Just y be?
06:14:08 <hexagoxel> i assume (<>) would be liftM2 (<>)
06:14:45 <pavonia> > Just [1,2,3] <> Just [4,5,6]
06:14:48 <lambdabot>  Just [1,2,3,4,5,6]
06:16:49 <hexagoxel> > Nothing <> Just [4,5,6]
06:16:52 <lambdabot>  Just [4,5,6]
06:17:18 <hexagoxel> > liftM2 (<>) Nothing (Just [4,5,6])
06:17:21 <lambdabot>  Nothing
06:21:37 <kuribas> seems Just x <> Just y == Just (x <> y)
06:22:09 <kuribas> > Just x <> Nothing
06:22:12 <lambdabot>  Just x
06:23:03 <kuribas> > Just x <> Just y
06:23:06 <lambdabot>  Just (x <> y)
06:23:10 <kuribas> neat
06:24:31 <kuribas> > let f = (+) in f x y
06:24:34 <lambdabot>  x + y
06:26:36 <ongy> > map f [x, y, z]
06:26:38 <lambdabot>  error:
06:26:39 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M137989511550...
06:26:39 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
06:27:05 <kuribas> > f x
06:27:06 <ongy> I thought that works. lambdabot has some 1char variable names sensibly defined, they have a Type to force it, but I don't remember
06:27:08 <lambdabot>  error:
06:27:09 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M590091449220...
06:27:09 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:27:45 <joncol> Yes, I think the Maybe monad solves my problems.
06:28:22 <joncol> Implementing ray/box intersection, slab algorithm proved much more difficult than I thought...
06:28:45 <joncol> Very imperative> https://tavianator.com/fast-branchless-raybounding-box-intersections-part-2-nans/
06:29:17 <joncol> A bit difficult to get nice in Haskell, I think.
06:29:50 <kuribas> joncol: you can use the ST monad, with mutable vectors if necessary.
06:30:09 <joncol> kuribas: Good idea... I haven't learned ST yet.
06:31:01 <joncol> But would the use of ST monad spread, so that everything that calls my intersection method then would need it too?
06:31:05 <kuribas> joncol: it's just a state monad, where the state is hidden from the outside world by a forall.
06:31:19 <kuribas> joncol: only the mutable part needs the ST
06:31:26 <joncol> kuribas: OK
06:32:08 <kuribas> The outside world sees a pure function.
06:32:37 <Tuplanolla> :t Data.Vector.Unboxed.create -- This is especially useful, joncol.
06:32:40 <lambdabot> Data.Vector.Unboxed.Base.Unbox a => (forall s. ST s (Data.Vector.Unboxed.Base.MVector s a)) -> Data.Vector.Unboxed.Base.Vector a
06:32:42 <juri_> -Weverything is fun.
06:33:12 <joncol> Tuplanolla: OK, I'll look into it
06:33:20 <juri_> I just got my library to compile with -Wall -Werror. ;)
06:34:14 <cocreature> joncol: it seems like you should be able to separate that algorithm into a map part that creates a vector of pairs (t1,t2) and then you can fold over that to find tmin/tmax
06:34:32 <cocreature> vector fusion should make sure, that the intermediate vector is never actually constructed
06:37:30 <joncol> cocreature: Aha, nice. I should start using Vectors then. Currently I was thinking on doing it with sconcat and Min/Max semigroups, but that would probably cause unnecessary intermediate evaluations..
06:46:52 <ertesx> CT question: is there a word for two objects that have monomorphisms in both directions?
06:47:27 <ertesx> (in Sets i would call them isomorphic, but that doesn't generalise)
06:55:49 <dgpratt> ertesx: I probably shouldn't be commenting on something I know so little about, but I thought isomorphisms were "a thing" in CT and my interpretation of this article seems to corroborate that: https://en.wikipedia.org/wiki/Isomorphism
06:56:14 <dgpratt> "A morphism f : X → Y in a category is an isomorphism if it admits a two-sided inverse"
06:56:27 <ertesx> dgpratt: yes, but isomorphisms are stronger than monomorphisms
06:56:41 <ertesx> in the category of sets they just happen to be equivalent
06:56:57 <dgpratt> ah
07:02:41 <kuribas> Do you use IO (Either String res) for signalling an error in reading a file, or exceptions?
07:04:10 <juri_> I get the feeling that -Weverything is going to be as much of a headache as -Wall was..
07:04:15 <ertesx> kuribas: usually exceptions
07:04:42 <juri_> a battle i must understand my way out of..
07:04:55 <ertesx> juri_: judging by the name…  that's…  i can see why
07:05:13 <cocreature> juri_: do we have -Weverything in haskell by now or are you writing c/c++?
07:05:23 <juri_> it's in haskell.
07:05:34 <cocreature> huh, I only knew of clang supporting that option
07:06:32 <ertesx> juri_: -W is a good compromise…  it warns about most important things like missing patterns and unused variables without getting too annoying
07:06:39 <ongy> what's -Weverything? is it better than -Wextra?
07:06:57 <juri_> It took me two years to understand enough haskell to remove all of the warnings on ImplicitCAD. here's hoping -Weverything is shorter. ;)
07:13:51 <hpc> i want to know when -Wall got renamed
07:13:55 <joncol> -quit
07:16:10 <Rotaerk> ski, hmm interesting idea (the light-weight variant types you mentioned 6 hours ago)
07:18:30 <Rotaerk> reminds me a bit of this:  http://www.haskellforall.com/2016/04/data-is-code.html
07:18:48 <lwm> I have spent 2 hours trying to figure out how to copy a directory into an sdist with Cabal
07:19:13 <lwm> Has anyone got a clue which field it is to copy those over? :|
07:22:12 <hvr> lwm: http://cabal.readthedocs.io/en/latest/developing-packages.html?highlight=extra-source-files#pkg-field-extra-source-files
07:22:37 <hvr> lwm: that's if you *only* need it included in the sdist
07:23:01 <hvr> lwm: look also at the fields near that section of the user guide
07:26:07 <lwm> hvr, thanks but that doesn't allow me to do recursive copy of a directory, on files, right?
07:26:14 <lwm> only files*
07:26:53 <hvr> lwm: that's true; there's plans to allow a recursive ** glob, but for existing .cabal files you'll have to generate that section if you need it recursive
07:27:15 <hvr> lwm: i.e. have a script that updates the extra-source-files directive
07:27:32 <hvr> the problem is also, that you have to make sure not to include garbage
07:27:40 <hvr> like *~ or other temp-files
07:28:06 <lwm> hvr: Oh I see. Have you seen anyone use `Distribution.Simple.postSDist` for copying files?
07:28:06 <hvr> that's why blind recursive inclusion isn't implemented yet
07:28:21 <hvr> lwm: no, but it's totally doable
07:28:50 <lwm> hvr: ok, thanks for the help!
07:29:00 <hvr> personally I'd go with modifying/generating the .cabal file though, as using Setup.hs has its own problems
07:37:41 <lwm> Hmmm ... do you have any examples of a modifying/generating script?
07:54:22 <ania123> can one correct whether following sentence is ok:
07:54:24 <ania123> to the best of our knowledge, no one else ever tried to implement such a procedure on SQL language. But, there is no strong reason not to do so.
07:56:54 <systemfault> ania123: "on" could be "using the"
07:57:22 <systemfault> "But" could be "However" or "Nonetheless" or even "Yet"
07:59:54 <ania123> thx
08:00:51 <ania123> We choose SQL for two reasons: first reason... "after discription of first reason finishs, should I from paragraph ?"
08:00:57 <ania123> systemfault?
08:02:34 <systemfault> I'll be honest with you...  I cannot understand that.
08:05:58 <ertesx> ania123: regarding your first sentence: is there *any* reason not to implement the procedure?
08:07:08 <ania123> ertesx: there is no
08:07:17 <ertesx> then the word "strong" is just a buzzword – scratch it
08:10:02 <ertesx> in fact the whole expression feels like useless filler:  to my knowledge nobody has ever written an image viewer that inverts images by default, but there is no reason not to write one
08:10:29 <ertesx> the former part may be useful in context, but the latter…
08:11:04 <ania123> Thus, having such a procedure already available inside the database will give us better performance, we believe.
08:11:09 <ania123> is it correct?
08:11:28 <ertesx> regarding the rest, please /join ##English
08:12:29 <ania123> ertesx: this is last sentenc eplease :)
08:13:45 * hackagebot shunya-library 0.1.0.3 - Initial project template from stack  https://hackage.haskell.org/package/shunya-library-0.1.0.3 (penguinshunya)
08:18:46 * hackagebot shunya-library 0.1.0.4 - Initial project template from stack  https://hackage.haskell.org/package/shunya-library-0.1.0.4 (penguinshunya)
08:18:47 * hackagebot shunyalib 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/shunyalib-0.1.0.0 (penguinshunya)
08:21:22 <ddk> hello all
08:21:34 <Schoolmeister> hi
08:22:24 <breadmonster> Hey guys.
08:22:59 <ddk> i have to implement a text editor using haskell .... but i have not used any user interface.. can anyone suggest me one tui which i could get in 1 or 2 day and complete my project
08:23:03 <fr33domlover> is it just me, or did the rise of stack bring lots of hackage releases with the default useless project synopsis / description
08:23:43 <fr33domlover> come on, at least go over your .cabal file before you release
08:23:46 * hackagebot shunyalib 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/shunyalib-0.1.0.1 (penguinshunya)
08:24:00 <sm> fr33domlover: no, we always had those :)
08:24:37 <sm> and the missing readme & changelog. It has improved a bit though
08:24:40 <fr33domlover> ddk, try nano
08:25:58 <ddk> fr33domlover : nano ~~Q  I got the name of hscurses
08:27:08 <osfameron> ddk: or implement `ed`, and then you won't even need a ui library!
08:27:11 <ddk> fr33domlover : whether I would be able to do whole sorts of thing with nano
08:27:35 <fr33domlover> ddk, do you want a library or an existing editor
08:27:58 <fr33domlover> if you want a lib, also try vty and brick
08:28:20 <fr33domlover> if you want an editor to clone, try nano
08:28:22 <ddk> fr33domlover : actually i have to develop a toy editor as a project ... and i prefer using haskell
08:28:50 <ddk> osfameron : what is ed
08:29:31 <mauke> ed is the standard editor.
08:29:43 <ddk> fr33domlover : actually i am taking vim as a model to implement some of its part
08:30:15 <ddk> mauke : ohh I have heard of sed !!
08:30:24 <sm> +1 for brick. You could also look at yi
08:30:55 <sm> but check out brick's editor widget example
08:31:04 <osfameron> brick looks interesting
08:31:24 <ddk> sm : what is brick , i have seen yi but that is too big and I couldn't understand it's code also
08:32:01 <grantwu> ed is not sed
08:32:43 <Clint> true
08:32:50 <ddk> grantwu : ya ... just sounds same !!
08:33:31 <Rotaerk> I like the keyboard controls for vim, and the modal control model, but I've decided I don't like how vim is so heavy on the configuration, and I prefer tools that are simple and composable
08:34:34 <Rotaerk> as in, if you want some altered behavior, you don't go digging through some documentation about configuration, you go look for, or create, something that integrates with it to give the desired behavior
08:34:39 <xT1ger> Hi, can anyone tell me, why ghci won't take this signature: "laenge' :: (Ord a, Num b) => b -> [a] -> [[a][a][b]] -> int -> b"?
08:34:40 <Rotaerk> not sure how that would work with an editor though
08:35:12 <ertesx> ddk: if you want to get it done, use a GUI toolkit…  drop a text box there and a menu here, perhaps a toolbar, implement loading and saving, and you're basically done
08:35:17 <xT1ger> it gives me this error:" Expecting two fewer arguments to ‘[a]’      Expected kind ‘* -> * -> *’, but ‘[a]’ has kind ‘*’"
08:35:18 <ddk> so someone please suggest me one of tui library ...that i should use for my text editor ... which would be simple and well documented
08:35:23 <Rotaerk> xT1ger, [[a][a][b]] doesn't make sense
08:35:29 <xT1ger> why?
08:35:31 <Rotaerk> what do you intend by that?
08:35:34 <ertesx> ddk: but to answer your question: i'd most likely use vty together with reflex
08:35:54 <ertesx> vty is pretty raw though, so you will have to implement most things yourself
08:36:21 <xT1ger> Rotaerk: I have to implement a travelling salesman problem, this is my cheap substitiute for a graph
08:36:26 <wayne> xT1ger: perhaps you can consider a tuple
08:36:36 <hexagoxel> i have a reflex interface for brick
08:36:55 <wayne> what do you mean by [[a][a][b]]?
08:37:01 <wayne> what are you trying to represent
08:37:16 <ddk> ertesx : actually i want to do it for know only because i am working on some other major project ... this is just a side one and i have to submit it on monday
08:37:17 <xT1ger> wayne: [from][to][cost]
08:37:41 <hexagoxel> but i was not granted permission to merge it upstream :/
08:37:53 <Rotaerk> xT1ger, are you wanting a list where every element within the list contains three values, a from, a to, and a cost?
08:38:03 <wayne> [(a, a, b)] may be closer o what you want
08:38:08 <xT1ger> Rotaerk: yes
08:38:14 <Rotaerk> yea, what wayne said
08:38:17 <osfameron> ddk: do you mean something by "tui" specifically?  e.g. as opposed to "ui"?
08:38:28 <Rotaerk> [[a][a][b]] is syntactical nonsense :P
08:38:51 <wayne> yeah, lists can only be for one type
08:38:53 <ddk> osfameron : no ...
08:38:58 <ertesx> ddk: if you insist on TUI, vty-ui is currently the most complete framework in haskell…  but in that case i would use reactive-banana rather than reflex
08:38:59 <wayne> and that type can be a tuple
08:39:08 <xT1ger> wayne, oh,ok
08:39:12 <osfameron> ah, "t" for "Text"?
08:39:18 <Clint> ertesx: s/vty-ui/brick/
08:39:26 <ertesx> i'm aware of brick
08:39:31 <ddk> ertesx : which would be easier tui or gui ~~Q
08:39:33 <hexagoxel> (i also have a reactive-banana version of a brick interface)
08:40:55 <hexagoxel> i found the difference between reactive-banana and reflex fairly small, really
08:40:58 <ertesx> ddk: not sure…  the effort is about the same, unless you need to build on windows
08:41:49 <ddk> ertesx : i have to do it for linux ... but want it to be portable ..
08:42:02 <ertesx> hexagoxel: huh?  the difference is pretty large in terms of framework development…  reactive-banana takes control and lets you register handlers, while in reflex you have to come up with a main loop and corresponding state
08:42:24 <ertesx> (the FRP interfaces are similar though)
08:42:34 <ertesx> ddk: good luck =)
08:42:44 <hexagoxel> ertesx: true, you need reflex-host, too.
08:43:04 <ertesx> ddk: vty is not portable, so none of the vty-based frameworks will work on windows, including brick and vty-ui
08:43:25 <osfameron> is portability an important thing in a project you're trying to deliver in *2 days*?
08:43:32 <ertesx> ddk: and most GUI toolkits are a nightmare to build on windows
08:43:47 * hackagebot nix-eval 0.3.3.0 - Evaluate Haskell expressions using Nix to get packages  https://hackage.haskell.org/package/nix-eval-0.3.3.0 (chriswarbo)
08:44:07 <ertesx> ddk: there was one framework recently that strived to be easy to build everywhere, but i forgot its name
08:44:11 <ddk> osfameron : not actually ... !!
08:44:13 <hexagoxel> ertesx: and i'll fully admit that reflex-host is not properly advertised from reflex; any non-web use-cases of reflex are sparely documented
08:44:41 <osfameron> ddk: great!  reduce the scope as much as you can if you've got limited time
08:45:44 <osfameron> ddk: then it sounds like you should have a look at brick, play with it for an hour, see if you can get your head round it and it'll do what you want to do
08:45:47 <ddk> ertesk : ok , lets forget for portablity right now ... which would help me to do the job faster ...and easier as i have to pass the course , Gui or Tui
08:46:52 <ertesx> ddk: BTW, i'm being unfair…  i'm suggesting to use an FRP framework at the same time, two days may be too short to learn FRP =)
08:46:55 <ertesx> with that in mind i recommend brick, too
08:46:56 <buglebudabey> i just successfully installed hstats with stack but my project still can't find the module Math.Statistics?
08:46:58 <osfameron> (and, if "faster" is the criterion, is "doing it in Haskell" still a requirement -- for example if you know a GUI framework in $some_other_language)
08:47:21 <ongy> buglebudabey: is it saying something about a hidden package?
08:47:38 <buglebudabey> ongy nope, just could not find the module
08:47:49 <ddk> osfameron : is brick ok from your point , no actually I don't know any other language !!
08:48:47 <geekosaur> buglebudabey, make sure it's listed in your cabal file as a dependency or stack will hide it
08:48:52 <osfameron> ddk: I've not used it myself.  But it seems to have documentation and example programs (see https://github.com/jtdaugherty/brick/blob/master/docs/guide.rst ) and looks like it's probably sane and powerful enough.
08:49:08 <buglebudabey> geekosaur this isn't a stack project yet, simply a file i'm trying to run
08:50:01 <ddk> ertesk : these days i am learning new things ... i wanted to learn FRP but due to time constraints ... I delayed it ... well please suggest me finally what should i do now ..~Q
08:51:40 <srk> ertesx: frp framework recommendations? for network programming e.g.
08:52:24 <geekosaur> buglebudabey, still true then, but may need extra stuff. (this is the flip side of stack not having so many package conflicts...) there is a global stack.yaml, or for a script you may need --package flags to tell it what to expose
08:52:34 <ertesx> srk: i generally recommend reflex, if you're in control and need event push
08:52:56 <ertesx> srk: if you need 60 FPS and a highly dynamic scene, i recommend wires
08:53:05 <ertesx> srk: in all other cases i recommend reactive-banana
08:53:29 <geekosaur> https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter but the package stuff also applied to standalone programs
08:53:45 <srk> ertesx: cool thanks
08:54:03 <ddk> ertesx : please suggest me ... what should I do now 
08:54:34 <srk> hexagoxel: where's your frped brick? :) sounds cool
08:54:45 <buglebudabey> geekosaur as a test all i put was http://lpaste.net/338136 and still getting nothing
08:54:53 <ertesx> ddk: start learning brick
08:55:16 <buglebudabey> geekosaur ill check out what you sent
08:55:38 <ddk> ertesx : brick is tui ...would developping gui would be easier ~~Q
08:56:50 <ertesx> ddk: usually i would say yes, but i assume you have no FRP experience, and without that brick is the most functional framework i know
08:57:54 <felko> how can I generalize a Float or a Double to a Num a => a ?
08:58:05 <ddk> ertesx : thanks a lot .... now i am going for brick !!
08:58:18 <felko> like one would do with fromInteger or fromIntegral for Int and Integer
08:58:28 <ongy> :t floor
08:58:31 <lambdabot> (RealFrac a, Integral b) => a -> b
08:58:39 <ertesx> felko: you need to give up precision, because Num only guarantees integers
08:59:16 <ertesx> :t fromInteger . round
08:59:18 <lambdabot> (RealFrac a, Num c) => a -> c
08:59:27 <felko> ertesx: ok, thanks a lot
08:59:53 <hexagoxel> srk: https://github.com/lspitzner/brick/blob/master/src/Brick/MainReflex.hs
08:59:53 <felko> any reasons Num is designed like this ? historical reasons ?
09:00:39 <geekosaur> strict typing and "just pretend every number is of every type always" are contradictory
09:00:51 <hexagoxel> srk: the reactive-banana interface is in that fork as well
09:00:53 <geekosaur> an exception is made for numeric literals only
09:01:06 <srk> hexagoxel: nice, thanks
09:01:18 <felko> geekosaur: ok, thanks
09:01:47 <hexagoxel> srk: there are even a few example applications :)
09:01:49 <ertesx> felko: also Num is the most generic numeric class, so naturally it makes the fewest assumptions
09:02:09 <srk> hexagoxel: awesome \o/ 
09:02:15 <ertesx> "fewest"…  is that a word?
09:02:26 <geekosaur> yes
09:02:39 <geekosaur> haskell never does implicit conversion. there are limited ways to fake it using typeclasses, but you can get into trouble fairly quickly that way.
09:03:14 <felko> but here's the problem i'm trying to solve: I have a data X = A Int | B Float, and a class IsX a where fromX :: X -> a; toX :: a -> X
09:03:30 <felko> I'd like to implement IsX for Int and Float
09:03:48 <ertesx> felko: are fromX and toX supposed to be inverses of each other?
09:03:48 <felko> but then, I can't use polymorphic constraints such as Num a => a
09:03:55 <felko> ertesx: yes
09:04:06 <ertesx> felko: then you can't implement it for Int
09:04:25 <felko> oops there's a mistake
09:04:42 <felko> fromX :: X -> Maybe a
09:04:51 <felko> because I also have non numeric types
09:05:27 <ertesx> now you basically have a dynamically typed number type X
09:06:04 <ertesx> if you want to write functions in terms of Num *and* use X with those functions, you need to write a Num instance for X
09:06:14 <Tuplanolla> This sounds like a use case for prisms to me, felko.
09:06:39 <felko> ertesx: yeah but X does not only contain numeric types, there are also strings and stuff
09:06:50 <mmachenry> Does anyone know the nature of this linkage error? I'm on Mac OS building a project using hslua. I have luabind installed. http://lpaste.net/338112
09:06:55 <felko> Tuplanolla: i don't know about prims, i'll check it out, thanks
09:07:17 <ertesx> felko: then X is not a Num
09:07:36 <ertesx> (even if it were purely numeric, it would be a questionable Num, but regardless)
09:07:46 <Tuplanolla> They're like lenses, but instead of products you have sums.
09:08:27 <geekosaur> mmachenry, usually that means something you linked against has a module that is not exported, but is required for linking, and is not listed in other-modules
09:08:54 <felko> ertesx: let me precise my use case: I'm trying to implement a toy stack-based VM in which I can pop value from the stack
09:09:10 <felko> the VM is contained into a failable monad (with Except)
09:09:44 <felko> and I'm trying to implement a function pop :: VM a
09:09:48 <geekosaur> likely package name "dirty", names Item.loadItemTemplate1, Item.TangibleItem2 among others defined in the missing module
09:09:58 <ertesx> felko: the stack contains values of type X?
09:10:31 <felko> ertesx: yes but thats why I did a fromX function, to turn it into a a
09:10:46 <felko> so that the user can do pop :: VM Int if they want an Int, and fail if the top of the stack is not an int
09:10:46 <ertesx> felko: you could just use Data.Dynamic
09:11:00 <ertesx> pop :: (Typeable a) => VM a
09:11:15 <ertesx> (pop :: VM a) is not possible
09:11:34 <felko> oops, i meant IsX a => VM a
09:11:46 <felko> pop :: IsX a => VM a
09:12:15 <ertesx> ok, then what's the problem?
09:13:38 <felko> if i'm trying to do someting like (+) <$> pop <*> pop, since there is no instance for Num a => IsX a, this does not compile
09:14:10 <ertesx> felko: that's not the reason it doesn't compile
09:14:15 <monochrom> But you don't need "a". You just need "Int".
09:14:22 <ertesx> the reason is that GHC doesn't want to read your mind =)
09:14:40 <ertesx> try:  (+) <$> pop <*> pop :: VM Int
09:16:38 <mmachenry> geekosaur: Oh.. hm…
09:19:18 <felko> ertesx: this compiles, but if I have two floats at the top of the stack, it won't work
09:19:27 <breadmonster> Hello.
09:19:34 <ertesx> felko: of course
09:20:14 <ertesx> felko: however, you can make it work, if you want dynamic conversion, too
09:20:24 <mmachenry> geekosaur: I think that was it. Thank you. do you know why I should need to mark all of my modules as exposed in my cabal file even if they are not imported by my executable ?
09:20:50 <geekosaur> you don't. you *do* have to list them somewhere in the cabal file though, specifically other-modules:
09:20:54 <felko> can i manually tell GHC what I want by explicitly writing (+) for every combination of Xs ?
09:20:56 <ertesx> felko: in the (IsX Float) instance you can do this: fromX (A x) = fromIntegral x
09:21:13 <wayne> 171803 < geekosaur> you don't. you *do* have to list them somewhere in the cabal file though, 
09:21:16 <wayne> oops
09:21:21 <wayne> keyboard messed up
09:21:32 <ertesx> felko: yes, you can, but you also need to tell it the same for (-) and (*) and 'negate' and 'abs' and …
09:21:35 <wayne> i was going to ask instead, is there a page that lists reflex used in production environments?
09:22:01 <felko> ertesx: yup, but your dynamic conversion seems cleaner
09:22:02 <ertesx> felko: the way to do that is to write a Num instance for X, which of course doesn't make sense, if X can hold a String or other non-numeric stuff
09:28:07 <Skogar> Hi, do thaw and freeze have some copying overhead?
09:28:21 <Skogar> I mean, can I thaw and freeze back often?
09:28:52 <elfeck> for my program, I have a large set of parameters which are required for almost every function. How can I avoid passing around a huge set of parameters?
09:29:25 <geekosaur> Reader or ReaderT
09:29:45 <Skogar> elfeck: you can bundle your parameters in a Data type
09:30:52 <elfeck> Skogar: Hm I really would like avoid passing them around. Can I utilize the State Monad somehow to just "have them available"?
09:31:48 <geekosaur> elfeck, Reader is literally a hidden parameter
09:31:58 <geekosaur> @unmtl Reader r a
09:31:58 <lambdabot> r -> a
09:31:58 <Skogar> elfeck: as geokosaur said, the Reader monad allows to read some configuration anywhere in the computation
09:32:21 <ertesx> Skogar: from the vector library?  they have by definition, but they may be optimised away in some cases
09:32:27 <geekosaur> which is to say, any function of type ... -> Reader r a is actually a function ... -> r -> a
09:32:51 <Skogar> ertesx: I am looking at Data.Array
09:32:54 <elfeck> I see. Is there a performance difference between using reader and passing them?
09:33:05 <geekosaur> nope
09:33:19 <ertesx> Skogar: in that case i would expect there to be a definite overhead
09:33:40 <elfeck> geekosaur: okay I'll look into it, thanks
09:33:42 <geekosaur> it is *actually* a function as I described. Only the typechecker knows differently, and that only at compile time.
09:34:28 <geekosaur> mind, depending on how you combine your parameters into the "r", *that* could cause overhead --- but a flat record would not, usually.
09:34:37 <ertesx> Skogar: if you want to create an array from an ST action without copying, you can use runST(U)Array
09:35:11 <elfeck> geekosaur: can you given an example where it has overhead?
09:35:42 <elfeck> right now I need to have a Vector Int and a bunch of Ints as environment
09:36:29 <geekosaur> the most obvious is using an IORef, which you would need to do if values can be changed by callbacks. multiple level records can also cause overhead sometimes. most simple uses won't, though
09:37:02 <elfeck> okay. My pure values will never change 
09:38:51 <geekosaur> if you really care, it's possible to inspect the intermediate code generated by the compiler (post-typechecking, so the Reader has already been converted to an actual function type). it's not especially common for this to be a problem though unless you need really high throughput, and even in that case there are usually other things that matter more
09:39:15 <geekosaur> (you may have noticed the other discussion between ertesx and Skogar mentioning performance, but they're doing rather more than just a Reader)
09:39:38 <elfeck> geekosaur: okay
09:40:38 <khairulimam> oop guy trying some functional, am i welcomed?
09:40:59 <geekosaur> like, they're talking Arrays, and (immutable, especially) arrays are something of a screw case for any garbage collector and this has both space and performance implications
09:41:04 <geekosaur> khairulimam, sure
09:41:12 <xT1ger> Another question: Why does this (http://pastebin.com/N7Xn0Xcs) give me a not in scope error for "cost"?
09:41:34 <geekosaur> at least, we will welcome you. the difference between the way FP type systems work and OO type systems work is often less welcoming
09:42:07 <geekosaur> xT1ger, `where` scopes over guards, not equations
09:42:13 <Tuplanolla> We have outsourced shouting at you to the compiler.
09:42:17 <geekosaur> cost is only defined for the second one
09:42:21 <Skogar> ertesx: another take, is there a kind of ST that can read from an STUArray but not write to it?
09:42:47 <khairulimam> alright,. i'm exciting!!
09:42:51 <Skogar> ertesx: I'm afraid I would have to build one :(
09:45:07 <Claudius1aximus> Skogar: you could pass to your sub action  a partially applied read action  :: Index -> ST s Value  instead of the array itself, perhaps
09:45:23 <xT1ger> geekosaur: thanks. Is there a more elgant solution than to write the where bit twice(under every equation once)?
09:46:03 <geekosaur> you can rewrite it to use a guard (number patterns are something  of a hack anyway)
09:46:56 <geekosaur> laenge' currentLength route graph it | it == 0 = ... | otherwise = ... where ...
09:47:35 <geekosaur> (the compiler is actually doing that anyway, at some level)
09:48:04 <Skogar> ertesx: ClaudiusMaximus: staying in ST seems best, thanks for your help
09:50:04 <monochrom> geekosaur: Haha, "the people love you but the compiler hates you" :)
09:50:38 <geekosaur> show me a language where that's *not* true :p
09:56:38 <ertesx> FWIW there is an "ST that can only read from an array, but not write to it":  it's called (U)Array (or immutable vectors)
09:57:09 <xT1ger> geekosaur: thank you so much, dind't think of that for the last 2 hours... (facepalm)
09:57:43 <juliagoda>  curry (\ (x,y) -> 2*x+y)
09:57:49 <juliagoda> sorry
09:57:56 <juliagoda> wrong place
09:58:06 <juliagoda> ;D
10:18:30 <rafal1> How are you losers today ?
10:19:46 <suppi> is there something like the boxes package that uses Text instead?
10:19:56 <Welkin> hi suppi 
10:20:02 <suppi> hi Welkin 
10:20:11 <Welkin> I didn't know you were so involved with purescript these days
10:20:34 <suppi> what made you say that? :)
10:21:10 <Welkin> I was looking at some purescript information and somone mentioned you as a person to follow in the community
10:21:24 <suppi> really? :o
10:21:57 <suppi> well, i do think it's a great language and all
10:23:33 <sm> suppi: tabular has multiple renderers, you could add one for Text
10:24:06 <sm> you probably meant "that I don't have to write", I know :)
10:24:22 <suppi> sm, thanks anyway. i'll take a look :)
10:25:05 <Welkin> suppi: I see an IsString typeclass in the boxes package
10:25:37 <suppi> oh, not sure that's what i had in mind sm :)
10:25:51 <Welkin> lol dfeuer!
10:25:53 <Welkin> file:///home/dfeuer/GHC/7.8.3.bin/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:IsString
10:25:56 <Welkin> fix your links!
10:26:14 <monochrom> haha
10:26:58 <sm> oh different is it. I can't figure out these clever libs without screenshots
10:27:09 <sm> s/can't/don't/
10:27:21 <suppi> lol
10:27:23 <ski> Rotaerk : hm, though that does Church-encoding, which wasn't what i had in mind
10:27:51 <suppi> Welkin: i guess that'll be enough. thanks
10:59:31 <kosc> Hello. Why when I'm using stack for installing any haskell package, it always ends with "Populating index cache ...Killed"?
11:04:14 <monochrom> maybe not enough memory
11:04:14 <Schoolmeister> https://github.com/commercialhaskell/stack/issues/1335
11:04:18 <Schoolmeister> maybe this can help you
11:04:28 <Schoolmeister> yeah, that's what the post pretty much says
11:04:43 <monochrom> oh heh, 128MB is not enough for everyone
11:06:56 <Tuplanolla> He left already.
11:07:22 <Schoolmeister> Oh
11:07:34 <Schoolmeister> That's just being impatient
11:09:05 <grantwu> Hrm...
11:09:56 <grantwu> > let test = Just undefined; case test of Just bar -> 3; Nothing -> 5
11:10:00 <sm> irc client ... also Killed
11:10:01 <lambdabot>  <hint>:1:68: error:
11:10:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:10:12 <grantwu> grmbl
11:12:00 <grantwu> @let test = Just undefined
11:12:02 <lambdabot>  Defined.
11:12:13 <grantwu> > case test of Just bar -> 3
11:12:16 <lambdabot>  3
11:12:23 <grantwu> > case test of Just bar -> undefined
11:12:26 <lambdabot>  *Exception: Prelude.undefined
11:12:31 <grantwu> er, no, that's not what I wanted
11:12:36 <grantwu> > case test of Just bar -> bar
11:12:39 <lambdabot>  *Exception: Prelude.undefined
11:12:51 <grantwu> So pattern matching something evaluates it to WHNF?
11:13:03 <Tuplanolla> You can make pattern matching lazy with `~`.
11:13:52 * hackagebot EntrezHTTP 1.0.3 - Libary to interface with the NCBI Entrez REST service.  https://hackage.haskell.org/package/EntrezHTTP-1.0.3 (FlorianEggenhofer)
11:14:10 <Tuplanolla> However that's not the problem here.
11:14:30 <grantwu> That's okay.  I just wanted to make sure bar didn't get evaluated.
11:14:33 <grantwu> (unless needed)
11:15:36 <monochrom> what you meant to test is: case Just undefined of Just _ -> 3
11:15:53 <felko> sorry I'm still on my VM problem, is there a polymorphic numeric type in which Integrals and Fractionals can be converted ? (Int, Float, Double, ...)
11:16:10 <monochrom> oh, you did that already
11:18:42 <felko> like, i'm looking for a function f and a type T that can turn Ints, Floats, Doubles, etc... into T a => a
11:20:29 <Tuplanolla> Why not `Fractional`, felko?
11:21:00 <felko> Tuplanolla: can Ints be turned into Fractional a => a ?
11:21:37 <Tuplanolla> :t fromIntegral (42 :: Int) :: Fractional a => a
11:21:39 <lambdabot> Fractional a => a
11:24:11 <pavonia> Tuplanolla: And how to turn a Double into that?
11:25:05 <prototrout> :t toRational
11:25:07 <lambdabot> Real a => a -> Rational
11:25:26 <younder> Isn't it better to convert fractions to normal form ( divide numerator and denominator by their GCD) and convert to int if possible?
11:25:40 <Tuplanolla> :t fromRational (toRational (4.2 :: Double)) :: Fractional a => a
11:25:43 <lambdabot> Fractional a => a
11:25:56 <felko> pavonia: maybe fromRational . toRational
11:26:03 <felko> but I hav to add a Real constraint then
11:26:07 <felko> *have
11:26:45 <prototrout> if a Real constraint is OK there's realToFrac
11:27:14 <Tuplanolla> I have to say treating integers and floating-point numbers the same way seems like a bad idea.
11:27:22 <Tuplanolla> They have very little in common.
11:27:36 <felko> can I use just Real instead of Fractional Tuplanolla ?
11:27:58 <Tuplanolla> You can do anything. There's also `Floating`.
11:29:11 <younder> A froation point number can be seen as a tupele (num, eps) where eps is the epsion region for unceirtanty. Ideally for each float computation you should enter a required eps and te function fails if it can't compute it to withing that region.
11:29:34 <younder> s/floating/fraotion/
11:36:39 <felko> why can't I declare a Real a => FromValue a instance without UndecidableInstances ?
11:37:26 <felko> i recently switched my GHC version, and before that I could declare that instance perfectly fine
11:38:46 <felko> I now have GHC version 7.6.3
11:46:10 <monochrom> I don't trust the part about "previous versions allowed it".
11:46:36 <felko> or future versions, I think I had 8.0.1 before
11:46:38 <monochrom> "instance X a => Y a" is rightfully an undecidable instance.
11:47:11 <felko> yes I understand now, after checking the docs
11:47:24 <monochrom> The meaning of that kind of instance headers is a common misconception (or common disappointment) for beginners.
11:49:33 <felko> my understanding of the type system is still fragile
11:51:55 <felko> now GHC is complaining about instance Real a => FromValue a overlapping with instance FromValue Value, whereas Value has no Real instance
11:52:04 <monochrom> Err, no, I am mixing up two factors. It could be decidable.
11:53:29 <felko> how ?
11:53:36 <int-e> felko: the constraints (like the Real a => there) are ignored by ghc when selecting instances.
11:53:55 <felko> int-e: why ?
11:55:25 <int-e> felko: basically it's so that the type inference does not have to do any backtracking, I believe.
11:55:52 <felko> why would it be problematic to do backtracking ?
11:56:09 <int-e> because that often causes an exponential blowup.
11:56:12 <nshepperd1> Also so that the behaviour of your program doesn't depend on what instances are in scope
11:56:14 <grantwu> KABOOM
11:56:32 <felko> ok
11:57:13 <felko> thanks, but how can I do what I want then ?
11:57:42 <nshepperd1> Although overlapping instances already takes away that property i guess
11:58:32 <int-e> Maybe IncoherentInstances (which try to select the most specific instance) will achieve what you want... but usually I would prefer to not have an instance like Real a => FromValue a at all, but rather some newtype (say newtype RealValue a = RealValue a) and an instance for that (Real a => FromValue (RealValue a)
12:00:02 <Maaarcocr> Hi! I'm trying to port some functionalities of Intero to Visual Studio Code (it's a project with my Uni) and I am mainly interested in the :complete-at functionality. What I don't understand is how I could make it works with a file that is being typed. In order to use the :complete-at function I first need to load the file, but if the file is being typed it may not be successfully loaded. How can I solve this? I am sorry if this is
12:03:17 <mmachenry> I'm getting an error regarding two mismatched copies of the same library but I'm building with Stack. I'm confused. Isn't protecting against this error the entire point of stack?
12:03:51 <geekosaur> Maaarcocr, -fdefer-type-errors or -fdefer-all-errors
12:04:46 <ski> Maaarcocr : suspected cut off near ".. How can I solve this? I am sorry if this is"
12:06:49 <xcmw> Is there a good data structure which is like a map but the keys are static and the values type can be different? The same key must be able to be used on multiple different maps.
12:07:00 <sm> mmachenry: let's have a look-see
12:08:52 <Liskni_si> mmachenry: yes but if you let stack use system ghc and system libraries, this can happen
12:09:24 <monochrom> xcmw: My radical idea is "data X a b c = MkX {key1 :: a, key2 :: b, key3 :: c}" so I don't have keys I have fields.
12:09:40 <Liskni_si> mmachenry: basically every time I let apt-get upgrade any libghc-*-dev stuff, I have to wipe ~/.stack/snapshots, just to be sure
12:11:36 <xcmw> monochrom: I attemped that. I can't remeber why it failed. I will look.
12:12:05 <mmachenry> Liskni_si: Ah, interesting. So, should I delete that directory? It's grabbing a different version of attoparsec for me
12:13:45 <geekosaur> mmachenry, the global package db basically can't be controlled
12:13:49 <Liskni_si> mmachenry: Depends on how much you want to understand the problem. :-) If not much, just delete it and rebuild. But if you didn't upgrade any system packages, it's probably a different issue and you might not want to delete anything yet.
12:14:23 <geekosaur> you are best off not putting anything in the global package db, and not letting e.g. system package managers put anything there except as direct dependencies of ghc itself
12:14:44 <mmachenry> Liskni_si: Well, I just started using Stack and this is happening on my first usage. I haven't upgraded anything.
12:14:59 <Liskni_si> mmachenry: Then that is definitely a different issue!
12:15:09 <geekosaur> unless you already had a system ghc from somewhere
12:15:26 <xcmw> monochrom: I ended up with http://lpaste.net/314646. Could not get the type system to understand what I was trying to do.
12:15:47 <geekosaur> if you had nothing haskell related installed and let stack install ghc for you, then this can't be a problem
12:15:51 <Liskni_si> geekosaur: I'm not sure I can agree with you. Stack could remember what package versions it used from the global db and rebuild things if that db changes.
12:15:59 <mmachenry> Liskni_si: Damn. Well it might still be that I let it use system stuff though, right?
12:16:02 <geekosaur> (unless you install something with stack exec ghc, in which case you deserve what you got)
12:16:32 <geekosaur> Liskni_si, the point of stack is it tries to precisely control what ghc sees --- because ghc will pick things according to its own ruls if it can see them
12:16:44 <geekosaur> it will happily pick conflicting package versions if you let it
12:17:09 <geekosaur> and if you put anything that isn't a ghc bootlib in the global db, you have given ghc license to screw up
12:18:17 <Liskni_si> yeah but assuming that one would install ghc from distro but not any additional packages is isomorphic to sticking fingers in your ears and screaming lalala
12:18:52 <geekosaur> which is why I said [12 20:15:25] <geekosaur> if you had nothing haskell related installed and let stack install ghc for you, then this can't be a problem
12:18:55 * hackagebot BlastHTTP 1.2.1 - Libary to interface with the NCBI blast REST interface  https://hackage.haskell.org/package/BlastHTTP-1.2.1 (FlorianEggenhofer)
12:19:01 <Liskni_si> if stack pretends to support reusing distro ghc, then it should at least try to cope with the common usage patterns :-)
12:19:17 <geekosaur> fine, you go patch ghc to not do this
12:20:31 <geekosaur> stack's only leverage in controlling ghc is in controlling what package dbs it can see. you can't hide the global package db because it has the runtime and base in it. your options for hiding anything else in it are limited at best
12:21:04 <geekosaur> you either let stack install and manage ghc --- which is what stack strongly recommends --- or you risk this kind of problem
12:21:13 <Liskni_si> oh, I thought stack knows what was built against what
12:21:49 <Liskni_si> I mean, against which packages, not package dbs
12:21:56 <geekosaur> it does to some extent. but it can only rebuild things it controls, not stuff in external package databases
12:22:16 <athan> Is there a way to format NominalDiffTime into something like Hours, etc?
12:22:31 <Liskni_si> yeah, but I haven't had things break in external package databases, just the things stack built on top of that
12:22:58 <Liskni_si> if it just rebuild it, I wouldn't have run into any problems at all, I think :-)
12:23:23 <mmachenry> Would uninstalling that package help?
12:23:37 <geekosaur> if it's in the global db, yes.
12:24:01 <Welkin> or just use nix and never have to compile anyting again
12:24:09 <Welkin> just download cached binaries
12:24:10 <monochrom> xcmw: I don't know lens.
12:24:11 <geekosaur> if it's in stack only, you may have found a stack bug (or possibly you have specified something impossible in stack.yaml, but even that is arguably a bug if it didn't detect it and slap you)
12:24:15 <mmachenry> It is I think. Is it possible to remove a package from that easily?
12:24:41 <mmachenry> No it's in the global db
12:24:51 <geekosaur> then you want to remove the global db copy
12:25:02 <xcmw> monochrom: If you get get it to work with a just a getter function that would be good enough
12:25:30 <mmachenry> geekosaur: Is there a cleaner way than rm ~/.cabal ?
12:25:35 <geekosaur> xcmw, I think you can't use lenses with existential that way. there are special lens wrappers for your use case (ALens, AGetter, ... iirc)
12:25:44 <geekosaur> that is not the global db
12:25:47 <geekosaur> it's not even the db
12:25:53 <Welkin> lol
12:26:01 <Welkin> ghc-pkg delete
12:26:03 <Welkin> or remove
12:26:05 <Welkin> or whatever
12:26:14 <Welkin> I just use nix these days though
12:26:16 <xcmw> geekosaur: Ok thanks. I have never heard of those.
12:26:17 <Welkin> previously used stack
12:26:30 <geekosaur> ~/.cabal/lib is storage for stuff installed in the *user* package db. stack hides this completely, it relaces it with its own package db (because ghc allows that)
12:26:39 <geekosaur> the user package db is ~/.ghc
12:27:12 <geekosaur> it should be irrelevant if using stack, because stack manages its own user package db and makes ghc use that
12:27:31 <geekosaur> the global package db will be, for a ghc from a package manager, be /usr/lib/something
12:27:44 <geekosaur> or possibly /usr/local/lib
12:27:45 <ski> (geekosaur : existential ?)
12:28:03 <geekosaur> ski, forall ... Lens ...
12:28:11 <ski> rank-2 ?
12:28:18 <geekosaur> yeh
12:28:26 <ski> (or higher, possibly)
12:28:55 * hackagebot reduce-equations 0.1.1.0 - Simplify a set of equations by removing redundancies  https://hackage.haskell.org/package/reduce-equations-0.1.1.0 (chriswarbo)
12:29:41 <boxscape> quick question: is it a good idea to just derive Show on every type, or rather, is there any reason why you shouldn't do it?
12:30:05 <boxscape> i.e. should I remove it if after I'm done debugging if I don't need it?
12:30:11 <ski> you probably don't want to do it for an abstract data type
12:30:27 <ski> also, in some cases, `Show' can't be derived
12:30:35 <boxscape> I see
12:30:43 <boxscape> yeah, that makes sense
12:30:46 <geekosaur> boxscape, it doesn't cost anything if you aren't using it; the only real question is whether you can derive Show at all
12:30:54 <boxscape> ok, thanks guys
12:31:23 <ski> (also, sometimes when using record syntax, i don't want that to weight down the `Show', so i manually type what i'd otherwise get)
12:32:07 <boxscape> yeah, records can get annoying
12:32:16 <ski> in case you have multiple representations of the same ideal value, then you probably don't want `Show' to be able to differentiate between them
12:32:51 <ski> (that's for quotient types, which is one of the uses of abstract data types)
12:34:33 <ski> (btw, if you manually make a `Show' instance, then you usually want to define `showsPrec' (not `show' or `shows'), by using `showParen',`showChar',`showString',`showsPrec',`shows',..)
12:34:45 <boxscape> oh, interesting
12:35:37 <Tuplanolla> We should totally have an automatically derivable read-show system and a different pretty printing system.
12:36:45 <boxscape> would it be correct to say that using showsPrec essentially means you're using a difference list?
12:37:08 <ski> in the FP sense of it, yes
12:37:18 <ski> @src ShowS
12:37:18 <lambdabot> type ShowS = String -> String
12:37:37 <ski> (in LP, "difference list" means something different, but related)
12:37:44 <boxscape> okay
12:43:55 * hackagebot RNAlien 1.2.6 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.2.6 (FlorianEggenhofer)
12:45:47 <JonReed> Hi, what is the proper way to convert one numeric type into another and throw if it overflows
12:45:57 <JonReed> fromIntegral will silently overflow
12:52:07 <monochrom> you probably have to do your own range test first
12:55:16 <JonReed> :( ok. It's strange that there is no supplied function for this, I can't be the first one needing this.
12:55:17 <hexagoxel> can anyone think of a "common" type constructor with kind (* -> *) -> *  ?
12:55:24 <dmj`> monochrom: {-# LANGUAGE ExtendedDefaultRules, OverloadedStrings #-} with default (MyString) works really well, except it shows a lot of warnings with -Wall on string literals. Otherwise, super convenient.
12:55:43 <monochrom> neat
12:56:20 <Tuplanolla> :t Fix -- hexagoxel
12:56:22 <lambdabot> error:
12:56:22 <lambdabot>     • Data constructor not in scope: Fix
12:56:22 <lambdabot>     • Perhaps you meant one of these:
12:56:31 <Tuplanolla> :t Data.Fix.Fix
12:56:33 <lambdabot> error:
12:56:33 <lambdabot>     Not in scope: data constructor ‘Data.Fix.Fix’
12:56:33 <lambdabot>     No module named ‘Data.Fix’ is imported.
12:56:37 <monochrom> although, you may like "default (Integer, Double, MyString)" so you don't lose defaulting to Integer and/or Double when it comes to Num :)
12:57:04 <Tuplanolla> It's common for me at least.
12:57:29 <xT1ger> So i need help again: This is my Code: http://pastebin.com/raw/51TiusgJ When compiling it throws this: http://pastebin.com/raw/J6gmmsF2
12:57:31 <monochrom> I am not sure :t is informative, even if lambdabot had Fix.
12:57:47 <Welkin> oh hi dmj` 
12:57:58 <xT1ger> According to what i did on ppaper the types should match, so i don't understand what went wrong here.
12:58:01 <hexagoxel> Tuplanolla: right, common enough; thanks!
12:58:03 <Tuplanolla> Perhaps `:k` would work better indeed, monochrom.
12:58:28 <Welkin> dmj`: what do you use for the frontend again? ghcjs?
12:58:33 <dmj`> Welkin: yea
12:58:54 <ski> @kind Mu
12:58:56 <lambdabot> (* -> *) -> *
12:59:09 <Welkin> dmj`: mind joining #haskell-offtopic ?
12:59:13 <dmj`> Welkin: single project, one cabal file, 2 compilers get run on it. 
13:00:13 <Tuplanolla> Where's that from, ski?
13:03:07 <Tuplanolla> At least `recursion-schemes` has it.
13:03:24 <ski> i suppose it's from one of the imports at
13:03:28 <ski> @where L.hs
13:03:28 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
13:03:33 <ski> not sure which, though
13:05:42 <jophish> how long should I as a package author be expected to support ghc 7.10.3 in your opinion?
13:06:17 <monochrom> my opinion: until 8.2
13:08:56 * hackagebot hackport 0.5.1 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.5.1 (SergeiTrofimovich)
13:09:20 <younder> I see cabal upgrade is disabled. That must mean that you can't update all dependencies and keep the library in a consistent state.
13:10:15 * younder feels a headache comin on ..
13:10:58 <monochrom> no, cabal upgrade was the cause of inconsistency, not the cure
13:11:15 <monochrom> the cure is scorched earth policy
13:11:39 <geekosaur> well, arguably the cure is a local-policy "stackage"
13:12:00 <Welkin> what about nix? :O
13:12:14 <geekosaur> where the only way to upgrade dependencies and yet maintain consistency is all at once (cabal reinstall World vs. switching stack resolvers)
13:12:28 <younder> monochrom, Yes complete reintsall. I got that.
13:12:36 <younder> reinstall
13:13:14 <geekosaur> Welkin, nix arguably punts that issue to the maintainers upstream
13:13:32 <geekosaur> and they *do* have problems with the result; go look at their bug tracker
13:13:33 <younder> Hence the necessity to keep backwards compliance for packages.
13:13:53 <younder> I'll keep that in mind.
13:14:07 <Tuplanolla> The user guide needs a section called Coming to Terms with Unpleasant Realities.
13:14:41 <monochrom> That may become true soon. It already has "Feeding and Care of the User Guide"
13:15:22 <geekosaur> (nix is still trying to come to terms with how to deal with security updates, for example)
13:15:25 <KNO1> any DnD nerds in here? 
13:15:25 <KNO1> lol
13:15:40 <tdammers> cabal upgrade was a pipe dream
13:15:52 <geekosaur> not sure about DnD per se, but there's a somewhat scary overlap between #haskell and ##crawl :p
13:16:22 <KNO1> haha geekosaur 
13:16:42 <younder> Well even for ubuntu upgrade is a bit like russian roulette. I do a compete reinstall every to years or so.
13:17:09 <tdammers> that's because ubuntu is a bit shitty that way though
13:17:20 <ertesx> younder: something like stackage in terms of nix is possible, and in fact nixpkgs used to keep up with their LTS sets
13:17:34 <jophish> geekosaur: replace runtime dependencies?
13:17:35 <ertesx> i don't think anyone is maintaining something like that right now
13:18:08 <ertesx> personally i would just freeze package sets and try to upgrade all-or-nothing most of the time
13:18:31 <ertesx> if you really need a particular upgrade without changing anything else, you can override individual packages
13:18:38 <geekosaur> actually OS distributors do have to deal with the same problems, on an even larger scale because they have to deal with not just haskell's issues but c's (and how gnome highlights them), c++'s (and how kde highlights them), etc.
13:19:21 <geekosaur> the tools available to snapshot distros like fedora and debian/ubuntu are different from those available to rolling release (arch/gentoo) but the core problems are the same
13:20:52 <geekosaur> also, the way they present differs --- and clever tooling like nix sometimes brings with it bigger problems, like https://github.com/NixOS/nixpkgs/pull/10851
13:21:15 <geekosaur> "the more they overthink the plumbing..."
13:22:44 <monochrom> the more the plumbing becomes a lot of OpenWRT routers. Also check out "software defined networks". :)
13:24:07 <monochrom> when one day the plumbing becomes sentient, pipe dreams become true, literally :)
13:24:40 <younder> monochrom, I thought Unix was buildt on pipe dreams ;)
13:26:26 <xcmw> I was unable to figure out how to use a ALens to solve my problem. http://lpaste.net/338354 is an example of it working but it requires lots of boilerplate code and boxing and unboxing of all values.
13:27:49 <nmattia> mh... is it possible to create a Symbol from a String using TH? something like String -> Q Type?
13:29:42 <geekosaur> younder, pipes and dreams, rarely combined though :p
13:29:42 <nmattia> there's something here, though I'm struggling to understand what 'stype' actually does: https://www.reddit.com/r/haskell/comments/3wtwx3/typelevel_show_type_family_tshow_k_symbol/
13:30:12 <delYsid> What does the ~ mean in pattern matches like ~(a, w) -> ...?
13:30:31 <Tuplanolla> It's lazy, delYsid.
13:30:43 <ski> delayed pattern match
13:30:47 <Tuplanolla> Pass in `undefined` without using the variables to see.
13:30:54 <nmattia> delYsid: opposite of !(a,w) -> ...
13:31:01 <hexagoxel> nmattia: reify . mkName has the right type.
13:31:09 <ski> > case undefined of (_,_) -> ()
13:31:12 <delYsid> isn't lazy the default?
13:31:12 <lambdabot>  *Exception: Prelude.undefined
13:31:13 <ski> > case undefined of ~(_,_) -> ()
13:31:16 <lambdabot>  ()
13:31:26 <jle`> delYsid: control goes straight into the branch w/out checking if that's the actual constructor
13:31:27 <geekosaur> delYsid, lazy is not the default for pattern matches
13:31:28 <nmattia> hexagoxel: there are a few things that have the right type, however it's unclear to me what they actually do
13:31:39 <jle`> delYsid: it's kind of like the wildcard, _
13:31:45 <jle`> it matches on that branch "no matter what"
13:31:46 <nmattia> what does reify do?
13:31:52 <ski> delYsid : it's the default in `where' and `let', but not in `case' and "to the left of `='"
13:31:58 <geekosaur> (well, it is in let-s, but not top level definitions or case (which top levels desugar to)
13:32:10 <jle`> delYsid: normally, case foo of Just _ -> ..., Nothing -> ..., would pick which branch to go down by chekcing the constructor
13:32:18 <ski> delYsid : the match is delayed until a variable bound by it is forced
13:32:25 <geekosaur> and ! is not quite the opposite; ! actually pushes evaluation one level deeper
13:32:30 <jle`> but case foo of ~(Just _) -> ..., Nothing -> ..., it'l go down the firt branch no matter what
13:33:08 <jle`> case foo of ~(Just _) -> ...; is pretty much the same as case foo of _ -> ... 
13:33:21 <jle`> it doesn't check if Just is really hte constructor or not before committing on that branch
13:33:42 <delYsid> ski: "the match is delayed until a variable bound by it is forced", that made a click here.  So it is for when you only have one match, and want to have that work lazily
13:34:08 <jle`> case foo of ~(Just x) -> ...; is kind of the same as case foo of jx -> let Just x = jx in ...
13:34:35 <ski> delYsid : or for when you know that it'll be of a certain shape, but you don't want to actually force the match yet (for performance reasons, or for reasons of avoiding an infinite loop, possibly when tying-the-knot)
13:34:39 <ski> @src partition
13:34:40 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
13:34:40 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
13:34:40 <lambdabot>                               | otherwise = (ts, x:fs)
13:35:01 <ski> > (take 4 *** take 4) (partition even [0 ..])
13:35:04 <lambdabot>  ([0,2,4,6],[1,3,5,7])
13:35:25 <jle`> delYsid: note that while it might seem like (,) is the "only" constructor for (a,b), and so a lazy pattern match wouldn't make a difference ... there are actually other possible constructors for a value of type (a,b)
13:35:35 <jle`> notably, 'undefined', like we mentioned earlier
13:35:44 <ski> @let partition' p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x = (x:ts,fs) | otherwise = (ts,x:fs)
13:35:47 <lambdabot>  Defined.
13:35:49 <ski> > (take 4 *** take 4) (partition' even [0 ..])
13:35:52 <athan> jle`: Isn't that partial, though?
13:35:52 <lambdabot>  (*Exception: stack overflow
13:35:58 <athan> Or do you have lambda-cases for that :s
13:35:59 <nmattia> hah! I managed: LitT . StrTyLit
13:36:05 <jle`> if you *actually* match on (x,y), GHC has to actually evaluate enough of the tuple to know that the (,) constructor *was* used
13:36:08 <jle`> and not something silly like undefined
13:36:09 <ski> delYsid : without the `~' in `partition', it'll fail on infinite list
13:36:25 <jle`> athan: what is partial?
13:36:27 <ski> JagaJaga : well, it's not a constructor
13:36:35 <hexagoxel> nmattia: ah, that does something completely different from reify :D
13:36:41 <ski> er
13:36:46 <ski> jle` ^
13:36:49 <JagaJaga> :)
13:36:50 <jle`> (,) is not a constructor?
13:37:03 <ski> `undefined' is not a constructor
13:37:10 <athan> Sorry, ~(Just x) -> ...
13:37:20 <athan> :s
13:37:21 <delYsid> OK, and while we are at it, another construct I frequently see but have absolutely no intution for is class Foo a b | b -> a  What does the | do here?
13:37:24 <jle`> ah yeah.  i guess i should mean, there are values of type (a,b) that aren't created using the (,) constructor
13:37:29 <nmattia> hexagoxel: yeah there was some type mismatch there, it gave me an 'Info' instead of a 'Type'
13:37:32 <ski> delYsid : functional dependency
13:37:57 <jle`> so GHC has to evaluate enough of the value to know for sure that it's definitely one of the values that was created by the (,) constructor, and not one of the ones that wasn't
13:38:02 <delYsid> so extension world?
13:38:23 <hexagoxel> nmattia: if you had wanted to extract type information about symbols in scope, you could have gotten it out of the Info.
13:38:29 <jle`> athan: it matches on everything, but if you try to use 'x' and it was 'Nothing', then you'll get a runtime error
13:38:37 <ski> delYsid : it means `forall b. unique a. Foo a b', which means `forall b a0 a1. (Foo a0 b,Foo a1 b) => a0 = a1', iow there can at most be one `a' having an instance `Foo a b', for any given `b'
13:38:57 * hackagebot vector-sized 0.4.0.1 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.4.0.1 (jophish)
13:38:58 <athan> jle`: oh! sorry, I forgot what ~ meant. Thanks :) I remember now
13:39:00 <jle`> > case (if even (sum [1..]) then (1,2) else undefined) of (x,y) -> x + y
13:39:07 <Tuplanolla> > case Nothing of ~(Just x) -> True; Nothing -> False
13:39:08 <lambdabot>  mueval-core: Time limit exceeded
13:39:09 <lambdabot>  mueval: ExitFailure 1
13:39:13 <lambdabot>  True
13:39:32 <nmattia> hexagoxel: oh I see. So it gives you info about something that exists already, rather than creating a new type
13:39:32 <jle`> ^ in that case, even figuring out if `if even (sum [1..]) then (1,2) else undefined` was created using the (,) construcor or not takes an infinite amount of time
13:39:33 <ski> delYsid : the direct practical use of it (as opposed to the conceptual, modelling use of it) is that it reduces ambiguity, when you use methods from the class
13:39:49 <jle`> > case (if even (sum [1..]) then (1,2) else undefined) of ~(x,y) -> "hi"
13:39:52 <lambdabot>  "hi"
13:39:55 <jle`> > case (if even (sum [1..]) then (1,2) else undefined) of (x,y) -> "hi"
13:39:56 <mmachenry> If I already had Haskell Platform installed and cabal installed a lot of global packages and then installed Stack and want to use stack, what should I do? Is there a guide for this? Should I uninstall global ghc so Stack can install it?
13:40:02 <lambdabot>  mueval-core: Time limit exceeded
13:40:03 <lambdabot>  mueval: ExitFailure 1
13:40:14 <mmachenry> I'm getting global vs stack package conflicts and I need to resolve them.
13:40:23 <dmj`> mmachenry: yea, you can just nuke the haskell platform
13:41:02 <mmachenry> On a Mac I guess that means brew uninstall haskell-platform roughtly. Perhaps destroy ~/.cabal and ~/.ghc as well?
13:41:07 <dmj`> mmachenry: if you do 'ghc-pkg list', does it show two package directories?
13:41:36 <ski> delYsid : ok ?
13:41:41 <ahri> hi, i was wondering why elemIndex has the signature "elemIndex :: Eq a => a -> [a] -> Maybe Int"; given that a list can presumably be infinitely large, shouldn't it return Integer?
13:41:55 <mmachenry> dmj'	It does
13:42:12 <Welkin> ahri: no, because the element may not exist
13:42:14 <dmj`> mmachenry: is there an uninstaller that comes with HP?
13:42:20 <ski> delYsid : are you perhaps familiar with functional dependencies in normalization of relations in the relational data model ?
13:42:27 <Welkin> there is an uninstaller for hp
13:42:28 <mmachenry> dmj`: No clue
13:42:35 <jle`> ahri: 'length' returns Int, too
13:42:36 <hexagoxel> nmattia: yes, although i think the output of LitT . StrTyLit is only as new as its input
13:42:42 <ahri> Welkin: sorry, i meant Maybe Integer, rather than Maybe Int
13:42:47 <Welkin> haskell-platform-uninstall or something
13:43:01 <jle`> ahri: well, if your list is longer than machine Int...
13:43:15 <jle`> ahri: reaching the element would probably be a bigger problem
13:43:29 <jle`> elemIndex is probably not going to work whether or not you use Integer/Int
13:43:36 <ski> i think `elemIndex' is normally used on a list you intend to use again later ?
13:43:59 <jle`> > maxBound :: Int
13:44:02 <lambdabot>  9223372036854775807
13:44:29 <ski> (if you don't use it later, it can be GC:ed as you go, as so doesn't all have to fit in memory at the same time)
13:44:50 <dmj`> mmachenry: If you're starting from scratch, yea probably nuke what's in ~/.cabal, ~/.ghc and you might have to delete /usr/local/bin/ghc*
13:44:57 <Welkin> ahri: because lists are indexed by Int, not Integer
13:45:12 <Welkin> :t (!)
13:45:14 <ahri> Welkin: ah, that makes more sense then
13:45:14 <lambdabot> Ix i => Array i e -> i -> e
13:45:16 <Welkin> :t (!!)
13:45:18 <lambdabot> [a] -> Int -> a
13:45:56 <ski> @type genericIndex
13:45:58 <lambdabot> Integral i => [a] -> i -> a
13:45:59 <ahri> thank you for explaining :)
13:47:00 <mmachenry> Is there a setting in Stack to say not to use anything global?
13:47:26 <geekosaur> no, nor can there be
13:47:42 <xcmw> Is there a simpler way to write http://lpaste.net/338354? Perferably without boxing and unboxing.
13:47:47 <geekosaur> the runtime is only in global. no you can't install a separate one because it has to exactly match the compiler
13:47:53 <hexagoxel> stack should not ever be using anything "global" in an observable manner
13:48:23 <geekosaur> hexagoxel, once again, you try telling ghc that
13:48:58 <ahri> to my recent irritation it definitely uses /usr/bin/ld ;)
13:48:59 <geekosaur> but, I think I'm done since everyone absolutely knows that what happens, cannot possibly be
13:49:37 <hexagoxel> i said "should not", not "does not"
13:49:39 <mmachenry> How do I use ghci for just do quick experiments, using it as a calculator, or scripting if I don't have a global ghci anymore. Is there a mode with stack for programming without a project that has a Setup.hs, directory structure, LICENSE file, etc?
13:50:01 <ahri> mmachenry: can't you just do "stack ghci" ?
13:50:04 <geekosaur> mmachenry, it uses a "global stack.yaml" somewhere under ~/.stack-work
13:50:05 <MarcelineVQ> stack ghci or stack exec ghci should work fine
13:50:37 <geekosaur> this still does not change that ghc will use anything it finds in its global package database, and the only way to give stack control over that is to only ever use a ghc that stack itself has installed and controls
13:50:47 <mmachenry> Do people using Stack like this have a copy of the same version of ghc installed once for every project they have on their system?
13:51:07 <geekosaur> mmachenry, it caches ghcs like it caches packages
13:51:33 <mmachenry> Okay so it's not a different install every time. 
13:52:28 <geekosaur> if it has installed the ghc, it can expose that ghc to every project and it can control what that ghc's global db looks like. it cannot do this to OS or externally installed ghcs
13:53:07 <mmachenry> I see. That makes sense. 
14:05:05 <linduxed> hey guys
14:05:14 <linduxed> is there something like the inverse of this: https://hackage.haskell.org/package/friendly-time-0.4/docs/Data-Time-Format-Human.html
14:05:31 <linduxed> i want to be able to write "in two weeks" and get a date back
14:09:32 <nmattia> nmattia: sorry I can't help but thanks for sharing friendly-time
14:09:40 <nmattia> linduxed: ^^
14:09:48 <linduxed> haha
14:09:50 <linduxed> np
14:10:17 <linduxed> essentially this: https://github.com/mojombo/chronic
14:11:43 <linduxed> oooh
14:11:47 <linduxed> found this: https://github.com/mavenraven/chronic-haskell
14:12:20 <Welkin> O.o
14:12:31 <Welkin> is that a druggie haskell library?
14:14:12 <Tuplanolla> Can it handle "later"?
14:31:47 <linduxed> dunno, haven't looked into it much
14:32:42 <dmj`> Welkin: ping
14:35:22 <mmachenry> I'm confused about Stack's inability to find my module. This is my .cabal file. My library file cannot fine Data.Conduit.Network.Server, which is clearly listed as an exported module. https://github.com/mmachenry/server-conduit/blob/master/server-conduit.cabal
14:35:54 <mmachenry> Furthermore this was working with the same .cabal file earlier tonight before I uninstalled my global ghc to make stack work better.
14:38:53 <Welkin> mmachenry: you probably deleted it from your global cache
14:39:10 <Welkin> reinstall it using stack install
14:40:50 <MarcelineVQ> they define the module in their project Welkin it's not an external dependency. also stack install is for copying excutables
14:43:51 <MarcelineVQ> hmm, I can only imagine it's some sort of path issue mmachenry, your git project builds for me with stack build
14:44:04 <mmachenry> @WelkinYes that worked. Does stack need to install even the libraries that I have local to a project? Is the typical compile command to stack build, then stack install, then stack runghc my main to test it?
14:44:05 <lambdabot> Unknown command, try @list
14:44:47 <mmachenry> MarcelineVQ: That's troubling that it builds for you more easily than it builds for me. I needed to stack install server-conduit like Welkin suggested.
14:45:05 <mmachenry> MarcelineVQ: can you stack runghc app/Main.hs ?
14:45:24 <mmachenry> Or does that require you to do a stack install?
14:45:59 <juri_> mmachenry: o/
14:46:03 <geekosaur> I am recalling thatthere are some cases stack gets wrong and certain environment changes confuse it, requiring you to nuke part of ~/.stack-work
14:46:16 <geekosaur> (these are necessarily bugs, but hard to track down and fix)
14:46:37 <mmachenry> juri_: hi
14:46:40 <MarcelineVQ> hmm, well, what exactly are you trying to do? stack install is just stack build, and then it copies executables to .loca/bin if there are any
14:47:22 <mmachenry> MarcelineVQ: Just getting the hang of running my program with stack. I ultimately want to run app/Main.hs
14:48:25 <MarcelineVQ> to run something like that during development I'd put: stack build --exec server-conduit-exe
15:03:40 <n_blownapart> hi more questions re: ide-haskell for atom. I got everything working on a debian machine including the mouse-over feature! but , on osX , with stack I installed the binary dependencies: ghc-mod , ghc-modi and hlint -- and the editor doesn't like it. I get a big fat error message. any help ? thanks
15:04:08 <wespiser> use debian?
15:04:33 <wespiser> sorry, but I have a macbook and I just remote into a ubuntu server!
15:08:28 <Welkin> wasn't there someone else in here recently having trouble with ghc-mod and atom?
15:08:42 <Welkin> no one here uses atom as far as I know
15:09:01 <MarcelineVQ> I use atom but I don't use osx
15:09:17 <Welkin> I don't even use ghc-mod
15:09:30 <lgstate> language without tco forces me to write recursive funcs as loops
15:09:31 <lgstate> ick
15:10:38 <MarcelineVQ> the most common issue I've run into with ghc-mod is when the lts resolver of your .stack/global-project/stack.yaml (or whichever you used to build ghc-mod) doesn't match your project's stack.yaml
15:10:51 <ski> lgstate : it should not be an optimization, it should be a language requirement
15:11:06 <n_blownapart> Welkin: thanks it was I. on debian. now my travails are with osX where I work. MarcelineVQ
15:11:24 <ski> (on the asymptotic space behaviour, not on details of the operational semantics)
15:11:27 <lgstate> ski: indeed, loops provide so much oportunity to write bugs
15:12:40 <n_blownapart> I just ran $ stack upgrade --install-ghc . its busy now
15:13:28 <mmachenry>  MarcelineVQ is that the typical command people use to run an executable project? I haven't seen that in tutorials. 
15:14:22 <MarcelineVQ> typically you'd run `stack build` and then `stack exec myprojects-exe` but I don't like to repeat myself :>
15:14:37 <Welkin> lol
15:15:19 <Welkin> when I build my hakyll projects I use `~/.local/bin/projectname clean && stack clean && stack install && ~/.local/bin/projectname watch`
15:15:32 <Welkin> and can't forget about `cabal clean && cabal configure && cabal build`
15:15:42 <MarcelineVQ> clean can matter too so that's a good idea as well
15:16:53 <n_blownapart> dang, my scheme environment is a 1000 times easier : DrRacket . I've spent hours trying to set up atom, not that I'm complaining or repeating myself.
15:19:02 <Tuplanolla> My Forth environment is even easier.
15:19:08 <MarcelineVQ> :>
15:19:36 <Welkin> forget about atom
15:19:41 <Welkin> just use emacs
15:20:13 <MarcelineVQ> that's good advice. Personally emacs is overwhelming, but it's still good advice
15:20:22 <jmcarthur> I've been using spacemacs, the haskell layer, intero. It's great.
15:20:34 <MarcelineVQ> these days I use `stack exec atom` to run atom so it can find things in context
15:20:35 <david__> is it possible to convert an "Either a Void" to an "Either a b" without unsafeCoerce
15:20:48 <n_blownapart> jmcarthur: is spacemacs a separate entity or extension of emacs?
15:21:16 <jmcarthur> n_blownapart: It's a bunch of configs for Emacs.
15:21:18 <Welkin> it is eamcs with lots of things installed
15:21:22 <Welkin> emacs*
15:21:23 <ski> david__ : `fmap' ?
15:21:25 <Welkin> some people don't like it
15:21:32 <Welkin> I'm fine with regular emacs
15:21:37 <david__> fmap absurd?
15:21:42 <ski> yes
15:21:59 <david__> that will incur a runtime cost, no? (just clarifying, but thank you for answering)
15:22:03 <ski> it'll probably copy the `Left'
15:22:26 <david__> is it also safe to use unsafeCoerce, then?
15:22:30 <n_blownapart> there is a uc Berkeley professor famous for scheme, Dr. Hilfiger who swears by emacs for the few people who still study scheme.
15:22:36 <jmcarthur> It would be cool if there was a Coercible instance for Void.
15:22:51 <ski> david__ : i'd ask #ghc, perhaps
15:23:30 <MarcelineVQ> well emacs is configured by a dialect of lisp iirc, so that's pretty reasonable
15:23:34 * ski . o O ( Edwin )
15:24:17 <Welkin> you don't need to know elisp
15:24:20 <Welkin> I just copy-paste
15:24:39 <jgt> anyone used Scalpel for scraping?
15:24:43 * ski . o O ( Guilemacs )
15:25:38 <jmcarthur> I have a lot of problems with Emacs, but it's the only thing that does what it does.
15:25:48 <Welkin> it is extremely stable
15:26:00 <Welkin> it has a huge ecosystem and community
15:26:14 <Welkin> it has pretty much everything you could ever think of wanting
15:26:37 <jmcarthur> Clearly the right thing to do is make a new Emacs in Haskell.
15:27:47 <n_blownapart> Welkin: MarcelineVQ  very kind of you, if I could continue with soft questions: I'm trying to learn math and programming together. a friend said *learn haskell* and forget scheme. I got through the first half of math-heavy chapter 1 of the sicp book. still haven't a clue. should I go for haskell and this curry isomorphism / category theory business ?
15:28:20 <Welkin> n_blownapart: that is a misunderstanding people have about haskell
15:28:20 <Tuplanolla> Both are good in different ways, n_blownapart.
15:28:23 * ski would suggest learning both
15:28:24 <MarcelineVQ> If you have time I'd learn both
15:28:26 <Welkin> you don't need to know anything about category theory
15:28:43 <Welkin> or anything theoretical
15:28:51 <Welkin> it's just a programming language
15:28:57 <n_blownapart> ski et al. I heard learning both together would be *hell*
15:29:06 <ski> perhaps
15:29:10 <Tuplanolla> Haskell's metaprogramming story is quite miserable in comparison to that of Scheme, n_blownapart.
15:29:26 <n_blownapart> please elaborate Tuplanolla
15:29:27 <ab9rf> only insofar is that it's hard to learn two completely unfamiliar things at the same time
15:29:45 * ski . o O ( MetaML/MetaOCaml )
15:31:06 <n_blownapart> ab9rf: true its unfamiliar to me though I enjoy seeing math running in code. any comments on the bloody sicp book? 
15:31:21 <Tuplanolla> In Scheme all programs are built of what happen to also be its most central data types, n_blownapart. You also have the interpreter at your disposal at all times.
15:31:42 <jmcarthur> The "only" problem with template haskell is that Haskell syntax is nowhere near as convenient as s-expressions.
15:32:08 <Tuplanolla> With Haskell you have to work with TH and GHC as a library.
15:32:22 <ski> jmcarthur : i never figured out TH's stance on hygiene
15:32:56 <jmcarthur> Haskell syntax has its own benefits, but I often wonder if maybe it would be better to just get over the ugliness of s-expressions. Scheme diehards might be right on this one.
15:32:56 <jle`> n_blownapart: yeah, learning haskell doesn't involve learning any math
15:33:03 <tinco> n_blownapart: what kind of math are you trying to learn? it's a rather specific thing to do
15:33:52 <n_blownapart> jmcarthur: interesting. one moment tinco
15:33:54 <tinco> I bet learning math with a programming language would be easier in a language and domain that frequently together, like R and statistics, or C and 3d-graphics, Java and AI
15:34:04 <ski> jmcarthur : by-value macros would be useful, i think. but requires something like types
15:34:10 <monochrom> You can follow the book "the haskell road to logic and math", if it's your cup of tea. No guarantee.
15:34:20 <jmcarthur> (Actually I think it would be better to build the language with simpler pieces so that macros aren't necessary, but that's the hard way, like designing programs to have simple denotational semantics.)
15:34:24 <n_blownapart> monochrom: I have it !
15:34:42 <monochrom> and certainly Haskell is not the only way to concurrently learn programming and math
15:34:49 <jle`> haskell has helped me learn some parts of maths in the same sense that learning excel helped me learn how to balance my finances
15:34:51 <monochrom> Another way for example is Mathematica.
15:34:51 <ski> tinco : why not Prolog or a lisp with AI (they have traditionally been used together) ?
15:34:52 <n_blownapart> thing is, sicp is very cool but I am going through it like *molasses.*
15:35:00 <Tuplanolla> Personally I read SICP first and LYaH a few years later, n_blownapart. I'd say it worked rather well, because LYaH is more of a tour than a textbook. The math stuff only came up later.
15:35:32 <tinco> ski: well my impression was that in modern AI, like the stuff that's google currently doing a lot of, it's mostly Java, I'm aware that lisp is the traditional AI language
15:36:04 <jle`> modern AI is mostly java?
15:36:10 <jle`> huh, you learn something new every day
15:36:16 <Welkin> o.o
15:36:17 <Welkin> it's not
15:36:21 <tinco> jle`: well at google probably mostly C++ though :P
15:36:33 <Welkin> all of the ai companies I have come across are using clojure or something
15:36:42 <Welkin> but yeah, ew, still jvm
15:37:14 <tinco> yeah they use clojure because the libraries they want to use are implemented in Java probably
15:37:18 <n_blownapart> if I may put it differently ...
15:37:49 <Welkin> it's doubtful
15:38:00 <monochrom> LYAH is like there is a movie trailer that lasts 2 hours.
15:38:42 <n_blownapart> with the new trends upon us in IT, like AI , data-mining bigData etc. what sort of math should I focus on ? I heard haskell is excellent for math. essentially I'm learning basic recursion now.
15:39:31 <grantwu> too many buzzwords... buzzword overload... shutting down.
15:39:45 <n_blownapart> grantwu: word
15:39:45 <monochrom> Bayesian inference. And Haskell is not particularly advantageous.
15:40:28 <Tuplanolla> That's a funny question, because Haskell is great for some topics, yet pretty horrible for others, n_blownapart.
15:40:56 <monochrom> "math" is too broad
15:41:24 <n_blownapart> hmm ok . I might try to stick with scheme, especially if I can't get this editor to give me types on a mouse-over.
15:41:31 <Welkin> if you are really interested in maths, use coq or agda
15:41:44 <Welkin> haskell is better for building applications
15:42:17 <tinco> so n_blownapart is this your first programming language? you mentioned learning basic recursion
15:42:19 <monochrom> You go to a chat room full of people who have eye problems, and you ask what is the best way to learn about an elephant.
15:42:47 <monochrom> One of them is going to say "learn rubber sheets, because an elephant is like a rubber sheet"
15:42:52 <Welkin> monochrom: I think you got that cliche wrong
15:42:56 <n_blownapart> Welkin:  yes I heard that ! bloody complicated I gather. not for someone like me who has a wee bit of ruby knowledge and a wee bit of scheme. tinco I went through a ruby on rails tutorial... everything is self - taught
15:43:13 <Welkin> n_blownapart: coq and agda are hardly programming languages really
15:43:16 <Welkin> they are for writing proofs
15:43:22 <Welkin> not building applications
15:43:22 <monochrom> Another of them is going to say "learn wires, because an elephant is like a wire"
15:43:22 <tinco> :D
15:43:40 <ertesx> n_blownapart: note that no language comparisons have been done yet related to your question
15:43:42 <monochrom> Now you go to #haskell and ask about learning math.
15:43:49 <tinco> right, so Ruby, Scheme and Haskell are all equally suited for math ;)
15:43:51 <grantwu> Welkin: Careful, the computational trinitarians are going to get you.
15:43:53 <tinco> in general :P
15:44:02 <Tuplanolla> If you asked my advisor about programming languages for doing math, he'd tell you to use Fortran, n_blownapart.
15:44:02 <n_blownapart> monchrom is not in the living room...
15:44:10 <n_blownapart> monochrom*
15:44:16 <n_blownapart> monochrom *
15:44:23 <monochrom> what does that mean?
15:44:45 <Welkin> monochrom: one in the monad is worth 65,535 in the IO
15:44:51 <n_blownapart> like "there's an elephant in the living room" just messing with mixed metaphor
15:45:17 <Tuplanolla> So what happens next, n_blownapart?
15:45:19 <tinco> n_blownapart: learn Haskell and you'll become an excellent programmer, your Ruby will make more sense as well :) for the maths I'd advice you pick up a specific course from any university
15:45:31 <Welkin> like an elf in a china shop
15:45:39 * ski . o O ( "Sketches of an Elephant" <https://www.amazon.com/Sketches-Elephant-Theory-Compendium-Oxford/dp/019852496X> )
15:45:43 <tinco> I bet you could pick up data-mining or big-data AI from MIT or something like that
15:45:46 <david__> in #ghc I was recommended to ask here instead, so I'll ask again: is it safe to use "unsafeCoerce" to convert an "Either Void Bool" into an "Either Int Bool"?
15:45:50 <ertesx> n_blownapart: in other words: "i should use haskell" is as much of jumping to conclusions as "i shouldn't use haskell" at this point…  first you should pick a topic of interest, which may or may not be a math topic, and only then the language becomes relevant
15:46:08 <Welkin> "data-mining" and "big data ai/machine learning" are all just statistics...
15:46:12 <Welkin> nothing to do with AI
15:46:30 <monochrom> AI is broad too
15:46:40 <n_blownapart> ertesx thanks  et al thanks very interesting
15:46:47 <monochrom> but currently the statistics perspective is popular
15:46:59 <xcmw> Is there a type contriant like ~ that means is a instead of equal to?
15:47:00 <Welkin> it's a fad
15:47:03 <tinco> I don't think that's true, big-data machine learning is likely rather close to how are brains work, which I think is one of the main objectives of AI
15:47:04 <Welkin> machine learing faf
15:47:10 <Welkin> machine learning fad
15:47:18 <ertesx> xcmw: uh…  try that again
15:47:38 <ertesx> xcmw: perhaps with an example
15:47:48 <monochrom> Oh AI is so broad, there are two conflicting objectives.
15:48:08 <monochrom> One is to do what the brain does. The other is to avoid what the brain does.
15:48:12 <tinco> :D
15:48:12 <xcmw> ertesx: a -> a ??? String -> String
15:48:33 <ertesx> xcmw: and what should it mean?
15:48:40 <xcmw> ~ does not work because they are not equal
15:48:42 <ertesx> i mean: what other than equality?
15:48:48 <ertesx> they can be equal
15:48:52 <Welkin> lol
15:48:57 <Welkin> you mean like == and === in js?
15:49:05 <xcmw> No
15:49:09 <xcmw> Type level
15:49:22 <ertesx> > let f :: (a -> a ~ String -> String) => a -> String; f x = x in f "blah"
15:49:24 <n_blownapart> Welkin: specifically machine learning is a fad?
15:49:25 <lambdabot>  error:
15:49:25 <lambdabot>      • Expected a constraint,
15:49:25 <lambdabot>          but ‘a -> a ~ String => String’ has kind ‘*’
15:49:34 <tinco> I like the non-brainy AI better, but practical results show the way google is doing it is rather effective :P I mean they're beating humans at Go, which is better than anyone in the 'traditional' ai scene could have expected
15:49:39 <ertesx> > let f :: ((a -> a) ~ (String -> String)) => a -> String; f x = x in f "blah"
15:49:42 <lambdabot>  "blah"
15:49:48 <ertesx> xcmw: ^
15:50:05 <ertesx> xcmw: but that's of course just the same as saying (a ~ String)
15:50:10 <ertesx> or just writing String in the first place
15:50:28 <xcmw> rr :: (a ~ b) => a -> proxy b -> String
15:50:28 <xcmw> rr = undefined
15:50:32 <xcmw> e = rr id (Proxy :: Proxy (String -> String))
15:50:55 <xcmw> That gives an error. What can I use instead of ~?
15:50:58 <n_blownapart> the Go thing is amazing tinco
15:51:02 <ertesx> xcmw: rr :: a -> proxy a -> String
15:51:08 <ertesx> same thing
15:51:26 <Profpatsch> Does anyone know how I can tell SmallCheck: “ByteString series, but without these Word8s”?
15:51:31 <ertesx> and 'e' should type-check, unless i'm overlooking something
15:52:25 <n_blownapart> by the way the $ stack upgrade --install-ghc   took over 10 minutes . what is going on?
15:52:59 <david__> anyone?
15:53:14 <xcmw> ertesx: http://lpaste.net/338423
15:53:26 <Tuplanolla> I'd like to say yes, david__.
15:53:42 <Cale> david__: It's reasonably safe, I guess, but why?
15:53:58 <david__> Cale: reasons :)
15:54:17 <Profpatsch> david__: fmapL (const 0)
15:54:30 <ertesx> xcmw: i won't guess the error message and position =)
15:54:32 <tinco> n_blownapart: is it not printing anything? is your internet particularly slow perhaps?
15:54:47 <xcmw> ertesx: I included it line 61
15:54:52 <david__> Profpatsch: what about it?
15:55:00 <Cale> david__: Wherever you're producing the Either Void Bool, perhaps consider just using Bool instead...
15:55:02 <ertesx> oh, indeed
15:55:16 <david__> Cale: I know, it's a simplified example, but it is not an XY problem I assure you
15:55:19 <n_blownapart> no it finished tinco thanks. checking it now
15:55:20 <Profpatsch> david__: That should produce the type you desire.
15:55:44 <david__> Profpatsch: It's not an XY problem, I really do want to know if the usage of unsafeCoerce is sane
15:56:03 <david__> fmapL (const 0) is also not free, but again, not an XY problem
15:56:08 <xcmw> I can't do it the normal way or else I get Illegal type synonym family application in instance
15:56:16 <ertesx> xcmw: pretty basic error as far as i see:  d2 is of type A K2
15:56:30 <Profpatsch> david__: It sounds to me like this depends on GHC internals.
15:56:33 <david__> Cale: any reason why you said it's "reasonably" safe and not just "safe"?
15:56:42 <ertesx> xcmw: which means that fields aren't direct functions, but are wrapped by at least the K2 constructor
15:56:43 <monochrom> david__: unsafeCoerce (Left ???) is going to be problematic.
15:57:05 <david__> monochrom: but "???" could only be undefined, because Void has no other values
15:57:09 <monochrom> unless you assure me Left never happens.
15:57:18 <david__> monochrom: "data Void -- empty data decl"
15:57:39 <exio4> hmm, 40% sounds cool
15:57:43 <monochrom> That is no consolation. Does your code never produce a Left? Yes or No?
15:57:43 <Tuplanolla> You can do `Left (error "urgh")`, david__.
15:57:53 <david__> monochrom: how is that no consolation?
15:58:13 <david__> Tuplanolla: yes, I know - and in this case, "unsafeCoerce" to an "Either Int Bool" is still safe, no?
15:58:14 <monochrom> Because you can have buggy code that goes ahead produce "Left undefined" anyway.
15:58:22 <david__> monochrom: and why is that a problem?
15:58:45 <Profpatsch> david__: Now I am very interested in your use case.
15:59:00 <david__> Profpatsch: you mean the real use case?
15:59:09 <Profpatsch> yeah
15:59:10 <monochrom> becasue then "unsafeCoerce (Left ???)" will give you "Left (nonsense :: Int)" and that nonsense "number" will cause problems.
15:59:27 <david__> monochrom: it will cause no more problems than the original "undefined" ;)
15:59:31 <monochrom> You really have to tell me "my code never makes Left"
15:59:38 <david__> why do I have to tell you that?
15:59:39 <xcmw> ertesx: Fixed that. Still same error
15:59:45 <david__> that's not possible to say one way or the other
15:59:51 <Tuplanolla> It'll probably give you a graceful segmentation fault instead of an exception, david__.
16:00:09 <david__> Tuplanolla: why? both Void and Int are boxed
16:00:09 <isd> So I asked the other day if there were monad transformers somewhere corresponding to the MonadGet/MonadPut classes in the bytes package, and was told there weren't, and folks tended to construct custom stuff with free monads. Is there a specific reason /why/ this doesn't exist, or is it just that no-one has written it?
16:00:17 <monochrom> No, I think it causes more problems.
16:00:40 <david__> monochrom: can you elaborate? I'm not seeing how having "undefined" coerced to and from boxed types will cause a problem that didn't already exist
16:00:50 <xcmw> ertesx: If I cast id to String -> String it works but haskell should do that automatically
16:00:55 <Profpatsch> david__: Why not just fmapL undefined then?
16:01:01 <ertesx> xcmw: rr isn't even defined anywhere
16:01:03 <david__> Profpatsch: that's not free at runtime
16:01:03 <monochrom> undefined :: Void aborts the program.  nonsense :: Int tricks the computer into doing random work that doesn't necessarily just abort the problem.
16:01:25 <monochrom> s/abort the problem/abort the program/
16:01:29 <david__> monochrom: undefined::Void only aborts the program when forced, same as undefined::Int
16:01:39 <ertesx> xcmw: please make sure the code is complete and post the full error
16:01:43 <monochrom> but you won't get undefined :: Int
16:01:55 <david__> oh?
16:01:56 <monochrom> OK, maybe you do.
16:02:01 <Profpatsch> david__: Erm, it’s as not-free as unsafe-coercing it.
16:02:12 <xcmw> ertesx: rr was a made up example. The complete fixed code is in the original lpaste.
16:02:15 <Profpatsch> Since you will have to look into the Right in any case.
16:02:18 <david__> Profpatsch: no, unsafeCoerce does not traverse a data structure like fmap does
16:02:25 <monochrom> OK, no further objection.
16:02:32 <david__> ah, i see what you mean Profpatsch...
16:02:41 <xcmw> By fixed I mean I added k before id. It still does not work
16:02:45 <Profpatsch> And it can never be left.
16:03:02 <Tuplanolla> What does the language report say about this, david__?
16:03:03 <david__> right. so, now pretend you actually have to traverse somewhere in order to apply the fmap
16:03:19 <david__> like, [Either Void Int] -> [Either Bool Int]
16:03:45 <ertesx> xcmw: i'll let you research for a few minutes while i make another pot of tea, and if you haven't figured it out, i'll load it myself =)
16:03:47 <Profpatsch> You are in a lazy language, remember?
16:03:58 <david__> Profpatsch: yes?
16:04:52 <Profpatsch> Why would it traverse if it doesn’t look at the values?
16:04:55 <david__> Tuplanolla: it says that unsafeCoerce is safe as long as the two types share the same representation
16:05:00 <ski> (presumably `fmapL' will copy `Right')
16:05:05 <david__> Profpatsch: because you still have to traverse the list
16:05:23 <david__> i'd rather do unsafeCoerce, kind of like how safe Data.Coerce.coerce works
16:05:33 <Profpatsch> I really do want to see the use case for that.
16:05:44 <Profpatsch> Especially the one where this impacts runtime.
16:05:47 <grazie> question: why an exclamation mark ! in front of the types?: data PointSum = PointSum !Int !Double !Double
16:06:09 <monochrom> w00t I have a nice article for exactly that
16:06:20 <monochrom> http://www.vex.net/~trebla/haskell/strict-field.xhtml
16:06:29 <david__> Profpatsch: I'm just saying that "fmapL (const False)" as a "safe looking" alternative to unsafeCoerce is not exactly the same, because it incurs a runtime cost
16:06:42 <david__> when converting from Either Void Int -> Either Bool Int
16:06:51 <camm> Hello everybody. Is it possible to show the help text for a command or subcommand  if it fails with no input using `optparse-applicative-0.11.0.2`? In the version 0.13.0.0 it's easy becuase it's `prefShowHelpOnEmpty` there. May you can help me?
16:07:14 <Profpatsch> david__: Are you sure GHC doesn’t optimize it away?
16:07:22 <david__> Profpatsch: yeah
16:07:28 <ski> grazie : making the data constructor strict in those components
16:07:31 <grazie> monochrom: thank you, I didn't realize that link was for me
16:07:32 <david__> think arbitrarily deep. rewrite rules only get you so far.
16:08:03 <Profpatsch> And are you sure the runtime cost will influence your program in any way that makes thinking about unsafeCoerce worth it?
16:08:27 <Profpatsch> And are you sure there is no design problem, when you have to convert from Void like that?
16:11:11 <david__> yes
16:11:30 <david__> I'm asking about the safety properties of this particular unsafeCoerce
16:11:44 <david__> not asking how I might restructure my code, or if the runtime costs are punitive, or anything else
16:12:02 <david__> sorry to be brash but people keep dodging my straighforward inquiry :P thanks for the help though
16:12:33 <Profpatsch> I am still pretty sure there is pretty much no case where the coerce might be needed.
16:12:56 <david__> Profpatsch: convert [Either Void Int] into [Either Bool Int]
16:13:05 <Profpatsch> x->y :)
16:13:11 <david__> hm?
16:14:10 <Profpatsch> If you can show me a realistic example where the runtime cost overhead actually matters, I will believe there is a use case.
16:14:18 <david__> ok, well i just showed you one
16:14:44 <Tuplanolla> That's not a real use case, david__.
16:14:48 <Profpatsch> runnable, measurable code of course.
16:14:57 <david__> Tuplanolla: yes it is...
16:15:36 <Profpatsch> That I can put into my RTS and see the difference in runtime of coerce vs fmapL
16:16:05 <david__> Profpatsch: you can, with that example. Just make a hundred million element list
16:16:16 <Tuplanolla> That's not "a description consisting of one or more sentences in the everyday or business language of the end user or user of a system that captures what a user does or needs to do as part of his or her job function", david__.
16:16:34 <ertesx> xcmw: note that (K2 id) works there, so it has something to do with instance resolution
16:16:46 <david__> Tuplanolla: I'm less interested in convincing you I have a "real world" use case, and more interested in the semantics of unsafeCoerce
16:17:00 <david__> so, if you don't know, I'd rather not hear again and again how my problem is not a real problem
16:17:18 <isd> I think I may just want iteratee
16:17:59 <xcmw> ertesx: Still don't know
16:18:09 <Tuplanolla> Is it, then, not enough to try it to see if it works, david__?
16:18:20 <ertesx> xcmw: i suspect that it has something to do with TK2
16:19:00 <david__> Tuplanolla: oh, I tried it, and it works in my one-off GHCI toying. I came here to clarify that it is safe in all cases, since as you know Haskell is a large language with many interacting features
16:19:42 <Tuplanolla> Well, there's an easy answer to that too. If it's not mentioned in the language report, then it's not safe.
16:20:02 <xcmw> ertesx: Yes. See line 54
16:20:13 <david__> well, that's not an answer, because unsafeCoerce is well-defined and documented, I just don't personally know all of its ins and outs. hence my asking.
16:21:24 <ertesx> xcmw: yeah, i saw that one and tried to add an injectivity constraint, but it didn't help…  there are a lot of type-level interactions in this code, so it's a bit difficult to follow
16:21:32 <ertesx> especially with names like K1 and TK2
16:21:57 <Tuplanolla> Where is it mentioned, david__? I want to see.
16:23:02 <david__> Tuplanolla: check out the docs in Unsafe.Coerce (in base) for some commentary. I'm not sure about the haskell report
16:23:28 <david__> Tuplanolla: there is also unsafeCoerce# in ghc-prim: https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Prim.html
16:23:42 <Tuplanolla> That commentary is specific to GHC, so it's useless to you.
16:24:04 * hackagebot vty 5.12 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.12 (JonathanDaugherty)
16:24:29 <david__> Tuplanolla: well, I'm using GHC to compile the code
16:24:38 <david__> it's useless because?
16:24:50 <ertesx> xcmw: why don't you just explain what you're doing?
16:25:24 <xcmw> ertesx: That specific line or the entire thing?
16:25:37 <Tuplanolla> Once more: do you care about GHC or Haskell, david__?
16:26:01 <Tuplanolla> If it's the former, verify your claim empirically. If it's the latter, see if the language report answers the question.
16:26:13 <ertesx> xcmw: the entire thing
16:26:16 <dmj`> david__: coerce is safe, unsafeCoerce is not
16:26:25 <david__> dmj`: ah - why's that?
16:27:19 <dmj`> unsafeCoerce means you're telling GHC that you can guarantee that the underlying runtime representation of type 'a' can be converted to 'b'
16:27:41 <dmj`> coerce I believe gives you a compile time guarantee that this coercion is safe to perform
16:27:43 <david__> right - I think you must have missed my original question - I'm wondering about the coercion between "Either Void Int" and "Either Bool Int"
16:27:55 <david__> in this case, it seems like unsafeCoerce is safe, but I'd like to make sure
16:28:39 <xcmw> ertesx: I wanted map like data structure that had static keys and values with different types. A key of one map had to work on another map. I ended up with that. If you can think of a better way, I would be happy to try it.
16:28:52 <dmj`> david__: (unsafeCoerce (Right 1) :: Either Void Int -> Either Bool Int) seems like it would be fine. I can't speak for the other constructor
16:29:04 * hackagebot brick 0.14 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.14 (JonathanDaugherty)
16:29:10 <david__> dmj`: Void has no values, so it can only be inhabited by undefined
16:29:12 <ertesx> xcmw: static keys?  as in: a function?
16:29:30 <ertesx> xcmw: or just that the keys determine the value type?
16:29:38 <ertesx> xcmw: because in the latter case see the dependent-map library
16:29:42 <david__> dmj`: therefore, i think coercing "undefined :: Void" to e.g. "undefined :: Bool" should be safe too, no?
16:30:27 <dmj`> david__: http://lpaste.net/6470501207906451456
16:30:43 <dmj`> "segmentation faults await"
16:30:46 <david__> that's the opposite direction
16:30:50 <david__> you coerced True to Void...
16:30:55 <xcmw> static keys mean that the all the keys of each map and their types are determined at compile time
16:30:59 <david__> not Void to True
16:31:37 <ertesx> xcmw: it's like Map from containers, but your key type is a * -> *, and it uses type refinement to determine the value type
16:31:51 * byorgey is disappointed by all the responses to david__'s question.  It seems like a lot of "YOU'RE WRONG but I don't know why exactly, just try it, you'll see".  If you don't know the answer, don't say anything.
16:32:12 <ertesx> xcmw: insert :: k a -> f a -> DMap k f -> DMap k f
16:32:19 <ertesx> xcmw: something like that?
16:32:32 <david__> byorgey: it's fine :)
16:32:40 <Tuplanolla> The problem is that it's unknowable for Haskell in general, because the language report doesn't say enough, byorgey.
16:33:08 <david__> Tuplanolla: it's definitely not unknowable, it's just not known by <-- me
16:33:16 <david__> or, evidently, you
16:33:25 <dmj`> david__: since bottom inhabits every type, you /can/ coerce it, but its a ticking time bomb. It's basically writing a :: Bool = undefined
16:33:49 <byorgey> Tuplanolla: sure, I'm not arguing with that.
16:33:51 <david__> dmj`: indeed, but you already *had* an undefined! so the unsafeCoerce is not the creator of the bomb
16:33:58 <Tuplanolla> The report allows one to make a conforming Haskell compiler where it's safe and another compiler where it's not safe, david__.
16:33:59 <xcmw> ertesx: If can implement the t and q functions form the lpaste, then it is good
16:34:02 <ongy> david__: Tuplanolla is saying that it may be fine (or not) for GHC, which isn't all of haskell. Even if that's what most people use
16:34:28 <david__> ongy: ah, in that case consider my question one of GHC semantics, not Haskell
16:34:38 <monochrom> If you invoke the Haskell Report, unsafeCoerce doesn't exist.
16:34:53 <david__> my mistake, I thought it was defined in the report
16:35:00 <dmj`> david__: right, in that case 'Void' isn't necessary, you can use any type with undefined
16:35:01 <Tuplanolla> It does at least mention `unsafeCoerce#`, monochrom.
16:35:11 <monochrom> where?
16:35:18 <ertesx> xcmw: as far as i understand (A k) is a k-indexed container such that k selects the value type at individual indices…  is that correct?
16:35:46 <david__> dmj`: so is unsafeCoerce safe in this case, then? Void being "necessary" notwithstanding (as it's just a toy example)
16:36:11 <xcmw> ertesx: It looks promising. I will try it.
16:37:09 <dmj`> david__: It's unnecesary since bottom needs no coercing to inhabit any type
16:37:27 <ertesx> xcmw: yeah, now it looks like you're trying to write something like DMap, and in fact your main mistake seems to be that you didn't make use of type refinement…  DMap relies heavily on GADTs and their type refinement on pattern matching
16:37:32 <byorgey> david__: it seems to me the central question is whether GHC will always compile  Either a b  to the same runtime representation regardless of a and b.  But I don't know the answer to that.
16:37:33 <Tuplanolla> You're right, monochrom. It's not even in here.
16:37:43 <david__> byorgey: yes, that is the question :)
16:38:00 <byorgey> and I haven't heard anyone else address that question either.
16:38:19 <david__> indeed, but someone might come along!
16:38:29 <byorgey> yes, they might =)
16:38:36 <Tuplanolla> I wonder if GHC developers have even decided on it.
16:38:38 <Cale> byorgey, david__: I would be extremely surprised if the answer to that question was anything but "yes"
16:39:11 <Cale> GHC doesn't presently specialise the implementation of parametric types for specific parameters so far as I know -- I wish that it could.
16:39:15 <ertesx> xcmw: example:  data MyK :: * -> * where MyIntK :: String -> MyK Int; MyBoolK :: MyK Bool  -- this is a key type that can refer to values of type Int and Bool…  in the int case there is an additional index of type String
16:39:44 <ertesx> xcmw: i hope that makes sense, and if it doesn't, just learn the DMap library…  it should make sense quickly
16:39:57 <ertesx> s/DMap/dependent-map/
16:39:57 <Cale> It would actually be really cool to be able to, e.g. use FingerTree directly and get decent performance, rather than seeing it as some sort of inspiration for things that you're going to have to replace with handcrafted data structures.
16:40:02 <byorgey> that's what I would expect too. in which case unsafeCoerce should be perfectly safe.
16:40:04 <n_blownapart> let it be known : atom with stack is *dead slow* on mac el capitan .
16:40:17 <xcmw> ertesx: I will look at DMap. That you for your help.
16:40:21 <david__> Cale: is it possible that GHC treats empty data types specially, though? my intuition is no, because they can be inhabited by bottom. but again - uncertain!
16:40:54 <Cale> david__: As far as I'm aware, GHC doesn't do anything to treat Void specially.
16:41:16 <Cale> If you care about things being future proof though, you really should only apply unsafeCoerce in situations where you *know* the type is the same
16:41:52 <Cale> and situations like this one, well, I don't know, but it's rather suspicious to end up with an Either Void anything.
16:41:58 <david__> Cale: not necessarily, there are many tricks in the wild where the types are not at all the same but the representations are
16:42:07 <david__> reflection comes to mind... but more benign uses, too
16:43:33 <ertes> xcmw: one final note: you can achieve type refinement through equality constraints, but only at rank 2 with scott/church encoding
16:43:53 <david__> Cale: the actual coercion I want to make is "Ap f (Ap (Sum f VoidF) a) -> Ap f (Ap (Sum f g) a)", hence why I didn't bother showing my actual example... it's pointless complexity
16:44:03 <david__> where VoidF is "data VoidF a"
16:45:16 <ertes> data X :: * -> * where Xb :: Bool -> X Bool; Xi :: Int -> X Int; Xa :: a -> X a
16:45:54 <Cale> david__: I'm not sure I'd be comfortable calling the stuff that goes on inside the reflection package stable though.
16:45:54 <ertes> newtype Y a = Y { fromY :: forall r. ((a ~ Bool) => Bool -> r) -> ((a ~ Int) => Int -> r) -> (a -> r) -> r }
16:45:58 <ertes> X ≃ Y
16:46:29 <Cale> david__: It's relying a bit on particular details of the way that GHC is implementing the language, and little changes could upset that.
16:47:07 <xcmw> ertes: Thanks
16:47:48 <david__> Cale: there's a great comment by kmett circa 2012 about a litany of real uses he's found for unsafeCoerce (most being performance related). but yes, technically all uses of unsafeCoerce may break
16:48:31 <monochrom> There is a way you can dismiss future concerns.
16:48:40 <ertes> david__: those uses are best kept in tightly sealed edwardk packages like reflection, where they are safe =)
16:48:53 <monochrom> "It is not future-proof, in a future in which I will have switched to Idris." :)
16:49:05 <david__> ertes: do you know if my use-case is safe or not?
16:49:09 <Cale> Well, the safest uses of unsafeCoerce won't -- if you're carrying around other evidence regarding what the types are, and making sure that it matches up, you can often have some runtime guarantees about the type of thing you're applying unsafeCoerce to.
16:49:13 <david__> ertes: [Either Void Bool] -> [Either Int Bool]
16:49:22 <ertes> david__: i don't know, sorry
16:49:46 <ertes> especially with something like Void i'd be super-careful
16:49:53 <david__> Cale: indeed, that is how dynamic used to work I think
16:49:54 <ertes> GHC is a very aggressive optimiser
16:50:16 <Tuplanolla> This is just like the untagged union talk we had a few weeks back.
16:50:19 <david__> ertes: yes, so the question is, will GHC see "Either Void _" and think "I should represent this as X instead of Y"
16:50:23 <Cale> Several years ago, one of our FRP system implementations took advantage of this to implement a typed heterogeneous graph -- there was some unsafeCoercing going on in order to stick everything into the same Map, but all the types were recoverable from the GADT used for nodes.
16:50:47 <david__> ertes: i would think not, because void has one inhabitant - bottom
16:51:00 <david__> so how can GHC represent it any differently than any other boxed value?
16:51:32 <ertes> david__: i really don't know, so this is a pure guess:  while there is still an inhabitant, GHC knows in principle that nothing can ever *observe* it
16:51:50 <david__> Cale: are you talking about Any/unsafeCoerce#? a little different of a beast than regular old unsafeCoerce
16:51:59 <Cale> nope
16:52:13 <ertes> david__: but there is only one way to find out:  try it
16:52:17 <david__> ertes: ah, but you can observe it, because you can force the thunk and catch the exception in IO, for example
16:52:36 <ertes> david__: you're making assumptions on the kind of bottom
16:52:39 <monochrom> Cale: What is the ending of that story? Is it a happy ending or is it a sad ending? :)
16:52:49 <david__> ertes: I tried it; it works in GHCi - asking for clarification of the rules/semantics
16:53:03 <ertes> david__: whether it works compiled is more important
16:53:06 <david__> I'm not super sure it always works, I only *assume* so with no real proof
16:53:11 <ertes> GHCi does far less optimising
16:53:12 <david__> it works compiled, too
16:53:36 <Cale> monochrom: Well, it worked and we implemented some interesting transformations, but it was like 8000 lines of some of the densest Haskell code I've ever worked on, and probably the benefit wasn't really big enough to justify the development effort
16:53:40 <ertes> try with different -O levels, etc.
16:53:54 <monochrom> Hrm!
16:53:59 <ertes> david__: different question: why are you doing this?
16:54:23 <monochrom> I thought unsafeCoerce saved you from writing more code.
16:55:09 <david__> ertes: ah, a little hard to explain but it's somewhere deep inside some extensible-effects type code
16:55:12 <Cale> monochrom: Well, it wasn't so much that unsafeCoerce had a huge impact in our case.
16:55:32 <david__> "Ap f (Ap (Sum f VoidF) a) -> Ap f (Ap (Sum f g) a)" is the coercion i want to make
16:55:39 <ertes> david__: trying to make lifting cheaper?
16:56:12 <david__> ertes: trying to do that ^
16:56:26 <ertes> ah, you're trying to do something like 'absurd'?
16:56:26 <Profpatsch> @pl \cs -> any (\w8 -> (any (==w8) cs))
16:56:27 <lambdabot> any . flip (any . (==))
16:56:28 <Cale> monochrom: The overall thing we were doing was kind of crazy: turning a bunch of Arrow computations into a heterogeneous graph representing the flow of data in the FRP network and rewriting that a bunch at runtime before actually running it.
16:56:28 <david__> coerce a "Sum f VoidF" to a "Sum f g", everywhere inside a data structure
16:56:40 <david__> yes! except absurd would incur a runtime cost
16:57:07 <ertes> david__: i see
16:57:17 <david__> Cale: this sounds familiar... where did you work?
16:57:28 <Cale> That was for iPwn Studios
16:58:00 <Cale> along with Ryan Trinkle, who I'm now working with again at Obsidian Systems
16:58:12 <ertes> david__: why does 'absurd' have a run-time cost?  because it needs to cross the Ap layers?
16:58:39 <david__> ertes: yeah
16:58:45 <monochrom> fascinating stuff
16:58:54 <david__> ertes: the same reason "map Sum" incurs a runtime cost even though it's a newtype wrapper
16:58:59 <jmcarthur> Propose that GHC make a Coerce instance for Void
16:59:16 <ertes> david__: can you design Ap/Sum in such a way that they can be used "a la carte"?  then you don't need to "seal the Sum"
16:59:29 <exio4> there's coerce now, which is "type-safe unsafeCoerce" 
16:59:39 <nshepperd1> It's not the absurd that has the cost really, but the fmapping. And a Coerce instance sounds like the thing yeah
16:59:40 <jmcarthur> exio4: It doesn't support Void in this way.
16:59:54 <Cale> jmcarthur: Of course, usually coercing Void to other stuff is a bad plan.
16:59:58 <david__> ertes: what do yoou mean?
17:00:12 <david__> like an open union?
17:00:15 <jmcarthur> Cale: You're right. It's more complicated than I made it sound.
17:00:30 <monochrom> No wait, Void -> a is a theorem.
17:00:32 <ertes> david__: you seem to have some layering scheme, but perhaps it's possible to have a monoidal "addition" scheme instead
17:00:53 <ertes> david__: replace Succ (Succ (Succ Zero)) by 1 + 1 + 1
17:01:08 <jmcarthur> Cale: I take it back. I was right before.
17:01:20 <jmcarthur> Cale: I brain farted when you made me rethink it. :P
17:01:24 <ertes> david__: if you can't do that, i'd try to make Data.Coerce work
17:01:38 <exio4> we dont have a real Void, though
17:01:39 <Cale> jmcarthur: Well, it's sort of okay to make that coercion
17:01:52 <david__> ertes: there's no "Coercible Void a" :(
17:02:06 <monochrom> Void+Bot -> a+Bot is still a theorem
17:02:07 <ertes> david__: you can define your own Void
17:02:09 <david__> and besides I'm using a different Void not in base, at kind * -> *
17:02:17 <jmcarthur> Cale: Why only sort of?
17:02:17 <nshepperd1> Cale: huh? absurd basically is that "coercing void to other things"
17:02:19 <david__> ertes: right but you can't make Coercible instances, or can you?
17:03:05 <ertes> ah, right…  Coercible is like Typeable
17:03:05 <jmcarthur> david__: You can't indeed.
17:03:12 <david__> right
17:03:22 <david__> so here I am, wanting to use unsafeCoerce.... I'm just gonna do it
17:03:32 <monochrom> I support you.
17:03:36 <david__> *climbs into jumpsuit*
17:03:41 <monochrom> I opposed it but you convinced me.
17:03:53 <ertes> nshepperd1: as you said, the fmapping to get to the Void is what has the cost
17:04:01 <ongy> Void with kind * -> *, is that Proxy?
17:04:08 <Tuplanolla> A C programmer wouldn't have a two-hour discussion before casting a `void*`.
17:04:12 <david__> ongy: no, Proxy has one value (+ undefined)
17:04:14 <ertes> ongy: Proxy is Unit
17:04:30 <ongy> ah, ok
17:04:56 <david__> but a C programmer knows how his language represents data :P
17:04:58 <ertes> Tuplanolla: except it's not a C (void *)
17:05:02 <david__> (or her)
17:05:04 <monochrom> But C has much less of a difference between standard and compiler.
17:05:25 <david__> ongy: Void at kind * -> * is: "data Void2 a"
17:05:29 <ertes> in C it's quite predictable what will happen
17:06:04 <monochrom> the C standard pretty much prescribes a memory-and-address model that tells you what happens to void* and every compiler has to suck it up.
17:06:18 <nshepperd1> Well, the c standard itself is actually really vague about such matters, last time i tried reading it
17:06:21 <Cale> ertes: Quite predictably, just about anything you do will cause the program to start a game of Tetric
17:06:22 <monochrom> the Haskell standard doesn't even say that you have a Turing machine.
17:06:24 <Cale> Tetris*
17:06:33 <Cale> :)
17:06:43 <Welkin> M-x tetris
17:07:19 <ongy> a lot of garbage memory and a well placed jump could do that...
17:07:33 <mietek> Anyone experienced with GHC.TypeLits, in particular Symbol?
17:07:51 <dmj`> mietek: sure
17:07:53 <ertes> hehe
17:08:37 <david__> mietek: yup
17:08:42 <dmj`> mietek: there is no type level Char yet, we all want it though
17:08:44 <monochrom> In C, you will have 2-hour flame wars on f(i++, ++j, --i--)
17:08:48 <Cale> Anything which is undefined behaviour should start a game of Tetris.
17:09:01 <mietek> OK. I’m actually happy with Symbol being atomic.
17:09:07 <hpc> monochrom: are those commas supposed to be commas?
17:09:14 <monochrom> yes!
17:09:15 <ertes> … or delete your source code file
17:09:26 <hpc> oh, f
17:09:30 <mietek> I am deeply confused by the Symbol/KnownSymbol/SomeSymbol/SSymbol datatypes
17:09:30 <hpc> i was reading it as for
17:09:35 <monochrom> yeah, function call semantics
17:09:36 * jmcarthur imagines the number of bug reports about surprise games of tetris
17:09:39 <ab9rf> Cale: that would create an incentive for undefined behavior
17:09:41 <mietek> I have rolled my own type-level naturals and singletons for them, and these make sense to me
17:10:49 <ab9rf> Cale: one architecture i used to work with had two different levels of "undefined"; the lower level was restrained by memory protection, but the higher level was not. in theory, the higher level could cause the CPU to catch on fire
17:11:00 <ongy> monochrom: --i--? sounds perfectly safe. Why should get something like that into haskell
17:11:16 <ab9rf> ongy: it's not, but we don't need to go into why
17:11:17 <monochrom> :)
17:11:27 <ertes> https://twitter.com/bos31337/status/116372971509121025
17:11:35 <david__> mietek: what would you like to know?
17:11:56 <mietek> dmj`, david__: here are my naturals: https://gist.github.com/mietek/e1a644889498d11a383b27897bb6563e
17:11:57 <monochrom> I am saying that C people will have their 2-hour flame wars, just on a different part of their language.
17:12:08 <mietek> Anything weird or bad about them?
17:12:18 <Cale> ab9rf: HCF
17:12:29 <david__> mietek: these are fine, not the same as the TypeLits in base though
17:13:02 <ab9rf> Cale: i recall the architecture manual stating that "undefined behavior should not cause damage to hardware, but this cannot be guaranteed"
17:13:03 <mietek> Indeed. I don’t particularly care about compatibility with base, but I wanted to have type-level Strings and run into a problem
17:13:14 <mietek> It seems that String is unpromoteable
17:13:30 <david__> mietek: it is
17:13:44 <david__> you could make your own alphabet, and then use a list of it at the type level
17:14:09 <david__> like "data Chr = A | B | C | D | E | F | G | ..."
17:14:11 <geekosaur> ob F00FC7C8
17:14:27 <mietek> Can you tell me how to make use of TypeLits.Symbol and TypeLits.Nat?
17:14:46 <mietek> Here's what I figured out about Symbol
17:14:49 <david__> mietek: the ones in base or in singletons?
17:14:54 <mietek> base
17:15:25 <david__> mietek: ok. so, you can have type-level strings whose kind is "Symbol", and given a "KnownSymbol x" constraint on a Symbol, you can reify it into a String
17:15:34 <monochrom> geekosaur: what is F00FC7C8?
17:15:44 <dmj`> > natVal ( Proxy :: Proxy ( 1 + 1 ) )
17:15:46 <lambdabot>  error:
17:15:47 <lambdabot>      Not in scope: type constructor or class ‘+’
17:15:56 <geekosaur> monochrom, edge case in page table handling that caused certain Intel CPUs to lock up hard
17:16:02 <geekosaur> "f00f bug"
17:16:46 <mietek> dmj`, david__: https://gist.github.com/mietek/763d5c3b4fc224aef19bdd06b84864fb
17:16:56 <mietek> I know how to get from the type world to the value world
17:16:57 <geekosaur> iirc it wasn't even a valid instruction, although it was successfully decoded into microcode that locked the CPU
17:17:08 <mietek> How can I turn a String into a Symbol?
17:17:45 <mietek> So, get from the value world to the type world
17:17:46 <david__> mietek: you can't
17:18:06 <ertes> that makes me wonder: the way to dependent types may be long, but in the meantime wouldn't it be possible to completely embed the type language in the value language?  that way we could at least refer to and pattern-match on things bound by 'forall' instead of lambda
17:18:15 <geekosaur> mietek, the problem is Symbol wasn't thought out the way Nat was. while mechanisms were devised to build up Nat-s from smaller ones, no such mechanism was provided for Symbol
17:18:36 <david__> geekosaur: no such mechanisms exist for nat, it's opaque
17:18:40 <geekosaur> an obvious one would be type level Char + the existing type level lists, but that machinery doesn't exist
17:18:41 <david__> not inductively defined
17:18:51 <geekosaur> and neither does type level Char
17:19:06 * hackagebot yesod-elements 1.0 - Non template haskell markup building function in the spirit of lucid  https://hackage.haskell.org/package/yesod-elements-1.0 (andrewthad)
17:19:17 <mietek> I’m missing something
17:19:36 <geekosaur> david__, I thought I found an equivalent to the old hack for large type level nats
17:20:25 <david__> geekosaur: hm, I'm not familiar with that hack. I just meant that "data Nat = Z | S Nat" is *not* how Nat is defined in TypeLits (though it would be much more useful if so)
17:21:00 <mietek> Let me ask a more general question...
17:21:21 <geekosaur> correct, it's not. the hack started with that and then added D* for single digit values, and type level silliness (type families iirc) to let you build multi-digit naturals out of those
17:21:40 <mietek> What is the best way to move the same, uh, *sort* of information from the value world to the type world, and vice versa?
17:21:55 <ertes> mietek: reflection
17:22:01 <david__> mietek: singletons, like you're doing with your code snippets
17:22:03 <ertes> @package reflection
17:22:03 <lambdabot> http://hackage.haskell.org/package/reflection
17:22:12 <david__> no, not reflection...?
17:22:19 <mietek> No, let’s not talk about reflection
17:22:27 <ertes> it's the "best" way if that's all you need
17:22:40 <david__> ertes: ???
17:22:47 <geekosaur> and I thought something that didnt work anything like that but still let you sanely reflect numbers without significant restriction was in there, whereas it's not possible to build an arbitrary String at runtime and reflect it into type level, theres KnownNat hackery that allows it for computed naturals-range values to some extent
17:22:48 <mietek> david__: can you expand on your suggestion, please?
17:22:59 <ertes> mietek: what's the application?
17:23:06 <mietek> > not possible to build an arbitrary String at runtime and reflect it into type level
17:23:09 <lambdabot>  <hint>:1:74: error: parse error on input ‘type’
17:23:18 <mietek> @cookie
17:23:18 <lambdabot> Unknown command, try @list
17:23:20 <david__> mietek: that's correct
17:23:36 <ertes> uhm…  that's actually possible
17:23:42 <david__> you can tuck it in an existential
17:24:03 <ertes> or use RankNTypes
17:24:05 <monochrom> but Nat : KnownNat :: Symbol :: KnownSymbol
17:24:23 <pokalyis> Is it possible to create a type that consists of a particular sequence of strings, i.e a comment? I.e (pseudo code); 'type Comment = ";" + String'
17:24:32 <david__> monochrom: what you're trying to do might be possible, but it also might require dependent types. can you say more about what you're trying to do?
17:24:51 <monochrom> you mean mietek :)
17:25:00 <david__> oops, sorry
17:25:11 <mietek> david__: yeah, I’m porting some Agda to Haskell
17:25:18 <ertes> pokalyis: yes, use a String-like type and make its semantics such that it pretends that there is a ';' in front of every string
17:25:27 <david__> ah, so then you'd know if what you're doing requires dependent types :P
17:25:33 <mietek> And getting very confused about the limitations
17:25:37 <geekosaur> iirc KnownSymbol has restrictions KnownNat doesn't
17:25:39 <mietek> Well, what I don’t know is what Haskell allows
17:25:52 <geekosaur> although possibly I am just misunderstanding what is going on
17:26:12 <david__> mietek: you can do this... String -> (forall s. KnownSymbol s => r) -> r
17:26:16 <geekosaur> but, quite a few people seem to be looking for functionality in KnownNat that doesn't seem to be currently possible with KnownString
17:26:25 <geekosaur> er KnownSymbol
17:26:40 <mietek> david__: erm.
17:26:53 <mietek> Ah.
17:26:55 <jasonkuhrt> Hi, How do I pass ENV variables to a haskell app?
17:27:20 <david__> mietek: but not this: (s : String) -> s
17:27:35 <ongy> jasonkuhrt: the same way you would for others. are you interested in reading them?
17:27:40 <ertes> if the application were known, nobody would have to guess
17:28:12 <mietek> david__: wait... what does that last thing mean?
17:28:15 <geekosaur> jasonkuhrt, presmably you want System.Environment, or for more functionality but less portability System.Posix.Environment or the Win32.* equivalent that I don't know offhand
17:28:35 <david__> mietek: i meant to write a dependent function, e.g. (s : String) -> Foo s
17:28:38 <jasonkuhrt> ongy: I have the read code working, But when I package my app up in docker via stack build and then run stack exec my-exec env vars passed via docker --env do not work
17:28:52 <mietek> david__, dmj`: the application is, I have a datatype of typed abstract syntax trees
17:29:04 <geekosaur> jasonkuhrt, there's too many moving parts there
17:29:07 <ertes> discussions like this quickly get into "dependent types" territory when all the application requires is reflection
17:29:10 <mietek> And one of the (object-language) types would like to be parametrised by a String
17:29:14 <jasonkuhrt> Ok, one sec
17:29:35 <geekosaur> jasonkuhrt, I don't know what if anything stack does with envars, for example.
17:29:35 <david__> mietek: is the string erased?
17:29:54 <mietek> So, this String would have to live at the type-level, when describing a term of the (Haskell-level) type Term cx ty
17:30:12 <ski> Tuplanolla : "untagged union talk" ?
17:30:27 <mietek> So yeah, it would be ordinarily erased, I think
17:30:36 <geekosaur> I would start with something like ``` FOO=foo stack exec sh -c 'echo $FOO' ```, then start swapping parts like docker --env in until FOO disappears
17:30:45 <david__> mietek: ok, then regular old GADTs and type families will be enough
17:31:01 <mietek> Well — would be enough if it was always erased
17:31:09 <david__> ya
17:31:16 <geekosaur> er, that robably needs to be: FOO=foo stack exec -- sh -c 'echo $FOO'
17:31:18 <mietek> I’m slowly getting to the point that it’d be nice to be able to print a term and see its type, too
17:31:33 <ertes> that's possible
17:32:25 <jasonkuhrt> So I can get an env var to be read when running stack locally e.g. without the env var:
17:32:27 <jasonkuhrt> ❯ stack exec hlg-website
17:32:27 <jasonkuhrt> Exiting process; Error: A slack token with admin scope must be supplied as an ENV variable called APP_SLACK_TOKEN.
17:32:28 <david__> i think actually it doesn't necessarily have to be erased, it just can't be used in any dependent types
17:32:40 <jasonkuhrt> then with: ❯ APP_SLACK_TOKEN=foobar stack exec hlg-website
17:32:41 <jasonkuhrt> Setting phasers to stun... (port 8080) (ctrl-c to quit)
17:32:44 <david__> because you can get the "value" of the "type" in haskell too (with knownSymbol)
17:32:45 <jasonkuhrt> So that's great
17:32:56 <david__> err, "symbolVal"
17:33:04 <geekosaur> then apparently your problem is elsewhere than the Haskell program
17:33:16 <mietek> david__: yes, I know how to get it
17:33:18 <jasonkuhrt> But via docker: docker run 838baa79cc43 --env APP_SLACK_TOKEN=foobar the app for some reason doesn't see the env var
17:33:22 <mietek> david__: what I don’t know is how to put it!
17:33:29 <david__> you just write it!
17:33:36 <monochrom> "setting phasers to stun"... is it in preparation of unsafePerformIO FirePhaser?
17:34:01 <david__> mietek: care to share a snippet?
17:34:18 <geekosaur> jasonkuhrt, I think I would worry about how your docker launches the application, then
17:34:47 <geekosaur> but I am barely conversant with docker (it's on my list of things to learn, somewhere around the health issues...)
17:35:29 <jasonkuhrt> geekosaur: Yeah seems like it, I'll dig in more, just thought there was something everyone else knows I might be missing because I've used docker a fair bit with other langauges and never had this kind of issue.
17:35:46 <jasonkuhrt> Thanks!
17:36:11 <geekosaur> I have far too little information (and far too little docker detailed knowledge) to help, or to know why there would be a difference here
17:36:35 <geekosaur> but there could be other parts involved as well (e.g. sudo?)
17:36:50 <geekosaur> because I don't know how the docker container is set up
17:36:55 <geekosaur> or what it is actually doing
17:37:46 <geekosaur> also fun like "systemd stuck its fingers in here, your envars ended up somewhere else"
17:41:22 <mietek> david__: https://gist.github.com/mietek/87e96f2321d31d9d713f346455b4182e
17:41:48 <mietek> The problem is evident in line 116
17:41:51 <mietek> There is a hole
17:42:08 <mietek> We would like to "unsing", or move from the type level to the value level, and get a Ty
17:42:27 <mietek> But we’ve lost the information about the parameter to the Atom constructor of Ty
17:42:34 <mietek> SingAtom doesn’t have a parameter
17:42:51 <mietek> And I don’t know what should this parameter be
17:43:50 <david__> define the SingAtom constructor as "SingAtom :: KnownSymbol s => SingTy (Atom s)"
17:45:16 <david__> then you can write line 116 as: unsingTy (SingAtom :: SingTy (Atom s)) = Atom (symbolVal (Proxy s))
17:47:36 <mietek> So first, to change Atom to take Symbol, not string?
17:48:06 <david__> no, that has to stay String - Symbols only exist at the type level
17:48:22 <mietek> Can you try to make the modification you suggested and see what happens?
17:48:33 <david__> does it blow up horribly?
17:49:04 <mietek>     • Expected kind ‘String’, but ‘s’ has kind ‘Symbol’
17:49:29 <dmj`> mietek: you can 'promote' a String with 'someSymbolVal'
17:49:39 <mietek> If we have "KnownSymbol s", then we can’t have "Atom s", unless Atom takes a Symbol — right?
17:49:48 <mietek> dmj:` only to SomeSymbol, and not to Symbol!
17:49:57 <mietek> That is making my head hurt
17:50:06 <dmj`> mietek: right, the witness is an existential
17:50:15 <dmj`> which means its resolved at runtime
17:50:38 <mietek> dmj`: and where is the function which goes from SomeSymbol to String?
17:51:19 <dmj`> mietek: that's the trick, you have to case match on SomeSymbol, case (SomeSymbol unknownSymbol) of -> ...
17:51:40 <dmj`> then you compare it to already known symbols at compile time
17:51:56 <david__> mietek: ah i see the problem... yes, you cannot index SingTy by Atom
17:52:37 <dmj`> mietek: http://lpaste.net/2271644942004649984
17:53:18 <david__> mietek: haskell can't do what you want here, sorry
17:53:36 <mietek> @quote can do that
17:53:37 <lambdabot> No quotes for this person. My pet ferret can type better than you!
17:53:42 <mietek> Come. On.
17:54:47 <Welkin> lambdabot: pet ferrets are illegal!
17:54:59 <wespiser> not it massachusetts
17:55:05 * Welkin calls the thoughtpolice 
17:55:09 <wespiser> boston does have the best start-up scene!
17:55:55 <delYsid> ski: Sorry, had to leave... I have to admit most of why you explained about FDs was pretty much over my head, but I think I've got at least part of what you said.  Thanks.
17:56:18 <mietek> dmj`: can I extract the value inside unknownSym and print *that*?
17:56:35 <mietek> I don’t even care if it’s unsafe at this point
17:56:38 <mietek> Haskell is unsafe ;p
17:57:27 <ski> delYsid : i stated several equivalent ways of saying the same thing, then mentioned a direct practical use of it
17:58:19 <delYsid> ski: I appreciate that.
17:58:27 <dmj`> mietek: you can if it's the exact same as another symbol which is not an existential
17:59:12 <delYsid> er, s/why/what/
18:00:19 <mietek> OK.
18:00:25 <dmj`> mietek: it all has to exist at compile time to be accessible. If you try to go back (from runtime) with someSymbolVal you'll just get Proxy's w/ existentials types. You can't go from String to SomeSymbol back to String, without some other kind of witness that isn't existential.
18:00:53 <mietek> Well, a singleton is exactly that: a witness
18:01:13 <mietek> And if you look at the bottom of https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.TypeLits.html#ErrorMessage
18:01:31 <dmj`> case SomeSymbol unknownProxy of if isJust (sameSymbol (Proxy :: Proxy "foo") unknownProxy) then print $ symbolVal (Proxy :: Proxy "foo") else putStrLn "not found"
18:01:50 <mietek> There is the newtype SSymbol and data WrapS
18:02:03 <mietek> and it seems to me SSymbol is a singleton type
18:39:38 <isd> I see that the enumerator package says that it's deprecated; is there a consensus on what to use instead?
18:42:41 <hpc> iirc historically it went enumerators, then iteratees, then traversible
18:43:09 <hpc> or maybe conduit
18:48:46 <byorgey> hpc: I don't see what traversable has to do with the other three
18:48:56 <byorgey> there's also pipes
18:53:20 <hpc> byorgey: misremembering
18:53:44 <hpc> i never really used the first two much
19:09:40 <khairulimam> Anyone using social media ...?
19:10:18 <geekosaur> are you implying this isn't?
19:11:48 <byorgey> khairulimam: obviously there are lots of people using social media.  I am not sure what you are really asking.  Are you asking whether people are using social media to discuss Haskell?
19:14:58 <khairulimam> Yes,. Maybe I can connect with them.. I usually connect with people on facebook or Twitter to see their post hope I could get advantages/knowledge of their post
19:16:35 <byorgey> khairulimam: see https://planet.haskell.org/ , and just search for Haskell on facebook and twitter, you will find lots on twitter especially
19:33:04 <xcmw> Does anyone have a working example for the dependent-map library. I tried the one on the homepage but I get errors.
19:34:27 <xcmw> FooGADT which is required by that example gives "Data constructor not in scope:"
19:34:30 <xcmw>   GReadResult
19:43:43 <geekosaur> xcmw, you need to import Data.GADT.Show (which is in the dependent-sum package, which is a dependency of dependent-map)
19:47:11 <xcmw> I imported it
19:48:41 <geekosaur> hm. perhaps you have an older version; the one I checked has it, and does not restrict its exports
19:49:06 <geekosaur> https://github.com/mokus0/dependent-sum/blob/master/src/Data/GADT/Show.hs#L26
19:50:22 <rafal1> Ehllo !
19:50:46 <xcmw> geekosaur: Ok, thanks
19:51:21 <dmj`> rafal1: hi
19:52:08 <rafal1> How's everyone doing tonight ?
19:53:57 <ongy> when I 'cabal sandbox init && cabal install text' I expected it to give me a sandbox with exactly text and all it's dependencies, but I get a mesage that I already have text. Where am I going wrong?
19:54:16 <geekosaur> it's likely in the global package database
19:54:32 <geekosaur> which can't be hidden because it has the runtime and base package in it
19:54:43 <geekosaur> ghc-pkg list --global
19:55:15 <ongy> I have a few things installed global (user-global) so that makes sense
19:56:08 <ongy> oh, that's system global, but it has text
19:56:13 <geekosaur> "user-global" (~/.ghc, or what most people think ~/.cabal is) doesn't count, the sandbox replaces that. it can't replace or hide the global packages (usually /usr/lib/ghc-VER)
19:59:24 <rafal1> skyres molested my son. 
20:03:48 <xcmw> geekosaur: I have the lastest version form stack
20:05:19 <xcmw> geekosaur: https://www.stackage.org/haddock/lts-7.8/dependent-sum-0.3.2.2/src/Data.GADT.Show.html
20:06:25 <xcmw> Guess I have to install from hackage
20:06:38 <geekosaur> xcmw, then I think the example you got requires the git versions of both, or at least something later than that lts
20:06:59 <geekosaur> except that lts is latest, so.
20:07:39 <geekosaur> possibly you just need to install source for stackage's version of dependent-map and check its examples, instead of trying to use the one on github which requires a possibly unreleased version
20:08:10 <geekosaur> (it would make sense that the one on github tracks HEAD)
20:08:41 <xcmw> Installed from Hackage and error disappeared
20:09:20 <geekosaur> so stackage is just lagging for some reason, presumably some dependency is not compatible with other stackage packages yet
20:09:32 <geekosaur> or some dependent hasn't been updated for the new one
20:10:34 <geekosaur> the benefit of snapshots is also the bane of snapshots: stability. nothing can move until everything else that cares works with it
20:22:28 <cads> hey guys, I'd like to do some computational geometry programming and I'm thinking haskell could be a nice environment for it, but I'd also like to use an existing library - CGAL
20:23:03 <cads> it's a c++ library with SWIG bindings available, and I'm wondering if that make things any easier
20:23:23 <erlanger> hi, could any one explain the use of $ in haskell? I mean in the language, not in a regex; thank you so much
20:23:35 <cads> I find some older stuff about swig and haskell but nothing very current
20:23:54 <Clint> erlanger: it's a sometimes-prettier alternative to parentheses
20:24:23 <xcmw> geekosaur: Do you know how to ensure a map has a key based on the type signature?
20:25:11 <erlanger> Clint: thanks, so you use only one $ to say "new association begins here" ?
20:25:50 <hodapp> If you'd otherwise have, say, foo (bar (baz (quux 0))), then you may see things like foo $ bar $ baz $ quux 0. Once you use it a bit it becomes very natural.
20:25:52 <cads> hmm, looks like SWIG doesn't by itself support haskell
20:26:44 <geekosaur> erlanger, $ is just function application with lowest precedence instead of the normal highest
20:28:19 <geekosaur> nothing really special about its use, it's just really convenient for someFunction $ complex expression here
20:28:25 <geekosaur> and similar
20:29:06 <erlanger> thank you so much, I think you guys live up to the good reputation of the haskell community (first time here for me)
20:29:20 <hodapp> :)
20:29:32 <hodapp> have your experiences in other channels been worse?
20:30:15 <erlanger> hodapp: yes, but it was not a haskell channel 
20:30:33 <hodapp> hopefully not the Erlang channel!
20:31:21 <erlanger> hehehe nope, the erlang channel is usually good also :) 
20:31:50 <erlanger> erlang-lisp and you guys are the friendliest of all
20:32:01 <erlanger> (so far)
20:33:10 <hodapp> cads: hmmm, there is always the approach of writing a C wrapper, but that can be quite a pain
20:34:26 <xcmw> geekosaur: I found a lookup method but it returns Maybe. Is there a way to verify at compile time that a map has a key?
20:35:33 <geekosaur> xcmw, I think that requires type level maps, or something like that, so I doubt it. but I suspect I can't really help here
20:49:13 * hackagebot snap-core 1.0.1.0 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.1.0 (DougBeardsley)
