00:07:39 * hackagebot users-mysql-haskell 0.5.1.0 - A mysql-haskell backend for the users library.  https://hackage.haskell.org/package/users-mysql-haskell-0.5.1.0 (DanielDiazCarrete)
00:07:39 * hackagebot users-mysql-haskell 0.5.2.0 - A mysql-haskell backend for the users library.  https://hackage.haskell.org/package/users-mysql-haskell-0.5.2.0 (DanielDiazCarrete)
00:20:06 <Squarism> im planning on writing my own Show and Read for this type http://lpaste.net/343023
00:21:41 <Squarism> For all but PlainCard constructor i could just as well use the default Read / Show mechanism. So i wonder, can i get the name of a constructor, wo using show?
00:26:25 <dmj`> Squarism: With Generics you can, but why not just make a separate data type for PlainCard, this way you can avoid partial functions as well.. | PlainCard Plain, data Plain = Plain { _levy :: Int, _move :: Int }.
00:27:14 <Squarism> good point
00:30:46 <Squarism> dmj`, looking at the Generic class right now. How would i use that to get the name of the constructor?
00:36:04 <dmj`> Squarism: you'd need to call `from` on your data type, then have a typeclass create instances for all the Generic types and their data types (M1, etc). There might be a simpler way of just getting the constructor name with Data.Data
00:38:00 <Xnuk> @hoogle Context -> Socket
00:38:00 <lambdabot> Network.Anonymous.I2P.Types.Session conn :: Context -> Socket
00:38:01 <lambdabot> Network.SocketIO engineIOSocket :: Socket -> Socket
00:38:01 <lambdabot> Idris.Core.DeepSeq forceDefCtxt :: Context -> Context
00:42:34 * hackagebot time 1.7 - A time library  https://hackage.haskell.org/package/time-1.7 (AshleyYakeley)
00:52:35 * hackagebot json-stream 0.4.1.3 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.4.1.3 (ondrap)
01:04:34 <joehh> Hi, I'm having some problems with some memory leaks
01:05:18 <joehh> I haven't been able to reproduce them in "dev" and I wonder if CPU speed could affect the ability of the GC to collect effectively
01:06:10 <joehh> The code is receiving data over the network using conduits, updating some central state via STM TQueues and logging the data
01:06:23 <joehh> data comes in at roughly 20Hz times 6-7 sources
01:06:59 <joehh> In "production", the software is running on a Intel(R) Atom(TM) x7-Z8700  CPU @ 1.60GHz
01:07:05 <joehh> which is fairly slow
01:07:33 <joehh> in that environment, the ram usage increases to about 4gb over approximately 10 hours
01:08:05 <joehh> but on my laptop ("dev") (Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz), I don't see any increases
01:08:18 <joehh> Is it possible that this cpu speed means that the GC does not keep up?
01:08:46 <joehh> or should I be looking harder for innappropriate laziness or something holding on to references?
01:08:56 <joehh> thanks in advance for any thoughts!
01:27:20 <joehh> and this is all with ghc version 7.10.3 (stack lts-6.13)
01:33:11 <wespiser> huh
01:33:59 <wespiser> you've recreating the conditions on your laptop, except the what exactly? the processor?
01:41:42 <wespiser> @unmtl ReaderT EnvCtx (ExceptT LispError (ResourceT ((IO a)))
01:41:43 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
01:41:45 <wespiser> @unmtl ReaderT EnvCtx (ExceptT LispError (ResourceT ((IO a))
01:41:45 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
01:41:53 <wespiser> @unmtl ReaderT EnvCtx (ExceptT LispError (ResourceT (IO a)))
01:41:53 <lambdabot> Plugin `unmtl' failed with: `ReaderT EnvCtx (ExceptT LispError (ResourceT (IO a)))' is not applied to enough arguments, giving `/\A. EnvCtx -> ExceptT LispError (ResourceT (IO a)) A'
01:42:07 <wespiser> @unmtl ReaderT EnvCtx (ResourceT (IO a))
01:42:07 <lambdabot> Plugin `unmtl' failed with: `ReaderT EnvCtx (ResourceT (IO a))' is not applied to enough arguments, giving `/\A. EnvCtx -> ResourceT (IO a) A'
01:42:35 <MarcelineVQ> you can private message lambdabot with /msg lambdabot or /query lambdabot
01:42:37 <Phyx-> @tell ouyout glguy just a note: double-conversion may work out of the box with 8.0.2 without needing that patch. 
01:42:37 <lambdabot> Consider it noted.
01:42:56 <wespiser> thanks!
01:43:34 <wespiser> lol, I finally got right of the "ExceptT MyExpcetion (IO a)" antipattern in my prog. lang tutorial im writing
01:43:53 <wespiser> *got rid of it
01:44:09 <wespiser> moved to monadThrow and ResourceT 
01:54:45 <srhb> wespiser: Isn't unmtl exactly for translating MonadThow, MonadIO etc. into ExceptT, IO, etc ?
02:01:27 <jle`> unmtl is a bit oddly named
02:01:33 <jle`> it should be called untransformers
02:01:52 <jle`> mtl doesn't even define monad transformers
02:02:03 <jle`> i am not ok with this
02:02:11 <jle`> update - i'm kind of ok
02:05:06 <ania123> hi all
02:05:29 <ania123> can one help me, to correct a sentence written in english. It is related to haskell :)
02:06:33 <jle`> best to just ask your question! :)
02:07:02 <ania123> I have added in the smart the countdown problem without documentation implemented in Haskell. Please write the documentation for the program, i.e. describe each functions, types, etc. Write inputs/outputs of the program, describe how do we approach to solve the problem. 
02:12:37 * hackagebot jack 0.7.1.1 - Bindings for the JACK Audio Connection Kit  https://hackage.haskell.org/package/jack-0.7.1.1 (HenningThielemann)
02:12:41 <ania123> jle`: asked :)
02:17:38 * hackagebot alsa-seq 0.6.0.7 - Binding to the ALSA Library API (MIDI sequencer).  https://hackage.haskell.org/package/alsa-seq-0.6.0.7 (HenningThielemann)
02:17:40 * hackagebot http-dispatch 0.6.1.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.6.1.0 (owainlewis)
02:25:16 <joehh> wespiser: sorry for the delay - I've recreated most of the conditions, but the "production" hardware is much slower than my laptop
02:25:27 <joehh> I'm wondering if this could contribute to the leak
02:27:17 <joehh> it seems unlikely, I think I will just have to upload a profiling version to test
02:29:25 <ania123> joehh:
02:29:29 <ania123> hi
02:29:43 <ania123> is your mother language English?
02:29:56 <joehh> yes
02:30:05 <ania123> may I pm you?
02:30:10 <joehh> yes
02:30:29 <ania123> i did
02:30:38 <ania123> did u get my message?
02:31:16 <joehh> not yet - still learning my way around weechat
02:38:44 <pticochon> good morning
03:20:28 <cmdv> hello does anyone use spacemacs and mind pasting how they set up intero or other options in their dotspacemacs-configuration-layer
03:22:40 * hackagebot cmark-sections 0.1.0.2 - Represent cmark-parsed Markdown as a tree of sections  https://hackage.haskell.org/package/cmark-sections-0.1.0.2 (Artyom)
03:43:40 <mmachenry> I'm trying to refactor some code that has a bunch of mutually recursive data types. Player has a character. The character has a player. Rooms have a list of characters in them. Characters have a room they are in. Is there a better way that having one giant module for all my data types?
03:44:21 <mmachenry> I'm considering using some kind of parameterized data type. But that's a bit odd since I know the concrete type it will be.
03:55:27 <EvanR> mmachenry: it sounds more like you have sets of things and relations between those sets
03:55:47 <EvanR> which isnt as straight forward to encode in haskell
03:56:39 <EvanR> but to do what you want, just put all the types in one module
04:08:24 <safiire> Good day to you all.
04:15:24 <mmachenry> EvanR: Yeah, that's what I've done. I guess I'll stick with it. Thanks. 
04:17:43 * hackagebot gore-and-ash 1.2.2.0 - Core of FRP game engine called Gore&Ash  https://hackage.haskell.org/package/gore-and-ash-1.2.2.0 (NCrashed)
04:22:34 <jchia_1> TH question: How can I inspect what reify returns for a given function? In GHC, when I try to runQ $ reify foo, I get an error "Template Haskell error: Can't do `reify' in the IO monad"
04:22:46 <jchia_1> I mean reify 'foo
04:32:22 <AndreasK> Is it reasonable to use the GHC installed by stack as a global GHC? And what would be the best way to go about that? Just adding it to PATH?
04:33:09 <athan> AndreasK: Yeah I just add it to PATH - you should aim for a specific global version though
04:33:23 <athan> when you run `stack ghci`, you'll use the GHC affilliated with your stack.yaml though
04:35:14 <AndreasK> I used stack ghc[i] so far, but atm I want to try and build ghc from source and it expects to find a global ghc so it won't work for that
04:36:45 <athan> ahh yeah, I'd just add `~/.stack/programs/<arch>/<version>/bin` to your PATH
04:37:01 <athan> (not literally, find the dir on your system :x)
04:37:21 <AndreasK> Yeah stack path gives the exact install path already :) Thanks
04:37:41 <athan> :) good luck!
04:57:44 * hackagebot gore-and-ash-logging 2.0.1.0 - Core module for gore-and-ash with logging utilities  https://hackage.haskell.org/package/gore-and-ash-logging-2.0.1.0 (NCrashed)
04:59:14 <mettekou_> Are multi-parameter type classes with functional dependencies (so excluding type classes which represent relations on types, rather than functions) equivalent to type families or can they express something type families cannot?
05:00:05 <athan> associated types are like automatically applied, like how you were saying modeled as functions, not relations
05:00:22 <athan> but in the keys package, you can see an open type family used with typeclasses (Key, I think)
05:00:52 <athan> while associated types usually just make it one-value-per-instance, even if the codomains might vary wildly
05:00:58 <athan> mettekou: ^ :)
05:01:55 <athan> oh wait I completely misunderstood
05:02:16 <athan> you can go in-between functionally deciding and relation
05:02:47 <athan> so `class Foo a b c | a -> b where...` or `class Foo a b c d | a b -> c d where...`
05:03:03 <ertesx> mettekou: fundeps are more expressive; example:  class C a b | a -> b, b -> a
05:03:08 <athan> in the latter, a and b decide c and d, together (that's decent syntax, right? :s)
05:03:29 <athan> but you don't need to be exhaustive
05:04:14 <mettekou> ertesx: Oh right, you can basically express that the inverse relation is also a function?
05:04:17 <athan> also (check me on this), functional deps also need more monomorphism to discretely "point" to uniquely identified types
05:05:54 <ertesx> mettekou: yeah, but i think it's important to separete type families from data/newtype families, because the latter are rather unrelated
05:05:56 <mettekou> athan: Hmmm... I wonder if there isn't a way to express your example with a type family.
05:06:03 <AndreasK> Ghc itself works but (not too surprising) it messes with the package database
05:06:47 <mettekou> ertesx: Yeah, I meant type synonym families and the type-level part of type classes, not the fact that type classes can add functions at the value-level.
05:06:56 <mettekou> Or at the term level, rather.
05:07:36 <athan> mettekou: iirc you can, it's just not as tightly-knit, and instances aren't bound do those constraints :)
05:07:50 <athan> that's also very useful
05:08:05 <athan> I've done heterogeneous recursion a number of times via typeclasses
05:08:16 * athan throws in other big words
05:08:20 <athan> bigly :|
05:09:30 <athan> > (let fix f = let x = f x in x in fix $ "Make recursion " ++) ++ " again"
05:09:33 <lambdabot>  <hint>:1:60: error: parse error on input ‘)’
05:09:36 <athan> :x
05:10:16 <ertesx> mettekou: there is a lot of overlap in use cases, and in those cases choose the solution that seems more reasonable to you…  i go with fundeps a lot, simply because they are less to type (they let you name the related things instead of forcing you to use a type function), but in algebraic patterns i often use ATs
05:23:21 <surina> I'm trying to parse a log message from String (for example "E 2 148 #56k istereadeat lo d200ff] BOOTMEM", where 'E' is the type of the log message, 2 is the error type in this case, 148 is the timestamp and rest of the String is the message. Do I have to use many nested case () of expressions or is there some better way to do it?
05:24:34 <pavonia> This looks like a great usecase for parser combinators like one of the *parsec libraries
05:24:41 <ertesx> surina: you can split the message at ' ' three times
05:24:54 <fawfwafafew> Anyone here?
05:25:14 <MarcelineVQ> pavonia: it's from week 2 of http://cis.upenn.edu/~cis194/spring13/lectures.html
05:25:34 <pavonia> Oh, okay
05:25:44 <fawfwafafew> Can someone help me quickly? :)
05:25:45 <ertesx> surina: pavonia's solution is more convenient though, because parsers fail with useful messages
05:26:10 <ertesx> surina: try megaparsec
05:26:57 <pavonia> fawfwafafew: Rule #1 of IRC: Just ask your actual question
05:27:45 * hackagebot gore-and-ash-network 1.4.0.0 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.4.0.0 (NCrashed)
05:28:37 <fawfwafafew> So I have a function that should return a Maybe String, so I have a guard that does similar to this: foo s | (condition) = Just "bar" : foo (take 3 s)
05:29:01 <fawfwafafew> How can I print out a Just String but keep on calling the function until it's empty?
05:30:29 <fawfwafafew> I tried to do this as well, Just (foo (take 3 s) ++ "bar")
05:30:32 <fawfwafafew> That didn't work either.
05:31:14 <pavonia> Do you want the result to be of type Maybe String or [Maybe String]?
05:31:39 <fawfwafafew> A Maybe String.
05:31:54 <fawfwafafew> foo :: String -> Maybe String
05:32:33 <jchia_1> I was asking earlier about how to inspect the result of reify 'foo. I found the answer. I can use runIO to dump it during compilation.
05:32:40 <pavonia> fawfwafafew: And what do you want to do with the result of the recursive call?
05:33:22 <fawfwafafew> So I have multiple guards that would create a Maybe String 
05:33:28 <fawfwafafew> Like converting a string you could say.
05:34:28 <pavonia> So you probably don't need to call foo in the result then
05:34:39 <fawfwafafew> No? But I need to do it recursively, no?
05:35:02 <pavonia> Well, that's what I'm asking, what is the recursive call for?
05:35:23 <ertesx> fawfwafafew: you have a function you want to *iterate*? ;)
05:35:32 <fawfwafafew> Oh it's supposed to be: foo s | (condition) = Just "bar" : foo (drop 3 s)
05:35:46 <fawfwafafew> So I make the string shorter and shorter, and replaces a certain part of a string with another character.
05:36:36 <pavonia> That would give a list of Maybe's as result
05:36:56 <fawfwafafew> Well it won't even compile for me.
05:37:03 <fawfwafafew> And I don't want a list of it, I just want one Maybe String
05:37:12 <pavonia> Yeah, it has the wrong type
05:37:18 <fawfwafafew> Like Just(foo (drop 3 s) ++ "bar")
05:37:24 <jophish> It would be nice if aeson was able to warn when extra keys are present
05:37:38 <jophish> but perhaps that goes against the spirit of JSON
05:37:41 <pavonia> fawfwafafew: Again, why the recursive call?
05:37:56 <ertesx> @let import qualified Data.List.NonEmpty as N
05:37:58 <lambdabot>  Defined.
05:38:18 <fawfwafafew> What could I do instead? Because I want to replace certain infixes in a string with a character.
05:39:31 <ertesx> fawfwafafew: write a function that does one step and indicates somehow when nothing happened
05:40:01 <ertesx> fawfwafafew: rep :: String -> Maybe String  -- return Nothing if there was nothing to replace
05:40:25 <pavonia> Just ("bar" ++ drop 3 s) perhaps, but it's hard to tell without more information
05:40:28 <ertesx> fawfwafafew: then use 'iterate'
05:40:33 <ertesx> fawfwafafew: or 'unfoldr'
05:40:36 <surina> How does <$> operator differ from $?
05:41:03 <fawfwafafew> The thing is that I iterate over 4 characters from start every time, and replace those 4 characters with one.
05:41:40 <ertesx> fawfwafafew: but you want to be able to print each individual step?
05:41:52 <fawfwafafew> No, just one single Just String of it.
05:41:53 <surina> Oh <$> is a functor
05:42:12 <surina> no it's not
05:42:20 <Tuplanolla> @src (<$>)
05:42:20 <lambdabot> f <$> a = fmap f a
05:42:38 <fawfwafafew> So, "12341234123412341234" = "abcdef"
05:42:57 <fawfwafafew> And 1234 = different combinations of 4 characters.
05:44:05 <fawfwafafew> Like 1234 = a, 1234 = b, 1234 = c, and so on.
05:44:17 <ertesx> @let rep [] = Nothing; rep xs0@(x:xs) | "1234" `isPrefixOf` xs0 = Just ("a", drop 4 xs0) | otherwise = Just (x, xs)
05:44:18 <lambdabot>  .L.hs:166:17: error:
05:44:18 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
05:44:18 <lambdabot>        Expected type: Maybe ([Char], [Char])
05:44:40 <ertesx> @let rep [] = Nothing; rep xs0@(x:xs) | "1234" `isPrefixOf` xs0 = Just ("a", drop 4 xs0) | otherwise = Just ([x], xs)
05:44:42 <lambdabot>  Defined.
05:44:53 <ertesx> > rep "1234hgdh"
05:44:55 <lambdabot>  Just ("a","hgdh")
05:45:00 <ertesx> > rep "2234hgdh"
05:45:02 <lambdabot>  Just ("2","234hgdh")
05:45:21 <ertesx> > unfoldr rep "1234abgd1234tewrh12346"
05:45:24 <lambdabot>  ["a","a","b","g","d","a","t","e","w","r","h","a","6"]
05:45:32 <ertesx> > concat (unfoldr rep "1234abgd1234tewrh12346")
05:45:35 <lambdabot>  "aabgdatewrha6"
05:45:42 <ertesx> actually that was stupid
05:45:43 <ertesx> @undef
05:45:43 <lambdabot> Undefined.
05:45:53 <ertesx> @let rep [] = Nothing; rep xs0@(x:xs) | "1234" `isPrefixOf` xs0 = Just ('a', drop 4 xs0) | otherwise = Just (x, xs)
05:45:55 <lambdabot>  Defined.
05:45:58 <ertesx> > unfoldr rep "1234abgd1234tewrh12346"
05:46:02 <lambdabot>  "aabgdatewrha6"
05:46:13 <ertesx> fawfwafafew: ^ like this?
05:46:20 <fawfwafafew> Yeah, kind of
05:46:42 <fawfwafafew> What if you have multiple ones?
05:46:53 <ertesx> multiple what?
05:47:01 <fawfwafafew> Like "1234", "5678"
05:47:09 <fawfwafafew> I want to compare a lot of different 4 characters.
05:47:14 <ertesx> then 'rep' has to handle multiple ones
05:48:48 <fawfwafafew> I think I got an idea now of it, thanks! :)
05:48:49 <fawfwafafew> Ciao.
05:49:07 <ertesx> fawfwafafew: if you have lots of such replacements and you want it to be efficient, a trie will help you
05:49:44 <ertesx> unfortunately the only good trie implementation i know is bytestring-trie, which works only on bytestring
05:50:12 <ertesx> but it's probably easy enough to make it work with Text (or use UTF-8-encoded ByteString everywhere)
05:50:56 <kirillow> what is the mempty of a type with one nullary data constructor?
05:51:18 <ertesx> kirillow: every monoid must have an identity
05:51:28 <ertesx> kirillow: that leaves you really only one choice, doesn't it?
05:51:59 <kirillow> ...i HOPE its that very nullary data constructor
05:52:14 <ertesx> kirillow: let's call it X
05:52:19 <ertesx> kirillow: mappend X X = ?
05:52:27 <kirillow> X
05:52:32 <kirillow> !
05:52:41 <ertesx> good…  is X the identity of that mappend?
05:53:01 <ertesx> i.e. is it the case that for all y (mappend y X = y)?
05:53:18 <kirillow> yes
05:53:21 <ertesx> and is it the case that for all y (mappend X y = y)?
05:53:28 <kirillow> well
05:53:39 <surina> ertesx: What function can I use to split the message at ' ' N times?
05:54:21 <ertesx> surina: 'span' or 'break'
05:54:50 <Tuplanolla> There's the `split` package too, surina.
05:55:23 <ertesx> i recommend using neither 'span' nor 'break' nor the 'split' package…  i recommend using Text instead, which comes with splitting functions
05:55:50 <ertesx> surina: https://hackage.haskell.org/package/text
05:56:21 <MarcelineVQ> it's from introductory material ertesx, to get comfortable with pattern matching and the basic libs
05:56:30 <ertesx> ah, ok
05:56:45 <ertesx> surina: then scratch my last remark =)
05:58:03 <surina> That's true
05:58:15 <surina> ertesx: Thank you anyway :)
05:58:46 <surina> I'm still wondering if there is a better way than using a bunch of case () of expressions
05:59:29 <surina> Like with the basic libs
05:59:31 <MarcelineVQ> I'd use span or words
05:59:51 <ertesx> surina: let (s1, r1) = break (== ' ') xs; (s2, r2) = break (== ' ') r1; … in …
06:01:53 <surina> ertesx: Is xs defined in this case?
06:02:18 <ertesx> surina: that's the line you're splitting
06:02:27 <ertesx> oh, wait
06:02:28 <surina> ertesx: Oh I see
06:02:39 <ertesx> that's not going to work, because:
06:02:47 <ertesx> > break (== ' ') "abc def ghi"
06:02:49 <lambdabot>  ("abc"," def ghi")
06:03:04 <ertesx> 'break' leaves the space in the suffix string
06:03:23 <surina> Yeah
06:03:27 <surina> Hmm..
06:03:31 <Wizek_> Hey, anyone knows if/how it would be possible to run handler code directly in tests for Yesod? More info on what I've tried so far: http://stackoverflow.com/a/40688369/499478
06:03:37 <ertesx> at this stage i recommend using 'case'
06:03:47 <ertesx> don't worry, there will be much better ways, once you learn more
06:04:03 <surina> ertesx: Ok that I shall do. Thanks for your help!
06:04:47 <ertesx> surina: you need two patterns in each case:  (s1, ' ' : r1) and (_, _)
06:04:58 <ertesx> surina: the latter is for the case when no more ' ' could be found
06:05:52 <surina> ertesx: Ok, thanks :)
06:05:53 <ertesx> > break (== ' ') "abcdef"
06:05:55 <lambdabot>  ("abcdef","")
06:06:03 <MarcelineVQ> you can avoid nesting the cases by doing something like `case words xs of ("E":y:z:zs) -> ...` you'd need to unwords zs when you want to put the line back together though
06:06:38 <ertesx> i was going to recommend 'words', too, but it has a nasty habit
06:06:55 <ertesx> unfortunately unwords . words ≠ id
06:07:13 <MarcelineVQ> it eats multiple spaces yes?
06:07:18 <ertesx> yeah
06:08:16 <surina> ertesx: words is nasty because the string might be very long and contain afwul amount of words?
06:08:26 <surina> awful*
06:08:32 <ertesx> surina: no, because it isn't invertible
06:08:44 <ertesx> > word "a b c d     e          f"
06:08:44 <surina> ertesx: Oh ok
06:08:46 <lambdabot>  error:
06:08:46 <lambdabot>      • Variable not in scope: word :: [Char] -> t
06:08:46 <lambdabot>      • Perhaps you meant one of these:
06:08:51 <ertesx> > words "a b c d     e          f"
06:08:53 <lambdabot>  ["a","b","c","d","e","f"]
06:09:00 <ertesx> surina: do you see the problem?
06:09:06 <surina> ertesx: Yes I see it
06:10:02 <ertesx> surina: you can write your own version of 'words' that is invertible, then you can use MarcelineVQ's much more beautiful pattern
06:11:59 <surina> What makes this a little bit more difficult is the fact that the log message might not be valid.
06:14:29 <MarcelineVQ> difficult in that you need to repeat the failure case when you're nesting?
06:15:30 <MarcelineVQ> ertesx: parsing failure produces an: Unknown <verbatem log line>
06:15:35 <surina> MarcelineVQ: yes
06:16:06 <ertesx> surina: yeah, as i said there will be much better ways to handle this
06:16:10 <surina> also I don't see the difference between break and span
06:16:26 <ertesx> break p = span (not . p)
06:16:29 <surina> ertesx: Using Parsec library?
06:16:40 <ertesx> surina: not necessarily
06:17:40 <surina> ertesx: You mean this "let (s1, r1) = break (== ' ') xs; (s2, r2) = break (== ' ')  r1; … in …
06:18:38 <ertesx> surina: ultimately you will be able to rewrite this to:  do w1 <- nextWord; w2 <- nextWord; w3 <- nextWord; r <- rest; …
06:19:11 <ertesx> surina: but it requires the introduction of something your tutorial probably hasn't covered yet, if it's at basic pattern matching =)
06:19:39 <surina> ertesx: Actually I'm somewhat familiar with the notation
06:19:49 <ertesx> surina: from IO i presume
06:20:23 <surina> ertesx: Yes, but you can use the do notation with other Monads as well?
06:20:31 <ertesx> yeah
06:20:46 <ertesx> > do x <- Just 5; y <- Just 7; pure (x + y)
06:20:48 <lambdabot>  Just 12
06:26:30 <osfameron> am I missing an obvious function :: a -> Bool -> Maybe a ?
06:26:51 <osfameron> e.g. the equivalent of if b then Just a else Nothing
06:26:56 <osfameron> (didn't find anything on Hoogle)
06:27:26 <ertesx> osfameron: i think it doesn't exist, but:
06:27:48 * hackagebot gore-and-ash-async 1.1.1.0 - Core module for Gore&Ash engine that embeds async IO actions into game loop.  https://hackage.haskell.org/package/gore-and-ash-async-1.1.1.0 (NCrashed)
06:27:48 <ertesx> :t x p -> guard p *> pure x
06:27:49 <lambdabot> error: parse error on input ‘->’
06:27:50 * hackagebot flaccuraterip 0.3.7 - Verify FLAC files ripped form CD using AccurateRip"  https://hackage.haskell.org/package/flaccuraterip-0.3.7 (NicolaSquartini)
06:27:52 * hackagebot stm-supply 0.2.0.0 - STM wrapper around Control.Concurrent.Supply.  https://hackage.haskell.org/package/stm-supply-0.2.0.0 (jmc41493)
06:27:54 <ertesx> :t \x p -> guard p *> pure x
06:27:55 <lambdabot> Alternative f => b -> Bool -> f b
06:28:12 <lpaste> surina pasted “No title” at http://lpaste.net/343245
06:28:20 <MarcelineVQ> osfameron: the safe package has that as a hidden helper, but it's not publicly exported iirc
06:28:47 <surina> ertesx: So I would have to make a Monad instance of that, so I can use the do notation above?
06:28:51 <osfameron> ertesx: aha, cute, but over the top (especially as this is for some simple tutorial code ;-)
06:29:00 <osfameron> MarcelineVQ: thanks
06:29:19 <ertesx> surina: no, and i can't summarise it on a few IRC lines either…  please be patient until your introduction covers the topic itself
06:29:31 <surina> ertesx: ok
06:29:54 <ertesx> surina: also i would get rid of the Unknown case
06:30:24 <ertesx> surina: use (Either String) in the case when you need an additional failure value
06:30:31 <surina> ertesx: That is given in the CIS 194 exercise that I'm doing
06:30:41 <ertesx> hmm, i see
06:30:45 <surina> http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
06:31:42 <MarcelineVQ> osfameron: oh okay it's not quite the same http://hackage.haskell.org/package/safe-0.3.10/src/Safe/Util.hs
06:32:19 <MarcelineVQ> anyway it may not be around because it's so straightforward that you just wrote it yourself in under 10 words
06:32:36 <osfameron> MarcelineVQ: that's also true yeah ;-)
06:32:48 * hackagebot gore-and-ash-actor 1.2.2.0 - Gore&Ash engine extension that implements actor style of programming  https://hackage.haskell.org/package/gore-and-ash-actor-1.2.2.0 (NCrashed)
06:33:26 <osfameron> but many functions do have simple implementations, so I was surprised not to find it (as it seemed like an obvious thing to want to do... but perhaps it isn't and is a code smell)
06:34:03 <MarcelineVQ> idk about smell, it's not in base but it is around http://hackage.haskell.org/package/data-easy-0.7.0/docs/Data-Easy.html#v:boolToMaybe
06:34:19 <ertesx> if you include every function that someone found useful at some point and has a simple definition, the base library would probably collapse into a black hole =)
06:34:22 <osfameron> so I guess there I could use liftMay id id, but again, it's overkill, I'll just write the short function myself :D
06:34:32 <Shou> Can I set a class constraint on a whole type family? E.g. Default (MyFamily a) and only family instances that conform are accepted.
06:34:43 <osfameron> hehe, yes indeed
06:35:18 <ertesx> the thing is:  "this is so simple, i can't believe it's not predefined" is a good reason why something probably should *not* be predefined
06:36:50 <Tuplanolla> I'm in favor of defining even useless functions if they are somehow dual or analogous to other useful functions.
06:37:08 <MarcelineVQ> osfameron: http://hackage.haskell.org/package/utility-ht-0.0.12 has a ton of things like that you might like, including toMaybe :: Bool -> a -> Maybe a
06:37:30 <Tuplanolla> Some things should exist just for the sake of existing.
06:38:28 <osfameron> MarcelineVQ: thanks :-)  (though the fact it's called "utility" is a warning sign ;-)
06:38:56 <MarcelineVQ> breakAfter :: (a -> Bool) -> [a] -> ([a], [a]) guess that this one does :>
06:39:11 <fawfawfwae> Yo, how come this list won't compile? https://gist.github.com/anonymous/e6f052f76a6bced974b11938d51eda23
06:40:20 <Tuplanolla> Don't use `let` at top level, fawfawfwae.
06:40:21 <MarcelineVQ> in a file? you can't use let at the top level
06:40:33 <fawfawfwae> Oh, no?
06:40:45 <fawfawfwae> It complies, woo!
06:40:51 <fawfawfwae> Someone care to explain to em why?
06:40:53 <fawfawfwae> me*
06:43:10 <MarcelineVQ> the top level is restricted to 'declarations' but a let is a let 'expression', I don't know why that disctinction is strictly necesary though
06:44:01 <MarcelineVQ> I guess because expressions exist to be reduced so there's a neccesary distinction, not suuure
06:44:56 <Tuplanolla> It prevents local type definitions and other funky things that ought to be possible, MarcelineVQ.
06:45:36 <Tuplanolla> Consider local instance definitions for example.
06:47:48 * hackagebot gore-and-ash-sync 1.2.0.1 - Gore&Ash module for high level network synchronization  https://hackage.haskell.org/package/gore-and-ash-sync-1.2.0.1 (NCrashed)
06:52:49 * hackagebot median-stream 0.4.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.4.0.0 (jmc41493)
06:52:51 * hackagebot median-stream 0.5.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.5.0.0 (jmc41493)
06:52:51 <jabley> Hello. I'm seeing a problem trying to clone the repo.
06:52:53 <jabley> https://gist.github.com/jabley/806141b9e368ee55adb99db0b82df018
06:53:14 <jabley> This is seen when I'm trying to install ghc on MacOS Sierra
06:58:22 <jabley> I'm using git 2.10.0
06:59:24 <MarcelineVQ> try git clone --recursive git://github.com/ghc/ghc instead
06:59:45 <MarcelineVQ> re: https://ghc.haskell.org/trac/ghc/wiki/Newcomers
07:01:11 <MarcelineVQ> the git config line mentioned there may matter for you as well
07:03:50 <jabley> Still get failures to clone Cabal...
07:04:08 <jabley> https://www.irccloud.com/pastebin/MjSlkInz/clone-errr.sh
07:05:25 <MarcelineVQ> hmm quite odd, I'm not able to reproduce the issue
07:05:44 <jabley> http://stackoverflow.com/questions/21971941/invalid-author-committer-line-missing-space-before-email
07:06:04 <jabley> The commit in question is ancient, so I'm not sure what's different on my current laptop
07:06:18 <jabley> https://git.haskell.org/packages/Cabal.git/commit/cc2f67f98fbc246f010516c71722d5c3432e0a2b
07:07:17 <hvr> I honestly doubt we're going to fix that
07:07:33 <hvr> as that would require to rewrite all of Cabal's git history which would be a big mess
07:08:09 <hvr> jbalint: which version is your git?
07:08:35 <jabley> I wouldn't expect to see people rewrite Cabal's history like that
07:08:47 <jabley> git 2.10.0
07:10:22 <Welkin> history has been rewritten!
07:10:26 <Welkin> it's a time paradox!
07:10:30 <Welkin> we are all doomed
07:10:58 <circ-user-eGcqb> You say that Functor takes a container, a function and produced container whose every element updated according to that function. And, function is also a functor. What does that mean?
07:11:03 <circ-user-eGcqb> Which containers/values to function take, which functions they take to apply to those containers?
07:11:15 <hvr> jabley: ok... the latest git I have here is git 2.9.x :-/
07:11:46 <hvr> jabley: so it's difficult for me to reproduce... however, I honestly hope they'll make Git a bit more tolerant again
07:12:05 <hvr> previous versions would complain about that commit when you 'git fsck'
07:12:09 <Welkin> circ-user-eGcqb: you are just babbling
07:12:11 <MarcelineVQ> hmm I'm on 2.10.2 and don't experience the problem, perhaps it's a setting
07:12:13 <Welkin> circ-user-eGcqb: you make no sense at all
07:12:20 <hvr> but they would let you clone it
07:12:24 <byorgey> circ-user-eGcqb: you can think of a function  (a -> b)  as a "container" which contains one value of type 'b' for every value of type 'a'
07:12:51 <byorgey> Welkin: that's not an appropriate way to respond to someone asking a question.
07:12:56 <jabley> Just downgrading back to 2.9.0 and seeing if that fixes it
07:13:40 <jabley> Otherwise it could be something in my .gitconfig, but the only thing I've changed with that recently is making sure I sign all commits
07:22:22 <circ-user-eGcqb> byorgey: Wow, sounds cool. You restore my faith in humanity!
07:26:37 <jabley> No, 2.9.0 gives the same issue
07:26:42 <jabley> Config is https://github.com/jabley/homedir/blob/master/.gitconfig
07:31:42 <jabley> Okay, I reckon it's because I have various `fsckobjects = true` set up. I mustn't have had that last time I built ghc
07:33:48 <MarcelineVQ> that does seem to be it, adding that section to mine causes the same failure
07:34:51 <jabley> Thanks for the help 👍
07:35:03 <jabley> PEBKAC, as usual ;)
07:43:12 <joe9> source https://github.com/joe9/betfair-api/blob/master/src/Betfair/APING/API/GetResponse.hs , error: http://codepad.org/2FUmtC8m . any suggestions on how I can derive instances for a hidden data type?
07:46:06 <joe9> on lines 35, 36 is my deriving instance line
07:46:23 <joe9> I am trying to derive Generic for the Request data type. It has typeable
07:47:27 <joe9> I am not sure if I can derive Generic from Typeable
07:49:32 <lyxia> they are quite different typeclasses
07:50:16 <lyxia> joe9: the error you have has nothing to do with whether you can derive these classes
07:50:41 <lyxia> have you added the package http-client to your .cabal
07:51:26 <lyxia> oh it's just hidden
07:51:31 <MarcelineVQ> lyxia: I think that would be a hidden member error, this is a hidden module
07:51:56 <lyxia> MarcelineVQ: you are right, my bad
07:51:57 <joe9> lyxia: yes, it is in my .cabal, but, that module (I think) is hidden.
07:52:26 <joe9> lyxia: the data type hase Typeable derived
07:52:27 <Welkin> you mean not exported?
07:52:51 * hackagebot reactive-midyim 0.3 - Process MIDI events via reactive-banana  https://hackage.haskell.org/package/reactive-midyim-0.3 (HenningThielemann)
07:52:53 * hackagebot reactive-balsa 0.3 - Programmatically edit MIDI events via ALSA and reactive-banana  https://hackage.haskell.org/package/reactive-balsa-0.3 (HenningThielemann)
07:52:55 * hackagebot reactive-jack 0.3 - Process MIDI events via reactive-banana and JACK  https://hackage.haskell.org/package/reactive-jack-0.3 (HenningThielemann)
07:53:10 <joe9> Welkin: I have it exported line 23
07:53:11 <lyxia> I wonder whether it is a good idea to derive ToJSON for Request
07:53:13 <valerio> hi guys, stupid question: how to get the floor out of a logBase? i can't find anything and ghci keep on giving me errors!
07:53:30 <MarcelineVQ> *member of a hidden package error
07:53:44 <lyxia> surely there is a better thing to do
07:53:55 <joe9> lyxia:  I am trying to pretty print without using String. Instead of trying to build a pretty text printer, I am trying to leverage aeson-pretty to print it out.
07:55:17 <lyxia> Request contains a function BTW so you can't derive Generic anyway.
07:55:28 <lyxia> Much less ToJSON
07:57:01 <lyxia> What am I saying, you can derive Generic. But serializing functions is still impossible.
07:57:26 <joe9> lyxia: fair enough, I want to do what it's Show instance does.
07:57:54 <joe9> lyxia: there is a Show instance for Request. I want to show that in json.
07:58:42 <joe9> lyxia: or, I can write a ToJSON instance for Request without using deriving.
07:59:02 <joe9> lyxia: basically, a wrapper using the Show instance.
08:00:59 <lyxia> I think you'll have to write it by hand
08:01:17 <ph88> in this SO answer http://stackoverflow.com/a/8245394 why is the guy saying "instead of monomorphic ReadMemory Word8" when his data constructor is defined as "ReadMemory Word16" ??
08:02:07 <joe9> lyxia: ok, Thanks.
08:04:28 <lyxia> ph88: I think it's a typo
08:04:54 <lyxia> ph88: ReadMemory will be a value of type ExecutionAST t instead of monomorphic ExecutionAST Word8
08:04:57 <geekosaur> looks to me like the point is you can use one of the Word8 constructors in a Word16 context, and the GADT is to avoid that
08:05:54 <geekosaur> ...oh, right, that part is a typo because they were thinking of that mismatch when writing that
08:06:05 <ph88> lyxia, you think the typo in on the data constructor ?
08:06:59 <lyxia> ph88: I mean that he writes ReadMemory twice instead of ExecutionAST.
08:07:05 <ph88> oooh right i see it now
08:08:00 <ph88> maybe i shall correct that ?
08:08:05 <Squarism> I can only find cumbersome solotions to this "simple" task. Say i have list [A,B,C]. I want [(0,A),(<hieght A>,B),(<hieght B>,C)]. What list function fixes this for me. How height X is calculated is not important.
08:08:15 <lyxia> ph88: go ahead
08:09:00 <lyxia> zip (0 : map height list) list
08:09:18 <Rembane> Squarism: zipWith is also nice.
08:09:21 <Rembane> :t zipWith
08:09:22 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:11:21 <ph88> why can't haskell figure out that  ExecutionAST t  is not  ExecutionAST t  when the t's are different? i mean why does this go wrong on runtime and can't be infered on compile time?
08:11:52 <Squarism> lyxia, Rembane : i knew it! Allways as simple solution in FP land
08:11:57 <Squarism> thanks
08:14:01 <lyxia> ph88: I'm not sure what you mean by that
08:14:13 <Rembane> Squarism: No worries. Good luck! :D
08:14:29 <lyxia> ph88: isn't the point of the GADT that it will not go wrong
08:15:55 <ph88> lyxia, he starts his explanation by saying GADT's give extra type safety, and ends that paragraph with saying that compile-time errors are better than runtime-errors. Implying that without GADT's you would get runtime errors when you do  a = Bind (ReadMemory 1) (WriteRegister2 x)  where 1 and x are different types
08:16:45 <glguy> ph88: It looks like you're interpreting the sentence backwards
08:16:59 <ph88> so with GADT's you can specifically tell the compiler to check for that. And my question is: why do i have to tell this to the compiler (with GADT's) and can't it check himself if the t's in  ExecutionAST t  are of the same type
08:17:52 * hackagebot gore-and-ash-sdl 2.1.1.0 - Gore&Ash core module for integration with SDL library  https://hackage.haskell.org/package/gore-and-ash-sdl-2.1.1.0 (NCrashed)
08:18:18 <lyxia> ph88: it's not only that the t's are the same, but that they are consistent with the constructors you use.
08:18:39 <ph88> oh
08:18:51 <ph88> since WriteRegister2 is a different constructor ..
08:19:00 <ph88> yes was already wondering were the 2 is coming from
08:19:14 <ph88> oh it's in the openingspost
08:19:53 <sachin> Hey i am noob to haskell
08:20:00 <ph88> hi noob
08:20:04 <sachin> A small question?
08:20:08 <ph88> sure
08:20:51 <sachin> If functional programming is so powerful, why are many companies still going with Java, Python and other imperatives?
08:21:17 <hpc> being good has very little correlation with being used
08:21:28 <hpc> see also, microsoft access
08:21:33 <lyxia> because they are already well established, so if something goes wrong, it's not the fault of the one who chose the language
08:21:37 <imalison> I'm looking for some help with existential types -- in particular, I would like to create a heterogenous list of LayoutClasses (from XMonad) and later join them all together to construct a layoutHook.
08:22:17 <imalison> I've actually succeeded in making the heterogeneous list with the following type data LayoutBox a = forall l. (LayoutClass l a) => LB (l a)
08:22:26 <sachin> Does that mean Haskell doesnt scale well?
08:22:35 <ph88> lol
08:23:37 <imalison> The issue is that i can't recover the original layout class using a function like unBoxLayout (LB layout) = layout
08:24:21 <ph88> no it just means that companies stick to the language they know, or use the same language as their neighbour. So they look at "what works" as opposed to "what works best"
08:24:35 <imalison> the compiler gives me a error about the type l escaping its original context
08:24:42 <mthek> sachin: my best guess is that, Haskell is a language that takes more time for people to learn. Most imperative languages, particularly those that are very popular like JavaScript / Python are very intuitive and easy to pick up and get started with. Haskell takes more of a time investment for the programmer. 
08:24:59 <joe9> is there any way to make this work: data JsonBody a = (Generic a, ToJSON a) => JsonBody a deriving (Generic ,ToJSON)
08:25:14 <byorgey> mthek: as someone who regularly teaches imperative languages to college students, I can tell you that they are *not* intuitive and easy to pick up.
08:25:20 <larryba> they are easy to pick up when you have already picked up half a dozen imperative languages prior to learning a new one
08:25:39 <ph88> imalison, have you tried forall ?
08:25:41 <lyxia> imalison: indeed you can't define a function that just deconstructs LayoutBox and returns the contents. you must do produce a type that doesn't depend on the existentially quantified l.
08:25:43 <mthek> sachin: we have a tendency to go for the path of least resistence and consider numbers (popularity) a sign of a successful language, which is only partially true (the partial part being that popular languages have usually a lot of tooling and libraries)
08:26:03 <mthek> byorgey: That gives me hope and confidence ;)
08:26:11 <byorgey> =)
08:26:46 <imalison> ph88: yes see my code example
08:26:53 <ph88> yeah sorry read over it ^^
08:27:11 <imalison> i think the problem is that I'm trying to return the unboxed layout as a value
08:27:26 <imalison> and really i need to keep it in boxed form, until the moment I need to use it
08:27:57 <mthek> byorgey: I am still a relative novice but found that in imperative languages (in which I have far more experience) it was easier to get started, even though it often meant writing terrible code
08:28:01 <lyxia> imalison: you must deconstruct it in the function that uses it.
08:28:19 <mthek> byorgey: Haskell forces you to understand fundamentals, which is why I love it
08:28:34 <imalison> lyxia: haha yeah thats what I just wrote that I suspected above
08:28:37 <mthek> byorgey: but it takes more time initially, and probably saves a lot of time later on 
08:28:51 <imalison> lyxia: so basically theres no way to return a value that is simply the type class
08:28:57 <lyxia> joe9: There isn't much support for generic programming with existential types
08:29:31 <lyxia> imalison: right
08:29:34 <byorgey> mthek: yes, I think a lot of people have that reaction
08:29:39 <byorgey> mthek: I am just curious though, when did you learn your very first imperative language?
08:30:20 <mthek> byorgey: I started with assembly when I was 11/12 and then pretty quickly ended up learning PHP, several years later moving to Python 
08:30:30 <ph88> mthek, why you say haskell forces that ?
08:31:02 <byorgey> mthek: see, I wonder if it actually took you a lot more time to get started at first, but you didn't notice because you were 11/12 and having fun =)
08:31:34 <suppi> what are the main differences between trifecta and megaparsec for PL? Specifically I'm interested in partial parsing and error recovery
08:31:59 <joe9> lyxia: ok, Thanks.
08:32:09 <ph88> suppi, what's PL ?
08:32:12 <sachin> Sorry got disconnected
08:32:30 <ph88> there are channel logs
08:32:33 <suppi> ph88: i mean parsing programming languages
08:32:49 <sachin> Thanks <ph88>
08:32:53 * hackagebot median-stream 0.6.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.6.0.0 (jmc41493)
08:33:03 <mthek> ph88: I mean it in a very positive way. Take lambda calculus, without understanding it (it's not particularly hard but takes some hours) you pretty quickly get lost. The same with the type system (compared to languages with dynamic typing). Where in other languages recursion is through a defined keyword (for, while etc,) in Haskell you need to understand evaluation etc.
08:33:04 <ph88> suppi, i'm using megaparsec, but haven't tried trifecta
08:34:10 <mthek> byorgey: you could be very right, but I think that is a little bit the problem with many imperative languages that are easy to get started with, e.g. JS, is that it gives instant gratification to the person who is learning it
08:34:32 <suppi> ph88: any comment on the points i mentioned?
08:35:01 <Profpatsch> mthek: I think that tells more about the language infrastructure than the language.
08:35:27 <Profpatsch> mthek: e.g. it’s so easy to get started with JS because you can just fool around with the Devtools.
08:35:44 <Profpatsch> And because everyone wants to script a webpage sooner or later.
08:35:54 <byorgey> mthek: sure, and that's why I'm excited by initiatives such as CodeWorld (http://code.world), and why I'm working on a simple language and web-based IDE to teach FP + discrete math (http://github.com/disco-lang/disco)
08:35:57 <mthek> Profpatsch: That's an interesting point, are you essentially saying if we put in the work, you can create a path for people learning Haskell more "as you go along" instead of "after you've studied it"
08:36:18 <mthek> byorgey: very interesting, let me check them out
08:36:25 <Profpatsch> mthek: See “Haskell from first principles”
08:36:31 <Profpatsch> Disclaimer: haven’t read it.
08:36:48 <ph88> suppi, for partial parsing you will have to provide default to make your type complete. Suppose you have data Foo Int Int, and you have input "1" instead of "1 2", then you will have to give a default value.
08:37:07 <Profpatsch> yes, you always learn as you go along, but no, you still need to know the basics in order to do “real” programming
08:37:16 <Profpatsch> Everything else is cargo cult imho.
08:37:25 <mthek> Profpatsch: that's how I got into Haskell, that book has made me fall in love with the language
08:37:33 <Profpatsch> And there is *a lot* of cargo culting out there.
08:37:53 * hackagebot hledger-interest 1.5.1 - computes interest for a given account  https://hackage.haskell.org/package/hledger-interest-1.5.1 (PeterSimons)
08:38:07 <nitrix> That's Rust. Here we cabal :)
08:38:10 <suppi> ph88: what about stopping and continuing later, like with coroutines, is it possible with megaparsec?
08:38:48 <sachin> Asking this just out of curiosity?
08:38:51 <mthek> Profpatsch: I couldn't agree more with you, my point is also not "don't do the work" (I personally actually love that part of it) but I think initiatives like byorgey's are crucial to popularise a language (because at the end of the day, it creates a lot of crap but amongst the volume will be quality work, tooling, infra etc.)
08:39:07 <ph88> suppi, suppose you are taking a random piece of text that wouldn't necessarily start at the root node of your grammer you could just try a bunch of parsers until one succeeds. For parser importance i would recommend a breath-width ordering of the parser functions according to the matching tree of your types.
08:39:38 <ph88> suppi, i'm just trying to say that "partial parsing" can mean a few things
08:39:45 <mthek> sachin: please take my comments just as one person's opinion, I am not expert
08:40:23 <sachin> mthek: Sure
08:40:35 <sachin> So are there people or companies building tools out of Haskell?
08:41:42 <mthek> sachin: at my company we're considering using Haskell for generating AST's for every programming language that exists (we're evaluation it against ANTLR). The main reason we don't use Haskell for everything is just the lack of people in the market we could hire.
08:41:48 <suppi> ph88: i'm not sure i understand your answer
08:42:11 <sachin> mthek: Hmm... I see
08:42:21 <sachin> Just started digging into haskell
08:42:21 <ph88> suppi, then for error recovery, what is called error recovery in megaparsec is basically just so one thing: do something else if the parser fails. By example that is execute yet another parser, but there is nothing stopping you for adding yet another error recovery on the alternative parser. Allowing you to create as many alternatives as you need. Suppose you tried already 5 parsers and none of them match you could try to implement a 
08:42:21 <ph88> "desperate parser" .. just skip 2 lines and try to parse something there. In regex that would be like ".*\n.*\n"
08:42:27 <mthek> sachin: one thing that I can tell you, the Haskell community is by far the friendliest I have come across
08:42:41 <sachin> Will use this channel for all my queries
08:42:53 <mthek> sachin: be sure to also check out #haskell-beginners
08:43:04 <sachin> mthek: Sure
08:43:14 <Profpatsch> mthek: People should not be the problem.
08:43:39 <Profpatsch> I personally know a few dozen people that would love to do Haskell full-time.
08:44:03 <Profpatsch> And most don’t because there’s just not enough companies doing it.
08:44:15 <circ-user-eGcqb> It reads like a joke. In the end of Functors, Applicatives and Monads in pictures I read that Haskell provides a syntactic sugar for getLine >>= readFile >>= putStrLn, which looks like foo = do     filename <- getLine     contents <- readFile filename     putStrLn contents.
08:44:21 <joe9> lyxia: any good beginner material to understand how to write Generic instances, please?
08:44:40 <suppi> ph88: right. that makes sense
08:44:40 <lyxia> circ-user-eGcqb: that's probably not the best example
08:44:41 <monochrom> Murphy's law #189: The people you want to hire are always in the wrong town :)
08:44:42 <mthek> Profpatsch: we're considering building a Haskell team, we're language agnostic, we use Golang a lot, Python for deep learning, we do a lot of CUDA programming for GPU's, Scala w/ Spark
08:44:55 <mthek> Profpatsch: for some of those areas, Haskell just doesn't work well yet 
08:44:58 <ph88> suppi suppose your language looks like  data File = [Paragraph] [Chapter]  data Paragraph = [Sentence]  data Sentence = [Word]  and so on .. you could try first the parser for File, if that doesn't work, try the parser for Paragraph, then Chapter, Sentence and lastly Word
08:45:16 <lyxia> joe9: you're not supposed to write them
08:45:45 <joe9> lyxia: I want to write a text pretty printer that can be derived.
08:46:30 <nitrix> circ-user-eGcqb: Yes, do-syntax desugars as >> or >>=, in certain cases <*> as well if you use ApplicativeDo.
08:47:08 <joe9> lyxia: extend wl-pprint-text to allow deriving Pretty
08:47:18 <ph88> suppi, that is if someone gives you a random piece of source code that doesn't necessarily make sense but you want to parse it anyway. For Example if your parser is SQL and someone gives you "name FROM table" and you are missing "SELECT" you can still try to piece together the meaning of the input with other parsers. Of course you will have to ask yourself if that has any meaning at all. In the example it could make sense, you could try to 
08:47:19 <ph88> parse "name FROM table" and check correctness of that and then present to the user "Did you forget to prepend your statement with SELECT" ?
08:48:03 <lyxia> joe9: Isn't the problem that you don't have a generic type
08:48:19 <lyxia> In which case you're better off writing the printer yourself
08:48:55 <nitrix> circ-user-eGcqb: It provides a nicer way to work with complicated nested computations, but this example doesn't do it justice as getLine/readFile/putStrLn just so happen to chain nicely together.
08:49:38 <ph88> suppi, the hard part which the parser library does not solve for you is to come up with a strategy to do "intelligent" things when your parser fails. Out of the box your parser will just stop, which is annoying for the programmer as he can just look at 1 error at a time.
08:51:13 <joe9> lyxia: I got around that issue. I find now that aeson-pretty is not showing all the data that a pretty printer would.
08:51:41 <suppi> ph88: yeah that's true
08:51:49 <joe9> lyxia: hence, want to explore adding generic to wl-pprint-text instead.
08:52:09 <lyxia> what data
08:52:19 <imalison> Does anyone have a good way of 'jumping to definition' of depedencies set up in their editor. As with most compiled languages, one of the issues with doing this in haskell is that you need the source code of your dependencies on your machine which you may not actually have. Is there a way to make stack also retrieve relevant source code to support this type of functionality?
08:52:21 <Profpatsch> ph88: Can megaparsec do that?
08:52:35 <ph88> Profpatsch, do what ?
08:52:46 <Profpatsch> The “continue parsing” part
08:52:54 * hackagebot gore-and-ash-glfw 1.1.2.0 - Core module for Gore&Ash engine for GLFW input events  https://hackage.haskell.org/package/gore-and-ash-glfw-1.1.2.0 (NCrashed)
08:53:36 <lyxia> joe9: is there a reason you prefer using this package over one that has been updated in the past year
08:55:05 <ph88> Profpatsch, yes on each parser you can add an option "do something else if parsing fails" .. that something else can be a parser you preprogrammed to try next, it can be an intelligent algorithm that goes to figure out which other parsers could apply (by first selecting them and then trying). But the point is that megaparsec just gives you the option to do SOMETHING. What that other thing is is entirely up to you. I was just speculating 
08:55:06 <ph88> and making the parser smarter by doing a breadth-width search on your parser tree as a possible form of "intelligence"
08:56:02 <Profpatsch> ph88: Hm, isn’t that just <|> ?
08:56:29 <ph88> suppose if the primary "correct" parser 5 fails .. and 5 other parsers match you can present 5 suggestions to the user "Did you mean ...?"
08:56:51 <Profpatsch> Then on the right side of <|> is a (recursive) new Parser that is given the rest of the input?
08:57:54 <ph88> Profpatsch, no <|> is for choices in your CORRECT grammar. But if your input is garbage and you want to handle cases which should normally not happen (= errors) you should use error recovery. Then in using error recovery you have the choice of how to recover from that error, of which one option is to try an alternative parser. This means that you will leave a gap in your tree, but it allows you to continue to make sense of the rest of the 
08:57:55 <ph88> input
08:58:42 <Profpatsch> So, if I want to parse all foo = … definitions I can, how about something like parseOneDefinition = … <|> (skipDefinition *> parseOneDefinition)
08:59:12 <joe9> lyxia: which is the package that has been updated in the past year? I know of only wl-pprint-text that works with Text.
08:59:26 <Profpatsch> Of course, that silently skips over the wrong parser …
09:00:00 <ph88> suppose "SELECT * FROM Table WHARE id = 1" .. no correct parser is going to identify "WHARE" for you. But you have a parser that can parse "ORDER BY", you have one that can parse "JOIN" and you have one that can parse "WHERE" ? to use it seems obvious that the best candidate is the latter one. But it's up to you to implement what to do if incorrect input was detected in the first place
09:00:20 <lyxia> joe9: oh ok. pretty doesn't work with text
09:00:27 <ph88> to use it seems obvious -> to us it seems obvious
09:01:45 <lyxia> joe9: what exactly is missing from aeson-pretty though
09:01:48 <Profpatsch> ph88: I’m all with you on the “parse at much as you can and display errors & possible better stuff”-part. But the automatic guessing is dangerous.
09:02:00 <Profpatsch> Of course that’s not of interest to the parser library.
09:02:19 <Profpatsch> Can attoparsec do that?
09:03:35 <nickols> our team's working on this "code annotation" website (which in itself has nothing to do with Haskell...) but noticed a user working on a Haskell tutorial: https://annot.io/github.com/agarick/haskell-wikibook
09:03:54 <nickols> thought it might help those starting to learn Haskell. While getting feedback on the website :-D
09:04:36 <ph88> Profpatsch, the question you should answer yourself is how are you going to make a distinction between correct input and incorrect input. Suppose your parser "skipDefinition" is going to succeed .. how are you going to encode that in your types? Perhaps you don't even want to encode that at all. With error recovery you can do something entirely different such as starting a new data tree on the basis of a child-parser, which has no relation 
09:04:36 <ph88> the primary data tree. The result of your parser is then in fact "a few results" which should be interpreted by the user as: Well here the result of the first part of your code, then i ran into a few difficulties and here is how i interpreted the rest, but i can not tell you how the first part and the second relate to each other (because the input error caused that there could not be found a natural relation in the grammar)
09:04:57 <Profpatsch> nickols: I’d recommend you put a paragraph on what it is and can do for me pretty far up.
09:05:23 <Profpatsch> nickols: And then a more in-depth “about” page with examples & pictures somewhere easy to findd.
09:05:56 <Profpatsch> It took me ~20scs to find out what it is and I’m not entirely sure if I got it right.
09:05:56 <nickols> Profpatsch: you mean a paragraph about the website?
09:05:59 <MarcelineVQ> Profpatsch: I believe nickols's is saying it's not their project
09:06:23 <ph88> Profpatsch, it's up to you if you want to encode error alternatives in your types, it does have some benefit though .. even though there was no relation in the grammar, you can still tell what was the point in the correct input at which things started going wrong
09:06:30 <Profpatsch> nickols: A paragraph on the startpage of annot.io.
09:06:46 <MarcelineVQ> Oh I see my bad
09:07:21 <nickols> Profpatsch: aha, thanks for that feedback :). Definitely put that into consideration.
09:07:52 <ph88> nickols, in my browser the css doesn't seem to load properly
09:08:52 <nickols> that's a shame.. (I'd hate to go off-topic, but could you tell me what browser you use?)
09:10:37 <MarcelineVQ> if there's much to say you could /query about it, alternatively there's #haskell-offtopic reccomend you get a screenshot in case there isn't really a css issue or it's one you know about
09:11:20 <ph88> nickols, chromium 53.0.2785.143 on ubuntu 16.04
09:12:34 <nickols> MarcelineVQ: ok will do, ph88: awesome thanks
09:15:43 <nickols> I've always been meaning, but haven't got around to learning haskell. If there had been browser integration like js ... that might be nice :-)
09:29:53 <Gurkenglas> https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Set.html#v:union <- "O(m*log(nm + 1)), m <= n/" why not "O(m*log(n + 1)), m <= n/"? Insert all of the smaller set's elements into the larger.
09:31:18 <EvanR> one by one ?
09:31:30 <MarcelineVQ> kinda looks like a doc bug, early escaping of / ?
09:31:36 <MarcelineVQ> -- | /O(m*log(n/m + 1)), m <= n/. The intersection of two sets.
09:31:57 <EvanR> also you begin by counting the size of each set ?
09:32:36 <jmcarthur> Sets cache their size, so that wouldn't be bad.
09:32:48 <jmcarthur> But in any case, I agree that looks like a documentation bug.
09:37:21 <mthek> nickols: have you seen excersism.io?
09:38:24 <nickols> mthek: i remember coming across it mentioned in github somewhere. wasn't it about doing programming exercises?
09:38:56 <mthek> nickols: exactly, not the same as what you're doing but could be worth having a look at, also rosettacode
09:40:55 <nickols> mthek: thanks, i'll put it on my radar. i've been refering to rosettacode for ages. hm.. but haven't visited for a while, for some reason
09:41:19 <mthek> nickols: I am working on a project that might overlap with you guys, let's chat in PM
09:42:07 <nickols> mthek: yeah that'd be great!
09:43:02 <nickols> mthek: i like the range of languages exercism.io is providing
09:43:33 <mthek> mthek: it's great and the community around it is amazing
09:48:40 <joe9> lyxia: aeson-pretty is not printing the field names or the record name.
09:58:31 <lyxia> why not the field names? did you not encode it as an object?
09:58:49 <lyxia> Similarly you can add your own field for the type
10:24:41 <kirillow> what does #haskell think of elixir?
10:25:41 <Rotaerk> just googled it and saw "dynamically typed" and gagged a little
10:34:54 <srhb> kirillow: Erlang with a twist. It's not so bad. 
10:34:59 <srhb> (I, too, miss real types.)
10:35:21 <glguy> #haskell thinks that Elixir is off-topic in #haskell
10:35:49 <srhb> True enough.
10:36:07 <ralu> Is there generic idea/class,  to represent cons like function?
10:37:29 <srhb> ralu: Something like Traversable t => a -> t a -> t a ?
10:37:42 <ralu> yes
10:38:28 <ralu> or just Foldable
10:38:55 <srhb> ralu: Monoid with Applicative gets closeish. I'm not sure it's terribly useful though.
10:41:20 <ralu> I am not sure that works for me. My functor is like infinite list
10:41:42 <ralu> so applicative instance is also too long
10:43:52 <srhb> ralu: I'm not sure how that excludes it though. pure 1 <> [2..] makes perfect sense to me
10:44:06 <ralu> pure 1 is infinite
10:44:13 <ralu> [1, ... ]
10:45:36 <srhb> ralu: Okay, what's the other argument then?
10:46:04 <ralu> i want to prepand
10:46:04 <ph88> why are the types of the documentation https://hackage.haskell.org/package/megaparsec-5.1.2/docs/Text-Megaparsec.html#t:Parsec and the source https://hackage.haskell.org/package/megaparsec-5.1.2/docs/src/Text-Megaparsec-Prim.html#Parsec not the same ?
10:46:06 <glguy> > pure 1 <> [2..]
10:46:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:47:36 <glguy> I'm not saying that's a good solution, but pure isn't infinite on [], is infinite on ZipList
10:48:26 <ralu> that is something i deal with
10:49:34 <glguy> you'll probably need to make a new class with what ever special behavior you're looking for
10:49:51 <ralu> so how should one prepend to zipList ?
10:50:10 <geekosaur> ph88, I think docs were built manually ... and quite possibly against the wrong source
10:50:19 <geekosaur> (master instead of the 5.1.2 release, maybe)
10:51:21 <ph88> oki
10:52:47 <nshepperd1> Heh, you sort of can write a cons function for fixed length (including infinite) things with traversable and lazy state
10:53:10 <nshepperd1> Would be silly for infinite lists though
10:53:35 <nshepperd1> Much more expensive than just using (:)
11:02:05 <Hijiri> ralu: you could unwrap the ZipList and cons to the underlying list (and then rewrap)
11:02:33 <ralu> I can, but i have different typclass that bhaves different way
11:02:46 <ralu> *behaves same way :(
11:03:12 <Hijiri> what typeclass?
11:03:48 <ralu> Infinite Signal
11:04:03 <Hijiri> that's a typeclass?
11:04:05 <Hijiri> not a type?
11:04:59 <ralu> i am not sure
11:05:17 <Hijiri> could you post the definition
11:05:41 <Hijiri> something is a typeclass only if you declare it with "class Blah z where ..."
11:05:58 <Hijiri> I am guessing there is some way to cons onto your signal thing too, but I would have to see how it's defined
11:06:10 <ralu> It is Applicative, Traversabale not Monoid and not Monad
11:06:29 <Hijiri> that's not enough to know whether something can be consed onto it
11:06:33 <ralu> It is not issue
11:06:39 <Hijiri> there's nothing about applicative and traversable that allows you to prepend
11:07:39 <ralu> I am just trying too reuse something. I have my own type that will need to be genaralised over cons using some typeclass
11:07:57 <Hijiri> I don't think there is a standard typeclass for consing
11:07:59 <ralu> * would like to generalise
11:08:04 <Hijiri> you might want to write your own, if you really need it
11:08:12 <ralu> Ok, hanks
11:08:55 <ralu> * thank You
11:11:16 <jmcarthur> Does anybody know how I can make a local copy of a Stackage snapshot and use it instead of relying on the Internet?
11:12:10 <jmcarthur> I want to be able to use stack while not necessarily being connected.
11:12:51 <talzs> So I'm reading through Functional Programming with Bananas, Lenses, Envelopes, and Barbed Wire. I don't understand some of the type signatures. They say something like 'binop is an element of A||B->B'. I think I understand what they're trying to say (by how they use the function), but I don't understand the notation. Any resources that would clarify my understanding?
11:12:59 * hackagebot hledger-ui 1.0.5 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-1.0.5 (SimonMichael)
11:19:33 <byorgey> talzs: you're right, they don't define the || notation, but it seems clear it's just pairing
11:19:43 <byorgey> i.e. A || B  is the same as  (A,B) in Haskell
11:20:03 <byorgey> talzs: other than that I seem to recall that paper is fairly self-contained.
11:20:34 <byorgey> though 'self-contained' is not at all the same as 'easy'.
11:20:41 <byorgey> It's difficult to digest but quite rewarding.
11:23:00 * hackagebot http-dispatch 0.6.2.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.6.2.0 (owainlewis)
11:25:27 <talzs> That's what I was thinking, do these signatures only specify the return types? They use a similar signature for the anamorphism (b->a, b), which returns a tuple, but the catamorphism (a,b->b) seems to only reduce
11:53:00 * hackagebot vty 5.13 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.13 (JonathanDaugherty)
11:56:59 <jmcarthur> One more try: I can't seem to find anything explaining how to set up a local stackage mirror. Has anybody done this or have an idea of how to do it?
12:14:19 <MarcelineVQ> jmcarthur: custom snapshots or a mirror of the currently available lts?
12:14:47 <jmcarthur> the latter
12:23:00 <circ-user-QJY8M> Why do they replaced a for a1 -> a2 in (b -> c) -> (a -> b) -> a -> c and call it a composition of compositions?
12:23:32 <geekosaur> ...where?
12:24:03 <jmcarthur> The situation is I'm going on a trip where I'm mostly not going to have internet access. I can try to anticipate every package I might need, which would be difficult, or I could grab a stackage mirror and use it, which at first I thought sounded easier, but now I think I might as well just try to pre-install all packages I might need...
12:24:59 <geekosaur> it may not be that easy, since you apparently also need to duplicate or mirror their all-hackage-signatures repo for stack to work right iirc
12:24:59 <circ-user-QJY8M> What are two compositions that are composed in  (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c?
12:25:06 <jmcarthur> Maybe I should try a docker image.
12:26:14 <geekosaur> the same compose operator
12:26:15 <geekosaur> :t (.) . (.)
12:26:17 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:26:50 <geekosaur> I assume this is about alpha renaming, since you can't reuse the same a/b/c when substituting the type variables for one instance of (.) into anothet
12:27:15 <geekosaur> (current ghc alpha-renames differently, you'll note; it changes every so often)
12:27:26 <geekosaur> :t (.)
12:27:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:31:16 <circ-user-QJY8M> I did not get your xplanati0n. I read here http://www.adit.io/posts/2013-07-22-lenses-in-pictures.html
12:33:19 <geekosaur> it is the same composition. they are doing the operation: (.) . (.)
12:33:25 <geekosaur> which composes the composition operator with itself
12:35:17 <MarcelineVQ> jmcarthur: You may be best off with a docker with as much installed as you can think of, I tried some custom resolver things but they didn't work out
12:35:43 <circ-user-QJY8M> I understand that composition of compositions is a composition of composition operators. I am trying to recognize where are the two composition operators in in  (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c? Can you list them through the comma?
12:36:08 <geekosaur> :t (.)
12:36:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:36:13 <geekosaur> :t (.) . (.)
12:36:15 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:36:35 <geekosaur> which uses different type variables but is the same type
12:37:04 <jmcarthur> MarcelineVQ: Yeah I think I'm gonna try the "full" image.
12:37:30 <jmcarthur> Never used docker before, so this is probably a good thing to learn anyway.
12:38:02 * hackagebot sproxy2 1.90.0 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.90.0 (ip1981)
12:38:27 <circ-user-QJY8M> You just replace single a variable with a function. You make a first function in composition a two-variable function. I see how this function is composed with b->c . I do not see the two composition operators in the right hand of (.).(.).
12:39:15 <geekosaur> I feel like you are misunderstanding something. The type is just what you get when you substitute the type of the composition operator into itself, to derive the type of (.) . (.)
12:40:36 <Tuplanolla> Perhaps it would help to arrange it like this, circ-user-QJY8M: `let f = (.); g = (.); h = (.) in f g h`
12:40:57 <Tuplanolla> You can now easily infer the types of `f`, `g` and `h`.
12:46:21 <circ-user-QJY8M> I see they do the same with traversible later. They define it with a long expression traverse :: (a -> m b) -> f a -> m (f b)
12:46:37 <circ-user-QJY8M> But, composition traverse.traverse :: (a -> m b) -> f (g a) -> m (f (g b)) is not much longer.
12:47:03 <circ-user-QJY8M> It just replaces a for (g a). It is a puzzle why.
12:52:31 <jedai> circ-user-QJY8M: Does it help if I add some brackets : (b -> c) -> ( (a -> b) -> (a -> c) ) ? put thos twice in the (.) signature with proper inference and see the type of the result (the (a -> c) initially)
12:54:15 <byorgey> circ-user-QJY8M: the type of a composition does not include everything from the types of the things you composed.  Look at the type of composition itself:  (.) :: (b -> c) -> (a -> b) -> (a -> c).  Notice that the result is  a -> c  --- the type 'b' has disappeared.
12:55:44 <MarcelineVQ> jmcarthur: there's some info here if you haven't seen it yet, including some applicable docker images https://docs.haskellstack.org/en/stable/docker_integration/
12:56:06 <jmcarthur> MarcelineVQ: Yeah, but I have found that the stack-full images haven't been updated since LTS 5 :(
12:56:57 <MarcelineVQ> check out this and see if it can be modified for you https://github.com/rlpowell/stack_all
12:57:07 <circ-user-QJY8M> We do not need b because it is intermediate that is consumed by b -> c. Yet, I see how ( (a -> b) consumes a and ( (b -> c) consumes its result to make a composition.
12:57:33 <circ-user-QJY8M> I do not see how two-argument function makes a composition of compositions.
12:57:48 <jmcarthur> MarcelineVQ: I think I'd have to build everything myself for that. I was wanting to either do that lazily or use pre-built.
12:58:09 <jmcarthur> I appreciate the help though
12:58:22 <mettekou> Is OpenBSD an option to deploy a Haskell web application using Stack? It seems to be a pain.
12:59:34 <byorgey> circ-user-QJY8M: in Haskell every function takes only one argument.  a -> b -> c  is really the same as   a -> (b -> c)
12:59:49 <byorgey> i.e. a function which takes an argument of type 'a' and returns another function.
13:18:21 <jedai> circ-user-QJY8M: another way to see it : apply it ! ( (.) . (.) ) f g x y ==  ( (.) . (f .) ) g x y == ( (.) (f .) g ) x y == (f .) (g x) y == (f . g x) y == f (g x y)
13:20:31 <sm> mettekou: what problem are you seeing ?
13:21:15 <jedai> There's one too many . in the second step...
13:22:33 <mettekou> sm: Well, I don't think it's impossible, but there's no port of the latest GHC or Stack, so you'd have to compile them yourself?
13:27:21 <sm> mettekou: I'm told GHC 7.10.3 is in openbsd's packages. Maybe cabal too ? That's enough in many cases, and I assume stack can be built
13:28:04 * hackagebot google-oauth2 0.2.2 - Google OAuth2 token negotiation  https://hackage.haskell.org/package/google-oauth2-0.2.2 (PatrickBrisbin)
13:28:06 * hackagebot yesod-markdown 0.11.2 - Tools for using markdown in a yesod application  https://hackage.haskell.org/package/yesod-markdown-0.11.2 (PatrickBrisbin)
13:30:01 <geekosaur> ghc poses ports-based (build from source) systems a problem, because you can only build from source using an older version. so someone needs to come up with a bootstrap package for all supported platforms
13:30:09 <sm> mettekou: and I suppose the packager is working on GHC 8. Note 7.10.3 is still quite well supported, it's not essential to have 8
13:33:04 * hackagebot dmenu 0.1.0.1 - Complete bindings to the dmenu and dmenu2 command line tools.  https://hackage.haskell.org/package/dmenu-0.1.0.1 (m0rphism)
13:33:05 <geekosaur> even if you can make that from the previous port, you may still have trouble rounding up packages for all platforms you want the port to support (fbsd doesn't poudriere packages for all supported platforms, I doubt openbsd does either --- just the higher tier ones)
13:35:06 <xcmw> Is there a library that makes packing and unpack data and newtypes easier? Currently I have a type class with pack and unpack. Can instances be automatically generated?
13:36:55 <dibblego> lens
13:37:05 <dibblego> @type _Wrapped
13:37:07 <lambdabot> (Profunctor p, Rewrapped t s, Rewrapped s t, Functor f) => p (Unwrapped s) (f (Unwrapped t)) -> p s (f t)
13:38:45 <xcmw> dibblego: Does that require you to manaully implement the interface?
13:39:11 <dibblego> makeWrapped can do it for you
13:40:26 <xcmw> dibblego: Can it handle type families and extistential type in the data or newtype declaration?
13:40:28 <geekosaur> there is also http://hackage.haskell.org/package/newtype-generics-0.5/docs/Control-Newtype.html
13:40:37 <geekosaur> but I don't know if it can do that...
13:41:48 <xcmw> Thanks I will try those
13:50:37 <Lokathor> I think i've ended up with a reverse Phantom Type
13:51:26 <MarcelineVQ> a real type?
13:52:45 <Lokathor> so i want to be able to have a series of rooms that users connect to and then play games in
13:52:59 <Lokathor> each room can play different games though, so the rules and state of each room will be different
13:53:16 <Lokathor> so my idea is that the basic functino for processing the incoming messages would be
13:53:16 <Lokathor> foo :: TVar s -> User -> Text -> Set User -> IO ()
13:53:30 <Lokathor> for some sort of state s
13:53:50 <Lokathor> and then you'd actually stick that in a record with the first argument applied, hiding away the different forms of state that are going on
13:54:25 <Lokathor> data Room = Room { ... , roomProcessor :: User -> Text -> Set User -> IO () }
13:55:35 <Lokathor> then the library would pass in the final paramaters, run the IO action (which we're assuming will be some sort of atomically (STM ()) thing)
14:00:22 <Lokathor> i can't tell if the silence is because this is a really good idea or a really bad idea
14:03:05 * hackagebot gore-and-ash-demo 1.2.0.0 - Demonstration game for Gore&Ash game engine  https://hackage.haskell.org/package/gore-and-ash-demo-1.2.0.0 (NCrashed)
14:03:35 <MarcelineVQ> You didn't aska a question :>
14:03:57 <Lokathor> hmm, then my question is what the local vampire population thinks about the idea
14:04:18 <zq> :t compare `on` xor
14:04:20 <lambdabot> (Bits a, Ord (a -> a)) => a -> a -> Ordering
14:04:29 <zq> :t compare `on` uncurry  xor
14:04:29 <MarcelineVQ> I've not used STM or MVars even
14:04:30 <lambdabot> (Bits a, Ord a) => (a, a) -> (a, a) -> Ordering
14:04:41 <Lokathor> oh my you should it's cool
14:04:51 <zq> :t maximumBy $ compare `on` uncurry  xor
14:04:53 <lambdabot> error:
14:04:53 <lambdabot>     Precedence parsing error
14:04:53 <lambdabot>         cannot mix ‘$’ [infixr 0] and ‘on’ [infixl 0] in the same infix expression
14:05:08 <zq> lolwat
14:05:38 <zq> :t let f = unsefined in maximumBy $ compare `f` uncurry  xor
14:05:40 <lambdabot> error:
14:05:40 <lambdabot>     • Variable not in scope: unsefined
14:05:40 <lambdabot>     • Perhaps you meant ‘undefined’ (imported from Prelude)
14:05:55 <zq> :t let f = undefined in maximumBy $ compare `f` uncurry  xor
14:05:57 <lambdabot> error:
14:05:58 <lambdabot>     • Could not deduce (Bits c0) arising from a use of ‘xor’
14:05:58 <lambdabot>       from the context: Foldable t
14:32:19 <tempay> guys, I have something awful to show you, and I want you to console me and commiserate with me
14:32:21 <tempay> https://hackage.haskell.org/package/hmm-hmatrix-0.0.1/docs/Math-HiddenMarkovModel.html
14:32:38 <tempay> check out the T's in the type signature for logLikelihood
14:32:58 <tempay> anything off about them?
14:33:16 <tempay> that's right... they're completely different, and come from two different packages!
14:33:18 <tempay> kill me!
14:34:00 <geekosaur> "Author	Henning Thielemann"
14:34:06 <geekosaur> ...expected, sadly
14:34:24 <tempay> that bad? should I not try to use this package?
14:35:10 <geekosaur> Henning's very good, except for his naming convention (all types are T, all typeclasses are C, both used always qualified, only one type+maybe typeclass declared per module)
14:35:26 <geekosaur> which is what makes it so frustrating
14:35:59 <tempay> yeah I notice that part, and the crazy overabstraction that means I seem to need type annotations on every line
14:36:18 <tempay> but if he's good in general I'll try to make this function..
14:36:31 <geekosaur> but if you have an option written by Henning and one written by someone else, with very few exceptions Henning's will be the better one
14:36:52 <tempay> ok that's comforting
14:43:07 * hackagebot dmenu 0.1.0.2 - Complete bindings to the dmenu and dmenu2 command line tools.  https://hackage.haskell.org/package/dmenu-0.1.0.2 (m0rphism)
14:43:09 * hackagebot mmorph 1.0.7 - Monad morphisms  https://hackage.haskell.org/package/mmorph-1.0.7 (GabrielGonzalez)
14:48:07 * hackagebot gore-and-ash-lambdacube 0.2.0.0 - Core module for Gore&Ash engine that do something.  https://hackage.haskell.org/package/gore-and-ash-lambdacube-0.2.0.0 (NCrashed)
14:54:06 <xcmw> dibblego: Does that require you to manaully implement the interface?
14:54:41 <xcmw> dibblego: Unwrapped did not work with type synomyms
14:55:09 <xcmw> I accidently sent the other message again
15:10:34 <Guest95146> hey! I'm trying to get https://github.com/adscib/monad-bayes running with stack, but have encountered the following error: "$ stack install monad-bayes After installing Cabal, the package id couldn't be found (via ghc-pkg describe Cabal). This shouldn't happen, please report as a bug"
15:13:44 <Xyliton> how do I use "Network.Download"'s openURIString to download the content of a url? I don't really understand the data type (which is "IO (Either String String)" )
15:15:13 <xcmw> dibblego: Nevermind it does work with type synonyms
15:19:23 <geekosaur> Xyliton, I would understand that type as an IO action producing either Left errorString or Right theContent
15:20:20 <geekosaur> r <- openURIString ...; case r of {Left err -> error err; Right res -> {- handle the result here -} }
15:22:08 <Xyliton> geekosaur: that tells me "Couldn't match type 'IO' with '[]' " on the line where I bind openURIString to r
15:22:35 <geekosaur> that sounds like you are not in IO
15:22:52 <geekosaur> or, you have given the wrong type for openURIString, but that seems unlikely
15:23:31 <joe9> I am trying to figure out how to use :kind! as described here: http://dev.stephendiehl.com/hask/#generic
15:24:02 <geekosaur> Xyliton, @paste the actual program and full error message
15:24:03 <geekosaur> @paste
15:24:03 <lambdabot> Haskell pastebin: http://lpaste.net/
15:24:35 <joe9> How do I figure out how to use this --  :kind! Rep Animal
15:26:08 <Xyliton> geekosaur: The program: http://lpaste.net/343483 and the error: http://lpaste.net/343485
15:29:11 <geekosaur> Xyliton, (a) I only did the case on one line because IRC is line oriented; (b) you are producing it in an IO context, you need `return` to pull it into IO (since you didn't use it, it took the monad to be [] because String = [Char] then that didn't match declared type IO String
15:29:33 <geekosaur> I was expecting you to use it immediately not assuming you would just return it
15:30:01 <geekosaur> ...and you are apparently not familiar enough with Haskell to realize that, which will cause you problems later
15:30:06 <ajp> could anyone help me write a GEq instance? http://stackoverflow.com/questions/40698207/how-can-i-write-this-geq-instance
15:30:22 <ajp> I've figured out how to write it for my Tup2List type, but I'm pretty stuck on GTag
15:31:27 <Xyliton> geekosaur: Is it that obvious that I suck at Haskell? :o Yea, I started learning it like 5 days ago
15:31:42 <geekosaur> this is a common new-Haskeller failure
15:31:54 <geekosaur> I suggest you sit down with an introduction to Haskell's IO
15:32:04 <geekosaur> or you will get weird type errors like that
15:32:35 <geekosaur> (perhas I should say introduction to IO in Haskell... not quite the same thing)
15:36:50 <manek> Hello! :) I've got a value of a type Map Int (Map Int Int). How can I use lenses to lookup a value in the nested map? I was trying to use (at ixd . at idx') but it didnt worked
15:37:23 <MitchellSalad> manek: that should work
15:37:40 <MitchellSalad> oh, I'm thinking of ix
15:38:04 <MitchellSalad> you can either do "ix int1 . ix int2" or "at int1 . _Just . at int2"
15:38:35 <Xyliton> geekosaur: I tried to do it "inline" in the main function but it still errors :/ http://lpaste.net/343489
15:38:43 <xcmw> Both newtype-generics and makeWrapped from Lens support type synomyms in the declaration. Both fail on extisential types. Which one is better?
15:38:44 <manek> MitchellSalad: oh, htanks!
15:39:37 <geekosaur> Xyliton, ... I don't even know where you got that idea
15:39:47 <MitchellSalad> Xyliton: In a "x <- y" expression, what is the type of y?
15:39:48 <geekosaur> it will not work like that
15:40:16 <Xyliton> geekosaur: I have no idea either. I'm just trying to hack something together right now ;-;
15:40:25 <geekosaur> and, what was wrong with using the original code and adding return like I said?
15:40:30 <Xyliton> MitchellSalad: IO a, maybe?
15:40:46 <geekosaur> (hint, in your attempted rewrite the return is in the wrong place)
15:40:49 <MitchellSalad> Xyliton: Yup, but it looks like you've got a lambda, not an IO thing
15:40:54 <geekosaur> (but, you were better off the first time)
15:41:29 <geekosaur> I mean, do you really want to treat an error message like the content and just roll right along with it?
15:43:56 <Xyliton> geekosaur: well... It would make quite the interesting Hangman game if you could try to guess error messages :P
15:44:11 <Xyliton> I fixed it: http://lpaste.net/343491
15:44:24 <Xyliton> the return really just was at the wrong place. *facepalm*
15:44:54 <Xyliton> (plus I used randomWord at some places where I rather wanted to word extracted from the current state)
15:45:02 <geekosaur> well, in the second one you wanted it on the result of either, not where you put it. (but I still find the whole idea of that second attempt dubious at best)
15:45:58 <Xyliton> in my second attempt I wanted an error to default to an empty string though
15:47:08 <geekosaur> id is not an empty string. it just passes its parameter (the error string) through
15:47:29 <geekosaur> (const "") would have gotten you the empty string (`const` so it consumes the String it is passed)
15:47:52 <Xyliton> oh, damn. so I also messed up the order?
15:48:38 <geekosaur> either Left-fun Right-fun valye
15:48:44 <geekosaur> *value
15:49:14 <geekosaur> your const was on the right and I spaced on that, or I would have given better feedback there... whoops. (I just stopped at the `id` with "wat?")
15:52:01 <Xyliton> here's a demo of how the program works right now: https://asciinema.org/a/4ibnkameutdu2aevtl7djgvy0
15:52:14 <Xyliton> Do you have any suggestions how I could improve it?
15:54:31 <Profpatsch> I don’t understand Wai Middleware.
15:55:20 <Profpatsch> I defined a simple M like so, that it rewrites the Request path if it’s /, to /index.html
15:55:22 <Profpatsch>         let req' = if (traceShowId (Wai.pathInfo req)) == []
15:55:24 <Profpatsch>                    then req { Wai.pathInfo = ["index.html"] }
15:55:26 <Profpatsch>                    else req
15:55:44 <Profpatsch> Ah, sorry, let’s put it in a paste
15:56:19 <Profpatsch> http://lpaste.net/343492
15:56:27 <Profpatsch> These are the two middlewares.
15:56:58 <Profpatsch> Now, if I do rootToIndexMiddleware . staticMiddleware
15:57:15 <Profpatsch> It prints the trace for /foo => ["foo"]
15:57:28 <Profpatsch> But for / it prints nothing.
15:58:15 <Profpatsch> for / it prints nothing *and* returns index.html
15:58:53 <Profpatsch> So the rewrite was sucessful, but the trace didn’t happen. wat?
16:03:10 * hackagebot bench 1.0.2 - Command-line benchmark tool  https://hackage.haskell.org/package/bench-1.0.2 (GabrielGonzalez)
16:06:16 <Profpatsch> Apparently the middleware routing is done from innermost to outermost.
16:08:40 <Profpatsch> Or, better: the last call to respond is used as final response.
16:10:26 <Profpatsch> Oh, I see now.
16:12:21 <Profpatsch> Complete inversion of control.
16:13:02 <Profpatsch> So the logical flow through middleware concatenated with (.) is from left to right, similar to Lenses.
16:28:11 * hackagebot leapseconds 1.0 -   https://hackage.haskell.org/package/leapseconds-1.0 (AshleyYakeley)
16:39:51 <byorgey> wow, someone doesn't like indentation: https://github.com/AshleyYakeley/leapseconds/blob/master/src/Data/Time/Clock/LeapSeconds.hs
16:40:46 <Tuplanolla> I'm glad that's possible, even if I don't like it.
16:41:40 <geekosaur> ... looks like someone writing C, K^R style
16:41:46 <geekosaur> *K&R
16:47:56 <qwertyuiop[m]> wut
17:11:37 <Enzyme> R5
17:19:54 <ajp> could anyone familiar with Data.GADT.Compare.GEq help me write a GEq instance? the full situation and code is here http://stackoverflow.com/questions/40698207/how-can-i-write-this-geq-instance (I asked an hour ago - I'm asking one more time in case it got lost in the noise)
17:26:18 <Profpatsch> Eh, now I’m inside ghcjs compiler code.
17:26:26 <Profpatsch> I should go to bed.
17:36:10 <xcmw> http://lpaste.net/343525
17:37:05 <geekosaur> I'm not aware of a shorthand for that
17:38:02 * geekosaur would probably make his editor do the boilerplate >.>
17:39:18 <xcmw> I will either do that or use TH
17:40:25 <xcmw> Why does that message look different?
17:40:43 <geekosaur> ?
17:41:22 <geekosaur> if you mean my two messages, one was a normal channel message and the other was an ACTION (/me)
17:42:06 * xcmw understands what you said
17:51:37 <xcmw> When making a hetergenous list is haskell, is way to avoid typing Box every time? [Box A, Box B, Box C, ...]
17:58:10 <geekosaur> no, unless you count the HList syntax (hint: it's worse)
17:58:38 <Hafydd> Isn't it also possible to use existential types to do this, in some way?
17:59:33 <xcmw> Hafydd: I am using existential types which is why I have to do this
17:59:37 <Hafydd> Oh, I see.
18:10:37 <imalison`> why is it impossible to use derivation on existential types
18:11:24 <imalison`> Am I missing something obvious?
18:12:51 <xcmw> Good question
18:12:53 <geekosaur> you can't do *anything* with an existential except via any typeclass contexts
18:13:12 <geekosaur> (and if it has none, you can't do anything with it)
18:14:57 <imalison`> sure I get that, but I'm still not entirely sure why that means that derivation can't be used with existentials
18:14:59 <imalison`> forexample
18:15:12 <imalison`> if the existential requires the typeclass being derived
18:15:34 <imalison`> think show, forexample
18:23:20 <augur> is anyone familiar with the indentation parser for parsec?
18:23:53 <geekosaur> Show may actually be an exception
18:24:18 <geekosaur> whoops
18:33:03 <lordcirth> I'm looking at the Vty lib https://github.com/coreyoconnor/vty/blob/25b03409cda29d15650b94490af78714e1fa4a6b/src/Graphics/Vty/Input/Events.hs  , and I'm wondering, how do I find if the player has pressed a normal key, like 'k' ?
18:35:13 <glguy> lordcirth: You can use the vty-demo executable to see what events you get when you press keys
18:35:24 <lordcirth> glguy, oh ok thanks
18:35:26 <geekosaur> KChar, I'd think
18:35:56 <lordcirth> EvKey (KChar 'j')
18:36:25 <lordcirth> Ah, I see it in the file now, 'KChar Char'
18:36:37 <lordcirth> Thanks guys!
18:40:19 <xcmw> Which is "better" newtype-generics or makeWrapped from Lens?
18:43:40 <grantwu> Are orphan instances necessarily bad?  I have a generic datatype Foo in file A of kind * -> * -> * and a typeclass MyTypeClass, and then files B and C which have type synonyms type Foo' = Foo Bar Baz, which declare instance Foo' MyTypeClass
18:46:51 <benzrf> grantwu: they are often bad
18:47:01 <benzrf> they can cause really weird behavior
18:47:30 <benzrf> for example - if you have two separate orphan instances - then the order in which you (transitively, even!) import stuff will fuck with behavior
18:47:43 <benzrf> iirc
18:48:12 <grantwu> Hrm.. looking at the wiki.haskell.org page, this might fall under "when orphan instances can be useful"
18:48:33 <grantwu> Right, but that's only a problem when you have multiple instances for the same type right?
18:49:16 <benzrf> i think so yeah
18:50:08 <grantwu> Hrm yeah I think we are kind of making some sort of ad hoc module thing here
18:50:34 <n_blownapart> Hi soft question: what is the preferred haskell editor. I've been happily using atom / ide-haskell / stack and suddenly I'm getting errors from the haskell-ghc-mod package -again- after it working fine for a week.
18:56:08 <joe9> I cannot figure out what happens to the c in the signature : newtype M1 i c f p = M1 { unM1 :: f p } -- http://dev.stephendiehl.com/hask/#generic
18:56:20 <joe9> how do I extract the c value?
18:56:29 <joe9> I understand that c represents the Constructor
18:57:37 <wespiser> so do I get any additional safety when I put (ResourceT IO) over IO into my mtl stack?
18:57:44 <joe9> but, I cannot figure out why there is no constructor to get the 'c' value? I see there are methods conName, but, i cannot figure out how it works.
18:58:23 <wespiser> joe9: you need a function with type fn :: M1 i c f p -> c
18:58:52 <wespiser> or something like fn :: (c -> d) -> M1 i c f p -> M1 i d f p
18:59:27 <geekosaur> joe9, it's a phantom type. Generics can extract it from the type information, as can Typeable
18:59:40 <geekosaur> there is no *value*, just a type
18:59:46 <joe9> Thanks, will check on phantom types.
19:00:03 <geekosaur> phantom type just means it is a type in the type signature with no associated value
19:00:16 <geekosaur> so it exists only on type level, for typechecking or type level programming
19:00:57 <geekosaur> in your (their) newtype, f and p are used in the value, i and c are phantoms and only available as part of the type
19:02:07 <jle`> joe9: do you understand the type:
19:02:14 <jle`> data Proxy a = Proxy
19:02:20 <jle`> how do you get an 'Int' from a 'Proxy Int' ?
19:02:42 <jle`> the 'a' just exists in the type; there is no actual value of type 'a' in a 'Proxy a'
19:05:35 <Rotaerk> it's called a phantom type
19:05:44 <Rotaerk> oh, already mentioned
19:07:59 <geekosaur> their Constructor is a symbol that exists solely for its type information (and, via class Constructor, an associated String which is its name). conName takes something that looks like a value of the newtype M1, and returns the String corresponding to the type c which is specified in the Constructor instance
19:08:06 <sm> n_blownapart: ghc-mod is fragile. Maybe just run ghcid in a side window ?
19:08:17 * hackagebot hashabler 2.0.0 - Principled, portable & extensible hashing of data and types, including an implementation of the FNV-1a and SipHash algorithms.  https://hackage.haskell.org/package/hashabler-2.0.0 (BrandonSimmons)
19:08:35 <geekosaur> sadly, pretty much any such tool is fragile, because of how ghc works internally
19:09:04 <n_blownapart> sm thanks what I did was ..
19:09:07 <sm> n_blownapart: and, I was liking atom but switched to IDEA
19:09:20 <geekosaur> the specific binary the editor is running must have been built against the exact ghc that you are using
19:09:53 <sm> in emacs land, intero is the latest thing
19:10:01 <geekosaur> (or have access to a backend that matches that exact ghc; this is the method being used for newer tools, and aided by ghcid in ghc8)
19:10:11 <n_blownapart> I just got rid of the ghc-mod plugin for the mouseOver feature which gives you the type. the feature is patchy anyway. that fixed it
19:10:55 <n_blownapart> sm geekosaur yeah it really complicated. what about just spending the time to learn emacs ? another thing to spend like 20 hours on perhaps
19:10:59 <n_blownapart> its
19:11:23 <geekosaur> you could try spacemacs, which tries to reduce the ramp-up time
19:11:38 <n_blownapart> heard about it thanks
19:11:49 * geekosaur uses emacs, but has been using emacs since ... 1984ish, so.
19:12:22 <n_blownapart> so space macs is a plug-in for emacs? geekosaur 
19:13:01 <geekosaur> it's a bundle containing an emacs customized with easier defaults. including vim emulation by default
19:13:29 <geekosaur> you could duplicate it with a standard emacs, or you can just install and run spacemacs
19:13:31 <grantwu> I tried spacemacs and was somewhat unimpressed by the amount of error message spew I got on startup
19:13:37 <sm> atom or IDEA or editor-of-choice + ghcid is the quick solution
19:14:14 <sm> quick and robust
19:14:31 <geekosaur> yay. [20 02:06:03] -ghc-github/#ghc- [ghc] ghc-mirror tagged ghc-8.0.2-rc1 at ghc-8.0: https://git.io/vXbk7
19:15:16 <n_blownapart> sm geekosaur thanks, so sm do you use that mouseover feature? I heard it was very cool but it is throwing off the whole thing since it relies on the haskell-ghc-mod package
19:15:30 <wespiser> anyone here familiar with ResourceT ?
19:15:49 <sm> no, I gave up on ghc-mod after serious efforts
19:16:00 <n_blownapart> sm word what a pain
19:16:08 <Clint> wespiser: i've used it
19:16:30 <sm> it's probably fine in some projects I'm sure. Its stack support was not all there and it didn't handle multi-package projects
19:16:51 <wespiser> Clint: I'm alittle unclear with the usage, does runResourceT  on a monad transformer make sure all the resources are cleaned up?
19:17:19 <wespiser> my stack is ReaderT Env (ResourceT IO) a
19:17:40 <wespiser> and usage is runResourceT $ runReaderT (unWrap obj)
19:18:16 <n_blownapart> sm so I just have the two required packages plus autoComplete . fine for a beginner?
19:19:06 <sm> is it working ?
19:19:35 <joe9> geekosaur:  Thanks a lot. That makes sense now.
19:20:08 <n_blownapart> yeah the only thing the doesn't work now is the mouseOver, which was patchy anyway sm
19:20:17 <n_blownapart> that*
19:20:32 <sm> sounds pretty good to me
19:20:39 <n_blownapart> thanks pax
19:20:49 <sm> do you get accurate and timely red squiggles ?
19:20:50 <Clint> wespiser: it should do whtever cleanup is registered
19:21:10 <n_blownapart> what do you mean?
19:21:14 <wespiser> okay, I'm just using 'withFile'
19:21:20 <wespiser> pretty basic
19:23:05 <n_blownapart> sm oh shit now the autocomplete doesn't work. it says I can use another package which "provides haskell-completion-backend" . any clue sm ?
19:23:23 <n_blownapart> aside from ghc-mod
19:24:15 <joe9> The M1 D or M1 C or M1 S are all different types? or, are they the same type and if D , C and S are constructors? If they are constructors, I have one instance for M1 and pattern match on D or C or S, correct?
19:25:13 <sm> nope
19:25:31 <joe9>  instance (GSerialize a) => GSerialize (M1 i c a) where gput (M1 x) = gput x -- what is x?
19:25:35 <sm> you have angered it
19:26:43 <joe9> got it, x == M1 (C or S or D) or K1
19:26:53 <joe9> the value.
19:27:06 <ThusSpakeHarambe> i saw some irc logs where people try to come in here and troll the channel and instead the channel convinces them to learn haskell
19:27:17 <geekosaur> newtype M1 i c f p = M1 { unM1 :: f p }
19:27:30 <geekosaur> so the *value* is a thing of type f p
19:27:32 <sm> ThusSpakeHarambe: come to try your luck ?
19:27:44 <n_blownapart> uninstall auto
19:27:45 <ThusSpakeHarambe> nah, i already like haskell
19:27:47 <sm> just kidding, please don't :)
19:27:50 <rjromero> lol
19:27:51 <n_blownapart> complete 
19:28:31 <joe9> geekosaur: so, M1 C , M1 D , M1 S are different types, correct? need an instance for each one distinctly, correct?
19:28:43 <ThusSpakeHarambe> what i really like that is that web developers (front end people in general) are starting to leverage ideas from haskell and elm, you see this with redux, immutable.js, rxjs
19:28:54 <ThusSpakeHarambe> and here i thought the front end guys were the dumb ones
19:29:37 <grantwu> I mean
19:29:39 <grantwu> https://twitter.com/dan_abramov/status/537951646245216256
19:29:52 <ThusSpakeHarambe> lol
19:30:30 <lordcirth> Can I pattern match on a range of Char?  like a-z or 0-9 ?
19:30:53 <grantwu> Fairly sure you want to use guards for that
19:30:53 <joe9> lordcirth: checkout isAscii of Data.Char
19:31:02 <grantwu> or that
19:31:23 <lordcirth> currently it's a case expression, but I could use guards or whatever
19:31:37 <geekosaur> you can pattern match, but pattern matching doesn't support ranges. guards are preferred. note that case expressions can use guards
19:32:00 <joe9> geekosaur: in this, both i and c are phantom types, correct? newtype M1 i c f p = M1 { unM1 :: f p }
19:32:15 <geekosaur> joe9, yes, and I even mentioned that earlier
19:32:31 <geekosaur> [20 03:00:34] <geekosaur> in your (their) newtype, f and p are used in the value, i and c are phantoms and only available as part of the type
19:32:37 <lordcirth> geekosaur, the guards nest inside one of the case matches, though, right?
19:32:43 <geekosaur> yes
19:33:10 <geekosaur> you can "cheat" though: case () of () | guardA -> ... | guardB -> ...
19:33:19 <geekosaur> (if-then-else actually gets turned into that, iirc)
19:33:53 <geekosaur> see also the MultiWayIf extension, which gets rid of the `() of ()` noise
19:33:58 <lordcirth> Not sure I understand that
19:34:37 <geekosaur> it's a dummy pattern match so you can put the real logic in the guards
19:35:07 <geekosaur> with MultiWayIf you can just write: case | guardA -> ... | guardB -> ...
19:35:11 <lordcirth> Basically I'm getting some keypress from a user, if it's a numpad / number, I want to hand that to a function that handles that group, etc
19:35:35 <geekosaur> where guardA might be something like theChar `elem` ['0' .. '9']
19:36:09 <lordcirth> I guess it would be better to just not use case at all, and use only guards?
19:36:26 <benzrf> geekosaur: i think you mean if | |
19:36:33 <geekosaur> if this is looking at vty events, you probably want a real case though, since you need to handle the different constructors
19:37:13 <lordcirth> I see
19:37:46 <lordcirth> So case match on all V.KChar events, and use guards on those?
19:38:00 <sm> somethink like https://github.com/simonmichael/hledger/blob/master/hledger-ui/Hledger/UI/AccountsScreen.hs#L321 ?
19:38:11 <sm> pattern matching + guards
19:38:21 <geekosaur> right
19:39:08 <lordcirth> You have multiple "VtyEvent (EvKey k [])" pattern matches?
19:39:21 <sm> yes, but with different guards
19:39:46 <lordcirth> I didn't realize it worked that way
19:40:06 <sm> they are like an extra condition augmenting pattern matching
19:40:08 <lordcirth> so the guards actually integrate into the case statement?
19:40:23 <lordcirth> I thought it just worked like nested ifs
19:40:23 <sm> yup
19:40:35 <lordcirth> Ok that works then
19:41:04 <geekosaur> they integrate, if one guard fails it tries the next, if all fail it tries the next case pattern
19:41:18 <lordcirth> nice
19:41:25 <sm> it is indeed
19:42:46 <Paprikachu> hi, is there a function that takes a binary function, a unary function and two arguments and calls the binary function with the results of applying the unary function to the arguments?
19:43:04 <geekosaur> (and if you don't want it to try the next pattern, add a guard for "otherwise" (or "True")
19:43:17 <geekosaur> :t on
19:43:18 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:43:33 <geekosaur> alternately, you might be looking for Applicatives
19:43:47 <geekosaur> (specifically the ((->) e) instance)
19:44:14 <lordcirth> that seems an oddly specific function
19:45:05 <geekosaur> you could call it the Haskell equivalent of the Schwartzian transform. it's often used with things like the *By functions in Data.List (and similar modules)
19:45:32 <Paprikachu> > ((+) `on` (+1)) 1 2
19:45:34 <lambdabot>  5
19:45:42 <Paprikachu> nice, thanks
19:46:08 <benzrf> is there some generalized abstraction for control flow graphs w/ monads
19:46:09 <wespiser> are they still publishing monadReader, the publication, not the monad abstraction?
19:46:24 <geekosaur> I haven't seen one in a long time
19:46:28 <wespiser> aug 2015
19:46:36 <benzrf> over which you could build, e.g., loops, imperative if, exceptions
19:46:56 <wespiser> shame, I'd like to get to that level some day!
19:47:58 <Hijiri> not really a control flow graph, but Cont?
19:49:53 <lordcirth> How do you get the Char out of the V.Key ?
19:51:31 <benzrf> Hijiri: hm
19:52:53 <Paprikachu> hmm, so this isn't working: u1 . b1 `on` u2 (where uN/bN denote unary/binary functions)
19:53:28 <lordcirth> nevermind I think I got it, pattern match on V.KChar k, bind k
19:53:34 <Paprikachu> what i want is: f a b = u1 $ b1 (u2 a) (u2 b)
19:54:04 <Paprikachu> f = u1 . b1 `on` u2 fails
20:02:20 <Paprikachu> http://ideone.com/43HDNH
20:04:33 <glguy> Paprikachu: it'll be a good exercise to understand why that fails
20:09:32 <Paprikachu> ugh, whatevs. homework is done
20:10:29 <amytran1997> ^ how to piss people off in IRC
20:12:02 <Paprikachu> i don't feel like playing guessing games
20:12:24 <Paprikachu> if you know why, just tell me; i don't care enough to waste an hour trying to figure it out
20:12:33 <justin_> how could I stop generating a sequence once i've gotten past a max value? genFibs = [fib y | y <-[1..], fib y < 4000000] ?
20:12:51 <justin_> 2nd day learning haskell, so sorry if it's obvious
20:12:59 <pavonia> :t takeWhile
20:13:01 <lambdabot> (a -> Bool) -> [a] -> [a]
20:20:11 <justin_> thankyou!
20:20:40 <wespiser> goodluck!
20:36:03 <justin_> right now I have written a function prime x = length (factors x) == 0 for telling if a number is prime
20:36:45 <justin_> is there a way to short-circuit? so that as soon as one factor is found the function returns?
20:36:51 <justin_> or does it do that automatically?
20:37:16 <geekosaur> not like that it won't
20:37:35 <justin_> okay didn't think so, any advice?
20:37:49 <geekosaur> but if you write instead: prime x = null (factors x)
20:38:12 <geekosaur> then it knows to stop as soon as the list is shown to be nonempty
20:38:57 <lordcirth> :t null
20:38:59 <lambdabot> Foldable t => t a -> Bool
20:39:09 <justin_> okay thanks, I didn't know about null
20:39:48 <lordcirth> that's interesting
20:39:53 <justin_> what can I do to improve my factors function? factors x = [ y | y <- [2..(quot x 2)], mod x y == 0]
20:39:56 <geekosaur> (or these days the Foldable, yeh; whether it will shortcircuit may depend on the specific instance, but for lists it should do the right thing)
21:02:32 <jchia_1> Last time when I asked someone how I should decide between using binary and using cereal, the answer I got essentially was that it's a coin flip. Is it still the same now? I would prefer to stick to one for my codebase but some external libraries I'll need to use may be based on one or the other other but not both.
21:04:37 <Clint> jchia_1: i don't think there are any compelling reasons to use cereal anymore
21:04:50 <jle`> binary has that performance bug though
21:04:52 <jle`> with Double's
21:05:18 <jle`> cereal also has safecopy
21:05:25 <jchia_1> Clint: How are binary & cereal different today so that there are no reasons to use cereal anymore?
21:06:06 <jchia_1> I noticed today that with binary, I automatically get the Binary instance for Fingerprint, but not with cereal.
21:06:14 <Clint> jchia_1: listen to jle`; he's clearly more up-to-date than i am
21:06:36 <jle`> binary had that really ugly bug that we found out about a year ago, i'm not sure if it's fixed yet
21:06:50 <jle`> people who aren't acid-ing usually don't use safecopy, but i really like it heh
21:06:59 <lordcirth> acid?
21:07:01 <jle`> there's a new kid on the block too, serial
21:07:17 <jle`> lordcirth: a haskell persistence/database replacement library
21:07:30 <lordcirth> Interesting
21:07:45 <jle`> FPComplete + snoyman's crew has 'serial' which just came out recently
21:08:08 <jle`> oh it's called 'store'
21:08:10 <lordcirth> Looks very nice
21:08:10 <jle`> sorry
21:08:20 <jle`> https://github.com/fpco/store/
21:08:28 <EvanR> what about binary CBOR
21:08:38 <jle`> oh yeah that's a thing too
21:08:53 <jchia_1> jle`: So there's a third option now?
21:09:18 <jle`> i mostly use binary out of habit and because more libraries seem to use Binary than Serialize
21:09:37 <jle`> i've never actually used 'store'
21:10:26 <Clint> i switched from cereal to binary when it achieved feature parity
21:10:36 <jle`> i like safecopy because i change my data types a lot and safecopy gives you backwards compatability when deserializing data written with old versions of your data types
21:11:10 <jle`> as for the binary double bug, serialization has never been a bottleneck for my applications, but i know that it's a big deal in other contexts
21:12:39 <jchia_1> It seems that store is not on stackage, though.
21:13:04 <jle`> that's kind of ironic heh, being an fpco project.  maybe that's their way of saying that it's not stable yet
21:14:00 <jle`> the benchmarks seemed pretty promising though
21:14:07 <jle`> but in the end for me it's up to library compatability
21:14:21 <jle`> in reality it's hard to avoid having both as reverse deps
21:14:28 <jle`> s/reverse//
21:15:04 <napping> store gives up binary compatibility, or at least architecture independence
21:15:24 <napping> it does seem to buy a lot of speed, if that's what you need
21:16:03 <jchia_1> binary compatibility between different versions of the package?
21:16:10 <joeyh> is there any way to compose 2 free monads? eg, I have one for network communication, and one for local IO
21:16:29 <napping> probably mostly between different architectures, maybe 32 vs 64 bits
21:16:44 <jle`> jchia_1: you can compose the functors
21:16:58 <jle`> and use the composed functor under Free
21:17:05 <jchia_1> jle`: I think you meant joeyh?
21:17:14 <jle`> oh yaeh, joeyh :)
21:17:15 <napping> joeyh: how fancy do you want to get? That's where things like data type a'la carte lead
21:17:53 <jle`> joeyh: but also, if your type is an operational summy type (either a network action or a local io action), you can use Sum
21:17:59 <joeyh> jchia_1: compose the functors how?
21:18:07 <jle`> data Sum f g a = InL (f a) | InR (g a)
21:18:07 <Clint> jchia_1: https://www.stackage.org/package/store
21:18:20 <jle`> data Compose f g a = Compose (f (g a))
21:18:24 <napping> poor jchia_1 getting all the messages about free monads
21:19:40 <jchia_1> Clint: OK, but it's not in the latest nightly, somehow
21:21:55 <napping> joeyh: how do you want to compose things, and how many?
21:23:23 * hackagebot conduit-combinators 1.0.8.2 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.8.2 (MichaelSnoyman)
21:26:18 <joeyh> napping: well, I want a Proto monad that can combine Net and Local actions, as needed. Not just one or the other.
21:26:55 <napping> using Sum will probably be easy enough
21:27:21 <napping> if you want to combine many things, the compdata package might help
21:35:03 <larryba> what mode is popular for haskell these days? haskell-mode? ghc-mode? something else
21:35:15 <larryba> ^ for emacs
21:43:18 <n_blownapart> hi please help me find my error on line 10 here https://www.refheap.com/123915 thanks
21:43:57 <napping> what's wrong?
21:44:15 <lordcirth> n_blownapart, what is the error message?
21:44:39 <napping> line 10 is fine
21:45:00 <napping> no instance Ord [Int] ?
21:45:09 <napping> look up "min" again
21:45:33 <lordcirth> oh, "where m = min xs" <- what?
21:45:46 <lordcirth> :t min
21:45:48 <lambdabot> Ord a => a -> a -> a
21:48:10 <n_blownapart> lordcirth, sorry one moment please
21:49:55 <n_blownapart> lordcirth https://www.refheap.com/123916
21:50:33 <n_blownapart> sorry napping lordcirth I was interrupted one moment please
21:50:42 <lordcirth> n_blownapart, thanks, but he already saw your problem^
21:52:16 <lordcirth> 'min' is not the function you want
21:52:27 <n_blownapart> absolute beginner here, please explain Ord ...
21:52:48 <lordcirth> n_blownapart, I think you want 'minimum'
21:52:53 <lordcirth> :t min
21:52:55 <lambdabot> Ord a => a -> a -> a
21:52:57 <lordcirth> :t minimum
21:52:58 <lambdabot> (Foldable t, Ord a) => t a -> a
21:53:19 <n_blownapart> ok thanks lordcirth looking at that
21:55:10 <n_blownapart> that worked thanks. I'm using an older book that uses hugs, if that makes a difference
21:55:21 <EvanR> which book
21:55:39 <lordcirth> what's hugs?
21:55:43 <n_blownapart> the Haskell Road to Logic, Maths and Programming  .. slightly older
21:55:48 <napping> not much here, just that hugs would have minimum :: (Ord a) => [a] -> a
21:56:13 <EvanR> oh that one uses hugs... uhg
21:56:53 <n_blownapart> yeah .. any comments on the book? I bailed on scheme because of the sicp book was killing me.
21:57:27 <n_blownapart> I'm trying to learn programming and math together
21:58:37 <n_blownapart> EvanR, every use it ?  ^^
21:58:43 <n_blownapart> ever*
21:59:42 <EvanR> no but like you discovered its incompatible with modern haskell
22:00:04 <n_blownapart> dang 
22:00:38 <n_blownapart> I heard its an interesting book. most of the code has been working
22:04:58 <EvanR> thats good
22:06:38 <jle`> if you're trying to learn haskell, haskell roda to logic, maths, and programming is not a book you'd read to get to that goal
22:07:39 <jle`> in fact, it's one of the worst paths you can take if learning haskell is your goal
22:07:51 <jle`> n_blownapart ^^
22:08:01 <jle`> i can think of only a few worse things you can do
22:08:07 <n_blownapart> jle`, thanks, I'm going to use others . I want a challenge similar to sicp. what is your experience with that book?
22:08:19 <jle`> it's a good book, but it's not meant for learning haskell
22:08:32 <jle`> it's like learning haskell from reading Harry Potter
22:08:37 <jle`> both great books, but unrelated to learning haskell
22:09:04 <kid_icarus> i read learn you a haskell, figured out some basics, and module syntax now i want to start playing with libraries and make something
22:09:27 <wespiser> yea, there needs to be a SICP for Haskell
22:09:32 <n_blownapart> I think I'm going to get Haskell: the Craft of FP  jle` 
22:09:51 <n_blownapart> based on a recommendation 
22:09:57 <wespiser> n_blownapart: read Stephen Diehl
22:10:16 <wespiser> all his stuff is free, and its geared towards industry
22:10:43 <n_blownapart> fwiw I'm not a programmer . self-taught in a bit of ruby and the first 24 problems of sicp wespiser jle` 
22:10:59 <wespiser> i'm self-taught to
22:11:13 <wespiser> well, i didn't major in it, I sort of picked it up on the job
22:11:25 <n_blownapart> thanks for the tip on Diehl
22:12:14 <wespiser> np, what I wish when I was learning haskell is probably the most comprehensive, up to date resource
22:13:10 <ogkloo> or do what I did and fail your way to being mildly proficient
22:13:35 <wespiser> yea, which includes a decent way to grok monads
22:14:33 <ThusSpakeHarambe> ruby isnt a language
22:14:37 <ThusSpakeHarambe> its ruby on rails!
22:15:11 <wespiser> matz would disagree
22:15:26 <n_blownapart> wespiser, the Haskell Road to Logic, Maths and Programming teaches how to do proofs. I first became interested in haskell because a friend said its a good way to learn math. I read about "programs as proofs" a little and got interested. any comment. btw I didn't like Rails
22:16:12 <n_blownapart> I could never figure out what was happening with Rails. At least in Scheme you can see what is happening 
22:16:45 <wespiser> yea, Haskell got me really into Type Theory and Category Theory. You use a lot of algebraic composition when programming Haskell, but its really nothing more than high school math, just a little bit more complicated.  If you want to see some really heady stuff, check out the work of Edward Kmett!
22:17:02 <ThusSpakeHarambe> matz? you mean david hansson?
22:17:50 <n_blownapart> ruby is pretty. Rails seemed so clunky
22:17:56 <systemfault> saturday night trolling
22:18:16 <wespiser> https://en.wikipedia.org/wiki/Yukihiro_Matsumoto
22:18:28 <wespiser> lol, oic
22:18:48 <ThusSpakeHarambe> its a joke about how rubys only popular because of RoR
22:19:16 <n_blownapart> Diehl What I wish I knew when Learning Haskell ... that one wespiser  ?
22:19:23 <wespiser> yea
22:20:05 <systemfault> ThusSpakeHarambe: It's the truth...
22:20:08 <systemfault> Joke or not.
22:20:50 <wespiser> either fail fail (choose RoR LAMP)
22:21:30 <n_blownapart> for someone new you think its good? there's a section on Emacs / Vim integration ( about ready to toss Atom ) wespiser 
22:21:47 <wespiser> Learn You a Haskell for great good
22:21:55 <wespiser> i read that cover to cover first
22:22:06 <n_blownapart> thanks
22:22:24 <EvanR> ruby is still not popular, only RoR is
22:22:29 <wespiser> Diehl's is a good reference
22:22:58 <wespiser> does anyone know a dev using ruby not RoR?
22:23:23 <EvanR> i mean, shops do when they have RoR
22:23:25 * hackagebot haskelisp 0.1.0.2 - Write Emacs module in Haskell, using Emacs 25's Dynamic Module feature  https://hackage.haskell.org/package/haskelisp-0.1.0.2 (shintak)
22:23:29 <ThusSpakeHarambe> happy haskell
22:23:30 <EvanR> use ruby for everything else if they can help it
22:23:35 <ThusSpakeHarambe> is easier if you're more tarded
22:23:42 <ThusSpakeHarambe> like me
22:24:06 <ThusSpakeHarambe> http://www.happylearnhaskelltutorial.com/
22:24:29 <n_blownapart> any comments on editors ? Atom is patchy
22:24:40 <n_blownapart> ide-haskell ^
22:24:42 <EvanR> vim
22:25:23 <ThusSpakeHarambe> i use sublime text for pretty much everything
22:25:43 <wespiser> vim
22:25:47 <n_blownapart> I don't know anything about editor integration / spaceMacs all that stuff. sounds cool though
22:25:54 <wespiser> i use atom for editing *.md files
22:26:22 <ThusSpakeHarambe> sublime is for winners
22:26:28 <EvanR> learning vim to learn haskell probably has a more plausible sounding "you will learn something valuable even if you dont end up using haskell" story attached
22:26:49 <ThusSpakeHarambe> or you just burn out after a day and dont learn anything
22:26:51 <EvanR> than just learning haskell
22:27:05 <EvanR> burn out right, but maybe the haskell part is the secret sauce to keep going
22:27:11 <EvanR> to keep it interesting
22:27:41 <wespiser> yea, it took my a couple tries to learn Haskell. 
22:27:43 <n_blownapart> I was reading that in spaceMacs you have vim as default. what's that mean?
22:28:15 <ThusSpakeHarambe> it takes me like 100 tries to learn everything, im pretty persistent though
22:28:24 <srhb> n_blownapart: Spacemacs, not spaceMacs. And presumably just that it has vi key bindings as default. 
22:28:45 <augur> is anyone familiar with how to do line-folding in parsec w/ the indents package
22:28:46 <augur> ??
22:28:56 <n_blownapart> thanks srhb 
22:29:34 <augur> i cant for the life of me understand how this is supposed to work
22:30:07 <augur> i need some way to prevent a line form continuing to be parsed after the indentation shifts back out :(
22:30:53 <wespiser> augur: there is an example indent parser for python out there somewhere, have you found that?
22:31:05 <augur> what?
22:31:14 <wespiser> it came up on the aggregators alittle while ago
22:31:28 <n_blownapart> Diehl looks like a great resource
22:33:25 <wespiser> https://spin.atomicobject.com/2012/03/16/using-text-parsec-indent-to-parse-an-indentation-sensitive-language-with-haskells-parsec-library/
22:33:30 <wespiser> I don't know if that will help or not
22:35:06 <wespiser> n_blownapart: yea, Stephen as contributed a ton of work to that
22:39:24 <augur> wespiser: yes, ive seen that, but it doesn't deal with line folding
22:39:48 <augur> i'm trying to modify that code to handle line-folding. it's not clear how to do this
22:41:03 <wespiser> yes, I see now. I'd have to think about the rules for line folding and indenting
22:41:33 <wespiser> you can only line fold when the starting line is not indenting, correct?
22:42:28 <augur> no
22:42:57 <augur> consider where definitions in haskell, where the where clauses are indented further than the "where" keyword
22:43:15 <augur> but each clause is line-folded, so that subsequent lines that indent further are part of the previous line
22:43:25 <wespiser> okay, i see the definition in the indent package
22:59:30 <n_blownapart> wespiser hi wondering, what about using haskell-vim-now which looks like an easy install
22:59:45 <wespiser> yea, i use it
22:59:49 <wespiser> ghc-mod is helpful
23:00:15 <n_blownapart> Diehl has another way to install that looks way complicated
23:01:05 <n_blownapart> I wonder if the stack I have already installed will conflict with the vim dependencies wespiser 
23:01:32 <wespiser> tbh i forgot how i did it
23:08:30 <lolguy> hey guys
23:09:26 <cocreature> hey lolguy 
23:26:34 <n_blownapart> wes*piser et al anyone know how I learn how to use haskell-vim-now  ? no clue is there a tutorial somewhere?
23:32:19 <wespiser> no idea, sorry
23:33:38 <n_blownapart> thanks I'll find something on youtube
