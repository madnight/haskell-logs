00:00:06 <meditans> and manually unwrap Identity each time, etc
00:00:11 <kosmikus> meditans: a "classic" example would be the validation example from the SOP paper
00:00:30 <meditans> kosmikus: I somehow missed that, googling
00:00:48 <meditans> true sums of products?
00:01:33 <kosmikus> meditans: there "validationRules" has a result type of POP (I -.-> K Bool) (Code a)
00:01:44 <kosmikus> meditans: so it's not using an associated type explicitly
00:01:58 <kosmikus> meditans: but it could be one, which has this as its default definition
00:05:16 <kosmikus> meditans: yes, "Generic Programming with True Sums of Products"
00:05:16 <kosmikus> meditans: Section 6.3
00:05:16 <meditans> kosmikus: perfect, thanks for the pointers, I'll read this now and try to write a solution :)
00:05:16 <kosmikus> meditans: what you want sounds difficult though
00:05:16 <kosmikus> meditans: so you won't be able to get anything out of that type family that feels like a first-class datatype
00:05:39 <meditans> kosmikus: oh, and why does that happen? What will I miss?
00:05:53 <unclechu> hey guys, I see that most of the people use `(&)` as pipe operator that in case is implemented as `flip ($)` but how about flipped compose operator `(.)`? how people usually names it?
00:05:56 <kosmikus> meditans: so if you have something like "data Foo = C ... Bar ..." and want to turn it into "data Foo' = C' ... Baz ...", then there's no way to generically declare a datatype Foo' and a constructor C'
00:06:39 <kosmikus> meditans: the best you can get is some structural representation of the Foo' type
00:07:38 * hackagebot cereal 0.5.4.0 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.4.0 (TrevorElliott)
00:07:38 * hackagebot sibe 0.2.0.3 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.3 (mdibaiee)
00:07:41 <meditans> kosmikus: so, a Code Foo'? Why couldn't I turn that into a Foo' afterwards?
00:07:54 <kosmikus> meditans: because there is no Foo'
00:08:09 <kosmikus> meditans: except if you already have it defined somewhere
00:08:29 <kosmikus> meditans: but you cannot generically create a new datatype with a new name
00:09:09 <meditans> oh, I cannot create a datatype from its code? That seems a quite heavy limitation, you're right
00:09:19 <liste> :t (>>>) `asAppliedTo` (const undefined) -- unclechu 
00:09:22 <lambdabot> (a -> b) -> (b -> c) -> a -> c
00:09:22 <polo> how do I define type of the following function:superimpose = zipWith wavg where wavg x y = (x + y + (max x y))/3
00:09:32 <kosmikus> meditans: nothing can create a new top-level declaration except Template Haskell
00:09:41 <polo> I did this:superimpose::(Num a)=> (a -> a)->[a] but was wrong.
00:09:55 <unclechu> liste: is it from some library?
00:10:07 <liste> unclechu: Control.Category
00:10:15 <unclechu> liste: thanks
00:10:28 <polo> let superimpose = zipWith wavg where wavg x y = (x + y + (max x y))/3
00:10:35 <polo> :t superimpose
00:10:37 <lambdabot> error: Variable not in scope: superimpose
00:11:07 <liste> :t let superimpose = zipWith wavg where wavg x y = (x + y + (max x y))/3 in superimpose
00:11:10 <lambdabot> (Ord c, Fractional c) => [c] -> [c] -> [c]
00:11:45 <polo> lsite: why fractional?
00:11:58 <liste> polo: the (/)
00:12:01 <liste> :t (/)
00:12:02 <lambdabot> Fractional a => a -> a -> a
00:12:13 <liste> :t div
00:12:15 <lambdabot> Integral a => a -> a -> a
00:16:01 <meditans> kosmikus: right, but I will be able to declare manually the derived datatype, so it's essentially a few lines of boilerplate, right?
00:16:47 <kosmikus> meditans: that's one option you have. or perhaps you don't need to have constructors for that type and can just work with the representation.
00:17:12 <kosmikus> meditans: anyway, good luck. let me know how it works out.
00:17:27 <meditans> kosmikus: sure, thanks again for the suggestions!
00:18:22 <younder> ctrl-c sends sigterm which allows for cleanup. sigkill kills the process at os level 
00:19:19 <kosmikus> meditans: btw, another non-trivial computation on the type level happens in generics-sop itself, in Generics.SOP.GGP, where there's a type-level computation that computes GCode a from the GHC-derived generic representation
00:34:04 <bollu> quick HoTT question: so, sigma types is like a tuple with the second type dependant on the first type, right?
00:36:03 <phadej> bollu: yes
00:36:17 <phadej> on the value of the 'fst'
00:36:21 <bollu> right
00:36:23 <bollu> thanks :)
00:36:49 <bollu> so, pi: dependant type function. sigma: dependant tuple. + : coproduct. So far so good, right?
00:37:42 <phadej> yeah. It's a but confusing, as tuple is product, but sigma is a sum ;)
00:38:50 <bollu> yes xD
00:39:40 <bollu> Also, I didn't really understand the "aoc" version they present in chapter 1. how is it a choice function? a choice function is something that lets you take an infinite product of infinite sets and pick one out of each set. I don't really see a "choice function" there
00:41:13 <phadej> I don't remember HoTT unfortunately that well :(
00:41:25 <bollu> ah, okay :)
00:44:17 <phadej> otoh, aoc can be massaged in very different but equivalent definitions, so it's more of aoc stuff than hott probably
00:47:34 * hackagebot transient 0.4.4.1 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.4.4.1 (geraldus)
00:49:00 <Cale> bollu: An infinite product of nonempty sets
00:49:23 <bollu> Cale: yes, meant that :)
00:49:28 <bollu> Cale: 	but I don't get the flavour
00:49:54 <bollu> Cale: how is the choice function presented a "choice function"? I couldn't see it
00:50:03 <Cale> bollu: Which one?
00:50:13 <bollu> Cale: chapter 1
00:50:24 <bollu> Cale: lemme link it
00:51:17 <Cale> There's no reference to the axiom of choice in chapter 1
00:52:09 <Cale> Do you mean in the introduction?
00:52:28 <Cale> oh, sorry
00:53:00 <Cale> I missed it -- somehow it's not in the index
00:53:10 <Vyn> It's in the second chapter?
00:53:32 <Vyn> After Theorem 2.15.7?
00:53:56 <Cale> There's a mention of the type-theoretic axiom of choice in 1.6
00:54:09 <Cale> i.e. the one which is a theorem
00:54:20 <bollu> Cale: page 32
00:54:21 <bollu> yes
00:54:25 <bollu> that one
00:54:49 <Vyn> Ah
00:55:11 <bollu> uh, how do I read it like AoC?
00:55:14 <HansTrashy> Hi! I'm trying to query some data from a sqlite database with sqlite-simple and that works fine somewhat, my problem is that the database contains characters like "é" and so on. My output then just looks like "Almer\237a". Someone has a clue why this happens?
00:55:20 <Cale> Well, if you replace the Sigma by "exists" and the Pi by "for all" and types by sets, this is exactly the traditional statement of the axiom of choice
00:55:40 <merijn> HansTrashy: I'm guessing you're using show/print on String/Text?
00:56:23 <Cale> Well, okay, the "family of sets" might look a little different here
00:56:24 <bollu> Cale: really? what role does the R play here?
00:56:35 <bollu> Cale: could you unpack it for me please?
00:57:37 <HansTrashy> merijn: im using it like this http://lpaste.net/334286
00:57:46 <Cale> So you can think of A as indexing the family of sets, and B as indexing their union, and R(x,y) meaning that y is an element of the set corresponding to x
00:58:57 <Cale> and this says that whenever you have such a situation where for any such x in A, there must be some y in B for which "y is a member of x" (or the set corresponding to y is a member of the set corresponding to x)
00:59:00 <bollu> Cale: so R is the choice function? the thing that's picking elements out of the union?
00:59:05 <Cale> f is the choice function
00:59:12 <Cale> R is the element-of relation
00:59:12 <merijn> HansTrashy: You don't want to use hPrint, that uses show on Text/String, which escapes special characters
00:59:16 <bollu> ah
00:59:32 <merijn> > show "ë"
00:59:34 <lambdabot>  "\"\\235\""
00:59:39 <merijn> > text "ë"
00:59:42 <lambdabot>  ë
01:00:33 <Cale> bollu: Or I should say "contains as an element"
01:00:39 <bollu> R(x, y) means y \in x?
01:00:42 <merijn> HansTrashy: Use either System.IO.hPutStrLn (for String) or Data.Text.IO.hPutStrLn (for Text)
01:00:42 <Cale> bollu: since the arguments are the other way around
01:00:43 <Cale> yeah
01:00:50 <bollu> hm
01:01:54 <Cale> So if for all x in A (the family of sets), we have some y in B (the union of that family) for which y is a member of x, that is, if all the members of the family of sets are nonempty
01:02:32 <Cale> Then there is some choice function f: A -> B, assigning to each member of the family of sets, some member of their union, such that for all x in A, we have that f(x) is a member of x
01:02:42 <HansTrashy> thank you merijn ill try that
01:02:50 <bollu> ohh
01:02:51 <Cale> bollu: right?
01:02:57 <bollu> yes! :)
01:03:05 <bollu> "for which y is a member of x, that is, if all the members of the family of sets are nonempty" <- thank you, that was crucial
01:03:17 <bollu> I didn't realise that it was phrasing "non-emptiness" 
01:03:35 <Cale> bollu: The thing which makes this very unlike the usual axiom of choice is that Sigma is stronger than usual classical existence.
01:04:05 <bollu> Cale: in the sense that? you need to actually provide the value whose existence you're talking about? 
01:04:07 <Cale> and to provide a proof of Sigma (y:B), R(x,y), you have to say which y you chose.
01:04:27 <Cale> So the antecedent here will already in some sense *be* a choice function
01:04:53 <Cale> Which for each x in A, not only picks some y in B, but also pairs that with a proof that y is a member of x
01:05:14 <Cale> So, that's why it's a trivial theorem
01:05:19 <bollu> hm, I see
01:05:35 <Cale> and it's also why you can't use it to do any of the fun things you can use the classical axiom of choice to do
01:06:41 <Cale> (because it's too hard to obtain the antecedent required)
01:07:19 <bollu> hm
01:07:25 <nz`> why should I learn Haskell instead of Scheme, OCaml etc?
01:07:28 <bollu> Cale: I should be able to code all of this right?
01:07:31 <Cale> Later in the book, there are some other versions of the axiom of choice which use the propositional truncation or other truncations, and they have more of the character of the classical one.
01:07:34 <bollu> Cale: which language can I use?
01:07:40 <Cale> Coq, Agda
01:07:44 <Cale> cubical
01:07:55 <bollu> Cale: what would you recommend?
01:08:34 <Cale> Try Coq -- you don't necessarily even need the version and library specific to homotopy type theory.
01:08:53 <bollu> all right, cool
01:09:00 <bollu> what imports would I need?
01:09:04 <Cale> none
01:09:18 <bollu> wait, what
01:09:19 <Cale> here, I'll write it if you like
01:09:20 <bollu> ?
01:09:23 <bollu> sure
01:16:02 <bollu> Cale: what's the Coq version?
01:17:21 <lpaste> Cale pasted “Axiom of Choice in Coq.” at http://lpaste.net/334288
01:18:10 <Cale> Just had to translate to Coq's notation and carry out the proof -- it will help perhaps to step through it if you have coqide open.
01:19:11 <Cale> fun x => ... is Coq's notation for lambda
01:19:33 <Cale> and projT1/projT2 are the projections of the dependent pair type
01:19:38 <Cale> (the Sigma type)
01:20:43 <Cale> The thing at the end is just a printout of the term that interactively-constructed proof generated
01:23:17 <younder> hmm. "Introduction to lattices and order" by Davey and Priestly is the best introduction to 'thinking haskell'  I have seen. I'm supprised,  this math books really filled in a few gaps in my knowlege.
01:24:06 <Cale> I can see how that might be useful
01:26:41 <Cale> Well, I don't think there are really such a great number of results of lattice theory that are helpful on a regular basis, but the definitions such that you can understand what a directed-complete partial order is, and what Scott continuity is about are likely helpful.
01:27:27 <Cale> at least, when it comes down to really understanding the details of the denotational semantics
01:28:10 <Cale> I should be asleep
01:28:20 <Cale> bollu: sorry for not explaining that Coq code further right now
01:28:38 <Cale> bollu: I can help you with it later, or I'm sure there are others around who can help
01:31:57 <abe> why lengthLambda = sum ( map (\_ -> 1) ) doesn't work but lengthLambda = sum . map (\_ -> 1)  works?
01:32:20 <abe> also why lengthLambda = sum $ map (\_ -> 1)  does not work?
01:36:08 <sdx23> abe: 3 and 1 is the same. 1 is essentially a sum over functions.
01:37:06 <merijn> abe: Sum takes a list as argument. "map (\_ -> 1)" is a function, not a list
01:41:31 <abe> sdx23: what do you mean by 3 and 1 is the same?
01:42:00 <delYsid> abe: Because you need function composition if you want to omit arguments.
01:42:46 <delYsid> abe: lengthLambda l = sum ( map (\_ -> 1) l)  would work.
01:43:02 <abe> delYsid: to my understanding, I thought "." and "$" like the as () 
01:43:34 <delYsid> huh?
01:43:34 <abe> sum (odd [1,2,3,4,5,6])
01:43:52 <abe> > sum (odd [1,2,3,4,5,6])
01:43:54 <lambdabot>  error:
01:43:55 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Bool’
01:43:55 <lambdabot>      • In the first argument of ‘sum’, namely ‘(odd [1, 2, 3, 4, ....])’
01:44:43 <delYsid> > sum $ filter odd [1,2,3,4,5,6]
01:44:48 <lambdabot>  9
01:45:02 <abe> delYsid: I thought parenthesis and . work the same way?
01:45:10 <delYsid> no
01:45:43 <delYsid> . is function composition
01:45:52 <younder> > sum (map odd [1..5])
01:45:55 <lambdabot>  error:
01:45:55 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘sum’
01:45:55 <lambdabot>      • In the expression: sum (map odd [1 .. 5])
01:46:27 <delYsid> no, you can not sum Bools.
01:46:35 <delYsid> @type odd
01:46:37 <lambdabot> Integral a => a -> Bool
01:46:38 <Salih> younder sum(1..5)
01:47:05 <mniip> there's 'and' and 'or'
01:47:11 <Salih> younder sum([1..5])
01:47:27 <younder> > sum (filter odd [1..5])
01:47:29 <lambdabot>  9
01:47:35 <younder> more like it
01:48:01 <Salih> younder sum([1..5])filter betteR =)
01:48:08 * younder blushes over his brainfart
01:57:37 * hackagebot operate-do 0.1.0 - Simple project template from stack  https://hackage.haskell.org/package/operate-do-0.1.0 (mizunashi_mana)
02:02:06 * younder notes sum [1..5]  = (1+5)/2 * 5 = 15 and sum [1,3..5] = (1+5)/2 * 3 = 9, but Haskell doesn't realize the elements are evenly seperated
02:02:37 * hackagebot cli-builder 0.1.0 - Simple project template from stack  https://hackage.haskell.org/package/cli-builder-0.1.0 (mizunashi_mana)
02:03:17 <younder> evenly as in equidistant
02:04:07 <lyxia> Haskell doesn't realize a lot of things.
02:04:51 <merijn> Haskell doesn't do anything, it just is. I think you mean GHC :p
02:05:11 <merijn> Relatedly, what guarantees does GHC give me about the promptness of running finalizers for ForeignPtrs?
02:09:01 <younder> merijn, it is possible to pattern-match somthing like this, but I think it would be a mess to program all cases. (no sentinence required)
02:10:59 <lyxia> There's not much to gain with such an optimization.
02:11:31 <lyxia> It only makes homework programs run faster.
02:13:11 <younder> lyxia, For now it is better to let us do it. Still doing math autonomously is somewhat if a holy grail in CS.
02:17:38 * hackagebot conduit-extra 1.1.14 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.14 (MichaelSnoyman)
02:17:40 * hackagebot http-client 0.5.4 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.4 (MichaelSnoyman)
02:52:39 * hackagebot IPv6Addr 0.6.2.0 - Library to deal with IPv6 address text representations.  https://hackage.haskell.org/package/IPv6Addr-0.6.2.0 (MichelBoucey)
02:54:22 <Darwin226> Here's a puzzle. Is it possible to write a `(m a -> m b) -> m (a, c) -> m (b, c)` function without "executing" the action twice?
02:56:04 <merijn> Darwin226: Assuming "Monad m =>" ?
02:56:28 <Darwin226> Yeah
02:56:33 <merijn> I think so?
02:56:44 <Darwin226> Though it may be interesting to see if you can do it with less
02:56:55 <Darwin226> I can't figure it out for Monad
02:57:53 <merijn> Oh, hmmm. For Kleisli it'd be easy, but this isn't quite Kleisli
02:58:02 <byorgey> you have to execute it to get a 'c' value out.  Then you have to pass an 'm a' to the function, which may or may not 'execute' the m a
02:58:14 <byorgey> then stick the c into the result
02:58:20 <Darwin226> Hmm, you could go m (a, c) to m (m a, c) to m (m b, c) to m (m (b, c)) to m (b, c) but I don't know how many times this executes the action
02:59:04 <byorgey> oh, interesting, but that would have different behavior than what I described
02:59:28 <byorgey> well, it might.  hmm.
02:59:48 <merijn> Oh, wait, I think it's easy?
03:00:16 <merijn> Lemme try and simplify
03:00:52 <Darwin226> The problem with the above approach is that the `m a` that I give to the function is just `return a`
03:00:59 <Darwin226> so it might not be the same thing
03:01:06 <merijn> oh, wait, yeah
03:03:16 <lyxia> throw in some unsafePerformIO to store c...
03:04:29 <Darwin226> if (m a -> m b) was forkIO, then the whole thing becomes `(IO a -> IO ThreadId) -> IO (a, c) -> IO (ThreadId, c)`. If there was a way to execute IO (a, c) only once that would mean that only the IO a part got forked, right?
03:06:01 <lyxia> That sounds lke a reasonable interpretation, if only infeasible.
03:06:42 <Darwin226> Yeah, I think that means it can't be done for a Monad in general.
03:10:59 <kuribas> So now proof it cannot be done (without _|_)?
03:12:05 <Darwin226> Well, it's been reduced to a less interesting problem, so I'm done right? :D
03:12:37 <kuribas> Darwin226: is this a practical problem?
03:12:52 <Darwin226> semi practical
03:15:01 <kuribas> To get (m a) out of m (a, c) you have to discard c.
03:15:19 <kuribas> I don't think you can recover c
03:15:30 <M2tias> why not? :o
03:15:46 <M2tias> isn't that like [a] and [a,c]?
03:16:04 <kuribas> because a monad doesn't allow the inner type to escape (which is why IO works).
03:16:39 <kuribas> M2tias: no, because a and c have the same type.
03:16:41 <Darwin226> intuitively it's confusing because it seems like you should be able to convert a (m a -> m b) function to (m (a, c) -> m (b, c)) just like you can do for m ~ Identity
03:16:43 <opqdonut> and "fmap fst ma" doesn't count for some reason I can't formulate
03:17:06 <opqdonut> right you can't get the c back later
03:17:40 * hackagebot regex-do 1.7 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.7 (procione)
03:18:09 <kuribas> Darwin226: Not without executing it twice.
03:18:47 <M2tias> kuribas: right
03:19:26 <Darwin226> puzzle f m = join $ fmap (\(a, c) -> fmap (\b -> (b, c)) $ f (return a)) m
03:21:39 <sdx23> http://lpaste.net/334315 would you consider sameInside'' better or sameInside? If so why? I'd say sameInside'' is nicer, but it has extra dependencies.
03:21:54 <Darwin226> This typechecks and matches the above type
03:22:13 <Darwin226> but the inferred type I think shows why it doesn't quite do the right thing semantically
03:22:15 <Darwin226> puzzle   :: (Monad m, Monad m1) => (m1 a -> m t) -> m (a, t1) -> m (t, t1)
03:22:56 <Darwin226> m1 is separate from m.
03:23:20 <sdx23> (background: just skimmed through https://hackage.haskell.org/package/IPv6Addr-0.6.1.0/docs/src/Text-IPv6Addr.html#sameIPv6Addr and wondered about the implementation)
03:23:44 <lyxia> Darwin226: that looks like a profunctor thing
03:24:00 <lyxia> http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor.html
03:24:09 <lyxia> Strong
03:24:17 <opqdonut> sdx23: sameInside'' is best, but I might use applicative instead of monad, so (==) <$> f a <*> g b
03:24:42 <opqdonut> sdx23: nested pattern matches of Maybe is just screaming for Monad (or Applicative in this case)
03:24:59 <Darwin226> lyxia: I don't know how to conclude anything from that
03:27:46 <lyxia> Maybe staring at profunctors long enough will give you an idea of a generalization of whatever structure you are looking for.
03:28:18 <sdx23> opqdonut: ah, Applicative is a nice hint. I guess I overlook that too easily
03:30:09 <opqdonut> sdx23: the trend these days seems to avoid using Monad when Applicative is enough
03:30:20 <opqdonut> sdx23: it's a useful pattern
03:31:21 <sdx23> opqdonut: that's why I tried rewriting that, when I saw it. I should practice this sort of things more.
03:31:41 <nevere> Why do I get this error with this typeclass declaration http://lpaste.net/303140?
03:33:34 <byorgey> nevere: since the type variable 'columnsW' does not show up in the type of 'makeCreatable' except in a constraint, it cannot be inferred from a use of 'makeCreatable'
03:34:57 <byorgey> nevere: one solution might be to enable FunctionalDependencies and declare that a and b together determine createW, i.e.    class Creatable a b createW | a b -> createW  where ...
03:35:12 <nevere> byorgey: Yes
03:35:33 <byorgey> or perhaps you should use an associated type family to compute the type createW from a and b.  But without knowing what you are trying to do I'm really not sure.
03:36:39 <byorgey> nevere: did you write the Creatable class yourself?  or is it from a library?
03:37:16 <nevere> byorgey: Not from a library.
04:03:45 <merijn> What guarantees does GHC give me about the promptness of running finalizers for ForeignPtrs?
04:07:14 <kuribas> Why doesn't IntMap support Int32 as Key?
04:07:42 * hackagebot text1 0.0.4 - Non-empty values of `Data.Text`.  https://hackage.haskell.org/package/text1-0.0.4 (TonyMorris)
04:07:59 <merijn> kuribas: Because it's not Int32Map?
04:08:12 <kuribas> merijn: where can I find Int32Map?
04:08:23 <merijn> It doesn't exist, afaik
04:09:00 <kuribas> Back to Data.Map then...
04:23:26 <dxtr> Hi! I'm having two interesting issues that might or might not be related
04:24:01 <dxtr> https://github.com/dxtr/hsidentd/blob/master/src/Lib.hs <- setSocketOption is not working on ipv6 sockets on openbsd
04:25:10 <dxtr> According to ktrace it's trying to do this:  18083 hsidentd CALL  setsockopt(27,41<ipv6>,27,0x2ec105478,4)
04:25:21 <dxtr> Which results in 18083 hsidentd RET   setsockopt -1 errno 22 Invalid argument
04:25:53 <dxtr> And it's not listening on the ipv6 socket at all (I assume that setsockopt error is related to that)
04:27:28 <oherrala> dxtr: OpenBSD doesn't have IPv4/6 dualstack
04:27:48 <dxtr> oherrala: What do you mean?
04:27:59 <oherrala> dxtr: so if your problem is this "when (af == AF_INET6) $ setSockOpt sock IPv6Only 1"
04:28:11 <dxtr> No I tried removing that line
04:28:18 <dxtr> And it's still failing on setSocketOption
04:28:48 <oherrala> dxtr: which one?
04:29:37 <oherrala> dxtr: and I mean that OpenBSD socket is either IPv4 or IPv6, but not both at the same time.
04:30:08 <dxtr> oherrala: which is why I am opening two separate sockets
04:30:55 <dxtr> Actually, I lied
04:31:26 <dxtr> Even if I remove all setSocketOption calls it's still trying to make a setsockopt() on the socket
04:35:32 <merijn> dxtr: That's because the runtime system marks all sockets as non-blocking by default, afaik
04:36:48 <dxtr> merijn: According to the trace here it doesn't do that with setsockopt() but rather with a flag to accept()
04:37:04 <dxtr>  47445 hsidentd CALL  accept4(27,0x274217010,0x274217040,0x4000<SOCK_NONBLOCK>)
04:41:00 <kuribas> Is seeking forward and backwards when writing a file cheap?
04:41:33 <kuribas> For example for writing a checksum.
04:41:41 <merijn> kuribas: Yes
04:41:42 <hpc> theoretically it's just changing a single int
04:41:56 <hpc> i would be more concerned about the repeated non-local reads/writes that come with those seeks
04:42:12 <kuribas> hpc: it should be buffered on any modern system.
04:42:55 <kuribas> I just want to avoid have the whole lazy bytestring in memory.
04:43:24 <merijn> dxtr: sockopt 27 seems to be...SO_DETACH_FILTER? On linux, at least. Not sure about on OpenBSD
04:43:38 <merijn> kuribas: You can't seek on a bytestring
04:43:54 <dxtr> merijn: 27 is the socket, isn't it?
04:44:07 <merijn> dxtr: The 3rd argument is the option name
04:44:28 <dxtr> Oh that's right
04:44:46 <merijn> dxtr: Also, compile with "ghc -debug" and try to set a breakpoint on setsockopt to find where it comes from?
04:44:58 <merijn> i.e. whether it's from haskell code or the runtime
04:45:17 <kuribas> merijn: I am probably prematurely optimizing...
04:46:14 <dxtr> merijn: 27 doesn't even exist on openbsd
04:46:59 <dxtr> merijn: Do I just run the binary in gdb? 
04:47:13 <merijn> dxtr: Yeah
04:47:34 <dxtr> I guess removing -threaded is preferred too? :p
04:47:38 <merijn> dxtr: Right, so sock option 27 not existing sounds like a pretty big redflag
04:48:07 <merijn> dxtr: Naah, that's ok. You said it happened if you removed all setsockopt calls from your code right? So I'm vaguely assuming it to be the runtime doing stuff
04:48:23 <merijn> dxtr: If it's coming from haskell code it's a bit trickier to catch
04:48:50 <dxtr> merijn: So.. Uhm.. Where do I set a breakpoint?
04:49:34 <merijn> dxtr: "break setsockopt"? :)
04:49:44 <dsub>    
04:50:05 <dxtr> merijn: Yeah that's what I did :p Was thinking if there was something else you had in mind
04:52:54 <dxtr> merijn: http://pastebin.com/NwYpLGjb
04:52:56 <dxtr> Hmm
04:53:19 <merijn> ok, so not the runtime...
04:53:36 <merijn> You'd have to look at the source of Network to figure out what it's calling
04:55:17 <dxtr>     when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
04:55:17 <dxtr>       setSocketOption sock IPv6Only 0 `onException` close sock
04:56:15 <dxtr> That seems very naive :p
04:56:30 <dxtr> So where do I send bug reports?
04:56:40 <dxtr> Or who do I talk to about this library? :P
04:57:44 * hackagebot regex-do 1.8 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.8 (procione)
04:58:06 <merijn> There's not really a bug to report, no? I'm not sure why this is failing.
04:58:32 <merijn> Somehow this line https://github.com/haskell/network/blob/master/Network/Socket.hsc#L917 is producing 27 as option for setsockopt
04:59:08 <merijn> Which is odd...
04:59:52 <merijn> Because that should just translate to whatever your C compiler thinks IPV6_V6ONLY is
05:00:11 <dxtr> And if IPV6_V6ONLY doesn't exist? :)
05:01:13 <dxtr> Oooh.. Is stack using precompiled libraries or something?
05:01:29 <merijn> Ding ding ding
05:01:31 <merijn> https://github.com/haskell/network/blob/master/include/HsNet.h#L39-L45
05:01:45 <merijn> Looks like your Network package thinks it's windows
05:02:22 <dxtr> I'm not sure
05:02:35 <dxtr> One min
05:03:16 <merijn> What was your error code?
05:03:21 <merijn> 22 EINVAL?
05:03:36 <dxtr> Yep
05:04:19 <dxtr> http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/netinet6/in6.h?rev=1.91&content-type=text/x-cvsweb-markup
05:04:27 <dxtr> Search for IPV6_V6ONLY there
05:04:35 <dxtr> It exists and has value 27
05:04:35 <merijn> Looks like BSD's in general don't allow that option on IP6 sockets: https://stackoverflow.com/questions/5587935/cant-turn-off-socket-option-ipv6-v6only
05:05:50 <dxtr> That I knew. I didn't know IPV6_V6ONLY still existed, though.
05:07:56 <oherrala> https://github.com/openbsd/src/search?utf8=%E2%9C%93&q=IPV6_V6ONLY
05:08:09 <dxtr> http://man.openbsd.org/OpenBSD-current/man4/ip6.4
05:08:15 <dxtr> With OpenBSD IPv6 sockets are always IPv6-only, so the socket option is read-only (not modifiable).
05:08:27 <oherrala> it's probably because all the GNU things
05:08:30 <dxtr> So it's there so you can read the value in run-time
05:08:52 <dxtr> oherrala: That makes sense
05:09:10 <merijn> dxtr: https://github.com/haskell/network/issues
05:10:21 <dxtr> I wonder if the same is applicable under all BSDs
05:10:45 <dxtr> ip6(4) on freebsd doesn't mention it
05:10:51 <merijn> dxtr: OSX doesn't mention it being readonly either
05:11:13 <merijn> dxtr: Sounds like OpenBSD is not conforming by making it read-only
05:11:56 <oherrala> merijn: what do you mean?
05:12:01 <dxtr> merijn: According to your stack overflow link freebsd is doing the same thing, though
05:12:05 <merijn> dxtr: btw, binding to localhost is probably not what you want. You'll want to either 1) bind a specific IP or 2) use INADDR_ANY
05:12:13 <merijn> dxtr: 
05:12:19 <merijn> oherrala: by what?
05:12:28 <oherrala> MarcelineVQ: "Sounds like OpenBSD is not conforming by making it read-only"
05:12:31 <oherrala> argh
05:12:35 <oherrala> for merijn that
05:13:23 <oherrala> merijn: isn't writable IPV6_V6ONLY pretty useless if IPv6 socket is only IPv6 socket? :)
05:13:31 <merijn> oherrala: On linux, OSX, and as far as I can tell the standard it's not supposed to be read-only
05:13:47 <merijn> oherrala: On linux: " If this flag is set to false (zero), then the socket can be"
05:13:50 <merijn>               used to send and receive packets to and from an IPv6 address
05:13:52 <merijn>               or an IPv4-mapped IPv6 address.
05:14:00 <dxtr> IPV6_V6ONLY isn't standard at all, right?
05:14:41 <merijn> dxtr: OSX man page says RFC 3542
05:14:49 <oherrala> merijn: but there's no such dual stack thing on OpenBSD
05:14:55 <merijn> "The IPV6_V6ONLY socket option is defined in RFC 3542."
05:15:04 <merijn> oherrala: So? Then they should make it a no-op
05:15:15 <merijn> oherrala: By not confirming things like this break
05:15:27 <merijn> *conforming
05:15:28 <dxtr> merijn: I can't find IPV6_V6ONLY there
05:15:56 <dxtr> https://www.ietf.org/rfc/rfc3542.txt <- or is it just me?
05:19:04 <merijn> dxtr: Dunno, haven't looked
05:19:33 <ongy> case insensitive search on only doesn't show it
05:20:14 <oherrala> merijn: probably it's read-only instead of no-op just to catch these :)
05:20:38 <oherrala> https://tools.ietf.org/html/rfc3493#section-5.3
05:21:20 <oherrala> also this: http://www.uninet.edu/6fevu/text/afindependence.html
05:21:21 <ongy> seconds faster :(
05:23:36 <dxtr> Hmm, why didn't I find that? :P 
05:24:48 <sdx23> rfc3493 /= rfc3542
05:24:56 <dxtr> That is very true
05:25:09 <oherrala> indeed :)
05:25:50 <dxtr> Anyway, they removed that once upon a time because it led to so many issues
05:26:17 <dxtr> Besides, opening two sockets isn't that problematic
05:27:32 <kuribas> To pad in the Put monad, I need to write to a byteString, calculate the length, then create a new bytestring and add padding.  That seems pretty inefficient.
05:28:27 <merijn> kuribas: Why not track length as you write and insert padding at the end?
05:28:32 <dxtr> Actually, that setsockopt() might have worked in earlier versions of openbsd
05:28:49 <dxtr> EINVAL was added in May for IPV6_V6ONLY
05:28:52 <kuribas> merijn: I wrote the Put in a streaming way.
05:29:13 <merijn> kuribas: So? You know the length of stuff you Put, no?
05:30:01 <kuribas> hm, I guess I should...
05:30:49 <merijn> kuribas: "StateT Int PutM ()" "runStateT putThingy 0"
05:31:06 <merijn> check length at the return, insert padding based on length
05:32:55 <kuribas> Ok, I'll rewrite my stuff to PutM Int (Int being size of bytestring).
05:33:45 <merijn> That could also work
05:34:10 <lyxia> you can use the typeclass from the bytes package to expose the same interface for PutM and StateT Int PutM.
05:34:12 <dxtr> https://tools.ietf.org/html/draft-itojun-v6ops-v4mapped-harmful-02 :p
05:50:20 <paolino> hello I've never used TH, I have this code https://kobra.io/#/e/-KW7OwoZS5G3PPcf8fZI
05:50:59 <paolino> is it possible to use TH to write everything from the first 3 definitions ?
05:51:46 <paolino> everything following those
05:54:08 <lyxia> That looks possible.
05:56:04 <int-e> meh, just javascript.
05:56:12 <soLucien> if i have a list of [[Foo "a", Foo "b"]] and i want to turn it into a [["a","b"]]
05:56:25 <mlehmk> @pl \x -> -x
05:56:25 <lambdabot> (line 1, column 7):
05:56:25 <lambdabot> unexpected "-"
05:56:25 <lambdabot> expecting lambda abstraction or expression
05:56:29 <soLucien> what is the best approach to do it ?
05:56:37 <lyxia> (fmap . fmap) unFoo
05:56:40 <mlehmk> @pl \x -> (-x)
05:56:40 <lambdabot> negate
05:56:41 <dxtr> merijn: So if I were to (at least temporarily) fork that library and remove the offending setsockopt call - can I somehow tell stack to use that library instead then?
05:56:44 <mlehmk> >:<
05:56:46 <soLucien> so double mapping
05:56:57 <merijn> dxtr: Dunno, I don't know how to use stack :)
05:57:06 <dxtr> Alright!
05:57:19 <jle`> soLucien: what do you mean a list of [[Foo "a", Foo "b"]] ?
05:57:29 <soLucien> a list of lists
05:57:41 <jle`> like, [[[Foo "a", Foo "b"]], [[Foo "a", Foo "b"]]] ?
05:57:42 <soLucien> and i want each of the lists to be "un-fooed"
05:57:43 <jle`> ah
05:57:49 <jle`> so a list of [Foo "a", Foo "b"]'s?
05:58:09 <paolino> lyxia, thanks, I'm giving it for granted, even if I don't konw how much does it take
05:58:13 <lyxia> did you mean "a list [[Foo "a", Foo "b"]]"
05:58:13 <soLucien> i mean [Foo "a", Foo "b"], [Foo "a", Foo "b"]]
05:58:21 <soLucien> [[Foo "a", Foo "b"], [Foo "a", Foo "b"]]
05:58:21 <jle`> ah
05:58:36 <jle`> (map.map) unFoo works, if Foo is the only constructor
05:58:55 <sdx23> let unFooList = map unFoo in map unFooList
05:59:04 <mlehmk> is it true that one "fmap" to rule them all?
05:59:16 <mlehmk> map and liftM
05:59:16 <jle`> hm, what do you mean by that?
05:59:34 <jle`> i use map sometimes over fmap because it makes code more readable in a lot of cases
05:59:48 <jle`> and liftM has some use cases that fmap can't replace
05:59:58 <merijn> @let data Foo a = Foo a deriving (Show)
05:59:59 <lambdabot>  .L.hs:171:1: error:
05:59:59 <lambdabot>      Multiple declarations of ‘Foo’
05:59:59 <lambdabot>      Declared at: .L.hs:164:1
05:59:59 <jle`> by some use cases i mean one use case, heh
06:00:15 <mlehmk> data Foo = Foo a deriving (Show) I think
06:00:19 <merijn> > [x | Foo x <- [Foo 'a', Foo 'b']] -- easy
06:00:20 <mlehmk> ohh wait
06:00:22 <lambdabot>  error:
06:00:23 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Char’
06:00:23 <lambdabot>      • In the first argument of ‘Foo’, namely ‘'a'’
06:00:34 <merijn> wuut?
06:00:35 <merijn> oh
06:00:38 <merijn> @undefine
06:00:38 <lambdabot> Undefined.
06:00:42 <merijn> @let data Foo a = Foo a deriving (Show)
06:00:45 <lambdabot>  Defined.
06:00:48 <merijn> > [x | Foo x <- [Foo 'a', Foo 'b']] -- easy
06:00:51 <lambdabot>  "ab"
06:00:54 <jle`> merijn: it's over nested lists tho, and list comprehensions always collapse it to one lest
06:01:11 <jle`> you'd have to map (\xs -> [x | Foo x <- [Foo 'a', Foo 'b']])
06:01:16 <merijn> jle`: So, turn it into a function an map
06:01:24 <jle`> er, map (\xs -> [ x | Foo x <- xs ])
06:01:37 <jle`> yeah, it's not as clear cut what is cleaner in this case
06:02:24 <merijn> This one doesn't rely on being able to write a non-partial unFoo
06:02:42 <merijn> So I'd argue it's superior
06:02:51 <jle`> maybe if Foo is not the only constructor
06:03:33 <SteeveUk> Hello all :)
06:03:38 <jle`> hi!
06:04:42 <SteeveUk> bored @ work so I thought Id take a look around IRC
06:04:53 <SteeveUk> someone on Reddit suggested this channel for being helpful
06:05:30 <M2tias> SteeveUk: this is a very active channel
06:06:26 <SteeveUk> M2tias: That isn't a bad thing is it? :)
06:06:48 <M2tias> not at all, just hang around if you need help. I'm a noob but I'm sure others can help you
06:08:05 <SteeveUk> what languages are people adept in on here??
06:08:42 <ahihi> Haskell is the subject of this channel
06:09:33 <M2tias> ahihi: is that like "other languages are not allowed!"?
06:10:01 <dxtr> What? No Javascript!?
06:10:03 <srhb> M2tias: Yeah. :)
06:10:07 <ahihi> I'm no op, but I believe it would be considered off topic
06:10:11 <srhb> M2tias: At least if it doesn't relate to Haskell.
06:10:28 <srhb> (Agda and Idris, for instance, might be relevant. Elm, too, perhaps.)
06:10:39 <M2tias> if this channel doesn't like offtopic, it's the first for me. but I'm ok with it
06:10:51 <srhb> M2tias: People are pretty good at staying on topic. :-)
06:11:10 <M2tias> at least we won't fight about nonsense :)
06:14:32 <SteeveUk> well, i'm in the wrong channel then :)... oh well, take care guys!
06:15:43 <M2tias> SteeveUk: why's that?
06:16:04 <SteeveUk> M2tias: I am not using haskell :D :P
06:16:16 <M2tias> haha, ok then
06:16:21 <dxtr> Now's a good time to start!
06:16:29 <M2tias> yep!
06:16:52 <M2tias> SteeveUk: this is a great book to read. http://learnyouahaskell.com/
06:18:53 <SteeveUk> Hmmm, I don't think it'd be applicable for what I do
06:19:04 <SteeveUk> Unfortunately :(
06:19:08 <M2tias> hobbies!
06:19:17 <ertesx> this channel actually covers a number of non-haskell topics regularly, but they are all in some way related to haskell
06:19:33 <merijn> type theory, functional programming, category theory :)
06:19:44 <ertesx> and yes, we do talk about other languages from time to time, as long as, again, it's somehow related to haskell (comparisons, translations, etc.)
06:21:20 <SteeveUk> My life is too full for hobbies these days M2tias, i see ertesx & merijn... Sorry for wasting peoples time :(
06:21:37 <M2tias> SteeveUk: don't worry :D
06:21:45 <merijn> ertesx: Implemented in ;)
06:21:57 <ertesx> yeah =)
06:22:26 <SteeveUk> Thanks anyways and cheers for the info. If I ever get into haskell I'll be sure to visit :)! Laters y'all
06:22:27 <ertesx> to be honest i even ask my math questions here rather than in ##math most of the time, because i like the way haskellers think and answer them =)
06:22:36 <ertesx> (but it's rare)
06:22:47 * hackagebot snap-server 1.0.1.1 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.0.1.1 (DougBeardsley)
06:22:55 <SteeveUk> Haha, I'll keep that in mind too ;)
06:23:06 <ertesx> SteeveUk: don't…  it's a bad habit of mine ;)
06:23:10 <M2tias> what math?
06:23:38 <SteeveUk> ertesx: Don't know the command to delete with haskell but image i just did it to that bit of info you told me
06:23:44 <SteeveUk> imagine*
06:23:53 <ertesx> ;)
06:24:17 <ertesx> M2tias: linear algebra and group theory came up in the past (i don't count category theory)
06:24:28 <SteeveUk> Anyway byeeee all!
06:24:39 <M2tias> bye
06:26:13 <M2tias> I took one abstract algebra class in university. I've known that haskell is tightly related to math, but I didn't expect to see that much similarity when I got to monads and functors
06:26:28 <M2tias> or that I'd know some of it beforehand :D
06:26:54 <dxtr> I flunked high school math. Do I win? :p 
06:27:02 <M2tias> :D
06:27:21 <kadoban> M2tias: It's not really that related to math, IMO. It just borrowed more terms and ideas than some other languages did.
06:27:38 <M2tias> I was math major in university, but I realised that if I switch to CS, I get to be lazy
06:27:51 <merijn> I would say haskell is very related to math, just not at all to category theory :p
06:28:13 <merijn> But then I consider lambda calculus and type theory math :)
06:28:20 <younder> kadoban, I disagree. It is closely related to math. In fact I have it herad said it is math with a special notation.
06:28:36 <ertesx> that's a philosophical question…  if you are like me, then all programming is math, and then it makes sense to use the abstractions and module systems we know from math =)
06:28:52 <ertesx> to me haskell is 100% math
06:28:58 <dxtr> There are module systems in math?
06:29:17 <ertesx> dxtr: you could consider category theory a powerful kind of module system
06:29:42 <dxtr> If I go back to school some day I'm gonna start the pages in my math assignments with 'import Page X'
06:30:01 <ertesx> dxtr: start them with "for all X" instead
06:30:07 <M2tias> :D
06:30:41 <M2tias> let ɛ > 0
06:31:26 <younder> category theory binds objects to order preserving maps defining the behaviour. So it'a type system and not a module system
06:32:10 <Monoide> its just a vocabulary :o
06:32:36 <ertesx> at the same time it abstracts away details and allows you to transfer high-level results between categories, so it's a module system, too =)
06:36:20 <younder> ertesx, You mean type classes?
06:36:24 <M2tias> do you have jobs in the haskell industry? what kind of project would suffice as a portfolio?
06:38:12 <dxtr> There's a haskell industry?
06:38:20 <M2tias> :D
06:38:43 <ertesx> younder: no, i mean functors (not just Functor, but functors in general)
06:38:44 <M2tias> there are companies that use Haskell
06:42:03 <merijn> dxtr: Just this week Standard Chartered Bank was (again) recruiting people in Singapore, so yes.
06:42:35 <merijn> dxtr: Facebook, Barclays, Morgan-Stanley are others that I know use Haskell, but there are more I don't know about
06:43:43 <dxtr> But they are all in different industries
06:43:49 <M2tias> there are some lists. searching r/haskell helps
06:44:01 <M2tias> but seriously, what do you think is enough to show "I can haskell around"
06:44:26 <merijn> M2tias: Plenty of them are willing to hire intermediate haskellers
06:44:46 <kadoban> M2tias: What is enough is hard to answer, it's going to depend on the place of course. Write a few projects, give it a shot, etc.
06:44:49 <merijn> M2tias: You don't have to be, like, edwardk. But you shouldn't get stumped by basic things like transformers, etc. either
06:45:04 <merijn> M2tias: I think writing any non-trivial project should be a good start
06:45:07 <M2tias> I actually found one remote internship where it was fine if the intern learned haskell during the internship :D
06:45:09 <kadoban> Isn't there one of the more famous haskell places that has a public project they ask everyone to do as a first step? I forget which place it is.
06:45:22 <kadoban> M2tias: Wow, cool
06:45:39 <M2tias> it was posted in r/haskell
06:46:32 <M2tias> time to leave work!
06:49:05 <abe> In the following function:lengthFold = foldr (\_ x -> x + 1) 0 ; why do we need to use _ in the labmda function? 
06:49:28 <kuribas> abe: because you ignore the value of the list
06:49:46 <kuribas> length doesn't depend on the contents of the list.
06:50:27 <kadoban> abe: If you're not aware, _ is like putting y there, and then never using it. You use it for "I don't care what this argument is"
06:50:54 <ertesx> abe: note that you don't *need* to use it
06:50:58 <abe> juribas: so when I'm doing \ _ y -> y +1; doesn't that mean this function takes two parameters but returns second parameter + 1?
06:51:12 <ertesx> foldr (\y x -> x + 1) 0  -- same function
06:51:31 <kadoban> abe: Yes, exactly
06:52:05 <ab9rf> i actually prefer the pointfree form for that one: const (+1)
06:52:20 <mettekou_> Is there a recommended framework for benchmarking Haskell code?
06:52:27 <ertesx> mettekou_: criterion
06:53:04 <ab9rf> but i supopse that's becauase i've become used to seeing const in its role of "ignore my argument"
06:53:15 <ertesx> mettekou_: (or profiling, depending on whether you're optimising or chasing a strictness bug)
06:53:17 <abe> I did not write the lengthLambda function , so I'm trying to understand how it works.lengthFold = foldr (\_ x -> x + 1) 0  I'm really not getting how is it returning length?
06:53:58 <ertesx> abe: to understand that one you should first learn how foldr works
06:53:58 <mettekou_> ertesx: I was looking for something to play around with for later use in real projects through Cabal's benchmark field.
06:54:12 <ertesx> mettekou: yeah, then criterion
06:54:19 <ab9rf> i think hre the problem is understanding foldr, which isn't surprising bceause foldr is kinda tough
06:54:28 <mettekou> ertesx: Ok, thanks!
06:54:43 <rightfold> I'm pretty tough indeed!
06:55:03 <ertesx> abe: the easiest way to understand foldr is to write a bunch of functions yourself and see the pattern that foldr abstracts
06:55:22 <kadoban> ab9rf: It's saying: for every element of the list, ignore the value of the element and increment our accumulator by 1.
06:55:42 <kadoban> (and the 0 part is: "start at 0")
06:55:43 <ertesx> abe: write the length function by hand, then also write the 'concat' function, and perhaps the 'reverse' function
06:55:50 <ab9rf> kadoban: i know that :)
06:56:09 <ertesx> abe: then compare all those functions and try to see a pattern
07:01:16 <ertesx> foldr is one of those patterns that is so natural…  if you train yourself to see it, you will see it *everywhere* =)
07:02:49 <ertesx> :t foldr (\fp -> liftA2 (<>) (Data.Text.IO.readFile fp)) (pure mempty)
07:02:51 <lambdabot> Foldable t => t FilePath -> IO Data.Text.Internal.Text
07:09:55 <soLucien> i have a list of functions [a->b] and an a. how do i apply it to an a and get a list of results ?
07:10:01 <soLucien> i tried map but it's not working
07:10:43 <ab9rf> it's map you want, but not quite how you expected
07:11:15 <soLucien> it's map with a reversed function
07:11:22 <soLucien> or smth like that ?
07:11:52 <soLucien> map a to the list of [a->b] did not work either
07:12:52 <ab9rf> you can't map a to a list of unctions because a isn't a funciton
07:12:53 <ertesx> soLucien: map (\f -> …) fs
07:13:07 <ertesx> the mapping function receives a *function* as its argument
07:13:20 <ertesx> what do you want to do with each function again?
07:13:23 <ab9rf> you need to use a function (a -> (a->b) -> b)
07:13:30 <soLucien> apply all the functions in a list
07:13:32 <soLucien> to a single argument
07:13:42 <soLucien> and get back a list of results
07:13:47 <ertesx> soLucien: express it differently:  for every function f i want to compute …
07:14:11 <soLucien> okay i get what you are saying
07:16:59 <ertesx> map (\x -> x + 5)  -- "for every value x in the list i want to compute x + 5"
07:17:00 <soLucien> thanks ertesx
07:17:03 <delYsid> where do I find the code for lambdabot @pl?  I'd like to see how this is done.
07:17:49 * hackagebot code-page 0.1.1 - Windows code page library for Haskell  https://hackage.haskell.org/package/code-page-0.1.1 (ryanglscott)
07:21:29 <geppettodivacin> delYsid: https://github.com/lambdabot/lambdabot/blob/1d1ed3e7980081c9f356f8d2fd8ca2771c0ed4f4/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Pl.hs
07:23:17 <byorgey> delYsid: also there is a nice article explaining how it works in Issue 17 of the Monad.Reader: https://themonadreader.files.wordpress.com/2011/01/issue17.pdf (the third article)
07:26:50 <delYsid> thank you both.
07:27:36 <delYsid> PDF :( ...
07:29:55 <byorgey> delYsid: if you don't like PDFs, the literate Haskell source for that article is here: http://code.haskell.org/~byorgey/TMR/Issue17/Convert.lhs
07:30:39 <delYsid> ahh, nice, just darcs got the repo.
07:31:02 * delYsid is blind and always fails when it comes to PDF and Linux console
07:31:42 <shapr> I'm tempted to reboot TMR
07:31:49 <shapr> Looks like it's no longer active
07:32:00 <byorgey> delYsid: gotcha.  And actually, it looks like Convert.lhs is just some code, the source of the article is in mr_ae.lhs
07:34:01 <byorgey> shapr: in theory ezyang is still the editor, but I doubt he has much time for it.  I think the most recent issue was August of last year.
07:36:04 <lyxia> TMR?
07:36:18 <shapr> The Monad Reader!
07:36:22 <shapr> lyxia: have you heard of it?
07:36:48 <shapr> byorgey: does your Typeclassopedia still get referenced in current research papers?
07:37:07 <lyxia> Hmmm, doesn't ring a bell.
07:38:02 <shapr> lyxia: https://wiki.haskell.org/The_Monad.Reader
07:38:55 <lyxia> Oh. I'd be definitely interested if it ever lives again.
07:39:22 <shapr> lyxia: you saying you want to write an article?
07:39:41 <lyxia> Both read and write yeah.
07:39:57 <shapr> hrm
07:40:38 <byorgey> shapr: in research papers, I'm not sure.
07:42:03 <byorgey> shapr: huh, according to Google scholar it does.
07:42:07 <shapr> byorgey: scholar.google.com says you got a reference in 2015, but Giving Haskell a Promotion has the most
07:42:21 <shapr> 299 references! Did that get you tenure?
07:42:40 <byorgey> If it did, no one told me about it!
07:42:44 <byorgey> (I don't have tenure yet =)
07:43:02 <kadoban> Haha. It should have, you're awesome.
07:43:41 <byorgey> thanks kadoban =)
07:55:45 <soLucien> i want to turn (1,2) into (1,2,3) . Is this possible ?
07:55:49 <soLucien> (,) <$> (1,2) 3
07:55:52 <soLucien> that is what i tried
07:56:08 <soLucien> and other variations of it
07:56:22 <opqdonut> 3-tuples are completely separate from 2-tuples
07:56:35 <opqdonut> you need to do something like "let (a,b) = (1,2) in (a,b,3)"
07:57:11 <opqdonut> oh, there's this nifty hack:
07:57:16 <soLucien> or map a lambda
07:57:21 <soLucien> that does that
07:57:24 <opqdonut> > uncurry (,,) (1,2) 3
07:57:27 <opqdonut> well yeah
07:57:27 <lambdabot>  (1,2,3)
07:58:07 <opqdonut> (,,) is the constructor for three tuples: (,,) 1 2 3 ==> (1,2,3)
07:58:15 <soLucien> i see
07:58:19 <soLucien> thanks !
08:08:42 <gry_> Hello, friends.
08:09:51 <ongy> hello gry_ 
08:10:37 <slack1256> delay :: Shape sh => Source r e => Array r sh e -> Array D sh e
08:10:50 <jle`> soLucien: (<$>) for tuples maps a function to the second item in a tuple
08:10:50 <slack1256> I never knew we would curry type-class instances
08:11:06 <jle`> (<$>) :: (a -> b) -> (c, a) -> (c, b)    -- soLucien 
08:11:24 <jle`> slack1256: it's actually constraints
08:11:33 <slack1256> that!
08:11:39 <jle`> and, it makes sense if you think of it in the general (constraints => type) thing
08:11:57 <glguy> slack1256: GHC accepts it, but it's not valid "Haskell"
08:12:06 <jle`> if you imagine that types can contain constraints
08:12:08 <slack1256> yeah, but I had't seen in the wild
08:12:08 <soLucien> okay this is a hard one (for me) . I used to have this [a] and [b] . In order to transform it to a tuple of all possible combinations, i used (,) <$> as <*> bs
08:12:29 <jle`> so `Foo a => [a]` is a valid type
08:12:29 <soLucien> and i got [(a,b)]
08:12:40 <jle`> and so then so is `Bar a => (Foo a => [a])`
08:12:55 <jle`> it's just the type (Foo a => [a]) constrained by 'Bar a' :)
08:13:12 <soLucien> now i have [(a,b)] and [c] and i want to turn it into [(a,b,c)]
08:13:14 <jle`> i tried it out for a bit because it made alignment easier
08:13:25 <jle`> but i stopped because it wasn't very idiomatic
08:13:26 <gry_> How do you pronounce <*> and <$>?
08:13:31 <jle`> gry_: ap, map
08:13:35 <jle`> or ap, fmap
08:13:38 <soLucien> apply and map
08:14:04 <gry_> Oh, <$> is map. Thanks :)
08:14:10 <jle`> soLucien: (\(x,y) z -> (x,y,z)) <$> xs <*> ys
08:14:22 <jle`> er, xsys, zs
08:15:02 <gry_> Any reason for the crazy operators? Are they supposed to resemble some symbol? Or is it random?
08:15:39 <sm> well, <$> is like $ (function application)
08:15:41 <srhb> gry_: <$> is like lifted application
08:15:44 <soLucien> that was easier than i expected, thanks jle
08:15:51 <jle`> no problem!
08:15:54 <jle`> things in haskell usually are
08:16:02 <jle`> :)
08:16:13 <sm> and <*>... was available ? dunno
08:16:19 <gry_> Ha!
08:16:23 * sm waits for enlightenment
08:17:12 <srhb> sm: It's, like, multiplication, because you can... lift with multiple arguments! >_>
08:17:31 <gry_> If I squint really hard I can see it!
08:18:59 <srhb> gry_: But really, foo <$> bar <*> baz <*> quux <*> is often nicer than liftAN foo ... for some N
08:19:26 <mmaruseacph2> the way I see it is from the List instance of Applicative where <*> takes the role of Cartesian Product
08:19:35 <gry_> I'm still very much a beginner. So everything looks crazy to me, heh
08:19:40 <mmaruseacph2> and then you generalize over the other Applicatives
08:19:45 <srhb> gry_: That's fair, it will for a while, probably. :-)
08:19:59 <gry_> It's very satisfying when it finally clicks though
08:21:46 <srhb> gry_: Definitely!
08:22:52 * hackagebot gitit 0.12.2 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.12.2 (JohnMacFarlane)
08:23:16 <jle`> yeah, to most haskellers, when they encounter 'f <$> x <*> y <*> z', they just see 'f x y z'
08:23:38 <jle`> that's sort of what the idiom is supposed to represent
08:23:45 * srhb wishes for idiom brackets
08:23:57 <jle`> <$>/<*> is kinda basically line noise in this context though so that kind of sucks
08:28:11 <gry_> Ok, so this might be a stupid question. There are all these ways to "lift" functions. Is there something like an "unlift" as well? Like say I have a function `f a -> f b`. Is there a (built-in) way to turn this into `a -> f b`? I don't even know if that makes any sense
08:28:32 <gry_> I mean I guess I could always to pure/return/whatever on the `a` and then pass that to the function
08:28:34 <jle`> what do you mean by "built-in"?
08:28:38 <jle`> there is little built into haskell
08:29:02 <srhb> gry_: Yes, that's the correct way.
08:29:04 <gry_> Built-in as in an already existing function that does exactly that
08:29:05 <jle`> do you mean available in normal libraries?
08:29:09 <gry_> Yes
08:29:26 <gry_> It probably doesn't make sense to try and transform the function when I can just transform the value I guess
08:30:17 <srhb> gry_: usually lifting (a -> b) turns it into (f a -> f b)
08:30:29 <jle`> :t \f x -> f (pure x)
08:30:31 <lambdabot> Applicative f => (f a -> t) -> a -> t
08:31:06 <jle`> :t (. pure)
08:31:08 <lambdabot> Applicative f => (f a -> c) -> a -> c
08:31:17 <jle`> hm
08:31:19 <jle`> :t lmap pure
08:31:21 <lambdabot> (Profunctor p, Applicative f) => p (f a) c -> p a c
08:31:28 <gry_> Profunctor...?
08:31:37 <jle`> ah i mean to use the (->) instance there
08:31:44 <jle`> so that'd be (f a -> c) -> (a -> c)
08:32:03 <jle`> > lmap pure (take 3) 1
08:32:05 <lambdabot>  [1]
08:32:13 <gry_> Great, now I gotta look up what a profunctor is
08:32:18 <jle`> (lmap g f) "precomposes" 'g' onto f 
08:32:20 <jle`> nah
08:32:21 <gry_> Next rabbit hole, here I come!
08:32:29 <kadoban> gry_: The other examples are fine without profunctor really, with pure before that.
08:32:36 <mmaruseacph2> w/win 12
08:32:42 <mmaruseacph2> bad window, sorry
08:32:46 <gry_> I know, but now I saw the word and I'm curios!
08:32:55 <jle`> yeah, my example doesn't really involve "profunctors"
08:33:01 <jle`> just a utility function for (->)
08:33:17 <jle`> lmap :: (a -> b) -> (b -> c) -> (a -> c)
08:33:27 <jle`> lmap g f = f . g
08:33:36 <jle`> rmap g f = g . f
08:33:43 <jle`> dimap g h f = h . f . g
08:33:48 <jle`> just convenient composition functions :)
08:33:49 <gry_> Wait, how is lmap different from . ?
08:33:55 <jle`> it's flip (.)
08:33:55 <gry_> :t (.)
08:33:56 <kadoban> It's flipped
08:33:57 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:34:03 <gry_> Oooh
08:34:31 <jle`> lmap is pre-compose and rmap is post-compose
08:35:06 <gry_> :t rmap
08:35:07 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
08:35:17 <gry_> Well...
08:36:13 <gry_> Man, how many types of funtors are there :o
08:36:17 <gry_> functors*
08:36:25 <jle`> yeah, to read those type signatures, just put in the instance you want, heh
08:36:35 <jle`> we're talking about the (->) instance, so put in (->) wherever you see 'p'
08:36:41 <srhb> gry_: You can string adjectives together and get a new one :-P
08:36:44 <jle`> rmap :: (b -> c) -> (a -> b) -> (a -> c)
08:36:57 <gry_> srhb: Haha
08:36:57 <jle`> incidentally rmap == fmap == (.)
08:37:39 <gry_> Whats another example of a profunctor? 
08:37:57 <gry_> What else can I put into rmap?
08:38:06 <gry_> Because (->) is the only that makes sense to me
08:38:13 <gry_> only one*
08:38:37 <jle`> any of the Arrow instances in base
08:38:47 <jle`> honestly for the most part you only really ever work with (->)
08:38:57 <jle`> oh, one of my favorite instances is for Fold from the foldl library
08:39:18 <jle`> a 'Fold a b' is a folding function that takes a list of a's and folds them down into a b
08:39:33 <jle`> lmap :: (a -> b) -> Fold a c -> Fold b c
08:39:47 <jle`> it basically turns a fold on a list of a's into a fold on a list of b's
08:39:55 <jle`> by mapping the (a -> b) on the list before doing the folding
08:40:09 <gry_> Hm.. that's pretty cool
08:40:19 <jle`> and rmap :: (a -> b) -> Fold c a -> Fold c b
08:40:26 <jle`> it turns a fold producing an 'a' into a fold producing a 'b'
08:40:35 <jle`> and it does that just by applying the (a -> b) on the result of the fold before giving it to you
08:41:32 <jle`> actually Fold is probably the profunctor instance that i usually am using if i use lmap/rmap
08:41:45 <jle`> becuase you can get lmap/rmap for functions by using (.) already, heh
08:44:24 <gry_> lmap :: (a -> b) -> Fold a c -> Fold b c
08:44:37 <gry_> Are these types actually correct? Because I can't seem to figure out a way to make that work
08:45:52 <hexagoxel> the `derive` package docs say "There are two methods for writing a new derivation, guessing or coding". What does `guessing` refer to?
08:45:54 <glguy> No, that's not right
08:46:02 <glguy> lmap :: Profunctor p => (a -> b) -> p b c -> p a c
08:46:22 <glguy> so lmap :: (a -> b) -> Fold b c -> Fold a c
08:46:43 <jle`> gry_: yeah, sorry, i flipped the :|
08:46:45 <jle`> *them
08:47:22 <gry_> Hm, that doesn't help me. I still don't see how line up these types. At what point does (a -> b) applied?
08:47:23 <gry_> And to what?
08:47:35 <jle`> gry_: a 'Fold a b' folds a list of a's into a b
08:47:45 <gry_> Right.
08:47:48 <jle`> and a 'Fold c b' folds a list of c's into a b
08:47:55 <jle`> so how can you make a 'Fold c b', given a 'Fold a b'?
08:48:06 <jle`> you can just map the list of a's with an (a -> c), and feed it to the 'Fold c b'
08:48:47 <glguy> gry_: There's a recent post that is relevant to this topic you might be interested in https://www.fpcomplete.com/blog/2016/11/covariance-contravariance
08:48:54 <jle`> or well, you can have the 'Fold c b' map its input list with the (a -> c) before it processes things
08:48:56 <gry_> 'Fold b c' instead of 'Fold c b', right?
08:49:58 <gry_> Oooh, I got it now
08:50:27 <gry_> I completely derped. I forgot that 'p a c' is the result and not just another argument
08:50:39 <gry_> Whoops
08:51:55 <gry_> I thought lmap took 3 arguments, (a -> b), 'p b c' and 'p a c'. And I just thought there's no way to make these three types work with each other
08:52:08 <gry_> Anyways, thanks for the explanations :)
08:58:14 <gry_> glguy: Thanks for the link
08:58:22 <pka> is there a way to specify package flags when building ghcjs from source with stack?
08:58:45 <pka> cryptonite-0.19 fails with 'no such instruction: `rdrand %rcx''
08:59:06 <pka> normally this is solved by specifying support_rdrand: false in stack.yaml
08:59:24 <pka> but the flag is seemingly ignored when building ghcjs
08:59:31 <glguy> pka: Yes, package flags can be set in the stack.yaml
09:00:05 <glguy> "Flags will only affect packages in your packages and extra-deps settings. Packages that come from the snapshot global database are not affected." might be relevant
09:00:34 <pka> glguy: yeah, cryptonite is in extra-deps
09:01:11 <pka> i guess this is because the compiler build stage (i.e. stack setup) ignores the flag settings...
09:01:14 <pka> im not sure
09:06:30 <ksajalk1> can I ask haskell questions here?
09:07:46 <ertesx> ksajalk1: yeah
09:07:53 <glguy> ksajalk1: Yeah, that's basically all you can do here
09:22:28 <NemesisD> is there a category theory term for a one way mapping where no two inputs can produce the same output?
09:22:51 <Oflor> NemesisD: injective?
09:23:32 <NemesisD> Oflor: thanks!
09:28:03 <ertes> NemesisD: monomorphism
09:28:23 <gry_> Injective is from set theory, not category theory if I'm not mistaken
09:28:34 <ertes> NemesisD: but it's more general than injectivity
09:29:56 <NemesisD> i've basically got a function a -> b and i'm figuring out how to name the quickcheck property that no two distinct a should produce the same b
09:30:14 <ertes> NemesisD: "injective"
09:30:42 <ertes> you could name it "monic", but "injective" is more specific
09:31:37 <NemesisD> actually i guess this isn't true. b is basically the constructor tags for a. so if data A = Foo Int | Bar String, data B = Foo' | Bar', aToB (Foo 1) == aToB (Foo 2) == Foo'
09:31:48 <NemesisD> so maybe this isn't even anything
09:32:15 <ertes> yeah, that's not injective
09:32:47 <ertes> NemesisD: but you could view B as a form of quotient type…  you're mapping representants to equivalence classes
09:33:23 <NemesisD> i don't think i can write this quickcheck test other than one that asserts that the function is total
09:33:58 <ertes> is this test even worth it?  it doesn't look like a function that's easy to get wrong
09:34:15 <NemesisD> yeah its basically fool proof with -Wall -Werror
09:34:39 <ertes> NemesisD: i used the following idiom in the past:
09:35:26 <ertes> data A f = A1 (f Int) | A2 (f Double) | …
09:35:49 <ertes> (A Identity) is your A, while (A Unit) is your B
09:36:05 <ertes> where you can take Unit = Const () or define it yourself
09:36:33 <ertes> tags :: A f -> A Unit
09:36:42 <NemesisD> ertes: ah thats clever. so you avoid manually mapping anything since its one set of constructors
09:37:26 <NemesisD> another thing I need from this is the ability to get all the possible constructors for [B] which I guess i can do with generic
09:41:05 <ertes> NemesisD: you can still get it wrong, but you don't need two types anymore
09:41:38 <ertes> you can do generic, or you can try deriving Enum for (A Unit)
09:41:59 <ertes> perhaps it works with standalone deriving…  if not, you can use generics
09:42:59 <NemesisD> yeah, the fact that f is kind * -> * seems to screw up a lot of derived typeclasses
09:43:47 <NemesisD> e.g. show, eq
09:50:49 <zyhn> anyone know if it's possible to get stack or cabal to compile/link cuda sources along with my haskell code?
09:51:34 <ertes> zyhn: nix could do that, and i think you can use stack with nix for things like that
09:52:10 <zyhn> I'll check that out. thanks
10:13:08 <PhsShft> http://lpaste.net/334414 can someone explain to me why these are two equivalent implementation of instance Monad State s, and how to get the second one from the first one? 
10:15:21 <lyxia> PhsShft: for  return = pure  you'll need to look at the Applicative instance
10:24:43 <kadoban> PhsShft: Any specific part(s)? It's mostly just differing ways that the runStates are used and the results given names. I guess we could do like a mechanical rewording of each until they're the same, is that what you're looking for?
10:25:23 <PhsShft> Yea I got it now, im just thinking about how (,) a is the same as \s -> (a,s)
10:25:50 <mettekou> PhsShft: That's just eta reduction.
10:26:15 <kadoban> Ah
10:26:33 <PhsShft> Yea eta reduction is magical… I haven’t learned much about eta-reduction in labmda expression
10:26:39 <mettekou> I think the Haskell Report states that operator sections are equivalent to their eta expanded form, but GHC doesn't guarantee this in the face of bottoms.
10:27:12 <Tuplanolla> > (, 2,) 1 3
10:27:15 <lambdabot>  (1,2,3)
10:27:35 <kadoban> PhsShft: It can certainly be a bit confusing at first, but you catch on with time very well typically.
10:28:18 <PhsShft> > (,2) 3
10:28:20 <lambdabot>  (3,2)
10:29:03 <mettekou> > let f = (, undefined) in fst $ f 10
10:29:05 <lambdabot>  10
10:29:28 <mettekou> > let f = \x -> (x, undefined) in fst $ f 10
10:29:31 <lambdabot>  10
10:29:35 <mettekou> Hmmm...
10:31:11 <mettekou> > (, undefined)
10:31:14 <lambdabot>  error:
10:31:14 <lambdabot>      • No instance for (Typeable t0)
10:31:14 <lambdabot>          arising from a use of ‘show_M858032724151266979721540’
10:31:34 <mettekou> > \x -> (x, undefined)
10:31:36 <lambdabot>  error:
10:31:36 <lambdabot>      • No instance for (Typeable t0)
10:31:36 <lambdabot>          arising from a use of ‘show_M847039433784044493621569’
10:31:41 <mettekou> Guess I was wrong.
10:31:45 <Tuplanolla> What are you trying to do, mettekou?
10:33:10 <mettekou> Tuplanolla: I thought GHC didn't treat operator sections as equivalent to their eta-expanded form, as per the Haskell 2010 Report. Guess I was wrong though.
10:33:23 <mettekou> With respect to bottom values, I mean
10:33:55 <geekosaur> mettekou, it used to treat them differently, that was changed
10:34:16 <mettekou> geekosaur: Hallelujah, I'm not going insane!
10:34:20 <Tuplanolla> We had this discussion a few days ago.
10:51:14 <pavonia> If you have a pattern in a State like "foo = do ...; case x of { y -> return []; z -> (z :) <$> foo", is this something the compiler can optimize like tail-recursion?
10:55:41 <zyhn> not sure about ghc, but that looks a lot like cps used in scheme
10:57:48 <Tuplanolla> No, because `(z :)` is in tail position instead of `foo`, pavonia.
10:59:44 <pavonia> So that means the final list will not be created lazily?
11:00:13 <Tuplanolla> That's unrelated.
11:02:52 <ertes> pavonia: if you use a lazy state monad, it will work
11:03:22 <pavonia> Okay, that's good
11:04:19 <ertes> > Control.Monad.State.Lazy.evalState (let go = liftA2 (:) (state (randomR (0, 9 :: Int))) go in go) (mkStdGen 0)
11:04:21 <lambdabot>  error:
11:04:22 <lambdabot>      Not in scope: ‘Control.Monad.State.Lazy.evalState’
11:04:22 <lambdabot>      Perhaps you meant one of these:
11:04:30 <ertes> > Control.Monad.State.evalState (let go = liftA2 (:) (state (randomR (0, 9 :: Int))) go in go) (mkStdGen 0)
11:04:33 <lambdabot>  [3,3,3,8,0,7,1,1,1,6,3,0,2,0,4,5,0,1,5,2,2,6,0,5,6,9,0,9,1,0,7,2,3,4,0,0,0,8...
11:04:37 <ertes> > Control.Monad.State.Strict.evalState (let go = liftA2 (:) (state (randomR (0, 9 :: Int))) go in go) (mkStdGen 0)
11:04:40 <lambdabot>  error:
11:04:40 <lambdabot>      Not in scope: ‘Control.Monad.State.Strict.evalState’
11:04:40 <lambdabot>      Perhaps you meant one of these:
11:05:17 <ertes> @let import qualified Control.Monad.State.Strict
11:05:19 <lambdabot>  Defined.
11:05:21 <ertes> > Control.Monad.State.Strict.evalState (let go = liftA2 (:) (state (randomR (0, 9 :: Int))) go in go) (mkStdGen 0)
11:05:24 <lambdabot>  *Exception: stack overflow
11:05:36 <ertes> pavonia: ^
11:06:10 <pavonia> Excellent, thanks
11:06:14 <ertes> pavonia: it's surprising at first that this is actually about how StateT handles its *tuples*, not the state
11:13:52 <infandum> How can I profile a program without...uh...enabling profiling?
11:14:19 <infandum> haskellr breaks down with profiling enabled, so is there an alternative way?
11:14:27 <Tuplanolla> Use `/usr/bin/time`?
11:14:44 <infandum> Tuplanolla: For individual functions though
11:14:53 <infandum> I don't know what the limiting function is
11:15:56 <Tuplanolla> Can you open it in a debugger, interrupt it at random times and make sampling profiler noises?
11:16:08 <Tuplanolla> It's almost as good as the real thing.
11:16:46 <infandum> interesting
11:16:54 <infandum> What debugger?
11:17:02 <infandum> I am able to run it in ghci
11:17:24 <infandum> and I know the general idea where the issue is
11:17:28 <infandum> just not enough
11:18:24 <Tuplanolla> For example GDB. The names will be a bit mangled, but you might be able to figure it out anyway.
11:19:31 <cocreature> infandum: you can generate dwarf debug info by passing -g to ghc and then use perf to prefile but it’s quite rough and hard to understand
11:20:53 <sm> you can emit trace output and timestamps at key points in your code to get some ideas
11:41:29 <tnks> so the Haddocks for MonadError doesn't seem to have laws written out.  But the Purescript docs do have three laws ("left zero", "catch", "pure").  Are these laws considered essential?  Or just conventions?
11:42:14 <tnks> personally, I want them to be essential, and have Haskellers avoid creating instances that violate these laws.
11:42:27 <tnks> but if they don't have a history of doing so, I'd like to know where the breaks are.
12:10:07 <ania123> type Pair a = (a,a)
12:10:25 <ania123> can one explain me, what this type means?
12:11:16 <verement> it means that Pair a is a synonym for (a, a)
12:20:34 <ania123> type Pair a = (a,a)
12:20:45 <ania123> verement: what Pair means here?
12:21:30 <geekosaur> what was wrong with the previous answer that you need to ask them again?
12:21:48 <ania123> it is not clear for me
12:21:55 <ania123> is Pair variable?
12:22:09 <geekosaur> ?
12:22:21 <geekosaur> if you use a type Pair Int then you are using a type (Int,Int)
12:22:30 <geekosaur> there is no difference between them whatsoever
12:23:24 <lgstate> is there any plans of merging ghcjs into ghc, or will it forever remain a 2nd class citizen?
12:23:54 <geekosaur> that's completely up to luite
12:24:16 <lgstate> geekosaur: not the ghc committee ?
12:24:55 <geekosaur> it will be up to them if luite ever submits ghcjs to them
12:25:20 <geekosaur> (although I am not sure I'd call what ghc has a committee; that implies more organization :)
12:27:26 <tdammers> ania123: type Foo = Bar -- means "whatever type is currently known as "Bar" shall also be known as "Foo""
12:27:50 <ania123> ok, thx
12:28:26 <geekosaur> I mean, conceivably the ghc folks could adopt ghcjs without luite's involvement, because it's open source. but I doubt they want to take on the maintenance of it, and I doubt luite would have much incentive to do so in such case
12:29:36 <geekosaur> (presumably having to then support his development branch and a lagged ghc-included branch)
12:30:06 <lgstate> sounds like "not too optimistic" :-(
12:30:31 <lgstate> this is one of the situations where a commercially backaed language with a poointy hair boss could say "merge" and engineers would make it happen
12:30:31 <Tuplanolla> Whenever you have a statement split by `=` or `<-`, you're defining the left side according to the right side, ania123.
12:31:12 <ania123> ok. clear
12:31:50 <geekosaur> it's more that I have no clue what luite's plans are
12:32:11 <geekosaur> presumably if luite were to choose the merge, development would become part of ghc development instead of leading to split releases
12:33:40 <geekosaur> for all I know, luite will submit it upstream as soon as 8.0.2 hits the wires. or might choose to wait for 8.2, or 9.0. I don't know their plans
12:33:44 <tdammers> the obvious solution is for microsoft research to hire luite
12:38:26 <ania123> data Answer = Yes | No | Unknown
12:38:43 <ania123> answers :: [Answer] 
12:38:45 <ania123> answers = [Yes,No,Unknown]
12:38:58 <ania123> so,
12:40:11 <ania123> answers :: [Answer] means answer data is list type
12:40:27 <ania123> what does answers = [Yes,No,Unknown] means?
12:40:41 <geekosaur> o.O
12:40:46 <ania123> why is answer restrected to be equal to that list?
12:40:49 <geekosaur> that's the value
12:41:28 <ania123> answers = [Yes,No,Yes,Unknown]
12:41:32 <ania123> is it value also?
12:41:37 <geekosaur> yes
12:41:54 <ania123> answers = [Yes,No,Yes,No,Unknown]
12:41:56 <ania123> this
12:41:58 <ania123> ?
12:42:10 <geekosaur> and it's a list, so you can put anything in it that is a valid value of type Answer --- which you specified in the data declaration as any of Yes, No, Unknown
12:42:35 <ania123> clear
12:42:44 <Tuplanolla> Like `answers = Yes : answers`.
12:43:25 <geekosaur> it's not just the definition of Answer that is relevant here but also the definition of lists: data List a = [] | (a : List a) -- the parens are not needed but I included them for clarity
12:44:06 <geekosaur> (note you can't actually write that, and the actual wired-in definition would, if you could write it, be: data [] a = [] | (a : [] a))
12:44:25 <geekosaur> and [a] is at both type level and value level a shorthand for [] a
12:45:40 <geekosaur> well, nt exactly. type level yes, value level is more interesting because the native representation is a : []
12:48:21 <geekosaur> there are some interesting edge cases between [a,b,c] syntax and constructors
12:48:40 <mathk> Let say that I have a data define as : 
12:48:40 <mathk> data Nucleotide = A | C | G | T | U
12:48:40 <mathk> And I now want to define Dna as a list of  A C G or T excluding U
12:48:40 <mathk> Will Rna as a list of A C G U excluding T
12:48:40 <mathk> Can I define my new type Dna/Rna with such constrain ?
12:49:43 <geekosaur> not directly; Haskell doesn't have subset types. this can be simulated to some extent with smart constructors (basically don't export the real constructor, but a function that will throw if it sees the wrong value)
12:50:10 <geekosaur> there's also some type level hackery that could be used but your types would end up looking rather different
12:51:17 <mathk> would it be better to define 2 data RnaNucleotide/DnaNucleotide
12:51:46 <geekosaur> probably not, since you'd have to deal with the overlap all the time
12:53:20 <geekosaur> another way would start out looking something like: data A; data C; data G; data T; data U; class DNATide; class RNATide; instance DNATide A; RNATide A; ...; instance DNATide T; instance RNATide U;
12:53:30 <geekosaur> but that turns out to have its own shortcomings
12:53:55 <geekosaur> basically there are a lot of hacky semi-solutions
12:54:21 <Tuplanolla> I'd probably go with a `ByteString` and some `PatternSynonyms`.
12:55:22 <Tuplanolla> I expect there to be more than a handful of those nucleotides.
12:55:40 <geekosaur> nature disagrees with you :)
12:55:42 <mathk> geekosaur, anyway I am already hidding A,C,G,T,U constructor so I guess I am safe.
12:56:23 <Tuplanolla> I mean long strands.
12:56:34 <joe9_> is there a quick way to get the first and last key of a HashMap.Strict? I do ( fst . head . HashMap.toList) -- just want to check if there is a better way
12:56:56 <mathk> Tuplanolla,  can you expand a bit more on your solution ?
12:57:05 <geekosaur> joe9, the essential nature of a HashMap is that it isn't ordered
12:57:37 <geekosaur> any ordering would be either introduced by toList, or not guaranteed to be stable
12:57:50 <joe9_> geekosaur: ok, Thanks.
12:57:50 <Tuplanolla> You'd secretly represent them as small integers, because that gives you instances for `Unbox` and the like for free, mathk.
12:59:23 <Tuplanolla> Then `PatternSynonyms` would allow you to name the integers for pattern matching and stuff.
12:59:40 <Tuplanolla> Some foreign interfaces use this trick.
13:03:25 <adarqui> so, was my decision to upgrade osx to sierra a bad idea? can't build any of my haskell projects using 7.10.3
13:05:14 <geekosaur> adarqui, pretty much, yes. working around the linker change is what's holding up 8.0.2
13:05:56 <adarqui> :/
13:09:54 <joe9_> What is wrong with this? http://codepad.org/fdIT7NKK , error message:         Qualified name in binding position: HashMap.empty
13:10:12 <joe9_> other than having to write a case statement. Is there a better way of doing that?
13:10:35 <Tuplanolla> It's because `empty` is not a constructor, joe9_.
13:11:27 <Tuplanolla> You can't define `empty = []` and then use `empty` in a pattern either.
13:11:35 <joe9_> Tuplanolla: oh, ok. Thanks. so, would need a guard to do this?
13:11:44 <byorgey> joe9_: you can instead write   latestAsOf dataSeries | null dataSeries = ...
13:11:47 <byorgey> yes
13:11:47 <Tuplanolla> However with the `PatternSynonyms` I just mentioned in passing...
13:11:50 <adarqui> lots of my small dependencies/libraries are actually compiling.. it's just the most important one that isn't.. my yesod app
13:12:02 <joe9_> byorgey: ok, Thanks.
13:16:09 <nshepperd1> mathk: crazy gadt solution: data NucleotideType = Dna | Rna; data Nucleotide (t :: NucleotideType) where { A :: Nucleotide t, T :: Nucleotide Dna, U :: Nucleotide Rna, ...}
13:16:52 <nshepperd1> It's not really subset types, does let you write [Nucleotide Rna]
13:18:03 * hackagebot simple-effects 0.6.0.0 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.6.0.0 (darwin226)
13:18:10 <nshepperd1> *but does*
13:26:37 <mathk> crazy
13:27:48 <joe9_> to get a minimum value of a hashMap. I am doing: minimum . HashMap.elems. I guess that is the only way. Is it?
13:28:04 <nshepperd1> In this system a list [U, T] is ill typed, also
13:28:21 <nshepperd1> This may be a feature or a bug i guess
13:28:47 <lyxia> :t minimum
13:28:49 <lambdabot> (Foldable t, Ord a) => t a -> a
13:28:58 <geekosaur> joe9_, yes
13:29:09 <lyxia> Is HashMap Foldable?
13:29:35 <lyxia> Looks like it is.
13:29:47 <geekosaur> maybe you can find or modify a priority queue to be backed by a HashMap, but I suspect that would not perform well --- again, HashMap is not ordered, so minimum will be expensive
13:30:07 <geekosaur> if you really need ordering, perhaps using HashMap was not the best choice
13:30:28 <Tuplanolla> :t minView
13:30:29 <lambdabot> error:
13:30:30 <lambdabot>     • Variable not in scope: minView
13:30:30 <lambdabot>     • Perhaps you meant one of these:
13:30:50 <Tuplanolla> I was hoping to see "these".
13:31:05 <joe9_> geekosaur: let me see if performance becomes an issue. Thansk.
13:31:36 <joe9_> How would Data.Foldable.minimum work with an empty HashMap? error?
13:31:56 <geekosaur> it does sound to me like you wanted a psqueue instead of a hashmap
13:32:13 <glguy> joe9_: You wouldn't want to use it with one
13:32:22 <joe9_> geekosaur: ok, will check on psQueue.
13:33:12 <geekosaur> it's hard to be certain just from what you have asked so far though
13:35:20 <joe9_> geekosaur: this is my data structure. https://github.com/joe9/haskell-opengl-charting/blob/master/src/PriceData.hs#L33
13:35:51 <geekosaur> it's not the data structure either, necessarily; it's how you use it that would determine what would work better
13:35:54 <joe9_> geekosaur: this is how I am using it: https://github.com/joe9/haskell-opengl-charting/blob/master/src/Drawable/PriceAreaGraph.hs#L45
13:36:19 <joe9_> For every new item, I would have to find the minimum x and y values
13:36:33 <joe9_> as I need the minimum and maximum values to arrive at the scale.
13:36:54 <joe9_> I could store the minimum and maximum values if it gets to be too slow.
13:37:19 <geekosaur> that might well work better for this
13:37:41 <joe9_> geekosaur:  https://github.com/joe9/haskell-opengl-charting/blob/master/src/Drawable/PriceAreaGraph.hs#L45 is where I am calculating the minimum and maximum values.
13:38:02 <geekosaur> pqueue/psqueue is more for when you are pulling off the queue by minimum (or maximum) value, not for referencing those values without changing the structure so much
13:38:50 <geekosaur> although, you might toList once and then put it into a Seq at the start of generating the graph, and work from that
13:39:17 <joe9_> or, I could have a wrapper over the HashMap AsOf PriceData  to store these minimum and maximum values
13:41:07 <davean> joe9_: why are you using a HashMap in the first place?
13:41:38 <joe9_> davean: I want to be able to quickly insert/replace using AsOf (time in microseconds)
13:42:01 <joe9_> davean: I had it as a vector unboxed. but, realized that it is a pita to find or update duplicates.
13:42:14 <joe9_> davean: with hashmap, I get that for free.
13:42:54 <kadoban> joe9_: Use an ordered map that lets you test minimum/maximum quickly? Would IntMap work?
13:42:57 <davean> joe9_: why not an actual map?
13:43:04 * hackagebot regex-do 1.9 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.9 (procione)
13:43:04 <davean> joe9_: or a priority queue
13:43:09 <davean> er, prioity search queue
13:43:19 <davean> or any other structure that actually represents the structure on the data you are using
13:44:34 * geekosaur already mentioned psqueues :)
13:44:36 <joe9_> davean: kadoban, I can use Map instead of a HashMap.
13:45:05 <davean> THat would be good. A priority search queue might be even more up your ally, depending on your usage pattern
13:45:12 <dmwit_> http://hackage.haskell.org/package/bimap-0.3.2/docs/Data-Bimap.html#g:5
13:45:43 <dmwit> Efficient `Map`-like access, efficient `min` and `max` on values. Can even delete the `min` or `max` value efficiently.
13:45:47 <dmwit> Seems pretty well suited.
13:48:18 <dmwit> Hm, on second thought, perhaps not. That wouldn't really let you have two keys with the same value.
13:49:08 <k0ral> Hello
13:49:14 * dmwit waves
13:50:01 <k0ral> I'm having trouble running a Haskell program that uses GLUT (through gloss library): it says "user error (unknown GLUT entry glutInit)"; any clue ?
13:50:32 <k0ral> I'm running under NixOS so it may be related to the way libraries are installed
13:50:44 <joe9_> davean: Instead of a psQueue, would an IxSet work better?
13:51:01 <k0ral> but when I ldd the executable, every dynamic library is found
13:51:08 <davean> joe9_: I don't see why it would
13:51:13 <davean> joe9_: why would you think that?
13:51:59 <joe9_> k0ral: with gl, you can enable debug context. That is a good way to figure out what is wrong.
13:52:19 <geekosaur> k0ral, that error indicates that it's dynamically loading GLUT; ldd will tell you nothing useful
13:52:45 <geekosaur> thta is, it's calling dlopen() and dlsym() from library code instead of letting process initialization load it
13:53:13 <joe9_> davean: is this what you had in mind? https://hackage.haskell.org/package/PSQueue-1.1/docs/Data-PSQueue.html for psqueue?
13:53:24 <davean> joe9_: a psqueue is litterly the name for "what is the optimal datastructure when we need to consider things in the order of their order but look up and remove and insert things by a seperate key"
13:53:43 <davean> joe9_: hackage.haskell.org/package/psqueues
13:53:53 <joe9_> davean:  ok, That is exactly what I want.
13:53:57 <joe9_> davean: Thanks so much.
13:55:05 <k0ral> geekosaur: maybe strace then ? I can see it's trying to open libglut.so in several paths but doesn't find it
13:55:54 <geekosaur> that sounds like a problem, yes. although I am told glut isn't used much any more, so you may well not have it
13:56:14 <k0ral> joe9_: could you please clarify what you meant ? is that a feature from gloss ?
13:57:52 <k0ral> I think this is a solution: https://github.com/NixOS/nixpkgs/commit/22281009b7af633398d3cb315321b83483f884bd
13:59:02 <joe9_> k0ral: this is how I used Gloss https://github.com/joe9/baby-steps-to-building-a-realtime-chart-with-haskell/blob/master/app/Step025Gloss.hs
14:02:07 <mmaruseacph2> I'm using Chart right now and found it quite intuitive
14:03:25 <k0ral> I don't understand, I'm using stack under NixOS, the patch on GLUT should be applying to me, yet it seems it doesn't
14:07:25 <ertes> k0ral: if you're on NixOS, why don't you just use nix?  it tends to just work, and in case it doesn't, fixes are applied on nixpkgs
14:07:49 <ertes> (that is nix instead of stack)
14:08:26 <ertes> since haskell-ng i had a very smooth experience with nix regarding haskell
14:08:48 <k0ral> ertes: I already went that way, actually I went back and forth several times between nix and stack, now that I have something that works I'm very reluctant to change anything
14:09:10 <k0ral> ertes: you mean writing a .nix derivation thanks to cabal2nix ?
14:09:12 <geekosaur> except, you don't have something that works
14:09:33 <ertes> k0ral: you can just see if it works without changing anything:  cabal2nix . > shell.nix && nix-build shell.nix
14:09:40 <geekosaur> you just deferred the error from compile time to run time, which is kinda the opposite of what you want to do in haskell
14:09:41 <k0ral> geekosaur: yeah, half-expected that reply :)
14:10:09 <ertes> k0ral: if it doesn't work, just delete the shell.nix file and forget what i said =)
14:10:27 <geekosaur> I would imagine you need to use some specific nix environment to make a glut library visible at runtime
14:10:51 <geekosaur> whereas if you used something compile time, you'd only need the environment while building
14:10:55 <k0ral> error: cannot auto-call a function that has an argument without a default value (‘mkDerivation’)
14:11:04 <ertes> name a GLUT application on hackage and i'll see if it works for me
14:11:27 <k0ral> let's check the reverse dependencies for gloss
14:11:33 <ertes> huh?  are you running an older NixOS channel?
14:11:45 <k0ral> I'm on nixos-unstable
14:11:57 <ertes> oh!
14:12:01 <ertes> i'm stupid, sorry
14:12:06 <ertes> cabal2nix --shell . > shell.nix
14:12:19 <david___> Hi folks! Quick question on GHC: is it possible to set RTS options (like +RTS -M2G) from within the program? 
14:12:20 <joe9_> geekosaur: with HashPSQ https://hackage.haskell.org/package/psqueues-0.2.2.2/docs/Data-HashPSQ.html, I cannot have multiple priorities, correct? I want to be able to find the minimum bid or ask, or minimum volume, etc.
14:12:42 <k0ral> ertes: it's running
14:13:44 <geekosaur> joe9_, yes. if you are doing this for arbitrary fields, this sounds like you really want a database instead
14:13:56 <k0ral> geekosaur: what's your point about build time vs run time ? will using nix rather than stack link everything statically ?
14:14:34 <k0ral> ertes: ok I'm actually impressed, it just worked
14:14:50 <k0ral> no more dynamic-loading error
14:14:54 <geekosaur> k0ral, my point is that build time can ensure that the dynamic objects referenced while building will be available at runtime. no such promise is made for dynamic objects that are dlopen()ed
14:15:17 <geekosaur> although if you impute a fake compile time dependency on the glut library, maybe it will work and not "optimize" it away
14:16:13 <geekosaur> but in general, if something uses dlopen with nix, you would need to run in a nix environment that exposes the library being dlopen()ed
14:16:41 <k0ral> geekosaur: I tried "nix-shell -p freeglut --run ..." but it didn't help
14:16:44 <geekosaur> instead of just building in it. "stack" is not particularly relevant here since it just automates setting up the build-time nix environment
14:17:48 <ertes> it may be one of those cases that needed nixpkgs-level fixing, although i find that hard to believe
14:18:05 * hackagebot regex-do 2.0 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.0 (procione)
14:23:24 <k0ral> ertes, geekosaur: anyway, thank you guys, going back to coding :)
14:30:36 <david___> Hi folks! Quick question on GHC: is it possible to set RTS options (like +RTS -M2G) from within the program? 
14:31:44 <geekosaur> not at runtime, as such. you can use an hs_main_with() in a custom C startup, or -with-rtsopts="..." at build time
14:31:50 <geekosaur> or GHCRTS envar
14:32:07 <Tuplanolla> You could cheat by displacing the process with `exec`.
14:32:09 <geekosaur> but after hs_main has happened by whatever means, you can't change rts opts
14:32:27 <geekosaur> unless you want to use the xmonad/dyre trick (basically re-exec()ing itself)
14:33:54 <david___> Ok. Thought about exec()ing again. But not being able to do it at runtime answers my question
14:38:20 <vb5piz3r> hi
14:38:47 <vb5piz3r> hi
14:39:51 <athan> hey vb5piz3r
14:41:07 <vb5piz3r> is it really worthwhile learning haskell? i mean you're obviously biased but can you name me some real real life applications for haskell? excuse the noob
14:42:12 <maerwald> vb5piz3r: if you want to just make your CV look good: no. If you want to learn something really new, yes.
14:42:55 <david___> 
14:43:20 <athan> vb5piz3r: It's been the best educational experience for me, and I've still got a long way to go (Which is awesome c:)
14:43:38 <vb5piz3r> i love learning new stuff, but i just wonder if anything really useful comes out of this? there must be i guess, haskell has quite a big and lively community for such an 'esoteric' language
14:44:06 <johnw> many of us use it productive every day
14:44:14 <maerwald> vb5piz3r: it's in fact not that esoteric and is used here and there in the industry (those that can afford it, like facebook)
14:44:16 <johnw> so we can't say for certain what its use for you will be, since I don't know your life
14:45:45 <vb5piz3r> haha, for sure you can't know that, but what is being done right now? there must be something interesting powered by haskell right now?
14:45:59 <maerwald> a lot of web frameworks
14:46:44 <athan> vb5piz3r: The science behind haskell is incredibly useful to learn
14:47:01 <vb5piz3r> now that's interesting, what makes haskell a good choice for web frameworks? efficiency i guess?
14:47:03 <maerwald> athan: what sience?
14:47:18 <maerwald> vb5piz3r: no, abstraction and reasoning
14:49:57 <vb5piz3r> that sounds to my taste, hence i was interested in haskell in the first place. functional programming seems to be very direct and formulaic, i had no idea that's useful for web frameworks. i was thinking more towards mathematical modelling
14:50:05 <maerwald> vb5piz3r: here's a facebook talk about using haskell https://youtu.be/sl2zo7tzrO8
14:50:28 <vb5piz3r> thanks maerwald
14:50:47 <ertes> vb5piz3r: haskell appears to be obscure and "esoteric" mostly because most newcomers are used to other languages…  actually haskell is a very natural language
14:50:55 <maerwald> vb5piz3r: most people think that. It turns out haskell is pretty good for writing DSLs, compilers etc. web frameworks sort of fit in thet scheme
14:51:51 <ertes> vb5piz3r: it's one of the few languages that lets you reason with confidence: "if it makes sense, haskell allows it" (with a small number of exceptions)
14:51:54 <mlehmk> haskell feels like I describe how something is pieced together and the kernel managed to generate an algorithm fitting that description
14:52:01 <Welkin> I've lost enthusiasm for explaining why haskell is a good choice these days
14:52:17 <maerwald> mlehmk: that's an overstatement
14:52:33 <mlehmk> and how I cannot tell whether my merge-sort is actually executel like a heap-sort instead
14:52:45 <ertes> Welkin: i'd point you toward agda/idris, but they only make you come back to haskell with depression =)
14:52:52 <Welkin> lol ertes 
14:52:55 <Welkin> it's not that
14:53:07 <Welkin> it's that I am tired of explaining it to people who demand long debates
14:53:12 <maerwald> well, both are more powerful from a language-desgin perspective, but the ecosystem is not the same
14:53:34 <mlehmk> haskell is a good choice for some problem domains
14:54:23 <c_wraith> Welkin, yeah, me too. I just say that it's the most practical language I've used for any domain where garbage collection is appropriate. if they think I'm crazy, I shrug. 
14:54:24 <ertes> Welkin: i know, but i'm not under the impression that vb5piz3r did that
14:54:34 <vb5piz3r> awesome guys, that's some food for thought. any suggestions on how i best go about learning?
14:54:46 <maerwald> @where learnhaskell
14:54:46 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:55:01 <Welkin> vb5piz3r: jump right in, start a small project
14:55:07 <Welkin> and go to that link above
14:55:08 <ertes> if someone genuinely would like to know why people like haskell, i'm happy to explain it for the 1000th time…  after all why should i explain foldr 1000 times, but not the language that surrounds it?
14:55:57 <maerwald> why are we having a meta discussion again?
14:56:27 <c_wraith> the more I deal with edge cases of using foldr, the more I think that if you understand it, you understand the entire evaluation model of haskell. all that's left over is the type system. :) 
14:56:30 <maerwald> Welkin: go code something you slacker :P
14:56:41 <ertes> c_wraith: indeed =)
14:56:43 <Welkin> maerwald: I am
14:56:59 <vb5piz3r> sorry for interrupting with my meta, and thanks for all your input! i know what to do with my free time for the next couple week :)
14:57:11 <maerwald> vb5piz3r: make it months, haha
14:57:12 <Tuplanolla> You mean years, right?
14:57:16 <maerwald> ...
14:57:47 <ertes> vb5piz3r: i've been coding haskell since ~2007, and you know when i first thought that i understand haskell?
14:57:52 <ertes> never
14:58:00 <maerwald> sheesh, this again :P
14:58:18 <Welkin> all you need is to understand it *enough*
14:58:26 <maerwald> the haskell mystification incoming
14:58:27 <vb5piz3r> oh dear, i hope i didn't start something grave here...
14:58:30 <Welkin> most people would advise against starting with yesod, but I did
14:58:31 <Welkin> and it was fine
14:58:35 * pharaun gets out a gravestone
14:58:39 <ertes> vb5piz3r: nah, don't worry =)
14:58:41 <pharaun> i started with xmonad then yesod
14:58:47 <Welkin> it was more of a DSL for me, but it helped me learn a lot about actually using monads and monad transformers
14:58:47 <pharaun> then it panned out from there
14:59:01 <maerwald> pharaun: both terrible overuse of monad transformers :P
14:59:06 <Welkin> it was ostly magic for a long time though
14:59:11 <Welkin> all the template haskell
14:59:13 * maerwald must resist
14:59:26 <pharaun> maerwald: :P fwiw none of my projects have had much transformers
14:59:32 <maerwald> nice
14:59:43 <pharaun> even after using yesod/xmonad i still didn't feel comfortable with super vertical transformers
15:00:26 <maerwald> I have never understood why people take such great lengths to hide a few additional function parameters under a non-intuitive crappy API
15:00:43 <Fairy> I'm not particularly happy with my Haskell function http://lpaste.net/6362824011268751360 is anyone able to take a quick look and judge it? (I'm a newbie <3 ) 
15:00:48 <ertes> i'd like to know why web frameworks gravitate so much toward complicated monad transformers
15:01:06 <Welkin> ertes: Servant doesn't
15:01:35 <osfameron> I'm confused why Haskell *templating* systems have such complicated interfaces :-)
15:01:40 <ertes> Fairy: are you supposed/allowed to use 'break'?
15:01:50 <Welkin> osfameron: what do you mean?
15:01:55 <ertes> osfameron: blaze-html and lucid are really simple
15:02:20 <osfameron> I found lucid *really hard*.  It doesn't really have any usage documentation
15:02:35 <Fairy> This is not a homework task or anything of that kind. I'm just trying to do arbitrary things and creating this function was one that came to mind (as it seemed rather simple, didn't quite turn out simple)
15:02:42 <Welkin> osfameron: it is just html
15:02:42 <Fairy> > ertes
15:02:44 <lambdabot>  error: Variable not in scope: ertes
15:02:53 <osfameron> and you seem to need to be really comfortable in writing stuff with monads to get it to do anything, even simple things
15:02:55 <ertes> i'm not in lambdabot's scope =(
15:02:58 <Welkin> osfameron: once you have used one you have used them all
15:03:01 <osfameron> Welkin: no it's not.  *html* is just html.
15:03:18 <osfameron> this is programmatic generation of html, which is entirely different.
15:05:18 <maerwald> ertes: hsp is horrible there
15:05:35 <maerwald> once had to deal with that and it probably took me half an hour to get what's going on
15:07:52 <ertes> Fairy: i'd write it in terms of foldr
15:08:16 <ertes> Fairy: do you want to try it yourself, or should i just show you mine?
15:08:24 <ertes> maerwald: hsp?
15:08:27 <ertes> ah
15:08:31 <maerwald> yeah, the package
15:08:45 <Fairy> ertes: I wouldn't mind seeing yours ;)
15:08:47 <maerwald> lost in the monad stack
15:08:49 <ertes> even though i used happstack in the past, i haven't actually used hsp/hsx
15:09:24 <maerwald> when you need to start guessing what "return" actually does
15:09:38 <ertes> @let ertesSplitBy p = uncurry (:) . foldr (\x (xs, xss) -> if p x then ([], xs : xss) else (x : xs, xss)) ([], [])
15:09:40 <lambdabot>  Defined.
15:09:45 <ertes> Fairy: ^
15:10:32 <ertes> > ertesSplitBy (== ',') ",blah,,blubb,,,hah!,,"
15:10:34 <lambdabot>  ["","blah","","blubb","","","hah!","",""]
15:11:49 <Fairy> ertes: ok, that sort of looks like magic, hang on, I think I'll have some questions ;p
15:12:34 <ertes> wait…
15:12:43 <ertes> > ertesSplitBy (== ',') (repeat ',')
15:12:48 <lambdabot>  ["*Exception: stack overflow
15:12:49 <osfameron> Welkin: ertes: sorry, I realise I'm grumpy today but don't mean to be hostile.  I'm sure they're great modules, but they seem to require you to know *a lot* of Haskell to get any results, and could probably do with links to a good tutorial.
15:12:49 <ertes> hah!
15:12:51 <ertes> @undef
15:12:56 <lambdabot> Undefined.
15:13:00 <ertes> @let ertesSplitBy p = uncurry (:) . foldr (\x ~(xs, xss) -> if p x then ([], xs : xss) else (x : xs, xss)) ([], [])
15:13:02 <lambdabot>  Defined.
15:13:05 <ertes> > ertesSplitBy (== ',') (repeat ',')
15:13:07 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
15:13:08 <Welkin> osfameron: use some of the examples from blaze-html's docs
15:13:10 <ertes> there we go
15:13:21 <Welkin> lucid is meant to be a drop-in replacement for it, pretty much
15:13:31 <Welkin> there are also some blog posts by the author
15:13:32 <ertes> osfameron: most of them want you to know about monoids
15:13:48 <ertes> osfameron: at least the EDSL ones…  there is one notable exception:  heist
15:14:08 <osfameron> Welkin: so if I go to https://hackage.haskell.org/package/blaze-html and then click on https://hackage.haskell.org/package/blaze-html-0.8.1.2/docs/Text-Blaze-Html.html ... I don't see many examples :D
15:14:36 <ertes> lucid's *types* can look a bit magic compared to blaze-html, mostly because it's more flexible in the way you can write attributes
15:14:44 <Welkin> osfameron: http://chrisdone.com/posts/lucid
15:15:07 <Welkin> I have found that pretty much all of these html dsls are almost identical
15:15:12 <osfameron> ertes: yeah.  But also about bytestrings and all kinds of other stuff before you can even get it to render anything at all
15:15:26 <Welkin> blaze-html, lucid, elm
15:15:41 <ertes> Fairy: (if you copy mine, be sure to copy the later one…  the former is wrong…  it diverges at infinity)
15:15:48 <osfameron> ertes: Heist looks interesting, but its documentation is... weird.  It explains all kinds of stuff with odd terminology, but doesn't deign anywhere to tell you how to replace a tag with... a variable
15:16:06 <Fairy> ertes could you explain the ~ tilde in it?
15:16:20 <Welkin> I used to like the shakespeare templates (hamlet/cassius/julius)
15:16:29 <Welkin> but now I prefer the blaze/lucid/elm style dsls
15:16:37 <osfameron> e.g. I'm coming from the Perl/Ruby/Python thing where you'd write something like:  <foo attribute="[% attr %]" />
15:16:45 <Welkin> osfameron: yes, that is not quite the same thing
15:16:54 <Welkin> that is something that needs to be parsed and processed
15:16:56 <ertes> osfameron: heist does something like that, except it uses XML syntax
15:17:02 <Welkin> what you write with blaze/lucid is actual code
15:17:02 <ertes> Fairy: observe:
15:17:22 <ertes> > let f (x, y) = () in f undefined
15:17:24 <lambdabot>  *Exception: Prelude.undefined
15:17:28 <ertes> > let f ~(x, y) = () in f undefined
15:17:30 <lambdabot>  ()
15:17:30 <Welkin> it is not a templating language
15:17:33 <Welkin> iti s just plain haskell
15:17:35 <osfameron> ertes: yeah, I can imagine that it must do (because it'd be a really strange templating system if you couldn't), it's just baffling that they don't seem to want to document it :D
15:17:44 <ertes> Fairy: the tilde makes the pattern match lazy
15:18:27 <ertes> osfameron: no, i mean it uses XML for the placeholders
15:18:39 <ertes> <p><my-content /></p>
15:18:58 <ertes> my-content is a placeholder, and you define in your code what it is
15:18:59 <osfameron> Welkin: I'd read the chrisdone post on lucid - again, it looks like a great technical blog post about implementation and reasons for why it's different from blaze, but it's not a tutorial.
15:19:30 <ertes> osfameron: heist is mostly for projects that have non-programmer web designers…  they can just write HTML
15:19:39 <Welkin> osfameron: if you like templating languages instead of using html combinators in plain haskell, then look at shakespeare http://www.yesodweb.com/book/shakespearean-templates
15:19:52 <Welkin> but I recommend using html combinators
15:19:54 <ertes> osfameron: but if you write the markup as a programmer, something like lucid is generally more flexible, because templates are just functions
15:20:09 <davean> ertes: Theres a lot to be said for lower iteration times though too
15:20:19 <davean> lucid is really terrible in those terms
15:20:26 <ertes> davean: what do you mean?
15:20:30 <osfameron> ertes: sure.  but I *am* a programmer, allegedly.  I can read documentation for templating libraries in most languages, usually.  I can't make head or tail of it in lucid or heist though :-(
15:20:48 <Welkin> osfameron: I just linked you to an actual tutorial on shakespeare
15:20:53 <davean> ertes: It takes eons from a change in lucid to seeing it on the screen
15:20:59 <Welkin> but then you are going to need to use template haskell
15:21:03 <davean> ertes: that can massively slow development, even for devs
15:21:05 <osfameron> Welkin: ta.  Yeah, I think shakespeare might be more "traditional" for my taste, yeah
15:21:14 <ertes> davean: a GHCi reload takes like half a second for me most of the time
15:21:17 <davean> ertes: Which is why several of the best programmers I know completely rejected working in it
15:21:52 <Welkin> lol
15:21:53 <ertes> davean: i've even written a library to make rapid prototyping possible without even restarting the server:  https://hackage.haskell.org/package/rapid
15:21:57 <Welkin> it wasn't a problem for me
15:22:05 <Welkin> I built 3 production apps using yesod
15:22:13 <ertes> davean: change the template, reload, refresh page
15:22:16 <Welkin> sure, it would take a second or two
15:22:18 <Welkin> not a big deal
15:22:25 <Welkin> it's a lot faster using elm on the frontend now though
15:22:30 <davean> ertes: I think we might have different beliefs in common project sizes
15:23:36 <ertes> davean: i'm convinced that this will work well even with huge projects, as long as templates are written in their own modules
15:23:58 <davean> Ok
15:24:03 <davean> thats very counter to my experience
15:24:31 <ertes> davean: try rapid then…  it might change your mind =)
15:24:32 <davean> You have beliefs, I have projects people ran from because of it
15:24:42 <ertes> if not, please report a bug =)
15:28:07 * hackagebot th-orphans 0.13.3 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.3 (ryanglscott)
15:38:20 <osfameron> OK, trying Lucid again.  How do I get the first example on https://hackage.haskell.org/package/lucid-2.9.6/docs/Lucid.html to work?
15:38:27 <osfameron> e.g. "123 < 456" :: Html ()
15:38:58 <osfameron> I've added 'lucid' to my stack's cabal file
15:39:56 <kadoban> osfameron: What issue(s) are you running into?
15:40:08 <osfameron> kadoban: it can't find the type Html
15:40:28 <kadoban> osfameron: Did you import the correct module?
15:40:32 <osfameron> I don't know
15:40:43 <osfameron> I've done *everything* that the documentation tells me to do
15:40:48 <osfameron> (it doesn't tell me to do anything)
15:41:06 <kadoban> Well, did you import any module?
15:41:11 <ertes> osfameron: did you import Lucid?
15:41:21 <MarcelineVQ> you'll need to import the module the documentation is about, e.g.:​ import Lucid
15:42:39 <ertes> osfameron: library (lucid) ≠ module (Lucid)…  you need to depend on the library, and then import its module(s)
15:43:08 <President_Trump> aatxe: Build the Wall
15:43:17 <osfameron> ok, that makes sense, sorry :-(
15:43:30 <osfameron> that said, now I get this error: Couldn't match type ‘[Char]’ with ‘HtmlT Data.Functor.Identity.Identity ()’
15:43:42 <MarcelineVQ> that's due to not having the extensions enabled that it mentions above the example
15:43:47 <kadoban> osfameron: You need the OverloadedStrings extension as well
15:44:04 <MarcelineVQ> in ghci that's something like :set -XOverloadedStrings
15:44:10 <Koterpillar> the docs could do with mentioning that, though
15:44:15 <osfameron> ok... I don't understand why this stuff isn't in the synopsis?
15:44:19 <ertes> better use :seti
15:44:40 <osfameron> e.g. see https://metacpan.org/pod/Template#SYNOPSIS for an example from the Perl world
15:44:58 <Koterpillar> osfameron: "Plain text is written using the OverloadedStrings and ExtendedDefaultRules extensions, and is automatically escaped:"
15:45:02 <osfameron> it even says "use Template;" (e.g. the Perl equivalent of the "import Lucid" that I missed above)
15:45:03 <Koterpillar> that one is mentioned
15:45:11 <MarcelineVQ> the extensionsd are mentions, it's just also assuming a familiarity with haskell projects
15:45:13 <osfameron> Koterpillar: that's not an instruction
15:45:26 <osfameron> "is written" isn't the same as "do this: ..."
15:45:41 <osfameron> woo
15:46:02 <ertes> osfameron: this is not a defense, but personally as an experienced haskeller i like the "no bloat" approach to explaining things that many libraries follow, i.e. explain the library, not haskell
15:46:46 <ertes> osfameron: web frameworks generally have two documentation sources:  one (usually on the home page) that explains everything, and then the haddocks that do the "no bloat" explanation
15:46:52 <Koterpillar> OTOH if we make sure the documentation is literate, it helps test it
15:47:10 <Koterpillar> ertes: I just checked, the documentation link points to the same thing: http://chrisdone.github.io/lucid/Lucid.html
15:47:11 <osfameron> ertes: I know what you mean, it's a tradeoff
15:47:48 <osfameron> I'm possibly spoilt by Perl docs, which tend to be really good to get you started (and often less good at telling you the *details* admittedly)
15:48:32 <osfameron> I do like the "here's 10 lines with a tiny example of how you might use the library to do something really simple" though.  It's not *that*  much bloat.
15:48:38 <ertes> Koterpillar: i don't consider lucid a web framework =)
15:48:43 <clmg> What can I use to generate a sequence like [2,2,4,4,4,4,8,8,8,8,8,8,8,8...] ?
15:48:56 <Koterpillar> ertes: ?
15:49:10 <ertes> > [2,4..] >>= \n -> replicate n n
15:49:12 <lambdabot>  [2,2,4,4,4,4,6,6,6,6,6,6,8,8,8,8,8,8,8,8,10,10,10,10,10,10,10,10,10,10,12,12...
15:49:15 <ertes> oh
15:49:20 <ertes> > iterate (2*) 2 >>= \n -> replicate n n
15:49:23 <lambdabot>  [2,2,4,4,4,4,8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16...
15:49:25 <ertes> more like that
15:49:40 <clmg> what if the numbers weren't identical to their counts?
15:49:57 <ChaiTRex> clmg: What is the pattern?
15:50:19 <clmg> [3,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5]
15:50:31 <ertes> > zip (,) [1..] (iterate (2*) 2) >>= uncurry replicate
15:50:34 <lambdabot>  error:
15:50:34 <lambdabot>      • Couldn't match expected type ‘[Integer] -> [(Int, b)]’
15:50:34 <lambdabot>                    with actual type ‘[(a0, Integer)]’
15:50:38 <ertes> > zip [1..] (iterate (2*) 2) >>= uncurry replicate
15:50:40 <lambdabot>  [2,4,4,8,8,8,16,16,16,16,32,32,32,32,32,64,64,64,64,64,64,128,128,128,128,12...
15:50:44 <kadoban> clmg: That's not really enough to figure out a pattern from :-/
15:50:47 <ertes> clmg: like that?
15:50:53 <clmg> ertes: closer
15:51:03 <ertes> clmg: there are infinitely many patterns, so you have to explain which one you need =)
15:51:11 <osfameron> hmm, so the 4th example doesn't work either:  p_ "hello" <> p_ "sup" :: Html ()
15:51:16 <ertes> clmg: but in any case concatMap (a.k.a (=<<)) is your friend
15:51:18 <osfameron> presumably I need the definition of (<>) from somewhere?
15:51:25 <delYsid> what is a good way to deal with an AST which is progressively enhanced with information during semantic analysis?  Flat records with a lot of Maybes, or several levels of wrapper types? Or something else?  Maybes sort of polute the parser side, and stacked wrappers result in nested accessors, neither feels very neat.
15:51:27 <kadoban> osfameron: Data.Monoid
15:51:40 <clmg> it goes 3x6, 5x12, 7x18, 8x24
15:51:45 <osfameron> kadoban: thanks
15:51:55 <ertes> clmg: that one i'll leave for you to figure out =)
15:52:07 <clmg> the counts increase by 6, the numbers increase by two
15:52:51 <osfameron> so would a PR that added an example with 'import Lucid', how to import the overloaded string instance, and data.monoid be welcomed?
15:53:07 <exio4> delYsid: parametrize! data Expr f = FunCall [(f (Expr f))] [(f (Expr f))] | RawInt (f Integer) | ... ?
15:53:38 <ertes> osfameron: maybe, although it would be more helpful to turn "<>" in the example code into an actual link
15:53:58 <MarcelineVQ> osfameron: quite possibly, you could file an issue on github asking about it
15:54:26 <ertes> osfameron: a quick "this library generally requires the OverloadedStrings extension" also seems like a good idea, as long as you don't turn the haddocks into a haskell tutorial
15:54:55 <kadoban> It kinda already says that part
15:54:58 <osfameron> ertes: oh, can you link within code blocks?  is there an example of that somewhere?
15:55:20 <osfameron> MarcelineVQ: hmm, I'll do that (I suspect I don't know haddock well enough to file an approvable request right now)
15:55:31 <ertes> osfameron: https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810780208
15:55:41 <ertes> "There is an important difference between the two forms of code block: in the bird-track form, the text to the right of the ’>‚ is interpreted literally, whereas the @...@ form interprets markup as normal inside the code block."
15:56:05 <clmg> > zip [6,12..] (iterate (2+) 3) >>= uncurry replicate
15:56:07 <lambdabot>  [3,3,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,9...
15:56:26 <ertes> clmg: iterate (2+) 3 = [3,5..]
15:56:34 <osfameron> ertes: ah, nice
15:56:55 <osfameron> kadoban: "kinda" yeah ;-)
15:57:03 <ChaiTRex> > concat $ zipWith (flip replicate) [3, 5..] [6, 12..]
15:57:05 <lambdabot>  [3,3,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,9...
15:57:08 <mlehmk> > fmap fst $ iterate (\(x, y) -> (y, x + y)) (1,1)
15:57:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:57:10 <ertes> clmg: i think as a beginner it may be more helpful to write that one differently
15:57:21 <ertes> clmg: yeah, ChaiTRex read my mind =)
15:57:25 <delYsid> exio4: hmm, I think I see.  I have almost no recursion in my AST, but the same trick might help me as well.
15:58:01 <kadoban> osfameron: Well, it says that plain text is written using the OverloadedStrings blah blah blah ... which is not very different from the language I was responding to.
15:58:10 <exio4> delYsid: anyway, you could just add f in the places where you need tags, and then Identity would give you your current AST :)
15:59:08 <osfameron> kadoban: "is written" doesn't mean anything to a beginner.  It doesn't say "You must do *this* in order to run the following code"
15:59:50 <kadoban> osfameron: I have no particular thoughts on that. Just was pointing out that specific lanugage proposed was already basically in there.
16:00:19 <osfameron> sure, it's just about how to format it to be useful, I guess
16:00:34 <kadoban> Sure, probably a good idea.
16:04:59 * osfameron opens https://github.com/chrisdone/lucid/issues/57 for now
16:05:45 <osfameron> thanks all for the help and feedback :-)
16:06:48 <delYsid> exio4: Is there a way to use records with this? As far as I can currently see, it would force me to pack all fields of a data type into a tuple to be able to pass it as one arg to f.
16:07:32 <exio4> delYsid: uh?
16:07:49 <delYsid> data Atom f = Note (f (Pitch, Duration, Dots)) | Rest (f (Duration, Dots))
16:08:19 <exio4> delYsid: why note data Atom f = Note (f Pitch) (f Duration) (f Dots) | Rest (f Duration) (f Dots) ? 
16:09:40 <delYsid> exio4: I calculate new info for a Note or Rest, but not for each octave and duration...
16:09:46 <mlehmk> I think I made a joke in Haskell
16:09:52 <mlehmk> phi = last (fmap (\(x, y) -> (y / x)) $ iterate (\(x, y) -> (y, x + y)) (1,1))
16:11:21 <mlehmk> I think the essence of these jokes is absurd :: Void -> a
16:11:23 <exio4> delYsid: well, no idea what a good solution other than a tuple or extra data types could be
16:11:48 <clmg> how about this pattern? [1,3,5,7,9,13,17,21,25,31,37,43,49] ?
16:12:04 <clmg> It has another dimension to it. Can I still do it with iterate/replicate?
16:12:17 <mlehmk> I don't know a constant memory variant of generating that pattern
16:12:29 <mlehmk> wait, I do
16:13:36 <mlehmk> but it's a Shlemiel the Painter's algorithm way in constant memory
16:14:30 <ChaiTRex> clmg: What is the pattern?
16:14:38 <grazie> question: the evaluate function of Control.Exception.Base isn't defined in the file Control/Exception/Base.hs - why not? http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception-Base.html#v:evaluate
16:14:56 <mlehmk> iterate over it and try if it's divisible by any of [2..(sqrt x)]
16:15:04 <clmg> ChaiTRex: increase by two for 4, then 4 for 4, then 6 for 4
16:15:09 <grazie> it seems to be defined in GHC.IO https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IO.html#evaluate
16:16:27 <grazie> I was looking in base 4.9.0.0 control/exception/base.hs for `evaluate` (it's exported by that module) but it's not defined there Control-Exception-Base
16:17:14 <ertes> > scanl (+) 1 ([2,4..] >>= replicate 4)
16:17:17 <lambdabot>  [1,3,5,7,9,13,17,21,25,31,37,43,49,57,65,73,81,91,101,111,121,133,145,157,16...
16:17:30 <mlehmk> oh my
16:17:30 <Koterpillar> grazie: modules can re-export things
16:17:48 <clmg> ertes:godlike
16:17:58 <ChaiTRex> scanl is quite nice.
16:18:08 <ertes> clmg: you can have any pattern you want
16:18:18 <clmg> i was just playing with scanl and on the right track.
16:18:19 <ertes> as long as it's computable
16:18:42 <clmg> I just can't wrap my head around some of these patterns
16:19:16 <ertes> clmg: the best way to learn them is to implement them yourself
16:20:23 <grazie> Koterpillar: interestingly, Hoogle reported that `evaluate` is exported by Control/Exception/Base.hs but not GHC/IO 
16:23:38 <grazie> so the reason why I was looking for source of `evaluate`: can anyone explain it's type signature? evaluate :: a -> IO a
16:23:50 <grazie> in the context of it's source https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IO.html#evaluate
16:26:23 <grazie> does the IO a in the return mean that it's only used in IO situations ?
16:27:17 <Koterpillar> it means the result is an IO action, which you can, for example, wrap a `catch` around
16:27:55 <Cale> grazie: It gives you an IO action which, when executed, will cause the evaluation of that expression.
16:28:04 <Cale> (the expression to which it has been applied)
16:28:50 <grazie> why would evaluate be used in this code (from concurrent and parallel programming in haskell) https://gist.github.com/fa1c6f03ecf2ec582e16a9a01bdf6451
16:28:53 <Cale> grazie: While no actual I/O occurs, this is often useful in conjunction with exceptions -- sometimes you *really* need to catch an exception which is thrown from the evaluation of an expression rather than from IO.
16:29:30 <Cale> ah, hmm
16:29:41 <jle`> grazie: maybe because of readFile, which complicates things
16:29:45 <Cale> Well, that will cause the entire file to be read up front.
16:29:47 <MarcelineVQ> looks like it's being used to for the file to be read all at once
16:29:51 <mlehmk> > filter (\ x -> all ((0 /=) . mod x) [2..(floor $ sqrt $ fromIntegral x)]) [2..]
16:29:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:29:55 <Cale> But I don't really see why it would be necessary
16:29:57 <jle`> readFile is kind of awkward because evaluation of the result drives IO
16:30:03 <jle`> so evaluation causes IO
16:30:31 <Cale> Well, I don't know if it's really being used for that here
16:30:31 <Cale> hmm
16:30:58 <jle`> it might be so that parMap can work on all the inputs at once?
16:30:59 <Cale> Yeah, it should be roughly the same without that...
16:31:00 <MarcelineVQ> it's just traversing the spine, I think it's loading it so that parMap's efficieny can be measured in terms of work not IO
16:31:00 <grazie> ok, what about this example (from same book) where there's no readFile and (presumably) no possibility of exception https://gist.github.com/831ea91875dce66b0bf67be13b795d42
16:31:26 <Cale> Well, yeah, it might have something to do with increasing the degree of parallelism, but I don't see how doing extraneous evaluation up front is helpful overall.
16:31:31 <jle`> ah yeah, maybe because parmap would be doing IO the same time it's running 'solve'
16:31:48 <Cale> Oh, it would make sense if we were *measuring* the performance
16:31:54 <grazie> I think the author explained that it's forcing execution (as in traversing the spine like MarcelineVQ said) but that's why I don't get the IO a return value
16:32:14 <Cale> grazie: It's just a way of doing that which is sequential with other IO actions
16:32:34 <jle`> grazie: it's just so that the result of the IO action is the thing passed to evaluate
16:32:41 <Cale> grazie: i.e. evaluate (some expression) will cause (some expression) to be evaluated *when that IO action is executed*
16:34:14 <grazie> is there anything about `runEval test` in this code that makes it an IO action (other than that it's in a do block of main)?
16:34:15 <Cale> grazie: It's important to realise that there are two somewhat-separate processes taking place as a Haskell program runs: there's evaluation, which takes expressions and basically rewrites them according to the definitions in the program until they can match a pattern
16:34:16 <grazie> https://gist.github.com/831ea91875dce66b0bf67be13b795d42
16:34:17 <jle`> also somtimes people do stuff like x <- evaluate =<< foo
16:34:26 <Cale> It (typically) has no user-visible effects
16:34:32 <jle`> by some people i mean me
16:34:37 <Cale> (apart from lazy I/O reads, and traces)
16:34:51 <Cale> and then there's execution of IO actions
16:35:23 <Cale> which means taking some x :: IO t, and carrying out the steps that value describes (and obtaining a result of type t at the end, if we terminate normally)
16:35:23 <jle`> grazie: oh, in this case, it's because youa re timing things
16:35:38 <jle`> grazie: if you had just done r = runEval test
16:35:41 <jle`> then that doesn't evaluate r
16:35:50 <jle`> so t1 <- getTime; let r = runEval test; t2 <- getTime ...
16:35:53 <jle`> that would be a silly way to time it
16:35:56 <grazie> ok, 
16:36:02 <jle`> because the two IO actions would happen one after the other immediately
16:36:07 <jle`> 'let r = runEval test' doesn't evaluate anything...
16:36:14 <jle`> it just defines an "alias" for runEval test, essentially.
16:36:21 <grazie> thank you
16:36:34 <jle`> 'r <- evaluate (runEval test)' is an IO action that, when executed, evaluates runEval test
16:36:45 <jle`> so t1 <- getTime; r <- evaluate (runEval test); t2 <- getTime
16:36:58 <jle`> that's three IO actions: (1) get the time, (2) spend the time to evaluate runEval test, (3) get the time
16:37:20 <jle`> if it was t1 <- getTime; let r = runEval test; t2 <- getTime, that'd just be (1) get the time, (2) get the time again
16:38:15 <jle`> grazie: remember that 'let r = ...' in the middle of a do block doesn't sequence the evaluation of 'r'.  it just defines r as ..., kind of like an alias
16:38:58 <jle`> 'evaluate (runEval test)' is itself a sequencable IO action (like getLine, putStrLn) whose effect is to evaluate (runEval test)
16:39:15 <grazie> thank you
16:39:35 <grazie> that's actually explained inthe book but it didn't click when I looked at that code
16:40:12 <ajp> is there a name for options of a sumtype? As in, "Left and Right are <something>s of Either"
16:40:18 <jle`> constructors?
16:40:24 <mlehmk> > ffib 1000
16:40:27 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
16:40:30 <ajp> ah, of course
16:42:07 <mlehmk> that's a fast fibonacci
16:42:53 <jle`> you aren't fibbin'
16:43:47 <mlehmk> checking wolfram alpha I get the same result
16:44:20 <ajp> jle`: and, if I had `Either Int Char`, is there a similar name for "Int and Char are <something>s of the Either type"?
16:45:11 <ajp> I might say something like subtypes or alternatives
16:46:51 <jle`> hm, i'm not sure what i'd call it
16:47:30 <mlehmk> ffib 10000 took 51.8 secs and about 4.7 GB
16:48:43 <jle`> that's weird
16:48:51 <jle`> how is it implemented?
16:50:38 <mlehmk> ffib 0 = 0 ; ffib 1 = 1 ; ffib 2 = 1 ; ffib x | even x = let a = x `div`2 in ffib(a) * (2 * ffib(a + 1) - ffib(a)) | odd x = let a = (x - 1) `div`2 in ffib(a+1)*ffib(a+1)+ffib(a)*ffib(a)
16:51:23 <jle`> oh
16:51:25 <mlehmk> the result of ffib 1000 and https://www.wolframalpha.com/input/?i=fibonacci+1000 are the same
16:51:38 <jle`> that sounds decently space inefficient
16:51:46 <mlehmk> but is time efficient
16:51:48 <jle`> is it quadratic space?
16:51:52 <jle`> but, is ti really?
16:53:04 <jle`> @let (x : xs) !!* n | n <= 0 = x | otherwise = x `seq` (xs !!* (n - 1))
16:53:06 <lambdabot>  Defined.
16:53:20 <jle`> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
16:53:22 <lambdabot>  Defined.
16:53:29 <jle`> > fibs !!* 10000
16:53:31 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
16:53:38 <jle`> > fibs !!* 100000
16:53:41 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
16:53:49 <mlehmk> huh?
16:53:54 <jle`> this one should be constant space
16:54:20 <jle`>  !!* is just !! but it forces values as it goes along
16:54:35 <jle`> alternatively
16:55:15 <jle`> @let szipWith f (x:xs) (y:ys) = let z = f x y in z `seq` z : szipWith f xs ys
16:55:17 <lambdabot>  Defined.
16:55:28 <jle`> @let fibs' = 0 : 1 : szipWith (+) fibs' (tail fibs')
16:55:30 <lambdabot>  Defined.
16:55:35 <jle`> > fibs' !! 10000
16:55:37 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
16:55:39 <jle`> > fibs' !! 100000
16:55:42 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
16:56:03 <mlehmk> okay
16:56:30 <jle`> szipWith is zipWith but it forces evaluation as it goes along
17:00:49 <mlehmk> why can't I find szipWith on hoogle?
17:01:05 <MarcelineVQ> he just wrote it in those example :>
17:01:14 <mlehmk> ohh, I missed that
17:01:25 <jle`> yeah, you need either a strict zipWith or a strict !!
17:01:33 <jle`> otherwise the naive fibbing leaks space v.v
17:01:42 <jle`> it's kind of annoying that there isn't one in prelude
17:02:06 <MarcelineVQ> Prelude or base?
17:02:11 <jle`> anywhere
17:02:14 <jle`> :'(
17:02:24 <MarcelineVQ> ah hmm, well there is a strict scanl
17:02:33 <MarcelineVQ> > fix ((1 :) . scanl' (+) 1) !! 100000
17:02:36 <lambdabot>  4202692702995154386319005101293915131773915702632234503304716087198335731457...
17:02:49 <jle`> ah that's neat
17:02:56 <MarcelineVQ> pretty inscrutable though really
17:03:10 <jle`> what did you call me
17:03:37 <mlehmk> learning something new every day
17:03:40 <MarcelineVQ> yaheardme
17:03:51 <Welkin> jle`: that's racist
17:04:05 <jle`> yeah, fibs = 1 : 1 : zipWith (+) fibs (tail fibs) is my favorite haskell fib
17:04:06 <MarcelineVQ> that scanl will do !! 1M is 6 secs in ghci
17:04:11 <MarcelineVQ> *in
17:04:16 <hodapp> :t scanl
17:04:19 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
17:04:49 <jle`> except with !! it leaks space
17:08:25 <MarcelineVQ> I also prefer zipWith, especially as an example piece, some places scans gets used though are super interesting
17:10:01 <mlehmk> for some reason it doesn't do well with 1M
17:10:24 <hodapp> scanl is a thing I've never really learned... hmmm.
17:10:36 <mlehmk> using 44GB
17:10:51 <hodapp> eeep
17:11:24 <mlehmk> but that's leaking memory that isn't needed
17:11:40 <fresheyeball> anyone out there trying to run ghc-mod in nix-shell?
17:12:22 <MarcelineVQ> Be sure to be using scanl' when you're up at 1M
17:12:38 <Cale> fresheyeball: I haven't tried that, but if you figure something out, let me know.
17:12:42 <mlehmk> I'm using scanl'
17:13:15 <mlehmk> I used this: fib = (fix ((1 :) . scanl' (+) 1) !!) . (-1 +)
17:13:50 <mlehmk> maybe I need a different fix or scanl'
17:14:09 <Cale> fresheyeball: There's a script that a coworker of mine wrote to get hdevtools working in a nix shell... I'm not sure if it works generally or just in our setup...
17:15:05 <Cale> ah, it seems to be particularly constructed for our nix configs
17:15:30 <mlehmk> I tried with fix from Data.Function and scanl' from Data.List
17:16:21 <MarcelineVQ> mlehmk: that looks fine, that exampe is on par with the szipWith version shown above
17:16:24 <Cale> > let lucas a b = a : lucas b (a+b) in lucas 0 1
17:16:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:16:56 <Cale> That might be better in terms of garbage collection
17:17:37 <Cale> hmm
17:20:09 <mlehmk> (!!) uses so much memory
17:22:59 <fresheyeball> its not see ghc-mod: <command line>: cannot satisfy -package-id reflex-dom-0.4-J8C62owOAt5HVwCfe8zlQ1
17:22:59 <fresheyeball> ghc-mod: <command line>: cannot satisfy -package-id reflex-dom-0.4-J8C62owOAt5HVwCfe8zlQ1
17:22:59 <fresheyeball> so I'm new to nix-shell 
17:22:59 <fresheyeball> and getting errors running ghc-check instide the nix shell 
17:22:59 <fresheyeball> specifically it can't satisfy dependencies 
17:22:59 <fresheyeball> I've tried cabal build (which works fine) 
17:22:59 <fresheyeball> making a cabal sandbox and building (also compiles fine) 
17:23:00 <fresheyeball> but ghc-mod check still does not work 
17:23:00 <fresheyeball> any ideas?
17:29:58 <mlehmk> whatever I do... it uses lots of memory
17:33:46 <mlehmk> even trying fib a _ 0 = a ; fib a b n = fib b (a+b) (n-1) uses a lot of memory
17:38:10 <kadoban> mlehmk: How much is a lot? Are you compiling with optimizations? You should put bang patterns on some of those   fib a !b !n  or so I believe. You can use seq if you don't want to use an extension
17:40:18 <mlehmk> bang? mmm
17:41:12 <kadoban> As shown in the example. If you try it it'll tell you what extension you need to turn on to allow it.
17:47:56 <ertes> mlehmk: try this:  (x : xs) !!! 0 = x; (x : xs) !!! i = x `seq` xs !!! (i - 1); _ !!! _ = error "I suck, because I'm a partial function"
17:48:15 <ertes> it's not fib that is your problem
17:52:40 <mlehmk> I didn't even use !! in the later tries
17:53:12 <mlehmk> anyways, see you
17:53:37 <kadoban> mlehmk: By the way, you know the numbers for fib get *huge* fairly quickly, right? It's unclear how much memory you're talking about here.
17:55:39 <mlehmk> kadoban, in the 44GB with 1 million
17:58:06 <jle`> mlehmk: the main problem with the non-strict versions is that the result of fib 1000000 is a giant expression tree that evaluates to the answer
17:58:17 <jle`> and that giant expression tree takes up a lot of memory
17:58:25 <jle`> that's why the strictness is necessary
18:45:33 <Lokathor> i'd like to ask about style a bit, which is dangerous, I know
18:45:54 <Lokathor> but about when do folks favor ReaderT over just passing a record around?
18:47:49 <c_wraith> Lokathor: When it passes in things that you typically use in leaves, so passing the record manually would be a lot of syntactic noise
18:49:55 <AbelianGrape> Hello all. I'm trying to use Heist to render a webpage. I have a template file, "bar.tpl" that contains "<foo/>". How do I make it so that when I call "Compiled.renderTemplate heistState "bar"", it substitutes some text of my choosing where "<foo/>" used to be? I tried to find out online, but every example I've found is way too complicated to easily derive any meaning from.
18:49:55 <Cale> Lokathor: I mainly use ReaderT as a component in a definition of a monad which involves other, less trivial monad transformers.
18:50:16 <Cale> Lokathor: If there are no other monad transformers around, it's almost never worth it.
18:50:34 <Lokathor> at the moment i'm just using something like, type IRC a = ReaderT ConnectionEnv IO a
18:50:44 <Lokathor> but probably a StateT will be thrown on top later
18:50:55 <Cale> Lokathor: also, consider using newtype rather than type
18:52:04 <Lokathor> hmm, does it make a big difference if outside modules can't create a ConnecitonEnv anyway? (private constructor)
18:53:17 <Cale> Lokathor: The point is that you want to limit the part of your program which can tell how your monad is implemented
18:53:48 <Cale> So that it doesn't become painful later when you change that.
18:53:50 <Lokathor> ah, yes
18:54:04 <AbelianGrape> Oh wait, wow, is there no way to pass a value into renderTemplate? Can you not actually pass something into a compiled splice?
19:01:24 <Lokathor> readTChan blocks/retries if the TChan is empty, right?
19:01:35 <Lokathor> that seems to be the implication from the docs
19:01:45 <Cale> Yeah, it should retry
19:02:52 <Lokathor> http://lpaste.net/334566 so handy
19:03:15 * hackagebot mysql-haskell 0.7.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.7.0.0 (winterland)
19:03:53 <Cale> Lokathor: Well, that's not really any different from an ordinary Chan
19:04:14 <Lokathor> I'm not familiar with other Chans
19:08:08 <bollu> Why are the type of Booleans (2) not used for true and false?
19:08:30 <bollu> In HoTT ^ 
19:08:30 <Lokathor> booleans are used for true and false
19:25:03 <AbelianGrape> If I'm understanding this correctly, this is horrible. Can someone who knows Heist confirm or deny this? There is no way to pass information into and render a compiled splice at runtime. Instead, the compiled splice runs a monadic action *which can do IO and stuff* at runtime, but there's no way you can actually pass anything into the "rendering context"
19:25:14 <AbelianGrape> If true, this is a really awful design
19:26:22 <xenon-> does ghc-mode (or whatever the currently popular haskell emacs mode is) work as well with spacemacs as with regular emacs?
19:29:34 <AbelianGrape> The library author's answers on StackOverflow are worse than useless. Just "No, Heist is way more powerful than you're understanding, not that I'm actually going to tell you how."
19:32:05 <Dacto> using optparse-applicative how do i know when a particular flag' is used?
19:33:58 <Dacto> looking at the --version example on hackage, I dont understand how to know if --version was called so i can show some text
19:34:02 <Lokathor> http://lpaste.net/334573 maybe this time it actually works how i think it works
19:36:28 <pavonia> Dacto: The return value of the parser tells you what flags where used
19:37:30 <Dacto> pavonia: the return value is Nothing for the example https://hackage.haskell.org/package/optparse-applicative-0.13.0.0#flags
19:38:16 * hackagebot mysql-haskell-openssl 0.7.0.0 - TLS support for mysql-haskell package using openssl  https://hackage.haskell.org/package/mysql-haskell-openssl-0.7.0.0 (winterland)
19:38:36 <pavonia> Dacto: What flag do you call it with?
19:41:26 <Dacto> pavonia: http://lpaste.net/1726274336970506240
19:41:47 <Dacto> pavonia: called with '--version'
19:45:57 <AbelianGrape> For anyone in the future searching IRC logs, to "pass" parameters into compiled heist, you can parametrize it over a Reader (Map Text Text) monad instead of whatever monad you're running in
19:51:47 <pavonia> Dacto: I think flag' will always return the first parameter, it only seems to make sense to use this parser in certain contexts
19:52:38 <Dacto> pavonia: so, i should use 'maybe' on the parser return value to show the text vs work with other args? 
19:53:20 <Dacto> pavonia: i don't understand how one would have multiple flags and do different things depending on set of flags used since they could all return Nothing, right?
19:53:40 <pavonia> You probably want another parser instead, like flag
19:54:04 <Clint> or infoOption
19:54:23 <Dacto> pavonia: ah, true
19:55:31 <Dacto> Clint: yes - infoOption would work too for version since it will exit
19:56:41 * Clint nods.
20:50:39 <clmg> Is there anything wrong with using `foo $bar $raz` instead of `foo . bar $ raz` ?
20:50:52 <clmg> The former is more concise but harder to read, I suppose.
20:51:09 <pikajude> it'll stop parsing correctly if you turn on template haskell
20:51:16 <pikajude> or rather, it'll parse differently
20:51:22 <clmg> oh
20:51:32 <glguy> specifically because of the lack of a space after the $
20:51:49 <glguy> or foo $ bar raz,  or even better:   foo (bar raz)
20:52:28 <slack1256> has somebody done the work of enumarating patterns to look out for space leaks?
20:52:57 <clmg> When I first started I used parentheses but switched to $ notation
20:54:32 <crakesh> test
20:56:26 <monochrom> yes, one pattern is lazy evaluation, another pattern is eager evaluation
20:57:09 <monochrom> and within lazy evaluation, one pattern is foldr, another pattern is foldl
20:57:33 <monochrom> likewise, within eager evaluation, one pattern is foldr', another pattern is foldl'
21:15:43 <boxscape> just installed stack on arch and am trying to install ghc... is it normal that "updating package index" takes more than a few minutes? that hasn't been the case for me before
21:23:49 <boxscape> well, nevermind, got past it now, apparently it did just take time
21:42:37 <amiller> https://www.youtube.com/watch?v=2vJ9toLlBE4  ΛОλ: Functional Lattice Cryptography   CCS 2016 - 
21:42:56 <amiller> couldn't find this posted elsewhere
21:43:01 <begriffs> Is there a common way to map on the left value of an either, or is it best to roll your own function for this?
21:43:44 <Koterpillar> begriffs: lens?
21:44:11 <begriffs> What's the lensy way to do it?
21:46:40 <Koterpillar> > over (mapped . _1) negate [(1, 2)]
21:46:42 <lambdabot>  [(-1,2)]
21:47:36 <Koterpillar> > over (mapped . _Left) negate [Right 2, Left 1]
21:47:38 <lambdabot>  [Right 2,Left (-1)]
21:48:01 <begriffs> Looking through the docs seems like `& _Left %~ foo` will map foo over the left val.
21:50:56 <xenon-> i am struggling to express this in haskell.. say i am representing an ad on ad site. there are multiple ad sites. and each ad site has its own type of ads (computer ads, real estate ads, etc), each with its own fields, while sharing a common field (subject, text, price). how would i represent this in haskell that would allow me to reuse as much as code as possible and to treat all ads from all the sites uniformly?
21:51:32 <xenon-> it seems that i am looking for inheritance equivalent, but we obviously don't have that
21:52:13 <Koterpillar> xenon-: the simplest way is data Ad = Ad { adSubject :: String, adText :: String, adPrice :: Currency, adDetails :: AdDetails }
21:52:29 <Koterpillar> xenon-: and data AdDetails = ComputerAd ... | RealEstateAd ... | etc.
21:53:23 <xenon-> Koterpillar i tried something similar.. i am not really happy with it. for example adCPU realEstateAd will fail at runtime
21:54:04 <Koterpillar> don't use or export those accessors
21:54:25 <Koterpillar> write your own that do Maybe, or use lenses
21:54:55 <xenon-> yeah good poitn
21:55:14 <xenon-> is there an extension that would return Nothing for missing fields/mismatched ads?
21:55:45 <xenon-> probably not
21:55:57 <Koterpillar> is there that many fields?
21:56:55 <xenon-> up to a dozen.. and i am not using all the info when scraping the site, so i may add more in future
21:58:13 <johnw> begriffs: yes, that way works well, but it's a bit heavy
21:58:22 <Koterpillar> xenon-: some simple TH will get you there
21:58:43 <johnw> begriffs: Either is also a bifunctor, so "bimap foo id" would accomplish that too, but that's yet another dependency
21:58:51 <xenon-> would lens help me here?
21:59:05 <Koterpillar> xenon-: depends what do you mean by "help"
21:59:17 <begriffs> johnw: agreed, I think stylistically I'd rather reinvent the wheel a little than obscure the code with all that.
21:59:19 <xenon-> remove the boilerplate (or having to write TH to remove it)
21:59:26 <johnw> begriffs: yes, mapLeft is hard to argue with :)
21:59:38 <johnw> it's in the 'either' package, fwiw
22:00:25 <Koterpillar> xenon-: lens will derive you Traversals for the fields that aren't guaranteed to be there
22:02:05 <xenon-> i don't know what the f that means :P
22:02:38 <Koterpillar> AFAIR they won't let you just ^. those
22:03:01 <Koterpillar> you'll be able to _set_ them, and setting CPU on a real estate ad is a no-op
22:03:19 <Koterpillar> with the right invocation, you'll get out a Maybe CPU of it
22:05:00 <xenon-> ok i'll probably do it either like you suggested or with lens if it works (or if i get it to work). but just out of curiosity, what if we also wanted to write this as a library, and to allow user to write new type of ads
22:05:12 <xenon-> how would one do that?
22:05:50 <Koterpillar> typeclasses plus a lot of higher rank types?
22:06:22 <Koterpillar> if a user supplies the ad type, you can't use it in the library though
22:06:43 <Koterpillar> i.e. what you see is just an opaque value
22:06:48 <xenon-> in OOP library would define baseAd, then user would inherit that and extend it
22:07:19 <Koterpillar> but you can't call anything on the instances that baseAd doesn't have
22:08:39 <xenon-> you can't if it is really baseAd, you can if it is some other type of ad pointed to by baseAd reference type
22:09:11 <Koterpillar> how would you know _what_ to call though?
22:09:32 <xenon-> try all possibilities?
22:10:21 <xenon-> unless you just want to use it as a generic baseAd, in which case just use baseAd members 
22:10:57 <Koterpillar> this is impossible in languages without reflection
22:11:13 <Koterpillar> e.g. suppose I have defined an ad for cats, with adEyeColor
22:11:15 <xenon-> i don't think C++ has reflection
22:11:29 <Koterpillar> but the base library doesn't call adEyeColor anywhere
22:11:38 <xenon-> java/C# have it, but i think it is possible without reflection as well
22:12:12 <xenon-> Koterpillar not a problem. cast BaseAd to CatsAd
22:12:33 <Koterpillar> no, I mean, at the time you wrote the library, you didn't know adEyeColor was a thing
22:13:04 <xenon-> sure. but why does that matter? 
22:13:31 <Koterpillar> so your library will have zero calls to adEyeColor
22:14:08 <xenon-> user of the library will write CatsAd that inherits inherit from BaseAd. and he can then cast away
22:14:32 <xenon-> there's no reason why a library (that contains generic functions) would use adEyeColor, or know that it will exist in future
22:14:52 <monochrom> What is "inherit"? In Haskell?
22:15:12 <Koterpillar> xenon-: as a compromise, maybe you let the users define the whole AdDetails?
22:15:33 <Koterpillar> xenon-: data Ad details = { adText :: ..., adDetails :: details }
22:16:12 <Koterpillar> this way, the library can access the base attributes, but the users instantiate with the right details, one of the options of which is Cats, and use that
22:16:30 <xenon-> Koterpillar, ok, but then what will findAd in the library return?
22:16:36 <xenon-> just Ad?
22:17:09 <Koterpillar> findAd :: String -> [Ad detials] -> Ad details
22:17:20 <xenon-> oh i get it now
22:17:29 <xenon-> but another problem :(
22:17:56 <xenon-> now Ad RealEstate is different type than Ad Pets
22:18:00 <Koterpillar> nope
22:18:13 <Koterpillar> you have data AdDetails = RealEstate ... | Pet ...
22:18:31 <xenon-> oh
22:19:14 <monochrom> So wait a second, do you need the type variable "details"?
22:19:47 <xenon-> no, yes, maybe? :P
22:19:53 <xenon-> my head is spinning a bit
22:19:56 <Koterpillar> xenon-: what do you want to do?
22:20:06 <Koterpillar> make a library for ad scrapers?
22:20:10 <xenon-> yeah
22:20:20 <xenon-> most of the code is generic
22:20:34 <Koterpillar> and the rest should be extensible?
22:20:43 <xenon-> but i want to support different kind of ads, with different fields, and those different ads also need a little help with scraping
22:20:49 <xenon-> yes
22:20:59 <xenon-> ideally
22:21:30 <xenon-> I also have more than one site
22:21:34 <xenon-> that i want to scrap
22:21:43 <Koterpillar> what I mentioned earlier was
22:22:57 <Koterpillar> make a typeclass and accept [forall a. AdDetails a => a] (not sure if this is the proper syntax)
22:23:27 <xenon-> another issue.. similar ads may be missing some fields in different sites. so what do i do? just return Maybe everywhere?
22:23:56 <xenon-> I was actually temped to go the (String, Maybe IntStringDouble) way.. but that would be horrible
22:23:56 <Koterpillar> if you want that piece of data, and it's not there, then yes
22:24:12 <Koterpillar> if you don't do heavy processing on the values, that's the way
22:24:23 <xenon-> field as String?
22:24:34 <Koterpillar> does your library really need to sort all the ads by CPU?
22:24:41 <Koterpillar> half CPUs are also missing
22:25:36 <xenon-> no. but, sorting real estate ads by location or number of rooms would be useful
22:26:46 <xenon-> so you don't think String for field would be horrible? as a bonus i could dynamically scrap all the data from the table
22:28:05 <Koterpillar> so sorting by anything would be useful then?
22:28:17 <Koterpillar> assuming you can figure out how to clean the data
22:28:33 <xenon-> yeah
22:29:12 <Koterpillar> then you need data Ad = Ad { adText :: ..., adAttributes :: Map String Anything }
22:30:56 <xenon-> that would probably be the simplest way to do it.. i just feel i may be missing the advantage of haskell's type system when i hardcode fields as strings
22:31:23 <Koterpillar> you can't tell what will they be
22:31:35 <Koterpillar> so the type system can't help you either
22:31:46 <Koterpillar> on the other hand, you aren't doing anything with them
22:32:06 <xenon-> i know what it is for the ads i want to currently support. but say, tomorrow, i want to inspect some other ads, i'd have to recompile the program
22:32:39 <xenon-> how would you define Anything?
22:32:42 <Koterpillar> well, if you have to modify the scraper tomorrow, might as well modify the type
22:33:00 <Koterpillar> data Anything = AString String | AnInt Int | ...
22:33:25 <Koterpillar> if you are scraping, then someone will put "five" in number of rooms
22:33:41 <Koterpillar> and tomorrow, it will also contain "Queensland"
22:33:48 <xenon-> thankfully sites i support don't allow that. but good point
22:34:07 <Koterpillar> well, probably not for real estate
22:34:21 <Koterpillar> but computer ads are, ironically, hopeless here
22:34:33 <xenon-> also i worry.. what if the field says "Rooms" now, but "# of rooms" tomorrow.. and i am storing data in database. they will be stored as different fields :|
22:34:44 <kirillow> when do I use cabal instead of stack?
22:35:20 <Koterpillar> kirillow: probably on nixos?
22:35:38 <Koterpillar> kirillow: or otherwise in an environment where dependency conflicts aren't a problem
22:35:38 <kirillow> Uhm?
22:35:48 <kirillow> aah
22:36:04 <Koterpillar> kirillow: I'm assuming you mean cabal-install the CLI tool providing "cabal build", and not "cabal new-build"
22:36:36 <kirillow> yea
22:37:06 <Koterpillar> I've heard "cabal new-build" is like stack now, but haven't tried it
22:38:01 <xenon-> anyway.. thanks for suggestions. going for data Ad = Ad { adText :: ..., adAttributes :: Map String Anything } now for simplicity sake, and ability to support all ads without any extra code
22:56:29 <n_blownapart> anyone use ide-haskell on atom editor ?  I get this error message when opening a file: " the GHC version in your PATH '7.6.3' doesn't match with GHC version used to build ghc-mod '8.0.1'. This can lead to problems when using Cabal or Plain projects
22:59:24 <xenon-> is there any reason to use Map Foo Bar over (Foo, Bar) if I have 20 elements or less?
22:59:47 <sdx23> n_blownapart: well, check your $PATH, ghc and ghc-mod location
23:00:03 <jle`> xenon-: it's a nicer API
23:00:05 <xenon-> over [(Foo, Bar)] even
23:00:14 <jle`> and you don't have to implement a lot yourself
23:00:41 <jle`> also [(Foo, Bar)] is different...it can have duplicates?
23:00:44 <n_blownapart> sdx23, thank you. kindly look at something .....
23:01:43 <xenon-> :t lookup
23:01:45 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:01:56 <xenon-> is there a way to insert values in this datastructure?
23:02:01 <xenon-> built-in insert function
23:02:19 <xenon-> it should work the same as Map's insert
23:02:41 <xenon-> i just assumed there was, since we have lookup
23:02:43 <n_blownapart> https://www.refheap.com/123761  << sdx23   I know this can't be right, be I added all of stack dependencies to my .bashrc.
23:03:39 <n_blownapart> *but
23:04:09 <dmj`> jle`: o/
23:05:14 <xenon-> @hoogle Eq a => (a, b) ->: [(a, b)] -> [(a, b)]
23:05:17 <jle`>  \o
23:05:18 <lambdabot> Control.Lens.Iso curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)
23:05:18 <lambdabot> Control.Lens.Iso uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)
23:05:18 <lambdabot> Graphics.GL.Internal.Shared glTexImage3DFunPtr :: FunPtr (GLenum -> GLint -> GLint -> GLsizei -> GLsizei -> GLsizei -> GLint -> GLenum -> GLenum -> Ptr () -> IO ())
23:05:27 <xenon-> :-O
23:05:29 <jle`> xenon-: (:)
23:05:35 <jle`> :t (:)
23:05:36 <lambdabot> a -> [a] -> [a]
23:05:49 <sdx23> n_blownapart: $PATH should only contain directories. One line of "export PATH=$PATH:/home/john/.local/bin" will be sufficient
23:06:02 <jle`> :t curry (:)
23:06:04 <lambdabot> a -> b -> [(a, b)] -> [(a, b)]
23:06:15 <sdx23> n_blownapart: also, look at the output of "which ghc", "which ghc-mod" and so on
23:06:17 <jle`> xenon-: also, lookup isn't a built-in function
23:06:21 <jle`> it's just a library function :)
23:06:41 <kirillow> in stack: what goes into src/ what goes into app/ (apart from Main.hs)?
23:06:43 <sdx23> n_blownapart: most likely there's another ghc used, that's somewhere "before" in the PATH.
23:07:03 <sdx23> kriztw: src is library, app is programs
23:07:11 <jle`> kirillow: src has library source files, app has executables :o
23:07:34 <xenon-> jle` is there a point in this nitpicking
23:07:40 <xenon-> (:) obviously isn't what i want
23:07:43 <kirillow> thanks
23:07:47 <n_blownapart> sdx23, thanks a lot. please stand by if you have time
23:08:23 * hackagebot jason 0.1.0.0 - A fast JASONETTE-iOS JSON combinator library for haskell.  https://hackage.haskell.org/package/jason-0.1.0.0 (Lupino)
23:09:35 <jle`> xenon-: built-in functions are provided by ghc's api and hook into the compiler, but functions like lookup are just simple utility functions that you could probably write yourself in a line or two
23:09:44 <jle`> xenon-: (:) is the closest thing to what you are looking for
23:09:49 <liste> @src lookup
23:09:50 <lambdabot> lookup _key []                      = Nothing
23:09:50 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
23:09:50 <lambdabot>                         | otherwise = lookup key xys
23:10:05 <liste> that's one way lookup could be implemented
23:10:11 <jle`> > curry (:) "foo" 10 [("bar",11),("baz",12)]
23:10:14 <lambdabot>  [("foo",10),("bar",11),("baz",12)]
23:10:25 <lolisa> hi, can anyone tell me how to do curry in point free style (with SKI, BCKW, fst, snd, (,))? I got stuck for an hour...
23:10:36 <jle`> you could use it uncurried too if that's your style
23:10:46 <n_blownapart> the output of  $ which ghc is /usr/bin/ghc .. sdx23 should that also go in .bashrc ? Usually I can set up an ide / editor without trouble..
23:10:48 <jle`> > (:) ("foo", 10) [("bar",11),("baz", 12)]
23:10:50 <lambdabot>  [("foo",10),("bar",11),("baz",12)]
23:11:12 <jle`> lolisa: do you have a specific question?
23:11:43 <lolisa> Yes, writting curry. So I am developing a dsl, and I had not add variable treatment. Now I want to keep the core definition small
23:12:12 <liste> @pl curry f x y = f (x, y) -- lolisa
23:12:12 <lolisa> and use it to derive curry, uncurry, etc. I am having no problem with most def, except curry...
23:12:12 <lambdabot> curry = (. (,)) . (.)
23:12:44 <lolisa> wow, thx
23:13:26 <sdx23> n_blownapart: nah, which outputs the one which is used (hrhr). So your problem is: you added the path at the end, echo $PATH will tell you /usr/bin comes before, so the ghc installed by your package manager (apt or whatever) comes first and is used.
23:13:49 <lolisa> now I am really sad that I spent hours doing point free by hand... :( at least I dont have to do it anymore
23:13:57 <jle`> xenon-: you could 'nubBy' after you (:) if you want to enforce one value per key
23:14:05 <jle`> but, at that point, you're better off just using Map
23:14:15 <jle`> it's better to use a type that enforces the invariants that you want
23:14:34 <jle`> instead of hacking a type that doesn't enforce the invariants
23:14:37 <xenon-> jle` you are right, i'll just use Map. thanks
23:14:44 <jle`> that's definitely a strong principle of Haskell
23:14:50 <jle`> let your types enforce your invariants
23:15:00 <jle`> otherwise we would just be using 'Double' instad of Bool
23:15:12 <jle`> and trying to manually enforce a variant that they're either 0.0 or 1.0 :p
23:15:30 <jle`> *invariant
23:15:35 <sdx23> n_blownapart: if you work with stack, look here https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
23:16:36 <sdx23> actually, if you're editing a file of a stack project, this may be a bug in ghc-mod
23:18:32 <n_blownapart> sdx23 yeah, somethings funky. I just wanted the hover over and get the type feature. do I need stack and all that? I'm just starting to learn haskell after scheme and the sicp nightmare. 
23:19:20 <sdx23> n_blownapart: well, from .local/bin I was guessing you used stack to install ghc-mod. Stack used it's "own" ghc, which is not on the PATH
23:20:01 <n_blownapart> yeah I used stack sdx23  . how to get it to recognize the correct ghc directory?
23:20:11 <sdx23> stack path # will show you. You may just add that directory to (the beginning of) PATH, even though that's not the cleanest of solutions
23:22:12 <n_blownapart> sdx23, huge output there. still wondering, do I need stack and all these dependencies to get the hover-over-for-types feature in ide-haskell ?
23:23:46 <sdx23> n_blownapart: for that thing you need ghc-mod, and ghc-mod requires you to use the ghc version itself was built with. You could install ghc-mod via the package manager also
23:24:11 <sdx23> then which ghc-mod will tell you /usr/bin/ghc-mod is used, and that one fits to /usr/bin/ghc
23:24:49 <n_blownapart> oh so no need to mess with .bashrc ? 
23:24:53 <n_blownapart> sdx23, 
23:26:03 <MarcelineVQ> personally I add ~/.local/bin to my .bash_profile this is the directory stack will place things if you do something like: stack install ghc-mod
23:26:27 <MarcelineVQ> It's not where you'd find ghc and such though, just things from 'install'
23:27:22 <n_blownapart> MarcelineVQ, oh put this in there?  export PATH=$PATH:/home/john/.local/bin/
23:27:34 <sdx23> MarcelineVQ: and exactly this is the problem. His ghc-mod is from there, but the system ghc is too old for it.
23:28:18 <n_blownapart> sdx23, quick fix then: just get rid of this stack business and install the ghc-mod plugin in the conventional way?
23:29:02 <n_blownapart> btw I updated atom as per suggestion in a blog
23:30:47 <sdx23> n_blownapart: for the start apt install ghc-mod should do. At some point you'll want a newer ghc version and use stack then anyways.
23:30:57 <MarcelineVQ> Just recently I've been having issues with ghc-mod myself that haven't been solved by ensuring the versioning matches up. Typically when version mismatches occur I've just matched the lts resolver versions for building ghc-mod and the project I'm on but that's not working currently. Not sure where the problem really is.
23:32:55 <mstruebing> is it possible to load a file into ghci while calling the ghci? liks so: `stack ghci myHaskellFile.hs`
23:33:57 <sdx23> mstruebing: should. Maybe stack messes with your options, then insert --
23:35:06 <mstruebing> it always says │Error parsing targets: Directory not found: myHaskellFile.hs
23:36:46 <MarcelineVQ> it's a little weird, you need to use `stack exec ghci filename.hs` or `stack ghci --ghci-options filename.hs` not sure if that's intended
