00:01:05 <hololeap> and is there a good universal way to make a single step list in either direction (e.g. [0 .. x] works only when x is positive)
00:07:41 * hackagebot XSaiga 1.5.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.5.0.0 (InBetweenNames)
00:07:41 * hackagebot markdown 0.1.16 - Convert Markdown to HTML, with XSS protection  https://hackage.haskell.org/package/markdown-0.1.16 (MichaelSnoyman)
00:10:11 <lyxia> hololeap: you must specify the step explicitly.
00:10:49 <hololeap> lyxia: right, but i don't know if x is going to be positive or negative and so i don't know which way to step
00:12:51 <hololeap> i guess there is this solution: step f t = [f, f + signum (t - f) .. t]
00:13:01 <hololeap> seems kinda clunky though
00:13:16 <lyxia> > [0, -1 .. -5]
00:13:18 <lambdabot>  [0,-1,-2,-3,-4,-5]
00:15:18 <lyxia> I suppose they could have chosen not to repeat the first element
00:20:31 <noze> can haskell-mode generate a case tree for a datatype? (the way you can "split an expression" in Agda)
00:29:16 <jedai> noze: I think ghc-mod can
00:36:37 <ertesx> hololeap: if you don't mind additional constraints you could do [min x y .. max x y]
00:36:37 <circ-user-QJY8M> Does State a s contain both a and s data items or it contains only s -> (a,s) function?
00:37:03 <ertesx> circ-user-QJY8M: a (State s a) *is* a function of type (s -> (a, s))
00:37:31 <circ-user-QJY8M> I can understand Just a. It contins item a, which you can bind to another Just b. But I do not wrap my head around the State monad.
00:38:12 <ertesx> circ-user-QJY8M: before you try to understand the state *monad*, first try to understand the type…  are you defining it yourself?
00:52:36 * hackagebot mysql-haskell 0.7.1.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.7.1.0 (winterland)
01:12:37 * hackagebot directory 1.2.7.1 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.7.1 (Rufflewind)
01:21:36 <jle`> circ-user-QJY8M: the 'State' type is just a newtype wrapper over a function
01:21:40 <jle`> a function (s -> (a, s))
01:21:53 <jle`> oh i'm a little late
01:22:18 <circ-user-QJY8M> ok. I see that you can still get a by calling the func
01:22:37 * hackagebot jose 0.5.0.1 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.5.0.1 (frasertweedale)
01:26:57 <sdx23> circ-user-QJY8M: given an initial state; this is exactly what evalState does
01:37:38 * hackagebot heterocephalus 1.0.0.1 - A type safe template engine for collaborating with front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.0.1 (arowM)
01:52:38 <circ-user-QJY8M> In  2 m >>= k = State $ \s -> let (a, s') = runState m s  \n  in runState (k a) s', I understand that m and k are given to the bind function and new State is created from (k a) s'. But, what is State \s? Is it another monad?
01:53:01 <circ-user-QJY8M> Where is third state  monad is coming from?
01:54:48 <ongy> State is the constructor for the type, and the \s -> [..] is the argument lambda
02:01:13 <circ-user-QJY8M> That is trivial. I am asking concretely, which object is received/constructed  in State \s?
02:02:41 <jle`> circ-user-QJY8M: can you upload what you're looking at online, on lpaste maybe?
02:02:56 <jle`> it looks like something is being misformatted
02:03:04 <pavonia> circ-user-QJY8M: It's a new State value, made of the results of running the old ones
02:03:18 <circ-user-QJY8M> It is from here http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused
02:03:25 <jle`> unless you're just missing a $ after runSate m s
02:03:37 <jle`> oh i see
02:03:42 <erisco> can I use hexadecimal literals in GHC?
02:03:46 <jle`> the \n isn't suppose dto be there
02:04:00 <pavonia> erisco: Yes, 0xFC
02:04:04 <jle`> circ-user-QJY8M: do you see the type of (>>=) ?
02:04:07 <erisco> thanks
02:04:21 <jle`> circ-user-QJY8M: (m >>= f) returns a State s b
02:04:28 <jle`> circ-user-QJY8M: so, how do you make a State s b?
02:04:28 <erisco> are there binary literals?
02:04:46 <pavonia> erisco: There's an extension for that
02:04:46 <jle`> circ-user-QJY8M: by providing a (s -> (b, s)) function
02:05:03 <pavonia> -XBinaryLiterals, presumably
02:05:20 <jle`> circ-user-QJY8M: (>>=) :: State s a -> (a -> State s b) -> State s b
02:05:31 <jle`> so the result is a new value of type 'State s b'
02:05:58 <jle`> the 'm' is 'State s a', the 'k' is (a -> State s b)
02:06:05 <jle`> and the resutlt is a 'State s b'
02:06:23 <jle`> and that's exactly what (State $ \s -> ...) is
02:06:29 <jle`> it's a value of type State s b
02:06:53 <circ-user-QJY8M> Ok, this is what we produce. Thanks.
02:07:36 <jle`> yup.  (>>=) takes a `State s a` and a `a -> State s b`, and returns a `State s b`
02:07:43 <jle`> btw, monads aren't values
02:07:51 <jle`> you can't return a monad/create a monad
02:08:09 <jle`> there is no 'third state monad'
02:08:14 <jle`> they're all just values
02:08:20 <jle`> values of type 'State s a', 'State s b', etc.
02:08:38 <jle`> there's only one Monad at play here, and that's the *type* 'State s'.
02:08:50 <jle`> just mentioning this because you're going to confuse a lot of people of you call values 'monads'
02:09:15 <jle`> most people would not understand what you're asking :)
02:09:25 <Maxdamantus> well, is it the type, or is it the instance?
02:10:14 <jle`> i think the capital-m Monad in haskell refers to the type
02:10:56 <jle`> hm
02:11:04 <jle`> maybe it's more correct to say that 'State s' is a Monad instance
02:11:16 <jle`> in any case, nobody would be confused if you called 'State s' a Monad
02:11:17 <Maxdamantus> but the Monad (State s) is what is defined when you write `instance Monad (State s)`
02:11:54 <Maxdamantus> ie, the monad for State s (for any s)
02:12:08 <jle`> yeah. but you wouldn't call Bool an Ord
02:12:12 <jle`> you'd call it an Ord instance
02:12:32 <Maxdamantus> Ord Bool is the Ord instance for Bools.
02:13:20 <jle`> i'm not sure where we're disagreeing here
02:13:52 <Maxdamantus> Well, I wouldn't call Bool an Ord instance if I were trying to be accurate.
02:14:04 <jle`> but in any case, calling 'State s' a Monad might not be technically correct (?), but it's definitely something where poeple would understand what you're saying without any ambiguity
02:14:09 <jle`> Maxdamantus: ah, i see.
02:14:45 <e> State s has a Monad instance, which is about all the useful meaning i think "a Monad" is likely to have
02:14:51 <jle`> but, how would you explain the type of a function like Ord a => a -> a -> Bool ?
02:15:12 <circ-user-QJY8M> I came from Scala where everything is an object and certain objects conform to certain interfaces by implementing necessary methods, like Option[A] is a Maybe monad and I can have nstances of that option.
02:15:22 <Maxdamantus> I'd want to describe it as a polytype.
02:15:31 <Maxdamantus> and it's not a function.
02:15:45 <jle`> i mean, it takes two values of the same type that are instances of Ord
02:15:56 <e> are you saying it's not a function because it is the type of a function?
02:15:58 <jle`> *the type of a function whose type is
02:16:09 <e> that seems excessive
02:16:26 <jle`> circ-user-QJY8M: yeah.  in Haskell, it's a bit different, so you might confuse people if you call values of *type* 'Maybe Int' as a Maybe monad
02:16:40 <Maxdamantus> e: it's not a monotype so there can't be a function that has that type.
02:17:12 <Maxdamantus> values in Haskell are monomorphic.
02:17:12 <jle`> circ-user-QJY8M: especially when you say something like "create a new monad", it sounds like you're defining a new Monad instance
02:17:25 <jle`> circ-user-QJY8M: instead of creating a new value
02:17:32 <jle`> just a heads up :)
02:17:32 <circ-user-QJY8M> I see.
02:17:55 <jle`> i understand there is a lot of weird vocabluary that's overlapping in all the wrong ways between scala/java and haskell
02:18:13 <e> Maxdamantus: ok, a function type
02:18:21 <jle`> instance in haskell means something completely different in scala/java, so that's kind of weird too heh
02:18:39 <jle`> er, i mean, the word 'instance' imeans completely different things in haskell and scala/java
02:19:00 <Maxdamantus> e: it's a polytype where all types derived from it happen to be functions.
02:19:19 <Maxdamantus> e: is `Monad m => m Int` a function?
02:19:52 <e> there can be more than one important thing about a type
02:22:40 * hackagebot polar-shader 0.3.0.0 - High-level shader compiler framework  https://hackage.haskell.org/package/polar-shader-0.3.0.0 (Shockk)
02:22:51 <Maxdamantus> "instance" doesn't really mean something completely different. It relates to class in pretty much the same way in either language.
02:23:01 <Maxdamantus> class just happens to be different.
02:23:34 <e> you can play that either way around
02:24:09 <e> (class means "thing you can have instances of" in either language, instance just happens to be different)
02:24:19 <ertes> circ-user-QJY8M: haskell uses much of the same terms that OOP uses, but for entirely different things…  in fact i can't think of a single term that means the same thing…  so until you get used to it, i recommend that each time you hear a new term in a haskell context, repeat to yourself five times: "this is not OOP!"
02:24:26 <Maxdamantus> Heh, I guess so.
02:24:41 <Reisen> In which cases can type constructors be promoted without requiring ' ?
02:24:58 <ertes> Reisen: in the cases when they are unique
02:25:10 <tdammers> ertes: true. this is particularly unfortunate in those rare cases where you do OOP in Haskell
02:25:15 <erisco> classes are not types, instances are not objects (values)
02:25:34 <erisco> both are quite different
02:25:37 <Reisen> ertes, thanks, just occurred to me then that my errors are because of -Wall/-Werror
02:25:45 <ertes> and classes are not interfaces either
02:26:01 <erisco> interfaces are types, and classes are not types
02:26:15 <tdammers> wow, this conversation confuses me
02:26:21 <erisco> you need existential type classes, then they are :3
02:26:37 <e> maybe we should start attaching domain prefixes to words
02:26:55 <ertes> tdammers: OOP in haskell?  sounds like a lot of engineering work =)
02:27:27 <e> you'd think compsci would be the field most able to produce a uniquely decodable lexicon
02:27:35 <e> so i wonder why we are so bad at it
02:28:41 <ertes> e: i'd question whether there are even countably many meanings of "product" in mathematics =)
02:28:51 <Maxdamantus> Does Haskell have any mutable hashes?
02:29:02 <e> ertes: haha, fair enough
02:29:30 <ertes> e: since haskell is inspired by math, it probably took some of the bad habits as well, although we can't exactly be blamed for OOP language designers to reuse *our* words =)
02:30:23 <ertes> Maxdamantus: hashes?  hash tables?
02:32:00 <schoppenhauer> hi. does using the exception monad consume stack space (binding is recursive, after all), or will haskell collapse the calls automatically?
02:38:48 <liste> @hackage hashtables -- Maxdamantus 
02:38:48 <lambdabot> http://hackage.haskell.org/package/hashtables -- Maxdamantus
02:39:33 <John[Lisbeth]> is it possible to implement a linked list that will accept anything of any type?
02:40:06 <bartavelle> John[Lisbeth], you can write nested tuples which would be a low-tech way to approach that problem
02:40:09 <ertes> liste, Maxdamantus: the hashtables library has terrible performance though…  it hardly performed better than a pure algorithm with HashMap for me
02:40:14 <Maxdamantus> I was just joking about how people refer to hashtables/maps as "hashes".
02:40:29 <Maxdamantus> which seems like referring to electron microscopes as "electrons".
02:40:40 <bartavelle> John[Lisbeth], then there is this : https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Dynamic.html and https://hackage.haskell.org/package/HList
02:40:57 <Maxdamantus> electron microscopes are microscopes that use electrons, just as hash tables are tables that use hashes.
02:41:30 <ertes> and as milk bottles are bottles that use milk
02:41:47 <Maxdamantus> they're bottles, yes. They store milk.
02:41:51 <ertes> couldn't resist =)
02:44:29 <jchia1> is it possible to export  a algebraic data type with its constructor(s) but without exporting the field accessors?
02:45:12 <athan> jchia1: Yep! `module Foo (Foo (Foo)) where...` with `data Foo = Foo {someHiddenField :: ...}`
02:45:22 <athan> maybe too many Foos :)
02:45:25 <jchia1> athan: Thanks
02:48:21 <lyxia> schoppenhauer: are you talking about ExceptT
02:48:29 <lyxia> I think it does consume stack space
02:50:00 <schoppenhauer> lyxia: yes. I do. well, actually, I use maybe, but that is similar. the problem is that I do stream processing, and therefore I get a stack frame for every byte …
02:50:18 <schoppenhauer> lyxia: what would be the method of choice, if I really wanted to do it lazily (as opposed to, say, using iteratees)
02:50:35 <jchia1> what was that mass entering?
02:50:45 <schoppenhauer> lyxia: (I know that iteratees would be the better choice for what I do, but the codebase is too large to change it now)
02:50:50 <schoppenhauer> jchia1: I think it was a netsplit
02:51:46 <jchia1> schoppenhauer: Yeah, all from matrix.org
02:52:00 <Maxdamantus> It seems to be some sort of alternative distributed chat system.
02:52:23 <Maxdamantus> but they have lots of clients on Freenode as a bridge between IRC and their system.
02:52:57 <oisdk_> I'm having some trouble getting -XGeneralizedNewtypeDeriving to work with -XRankNTypes. Is there a way to get something like this to work? https://gist.github.com/oisdk/c952655a700b22b6299f07f97feccb59
02:58:28 <lyxia> schoppenhauer: So using a continuation passing style transformer would work I think. Codensity from the kan-extensions package does that in a general way.
03:00:22 <lyxia> schoppenhauer: ExceptT e m a = ExceptT { runExceptT :: forall r. (e -> m r) -> (a -> m r) -> m r }
03:02:08 <lyxia> oisdk_: unfortunately not
03:05:00 <lyxia> oisdk_: While FreeMonoidType can be used in any context like a monoid, it is technically not an instance of Monoid, which is what GeneralizedNewtypeDeriving requires.
03:06:22 <oisdk_> lyxia Ah, that's a pity. Thanks anyway!
03:06:56 <lyxia> GeneralizedNewtypeDeriving might be extended to support a use case like this but I think that requires non-trivial modifications.
03:09:16 <lyxia> The dictionary passing seems tricky to handle though.
03:12:05 <schoppenhauer> lyxia: what is that?
03:13:47 <lyxia> schoppenhauer: That's an alternative definition of ExceptT where (>>=) takes no stack space.
03:14:53 <schoppenhauer> lyxia: where is it defined?
03:15:11 <lyxia> only here on IRC
03:15:50 <schoppenhauer> lyxia: ok, I am not sure how to define runExceptT then, from the type signature (it's not apparent to me currently, sry)
03:17:09 <lyxia> schoppenhauer: runExceptT (ExceptT f) = f (return . Left) (return . Right)
03:21:09 <schoppenhauer> lyxia: I see, thx
03:38:15 <ertes> oisdk_: if you define your free monoid type directly, it becomes a monad, too
03:38:51 <ertes> oisdk_: newtype FreeMonoid a = FreeMonoid { runFreeMonoid :: forall r. (Monoid r) => (a -> r) -> r }
03:39:07 <ertes> so you may want to do that anyway
03:46:49 <malthe> Invoking ghci with a module, I get: "Failed to load interface for 'IO'".
03:47:43 * hackagebot dom-parser 0.1.0 - Simple monadic DOM parser  https://hackage.haskell.org/package/dom-parser-0.1.0 (typeable)
03:49:22 <malthe> but it's there in base-.../System/IO.hi
03:55:51 <pavonia> malthe: What is the module you are importing?
03:57:12 <malthe> pavonia: pavonia PPrint
03:57:33 <malthe> errr sorry, import IO           -- (Handle,hPutStr,hPutChar,stdout,openFile,hClose)
03:57:50 <malthe> just base system modules
03:57:57 <pavonia> The module name is System.IO
03:58:14 <malthe> this is on mac os, and they're all dyn_hi libs that are somehow not found or linkable
03:59:11 <malthe> oh nice. is that new with ghc 8?
04:00:07 <malthe> how do I not load <$> from Prelude, since it's redefined in this module
04:00:25 <pavonia> I can't remember this module was ever called other than System.IO
04:00:49 <pavonia> You can qualify it like Prelude.<$>
04:00:51 <oisdk_> ertes I was hoping to use Cont to define a bunch of free constructions (semiring, etc) with newtypes. 
04:01:15 <malthe> pavonia: I want the opposite - this module defines its own <$> but it clashes with the already-loaded symbol from the prelude.
04:01:39 <pavonia> Then YourModuleName.<$>
04:01:57 <pavonia> or import <$> from Prelude qualified
04:02:16 <malthe> ""import IO" is obsolescent, and recent Ubuntu went with a GHC that
04:02:17 <malthe> deprecated it unless you ask for strict Haskell '98 compatibility.  So you
04:02:17 <malthe> can do that ("-package haskell98"), or you can use the modern name ("import
04:02:19 <malthe> System.IO").
04:02:42 <malthe> I guess it's just a deprecated import name.
04:03:02 <oisdk_> Btw, is there a name for the `newtype FreeSomething a = Free { runFree :: forall s. Something s => (a -> s) -> s }` pattern for constructing free things from their typeclasses? I've heard it described as the "initial" encoding, but I'm not sure if that's correct.
04:10:08 <aspiringNoob> hey guys, might be a stupid question, but when I'm trying to use a instance of a class I wrote, I get an error about the type I'm using being ambiguous (0 could be int, float, double, etc)
04:11:36 <pavonia> It doesn't seem to know which class instance to choose because of the ambiguity
04:12:46 <aspiringNoob> Ah I actually found it as soon as I ask here for help ofc, I just need to put :: (Integer, Integer) when instantiating
04:17:45 * hackagebot open-union 0.2.0.0 - Extensible, type-safe unions.  https://hackage.haskell.org/package/open-union-0.2.0.0 (BenFoppa)
04:22:27 <kuribas> > (`runCont` id) $ callCC $ \exit -> foldlM (\a e -> if even e then exit (a+e) else return (a+e)) 0 ([1, 5, 13] ++ [2..])
04:22:30 <lambdabot>  21
04:22:36 <quchen> Is there a way to collapse anything in Haddock documentation persistent over reloads?
04:22:45 * hackagebot xml-isogen 0.1.0 - Generate XML-isomorphic types  https://hackage.haskell.org/package/xml-isogen-0.1.0 (typeable)
04:22:54 <quchen> Do I really have to browse Haddock in incognito mode?
04:23:00 <ertes> oisdk_: well, it's pretty much just "Free"
04:23:23 <ertes> oisdk_: Free :: (* -> Constraint) -> * -> *
04:23:38 <ertes> like Free Monoid or Free Semigroup
04:23:47 <Marqin> is there some Set or Map that doesn't need a to be Ord, but just Eq?
04:23:54 <Marqin> in stdlib
04:24:20 <ertes> oisdk_: the problem is that "Free" is generally used for free monads
04:24:28 <ertes> Marqin: []
04:24:50 <kuribas> > foldr (\e cont a -> if even e then (a+e) else cont (a+e)) id ([1, 5, 13] ++ [2..]) 0
04:24:53 <lambdabot>  21
04:26:07 <merijn> Marqin: Not really, how would you expect set/map operations to be efficient without Ord?
04:26:48 <merijn> Marqin: You could use [] as suggested, but that means things like "member" become O(n) instead of O(log n), same for lookups, etc.
04:27:01 <Marqin> merijn: i don't expect it to be efficent
04:27:05 <merijn> Although, I suppose insertion becomes cheap :)
04:27:24 <merijn> Marqin: What are you actually needing to store? And why doesn't it/can't it have an Ord instance?
04:27:30 <ertes> Marqin: what type could possibly only have Eq, but no Ord?
04:27:43 <merijn> ertes: Well, there's a bunch in Base already :)
04:27:46 <kuribas> Marqin: You can use set operations on list.
04:27:56 <kuribas> Marqin: but there is no good reason to.
04:28:13 <kuribas> Marqin: If you don't have an Ord instance, use a newtype wrapper.
04:28:17 <merijn> ertes: Notably, MVar, Chan, and essentially anything that's Ptr based internally :)
04:28:38 <Marqin> i've to work on "Eq a => a" type
04:28:49 <Marqin> but ok, i'll make it on just lists
04:28:51 <ertes> merijn: sure, but those aren't Ord pretty much because they have no Ord instances =)
04:29:10 <merijn> ertes: That's what I thought, but what would your order them by>
04:29:21 <kuribas> Marqin: why "have to"?
04:29:56 <merijn> ertes: And if you say "pointer value!", like I did, then I can disappoint you (like I was disappointed) that that doesn't actually work :\
04:29:58 <ertes> merijn: if all else fails by some unique number as for example generated by Data.Unique
04:30:24 <ertes> merijn: there is a new* operation for all these things after all
04:30:29 <Marqin> kuribas: i was given signatures of functions that have to do stuff on graphs
04:30:30 <merijn> ertes: Right, but now you bottleneck the generation of all of them by going through a single unique number queue :p
04:30:59 <kuribas> Marqin: homework?
04:31:01 <ertes> merijn: yeah, i know what you mean, although it's really a problem of the way unique numbers are generated, and it could be fixed =)
04:31:34 <kuribas> Marqin: I doubt adding Ord is a problem...
04:31:41 <ertes> merijn: if unique identifiers would have the generating thread id encoded in them, this wouldn't have to be the case
04:32:01 <merijn> ertes: Assuming thread id's never repeat... ;)
04:32:11 <merijn> Which isn't guaranteed, currently, afaict
04:32:24 <Marqin> kuribas: yeah
04:32:26 <ertes> merijn: then guarantee it =)
04:33:17 <kuribas> Marqin: then either use list, or argue with your proffessor that adding Ord makes it more efficient :)
04:36:42 <Marqin> kuribas: it's written explicitely to not care about efficency here
04:37:23 <kuribas> Marqin: in that case use list operations https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#g:20
04:44:08 <mroman> Is (replicateM (toInt n) ls) space leaky?
04:44:23 <mroman> My program accumulates memory I don't think it should have to.
04:45:57 <BernhardPosselt1> hi, any category theory book that you can recommend for programmers?
04:46:02 <kuribas> mroman: hard to say without context
04:46:11 <mroman> well
04:46:23 <mroman> length $ replicateM 32 "10"
04:46:27 <mroman> ^- out of memory
04:47:06 <merijn> BernhardPosselt1: Depends on the goal, if it's for curiosity's sake/liking abstract math, then Bartosz' blog series, Pierce's book (CT for Computer Scientists) and Awodey's "Category Theory" are pretty good.
04:47:14 <mroman> so probably replicateM needs results from the last step to calculate next
04:47:31 <merijn> BernhardPosselt1: If the goal is "become better at (understanding) Haskell", then my advice would most likely be "don't bother with CT, there's more useful stuff"
04:47:36 <mroman> which means I gotta look for a better way to calculate combinations/variations
04:47:40 <kuribas> mroman: you're creating a list of 2^32 (4294967296) elements
04:48:04 <mroman> kuribas: Yes but I unwisely assumed that lazyness will take care of that
04:48:17 <mroman> but I see that this doesn't work with replicateM.
04:48:22 <BernhardPosselt1> merijn: i read about it quite often in all sorts of programming languages blogs and think it would be useful to understand the implications
04:48:28 <kuribas> mroman: perhaps with optimizations on?
04:48:35 <mroman> I have -O3 turned on
04:48:36 <mroman> but no.
04:48:43 <BernhardPosselt1> and terms
04:49:31 <mroman> maybe replicateM needs the intermediate results because it just appends values in every step
04:49:39 <kuribas> mroman: yeah
04:49:50 <kuribas> mroman: for the list monad
04:50:22 <merijn> BernhardPosselt1: If it's about interest or better understanding of programming languages and blogs I would probably recommend picking "Types and Programming Languages" (by Pierce, mostly about type theory, type checking, etc.) and "Software Foundations" (co-written by Pierce, focusses on proving properties about programs and formal verification of their behaviour)
04:51:12 <merijn> BernhardPosselt1: Which I personally found more useful, only recently have I reached the point where I get stuck without CT :) In which case, see the previous recommendation of Bartosz' blog, Awodey, etc.
04:51:24 <mroman> so I need something that generates variations as a list but can do so "streamingly" 
04:51:48 <BernhardPosselt1> merijn: thanks, will take a look :)
04:51:58 <lpaste> kuribas pasted “quiz” at http://lpaste.net/344419
04:52:08 <merijn> @where sf
04:52:08 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
04:52:08 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
04:52:17 <kuribas> quiz: which one of test1, test2, test3 is the fastest?  http://lpaste.net/344419
04:52:48 <merijn> BernhardPosselt1: Incidentally, TaPL is excellent if you have a practical interest in programming languages (i.e., you want to implement one), because it comes with example implementations of all the type checkers discussed in the book :)
04:53:36 <malthe> pavonia: thx for your help - got everything working now (https://github.com/malthe/hmf)
04:53:56 <kuribas> (you probably get it wrong)
04:54:07 <kuribas> I did ...
04:54:08 <merijn> kuribas: Won't your results get biased because the first benchmark constructs the list 'l', saving the others work?
04:54:17 <kuribas> merijn: no, it checked it
04:54:27 <kuribas> merijn: the order didn't really change the results
04:54:55 <merijn> kuribas: Is it test3?
04:55:06 <kuribas> merijn: test2!
04:55:12 <merijn> Drat, my initial guess
04:55:31 <merijn> But then I figured '3' was forcing it by using even, but I forgot so was 2
04:55:33 <lpaste> kuribas annotated “quiz” with “quiz (annotation)” at http://lpaste.net/344419#a344421
04:56:09 <ertes> BernhardPosselt1: to learn category theory basics (and only basics) i found this lecture series good, although it does tend to give you the impression that there are no infinities: https://www.youtube.com/playlist?list=PLm_IBvOSjN4zthQSQ_Xt6gyZJZZAPoQ6v
04:56:28 <kuribas> merijn: strange isn't it?
04:56:36 <merijn> kuribas: Why?
04:56:48 <kuribas> I'd expect the explicit loop to be faster
04:57:47 <kuribas> merijn: or is it making thunks?
04:57:48 <merijn> kuribas: Well, if 'l' gets inlined into 'test2' then I can see fusion kicking in, removing the entire list allocation, resulting in a tight loop that GHC can easily unbox
04:58:17 <merijn> kuribas: So then you have a tight unboxed loop on Int#, which seems trivial to get fast.
04:58:20 <absence> i was watching bartosz milewski's videos on category theory, and i remember one of them talked about what makes something "strong", but i've forgotten which video it was, and what was said. anyone know?
04:58:30 <merijn> kuribas: The others are more complicated to transform that way
04:58:58 <merijn> kuribas: But that's just speculation, can't tell without inspecting the core
04:59:22 <kuribas> merijn: so I should try with a large random list?
04:59:54 <merijn> Not sure the randomness will get rid of that
05:00:17 <merijn> Also, the random list generation might end up dominating the runtime
05:01:00 <merijn> kuribas: Anyway, my explanation is: With my understanding test2 looks like it's by far the simplest for GHC to optimise/inline, therefore it's not particularly odd for it to be fast :)
05:02:52 <kuribas> merijn: adding seq to test3 seems to speed it up considerably.
05:02:54 <lpaste> kuribas annotated “quiz” with “quiz (annotation)” at http://lpaste.net/344419#a344424
05:04:06 <kuribas> weird, the time for test1 has gone done
05:04:58 <MarcelineVQ> should make sure you're sharing the list with an env or a let 
05:05:13 <merijn> kuribas: Welcome to the amazing world of (micro)benchmarking :)
05:05:51 <kuribas> merijn: it's seems the difference is -O vs -O2
05:06:21 <merijn> kuribas: Not sure what exactly the difference is between those, but I think -O2 inlines more?
05:07:13 <kuribas> merijn: yeah, I guess so
05:08:19 <lpaste> kuribas annotated “quiz” with “quiz (annotation) (annotation)” at http://lpaste.net/344419#a344425
05:08:22 <merijn> kuribas: tbh, my own experience with benchmarking makes me predict it'll take you at least 2 days to a week to figure out all possible things that could trip up your benchmark and finally get a reliable one that says which of the 3 is fastest. And then someone comes up with 2 lines of gibberish that for some obscure reason is even faster ;)
05:09:14 <kuribas> merijn: I find it quite amazing that with O2 the continuation passing ones are as fast as the unrolled loop.
05:09:38 <merijn> kuribas: Have you had a look at the Core for different versions?
05:09:44 <kuribas> no
05:09:56 <merijn> That's the only real way to figure out what GHC is doing to make them faster/different
05:12:28 <kuribas> merijn: I would have thought that CPS would make it slower
05:14:29 <ertes> GHC loves CPS
05:14:49 <ertes> at least for the most part =)
05:14:49 <merijn> Every compiler loves CPS
05:14:58 <merijn> That's why SSA exists
05:15:54 <ertes> every compiler loves CPS, but GHC is serious about the relationship =)
05:17:45 <kuribas> hmm "ghc: unrecognised flag: -fext-core"
05:18:23 <ertes> kuribas: -ddump-simpl -ddump-to-file, and most likely -dsuppress-all
05:32:48 * hackagebot system-info 0.1.0.3 - Get information about CPUs, memory, etc.  https://hackage.haskell.org/package/system-info-0.1.0.3 (dtaskoff)
05:55:08 <squall_> Hi, im trying to rewrite some instances for list using noImplicitPrelude and it complains... can someone tell me how to write infix datatypes?
05:55:09 <squall_> http://lpaste.net/344437
05:56:53 <squall_> i dont think it likes "data [a] = [] | a:[a]"
05:57:11 <squall_> complaining that; "Malformed head of type or class declaration: [a]"
05:58:32 <lyxia> I don't think you can rebind this built-in syntax.
05:58:34 <MarcelineVQ> [] uses magical syntax there
05:59:35 <squall_> its important for my presentation that im able to do this, is there a resource that would explain this "magic" or would you be able to explain that to me now?
06:01:15 <Boomerang> I actually think (:) and [] are not even implemented in Prelude, if you load ghci with :set -XNoImplicitPrelude (:) and [] are still defined
06:01:43 <squall_> omg
06:01:58 <squall_> crazy times
06:01:58 <Boomerang> Just give them other names: data List a = Empty | a :# List a
06:02:10 <squall_> ok
06:06:25 <squall_> hmm, i still get an error...
06:06:26 <squall_> http://lpaste.net/344440
06:08:54 <Clint> squall_: that seems legit
06:09:15 <squall_> pardon?
06:09:52 <Clint> squall_: the error
06:10:07 <lyxia> instance Functor List where   <- no "a"
06:11:24 <squall_> commenting out the instances does not improve the situation
06:11:32 <cloudhead> is it possible to have a function with a :: MonadError e m => m () type which can throw/catch exceptions of several types?
06:11:35 <Clint> squall_: because of your class definition
06:11:38 <cloudhead> I'm having trouble getting it to work
06:12:24 <squall_> can you be more explicit?
06:13:23 <Clint> what is the purpose of this exercise?
06:13:43 <squall_> no time to answer tha
06:13:46 <squall_> that
06:13:48 <squall_> sorry
06:14:01 <Clint> ah
06:14:02 <squall_> im constructing a presentation
06:15:18 <lyxia> cloudhead: do you mean that the same action can throw/catch errors of multiple types for a fixed type m?
06:15:43 <lyxia> cloudhead: that contradicts the functional dependency MonadError has.
06:15:46 <cloudhead> lyxia: yeah I think so
06:16:02 <cloudhead> lyxia: I see.. so does that mean I'd have to use a sum type of all the errors?
06:16:06 <lyxia> right
06:16:31 <cloudhead> lyxia: cool, thanks
06:17:51 <squall_> ah, i see the problem, thanks
06:17:52 <squall_> http://lpaste.net/344443
06:18:20 <squall_> ill fill out those instances and then ask about the question in the comment at the top
06:21:51 <Boomerang> squall_: I think you don't need the (Monad m) constraint in your join function, the constraint is already given by the class. Also since you're not using Prelude you will have to define id and (.) yourself
06:24:59 <squall_> indeed...
06:25:29 <squall_> also having trouble since Applicative and Monad use paralell list generators...  eg    xs >>= f             = [y | x <- xs, y <- f x]
06:25:49 <squall_> i guess i can use build, but its not so intuative for presentation purposes
06:28:10 <squall_> and also i think for extract i need non empty lists...
06:29:21 <yulax> i have a problem
06:29:47 <yulax> i used cabal to install the time package, thinking it wasn't already present (silly, yes)
06:30:06 <yulax> and now i get conflicts when i load a function that makes use of time
06:30:15 <yulax> how can i remove a cabal package?
06:30:46 <tdammers> yulax: you can't. You can unregister it, or you can nuke the entire ~/.cabal
06:31:03 <yulax> that seems rather bad design...
06:31:11 <tdammers> it's honest
06:31:16 <kuribas> or nuke .ghc
06:31:20 <yulax> naw
06:31:27 <yulax> i'll nuke cabal
06:31:37 <tdammers> might have to nuke both
06:31:44 <hvr> poor ghc & cabal
06:31:48 <tdammers> anyway, this is something haskell has been struggling with for a while
06:31:52 <kuribas> yulax: if you nuke .ghc it will rebuild all packages
06:31:59 <squall_> ok, this looks like the best im going to get... http://lpaste.net/344448
06:32:30 <tdammers> the bottom line is, removing individual packages while also guaranteeing consistent dependencies *and* not being able to have multiple versions of the same package installed alongside one another is an impossible problem to solve
06:32:39 <tdammers> so cabal doesn't attempt to do that
06:32:46 <yulax> it is good
06:32:50 * hackagebot IntervalMap 0.5.2.0 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.5.2.0 (ChristophBreitkopf)
06:32:59 <yulax> but i still think it is somewhat annoying
06:33:03 <tdammers> it is
06:33:15 <hvr> ...but ppl are working on it!
06:33:19 <tdammers> but the alternatives are not much better in the end
06:33:19 <yulax> umh... does it download over https?
06:33:35 <yulax> or verify in any way, eg. checksums?
06:33:39 <squall_> so i guess my question is, can i make a datatype which is both a Monad and a Comonad?
06:33:46 <edwardk> sure
06:33:48 <edwardk> Identity
06:33:54 <squall_> is that the only one?
06:33:55 <edwardk> (,) m for m a monoid
06:34:08 <edwardk> (->) m for m a monoid
06:34:19 <squall_> hmm, plenty...
06:34:28 <squall_> but just not List...
06:34:37 <edwardk> data Seq a = a :- Seq a
06:34:52 <edwardk> data Moore a b = Moore b (a -> Moore a b)
06:35:12 <edwardk> the latter two can actually be seen as special cases of the (->) m thing
06:35:22 <edwardk> which m = Nat for the former
06:35:33 <edwardk> and m = [a] for the latter
06:35:37 <edwardk> there are lots
06:35:59 <edwardk> note: the monad structure and the comonad structure don't necessarily have anything to do with one another
06:36:31 <squall_> did you follow my derivation of a comonad instance for Free Zipper earlier in the year?
06:36:38 <edwardk> there are names for some relations they can have though, but they are more common in other categories
06:36:52 <edwardk> i must have missed it
06:37:08 <squall_> ill dig it out one sec
06:37:15 <edwardk> you can get an infinite list zipper comonad by using Integer as your monoid with (+)
06:37:41 <edwardk> you can get a finite one by thinking about the above stuff with a dependent type, or by building it from scratch
06:37:48 <zipper> That random mention from edwardk lol
06:37:55 <sm> tdammers: unregister is how you remove a package. No ?
06:38:04 <edwardk> zipper: =)
06:38:22 <squall_> http://lpaste.net/194212
06:38:29 <edwardk> zipper: i've uploaded you to hackage: http://hackage.haskell.org/package/zippers
06:38:50 <zipper> haha flattered
06:38:58 <edwardk> if you want a comonadic list zipper you want to have a guaranteed element
06:39:04 <edwardk> data Z a = Z [a] a [a]
06:39:16 <edwardk> then the 'extract' always has an element to pull from
06:39:25 <edwardk> it is fun to compare the two
06:39:47 <zipper> hmmm I wonder weren't zippers as they were enough? Oh "This module provides a Zipper with fairly strong type checking guarantees"
06:39:49 <mniip> hmmmm what was that zipper-related paper
06:39:50 <squall_> the duplicate instance starts at line 91 edwardk
06:39:58 <mniip> clowns and jokers or something?
06:40:18 <edwardk> squall_: the issue is the lack of 'extract'
06:40:30 <mniip> "Clowns to the Left of me, Jokers to the Right" righto
06:40:35 <edwardk> squall_: you have a 'semicomonad' effectively here.
06:40:36 <squall_> yeah, as im not using non empty zippers like how you describe
06:41:22 <squall_> i guess i could fix that, the Free can take care of the Empty...
06:41:25 <edwardk> > init $ tails [1..5]
06:41:28 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
06:41:32 <edwardk> gives a form of duplicate for []
06:41:51 <squall_> my duplicate is more like;
06:41:59 <edwardk> the analogy is similar here between lists and non-empty
06:42:14 <squall_> > let duplic = map (:[]) in duplic [1..5]
06:42:16 <lambdabot>  [[1],[2],[3],[4],[5]]
06:42:26 <edwardk> squall_: that isn't a legal duplicate then
06:42:31 <squall_> oh noes
06:42:38 <squall_> why ever not?
06:42:56 <edwardk> the duplicate for a zipper would have to give you a zipper full of zippers focused on each spot in the original
06:43:19 <squall_> > let duplic = map (:[]) in [1..5] == ((join. duplic) [1..5])
06:43:21 <lambdabot>  True
06:43:29 <edwardk> extend to the infinite case and add the missing member and then you can compare this to Integer ->  a  comonad
06:43:38 <EvanR> comonad duplicate evokes in my imagination the compound eye of an insect effect
06:43:40 <edwardk> join and duplicate have no meaningful relationship
06:43:43 <edwardk> duplicate and extract do
06:44:00 <edwardk> let's consider the Integer ->     comonad for a minute
06:44:12 <edwardk> duplicate :: (Integer -> a) -> (Integer -> Integer -> a 
06:44:17 <edwardk> duplicate f a b = f (a + b)
06:44:20 <edwardk> extract f = f 0
06:44:38 <edwardk> the integer is the position
06:45:02 <kuribas> edwardk: just out of interest, are there lens functions that give acces to the surrounding elements?
06:45:27 <edwardk> kuribas: no. 'elements' aren't really a concept in lens
06:45:51 <edwardk> squall_: in the above integer analogy your version is more like
06:46:02 <edwardk> duplicate f a b = f a
06:46:15 <edwardk> well not exactly, because you have finite lists
06:46:36 <edwardk> but the fact that join retracts duplicate is irrelevant
06:46:56 <squall_> oh
06:47:12 <squall_> i thought rhey were opposites kind of
06:47:20 <mniip> join retracts duplicate? surely you don't mean join . duplicate = id?
06:47:34 <edwardk> you need the fmap duplicate . duplicate = duplicate . duplicate
06:47:51 <edwardk> mniip: in his example it does. but my point was that it was irrelevant
06:47:54 <squall_> yeah, mniip thats what i was getting at
06:48:11 <mniip> well, it's not a law
06:48:16 <mniip> NonEmpty is a counterexample
06:48:19 <edwardk> mniip: exactly
06:48:26 <squall_> ok nvm
06:48:27 <younder> bizarre code
06:48:52 <squall_> which, my difference scheme?
06:49:14 <edwardk> you need fmap duplicate . duplicate = duplicate . duplicate; fmap extract . duplicate = id; extract . duplicate = id
06:49:19 <kuribas> edwardk: I can image a traversal that keeps track of next and previous elements.
06:49:23 <edwardk> those are the 3 comonad laws
06:49:29 <edwardk> there isn't any mention of join or return in there
06:50:20 <edwardk> kuribas: you can come up with combinators that accept traversals and do all sorts of things. once you add the tracking you mention it'd fail to pass laws as a traversal itself, but you can do anything you want with a combinator
06:50:28 <ertes> put differently:  monads in Hask and monads in Hask^op are rather different and unrelated things, but even unrelated things can sometimes pretend that they are related =)
06:50:32 <mniip> !
06:50:50 <squall_> perhaps im restricting my considerations to Comonads which are Monads where dulicate is the inverse of join.
06:50:53 <mniip> a comonad is just a comonoid in the endofunctor category
06:50:59 <mniip> wrt composition + identity
06:51:21 <EvanR> theyre related by a duality
06:51:34 <EvanR> which might not mean much else!
06:51:37 <squall_> endo what now?
06:51:41 <edwardk> squall_: the commonly considered 'interesting' interactions are where return and join are comonad homomorphisms.   this is equivalent to showing extract and duplicate are monad homomorphisms
06:51:59 <squall_> mind = blown
06:51:59 <mniip> oh that was not intended to be helpful, just something I realized just now
06:52:17 <edwardk> squall_: i gave a talk a while back at zurihac on monad homomorphisms
06:52:23 <edwardk> you might want to watch that to help unpack that statement
06:52:57 <edwardk> https://www.youtube.com/watch?v=YTaNkWjd-ac
06:52:58 <squall_> im not sure if thats my most relevant priority.... perhaps even it would be difficult to understand if it was
06:53:12 <squall_> ok, ill give it a wach when i get settled
06:53:24 <edwardk> well, i'm trying to help you get your thinking on these topics screwed on straight in general =)
06:53:35 <edwardk> you'll find that the thing you have fails to be a comonad
06:53:52 <edwardk> so you fall apart before you get to a meaningful interaction between the comonad and monad
06:53:53 <ertes> squall_: if the concept of monoid/group homomorphisms makes sense to you, monad/comonad homomorphisms shouldn't be too alien
06:54:24 <edwardk> in other categories you can find interesting things like hopf algebras which act like really fancy monad/comonad pairings that interact like i mentioned with an additional operation with even more laws
06:54:37 <edwardk> but hask is boring enough that that doesn't happen
06:55:12 <edwardk> monad homomorphism:   f (return a) = return a;   f (m >>= k) = f m >>= f . k
06:55:30 <edwardk> if that holds for all a m and k, that says f is a monad homomorphism
06:55:45 <mniip> such as listToMaybe / maybeToList
06:55:48 <ertes> example:  f = either (const Nothing) Just
06:56:14 <ertes> :t either (const Nothing) Just
06:56:16 <lambdabot> Either b a -> Maybe a
06:56:21 <edwardk> that talk gives about a couple of hours of other examples =)
06:56:40 <squall_> ok this is starting to become unbearably stressfull, im going to cut out.
06:56:51 <edwardk> squall_: not meaning to stress you
06:57:01 <squall_> not your fault
06:57:02 <edwardk> take a look at the video when you get time
06:57:11 <squall_> i have saved them to my inbox
06:57:13 <edwardk> and relax and enjoy this stuff
06:57:14 <squall_> thanks for the help
06:57:40 <edwardk> anyways the relationship you want to find is stronger than the one you'll find in practice for anything that passes the laws here, except for things like identity
06:57:52 * hackagebot concrete-haskell 0.1.0.0 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.0 (TomLippincott)
06:57:53 <edwardk> at least that is my intuition
06:57:55 <edwardk> i could be wrong
06:58:04 <squall_> i figured something similar
06:58:25 <squall_> i was hoping it might contain, eg Free NonemptyList
06:58:30 <edwardk> yeah. at best you can get a one sided inverse between return and extract
06:58:38 <edwardk> otherwise you're stuck with identity
06:58:51 <squall_> thats a bit restricvtive anyway
07:00:15 <squall_> when i can get my head together ill present the Free Free Zipper thing i have been working on, but its somewhat complex
07:00:24 <squall_> ciao
07:00:31 <edwardk> later
07:01:16 <EvanR> a lot of times CT stuff is presented in a way where the punchline ends up being the definition of something
07:01:31 <EvanR> like what a monad morphism is
07:01:38 <EvanR> but whats missing is, why do we care
07:01:45 <EvanR> granted i didnt watch the video yet
07:02:15 <edwardk> EvanR: the talk is given in terms of 'hey i want to make code run faster' -- the answer winds up being those things
07:02:42 <EvanR> now thats what i wanna hear 
07:02:59 <Aleksejs> Hi, why (-0-0) evaluates to 0, but 1/(-0-0) evaluates to -Inf?
07:03:19 <ertes> Aleksejs:
07:03:22 <edwardk> Aleksejs: ieee floating point actually distinguishes -0 and 0
07:03:25 <ertes> > (-0-0) :: Double
07:03:27 <lambdabot>  -0.0
07:03:39 <edwardk> they compare as equal, but 1/ them goes to different infinities
07:03:53 <ertes> Aleksejs: (-0-0) with no further specialisation defaults to Integer, which does not have negative zero
07:03:56 <edwardk> it can matter when you need to figure out if you underflowed to zero from above or below
07:04:08 <tdammers> that actually makes sense if you consider floats conceptually approximates
07:04:32 <ertes> Aleksejs: also:
07:04:39 <ertes> > 1 / fromInteger (-0 - 0)
07:04:42 <lambdabot>  Infinity
07:04:47 <tdammers> which is also why it is reasonable to have 1/0 == Inf
07:04:48 <EvanR> whats NaN approximate to?
07:04:58 <edwardk> these things actually matter to folks who care about numerical accuracy
07:05:26 <EvanR> if its approximate to all numbers, then they shouldnt have called it *not* a number heh
07:05:32 <ertes> EvanR: 0.0000000001/0.0000000001 =)
07:05:39 <edwardk> EvanR: NaN makes sense in a world that needed to do a lot of floating point calculation where branching was ridiculously expensive and numerical analysts were cheaper than computers
07:05:44 <tdammers> NaN is "I give up"
07:06:49 <edwardk> to a haskeller it seems dumb. e.g. "why not maybe?" but that isn't the world in which ieee floating point was forged
07:07:04 <carter> Also different nan can mean different things.  Just not utilized. 
07:07:05 <ertes> NaN is "your suck at numerical methods"
07:07:15 <EvanR> NaN is effectively Maybe
07:07:18 <tdammers> floats are "pragmatic"
07:07:20 <ertes> (and i suck at english)
07:07:21 <tdammers> :(
07:07:22 <EvanR> one NaN infects everything
07:07:34 <carter> You should read the standard
07:07:42 <carter> You can set nans to be signaling :)
07:07:55 <EvanR> yes only talking about the nans we usually get
07:08:01 <carter> And a language supporting floats is allowed to treat those as exceptions.
07:08:02 <edwardk> yeah and as carter notes: NaN has all sorts of internal structure. there are distinguishable positive and negative nans, signaling and non-signalling ones. you can pack a payload in them...
07:08:26 <ertes> edwardk: actually i'm not sure how to introduce Maybe there…  would you really prefer ((/) :: (Fractional a) => a -> a -> Maybe a)?
07:08:29 <carter> Yeah. The standard says languages can do fun stuff with those. But no ones really exploded them
07:08:31 <EvanR> none of that makes me like NaNs more
07:08:50 <carter> EvanR: precision issues happen even with exact reals
07:09:07 <edwardk> ertes: no. i personally wouldn't, but its the kinda thing that would start to follow from attempting a redesign that removed some weirdnesses
07:09:27 <EvanR> which issues are you referring to?
07:09:42 <carter> edwardk: ertes id favor a proof of not equal to zero input
07:09:45 <edwardk> ertes: that said, you _can_ have a design where (/) allows for that sort of thing and can be defined properly for integers, where you talk about which numbers in the ring are units, etc.
07:09:49 <carter> Rather than checking the output
07:09:53 <kuribas> edwardk: would something like this work? withEnvironment Traversal :: Traversal s t a b -> Traversal s ([t], t, [t]) a b 
07:10:01 <EvanR> not equal to zero!
07:10:05 <edwardk> kuribas: that isn't a traversal
07:10:35 <ertes> carter: in a language other than haskell i'd probably favour that, too
07:10:38 <edwardk> the fact that s can't be unified with t in there is a dead giveaway
07:10:52 <ertes> a language that lets you prove non-trivial things without going crazy
07:10:58 <kuribas> edwardk: ok
07:10:59 <edwardk> s and t aren't 'independent'. see http://comonad.com/reader/2012/mirrored-lenses/
07:11:14 <edwardk> they are an approximation to something we can'tsay in haskell's type system
07:11:19 <EvanR> how about the specific number strictly gerater than zero which separates it from zero
07:11:21 <carter> Nonzero a
07:11:31 <younder> ertes, That would be suficcient and complete
07:11:44 <EvanR> not equal to zero might be problematic in your foundations
07:11:52 <younder> ertes, a strong MIN on sufficient
07:11:56 <carter> Why
07:12:09 <ertes> carter: with (unsafeNonzero :: a -> Nonzero a)?
07:12:23 <EvanR> because its not necessarily the case that a number that is not equal to zero can be inverted
07:12:25 <carter> Who said unsafe
07:12:29 <edwardk> carter: consider the integer example above
07:12:40 <carter> Exact inversion?
07:13:06 <carter> The infinite?
07:13:14 <ertes> carter: nonzero :: a -> Maybe (Nonzero a)?
07:13:46 <carter> Sure
07:14:09 <younder> In differentail geometry we have soething called the tangent bundle. The surface composite is not infinity.
07:14:12 <carter> Ertes I've been very happy with the analogues operations in the type nat / type kits
07:14:14 <EvanR> for one example, the nilpotent infintesimals in smooth infinteimsal analysis dont have an inverse, but also arent "not equal to zero"
07:14:32 <carter> Do they have a distance from zero?
07:14:33 <younder> s/composite/oposite/
07:14:53 <ertes> carter: but what if i have a proof that it's non-zero?
07:14:53 <EvanR> they have a distance that isnt greater than zero
07:15:15 <carter> Sure o
07:15:23 <malc_> younder: "opposite"
07:16:14 <younder> It is possible to compose a algebra over the complemet of a surface.
07:16:47 <carter> I agree that for stuff bigger than the reals it gets more complicated :)
07:17:10 <EvanR> reals being programs is complicated
07:17:18 <ertes> carter: then i have to write boolean-blind code (fromJust), unless you have a better transition function
07:18:01 <carter> Aborts are ok :)
07:18:20 <EvanR> reals as programs is already "bigger than the reals" in the sense that we have different programs that go to the same real
07:18:40 <EvanR> or we dont know if they go to the same real
07:18:47 <carter> Proof irrelevance fixes that ;)
07:18:55 <ertes> i mean: don't construct a Maybe, if it can never be Nothing…  unfortunately haskell's type system is not good enough to support that
07:19:04 <younder> EvanR,  Now I a confused :) What do you mean
07:19:39 <carter> Ertes moar singletons.
07:19:49 <carter> Also proving stuff is too much work :)
07:19:52 <ertes> EvanR: the number of equivalence classes then is still the size of the reals (i think!)
07:20:04 <EvanR> im temporarily inspired by "bishop sets" where to define a type, like the reals, you first have to define all possible ways to build elements, and separately ways to tell when two ways are the same
07:20:10 <ertes> carter: yeah, and that's why we have 'head' in Prelude =)
07:20:30 <EvanR> if you dont do the second thing, you have a "preset"
07:20:38 <EvanR> which is where programming syntax lives
07:20:44 <ertes> carter: to be honest i would prefer (/) to 'throw' an exception instead of returning a NaN, but i wouldn't want it to return a Maybe *in haskell*
07:22:11 <EvanR> agreed
07:22:15 <younder> Just awful?
07:22:31 <EvanR> and we can enable the signalling NaN with the FP env configurator
07:22:37 <EvanR> wouldnt that be interesting
07:23:14 <ertes> carter: reason is that NaN usually is the kind of value that tells you that you've done your arithmetic wrong somewhere, so it signals a bug rather than an ordinary failure mode
07:23:15 <EvanR> but what does it get you, you still dont get an exception when your numerics are all off
07:23:23 <EvanR> unfortunately
07:23:28 <younder> I prefer numeric exceptins myself
07:24:10 <younder> Less hassle with (explicit or implicit) chained if's
07:24:27 <ertes> EvanR: i'm not even convinced that the reals are larger than the natural numbers in type theory, because i haven't done that proof yet, and haven't seen anyone else do it
07:24:49 <ertes> type theory is weird when it comes to cardinality
07:24:51 <Cale> younder: Use an algebraic data type and pattern match
07:24:54 <younder> ertes, Well I have, and I can
07:25:21 <ertes> younder: the proof?
07:25:21 <Cale> ertes: They are
07:25:22 <EvanR> ertes: i just ignore cardinality now
07:25:42 <ertes> Cale: sure, but i still want to prove it myself =)
07:25:48 <Cale> If you prefer, just do the proof for binary sequences to start
07:25:55 <ertes> yeah, that's the plan
07:25:56 <younder> ertes,  It comes back to the hilbert hotell. It is a thought experiment but it illustrates cantors idea: https://no.wikipedia.org/wiki/Hilberts_hotell
07:26:03 <Cale> Then write an injective map {0,1}* -> R, which is easy
07:27:15 <EvanR> it depends on your allowed logic and reasoning principles
07:27:36 <mniip> indeed
07:27:47 <EvanR> so its a plurality of results rather than a fact of the matter
07:28:02 <ertes> Cale: yeah, i have laid out the tools for that already…  i have proved that objects form a partial order with respect to monomorphisms
07:28:39 <kuribas> ertes: there is also this: hackage.haskell.org/package/HerbiePlugin
07:29:01 <mniip> consider like
07:29:10 <mniip> what is a real number?
07:29:19 <mniip> a dedekind cut?
07:29:41 <mniip> then a {0, 1} -> R map means a {0, 1} -> Q -> Bool map
07:29:47 <mniip> can you really construct one?
07:30:01 <Cale> {0,1}*, not just {0,1} :)
07:30:04 <mniip> eer yes
07:30:46 <younder> Again I recommend the book "Introduction to Lattices and Order 2nd Edition" by B. A. Dave. The solution to Haskell the universe and everything
07:30:49 <ertes> i'd go with 2^ℕ rather than 2*
07:30:51 <carter> EvanR: ertes I'm hoping to add that to ghc soon , this winter vacay
07:31:04 <Cale> and yeah, fair enough
07:31:13 <Cale> 2^N is perhaps nicer
07:31:38 <ertes> carter: i'm looking forward to it, even though i don't have a concrete use case right now =)
07:31:53 <ertes> Cale: smaller equivalence classes
07:32:10 <mniip> if you stick with 2^N ~ R
07:32:14 <mniip> can you multiply by 3?
07:32:16 <younder> Well at leat it clears up a few things about posets and categoies in Haskell.
07:32:44 <EvanR> with axiom of choice you can do anything
07:32:45 <ertes> even 2^ℕ has equivalence classes, which is a bit unfortunate
07:32:51 <mniip> duh
07:32:55 <Cale> Er, what?
07:32:59 <younder> Something I found very confusing at first.
07:33:02 <mniip> nonconstructivity
07:34:04 <ertes> Cale: i could disregard them, but 0.01111… ≡ 0.1
07:34:10 <EvanR> a strict sequence of bits doesnt actually let you do arithmetic correctly
07:34:21 <EvanR> it will freeze up
07:34:39 <EvanR> you could use signed bits, but thats not N -> Bool
07:34:42 <ertes> *if* you interpret 2^ℕ as the type of streams of digits
07:34:43 <mniip> a lazy sequence won't either
07:35:04 <younder> EvanR, That sound confusedto me
07:35:07 <EvanR> yeah N -> a is isomorphic to a lazy list of a
07:35:29 <younder> EvanR, A two complemet is just a number
07:35:32 <ertes> i'm not sure if disregarding them has any consequences
07:36:08 <younder> EvanR, It is not just a whole number with it's sign changed
07:36:46 <EvanR> can you fix your typos to give me a chance of comprehending you
07:36:58 <Cale> ertes: Oh, just use a different base
07:36:58 <EvanR> two's complement? what?
07:37:20 <mniip> actually
07:37:23 <Cale> like, if you were to use base 10, and 3 and 7 as your digits, you don't have that problem
07:37:23 <EvanR> theres no whole number base which lets you do arithmetic without freezing up somewhere
07:37:30 <younder> EvanR, It is important to remeber that numers in a cumuter are COSED posets. IE they have a upper and a lower bound. This is essential to the computers abillity to do computatins n hem.
07:37:37 <Cale> (it's not surjective, but you probably don't care)
07:37:41 <mniip> I wonder wwhat the proposed 2* -> R mapping what would like
07:37:50 <ertes> Cale: is P(ℕ) ≃ ℝ a theorem in type theory?
07:37:51 <mniip> wrt the integer part
07:38:07 <younder> ertes, yes
07:38:12 <Cale> ertes: it might be hard to get a map R -> P(N)
07:38:31 <Cale> younder: It's not so clear.
07:38:35 <ertes> younder: type theory!
07:38:40 <younder> a closed postet can't be conguent to a Real
07:38:52 <younder> come to thiink about it
07:38:54 <EvanR> ertes: sure, type theory is just a language to do proofs, you could use whatever principles to get the same results as classical math
07:39:12 <EvanR> to get different semantics, you have to pick different principles
07:40:15 <ertes> Cale, EvanR: i think the first step would be to actually define what i mean by "ℝ"…  i'll do some research, but not right now =)
07:40:40 <younder> EvanR, I disagee. There is a new theory on "Type theory and categorical logic" which bind types and objects together using 'categorica fibers.
07:40:56 <ertes> and i'll try to define ℝ in such a way that an injective map into P(ℕ) is possible/easy
07:41:09 <Cale> ertes: Generally, you shouldn't expect to be able to define maps which wouldn't be continuous in topology
07:41:33 <Cale> If you're not going to adopt classicality principles like some form of LEM
07:42:15 <younder> As I said. It's like a ruler. You read the value to the nearest marker. It is and must be ma projection and a lossful one at hat. There can in general be no bijective mapping.
07:42:22 <ertes> Cale: yeah, makes sense
07:42:53 <ertes> and i'm not going to use any non-constructive principles
07:43:30 <EvanR> an interesting way to look at the reals is with toposes
07:44:11 <Cale> ertes: So 2^N has the property that its topology is totally disconnected (it is basically the same thing as the Cantor set)
07:44:40 <Cale> ertes: and so constructing a non-constant map R -> 2^N is typically impossible
07:44:44 <Cale> But the other way is easy
07:45:59 <younder> N^2 i not a problem it is N->N.
07:46:01 <EvanR> which topology on 2^N ?
07:46:10 <younder> it is O(1)
07:46:22 <younder> or N
07:47:36 <younder> Now the real numbers have a infinate numer of points between 0 and 1. That has a O(2) and ininitie of infineties.
07:48:11 <younder> The esssence of the Hilbert hotel
07:49:01 <younder> Now N^2 is a monoid.  And N->R is a monad
07:50:41 <EvanR> in a topos with an NNO, you can do the dedekind construction with that internal logic and get... *something*, the real numbers as interpreted in that universe
07:51:49 <younder> EvanR, Why do you use dekind cuts instead of cachey sequences?
07:53:04 <ertes> Cale: i wanted to learn about those "automatic" topologies for a long time…  can you point me to a good introduction?
07:53:38 <EvanR> dedekind is order theoretic, posets, you dont need arithmetic or metrics already
07:54:15 <bollu> what does this do? newtype Mon m (a :: ()) (b :: ()) = Mon m
07:54:15 <bollu>                                     deriving (Eq, Ord, Show)
07:54:23 <bollu> I think its using DataKinds?
07:54:23 <younder> nor in cachey sequences, they are  derived from the definition
07:54:33 <bollu> its from here: https://www.reddit.com/r/programming/comments/5e0odt/algebraic_patterns_category/
07:54:49 <mniip> 1479743137 [18:45:37] <younder> N^2 i not a problem it is N->N.
07:54:51 <mniip> umm what?
07:54:58 <mniip> N^2 is N*N
07:55:02 <mniip> N->N is something else
07:55:07 <ertes> bollu: it probably comes with a Category instance
07:55:13 <bollu> ertes: yes, it does
07:55:22 <bollu> but, like, what does the (a :: ()) and (b :: ()) do?
07:55:26 <ertes> bollu: it shows a way to define a monoid in terms of Category
07:55:44 <ertes> bollu: a monoid can be defined as a single-object category
07:55:54 <younder> EvanR, Personally I prefer to strt with sequences. They are computatinally equivalent to sets. And in computers they make more sence. Simuary avoid the the Russel paradoxwand ZF by intrucdicing classes.
07:56:11 <younder> start
07:56:55 <ertes> bollu: similarly a semigroup can be defined as a single-object semigroupoid
07:57:02 <ertes> bollu: similarly a group can be defined as a single-object groupoid
07:57:42 <younder> Once the difinitin of a set is different from the instance of a set the paradox ceases to exist.
07:58:27 <bollu> ertes: oh, that's what its doing!
07:58:40 <bollu> ertes: okay, yeah, I thought it was a general category and was so confused
07:58:50 <bollu> ertes: so, how do I encode a "general" category?
07:59:00 <ertes> bollu: what is a general category?
07:59:22 <younder> bollu, You don't! Haskell categories are over posets
07:59:44 <younder> well not with the type system
07:59:56 <ertes> bollu: as long as there is a "kind of objects" and a "type of morphisms" you can define your category in terms of Category
08:01:43 <younder> Unless ttere  is a equivalence between the categories that can be described by posets and general categories. I have been wondering about that.
08:01:44 <EvanR> younder: theres nothing wrong with that, but the two things dont necessarily result in the same reals
08:03:16 <younder> EvanR, To what are you refering?
08:05:01 <EvanR> younder: the cauchy sequences or cauchy approximations using rationals method
08:07:01 <younder> EvanR, Surely the important thing is to get a distinct locateor when you dissect the rage 0-1 in an ifinate number of points and fill in the gaps between the rationals.
08:07:28 <ertes> i wonder if there is an easy way with emacs and linux to hook up someone's IRC lines with my entropy pool
08:07:55 * hackagebot ngx-export 0.2.5.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.5.0 (lyokha)
08:08:25 <younder> If there is suc a distict mapping it must be one to oe and onto and thus the two representations are equivalent.
08:09:34 <EvanR> theyre not equivalent in general, is whats interesting
08:10:09 <nshepperd1> younder: can you not misspell everything
08:10:19 <younder> I can try
08:10:54 <nshepperd1> Also, how does creal work if arithmetic in integer bases freezes up?
08:11:35 <EvanR> it doesnt guarantee that the digits you get are right
08:11:49 <EvanR> it guarantees that the answer is within a certain distance from the real answer
08:12:17 <EvanR> but with a single lazy list of digits, youd obviously expect them to all be right
08:12:22 <EvanR> but its impossible
08:12:24 <nshepperd1> Ah
08:13:39 <younder> Numeriacl Analysis is all about minimiing that epsion. The distance from the actual value to the answer. Mathematicallly it can be thought of an operator theory for doing algebra on phase planes.
08:14:26 <younder> You take the epsion regiin as a plane.
08:15:35 <younder> You then do a optimatio to minimize the error term. The epsilon.
08:15:47 <squall_> these words are not makes sense
08:16:27 <stalk> hi
08:16:30 <stalk> hello jedai 
08:16:40 <younder> squall_, sorry, try this:https://en.wikipedia.org/wiki/Numerical_analysis
08:17:08 <bollu> ertes: which Category? is there a Control.Category?
08:17:11 <squall_> younder, please can you stick to Haskell related content
08:20:15 <EvanR> to be more concrete about the creals library (both of them), if you have 1/2 + (a carefully crafted number which is 10^-100 more than 1/2), and ask for 5 digits, it might give you 0.99999 even though the answer is really 1.00000
08:21:28 <younder> EvanR, 0.999... = 1
08:21:49 <EvanR> 0.9999... is not 1.0000... 10^100 .... 001
08:22:03 <nshepperd1> I see
08:22:09 <younder> 9/9=0.9999..=1
08:22:37 <EvanR> what trips up a naive algorithm for addition is, + a number that is an amount greater than 1/2 that no one knows, perhaps even zero
08:22:51 <EvanR> it will just freeze up trying to carry, to avoid showing incorrect 0.9999s
08:22:59 <younder> 1971/9999=0.197119711971...
08:23:52 <ertes> bollu: yeah
08:24:03 <nshepperd1> So it's sort of using the actual real topology instead of cantor topology to avoid that problem
08:24:08 <ertes> bollu: and it's polykinded now
08:24:16 <nshepperd1> In some way i can't really verbalise
08:25:23 <ertes> bollu: (.) :: forall (a :: o) (b :: o) (c :: o) (cat :: o -> o -> *). (Category cat) => cat b c -> cat a b -> cat a c
08:25:34 <EvanR> i was wondering what that topology on N->2 Cale was referring to was
08:26:49 <younder> nshepperd, In computeres we introduce discrete values and upper and lower bounds. Or total postets.
08:27:00 <EvanR> postetes?
08:27:14 <bollu> ertes: what does the (a :: o) even do? is that creating a depedantly typed function? of kind o -> o -> *?
08:27:16 <EvanR> i cant tell if youre typoing or talking about a weird as math thing
08:27:17 <bollu> oh my god
08:27:21 <bollu> haskell has dependant types? :O
08:27:44 <younder> EvanR, posets
08:27:45 <EvanR> yes, if you live on in the kind level
08:27:53 <EvanR> only
08:27:54 <hackrilege> are you talking about the fixed point of a convergent series?
08:28:07 <bollu> EvanR: "yes, if you live on in the kind level" what does that mean?
08:28:13 <EvanR> if you live only in the kind level
08:28:48 <nshepperd1> Yes, cantor space is the "natural" topology on 2^b, in Haskell, i think, because it expresses that you can only read a finite prefix of the input in finite time
08:29:03 <ertes> bollu: no, it's just using kind variables
08:29:11 <ertes> bollu: o is a kind variable
08:29:22 <ertes> bollu: try o = *
08:29:55 <ertes> then you have traditional Category, where objects must be concrete haskell types
08:30:32 <younder> ertes, You have lost me.  Kind variables?
08:31:01 <younder> Type fibres. Prehaps?
08:31:23 <nshepperd1> I think it probably emerges from the definedness partial ordering somehow which is what you
08:33:37 <okuu> Is there some easy way to check in the command line why two versions of two libraries are incompatible?
08:33:47 <EvanR> i see, cantor space looks like the brouwerian choice sequence thing. 
08:33:53 <younder> Whatever, have fun guy's.  I'll join at some later point when things have cooled down. (Enough chit chat)
08:34:12 <ertes> younder: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-polymorphism-and-type-in-type
08:34:48 <c_wraith> okuu: attempt to install them at the same time in a fresh sandbox?
08:36:03 <c_wraith> okuu: that is, in a new directory, do "cabal sandbox init" followed by "cabal install package1-version package2-version"
08:36:23 <c_wraith> okuu: if they're actually incompatible, that should tell you why in an error message.
08:37:03 <okuu> Ah, right, thanks. I was hoping for a way that didn't involve actually trying to download and install them, since my Internet connection is rather slow. :-|
08:37:36 <hvr> okuu: actually, the solving doesn't download them yet
08:37:38 <okuu> Never mind, I just said something stupid. I actually have to try to install them in a single go.
08:37:43 <hvr> only when the sovler finds a solution and starts building them
08:37:52 <c_wraith> okuu: add --dry-run to the cabal install
08:38:00 <c_wraith> okuu: that'll make it skip the actual building
08:38:05 <c_wraith> (and downloading)
08:39:27 <nshepperd1> Yes, that! So eg a computable function (a -> Bool) -> (a -> Bool) is a continuous function on a cantor space
08:40:31 <c_wraith> nshepperd1: this sounds related to the exhaustive search on infinite spaces stuff.  I can't remember the exact name..
08:41:29 <nshepperd1> Which means that a finite prefix of the output (an open set) can only depend on a finite prefix of the input (ie. preimage is an open set)
08:42:14 <c_wraith> nshepperd1: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/  is that related?
08:42:41 <nshepperd1> c_wraith: yes, definitely
08:44:45 <hackrilege> illegible!
08:46:54 <nshepperd1> Possibly i should be saying (Nat -> a) rather than (b -> Bool) if i want to be describing these things as sequences
08:47:44 <nshepperd1> a can be Bool for the normal cantor set
08:51:22 <hackrilege> I missed the start of the discussion, what are you talking about? functional equivalence?
08:52:24 <EvanR> nshepperd1: this topic has so many funny branches into other stuff...
08:52:51 <EvanR> hackrilege: different ideas about real numbers
08:53:53 <hackrilege> how do I find the fiexed point of an operator?
08:54:49 <c_wraith> depends.  What fixed point are you searching for?
08:54:56 <EvanR> :t ((+1) `fix`)
08:54:58 <lambdabot> Num a => a
08:55:18 <bollu> EvanR: the 'fix' in haskell is not 'fixed point' in general, no?
08:55:27 <bollu> fix is Y, fixed point is x = f(x)..?
08:55:34 <EvanR> it gives you 'a' fixed point
08:55:47 <c_wraith> It's a general least-defined (in domain theory sense) fixed point
08:55:48 <EvanR> which might be bottom
08:55:51 <hackrilege> > (iterate sqrt 10) !! 50
08:55:53 <lambdabot>  1.000000000000002
08:56:04 <c_wraith> Many functions have bottom as their least-defined fixed point
08:56:26 <c_wraith> There are other fixed points one might want to find.
08:56:36 <EvanR> bollu: Y is also called the fixed point combinator
08:57:05 <EvanR> since Y (Y foo) = Y foo
08:57:08 <bollu> EvanR: yes, but I've never seen how. I don't know domain theory, so I don't understand the "least defined" bit
08:57:57 * hackagebot operational 0.2.3.5 - Implementation of difficult monads made easy  with operational semantics.  https://hackage.haskell.org/package/operational-0.2.3.5 (HeinrichApfelmus)
08:58:48 <EvanR> one way to look at haskell values is as a lattice of more and more defined versions
08:59:24 <okuu> Is it a lattice or just a domain?
08:59:29 <EvanR> ⊥ is always the least defined version
08:59:37 <EvanR> (⊥,⊥) is more defined than that
08:59:54 <EvanR> (1,⊥) is more defined than that, but is incomparable to (⊥,2), both are more defined than (⊥,⊥)
09:00:50 <hackrilege> > foldl1 (\ a b -> if a - b <= 0.01 then a else b)  $ iterate (/2) 10
09:00:59 <lambdabot>  mueval: ExitFailure 1
09:01:26 <MarcelineVQ> > ("count", , "pringles", "per", ) 12 "can" -- til tuple sections account for any position, but the gaps are weird enough to read or miss that I can't see myself using that feature
09:01:33 <lambdabot>  ("count",12,"pringles","per","can")
09:01:44 <EvanR> oh didnt see the second hole there
09:02:09 <hackrilege> wow that's pretty cool
09:03:49 <hackrilege> shame that cant be done with lists
09:03:51 <EvanR> i wonder if some float really is the fixed point of your algorithm
09:04:06 <c_wraith> okuu, it's just a domain.. unless you do fancy things like the lub library does to combine values. 
09:05:13 <c_wraith> okuu, but that library depends on an assumption you can't generally rely on in Haskell - that the two values being combined differ only where one is defined and the other isn't. 
09:08:44 <okuu> c_wraith: Can't that be fixed by adding a top value, which means having inconsistent information?
09:09:07 <okuu> I have no idea what exactly should happen at runtime if you compute top.
09:09:16 <EvanR> top wouldnt make sense
09:09:38 <EvanR> it would be more defined than 5, and "foo"
09:09:45 <younder> The powerset! The key to a general category in terms of Posets is in the powerset :)
09:09:47 <EvanR> or equal
09:10:10 <EvanR> great scott!
09:12:22 <EvanR> now im wondering how lub works, does it do iterated unamb ?
09:12:36 <felko> how can I write a Category instance for newtype KleisliT m a b c = KeisliT { runKleisliT :: a b (m c) } ?
09:12:56 * younder lets go for a long grind at that prooving bit
09:12:56 <felko> id is pretty straightforward, but I can't figure out (.)
09:13:14 <conal> EvanR: yes. unamb is lub for flat types. for non-flat, a lub needs multiple lubs
09:13:33 <EvanR> multiple unambs
09:13:56 <conal> EvanR: multiple lubs. eventually, bottoming out as flat lub, ie unamb.
09:14:04 <EvanR> oh
09:14:10 <EvanR> its recursive
09:14:23 <conal> EvanR: yes. think about lub, not unamb.
09:14:33 <conal> unamb is just an implementation of lub for flat types.
09:14:55 <conal> lub is the fundamental concept. it's at the root of the meaning of programming languages.
09:15:03 <bollu> what's lub?
09:15:15 <conal> "least upper bound"
09:15:29 <conal> for partial orders. and specifically for information partial orders.
09:15:47 <ertes> felko: given (Category a) you have (.) :: a (m c) (m d) -> a b (m c) -> a b (m d)  -- not sure what you want to do with KleisliT
09:16:20 <conal> the lub of two pieces of information is the least (informative) info consistent with both.
09:16:52 <okuu> conal: How do you define whether a function is more defined than another? Pointwise?
09:17:17 <conal> okuu: exactly. f [= g   iff  forall x. f x [= g x
09:17:51 <ertes> felko: in any case (Category a) is not sufficient…  i didn't think this through, but you probably need (Profunctor a), too
09:18:51 <conal> The "fix" operator, which gives meaning to recursion, is the *least* fixed point in that [= information ordering
09:19:14 <felko> ertes: wouldn't that be (.) :: a c (m d) -> a b (m c) -> a b (m d) ?
09:19:30 <ertes> felko: nope, those types don't line up
09:19:51 <ertes> felko: it's: (.) :: a c d -> a b c -> a b d
09:20:07 <ertes> let me use different names
09:20:17 <ertes> felko: it's: (.) :: a y z -> a x y -> a x z
09:20:28 <felko> yeah but for KleisliT, if we substitute what's inside the KleisliT, we have the signature I gave no ?
09:20:38 <ertes> and you would need to instantiate (y = m c) to use it
09:21:05 <ertes> unfortunately Category isn't enough to give you any kind of access to the (m c), so you need some way to map over it in order to make use of (Monad m)
09:22:07 <ertes> just try it:  (a y z -> a x y -> a x z) with (y = m c):  a (m c) z -> a x (m c) -> a x z
09:22:09 <felko> I tried to implement (Arrow a, Monad m) => Category (KleisliT m a), but I can't figure out an implementation that checks, si Arrow is not sufficient neither
09:22:27 <felko> ertes: ok
09:24:03 <felko> ertes: I think I didn't get what you said, because I need to have (.) :: KleisliT m a y z -> KleisliT m a x y -> KleisliT m a x z
09:25:47 <felko> so I need to find an arrow to do KleisliT arrow, such as arrow has type a x (m z)
09:27:29 <ertes> felko: i see no way to implement this
09:28:32 <felko> I also tried adding an ArrowApply constraint on a, but I can't figure out neither
09:28:34 <ertes> felko: in fact the whole type doesn't really make sense to me
09:28:42 <lyxia> you'll need constraints on a and m
09:28:56 <felko> ertes: why ?
09:29:38 <ertes> felko: if i use the template: KleisliT c2 . KleisliT c1 = KleisliT (c2 . rmap _ c1)
09:29:48 <felko> and how can you deduce things like this so quickly, it's not the first time you just say "it's impossible" when I've been trying to do something for hours
09:29:51 <ertes> then: Found hole: _ :: m b -> b
09:30:12 <felko> ok
09:30:25 <felko> I'm not familiar with type holes
09:30:50 <felko> what is rmap ?
09:30:59 <implementation> new constraint Comonad m :>
09:31:05 <ertes> rmap is from Profunctor…  let me use Arrow instead
09:31:15 <nitrix> felko: It just says that the type inferred for the underscore in that expression would need to have this given type to typecheck properly.
09:31:43 <ertes> KleisliT c2 . KleisliT c1 = KleisliT (c2 . arr _ . c1)
09:31:49 <ertes> Found hole: _ :: m b -> b
09:32:13 <felko> wow, ok
09:32:25 <nitrix> This looks impossible unless `m` is a comonad.
09:32:46 <ertes> yep
09:32:48 <felko> yep but I want to use KleisliT for IO, so thats going to be a problem
09:33:08 <nitrix> Won't work then :)
09:33:16 <ertes> felko: why don't you just explain your application?  i'd almost bet that there is a simpler way =)
09:33:17 <implementation> there's an OI comonad, maybe that's an alternative
09:33:43 <felko> ertes: yeah but don't tell me whether it is impossible or not, I want to get stuck for hours
09:34:00 <lyxia> that doesn't sound very productive
09:34:10 <felko> production is not my goal
09:34:49 <younder> prototype narrow and THEN spesify
09:35:23 <felko> I'm trying to implement a data ProcessT a b c where { ForkT :: [ProcessT a b c] -> ProcessT a b [c]; LiftT :: KleisliT IO a b c -> ProcessT a b c }
09:35:40 <nitrix> felko: There's work already done on the subject, something proposed by Kieburtz called the OI comonad. It's supposed to preserve referential transparency but I have no idea how it works of if it works at all.
09:36:12 <felko> nitrix: cool, I'll check that out
09:36:36 <nitrix> felko: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.5169&rep=rep1&type=pdf
09:37:00 <felko> thx
09:37:26 <ertes> felko: so you want to crunch on difficult problems…  wait…  i think i have a list…
09:37:35 * ertes rifles through shreds of files
09:37:47 <felko> don't tell me the answer
09:38:05 <Cale> implementation: That OI comonad thing turned out to be unsafe though
09:38:22 <implementation> what a pity :(
09:38:42 <felko> :(
09:38:49 <nitrix> Cale: How does it work breifly? Does it gives you a RealWorld# token or something?
09:39:58 <nitrix> Any contraptions I can think of are very error prone for the user. I'm thinking of reading that paper during lunch for fun though :P
09:40:03 <felko> ertes: the reason I need IO is because the thing will use forkIO at some point
09:41:18 <ertes> felko: the Comonad constraint shouldn't tell you: "i need comonads", but: "something is conceptually wrong here, and i need to rethink my whole approach"
09:41:32 <ertes> in other words: IO is not your problem
09:42:03 <felko> my problem is that I want to use a transformer, right ?
09:42:28 <ertes> felko: i still don't know what ProcessT is supposed to do (and why it needs to be so complicated)
09:42:46 <felko> I could just define Process b c (analog to ProcessT, but with a = (->)), and the implementations will be trivial
09:42:48 <implementation> and why exactly do you need a Category instance?
09:42:55 <ertes> felko: note in particular that we don't have many proper arrows that are actually useful
09:43:07 <felko> implementation: because it needs to be composable, and it will be an arrow
09:43:30 <Cale> nitrix: The only implementations of it that ever actually did anything just used unsafePerformIO to provide primitives like coPutChar :: Char -> OI Handle -> (), but if you think about that much at all, it should be clear why there's a problem
09:43:36 <ertes> felko: *why* will it be an arrow?  do you have a (formal, not intuitive!) reason why it can't be a monad?
09:44:06 <felko> no, I just like to try arrowizing monads
09:44:26 <felko> I have no solid knowledge on category theory
09:44:26 <ertes> felko: then how about i give you an exercise with an actual proper (non-monad) arrow?
09:44:49 <felko> ertes: sure, I must go right now, but I'll try
09:44:58 <felko> last exercise you gave me was cool
09:45:04 <ertes> felko: want me to give it now?
09:45:40 <felko> ertes: sure
09:45:47 <ertes> what was the last exercise?  was it about arrows?
09:45:57 <ski> @where topology
09:45:58 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
09:45:58 <lambdabot> dvi|ps)> by Martn Escard
09:45:59 <ski> nshepperd_ : did you see ^ ?
09:46:34 <felko> yes it was, you made me undersrand that some monad couldn't be arrowized, i don't remember exactly, but it was interesting
09:46:52 <felko> it was, like, 2 months ago
09:46:59 <ertes> felko: that was probably the state monad with meta-information
09:47:15 <c_wraith> huh? all monads form kleisli arrows, by definition.. 
09:47:42 <felko> ertes: that was another exercise even before, because I finally managed to arrowize State
09:47:43 <ertes> c_wraith: this was about an arrow that doesn't have a corresponding monad
09:47:54 <c_wraith> ah, that makes more sense. 
09:48:14 <felko> ertes: https://github.com/felko/atl/blob/master/Control/Arrow/State.hs
09:49:15 <ertes> felko: ok, that one is just arrowised State, so not a proper arrow
09:49:42 <ertes> "proper arrow" vs. "arrow" in the sense of "proper subset" vs. "subset"
09:50:09 <ertes> felko: did you solve the state monad with meta-info exercise?
09:50:29 <felko> no, because I can't
09:50:35 <ertes> then try again
09:50:37 <felko> I had to add other things
09:50:45 <felko> but I can't remember
09:51:02 <ertes> first try to make the following a monad:
09:51:20 <Xyliton> Hello, I just received a coding task (without a special target language) from my teacher and I though I might write it in Haskell to practice it a bit. The task is somewhat "easy": there's a list of numbers and ten "storages". At the beginning every storage will be filled with one number from the list (it always takes the head of the list and then uses the rest as new "list"). Then the program has to organize the numbers so
09:51:20 <Xyliton> Is it a good idea to use Haskell for this (I thought it might be because this seems to be a pure logical problem to me), or is there some language which fits better?
09:51:45 <ertes> data StateT s m a = StateT { _usesPut :: Bool, _runStateT :: s -> m (s, a) }
09:52:08 <felko> yes, it was that exercise, now I remember
09:52:29 <nitrix> Xyliton: That seems like a relatively trivial recursive function; depending on what kind of ordering is needed for these "storage".
09:52:45 <felko> ertes: I must go, but thanks
09:52:47 <felko> (again)
09:52:55 <ertes> felko: try to make this a monad that tracks whether 'put' has been used…  go as far as you can…  you will eventually fail to go further, but i want you to understand just how far you can go, and why you can't go any further
09:53:19 <felko> thanks a lot
09:53:21 <felko> bye
09:53:31 <ertes> have fun, bye =)
09:53:33 <Xyliton> nitrix: I just need to find pairs of them whose value is equal, or as near as possible but now below 20
09:53:55 <Xyliton> nitrix: but they have to be unique "storages"
09:54:13 <nitrix> Xyliton: If you could phrase it all down on an lpaste.net, I'll give it a shot :)
09:54:18 <nshepperd> ski: ah, I haven't seen those
09:54:23 <neonfuz> Is there a standard library function to safely get an element from a list
09:54:29 <nitrix> Xyliton: With ideally some sample inputs and expected outputs to help.
09:54:43 <ertes> Xyliton: your problem description was cut off (silent IRC line length limit)
09:54:44 <nshepperd> I saw Escardó's 2012 popl talk (well, the slides)
09:54:56 <neonfuz> one that checks if the list actually is long enough to have an element at that position rather than crashing
09:55:00 <nshepperd> ski: thanks!
09:55:08 <ertes> nitrix: i think Xyliton should try that by themselves…  it's an exercise after all =)
09:55:23 <nitrix> neonfuz: https://hackage.haskell.org/package/safe-0.3.10/docs/Safe.html
09:55:27 <nitrix> neonfuz: Look at `at`.
09:55:38 <nitrix> Whoops, sorry.
09:56:00 <nitrix> atMay.
09:57:13 <ski> nshepperd : np
09:57:25 <Xyliton> ertes: http://lpaste.net/344495 this is the description I wrote. I didn't knew that IRC just cuts my messages ;-;
09:57:43 <Xyliton> I tried to implement it in Ruby once, but I ran into "some" issues
09:57:59 * hackagebot latex-function-tables 0.1.0.0 - Function table specifications in latex  https://hackage.haskell.org/package/latex-function-tables-0.1.0.0 (SimonHudon)
09:59:00 <Xyliton> My implementation was using the built-in permutation function to get all the different combinations of "storages" and then calculate their sums. If it finds one that fits the description it empties the one it found and refills them afterwards
09:59:53 <Xyliton> but that would error when it gets input like [1,1,1,1,1,1,1,1,1,1,...] because the sum of 10 1s is not 20 :')
10:00:16 <ertes> Xyliton: is there a limit to how many values a storage can hold?
10:00:39 <ertes> your description doesn't specify any
10:00:54 <Xyliton> a storage holds exactly one value and has one id (to make it unique and distinguishible)
10:01:03 <Xyliton> *distinguishable
10:01:05 <ertes> ah, i see
10:01:16 <ertes> well, it always takes the head
10:01:45 <infandum> I have three monad actions but only the first is executed. I call it three times, do { function; function; function } but only the first get's called, the type returns (). What am I doing wrong?
10:01:58 <Xyliton> also there is one "output storage" which they are emptied into. So it would be possible to empty every storage twice if the input is 20 1's. But the program is not able to look at the next value in the list
10:02:45 <ski> @paste
10:02:45 <lambdabot> Haskell pastebin: http://lpaste.net/
10:02:47 <ski> infandum ^
10:03:13 <ertes> Xyliton: example list: replicate 100 2
10:03:46 <ertes> Xyliton: so the algorithm would receive the first value 2 and choose which storage to put it in, then it would receive the next…  right?
10:03:56 <dev987> What is the simplest or most idiomatic way to write `(a, Maybe b) -> Maybe (a, b)`
10:04:01 <nitrix> Xyliton: So the closest to 20, above is tolerated but below isn't?
10:04:32 <nitrix> Xyliton: I think by definition, that means 100 would be allowed in some worst cases... so how can the algorithm possibly get "stuck" as described?
10:04:42 <ski> dev987 : `uncurry (fmap . (,))' is one way
10:04:49 <Xyliton> nitrix: once a number below 20 is reached
10:04:57 <dev987> ski: thank you. let me try that.
10:05:09 <nitrix> Xyliton: Oh, as if the sum of the list is lower then 20.
10:05:12 <nitrix> Xyliton: Gotcha.
10:05:41 <nitrix> Xyliton: Getting lunch and I'll try to see what I come up with. Sounds like a fun problem :P
10:06:23 <allenj12> is there an example of a contravariant functor that isnt a function type in the definition? I feel like its impossible, but havent heard anyone talk about it
10:06:24 <Xyliton> brb, I have to eat
10:06:31 <ertes> honestly i have no idea what the problem even is
10:08:29 <allenj12> to elaborate: Predicate a = Predicate a -> bool, is an example of the function type I was talking about, but is there any way to have a contravariant functor with just say: Contra = Contra a | Var b c or something?
10:09:30 <MitchellSalad> allenj12: sure, "Predicate a" :)
10:09:34 <quchen> Const a b should be a contravariant Functor in a, no?
10:09:52 <MitchellSalad> you mean in `b`?
10:10:13 <quchen> No, I meant in "a", and I now see that that was nonsense. :-s
10:10:26 <MitchellSalad> well it is contravariant in b - covariant too
10:10:28 <allenj12> quchen: so wich is it?
10:10:30 <quchen> Went too quickly with the “thing has to be on the left” ;-)
10:10:32 <ski> allenj12 : in SML/NJ, `cont' (for continuation) is contravariant
10:11:11 <quchen> MitchellSalad: Not sure why I went for Const, Proxy has the same properties
10:11:22 <quchen> But those are pathological examples, usually
10:11:27 <allenj12> MitchellSalad: so just "Predicate a" is a contravariant functor? Wouldent that be just a normal functor
10:11:32 <dev987> ski: thank you that snippet works perfectly
10:11:35 <ski> allenj12 : a "write-end" of a channel, that you could attach preprocess code to (aka `CoyonedaOp'), would also be contravariant
10:12:15 <ertes> Xyliton: the problem doesn't make sense to me at all…  especially since the sum of any permutation of xs is the same as the sum of xs (addition is commutative)
10:12:28 * ski doesn't really understand allenj12's `Predicate a = Predicate a -> bool', looks like `a' is (effectively) unused there ?
10:13:04 <Tertain_> Anyone else been running into problems with ghci lines recently? Seems like every time text fills up 80% of the line ghci goes crazy.
10:13:06 <ertes> Xyliton: either it's really that easy (and the storages are completely irrelevant), or the problem description is missing something important
10:13:06 <allenj12> ski: i think thats Predicate is actually built into the contravariant package
10:13:08 <quchen> ski: Probably missing parentheses.
10:14:00 * ski suspects a missing `data'/`newtype' in what allenj12 said
10:14:06 <ski> (otherwise it's recursive)
10:14:09 <allenj12> o yes
10:14:13 <allenj12> i am
10:14:13 <quchen> ertes: Even for infinite lists? Reminds me a bit of Riemann reordering where permutations on infinite things result in weird properties.
10:14:14 <allenj12> haha
10:14:38 <ertes> quchen: i seriously doubt that that's what Xyliton's teacher was going for
10:15:00 <quchen> ertes: I didn’t catch the question, just your answer. Nevermind then
10:15:13 <ertes> quchen: http://lpaste.net/344495
10:15:36 <quchen> Hah, an ertes paste!
10:15:46 <ertes> quchen: that's not mine =)
10:15:52 <quchen> Oh, I thought it would be some insightful code snippet :-(
10:15:56 <allenj12> quchen: can you finish your example? its Const a b = Const a?
10:16:10 <quchen> allenj12: My example was wrong, MitchellSalad corrected me.
10:16:19 <ski> (`newtype Const a b = Const a', rather)
10:16:31 <allenj12> quchen: but MitchellSalad said it was contravariant on one of the parameters
10:16:39 <quchen> data Proxy a = Proxy; instance ContraFunctor Proxy where contramap _ Proxy = Proxy
10:17:00 <ertes> quchen: <https://github.com/esoeylemez/snippets>, <https://gist.github.com/esoeylemez>
10:17:02 <ertes> enjoy =)
10:17:03 <quchen> data Const a b = Const a; instance ContraFunctor (Const a) where contramap _ (Const a) = Const a
10:17:12 <allenj12> ski: ofc :D and that is contravariant?
10:17:39 <ski> allenj12 : `Const a' is a contravariant functor (and also a covariant functor), for each type `a'
10:17:39 <quchen> Well, Proxy and Const just ignore one parameter, so you can basically do whatever you want with it
10:17:43 <allenj12> since the last argument of the type is b, which gives us the const of a
10:17:52 <quchen> ertes: Hah!
10:17:57 <ski> allenj12 : alternatively phrased, `Const a b' is contravariant (and covariant) in `b'
10:18:07 <quchen> ertes: When I’m done re-understanding my Hindley-Milner article I’ll give those a read ;-)
10:18:11 <MitchellSalad> lens uses (Functor f, Contravariant f) to mean "has phantom type"
10:18:16 <allenj12> ski: perfect thank you
10:18:30 <ski> allenj12 : alternatively phrased, `b' occurs negatively (and positively) in `Const a b'
10:18:39 <quchen> MitchellSalad: Really? Awkward.
10:18:47 <quchen> MitchellSalad: I mean it’s not the clearest of code.
10:18:56 <ertes> hehe
10:19:14 <quchen> ertes: perm2 n = foldr (\x -> (>>= dist x)) ಠ_ಠ 
10:19:18 <MitchellSalad> no argument there =P
10:19:41 <quchen> :t \dist -> foldr (\x -> (>>= dist x))
10:19:43 <lambdabot> (Foldable t, Monad m) => (t1 -> a -> m a) -> m a -> t t1 -> m a
10:19:45 <quchen> Good heavens.
10:20:58 <dolio> ski: That last one seems like a bad description.
10:21:29 <dolio> It's both covariant and contravariant because b doesn't occur at all.
10:21:32 <ertes> quchen: i can haz catamorphizm!
10:21:47 <hodapp> lolcategories?
10:21:49 <quchen> Zygohistomorphic prepromorphism, eh
10:21:56 <dolio> Whereas b occuring both negatively and positively could mean that it's neither covariant nor contravariant.
10:22:18 <ertes> hodapp: lolcats!
10:22:59 <hodapp> 9_9
10:23:00 * hackagebot semiring-num 0.5.4.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.5.4.0 (oisdk)
10:23:03 <quchen> ertes: Now I accidentially clicked on an Agda source file and was slightly scared
10:23:11 <quchen> Thought that was Haskell for a second
10:24:51 <quchen> ertes: Are you working with Haskell in academia?
10:25:00 <quchen> Or do you just like to play around with this sort of stuff
10:25:00 <ertes> quchen: nope
10:25:09 <ertes> the latter
10:25:35 <quchen> Good thing I didn’t place a bet. You have a very Connor-y vibe coming from you. :-)
10:25:43 <Darwin226> Hey, how come StateT is defined like s -> m (a, s) instead of m (s -> (a, s))?
10:25:55 <Darwin226> It seems like you can write all the instances for the other one
10:25:58 <quchen> s/Connor/Conor/
10:26:09 <ski> dolio : surely `b' occurs in `Const a b' (<- right there, at the end), though not in the "expansion"
10:26:16 <quchen> Darwin226: No particular reason. Historical.
10:26:32 <quchen> Ohh.
10:26:34 <wespiser> Darwin226: when you run StateT, you start with an input state, then return an monadic context
10:26:34 <quchen> Nevermind, misread.
10:26:35 <Darwin226> quchen: But they don't really see equivalent. Is there anything interesting to be said?
10:26:43 <ski> dolio : good clarification, anyway
10:26:50 <quchen> Darwin226: Sorry, I thought you meant the (a,s) vs (s,a) debate.
10:26:55 <ertes> quchen: uh, that has to be the best compliment i received yet =)
10:27:00 <quchen> Not the "where does the m go"
10:27:05 <quchen> ertes: :-)
10:27:06 <lyxia> Darwin226: m (s -> (a, s)) the computation can't depend on the state
10:27:07 <wespiser> @unmtl StateT s m a
10:27:07 <lambdabot> s -> m (a, s)
10:27:29 <Darwin226> Yeah, I "get" that but I don't really
10:27:30 <lyxia> Darwin226: implement bind.
10:27:42 <lyxia> can you?
10:27:43 <dolio> ski: I guess. I probably wouldn't call that occurrence positive or negative.
10:27:52 <quchen> Now that monochrom went mute (?) you’re the advanced stuff guy, ertes. Enjoy your new title
10:28:09 <wespiser> my advice, go through the 'get' and 'put' functions, as well as 'bind' and 'return' until you can repeat them in your sleep
10:28:30 <ertes> quchen: well, unfortunately i have this disease
10:28:41 <ertes> i need to talk bullshit at least once a day
10:28:43 <Darwin226> lyxia: Oh, right. Seems my "walking home" brain took a few shortcuts when implementing the bind.
10:29:08 <Xyliton> ertes: The good thing is that I'm just a mere 16 year old student so the problem won't involve infinite lists or that kind of stuff :D
10:29:41 <shapr> I think infinite lists are only illegal if you're under 12
10:29:58 <wespiser> i live in massachusetts, they are banned here
10:30:23 <nitrix> Xyliton: You problem is complicated because it becomes a "packing problem". One might take the first combination they see that sums to 20, but a more clever person would favoritize merging the smaller numbers first, to free out as many "storage" as possible, to give a chance for the algorithm to get stuck less frequently.
10:30:59 <ertes> i live in germany, where technically they're allowed, but you can only use them with concatMap, sort and (take n) with 20 <= n <= 417
10:31:23 <Xyliton> ertes: I'm from germany too. 
10:31:27 <kuribas> @hoogle [a] -> Int -> Mayeb a
10:31:30 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:31:30 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:31:30 <lambdabot> Data.List take :: Int -> [a] -> [a]
10:31:33 <kuribas> @hoogle [a] -> Int -> Maybe a
10:31:34 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
10:31:34 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
10:31:34 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
10:31:57 <kuribas> :i atMay
10:32:04 <kuribas> @src atMay
10:32:04 <lambdabot> Source not found. You speak an infinite deal of nothing.
10:32:19 <athan> tell me something I don't know, lambdabot!
10:32:23 <kuribas> Why doesn't the prelude have a safe index?
10:32:26 <ski> @quote please.talk
10:32:27 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
10:32:41 <ertes> Xyliton: hello, neighbour =)
10:32:54 <Xyliton> but my teacher is _really_ competent and we just started with Java (which I already know) so it shouldn't involve any "complicated" stuff
10:33:00 <Xyliton> ertes: o/
10:33:13 <younder> ertes, I'm from Norway
10:33:28 <lyxia> kuribas: good question
10:33:38 <wespiser> Java is a complicated mess
10:33:43 <kuribas> > [1..3] !! 4
10:33:45 <lambdabot>  *Exception: Prelude.!!: index too large
10:34:05 <Xyliton> the storages are used because you can only use 10 numbers at a time
10:34:23 <ertes> quchen: did you see my latest golf for 'permutations'?
10:34:33 * ski misses ddarius,Heffalump,TheHunter,mmorrow,vixey,Pseudonym,&c.
10:34:37 <nitrix> Xyliton: It's alright. I'm almost done :)
10:34:40 <younder> I am still trying to figure out how to use Tarski's mid point theorem t proove program terminatin.
10:35:06 <Xyliton> nitrix: you almost solved the problem? :o
10:35:19 <nitrix> Sure.
10:35:28 <nitrix> Well, I'm eating at the same time :P
10:36:44 <Xyliton> wow. One day I want to be as skiled as you ;-;
10:36:55 <Xyliton> *as you are
10:37:08 <Xyliton> btw, here's my ruby code: http://lpaste.net/344510
10:37:19 <Xyliton> *skilled
10:37:31 <mpickering> younder: Isn't it Tarski's fixed point theorem or is that different?
10:37:48 <younder> mpickering, Yes it is.
10:38:49 <younder> It has been a source of confusion. I am not sure how to set up an algorithm to test for it.
10:39:13 <quchen> ertes: I saw something and was repulsed. Is there something even shorter around?
10:40:24 <younder> Unttin a couple of weeks a go when Tupanella introduced me to this I was sure it was limited to reducing itteratetly or setting an upper limit.
10:41:30 <ertes> > foldr(\x->(>>=zipWith((.(x:)).(++))<$>inits<*>tails))[[]] "abc"
10:41:35 <lambdabot>  ["abc","bac","bca","acb","cab","cba"]
10:41:36 <younder> But anyhow computational categoty theory is starting to yield.
10:41:57 <ertes> quchen: it's not the same as 'permutations', but at least i got rid of that ugly foldM =)
10:42:38 <younder> ugly foldM ?
10:42:41 <mpickering> \whois younder 
10:42:46 <mpickering> woops :)
10:47:55 <Xyliton> ertes: btw, did you see my Hangman solution?
10:48:06 <ertes> Xyliton: i saw the video
10:48:29 <Xyliton> Is there anything I should add?
10:48:44 <ertes> Xyliton: code =)
10:49:12 <Xyliton> http://lpaste.net/344517
10:49:28 <younder> My crossword puzzle soler is in Common Lisp.
10:49:33 <younder> solver
10:51:04 <ertes> Xyliton: first glance: it looks complete (except perhaps that it has no penalties/wrong guess limit)
10:51:31 <ertes> how about a functional way to implement it? =)
10:51:38 <Xyliton> a functional way?
10:53:41 <ertes> Xyliton: the idea is that you construct a type that models hangman games
10:54:28 <ertes> what's a hangman game (without guess limit)?  it's either a running guess game, or it's a game that has already been won
10:54:41 <ertes> data Hangman = Guess … | Won …
10:55:24 <Xyliton> but how would that "enrich" the current code?
10:55:39 <Xyliton> Would it make the code more readable?
10:55:55 <ertes> firstly it would make defining the game logic *much* simpler, as you will see
10:56:12 <ertes> secondly it introduces separation of concerns…  the game logic is strictly separate from the UI
10:56:48 <Xyliton> isn't it already?
10:57:03 <Xyliton> I mean... that's what brick enforces after all, AFAIK
10:57:32 <ertes> and thirdly it comes with a built-in concept for extensions based on algebra =)
10:57:56 <ertes> not fully…  implementation details leak through into your UI layer
10:58:37 <Xyliton> where do I have stuff other than the ui in my ui function? :o
10:58:56 <Xyliton> "extensions based on algebra"? sounds interesting!
10:59:04 <Xyliton> but what can these extensions do?
10:59:39 <ertes> for example 'input' (line 29) is an implementation detail
11:00:15 <Xyliton> isn't it just extracting both values from a tuple?
11:00:25 <Xyliton> (which is the current state of the program)
11:00:26 <ertes> extensions: you can add penalties or add new game logic
11:00:35 <ertes> or change game logic (as far as the game exposes it)
11:00:55 <ertes> let me just show you the version i have in mind
11:01:13 <ertes> it's slightly fancier, but still simple enough:  https://github.com/esoeylemez/snippets/blob/master/Hangman.hs
11:01:46 <Boomerang> Another advantage of doing the game logic as ertes recommends is that if tomorrow you want to render your game with graphics or as a webpage you just have to change the interface, not the game logic
11:02:21 <ertes> first major difference: all implementation details are completely hidden…  an "interpreter" (e.g. a UI) that receives a Hangman value only sees a challenge (a string with holes) and a guessing function
11:03:35 <ertes> second major difference:  Hangman is a family of monoids, so i don't define the game logic as matching input to the secret word, but instead i define singleton hangman games (lines 72 and 46) and game composition (37)
11:03:53 <Xyliton> ertes: so this expects the main code to implement "Hangman" and run that?
11:03:55 <younder> perhaps you can make some use of this onld CL code: http://paste.lisp.org/+749X
11:04:58 <ertes> Xyliton: nope, you would do this:  main = hangmanStdio_ (foldMap char "my secret phrase")
11:05:14 <ertes> or:  main = hangmanStdio_ (fromString "my secret phrase")
11:05:32 <ertes> or with -XOverloadedStrings even just: main = hangmanStdio_ "my secret phrase"
11:06:20 <ertes> you construct hangman games by composing singleton games:  char 'm' <> char 'y' <> char ' ' <> char 's' <> …
11:06:30 <omnom> hi! I wanted to try gui programming in functional reactive style. I found this: http://stackoverflow.com/a/2672898  Sadly I've got trouble installing any of the suggested libraries with cabal... has anybody some time to help me with this? 
11:07:10 <Xyliton> ertes: so this basically a hangman game creating many small ones?
11:07:14 <Xyliton> *this is
11:07:51 <ertes> omnom: this is very old…  modern FRP libraries include reactive-banana and reflex
11:08:02 * hackagebot dom-parser 0.1.1 - Simple monadic DOM parser  https://hackage.haskell.org/package/dom-parser-0.1.1 (typeable)
11:08:20 <Xyliton> but what does the "instance" keyword? and what is a Monoid?
11:09:14 <Xyliton> *keyword mean
11:09:43 <younder> Xyliton, You really know what a monoid is.. It is function that matps to the same type thet it came from. Like strsearch, or sqrt
11:09:59 <ertes> Xyliton: yeah, exactly…  and sorry, i made the assumption that you're already familiar with basic type classes
11:10:08 <younder> Xyliton, You really know what a monoid is.. It is function that maps to the same type that it came from. Like strsearch, or sqrt
11:10:49 <dev987> Is this multimap a good choice: https://hackage.haskell.org/package/multimap-1.2.1? Or is there a better option, perhaps with the basic collections package?
11:11:47 <omnom> ertes, ty
11:12:28 <Xyliton> ertes: the only stuff I learned about typeclasses is that they are some magical thing which allows me to make stuff Comparable, or "show"-able. I never really learned more about them
11:12:30 <ertes> Xyliton: monoids are a very simple composition pattern: let ((!) :: A -> A -> A) be an associative binary function with a special element 'e' that is neutral w.r.t. (!)
11:12:53 <ertes> then (!) is a monoid over A
11:13:03 <Xyliton> "w.r.t"?
11:13:08 <ertes> with respect to
11:13:14 <EvanR> type classes are a magical thing to pass a dictionary of functions around
11:13:17 <ertes> example: (+) is a monoid over Integer
11:13:23 <ertes> example: (*) is a monoid over Integer
11:13:31 <ertes> example: (++) is a monoid over [a] for any 'a'
11:13:54 <Xyliton> do monoids have to take exactly two arguments?
11:14:00 <Xyliton> or can they receive more/less?
11:14:10 <ertes> counterexample: (-) is not a monoid over Integer, because it's not associative:  (0 - 1) - 2 ≠ 0 - (1 - 2)
11:14:27 <EvanR> (+) (*) and (++) take exactly 2
11:14:32 <ertes> the operator always receives two arguments…  that's necessary to make sense of associativity
11:14:35 <EvanR> sum, product, and concat takes a list of arguments
11:14:45 <younder> Xyliton, the ca have as many arguments as they like, but they need to be spesified, not a arbitrary number
11:14:46 <EvanR> which makes sense because of associativity
11:14:52 <joe9> What does the conIsRecord signify?
11:14:54 <jedai> Xyliton: a type is an instance of Monoid if you can define an associative binary operation on it that have a neutral element
11:15:04 <EvanR> younder: what? that sounds wrong and confusing
11:15:23 <Xyliton> jedai: now I feel like I'm brain-dead. ;-;
11:15:28 <ertes> Xyliton: that's the *mathematical* monoids
11:15:29 <jedai> Xyliton: once you have a binary operation you can operate on more elements just by chaining your operation
11:15:40 <Xyliton> that's confusing af to for me ;-;
11:15:42 <jedai> :t mconcat
11:15:45 <lambdabot> Monoid a => [a] -> a
11:15:46 <ertes> Xyliton: a haskell monoid kinda inverts that (but they're still the same thing)
11:16:11 <ertes> Xyliton: a haskell Monoid is a *type* together with an associative binary function with a neutral element
11:16:12 <younder> Xyliton, they ca have as many arguments, but they must be spesified exlpicitly, you can't have  not a arbitrary number of arguments
11:16:22 <EvanR> binary operations take 2 arguments. In LISP lore they take any number, but that only makes sense because the operators in particular are associative
11:16:41 <Xyliton> jedai: isn't that the same as a "normal" concat?
11:16:50 <jedai> Xyliton: monoids are *really* simple, so simple that some refuse to believe something so simple can be useful
11:17:12 <ertes> Xyliton: exercise:  newtype MySum = MySum Integer
11:17:26 <jedai> Xyliton: no, concat is a specialization of mconcat on lists [a] with the (++) operator (and [] as neutral element)
11:17:31 <jedai> :t concat
11:17:32 <lambdabot> Foldable t => t [a] -> [a]
11:17:37 <younder> (+ 1)  has one aumant (+) has two plus(one, two, three) takes three
11:17:38 <Xyliton> you say that they are simple, but I don't even understand their definiton -> I won't be able to utilise them
11:17:39 <ertes> write a Monoid instance for this one, and here is a template:  instance Monoid MySum where mappend = …; mempty = …
11:18:02 * hackagebot playlists 0.4.0.0 - Library and executable for working with playlist files.  https://hackage.haskell.org/package/playlists-0.4.0.0 (PeterJones)
11:18:06 <ertes> mappend :: MySum -> MySum -> MySum  -- it should just do addition
11:18:13 <jedai> Xyliton: No, you're just searching the complication where there are none
11:18:21 <ertes> mempty :: MySum  -- this should be the neutral element of addition
11:18:51 <ertes> Xyliton: just try it…  you will find it surprisingly simple to define it
11:19:29 <jedai> Xyliton: a type can be made an instance of the Monoid typeclass if you know a way to _combine_ two elements of this type in an associative manner (and there is a "neutral element, which just means like 0 for addition, or 1 for multiplication)
11:19:45 <younder> Xyliton, why not try this book: http://book.realworldhaskell.org/read/
11:20:08 <younder> Xyliton, It is available online and you get to get a taste
11:22:08 <lpaste> atondwal pasted “Xyliton: (*) Monoid Example” at http://lpaste.net/344525
11:23:08 <younder> Haskell isn't the easiest language to learn, but when you start to get to know it it brings  huge grin factor.
11:23:32 <jedai> Xyliton: so Int with the usual (+) operation (and 0 as neutral element) is a Monoid, or Int with (*) (and 1 as the Neutral Element)
11:23:58 <jedai> Xyliton: or [a] with (++) (and [] as neutral element)
11:24:19 <younder> concatinate (++)
11:24:51 <dfeuer> Ping conal 
11:25:30 <jedai> Xyliton: this seems fairly simple and not worth a typeclass but surprisingly there are many more useful Monoids, one that I particularly like is the one on Ordering that produce the lexical order
11:25:33 <EvanR> if Xyliton is confused at this point, theres any number of prereq concepts they may not know, and assuming they do would be silly.
11:26:00 <EvanR> so suggesting a resource would be best
11:26:02 <Xyliton> http://lpaste.net/344527 this is what I have right now
11:26:11 <jedai> EvanR: You're probably right... For instance I'm not sure if Xyliton has been exposed to typeclasses
11:26:17 <ertes> Xyliton: that's correct!
11:26:22 <Xyliton> ghci compiles that without an error
11:26:29 <Xyliton> but I can't use addition on that
11:26:31 <EvanR> or obviously monoids, but even operators, associativity, etc
11:26:34 <ertes> Xyliton: now with every Monoid instance comes a contract
11:26:46 <ertes> Xyliton: you can:  use 'mappend' or its alias (<>)
11:26:51 <ertes> > MySum 5 <> MySum 7
11:26:54 <Xyliton> ohh
11:26:54 <lambdabot>  MySum 12
11:27:12 <ertes> you need to import Data.Monoid for the alias
11:27:28 <jedai> > mconcat . map MySum $ [1..10]
11:27:31 <lambdabot>  MySum 55
11:27:33 <ertes> Xyliton: now that you defined this instance, you get a bunch of functions for free, for example mconcat
11:27:38 <ertes> what jedai just wrote
11:27:48 <EvanR> (<>) isnt in prelude yet?
11:27:52 <atondwal> woah, how does lambdabot know about `MySum`?
11:27:53 <jedai> Xyliton: an elaborate way of writing sum...
11:27:58 <jedai> EvanR: it is :)
11:28:03 * hackagebot playlists-http 0.1.0.0 - Library to glue together playlists and http-client  https://hackage.haskell.org/package/playlists-http-0.1.0.0 (PeterJones)
11:28:08 <ertes> atondwal: i told it secretly =)
11:28:13 <EvanR> good
11:28:31 <EvanR> everything i normally uses hould be in prelude, nothing more ;)
11:28:35 <ertes> Xyliton: oh, and you will find this helpful:  newtype MySum = MySum Integer  deriving (Eq, Ord, Show)
11:29:01 * sm tries Xyliton's game. Nice, needs a hanged man!
11:29:27 <ertes> Xyliton: anyway, the most important part about the Monoid type class can be found in its documentation: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html
11:29:53 <ertes> Xyliton: there is a contract associated with the Monoid class, namely that 'mappend' is associative, and that 'mempty' is the neutral element of 'mappend'
11:30:16 <ertes> this cannot be enforced by the type system, so you need to be careful
11:30:17 <Xyliton> is the neutral element something like the "default"?
11:30:41 <Xyliton> and what do you mean with "associative"?
11:30:50 <ertes> Xyliton: look at the docs, specifically: "instances should satisfy the following laws: …"
11:31:09 <ertes> these laws are the contract, and neutrality is given by laws 1 and 2
11:31:16 <maerwald> haskell is missing a proof assistant to verify the laws
11:31:20 <ertes> associativity is given by law 3
11:31:52 <jedai> Xyliton: just to give you a taste of how Monoid can be really nice, it turns out that comparison functions forms a Monoid, that allows one to write thing like : sortBy (comparing fst <> comparing (sum . snd)) which sorts pair (Int, [Int] ) first by looking at their first element then by looking at the sum of their second element
11:32:11 <c_wraith> I have received the occasional enlightenment from using an illegal Monoid instance. 
11:32:46 <Xyliton> so neutrality means that if one element is "empty" it will always return x? and associative means that brackets don't matter?
11:33:00 <ertes> yeah, if you write a wrong Monoid instance, GHC might delete your source files
11:33:12 <ertes> Xyliton: exactly =)
11:33:19 <c_wraith> not if it type checks. 
11:33:37 <Xyliton> Although I kinda understand how Monoids work now, I don't see why they would be useful? can't I just use normal numbers etc?
11:33:42 <c_wraith> (that was the best ghc bug.. to read about many years after the fact) 
11:33:43 <jedai> Xyliton: Right, same way as 0 + x = x + 0 = x and 1 * x = x *1 = x
11:34:06 <ski> Xyliton : another way to express the laws : `forall x. mconcat [x] = x' and `forall xss. mconcat (map mconcat xss) = mconcat (concat xss)'
11:34:23 <ertes> Xyliton: the point of structures like monoids is that you can abstract over them…  that's why you get lots of functions for free
11:34:27 <c_wraith> Xyliton, if you're using a concrete monoid, the abstraction means little. the value comes when you can write code that does something meaningful for all monoids 
11:34:28 <jedai> Xyliton: See my code for an exemple of Monoid being useful (there are ton of others but they're harder to put in a oneliner)
11:34:42 <atondwal> maerwald: have you played with liquidhaskell at all? it's actually pretty straightforward to prove Monoid laws in it!
11:34:48 <c_wraith> :t fold
11:34:50 <lambdabot> (Monoid m, Foldable t) => t m -> m
11:35:10 <ertes> > foldMap (MySum . toInteger . length) ["abc", "def", "ghi"]
11:35:11 <c_wraith> see? works meaningfully for all Monoids 
11:35:13 <lambdabot>  MySum 9
11:35:13 <ski> Xyliton : this implies that `mconcat [[x,y],[],[z]] = mconcat [x,y,mempty,z] = mconcat [x,y,z] = x <> y <> z', so extra `mempty's in the sequence of elements shouldn't matter, in addition to the bracketing of the sequence not mattering
11:35:25 <maerwald> atondwal: yes, too many rough edges
11:36:02 <ertes> Xyliton: if you look around the base library you will find countless functions with Monoid constraints in their types
11:36:11 <ertes> Xyliton: now all of these functions work for MySum – for free
11:36:38 <ski> Xyliton : the point of `mempty' and `(<>)'/`mappend', with their three laws, is that one can define a `mconcat' that works for any (finite) sequence of elements, and where grouping doesn't matter
11:38:03 * hackagebot amqp-worker 0.2.2 - High level functions for working with message queues  https://hackage.haskell.org/package/amqp-worker-0.2.2 (seanhess)
11:38:49 <ertes> Xyliton: if you look at my hangman example again you'll notice that i used foldMap, which i can use because there is a Monoid instance for Hangman…  it's not a huge function, but nevertheless i got it for free
11:38:56 <atondwal> maerwald: yeah, it's research software... but anything in particular you find particularly grating?
11:40:27 <Xyliton> ertes: I see that you are using mappend in your example, but it's a mystery to me how you used it :/
11:40:41 <atondwal> sorry about all the leave/join notifications... I just switched from weechat to xchat, and I'm not used to ^W not being delete backwards
11:40:58 <monochrom> heh
11:41:38 <ertes> Xyliton: let g1 and g2 be two hangman games…  imagine two boards with underscores and two game masters…  mappend combines them into one by concatenating the words and combining the game logics
11:41:46 <c_wraith> atondwal, don't worry, you haven't approached the level of spam a netsplit creates in here. 
11:41:49 <EvanR> an interesting sort of failure of the world wide web the just happened to me. in the commends of "monad for infinite search in finite time" someone lpasted some code here: http://lpaste.net/13260
11:42:05 <EvanR> however this is not that... its something else!
11:42:09 <EvanR> instead of 404 its "wrong"
11:42:57 <EvanR> like the lpaste database numbers reset at some point since 2008
11:43:42 <Xyliton> ertes: so you are creating many hangman "games" which all only "react" to one char, and then append them together so they are one "big" hangman game which "reacts" to a whole string?
11:43:54 <ertes> atondwal: in emacs C-w is kill-region (a.k.a. "cut")…  after the second time you accidentally closed the firefox tab while editing text you become *very* careful
11:43:56 * hackagebot playlists-http 0.1.0.0 - Library to glue together playlists and http-client  https://hackage.haskell.org/package/playlists-http-0.1.0.0 (PeterJones)
11:43:56 * hackagebot amqp-worker 0.2.2 - High level functions for working with message queues  https://hackage.haskell.org/package/amqp-worker-0.2.2 (seanhess)
11:44:20 <mniip> there's C-T for that
11:44:36 <mniip> C-S-t
11:44:41 <Xyliton> just reopen the firefox tab
11:44:49 <ertes> Xyliton: exactly
11:45:07 <ertes> mniip: yeah, but on some sites the text doesn't reappear
11:45:26 <Xyliton> ertes: and how do you pass the input between all of them?
11:45:51 <Xyliton> and how does it check if all are won?
11:46:03 <ertes> Xyliton:
11:46:05 <mniip> well, likewise I sometimes left :wq at the end of forms
11:46:18 <ertes> instance (Monoid b) => Monoid (a -> b)
11:46:26 <ertes> this instance is predefined
11:46:40 <ertes> > (reverse <> id) "abcde"
11:46:42 <lambdabot>  "edcbaabcde"
11:46:54 <ertes> Xyliton: mappend (Guess xs f) (Guess ys g) = Guess (xs <> ys) (f <> g)
11:47:08 <ertes> the (f <> g) part is actually a function (the second field of Guess)
11:47:19 <ertes> f <> g = \x -> f x <> g x
11:47:34 <ertes> x is the guess
11:47:44 <ertes> and mappend just hands it to both subgames
11:48:04 <atondwal> is there hangman code we can look at?
11:48:21 <ertes> atondwal: i'm currently talking about this one: https://github.com/esoeylemez/snippets/blob/master/Hangman.hs
11:48:42 <Xyliton> Now I don't understand it at all, again. I'm feeling so stupid right now ;-,
11:49:17 <ertes> Xyliton: don't feel stupid…  it can take a while to get used to these kinds of instances
11:49:36 <ertes> instance (Monoid b) => Monoid (a -> b)  -- does this make sense to you?
11:50:08 <Xyliton> this looks like a Monoid over a function which returns another Monoid
11:50:33 <ertes> in words:  if values of type 'b' form a monoid, then functions of type (a -> b) form a monoid, too
11:50:59 <Xyliton> so this is implication?
11:51:02 <ertes> with the following semantics:  mappend f g = \x -> mappend (f x) (g x)
11:51:33 * ski . o O ( pointwise/coordinatewise definition )
11:51:38 <Wizek> Hey, anyone knows if `system-ghc: true/false` can be specified for `stack build` as a cli argument just like it can be in stack.yaml?
11:51:47 <ertes> you could say that
11:51:55 <ski> (or direct product, if you will)
11:52:28 <ertes> Xyliton: String is a monoid, namely the concatenation monoid
11:52:35 <ertes> > "abc" <> "def"
11:52:37 <lambdabot>  "abcdef"
11:52:40 <ertes> Xyliton: good so far?
11:52:42 <ski> @src String
11:52:42 <lambdabot> type String = [Char]
11:52:48 <Xyliton> ,-,
11:53:07 <Xyliton> @src Char
11:53:08 <lambdabot> data Char = C# Char#
11:53:16 <Xyliton> :t String
11:53:18 <lambdabot> error:
11:53:18 <lambdabot>     • Data constructor not in scope: String
11:53:18 <lambdabot>     • Perhaps you meant one of these:
11:53:27 <Xyliton> um...
11:53:45 <monochrom> ":t" does not mean "general DWIM inquiry"
11:53:46 <Wizek> Hmm, apparently --[no-]system-ghc seems to have the desired effect. Last time I checked I don't remember that working or being documented.
11:54:03 <jedai> Xyliton: For Strings (or any lists since String is just a synonym for a list of Char), <> is concatenation (++) (and the neutral element is [] or "" if you want String notation)
11:54:05 <ertes> Xyliton: instance Monoid [a]  -- all list types form concatenation monoids
11:54:14 <ertes> > "abc" <> "def"
11:54:17 <lambdabot>  "abcdef"
11:54:22 <ertes> > [1,2,3] <> [4,5,6]
11:54:22 <ski> @kind String
11:54:26 <lambdabot> *
11:54:27 <lambdabot>  [1,2,3,4,5,6]
11:54:33 <ertes> Xyliton: does that make sense?
11:54:40 <functor> Oie
11:54:54 <Xyliton> makes sense
11:55:05 <ertes> Xyliton: ok, now let's focus on String
11:55:19 <ertes> instance (Monoid b) => Monoid (a -> b)
11:55:35 <ertes> since (Monoid String), there is an instance Monoid (a -> String)
11:56:12 <ertes> that's what the instance says…  so far so good?
11:56:31 <Xyliton> because String is a Monoid, every function returning String is a Monoid?
11:56:37 <ertes> correct
11:56:47 <Xyliton> okay
11:56:52 <ertes> (not the functions themselves, but their types)
11:56:56 <Tuplanolla> Next `Endo`?
11:57:23 <ertes> Xyliton: this particular monoid has the following semantics:  mappend f g = \x -> mappend (f x) (g x)
11:57:29 <jedai> Tuplanolla: I think this is building up to ertes Hangman type being a Monoid
11:57:42 <Xyliton> why are functions and their types separated?
11:57:57 <Tuplanolla> Oh.
11:58:05 <hiptobecubic> ertes, Xyliton don't forget that types aren't monoids unless you're also talking about the `mappend` operation with it.
11:58:08 <monochrom> because all values are separated from all types by a level line. value level vs type level
11:58:08 <jedai> Xyliton: in the same way that 5 is an Int but Int is not 5
11:58:12 <ertes> Xyliton: meaning that if you combine two String *functions*, the result being another function, the resulting function just passes its argument to both component functions and combines their results
11:58:53 <ertes> so: reverse <> id = \xs -> reverse xs <> id xs
11:59:39 <ertes> (remember that (<>) is just a more convenient name for mappend)
11:59:57 <ertes> mappend reverse id = \xs -> mappend (reverse xs) (id xs)
12:00:31 <Xyliton> so this just returns a function which returns the return values of reverse and id, "mappend"'ed?
12:00:39 <ertes> Xyliton: exactly
12:01:19 <Xyliton> what if these functions return functions, which then return strings? will this happen recursively?
12:01:27 <ertes> yes
12:01:29 <monochrom> :)
12:01:35 <Xyliton> okay
12:01:42 <mniip> hmm,
12:01:43 <ertes> and good question =)
12:01:45 <jedai> Xyliton: that's fine, this is how my exemple with comparison functions worked
12:01:58 <ski> @where monoids
12:01:58 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
12:01:58 <lambdabot> instance Monoid a => Monoid (rho -> a)'
12:02:18 <mniip> where can I find the implementation of the frost-hafiz-callhagan algorithm, is it on hackage?
12:03:11 <ertes> > (take <> const (const ",") <> drop) 4 "abcdefghijkl"
12:03:13 <lambdabot>  "abcd,efghijkl"
12:03:53 <Xyliton> will this mappend take and const(const",") first, and then mappend the result with drop?
12:04:05 <ertes> Xyliton: let's find out:
12:04:15 <Xyliton> also, why are you using const twice?
12:04:46 <ertes> (take <> const (const ",") <> drop) n xs = (take n <> const (const ",") n <> drop n) xs
12:04:55 <ertes> = (take n <> const "," <> drop n) xs
12:05:04 <ertes> = take n xs <> const "," xs <> drop n xs
12:05:09 <ertes> = take n xs <> "," <> drop n xs
12:05:30 <monochrom> @type const (const ",")
12:05:32 <lambdabot> b -> b1 -> [Char]
12:05:52 <monochrom> the type of functions you just asked about
12:06:16 <Xyliton> so this has to be called twice until it returns ","?
12:06:28 <monochrom> "Customers who have requested information on functions that return functions that return String may be interested in const (const ",") "
12:06:45 <ertes> Xyliton: it receives two arguments and ignores both
12:06:51 <monochrom> "Black Friday Week specials"
12:07:06 <ertes> (\n xs -> ",") = (\n -> const ",") = const (const ",")
12:07:28 <Xyliton> oh, i see
12:08:38 <Xyliton> and you did that because all the other functions also receive two arguments?
12:08:41 <ongy> :t const
12:08:43 <lambdabot> a -> b -> a
12:08:44 <ongy> :t const const const
12:08:46 <lambdabot> a -> b -> a
12:08:47 <ongy> this amuses me way to much
12:09:02 <monochrom> hehe
12:09:03 <ertes> Xyliton: yeah
12:10:15 <jedai> ertes: that's a nifty definition for splitAt (if a bit inefficient)
12:10:39 <Xyliton> you said that mappend is associtative... that only means that brackets don't matter, but order does, right?
12:11:00 <jedai> Xyliton: Right
12:11:23 <ertes> jedai: i didn't even consider that =)
12:11:29 <jedai> > (drop <> const (const ",") <> take) 4 "abcdefghijkl"
12:11:31 <lambdabot>  "efghijkl,abcd"
12:11:50 <jedai> ertes: Well I'm wrong since it doesn't retunr a pair but it looks like it does :D
12:12:15 <ertes> jedai: well, there is Applicative =)
12:12:33 <Xyliton> is that the same as " (take <> const (const ",") <> drop 4 "..." ", but reversed? :o 
12:12:39 <monochrom> it would be a pair in CSV :)
12:12:44 <ertes> :t liftA2 (liftA2 (,)) take drop
12:12:46 <lambdabot> Int -> [a] -> ([a], [a])
12:12:53 <jedai> Xyliton: Right, so as you said order does matter
12:12:59 <ertes> jedai: please don't use it
12:13:02 <Xyliton> *" (take <> const (const ",") <> drop) 4 "..." "
12:14:01 <ertes> Xyliton: associativity (brackets don't matter) ≠ commutativity (order doesn't matter)
12:14:23 <Xyliton> but what exactly is this function doing now? I know that it replaces the n'th char with ",", but how do the functions work together?
12:14:42 <monochrom> it doesn't replace. it inserts.
12:14:43 <ertes> Xyliton: it doesn't really *replace* anything
12:15:05 <monochrom> and it works by expansion. f<>g = \x -> f x <> g x
12:15:21 <younder> fine rfld is the thing, maximal non lazyness and full joy as it is the easiest. Did I say loop?
12:15:23 <Xyliton> is it "take"ing everything from 0 to n, inserts ",", and then appends everything from n to (length xs)?
12:15:52 <ertes> Xyliton: yeah, that sounds about right
12:17:02 <ertes> Xyliton: (take <> const (const ",") <> drop)  -- this is a function that, given arguments n and xs, returns the concatenation of (take n xs), "," and (drop n xs)
12:17:41 <Xyliton> ohh
12:17:42 <Xyliton> I see
12:18:06 <Xyliton> that's why you didn't give any arguments for take and drop, and made "," consume two arguments by using const
12:18:06 <ertes> just like burritos, isn't it?
12:18:17 <ertes> ignore that =)
12:18:26 <ertes> yeah
12:19:08 <joe9> any recommendations for understanding the types (the data structures used to represent data, type, newtype, etc)? I am a non-math guy, so, something basic would be very helpful.
12:19:47 <monochrom> my recommendation is to become a math guy.
12:19:52 <Xyliton> xD
12:19:55 <monochrom> or at least a logic guy.
12:20:10 <monochrom> types are best understood as a logic system (the proof kind)
12:20:25 <Xyliton> I'm more on the math side of things and I don't understand anything either
12:21:25 <monochrom> all intuitive, non-math-like (informal) explanations can't do justice to types.
12:21:55 <jedai> Right but that's not the math most people that say this are used to
12:21:58 <joe9> monochrom: I am trying to build a module using generics and I find that not knowing how the types are structured is a big handicap.
12:22:08 <jedai> So sometimes it agree better with them... 
12:22:17 <joe9> monochrom: Hence, I am trying to figure out how the data types are represented.
12:22:55 <joe9> monochrom:  for example, I see the conIsRecord. I understand that this means if the "constructor is a record". just want to get more details about such
12:23:00 <jedai> joe9: are you talking about the structure of the value in memory
12:23:10 <joe9> monochrom: Does that make sense?
12:23:46 <jedai> joe9: ok I think I see, you should probably read the paper on Generics
12:24:00 <monochrom> yes, but then you should ask about Haskell generics rather than "understand types" or "how to represent types"
12:24:14 <jedai> joe9: it wasn't too crazy if I remember correctly and you don't have to understand everything in it
12:24:44 <monochrom> never generalize your question.
12:24:51 <joe9> monochrom: just reading up on haskell generics is not helping as the material is mostly generic class specific. I find that not knowing how the types are represented is a big handicap.
12:25:20 <jedai> joe9: have you read https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Generics.html
12:25:23 <jedai> ?
12:26:16 <Tuplanolla> I think when people say they want a non-math presentation, they mean a presentation where the examples are not drawn from analysis or topology.
12:26:21 <jedai> joe9: Are you talking about the algebra of types ? there's not too many things to know there (at least when staying with normal ADT types)
12:26:53 <joe9> monochrom: I am writing a text based pretty printer https://github.com/joe9/GenericPretty/blob/master/src/Text/PrettyPrint/GenericPretty.hs . My issue is not just the Generics class or it's usage, but, understand how the types are represented.
12:27:12 <ertes> joe9: being familiar with "data types a la carte" would be very useful to understand generics
12:27:51 <joe9> jedai: https://github.com/sdiehl/cooking-generics I love how sdiehl parsed the data types on the fly.
12:27:51 <ertes> joe9: are you familiar with the concept of isomorphism?  A ≃ B
12:28:04 <atondwal> I think he's just looking for how values are laid out in-memory
12:28:11 <younder> etres congruence
12:28:19 <joe9> jedai: I understand the Generics portion and the instances Sum, Product, Unit, etc.
12:28:41 <ertes> ah, i see
12:28:43 <ertes> nevermind then
12:28:44 <joe9> what I am lacking is knowing how the different field constructors, such a fieldNames, etc.
12:30:10 <joe9> something less detailed than these docs: http://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-8.0.1/TyCon.html#t:TyCon
12:30:48 <monochrom> Huh? I don't think you need to know about the GHC API.
12:31:51 <monochrom> atondwal: It would be an epic XYZ problem to go from "I try to get generics to work" to "what happens in RAM"
12:32:32 <joe9> no, not how they are represented in memory. Just how they are represented in GHC types.
12:32:54 <joe9> as, that would help me figure out what I would do to pretty print a record, etc.
12:33:22 <younder> monochrom, In a nutshell, lazy is efficient, anything that evaluates the whole list like rfold is not. 
12:33:30 <joe9> for example, there is the function conIsRecord, How does it tell us if the constructor is a record?
12:33:59 <Xyliton> ertes: If I have a custom data type (let's just call it MySum again) how would I calculate the sum of a list of MySums? (if MySum won't have an mappend which does addition)
12:34:24 <monochrom> younder, you are not making a positive contribution. I ask you to stop.
12:35:43 <ertes> Xyliton: well, not via mconcat =)
12:36:15 <Xyliton> do I need to write a helper function which "extracts" the number somehow?
12:36:16 <ertes> Xyliton: for number types there are many possible monoid semantics…  we solve that by using newtype wrappers
12:36:36 <ertes> Xyliton: example:  instance (Num a) => Monoid (Sum a)
12:36:46 <ertes> > mconcat [Sum 2, Sum 3, Sum 4]
12:36:48 <lambdabot>  Sum {getSum = 9}
12:36:53 <Xyliton> what if it isn't a Monoid?
12:36:55 <ertes> > mconcat [Product 2, Product 3, Product 4]
12:36:57 <lambdabot>  Product {getProduct = 24}
12:37:24 <ertes> it doesn't have to be
12:37:28 <jedai> Xyliton: Well if it isn't a monoid, you suddenly don't have all those free functions anymore...
12:37:31 <ertes> Integer is not a monoid
12:37:47 <ertes> but Integer is a Num, and therefore Sum Integer is a monoid
12:37:50 <joe9> monochrom: Is the a -dump-deriv like phase that can show how the types are represented?
12:37:58 <ertes> read again:  instance (Num a) => Monoid (Sum a)
12:38:06 <ertes> and let a = Integer
12:38:35 <jedai> Xyliton: so you either *make* it a monoid (by wrapping the right newtype constructor around it like ertes is doing) or you write a monoid instance for your type (if it makes sense and is sane)
12:39:07 <monochrom> yes
12:39:17 <Xyliton> for every a of type Num there is a Monoid over "Sum a"? Or did I remember that the wrong way?
12:39:45 <ertes> Xyliton: for every type 'a' such that there is an instance (Num a), (Sum a) is a monoid
12:39:47 <monochrom> but I think ":kind! Rep Foo" is simpler
12:39:57 <ertes> Xyliton: (Num is not a type)
12:40:01 <monochrom> certainly less clutter
12:40:23 <Xyliton> num is a typeclass, correct?
12:40:31 <ertes> Num is, yeah
12:40:32 <Xyliton> or what was it?
12:40:36 <ertes> just like Monoid
12:40:45 <Monoide> yes?
12:41:10 <Xyliton> to get back to my "initial" problem with the "storage": I would define it like this: "data Storage = Storage Integer Integer". How would I get the sum of these, if I only care about the first Integer?
12:41:19 <Xyliton> should I make a Monoid for that?
12:41:40 <Xyliton> (the second integer is the id of the storage)
12:42:09 <ertes> doesn't look like a use case for monoids, unless you want to *combine* storages somehow
12:42:45 <Xyliton> not really. I only want the sum of the first integer, of a list of Storages
12:42:49 <joe9> monochrom: http://codepad.org/4SBu3zlK . Was the :kind! Rep Foo meant for me? There is not much info there.
12:43:10 <monochrom> you need the !
12:43:28 <monochrom> No, you already have the !
12:43:36 <monochrom> But that's not what I got.
12:43:56 <joe9> oh, really. What do you have? which version of ghc? 8.0.1?
12:44:03 <monochrom> 8.0.1
12:44:14 <monochrom> I get 10 lines like
12:44:21 <monochrom> Rep H :: * -> *
12:44:21 <monochrom> = D1
12:44:21 <monochrom>     ('MetaData "H" "Main" "main" 'False)
12:44:21 <monochrom>     (C1
12:44:21 <monochrom>        ('MetaCons "MkH" 'PrefixI 'False)
12:44:23 <monochrom> etc etc
12:44:36 <monochrom> How do I reproduce your problem?
12:44:44 <kuribas> Xyliton: "amount (Storage x _) = x" then "amount a + amount b"
12:44:46 <joe9> monochrom: ok, I am using 7.10.3
12:44:52 <joe9> monochrom: let me use 8
12:45:21 <jedai> Xyliton: You should probably just do "sum . map amount $ listOfStorages" with amount from kuribas
12:45:37 <monochrom> 7.10.3 gives me fewer lines but still non-trivial
12:45:44 <monochrom> Rep H :: * -> *
12:45:44 <monochrom> = D1
12:45:44 <monochrom>     Main.D1H
12:45:44 <monochrom>     (C1
12:45:44 <monochrom>        Main.C1_0H
12:45:44 <monochrom>        (S1 NoSelector (Rec0 Int) :*: S1 NoSelector (Rec0 Char)))
12:45:53 <monochrom> So how do I reproduce your problem?
12:46:37 <joe9> I just git cloned this repo https://github.com/sdiehl/cooking-generics and did stack repl in that folder
12:47:21 <monochrom> why are you not having "deriving Generic" left right and centre?
12:48:19 <joe9> http://codepad.org/upFTqQCg is the ghci session
12:48:44 <joe9> monochrom: where do you see the "deriving Generic"?
12:48:54 <monochrom> Nowhere. That's my point.
12:49:11 <Xyliton> How do I get all the permutations of a list?
12:49:32 <joe9> oh, ok. I need that for kind! to show the Rep. Thanks.
12:49:37 <Xyliton> derp, there's a function for that
12:49:37 <monochrom> I don't know what https://github.com/sdiehl/cooking-generics is doing, but it has nothing to do with GHC.Generics or "deriving Generic".
12:50:13 <monochrom> And looking through its code I don't even find any relevance to any general concept of generics, despite its URL.
12:51:00 <joe9> monochrom: Dump.hs is relevant.
12:51:22 <joe9> monochrom: It shows how Generics can be implemented
12:51:52 <joe9> monochrom:  without using deriving Generic. Understand how ghc represents the types and how to use that representation.
12:52:16 <joe9> monochrom: It is more of a learning material
12:52:20 <monochrom> That's an epic XY problem.
12:53:47 <monochrom> But it's your poison. https://github.com/sdiehl/cooking-generics is using the GHC API directly. (You know by seeing "import GHC".) Go wild and learn the GHC API completely.
12:54:28 <monochrom> I predict that it will take you a year. (I spent half a year and only learned like 10%.)
12:56:30 <joe9> monochrom: oh, wow. I did not realize that the task is that hard. Thanks for clearing it up.
12:56:54 <monochrom> Meanwhile, before talking to you today, I knew nothing about GHC.Generics. After, I took jedai's suggestion and read the doc of GHC.Generics for real. Well yes it's still information overload, but I saw the tips "-ddump-deriv" and ":kind! Rep Foo" and realized that I do not need to read a lot, I can just generate some examples and cargo-cult a bit. I feel that within two hours I will be able to actually use it.
12:58:53 <Xyliton> how do I make a list unique? (only checking if the elements are the same, not their position)
12:59:14 <ski> > nub "mississippi"
12:59:17 <lambdabot>  "misp"
13:00:28 <Xyliton> ski: didn't work for some reason :/
13:01:03 <MarcelineVQ> you need to `import Data.List` if you didn't
13:01:09 <jedai> Xyliton: *How* didn't it work ?
13:02:02 <Xyliton> jedai: here's the code: http://lpaste.net/344555
13:02:12 <Xyliton> it won't filter the list
13:02:36 <Xyliton> if I use a list like [Storage 1 1, Storage 9 2, Storage 3 3, Storage 7 4]
13:02:53 <Xyliton> getPerms should return one list, but it returns many lists
13:03:59 <jedai> Xyliton: nub check exact equality, not up to ordering
13:04:03 <joe9> monochrom: https://www.andres-loeh.de/DGP-Intro.pdf is a good one too.
13:04:22 <jedai> Xyliton: all permutations are different from nub point of view
13:04:54 <jedai> Xyliton: I'll also note that permutations only change the order of elements, so the sum will be the same for every one of them
13:06:11 <jedai> Xyliton: you probably don't want permutations but powerset (that is all subsets)
13:06:16 <Xyliton> jedai: true. Is it possible to filter all permutations and "sub-permutations"? (as in: also filtering the permutations of the list minus it's head, until it only has a single entry)
13:06:55 <younder> https://mail.haskell.org/pipermail/haskell-cafe/2003-June/004484.html
13:06:56 <ski> @type nubBy
13:06:58 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
13:07:03 <younder> no helping again
13:07:10 <jedai> Xyliton: In fact Data.List come with the function subsequences
13:07:38 <jedai> > subsequences [1..4]
13:07:41 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
13:07:49 <Xyliton> thank <3
13:08:35 <ski> > filterM (const [False,True]) [1 .. 4]
13:08:37 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
13:08:42 <jedai> Xyliton: that "may" not be the most efficient way to go though (but  I expect you knew that, it's O(2^n) complexity after all...)
13:09:21 <mniip> ski, I think it needs (fmap reverse .) and (. reverse)
13:09:51 <ski> i suppose so
13:10:04 <ski> @type filterM
13:10:06 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
13:10:45 <jedai> Xyliton: also if you want to try it on a big list (but stay modest, O(2^n) is monstrous) you absolutely have to compile your program with optimizations (-O2) because it will be bestially slow in ghci
13:10:57 <mniip> actually 'subsequences' is moree lazy
13:11:27 <mniip> @src filterM
13:11:27 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:11:49 <Xyliton> jedai: how else should I check for subsets which satisfy the requirement
13:13:28 <ertes> subsequences is super-lazy
13:13:32 <ertes> > subsequences [1..]
13:13:33 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
13:13:37 <jedai> Xyliton: usually you would use various strategy to avoid checking whole parts of the subsets (like any subsets that has too big a sum should be excluded and all subsets containing this subset (if negative numbers are not involved ?))
13:14:06 <mniip> @let filterM' p [] = pure []; filterM' p (x:xs) = map (bool (x:) id) (p x) <*> filterM' p xs
13:14:09 <lambdabot>  Defined.
13:14:12 <Xyliton> the size limit for the list I'm going to check is 20. is that too mucH?
13:14:15 <mniip> > filterM' (const [False,True]) [1 .. 4]
13:14:17 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
13:14:28 <Xyliton> *much
13:14:28 <jedai> Xyliton: Note that your current strategy is fine for *small* list of storages
13:14:41 * ski . o O ( `⌜⌞reverse⌟ Integer -> [⌞reverse⌟ Integer]⌝ (filterM @[] @ApplicativeListDict Integer (const @[Bool] @Integer [False,True])) [1 .. 4]' )
13:14:41 <mniip> hmm, that's the opposite and still needs a reverse
13:14:45 <mniip> @undefine
13:14:45 <lambdabot> Undefined.
13:14:56 <jedai> *small* here to be determined by your tries
13:15:11 <mniip> @let filterM' p [] = pure []; filterM' p (x:xs) = filterM' p xs <**> map (bool id (x:)) (p x)
13:15:13 <lambdabot>  Defined.
13:15:15 <mniip> > filterM' (const [False,True]) [1 .. 4]
13:15:18 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
13:15:19 <mniip> there we go
13:15:23 <ski> yay !
13:16:52 <Stuart> Hello
13:16:56 <younder> powerset
13:17:11 <ski> hello Stuart
13:17:35 <ertes> > filterM' (const [False, True]) [1..]
13:17:36 <Stuart> Hello ski, I am trying to understand how I can implement composible from the haskell book
13:17:38 <lambdabot>  *Exception: stack overflow
13:17:44 <ertes> mniip: still not the same
13:18:05 <mniip> hmm
13:18:07 <Stuart> (<*>) :: Compose f g (a -> b)
13:18:07 <Stuart> -> Compose f g a
13:18:07 <Stuart> -> Compose f g b
13:18:07 <Stuart> (Compose f) <*> (Compose a) = undefined
13:18:24 <ski> @type filterM'
13:18:25 <lambdabot> (t -> [Bool]) -> [t] -> [[t]]
13:18:38 <Stuart> I am finding the type system a bit strange 
13:18:42 <mniip> I guess <**> is more strict in the first argument than in the second
13:18:49 <mniip> unlike <*>
13:18:56 --- mode: ChanServ set +o monochrom
13:18:58 <ski> Stuart : could you repeat the definition of `Compose' ?
13:19:05 <mniip> rather, in the same way as <*> unlike 'flip <*>'
13:19:07 <Stuart> This is the definistion for compose is newtype Compose f g a = Compose { getCompose :: f (g a) }
13:19:29 <Xyliton> when breaking down functions into multiple lines should I indent them like this: http://lpaste.net/344562 or not indent?
13:19:33 <ski> Stuart : so in `(Compose f) <*> (Compose a) = undefined', you know :
13:19:36 --- mode: monochrom set +q *!*@ti0108a400-1289.bb.online.no
13:19:39 <ski>   Compose f :: Compose f g (a -> b)
13:19:41 <Xyliton> or indent in some other way?
13:19:47 --- mode: monochrom set -o monochrom
13:19:49 <ski>   (Compose a :: Compose f g a
13:19:55 <ski>   undefined :: Compose f g b
13:20:01 <Tuplanolla> There's no need to indent, Xyliton. Maybe if you have parentheses you can nest by level.
13:20:06 <ski> (er, sorry, stray bracket)
13:20:15 <ski> therefore, you also know
13:20:21 <ski>   f :: f (g (a -> b))
13:20:28 <ski>   a :: f (g a)
13:20:30 <Stuart> What I don't understand what f and a is in (Compose f) <*> (Compose a)
13:20:49 <ski> Stuart : btw, note that `f' and `a' in `(Compose f) <*> (Compose a) = undefined' are unrelated to the `f' and `a' in the type signature
13:21:10 <Xyliton> Tuplanolla: I'm more concerned about readability. Would the paste be more readable than this function without indentation?
13:21:34 <Tuplanolla> That's what I commented on, Xyliton. Styles vary wildly.
13:21:48 <ski> Stuart : do you know basic pattern-matching, e.g. on tuples, lists, `Maybe' ?
13:24:45 <Stuart> ski: Yes
13:26:29 <ski> Stuart : well, in `(Compose f) <*> (Compose a)', `Compose f' is the first argument, which has been constructed by the data constructor `Compose' from some data `f', having type `f (g (a -> b))' (in terms of the type signature of `(<*>)' here)
13:26:46 <ski> Stuart : and similarly for `Compose a', `a' there must have type `f (g a)'
13:27:36 <ski> Stuart : now your job is to figure out how to combine `f', of type `f (g (a -> b))', with `a', of type `f (g a)', in some (hopefully sensible way), to get a result of type `Compose f g b'
13:28:11 <ski> Stuart : .. perhaps the simplest would be to "start at the end", iow figure out how to construct the final value of type `Composse f g b'
13:28:19 <ski> and then work backwards from there
13:28:55 * hackagebot snaplet-sqlite-simple-jwt-auth 0.2.0.0 - Snaplet for JWT authentication with snaplet-sqlite-simple  https://hackage.haskell.org/package/snaplet-sqlite-simple-jwt-auth-0.2.0.0 (JanneHellsten)
13:32:39 <Xyliton> is there a function which let's me "filter" out a list and then apply either function a or function b, depending on if the entry satisfied the predicate?
13:32:59 <ertes> mniip: yours is equivalent to this one:
13:33:03 <ertes> > foldr (\x -> (>>= \xs -> [xs, x:xs])) [[]] "abc"
13:33:05 <lambdabot>  ["","a","b","ab","c","ac","bc","abc"]
13:33:18 <ertes> mniip: the problem is that both versions refer to 'xs' for the list head
13:33:43 <ertes> so the in order to know the head of the result, the full argument list has to be traversed
13:33:46 <jedai> Xyliton: you probably would build that with the partition function
13:34:10 <ertes> Xyliton: map (\x -> if p x then f x else g x)?
13:34:12 <jedai> Xyliton: or just a map
13:34:20 <jedai> yep ... :/
13:34:57 <Tuplanolla> I feel that the pointless version of that could look good, ertes.
13:35:03 <jedai> Xyliton: though I guess that depends if you want to separate your results depending on the criteria or not
13:35:12 <ertes> Tuplanolla: i don't really like 'bool' though
13:35:16 <ertes> :t bool
13:35:18 <lambdabot> a -> a -> Bool -> a
13:35:18 <ertes> scary
13:35:26 <Xyliton> jedai: I want to "refill" my storages, but only the ones with 0 as value
13:35:50 <jedai> Xyliton: so probably the map solution
13:36:17 <ertes> :t \f -> foldr (\x -> (>>= f x))
13:36:18 <lambdabot> (Foldable t, Monad m) => (t1 -> a -> m a) -> m a -> t t1 -> m a
13:36:26 <ertes> i'm using this *a lot*
13:36:29 <Tuplanolla> There's `if'` too, ertes.
13:36:36 <ertes> :t if'
13:36:38 <lambdabot> error:
13:36:38 <lambdabot>     • Variable not in scope: if'
13:36:38 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
13:36:44 <ertes> :m +Data.Bool
13:36:52 <ertes> @let import Data.Bool
13:36:53 <lambdabot>  Defined.
13:36:57 <ertes> :t if'
13:36:58 <lambdabot> error:
13:36:58 <lambdabot>     • Variable not in scope: if'
13:36:58 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
13:37:04 <ertes> Tuplanolla: there is?
13:37:15 <Tuplanolla> I know it's somewhere.
13:37:51 <ertes> isn't that basically the same thing?
13:38:02 <Stuart> ski: Sorry, was talking to mother-inlaw
13:38:08 <ski> nw
13:38:24 <Stuart> ski: so how do work backwards
13:38:38 <Stuart> I want to return a compose f g b
13:38:46 <Tuplanolla> :t ifThenElse -- It was actually called this, ertes, but yes, it's the same.
13:38:48 <lambdabot> Bool -> t -> t -> t
13:38:48 <ski> Stuart : well, you want to write an expression, in place of the `undefined', of type `Compose f g b', .. yes
13:38:50 <Stuart> we have (a -> b)
13:38:54 <geekosaur> if' doesn't exist, it's a figment of @pl's imagination
13:39:56 <MarcelineVQ> :>
13:40:12 <ski> Stuart : since the data type `Compose' is defined as `newtype Compose f g a = Compose { getCompose :: f (g a) }' (which you can imagine being just `Compose f g a = Compose (f (g a))', ignoring the record notation stuff), the only way to create a concrete value of type `Compose f g a' is to use an expression like `Compose blah', with `blah' of type `f (g a)'
13:40:17 <ski> Stuart : do you follow that ?
13:40:27 <suzu> :t bool
13:40:29 <lambdabot> a -> a -> Bool -> a
13:40:31 <suzu> wtf
13:40:39 <ski> @src bool
13:40:39 <lambdabot> bool f _ False = f
13:40:39 <lambdabot> bool _ t True  = t
13:40:40 <suzu> > bool 5 5 True
13:40:42 <lambdabot>  5
13:40:50 <suzu> oh lmao
13:40:59 <ski> @type either
13:41:00 <Stuart> ski: hmmm, thinking
13:41:01 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:41:01 <ski> @src either
13:41:01 <lambdabot> either f _ (Left x)  = f x
13:41:01 <lambdabot> either _ g (Right y) = g y
13:41:08 <ski> @type foldr
13:41:10 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:41:25 <ski> @type foldr :: (a -> b -> b) -> b -> [a] -> b
13:41:27 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:41:28 <ski> @src foldr
13:41:28 <lambdabot> foldr f z []     = z
13:41:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:41:31 <Stuart> ski Compose $ \g -> (g (f a)) 
13:41:48 <Stuart> ski that's not right
13:41:50 <ski> Stuart : let's take it slow, one step at a time, ok ?
13:42:39 <ski> suzu : anyway, those ^ are all examples of the same pattern (fold/catamorphism)
13:43:47 <ski> Stuart : anyway, in your case, you don't want to construct a value of type `Compose f g a', but rather of type `Compose f g b', and so in your case you'll use something like `Compose blah', where `blah' here would have type `f (g b)' (not `f (g a)')
13:43:52 <ski> Stuart : agree, so far ?
13:44:20 <Xyliton> How would I achieve this: map a list, and every time the argument for the function is 0, map it to the number of times 0 appeared?
13:44:23 <ertes> before you get used to the haskell way of thinking, get used to the haskell way of naming
13:45:02 <ski> Xyliton : "the number of times 0 appeared" -- so far, or the number of times overall in the whole list (or even across different lists ?) ?
13:45:13 <ertes> Xyliton: f [1,2,0,3,4,0,5,6] = [1,2,1,3,4,2,5,6]  -- like this?
13:45:22 <Xyliton> yep
13:45:56 <ski> Xyliton : `mapAccumL', or `mapM' on `State Integer' (or whatever numeric type you have)
13:46:15 <ski> @type mapAccumL
13:46:17 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:46:54 <ertes> > fst . foldr (\x ~(n, r) -> if x == 0 then (n + 1, n : r) else (n, x : r)) (1, []) $ [1,2,0,3,4,0,5,6,0]
13:46:57 <lambdabot>  4
13:46:58 <ski> `a' there is the type of your accumulator which is passed along from the left to the right, it'll be the number of times you've seen `0' in your case
13:46:59 <ertes> > snd . foldr (\x ~(n, r) -> if x == 0 then (n + 1, n : r) else (n, x : r)) (1, []) $ [1,2,0,3,4,0,5,6,0]
13:47:01 <lambdabot>  [1,2,3,3,4,2,5,6,1]
13:47:17 * ski leaves to Xyliton to figure out how to make `mapAccumL' do what they want
13:47:41 <ski> ertes : wrong direction :)
13:47:47 <ertes> yeah, i noticed =)
13:48:24 * ski looks at Stuart
13:51:48 <ertes> > foldr (\x r n -> if x == 0 then n : r (n + 1) else x : r n) mempty [1,2,0,3,4,0,5,6,0] 1
13:51:50 <lambdabot>  [1,2,1,3,4,2,5,6,3]
13:52:10 * ski leans to the right, falls over
13:53:00 <Xyliton> > mapAccumL (\a b -> (case b of { 0 -> a+1; _ -> a},case b of {0 -> a+1; _ -> b})) 0 [1,0,2,0,3,0,4,0]
13:53:02 <lambdabot>  (4,[1,1,2,2,3,3,4,4])
13:53:31 <Xyliton> seems to work :P
13:53:41 <ski> yeah, though you could factor the `case', i think ?
13:53:46 <Xyliton> how?
13:54:06 <Xyliton> is there a ternary operator in haskell?
13:54:41 <ertes> Xyliton: there is, but factor the case instead:  case b of 0 -> (a + 1, a + 1); _ -> (a, b)
13:54:50 <ski> > mapAccumL (\a b -> case b of {0 -> let a' = a+1 in (a',a'); _ -> (a,b)}) 0 [1,0,2,0,3,0,4,0]
13:54:52 <lambdabot>  (4,[1,1,2,2,3,3,4,4])
13:55:45 <ski> (however, i think that people too seldom use `case' or `if' or `let' inside subexpressions, so i'm happy that you tried that)
13:56:09 <Xyliton> I first tried if but that looked ugly IMO so I tried case :P
13:56:36 <ski> either would work here, with factored or non-factored
13:56:58 * ski sometimes uses `(if ... then ... else id) (...)'
13:57:36 <Tuplanolla> If you hate parentheses, you can even `x & if p then f else g`.
13:58:17 * ski doesn't see why people go to such lengths to use `$' to try to avoid brackets (often unsuccessfully)
13:58:56 * hackagebot obdd 0.4.0 - Ordered Reduced Binary Decision Diagrams  https://hackage.haskell.org/package/obdd-0.4.0 (JohannesWaldmann)
14:00:09 * ski . o O ( "Dr. Strangelisp or: How I Learned to Stop Worrying and Love the Bracket" )
14:00:59 * Clint smirks.
14:02:01 <monochrom> My theory is that they hate parentheses because they hated highschool math.
14:02:33 <Xyliton> tail gives me everything but the head, which functions gives me only the last item of a list?
14:02:45 <ski> > last "tail"
14:02:48 <lambdabot>  'l'
14:02:55 <ski> > init "tail"
14:02:58 <lambdabot>  "tai"
14:02:59 <tdammers> . o O ( What's wrong with parentheses [ or square brackets ) anyway? ]
14:03:17 <Xyliton> thanks :)
14:03:20 <kadoban> Xyliton: If you find yourself using that much, it probably means you have the wrong data structure or the wrong organization of data.
14:03:37 * ski suspects tdammers of being a racket maker
14:03:58 <ski> > tails "tail"
14:04:01 <lambdabot>  ["tail","ail","il","l",""]
14:04:02 <ski> > inits "tail"
14:04:05 <lambdabot>  ["","t","ta","tai","tail"]
14:05:08 <ski> re, Stuart
14:08:07 <Xyliton> why is this throwing a "Prelude.last: empty list" exception? http://lpaste.net/344572
14:09:45 <monochrom> superficially reason: last "" is a bad idea
14:09:53 <monochrom> or rather last [].
14:11:41 <monochrom> I am too lazy to debug this code, but "take a used" becomes [] at some point. Two ways it could be []: used is too short; a==0.
14:13:33 <kuribas> > set (partsOf (each.filtered (==0))) [1..] [1,2,0,3,4,0,5,6]
14:13:35 <lambdabot>  [1,2,1,3,4,2,5,6]
14:13:54 * ski claps
14:15:39 <Xyliton> monochrom: I fixed it thanks to you pointing out where the problem happened. It was quite a simple (and stupid) one: I used a (which is 0 in the first iteration) instead of a' as argument for take. And it seems like taking the 0th element of a list returns an empty list
14:16:07 <kuribas> ski: not sure that's what Xyliton wants or needs.
14:16:09 <geekosaur> muh? take doesn't take a specified element, it takes that many elements
14:16:21 <geekosaur> take 0 _ is quite reasonably []
14:16:40 <Xyliton> geekosaur: sorry, I kinda mixed that up :^)
14:16:50 <cath_> Does anyone know how to force stack to look for .so files in a shared directory instead of .dylib files on OSX?
14:17:05 <Xyliton> although I use "last $ take a' used" , so it technically takes the last item
14:17:08 <ski> kuribas : probably they wanted something simpler, that they're able to understand at this point
14:17:18 <monochrom> oh heh
14:18:34 <Xyliton> ski: yea, understanding the code I write is the most important thing for me. If I don't understand it, how am I supposed to tell others how it works? 
14:19:10 <kuribas> ski: yeah
14:22:08 <tdammers> Xyliton: I don't need to fully understand it; as long as I understand the kind of constraints and assumptions I want to make, write them down, and have the compiler tell me that they look good enough, I'm fine
14:22:33 <kuribas> ski: it maybe inefficient also.
14:28:40 <kuribas> > snd $ mapAccumLOf (each.filtered (==0)) (\s -> const (s, s+1)) 0 [1, 2, 0, 3, 0, 2, 0, 4]
14:28:43 <lambdabot>  [1,2,1,3,1,2,1,4]
14:29:10 <ertes> :t filtered
14:29:12 <lambdabot> (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
14:29:35 <kuribas> that didn't work...
14:29:36 <ertes> > (filtered .~ [1..]) [1,2,0,3,4,0,5,6,0]
14:29:38 <lambdabot>  error:
14:29:39 <lambdabot>      • Couldn't match type ‘p0 a’ with ‘Identity’
14:29:39 <lambdabot>        Expected type: ASetter (p0 a (f a)) (f a) a [Integer]
14:29:48 <ertes> > (filtered (== 0) .~ [1..]) [1,2,0,3,4,0,5,6,0]
14:29:50 <lambdabot>  error:
14:29:51 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M638190935536...
14:29:51 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
14:30:00 <Xyliton> I got to go. Thanks for all your help today <3 bye o/
14:30:02 <kuribas> > snd $ mapAccumLOf (each.filtered (==0)) (\s -> const (s+1, s)) 0 [1, 2, 0, 3, 0, 2, 0, 4]
14:30:04 <lambdabot>  [1,2,0,3,1,2,2,4]
14:32:25 <NemesisD> i've got too lists, [a, b] and [c, d] and i want to permute them in this way: [[a, c], [b, c], [a, d], [b, d]]. how do i do it?
14:33:04 <Tuplanolla> > sequenceA ["ab", "cd"]
14:33:07 <lambdabot>  ["ac","ad","bc","bd"]
14:33:57 * hackagebot sproxy2 1.90.1 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.90.1 (ip1981)
14:34:14 <NemesisD> not quite right
14:35:02 <NemesisD> was looking for "ac", "bc", "ad", "bd", in other words drawing from the first list completely for the first elemnt of the second list before moving onto the next element of the second list
14:36:41 <kuribas> > map reverse $ sequenceA ["cd", "ab"]
14:36:44 <lambdabot>  ["ac","bc","ad","bd"]
14:36:58 <NemesisD> i suppose i could do it with an explicit nested map
14:44:14 <mniip> hmm
14:45:23 <mniip> 'StateT [tok] []' or 'FreeT [] tok' are a nice type-theoretical way to construct parsing combinators for LL parsers
14:45:30 <mniip> is there anything of the sort for LR?
14:46:33 * ski would doubt it
14:47:09 <ski> (seeing how LR are bottom-up, and, afaiui, requires global knowledge)
14:47:39 <mniip> in that case I don't suppose any of the left recursion avoidance techniques map nicely to algebraic constructions?
14:59:10 <ph88> when i have a function   f :: Prs a => a -> a   how can i match on the data constructor ? i have only 2 instances of Prs .. so i should be able to match on them, no ?
14:59:16 <kuribas> lens is the opposite from perl, it's easy to read, hard to write.
14:59:37 <byorgey> ph88: no, you can't.
14:59:52 <Koterpillar> ph88: anyone can write a new instance
15:00:12 <byorgey> ph88: type information is erased before runtime.  So at runtime there is no way to tell which type you have.
15:00:14 <kuribas> ph88: you want to write a specific function for an instance?
15:00:16 <Koterpillar> ph88: you can add another member to it though, isThatOne :: Prs a => a -> Bool
15:00:26 <Koterpillar> isThatOtherOne :: Prs a => a -> Bool
15:00:28 <kuribas> ph88: you can do that with rewrite rules.
15:00:30 <ph88> ok but i have as last case   x = x   which should match all the other instances that are not covered
15:00:46 <Koterpillar> what do you actually want to do?
15:00:55 <Koterpillar> can f just go to the typeclass?
15:01:11 <Koterpillar> and you'd implement it for each type explicitly, and default to id
15:01:41 <ph88> still trying to come up with an alternative for the uniplate library
15:02:36 <kuribas> ph88: if you use rewrite rules, make sure both sides are actually equal.
15:02:47 <ph88> what are rewrite rules ?
15:03:05 <kuribas> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
15:03:52 <ph88> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules
15:04:23 <kuribas> ph88: it's only for performance though.
15:05:05 <ph88> i noticed uniplate uses multi param typeclasses for bidirectional plating
15:05:42 <ph88> ok this is not gonna work this way
15:05:54 <ph88> what about making a big sum type of all the types i have ?
15:06:25 <ph88> it's like 150 different types and i can do   data Sum = Type1 | Type2 | Type3  and so on .. and then i can go from   Sum to Sum
15:08:21 <jle`> you can use anonymous sums maybe
15:08:28 <jle`> if that's more convenient
15:08:32 <jle`> and you know what you want at compile-time
15:08:45 <mniip> anonymous sums?
15:08:51 <mniip> like Either or like (#|#) ?
15:09:03 <jle`> like Either
15:09:10 <jle`> or some of those multi-arity Either's on hackage
15:09:18 <jle`> that generalize either to N arguments
15:09:20 <Jello_Raptor> I'm not sure where I should be asking this, but I'm watching the "category theory for programmers" lectures, and through they seem to referring to categories as <notion of object, notion of morphism from object to object, notion of composition of morphisms, id morphisms for every object> but the definitions for epimorphisms and monomorphisms seem to also require a notion of equality between morphisms that isn't strictly dependent on 
15:09:20 <Jello_Raptor> the other parts of the definition of a category. Ami I missing something here?  
15:09:25 <jle`> but they are a big pain to pattern match on
15:09:28 <ph88> what's anonymous about the anonymous sums ?
15:09:43 <jle`> the same way that tuples are anonymous products
15:09:50 <ski> nothing, if they're like `Either' ?
15:09:57 <mniip> Jello_Raptor, yeah, CT is all about equality of morphisms and nothing about equality of objects
15:09:58 <Jello_Raptor> do categories also require a notion of equality of morphisms? 
15:10:11 <jle`> i guess they're not 'built into the language' and technically have a name so aren't anonymous
15:10:13 <ph88> jle`, you have a reference link for that ?
15:10:21 <mniip> it is kind of required to fullfill the "f . id = f" laws and the like
15:10:23 <jle`> i guess a better word should be 'generic' sums?
15:10:47 * ski 'd like to be able to write e.g. `(|| False|)' of type `forall a b d. ( a | b | Bool | d )'
15:11:02 <jle`> just like throwaway types that are sums where you don't care about "naming" what they are
15:11:15 <mniip> ski, well there's unboxed sums
15:11:15 <ski> light-weight variants, would also be nice
15:11:19 <jle`> you'd in theory use them the same way you'd use a tuple instead of just making a new data type for every "pair" you ever use
15:11:24 <ski> (called "polymorphic variants" in OCaml)
15:11:27 <mniip> but due to their unboxity they come with interesting performance quirks
15:11:41 <ski> mniip : unboxed values or unboxed continuations ?
15:11:51 <jle`> like, there's no reason to create a new data type every time you'd want to use a tuple.  and no reason to create a new sum type every time you use an Either
15:11:58 <mniip> unboxed sums
15:12:02 <kuribas> jle`: that would be nice.
15:12:28 <ph88> jle`, i mean a link to documentation about what you are describing
15:12:31 <jle`> ph88: one example of such an implementation is 'Sum Identity' from type-combinators
15:12:35 <jle`> http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Sum.html
15:12:50 <jle`> so, `Sum I '[Int, Bool, Int, String]`
15:13:03 <jle`> is a four-way sum tagged sum between int/bool/int/string
15:13:09 <jle`> but they are a huge hassle to pattern match on
15:13:24 <Jello_Raptor> mniip: I cam imagine two categories with objects A,B,C and arrows (f :: a -> b, f' :: a -> b, g :: b -> c) where one has (f . g == f' . g) and the other doesn't. But if the definition of category doesn't require a notion of equality, then those would seem to be equal. 
15:13:25 <jle`> i guess you could create pattern synonyms, but then you wouldn't have completeness checking yet in ghc
15:13:38 <Jello_Raptor> mniip: but yeah, I'm not sure why it's not explicit 
15:13:46 <ski> mniip : doesn't answer my question :)
15:14:13 <mniip> ski, the question seems malformed?
15:14:16 <jle`> hm, also i suppse 'base' already comes with anyonyms sums
15:14:28 <ski> jle` : "there's no reason to ..." -- exactly
15:14:28 <ph88> jle`, alright doesn't seem very attractive. You familiar with associated data ?
15:14:58 <jle`> as in data families?
15:15:00 <ph88> ya
15:15:29 <ski> mniip : if you have `foo :: [a] -> (# [a] | [a] #)', does that mean that it'll return a tag and a list, or that it'll pass two alternative continuations (iow return points) to the call ?
15:15:30 <jle`> i have worked with a couple in my dayds
15:15:32 <jle`> *days
15:16:02 <ph88> jle`, this guy mentions it http://stackoverflow.com/a/5758366 don't know what he means with "where you prove to the compiler that a data type is shared amongst all instances"
15:16:11 <mniip> I don't think I remember the calling convention for returning unboxed sums
15:18:31 <jomg> Jello_Raptor, a category still requires closure under composition. your first category would have one morphism a -> c, the other would have two
15:18:36 <jomg> if that helps you in any way
15:18:59 <ph88> eh this is maybe a stupid question  but when i do   data Foo = F String    and    data Sum = Foo | Int    the second Foo refers to the first Foo, no ?
15:18:59 * hackagebot amby 0.3.1 - Statistical data visualization  https://hackage.haskell.org/package/amby-0.3.1 (jsermeno)
15:19:08 <jle`> ph88: i'm not sure what don is thinking about there.  not sure how you can write a data family that would let you do what he's talking about
15:19:14 <jle`> ph88: no, it doesn't
15:19:25 <jle`> ph88: the second Foo is a data constructor on the value leve;
15:19:33 <jle`> they're in different scopes
15:19:39 <ski> mniip : fair enough
15:19:43 <ph88> ok another plan down the drain :/
15:19:44 <jle`> @let Hello = Int | Bool
15:19:44 <lambdabot>  Parse failed: Parse error: |
15:19:49 <jle`> @let data Hello = Int | Bool
15:19:50 <Jello_Raptor> jomg: ahh that makes sense. Or at the very least its a reasonable excuse to leaev it implicit. 
15:19:51 <lambdabot>  Defined.
15:19:51 <jle`> :t Int
15:19:53 <lambdabot> Hello
15:20:01 <jle`> ph88: there, Int is just a name for a value constructor
15:20:07 <jle`> it doesn't have anything to do with the 'Int' type
15:20:14 <jle`> it could have been named Nothing, Inty, etc.
15:20:27 <jle`> :t [Int, Bool]
15:20:28 <lambdabot> [Hello]
15:20:29 <ph88> i guess polymorphism is not going to help here
15:20:52 * ski wishes people would stop using the convention `newtype Blah = Blah ...'
15:21:07 <kuribas> ski: why?
15:21:07 <jle`> it's not going away
15:21:10 <jle`> :'(
15:21:19 <jle`> well, one of the first things we teach when teaching haskell is "don't do that"
15:21:27 <jle`> but then, 90% of newtypes in base and in common libraries do that
15:21:38 <jle`> so, i think it's more of a thing for beginners to help them not get confused
15:21:41 <ski> it's confusing, especially for newbies
15:22:02 <ski> and it doesn't make it easier to intermingle the value and type levels ("moving in the direction of dependent types")
15:22:06 <jle`> it might be just an issue for beginners in particular, but it does save a lot of cognitive overhead when you're already familiar with the language
15:22:20 <jle`> otherwise you'd have to remember/memorize the constructor name for every newtype
15:22:27 <hpc> what would you replace it with?
15:22:30 <ski> (for the same reason, i'm not fond of using the same notation for tuple types as for tuple values. also list types look like singleton lists)
15:22:44 <jle`> there's the convention of newtype Sum a = MkSum { getSum :: a }
15:22:50 <ski> the MLs use `A * B * C' instead of `(A,B,C)'
15:22:51 <jle`> ^ hpc 
15:23:10 <jle`> i see that a lot in DT languages
15:23:15 * ski knows this is probably a lost cause, but can still imagine
15:23:32 <jle`> maybe in a world where every haskeller develops in an IDE with tab completion fo rthings like these
15:23:41 * ski normally uses the `Mk'-convention, unless a more sensible name suggests itself
15:23:44 <jle`> so the extra cognitive burden is gon
15:24:01 <jle`> the Mk- convention is a little awkward in the pattern matching position though
15:24:11 <jle`> but yeah, if *everyone* did Mk-, then there wouldn't be a problem
15:24:20 <jle`> but maybe it's too late for that :'(
15:24:58 <Tuplanolla> At least it's not `My`.
15:25:12 <ski> that would be obnoxious ..
15:26:10 <jle`> maybethe convention can be to repeat the name twice
15:26:16 <jle`> newtype Sum a = SumSum { getSum :: a }
15:26:28 <jle`> this is something i can stand for
15:28:11 <jle`> is there a nice library for interfacing with external already-defined sql databases?
15:28:11 * ski thinks `Mk' nicely complements `get'/`run'/`un'/`app'
15:28:37 <Tuplanolla> Write the constructor in German. If it's the same, try another language. Repeat until a consistency of chaos is achieved.
15:28:37 <ph88> https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs lol :P
15:29:18 <jle`> lol
15:29:19 * ski . o O ( `data Vel a b = Sinister a | Dexter b' )
15:37:37 <EvanR> jle`: *-simple ?
15:37:53 <jle`> hm, yeah, i found a couple of those
15:37:56 <Shockk> hello, I've currently got a problem building glfw-b with stack lts-7.9
15:38:00 <jle`> going to look into it, thanks :)
15:38:33 <EvanR> though its postgres-simple... not postgres-nice ;)
15:38:47 <jle`> heh, i'm actually stuck with mysql at the moment
15:38:49 <jle`> despite my protests
15:39:09 <Shockk> I get the following error https://gist.githubusercontent.com/shockkolate/9fa7c2d50d5f4e5ea065fe4a1af0887d/raw/f64fb0ff11605f9a5143ec31366b87b8ac74cab5/glfw-error.log
15:39:09 <EvanR> not sure which name is more self serving
15:39:35 <Shockk> I'm confused about it because I don't think I ever got an error like this, back a few months ago when I was working on my code, and now I'm getting it
15:43:00 <Shockk> anyone have any ideas on how to fix this?
15:46:17 <sm> Shockk: tried a stack clean ?
15:46:49 <Shockk> sm: yep
15:46:50 <Shockk> :(
15:48:43 <Shockk> I tried an rm -rf .stack-work/ too, without any luck
15:49:00 * hackagebot rotating-log 0.4.1 - Size-limited, concurrent, automatically-rotating log writer.  https://hackage.haskell.org/package/rotating-log-0.4.1 (MichaelXavier)
15:50:07 <sm> perhaps you have an incompatible GLWF C lib installed ?
15:50:27 <Shockk> hmm
15:50:43 <sm> http://hackage.haskell.org/package/bindings-GLFW 3.1.2.2 seems to want "GLFW 3.1 released 2015-01-18"
15:50:49 <Shockk> that would be a problem; I've not installed the glfw lib yet since I'm on a new windows installation
15:51:02 <sm> ah
15:51:06 <Shockk> lol
15:55:39 <d34df00d> Hi! I'd like to tell the typechecker that `s'` uniquely determines `i` in the following code, but fundeps won't do since they require `i` to be present in the type parameters list. What alternatives do I have?
15:56:10 <d34df00d> http://melpon.org/wandbox/permlink/icqrSicw5DndH73j
15:56:56 <d34df00d> Type families would do the trick, but it seems to be possible to derive the type, so specifying the type explicitly seems like (unnecessary?) boilerplate.
15:57:58 <Shockk> sm: actually I'm not crazy I swear; I checked the bindings-GLFW repository and it includes the GLFW source in it; so I'm guessing the unknown symbol "strdup" is some problem with my compiler setup on windows/cygwin
15:58:17 <Shockk> I don't have vc++ installed for example which may be related somehow
15:58:18 <sm> GLFW includes the source, GLFW-b doesn't
15:58:27 <Shockk> GLFW-b repends on bindings-GLFW though
15:58:34 <sm> yeah.. not sure
15:59:18 <sm> maybe you were using an older version before
15:59:28 <Shockk> probably
15:59:40 <Shockk> I'm going to try installing the vc redist
16:00:04 <Shockk> will probably do nothing at all but it'll at least eliminate that as a possibility
16:03:06 <Shockk> nope that did nothing unfortunately
16:04:19 <Jello_Raptor> hm
16:07:09 <Shockk> hmm that's weird
16:07:39 <Jello_Raptor> There's got to be a better pattern for this: http://lpaste.net/344585
16:07:45 <Shockk> sm: with cabal, I tried first installing bindings-GLFW, which worked, then GLFW-b, which gives me that same error
16:08:03 <Jello_Raptor> One that doesn't require undecidable instances,
16:08:19 <Jello_Raptor> or promoting the Show constraints to the class definition 
16:08:47 <sm> can you use GLFW (not GLFW-b) instead ?
16:09:56 <Jello_Raptor> anyone have any ideas? or at the very least some way to show that using undecidable instances won't explode on e 
16:12:39 <Jello_Raptor> I want to say the fact that a Data family is bijective should mean there isn't a problem, expecially if no other module uses UndecidableInstances ,but Im not sure
16:25:10 <atondwal> Is there some clever way to pretend Hask is a groupoid instead of a category?
16:26:07 <atondwal> Concretely, I want all the Applicative, Functor, Alternative, etc stuff, but for `Iso`s instead of just `(->)`
16:26:59 <atondwal> I mean I could just define them all and there's probably something I could use in semigroup-extras, but there has to be a better way...
16:28:01 <atondwal> I suppose I spend a weekend writing in ML, and I start to wish Haskell modules were implicitly parameterized over ->
16:28:45 * ski . o O ( which ML ? )
16:40:40 <slack1256> I got an app with the graphical part and the core data type on the same thread. I can put each (with their own state) on separated threads, yet passing "commands" between the two can be bothersome (did i enumerate all the ways of interaction?)
16:40:59 <slack1256> I don't have much experience with GUI apps, is this a common pattern?
16:46:14 <sm> slack1256: folks sometimes do that to take advantage of nice GUI libs available in another language. What's the advantage of doing it in a single language ?
16:47:38 <slack1256> just force yourself into disciple (and your peers) on separation of concerns
16:48:31 <slack1256> sm: btw, that seems a cool way to do GUI programming in haskell. haskell backend, XXX frontend
16:48:52 <monochrom> the beauty of functional programming is that separation of concerns does not imply separation of threads.
16:49:21 <anks> Hi, having type like this: type Application = forall m. ReaderT (Services m) m
16:49:29 <anks> How would I ever run it?
16:49:55 <monochrom> for example if you do so much as "consumer . filter_out_unwanted . producer" you're already doing separation of concerns perfectly.
16:50:00 <anks> If i pass concrete services to runReaderT it doesnt compile ;/
16:50:19 <dfeuer> Is there anything in lens like Ixed but that can't fail? That is, when the "index" is guaranteed to be present?
16:50:27 <ski> anks : pick some particular type for `m' ?
16:50:36 <dfeuer> Well, I guess I mean more like ix in Ixed,
16:51:07 <dfeuer> er... no, actually I do mean like Ixed.
16:51:20 <anks> well I do pick services implemented for IO
16:51:36 <ski> anks : "it doesnt compile" isn't specific. what is the compile error ?
16:52:27 <anks> couldnt match type ‘forall (m :: * -> *). ReaderT (Services m) m’ with ‘ReaderT (Services IO) IO’
16:52:27 <anks>  
16:52:46 <roboguy`> anks: why do you have a forall there?
16:52:47 <monochrom> are you sure you need "forall m"?
16:53:01 <Axman6> dfeuer: what's wrong with ix?
16:53:11 <dfeuer> We have  ix :: Index m -> Traversal' m (IxValue m). I'm looking for ixSure :: Index m -> Lens' m (IxValue m)
16:53:34 <anks> I kinda need it, so I can have only one Application type abstracted over all monads
16:53:40 <slack1256> that separation of concerns has to do with the classic producer consumer step lock. A good composition operator is the answer to that. But here I mean an ADT the represent the current state and user input that sets flags on such ADT. This separation of concerns is about enforcing at level of architecture, the semantic level you want.
16:53:42 <glguy> Demo.hs:3:1: error: It doesnt compile
16:54:05 <dfeuer> Axman6, it has the wrong type (see above)
16:54:11 <Axman6> anks: that doesn't sound like you want that
16:54:11 <anks> Look at this: http://www.parsonsmatt.org/2016/07/14/rank_n_classy_limited_effects.html
16:54:17 <monochrom> I don't think you know either what "abstracted over all monads" means or what kind of abstraction "forall" gives you.
16:54:21 <Koterpillar> dfeuer: singular
16:54:26 <Koterpillar> :t singular . ix
16:54:28 <lambdabot> (Ixed t, Functor f) => Index t -> Over (->) f t t (IxValue t) (IxValue t)
16:54:36 <Axman6> dfeuer: you can always treat a traversal as if it always succeeds with things like ^?!
16:54:39 <Koterpillar> :t singular (ix 2)
16:54:41 <lambdabot> (Ixed t, Num (Index t), Functor f) => Over (->) f t t (IxValue t) (IxValue t)
16:54:54 <Axman6> :t singular
16:54:55 <lambdabot> (Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
16:55:02 <monochrom> At any rate it's time to see actual code.
16:55:24 <dfeuer> Koterpillar, Axman6, so you don't think there's an actual class for that?
16:55:38 <dfeuer> I mean, there actually *is* one.
16:55:41 <dfeuer> But it doesn't match lens.
16:55:48 <dfeuer> (i.e., Representable)
16:55:50 * ski agrees with monochrom
16:57:00 <dfeuer> I can certainly write  ixSure :: Representable f => Rep f -> Lens' (f a) a, but that has a more polymorphic sort of type than lens usually deals with.
16:57:50 * ski . o O ( `(Disjoined s,Functor f) => Alternating t a n s t a a f l -> Under t a n s t a a f l')
16:58:06 <dfeuer> ski, what does that junk even mean?
16:58:11 <glguy> It's a joke
16:58:26 <dfeuer> there ain't no such thing as a free lunch....
16:58:51 <monochrom> indeed, there isn't such thing as non-insider joke.
17:00:18 <hpc> i think if you actually implemented that saying, you'd end up with backwards lexical scoping
17:00:22 <hpc> you could use bound lunch
17:00:26 <hpc> \lunch -> whatever
17:00:45 <hpc> but it could never occur free, so \lunch -> \x -> lunch would be a scoping error
17:01:53 <hpc> it would also be pretty much unusable as a language ;)
17:02:05 * ski . o O ( strange scoping with linear logic types )
17:02:16 <monochrom> yeah, backwards lexical scoping, I'm too tired to imagine what it's like
17:02:47 <c_wraith> hpc, there are languages with only global scope. nothing free! 
17:02:48 <anks> Axman6: if I used for type such as type Application m = ReaderT (Services m) m, I'd have to specify my application target intepretation monad upfront
17:02:58 <hpc> ah, that works too
17:03:17 <anks> what i want is that this type is derived from passed (to runReaderT) Services type
17:04:20 <anks> im probly still pretty lame and this type level thingies :|
17:04:28 <anks> at
17:04:48 <roboguy`> anks: we would definitely be able help more with code...
17:05:04 <roboguy`> but consider the fact that you cannot, in general, just "run" any monad
17:06:42 <roboguy`> If you do need that forall, you probably also need a constraint on it (maybe MonadIO)
17:09:32 <anks> pastebin.com/eeT2Dxw7 if I replace the code from commented lines it gives me the aforementioned error
17:10:41 <anks> ahh and the 2nd parameter to runReaderT is of type Services IO
17:14:01 <monochrom> If you want to put back "forall m" into the definition of "Application", I wonder what is the type of "Services testLogService".
17:15:32 <anks> It is Services IO
17:15:52 <monochrom> OK, then it should work.
17:15:57 <anks> damn
17:17:26 <anks> no luck here, and of course the commented line of above application type should be: 
17:17:26 <anks> type Application = forall m. ReaderT (Services m) m
17:17:36 <n_blownapart> hi is it possible to change the Main.hs in a stack project to any name? I tried but at compile the file is not recognized. 
17:17:55 <sm> you'll have to change it in the cabal file too
17:18:09 <n_blownapart> cool thanks sm
17:18:15 <sm> add a main-is: File.hs in the executable section
17:18:39 <n_blownapart> please elaborate
17:18:42 <n_blownapart> sm
17:19:01 <anks> n_blownapart:  this is the change in cabal file.
17:19:04 <monochrom> What is the verbatim error message?
17:19:31 <anks> monochrom: Couldn't match type ‘forall (m :: * -> *). ReaderT (Services m) m’ with ‘ReaderT (Services IO) IO’
17:19:31 <anks>  
17:19:52 <n_blownapart> oh main-is: is like an assignment, I see. 
17:21:00 <roboguy`> anks: what sort of ms do you want to use? It looks like, ultimately, you will want all of them to be able to be transformed into IO
17:21:01 <athan> anks: That means you need to make `m` equal to `IO` somehow
17:21:16 <roboguy`> if that's the case, that's exactly what a MonadIO constraint next to the forall would give you
17:21:42 <roboguy`> oh wait, that would be the opposite wouldn't it
17:22:21 <monochrom> athan: No no, I think it's something else. Have this example: (turn on all necessary extensions)  type A = forall m. Either m; g :: A Int; g = Right 4.  What is going to happen?
17:23:14 <ski> monochrom : `forall m. Either m', kind error ?
17:23:17 <monochrom> You will have to change it to "type A t = forall m. Either m t". Similarly for Application, "type Application t = forall m. ReaderT (Service m) m t"
17:23:37 <monochrom> You know what, I don't even know what kind of error this error is. :)
17:23:41 <athan> ahh oops :x
17:24:02 <monochrom> But consider "(forall m. Either m) Int". Does it make sense?
17:24:06 <anks> lol
17:24:17 <roboguy`> I would think you will also need to pass around an interpreter function. Something like "type Application a = forall m. (ReaderT (Service m) m a, (forall x. m x -> IO x))"
17:24:38 <monochrom> If I use "g = undefined" instead, I get a much better clue of what GHC thinks of it.
17:24:43 <anks> it did compile
17:24:53 <anks>  type Application a = forall m. ReaderT (Services m) m a
17:25:00 <monochrom> On GHC 7.10.3, it is accepted.  On GHC 8.0.1, the error is "I don't do impredicative types"
17:25:09 <anks> i somehow curried the type and thought it'd work
17:25:23 <monochrom> So I think the ultimate problem with "(forall m. blah blah) Int" is impredicative types.
17:25:23 <ski> s/curried/attempted eta-reduction/
17:25:59 <anks> well, problem solved :) thank you guys
17:27:05 <anks> and roboguy` : you're right i'd probably (in the end) want it transformed to IO
17:27:48 <ski> monochrom : hm, this is strange. why is `(forall m. Either m) Int' even allowed ?
17:28:17 <monochrom> the type alias "type Application = ..." or "type Application a = ..." proves to be a negative contribution.
17:28:36 <monochrom> 7.10.3 probably still tried to allow impredicative types
17:30:09 <monochrom> If you write "app1 :: ReaderT m (Service m) ()" it's unproblematic, readable, and just as effect-limiting as you want.
17:31:04 <monochrom> If you like emphases you can always add "forall m." there too.
17:31:45 <monochrom> once again, type synonyms prove to be leaky abstractions.
17:32:09 <anks> monochrom: i guess you're right
17:32:24 <anks> after all it's not the scariest type to read
17:32:25 <monochrom> leaky abstractions are the #1 cause of why "the real world is complicated". It's self-inflicted.
17:38:17 <dfeuer> Ping edwardk 
17:39:10 <dibblego> can we stop calling them leaky abstractions and start calling them not anything at all like abstractions, yet?
17:39:20 <anks> Another thing. Now i have this effect limiting monad that enables me to inject various interpreters depending on my needs. But all of my "effect accessing logic" now has to happen in this monad. If there are a lot of different effects/services it'll start getting pointless. What i'd love to see it some kind of extra constraints or labels on types so could write functions limited to only a subset of these effects. What are the
17:39:20 <anks> possibilities here and where should I start? ; )
17:40:22 <Rotaerk> leaky abstractions are abstractions, just poorly chosen ones
17:40:35 <dibblego> I'll take that as a no.
17:41:17 <Rotaerk> well, maybe I'm thinking of something else, actually
17:42:05 <Rotaerk> an abstraction that starts abstract, but then later turns out to be bad, and then details are pushed through to compensate, making the abstraction pointless
17:42:33 <Rotaerk> s/bad/limiting to the ability to implement some new feature/
17:43:30 <monochrom> "leaky abstraction" is a phrase people understand to refer to failed, flawed, should-not-have-been-born, misguided-attempt-at abstraction, so I use it.
17:44:17 <zyhn> how do I make an immutable copy of an IOVector? freeze wants an MVector (PrimState m) a, but IOVector is a synonym for MVector RealWorld
17:44:35 <dibblego> I agree, but if we can start calling it what it actually is, maybe there would be less of it :)
17:44:52 <monochrom> I would love to call it "hypocritic, pretended, are you abstracting or are you not?" if there were not already a common term.
17:45:06 <dibblego> you are I, again, are on the same team
17:47:18 <monochrom> Oh! I have the perfect description from Feynman. "You give it a name so you can pretend you understand it."
17:47:39 <dibblego> heh
17:47:59 <dibblego> I like Runar's, "dependency injection is just the pretentious name for passing an argument to a function."
17:49:12 <wespiser> dibblego: this is how we know we are programming in Haskell
17:49:20 <wespiser> its not a fold, its a catamorphism
17:50:19 <monochrom> I just say "fold" or "foldr" for those who do not already know the word "catamorphism".
17:51:00 <dibblego> Studying aviation meteorology you'll come across anabatic and katabatic winds.
17:51:11 <dibblego> That was nice to be able to think, "been here already"
17:51:16 <Rotaerk> at least with how they teach you about abstraction in school, with OOP, you tend to pick your abstraction based on the instances you have
17:51:20 <monochrom> neato
17:51:38 <Rotaerk> like... I have a Dog class and a Cat class... they're both animals so let's make an Animal abstraction
17:51:56 <dibblego> I once lectured a subject called Object Oriented Analysis and Design, around 2002, and I probably said the word "abstraction" a lot in those lectures, but I am certain I was never talking about abstraction.
17:51:59 * ski . o O ( <https://en.wikipedia.org/wiki/Adiabatic_process> )
17:52:53 <Rotaerk> but you end up with Animal being a completely open-ended collection of methods, and every method you add needs to be implemented by Cat and Dog
17:53:05 <Rotaerk> since there's no fixed notion of what it means to be an animal...
17:53:23 <LordBrain> hmm
17:53:45 <dibblego> let us call that, "confusion" and not "abstraction", since while still maybe inaccurate, has got to be closer
17:54:27 <monochrom> this inspires me to visualize that people love OOP because it gives them license legitimize DWIM
17:54:31 <hpc> it's a refactoring that doesn't abstract
17:54:48 <ski> how about "profusion", sounds more positive, no ?
17:55:00 <Rotaerk> taxonomization?
17:56:37 <Rotaerk> the reason they do that is because they think "A is (conceptually) a B" implies that "class CA representing A should derive from class CB representing B"
17:56:56 <Rotaerk> so it's a kind of taxonomy
17:57:43 <monochrom> true
17:57:55 <slack1256> DWIM?
17:58:03 <ski> Do What I Mean
17:58:34 <slack1256> but I don't know you :-)
17:59:40 <jle`> hey
17:59:45 <jle`> why aren't empty record updates allowed
18:00:45 <dfeuer> jle`, because Template Haskell didn't exist when the syntax was designed?
18:00:45 <ski> > False {}  -- ?
18:00:49 <lambdabot>  False
18:01:06 <ski> > False {} {}  -- oh
18:01:08 <lambdabot>  error: Empty record update
18:01:20 <dfeuer> > (3,4) {}
18:01:22 <lambdabot>  error: Empty record update
18:02:22 <Koterpillar> > (\x -> x x) {}
18:02:25 <lambdabot>  error: Empty record update
18:03:06 <slack1256> @type (\x -> x x)
18:03:08 <lambdabot> error:
18:03:08 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
18:03:08 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
18:03:10 <ski> > [() | let in case () of]
18:03:13 <lambdabot>  *Exception: <interactive>:3:14-17: Non-exhaustive patterns in case
18:03:16 <hpc> wait, how did False {} work?
18:03:23 <ski> > [() | let]
18:03:25 <lambdabot>  [()]
18:03:29 <ski> hpc : empty record construction
18:03:34 <hpc> ah
18:03:39 <hpc> that's a goofy distinction
18:03:47 <ski> indeed
18:04:00 * ski would've expected both to work, or neither
18:04:12 <dfeuer> Haskell record syntax is basically bad.
18:04:37 <hpc> we should make it complicatedly bad instead
18:04:37 <slack1256> for an optional feature, what are my options apart from CPP ?
18:04:41 <dfeuer> And the record syntax extensions piled on top of it don't strike me as likely to be such hot ideas either, for the most part.
18:05:45 <hpc> slack1256: how do you mean optional feature?
18:06:33 <jle`> > (Just 1) {}
18:06:35 <lambdabot>  error: Empty record update
18:06:42 <jle`> > (Sum 1) {}
18:06:45 <lambdabot>  error: Empty record update
18:06:47 <jle`> :(
18:06:57 <slack1256> something that will be selected by a cabal flag to be compiled. Ideally will add new extra logic on the program
18:07:01 <hpc> > Just {}
18:07:03 <lambdabot>  Just *Exception: <interactive>:3:1-7: Missing field in record construction
18:07:57 <hpc> you can also do conditionals in the cabal file
18:08:54 <danilo2> Hello guys! Is there any flag in GHC that will just not allow for partial pattern matches? I just want to throw compiler error on anything similar to (Just a = f x)
18:09:13 <hpc> conditionally adding source directories or something like that
18:10:14 <slack1256> danilo2: ghc -W -o main <etc>
18:10:45 <hpc> all in all it's just another check in the -Wall
18:11:10 * ski smiles
18:11:23 <danilo2> slack1256, hpc : it wont throw error, will it?
18:11:30 <danilo2> I mean, it will just put warning
18:11:36 <hpc> -Werror will fix that
18:12:33 <danilo2> hpc: will -Werror throw error for each warning from -Wall? If so, is there a way to throw only from selected ones?
18:12:56 <hpc> maybe?
18:13:39 <danilo2> hpc: Makes any warning into a fatal error. Useful so that you don't miss warnings when doing batch compilation.
18:13:40 <slack1256> ghc -W -o main <etc> && rm main 
18:13:42 <slack1256> :-)
18:13:52 <danilo2> hpc: so yes it will raise every worning then
18:14:14 <hpc> oh, it'll definitely do that
18:14:20 <hpc> "maybe?" was to the second question
18:15:05 <danilo2> hpc: oh ok, thanks ! :) Hmm, that would be great. I just didnt found any option allowing for it
18:15:08 <danilo2> *yet
18:15:53 <slack1256> ghc -W -o main <etc> 2>doom ; if expr $(wc -m <doom) > 1 ; rm main ; false ; fi
18:16:39 <slack1256> well -gt instead of > 1, but you get the gist
18:17:14 <hpc> "fi" :(
18:17:37 <hpc> if you're going to use non-trivial features of a language as bad as bash, go all the way and use "esac"
18:17:57 * hpc forgets if that's the silliest keyword it has
18:18:37 * slack1256 needs to compile hugs to use it like he uses gawk on his shell
18:19:36 <hpc> my favorite keyword in any language is 1.2.840.113556.1.4.803
18:19:53 <hpc> which is bitwise AND in active directory LDAP
18:20:33 <danilo2> slack1256: hehe funny, yeah it will work this way. Still I prefer just stop building when error is found than just looking for errors after the build
18:22:34 <danilo2> By the way, I've just found SO thread about it: http://stackoverflow.com/questions/5936406/can-ghc-treat-certain-specified-warnings-as-errors-and-others-as-warnings
18:22:52 <slack1256> yeah, but you also wanted all the warning in one go, so that was at odds with stopping at the first warning
18:23:43 <danilo2> slack1256: I want all warnigns and stops only on incompete patternmatches
18:24:31 <slack1256> I misunderstood then
18:26:19 <chachi> Question: I'm working through the NICTA course, and they wrote a function getFile :: FilePath -> IO (FilePath, String) as liftA2 (<$>) (,) readFile.  I wrote a function that works using do notation, but am trying to understand the solution given.  I have what I think is a reasonbal understanding of applicatives, but I'm struggling to parse that one-liner.  Any pointers?
18:26:57 <slack1256> danilo2: -Wwarn: Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a -Werror flag.
18:27:03 <ski> chachi : `liftA2' is using the `(rho ->)' idiom (in this case `rho = FilePath')
18:27:26 <dibblego> chachi: liftA2 is using the ((->) t) instance of Applicative, which is in Applicative.hs
18:27:27 <danilo2> slack1256: yep, but it didnt allow for negating only selected warnings
18:28:06 <dibblego> (liftA2 :: (a -> b -> c) -> f a -> f b -> f c) where each instead of (f) becomes (t ->) for this case.
18:28:15 <slack1256> so maybe $ ghc -w -fwarn-incomplete-patterns -Werror -Wwarn -W  ?
18:39:01 <chachi> Wow, you guys are fast, thanks!  I'll dig back into the HaskellBook chapter on Reader, where ((->) t) is covered in more detail.  Any other suggestions for places to look for exercises that I can play around with to get an intuition for it?  I've read things like Learn You a Haskell and even already worked through HaskellBook once, but I need reps.
18:39:29 <dibblego> chachi: I wrote those exercises :)
18:40:07 <dibblego> the intution for reader, given do-notation, is to see repeated function application to the same value
18:41:14 <ski> chachi : perhaps Typeclassopedia ?
18:43:23 <chachi> dibblego: Good stuff. :)  I'll go back and do them again.  Sometimes I just need to repeat until it hurts and then repeat some more until my brain actually comprehends what it's doing.
18:43:25 <Axman6> chachi: that one-liner is equivalent to getFile fn = (\content -> (fn,content)) <$> readFile fn. 
18:43:59 <Axman6> chachi: understanding the transformation between the two is a lot easier when you're in the course with dibblego and I and he does it over and over again :P
18:44:36 <dibblego> how many arguments does the liftA2 function take?
18:46:04 <chachi> Axman6, dibblego: is the course available anytime soon?  I saw it was given at LambdaConf but I couldn't make it.
18:46:16 * Axman6 repeats the mantra: All functions only take one argument, All functions only take one argument. All functions...
18:46:34 <Axman6> chachi: we gave it in Canberra last week and Sydney the month before
18:46:37 * monochrom repeats his joke
18:46:42 <monochrom> @quote monochrom 17-ary
18:46:43 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
18:47:07 <dibblego> chachi: I don't know anything about it at lambdaconf
18:47:13 <chachi> dibblego, Axman6:  I almost said three but I caught myself. :)  So, Sydney, Canberra, I'm guessing you don't have travel plans to Cleveland Ohio.
18:47:37 <Axman6> chachi: anything's possibly with $$$ :)
18:47:52 <Axman6> dibblego: Tour of the US?
18:48:04 <Axman6> spreading the gospel of lambda?
18:48:12 <dibblego> sure
18:53:46 <chachi> dibblego, Axman6: I wish I had that kind of dough.  I feel lucky that I don't mind shelling out for the occasional book, since so many learners seem reluctant.  I've worked through the types there and got them to line up finally.  So in practice when you're writing a function FilePath -> IO (FilePath, String) how do you approach it?
18:54:22 <dibblego> "I have a FilePath and I need to produce a value :: IO (FilePath, String). How do I produce that value?"
18:54:59 <dibblego> typically, the types restrict the number of possible answers, but without the types, you have to also follow the "instructions"
18:55:24 <dibblego> \p -> pure (p, p) -- this is a type-checking answer. It is an incorrect answer. 
18:56:02 <tnks> why is this defined as this "instance e ~ SomeException => MonadMask (Either e)" instead of this "instance MonadMask (Either SomeException)"?
18:56:15 <tnks> I'm still trying to understand `~`
18:58:48 <Axman6> tnks: it means type equality, it says that e is SimeException
18:58:53 <Axman6> SomeException*
18:59:03 <byorgey> tnks: the first instance matches anything of the form  Either e,  and forces e to be SomeException.  The second only matches  Either SomeException.  i.e. in the second case the argument to Either must already be known to be SomeException.  In the first case e may still be ambiguous but the instance itself makes e known.
19:04:06 <jle`> why isn't there a PathPiece instance for UTCTime by default in persistent ... UTCTime is even used in the tutorial
19:04:21 <jle`> are the code examples even tested lol
19:05:15 <jle`> oh quote from snoyman, "I think we didn't put it in because it's a little tricky to get the serialization just right"
19:05:32 <jle`> but then, why use it in the tutorial
19:05:34 <jle`> :'(
19:06:44 <jle`> oh i see, it's because i use it as a part of a composite key
19:06:48 <jle`> my bad
19:06:54 <jle`> still, it'd be nice to have the instance
19:07:27 <jle`> oh wait, it's necessary even if i just use it as a normal field.
19:09:05 <tsani> Hi
19:09:06 <codedmart> With forkIO if my process dies can I catch that and restart it?
19:09:27 <jle`> oh wait it works now for some reason magically
19:09:29 * jle` shrugs
19:09:33 <tsani> I used the strategy outlined here to represent a syntax tree http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html but for an imperative language
19:09:57 <tsani> now I want to write a transformation on the tree, but that is guaranteed to preserve its shape
19:10:57 <c_wraith> codedmart: if you want to go in that direction, you should check out the async package.  It gives a lot more tools for managing processes.
19:11:24 <tsani> Rather than the type of an expression being stored in the GADT index, I store a datakind that represents 'where we are in the tree' so to speak, so the indices are things like ExpressionNode or StatementNode
19:11:49 <Axman6> chachi: do you mean if the thread you've forked dies? there are a few ways to do that, I believe Async will give you some low level tools, and distributed-process gives you much more haevy weight tools for process hierarchies
19:12:02 <Axman6> uh, codedmart 
19:12:34 <codedmart> c_wraith Axman6 OK I will check out async. Thanks!
19:13:12 <c_wraith> codedmart: I didn't know about distributed-process.  It's probably a good next step if async seems too low-level.
19:13:53 <c_wraith> ... It is certainly more complex. :)
19:14:22 <Axman6> yeah much more, being aimed at erlang style distributed concurrency
19:14:42 <Axman6> with process supervision trees etc.
19:15:12 <c_wraith> async at least gives you link! :)
19:32:36 <winter_> https://mail.haskell.org/pipermail/haskell-cafe/2016-November/125587.html
19:32:49 <winter_> any ideas are welcomed!
19:42:23 <Axman6> winter_: what do you expect the result of (show . get) <$> ask to be for a Reader (Int,Bool) a?
19:42:41 <Axman6> should it give you "True", "7"? "(7,True)"?
19:42:50 <Axman6> the results are undecidable
19:43:38 <Axman6> lens gives an ok solution to this problem by allowing for HasFoo classes to be defined using classyLenses
19:44:35 <Axman6> see for instance http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:makeClassy
19:48:37 <winter_> get is polymorphric so you have to use type here i'm afraid
19:49:07 <Axman6> right, this idea will pretty much always require you to annotate things with type signatures
19:49:43 <Axman6> type application might make things a wee bit less painful, but I thinnk there are better choices
19:50:04 <winter_> but my use case is something more like (Has Logger env,  Has SqlBackEnd env, …) =>  MyMonad env () 
19:50:25 <Axman6> right, lens gives you that
19:51:01 <winter_> when you use get to get the logger, there're always a concrete function like log :: Logger -> Str -> IO ()
19:51:42 <winter_> You mean there's Has class equivalent already ?
19:53:13 <Axman6> it can give you things like: class HasLogger t where logger :: Lens t Logger; instance HasLogger Logger ..., then you can write things like: myLoggingAction :: (HasLogger t, MonstReader t m) => m (); myLoggingAction = do ... ; lggr <- view logger; ...
19:54:05 <Axman6> admittedly you end up with a huge number of HasFoo classes, but it could be worse
19:55:09 <winter_> Ah, that's not what i want.
19:55:29 <Axman6> I have a strong feeling what you want, or at least how you want it, is generally a bad idea
19:56:06 <winter_> I'd like to hear drawback indeed.
19:56:16 <winter_> because it seems to be such a simple idea
19:56:31 <winter_> it must have some problems or people are doing it already
19:56:44 <Axman6> I'm sure dibblego and edwardk would be able to give a much better explanation than I could
19:57:00 <Axman6> actually, many people in here could
19:58:30 <chachi> dibblego, Axman6: Thanks for your help. I've worked back through and I now see that when you make an "obvious" (to me) one-liner and then make it point-free, you use liftA2 and implicitly ((->) t) to remove some duplication and voila.  Thanks again!
19:58:46 <dibblego> no problem
20:01:12 <winter_> ok, let's see ; )
20:01:25 <jle`> TH generating persistent piping for a db table with a large number of rows froze up my decent computer for a few minutes
20:43:35 <dev0null> ls
20:43:36 <dev0null> oops
20:48:54 <wespiser> dev0null, where do you store all the files I've sent you?
21:04:00 <dev0null> wespiser: sorry fam
21:04:20 <wespiser> np, I'm just winding down myself
21:04:34 <dev0null> feel free to send me more
21:06:19 <wespiser> I got a good one, I'm writing a scheme using a ReaderT monad, ReaderT (Map Text LispVal) IO LispVal, and am trying to get a REPL to work such that the environment tracks from one input to the next
21:06:33 <wespiser> https://github.com/write-you-a-scheme-v2/scheme/blob/master/docs/06_repl.md
21:07:06 <wespiser> since ReaderT basically goes e -> a, I kind of lose my e
21:07:20 <wespiser> unless I make it go e -> (e, a)
21:07:36 <wespiser> which is StateT, fudge
21:07:40 <jle`> yup, there's actually a common type that offers that
21:07:41 <jle`> and, yeah
21:08:00 <wespiser> thanks, I needed to talk my way through that
21:08:53 <wespiser> on the plus side, that means chapter 6 on REPL is done
21:15:17 <jle`> no problem :) and congrats!
21:22:19 <n_blownapart> http://pastie.org/10967284 hi please show me how to use trace on the removeFst function here. (I'm trying to follow " y : removeFst ys "  thanks
21:40:39 <angerman> Given f :: IO (Maybe T),  and g :: T -> IO (Maybe T2), how do I properly compose them to obtain g . f :: IO (Maybe T2)?
21:41:40 <Lokathor_> angerman, you have to use a case statement on the result of f
21:41:40 <geekosaur> f >>= maybe (return Nothing) g -- ?
21:42:03 <Lokathor_> or a function that does the case statement for you such as what geekosaur showed
21:42:10 <geekosaur> (which, morally, gas a case statement hidden in it)
21:42:38 <geekosaur> what you cant really do is use the fact that Maybe is itself a monad, since the monadic "focus" is on IO
21:42:51 <geekosaur> and has to stay there, otherwise you can't get an IO anything out of it
21:43:24 <angerman> geekosaur if it was `f :: Maybe T`, `g :: T -> Maybe T2`,  `f >>= g` would just do. However the double layering is tripping me off every time..
21:43:34 <geekosaur> yep
21:43:42 <geekosaur> it will and there's no good way around it
21:44:08 <geekosaur> monads don't compose that way, sadly
21:45:19 <angerman> Well. So at least I can fell less stupid :) Thanks! 
21:45:34 <Lokathor_> http://lpaste.net/344680 is what you're after, basically
21:45:43 <Lokathor_> if i understand your question properly
21:46:22 <angerman> yep.
21:46:24 <jle`> angerman: you can pattern match to do it, but if you're doing several of these and nested pattern matches are getting annoying, you can use MaybeT to remove some of the boilerplate
21:46:51 <jle`> 'MaybeT IO a' is basically a newtype wraper over IO (Maybe a) that implements >>= that respects the maybe-ness
21:47:08 <jle`> but it's pretty overkill for just a single usage of (>>=)
21:47:26 <jle`> if you use the MaybeT newtype wrapper, you'd write it as f >>= g, or g =<< f
21:47:28 <angerman> jle` the git (hs-git) package has lots of function with those IO (Maybe a)  signatures
21:47:28 <marcx> how is flip (<$>) operator usually named?  i think it is part of some third party lib not prelude
21:47:35 <geekosaur> mm, right, that always throws me because it's "backwards"
21:47:36 <jle`> marcx: <&>
21:48:03 <marcx> @hoogle (<&>)
21:48:04 <jle`> angerman: with the newtypeness explicit, it'd be 'MaybeT . g =<< MaybeT f'
21:48:06 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
21:48:07 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
21:48:07 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
21:48:16 <jle`> angerman: that's how you'd wrap f and the result of g in the newtype wrapper
21:48:18 <marcx> oh it is part of lens?
21:48:21 <jle`> (=<<) does what you'd want in this case
21:48:28 <jle`> marcx: lens is one library that defines it, yes
21:48:45 <jle`> angerman: but in the end if you watn to get it back to an IO (Maybe a), you'd have to unwrap it, like runMaybeT $ MaybeT . g =<< MaybeT f
21:48:51 <jle`> angerman: so, pretty ugly for just a single bind
21:48:59 <jle`> angerman: but if you do several of them and do it in do notation, it gets more handy
21:49:01 <angerman> jle` maybe I'll just write my own combinator.
21:49:12 <marcx> i am not using lens in this project, what lighter library defines it?
21:49:49 <angerman> jle` but thanks for the pointer towards MaybeT
21:50:09 <jle`> angerman:  no problem.  if you have a lot of these and are combining them a lot and using the combinator a lot/have a lot of nested case matches, that's when MaybeT becomes useful
21:50:24 <jle`> angerman: it's also useful when you throw it into monad-polymorphic functions, like replicateM, forever, sequence, etc.
21:50:30 <angerman> jle` is there EitherT then as well? ;-)
21:50:35 <jle`> and in Alternative-polymorphic functions like (<|>), etc.
21:50:43 <jle`> angerman: yes, except it's called ExceptT for some reason
21:51:06 <jle`> angerman: for example, even if you used your combinators, you'd have to re-write replicateM/forever/seuqnece/asum/etc. respecting your Maybe rules
21:51:21 <jle`> but using MaybeT lets you work with those.  so it's a bit of a tradeoff
21:51:23 <dev0null> Good night boys
21:51:23 <Rotaerk> there's an EitherT here:  https://hackage.haskell.org/package/either
21:51:38 <jle`> yeah, but it's a little pointless to use it if there's ExceptT in 'transformers'
21:51:42 <jle`> which is included with ghc
21:51:54 <jle`> EitherT only existed becoase ExceptT wasn't yet pulled into transformers
21:52:00 <Rotaerk> ah
21:52:03 <jle`> but once ExceptT got added to transformers, EitherT is a little redundant
21:52:19 <jle`> marcx: i wouldn't trust a library that just offers little combinators like (<&>)
21:52:23 <geekosaur> marcx, http://hackage.haskell.org/package/microlens
21:52:38 <jle`> marcx: if you use it a lot, and you don't do any lensy stuff, you might as well define it yourself :)
21:53:20 <geekosaur> ^ also true, if that's all you want just say `<&> = flip fmap` somewhere
21:53:39 <Rotaerk> one thing about Either that I never liked is that the left was generally used for the failure case, and the right for the successful case, but they're *called* left and right... not particularly intuitive
21:53:52 <marcx> i guess i could. is & = flip ($) a common definition as well?
21:54:02 <jle`> marcx: (&) is already in 'base'
21:54:09 <marcx> oh?
21:54:11 <jle`> mhm
21:54:15 <geekosaur> @index (&)
21:54:15 <lambdabot> Data.Function
21:54:19 <Rotaerk> the naming allows it to be more general-purpose than the convention of left-is-failure, but... does anyone use that flexibility?
21:54:21 <marcx> :t (&)
21:54:23 <lambdabot> a -> (a -> b) -> b
21:54:31 <geekosaur> it' actually flip (.) iirc
21:54:39 <marcx> hmm
21:54:41 <geekosaur> hm, no
21:54:54 <geekosaur> that type is flip ($)
21:54:57 <jle`> flip (.) is the awkwardly-named awkwardly-fixitie'd (<<<)
21:55:01 <geekosaur> :t flip ($)
21:55:03 <lambdabot> a -> (a -> c) -> c
21:55:03 <marcx> > 10 & (+1) & (*10)
21:55:06 <lambdabot>  110
21:55:24 <Lokathor> Rotaerk, usually people will simply make their own union types, because it's so easy
21:55:24 <jle`> but yeah, bag-of-assorted-combinator libraries are a little sketch
21:55:35 <Rotaerk> yea
21:55:49 <jle`> they're susceptible to bitrot and they aren't really that commonly used either
21:56:08 <jle`> so if you just need (<&>), probably better to just define it yourself
21:56:15 <Rotaerk> I was considering using an Either type in C#, but I figured it might make the code less readable if people saw "left" and "right" all over the place
21:56:28 <jle`> also see: leftpad
21:56:47 <Lokathor> though it's helpful to have that (Left e) part stay up in the air as long as possible, sometimes you'll want your error message as String and others as Text for example
21:57:36 <wespiser> jle`: can you define the term "bitrot"
21:58:12 <Lokathor> botrot is generally when older code fails to compile in later versions because the assumptions that it assumed are no longer true
21:58:14 <geekosaur> it's a quasi-joke describing when the language/ecosystem changes out from under something so that it no longer works
21:58:53 <Lokathor> perhaps stack can save us from bitrot! (sadly, no it can't actually :P)
21:59:12 <jle`> wespiser: if those bag-of-utility-combinator packages go unmaintained for a little while, then the ecosystem changes around them and they stop working
21:59:17 <jle`> and the problem gets worse and worse over time
21:59:25 <jle`> so it requires an active maintainer
21:59:27 <wespiser> okay, thanks
21:59:34 <geekosaur> if something is not maintained, automatic maintenance only goes so far. especially in something like ghc's ecosystem where the compiler changes a lot
21:59:49 <geekosaur> (or the ecosystem bundled with it; cf. AMP, FTP in 7.10)
21:59:53 <wespiser> I haven't been around Haskell long enough, or gone deep enough to see that yet!
21:59:58 <jle`> or at least a maintainer who is willing to cede control .... and people who use the library enough to care enough to submit patches
22:00:18 <jle`> it's a more general programming/software dev problem than just a haskell problem actually heh
22:00:39 <jle`> but the effect in haskell is exaggerated because the haskell ecosystem changes so rapidly
22:00:58 <geekosaur> (and for those watching from home, that's Applicative-Monad Proposal and Foldable-Traversable Proposal. the latter of which was jokingly called the bridge-burning proposal during planning; it's not like people don't know they're doing it...)
22:01:02 <jle`> every 6 months or so GHC goes through breaking changes of some sort lol
22:01:36 <geekosaur> s/doing it/breaking stuff/
22:02:45 <wespiser> huh, i didn't realize cf. AMP FTP would have had that effect, makes sense though
22:02:50 <jle`> 'stack' at least lets you pin down your project/application to a recreatable snapshot
22:03:03 <wespiser> yea, its great for industry
22:03:11 <wespiser> one more step in the right direction
22:04:42 <wespiser> wait, FTP should have had nearly no effect on code that compiled before it
22:06:23 <geekosaur> FTP not only has that effect, it's also hard to back out of if they'd decided in retrospect that ti was a bad idea. hence "bridge burning proposal"
22:07:05 <geekosaur> plenty of code out there that originated before Applicative and never bothered to add instances for it
22:07:16 <geekosaur> Applicative is itself a relative newcomer
22:09:08 <geekosaur> (almost all code that defines its own Monad(s) has Functor instances, but Functor isn't sufficient for AMP)
22:10:20 <marcx> doit path = path & normalisePath & readFile >>= processFile >>= putStrLn
22:10:41 <marcx> much better than mixing and matching >>= . $ etc
22:10:49 <marcx> those operators should come by default
22:11:44 <marcx> (well these do I guess :). but <&> doesn't)
22:12:50 <Cale> Perhaps consider using =<< with (.)
22:13:29 <Cale> Or (<=<)
22:14:31 <Cale> e.g. doit = putStrLn <=< processFile <=< readFile . normalisePath
22:15:45 <Cale> This direction also reads more nicely on the right hand side of an <- in a do-block
22:21:53 <Hafydd> Just doit = pure $ putStrLn <=< processFile <=< readFile . normalisePath
22:23:00 * angerman jle` that actually ended up working quite nicely! Thanks!
22:24:14 <jle`> np!
22:37:42 <marcx> Cale that looks nice point free. but when i can't do point free i am used to using >>=, and then, with standard operators, data flow isn't in a single direction
22:38:16 <Axman6> marcx: you can always use =<<
22:48:40 <marcx> Axman6 i am used to using >>=, that is the first i learnt when learning monads, i found out about =<< a lot later. also it just seems more natural to read actions from left to right
22:49:52 <Axman6> >=> also exists
22:50:35 <grantwu> <>= fish operator!
23:11:08 <nathann> i want to learn about automated theorem proving and proof assistants, i have a strong background in math though i know essentially nothing about cs
23:11:24 <nathann> can i jump right into this, or should i try to learn some more cs first?
23:11:59 <ski> do you know any programming language ?
23:12:04 <nathann> no
23:12:38 <grantwu> How much logic do you know?
23:12:44 <ski> perhaps it would be possible to jump directly into it, but i'd try to get some basic programming experience first
23:12:45 <nathann> basically i want to learn about programs capable of symbolically manipulating expressions into equivalent ones until a result is verified
23:13:03 <nathann> 1st 2nd order
23:13:04 <ski> yes, knowing something about derivation/proof/inference systems in logic would also help
23:13:14 <ski> (e.g. natural deduction)
23:13:21 <grantwu> constructive logic ;-;
23:13:28 * grantwu withdrew from that class this semester.
23:15:11 <ski> nathann : functional programming (such as Haskell) is relatively close to some approaches to proof assistants (such as Coq and Agda)
23:15:20 <ski> @where SF
23:15:20 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
23:15:20 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
23:15:53 <ski> might be useful, but might be too advanced for you atm, perhaps check it out
23:17:39 <nathann> sorry if i wasnt clear
23:17:44 <nathann> when i said automated theorem proving
23:17:57 <nathann> i dont mean like verifying
23:18:01 <nathann> the correctness of programs
23:18:12 <ski> "Haskell" is sometimes claimed to be "more mathematical" than some other programming languages. i'm not sure whether that's really that true, but i do think it (and functional programming in general, to various degrees, depending on the language in question) is in some ways closer to how you think in math
23:18:16 <nathann> i mean like proving mathematical theorems
23:18:17 * ski nods
23:18:25 <ski> you can do both, in Coq and Agda
23:19:11 <nathann> also i dont know but, i want to learn something that wont be obsolete 
23:19:14 <nathann> that happens right?
23:19:16 <ski> (of course you first need to define or specify/characterize the notions that you're proving theorems about)
23:19:20 <nathann> people stop writing in programs
23:19:31 <nathann> i mean i imagine
23:19:40 <ski> Coq is many years old
23:19:46 <nathann> like future proof'
23:19:51 <nathann> is that the most widely used?
23:19:55 <ski> i believe so
23:20:11 * ski knows less about automated theorem proving, though
23:20:18 <lgstate> http://lambda-startup.com/developing-clojure-on-app-engine/ <-- is this best docs for setting up clojure on GAE
23:20:20 <lgstate> wrong channel, sorry
23:20:37 <ski> btw, you can also ask in #coq and #agda
23:20:58 <lgstate> #coq is amazing for clarifying thought
23:20:59 <nathann> thx ski
23:36:25 <EvanR> ski: reading the escardo paper you linked earlier, and i think im stuck on a section. a subspace of a data type is called hausdorff if the sierpinski-valued apartness map is continuous (defineable in the language), then it says no data type is hausdorff because of bottom. ... but how am i wrong with this apartness map for (datatype) Nat
23:37:39 <ski> EvanR : cut off near "... but how am i wrong with this apartness map for (datatype) Nat"
23:37:52 <EvanR> not cut off, i just didnt write out the algorithm yet
23:37:56 <ski> oh
23:38:53 <ski> well, you can't tell `_|_' apart from `Succ _|_', e.g.
23:39:11 <ski> (while you can tell `Zero' apart from `Succ _|_')
23:40:36 <EvanR> if you just apply (/=) to m and n, then for actual numbers itll be right... and if both are bottom, itll be right (bottom, not apart)
23:40:54 <EvanR> but i guess its wrong if one is bottom and the other isnt
23:41:06 <EvanR> i was trying to think of a way to race m and n somehow... but i failed
23:42:07 <ski> the problem is that with a finite time to observe `_|_', you can't in general say that you won't later discover it to be `Zero' or `Succ x', for some `x'
23:43:15 <ski> so, in the paper, they consider subsets (subspaces) of types, where they assume, as a precondition if you will, that certain values in the type won't be input
23:43:49 <EvanR> yes, the subspace of actual natural numbers is hausdorff
23:44:06 <EvanR> unequality is decidable
23:44:15 <EvanR> so its definable 
23:46:26 <EvanR> so if m is 3 and n is bottom, there is no right way to return truth
23:46:54 <EvanR> is there a proof of this?
23:47:49 <Cipher> hello?
23:48:14 <EvanR> so far im understanding this on an intuitive level
23:49:29 <EvanR> "cant tell the diff between _|_ and S _|_" , hmmm
23:50:01 <EvanR> or an infinite sequence of S
23:55:31 <EvanR> this is what i was thinking of, the \/ operation is definable, T \/ T = T, T \/ bottom = T, b \/ b = b, using racing. but the key with N i guess is that the results have to be further scrutinized when the args are both non bottoms
23:55:57 * EvanR tries to come up with a proof of undefinability
23:56:30 <Cipher> Anyone kind enough to tell me how to mix [a,b] and [c,d] to [[(a, c) (b, c)],  [(a, c), (b, d)],  [(a, d), (b, c)],  [(a, d), (b, d)]]?
23:57:40 <liste> > [(a, b) | a <- [1,2], b <- [3,4]]
23:57:43 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:58:24 <liste> > do { a <- [1,2]; b <- [3,4]; return (a, b) }
23:58:27 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:58:53 <liste> there's 2 common ways
23:59:30 <liste> Cipher: ^
23:59:36 <Cipher> but there's no gathered (1,3) (2,3) and (1,4) (2,4)
