00:07:41 * hackagebot pinboard 0.9.12.1 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.12.1 (jonschoning)
00:07:41 * hackagebot freer 0.2.4.0 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.4.0 (alcabrera)
00:26:39 <hrk> Is it possible to derive Generic instance for type declared in 3rd party library?
00:28:45 <tsahyt> Hello. I'm still unsure whether I should use a typeclass or a record type to abstract a bunch of calculations away from the representation of the task that they're defined on. What indications should I look for to see whether one or the other approach is better?
00:29:33 <lyxia> hrk: with standalone deriving I think you can
00:29:54 <tsahyt> from what I can tell, the type class approach makes it easier to modify the data without having to roll it all back into a record
00:30:05 <tsahyt> and it doesn't require extensions, which is a plus
00:30:33 <tsahyt> erm, the record approach doesn't require extensions
00:30:44 <hrk> lyxia: standalone deriving is what I was looking for. Thank you
00:30:45 <lyxia> you can only have one instance of a typeclass per datatype
00:30:58 <tsahyt> here's both definitions: http://lpaste.net/6721335200732676096
00:32:36 * hackagebot timezone-unix 1.0 -   https://hackage.haskell.org/package/timezone-unix-1.0 (AshleyYakeley)
00:32:49 <tsahyt> for the record variant I could probably get rid of the last couple of functions and put them into a typeclass of their own. I'm unsure whether I can do the same with the type families while reusing the same associated types
00:33:39 <lyxia> tsahyt: none of o, f, s uniquely determine the whole triple?
00:34:18 <tsahyt> no. o and f can be isomorphic, s is some collection of fs
00:35:50 <lyxia> I mean, in practice, if you have STRIPS o f s and STRIPS o' f' s', are the three equalities o ~ o', f ~ f', s ~ s', possible
00:36:30 <lyxia> In that case, the typeclass doesn't bring you any benefit actually
00:36:35 <tsahyt> I'm not sure I understand
00:37:00 <tsahyt> if those three equalities hold then STRIPS o f s and STRIPS o' f' s' are the same type, aren't they?
00:37:35 <lyxia> yes
00:38:08 <lyxia> Well if you can have two different dictionaries of the same type that would answer my question
00:38:35 <lyxia> but more generally I was asking whether these equalities can hold, independently.
00:38:47 <tsahyt> sure. I can represent a task over the same o f s using different implementations underneath
00:39:24 <lyxia> I mean you're using an extra type p which isn't used by the operations, only to define a type family on it.
00:39:34 <tsahyt> e.g o ~ Int, f ~ Int, s ~ Set Int, I can define the type using a bipartite fgl graph underneath, or using intsets, or whatever
00:39:54 <tsahyt> this difference in implementation underneath, regardless of what o f s are is what I want to encapsulate
00:40:05 <lyxia> and you plan to have different implementations available at the same time?
00:40:28 <tsahyt> possibly. I don't want the user to pick one specific representation of the task to run computations on
00:40:38 <tsahyt> or rather to force the user into one representation
00:41:06 <tsahyt> for me it's a benchmarking thing as well, I want to know which representation performs best
00:41:40 <lyxia> I think the data one is better
00:41:41 <tsahyt> and one might do better on one specific calculation than another, but I still want to define the calculation in terms of the structure properties (e.g. preconditions, postconditions, etc) rather than on specific representations
00:42:36 <tsahyt> lyxia: the only real downside I can find to the data one is that when I change something about the underlying data, I'd have to recompile it into that record to use it. this may or may not be a fast operation.
00:42:36 * hackagebot Agda 2.5.1.2 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.5.1.2 (UlfNorell)
00:42:41 <lyxia> in both cases you'll be passing around a token anyway, either an explicit STRIPS dictionary or a proxy-like value of type p.
00:43:06 <tsahyt> lyxia: In the type class approach, p would be a type containing the underlying data
00:43:16 <tsahyt> in the record approach this data is lost in a closure somewhere
00:44:29 <lyxia> why not pass values of type (p -> STRIPS o f s) instead then
00:46:22 <lyxia> hmm... that complicates things
00:49:01 <lyxia> though if p carries information, wouldn't you really want a data STRIPS p o f s instead
00:49:23 <lyxia> with p as an argument of all fields
00:50:41 <tsahyt> the p is what I want to hide away though. For all my calculations it would just dangle there as an all quantified parameter. Changing the p is not something that I ever do in this library.
00:51:00 <tsahyt> but a user might want to change the task (i.e. the p), and then call some calculation again
00:52:58 <lyxia> I don't understand. you don't change p, but a user might, and you want to hide p.
00:53:07 <lyxia> are we talking about p the type or a value of type p
00:53:13 <tsahyt> the value
00:54:07 <lyxia> so wouldn't what you described look more like (p -> STRIPS o f s)?
00:55:09 <tsahyt> yes that's probably how a user who wants to change the value of p would thread things around
00:56:03 <tsahyt> hmm. I think I'll just go with the data approach and see where that gets me
00:56:46 <tsahyt> for any reasonable representation p that I can think of, p -> STRIPS o f s should be fast
01:12:37 * hackagebot log-base 0.7 - Structured logging solution (base package)  https://hackage.haskell.org/package/log-base-0.7 (MikhailGlushenkov)
01:12:39 * hackagebot log-postgres 0.7 - Structured logging solution (PostgreSQL back end)  https://hackage.haskell.org/package/log-postgres-0.7 (MikhailGlushenkov)
01:12:41 * hackagebot log-elasticsearch 0.7 - Structured logging solution (Elasticsearch back end)  https://hackage.haskell.org/package/log-elasticsearch-0.7 (MikhailGlushenkov)
01:12:43 * hackagebot log 0.7 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.7 (MikhailGlushenkov)
01:27:38 * hackagebot freer 0.2.4.1 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.4.1 (alcabrera)
01:41:18 <AndreasK> Is there a way to make -ddump-to-file respect the output directory?
01:41:41 <AndreasK> It always dumps to the folder the code is in :/
02:01:35 <wagnerf> I'm wondering about using hash tables
02:02:00 <wagnerf> however Data.HashTable is using IO
02:02:47 <wagnerf> and i'd better like somehting pure
02:03:09 <wagnerf> is there any reason why it is not pure like sets
02:03:25 <AndreasK> Use of pointers I assume
02:04:00 <AndreasK> All mutable data structures are in some kind of PrimMonad as far as I know
02:04:01 <wagnerf> AndreasK: but isnt there pointers in binary trees also ?
02:04:22 <wagnerf> yes i was also thinking about the state monad
02:04:46 <AndreasK> Depends on the implementation. Map uses finger trees iirc
02:04:53 <AndreasK> So it's a pure data structure
02:05:53 <wagnerf> oh, it's amortized O(1) ?
02:06:32 <wagnerf> well no big deal anyway i'll go for sets
02:06:44 <AndreasK> afaik Data.Map has logn access
02:07:04 <wagnerf> i think so, i was just reading the wikipedia page
02:07:25 <AndreasK> For hashmaps?
02:07:39 <wagnerf> well i'll go for sets. it is not a big deal anyway
02:07:45 <wagnerf> no for finger trees
02:08:47 <wagnerf> it seems pushing is O(1) amortized but I guess the search is still logarithmic
02:12:39 * hackagebot elm-bridge 0.4.0 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.4.0 (AlexanderThiemann)
02:14:02 <tsahyt> Data.Map is based on balanced binary trees
02:14:30 <tsahyt> and it has log(n) insert and lookup
02:15:13 <tsahyt> IntMap is based on patricia trees, having O(min(n,W)) for those operations where W is the word size of your architecture, making them effectively constant time operations for large maps
02:15:28 <tsahyt> the same goes for HashMap if you ignore the hashing overhead
02:16:52 <tsahyt> in my experience Map is good enough most of the time, and doesn't require a Hashable constraint. Then again you can derive Hashable using generics, so it's not that big of a deal.
02:17:13 <tsahyt> if you know you're working on integer keys, IntMap is the way to go
02:19:40 <wagnerf> tsahyt: hey thanks for the tip. 
02:20:07 <tsahyt> wagnerf: for reference, the HashMap I'm talking about is from the unordered-containers package
02:20:16 <wagnerf> i'll test both the standard map and hashmap for comparisons
02:20:46 <wagnerf> i was a bit worried since i'm porting some my python code to haskell and the python dict used to be very crowded
02:20:48 <tsahyt> I've done some tests on my machine and the difference is definitely noticeable. HashMap tops out at about 30ns per lookup iirc with Text keys
02:21:14 <tsahyt> that was with I think about 10000 keys or so.
02:21:34 <wagnerf> ok
02:21:49 <tsahyt> the keys were <10 characters in size. If you have huge keys, the hashing overhead becomes noticeable of course
02:21:55 <wagnerf> seems good for me
02:22:27 <wagnerf> i'm hashing strings of around 30 chars
02:22:41 <tsahyt> yeah it's a decent implementation. Fast enough that I sometimes use a lazy HashMap as a cheap cache in front of a more expensive (and expressive) structure
02:24:33 <lyxia> log(n) is effectively O(W) for Int too
02:26:20 <tsahyt> iirc IntMap still beats out Map Int in practice though
02:27:05 <lyxia> yes indeed
02:27:40 * hackagebot slope-field 0.1.0.1 - Visualize mathematical function's slope fields  https://hackage.haskell.org/package/slope-field-0.1.0.1 (mdibaiee)
02:35:16 <Athas> Is Tran Ma on IRC?
02:39:19 <ertes> note that IntMap is based on a radix tree, so it will most likely perform better than Map even in very shallow cases, if only because Int can be unboxed within the data structure
02:39:45 <tsahyt> is there some way to write a function that uses a HashMap when a Hashable instance is available but a Map when only Ord is available?
02:40:13 <ertes> tsahyt: you could write a type class together with an associated type
02:41:19 <tsahyt> I suppose such a thing does not exist in a library somewhere?
02:42:02 <ertes> tsahyt: wait, i may have misunderstood the problem: you literally want to select implementation based on whether there is a Hashable instance?
02:42:11 <tsahyt> statically, yes
02:42:16 <ertes> because that's actually impossible
02:42:19 <ertes> i think
02:42:34 <ertes> what you can do is choose implementation based on key type
02:43:56 <tsahyt> but the key type determines whether there is a Hashable instance for it
02:44:04 <tsahyt> (assuming no orphans)
02:45:20 <ertes> lack of a Hashable instance doesn't mean that there is none (open world assumption)‚Ä¶  if you could actually decide based on whether an instance is in scope, that would mean that an import could change semantics
02:45:43 <tsahyt> basically I want to provide an algorithm that is polymorphic over some type without putting the burden of creating necessary instances on the user if they don't want to/can't provide them
02:45:53 <tsahyt> while still ensuring the best possible performance
02:46:08 <ertes> then you should abstract over the map type, not the key type
02:46:27 <mrkgnao> I just posted a question on reddit. would someone be so kind as to take a look?
02:46:30 <lyxia> you could have a GADT   MapThing k a where HashMap :: Hashable k => HashMap k a | Map :: Ord k => Map k a, you select the one you want at initialization.
02:46:32 <mrkgnao> <https://www.reddit.com/r/haskell/comments/5esz48/bumbling_through_my_first_monad_transformer_code/>
02:47:06 <ertes> lyxia: better make that a data family
02:47:37 <mrkgnao> I have no idea why I have to do lift . lift . lift for my transformer stack
02:48:17 <tsahyt> mrkgnao: liftIO
02:48:27 <tsahyt> for the majority of these things anyhow
02:49:26 <ertes> mrkgnao: given a stack T1 (T2 (T3 M)) you need 'lift' to perform a T2 effect, (lift . lift) to perform a T3 effect and (lift . lift . lift) to perform an M effect
02:49:55 <tsahyt> unless you use mtl
02:50:09 <ertes> mrkgnao: to get rid of all those lifts the most common method is to use mtl-style effect classes with the most common being MonadIO (which is actually not in mtl, but in base)
02:51:49 <MarLinn> For that map thing you might want to take a look at mono-traversable's "IsMap"
02:59:45 <tsahyt> MarLinn: but using this class, how would I statically choose the most performant map that the key can work with?
03:00:05 <tsahyt> i.e. if key ~ Int, choose IntMap, if Hashable key, choose HashMap, etc
03:02:39 <MarLinn> tsahyt: You just push it down the line until you know what you actually want ;)
03:03:25 <tsahyt> I'm not sure I can do that. the map is internal to an algorithm I'm supplying, it's not user facing
03:04:03 <tsahyt> I think I'll just go with HashMap and force the Hashable constraint on the user. it's not too hard to get an instance of that anyhow
03:05:30 <MarLinn> well, IsMap only solves the first step of unifying the maps. For the actual choice you could try a second class with overlapping instances. Just don't tell anyone
03:18:32 <tsahyt> why is Text not Hashable?
03:19:27 <tsahyt> nvm, it is
03:19:36 <tsahyt> it's just defined in the hashable package, not in text
03:30:42 <tsahyt> so I did some benchmarks. it turns out that lookup time for Map Int vs IntMap is virtually the same
03:30:50 <tsahyt> but IntMap is *much* faster on insertion
03:31:04 <tsahyt> interestingly enough HashMap Int has the fastest lookup time of them all
03:32:42 <tsahyt> https://pste.eu/p/fnO.html
03:32:48 <tsahyt> in case anyone is interested in the results
03:33:06 <tsahyt> map sizes were about 55000 elements for all tests
03:33:27 <tsahyt> the text keys are contiguous "aaaaaa" to "ffffff", the int keys are [1..55000].
03:37:49 <tsahyt> this suggests that if all you're gonna do with your map is modifying (i.e. not deleting or adding keys) and lookups, HashMap is a better choice for Int keys than IntMap. I did really not expect that.
03:39:08 <tsahyt> here's the benchmarking code, in case anybody can find something wrong with it http://lpaste.net/1358228732426321920
03:40:33 <hrk> Anyone has some experience with aeson? I'd like to encode my type with single data constructor but not as object {filed1:value1; field2:value2} but as json array like [value1, value2] to save space. How do I do that?
03:42:32 <mrkgnao> why is WriterT bad?
03:42:43 * hackagebot bolt 0.1.0.1 - Bolt driver for Neo4j  https://hackage.haskell.org/package/bolt-0.1.0.1 (bflyblue)
03:42:58 <tsahyt> mrkgnao: it tends to leak space
03:43:17 <mrkgnao> why?
03:43:40 <mrkgnao> does it build a huge "postponed computation" that sits around in memory?
03:43:45 <tsahyt> basically, yes
03:44:04 <tsahyt> mtl has Control.Monad.Writer.Strict, which may help
03:44:13 <mrkgnao> isn't there a strict version?
03:44:15 <mrkgnao> oh
03:44:45 <tsahyt> but I'm not sure how much it really does help in practice because you'd need the underlying monoid to be strict too I think
03:46:06 <tsahyt> mrkgnao: whether that is really bad depends a lot on what you're trying to do with it. it's completely unsuitable for a long running computation that requires logging for example
03:46:12 <tsahyt> monad-logger provides a solution for that
03:46:13 <fr33domlover> hrk, in your ToJSON instance you could build a list and apply the encoding function to it
03:46:37 <tsahyt> mrkgnao: for logging, Writer also comes with the problem that the log is only available after the computation ends
03:46:56 <mrkgnao> yep, I am looking for a logging solution
03:47:07 <mrkgnao> and I faced the problem you speak of
03:47:22 <fr33domlover> e.g. toJSON bird = toJSON [beak, wings]
03:47:28 <mrkgnao> I'm curious how monad-logger works, thanks for the reference
03:48:03 <hrk> fr33domlover: I've got something like this: http://lpaste.net/345715 Is that the way to go?
03:48:17 <fr33domlover> mrkgnao, MonadLogger is a typeclass, each instance works in its own way
03:48:46 <fr33domlover> e.g. there's a trivial instance that writes straight to stdout
03:48:57 <fr33domlover> iirc there's also an instance for fast-logger
03:49:40 <tsahyt> fr33domlover: stdout, stderr, or to a Chan
03:50:25 <fr33domlover> tsahyt, yeah i mean there can be more. wai/warp has an instance that uses fast-logger iirc and makes apache-style access logs
03:50:55 <tsahyt> I've only ever used it to write to stderr tbh, but it does that very well
03:51:11 <tsahyt> and it has very little overhead in my experience
03:51:58 <mrkgnao> fr33domlover: oh, I thought it was a full-blown monad
03:52:10 <tsahyt> mrkgnao: there's the LoggingT transformer
03:52:10 <fr33domlover> mrkgnao, the package does provide instances
03:52:11 <mrkgnao> yeah, std(out|err) works for me
03:52:46 <fr33domlover> there is also NoLoggingT, useful sometimes :-)
03:53:55 <jophish> Does haddock define GLASGOW_HASKELL?
03:58:51 <merijn> jophish: That question seems confused :)
03:59:06 <merijn> jophish: Haddock looks at sources *after* preprocessing, generation, etc.
03:59:21 <merijn> So, no, because haddock doesn't do CPP at all
04:03:03 <jophish> merijn: oh yes, I suppose I meant cabal haddock or whatever gets run
04:03:28 <jophish> and that's obviously yes :)
04:04:05 <merijn> jophish: It's one of the reasons why Hackage doesn't generate documentation for packages that don't compile. It's called in the final stage of compilation :)
04:05:16 <jophish> yeah, I remember I know all that. I must not be getting enough sleep :/
04:08:15 <merijn> jophish: Join the club :p
04:08:57 <stalk> hi
04:10:37 <stalk> I'm trying to work on the `filestore` package
04:10:55 <stalk> And here is a file that I'm working with to test it up a bit http://lpaste.net/1631592573204168704
04:11:45 <stalk> What I was doing before was `stack build` and then `stack runhaskell git-days.hs ‚Ä¶` (`git-days.hs` is the name of the file) and it worked
04:12:15 <stalk> But now, I think after a system update, when running the same command, I get `Could not find module `Data.FileStore'`
04:12:33 <stalk> Any idea on what the reason could be?
04:13:28 <stalk> https://hackage.haskell.org/package/filestore
04:13:39 <stalk> ^ That's what I mean by `filestore`
04:14:45 <AndreasK> is git-days part of a package or  a single file? Maybe the system update removed the FileStore package
04:15:55 <stalk> Ah, just to be clear, I cloned the git repo, and am working from that. the git-days.hs file is in an example directory in the `filestore` tree
04:17:20 <AndreasK> To me the only obvious possibility is that ghc used a global package before you update which now no longer exists, but doesn't mean it couldn't be a more obscure issue
04:17:41 <stalk> my understanding was that one of `stack build` or `stack install` would make this module accessible, somehow. Or that when running `stack runhaskell`, stack would know from its environment to include filestore
04:18:04 <AndreasK> I'
04:18:07 <stalk> AndreasK: mmh, ok
04:18:21 <stalk> What's the procedure to work on some library like I'm doing then?
04:18:22 <AndreasK> stack build should pull the dependencies into the local stack project
04:18:40 <nure> hello
04:19:19 <AndreasK> Not sure how runhaskell handles these things though. I always run an exeplicit target from the cabal file. like stack exec my-app
04:19:23 <byorgey> hi nure 
04:21:06 <stalk> That would mean that the git-days.hs file would be "included" in your package?
04:21:21 <AndreasK> stalk: If it's any help I can try to clone the repo and see if it works for me
04:22:23 <stalk> I'll just see first if the original repo also has this problem or if I messed up something
04:24:50 <stalk> AndreasK: Ok, I get the same error with a freshly clone repo
04:24:57 <AndreasK> stalk: I cloned head: git clone git://github.com/jgm/filestore.git and can run the file on my machine
04:25:04 <stalk> argh
04:25:11 <AndreasK> have you run stack build in the filestore directory?
04:25:19 <stalk> yes
04:26:00 <stalk> What did you do ? `git clone; cd filestore; stack build; runhaskell darcs-days.hs` ?
04:26:39 <AndreasK> switched to the example dir before runhaskell but yes
04:27:05 <AndreasK> What os/stack version are you on?
04:27:33 <stalk> fedora 25, and stack gives me 1.2.0
04:27:46 <stalk> Is there some hidden config that I should have made before?
04:28:03 <AndreasK> Did you clone the same repo as me?
04:28:08 <stalk> it seems that before the update (ie at fedora 24), it was working
04:28:10 <stalk> yes
04:29:24 <AndreasK> Maybe fedore messed up your path someone, i run win10 but i can try it on the vm in mint
04:29:59 <stalk> What should I have in my path?
04:31:32 <stalk> Are we talking $PATH or something else, btw?
04:33:13 <AndreasK> stalk: $PATH but I couldn't tell you if it were wrong. I use mostly windows and not really knowledgage about the stack internals
04:33:55 <AndreasK> stalk: http://lpaste.net/4900356263654719488 works for me under Linux mint
04:36:33 <stalk> https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
04:36:40 <AndreasK> stalk: I can't load it into a global instace of ghc though
04:36:48 <stalk> it seems that setting up the path is just to have installed binaries available
04:39:00 <AndreasK> stalk: What my guess is that stack doesn't set up the paths the the packages correctly. If you have called stack build in the filestore directory. and then run "cd examples && stack run ghci"
04:39:11 <AndreasK> and in ghci :l darcs-days.hs
04:39:14 <AndreasK> does that work?
04:40:04 <stalk> do you mean just `stack ghci` ?
04:40:22 <AndreasK> yes my mistake
04:40:50 <stalk> Yeah, I think it works
04:41:05 <AndreasK> You can just try to run main from within ghci
04:41:18 <AndreasK> should do the same as stack runhaskell <file> should have done
04:43:06 <stalk> mmh, that's something at least
04:43:16 <AndreasK> If that works than for some reason stack runhaskell uses the wrong package list in your install
04:43:38 <stalk> But in the ghci prompt, I just enter "main" ?
04:43:47 <AndreasK> after :l <file> yes
04:44:00 <AndreasK> :l <file> loads the defenitions from the file given
04:44:10 <AndreasK> then you can run functions interactive
04:44:15 <stalk> it gives me an exception: "Prelude.head: empty list"
04:44:29 <AndreasK> Yeah but that means the code gets executed
04:44:34 <stalk> yeah,
04:44:44 <stalk> I think it doesn't find the arguments it wants
04:44:52 <stalk> but filestore gets loaded nonetheless
04:45:13 <AndreasK> Yeah I get the same error probably expects a file or path I assume
04:46:12 <AndreasK> with stack you can also use runghc instead of runhaskell
04:46:18 <AndreasK> same command shorter name
04:46:59 <stalk> strangely, this gives me a different error
04:47:36 <AndreasK> thats is indeed strange. Which one?
04:47:42 <stalk> http://lpaste.net/493834472110686208
04:47:45 * hackagebot bolt 0.1.0.2 - Bolt driver for Neo4j  https://hackage.haskell.org/package/bolt-0.1.0.2 (bflyblue)
04:48:14 <stalk> ah, nvm
04:48:22 <stalk> it's because I wasn't in the right folder
04:48:35 <stalk> I mean, running it from examples/ gives the same error
04:50:07 <AndreasK> Either way seems to be a fedora specific issue. Maybe try to get another fedora user to try to run it and see if they get an error as well.
04:50:14 <EvanR> @tell erisco {{1,2},{3,4}} = {{2,1},{4,3}}, brokeJoin {{1,2},{3,4}} /= brokeJoin {{2,1},{4,3}} since {1,3} /= {2,4}
04:50:14 <lambdabot> Consider it noted.
04:52:11 <stalk> mmh, yeah, I'd say I just messed up something
04:52:20 <stalk> anyway, thanks for the troubleshooting AndreasK !
04:52:49 <AndreasK> No issue, it's always a chance to learn something new.
04:58:18 <kuribas> :t ($!)
04:58:19 <lambdabot> (a -> b) -> a -> b
04:58:38 <kuribas> > const 3 $! undefined
04:58:40 <lambdabot>  *Exception: Prelude.undefined
04:58:44 <kuribas> > const 3 $ undefined
04:58:46 <lambdabot>  3
05:00:04 <EvanR> seq ruins parametricity yat
05:00:16 <EvanR> yay
05:01:17 <merijn> Fast and Loose Reasoning is Morally Correct!
05:02:18 <kuribas> is this equivalent?  foldl' (+) 0 == foldl (\a e -> (e+) $! a) 0
05:02:46 * hackagebot classyplate 0.2.0.0 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.2.0.0 (lazac)
05:02:48 * hackagebot transient-universe 0.3.5.1 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.5.1 (geraldus)
05:02:51 <merijn> :t foldl
05:02:52 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
05:03:06 <EvanR> @src foldl'
05:03:06 <lambdabot> foldl' f a []     = a
05:03:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:03:19 <merijn> kuribas: Looks like it, yes
05:03:20 <EvanR> i dont think so
05:03:54 <merijn> EvanR: @src isn't to be trusted anyway
05:03:57 <EvanR> > foldl (\a e -> (e+) $! a) 0 [0..1000000]
05:04:00 <lambdabot>  *Exception: stack overflow
05:04:09 <EvanR> > foldl' (+) 0 [0..1000000]
05:04:11 <lambdabot>  500000500000
05:04:37 <kuribas> EvanR: so foldl always creates thunks?
05:04:38 <merijn> oh, wait
05:04:42 <merijn> I see the problem
05:04:48 <EvanR> src shouldnt be trusted for performance, but i hope its still correct
05:04:52 <merijn> kuribas: No, but the lambda you introduced, does
05:05:07 <merijn> EvanR: @src lists the Report version, it doesn't list actual sources
05:05:24 <EvanR> src lists code listed in a text file in some lambdabot dir
05:05:35 <EvanR> to demonstrate something important in this case how foldl' works
05:05:37 <kuribas> merijn: but I cannot define f without a lambda!
05:05:47 <EvanR> namely, evaluating the intermediate results before recursing
05:05:53 <EvanR> which kuribas's version doesnt do
05:05:57 <merijn> kuribas: Sure you can, let/where
05:06:20 <EvanR> @src foldl
05:06:20 <lambdabot> foldl f z []     = z
05:06:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:06:21 <kuribas> merijn: show me?
05:06:33 <merijn> kuribas: The foldl' from @src does that :)
05:06:47 <EvanR> i dont see how you can make it strict without modifying the foldl function itself
05:06:53 <kuribas> merijn: foldl' doesn't use foldl
05:07:07 <merijn> kuribas: The way it uses let generalises fine
05:07:20 <merijn> Incidentally, the actual foldl' in current GHC is implemented using foldr :)
05:07:27 <kuribas> merijn:  <kuribas> EvanR: so foldl always creates thunks?
05:07:29 <EvanR> that would work
05:07:54 <EvanR> kuribas: foldl traverses to the end of the list before any of your visitor code will be evaluating
05:08:00 <EvanR> so basically yes
05:08:19 <kuribas> foldl is pretty useless.
05:08:27 <EvanR> yes, its pretty useless ;)
05:08:30 <EvanR> but not totally useless
05:08:41 <merijn> It's pretty totally useless :)
05:08:50 <kuribas> foldl in Prelude should be foldl', and there should be foldl-lazy for academic corner cases.
05:08:50 <EvanR> you can use it to define reverse
05:08:52 <EvanR> or last
05:09:15 <kuribas> EvanR: reverse is strict
05:09:17 <EvanR> kuribas: that would be a thing they do by fiat in something like clojure, yes
05:09:18 <ggVGc> how can I improve this? I am fumbling about with monad transformers, https://gist.github.com/anonymous/28587a53f5549890378ebe9bfb15065a
05:09:22 <merijn> kuribas: Yes, but everyone is to afraid of breaking backward compatibility incase there's a broken corner case
05:09:34 <ggVGc> specifically, I'm fairly unhappy with all my "pure Nothing"'s
05:09:59 <ggVGc> how could I restructure it?
05:10:01 <merijn> ggVGc: Put the pure in front of the case?
05:10:05 <kuribas> ggVGc: your not very ZEN then :)
05:10:20 <ggVGc> kuribas: hah, I was thinking that.. but yeah
05:10:22 <EvanR> kuribas: however i do like that its conceptually simple and follows laws, and it would be obvious to anyone who understands that that seq would need to be introduced to get a law-breaking performance-enhancing effect, like you saw with $!
05:10:23 <merijn> ggVGc: "pure $ case blah of ..."
05:10:50 <ggVGc> merijn: that doesn't work, since I need the Writer instance in this block
05:10:51 <merijn> ggVGc: Or "let myResult = case blah of ...; pure myResult"
05:10:53 <ggVGc> or maybe I am wrong
05:10:55 <EvanR> rather than performance enhancing law breaking by default, and no one ever knew there were laws
05:11:04 <Guest86426> Does anyone have experience with Servant?  I'm trying to follow through the tutorial but getting "variable not in scope: runClientM", and "variable not in scope: ClientEnv", although I am importing Servant.Client and Servant.Common.Req, which export those definitions
05:11:27 <merijn> ggVGc: The case itself does nothing with the monad context, it's just an expression, so you can move the pure in front
05:12:52 <merijn> ggVGc: Oh, maybe that doesn't quite work for the else branch (I haven't looked hard enough), but certainly it works for the if branch
05:13:38 <ggVGc> merijn: yeah, this part is what's causing the trouble, https://gist.github.com/d5edd172b8f1239ddc04d87cdede6924
05:14:26 <merijn> ggVGc: When in doubt, use more let/where
05:14:34 <merijn> ggVGc: Also, the nested if is pretty awful
05:15:22 <Saizan> ggVGc: you could use MaybeT and then use <- bindings rather than case for some of them, also "guard" instead of if/then/else
05:15:30 <kuribas> > foldl (\a e -> if e == 0 then 0 else (a+e)) 0 [4, 1, 5, 0, 2, 5, 3]
05:15:32 <lambdabot>  10
05:15:36 <kuribas> > foldl' (\a e -> if e == 0 then 0 else (a+e)) 0 [4, 1, 5, 0, 2, 5, 3]
05:15:38 <lambdabot>  10
05:15:45 <kuribas> > foldl' (\a e -> if e == 0 then 0 else (a+e)) 0 [4, undefined, 5, 0, 2, 5, 3]
05:15:47 <lambdabot>  *Exception: Prelude.undefined
05:15:50 <kuribas> > foldl (\a e -> if e == 0 then 0 else (a+e)) 0 [4, undefined, 5, 0, 2, 5, 3]
05:15:53 <lambdabot>  10
05:16:00 * kuribas found a corner case
05:17:04 <EvanR> kuribas: an example "obvious to do by default" thing is that their lazy lists automatically evaluate 32 steps at a time. so if you take 10 and item 13 was "undefined", it would "inexplicably" crash...
05:17:25 <bollu> so, I'm writing a library that binds to lists, matrices, etc in C. are type-level numbers stable enough for me to encode the sizes of the vectors, matrices, etc. at the type level?
05:17:41 <bollu> like, is it considered "wacko library" to use type-level numbers or is it encouraged when writing a new library?
05:17:47 <EvanR> but if item 33 was undefined, it would work
05:17:54 <kuribas> yeah
05:19:16 <merijn> ggVGc: Incidentally, "pure $ fmap (\m -> (UpdateSingle, m)) newModel" seems really weird
05:19:26 <merijn> ggVGc: Why do you need pure if you're using fmap?
05:19:42 <merijn> ggVGc: newModel is already an UpdateResult (else the do-block wouldn't typecheck)
05:20:00 <merijn> ggVGc: So by doing "pure $ fmap" you're storing an UpdateResult inside an UpdateResult?
05:20:25 <ggVGc> merijn: to add the UpdateSingle flag to it
05:20:31 <ggVGc> but yeah, this whole thing is a mess
05:20:53 <bollu> guys? what is the status of type level nats?
05:20:55 <merijn> ggVGc: Shouldn't you be doing "fmap (\m -> (UpdateSingle, m)) newModel" for that?
05:20:55 <ggVGc> I am only 60% aware of what I'm doing
05:20:58 <bollu> is it considered good library design to use them?
05:21:07 <merijn> ggVGc: fmap already fmaps the UpdateSingle into the UpdateResult
05:21:24 <merijn> ggVGc: Adding another "pure" takes the resulting UpdateResult and puts that into another one...
05:21:29 <merijn> ggVGc: Does this even typecheck?
05:21:41 <ggVGc> yes
05:21:45 <ggVGc> but only fmap does not
05:21:54 <merijn> That's...weird as hell
05:21:56 <ggVGc> merijn: newModel is not a SeqModel. It's a Maybe SeqModel
05:22:13 <merijn> ggVGc: Ooooh, wait, yes, I get it
05:22:36 <kuribas> ggVGc: can't you merge NoteDown with x?
05:22:46 <kuribas> ggVGc: line 27
05:24:47 <ggVGc> kuribas: yeah, thanks
05:25:14 <lpaste> merijn pasted ‚ÄúRefactor‚Äù at http://lpaste.net/345734
05:25:39 <merijn> ggVGc: I would start refactoring like this, and now simplify/refactor the two guards inside doWork to see if you can get those cleaner
05:26:14 <kuribas> ggVGc: you could clean it a bit with patternGuards
05:26:25 <merijn> pattern guards == <3
05:26:37 <kuribas> ggVGc: and multiwayIf
05:26:52 <merijn> kuribas: pattern guards has the advantage of not being an extension :)
05:27:12 <kuribas> it isn't? :-)
05:27:54 <merijn> Everyone always forgets that the Haskell98 extension PatternGuards became part of the Report for Haskell2010 :p
05:28:13 <merijn> So if you use Haskell2010 (like GHC does by default...) it's no longer an extension :)
05:29:33 <merijn> Anyway, starting from my paste and trying to simplify using pattern guards is the most promising way to refactor, imho
05:29:56 <merijn> I would also move they list pattern on line 7 to it's own where binding, for example
05:30:28 <hrk> What's correct way to escape special chars (like ") in Data.Text? With string I can just do show "abc" to get "\"abc\"". Any way to achieve the same with Text?
05:31:35 <merijn> hrk: "show" is not a reliable way to escape characters
05:31:39 <Will1> I'm confused.  https://hackage.haskell.org/package/servant-client-0.9.1.1/docs/src/Servant.Client.html - this module exports "runClientM", but if I import it in GHCI and then ":t runClientM", I get "variable not in scope"
05:31:42 <bollu> what is size_t across the FFI?
05:31:45 <Will1> Am I missing something because I'm a noob?
05:31:54 <merijn> bollu: CSize, afaik?
05:32:03 <bollu> ah, thanks
05:32:19 <merijn> bollu: The module Foreign.C.Types has a lot of (mostly obvious) type definitions
05:32:47 * hackagebot concrete-haskell 0.1.0.3 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.3 (TomLippincott)
05:33:07 <merijn> Will1: Do you have the same version of servant-client installed?
05:33:14 <jophish> mpickering: Do you remember what made this annoying to fix? https://github.com/haskell-suite/haskell-src-exts/issues/324
05:33:41 <Will1> I specified in my .cabal file "servant-client == 0.9.1.1" - TBH unsure if that's the right syntax, but "stack build" didn't complain?
05:33:51 <merijn> Will1: Use "ghc-pkg list" (or equivalent for whatever the hell stack uses :)) to see what's installed
05:34:12 <Will1> merijn thanks, I will try!
05:34:14 <merijn> Will1: hmm, yes. How are you starting ghci? The appropriate stack way or just running "ghci"?
05:34:20 <Will1> stack ghci
05:35:04 <merijn> Will1: Can you copy the exact input you're writing in ghci and full error?
05:35:24 <jophish> bollu: yeah, we use type level nats all the time here with great success
05:35:31 <Will1> Will do - just going to comment out some stuff to make sure it is being built properly - thanks
05:35:51 <bollu> jophish: very well, I'll make my library use type level nats as well :)
05:36:11 <merijn> bollu: Type level Nat is pretty stable and reliable, but solving type level arithmetic is still a bit unfinished
05:36:11 <jophish> shameless plug: https://hackage.haskell.org/package/vector-sized-0.4.1.0 -- bollu 
05:36:26 <bollu> merijn: I think I'll just need addition and subrtraction
05:36:45 <bollu> jophish: do you recommend I write my "core library" without nats and then provide a library?
05:36:50 <bollu> or just write the entire thing with nats?
05:37:07 <Will1> Ah my bad, it was failing to rebuild since I specified the exact version, I guess because my code couldn't compile.  I am now getting:
05:37:10 <Will1> While constructing the build plan, the following exceptions were encountered:  In the dependencies for servant-app-0.1.0.0:     servant-client-0.8.1 must match ==0.9.1.1 (latest applicable is 0.9.1.1)
05:37:29 <jophish> also, check the typechecker plugins here https://hackage.haskell.org/user/ChristiaanBaaij
05:37:31 <Will1> (servant-app-0.1.0.0 being my own code)
05:37:36 <jophish> (the ones starting with ghc-typelits
05:38:22 <jophish> bollu: If they're providing extra type safety you should use them everywhere you can )
05:39:11 <Will1> OK, guess I need to tell stack to look at the nightly index, rather than LTS - will figure that out.  Thanks for your help :)
05:39:28 <bollu> jophish: fair point
05:42:07 <mpickering> jophish: Nope, If you want to fix it be my guest :p
05:42:41 <mpickering> I think it might have been lots of little AST changes
05:42:47 * hackagebot concrete-haskell 0.1.0.4 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.4 (TomLippincott)
05:42:57 <mpickering> Also if I remember the parsing is a bit intricate 
06:03:43 <lonokhov> hm, cabal seem to build executables fine even if I don't have "other-modules". Why is this field needed?
06:04:29 <dcoutts> lonokhov: you can sometimes get away with it without immediate failures, but not in general, and cabal ought to check and warn when you miss them out, same for libs
06:04:54 <dcoutts> e.g. sdist will miss files, things will go wrong with pre-processors
06:05:12 <jophish> lonokhov: I always get a stack of linker errors without them listed
06:05:15 <dcoutts> cabal (and I think stack) will not notice when files have changed
06:05:25 <jophish> (and am always annoyed that cabal doesn't shout at me)
06:05:26 <dcoutts> jophish: that's libs, lonokhov means exes
06:05:34 <jophish> oh, didn't see that
06:05:42 <dcoutts> jophish: yes it really should, I completely agree
06:05:42 <lonokhov> Hm, ok.
06:05:54 <jophish> It's mad that I (a human) have to specify these anyway
06:06:32 <lonokhov> dcoutts: will we get shared "build-depends" in next cabal?
06:06:33 <dcoutts> jophish: well, we can in principle detect when you do it wrong, but cannot in general discover them all, in the presence of cpp, conditionals/flags etc
06:07:38 <dcoutts> lonokhov: not immediately, but when the parser has been overhauled so we can add new sections more sanely then we'll get a mechanism for a general shared/common section, in which you could list build-depends
06:07:40 <jophish> then perhaps there should be an option for specifying them, but autogenerate that list by default
06:08:24 <lonokhov> I used to split executable into lib and exe, so I could run tests linked with it. But I get huge closures in nix because shared libs link to all the things :(
06:08:25 <urbanslug> Why is mconcat in the monoid typeclass yet it only applies to one monoid, the list?
06:08:26 <dcoutts> jophish: we cannot in general tell when we pass the threshold when we start to not be able to autogenerate them reliably
06:08:40 <merijn> dcoutts: I <3 you. Every single time I hear about upcoming cabal features it's always something I either 1) wanted a lot or 2) something I didn't even realise I wanted a lot yet ;)
06:08:54 <urbanslug> merijn: :D
06:08:55 <merijn> urbanslug: It applies to all monoids
06:09:00 <merijn> :t mconcat
06:09:02 <lambdabot> Monoid a => [a] -> a
06:09:10 <urbanslug> merijn: See it's for lists
06:09:13 <dcoutts> merijn: in this case thanks phadej for pushing the parser rewrite
06:09:13 <merijn> urbanslug: Note, it's concatting a list of monoids
06:09:31 <phadej> hmm, what
06:09:31 <urbanslug> :t concat
06:09:32 <lambdabot> Foldable t => t [a] -> [a]
06:09:35 <lonokhov> thanks phadej!
06:09:42 <merijn> urbanslug: Because having a list of values and wanting to mappend them is a common thing to want
06:10:12 <merijn> urbanslug: mconcat is just "fold mappend" and that mappend is not working on lists, but on the values IN the list
06:10:17 <phadej> ah, just general parser stuff
06:10:25 <phadej> yeah. it's ongoing process
06:10:31 <merijn> urbanslug: See also, the more general
06:10:32 <merijn> :t fold
06:10:34 <lambdabot> (Monoid m, Foldable t) => t m -> m
06:10:47 <merijn> urbanslug: Which is basically mconcat for Foldable instances
06:11:26 <urbanslug> mconcat [Just (Product 1), Just (Product 1)]
06:11:30 <urbanslug> > mconcat [Just (Product 1), Just (Product 1)]
06:11:32 <lambdabot>  Just (Product {getProduct = 1})
06:11:56 <merijn> urbanslug: Note that that uses the Monoid instance of maybe, and not Product
06:12:21 <merijn> > getSum $ mconcat [1..10]
06:12:23 <lambdabot>  error:
06:12:23 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M938738150259...
06:12:23 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
06:12:29 <urbanslug> hahah I hadn't actually
06:12:31 <merijn> oh, duh
06:12:37 <urbanslug> > mconcat [Just (Product 2), Just (Product 3)]
06:12:39 <lambdabot>  Just (Product {getProduct = 6})
06:12:46 <merijn> heh
06:12:49 <urbanslug> naaah it used Product
06:12:51 <merijn> oh, right
06:12:52 <urbanslug> not maybe
06:13:03 <urbanslug> It recursively ran mappend
06:13:13 <merijn> urbanslug: That's because the Monoid instance of Maybe is morally wrong
06:13:32 <merijn> urbanslug: It should clearly be "instance Semigroup a => Monoid (Maybe a)"
06:13:38 <lpaste> MarLinn pasted ‚Äúghc-make log‚Äù at http://lpaste.net/345746
06:13:40 <merijn> Which is the free monoid of 'a'
06:14:11 <urbanslug> merijn: Yeah I can see why Maybe is not a monoid
06:14:24 <merijn> urbanslug: It is a Monoid, just not the one it should be :)
06:14:26 <urbanslug> It lacks an identity
06:14:36 <merijn> urbanslug: You'd expect mempty = Nothing
06:14:42 <urbanslug> Well yeah but
06:14:44 <merijn> > mempty :: Maybe String
06:14:47 <lambdabot>  Nothing
06:15:04 <EvanR> > Nothing <> Just ""
06:15:07 <lambdabot>  Just ""
06:15:12 <urbanslug> Just [1] <> Just [2]
06:15:16 <EvanR> crash
06:15:16 <urbanslug> > Just [1] <> Just [2]
06:15:18 <EvanR> oh
06:15:19 <lambdabot>  Just [1,2]
06:15:30 <MarLinn> Sorry that the log is in German, but maybe someone has an idea why make thinks there's nothing to do when installing my ghc bindist?
06:15:32 <EvanR> unpredictable
06:15:40 <merijn> I thought mempty was "pure mempty" for Maybe
06:16:08 <urbanslug> Ok but merijn I think I get it. The point is. We liked folding/mappending a list of monoids a lot.
06:16:44 <urbanslug> pure is from applicative
06:16:44 <merijn> urbanslug: Well, it's more specific, it's because for some monoids you can optimise mconcat to be faster than folding mappend
06:17:04 <urbanslug> Oh 
06:17:43 <merijn> urbanslug: For example, "newtype First a = First { getFirst :: Maybe a }"
06:18:12 <merijn> urbanslug: Which keeps the first Just value. You can specialise mconcat to stop recursing as soon as you find a Just (since mappend on the remainder of the list is redundant and won't change the answer)
06:18:35 <merijn> urbanslug: So by putting mconcat inside the Monoid class it allows monoid specific optimised versions like that
06:18:53 <merijn> urbanslug: If you don't want to optimise it you can just rely on the default implementation
06:19:17 <urbanslug> Nice, makes sense.
06:19:42 <urbanslug> Thanks
06:21:41 <jophish> mpickering: you make it sound really tempting :)
06:27:49 * hackagebot hsparql 0.3.0 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  https://hackage.haskell.org/package/hsparql-0.3.0 (RobStewart)
06:38:24 <dsub> While trying to install hstats via stack, i get an error : base-4.9.0.0 must match >=3.0 && <4.9 (latest applicable is 4.8.2.0)
06:38:34 <dsub> Does anyone knows how to resolve that error?
06:39:02 <merijn> dsub: It means that the current version of hstats (claims to) not supports the version of GHC you're using
06:39:17 <dsub> Ok, so use another resolver?
06:39:23 <merijn> dsub: Because base is a part of GHC and can't be updated/downgraded
06:39:35 <merijn> dsub: That or try to patch hstats to work with a newer GHC
06:40:01 <dsub> merijn: Ok, thanx.
06:40:13 <EvanR> probably just adjust the bounds
06:40:47 <dsub> EvanR: in hstats or my .cabal-file?
06:40:52 <merijn> Probably, but OTOH GHC8 changes some pretty major things
06:41:16 <merijn> dsub: He means that there's probably a 90% chance that hstats will Just Work (TM) if you just patch the bounds, without other changes
06:41:57 * sm wonders why dsub is getting that error
06:42:10 <sm> are you installing it from source with a stack.yaml you generated by hand ?
06:42:43 <dsub> sm: no, trying to install outside stack-project
06:42:59 <Freundlich> dsub: https://github.com/haas/hstats/issues/5
06:43:25 <sm> so stack is pulling it from hackage ? I would have expected it to pick the right GHC for you
06:43:42 <dsub> Freundlich: Oooh... Thnx
06:44:20 <dsub> sm: Yeah, so the link from Freundlich showed that hstats doesn't build with GHC 8, yet at least
06:44:49 <sm> it seems 0.3.0.1 has a base upper bound to enforce that, maybe stack was pulling 0.3 ?
06:45:06 <MarcelineVQ> sm: there's a global resolver version so it'll install based on that
06:45:15 <Freundlich> dsub: The issue reporter claims that adjusting the bounds does work.
06:46:31 <MarcelineVQ> if you want to just build the tool you can use ghc 7.10.3 by writing, I don't know what the tool is though so‚Äã idk if the version you built with matters: stack install --resolver lts-6.26 hstats
06:47:36 <sm> MarcelineVQ: I have lts-7 (GHC 8) configured in ~/.stack/global/stack.yaml, and stack refuses to install any of hstats, hstats-0.3, hstats-0.3.0.1
06:47:39 <MarcelineVQ> oh okay it's a library
06:48:05 <sm> I'm just curious how it went wrong for dsub. But no big deal
06:48:59 <dsub> I'm currentrly trying with new resolver. brb
06:50:12 <MarcelineVQ> I thought it was a tool you were building but it's a library so unless your project also uses that resolver it's not going to help
06:53:12 <MarLinn> speaking of ghc 7.10.3, is there any documentation of the options I can pass to "make install" when building it? I'm speaking of things like "BINDIST=YES"
06:54:58 <dsub> MarLinn: no, it's a tool. Ran into other issues whith new resolver instead, but thanks anyway.
06:55:43 <MarcelineVQ> can you link its hackage page? the hstats I found is a library
06:57:30 <MarLinn> dsub: I was asking for myself actually. Third day of trying to poke ghc aliveÖ
06:58:16 <MarcelineVQ> MarLinn: they were talkin to me I think :>
06:58:23 <dsub> MarcelineVQ: Oh, misunderstood. Yes, the hstats is a library, but I'm building a tool. lol
06:59:15 <MarcelineVQ> dsub: The library is a single .hs file, if you continue to have issues you might consider copying that file and working with it directly for now http://hackage.haskell.org/package/hstats-0.3.0.1/src/
07:00:48 <dsub> MarcelineVQ: yeah, It's only a few functions I need from there anyway, so do some copy pasta from source instead. Ugly but works.
07:02:26 <MarcelineVQ> I meant as a whole module but whatever works, there's a liscense file there you should read if that kind of thing matters to you, I know nothing about them myself
07:03:56 <ggVGc> what's a better way to do this? https://gist.github.com/1a4142a58efb4d62326f8e578caffa0c
07:04:42 <ggVGc> well, newMod and actions should just be underscores
07:04:43 <ggVGc> but still
07:05:05 <lyxia> didAction = \case (Nothing, []) -> Nothing ; m -> Just m
07:05:20 <ggVGc> basically I want "if either of the values in this 2-tuple are not empty, then Just, else Nothing"
07:05:33 <ggVGc> lyxia: ah, heh, thanks
07:05:40 <ggVGc> still, is there some other better trick for this situation?
07:06:03 <ggVGc> lyxia: hm, that doesn't to the same thing as my logic I think?
07:06:57 <lyxia> "either of them is not empty" = "not (both of them are empty)"
07:07:23 <ggVGc> but it's fine that one of them is empty
07:07:26 <ggVGc> I still want the value
07:07:28 <ggVGc> https://gist.github.com/d45643a49fa2fcc9a13e2157af663386
07:07:51 <ggVGc> hm, okay
07:07:53 <ggVGc> yeah, you're right
07:07:55 <ggVGc> heh, thanks
07:08:08 <ggVGc> It's been a long day
07:08:13 <lyxia> you can just filter here actually
07:08:15 <Drezil> ggVGc: you can't .. (a,b) should yield what? Maybe a? Maybe b?
07:08:55 <Drezil> oh.. 
07:09:00 <Drezil> Maybe (a,b) .. 
07:09:14 <Drezil> but then why apply that in the first place?
07:09:48 <ggVGc> basically I have functions that generate actions and return a Maybe. I want to pick the first of these functions that either return a Just value OR generate some actions
07:10:01 <ggVGc> that is, I still want to pick it if it generates actions but not an output value
07:10:04 <ggVGc> and vice versa
07:10:26 <lyxia> map f >>> mapMaybe g = mapMaybe (g . f)
07:10:38 <Drezil> sounds like msum ...
07:10:51 <lyxia> oh good one
07:11:00 <Drezil> how are those functions "generated"?
07:11:07 <MarcelineVQ> MarLinn: there's a few pages with common things you might do: https://ghc.haskell.org/trac/ghc/wiki/Building/Installing mentions bindist, https://ghc.haskell.org/trac/ghc/wiki/Building has links to the rest
07:11:08 <Drezil> List of maybes? list of tuples? one maybe?
07:12:00 <MarLinn> ggVGc: That sounds like what you really want is something more specialized like data Result a = Value a | Actions [a] | NoResult
07:12:28 <Drezil> if you have a list of things you want headMay .. of you have a list of Maybes, you want msum .. if you have something different you maybe want to think about your data-structures :)
07:14:02 <Drezil> basically avoid tuples .. they have no structure ... define your own data-type and then have a mono-typed list (or similar)
07:14:13 <Welkin> tuples are useful for pairs only
07:14:47 <Bonnie> hi im a beginner of haskell and i really don't know why this function is not working 
07:14:50 <Bonnie> list2numb :: [Char] -> [Int] list2numb [] = [] list2numb (x:xs) = fromEnum (x) ++ list2numb xs
07:14:51 <Welkin> sometimes I use tuples in a pattern match for a case expression
07:15:02 <awkure> the next generation of computer programming
07:15:04 <MarLinn> MarcelineVQ, thx, that looks like it might offer a few more places to poke at
07:15:05 <Welkin> case (f x, g y, h z) of ...
07:15:13 <Bonnie> can anyone help me?
07:15:32 <lpaste> jerome pasted ‚Äúthere's a foldM somewhere‚Äù at http://lpaste.net/345776
07:15:46 <jerome> Hi guys
07:16:01 <jerome> Can you help me improve the lpaste just posted ?
07:16:18 <Welkin> Bonnie: hello- ello- ello. Is there anybody out there---?
07:16:21 <jerome> related to https://projecteuler.net/problem=61
07:17:09 <Bonnie> Im asking, do you know about the problem?
07:17:19 <sm> Bonnie: fromEnum returns a single item, but ++ expects two lists of items
07:17:22 <ggVGc> Drezil, MarLinn, lyxia: thanks, all those things are useful. I'll see how I can apply it to my case :)
07:17:27 <Welkin> Bonnie: so that was not a pink floyd reference?
07:17:35 <Bonnie> ahhhhh nicenice!!
07:17:38 <sm> if you read the error message carefully, it will make sense
07:17:42 <Bonnie> thanks sm
07:17:49 <Bonnie> helped me 
07:18:10 <Bonnie> but can i use" :"?
07:18:19 <Welkin> Bonnie is comfortably numb
07:18:26 <Welkin> :t (:)
07:18:28 <lambdabot> a -> [a] -> [a]
07:18:32 <Welkin> look at the types
07:18:34 <Welkin> they tell all
07:18:46 <Bonnie> @Welkin thank u :)
07:18:46 <lambdabot> Unknown command, try @list
07:18:49 <maerwald> Welkin: no :P
07:18:52 <sm> yes, you could do (fromEnum x : []). But easier to do [fromEnum x]
07:19:06 <maerwald> (:) could always return an empty list if you are funny 
07:19:22 <Bonnie> sm but fromEnum x is not a list right?
07:19:25 <hpc> if it wasn't a constructor at least ;)
07:19:37 <Welkin> a boa constructor
07:19:41 <sm> Bonnie: right, but writing in [ ] makes it one
07:19:48 <awkure> test
07:20:01 <sm> Bonnie: but best of all, and maybe you were thinking this:  fromEnum x : list2numb xs
07:20:04 <Bonnie> ahhhh now i get it haha thank u guys :)
07:20:09 <lpaste> jerome revised ‚Äúthere's a foldM somewhere‚Äù: ‚Äúthere's a foldM somewhere‚Äù at http://lpaste.net/345776
07:20:21 <Bonnie> yes sm that is it!
07:21:42 <maerwald> hpc: that fact is not part of the type signature
07:23:50 <hpc> it's part of the identifier name, and you technically said (:) and not (a -> [a] -> [a])
07:23:55 <hpc> (the best kind of correct!)
07:24:05 <maerwald> hpc: what?
07:24:14 <hpc> technically correct is the best kind of correct
07:24:17 * hpc is being silly
07:24:49 <maerwald> me too, that's ok
07:25:25 <sm> I want to have one (or possibly more) threads sending events to another thread. Chan says "possibility of races, deadlocks etc", and I'm unsure if it's suitable for this. And if not, when *is* it safe to use ?
07:25:50 <maerwald> sm: is this about darcsden?
07:26:02 <sm> no, this is for hledger-ui
07:26:15 * maerwald wonders how he can force sm to work on darcsden
07:26:36 <sm> hehe, good to hear interest! I'd like to find a way too
07:27:04 <sm> I did a little this week (working on ssh server, GHC 8 support)
07:27:12 <Bonnie> guys just one question again: how can i make a string "0270" to  be treated like int? is it possible with fromEnum?
07:27:14 <sm> and a darcsden release , actually
07:27:21 <maerwald> the main problem was still that darcs is not thread-safe afair
07:27:44 <maerwald> and relies on CWD
07:27:55 <sm> ah, there's way out of scope for what I can tackle. It's darcs, not darcsden
07:28:03 <sm> s/there/that/
07:28:08 <maerwald> but darcs has beautiful code :P
07:29:28 <lpaste> lyxia annotated ‚Äúthere's a foldM somewhere‚Äù with ‚Äúthere's a foldM somewhere (to jerome)‚Äù at http://lpaste.net/345776#a345781
07:29:38 <sm> so.. is Chan a reliable way to send events between threads ?
07:31:00 * MarLinn . o O ("Come to the darcs side. We have cookies.")
07:32:03 <lyxia> Bonnie: read?
07:32:51 * hackagebot Glob 0.7.13 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.13 (MattiNiemenmaa)
07:32:51 <ongy> do you? Way to many cookies for websites already, why copy them for vcs?
07:33:50 <sm> maerwald: actually, is darcs limitation affecting you in practice ?
07:33:57 <sm> is that
07:36:14 <geppettodivacin> Is there a way to make ghci forget a cached value? I interrupted it during a long computation and now it displays "Interrupted" when I try to recompute it.
07:36:16 <Bonnie> Lyxia yes i just don't understand how 2 use read :/ 
07:36:40 <lyxia> > read "0280" :: Int -- does that work
07:36:42 <lambdabot>  280
07:36:44 <lyxia> it does
07:37:13 <ggVGc> > read "0x34" :: Int
07:37:15 <lambdabot>  52
07:37:24 <ggVGc> nit sure I agree with that
07:37:34 <ggVGc> but yeah, maybe
07:40:00 <zipper> Hey how can I query stack for the version of a package I am using?
07:40:36 <MarLinn> ongy, if sites don't invalidate old cookies and you store them in vcs, you might be able to go back in time to previous sessions. Great fun for the whole family if it happens to work, say, on online banking sites.
07:41:10 <MarcelineVQ> zipper: try stack exec -- ghc-pkg list
07:41:15 <ongy> MarLinn: yay, replay attacks. I hope no banking system is actually that bad
07:41:27 <zipper> Thanks MarcelineVQ 
07:42:47 <zipper> Do we have any wreq users getting this error for sites like you tube `*** Exception: TlsExceptionHostPort (HandshakeFailed Error_EOF) "www.youtube.com" 443`
07:43:08 <hpc> > read "0o280" -- ggVGc
07:43:11 <lambdabot>  *Exception: Prelude.read: no parse
07:43:40 <hpc> > (read "0o12" :: Int, read "0b1001" :: Int)
07:43:42 <lambdabot>  (10,*Exception: Prelude.read: no parse
07:44:30 <hexagoxel> (`stack list-dependencies` probably is way more reliable/accurate)
07:46:55 <MarLinn> hpc, I think there was an extension for binary
07:47:10 <MarcelineVQ> BinaryLiterals lambdabot doesn't seem to have it available
07:48:36 <MarcelineVQ> though read should still read them though
07:49:35 <MarcelineVQ> At least I thought it did, clearly not given the error above
07:52:52 * hackagebot colour-space 0.1.1.0 - Instances of the manifold-classes for colour types  https://hackage.haskell.org/package/colour-space-0.1.1.0 (leftaroundabout)
07:53:18 <MarLinn> mh, seems like it only activates literals, but doesn't add any functionality to the reader. Makes sense I guess
08:02:52 * hackagebot bolt 0.1.0.3 - Bolt driver for Neo4j  https://hackage.haskell.org/package/bolt-0.1.0.3 (bflyblue)
08:15:25 <sumi> http://lpaste.net/345794
08:16:07 <sumi> if currying happens then http://lpaste.net/345794 in this second function is also supposed to work right ? am I missing something
08:18:25 <lyxia> head $ dropWhile f stock = head (dropWhile f stock)
08:18:33 <lyxia> head $ dropWhile f = head (dropWhile f)
08:18:59 <lyxia> dropWhile f :: [(a,a,a,a)] -> [(a,a,a,a)], so you can't apply head to it
08:19:05 <lyxia> you can compose with head though
08:19:08 <lyxia> head . dropWhile f
08:24:47 <stalk> hello
08:25:50 <sumi> @<lyxia> please have a look at this I updated http://lpaste.net/345794
08:25:50 <lambdabot> Unknown command, try @list
08:26:50 <sumi> Please have a look at http://lpaste.net/345794 and suggest me. I am a beginner.
08:27:51 <MarLinn> I think I might have finally figured out my ghc build troubles. Seems like mounting a shared folder into a VM (as writeable) and trying to build there is not a good idea.
08:28:31 <mmaruseacph2> sumi: f x = g $ h a x is the same as f x = g $ h a $ x which is the same as f x = g . h a $ x and only now you can remove the x
08:28:51 <mmaruseacph2> that's what lyxia said above too
08:31:17 <sumi> Thank you very much mmaruseacph2 & lyxia
08:36:46 <manek> Hello! I was searching for this function but didnt found anything and I dont want to implement it by myself cause it is just ugly method to fix missing standard libraries.
08:37:07 <manek> I'm looking for something like this: mapWithKeyM :: (k -> a -> m b) -> Map k a -> m (Map k b)
08:37:40 <manek> oh wait I can use sequence!
08:37:52 <manek> thank you ! :D
08:38:20 <lyxia> traverseWithKey has that signature
08:38:46 <lyxia> but if you don't need the key then sequence/traverse do that indeed
08:38:52 <sm> maerwald: ping - is that darcs limitation affecting you in practice ?
08:39:13 <maerwald> sm: it was in the context of implementing SSL for darcsden, which requires multi-threaded environment
08:40:09 <sm> ah, interesting
08:40:25 <sm> it's possible to just put darcsden behind an SSL proxy, right ?
08:40:48 <maerwald> yes, but then you have annoying stuff with internal urls, external entities and whatnot
08:43:01 <tabaqui1> uhm, cannot formulate the question so
08:43:12 <tabaqui1> replicate 5 <$> newEmptyMVar
08:43:26 <tabaqui1> it returns 5 absolutely identical mvars
08:43:34 <tabaqui1> not 5 differents mvars
08:44:10 <tabaqui1> I thought that replicate means `copy` in English, not so/
08:44:16 <tabaqui1> *?
08:45:24 <erisco> yes, it copies the same one
08:48:32 <tabaqui1> so how can I create list of different objects?
08:49:39 <erisco> EvanR, that's a good point, as that breaks the purity of join
08:50:54 <erisco> you sequence them, so  newEmptyMVar >>= \a -> newEmptyMVar >>= \b -> ... and so forth
08:51:10 <lyxia> replicateM 5 newEmptyMVar
08:51:16 <erisco> :t sequence (replicate 5 <$> newEmptyMVar)
08:51:17 <lambdabot> error:
08:51:17 <lambdabot>     Variable not in scope: newEmptyMVar :: t a
08:51:43 <erisco> well if it was there it would be  IO [MVar a]
08:52:17 <lyxia> without <$>
08:53:11 <erisco> oh derp :) cannot take anything for granted, heh
08:53:20 <tabaqui1> putMVar (a !! 0) 2
08:53:24 <tabaqui1> takeMVar (a !! 1)
08:53:27 <tabaqui1> hangs
08:53:29 <tabaqui1> looks fine
08:53:33 <tabaqui1> thanks
08:53:35 <erisco> okay I misunderstood slightly
08:54:01 <erisco> replicate 5 <$> newEmptyMVar   copies the same mvar 5 times
08:54:10 <erisco> replicate 5 newEmptyMVar  copies the instruction to make a new mvar 5 times
08:55:57 <mmaruseacph2> :t getRandom
08:55:58 <lambdabot> error: Variable not in scope: getRandom
08:57:51 <mniip> 1480092170 [19:42:50] <tabaqui1> replicate 5 <$> newEmptyMVar
08:57:55 * hackagebot model 0.2 - Derive a model of a data type using Generics  https://hackage.haskell.org/package/model-0.2 (PasqualinoAssini)
08:57:59 <mniip> replicateM 5 newEmptyMVar
09:07:12 <stalk> Could somebody on fedora 25 try running this http://lpaste.net/4900356263654719488 ? I'm having trouble with stack and wonder if it's due to fedora or me
09:07:50 <hpc> what error do you get?
09:07:57 <stalk> hpc: module not found
09:08:12 <stalk> the module in question being `filestore` itself
09:08:17 <erisco> import Control.hpc
09:08:21 <erisco> maybe he's Data
09:08:55 <Guest76050> Anyeone have to help me fix a 2 line function?
09:08:57 <hpc> stalk: are you sure it's a module named "filestore" and not "Data.FileStore"?
09:09:01 <Guest76050> I'd be super happy and appreciative
09:09:29 <Guest76050> *Anyone have (time to)**** help me :p
09:09:40 <stalk> I'm sorry, I actually meant `Data.FileStore`
09:10:09 <lyxia> Guest76050: you can just ask your question, it's much more efficient than asking for permission
09:10:38 <Guest76050> ahh, thanks
09:10:44 <hpc> your stack.yaml looks fine
09:10:47 <Guest76050> http://pastebin.com/9z5uXdQv
09:11:00 <Guest76050> Basically this function is complaining about typing
09:11:00 <stalk> hpc: Just to be clear, I'm not the author
09:11:14 <Guest76050> My first time to actually use a function as an arguement
09:11:27 <hpc> ah, fair enough
09:11:37 <lyxia> Guest76050: you just forgot to recursively call mape
09:12:22 <lyxia> y : mape f e' xs
09:12:26 <stalk> I'm trying to "hack" on this module to adapt it to my needs. It worked before, but I think the update from f24 to f25 changed something and now it gives me this error
09:12:46 <Guest76050> You're my hero
09:12:49 <Guest76050> Thanks man
09:12:55 * hackagebot model 0.2.1 - Derive a model of a data type using Generics  https://hackage.haskell.org/package/model-0.2.1 (PasqualinoAssini)
09:13:24 <hpc> stalk: trying on windows
09:14:16 <stalk> hpc: I predict it will work. andreas_k tried and it worked
09:14:50 <hpc> hmm, odd
09:15:12 <hpc> can you paste your full "stack build" output? might be something before that error line that says what's wrong
09:15:14 <stalk> well, there are big chances I just messed up somewhere and it's not an OS problem
09:15:22 <stalk> ok, with -v?
09:15:42 <hpc> oh, and are you getting the error when you run the example or on building?
09:16:40 <stalk> when running
09:16:55 <hpc> hmm
09:17:12 <stalk> actually, when running `stack ghci` and then `:l` the example file, it loads correctly
09:18:27 <hpc> what if you run stack runhaskell examples/darcs-days.hs?
09:18:29 <hpc> without the cd
09:19:22 <stalk> http://lpaste.net/153446382483537920
09:19:26 <stalk> it gives me this error
09:19:33 <Natalya> Hello! I am from Moscow. Does anyone want to chat?
09:22:00 * hpc is out of ideas :(
09:22:18 <hpc> my usual approach to packaging issues is to assume i messed up somewhere and start over
09:22:38 <jophish> thoughtpolice: is pcap-conduit good to use?
09:24:20 <stalk> hpc: that's `stack build`'s output http://lpaste.net/8243621281455407104
09:26:18 <stalk> Let me test it with a fresh user
09:30:05 <stalk> ah, fresh user works
09:35:34 <osfameron> is there a way to use neovimhaskell/haskell-vim without the maddening autoindent?
09:35:43 <osfameron> e.g. I only want the syntax highlighting
09:36:10 <stalk> haha, yes, I `rm -rf`'d all stack related directories and it works now
09:36:18 <stalk> Thanks AndreasK and hpc !
09:39:16 <osfameron> aha, there's no configuration for it, but I can switch it by massacring the source vim file.  I might submit a patch/bug report for that :-(
09:41:43 <osfameron> and hurrah, there already is one https://github.com/neovimhaskell/haskell-vim/pull/88
09:41:58 <osfameron> alx741++
09:42:14 <hpc> stalk: yay
09:45:59 <alx741> osfameron: as a workaround you could use that branch, until it's merged upstream: https://github.com/alx741/haskell-vim/tree/disable_indentation
09:46:23 <alx741> I'm using vim-plug, so I have this line in my .vimrc:     Plug '~/lab/haskell-vim', { 'branch': 'disable_indentation' }
09:46:50 <alx741> replace the innter '...' with the URL of course
09:56:55 <erisco> is it just me or is there a lack of algorithms for Data.Array.Unboxed?
09:57:09 <erisco> no folds!
09:59:58 <erisco> I cannot believe that I'd really have to write it myself
10:00:33 <glguy> @tell conal I had an idea for deriving flatter datatypes from the GHC.Generics representation of types for tries, it doesn't quite work out yet but I'm not sure how far away it is from working http://lpaste.net/345849
10:00:33 <lambdabot> Consider it noted.
10:06:32 <erisco> maybe the reasonable thing is to convert the array to a list for means of folding
10:09:20 <erisco> I dunno, I am always skeptical about the compiler
10:23:07 <stalk> jedai: I'm starting to get something working
10:24:24 <erisco> why are unboxed types so restricted, hrm
10:25:24 <sleblanc> hello, I am looking for information on building and packaging haskell apps for Windows, from a Linux development machine.
10:25:48 <sleblanc> when I search for Windows haskell, most information I find is about running and developing on Windows
10:25:53 <osfameron> alx741: thanks - if it doesn't get merged soon I'll do that.  For now I just butchered it inline as it was annoying me so much :D
10:26:06 <sm> sleblanc: you can do it in wine sometimes
10:26:28 <osfameron> I didn't know that Pathogen/Bundler/Vundle/Whatever-the-new-vim-installer-hotness-is-now let you install specific branches too, cute
10:26:46 <sm> or you can do it on appveyor and get binaries from there
10:27:58 <sm> sleblanc: I guess you're talking about shipping windows binaries, right 
10:28:22 <sleblanc> yes!
10:28:40 <sleblanc> key part being making those binaries ;-)
10:29:17 <sleblanc> I am starting work on a project, and I am still split between using Haskell and Python
10:29:33 <Aruro> haskell and windows? hm
10:29:50 <sleblanc> because most of my users will be using Windows, and I do development on Linux‚Ä¶ I don't want to start installing Windows VMs and stuff
10:30:02 <Aruro> use python :)
10:30:53 <sm> deploying a haskell app will be easier than a python one, all being equal
10:31:29 <Aruro> sm: how much easier?
10:31:54 <sm> <-   this much   ->
10:32:05 <anks> Hi, can anyone help me with getting this to compile: http://pastebin.com/pzAQMrWV
10:32:36 <anks> i'm trying to use row polymorphism with vinyl, but it seems that it cannot deduce the right type
10:32:47 <sleblanc> anks, funky character "ss ‚äÜ sr", what is this?
10:33:12 <anks> this is unicode symbol operator representing constraint
10:33:21 <anks> from vinyl library
10:33:23 <glguy> sleblanc: You can type that character into google and it will show a wikipedia link
10:33:43 <Aruro> anks: is easy to type them?
10:33:59 <Aruro> it*
10:34:11 <glguy> In VIM you can type ^K(_ to enter a ‚äÜ
10:34:13 <sleblanc> anks, is this built into Haskell?
10:34:14 <anks> This is the error:    ‚Ä¢ Could not deduce (RElem
10:34:15 <anks>                           'HttpService sr (Data.Vinyl.TypeLevel.RIndex 'HttpService sr))
10:34:15 <anks>         arising from a use of ‚Äòrlens‚Äô
10:34:15 <anks>       from the context: (Monad m, '['HttpService] ‚äÜ sr)
10:34:17 <anks>         bound by the type signature for:
10:34:20 <anks>                    httpFun :: (Monad m, '['HttpService] ‚äÜ sr) =>
10:34:23 <anks>                               ReaderT (Rec (Attr m) sr) m ByteString
10:34:24 --- mode: ChanServ set +o glguy
10:34:26 --- kick: anks was kicked by glguy (anks)
10:34:47 <anks> right
10:34:50 <anks> irc ftw ;]
10:34:50 <glguy> You can paste to a pastebin
10:34:55 <anks> oknedrupa: 
10:34:57 <anks> ok
10:35:52 <anks> http://pastebin.com/Rznm3vKY
10:37:14 --- mode: glguy set -o glguy
10:38:46 <Aruro> sleblanc: there is this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntax
10:39:11 <Aruro> how he made use of above symbol i dont know
10:41:49 <geekosaur> you don't need unicode syntax for that, or a compiler extension. unicode symbol operators are perfectly valid in standard Haskell
10:42:12 <Aruro> yeah, i misundersood, thought he was using it instead of =>
10:42:14 <glguy> You need an extension, however, to use type operator ‚äÜ 
10:42:18 <geekosaur> (lambdabot has been known to not accept them but that was a bug in the safety wrappers)
10:42:24 <sleblanc> geekosaur, oh, I did not know
10:43:28 <Aruro> but one can not have unicode identifiers?
10:43:35 <sleblanc> sm, so, should I go down the "Build on Windows" road, trying to adapt the solutions to a Wine install, hoping that it works? What I would like to find is blog posts or accounts of other people in the same situation
10:44:58 <geekosaur> > let —ïÿ´’ÆÍ®à = "mu" in —ïÿ´’ÆÍ®à
10:45:00 <lambdabot>  "mu"
10:45:09 <sleblanc> that's not very nice
10:45:16 <sleblanc> (this specific example)
10:45:23 <anks> > sad
10:45:26 <lambdabot>  error:
10:45:26 <lambdabot>      ‚Ä¢ Variable not in scope: sad
10:45:26 <lambdabot>      ‚Ä¢ Perhaps you meant ‚Äòsnd‚Äô (imported from Data.Tuple)
10:45:27 <geekosaur> same rules as usual, if it's a unicode letter then it's an identifier character, if unicode symbol it's an operator character
10:45:40 <anks> any clues guys?
10:46:39 <anks> nvm, gotta go, there's a craft beer festival in my city
10:47:53 <erisco> is there a way to get from Int8 to Word8 without jumping through Integer with fromIntegral?
10:48:17 <mmaruseacph2> they should fuse together afaik
10:48:22 <mmaruseacph2> or you could try unsafeCoerce
10:48:27 <glguy> erisco: Yeah, use fromIntegral
10:48:35 <mmaruseacph2> with all the caveats that come from using unsafe functions
10:49:02 <geekosaur> also toEnum . fromEnum which goes through Int --- and should also fuse
10:49:12 <erisco> fromIntegral = fromInteger . toInteger
10:49:26 <glguy> erisco: yeah, it's fine
10:49:52 <erisco> how do you know it vanishes?
10:50:26 <erisco> there are some pragmas for Int <=> Word conversions
10:51:07 <glguy> erisco: You can dump the core to see what optimizations did: -ddump-simpl
10:51:12 <glguy> You can look at the RULES in the source code
10:52:03 <sm> sleblanc: I've used both of those methods, and I'd recommend appveyor, which is easier. You can see it used at http://hledger.org/download.html
10:52:21 <sm> I don't think there's much written about it
10:53:28 <sm> I'm just linking to the latest appveyor-built executables, but there is also some concept of a more formal release artifact
10:54:37 <sm> I'm sure you could also rent some kind of windows VPS nowadays, and use it to build stuff yourself with stack
10:55:13 <sm> but appveyor is free, and great
10:55:18 <sleblanc> sm, thank you! great find
10:55:26 <glguy> it will be good to have a Windows environment anyway since you'll need to actual test on it
10:55:36 <sm> heh that's what users are for
10:55:41 <glguy> things work differently on Windows and Linux
10:55:48 <sleblanc> glguy, indeed
10:55:53 <glguy> depends on what his users expect
10:56:06 <sm> yeah. "It depends"
10:57:02 <erisco> do I need to turn on optimisations as well?
11:00:05 <erisco> what flags to dump core only? don't generate .o or link and so on
11:19:23 <erisco> uhh wat... is duplicate record fields kinda broken?
11:20:03 <Tuplanolla> Is that a loaded question?
11:20:24 <erisco> it only worked when I annotated the projector
11:20:52 <erisco> even though the data value was annotated
11:22:55 <erisco> back to name prefixes then
11:37:59 <mmaruseacph2> or lenses
11:38:01 * hackagebot rerebase 1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1 (NikitaVolkov)
11:39:17 <jacco> Are there any alternatives to monad transformers that are commonly used? I found extensible-effects, but it seems to have very few reverse dependencies
11:40:40 <erisco> dependents
11:48:01 <manek> jacco: extensible-effects have performance overhead cause they are implemented on top of free monad
11:53:01 * hackagebot cabal-debian 4.35.3 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.35.3 (DavidFox)
12:03:08 <erisco> this lib is a little frustrating oO
12:03:19 <erisco> no map with indices for MArray
12:04:08 <erisco> have to convert to list to get things done
12:08:02 * hackagebot shikensu 0.1.3 - A small toolset for building static websites  https://hackage.haskell.org/package/shikensu-0.1.3 (icidasset)
12:29:23 <laudiacay> hey, I'm trying to parse expressions of the form (5--3)
12:29:35 <laudiacay> where - is both "minus" and "negate"
12:29:45 <laudiacay> using the parsercombinators.readp library
12:30:16 <laudiacay> and I'm really not sure what I'm doing, here's relevant code
12:31:43 * geekosaur suspects ReadP is going to have problems with that no matter what
12:32:04 <geekosaur> it's biased toward Haskell syntax which already has problems with that
12:32:44 <laudiacay> yeah idk apparently it's possible
12:32:44 <EvanR> isnt that ambiguous
12:32:51 <laudiacay> one sec getting together relevant code
12:33:25 <AndreasK> You can always just try if its a valid statement when treated as minus, and if not backtrack and use it as negate i guess
12:33:42 <laudiacay> http://pastebin.com/UZFzrM87
12:33:48 <laudiacay> and here's the output right now
12:34:50 <AndreasK> your parseMinus method is called parsePlus in the paste
12:34:52 <laudiacay> http://pastebin.com/SHUHJaMR the left is what it should be giving me, the right is what I'm actually getting
12:35:00 <laudiacay> oh crap yeah i fucked up pasting
12:35:05 <laudiacay> ignore that it's right in the code lmao
12:35:17 <jmorris> why does this not work? http://lpaste.net/345937
12:36:01 <laudiacay> AndreasK: how would you advise that using ReadP?
12:36:36 <Tuplanolla> Needs `Eq a`, jmorris.
12:36:51 <AndreasK> If you can stand it I would just enforce a syntax where negate must be in braces.
12:36:59 <jmorris> in the type Tuplanolla?
12:37:06 <Tuplanolla> Also can't compare `y` to `Nil`, jmorris.
12:37:21 <jmorris> oh
12:40:32 <MarLinn> I'm not sure I'm convinced that you need backtracking
12:41:54 <laudiacay> AndreasK: I don't get to pick the syntax :(
12:42:05 <laudiacay> MarLinn: yeah i don't think so, we havent been taught this in class
12:45:13 <AndreasK> laudiacay: I think splitting it into: number, operator, number, operator, number, ... should work. Number can then just accept a leading - optionally
12:45:45 <laudiacay> AndreasK: how could i do that with parsers i suppose is what I don't understand
12:47:13 <MarLinn> Can you solve it on paper as a state machine? 
12:47:18 <AndreasK> laudiacay: You can use option
12:50:24 <AndreasK> laudiacay: If you have learned grammars already try to write down the grammar in a form thats not left recursive. Once you have done that it's more or less a mechanical translation
12:50:34 <laudiacay> hmmm lemme see ill try that
12:54:14 <monochrom> If you want left-recursive, use chainl or chainr
12:58:38 <duduar> hi there
12:58:59 <duduar> guys can you hear me?
12:59:26 <cite-reader> We can. (Not all of us are guys)
12:59:30 <FullyFunctional> In space no one can hear you.
12:59:51 <duduar> sry I was just wondering if I had to do the any registration.
12:59:57 <EvanR> nobody here but us chickens
13:00:08 <cite-reader> I'm a crab. *snaps pincers*
13:00:11 <tdammers> what is this, -blah?
13:00:18 <cite-reader> Right sorry
13:00:31 <laudiacay> monochrom: i'm using chainl1
13:01:00 <tdammers> duduar: this is IRC; registration is recommended, but not required
13:01:31 <duduar> tdammers well other IRCs force you to register if you want to chat
13:01:45 <laudiacay> ok so what do I do when I get literally the same parse twice from a parsercombinator
13:02:04 <laudiacay> and the shell code my instructor gives me freaks out when it gets more than one parse
13:02:19 <laudiacay> but apparently this parse is ambiguousin that it gives the exact same parse twice
13:02:34 <laudiacay> like it could be thing a, or it could be thing a, therefore we don't know what it is
13:02:35 <monochrom> File a bug report. To yourself.
13:02:38 <laudiacay> this is so stupid
13:03:00 <monochrom> More seriously, talk to your instructor.
13:03:01 <AndreasK> laudiacay: Whats the input? There can be sometimes two valid parses which give the same result
13:03:35 <monochrom> I know there is a prof who keep reminding students: get your money's worth, go to office hours.
13:04:03 <AndreasK> What if I study for free :(
13:04:24 <monochrom> In fact, the full sentence is: What if you get stuck? Get your money's worth, go to office hours.
13:04:47 <laudiacay> it's due at midnight :( AndreasK, it's let var = (1+2) in var*var and my output is Ambiguous parse: [(LetTLE ["var"] [Plus (Number 1) (Number 2)] (Mult (Var "var") (Var "var")),""),(LetTLE ["var"] [Plus (Number 1) (Number 2)] (Mult (Var "var") (Var "var")),"")]
13:05:02 <laudiacay> like those are exactly the same....
13:05:06 <laudiacay> maybe i should use sepby1
13:05:08 <laudiacay> and munch
13:05:10 <laudiacay> in more places
13:05:16 <laudiacay> greed is always good in parsers
13:05:50 <monochrom> This is why we instructors and TAs get paid so much money and need to do so little work. Students start their assignments two days after the final office hours.
13:07:18 <MarLinn> just create both results, escape from IO, filter duplicates, sneak back in through the smokers' entrance, done!
13:07:20 <AndreasK> Sry don't have a good idea what would case that from the top of my head either
13:08:04 * hackagebot sproxy2 1.90.2 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.90.2 (ip1981)
13:08:17 <laudiacay> monochrom: i've been working on this for a week
13:08:20 <laudiacay> with no progress
13:08:43 <Alphinopac> Hi there is there a newbie help subchannel
13:09:03 <cite-reader> #haskell-beginners
13:09:17 <MarcelineVQ> there is but questions are just as welcome here
13:09:41 <Alphinopac> cite-reader: Thanks
13:11:06 <n_blownapart> hi from prelude can I send commands to the unix shell, as in ruby repl where you do  > .cd app   with dot notation?  thanks
13:11:48 <MarcelineVQ> from ghci?
13:11:59 <Alphinopac> MarcelineVQ if a type is [a] it could be that it is in fact [[b]] and a's type is a list
13:12:26 <Alphinopac> Right?
13:12:33 <n_blownapart> yeah
13:12:38 <geekosaur> :!cmd
13:12:40 <jedai> n_blownapart: there's this command in ghci :help, it will tell you what you want and much more (the answer is yes, with :!command )
13:12:49 <MarcelineVQ> Alphinopac: yes
13:12:54 <geekosaur> note that cd is not a useful command for that, either in ghci or ruby
13:13:00 <MarLinn> laudiacay, could it be that the parser sees the two appearances of "var" as a permutation?
13:13:07 <jmorris> could someone help me with this function, http://lpaste.net/345937, it returns the head or x 
13:13:17 <laudiacay> MarLinn: i hope not
13:13:20 <geekosaur> mmm, actually it might well work on windows because windows has a different notion of paths
13:13:27 <n_blownapart> geekosaur not sure I understand why not
13:13:56 <geekosaur> as I just said, on windows it might work. current directory is a session property not a process property
13:14:15 <geekosaur> on unix/linux it spawns a subshell, which changes directory and exits. nothing else is affected
13:14:23 <laudiacay> how would i say the regex -?[0-9]+ in parsers
13:14:29 <jedai> n_blownapart: basically the command change directory but the repl does not see it (there's a :cd command though, that works everywhere)
13:14:30 <laudiacay> i'm really just struggling with the optional -
13:14:36 <laudiacay> i know how to do the +
13:14:52 <laudiacay> like how can you say parse one of this char.... or don't.... but don't fail if you don't?
13:15:05 <AndreasK> laudiacay: http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-ParserCombinators-ReadP.html#v:option
13:15:19 <AndreasK> laudiacay: Said it before option works for that
13:15:33 <laudiacay> oh I didn't understand it before
13:15:34 <AndreasK> Or optional if you want to throw away the result
13:15:38 <laudiacay> hmmmmm okay
13:15:43 <n_blownapart> geekosaur: jedai thanks yeah should have guessed it was with :
13:16:42 <MarLinn> :!ghci  (*cue inception music*)
13:17:02 <geekosaur> jmorris, that function doesn't make a lot of sense
13:17:26 <geekosaur> line 11 you check for Nil :. something, which would be a list with one element which is an empty list
13:17:48 <jmorris> geekosaur: oh i think i know what to do
13:18:12 <geekosaur> the correct way to do this, if it's what it looks like it intends to do, doesn't involve == at all
13:18:36 <jmorris> I got it
13:18:38 <jmorris> thanks
13:18:49 <laudiacay> oh shit i just realized... I have to be able to negate expressions too, like in parentheses :(
13:18:53 <jmorris> i did it in two different equations
13:18:57 <laudiacay> damn
13:19:05 <jmorris> like this, headOr x (y:.ys) = y
13:19:05 <jmorris> headOr x Nil = x
13:20:34 <AndreasK> laudiacay: so make it [-]expr
13:20:44 <n_blownapart> well I'll function with two commands I guess :!pwd works and :cd .. works for certain things. 
13:22:07 <Alphinopac> How do I shash dropWhile, \=, head, [[a]] in order to drop [a]'s until i found a [a] with non zero head?
13:22:19 <Alphinopac> *smash
13:23:47 <AndreasK> Alphinopac: I would use head . takeWhile 
13:23:51 <jedai> Alphinopac: What have you tried ?
13:24:23 <AndreasK> Although I guess find would  be even better
13:24:32 <Alphinopac> My best guess was dropWhile ((/=) 0 (head)) [[a]]
13:24:33 <jedai> Alphinopac: by the way it's /= not \=
13:24:58 <Alphinopac> Yeah im on phone so sorry for the typos
13:25:03 <AndreasK> find (not . null) [[], [1]]
13:25:45 <AndreasK> Makes it total function as a nice sideeffect :D
13:25:56 <jedai> Alphinopac: ok the problem here is that's the same as (0 /= head) and you're comparing a number 0 and a function head() (plus the whole thing shoulkd be a function and there no argument
13:26:35 <jedai> dropWhile (\xs -> 0 /= head xs) 
13:26:42 <jedai> Alphinopac: that works
13:27:15 <Alphinopac> Is that a lamda?
13:27:17 <jedai> Alphinopac: you don't always have to use pointfree style, thoug here you could : dropWhile ((/=0) . head)
13:27:23 <hrk> Could someone please explain to me what does the 't' in type parameter mean in the definition of GenParser and why is it even legal to have such "free"(?) type variable? https://www.stackage.org/haddock/nightly-2016-11-25/parsec-3.1.11/Text-Parsec-ByteString.html
13:27:30 <jedai> Alphinopac: Yes
13:28:17 <Tuplanolla> It's not used, so it can be anything, hrk.
13:28:29 <jedai> Alphinopac: there remains the problem that 1) your function doesn't do what you said, that would be dropWhile ((== 0) . head)
13:28:53 <jedai> 2) Your function will blow up if there's an empty list in the list of list argument
13:29:59 <jedai> I don't know if 2) is a problem for you, or even if you consider that an empty list has a non-null head (probably not ?)
13:31:18 <geekosaur> hrk, it isn't used by the ByteString parser. note that the String and Text parsers also have a GenParser, and both use that parameter
13:31:53 <geekosaur> so it's probably kept the same shape for all of them to make it easier to switch between backends
13:32:47 <Alphinopac> jedai: i pattern check against empty lists for safety
13:35:15 <hrk> Tuplanolla, geekosaur: thanks, I'll have to read something about it. At least now I know what to read about: phantom types :)
13:35:51 <geekosaur> well, in this case it won't tell you much because in the normal use case for parsec it's not even usefully phantom. it's just irrelevant
13:36:48 <geekosaur> (it's a type synonym, so during typechecking the unused tyvar should just vanish without affecting anything)
13:37:01 <Tuplanolla> The idea is for users to import either `Text.Parsec.String` or `Text.Parsec.Text` and get the right kind of definition for `Parser`, hrk. That's one thing.
13:38:57 <jedai> Alphinopac: ok, though I don't get a which stage you do that. If you want to be more robust you could do : dropWhile headIsZero where headIsZero (0:_) = True; headIsZero _ = False
13:39:36 <hrk> Tuplanolla: that one I understand. I'm just trying to learn more about Haskell by trying to understand libraries I'm using to expand my repertoire of features I could use
13:55:20 <loskutak> Hi, would you please recommend some good books/courses/challenges/... for learning haskell? I had some basics in one of our university courses, but don't remember much and would like to learn it.
13:56:37 <johnw> loskutak: challenge: implement all the function types given in the Data.List module
13:57:16 <julianleviston> :t concatMap
13:57:18 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
13:57:38 <julianleviston> intresting. I would have thought its type would have been concatMap :: (Foldable f, Monoid (f b)) => (a -> f b) -> f a -> f b
13:57:59 <julianleviston> Is concatMap not parallellizable ‚Äúout of the box‚Äù ?
13:58:13 <julianleviston> :t foldMap
13:58:15 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:58:48 <julianleviston> is folding inherently sequential?
14:00:52 <mmaruseacph2> is there a way to tell QuickCheck "hey, I expect this property to fail sometime but not more than 5% of the tests"?
14:01:12 <ezyang> mmaruseacph2: I doubt it 
14:01:20 <geekosaur> folding is since each iteration receives the result of the previous fold along with the next item to be folded
14:01:28 <ezyang> but maybe SmallCheck has a feature like this; it makes a lot more sense if you're doing exhaustive testing 
14:01:46 <julianleviston> geekosaur: but is that inherent to what a catamorphism is?
14:01:54 <mmaruseacph2> testing RNGs
14:02:45 <julianleviston> geekosaur: or just an implementation detail in the lambda-calculus based pure FP languages?
14:02:57 <julianleviston> geekosaur: sorry for asking annoying questions
14:03:16 <geekosaur> julianleviston, conceptually perhaps not. practically, to remove an ordering constraint you need to require something extra (commutativity)
14:04:09 <julianleviston> geekosaur: I‚Äôm interested in if there could be a typeclass that takes some monoidal values, maps their ‚Äúcontents‚Äù and mappends them together‚Ä¶ in parallel or sequential
14:04:24 <geekosaur> I think there are such things already
14:04:28 <AndreasK> So map reduce?
14:04:36 <julianleviston> AndreasK: yep
14:05:12 <julianleviston> geekosaur: so they say nothing about *how* they‚Äôre evaluated, but rather leave that open to an execution scheme?
14:05:23 <geekosaur> right, on a conceptual level
14:05:54 <geekosaur> but when you head down into lambda calculus instead of abstract mathematics, you end up having to think about that
14:05:55 <AndreasK> googling haskell map reduce at least gives a few results which look like they could help you
14:05:59 <julianleviston> geekosaur: well, to do that on a practical level (as well), one would need to program it according to the most open case, right? This is why we can do things like shove applicative into do notation.
14:06:21 <julianleviston> I don‚Äôt want a monad tho.
14:06:49 <julianleviston> because monads are inherently sequential, right?
14:08:00 <geekosaur> iirc monads don't have to be sequential but *enable* sequential processing, and most of the cases where they are useful make use of that
14:08:04 <julianleviston> but I‚Äôd like it to ‚Äúautomatically‚Äù do it in a sequencing style if that‚Äôs what you want, otherwise ‚Äúautomatically‚Äù do it in a parrallel style if that‚Äôs what you want. (without specifying in the expression/ term-level code, but rather only specifying when setting up the type)
14:08:09 <geekosaur> so it's kinda hard to find monad use cases that aren't sequential
14:08:15 <julianleviston> geekosaur: oh? I didn‚Äôt know they could be non-sequential
14:08:20 <geekosaur> (at least conceptually, the list monad is not sequential)
14:08:44 <julianleviston> geekosaur: but the structure is‚Ä¶ isn‚Äôt it? I mean‚Ä¶ a singly linked list has a sequential *shape*
14:09:29 <julianleviston> geekosaur: but maybe when you say ‚Äúconceptually‚Äù you‚Äôre maning ‚Äúhaving a bag of things, that have an order‚Äù ?
14:09:49 <julianleviston> geekosaur: it‚Äôs kinda difficult to talk about the properties of conceptual things unless we define what those properties are isn‚Äôt it?
14:09:53 <geekosaur> yes
14:10:15 <julianleviston> I figure Haskell could do this easily
14:10:32 <geekosaur> I am not remembering offhand the strict definition of the list monad, but my impression is that it represents operating on all elements "simultaneously" with the assumption that they are independent
14:10:43 <geekosaur> (and that assumption is why the stock ListT is broken)
14:10:44 <julianleviston> oh really? wow
14:11:47 <julianleviston> geekosaur: I thought that was what applicative was.
14:11:51 <julianleviston> geekosaur: so much to learn, I have!
14:11:53 <geekosaur> (or more precisely ListT is only a monad when the transformed monad does not introduce an ordering dependency)
14:12:19 <julianleviston> ahhh
14:13:07 * hackagebot rebase 1.0.6 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.6 (NikitaVolkov)
14:13:41 <geekosaur> no, applicative is about chaining actions that can't look at the value being acted on (the actual chain operation can and must look, but the actions being chained can't be conditional on the value). whereas monads get the value and can inspect it
14:14:06 <julianleviston> god I love Haskell :)
14:14:32 <geekosaur> @google arrows idioms meticulous
14:14:34 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
14:14:34 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
14:15:04 <geekosaur> good overview of how arrows, applicatives (which used to be called idioms), and monads relate
14:15:32 <julianleviston> I‚Äôm still pretty curious about how there can be a monad without sequence‚Ä¶ is that a commutative monad?
14:16:14 <AndreasK> julianleviston: Look at the >>= definition for the List instance
14:16:41 <julianleviston> AndreasK: it‚Äôs been a while ‚Ä¶ so I‚Äôll go take another look :)
14:17:27 <AndreasK> Although iirc it's defined as list comprehension so that would result in a guaranteed ordering still I assume?
14:17:34 <volhovm> Hello everyone! :) I have to write some mvc-oriented web app with very simple state.
14:17:37 <geekosaur> as currently implemented
14:17:39 <volhovm> What's the easiest way to do that?
14:17:39 <julianleviston> AndreasK: :( it‚Äôs a comprehension.
14:17:57 <volhovm> I've already spent like an hour reading yesod docs and i think it's kind of overkill.
14:18:05 <julianleviston> oh‚Ä¶ that was 4.9.0.0
14:18:07 * hackagebot rerebase 1.0.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.0.1 (NikitaVolkov)
14:18:14 <geekosaur> there is no requirement for that, and aside from the fact that it wouldn't work very well without manual control over reduction you could in theory define a concurrent (>>=) for lists
14:18:17 <volhovm> I have experience with servant, but i'm not sure it's suitable.
14:18:35 <julianleviston> volhovm: snap is good
14:18:55 <volhovm> I'd like to spend <2h writing it, more logic, less frontend.
14:19:06 <julianleviston> geekosaur: wow. I don‚Äôt know how - wouldn‚Äôt it have to traverse the list a number of times to split it to parallelize it?
14:19:16 <volhovm> i can write something similar using gtk2hs, but the task is about frontend+mpc sadly
14:19:20 <volhovm> mvc*
14:19:22 <julianleviston> volhovm: it depends how well versed you are at Haskell I guess
14:19:38 <julianleviston> volhovm: as to the time taken
14:19:44 <geekosaur> you'd just fork a thread for every list element and concat the results onto the result as they come in
14:20:00 <volhovm> julianleviston: is there any manual on it?
14:20:04 <julianleviston> geekosaur: yeah but somehow you‚Äôd have to get them out, right?
14:20:22 <julianleviston> volhovm: the main page has docs‚Ä¶ 
14:20:29 <geekosaur> ...the problem with this being that laziness means most of the time the threads would do nothing and all the computations would be forced outside the threaded code, so it's kinda useless to do so
14:20:34 <julianleviston> volhovm: it doesn‚Äôt have an ‚ÄúM‚Äù story (in MVC) tho‚Ä¶
14:20:58 <julianleviston> volhovm: it‚Äôs not a framework like yesod is.
14:21:37 * MarLinn wonders if the lack of non-sequential monads is a symptom of the our continued struggles to shift to non-sequential programming patterns
14:21:40 <geekosaur> create a Chan of lists, each thread would put its result in the Chan when finished, you pull stuff out of the Chan and concat it onto the result list
14:21:48 <AndreasK> geekosaur: Wouldn't only the argument be evaluated outside of the forked process?
14:21:50 <geekosaur> well, the other reason it's not done is you'd have to do it in IO
14:21:58 <julianleviston> geekosaur: that doens‚Äôt sound very ‚Äúdrop-in-replacement‚Äù ish :)
14:21:58 <volhovm> julianleviston: oh, i wish it was.
14:22:37 <geekosaur> exactly. but in theory the implementation could go around Haskell to do it (that is, process it inside the runtime where the normal rules don't apply)
14:23:52 <julianleviston> volhovm: TBH you don‚Äôt *need* the ‚ÄúM‚Äù any more than just having a DB layer, IMO
14:24:03 <geekosaur> in practice, it has enough hairballs that nobody's going to try it (in Haskell. the list monad is also considered a "logic monad" (see LogicT) and iirc there are logic languages that *do* provide this as a primitive)
14:24:33 <volhovm> julianleviston: i think so, yes. "my model is just these Getters/Setters" sounds plausible :)
14:24:36 <volhovm> thanks
14:25:35 <julianleviston> volhovm: sort of‚Ä¶ I don‚Äôt think the MVC pattern fits FP very well particularly‚Ä¶ you‚Äôre better off with the idea of pipelining transformations of data through functions, and organising things naturally as your business domain requires it.
14:26:05 <volhovm> julianleviston: it's just an auxiliary university task on java course hehe
14:26:21 <geekosaur> think about this one: https://en.wikipedia.org/wiki/Concurrent_logic_programming
14:26:27 <geekosaur> (mentions ghc!)
14:26:59 <geekosaur> (admittedly in the context of implementing a concurrent logic language, but looking at that implementation might well give you ideas...)
14:27:09 <julianleviston> volhovm: the irony is that the ‚Äúnext thing‚Äù by the guy who created MVC is this thing called DCI (Data / Context / Interactions) which seeks to model the MVC objects with their runtime roles‚Ä¶ and we end up as just having a bunch of things with some functionality that runs on them - sounds suspiciously like the FP style data / function break-up to me ;-) (with nice organisation into modules for what you want things
14:27:09 <julianleviston> do / be / act like)
14:27:15 <geekosaur> oh wait
14:27:16 <geekosaur> wrong ghc
14:27:26 <geekosaur> in context that must be guarded horn clause :(
14:27:31 <geekosaur> futz
14:27:50 <geekosaur> think that's the first time I've hit a name collision there...
14:28:57 <EvanR> > 26^3
14:28:59 <lambdabot>  17576
14:29:09 <EvanR> should be enough acronyms for anybody
14:29:58 <AndreasK> Not for everybody though :(
14:30:40 <julianleviston> So if a monad is commutative, does GHC work this out and automagically parrallize it? :)
14:30:45 <julianleviston> I‚Äôm guessing not.
14:31:22 <EvanR> automatically parallizing anything is just not something ive heard of
14:31:27 <Rembane> julianleviston: No, because it could be much slower running it in parallell.
14:31:46 <julianleviston> Rembane: (if you ask it to?)
14:31:52 <julianleviston> I‚Äôm interested in if it *can*...
14:32:18 <Rembane> julianleviston: If you ask it to, by for instance using the par operator it will. But you need to compile your program with the -threaded switch.
14:32:31 <julianleviston> Rembane:  I don‚Äôt want to adjust the term-level code
14:32:40 <Rembane> julianleviston: There's a whole book about it. http://chimera.labs.oreilly.com/books/1230000000929
14:32:51 <Rembane> julianleviston: What's a term-level code?
14:32:59 <julianleviston> Rembane:  sorry that was my ‚Äúhand-wavey‚Äù version of what I meant by automagically
14:33:09 <julianleviston> Rembane: yeah I like that book a lot :) 
14:33:29 <julianleviston> Rembane: term-level code is the code where we write definitions for things...
14:33:36 <EvanR> i.e. code
14:33:38 <Rembane> julianleviston: No automagic in this case. It is too easy to get this wrong. :)
14:33:38 <julianleviston> Rembane: probably badly worded...
14:33:56 <julianleviston> Rembane: I want to *specify* it, but to be able to factor out the specificity of that.
14:34:08 <Rembane> julianleviston: Checkout the Par monad and skeletons in the book.
14:34:11 <julianleviston> Rembane: so‚Ä¶ for example, if I switch the type to a different class...
14:34:21 <julianleviston> Rembane: yeah I‚Äôve read the book :)
14:34:29 <julianleviston> Rembane: I should re-read it many many more times tho.
14:34:45 <Rembane> julianleviston: Indeed.
14:34:46 <julianleviston> Rembane: skeletons doesn‚Äôt come to mind right now‚Ä¶ 
14:35:24 <geekosaur> automatic parallelization is still a hot research topic... but most attempts at it have fared very poorly
14:35:34 <julianleviston> Rembane: ?
14:35:54 <geekosaur> computers turn out to be lousy at figuring out what is worth parallelizing (i.e. the gain is lower than the overhead)
14:35:55 <Rembane> julianleviston: I think I mixed up the words. I meant Strategies: http://chimera.labs.oreilly.com/books/1230000000929/ch03.html
14:37:10 <geekosaur> iirc it's actually most successful with fortran, because the language is so simplistic that working out overhead vs. expected gain is quite tractable
14:38:03 <EvanR> need a fortran monad
14:38:08 * hackagebot pregame 1.0.0.0 - Prelude for applications  https://hackage.haskell.org/package/pregame-1.0.0.0 (jxv)
14:38:09 <Rembane> +1
14:38:26 <netheranthem> that's interesting... outside of losing the advantage of laziness to a degree, what would happen if all functions that could be parallelized in haskell actually were (i.e. map, filter, etc...) what would happen overall?
14:38:40 <geekosaur> (and how to best chunk operations to maximize the gain and minimize overhead)
14:39:20 <geekosaur> netheranthem, net loss because most operations complete too quickly and you eat the overhead without gaining anything from parallelizing
14:41:15 <EvanR> you could parallelize pretty much everything, with this simple rule... when you see f applied to x, evaluate the application of f to x and x in parallel!
14:41:22 <EvanR> and itd be slow as hell
14:41:38 <nitrix> Are records of functions the only alternatives for existantials of type classes?
14:42:48 <nitrix> Presumably, a simple game could have multiple "stages", the menu screen, the game screen and the credits or similar, all of which captures different network events, window events, input events...
14:43:15 <nitrix> I'm trying to devise the best abstraction with handler for each of those events, and group them by those "stages".
14:43:32 <EvanR> ive seen two interesting ways to do that recently without going to OOP way
14:43:42 <EvanR> the OOP way*
14:43:50 <nitrix> It looks very reminescent of OOP though, hence why I'm asking to avoid these pitfalls.
14:44:53 <EvanR> nitrix: with this database-ish language, events only activate if the pattern-matched conditions are met http://witheve.com/
14:45:10 <nitrix> data Stage = Stage { networkHandler :: ..., windowHandler :: ..., inputHandler :: ..., timerHandler :: ... }
14:45:28 <EvanR> essentially, if theres an effect that happens on an event, but only when certain things are true, then you check them all. the system magically figures out how to optimize it
14:45:50 <EvanR> manually managing handlers is the manual way
14:45:54 <EvanR> clearly
14:46:01 <nitrix> Then I can have the current stage as a stateful thing or maybe even a list of these stages if they can overlap and pass the control (events not processed) to the next stage....
14:46:11 <nitrix> This is starting to look like a UI / widget system.
14:46:14 <nitrix> :P
14:46:51 <tdammers> at a glance, it looks like OOP
14:47:06 <EvanR> the flappy birds example there has the start-game and the flip event "on the same level", but one checks the "screen" for the title menu, or for the main game in the preconditions
14:47:11 <nitrix> (Where the top visible/focused UI has priority on handling events, otherwise passes it down to what's below)
14:47:42 <nitrix> EvanR: Checking
14:48:03 <geekosaur> w00t http://downloads.haskell.org/~ghc/8.0.2-rc1/
14:48:08 <EvanR> nitrix: youll notice in your way that sometimes youll pass it down to something that then does a filter-like check to see if the event applies at this time, this is exactly the sort of thing swapping out handlers does too, so its interesting theres two mechanisms for the same ting
14:48:41 <nitrix> EvanR: Yes, they do behave like filters. Now I'm thinking of FRP as well. 
14:48:42 <EvanR> the way eve and this other thing go with it is, theres only one thing, the filter-like checking
14:49:05 <EvanR> handler swapping is an operational way to do that, only its stateful
14:49:28 <nitrix> EvanR: So how is this statefulness avoided?
14:49:30 <EvanR> handler swapping also only goes so far
14:49:44 <EvanR> you wont be able to replace all your checks with them
14:49:55 <nitrix> I've seen the eve lander page before but I still fail to see how that translate directly to Haskell without switching to their approach.
14:50:10 <EvanR> nitrix: well, it definitely avoids the state of "history of what handlers were swapped out when"
14:50:42 <julianleviston> I really like this dan piponi talk: https://vimeo.com/6590617
14:51:25 <EvanR> nitrix: well, theres a way. but i am suspicious of your implied requirement that you dont want to modify anything ;)
14:52:16 <nitrix> EvanR: I've actually put all my project in a legacy folder and looking at what's around to give this a new try from scratch, now that I've deepened my Haskell knowledge.
14:52:18 <erisco> mutate all the things
14:52:42 <nitrix> EvanR: By the way, making a good quality game in Haskell is no small feat.
14:52:53 <erisco> that's how all my Haskell programs go... I have a folder with a bunch of files, each being an iteration of the last
14:53:09 * hackagebot HMarkov 1.0.0.0 - Markov-generated sequences  https://hackage.haskell.org/package/HMarkov-1.0.0.0 (swizzard)
14:53:26 <EvanR> no argument there
14:53:37 <maerwald> nitrix: wrong language for that domain
14:54:13 <EvanR> that has yet to be proven
14:54:20 <maerwald> it already is
14:54:21 <erisco> its alright for non-RT stuff
14:54:24 <nitrix> maerwald: Beyond the upfront design cost and a couple concerns with performance, it's actually nicer to work with.
14:54:29 <monochrom> GHC 8.0.2 release candidate. Black Friday special.
14:54:49 <maerwald> nitrix: except that real-world game development has nothing to do with "upfront design", which is the main reason why it's the wrong language
14:54:58 <nitrix> maerwald: I think if I can implement an engine that's somewhat elegant, I'll be able to make that claim completely false. But it's to get there :P
14:55:07 <Zekka> if someone releases good haskell tools for gamedev I'll be pretty happy
14:55:17 <Zekka> it seems like there's a lot of good parts of tools, at least
14:55:24 <maerwald> nitrix: no, "elegant" is completely uselss for game development, "performance" is what counts
14:55:28 <Zekka> until then I'll proabably stick to other stuff
14:55:44 <Zekka> a lot of these small indie games don't seem to lean that heavily on performance
14:55:46 <EvanR> elegant and performance both dont count, its ease of workflow
14:55:50 <roboguy`> Zekka: as I understand it, one of the main lingering issues is the stop-the-world garbage collection doesn't play well with real time gaming
14:55:51 <nitrix> maerwald: My game has completely pure references between things, and looking them up and modifying them is O(1).
14:55:56 <erisco> which is why you do something like a puzzle game
14:55:56 <Zekka> you know, the type with retro graphics and a really simple world model
14:56:04 <nitrix> Which is as far as I known, unknown of in the Haskell ecosystem.
14:56:12 <m`> maybe a rather mathematical question, however expressed in haskell: say I have two functions: f1 x = x * a; f2 x = x / a; whereas a is a constant value. How can I make this one function which accepts one argument? 
14:56:14 <Zekka> roboguy`: yeah, this is what my game developer friends tell me
14:56:16 <erisco> then you're not so pressured to deliver a smooth framerate
14:56:27 <nitrix> It also detects bicomponents in a graph in O(1) instead of O(|V|+|E|) which is also unheard of.
14:56:48 <maerwald> good, now write an actual AAA engine in haskell
14:56:57 <EvanR> roboguy`: Zekka if Java and C# "real time" games sell millions of copies, it cant be that bad
14:57:04 <Zekka> I don't know exactly what garbage collection methodology Unity, Monogame, and JavaScript implementations tend to use -- those are garbage-collected tools that seem to work OK
14:57:16 <nitrix> maerwald: I do not know enough about OpenGL to do that, but I'll surely try to reach AA.
14:57:17 <monochrom> My impression is that performance is gained by inflated hardware requirements rather than high-performance programming languages. Because for example Civ 5 and probably Civ 6 too uses Lua heavily --- not  a "performance" language in any sense.
14:57:27 <Zekka> EvanR: yeah, I personally seem to think there's a big niche where this apparently works
14:57:40 <Zekka> monochrom: well, the tightest loops in civ 5 and civ 6 probably aren't written in lua
14:57:48 <roboguy`> EvanR: hmm, do they have stop-the-world GC?
14:57:50 <erisco> monochrom, probably for small stuff that runs periodically
14:57:51 <maerwald> nitrix: again: haskell is not the right language. You want full memory control and do weird optimization, not depend on the huge GHC-laziness-machinery
14:57:52 <Zekka> (they probably wouldn't be written in Haskell in an engine targeted to Haskell users, either)
14:57:59 <julianleviston> This is what I was after: https://wiki.haskell.org/MapReduce_as_a_monad
14:58:03 <EvanR> i have first hand experience with games that use their "slow" gc languages, and what i noticed was a milliseconds lag every hour maybe, or during a loading screen
14:58:06 <nitrix> monochrom: Depending on the game, you can also exploit very nice space partitioning data structures or culling algorithms.
14:58:19 <nitrix> Or, lazy drawing :P
14:58:22 <roboguy`> EvanR: my understanding is that it isn't GC in general, it is the stop-the-world GC currently used by GHC
14:58:26 <erisco> the difference with Java and C# is it is easier to game the GC
14:58:29 <nitrix> We lazy evaluate, might as well lazy draw :P
14:58:31 <roboguy`> which can cause "hiccups"
14:58:31 <EvanR> roboguy`: yes, thats the standard strategy
14:58:34 <erisco> object pooling and pre-allocating and so on
14:58:46 <EvanR> incremental GC might not actually do its job
14:58:57 <erisco> if you don't "new" then you don't put stuff on the heap and the GC isn't active
14:59:04 <EvanR> and youll run out of memory despite not using very much in total
14:59:05 <erisco> how straight-forward is it in Haskell?
14:59:40 <erisco> a more promising idea for RT Haskell is code generation
14:59:49 <Zekka> if I were gonna write a game in Haskell I'd probably try to have a pretty big split between world simulator (allowed to lag and freeze periodically) and graphics output (not allowed to lag and freeze -- possibly not written in Haskell)
15:00:01 <EvanR> erisco: maybe where RT means "thing running on a microcontroller", not a PC gaming rig
15:00:09 <nitrix> Now I understand why there's a more receptive #haskell-game channel.
15:00:09 <EvanR> with 16G of ram
15:00:11 <maerwald> haskell might be interesting for game logic to some degree, but for proper engine stuff: lol no
15:00:11 <Zekka> and it's possible you could apply Haskell features towards making the bridge between these parts of the program really seamless
15:00:24 <erisco> EvanR, it is quite trivial to squander it
15:00:33 <Zekka> iirc there's someone in this channel who actually wrote a game using the methodology I'm talking about?
15:00:35 <maerwald> nitrix: except they tell you the same thing
15:00:40 <Zekka> I can't remember who, Cale maybe?
15:00:43 <nitrix> Okay, continue on your tangeant. I'll re-ask my original question later.
15:00:56 <maerwald> be realistic
15:01:08 <EvanR> Zekka: and the overhead of writing all the glue to talk between two processes...
15:01:21 <geekosaur> that was cale iirc, and it was for a game that got cancelled?
15:01:30 <roboguy`> that sounds right, I think
15:01:31 <Zekka> EvanR: I don't really mean two processes, ideally we'd be talking about separate code in the same process
15:01:47 <erisco> you can use Haskell as a host language to do code generation... eDSLs
15:02:06 <roboguy`> that's very true!
15:02:08 <erisco> that is how I would approach it
15:02:20 <Zekka> geekosaur: It got canceled? Bummer
15:02:24 <erisco> but for non-RT games you can get away with straight Haskell easy
15:02:38 <roboguy`> I'm working with several DSLs right now (one of them not really embedded, exactly)
15:03:09 * hackagebot pure-zlib 0.6 - A Haskell-only implementation of zlib / DEFLATE  https://hackage.haskell.org/package/pure-zlib-0.6 (AdamWick)
15:03:39 <erisco> (which is what I'm doing)
15:03:48 <EvanR> i think its intersting that the focus is on absolute highest performance and lowest latency
15:03:52 <geekosaur> don't recall. may have run out of funding
15:04:02 <EvanR> when thats probably not really the bottleneck in a video game project, for the most part
15:04:10 <Zekka> I don't blame guys for doing that in code that's gonna run really really frequently
15:04:12 <erisco> hell yes it is
15:04:13 <EvanR> especially among haskell people
15:04:30 <EvanR> no, not all video games look like call of duty infinite warfare
15:04:31 <Zekka> really high-level world simulation stuff? nearly everyone uses lua for that
15:04:40 <erisco> games are always battling performance issues throughout development
15:04:49 <EvanR> haskell doesnt even get to that point
15:04:54 <grantwu> Have you never ever played a text game
15:04:55 <Zekka> but I wouldn't want to use haskell in code that runs every frame (or, for some engines, more frequently than that)
15:04:57 <grantwu> Or a 2D game
15:04:57 <EvanR> its about architecture and workflow
15:05:07 <roboguy`> There is some pretty fancy DSL research going on right now. There's one team that looks like it can currently transform normal Haskell code into Verilog code for a FPGA (I'm working with something similar, actually)
15:05:10 <erisco> well I already drew the distinction between RT and non-RT
15:05:18 <Zekka> grantwu: yeah, I've actually written games like that in languages that are not performant and it went cool
15:05:19 <erisco> there isn't a focus on either one, they both exist
15:05:33 <EvanR> RT, like the code running on your cars fuel injection microcontrollers?
15:05:36 <Zekka> I'm just saying there's totally a big niche for games which will run into big scary performance problems
15:05:37 <grantwu> Zekka: Right, that was aimed more at erisco 
15:05:40 <nitrix> I apologies for starting this by the way. I'll refrain from giving context in the future.
15:05:56 <Zekka> nitrix: you seem annoyed and I'm sad because I thought you were cool =(
15:05:57 <grantwu> Yeah, big scary performance problems are... big and scary :P
15:06:15 <erisco> just have a gander through Steam Greenlight if you're curious about how pervasive performance issues are
15:06:34 <erisco> I don't understand your criticism EvanR
15:06:38 <EvanR> well i get the feeling all those games are using unity
15:07:01 <EvanR> so they are tweaking performance by moving a slider in a configuration popup
15:07:02 <erisco> it isn't life-threatening RT, but it degrades the product when it fails
15:07:04 <nilof> I'm kind of spooked by the apparent inverse correlation between the mainstream-ness of a language and the quality of its IRC channel
15:07:22 <nitrix> Zekka: It saddens me to see people argue the place of Haskell in a given field. Only time will tell; it takes pioneers to find out and iron out the quirks and the best pratices. We've already come so far in many areas, it'd be weird to create an immaginary barrier there.
15:07:40 <Zekka> fwiw I have a feeling applications for haskell in gamedev will probably get at least a little better in the near future
15:07:43 <nitrix> Besides, you can have a successful game in Java and name it Minecraft, so anything's possible.
15:07:45 <kuribas> Avoid succes at all costs!
15:07:57 <Zekka> it kinda had a popularity spike over the past two or three years iirc? so we're probably going to see more new code emerge
15:08:09 * hackagebot HMarkov 1.0.0.1 - Markov-generated sequences  https://hackage.haskell.org/package/HMarkov-1.0.0.1 (swizzard)
15:08:11 * hackagebot HMarkov 1.0.0.2 - Markov-generated sequences  https://hackage.haskell.org/package/HMarkov-1.0.0.2 (swizzard)
15:08:49 <roboguy`> I think it will be possible at some point. We are already at the point where we have DSLs generating FPGA code and DSLs that generate code that runs on bare metal
15:08:58 <erisco> you have 0.0069s to pump out a frame to my monitor ;)
15:08:59 <maerwald> nitrix: there is an alternative minecraft-like implementation in C++ and the performance is worse
15:09:10 <EvanR> i dont even think that would be necessary to implement call of duty infinite warfare
15:09:50 <EvanR> and if thats true, the role of nice game development workflow comes up, for all games not just ones requiring a room full of GPUs
15:10:34 <monochrom> erisco: I guess you're right. CPUs are maxing out at 4GHz, but players are demanding more and more detailed computations per frame or per second.
15:10:36 <Zekka> with a little luck, maybe games with user-hosted servers will get more popular and someone will write theirs in haskell
15:10:57 <monochrom> like "more real physics" or "more army units"
15:11:17 <Zekka> (because that way the devs don't have to pay the money cost of hosting their slow server software, and users don't have to pay the performance cost of GC and crap)
15:11:20 <erisco> sure, because you can sell bigger
15:11:25 <EvanR> more army units is kind of funny, *thats* been maxed out for the last ~10 years
15:11:38 <EvanR> guess they need to move armies to the gpu
15:11:50 <Rembane> Over nine thousand dudes!
15:12:03 <erisco> you have to balance population with fidelity
15:13:21 <EvanR> lets review what games make more money than any other, casual puzzles (requiring orders of magnitude less hardware and thought), casino/barroom shitty video screen games
15:14:03 <EvanR> steam hides the shameful truth sometimes
15:14:33 <Zekka> although with video slots it seems like there's so little code complexity it almost doesn't matter what you write them in
15:14:39 <Zekka> (R&D? I bet that's killer, though)
15:14:40 <EvanR> indeed
15:15:30 <netheranthem> mostly marketing research?
15:15:32 <nitrix> Dwarf Fortress is probably a good example of deep complexity and minimal graphics.
15:15:53 <EvanR> DF also suffers from performance because of its simulation
15:16:05 <Zekka> yeah, DF simulates very very many frames more than the user sees
15:16:06 <EvanR> but also because they mixed up the simulation with the graphs loop... 
15:16:12 <erisco> you can call many things a "video game" but there is a lot of division in the market
15:16:18 <erisco> can't say I've played a slot machine in my life
15:16:21 <netheranthem> I heard that the person who programmed DF also doesn't optimize to the fullest extent as the project started with them not being an expert.
15:16:31 <Zekka> it's internally very turnbased but the turns are fast enough that it feels like it's moving in realtime
15:16:40 <netheranthem> He mentioned he let someone optimize the graphics but couldn't touch it anymore because of how much it changed
15:16:46 <Zekka> netheranthem: I've read some of the author's code on another project -- it's really not great, although it's not heinous either imho
15:16:57 <netheranthem> That's what I would expect
15:17:19 <EvanR> that is something i really want to investigate, everyone and their dog writes games with a fast loop that does lots of useless checking
15:17:36 <Zekka> he writes very directly, a lot of big if/elif cases, a lot of functions that just handle every possible state for a given thing
15:17:43 <netheranthem> With modern computers DF doesn't seem to cause any issues, I'm just wondering how it would run on a netbook or such
15:17:56 <EvanR> but almost all of it could be sleeping, waiting for a predicted future time, or cancelled and rescheduled due to an interfering event
15:18:01 <erisco> manual inlining... trust nothing!
15:18:02 <mpickering> How do I turn on -Wall with "stack repl" ?
15:18:04 <Zekka> i'm guessing this is actually pretty good style for performance becaues it involves almost no dereffing and very little dynamic dispatch
15:18:19 <Zekka> but above the single-procedure scale it's probably a pain to do refactors on
15:18:19 <kadoban> I've never gotten DF to perform well enough to actually be usable past the uhm, "economy" phase or whatever. It starts to drag by then too much.
15:18:31 <EvanR> Zekka: no.
15:18:34 <MarcelineVQ> mpickering: you can write :set -Wall when it's open
15:18:45 <erisco> perf issues in a text game? you guys must be crazy
15:18:45 <mpickering> But then it won't recompile all the modules?
15:18:51 <Zekka> hm, when's the last time you played it? economy was disabled for the last few iterations
15:18:55 <Zekka> EvanR: re what?
15:19:13 <EvanR> Zekka: definitely in the case of DF and minecraft, so much performance would be saved by not continuoually "decrementing a counter and checking if its zero 1000 times a second"
15:19:22 <EvanR> its just not culturally a thing to try
15:19:24 <Zekka> oh, I actually don't know how DF does this
15:19:30 <Zekka> I was talking about Liberal Crime Squad
15:19:45 <kuribas> DF doesn't look very heave on graphics...
15:19:50 <kuribas> heavy
15:20:03 <Zekka> that's a truly turn-based game and it's generally only handling behaviors for one game state at a time. (e.g. it's not going to be making millions of micro-updates to the political sim while you walk around the fortress of evil)
15:20:20 <erisco> it isn't just graphics that are the issue. Just because it is text or 2D or whatever doesn't mean it is free of performance problems. You still have the CPU!
15:20:32 <EvanR> if its completely turn based, including the animation, thats another story and you have your toolkits paradigm
15:20:36 <Zekka> most of the data is stored afaik contiguously in giant global array-lists. (it stops the world periodically to reallocate them, not that you would notice)
15:20:36 <erisco> ever play Falling Sand? trivial game but can tank your CPU in a heartbeat
15:20:38 <Zekka> it has no animation
15:20:38 <MarcelineVQ> mpickering: it won't, does stack repl --ghc-options="-Wall" do what you're after? I don't have a project to test on
15:20:54 <Zekka> it's an ncurses game that runs until it blocks for user input, then runs some more
15:20:56 <mpickering> No, that's what I tried first
15:21:54 <MarcelineVQ> not sure then, I've only used -Wall by module
15:22:16 <kuribas> Couldn't you use haskell for the non-realtime bits, like AI in a turnbased game?
15:22:33 <Zekka> Yeah, I suggested it earlier, and there are a lot of games that already use a slow language (that's not Haskell) for those bits
15:22:37 <erisco> that's what they're using LUA for
15:22:44 <netheranthem> checking a few counters at every turn doesn't feel like it would be a problem
15:22:50 <erisco> high level stuff they want to tweak quickly
15:22:54 <netheranthem> now if there are very many, that would be a problem
15:23:08 <EvanR> ghc can do DSP in real time without drop outs
15:23:14 <EvanR> im not scared
15:23:48 <Zekka> df has a lot of features that relate to things that happen every step and *feel* quadratic, if you were to implement them naively
15:23:56 <Zekka> knowing the author's style, they are actually quadratic
15:24:08 <EvanR> if the code runs 1.5x slower than C and 1.1x faster than C on a good day...
15:24:10 <Zekka> (e.g.: does a dwarf fall in love with another dwarf? well, for each dwarf -- for every other dwarf -- are we compatible? and so on)
15:24:27 <erisco> first step to performance is to fix your algorithms
15:24:50 <EvanR> first step to optimization identify the bottleneck 
15:25:12 <Zekka> there are things that are naively linear, but over far larger datasets, like water physics
15:25:24 <Zekka> we know that you can make disastrous things happen to df's performance by doing bad stuff with items
15:25:29 <kuribas> EvanR: I try to avoid quadratic always.
15:25:29 <erisco> except you don't always have a glaring bottleneck
15:25:36 <MarcelineVQ> to join this amazingly offtopic topic, df's main lack is that nothing is offloaded, the vast majority of work it does is for things that don't affect you immediately so they can be done by othe threads
15:25:39 <Zekka> and we know that dwarf item selection can create an apparent performance problem
15:25:42 <erisco> where there is this one thing you can fix and suddenly all the problems go away
15:25:48 <erisco> it is more like there are dozens or hundreds of things wrong
15:25:58 <erisco> requiring substantial reworking of how you do... everything
15:26:08 <monochrom> consider Chess :)
15:26:39 <EvanR> yes chess is a tough program to make high performance
15:26:40 <roboguy`> maybe df should use GPGPU =)
15:27:01 <EvanR> i need AI needs to have at least 3000 FPS
15:27:01 <Zekka> a ton of df is about manipulating giant matrices, maybe someday for a laugh they'll try it
15:27:11 <erisco> DF should use real dwarves
15:27:18 <Zekka> df is *relentless* about updating ai every gameworld tick iirc
15:27:24 <roboguy`> Zekka: never played it, but that would be kind of interesting
15:27:59 <monochrom> Chess and Go took IBM and Google supercomputers to play on par with us, and graphics was not the bottleneck; hell, they actually had no GUI, and even their text UIs were cryptic.
15:28:07 <roboguy`> almost a full circle thing: GPUs originally made for graphics (particularly games), GPGPU being developed for scientific applications and things that use a lot of data parallelism, back to games but this time not for the graphics!
15:28:17 <EvanR> Zekka: another situation where my criticism holds, AI plans to do something based on the facts, then it sleeps until the facts have changed or they reach the end of their plan
15:28:35 <EvanR> instead of continually reevaluating everything all the time
15:29:02 <Zekka> EvanR: you don't need me ot tell you this but that's imho a hard model to implement in languages like C++ where it's hard to represent a plan
15:29:08 <erisco> every second evaluate all the things, sleep otherwise
15:29:17 <monochrom> To be sure, Chess and Go are an extreme, but you start to see how strategy games are at a hard place where both graphics and "I have to compute 200 soldiers" become twice the problem.
15:29:27 <EvanR> Zekka: im not sure thats true, esp C++ is keen on putting in programmable read/write barriers
15:29:37 <erisco> there is cost to tracking what has (or has not) changed
15:29:49 <erisco> potentially better to just wait until many things have likely changed
15:29:58 <kuribas> monochrom: I like to play "Age of Wonders", the graphics look very nice, but the AI is really dumb.
15:30:41 <EvanR> erisco: if you sleep for 0.456 seconds, vs definitely reevaluating your entire "currently swapped in design pattern object" every 0.001 seconds...
15:30:46 <Zekka> EvanR: hm, I was actually thinking about how e.g. subscribing to a change of the facts requires introducing a ton of new representations, and those representations are likely to be slightly different depending on what thing you're trying to observe
15:30:47 <EvanR> for all objects
15:30:48 <erisco> they should start using machine learning for RTS AIs
15:31:03 <Zekka> also keep in mind that something needs to determine, when a thing gets changed, what subscribers to update
15:31:06 <roboguy`> erisco: Google already is!
15:31:26 <roboguy`> erisco: Google is putting DeepMind to work on StarCraft II
15:31:29 <Zekka> (or you need to do the alternate design you're describing, and recheck the facts every millisecond, but only for the current plan)
15:31:30 <hrqfjj> Could I get some guidance on parsing something like "let (x,y,z) = (1,2,3) in x + y + z)" into something like valueConstructor ["x","y","z"] [Number 1, Number 2, Number 3] Plus (Number 1) (Plus (Number 1) (Number 2))?
15:31:32 <roboguy`> (they just started that recently)
15:31:34 <erisco> oh, good, how is it coming?
15:31:40 <EvanR> Zekka: yeah i developed all this... using a fancy trie. but i bet it would be even faster in C++ with "a dumb vector of things"
15:31:45 <hrqfjj> I am able to parse 1+ 2 + 3 already and x + y + z
15:31:52 <erisco> they've limited the actions it can do per second to something human-like, yes?
15:32:04 <roboguy`> erisco: they just started, don't think there's anything too public yet. I think they are actually releasing a general AI API for SC2 that anyone can use though
15:32:08 <hrqfjj> (note, this is an assignment, looking for guidance)
15:32:15 <roboguy`> erisco: not sure, but I hope so. I've wondered that too...
15:32:22 <erisco> because we already know that superhuman input/response speed breaks the game
15:32:26 <kuribas> EvanR: The trie may scale better.
15:32:37 <roboguy`> if it can micro everything perfectly at all times, that's not a particularly fair test of the systm
15:32:39 <Zekka> yeah, but scaling behavior isn't always the most important thing
15:32:51 <monochrom> hrqfjj: There are several parts. Can you parse "let ... in ..."? Can you parse "(foo, bar, bee)"?
15:32:59 <EvanR> kuribas: but scale ends up not mattering in C++ games alot, because the savings show up at ~ a million things, when your game stops at a thousand
15:33:24 <Zekka> also, iterating over a vector is usually gonna be superduperduper fast compared to iterating over a trie no matter what -- so if you're only updating it once every 10,000 steps, but you're iterating it over it for each one of those steps, then you will possibly get better speed no matter what
15:33:46 <hrqfjj> monochrom, I cannot parse let ... in ... yet, or (foo, bar, bee)
15:33:49 <kuribas> EvanR: as long as no script kiddy is able to crash your computer over a lan game...
15:34:10 <monochrom> So you need to work on those parts. You can work on them separately. Their solutions are easy to combine.
15:34:20 <EvanR> as far as security goes... haskell over C++ please
15:34:21 <erisco> I don't understand why RTS games don't release APIs and have online AI matches... no money in it I guess
15:34:40 <erisco> like, give us a Hearthstone API, that'd be cool
15:34:42 <hrqfjj> monochrom, Got it, thanks. I'll work on that :)
15:34:59 <EvanR> erisco: because the current starcraft AI tournament is 80% AIs that do stuff laughably stupid
15:35:01 <erisco> people have hacked it anyways by intercepting draw calls
15:35:28 <erisco> well I'm not suggesting you televise and make a show out of it :P
15:35:30 <roboguy`> erisco: well, at least they are for SC2 (I think)
15:35:58 <erisco> it is just an obvious platform for developing AI, is all
15:36:18 <roboguy`> it will be interesting... as far as I know, no one has ever made an AI that can beat a good human player at SC2 without cheating
15:36:47 <roboguy`> consistently, at least
15:37:14 <erisco> you don't have discrete search spaces and game states... probably makes it much harder
15:37:57 <EvanR> Zekka: even considering performance as secondary, and implementing this scheme in the dumbest way (reevaluate strategies any time anything changes), i think it could boost workflow and work out for non xbox-scale games
15:38:07 <hrqfjj> monochrom, So the tuple parser should, when executed, return a list of strings according to the above definition, right? (a,b,c) -> ["a","b","c"]
15:38:10 * hackagebot pregame 1.0.0.1 - Prelude for applications  https://hackage.haskell.org/package/pregame-1.0.0.1 (jxv)
15:38:18 <monochrom> yes
15:38:41 <Zekka> EvanR: I don't know what state of the art looks like in commercial games right now. (I knew a guy on the AI team for ReCore but most of his job was fixing horrible race conditions introduced by other devs)
15:39:17 <EvanR> horrible race conditions would be solved by having everything happen simultaneously ;)
15:39:29 <EvanR> a common strategy in FRP
15:39:44 <Zekka> well I think the issue is that everything was happening simultaneously
15:39:53 <EvanR> i doubt it
15:39:54 <Zekka> where "everything" includes "updating data structures"
15:40:08 <Zekka> and updating data structures includes silly nonatomic operations with pointers
15:40:19 <EvanR> yeah so thats NOT simultaneous
15:40:26 <EvanR> the updates got serialized in some way
15:40:37 <EvanR> unpredictably
15:40:57 <Zekka> ok, so you're using a definition of simultaneous that couldn't apply to the literal model on hardware, in which case I get you
15:41:03 <Zekka> you would need a different abstraction
15:41:05 <EvanR> no
15:41:22 <EvanR> it totally works on hardware
15:41:40 <EvanR> because the point is hardware shouldnt be involved in the model
15:41:52 <Zekka> we are using a different version of "on hardware" too, I think
15:41:53 <EvanR> math rocks
15:41:59 <EvanR> o_O
15:42:34 <Zekka> what I mean is that if you start with "we can launch threads that run native code" and you have native code that says "set cell 0x40 to 4" in one thread and "set cell 0x40 to 5", then you don't have an order guarantee but it's not simultaneous
15:42:43 <Zekka> the effect is that you get a value of 4 or a value of 5
15:42:53 <Zekka> afaict you can avoid these situations by limiting what you can do on hardware
15:43:05 <erisco> the amount of real-world time something takes is dependent on the hardware
15:43:12 <Zekka> but if you're allowed to write anything that's technically valid in your instruction set, and also use threads, I don't think you can guarantee the kind of simultaneity you're talking about
15:43:22 <EvanR> i try not to explain how stuff works by appealing to hardware, even pthreads cant be explained by doing that
15:43:35 <EvanR> C almost cant be explained by doing that
15:44:03 <Zekka> yeah, I think you're right -- whether or not you say hardware, his model allows you to ask the computer to do things where the outcome is obviously that they didn't happen simultaneously
15:44:13 <EvanR> eh? this is haskell, why would we be writing arbitrary instructions?
15:44:24 <Zekka> this wasn't haskell, this game was written in C#
15:44:31 <Zekka> I'm still talking about the project my poor friend was saddled with
15:44:46 <EvanR> oh. yeah so its still simultaneous in any way i can see
15:44:51 <EvanR> er, NOT
15:44:59 <Zekka> yeah, I'm on the same page as you about what that means
15:45:13 <Zekka> you've asked it to do two non-atomic data structure updates and the result is that the program did something crazy
15:45:39 <Zekka> it interleaved instructions between those updates, but those instructions weren't simultaneous because you can't simultaneously set a variable to two different values at once in C#
15:45:50 <EvanR> thats one way to make it simultaneous, its an update to two TVars
15:46:02 <EvanR> (that succeeds)
15:46:27 <Zekka> well, wait, being clear, we are talking about e.g. "I have a doubly linked list, and one thread is asking to remove an item from the doubly linked list and one is asking to iterate over it starting form that item"
15:46:43 <loskutak> Hi, would you please recommend some good books/courses/challenges/... for learning haskell? I had some basics in one of our university courses, but don't remember much and would like to learn it.
15:46:44 <Zekka> if you are allowed to have this situation with no extra information, afaik something crazy will happen
15:47:04 <EvanR> that sounds crazy, but its a common strategy for DAW or plugin GUIs
15:47:17 <EvanR> to avoid locking they just directly modify structures
15:47:26 <Zekka> if it chooses to iterate first, then you're using a bad version of hte data -- if it chooses to remove first, then you're going to have problems iterating -- so you need more information about what the program is going to do
15:47:40 <atl`> any "good" first projects for a new haskell user?
15:47:53 <EvanR> when you write to a linked list pointer slot, its "atomic", the iteration will either see the item or not
15:47:58 <Tuplanolla> Any trivial board game, atl`.
15:48:11 * hackagebot HMarkov 1.0.0.3 - Markov-generated sequences  https://hackage.haskell.org/package/HMarkov-1.0.0.3 (swizzard)
15:48:18 <EvanR> Zekka: the trick is, dont consider that removed item bad yet, you have to "wait a while"
15:48:37 <Zekka> ok, but that's more information than was included in the description I gave
15:48:45 <Zekka> and the level of description I gave is basically all the description you can give to C#
15:49:04 <loskutak> Tuplanolla: hmm, might try something like that, thanks.
15:49:50 <Zekka> imho that's information you should include in your program somehow if you've got a race condition, by writing more code or something else
15:50:05 <Tuplanolla> It's an especially fun exercise to generalize board games to higher dimensions, atl` and loskutak.
15:50:22 <Zekka> you could try implementing solitaire
15:50:33 <Zekka> that will get you string manipulation and you will probably be writing some complicated checks with recursive functions
15:50:48 <loskutak> High-dimensional solitaire? :D
15:50:50 <Zekka> you'll also be using algebraic data type sto represent the cards
15:50:59 <Zekka> if you can figure out a way to do solitaire in more dimensions go for it
15:50:59 <EvanR> i found the list monad useful for enumerating a list of valid moves
15:51:50 <EvanR> n-D sudoku?
15:52:11 <Zekka> how does solitaire generalize to n dimensions? you could do it with 2x2x2 boxes using digits 1-8
15:52:38 <Zekka> then you could make it four 2x2x2 boxes tall, four 2x2x2 boxes wide
15:52:45 <Zekka> (and, uh, four 2x2x2 boxes deep)
15:52:51 <Zekka> er, not solitaire, sudoku*
15:52:59 <loskutak> I know nothing about monads, maybe I have to start from the beginning
15:53:02 <EvanR> how about a rubik's cube program
15:53:16 <Zekka> I bet you can do solitaire without monads but I have not done so
15:53:22 <Zekka> (well, you might use IO)
15:53:29 <suzu> *~*~*~*~*MONADS*~*~*~*~
15:53:34 <Rembane> SO CUTE!
15:53:35 <Zekka> i know, monads are terrifying
15:53:46 <suzu> ;.,.,.,.,; MONADS
15:53:47 <Zekka> I really mean I doubt you'd need a lot of parametric types
15:53:55 <Rembane> <3 <3 <3  MONADS  <3 <3 <3
15:54:06 <Rembane> "These monads have been passed on in my family for generations."
15:54:08 <EvanR> you might not need parametric types, but you want them!
15:54:12 <monochrom> Black Friday special monads.
15:54:18 <suzu>   ïÔºõ ‚Ä¢`·¥•‚Ä¢¬¥ î MONADS
15:54:31 <suzu> monads on sale this black friday
15:54:34 <suzu> 50% off
15:54:36 <suzu> get 'em here
15:54:46 <Tuplanolla> That's just nads.
15:54:46 <loskutak> well, could you recommend some introductory materials? I really probably remember exactly nothing from our university haskell :/
15:54:57 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png
15:54:57 <suzu> we got Functor, [], Maybe, Either, and even ((-> r) !
15:55:10 <Zekka> I haven't read the books people currently recommend here -- they like haskellbook, and I liked at least the first few chapters of it
15:55:22 <Zekka> (I haven't yet read the rest)
15:56:03 <loskutak> isn't there some 'interactive' tutorial to haskell?
15:56:14 <EvanR> suzu: all your favorite monads, pay no attention to the phoney isomorphic ones with weird names across the street
15:56:33 <Zekka> yes! https://tryhaskell.org/
15:56:39 <Zekka> i don't remember if it's good but it exists alright
15:59:34 <atl`> should i really shell out $60 for haskellbook
16:00:01 <Zekka> I can't really recommend one way or the other because I haven't read the whole thing
16:00:24 <loskutak> hmm, maybe I am searching for a haskell university course...
16:02:38 <EvanR> this one comes up http://cis.upenn.edu/~cis194/spring13/
16:02:54 <atl`> any examples of someone who has written their own monad for their own application/library?
16:02:55 <glguy> I have a copy of "Programming in Haskell" (2nd Ed) that I like
16:03:04 <atl`> im sure it's somewhat frequent... 
16:03:20 <suzu> i wrote my own monad
16:03:26 <suzu> what do you want to know about monads?
16:03:26 <glguy> http://cis.upenn.edu/~cis194/spring13/ is well regarded
16:03:35 <suzu> i run the monad emporium. we sell monads for cheap
16:03:36 <glguy> and has the exercises and lecture notes available
16:03:44 <EvanR> an application-wide monad is a possible strategy, it would give you global variables and ways to execute side effects wherever and whenever you want
16:03:53 <atl`> suzu: great, well, why? i sort of understand the monads that currently exist
16:04:01 <Tuplanolla> Example of such a monad: Hakyll.
16:04:04 <EvanR> which... doesnt sound great but people do it
16:04:09 <atl`> but i can't think of an application in which someone would write one that doesn't currently exist 
16:04:17 <suzu> oh, writing your own monad from nothing
16:04:19 <suzu> nah never done that
16:04:23 <loskutak> just found that course as well... I think that is the right place where I will start :). Thanks for the help!
16:04:26 <atl`> not because i doubt their usefulness 
16:04:29 <suzu> all the stuff i've needed has been there
16:04:37 <suzu> State, Reader, Writer, IO
16:04:43 <suzu> EithreT
16:04:45 <suzu> ErrorT
16:04:47 <suzu> EitherT*
16:04:51 <atl`> i think uh some sqlite library used uh 
16:04:54 <atl`> wrote* their own monad
16:05:07 <atl`> probably just something on top another
16:05:11 <suzu> yeah but i'll bet that monad was just another monad jenga
16:05:50 <EvanR> essentially new monads dont come up often
16:06:05 <EvanR> but you probably dont want to write your program literally in terms of the StateT operations
16:06:31 <EvanR> we need an article about that...
16:07:13 <aarvar> :w
16:07:17 <aarvar> woops!
16:09:51 <hrqfjj> monochrom, So far trying to parse tuples, I have: parseVarTuple = fmap (map read) $ parseParens $ sepBy1 (many1 $ satisfy isAlpha) (char ',')
16:10:37 <hrqfjj> monochrom, But this isn't working. However, if I change isAlpha to isDigit, it works on numbers
16:10:49 <hrqfjj> ex. readP_to_S parseVarTuple  "(1,2)"
16:12:12 <hrqfjj> I guess the problem is I can't read a :: String, but I can read 1 :: String
16:12:29 <hrqfjj> oh wait
16:13:12 * hackagebot cudd 0.1.0.3 - Bindings to the CUDD binary decision diagrams library  https://hackage.haskell.org/package/cudd-0.1.0.3 (adamwalker)
16:16:25 <hrqfjj> Can anyone offer any guidance here please? I'm working with ReadP and have written the above function, but I want to be able to parse (a,b,c) as ["a","b","c"]
16:17:00 <hrqfjj> Currently, if I change the above isAlpha to isDigit, I can parse "(1,2,3)" as (1,2,3)
16:17:37 <geekosaur> note that read does not read raw Strings
16:17:40 <glguy> hrqfjj: To read on strings parses string literals as strings
16:17:48 <geekosaur> > read "a" :: String
16:17:50 <lambdabot>  "*Exception: Prelude.read: no parse
16:17:55 <glguy> so you'd use it to turn the string  "\"a\"" into "a"
16:18:00 <geekosaur> > read "\"a\"" :: String
16:18:02 <lambdabot>  "a"
16:18:25 <geekosaur> the convention for Show and Read is that they produce and consume something that is Haskell source syntax
16:19:08 <hrqfjj> So I guess what I had written isn't that closely related to what I want, because I want to parse string and return a list of strings
16:20:18 <geekosaur> in the case of numbers, you want to use read to extract the numeric value from the string representation. you don't need to do that for strings with the representation you are using
16:20:41 <geekosaur> they're already what you want; what purpose is `read` supposed to serve?
16:21:58 <hrqfjj> I guess I might not want to use read here. I want to go from "(var1, var2)" to ["var1","var2"], and there's nothing resembling "\"var1\",\"var2\""
16:22:50 <hrqfjj> yep, that was it
16:23:00 <hrqfjj> geekosaur, glguy Thanks :)
16:28:44 <Gurkenglas_> Could you abuse Coercible to use a given isomorphism?
16:30:35 <Gurkenglas> (The function thus defined could specialize to "Iso' s a -> (s -> s) -> (a -> a)", "Iso' s a -> Lens a a s a -> Lens a s s s", etc.)
16:31:18 <roboguy`> Gurkenglas: wouldn't that defeat the purpose of it being zero-cost?
16:32:17 <Gurkenglas> Yup. Not the one of it solving a good chunk of the boilerplate problem though
16:33:00 <roboguy`> ahhh. hmm
16:36:24 <Gurkenglas> (The use that made me think of this would be "Iso' s a -> (a -> a -> a) -> (s -> s -> s)")
16:40:54 <sophiag> if i iterate over an already infinite list then how do i terminate it? calling take on type [[a]] doesn't seem to do anything...
16:42:32 <latro`a> sophiag, can you elaborate a little bit? what did you do, map iterate xs?
16:42:39 <latro`a> er, "map (iterate f) xs"?
16:43:15 <latro`a> where f :: a->a and xs is an infinite [a]?
16:43:34 <sophiag> it's the van Wijngaarden transform, a variation of the Euler transform. so series acceleration
16:43:55 <sophiag> tail . (/2) . ([1,1]*) . scanl (+) 0
16:44:10 <latro`a> oh, iterate like that
16:44:19 <sophiag> oh oops, that's the wrong version
16:44:39 <sophiag> iterate (tail . (/2) . ([1,1]*) . scanl (+) 0
16:44:57 <sophiag> so then i'm trying something like:
16:45:01 <latro`a> what's this multiplication by lists instance?
16:45:25 <latro`a> also your parens don't match
16:45:40 <monochrom> > iterate (tail . (/2) . ([1,1]*) . scanl (+) 0
16:45:41 <sophiag> oh yeah, i fixed that in my code
16:45:42 <lambdabot>  <hint>:1:46: error:
16:45:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:45:44 <sophiag> i know
16:45:59 <latro`a> it's not clear to me how the parens necessarily should be, though
16:46:03 <sophiag> sorry i took out the iterate to make it terminate then pasted in the version with the syntax error
16:46:16 <latro`a> is it "iterate (tail . (/2) . ([1,1]*)) . scanl (+) 0"
16:46:17 <latro`a> ?
16:46:23 <sophiag> iter (tail . (/2) . ([1,1]*)) . scanl (+) 0
16:46:30 <latro`a> ok
16:46:40 <latro`a> what's [1,1]*?
16:46:41 <sophiag> ugh, also on a new keyboard today
16:46:42 <monochrom> iter? iterate?
16:46:58 <Clint> iter8
16:47:02 <monochrom> You should just put real code on lpaste.net and give us the URL
16:47:03 <sophiag> lol yes
16:47:09 <sophiag> one sec
16:47:49 <monochrom> 10 seconds of posting real code can be saved by 5 minutes of keep revising mock code
16:48:20 <sophiag> take 20 $ iterate (tail . (/2) . ([1,1]*)) . scanl (+) 0 $ map (1/) $ [1..]#[0,-1]
16:48:30 <sophiag> ^ there's what i'm trying to do and it's not working
16:48:31 <monochrom> > take 20 $ iterate (tail . (/2) . ([1,1]*)) . scanl (+) 0 $ map (1/) $ [1..]#[0,-1]
16:48:33 <lambdabot>  error:
16:48:33 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[Integer]‚Äô
16:48:33 <lambdabot>                       with ‚ÄòData.Tagged.Tagged [Integer] (Identity [Integer])
16:48:53 <latro`a> you still haven't said what this Num instance for lists is
16:49:08 <monochrom> yeah, what is ([1,1]*) doing there?
16:49:14 <sophiag> (Fractional a, Eq a) => [a] -> [[a]]
16:49:18 <monochrom> or rather, what does it mean?
16:49:36 <monochrom> thanks for the type but that's only half of the story. or only 25%.
16:49:42 <sophiag> true
16:50:20 <monochrom> actually that cannot be the type either.
16:50:25 <monochrom> @type ([1,1]*)
16:50:27 <lambdabot> (Num [t], Num t) => [t] -> [t]
16:50:51 <monochrom> you cannot have both t=a and t=[a] at the same time.
16:52:30 <latro`a> I mean you could have a Num instance for specifically [Int]
16:52:33 <latro`a> or [Double]
16:52:38 <sophiag> ah sorry, that's the type if i factor out the Num
16:52:41 <latro`a> i don't know what it would be, but it could work
16:52:54 <sophiag> otherwise it's (Fractional a, Eq a) => [a] -> [a]
16:53:16 <latro`a> still, what is [1,1]*[1,2], say?
16:53:19 <Tuplanolla> No sense is made around here.
16:53:25 <MarcelineVQ> so what's the complete actual code look like?
16:53:25 <Tuplanolla> @paste
16:53:25 <lambdabot> Haskell pastebin: http://lpaste.net/
16:53:39 <hrqfjj> I guess this is a stupid question, but is there a way to parse a string, checking if the first variable is a letter and the rest alphanumeric?
16:53:43 <hrqfjj> Without using do notation
16:53:55 <hrqfjj> (and then stitching back together)
16:54:08 <Myrl-saki> hrqfjj: context?
16:54:14 <monochrom> I take it you mean s/variable/character/. You need either do-notation or >>=.
16:54:41 <latro`a> hrqfjj, seems like something of the form "f (x:xs) = p x && all q xs" would work, for appropriate p,q
16:54:49 <EvanR> "(x, abc1)" -> Just "(x,abc1)"
16:54:51 <hrqfjj> I currently have parseVar = skipSpaces *> (Var <$> munch1 isAlphaNum) 
16:55:00 <EvanR> "(x, ---)" -> Nothing 
16:55:05 <monochrom> on second thought, I'm wrong. there is an Applicative way using <$> and <*>
16:55:10 <hrqfjj> But I want to enforce that the first char has to satisfy isAlpha
16:55:11 <latro`a> (but maybe I don't understand the exact question.)
16:55:34 <MarLinn> mh, a rather natural way to define Num a => Num [a] could be to see the numbers as factors of a polynomial
16:55:38 <hrqfjj> I guess both need to be applied, with the output of both being kept
16:55:43 <Myrl-saki> hrqfjj: isAlpha >> munch1 isAlphaNum
16:55:48 <monochrom> eh, you're missing an "isAlpha" for the "the 1st character is a letter"
16:55:53 <Myrl-saki> hrqfjj: Or something.
16:56:08 <geekosaur> >> seems wrong if you want to capture the result
16:56:17 <Myrl-saki> geekosaur: Oh true.
16:56:39 <Myrl-saki> Isn't it supposed to be something like
16:56:42 <monochrom> (\c d -> Var (c:d)) <$> satisfy isAlpha <*> munch isAlphaNum
16:56:43 <Myrl-saki> alpha >> many alphaNum?
16:56:45 <Myrl-saki> Or something?
16:56:47 <hrqfjj> Yep. it seems pretty straightforward with do notation, since I can just bind each result
16:56:58 <hrqfjj> Yea, that was what I was hoping, but it didn't seem to work
16:57:06 <Myrl-saki> Err
16:57:09 <kristianpaul> roboguy`: do you have docs about that FPGA work? links
16:57:12 <kristianpaul> ?
16:57:28 <sophiag> ok, sorry about all the errors from jumping between versions. this is what i was talking about: http://lpaste.net/346014
16:57:31 <Myrl-saki> `(:) <$> alpha <*> many alphaNum` I mean.
16:57:46 <roboguy`> kristianpaul: here's a talk about it https://www.youtube.com/watch?v=k02mEtPfdaQ
16:57:56 <monochrom> > (\c d -> Right (c:d)) <$> Just 'a' <*> Just "1b"
16:57:58 <lambdabot>  Just (Right "a1b")
16:57:59 <roboguy`> kristianpaul: which references their paper http://arcade.cs.columbia.edu/hardware-codes15.pdf
16:58:13 <monochrom> should work. your error is elsewhere.
16:59:26 <monochrom> sophiag, that is not complete code. where is # defined? where is the Num instance for lists defined? what library are you importing that you are keeping secret?
17:00:17 <monochrom> If someone take your paste verbatim and load it in ghci, ghci is just going to say "I don't know what you're talking about" left right and centre.
17:00:34 <monochrom> In other words how does an impartial third party reproduce your observation?
17:01:01 <kristianpaul> thanks kind sr !
17:01:21 <EvanR> is there something like a monad but without return
17:01:25 <sophiag> sorry, i totally forgot about those parts in the function definition. i'll add them in now
17:01:26 <hrqfjj> monochrom, Sorry, are you saying parseVar = skipSpaces *> (Var (:) <$> satisfy isAlpha <*> munch1 isAlphaNum)  should work?
17:01:33 <roboguy`> kristianpaul: no problem!
17:01:54 <monochrom> No. I do not expect Var(:) to work. I expect (\c d -> Var (c:d)) to work.
17:02:25 <Tuplanolla> That's `Var .: (:)`, hrqfjj.
17:02:42 <Tuplanolla> Not `Var . (:)` or `Var (:)`.
17:04:00 <sophiag> monochrom: this should do it http://lpaste.net/346014
17:05:13 <hrqfjj> Tuplanolla, Sorry, don't quite follow how .: (:) works?
17:05:29 <Tuplanolla> Don't worry about it, hrqfjj. Just do what monochrom says.
17:06:18 <hrqfjj> Tuplanolla, this? parseVar = skipSpaces *> (Var .: (:) <$> satisfy isAlpha <*> munch1 isAlphaNum)
17:06:39 <monochrom> why do you hate lambda so much?
17:06:53 <Tuplanolla> That's one way to do it, but you need `(.:) = (.) . (.)`, hrqfjj.
17:09:30 <kuribas> :t (.:)
17:09:32 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:09:52 <Gurkenglas> sophiag, I'd make the association order in line 15 explicit
17:10:13 <hrqfjj> And to make the second part optional (so "a" can be parsed as a variable),maybe I can add something like option?
17:10:25 <Gurkenglas> (Not sure whether : or + comes first)
17:10:53 <monochrom> hrqfjj: You have two levels of lists. You have [ inner-infinite-list-0, inner-infinite-list-1, ... ad nauseum ], you know that?
17:11:16 <monochrom> err sorry, not hrqfjj
17:11:30 <monochrom> sophiag: You have two levels of lists. You have [ inner-infinite-list-0, inner-infinite-list-1, ... ad nauseum ], you know that?
17:12:25 <hrqfjj> Ah silly me
17:12:37 <monochrom> So if you merely do a "take 3" on that, you're getting [ inner-infinite-list-0, inner-infinite-list-1, inner-infinite-list-2 ], you agree?
17:12:45 <hrqfjj> Just changed munch1 to munch to avoid failure on no further chars
17:12:54 <hrqfjj> Thanks Tuplanolla and monochrom 
17:13:03 <monochrom> And so if you print that out, you're stuck with only seeing a prefex of inner-infinite-list-0, ever, you realize that?
17:13:11 <sophiag> monochrom: yes, i know that. and i know that's the problem...just not sure how to get the result i want
17:13:49 <monochrom> OK, what you do want printed?
17:13:52 <sophiag> so there's no way to like compose two takes, for example? (i have tried that...)
17:14:04 <sophiag> i'd like the first n values from the list of lists
17:14:18 <monochrom> There is always a way, but first I need to know what you want. Explain like I am not telepathic.
17:14:43 <sophiag> ah ok. well just calling take on it doesn't make it terminate for the reason you obviously understand
17:14:45 <danilo2> Hello guys! Does something like `data Lst (ls :: [*]) where El :: e -> Lst ls -> Lst (e ': ls); Null :: Lst '[]` be optimized in such way that it will have no runtime overhead? It could be optimized just like a tuple, but gives a little greater type management flexibility
17:15:01 <danilo2> In fact it is just another implementation of tuple, that we can just "walk" on type level
17:15:04 <kuribas> > take 5 $ concat [[1, 2, 3], [4, 5], [6..]]
17:15:06 <lambdabot>  [1,2,3,4,5]
17:15:15 <monochrom> How many items from inner-infinite-list-0 do you want? How many items from inner-infinite-list-1 do you want? When do I stop?
17:15:39 <sophiag> Gurkenglas: isn't your question answered just by operator precedence?
17:16:40 <Gurkenglas> Right but one shouldnt have to look up operator predecences for operators that ordinarily cannot associate to read your code
17:16:43 <sophiag> monochrom: well, i suppose if i could write a function to pull values from them like a square that would be nice to start
17:17:05 <monochrom> OK, I'll give you a 20x20 square
17:17:17 <monochrom> take 20 (map (take 20)) your-thing
17:17:18 <Gurkenglas> sophiag, does your line at least output "[0," before hanging?
17:17:23 <monochrom> no
17:17:28 <monochrom> take 20 (map (take 20) your-thing)
17:17:31 <sophiag> it outputs an infinite list that never terminates
17:17:49 <Gurkenglas> What is the output, and what should it be?
17:17:56 <sophiag> it does converge quickly to the correct value...the point was to accelerate the convergence while maintaining correctness
17:18:09 <sophiag> an infinite series approaching ln2
17:18:51 <Gurkenglas> Can you paste the output you have and the one you'd like to have? We might be able to give you what you would need to put to the right of "print" to get you what you wanted
17:19:25 <sophiag> i think monochrom gets it
17:19:50 <sophiag> or look at this: https://en.wikipedia.org/wiki/Van_Wijngaarden_transformation
17:20:08 <sophiag> much prettier than if i dumped a huge list of doubles on you
17:21:54 <Gurkenglas> From what I understood your mathematical parts were working and you were having trouble with the plumbing at the end, so looking at the dump would help more than at the algorithm. Nvm ofc if monochroms suggestion works
17:22:57 <sophiag> well the point is the dump is an infinite list
17:23:15 <sophiag> you don't want me to paste in the contents before i ctrl-c it :p
17:23:18 <Keke> Hey babes
17:23:20 <Keke> I am a bot
17:23:23 <Keke> looking for a fuck buddy
17:23:26 <Keke> Anybody else?
17:23:50 <Tuplanolla> "This table results from the J formula" that is totally great.
17:23:57 <Keke> People are so edgy on IRC (;
17:24:04 <Tuplanolla> I've written some J, but I feel lost every time.
17:24:15 <Keke> Lmao this channel shows the ip when people join?
17:24:23 <Keke> Thats kinda gay
17:28:09 <Myrl-saki> Tuplanolla: just lost? you're lucky. some people stopped programming after using it.
17:35:42 <sophiag> Tuplanolla: i didn't even notice that part!
17:36:28 <EvanR> best representation for a type of real numbers ever, "complete binary tree". data CBT = Node CBT CBT
17:36:38 <danilo2> Hello guys! Does something like `data Lst (ls :: [*]) where El :: e -> Lst ls -> Lst (e ': ls); Null :: Lst '[]` be optimized in such way that it will have no runtime overhead? It could be optimized just like a tuple, but gives a little greater type management flexibility
17:36:54 <danilo2> In fact it is just another implementation of tuple, that we can just "walk" on type level, so theoretically it could be optimized away
18:03:42 <lpaste> haskneyed pasted ‚ÄúDerive generic conversion functions from persistent entities to user-defined types.‚Äù at http://lpaste.net/346029
18:04:44 <haskneyed> Anyone knowledgeable about GHC.Generics around?
18:06:33 <haskneyed> Say you have a user-defined type: `data Person = Person { personId :: Int64, personName :: String}`.
18:07:11 <haskneyed> And a persistent mapping with matching field names: `Person name String`.
18:08:37 <haskneyed> You can derive a Generic instance for the persistent entity. Therefore, you can take the `Rep Persistent.Person` and read the values from the source into the target and apply `to` to get Persistent.Person.
18:09:21 <michbad> What version of Stack should I install on Ubuntu 16.10?
18:10:21 <roboguy`> michbad: I doubt the Ubuntu version will have an impact on that... I'd go for the latest
18:10:47 <roboguy`> unless maybe Ubuntu is still super behind on their GHC version and the latest Stack requires a new one
18:11:03 <geekosaur> even then you let stack install its own ghc
18:11:08 <roboguy`> (in which case I'd suggest upgrading GHC and then getting the latest version of stack)
18:11:09 <michbad> robobguy: They give one-liners for different versions, up to 15.10... It would be easier to use that, but I don't know.
18:11:12 <roboguy`> oh yeah, good point
18:11:49 <michbad> Hmm... so I've tried installing from the 15.10 instructions, but I was getting linker errors when trying to run 'stack setup'
18:11:52 <geekosaur> that said 16.10 does have an issue with building ghc, so possibly you want to just hold off for ghc 8.0.2 (or see if stack will install 8.0.2rc1)
18:12:37 <geekosaur> there's some hackery needed to ghc and Cabal to make older versions work around 16.10's position independent executables default
18:12:41 <roboguy`> geekosaur: speaking of 8.0.2, do you happen to know if there's an estimated release date for it? I know the rc just came out
18:12:50 <geekosaur> (I think 8.0.2 fixes it correctly)
18:12:56 <geekosaur> no, I don't
18:13:32 <roboguy`> that reminds me, I might have found a bug a while back (a possible regression) that I never got around to reporting... I should probably look into that again...
18:20:21 <hrqfjj> I currently have a parser that parses a tuple such as "(var1, var2, var3)" to a list of strings ["var1","var2","var3"]
18:20:33 <hrqfjj> parseVarTuple = parseParens $ sepBy1 (many1 $ satisfy isAlphaNum) (char ',')
18:20:46 <hrqfjj> I want to add the ability to skip spaces
18:20:59 <hrqfjj> Sorry, it can't parse ":(var1, var2, var3)"
18:21:06 <hrqfjj> it can only parse "(var1,var2,var3)"
18:21:38 <hrqfjj> what should i look to change?
18:21:58 <hrqfjj> (using readP)
18:23:18 <EvanR> put a whitespace parser after the , parser
18:23:25 <EvanR> optional (many1 space)
18:23:43 <hrqfjj> EvanR, when you say after, what would that look like
18:23:55 <EvanR> char ',' >> that
18:25:54 <hrqfjj> EvanR, Hmm, I'm getting a type error. this is what I have exactly: parseNumTuple = fmap (map read) $ parseParens $ sepBy1 (many1 $ satisfy isMathChar) ((char ',') >> optional (many1 ' ')) 
18:27:24 <EvanR> many1 space
18:27:46 <EvanR> many1 takes a parser, not a character
18:28:41 <hrqfjj> EvanR, skipSpaces?
18:29:01 <hrqfjj> EvanR, sorry, i now see that in the error message
18:29:08 <EvanR> alternatively, you could read the type error message
18:30:40 <hrqfjj> So no type error but still failing to parse the examples with spaces (ex. "(abc ,def ,xyz)" doesn't parse)
18:32:09 <geekosaur> you showed commas afterm so that was the parser you were given
18:32:17 <geekosaur> *after
18:32:26 <geekosaur> er, spaces after commas
18:33:15 <hrqfjj> geekosaur, Sorry, what do you mean? It's not parsing with spaces before or after
18:33:28 <hrqfjj> geekosaur, (any spaces at all leads to failed parse)
18:39:35 <hrqfjj> I've also tried using <*, but not sure if that's the right direction
18:52:36 <hrqfjj> geekosaur, EvanR Sorry, not sure if either of you are still around. Did I miss anything in what you said?
18:54:35 <geekosaur> hrqfjj, it would be nice if you learned enough about what you are working with to be able to recognize that when you asked for `such as "(var1, var2, var3)"` and were given exactly that, you could recognize that it wasn't actully what you really wanted and ask for what you actually wanted
18:56:07 <hrqfjj> geekosaur, Ok, so maybe you're misunderstood. I said that it's not working if ANY spaces. What I asked for, which is what you said, includes spaces. Not seeing how I asked for something then didn't realize it was wrong? What was given typechecks but fails to fails when there are ANY spaces
18:56:19 <hrqfjj> misunderstanding*
18:56:57 <geekosaur> Im not even looking at that yet, yes I un derstand that is more important to you than that you asked for the wrong thing but now I am not sure if I am supposed to fix both problems at once or ???
18:57:24 <hrqfjj> Where did I ask for the wrong thing? I'm not following
18:57:36 <geekosaur> such as "(var1, var2, var3)"
18:57:55 <hrqfjj> Yes? That's one example of what I'm looking to parse
18:57:57 <geekosaur> examples with spaces (ex. "(abc ,def ,xyz)"
18:58:02 <hrqfjj> Sorry, I might be wrong here
18:58:05 <hrqfjj> Yes, they are both examples
18:58:26 <hrqfjj> neither parses from what I took away
18:58:52 <geekosaur> nice, one exanmple from which we are to infer both, when you had two chances and showed the same thing in both --- and that style is common in both normal writing and many data formats, so assuming that means spaces after instead of spaces anywhere is normal
18:59:24 <geekosaur> never mind, I don't think I have the patience this evening
19:00:08 <hrqfjj> Ok, I'm sorry you are getting upset but if you reread what I posted, I actually included both over two messages. Sorry for the confusion, I'm just trying to learn how to use the parser
19:00:26 <hrqfjj> I recognize that I should have communicated it more clearly
19:00:27 <geekosaur> no, actually the second one was from only afterward when you came back
19:00:37 <hrqfjj> I agree, I'm sorry
19:00:42 <geekosaur> not before you were given a solution to the example you asked for
19:01:44 <geekosaur> meanwhile I do not have all the pieces of your problem
19:02:16 <geekosaur> and I have to go back several hours to find the rest, I see
19:02:19 <hrqfjj> Is there anything I can clarify?
19:05:24 <hrqfjj> geekosaur, The best way of putting it I think is that I want to be able to parse a tuple, ignoring all spaces in the input. What I currently have is parseNumTuple = fmap (map read) $ parseParens $ sepBy1 (many1 $ satisfy isMathChar) ((char ',') >> optional many1 skipSpaces)
19:05:36 <sophiag> ok, i didn't realize @monochrom had already answered my question before and now i have a real noob syntax follow-up q
19:05:52 <sophiag> takeArray n f = take n $ map (take n) f
19:06:53 <sophiag> i'm wondering about simplifying the syntax for that function? can't i remove one of the variables explicitly and avoid the parentheses as well if i wanted to (not saying this is the best for legibility, just learning)?
19:08:18 * hackagebot pregame 1.0.1.0 - Prelude for applications  https://hackage.haskell.org/package/pregame-1.0.1.0 (jxv)
19:08:26 <exio4> takeArray n = take n . map (take n) is what I would call nicer`
19:08:55 <sophiag> yes, that looks good :)
19:11:39 <sophiag> exio4: i thought i could remove n as well, but doesn't seem to be working. might be a typing issue? takeArray :: Int -> [[a]] -> [[a]]
19:12:26 <exio4> sophiag: quite more annoying :)
19:12:47 <exio4> @pl takeArray n = take n . map (take n)
19:12:47 <lambdabot> takeArray = liftM2 (.) take (map . take)
19:13:01 <sophiag> ah i see
19:13:08 <sophiag> o
19:13:34 <sophiag> oops...i'll stick with n ;)
19:15:17 <hrqfjj> If anyone can help me learn how to use the ReadP parser, I'd greatly appreciate it. Here's where I'm at:
19:15:27 <hrqfjj> The best way of putting it I think is that I want to be able to parse a tuple, ignoring all spaces in the input. What I currently have is parseNumTuple = fmap (map read) $ parseParens $ sepBy1 (many1 $ satisfy isMathChar) ((char ',') >> optional many1 skipSpaces)
19:18:28 <alx741> I'm trying to make a custom data type Matrix (a String matrix will come in handy for trying it out) would the package 'matrix' help me here? or is it just for numbers?
19:20:49 <hrqfjj> Or more generally, how is the parser "option" from ReadP used?
19:35:05 <hrqfjj> Ok, so I've figured out how to use optional, (I ended up with (char ',') *> optional skipSpaces), but I'm only able to skip spaces surrounding the last term in the tuple
19:35:29 <hrqfjj> So what I have now is this: parseNumTuple = fmap (map read) $ parseParens $ sepBy1 (many1 $ satisfy isMathChar) ((char ',') *> (optional skipSpaces))
19:40:16 <hrqfjj> Actually, I guess the optional is unnecessary here. The problem I'm trying to resolve remains that I can't parse spaces surrounding any term in a tuple except the last one (ex. can parse (1,2, 3 ), but not "(1, 2, 3)")
19:40:49 <dkk> hello all
19:41:24 * JSharp waves
19:42:40 <dkk> hi i am new to haskell and given a project in my CS course to develop  text editor .... can some one suggest some thing to me.... please
19:43:16 <orion> dkk: What are the parameters of the assignment?
19:43:24 <Cale> dkk: You're writing a complete text editor in Haskell?
19:43:56 <roboguy`> Cale: I've seen one course where you write an ed style text editor, which doesn't seem *too* unreasonable
19:44:37 <dkk> orion : i have planned to write a toy editor with some of the features from vi and i have very less time like 10 days ....it could be cui or gui
19:45:05 <dkk> cale : yes i preffer haskell because otherwise i only know C language
19:46:05 <dkk> cale : and i also wan't to exel in haskell as much as possible so i am with haskell and ready to learn any of the new technique
19:46:23 <systemfault> dkk: Do you already know haskell?
19:46:37 <systemfault> If not, you're going to fail.
19:47:19 <dkk> systemfault : hmm yes little bit i have done one sem in haskell and feel nice to code in haskell
19:47:23 <roboguy`> writing a vi style editor in Haskell in 10 days is a bit of a steep challenge
19:47:38 <roboguy`> depending on your level of knowledge of the related things, I suppose
19:48:20 * hackagebot foscam-directory 0.0.8 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.8 (TonyMorris)
19:48:33 <roboguy`> I looked into making a simple text editor like that with Haskell a while ago, but I never did quite figure out how the CUI libraries that I found would work for that
19:49:02 <dkk> roboguy : i have not to implement all feautres but a little things ...toyyisg things lik find - replace -- autofill support -- syntax highlighting -- spell cheking ..etc 
19:50:08 <dkk> roboguy : i have gone through with the new brick library ... it seemed me almost ok for the job..
19:51:20 <roboguy`> dkk: huh, I haven't seen that one
19:52:14 <dkk> roboguy : ohh... they have provided some nice abstractions for modeling in an event based style 
19:52:30 <roboguy`> dkk: ahh, that could be nice
19:53:19 <dkk> but i am thinking whether i should go for complete frp or stick with brick ...considering time limits 
19:55:12 <dkk> would someone wants to suggest me something please !!
19:55:43 <Cale> A couple of us at Obsidian Systems were thinking about making a Reflex interface to brick, but just doing that much would easily eat up a lot of your time.
19:58:01 <dkk> cale : acually currently i don't know a shit about frp ... but I am interested to do some nontrivial work in haskell to get a job after my school gets over ...what would you prefer
19:58:20 * hackagebot foscam-sort 0.0.3 - Foscam File format  https://hackage.haskell.org/package/foscam-sort-0.0.3 (TonyMorris)
19:58:59 <ertes> i think ten days for a simple editor is realistic, even for a beginner, if you don't follow the many distractions that throw themselves at you
19:59:14 <Cale> dkk: Yeah, if you haven't used an FRP library before, I wouldn't typically recommend trying to implement a binding for one -- especially with limited time
19:59:43 <ertes> FRP is one of those distractions‚Ä¶  you should learn it, but not in those ten days =)
19:59:50 <dkk> cale : also if i don't complete in that time interval then i will not fail but i want to do robust work for showcasing in future when i will apply for a job in FP 
20:00:16 <Cale> But definitely, yeah, it would be really nice to go back and try it again using FRP when you have more time
20:01:00 <Cale> Certainly, experience with Reflex looks good if you were applying for a job at the company I work for ;)
20:01:18 <hrqfjj> Is there a blank character in haskell by any chance?
20:01:36 <ertes> hrqfjj: you mean like ' '?
20:01:51 <hrqfjj> ertes, Yes, I'm not sure that works though. But my mistake might be elsewhere
20:01:58 <Cale> hrqfjj: What do you mean by blank?
20:02:00 <ertes> > ' '
20:02:02 <lambdabot>  ' '
20:02:07 <ertes> > fromEnum ' '
20:02:09 <lambdabot>  32
20:02:28 <Cale> hrqfjj: Haskell's Char type is basically unicode code points
20:02:52 <hrqfjj> So I'm working with a parser, and if there is no paren and my paren parser fails, I want to just return a "blank"
20:03:14 <Cale> hrqfjj: I think you'd want the paren parser to fail, wouldn't you?
20:03:25 <Cale> Er...
20:03:34 <hrqfjj> Well, if there's no parenthesis, I need it to succeed and keep going. But if there is, I need it to behave differently
20:03:40 <hrqfjj> I thought this was an application of optional
20:03:41 <ertes> hrqfjj: how does this "blank" fit in your resulting AST?
20:03:43 <hrqfjj> (I'm using readP)
20:04:10 <ertes> hrqfjj: in other words: what do you mean by "blank"?  "no information"?  "yet to be defined"?  ‚Ä¶?
20:04:14 <Cale> okay, so you either parse a "(" and return one thing, or you simply return a different thing?
20:04:28 <hrqfjj> Yes, more of less. It might be more clear with this example: parseMaybeParens = between (skipSpaces *> (option '' (char '(')) (skipSpaces *> (option '' (char ')')))
20:04:44 <hrqfjj> (non functional, but perhaps shows what i'm trying to get working)
20:04:52 <hrqfjj> the problem with optional is that it has type ReadP ()
20:05:01 <hrqfjj> so if it parses a parens, it just throws it out
20:05:07 <dkk> cale : i am doing this project with keeping in mind that i have to apply for FP otherwise i may have not taken it and also some extra time may be provided to me if I show my work in progress... so what do you say about it ~~Q
20:05:10 <Cale> would you mind parsing a string instead?
20:05:14 <Cale> There is an empty string
20:05:14 <hrqfjj> but I want it to be consumed and added to my parsed part
20:05:58 <hrqfjj> Cale, hmmm, I'm not 100% sure I understand what you're aiming at but I'll try it
20:06:10 <Cale> dkk: I mean, it's up to you what you want to explore, but learning FRP in 10 days could be bit much.
20:06:33 <Cale> dkk: Especially learning it to the point where you can implement a binding to a new library, rather than using something that someone else made already
20:06:44 <hrqfjj> Cale, Basically, I want to add a parens to the parsed part if there's one there, but proceed without jeopardizing the rest of my parse if there isn't one there
20:06:59 <Cale> If I'd already written a reflex-brick library for you to use or something, I wouldn't be as hesitant to recommend trying that :)
20:07:21 <Cale> hrqfjj: Try string "(" and option ""
20:07:57 <ertes> (and reflex, except for the user-facing FRP part, isn't exactly the best documented library‚Ä¶  it's simple, if you understand enough haskell to understand the types, but otherwise it's a challenge)
20:08:24 <hrqfjj> Cale, Sorry, what would that look like?
20:09:30 <Cale> between (skipSpaces *> (option "" (string "("))) (skipSpaces *> (option "" (string ")"))) :: ReadP a -> ReadP a
20:09:49 <Cale> However, I don't think this is actually what you likely want
20:10:10 <Cale> Probably you'd want to require ")" if you got a "(" and not otherwise
20:11:15 <hrqfjj> Cale, Yes, and I need to make sure the '(' and ')' are not thrown out
20:11:25 <haskell290> cale : sorry my connection has been lost 
20:11:37 <Cale> hrqfjj: Well, that's not what I'm complaining about
20:12:05 <Cale> hrqfjj: I mean, what about something like "(foo" or "foo)" where foo is something that your inner parser matches
20:12:21 <Cale> Sure the paren won't be thrown out, but do you really want to match that?
20:12:32 <hrqfjj> Cale, It wouldn't match because of the between, right?
20:12:54 <dfeuer> hrqfjj, you may want to look at the `paren` function.
20:12:56 <Cale> it would, because the parsers you're passing to between optionally match parens
20:13:23 <hrqfjj> Cale, Oh right, we rewrote them
20:13:34 <haskell290> ok is there someone who have used brick library ~~Q 
20:13:59 <Cale> So you really just want something like  between (char '(') (char ')') p <|> p
20:14:13 <hrqfjj> yep, that looks to be better
20:14:17 <dfeuer> Cale, do you think you'll have some time to help me out Sunday?
20:14:26 <Cale> dfeuer: sure
20:14:33 <Cale> dfeuer: What do you need help with?
20:14:59 <Cale> More learning to write web applications? Map stuff? :)
20:15:08 <dfeuer> Cale, just dealing with my silly Minesweeper thing. I've got a lot of pieces, but I'm not sure of the right way to put them together Reflex-style.
20:15:19 <Cale> ah, cool
20:15:20 <dfeuer> Some of my pieces are very much overdesigned
20:15:41 <dfeuer> I decided to use reflection to express vector sizes, for instance... :P
20:15:52 <Cale> hahaha
20:16:15 <dfeuer> Which is kind of cool, because some bounds just get inferred automagically.
20:16:23 <dfeuer> But it really wasn't necessary.
20:16:49 <dfeuer> Like I can't really mix up row and column numbers because they won't typecheck...
20:16:58 <Cale> nice
20:17:04 <ertes> honestly i think Data.Reflection should be in base
20:17:15 <dfeuer> ertes, I almost agree, but it should be in ghc-prim.
20:17:23 <ertes> true
20:17:34 <dfeuer> And there's a spot where it could really benefit from some special treatment from GHC.
20:17:48 <dkk> cale : sorry i have lost my internet  connection
20:17:49 <hrqfjj> Cale, So I get that idea in theory, but I'm not sure what the 'p' is. Basically, if it's not the first case, I don't want to do any parsing, right?
20:17:52 <dfeuer> (to get reflected stuff to inline safely)
20:18:31 <Cale> hrqfjj: p is the parser for whatever goes between the parens
20:18:48 <dfeuer> Cale, hrqfjj, really look at the paren combinator.
20:18:53 <dfeuer> In Text.Read.
20:18:59 <Cale> (or whatever you'll be parsing without parens)
20:19:05 <dfeuer> Or Text.ParserCombinators.ReadPrec, or wherever.
20:19:09 <Cale> I'm assuming you want to parse the same stuff in both cases
20:19:17 <hrqfjj> Cale, Yep, that's true
20:19:18 <dfeuer> or Text.ParserCombinators.ReadP, I mean.
20:19:37 <hrqfjj> dfeuer, There's a paren combinator in ReadP?
20:19:39 <dfeuer> Now with considerably less efficiency stupidity. :-)
20:19:43 <dfeuer> Yes.
20:19:50 <ertes> as far as i'm concerned feel free to add reflection to haskell prime and dump Data.Reflection into Prelude =)
20:20:04 <dfeuer> Hahahahahaha.
20:20:33 <Cale> lol, that seems a bit much
20:20:35 <dkk> is there someone to help or suggest something to develop a toy text-editor in haskell with keeping vi as intuition in mind 
20:20:58 <ertes> Cale: right, you can leave Given out
20:21:16 <hrqfjj> Cale, So I run the paren parser, and then I apply other parsers to it. The function itself doesn't apply another parser. So there is no p, right?
20:21:33 <Cale> dkk: Well, you already found brick -- it looks interesting. I haven't tried it myself yet, but I recall it looked decent.
20:22:41 <dkk> cale : but i have not yet started and whether that would be ok for my job ....or something else is more fine 
20:22:52 <hrqfjj> dfeuer, Also, not seeing the parens parser. Perhaps you're mistaken?
20:23:03 <hrqfjj> dfeuer, To confirm, I'm looking in ReadP
20:24:34 <hrqfjj> oh, maybe I can make the entire between optional?
20:24:40 <hrqfjj> I'll try that
20:25:12 <hrqfjj> Oh, but it'll return nothing then
20:27:24 <dkk> cale : actually i am wondering that in brick also i have to model whole thing from the scratch so if i have modeled editor as in Frp and do work for it would that would be more paying off for my future concerns ~~Q or i should go with brick itself
20:27:58 <Cale> dkk: The thing is, you'll end up wanting to build some sort of binding between brick and whatever FRP library you use
20:28:10 <Cale> and that in itself could eat up a good chunk of your time
20:28:38 <Cale> I don't know if there's an FRP library which has a good binding to something along the lines of brick or hscurses or something
20:28:54 <hrqfjj> Is there some way I can make the entire "between" conditional?
20:29:03 <Cale> hrqfjj: That's... what I did
20:29:05 <ertes> brick itself kinda resists easy binding
20:29:05 <dkk> cale : is it necessary to use brick if i go for frp ~~Q .... as i have not started with brick also ... 
20:29:27 <Cale> dkk: Well, you'd want *some* library which deals with controlling the terminal
20:29:28 <hrqfjj> Cale, but didn't you're require access to the parser that'll be run next?
20:29:37 <hrqfjj> Cale, Sorry if I'm misunderstanding
20:29:51 <Cale> hrqfjj: yes, well, you can abstract it with lambda
20:30:03 <Cale> (\p -> between (char '(') (char ')') p <|> p)
20:30:13 <dkk> cale : yes i would but i could also go for GUI 
20:30:44 <dkk> ertes : have you used brick ~~Q
20:30:58 <Cale> dkk: Sure -- it would be easy to do a simple plain text editor if you get to use an existing text input widget :)
20:32:00 <ertes> dkk: i myself tried to do a reflex/brick bridge‚Ä¶  brick itself tries to be functional (without being FRP), so it wants you to follow a very specific structure of control
20:33:31 <dfeuer> hrqfjj, let me check.
20:33:42 <ertes> dkk: honestly i'd say: just use brick and consider FRP later
20:33:56 <ertes> dkk: you won't have time to learn haskell, brick, text editors *and* FRP
20:33:58 <hrqfjj> Cale, Thank you so much for the help. Sorry for the pedantic questions :P
20:34:26 <ertes> dkk: in particular don't underestimate the engineering challenge that is writing an editor
20:34:34 <dfeuer> hrqfjj, found it.
20:35:03 <dkk_> cale : sorry again i have lost my connection :)
20:35:10 <ertes> dkk_: http://ircbrowse.net/day/haskell/today/recent
20:35:12 <dfeuer> hrqfjj, I was talking about an internal function, but the functionality is available in Text.Read.readParen
20:36:21 <dkk_> ertes : thanks 
20:38:00 <dkk_> ertes : so now i start to model y editor according to brick only ....
20:39:08 <dkk_> ertes : but after going to lot of nice documentation of brick i have not get much as i should ... so i need someone who have actually used brick 
20:39:45 <ertes> dkk_: if you weren't learning so many things at the same time, i'd say go for FRP, but really 10 days is just too short‚Ä¶  even getting an editor done could be challenging
20:40:40 <dkk_> ertes : yes but i could exceed my time limit may be upto 1 month
20:42:03 <ertes> dkk_: even then, do the simple/straightforward thing first (even if only to understand what's the difference between that and FRP)
20:42:05 <dkk_> ertes : only consequences would be that i would not get full marks that i never care for .... i have already passed the course
20:42:23 <ertes> dkk_: the problem is that it's impossible to estimate how long you are going to need, if you learn too many things
20:43:14 <ertes> dkk_: do the straightforward thing first, and if there is time left, you can still go for FRP
20:43:19 <ertes> refactoring in haskell is very easy
20:43:23 <dkk_> ertes : yes ... its correct .. recently i have taken much time to understand monads and transformers ...like reader, state etc
20:44:51 <dkk_> cale : ertes : ohk thanks a lot for guiding me !! have a nice day
20:45:02 <ertes> ah, so you're at stage 2 of 5 on the monad transformer ladder
20:46:46 <dkk_> ertes : stage 2 ... hahaha .. don't know ... recently i have written a text based game using stateTransformers and all and then feel ohh got atleast something called monad that can't be explained ....
20:47:26 <ertes> stage 1. Cfg -> IO (), 2. ReaderT Cfg IO (), 3. (MonadReader Cfg m, MonadIO m) => m (), 4. Eff '[Reader Cfg, Io] (), 5. Cfg -> IO ()
20:48:46 <dkk_> ertes : what is 4th 
20:49:39 <ertes> dkk_: not sure i'm doing you a favour, but: https://hackage.haskell.org/package/freer
20:49:41 <dfeuer> dkk_, extensible effects.
20:49:53 <dfeuer> I wouldn't particularly recommend 'em.
20:50:43 <ertes> ditto
20:51:14 <dfeuer> But at least one of them is built on the rather cool ideas of reflection-without-remorse, which are thoroughly orthogonal.
20:52:51 <dfeuer> Andras Kovacs (sp?) has some ideas for making extensible effects less unpleasant to work with. But I'm still not quite buying the idea that we should all be using a system few can understand.
20:53:16 <ertes> dfeuer: that actually reminds me of a question i wanted to ask you:  would it come with a performance penalty to generalise Seq to support indexed element types, and then have Seq be a special case?
20:54:18 <ertes> (<|) :: a b c -> GSeq a c d -> GSeq a b d
20:54:21 <dfeuer> ertes, I can't say for sure, but I think that would likely be fine. The big problem is that there are people who would get very upset if containers were to rely on fancy things like GADTs.
20:54:26 <hrqfjj> I'm trying to use a composition of my parseMaybeParens from earlier to parse to my internal data structure, MathExps. Here is what I have so far: parseMathExprs = fmap (map read) $ parseMaybeParens $ sepBy1 (many1 $ satisfy isMathChar) (skipSpaces *> (char ',') *> skipSpaces) 
20:54:36 <ertes> dfeuer: yeah, i see
20:54:41 <dfeuer> ertes, actually, there's one other complication.
20:54:52 <dfeuer> At least one other.
20:55:06 <dkk_> i am not getting what you r talking about
20:55:12 <dfeuer> There are a few operations that don't work for indexed sequences. Notably zipWith.
20:55:23 <dfeuer> (Or at least don't work *meaningfully*)
20:55:35 <dfeuer> So those would have to be constrained to kinds like ().
20:55:45 <ertes> sure
20:55:45 <hrqfjj> When I try to readP_to_S parseMathExprs "1 + 2", my parse result is [([Number 1]," + 2")]
20:56:06 <hrqfjj> Any chance someone could help me figure out what I'm doing wrong?
20:56:40 <hrqfjj> isMathChar is a simple helper to check if the characters are either an operation character or alphanumeric
20:56:57 <dkk_> ertes : why you gave me that link can you explain ....
20:57:12 <glguy> ertes: Would that mean generalizing the "Int" measure on the FingerTree in Seq?
20:57:25 <ertes> dkk_: Eff is a type for extensible effects, and 'freer' is one implementation of them
20:57:37 <dfeuer> glguy, no.
20:57:40 <ertes> glguy: nope
20:57:50 <ertes> glguy: that one would definitely come with a penalty
20:58:04 <dfeuer> glguy, type-aligned sequences split into existentially quantified pieces.
20:58:22 <glguy> I thought so, too. I didn't realize you meant type-indexed.
20:59:00 <dfeuer> ertes, there could be some small penalties building the simple version on top.
20:59:24 <dfeuer> Err.... maybe not, actually.
20:59:45 <dfeuer> Anyway, like I said, I think I'd likely get too many complaints about portability.
20:59:55 <dkk_> ertes : ohk thats fine i don't know a bit about that right now ... i think i should focus on editor implementation
20:59:57 <ertes> dfeuer: i can see that a newtype wrapper would be required, which might blind rules
21:00:36 <dfeuer> ertes, I would think that would be pretty easy to work around, but I certainly haven't tried it. It would also be a lot of work.
21:00:41 <ertes> dkk_: good idea =)
21:01:48 <dfeuer> ertes, for example, I believe it's possible to implement an operation equivalent to <*>, but ... um ... good luck.
21:02:38 <ertes> dfeuer: another complication i can imagine is that you can no longer return things unchanged in some cases:  (f (x :: A) = x :: A) vs. (f (x :: A a b) = x :: A a c)
21:03:04 <ertes> the latter is a type error and would require pattern-matching on x
21:03:15 <dfeuer> ertes, can you be more specific?
21:03:40 <ertes> dfeuer: i can't, because it's only conceptual, but think about the explicit implementation of 'fmap' for Maybe
21:03:48 <ertes> fmap f x@Nothing = x  -- type error
21:04:08 <pavonia> Given the type and value here <http://lpaste.net/346056>, is there a way to write a function showExpr that transforms any value of Expr to a String such that e.g. showToken false == "Œªx.Œªy.x"?
21:04:52 <ertes> dfeuer: since i'm not really familiar with the implementation of Seq, i don't know if cases like that will come up
21:04:53 <dfeuer> For Either, that's a real issue. You could have a problem if you try to modify the graph you're working over after the fact, but I don't know that you'll run into that as a matter of course.
21:05:08 <dfeuer> (For Maybe, that's not a real issue, because there's only one Nothing)
21:05:26 <pavonia> I'm already struggling with how the type signature for this would look like
21:05:41 <ertes> dfeuer: yeah, Either is a better example indeed
21:06:05 <dfeuer> ertes, yeah, I dunno. The reflection-without-remorse package has an implementation of type-aligned finger trees (which strikes a bad balance)
21:06:36 <dfeuer> (because they're unannotated Hinze-Paterson trees, so they're shaped to be splittable but they're not actually splittable)
21:06:45 <ertes> oh, i didn't even know about that pacakge =)
21:07:03 <dfeuer> If you want to think about this, you should probably look in there and add annotations and consider the many missing operations.
21:07:08 <dfeuer> Well, not *many*
21:07:11 <dfeuer> But several.
21:07:32 <geekosaur> pavonia, Lam takes a function as a parameter, and then represents in in the Expr as a function for App. if you represented them as data, it could be done; as functions, no
21:08:06 <dfeuer> ertes, there could be some optimization issues with the unsafeCoerces I anticipate needing for zipWith to prove that   (a :: ()) ~ '()
21:08:44 <dfeuer> I have no idea, as I said, how to translate the <*> algorithm.
21:08:47 <ertes> dfeuer: do you really expect that to be necessary?  GHC is pretty easy to convince of equality
21:09:09 <dfeuer> ertes, well, I haven't tried in 8.0, but it certainly didn't work before...
21:09:26 <ertes> i should do a list variant and see what issues i run into
21:09:41 <pavonia> geekosaur: I thought about applying this function to some generated variable names such that they show up in the Var parts of the expression
21:10:32 <dfeuer> ertes, no, not even in 8.0.
21:11:07 <ertes> dfeuer: is this issue Seq-specific, or will i run into it with type-aligned lists, too?
21:11:25 <dfeuer> ertes, along with <*> and zipWith, other likely difficult spots include inits and tails.
21:12:19 <dfeuer> ertes, I believe it's inherent to any zipWith with any hope of efficiency. The unsafe coercions may not actually hurt performance. I'm not sure.
21:12:38 <ertes> dfeuer: ah, wait‚Ä¶  you're thinking of defining zipWith for (let's call it) GSeq specialised on object kind ()
21:12:43 <dfeuer> Yes.
21:12:47 <ertes> dfeuer: i was thinking of defining zipWith on Seq instead
21:13:13 <dfeuer> ertes, you can't make that as efficient. Look at how it's implemented today.
21:13:25 <ertes> i see
21:14:05 <dfeuer> ertes, it *used* to be implemented the simple way, but that was slow and overly eager.
21:14:16 <dfeuer> So I fixed it :P
21:14:29 <ertes> > () :: (a :: ()) ~ '() => ()
21:14:31 <lambdabot>  ()
21:14:35 <ertes> dfeuer: well‚Ä¶
21:14:47 <ertes> the problem seems to be elsewhere =)
21:15:15 <dfeuer> ertes, I dunno... I tried   let foo :: (a :: ()) :~: '(); foo = Refl    in GHCi, and that didn't work.
21:16:16 <ertes> > Refl :: forall (a :: ()). a :~: '()
21:16:19 <lambdabot>  error:
21:16:19 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äòa1‚Äô with ‚Äò'()‚Äô
21:16:19 <lambdabot>        ‚Äòa1‚Äô is a rigid type variable bound by
21:16:20 <dfeuer> So I don't know why your example works.
21:16:23 <ertes> i see
21:16:39 <ertes> (~) seems to take into account that () is a singleton type somehow
21:16:51 <hrqfjj> Would either of you be willing to help me figure out why I'm unable to parse expressions the way I'm expecting really quickly? :p Sorry to interrupt
21:16:53 <ertes> ah, of course‚Ä¶  there is no type-level pattern-matching
21:17:07 <dfeuer> > () :: (a ~ Int) => ()
21:17:10 <lambdabot>  ()
21:17:38 <dfeuer> So it's just propagating that up.
21:17:52 <ertes> yeah, i see the problem
21:18:40 <ertes> forall (a :: ()). case a of '() -> a :~: '()  -- this would work, if it were haskell
21:23:02 <ertes> no, actually you would need to pattern-match against 'a' on the value level
21:23:18 <ertes> s/against//
21:30:12 <hrqfjj> Any chance I could get some guidance with parsing?
21:31:48 <pavonia> On what exactly?
21:33:16 <hrqfjj> http://lpaste.net/8828456391057342464
21:33:43 <hrqfjj> pavonia, I'm having issues with my parseMathExprs
21:33:56 <hrqfjj> I need to be able to parse both "x = 1 + 2"
21:34:21 <hrqfjj> and "(x,y) = (1,1)" or "(x,y) = (1,1+2)"
21:34:31 <hrqfjj> The tuple stuff is working
21:34:50 <hrqfjj> pavonia, But my non-tuple stuff is not
21:44:00 <pavonia> hrqfjj: At what point does it fail?
21:44:11 <hrqfjj> When there are spaces in the math expression
21:44:22 <hrqfjj> pavonia, ex. "1+2" is fine
21:44:24 <hrqfjj> pavonia, ex. "1+ 2" is fine
21:44:28 <hrqfjj> pavonia, ex. "1+ 2" is fails, rather
21:44:44 <hrqfjj> The problem is, when I run the parser separately it seems "1+2" fails
21:47:13 <pavonia> Hhm, that code is not immediately easy to understand
22:29:22 <dmwit> > let f :: proxy (a :: ()) -> proxy (); f p = p in ()
22:29:24 <lambdabot>  error:
22:29:24 <lambdabot>      ‚Ä¢ Expected kind ‚Äò()‚Äô, but ‚Äò()‚Äô has kind ‚Äò*‚Äô
22:29:24 <lambdabot>      ‚Ä¢ In the first argument of ‚Äòproxy‚Äô, namely ‚Äò()‚Äô
22:30:01 <dmwit> > let f :: Proxy (a :: ()) -> Proxy (() :: ()); f p = p in ()
22:30:04 <lambdabot>  error:
22:30:04 <lambdabot>      ‚Ä¢ Expected kind ‚Äò()‚Äô, but ‚Äò()‚Äô has kind ‚Äò*‚Äô
22:30:04 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄòProxy‚Äô, namely ‚Äò(() :: ())‚Äô
22:31:22 <dmwit> oh
22:31:35 <dmwit> > let f :: Proxy (a :: ()) -> Proxy ('() :: ()); f p = p in ()
22:31:37 <lambdabot>  error:
22:31:37 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äòa‚Äô with ‚Äò'()‚Äô
22:31:37 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
22:31:48 <dmwit> That's more like the type error I was hoping for. =)
22:41:34 <jchia_1> I'm trying to use CPP to do conditional reexport of some module, using the MIN_VERSION_... macro. How do I use it properly if the minimum version I want has only two parts, e.g. lens-4.14? MIN_VERSION_lens takes 3 arguments.
22:43:23 <jchia_1> how can i specify a minimum version of 1.4 instead of 1.4.0? 1.4.0 > 1.4, so there is a difference between MIN_VERSION_lens(1,4,0) and MIN_VERSION_lens(1,4) (if it can be specified).
22:43:51 <LordBrain> i don't think you can do that
22:44:03 <jchia_1> of course i could do something hacky like MIN_VERSION_lens(1.3.99) knowing there is no lens-1.3.99, but is there a cleaner way.
22:44:32 <jchia_1> i mean MIN_VERSION_lens(1,3,99)
22:45:08 <LordBrain> jchia_1, there is a version macro too that gives you the version as a string or number or something if i recall
22:46:24 <LordBrain> jchia_1, in the dist folder, you can find the actual .h file and see the macro defs
22:52:13 <dmwit> jchia_1: There's MIN_VERSION and !MAX_VERSION, right?
23:00:25 <jchia_1> dmwit: I couldn't find the documentation for MIN_VERSION and MAX_VERSION, but from examples of where they are used, can only deduce that MIN_VERSION is true if version is at least the specified version and MAX_VERSION is true if the version is at most the specified version. Is that right? Do you mean !MAX_VERSION_lens(4, 13, 2) with the knowledge that 4.13.2 is followed immediately by 4.14 (ignoring 4.13.2.1 which has 4 digits)?
23:01:06 <jchia_1> i don't know what MAX_VERSION would do for 4.13.2.1, though
23:05:18 <glguy> If a component is omitted from a version, the MIN_VERSION macros treat that component as a zero
23:05:38 <glguy> only the first 3 components are considered
23:05:56 <jchia_1> glguy: So MIN_VERSION_lens(4, 14, 0) would be true for both lens-4.14 and lens-4.14.0?
23:06:08 <glguy> 4.13.2 and 4.13.2.1 are guishable to the macros
23:06:13 <glguy> 4.13.2 and 4.13.2.1 are indistinguishable to the macros
23:07:08 <glguy> jchia_1: yeah
23:07:11 <jchia_1> thanks
23:12:35 <stalk> hello
23:14:30 <stalk> Quick question which I guessed is asked a lot: haskell doesn't "memo" previous results of function calls, does it?
23:15:19 <glguy> memoizing functions automatically wouldn't necessarily make execution faster and would use up memory in the process
23:16:00 <glguy> and then you'd have the question of deciding how to determine that two arguments are the same at all
23:16:07 <stalk> so you have to do it using Data.MemoCombinators for instance?
23:16:21 <stalk> glguy: well, "Eq" would take care of that, wouldn't it?
23:16:42 <```a> hi! can someone help explain to me why/how the list is a monad? thanks in advanced!
23:16:58 <glguy> No, relying on Eq would lead to a particularly slow implementation of memoization
23:17:46 <stalk> Ok, then you could just consider arguments equal if their in-memory representation is equal
23:18:03 <stalk> But I'm not arguing either way, just verifying
23:18:21 <glguy> Yeah, fortunately Haskell doesn't mandate it and GHC doesn't do it
23:20:19 <stalk> So, if a recursive implementation of some algo (say the levenshtein distance) is slow in some imperative language, it will stay slow in haskell
23:20:52 <glguy> ```a: For a type to be a monad you need it to have the kind * -> * and to select two operations with types that match (>>=) and return
23:21:08 <glguy> for [], those operations are a flipped concatMap and \x -> [x]
23:21:24 <glguy> those operations have to satisfy the "monad laws" (and do)
23:21:28 <```a> so bind on a list really just allows you to chain operations
23:26:48 <dcci_> is there any reason why SemiGroup is not a superclass of Monoid?
23:28:29 <glguy> https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
23:33:30 * hackagebot bond-haskell-compiler 0.1.5.0 - Bond code generator for Haskell  https://hackage.haskell.org/package/bond-haskell-compiler-0.1.5.0 (blaze)
23:33:32 * hackagebot bond-haskell 0.1.5.0 - Runtime support for BOND serialization  https://hackage.haskell.org/package/bond-haskell-0.1.5.0 (blaze)
