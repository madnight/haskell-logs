00:07:35 * hackagebot egison 3.6.2 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.6.2 (SatoshiEgi)
00:07:35 * hackagebot egison-tutorial 3.6.2 - A tutorial program for the Egison programming language  https://hackage.haskell.org/package/egison-tutorial-3.6.2 (SatoshiEgi)
00:09:44 <kirillow> I'm really stuck here. I'm trying to make the QuickChecks work, and I think I have to write an Arbitrary for `First' String`? I know how I'd do that for a type without a field. Or a type with a defined field like `String`. But `Optional a` - thats really beyond me somehow.. LINK: http://lpaste.net/4885608780479332352
00:27:04 <fierce_katie> why don't you use Maybe instead of introducing Optional? It seems to be the thing you need and it already has the Arbitrary instance
00:27:17 <MarcelineVQ> it's an exercise
00:27:28 <lpaste> MarcelineVQ annotated “QuickCheck First'” with “QuickCheck First' (annotation)” at http://lpaste.net/4885608780479332352#a339590
00:28:04 <kirillow> It's a learning thing...... (thats not working out to well at this particular point)
00:28:35 <MarcelineVQ> you're kind of on the right track, in the same way you can require the `a` of `instance Monoid a => Monoid (Optional a)` to be a Monoid you can require the `a` of instance Arbitrary (First' a) to be an Arbitrary, what might that look like?
00:28:45 <lpaste> kirillow revised “QuickCheck First'”: “QuickCheck First'” at http://lpaste.net/4885608780479332352
00:40:49 <kirillow> So, like `(Arbitrary a) => Arbitrary (First' a)`
00:44:16 <tdammers> is there something like overloaded tuples?
00:44:54 <MarcelineVQ> that's right, `instance (Arbitrary a) => Arbitrary (First' a) where` ensures `a` has an Arbitrary instance which allows us generate arbitrary values of that type. So next what is the type of arbitrary?
00:46:14 <tdammers> I have these list types with type-safe lengths here that I'm toying with
00:46:27 <tdammers> writing them as tuples would be cool
00:46:43 <MarcelineVQ> bleh, this nomenclature :> I mean what is the type signature of `arbitrary` itself
00:46:46 <tdammers> although overloaded lists would work in a pinch
00:47:00 <tdammers> :t arbitrary
00:47:03 <lambdabot> Arbitrary a => Gen a
00:47:35 <MarcelineVQ> I wasn't askin ye, but yes that's it there, notice that is' just a value. It doesn't take an argument.
00:47:43 <tdammers> correct
00:47:45 <MarcelineVQ> *it's just
00:47:56 <tdammers> for any given a with an Arbitrary instance, you can conjure up exactly one Gen
00:48:27 <tdammers> another popular class that consists of "just a value" is Default from Data.Default
00:49:10 <MarcelineVQ> kirillow: so `arbitrary (First' x) = First' <$> x` won't be correct here, it doesn't take an argument
00:49:26 <kirillow> ha yea thats what i tried
00:49:34 <kirillow> so i need a generator for Optional a
00:49:58 <kirillow> no
00:50:00 <kirillow> wait
00:50:02 <kirillow> hngh
00:50:05 <MarcelineVQ> sure you can make one for Optional a and reuse it for First' or you can just make one for First'
00:50:13 <kirillow> huh
00:50:15 <kirillow> how
00:52:13 <MarcelineVQ> We'll to do that we'll take advantage of the fact that we know `a` already has an Arbitrary instance
00:52:40 <jmorris> Is there a way I can do something like this, https://github.com/joshua-morris/hpass/blob/master/src/Hpass/CreateFile.hs, without having IO in every type?
00:54:01 <tdammers> jmorris: not really, no. Every one of these functions actually does I/O, so how would you do that?
00:54:27 <jmorris> tdammers: Idk, I just thought it looked really ugly
00:54:39 <tdammers> jmorris: only thing you might do is use something like Conduit, but that amounts to an abstractions on top of IO, and instead of dragging IO around, you'll drag Sinks and Sources and such around
00:54:50 <jmorris> ok
00:55:05 <tdammers> I don't think this one's bad at all
00:55:33 <tdammers> the IO in the type signature does exactly what it's supposed to do, namely signal that this function does I/O
00:55:44 <tdammers> (strictly speaking, it says that the functions returns an IO action)
00:56:42 <jmorris> thats good, I just thought I might be missing something
00:57:27 <MarcelineVQ> kirillow: That's not really an answer, I'm just trying to figure out how to explain the next part
00:57:49 <kirillow> sorry i really do not get it
01:00:13 <bsrk> I am having trouble using the applicative instance of (:.:)
01:00:19 <bsrk> http://ideone.com/WxBC7u
01:00:48 <bsrk> the compilation error is: No instance for (Control.Applicative.Applicative (Maybe :.: Maybe))
01:00:56 <tdammers> jmorris: when your programs get more complex than this, you will want to split the domain logic from the I/O parts, and when you do that, having IO in the type sigs helps you keep them separate and make things explicit
01:05:51 <MarcelineVQ> ohh okay thank god it is covered earlier hehe
01:06:41 <MarcelineVQ> okay so check out section 14.4 possibly page 539 in your book depending on version, genTuple
01:07:56 <MarcelineVQ> Do you see there how when you know a value is an Arbitrary you can leverage its definition of `arbitrary` to get a useful value from it ?
01:08:25 <kirillow> !!!!
01:08:28 <MarcelineVQ> right above it as well are two useful functions elements, and choose, either of which can use used to define First' along with what you have
01:08:48 <kirillow> totally forgot about that
01:09:04 <MarcelineVQ> *can be used
01:09:58 <MarcelineVQ> All my explanations had `a` in them 100 times so I'm glad there's a clean example available :X
01:11:23 <Myrl-saki> Err.
01:11:55 <Myrl-saki> How do I work with persistent, Haskell and another language?
01:12:14 <Myrl-saki> (which also uses the database)
01:12:35 <tdammers> persistent might not be your best choice then
01:12:55 <tdammers> I'd design the database schema using traditional methods, and then use something like HDBC to query it from Haskell
01:13:36 <tdammers> if you do want to use persistent, the best approach IMO is to start with the Haskell part, see what kind of database schema you end up with, and then write code in the other language to match that
01:13:46 <Myrl-saki> tdammers: I see.
01:14:00 <Myrl-saki> Thanks.
01:14:20 <tdammers> I'll plug my library, too... http://hackage.haskell.org/package/yeshql
01:14:56 <tdammers> allows you to define a bunch of SQL queries in SQL, then you wrap them in a quasiquoter which turns them into regular Haskell functions
01:15:19 <Myrl-saki> tdammers: I don't exactly know how to use SQL though.
01:15:52 <tdammers> Myrl-saki: then you better learn... it's not going away, and none of the abstraction layers I've seen so far manage to completely hide SQL away
01:16:09 <tdammers> plus it's not a lousy DSL for writing relational queries at all
01:16:20 <Myrl-saki> tdammers: Okay. Thanks. :D
01:30:37 <Lokathor> I read a non-haskell  tutorial the other day that interspersed all the IO everywhere in the entire program using a dozen little abstracted component things and update methods all over the place
01:30:46 <Lokathor> made my skin crawl just trying to read it
01:32:32 * hackagebot btrfs 0.1.2.2 - Bindings to the btrfs API  https://hackage.haskell.org/package/btrfs-0.1.2.2 (MariosTitas)
01:44:35 <wagnerf> hi, I have a function f taking several arguments and a list l of the same size
01:44:49 <wagnerf> is there an easy way to call f on the elements of l ?
01:44:52 <cheater> hi
01:50:11 <srhb> wagnerf: map (f a b c d) l ?
01:50:21 <srhb> wagnerf: where f is 5-ary
01:50:23 <srhb> (at least)
01:50:34 <srhb> wagnerf: Not sure what you're asking really :)
01:50:48 <wagnerf> srhb: no 
01:51:05 <wagnerf> l = [a:b:c:d]
01:51:07 <wagnerf> f a b c d
01:51:45 <wagnerf> my question is like : can I avoid naming all elements ?
01:52:52 <wagnerf> I googled a little bit and found some references on "apply" for scheme
01:53:54 <ongy> with TH, but that just hides the naming. Thinking about the type the function should have and that lists don't have type level length, I doubt it's possible 
01:56:57 <wagnerf> ongy: TH ?
01:57:49 <Hijiri> it works in scheme because when you do a function call it is basically passing a scheme list of arguments
01:58:13 <Hijiri> but that's not how function calls work in haskell
01:59:32 <Hijiri> multiple-argument functions in haskell are represented by curried functions, and there's the type system on top of that, so you might not have a good type to go to, even if you limit it to functions whose arguments are all the same type
01:59:39 <Hijiri> take for example f :: Int -> Int -> Int
01:59:58 <Hijiri> If I do apply f [1,2], then the result should be f 1 2 :: Int
02:00:09 <Hijiri> If I do apply f [1], though, the result should be f 1 :: Int -> Int
02:01:11 <Myrl-saki> Mmm
02:01:28 <Hijiri> In scheme that's not a problem since functions just take the list, and then they can call an error if it was defined to have a specific number of arguments
02:01:41 <Myrl-saki> Hijiri: typeclass
02:01:44 <Myrl-saki> Hijiri: I guess
02:01:56 <Hijiri> Myrl-saki: how would that work?
02:02:04 <Hijiri> THe type would depend on the input list
02:02:05 <Hijiri> not on the types
02:02:19 <Hijiri> the output type would depend, I mean
02:02:20 <Myrl-saki> Look at the printf typeclass.
02:02:40 <Hijiri> printf typeclass works by checking how many arguments you apply it to
02:02:50 <lyxia> wagnerf: TH = template haskell
02:02:54 <Hijiri> it doesn't check any of the arguments for being a list of certain length
02:03:05 <Hijiri> It can check the arguments type, though
02:03:20 <Hijiri> unfortunately haskell lists of different length do not have distinct types (as ongy mentioned)
02:03:30 <lyxia> you can add the check in the typeclass, returning Nothing if the arguments don't match
02:03:56 <Hijiri> lyxia: So in my earlier example, what instance should apply use?
02:05:10 <Hijiri> Should it be looking for 1 or 2 arguments?
02:05:13 <Hijiri> Or maybe even 0?
02:05:46 <Myrl-saki> Or you can use Either.
02:06:08 <lyxia> ah yeah what you were talking about is not possible indeed.
02:06:18 <Hijiri> I don't see how Either would help
02:06:23 <Hijiri> we can extend this to more than two arguments
02:06:26 <lyxia> Prtially applying a function with arguments in a list
02:07:10 <lyxia> What I meant was applying a function with a fixed number of arguments from a list.
02:07:45 <Hijiri> like defining specific apply2, apply3 etc?
02:08:08 <Hijiri> or maybe apply 2, apply 3, with singletons
02:09:12 <lyxia> Or apply deduces the number of arguments from the type of the function
02:09:40 <Hijiri> any function of n arguments is a function of i arguments, for i <= n
02:10:02 <Hijiri> I think the constraint "blah is not a function" is not decidable, from vague rememberings
02:10:38 <Hijiri> like what if you had f :: a -> a -> a
02:10:43 <Hijiri> how would you know how many arguments f had?
02:10:49 <ph88> hey lyxia are you around ?
02:10:52 <lyxia> There will always be cases where it won't work.
02:10:52 <Hijiri> a might be (a -> a) or something
02:11:02 <ph88> i guess that's a yes :>
02:11:15 <Hijiri> I'm saying you can't infer the number of arguments of a function
02:11:42 <lyxia> Well then only use that pattern when you can infer it.
02:11:43 <Hijiri> maybe you can try invoking UndecidableInstances and you can get it to work on the subset of things it works on
02:12:28 <lyxia> I am aware that it is not compatible with type inference, but I was just mentioning that solution for cases where you don't need it.
02:12:40 <lyxia> ph88: Hello.
02:13:40 <ph88> hi !
02:15:48 <ph88> lyxia, i'm trying to write a biplate function where the child is a list  https://paste.fedoraproject.org/481519/14792048/  i tried already several things with map .. i think i can combine the a's of the child with listStr .. but i don't know how to combine the b's
02:17:22 <volhovm> Hello everyone
02:17:25 <Myrl-saki> Hijiri: You can do applyn.
02:17:37 <volhovm> Why doesn't everybody use difference lists instead of regular ones
02:17:44 <volhovm> if they are good in concat performance
02:17:45 <volhovm> i wonder
02:17:51 <Myrl-saki> Oh wait...
02:17:56 <Myrl-saki> :t map
02:17:57 <lambdabot> (a -> b) -> [a] -> [b]
02:17:59 <Myrl-saki> :t fold
02:18:00 <lambdabot> (Monoid m, Foldable t) => t m -> m
02:18:04 <Myrl-saki> :t foldl
02:18:06 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
02:18:36 <Myrl-saki> Oh right. Won't work.
02:18:45 <Myrl-saki> Will work elsewhere but not Haskell.
02:19:00 <Hijiri> volhovm: they're not good for deconstructing
02:19:42 <volhovm> Hijiri: you can always apply pattern matching on (x []) for example
02:19:56 <ongy> also they aren't in Prelude. Which actually is the main reason I use String instead of Text if I dont do processing, only some FFI binding
02:20:00 <Hijiri> what's (x [])? A function x applied to []?
02:20:03 <volhovm> We could have had special syntax for that 
02:20:12 <Hijiri> you can't pattern match on a function
02:20:13 <volhovm> Hijiri: yes, if x is a diff list
02:20:17 <Hijiri> on a function application
02:20:20 <volhovm> > syntatix sugar
02:20:23 <lambdabot>  error:
02:20:23 <lambdabot>      Variable not in scope: syntatix :: t0 -> terror: Variable not in scope: ...
02:20:28 <Hijiri> syntax sugar for what?
02:20:39 <Hijiri> I'm not talking about syntactic ease of matching
02:20:40 <volhovm> for unwrapping it inside...
02:20:58 <Hijiri> when you want to get the head you have to convert it to a list first and then convert the tail back to a diff list
02:21:05 <Hijiri> this adds a traversal to the list each time
02:21:07 <volhovm> we have viewpatterns
02:21:17 <Hijiri> taking the head/tail is O(n) time, as opposed to constant time for normal lists
02:21:20 <volhovm> so (:[] -> list) is valid pattern matching i suppose
02:21:40 <Hijiri> I'm sure pattern matching on diff lists could be made syntactically easy
02:21:50 <Hijiri> It just has bad performance characteristics
02:22:11 <volhovm> Why taking head/tail is O(n)?
02:22:23 <Hijiri> Hijiri ╡ when you want to get the head you have to convert it to a list first and then convert the tail back to a diff list
02:22:25 <Hijiri>      ⤷ ╡ this adds a traversal to the list each time
02:23:34 <volhovm> Ok, i got your point
02:23:36 <volhovm> thanks
02:25:09 <ongy> and if you need a lot of concatenation (or other things that are slow on lists) you can use a different type locally. e.g. For building lists it works nicely to build it in reverse ( (:) to front) and reverse them at the end
02:33:17 <lyxia> ph88: biplate (LW names) = plate LW ||+ names
02:33:35 <lyxia> with the combinators from Uniplate.Direct
02:43:16 <ph88> lyxia, ah yes that works .. perhaps i could replace the first function by using the |+ combinator ?
02:43:20 <ph88> ill try it
02:43:52 <lyxia> yeah
02:44:03 <ph88> yup works ^^
02:44:12 <ph88> excellent
02:44:20 <lyxia> I dunno why I didn't want to do this before.
02:44:37 <ph88> maybe you didn't know about the combinators before ?
02:44:47 <ph88> anyway it's not so bad to know how they work by creating it self
02:45:01 <ph88> quite a lot of boilerplate though this Uniplate.Direct .. but it's the only solution i've got right now :/
02:45:55 <lyxia> I think it was because you were implementing a trivial instance where there were no children to speak of.
02:46:35 <ph88> right
02:48:53 <ph88> lyxia, why did you choose the ||+ combinator of the ||* ?
02:50:27 <lyxia> ph88: ||+ accesses the children of each element. ||* considers each element as the children themselves.
02:51:12 <lyxia> ph88: you can see that ||+ has a Biplate constraint, which you defer to in order to access the nested Identifiers.
02:51:25 <novakboskov> Hello, I have an issue with emacs and haskell-mode. GHC sometimes give me a suggestion for an expression. It is shown in mini buffer alongside a colored message on the end which says "(Hit `C-c C-r' in the Haskell buffer to apply suggestions)". When I type C-h k C-c C-r it says that C-c C-r runs the command haskell-process-reload. It is OK to have haskell-process-reload bound to this but how to apply GHC suggestions then?
02:53:22 <ph88> ok ill make note ^^
04:20:08 <DutchComputerKid> I was told this group was fun so hiii everyone
04:20:25 <DutchComputerKid> 1548 people holy sh!t
04:21:47 <DutchComputerKid> hm
04:21:52 <DutchComputerKid> so silent
04:22:53 <chpatrick> o/
04:25:22 <DutchComputerKid> Why is it so silent, I heard people had the biggest LOL's right here :P
04:26:02 <exio4> DutchComputerKid: becausen nobody had a haskell problem :)
04:26:18 <DutchComputerKid> exio4: Wow, :)
04:27:26 <DutchComputerKid> Why knows some good channels, just for general talk & boredness
04:27:29 <DutchComputerKid> *Who
04:28:05 <exio4> DutchComputerKid: offtopic per topic goes to #haskell-offtopic 
04:28:32 <byorgey> DutchComputerKid: this is a great channel for curing boredness.  You can learn Haskell, which is a really cool programming language: http://www.haskell.org/
04:28:56 <DutchComputerKid> hmmm
04:29:21 <arzav> Hi!
04:29:58 <DutchComputerKid> What can you do with Haskell?
04:30:08 <arzav> Where can I find haskell jobs ? 
04:30:25 <chelfi1> anything
04:30:26 <byorgey> DutchComputerKid: anything! It is a general-purpose language.
04:30:27 <chelfi1> anywhere
04:30:40 <DutchComputerKid> How does whispering work lol
04:31:05 <arzav> chelfi1: ok thx :)
04:31:50 <DutchComputerKid> Welp, ill loook up what I can do with this, :P
04:32:17 <juliagoda> What don't you understand in anything and anywhere?
04:32:47 <byorgey> arzav: I thought chelfi was answering DutchComputerKid's question
04:33:11 <arzav> byorgey: yep I see, thx.
04:34:11 <DutchComputerKid> Is haskell terminal (CMD) basic or GUI?
04:34:39 <chpatrick> DutchComputerKid: it's a GUI in visual basic
04:34:47 <bartavelle> :/
04:35:26 <DutchComputerKid> chpatrick: in VB, I program in VB! Should be easy as pie then.... VB.net I assume?
04:35:32 <bartavelle> DutchComputerKid, it is a general purpose programming language, so you can write command line applications, gui applications, network applications, etc.
04:35:45 <byorgey> chpatrick: that was unnecessary.
04:35:54 <DutchComputerKid> wut lol
04:36:00 <bartavelle> with ghcjs you can write code that runs in the browser
04:36:09 <DutchComputerKid> huh
04:36:13 <DutchComputerKid> how neat
04:36:33 <bartavelle> there are even some dsls that help you write code for FPGAs
04:36:44 <chelfi> anything was for DutchComputerKid, anywhere was for arzav :)
04:37:06 <DutchComputerKid> :)
04:37:28 <DutchComputerKid> Welp, what's the name for apt-get? GHC?
04:37:39 * hackagebot patat 0.4.0.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.4.0.0 (JasperVanDerJeugt)
04:37:50 <DutchComputerKid> patat NOM
04:38:29 <hodapp> whaaa
04:38:31 <DutchComputerKid> anyway, I'll get right to it
04:39:07 <DutchComputerKid> 208MB of data.......... this is going to take a while
04:41:51 <DutchComputerKid> Wait what's the actual programming interface called cause ghc is the compliler
04:42:50 <bartavelle> DutchComputerKid, there is no standard "programming interface", you usually use "cabal" or "stack" to compile your program on the command line, and edit it with any editor you like
04:43:21 <DutchComputerKid> Oh. It's that primitive huh.
04:43:24 * hvr often uses ghc directly w/o cabal or stack
04:43:57 <bartavelle> hvr, has a point, especially when starting, you'll probably spend a lot of time in the REPL (ghci) or compiling single files with ghc
04:43:58 <DutchComputerKid> package not found, oh oh
04:44:17 <DutchComputerKid> nvm got it
04:44:56 <hvr> bartavelle: I often abuse ghci as a calculator :)
04:45:16 <bartavelle> hvr, so do I!
04:46:46 <byorgey> abusing an interactive interface to a general-purpose computation language in order to interactively compute things, o noes ;-)
04:47:15 <kirillow> I!
04:47:19 <kirillow> woops
04:47:39 * hackagebot cassava-conduit 0.3.5 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.5 (domdere)
04:47:53 <DutchComputerKid> GHCI does not work...
04:48:24 <DutchComputerKid> or edit with nano, compile with GHC?
04:48:45 <juliagoda> ...
04:48:51 <kirillow> both should work fine
04:49:51 <ertes> DutchComputerKid: GHCi is a command line interface…  when you start it, you should see a prompt that looks like this: "Prelude>"
04:50:03 <DutchComputerKid> ertes:yep
04:50:09 <ertes> then it does work =)
04:50:13 <DutchComputerKid> ugh how does whisper work
04:50:13 <ertes> enter 1 + 1
04:50:31 <ertes> "whisper"?
04:50:48 <DutchComputerKid> nope
04:50:59 <DutchComputerKid> like the MSG
04:51:16 <bartavelle> there is no such think on IRC AFAIK, only msg or notice
04:51:16 <kirillow> what
04:51:17 * bartavelle like that
04:51:23 <DutchComputerKid> ah ok
04:51:48 <bartavelle> there are mirc extensions for color/bold/underline, but it is generally frowned upon
04:52:25 <DutchComputerKid> but /msg does nothing nor /w or /whisper
04:52:52 <bartavelle> /msg needs a target, but it's really the same thing as just typing your message in the input box
04:53:36 <bartavelle> unsure what whisper is supposed to do though
04:53:39 <DutchComputerKid> yeahyeh, but anyway.... I just compliled the hello world from wikipedia sucessfully soo I'll just go and let myself learn some Haskell
04:53:43 <ertes> bartavelle: query
04:54:16 <ertes> DutchComputerKid: be warned though
04:54:32 <DutchComputerKid> ertes: why
04:54:42 <ertes> haskell ruins you for most, if not all, of the more popular languages =)
04:54:48 <DutchComputerKid> oh
04:55:03 <DutchComputerKid> like QBASIC and VB6...... Welp
04:55:11 <DutchComputerKid> Why would it lead to that though
04:55:36 <hpc> because it's too damn good, and you find yourself wanting things those languages are incapable of doing
04:55:39 <ertes> unforunately noone can be told what the magic of haskell is…  you have to experience it for yourself
04:56:48 <DutchComputerKid> Huh... But BASIC is my main language, nvm then..... I'll see if there are intepreters for that for CLI. For now, I'll just leave Haskell installed for college.
04:57:06 <DutchComputerKid> Cya all and thanx so much for the help! Really appriciate it
04:58:43 <ertes> have fun!
05:06:16 <suppi> when profiling haskell, some entries in the .prof file looks like: func.(..
05:06:25 <suppi> func.(...)
05:06:37 <suppi> what does the .(...) part mean?
05:06:39 <DutchComputerKid> And fail
05:06:43 <DutchComputerKid> There are none
05:06:52 <DutchComputerKid> lol
05:08:27 <sdx23> suppi: lambdas i suppose
05:09:02 <suppi> sdx23: alright. i'll test that. thanks for the hint :)
05:39:02 <user_> can someone help me with a function?
05:40:41 <nevere> I am using TH to create a function as shown here http://lpaste.net/339638. How can I use an argument to set the function name as well?
05:44:23 <jophish> caconym: favourite culture novel?
05:44:46 <user_> can someone give me a help with a haskell function
05:45:10 <liste> user_: go ahead - tell us what help you want, and paste your code to http://lpaste.net/
05:46:56 <nevere> I am using TH to create a function as shown here http://lpaste.net/339638. How can I use an argument to set the function name as well?
05:48:22 <lyxia> You must construct the declaration without quasiquotations.
05:48:55 <lyxia> the body expression can be in a quotation though.
05:49:39 <kirillow> Can somebody explain this syntax to me: `newtype Combine a b = Combine { unCombine :: (a -> b) }`
05:49:42 <nevere> lyxia: Using SigE?
05:50:08 <kirillow> Combine has a record, and it's a function of type (a -> b), correct?
05:50:08 <nevere> lyxia: Sorry. Using SigD?
05:50:50 <lpaste> user_ pasted “convert types” at http://lpaste.net/339650
05:52:48 <Boomerang> user_: To build the inner [Char] you probably want to use append (++) instead of cons (:)
05:54:02 <nevere> kirillow: Combine is a record with one field named "unCombine" and it is of type a -> b, where a and b comes from the LHS.
05:54:13 <Boomerang> user_: In your description you say you want [["+ 5 2"],["+ 3 3"]], am I right in thinking you actually want ["+ 5 2","+ 3 3"]
05:55:02 <user_> sure
05:57:05 <lpaste> Boomerang revised “convert types”: “convert types” at http://lpaste.net/339650
05:58:34 <user_> yeah thats it, thanks man
05:58:59 <Boomerang> You're welcome, do you understand why it didn't work before?
05:59:59 <user_> before i was saying that i was doing like ["+"," ","5"...
06:01:19 <user_> instead of getting them together [Char] ++ [Char]
06:02:13 <Boomerang> Yeah it's the kind of problem where the compiler can't help you because the type signature is technically correct.
06:04:19 <user_> And types are sometimes my problem with haskell, it's so different the way i need to think...
06:06:13 <kuribas> Are bytestring chuncks multiples of 4?
06:06:19 <kuribas> (except the last)
06:08:01 <ertes> kuribas: ByteString is a continuous array of memory
06:08:27 <kuribas> ertes: well, lazyByteString then...
06:08:30 <ertes> kuribas: lazy ByteString is essentially a list of those with arbitrary chunk sizes
06:09:17 <ertes> kuribas: for example if you use fromStrict you get a single chunk
06:09:57 <lyxia> I don't think there is any guarantee about the length and number of the chunks. It can be quite uneven depending on your data source.
06:10:25 <kuribas> ok, thanks
06:12:42 * hackagebot hasql-optparse-applicative 0.2 - "optparse-applicative" parsers for "hasql"  https://hackage.haskell.org/package/hasql-optparse-applicative-0.2 (NikitaVolkov)
06:42:44 * hackagebot diversity 0.8.0.2 - Quantify the diversity of a population  https://hackage.haskell.org/package/diversity-0.8.0.2 (GregorySchwartz)
06:57:44 * hackagebot sparse-linear-algebra 0.2.2.0 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.2.0 (ocramz)
07:07:45 * hackagebot opentype 0.0.1 - Opentype loading and writing  https://hackage.haskell.org/package/opentype-0.0.1 (KristofBastiaensen)
07:29:29 <zebr> hi all, a quick question: can GHC FFI handle C++ template instantiation? my guess is no... but it would be really nice to be able to have templates manifest as higher-order types
07:35:57 <SchwererGustav> hello
07:36:00 <lpaste> kirillow pasted “test/Semigroup.hs” at http://lpaste.net/602371340812419072
07:36:00 <SchwererGustav> how are u all
07:36:07 <peddie> zebr: the GHC FFI only works with C, so it doesn't know that any particular instance of a C++ template is a template
07:36:13 <hodapp> zebr: my brief prior research says no
07:36:20 <SchwererGustav> i m new here and i ve been told that this is the best channel 
07:36:26 <hodapp> C++ tends to play badly with... pretty much every other language
07:36:40 <hodapp> SchwererGustav: good, are you new to Haskell?
07:36:43 <hodapp> or just to this chanel
07:36:46 <hodapp> s/chanel/channel/
07:36:53 <SchwererGustav> yes i m new to everything even to irssi
07:37:06 <hodapp> you might want to avoid IRCing as root
07:37:15 <Welkin> lol what
07:37:31 <SchwererGustav> i know that i should avoid it ,but how hodapp ?
07:37:50 <silver> Welkin, some clients use username as default ident
07:37:57 <hodapp> make another user, and run irssi as that user
07:38:25 <SchwererGustav> ok i will thanks hodapp 
07:38:41 <SchwererGustav> is there any way to hide the ip ?
07:39:03 <hodapp> you can get a mask but I think you have to ask in #freenode or something
07:39:31 <SchwererGustav> ahh ok thanks 
07:39:40 <SchwererGustav> so what are u discussing here normally
07:39:52 <ongy> I think it's called cloak. And for the unafilliated you just have to ask. But you need sasl login for a registered account for it to work properly.
07:40:21 <silver> SchwererGustav, haskell the programming language
07:40:29 <ongy> In this channel we are discussing haskell and haskell related topics. Sometimes it's derailed off topic into maths
07:40:31 <lyxia> kirillow: quickCheck requires you to be able to Show and compare values of type Combine, but you haven't implmented those.
07:40:36 <SchwererGustav> ahh that s why u call it like that
07:40:37 <hodapp> ongy: cloak, that's what I was mis-remembering!
07:41:16 <SchwererGustav> i m actually a face surgeon ,but as a hobby i use python as a programming language
07:43:12 <Tuplanolla> There's #python too, SchwererGustav.
07:43:13 <SchwererGustav> python in every single aspect is better than all other languages 
07:43:26 <Tuplanolla> Maybe you should go there instead.
07:43:41 <mlehmk> C++ does very well with any language that interfaces with C
07:43:44 <SchwererGustav> i m just here because i was told that this is the best channel 
07:43:55 <mlehmk> that's by design
07:44:18 <hodapp> mlehmk: C++ code can be made compatible with any language that interfaces with C. Saying it "does very well" is quite a stretch.
07:44:32 <hodapp> that act of making it compatible can be a royal pain
07:44:40 <mlehmk> hodapp, "stretch" depends
07:44:46 <mlehmk> I find it simple
07:44:58 <hodapp> Basically, if you use C++ like it's just C, then yes, it does very well with any language that interfaces with C.
07:45:08 <mlehmk> it might just be a lot to write
07:45:18 <mlehmk> but that'd basically be simple glue
07:45:30 <Welkin> is the glue made from horses?
07:45:33 <hodapp> It's complex enough that a whole array of dedicated tools exist for making C++ play nice with C-compatible bindings.
07:45:41 <kuribas> mlehmk: have you looked at wxHaskell?  That's hardly simple glue.
07:45:52 <hodapp> Sure, the code is "simple", it's just a *lot* of simple code.
07:46:01 <SchwererGustav> i must go now ,thanks a lot hodapp ,you are a very nice person 
07:46:05 <mlehmk> that's often the problem...
07:46:35 <hodapp> SchwererGustav: thanks, and do return if you'd like to learn more about Haskell
07:46:58 <hodapp> kuribas: in spite of that, how good are the bindings?
07:47:02 <hodapp> I've never done GUI stuff in Haskell.
07:47:07 <hodapp> probably because I avoid GUI stuff in most languages...
07:47:08 <kuribas> hodapp: they are low level but ok.
07:48:06 <kuribas> hodapp: I like how they implemented the object system in haskell.
07:48:57 <jchia_3> how do i actually use Control.Distributed.Closure? I know how to make a Closure from a StaticPtr and a StaticPtr from a top-level function. How do I make a closure from a value like (1 :: Int) so that I can combine it with a "function closure" using cap? The example given in the readme is wrong.
07:50:47 <kuribas> hodapp: Using wxHaskell imperatively is a bit messy, but it works nice with FRP like reactive-banana.
07:52:31 <hodapp> kuribas: interesting, FRP with 'real' GUI libraries... that's new to me as a possibility
07:52:51 <kuribas> well, you have to fire the events from IO yourself.
07:53:12 <kuribas> But that isn't hard.
07:54:22 <hodapp> I've just never really used FRP - only read about it.
07:54:25 <hodapp> and not enough.
07:55:03 <kuribas> hodapp: it's pretty easy when you understand the basics.
07:55:54 <lyxia> jchia_3: cpure closureDict (1 :: Int)
07:56:04 <kuribas> Instead of having events which imperatively modify the state, you encapsulate the state with the events that act upon it as a behaviour.
07:56:15 <hodapp> kuribas: I've read all that many times, I just need to use it :P
07:56:25 <kuribas> do it ;-)
07:56:31 <hodapp> busy doing other crap.
07:56:37 <hodapp> blaaaaaah.
07:56:59 <kirillow> Is there a way to compare functions? Actual functions, not their results using QuickCheck? Why not?
07:57:01 <kuribas> hodapp: well, if you need to write GUI code, I can recommend reactive banana :)
07:57:33 <kuribas> kirillow: if the domain is finite, you can test every combination.
07:57:46 <hodapp> kuribas: I will definitely keep that in mind for when I get a chance to look at this
07:58:18 <kuribas> hodapp: if you have complex dependencies in your app, it will make it much easier.
07:59:24 <lyxia> kirillow: it's not decidable whether two functions are equal
07:59:27 <kuribas> hodapp: otherwise it may be the same.
07:59:57 <ertes> kirillow: what does it mean for functions 'f' and 'g' to be equal?
08:01:33 * hodapp mutters something about a trick question
08:02:01 <kuribas> kirillow: for every value x in the domain of f, f x == g x
08:02:09 <ertes> it's not a trick question
08:02:10 <kuribas> ertes: ^
08:02:16 <ertes> kuribas: i know what it means
08:02:25 <ertes> kuribas: the question is whether kirillow knows =)
08:02:31 <kuribas> ertes: ah, sorry...
08:04:43 <ertes> kirillow: the point is: if you use the most common definition of function equality, you will find that quickcheck checking equality of outputs for random inputs is actually exactly what you want
08:04:56 <ertes> that's *testing* equality of functions
08:06:23 <kirillow> yea but what i want is an `instance Eq MyType...` where the constructor takes a function
08:06:35 <Profpatsch> Everyone goes through the “why can’t I compare two functions” phase sooner or later.
08:06:55 <kirillow> but why cant I ;____; this not fair
08:07:11 <Profpatsch> I’m at the acceptance stage I think.
08:07:12 <ertes> kirillow: you can in some cases
08:07:17 <hodapp> what's the context in which you are needing to compare two functions?
08:07:17 <silver> kirillow, you can't do that in general, but if you restrict possible functions something can be done
08:07:24 <Profpatsch> I actually forgot how the proof goes.
08:07:38 <ertes> kirillow: namely when the domain is finite
08:07:49 <kirillow> Well its not 8(
08:07:56 <hodapp> Profpatsch: probably some diagonalization argument in which Kurt Gödel and Alan Turing are cackling in the back of your mind near the end
08:08:02 <ertes> kirillow: then it's undecidable, as lyxia noted
08:08:47 <lyxia> Just work with constant functions.
08:09:33 <nevere> How can I pass a parametric type to a TH haskell function?
08:09:37 <Profpatsch> kirillow: you will have to restructure your program that the part with the equality check doesn’t actually get a structure with functions in it.
08:09:50 <ertes> kirillow: if you want to compare functions, you need to construct a language for functions that is restricted in such a way to allow function equality
08:10:06 <ertes> kirillow: (un)fortunately (->) is not such a language
08:10:39 <Profpatsch> I wonder what happens if you compare two such lists though:
08:10:43 <ertes> also haskell is probably not the best language to do that in =)
08:10:56 <Profpatsch> > [1..] == [1,2,3,5,..]
08:10:58 <lambdabot>  <hint>:1:19: error: parse error on input ‘..’
08:12:31 <Profpatsch> > [1..] == [x | x <- [1..], x `mod` 2 == 0]
08:12:33 <lambdabot>  False
08:12:43 <Profpatsch> > [1..] == [1..]
08:12:49 <lambdabot>  mueval-core: Time limit exceeded
08:12:51 <nevere> What is the counterpart of syntac ''User when User is parametric? I cannot seem to do ''User String.
08:12:52 <Profpatsch> Ah, ok
08:13:46 <Profpatsch> For that you’d need an actual proof system.
08:18:00 <lyxia> nevere: there's no such thing, ''User is just a Name.
08:18:51 <lyxia> You can quasiquote a type [t|User String|]
08:19:03 <nevere> lyxia: So is it not possible? I want to pass the type name to include it in signature created by TH.
08:19:12 <nevere> lyxia: Oh. Ok
08:20:47 <lpaste> kirillow revised “test/Semigroup.hs”: “test/Semigroup.hs” at http://lpaste.net/602371340812419072
08:20:49 <lyxia> Then don't pass a Name.
08:21:20 <lpaste> kirillow revised “test/Semigroup.hs”: “test/Semigroup.hs” at http://lpaste.net/602371340812419072
08:24:38 <lyxia> kirillow: why are you trying to implement coarbitrary
08:25:17 <kirillow> to quick check functions
08:25:53 <lyxia> You don't need one to check associativity of <> on Combine.
08:25:59 <kirillow> more precisely: quickcheck associativity of functions
08:26:18 <kirillow> ?
08:26:23 <lyxia> "CoArbitrary Combine" would be useful if you needed to generate functions "Combine -> something".
08:26:30 <kirillow> yeah
08:27:09 <lyxia> But semigroupAssoc is a predicate on "Combine String String", not "Combine String String -> something".
08:27:54 <kirillow> uuuuuuuhm
08:28:18 <kirillow> but String String are just the types of Domain and Codomain respectively
08:29:33 <lyxia> You want to generate values of type Combine a b, this is the role of the Arbitrary typeclass.
08:30:23 <kirillow> Yeah but that'd actually be Combine x :: Combine (a -> b)?
08:30:34 <kirillow> @_@
08:31:19 <kirillow> Like Combine $ \ n -> n
08:36:03 <lpaste> lyxia annotated “test/Semigroup.hs” with “test/Semigroup.hs (annotation for kirillow)” at http://lpaste.net/602371340812419072#a339700
09:08:58 <BernhardPosselt> just a quick question: m a -> (a -> m b) -> m b
09:09:08 <BernhardPosselt> the m must always be the same type, correct?
09:09:11 <BernhardPosselt> e.g.
09:09:21 <BernhardPosselt> Maybe a -> (a -> Maybe b) -> Maybe b
09:09:31 <BernhardPosselt> and not
09:09:38 <BernhardPosselt> Maybe a -> (a -> Maybe b) -> IO b
09:09:42 <Tuplanolla> Yes.
09:09:47 <BernhardPosselt> thanks :)
09:10:00 <Tuplanolla> They're variables like any other.
09:10:20 <Tuplanolla> You can even use them as such with the `ScopedTypeVariables` extension.
09:10:28 <nitrix> BernhardPosselt: Only if they belongs to the same quantification.
09:10:36 <alx741> Hello everyone, I'm struggling a bit with this: With Cabal I can search hackage packages with `cabal list matchstring`, how could I do that with Stack (for hackage and stackage), and how can I list the (stack) installed packages and versions?'
09:11:07 <BernhardPosselt> nitrix: as in: depends on what you write for its type class?
09:11:17 <nitrix> BernhardPosselt: In your case, there's an implicit quantification at the begining, `forall m.`, saying for all types `m`,  m a -> (a -> m b) -> m b, so the substitution has to follow throughly.
09:11:39 <nitrix> BernhardPosselt: It's possible to have  forall m. m a -> (forall m. ...) and those would be two different m's.
09:11:54 <BernhardPosselt> nitrix: nested type classes?
09:12:08 <nitrix> (Higher-order functions, rank-2)
09:12:31 <nitrix> BernhardPosselt: Not quite. It'd be a polymorphic function accepting another polymorphic function as an argument.
09:12:42 <BernhardPosselt> i see
09:12:58 <Tuplanolla> Take a look at the extension I mentioned and the `RankNTypes` extension nitrix is talking about, BernhardPosselt.
09:13:19 <BernhardPosselt> thanks :)
09:13:37 <Tuplanolla> It's in the user guide's section 9.1.
09:13:46 <nitrix> I could probably build a more useful example if that's what you're learning at the moment. Otherwise, it's probably best not to talk to much about it until you get there :)
09:14:32 <BernhardPosselt> im just periodically stumbling upon things where i find some haskell code and then i take a look
09:15:00 <BernhardPosselt> cross references :)
09:16:13 <nitrix> foo f a b = f a ++ show (f b)
09:16:48 <nitrix> BernhardPosselt: Let's pretend this function is invoked as `foo id "Hi" 123`.
09:17:34 <BernhardPosselt> so basically "Hi123" ?
09:17:47 <nitrix> BernhardPosselt: Presumably, the type of `a` is `String` and `b` is `Int`, which leaves the question of the type of `f`.
09:18:13 <nitrix> `f` takes something of a given type and just returns that same type, so we can suppose it's polymorphic, `a -> a`.
09:18:38 <nitrix> The problem is foo :: (a -> a) -> String -> Int -> String  is not going to compile.
09:19:59 <nitrix> That's because in one case, the polymorphic function `f` of type `(a -> a)` has to become `String -> String` and in the other case, it has to become `Int -> Int`.
09:20:21 <BernhardPosselt> right
09:20:29 <nitrix> (forall a. a -> a) -> String -> Int -> String would solve this.
09:20:58 <BernhardPosselt> is that valid notation?
09:21:02 <nitrix> Yup.
09:21:28 <BernhardPosselt> and it basically creates a function instead of a value for the type system
09:21:30 <nitrix> You need the RankNTypes or Rank2Types extension enabled though for higher ranked functions.
09:21:38 <BernhardPosselt> that whatever is plugged in returns the correct signature?
09:21:44 <glguy> It's valid using a GHC extension, it's not allowed in normal Haskell
09:22:42 <demoninajar> @pl \f g h -> (\x y -> f (g x) (h y))
09:22:42 <lambdabot> ((flip . ((.) .)) .) . (.)
09:22:51 <demoninajar> ew
09:22:57 <nitrix> BernhardPosselt: I can attempt to step back and explain this more simply now that we know what the goal is.
09:23:27 <BernhardPosselt> sure
09:23:40 <erisco> demoninajar, see http://stackoverflow.com/a/38546047/260584
09:24:51 <erisco> demoninajar, applicative-style does not work (simply) but the other three methods will. ~> is particularly good here
09:25:25 <nitrix> BernhardPosselt: Simplified, I like to give this as a starting point: there are two ways to observe a given polymorphic function. (1) The author of the function, that's the person implementing it and deciding what the function does, and (2) the user of that function, the person calling it.
09:27:05 <nitrix> BernhardPosselt: The type inference system works such as, from the user perspective, the function works for any type `a` and he's able to determines what types he wants to chose. From the author's perspective, the `a`, despite being `any type`, has actually already been determined by the user.
09:27:50 * hackagebot sbp 2.0.0 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.0.0 (markfine)
09:29:48 <erisco> demoninajar, liftA2 f <$> pure . g <*> pure (h $)
09:30:23 <nitrix> Thus, if you're the author of `foo` your type signature contains `(a -> a)`, you're letting the user choose what that `a` is, yet, you're also yourself using it polymorphically on two things of different types, so you're yourself a user as well.
09:31:15 <nitrix> BernhardPosselt: Hence why you need the additional notation. I'm not going to explain universal quantification but I think it's a decent starting point :)
09:31:26 <BernhardPosselt> nitrix: thanks for your time :)
09:32:14 <demoninajar> hmm flip $ f <$> g <$> h
09:33:22 <jedai> BernhardPosselt: basically in the first signature : "forall a . (a -> a) -> String -> Int -> String", the user can give you any function that can match the (a -> a) type, so (Int -> Int) or (Float -> Float) would be authorized... and of course you can't apply those function to both a String and an Int !
09:34:02 <nitrix> If you change it with (forall a. a -> a), now the user is required to provide you with something highly polymorphic, such as `id`.
09:34:21 <BernhardPosselt> hm, reminds me of the associated type constructors discussion on the rust blog
09:34:44 <jedai> BernhardPosselt: in the second signature : "(forall a . a -> a) -> String -> Int -> String", the user must give you a function that match (forall a . a -> a), that is they can only give you a function that work for any type, you thus can apply it to both Int and String
09:34:52 <erisco> demoninajar, that doesn't look to be quite right
09:35:08 <nitrix> jedai: You worded the conclusion better than I could. I appreciate.
09:36:03 <BernhardPosselt> http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/
09:36:17 <erisco> you can keep following this pattern
09:36:20 <erisco> :t \f g h i -> liftA3 (liftA3 f) <$> pure . pure . g <*> pure (pure . h) <*> pure (pure (i $))
09:36:22 <lambdabot> (a -> b -> c -> d) -> (a1 -> a) -> (a2 -> b) -> (a3 -> c) -> a1 -> a2 -> a3 -> d
09:36:45 <erisco> not too pretty though... use ~>
09:36:46 <BernhardPosselt> ah no, probably something different :D
09:37:23 <demoninajar> noted
09:37:36 <jedai> BernhardPosselt: we have that in Haskell too (that's type family)
09:37:38 <erisco> so it is  (g ~> h ~> id) f
09:38:02 <nitrix> BernhardPosselt: As you'd imagine, polymorphic functions taking polymorphic functions as arguments as bound to look a little complicated, but things fall into place quickly once you stumble on it a few times.
09:38:12 <BernhardPosselt> right
09:39:21 <erisco> I had a nice addition to ~> but I have misplaced it oO
09:39:42 <nitrix> BernhardPosselt: It's not _that_ common either that you need that level of abstraction; usually for libraries or helper functions.
09:41:00 <erisco> I dug it out of the logs... ($~>) x g = g . ($x)
09:41:28 <jedai> BernhardPosselt: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-families is the reference for something similar to your Rust concept (especially the "9.9.3. Associated data and type families" section), in fact I think Rust drew direct inspiration from this work in GHC (which date back a few years itself)
09:41:31 <nitrix> BernhardPosselt: Even more powerful are polymorphic kinds, but like, you count the use of those on one hand. Unless you're Edward Kmett.
09:42:13 <chelfi> does he have less fingers than other haskell coders ? 
09:42:17 * chelfi -> []
09:42:22 <jedai> nitrix: Right, plus it's really recent compared to Rank-n types
09:42:39 <erisco> that lets you apply an argument
09:42:46 <erisco> so instead of mapping an argument you make it constant
09:42:50 <geekosaur> he throws around polymorphic kinds like other people throw around concrete types >.>
09:43:12 <erisco> though... not the constant mapping either so perhaps that is the a confusing way to put it
09:43:17 <geekosaur> (do we measure type level hackery in millikmetts yet?)
09:43:59 <mmaruseacph2> :i (~>)
09:44:22 <mmaruseacph2> :t (~>)
09:44:24 <lambdabot> error:
09:44:24 <lambdabot>     • Variable not in scope: ~>
09:44:24 <lambdabot>     • Perhaps you meant one of these:
09:44:29 <mmaruseacph2> oh, well
09:45:14 <demoninajar> interesting, i'll have to take a look at this
09:45:23 <demoninajar> thanks
09:46:45 <jedai> mmaruseacph2: http://hayoo.fh-wedel.de/?query=%22%7E%3E%22
09:46:58 <jedai> mmaruseacph2: so which one do you want ?? ;)
09:47:27 <mmaruseacph2> yeah, looking through them now
09:47:41 <mmaruseacph2> was mainly curious from the above discussion
09:48:00 <erisco> mmaruseacph2, (~>) f g = (g .) . (. f) http://hackage.haskell.org/package/TypeCompose-0.9.12/docs/Control-Compose.html
09:48:38 <mmaruseacph2> interesting
09:51:32 <erisco> :t (+1) ~> 2 $~> (*3)
09:51:34 <lambdabot> (Num a, Num b1, Num c) => (b1 -> a -> c) -> b1 -> c
09:51:54 <erisco> > ((+1) ~> 2 $~> (*3)) (+) 4
09:51:56 <lambdabot>  21
09:52:08 <nitrix> Why does TypeCompose doesn't use things like contravariant?
09:52:42 <nitrix> I see their ContraFunctor type class, it's the same as the Contravariant one...
09:52:52 <nitrix> We have these nice abstractions and we don't re-use them :(
09:53:16 <conal> nitrix: TypeCompose an old package. Predates contravariant.
09:53:18 <erisco> well it may not have been around in 2007
09:53:26 <nitrix> Oh. Gotcha.
09:54:51 <nitrix> conal: Is it worth the effort of plugging contravariant to it and deprecating contraFmap or I shouldn't bother to create a pull request?
09:56:33 <conal> nitrix: i'm neutral about it. i'd probably integrate a pull request.
09:56:36 <nitrix> Although, now that I think about it, I don't see why Edward's should be prioritized over yours.
09:57:53 <nitrix> More recent maybe? In retrospective, I should've kept that little thought to myself :P
10:00:04 <nitrix> It just saddens me to see duplicated efforts... but I jumped the guns here :]
10:01:31 <jedai> nitrix: "We have these nice abstractions and we don't re-use them"... indeed... In fact Haskell is pretty insane in the number of 'small' packages we import to get nice little abstractions, when you install a package a bit further on the scale you get this deluge of basic package installing (the first few invocations of stack are frightening !) and I'm not even speaking of lens
10:04:25 <mmaruseacph2> imagine using cabal sandboxes and having to reinstall those same packages countless times
10:05:23 <jedai> mmaruseacph2: thankfully, cabal new-build should help there
10:05:30 <mmaruseacph2> exactly :D
10:05:42 <erisco> nitrix, a foray into Haskell politics
10:06:10 <mmaruseacph2> yeah, better not dvelve into those again
10:10:13 <aspiwack[m]> orion, JonReed: Let me clarify a few things about linear types. The wiki page has indeed been dormant, that's because we have been working on a larger article (not public yet) discussing the details of the proposal and exploring (some of) the motivations and consequences, in cooperation with GHC HQ. (which reminds me that the design has evolved since then, and I need to update the wiki page accordingly). We've started
10:10:14 <aspiwack[m]> with the implementation, but it's still in a very early stage. We really want it to happen, so we're dedicating as much time as we can. If you (or anyone) have a question about or want to discuss the linear types proposal, I'm lurking about: don't hesitate to highlight me.
10:11:23 <erisco> linear types Q2 2017 confirmed
10:12:11 <geekosaur> ignoring the 6 month delay before enough yaks are shaved for the relevant ghc version can be released >.>
10:12:18 <geekosaur> s/can be/to be/
10:12:21 <aspiwack[m]> :-p If we can pull that off, I'd be really happy. It's a non-trivial change.
10:13:51 <mmaruseacph2> that would be cool
10:17:52 * hackagebot gnss-converters 0.1.19 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.19 (markfine)
10:21:29 <stalk> hi
10:22:09 <Welkin> stalk: verb or noun?
10:22:17 <stalk> noun
10:22:38 <mmaruseacph2> both?
10:22:47 <mmaruseacph2> oh, you meant the nickname
10:23:38 <stalk> Tell me if it's too offtopic: I'd like to adapt the gitit software to be able to work with a remote repository. I didn't find the part of the code that interfaces with git (bad start!), anybody could point me to it?
10:31:30 <dmwit_> Perfectly on-topic. No idea the answer, though.
10:31:53 <jedai> stalk: I think it use the filestore package
10:32:05 <jedai> https://hackage.haskell.org/package/filestore
10:32:47 <gajus> Whats the equivalent of http://clojure.org/guides/threading_macros#thread-first is Haskell?
10:32:49 <stalk> jedai: ah, right, thank you!
10:33:40 <stalk> that means it'd harder than expected to make it do what I want
10:33:59 <dmwit_> gajus: State(T)
10:34:46 <dmwit> ?let data Person = Person { name :: String, age :: Int, hairColor :: String }
10:34:47 <lambdabot>  Defined.
10:35:00 <jedai> stalk: well you'd probably need to modify filestore
10:35:34 <dmwit> > runState (modify (\p -> p { age = age p + 1 }) >> modify (\p -> p { hairColor = "gray" })) (Person { name = "Socrates", age = 39 })
10:35:37 <lambdabot>  error:
10:35:38 <lambdabot>      • No instance for (Show Person)
10:35:38 <lambdabot>          arising from a use of ‘show_M42942022335899492932392’
10:35:43 <dmwit> ?undefine
10:35:44 <lambdabot> Undefined.
10:35:50 <dmwit> ?let data Person = Person { name :: String, age :: Int, hairColor :: String } deriving (Eq, Ord, Read, Show)
10:35:53 <lambdabot>  Defined.
10:35:56 <stalk> and it would be even more transparent on the gitit side, potentialy?
10:35:56 <dmwit> > runState (modify (\p -> p { age = age p + 1 }) >> modify (\p -> p { hairColor = "gray" })) (Person { name = "Socrates", age = 39 })
10:35:58 <lambdabot>  ((),Person {name = "Socrates", age = 40, hairColor = "gray"})
10:37:01 <jedai> stalk: Right, that would be ideal
10:37:22 <dmwit> gajus: ...or possibly just `(.)`, depending on exactly what you want.
10:37:46 <dmwit> > (\p -> p { age = age p + 1 }) . (\p -> p { hairColor = "gray" }) $ Person { name = "Socrates", age = 39 }
10:37:49 <lambdabot>  Person {name = "Socrates", age = 40, hairColor = "gray"}
10:37:53 <stalk> jedai: Do you think it would be doable/accepted upstream?
10:37:56 <jedai> gajus: strictly speaking there is no exact equivalent since this is a macro (Haskell has Template-Haskell but that's not the same
10:38:07 <dmwit> jedai: Lazy functions are much like macros.
10:38:19 <dmwit> But cleaner, theoretically. =)
10:38:25 <jedai> stalk: I'm pretty sure that such an extension, implemented nicely would be very well received
10:38:53 <jedai> dmwit: sure but in this bparticular cas it won't work since this is a purely syntactical modification
10:39:02 <stalk> ok, I'll see what's possible. Thanks for your help!
10:39:26 <dmwit> jedai: I'm not sure I understand the distinction you're making.
10:39:41 <jedai> gajus: but as demonstrated by dmwit such a thing isn't really necessary in Haskell (beside you can even improve on the syntax is you use a Lens library)
10:40:59 <dmwit> jedai: Suppose GHC took applications of the form `f . g` and transformed them at compile time to `\x -> f (g x)` (which it does). Would this qualify as "purely syntactic"?
10:41:21 <jedai> dmwit: Lazy functions are nice to replace use of macro as control structure but this here isn't really so much that, it insert a value as first argument in a bunch of incomplete functions (which wouldn't even compile without this insertion in Haskell)
10:41:58 <jedai> dmwit: Will that's the compiler, by definition it can do syntactic transformation (since it has an AST and all)
10:42:02 <geekosaur> jedai, that sounds like you have an issue with strong typing
10:42:05 <jedai> *Well
10:42:11 <geekosaur> macros will not save you from strong typing
10:42:33 <jedai> geekosaur: I didn't say I thought this macro was a *good* idea !
10:42:46 <dmwit> jedai: Is the "first argument"/"last argument" distinction actually important? `(.)` inserts a value as the last argument of a bunch of incomplete functions.
10:43:28 <dmwit> Or am I misunderstanding? Is the value being supplied here mutable? In that case, the closer analogy would be `Reader`.
10:43:31 <jedai> geekosaur: I just said that some macros can't be replicated by lazy functions because they do syntaxic manipulations on code that wouldn't even make sense without those manipulations
10:43:33 <geekosaur> jedai, you're still not making much sense. unless I interpret you as "turn Haskell into Scheme" in which case the answer is necessarily "of course not"
10:44:02 <jedai> geekosaur: I don't think I understand what you thought I was saying...
10:44:04 <geekosaur> or rather, that I interpret the original question as "how do I turn Haskell 100% into Scheme" which seems a non-useful interpretation
10:44:46 <geekosaur> you seem to be focusing on "so how do I exactly replicate this thing that requires a completely different basis than Haskell"
10:44:47 <dmwit> Well, the original question is "what's the Haskell equivalent of clojure's thread-first macro" which is rather more targeted than "how do I turn Haskell into Scheme".
10:45:03 <jedai> geekosaur: I'm not the one who asked the original question.... :/
10:45:06 <geekosaur> becuase that's the only way I can understand your com[laints
10:45:07 <dmwit> I think one of `(.)` or `Reader` is probably the targeted answer to that question.
10:45:23 <jedai> geekosaur: and I also didn't voice any complaints...
10:45:34 <geekosaur> (i.e. your complaints look like "but that does nto answer how to exactly replicate this thing")
10:46:14 <jedai> dmwit: Right, or State with a lens library to have pretty syntax (but your exemple already showed that it was really unnecessary in Haskell)
10:46:38 <jedai> geekosaur: could you read my last two posts before continuing in this vein ?
10:47:15 <dmwit> gajus: Hopefully this discussion has been clear as mud. Any other questions we can answer confusingly? =D
10:47:50 <gajus> dmwit Sorry for the lack of response, I have noted down things, but will need to dig more into Haskell to understand which is the most correct for the use case.
10:48:14 <gajus> To give a bit of context, I want to add a reference to Haskell docs for people reading about this proposal to ES
10:48:15 <gajus> https://github.com/gajus/babel-plugin-transform-function-composition
10:48:36 <ertes> gajus: i think the discussion is pretty much completely irrelevant to your question, and the answer is (.) =)
10:48:46 <ertes> or potentially StateT
10:49:44 <dmwit> I believe all three people who answered have now come to the same conclusion.
10:49:57 <dmwit> (.), or maybe in really complicated situations, State(T)
10:49:58 <ertes> i have no idea how macros got into this anyway…  yes, "->" in clojure may be a macro, but the only reason, as far as i see, is because it wants to look pretty in a lisp setting, where you can't just remove parentheses for associative functions
10:50:32 <geekosaur> jedai, I strongly suggest you reread what *I* wrote (I do not see how you managed to read anything as claiming you as the asker of the original question). and possibly what you wrote at 18:38:31 utc
10:50:52 <geekosaur> however I am done now since I enjoy being misinterpreted so *very* much
10:52:20 <jedai> geekosaur: Right, I do too so if you refer to "dmwit: sure but in this particular cas it won't work since this is a purely syntactical modification" that was in response to <dmwit> jedai: Lazy functions are much like macros. But cleaner, theoretically. =)
10:53:36 <jedai> geekosaur: and I said that because Lazy functions cannot replicate all macros. I didn't argue for the usefulness of either approach or whether a macro was really appropriate here
10:54:08 <dmwit> I think geekosaur's point (and mine) is that we're not trying to replicate all macros. Just this one.
10:54:09 <ertes> that's because lazy functions aren't like macros in any way
10:54:17 <dmwit> ertes: They fill a similar ecological niche.
10:54:22 <ertes> sure
10:54:51 <johnw> we should note that you're referring to Lisp macros, and their ability to make evaluation of arguments dependent on logic within the macro
10:55:03 <ertes> but macros achieve that goal in a fundamentally different way, a way that isn't even consistent with haskell semantics
10:55:12 <johnw> i.e., absolutely not the same as a C macro
10:55:21 <jedai> dmwit: But you don't even need lazy functions here... that's just composition
10:55:32 <ertes> they aren't even like haskell's TH
10:56:32 <dmwit> fair point
10:56:35 <jedai> dmwit: though sure, composition is much better with lazy language
11:04:24 <younder> yes, be lazy avoid getting fat.
11:09:45 <duairc> Hi
11:10:06 <duairc> I have some code that works on GHC 7.10.3, but fails on GHC 8, and I can't figure out why. I'm getting an error message about functional dependencies.
11:10:09 <duairc> http://hastebin.com/obofakarec.hs
11:10:33 <duairc> That's the code, and it shows an example of what happens when I run it in GHCi 7.10.3 and GHC 8
11:10:38 <duairc> If anybody can figure out what's going on, that would be great.
11:11:57 <bbear> hi
11:13:27 <jedai> duairc: I don't understand why you need your two instances of Update 0
11:13:44 <bbear> Actually I think clear mathematical definition from a set-theory pov would be much more clear on what are this classes : applicative, functor, monad, etc.
11:13:46 <jedai> duairc: a priori the second one is enough to cover the first case
11:14:17 <bbear> + good examples
11:14:33 <duairc> jedai: Yes, it is, but because of how overlapping instances works (it selects the "most specific" instance), there are cases where I need the first (most specific) one to force it to pick a sensible one
11:15:25 <jedai> duairc: Really ? but the first one do exactly the same as the second. Is this a type inference problem ?
11:15:40 <lyxia> duairc: is line 74 the last instance?
11:17:27 <duairc> lyxia: Sorry, those line numbers are wrong, they are from before I pasted that output at the top of the file. It should really be (106,31)-(107,34). Which is indeed the last instance.
11:17:42 <mniip> bbear, but CT operates on a level that is above set theory
11:17:58 <mniip> and all 3 classes are CT concepts
11:18:01 <bbear> yeah, it is above
11:18:03 <lyxia> jedai: I suppose if a ~ b then GHC can't decide between the last two ones
11:18:15 <duairc> lyxia: jedai: Yeah, that's it
11:18:16 <bbear> but it can be defined mathematically however
11:18:18 <bbear> I think
11:18:21 <bbear> and well defined
11:18:56 <bbear> I wonder why nobody did this. After all not every haskell programmer is a category specialist. So a gentle introduction would really help.
11:18:56 <mniip> sure,
11:19:01 <mniip> um
11:19:03 <lyxia> If a ~ b and n ~ 0 actually.
11:19:08 <mniip> it has been done plenty of times
11:19:30 <bbear> I am reading typeclassopedia but I find it hard to give me a good grasp.
11:19:58 <mniip> https://ncatlab.org/nlab/show/functor
11:21:43 <Tuplanolla> You can replace `Functor` with `Mappable`, `Monad` with `Bindable` and so on, and carry on without having to worry about it, bbear.
11:21:48 <mniip> keep in mind that the Functor typeclass *represents* the concept of a CT functor in haskell - there are some nuance
11:21:48 <duairc> lyxia: jedai: http://hastebin.com/calirehazo.hs It does work in GHC 8 if I give an explicit type signature for the output. Surely the whole point of functional dependencies is that I shouldn't have to do that?
11:21:53 <mniip> s
11:22:06 <Tuplanolla> The categorical motivation works fine as an afterthought.
11:22:20 <mniip> Tuplanolla, how is Reader Mappable?
11:22:23 <lyxia> duairc: right
11:22:51 <lyxia> what if you comment out the last one
11:23:13 <Tuplanolla> I have no problems calling a function a container, mniip.
11:23:25 <mniip> okay well then
11:24:13 <erisco> you put things in the container with const, and take them out with $
11:24:41 <duairc> lyxia: It works with the last instance commented out. But then I also want that instance for updating non-zero indexes...
11:25:39 <bbear> Tuplanolla: hell
11:25:49 <bbear> I am just realizing that I must learn CT 
11:25:51 <bbear> the hard way
11:26:02 <bbear> before going on with haskell.
11:26:25 <Welkin> bbear: what
11:26:31 <Welkin> you don't need any category theory for haskell
11:26:32 <Welkin> at all
11:26:33 <Welkin> none
11:26:48 <Welkin> you only need to understand what a typeclass is and how to use one
11:27:25 <lyxia> duairc: It's doing something very fishy. I'm not sure what either.
11:28:02 <duairc> lyxia: Yeah. What's weird is just that it's changed vs GHC 7.10.3, and also that it works with the type signature.
11:28:41 <lyxia> I'm not sure which one should be correct.
11:28:56 <lyxia> Your instances imply different dependencies.
11:29:40 <duairc> lyxia: What do you mean? What dependencies do they imply?
11:30:27 <bbear> what a typeclass is and how to use it ?
11:30:46 <bbear> first of all the typeclass notion is fuzzy to me
11:31:18 <bbear> about how to use it and read types for Monads, etc, it is exactly the same as reading their mathematical definitions in a more shaky / less precise maneer
11:31:27 <bbear> but
11:31:30 <Welkin> what
11:31:34 <Welkin> it has nothing to do with math
11:31:42 <Welkin> a typeclass is just an interface you define
11:31:44 <Welkin> or use
11:31:49 <geekosaur> understanding CT won't help you understand Data.Default >.>
11:31:57 <lyxia> duairc: A constraint Update n b (a : as) (c : bs) implies either b ~ c or a ~ c depending on the instance you select.
11:32:01 <geekosaur> or for that matter Num
11:32:23 <lyxia> duairc: do you know at what point functional dependencies should be resolved
11:33:02 <Tuplanolla> Learning category theory might, however, equip you with enough mathematical maturity to stop worrying about tangential topics.
11:33:26 <glguy> duairc: I think you'd be better off with this : http://hastebin.com/ifigewetuv.hs
11:33:28 <maerwald> don't learn stuff you don't need
11:33:50 <erisco> "mathematical maturity" lol
11:34:06 <ab9rf> mathematical toddler
11:34:09 <erisco> favourite phrase of one of my professors
11:35:02 <duairc> glguy: Well, that works! 
11:35:47 <geekosaur> basically, a typeclass lets you group together conceptually similar but type-distinct operations. for some but not all typeclasses, "conceptually similar" may involve number theory or category theory or etc. for others (e.g. Default and by some arguments Num), it's completely seat-of-your-pants
11:36:08 <duairc> glguy: Thanks for that.
11:39:26 <Squarism> I guess im forgetting an obvious simplification here but cannot seem to remember it : http://lpaste.net/339795
11:39:40 <phadej> when is PLDI deadline, seems nothing really happens before it
11:39:54 <glguy> Squarism: You can "traverse" opponentIdOpt
11:40:05 <Squarism> toCG :: .... -> ..-> IO ClientGame
11:40:09 <Squarism> oh ok
11:41:40 <Ed____> Are these equivalent? and [elem (x,z) r | (x,y1) <- r, (y2,z) <- r, y1 == y2] && and [elem (x,z) r | (x,a) <- r, (b,z) <- r]
11:41:51 <Ed____> Are these equivalent? and [elem (x,z) r | (x,y1) <- r, (y2,z) <- r, y1 == y2] && and [elem (x,z) r | (x,a) <- r, (a,z) <- r]
11:41:56 <Ed____> disregard the first one. sorry
11:42:00 <Squarism> glguy, thanks that worked fine
11:42:09 <IngoB> hi, quick question (from working through "Haskell Programming from first principles): exercise says find the two possible ways of implementing a -> a -> a and the answer is presumably f x y = x or f x y = y (show first or second argument). But that really get type signature a -> b -> a or a -> b -> b. The only way I see of enforcing same type for both arguments is trickery like f x y = if True then x else y and f x y = if False then x
11:42:29 <glguy> Ed____: No, using 'a' twice like that doesn't force them to be equal, it causes the first 'a' to be forgotten
11:42:53 <bbear> seems like identity
11:43:05 <Welkin> @djinn a -> a -> a
11:43:05 <lambdabot> f _ a = a
11:43:11 <Ed____> @glguy thanks
11:43:11 <lambdabot> Unknown command, try @list
11:43:20 <Welkin> Ed____: don't use @ on irc
11:43:32 <Tuplanolla> If you have `a ~ b`, then the types match, IngoB.
11:43:45 <kadoban> IngoB: You're supposed to assume you have that type annotation already and come up with implementation(s).
11:43:53 <geekosaur> IngoB, I think the point is you are given the type signature. once you have that, there are two possible implementations. you do not have to try to enforce the type signature in your code
11:44:06 <kadoban> IngoB: So yes, either implementatation has a less restrictive possible type, but it doesn't matter, it still unifies with :: a -> a -> a  too
11:44:07 <hololeap> is there a another way to do composition on both arguments in a two-argument function, eg. let (nx:ny:_) = map (this . that . other) [x,y] in compare nx ny
11:44:14 <geekosaur> it is already enforced, that is why there are only two possible implementations
11:44:38 <Welkin> :t (.).(.)
11:44:40 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:45:00 <bbear> > :t f a _ =a
11:45:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:45:07 <bbear> > :t f a _ =a
11:45:10 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:45:14 <Welkin> bbear: remove the >
11:45:21 <bbear> :t f a _ =a
11:45:23 <lambdabot> error:
11:45:23 <lambdabot>     parse error on input ‘=’
11:45:23 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
11:45:30 <lyxia> duairc: I think you're encountering an issue related to this https://ghc.haskell.org/trac/ghc/ticket/10675
11:45:38 <hololeap> so boobs with a mole?
11:45:59 <erisco> :t \a _ -> a
11:46:01 <lambdabot> t -> t1 -> t
11:46:09 <erisco> :t let f a _ = a in f
11:46:11 <lambdabot> t -> t1 -> t
11:46:18 <bbear> btw do you know of a little bit more practical language like Haskell ?
11:46:23 <IngoB> f _ a = a is a -> b -> b not a-> a -> a.  But I get the comment about just comping to the signature (rather than making type inference get the same type) 
11:46:25 <bbear> Rust for example is it good ?
11:46:32 <Welkin> bbear: haskell is the most practical haskell-like language
11:46:42 <bbear> I am looking for my next compiled functional language
11:46:43 <Welkin> no, haskell is very practical
11:46:44 <lyxia> duairc: you have "inconsistent" instances, but because of overlapping rules the inconsistency might not be observable.
11:46:53 <erisco> Rust and Haskell do not have much in common
11:46:55 <bbear> Welkin: I don't mean to debate
11:46:56 <Welkin> bbear: I build all my web apps using it
11:46:58 <jedai> hololeap: you probably want on
11:47:04 <jedai> :t on
11:47:06 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:47:19 <kadoban> bbear: I have heard interesting things about rust, but I don't know much about it. *shrug*
11:47:35 <jedai> hololeap: compare `on` fst
11:47:38 <bbear> maybe if I go to #rust they will tell me it's extracool
11:47:40 <hololeap> jedai: what module is that in?
11:47:49 <jedai> hololeap: Data.Function ? 
11:47:53 <jedai> Ithink
11:47:55 * hackagebot GLUtil 0.9.1.1 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.9.1.1 (AnthonyCowley)
11:47:58 <ertes> bbear: do you want to learn haskell?
11:48:09 <lyxia> duairc: and somehow 8.0 added a stronger check
11:48:13 <hololeap> jedai: thanks
11:48:17 <erisco> if you like the idea of three different types of closures then go on ;)
11:48:29 <maerwald> bbear: rust doesn't prove that your code is memory safe, it just enforces extremely conservative rules on you that mostly lead to memory safety. That's a pretty huge difference. But also offtopic
11:48:30 <bbear> yes but I think it is really a long term effort
11:48:43 <bbear> (I mean to learn haskell)
11:48:43 <ab9rf> this really isn't the place to discuss languages that are not haskell
11:48:51 <Tuplanolla> We'll see once you have met Rust's borrow checker, bbear.
11:48:56 <ertes> bbear: no buts…  yes or no?
11:49:05 <bbear> yes 
11:49:18 <ertes> bbear: then go ahead and learn it
11:49:21 <bbear> that's not the question
11:49:56 <bbear> everybody can go ahead -- the learning curve is just really steep.
11:49:59 <ertes> if haskell is the language you want to learn, then learn haskell…  there is no language that is "like haskell" and also practical
11:50:01 <duairc> lyxia: Thanks for hunting that down. That seems plausible alright.
11:50:01 <bbear> (for me I mean)
11:50:18 <ertes> the languages that try to come close to haskell are actually nothing like haskell
11:50:24 <maerwald> ertes: that's false
11:50:28 <bbear> i'm not looking for a replacement :p
11:50:31 <erisco> learn Miranda. it is practical for learning FP
11:50:31 <ertes> and those that do come close are usually not that practical
11:50:32 <maerwald> purescript is practical
11:50:42 <ertes> maerwald: and it's also nothing like haskell
11:50:48 <maerwald> it is
11:50:53 <ab9rf> bbear: haskell's learning curve isn't really that steep. it's more that it's UNLEARNING curve is a bit heavy: people have to unlearn a lot of folderol they learned in order to use imperative/procedural languages.
11:50:59 <ertes> similar syntax ≠ like haskell
11:51:05 <maerwald> I disagree
11:51:11 <Welkin> lol
11:51:20 <maerwald> on your definition of "like haskell"
11:51:23 <hololeap> miranda maybe?
11:51:30 <Welkin> I laugh when people say that Elm is like Haskell
11:51:37 <Tuplanolla> There's Gallina...
11:51:38 <Welkin> nothing alike at all
11:52:02 <Welkin> except for being in the ML language family
11:52:02 <ab9rf> i remember back when i was a CS TA spending oodles of time convincing people that "a = 2 * a" wasn't "illogical" and that "b = 2 * a" followed by "a = 7" didn't make b equal to 14
11:52:03 <ertes> ok, sorry, if we judge by syntax, purescript is probably like haskell…  and so is python
11:52:28 <kadoban> Python is like haskell? Why the whitespace stuff?
11:52:37 <bbear> Welkin: this is typically really your point of view, after reading a bit of Haskell, I find that Elm looks a lot like Haskell.
11:52:56 <Welkin> bbear: I have used elm quite a lot now and it has almost no similarities
11:52:59 <ertes> kadoban: i'm just trying to show how ridiculous it is to compare languages by syntax
11:53:02 <jedai> ertes: but purescript is actually pretty close, no ? What's the big difference ?
11:53:04 <Welkin> totally different language
11:53:08 <bbear> ab9rf: heu but it's illogical
11:53:08 <kadoban> ertes: Oh okay, fair enough.
11:53:18 <maerwald> the way they define "like haskell" you could just say "exactly haskell", so the point is useless
11:53:24 <jedai> ertes: records ?
11:53:28 <bbear> yes lol
11:53:36 <ertes> jedai: laziness for example
11:53:46 <ertes> concurrency
11:53:56 <erisco> if it isn't lazy then it isn't like Haskell
11:53:58 <ertes> and the fact that purescript targets JS exclusively
11:54:10 <ab9rf> quite a lot of my CS students came into intro CS thinking that "a = 2 * a" would make a equal to 0
11:54:12 <Welkin> suppoesdly purescript will soon target c++?
11:54:18 <jedai> ertes: Well okay for lazyness though concurrency is more a matter of runtime and libraries
11:54:28 <bbear> laziness is one strategy of evaluation, why would it be the central point in Haskell.
11:54:35 <bbear> ppl use the language, not the laziness
11:54:37 <ngWalrus> I might be completely off point but I think some of the issues with haskell's learning curve is that you have to learn quite a bit of stuff with scary looking names
11:54:41 <IngoB> speaking as someone used to C(++) and even Fortran, I think learning Haskell is difficult more because of enforcing a different point of view / approach to problem decomposition. can be a bit mind-bending. in all other ways it is really easier / simpler /quicker code to write
11:54:44 <ertes> jedai: would you say that IO is part of the language?
11:54:46 <erisco> but we do use the laziness all the time
11:54:47 <ab9rf> ngWalrus: you don't really
11:54:48 <Tuplanolla> How absolutely hilarious would it be if we had a language extension for C-like syntax?
11:55:00 <jedai> ertes: Not really, no
11:55:02 <Welkin> Tuplanolla: inline-c?
11:55:06 <ertes> bbear: i use laziness all the time
11:55:10 <ab9rf> Tuplanolla: i've thought about that
11:55:12 <Welkin> http://hackage.haskell.org/package/inline-c
11:55:24 <Tuplanolla> Isn't that actually C, Welkin?
11:55:26 <Welkin> yes
11:55:31 <bbear> you can use laziness in other language as well. It is just enforced in Haskell because the language is defined like that.
11:55:32 <ertes> jedai: then ok, but i would disagree, because you can only define IO primitively
11:55:34 <Tuplanolla> Then it's beside the point.
11:55:36 <lgstate> every day that I use clojure make me wish haskell's type system more
11:55:51 <Welkin> lgstate: there is typed clojure I thought
11:55:54 <bbear> you don't like clojure ?
11:55:54 <jedai> ertes: though it's certainly a core part of the standard library and it needs special support from the runtime to do what it does (you can still define IO, it just won't do any I/O)
11:56:03 <ab9rf> IngoB: i learned fortran before C :)
11:56:20 <lgstate> Welkin: core.typed is no where near ghc
11:56:32 <lgstate> bbear: clojure tooling is awesome, but so many of my bugs would have been caught by a type checker
11:56:34 <ertes> jedai: that's why i consider IO, and thus concurrency, part of the language
11:56:38 <IngoB> ab9rf: same, but I learned BASIC and Pascal before Fortran... 
11:56:40 <Welkin> lgstate: of course not
11:56:47 <erisco> in other languages it often leaks into the interface (or would have to)
11:56:53 <ab9rf> IngoB: same here, basic first, then pascal. fortran was #3.
11:57:01 <ertes> jedai: and yes, i do consider Int part of the language
11:57:06 <ngWalrus> ab9rf functors and monoids and monads sound scary to my ear. It might be just the unlearning process since I've mainly only written in imperative languages
11:57:10 <IngoB> ab9rf: and you are a physicist? ;-)
11:57:10 <erisco> you have to do manual thunking and evaluating
11:57:14 <ab9rf> no, wait, lisp and logo preceded fortran.
11:57:35 <ab9rf> ngWalrus: you don't need to learn any of those to become fairly proficient in Haskell
11:57:42 <erisco> you do not get lazy data structures
11:57:50 <erisco> it just isn't the same
11:57:52 <ab9rf> ngWalrus: i still don't fully understand monads and still manage to write haskell code that works
11:58:09 <ertes> in any case, all practical languages on the market are different from haskell in at least one fundamental way
11:58:14 <ertes> now PS is definitely inspired by haskell
11:58:16 <ngWalrus> from what I've read around you really just need to write haskell to get monads
11:58:26 <ngWalrus> and not compare them to jalapeno poppers
11:58:26 <ab9rf> ertes: by psyou mean powershell?
11:58:27 <ertes> it has a well designed standard library, it has beautiful syntax
11:58:32 <Welkin> ab9rf: lol
11:58:34 <ertes> ab9rf: purescript ;)
11:58:35 <Welkin> no, purescript
11:58:40 <lgstate> ngWalrus: to get monads, you need typeclasses, tco, and laziness is nice sometimes too
11:58:47 <ab9rf> ertes: ok, that is more tolerable of a statement
11:59:06 <jedai> ertes: Well, from your definition, clearly Haskell is the only Haskell :D
11:59:06 <ab9rf> ertes: powershell actually has haskell-based roots as wel, but it's a strange and tortuous relationship
11:59:15 <ab9rf> and powershell has the ugliest syntax of any language i've ever used
11:59:25 <ertes> jedai: indeed =)
11:59:26 <ngWalrus> powershell syntax is beautiful
11:59:31 <ertes> and that'S why bbear should learn haskell =)
11:59:34 <ngWalrus> beauty in unreadability
11:59:56 <bbear> yes but I can't remember 
11:59:57 <ertes> ab9rf: most modern MS things seem to have some roots in haskell…  just see C# =)
12:00:08 <IngoB> I used to program in Forth a bit, now that's a language where you can produce some really unreadable code...
12:00:13 <bbear> for example I want to structure my code into one main that would follow two options
12:00:26 <bbear> how is it something similar to argparse in Haskell ?
12:00:32 <bbear> how do I do the branching ?
12:00:34 <ertes> ab9rf: but they always introduce it in some awkward or even malformed way…  to the point that it's downright useless
12:00:42 <ab9rf> my wife writes a lot of powershell for her job, i'm really tempted to teach her haskell because she has a math background and would probably get haskell better, and with the conduit library mosto f her scripts would be faster, more consistently-behaved, and easier to express
12:00:46 <ertes> for example F# is supposed to support monads ("computation expressions")
12:00:48 <ertes> but it doesn't
12:00:54 <bbear> Can I read an input argument from the command line and open a file with that argument ?
12:00:58 <erisco> branching is done with case analysis, so case/of
12:01:16 <ab9rf> ertes: i tend to agree with you , which is why i keep coming back to haskell after going off to futz with some other language fora  while
12:01:22 <bbear> typically I would do main arg1 = blabla
12:01:25 <jedai> bbear: is that a real question ?
12:01:28 <bbear> main arg2 = blabla
12:01:32 <bbear> yes
12:01:37 <bbear> which one ?
12:01:41 <jedai> bbear: main doesn't take arguments
12:01:41 <ab9rf> ertes: e.g. my occasonal dalliances with scala, which i still use but only for modding minecraft
12:01:43 <bbear> they are all 
12:01:43 <ertes> the whole "F# has monads" thing is a lie, because like all .NET languages use the same core type system, which does not allow higher-kinded polymorphism
12:01:47 <bbear> jedai: so that's a problem.
12:01:50 <bbear> you see
12:01:58 <jedai> bbear: you use getArgs to get the arguments that were passed
12:02:05 <bbear> I usually thinks to main as a function that will take arguments
12:02:16 <ab9rf> yeah, scala has simialr issues, its forced dependency on the JVM locks it into the JVM's type system
12:02:29 <bbear> yes, but how do you do the branching ?
12:02:30 <jedai> bbear: there are good command line parsing and dispatching libraries
12:02:44 <ertes> and the same can be said about C#:  LINQ is *not* "monads"…  not the way haskell has monads
12:02:49 <jedai> bbear: by ... branching as usual
12:02:55 * hackagebot natural-transformation 0.4 - A natural transformation package.  https://hackage.haskell.org/package/natural-transformation-0.4 (ryanglscott)
12:02:57 <bbear> it looks imperative
12:03:13 <ab9rf> you can write imperative-looking code in haskell, it's actually really easy 
12:03:19 <bbear> in the end I am always stuck with the same problems without knowing how to solve them
12:03:28 <ertes> bbear: then ask here
12:03:37 <erisco> bbear, http://learnyouahaskell.com/chapters
12:03:42 <jedai> bbear: it's not like you magically lose the capacity to use if then else or case of (neither are anything imperative) just because you got your values with getArgs rathen than as an argument
12:03:43 <Welkin> bbear: then learn it correctly by going through the course
12:03:46 <Welkin> @where learnhaskell
12:03:47 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:03:47 <maerwald> not every language needs monads, calm down
12:04:05 <ab9rf> maerwald: but then where will we get our burritos?
12:04:44 <jedai> bbear: I don't get your problem, if you don't know how to do branching with if then else or case of, you really shouldn't be writing a real program in Haskell
12:04:48 <erisco> if/then/else in languages like C is imperative. In Haskell it is not
12:04:54 <ertes> sorry…  i had to work with both C# and F#…  i hated it =)
12:05:09 <bbear> ha yes I was stuck in that tutorial
12:05:23 <ertes> erisco: _?_:_ is not imperative either in C-like languages
12:05:40 <grantwu> You can have side effects in expressions
12:05:43 <ertes> if/then/else in those doesn't really correspond to if/then/else in haskell
12:05:46 <erisco> ertes, I agree
12:05:51 <erisco> bbear, see http://stackoverflow.com/a/40132517/260584
12:05:54 <jedai> bbear: Note that if/then/else can't miss an else branch (because it has to return a value, since the branch are not statement but expression and the whole if/then/else is an expression
12:06:16 <ertes> but i wonder why we're explaining that to bbear =)
12:06:21 <ab9rf> ertes: i once saw a guy write a condition return statement in C++ using ?: and setjmp/longjmp
12:06:33 <ab9rf> actually in C, but same diff
12:06:52 <jedai> ab9rf: Burn the heretic !! ;)
12:07:03 <ertes> ab9rf: i bet i can do the same in haskell using if/then/else and ContT ;)
12:07:04 <ab9rf> i had to wipe coffee off m y monitor
12:07:18 <ab9rf> ertes: yes, and it would be easier to understand in haskell :)
12:07:19 <jedai> ab9rf: I think that would have been my reaction too :)
12:07:29 <IngoB> bbear: I recommed http://haskellbook.com if you want to learn haskell fairly from scratch, it's much more extensive and slower-paced than most online tutorials. I'm learning from that book myself
12:07:50 <ngWalrus> haskellbook is pretty nice even if you know programming
12:07:53 <ertes> ab9rf: would it?  setjmp/longjmp as an abstraction is basically a special case of ContT =)
12:07:53 <Tuplanolla> How about a file including itself with different `define`s to simulate multipass compilation, ab9rf?
12:07:56 * hackagebot hscaffold 0.4.5.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.4.5.0 (yamadapc)
12:08:07 <IngoB> bear: you can download chapters 2, 3 and 4 for free from that website, to check it out.
12:08:15 <ab9rf> ertes: sure, i actually wrote an article about how his evilness leads to the concept of coroutines
12:09:04 <ertes> ab9rf: honestly?  i've used setjmp/longjmp to work around C's lack of exceptions in the past
12:09:30 <ab9rf> ertes: that's the more common use-case for setjmp, but you can use it to implement coroutines as well (a lot of discipline is required to make it work)
12:09:49 <geekosaur> except these days ucontext is safer
12:10:12 <ab9rf> ertes: iirc some early scheme compilers used setjmp/longjmp to implement continuations.
12:10:21 <bbear> ok
12:10:59 <geekosaur> we used to use it for green threads back in the day
12:11:06 <ab9rf> you have provlems with stack collisions, though
12:11:31 <ab9rf> geekosaur: that makes sense as well
12:12:08 <jedai> bbear: Anyway, if you wanted to do a small script that needed to branch depending on its arguments, you would just get them with getArgs then do case args of ... -> ... ; ... -> ...
12:12:24 <lgstate> what is the symbol name for @ ?
12:12:29 <lgstate> wrong channel sorry
12:12:31 <ab9rf> bbear: i've written plenty of haskell code that reads command line args with getargs and then does things on the result
12:12:33 <bbear> when you do main = do bla 
12:12:56 <bbear> you can't escape from the do block, you have to go to the end, right ?
12:12:59 <jedai> bbear: in a complex command line argument handling situation you would use a specialized library (they do much more than just the dispatching too)
12:13:08 <ab9rf> bbear: "escape from the do block"? what does that mean?
12:13:21 <bbear> I mean your main function is monolithic
12:13:21 <erisco> read the section on do-notation in your book
12:13:30 <erisco> your question is wrong
12:13:32 <ab9rf> bbear: monolithic?
12:13:49 <ab9rf> you have a single main function, but that's true in every language i've ever u sed
12:13:51 <IngoB> does anybody know of any decent ODE (ordinary differential equation) solvers written natively in haskell?
12:14:12 <ab9rf> IngoB: symbolic or numeric?
12:14:17 <IngoB> numeric
12:14:22 <jedai> bbear: main = do
12:14:22 <jedai>   args <- getArgs
12:14:22 <jedai>   case args of
12:14:22 <jedai>     ("something": otherArgs) -> doSomething ...
12:14:22 <jedai>     ("anotherThing":otherArgs) -> doSomethingElse ...
12:14:26 <ab9rf> hrm, not really aware of one
12:14:38 <bbear> http://lpaste.net/339803
12:14:42 <bbear> that thing work :)
12:15:10 <bbear> hey, I have a question
12:15:18 <jedai> bbear: Right, you don't even need the return ()
12:15:28 <ab9rf> yeah, putstrLn has the appropriate type
12:15:30 <bbear> let's say I want to read a file byte by byte, and work out each byte, how would I do it ?
12:15:31 <IngoB> ab9rf: well, that's going to be my haskell project then, i guess, once i finish learning
12:15:55 <jedai> bbear: You should really use ByteString in this case
12:16:08 <ab9rf> bbear: "work out each byte"? 
12:16:28 <bbear> actually I want to do huffman coding
12:16:33 <maerwald> bbear: I have done that, it's more annoying than in C
12:16:33 <ngWalrus> IngoB  but why wait
12:16:48 <jedai> bbear: https://hackage.haskell.org/package/bytestring-0.10.8.1
12:16:49 <bbear> so I have to update a dict each time I read a byte.
12:16:55 <bbear> to count the occurences of each char 
12:16:56 <ab9rf> state
12:17:03 <bbear> which library would you use ?
12:17:34 <bbear> I mean which data structure, etc
12:17:34 <ab9rf> bbear: actually that's just a fold over the bytestream
12:17:34 <bbear> ab9rf yes
12:17:52 <ab9rf> you ahve a funciton Byte -> Counter -> Counter
12:17:54 <IngoB> ngWalrus: huh? why learn a language before writing a library in it?
12:17:59 <jedai> maerwald: I'm not sure I agree, Huffman coding is marvelously encoded as a fold
12:18:05 <ab9rf> fold that over the bytestream with an empty counter and the result is a fully counted stream
12:18:12 <bbear> Byte -> Counter -> Counter, ok...
12:18:28 <maerwald> jedai: I'm not talking about huffman
12:18:30 <bbear> would you be recursive ?
12:18:37 <ab9rf> bbear: the fold provides the recursion
12:18:45 <bbear> ah yes
12:18:56 <bbear> you do fold countByte ByteStream and it's over
12:19:07 <ab9rf> bbear: pretty much
12:19:08 <bbear> that's what you meant ?
12:19:18 <bbear> ok
12:19:35 <ab9rf> i'd have to look up some library specifics but yeah
12:19:37 <jedai> maerwald: reading the file ? you can do it exactly like in C with ByteString. Of course you would really hope you can do better (which is where the various powerful but complex streaming library come in play)
12:20:13 <bbear> but how would you do to have that ByteString object that you could lazily take into until it's empty ?
12:20:38 <bbear> and for the DataStructure, I would use a naive list
12:20:48 <ab9rf> i'd probably use a map
12:20:50 <bbear> but A map should be much better although non standard
12:21:03 <bbear> and how could I keep this map sorted ?
12:21:04 <maerwald> jedai: I know how to do it, since I've done it in both languages
12:21:36 <ab9rf> what's nonstandard about a map?
12:22:58 <IngoB> anyway, thanks and CU
12:23:30 <bbear> that's non standard Haskell :p
12:23:37 <bbear> i mean it's not in the std lib
12:23:48 <bbear> but I read they are made out of binary trees.
12:23:56 <bbear> binary hash map are kewl
12:24:07 <kadoban> Has Int always been at least 32 bits (31 for magnitude) in GHC, at least since GHC 7.8?
12:24:29 <drninjabatman> hello
12:25:07 <drninjabatman> is there a way to use LiberalTypeSynonyms with type families?
12:25:37 <jedai> bbear: Data.Map is definitely in "the standard lib", though not in the Prelude, it comes with GHC
12:26:47 <bbear> binary hash map are self contradictories
12:26:55 <bbear> it's binary map or hash map
12:28:20 <drninjabatman> for example `type family X a` and `type instance X Int = forall a b. (a,b,Int)`
12:28:44 <ab9rf> bbear: i can write the counting function in a single :)
12:28:49 <ab9rf> single line :)
12:28:57 <bbear> That's what I do actually
12:29:02 <bbear> but I would like a map
12:29:11 <ab9rf> > foldl (\m c -> M.insertWith (+) c (1::Int) m) M.empty "aabbcc"
12:29:14 <lambdabot>  fromList [('a',2),('b',2),('c',2)]
12:29:29 <ab9rf> that yields a map
12:30:19 <bbear> talk of esoterics
12:30:26 <ab9rf> there's nothing esoteric in that
12:30:33 <bbear> of course if you understand it
12:30:48 <ab9rf> it's foldl, a simple lambda, and a few very standard functions from Data.Map
12:31:02 <bbear> what is this \m c
12:31:13 <ab9rf> bbear: an anonymous function
12:31:13 <bbear> you could have wrote \k v for key, value
12:31:13 <maerwald> please read a tutorial
12:31:51 <jedai> bbear: m was for a map and c for a character...
12:31:52 <erisco> m is for map, c is for character
12:32:10 <ab9rf> bbear: see, jedai figured out my variable choices, even though i didn't explain them
12:32:12 <bbear> why the M
12:32:23 <erisco> import qualified Data.Map as M
12:32:29 <ab9rf> because lamdbabot imports Data.Map squalified as M
12:32:32 <jedai> bbear: that's only because lambdabot import Data.Map qualified as M
12:32:37 <jedai> arg :)
12:32:42 <bbear> why the keyword qualified ?
12:33:09 <geekosaur> apparently this channel is the only tutorial
12:33:13 <ab9rf> bbear: because that's haskell syntax, and because lambdabot wants to keep its main namespace free of conflicts from the many other modules it also imports
12:33:16 <jedai> bbear: that allows to define a shortcut for the name of a module to disambiguate functions from several modules that have the same name
12:33:21 <bbear> i told you there's too much to learn 
12:33:29 <ab9rf> bbear: obviously not, since all of us learned it
12:33:50 <jedai> bbear: Yeah right, because no other language has any kind of namespace handling....
12:34:53 <jedai> bbear: Sure learning Haskell can be daunting but certainly not because of the syntax (or only if this is your first language)
12:35:06 <ab9rf> the most "esoteric" thing in all of that is the (1::Int), which is used to force a specific tytpe for the map
12:35:09 <grantwu> Haskell's imports is far saner than, say, Python's
12:35:14 <grantwu> At least in my opinion
12:35:18 <bbear> i don't know I don't want to criticize anyone I m my better enemy as they say.
12:35:47 <bbear> yes, 1::Int is cryptic, I don't really understand it
12:35:54 <ab9rf> it's probably not necessary (in fact, it's not), but i've had bad experiences with haskell's polymorphic integers and thus often force their types
12:36:02 <bbear> And I suppose I don't read types well.
12:36:12 <ab9rf> :t foldl (\m c -> M.insertWith (+) c (1) m) M.empty "aabbcc"
12:36:15 <lambdabot> Num a => M.Map Char a
12:36:15 <jedai> bbear: 1 is a integral literal
12:36:17 <bbear> :t M
12:36:19 <lambdabot> error: Data constructor not in scope: M
12:36:27 <ab9rf> > foldl (\m c -> M.insertWith (+) c (1) m) M.empty "aabbcc"
12:36:29 <lambdabot>  fromList [('a',2),('b',2),('c',2)]
12:36:40 <ab9rf> turns out it works without being forced
12:36:44 <jedai> bbear: they're polymorphic because 1 can as well be a Float, Double, Int, Integer, Complex and so on
12:37:07 <bbear> so M.empty is the empty map
12:37:10 <ab9rf> bbear: yes
12:37:20 <bbear> and the lambda insertWith is what increments the counter.
12:37:41 <ab9rf> bbear: insertWith updates the map. it inclrements it becuase i told it to use (+)
12:38:04 <ab9rf> i used insertWith because insertWith uses an update function if the key is found, and an insert if the key is not found, which yields the desired semantics here
12:38:05 <bbear> yes
12:38:05 <jedai> bbear: well the (\...) is an anonymous function that takes two arguments, a Map m and a Char c
12:38:23 <bbear> the (+) is weird also... I read something about it long time ago but it is actually a function
12:38:23 <jedai> bbear: it uses insertWith to return a map with updated counters
12:38:23 <ab9rf> i could have written that in pointless form if i had wanted
12:38:31 <ab9rf> @pl \m c -> M.insertWith (+) c 1
12:38:31 <lambdabot> const (flip (M.insertWith (+)) 1)
12:38:39 <bbear> because :t (+) is a->a->a->
12:38:47 <ab9rf> :t (+)
12:38:49 <lambdabot> Num a => a -> a -> a
12:39:02 <jedai> bbear: it tries to insert 1 for c but if c already is in the map it will add 1 to the count that is already there
12:39:15 <ab9rf> i tend to use expicit lambdas instead of pointless forms because pointless forms are often FAR less explicit
12:39:38 <bbear> what do you mean pointless forms
12:39:45 <jedai> bbear: all operators are functions, they just have a special syntax that allow them to be applied infix
12:39:49 <bbear> I was confused by the \x y -> x*y
12:40:09 <bbear> ah yes so you could write (+) 1 2 == 3 it would be True
12:40:17 <jedai> > (+) 1 2 == 3
12:40:20 <lambdabot>  True
12:40:25 <bbear> ha ok
12:40:30 <maerwald> these are fundamental basics, there are tutorials for that
12:40:33 <bbear> things start to make sense again
12:41:41 <ab9rf> > foldl (\m c -> M.insertWith (:) c [c] m) M.empty "aabbcc"
12:41:44 <lambdabot>  error:
12:41:44 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
12:41:44 <lambdabot>        Expected type: [Char] -> [Char] -> [Char]
12:41:51 <ab9rf> feh, blew the types
12:42:02 <jedai> ab9rf: flip ?
12:42:18 <ab9rf> jedai: could be
12:42:37 <jedai> > foldl (\m c -> M.insertWith (flip (:)) c [c] m) M.empty "aabbcc"
12:42:40 <lambdabot>  error:
12:42:40 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
12:42:40 <lambdabot>        Expected type: [Char] -> [Char] -> [Char]
12:43:00 <jedai> > foldl (\m c -> M.insertWith (++) c [c] m) M.empty "aabbcc"
12:43:03 <lambdabot>  fromList [('a',"aa"),('b',"bb"),('c',"cc")]
12:43:14 <jedai> ab9rf: not flip ... :(
12:43:19 <ab9rf> jedai: so i gathered :)
12:44:29 <ab9rf> bbear: you really should spend some time with a tutorial and a running ghci REPL
12:44:39 <ab9rf> all of this is really basic syntax and concepts
12:45:25 <erisco> pointed expressions feel like duct tape
12:46:42 <erisco> both the worst and the best expressions are found in pointfree form
12:46:54 <ab9rf> i use pointfree when i can
12:47:08 <ab9rf> and i often generate pointfree expressions after finding a pointed one that works
12:47:28 <ab9rf> sometimes the pointfree makes sense or reveals a structural feature i hadn't noticed 
12:47:35 <ab9rf> or exposes an opportunity to generalize
12:47:51 <ab9rf> other times, not so much
12:47:56 <erisco> lambdabot's @pl often makes a mess
12:48:18 <jle`> yeah, point-free code is usually harder to readthan pointful code.  the situations where writing point-free helps is the extreme minority
12:48:39 <erisco> the thing with pointfree is you need more combinators for more situations
12:49:01 <erisco> if you want it to be concise and clear, which is when it is useful
12:49:08 <jle`> the cases where point-free makes things easier to read/helps you understand the code better exist, but are by far outnumbered many times where it makes things worse
12:49:31 <ab9rf> i'll shove a lambda into pl and if what comes out is ugly, i just go "feh" and go awy
12:49:51 <ab9rf> sometimes it comes out nice though
12:49:54 <jle`> kind of like how almost no real numbers are integers
12:49:56 <jle`> but some of them are
12:50:15 <ab9rf> and the process of putting external references to values that @pl doesn't know about yields a better function
12:51:22 <ab9rf> e.g \x y -> ... f .. .g ... becames \f g x y -> ... f ... g .. and sometimes the process of making those free references into arguments makes for better code in the end
12:51:24 <ggVGc> the best part about point free is how many points there are
12:51:53 <erisco> jle`, there are not *that* many expressions ;)
12:52:21 <jle`> (;
12:52:26 <erisco> putting expressions into pointfree form is good exercise
12:52:28 <erisco> I do it frequently
12:52:53 <jle`> i do it for fun too, but i don't pretend that it makes my code any more readable :3
12:52:58 * hackagebot servant-auth-cookie 0.4.1 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.4.1 (zohl)
12:53:29 <jle`> (not saying that you do, ofc)
12:54:00 <erisco> I just say you can find both the best and worst code in pointfree form
12:54:43 <delYsid> > harmonicMean = uncurry (/) . foldr (((1 +) ***) . (+) . recip) (0, 0)
12:54:45 <lambdabot>  <hint>:1:14: error:
12:54:46 <lambdabot>      parse error on input ‘=’
12:54:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:00:47 <Skull> Hii
13:01:24 <mmaruseacph2> hi
13:03:52 <erisco> delYsid, with the appropriate Num instance maybe you can use  curry (const 1 + snd *** recip . fst + snd)
13:04:36 <Guest42298> Any interesting gossips about dark web??
13:04:43 <erisco> I think I screwed something up in there but the idea shouldn't change much
13:05:02 <kadoban> Guest42298: Not really on topic here
13:05:12 <Guest42298> Ohkk
13:05:31 <osfameron> I always just go to random channels to talk about whatever's interesting to me
13:05:38 <osfameron> Guest42298: talk to me about giraffes!
13:05:46 <Tuplanolla> There's #haskell-offtopic.
13:05:53 <Guest42298> Giraffes are tall
13:06:05 <Guest42298> 😂
13:06:11 <geekosaur> are people seeing "hackage" in the topic and thinking it relates to hacking? sigh
13:06:15 <Guest42298> What you think??
13:06:22 <Guest42298> Nahh
13:06:37 <erisco> did some sick hackage last night
13:06:51 <osfameron> certainly #hackspace get lots of that
13:07:34 <Tuplanolla> If only his name had been Hackell Curry...
13:08:13 <bbear> for how many times have you been Haskell coders ?
13:08:19 <erisco> Cackle Hurry
13:08:48 <erisco> quite a few… 3:00 o'clock, 4:00 o'clock, many times
13:09:20 <jedai> bbear: Haskell was first defined by a commitee in 1989 I think
13:09:22 <osfameron> there's a witticism (of Larry Wall's I think) along lines of "Haskell is easy to learn! I should know, I've learnt it 5 times now!"
13:09:46 <jedai> bbear: but it lacked many of its characteristics at the time
13:10:24 <delYsid> orion: Num ((c, c) -> c), Num ((a, c) -> c)?
13:10:41 <jedai> bbear: The Haskell 98 standard should probably be considered the start of the "modern" period of Haskell (but it still has evolved a lot since then)
13:10:50 <delYsid> er, erisco ^
13:10:55 <maerwald> jedai: actually it hasn't changed that much
13:10:59 <bbear> s/times/time
13:10:59 <maerwald> GHC != haskell
13:11:42 <jedai> maerwald: True. So Haskell as used by major libraries has grown quite a bit since the Haskell 98 standard (though it's still very close)
13:12:18 <erisco> delYsid, yeah
13:13:02 <jedai> maerwald: Plus you have to consider the growth of the standard libraries and library ecosystem too (yes I know that's not really the language but it certainly impact Haskell development)
13:13:34 <maerwald> you were talking about the standard, so I was assuming you mean the language, not the community
13:14:37 <jedai> maerwald: Well I intended the standard more as a landmark of Haskell evolution as a whole than just as a discussion of the language standard itself
13:15:43 <erisco> delYsid, functions are containers, you can stick a thing in them with const and get it out with $
13:15:48 <erisco> delYsid, you can put numbers in them
13:16:14 <jedai> bbear: mmmhhh did you mean "For how long have you been Haskell coders ?" as a personal question ? Then a few year for me (though that's not my focus, I'm not even programming as my job, I'm teaching)
13:16:29 <bbear> okay
13:16:43 <bbear> my english is poor but my tailor is rich.
13:17:46 <erisco> teaching programming?
13:18:36 <jchia_3> lyxia: Thanks
13:18:40 <Tuplanolla> My answer is identical to jedai's.
13:19:10 <jedai> erisco: math mainly, though I have been teaching programming (in a very limited fashion, to high-school students) recently
13:19:51 <erisco> sans a comp sci teacher they grab a math teacher
13:20:54 <jedai> erisco: In my country (France) CS teaching in high-school is very often delegated to math teachers (most of which have no idea whay they're doing)
13:21:16 <erisco> same here in Canada
13:21:46 <erisco> they've taken a course in BASIC
13:23:02 <jchia_3> lyxia: Thanks, doesn't seem to work, though. "No instance for (Static (Serializable Int)) arising from ..." I found an answer on r/haskell, though.
13:23:16 <erisco> in Star Trek they grab a handyman… it could be worse :P
13:23:20 <ab9rf> osfameron: i've definitely "learned" haskell at least three times now
13:23:51 <osfameron> ab9rf: yeah.  I'm probably up to half a dozen or so.  I learn a *bit* more each time :D
13:24:29 <jedai> erisco: Sure, they could ask the biology teachers to do it !! o_O 
13:24:41 <ab9rf> jedai: that might not be worse.
13:25:01 <ksj> my math teather was a computer scientists and then we got a chemical engineer
13:25:06 <bbear> oh Jedai you are from France ?
13:25:11 <ksj> but the first one actually talked about programming
13:25:13 <ab9rf> they might have no programming experience at all, instaed of having only a course in Dartmouth BASIC
13:25:22 <bbear> I learnt programming with BASIC
13:25:26 <bbear> crippling
13:25:37 <bbear> Everybody should start with Haskell in the Craddle
13:25:55 <jedai> ab9rf: Most biology teachers are not very logic oriented (sadly because understanding and being clear on evolution require a clear mind)
13:26:16 <jedai> ab9rf: Beside of course they would get the Basic course !! 
13:26:36 <ab9rf> jedai: well, today probably. when i was in HS, though, most likely not.
13:26:42 <ab9rf> but i'm an old fart
13:26:44 <jedai> ab9rf: You don't change a team that ... win ?
13:27:33 <bbear> I even got the teaching certificate as they call it.
13:27:42 <ab9rf> i would love to see a correlation between first programming language and age
13:27:53 <bbear> what could it be
13:27:58 <ab9rf> at what point does it become BASIC, and then stop being BASIC
13:28:09 <dibblego> both my children started with haskell, and they both now write open source
13:28:12 <bbear> I suppose it would look like Basic -> C / C++ -> Java -> Python
13:28:14 <jedai> ab9rf: Maybe, I wouldn't know being so very young... (well I'll keep telling myself that). Biology is the field with the most problems in studies and reproductibility (of experimental science) though
13:28:30 <erisco> dibblego, I'm sorry
13:28:34 <bbear> reproductibility is not what matters most I believ in Biology
13:28:40 <kadoban> dibblego: Nice
13:28:41 <dibblego> erisco: ok
13:28:51 <ab9rf> i would think that biology is all about reproducibility :)
13:28:54 <bbear> if it was the point, then it would be bio chemistry
13:28:56 <jedai> bbear: It damn well should !!!
13:28:58 <dibblego> I am doing NICTA/course in Canberra at the moment. They haven't done that.
13:28:58 <ab9rf> but i digress
13:28:58 <bbear> or even physics
13:29:32 <jedai> bbear: if you can't reproduce your experiment that shows the viability of your new treatment, I shouldn't have to try it for you....
13:29:33 <bbear> jedai: i don't really agree for fundamental reasons , laws of life and evolution 
13:29:33 <MarcelineVQ> ab9rf: heu :>
13:30:02 <ab9rf> i definitely do not want to turn this into a discussion of the relative epistemologies of the various sciences, that will only lead to flamewars and is horribly off-topic
13:30:06 <bbear> jedai: all medication I believe are known to have secondary effects and to be not predictible in small set of the population
13:30:32 <Tuplanolla> That's just dandy.
13:31:00 <jedai> bbear: sure but you have to hope that the studies was well documented, the methodoloy impecable (and thus reproducible) and the results statistically significant
13:31:08 <jchia_3> lyxia, I think it's "cpure $cdict (1 :: Int)"
13:31:18 <bbear> oh yes, of course. But correlation is not causality as they said
13:31:30 <jedai> bbear: I'm not speaking about the current state of the discipline here (sadly), I'm speaking about what it should be
13:31:46 <ab9rf> someone is going to have to start waving the topic stick soon
13:32:25 <bbear> nah dont bother 
13:32:48 <jedai> ab9rf: Well it started with a discussion about CS teaching in high-school... :)
13:32:55 <ab9rf> jedai: which is already off-topic
13:33:02 <jedai> ab9rf: Right ;)
13:33:22 <Tuplanolla> I don't mind as long as you don't displace topical discussions.
13:33:36 <erisco> so… see any good type sigs lately?
13:34:16 <Tuplanolla> Here's one: `(Monoid a, Traversable f) => (a -> a -> b) -> f a -> f b`
13:35:03 <erisco> adjacent pairs, overlapping pairs, or what?
13:36:02 <jedai> erisco: Note that b is not a Monoid.... I'm intrigued
13:36:07 <erisco> Monoid a   is mysterious
13:36:43 <jedai> Though I guess it's f b
13:36:46 <Tuplanolla> @let withMax f = fmap (join bimap getMax) . f . fmap Max
13:36:48 <lambdabot>  .L.hs:163:30: error: Variable not in scope: getMax :: c -> d
13:36:48 <lambdabot>  
13:36:48 <lambdabot>  .L.hs:163:49: error:
13:37:09 <Tuplanolla> @let import Data.Max
13:37:09 <lambdabot>  .L.hs:105:1: error:
13:37:10 <lambdabot>      Failed to load interface for ‘Data.Max’
13:37:10 <lambdabot>      Perhaps you meant
13:37:57 <Tuplanolla> I was going to demonstrate, but lambdabot is sucking again.
13:38:46 <Tuplanolla> @let withSum f = fmap (join bimap getSum) . f . fmap Sum
13:38:48 <lambdabot>  Defined.
13:39:08 <Tuplanolla> > zippendWith `withSum` [1, 8, 1, 5, 2, 3]
13:39:10 <lambdabot>  error:
13:39:10 <lambdabot>      • Couldn't match type ‘[Sum Integer]’ with ‘t1 -> t1 -> Sum a’
13:39:10 <lambdabot>        Expected type: [Sum Integer] -> p (Sum a) t1 -> p (Sum a) (Sum a)
13:39:30 <Tuplanolla> > zippendWith (,) `withSum` [1, 8, 1, 5, 2, 3]
13:39:33 <lambdabot>  [(20,1),(20,8),(20,1),(20,5),(20,2),(20,3)]
13:39:52 <Tuplanolla> There we go.
13:40:21 <jedai> :t zippendWith
13:40:23 <lambdabot> (Monoid t1, Traversable t) => (t1 -> t1 -> c) -> t t1 -> t c
13:42:20 <erisco> > zippendWith (,) [1..10]
13:42:23 <lambdabot>  error:
13:42:23 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M319657819064...
13:42:23 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
13:43:00 <erisco> > zippendWith (,) ["foo","bar","qux"]
13:43:03 <lambdabot>  [("quxbarfoo","foo"),("quxbarfoo","bar"),("quxbarfoo","qux")]
13:43:12 <jedai> > zippendWith (,) (fmap Sum [1..10])
13:43:15 <lambdabot>  [(Sum {getSum = 55},Sum {getSum = 1}),(Sum {getSum = 55},Sum {getSum = 2}),(...
13:44:01 <Tuplanolla> I defined `withSum` just to get rid of that noise.
13:44:04 <kuribas> Is there a traverse with state?
13:44:24 <jedai> Ok... could you provide a usecase ?
13:44:50 <glguy> :t alaf StateT traverse
13:44:53 <lambdabot> (Traversable t, Monad m') => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
13:44:54 <MarcelineVQ> kuribas: like mapAccumR ?
13:45:03 <kuribas> :t mapAccumR
13:45:04 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:45:40 <jedai> kuribas: what do you mean ? like forM in the State monad ?
13:46:10 <kuribas> jedai: like iterating over values with state, then performing an action for each one
13:46:29 <Welkin> kuribas: mapM
13:46:53 <jedai> kuribas: action ? IO action ? then StateT IO or simply IO with an IORef should work
13:47:00 <kuribas> jedai: yeah, IO action
13:48:38 <jedai> kuribas: or maybe foldM
13:49:13 <jedai> right, foldM seems a good bet for something quite simple that can pass state along
13:49:18 <kuribas> :t foldM
13:49:19 <jedai> :t foldM
13:49:19 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
13:49:20 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
13:49:44 <mmaruseacph2> jinx
13:49:55 <kuribas> jedai: that may be it...
13:50:31 <kuribas> :t foldM_
13:50:33 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
13:51:23 <kuribas> :t scanlM
13:51:25 <lambdabot> error:
13:51:25 <lambdabot>     • Variable not in scope: scanlM
13:51:25 <lambdabot>     • Perhaps you meant one of these:
13:53:35 <glguy> :t alaf Kleisli traverse
13:53:37 <lambdabot> (Traversable t, Applicative (Kleisli m' a')) => (a -> a' -> m' b') -> t a -> a' -> m' (t b')
13:53:52 <mmaruseacph2> :t alaf
13:53:56 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
13:54:06 <glguy> :t auf
13:54:08 <lambdabot> Optic (Data.Profunctor.Types.Costar f) g s t a b -> (f a -> g b) -> f s -> g t
13:54:16 <Tuplanolla> What is this nonsense, glguy?
13:54:16 <mmaruseacph2> :i Costar
13:54:17 <glguy> alaf is a shortcut for auf
13:54:21 <kuribas> @hoogle Traversable t => (a -> b -> m (a, c)) -> a -> t b -> m (a, t c)
13:54:25 <lambdabot> Data.Functor.Fixedpoint hyloM :: (Traversable f, Monad m) => (f b -> m b) -> (a -> m (f a)) -> (a -> m b)
13:54:25 <lambdabot> Control.Lens.Traversal sequenceBy :: Traversable t => (forall x . x -> f x) -> (forall x y . f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)
13:54:25 <lambdabot> Data.Reflection sequenceBy :: Traversable t => (forall x . x -> f x) -> (forall x y . f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)
13:54:47 <glguy> kuribas: I pasted that one earlier
13:54:54 <glguy> :t alaf StateT traverse
13:54:56 <lambdabot> (Traversable t, Monad m') => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
13:55:07 <kuribas> glguy: right :)
13:55:11 <kuribas> glguy: what's alaf?
13:55:12 <glguy> that'd be mapAccumLM
13:55:23 <kuribas> :t mapAccumLM
13:55:24 <Tuplanolla> Now it makes sense.
13:55:25 <lambdabot> error:
13:55:25 <lambdabot>     • Variable not in scope: mapAccumLM
13:55:25 <lambdabot>     • Perhaps you meant one of these:
13:55:27 <glguy> scanlM would be more like: alaf Kleisli traverse
13:55:35 <kuribas> :t alaf
13:55:37 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
13:55:50 <glguy> mapAccumLM is what I'd expect that operation to be called on its own, but that isn't defined anywhere standard
13:55:51 <Tuplanolla> Up to `lens`.
13:56:42 <glguy> alaf _ traverse   let's me run traverse on a transformed type selected by the constructor I provide in the missing argument
13:57:01 <glguy> instead of manually wrapping and unwrapping the newtype
13:57:34 <Tuplanolla> :t alaf Identity traverse
13:57:36 <lambdabot> Traversable t => (a -> b) -> t a -> t b
13:57:51 <Tuplanolla> Is this just `fmap`?
13:57:57 <kuribas> glguy: is alaf something from lens?
13:58:13 <glguy> Yeah, that's where it's defined
13:58:36 <mmaruseacph2> it has Optic in it's type signature so it's most likely from there
13:59:10 <MarcelineVQ> alaf is from Control.Lens.Wrapped iirc
14:00:02 <Tuplanolla> Is it some sort of play on "à la functor"?
14:00:10 <glguy> It's not doing anything particularly complicated: alaf StateT traverse   is   \f x -> runStateT (traverse (StateT . f) x)
14:00:34 <glguy> the typeclasses just allow it to lookup the constructor and accessor for StateT by type
14:01:36 <jle`> yeah, i wouldn't call it a lens thing as much as a typeclass thing
14:05:13 <erisco> Tuplanolla, join . (fold ~> fmapDefault)
14:06:02 <MarcelineVQ> did any of that help with your problem kuribas?
14:06:10 <kuribas> MarcelineVQ: yeah
14:06:35 <kuribas> MarcelineVQ: foldM will work, since I don't need the return value.
14:06:39 <kuribas> erm foldM_
14:06:54 <kuribas> :t \f x -> runStateT (traverse (StateT . f) x)
14:06:56 <lambdabot> (Traversable t, Monad m) => (a -> s -> m (b, s)) -> t a -> s -> m (t b, s)
14:08:34 <kuribas> I could use that without the alaf
14:09:01 <erisco> or (id ~> join) (fold ~> fmapDefault)
14:11:00 <Tuplanolla> I still haven't achieved lens satori.
14:11:07 <johnw> lol
14:11:26 <johnw> is that lens that locates the self within mind?
14:11:29 <kuribas> Tuplanolla: I finally understood lenses are actually traversals.
14:11:55 <johnw> how are lenses traversals?
14:12:23 <kuribas> well, _like_ traversals
14:12:27 <erisco> Tuplanolla, I didn't use lens ^.^ though maybe a precursor to it
14:12:32 <kuribas> for a single element
14:12:43 <Welkin> erisco: is that a face or a lens operator?
14:12:44 <johnw> right, they specialize traversals to one specific case :)
14:12:55 <Koterpillar> erisco: careful with these smileys, you'll accidentally reference some operator in lens
14:12:59 <erisco> Welkin, I had the same thought oO
14:13:30 <hvr> ...that's when you know you have been using lenses too much ;)
14:13:32 <kuribas> johnw: and a prism is a traversal for zero or one elements.
14:14:18 <johnw> right
14:14:30 <johnw> and a fold is a traversal that only "gets"
14:14:39 * hvr wonders if there's the equivalent of NonEmpty traversals
14:15:01 <dolio> Yes.
14:15:12 <hvr> dolio: which one is it?
14:15:24 <dolio> Oh, you mean defined in lens?
14:15:25 <glguy> It's not named in the lens package
14:15:29 <hvr> dolio: yep
14:16:13 <jle`> hvr: it's just a Traversal but only with an Apply constraint instead of an Applicative constraint, probably
14:16:14 <dolio> They'd be what you get if you added a pre-Applicative without pure.
14:16:22 <erisco> Tuplanolla, I started with the fairly obvious  \f -> fmapDefault . f . fold <*> id   and simplified
14:16:34 <glguy> http://hackage.haskell.org/package/semigroupoids-5.1/docs/Data-Functor-Apply.html#g:2
14:16:41 <jle`> type NonEmpty s t a b = forall f. Apply f => (a -> f b) -> (s -> f t)
14:17:35 <kuribas> johnw: and a getter is a traversal restricted to the Const functor.
14:17:42 <jle`> the neat thing with this is that you can already use it with 'over', 'toListOf', and all other Fold methods
14:17:54 <dolio> kuribas: No, that's a fold.
14:18:15 <jle`> if you just defined that type synonym, you can use it as a fold and a setter
14:18:22 <jle`> optics are neat
14:18:25 <dolio> Getter is a _lens_ restricted that way.
14:18:33 <kuribas> dolio: right :)
14:18:50 <erisco> I guess I can say fmap rather than fmapDefault
14:19:13 <erisco> this gives you  Foldable f, Functor f
14:19:31 <erisco> necessary but not sufficient for Traversable
14:19:55 <johnw> kuribas: if you look at the lens UML diagram, Traversal is not the most fundamental concept
14:20:12 <erisco> hence more general :3
14:20:44 <kuribas> the "gigantic UML diagram of DOOM" :)
14:21:08 <johnw> yeah, but once you know what it's saying, it's actually pretty valuable
14:21:19 <jle`> yup i reference it like every day
14:21:32 <jle`> i wonder if there's a nicer way to present it so that it's not as intimidating
14:21:37 <erisco> I read it as a bedtime story for the kids
14:21:39 <jle`> because once you see how it use it it's pretty clear/obv
14:21:48 <kuribas> johnw: right.  I choose traversal because it is known from the standard libraries.
14:22:54 <jle`> i like the idea that there's a general `p a (f b) -> p s (f t)` pattern that you can get interesting things out of by just restricting/loosening restrictions on p and f
14:23:02 <MarcelineVQ> UML diagram?
14:23:10 <jle`> p ~ (->) and f ~ forall f. Applicative f, and you get traversals
14:23:36 <jle`> if you generalize that to forall f. Functor f, you get lenses
14:23:51 <kuribas> MarcelineVQ: https://hackage.haskell.org/package/lens-4.15.1
14:24:05 <jle`> if you restrit it to (Covariant f, Applicative f), you get folds
14:24:11 <MarcelineVQ> a uml diagram is the image there?
14:24:53 <jle`> if you allow p to be *any* Profunctor, and f to be *any* Functor, you get iso's
14:25:21 <kuribas> MarcelineVQ: yes
14:25:24 <MarcelineVQ> thank you
14:25:31 <jle`> and the nice thing here is that it allows a type of subtyping... you can use an iso as a lens becuase iso has a more general type
14:26:18 <jedai> MarcelineVQ: Well there's lot of UML diagrams type but this image is one of them (and that's probably the only Haskell package that come with one)
14:26:57 <MarcelineVQ> I ​had put in UML lens in google and got an entirely differen't set of results than leaving out lens :>
14:27:47 <kkini> packaging question -- I have an oldish unmaintained haskell program lying around.  Its INSTALL file instructs the user to install justhub ( http://justhub.org/ ) in order to compile/run it.  But justhub seems to be dead, so I want to change the instructions to refer to stack instead.
14:27:47 <kkini> My question is, should I generate a stack.yaml myself and include it in the tarball, or just provide the .cabal file and instruct users to run `stack init` themselves?  What's the standard practice?  What's the lifetime of an unmaintained stack.yaml compared to an unmaintained .cabal file?
14:28:54 <jedai> kkini: an unmaintained stack.yaml should last years (that's the model of stack : once you have a build solution it should continue to build)
14:29:04 <MarcelineVQ> the point of a stack.yaml is to remain stable over time, long-term-support, so I'd make the stack.yaml so you can choose the lts that will work for the project
14:29:29 <glguy> kkini: If you're going to provide a stack.yaml, it's nice to do so under a name like: stack.yaml.default so that it can be used as a started point if desired
14:29:55 <glguy> that file contains information specific to a local workspace and the user is likely to customize it
14:30:13 <jedai> An unmaintained .cabal can last a long time with proper upper bounds on the dependencies (though you'll probably run into a problem with the newer GHCs which you wouldn't have with stack))
14:31:08 <glguy> kkini: If you're developing a library the users of your library won't be using your stack.yaml
14:32:44 <kkini> Hmm... this program doesn't actually have any dependencies -- pure Haskell2010 -- so I'm not really sure what breakage could even occur
14:32:53 <kkini> and it's not a library, just builds an executable
14:33:36 <kkini> so my gut feeling was that the cabal file could never break if I write "default-language: Haskell2010" in my executable section (unless haskell compilers in the post-apocalyptic future stop supporting Haskell2010)
14:34:04 <kkini> whereas the stack.yaml might break if one day lts-7.8 (which is what `stack init` currently chooses for me) disappears
14:35:00 <jedai> the stack lts are there for quite some time, and it's not like providing a stack will make your .cabal disappear.... 
14:35:11 <kadoban> kkini: The lts disappearing ... isn't going to happen.
14:35:26 <kkini> well, I guess one solution is to provide a stack.yaml.default as glguy suggested, and then write in the README that if in the year 2250 the stack.yaml.default doesn't work anymore, just make a new one with `stack init` :P
14:35:43 <kkini> jedai: yup, true :)
14:35:53 <kkini> ok, I guess I'll just do that.  Thanks for the advice, everyone!
14:36:03 <glguy> kkini: What's more likely to happen is that in a year or two the version of GHC required by that lts won't work on whatever OS the user is using now
14:37:11 <kkini> makes sense
14:38:25 <jedai> glguy: That may take a bit more than a year or two though ? Ok , there's the whole PIE debacle recently on Linux but for most cases binary distributions of executable last for far more than two years
14:38:49 <MarcelineVQ> PIE isn't new it's just back again :>
14:38:53 <glguy> jedai: No, not far more
14:40:31 <jedai> glguy: depends on the OS I guess but there are lots of executable that were compiled for Windows XP 10 years ago that still work on a current Windows 10 (sure there are other that didn't fare that well)
14:40:55 <jedai> On linux... I guess the problem would come from the libc ?
14:40:57 <glguy> jedai: I'm talking about GHC in particular, not generic Windows executables
14:41:31 <jedai> glguy: what other problems do GHC have, as a binary ?
14:41:51 <glguy> yeah, shared library versions move on, changes like macOS getting the protected system directoris requiring an update to the unix package for the expected error codes
14:42:19 <glguy> and when those require updates they aren't backported to old GHCs, so to work on the new OS you need the new GHC
14:48:56 <jedai> glguy: I still think that expecting a milleage of 3 to 5 year out of a current stack.yaml with lts7 shouldn't be too much of a bet... Let's dream a little ! ;)
14:49:09 <glguy> Yeah, definitely dream, just don't bet on it
14:50:13 <hvr> but it's got "LTS" in its name?!
14:50:36 <glguy> 3 months is pretty long term
14:50:47 <jedai> hvr: glguy seems to think the problem will be the GHC binaries
14:51:08 <glguy> jedai: I also included a package being the problem in my examples
14:51:32 <hvr> jedai: yes, but that's something that should have been considered when coining the term LTS too :-)
14:51:59 <jedai> glguy: You mean the unix update necessary due to macOS changes ?
14:52:15 <glguy> Yeah
14:53:46 <hvr> when I see LTS, I rather think about stuff like https://wiki.ubuntu.com/LTS which has a 5-year window
14:53:48 <jedai> glguy: Well I guess that could be a problem (packages can be updated inbetween two minor versions of the lts but that's already not the same and besides Haskell doesn't really have a culture of backporting the changes when there have been a new major version...)
14:54:02 <hvr> which also includes backports of security fixes
14:54:10 <glguy> Yeah, the updates aren't likely to be backported to a minor version, and the LTS won't be getting updates anyway
14:54:37 <jedai> hvr: Well I think that if you keep using this ubuntu lts, you're likely to be able to use the same stack.yaml for 5 years too
14:54:58 <hvr> jedai: except for the lack of security backports :-)
14:55:40 <jedai> hvr: That's the problem of frozen versions ! :) But everyone know there's no security bugs in any Haskell software ;-)
14:56:57 <kuribas> Is haskell harder than other languages?  Does it take more "mental effort" to program in haskell?  Or is it just a question of adaptation?
14:57:20 <johnw> kuribas: it sort of depends on where you're coming from
14:57:38 <mmaruseacph2> from my experience is just a matter of adaptation and learning
14:57:39 <johnw> i think that if you've never been taught to think imperatively, it would require less mental effort
14:57:55 <hvr> jedai: it's still a misnomer to me and seems like an attempt to attract enterprise users w/o actually providing the usual LTS semantics
14:58:21 <nitrix> kuribas: Try not approaching the language like you'd approach modern languages (which usually is simply a matter of learning their syntax). Haskell does have a bagage of interesting topics related to it and part of learning Haskell encompass learning about these things too.
14:58:41 <nitrix> You'll have to truly try to learn new things, as opposed to "adapting".
14:59:40 <Tuplanolla> I have noticed that certain problems do not fit the type system and are easier solved with dynamic types, kuribas.
14:59:51 <kuribas> Tuplanolla: like what?
14:59:54 <hvr> jedai: it's just an ordinary distribution, there's nothing "LTS" about it
15:00:00 <erisco> kuribas, it is neither harder nor requires more mental effort
15:00:12 <kuribas> Tuplanolla: In my experience it's a question of finding the right model.
15:00:14 <Tuplanolla> Path integral Monte Carlo computations most recently, kuribas.
15:00:50 <hvr> jedai: e.g. just like non-LTS ubuntu releases, you get updates for a few months and then it stops getting updated; you can still use some 5 year old non-LTS Ubuntu release; but you clearly shouldn't
15:00:59 <Tuplanolla> Matching the units or dimensions of matrices is the least of my concerns, especially when working with Hartree units.
15:02:41 <kuribas> An imperative programmer might say, why do I have to learn about statemonad transformers, when I can just loop and mutate a variable.
15:03:13 <kuribas> I wouldn't have an easy answer...
15:03:34 <Welkin> state monad is not mutation
15:04:13 <Tuplanolla> It's also cumbersome to carry the random number generator and the estimator logs around when they're involved everywhere anyway, kuribas.
15:04:45 <kuribas> Tuplanolla: true
15:04:55 <ab9rf> random number generators are so heavy
15:05:06 <ab9rf> the poor executor gets tired carrying them around everywhere
15:05:52 <Tuplanolla> There's `mwc-random`, but then the `IO` spills all over the place.
15:10:42 <tommd> kuribas: And then you can just learn about the ST monad, no State monad required!
15:10:58 <ggVGc> but
15:10:58 <tommd> (the general 'you', not specifically you)
15:11:04 <ggVGc> ST and State are very different?
15:11:09 <kuribas> tommd: right
15:11:41 <kuribas> ggVGc: ST allows you to have mutable variables.
15:11:45 <tommd> ggVGc: Sure, just look at the type of '$' in GHC 8.0
15:11:46 <ggVGc> yes
15:11:48 <ggVGc> I know
15:11:51 <ggVGc> that's why I said they're not the same
15:11:55 <ggVGc> so you can't just use one of them
15:12:44 <tommd> It fit the role kuribas was referring to wrt the cardboard cut-out imperative programmer, that's all.
15:14:36 <ertes> kuribas: one reason is that state actions, just like IO actions, are first class, so you can write combinators for them
15:14:37 <Welkin> cookie cutter programmers?
15:14:39 <Welkin> you mean java?
15:14:59 <glguy> I'm still using the old manual cookie cutters at home
15:15:08 <glguy> I didn't even know they could be programmable
15:15:29 <kadoban> I'd imagine they can be weaponized.
15:15:48 <ertes> kuribas: another reason is that state actions admit equational reasoning
15:16:26 <ertes> something that is just impossible when state manipulation is done by side effects
15:16:50 <catalin> Hello everybody, this is my first time here. I was hoping one of you could help me with something. I started learning Haskell two months ago. Recently I played with the Eval Monad and encountered something that I don't quite understand. It involves core usage.
15:17:03 <kuribas> ertes: good point
15:19:31 <mmaruseacph2> catalin: sure, just ask the question
15:20:53 <ab9rf> i read that as "evil monad" at first
15:21:28 <kadoban> That sounds much more exciting
15:22:25 <hpc> i can think of some things that qualify for that name
15:22:30 <ab9rf> i don't need a test to tell that i'm a lesbian, but thanks
15:22:36 <ab9rf> oops
15:22:47 <ab9rf> damn irc 
15:22:56 <hpc> it's the newest addition to lens
15:23:07 <ab9rf> lens has an evil monad?
15:23:23 <ertes> lens has Confused
15:23:29 <ab9rf> heh
15:23:33 <ertes> of course it also has an evil monad
15:23:34 <ab9rf> http://kawagner.blogspot.com/2007/02/why-monads-are-evil.html
15:24:51 <kuribas> ab9rf: that misses the point (>>=) is referentially transparent.
15:24:59 <ggVGc> this article is written very very badly
15:25:09 <ggVGc> no one should probably read it
15:25:39 <ab9rf> ggVGc: yes, i agree. it's also the first hit for "evil monad"
15:25:41 <kuribas> ab9rf: it will create the same action given the same inputs.  Which has nothing to do with actually "running" the action.
15:25:47 <ertes> i'm not going to read that one, for the same reason i'm not going to read an article that claims that there are only finitely many prime numbers
15:26:03 <ertes> (i would read it, if it were shorter)
15:26:27 <kuribas> https://www.kickstarter.com/projects/elite-pcs/the-pi-z0ne
15:26:40 <ab9rf> catalin: you had a question?
15:27:01 <ggVGc> ertes: here's a short one: There are finitely many prime numbers. I've counted all that I've seen, and they were not infinite.
15:27:55 <ertes> ggVGc: i have an exercise for you
15:28:17 <MarcelineVQ> like how in "x = 4" x is a random number because I rolled the 4 on a die
15:28:36 <MarcelineVQ> juuust stupid enough to write an article about
15:28:50 <kuribas> catalin: Are you refering to processor cores?
15:28:53 <erisco> kuribas, I wonder how they got it to land on $314 pledged
15:29:38 <kuribas> erisco: haha, that's nice.  I think they couldn't bother for $3141 or $31415
15:29:52 <erisco> there is drivel in the comments as well
15:30:01 <catalin> Guys, I have this program http://lpaste.net/339849 . When I profile it with threadscope, after 5 seconds, 3 of my 4 cores stop doing any work. Can someone shed some light on this?
15:30:02 <erisco> "Unless you write your own operating system and build a supercomputer costing millions, you will be limited to 64-bit math."
15:30:04 <erisco> *facepalm*
15:30:35 <glguy> Bad ideas floated on kickstarter could probably sustain its own IRC channel, its also offtopic on this one
15:31:08 <ertes> catalin: have you tried using the parMap from Control.Parallel.Strategies for comparison?
15:31:49 <erisco> "I'd also be interested in using this supercomputer to help with my project on finding the last digit of 1/3, when all of this is over." XD
15:32:21 <catalin> Silly me, I haven't tried that. I will now and see if anything changes.
15:32:33 <yulax> all good things come to an end after all
15:33:10 <ertes> catalin: if that one does the same thing, the i would suspect that the workload is not evenly distributed, because isPrime's run-time depends on its argument size
15:33:29 <ab9rf> yes, that would be my expectation too
15:34:19 <ertes> catalin: also if x is large enough, parMap starts to have a cost of its own…  you should use parBuffer in those cases
15:35:07 <ertes> (parMap can't handle long lists well, because it essentially views them as arrays)
15:35:22 <ertes> (the x from withPar)
15:36:24 <ab9rf> wow, that isPrime function is horrific
15:37:15 <pumita> Hello, I'm using parsec to parse some kind of markdown language. I want to parse the size of the text, just as MD does, i.e., counting the number of '#'. What's the best way to achieve this with parsec?
15:37:44 <erisco> pumita, collect the #'s in a list and count them
15:38:17 <ab9rf> i don't understand what hashmarks have to do with the size of the text
15:39:29 <Tuplanolla> ab9rf: Section headings start with `#`, subsection headings with `##`, ...
15:39:43 <catalin> I tried the library parMap and things changed a little. Now one core is always active while the other three alternate (so basically 2 cores are active at a time).
15:40:28 <ab9rf> catalin: what architecture do you actuall yhave?
15:40:40 <kuribas> @hoogle a -> b -> b
15:40:41 <lambdabot> Prelude max :: a -> a -> a
15:40:41 <lambdabot> Prelude min :: a -> a -> a
15:40:41 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:40:42 <ertes> catalin: i assume that you have compiled with -threaded and are using +RTS -N as program arguments
15:41:03 <pumita> erisco, thanks, do you think calling recursively some parser like `char '#'` and count those, failing otherwise will be ok?
15:41:08 <erisco> :t flip const
15:41:08 <MarcelineVQ> :t curry snd -- kuribas
15:41:09 <lambdabot> b -> c -> c
15:41:10 <lambdabot> a -> c -> c
15:41:29 <Tuplanolla> Just use `many1 (char '#')`, pumita.
15:42:02 <erisco> pumita, length <$> some (char '#')  should work, I think
15:42:31 <catalin> x64 with two cores (4 threads). But for 5 seconds all 4 physical thread are active, only after that I see this strange behavior. Can I upload the picture somewhere?
15:42:53 <ab9rf> catalin: so hyou really only have two cores. the other two are quasi cores provided by x64 hyperthreading?
15:43:06 <catalin> I do believe so
15:43:08 <pumita> Tuplanolla, yes, but I need to count a constant number of '#' occurrences
15:43:15 <ab9rf> catalin: that's expected behavior, and is because you really only have two cores.
15:43:55 <ertes> note that hyperthreading is intel only, and i often get very good results with it
15:44:13 <ab9rf> catalin: the odd-numbered threads are only partially implemented; they share part of their pipeline with their precedessor (even numbered) thread. generally both cannot execute continously at the same time.
15:44:48 <erisco> one executes while the other is waiting for memory, afaik
15:44:50 <ertes> catalin: you should fire up 'factor' (it's a coreutils program) on some difficult number four times and see if it takes longer than when you run it twice at the same time
15:44:59 <ertes> catalin: and, just for comparison, only once
15:45:00 <ab9rf> hyperthreading is useful and often improves performance, but a hyperthread is NOT a full core
15:45:16 <erisco> if there is anything else to hyperthreading I don't know what it is
15:45:22 <ab9rf> if you've got threads running in tight loops that are fully in cache, you will see the sort of behavior you describe
15:45:51 <ertes> catalin: like this: factor 10000000000000000000000000000000000001
15:45:57 <johnw> erisco: hyperthreading = the ability to suspend process registers and such *on the CPU*, rather than suspending them to memory or cache, when task switching
15:46:20 <johnw> so it is allows extremely fast context switches
15:46:52 <erisco> johnw, okay then I guess I am misinformed. that doesn't sound transparent to the OS
15:47:23 <johnw> it presents to the OS like it's another core, but it doesn't run asynchronously with the other side of its twin
15:48:00 <johnw> http://www.makeuseof.com/tag/hyperthreading-technology-explained/
15:48:52 <ab9rf> the two threads that share the same execution engine alternate, with one thread running wheneever the other thread stalls due to a branch miss or cache miss
15:48:57 <ertes> catalin: also whenever it's about parallelism and concurrency i generally recommend reading The Book: http://chimera.labs.oreilly.com/books/1230000000929/
15:49:11 <ab9rf> when one thread has to wait for memory, the other thread runs until it too stalls
15:49:24 <johnw> what ab9rf said :)
15:49:49 <erisco> johnw, when is it going to switch work to the other thread? I thought when one thread goes for memory
15:49:59 <ab9rf> usually it's for memory
15:50:09 <erisco> or IO I guess, that is also slow
15:50:12 <ab9rf> it could also be for some other resource 
15:50:12 <johnw> yeah, or PCI bus I imagine
15:50:27 <erisco> so I don't think I was misinformed on it
15:51:17 <catalin> I will try the factor function and see the results. This is how the profile looks https://imgur.com/a/cVMdw
15:51:27 <ab9rf> a stall can also arise if an instruction is waiting for a result from another instruction that is "ahead" of it in the pipeline
15:51:46 <ertes> so the worse your program's cache performance, the better it will utilise hyperthreading =)
15:52:07 <catalin> The cache argument seems valid.
15:52:14 <ab9rf> on some architectures, condition flags may take two or more instruction cycles to "settle" as they propagate backwards through the execution core. a DD stall can occur if an instruction attempts to reference processor state that hasn't propagated backwards.
15:52:26 <ab9rf> ertes: yes
15:52:49 <ertes> catalin: that one wasn't related to your question (or perhaps only secondarily)
15:52:49 <ab9rf> on some pipelined architectures, it's necessary to insert NOPs into code to avoid DD stalls
15:53:00 <erisco> like an IO queue in the OS scheduler
15:53:17 <Tuplanolla> Don't stop now, ab9rf.
15:53:35 <ab9rf> :)
15:54:07 * ertes watches as ab9rf throws Tuplanolla a bone
15:54:24 <ab9rf> catalin: the code you've written likely runs pretty tight, and so the threads will run without stalling for a fairly long time
15:55:33 <ab9rf> possibly several milliseconds at a go :)
15:56:01 <ab9rf> espevially given how stupid your isPrime function is
15:56:03 <ab9rf> :)
15:57:07 <erisco> that is how you program a space heater
15:58:24 <catalin> It's just for testing. I know how to do a proper one. 
15:58:26 <grantwu> I need a space heater.
15:58:55 <grantwu> I also need a responsive computer, though...
15:59:08 <ab9rf> catalin: it's likely that that function rarely fails branch predictions, which made the behavior you got more likely to be noticeable.
16:00:58 <catalin> How does the fact that it doesn't fail branch prediction make it more likely?
16:01:09 <ab9rf> catalin: much less likely for the thread to stall
16:01:26 <ab9rf> catalin: which results in the other thread visibly starving
16:01:50 <ab9rf> if there were more stalls, you'd end up with both threads showing ~50% load instead of them alternating 100%/0%
16:02:23 <ab9rf> or even closer to 100% on both if they bvoth stalled frequently
16:04:17 <catalin> If I understand correctly (correct if I don't), because two threads share the same cache memory and one always has something to do (and finishes it's work fast, so it needs to bring more stuff from RAM to chache), this makes the second thread not able to do any work since the cache is always worked upon the first thread.
16:05:08 <ab9rf> catalin: both threads share the same cache, but this function is so small that it's likely that both threads working memory fits entirely in cache
16:05:40 <ab9rf> thus, the stalls here are caused either by a branch prediction failure, or because the operating system had to use that core to process an interrupt.
16:07:20 <kuribas> :t uncurry $ flip $ curry $ id
16:07:21 <lambdabot> (b, a) -> (a, b)
16:07:23 <obadz> how does one generate hcr core files in ghc8 ?
16:07:31 <obadz> looks like -fext-core doesn't work
16:10:09 <catalin> Ok, obviously I need to read more about this stuff. thanks ab9rf and ertes for your help, I appreciate it. At least how I have something to investigate.
16:12:10 <ertes> catalin: also follow the link i gave you…  it's currently *the* resource on parallelism in haskell
16:12:52 <catalin> :ertes Ok, I will, thanks.
16:13:05 <erisco> kuribas, an interesting way to define swap :3
16:13:28 <kuribas> :t swap
16:13:28 <ertes> catalin: also remember that the performance of your code depends on the value 'x' from withPar
16:13:30 <lambdabot> (a, b) -> (b, a)
16:13:41 <kuribas> @hoogle swap
16:13:41 <ertes> catalin: you should try parBuffer for comparison
16:13:42 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
16:13:42 <lambdabot> Data.Vector.Generic.Mutable swap :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> Int -> m ()
16:13:42 <lambdabot> Data.Vector.Mutable swap :: PrimMonad m => MVector (PrimState m) a -> Int -> Int -> m ()
16:14:04 <kuribas> erisco: thanks :)
16:14:24 <ertes> catalin: (in fact i'd generally just ignore parMap, because parBuffer is superior in every way i can think of)
16:16:10 <catalin> :)) i will look into it. Thanks again for the book recommendation. I had a great time here. I will be leaving now. Have a great day.
16:16:28 <ab9rf> catalin: thamnk you for an interesting question
16:23:06 * hackagebot oauth10a 0.1.0.0 - Simple utilities to create OAuth 1.0a headers  https://hackage.haskell.org/package/oauth10a-0.1.0.0 (gatlin)
16:24:38 <muyfine> I'm having trouble navigating through nested Maybe's with lenses
16:24:57 <muyfine> I can hack up a solution - http://lpaste.net/339854
16:25:17 <jle`> looks very fine to me
16:25:37 <muyfine> but it seems like there should be a cleaner way to use lenses without having to build a "default" object
16:25:44 <jle`> dislaimer i haven't actaully looked at it
16:26:13 <jle`> well, what are you trying to do?
16:26:34 <jle`> what would you want to be returned if there is Nothing?
16:26:53 <ertes> muyfine: in childNickname you can use (>>=) to streamline the Maybes
16:27:13 <muyfine> yeah, I'd like to return a default value, without having to build a default object around that value
16:27:33 <muyfine> ertes ahh, good point
16:27:41 <ertes> muyfine: maybe def id (mx >>= \x -> my x >>= \y -> …)
16:29:10 <jle`> childName = fromMaybe def . preview (pChild . cName) 
16:29:13 <jle`> if you wanted to use lens
16:29:36 <jle`> preview (pChild . cName) :: Parent -> Maybe Text
16:29:56 <jle`> preview (pChild . cNickname) :: Parent -> Maybe Text
16:31:12 <glguy> rather: preview (pChild . folded . cName)
16:31:47 <jle`> oh yeah
16:34:10 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/339854#a339856
16:38:45 <muyfine> oh wow, folded?
16:38:59 <muyfine> I didn't know about that
16:39:25 <muyfine> that's great
16:39:27 <muyfine> thanks!
16:39:42 <muyfine> thanks jle` glguy !
16:42:05 <jle`> :D
16:42:17 <zennist> when working with FFI, if I have a foreign exported haskell callback that the C code calls upon some event; is that haskell callback guaranteed to be run in the same OS thread as that C code (and blocks while running)? or does ghc have the choice to runs the callback in another thread?
16:51:33 <kirillow> lyxia: thank you!
17:03:41 <EvanR> zennist: it cant run in the same thread in general, since you could have used that callback during the FFI call
17:03:52 <EvanR> with -threaded the callback will work, not deadlock
17:16:15 <n_blownapart> is lazy eval the same as normal order evaluation in scheme, essentially?
17:21:55 <Guest59562> ok 
17:21:56 <Guest59562> like
17:22:01 <spik3> Hi all
17:22:18 <Voltz> Ok so 
17:22:30 <Voltz> "A monad is a monoid in the category of endo functors" 
17:22:33 <Voltz> Where is the monoid bit?
17:22:40 <Voltz> mappend and mempty?
17:25:08 <spik3> When I call this function http://lpaste.net/5694707445687910400 with the following argument "insert 5 (Node 8 (Node 3 Nil Nil) (Node 10 Nil Nil))" I get this error "Node 8 (Node 3 Nil Nil) Program error: Empty Tree as Argument"
17:25:57 <spik3> Why does the program stop on the second subtree?
17:28:20 <geekosaur> the thing generating that error is not shown, so it's hard to tell. I would be tempted to say it's the printer that is broken, since I don't see anything obvious wrong with the given code
17:30:24 <spik3> Oh I think I fixed it. I forgot to delete the debug message...
17:31:19 <spik3> geekosaur, thanks :)
17:31:51 <latro`a> Voltz, https://en.wikipedia.org/wiki/Monoid_(category_theory)
17:32:04 <latro`a> the "multiplication" is composition of Kleisli arrows, the "unit" is return
17:32:12 <latro`a> (iirc)
17:35:00 <byorgey> Voltz: how much category theory do you know?
17:36:55 <byorgey> understanding the precise meaning of that famous quote is a nice exercise, if you already know some basic category theory.  But otherwise I wouldn't worry about it.
17:37:35 <byorgey> latro`a: actually the "multiplication" is join
17:38:28 <latro`a> ah thank you
17:38:36 <latro`a> misremembered
17:39:46 <byorgey> no worries, there are lots of different monoid/category-ish things related to monads =)
17:39:51 <byorgey> the Kleisli category being one of them.
17:40:58 <EvanR> and applicatives
17:44:01 <Voltz> Ohhh that makes sense latro`a
17:44:37 <latro`a> Voltz, see byorgey's correction
17:44:41 <Voltz> I did 
17:45:32 <EvanR> i still havent really gotten to the point in CT when there is anything but a huge pile of identifying structures by name. yonedas lemma might be my first real theorem, once can grok that much
17:47:24 <Voltz> ok so the dual of a category is reversing the arrows... so a comonoid, the associative operation takes in a single value and returns a product type
17:47:33 <Voltz> what happens to the empty value? 
17:47:40 <Voltz> how do you reverse the arrow on a value?
17:47:55 <EvanR> Voltz: its important to note that the "monoid" referenced in that quote, and in your question about comonoids, is not the same thing as a classic algebra monoid
17:48:15 <EvanR> its a category theory monoid object
17:48:43 <Voltz> Why must all the names be the same D:
17:49:06 <EvanR> because a classic algebra monoid is "just a monoid object in the category of sets"
17:49:43 <EvanR> in that context, you can talk about "values"
17:49:47 <EvanR> but not in general
17:50:21 <Voltz> eh... I'm not quite sure I understand. Maybe I'm getting ahead of myself 
17:50:30 <EvanR> right
17:51:29 <EvanR> also dont confuse the endofunctor quote with the definition of monad, that doesnt define monads its only an observation
17:52:27 <EvanR> i guess i mean, there are monoids in endofunctor categories that arent monads
17:52:30 <Voltz> That was mostly unrelated to my quesiton about comonoid
17:54:21 <EvanR> Voltz: well you can begin figuring out the comonoid question by looking at the definition of monoid *object*
17:54:21 <Voltz> I'm not sure how accurate Wikipedia is on the it, but a monoid is a structure with an associative operation and some identity element 
17:54:40 <EvanR> https://en.wikipedia.org/wiki/Monoid_(category_theory)
17:55:33 <EvanR> but wikipedia is generally really terse and uninspiring with its CT
17:56:18 <EvanR> a comonoid is a thing with all the arrows on that page reversed
17:58:27 <Voltz> M is the monoidal category you're working in, correct? 
17:58:51 <EvanR> no
17:59:00 <EvanR> its the monoid (object)
17:59:14 <EvanR> you can think of it like a type
17:59:30 <Voltz> ok 
18:13:25 <SAL9000> If I have an infinite lazy list, which is "consumed" by a callback (in a forkIO thread), what's the best-practices way to ensure that this callback continues along the list rather than always evaluating the first element? I'm currently using mapM_ (putMVar mv) lazyList in another thread, but that feels like a kludge
18:30:33 <EvanR> SAL9000: one way is to use a recursive function, keep passing the tail of the list to the next iteration
18:30:58 <Squarism> just found out Atom is built on html, javascript and css. That is so lol. Taking everything that sux with web and move it to the desktop
18:31:26 <ab9rf> Squarism: duh
18:31:44 <EvanR> honestly, is there a better GUI idea?
18:31:50 <ab9rf> Squarism: this is doen because processors are cheaper than developers, and web developers are cheap
18:31:57 <Koterpillar> Squarism: it happens that people put a lot of work into refining the display of HTML and CSS
18:33:02 <orion> Would it be profitable to write an ASN1 compiler for Haskell? E.g. You give me a ASN1 file and I will send you Haskell code which does all the parsing for you.
18:33:22 <SAL9000> EvanR: the "problem" is that the project I'm integrating this into is using callbacks with no "userdata" state like that. Thus the idea of using MVars so that the callback always gets the "next" value.
18:33:31 <Squarism> EvanR, id be ok with html and javascript - but javascript, cant see past taht
18:33:45 <Squarism> oh
18:33:47 <EvanR> SAL9000: a recursive function doesnt need any a priori state
18:33:55 <Squarism> html and css ... but not js
18:34:05 <EvanR> Squarism: make up your mind man!
18:34:21 <EvanR> which terrible technologies are OK tell us
18:34:23 <Koterpillar> Squarism: thankfully, a lot of languages compile to JS now
18:34:37 <Koterpillar> Squarism: and I believe Atom isn't using JS itself, but one of them
18:35:34 <EvanR> Atom: if you didnt know it was using html css and js, but were using it, then whats the difference? its slow? well thats a different problem really
18:35:41 <Squarism> I meant id be ok with html and css.. but javascript i cannot stand. Its lacks all things i like in a programming language
18:36:02 <EvanR> should the user care what programming language something was made in
18:36:05 <Koterpillar> the tram I sometimes take is using Windows 3.11
18:36:38 <EvanR> also this has nothing to do with haskell
18:36:44 <Koterpillar> yes, sorry
18:37:00 <Squarism> Yes, if you are planning to invest time in something. I cannot see Atom evolve into a competent IDE
18:40:44 <Myrl-saki> I'm pretty sure that Atom either uses JS or a direct derivative.
18:41:43 <Myrl-saki> Repo: CoffeeScript 74.5%; JavaScript 24.1%
19:33:18 <byorgey> does anyone know if the handling of indentation for do-blocks changed in GHC 8?  Specifically, I have some code where nested do blocks line up under previous ones, which used to work, but I get 'empty 'do' block' errors with GHC 8
19:34:23 <lpaste> byorgey pasted “nested do indentation” at http://lpaste.net/339880
19:34:35 <byorgey> ^^^ this is an example
19:35:15 <kadoban> Huh, I didn't think you could do that. I always indent the inner do block a bit
19:35:16 <monochrom> interesting layout :)
19:35:21 * kadoban goes to look at the rules again
19:35:42 <geekosaur> sounds like NondecreasingIndentation got changed or turned off?
19:35:48 <byorgey> I like this style when each nested 'do' is essentially a continuation in tail position
19:35:52 <geekosaur> (ghc extension, default *on*)
19:37:18 <byorgey> huh, adding {-# LANGUAGE NondecreasingIndentation #-} fixed it.  I also thought the default was for that to be on.
19:37:54 <byorgey> I guess the other thing that changed is that I am building with stack.  Maybe it has different rules about how it decides what flags to pass to GHC.
19:38:01 <geekosaur> defaults on in 7.10 certainly
19:38:58 <monochrom> I get it accepted by both 7.10 and 8.0
19:39:27 <geekosaur> weird
19:39:39 <byorgey> hmm, yeah, must be something about the way stack is building ite
19:39:41 <monochrom> let me add -XHaskell2010 and see what happens
19:39:43 <byorgey> *it
19:40:07 <monochrom> \∩/ -XHaskell2010 kills it
19:40:39 <byorgey> ah, my .cabal file has  default-language: Haskell2010.  I bet cabal ignores that, but stack takes it seriously
19:40:49 <byorgey> fair enough!
19:41:15 <kadoban> Does cabal really ignore that? That'd be ... interesting.
19:41:40 <geekosaur> ghc itself describes its default language as H2010 + ...
19:41:46 <geekosaur> (or ghci does at least)
19:42:14 <geekosaur> but explicit -XHaskell2010 disables the extensions normally turned on
19:42:16 <monochrom> cabal doesn't ignore it. actually, cabal takes it so seriously, cabal tells GHC an explicit -XHaskell2010 or -XHaskell98 depending on what you set with "default-language" (and if you don't set it, cabal still chooses one for you)
19:42:17 <byorgey> kadoban: I mean it parses it of course.  It probably has *some* effect.  But I guess it doesn't go as far as passing  -XNoDecreasingIndentation  to invocations of GHC, but stack does
19:43:07 <byorgey> oh!  so maybe it's really cabal that was doing this, not stack
19:43:12 <monochrom> If you don't set default-language, cabal may throw in -XHaskell98 for really backward compatibility
19:43:22 <byorgey> come to think of it, perhaps I have not built this with cabal before either
19:43:38 <byorgey> I just had a collection of .hs files that I was loading into ghci
19:43:41 <kadoban> Hmm, that sounds like it makes more sense, I'd expect them both to do it, otherwise that sounds a bit problematic really.
19:43:42 <monochrom> stack probably does the same thing as cabal on this
19:44:07 <byorgey> thanks for straightening me out.
19:44:20 <byorgey> monochrom++ geekosaur++
19:44:21 <monochrom> of all the differences and improvements stack brings, it won't want to change *.cabal semantics
19:44:22 <MarcelineVQ> byorgey: someone else had that issue just last night
19:44:35 <byorgey> monochrom: that's a good point
19:45:21 <byorgey> MarcelineVQ: hah, really?  well, now if anyone else has the problem we will know how to help =)
19:45:31 <byorgey> \o/ project built successfully
19:45:54 <geekosaur> someone did raise unexpected behavior of that extension on -cafe earlier today, too
19:45:56 <MarcelineVQ> I like to indent anyway because I want the things in the do block to be appearant that they belong to the do
19:46:04 <geekosaur> "guess what this program does when you comment out a line"
19:46:21 <monochrom> haha
19:46:40 <geekosaur> (and what it does is different depending on whether NondecreasingIndentation is on or off)
19:47:04 <kadoban> byorgey: Hmm, what should we really suggest though, that they turn that extension on I guess?
19:47:16 <kadoban> Or ... off would it be? Haha so confused.
19:48:55 <monochrom> do-if-then-else is realized by a strange and simple grammar rule. this may be the cause of the weirdness in the -cafe post
19:49:37 <monochrom> it is realized by not touching any of the layout rules or do-notation rules.
19:50:07 <monochrom> Instead, it is simply declared that if-then-else expressions allow optional semicolons, e.g., "if x; then y; else z;"
19:50:28 <monochrom> so you just let Haskell98 layout rules do the rest.
19:50:44 <monochrom> (do the rest to add your semicolons)
19:50:48 <byorgey> monochrom: haha, TIL
19:51:03 <byorgey> kadoban: on =)
19:51:41 <monochrom> http://lpaste.net/81623 shows some examples
20:45:27 <jerin> Hello, I'm trying to implement the Exception Monad from https://cse.sc.edu/~mgv/csce330f16/wadler_monadsForFP_95.pdf, how do I see the result? 
20:45:28 <jerin> Am I supposed to create a new instance of show? 
20:45:29 <jerin> https://ptpb.pw/3EZF
20:46:52 <Koterpillar> jerin: you can pattern match on M if you don't want Show
20:51:33 <jerin> how do I pattern match
20:51:45 <jerin> I tried showVal(Return a) = (show a)
20:51:54 <jerin> which is getting me compile errors
20:51:56 <jerin> Koterpillar: 
20:56:15 <jerin> nevermind, got it using cases
20:56:31 <jerin> How do I create a show instance on the above monad?
20:59:03 <Squarism> how do i check what packages depend on a certain package in cabal?
21:01:27 <sm> Squarism: http://packdeps.haskellers.com/reverse
21:02:45 <Squarism> ok thanks
21:16:25 <jle`> jerin: what is the above monad?
21:17:29 <jerin> https://matrix.org/_matrix/media/v1/download/matrix.org/yVXCdQVKhAkgKpOJPKdrsYcn - jerin_2016-11-16_05:17:06.txt
21:18:49 <jerin> jle: my current code looks like this: https://ptpb.pw/UmvQ
21:20:04 <jerin> jle: I'm looking for a show which can operate on (M Int) given by (eval answer) and display the result
21:29:09 <tnks> if I have types of kind *->*->*, and I want to make a type class `TC`, but dependent on them being a functor when applied to any type (to make them of kind *->*), is there a notation for that?
21:29:35 <tnks> class Functor (m _) => MyTypeClass m where ???
21:29:49 <dfeuer> I wish I didn't have to keep defining newtype Flip f a b = Flip {unFlip :: f b a}.  It's getting tiresome.
21:30:04 <dfeuer> It seems to pop up all over the dang place.
21:30:32 <dfeuer> I guess I could import whatever categorical package has Op.
21:30:37 <dfeuer> :/
21:32:02 <jle`> dfeuer: i use the one from the type-combinators package
21:32:08 <jle`> but that's because i already use that package for other things too
21:32:16 <dfeuer> jle`, thanks; I haven't heard of that one before.
21:32:18 <tnks> wait, I think ConstraintKinds helps with what I want.
21:33:18 <jle`> tnks: you want something like (forall a. (Functor (m a))) => Foo m, i'm guesisng?
21:33:50 <dfeuer> tnks, if jle`'s guess is right, then you need Data.Constraint.Forall from the constraints package.
21:34:14 <dfeuer> (or you can use a higher-kinded class of some sort)
21:35:48 <jle`> tnks: reading it over again it looks like that's what you're looking for, but how to best go about implementing/writing it is different based on what you want to do exactly
21:36:34 <tnks> jle`: yeah, that's what I want.
21:37:33 <tnks> (but now I have to figure out how to use it!)
21:38:39 <dfeuer> tnks, if you're talking about Data.Constraint.Forall, then the critical bits are Forall and inst. Everything else is built on those.
21:38:42 <jle`> it's something that i've run into a few times, it's a little annoying that haskell doesn't have a standard way to doit
21:38:52 <dfeuer> Very annoying.
21:39:49 <dfeuer> Because it leads us to double names to be able to work with higher-kinded versions of the same ideas.
21:40:56 <dfeuer> Or to use Forall, which is a hack, and which I believe may interfere with optimization (unsafeCoerce tends to do that).
21:41:07 <dfeuer> It's a beautiful hack, but it's a hakc.
21:43:52 <Squarism> $ cabal new-build
21:43:52 <Squarism> BadPackageLocations [BadLocGlobEmptyMatch "./*.cabal"]
21:43:56 <Squarism> ?
21:51:39 <tnks> jle`: some of the extension in the `constraints` package are new to me.
21:52:27 <tnks> could you help me figure out what I type to get the equivalent of `(forall a. (Functor (m a))) => Foo m`?
21:55:43 <jle`> tnks: i think you should be able to do ForallF Functor m => Foo m
21:56:35 <tnks> okay, I tried that, and ghc is asking me to turn on UndecideableInstances.
21:56:36 <jle`> and then you can generate a Functor (m a) at-will for any 'a' using instF
21:56:40 <tnks> is that reasonable to turn on?
21:56:50 <jle`> yeah, for the most part
21:58:03 <dfeuer> UndecidableInstances is one of the less troublesome class system extensions.
21:58:05 <jle`> and now, if you do `blah blah blah \\ instF`, then you'll have the Functor (m a) instance "in-scope"
21:58:12 <jle`> in the blah blah blah part
21:58:20 <jle`> you might need to give an explicit type annotation somehwere
21:59:02 <dfeuer> jle`, tnks, when learning, I'd recommend focusing on inst rather than instF or any of those other convenience functions.
21:59:14 <dfeuer> Look at how instF is defined in terms of inst.
21:59:39 <dfeuer> And how ForallF or whatever it's called is defined in terms of Forall.
21:59:55 <tnks> ah, I see, this isn't just going to be a magic fix.
22:00:01 <jle`> hm, how is this going to work with Forall?
22:00:14 <tnks> this is going to require that I use inst/instF in my calling code?
22:00:21 <jle`> yeah
22:00:24 <dfeuer> jle`, you have to use one or more auxiliary classes.
22:00:34 <tnks> jle`: okay, this makes me a touch sad.
22:01:00 <Squarism> do you people use haskell for scripting tasks? 
22:01:01 <dfeuer> tnks,  it is sad. You can write copies of class methods that hide that away, if you like.
22:01:08 <jle`> it seems to work out-of-the-box with ForallF though
22:01:08 <jle`> and instF
22:01:09 <jle`> tnks: yeah, inst/instF is needed to unlock/generate the Functor (m a) instances
22:01:19 <jle`> Squarism: yes
22:01:25 <kadoban> Squarism: Depends what that means
22:01:27 <jle`> tnks: as a one-off hack you can write your own Functor1 typeclass
22:01:41 <jle`> but you'll have to write an instance for every Functor you want to use it with
22:02:06 <dfeuer> jle`, sure, but then when you hit something ForallF isn't good enough for, you'll be learning how to use Forall in a hairy context!
22:02:15 <Squarism> kadoban, typically would be read something from stdin-process-write on stdout... like lists of strings typically
22:03:13 <kadoban> Squarism: Well, that's certainly quite doable. The 'interact' function helps a ton for that kind of thing. I also like using haskell stack in script interpreter mode for that kind of thing, works great.
22:03:18 * hackagebot heredocs 0.1.3.2 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.3.2 (KatsutoshiItoh)
22:04:33 <tnks> jle`: also, if I write a Functor1 type class, it won't play nice with any combinators written in terms of the Functor constraint, right?
22:04:35 <Squarism> kadoban, script interpeter mode?
22:04:44 <Squarism> interpreter
22:04:54 <Squarism> like a shabang? 
22:05:07 <kadoban> Squarism: You just put magic shebang stuff and an extra comment at the top, yeah. It's in the docs somewhere, sec.
22:05:36 <jle`> tnks: yeah, unless you can bring a Functor instance into scope with a trick like inst
22:05:39 <kadoban> https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
22:08:51 <Squarism> thanks
22:09:06 <Squarism> looks good. Gotta try next time i need simple scripts
22:14:47 <tnks> jle`: hey, thanks for your help.
22:15:04 <tnks> I was trying to do this to make my API easier to use, but I think it's ultimately not worth the effort.
22:15:24 <tnks> it's not that I can't do it. . . it's just that I can't figure out a way to hide it from the usage of my API.
22:15:33 <tnks> dfeuer: same ^
22:16:05 <tnks> I'm doing a tagless encoding, and the constraints were stacking up.  I was hoping to get rid of them with superclasses.
22:17:47 <jle`> kkkkkkk
22:30:05 <cocreature> tnks: you can also make a synonym for a set of constraints if you enable -XConstraintKinds (which is a safe extension)
22:31:05 <jle`> er, sorry about that
22:43:19 * hackagebot tianbar 1.2.2.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.2.2.0 (AlexeyKotlyarov)
22:53:19 * hackagebot heredocs 0.1.4 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.4 (KatsutoshiItoh)
23:02:41 <lambdacat> Has anyone used GHC.Generics for constructing types?
23:05:41 <lambdacat> Say you have two types that derive Generic and they have the same fields and types. E.g., suppose we have `Foo` and `Bar`, theoretically, you could have `to (from Foo { x = “baz” }) :: Bar`.
23:06:07 <lambdacat> Which would return `Bar { x = “baz” }`.
23:12:09 <jle`> i haven't used it for that but i know that other people have
23:13:29 <clmg> Is it possible to passs around a list of functions to later apply arguments to?
23:13:35 <clmg> like I have [foo, bar, raz]
23:13:46 <pikajude> :t [succ, pred]
23:13:47 <lambdabot> Enum a => [a -> a]
23:13:49 <pikajude> yep
23:14:08 <clmg> and I want to do [f x | f <- [list,of,functions], [1..10]]
23:14:14 <pikajude> :t foldr (.) id
23:14:16 <lambdabot> Foldable t => t (b -> b) -> b -> b
23:14:34 <pikajude> pretend the "t" there is []
23:14:53 <kadoban> > [f x | f <- [succ, pred], x <- [1..3]]
23:14:55 <lambdabot>  [2,3,4,0,1,2]
23:15:16 <clmg> kadoban: when I try to create that list, it says "maybe applied to too few arguments?"
23:15:35 <pikajude> code, maybe?
23:17:02 <clmg> http://lpaste.net/339939
23:17:47 <kadoban> clmg: Those functions aren't of the same type. The elements of lists always need to each have the same type.
23:18:03 <clmg> what if they are pairs?
23:18:37 <clmg> rules = [(aer, 1), (mpp, 2)]
23:18:56 <kadoban> That's just the same problem one step removed
23:19:14 <clmg> kadoban: but why would it error?
23:19:34 <kadoban> Because the elements of list always need to each have the same type, and those don't.
23:19:48 <kadoban> :t [succ, pred]
23:19:50 <lambdabot> Enum a => [a -> a]
23:19:53 <kadoban> :t [succ, (+)]
23:19:54 <lambdabot> error:
23:19:54 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
23:19:54 <lambdabot>       Expected type: (a -> a) -> a -> a
23:20:08 <kadoban> :t [(succ, 2), ((+), 5)]
23:20:09 <lambdabot> error:
23:20:09 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
23:20:09 <lambdabot>       Expected type: (a -> a) -> a -> a
23:20:12 <kadoban> Same problem
23:20:45 <clmg> ah the error is just misleading
23:20:57 <clmg> Can I have a type that takes an undefined number of arguments?
23:21:28 <kadoban> Not really
23:21:35 <clmg> damn
23:21:38 <jle`> clmg: remember all types in haskell take only one argument
23:22:12 <jle`> s/all types/all functions
