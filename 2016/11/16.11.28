00:07:37 <lyxia> bollu: createSqlPool has a monadLogger constraint
00:08:39 <bollu> lyxia: ohh, thanks
00:08:50 <bollu> lyxia: how do you find things like this out?
00:09:16 <lyxia> I just look up the functions on hoogle
00:11:16 <paolino> hello, shouldn't be instance (Ord k, Monoid v) => Monoid (Map k v) ?
00:12:42 <lyxia> you don't need Monoid v if you're going to throw the old one out
00:13:06 <paolino> shouldn't be implemented with some const monoid ?
00:14:31 <lyxia> why should it
00:15:32 <paolino> it feels natural that when I use a monoid it makes the best to use the internal monoid when there are
00:17:07 <lyxia> that would mirror the (->) instance for sure
00:17:50 <paolino> in some sense being a monoid is more important of being something else
00:18:43 <paolino> or, throw away less information than you can
00:18:54 <lyxia> (Ord k,Semigroup v) would be better then
00:18:56 <jle`> i like that instance, but it's just one of several valid instances
00:19:07 <jle`> just not the one chosen by the library maintainers
00:19:39 <paolino> jle`, I'm arguing there is an order and there is a best one
00:20:17 <jle`> there are arguments for a bunch  of different possible instances
00:20:29 <jle`> for example, your instance wouldn't be usable if v wans't an instance of Monoid
00:21:16 <paolino> well you can fmap Const for that
00:21:22 <paolino> I cannot
00:21:29 <paolino> I have to wrap it
00:21:36 <jle`> yeah, so then again it's a question about which should be the default behavior
00:21:39 <jle`> and which should require boilerplate
00:21:53 <paolino> fmap is not boilerplate
00:22:06 <paolino> well less boilerplate than newtype
00:22:09 <jle`> newtype wrapping and unwrapping is boilerplate/synatctic noise
00:22:21 <lyxia> let's reverse the argument, you can use unionWith to combine values with your own operation
00:22:37 <paolino> that's what I have to do
00:22:55 <paolino> there is a natural union
00:22:58 <paolino> it's monoid
00:23:01 <jle`> and, if your instance was the default instance, someone else would have to use unionWith for their operation
00:23:23 <jle`> half of your situations you'd use unionWith, half of them you'd use (<>)
00:24:16 <paolino> btw, np, I wrap it up
00:24:20 <lyxia> throwing away the first operand is more than natural, it's universal
00:24:24 <jle`> what's "natural" is in the eye of the beholder; what's more useful/less noisy/more practical is a little more arguable
00:24:32 <lyxia> you can do it on every set
00:25:18 <lyxia> it's actually a semigroup
00:25:25 <paolino> if I can't convince you I'm stopping convincing any mantainer
00:25:57 <jle`> it is indeed the perfect parametrically polymorphic universal monoidal operation
00:26:00 <jle`> or well, one of a couple
00:26:09 <jle`> it is the platonic ideal of a monoid
00:26:55 <paolino> on the flip side you didn't convince me of the opposite, Const throw away information, it's inferior in my eyes
00:28:35 * hackagebot flat-mcmc 1.3.0 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.3.0 (JaredTobin)
00:28:37 * hackagebot haskelisp 0.1.1.0 - Write Emacs module in Haskell, using Emacs 25's Dynamic Module feature  https://hackage.haskell.org/package/haskelisp-0.1.1.0 (shintak)
00:31:08 <koz_> Could someone explain what invariant functors are?
00:31:11 <koz_> I'm a bit confused.
00:31:48 <lyxia> paolino: If you still decide to bring this up, it would be better to argue what makes it better to use in a practical sense, rather than some abstract notion of goodness.
00:33:35 <lyxia> koz_: have you read this https://www.fpcomplete.com/blog/2016/11/covariance-contravariance
00:34:18 <paolino> lyxia, make sense, but there is not much to say , I had this surprise using it, so I went to the docs, and there I see it misses the constraint and I thought that too much surprise not to spell
00:36:20 <paolino> it boils down to let the signatures speak more than possible, so it's abstract notion of goodness in the end
00:36:57 <jle`> the type signature w/o the Monoid constraint actually says more about the function than the type signature with it
00:37:27 <koz_> lyxia: I will now. Thank you!
00:37:39 <jle`> leaving off the Monoid constraint lets the type signature say more about what the function does
00:38:25 <paolino> jle`, again , I think exactly the opposite :-/
00:38:40 <jle`> how many functions do you think have the type foo :: a -> a -> a ?
00:38:52 <jle`> and how many functions have the type foo :: Monoid a => a -> a -> a ?
00:39:00 <jle`> the first type signature says much more about the function it describes than the second
00:39:14 <jle`> the second actually has an infinite number of possible implementations
00:39:28 <jle`> the first one only has two total ones
00:39:47 <jle`> the first function's type signature says much, much more than the second one's type signature
00:39:50 <jle`> infinitely more, actually :)
00:40:48 <jle`> as in, the first one encodes more invariants that the reader can look at and use
00:41:33 <koz_> lyxia: OK, I think I get what the deal is with invariant functors now - thank you!
00:42:02 <paolino> jle`, it makes sense
00:42:32 <paolino> like swap
00:43:29 <paolino> parametric polymorphism is constraining, still we live of ad-hoc
00:44:09 <paolino> to share a common language
00:46:11 <paolino> everyone knows about some typeclasses so we can use the functions with combinators, without type classes, no accepted combinators/language
00:46:56 <paolino> this has implication on what we expect from functions (functors)
00:46:57 <pavonia> Does  Monoid a => a -> a -> a even have uncountably infinitely many implementations?
00:48:06 <lyxia> there are only countably many programs
00:48:08 <koz_> pavonia: Do we have uncountably-infinitely many Monoids?
00:48:48 <paolino> koz_ less than we have 'a'
00:48:55 <pavonia> For the same Monoid I mean
00:49:08 <koz_> What lyxia said also applies, pavonia.
00:50:34 <paolino> possible implementation introducing Monoid are mappend , \x y -> y `mappend` x, const mempty I guess
00:51:00 <paolino> \_ _ -> mempty better
00:52:20 <pavonia> You could also have foo x y = x <> x <> x <> ..., and then various combinations of x and y
00:52:35 <paolino> right
00:52:48 <pavonia> which is pretty similar to infinite binary representations of numbers
00:53:43 <pavonia> And then you could apply Cantor diagonalization to create a new implementation that is different from all others. Shouldn't this give more than countably infinitely many?
00:54:05 <koz_> pavonia: We can't write an infinitely-long program.
00:54:52 <koz_> And plus, there are only countably-infinitely many programs.
00:55:18 <pavonia> Yeah, but where's the error in this reasoning?
00:55:32 <pavonia> We could create infite streams of applications due to laziness
00:56:55 <paolino> (btw, tries are super fast in counting the length distribution of words i a dict)
00:58:12 <pavonia> The problem seems to be that you can give a single infinite definition, but not infinitely many of them
01:02:00 <paolino> english words length moda is 7
01:02:07 <paolino> italians 10
01:02:49 <paolino> I guess german is more, but I don't have a big german text
01:03:01 <koz_> paolino: German is a concatenative language.
01:04:13 <riaqn> Hi, in haskell how can I extend an existing enumeration type, to define another enumeration type？
01:04:35 <riaqn> I mean, data A = X | Y 
01:04:54 <riaqn> and I hope to define data B = X | Y | Z, without actually having to write X and Y.
01:05:15 <liste> riaqn: you can do data B = AWrapper A | Z
01:05:24 <ab9rf> beat me to it
01:06:01 <ab9rf> you can't use "X" as a value of type B because X is a value of type A
01:06:10 <riaqn> liste: ahh, no better solution?
01:06:13 <riaqn> OK I see.
01:07:43 <psmmr> hello there!
01:08:15 <psmmr> How to I convert a Floating a into an Integral a?
01:08:44 <cocreature> psmmr: depends on how you want to do the conversion. do you just want to cut off the decimals?
01:08:54 <ab9rf> strictly speaking, you don't
01:08:54 <psmmr> yeap
01:09:00 <cocreature> floor
01:09:06 <ab9rf> :t floor
01:09:07 <lambdabot> (RealFrac a, Integral b) => a -> b
01:09:23 <pavonia> Wouldn't it be possible to implement real sum types with a similar approach to how type classes are implemented?
01:09:43 <cocreature> pavonia: what do you mean by “real sum types”?
01:09:57 <ab9rf> pavonia: extensible enums make pattern matching challenging
01:10:27 <pavonia> Like data A = X | Y, data B = A plus Z | Z'
01:10:42 <pavonia> ab9rf: Do you have an example?
01:10:56 <ab9rf> pavonia: then the values X and Y have ambigious types.
01:11:11 <ab9rf> pavonia: is X of type A or of type B?
01:12:08 <pavonia> But you have the same problem with type classes, and in most cases you can infer the type from context
01:12:20 <pavonia> *type class functions
01:12:45 <ab9rf> how do you have the same problem with type classes?
01:12:57 <ab9rf> type classes are not the same as types
01:13:37 * hackagebot hip 1.1.0.1 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.1.0.1 (lehins)
01:14:10 <ab9rf> having multiple instances of a type class doesn't result in values having ambiguous types
01:15:08 <pavonia> I'm trying to think of a concrete example where this might be a problem
01:15:58 <pavonia> Like in "show x" you can't tell what the type of x is, you can only narrow it down to a certain class. The same could go for contructors
01:16:08 <pavonia> just with a new type contraint
01:16:34 <ab9rf> show always has the same type: Show a => a -> String
01:17:01 <ab9rf> it's a constrained polymorphic type
01:17:47 <psmmr> cocreature: floor gets a RealFrac and I just have a Floating
01:18:04 <pavonia> ab9rf: And so X could have a type (a :: A | a :: b) => a, or whatever syntax you would choose for sums
01:18:41 <ab9rf> pavonia: i have a suspicion that the type system that would result in would be unsolvable.
01:20:23 <psmmr> again I repeat: how do I truncate a Floating a into an Integral b ?
01:20:53 <psmmr> floor round and the likes are meant to get a RealFrac instead of a Floating
01:21:02 <psmmr> :t floor
01:21:04 <lambdabot> (RealFrac a, Integral b) => a -> b
01:21:08 <psmmr> :t round
01:21:09 <ab9rf> psmmr: you can't, there's nothing that iwll do that on all types a that are instances of Floating
01:21:10 <lambdabot> (RealFrac a, Integral b) => a -> b
01:21:20 <liste> psmmr: cvan you add a RealFrac constraint to the function?
01:21:28 <liste> you're writing
01:21:29 <ab9rf> psmmr: what type do you really have? Floating is a typeclass, not a type.
01:22:30 <psmmr> ilste
01:22:33 <psmmr> thank you
01:22:40 <psmmr> I guess that must be the way to go
01:23:37 <ab9rf> Floating is a typeclass of "numbers" for which trigonometric and hyperbolic functions can be defined. notably, complex numbers are Floating
01:24:38 <ab9rf> there's nothing inthe definition of Floating that would provide an expectation of an ability to convert one to an integer
02:08:31 <implementation> :t truncate
02:08:33 <lambdabot> (RealFrac a, Integral b) => a -> b
02:23:39 * hackagebot conduit-combinators 1.0.8.3 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.8.3 (MichaelSnoyman)
02:33:40 * hackagebot blaze-markup 0.7.1.1 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.7.1.1 (JasperVanDerJeugt)
02:33:42 * hackagebot blaze-html 0.8.1.3 - A blazingly fast HTML combinator library for Haskell  https://hackage.haskell.org/package/blaze-html-0.8.1.3 (JasperVanDerJeugt)
02:38:40 * hackagebot classy-prelude 1.0.2 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-1.0.2 (MichaelSnoyman)
02:38:42 * hackagebot classy-prelude-conduit 1.0.2 - classy-prelude together with conduit functions  https://hackage.haskell.org/package/classy-prelude-conduit-1.0.2 (MichaelSnoyman)
02:38:44 * hackagebot classy-prelude-yesod 1.0.2 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-1.0.2 (MichaelSnoyman)
02:38:46 * hackagebot psqueues 0.2.2.3 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.2.3 (JasperVanDerJeugt)
02:43:40 * hackagebot yaml 0.8.21 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.21 (MichaelSnoyman)
02:43:42 * hackagebot eventstore 0.14.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.14.0.0 (YorickLaupa)
02:43:44 * hackagebot stylish-haskell 0.6.5.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.6.5.0 (JasperVanDerJeugt)
02:53:41 * hackagebot websockets 0.9.8.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.9.8.0 (JasperVanDerJeugt)
02:53:43 * hackagebot websockets-snap 0.10.1.0 - Snap integration for the websockets library  https://hackage.haskell.org/package/websockets-snap-0.10.1.0 (JasperVanDerJeugt)
02:56:02 <cocreature> using +RTS -p I’m seeing callstacks that are impossible. I thought these callstacks are independent of the evaluation order used in ghc, so what can cause this?
02:56:17 <cocreature> by impossible I mean that functions that are below some other function in the callstack are definitely not called
02:58:10 <cocreature> oh can a >> b cause a callstack a -> b?
02:59:50 <cocreature> hm ParsecT looks cpsd so this seems quite likely
03:00:01 <cocreature> gnah, that’s making profiling really hard
03:25:09 <www-bukolay-net> Hi
03:25:41 <liste> hi www-bukolay-net 
03:25:54 <www-bukolay-net> Help mi
03:25:57 <www-bukolay-net> Pls
03:26:05 <www-bukolay-net> Logo error
03:26:18 <www-bukolay-net> File
03:26:20 <www-bukolay-net> How
03:28:42 * hackagebot hip 1.1.0.2 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.1.0.2 (lehins)
03:38:43 * hackagebot hakyll-filestore 0.1.5 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.5 (aergus)
03:39:06 <merijn> What's the best locality aware sort algorithm? Merge-sort?
03:44:38 <Axman6> what do you mean by locality aware?
03:46:12 <merijn> Axman6: As in, you want memory accesses to be grouped to make use of CPU caches (or in my case, since I have large data sets, operations on the same memory page, to reduce paging from disk)
03:46:32 <merijn> Axman6: So, sorts where memory accesses of the algorithm tend to cluster close together
03:46:45 <merijn> Axman6: i.e., quicksort is *awful*, since it keeps jumping around
03:47:01 <Axman6> yeah mergesort is probably a good choice
03:47:40 <merijn> Axman6: Only downside is the fact you can't do it in place. Although I seem to have found some in-place variants
03:48:06 <merijn> But since the merge is just sequential accesses and writes it's pretty good
03:48:12 <Hafydd> merijn: I think you mean "e.g."
03:48:53 <merijn> Hafydd: Yeah, I'm not to careful unless it's a paper >.>
03:49:08 <Hafydd> merijn: I suggest being more careful, then.
03:49:39 <SrPx> I have two divs side by side using display:inline-block and white-space:nowrap (on the container). This divides the layout of my site in two 600px wide blocks. When the browser is less wide than 1200px, the body doesn't expand to fit those 2 divs. That results in the top bar not going all the way to the right when you scroll right. How do I fix that?
03:49:48 <SrPx> OH damn. Sorry, wrong channel :)
03:49:56 <Boomerang> What about radix-sort? Doesn't it have good memory access patterns? It's more difficult to figure out wether it's faster or not depending on the data you're sorting though
03:50:17 * SrPx read "merijn" and wondered what he was doing on #css
03:51:11 <merijn> Boomerang: I've been considering radix-sort too, because I do have buckets, but I don't know bucket sizes in advance, which is a downside. OTOH traversing the data twice (once to discover bucket sizes and another to sort) might be faster than sorting directly
03:53:43 * hackagebot websockets-snap 0.10.1.1 - Snap integration for the websockets library  https://hackage.haskell.org/package/websockets-snap-0.10.1.1 (JasperVanDerJeugt)
03:54:12 <Boomerang> I'm afraid I don't know much more about it. If it's not too difficult to implement you could just test it and see if it makes any significant differences. Traversing the data twice could work
03:57:26 <merijn> Boomerang: Yeah, I'll need to test/benchmark a bunch of stuff anyway. Just doing some upfront research to reduce the amount to test :p
03:59:45 <merijn> Boomerang: It'd be interesting, because I'm not quite sure how well radix sort would behave, given that it the writes do end up being pretty disparate
04:01:11 <riaqn> Hi, I need some naming advice.
04:02:02 <Boomerang> merijn: If I understand well there are two types of locality, space and time. Reusing the same data close in time is very good for cache as well
04:02:02 <riaqn> What would be a good name for a class that's decode-able? that is, decode :: a -> Data.Binary.Strict.Get a
04:04:06 <merijn> Boomerang: I'm working with data that's large (i.e., hard to keep everything in RAM) so has to be paged in/out, so I mostly care about memory locality so you don't have to re-page memory pages all the time
04:04:27 <merijn> riaqn: Well, binary already has Serializable, no?
04:05:11 <riaqn> merijn: great, it's called class Binary t.
04:05:21 <riaqn> which provides both put and get
04:06:21 <merijn> riaqn: Is there a reason why it has to be a class?
04:06:41 <merijn> riaqn: Wouldn't just "Get MyFoo" by sufficient?
04:06:57 <riaqn> merijn: ahh, just some habit. 
04:07:19 <riaqn> merijn: I'm writing a DNS library, thought it would be good to make some generalization
04:07:34 <merijn> riaqn: If you just have like 1 or 2 datatypes in your library I would just expose a few explicit Get values
04:07:39 <riaqn> since I will parse headers, resource records, question records.
04:07:56 <riaqn> merijn: Well there's actually maybe seven or eight.
04:08:10 <riaqn> even if it's only one data types, I think it's good to generalize
04:08:25 <riaqn> if there is already such a type class, expressing exactly what I'm doing.
04:08:36 <merijn> riaqn: Even then, the question is "is it possible to write code that can sensibly use "decode :: Decodable a => Get a"?
04:08:51 <merijn> riaqn: Because you have to explicitly write the "Get" code anyway for each datatype
04:09:08 <riaqn> merijn: yes, the code is as much.
04:09:13 <merijn> riaqn: Whether that's stored in a class seems orthogonal and the class only makes sense if you'd ever use something polymorphic
04:09:44 <riaqn> well, you can call it a strange habbit. :-)
04:10:00 <merijn> "nameRecord :: Get NameRecord" seems a perfectly sensible API, imo :)
04:10:33 <jemendja> morning
04:10:58 <Boomerang> merijn: there are also hybrid sorting methods where you use different algorithms for different sizes so you can mix and match at different points, this page mentions a mix of mergesort and quicksort https://en.wikipedia.org/wiki/External_sorting#External_merge_sort maybe something similar with radix or other would work for you
04:11:37 <merijn> Boomerang: Well, I've found "block sort"/"block merge sort" which appears to be in-place merge sort
04:12:08 <merijn> Boomerang: Worst case O(n log n), best case O(n), worst case space complexity O(1), sounds promising :)
04:13:19 <Boomerang> It looks pretty nice (the animation that is ^^). Are you doing this in Haskell? Good luck! :)
04:13:43 <Boomerang> (animation on wikipedia)
04:13:57 <merijn> Boomerang: I need/want to get it working in both Haskell and C++ :)
04:14:27 <Boomerang> Is c++ necessary? Have you tried Rust?
04:14:54 <merijn> Boomerang: I'm working with CUDA, so C++ it is :)
04:15:26 <merijn> Boomerang: The external thing is pretty much what I'm aiming for, but I wanna skip the repeated reading in/writing out of files by just using mmap directly, because mmap == <3
04:47:47 <ebzzry> In stack.yml, what is the effect of having nix and docker set to true?
05:11:58 <kuribas> > flip runCont id $ foldlM (\a b -> cont $ \next -> if b == 0 then a else next (a+b)) 0 ([1, 5, 2, 6, 4, 6] ++ [0..])
05:12:00 <lambdabot>  24
05:31:38 <tabaqui1> Can I crate my own parenthesis?
05:31:56 <tabaqui1> like <,> :: a -> b -> <a, b>
05:32:01 <opqdonut> no
05:32:28 <tabaqui1> pity
05:32:42 <opqdonut> you can do some nifty tricks like define operators <^ and ^> suitably and then you can have expressions like "foo x <^ a b ^> y"
05:33:04 <rollick>  /WINDOW NEW   
05:33:14 <tabaqui1> mm, maybe I'll try
05:33:16 <tabaqui1> thx
05:33:25 <opqdonut> don't remember where I saw that
05:33:59 <mathk> Hi all I would need some help to understand a dependency issue. And how to solve them if possible. Here is a kind of issue I am having: http://pastebin.com/T6zY71b3
05:34:53 <kuribas> tabaqui1: you can define infix constructors
05:35:12 <tabaqui1> kuribas: I know, but it's not the same
05:35:25 <tabaqui1> mathk: wellcome to d.hell
05:35:46 <tabaqui1> I very recommend you to use stack
05:36:08 <tabaqui1> if there is a confilict between system libs and project dependencies, stack will help you
05:36:31 <tabaqui1> otherwise, only the stars help you
05:36:36 <mathk> ok, is stack a replacement of cabal ?
05:36:52 <merijn> mathk: Your compiler is to new for threepenny-gui
05:37:07 <merijn> mathk: (i.e. threepenny-gui hasn't updated to support the new GHC yet)
05:37:14 <dcoutts> mathk: cabal-install and stack are alternatives, both build on Cabal the spec + build system
05:38:01 <merijn> mathk: As always, my advise to beginners is pick the newest-but-one version of GHC, rather than bleeding edge
05:38:07 <mathk> dcoutts, so if i understand you, I can keep my *.cabal file and start using stack ?
05:38:18 <dcoutts> mathk: yes
05:38:46 <Boomerang> Well the later versions of threepenny-gui do support a more recent base but the package you are using Hoed forces you to use version 0.6.0.5 of threepenny-gui. The simplest thing to do if you don't need the latest base is to downgrade it to <4.9
05:39:32 <grazie> anyone here use vim with haskell that can share how to get a list of methods in a file -- the way that `cmd r` does in SublimeText?
05:39:37 <Boomerang> But yeah use stack if you can! :)
05:39:52 <mathk> Boomerang, yeap I wanted to try this Hoed. But downgrading to <4.9 mean that I need to install a older ghc.. ?
05:40:10 <merijn> mathk: Yes
05:40:32 <Boomerang> Ah yes 4.9 is the limit between ghc7 and ghc8
05:40:41 <merijn> mathk: But I would recommend sticking with 7.10 for now anyway :)
05:40:51 <mathk> ok I will give stack a try, Does it has the sandbox concept and so on ?
05:41:06 <Boomerang> mathk stack sandboxes everything by default
05:41:13 <tabaqui1> grazie: I have some plugins to do so
05:41:15 <mathk> merijn: oh I see, stack is a kind of selection tool .
05:41:25 <Boomerang> you can just do stack init to make it use your current .cabal file
05:41:38 <tabaqui1> grazie: I think it elaforge/fast-tags
05:42:12 <tabaqui1> but not sure, there are 8 strings, but it looks the closest
05:42:43 <grazie> tabaquil: thank you, I'll have a look.  vim's native folding isn't doing anything with my haskell file (unless I'm doing it wrong)
05:43:30 <merijn> grazie: There's no syntax folding for haskal, afaict
05:43:40 <merijn> grazie: You could try simply ":set foldmethod=indent"
05:44:13 <tabaqui1> grazie: foldmethod syntax doesn't work well,
05:44:26 <tabaqui1> dunno, maybe you will find a plugin
05:45:33 <grazie> thanks, trying this ":set foldmethod=indent" now 
05:45:34 <boxscape> grazie: twinside/vim-haskellfold provides folding
05:46:28 <grazie> all I really want is a way to see a list of all function (and type) names in a file, with or without folding, which way would you recommend
05:46:40 <absence> http://lpaste.net/347437 <- how is this kind of "object oriented data" best represented with ADTs?
05:47:44 <boxscape> grazie: you could use tagbar - it's a plugin that let's you have open a window with all functions where you can jump to each one. I think lushtags for haskell supports it
05:50:43 <hodapp> absence: I'd say common ways are simply composing rather than inheriting, and sometimes using typeclasses
05:52:15 <mrkgnao> so I'm thinking about writing a little game that you can play by writing bots for it
05:53:23 <mrkgnao> essentially, every player has >=1 "drones" on a grid, and those drones can move around independently
05:53:49 <mrkgnao> and the drones leave trails, and if the trail encloses a region then it becomes the player's territory
05:54:30 <mrkgnao> this is *exactly* the same idea as <http://splix.io/>, except for the >1 drones part
05:54:45 <mrkgnao> how do I represent ownership of territory on a very large grid?
05:56:34 <merijn> mrkgnao: Well, how big do you plan to make your grid in total? How many players?
05:56:53 <lpaste> Will1 pasted “DB testing” at http://lpaste.net/347440
05:57:00 <merijn> mrkgnao: Naively you could just have a NxM array storing ownership at every coordinate, but for large grids that becomes untenable
05:57:46 <Boomerang> mrkgnao, since the regions owned are also going to be a set of rectangles you could try to only keep the top-left and bottom-right coordinates and do some kind of 2D AABB (Axis Aligned Bounding Box) algorithm to check if a point is inside or outside of a region
05:57:59 <Will1> Can someone advise a noob about writing tests that do stuff with a database.  I have the following test, which uses unsafePerformIO, which I know is generally considered bad.  But if I cannot connect to the DB, or my SQL is malformed, an exception in the test suite seems an OK way to know that? http://lpaste.net/347440
05:57:59 <Boomerang> s/also/all
05:58:03 <merijn> mrkgnao: Then you probably want to store ownership as combinations of rectangles and use a quadtree for storing the geometry
05:58:33 <merijn> @quote Lemmih not.a.bug
05:58:33 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
05:58:35 <frontendloader> Will1: mocks, my ninja
05:59:08 <mrkgnao> merijn: big enough that a naive array doesn't sound like the best idea
05:59:30 <mrkgnao> Boomerang: actually, I'm *sort of* thinking about a hexagonal grid
05:59:32 <merijn> mrkgnao: On the one hand, you're right, on the other, you can store some pretty big arrays quite easily ;)
05:59:54 <mrkgnao> let's just say I want to learn how to do it differently, then?
06:00:00 <Will1> @frontendloader - What would I gain by mocking the database?  It seems like I would be testing less stuff if I did that.
06:00:00 <lambdabot> Unknown command, try @list
06:00:30 <Boomerang> mrkgnao: you can still represent a hexagonal grid with simple x y coordinates, bounding boxes might be a bit more complicated though
06:01:00 <mrkgnao> there's actually an interesting way to represent a hexagonal grid with x, y, and z coordinates
06:01:01 <frontendloader> the idea is to not test the connection to the DB
06:01:07 <grazie> ctags ( a dependency of tagbar plugin) seems to support every language except haskell...
06:01:21 <frontendloader> or even test the DB at all
06:01:28 <frontendloader> it's your code you want to test
06:01:30 <mrkgnao> <http://www.redblobgames.com/grids/hexagons/>
06:01:41 <Boomerang> The best reference for exagonal grid maths I know is: http://www.redblobgames.com/grids/hexagons/
06:01:45 <Boomerang> Oh yeah that one ^^
06:01:48 <mrkgnao> haha
06:02:00 <Will1> Sure - but if all my code does is create a query "select * from users", and send that query to the DB, it seems not worth testing
06:02:11 <Boomerang> I made a small game on a hexagonal grid myself, I didn't need a big grid though
06:02:22 <frontendloader> what does it do with the return result?
06:02:45 <Will1> It converts it into a value of type User - which I do have a test for
06:03:27 <mrkgnao> Boomerang: so what do you think I should do?
06:04:25 <grazie> yep, sadly tags plugin doesn't work with haskell
06:05:58 <boxscape> grazie: you mean tagbar? It works for me, as long as I use it with lushtags. the lushtags github page has some info about installing it with tagbar
06:06:21 <grazie> boxscape: oh, ok, I'll look at lushtags
06:08:21 <kuribas> Hexagonal grids are very common for strategy games.
06:08:41 <Boomerang> mrkgnao, I'll have to think about it a bit, if you're going to do some kind of bounding boxes to represent the regions that are owned I am not sure what shape would be the fastest while having as few of them as possible. Maybe x y z would be beneficial for this particular case
06:10:45 <grazie> boxscape when I tried to build lushtags, it said "Failed to load interface for ‘Language.Haskell.Exts.Annotated" 
06:11:05 <grazie> boxscape: how would you install lushtags so that all necessary dependencies are installed
06:11:13 <boxscape> grazie: did you install it with stack?
06:11:23 <grazie> cabal install lushtags didn't do the trick... No, I didn't use stack
06:11:47 <boxscape> doing it with stack should work, I think. 
06:11:50 <grazie> boxscape: stack install lushtags?
06:11:54 <boxscape> yes
06:12:12 <boxscape> or wait a second
06:12:30 <boxscape> grazie: I actually cloned the github repo into a local folder and ran `stack install` from there
06:12:36 <lyxia> it's not on stackage
06:12:36 <boxscape> I think I had to do that for some reason
06:12:40 <boxscape> ah, that would be why
06:13:12 <grazie> boxscape: does it matter which dir I clone it into? can I clone it into the dir where cabal installs everything for system?
06:13:45 <boxscape> you can... but I don't think I'd do that. I would clone it into a separate directory, and stack will install the executable into the same directory as cabal would
06:14:57 <kadoban> I don't think cabal and stack usually install in the same place. Stack installs executables to ~/.local/bin/ by default
06:15:16 <boxscape> oh, you're right, soryr
06:15:57 <kadoban> But that's a pretty minor detail
06:17:28 <boxscape> just to confirm... you don't have to run `stack build` before you run `stack install`, do you?
06:17:43 <boxscape> (in general)
06:17:57 <kadoban> boxscape: No, it's implicit
06:18:01 <boxscape> okay, thanks
06:18:15 <grazie> according to lushtags github, you do have to run stack build first, but I didn't
06:18:23 <boxscape> right, that's why I'm asking
06:18:24 <grazie> seems to be working now ... thank you for your help
06:18:30 <boxscape> no problem
06:20:12 <absence> hodapp: http://lpaste.net/347437 <- something like this?
06:21:37 <nevere> In Haskell what is the best Datatype to use to represent Money values?
06:21:55 <merijn> nevere: Do you just want fixed precision?
06:22:27 <Boomerang> Int/Integer for cents? Or do you need to have fractions of cents/pence?
06:22:47 <merijn> > 10.10101 :: Centi
06:22:49 <lambdabot>  10.10
06:23:31 <boxscape> > 0.1 + (0.2 :: Centi)
06:23:34 <lambdabot>  0.30
06:23:35 <boxscape> nice
06:24:02 <merijn> boxscape: It's just a synonym for Data.Fixed, which lets you specify whatever precision you want
06:24:07 <Hafydd> > let tau = 2*pi in fromRational $ toRational tau :: Centi -- Tau Centi
06:24:07 <nevere> merijn: Yes
06:24:10 <lambdabot>  6.28
06:24:25 <boxscape> merijn: right, I just looked it up and saw that :)
06:24:43 <merijn> nevere: Then use Centi/Fixed E2
06:26:23 <wagnerf> hi everyone, I have a list of type [Maybe a] and I want to get the first non-Nothing value if there is one or Nothing if its all Nothing
06:26:39 <wagnerf> I have a solution but it's kind of long
06:27:01 <merijn> :t listToMaybe . catMaybes
06:27:02 <kadoban> wagnerf: I believe that's listToMaybe from Data.Maybe
06:27:03 <lambdabot> [Maybe a] -> Maybe a
06:27:22 <kadoban> Oh, ya that, my bad.
06:27:44 <wagnerf> thanks
06:27:49 <mettekou_> Is there a way to refactor the given snippet (line 30 to 38) from the following example: https://gist.github.com/mettekou/760132bed9ca1829e0165709003f37a6#file-term-hs-L30-L38.
06:31:24 <haskell493> @pl f x = (,) <$> pure (fst x) <*> snd x
06:31:24 <lambdabot> f = ((,) <$>) . uncurry ((<*>) . pure)
06:31:44 <kuribas> :t foldr (<|>) Nothing
06:31:45 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
06:32:07 <rvion> Hi, do you know if ghc bindist are compiled with llvm ? If not, is it possible at all, and would it speed up ghc compile time ?
06:32:44 <rvion> (ghc compie time -> the time needed by ghc to compile some other haskell code)
06:36:07 <merijn> rvion: I doubt it'd make things faster
06:36:35 <merijn> rvion: At least, not a lot. Main advantage is that the LLVM backend produces faster code in some case (mostly numeric heavy applications)
06:38:39 <absence> http://lpaste.net/347437 <- is the lower part how one would express the upper part with ADTs?
06:48:57 <rvion> merijn: thanks for the answer. Is there some benchmarks available, or guides toward benchmarking the 2 ? 
06:49:33 <mrkgnao> Boomerang: maybe an octree?
06:49:50 <rvion> merijn: even a 5 or 10% compile time decrease would be a huge gain for the community
06:49:55 <mettekou> absence: Inheritance requires subtyping, which cannot be mimicked by sum and product types alone. In the second example, a term of type S2and1 cannot be used where a term of type S1 or of type S2 is expected.
06:52:01 <mettekou> absence: A way to simulate this in Haskell would be to link the types S2and1 and S1 by making each of them an instance of a type class HasS1 which has three methods: a, b, and c.
06:52:57 <mettekou> absence: But since your syntax is pseudo-C, I don't assume you want to try this in Haskell.
06:56:27 <Boomerang> mrkgnao: Yeah octree sounds appropriate since you can look at your hexgrid as some kind of cube (using the x y z coordinate system) and then subdivide in 8 smaller cubes. This looks very exiting, would love to see the results! :)
06:57:23 <mrkgnao> yep, me too!
06:59:17 <mrkgnao> but I think I'm going to write a little troll game in Gloss as a warmup first, like a tic-tac-toe or something, to get familiar with the setup
06:59:48 <peddie> :t asum  -- kuribas, were you looking for this?
06:59:51 <mrkgnao> currently stack is downloading the 7.11 cabal hashes, and this can be painful on an Indian internet connection :/
06:59:53 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
07:00:22 <Tuplanolla> Is there a tool to find unused return values in foreign code (well, C) the way GHC warns about `f` instead of `_ <- f` inside a `do` block?
07:00:25 <kuribas> > asum [Nothing, Just 2, Just 3]
07:00:30 <lambdabot>  Just 2
07:01:00 <kuribas> peddie: not me, wagnerf 
07:01:04 <peddie> oh, I see, it was wagnerf originally -- wagnerf, check out asum
07:04:45 <absence> mettekou: right, i'm trying to port some stuff from c++. going to get rid of some inheritance that isn't strictly needed, which is why i wanted to express the types without inheritance
07:05:14 <kuribas> peddie: ah, it's in Data.Foldable.  I was looking in Control.Applicative.
07:11:03 <mettekou> absence: If you would like the code reuse available in object-oriented languages through inheritance, the paper Data Types à la Carte's approach is an option.
07:13:13 <absence> mettekou: ah yes. a bit too heavy machinery for my use case, but definitely nice
07:14:08 <kuribas> > asum $ [Nothing, Just 2] ++ repeat (Just 3..)
07:14:10 <lambdabot>  <hint>:1:43: error: parse error on input ‘..’
07:14:16 <kuribas> > asum $ [Nothing, Just 2] ++ repeat (Just 3)
07:14:19 <lambdabot>  Just 2
07:21:08 <hackrilege> Does anyone know anything about type level Ints? I'm trying to represent nd space as nested lists of depth n
07:23:45 <hackrilege> I figure I can do this by creating an integer parameterized version of list and requiring it to contain a list of decrimented Int parameter
07:24:38 <hackrilege> I guess I could use Free, maybe adding the type level Int parameter to indicate the degree of nesting
07:26:13 <mizu_no_oto_work> hackrilege: what do you mean, "nested lists of depth n"?  Would [[[a]]] have depth 3?
07:26:24 <hackrilege> Yes
07:27:06 <mizu_no_oto_work> Why do you want to use type-level ints for this?
07:28:11 <hackrilege> I can just use Int? I thought maybe I would need the Int during pattern matching
07:28:19 <byorgey> hackrilege: reminds me of http://hackage.haskell.org/package/repa
07:30:07 <hackrilege> I guess you could call what I'm doing a study of a subset of the functionality of repa, I wish to test alternative algorithms though, with priority on legibility and 0 dependencies as I will have to present all theoretical framework rigorously
07:31:22 <hackrilege> One consideration is that the tuples or lists contained as the elements of the nd grid should be of length n
07:32:25 <hackrilege> I guess some way to handle this without Int parameters would also be satisfactory
07:35:29 <hackrilege> I'm surprised I can't find references for such a structure, it seems like it would be common
07:36:57 <hackrilege> I guess the reason I suspect a parameter is necessary is so that it can be provided to the elements...
07:37:44 <merijn> hackrilege: Exactly what do you plan to study?
07:38:06 <hackrilege> Many body dynamics in nd space
07:38:26 <merijn> Yeah...that seems like a particular poor choice of data structure, then
07:38:40 <hackrilege> Oh? Go on
07:39:21 <merijn> Nested lists have *awful* characteristics when it comes to performance, especially when doing something numerical like many body simulations
07:39:31 <hackrilege> Ok so there is another motivation of using difference lists and zippers to provide constant time nearest neighbor lookup
07:41:23 <hackrilege> I guess that's the fundamental algorithm I wish to investigate, I have studied this using Free Zippers and it worked great, but now I wish for my contained elements to be parameterized by the same Int as the container and I'm just trying to think how to do that. Don't worry so much about why, I'm just worried about how
07:41:25 <merijn> hackrilege: Nearest neighbours in n dimensions would be better off using either quad-/octtrees (assuming 2 or 3 dimensions) or trees inspired on that using alternating splits
07:42:33 <merijn> hackrilege: I'm just warning you that down this path lies performance that will quickly become unusable, even for small numbers :) So if you plan to actually use it to compute something you're better off abandoning it
07:43:02 <hackrilege> Yes that's what I'm using
07:43:04 <hackrilege> The list representation is a first step before I add the Free Free Zipper which operates in the way you describe
07:43:30 <hackrilege> It's not ready for presentation yet sorry, I just want to worry about this parameterization problem presently
07:44:11 <hackrilege> I understand, I plan to show there is utility in the approach however
07:44:54 <hackrilege> So performance issues aside, I just want to understand how to implement such a structure
07:45:36 <hackrilege> Sorry to be obstinate :/
07:47:35 <merijn> You'd have to introduce a Peano number at the type level (since Nat in GHC doesn't support arithmetic yet, afaik), and use GADTs to enforce the nesting
07:47:56 <hackrilege> Aha, I thought as much
07:48:31 <hackrilege> I was searching for Church rather than Peano, thanks
07:48:54 * hackagebot servant-auth 0.2.1.0 - Authentication combinators for servant  https://hackage.haskell.org/package/servant-auth-0.2.1.0 (jkarni)
07:48:56 * hackagebot servant-auth-client 0.2.1.0 - servant-client/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-client-0.2.1.0 (jkarni)
07:48:58 * hackagebot servant-auth-docs 0.2.1.0 - servant-docs/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-docs-0.2.1.0 (jkarni)
07:49:00 * hackagebot servant-auth-server 0.2.1.0 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.2.1.0 (jkarni)
07:50:12 <hackrilege> Oh it's basically just Free ()
07:50:51 <c_wraith> That doesn't kind-check
07:50:57 <hackrilege> Can you say something more about "using GADTs to enforce the nesting"
07:51:25 <hackrilege> Free (,)?
07:51:32 <c_wraith> Also doesn't kind-check. :P
07:51:40 <c_wraith> Free ((,) a)
07:51:42 <c_wraith> that does!
07:51:58 <hackrilege> What about Free ((),)
07:52:12 <c_wraith> syntax error, but if you fix that it works.
07:52:35 <c_wraith> There aren't type-level sections
07:52:58 <hackrilege> Free Const?
07:53:06 <c_wraith> Wrong kind.
07:53:13 <c_wraith> Free's first argument must have kind * -> *
07:53:19 <c_wraith> Const is * -> * -> *
07:53:40 <c_wraith> actually, I guess Const *could* be polykinded to * -> k -> *
07:54:41 <c_wraith> Looks like Const is polykinded, so.. the latter
07:55:23 <hackrilege> Free Identity
07:55:49 <c_wraith> Free Identity is basically a peano number
07:55:55 <c_wraith> Is that what you were going for?
07:56:06 <hackrilege> Yay, it was
07:56:38 <c_wraith> Well.  It's a bit more.
07:56:46 <hackrilege> merijn, what did you mean about using GADTs?
07:57:05 <hackrilege> How do you mean a bit more?
07:57:06 <c_wraith> It's a peano number + another value at the end.
07:57:29 <hackrilege> Free Identity ()
07:58:06 <c_wraith> I mean, that still has another value at the end, it just is likely to be boring. :)
07:58:30 <c_wraith> (It's either boring or bottom)
07:58:31 <hackrilege> What?
07:58:45 <hackrilege> I don't get this bit sorry....
07:59:29 <c_wraith> A value of type () is still a value.  And it's a lifted value, so it could be undefined, an infinite loop, a call to error, things like that.
07:59:54 <c_wraith> If it evaluates to (), it was probably boring.  If it doesn't, it was denotationally bottom.
08:00:35 <c_wraith> it might not be boring if it evaluated to () but forced other evaluation at the same time due to previous uses of seq.
08:00:48 <c_wraith> rnf does that, for instance.
08:00:54 <c_wraith> :t rnf
08:00:55 <lambdabot> error: Variable not in scope: rnf
08:01:20 <c_wraith> @let import Control.DeepSeq
08:01:26 <lambdabot>  Defined.
08:01:29 <c_wraith> :t rnf
08:01:29 <hackrilege> Oh ok, is there a kind * object like Null that I should use? I kind of thought that's what () was...
08:01:33 <lambdabot> NFData a => a -> ()
08:01:40 <hackrilege> :t ()
08:01:41 <lambdabot> ()
08:01:48 <hackrilege> !?
08:01:54 <c_wraith> () is a value of type ()
08:03:05 <c_wraith> hackrilege: there is the Void type, but it isn't what you want in this case.  () is a better fit.  I was just saying that it is a real value.  (Void is a lifted type too, so it also has values - but all of them are bottoms)
08:04:43 <hackrilege> I'm thinking I might just stick to the usual definition of Piano to avoid all of this stuff
08:04:54 <c_wraith> Sounds much saner to me. :)
08:05:03 <hackrilege> Did you understand what merijn meant about GADTs?
08:05:58 <hexagoxel> do large number of quasiquotations commonly slow down compilation times significantly? (40 sec for 600 line module with 100 qqs) (the QuasiQuoter in question is completely trivial, so i doubt this has anything to do with the specific qq.)
08:06:25 <hackrilege> (merijn) You'd have to introduce a Peano number at the type level (since Nat in GHC doesn't support arithmetic yet, afaik), and use GADTs to enforce the nesting
08:06:52 <c_wraith> I know the general approach.  data Zero ; data Succ ; data Foo n a where Cons :: a -> Foo n a -> Foo (Succ n) a ; Nil :: Foo Zero a
08:07:07 <c_wraith> Err, data Succ n
08:08:15 <hackrilege> data Peano = Zero | Succ Peano
08:08:30 <c_wraith> That creates value-level Peanos, not type-level
08:08:37 <hackrilege> Oh noes
08:08:37 <c_wraith> Unless you're also using DataKinds and promote it
08:08:44 <hackrilege> Woah
08:08:51 <hackrilege> You can do that!?
08:09:03 <c_wraith> Yeah, that's the main purpose of the DataKinds extension
08:09:08 <hackrilege> Sounds extreme
08:10:23 <c_wraith> data Peano = Zero | Succ Peano ; data Foo (n :: 'Peano) a where Nil :: Foo 'Zero a ; Cons :: a -> Foo n a -> Foo ('Succ n) a
08:10:41 <c_wraith> the leading ' means promote the following name.
08:10:52 <c_wraith> It promotes values to types, and types to kinds
08:12:35 <hackrilege> Oh my god
08:12:43 <hackrilege> I'm not ready for this
08:13:00 <c_wraith> Then don't worry about it.
08:13:05 <c_wraith> Stick with the first version.
08:15:10 <hackrilege> I guess there is no harm in taking a moment to get to grips with this concept of promotion, it might help me keep up with my reading on lens
08:15:24 <c_wraith> Eh, lens doesn't use it.  :)
08:15:42 <c_wraith> In all honesty it's not heavily used outside of packages like Servant
08:15:42 <mmaruseacph2> servant does, on the other hand, afaik
08:15:50 <mmaruseacph2> jinx
08:15:54 <c_wraith> :)
08:16:18 <hackrilege> I'm seeing something called BOX, what's that about?
08:16:59 <c_wraith> that's the Sort of everything
08:17:06 <c_wraith> Sort is the layer above kind
08:17:20 <hackrilege> And is "sort" the next item in the sequence... You just answered my question
08:17:49 <mmaruseacph2> what's above Sorts?
08:17:58 <c_wraith> hackrilege: fwiw, http://lpaste.net/347487 is the simpler version, run through ghci to make sure it's free of typos :)
08:19:18 <hackrilege> Argh, that's confusing. Values have types, type constructors have kinds and ? "Kind constructors have sorts" ? It's too abstract to conceive
08:19:27 * ski has sometimes seen "sort" as a generic term for types, kinds, &c.
08:19:38 <c_wraith> mmaruseacph2: Not sure.  I don't think it matters too much, given that TypeInType collapses everything above kinds
08:19:47 <mmaruseacph2> on the other hand, it has to be like this to prevent Russel paradox
08:19:48 <ski> (more or less, anything that can stand to the right of `::')
08:20:09 <ski> s/constructors //
08:20:11 * mmaruseacph2 is curious if he can recreate barber's paradox with TypeInType
08:20:13 <c_wraith> mmaruseacph2: TypeInType allows the Russell paradox.  It's ok.
08:20:17 <mmaruseacph2> jinx
08:20:21 <shapr> yay haskell code, w00t!
08:20:29 <ski> nginx
08:20:55 <hackrilege> Everyone seems quite excited
08:21:07 * ski imagines shapr is boinging on chair
08:21:09 <c_wraith> Haskell already is unsound by way of undefined :: a
08:21:17 <mmaruseacph2> that's true
08:21:22 <c_wraith> So allowing Russell's paradox is no big deal. :)
08:21:26 <hodapp> c_wraith: get out of here, Bob Harper
08:21:56 <shapr> harpers gonna harp
08:21:58 <mmaruseacph2> afaik, there was a acme-* package proving false
08:22:03 <c_wraith> hodapp: unlike Bob Harper, I admit that ML has the same issues, you just need a function call involved. :)
08:22:05 <hackrilege> Descended into chaos, I shall return later
08:22:14 <hodapp> shapr: ...whoa, that actually fits
08:22:15 <hackrilege> Thanks for the help
08:22:28 <ski> c_wraith : "same issues" being ? (i came in late)
08:22:35 <shapr> hodapp: I stole it from bos
08:23:04 <c_wraith> ski: the type system is unsound.
08:23:19 <c_wraith> Because it allows non-termination.
08:24:14 <c_wraith> In practice it's usually easier to have an unsound type system than a termination checker.
08:24:16 <ski> one could think of it as a value of type `int' must be defined, but a function of type `unit -> int' can fail to return a defined value
08:24:50 <ski> but if we instead thing of expressions, then already an expression of type `int' can fail to denote a defined value
08:25:01 <ski> (s/thing/think/)
08:25:14 <c_wraith> are you quoting?
08:25:23 <ski> i'm not
08:26:05 <thomasd> anyone here familiar with template haskell enough to ponder a slightly detailed question?
08:26:12 <c_wraith> Ah.  It does sound like something he'd say.  (He has admitted basically that before, he just makes it sound like it's personally painful to do so)
08:26:39 <c_wraith> thomasd: depends on the parts of template haskell you're using.
08:27:02 <jita> I am a python developer and want to learn functional programming, which language will be easier to learn clojure or haskell or any other ?
08:27:02 <thomasd> from what I know about it, the basic parts, hah, maybe I should just ask 
08:27:16 <ski> (just saying that, from the latter of the above viewpoints, it's, in some sense, not function calls (specifically trying to evaluate the result of them) that brings non-termination, but expressions (versus values, in the MLs))
08:27:35 <c_wraith> jita: Haskell is probably not the easiest.  It's the most radical.  But it might be the most enlightening because it doesn't give you ways out.
08:27:40 <thomasd> I pass in a constructor name to a function in the Q monad (quasi quoter), and I want to pattern match on this constructor inside a quasi quote
08:28:06 <ski> (of course, how does an expression fail to denote a defined value ? often, it's by calling a function. but even SML has `while' loops, so you could use that instead)
08:28:13 <suppi> jita clojure will probably be less of a paradigm shift
08:28:19 <thomasd> so I end up with something like "case res of $(conP nmQ) q -> ... do something with q ..."
08:28:22 <jita> c_wraith, should I take a least resistance path? Learning easier one first before diving deep into haskell or do you recommend haskell as a starting point ?
08:28:33 <thomasd> but it tells me theres a parse error on $(conP nmQ)
08:28:37 <ski> c_wraith : painful to admit it, or what ?
08:28:46 <thomasd> where nmQ is the name of the constructor I want to pattern match on
08:29:03 <c_wraith> ski: he never likes to say anything bad about sml. :)
08:29:34 * ski likes all three of Haskell, SML, OCaml
08:29:42 <c_wraith> jita: for what it's worth, Haskell was the hardest language to learn I've ever come across.  It was actually deeply different.  It's also been the most rewarding language to learn I've ever gone through.
08:29:48 <ski> (possibly in that order .. depending a bit on what one's discussing)
08:30:01 <suppi> jita, if haskell is your target learn Haskell and not Clojure :)
08:30:24 <hodapp> both Clojure and Haskell will turn your brain inside out a bit if you've never worked with a Lisp or with statically-typed FP
08:30:32 <hodapp> they go about it different ways
08:30:48 <c_wraith> jita: also, don't mistake what I'm saying - I think haskell is a very practical language for building software.  It's just..  different.
08:30:55 <jita> so learning one from the other will be challenging ?
08:31:02 <hodapp> it's going to be challenging regardless
08:31:03 <suppi> yes
08:31:24 <hodapp> Haskell will also make you realize how many "different" languages are just identical languages with slightly different frosting
08:32:40 * ski cakes the ice
08:32:51 <jita> any suggestions for ocaml ? Is it easier to learn than haskell ? But still closer to haskell ?
08:33:22 <c_wraith> Sadly, I think elisp has ruined all lisps for me.
08:33:30 <jita> The thing is i am afraid of starting haskell without any functional background and I want to learn some language which will prepare me for haskell
08:33:33 * ski would probably suggest SML over OCaml
08:33:38 <suppi> jita: all languages are interesting, depends on your goals
08:33:45 <hodapp> except for the languages that aren't
08:33:47 <hodapp> at all
08:33:49 <jita> suppi, goal is to learn functional programming concepts
08:34:16 <suppi> jita: don't be afraid of learning Haskell. use a quality resource like haskellbook.com
08:34:42 <ski> jita : in any case, i think it's well worth to learn one of the MLs, because of the awesome module system (so, SML, or OCaml, or maybe Alice ML (more experimental/researchy) .. F# sadly doesn't include the module system)
08:34:42 <boxscape> I feel like learning functional concepts might be easier if you do it in a language that really embraces it rather than something that's something inbetween python and haskell, or something like that
08:34:49 <suppi> also try the programming languages course from Washington U on coursera
08:34:58 * ski has often wanted an ML-style module system in Haskell
08:35:00 <hodapp> depending on what form of 'functional programming' that means, I'd also suggest reading SICP or reading Software Foundations (https://www.cis.upenn.edu/~bcpierce/sf/current/index.html)
08:35:07 <c_wraith> ski: so how about backpack?
08:35:24 <jita> cool thanks a lot guy I would definitely look into haskell book and hopefully understand it !!
08:35:25 <jita> :)
08:35:34 <ski> c_wraith : is there a prototype implementation ?
08:35:48 <suppi> jita, https://www.coursera.org/learn/programming-languages
08:35:53 * ski keeps meaning to look into Backpack, then forgets it exists again .. :/
08:36:05 <c_wraith> ski: It sounded like it, when ezyang was writing up how it works.  It looked like there's a prototype.
08:36:06 <ski> @where SICP
08:36:06 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
08:36:06 <lambdabot> Packages"
08:36:16 <jita> suppi, thanks 
08:36:47 <suppi> bye
08:38:30 <c_wraith> ski: there is a prototype, if you're willing to compile all sorts of stuff :)  http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
08:38:45 <ski> c_wraith : Scheme is worthwhile to learn, because of hygienic macros, (staged programming, and also continuations, if one doesn't already know about them)
08:39:16 <c_wraith> Scheme has undelimited continuations, right?
08:39:41 <ski> btw, Scheme48 (a Scheme implementation) also has a version of the ML module system (obviously without types, but still useful, including module functors)
08:40:36 <ski> c_wraith : yes, but you can implement delimited ones in terms of them and state (some implementations have a primitive implementations of delimited/composable/sub- continuations, for efficiency. e.g. PLT Scheme^W^WRacket)
08:41:01 <c_wraith> ski: you could just define delimited continuations in terms of functions too. :)
08:41:19 <ski> (the Scheme48 version also includes syntax (aka macros) in the signatures of the modules, iirc)
08:42:40 <ski> c_wraith : not if you're having a language with continuation *side*-effects, as opposed to encoding continuation effects with something like `Cont' (or rather `Cont2') in Haskell
08:43:42 <ski> of course, applying Filinski's "Representing Monads", you can "reflect" any monadic effect that you can implement in the language into a corresponding monadic *side*-effect, given composable continuation side-effects
08:45:29 <kuribas> ski: IMO undelimited continuations make the language more difficult to implement, with little benefits.
08:46:20 <ski> yes, there's an argument that there's naturally some kind of dynamic delimiter anyway, e.g. the current prompt in the interactor, or the start of the process
08:47:05 <c_wraith> Did Oleg write a paper making that argument?  I know I've read it.
08:47:12 <c_wraith> I can't remember who it was by.
08:47:32 <ski> i don't recall where i read it (or if it included the part about start of process)
08:47:42 <kuribas> What's the type of an undelimited continuation?
08:47:51 <ski> logically, it's negation
08:48:02 <ski> in SML/NJ, there's a `cont' type constructor
08:48:09 <ski> you can program e.g.
08:48:29 <ski>   val excluded_middle : unit -> ('a cont,'a) either
08:48:31 <hackrilege> What is this stuff about ml modules?
08:48:45 <hackrilege> It's about orphaned instances right?
08:48:48 <c_wraith> Oleg did write something about it...  http://okmij.org/ftp/continuations/undelimited.html
08:48:55 <c_wraith> hackrilege: ML doesn't have instances.
08:49:18 <hackrilege> Ok, so what is so great about it's modules
08:49:22 <c_wraith> hackrilege: It's about a different approach to writing code that works over multiple types.
08:49:32 <hackrilege> What is backpack attempting to bring to Haskell?
08:49:48 <c_wraith> A different flavor of non-parametric polymorphism than type-classes.
08:49:50 <ski> when evaluating `excluded_middle ()', it'll first return `Left k', `k' being a continuation. when (if) you later jump (not apply) that continuation to a value `x', then the *same* call to `excluded_middle' will return again, this time `Right x'
08:50:00 <ski> so, it behaves a bit like backtracking
08:50:36 <hackrilege> Yuk
08:50:41 <ski> hackrilege : you can write "functions" that take a module (of a specified signature) as input, and produces another module as output
08:51:01 <hackrilege> Module!?
08:51:09 <ski> hackrilege : so you can e.g. parameterize your code on which implementation of some datastructure you're going to use
08:51:16 <hackrilege> Passing libraries as arguments!?
08:51:21 <ski> hackrilege : exactly ! :)
08:51:33 <hackrilege> So extreme
08:51:53 <ski> hackrilege : in the vanilla version of the ML module system, this all happens statically (at the latest, at link-time). there's extensions, where you can also do this at run-time
08:52:18 <hackrilege> I guess I should look into vanilla
08:52:25 <ski> hackrilege : these "module functions" are called "functors" (not related to the category theoretic notion of functor that Haskell has more or less borrowed)
08:52:35 <ski> @where on-functors
08:52:35 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
08:53:05 <ski> (that's just about the different notions of "functor", used in programming)
08:54:02 <ski> in extended versions of the module system, you can even have higher-order functors
08:55:39 <hackrilege> :(
08:56:10 <ski> (and there were some practical example which motivated that, that i saw, but that i don't recall now :/ ..)
08:57:34 <ocharles_> Does anyone know why this code compiles in GHC 7 but not GHC 8? https://gist.github.com/ocharles/ce0f7cca78011cbcb0696c3c6c8053b2
08:57:44 <ocharles_> The line 93 referred to there is line 30 in the paste
08:59:13 <ocharles_> If I manually add "getAppExtra = lift getAppExtra" (and the same for each method in that class), it compiles.
08:59:26 <ocharles_> that is, I copy and paste the default implementations verbatim
09:03:58 * hackagebot katip 0.3.1.1 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.3.1.1 (MichaelXavier)
09:12:46 <puregreen> I've got an issue about a library I maintain not building on ARM (https://github.com/ChrisKuklewicz/regex-tdfa/issues/3) and I don't know how to proceed with it (because I don't have an ARM machine). Any advice? Is there something Travis-CI-like that provides ARM, or maybe an easy way to simulate ARM on x86?
09:13:58 * hackagebot katip-elasticsearch 0.3.0.1 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.3.0.1 (MichaelXavier)
09:14:00 * hackagebot java-adt 0.2016.11.28 - Create immutable algebraic data structures for Java.  https://hackage.haskell.org/package/java-adt-0.2016.11.28 (AndreasAbel)
09:14:21 <puregreen> Or another way to install GHC-for-ARM on an ordinary x86 box?
09:19:29 <glguy> puregreen: I don't have a solution to your question of a way to build on ARM, but there seems to be very little information in that pasted build output. Could the issue be something as simple as the ARM device has very little RAM and regex-tdfa has a module that requires a lot of memory when GHC compiles it and it was killed for OOM?
09:25:01 <bitemyapp> puregreen: what glguy said, can you dump the build log or check dmesg? If it does turn out to be OOM, the trick I use on Linux VPSes with limited RAM is I turn vm.swappiness to 100 and swapon at least a gig or two of space.
09:26:16 <puregreen> bitemyapp, glguy: okay, thanks! I'll pass that on to the person who opened the issue
09:35:33 <saurabhnanda> is there a stack oneliner which will fire up a ghci session while ensuring that certain libraries are pre-installed and available to import?
09:35:39 <saurabhnanda> need it for a tutorial
09:36:35 <alx741> saurabhnanda: you could write an script for that, where the first line uses stack to install a list of libraries, and then runs `stack ghci`
09:36:40 <oherrala> saurabhnanda: stack ghci --package=package ?
09:37:08 <oherrala> or does that install anything?
09:38:20 <saurabhnanda> The following target packages were not found: Opaleye 
09:39:01 <MarLinn> if there's a cabal file and a stack.yaml, "stack exec -- ghci" should do that, right? (and there's probably a shorter version of that) 
09:40:01 <glguy> saurabhnanda: You didn't actually capitalize opaleye in the package flag, right?
09:40:28 <glguy> It's probably worth manually specifying the resolver, too
09:40:30 <saurabhnanda> I did :)
09:40:49 <saurabhnanda> ya
09:40:52 <saurabhnanda> it's installing now
09:40:58 <saurabhnanda> didn't need to be capitalized
09:42:23 <MarLinn> the Yesod quick start guide has something with "stack init" that does a whole bunch of setup from a template... don't know where it gets that template from but maybe you can set one up yourself for more complicated stuff
09:47:18 <mrkgnao> lens noob here, how do I clean this line of code up?
09:47:33 <mrkgnao> update t game = over player (move (game ^. player . velocity)) game
09:47:57 <mrkgnao> I don't know any more lens combinators than this, sadly
09:48:52 <glguy> update = over player (\p -> move (view velocity p) p)
09:50:09 <glguy> or if you always move by the player's velocity, put that logic into move
09:50:16 <glguy> over player move
09:54:00 * hackagebot giphy-api 0.5.1.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.5.1.0 (passy)
10:44:02 * hackagebot test-fixture 0.5.0.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.5.0.0 (lexi_lambda)
10:44:04 * hackagebot sproxy2 1.92.0 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.92.0 (ip1981)
11:10:06 <martinj> exit
11:14:51 <www-bukolay-net> Hi
11:15:25 <sabastiaan> Hello 
11:15:50 <sabastiaan> Currently I'm trying to set up stack for the first time
11:16:02 <sabastiaan> However I keep getting the following error "Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"
11:16:02 <sabastiaan> " 
11:17:10 <geekosaur> did you install stack from an OS package manager?
11:17:15 <sabastiaan> I upgraded stack to the latest version from github, it has an internal ghc8. something, but my system ghc is 7.10.3 
11:17:19 <geekosaur> because that looks like a very ancient version of stack
11:17:31 <sabastiaan> ye I did
11:17:54 <geekosaur> then uninstall the one from the package manager, then "hash -r" so your shell finds the new one
11:18:06 <sabastiaan> my current version is Version 1.2.1, Git revision 0b866b5d0939705d72f2b604f328570dd7d46ba3 x86_64 hpack-0.14.1
11:18:44 <sabastiaan> Ok will do
11:19:33 <sabastiaan> eeeuhhhmm
11:19:49 <sabastiaan> maby I shouldn't remove linux headers with it X_X
11:19:59 <geekosaur> basically that error you got is what happens when stack 0.1.5 or some such sees current repos
11:20:08 <geekosaur> ...what did you try to remove exactly?
11:20:20 <geekosaur> no OS packages should depend on stack
11:21:08 <sabastiaan> I called apt autoremove stack
11:21:36 <sabastiaan> I guess it wanted to remove all the dependencies of stack itself.
11:22:32 <geekosaur> no, autoremove also uninstalls any unreferenced packages installed as a dependency for something else
11:22:44 <geekosaur> which sometimes you want and sometimes you don
11:22:45 <geekosaur> t
11:23:01 <geekosaur> (and sometimes you want to change the autoinstalled flag for some packages so they stick around, then autoremove the rest)
11:23:18 <sabastiaan> ahah
11:25:04 <sabastiaan> when I run stack as sudo it gives me the following warning "sudo: stack: command not found" 
11:25:19 <sabastiaan> sudo with an other command and stack without sudo works fine
11:25:20 <sabastiaan> 0_O
11:26:19 <MarcelineVQ> there's not a reason to run stack as root, it lives in your home directory
11:26:38 <sabastiaan> huh
11:27:24 <sabastiaan> It keeps giving me an error that it doesn't have permission to access the .stack/induces/Hackage/00-index.cache file
11:29:29 <sabastiaan> I have a feeling something is terribly broken with my system:?
11:29:31 <sabastiaan> :/
11:30:42 <sabastiaan> is stack supposed to be in ~/.local/bin/stack?
11:30:43 <jedai> sabastiaan: Terribly broken may be an exageration
11:30:46 <MarcelineVQ> it might just not have permission, if you were using sudo before, you can delete the .stack/indices folder if it's giving you trouble, stack will redownload it when it needs it, though it may take awhile to redownload that one
11:31:06 <MarcelineVQ> sabastiaan: yes, if you ran stack upgrade that's where it should be
11:31:15 <geekosaur> sabastiaan, yes, that is where stack puts things it installs (including itself if you update it)
11:31:35 <geekosaur> also running stack under sudo seems a strange idea
11:32:33 <sabastiaan> Just deleted my .stack/indices, lets see if that works
11:35:32 <sabastiaan> Ok that seemed to fix it
11:35:34 <sabastiaan> thanks!
11:36:00 <jedai> sabastiaan: You can usually delete anything in .stack/
11:37:12 <jedai> sabastiaan: Of course you lose your cache of compiled packages (and local GHC I think ?) that way so the first few compilations afterward will be slow but it won't harm stack itself
11:37:28 <sabastiaan> thats good to know
11:37:49 <sabastiaan> jedai, is it recommended to put my .local/bin/stack somewhere else?
11:39:15 <jedai> sabastiaan: No ? Under normal circumstances, it's a good place for it
11:40:40 <jedai> sabastiaan: Well if you were an admin and wanted every user to use the same stack maybe (I'm not sure that's a good idea...)
11:41:32 <hvr> jedai: it's a good idea if you consider stack, cabal and compilers to be system tools
11:41:54 <jedai> sabastiaan: note that by default every user would still have his own cache (and eventual local GHC, though I would expect such an admin to put a recent GHC system-wide)
11:42:47 <jedai> hvr: I have no objections to it but since every user still have his own .stack... 
11:43:17 <sabastiaan> jedai, This is for currently just on my own desktop, so no need to share it with others. Just looking for good practices
11:44:19 <geekosaur> the stack philosophy strongly believes in per-user stuff over global/system stuff
11:45:36 <hvr> jedai: well, the .stack folder is legitimate for stuff that stack actually generates
11:45:48 <hvr> jedai: but ghc is not one of the things that stack generates
11:47:29 <martinj> how does 0-1-3 get evaluated?
11:48:07 <kadoban> Probably confusingly, - is terrible black magic
11:48:55 <MarcelineVQ> sometimes :>
11:49:10 <MarcelineVQ> ​:info (-) says that - is infix left so:  (0 - 1) - 3
11:49:38 <martinj> ah, it's left associative
11:49:59 <zipper> Hey what could be the cause of an error like " No instance for (MonadIO Identity) arising from a use of ..."
11:50:44 <martinj> Thank you MarcelineVQ!
11:51:06 <MarcelineVQ> martinj: np, check out :info in ghci it's really useful
11:51:20 <geekosaur> zipper, you tried to use liftIO in something that is not on top of IO
11:51:46 <martinj> just tried. I guess "infixl" means infix left?
11:51:53 <MarcelineVQ> that's right
11:51:57 <zipper> geekosaur: Probably :)
11:52:08 <martinj> cool!
11:52:10 <MarcelineVQ> and the number is the precidence, higher binds tighter
11:52:52 <MarcelineVQ> for example * is infixl 7
11:53:24 <martinj> ah, so * has highter precedence over - ?
11:53:41 <MarcelineVQ> yep
11:54:08 <martinj> cool I can see that in the repl
11:54:23 <nitrix> Hi. I'm interesting in an application that is executed very often and has to temrinate. During executions, it'd communicated with a process/thread that it's keeping alive in the background. How would I achieve this?
11:54:48 <nitrix> The only tool that I'm aware that does something similar to this is hdevtools keeping a ghci process running.
11:55:23 <johnw> nailgun for java does something like this too
11:55:34 <johnw> I don't think it's all that uncommon
11:55:51 <johnw> it's client/server, on a small scale
11:55:53 <geekosaur> you give that background application a known "address" (dbus endpoint, unix socket, windows mailbox, ...) and if a probe shows it not running then you launch it
11:56:00 <nitrix> Is it a semaphore? Where should I look?
11:56:45 <geekosaur> the probe might be a way to check if it is registered (dbus, mailbox) or just trying to send it a null command and see if you get an error or a response or a timeout
11:56:48 <nitrix> I can't use a linux socket though, this will be on windows.
11:57:02 <nitrix> I guess I'll just bind a local port :/
11:59:55 <lam3r1> hey
12:00:53 <geekosaur> win32 package doesn't have a mailbox api? lame
12:01:30 <lam3r1> anyone into anonymous?
12:06:52 <yulax> that bot has been on a few other channels
12:15:41 <Phyx-> geekosaur: pull request accepted :)
12:15:55 <Phyx-> nitrix: you could just use a pipe
12:16:59 * geekosaur just trawled hackage and got depressed at ghc's rather unix-focused ecosystem again. despite being a unix type that mostly avoids windows...
12:19:02 * Phyx- gets depressed at the blatant use of the 'unix' package for functionality provided in a cross platform manner in the 'process' package
12:22:54 * orion didn't know there was a 'process' package.
12:25:32 <maerwald> the real problem is that packages trey to be cross-platform where cross-platform is wrong
12:27:15 * geekosaur sometimes has legitimate need for the posix-specific process API. but even so, most of the time use and recommend the portable one
12:27:15 <tdammers> it's just the result of a particular demographic and particular use cases being represented more strongly in the haskell community
12:29:30 <AndreasK> maerwald: Why?
12:30:24 <maerwald> AndreasK: because you can't always properly abstract over platforms without introducing widely varying behavior inside one function
12:30:44 <maerwald> which breaks reasoning about code
12:31:37 <maerwald> to the point that I sometimes think "hope this does not compile on windows"
12:33:06 <grazie> question: when I remove the helper function `set` from the where clause and put the `nub . concat` code inline, it produces error message in ghci https://gist.github.com/95ad6221a5a47d1917b819379f76bdfe
12:33:13 <grazie> why?
12:35:09 <mmalone_> grazie: operator precedence... try putting nub . concat in parenthesis
12:35:15 <geekosaur> ^
12:35:42 <AndreasK> maerwald: In the past i've usually been more happy about a wonky windows implementation than finding none. I guess that the point could be made that maybe someone would be motivated to write a windows one in that case but that really depends on the the thing in question.
12:35:45 <geekosaur> `nub . concat (units !s)` parses as `nub . (concat (units !s))`
12:35:59 <geekosaur> application is always higher precedence than any operator
12:36:25 <maerwald> AndreasK: I think that's a dangerous approach
12:36:56 <grazie> geekosaur: and `nub . (concat (units !s))` is differnet from `(nub . concat) (units !s)`? why,,,,does the former run nub before concat?
12:36:57 <geekosaur> and since (.) composes functions, it forces the type of (concat (units !s)) to be a function, which it is not
12:37:14 <geekosaur> laziness
12:37:39 <grazie> geekosaur: ok, thanks, I didn't realize . forces (concat (units !s)) to be a func
12:37:45 <geekosaur> the parentheses in (nub . concat) do the exact same thing splitting that out into a separate binding `set` does
12:37:54 <grazie> mmalone_ thanks, it works
12:37:55 <geekosaur> (.) composes functions
12:38:04 <geekosaur> :t (.)
12:38:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:38:24 <grazie> I realize (.) composes functions, just didn't realizes it would treat (concat (units !s)) as one func
12:38:29 <geekosaur> takes two functions. so (concat (units !s)) must be a function to work
12:38:59 <geekosaur> (nub is the (b -> c) there, (concat (units !s)) is the (a -> b)
12:39:35 <grazie> geekosaur: so with the brackets, is this  parsing right to left or left to right?  nub . (concat (units !s))
12:40:15 * geekosaur doesn't understand the question
12:40:21 <AndreasK> maerwald: Sure. Depends on the use case though. I only do hobby stuff in haskell so for me correctness isn't as much a priority
12:40:23 <geekosaur> the brackets I added just to make explicit what it is doing
12:41:36 <geekosaur> function application is always highest precedence, so `nub . concat (units ! s)` will always apply `(units ! s)` to `concat`, never to `nub . concat`
12:41:38 <Phyx-> I don't see how you can prove anything related to correctness with the unix platform anyway
12:41:40 <maerwald> AndreasK: if I think about file handling for example which is done in very shaky cross-platform ways sometimes, correctness is the number once concern
12:41:41 <grazie> geekosaur, I guess my question was, if the parser "processed" units !s first and then applied concat to the result, then no brackets needed
12:41:51 <Phyx-> do all POSIX functions come with proof of correctness?
12:42:03 <Phyx-> and completely verified implementations?
12:42:32 <geekosaur> Phyx-, not as ghc uses it. technically POSIX can only be claimed if you pass the fairly comprehensive test suite
12:42:55 <Phyx-> I'm being facetious just to point out you're assiming the POSIX stuff is correct but assume the cross platform Haskell stuff isn't :)
12:42:58 <geekosaur> no current linux distribution that I know of has been through that, because it's fairly expensive
12:43:01 <mruize85> @pl
12:43:03 <lambdabot> (line 1, column 1):
12:43:03 <lambdabot> unexpected end of input
12:43:03 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:43:06 <geekosaur> what?
12:43:21 <Phyx-> assuming*
12:43:38 <geekosaur> I didn't see anyone claim that, or even assume it
12:44:18 <geekosaur> I said I sometimes need to use it. I'm a Unix sysadmin; sometimes I need to use aspects of the API that are hard to provide in a cross platform manner, but needed for integration with something else. as I also said, this is fairly rare
12:44:42 <orion> Would it be possible to create a competing POSIX standard where the entire system is specified in Haskell?
12:44:57 <maerwald> yeah we need more standards clearly
12:45:19 <geekosaur> POSIX does not care what it's implemented in
12:45:27 <geekosaur> it only has to pass the test suite
12:45:50 <orion> The specifications are written in such a way as to limit itself to C.
12:46:07 <geekosaur> the most recent version of OpenVMS is reportedly POSIX certified. it's not unix and I don't think it's written in C for the most part
12:46:10 <Phyx-> fair enough, but I think most people start off having the intention to not make the package cross platform. At least that's the way it feels. some times the effort is so little, if you think about it from the start
12:46:45 <hodapp> I think that wonky OS written in Rust even has some level of POSIX compliance.
12:47:12 <ab9rf> VMS was written originally in BLISS as i recall, but i might be mistaken about that
12:47:47 <sabastiaan> Does anybody know how I can build an stack project from within (spac)emacs?
12:48:08 <AndreasK> maerwald: True. But if I want to parse some strange file format or similar I would still prefer a library thats shaky to having none. Usually it's easier to work around the shakyness than to reimplement it for windows properly for me. 
12:48:11 <ab9rf> i usde to have access to VMS source code, but that was 30 years ago and i don't recall ever looking at the kernel itself
12:48:11 <mmalone> are the APIs that people actually use these days even covered by POSIX?
12:48:16 <geekosaur> bliss-11, yes. (there wasn't one "bliss", it differed per platform. bliss-10 did considerably more than bliss-11, since pdp-10 was more powerful than pdp-11/vax-11
12:48:19 <dqubed> hodapp: Redox? It does but it does so by basically accident (being an "unix-like")
12:48:43 <AndreasK> maerwald: Which often seem to be the two options :(
12:48:55 <ab9rf> geekosaur: vms would have been bliss32
12:49:13 <grazie> the type def of `peers` is `Array Square [Square]`, i.e. peer returns a list of [Squares], but what is the Square? can you tell from this code? https://gist.github.com/aac6031097715944344900febf27552f
12:49:19 <geekosaur> mm, right, they would have needed a new bliss for vax
12:49:22 <ab9rf> except for components intended to run in pdp emulation mode
12:49:28 <geekosaur> same reason it was different for pdp10
12:50:04 <grazie> I assumed it was `box` but `box` isn't of type Square - box = (('A','1'),('I','9'))  https://gist.github.com/aac6031097715944344900febf27552f
12:52:18 <cschneid_> Does anybody have a link to that paper that talks about designing datatypes and combinators for financial bonds
12:52:27 <cschneid_> because I suck at tracking papers
12:54:14 <geekosaur> grazie, are you talking about a different function `peer` there or was that a typo?
12:54:42 <geekosaur> `peers` returns an Array, indexed by Square, each element of which is a [Square]
12:55:18 <geekosaur> Array is not like e.g. State or Reader
12:55:44 <grazie> geekosaur: it was a typo, 'peers' is correct,, so Array is not like an array in javascript
12:56:27 * geekosaur doesn't know offhand what that means...
12:56:47 <grazie> geekosaur: the Array you describe seems like a python Dictionary, where the index is the key
12:57:19 <geekosaur> sort of. you can use any type that has an Ix instance as an index, but internally it is translated to an Int#
12:57:43 <geekosaur> and normalized so the internal lower bound is 0#
12:58:48 <geekosaur> but lets you specify in the array combinator what the index or indices are. `box` says it's a 2D array whose first index's range is enumFromTo 'A' 'I' and whose second's range is enumFromTo '1' '9'
12:59:36 <geekosaur> it then takes a list of pairs, the first element being the index (or in this case indices since it's 2D) and the second being the value to be stored there
12:59:42 <grazie> geekosaur:  yes, so haskell Array let's you specificy what the index is, whereas javascript array it just counts from 0 where 0 is first element of array
13:00:52 <geekosaur> the Ix instance remaps the indices to the usual 0..
13:01:11 <grazie> ok, thank you for your help
13:01:25 <geekosaur> (well, converts to numeric and the normalization to 0 is internal to Array, otherwise you'd need a custom newtype to start at 'A' or '1' instead of '\NUL')
13:02:15 <geekosaur> so, yes, Array provides a richer interface instead of making you map your preferred indices to numbers counting from 0
13:02:45 <geekosaur> Vector provides something more "traditional"
13:28:52 <c_wraith> you could use Ix with Vector, but I can see why they don't. it's kind of a lot of extra junk. 
13:28:58 <dmwit> cschneid_: possibly http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
13:30:58 <dmwit> `Ix` was made and used with good intentions.
13:31:04 <ab9rf> heh
13:32:25 <c_wraith> Ix is a friendly interface, but it had overhead in all sorts of ways. 
13:32:45 <c_wraith> and Vector is all about eliminating overhead. 
13:35:43 <geekosaur> yep
13:45:38 <cschneid_> dmwit: yes - thank you :)
13:50:28 <seagreen> Is there a convenient way to visualize the module imports within a Haskell library?
13:50:52 <seagreen> I used to use SourceGraph for this, but it's not building in NixOS any more.
13:52:42 <seagreen> If I thought it was still being maintained I'd try to get it building again, but it doesn't look like it.
14:19:10 * hackagebot datasets 0.2.1 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.2.1 (glutamate)
14:19:18 <EvanR> hmm, https://refuses.github.io/
14:51:49 <loskutak> Hi, I am following write yourself a scheme at https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing and I got stuck with one of the exercises... It asks me to rewrite a bit of code using liftM by using >>=, but I cannot get my head around how the >>= actually work
14:53:09 <GodotMisogi> I need help setting up Agda and Haskell on Windows with Sublime Text as my editor. Could anyone lend a hand, please?
14:53:28 <NibbleNinja> Who is Agda?
14:53:42 <hodapp> uhh, Agda the programming language?
14:53:47 <GodotMisogi> Yup
14:53:55 <NibbleNinja> No no, Agda is a female name.
14:53:58 <NibbleNinja> Not a programming language.
14:55:04 <jle`> GodotMisogi: best to just ask your question
14:55:06 <jle`> :)
14:56:44 <monochrom> loskutak: It may be easier to symbolically (not intuitively) compare the types of liftM and >>= and guess how to bridge their difference.
14:57:10 <loskutak> monochrom: thanks, will try that
14:58:11 <monochrom> If your monad is called "M", you are look at: You are given (>>=) :: M a -> (a -> M b) -> M b. And you are to use it (plus your own code, a little bit) to produce something of type (a -> b) -> (M a -> M b)
14:59:32 <monochrom> And it may be better to first imagine that you're given (>>=) but with the other parameter order, i.e., (=<<) :: (a -> M b) -> (M a -> M b). Now the similarity and the difference from liftM is easier to see. You are to go from (a -> b) to (a -> M b).
15:09:43 <ebzzry> Is 'resolver: lts-7.11' not compatible with 'repo: "fpco/stack-build"'?
15:10:11 <loskutak> monochrom: I am still completely confused :/
15:18:44 <ski> NibbleNinja : Ada,Miranda,Alice ML,GCLA (pronounced "Gisela") ?
15:26:20 <danilo2> Hello guys! What is the overall performance overhead of IORef / STRef? I've been looking for some info but didnt found any answer on that topic so far
15:27:07 <loskutak> monochrom: I think I have finally done it :) thanks for the help! I am still very very confused, but at least I have got this working
15:29:13 * hackagebot hinterface 0.5.0.0 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-0.5.0.0 (SvenHeyll)
15:29:43 <unskill> In "a + b" function (+) is in infix notation, in "(,) a b" function "(,)" is in prefix notation. But how do you call notation of "(,)" in "(a, b)"?
15:29:56 <unskill> Sorry for such a stupid question.
15:30:13 <Koterpillar> unskill: that's not a function there
15:30:29 <kadoban> It's rather special syntax, it's not really function syntax at all. I don't think infix/prefix/other makes sense for the last one.
15:30:32 <unskill> Data constructor, if you want
15:30:46 <geekosaur> problem is it's not really a data constructor
15:30:49 <Koterpillar> unskill: I don't know of a name to that notation, but here's another question for you: what's the notation for [1, 2, 3]?
15:31:04 <unskill> It is syntactic sugar.
15:31:36 <rblaze> unskill: this is special syntax construct, built in language parser. You can't create one like this yourself.
15:32:43 <unskill> rblaze: I don't want to create, I just wonder if there is a special name for such a notation.
15:32:56 <MarcelineVQ> if these were operators they'd be mixfix/distfix probably, some more advanced examples here http://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf
15:33:06 <Axman6> I believe the ability to do that is often called mixfix
15:33:33 <Axman6> some languages let you define if_then_else :: Bool -> a -> a -> a and use it as if x then y else z
15:34:23 <Axman6> Agda I think has that?
15:34:42 <rblaze> unskill: as mentioned, in haskell it is called "syntax sugar" :)
15:34:55 <unskill> MarcelineVQ: Axman6: thank you
15:35:47 <byorgey> danilo2: it's approximately 6
15:37:27 <byorgey> danilo2: your question is not meaningful, because you cannot just compare a program using IORef / STRef to one that does not.  In general, "what is the performance overhead of feature X" is usually not a meaningful question.
15:38:45 <ski> unskill : "mixfix" or "distfix"
15:40:42 <MarLinn> "mix-" makes sense to me. But why "dist-"?
15:41:53 <unskill> MarLinn: may be distinct?
15:42:11 <MarLinn> I just found "distributed".
15:43:09 <MarLinn> that makes even more sense than "mix" now
15:44:11 <unskill> "mixfix" doesn't mean some specific notation, but a mixture of them
15:44:46 <unskill> E.g. (a, b) is mixture of infix (comma between operands) and closed (parens around operands) notation
15:45:46 * ski . o O ( "Precedences in Specifications and Implementations of Programming Languages" by Annika Aasa in 199[15] at <https://web.archive.org/web/20070701130745/http://www.cs.chalmers.se/~annika/plilp91.ps>,<https://web.archive.org/web/20070701130745/http://www.cs.chalmers.se/~annika/tcs95.ps> )
15:47:05 <jle`> unskill: you don't have to be sorry for asking a question lol
15:47:30 <unskill> jle`: but have to be for asking stupid ones
15:47:33 <BusFactor1> jle: maybe he's canadian
15:47:34 <BusFactor1> ;-)
15:50:22 <ski> unskill : it's not a stupid question
15:53:21 * ski . o O ( "There're no stupid questions, only stupid people" )
15:56:36 <mounty_> Hello;  I'm trying to build a project and encountering the error that hsql-postgresql uses Control.OldException which is no longer available.  Is hsql-postgresql itself deprecated ?
16:00:53 <Axman6> I've never even heard of hsql
16:01:27 <Axman6> yeah that's 4 years old, there are definitely newer options
16:01:40 <geekosaur> mounty_, the fact that you got that error means it has not been maintained in a long time, so yes
16:01:55 <c_wraith> I've never heard of it either. it's certainly never gained any traction, regardless of its official deprecation status. 
16:03:10 <Axman6> I'm quite a fan of hasql, but it is a bit unconventional
16:04:10 * geekosaur remembers hsql, but doesn't recall seeing much of anything ever use it
16:05:02 <mounty_> OK, thanks all;  I'll look around for the most appropriate replacement.
16:06:13 <MarLinn> Thx, ski, for the paper. Now I'm imagining even more crazy extensions than before, like user definable `back ticks` with custom precedence rules.
16:07:57 <ski> MarLinn : also the one mentioned by MarcelineVQ
16:09:45 <MarLinn> Oh, I missed that. thx. 
16:09:56 * ski has some vague ideas relating precedence to pentagonal law ..
16:10:39 <ski> (and in case you've not seen it, you should be aware of prefix and postfix operators in Prolog)
16:11:52 <MarLinn> I feel there's an esoteric language based entirely on one primitive and a bunch of precedence rules waiting to be born
16:12:06 * JSharp ponders
16:13:10 * loskutak had so much fun in his first serious try at Haskell :)
16:13:13 <Rembane> Can you create a BF-dialect in that language?
16:13:23 <Rembane> MarLinn: See previous line.
16:16:27 <MarLinn> I'm not that far yet. I just heard a distant call from the other side of Styx muffled by mist.
16:16:47 <Rembane> Remember to bring a coin and have your state monad in order.
16:18:30 <codedmart> I have a Schema.hs file that is getting quite large. I am trying to see if hs-boot will work for me unless there is some other ideas.
16:19:16 <codedmart> With hs-boot do you put your full `data` or `newtype` in the hs-boot file with all instances?
16:19:35 <mpickering> Why do you need a hs-boot? 
16:19:42 <monochrom> No, we usually put the absolute minimum.
16:20:06 <MarLinn> Well I suppose if I have time over the holidays I could go on the trip. If nothing else takes precedence, that is. *ba-dum-tsh*
16:20:48 <mpickering> Really try to avoid adding a hs boot if possible 
16:21:39 <codedmart> mpickering: My Schema.hs file is already 500 LOC, and I still have a lot to add.
16:21:54 <codedmart> It is slow to recompile.
16:22:20 <codedmart> So just trying to look at alternatives again if possible.
16:22:35 <mpickering> Are all your definitions mutually recursive? 
16:23:01 <codedmart> mpickering: I guess not all of them, but a fair amount.
16:23:42 <codedmart> But if that is still my best approach I will keep it that way.
16:31:59 <danilo2> byorgey: I didnt see your reply, sorry
16:33:07 <danilo2> byorgey: hmm I dont think its meaningful, Im just asking about the underlying implementation of STRef / IORef. If STRef could be completely thrown away during optimization of runST or IORef is represented as a memory pointer under the hood, that tells much about the overhead
16:33:22 <danilo2> I'm jsut asking about how these two things are handled by GHC
16:44:35 <ski> danilo2 : in GHC, `IORef' and `STRef' is represented in the same way
16:45:09 <danilo2> ski: oh, thats intersting. Do you know how exactly is it represented?
16:45:47 <ski> barring optimizations, i think as a reference to a mutable memory cell
16:46:32 <ski> (also see `runSTArray',`runSTUArray' and such things)
17:20:36 <lambda-11235> \
17:21:04 <lambda-11235> oops
17:24:12 <lpaste> Cale pasted “instance of Exception for Either” at http://lpaste.net/347656
17:44:18 * hackagebot jsaddle-dom 0.7.0.1 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.7.0.1 (HamishMackenzie)
17:57:53 <imalison> I can't figure out a dependency issue that has started occuring suddenly on my machine
17:58:01 <erisco> :t \f -> foldl' (\a x -> (&&) <$> a <*> f x) (pure True)
17:58:02 <lambdabot> (Foldable t, Applicative f) => (t1 -> f Bool) -> t t1 -> f Bool
17:58:13 <imalison> I'm getting   <command line>: cannot satisfy -package-id whenever I try to run stack install
17:59:53 <jle`> erisco: fmap and . traverse f   -- ?
18:00:34 <jle`> it might not do what you want/expect, though
18:01:10 <Koterpillar> imalison: post your relevant stack.yaml?
18:01:12 <erisco> jle`, it isn't strict though
18:01:25 <erisco> and I don't trust lists
18:01:45 <jle`> what are you hoping to achieve from strictness here?
18:01:49 <jle`> less space overhead?
18:01:55 <erisco> and time, yes
18:02:17 <imalison> Koterpillar: I don't think the stack.yaml is relevant because its happening for literally any project for which i try to run stack
18:02:22 <jle`> should be neglible unless your list is huge i suppose
18:02:36 <erisco> no I just do it millions of times
18:03:12 <jle`> fair enough :)
18:07:33 <lpaste> EvilMachine pasted “late night code” at http://lpaste.net/347666
18:07:59 <EvilMachine> Why does this not work again?
18:08:09 * EvilMachine is very tired. It may be stupid.
18:08:28 <jle`> EvilMachine: zeige is not a method of the 'Show' typeclass
18:08:39 <EvilMachine> jle`: but show is
18:08:52 <jle`> do you see why this doesn't work:
18:09:07 <EvilMachine> jle`: I’m sure it’s something very simple.
18:09:09 <jle`> instance Functor Maybe where (x >>= y) = show x
18:09:15 <jle`> you're defining a Functor instance
18:09:18 <jle`> so you want to give 'fmap'
18:09:19 * hackagebot ghcjs-dom-jsaddle 0.7.0.1 - DOM library that supports both GHCJS and GHC using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.7.0.1 (HamishMackenzie)
18:09:23 <jle`> you don't want to define (>>=)
18:09:28 <jle`> or how about:
18:09:37 <jle`> instance Eq Bool where show _ = "hello"
18:09:48 <Guest91680> EvilMachine: are you translate Haskell into german?
18:09:50 <jle`> instance Eq Bool where foo = "bar"
18:10:02 <jle`> oh wait, i misread your code, sorry ><
18:10:07 <jle`> Zeige is the typeclass
18:10:24 <EvilMachine> Guest91680: No. Zeige is meant for printing. For humans. So it’s meant to print stings without quotes etc. This is just the default fallback.
18:10:47 <jle`> EvilMachine: in this case, what do you mean by "doesn't work" ?
18:10:54 <jle`> because i think it should compile, with a couple of extensions
18:10:55 <geekosaur> that should work by itself. it's hen you use it with other instances that things fall apart
18:11:01 <EvilMachine> jle`: Illegal instance declaration for ‘Zeige show’
18:11:06 <jle`> and...what does the next line say?
18:11:12 <EvilMachine> jle`: sorry for forgetting to post the error.
18:11:21 <EvilMachine> jle`: wait, i’ll add it to a paste
18:11:23 <jle`> the error should give you instructions on how to get it to compile
18:11:30 <geekosaur> include the class definition too
18:11:31 <jle`> it should be the next line after the one you posted
18:11:46 <jle`> but yeah, the instance should compile once you follow the instructions in the error, but it's probably not what you want in the end
18:11:57 <geekosaur> but even after fixing the instance declaration to compile, it won't wortk
18:12:09 <lpaste> EvilMachine revised “late night code”: “late night code” at http://lpaste.net/347666
18:12:12 <geekosaur> because it overlaps all other instances
18:12:30 <jle`> EvilMachine: 'use FlexibleInstances ...'
18:12:32 <EvilMachine> geekosaur: thaat might be it. :)
18:12:33 <geekosaur> the context is not consulted until *after* an instance is chosen
18:13:00 <jle`> but yeah, in haskell, typeclasses are "chosen" based on the instance head ... it doesn't look at the constraints
18:13:01 <EvilMachine> jle`: so that’s giving me this ”fallback” logic?
18:13:14 <jle`> that's not going to give you fallback logic
18:13:25 <EvilMachine> jle`: ah, by constraints you mean the stuff left of the =>
18:13:26 <jle`> it's going to give you headaches :)
18:13:47 <jle`> yeah, so for example, say you want to call 'zeig' on (Int -> Bool)
18:13:55 <jle`> it'll say, "oh, we have an instance for Zeig a...let's use it on that"
18:14:22 <jle`> er wait, that's a bad example
18:14:34 <jle`> if you had a type Foo, it'll match on a 'Zeig a' instance no matter what
18:14:42 <jle`> even if there's a 'Zeig Foo' instance
18:14:54 <lpaste> EvilMachine pasted “What I originally wanted…” at http://lpaste.net/347669
18:15:03 <EvilMachine> jle`: okay, then I’ll go with ↑
18:15:27 <jle`> you don't need the Show constraint either in that case :o
18:15:32 <EvilMachine> jle`: thanks. yeah, i should be in bed. :)
18:15:36 <geekosaur> also is Zeige a `type` instead of a `newtype` or `data`? afaict that instance declaration is valid
18:15:37 <jle`> you can add it in the default impl using default implementation sigs
18:15:43 <EvilMachine> jle`: wait, yes, i do.
18:16:03 <EvilMachine> geekosaur: Zeige is not a type. 
18:16:17 <jle`> EvilMachine: https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#default-method-signatures
18:16:37 <jle`> er well, i guess you do in the current implementation
18:16:48 <jle`> but using DefaultSignatures gives you that fallback "free instance"
18:16:53 <jle`> while also letting you define Zeig for non-showables
18:17:09 <jle`> then you can write `instance Zeig Bool` without needing to provide an impl of zeig
18:17:24 <jle`> and then you can also write instance Zeig (Int -> Bool) where zeig _ = "Int -> Bool"
18:18:14 <EvilMachine> jle`: that sounds like exactly what i want
18:20:31 <EvilMachine> jle`: Alright! It works!
18:20:36 <jle`> nice :)
18:20:46 <EvilMachine> That default signature stuff is new in GHC 8 right?
18:21:08 <geekosaur> 7.something I think?
18:21:10 * EvilMachine has too much other stuff to do, to keep up with everything. :/
18:21:14 <EvilMachine> geekosaur: hmm…
18:21:33 <EvilMachine> Anyway… back to fixing the last few errors.
18:21:43 <EvilMachine> Thanks, everyone. :) You’re the best.
18:21:45 <jle`> 7.2
18:21:51 * EvilMachine turns his brain back off. :P
18:23:25 <geekosaur> I wanted to say 7.2 but couldn't recall exactly
18:24:20 * hackagebot ghcjs-dom-jsffi 0.7.0.1 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.7.0.1 (HamishMackenzie)
18:24:22 * hackagebot ghcjs-dom 0.7.0.1 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.7.0.1 (HamishMackenzie)
18:24:23 <jle`> i only knew because the link i posted said so, heh
18:43:25 <dpren> Does GHC memoize function results even if they're not  bound to a name of any sort?
18:43:52 <c_wraith> Not unless it has decided to do some sort of CSE
18:44:06 <c_wraith> Or float a constant.
18:44:17 <c_wraith> Which I guess is just an extreme version of CSE
18:44:38 <c_wraith> Usually memoization is a performance degradation.
18:44:45 <c_wraith> So it usually isn't done.
18:49:35 <dpren> c_wraith: Interesting. Why's it a performance degradation?
18:50:07 <c_wraith> dpren: most functions are simple enough that they're faster to calculate than lookup.
18:51:50 <c_wraith> dpren: especially considering the frequent memory cost of requiring some large result to stay resident in memory instead of being collected immediately.
18:55:43 <c_wraith> dpren: consider (sum [1..10000000] + product [1..10000000] :: Integer) vs (let list = [1..10000000] in sum list + product list :: Integer)
18:57:02 <c_wraith> ...  Both of those will be relatively slow, given how big that product gets.
18:57:06 <c_wraith> But still.
18:57:43 <c_wraith> Maybe find some other fold than product. :)
18:57:54 <Axman6> length
18:58:19 <c_wraith> That breaks me calling the result an Integer. :P
18:58:41 <c_wraith> Still, the result would fit in an Int with that change.
18:59:58 <dpren> c_wraith:  I see. So in general, should I just code for readability, and GHC will do it's thing?
19:00:37 <c_wraith> dpren: in general, that works.  In practice, sometimes you need to tweak the code for performance.
19:01:01 <dpren> c_wraith: I imagine so
19:02:06 <c_wraith> The funny thing is that there are few concrete rules.  Sometimes more sharing is better.  Sometimes less sharing is better.  Sometimes being lazier is better.  Sometimes being stricter is better.  It all depends on what you're doing.
19:09:05 <ski> dpren : note that memoizing a function (caching&sharing the association from input value to output value, requiring some kind of lookup structure) is different from caching&sharing the result of subexpressions (e.g. function arguments) (aka (call-)by-need / laziness)
19:27:22 <jao> haskell in the large, pretty interesting -- https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems#video
19:27:44 <jao> (oops sorry, wrong buffer)
19:28:41 <MarcelineVQ> it's on topic at least
19:29:15 <Squarism> is there a "goto" logging framework in haskell land?
19:31:42 <jao> MarcelineVQ, indeed.  And the talk is really quite interesting, although i presume most people around were already in the know.
19:34:23 * hackagebot cabal-rpm 0.10.1 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.10.1 (JensPetersen)
19:44:23 * hackagebot diagrams-builder 0.8.0.1 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.8.0.1 (BrentYorgey)
19:48:36 <danilo2_> Hi! :) I need a data structure that will keep Ints and will give me access to: iterate in sorted order, adding new elements, removing either of elements (any of available and giving it to me). I want such strucutre to behave as fast as possible (probably some tree under the hood). Coud anybody recommend something to me ?
19:49:23 * hackagebot diagrams-haddock 0.4.0.1 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.4.0.1 (BrentYorgey)
19:49:25 <geekosaur> does it need to store duplicates?
19:49:59 <danilo2_> geekosaur: no, there will never be duplicates
19:50:12 <geekosaur> Set Int or IntSet
19:50:13 <danilo2_> geekosaur: it will be used to store free vector indexes
19:50:33 <danilo2_> geekosaur: does IntSet keep it sorted?
19:51:45 <geekosaur> looks like it, yes
19:53:12 <danilo2_> geekosaur: thats really cool, thank you, I'd never thought that IntSet keeps it sorted. After thinking about it it makes sense though! Thanks!
19:59:24 * hackagebot BlogLiterately-diagrams 0.2.0.4 - Include images in blog posts with inline diagrams code  https://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.0.4 (BrentYorgey)
20:10:17 <codedmart> I was doing an exercise from haskell book and wanted to go another step, but I am lost here: https://gist.github.com/codedmart/6a2daa1cfaacf35d47b64baae5f94965#file-compose-hs-L25
20:11:16 <codedmart> Anyone have a hint or suggestion?
20:14:44 <codedmart> Sorry I meant this line https://gist.github.com/codedmart/6a2daa1cfaacf35d47b64baae5f94965#file-compose-hs-L21
20:21:37 <manek> That could be very nooby question, but what is the most performant way to sort list of ints in Haskell? It could be something other than list if it provides as fast cons / snoc 
20:22:22 <manek> Is it Data.Seq unstableSort ?
20:28:37 <solrize> probably something in an array library
20:35:16 <eklavya> I have read it a few times now that Free monads are a better abstraction than monad transformers (I am not sure if that was what was said)
20:35:25 <eklavya> is it so?
20:40:24 <dmj`> eklavya: that’s a strange thing to say, since free monads can be transformed themselves
20:40:52 <eklavya> dmj`: I am pretty sure I read/understood it wrong
20:41:01 <eklavya> let me dig it up again
20:41:32 <eklavya> but from what I remember it said free monads are an easier composing technique?
20:42:36 <codedmart> dmj`: Any hints you can give on this -> https://gist.github.com/codedmart/6a2daa1cfaacf35d47b64baae5f94965#file-compose-hs-L21
21:02:13 <eklavya> I am finding it hard to get free monads :(
21:02:34 <eklavya> anybody knows of a beginner friendly tutorial for it?
21:09:53 <erisco> is there a short way to do case analysis on a in m a?
21:10:53 <geekosaur> >>= \case ?
21:14:15 <Cale> Yeah, that's practically the original motivation for lambdacase :)
21:16:52 <sophiag> hi, i'm new to haskell and building the web server from the Awkward Squad among other projects to get a grip on IO stuff. wondering what package currently contains types Config and Handle? seems a lot of dependencies have changed since that paper was written
21:19:10 <Axman6> which paper?
21:19:35 <MarcelineVQ> Axman6: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
21:27:23 <geekosaur> Handle is in base, in the module System.IO
21:27:53 <geekosaur> there is no standard Config; it must be from their web server
21:29:24 <sophiag> ah, actually i'm digging deeper into the example code from Simon Marlow and that makes sense now
21:29:46 <geekosaur> actually it doesn't define it from what I see
21:30:15 <geekosaur> it's just an example and incomplete. but the style is used by a number of web server packages (although none of them call their config simply Config)
21:30:18 <sophiag> it doesn't in the paper, but there was example code floating around at the time that's been through several modifications since
21:30:56 <sophiag> the one by Simon Marlow based on the paper has a Config module in the src
21:31:14 <geekosaur> ok, that would make sense
21:31:41 <sophiag> i figured it was a standard package, which i guess there are except not exactly of this type
21:36:06 <geekosaur> the style is standard. the configuration type for different packages will be different, although there are some commonalities (like, most Haskell web frameworks are based on warp, so its Settings type may be buried somewhere in the more specific configuration)
21:38:05 <geekosaur> so scotty has an Options which has a warp Settings inside it
21:40:47 <sophiag> ah, ok. good to know. i don't really care about server architecture tbh tho. just figured it'd be an easy exercise i could compare to say, node, for example. so far i learned much more from Peyton-Jones' STM paper tho. it's more focused and covers the nuts and bolts of designing a library
21:41:01 <geekosaur> spock has a SpockCfg, snap has a Config, yesod has Yesod, etc.
22:41:03 <Ed1> why does elem 2 (2,3) return False but elem 3 (2,3) returns True
22:42:47 <liste> Ed1: because the Foldable instance of (,) only concerns the second element
22:43:24 <liste> > F.toList (1,2)
22:43:26 <lambdabot>  [2]
22:44:20 <liste> actually the Foldable instance is for (,) a
22:48:09 <Ed1> liste: is there a function that checks if a value is an element of either the fst or snd of a pair without actually defining your own"
22:48:11 <Ed1> ?
22:49:46 <Koterpillar> @hoogle Eq a => a -> (a, a) -> Bool
22:49:46 <lambdabot> Text.HTML.TagStream.ByteString in2 :: Eq a => (a, a) -> a -> Bool
22:49:46 <lambdabot> Text.HTML.TagStream.Text in2 :: Eq a => (a, a) -> a -> Bool
22:49:46 <lambdabot> Data.List.Utils hasKeyAL :: Eq a => a -> [(a, b)] -> Bool
22:49:52 <Koterpillar> :t both
22:49:54 <lambdabot> (Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
22:51:04 <liste> Ed1: seems there's no such function
22:51:10 <Ed1> got it
22:51:17 <Ed1> thanks
22:57:33 <sssilver> Hey guys, are monad transformers a thing?
22:58:21 <ab9rf> um, yes?
22:59:19 <sssilver> ab9rf cool, thanks!
23:02:29 <glguy> ab9rf: teach the controversy
23:02:48 <ab9rf> glguy: i'd have to know what that controversy is first
23:03:24 <geppettodivacin> I mean, they are in fact a thing. Not much controversy there.
23:04:35 <jle`> :t \x -> uncurry (&&) . join bimap (== x)
23:04:37 <lambdabot> Eq a => a -> (a, a) -> Bool
23:04:38 <jle`> idk
23:05:07 <jle`> :t \x -> uncurry (&&) . bimap (== x) (== x)
23:05:08 <lambdabot> Eq a => a -> (a, a) -> Bool
23:05:16 <ab9rf> (. liftM2 (:) fst (return . snd)) . any . (==)
23:05:26 <glguy> :t \x -> allOf both (x==)
23:05:28 <lambdabot> (Bitraversable r, Eq a) => a -> r a a -> Bool
23:05:48 <jle`> glguy: oh that's good
23:05:57 <jle`> oh i should have done (||) earlier
23:06:08 <glguy> :t elemOf both
23:06:09 <lambdabot> (Bitraversable r, Eq a) => a -> r a a -> Bool
23:07:05 <jle`> sweet
23:14:25 <jle`> bitraversable is such an awkward class.  there are only two instances that people ever really use
23:14:33 * hackagebot ede 0.2.8.6 - Templating language with similar syntax and features to Liquid or Jinja2.  https://hackage.haskell.org/package/ede-0.2.8.6 (BrendanHay)
23:14:37 <jle`> same for bifunctor
23:15:26 <jle`> there's just Either and (,) and various variations of Const
23:17:38 <geppettodivacin> What is BitTraversal even for?
23:17:46 <jle`> feels like a solution looking for a problem
23:17:53 <jle`> geppettodivacin: Bifunctor is a part of base
23:18:07 <jle`> Bitraversable is similar
23:18:20 <jle`> > bimap (*2) length (4, "hello")
23:18:22 <lambdabot>  (8,5)
23:19:26 <geppettodivacin> Ah, apparently I can't read this late at night.
23:19:42 <geppettodivacin> I spelled it exactly how I read it.
23:20:22 <geppettodivacin> Is there any advantage to Bitraversable over Bifunctor?
23:20:36 <jle`> bitraversable is to bifunctor as traversable is to functor
23:21:00 <jle`> geppettodivacin: traversable lets you map "effectful" functions
23:21:13 <jle`> and sequences them
23:21:35 <jle`> :t ptraverse putStrLn ["hello", "world"]
23:21:37 <lambdabot> error:
23:21:37 <lambdabot>     • Variable not in scope:
23:21:37 <lambdabot>         ptraverse :: (String -> IO ()) -> [[Char]] -> t
23:21:43 <jle`> :t traverse putStrLn ["hello", "world"]
23:21:45 <lambdabot> IO [()]
23:22:26 <jle`> :t bitraverse putStrLn void ("hello", getLine)
23:22:28 <lambdabot> IO ((), ())
23:23:07 <geppettodivacin> Ah, cool. So, like mapM_, but for Applicative.
23:23:19 <jle`> it's like mapM except for tuples
23:23:21 <jle`> kinda
23:23:32 <jle`> Traversable works with Applicative too :)
23:25:57 <jle`> geppettodivacin: bitraverse :: (a -> f b) -> (c -> f d) -> (a, b) -> f (c, d)
23:25:59 <jle`> for tuples
23:26:16 <sssilver> I hate this life :((( I can code reasonably well in Haskell, hell I even get monads, yet I feel like I'm a way below average programmer........ and I don't know how to fix it, that's the worst part
23:32:19 <kadoban> sssilver: Program more? Look up dunning-kruger, get on with life?
23:32:43 <sssilver> kadoban I think I'm objective though.
23:32:54 <sssilver> my problem are the interview questions/programming puzzles/ACM questions. I never know how to solve them. And I don't know how to learn
23:33:10 <sssilver> no matter how many I try, across the years, every new one makes me go :pokerface:
23:34:05 <kadoban> sssilver: Try easier ones. They're a skill that's mostly separate from general programming really, IMO.
23:34:43 <sssilver> I could design a beautifully elegant system using sophisticated types, but fuck me I can't figure out how to generate all polyominoes of N complexity if you put a pistol to my head
23:34:48 <kadoban> Start with like the easy ones on some site, there's a bunch, you'll be able to do them no problem, work your way up. If your grounding in algorithms and data structures is weak, you could study some fundamentals there as well, some of that is necessary.
23:35:06 <sssilver> I know all the data structures pretty well
23:35:30 <sssilver> I understand all the algorithms when I read them (and forget them immediately because they're boring as hell)
23:35:43 <sssilver> but ask me "please generate all polyominoes of N complexity" and I'm like "well fuck"
23:35:51 <sssilver> "should that be a graph or a matrix"
23:35:55 <sssilver> etc etc etc
23:37:29 <kadoban> Well, that kind of suggests you're not really interested in algorithms of this sort ... so maybe don't bother with competitive programming as a hobby I guess? This type of thing is rather separate from most programming you see day-to-day for most people really.
23:38:02 <kadoban> Though thinking all algorithms are boring is ... maybe not the best mindset to have as a programmer, but perhaps you mean something different from the usual by "algorithms"
23:42:45 <sssilver> kadoban I mean, yes it depends on your definition of an "algorithm"
23:42:51 <sssilver> all code is in a way an "algorithm"
23:42:57 <sssilver> no I don't find code boring
23:43:18 <sssilver> I find it pleasant and fun to model abstract systems that I design in my head
23:44:19 <sssilver> but unfortunately in this world all the companies judge your worth by asking you programming puzzles
23:44:45 <sssilver> and even if I can sometimes answer them, I don't even feel like that taps in any way into the actually valuable programming skills that I have in my head
23:45:36 <kadoban> Not all of them. Quite a few of the bigger ones seem to ask at least a bit. *shrug*, you could probably talk your way through not having to answer one to get a job if you really need to maybe.
23:47:00 <sssilver> OK I have a question for you -- how do you go about getting better at solving an unexpected algorithmic problem like generating all polyominoes permutations?
23:47:12 <sssilver> clearly it's not an algorithm you have to learn by heart
23:47:21 <coms> This may not be the correct channel, but I'm taking a shot: is confluence the same as normalization?
23:48:09 <MarcelineVQ> sssilver: I think you already know the answer to that right? :>
23:48:36 <kadoban> sssilver: Go on one of the competitive programming sites and start at the easy ones, move up slowly. If you get stuck, ask people at least so you know what concept is suggested by the problem and learn it better, etc. There's a few sites. hackerrank is okay, I do a few there when I'm bored, codeforces is supposed to be good I think
23:48:43 <sssilver> MarcelineVQ unfortunately I don't :(
23:48:53 <MarcelineVQ> love, peace, and practice
23:49:09 <sssilver> MarcelineVQ practice what? you can't practice generating polyominoes, that's the problem
23:49:52 <kadoban> You seem to be stuck thinking they're all some problem that particularly pissed you off, I have no idea what that word-phrase thing is ...
23:50:14 <sssilver> kadoban hm?
23:50:33 <kadoban> "polyominoes" that you keep mentioning
23:50:36 <kadoban> Never heard of it
23:51:00 <sssilver> kadoban ah think like Tetris pieces but not made of 4 blocks but N blocks
23:51:30 <sssilver> kadoban https://en.wikipedia.org/wiki/Polyomino
23:52:11 <MarcelineVQ> "<sssilver> MarcelineVQ practice what?" problem solving. check out codingame.com if you want to have half-way fun things to try to tackle
23:52:15 <kadoban> I don't recall ever seeing a problem that dealt with those
23:56:03 <guillaum2> I just discovered that `min` and `max` are respectively left and right biased (such as, if `compare a b == EQ`, then `min a b == a` and `max a b == b`. Do you know about this behavior? Is this documented ?
23:59:05 <sssilver> kadoban can you make an algorithm that generates all polyominoes of given N complexity?
23:59:12 <sssilver> in case of 4, it'd generate all the tetris pieces
23:59:21 <sssilver> in case of 2, it'd generate a domino
