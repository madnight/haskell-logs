00:02:13 <l_zzie> cheater, loose connection, probably
00:02:34 <l_zzie> maybe solder "whiskers"
00:03:54 <Squarism> how can i add type signature to a do-clause like : x <- action
00:04:10 <l_zzie> x <- (action :: Something)
00:04:37 <l_zzie> probably x <- (action :: SomeMonad SomeThing)
00:05:55 <jle`> Squarism: you can also do x :: Foo <- action with the ScopedTypeVariables extension
00:06:44 <Squarism> jle`, oh ok
00:06:46 <Squarism> ill try that
00:16:10 <jle`> the integral typeclass in haskell has nothing to do with integrals
00:38:30 * hackagebot hspec-expectations-lifted 0.8.2 - A version of hspec-expectations generalized to MonadIO  https://hackage.haskell.org/package/hspec-expectations-lifted-0.8.2 (SimonHengel)
01:00:43 <jchia1> How can i conveniently start a new thread to execute an IO and kill it if it does not finish within some fixed time? The IO may create an external process and I want a timeout to also kill the process.
01:01:11 <jchia1> It doesn't necessarily have to be a new thread but I just thought a new thread would be cleaner.
01:03:30 <icosane> jchia1: You could first start a thread A which executes an I/O action and then start another thread B that waits for a fixed amount of time and then kills thread A and the process. Also, thread A must kill thread B when the I/O action is completed.
01:04:04 <jchia1> icosane: Won't A die when it finishes the IO?
01:04:16 <jchia1> Won't A automatically die when it finishes the IO?
01:04:37 <jchia1> i see you mean A has to kil B
01:04:57 <icosane> jchia1: Yes, when the I/O action is completed
01:05:45 <jchia1> Are there libraries for such things?
01:06:25 <icosane> jchia1: I don't know whether there are libraries for limiting the execution time, but it would not be too hard to write one yourself.
01:07:17 <jchia1> iconsane: From the original thread, how do I tell whether thread A died naturally?
01:07:37 <jchia1> check for some MVar?
01:07:43 <icosane> jchia1: yes
01:07:56 <icosane> jchia1: I think so
01:08:13 <icosane> jchia1: I'm trying to write a library for that
01:08:29 <jchia1> iconsane: There could be other ways, but MVar is most obvious to me. I'm not familiar about how exceptions and threads work together. Thanks.
01:10:16 <liste> :t timeout
01:10:18 <lambdabot> error: Variable not in scope: timeout
01:10:25 <liste> @let import System.Timeout
01:10:26 <l_zzie> yeah, System.Timeout has timeout
01:10:26 <lambdabot>  Defined.
01:10:30 <liste> :t timeout
01:10:32 <lambdabot> Int -> IO a -> IO (Maybe a)
01:11:08 <jchia1> l_zzie: But the max timeout is too short. It's not even an hour.
01:12:41 <l_zzie> do you mean maxBound or something else?
01:12:52 <jchia1> max Int is about 2^31
01:13:04 <jchia1> The unit is microseconds, so that's only 2147 seconds.
01:13:38 <l_zzie> Oh, you have a 32-bit machine?
01:13:47 <jchia1> I thought Int is 32-bit?
01:14:02 <jchia1> OK, I was mistaken
01:14:10 <jchia1> I have a 64-bit machine and this should work
01:14:18 <l_zzie> > maxBound :: Int
01:14:21 <lambdabot>  9223372036854775807
01:15:06 <l_zzie> > logBase 2 $ fromIntegral (maxBound :: Int)
01:15:08 <lambdabot>  63.0
01:15:50 <jchia1> l_zzie: But if the IO creates an external process and I want the process to die on timeout, I'll have to do additional work myself, right?
01:16:09 <l_zzie> I'm not sure
01:16:11 <l_zzie> probably
01:16:13 <jchia1> What about putting cleanup IO in an MVar that I read outside?
01:16:29 <jchia1> If the MVar is empty, then no cleanup to do.
01:17:54 <lpaste> icosane pasted “timeout IO” at http://lpaste.net/324053
01:17:55 <l_zzie> that could work. or you could sleep and check if it's alive with 'kill' in a loop.
01:18:10 <l_zzie> I don't know if that's the best way though.
01:18:11 <icosane> jchia1: I was thinking of something like that
01:18:16 <icosane> (lpaste)
01:19:42 <jchia1> icosane: What is c?
01:20:42 <lpaste> icosane pasted “timeout IO 2” at http://lpaste.net/324058
01:28:31 * hackagebot timeconsole 0.1.0.1 - time each line of terminal output  https://hackage.haskell.org/package/timeconsole-0.1.0.1 (AlanHawkins)
01:32:21 <lpaste> icosane pasted “timeout IO 3” at http://lpaste.net/324079
01:38:37 <jchia1> icosane: nobody's killing the watchThread
01:44:33 <lpaste> icosane revised “timeout IO 3”: “timeout IO 4 for jchia1” at http://lpaste.net/324079
01:47:34 <icosane> jchia1: let the watch thread wait a bit, then put Nothing in the mvar, and let the computation thread start directly and after put something in the mvar. The two results cases (watch thread puts something in mvar, computation thread puts something in mvar) can easily be distinguished from each other. Read something from the mvar and kill the losing thread.
01:48:06 <jchia1> icosane: The performThread knows what it needs to do for cleaning up. Outside threads may not know. So, maybe it makes more sense to let the performThread catch exceptions to do cleanup on its own. For example, if performThread spawns a process, only it knows what that process is.
01:50:52 <icosane> jchia1: cleaning up in the performThread should work, if you don't forget to catch exceptions (I would use finally from MonadMask), like you said
01:52:06 <jchia1> icosane: Control.Monad.Catch.finally?
01:53:04 <icosane> jchia1: Control.Monad.Catch.finally. I never have used that, but I don't really use haskell much either.
01:55:36 <icosane> jchia1: or bracket, from the same module
01:56:14 <damian_> hello everyone, I am having problems using hdevtools in my stack project. for some reason it's giving me the following error "unable to load package `cryptonite-0.15'"
01:56:21 <jchia1> OK
01:56:29 <damian_> I guess is looking for packages outside the stack project
01:56:50 <damian_> can someone help me understand what is going on?
01:58:03 <jchia1> damian_: Which stack resolver are you using? Did you specify that version of cryptonite in your cabal file?
01:58:32 <jchia1> or maybe some other package you use needs that version of cryptonite
01:59:12 <damian_> jchia1: I am using "resolver: lts-6.12" but if I stack build or stack install it's working finr
01:59:15 <damian_> fine
02:02:15 <jchia1> damian_: I'm not familiar with hdevtools, so just a wild guess. maybe you need to explicitly build cryptonite first or hdevtools doesn't know where to get it?
02:03:00 <damian_> jchia1: maybe, will continue doing research. Does anyone know any better way to use vim with haskell appart from hdevtools?
02:03:07 <damian_> is ghc-mod any better?
02:03:27 <jchia1> I don't know about vim but ghc-mod with atom is pretty smooth
02:05:20 <damian_> right, thanks jchia1, will try hdevtools a little more and if not use atom.. I would really like to stick with vim
02:13:18 <oded_> damian_: try stack clean --full
02:15:39 <damian_> oded_: same problem, builds correctly, hdvetool check gives unable to load package....
02:16:15 <damian_> it really looks like hdevtools is getting dependenciy packages globally instad of the once inside the stack project
02:17:09 <tsahyt> I have a C library which exhibits access to runtime statistics. it's key based. you can get a root key, and each key points to either a map, array, or value, which you can traverse from there. So in essence it is a tree. Since it is read-only, I've been thinking about wrapping access to this in something nicer. I want a composable way to describe a path through the tree. So far I've come up with this:
02:17:11 <tsahyt> http://lpaste.net/8449533820490743808
02:17:17 <tsahyt> does this look somewhat reasonable to use?
02:17:37 <tsahyt> I could of course provide a synonym for >=>
02:19:43 <tsahyt> I suppose I'm just reinventing some particular kind of lens again
02:20:47 <oded_> damian_: are you running "stack install hdevtools"
02:21:50 <damian_> oded_: yes....after stack install hdevtools in the project: Copied executables to /home/damian/.local/bin:- hdevtools
02:22:42 <tsahyt> the problem I have is that because I don't know the shape of the tree in advance, every lookup can possibly fail. afaik Getters don't support that
02:23:34 <l_zzie> there are non-Getter lenses
02:23:59 <tsahyt> right, but I cannot write back into the library
02:24:10 <l_zzie> I see
02:24:24 <tsahyt> when providing a pure version of the object, it doesn't matter that much. the user could do whatever they want to their modified version of course
02:24:24 <l_zzie> why do you want lensiness at all, then?
02:24:42 <tsahyt> l_zzie: because the interface provided by the library itself is really really awful
02:25:04 <l_zzie> I mean, what's wrong with what you have?
02:25:22 <tsahyt> with what I posted? not sure yet
02:25:38 <oded_> damian_: try to run "stack install hdevtools" outside your project, in /tmp where there is no stack.yaml 
02:25:55 <tsahyt> that's why I am asking. I feel like I don't have enough experience with this sort of thing.
02:26:01 <l_zzie> tsahyt, Traversable / Foldable et al might be useful to have
02:26:14 <l_zzie> maybe Functor. maybe Monad.
02:26:14 <damian_> oded_: yes, tried that already, same problem :/
02:26:24 <tsahyt> yes, I would provide instances when possible
02:26:24 <icosane> tsahyt: how is the interface of the library like? (provide a link to API documentation, show how you would use it from C ...)
02:26:43 <tsahyt> icosane: https://potassco.org/clingo/c-api/current/group__statistics
02:26:51 <tsahyt> an example is here: https://potassco.org/clingo/c-api/current/statistics_8c-example.html
02:28:24 <tsahyt> the main use-case is to run the main function of the library (i.e. solving a logic program), and then checking the statistics object for information that you might want to use
02:28:48 <tsahyt> I suppose you could use it for progress reporting if you tried, but I don't think the library does anything to prevent race conditions or anything for that
02:29:29 <younder> This linear logic stuff is cool. Thinking of making a dataflow pipeline using the Par monad. 
02:30:18 <icosane> tsahyt: I would first write a low-level interface with the FFI (foreign function interface), literally wrapping the underlying C API (pointers, lots of IO monads ...) I don't really know clingo, but if you would write a simple, although low-level API,  you can start using it.
02:30:36 <tsahyt> icosane: I have already done so, for the entire library
02:30:50 <tsahyt> twice, actually. one that is 1:1 bindings, and one that introduces safety where possible
02:31:09 <tsahyt> now I want to take some parts (like this) and provide a decent interface for it. other parts of the library are decently usable as is
02:32:24 <icosane> tsahyt: do you only retrieve information from the library, or do also need to modify C data structures? If it is only for reading, building a haskell data structure based on the C structure is enough.
02:37:01 <tsahyt> icosane: for the stats thing I only need to retrieve it
02:37:24 <tsahyt> there's another structure that is somewhat similar that allows writing too
02:38:34 * hackagebot pkcs10 0.2.0.0 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.2.0.0 (ktimothy)
02:41:31 <m1dnight_> Im trying to play around with uniplate and I'm trying to use it to transform from one data structure (data Exp) to another data type (data CoreExp)
02:42:00 <m1dnight_> Is there any way I can make uniplate automatically reapply the transformation to its children?
02:42:11 <m1dnight_> I know it does that when you use the same data type as return value, but now I have another one.
02:42:18 <m1dnight_> If that makes sense
02:43:36 <lyxia> m1dnight_: para :: Uniplate on => (on -> [r] -> r) -> on -> r
02:50:50 <m1dnight_> Ah, so if I'm not mistaken, the fold returns a list with all the expressions that have been converted up to that point
02:50:52 <m1dnight_> I think I get it
02:51:16 <m1dnight_> And then when I encounter, e.g, (EMinus 5 6) I can take the first two elements of the list and replace them with the children of my Expression
02:51:24 <m1dnight_> Giong to give it a shot. Thanks lyxia 
02:51:37 <lyxia> there would be only two elements
02:51:57 <lyxia> I believe the list contains only the transformed children
02:52:05 <lyxia> poor children
03:16:36 <jarlg> I have a local cabal package implementing a library and exposing certain modules. How can I include these modules in another local package? Using stack, neither extra-deps or extra-lib-dirs seems to help..
03:17:40 <lyxia> jarlg: you can put the path to your local package in the "package" field
03:19:58 <LordBrain> jarlg, i don't use stack, but in cabal, you can add-source the directory of the other local package
03:20:19 <LordBrain> if you are building in a sandbox
03:20:34 <tsahyt> I can still force the result of a lazy IO operation using appropriate seqs, right?
03:20:42 <jarlg> lyxia: Yes, tried that as well. It seems to bulid the executable of the package I want to include, but doesn't make the exposed-modules available. (Stack warns me to add the exposed-modules to 'other-modules' of the executable, but it doesn't change anything.)
03:21:04 <LordBrain> oh wait i missunderstood your issue i think
03:21:16 <merijn> tsahyt: Maybe using deepseq and lots of voodoo, but it'll be tricky to say the least
03:21:20 <jarlg> LordBrain: No your suggestion seems reasonable, will try!
03:21:36 <tsahyt> merijn: I have constructors for the entire structure available
03:21:45 <tsahyt> and it's a relatively simple one, just a tree
03:21:54 <tsahyt> well, kinda a tree anyhow
03:22:17 <lyxia> jarlg: can you show us the .cabal file?
03:24:37 <jarlg> lyxia: It's the unaltered one given by 'stack new name Simple'
03:26:45 <lyxia> jarlg: uh, I don't see a library in mine.
03:27:08 <jarlg> lyxia: Ah, you mean for the package I want to include, of course.. sorry just a second :)
03:28:15 <jarlg> https://hackage.haskell.org/package/hscd-0.0.3/src/hscd.cabal
03:28:47 <jarlg> (it implements bindings for the soundcloud API as well as a command line executable, I just want to use the bindings)
03:29:00 <jarlg> lyxia: ^ :)
03:29:21 <lyxia> jarlg: stack warning about putting your modules to other-modules is a separate issue due to the executable and the library being in the same directory
03:30:30 <jarlg> lyxia: Alright. I'll also mention I've changed that cabal file to remove restrictions on aeson, and it compiles fine (if not the aeson dep is too old for stack).
03:30:43 <lyxia> jarlg: your executable is not reusing the library, the compiler sees the file in src/ as modules that are local to the executable when building it, and not part of the previously built library.
03:33:59 <jarlg> lyxia: Not quite sure I understand, the executable does use the library (i.e. import Network.SoundCloud ...) but I see it isn't mentioned in the cabal file. Anyway the executable doesn't interest me; can I just "import the exposed modules"?
03:36:29 <lyxia> jarlg: you can
03:37:38 <anhex> Does anyone know of a good example of a plugin architecture?
03:37:43 <anhex> Any open source project?
03:38:32 <lyxia> jarlg: you can see that the executable does not depend on the library because of the fact that the library does not appear in its build-depend field. If you move the executable module in a separate directory, it will not compile because the compiler cannot find the modules anymore.
03:41:27 <jarlg> lyxia: Yes, I see -- I guess the cabal file should be updated to include the library as a dependency of the executable?
03:41:54 <lyxia> jarlg: anyway, I couldn't find anything wrong. here is an example of a setup where a program depends on a local hscd http://lpaste.net/324315
03:42:01 <jarlg> lyxia: For now I've just removed the executable field, and things seem to work better.
03:42:07 <jarlg> lyxia: oh, thanks!
03:42:12 <jophish> What the mnemonic for Biff and Tannen from bifunctors?
03:43:52 <lyxia> jarlg: it is also important to put the library and the executable(s) in separate directories, so it is not possible to do it retroactively on uploaded packages.
03:44:43 <srhb> jophish: Is it from the McBride paper?
03:45:09 <jarlg> lyxia: what do you mean by "it" in "...do it retroactively..."?
03:45:20 <lyxia> jarlg: I admit it is a fairly minor issue, though I see many packages affected by it, and at best it can cut compilation time in half.
03:46:48 <lyxia> jarlg: I mean making the executable actually depend on the library and use its precompiled modules. Just adding the library in build-depends won't change anything.
03:48:43 <jophish> srhb: I couldn't find them in there
03:48:47 <jarlg> lyxia: Yes, it'd be best to have two separate directories (one executable, one library) and have their relation explicit in the .cabal file? So changes to executable won't force recompile of library, for example.
03:48:53 <jophish> edwardk: ^
03:49:31 <jarlg> lyxia: Thank you for explaining, makes good sense.
03:50:14 <srhb> jophish: Hum, no idea then...
03:50:28 <lyxia> jarlg: Yes that's right. Changes to the executable already don't force a recompilation of the library anyway though. The problem is the library being compiled twice.
03:51:20 <srhb> jophish: It's a BTTF reference, but aside from that... :-P
03:53:17 <jophish> yeah, I couldn't quite figure out the connection
04:42:17 <bonnie_> hi does anyone know if theres is a beginners channel?
04:43:19 <liste> bonnie_: #haskell-beginners, but we're beginner friendly too, if you don't mind witnessing pretty abstract conversations every now and then
04:43:46 <liste> we certainly don't mind answering beginner questions
04:44:40 <bonnie_> ok but im a really zero beginner :)
04:46:49 <bonnie_> liste_: do you know how a download of haskell platform works on a mac? unfortunately i bought my laptop before studying cs...
04:48:00 <bonnie_> liste_: i downloaded stack and atom but can't go further...
04:48:17 <liste> bonnie_: are you comfortable with the command line?
04:48:23 <liste> Terminal.app
04:48:33 <liste> (I'm not a Mac user, but know something)
04:50:48 <bonnie_> Liste_: u mean the command line tools? i installed them via Xcode, but i can never go further than the installation... 
04:51:46 <liste> bonnie_: is there a Terminal.app in your applications?
04:51:55 <bonnie_> liste_: terminal i know! i already used it
04:52:16 <liste> what happens if you type "stack setup" and Enter into your terminal?
04:52:25 <liste> without the quotes
04:52:55 <bonnie_> liste_: gives me a long answer
04:53:13 <liste> bonnie_: can you paste the output to http://lpaste.net/ ?
04:54:55 <bonnie_> liste_: it says something about GHC in Path
04:55:55 <liste> bonnie_: what something?
04:57:08 <bonnie_> liste_: wait, in a minute
04:57:42 <bonnie_> liste_:To use this GHC and packages outside of a project, consider using: stack ghc, stack ghci, stack runghc, or stack exec
04:58:02 <bonnie_> liste_: thats what it says
04:58:04 <liste> bonnie_: then seems you're good to go
04:58:09 <liste> bonnie_: try running "stack ghci"
04:58:29 <bonnie_> liste_: nice! thank you
04:59:23 <liste> you should end up with a prompt something like this http://lpaste.net/324347
04:59:44 <liste> and then you can start typing Haskell expressions into the "Prelude>" prompt
05:01:14 <bonnie_> liste_:Okay nice thank you!! and can i also open this in atom instead of terminal?
05:02:19 <bonnie_> liste_:okay i have to leave im afraid! u helped me a lot!! thanx a lot!!
05:02:23 <liste> bonnie_: it should be possible, if you follow instructions in https://atom.io/packages/ide-haskell
05:02:44 <liste> bonnie_: you're welcome
05:03:05 <shlevy> When pattern matching on an existentially quantified constructor, can I bind the type variable somehow to make a Proxy?
05:08:34 <ph88> can anyone tell me why this is causing a parse error later on in my code?   https://paste.fedoraproject.org/468099/14780884/
05:10:05 <lyxia> shlevy: yes you can http://lpaste.net/324351
05:10:57 <lyxia> ph88: where c ceiling sigs / pc
05:11:24 <shlevy> lyxia: the GADT there just makes the forall implicit, right?
05:11:35 <lyxia> yes indeed
05:12:05 <shlevy> Thanks!
05:12:17 <narff> ph88: also to add a to the end of a list you do ps ++ [x]
05:14:48 <narff> is there a why to auto-edit the code so the imports are narrowed down to the actual functions I use?
05:16:14 <ongy> ghc can output it
05:16:29 <ongy> and there was a package on hackage for it, but last I tried I failed to build it
05:17:52 <lyxia> HaRe used to do it, but the latest rewrite hasn't caught up with this feature yet.
05:18:04 <ph88> narff, what you mean add a to end of list ?
05:19:01 <alanz> lyxia et al: contributors welcome
05:19:11 <lyxia> :)
05:21:56 <ongy> who's the ide engine coming along?
05:23:41 <hpc> who indeed ;)
05:27:11 <merijn> narff: With -Wall GHC warns you for unused imports, IIRC
05:27:40 <merijn> narff: Or did you mean going from "import Foo" to "import Foo (bar,baz,xyzzy)"?
05:29:48 <narff> merijn, the latter
05:30:12 <merijn> narff: I usually just change "import Foo" to "import Foo ()" and then manually add names the compiler yells about
05:33:32 <narff> merijn, i do that too but i'm looking a better way. I think it would be nice extension to stylish-haskell
05:34:39 <merijn> narff: Yeah, I think it should be possible using, e.g. GHC-as-a-library. But I'm not aware of an existing solution
05:38:52 <absence> how do i import stuff in lambdabot?
05:39:19 <liste> absence: @let import
05:39:27 <liste> @let import Data.Monoid
05:39:31 <lambdabot>  Defined.
05:39:39 <liste> > "1" <> "2"
05:39:41 <lambdabot>  "12"
05:39:47 <absence> thanks
05:58:19 <ph88> [2..4] makes [2,3,4], why does [4..2] not make [4,3,2] ?
05:58:30 <ph88> what is the best way to make this list ?
05:58:44 <ph88> right now i have  [x..2]  which doesn't work
05:59:01 <ahihi> > [10,9..1]
05:59:06 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
05:59:52 <ph88> that would become    if x == 2 then [2] else [x,x-1,2]
06:00:21 <barrucadu> You could just do 'reverse [2..x]'
06:00:59 <ahihi> > let range a b | a > b = [b,b-1..a] | otherwise = [a..b] in (range 1 5, range 5 1)
06:01:01 <lambdabot>  ([1,2,3,4,5],[])
06:01:09 <ahihi> oops
06:01:15 <ahihi> > let range a b | a > b = [a,a-1..b] | otherwise = [a..b] in (range 1 5, range 5 1)
06:01:17 <lambdabot>  ([1,2,3,4,5],[5,4,3,2,1])
06:03:26 <yhhko> can anyone on a mac do a small test for me? compile a C hello world program: ghc -no-hs-main hello_world.c , and see if it runs.
06:05:01 <ahihi> it does
06:05:03 <merijn> yhhko: Works for me
06:05:40 <yhhko> ahihi, merijn: huh, that's curious. okay, thanks
06:05:56 <merijn> yhhko: Which version of GHC, which version of OSX and which version of Xcode?
06:06:12 <yhhko> uh let me find out
06:07:33 <yhhko> merijn: i don't know which version of OSX (the Travis CI one), both ghc 7.10.3 and 8.0.1 fail
06:07:46 <haasn> Is it just me or do all programs compiled with GHC 8 use >1 TB of virtual memory? even a hello world
06:07:48 <yhhko> but maybe we're calling it with more complicated flags that break things
06:08:05 <merijn> I'm on OSX 10.11, GHC 7.10 and XCode 8.0 (I think?)
06:08:20 <merijn> But version of OSX and xcode are rather crucial
06:08:35 <ahihi> haasn: https://downloads.haskell.org/~ghc/master/users-guide/8.0.1-notes.html#runtime-system
06:09:00 <merijn> haasn: Working as intended
06:09:08 <haasn> Ah okay, thanks
06:09:22 <yhhko> merijn: "Travis CI uses OS X 10.11.6 (and Xcode 7.3.1) by default ."
06:09:30 <yhhko> can't verify that though
06:09:41 <merijn> Maybe this will *finally* teach people that virtual memory is a stupid measure of efficiency >.>
06:10:26 <merijn> yhhko: Have you tested compiling the C code using clang?
06:10:35 <yhhko> merijn: it's a hello world program
06:10:35 <merijn> yhhko: Are your compilation flags clang compatible?
06:10:55 <yhhko> not sure what the compilation flags are, i'm about to find out in 25 minutes when the test runs
06:11:18 <yhhko> but the compiler ain't choking. it segfaults.
06:11:51 <merijn> uh....
06:11:54 <merijn> That can't be right
06:12:53 <yhhko> and the best part is that it works fine on linux and windows
06:13:22 <yhhko> merijn: sorry, let me clarify: the compiler doesn't choke on it; it compiles. the compiled executable segfaults
06:13:30 <yhhko> that was a bit ambiguous
06:14:16 <merijn> haasn: The gist is basically "GC is dramatically easier if we can assume a single, huge, contiguous address range. So if we just reserve a 1 TB address we can assume that's true and actually request memory we need on demand"
06:14:34 <haasn> neat, apparently it's a 8%-9% performance boost in benchmarks?
06:14:42 <haasn> oh, just for GC work
06:14:52 <merijn> Basically, sometimes faster, sometimes no difference, but never worse
06:15:26 <merijn> Only "downside" is huge virtual listings due to the way kernel accounting of virtual reservations go
06:15:47 <merijn> But resident is the only real measure of RAM usage anyhow
06:19:29 <yhhko> merijn: okay, so i think the culprit was a couple of linking flags?
06:19:58 <merijn> yhhko: Could very well be, OSX linker flags are wildly different from linux
06:20:11 <yhhko> merijn: can you try your hello world thing when linking in some random other C library?
06:20:17 <haasn> merijn: makes htop mark it red :p
06:20:31 <yhhko> merijn: like add -lm or something
06:21:01 <merijn> yhhko: How are you passing those linker flags? Directly to ghc?
06:21:04 <yhhko> yeah
06:21:15 <yhhko> e.g. ghc -no-hs-main hello_world.c -lm
06:21:56 <merijn> Works fine here
06:22:00 <yhhko> :o
06:22:40 <yhhko> merijn: okay, thanks
06:23:02 <yhhko> we'll just solve this a different way
06:24:25 <patsToms> morning. Can someone give any hints with this? So I am talking about code from here - http://vpaste.net/Bu0x4 . If I am trying to execute ff_a in ghci but I got this http://vpaste.net/VfJV4
06:24:59 <lyxia> patsToms: what is that supposed to do
06:25:21 <patsToms> is there any way to get that output in ghci without makeing own functions which will output that structure?
06:25:21 <merijn> patsToms: Functions can't be printed
06:32:20 <patsToms> ok. Seems like I don't understand something. I can just output that tree in ghci, but what is wrong with ff_a then? As I understand it is a function which returns data
06:32:44 <merijn> patsToms: You need to call the function to get a result
06:42:49 <piyush-kurur> anyone knows how to make criterion benchmarks print cpu cycles 
06:44:57 <saurabhnanda> piyush-kurur: just the person for my existential question. https://github.com/tomjaguarpaw/haskell-opaleye/issues/225
06:45:47 <metl> how do i un-install stack/stackage ?
06:47:09 <piyush-kurur> saurabhnanda: tough luck. Lens is still beyond me. I have a hazy view through lenses (pun intended)
06:47:44 <saurabhnanda> piyush-kurur: too much category theory :)
06:48:06 <sm> metl: rm -rf ~/.stack ; rm ~/.local/bin/stack ?
06:49:23 <metl> sm: stack is in /usr/local/bin/stack though? i see a stack package in aptitude but it's not installed so i don't remember how stack got installed in the first place
06:49:53 <sm> ok, then the answer is probably apt[itude] remove stack
06:50:03 <MarcelineVQ> piyush-kurur: a Report value includes cycle information in the reportMeasured field, e.g. reportMeasured <$> (benchmark' $ whnf head [1..1000])
06:50:23 <metl> the problem is ghc 8.0.1 is installed, and when i try to stack upgrade it says it wants ghc 7.10.3, even though i was using nightly in the global package config
06:50:40 <metl> sm: it shows *not* installed in aptitude
06:50:56 <MarcelineVQ> piyush-kurur: more info here https://hackage.haskell.org/package/criterion-1.1.1.0/docs/Criterion-Types.html#t:Report
06:51:28 <sm> metl: what's your goal ? upgrade to the latest stack ?
06:51:52 <metl> as long as LTS is ghc 8.0.1 that's all i need
06:52:58 <metl> sm: well actually i'm trying to upgrade Idris, which requires me to run stack build
06:53:35 <sm> metl: and that works already, or.. ?
06:53:36 <chpatrick> hey
06:53:52 <chpatrick> do you know of a deferred list representation that supports zipWith without forcing?
06:54:07 <metl> sm: i think i reached an error which started me on this upgrade path :) i'm running it again to see what happened
06:54:12 <chpatrick> similar to how lists are represented as foldrs internally in many operations
06:54:37 <chpatrick> but afaik zipWith x y is only a "good consumer" for x or y
06:55:27 <metl> sm: error while building libffi-0.1: the pkg-config package 'libffi' is required but it could not be found
06:56:05 <sm> perhaps you need apt install libffi-dev
06:57:59 <sm> and for upgrading, perhaps stack --system-ghc upgrade works
06:58:07 <lyxia> chpatrick: what is a "good consumer"
06:58:09 <ph88> anyone know a library where i can input a bunch of input variables and a bunch of output variables and it will find a formula for it ?
06:58:35 <MarcelineVQ> lyxia: an operation that fuses when paired with a good producer iirc
06:59:44 <MarcelineVQ> lyxia: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#list-fusion
07:00:15 <metl> sm: i think missing libffi-dev was it :)
07:00:21 <chpatrick> MarcelineVQ: lyxia: what I'm looking for is zipWith :: (a -> b -> c) -> Deferred a -> Deferred b -> Deferred c
07:00:31 <chpatrick> that doesn't internally turn Deferred into a list
07:02:11 <chpatrick> or rather I'm looking for newtype Deferred a = ???
07:02:47 <lyxia> I kind of understand but not enough to help you here :/
07:03:09 <piyush-kurur> MarcelineVQ: thanks will try
07:13:43 * hackagebot hledger-ui 1.0.4 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-1.0.4 (SimonMichael)
07:30:28 <merijn> chpatrick: What's Deferred supposed to be/do?
07:31:55 <merijn> chpatrick: Aren't you just suggesting a lazy toList?
07:32:32 <chpatrick> merijn: do you know how good producers/consumers work?
07:33:49 <merijn> chpatrick: The basics
07:33:52 <chpatrick> most basic list operations actually operate on newtype DeferredList = DeferredList ((a -> b -> b) -> b -> b)
07:34:02 <chpatrick> and use RULES to put in conversions to [ a ] as needed
07:34:06 <chpatrick> or rather to take them out
07:34:36 <chpatrick> as far as I know this representation doesn't properly support zipWith because you need to turn one of the operands into a concrete list
07:34:49 <chpatrick> I'm wondering if there's a representation that does
07:36:23 <merijn> chpatrick: Eh, which newtype are you talking about? I don't see a newtype anywhere in base?
07:36:53 <merijn> chpatrick: What kinda data structure are you trying to zip?
07:37:36 <chpatrick> merijn: there's no newtype for it in base
07:37:54 <chpatrick> https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Exts.html#v:build
07:38:03 <chpatrick> it's here
07:40:11 <merijn> chpatrick: It's really unclear to me what your actual problem is?
07:40:40 <chpatrick> merijn: the problem is that you can't write zipWith that takes two of those deferred lists and produces a new one
07:40:48 <chpatrick> without internally turning one of them into a list
07:41:32 <merijn> Right, and?
07:41:36 <ph88> hey guys, sometimes i need to loop over something and remember something from the last iteration .. how can i do this? i tried with fold but this returns that "something from the last iteration" .. which should not be in the final output
07:41:42 <chpatrick> merijn
07:41:53 <chpatrick> I want to know if there's a different representation where that is possible
07:41:59 <chpatrick> because I want to avoid any intermediate list
07:42:12 <liste> ph88: return the something from the last iteration and strip it out finally
07:42:13 <kadoban> ph88: Strip it off afterwards?
07:43:52 <ph88> i could make a wrapper function so that it doesn't leak out in the rest of the program .. i was just wondering if there is such a function out of the box
07:43:56 <merijn> chpatrick: Well...no, afaik. Although I suppose that also depends on the limits of "different representation"
07:44:27 <merijn> ph88: I might know a trick, but it depends on exactly what you want
07:45:04 <ph88> merijn, i didn't know how to write it in haskell yet so i made it in php  http://pastebin.com/YB8Qky4w
07:45:41 <merijn> ph88: I don't know enough php to understand what that does
07:46:01 <ph88> ok
07:50:10 <jchia1> How could I go about writing a polymorphic function roughly like this: packArgs :: (a -> b -> ... -> z) -> a -> b -> ... -> z -> (a, b, ..., z). It needs to be able to handle functions of different arity.
07:50:46 <c_wraith> jchia1: in general, you don't.
07:50:46 <opqdonut> there's no easy way
07:50:56 <opqdonut> haskell doesn't really support generic tuple operations
07:51:19 <jchia1> Is there any hope if I use TH?
07:51:26 <c_wraith> Why do you even want it?
07:51:33 <jchia1> pack a closure
07:51:42 <jchia1> send it over the wire, let another process run it
07:52:10 <Squarism> Im using https://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty.html for some rest methods. A rest method like "get" seems to return ActionM results. I wonder, how do i invoke IO functions in the middle of such a ActionM do block?
07:52:11 <c_wraith> Why don't you see what any of the existing libraries that do that do?
07:52:44 <Squarism> (sorry for not using the right lingo). 
07:52:48 <jchia1> cloud haskell does similar things but it doesn't give you the nice packing functionality
07:52:51 <c_wraith> Squarism: there's a good chance ActionM is an instance of MonadIO.
07:52:57 <gargawel> ph88: what is your code supposed to do ?
07:52:59 <jchia1> you have to make the tuple yourself and it's not type-checked
07:53:00 <chpatrick> jchia1: you could do the variadic trick like printf
07:53:03 <c_wraith> Squarism: don't ignore instance lists
07:53:30 <chpatrick> jchia1: https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Printf.html#v:printf
07:54:36 <Squarism> c_wraith, instance lists?
07:54:37 <c_wraith> Squarism: turns out ActionM is an alias for ActionT Text IO, and ActionT has an instance (MonadIO m, ScottyError e) => MonadIO (ActionT e m)
07:54:49 <c_wraith> https://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty-Internal-Types.html#t:ActionT
07:54:58 <c_wraith> Squarism: see that huge list of instances under ActionT?
07:55:04 <c_wraith> Squarism: those are *really* important
07:55:08 <Squarism> ill have a look
07:55:19 <c_wraith> Squarism: and the instance you're looking for is MonadIO
07:55:19 <gargawel> ph88: it looks like a fold is indeed what you want - you may return something like (Int, [(Int,Int)]) and discard the first part to get the final results
07:55:55 <c_wraith> Squarism: see https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO for what MonadIO provides
07:58:45 * hackagebot network-multicast 0.2.0 - Simple multicast library  https://hackage.haskell.org/package/network-multicast-0.2.0 (ocramz)
08:07:40 <iddqd> hello folks. ive a delay when im in xmonad when i scroll through a terminal. thefe's a half second delay when i try to scroll and it then scrolls normal. what is happenning ? 
08:08:00 <Guest22482> hello, I am a haskell newbie and I have a problem with ghc packages on macOSX. my ghc cannot find mtl library although it is installed, if I run ghc-pkg I see mtl package under globally installed packages (vs locally installed) and it is exposed, but when I compile some code samples that rely on modules from this package, it does not compile. and also my editor complains that It cannot find Control.Monad.State .  Any Ideas on th
08:08:08 <ph88> gargawel, sorry i wasnt watching chat for a moment .. you still need explaination what the code is suppose to do ?
08:09:16 <liste> Guest22482: is the code inside a project?
08:09:51 <Guest22482> @liste yes it is, it is a simple homework assignment
08:09:51 <lambdabot> No module "yes it is, it is a simple homework assignment" loaded
08:14:22 <Guest22482> "yes it is, it is a simple homework assignment"
08:14:38 <srhb> Guest22482: prefix @ to a message triggers lambdabot :)
08:14:42 <liste> Guest22482: does the project have mtl exposed?
08:14:54 <liste> in the .cabal file
08:15:19 <Guest22482> I don't think so, I don't know what that is
08:15:49 <Guest22482> thank you srhb, I wonder how people tag each other here
08:16:12 <liste> Guest22482: like this
08:16:33 <jle`> sr<tab>
08:17:03 <Guest22482> <liste> I try to to load the that specific file to GHCi and I still get an error
08:17:43 * shapr hops randomly
08:19:29 <Guest22482> liste: like this !?
08:19:56 <liste> Guest22482: yes
08:20:44 <Guest22482> liste: like I said I load that file to GHCi and it complains
08:23:13 <liste> Guest22482: so there's no .cabal file around?
08:25:13 <Guest22482> liste: no there isn't, as far as know. I didn't create that file, nor that I downloaded a folder. I downloaded each file separately.
08:28:13 <shapr> Any Haskellers in Denver or Boulder? I'm looking for people to meet weekend Nov 06!
08:31:27 <miladz1> liste: no Ideas ? :/
08:35:22 <orion> Any Haskellers in the Boston area? I like long walks on the beach.
08:35:38 <shapr> ha
08:36:09 <Monoide> I wish
08:36:25 <shapr> Would also be nice to find more Haskellers in Atlanta
08:36:51 <Monoide> there're planty in Paris
08:38:10 <Clint> what happened to the ones in boston?
08:38:51 <orion> Clint: Ed Kemett was in Boston recently.
08:39:19 <shapr> edwardk: Are you still in Boston?
08:40:57 <eacameron> Sigh...It's not encouraging when your *first* medium-sized Haskell app for a client segfaults when sending an HTTP request. But only does so if you don't "print msg" first. :(
08:42:10 <ongy> segfault or some oom?
08:45:37 <eacameron> oom?
08:45:40 <eacameron> ongy ^
08:45:47 <eacameron> oh. Out of mem.
08:45:54 <eacameron> No. SEGV
08:46:30 <ongy> sounds bad. are you using any FFI you made?
08:46:53 * shapr hugs ongy 
08:47:12 <eacameron> ongy: I'm certainly not...although maybe a library underneath is. I'm using GHC 8. The problem exists on both Linux and darwin.
08:48:12 <eacameron> ongy: I'll build a minimal use case once the client has what they need to move on. For now...print msg is saving me from extreme embarrassment. 
08:48:51 <dolio> orion: There's a meetup in two weeks.
08:49:06 <dolio> Third Wednesday of every month.
08:50:48 <sdx23> eacameron: tried whether it's also solved by just evaluating msg instead of printing? Might be some lazyness issue.
08:55:25 <ph88> how can i pattern match on this record where size = 1 and nat i don't care about?  https://hackage.haskell.org/package/bv-0.4.1/docs/src/Data-BitVector.html#BV
08:58:51 <ph88> am i even obliged to mention all the members of a record when pattern matching ?
08:59:39 <verement> ph88: no
08:59:39 <Hafydd> ph88: when using brace notation, you are not obliged to mention any particular member.
08:59:57 <Hafydd> (For pattern-matching and updates, but not for construction.)
09:00:05 <ph88> ah ok
09:00:53 <ph88> i have the feeling this module does not actually export data constructor BV .. now i have trouble pattern matching on it .. is there a way around this ?
09:00:57 <orion> dolio: I gave the last one. :p
09:01:07 <dolio> Oh. :)
09:01:21 <MarcelineVQ> It's in the export list, how are you matching it now?
09:01:34 <MarcelineVQ> Oh it's just the type in the list maybe
09:01:43 <ph88> go itr bits@(BV {size=1}) = Algo3 bits nil 1
09:02:22 <verement> ph88: go itr bits | size bits == 1 = Algo3 bits nil 1
09:02:48 <ph88> ya ok guards guards !
09:07:34 <eacameron> sdx23: Yes I think that's probably it. The type doesn't have an NFData instance so I can't deepseq it. But printing will do for now.
09:09:14 <ph88> +++ OK, passed 100 tests.
09:11:02 <ph88> what can i do about this message:  Pattern match(es) are overlapped.   .. they may overlap but the code is as i want it
09:12:34 <ahihi> I believe that warning means you have a case that will never be reached
09:17:56 <jle`> ph88: if patterns are overlapping, the code is probably not as you want it
09:23:21 <nitrix> You can pattern match on records!?
09:23:40 <buck1> is this really the only doc for ghc TypeInType? https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1
09:23:55 <ongy> nitrix: what?
09:24:36 <nitrix> @let data Foo = MkFoo { foo :: Int }; bar (MkFoo {foo=5}) = "Yay!"; bar _ = "Nay!";
09:24:38 <lambdabot>  .L.hs:167:18: error:
09:24:38 <lambdabot>      Multiple declarations of ‘foo’
09:24:38 <lambdabot>      Declared at: .L.hs:159:1
09:25:03 <nitrix> @let data MyFoo = MkMyFoo { myFoo :: Int }; bar (MkMyFoo {myFoo=5}) = "Yay!"; bar _ = "Nay!";
09:25:04 <lambdabot>  Defined.
09:25:17 <nitrix> > bar (MkMyFoo 5)
09:25:18 <lambdabot>  "Yay!"
09:25:20 <nitrix> > bar (MkMyFoo 6)
09:25:23 <lambdabot>  "Nay!"
09:25:43 <buck1> ah here it is: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#overview-of-type-in-type
09:25:50 <buck1> it absolutly doesn't show up in google afaict
09:25:58 <nitrix> That's awesome! I didn't know that o:
09:28:02 <nitrix> ongy: That above. Pattern matching on records, taken from ph88's snippet.
09:28:39 <ongy> ah that. I thought people knew
09:28:53 <nitrix> I wonder if it's just a coincidence that it works because my record has no other fields so they're obviously equal.
09:28:55 <MarcelineVQ> nitrix: yep they're just datatypes with named fields :> Further you can export just those names and not the constructor to let people get things from your datatype and not make one themselves
09:29:46 <nitrix> What happens if I have extra fields, would my (MkMyFoo { myFoo = 5 }) -- leaving the other fields unitialized, work when it tries to get pattern matched?
09:30:20 <ongy> afaik
09:30:38 <geekosaur> nitrix, it matches the otgers against _
09:30:39 <nitrix> I guess the question is if the pattern is clever enough to understand I'm interested in the value of specific fields, rather than comparing the whole record for equality.
09:30:52 <nitrix> geekosaur: Awesome :)
09:31:00 <nshepperd> > case MkFoo 7 of MkFoo {foo = x} -> x
09:31:02 <lambdabot>  error: Not in scope: data constructor ‘MkFoo’
09:31:13 <nshepperd> > case MkMyFoo 7 of MkMyFoo {foo = x} -> x
09:31:15 <lambdabot>  error:
09:31:16 <lambdabot>      • Constructor ‘MkMyFoo’ does not have field ‘foo’
09:31:16 <lambdabot>      • In the pattern: MkMyFoo {foo = x}
09:31:20 <nitrix> myfoo :P
09:31:23 <nshepperd> :(
09:31:41 <nshepperd> > case MkMyFoo 7 of MkMyFoo {myFoo = x} -> x
09:31:43 <lambdabot>  7
09:32:18 <nitrix> That's not really answering the last question, but I'll trust geekosaur on that one.
09:32:21 <jle`> nitrix: there's that common idiom of matching on constructors and ignoring the fields, too
09:32:31 <jle`> > case Just 10 of Just{} -> "hello"
09:32:33 <lambdabot>  "hello"
09:32:44 <jle`> ^ that's just pattern matching on records, but not naming any records
09:32:47 <geekosaur> anyway given a record XX { a :: String, b :: Int, c :: Bool }, pattern XX {b = 5} is the same as XX _ 5 _
09:32:47 <nshepperd> :O
09:33:00 <nshepperd> that works even though Just wasn't defined with record syntax?
09:33:06 <geekosaur> (literally the same, you can use either one to match)
09:33:07 <jle`> XX{} is the same as XX _ _ _, for instance
09:33:14 <geekosaur> {} is a special case
09:33:15 <jle`> nshepperd: yeah, hlint told me heh
09:33:21 <geekosaur> that works even without record syntax
09:33:32 <nitrix> Oh true. I guess it's not very different than (MkMyFoo _ _ _)
09:33:57 <tsahyt> I need some input. I'm in the process of building a nice API on top of this C library. I've got raw bindings which are exported in a *.Raw.* namespace, which are pretty much the raw FFI functions. I've written versions for each of these that take care of exception handling, abstract the pointers and ugly details away etc. Now that I'm writing a Haskell API on top of these, I wonder whether I should export
09:33:58 <tsahyt> those "mid-level" bindings. I guess they'd be very useful if you want to build your own abstraction.
09:34:32 <merijn> geekosaur: I would argue {} is not a special case
09:34:59 <tsahyt> Since I already export the completely Raw ones, you can still do that even if I don't export them, but getting all the pointers out of the way etc is a lot of work if you just want to abstract something differently than I do
09:35:21 <merijn> geekosaur: { foo = ? } considers the field accessor foo, { foo = ?, bar = ? } considers two field accessors. Logically {} considers 0 field accessors and thus also works for everything without field accessors
09:35:28 <MarcelineVQ> { .. } is a special case :>
09:35:38 <Cale> It is a special case though, in that it works even if the type is not defined using record syntax.
09:35:38 <geekosaur> also an extension
09:35:44 <geekosaur> ^
09:35:49 <geekosaur> suppose it depends on how you look at it
09:35:52 <merijn> nshepperd: Also, yes, it works for all datatypes, good for writing future proof patterns/filtering
09:36:18 <nitrix> What happened to languages consistency D:
09:36:30 <merijn> Cale: That assumes an a priori assumption that "record" and "non-record" data types are indeed separated
09:36:33 <nitrix> I'd burn all the special cases.
09:36:48 <merijn> Which seems senseless, since you can can construct record datatypes without record syntax
09:36:58 <geekosaur> nitrix, you can do that, and then complain about all the boilerplate you have to write instead
09:37:00 <merijn> And you can mix record and non record constructors
09:37:11 <merijn> nitrix: It is consistent!
09:37:22 <merijn> nitrix: You just need to look at it from a different perspective!
09:37:40 <nshepperd> arguably { foo = ? } could be considered to 'work' even if the type is not defined using record syntax
09:37:47 <miladz1> if I want to import modules from other packages, is it necessary to have a .cabal file ? P.S I am a total noob
09:37:50 <merijn> @let data Foo = Foo { foo :: Int, bar :: Bool } | Bar Int
09:37:52 <lambdabot>  .L.hs:169:16: error:
09:37:52 <lambdabot>      Multiple declarations of ‘foo’
09:37:52 <lambdabot>      Declared at: .L.hs:159:1
09:37:56 <nshepperd> you just get an error because there's no 'foo' accessor
09:37:56 <merijn> @undefine
09:37:57 <lambdabot> Undefined.
09:37:59 <merijn> @let data Foo = Foo { foo :: Int, bar :: Bool } | Bar Int
09:38:00 <lambdabot>  Defined.
09:38:03 <merijn> eh
09:38:04 <merijn> @undefine
09:38:05 <Cale> "The pattern F {} matches any value built with constructor F, whether or not F was declared with record syntax." -- The Haskell Report saw a need for the distinction :)
09:38:05 <lambdabot> Undefined.
09:38:12 <merijn> @let data Foo = Foo { foo :: Int, bar :: Bool } | Bar Int deriving (Show)
09:38:14 <lambdabot>  Defined.
09:38:25 <merijn> > Foo 1 True
09:38:27 <lambdabot>  Foo {foo = 1, bar = True}
09:38:38 <nshepperd> > case Just 5 of Just { foo = x } -> x
09:38:40 <lambdabot>  error:
09:38:40 <lambdabot>      • Constructor ‘Just’ does not have field ‘foo’
09:38:40 <lambdabot>      • In the pattern: Just {foo = x}
09:38:51 <nshepperd> > case Sum 5 of Sum { foo = x } -> x
09:38:53 <lambdabot>  error:
09:38:54 <lambdabot>      • Constructor ‘Sum’ does not have field ‘foo’
09:38:54 <lambdabot>      • In the pattern: Sum {foo = x}
09:38:55 <merijn> > let x@Bar{} = Bar 1 in x
09:38:57 <lambdabot>  Bar 1
09:39:01 <miladz1> can someone help please ?
09:39:05 <nshepperd> ^^ seems consistent
09:39:23 <nitrix> merijn: That's actually a good point. YEah seems consistent to me.  foo (Bar 1) will explode though, right?
09:39:32 <merijn> nitrix: Right
09:39:32 <Cale> miladz1: Oh, no it's not necessary to have a .cabal file
09:39:37 <geekosaur> miladz1, that's the easy way. otherwise, you can hope ghc does the right thing or you can add -package parameters
09:39:59 <geekosaur> (best to only have one version of a package installed if you want to have it "just work" without any options or cabal file)
09:40:01 <merijn> > foo (Bar 1)
09:40:03 <lambdabot>  *Exception: No match in record selector foo
09:40:08 <nitrix> Gotcha.
09:40:33 <tsahyt> talking about packages, is there any good way to handle depending on two packages which export the same module name?
09:40:50 <tsahyt> It's not a current issue of mine but I remember having such a problem in the past
09:41:07 <merijn> nitrix: The nice part is that if you want match on *just* a constructor and not any fields, you can future proof your pattern!
09:41:12 <geekosaur> tsahyt, as long as you don't need to import both in the same module, you can use the PackageImports extension
09:41:35 <tsahyt> what if I'd need both in the same module?
09:41:38 <merijn> nitrix: Not very relevant for, e.g. Just or Left/Right, but for pattern matching in, e.g. an AST that's nice if you change the type a lot
09:41:39 <geekosaur> maybe even in the case of both in the same module but you may need qualified ... as (if only for sanity)
09:41:54 <tsahyt> qualified makes sense here
09:41:54 <geekosaur> but you will need PackageImports to be able to get at both
09:41:56 <nitrix> merijn: Now I have the inverse argument that the pattern (Foo) should also work and be understood as (Foo{})
09:42:08 <tsahyt> ok, thanks
09:42:10 <miladz1> geeksaur: well my ghci does not import any modules from my ghc packages, I don't know How I can do this
09:42:25 <ph88> where could i place a type to resolve this ambiguity ? https://paste.fedoraproject.org/468196/04891147/
09:42:28 <merijn> Although it's nice that you can write something like "selectLeft l = [x | x@Left{} <- l]"
09:42:31 <geekosaur> miladz1, where are these packages?
09:42:44 <geekosaur> does "ghc-pkg list" show them?
09:42:50 <geekosaur> how did you install them?
09:42:55 <merijn> nitrix: How do you distinguish nullary constructors from those with arguments?
09:43:39 <miladz1> geekosaur: installed here: /Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/lib/ghc-8.0.1/package.conf.d
09:43:55 <Cale> I seem to recall someone (maybe it was Duncan Coutts?) recommending against using PackageImports for some reason -- they were added for the base package major version transition, and there might be some caveats. Then again, that was a long time ago, it's quite possible they work just fine now.
09:43:56 <geekosaur> then I think something else is wronhg
09:44:27 <geekosaur> do you have a second ghci somewhere which is missing its package database, possibly because of incomplete removal of an older version from e.g. brew?
09:44:45 <geekosaur> (well, part of --- you would not get very far if base were missing)
09:45:08 <dcoutts> Cale: it's not that they "don't work", it's mainly that they're not the best solution to the problem of "which package do I want"
09:45:19 <nitrix> merijn: By name. Aren't there only a single Foo defined?
09:45:24 <miladz1> geekosaur: I don't know, how can I confirm this ?
09:45:38 <geekosaur> "type ghci
09:45:40 <geekosaur> er
09:46:20 <Cale> dcoutts: Oh, definitely fair enough :)
09:46:38 * geekosaur suddenly trying to recall if h-p went ahead with using /usr/local despite brew on systems with SIP
09:46:39 <nitrix> merijn: (Foo) would desugar to (Foo _ _ _ _) regardless how how many arguments there are. Kinda like (Foo{}) works.
09:46:57 <miladz1> geekosaur: I did type ghci and it launched ghci ! 
09:47:03 <geekosaur> yes, that proves little
09:47:12 <Cale> dcoutts: I suppose there's not much else in the way of disambiguating that if multiple packages that you need simultaneously are exporting modules of the same name.
09:47:19 <geekosaur> it launcges what version using what package db?
09:47:48 <dcoutts> Cale: these days you can do import renaming in the .cabal files
09:47:54 <Cale> dcoutts: ahhh
09:48:00 <Cale> I didn't know about that :)
09:48:08 <geekosaur> Cale, arguably PackageImports is a technical solution to a non-technical problem (reusing the same names in multiple packages). it's a fragile solution at best
09:48:25 <miladz1> geekosaur: version 8.0.1 , and I don't know the package db version. sorry for being such a noob :\
09:48:34 <Cale> import renaming in the .cabal files seems a good bit nicer
09:48:35 <dcoutts> Cale: this is part of the backpack stuff, similarly we can do re-exporting modules from other packages
09:48:53 <Cale> miladz1: try "ghci -v"
09:49:03 <Cale> miladz1: and look for "loading package database"
09:49:18 <geekosaur> see. ghci in particular auto-imports fully qualified names, so if it is not finding a module then it is not in that ghci
09:49:34 <geekosaur> s package db (or the package is broken; maybe "ghc-pkg check")
09:49:42 <Cale> Though I suspect that won't tell us everything -- it's likely to only show your global db
09:49:49 <miladz1> geekosaur: loading package database /Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/lib/ghc-8.0.1/package.conf.d
09:49:55 <Cale> yeah
09:49:57 <geekosaur> they're truing to import a package in the global db
09:50:25 <geekosaur> miladz1, then I think "ghc-pkg check" and put the output in a pastebin
09:50:27 <geekosaur> @paste
09:50:27 <lambdabot> Haskell pastebin: http://lpaste.net/
09:51:35 <geekosaur> (mac hint: "ghc-pkg check 2>&1 | pbcopy" then you can switch to the browser window and cmd-v into the paste sitetextarea
09:52:40 <miladz1> geekosaur: ghc-pkg check returns nothing
09:55:19 <miladz1> geekosaur: I did "ghc-pkg check" and it returned nothing
09:55:26 <geekosaur> yes. I saw
09:55:49 <geekosaur> sorry I am not responding to every isingle message immediately instead of trying to figure out what to try next ... I have no idea what is going on
09:55:50 <miladz1> sorry 
09:56:07 <miladz1> thanks
09:56:29 <geekosaur> all I can think of now is "ghc-pkg list" and make sure ghc thinks the packages exist
09:56:51 <geekosaur> could imagine some weirdness with the package cache but I'd think *something* would complain in that case
09:57:00 <miladz1> geekosaur: it returns a list of many packages
09:57:18 <geekosaur> hm
09:57:32 <miladz1> including the package that contains the module that I want to import
09:57:46 <geekosaur> maybe I should have checked something mroe basic first. how exactly are you trying to import the module?
09:58:33 <miladz1> geekosaur: I import them by typing import in a .hs file :/
09:58:43 <geekosaur> I..
09:58:50 <geekosaur> what part of "exactly" was not clear
09:58:55 <geekosaur> module name, exact spelling
09:59:00 <geekosaur> and exact *case*
09:59:24 <miladz1> geekosaur: import Control.Monad.State
10:08:48 <geekosaur> ok then I have no idea what is happening :/
10:13:20 <spopejoy> miladz1: is `mtl` in your package list? 
10:13:46 <spopejoy> try "ghc-pkg list | grep mtl"
10:13:53 <miladz1> spopejoy: yes it is
10:14:02 <spopejoy> how are you compiling?
10:16:07 <miladz1> spopejoy: I get error in my atom editor. and also when I load the file to ghci it gives error that it cannot find method from that module. but I don't compile it
10:16:44 <miladz1> spopejoy: I also get error when doing "runhaskell StringBufEditor.hs"
10:16:50 <spopejoy> try launching ghci, issue `:browse Control.Monad.State`
10:17:20 <spopejoy> you should see a bunch of info about the module
10:18:00 <miladz1> spopejoy: I do see bunch of info
10:18:52 <spopejoy> ok so `mtl` is there. so, what happens when you do `:load "StringBufEditor.hs"` (or whatever your file is called)
10:21:52 <tsahyt> http://lpaste.net/4577374624211271680
10:22:25 <tsahyt> can someone help me with this? I'm trying to define a Monad to keep track of some handles (and soon some other invariants) that is parameterized over a "stage" of computations
10:22:44 <tsahyt> this is used to implement a few callbacks. during the init callback I have different operations available
10:23:37 <tsahyt> hence the distinction between Propagation 'Init and Propagation 'Solving. Because they use different handles, I introduce a type family to map them accordingly. but the reader instance deriving doesn't work
10:23:50 * hackagebot quickcheck-special 0.1.0.0 - Edge cases and special values for QuickCheck Arbitrary instances  https://hackage.haskell.org/package/quickcheck-special-0.1.0.0 (minad)
10:25:03 <tsahyt> the additional s parameter is a phantom parameter used to scope handles within a function by using rank-2 types
10:25:10 <blackgnezdo> Is FFI cool with passing C struct parameters in? E.g. TF_Port here: https://github.com/tensorflow/tensorflow/blob/bad7c50b9dc9789ad7dd0a62daca40b7269841ed/tensorflow/c/c_api.h#L300
10:25:42 <tsahyt> blackgnezdo: no, you need a wrapper around this function that takes a pointer
10:25:44 <tsahyt> at least afaik
10:26:09 <jle`> tsahyt: it's interesting
10:26:12 <glguy> You can do it but you have to be careful
10:26:18 <jle`> have you tried defining the MonadReader instance by hand?
10:26:33 <chpatrick> blackgnezdo: in my experience the best thing to do in this situation is to put it in a ForeignPtr
10:26:39 <tsahyt> jle`: not yet, but that'd be the next thing to try I suppose
10:26:58 <chpatrick> data C'TF_Port
10:26:58 <chpatrick> newtype TFPort = TFPort (ForeignPtr C'TF_Port)
10:27:30 <glguy> You don't need a ForeignPtr if the pointer is being passed in and you're not responsible for freeing it
10:27:40 <chpatrick> yes
10:27:46 <glguy> or if its being passed in and you're immediately going to free it
10:27:57 <chpatrick> otherwise allocate it on the heap in C and free it from haskell with finalizerFree
10:28:27 <blackgnezdo> chpatrick: but I still have to write C glue, don't I?
10:28:34 <chpatrick> blackgnezdo: yes
10:28:53 <chpatrick> TF_Port *port = malloc(sizeof(TF_Port)); *port = get_port_from_somewhere; return port;
10:28:55 <chpatrick> to create
10:29:02 <chpatrick> then newForeignPtr finalizerFree portPtr in Haskell
10:29:24 <tsahyt> jle`: in trying to do so GHC tells me "Illegal type synonym family application in instance"
10:29:28 <chpatrick> then when you want to pass it in somewhere use withForeignPtr
10:29:31 <tsahyt> I could try defining the two instances separately I suppose
10:29:33 <glguy> blackgnezdo: You can import that TF_Port struct as a Ptr and CInt argument
10:29:41 <chpatrick> blackgnezdo: btw if you aren't using it yet I highly recommend inline-c
10:29:50 <chpatrick> it makes FFI type safe and way less of a pain in the ass
10:30:07 <blackgnezdo> glguy: I suspect ABI is not going to be an easy thing to ignore
10:30:14 <miladz1> spopejoy: I asked a question in stackoverflow and got this answer: "basically what's happened is you've gotten yourself into a place where the libraries you have installed have conflicting dependencies. Since there are conflicts, things break. These days everyone uses either cabal sandboxes or stack to mitigate this problem. Again, every language from python to C# to Haskell has this problem at some point, and all have introduced a
10:30:34 <glguy> blackgnezdo: It's defined what it means to pass a struct as an argument
10:31:02 <blackgnezdo> glguy: and FFI guarantees to be compatible?
10:31:14 <blackgnezdo> padding and all?
10:31:20 <glguy> yeah, its not badding
10:31:21 <spopejoy> miladz1: are you trying to install something and it isn't working? also if your SO question is relevant to your current issue, please provide the link
10:31:22 <glguy> padding
10:31:28 <glguy> It's not passing the actual struct
10:32:02 <tsahyt> jle`: when using flexible instances to define the readers it works so far, but I don't have the implementations yet so I'm not completely sure
10:32:14 <miladz1> spopejoy: no I am not trying to install anything. and here is the link : http://stackoverflow.com/questions/40385728/ghc-package-cannot-be-found#40385728
10:35:48 <jle`> tsahyt: it's weird that generalizednewtypederiving doesn't complain, if writing the instance directly is illegal
10:36:17 <tsahyt> I'm not sure it should always be illegal, at least not for closed type families
10:36:38 <tsahyt> with that I mean that it should be possible to derive them somehow, not that GHC supports it now
10:36:51 <miladz1> geekosaur: thank you for you time <3
10:38:37 <spopejoy> miladz1: (fyi geekosaur) let's talk on the direct channel
10:39:22 <miladz1> spopejoy: how can I do that? I am new to IRC
10:40:02 <spopejoy> Did you see my questions for you?
10:40:34 <spopejoy> try typing /msg spopejoy
10:41:43 <miladz1> spopejoy: I type it and it says "Insufficient arguments for command."
10:41:52 <spopejoy> haha
10:42:08 <blackgnezdo> glguy: could you explain "not passing an actual struct"? the value on the stack has to be padding/alignment compatible. or you meant something else?
10:42:31 <spopejoy> miladz1: ok forget it :). can you put your .hs code in a pastebin? http://lpaste.net/new/haskell
10:42:50 <spopejoy> paste link here when done
10:43:05 <miladz1> spopejoy: sure
10:43:41 <miladz1> spopejoy: http://lpaste.net/325163
10:43:47 <icosane> miladz1: /msg spopejoy the message you want to send to spopejoy
10:44:59 <spopejoy> miladz1: where is `Buffer` defined? is that in another .hs in the same directory?
10:45:09 <miladz1> icosane: thank you so much
10:46:00 <miladz1> spopejoy: yes It is another file. I will upload it too
10:46:31 <icosane> miladz1: you're welcome
10:47:24 <miladz1> spopejoy: here is the link to it http://lpaste.net/325168
10:48:41 <spopejoy> miladz1: if you run ghci in the same directory as Buffer.hs, and issue :load Buffer, does this work
10:48:56 <spopejoy> (assuming that last file is called Buffer.hs, it should be)
10:50:08 <miladz1> spopejoy: it works
10:50:13 <spopejoy> great
10:50:17 <icosane> Is name++ (karma points) actually used one this IRC channel? Haskell wiki says it is required, but I never have seen it although good answers are given
10:50:37 <amalloy> required! that is a strong wording indeed
10:50:57 <MarcelineVQ> lambdabot has @karma+ name, it's a little silly :>
10:51:15 <spopejoy> miladz1: now try `:load StringBuffer`
10:51:27 <PhsShft> Why is Either not in MonadPlus typeclass? 
10:51:38 <spopejoy> (again assuming your second file is called StringBuffer.hs, which it should)
10:51:49 <PhsShft> Is MonadPlus just (Alternative m, Monad m)?
10:51:50 <spopejoy> (and is in same directory)
10:52:00 <phadej> PhsShft: yes
10:52:24 <miladz1> spopejoy: it works too !
10:52:29 <spopejoy> great
10:53:00 <spopejoy> i think your problem is you're trying to use `runhaskell`, which wants a main method. When working on "library" code, just load stuff into ghci
10:53:39 <miladz1> spopejoy: I feel stupid, this is the file that doesn't work ! http://lpaste.net/325176
10:54:21 <bitemyapp> miladz1: most of the time when working on code, you're going to want to use ghci and :load like spopejoy suggested.
10:54:24 <miladz1> I use :load Editor.hs and GHCi complains
10:54:31 <MarcelineVQ> oh is this spring13? you need line 38 to be: deriving (Functor, Applicative, Monad, MonadIO, MonadState (b,Int))
10:54:52 <nitrix> miladz1: What does it complains on? Buffer missing?
10:54:55 <bitemyapp> miladz1: knowing it complains doesn't give us a lot to go on, you'll want to paste the errors you get and share the link.
10:55:02 <PhsShft> So why is Either not a MonadPlus then
10:55:17 <spopejoy> miladz1: are you getting this error: `No instance for (Applicative (Editor b))`
10:55:39 <spopejoy> when you :load Editor
10:55:42 <miladz1> spopejoy: exactly
10:55:50 <MarcelineVQ> bitemyapp: The Applicative requirment for Monad has caught up to the spring13 course, this has come up a fair bit recently
10:55:58 <spopejoy> ok, simply add `Applicative` to your deriving list
10:56:16 <spopejoy> you're already deriving Functor and Monad
10:56:29 <spopejoy> well, trying to derive Monad, which can't, because you need an Applicative instance
10:56:59 <miladz1> ok, where should I add it ?
10:58:03 <miladz1> bytemyapp: I am following the learing path you have specified in your github page, thank you for that
10:58:15 <spopejoy> So, the idea here is your "deriving" functionality for your `Editor` newtype. You're already deriving Functor, Monad, MonadIO etc. The order doesn't matter. (Making lame attempt to actually educate and not just literally answer your question :) )
10:58:31 <bitemyapp> MarcelineVQ: sigh, I thought this would happen eventually.
10:58:41 <bitemyapp> MarcelineVQ: discuss in -beginners?
10:59:27 <spopejoy> miladz1: does that make sense
11:00:05 <grazie> Hi, the code example from Real World Haskell uses a deprecated version of `catch` from System.IO.Error - do you know what I can replace it with? https://gist.github.com/23a80a3c3b925407e6dad5fe9813da52
11:00:16 <grazie> i.e. to make the code run
11:00:25 <miladz1> spopejoy: yes it does, thank you for your time and patience <3
11:00:38 <spopejoy> miladz1: so, working now?
11:01:31 <spopejoy> btw you can just say the module name in :load, ie `:load Editor` instead of `:load Editor.hs`
11:01:44 <miladz1> spopejoy: let me see and I will tag you 
11:03:48 <miladz1> spopejoy: thank you so much, it works. I waisted a several hours on this !
11:03:55 <joe9> when using Tasty.HUnit, is there any way to hide the step description if the step is successful?
11:04:22 <spopejoy> miladz1: great. yeah programming is like that sometimes! not just haskell. I'm fighting with javascript this week
11:05:05 <ronbrz> Hey, I'm working through the NICTA course, and am a bit confused about the 'State' type. Specifically the type declaration.  Its defined as `newtype State s a = State { runState :: s -> (a,s) }`. So a state is just a function? It's not some sort of struct with that you can initialize?
11:06:12 <grazie> I replaced `catch` with `catchIOError` in my code to get it to work
11:06:19 <miladz1> spopejoy: well haskell is indeed a different beast :)
11:08:11 <sbrg> ronbrz: It is just a function, yes. It is a function which takes the current state, and returns a new state and some return value. 
11:09:16 <ronbrz> so any function with type `s -> (a, s)` is a state type?
11:10:31 <sbrg> Well, if you are ever writing some Haskell code, and you decide "okay, I need to pass some state along" .. and then you realize "and I need to return the updated state and perhaps pass it along to another function that will update it further".. and then you realize "but I also need to be able to return a value along with the new state".. then you will basically have a function of the type `s -> (a, s)` which is equivalent to the State
11:10:31 <sbrg> monad. 
11:10:41 <amalloy> ronbrz: a newtype isn't just a type alias, it is a wrapper you have to explicitly apply and un-apply. so you can't just treat any function with that type as State; you have to wrap it up in the State constructor
11:11:35 <acowley> "State s a" is a type formed with the "State" type constructor whose definition you just showed. Informally, we refer to "s -> (a, s)" as "state" only to emphasize that everything we know about how to use State applies to this function, and perhaps we should use State to gain access to library code written for it.
11:11:50 <spopejoy> ronbrz: i might recommend my article on Reader, which takes you through newtyping something that looks like Reader (e ->) all the way through building a Monad out of it: http://slpopejoy.github.io/posts/Effectful02.html
11:12:09 <spopejoy> which necessarily means putting it in a datatype, as amalloy says
11:12:31 <jle`> ronbrz: you can think of 'State s a' as an abstract data type that represents a stateful action that modifies an 's' and produces an 'a' as a result
11:12:45 <jle`> at the low-level, it is implemented with an (s -> (a, s)) function
11:12:56 <jle`> but there are many other implementaitons possible
11:13:10 <jle`> from an API perspective, you only need to use the public API that 'State' exposes
11:13:19 <joe9> grazie:  check out safe-exceptions
11:13:21 <jle`> you don't have to worry about its internal implementation
11:13:29 <jle`> unless, of course, you are trying to implement State :p
11:13:42 <joe9> grazie: i think it is good to learn about them while you are on the topic
11:14:01 <grazie> thank you joe9
11:14:06 <spopejoy> what's the big advantage of safe-exceptions over something like `exceptions`? 
11:14:18 <spopejoy> MonadCatch etc
11:15:27 <dolio> It has "safe" in the name.
11:15:29 <spopejoy> oh, safe-exceptions depends on exceptions
11:15:50 <spopejoy> safe-exceptions seems a little bit verbose, why not just exceptions
11:15:52 <monochrom> the opening documentation of safe-exceptions says what's safe about it
11:16:10 <monochrom> or links to a page that says it. I forgot which.
11:17:16 <spopejoy> Yeah ... i guess if you're exception-happy you should use this, but as a weary Java veteran I hate overuse of exceptions ... seems like safe-exceptions is for when you're dealing with weird "throw exceptions across threads" situations
11:17:37 <spopejoy> i just use MonadThrow/MonadCatch
11:18:21 <monochrom> I think Haskell people use exceptions correctly not overusely.
11:18:30 <spopejoy> Haha. Not necessarily.
11:18:46 <spopejoy> Errors in general have had their share of controversy.
11:20:20 <spopejoy> `safe-exceptions` seems to be for managing a complex multithreaded frameworky app, where you'd want to catch async exceptions, kill threads etc. otherwise, in a safe lang like haskell, exceptions should be ... exceptional. Catching is basically about logging and giving up.
11:20:47 <spopejoy> s/giving up/reporting the error and giving up on whatever you were doing just then
11:21:00 <geekosaur> ...and then you find Prelude.head
11:21:09 <spopejoy> you shouldn't catch that
11:21:16 <spopejoy> you should write safe code
11:21:29 <spopejoy> one should, not you
11:21:57 <spopejoy> excellent example of where an error should not be caught. unsafe head should be seen as a bug
11:22:04 <monochrom> yes, we use a lot more Either's than exceptions.
11:22:49 <spopejoy> The only reason I've used exceptions recently is they are faster than MonadExcept in a stack (that uses IO). 
11:23:30 <spopejoy> which btw kind of saddens me. I liked using ExceptT/Either but there's some way that it futzes with inlining in a monad stack
11:24:14 <spopejoy> but then again, this is for extremely perf-critical code. in normal app code, ExceptT/Either rocks
11:25:16 <ronbrz> amalloy: ok, this is starting to make more sense. I'm still a bit confused about how newtype is a wrapper. So to create a "State" type, I would need a function "f" of type "s -> (s, a)", and initialize it with "State f"? and on that struct I can run runState?
11:26:11 <amalloy> yes, although normally you wouldn't just wrap it with State and then immediately unwrap it by calling runState
11:26:42 <sbrg> `runState` gives you the stateful computation that's "inside" the `State` newtype wrapper, so that you can apply it to your state.
11:26:51 <amalloy> usually you'd create a simple State function, then compose it together with a bunch of other State functions using the relevant combinators, and then run the combined function
11:26:53 <sbrg> (apply it to your state = run the stateful computation, so to speak)
11:28:23 <amalloy> runState is the "inverse" of State, so calling one right after the other gets you nothing
11:29:24 <ronbrz> ok, that makes sense. Thanks!
11:31:13 <agocorona> Concerning exception handling a computation can register handlers and continuations in the state so when an exception happens, the stack of handlers can be invoked to close resources or fix the problem and retry
11:32:59 <ph88> hey guys, in a do-block i have   command   command    below each other .. but then if i want to execute a command several times ghc complains  the monad returns [()] instead of ()    i use    mapM (\x -> spread stats1 (show x) ) $ divisors signal_count
11:33:24 <geekosaur> did you want mapM_ ?
11:34:06 <ph88> ah yes
11:34:09 <ph88> i think so
11:35:14 <ph88> when i do  :!   in ghci it used /bin/sh  how can i use my own shell ? (zsh)
11:36:27 <sbrg> ph88: :!echo $SHELL
11:36:33 <sbrg> for me, using zsh, it is zsh.
11:36:39 <kirillow> Whats a good introduction to category theory in the context of learing haskell? (I had some math courses at university but am not particularly fit anymore)
11:37:04 <geekosaur> sbrg, that isn't checking what shell is running, it's checking what you requested to be your interactive shell
11:37:09 <icosane> sbrg: :!echo $0
11:37:12 <geekosaur> try :!echo $ZSH_VERSION
11:37:23 <sbrg> geekosaur: aah.
11:37:48 <sbrg> very well, not zsh then.
11:37:52 <geekosaur> (in fact $SHELL is what ghci should check to see what shell to launch... except I think it uses /bin/sh always so that :def-s that use :! and capture output work regardless of interactive shell)
11:38:03 <sbrg> bash for me.
11:38:08 <geekosaur> really ghci needs to differentiate those cases
11:38:20 <sbrg> well, /bin/sh which is symlinked to bash
11:38:25 <geekosaur> on most linuxes /bin/sh is bash. (some debian-derived systems will use dash instead)
11:38:33 <Cale> kirillow: If your goal is more just to learn Haskell, category theory is very optional (more of a distraction than anything), but given that you're interested in mathematics in a more general way, I would say try Steve Awodey's book "Category Theory"
11:38:41 <verement> you could probably write your own definition that runs :! zsh -c '…' or something
11:38:53 <Cale> https://www.mpi-sws.org/~dreyer/courses/catlogic/awodey.pdf
11:39:14 <sbrg> kirillow: There was also a video posted on the haskell reddit, recently, which may be of interest. https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
11:39:24 <sbrg> Category Theory for Programmers. I haven't watched it, though.
11:40:04 <icosane> if you just want to use a shell temporarily, you can also do :!  bash (or zsh), do the command, then exit from the shell  with control-d
11:41:10 <sbrg> or just ^Z to suspend
11:41:14 <ph88> sbrg, for me it's also eching zsh .. but when i type  !: ll    i get   /bin/sh: 1: ll: not found
11:41:30 <sbrg> ph88: see discussion above
11:41:57 <ph88> :!echo $0   is /bin/sh
11:42:09 <ph88> :!echo $ZSH_VERSION    is empty
11:42:30 <geekosaur> yes
11:42:49 <ph88> so i can set zsh somehow ?
11:43:00 <geekosaur> not directly
11:43:04 <verement> ph88: :! zsh -c 'echo $ZSH_VERSION'
11:43:08 <geekosaur> [02 18:37:30] <geekosaur> (in fact $SHELL is what ghci should check to see what shell to launch... except I think it uses /bin/sh always so that :def-s that use :! and capture output work regardless of interactive shell)
11:43:12 <kirillow> thanks!
11:43:41 <ph88> maybe i can make a new  def  for    :! zsh -c 'command'   ?
11:44:02 <verement> yes
11:45:09 <Cale> kirillow: Awodey also gave a sort of crash course on it, which is available on YouTube here -- it might be a little bit fast to absorb everything the first time around, but I suspect it's good for getting a broad overview of the kinds of things CT deals with  https://www.youtube.com/watch?v=BF6kHD1DAeU
11:46:19 <reygoch> does anyone know how to select row with groundhog by using int as primary key?
11:46:58 <verement> ph88: http://lpaste.net/325287
11:46:59 <geekosaur> Prelude> :def x \str -> return $ ":! ${SHELL-/bin/sh} -c '" ++ concat (map (\c -> if c == '\'' then "\\'" else c:[]) str) ++ "'"
11:46:59 <geekosaur> Prelude> :x echo $ZSH_VERSION
11:46:59 <geekosaur> 5.0.2
11:47:03 <reygoch> I can't figure out how to convert int to proper groundhog key type
11:47:27 <geekosaur> quick hack, may not quite be right re quoting
11:48:12 <ph88> thx verement 
11:48:29 <Cale> reygoch: Perhaps fromIntegral?
11:49:10 <Cale> (depending on what the primary key type is...)
11:49:18 <reygoch> does anyone have some experience with groundhog?
11:49:42 <Cale> I do
11:49:44 <reygoch> cale: it is integer in the database
11:49:56 <ph88> verement, hhmm it's not picking up on my .zshrc ^^
11:50:07 <bitemyapp> reygoch: it just reuses Persistent's keys does it not?
11:50:43 <reygoch> bitemyapp: I have to convert int to a key in this case
11:50:44 <bitemyapp> reygoch: I'd recommend just using Persistent (more widely used). There's a function in Persistent for creating keys from raw values called toSqlKey
11:51:00 <geekosaur> ok, both of those are not quite right it seems
11:51:05 <reygoch> bitemyapp: I'm working on existing project
11:51:05 <Cale> Groundhog is just a fork of persistent, they're very similar.
11:51:11 <bitemyapp> reygoch: https://hackage.haskell.org/package/persistent-2.6/docs/Database-Persist-Sql.html#v:toSqlKey
11:51:24 <verement> ph88: .zshrc is only read for interactive shells
11:51:33 <reygoch> I want to do something like this : update [UserAgentCustomTitleField =. Just agentCustomTitle, UserAgentCustomSegment1Field =. Just agentCustomSegment] $ AutoKeyField ==. 1
11:51:57 <verement> ph88: try adding -i
11:52:36 <Cale> reygoch: Try fromInteger
11:54:04 <bitemyapp> No instance for (Num (Key Person))
11:54:05 <lpaste> reygoch pasted “Groundhog errors” at http://lpaste.net/325303
11:54:07 <bitemyapp> you need toSqlKey
11:54:19 <Cale> Oh, right, okay
11:54:23 <bitemyapp> so, like I was saying
11:54:25 <bitemyapp> use toSqlKey
11:54:47 <ph88> verement, that puts ghci in suspend o_O
11:54:58 <reygoch> hm... don't have that function for some reason
11:55:10 <verement> yeah, it doesn't behave nicely
11:55:41 <bitemyapp> reygoch: you may need to import it.
11:55:55 <reygoch> bitemyapp: I don't see it in groundhog library
11:55:59 <bitemyapp> reygoch: http://hackage.haskell.org/package/groundhog-0.7.0.3/docs/src/Database-Groundhog-Core.html your key types are from this class.
11:56:20 <bitemyapp> reygoch: I was pointing out the Persistent equivalent, which Groundhog is forked from.
11:56:30 <geekosaur> ph88, verement: make sure that becomes zsh -i -c
11:56:33 <reygoch> yes, but problem is I can't find it :D
11:56:35 <bitemyapp> reygoch: now you know where your key type comes from, we know the equivalent in Persistent, just need to track it down now.
11:56:40 <bitemyapp> reygoch: yes but context helps, yeah?
11:56:46 <geekosaur> zsh is not clever about options, zsh -c -i will try to run -i as a command
11:56:46 <reygoch> I guess :D
11:57:17 <Cale> I also have the problem that while we use groundhog regularly, we also have all this other stuff built up around it
11:57:20 <Cale> heh
11:57:52 <ph88> geekosaur, i had -i -c
11:58:03 <ph88> i have this piece of code that works https://paste.fedoraproject.org/468413/78112937/ but now if i put  (runAlgo (algo3 x))  instead of  stats1  on line 13  it's saying No instance for (MonadRandom C.Identity)  what's going on here ?
11:58:13 <Cale> ah
11:58:44 <geekosaur> my version isn't suspending, but shell quoting is hard --- I can convince zsh to throw an error fairly easily with something that works at the zsh prompt
11:58:47 <bitemyapp> reygoch: https://github.com/lykahb/groundhog/issues/46#issuecomment-149704803
11:58:52 <Cale> Try toSinglePersistValue
11:58:53 <bitemyapp> reygoch: this should be your winner, that's the author.
11:58:59 <bitemyapp> unless it's out of date
11:59:11 <Cale> haha, good, similar answer :)
11:59:32 <bitemyapp> reygoch: with Haskell libraries, I recommend googling for what you want to do, then prioritizing any results that are Github issues/PRs from that project.
11:59:51 <bitemyapp> reygoch: Haskell doesn't have the blog-diaspora of How-Tos that other langs have, have to dig a bit deeper.
11:59:51 <reygoch> yes, that's what I'm doing at the moment :D
11:59:54 <Cale> We use an abstraction around the keys in our codebase, with a datatype Id a that has appropriate instances implemented for it
11:59:56 <bitemyapp> reygoch: you see my link?
12:00:03 <bitemyapp> Cale: thus Num?
12:00:10 <reygoch> yes, checking it out right now
12:00:24 <bitemyapp> reygoch: cool, try convert, then toSinglePersistValue like Cale suggested.
12:00:26 <Cale> Well, moreso PersistField and such
12:01:02 <Cale> (and while we don't have a Num instance for Id, there are things to convert that to the underlying numeric value)
12:01:44 <Cale> But yeah, toPersistValues / toSinglePersistValue will do the conversion of a number to the appropriate Key type, I believe.
12:02:56 <Longor> Hi! Question: Are there other kinds of types apart from Sum and Product types?
12:03:36 <reygoch> thanks Cale, bitemyapp
12:03:51 <reygoch> I did something like UserAgentKey (PersistInt64 $ fromIntegral agentID)
12:03:53 <Cale> Longor: Function types are neither of those
12:03:56 <reygoch> that worked
12:04:37 <Cale> reygoch: ah, okay
12:07:14 <lyxia> Longor: IO?
12:07:39 <Longor> Hum... okay.
12:08:02 <grantwu> I mean IO is kind of special right
12:08:24 <jle`> well, IO is an abstract data type
12:08:57 <jle`> and i think ADT's in general wouldn't really count as being "either sum and product types"
12:09:10 <jle`> ADT as in abstract data type, not as in algebraic data type, heh
12:09:44 <jle`> so 'Map'/'Set', for example, wouldn't even count
12:12:11 <Longor> I've read a tutorial that said: Sum = OR, Product = AND; and was wondering if there are other kinds of... type operators(?)?
12:12:26 <Longor> This tutorial: https://medium.com/@willkurt/why-sum-types-matter-in-haskell-ba2c1ab4e372#.mqdxhrav4
12:13:53 * hackagebot tagged-identity 0.1.0 - Trivial monad transformer that allows identical monad stacks have different types  https://hackage.haskell.org/package/tagged-identity-0.1.0 (mrkkrp)
12:14:15 <monochrom> yes, there is recursion
12:15:25 <Longor> Heh. Seems obvious.
12:15:56 <monochrom> Ah, recursion was not so obvious before Algol 60.
12:16:52 <Longor> I wasn't alive back then.
12:16:55 <Cale> Data recursion fails to be obvious to the extent that even supposedly modern languages still often fail to include it
12:17:58 <monochrom> (The following is about control-flow recursion not data recursion. But control-flow recursion is even easier.) When Peter Naur went to a conference to report that he had finished implementing and testing Algol 60, there were still people in the audience who asked/objected "but it is impossible!". Even after Naur had demoed it already.
12:18:20 <Cale> But yeah, continuing the algebraic analogy, function types A -> B are also sometimes called "exponentials", since A -> B behaves algebraically like B^A in a lot of ways.
12:19:36 <Cale> (C^B)^A is isomorphic to C^(A x B) (by currying/uncurrying)
12:19:41 <monochrom> Here is the reason why people thought recursive calls were impossible. They were still using the old trick of "for each procedure, statically reserve one call frame, because there is at most one caller at every moment, right?"
12:20:20 <monochrom> Naur thought up "use a growable call stack" and it was obvious in retrospect. But clearly everyone else didn't think of it.
12:20:31 <Longor> That sounds weird but okay.
12:21:11 <Cale> i.e. A -> (B -> C) is the same as (A, B) -> C, in Haskell syntax.
12:21:13 <ph88> Cale, which language don't include data recursion ?
12:22:31 <monochrom> You know the power of self-fulfilling prophecy, right? If you are too lazy to support recursion, you will just think up "statically reserve one call frame per procedure". And after you think that up, you will never think up anything that exceeds it and supports recursion.
12:22:53 <grantwu> C does not support data recursion
12:23:05 <ph88> no??
12:23:10 <grantwu> You must statically know the size of every struct when it is defined
12:23:20 <icosane> grantwu: but you can *dynamically* allocate memory
12:23:22 <grantwu> You can have pointers to your own struct though
12:23:32 <grantwu> Or, pointers to structs of the same type
12:23:36 <monochrom> I wouldn't say C doesn't. I may agree "it's weaker", but if you can settle with pointers, you still get a lot of data recursion.
12:23:42 <grantwu> Yeah
12:23:46 <ph88> yeah
12:25:40 <sbrg> there was a really good talk on the intuition between "product" and "sum" in product and sum types. I wish I remembered who did it or what it was called. They explained using some pretty good examples. 
12:26:03 <grantwu> Perhaps the number of inhabitants?
12:26:07 <ph88> well how hard can it be ?
12:26:19 <sbrg> grantwu: is that a name of a talk?
12:26:25 <grantwu> sbrg: No
12:26:28 <grantwu> I just mean like
12:26:33 <sbrg> grantwu: but yes, I know, it is the number of inhabitants
12:26:34 <monochrom> actually I don't think C's weaker. In GHC, data recursion is permitted for boxed types only. And "boxed types" mean pointers to struct. This is in equivalence with C's.
12:26:36 <isovector> using TypeInType, are there any term-level inhabitants of type-level *?
12:26:39 <grantwu> ah, ok
12:26:57 <sbrg> but I meant that it is a nice talk to watch if you haven't quite gotten how that works
12:27:31 <Cale> monochrom: Only if you break out of the abstraction though...
12:27:54 <monochrom> What you can claim is that C forces you to spell out the "pointer" part so you have to work with it at a lower level than you like.
12:28:54 <ph88> so i have this line     all_stats <- mapM (\x -> runAlgo (algo3 x)) $ divisors signal_count     but now i also would like to return x itself, i tried a tuple   but then ghc says it can't match with type IO
12:29:01 <monochrom> OTOH as soon as you need to predict space usage, you cannot avoid it. Even for Haskell.
12:29:19 <Cale> ph88: which x?
12:29:40 <Cale> ph88: You mean along with each of the results of runAlgo?
12:29:49 <monochrom> (All you can do is change terminology to pretend you're higher level, i.e., change "pointer" to "edge in a graph of nodes")
12:30:20 <Cale> mapM (\x -> do r <- runAlgo (algo3 x); return (x,r)) (divisors signal_count)
12:30:20 <ph88> Cale, yes
12:30:35 <Cale> This is starting to look better as a forM
12:30:55 <Cale> forM (divisors signal_count) $ \x -> do r <- runAlgo (algo3 x); return (x,r)
12:30:58 <monochrom> I mean, the way you explain why "let x = 0:x" takes O(1) space is by drawing a node that has a directed edge back to itself. There is your pointer.
12:31:18 <ph88> ah i get it now, that do-block puts runAlgo in it's own context
12:31:29 <Cale> I don't know what context means
12:31:33 <Cale> But okay
12:31:36 <ph88> :P
12:32:18 <Cale> The do-block builds an action which not only executes runAlgo (algo3 x), but also returns the pair of x with the result of that
12:32:30 <ph88> yes but in another monad i think
12:32:40 <Cale> No, it's all the same monad
12:33:16 <Longor> What kind of discussion did I kick off here?
12:34:56 <Cale> :t forM
12:34:58 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
12:35:04 <Cale> ^^ only one Monad m
12:35:18 <Cale> It's got to be the same monad as the action you're producing
12:35:35 <Cale> and all the actions in a do-block have to be actions of the same monad too
12:36:30 <Cale> (and the do-block as a whole will be an action of that same monad)
12:45:55 <monochrom> I have decided that "context" means Monad, "container" means Traversable.
12:46:21 <monochrom> And I am not sure whether "computation" should mean Monad, Arrow, or Applicative.
12:48:44 <Cale> Comonad would be a better bet for "context"
12:48:53 <Cale> If people actually used those :)
12:48:55 <Cale> haha
12:49:11 <monochrom> ah good
12:53:05 <Hijiri> I'm getting linker errors complaining about not being able to do relocations or something whenever I try to build things with ghc, this didn't happen before
12:53:19 <Hijiri> I'm on Debian andrecently did an apt-get dist-upgrade, could that have broken anything?
12:53:24 <Clint> Hijiri: yes
12:53:27 <geekosaur> Hijiri, yes, you took the gcc6 update and no-pie broke it
12:53:31 <Hijiri> rip
12:53:42 <Tuplanolla> No pie?
12:53:57 <Clint> Hijiri: if you use the ghc in unstable it should be happier
12:54:00 <jay72> position independent executable 
12:54:03 <geekosaur> actually backwards. pie (position independent executable) broke it, -no-pie added to the config unbreaks
12:54:15 <byorgey> monochrom: I would pick "computation" for Monad and "context" for Applicative =)
12:54:33 * geekosaur trying to remember the quick hack fix...
12:54:42 <Hijiri> Clint: but I won't be able to use ghcs that stack gets?
12:54:52 <Clint> Hijiri: not without passing whatever the equivalent of cabal flags are
12:54:58 <sebastianrkg> hey folks, has anyone else had the ToJson "genericToEncoding" create invalid JSON data? (At least according to JSON.parse in Chrome)
12:55:38 <sebastianrkg> namely, when using omitNothingFields as an aeson setting, I get JSON of the from {"someData": true,,,,,,,,,,,,,}
12:55:42 <byorgey> Tuplanolla: -no-pie for you
12:55:47 <Clint> Hijiri: -fno-PIE to the C compiler and -no-pie to the linker
12:56:14 <Hijiri> alright, thanks
12:56:19 <Tuplanolla> I'm glad it's not pic as usual.
12:56:22 <monochrom> oh what fun, so when I upgrade ubuntu to 16.10 I will run into this too
12:56:22 <Hijiri> I will try to figure out where to configure those
12:56:37 <Clint> Hijiri: and for ghc8 you apparently need to patch Cabal or hsc2hs will break
12:56:37 <sebastianrkg> I'm not sure if maybe aeson is playing off of an alternate definition of valid JSON or something, but that seems really unhelpful
12:58:23 <lwm> can someone give me a one liner to show `catch` working from `Control.Monad.Exception`?
12:58:41 <byorgey> sebastianrkg: what version of aeson are you using?
12:58:49 <hvr> monochrom: or use my ppa
12:59:35 <hvr> monochrom: I'm dogfooding my ppa on Ubuntu 16.10 and it works just fine w/ cabal
12:59:45 <byorgey> sebastianrkg: looks like https://github.com/bos/aeson/issues/454 maybe?
12:59:56 <sebastianrkg> byorgey: I'm using the lts-7.5 resolver in stack, let me check what that points to for aeson
13:00:00 <geekosaur> Hijiri, find the settings file in the ghc lib dir
13:00:32 <byorgey> sebastianrkg: yes, it's 0.11.2.1.  Looks like that bug has been fixed in aeson 1.0.x
13:00:40 <hvr> Hijiri: are you on sid or testing btw?
13:00:43 * geekosaur just noticed that still has a reference to perl. how long has the evil mangler been dead now?
13:00:43 <Hijiri> testing
13:00:55 <Cale> lwm: Sure... I mean wait, what? Control.Monad.Exception?
13:01:05 <hvr> Guess I should start building .debs for Debian 9 sooner than I planned to
13:01:08 <monochrom> geekosaur: consider it a tombstone :)
13:01:26 <Cale> lwm: I suppose that exists on hackage, are you using the control-monad-exception package?
13:01:34 <sebastianrkg> byorgey: thanks, that clears things up. I'll look for a more up-to-date resolver that will work
13:01:50 <lwm> Cale: Woops! I meant .Catch ;)
13:01:57 <Hijiri> geekosaur: thanks, found it
13:02:02 <byorgey> sebastianrkg: you'll have to use nightly
13:02:18 <byorgey> 7.7 is the latest resolver release and it still has aeson 0.11
13:02:25 <byorgey> but nightly has 1.0
13:02:57 <Cale> lwm: There's Control.Exception which defines a 'catch' -- is that what you mean?
13:03:32 <monochrom> thanks geekosaur. yeah, the settings file is obvious in retrospect
13:03:35 <joe9> just want to check if there is a library package that can build an absolute path from a Data.Tree data structure: input http://codepad.org/6G1VCc1o output: http://codepad.org/jj5KtPVV
13:03:37 <lwm> Cale: Sorry meant, Control.Monad.Catch
13:04:04 <monochrom> actually I should test it before I thank you :)
13:04:13 <Cale> lwm: Which package is that one from?
13:05:02 <geekosaur> someone lpaste-d a version of that file that works with recent testing yesterday, but I can't find it now (and urgh, the spam on lpaste...)
13:05:23 <Darwin226> Hey guys. Anyone know of a non-dead physics engine (binding)?
13:05:25 <lwm> Cale: https://hackage.haskell.org/package/exceptions
13:05:38 <Cale> ahh, okay
13:05:59 <Hijiri> geekosaur: I'm still getting errors, I just add the flags Clint mentioned to the "ld flags" and "C compiler flags" entries in the settings file, right?
13:06:01 <Cale> So yeah, this one is designed to work similarly to IO
13:06:09 <Hijiri> and I can use it with a normal ghc?
13:06:14 <lwm> Thought it was in base, silly me
13:06:39 <geekosaur> Hijiri, I think also C compiler link flags
13:06:46 <geekosaur> and you should not have to patch ghc or anything
13:07:06 <Hijiri> geekosaur: ah, it works now
13:07:07 <Hijiri> thanks
13:08:16 <geekosaur> (in general ld would be run directly to make shared objects, you want to go through the C compiler to link programs because the C compiler knows what preambles/postambles/etc. need to be added for libc to work)
13:08:47 <Cale> Prelude Control.Monad.Catch Control.Exception> Control.Monad.Catch.catch (throwM (AssertionFailed "hey")) (\e -> putStrLn "Caught!" >> print (e :: AssertionFailed))
13:08:47 <Cale> Caught!
13:08:48 <Cale> hey
13:09:49 <Cale> (Of course, if I'd been more careful about how I imported the modules, I wouldn't have to qualify which catch I meant)
13:10:16 <lwm> haha, awesome. Thanks, that makes sense
13:10:34 <Cale> lwm: Note that it uses the type of the exception you're trying to catch to determine if exceptions actually get caught
13:10:41 <Cale> :t fromException
13:10:43 <lambdabot> Exception e => SomeException -> Maybe e
13:11:16 <Cale> So sometimes you'll need to specify which, or if you want to catch absolutely anything, you can use SomeException
13:12:44 <Cale> By defining new Exception instances with non-default implementations of fromException, you can effectively create new "super" and "sub" types of existing exceptions.
13:14:10 <lwm> oof, good to know!!!
13:15:22 <sebastianrkg> byorgey: That fixed things. Running with nightly-2016-11-02 now
13:18:35 <Cale> lwm: http://lpaste.net/147654
13:18:55 * hackagebot hmatrix 0.18.0.0 - Numeric Linear Algebra  https://hackage.haskell.org/package/hmatrix-0.18.0.0 (AlbertoRuiz)
13:22:16 <fsestini> hi guys. i was taking a look at generalized folds for nested datatypes. even though they can be shown to be more powerful that regular folds, it seems to me that there are still functions that cannot be defined in terms of them. for example, I wasn’t able to define an instance of fmap for de bruijn lambda terms represented as a nested datatype. is my intuition actually true or it is just that I didn’t try hard enough? do you know i
13:22:16 <fsestini> there exist even more powerful notions of folds for these types?
13:23:55 * hackagebot hmatrix-gsl 0.18.0.1 - Numerical computation  https://hackage.haskell.org/package/hmatrix-gsl-0.18.0.1 (AlbertoRuiz)
13:23:57 * hackagebot hmatrix-special 0.4.0.1 - Interface to GSL special functions  https://hackage.haskell.org/package/hmatrix-special-0.4.0.1 (AlbertoRuiz)
13:23:59 * hackagebot hmatrix-glpk 0.6.0.0 - Linear Programming based on GLPK  https://hackage.haskell.org/package/hmatrix-glpk-0.6.0.0 (AlbertoRuiz)
13:24:01 * hackagebot hmatrix-tests 0.6.0.0 - Tests for hmatrix  https://hackage.haskell.org/package/hmatrix-tests-0.6.0.0 (AlbertoRuiz)
13:25:39 <xa0> if __name__ == "__main__":
13:25:50 <xa0> __name__: __main__:
13:26:09 <xa0> aw
13:26:12 <owlscientist> This is why we can't have nice things.
13:26:50 <Hijiri> Clint: I'm getting a linker error on a hsc file, but I'm using GHC 7.10.3, not 8 Should the same error be present here?
13:26:52 <sbrg> ^ that is why pythonistas can't have nice things
13:26:55 <sbrg> we have plenty of nice things.
13:27:10 <sbrg> in fact, we have the best things.
13:28:29 <Hijiri> specifically I am failing on zlib
13:30:04 <Clint> Hijiri: is it relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC or something else?
13:30:06 <geekosaur> Hijiri, no version of ghc knows how to create object files for PIE
13:30:24 <joe9> I am trying to figure out how to use teh foldTree of Data.Tree https://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Tree.html#foldTree any examples, please?
13:30:46 <Clint> geekosaur: it knows how to do PIC though
13:31:02 <geekosaur> yes, it just assumes that executables are not PIC
13:31:20 <geekosaur> so in theory it could generate the extra information in a position independent fashion, it just doesn't yet
13:31:26 <Hijiri> Clint: it's that, yeah
13:32:52 <Clint> Hijiri: what version of Cabal?
13:33:24 <Hijiri> 1.24
13:33:26 <Clint> Hijiri: oh, yeah, i guess Cabal is broken with 7.10.3 too
13:33:49 <Clint> Hijiri: you need https://git.haskell.org/packages/Cabal.git/commitdiff/c30b179a73d9fd3f6edcdda5e881523cd6edd46a
13:34:12 <Hijiri> Clint: ok, thanks again
13:34:36 <geekosaur> weeee
13:36:10 <Hijiri> I guess stack will have the same problem since it uses the cabal library
13:39:30 <joe9> I am trying to figure out how to build absolute paths when given a tree of relative names http://codepad.org/yq14MnyC
13:39:50 <joe9> I think I can use foldTree but cannot figure out how to pass on the parent name to the xs
13:40:45 <joe9> If I try this, it does not type match:  in Node (f,builtName) (fmap (absolutePath builtName) xs)
13:43:49 <joe9> http://codepad.org/3uNlHp2K type matches
13:44:16 <kirillow> Why is this https://gist.github.com/anonymous/1e09bec34457fffcf6d6383cb977bbc1 not working?
13:44:28 <mpickering> Is there a "non-empty ListT" in a package somewhere?
13:44:58 <Tuplanolla> You're confusing patterns and guards, kirillow.
13:45:00 <kadoban> kirillow: You're mixing up the syntax for pattern matching with the syntax for guards
13:45:00 <monochrom> kirillow: You have mixed up pattern-matching syntax and guard syntax.
13:45:17 <kirillow> m(
13:45:18 <kirillow> oh my
13:45:19 <monochrom> here is the right way to write the first equation: myZip [] _ = []
13:45:54 <monochrom> And the 3rd equation you're supposed to foresake head and tail, because pattern matching is superior.
13:47:09 <kirillow> in what way?
13:47:37 <kadoban> Pattern matching should generally be preferred if it's possible (and it is here).
13:47:42 <monochrom> see my http://www.vex.net/~trebla/haskell/crossroad.xhtml for why
13:48:52 <kirillow> thanks!
13:49:04 <monochrom> So in the long run you will have to foresake the habit from inferior languages of separating case-splitting from field-extracting.
13:53:47 <joe9> got it http://codepad.org/jn7cumtV
13:57:54 <monochrom> oh w00t 100th anniversary of Strachey
13:58:57 * hackagebot sbp 1.2.7 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.2.7 (markfine)
14:08:55 <chasm> I find this combinator useful: \f a -> f a >> return a ... hoogle doesn't turn anything up - does it exist? what would be a good name if not?
14:08:57 * hackagebot gnss-converters 0.1.18 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.18 (markfine)
14:10:05 <Hijiri> I just configured stack to use gcc 5 instead of 6
14:11:29 <Tuplanolla> chasm: https://hackage.haskell.org/package/IfElse-0.85/docs/Control-Monad-IfElse.html#v:returning
14:14:20 <jle`> chasm: i use x <$ f x or f x $> x
14:14:59 <jle`> > guard (even 10) $> 10
14:15:01 <lambdabot>  error:
14:15:01 <lambdabot>      • Variable not in scope: ($>) :: f0 () -> Integer -> t
14:15:01 <lambdabot>      • Perhaps you meant one of these:
14:15:04 <jle`> aw
14:15:07 <jle`> @let import Data.Functor
14:15:08 <lambdabot>  Defined.
14:15:12 <jle`> > guard (even 10) $> 10
14:15:14 <lambdabot>  error:
14:15:14 <lambdabot>      • Ambiguous type variables ‘f0’, ‘b0’ arising from a use of ‘show_M28055...
14:15:14 <lambdabot>        prevents the constraint ‘(Show (f0 b0))’ from being solved.
14:15:21 <jle`> > guard (even 10) $> 10 :: Maybe Int
14:15:24 <lambdabot>  Just 10
14:15:35 <jle`> > guard (even 9) $> 9 :: Maybe Int
14:15:38 <lambdabot>  Nothing
14:16:47 <geekosaur> hm, bridging back here from offtopic, it occurs to me that -fllvm might also work around the PIE issues since the relocation generation is offloaded to LLVM
14:18:07 <Clint> geekosaur: i think i tried that ages ago and stuff was still broken, but maybe that was the Cabal bug
14:20:56 <chasm> Tuplanolla: thanks, `returning` is exactly the combinator!
14:21:50 <chasm> is there a more comprehensive Hoogle somewhere? haskell.org/hoogle doesn't know about it
14:22:02 <Tuplanolla> You can install one locally.
14:22:09 <jle`> haskell.org/hoogle is a few years out of date
14:22:22 <jle`> hoogle.haskell.org is up to date, and there's also the stackage hoogle at stackage.org
14:22:24 <Koterpillar> hayoo.fh-wedel.de
14:22:24 <jle`> the stoogle
14:22:34 <geekosaur> hoogle.haskell.org is the newer one, also try fpcomplete.com/hoogle. but hoogle in general has issues with large databases; I use hayoo for most lookups instead (does all of hackage, doesnt require you to specify namespace)
14:23:05 <jle`> haskell.org/hoogle's updates have ben delayed pending the next major release of hoogle, but that's been delayed for a few years
14:23:09 <jle`> so it's a little awkward
14:23:13 <chasm> ty for the pointers! v useful
14:23:32 <jle`> s/have ben delayed/have been suspended
14:24:54 <Cale> I like how the new Hoogle has author search, so I can find all the stuff that great Haskellers such as ;5:A0=4@-&0 and @83>@89-%>;> have made.
14:25:52 <sbrg> definitely my favorite haskellers
14:30:51 <jle`> i like noogle too
14:34:19 <Welkin> halp
14:34:39 <Welkin> has anyone tried installing hakyll through nix on osx?
14:37:59 <joe9> I have a long string that I want to use as a key to use Data.HashMap.Strict. Unfortunately, there is a legacy application which requires a 64 bit value as key. Is there a way to convert the Data.HashMap.Strict key to a 64 bit unique value?
14:38:26 <hiptobecubic> Isn't that what hashing is?
14:38:32 <hiptobecubic> 64 bit hashing, anyway
14:38:58 * hackagebot hTensor 0.9.1 - Multidimensional arrays and simple tensor computations.  https://hackage.haskell.org/package/hTensor-0.9.1 (AlbertoRuiz)
14:39:45 <joe9> hiptobecubic: Is there a library that can help with that, please?
14:39:58 <hiptobecubic> hashing a value?
14:40:03 <geekosaur> you should be able to use the Hashable instance, same as Hashmap does
14:40:23 <joe9> hiptobecubic: but, with hashing, there is a potential for collisions, etc.
14:40:31 <joe9> geekosaur: good idea. will check it out. Thanks
14:40:57 <hiptobecubic> joe9, yes. There is no way to map arbitrary values into 64 bits with no risk of collisions.
14:41:14 <Cale> Though... once you're hashing stuff twice, it's really going to be questionable why you're not just using Data.Map
14:41:49 <neonfuz> what is the equivalent to "main.c" in haskell
14:41:55 <joe9> Main.hs?
14:41:57 <neonfuz> I hear a lot about "Setup.hs" or something
14:42:00 <lyxia> Just convert the hash with fromIntegral
14:42:01 <neonfuz> do people use Main.hs?
14:42:03 <hiptobecubic> "main.c" isn't a thing, is it?
14:42:20 <neonfuz> is it not? I see a lot of people using it (not universally though)
14:42:26 <Cale> neonfuz: Setup.hs is for custom installation code.
14:42:28 <kadoban> Setup.hs isn't really something you usually use. It's like an implementation detail that's usually just contains boilerplate.
14:42:36 <neonfuz> alright
14:42:44 <joe9> lyxia: fromIntegral could lose the high bits, correct?
14:42:46 <neonfuz> well what file do people usually have their main in in haskell, Main.hs?
14:42:48 <Cale> neonfuz: Usually it's just <desired executable name>.hs
14:42:54 <neonfuz> alright
14:42:59 <Cale> neonfuz: But Main.hs works
14:43:22 <Cale> also, you skip the module declaration in that file
14:43:31 <Cale> (typically)
14:43:50 <geekosaur> neonfuz, you can call it whatever you want, same as C (but executable name is common). as far as Haskell is concerned, it's what's inside that matters (module declaration omitted or "module Main"; export main :: IO a)
14:44:11 <neonfuz> alright
14:44:11 <kadoban> For single-shot short things I use WhateverName.hs and stack's script interpreter stuff in the top of the file. For real projects I use a cabal package setup with app/Main.hs as the main application, which usually doesn't have a lot in it except a call to the library code in src/*
14:44:19 <lyxia> joe9: no.
14:44:34 <joe9> Cale, Do you mean "hash the value of the string" and use this as the key for Data.Map?
14:44:50 <hiptobecubic> Seems like IntMap would make more sense, then
14:45:13 <lyxia> joe9: unless you are on an n-bit system with n>64?
14:46:03 <lyxia> not that losing bits would matter at that point...
14:48:16 <Cale> joe9: I was talking about this scheme of hashing the string to a 64 bit value and then using that as the key of a structure which is going to hash it again...
14:48:36 <Cale> joe9: vs. just not hashing and using something like Data.Map which is based on order comparisons
14:48:58 * hackagebot memcache 0.2.0.1 - A memcached client library.  https://hackage.haskell.org/package/memcache-0.2.0.1 (DavidTerei)
14:53:59 * hackagebot hakyll-series 0.1.0.1 - Adds series functionality to hakyll  https://hackage.haskell.org/package/hakyll-series-0.1.0.1 (oisdk)
14:55:35 <joe9> Cale, it makes sense to just use "Data.Map (string as key)" approach. What value (64 bit) should I give the legacy application?
14:56:38 <joe9> Cale, forget it. I get what you meant.
14:56:52 <joe9> Cale, just use the hashed value as the key with Data.Map
14:57:07 <joe9> instead of using IntMap or HashMap which would hash the hashvalue again.
15:00:42 <lyxia> IntMap uses hashing?
15:00:59 <yhhko> joe9: if you want to use a hash map, use HashMap?
15:02:36 <jmorris> how could i make the function find' search a list of tuples for their first element and return the entire tuple like this http://lpaste.net/325659
15:03:17 <joe9> yhhko: my issue is not with hashing, but, trying to provide a 64 bit value to a legacy app to refer back to the key.
15:03:23 <joe9> yhhko: does that make sense?
15:03:38 <monochrom> jmorris: use pattern matching and recursion
15:04:16 <yhhko> joe9: ah, so you want to know the explicit hash used by whatever container you ended up using
15:04:18 <monochrom> also, I think you have a major misconception.
15:04:21 <yhhko> joe9: (say)
15:04:28 <monochrom> No, two major misconception.
15:04:37 <joe9> yhhko: yes.
15:05:27 <monochrom> No, I simply no longer understand your notation.
15:06:02 <monochrom> I don't understand "find a -> ("a", "b", "c")" and I don't know what the line of [("a","b","c")("d","e","f")("g","h","i")("j","k","l")] is doing there.
15:06:20 <yhhko> joe9: then it'd probably be easiest to write some wrapper around IntMap that allows you to use Strings as keys, which uses their Hashable instance internally?
15:06:22 <l_zzie> > filter ((== 1) . fst) [(0, 1), (1, 2), (2, 3)] -- jmorris
15:06:25 <lambdabot>  [(1,2)]
15:06:54 <monochrom> The first issue is that your wording suggests that find' should have 2 parameters but your example "find a -> whatever" has only one.
15:06:55 <jmorris> l_zzie thanks
15:07:12 <monochrom> The second issue is that I don't know whether [("a","b","c")("d","e","f")("g","h","i")("j","k","l")] is intended to be parameter or answer.
15:07:35 <l_zzie> I think jmorris just forgot quotes around the first "a"
15:07:36 <jmorris> monochrom sorry, it should be a second parameter
15:07:47 <l_zzie> from context it's pretty clear it should be a parameter, and the first line indicates the expected result
15:07:55 <l_zzie> jmorris, does that sound right? ^
15:07:57 <monochrom> No, I am not even picking on quoting "a". I understand simple typos.
15:08:15 <jmorris> l_zzie is right
15:08:23 <sphinxo> How can I generally write performant  graphics code?
15:08:36 <sphinxo> lots of iorefs for vectors n things?
15:08:48 <l_zzie> sphinxo, write graphics code, and then make the slow things faster?
15:08:56 <l_zzie> do you have a specific bottleneck you're worried about?
15:09:30 <joe9> yhhko: any suggestions on how to deal with collisions?
15:09:42 <yhhko> joe9: the same way ordinary hash maps do?
15:10:04 <sphinxo> l_zzie: things that generally change very frequently I guess
15:10:25 <l_zzie> I wouldn't worry about that to start with
15:10:26 <joe9> yhhko: ok, Thanks. let me figure out how hash maps deal with collisions.
15:10:35 <MartianHaskeller> hashmaps considered harmful
15:10:45 <sphinxo> l_zzie: ok thanks
15:10:48 <jmorris> l_zzie does filter work with strings or just integers?
15:11:18 <joe9> yhhko: hashmaps have a collision constructor.
15:11:25 <l_zzie> :t filter -- jmorris
15:11:27 <lambdabot> (a -> Bool) -> [a] -> [a]
15:12:21 <laudiacay> i reallllly dont understand monadplus
15:12:33 <laudiacay> is there anything good written about it online anywhere
15:12:42 <yhhko> joe9: or you can just take a Data.Map and whenever your legacy app needs an int, you take the hash of the key
15:12:54 <MartianHaskeller> monadplus is an older version of alternative.
15:14:04 <jle`> laudiacay: i wrote a small tutorial series on using specific instances
15:14:13 <jle`> laudiacay: but really the typeclass itself isn't very complicated
15:14:34 <jle`> it's just that mplus has to be associative, and mzero is the identity
15:14:41 <MartianHaskeller> laudiacay:  don't use monadplus . use Alternative
15:14:55 <laudiacay> MartianHaskeller: unfortunately, i have to learn both for my cs class :(
15:15:17 <laudiacay> but i also dont understand alternative so well
15:15:30 <monochrom> you can change the question to "where are tutorials of Alternative?" and it will still be equally unanswered.
15:15:32 <MartianHaskeller> Alternative it is easier to understand
15:17:16 <MartianHaskeller> I'm empty <|>  x === x;        I have x <|> any  ===  x
15:17:56 <monochrom> "x <|> any === x" is not always true. It is false for lists.
15:18:15 <dmwit> :t any
15:18:17 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
15:18:18 <joe9> yhhko: that (hash of the key) would also be prone to collisions, correct?
15:18:31 <dmwit> :t many
15:18:33 <lambdabot> Alternative f => f a -> f [a]
15:18:59 * hackagebot mathexpr 0.1.0.0 - Parse and evaluate math expressions with variables and functions  https://hackage.haskell.org/package/mathexpr-0.1.0.0 (mdibaiee)
15:19:07 <dmwit> What is `x <|> any`?
15:19:15 <monochrom> :)
15:19:21 <yhhko> joe9: yeah but if your legacy app wants an int, you'll always have collissions
15:19:24 <MartianHaskeller> I mean any pseudocode for "anthing"
15:20:29 <dmwit> Is `empty <|> x === x` not a rule? In that case, `x <|> any === x` really restricts you a lot -- you can only have one value.
15:20:39 <joe9> yhhko: currently, I am using a vector and sending the vector index to the legacy app. but, the problem with this approach is to find by name, I am looping the vector.
15:20:58 <joe9> yhhko: maybe, something like an IxSet would make it easier to search?
15:21:19 <dmwit> (Namely: `empty` is that value, because `any === empty <|> any === empty`.)
15:21:31 <MartianHaskeller> laudiacay:      mzero in MonadPlus === empty in Alternative
15:21:46 <monochrom> I'm OK with "assume x is non-empty". However, lists are still a counterexample.
15:22:06 <MartianHaskeller> `mplus`  in MonadPlus ===  <|>  in Alternative.   that's all
15:22:13 <laudiacay> MartianHaskeller: what exactly is the point of these, like how are they useful
15:22:16 <laudiacay> i just dont get it :(
15:22:16 <jmorris> l_zzie: this is what I've got (http://lpaste.net/325699) the problem is that I want to be able to search a list of 2-tuples as well as 3-tuples but i get this error.
15:22:16 <jmorris> Couldn't match expected type ([Char], [Char]) with actual type ([Char], [Char], [Char])
15:22:40 <ertes> laudiacay: how is having two of them useful?  it isn't…  it's just a historical accident
15:22:45 <MartianHaskeller> laudiacay:   They are in order to compose alternative computations. If the first fails, the second is executed
15:22:46 <monochrom> No, you will not have one function that works for all tuples and nothing else.
15:22:48 <jmorris> l_zzie: thats with the parameters, find' "a" [("a","b"),("c","d","e")]
15:22:53 <dmwit> monochrom: Okay. But then this is just a specification of `First`, right?
15:23:05 <monochrom> Yes
15:23:11 <ertes> laudiacay: how is Alternative useful?  the same way Monoid is useful, but it's a bit stronger than Monoid, so it gives you some reasoning advantage
15:23:12 <laudiacay> oohhh that kinda makes sense. is there somewhere good for me to look at example usages?
15:23:13 <MartianHaskeller> 1 <|> 2 <|> 3 ..... you can compose as many as you can. It is useful for parsers for example
15:23:49 <ertes> > (Just 3 <|> Nothing, Nothing <|> Just 4)
15:23:51 <lambdabot>  (Just 3,Just 4)
15:24:01 <ertes> > Nothing <|> Nothing
15:24:03 <lambdabot>  Nothing
15:24:39 <laudiacay> hmmm that is very cool
15:24:53 <ertes> laudiacay: exercise: look at the Alternative laws and figure out what 'empty' is for Alternative Maybe
15:25:01 <laudiacay> so the composing element is sorta.... like.... "combine these things"??
15:25:22 <monochrom> I wouldn't use the broad word "combine" lightly.
15:25:41 <monochrom> <*> combines. <|> combines. >> combines. There are a million different "combine"s.
15:25:49 <laudiacay> ok that makes sense
15:25:53 <ertes> it's monoidcal composition, very similar to (<>) from Monoid: an associative binary function with an identity
15:26:03 <ertes> monoidal
15:26:16 <laudiacay> and the different things on the inside just mean like different combos of "boxed" and "unboxed" values?
15:26:55 <laudiacay> idk if im ever going to get down all the >>= <- <|> <$> <*> <> stuff
15:27:44 <monochrom> <$> is fmap. It's one of the easiest.
15:27:46 <ertes> laudiacay: they are pretty arbitrary, though most of the time when you see something enclosed in <angle brackets>, it's something related to Functor/Applicative
15:27:56 <laudiacay> yeah i think i get that so far
15:28:09 <laudiacay> but the different ones, theyre all some kind of combiners for this stuff
15:28:24 <monochrom> <|> for lists is list concatenate. Do not trust me, do your own lambdabot test.
15:28:30 <laudiacay> they just have different combos of boxed and unboxed input and output?
15:28:38 <laudiacay> > [1..3] <|> [3..5]
15:28:40 <lambdabot>  [1,2,3,3,4,5]
15:28:41 <ertes> their types are usually much more descriptive
15:28:43 <MartianHaskeller> laudiacay:  People use to play with Alternative for   Maybe values, but  each Monad may have his own Alternative instance
15:29:05 <laudiacay> ertes: oooh ok. 
15:29:12 <ertes> :t (<*>)
15:29:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:29:27 <monochrom> And observe that the list example goes a quite different approach than the Maybe example. Namely, the list example doesn't throw away anything.
15:29:56 <laudiacay> so that takes a boxed function that goes from unboxed type 1 to unboxed type 2 and a boxed value, and returns another boxed value of type 2
15:30:02 <laudiacay> ok that makes sense
15:30:05 <monochrom> OTOH you can also speak of the opposite.
15:30:33 <monochrom> So overall now you cannot assume "<|> throws away stuff" and you cannot assume "<|> doesn't throw away stuff either". \∩/
15:30:44 <laudiacay> what do you mean throw away stuff?
15:30:48 <ertes> laudiacay: try using "wrapped" and "pure", because "boxed" and "unboxed" have very specific meanings in haskell, so it may be a bit confusing out of context =)
15:30:55 <monochrom> > Just 5 <|> Just 10
15:30:57 <lambdabot>  Just 5
15:31:02 <monochrom> 10 is thrown away
15:31:04 <laudiacay> ertes: i thought pure also implied wrapped
15:31:17 <ertes> laudiacay: "wrapped" and "unwrapped" then
15:31:21 <monochrom> But the list example doesn't throw away your [3..5]
15:31:21 <laudiacay> okie
15:31:29 <laudiacay> monochrom: ooooh ok
15:31:50 <sbrg> I'm looking for a compilation flag that has been cropping up recently on reddit and similar places that can sometimes increase compilation speed. I simply can't remember it and I can't find it since, well, I don't remember it. This is really vague, but does anyone have an idea what I might be referring to?
15:31:57 <laudiacay> so about monadplus. what the heck is going on there?
15:32:09 <MartianHaskeller> monochrom: but that result for the list monad can be understood as a list of non-determinist results in which each element is selected one at a time
15:32:09 <ertes> sbrg: -O0?
15:32:23 <sbrg> nope, not that one. it's something about .. splitting things up, I think. maybe?
15:32:25 <MartianHaskeller> so in each iteration, one element is selected, and discarded all the rest
15:32:31 <monochrom> MonadPlus is when we only had Monad, we didn't have Applicative and Alternative.
15:32:34 <sbrg> oh, split-objs
15:32:48 <ertes> sbrg: does that decrease code quality?
15:32:57 <laudiacay> so monadplus, it has an identity, and it has mplus that crunches 2 things down into one thing
15:33:21 <monochrom> mzero becomes empty, mplus becomes <|>
15:33:22 <ertes> laudiacay: think of MonadPlus as a historical accident and focus on Alternative =)
15:33:34 <laudiacay> ertes: i have to learn monadplus for my class :(
15:33:36 <sbrg> ertes: no idea. i'm looking for info on it right now
15:34:25 <monochrom> we socially require MonadPlus (if present) to do the same thing as Alternative, so you just need to learn Alternative and the whole lesson carries over. It's a 2-for-1 Thursday.
15:34:28 <laudiacay> so the question for my homework is why either isn't an instance of monadplus (pleasssse nobody tell me the answer, don't want to cheat)
15:34:43 <monochrom> oh wait it's just Wednesday
15:35:03 <monochrom> OK Wednesday is buy-one-get-one-free and Thursday is 2-for-1. Problem solved.
15:35:18 <Tuplanolla> You can still tell your instructor to get bent for extra credit, laudiacay.
15:35:27 <ertes> laudiacay: is the question literally why Either is not a MonadPlus?  there is a subtlety involved here, so i'm asking
15:35:43 <MartianHaskeller> > [1,2] <|> [3,4]   -- four computations
15:35:45 <lambdabot>  [1,2,3,4]
15:35:59 <laudiacay> what i don't understand. why isn't mzero just like Right (something) and mplus returns the left is there is a left passed, or the second right if the input is two rights
15:36:11 <MartianHaskeller> it is not one nor two, but four
15:36:21 <laudiacay> ertes: *Exercise 15.3 Note that Either s, unlike Maybe, is not an element of the MonadPlus typeclass. Explain the obstruction.
15:36:26 <ertes> laudiacay: what's that "(something)"?
15:36:52 <ertes> ok, so (Either s)
15:37:04 <laudiacay> ertes: mmmm... like whatever mzero would be for s?
15:37:19 <ertes> laudiacay: Right's argument is not an s
15:37:31 <laudiacay> ertes: huh?
15:37:39 <ertes> mzero :: Either s a  -- Right takes an 'a'
15:37:46 <ertes> Left would take an 's'
15:37:50 <laudiacay> mmm oh true
15:38:20 <laudiacay> so a would have to be some kind of identity when it's mplus'd with whatever else
15:38:34 <laudiacay> like mzero would have to be Right (some sort of identity)
15:38:52 <ertes> laudiacay: can you come up with any value that you could apply Right to?
15:39:00 * hackagebot semiring-num 0.1.0.4 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.1.0.4 (oisdk)
15:39:07 <laudiacay> ertes: it would depend on a i think
15:39:31 <laudiacay> oh and that's no good, because we're coming up with an instance for Either s
15:39:35 <ertes> laudiacay: yeah, but problem is:  mzero :: Either s a -- mzero promises to work for any 'a' (as well as any 's')
15:39:49 <ertes> so it can't many any assumptions on 'a'
15:39:53 <laudiacay> that's rough
15:40:05 <ertes> that's a feature =)
15:40:17 <laudiacay> ok. yeah i see an issue with this, but i don't know how to state that in a way that answers the question
15:40:34 <ertes> you haven't exhausted all possibilities yet
15:40:37 <ertes> there is still Left
15:40:58 <ertes> mzero = Left _s  -- can you come up with a value _s?
15:41:03 <laudiacay> i mean we could do Left (id of s), but that would dominate any computation 
15:41:16 <ertes> what's "id of s"?
15:41:23 <laudiacay> like, if s is a list, []
15:41:30 <ertes> you don't know what s is
15:41:33 <ertes> again: no assumptions
15:41:35 <laudiacay> oh really?
15:41:37 <laudiacay> damn
15:41:45 <ertes> however:
15:41:49 <MartianHaskeller> too late. tired
15:42:00 <laudiacay> well it shouldn't really matter, right? you don't do any computations with Left besides just passing it down
15:42:07 <ertes> instance MonadPlus (Either s)  -- you are writing an instance for (Either s) for any type 's'
15:42:09 <monochrom> You know how to do "Either []" but you can't do "Either s" for unspecified s.
15:42:36 <ertes> like monochrom said, you *could* write an: instance MonadPlus (Either [])
15:42:39 <laudiacay> yeah, s isn't constrained in any way is it?
15:42:40 <ertes> but that's not the exercise
15:42:44 <laudiacay> hmmmm
15:42:45 <glguy> and then you'd have a kind error!
15:42:50 <ertes> whoops
15:42:58 <ertes> instance MonadPlus (Either [e])
15:43:06 <ertes> (for any 'e')
15:43:06 <monochrom> yikes
15:43:08 <laudiacay> so there's really no good way to do this is there
15:43:23 <laudiacay> because s is any type
15:43:31 <monochrom> in common speech you can say "there is no general default value"
15:44:02 <ertes> laudiacay: yeah, the essence of your problem is the following:  try to define a value (x :: a)
15:44:20 <laudiacay> wait huh?
15:44:33 <MartianHaskeller> I like  (<|>) when compose interesting things with high level meaning.  Either, [a] and Maybe are boring
15:44:49 <ertes> just type this into a source file:
15:44:49 <ertes> x :: a
15:44:49 <ertes> x = ?
15:45:05 <laudiacay> yeah good point
15:45:09 <monochrom> MartianHaskeller: You are tired and it is late and you need sleep instead of IRC.
15:45:26 <MartianHaskeller> monochrom:  sure ;)
15:45:52 <immersion> Is there a way to get `stack repl` to respect the magic comment that declares the required packages? For example, `-- stack --resolver lts-3.2 --install-ghc runghc --package turtle` https://docs.haskellstack.org/en/latest/GUIDE/#script-interpreter
15:46:04 <laudiacay> damn me too :( ive missed 2 cs lectures because pneumonia and yall are my salvation <3 thanks friends
15:46:30 <MartianHaskeller> I think that lambdabot restrict seriously the conversations on IRC
15:47:32 <Tuplanolla> Have you tried declaring an instance for `MonadPlus (Either a)` regardless of the unsoundness, laudiacay?
15:47:38 <ertes> #haskell needs a super-hero robe, and each time it has helped someone, it should say, "my pleasure, kid!", and vanish like a magic castle
15:47:56 <kadoban> Haha
15:48:13 <monochrom> I would freak out if a robe could speak.
15:48:36 <ertes> "i'm telling you!  #haskell exists!!"
15:48:45 <laudiacay> Tuplanolla: no i have not
15:49:00 <laudiacay> ertes: does this sound like a reasonable answer? There’s really no good way to define just a general identity for any type s, so defining mzero for (Either s) would basically be impossible.
15:49:05 <monochrom> Why is everyone saying bizzare things lately?
15:49:18 <ertes> laudiacay: try "value" instead of "identity"
15:49:26 <laudiacay> ertes: okay thanks :D
15:49:31 <kadoban> immersion: Not as far as I know, unfortunately
15:49:40 <Tuplanolla> Doing so should get you a duplicate instance declaration error, because there already exists an instance, but with the appropriate constraints, laudiacay.
15:50:16 <ertes> laudiacay: in haskell you can't just construct a value out of thin air, because each haskell type has its own specific schema for values (its constructors)
15:50:29 <ertes> laudiacay: like the only way to construct a Bool is to use True or False
15:50:41 <MartianHaskeller> and undefined
15:50:44 <ertes> laudiacay: (assuming that infinite loops don't exist)
15:51:05 <immersion> kadoban: Shoot, it would be really convenient for script development
15:51:27 <laudiacay> Tuplanolla: what do you mean? like constraining a to being like a monoid or something, where i can say it'll be like Right $ mempty a
15:51:43 <laudiacay> ertes: truuu
15:51:44 <Tuplanolla> Yes. It may be helpful to try that and study the other instance, laudiacay.
15:51:46 <kadoban> immersion: Ya, it's a good idea
15:51:57 <laudiacay> ohhh ok that makes sense! thank you guys SO MUCH!
15:52:21 <ertes> laudiacay: in other words, to construct a value of type 'a', you need to know something about 'a'…  if you know nothing, you can't construct values
15:52:49 <ertes> that's why you can't apply Left to anything (you know nothing about 's'), and same for Right
15:54:18 <ertes> laudiacay: BTW, if you want to learn more, this language feature is called *parametricity*
15:54:48 <ertes> it's annoyingly rare in programming languages, but haskell has it
15:55:00 <MartianHaskeller> and also Haskell can print your own name ten times
15:55:58 <MartianHaskeller> I mean, it is a programming language
15:57:52 <laudiacay> ertes: i think its just annoying :P
15:58:03 <laudiacay> but thank you so much again this has been amazing
15:58:15 <ertes> laudiacay: you'll learn to appreciate it =)
15:58:19 <laudiacay> ertes: also where can i learn more about parametricity?
15:59:01 * hackagebot semiring-num 0.1.0.5 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.1.0.5 (oisdk)
15:59:22 <Tuplanolla> Keywords for laudiacay: parametric polymorphism, free theorems.
15:59:25 <ertes> that's a good question =)
15:59:37 <ertes> oh yeah, "theorems for free" should be a good search term
16:00:39 <laudiacay> thanks dudes
16:00:46 <hpc> you can try them out with @free in a pm with lambdabot, though it's not exactly easy to use
16:01:07 <hpc> and you can indirectly see a more concrete benefit of parametricity by playing around with @djinn
16:01:13 <ertes>  @djinn is also a product of parametricity
16:01:26 <hpc> @djinn (a -> b -> c) -> (b -> a) -> (d -> b) -> d -> c
16:01:26 <lambdabot> f a b c d = a (b (c d)) (c d)
16:01:27 <laudiacay> what is djinn?
16:01:29 <ertes> @djinn Either a b -> Maybe b
16:01:30 <lambdabot> f a =
16:01:30 <lambdabot>     case a of
16:01:30 <lambdabot>     Left _ -> Nothing
16:01:30 <lambdabot>     Right b -> Just b
16:01:40 <hpc> you give it a type and it writes a function that matches it
16:01:41 <ertes> laudiacay: given a type, it writes a function of that type
16:01:53 <laudiacay> oh wow that's incredible where's the source?
16:01:59 <hpc> it works best if you give it more polymorphic types, for which there's often exactly one legal implementation
16:02:08 <ertes> https://hackage.haskell.org/package/djinn
16:02:18 <laudiacay> holy shit who wrote this
16:03:12 <hpc> he used to be here fairly often, goes by augustss
16:03:24 <hpc> he's done some other pretty great stuff like ghc's current sortBy implementation
16:03:28 <laudiacay> this is magical. cannot wait to play with it
16:03:55 <hpc> (which is based on a very long chain of other optimizations, but still quite impressive to read)
16:04:13 <ertes> i said you would learn to appreciate it =) but djinn is actually a minor reason…  the reason parametricity is so useful is reasoning about functions through their types…  you can tell a lot about an API just by looking at its types
16:04:15 <laudiacay> also, question, why is regex not included with like base haskell?
16:04:21 <laudiacay> ertes: :D
16:04:59 <EvanR> because regex shouldnt be encouraged as the tool to solve any text handling problem
16:04:59 <geekosaur> because parsers are easier to write and easier to understand (really: do you know what a random regex does by looking at it?)
16:05:20 <Tuplanolla> Take a look at Megaparsec and Trifecta for example, laudiacay.
16:05:21 <ertes> (parsers aren't exactly in base either)
16:05:26 <hpc> that bit of reasoning power is best experienced just by writing things
16:05:44 <hpc> you'll eventually find yourself going through hackage documentation and not even reading the descriptions of operations
16:05:45 <laudiacay> geekosaur: i mean i think regex is easier to read and write than most parsers
16:05:53 <ertes> laudiacay: beside what geekosaur just said, there are a million ways to implement regexes, and if you search for 'regex-' on hackage, you will see what i mean
16:06:01 <laudiacay> then again, i feel like im a regex wizard, but i am SO lost with parser writing
16:06:01 <hpc> or you'll just hoogle a type and take whatever looks like it matches your need
16:06:07 <hpc> implementation be damned
16:06:14 <EvanR> laudiacay: youll understand more once you start with parser combinators
16:06:21 <ertes> laudiacay: parsers are similar to regex, just more readable
16:06:27 <ertes> instead of x* you write (many x)
16:06:28 <laudiacay> see: my infix calc implementation from last week, when i needed about 9 functions to do what i could have done in one regex
16:06:31 <hpc> then someday you'll realize you've gone months without looking at the source of any of the packages you import
16:06:36 <ertes> instead of x+ you write (some x)
16:06:41 <EvanR> in haskell parser usually doesnt mean a bison program
16:06:50 <ertes> instead of x|y you write (x <|> y), and there it is again, that (<|>)
16:06:55 <laudiacay> mmm i guesssssss but regex is the beautiful easy way out of everything
16:07:11 <Tuplanolla> Context-free?
16:07:13 <EvanR> ... its not
16:07:40 <laudiacay> idk i spent like a month in this one class learning mad regex-fu and it's kinda sad to always be like "OH I KNOW HOW TO DO THIS" then realize i can't use regex
16:07:44 <kadoban> laudiacay: "beautiful" ... would not be my chosen descriptor
16:07:46 <ertes> laudiacay: oh yeah, we're talking about parser combinators, which is a functional API, not some extra language you have to compile
16:07:50 <ertes> it's literally a haskell library
16:07:50 <laudiacay> true
16:08:03 <laudiacay> i had to implement one last week it was awful
16:08:04 <EvanR> you can use regex, theres just better ways 
16:08:06 <kadoban> You certainly can use regex in haskell if you like.
16:08:09 <laudiacay> kadoban: idk i think they're v pretty
16:08:33 <kadoban> laudiacay: I'd go more with "travesty of readability and maintainability, and not that writable either"
16:08:54 <EvanR> laudiacay well, in haskell you definitely get used to not writing unchecked code as a string and having it evalled, thats another thing
16:09:01 * hackagebot sbp 1.2.8 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.2.8 (jgross)
16:09:14 <ertes> laudiacay: don't worry, there are regex libraries, even with sensible implementations that don't blow up exponentially like some do, but i invite you to try megaparsec
16:09:25 <laudiacay> i think if you get good enough at it, regex are incredibly readable and writable
16:09:25 <EvanR> (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\]) ... the beauty!
16:09:32 <EvanR> oh gez...
16:09:32 <laudiacay> oh god i think im going to puke
16:09:33 <hpc> the usefulness of regexes notwithstanding, their output is ridiculous and terrible when you try to capture all of it explicitly
16:09:40 <EvanR> that was bigger than i thought
16:09:53 <ertes> laudiacay: perhaps…  try megaparsec anyway =)
16:09:59 <EvanR> laudiacay: that regex demonstrates a basic missing feature that is also missing in HTML, variables
16:10:00 <hpc> you have the full matched string, the position in the source where it occurs, 9 capture groups, possibly a substitution
16:10:06 <laudiacay> i mean like url-recognition is one thing, but finding matched parens recursively is pretty nice
16:10:09 <EvanR> you have to repeat yourself a lot
16:10:22 <hpc> and then you have to repeat that for additional matches if the regex has /g or imilar
16:10:23 <Tuplanolla> How would you typically parse, say, XML, laudiacay?
16:10:25 <laudiacay> EvanR: you can use variables? just use capture groups
16:10:27 <EvanR> you cant find matched parens with regex
16:10:37 <ertes> laudiacay: first of all you can now parse complicated grammars *properly* (you can't do this with regex)…  yes, you can parse HTML…  i mean real HTML, not some flat approximation =)
16:10:37 <laudiacay> Tuplanolla: you're going to get mad, i just use mathematica's import or beautifulsoup
16:10:44 <EvanR> laudiacay: no, see the number of times [a-z0-9-] is written over and over?
16:10:53 <Schoolmeister> Regex is beautiful much in the same way that when you drop a nicely ordered stack of documents on the ground and they seem to have dropped without messing up the order, however you're not sure anymore, so you need to check anyway.
16:11:00 <EvanR> repeating code is silly
16:11:40 <Schoolmeister> that was a mouthful
16:11:42 <ertes> laudiacay: with regex you need a roundtrip for every level…  you need to *leave* regex land and write loopy code
16:12:00 <ertes> laudiacay: parser combinators have first-class support for recursive grammars
16:12:41 <ertes> laudiacay: but let's be honest…  there is probably a library for almost anything you're going to parse, so ideally you will just use the right library =)
16:12:58 <EvanR> really?
16:14:17 <EvanR> unless its json, xml, csv, midi files, or rocket league replays, theres probably not a library for it already
16:14:24 <ertes> probably…  my perspective may be skewed
16:14:35 <Cale> I've worked on two big client projects at Obsidian Systems so far, and both of them have custom parsers in them.
16:14:49 <ertes> alright, alright
16:16:06 <Cale> (One is for a chat service and parses special formatting codes out of the text the user types, the other is a parser for not-intended-to-be-machine-readable text files produced by the USDA regarding trucking rates.)
16:16:26 <EvanR> gross
16:17:04 <ertes> right…  i had to parse BCSV for a client
16:17:20 <ertes> it's similar to CSV, but…  you may guess what the B stands for
16:17:32 <EvanR> broken??
16:17:37 <ertes> Bullshit
16:17:45 <EvanR> was my first guess 
16:18:12 <Tuplanolla> "Barely" would be even more horrifying.
16:18:44 <ertes> \xFF as field separator, \n to separate lines, but the real horror was lack of quoting, even in the presence of commas
16:19:01 * hackagebot semiring-num 0.1.0.6 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.1.0.6 (oisdk)
16:19:22 <ertes> inconsistent encoding…  some fields latin-1, some UTF-8
16:19:47 <EvanR> hl7 is pretty cool, it has 4 levels of separators
16:20:01 <EvanR> for having nested sequences inside nested sequences
16:20:22 <EvanR> they decided 4 levels was enough for anybody
16:21:25 <ertes> i mixed something up…  \xFF was the row separator…  in any case it was ambiguous
16:21:55 <ertes> sounds lovely =)
16:45:09 <zipper> Hey, trying to install ghc via stack setup but the error is that the user package DB doesn't exist
16:45:13 <zipper> What do I do?
16:49:15 <sm> hi zipper, paste the command and error at a paste site like gist.github.com
16:50:21 <zipper> sm: I was lacking libtinfo
17:14:08 <Xpert> hi all 
17:14:17 <Xpert> where are u from haskell
17:14:31 <Xpert> buenas
17:14:34 <Xpert> boas
17:16:53 <Xpert> Lord_of_Life BOAS
17:16:55 <Xpert> slackircbot BOAS
17:17:17 <Lord_of_Life> no
17:18:44 <Xpert> slackircbot BOAS?
17:20:57 <Schoolmeister> What's BOAS?
17:25:09 <Xpert> who can help me with c++ scripts
17:25:29 <hiptobecubic> sigh
17:25:38 <Schoolmeister> doubt this is the channel for it
17:25:57 <hpc> /topic welcome to #c-pound-pound
17:26:15 <hpc> er, plus-plus
17:26:22 <hpc> actually i like that better
17:26:27 <hiptobecubic> C## is better
17:26:43 <Tuplanolla> Is that D or something?
17:26:59 <Schoolmeister> just sharper C#
17:27:10 <hiptobecubic> indeed
17:27:15 <hpc> stick 'em with the pointy end
17:27:24 <hiptobecubic> Although musically, I suppose it's D
17:27:42 <hiptobecubic> I don't remember the notation for quarter-tones
17:28:03 <hpc> musically that scale is pretty pants anyway
17:28:13 <hpc> there's no C flat
17:28:20 <Schoolmeister> C- ?
17:28:35 <hiptobecubic> There's C--
17:28:53 <hiptobecubic> There's certainly Cb
17:29:01 <hiptobecubic> Just like there's C##
17:29:18 <geekosaur> bring back B?
17:29:29 <hiptobecubic> Was B a language?
17:29:32 <Schoolmeister> yeah
17:29:42 <geekosaur> BCPL -> B -> C
17:29:53 <Schoolmeister> Wasn't A a language also?
17:30:31 <Schoolmeister> I've got a C textbook called "A Book on C", always quite liked that name
17:30:40 <amalloy> i wonder what BOAS was supposed to mean
17:30:45 <Clint> amalloy: it's portuguese
17:30:53 <hiptobecubic> There's CPL
17:31:05 <hpc> it's like GPL with a little bit erased
17:31:18 <hpc> clearly CPL = BSD
17:33:12 <Schoolmeister> fyi I was wrong, there's no A, at least not one before B
17:34:10 <hpc> you mean APL doesn't stand for "A Programming Language"?
17:34:17 * hpc 's world shatters
17:34:51 <Rembane> It is the best name for a programming language
17:35:03 <hpc> it's the only name for a programming language
17:36:08 <eacameron> a ~ b is a constraint that a and b are the same. Is there one for "not the same"?
17:36:11 <Schoolmeister> Clint: What did it mean though?
17:36:31 <hpc> eacameron: no
17:36:37 <eacameron> hpc: :(
17:37:07 <hpc> eacameron: the simple answer for why iirc is "it makes evaluating constraints undecidable"
17:37:19 <eacameron> hpc: I can see that...I guess.
17:37:25 <hpc> the more accurate answer is something for others to explain
17:37:47 <eacameron> hpc: But it seems you could use type level equalities to do a == b ~ False
17:37:48 <hpc> i am not quite in teaching shape on my understanding of that bit of theory
17:38:18 <hpc> the trick is that (~) isn't (==)
17:38:19 <Clint> Schoolmeister: well, he said "buenas" first, which would be short for "buenas tardes", so i assume he was shortening "boa tarde" and adding an s
17:39:01 <hpc> a type-level (==) would have a type like * -> * -> ''Bool (or however the notation is now, but let's go with this)
17:39:16 <hpc> (~) actually has type * -> * -> Constraint
17:39:33 <hpc> oh also s/type/kind, i have been doing some agda recently
17:40:06 <eacameron> hpc: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Type-Equality.html
17:41:15 <ertes> i'm gonna write the Final Guide to Haskell
17:41:55 <jmcarthur> Do most people write the Initial Guide to Haskell?
17:41:58 <hpc> eacameron: bwuh
17:42:14 <Clint> H.A.S.K.E.L.L.
17:42:28 <eacameron> hpc: bwuh?
17:42:35 <jmcarthur> Clint: More appealling to the DoD.
17:43:01 * Clint snorts.
17:44:04 * hackagebot web-routes-th 0.22.6 - Support for deriving PathInfo using Template Haskell  https://hackage.haskell.org/package/web-routes-th-0.22.6 (JeremyShaw)
17:44:17 <hpc> jmcarthur: he wants all links to point towards his guide
17:44:26 <hpc> jmcarthur: the initial guide to haskell would only be linking to other guides
17:44:57 <hpc> eacameron: just didn't expect that to exist, it's pretty neat
17:45:17 <eacameron> hpc: Yah it is.
17:45:18 <ertes> i couldn't think of a title that could be abbreviated as SKI
17:45:27 <ertes> (and yes, i'm nerd-sniping you)
17:51:46 <jmcarthur> hpc: That makes it sound like a Final Paper is one which is cited by all others, and therefore the chronologically first one.
17:52:57 <ertes> class PaperFix
17:54:10 <Tuplanolla> All of a sudden Final Fantasy makes sense, jmcarthur.
17:54:43 <Schoolmeister> Why is it legal to do, for example, [a] -> Integer, but not [a] -> Num?
17:55:02 <Clint> Schoolmeister: Num's not a type
17:55:26 <jchia1> Schoolmeister: Num b => [a] -> b
17:55:44 <EvanR> and no fair constraint kinds
17:56:30 <Schoolmeister> Clint: I see, I guess I was confusing classes and types. Thanks.
17:56:59 <AbelianGrape> In Heist, what is the best way to include the contents of another template? Right now I have `"theme.header" ## callTemplate "theme.header"` in my hcCompiledSplices, which works, but seems messy. Can I reference a template file by name wihtin a template?
17:57:25 <EvanR> you have to put types on the left or right of ->. this sounds obvious but actually I got mixed up alot until I beat that fact into my head
17:58:02 <eacameron> hpc: Yah it is.
17:58:11 <EvanR> (when doing dependent types i kept ending up with values there instead of types, which is nonsense)
17:59:14 <c_wraith> EvanR: -XTypeInType makes values perfectly good types.  :)  (But you can't put them on either side of ->)
17:59:52 <EvanR> right
17:59:57 <mightybyte> AbelianGrape: You can use heist's apply tag to do that.  http://snapframework.com/docs/tutorials/heist
18:00:36 <EvanR> c_wraith: er, it makes values into types?
18:00:47 <EvanR> it makes kinds into types
18:01:04 <c_wraith> EvanR: No.  But it lets you promote any value into a type.  (Not the same thing in reality)
18:01:47 <EvanR> that sounds odd
18:01:54 <c_wraith> EvanR: the promotion has to be done on a known type, during typechecking.  Hardly the same thing as a value at runtime.
18:02:14 <c_wraith> Err, on a known value
18:03:05 <c_wraith> Hmm.  I guess that's not *completely* true.  GHC still can't promote negative numbers or floating-point numbers.
18:03:20 <AbelianGrape> mightybyte: The first line of output is "<apply template='theme.header'></apply>&#13;"
18:03:28 <EvanR> i actually wanted floats in the types the other day
18:03:35 <AbelianGrape> Do I have to do something to make the apply tags do stuff?
18:03:35 <EvanR> or a form of float
18:03:54 <EvanR> or even a placeholder that does nothing but indicates stuff in the type
18:05:27 <mightybyte> AbelianGrape: Are you using compiled or interpreted mode?
18:05:51 <AbelianGrape> Compiled, as far as I know
18:06:16 <AbelianGrape> I import Hiest.Compiled and use renderTemplate
18:06:26 <AbelianGrape> *heist
18:06:55 <EvanR> c_wraith: do regular operators work on the promoted values at the type level?
18:07:16 <mightybyte> Then you should add defaultLoadTimeSplices (http://hackage.haskell.org/package/heist-1.0.1.0/docs/Heist.html#v:defaultLoadTimeSplices) to the load time splice section of your heist config.
18:07:55 <c_wraith> EvanR: no.  Only constructors and application of them to other things made of constructors and application.
18:08:27 <EvanR> what about type families
18:08:32 <c_wraith> Those do work on them
18:09:06 <c_wraith> A lot of what the singletons library does is let you write a definition once, and make it a function at the value level, a type family at the type level and..  what's the third thing?  A class for converting the type to the value?
18:11:07 <c_wraith> In any case, the long term plan of the people who built both -XTypeInType and the singletons library is building -XDependentTypes, allowing you to do those things without using the singletons library.
18:11:43 <c_wraith> It's just another 2-3 years out.  Maybe more, pessimistically.
18:12:19 <EvanR> -XDependentTypes seems like a bold statement...
18:12:37 <EvanR> i havent read much on what this would actually give you
18:12:48 <AbelianGrape> mightybyte: Thanks, that did it
18:12:59 <EvanR> arbitrary computation on values at the type level?
18:13:41 <AbelianGrape> mightybyte: How does directory nesting influence the name of tempates? e.g. if I had templates/foo/bar.tpl, how would I reference bar.tpl?
18:14:05 * hackagebot safecopy 0.9.2 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.9.2 (JeremyShaw)
18:14:39 <c_wraith> EvanR: Pi types and, iirc, promotion of functions to the type level.
18:15:04 <c_wraith> EvanR: A termination checker would not be included.  Haskell's already an inconsistent logic, who cares? :)
18:15:20 <EvanR> that will certainly be interesting
18:16:04 <EvanR> i wonder if they will have floats at the type level
18:16:16 <EvanR> or thats a specific "hell no" subject
18:17:09 <c_wraith> EvanR: for the existing details, see https://github.com/goldfirere/thesis and https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
18:17:15 <c_wraith> (possibly in the other order)
18:17:19 <kadoban> Out of curiosity, what do you use dependent types for if not for termination checker kind of stuff?
18:17:47 <EvanR> heres the type of the append function for animation segments
18:18:03 <EvanR> append :: A l1 a -> A l2 a -> A (l1 + l2) a
18:18:27 <EvanR> a measured monoid
18:19:00 <EvanR> you dont need dependent types for this, but its more natural if you have thme
18:19:19 <EvanR> stuff like this is everywhere
18:19:48 <jle`> you can make stronger statements about behavior/correctness with dependent types
18:19:54 <jle`> not just termination
18:20:40 <kadoban> Hmm
18:20:44 <EvanR> (i accidentally basically just reused the same tired dependent type example, concat of length indexed lists)
18:21:00 <EvanR> not a very convincing proof that this stuff is everywhere
18:21:09 <jchia1> What do you think of "foo :: Int; foo = 4" vs "foo = 4 :: Int" for a top-level variable? The latter takes only one line and has no type ambiguity but GHC still produces a warning.
18:22:00 <kadoban> jchia1: I'd do the former and wouldn't worry about one extra line.
18:22:14 <EvanR> c_wraith: i gather there wont be any fancy proof search, UI assistance to build proofs
18:22:32 <c_wraith> EvanR: Nope.  Most of what you're getting is pi types.
18:22:39 <jle`> yeah the lack of proof assistants in haskell makes things really annoying sometimes
18:23:12 <EvanR> does pi types imply sigma types
18:23:16 <jle`> having to manually prove trivial things like association and right-zeroes is annoying when it gets really involved 
18:23:22 <jle`> haskell already have sigma types
18:23:25 <jle`> :O
18:23:31 <EvanR> eh?
18:23:43 <jle`> s/have/has
18:24:31 <jle`> well they're not built into the language
18:24:35 <jle`> but they're straightforward enough
18:24:44 <c_wraith> jchia1: when types are more complex, it's far more convenient to separate them from the implementation, especially for someone browsing your code.  If you accept that, you might as well stick with the same convention with short types.
18:27:07 <EvanR> MkS :: a -> f a -> S a f ?
18:27:26 <EvanR> not dependent
18:27:53 <EvanR> the type of the second component has to depend on the value of the first component
18:28:38 <EvanR> sigma types and dependent records also come up a lot... everywhere
18:35:22 <jle`> MkS :: p a -> f a -> Sum p f, sigma(x satisfies p x) f(x)
18:37:27 <EvanR> huh
18:37:48 <EvanR> i have no idea what youre doing, so im not sure if this counts as "easy enough" ;)
18:37:50 <jle`> if the predicate is just "x in A", then that's Sum (Sing @A) f
18:38:30 <EvanR> x in A, but wheres the x ?
18:38:47 <jle`> you have to pattern match on the 'p a' to find out :)
18:39:12 <jle`> btw x (or a) is a type, A is meant to be a kind here
18:39:49 <EvanR> x is a type... phooey
18:40:24 <jle`> well, it can be a promoted value
18:53:06 <danilo2> Hello! Does anybody know any library that works just like xdg-open but is cross-platform in Haskell ?
19:14:26 <geekosaur> danilo2, no (and xdg-open is only reliable as the distribution packager; it's pretty broken on some, or only works fully if using certain desktop environments and fails for many file types otherwise, etc.)
19:14:38 <geekosaur> *only as reliable as
19:23:03 <danilo2> geekosaur: yep, but its the only standarized Linux way, so if its not working on a particular system, I dont care. I just want to be able to have an open function which will use xdg-open on linux, open on mac and some internal shit on windows
19:25:11 <geekosaur> don't even need internals. cmd /c start whatever
19:26:36 <danilo2> geekosaur: Oh I didnt know about it! If so it's pretty simple. Will cmd /c test.jpg or cmd /c http://google.com just work? If so, its straigthforward to create what I want. Sorry for asking lame windows questions, I'm just keeping as far as possible form this platform
19:27:04 <geekosaur> "start" is part of the command
19:27:59 <geekosaur> hm, but it pops a console window briefly
19:28:03 <geekosaur> (it does work though)
19:28:39 <geekosaur> cmd /c start https://www.google.com
19:29:47 <danilo2> geekosaur: great to know that! thank you! :)
19:34:06 <Rotaerk> hmm what's a good solution for inter-process communication when I will basically have one process that's a daemon, and then occasionally commands can be run (separate processes) that communicate with the daemon
19:34:15 <Rotaerk> was considering cloud haskell but that seems like overkill
19:34:23 <Rotaerk> also raw networking seems too low level
19:36:41 <Rotaerk> specifically, my daemon is going to maintain a connection to IRC, and I would want to run programs from the commandline that tell it to, say, join a channel
19:36:49 <Rotaerk> or connect to a network
19:37:20 <Rotaerk> so the programs don't do much more than send a message, and potentially receive a response
19:37:46 <EvanR> Rotaerk: ive used fork with stdio as communication
19:38:40 <EvanR> simple enough and works well if the other proces is in C
19:38:58 <EvanR> as opposed to being too complex for C
19:39:30 <geekosaur> on unix I generally use fork w/pipe, yeh. if you want to be hip you could use dbus
19:39:51 <tom7942> funny
19:39:58 <tom7942> dbus, yuck
19:40:13 <Rotaerk> could you provide a link to what you mean?  only fork I'm aware of is to spawn a separate thread
19:40:25 <EvanR> System.Process
19:40:30 <geekosaur> forkProcess
19:40:35 <Rotaerk> thanks
19:40:41 <geekosaur> in System.Process or System.Posix.Process
19:40:54 <geekosaur> well, possibly only the latter, SystemProces has the portable interface
19:41:03 <geekosaur> (you do not want to use fork() on windows. really.)
19:41:18 <EvanR> what happens?
19:41:42 <geekosaur> it has to be emulated. slowly, painfully, and in a way that causes many antivirus scanners to think you've been infected
19:41:54 <EvanR> nice
19:42:06 <geekosaur> (the new linux compat subsystem does fork natively. windows itself does not.)
19:43:45 <Rotaerk> hmm what exactly would I be forking?
19:43:46 <geekosaur> you can find a few bug reports and ghc mailing list messages where "geesh this windows compile is REALLY SLOW ... oh symantec starts scanning every filesystem tree it touches after fork()"
19:43:54 <Rotaerk> not clear on how that helps me communicate with the daemon
19:44:16 <geekosaur> hm, actually the case you described above would not work for the fork+pipe thing
19:44:26 <EvanR> i assumed this was part of the same applicatuon
19:44:41 <EvanR> so maybe youd be forked
19:44:42 <tom7942> inet or unix domain socket
19:44:44 <geekosaur> unix socket, fifo, ipcmsg, dbus
19:45:35 <geekosaur> (dbus is kinda ridic unless you are planning to integrate with a desktop environment. fifos and ipc msg have edge cases)
19:46:04 <geekosaur> (but fifo is simplest if you can work within its constraints)
19:46:07 <Rotaerk> I could try those, but they seem at around the same level of abstraction as raw networking
19:46:37 <EvanR> named pipes in the fs are pretty easy but they are now named pipes in the fs you have to manage
19:46:38 <geekosaur> yes, there isn't much between the raw interfaces and something like dbus
19:46:55 <geekosaur> at least fifos are simple, as long as they're not too simple for you
19:48:48 <tom7942> why is desktop environment a special case for ipc? mesh network?
19:48:54 <Rotaerk> hmm think I'll just do cloud haskell if there's nothing simpler but higher level than those other things
19:49:20 <geekosaur> just because everything else in the DE uses dbus already, and you can get some added interoperability/integration from it
19:58:51 <Rotaerk> actually, dbus looks perfect >_>
20:02:12 <tom7942> good luck
20:14:34 <orion> Would it be possible to use Cloud Haskell for things like job scheduling?
20:20:14 <Axman6> possible sure, but it would probably involve writing a lot of code
20:43:40 <coleman> Can I return a tuple of an undefined depth?
20:43:55 <geekosaur> no
20:44:17 <coleman> geekosaur: how can I represent a syntactic structure?
20:44:28 <coleman> (a, (b, (c, "foo"))
20:44:35 <coleman> tuples and strings
20:44:41 <gfixler> coleman: maybe a rose tree
20:44:50 <grantwu> I mean, you can go as deep as you want, but the depth must be known statically
20:44:52 <gfixler> or just a recursive ADT
20:45:02 <geekosaur> tuples don't make good lists. either use a list or a list/tree ADT
20:45:31 <geekosaur> tuples are best used when you are producing multiple values from a function
20:45:41 <coleman> geekosaur: any good tree libraries where I can travel up and down with ease?
20:45:50 <coleman> geekosaur: don't need anything fancy.
20:45:57 <gfixler> Data.Tree?
20:46:10 <gfixler> https://hackage.haskell.org/package/rosezipper-0.2/docs/Data-Tree-Zipper.html
20:46:17 <gfixler> that's a tree you can walk around
20:46:19 <geekosaur> the notion of moving up and down doesn't sound very functional, unless it's ... a zipper, yes
20:46:58 <coleman> say I'm at a leaf in the tree and I want to travel all the way back to beginning recording each step on the way
20:47:52 <gfixler> coleman: simple recursive function
20:48:00 <coleman> gfixler: with Data.Tree?
20:48:06 <gfixler> coleman: sure
20:48:15 <coleman> thanks guys
20:48:20 <coleman> peave
20:48:22 <coleman> pace*
20:48:25 <coleman> peace*
20:55:33 <Cale> coleman: You might also do something like parameterise the tree on a list of parents to which you intend to return
20:55:45 <Cale> er, parameterise the *function*
20:56:06 <coleman> Cale: okay, good to know!
20:56:13 <Cale> But I don't really know what it is that you're trying to compute
20:57:14 <coleman> Cale: okay I'm trying to take syntactic statements like ("not", ("not", p))
20:57:32 <coleman> Cale: and apply rules to them in an order to cunstruct a tree
20:57:42 <coleman> p = ("not", ("not", p))
20:57:48 <Cale> Surely that's not just a tuple?
20:58:02 <coleman> Cale: nope but I'm used to lisp
20:58:02 <geekosaur> you will find it hard to type such things in general
20:58:24 <coleman> geekosaur: use a different language then?
20:58:47 <Cale> Like, if you were to use that pair of pairs like that, the function you wrote would be of some type like (String, (String, Something)) -> SomethingElse
20:58:49 <coleman> geekosaur: haskell is great cause I can pattern match all the rules. I can define a whole logical system in ~10 lines.
20:58:52 <geekosaur> I mean you can't assign a type to tuples used that way, in general. you want a recursive data type of some kind
20:58:59 <Cale> and would only work on things of *exactly* that shape
20:59:05 <geekosaur> tuples are just the wrong type for this kind of thing
20:59:18 <coleman> geekosaur: right they aren't tuples. I just wrote it like scheme by habit
20:59:34 <Cale> So, usually when you're working with syntax trees, you define a recursive data type which precisely reflects the (abstract) syntax of your language
20:59:45 <coleman> Cale: any resources on this?
20:59:50 <Cale> hmmm
21:00:51 <Cale> http://dev.stephendiehl.com/fun/lambda_calculus.html -- Google came through, here's one :)
21:01:20 <coleman> Cale: thanks!
21:01:22 <gfixler> that's sure taking a step back
21:02:50 <EvanR> small step or big step back semantics
21:03:13 <Cale> There's a link to the full source at the bottom there
21:03:27 <Cale> with a nice little github repo that looks well-organised
21:03:42 <Cale> https://github.com/sdiehl/write-you-a-haskell/tree/master/chapter4/untyped
21:04:52 <coleman> Cale: I'm not really writing a langue, though. I'm just trying to write a program to do logical derivations.
21:05:21 <coleman> Say I have "not not p" as a premise and "p" as a conclusion, I want the program to tell me that the conclusion follows by  rule "DNI"
21:05:31 <coleman> in haskell:
21:05:37 <coleman> DNE*
21:05:45 <coleman> dne ("not, "not", c)) = c
21:06:00 <Cale> You should still have a type of logical expressions
21:06:10 <coleman> or dni c = ("not", ("not", c))
21:06:23 <Cale> data Expr = Var String | Not Expr | And Expr Expr | Or Expr Expr
21:06:24 <coleman> Cale: right. I shoudl read more.
21:06:26 <Cale> something like that
21:08:03 <Cale> and then you can write functions which manipulate values of that type, e.g.  dne (Not (Not x)) = dne x; dne (And x y) = And (dne x) (dne y); dne (Or x y) = Or (dne x) (dne y); dne (Var s) = Var s
21:08:34 <Cale> Or simply predicates which pattern match and tell you whether a given rule applies at the top level or something.
21:09:09 <Cale> dneApplies (Not (Not x)) = True; dneApplies x = False
21:09:12 <joe9> I am trying to understand this: http://stackoverflow.com/a/9234807 . Is it a pain to maintain this data type: data UserMessage = UserMessage { umUser :: User, umMessage :: Message }
21:09:31 <coleman> Cale: what does this mean `dne (Not (Not x)) = dne x`?
21:09:41 <joe9> or, can i just create a function that can generate this data type on the fly when query'ing?
21:10:02 <Cale> Oh, actually my function there is incomplete -- you need another case for a single Not after that
21:10:30 <Cale> coleman: Basically, this function is going to remove all the double negations recursively throughout the expression
21:10:41 <coleman> Cale: I onyl want to remove at the top :-)
21:10:42 <EvanR> joe9: you want to put just the raw data in the database, then view it as much as possible with functions
21:10:45 <Cale> coleman: So after removing the outermost double negation, it continues looking for another
21:10:55 <coleman> Cale: right, yeah
21:10:56 <Cale> But yeah, you can easily do simpler things :)
21:11:08 <coleman> Cale: yep I know, jsut checking
21:12:07 <EvanR> joe9: the more redundant data you put in the database, the more likely itll end up being inconsistent
21:12:07 <Cale> Oh yeah, and you might also want data Expr = ... | Lit Bool
21:12:19 <Cale> adding boolean literals to the language
21:12:58 <Cale> coleman: and you could write something like  eval :: Map String Bool -> Expr -> Maybe Bool
21:13:27 <tnks> I was looking at the source code for safe-exceptions (https://hackage.haskell.org/package/safe-exceptions-0.1.4.0/docs/src/Control-Exception-Safe.html#withException) and had a question.
21:13:29 <Cale> (which would try to evaluate the given boolean expression, looking up the values of the variables in the Map)
21:14:06 <tnks> what's the point of the underscore assignment?   _ :: Either SomeException b <- C.try $ after e1
21:14:20 <Rarrikins> tnks: It usually means to ignore the result.
21:14:27 <coleman> Cale: in sentential logic we just try to show that Q follows from P, not truth values, since eventually I'll want to add quantifiers, in which truth-functionality breaks down.
21:15:04 <joe9> EvanR , ok, Thanks.
21:15:04 <tnks> Rarrikins: right, but is that needed in Haskell?  Could we just have `C.try $ after e1`?
21:15:22 <Cale> coleman: fair enough, but it's a decent warm-up exercise anyway :)
21:15:37 <Rarrikins> tnks: Yes, except here we want to ensure the type of the ignored value is Either SomeException b
21:15:56 <Rarrikins> tnks: It's a bit harder to write the type without the <- part.
21:16:15 <coleman> Cale: right :-)
21:16:31 <tnks> Rarrikins: ah, this helps HM get the exact type we want, because exceptions are kind of unityped, right?
21:16:56 <EvanR> exceptions have types, and dynamic types
21:17:02 <EvanR> sometimes
21:17:25 <Cale> coleman: Once you get to quantifiers, it'll look even *more* like the lambda calculus implementation, because you'll have binders something like data Expr = ... | Forall String Expr | Exists String Expr
21:17:53 <coleman> Cale: I'll bet prolog does what I want ^_^ but I wanna build this anyway
21:19:37 <grantwu> I see prolog
21:19:39 <grantwu> Fleeeeee
21:20:03 <Rarrikins> tnks: Sorry, I'm not sure.
21:20:38 <tnks> Rarrikins: I think you've helped anyway.
21:25:39 <jim___> clear
21:27:27 <Cale> BZZT
21:27:47 <jim___> hello there
21:27:51 <Cale> hi
21:28:21 <jim___> Is this channel haskell-beginners friendly?
21:28:27 <Cale> yes
21:29:06 <jim___> I've been thinking about learning Haskell for quite some time already
21:29:24 <kadoban> jim___: Great :)
21:29:28 <Cale> Feel free to ask any questions you might have, there's usually someone around who is happy to help out.
21:29:38 <Cale> (if not too many :)
21:29:53 <jim___> I've been working with  C, Python and R for the last 4 years
21:30:07 <jim___> The closest I ever got to FP was JavaScript
21:30:26 <jim___> but I've heard it's not really considered a FP language
21:30:43 <jim___> I'm thinking about using Haskell to mathematic calculations
21:30:49 <Cale> Yeah, not really. You can attempt some FP things in it.
21:31:02 <jim___> I've been using numpy, scipy and R 
21:31:09 <kadoban> What exactly is a FP language is a matter of some debate. JS can be fairly functional, depending on how you write it. But haskell should feel quite a bit different I would guess.
21:31:27 <jim___> But I always seen people talking about Haskell as the best language for math
21:31:49 <jim___> I mean Haskell is purely functional, doesn't allow any OOP
21:31:52 <Cale> I don't know if I'd say Haskell was especially good at math, but it's a nice language to use if you think like a mathematician.
21:31:53 <kadoban> Not sure I'd really say that, though if it convinces you to learn it might be a lie worth letting pass ;)
21:31:59 <grantwu> Uh... define "math"
21:32:08 <grantwu> Uh... no, it doesn't allow implict effects
21:32:24 <gfixler> jim___: here's some inspiration for you: https://www.youtube.com/watch?v=jaHoYy2rnUc (McIlroy is the inventor of Unix pipes)
21:32:32 <grantwu> OOP is kind of orthogonal
21:32:35 <jim___> well, actually the main reason I wanna learn HAskell 
21:32:43 <jim___> is to make this change in mindset
21:32:45 <Cale> Functions in Haskell are honest functions -- if you apply a function to some arguments and obtain a result, you'll always obtain that result.
21:33:12 <jim___> Because most OOP languages are very similar - they share similar ideas of programming
21:33:21 <kadoban> jim___: Should definitely do that, haskell is a very interestingly different way of looking at programming compared to many other languages.
21:33:22 <jim___> and I wanted to learn some brand new approach in programming
21:33:23 <Cale> Because of this (and several other things, really), you can think of Haskell programs in an equational way, substituting functions for their definitions, for instance.
21:34:12 <grantwu> Most OOP languages are also imperative, yes
21:34:13 <jim___> What would be the best way to learn Haskell, considering that I already know my stuff in other languages?
21:34:20 <gfixler> that was something that took a while for me to notice in Haskell - functions are all just expressions
21:34:39 <gfixler> it took learning Haskell and seeing this to finally really understand what "statement" meant
21:34:55 <Cale> jim___: Well, there's some free course materials here: http://www.cis.upenn.edu/~cis194/spring13/lectures.html which people tend to like
21:34:57 <kadoban> jim___: http://haskellbook.com/ is my usual advice, though it's not free
21:35:45 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html -- this book by Graham Hutton is also a good intro
21:37:14 <Cale> (well, tbh, I haven't had a chance to really look carefully enough at haskellbook.com to know if I should recommend it or not -- a lot of beginners seem to enjoy it, which is nice, but I've also heard some mixed reviews from people who I'd usually trust)
21:37:36 <jim___> Oh, thank you 
21:38:05 <jim___> And what do you think would be the good approach to try and understand functional programming? 
21:38:16 <jim___> Try and rewrite my projects in Haskell
21:38:19 <coleman> Cale: how do I return the expr?
21:38:24 <jim___> would that be a good idea?
21:38:30 <coleman> dne (Not (Not Expr)) = Expr
21:38:33 <coleman> obv wrong
21:39:18 <Cale> jim___: Yeah, just trying to do stuff can definitely work -- be prepared to feel a little incompetent for a bit. Personally it took me like 2 months before I felt like I could really get useful things done, and about a year before I was properly comfortable.
21:39:41 <Cale> (But now it's by far my favourite language to get work done in)
21:40:20 <Cale> coleman: just bind a variable: Expr since it starts with an uppercase letter, would have to be a data constructor
21:40:35 <Cale> dne (Not (Not expr)) = expr  would work
21:40:42 <coleman> Cale: cool
21:40:46 <jim___> Thank you for advice, somewhere I've heard that #haskell is one of the most quality channels in FreeNode and I'm not dissapointed
21:40:56 <jim___> Thank you, very helpful :)
21:41:00 <Cale> jim___: No problem :)
21:41:01 <kadoban> jim___: I would strongly advise against that, unless you first do some other basic learning, or unless you're especially tolerant of extreme frustration.
21:41:20 <Cale> Well, everyone is different
21:41:35 <Cale> Some people can pick up the language and fight their way through to practicality rather quickly
21:41:53 <Cale> For other people, sticking to treating the language almost like a calculator for a while is better.
21:42:23 <Cale> (and avoiding I/O-performing programs, and using the interactive evaluator as a user interface)
21:42:37 <Cale> Most people I suspect are going to fall somewhere in between those two extremes
21:43:09 <Cale> If the programs you want to write mostly calculate stuff, just typing expressions into GHCi can be a pretty satisfying user interface.
21:44:50 <Cale> It's not that I/O is hard in Haskell, it's just rather different from every other language you're likely to have used, and it can help to understand types and typeclasses a bit before using it.
21:46:59 <Rotaerk> it's kind of like how, in qbasic, the first thing you might learn is a print statement, but then when you learn C, you have to deal with the main function and #includes and stuff before you can even do output
21:47:29 <Rotaerk> only haskell has even more stuff you should probably learn first before getting into that
21:49:14 <Cale> heh, yeah, perhaps
21:50:01 <dibblego> children pick up haskell easily, consistently
21:51:41 <jim___> Rotaerk: What are the features of Haskell you're talking about?
21:51:44 <saurabhnanda> so, what's the difference between a monoid and a foldable?
21:52:12 <MarcelineVQ> what an excellent question
21:52:17 <dibblego> quite a lot, how are they similar?
21:52:56 <edmundtse[m]> Hello there
21:53:29 <Cale> :t foldMap
21:53:30 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
21:54:28 <Cale> A Foldable data structure t is one for which if you can specify some way to convert its elements of type a to some monoid m, then it will provide a way to combine its elements using the monoid operation, producing some result of type m
21:54:49 <geekosaur> Monoid means you can combine two (Monoid a => a)s to get a third, somehow. Foldable means you can work your away across a Foldable given a seed value of some unrelated type, to produce a value of that unrelated type
21:55:17 <geekosaur> in particular Monoid does not imply an internal structure, whereas Foldable is specifically about folding across an internal structure
21:55:42 <Cale> and for example, providing the function (\x -> [x]) :: a -> [a]  will get you a function  t a -> [a]
21:56:01 <geekosaur> ...and Foldable lets you do something with the values folded across that isn't just regurgitating another value of the same type
21:56:04 <Cale> That is, there's a way to convert the structure to a list
21:56:22 <tom7942> monoid is a binary associative operation with an identity 
21:57:16 <tom7942> addition and multiplication for example
21:57:55 <Rotaerk> jim___, well, understanding some of the other language fundamentals (types, typeclasses, how evaluation works, etc) would be beneficial in providing context for how and why IO works the way it does
21:57:57 <geekosaur> suppose you could say that in some sense Foldable is a generalization of Monoid in the sense that Monoid must give you the same type back out but Foldable lets you work with some other type... although that doesn't really do Monoid justice
21:58:13 <geekosaur> or Foldable for that matter
21:58:27 <saurabhnanda> isn't foldable a "better" thing to have?
21:58:40 <saurabhnanda> :t foldl
21:58:41 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:58:42 <saurabhnanda> :t mappend
21:58:44 <lambdabot> Monoid a => a -> a -> a
21:59:23 <Rotaerk> you could probably jump into IO straightaway on your first day of haskell... but it wouldn't get you very far on its own
21:59:31 <saurabhnanda> isn't fold a more "explicit" version of a monoid? wherein you get to dictate how two 'a' values get "merged" together?
21:59:33 <geekosaur> saurabhnanda, depends on what you are doing
21:59:58 <geekosaur> integer multiplication is a monoid. you do not want to implement that as a fold :)
21:59:59 <tom7942> saurabhnanda:  with the monoid the combining function is baked into the instance 
22:00:09 <tom7942> rather than explicitly like in fold, yes
22:00:42 <geekosaur> especially if you implement it in terms of addition, and implement the addition monoid as a fold
22:00:59 <tom7942> but you're constraining fold to be a -> a
22:01:02 <tom7942> :t foldr
22:01:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:01:08 <saurabhnanda> so, basically I'm trying to understand what's the deep insight about a Monoid? It's just a pre-defined version of a foldl
22:01:22 <tom7942> it's a -> b -> b 
22:01:36 <Rotaerk> jim___, to demonstrate how easy it actually is to do really basic IO... hello world is just:  main = putStrLn "Hello World!"
22:01:51 <Rotaerk> but it doesn't really help you much without a lot of the groundwork in place already
22:01:58 <geekosaur> saurabhnanda, it's not deep at all. it's a generalized way to describe combining things
22:02:01 <tom7942> no, fold is more polymorphic because it can transform types
22:02:03 <geekosaur> of the same type
22:02:13 <tom7942> monoid only combines like types
22:02:34 <tom7942> but yeah, i'm not sure you can say one is "better" than the other
22:02:50 <geekosaur> it doesn't say *how* you combine them, it just lets you combine them. which lets you do things like chaining comparisons for a multilevel sort, because Ordering is a monoid
22:02:52 <saurabhnanda> I mean, why all this fuss about Monoids when trying to teach people Haskell?
22:03:02 <grantwu> I'm confusd
22:03:05 <grantwu> What fuss
22:03:08 <geekosaur> who fusses about them?
22:03:09 * grantwu peers around
22:03:09 <saurabhnanda> is there any great insight about having a datastructure that is a Monoid?
22:03:10 <tom7942> heh
22:03:22 <geekosaur> many people fuss about Mon*ad*, generally for no good reason
22:03:26 <joe9> type EntryIxs = '[Author, Id, Updated, Test] -- in this , what does the ' do? I found this in Data.IxSet.Typed
22:03:27 <tom7942> yes, the generalized pattern of binary associative operations with identity values
22:03:41 <grantwu> I haven't noticed any particular emphasis on Monoids, however, they are useful because they are a simple to understand example of an algebraic structure
22:03:50 <nshepperd1> Monoid is better because it's associative :>
22:04:02 <Axman6> joe9: gives you a type level list
22:04:23 <joe9> Axman6: ok, Thank.s
22:04:26 <Axman6> needed because [] is ambiguous in the type level (sometimes)
22:04:41 <saurabhnanda> so, basically, can the insight that X can be modelled as a monoid in a typical domain/business application, give me any advantage over saying, here's a bunch of Xs and I want to combine them using this function (foldl)
22:04:49 <nshepperd1> The f and z of a foldr aren't expected to have any special properties
22:05:00 <gfixler> monoids are just pretty useful
22:05:24 <gfixler> we could remove the identity requirement and have a semigroup, and remove associativity and have a magma
22:06:33 <nshepperd1> Associativity is very useful, as it gives you some handy parallel / caching evaluation strategies for free
22:06:39 <Axman6> Monoid (the class) is a fairly gentle introduction to typeclasses in Haskell so is often used to show what typeclasses are with something relatively easy to understand. We do it in the Data61 course before diving into Functor, Applicative etc
22:07:32 <gfixler> monoid comes in at a nice level, because magamas alone don't give anything beyond what operators themselves provide
22:07:45 <geekosaur> yes, to the extent that Monoid is interesting to beginners, it's as an example of a simple typeclass that gives you somewhat surprising expressiveness
22:07:57 <joe9> Which is recommended? IxSet or IxSet-typed?
22:07:58 <gfixler> and semigroups are useful, but folding works better with identities, e.g. when you fold an empty list
22:08:25 <joe9> ixset-typed seems to require more extensions. not sure if the extensions are good or bad.
22:08:58 <Axman6> joe9: what do you actually want to do?
22:09:09 <geekosaur> joe9, moving stuff to type level like that does require lots of extensions. but large classes of errors suddenly become compile time instead of run time
22:09:25 <gfixler> https://upload.wikimedia.org/wikipedia/commons/d/d0/Magma_to_group2.svg
22:09:47 <geekosaur> that said, you have to do a bit more work to use them
22:10:04 <geekosaur> since now you have to be more specific at type level to prove that you are using them correctly
22:10:47 <joe9> Axman6, I am trying to create an IxSet so I can lookup by more than 1 value.
22:11:08 <joe9> geekosaur: ok, Thanks. From what you say, ixset-typed seems a better idea
22:11:20 <gfixler> I think monoids are so talked about—moreso than the other structures—because the requirements for associativity and identity are the same as the requirements for categories
22:11:26 <gfixler> and haskell is steeped in category theory
22:11:43 * Axman6 has never heard of an IxSet before
22:12:26 <joe9> geekosaur: I cannot have a datatype like this http://codepad.org/hQsJxt0H when using an ixset-typed.
22:12:40 <joe9> geekosaur: sorry, ignore that.
22:15:30 <Lokathor> geekosaur, i did the thing you suggested with setting a var in the window resize handler and then checking the var later in the main thread
22:15:36 <Lokathor> it did not seem to make a differences
22:15:39 <Lokathor> difference*
22:15:46 <tnks> I wrote a question up in a gist.  I'd love responses:  https://gist.github.com/shajra/05b8cf62dfe47037256a37a507f085a6
22:15:56 <tnks> here or there is fine.
22:17:05 <geekosaur> Lokathor, I'm not going to argue it any more, if you're happy with the occasional core dump, do it the wrong way
22:17:22 <Lokathor> i thought i was doing it the way you said to do
22:17:43 <EvanR> Lokathor: are you still cursing?
22:17:48 <Lokathor> i'm not trying to argue, i'm genuinely just confused because like three people were talking at once
22:18:06 <Lokathor> EvanR, yes, still trying to get curses to work with inline-c
22:19:12 <geekosaur> when I brought up not calling stuff in the signal handler I said, multiple times, that it was not your current problem because your current problem was trivially reproducible and the problem with calling random stuff in a signal handler will only explode a small fraction of the time
22:19:41 <Lokathor> okay, which is the current problem?
22:19:48 <geekosaur> ...
22:21:03 <geekosaur> suddenly I no longer know if it is safe to say *anything* to you because you will apparently forget what you've been fighting with for several days now
22:22:09 <Lokathor> I mean the problem at first was that it crashed instantly after a window resize, but then after a change it crashed 1 keypress after that, and if you run it through gdb it doesn't crash at all
22:22:25 <EvanR> it sounds like some C-style corruption
22:22:28 <Lokathor> I honestly don't know how signals and stuff work, I never did C things, so I don't know what that means
22:22:58 <coleman> Cale: how can I make a tree containing aforementioned Exprs?
22:23:15 <EvanR> Lokathor: have you heard of undefined behavior? :)
22:23:23 <geekosaur> yes, and I have no idea what is happening there. I was pointing out a further problem that you could have when using a C signal handler, which could also make figuring out your original problem even more complicated.
22:23:51 <Lokathor> EvanR, unfortunately so
22:25:08 <Lokathor> well, then, as i understand your advice, i've eliminated the further problem with the signal handler only
22:25:19 <Lokathor> and am back to not knowing why it crashes without gdb
22:26:07 <geekosaur> unfortunately curses is rather opaque as to what's going on internally, and if running under gdb makes resize problems go away completely then I'm tempted to wonder about bugs in ncurses --- unless the bit about doing things both in Haskell level and (directly, or indirectly via ncurses' own SIGWINCH handler) is confusing it somehow
22:26:30 <geekosaur> (confusing presumably meaning corrupting its internal structures somehow)
22:27:06 <Cale> coleman: A tree of what sort?
22:27:38 <Lokathor> geekosaur, perhaps i would have luck trying with just a termcap library and maintaining my own internal structures and so forth
22:27:54 <gfixler> coleman: the Expr *is* the tree
22:28:06 <geekosaur> I'd have suggested vty-ui instead of curses, really. curses is a PITA no matter what
22:28:21 <coleman> gfixler: I need tow trees: one for the expression and one to contain a "history" of expressions and mutations of those expressions.
22:28:33 <coleman> data Tree a = Nil
22:28:33 <Lokathor> perhaps i am defeated and must use vty
22:28:41 <coleman> | Node a (Tree a) (Tree a)
22:28:45 <gfixler> coleman: that actually just sounds like standard, immutable data structures
22:28:46 <Lokathor> but since vty doesn't just let me paint a character i want to a spot i want, i hate it
22:28:51 <EvanR> coleman: er, are you sure you want a history tree, and not a simple list
22:29:12 <EvanR> of modifications
22:29:14 <coleman> EvanR: I need to apply all the rules to all the Exprs
22:29:27 <coleman> EvanR: keeping track of which rules where applied with what effect
22:29:28 <geekosaur> at this point I'd be making sure the OS was generating core files ("ulimit -c unlimited" and making sure there's nothing like rh/fedora ABRT eating core files) and reproduce it, then point gdb at the core file to find out where it's dying and hopefully what is being corrupted, and hope to work backwards from that to the cause
22:29:52 <coleman> EvanR: each time you finish applying all the rules, you go up a level and apply all the rules agian to the results of the previous applications
22:29:58 <coleman> but I need to "walk back"
22:30:16 <Lokathor> it's a debian box
22:30:51 <gfixler> coleman: have you worked much with immutability before?
22:31:00 <coleman> gfixler: in other languages, lots
22:31:16 <coleman> gfixler: are you sure that's what I'd like here? I've played with Data.Vector.Mutable
22:31:20 <jmorris> How can I make this function work with cases of [(a,(b,c)] and [(a,b)] http://lpaste.net/326485
22:31:38 <gfixler> coleman: well, with immutable structures, changes make copies, sharing any parts possible that don't change
22:31:52 <gfixler> so just saving each new version to a growing list will keep the 'history'
22:32:05 <gfixler> much of it potentially shared, for space efficiency
22:32:14 <gfixler> to apply things to all the history, you can just map something over the list
22:32:20 <coleman> gfixler: but it has to grow exponentially :/
22:32:23 <gfixler> ah
22:32:26 <appinventormu> hello i am new here
22:32:36 <Rarrikins> jmorris: What is the type of the list?
22:32:44 <gfixler> coleman: well, if you *need* all that data, then you have to create and store it regardless
22:32:51 <appinventormu> what is the best way to learn haskell?
22:32:55 <kadoban> jmorris: That last line, that list doesn't make sense. You can't have [("a", ("b", "c")), ("e", "f")], every list element must be the same type.
22:32:56 <gfixler> coleman: if you don't need all of it, then laziness will be very helpful
22:33:09 <jmorris> Rarrinkins: [(String, String)]
22:33:21 <gfixler> coleman: "don't need" e.g. if you just look at parts of it as needed later
22:33:39 <Rarrikins> jmorris: The first element is a different type: (String, (String, String)).
22:33:41 <coleman> gfixler: It will end up with many "wrong" branches and one branch will have the solution as its leaf
22:33:42 <coleman> gfixler: I only need the data of the solution. But I don't know what that is until I get there
22:33:42 <coleman> gfixler: so I have to store all the history in case one of them turns out to be the right solution
22:33:56 <jmorris> kadoban: Is there a way I can get it to work with both types
22:33:57 <jmorris> ?\
22:33:57 <lambdabot> Maybe you meant: v @ ? .
22:34:26 <Rarrikins> jmorris: You have a list with an element of type (String, (String, String)) and an element of type (String, String).
22:34:42 <Rarrikins> jmorris: Lists can only contain elements of the same type.
22:34:48 <gfixler> coleman: well, consider:
22:34:52 <gfixler> > map ('a':) ["foo","bar","baz"] 
22:34:53 <kadoban> jmorris: A list with heterogeneous elements isn't a list, at least in haskell. It's a bit unclear what you want to happen.
22:34:54 <lambdabot>  ["afoo","abar","abaz"]
22:35:15 <gfixler> the first list's elements are reused
22:35:27 <coleman> gfixler: right
22:35:40 <jmorris> Rarrikins: i want to be able to search a list that has some 3 elements and some 2 elements
22:35:43 <gfixler> so you can generate a lot of data, potentially, without creating nearly as much actual new data
22:35:54 <gfixler> depends on the data, of course
22:36:09 <dibblego> jmorris: you on the train?
22:36:26 <jmorris> dibblego no I'm in the car
22:36:34 <gfixler> coleman: something I don't know about is, say, walking a huge structure with a zipper, and garbage-collecting places you've visited
22:36:38 <dibblego> ok
22:36:43 <gfixler> I don't know if there's a way to revert things to thunks :)
22:36:48 <Rarrikins> jmorris: You need to have elements of the same type. One way is to make a type that has two constructors. Something like data Whatsit = Two (String, String) | Three (String, (String, String)).
22:36:54 <coleman> gfixler: thanks for the help, gotta go!
22:37:02 <kadoban> jmorris: Maybe you want [("a", ["b", "c"]), ("d", ["e"])] ?
22:37:15 <gfixler> anyone know if you can unthink a thunk?
22:37:24 <kadoban> It's hard to know what you want it to mean.
22:37:44 <dibblego> jmorris: (String, String, Maybe String)
22:37:48 <gfixler> if I walk around a zipper structure, and determine I don't care about parts of it, can I garbage collect them somehow?
22:38:03 <Axman6> gfixler: as in, not change the thunk pointer to point to the calculated result?
22:38:05 <dibblego> jmorris: I am not home, will be later, to help
22:38:38 <gfixler> Axman6: maybe?
22:38:48 <jmorris> dibblego: ok
22:38:53 <gfixler> e.g. I create some huge, sprawling tree structure of unevaluated thunks
22:39:11 <gfixler> then I walk around it, zipper-style, and down one branch I realize it's a bad path, so I walk back up
22:39:15 <gfixler> but now that path lingers forever
22:39:18 <gfixler> I never want to go back
22:39:34 <gfixler> the more I explore, the more memory I take up
22:39:40 <grantwu> I think you would need to like
22:39:51 <grantwu> Manually prevent yourself from reaching it later
22:40:02 <grantwu> but hrm, you can't really do that
22:40:06 <Axman6> well the structure will still be pointing to it
22:40:23 <joe9> EvanR: Can I use IxSet.size + 1 to generate new Id's for an item in the IxSet ?
22:40:25 <gfixler> I almost want to copy the thunk, evaluate it, and it it works out, point the actual zipper's pointer at it
22:40:56 <gfixler> hmmm
22:40:56 <EvanR> joe9: as long as you never delete
22:41:10 <gfixler> I suppose the zipper could just let go of anything beneath you
22:41:19 <gfixler> and redecide how to make it on the next descenet
22:41:22 <joe9> EvanR: very good point.
22:41:23 <gfixler> descent*
22:41:41 <EvanR> joe9: instead, for all your unique Id needs, you can have a global counter
22:42:02 <joe9> EvanR, I need 2 different Id's, so 2 global counters?
22:42:13 <EvanR> if they are internally Ints, i wouldnt bother
22:42:20 <appinventormu> any haskell resources for beginners?
22:42:39 <joe9> EvanR: yes, they are Int's. So, just use 1 for both?
22:42:48 <EvanR> thats what i would do
22:42:54 <joe9> ok, Thanks.
22:43:04 <EvanR> youre not supposed to use them for anything but identification so shouldnt matter
22:43:17 <gfixler> appinventormu: https://github.com/bitemyapp/learnhaskell
22:43:25 <joe9> EvanR: ok, Thank.s
22:43:27 <gfixler> appinventormu: that's a good list of starting resources
22:43:31 <appinventormu> thanks
22:43:49 <appinventormu> just a hint of the level of diff of haskell
22:44:37 <Axman6> if you mean difficulty, then probably higher than the average programming language
22:45:29 <appinventormu> i know java c++ c python so is it like c++?
22:45:38 <grantwu> No
22:46:00 <joe9> EvanR: it just seems messy to use Id's (global counter, etc.). wish there was a data structure that could do this automatically.
22:46:14 <kadoban> appinventormu: It's different from those languages, though personally I wouldn't say it's intrinsicly hard. Just different.
22:46:23 <joe9> an insert generates a unique id, etc.
22:46:27 <grantwu> Java, C++, C, and Python are all flavors of imperative languages
22:46:50 <appinventormu> ok else haskell is highly recommended because of strong pattern recognition
22:47:07 <appinventormu> that's why i wanted to learn it
22:47:23 <grantwu> What do you mean by strong pattern recognition?  Are you referring to pattern matching?
22:47:49 <appinventormu> yes if you want to create your own interpreted language this is useful
22:48:01 <Axman6> appinventormu: I think it would be a good idea to go and do some research
22:48:26 <Axman6> just to find out a bit more about what haskell is and what it's used for
22:48:33 <appinventormu> ok and sorry for interruption
22:49:02 <kadoban> Research why? Most of the answers you get to that question without knowing anything about the lanugage are ... close to useless. Just start learning and see what you think.
22:49:32 <appinventormu> ok i came across haskell through recommendation. seems respected enough but thanks!
22:50:02 <grantwu> Pattern matching is generally useful, yes, including in interpreters
22:50:20 <grantwu> Anything that deals with lots of symbolic manipulation loves pattern matching
22:51:31 <appinventormu> sorry i think i missed channel i should've start at #haskell-beginners
22:52:57 <kadoban> appinventormu: This channel is fine for beginners as well
22:53:00 <grantwu> There are beginners in here as well
22:55:01 <appinventormu> saw this channel on the wiki but on the github link saw the beginner one. Thanks for help. see you soon
22:55:16 <lgstate> ar eclojure transducers bsically three functions mashed into one?
22:55:51 <Axman6> they're basically folds iirc
22:56:05 <Axman6> they're not particularly interesting at all really
22:57:11 <lgstate> actually, they are, but due to a deficienty of clojure
22:57:12 <Axman6> http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/ gives a pretty good overview of them
22:57:18 <lgstate> yesterday, I was just implementing monads in clojure
22:57:26 <lgstate> and I realized: bind creates a new stack frame
22:57:40 <lgstate> so in languages like clojure, monads are a problem
22:57:53 <lgstate> and thus people's preferrnce to use redue / transducers
23:02:34 <Lokathor> alright
23:02:39 <Lokathor> i give up i guess
23:02:53 <Lokathor> i will switch to vty, or double down on insanity and use terminfo directly
23:03:20 <MarcelineVQ> blit fontmaps to a quad
23:03:48 <Lokathor> installing SDL on windows is much nightmare
23:03:52 <Axman6> kids these days and their lingo
23:07:13 <Lokathor> if only cmd.exe had a terminfo
23:09:15 * hackagebot oidc-client 0.3.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.3.0.0 (ShoKuroda)
23:13:32 <Axman6> lgstate: https://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/ might also be interesting, lots of good discussion in there
23:28:26 <benzrf> is there any nice data type for algebraic numbers
23:28:46 <benzrf> so that i can losslessly do (sqrt 2)**2
23:32:10 <joe9> The IxSet does not have a filter function. Data.List.filter . IxSet.toList seems inefficient. Any other options?
23:35:44 <EvanR> joe9: searching the IxSet is a filter
23:37:06 <EvanR> joe9: oh... you want to apply a Bool function to everything in the set
23:37:53 <EvanR> rebuilding the whole set would be faster than going through the records one by one and messing with indexes
23:37:59 <joe9> EvanR: yes. a bool function
23:38:20 <EvanR> alternatively you put the filterable condition into the data and make an index for it
23:38:35 <joe9> EvanR http://codepad.org/2qSsZU0e is my context
23:38:51 <joe9> I want to read all children in a directory
23:39:07 <EvanR> path should be indexed
23:39:16 <joe9> http://codepad.org/wrC2vusr yes, the path is indexed
23:39:34 <joe9> I have the absolute path + name indexed
23:39:36 <EvanR> what are you filtering by
23:39:59 <joe9>         (fmap (dStat . fDetails) . filter (belongsToDir (traceShowId dirname))) . IxSet.toList fsItems
23:40:05 <joe9> is my filter condition.
23:40:15 <EvanR> belongsToDir is?
23:40:38 <joe9> EvanR: http://codepad.org/wCB2uuQw
23:40:48 <EvanR> if the path is indexed, then using that index is the filter you want
23:40:49 <joe9> EvanR:  just a minute, the definition is a bit wrong
23:41:07 <joe9> oh, ok. So, I can add another field call AbsolutePath
23:41:10 <joe9> and then use that.
23:41:19 <EvanR> yes
23:41:21 <joe9> EvanR: Would that be better than filter . toList
23:41:30 <EvanR> yes, thats the point of indexed sets
23:42:25 <EvanR> when you apply a give path, it looks up 1 thing in 1 index Map
23:42:28 <EvanR> given*
23:42:30 <joe9> EvanR: I have only function that uses this functionality (filter)
23:42:36 <EvanR> instead of filtering the entire set
23:42:53 <EvanR> well, true, you may be prematurely optimizing
23:43:03 <joe9> I am wondering if it is worth the effort to have an index for one filter.
23:43:18 <EvanR> the effort is one thing, but another thing is memory usage
23:43:21 <joe9> yes, so will leave it as a filter then and bother with it later.
23:43:29 <EvanR> more indexes means more memory
23:43:36 <joe9> ok, Thank.s
23:44:18 <EvanR> more indexes also means more work during insert and delete
23:44:32 <joe9> EvanR: yes, agreed.
23:49:54 <seafood> What do people think the best string interpolation library is for Haskell?
23:50:13 <EvanR> probably (++)
23:50:34 <EvanR> or (<>) for Text
23:51:37 <jle`> i use Text.Printf from base for basic interpolation
23:51:44 <grantwu> There's bytestring builders
23:58:57 <jle`> wao hmatrix 1.18 out finally after over a year of accumulating unpublished improvements
23:59:00 <jle`> nice
