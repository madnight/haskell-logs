00:07:42 * hackagebot tianbar 1.2.0.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.2.0.0 (AlexeyKotlyarov)
00:07:42 * hackagebot stt 0.1.0.0 - A monad transformer version of the ST monad  https://hackage.haskell.org/package/stt-0.1.0.0 (mckeankylej)
00:29:42 <sam___> I want to write the length function using lambda expression and by not defining the arguments.I did the following: lengthLambda = foldr (\_ x -> 1 + x) 0   .However, I'm getting  ambiguous type error from foldr use.
00:56:07 <manyone> join haskell-beginners
00:56:19 <manyone> join #haskell-beginners
01:06:00 <sam___> Hello, can anyone help me to write length function uisnf
01:06:51 <sam___>  Hello, can anyone help me to write length function using lambda expression? I did the following:lengthLambda = foldr (\_ x -> 1 + x) 0 
01:08:52 <Maxdamantus> sam___: so what's wrong with it?
01:09:14 <dmj`> @def len' = foldr (\_ x -> x + 1) 0
01:09:17 <lambdabot>  Defined.
01:09:23 <dmj`> > len' [1::Int]
01:09:26 <lambdabot>  1
01:09:45 <sam___> Maxdamantus: I'm getting it's ambiguous error
01:10:57 <sam___> @def lengthLambda = foldr (\_ x -> 1 + x) 0   
01:10:59 <lambdabot>  Defined.
01:11:13 <sam___> lengthLambda "apple"
01:11:14 <Maxdamantus> It might be subject to the monomorphism restriction. Can never remember exactly the rules for that.
01:11:25 <dmj`> > lengthLambda "apple"
01:11:27 <lambdabot>  5
01:11:32 <Maxdamantus> in that case, you'd probably just add a type signature.
01:11:42 <sam___> > lengthLambda "apple"
01:11:44 <lambdabot>  5
01:11:57 <sam___> > lengthLambda [3,5..20]
01:12:00 <lambdabot>  9
01:12:05 <sam___> What???
01:12:15 <sam___> Why am I getting error then?
01:13:04 <dmj`> @def lank = foldr (\x _ -> x + 1) 0
01:13:06 <lambdabot>  Defined.
01:13:12 <dmj`> > lank [3,5..20]
01:13:14 <Maxdamantus> Hm, no, seems to work for me.
01:13:16 <lambdabot>  4
01:14:30 <dmj`> lengthLambda is correct
01:14:36 <dmj`> sam___: can you show us your code
01:14:44 <dmj`> @where paste
01:14:44 <lambdabot> Haskell pastebin: http://lpaste.net/
01:15:20 <sam___> dmj`: http://pastebin.com/H00it9UC
01:16:29 <sam___> dmj`: code is the same.This is error message:http://pastebin.com/H00it9UC
01:17:06 <dmj`> sam___: can you show us the definition as well, along with the error message, have you supplied a type signature?
01:17:26 <Maxdamantus> Ah, so I suspect it's the monomorphism restriction.
01:17:31 * Maxdamantus has an old version of GHC.
01:17:37 <sam___> dmj`: no I did not supply a type signiture. 
01:34:40 <definedwheel> So, I got my hands on AD, and fisrt thing I did was `diff (\x -> (sin x) / x) 0`, but it showed NaN. What did I do wrong?
01:37:44 <lyxia> def
01:38:16 <Vyn> definedwheel: What's that supposed to compute?
01:39:11 <lyxia> definedwheel: that function is technically not defined at 0
01:40:54 <definedwheel> Isn't the derivative of sin x / x equal to 1? I'm just testing what I've been told in the college.
01:41:00 <lyxia> it can be extended by continuity but ad is simply not powerful enough for that 
01:44:08 <pavonia> Is there a way to limit the number of errors reported by GHC for a module?
01:45:34 <lyxia> definedwheel: the limit of sin x/x at 0 is 1,  this fact then allows you to extend the domain of the function in a continuous way. 
01:51:37 <lyxia> definedwheel: there are hoops you must go through to not divide by zero, and ad does not implement such hoops. 
01:52:30 <definedwheel> lyxia: I plugged my function to reduction from simple-reflect, and there are infinities everywhere
01:52:53 <definedwheel> lyxia: What kinds of hoops?
01:53:22 <lyxia> the extension by continuity I was talking about 
01:53:54 <definedwheel> lyxia: Can this be done in haskell?
01:55:10 <lyxia> It's not really a matter of programming language. 
01:57:57 <lyxia> I mean haskell is as powerful as any other Turing complete language 
02:00:18 <lyxia> definedwheel: you can do it in this case by tracking derivatives, so that when you divide sin x by x, you can see it becomes 0/0 so you can apply l'hospital's rule. 
02:02:55 <definedwheel> lyxia: I'm just thinking about these hoops in general. Isn't your suggestion a symbolic manipulation?
02:07:44 * hackagebot Cabal 1.24.1.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.24.1.0 (ryant)
02:07:44 <lyxia> definedwheel: I don't think so because you must evaluate subexpressions and also compare them to zero which can be imprecise. 
02:09:48 <definedwheel> lyxia: Its a mix =)
02:10:04 <definedwheel> lyxia: Ok, I got what I wanted, thank you
02:10:12 <lyxia> yw 
02:19:46 <coleman> most efficient integer check?
02:27:45 * hackagebot cabal-install 1.24.0.1 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.24.0.1 (ryant)
02:40:03 <a6a3uh> Hi! Learned hsakell for a while but still can't get to something practical. Here is my practical task. I have a json that descrives a format of some binary file. I want to parse that binary according to that json. I easily came up with some python code. But haskell made me stuck. How for example I can get som functor to map other a depple nested JSON data? How can I get a foldable for that?
02:42:09 <a6a3uh> I mean data in json is either dictionary or a list (in python terms) or some endpoint (leaves). So data I get from Json is deeply nested. and I want to map other the leavse or fold them etc
03:03:54 <M0b10s> good morning =)
03:05:47 <bollu> morning
03:05:51 <a6a3uh> Good morning!
03:17:48 <wlemuel> morning
03:19:02 <NickHu> a6a3uh: Use the aeson package
03:21:07 <a6a3uh> I've tried aeson. It gives me some representation of json that is not a functor nor foldable
03:29:31 <cocreature> a6a3uh: what exactly are you trying to do? functor & foldable only make sense for polymorphic types and json is by definition not polymorphic
03:30:47 <a6a3uh> I want to map over all the endpoints or flatten all the structure. thats what I did in python for solving task.
03:31:09 <a6a3uh> by endp[oints I mean all the strings or nums not lists or associative lists
03:31:45 <a6a3uh> I'm looking for ost haskellish way of doing that with less code possible
03:32:11 <Taneb> a6a3uh, you can use lens and lens-aeson
03:32:42 <a6a3uh> wow... lens was out of my scope so far...( I've not learned them yet.
03:33:38 <a6a3uh> maybe thats the problem with haskell. to do simple things it is not enougth to know functors applicatives, monads, transformers etc. there are an order of magnitude more stuff you should learn to start doing something practical :)
03:33:57 <cocreature> a6a3uh: you can just write a simple recursive function that does what you want
03:34:19 <maerwald> a6a3uh: or you don't follow the hype train and only use stuff you actually need
03:34:45 <cocreature> just recurse on value and put thet hings you are interested in in a list
03:36:52 <a6a3uh> I see.. I was thinking of some "haskelish" way of dealing with task. to map some function over all the endpoints of flatten it and calculate some cumulative stuff over list. Now I will do almost the same I did in python by hands)
03:38:47 <Taneb> a6a3uh, yeah, lens is great for optimizing for "least code", not too great for "ease of understanding"
03:41:21 <a6a3uh> what I did in python is a generator that iterates recursively all the json in depth and it receives a function as an input that acts like a map changing some fields of jsons data while iterating tham. And taking a list from generator flattens it as well. Doing the same in haskell not shows its benefits. Maybe I have to learn lenses a bit.
03:41:42 <cocreature> you can also use "universe" from uniplate to get a list of all subtrees and then simply filter to the primitive values
03:43:20 <a6a3uh> thanks I'll look at that too
03:44:23 <cocreature> e.g. [x | Number x <-  universe ((fromJust $ decode "{\"a\": 1, \"b\" : 2}") :: Value)] would give you [1.0,2.0]
03:44:55 <a6a3uh> Nice! at least flatten is easy)
03:45:51 <a6a3uh> still need to find easy mapping)
03:46:04 <cocreature> mapping from what to what?
03:47:30 <cocreature> you might also want to consider creating a separate adt that only contains the primitive values to make sure that after your operation you have really thrown away all objects and arrays
03:47:58 <cocreature> simple adts to ensure invariants and functions mapping between them go a long way in haskell
03:48:36 <a6a3uh> mapping to subsitute each endtype string with value parsed from binary according to that endtype string
03:57:50 * hackagebot STMonadTrans 0.3.4 - A monad transformer version of the ST monad  https://hackage.haskell.org/package/STMonadTrans-0.3.4 (JosefSvenningsson)
04:03:57 <bollu> is it possible to have a noncommutative semigroup (S, <>) equipped with a partial order <= such that a <= a <> b?
04:04:01 <bollu> I'm looking for existence
04:10:43 <volhovm> Hello everyone! My `stack ghci project:bench:benchmark-name` fails to run ghci if benchmark code is broken.
04:11:34 <volhovm> Like, it compiles library, executables, then starts compiling benchmark, fails. Prints "build failed, but optimistically launching GHCi anyway" and then says that "cannot satisfy library".
04:13:10 <volhovm> http://pastebin.com/6izzV2hd
04:13:34 <icosane> volhovm: I don't use stack, but it seems like stack only succeeds if the benchmarks work
04:14:13 <volhovm> Well, i can't believe it's made to be like this by design :)
04:15:33 <icosane> volhovm: I think that it intended behaviour
04:15:33 <icosane> s/that it/it is
04:15:52 <volhovm> Hm, then how should i fix benchmarks? 
04:15:56 <volhovm> How am i supposed to do se
04:15:58 <volhovm> so*
04:16:18 <volhovm> like, the code is broken -- i'd like to launch stack ghci from haskell-interactive mode
04:16:45 <volhovm> By the way this behavior is also similar on test targets, but not on executables!
04:24:56 <Stuart> Hello
04:26:29 <bollu> Stuart: hey
04:26:56 <Stuart> Hi bollo
04:27:14 <Stuart> I trying to understand haskell syntax
04:27:22 <joncol> Is there any way to write the /function/ (-1) :: Num a => a -> a, without the explicit type?
04:27:53 <bollu> Stuart: go on
04:28:06 <Stuart> Its to do with tuples
04:28:33 <Stuart> First function foo1 :: Int -> (Int, Int), foo1 n = (n, x * 2)	
04:28:52 <Stuart> Secnond Function foo2 :: Int -> (Int, Int), foo2 n : (n, n * 2)
04:29:04 <jle`> joncol: what function are you trying to write?
04:29:12 <pavonia> joncol: There's pred
04:29:15 <jle`> joncol: \x -> x - 1 ?
04:29:21 <joncol> \n -> n - 1
04:29:26 <jle`> joncol: use 'subtract' instead of -
04:29:29 <jle`> > (subtract 1) 10
04:29:32 <lambdabot>  9
04:29:41 <joncol> jle`: thanks
04:29:43 <joncol> > pred 10
04:29:44 <jle`> btw, `(-1) :: Num a => a -> a` doesn't do what you think it does
04:29:45 <lambdabot>  9
04:29:52 <joncol> Ah pavonia: nice
04:29:55 <Stuart> I want to write a third function that gets the second result from foo1 and passes it to function 2
04:29:58 <jle`> > ((-1) :: Num a => a -> a) 3
04:30:01 <lambdabot>  error:
04:30:01 <lambdabot>      • Could not deduce (Num (a1 -> a1))
04:30:01 <lambdabot>          arising from a use of syntactic negation
04:30:12 <jle`> > let f = subtract 10 in f 100
04:30:14 <lambdabot>  90
04:30:41 <joncol> jle`: Why is that?
04:30:43 <jle`> joncol: (-x) isn't parsed in haskell as an operator section
04:30:48 <jle`> it's unary negation
04:30:50 <jle`> > -10
04:30:52 <lambdabot>  -10
04:31:01 <jle`> (-1) represents the number "negative one"
04:31:14 <jle`> not a section w/ the subtraction operator
04:31:22 <joncol> Yes, that I understood. But I thought I could "cast" it with the type.
04:31:26 <jle`> cast it...to what?
04:31:34 <jle`> how can you cast -1 to a function?
04:31:38 <joncol> Compare (+1)
04:31:43 <jle`> what function would you expect "negative one" to cast to?
04:31:50 <jle`> there is no casting in haskell :)
04:31:56 <joncol> > (+1) 10
04:31:58 <lambdabot>  11
04:32:03 <jle`>  (+ 1) is parsed differently
04:32:07 <jle`> it's not parsed as "positive one"
04:32:12 <jle`> it's never parsed as positive one in any context
04:32:19 <Stuart> I know how to do it. Doop
04:32:30 <joncol> Crap language ;)
04:32:31 <jle`> so (+1) is always going to be (\x -> x + 1), in every context
04:32:42 <jle`> unambiguous language :)
04:32:52 * hackagebot ngx-export 0.2.4.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.4.0 (lyokha)
04:32:56 <jle`> (+1) will never parse as positive one
04:33:17 <jle`> (-1) will always parse as negative 1.  it's a little annoying that - is special-cased in haskell, though.
04:33:38 <volhovm> It appeared that passing `--bench` flag does the trick
04:33:38 <joncol> jle`: Yes, I see. Thanks
04:33:39 <jle`> but yeah, also, haskell doens't have "casting" like you're talking about
04:33:47 <joncol> Yes I know
04:33:49 <jle`> you can't make something into another type magically just by giving it a type annotation :)
04:33:54 <volhovm> so `stack ghci :benchname` doesn't work, `stack ghci --bench :benchname` does.
04:33:59 <jle`> > True :: Num a => a -> a
04:34:02 <lambdabot>  error:
04:34:02 <lambdabot>      • Couldn't match expected type ‘a1 -> a1’ with actual type ‘Bool’
04:34:02 <lambdabot>      • In the expression: True :: Num a => a -> a
04:34:21 <jle`> like...what function would the number -1 even be "cast" to...?
04:34:30 <joncol> You're right
04:40:29 <Stuart> Ok with state monad
04:41:15 <Stuart> I trying to write State monad
04:41:33 <Stuart> fmap :: (a -> b) -> Moi s a -> Moi s b
04:42:45 <Stuart> Moi s a = (s -> (s, a)) and ( Moi s b) = (s -> (s, b))
04:43:37 <Stuart> Is doesn't seem to enough info
04:45:01 <Stuart> Does anyone have ideas regarding the state monad?
04:48:12 <ongy> > 1 - - 1
04:48:14 <lambdabot>  error:
04:48:14 <lambdabot>      Precedence parsing error
04:48:14 <lambdabot>          cannot mix ‘-’ [infixl 6] and prefix `-' [infixl 6] in the same infi...
04:49:17 <Stuart> I think I figured it out
05:05:59 <bonnie> hey  iam a beginner of haskell, can anyone help me? i can't open the file .hs in terminal (on mac) it says: <no location info>: error: can't find file:  ... I really am desperate...
05:06:26 <hpc> what is the file you are trying to open?
05:06:49 <bonnie> it is a .hs file
05:07:03 <Monoide> are you sure you are in the right folder ?
05:07:19 <hpc> i mean what's the filename, and what happens if you run "ls <the same filename>"?
05:07:51 <bonnie> should i be in a folder? im really hardcore beginner sorry
05:08:17 <bonnie> in the terminal? i mean im trying to load my file 
05:08:31 <hpc> let's start with pasting the whole error you are getting
05:08:32 <hpc> @lpaste
05:08:32 <lambdabot> Haskell pastebin: http://lpaste.net/
05:08:43 <hpc> and go from there
05:08:46 <bonnie> ok wait i ll do this now
05:09:01 <maerwald> bonnie: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#loading-source-files
05:11:24 <bonnie> Monoide_: what did you mean with the right folder?
05:12:54 * hackagebot cplex-hs 0.5.0.2 - high-level CPLEX interface  https://hackage.haskell.org/package/cplex-hs-0.5.0.2 (stefanjhlk)
05:22:04 <hpc> bonnie: in the future, when you use lpaste set the channel to #haskell or paste a link here, lpaste gets a lot of spam so they can get buried
05:22:07 <hpc> http://lpaste.net/329248
05:22:51 <hpc> bonnie: so when you run ghci, are you doing it from the same directory that contains beginning.hs?
05:23:50 <zennist> hey guys - I'm considering building a new PC; just want to know how much added benefit on ghc compilation is there for more cores?
05:24:48 <zennist> I can either get a 4 core or 6 core; there are plenty of benchmark on the effect of video encoding/decoding; but I don't think there's much for compilation (especially for ghc)
05:25:00 <hpc> zennist: cabal has a -j flag, so for projects that are structured to not be tremendously linear you get some nice benefit
05:25:33 <zennist> i see - is ghc itself parallel in nature?
05:26:23 <hpc> ghc also has the -j flag, but it won't automatically do it
05:26:53 <hvr> zennist: see cabal's parallelism at work e.g. here: https://github.com/haskell/cabal/issues/4040#issuecomment-257081098
05:35:01 <ggVGc> is there any library with an abstraction over long polling as channels or something similar for haskell?
05:38:19 <cocreature> ggVGc: there is https://hackage.haskell.org/package/socket-io but I’m not sure if that is what you’re looking for
05:38:57 <ggVGc> hm, maybe
05:38:59 <ggVGc> I'll give it a go
05:39:01 <ggVGc> thanks
06:03:18 <ph88> instance Foo Bar where   type Baz Bar =    what's this type in instance ?
06:06:01 <hvr> ph88: it's an associated type alias
06:06:59 <hvr> ph88: c.f. https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example
06:08:03 <ph88> thx
06:10:05 <ph88> hvr, "functions on types are really represented by functions and not relations"  can i use this to match on a type ?
06:19:07 <pilne> how large of a headache am I setting myself up for if i'd like to use Stack/GHC to develop a relatively simple cross-platform GUI app that does parsing and data visualization?
06:21:37 <hpc> the hardest part of that is "cross-platform GUI"
06:22:10 <ph88> pilne, if you don't mind using some web technologies https://codetalk.io/posts/2016-05-11-using-electron-with-haskell.html
06:22:59 <hpc> if you really feel up for some shennanigans, you can write the data crunching in local machine haskell, and then the visualizer in ghcjs
06:23:31 <hpc> maybe have the end of the data cruncher call xstart or whatever to launch the visualizer for you
06:24:07 <hpc> it's the kind of hack you only see in bash scripts, but then you aren't dealing with any UI toolkits
06:24:11 <hpc> which is convenient in any language
06:26:00 <hpc> also, stack makes it significantly easier to install gtk and such on windows, if you do end up going that route
06:26:18 <bollu> hpc: what is the best GTK / QT framework in haskell?
06:27:16 <maerwald> bollu: none, just the bindings
06:27:43 <hpc> https://github.com/gtk2hs/gtk2hs
06:28:25 <bollu> maerwald: lol
06:28:29 <maerwald> ?
06:28:40 <hpc> you can also try wx, which is another toolkit with bindings on hackage
06:29:03 <hpc> i haven't used either enough to say which is better
06:29:04 <bollu> maerwald: nothing, I was wondering if there was a higher level API that was more haskell-y :)
06:29:07 <pilne> awesome! i tried for a while to use electron with javascript, but javascript hurts my brain a bit, i really do find confidence and comfort in the GHC compiler being so strict
06:29:11 <maerwald> bollu: exactly, there is none
06:30:11 <hpc> someday there might be, once it becomes a common enough thing for people to write GUIs in haskell
06:30:35 <hpc> but that's generally going away with web frameworks anyway
06:30:39 <hpc> (for better or worse)
06:30:43 <maerwald> I doubt it will ever penetrate the desktop area
06:30:57 <maerwald> rust is more likely to do so
06:31:54 <hpc> i expect it to become even more fragmented
06:32:05 <hpc> with more .net and more cocoa or whatever osx uses
06:32:08 <hpc> and less cross-platform
06:32:10 <Rembane> I want to have some reasonable API for GUIs.
06:32:18 <Rembane> Regardless of language.
06:32:28 <ongy> first I want reasonable guis
06:32:35 <hpc> i want a pony
06:32:39 <maerwald> xD
06:33:13 <Rembane> I think the pony is the easiest thing to get.
06:35:47 <cocreature> does the pony language have good gui frameworks?
06:35:53 <obiwahn> hi is there some channel dedicated to cabal?
06:36:28 <maerwald> the thing is, gui frameworks are mostly object-oriented (even gtk+) and using that paradigm is rather intuitive in the gui-area
06:37:05 <cocreature> obiwahn: a lot of cabal devs hang around in #hackage, but I think there is also #cabal
06:44:09 <obiwahn> cocreature: how did you learn to use cabal?
06:44:36 <cocreature> obiwahn: reading the docs and asking/searching around if I couldn’t figure something out :)
06:46:15 <ertesx> i'd use reactive-banana with most GUI toolkits
06:46:18 <Squarism> is scotty recommended to create a production ready website with session support and all?
06:47:12 <ertesx> Squarism: make a list of what you need, then compare it to what is available for scotty
06:47:50 <ertesx> e.g. sessions, form handling, Accept support, etc.
06:48:01 <ertesx> … i18n, …
06:49:05 <ertesx> if you want to be safe, go with one of the Old Ones, i.e. happstack, snap or yesod
06:49:51 <Squarism> oh ok
06:50:12 <Squarism> ertesx, btw. Your hangman has mutated into : http://imgur.com/a/1wK1T
06:50:33 <ertesx> woah =)
06:50:37 <cocreature> that doesn’t look like hangman :)
06:50:56 <obiwahn> cocreature: So I would like to read something that describes how to handle different versions. I had xmonad 0.11 and 0.12 installed. But the excutable in .cabal/bin was still 0.11. So i tried something like reinstall, then force that told me i would break stuff. and in the end I deleted my local .ghc and .cabal directory and build everything from the start. now i would like to use the git version of xmonad.
06:50:57 <obiwahn> I think it is wrong to delete the directories all the time. So how do i switch the versions used in .cabal/bin
06:51:06 <Squarism> both are "games" though
06:51:07 <ertesx> i'm pretty sure there is a homomorphism somewhere from hangman games to this
06:51:25 <cocreature> obiwahn: I just use sandboxes for everything (or cabal new-build)
06:51:39 <ertesx> Squarism: is that a turn-based strategy game?
06:51:49 <Squarism> ertesx, yep
06:51:58 <obiwahn> cocreature: sandboxes are something like pythons virtualenv?
06:52:09 <ertesx> cool!  if that's online and open source, i'll definitely give it a try =)
06:52:37 <cocreature> obiwahn: yeah
06:52:59 * hackagebot rei 0.4.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.4.0 (kerkomen)
06:53:08 <Squarism> ertesx, im negotiating with the publisher of the original boardgame on publishing it (when its done). Will surely tell you when its finished.
06:53:40 <ertesx> Squarism: ah, you're doing this commercially?
06:54:16 <Squarism> ertesx, nope.. its free. But i need the board game publishers OK to use their "IP" so to speak
06:55:30 <ertesx> i see
06:57:16 <obiwahn> The sandbox approach really looks like a solution to some of my pain.
06:57:49 <NaOH> Hi there, a question: If I have a Data.Vector.Unboxed vector of Double(s), and then construct a tree containing data from that vector, will the tree copy the data or store a pointer to the Double in the vector? (currently I'm using a tree of Indices and using that to index into the vector, but that means that I have to pass arround the vector a lot, I want to know if I use a Double into the tree, what exactly will happen)
06:58:38 <ertesx> NaOH: unless you specifically construct the tree to point into that vector (you will know when you have done that), it will copy the values
07:00:41 <ertesx> NaOH: but pay attention to the strictness of your data structure:  if it's non-strict and you use (vec ! i), then it will initially store that expression (which is not a pointer) rather than the resulting value
07:03:00 * hackagebot multifile 0.1.0.4 - create many files from one  https://hackage.haskell.org/package/multifile-0.1.0.4 (AlanHawkins)
07:03:00 <NaOH_> ertesx: so if I don't want to duplicate data, I should do what I'm doing and store Int(s) in the tree, and use that to index into the vector?
07:03:02 * hackagebot rei 0.4.0.1 - Process lists easily  https://hackage.haskell.org/package/rei-0.4.0.1 (kerkomen)
07:03:33 <ertesx> NaOH_: well, Int on modern platforms is 64 bits, and so is Double
07:04:41 <ertesx> NaOH_: in case you didn't receive this: NaOH: but pay attention to the strictness of your data structure:  if it's non-strict and you use (vec ! i), then it will initially store that expression (which is not a pointer) rather than the resulting value
07:05:05 <ertesx> in general i suggest not to reinvent sharing (haskell does that for you, if you ask it to)
07:06:59 <ertesx> NaOH_: are you trying to implement binary search or something like that?
07:07:40 <NaOH_> ertesx: (thanks, yeah, my computer rebooted due to a power failure) So it would be wise to just use a tree of Double(s) (strict) and let haskell do it's thing, more so given that storing Int(s) would take the same ammount of memory
07:08:07 <NaOH_> ertesx: Yes, I'm building a binary search tree
07:08:51 <ertesx> NaOH_: using a ADT-based binary search tree would ruin most of the advantages of an unboxed vector anyway…  if you want to preserve it, you should sort the vector and search directly in it instead
07:09:44 <ertesx> NaOH_: in fact the 'vector-algorithms' library has everything you need
07:12:06 <heebo> how does one get stack to return the path to ghc?
07:12:44 <cocreature> heebo: run "stack path"
07:12:49 <cocreature> and look at compiler-exe
07:13:12 <NaOH_> ertesx: Yes you are right, the tree is not constructed in a straightforward way, though, it's not just the values sorted. However, you are right, you made me realize that I should really thing about how I'm using the vector, to see if it makes any sense in the first place to have it there (I'm using it's data in other structures beyond the tree)
07:14:08 <NaOH_> ertesx: thanks for your help! I'm going to try and think a little bit deeper into what I'm doing (I'm rewriting some code, where originally all I had were Int(s) referencing into the vector in diferent data structures)
07:14:20 <ertesx> NaOH_: if it doesn't, the containers and unordered-containers libraries probably have a ready-made and carefully optimised implementation of what you need
07:14:51 <ertesx> NaOH_: mostly binary trees and radix trees
07:17:59 <NaOH_> ertesx: I'm going to check if there is something appropiate there before rewriting, thanks!
07:21:37 <ertesx> NaOH_: keep in mind that an unboxed vector together with a binary tree of indices is equivalent to a vector sorted in a certain way
07:22:32 <ertesx> the question is whether you need to change that tree, which is efficient on trees (immutable update), but horribly inefficient on vectors (resorting)
07:23:17 <onintza> How could I fold a traversable using <*>?
07:23:31 <onintza> A traversable of applicatives, that is
07:23:50 <ertesx> onintza: like 'traverse' or 'sequenceA'?
07:23:54 <ertesx> :t sequenceA
07:23:56 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
07:27:41 <onintza> I need to understand what exactly I'm trying to do
07:28:00 * hackagebot Win32 2.4.0.0 - A binding to part of the Win32 library  https://hackage.haskell.org/package/Win32-2.4.0.0 (TamarChristina)
07:35:12 <joncol> I'm working on an exercise in the HPFFP book, chapter 26. The problem is one where you get a non-working Scotty skeleton which you are supposed to fix. I'm just wondering why I cannot `lift (putStrLn "hello, world")` inside my `app :: ScottyT Text (ReaderT Config IO)` function. It works when having `lift . lift $ putStrLn "..."`, but shouldn't there already be a `lift` defined for the stack, so I don't 
07:35:18 <joncol> have to repeat it like this??
07:35:30 <obiwahn> cocreature: http://paste.debian.net/892716/
07:35:37 <obiwahn> does this look about right?
07:35:49 <paolino> how is a way to resolve undecidable for a class CanParse a where canParse ::Text -> Maybe a and an instance Read a => CanParse a where -- use read ?
07:37:31 <cocreature> obiwahn: given that you are probably not developing xmonad or xmonad-contrib but only using a released version you can just install them into your sandbox rather than adding the sources
07:37:50 <obiwahn> how would i do that?
07:38:05 <obiwahn> cabal install /path/to/source in the sandbox?
07:38:09 <cocreature> run "cabal install xmonad" in the directory where the sandbox file lives
07:40:31 <Darwin226> Hey guys, does this look like a bug to you? http://lpaste.net/329326
07:40:39 <Darwin226> When I compile this I get a warning
07:40:45 <Darwin226> not used 'fromInt'
07:41:41 <paolino> I'd like to avoid undecidable here https://kobra.io/#/e/-KVov_AmDHS5eefQWaJe
07:43:20 <cocreature> Darwin226: looks like a bug to me
07:44:19 <cocreature> paolino: you can’t. "Read a => CanParse a" is not decidable because the constraint does not get smaller
07:45:06 <paolino> cocreature, so my question is how should I model that ?
07:46:25 <paolino> tagging the 'a' like instance Read a => CanParse (NotText a) ?
07:48:55 <cocreature> yeah, or just don’t make such a generic instance and instead simply make a separate function for parsing things that have a read constraint
08:15:03 <obiwahn> hey i have installed xmonad to .cabal-sandboxes/xmonad/.cabal-sandbox/bin
08:15:24 <obiwahn> now i get some errors when starting
08:16:19 <obiwahn> is there more i need to do other than pointing in my xinitrc to the xmonad executable in the above directory?
08:16:40 <Monoide> can't you install it through your package manager /
08:17:09 <obiwahn> no it has errors as the released version 12
08:18:13 <Monoide> I don't use xmonad but I think it just need to be soemthing like
08:18:21 <Monoide> exec path/to/xmonad
08:19:09 <obiwahn> http://paste.debian.net/892717/
08:19:31 <obiwahn> then i get the following errors
08:20:54 <obiwahn> it is like it is not finding it's libraries
08:24:01 <obiwahn> so how do i pass the library search path when starting some app in a sandbox?
08:28:54 <obiwahn> cocreature: are you still around?
08:30:44 <Monoide> obiwahn: are you sure that it is the path to an executable ?
08:32:38 <obiwahn> 3.5M -rwxr-xr-x 1 i i 3.5M Nov  5 15:39 .cabal-sandboxes/xmonad/.cabal-sandbox/bin/xmonad
08:32:49 <obiwahn> looks like it
08:32:53 <obiwahn> and it starts
08:33:14 <obiwahn> but seems to have problems with xmonad.hs
08:35:57 <Paprikachu> i don't get it
08:36:02 <Paprikachu> i can write a : b
08:36:12 <Paprikachu> but as soon as i write (:) a b i get an error
08:36:57 <jedai> Paprikachu: That's probably a matter of priorities (we'll need the context to diagnostic the problem)
08:37:33 <Paprikachu> i made sure the arguments are primary expressions
08:38:09 <Paprikachu> http://codepad.org/CgD8sRLR
08:38:10 <Paprikachu> line 18
08:39:20 <Squarism> anyone got something to say on Spock?
08:39:59 <jedai> Paprikachu: what's the error ?
08:40:01 <Squarism> im finding scotty lacks proper support for sessions 
08:40:02 <obiwahn> Is here nobody who knows how to add some paths for library lookup?
08:40:11 <Squarism> so im thinkking about switching to Spock
08:41:08 <Clint> Paprikachu: type error
08:41:17 <Clint> are you sure : worked?
08:41:30 <Paprikachu> http://codepad.org/bAJyylDx
08:41:32 <Paprikachu> it did.
08:41:34 <Squarism> snap / yesod seems a bit dated? 
08:42:02 <Clint> Paprikachu: and you were trying to pass off the output of (digitToDigit $ k `mod` 3) as a Digits?
08:42:48 <Paprikachu> oh, i get it now
08:42:53 <Paprikachu> i parenthesized incorrectly
08:48:01 <Paprikachu> why does haskell not let me leave off trailing arguments when defining a pattern
08:48:35 <Paprikachu> i.e. a function f :: x -> x -> x and i want to define f 0 = id
08:48:49 <jedai> Paprikachu: you have to put as many patterns for every definition line
08:48:59 <jedai> Paprikachu: you can do that
08:49:17 <Paprikachu> but i cant when i have f k l = ...
08:49:38 <jedai> > let f :: Int -> a -> a; f 0 = id in f 0 "Hey"
08:49:40 <lambdabot>  "Hey"
08:49:57 <jedai> Paprikachu: Right, every definition must have as many patterns
08:50:08 <Paprikachu> but... why :(
08:50:34 <jedai> Paprikachu: That's what the report say !
08:51:02 <jedai> Ok, I have no idea why (maybe this would make life difficult for the compiler)
08:52:07 <yulax> hi
08:52:25 <yulax> my friend is having a problem
08:52:59 <yulax> they define a list of strings let games=["pool","pipsqueak","bulldogs"]
08:53:10 <sm> Squarism: why not. Spock is scotty with more stuff.
08:53:20 <yulax> they can do games !! ( mod 2 $ length games)
08:53:42 <yulax> however, games !! $ mod 2 $ length games fails
08:53:46 <yulax> why is thisL
08:53:48 <yulax> ?
08:53:54 <sm> snap is spock with more stuff. yesod is snap with more stuff. Select appropriate stuff level. :)
08:53:54 <obiwahn> is there something like ld_preload ?
08:54:06 <yulax> is this because we cannot combine $ and functions in this way?
08:54:31 <yulax> their reasoning was that $ is equivalent to brackets onwards until the end of the line etc
08:54:33 <Paprikachu> shouldnt it be (games !!) $ ...
08:54:49 <yulax> Paprikachu: why is that?
08:55:24 <Paprikachu> because of the way it's parsed
08:55:31 <Paprikachu> !! expects another argument
08:55:59 <Paprikachu> same reason why you have to parenthesize e.g. (<2) when you want to pass it to filter
08:57:08 <yulax> but from my line of thinking, we see (games !!) as closing off an argument. i understand how it works in filter, but not here
08:57:26 <jedai> yulax: this is a "section"$
08:57:32 <yulax> is it because we are taking (games !!) to be evaluated first?
08:57:33 <jedai> forget the $
08:58:13 <jedai> yulax: a syntax that applies to every binary operator, be it (+ 5) , (< 2) or (games !!)
08:58:19 <yulax> i see
08:58:32 <yulax> i will read up on haskell sections.
08:58:48 <jedai> yulax: and $ is not the same as starting a bracket until the end of the line
08:58:58 <yulax> that's what i have come to think
08:59:18 <jedai> yulax: it just have somewhat the same effect due to its priority
08:59:32 <Paprikachu> $ is defined the haskell library, it's a regular binary operator
08:59:45 <Paprikachu> so all the rules for operators apply as well
08:59:51 <jedai> yulax: right it's just the "application" operator
08:59:58 <Paprikachu> guess !! $ has no argument between !! and $, which makes no sense
09:00:01 <yulax> and it defines evaluations, not being equivalent to brackets then?
09:00:03 <jedai> f $ x = f x
09:00:23 <ertesx> yulax: you are writing 4 * + 5
09:00:38 <ertesx> "xs !! $ i" is something like that
09:00:50 <yulax> yes, i understand now
09:00:54 <ertesx> remember that ($) is just another operator
09:00:56 <yulax> thank you for all your help
09:00:57 <jedai> jedai: but since it has the weakest priority of all operator (or function application), it's a bit like putting brackets around the before and the after of $
09:04:51 <obiwahn> how do i add extra search path to an app
09:05:14 <obiwahn> if possible an other way than -i at compile time
09:06:43 <cocreature> obiwahn: hs-source-dirs can contain multiple entries
09:06:52 <cocreature> or what kind of search path are you talking about?
09:08:02 <obiwahn> when i start xmoand and the xmonad.hs is read then i get some errors in a white window
09:08:09 <obiwahn> http://paste.debian.net/892717/
09:08:54 <obiwahn> to me it looks like some libraries can not be found 
09:09:03 <cocreature> try running "cabal exec xmonad" inside of the sandbox instead of "xmonad"
09:09:08 <obiwahn> i have added the path to the bin to my PATH
09:09:37 <obiwahn> and i do a cd into the sandbox before calling exec ../path/to/sandbox/bin/xmonad
09:09:55 <cocreature> or run "cabal exec env" inside of the sandbox and take a look at the environment variables and set the ghc related ones manually
09:10:13 <cocreature> you need to call "cabal exec" not just "exec"
09:10:17 <obiwahn> ok
09:10:28 <cocreature> or probably "exec cabal exec" if this is xinitrc
09:12:10 <obiwahn> almost all errors are gone! awesome
09:12:59 <obiwahn> it is a bit painful but it is easy to write some shell wrappers
09:22:03 <buttbutter>  /join #C
09:24:33 <obiwahn> there is no #c, if you need to troll then direct people to ##c
09:26:20 <ertes> that's not how you troll
09:26:28 <ertes>  /join #haskellv0,0
09:26:34 <ertes> *that* is how you troll
09:27:00 * Clint squints.
09:27:04 <maerwald> ideally, ppl wouldn't troll here
09:27:24 <Clint> this channel used to be trollproof
09:27:45 <kaol> unsafeTrollIO
09:27:53 <a6a3uh> Hi! aeson question. cant figure out how to simply get value by key from decoded json. first of all decoded json is Value not Object. So I made my unwrapping {let runVal (Object o) = o} next I invoking {flip parse (runVal j) (\o->o.:pack "a")} to hopefully read from key "a" and get Error "failed to parse field a: expected (), encountered Number". I understand I'm doing something really wrong :)
09:28:03 <ertes> it wasn't…  it's just that trolling haskell needs some thinking upfront =)
09:28:58 <a6a3uh> flip parse (runVal j) (\o->o .: pack "a")
09:29:16 <monochrom> where does j come from?
09:29:31 <a6a3uh> j is decode output
09:29:48 <a6a3uh> I mean j = (fromJust $ decode jdata) :: Value
09:29:54 <monochrom> So conceptually you are parsing decode output?!
09:30:12 <cocreature> a6a3uh: if you want to decode into an object, decode into an object instead of decoding to a value and then checking if it’s an object. there is a FromJSON instance for HashMap and Object is just a type synonym for that
09:30:30 <a6a3uh> I decoded the string. No I want to read from one  the keys
09:30:32 <cocreature> i.e. j = (fromJust $ decode jdata) :: Object
09:30:49 <cocreature> but really don’t use fromJust unless you are sure what you are doing or don’t care about your program crashing
09:31:01 <cocreature> I guess the latter implies the former
09:31:04 <a6a3uh> I cant decode into an object because I dont have one. I'm decoding some arbitrary json with unknown structure
09:31:36 <cocreature> decode into an Object and throw away the things that are Nothing
09:31:49 <a6a3uh> I'm just learning so really not care much
09:35:33 <a6a3uh> o... I see what I did wrong. thanks you pointed to right direction
09:36:33 <cocreature> a6a3uh: you are confusing different things. (.:) is for creating a parser as needed for a FromJSON instance. once you have this instance you just call "decode" to convert from the json to your custom type
09:36:51 <pilne> "i am just learning so i really not care much"???? when you are learning you should care the most about things to prevent getting into bad habits, or not learning throughly enough to understand things later...
09:37:51 <maerwald> this nitpicking is sometimes annoying. fromJust is used pretty often in real-world json context in web apps
09:37:53 <maerwald> and that's fine
09:38:31 <maerwald> you don't always handle failure immediately, especially in web apps
09:38:44 <maerwald> or sometimes you know there can't be failure
09:39:29 <maerwald> "fromJust can crash your program if you use it wrong" is enough for a comment
09:41:41 <Eduard_Munteanu> You can use a helper that throws a meaningful error and returns the object directly, without a Maybe.
09:42:14 <Eduard_Munteanu> e.g. like Yesod's requireJsonBody
09:48:05 * hackagebot multipath 0.1.0.0 - Parser and builder for unix-path-like objects.  https://hackage.haskell.org/package/multipath-0.1.0.0 (SupraSummus)
09:50:24 <xuxu> > (*) <$> Just 3 <*> Just 4 
09:50:27 <lambdabot>  Just 12
09:50:43 <xuxu> :t (<$>)
09:50:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:50:52 <xuxu> :t (<*>)
09:50:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:51:33 <xuxu> not following how <$> and <*> work together to arrive at Just 12
09:52:35 <Clint> > Just (*) <*> Just 3 <*> Just 4
09:52:38 <lambdabot>  Just 12
09:52:40 <xuxu> (* Just 3) Just 4
09:52:57 <xuxu> i think that's close to what you get after <$> is applie
09:52:59 <xuxu> d
09:53:10 <Clint> xuxu: why do you think that?
09:53:54 <xuxu> <$> takes an (a -> b), that's the (*). it also takes an f a, which i'm thinking is the Just 3.
09:54:01 <xuxu> (* Just 3)
09:54:59 <Clint> xuxu: i think i'm missing a step in your logic
09:55:39 <ongy> it returns a: f a -> f b -- or f b if you give it the second argument 
09:55:45 <xuxu> Clint: for what was just mentioned or the following steps
09:56:04 <mniip> xuxu, do you know what (*) <$> Just 3, is?
09:56:41 <xuxu> > (*) <$> Just 3 -- an error?
09:56:43 <lambdabot>  Just <Integer -> Integer>
09:56:55 <mniip> no, that's Just (3 *)
09:56:59 <Welkin> it is a function
09:57:29 <Welkin> :t fmap (*) (Just 3)
09:57:31 <lambdabot> Num a => Maybe (a -> a)
09:57:49 <xuxu> ghci's error wasn't a relevant error: No instance for (Show (a0 -> a0)) arising from a use of ‘print’
09:59:01 <xuxu> ah, it's kind of a partial application
09:59:09 <xuxu> which is a function which is what <*> needs 
09:59:19 <xuxu> and it already has the f a as well in Just 4
09:59:24 <xuxu> perfect, thank you Clint 
10:00:07 <Welkin> oh hi mniip 
10:00:11 <xuxu> i've been really busy at work, and i decided to look back at applicative functors before diving into monads. glad i did
10:00:20 <mniip> hello
10:00:42 <Clint> eyyyy
10:01:07 <xuxu> thansk mniip and Welkin as well for the crucial step in understanding :)
10:01:09 <Welkin> and you asked Clint because you read LYAH
10:01:13 <Welkin> and the monad chapter
10:01:33 <xuxu> hm?
10:01:44 <Welkin> A Fistful of Monads
10:01:54 <xuxu> i never mentioned lyah :)
10:02:05 <Welkin> it's a joke
10:02:09 <Clint> Welkin: i think you lost
10:02:18 <Welkin> also, xuxu is the name of one of the crew members you can play in FTL
10:02:32 <xuxu> Welkin: you are correct that i'm reading lyah :)
10:02:46 <xuxu> i don't know what ftl is 
10:03:02 <jedai> xuxu: Faster Then Light I suppose
10:03:06 <xuxu> google suggests faster than light on steam
10:03:14 <ongy> jup
10:03:33 <jedai> xuxu: that's a strange game where you "manage" a spaceship on the run
10:03:46 <Welkin> it's not strange, it's fun!
10:04:13 <Clint> why not both
10:04:29 <ongy> needs to be on mobile platforms. 
10:04:40 <Welkin> it is
10:04:43 <Welkin> it runs on ipad
10:04:51 <Welkin> which is where I play it
10:05:08 <Welkin> it would be too hard to play on a smaller screen though
10:05:35 <ongy> I was thinking 3DS
10:05:45 <ongy> maybe ps vita
10:10:36 <yulax> i have played it
10:10:48 <yulax> never got very good at it
10:10:53 <yulax> i just liked the music
10:11:07 <Welkin> I never got past the first boss
10:11:13 <yulax> i prefer... the crypt of the necrodancer!
10:11:18 <Welkin> yeah, that game is great too
10:11:47 <yulax> hmmm.. i still haven't made a game in haskell
10:12:02 <Welkin> I still didn't finish any of my games
10:12:03 <yulax> must get round to this sometime
10:12:07 <Welkin> not in haskell, or c, or lua
10:12:09 <yulax> yea me too
10:12:58 <joncol> Q: What's a reasonable type for a game loop that has State, Random-ness and IO. I have defined a type Game g = RandomGen g => Rand g (StateT GameState IO GameResult). Is this OK?
10:14:10 <joncol> I'm unsure about at what level to put Rand (or RandT)
10:14:18 <Welkin> try using MonadRandom instead
10:14:22 <Welkin> and MonadState
10:14:33 <joncol> What's better with them?
10:14:37 <Welkin> then you don't have to unpack any specific heirarchy
10:14:40 <breadmonster> Hello.
10:14:43 <Welkin> the typeclass handles it for you
10:14:50 <Welkin> so you don't have to explicitly lift. lift
10:14:55 <joncol> Ah.
10:16:43 <soLucien> hello guys ! If i want to build a specific char parser for parsec , what should i use ? I'm a bit lost in documentation . I want to parse something like (for example) [a-zA-Z0-9$_/<]
10:16:49 <soLucien> all occurences of this
10:17:21 <soLucien> in readP it would be like satisfy then munch
10:17:23 <breadmonster> soLucien: You want it to parse one character or a whole string?
10:17:33 <joncol> soLucien: Check out oneOf (in Text.Parsec.Char)
10:17:35 <soLucien> a string with as many of these as possible
10:18:00 <soLucien> cool , oneOf seems like what i'm looking for
10:18:28 <breadmonster> :t oneOf
10:18:28 <breadmonster> Where's lambdabot?
10:18:30 <lambdabot> Eq a => [a] -> Splitter a
10:18:35 <joncol> soLucien: And many1 (or many)
10:20:01 <breadmonster> soLucien: many1 . foldr (<|>) . map oneOf [ ['A'..'Z'], ['a'..'z'], ['0'..'9'], "$_/<"]
10:20:12 <soLucien> so smth like many (oneOf "a-z") etc
10:20:17 <breadmonster> Man, Haskell syntax is so compact, it's fantastic.
10:20:42 <Welkin> breadmonster: you've been writing haskell for well over a year now
10:20:50 <joncol> soLucien: "a-z" is not equal to ['a'..'z']
10:20:52 <Welkin> you are just now surprised?
10:21:03 <soLucien> yes, i was being lazy
10:21:06 <soLucien> but thanks, i understand
10:21:07 <breadmonster> No, I just wanted to mention it.
10:22:04 <joncol> soLucien: Cool :)
10:31:12 <sm> breadmonster: +1
10:39:57 <mpickering> If I run "stack ghc" then should the package db be set to something?
10:40:12 <mpickering> Then next question, how do I install something into this package db
10:40:30 <Welkin> stack install <package>
10:46:42 <soLucien> i'm missing a bit of explanatory documentation on Parsec. So there are 2 types being exported : GenParser and Parsec. They have different type signatures. Any idea what the difference is  between them , and what are the use cases ?
10:46:53 <soLucien> :i GenParser
10:46:55 <ezyang> If you're just starting, just use Parsec 
10:47:26 <soLucien>  type GenParser tok st = Parsec [tok] st  versus type Parser = Parsec String ()
10:47:40 <kadoban> mpickering: "stack ghc --package whatever --package whateverelse, etc.
10:48:12 <mpickering> What if I want to build a library from the source which has a stack.yaml file
10:48:20 <mpickering> but make it available in the global env
10:48:41 <Welkin> mpickering: should all be in the docs
10:48:41 <kadoban> In other words, you don't set up the global state as needed first, you just request the stuff you need.
10:49:19 <kadoban> mpickering: I believe you put that in ~/.stack/global-project/stack.yaml , you should use the same format as adding extra-deps to a specific project uses
10:49:46 <soLucien> okay .. so i will use type Parser = Parsec String ()
10:49:59 <soLucien> what does the final () represent ?
10:50:38 <soLucien> Or what should i read in order to understand it ?
10:51:15 <jedai> soLucien: You parser can maintain an internal state
10:51:33 <mpickering> kadoban: thanks
10:51:58 <jedai> soLucien: useful if your parser don't behave the same depending on what happened before
10:52:01 <soLucien> yes, that's the "string that's left to parse" , and the AST of the parse
10:52:13 <kadoban> mpickering: By the way, why not just add a stack.yaml specific for this package, and make it a full cabal package too?
10:52:13 <jedai> soLucien: no, not that
10:52:45 <mpickering> because these are pandoc filters which you just want to quickly compile to an executable
10:52:47 <soLucien> you mean make it context-sensitive ?
10:53:06 <jedai> soLucien: in addition to that you may have to track another information to parse your language correctly (for instance indentation level in last line to parse Haskell)
10:53:15 <jedai> soLucien: Right
10:53:32 <soLucien> i do need that , yes .. the grammar i am parsing is actually context-sensitive
10:53:44 <jedai> soLucien: so Parser by default put a unit () there so you don't get that
10:53:48 <mpickering> Haskell wouldn't be a very good scripting language if you had to make a project for throw away file
10:53:50 <monochrom> soLucien: Do you want a parsec tutorial? http://jakewheat.github.io/intro_to_parsing/ is good and up-to-date
10:54:19 <jedai> soLucien: then you may need to use GenParser Char YourState
10:54:43 <soLucien> i only have 2 states that i need to keep track of
10:54:59 <jedai> soLucien: most functions will behave the same but you'll get to manipulate this additional state
10:55:00 <sm> a stack script (with stack shebang line) is good for pandoc filters. To compile it, you have to run it once interpreted first
10:55:31 <sm> (mpickering)
10:55:35 <soLucien> i'll use that, monochrom , thank you. I've user ReadP before
10:55:41 <jedai> soLucien: Right, so create a type that contain both and keep tracking it during your parsing
10:55:42 <soLucien> used
10:56:06 <mpickering> sm: OK, perhaps you saw the thread I am wondering about on the pandoc mailing list?
10:56:19 <soLucien> play , so the st in GenParser is actually the state that i am tracking
10:56:35 <soLucien> okay so the state *
10:57:08 <sm> mpickering: now I have
10:57:36 <soLucien> i understand, many thanks 
10:58:08 <ggVGc> what's the correct way to resolve this? https://gist.github.com/c927403a0a1dc58c2464085b604c15b5
10:58:18 <ggVGc> I had to add socket-io-1.2.13 to extra-deps apparently
10:58:29 <mpickering> and that works?
10:58:32 <ggVGc> do I need to add specific version of things in my cabal file?
10:58:58 <sm> sure does, eg: #!/usr/bin/env stack
10:58:59 <jedai> ggVGc: I don't think so
10:59:11 <sm> {- stack runghc --verbosity info --package pandoc-types-1.16.1 -}
10:59:13 <ggVGc> oh, wait
10:59:17 <ggVGc> my resolved has too old base I think
10:59:32 <mpickering> sm: I believe you! I was talking to ggVGc 
10:59:46 <sm> oops
11:00:17 <mpickering> It looks like you are trying to use ghc 8.0 and engine-io only works for ghc-7.10
11:00:26 <ggVGc> oh, hm
11:00:33 <ggVGc> yeah, I'm using ghc 8
11:00:37 <jedai> ggVGc: not too old, too new
11:00:43 <ggVGc> argh
11:00:46 <ggVGc> alright
11:00:47 <jedai> base-4.9.0.0 must match >=4.6 && <4.9
11:00:56 <Welkin> upgrade your packages people
11:01:04 <Welkin> you'll get left behind
11:01:12 <Welkin> I only run ghc 8 now
11:01:18 <mpickering> (hides in the corner whilst suggesting --allow-newer) 
11:01:27 <sm> or use snapshot contemporaneous with the code you're building
11:01:43 <ggVGc> which is the latest resolver with ghc 7.10?
11:01:51 <sm> 6.23
11:01:54 <ggVGc> thanks
11:02:07 <jedai> Welkin: but one of stack advantage is that it is not too much of a problem to use an older package
11:02:33 <jedai> Welkin: it will even install the right version of ghc (and keep it isolated)
11:02:38 * sm just used lts-3.22 to get some "old" code running fine
11:02:42 <Welkin> yeah, but I moved on to nix
11:02:49 <Welkin> it's even easier than stack
11:03:00 <Welkin> you can use stack and nix together too I suppose
11:03:32 <Welkin> I haven't actually compiled a haskell library, or ghc, or cabal-install, in months
11:03:35 <ggVGc> my problem with using older ghc versions has been that it doesn't play well with ghc-mod if the system ghc isn't the same
11:03:38 <ggVGc> so will se how this goes now
11:03:52 <sm> ghc-mod is just a pain
11:03:58 <Welkin> I never used ghc-mod
11:03:58 <ggVGc> what do you use instead?
11:04:03 <Welkin> I don't use anything
11:04:06 <ggVGc> weird
11:04:07 <Welkin> just haskell-mode
11:04:19 <ggVGc> what does haskell mode use to supply type information etc.?
11:04:20 <sm> ghcid and text search/tags, for now
11:04:21 <jedai> Welkin: I don't think it is easier than stack. After all stack is kind of a nix specialized in Haskell. Nix advantage are speed (precompiled binaries) and non-haskell dependencies
11:04:40 <monochrom> haskell-mode justs asks ghci
11:04:41 <sm> intero if I'm feeling patient
11:04:48 <johnw> cabal new-build *is* a nix specialized in Haskell
11:04:52 <jedai> ggVGc: if you're under emacs, intero is really pretty good
11:05:01 <ggVGc> vim though :(
11:05:05 <Welkin> johnw: what is new-build?
11:05:09 <Welkin> and when does it come out?
11:05:13 <monochrom> yes it does imply that if your most recent load failed, you don't get much type information.
11:05:16 <Welkin> and can I use it inside of nix-shell?
11:05:30 <johnw> http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
11:06:15 <ezyang> also http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html 
11:06:17 <ggVGc> I should try getting a haskell dev enveronment set up with emacs and evil mode I guess
11:06:28 <ggVGc> haskell dev seems much more mature in emacs than in vim
11:06:29 <jedai> ggVGc: spacemacs
11:06:37 <ggVGc> nah, I really dislike spacemacs
11:06:54 <jedai> ggVGc: why ? if it isn't too indiscreet ?
11:07:20 <ggVGc> jedai: I don't like to use software preloaded with extensions picked and configured by other people
11:07:48 <ggVGc> I'd rather use emacs, evil mode, and whatever plugins and configuration I find useful
11:08:05 <Welkin> vanilla emacs with haskell-mode works for me
11:08:44 <ggVGc> Welkin: yeah, I just need evil mode becase I don't have the time or interest in actually learning emacs key bindings
11:08:59 <ggVGc>  but it doesn't work out so well, because even with evil mode I need to learn quite a bit of emacs
11:09:07 <ggVGc> and I just want to write haskell
11:09:40 <Welkin> emacs is easy to learn
11:09:41 <Welkin> o.o
11:09:49 <Welkin> use the built-in tutorial
11:09:58 <johnw> "<Welkin> emacs is easy to learn"
11:10:00 <johnw> hahahahaha
11:10:00 <ggVGc> it's still something I need to learn
11:10:02 <Welkin> you will be up and running in 20-30 minutes
11:10:08 <ggVGc> rather than using the text editor I've already learnt for 10 years
11:10:13 <Welkin> lol johnw 
11:10:18 <Welkin> I meant the basic keybindings
11:10:42 <ggVGc> yeah, but it's not so useful going from a powerful editor like vim where I know a lot of functionality to using "the basics of emacs"
11:10:42 <Welkin> and just copy-paste your .emacs
11:10:48 <ggVGc> it's quite a big step back
11:10:55 <Welkin> I don't need very many features
11:11:12 <Welkin> movement, selection, copy/kill/yank
11:11:20 <Welkin> search, replace
11:11:26 <Welkin> a keyboard macro every now and then
11:11:28 <ggVGc> that's not the point. I've been editing code in one tool for 10 years. it doesn't feel okay to go back to square one in another editor
11:11:31 <Welkin> maybe compile-mode
11:11:44 <monochrom> ezyang: on cabal.readthedocs.io you have two versions, "latest" and "status-command". What does "status-command" mean? :)
11:11:57 <ggVGc> anyway, evil mode is pretty good
11:12:04 <pilne> good info for ghc and vim here: http://www.stephendiehl.com/posts/vim_2016.html
11:12:09 <ggVGc> but I'd still miss a lot of my vim stuff for many months
11:12:14 <ggVGc> thanks pleiosaur 
11:12:18 <ggVGc> eh, pilne 
11:12:21 <Welkin> lol
11:12:23 <Welkin> what's a pleiosaur 
11:12:28 <pilne> np
11:13:00 <ezyang> monochrom: It's someones feature branch, we should probably delete it 
11:13:20 <ggVGc> pilne: all of that still relies on ghc-mod though
11:13:24 <ggVGc> which was the whole issue from the start
11:13:47 <ggVGc> but yeah, haskell dev in vim atm seems to be based on ghc-mod. While emacs has plugins just using ghci
11:13:48 <johnw> ezyang: it would be cool if running cabal new-build under Nix caused it to just use the Nix store :)
11:14:25 <Tuplanolla> Emacs is fun until you have to use it remotely and half of the shortcuts don't work, because Windows, PuTTY and a Finnish keyboard are entangled in a nontrivial way. It doesn't help that X11 forwarding doesn't work either and you can't read Emacs' dark blue text on a black background.
11:14:40 <Tuplanolla> That was my experience when I last tried your suggestion, Welkin.
11:14:55 <breadmonster> Tuplanolla: Why would you use it remotely?
11:15:07 <breadmonster> use tramp to run local emacs to edit a remote file.
11:15:09 <monochrom> I don't think "emacs -nw" sets any colour at all
11:15:13 <Welkin> I don't use windows or finnish keyboards though
11:15:13 <breadmonster> You _never_ have to leave emacs
11:15:23 <Welkin> emacs works perfectly fine in my terminal through ssh
11:15:30 <ezyang> johnw: There's a ticket for that https://github.com/haskell/cabal/issues/3882 https://github.com/haskell/cabal/issues/3651 
11:16:12 <Tuplanolla> I'd first have to wipe university workstations or other random people's computers I happen to use, breadmonster.
11:16:24 <ongy> putty is a bit weird
11:16:38 <monochrom> also do you already know the trick of e.g. M-x can be done by <esc> <x> ?
11:16:44 <breadmonster> Tuplanolla: No, like what I mean is that you can use emacs on your machine to edit stuff on theirs?
11:16:50 <breadmonster> Oh wait, you don't have your machine with you.
11:16:52 <breadmonster> Fair enough.
11:16:53 <pilne> almost all dev in haskell with "power" has ghc-mod tied in
11:17:09 <johnw> ezyang: excellent, thanks!
11:19:42 <Tuplanolla> I'm not happy with Vim either, but at least it tends to work for the few things I need. I just wish its action-motion language was more expressive, like Haskell.
11:20:08 <pilne> i must be the odd duck that actually likes atom
11:20:32 <Franciman> Hello, does anyone know the haskell scalpel library?
11:20:39 <Franciman> for scraping html pages
11:21:18 <Tuplanolla> It would be pretty sweet to be able to make a visual block selection and feed it through a program or, even better, write that program in Haskell on the spot.
11:24:22 <ggVGc> Tuplanolla: hm? You can visual select and run it through an external program and get the output into a buffer in vim
11:24:25 <ggVGc> easily
11:24:33 <Tuplanolla> Not a visual block selection, ggVGc.
11:24:39 <ggVGc> oh, block
11:24:44 <ggVGc> why is block specifically important?
11:25:45 <Tuplanolla> I could for example run `:!xargs -0 pointfree` on the selection or cut columns off a table and feed them into `gnuplot`.
11:27:33 <ggVGc> Tuplanolla: you could easily make a small plugin that does this though. E.g turn a block selection into lines and run those through external program
11:28:23 <Tuplanolla> I could easily do anything.
11:29:18 <Tuplanolla> I'd still be unhappy with Vim's lack of elegance. The shortcut language doesn't even have any useful algebraic properties.
11:29:31 <ggVGc> does emacs_
11:29:32 <ggVGc> ?
11:29:46 <Tuplanolla> No. Why does that matter?
11:36:22 <Tuplanolla> Either way it would be an interesting research project to construct such a transformation language and a way to visualize it interactively.
11:37:42 <joncol> I'm in a State monad based on IO. Can I get the "current" state and putStrLn it, without having to run execState? I'm in a potentially infinite game loop and want to print the current score (=the state).
11:38:14 <Tuplanolla> Just `get` it, joncol?
11:38:22 <monochrom> get >>= \x -> liftIO (putStrLn x)
11:38:30 <monochrom> or the equivalent do-notation
11:38:51 <monochrom> unless your state isn't type String
11:39:27 <monochrom> but then you'll have to explain what your "putStrLn" means for a non-String thing.
11:39:47 <joncol> ah, .. I may be confused here. Doesn't `get` return a function?
11:39:53 <Lokathor>     ghc-options:        -O2 -threaded +RTS --with-rtsopts=-N
11:39:56 <monochrom> No.
11:40:00 <Lokathor> is this how i make my program always run multi-core?
11:40:13 <Lokathor> or did i mangle it up somehow?
11:40:28 <joncol> monochrom: get :: Monad m => StateT s m s
11:40:34 <monochrom> I would drop the -O2 unless it's a very exceptional case.
11:40:35 <joncol> :t StateT
11:40:37 <lambdabot> (s -> m (a, s)) -> StateT s m a
11:40:52 <Lokathor> why drop O2?
11:41:11 <Tuplanolla> :t Control.Monad.State.Class.get
11:41:12 <implementation> :k StateT
11:41:13 <joncol> monochrom: A wrapped function?
11:41:13 <lambdabot> MonadState s m => m s
11:41:13 <lambdabot> * -> (* -> *) -> * -> *
11:41:22 <monochrom> because 90% of the time you should let the user decide the level of optimization.
11:41:46 <Lokathor> but i'm the user >_>
11:42:36 <monochrom> So the right way is not to ask "why omit -O in *.cabal". Instead, it is better to ask "why are you in the 10% case where you really need to hard-code -O2 in *.cabal".
11:43:08 <Tuplanolla> Look at that type of `get`, joncol. Now, what do you get when you use `<-` on something of type `m s`?
11:43:14 <Lokathor> well when i build it with "stack build" i want it to use O2
11:43:28 <monochrom> joncol, you should not always think of "s -> m (a,s)".
11:43:43 <Lokathor> and i'm going to be buildig it like, 10 times an hour any time i actually am building it
11:44:13 <joncol> Tuplanolla: s
11:45:17 <Tuplanolla> Substitute `m` for your choice of `StateT`, joncol. It still works.
11:45:32 <joncol> OK, cool.
11:46:43 <joncol> Looking at Control.Monad.State.Class makes things less confusing than looking at Control.Monad.Trans.State
11:48:09 <lwm> Anyone got some spare cycles to help me grok a compiler error?
11:48:25 <monochrom> No guarantee.
11:48:33 <lwm> https://github.com/commercialhaskell/stack/pull/2747#issuecomment-258207846
11:48:44 <lwm> Anything could help at this stage ;)
11:49:47 <monochrom> Where is line 79?
11:50:22 <monochrom> Haha GHC agrees with me. "Inaccessible code"
11:51:57 <monochrom> I don't know the cause, but I know you have a self-contradiction in the form of you wanting both "Either BuildPlanTypesException" and "IO" at the same time.
11:52:32 <monochrom> And if you are sure you did not want it explicitly, you still wanted it implicitly through type class instances and functional dependencies.
11:52:41 <geekosaur> lwm, error looks correct to me. if your monad is not an Either something, the type is wrong. since it looks like IO is actually needed there, you need the type to be something like IO (Either BuildPlanTypesException SnapName)
11:52:57 <lwm> Oh, here is #79: https://github.com/lwm/stack/blob/f9347fc33e62fe9d07d83ca00a1167a9f64c6bab/src/Stack/ConfigCmd.hs#L79
11:53:33 <lwm> monochrom: Right, I was really having a hard time grokking fundeps
11:53:35 <geekosaur> but I have little confidence that that is exactly the right type, minus full context
11:56:20 <lwm> geekosaur: Hmmm, let me try that then - IO ( ... ) 
11:57:50 <geekosaur> it *has* to be an IO something, or possibly something more complex atop IO given the MonadBaseControl stuff
11:58:01 <monochrom> try (parseSnapName newResolverText >>= loadMiniBuildPlan) :: (Either BuildPlanTypesException SnapName)  eh?
11:58:17 <monochrom> that is wrong parenthizing
11:59:21 <lwm> Ah, the SnapName type was wrong ... I think I got somewhere with: IO (Either BuildPlanTypesException MiniBuildPlan)
11:59:38 <lwm> But then getting equally mystic: Couldn't match type ‘m’ with ‘IO’
11:59:47 <monochrom> No, I mean this.
12:00:08 <monochrom> "x <- getLine :: String" has the right intention but the wrong coding.
12:00:21 <geekosaur> lwm, that was what I was afraid of.
12:00:44 <monochrom> there are two right codings. one is "x <- getLine :: IO String". But you can't use it for your case, you have general "m" rather than concrete "IO".
12:00:48 <geekosaur> hm. do you even need a type signature therE?
12:01:11 <monochrom> Oh wait you have ScopedTypeVariables already. You can do that.
12:01:17 * geekosaur has spotted the type signature and indeed hardcoding IO won't work. but if you need to use a type sig, you will need ScopedTypeVariables extension and add a forall m.
12:01:41 <geekosaur> and not be using m elsewhere in that binding
12:02:20 <monochrom> First you need to "cfgCmdSetValue :: forall m env . (StackMiniM env m, HasConfig env, HasGHCVariant env)  => ConfigCmdSet -> m Yaml.Value"
12:02:50 <monochrom> then it is "_ <- try (parseSnapName newResolverText >>= loadMiniBuildPlan) :: m (Either BuildPlanTypesException MiniBuildPlan)
12:02:59 * mattheuswilkisom
12:03:03 * mattheuswilkisom
12:03:08 <nshepperd> if you've got ScopedTypeVariables you can use (x :: String) <- getLine, no?
12:03:33 <monochrom> Oh oops, yeah, that's even better, and no need to add the "forall m env." thing.
12:03:42 <lwm> monochrom: wow, that worked.
12:03:49 <jedai> nshepperd: that's not scopedtypevariables I think ?
12:03:54 <geekosaur> it is
12:04:02 <jedai> really ?
12:04:11 <geekosaur> ScopedTypeVariables absorbed the old PatternSignatures
12:04:16 <Tuplanolla> There's probably a `Proxy` solution hiding in here as well.
12:04:18 <jedai> Ah...
12:04:39 <Tuplanolla> Not that it's any better.
12:05:34 <monochrom> You should only suggest the best solution you can think off. Not all tangential solutions you can think of.
12:05:49 <lwm> can anyone explain that to me like I am 5?
12:05:50 <Tuplanolla> It's better if you want to avoid all extensions.
12:05:51 <monochrom> This channel becomes high quality if everyone offers their best.
12:05:54 <lwm> possibly asking too much now ;) thanks though
12:06:25 <monochrom> Sure, but the file already has ScopedTypeVariables to begin with, way before this question.
12:06:53 <monochrom> Like you're 5: I'll tell you when you grow up.
12:06:58 <geekosaur> heh
12:07:14 <jedai> lwm: the forall m introduce a type variable that can be reused in the scope of the function
12:07:16 <monochrom> But I can do like-you're-15. That's much more reasonable
12:07:41 <geekosaur> so first off, you are doing something that requires an m something, not just an Either something somethingelse, because you are on the right of a <-.
12:08:44 <jedai> lwm: that's thanks to ScopedTypeVariables since by default if you use m in the type of the function and another m in a type in the function, those two m have nothing to do with each other (they're unrelated type variables)
12:08:47 <geekosaur> the type signature for that binding tells me you need an m, constrained according to the signature. if you actually need a type signature there (I am still dubious about that), then you need ScopedTypeVariables and to tell it via the forall that "m" needs to be a type variable in scope inside the binding so you can use it in a type signature
12:09:03 <geekosaur> normally the scope of a type variable is the signature it is in, and no more
12:09:11 <monochrom> There is also a good explanation in the GHC User's Guide.
12:09:11 <ph88> anyone know a good tutorial about type synonym families ?
12:09:32 <monochrom> That one is nicely done in the GHC User's Guide too.
12:09:43 <monochrom> I even learned Template Haskell from the GHC User's Guide.
12:10:15 <monochrom> No, TH is too big, the bulk is in the library not in the user's guide.
12:10:31 <monochrom> But I learned QuasiQuote from the GHC User's Guide.
12:10:50 <lwm> ok, coming together for me, thanks all. I'll head to the user's guide
12:11:10 <ph88> yup i recently discovered the users guide as well, it's a great resource
12:11:40 <monochrom> the user's guide is under-valued. buy its stock now, you will get rich.
12:11:45 <joncol> I want to use `guard` inside my Monad transformer stack. Is it right to add a MonadPlus m => constraint?
12:12:51 <joncol> I get a problem with runGame :: (MonadIO m, MonadPlus m, MonadRandom m) => m (Maybe GameResult), when guard causes the function to return mzero. I would like it to return Nothing instead. Is this possible? :)
12:16:36 <geekosaur> joncol, no. m will determine what mzero does, not Maybe
12:17:13 <joncol> geekosaur: OK, I thought it would be nice to avoid having a if-expression... :(
12:17:54 <monochrom> you can still use mzero.
12:18:06 <monochrom> It still probably does the right thing for m.
12:18:09 <joncol> And remove the Maybe?
12:18:43 <ph88> what's ~ in types ?
12:18:50 <jedai> ph88: equality
12:18:51 <geekosaur> ph88, type equivalence
12:18:52 <monochrom> You know what, it depends on what the caller of runGame wants.
12:19:18 <ph88> what other things like ~ are there ?
12:19:34 <unclechu> hey guys, I'm trying to write some bindings using FFI, but get error in runtime like this `APP_NAME: <<loop>>` where APP_NAME is binary file name of my application. what could it mean?
12:19:38 <jedai> ph88: Nothing right now I think ?
12:19:52 <ertes> :t Dinner
12:19:54 <lambdabot> I bet you thought it's pizza again
12:20:12 <hpc> unclechu: you've written an infinite loop, and it happened to be one ghc was able to detect
12:20:20 <ph88> so you can't say for example that the type of two things may not be the same ?
12:20:36 <monochrom> ertes: How did you do it?!
12:20:44 <jedai> ph88: You can't write a constraint like that, no
12:20:49 <monochrom> Oh, I see how now. Hahaha.
12:20:57 <ertes> =)
12:22:17 <geekosaur> unclechu, specifically <<loop>> means that when Haskell tried to evaluate some expression, it immediately landed in the same expression again. like `let x = x in x` but in your case it's probably a little more complicated
12:22:43 <ertes> ph88: you can write a *type* that denotes type unequality…  the difference is that you would have to pass values (i.e. proofs) explicitly
12:23:29 <ertes> ph88: first see the type for type *equality* in Data.Type.Equality
12:23:41 <ertes> ph88: then use this alias:  type Not a = a -> Void
12:23:58 <geekosaur> unclechu, for example let's say you have `let x = x + 1`, it will try to evaluate x, which is x + 1, so it goes to evaluate x and throws because that's where it started out
12:24:48 <unclechu> geekosaur: here is small example: http://pastebin.com/uCfTDytT 
12:24:49 <geekosaur> (because Haskell's let is letrec, the x is the same x on both sides of the =. you can't pretend you're in a language where that increments x)
12:25:07 <unclechu> geekosaur: I don't see any infinite loops there
12:25:08 <joncol> monochrom: I put a paste at http://lpaste.net/329400 if you have the time to take a look. I want to get rid of the ugly if on line 57.
12:25:20 <ertes> ph88: you'll also need the EmptyCase extension to write unequality proofs (equality refutations) somewhat safely…  it's all a bit ugly in haskell
12:25:33 <joncol> (Or anyone else)
12:25:50 <geekosaur> unclechu, it's right there... let ... returnPtr = returnPtr
12:26:10 <geekosaur> you can't do that in Haskell. it created a *new* binding returnPtr and bound it to itself
12:26:12 <ph88> ertes, sounds ugly indeed ^^
12:26:26 <unclechu> geekosaur: oh..
12:26:29 <geekosaur> it did *not* use the result of returnPtr <- ...
12:26:36 <ph88> ertes, do you know some stuff about generics ?
12:27:10 <ertes> ph88: just ask…  someone in this channel surely knows =)
12:27:14 <geekosaur> if you had warnings turned on, ghc would warn you that you shadowed the original returnPtr there
12:27:15 <unclechu> geekosaur: is there other way to describe typing inline?
12:27:24 <geekosaur> just use a different name for the new one
12:27:31 <unclechu> geekosaur: like `returnPtr :: Blabla <- ...`?
12:27:40 <pikajude> you have to put parentheses around that
12:27:52 <pikajude> (foo :: bar) <- ...
12:27:58 <geekosaur> unclechu, turn on ScopedTypeVariables and (returnPtr :: ...) <- ...
12:28:10 <ph88> well i was trying to figure out how to use GHC generics to see help create a function that only does something when a value is of a certain type
12:28:15 <geekosaur> or: returnPtr <- ... :: IO Ptr CTypes.CInt
12:28:17 <unclechu> okay, thanks
12:29:05 <ph88> type family F a b :: * -> *   -- F's arity is 2, although its overall kind is * -> * -> * -> *      why is this kind 4x * ?
12:29:11 <ertes> ph88: while GHC generics include metadata the whole point of them is to be oblivious to the type and only see its algebraic structure
12:29:27 <ertes> ph88: perhaps you want to use a type class instead?
12:29:40 <ph88> posibbly, what could i do with a type class ?
12:29:51 <ertes> ph88: ad-hoc overloading
12:30:10 <ph88> do you have an example on that ?
12:30:20 <ertes> f :: (MyClass a) => a -> IO ()
12:30:27 <ertes> print "Hello world!" only if a = MyType
12:31:03 <geekosaur> ph88, the overall kind will depend on what each instance expands to
12:31:24 <geekosaur> presumably either a or b is not kind *
12:31:47 <ertes> ph88: F :: * -> * -> * -> *
12:31:53 <ertes> F a :: * -> * -> *
12:31:56 <ertes> F a b :: * -> *
12:32:10 <ertes> and consequently, given (c :: *), F a b c :: *
12:32:22 <coleman> Can someone explain why `t <- (drop 10 myEnum)` is faster than `x <- [10..], let t = myEnum !! x` ???
12:32:35 <ertes> it's just type-level currying
12:33:20 <ph88> ertes, how can you check that a = MyType ? MyClass can be about many types, no ?
12:33:35 <ertes> you don't *check*, you define
12:33:51 <jedai> coleman: sure, the first one doesn't have to go through the whole list for each index again
12:33:57 <ertes> class MyClass a where f :: a -> IO ();  instance MyClass MyType where f _ = putStrLn "Hello world!"
12:34:15 <coleman> jedai: ah
12:34:25 <grantwu> When you use record syntax to generate accessors for various fields
12:34:31 <grantwu> Is convention to make them verbs or nouns?
12:34:35 <coleman> jedai: thanks, makes sense
12:34:51 <jedai> coleman: you're welcome :)
12:34:53 <ertes> grantwu: there is no convention, but i prefer nouns
12:34:55 <grantwu> i.e. data Foo = { getBar :: Bar } or data Foo = { bar :: Bar }
12:35:05 <grantwu> ertes: Hrm, okay, I also prefer nouns...
12:35:12 <geekosaur> grantwu, depends on how you are using it
12:35:26 <ertes> grantwu: for newtypes i use verbs like this:  newtype X = X { fromX :: Y }
12:35:31 <ertes> fromX :: X -> Y
12:35:42 <ertes> uhm…  that's not a verb
12:36:04 <ertes> you get the idea
12:47:12 <ph88> ertes, i tried your suggestion https://paste.fedoraproject.org/471450/83751251/ it works. But now i would like the replace function to take a function that does the transformation of the value, instead of defining it in the instance. Do you know how i could do that? I think the problem would be to figure out the type of such function
12:53:43 <EvanR> hrm, whats the good book about garbage collectors?
12:53:58 <EvanR> i remember reading one but cant remember the name (their all pretty generically named)
12:55:08 <ph88> i highly recommend this one https://www.amazon.com/Garbage-Collectors-Neighborhood-Paulette-Bourgeois/dp/1550748262
12:55:20 <EvanR> what
12:55:55 <ph88> The text focuses on several main concepts and outlines the problems that garbage creates.
12:56:44 <amx> that's a CS classic
12:57:19 <MarcelineVQ> @karma+ ph88
12:57:19 <lambdabot> ph88's karma raised to 1.
12:57:49 <monochrom> why is it dated as April 1? :)
12:57:59 <Tuplanolla> There's The Garbage Collection Handbook.
12:58:13 <Tuplanolla> I haven't read it, but I hear it's good.
12:59:10 <amx> ph88: I'm not entirely sure what you are up to, but maybe you can make it a Functor instance?
13:00:00 <younder> EvanR, "Garbage collection, Algorithms for automatic dynamic memory management" by Richard Jones and Rafael Lins
13:03:00 <ph88> amx, if i have a function with a contraint   Constraint a => a -> a    i need it to work on all a's with that constraint, but in case a is of a certain type then i want to apply a function to a, if it's not that type i just want to return a again
13:04:38 <Mibaz> I set up an independent study next semester for functional programming. I can do whatever project I want. Any cool suggestions??
13:04:38 <geekosaur> ph88, that's a "don't do that" mostly
13:05:33 <geekosaur> *sometimes* a typeclass may be appropriate. usually, you need to rethink what you are doing; that might make some kind of sense in e.g. Java, but is not really Haskell
13:05:46 <osfameron> Mibaz: that's a very broad question :-)
13:06:36 <ph88> https://paste.fedoraproject.org/471516/37636014/ this is how far i get
13:07:33 <ongy> Mibaz: get xmonad wayland ready. (I don't think you'd really want to do that)
13:07:40 <Mibaz> osfameron: it is :-)
13:08:14 <ph88> geekosaur, i was thinking of using ghc generics for this ^^
13:08:33 <ph88> Mibaz, a parser
13:09:08 <Mibaz> ongy: I couldn't find the box on the form to extend the study for 26 semesters ;)
13:09:33 <monochrom> ph88, type classes are designed and suitable for "if the type is Int, I want such and such". But not designed for "if the type is not Int Bool or Char, I want such and such".
13:10:00 <osfameron> Mibaz: so you *do* have an idea about the kind of things that you're capable of doing in the time you've got...
13:10:12 <monochrom> Even after adding all GHC extensions, they are still all designed around "if yes, do this", but not "if no".
13:10:18 <osfameron> it'd probably be a good idea to say what kind of thing you're interested in, and what kind of other ideas you've got...
13:10:28 <geekosaur> ph88, again, you should rethink what you are trying to do.
13:10:41 <monochrom> An example is type equality. We have an equality constraint. We don't have an inequality constraint.
13:10:49 <ab9rf> you can do a default implementation in the class definition
13:10:51 <geekosaur> not try harder and weirder ways to pretend to be writing some other language than Haskell
13:11:07 <ab9rf> but it looks what you're trying to do is implement dynamic typing
13:11:09 <Mibaz> ph88: That would be fun. Are parsers elegant in Haskell?
13:12:10 * younder is plodding throgh a NV PTX assebly manual trying to ind out what is making accelerate-cuda fail for newer cuda drivers.
13:12:32 <Mibaz> osfameron: Oh, yes, I'm fairly new to Haskell and have ~4 months. Wayland would be a bit out of my reach.
13:12:42 <ab9rf> ph88: try disabling the DMR?
13:12:45 <ph88> Mibaz, they are fast and work once they compile .. that's the main thing i think
13:13:06 <osfameron> Mibaz: heh, yes, I thought you were replying to the parser suggestion on first read :D
13:13:33 <monochrom> parsers are elegant and high level in Haskell.
13:14:03 <ph88> geekosaur, what about rethinking the tool, i know what i want to do ..
13:14:08 <ab9rf> ph88: but yeah, you look to be trying to do a dynamic dispatch akin to virtual methods in java
13:14:11 <Mibaz> osfameron: haha I hope I could get a parser done in 4 months ;)
13:14:25 <geekosaur> ues, we can tell, you want to write dynamic language
13:14:26 <monochrom> This is good for me, I like it. But you will find that this is bad for a lot of people. People who are stuck thinking low level and cannot digest the elegance.
13:14:26 <ab9rf> haskell typeclasses are not intended to support dynamic dispatch
13:14:38 <ph88> ab9rf, i don't write java but you could be right
13:15:09 <geekosaur> java was perhaps not the best example because, while it can do this, it's not really dynamic. javascript is fully dynamic, so are perl and python
13:15:10 <ab9rf> ph88: you're trying to make the code decide which of severeal different functions (or moethods) to call based on an value's type at runtime
13:15:24 <ph88> but with generics you can write functions over types and maintain type safety, no ?
13:15:27 <ab9rf> ph88: the same can be applied ot any OO language that supports dynamic dispatch (which is basically all of them)
13:15:28 <younder> There are many ways to write a parser. I like Mathematicas pattern matching.
13:15:37 <geekosaur> this is not an appropriate design for haskell, and you will write yourself into a corner if you try to force it
13:16:22 <monochrom> For example, you will find some beginners asking "where is the input buffer so I can random-access it at will?". No, this is a high-level parsing library, you don't random-access the input buffer at will. The input buffer is hidden from you so the library manages it for itself.
13:16:54 <ongy> which can be really annoying at times... stupid protocols that already exist
13:18:03 <ph88> have to switch train, be back later
13:18:12 * hackagebot pugixml 0.3.3 - pugixml binding.  https://hackage.haskell.org/package/pugixml-0.3.3 (NeilMitchell)
13:18:56 <monochrom> Another example is "the parsing output is a tree. therefore I need state to store the intermediate tree. where do I store state?"  No, that's an XYZ problem, all the "therefore"s are wrong. You don't need state just for that. You just need the return value being the tree (intermediate or final).
13:19:01 <zebr> hi all. is there any nicer way of writing `MaybeT . return :: Monad m => Maybe a -> MaybeT m a`? not that it's awful, it just feels like a common enough case.
13:19:18 <ab9rf> monochrom: i've got a parsing problem i've been trying to solve for ages which i know has an elegant solution that i constantly just out of my cognitive reach. everytime i get cloes to it, something interrupts me and i lose it.
13:20:29 <monochrom> (You can need state for a context-senitive grammar, even a Turing-complete grammar. You emphatically don't need state for context-free. All you need is stack, but recursive-decent already does that for you. You need nothing.)
13:21:09 <monochrom> (And yes, most Haskell parser libraries do recursive-decent. That's why so many non-Haskell people hate it.)
13:22:41 <Mibaz> monochrom: Being able to better grasp the elegance of functional code is a goal of mine, so this sounds good.
13:22:48 <monochrom> (Lastly, the parser libraries support state too. I'm just saying you don't need it until you step out of context-free. And you definitely don't need it for "intermediate tree" --- just make it a return value.)
13:23:23 <ab9rf> i'm still vaguely in awe of the people who figured out that types are differentiable.
13:23:26 <ongy> is binary/cereal a parser library?
13:23:36 <monochrom> yes
13:24:16 <ongy> how do I keep state with cereal? Short of wrapping it in GetT
13:24:19 <ongy> StateT that is
13:24:28 <monochrom> Or pass parameters around.
13:24:28 <younder> Context sesitivity can be 'faked' by having a variable remember the state. Push down automats are usually slow compared to recursive decent.
13:25:19 <monochrom> In fact yeah the parser libraries support state by doing the same thing as StateT which means it's just parameter passing all over again.
13:26:14 <monochrom> OTOH it does show you the beautiful theoretical result that parametrization is enough to get you Turing-completeness.
13:26:14 <ongy> when is haskell state not parameter passing?
13:26:28 <monochrom> when you use IORef or STRef or STM
13:26:35 <monochrom> or MVar etc
13:27:02 <ongy> soo, in IO
13:27:42 <nshepperd> isn't context sensitivity what you get when you use the Monad instance of, say, Parsec?
13:28:26 <nshepperd> you can extract info from previous parsed stuff and pass it as an argument to another parser
13:28:36 <monochrom> that sounds right, but I have to think it through
13:29:39 <monochrom> I am sure being Monadic steps outside of context-free already. I just haven't thought through whether it covers exactly context-sensitive no-more-no-less
13:33:05 <Lokathor> i wrote my own parser
13:33:58 <Lokathor> but it was a simple enough case to not call for a lib
13:34:00 <Lokathor> extractMessages :: ByteString -> ([IRCMessage],ByteString)
13:37:08 <monochrom> yes, it is easy to write your own too
13:38:53 <ertes> ph88^: are you sure you're not trying to do OO in haskell?
13:39:22 <Lokathor> writing the control system around the connection is... less obvious
13:39:36 <ertes> ph88^: very often when you make behaviour dependent on the type this is a strong warning sign that you're trying to do OO
13:40:07 <ertes> ph88^: the behaviour should only depend on the type, if the decision is actually static
13:42:46 <maerwald> https://hackage.haskell.org/package/gtk3-0.14.6/docs/Graphics-UI-Gtk-Abstract-Widget.html#t:Color ok cool... 
13:43:08 <maerwald> no constructor, no read instance, win
13:48:34 <Lokathor> so.. I have a type: type IRC a = ReaderT ConnectionEnv IO a
13:49:09 <Lokathor> is it a rational decision to put something that holds IRC a values into the ConnectionEnv?
13:49:20 <Lokathor> or would the circularness be bad?
13:54:31 <geekosaur> Lokathor, depends on laziness as to whether circularity would be bad, but I can't help but think this sounds like a less than ideal design
13:54:40 <Lokathor> fair
13:54:51 <Lokathor> i'll just pass it along manually
14:04:06 <Lokathor> so reading from and writing to an IORef are both atomic if done on their own?
14:05:54 <hamishmack> maerwald: It does have a constructor.  Hoddock just not picking it up.  Here is where it is defined https://github.com/gtk2hs/gtk2hs/blob/master/pango/Graphics/Rendering/Pango/Structs.hsc#L79
14:06:04 <maerwald> hamishmack: oh nice
14:06:32 <hamishmack> haskell-gi probably has a nicer version though
14:07:30 <maerwald> hamishmack: I'm trying to draw a colored frame around my Notebook, but gtk+ is so annoying, I have to create a GtkEventBox, adjust margins, then set background color of the eventbox... 
14:08:47 <ertes> Lokathor: there are a few designs for which it makes sense, but i can't imagine one that would be relevant to just keeping track of IRC state
14:09:05 <ertes> Lokathor: in fact i wouldn't even use ReaderT or define IRC
14:09:29 <Lokathor> mmm, but my socket fits so nicely into a ReaderT
14:09:40 <Lokathor> i guess i don't neeeeed readerT though
14:09:51 <ertes> it also fits into a ConnectionEnv passed as an explicit argument
14:10:01 <ertes> ReaderT over IO sounds more hassle than use
14:10:53 <Lokathor> funny, the other day i was told that it was a great design :P
14:11:00 <Lokathor> though that was for another sort of program i suppose
14:11:47 <Lokathor> the mangled up, "in between versions" code looks like this right now, http://lpaste.net/329449
14:11:56 <ertes> i don't think there is any program that would benefit from ReaderT except in the cases when the implicit argument is actually part of a monad with more semantics than "pass argument implicitly"
14:12:37 <ertes> and then again you don't have ReaderT…  you have WhateverT with a reader component
14:12:53 <Lokathor> the other program was with curses, where there are effectively a bunch of global vars floating around while curses is active, and i was holding them in a ReaderT of a record with all the IORefs
14:13:39 <ertes> you may be confusing *what* you pass (the record type, which is totally fine) with *how* you pass it (ReaderT as opposed to just a function)
14:14:48 <Lokathor> well, reader is for when you always need the context to persist but you don't always want to talk about it, i would say
14:14:50 <Lokathor> anyway
14:15:04 <Lokathor> reading and writing IORef values is atomic right?
14:16:34 <ertes> but you talk about it all the time anyway, don't you?  it's effectively "f x = …" vs. "c = do x <- ask; liftIO …", and i bet your code becomes simpler once you get rid of ReaderT =)
14:17:07 <Lokathor> depends
14:17:17 <ertes> remember that passing only has to occur at the top-level:  f x = …  where …  {- everything here can refer to x -}
14:17:28 <Lokathor> sendCommand :: Command -> IRC ()
14:17:28 <Lokathor> sendCommand cmd = sendMessage (IRCMessage Nothing cmd)
14:17:45 <Lokathor> here's a top level definition that is shorter as a result of the Reader context
14:18:04 <ertes> sendCommand :: Command -> ConnectionEnv -> IO ()
14:18:04 <ertes> sendCommand cmd = sendMessage (IRCMessage Nothing cmd)
14:18:08 <ertes> ;)
14:18:12 <Lokathor> ehhhh
14:18:25 <ertes> sendMessage :: … -> ConnectionEnv -> IO ()
14:19:17 <Lokathor> but i don't want the caller to have to bother with that, is really the deal here
14:20:07 <Lokathor> the person that uses sendCommand and the person that bothers to use ConnectionEnv are different personas of myself, even if they're not literally different people. They're different thought processes you might say
14:20:21 <Lokathor> and on the other hand, they really might litearlly be different people
14:22:24 <ertes> you don't have to defend your design, if you think it's good…  i'm just telling you: try writing it without ReaderT at least as an experiment, and in the end you might be convinced that just functions is generally an easier thought process for *both* parties
14:22:45 <ertes> and as a bonus it's most likely less code, too
14:23:14 * hackagebot rattletrap 0.1.7 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.1.7 (fozworth)
14:24:47 <Lokathor> i have done the no-reader version of things before :P
14:25:07 <Lokathor> when the call stack gets tall (conceptually if not literally) then it gets messy
14:25:52 <ertes> it didn't for me, mostly due to sharing…  just reuse the argument
14:26:34 <artzz> hello all. I am very new to haskell and I am trying a very simple example from haskell.com's wiki, but I am getting a non-exhaustive pattern error
14:26:50 <Tuplanolla> @paste
14:26:51 <lambdabot> Haskell pastebin: http://lpaste.net/
14:27:43 <ertes> if you do the ReaderT unmtling literally (i.e. rewrite (A -> ReaderT B M R) to (A -> B -> M R) instead of (B -> A -> M R)), you usually get less code than with ReaderT, because for the most part it's just the ReaderT style, but without the liftIOs
14:27:55 <artzz> thanks, it' s here http://lpaste.net/329456
14:28:11 <ertes> even with deeply nested applications
14:28:21 <artzz> I guess it has to do with the third parameter being a single element, but i tried to fix it and didn't work either
14:29:17 <Tuplanolla> The error is elsewhere, artzz.
14:32:13 <linduxed> so in ruby one can always write integer literals with underscores in them at arbitrary places. mostly this is used to separate every 10^3, like this: 4_500_000_000
14:32:35 <linduxed> is there some language extension that makes this possible in haskell
14:32:36 <linduxed> ?
14:32:41 <Lokathor> i feel like there is a GHC extension for that..
14:33:01 <linduxed> Lokathor: is there a GHC extension search engine or something to that effect?
14:33:15 <Lokathor> not that i know of
14:33:16 <Tuplanolla> There's `NumDecimals`, Lokathor and linduxed.
14:33:43 <Tuplanolla> You can write `4.5e+9` as an integer.
14:34:32 <artzz_> sorry my connection cut
14:34:40 <linduxed> Tuplanolla: oooh, didn't know that!
14:34:42 <linduxed> nice
14:35:56 <artzz_> Tuplanolla: is there a way to ask ghci to show how it 'unrolls' the function?
14:36:40 <Tuplanolla> There may be, but I haven't seen it, artzz_.
14:37:49 <artzz_> Tuplanolla: i am not sure how to proceed, do you have any hints on what is wrong there?
14:37:59 <Tuplanolla> The error is elsewhere, artzz_.
14:38:38 <EvanR> linduxed: there are quasi quoters for things like that
14:38:52 <linduxed> EvanR: "quasi quoters"?
14:39:06 <EvanR> it would look like [int| 4_500_000_000 |]
14:39:13 <EvanR> hypothetically
14:39:37 <Tuplanolla> Might as well use spaces, EvanR.
14:39:44 <Lokathor> linduxed, quasi quoters are template things that are basically fancy pre-processors on the code before GHC really goes to town
14:40:06 <linduxed> Lokathor: are we talking template haskell?
14:40:07 <EvanR> its template haskell but with arbitrary string as the input
14:40:30 <EvanR> which... you could also do with coolInt "4_500_000_000"
14:40:36 <EvanR> but you wouldnt have access to the TH environment
14:40:46 <EvanR> which you dont even need, so maybe go that route instead
14:41:03 <Lokathor> and please actually call it coolInt
14:41:50 <Lokathor> EvanR, if it were made with a quasi quoter though couldn't you have a compile time gurantee that you actaully wrote an int?
14:42:01 <linduxed> i think the built-in 4.5e+9 is good enough for my purpose
14:42:11 <EvanR> actually yes, that too
14:42:29 <EvanR> good point
14:43:26 <Tuplanolla> Make sure to keep the exponent a multiple of three to please the engineers and scientists in their natural habitat, linduxed.
14:43:46 <linduxed> Tuplanolla: i wouldn't ever consider anything else
14:43:57 <linduxed> i'd freak out if it wasn't that
14:44:06 <EvanR> the default float formatters doesn D:
14:44:17 <linduxed> did you know, btw, that the japanese go with powers of 4 instead of 3?
14:44:32 <linduxed> maybe not in science and whatnot, but in the language
14:44:42 <linduxed> they've got words that revolve around powers of 4
14:44:46 <EvanR> makes about as much sense as 3
14:44:50 <linduxed> sure
14:45:02 <linduxed> but it's a bit of a mental change when you learn that language
14:45:06 <linduxed> ALTHOUGH
14:45:07 <artzz_> Tuplanolla: ok i have no idea then
14:45:16 <linduxed> that ain't got nothing on the danish counting system
14:45:24 <linduxed> that thing is completely messed up
14:45:31 <geekosaur> roman numerals :p
14:45:33 <Tuplanolla> I have a paper from the Journal of the Physical Society of Japan on one of my workspaces, linduxed.
14:45:42 <linduxed> http://www.olestig.dk/dansk/numbers.html
14:45:49 <linduxed> geekosaur: no, danish is worse
14:45:56 <EvanR> https://hackage.haskell.org/package/roman-numerals
14:46:02 <linduxed> or maybe not
14:46:05 <linduxed> but they're both bad
14:46:50 <linduxed> Tuplanolla: is it in japanese?
14:47:00 <Lokathor> hmm, esperanto uses 10 / 100 / 1,000 / 1,000,000
14:47:24 <grantwu> Chinese also has words for 10,000 and 10,000^2
14:47:33 <Tuplanolla> No. I just had to check if their style carried over to English, linduxed.
14:48:27 <linduxed> i would assume it doesn't, considering english doesn't have those power-of-four oriented words
14:48:52 <linduxed> but i guess they could have had their numeric values be power-of-four oriented
14:48:54 <linduxed> :-/
14:48:56 <Tuplanolla> It looks like they opted to write "0.00018" instead.
14:52:21 <artzz_> Tuplanolla: does it has to do with not having defined the function type?
14:52:48 <Tuplanolla> No, artzz_. You're doing something else wrong.
14:53:38 <Tuplanolla> It's not in the paste.
14:53:51 <artzz_> Tuplanolla: yes but this works, http://lpaste.net/329461
14:54:28 <Lokathor> "Warning: Use foldr", what a fancy error to detect for and then warn about
14:55:07 <geekosaur> hlint is moderately strange in what it checks for
14:55:14 <artzz_> it seems to be the problem was to place it in ghci directly and not compile it in a separate file
14:55:28 <Tuplanolla> Oh, that would do it, artzz_.
14:56:05 <Tuplanolla> You need to slap them together with `:{` and `:}` if you write them into GHCi.
14:56:16 <Tuplanolla> Otherwise the latter line will shadow the former.
14:56:25 <artzz_> Tuplanolla: ahh great, thanks. and what else did you see wrong in the example?
14:56:57 <Tuplanolla> Nothing. It's `foldr` alright.
14:57:19 <oleks> Is pretty-show's ppShow pseudo-random?
14:57:46 <Tuplanolla> You can start GHCi with `-Wall` or `:set -Wall` in it to enable warnings though, artzz_.
14:57:57 <artzz_> Tuplanolla: thanks
15:05:31 <Athas> younder: for which drivers do you find that accelerate-cuda does not work?
15:10:05 <Stuart> Hi
15:10:27 <ertes> does GHC compute sums of literals at compile time?
15:10:28 <Stuart> From the Haskell book
15:10:32 <ertes> like 1 + 2 = 3
15:10:38 <Stuart> (<*>) :: Moi s (a -> b) -> Moi s a -> Moi s b
15:10:48 <Stuart> and newtype Moi s a = Moi { runMoi :: s -> (a, s) }
15:11:05 <Stuart> how do I implement (<*>)
15:11:09 <ertes> i'm trying to make sense of core, but it's like reading the necronomicon
15:11:45 <Stuart> ertes: It certainly seems like that
15:12:21 <Tuplanolla> Is it simplified Core, ertes?
15:13:06 <EvanR> Stuart: well, this is an exercise in following the types
15:13:16 <ertes> Tuplanolla: good question…  it's -ddump-simpl
15:13:39 <ertes> so it's *simplifier* core, but not sure about *simplified*
15:13:43 <Tuplanolla> Also `-dsuppress-all`, ertes.
15:14:11 <ertes> oh, nice…  thanks!
15:14:17 <ertes> that's super-helpful =)
15:14:19 <EvanR> Stuart: you have the type sig of (<*>) written, next begin the definition and maybe try putting _ where the implementation goes
15:14:38 <EvanR> _ is a hole, the compiler will tell you what the type of the hole needs to be and what the type of things in scope are
15:15:05 <EvanR> Moi x <*> Moi y = _
15:16:25 <Lokathor> hmmm
15:16:45 <Lokathor> i don't even remember what you put for the Moi problem
15:16:54 <Paprikachu> is there a way to define a 'named pattern' or a constant so that i can use it in pattern matching
15:17:16 <EvanR> first class patterns eh
15:17:25 <Tuplanolla> You're in luck, because `PatternSynonyms` is in town, Paprikachu.
15:17:35 <Paprikachu> does that work on hugs?
15:17:40 <monochrom> no
15:17:42 <Paprikachu> :)
15:17:52 <Lokathor> Paprikachu, try this: case foo where _ | foo == thingIDefined -> 
15:18:02 <Lokathor> er, replace "where" with "of"
15:18:45 <Paprikachu> well, i need four matches: _ 0, 0 _, 0 0 and x y where 0 is a more complex pattern
15:19:04 <Paprikachu> but i have an idea
15:19:07 <Aminadav> Hello everyone!. 
15:19:58 <Lokathor> ugly as it may be, you can nest case statements if you need to
15:20:10 <Aminadav> How I repeat a tuple. I tries: `repeat 10 (2,3)` but it don't work
15:20:19 <Aminadav> I want [(2,3),(2,3)] ...
15:20:20 <Stuart> (Moi f) <*> (Moi g) = Moi $ \s -> (fst (f $ (fst g s)), s)
15:20:25 <Stuart> Not sure yet
15:20:33 <Stuart> This doesn't work
15:20:37 <Lokathor> :t repeat
15:20:39 <lambdabot> a -> [a]
15:20:45 <Gurkenglas> :t replicate -- Aminadav
15:20:47 <lambdabot> Int -> a -> [a]
15:20:48 <Aminadav> The error I got:  * Couldn't match expected type `(Integer, Integer) -> t'                   with actual type `[Integer]'
15:21:07 <Aminadav> Gurkenglas Thank's
15:21:25 <Lokathor> repeat makes one thing into an infinite list of that thing, replicate gives you just X copies instead
15:22:39 <Aminadav> There is something similar to /*...*/ (multi-line comments) in haskell. I want to comment a a whole paragraph?
15:22:59 <Aminadav> I know about -- but I need to add it to each line
15:23:09 <Gurkenglas> Paprikachu, let no x y = if x == y then Nothing else Just y in f (no 0 x) (no 0 y) where f Nothing Nothing = ...; f _ Nothing = ...; f Nothing _ = ...; f (Just x) (Just y) = …
15:23:29 <monochrom> {- comment -}
15:23:50 <EvanR> Stuart: did you try the hole
15:24:24 <monochrom> you can also add more dashes. {---- comment --}
15:24:27 <Gurkenglas> (no's name being derived from lens's non)
15:25:42 <Paprikachu> Gurkenglas: i found a much easier solution for what i want to do, thanks though
15:26:09 <younder> Athas, : accelatete-cuda filas to buid. reports ... Data/Array/Accelerate/CUDA/Analysis/Launch.hs:91:3: Not in scope: ‘CUDA.optimalBlockSizeBy’
15:26:10 <monochrom> However, beware of this: {- x = "-}" -}
15:27:11 <Gurkenglas> Why don't we escape {}, then?
15:27:34 <monochrom> because I voted against it.
15:27:47 <geekosaur> younder, you do realize that that is an error in the Haskell binding and not the CUDA library itself?
15:28:04 <Gurkenglas> But then String has an unlawful Show instance according to the law I wish Show had
15:28:26 <monochrom> example?
15:28:51 <Gurkenglas> @show "{--}"
15:28:51 <lambdabot> "\"{--}\""
15:29:07 <monochrom> which law do you have in mind?
15:29:10 <Gurkenglas> show's supposed to generate strings that you can plug into haskell code to recover the value
15:29:42 <monochrom> after putStrLn or before putStrLn?
15:29:46 <geekosaur> does your proposed law also take into account random extensions (like, say, CPP)?
15:30:12 <monochrom> because putStrLn (show "{--}") successfully outputs legal Haskell code
15:30:14 <EvanR> i kind of wish Show didnt exist
15:30:17 <younder> geekosaur, yes. I figure there was some changes to the interface in Cuda 8.0 so it should be a simple matter to incorperate these.
15:30:26 <geekosaur> there is no 8.0 in this context
15:31:21 <monochrom> If you're seeing "\"{--}\"" you're looking at print (show "{--}") which is putStrLn (show (show "{--}"))  Do you see you're blaming the wrong guy?
15:31:22 <Gurkenglas> Oh, I mistakenly assumed {- in strings is as broken as -}, let me rethink
15:31:26 <Stuart> EvenR What do you mean the whoe
15:31:30 <Stuart> whole
15:31:30 <Athas> younder: oh, that sounds more like a problem with the Haskell CUDA package.
15:31:38 <EvanR> Stuart: did you read my original suggestion
15:31:39 <geekosaur> unless you know that cuda-0.7.5.1 builds differently if the FFI library is version 8.0
15:32:06 <geekosaur> (in which case, it should provide a way for dependents to find that out)
15:33:04 <Stuart> EvenR Yes I will try _
15:33:32 <EvanR> you can type Ev<tab> to spell peoples nicknames right
15:33:41 <EvanR> that start with Ev
15:34:01 <Stuart> Sorry EvanR
15:34:08 <geekosaur> younder, in fact optimalBlockSizeBy is not present in cuda-0.7.5.1 regardless of the FFI library version
15:34:31 <Stuart> I will try that. got to go
15:35:31 <geekosaur> younder, it was apparently replaced by optimalBlockSizeOf; compare http://hackage.haskell.org/package/cuda-0.7.0.0/docs/Foreign-CUDA-Analysis-Occupancy.html to http://hackage.haskell.org/package/cuda-0.7.5.1/docs/Foreign-CUDA-Analysis-Occupancy.html
15:35:52 <younder> geekosaur, Well to me it looked like the Cuda interface was generated from the header file and then the header changed and the haskell code used a declaration that does not exist anymore. 
15:36:15 <Gurkenglas> Okay no output of show will contain a top-level comment, so I can't give a breaking example without resorting to: Arbitrary code generated by show cannot be safely commented out without handling special -} cases. :/
15:36:16 <monochrom> Show Read printf scanf. You wish they didn't exist, but I pessimistic feel that human nature makes sure that they are doomed to exist and be entrenched.
15:36:30 <younder> geekosaur, That confirmed my suspicion.
15:36:54 <geekosaur> but this has nothing to do with the CUDA 8.0 FFI library
15:37:17 <geekosaur> it is a detail of the Haskell CUDA binding that changed in 0.7.5
15:38:24 <Gurkenglas> Wait why doesn't show "asd" produce "['a','s','d']", as instance Show a => Show [a] would dictate?
15:38:27 <younder> geekosaur, OK
15:38:44 <EvanR> monochrom: for debugging, repl support for pretty printing is better, for in-program pretty printing, pretty printing is better
15:38:48 <geekosaur> usually this means replacing something C-like with something more higher-order-Haskell
15:39:04 <Tuplanolla> The `Show` class has `showList`, Gurkenglas.
15:39:13 <EvanR> Read, is this even ever used
15:39:28 <monochrom> Char's showList gives you "asd"
15:40:05 <Gurkenglas> Ah ok I was expecting overlap hackiness or something phew :D
15:40:22 <geekosaur> haskell'98 doesn't have overlaps (nor does Haskell2010)
15:40:33 <geekosaur> and Show is specified by the Report
15:40:50 <Gurkenglas> EvanR, I used Show/Read for impromptu serialization when I didn't want to read into those libraries and figure out how to install them! :D
15:41:41 <EvanR> clojure comes with a proprietary thing specifically for serialize deserialize, like pickle
15:41:44 <younder> geekosaur, Speaking of hacking'ness where is this 'geekingfrog geekosaur' coming from?
15:41:47 <EvanR> too ;)
15:42:00 <EvanR> only it doesnt fully work in haskell
15:42:07 <EvanR> (Read/Show)
15:42:26 <geekosaur> you are pressing geek<tab> to complete my nick and there is also a user geekingfrog in the channel
15:42:44 <younder> aah sorry :)
15:42:47 <geekosaur> actually Geekingfrog but IRC nicks are case independent
15:43:03 <monochrom> I don't think monochrom is related to any other mono* either
15:43:08 <EvanR> case quotiented :D
15:43:44 <ab9rf> heh
15:43:49 <Tuplanolla> It is related to monologues, which it is a common source of.
15:44:14 <monochrom> monologues are a common source of confusion and quarrels.
15:44:29 <ab9rf> sqirrels?
15:44:48 <monochrom> whereas monochrom is a common source of wisdom
15:45:02 <ab9rf> squirrels are also a common source of wisdom
15:46:08 <EvanR> roadkill says otherwise
15:47:49 <Aminadav> How I get  all the possibilites of double 1..4?  (1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2) ....
15:48:00 <Aminadav>  ([1..4],[1..4])  -- This is what I tried
15:48:04 <ertes> i wouldn't mind using Read from time to time, but it's the epitome of the String problem =/
15:48:12 <Aminadav> This is what I got: 
15:48:13 <Aminadav> ([1,2,3,4],[1,2,3,4]) 
15:48:25 <monochrom> [ (x,y) | x<-[1..4], y<-[1..4] ]
15:48:54 <monochrom> actually liftA2 (,) [1..4] [1..4] is not too shabby either
15:48:55 <Aminadav> But I want a list of 16 tuples
15:49:04 <monochrom> yes you will get 16.
15:49:05 <Aminadav> Thank you @monochrom
15:49:16 <ertes> i wonder if we'll ever solve that problem, considering how long the AMP took, and that one was far less invasive
15:49:22 <Tuplanolla> Go further with `join . liftA2 (,)`.
15:49:45 <monochrom> No, don't.
15:50:07 <ertes> :k V2
15:50:09 <lambdabot> error:
15:50:09 <lambdabot>     Not in scope: type constructor or class ‘V2’
15:50:09 <lambdabot>     Perhaps you meant ‘E2’ (imported from Data.Fixed)
15:50:15 <younder> Tuplanolla, Too 'spicey' for a beginner ;)
15:50:23 <shirt> is it bad to run an executablle compiled with profiling in production?
15:50:38 <Tuplanolla> Alas that `.` was supposed to be `$`.
15:50:44 <Rarrikins> shirt: That can be useful if you use the profiling information to optimize.
15:50:50 <geekosaur> shirt, they tend to be a lot slower and leave profile output around
15:51:09 <geekosaur> but it's something to do if you specifically need that profiling information
15:51:36 <shirt> what about security?
15:52:35 <geekosaur> security may be an issue if someone can retrieve the profile output, although that is written only at exit so you can just scoop it up and remove it then
15:52:58 <monochrom> I included liftA2 (,) because I finally understood what Aminadav was thinking when they were trying ([1..4], [1..4]). They were thinking that (,) were distributive and would do the cartesian product for you. Which is exactly what liftA2 (,) does, to cartesian-product and distribute (,).
15:52:59 <Aminadav> How to filter a list [1,3,6,3,1,9,11] to all the sublist the summary to 10. For example: [  [1,3,6] , [1,9] )
15:53:18 <Aminadav> Where to start to do it? Do I must use recursion of function? Or I can do it somewhere with filters?
15:53:19 <geekosaur> otherwise, if someone can trick your app into divulging profiling infrmation while running, they can also trick it into divulging other information regardless of profiling
15:53:31 <monochrom> In other words I included liftA2 (,) because it says that they had the right idea, not because liftA2 is more advanced.
15:53:42 <shirt> ok thank you!
15:53:54 <Rarrikins> Aminadav: You want all sublists that sum to 10?
15:53:59 <Aminadav> Yes
15:54:05 <geekosaur> sounds like the list monad to me...
15:54:05 <monochrom> Whereas mentioning join is just because join is more advanced, no benefit.
15:54:51 <EvanR> so... simple way to get exceptions in other short lived threads to crash the whole program?
15:55:08 <glguy> EvanR: async package
15:55:22 <EvanR> yes, if the threads are being spawned by the main thread
15:55:47 <geekosaur> wrap each thread in a catch that throwTo-s the main thread?
15:55:52 <geekosaur> async probably automates this
15:55:56 <glguy> as long as you're making all your threads with async and linking them back to the spawner then it will work
15:55:57 <EvanR> sure
15:56:00 <Aminadav> @Rarrikins, Do you have a suggestions, how to do it, without recursion? or, in otehrs words. What it the most readable way, to achive that
15:56:00 <lambdabot> Unknown command, try @list
15:56:28 <EvanR> nope, threads are being generated by glfw-b bindings
15:56:36 <glguy> Then you're out of luck
15:56:42 <EvanR> is there a way to get access to the main thread?
15:56:46 <EvanR> programmatically
15:56:57 <glguy> Yeah, call myThreadId from the main thread
15:57:07 <EvanR> ah
15:57:11 <Rarrikins> Aminadav: It'll be recursive, but you can 'hide' the recursion.
15:57:30 <Rarrikins> Aminadav: Something like filter ((== 10) . sum) . subsequences
15:57:31 <monochrom> Aminadav: If you don't mind a slow algorithm, have one function to generate the list of all sublists, then you can use filter.
15:58:05 <monochrom> and the list of all sublists is something that can be obtained by "inits" and "tails"
15:58:19 <monochrom> But this is going to be quadratic time or cubic time
15:58:41 <monochrom> But I'm too lazy to recall and describe the linear-time solution.
15:58:43 <Aminadav> @monochrom. IT is sounds good. Because haskell is lazy, I hope that it will not really generate all the sublists for me
15:58:43 <lambdabot> Unknown command, try @list
15:58:58 <Aminadav> I will need to filter it in the end.
15:59:07 <monochrom> No, laziness is not "grant you 3 wishes".
15:59:15 <Rarrikins> Aminadav: It has to generate each in order to check whether it has the specified sum. If it leaves any out, it might miss one.
15:59:51 <monochrom> Yeah, use an information-theory argument to see why if you ask for the answer then all sublists will have to be generated and summed.
16:00:27 <EvanR> can anybody explain the value of floor (1/0 :: Double)
16:00:34 <monochrom> Well, if you only ask for "the first 4 sublists that each sum to 10", then sure the thing will stop after the 4th is detected.
16:01:16 <Rarrikins> EvanR: floor doesn't handle that properly.
16:01:32 <EvanR> clearly
16:01:40 <EvanR> except what would properly be
16:01:48 <Rarrikins> EvanR: Really, the maximum integer is a bit above that.
16:01:52 <monochrom> > floor (1/0 :: Double) :: Int
16:01:55 <lambdabot>  0
16:01:58 <monochrom> > floor (1/0 :: Double) :: Integer
16:02:00 <Aminadav> This is the question. I want to get in the end one list of 10 pairs (x,y). 
16:02:01 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
16:02:06 <EvanR> the maximum Integer ?
16:02:12 <monochrom> No I don't know how to explain that.
16:02:29 <Rarrikins> EvanR: Yep, floor of infinity should give you the integer part of infinity.
16:02:39 <Rarrikins> EvanR: Now that's close, but not quite it.
16:02:44 <Aminadav> 1<=x<=100   ,   1<=y<=100
16:02:58 <Tuplanolla> > fromInteger (floor (1 / 0 :: Double)) :: Double
16:03:01 <lambdabot>  Infinity
16:03:03 <EvanR> the integer part of infinity
16:03:06 <Tuplanolla> It gets better.
16:03:18 <monochrom> well at least it is reversible
16:03:25 <Tuplanolla> > fromInteger (floor (1 / 0 :: Double) - 1) :: Double
16:03:27 <lambdabot>  1.7976931348623157e308
16:03:37 <EvanR> oh interesting
16:04:11 <EvanR> are all doubles in that region integers
16:04:30 <Aminadav> I want one list of 10 pairs [(x,y), (x,y), (x,y), (x,y) , (x,y), (x,y), (x,y) , (x,y) , (x,y) ,(x,y)]. sum(x*y) must be less than 1000. y must be between 10 and 100. X must be between 1 to 90. At least one y must be 100
16:04:32 <EvanR> besides infinity
16:04:40 <Tuplanolla> How many bits would that require, EvanR?
16:04:58 <monochrom> yes
16:05:01 <Rarrikins> EvanR: Essentially, yes.
16:05:36 <Aminadav> I am coming from JavaScript. And I just started to learn Haskell. So I prefer Haskell way, and not just create function recursion and use them as I do in JavaScript
16:06:08 <ggVGc> has anyone here used the socket-io library? How do I make a blocking loop inside socketIO handler which waits for some condition and emits messages based on it?
16:06:17 <Rarrikins> Aminadav: Use a list comprehension with `take`.
16:06:48 <ggVGc> something like the first lines here, https://gist.github.com/90363102acd89f22697ca9e6d50c9549
16:07:11 <Aminadav> Rarrikins:: Here to put all my condition. How take helps?
16:07:32 <Rarrikins> Aminadav: `take` lets you take only the first so many elements from a list.
16:07:47 <Rarrikins> Aminadav: You said you want a list of 10 pairs, so you'd use `take 10` on the list.
16:08:10 <Rarrikins> Aminadav: It would be something like `take 10 [(x, y) | ...]`
16:08:49 <Aminadav> I don't know the (x,y). I want to create 10 pairs. And figure the x,y of all the pairs
16:09:22 <Lokathor> ggVGc, i'm unclear. Does this loop not already do what you want?
16:09:39 <Lokathor> oh, "this isn't valid"
16:09:44 <ggVGc> Lokathor: yes, but it's not correct. E.g it doesn't type check
16:09:54 <ggVGc> I'm not sure I can do what I want
16:10:03 <Aminadav> I have a real world problem.
16:10:07 <Aminadav> -- 1. My employer want to hire me for 10 projects.
16:10:11 <Aminadav> -- 2. My employer want to pay me a total of maximum $1000.
16:10:13 <Lokathor> i've done stuff with sockets, but not socket-io specifically
16:10:15 <Aminadav> -- 3. For each project I will take between $10 to $100
16:10:16 <ggVGc> Lokathor: also, that's not actually a loop.. but that's beside the point for now
16:10:19 <Aminadav> -- 4. For each project I will work between 1 hour to 90 hours
16:10:23 <Aminadav> -- 5. For at least one project I want to take $100.
16:10:29 <Aminadav> -- 5. The question is: How many hours, and how much to take for each project.
16:10:42 <ggVGc> you should learn to count first
16:11:34 <Aminadav> This is my question! I learn a book of Haskell. And try to solve my first real world problem. Working for 3 hours... and need help.
16:12:04 <ggVGc> well, so far you listed 6 things and counted to 5
16:12:33 <Aminadav> The last things. I don't need to count. This is the question, not one of the condition :)
16:13:01 <verement> EvanR: floor is defined in terms of properFraction, which is where I think the real issue lies
16:13:31 <Aminadav> I thought to create a pair. Of how much hours I'm working, and how much I take per hour (2,10)  mean 2 hours of $10 per hour.
16:14:09 <Lokathor> ggVGc, when you say socket-io... is this haskell or nodeJS?
16:14:12 <Aminadav> Then for example I need to find this list (  [1,10], [2,30],[3,40],[4,50]...). Number of pairs should be 10.  Total of 100 hours. Total of 1000 Dollar.
16:16:19 <ggVGc> Lokathor: haskell
16:16:19 <EvanR_> opinions on http://lpaste.net/329471
16:16:34 <ggVGc> EvanR_: too many 0s
16:16:38 <ggVGc> I prefer less 0s
16:16:51 <Lokathor> EvanR_, i like
16:17:13 <ggVGc> also, I'd like to be able to sleep negatvely so I can wake up before I went to bed
16:17:14 <Tuplanolla> Now `NumDecimals`, EvanR.
16:17:18 <ggVGc> those are my main concerns
16:17:48 <EvanR_> NumDecimals?
16:17:52 <obiwahn> I think haskell is a really cool language. Why doesn't it become a bit more stable? Everything is mutating all the time. ghc in debian got upgraded breaking xmonad-contrib-0.11.4. How is haskell used in production? Do you guys just install one target ghc and never change that?
16:18:30 <ab9rf> that is the strangest real-world problem i've ever seen
16:18:59 <Athas> obiwahn: you normally don't deploy GHC in production.  xmonad is kind of a weird case, since configuring it involves recompilation.
16:19:07 <Rarrikins> obiwahn: Usually, people will have a separate test server. They try upgrades on it. If the upgrades work out, then they upgrade the production server.
16:19:13 <Lokathor> obiwahn, there's a program called stack which has been out for a little while now, it manages versionioning on packages and compilers if you need consistent builds
16:19:29 <verement> EvanR_: I'd use (maxBound :: Int) instead of 1000000000
16:19:43 * EvanR_ imagines the default attitude being "meh we dont need consistent builds"
16:19:50 <EvanR_> being rather insane
16:20:08 <EvanR_> verement: well thing is... i remember that crashing on somepeoples computers
16:20:09 <Lokathor> esquelto and persistant aren't in lts-7.0 :/
16:20:10 <Lokathor> it's sad
16:20:19 <verement> oh?
16:20:22 <EvanR_> threadDelay maxBound causing an exception
16:20:23 <Darwin226> Is there a way to get nice behaving lenses for values that can only be gotten or set within some monad?
16:20:49 <Lokathor> (maxBound::Int) -5
16:21:07 <Tuplanolla> Remember that `Int` is only guaranteed to go up to `2 ^ 29 - 1`, EvanR.
16:21:08 <EvanR_> that also didnt work
16:21:24 <EvanR_> > 1000000000 < 2^29-1
16:21:26 <lambdabot>  False
16:21:29 <EvanR_> shoot
16:21:43 <obiwahn> Should I install a second ghc? Could that solve my problem? Is there something like nvm for node?
16:21:55 <verement> another option is nanosleep for large intervals, though I beileve that may not be as efficient
16:22:07 <Lokathor> obiwahn, what does nvm do?
16:22:12 <obiwahn> Lokathor: i'll look at stack
16:22:31 <obiwahn> it can switch between nodejs versions
16:22:59 <Athas> obiwahn: several GHC versions can coexist peacefully, but xmonad by default uses the one that is simply called 'ghc' in your PATH.
16:23:17 <Athas> If you want to use a specific version, then you must change your xmonad configuration (I'm not sure how).
16:23:46 <EvanR_> verement: nanosleep?
16:24:03 <verement> EvanR_: from System.Posix
16:24:56 <EvanR_> System.Posix dot...
16:25:12 <EvanR_> dont see it
16:25:52 <EvanR_> Unistd
16:25:57 <verement> EvanR_: http://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-Unistd.html#v:nanosleep
16:27:17 <EvanR_> none of these seem to play very nice with ghc runtime by default
16:29:33 <Lokathor> just sleep for 3ns at a time, most efficient
16:30:24 <EvanR_> the number 100000000, sanest magic number i can think of less than 2^29-1 is sleeping for 100 seconds at a time
16:30:36 <EvanR_> seems silly
16:30:42 <EvanR_> meh
16:30:53 <Lokathor> how long do you actually need the program to sleep for?
16:31:30 <EvanR_> however long it takes to not crash because it was passed a value that is rounded to a negative Int
16:32:03 <EvanR_> out of sight out of mind
16:32:04 <Lokathor> so you're *counting* on an overflow?
16:32:16 <EvanR_> im avoiding it
16:33:43 <EvanR_> Double/Integer -> Int
16:34:01 <Lokathor> ah
16:34:49 <Lokathor> so does it work to sleep in blocks of 100 seconds at a time?
16:35:09 <EvanR_> sure
16:35:20 <Lokathor> nifty
16:35:36 <Lokathor> i tried to emulate the erlang supervisor stuff one time, but couldn't get it to work quite right
16:39:02 <dimitrov> Is there a way to apply guards to an expression instead of a function argument or is that what case expressions are for?
16:39:18 <Lokathor> the latter
16:39:30 <monochrom> you can also use if-then-else
16:39:47 <monochrom> you can also turn on MultiwayIf and enjoy multiway-if
16:41:48 <dimitrov> Is there a document somewhere listing good haskell coding conventions? The one in the wiki is non-exhaustive
16:42:15 <Lokathor> i'm not sure you'll find an exhaustive style document anywhere
16:43:15 <lwm> dimitrov: sniff around in base for examples? https://github.com/ghc/ghc/tree/master/libraries/base
16:43:47 <monochrom> yikes :)
16:44:29 <dimitrov> lwm: Wasn't exactly what I was hoping for but that's one way to go about it
16:45:01 <Aminadav> This is more easy/ readble way to create this list? [ [(a,b),(c,d),(e,f)] | a<-[1..5],b<-[1..3],c<-[1..5],d<-[1..3],e<-[1..5],f<-[1..3] ]
16:45:47 <Aminadav> (List of pairs. Every fst should be 1..5 and every snd should be 1..3)
16:45:56 <dimitrov> It would be nice to have something like the iso c++ core guidelines for haskell
16:46:17 <jle`> Aminadav: do all three pairs have the same configuration?
16:46:39 <monochrom> I think what happened is that our coding convention is a more semantic level and design level "thinking pure-functionally" rather than micro-managing tweaks like "a 50-year debate on if-then-else vs guards".
16:46:50 <jle`> > liftA2 (,) [1..5] [1..3]
16:46:53 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,...
16:47:11 <jle`> > replicateM 3 (liftA2 (,) [1..5] [1..3])
16:47:14 <lambdabot>  [[(1,1),(1,1),(1,1)],[(1,1),(1,1),(1,2)],[(1,1),(1,1),(1,3)],[(1,1),(1,1),(2...
16:47:14 <monochrom> But then you don't need to write a long article on that. Because you just say "think pure-functionally", done.
16:47:23 <jle`> that should do it i think
16:47:36 <monochrom> OK, not done, but you can read John Hughes's "why functionally programming matters" for that.
16:47:40 <jle`> > replicateM 3 (liftA2 (,) "ab" "cd")
16:47:43 <lambdabot>  [[('a','c'),('a','c'),('a','c')],[('a','c'),('a','c'),('a','d')],[('a','c'),...
16:48:11 <jle`> or replicateM 3 ((,) <$> [1..5] <*> [1..3]) is that's your thing
16:48:43 <dimitrov> monochrom: Will check it out, thanks!
16:50:24 <jle`> Aminadav: basically, liftA2 (,) [1..5] [1..3] makes all pairswith [1..5] and [1..3], and replicateM 3 [x,y] = [[x,x,x],[x,x,y],[x,y,x]...], etc., all ways you can pick from x or y three times
16:50:44 <jle`> > replicateM 4 "01"
16:50:46 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
16:51:15 <Aminadav> @jle`. Thank you. But not working:     Variable not in scope:       liftA2 :: (a0 -> b0 -> (a0, b0)) -> [Integer] -> [Integer] -> t
16:51:15 <lambdabot> Unknown command, try @list
16:51:49 <monochrom> I don't understand that error message. There is a contradiction between "not in scope" and knowing its type.
16:52:00 <linduxed> so time and time again i hear people saying stuff like "records in haskell suck"
16:52:19 <monochrom> Yes I am saying that you have butchered the error message, it is no longer informative.
16:52:21 <linduxed> and this is a meme that has been going on for quite some time now
16:52:29 <jle`> Aminadav: you'll have to import Control.Applicative
16:52:29 <Gurkenglas> Aminadav, import liftA2 from Control.Applicative
16:52:34 <linduxed> as a somewhat casual user of haskell, i don't see the problem
16:52:56 <linduxed> anyone care to enlighten me as to why people often list this is a top-10 problem?
16:53:19 <monochrom> I do not agree that records in Haskell suck.
16:53:44 <monochrom> But I can see why it is in some kind of top-10 list. Because it is hard to find something worse to complain about.
16:54:03 <monochrom> I am also sure that "Haskell is not dependently typed" is on that list too.
16:54:28 <monochrom> Think of it as a first-world problem.
16:54:35 <Lokathor> well, records form functions (one per field), and functions get piled into a single namespace at any given scope
16:54:36 <Aminadav> Now. The import is working. But this is absolutle different result: liftA2 (,) [1..5] [1..3] gived me this list: [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,1),(5,2),(5,3)]
16:55:02 <Lokathor> so two fields with the same name can't exist in the program on different records without extra clarification
16:55:08 <Lokathor> so it can be annoying is all
16:55:56 <EvanR> linduxed: the field names thing
16:56:10 <EvanR> people want to call everything the same thing
16:56:36 <monochrom> Yes, people like to absolutely call everything by the same word.
16:56:37 <Rembane> And it can be solved with lenses, if you would like to have another problem to worry about. 
16:56:40 <Lokathor> i only ever want to call other people on IRC "EvanR"
16:56:59 <EvanR> name :: Fruit -> String, name :: User -> String, name :: OperatingSystem -> String
16:57:10 <Rembane> Lokathor: You can fix that with lenses you know.
16:57:32 <Cale> linduxed: Because there are so few other problems, mostly :P
16:57:45 <Lokathor> i'd have to write my own chat client
16:57:47 <osfameron> how do I load Test.QuickCheck in stack ghci, if I have it in deps for 'test-suite' but not 'library'?
16:57:53 <Lokathor> hexchat is probably in C, probably no lenses
16:58:15 <monochrom> Just over #haskell-beginners a beginner was quoting two books on how those two books introduce (>>=). They were literally "this function ... that function ... the first function ... the other function ... the function"
16:58:19 <osfameron> I see it was mooted in https://github.com/commercialhaskell/stack/issues/347 and there's a workaround suggested, but running ':l test/Spec.hs' still complains it can't find QuickCheck
16:58:20 <EvanR> on one hand we like avoid qualified stuff unless absolutely nec, then use single capital letters. on the other hand other languages recommend Using.The.Entire.Package.Name.For.Every.expression()
16:58:32 <monochrom> Two books doing that.
16:58:58 <monochrom> They absolutely haven't heard of "let's at least make up 3 names foo, bar, baz"
16:59:03 <Cale> linduxed: I guess it would perhaps be nicer if the field names, rather than being names of field extractors, were instead names of lenses to those fields.
16:59:20 <linduxed> hmmm, ok
16:59:42 <Cale> Some people want to be able to have the same field name in multiple record types... sometimes that might be nice, but mostly it would just be annoying imo.
16:59:43 <monochrom> oops, sorry, just one book. but it was Real World Haskell.
16:59:52 <EvanR> then wed have to use lenses to to extraction
17:00:10 <EvanR> and have kmettskell installed to use records
17:00:28 <EvanR> idris has nested update out of the box...
17:00:35 <EvanR> thats another thing linduxed 
17:00:42 <Cale> It's quite rare in my experience to really want polymorphism over all the record types which define a particular field.
17:01:09 <EvanR> not in web programming, where everything literally has the same field names
17:01:16 <EvanR> id, name, created_at, etc
17:01:18 <Cale> EvanR: well, we could just put view and set in the Prelude and that would be enough.
17:01:37 <Cale> You don't have to go whole hog with everything in Control.Lens
17:01:59 <EvanR> that would also increase the "get" operation by 1 word across the board
17:02:11 <Aminadav> Question about this: http://lpaste.net/329477
17:02:12 <EvanR> and add parens where there werent any before, in the case of partial apply
17:02:45 <Aminadav> I have created an algorithm that works for 3 pairs. How to make it dynamically to work to any size of pairs?
17:02:47 <monochrom> Haskell record syntax has its limitations and sometimes I run into them too. But I don't feel it important enough to complain. But I believe that a good first-world improvement would be row polymorphism.
17:03:07 <monochrom> (In other words for example I reject subtyping.)
17:03:16 <EvanR> extensible records with scoped labels, and extensible variants while theyre at it
17:03:46 <Rembane> Aminadav: Use a list of pairs instead of three pairs.
17:03:51 <monochrom> yeah, the dual of row polymorphism is open variants, I learned.
17:04:20 <Aminadav> @Rembane. Can you show me an example. How to change my code to work exactly the same algorithm for 4 pairs?
17:04:20 <lambdabot> Unknown command, try @list
17:04:33 <EvanR> which would go a ways to solving # 6 on that top ten list, managing a hetero univers of exception types
17:04:42 <monochrom> Some researcher made a small language to feature both. And explained they are duals so it's easier to do them together.
17:04:58 <Aminadav> See line #14 for example. It counts all the fst. and check that it is equal 5
17:04:58 <Rembane> Aminadav: I don't have your code, so I'm afraid I can't.
17:05:04 <Aminadav> http://lpaste.net/329477
17:05:06 <Aminadav> This is my code
17:05:19 <Rembane> Aminadav: Thank you. :)
17:05:33 <EvanR> "wah, i want weird additional exception types which seamlessly merge with random other exception types without making new sum types..." extensible variants
17:05:38 <Aminadav> This is my code. I want that the same algorithm will work for any long of list. 
17:06:17 <Rembane> Aminadav: I see. I'll give it a shot. 
17:06:18 <Aminadav> Now it is working only for list of 3 pairs (see for example line #14 that sum all the fst item of all the apris)
17:06:25 <Aminadav> Thank you!
17:06:59 <Cale> monochrom: Yeah, it would be nice to have Ermine-style row polymorphism in some cases -- in the cases where row polymorphism is nice, something like that is especially nice.
17:07:48 <Rembane> Aminadav: It doesn't sum all the first items of the pairs, it sums the first pair, then the first item of the second pair. Is that a bug?
17:08:13 <Aminadav> No. It is not a bug.
17:08:15 <Cale> EvanR: We already kind of have that?
17:08:34 <Lokathor> purescript has cool row polymorphism, but they also insist on having explicit forall on every signature even the basic stuff, which is annoying as frick
17:08:41 <monochrom> we use type class for the openness.
17:08:50 <Aminadav> Maybe I didn't explain here exactly what I need. But this code works for me. Now I want it to work for 10 pairs. But I don't want to do (a,b),(c,d),(d,e),(f,g),(h,i),(j,i)...
17:08:56 <Cale> EvanR: The existing Control.Exception mechanism is extremely general -- you can make new refinements of existing exception types, as well as arbitrary unions.
17:09:06 <monochrom> but it's open class/type rather than open sum type
17:09:26 <Cale> and like, weird views and stuff :)
17:11:28 <Rembane> Aminadav: a+b+c always be 5 regardless of how many pairs you have?
17:11:36 <Aminadav> Yes.
17:12:13 <Aminadav> Maybe I will change 5 to another number. But it is not depends on the number of the pairs
17:13:33 <monochrom> @type replicateM
17:13:35 <lambdabot> Applicative m => Int -> m a -> m [a]
17:14:06 <monochrom> > replicateM 5 [1,2,3]
17:14:08 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1,...
17:14:21 <Aminadav> My question in StackOveflow: http://stackoverflow.com/questions/40444687/haskell-how-to-change-algorithm-to-work-on-any-size-of-list
17:15:13 <monochrom> @type sequence
17:15:15 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
17:15:28 <monochrom> > sequence (replicate 5 [1,2,3])
17:15:31 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1,...
17:15:50 <monochrom> \∩/ I understand replicateM now. (axiom: I already understand sequence.)
17:16:57 <Gurkenglas> Aminadav, you aren't multiplying all the x's, those would be a*c*f
17:17:00 <Rembane> Aminadav: Cool, I'm afraid I'm at a loss.
17:18:13 <Aminadav> You right. I mean sum all the multiple of x*y
17:18:17 <monochrom> can you edit "a;;" to "all"? :)
17:18:18 <lpaste> Gurkenglas annotated “No title” with “Aminadav, here” at http://lpaste.net/329477#a329480
17:18:23 <Aminadav> @Rembane
17:18:24 <lambdabot> Unknown command, try @list
17:18:43 <monochrom> Also, please simply drop the "@". You should see why by now.
17:19:38 <monochrom> > replicateM 3 (liftA2 (,) [1..5] [1..3])
17:19:41 <lambdabot>  [[(1,1),(1,1),(1,1)],[(1,1),(1,1),(1,2)],[(1,1),(1,1),(1,3)],[(1,1),(1,1),(2...
17:20:14 <monochrom> I think it is the full list you want. Now you just have to filter it.
17:20:14 <Rembane> Aminadav: Aha. Can you explain what this algorithm should do? What goals should it achieve?
17:20:21 <Aminadav> I had an issue in line 15. I mean a +c + e. Not a+b+c
17:20:39 <hololeap> Aminadav: do they have to be unique pairs?
17:20:59 <lpaste> Gurkenglas annotated “No title” with “Aminadav, or like so” at http://lpaste.net/329477#a329483
17:21:02 <soLucien> how can I build an escape sequence in Parsec ?
17:23:58 <Aminadav> No. This don't need to be unique
17:24:07 <Aminadav> I'm checking you solutions
17:27:08 <Aminadav> Thank you, every one. But there is a problem. When I work on pair of 10 size. It is never finish...
17:27:25 <Aminadav> I need to change something to work. It is very slow.
17:28:07 <monochrom> > filter (\list -> sum (map fst list) == 5 && sum (map (\(x,y) -> x*y) list) < 6 && any (\(x,y) -> y==3) list) (replicateM 3 (liftA2 (,) [1..5] [1..3]))
17:28:09 <lambdabot>  []
17:29:20 <Aminadav> This is the story. (not real story, but for the algorithm). My employer want to hire me for 10 projects.
17:29:55 <Aminadav> For each project I can choose how many hours to work, and how much dollar asking for.
17:30:34 <monochrom> actually people have already posted solutions like mine on your http://lpaste.net/329477
17:33:08 <Aminadav> Thank you for your solution
17:33:34 <monochrom> it is going to be slow. it is brute-force.
17:34:01 <Aminadav> So. Do you have any better suggestions?
17:34:09 <monochrom> No, I'm too lazy to do it.
17:35:19 <soLucien> is it possible to pass a type as an argument to a function ? As in i have type Apple = String and type Peach = String
17:35:42 <grantwu> So, if I have a GADT data Foo a = One :: Constr1 Bar -> Foo Type1; Constr2 Baz -> Foo Type2
17:35:49 <monochrom> Yes use Data.Proxy. No, Apple and Peach are indistinguishable.
17:35:58 <soLucien> is it possible to create the method parseFruit :: t -> Parser FruitAst where i define
17:36:02 <grantwu> Is it possible to write a function which works for all sort of Foos?  What does the type signature look like?
17:36:17 <soLucien> parseFruit Apple = something and parseFruit Peach - somethingElse ?
17:36:17 <grantwu> soLucien: Why not have data Fruit = Apple String | Peach String
17:36:41 <soLucien> well i'm not allowed to change these types
17:37:02 <exio4> Apple and Peach are the same in the type system
17:37:08 <exio4> they're both String(s)
17:37:12 <soLucien> i see
17:37:22 <soLucien> so i'll have to pass a string there 
17:37:26 <EvanR> parseFruit :: t -> Parser FruitAst cant make use of the argument
17:37:30 <EvanR> its too polymorphic
17:37:36 <soLucien> cool , i'll just do parseFruit "Apple" = ...
17:37:37 <exio4> grantwu: Foo a -> Bool 
17:38:13 <grantwu> exio4: Oh, hrm, I guess I don't need to use forall?
17:38:20 * hackagebot HDBC-mysql 0.7.1.0 - MySQL driver for HDBC  https://hackage.haskell.org/package/HDBC-mysql-0.7.1.0 (ryantm)
17:39:19 <grantwu> if you have type Apple = String and type Peach = String, you are basically saying that Apples are Peaches
17:40:39 <EvanR> and theyre both linked list of Char
17:40:46 <EvanR> which makes even less sense
17:41:06 <exio4> grantwu: first-order quantification (iow the only quantification available in vanilla Haskell) is optional 
17:41:18 <soLucien> i understand .. i will pass in these arguments as String state .. parseFruit :: String -> Parser FruitAst
17:44:23 <EvanR> whats with the word argument ...
17:44:32 <EvanR> how does that work
17:44:53 <hololeap> i'm looking at liftA, and it seems like it does the same thing as fmap, just in a different way
17:45:21 <exio4> it is fmap implemented with applicative operators
17:45:43 <exio4> it can be used so you can implement Applicative and get Functor "for free" (fmap = liftA)
17:45:54 <exio4> just like you can use ap for (<*>) if you have Monad :)
17:46:08 <EvanR> the mathematical etymology escapes me
17:46:11 <exio4> @type ap 
17:46:13 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:46:34 <geekosaur> and liftA* parallel liftM* (and indeed, liftM is also fmap built from (>>=)
17:48:56 <hololeap> what is the point of that
17:49:36 <geekosaur> historical
17:49:50 <EvanR> so you can define a triple of Functor Applicative and Monad in a mutually recursive way
17:49:51 <grantwu> Uh, does anyone know about adding strictness annotations to newtypes causing compiler bugs?
17:49:54 <geekosaur> Monad originally did not require Functor, and Applicative didn't exist
17:49:56 <EvanR> that does nothing
17:50:01 <grantwu> Specifically,  isInjectiveTyCon sees a TcTyCon C0Type
17:50:06 <geekosaur> liftM* and ap were Applicative before there was Applicative
17:50:41 <hololeap> ok, makes sense. that's probably why they are pushed into Control.* instead of being in Prelude
17:51:05 <EvanR> even now that it requires Functor, you still might want to implement fmap in terms of >>=
17:51:32 <hololeap> are they not totally equivilent?
17:51:47 <hololeap> fmap, liftA, and liftM
17:51:55 <EvanR> should be
17:51:57 <geekosaur> yes, it's a nice way to retrofit Applicative onto old Monad instances when compiling in newer versions that require the Applicative constraint
17:52:37 <hololeap> ok
17:52:52 <geekosaur> use liftM to get Functor (fmap) and ap to get Applicative (<*>) and you are upgraded for the new world
17:54:13 <grantwu> Hrm, apparently the  isInjectiveTyCon sees a TcTyCon  issue has only been reported for TypeInType
17:54:16 <Aminadav> Thank you everyone. Leaving
17:54:50 <hololeap> yeah, otherwise i would just say that you are requiring a Monad more explicitly in the code. func = fmap :: Monad f => (a -> b) -> f a -> fb  (or something less obtrusive)
17:55:48 <EvanR> i think outside instance definitions its vastly more conventional to just use fmap
17:56:20 <hololeap> ok, that's what i thought
17:57:03 <geekosaur> right. it used to be more important to use liftM because there was no guarantee that fmap was available, since Monad didn't require Functor
18:07:06 <onintza> Some "Foldable t => t (a -> Bool) -> a -> Bool" that given a list of conditions and something to apply them on, returns true iff all conditions hold?
18:07:41 <EvanR> :t all
18:07:42 <Cale> @let swing f c a = f ($ a) c
18:07:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:07:44 <lambdabot>  Defined.
18:07:54 <Cale> :t swing all
18:07:56 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
18:08:16 <EvanR> (hmm... a foldable law?)
18:08:17 <onintza> wohoh, that swing is black magick
18:08:26 <onintza> EvanR: not exactly what i want
18:09:16 <Cale> Well, all is pretty much what you want, just need to turn the thing you want to apply your conditions to, x, into a function ($ x)
18:09:27 <Cale> (which is all that swing does)
18:09:31 <Cale> :t swing map
18:09:33 <lambdabot> [a -> b] -> a -> [b]
18:09:42 <Cale> :t swing partition
18:09:44 <lambdabot> [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
18:09:46 <Cale> heh
18:09:54 <Cale> :t swing zipWith
18:09:56 <lambdabot> [a -> b -> c] -> a -> [b] -> [c]
18:10:06 <onintza> This is very neat
18:10:24 <Adluc> Is there hoogle-like something, which knows all hackage packages?
18:10:42 <LordBrain> install it
18:10:44 <LordBrain> hoogle
18:10:52 <geekosaur> @where hayoo
18:10:52 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
18:11:11 <LordBrain> hoogle can know about anything and everything on hackage tho
18:11:24 <LordBrain> you just have to add it to a local database
18:12:09 <LordBrain> its generally nicer having it local in the command prompt anyway
18:12:53 <LordBrain> you'll have to rebuild the database everytime you install a package or whatever, and you can have multiple databases around and combine databases
18:14:32 <grantwu> http://lpaste.net/329484 Is there a solution to this issue that doesn't require unsafeCoerce?
18:17:04 <exio4> grantwu: what is C0FunType?
18:17:57 <grantwu> Added
18:18:22 * hackagebot hmatrix-gsl-stats 0.4.1.4 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.4 (VivianMcPhail)
18:18:26 <grantwu> Wait, there's more missing, I think
18:18:36 <exio4> grantwu: move the forall
18:19:05 <grantwu> Uh... where should it ve moved to?
18:19:55 <exio4> grantwu: newtype C0SizedType = forall x y. C0Sizedtype { ... }
18:21:01 <exio4> grantwu: with your current code, the record accessor would need to have type C0SizedType -> (forall x y. C0Type x y 'KnownSize)
18:21:01 <jvanbure>  exio4: I'm getting  "A newtype constructor cannot have existential type variables"
18:21:14 <exio4> which means you have to use data =)
18:21:51 <jvanbure> aha... magical...
18:22:05 <jvanbure> why doesn't it work with newtypes?
18:23:03 <jvanbure> I was attempting to get rid of runtime overhead for it, but if it's changed to a data, there will be some extra cruft
18:23:56 <exio4> jvanbure: an existential type will always add some overhead, I think, I am not sure how GHC deals with this
18:23:57 <jvanbure> would the unsafeCoerce + opaque constructor method of inserting things into the newtype achieve that? or am i mixed up as to what that would do
18:24:16 <exio4> jvanbure: nop, your newtype is not saying what you mean
18:25:26 <exio4> the opaque constructor isn't the issue, it's that pattern matching on a C0SizedType will give supposedly give you a C0Type x y 'KnownSize for any x,y 
18:25:43 <exio4> well, I think in this situation it could mean just losing type information
18:26:15 <exio4> which is already lost if you use existential types, hmm
18:26:28 <jvanbure> i thought that this was okay given that the GADT gives us every possible instance of C0Type _ _ 'KnownSize
18:26:41 <exio4> looks like so
18:28:44 <jvanbure> exio4: thanks for the help :)
18:30:54 <ggVGc> do you guys use ApplicativeDo?
18:32:20 <grantwu> Are you asking jvanbure and I specifically or
18:32:28 <ggVGc> no, in general
18:41:50 <EvanR> i might now that i realize what it does
19:01:22 <aminadav> Why I get this error:     * Couldn't match type `Integer' with `(Integer, Integer)'       Expected type: (Integer, Integer) -> Integer         Actual type: Integer -> Integer     * In the first argument of `canMove', namely `(+ 1)'       In the expression: canMove (+ 1) (+ 2) [(1, 1), (1, 3)]       In an equation for `y': y = canMove (+ 1) (+ 2) [(1, 1), (1, 3)]
19:02:25 <aminadav> My code: http://pastebin.com/uhdJ8d12
19:05:20 <EvanR> aminadav: put a type signature on canMove to see if either you are the compiler have gone insane
19:05:29 <EvanR> you or the compiler*
19:05:34 <aminadav> Ok
19:05:45 <geekosaur> it is telling you that you passed something of type Integer -> Integer (namely (+1)) to something expecting (Integer, Integer) -> Integer
19:06:50 <EvanR> apparently its expecting (Integer,Integer), but perhaps no one knows what aminadav is expecting without a type sig
19:07:48 <aminadav> This is my new code: http://pastebin.com/Gz4BjTZA
19:07:57 <aminadav> And new error:    * Couldn't match type `Int' with `Int -> Int'       Expected type: [(Int -> Int, Int -> Int)]         Actual type: [(Int, Int)]     * In the second argument of `elem', namely `list'       In the expression: (x (fst lastMove), y (snd lastMove)) `elem` list       In a stmt of a pattern guard for                      an equation for `canMove':         (x (fst lastMove), y (snd lastMove)) `elem` list
19:08:34 <EvanR> if x is a function with 2 args, and you use it on 1 arg, now its a function with 1 arg, not an Int
19:08:49 <aminadav> (+1) You right. (+1) get only one argument
19:09:24 <EvanR> practice getting the type sig consistent with what you want, and then work on getting the code right, in that order
19:10:47 <pavonia> Btw, "| a `elem` b = True | otherwise = False" is the same as just "= a `elem` b"
19:11:47 <aminadav> Thank you
19:12:01 <Gurkenglas> And you can write x and y instead of (x) and (y)
19:13:24 * hackagebot regex-do 1.0 - PCRE regex funs  https://hackage.haskell.org/package/regex-do-1.0 (procione)
19:41:13 <aminadav> Very simple task, not working as expected for me: http://stackoverflow.com/questions/40445481/haskell-why-the-knight-not-move-all-over-the-table
19:41:28 <aminadav> I try to move the knights all over the table, from (1,1). What's wrong/
19:54:55 <pavonia> aminadav: I think you need some kind of backtracking. Your code will always succeed on the first move that matches but will then apparently fail later
19:56:07 <aminadav> @pavonia: thank you
19:56:07 <lambdabot> Unknown command, try @list
20:02:39 <EvanR> "silly lisp and its hypersensitivity to parentheses" ... ((*) >>=) vs ((*) (>>=)) ... haskell too
20:06:53 <soLucien> is there something like "parse until you get a certain character" in Parsec ?
20:07:06 <soLucien> parse until \n without consuming it
20:12:16 <EvanR> you mean, get a String of the input up to a point?
20:12:36 <EvanR> thats usually counter productive, you want to consume and process that string with a parser
20:13:34 <EvanR> but you can do what you said with lookAhead
20:14:09 <pavonia> Can't you just use manyTill with a (/= '\n') predicate?
20:15:17 <hrqaa> I'm trying to start writing a program that, given an input of a long string of words combined together (ex. "thedogran"), segments the words according to a dictionary
20:15:22 <pavonia> Ah, that consumes the end too
20:15:31 <hrqaa> Is there a general approach that I should start with?
20:15:48 <EvanR> it consumes something at all, which soLucien said they didnt want
20:16:57 <EvanR> hrqaa: heh... a very large pattern matching automaton, where the dictionary is your regex
20:17:17 <hrqaa> Hmm. Reading this rn: http://stackoverflow.com/questions/5310756/split-a-string-to-a-string-of-valid-words-using-dynamic-programming
20:18:07 <pavonia> soLucien: Do you want the parser to not consume at all, or not consume only \n?
20:18:33 <soLucien> leave \n there
20:18:38 <soLucien> consume evrything until \n
20:18:57 <hrqaa> EvanR, I feel like having the dictionary in trie form would be good
20:19:24 <pavonia> soLucien: Then a combination of manyTill and lookAhead should work
20:19:55 <EvanR> yeah
20:20:24 <EvanR> check your current prefix in the trie, if its not unique, keep going, else return a match and drop the prefix, and keep going
20:21:08 <EvanR> if there are zero matches for this prefix... drop the prefix without emitting anything
20:25:27 <hrqaa> Is there a reason type inference for lamda-defined functions differs from normally defined functions?
20:29:34 <MarcelineVQ> I'm not aware of that being the case, did you have a specific example?
20:37:17 <EvanR> i do remember there being an oddball edge case with that...
20:45:26 <soLucien> would it be ok if i re-parsed a returned string from Parsec ?
20:45:51 <soLucien> i am thinking, but i can't figure out how to implement escape sequences
20:51:23 <EvanR> you probably should parse it normally
20:51:50 <EvanR> thats the point of the parser combinators, to not try to parse everything separately and repeat the verbose glue between them every time
20:52:04 <soLucien> EvanR basically it's something like manyTill anyChar (lookAhead endOfLine)
20:52:17 <soLucien> but i want \\\n to be an escape sequence
20:52:23 <EvanR> no, what are you really trying to parse?
20:52:36 <EvanR> what is on that line
20:52:54 <soLucien> any char except \n
20:52:59 <EvanR> when you have parser p for *that*, then parsing the line is p >> endOfLine
20:53:21 <EvanR> what are you going to do after you have that line of chars ?
20:53:39 <soLucien> so i parse any char except \n . Now i want \\\n to escape \n
20:54:08 <EvanR> and what are you going to do with THOSE chars
20:54:24 <soLucien> so that i can have "foo\\\n bar \n" to get parsed into "foo bar"
20:54:38 <EvanR> this doesnt sound like much of a parser
20:54:39 <soLucien> just like multiline strings in Haskell
20:54:43 <EvanR> its a string replacer
20:55:16 <soLucien> you know .. you can do \ at the end of the line , and enter and you carry on writing the second string
20:55:19 <soLucien> sorry 
20:55:26 <soLucien> the same string on the second line
20:56:22 <soLucien> does it make sense?
20:56:33 <EvanR> it sounds like you want a parser that gives you back "normal char" (either consume 1 char OR consuming 2 and unescaping) OR "end of line"
20:56:44 <EvanR> and you repeat that parser until you want to stop
20:56:56 <EvanR> and youll be left with yet another string of the form youre asking for
20:56:57 <soLucien> yes i had a similar thaught
20:57:15 <EvanR> but this is a thing youd do with a string replace in javascript
20:57:28 <EvanR> youre not really parsing
20:58:38 <soLucien> there's an issue though if i were to replace
20:59:00 <soLucien> the parser would stop at the first \n it finds
20:59:53 <soLucien> which would be "foo \\\n" instead of going all the way to "foo \\\n bar \n" then performing replace "\\\n" with ""
21:00:58 <hrqaa> MarcelineVQ, Oops sorry for not getting back. It had to do with Monomorphism restriction, but I guess it's not a thing in ghc 8
21:01:25 <EvanR> what parser? youre just trying to unescape
21:01:30 <hrqaa> MarcelineVQ, I've read about it as "the dreaded", etc. Is it still a problem?
21:02:00 <soLucien> EvanR i am trying to correctly parse escape sequences
21:02:16 <EvanR> it sounds like youre trying to correctly unescape escape sequences
21:02:19 <EvanR> String -> String
21:02:24 <soLucien> so the parser should first consume the inpyt
21:02:26 <soLucien> input
21:02:36 <soLucien> before it runs the unescape thing
21:03:06 <EvanR> lpaste an example of input and what you expect it to come out as
21:04:19 <soLucien> EvanR http://lpaste.net/329503
21:04:59 <EvanR> past more
21:05:02 <EvanR> more input
21:05:16 <EvanR> more lines
21:06:38 <EvanR> because with this poor example, i can suggest that you do f xs = Line (remove ["\\", "\n"] (init xs))
21:06:41 <soLucien> http://lpaste.net/329503
21:07:05 <EvanR> ok, so you are trying to output a list, not a Line
21:07:17 <soLucien> yes, Line is an atom
21:07:18 <EvanR> and are there any other ctors besides Line
21:07:24 <soLucien> yes
21:07:56 <EvanR> and it begins wtih a \n, are you sure you dont want [Line "", Line "before the foo there was the bar", Line "foo bar"]
21:08:10 <slack1256> Did I get this right? because of the copying GC, you need *twice* the amount of memory for the memory of live data. Is that correct?
21:08:24 <slack1256> not criticing, seems reasonable, I want to understand some gc summaries
21:08:28 <EvanR> thats true in the most basic copying collector
21:08:29 <soLucien> yes, i want non-empty lines
21:08:39 <EvanR> alright, so heres your "parser"
21:08:56 <slack1256> EvanR: is it true in general on haskell?
21:09:01 <soLucien> apologies for not making this clearer earlier, it made sense in my head the way i explained it :D
21:09:10 <EvanR> filter (not . null) . map (replace "\\\n" "") . lines xs
21:09:31 <EvanR> ... well no that wont work
21:09:34 <soLucien> i have to use Parsec
21:09:38 <slack1256> I got (known) 30 Mb of live data, and I got reported 70 Mb of "total memory in use" by +RTS -s -RTS
21:10:06 <soLucien> so i was thinking of something like
21:10:12 <soLucien> parse anything except \
21:10:21 <soLucien> if it's a \ look at the next character
21:10:22 <EvanR> you certainly have more space available than youre using, and you can tune it, but im not sure about the specific numbers
21:10:56 <soLucien> if it's supposed to be escaped, parse it 
21:11:03 <soLucien> otherwise carry on until \n
21:11:11 <EvanR> soLucien: so, first do replace "\\\n" "", then lines
21:11:21 <EvanR> then filter out empty lines
21:11:29 <soLucien> i can't replace \\\n
21:11:33 <soLucien> because i never get past it
21:11:34 <EvanR> why not?
21:11:44 <soLucien> the parser consumes input
21:11:48 <soLucien> until it reaches \n
21:11:56 <EvanR> i am suggesting to you, you dont have a parser
21:12:06 <EvanR> just based on your examples so far
21:12:20 <soLucien> ah .. i am writing a parser for this kind of grammar
21:12:30 <soLucien> if it was just string manipulation it would be way easier
21:12:46 <EvanR> as youve explained it, that is what it is
21:13:06 <EvanR> so far theres no indication you need to figure this parsec issue out
21:15:52 <soLucien> EvanR i added the parsec combinator
21:16:06 <soLucien> to the lpaste
21:16:19 <EvanR> to do it the parsec way, make a parser for a Line, repeat that parser until you get to whatever terminates this thing, which you havent explained
21:16:24 <EvanR> with manyTill
21:16:59 <EvanR> or many1
21:17:28 <EvanR> to make the parser for a line, use another parser which consumes characters, either one or two depending on if it sees escaping
21:17:31 <EvanR> break it down
21:18:20 <soLucien> i understand
21:22:15 <gfixler> watching a Conal talk, have a question
21:22:34 <gfixler> sumSquare :: (Functor f, Foldable f, Num a) => f a -> a
21:22:52 <gfixler> he says the signature could be inferred, especially with the monomorphism restriction turned off
21:22:57 <gfixler> I'd like to understand what that means
21:23:17 <pikajude> which part, the monomorphism restriction?
21:23:21 <gfixler> yes
21:23:29 <glguy> Google for "monomorphism restriction"
21:23:35 <gfixler> I did - reading up on it
21:23:42 <glguy> It's also described in the Haskell Report
21:25:54 <glguy> There's also a write up on the Haskell Wiki that covers the topic
21:26:02 <gfixler> that's the one I'm reading now
21:27:01 <gfixler> ah, I think I don't run into it because I mostly just screw around in GHCi, where it's turned off
21:27:23 <Clint> i am apparently made anxious by use of the phrase "monomorphism restriction" not preceded by "dreaded"
21:27:40 <glguy> Yeah, please leave the "dreaded" out of is
21:27:41 <glguy> it*
21:28:03 <EvanR> "If all the library authors could do this we can get back to hackage being a great source of documentation again." --glguy, reminiscent of a trump campaign slogan
21:28:20 * EvanR looks for a script like this
21:28:30 <EvanR> (to upload docs)
21:28:48 <EvanR> https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh ?
21:28:52 <glguy> EvanR: Here's what I made, you almost don't need a script any more ^
21:29:08 <glguy> It used to require more than two commands to do :)
21:29:31 <EvanR> i had something similar but it was adhoc and is between my computers floor boards somewhere
21:30:06 <bobajett> noobie question: in Real World Haskell there is a function defined like so:
21:30:10 <bobajett> oneChar c = case lookup c simpleEscapes of
21:30:10 <bobajett>               Just r -> text r
21:30:10 <bobajett>               Nothing | mustEscape c -> hexEscape c
21:30:11 <bobajett>                       | otherwise    -> char c
21:30:12 <MarcelineVQ> "<hrqaa> MarcelineVQ, I've read about it as "the dreaded", etc. Is it still a problem?" I don't know, I've encountered it before but don't run into it very often because my first instinct when things aren't quite right is to put signatures in to test my assumptions
21:30:28 <glguy> The docbuilder has been more reliable in recent days thanks to some improvements to how it queues works
21:30:56 <geppettodivacin> Why does the monomorphism restriction exist in the first place?
21:30:58 <EvanR> well it still will never build docs for mikmod bindings since it cant compile and link a c lib
21:31:05 <pikajude> geppettodivacin: hysterical raisins
21:31:07 <glguy> geppettodivacin: To improve performance
21:31:08 <MarcelineVQ> geppettodivacin: performance mostly
21:31:14 <pikajude> and that
21:31:23 <EvanR> and ive never really experienced the monomorphism dread or otherwise
21:31:44 <gfixler> hmm.. I can't get the suppose-to-fail example to fail
21:31:55 <bobajett> What does the "Nothing | mustEscape c -> hexEscape c" mean? I thought case expressions follow: case expression of p1 -> r1; p2 -> r2 -- I don't understand the "Nothing | p1 -> r1" syntax.
21:32:14 <glguy> bobajett: That's a "guard"
21:32:34 <glguy> Nothing is the pattern, p1 is a boolean expression
21:32:46 <Clint> bobajett: https://wiki.haskell.org/Pattern_guard
21:32:47 <gfixler> "A simple example is plus = (+). Without an explicit signature for plus, the compiler will not infer the type (+) :: (Num a) => a -> a -> a for `plus`, but will apply defaulting rules to specify plus :: Integer -> Integer -> Integer."
21:32:50 <bobajett> glguy: so Guard's can appear outside of top level as well?
21:32:51 <gfixler> this does not happen for me
21:32:56 <gfixler> it compiles and runs just fine
21:33:36 <glguy> bobajett: Yes, they can appear in a definition or a case expression
21:34:02 <geekosaur> gfixler, are you in ghci?
21:34:17 <gfixler> geekosaur: no, I'm doing stack exec ghci foo.hs
21:34:20 <gfixler> then ./foo
21:34:25 <gfixler> sorry, ghc
21:34:50 <glguy> "Pattern guards" extend normal boolean guards by allowing you to put a pattern match in the guard position
21:34:59 <glguy> pattern <- expression -> body
21:35:12 <glguy> and allowing you to separate patterns and boolean guards with commas
21:35:54 <gfixler> 2 lines of code in my file: plus = (+) and main = print (plus 3.5 2.7)
21:36:00 <bobajett> glguy: awesome! Thanks!
21:37:03 <glguy> gfixler: Your plus definition defaulted to a different type because you used a floating point literal with it
21:37:39 <gfixler> glguy: how am I supposed to see the failure case on this page then? https://wiki.haskell.org/Monomorphism_restriction
21:37:48 <gfixler> two files/
21:37:50 <gfixler> ?
21:38:11 <geekosaur> yes
21:38:18 <geekosaur> it does say ghci when presenting that example
21:38:35 <geekosaur> ghci has to resolve the type immediately and can't refer to future uses to infer a type
21:38:54 <glguy> gfixler: You put the definition of plus in a file
21:39:01 <glguy> but then you use it in GHCi
21:39:17 <gfixler> hmm
21:39:18 <glguy> If you use plus in the same file then GHC will infer the correct monomorphic type
21:39:36 <glguy> Because it has all the information available at compile time to do so and makes a different defaulting decision
21:39:50 <gfixler> okay
21:40:36 <gfixler> ah, there, I got it to crap out
21:40:58 <gfixler> paragraph 3, sentence 1, made me think that the problem only showed up in compiled modules, and not in GHCi
21:42:02 <glguy> This might give you some insight into why GHCi disables the monomorphism restriction
21:42:09 <glguy> It has to finish type checked every time you press enter
21:42:24 <glguy> and doesn't get to use future typing to inform previous lines
21:42:39 <geekosaur> well, ghci did compile the module, it just did so to bytecode. doesn't change anything really, if it compiles a module and doesn't see a use, it will end up defaulting to Integer (or whatever `default` specifies in the module)
21:42:46 <glguy> But in a single module loaded as a whole file, future lines can inform the type checking and defaulting of previous lines
21:43:26 <geekosaur> also note the difference between :set and :seti (or :show language, which applies to bytecode compiles, and :showi language, which applies to the prompyt
21:43:29 <glguy> So it would be a bigger burden to have the monomorphism enabled in GHCi than it is to have it in files
21:43:29 * hackagebot yesod-static 1.5.1 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.1 (MichaelSnoyman)
21:47:37 <gfixler> glguy: it would be a bigger burder to leave things polymorphic?
21:47:59 <glguy> No, in GHCi things would default to types that you wouldn't expect
21:48:38 <glguy> Suppose you wrote: let plus = (+) <ENTER> plus 3.5 3.5 <ENTER>
21:48:52 <glguy> In GHCi, without the MR turned off you'd get a type error
21:49:02 <gfixler> right
21:49:20 <gfixler> just wondering why you'd ever want it to choose a default instead of picking the most general type
21:49:26 <gfixler> but apparently that's a bit complicated to understand
21:49:35 <glguy> It's not complicated
21:49:47 <glguy> The problem is that your program would recompute more things that you might have expected
21:49:53 <gfixler> sorry, not picking the most general type, but rather not picking a type - remaining 'a' until such time as inputs determine something more
21:49:54 <glguy> simple value bindings like: x = stuff
21:50:07 <glguy> Might recompute "stuff" every time you used x
21:50:24 <gfixler> I suppose I can see that
21:51:09 <gfixler> "Basically, it solves one practical problem (without the restriction, there would be some ambiguous types)"
21:51:18 <gfixler> I don't know what those would be
21:51:40 <gfixler> "and one semantic problem (without the restriction, there would be some repeated evaluation where a programmer might expect the evaluation to be shared)"
21:52:35 <gfixler> I suppose I just find it odd to expect a polymorphic function not to have to decide on a type at each call point
21:53:03 <glguy> Polymorphic functions do that
21:53:30 * hackagebot http-client 0.5.3.4 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.3.4 (MichaelSnoyman)
21:53:45 <gfixler> aren't we only talking about polymorphic functions?
21:54:05 <glguy> If the MR is applied, then no, it's not a polymorphic function any more
21:54:10 <gfixler> right
21:54:20 <gfixler> I'm finding it weird to ever apply it, still
21:54:36 <gfixler> not grokking why I'd presume something wouldn't evaluate each time if polymorphic
21:55:08 <EvanR> glguy: to run your script... i needed cabal-install 1.24, so i installed it. but the command is still saying 1.22 (even after i removed the old cabal library)
21:55:17 <EvanR> capital Cabal
21:55:26 <glguy> EvanR: Have you "cabal clean"ed?
21:55:40 <EvanR> i must be experiencing messed up symlinks or something
21:55:40 <gfixler> so in my module, if I use `plus` in one location, and it clearly works on Ints, I presume Haskell just monomorphises it to a function on Ints
21:55:46 <EvanR> i mean, cabal --version is still old
21:55:56 <gfixler> but if I use it in 2 places, one clear Int, and one clearly Double, I suppose it would remain polymorphic
21:55:59 <glguy> EvanR: Perhaps you installed 1.24 to a different directory
21:56:13 <glguy> Like ~/.cabal/bin vs ~/.local/bin
21:56:32 <geekosaur> EvanR or your shell remembers where it found cabal before
21:56:34 <geekosaur> hash -r
21:56:50 <EvanR> they dont exist
21:57:19 <EvanR> hash -r did nothing, which cabal is still the same, /usr/local/bin/cabal
21:57:31 <geekosaur> see what this (not which!) says: type cabal
21:57:48 <geekosaur> "which" usually tells you what the next shell you start will see
21:58:04 <Clint> depends on which which you're running
21:58:08 <EvanR> and that is a symlink to the old version of cabal
21:58:13 <geekosaur> "type" tells you what your current shell knows, which may mean that it is still using an older one it had found
21:58:36 <EvanR> cabal is hashed (/usr/local/bin/cabal)
21:58:42 <soLucien> does anyone know whether there exists a "zero or one" parser in parsec ?
21:58:51 <EvanR> /usr/local/bin/cabal -> ../Cellar/cabal-install/1.22.6.0/bin/cabal
21:58:54 <glguy> :t optional
21:58:55 <soLucien> many means zero or many
21:58:56 <lambdabot> Alternative f => f a -> f (Maybe a)
21:59:17 <EvanR> theres no many
21:59:21 <geekosaur> ok, so how did you install the new cabal?
21:59:27 <EvanR> cabal install cabal-install
21:59:41 <Clint> EvanR: is /usr/local/bin in your PATH before wherever the new one is?
22:00:12 <EvanR> im not even sure what the new one is
22:00:19 <EvanR> havent seen it yet
22:00:35 <EvanR> /usr/local/bin is pretty early
22:00:40 <geekosaur> possibly ~/Library/Haskell/bin/cabal since you appear to be on a Mac
22:00:52 <geekosaur> (assuming /usr/local + Attic means brew)
22:01:58 <smelcome> anyone have time for a quick noob question?
22:01:58 <EvanR> yeah i see it there
22:02:11 <EvanR> guess i should move the haskell stuff up
22:02:22 <geekosaur> smelcome, ask away
22:02:35 <smelcome> compiler issue
22:03:03 <smelcome> main = do
22:03:03 <smelcome>     putStrLn "Enter a number"
22:03:03 <smelcome>     num1 <- readLn :: IO Int
22:03:03 <smelcome>     putStrLn "Enter another number"
22:03:03 <smelcome>     num2 <- readLn :: IO Int
22:03:04 <smelcome>     putStrLn "The sum of the two number is " ++ ( show (num1 + num2) )
22:03:07 <smelcome> that won't compile
22:03:24 <xuxu> exit
22:03:29 <glguy> smelcome: Don't paste to the channel, use a pastebin: http://lpaste.net
22:03:30 <EvanR> the problem was i had /usr/local/bin in there twice... some reason i was prepending it at the very end
22:03:41 <smelcome> Noted
22:03:54 <geekosaur> use a pastebin and include the full error message
22:04:02 <glguy> smelcome: you need parentheses on the last line
22:04:16 <glguy> smelcome: putStrLn ("stuff" ++ otherstuff)
22:04:19 <geekosaur> but the problem appears to be that you parenthesized the wrong thing
22:04:23 <EvanR> cabal: '/usr/local/bin/haddock' exited with an error: ;_;
22:04:25 <smelcome> ok then
22:04:29 <geekosaur> the ones around show ... are not needed
22:04:42 <geekosaur> but you need some around "The..." ++ show (...)
22:05:08 <geekosaur> otherwise it is: (putStrLn "The sum of the two number is ") ++ show ...
22:05:26 <geekosaur> i,e, trying to append the show's result to the result of the I/O operation
22:06:19 <smelcome> Is that an operator precedence issue?
22:06:43 <geekosaur> function application is higher precedence than anything else
22:07:01 <smelcome> ok then
22:07:08 <smelcome> Thanks. That worked
22:07:21 <geekosaur> (almost anything else but record update syntax, which I presume you'll encounter later)
22:08:07 <smelcome> Its pretty humbling to go from a 4 year cs degree and programming day job to complete noob when I switch from oop to fp
22:08:37 <smelcome> But that's haskell for you
22:09:04 <geekosaur> it's any new paradigm. prolog / logic programming would do the same
22:09:21 <geekosaur> or even something "simple" like ladder logic
22:09:28 <EvanR> smelcome: it never stops
22:09:59 <EvanR> so cabal haddock works now, but when i run your script it seems to be using the wrong PATH
22:10:22 <EvanR> and is picking the old-ass brew version (i dont even remember installing that)
22:10:53 <EvanR> which fails without an useful error message
22:11:02 <geekosaur> where'd you change $PATH?
22:11:22 <glguy> The script isn't doing anything clever with paths, so you might need to create a new shell if you just fixed your PATH issue
22:11:56 <geekosaur> if you only changed it in your current shell, and you are setting $PATH in someplace unfortunate like .bash_aliases, then that will override your shell's $PATH
22:12:25 <geekosaur> (also why .bashrc is not such a hot idea, although at least most scripts won't source .bashrc automatically)
22:12:50 <EvanR> no the PATH is right... but the cabal haddock with all the flags fails...
22:13:10 <EvanR> might be a version problem with all the libs
22:13:19 <EvanR> cabal: '/usr/local/bin/haddock' exited with an error:
22:13:31 <EvanR> oh well thats the totally wrong haddock...
22:14:00 <EvanR> frustrating
22:17:29 <EvanR> running the new cabal, but if i pass --haddock-options itll report an error from the usr/local haddock
22:18:00 <EvanR> for the hyperlinked 
22:19:36 <EvanR> geekosaur: no, its in .profile. Were you suggesting a better way to set the PATH?
22:20:38 <geekosaur> no. setting in .bashrc is sadly common and works about 90% of the time... then you try to use rbenv/rvm/pyenv/hsenv/whatever and you can't figure out why it doesn't work
22:20:58 <geekosaur> because .bashrc is overriding the environment manager's changes
22:21:56 <EvanR> yeah i have all that happening... in .profile though
22:22:13 <EvanR> so i think itll work if i exclude the hyperlinked sources option
22:22:19 <EvanR> no idea why that causes it to fail
22:23:10 <EvanR> oh jeez, then theres literally no _source_ link in the docs...
22:28:46 <glguy> EvanR: It looks like this mikmod package doesn't support the current version of GHC
22:29:05 <glguy> There's an old version of the documentation script in the lens repository that was for GHC 7.10.3 with the older version of haddock
22:30:19 <glguy> Not working with the current version of things is another reason why hackage can't build documentation for it
22:30:48 <glguy> The fancy new source hyperlinking was added to haddock after the version that comes with GHC 7.10.3
22:31:32 <glguy> EvanR: If that package is yours you should also update your PVP comment in the cabal file, it misrepresents the Haskell PVP
22:31:57 <glguy> OOOPs, I'm wrong
22:32:00 <glguy> I misread the ascii art
22:35:11 <glguy> EvanR: Also, I've uploaded some hyperlinked docs for that package and purged the previously stale http://hackage.haskell.org/package/mikmod URL
22:35:25 <coleman> What would you guys use for some simple/fun web development? Haskell? Elixir? Clojure?
22:35:57 <coleman> Erlang?
22:36:16 <EvanR> working on it
22:36:37 <EvanR> oh ok
22:37:11 <EvanR> well i bump the base bounds and the version number, so im about to try to go through all this
22:37:14 <EvanR> again
22:37:56 <glguy> EvanR: OK, let me know if you need help when you do the next upload :)
22:38:08 <EvanR> glguy: can you clarify, it doesnt work with ghc 7.10.3 ? or 
22:38:29 <glguy> The current version of the script assumes your haddock version knows about the hyperlinked-sources flag
22:38:36 <glguy> The version of haddock that came with GHC 7.10.3 didn't know about that
22:39:05 <EvanR> how is the source link supposed to get there
22:39:10 <EvanR> prior to that point
22:40:08 <glguy> EvanR: This is the older script for how you used to do it
22:40:09 <glguy> https://github.com/ekmett/lens/blob/7e269b3e79ee54c0b34e4c62770fa1220068b769/scripts/hackage-docs.sh
22:41:28 <EvanR> i found my script, in all its glory: http://codepad.org/x0yrA23j
22:41:48 <EvanR> but i noticed that this still doesnt correctly link the sources in the docs... its a 404 locally
22:42:04 <EvanR> alright, enough, im going to try and upload the latest version
22:43:47 <EvanR> also if you care to verify that it even builds on ghc 8 and or base 4.9...
22:43:53 <EvanR> thatd be awesome :D
22:44:21 <glguy> Did the code change or are you just updated bounds?
22:44:29 <EvanR> only updated the bounds
22:44:44 <glguy> Then you don't need a new version
22:44:48 <EvanR> really?
22:44:57 <glguy> It builds on GHC 8.0.1 on macOS, I don't know if it works
22:44:58 <EvanR> figure hackage had at most 1 of each version
22:45:11 <EvanR> well ill unbump the version
22:45:20 <glguy> You can fix version bounds on existing packages
22:45:52 <EvanR> nice
22:46:01 <glguy> Click "edit package information" > "mikmod-0.2.0.1"
22:46:53 <EvanR> awesome... well here goes nothing
22:47:31 <EvanR> oh, ... i dont need to upload anything
22:48:17 <EvanR> or i do
22:48:33 <EvanR> i dont see where to manage the bounds
22:49:18 <ezyang> Are there any "separate process" test frameworks, which are designed to run Haskell files by runghc'ing (rather than import'ing) 
22:49:33 <glguy> EvanR: There's a text box with the cabal file contents in it
22:50:21 <pikajude> ugh, why can stylish-haskell still not handle type applications
22:50:22 <pikajude> they're so convenient
22:50:38 <ezyang> pikajude: Submit a patch? ;) 
22:50:50 <EvanR> oh, the second mikmod-0.2.0.1 link, of course
22:51:06 <pikajude> yes...submit a patch...
22:52:11 <EvanR> glguy: i dont think this will work, it says the package itself isnt updated just the metadata
22:52:48 <EvanR> since it was originally set by a package upload, i dont know how this helps
22:53:19 <glguy> It helps
22:53:36 <glguy> The metadata is what cabal-install and stack use to resolve dependencies
22:53:48 <EvanR> not whats in the actual cabal file?
22:53:58 <EvanR> which i updated in the git repo
22:54:02 <EvanR> but not on hackage
22:54:14 <glguy> Definitely make the same change to your git repository
22:54:23 <EvanR> alright
22:54:32 <glguy> since you'll want it like that for the next time you cut a release
22:58:00 <EvanR> done messing with that lib for a while... now to fix another one
23:00:29 <EvanR> glguy: is it wise to put these upper bounds and then have to periodically bump them when it "still works"
23:01:35 <glguy> There are two camps. I think it's worth having them
23:01:57 <EvanR> is base 4.9 going to be around for a while
23:02:41 <glguy> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.2.1 says that GHC 8.2 could be released mid april
23:03:53 <glguy> So... "some time in 2017"
23:04:56 <EvanR> er and thats base-4.10?
23:05:16 <glguy> I'd expect so
23:09:05 <wespiser> hey, I have a command line program, an interpreter, than needs to parse some arguments. I would like to use a command line argument parser that would work very well in production. Whats state of the art?
23:09:11 <wespiser> thanks!!!!
23:09:39 <EvanR> optparse-applicative
23:10:11 <glguy> I prefer using http://hackage.haskell.org/package/base-4.9.0.0/docs/System-Console-GetOpt.html
23:10:42 <jle`> i use optparse-applicative
23:11:24 <EvanR> cool... bump my upper bounds on linear about 5 numbers... doesnt work anymore ;)
23:11:51 <EvanR> lets see what ekmett did
23:12:47 <wespiser> i really like applicative style parsing, thanks for the suggestion
23:13:00 <wespiser> in fact, applicatives make a lot of intuitive sense to me
23:13:54 <wespiser> optparse-applicative will go through okay with {-# LANGUAGE OverloadedStrings -#} ??
23:15:04 <jle`> whoa, how does optparse-applicative take advantages overloadedstrings? :O
23:15:19 <jle`> but yeah, being able to write a parser like Foo <$> parseThis <*> parseThat is pretty nice
23:15:27 <jle`> and printing out neat help messages and stuff
23:15:50 <wespiser> i'm just using overloaded strings through the project as a default
23:16:05 <jle`> oh, i didn't see the question marks
23:16:42 <jle`> yeah, overloaded strings won't interfere with anything for the most part.  there are some cases where you would have to provide type annotations though
23:16:44 <jle`> in general
23:16:54 <wespiser> its a tutorial, so I think its a little simpler to just stick with one thing, but yea, the performance advantage probably isn't going to be there
23:19:27 <wespiser> the project is in flux, its an updated version of write you a scheme: https://github.com/write-you-a-scheme-v2/scheme
23:20:52 <wespiser> I'm open to suggestions
23:21:43 <haskell204> Test
23:21:51 <laudiacay> are all monads applicatives?
23:22:04 <glguy> Yes
23:22:44 <haskell204> I have a class definition like this : 
23:22:51 <haskell204> class Queue q where   
23:22:53 <haskell204> empty :: q a
23:23:16 <wespiser> https://wiki.haskell.org/File:Typeclassopedia-diagram.png
23:23:29 <haskell204> i want a instance of it for for following type synon " type ListPair a = ([a], [a])"
23:23:42 <wespiser> https://wiki.haskell.org/Typeclassopedia is a good place to become an expert!
23:25:02 <jle`> haskell204: you can't write instances for type synonyms like that
23:25:03 <glguy> haskell204: Type synonyms don't create new, distinct types. So you can't make instances for them
23:25:11 <jle`> type synonyms can't be partially applied, either
23:25:11 <glguy> They're just aliases for existing types
23:25:25 <jle`> so you can't ever use 'ListPair' as a thing on its own
23:25:44 <haskell204> ok...using newtype is creating  boilerplate
23:25:45 <jle`> even with TypeSynonymInstances on
23:26:06 <jle`> haskell204: the alternative really wouldn't make sense
23:26:17 <jle`> how would ghc know what instance to use/when?
23:26:50 <jle`> supporting instances for unapplied type synonyms doesn't really make sense to implement without a big rehaul
23:27:41 <haskell204> using newtype is correct approach in that case?
23:28:03 <jle`> mhm
23:28:06 <EvanR> huzzah... another package updated... *with docs*
23:28:23 <wespiser> nice work!
23:28:33 * hackagebot lowgl 0.3.1.2 - Basic gl wrapper and reference  https://hackage.haskell.org/package/lowgl-0.3.1.2 (evanrinehart)
23:28:48 <glguy> haskell204: In this case where you have the two fields you might as well create a type with "data"
23:28:58 <jle`> haskell204: it also would make sense fi you wanted to offer a queue implemented using ([a],[a]) only through an abstract data type interface
23:29:03 <glguy> haskell204: data Queue a = MkQueue [a] [a]
23:29:16 <jle`> cause you wouldn't really want users to work with ti directly normally anyway :)
23:30:52 <wespiser> what operations does the queue support? just enqueue dequeue ?
23:31:10 <jle`> mkEmptyQueue :: Queue a, addToQueue :: a -> Queue a -> Queue a, etc.
23:41:59 <Lokathor> i flashed my rpi image the other day, but i wasn't able to save my binary of stack
23:42:04 <Lokathor> sad times
23:42:28 <kadoban> Hehe. How long does it take to build on rpi?
23:42:44 <Lokathor> oh i don't even know, i always just had it run overnight
23:43:03 <wespiser> ^^ this, every rpi project I've done
23:43:07 <Lokathor> but getting the system into a position to be able to build the first iteration of stack means working with haskell without stack :/
23:43:44 <hvr> working with haskell without stack is not as bad as some ppl make it sound ;)
23:43:45 <glguy> that's a good skill to have
23:44:14 <Lokathor> yeah
23:44:20 <Lokathor> and stack builds with cabal, so it's not even too bad
23:44:50 <wespiser> I started my haskell job 2 weeks before we switched to cabal, I guess there where just a few hours here or there that required some playing with dependencies
23:44:56 <wespiser> but that costs $$$
23:45:10 <hvr> wespiser: switched from what to cabal?
23:45:11 <Lokathor> what did you use before cabal?
23:45:13 <wespiser> *switched to stack
23:45:16 <wespiser> my bad
23:45:16 <Lokathor> oh :P
23:45:27 <wespiser> yea, we used shell scripts and perl :{
23:45:30 <wespiser> lol
23:46:05 * hvr would consider quitting his job if he was asked to switch from cabal to stack
23:46:41 <wespiser> can you elaborate ?
23:46:57 <glguy> hvr doesn't like questions
23:47:12 <hvr> glguy: what makes you say that? :)
23:47:17 <wespiser> elaborate.
23:47:27 <glguy> you'd quit your job over one!
23:47:32 <hvr> lol
23:47:45 <LordBrain> reality is like haskell, running on a computer, it seems to   go to great effort to appear static like math, but ultimately isn't.
23:48:08 <wespiser> performUnsafeIO says what?
23:48:11 <hvr> wespiser: well, to give you some context, I'm currently spending most of my time working on cabal :)
23:48:17 <hvr> (of my spare time)
23:48:34 <wespiser> yea, we need cabal. Stack doesn't replace it.
23:48:39 <Lokathor> realtiy is one giant unsafePerformIO
23:49:20 <wespiser> well, if the universe is deterministic you could look at it as entirely immutable in 4 dimensions.
23:49:20 <hvr> wespiser: and cabal new-build is closer to the UI that fits my workflow than stack's UI
23:49:42 <begriffs> hvr: tell me some things you like about cabal. I've found stack to be very convenient but maybe that's because I haven't needed as much manual control as somebody developing libraries rather than binaries.
23:49:42 <LordBrain> wespiser, then where is your consciousness?
23:49:44 <wespiser> hvr: you are fine with dependency management?
23:50:16 <hvr> wespiser: or maybe you just need to add more dimensions to make it appear static if 4 dims aren't enough ;-)
23:50:36 <hvr> LordBrain: consciousness is an illusion
23:50:45 <LordBrain> yeah
23:51:01 <LordBrain> either that or the staticness/determinancy is an illusion
23:51:14 <wespiser> yea, I'll leave that to the physics folks. I've convinced myself that referential transparency is the model of the universe that offers the most utilty. Hence, I program in Haskell.
23:51:40 <hvr> wespiser: wouldn't that rule out time travel though? :3
23:51:48 <wespiser> of course not
23:51:57 <wespiser> nor could I rule out god
23:52:27 <EvanR> #haskell-halfbaked-philosophy
23:52:33 <wespiser> I know, sorry 
23:52:49 <wespiser> I'm trying to steer this back to haskell
23:53:02 <hvr> begriffs: I like it's solver-centric workflow for one
23:53:39 <wespiser> isn't cabal an installation tool and stack a dependency management tool?
23:53:49 <wespiser> so they are complimentary ?
23:53:56 <hvr> begriffs: it's the whole declarative inter-package dep mgmt thing that attracts me
23:54:16 <hvr> wespiser: that's totally inaccurate
23:54:17 <LordBrain> you mean about cabal
23:54:20 <LordBrain> vs hackage
23:54:22 <LordBrain> er
23:54:24 <LordBrain> stack
23:54:51 <hvr> wespiser: a huge part of cabal is about dependency solving 
23:54:56 <begriffs> hvr: the idea that each package specifies constraints for other packages it works with and then cabal seeks to satisfy those constraints, rather than buying into a one-size-fits-all series of versioning snapshots?
23:55:19 <wespiser> so what is stacks role in all of this vs. cabals role?
23:55:55 <hvr> begriffs: yep, that one; it gives me flexibility and decentralises the dep tracking
23:56:17 <hvr> wespiser: stack is a different UI basically with different workflow-emphasis
23:56:34 <begriffs> One thing that has been simply wonderful about stack is how it can pull things I've already built into new "sandboxes" and avoid rebuilding. I remember that being painful about cabal. But then again that was because I chose to make new cabal sandboxes for every single project I worked on.
23:56:41 <LordBrain> yeah individual dependency like that has more power long term, its just we need to move more in the direction of generating dependencies from code, and updating them from code.
23:56:47 <wespiser> https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal
23:56:51 <hvr> wespiser: both, cabal & stack can do basically the same (except that cabal doesn't install ghc for you for reasons)
23:58:08 <wespiser> hvr: thanks!
23:58:14 <hvr> wespiser: but stack is designed around stackage snapshots, while cabal is designed around solving against the hackage index
23:58:39 <wespiser> yea, it seems like their approach to reproducibility is different
23:58:52 <hvr> wespiser: the reason stack exists comes down to philosophical differences about what is the right way
23:59:35 <wespiser> well, the makers of stack claim its a solution to an 'established' tooling problem in the community
23:59:53 <wespiser> identified via survey, however non-scientiffic
23:59:54 <hvr> wespiser: they *could* have contributed to cabal development, but there was too much of an ideological gap, that they wrote a new tool
