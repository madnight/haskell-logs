00:00:45 <liste> bollu: closer to DataKinds than LambdaCase
00:01:05 <liste> and I wouldn't call them too advanced (:
00:01:53 <bollu> liste: :) dpeends
00:02:04 <bollu> liste: I don't want it screwing with inference is all
00:03:31 <lyxia> echo-area: okay sorry
00:14:13 <lyxia> echo-area: requiring that the root of the definition be a fold might be restrictive. You can perhaps use a fold with a different accumulator type.
00:18:35 <lyxia> echo-area: you can define foldt' :: (a -> ListL b -> b) -> Tree a -> b  since  Forest a <-> ListL (Tree a)
00:29:19 <echo-area> lyxia: Ah, the root of the definition. That was what I thought too, let me try your suggestion
00:30:32 <lpaste> lyxia annotated “Trees” with “curry1' ? to echo-area” at http://lpaste.net/348024#a348063
00:31:57 <lyxia> I think when we say that we can use a fold to replace recursion, the idea is that every recursive function f can be written as f = h (fold ...), where h and the arguments of fold are not recursive.
00:32:30 <lyxia> you were trying to have h = id, which is too strong a requirement in general
00:34:11 <lyxia> actually I annotated with curry1, curry1' was already given
00:37:30 <echo-area> lyxia: Is your annotated curry1 supposed to be used with the give foldg?
00:38:30 <osa1> what was the lambdabot command that makes it print lens resources?
00:39:11 <liste> @where lens
00:39:11 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
00:39:13 <liste> ^ that?
00:39:34 <lyxia> echo-area: Yeah
00:39:47 <osa1> no there's a command that makes it print some blog post urls
00:39:50 <lyxia> echo-area: Does it not typecheck
00:40:05 <echo-area> lyxia: Yes it doesn't type check
00:40:09 <echo-area> *typecheck
00:40:10 <lyxia> damn
00:41:42 <GramCracker> help
00:42:15 <osa1> @where lenses
00:42:16 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
00:42:16 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
00:42:18 <osa1> yay
00:42:52 <cocreature> GramCracker: you need to be a bit more precise if you want people to be able to help you
00:43:45 <lyxia> echo-area: the errors are caused by the last part you annotated
00:43:53 <lyxia> I suppose you copied them from somewhere else
00:44:00 <GramCracker> Thanks im just new to irc and thought i had to login or something... but then i started seeing there were people chatting and i know im connected
00:44:58 <lyxia> GramCracker: yes we can see what you write
00:45:04 <echo-area> lyxia: I didn't change the functions above my annotation
00:45:59 <GramCracker> so haskell is a programming language? i've been learning python
00:46:34 <DavisMan> I need some help 
00:46:44 <eklavya> I have re exported everything in a single module name, now I think haddock is not listing docs for functions in the reexported modules
00:46:51 <eklavya> how to make it work?
00:47:27 <DavisMan> Can someone help me hack an instagram account (my gf, wanna see if shes cheating)
00:47:37 <lyxia> echo-area: remove everything after line 85, what error do you get
00:47:39 <Myrl-saki> DavisMan: gtfo
00:47:54 <quchen> Myrl-saki: :-|
00:47:55 <DavisMan> Just asking for help geez
00:48:02 <quchen> ?where ops
00:48:02 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
00:48:08 <Myrl-saki> ...
00:48:11 <Myrl-saki> oh wait. this is #haskell
00:48:13 <GramCracker> lol
00:48:25 <quchen> Myrl-saki: We can deal with this and stay civilized at the same time. :-)
00:48:31 <Myrl-saki> guampa: Yeah, sorry.
00:48:35 <GramCracker> i dont know from my research python is the place to start
00:48:39 <Myrl-saki> quchen: *
00:48:46 <DavisMan> I dont wanna mamke enemies I just wanna get some quick help that all :)
00:49:02 <GramCracker> if you think she is cheating she probably is
00:49:03 <zomg> DavisMan: frankly, if this is a serious question, your relationship is already shafted because you can't even trust her that much
00:49:09 <Myrl-saki> DavisMan: Well, first, this is a Haskell channel, I doubt anyone knows how to "hack" here.
00:49:23 <Myrl-saki> By "anyone" I mean at least 5%.
00:49:48 <quchen> There are plenty of hackers in here. Not sure about crackers.
00:49:49 <GramCracker> so 95% can hack? wtf
00:49:51 <lyxia> only hackers and bots go on irc
00:50:02 <Myrl-saki> GramCracker: wut
00:50:18 <GramCracker> well the read what you typed
00:50:23 <hal_> GramCracker, the sentence would read: "I double at least 5% knows how to "hack" here."
00:50:24 <GramCracker> just read*
00:50:32 <Myrl-saki> "I doubt at least 5% know how to hack here."
00:50:37 <hal_> doubt*
00:50:46 <GramCracker> 95% can hack
00:50:50 <DavisMan> Can anyone help me or not?
00:51:00 <hal_> DavisMan, unlikely.
00:51:05 <Myrl-saki> DavisMan: Well, we can probably offer relationship advice.
00:51:09 <Myrl-saki> In another channel.
00:51:13 <hal_> Do you need help with haskell?
00:51:13 <GramCracker> LOL
00:51:22 <DavisMan> I just need a password thats it
00:51:23 <SCHAAP137> haskell has documentation
00:51:31 <GramCracker> can somebody tell me why haskell is a better language then python?
00:51:38 <Myrl-saki> GramCracker: 1.) It's Haskell
00:51:40 <eklavya> please help me with haddock?
00:51:54 <SCHAAP137> it's not better per se from an ethical/moral pov, it's just different,
00:51:55 <GramCracker> thats what i said
00:52:09 <ertesx> DavisMan: i recommend that you learn some basic type theory, then you can prove the following: IWantToHackMyGF -> MyRelationshipIsInBadShape
00:52:12 <echo-area> lyxia: It's a correct definition, let me see
00:52:13 <GramCracker> so why bother then? there has to be some reason..
00:52:20 <Myrl-saki> ertesx: lmao
00:52:21 <ottanta> ertesx: LOL
00:52:24 <hal_> GramCracker, it depends on your use case and your preferences.
00:52:26 <echo-area> lyxia: I've checked against some values
00:52:40 <quchen> ertesx: Proof of provability is proof, no?
00:53:32 <ertesx> quchen: that…  sounds like LEM
00:53:34 <DavisMan> Ok, shes not my gf anymore shes my ex but wtfever
00:53:35 <GramCracker> hacking and programming
00:53:54 <GramCracker> what do you use hasksell for?
00:54:02 <GramCracker> haskell*
00:54:04 <SCHAAP137> file copying
00:54:16 <ottanta> I use haskell for my own masochistic and sadistic tendencies
00:54:38 <GramCracker> what kind of sadistic tendencies? lol
00:54:42 <ertesx> i mainly use it for foldr code golfing
00:54:47 <ottanta> making people help me with my source
00:54:50 <GramCracker> because we know all programming is in some way masochistic
00:54:53 <DavisMan> I use it because HN says people here are eager to ehlp, obv not
00:55:00 <echo-area> lyxia: Cool, thanks
00:55:07 <GramCracker> ahhh lol
00:55:18 <ottanta> programming is definitely masoschistic
00:55:53 <GramCracker> but its thrilling when you get good and can nail a code first try i always like that.
00:56:11 <ertesx> DavisMan: the problem is that the edit distance between "haskell" and "hacking" is apparently too small…  we're happy to help *with haskell*
00:56:28 <ertesx> DavisMan: haskell is a programming language
00:56:30 <DavisMan> Always wanted to code never knew where to start really
00:56:39 <ottanta> DavisMan: well, what about coding interests you
00:56:52 <hal_> (except hacking your gf)
00:56:53 <GramCracker> *cough* hacking *cough*
00:56:56 <ottanta> being literate in how computers work?
00:57:00 <DavisMan> Creating your own games is the most part. Making mods and things
00:57:08 <ertesx> DavisMan: well, now would be a good start…  have you installed GHC?
00:57:22 <ertesx> s/start/time to start/
00:57:27 <DavisMan> no
00:57:49 <ertesx> then install GHC and write your first hello world program
00:57:57 <GramCracker> anyone know some good darknet irc channels? lol
00:58:11 <ottanta> GramCracker: go get that TOR os and use their irc client/network
00:58:20 <DavisMan> Ok, and shes not my gf shes my ex, I lied cuz im a peice of shit
00:58:29 <GramCracker> i have the tor browser
00:58:30 <ottanta> DavisMan: it's cool we all know you don't have a gf
00:58:38 <DavisMan> NOt anymore no
00:58:53 <echo-area> lyxia: I think I can define the other functions too now. Thanks :)
00:58:55 <GramCracker> i tried orofusely to connect to a irc channel but its pretty confusing changing the port addresses and all that
00:59:00 <Limona> Hello guy, new to haskell here, but i see now's not a good time, a bunch of hecklers here
00:59:03 <Limona> i'll ask later
00:59:04 <ottanta> DavisMan: if you like modding games, lua might be good to learn, but lua itself is largely designed as an extension language
00:59:06 <Limona> guys*
00:59:23 <hal_> Limona, it is always a good time :)
00:59:25 <ertesx> Limona: i'd welcome on-topic discussions =)
00:59:35 <ottanta> Limona: you're new to haskell? have you seen the new-bie resources? like learn you a haskell and real world haskell? both are available online for free
00:59:40 <ottanta> and rwh is pretty cheap secondhand
01:00:06 <DavisMan> haskell vs c++?
01:00:11 <Limona> Well, i'm a c++ programmer, and i've thrown my eye to haskell, to see what's all the academic fuss about it
01:00:22 <Limona> so if possible, i'd like to get some resources to learn
01:00:29 <Limona> haven't found anything good yet
01:00:35 <ertesx> Limona: what have you tried so far?
01:00:44 <hal_> DavisMan, both are great, for different reasons. Why don't you give both a try?
01:01:11 <Limona> ertesx so far, a few haskell online resources, nothing quite clear enough
01:02:03 <Limona> so any kind of links or good book titles would be appreciated
01:02:14 <ertesx> Limona: if you're open to buying a book, try this one: http://www.cs.nott.ac.uk/~pszgmh/pih.html
01:02:19 <eklavya> yo yo yo it was indeed a bug in haddock, found a work around on reddit :P
01:02:34 <ottanta> Limona: 'haven't found anything good enough' like what have you tried thusfar, and what was your time investment on each
01:03:01 <Limona> ertesx thanks, i'll take a look
01:03:04 <eklavya> Limona: this is free http://learnyouahaskell.com
01:03:05 <hal_> I second ertesx' recommendation
01:03:06 <DavisMan> So when you are coding a game do your scripts go hand and hand with your 3d models? How does that work?
01:03:27 <ertesx> Limona: alternatively there is the haskell wikibook…  it has some really rough edges though, but feel free to use #haskell alongside that one
01:03:32 <hal_> DavisMan, if you want to make 3d games, have a look at the various game engines that exist.
01:03:33 <Limona> ottanta https://wiki.haskell.org/Tutorials#Best_places_to_start
01:04:04 <Limona> ertesx could you link please
01:04:05 <DavisMan> SO each game engine uses a specified language?
01:04:06 <hal_> Can anyone make a recommendation for DavisMan? I am not aware of the state of the art.
01:04:25 <eklavya> Limona: in my experience just getting a hang of the syntax and then starting to write something has been sufficient
01:04:34 <Limona> also why are there no ops here, how come there's that many hecklers here
01:04:35 <hal_> DavisMan, there are sometimes bindings in several languages to certain game engines, but I'll leave it up to someone else to make a recommendation.
01:04:38 <ertesx> Limona: http://en.wikibooks.org/wiki/Haskell
01:04:46 <DavisMan> Ok
01:05:05 <Limona> ertesx danke
01:05:12 <eklavya> Limona: I learned a lot by asking here
01:05:33 <hal_> My little piece of advice is to do some searching on game engines, because they will make your work a bit easier.
01:05:44 <ertesx> Limona: you're welcome =)
01:06:20 <DavisMan> After I identify the language of said game engine I need to find a course to learn the language right?
01:06:21 <ertesx> DavisMan: a "game engine" is really a collection of various parts:  there is a graphics engine, the sound engine, AI algorithms, etc.
01:06:48 <DavisMan> Oh ok
01:06:51 <ertesx> DavisMan: if you have no experience with any of those, i suggest that you start with individual parts…  perhaps program a small command line game just to get the hang of it
01:07:18 <hal_> I agree with ertesx that starting small is good, but keep your eye on your goal too.
01:07:57 <DavisMan> So things liek snake, tetris, pacman, etc?
01:08:07 <hal_> It helps tremendously if you focus on the fundamentals of programming before diving into big projects.
01:08:12 <ottanta> DavisMan: they tend to expose their own languages to developers, like Unity uses a unity script language, etc
01:09:17 <DavisMan> Programs for command line games?
01:09:56 <ertesx> DavisMan: you said that you have no programming experience yet, so even a game like snake is quite involved…  here is a simple challenge that is just difficult enough to get you learning: write a number guessing game
01:10:59 <DavisMan> Ok and what software am i using to write this program. or am i writing a simple batch file program?
01:11:24 <ertesx> well, since you came to #haskell, why don't you use the haskell programming language? ;)
01:11:55 <DavisMan> Ok I will give it a shot
01:12:04 <quchen> Does anyone have experience with building Text out of lots of small parts? Is using the Text Builder as slow as using String in this case, or does it use some smart hackery under the hood?
01:12:28 <ottanta> Game engines generally also have physics engines built in
01:12:44 <ottanta> Limona: how did you learn C++ btw
01:12:45 <quchen> A long singly linked list of singleton Text values is probably not a very good data structure
01:12:47 <ertesx> quchen: it uses smart hackery (it allocates fixed-size chunks and mutates them as pieces come in)
01:13:11 <Limona> ottanta mostly school, else was from books and work
01:13:13 <quchen> ertesx: An, and when I use a builder twice it does a copy-on-write?
01:13:14 <Limona> and side projects
01:13:49 <DavisMan> Seems that IRC is better than reddit
01:14:01 <ertesx> quchen: probably not…  you should reuse the resulting Text (unless sharing is a problem)
01:14:34 <quchen> ertesx: Not really a problem, but I would be surprised if sharing affected correctness of a library
01:15:04 <tdammers> quchen: I believe Builders use a "Hanoi Tower" kind of algorithm to speed up concatenation
01:15:06 <ottanta> DavisMan: people actually get banned on IRC for being racist
01:15:07 <ertesx> quchen: not correctness, but efficiency
01:15:26 <quchen> ertesx: But if it preallocates and mutates in place, then sharing would affect correctness
01:15:32 <DavisMan> Ok, irrelevant noone is being racsist.
01:15:34 <tdammers> quchen: copy-on-write
01:15:35 <ertesx> quchen: sharing can be good, but in the presence of laziness (such as for Text builders) it can be bad
01:15:36 <quchen> (If it’s not copying in a smart way)
01:15:51 <ottanta> DavisMan I was drawing a direct comparison to my Reddit experiences
01:15:53 <tdammers> obviously the copying *is* done in a smart enough way
01:15:54 <quchen> Speaking of text builders, why is there no strict version? I only see the lazy module
01:15:55 <ertesx> quchen: huh?  why?  the resulting Text is still immuatble
01:16:11 <ertesx> you can't rerun a builder in such a way that you overwrite *the same* memory
01:16:15 <ertesx> you would get a new copy
01:16:45 <bollu> so I have this typeclass to work with Foreign pointers: https://github.com/bollu/symengine.hs/blob/master/src/Symengine.hs#L70. I'm wondering it its overkill, but I really like the with2, with3, etc. Is there a different way to do this?
01:16:47 <ottanta> Limona: if you don't mind me asking, which of the haskell resources from https://wiki.haskell.org/Tutorials#Best_places_to_start did you look into, and what was your impression of them?
01:17:17 <DavisMan> as i type 23 * 36 i get the answer 828 but I dont know what the characters following mean   ;; Num a=> a
01:17:42 <quchen> ertesx: Oooh, I misunderstood which part you meant when you said “preallocate and write”, I thought the Builder value itself preallocates, but it’s “runBuilder” that does that part
01:17:45 <ottanta> > 23 * 36
01:17:48 <lambdabot>  828
01:18:01 <Limona> ottanta, i've looked at haskell tutorial below, but i didn't get the syntax. Honestly, the wikiguide looks the best resource so far, looking it up right now
01:18:03 <ottanta> DavisMan: that's the type signature of the result
01:18:11 <quchen> ertesx: However in that case, a chain of small builders is almost as inefficient to convert to Text than say String is
01:18:25 <quchen> Since we again have a list of characters (in the form of many builders)
01:18:28 <ottanta> Limona: have you taken many math courses? the syntax is pretty similar to math proofs 
01:18:47 <Limona> ottanta math courses? Yes, i've had algebra in college
01:19:11 <tdammers> quchen: if you receive your strings one character at a time, then I'd expect Builder and String to perform roughly the same
01:19:47 <ottanta> Limona: algebra like abstract algebra? like did you go over groups, magmas, rings, fields, linear transformations?
01:19:51 <tdammers> what happens is basically: allocate a buffer, fill it with characters until it's full, then resize to a buffer twice as large, etc.
01:20:29 <quchen> tdammers: Converting the Builder to Text is simple, yes. I was just hoping that concatenating builders does something sneaky.
01:20:53 <tdammers> like what?
01:21:07 <Limona> ottanta never used "magma", in our algebra classes we've used mathlab
01:21:19 <DavisMan> Ok I am going to do a little bit of this haskell tutorial and get back to you
01:21:47 <ottanta> Limona: a magma isn't software it's an algebraic structure
01:21:51 <hal_> DavisMan, good luck, you're welcome to ask us if you get confused.
01:21:53 <ertesx> quchen: a String, if it ever manifests in memory, is a linked list though, so you get linked list performance, while a built Text is a much denser structure
01:21:55 <bollu> right now, I'm using fromIntegral to convert from Int -> CUint and CInt. is there a faster way?
01:22:06 <quchen> tdammers: For example, consider (T.concat (repeat 1000 ("foo" <> "bar" :: Builder))). When converting this to Text, the <> is used 1000 times. A nicer way would be if the <> would secretly be (builderFromText (build foo" <> build "bar")).
01:22:44 <tdammers> I think it boils down to the same
01:22:46 <quchen> (Maybe it already does that. I’m not sure what my question is anymore. “Tell me builders are cool ..?” I guess.
01:22:57 <ertesx> quchen: in the worst case i would expect *building* to be as slow as traversing a String once
01:22:58 <Limona> ottanta i believe we've had group theories and souch, but not abstract algebra itself
01:23:04 <quchen> ertesx: Sure.
01:23:15 <quchen> ertesx: The resulting text is fast as Text.
01:23:35 <ertesx> quchen: however, i don't know what RULES are in place…  they might actually optimise individual character writes
01:23:37 <ottanta> Limona: anyway haskell's syntax is really really different from C-like languages like C++, python, java, javascript
01:23:49 <ottanta> Limona: it's kind of like coming to a tonal language from a romance one
01:23:55 <tdammers> ottanta: where exactly is Python syntax similar to C?
01:24:04 <DavisMan> *realizes there isn't any pot left* *hangs self with own shoelaces*
01:24:25 <Limona> ottanta yeah thought so. Hence my interest in it. 
01:25:36 <DavisMan> freaking 4 in the morning gotta bus a jog to keep myself awake
01:26:01 <ottanta> tdammers: foo(bar), semicolon support is explicitly the same, object.member, array[index], __foo__ for 'do not touch me' 
01:26:02 <tdammers> DavisMan: there's #haskell-blah and #haskell-offtopic for off-topic conversations
01:26:14 <ottanta> tdammers: the list goes on but much of the grammar is derived from C
01:26:40 <tdammers> ottanta: Python? The semantics and AST maybe, but the syntax doesn't have much more in common with C than Haskell does
01:26:47 <merijn> quchen: There's rules that turn String literals into text rather efficiently
01:27:05 <ottanta> tdammers: that is patently false
01:27:08 <tdammers> ottanta: semicolons are highly optional, and actively discouraged in PEP-8 and related style guides
01:27:26 <merijn> quchen: String literals are stored in the binary in some obscure ISO encoding and it builds String from that at runtime, Text has rules that skips the string building and goes directly from said encoding to Text
01:27:27 <DavisMan> so [char] is the value of "Davis"
01:27:42 <tdammers> DavisMan: casing matters. It's [Char], not [char]
01:27:49 <DavisMan> tok
01:28:09 <tdammers> DavisMan: char is a type variable; without further qualification, it means "any type you want, you pick"
01:29:15 <ottanta> tdammers: Python and C share way way WAY more similarities than C and Haskell, syntactically 
01:29:23 <tdammers> ottanta: which ones?
01:29:38 <ottanta> tdammers: how do you reference dictionary objects in Python
01:29:50 <ottanta> tdammers: how do you pass variables to functions
01:29:53 <merijn> I would like to point out that this is getting solidly off topic
01:29:55 <tdammers> ottanta: also, I didn't mean "C and Python" vs. "C and Haskell", but "C and Python" vs. "Haskell and Python"
01:30:00 <tdammers> merijn: agree
01:30:37 <ertesx> @quote HashMap Text
01:30:38 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
01:30:47 <merijn> I'm all for pedantic arguments about language semantics, but in here they should be about Haskell :) We have -offtopic for the rest (and ##programming)
01:30:47 <ertesx> @quote HashMap.Text
01:30:48 <lambdabot> No quotes match. It can only be attributed to human error.
01:30:51 <ottanta> tdammers: haskell came out 10 years after python
01:31:14 <ertesx> @quote HashMap.String
01:31:14 <lambdabot> ertes says: python can be summarised as HashMap String Dynamic
01:31:16 <GramCracker> but python is updated often enough
01:31:33 <ottanta> the first implementation of python came out a year before haskell's full implementation respectively
01:31:40 <ertesx> and now that we understand python, let's talk about haskell =)
01:32:09 <ottanta> lol
01:32:10 <GramCracker> is python not worth my time because thats what im learning right now.
01:32:30 <eklavya> how can I selectively re export definitions from a module?
01:32:32 <ottanta> nah I just derailed the chat from its topic which is haskell so
01:32:48 <ertesx> eklavya: just reexport them
01:32:52 <tdammers> ottanta: if you want to continue this, let's take it to #haskell-blah or #haskell-offtopic
01:33:02 <ertesx> module MyModule (print)  -- exports Prelude.print
01:33:17 <quchen> ertesx, tdammers: Oh, there’s the flush function for Builders!   "Pop the strict @Text@ we have constructed so far, if any, yielding a new chunk in the result lazy @Text@."
01:33:19 <eklavya> ertesx: I have a dummy module which re exports everything from all the modules
01:33:30 <eklavya> I need all the definitions to be visible inside the lib
01:33:34 <eklavya> but not from outside
01:33:47 <merijn> GramCracker: Depends on how you define worth your time. You should probably learn Python at some point, but tbh I wouldn't start with it. It encourages bad habits
01:33:50 <quchen> merijn: Oh, so Text works with GHC’s representation of Chars?
01:33:52 <quchen> Interesting.
01:33:54 <ertesx> eklavya: example?
01:33:56 <eklavya> so I was thinking if there was a way to limit visibility from that one module I am exporting
01:34:04 <merijn> quchen: No, this is different from GHC's Char representation
01:34:18 <merijn> quchen: GHC doesn't store Chars for string literals
01:34:21 <AndreasK> eklavya: You can restrict what a module exports as well
01:34:41 <GramCracker> merijn: where is a good place to start>
01:34:49 <quchen> merijn: Oh?
01:34:54 <ertesx> eklavya: you can either reexport a whole imported module ("module A (module B)"), or you can reexport individual definitions ("module A (b1, b2, b3)")
01:35:00 <merijn> quchen: It stores string literals as an array of binary data (i.e., like C programs do), except not ascii, but some weird iso encoding, iirc
01:35:04 <eklavya> this is what I have http://lpaste.net/348084
01:35:13 <merijn> quchen: This data is then used to (lazily) construct a String at runtime
01:35:17 <eklavya> I had to do it this way to please haddock
01:35:31 <eklavya> but the problem is I only want certain things visible to the user
01:35:33 <merijn> quchen: Text has a rule that replaces the "binary -> String" code with a direct "binary -> Text" conversion
01:35:34 <eklavya> and in haddock
01:36:12 <ertesx> eklavya: as i said, don't reexport the whole module, but individual definitions
01:36:34 <eklavya> you mean module CQL (module Batch(A, B) ..) ?
01:36:45 <ertesx> module CQL (A, B)
01:36:52 <merijn> GramCracker: Haskell, OCaml, maybe Go (I actually really dislike Go, but it's better than Python/Ruby (to dynamic) and Java (to OO)) modern C++ would be ok, but I can't in good conciousness recommend that to a beginner :)
01:37:00 <ertesx> eklavya: Batch is imported, so you can just refer to the identifiers as is
01:37:09 <eklavya> oh
01:37:17 <eklavya> got it
01:37:34 <merijn> GramCracker: Oh, if you wanna follow the hip dynamic crowd anyway then I suppose Erlang is an acceptable language. TypeScript also looks rather sane for web stuff
01:37:34 <eklavya> thanks ertesx AndreasK :)
01:37:46 <ertesx> eklavya: another way is to import the modules using an import list, but i highly recommend not doing that, because it makes the haddocks very confusing
01:38:03 <eklavya> ok
01:38:14 <ertesx> eklavya: module CQL (module Batch) where import Batch (A, B)
01:38:20 <ertesx> eklavya: don't do that
01:38:38 <ertesx> from the haddocks it will appear as if the whole Batch module is reexported, which is misleading
01:38:42 <ertesx> it's a shortcoming of haddock
01:38:49 <merijn> quchen: But I can't quickly find this stuff documented anywhere
01:38:54 <GramCracker> well i guess ill look more into haskell then
01:38:58 <eklavya> I should do module CQL (AFromBatch, BFromDriver), right?
01:39:24 <quchen> merijn: But that’s only for converting string literals, not any String, right?
01:40:02 <merijn> quchen: Right, because non-literal Strings aren't stored densely encoded
01:40:21 <quchen> merijn: I wondered about this for quite some time (whether OverloadedStrings used [Char] somewhere). Very happy to hear about this!
01:40:22 <merijn> quchen: They're generated at runtime and then it's just the usual fusion and RULES that apply
01:44:40 <merijn> quchen: https://github.com/bos/text/blob/bb3d8623d83b327f99d0520237e5ab44dbb5a9d8/Data/Text/Lazy.hs#L423-L430
01:45:12 <merijn> quchen: There's the rule that replaces GHC.unpackCString# (which is from GHC.Base, which apparently has no haddocks) and replaces it with a custom one
01:48:40 <quchen> merijn: Ah, and a CString# is probably a packed primitive array
01:48:54 <bollu> what is the haskell equivalent of assert()? along the lines of "you have broken a hard invariant" (eg. index out of bounds), "now crash / stack trace"
01:48:59 <merijn> quchen: Right
01:49:04 <quchen> bollu: assert.
01:49:10 <bollu> (it actually is index out of bounds for matrices that I'm trying to represent)
01:49:22 <bollu> quchen: oh, cool. It's haskell, right? not a GHC extension?
01:49:22 <quchen> > assert False "hello bollu"
01:49:24 <lambdabot>  "*Exception: Assertion failed
01:49:25 <lambdabot>  CallStack (from HasCallStack):
01:49:25 <lambdabot>    assert, called at <interactive>:3:1 in interactive:Ghci1
01:49:27 <quchen> > assert True "hello bollu"
01:49:30 <lambdabot>  "hello bollu"
01:49:41 <bollu> quchen: right, so it part of the haskell standard? or it a GHC extension?
01:50:02 <bollu> as much as haskell ~= GHC right now, I'd like to keep it portable out of some sense of.. idk
01:50:08 <bollu> cleanliness
01:50:16 <quchen> bollu: You can write it in plain Haskell, but GHC optimizes all assert calls away so you don’t have any overhead.
01:50:28 <bollu> quchen: okay, thank you :)
01:50:32 <quchen> So it’s GHC-well-supported standard Haskell.
01:50:42 <bollu> quchen: out of curiosity, how does one get the stack trace without compiler support?
01:50:53 <cocreature> tbh unless you work for standard chartered there is no haskell != ghc
01:50:56 <bollu> (since haskell execution does not have a "stack" AFAIK?)
01:51:27 <cocreature> bollu: you can get some sort of trace using DWARF debug info
01:51:45 <cocreature> but they are not easy to interpret most of the time
01:51:46 <merijn> cocreature: Sure there is
01:51:48 <merijn> cocreature: UHC
01:51:59 <quchen> bollu: One does not
01:52:20 <quchen> bollu: But you asked about assert, not stack traces :-)
01:52:35 <bollu> quchen: but the assert showed the stack trace? 
01:52:41 <bollu> quchen: " CallStack (from HasCallStack)"
01:52:42 <cocreature> merijn: fair enough, but tbh the number of people using it is small enough that you don’t need to worry about it
01:52:44 <quchen> (I don’t know how GHC generates stack traces anyway, since GHC does not have a call stack)
01:52:55 <bollu> quchen: yes, which was why I was asking
01:52:57 <hvr> cocreature: ...in some university courses, Haskell = Hugs98 still holds :)
01:52:59 <quchen> bollu: assert calls error on failure, and that has a stacktrace nowaday
01:52:59 <quchen> s
01:53:19 <bollu> hvr: really?
01:53:26 <hvr> bollu: unfortunately, yes
01:53:42 <cocreature> hvr: even if that is the case (I knew it was at some point, not sure if that is still true) you don’t target these courses if you implement a library
01:53:49 <hvr> bollu: iirc also Erik Meijers some time ago rejected GHC
01:53:49 <quchen> hvr: s/still/again/
01:53:54 <hvr> bollu: for his only MOOC
01:53:58 <hvr> s/only/online/
01:54:07 <bollu> also, I wanted a quick code review of this spock + persistent simple server I wrote that clocks in ~100 LOC:http://lpaste.net/347809 
01:54:17 <bollu> hvr: why?
01:54:26 <hvr> bollu: that FTP/AMP crazyness
01:54:38 <hvr> he didn't like the generalisations
01:54:55 <bollu> hvr: I see.
01:55:14 <tdammers> IIRC Erik Meijers decision to abandon GHC was in a teaching context, the argument being that Hugs was more suitable for his purpose
01:55:21 <DavisMan> i like gorillas
01:55:23 <Ferdirand> sorry, what is FTP/AMP ?
01:55:32 <quchen> Graham Hutton is also not a fan of FTP/AMP.
01:55:38 <Ferdirand> foldable-traversable-?
01:55:40 <bollu> Ferdirand: foldable traversable proposal, applicative monad proposal
01:55:42 <Ferdirand> applicative-monad-?
01:55:44 <quchen> Where “not a fan” is quote a euphemism.
01:55:47 <quchen> quite*
01:55:48 <Ferdirand> aaah, thx
01:55:49 <hvr> Ferdirand: https://wiki.haskell.org/Foldable_Traversable_In_Prelude
01:56:06 <bollu> hvr: I still think partial functions in Prelude is a terrible idea
01:56:27 <bollu> also, could someone pease review the code that I pasted? http://lpaste.net/347809 
01:56:37 <hvr> bollu: well, if somebody puts in the work, we could have a partial-function warning attached/inferred
01:56:39 <DavisMan> haskell already seems like avery neat language, i am already liking the (let) syntax
01:56:54 <hvr> bollu: which you can then promote to -Werror=partial-functions for your own code
01:57:15 <bollu> hvr: how would you detect partial functions?
01:57:25 <quchen> hvr: You mean the "errable" constraint someone brought up some time ago?
01:57:27 <bollu> hvr: feels turing-complete at first glance?
01:57:46 <hvr> bollu: similiar to SafeHaskell... manual annotations + best-effort inferral via callgraph
01:57:56 <bollu> hvr: I see
01:58:17 <bollu> hvr: liquidhaskell does some cool things with partiality. doesn't let you index out of bounds and such, I played around with it for a very small amount of time
01:58:20 <hvr> bollu: and yes, in general it's NP-hard, hence why a manual best-effort/manual approach would be needed
01:58:39 <bollu> hvr: huh, it's decidable though? that's.. interesting
01:58:55 <bollu> hvr: why NP hard?
01:59:18 <hvr> bollu: deciding partiality requires in general deciding termination
01:59:37 <merijn> Which is why we should throw out Turing completeness and all write in total languages!
01:59:42 <hvr> (depending how you define partiality)
02:00:25 <bollu> hvr: I don't understand, how is it NP-hard and not turing complete? wouldn't it be equivalent to the halting problem?
02:00:50 <quchen> merijn: Haskell’s typeckecker is total and I can still write programs that take hours to compile. Turing-completeness is overrated. Turing-incompleteness is overrated.
02:00:50 <hvr> bollu: anyway, it would be an interesting project to try to implement such a warning for GHC... I'm sure many would like to have that opt-in facility
02:01:13 <merijn> bollu: NP-hard is computational complexity description. Turing completeness is a computational power description. They describe different things
02:01:14 <DavisMan> so the command map is used liek print in c++?
02:02:50 <bollu> merijn: no, I mean, if something is turing complete, how can you measure how hard something is if its not even decidable?
02:03:26 <bollu> merijn: hm, I think I understand what you're saying, but I don't understand why (and how) you would measure the complexity of something that is not decidable
02:03:31 <bollu> merijn: ELIundergrad? :)
02:04:56 <merijn> bollu: hvr was saying that ruling out a subset of partiality is NP-hard, and ruling out partiality completely is impossible due to Turing completion
02:05:39 <merijn> hvr: I've been playing with tracking some partiality (i.e., exceptions), but I'm afraid I don't ever see that being able to be retrofitted into GHC/Haskell :\
02:05:52 <bollu> merijn: ahh, okay, thanks!
02:05:53 <hvr> bummer :-/
02:06:10 <bollu> so, how would someone even start working on GHC? the codebase size is daunting
02:06:16 <merijn> Checked exceptions would be nice, but I'm not sure you can do something like that without overhauling the type system
02:06:22 <hvr> bollu: by getting somebody on #ghc to mentor you :)
02:06:24 <DavisMan> https://www.haskell.org
02:06:36 <merijn> bollu: tbh, since it's all purely functional it's not that hard to dive in compared to many smaller projects I've seen :p
02:07:23 <pavonia> What practically relevant programs would you lose if you'd give up Turing completness?
02:07:37 <merijn> pavonia: I'm more and more convinced that the answer is "none"
02:08:12 <merijn> pavonia: There's some slight of hand tricks (similar to Haskell's IO) that you can use to produce "infinite" loops in a total language
02:08:36 <bollu> hvr: so who would mentor me? :P
02:08:53 <merijn> pavonia: By for example, having a "Partial" monad that evaluates at most N steps and then returns either a result or a continuation and then having a runtime call the continuation repeatedly or something similar to simulate an infinite loop
02:09:14 <merijn> pavonia: And most non-terminating programs are basically : infinite request handling loop with terminating request handlers
02:09:24 <liste> can you implement an interpreter for a non-total language in a total language?
02:09:31 <merijn> bollu: Plenty of people answering questions in #ghc :)
02:09:42 <merijn> liste: See above hacky workaround :)
02:10:29 <liste> merijn: I see
02:11:01 <merijn> liste: That way you move the partiality to the runtime, the same way haskell moves IO to the runtime :)
02:11:14 <pavonia> merijn: Does total also mean needs to stop after some amount of iterations?
02:11:35 <merijn> pavonia: total means it has to terminate in a finite number of steps
02:12:00 <merijn> pavonia: But, by ensuring it always returns after N steps you automatically guarantee finiteness
02:12:15 <pavonia> Oh, my understanding of it was completely wrong then
02:13:28 <DavisMan> Ok finished the tutuorial and now I have documentation to do 
02:15:02 <AndreasK> bollu: If you already have a idea what you want to work on I found it not hard to just starting to browse the code, read the wiki regarding that topic and so on
02:16:54 <pavonia> Okay, total function seems to mean different things in programming and mathematics
02:17:37 <merijn> pavonia: In PLT a total function is one that for every input produces an output in a finite time :)
02:18:13 <merijn> pavonia: I think the meaning is rather similar, but in PLT everything is implicitly constructive/intuitionistic :)
02:18:30 <pavonia> Yeah, I was thinking of non-partial functions
02:19:35 <merijn> pavonia: Well, partial is the inverse of total in PLT too, i.e. a function that results in bottom for any input value, whether that is due to non-termination of an accepted value or being passed an unacceptable value
02:20:54 <merijn> iow, the restrictions of partial and total in programming languages discussions are a superset of the restrictions in math in general, therefore any partial math function is always a partial function in a PLT setting (but not all total math functions are total PLT functions), similarly any total PLT functions must be a total function in general math terms
02:21:03 <lyxia> pavonia: what difference are you making
02:21:39 <tdammers> merijn: IIRC wikipedia passive-aggressively redirects "total function" to "function"
02:21:46 <merijn> tdammers: :)
02:25:03 <pavonia> lyxia: Maybe my understanding is wrong here but I would consider a function f x = f x total because it has a definition (in some sense) for all values
02:26:09 <tdammers> pavonia: it has a recursive definition that doesn't terminate, a.k.a. bottom, a.k.a. a gap
02:26:56 <pavonia> tdammers: Right, but you can't prove that in general, can you?
02:27:23 <tdammers> pavonia: not in finite time ;)
02:27:28 <pavonia> Is f(x) = f(x) even total in the mathematical sense?
02:27:50 <jameseb> pavonia: it has to actually return a value for all inputs to be total
02:28:56 <pavonia> I see
02:29:03 <jameseb> pavonia: and f(x)  = f(x) would be satisfied by all functions I think
02:29:22 <jameseb> it only makes sense if x is in the domain of f though
02:32:36 <tdammers> f(x) = f(x) is a tautology
02:32:40 <tdammers> in math, that is
02:32:46 <tdammers> in Haskell, it'd be a recursive definition
02:33:16 <Profpatsch> WHY does the encoding depend on system locale?!
02:33:40 <Profpatsch> It’s basically the worst possible way to handle it.
02:34:09 <merijn> Profpatsch: No, it's the only sane way to handle it
02:34:18 <merijn> Profpatsch: What the hell else should it do?
02:34:28 <Profpatsch> Locale = how the user wants things displayed /////===== How datastreams are encoded
02:34:36 <merijn> Profpatsch: Eh...no
02:34:43 <Profpatsch> It’s not even a related thing.
02:34:43 <merijn> Profpatsch: locale is also how things are encoded
02:34:52 <merijn> Profpatsch: Blame the pre-unicode era
02:35:06 <Profpatsch> merijn: Are you shure?
02:35:11 <Profpatsch> *sure
02:35:28 <merijn> Profpatsch: Yes, there's a reason why my locale is "en_US.UTF-8" as opposed to "en_US.ISO-whatever"
02:35:49 <merijn> Profpatsch: Before unicode not all encodings had all characters, such as the currency symbol for said location
02:36:41 <merijn> So you need an encoding that can actually write in the language you want. Ascii doesn't have a yen, pound, or say ẞ character
02:36:54 <Profpatsch> I KNOW what encodings are for.
02:37:12 <Profpatsch> But you are wrong in that locale is the encoding of datastreams
02:37:13 <merijn> The only way to sanely deal with it is specify encoding and localisation at the same time. To ensure the encoding can actually deal with the locale
02:37:17 <Profpatsch> > env LANG=ISO-8859-1 echo "お待たせしました" > foo
02:37:19 <lambdabot>  <hint>:1:9: error:
02:37:19 <lambdabot>      parse error on input ‘=’
02:37:19 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
02:37:26 <Profpatsch> file foo
02:37:32 <Profpatsch> foo: UTF-8 Unicode text
02:38:07 <merijn> Profpatsch: That's because, presumably your terminal is inputting UTF-8 bytesequences to type those
02:38:13 <Profpatsch> The ONLY sane way is to specify a default decoding and let the user set it.
02:38:21 <merijn> Profpatsch: Your terminal should produce data in the same encoding as your locale
02:38:28 <Profpatsch> Because only the user knows what encoding his input will be.
02:38:54 <merijn> Profpatsch: Right, which is why it's the users job to make sure his/her terminal and locale are set up to what they want
02:39:10 <merijn> Locale is the only way for the user to communicate what he wants/expects
02:39:24 <merijn> So how would you possibly decide on an encoding different from specified there
02:39:25 <Profpatsch> still not correct
02:39:27 <Profpatsch> env LANG=ISO-8859-1 bash -c "echo "お待たせしました" > foo"
02:39:33 <Profpatsch> > file foo
02:39:34 <Profpatsch> foo: UTF-8 Unicode text
02:39:35 <lambdabot>  error: Variable not in scope: file :: t0 -> terror:
02:39:35 <lambdabot>      • Variable not in scope: foo
02:39:35 <lambdabot>      • Perhaps you meant ‘for’ (imported from Data.Traversable)
02:39:42 <merijn> Profpatsch: bash is not your terminal
02:39:48 <Profpatsch> what
02:39:55 <merijn> Profpatsch: You need to set xterm/whatever you use to iso-8859-1
02:40:01 <Profpatsch> It’s my *shell* that handles redirection.
02:40:12 <merijn> Profpatsch: Yes, but it's your terminal that handles what your shell gets
02:40:21 <merijn> Profpatsch: bash just sees bytes
02:40:44 <merijn> Profpatsch: Your terminal is turning those unicode characters into utf-8 bytes, which bash happily echoes to a file
02:40:50 <merijn> Which then, of course, is a utf-8 file
02:41:15 <merijn> If your xterm doesn't match what your locale is set too then your system is configured wrong
02:41:26 <mpsag> this http://lpaste.net/4967679742875533312 is returning `Unrecognized option 'i /home/vagrant/videos/original/testtets.wmv'` - what am I doing wrong?
02:41:45 <mpsag> OOPS
02:41:47 <mpsag> sorry
02:42:33 <mpsag> wrong channel
02:42:48 <merijn> bash --noprofile
02:43:49 * hackagebot hsoz 0.0.0.2 - Iron, Hawk, Oz: Web auth protocols  https://hackage.haskell.org/package/hsoz-0.0.0.2 (rvl)
02:44:26 <Profpatsch> merijn: Okay, Python does it the same way.
02:45:30 <merijn> Profpatsch: I couldn't find iso-8859-1 in my encoding list, but if I start Terminal.app with "Japanese (Shift JIS X0213)" as encoding I get: http://lpaste.net/4834276916200472576
02:45:47 <merijn> As expected, since now it's written Shift JIS to said file
02:45:55 <Profpatsch> So the locale decoding is pretty much the only way to do it.
02:46:19 <merijn> Profpatsch: Yes, because you can't query the terminal emulator (you communicate via a byte-stream through the kernel)
02:46:44 <Profpatsch> But: can we please make Handle encoding errors output something more than what they do currently?
02:47:04 <merijn> Profpatsch: What do they currently do?
02:48:12 <merijn> Anyways, nowadays most terminal emulators default to utf-8, so I'd say most systems should have their locale set to that and I'd consider it a bug in your distro if it ships with an incorrect default locale
02:49:42 <merijn> That or we'd need encoding support for pipes/byte streams in the kernel, but I don't see that happening, look at the mess with ext[2-4] not specifying the encoding of file names. At least Apple/MS had the common sense to specify the encoding of filenames so that they can always be output sanely
02:49:58 <Profpatsch> merijn: jbovlaste.xml: hGetContents: invalid argument (invalid byte sequence)
02:50:11 <Profpatsch> That’s all
02:50:25 <Profpatsch> No source line. Not the byte which was wrong.
02:50:28 <Profpatsch> No locale used.
02:50:55 <Profpatsch> We can get stack traces in GHC 8, right?
02:51:08 <merijn> Profpatsch: tbh, I think in GHC8 you should be able to change that to have a stack trace, yes.
02:51:42 <Profpatsch> merijn: Do you know where to file a bug for that? GHC or base libraries?
02:51:43 <merijn> Locale used should be possible, because you can query the detected locale (and even overwrite it) in user code
02:52:29 <Profpatsch> Well, exactly the code that throws the error there should have the handle decoding VERY close, since it uses it to decode the byets.
02:52:33 <merijn> hGetContents for String is in base, I think? So ticket should go to GHC trac, backwards incompatible changes should be discussed on libraries@
02:53:03 <Profpatsch> It’s only backwards incompatible because HasCallStack is only GHC 8
02:53:08 <merijn> I think you could improve it without major changes, but not whether it's perfect
02:53:10 <Profpatsch> So #ifdef should be enough.
02:53:49 * hackagebot derive-storable 0.1.0.4 - Derive Storable instances with GHC.Generics.  https://hackage.haskell.org/package/derive-storable-0.1.0.4 (mkloczko)
02:53:54 <merijn> Profpatsch: THat's actually not a problem, since base is tied to GHC it doesn't have to be backwards compatible in terms of GHC support, just in terms of code using it not changing behaviour/performance
02:55:46 <Profpatsch> Well, adding a callstack should not have any semantics changes apart from the user interface.
03:08:50 * hackagebot hascas 1.0.0 - Cassandra driver for haskell  https://hackage.haskell.org/package/hascas-1.0.0 (eklavya)
03:09:43 <eklavya> hackage says docs pending? Will it generate docs or is that bug where docs are never generated still there?
03:10:26 <ramadoka> test
03:11:30 <eklavya> ?
03:13:50 * hackagebot digestive-bootstrap 0.3.0.0 - Speed up form designing using digestive functors and bootstrap  https://hackage.haskell.org/package/digestive-bootstrap-0.3.0.0 (AlexanderThiemann)
03:13:52 * hackagebot snap-cors 1.2.11 - Add CORS headers to Snap applications  https://hackage.haskell.org/package/snap-cors-1.2.11 (OliverCharles)
03:18:06 <eklavya> how can I use stack to upload docs to hackage, I have a script from glguy but that uses cabal and I am scared I will mess up my setup trying to get cabal to work :(
03:19:43 <ongy> I was under the impression that hackage is intended for packages that work with cabal
03:20:36 <eklavya> ongy: what do you mean, if it works with stack won't it work with cabal?
03:20:45 <eklavya> the project has a .cabal file
03:21:47 <ongy> I don't use stack, so I don't know. maybe I got your question a bit wrong, do you mean set up cabal to work locally with "get cabal to work"?
03:22:07 <eklavya> I have uploaded a package to hackage
03:22:15 <eklavya> but the docs generation of hackage is off (?)
03:22:23 <eklavya> so I want to manually upload docs
03:22:27 <Profpatsch> merijn: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.IO.Encoding.Failure.html#ioe_decodingError
03:23:44 <ongy> yes. and you said something about getting cabal to work. Do you mean your local setup, or for your package? If it's local, I would try stack exec the script, but as I said, I'm not really familiar with stack
03:24:16 <eklavya> let me try that :P
03:24:44 <eklavya> wait is stack exec for haskell files?
03:24:50 <eklavya> oh wait
03:24:56 <eklavya> stack exec is how I run my project
03:25:05 <eklavya> I have a shell script 
03:25:10 <hvr> eklavya: does the doc builder fail to build the docs for you?
03:25:19 <eklavya> which can upload docs to hackage
03:25:44 <hvr> eklavya: or rather, which package is it?
03:25:49 <eklavya> hvr: a while back I read it here that doc generation was not working on hackage
03:25:58 <eklavya> https://hackage.haskell.org/package/hascas
03:26:14 <eklavya> people suggested to manually upload docs
03:26:19 <hvr> eklavya: https://hackage.haskell.org/package/hascas-1.0.0/reports/1
03:26:35 <hvr> eklavya: looks all fine to me
03:27:05 <hvr> eklavya: https://hackage.haskell.org/package/hascas-1.0.0/docs/CQL.html
05:04:02 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
05:04:02 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
05:04:10 <Ferdirand> i'm thinking about this because my intuition sees a contradiction between apparently being able to translate all values to types and types to kinds, but not kinds to sorts
05:04:32 <merijn> Ferdirand: Oh, it's not that you couldn't translate kinds to sorts
05:04:45 <merijn> Ferdirand: It's just not useful in Haskell's theory
05:04:56 <merijn> Ferdirand: Because the theory haskell is based on ends there :)
05:05:10 <Ferdirand> here be dragons
05:05:11 <Ferdirand> okay
05:05:15 <merijn> Ferdirand: In other languages such a thing is certainly not ruled out
05:05:29 <Ferdirand> i have a case for the opposite though, so i can accept that
05:05:33 <merijn> Ferdirand: It's more of a "this is all we need to get what we want, so let's avoid doing work for no gain" :)
05:05:34 <Ferdirand> i know untyped languages
05:05:49 <Ferdirand> and typed languages without higher-order types
05:06:10 <merijn> As I said, there are multiple languages and theories that DO go past sorts and do allow you to lift/use kinds on the sort level :)
05:06:29 <Ferdirand> so
05:06:32 <Ferdirand> Nil is a value
05:06:48 <Ferdirand> of type HList '[]
05:06:52 <merijn> Right
05:06:53 <Ferdirand> both HList and '[] are types
05:07:02 <merijn> brb, I ran out of tea :)
05:07:37 <Ferdirand> the former of kind [*] -> *, the latter of kind [*]
05:07:43 <Ferdirand> i'll make some more myself
05:10:48 <Ferdirand> okay so
05:11:02 <merijn> Right
05:11:16 <merijn> So, the end result is "HList '[] :: *"
05:11:21 <Ferdirand> by default, a data declaration without a kind annotation on its left-side term
05:11:28 <Ferdirand> produces a type of kind *
05:11:37 <Ferdirand> and a kind of sort BOX
05:11:56 <Ferdirand> but here this annotation makes it so that the type is of kind [*] -> *
05:12:03 <Ferdirand> the kind is still of sort BOX, though
05:12:05 <merijn> Ferdirand: Well, if your data declaration has type parameters they are generally inferred
05:12:23 <merijn> "data Foo a = Bar a" -> "Foo :: * -> *"
05:12:25 <Ferdirand> oh right
05:12:26 <merijn> But yes
05:12:26 <Ferdirand> sorry
05:12:29 <Ferdirand> i'm an idiot
05:12:32 <merijn> The end result is * :)
05:12:38 <merijn> When fully applied
05:12:49 <Ferdirand> i was wondering if this kind annotation was tied into GADTs 
05:13:07 <merijn> Ferdirand: No, this is legal to: "data HList (l :: [*]) = Foo"
05:13:10 <Ferdirand> can you infer this kind from the defined clauses, actually ?
05:13:32 <merijn> Ferdirand: The reason you need GADTs is to restrict Nil to be '[] as opposed to any type of kind [*]
05:13:50 <Ferdirand> yes
05:13:52 <Ferdirand> aha
05:13:59 <Ferdirand> now it starts to make sense
05:14:08 <merijn> Ferdirand: I assume you're familiar with the usual Expr example of GADTs where you restrict, say an I constructor to "Expr Int"? :)
05:14:15 <Ferdirand> yes
05:14:28 <Ferdirand> but TBH that is the only use case I know for GADTs
05:14:38 <Ferdirand> it's like pretending to understand monads because you only know IO
05:14:40 <merijn> Ferdirand: Right, so this is the same. The fact that the argument is not of kind * is orthogonal here
05:14:54 <merijn> You can have non-GADTs with kind "[*] -> *" just fine :)
05:15:13 <NeoAnon> Hi
05:15:13 <merijn> But then you run into the same issue as with "data Expr a = I Int" :)
05:15:36 <Ferdirand> aha
05:16:15 <merijn> Ferdirand: So if you understand that example you understand this one :) We want to disallow "Nil :: HList [Bool, Char]", because that undermines everything :)
05:16:36 <merijn> Ferdirand: Thus we force "Nil :: HList '[]"
05:16:41 <Ferdirand> oooh
05:16:52 <Ferdirand> okay now I understand what HList does
05:17:38 <merijn> Ferdirand: Thus we also know that "HList [Bool,Char]" contains two elements, that is, 2 Cons that append a Bool and Char in front of Nil :)
05:17:42 <Ferdirand> Cons 1 (Cons 'a' (Cons "haha" Nil)) :: [Int, Char, String]
05:17:58 <merijn> Ferdirand: "HList [Int, Char, String]", but yes :)
05:18:10 <Ferdirand> for some reason
05:18:31 <Ferdirand> I find it much easier to write this code starting from the idea of needing heterogenous lists, than working out what they are from the code
05:18:36 <merijn> Ferdirand: There's some examples at the bottom, so maybe things would've been easier to skim down :)
05:19:20 <Ferdirand> yes, yes, sorry, i'm stubborn :)
05:19:23 <Ferdirand> okay so
05:19:31 <Ferdirand> now you need two separate instances for Show
05:19:32 <merijn> Ferdirand: Yes, most of the things aren't actually that complicated and putting them together (like lego) is pretty easy. Deciphering the result if you've never done it, however, is tricky :)
05:19:39 <Ferdirand> that is because
05:19:47 <kuribas> has nobody written a C++ like object system yet using existential quantification?
05:19:51 <merijn> Mostly because GHC's deriving is rather limited :)
05:20:18 <Ferdirand> ok so an instance is a relationship between a type and a class
05:20:44 <merijn> Ferdirand: Right, but since the GADT type result in having different types for different constructors you can't write it in one instance
05:20:48 <Ferdirand> a class has a kind, right ? in the sense that you can only instantiate types of the same kind for the same class ?
05:20:55 <Ferdirand> right
05:21:05 <merijn> Ferdirand: Yes, one of the other examples I linked plays with the kind of typeclasses :)
05:21:24 <merijn> "Show :: * -> Constraint"
05:21:36 <merijn> "Functor :: (* -> *) -> Constraint", etc.
05:22:25 <merijn> head and tail should also be fairly obvious to understand :)
05:22:55 <merijn> Note that they're total, because "Nil :: HList '[]" doesn't match the type of head and tail!
05:23:23 <Ferdirand> wait, wait wait
05:23:40 <Ferdirand> i've been fooled
05:23:45 <Ferdirand> those things are not lists
05:23:50 <Ferdirand> they are tuples in disguise !
05:24:31 <merijn> Ferdirand: A heterogeneous list is isomorphic to nested tuples, yes
05:24:51 <merijn> Ferdirand: But then, so is a regular list!
05:25:12 <Ferdirand> really ?
05:25:18 <merijn> [a] of length 2 = (a, (a, ())), [a] of length 3 = (a, (a, (a, ())))
05:25:19 <Ferdirand> let xs = 1 : xs
05:25:32 <Ferdirand> that has an analogous for nested tuples ?
05:25:38 <Ferdirand> that type-checks ?
05:26:09 <merijn> Ferdirand: During this discussion I actually started wondering whether I could pull off "repeat" for HList, I'm not sure, it's an interesting challenge :)
05:26:33 <Ferdirand> it is possible to define recursive types, right ?
05:26:47 <Ferdirand> i mean that weirdness with catamorphisms and anamorphisms
05:26:55 <Ferdirand> in the joke article about the evolution of a Haskell programmer
05:27:01 <merijn> Ferdirand: But, to show something that'd be harder to do than merely tuples, look at line 29 through 35 :)
05:27:30 <Ferdirand> type families. Something i've read about, but not used in practice yet
05:27:43 <Ferdirand> my impression was they were like type-level pattern matching
05:27:56 <merijn> Ferdirand: They're a limited form of type-level functions :)
05:28:15 <merijn> Ferdirand: In this case, we have one that takes two arguments of kind [*] and * and returns a type of kind *
05:28:42 <merijn> Basically, unfolding the type level list into a function type
05:29:22 <merijn> Which we can then use to define the type of 'apply' on line 33 (and there's an example using apply on the last line)
05:31:56 <Ferdirand> so
05:32:09 <Ferdirand> type family Fun (l :: [*]) (r :: *)
05:32:25 <Ferdirand> it introduces the type Fun, of kind [*] -> * -> * ?
05:32:31 <merijn> Right
05:32:34 <Ferdirand> and also a kind Fun, but that is irrelevant ?
05:33:01 <Ferdirand> btw, is there such a thing as data families ?
05:33:07 <merijn> Yes
05:33:20 <merijn> Ferdirand: I don't think type families get generalised to kinds
05:33:21 <Ferdirand> i'm just bothered by the fact that types are introduced with "data" and type families by "type family"
05:33:23 <merijn> Ferdirand: So no
05:33:38 <merijn> Ferdirand: "data family" is a thing too :p
05:33:56 * hackagebot wuss 1.1.3 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.3 (fozworth)
05:37:39 <Ferdirand> okay
05:37:44 <Ferdirand> i get what apply does
05:37:47 <Ferdirand> joy
05:38:40 <Ferdirand> and as a side effect I get why it is called type family and not type function now
05:39:27 <Ferdirand> okay then the next section is confusing me
05:39:37 <Ferdirand> Zippable is used as if it was a class
05:40:10 <merijn> "Zippable :: [*] -> [*] -> Constraint"
05:40:35 <plakband> In conduit, `sourceFileBS p` yields the contents of a file in 32kB chunks. Why does it not output the whole file at once, and can I safely use `sourceFile BS p .| (foldC >>= yield)` in order to get the whole file?
05:40:46 <merijn> Remember, "Show :: * -> Constraint" and "Functor :: (* -> *) -> Constraint", Constraint is the kind of, well, constraints
05:41:13 <kuribas> how many kinds are there?
05:41:29 <merijn> kuribas: Since you can define new ones, infinitely many
05:41:40 <kuribas> What about atomic ones?
05:41:44 <byorgey> even without being able to define new ones, there are infinitely many.
05:41:54 <merijn> Also, what byorgey said :)
05:42:04 <byorgey> kuribas: that depends.  Are you talking about Haskell 2010, or GHC Haskell with extensions?
05:42:11 <kuribas> with extensions
05:42:22 <merijn> Then uncountably infinite, afaict
05:42:45 <Ferdirand> Show :: * -> Constraint
05:42:49 <Ferdirand> that comes from which extension ?
05:42:54 <byorgey> how on earth could the number be *uncountable*?
05:43:13 <merijn> Ferdirand: That's how GHC represents typeclasses
05:43:21 <merijn> Ferdirand: ConstraintKinds gives the user access to them
05:43:47 <byorgey> kuribas: then there's *, and #, and Constraint.  But then you also have to count promoted data types as well
05:43:50 <Ferdirand> ok, because for the Haskell i know, classes and types live in separate spaces
05:44:17 <kuribas> byorgey: I see
05:44:18 <merijn> Ferdirand: Right, but the way GHC does things they don't :) Classes are just another type :)
05:44:24 <byorgey> Ferdirand: how quaint ;-)
05:44:42 <merijn> Ferdirand: And you can, in fact, give classes as argument types 
05:44:49 <merijn> :t Proxy :: Proxy Show
05:44:49 <byorgey> the way GHC does things now, kinds are just another type too =D
05:44:51 <lambdabot> Proxy Show
05:45:32 <merijn> Ferdirand: As far as GHC is concerned classes are types that (when fully applied) produce a type of kind Constraint
05:45:46 <merijn> Ferdirand: They behave exactly the same as other types
05:45:48 <Ferdirand> i can understand that
05:46:11 <merijn> Ferdirand: But, like type level lists cannot contain values (because Constraint /= *) :)
05:46:20 <Ferdirand> so formally
05:46:29 <Ferdirand> an instance declaration is bound to what
05:46:32 <Ferdirand> any constraint ?
05:46:33 <Ferdirand> no
05:46:43 <Ferdirand> i mean
05:47:01 <Ferdirand> you cannot have instance (Show a, Read a)
05:47:29 <Ferdirand> so is it that instances take a subset of constraints ? or rather that contexts are lists of constraints ?
05:47:31 <merijn> Ferdirand: You can think of Constraint being a "true/false" flag that you cannot inspect (but the compiler magically knows)
05:47:51 <Ferdirand> my question is just about the precise definition of Constraint
05:48:03 <merijn> Ferdirand: "internal compiler voodoo" :)
05:48:20 <lyxia> Ferdirand: Contexts are Constraints, I think.
05:48:31 <merijn> Ferdirand: GHC keeps track of which instances it knows about and during typechecking if it needs to check "is this constraint true" it looks it up in that list
05:48:53 <merijn> Ferdirand: The kind Constraint just indicates "it makes sense to ask this question"
05:48:56 * hackagebot hoogle 5.0.6 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.6 (NeilMitchell)
05:49:26 <lyxia> Ferdirand: while an instance is defined for a specific typeclass, which are a subset of constraints.
05:49:42 <Ferdirand> lyxia: okay, that makes the terminology clear, thanks
05:50:18 <Ferdirand> so wait
05:50:21 <jameseb> :k (Show Int, Read Int)
05:50:23 <lambdabot> Constraint
05:51:01 <Ferdirand> Zippable '[] '[] = ()
05:51:11 <Ferdirand> here () is a type
05:51:11 <merijn> Ferdirand: The empty (or trivial) constraint :)
05:51:14 <Ferdirand> of kind Constraint
05:51:40 <merijn> Ferdirand: Right
05:51:57 <lyxia> so much overloading
05:52:04 <merijn> lyxia: Sadly, yes
05:52:44 <Ferdirand> so why do you have to use a type family here
05:53:10 <merijn> Ferdirand: For the other cases :)
05:53:15 <Ferdirand> could you not have an empty class Zippable a b
05:53:37 <merijn> Ferdirand: Note that Zippable is recursing on the lists on the latter lines
05:53:39 <Ferdirand> then instance Zippable '[] '[]
05:54:23 <Ferdirand> then instance (Zippable as bs) => Zippable (a ': as) (b ': bs) ?
05:54:41 <merijn> Ferdirand: But then you can't write the last case :)
05:55:00 <Ferdirand> i do not know what ~ means in this context
05:55:15 <Ferdirand> and then, yes, you would not have the last case, but the compiler would err on missing instance ?
05:55:19 <merijn> ~ is type unification
05:55:25 <Ferdirand> which is not very user-friendly, I agree
05:55:30 <merijn> It tries to unify two types
05:55:51 <merijn> In this case two (different!) types of kind Symbol (type level strings)
05:55:59 <Ferdirand> but but but
05:56:09 <Ferdirand> okay
05:56:10 <merijn> Producing a type error (printing out both Symbols, hopefully enlightening the user about the exact error)
05:56:20 <Ferdirand> for consistency reason, why are these not written '"Error" ?
05:56:23 <merijn> It's a hacky way to get slightly more helpful errors
05:56:44 <Ferdirand> or do we want to enforce a difference between the Symbol and String kind ?
05:56:46 <merijn> Ferdirand: Laziness on my part? :)
05:56:54 <Ferdirand> oh but String is not a true type
05:57:00 <merijn> Ferdirand: Right :)
05:57:02 <Ferdirand> damn
05:57:07 <merijn> String is just [Char] :)
05:57:11 <ertes> > mappend undefined mempty :: ()  -- is this a known issue?
05:57:13 <lambdabot>  ()
05:57:22 <merijn> ertes: How is that an issue?
05:57:28 <lyxia> is that an issue
05:57:31 <merijn> ertes: "mappend _ _ = ()"
05:57:46 <ertes> undefined <> mempty ≠ undefined
05:57:49 <buttbutter> I need to read in a file (and store it in a matrix) that's formatted like this: x x x \n x x x \n... where x are floats. I was thinking of just using ReadP to do it...but is there a better way?
05:57:52 <ertes> mappend on () should be strict
05:57:59 <merijn> ertes: Says who?
05:58:09 <merijn> > undefined <> ()
05:58:11 <lambdabot>  ()
05:58:21 <ertes> merijn: the identity law
05:58:49 <merijn> ertes: I always assume laws are written totally
05:58:57 * hackagebot opentype 0.1.0 - Opentype loading and writing  https://hackage.haskell.org/package/opentype-0.1.0 (KristofBastiaensen)
05:59:11 <merijn> ertes: I don't consider that a bug
05:59:22 <byorgey> buttbutter: I would just use 'lines', 'words', and then map 'read'
06:00:02 <ertes> merijn: sure, for many types we would have to make that compromise, but () is a case that could be lawful even under "lifted" reasoning
06:00:16 <buttbutter> byorgey: That's...a far better idea :)
06:00:18 <buttbutter> byorgey: Thanks!
06:00:19 <merijn> ertes: I don't see that as desirable
06:00:20 <lyxia> > words "a\nb c"
06:00:22 <lambdabot>  ["a","b","c"]
06:00:55 <lyxia> Seems like words alone do the trick.
06:01:36 <lyxia> ah, it loses structure to store in a matrix.
06:02:50 <ertes> merijn: i can see why that's not much of an issue in practice, but why not desirable?  i don't see much potential for a performance hit (at least with GHC)
06:03:27 <merijn> ertes: I think the performance difference can be substantial
06:03:39 <merijn> ertes: Especially since that also disallows "mconcat l = ()"
06:03:39 <bonnie> do you know whether its possible to make an  Int to [Char] in this way : n => "n"?
06:03:54 <bonnie> maybe with case of?
06:03:59 <ertes> merijn: indeed, i see
06:03:59 <lyxia> show?
06:04:19 <lyxia> > show (99 :: Int) -- bonnie 
06:04:21 <lambdabot>  "99"
06:04:41 <bonnie> lyxia: thank you
06:05:33 <nil_> I'm truly sorry if this is noise but I could really use some help here. Repeating an earlier question:
06:05:43 <nil_> I'm writing a thesis that's mostly language agnostic, there's some pseudocode here and there. I want to be able to say "a BRDF is a function of type (angle, angle) -> (angle, angle) -> wavelength -> float", and I'm not sure I'm supposed to use the Haskell notation for "is of type", actually I'm pretty sure I'm not.
06:05:50 <nil_> So if the thesis itself is not about type theory nor can a typical reader be expected to know type theory notation what do you write? Do you write out the whole thing in natural language?
06:06:37 <lyxia> nil_: add a page explaining common notations you use at the beginning of your thesis
06:06:38 <ertes> nil_: if the underlying logical calculus of your thesis is type-theoretic, you can use the notation x : A
06:06:54 <ertes> nil_: otherwise i suggest going with standard notation: x ∈ A
06:07:25 <ertes> nil_: although even in set theory the notation f : A → B is common for functions
06:07:26 <nil_> ertes: that's basically what I'm doing. How do I introduce type synonyms like "type vector = (float, float, float)"
06:07:35 <kuribas> > printf "%x" 20 --bonnie
06:07:37 <lambdabot>  error:
06:07:37 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M546408613308...
06:07:37 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:07:53 <jophish> Is putting a bang on the single field of a data constructor the same (in terms of strictness) as using a newtype. If someone knows the answer to this could they chime in here please: https://github.com/ndmitchell/hlint/issues/285
06:07:53 <kuribas> > (printf "%x" (0x20::Int))
06:07:56 <lambdabot>  error:
06:07:56 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M763510428434...
06:07:56 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:07:57 <jophish> I'm pretty sure that's the case
06:08:17 <ertes> nil_: it's a style choice mainly…  most mathematicians are comfortable with:  "vector := float³"
06:08:18 <kuribas> > printf "%x" 0x20 :: String
06:08:20 <lyxia> jophish: not quite
06:08:20 <lambdabot>  "20"
06:08:22 <bollu> anyone know why cabal cannot write to /usr/bin/ar? Here is the Travis log: https://travis-ci.org/bollu/symengine.hs/jobs/180021525#L2618
06:08:47 <nil_> Excellent, thank you.
06:08:51 <nil_> lyxia++
06:08:52 <ertes> nil_: decide depending on your target audience
06:08:53 <nil_> ertes++
06:09:10 <jophish> lyxia: oh, how so?
06:09:26 <lyxia> > let f (Identity x) = x in f undefined
06:09:29 <lambdabot>  *Exception: Prelude.undefined
06:09:34 <lyxia> wait no
06:09:37 <lyxia> > let f (Identity x) = () in f undefined
06:09:39 <lambdabot>  ()
06:09:53 <lyxia> > let f (I x) = () in f undefined -- data I x = I !x
06:09:55 <lambdabot>  *Exception: Prelude.undefined
06:11:15 <lyxia> jophish: That's the only case where they are different that I know of.
06:11:32 <lyxia> I don't know if that's relevant to the issue you mentioned. *goes to read*
06:11:38 <bollu> cabal is failing weirdly, I need help on how to fix this: https://travis-ci.org/bollu/symengine.hs/jobs/180021525#L2618
06:11:41 <jophish> lyxia: thanks!
06:12:15 <www-bukolay-net> Hi
06:12:23 <bollu> www-bukolay-net: hey
06:12:37 <www-bukolay-net> Help mi
06:12:41 <www-bukolay-net> Me
06:13:10 <ertes> www-bukolay-net: with what?
06:13:13 <bollu> www-bukolay-net: with?
06:15:34 <ertes> merijn: interesting observation: for the () group the inverse function in fact has to be non-strict to be lawful, if you take ⊥ into account
06:15:48 <www-bukolay-net> Seo help
06:15:50 <www-bukolay-net> Pls
06:17:17 <dsub> www-bukolay-net: are you spam? You sent almost exactly the same messages a couple of days ago without posing a question, and your name is a URL so...
06:17:26 <ertes> www-bukolay-net: this channel is for discussion about the haskell programming language, but there are uncountably many SEO consulting companies you can approach
06:17:47 <dsub> #haskell.11-28.log:12:25 < www-bukolay-net> Hi
06:17:47 <dsub> #haskell.11-28.log:12:26 < liste> hi www-bukolay-net
06:17:47 <dsub> #haskell.11-28.log:12:26 < www-bukolay-net> Help mi
06:17:47 <dsub> #haskell.11-28.log:12:26 < www-bukolay-net> Pls
06:17:47 <dsub> #haskell.11-28.log:12:26 < www-bukolay-net> Logo error
06:17:49 <dsub> #haskell.11-28.log:12:26 < www-bukolay-net> File
06:17:52 <dsub> #haskell.11-28.log:12:26 < www-bukolay-net> How
06:17:54 <dsub> #haskell.11-30.log:15:12 < www-bukolay-net> Hi
06:18:00 <ertes> hehe
06:18:50 <jophish> hahah
06:19:19 <www-bukolay-net> How?
06:19:35 <www-bukolay-net> İ dnot  know
06:19:58 <www-bukolay-net> Logo error?
06:20:07 <www-bukolay-net> ●
06:20:27 <www-bukolay-net> Want Seo help
06:20:34 <zomg> someone needs to explain to him in turkish his english is impossible to understand :p
06:21:57 <quchen> Anyone Turkish here? ertes? ;-)
06:22:02 <Reisen> Silly question, if I have a function that takes 10 Maybe's as arguments, is it possible to pass the first 9 as Nothing using fix?
06:22:07 <ertes> sorry, my turkish is pretty bad
06:22:11 <Reisen> So as to not have to list them all out
06:22:48 <quchen> Reisen: No, fix is something completely different
06:23:00 <Reisen> Yeah I thought I was probably misunderstanding it
06:23:23 <quchen> Fix is a function to introduce recursion in a non-recursive setting, what you want is convenience to avoid repetition
06:23:26 <ertes> Reisen: do you need exactly 10?  often it's better to just generalise your function, even if you only ever plan to use it on 10 arguments
06:23:33 <ertes> Reisen: for example take a list as your argument
06:23:55 <tdammers> uncurry10 :P
06:23:58 <Reisen> ertes, It's just a particularly large value constructor of a lot of Maybe values
06:24:21 <Reisen> I could define a mkDataFromX and then shift the ugliness out into that function
06:24:21 <tdammers> seriously, would a record type with a Default instance work?
06:24:26 <ertes> Reisen: could you show us the definition?
06:24:40 <tdammers> then you could just write def { theFieldThatIsntNothing = Just someValue }
06:24:59 <LordBrain> i don't think a function with 10 maybes as parameters is necessarily a bad design
06:25:01 <ertes> Reisen: there is probably a super-easy way to get rid of the redundancy by using generics and Applicative =)
06:25:19 <quchen> I’ve had a 10-tuple and my mempty definition for it was “let e = mempty in Foo e e e e e e e e e e” :-/
06:25:31 <LordBrain> there are trade offs if you go to a record
06:25:47 <Reisen> Essentially this just comes from another library
06:25:48 <Reisen> http://lpaste.net/6961310618586447872
06:25:50 <Reisen> And looks like this
06:25:57 <kuribas> Reisen: just copy-past Nothing 9 times in your editor?
06:26:08 <Reisen> Yeah I can
06:26:10 <Reisen> I was just purely curious
06:26:13 <tdammers> oh, so you have a record type already
06:26:22 <Reisen> Yes, this is a record type I'm importing from elsewhere
06:26:27 <Reisen> I only care about setting the last value
06:26:42 <Reisen> And writing Nothing 10 times just kind of looked horrible
06:26:43 <ertes> Reisen: are you in control of that other library?
06:26:46 <Reisen> No
06:26:51 <tdammers> then I'd probably write an "all-Nothing" value (similar to what a Default instance would look like)
06:26:54 <kuribas> Reisen: or define defaultLargeX = SomeLargeX Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing 
06:26:57 <ertes> Reisen: then you will have to wrte a helper function
06:27:01 <ertes> write
06:27:03 <LordBrain> you can make functions which are simply wrappers on calls to that with lots of Nothing filled in
06:27:14 <tdammers> and then write defaultSomeLargeX { fieldThatInterestsMe = Just blah }
06:27:18 <Reisen> Yeah I mean, It's clearer anyway to have a makeXFromEmail function so I know this is probably the right way
06:27:52 <ertes> Reisen: look at the class instances of that type…  perhaps they made it easy some way
06:28:10 <tdammers> or use lenses, then you can write set fieldThatInterestsMe (Just blah) defaultLargeX
06:28:52 <Reisen> Will have a look around or just go with a helper function
06:28:58 <Reisen> Thanks
06:32:37 <bollu> is there a good tutorial on using type level nats?
06:32:43 <bollu> I want it for bounds checking on arrays
06:32:45 <bollu> and matrices
06:33:25 <EvanR> good question
06:34:02 <EvanR> i think we need to compile a list of subjects which can only be learned through mysterious osmosis, thats not good
06:34:18 <tdammers> but ghcjs on that list
06:34:21 <tdammers> s/but/put
06:34:40 <peddie> bollu: perhaps https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html is relevant?
06:35:58 <bollu> peddie: thank you
06:37:56 <EvanR> also, can only be learned through random blog posts is another one
06:38:14 <EvanR> somehow that doesnt sit well with me, thats how ruby manages to work
06:38:54 <bollu> oh my fucking god, using a type family to implement + is gorgeous.
06:38:55 <EvanR> like, blog posts instead of documentation or a guidebook
06:38:55 <merijn> EvanR: I disagree, type level nats are not mature enough for this
06:38:57 <bollu> that's so brilliant
06:39:16 <EvanR> type level nats in ghc arent mature?
06:39:20 <EvanR> or the idea of type level natas
06:39:27 <merijn> EvanR: There's no solver for basic arithmetic
06:39:33 <merijn> EvanR: So even the most trivial things are a pain
06:39:40 <bollu> merijn: can I do a < and > check?
06:40:08 <hodapp> I thought somebody wrote a solver but I can't recall
06:40:09 <merijn> bollu: Yes, but only if both sides are a Nat directly and not an addition/subtraction, etc. afaik
06:40:16 <EvanR> so because its the way it is, we need to not tell people about it, and discourage them from learning about it and its limitations?
06:40:22 <merijn> hodapp: It's a plugin, not yet really in GHC, afaik?
06:40:26 <hodapp> merijn: maybe you're right
06:40:43 <bollu> merijn: I see, that is unfortunate
06:40:50 <merijn> EvanR: I'm not saying that, but production ready things are generally well documented in the manual
06:41:02 <hodapp> I thought the manual documented type-level nats pretty well
06:41:04 <hodapp> perhaps I mis-remembered
06:41:07 <merijn> EvanR: The lack of official docs is because things aren't crystalised
06:41:24 <EvanR> the literal type literals feature is there
06:41:36 <merijn> hodapp: Sure, the explanation is ok, but actually doing something requires a bunch of workarounds
06:41:48 <EvanR> but not really "how you would use type level nats" which is its own university course i imagine
06:41:48 <ertes> bollu: you need a type-level version of (<), which you can implement either as a type class (then you can use instance resolution), or as a GADT (then you can do proofs)
06:42:18 <ertes> bollu: note that x < y on the type level is a *statement* that you can *prove* (or refute)…  it's not a "check"
06:42:21 <bollu> ertes: yes, I realise that
06:42:30 <bollu> ertes: wait, hang on
06:42:39 <bollu> ertes: go back to the "can prove" part
06:43:52 <ertes> bollu: do this:  data (<=) :: Nat -> Nat -> * where Zle :: Z <= y; Sle :: x <= y -> S x <= S y
06:44:01 <ertes> bollu: assuming:  data Nat = Z | S Nat
06:44:18 <ertes> bollu: then a value of type x <= y is a proof that x <= y
06:44:31 <merijn> ertes: Then you're no longer using GHC's Nat
06:44:50 <bollu> ertes: oh, hm, I see
06:44:53 <ertes> yeah, with GHC's Nat you're bound to using the predefined type families
06:45:44 <merijn> Then you're using DataKinds, not actually type level Nat as in GHCs TypeLits
06:46:10 <bollu> how does one write custom constraints?
06:46:19 <bollu> is it vanilla haskell?
06:46:23 <merijn> No
06:46:51 <ertes> i just saw that GHC's Nat comes with a type-level decision procedure
06:47:00 <bollu> so, do I choose to use GHC nats?
06:47:03 <bollu> for my library?
06:47:31 <ertes> good question…  i'm not overly fond of the built-in Nat, but you can take it pretty far
06:47:35 <EvanR> welp, so much for not being mature, its going into a library ;)
06:47:39 <ertes> the main advantage is that it's fast
06:47:57 <ertes> especially going between value-level Integer and type-level Nat
06:54:15 <bollu> ertes: wait, so GHC nats versus hand rolling nats?
06:54:57 <ertes> bollu: try if GHC nats work for you first
06:56:11 <jophish> we use the GHC nats extensively here without too many problems
06:56:24 <jophish> the typelits plugins really help
06:56:57 <kuribas> why Data.Functor, but Control.Applicative?
06:57:09 <tdammers> history
06:57:14 <kuribas> Do library authors flip a coin to decide on Data/Control?
06:57:36 <tsahyt> jophish: typelits plugins?
06:57:37 <tdammers> these days, I believe that's about as accurate a model as it'll get
06:58:10 <Ferdirand> merijn: are you still around ?
06:58:10 <tdammers> I think the distinction was born out of a mindset where data and behavior ("control") were separate worlds
06:58:46 <tdammers> like how in a structured/imperative language, control flow constructs (if, while, etc.) aren't first-class
06:58:59 * hackagebot raw-feldspar 0.2.1 - Resource-Aware Feldspar  https://hackage.haskell.org/package/raw-feldspar-0.2.1 (EmilAxelsson)
06:59:03 <merijn> Ferdirand: Yeah
06:59:11 <tdammers> and some things do in fact conceptually lean more towards the "data structures" or "control flow" sides
06:59:37 <Ferdirand> merijn: i'm done reading the first snippet (had to do other things in the meantime)
06:59:44 <tdammers> e.g., Control.Monad has lots of things that intuitively resemble traditional control flow constructs - when, forM, etc.
06:59:46 <merijn> kuribas: Data/Control is a historical mess due to overenthusiastic application of hierarchical modules when they were implemented
07:00:00 <kuribas> tdammers: it would make more sense to have Data _only_ for CS data structures.
07:00:01 <merijn> kuribas: So yeah, don't put too much stock into it
07:00:07 <Ferdirand> i was wondering about the definition of zip in it, and in particular if the compiler can get any sense of totality out of it
07:00:26 <tdammers> kuribas: you'd think that, but frankly, I don't think making this a fundamental distinction makes much sense in Haskell at all
07:00:33 <merijn> Ferdirand: Sadly, I would've expected it to work without the separate constraint, tbh. But it didn't
07:00:53 <kuribas> tdammers: true...
07:00:55 <tdammers> even things that are traditionally strictly dumb data structures, such as lists or Maybes, can take quasi-control-flow roles in Haskell
07:01:11 <merijn> Ferdirand: So the answer is "not really", although it does at least verify at compile time that both lists are equally long :)
07:01:19 <tdammers> a list, after all, can be thought of as representing a generator
07:01:26 <tdammers> kind of a first-class traversal construct
07:01:30 <Ferdirand> merijn: i tried to follow the steps of the type checker for the two clauses of zip, and it makes sense
07:01:42 <Ferdirand> i also have the impression that these two clauses are total
07:01:47 <tdammers> and Maybe has a monad instance that allows you to write pseudo-imperative code with anonymous failures
07:01:52 <kuribas> tdammers: it would make sense to reserve Control for typeclasses.
07:01:54 <Ferdirand> but i'm not sure if it is true, and if the compiler is able to prove it
07:02:19 <kuribas> tdammers: Monad/Functor/Applicative/etc...
07:02:22 <tdammers> kuribas: IMO it would make sense to just combine the two into one, and get rid of the other entirely
07:02:34 <Ferdirand> it's more a question about compiler design than haskell programming I guess, so it's not really important
07:02:38 <merijn> Ferdirand: The type level steps are total, because you can't write non-terminating functions at the type level in GHC (well, not without IncoherentInstances) :)
07:02:46 <tdammers> but, compatibility...
07:02:49 <kuribas> tdammers: or put them all at toplevel.
07:02:57 <merijn> Ferdirand: Eh, UndecidableInstances, I mean
07:03:03 <tdammers> I'm not so fond of that
07:03:05 <merijn> Ferdirand: IncoherentInstances is something else :)
07:03:16 <kuribas> tdammers: yeah, it's already to late
07:03:25 <kuribas> tdammers: hopefully for haskell 2.0
07:03:39 <EvanR> tdammers: thought of that earlier but ControlData is long and silly ;)
07:03:49 <Ferdirand> merijn: maybe total is not the correct word then
07:04:10 <tdammers> EvanR: how about Base
07:04:16 <Ferdirand> if i were to write a clause zip Nil (Cons a as) = ...
07:04:19 <tdammers> Base.Maybe, Base.List, Base.Monad, ...
07:04:23 <ertes> jophish: i would be interested in how you managed to write an Applicative instance for the typical Vec type
07:04:35 <Ferdirand> i can see how the compiler will hit your error clause in Zippable
07:04:42 <EvanR> ship it
07:04:44 <tdammers> but actually, moving the stuff that is in base isn't the problem; the real problem is all the other libraries out there
07:04:54 <ertes> jophish: instance (Applicative (Vec n)) => Applicative (Vec (1 + n))  -- error
07:05:21 <ertes> the problem is that there is no way to get type refinement with GHC's Nat, as far as i can tell
07:05:35 <tdammers> I'm almost entirely sure there is a non-empty set of Foo for which both Data.Foo and Control.Foo are defined in hackage libraries
07:05:37 <Ferdirand> is ghc able to use that to conclude that no, the definition of zip already covers all sensible cases, and that zip (Cons a b) Nil is not needed as well ?
07:06:16 <ertes> jophish: using the following type: data Vec :: Nat -> * -> * where Cons :: a -> Vec n a -> Vec (1 + n) a; Nil  :: Vec 0 a
07:06:34 <merijn> Ferdirand: Sadly, no. But the Zippable constraint ensures that that case cannot typecheck
07:06:36 <ertes> if there is a way to make this Applicative, i will change my mind about GHC's Nat =)
07:06:49 <merijn> Ferdirand: As that case would always result in Zippable returning an invalid constraint :p
07:07:36 <ertes> more generally so far i found it impossible to use induction on Nat
07:07:48 <ertes> and that's a key feature for pretty much everything i'd use them for
07:08:29 <ertes> my guess is that you can really only use Nat when it comes to communicating an Integer on the type level, which is a very special case
07:08:48 <Ferdirand> merijn: I see
07:09:06 <Ferdirand> then the snippet with Index and Vec is crystal clear, but that might be because I did it in Idris already :)
07:09:37 <Ferdirand> Restrict is a bit like black magic
07:10:22 <merijn> Ferdirand: You should have the tools to understand it after the earlier explanation :)
07:10:23 <Ferdirand> it forces me a bit too hard to think about how ghc implements constraint checking
07:10:41 <merijn> Ferdirand: It's actually pretty unrelated to that :)
07:10:46 <Ferdirand> oh the meaning of the code is crystal clear
07:11:59 <Ferdirand> it's just that so far i've modeled the type checker as a magic box that is as smart as a human when inferring types
07:12:55 <merijn> Ferdirand: The high level thing the compiler does is "try to unify all types, then check if constraints hold"
07:13:31 <Ferdirand> but i'm guessing that probably it starts by unifying all type variables that can be unified, and accumulates constraints and checks them at the end ?
07:13:38 <Forlorn> Ferdirand, nice name.
07:13:40 <merijn> Ferdirand: Yes
07:13:52 <merijn> Ferdirand: Constraints are only checked at the very end
07:19:00 * hackagebot hashmap 1.3.2 - Persistent containers Map and Set based on hashing.  https://hackage.haskell.org/package/hashmap-1.3.2 (ryanglscott)
07:19:41 <danilo2> Guys, I've got a terryfying behavior and I would love to ask you for help. So when I'm importing Control.Monad.Extra from extra-1.4.10 some other modules that use mutable vectors broke (memory is overriden and magic happens). This lib is not even used, only imported. When I use extra-1.5 instead it works. But how ... ?
07:20:33 <danilo2> and no, I dont have any minimal example, I've just got this behavior confirmed across different systems
07:23:23 <bollu> how do I get lambdabot into my channel?
07:24:29 <danilo2> Does anybody haveclue what could even cause such behavior ?
07:24:39 <tdammers> bollu: either build & run your own, or bug whoever runs lambdabot to have it join your channel
07:26:29 <bollu> tdammers: who runs lambdabot?
07:26:41 <bollu> tdammers: hm, actually, how easy is lambdabot to configure?
07:27:29 <tdammers> bollu: I do not know the answer to either question, unfortunately
07:27:29 <lyxia> int-e ^
07:27:35 <sm> is it geekosaur ?
07:28:13 <lyxia> I've heard it's pretty hard.
07:30:43 <ertes> try /invite
07:30:43 <ertes> i think it used to work
07:31:01 <bollu> I did
07:31:04 <bollu> doesn't :(
07:31:38 <Clint> you need to be opped to /invite
07:31:52 <bollu> I am, on my channel
07:31:54 <Clint> oh
07:32:32 <bollu> where is the lambdabot code?
07:32:49 <sm> hackage -> lambdabot -> github
07:34:00 <sm> int-e seems to be the recent committer
07:37:46 <byorgey> danilo2: the fact that it's only imported and not used makes me think of type class instances (just importing a module can bring them into scope). But still I don't see how some extra type class instances could change the semantics of existing code, without trying hard to break type class coherence
07:39:01 * hackagebot console-style 0.0.2.0 - Styled console text output using ANSI escape sequences.  https://hackage.haskell.org/package/console-style-0.0.2.0 (minad)
07:39:03 * hackagebot wl-pprint-console 0.0.1.2 - Wadler/Leijen pretty printer supporting colorful console output.  https://hackage.haskell.org/package/wl-pprint-console-0.0.1.2 (minad)
07:48:52 <muzzle> hi, does anyone know if the connection objects in the postgresql-simple package are thread-safe?
07:58:12 <kuribas> What's the most basic typeclass that reduces to lists?
07:58:17 <kuribas> Traversable?
07:58:31 <ertes> kuribas: Foldable?
07:58:43 <ertes> but Foldable is slightly more generic
07:59:07 <kuribas> more generic is good :)
08:00:17 <ertes> Foldable is the class of free monoids, basically
08:01:10 <kuribas> ah, there is toList :)
08:01:11 <kuribas> :t toList
08:01:13 <lambdabot> error:
08:01:13 <lambdabot>     Ambiguous occurrence ‘toList’
08:01:13 <lambdabot>     It could refer to either ‘F.toList’,
08:01:18 <kuribas> :t F.toList
08:01:20 <lambdabot> Foldable t => t a -> [a]
08:04:02 * hackagebot pandoc-citeproc 0.10.3 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.3 (JohnMacFarlane)
08:09:12 <hackrilege> can anyone help with this error, i cant get round it... http://lpaste.net/348182
08:10:16 <hackrilege> i cant place a (Show a,Show (f a)) contraint on fix...
08:11:23 <m0rphism> hackrilege: your instance declaration seems to be missing constraints
08:11:48 <hackrilege> thats because none work!
08:11:48 <lyxia> hackrilege: instance Show (f (Fix f)) => Show (Fix f)
08:12:24 <m0rphism> hackrilege: I would have guessed that  `instance (Show (f (Fix f))) => Show (Fix f) where`  should work with the UndecidableInstances extension
08:13:10 <m0rphism> I think it should also be derivable with `StandaloneDeriving` in combination with the constraint
08:13:13 <hackrilege> lyxia, then it compains f is used too often and requires undicidablinstances
08:13:47 <m0rphism> hackrilege: Add {-# LANGUAGE UndecidableInstances #-} at the top of your file
08:14:03 * hackagebot OpenGLRaw 3.2.4.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.2.4.0 (SvenPanne)
08:14:15 <hackrilege> thats not an option i want to consider...
08:14:16 <martinium> I wonder why the most commonly used GHC extensions aren't enabled by default
08:14:17 <lyxia> Or you can require Show1
08:14:22 <martinium> like overloaded strings...
08:14:44 <hackrilege> whats Show1?
08:14:56 <lyxia> hackrilege: it's Show for types of kind * -> ù
08:14:58 <lyxia> * -> *
08:15:11 <hackrilege> oh
08:15:22 <m0rphism> hackrilege: Show1 is defined in the prelude-extra's package: https://hackage.haskell.org/package/prelude-extras
08:15:30 <hackrilege> that could work
08:15:32 <lyxia> it's in base
08:16:02 <lyxia> instance Show1 f => Show (Fix f) where showsPrec n (Fix f) = showsPrec1 n f
08:16:04 <m0rphism> lyxia: nice, didn't knew it was moved to base :)
08:16:08 <lyxia> :)
08:16:28 <lyxia> oh it's pretty recent
08:16:37 <lyxia> since 4.9
08:16:38 <hackrilege> i thougt i might me able to say something like "forall a such that Show (f a) ..."
08:17:01 <lyxia> that's what Show1 and similar classes are meant to express
08:17:06 <m0rphism> hackrilege: That should be the same as "Show1 f"
08:17:45 <hackrilege> cant i do it in one line with rankn types or something?
08:20:15 <hackrilege> i guess its "for all f of a such that Show (f a) implies Show a"
08:22:12 <lyxia> you can't do much with that implication though
08:22:13 <ski> higher-rank instances would be nice
08:22:15 <m0rphism> hackrilege: I think the problem would be to express the "implies" in the constraints, which is worked around with the Show1 class.
08:22:30 <ski> iow `instance (forall a. Show a => Show (f a)) => Show (Fix f)'
08:23:13 <ski> `Show1 f' is (more or less, modulo some new details) meant to represent this `forall a. Show a => Show (f a)' constraint
08:23:56 <ski> hackrilege : unrelated, your `Show' instance is incorrect, since it doesn't output something to account for the `Fix' data constructor
08:24:03 * hackagebot sqlite-simple 0.4.12.0 - Mid-Level SQLite client library  https://hackage.haskell.org/package/sqlite-simple-0.4.12.0 (JanneHellsten)
08:24:08 <lyxia> The constraints package has some stuff for that too
08:24:18 <ski> (iow, you can't evaluate the generated string representation, and get back the same value that you passed in)
08:25:18 <ertes> is there a way to tell cabal/Setup repl to unhide all packages used by any component?  it seems like haskell-mode doesn't tell repl which component the loaded file is from, so i get hidden package errors
08:25:32 <ski> lyxia's constraint suggestion works, but might be considered (at least in similar cases) to leak too much implementation details about the data type in question
08:25:54 <ski> (the definition of `Fix' is presumably intended to be public, but other data types could prefer to be abstract)
08:26:14 <ski> (generally, that's one use of higher-rank stuff : hide implementation details)
08:26:42 <lyxia> how does it leak?
08:27:27 <ski> it leaks that `Fix f' uses `f' in the particular way `f (Fix f)' in its body
08:27:34 <ski> rather than using `f' in some other way
08:27:48 <ertes> i have to go, i'll ask again later
08:28:27 <ski> `instance (forall a. Show a => Show (f a)) => Show (Fix f)' (nor `instance Show1 f => Show (Fix f)') wouldn't leak that, instead insisting that `f a' be in `Show' for *any* `a' in `Show', rather than just in the case `a = Fix f'
08:28:54 <hackrilege> it complains about requiring a monotype....
08:29:06 <ski> hackrilege, paste ?
08:29:07 <hackrilege> not used to RankNType errors....
08:29:13 <lyxia> Ah yes you were talking about that "constraint". My mind had moved to Kmett's "constraint" package to do something equivalent to Show1.
08:29:58 <ski> lyxia : any particular part of that package i should be looking at ?
08:30:10 <hackrilege> one sec
08:31:07 <lyxia> ski: The closest I've found is Lifting p f, which just seems to be a generalization of the Class1 pattern, but you still have to implement it for every f.
08:31:14 <kuribas> If I have an instance "(Foldable t, MyClass a e) => MyClass (t a) e", how can I specify that a determines e?
08:31:40 <glguy> kuribas: Either with a functional dependency:  | a -> e
08:31:54 <kuribas> glguy: I have that in the class declaration
08:31:54 <glguy> or by not using a multiparameter type class and uses a type family for the e type
08:31:58 <ski> FDs attach to `class' declarations, not to `instance' declaration, afaik
08:32:18 <hackrilege> http://lpaste.net/348196
08:32:29 <kuribas> glguy: So I cannot use fundeps?
08:32:40 <glguy> kuribas: Instances of the form Class (t a) are generally illadvised
08:33:12 <kuribas> glguy: here is my code: http://lpaste.net/348197
08:33:15 <ski> kuribas : if you already have `class ... => MyClass a e | a -> e', then shouldn't it realize that because of the `MyClass a e' presupposition in your `instance' declaration, `a' already determines `e' ?
08:33:26 <ski> (but also what glguy said)
08:33:53 <glguy> You'll need an extra extension enabled for   the MyClass a e => constraint to satisfy the fundep requirements for the  (t a) instance
08:34:04 * hackagebot errors 2.1.3 - Simplified error-handling  https://hackage.haskell.org/package/errors-2.1.3 (GabrielGonzalez)
08:34:29 <kuribas> glguy: which one?
08:34:37 <glguy> GHC will tell you when it rejects it
08:34:57 <kuribas> ah, so UndecidableInstances...
08:35:41 <kuribas> okay, thanks
08:37:11 <glguy> kuribas: incidentally, it's "Unifiable"
08:37:31 <kuribas> glguy: thanks, I'll change it
08:37:59 <hackrilege> what is this error all about? http://lpaste.net/348196
08:38:48 <glguy> hackrilege: You can't put the "forall a" in your instance context
08:39:03 <glguy>  A constraint must be a monotype
08:39:19 <hackrilege> >:|
08:39:34 <hackrilege> darn
08:40:24 <lyxia> Data.Constraint.Forall has a nice/ugly hack to get "forall a. Show (f a)" mostly for free, without an extra Show1. Maybe it can be adapted to write "forall a. Show a => Show (f a)".
08:41:22 <hackrilege> i really struggle to extract the essence of those packages
08:43:26 <hackrilege> lyxia, can you elaborate?
08:47:46 <lpsmith> muzzle, they should be, yes
08:48:16 <lpsmith> muzzle, though keep in mind that the transaction and fold operators are not thread safe in and of themselves.
08:48:47 <hackrilege> i get this error using Show1 http://lpaste.net/348207
08:49:45 <glguy> hackrilege: You'll have to use the class methods of Show1 in addition to using a Show1 constraint
08:49:59 <glguy> show comes from Show
08:52:12 <hackrilege> you mean ShowsPerc1? i dontbknow what the int is for....
08:52:18 <muzzle> lpsmith thank you
08:53:14 <glguy> hackrilege: You can read about show the Show class works at http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:Show
08:53:30 <glguy> hackrilege: Show1 is the same except for the kind of types it works for
08:53:42 <kuribas> I'm getting an error, "conflicting family instance declarations:" http://lpaste.net/348210
08:54:14 <glguy> kuribas: Yeah, the (t a) instance continues to be illadvised
08:54:28 <kuribas> glguy: How else should I do it?
08:54:29 <lyxia> hackrilege: The trick is to somehow introduce something that behaves like a rigid type variable (what they call "skolem") "a", then if you have an "instance Show (F a)" with no additional constraint on "a" you can capture the instance in a GADT at the toplevel. If that typechecks, that means the Show instance for (F a) actually does not depend on a, so you can do an unsafeCoerce to change "a" to anything you
08:54:32 <lyxia> like.
08:54:35 <hackrilege> but what is the Int? presedence?? do i just set it to 0?
08:54:54 <kuribas> glguy: I want any Foldable to be unifiable
08:55:03 <glguy> kuribas: That's not really how instances work
08:55:27 <ski> hackrilege : yes, it would be very nice imho if we could have higher-rank instances, as in your paste .. but alas, we can't .. yet, at least
08:55:30 <glguy> kuribas: You can provide a default implementation of your class method in terms of Foldable that one could use to implement an instance for a particular type that had a Foldable instance
08:56:01 <muzzle> can i use the new ghc release candidate with stackage?
08:56:02 <kuribas> glguy: hmm, okay
08:56:18 <ski> hackrilege : generally, when instancing `Show', you should define `showsPrec' (rather than `shows', or worse, `show'). the `Int' is for the current precedence level
08:57:51 <kuribas> glguy: And when I want to support a type that isn't foldable?  Like (a,a,a)?
08:58:04 <glguy> Then you write that instance
08:58:09 <ski> hackrilege : so, you should have `instance Show1 f => Show (Fix f) where showsPrec p (Fix f) = showParen (p > 10) $ showString "Fix " . showsPrec1 11 f'
08:58:18 <glguy> but you don't use the implementation for foldable types
08:58:47 <glguy> kuribas: Here's an example of what I'm talking about http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Traversable.html#v:fmapDefault
08:58:50 <hackrilege> thanks!
08:59:51 <glguy> kuribas: It's not appropriate to have: instance Traversable t => Functor t, but you can provide the fmapDefault implementation once that any particular Functor instance could use
09:00:03 <ski> hackrilege : if we could have used a rank-2 instance instead of having to adapt to using `Show1', we'd have written `instance (forall a. Show a => Show (f a)) => Show (Fix f) where showsPrec p (Fix f) = showParen (p > 10) $ showString "Fix " . showsPrec1 11 f', the only difference being that we use `showsPrec' from `Show' instead of `showsPrec1' belonging to `Show1'
09:00:44 <hackrilege> yay it works
09:01:17 <ski> hackrilege : anyway, the code i wrote is the basic pattern that you'll get when using `deriving Show'. `showParen' will wrap the string in brackets in case the boolean is true, iow in case the current precedence level `p' is greater than the precedence level of the thing we're showing (which is an *application*, which has precedence level `10')
09:01:17 <hackrilege> do you mean we cant do it the latter way?
09:01:55 <hackrilege> (rank-2)
09:02:13 <kuribas> glguy: Does it mean I have to separately make an instance for each instance of Foldable?
09:02:17 <ski> hackrilege : `showString' just outputs a given string, `showsPrec 11' is used (`11' is the first `Int' greater than `10') because application is left-associative, so we need to raise the precedence level for the argument to the application, namely `f'
09:02:21 <glguy> kuribas: Yeah
09:03:09 <ski> hackrilege : we can't do the rank-2 instance way, because noone has implemented it in GHC. .. however, if it was implemented (and no problem with it was discovered), then (i think) i'd prefer using that to the `Show1' workaround
09:03:40 <hackrilege> its a shame i have to use prelude-extras, it will confuse my prof and any undergrads
09:04:01 <ski> hackrilege : well, you could just write `Show1' yourself in your code ..
09:04:27 <hackrilege> ill get my clipboard out
09:05:09 <ski> hackrilege : the alternative is what lyxia suggested, `instance Show (f (Fix f)) => Show (Fix f) where showsPrec p (Fix f) = showParen (p > 10) $ showString "Fix " . showsPrec 11 f', which requires a (benign) use of `UndecidableInstances'
09:05:25 <lyxia> hackrilege: Show1 is in base as of GHC 8.
09:05:31 <int-e> Axman6: @echo is obscure, but should be harmless enough (with the usual provision that like many lambdabot commands it can be needlessly noisy if abused)
09:05:53 <hackrilege> ok at least i can show my datatype now, and am aware of the problem :\
09:06:00 * ski thinks lyxia's suggestion is ok in this situation as well, just wanted to point out earlier that, generally speaking, it might not be ideal
09:06:05 <hackrilege> i had to install prelude-extras
09:06:25 <hackrilege> maybe its because i used the minimal version of the haskell platform
09:07:28 <hackrilege> so its ok to use undecidable instances in some cases? i thought it was strictly verbotern
09:07:31 <lyxia> hackrilege: it's in Data.Functor.Classes
09:08:08 <hackrilege> aha!
09:08:20 <glguy> The Data.Functor.Classes version of Show1 in base isn't the same as the one in prelude-extras
09:08:25 <lyxia> oh?
09:08:28 <glguy> It's a bit harder to use, solves the same problem though
09:09:09 <hackrilege> my example still compiles
09:09:25 <glguy> It's writing instances of it that's different
09:09:32 <lyxia> right
09:10:25 <guillaum2> can someone help me to fix a dependant type matrix operation (http://lpaste.net/348219). (Error at the end of the code sample)
09:11:55 <kuribas> glguy: what's so bad about (t f)?
09:12:07 <ski> ah, right, it was <http://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/Data-Functor-Classes.html> i was thinking of, for the a bit different (more expressive) formulation of `Show1'
09:12:53 <glguy> kuribas: It overlaps with all types of the form   t f
09:13:08 <glguy> Like your "Expr a"
09:13:09 <kuribas> glguy: where t is Foldable ...
09:13:11 <glguy> nope
09:13:21 <glguy> all types of the form   t f
09:13:41 <kuribas> glguy: then what does the "Foldable t =>" mean?
09:13:59 <glguy> It means that all types of the form t f will require a Foldable t constraint to use their instance
09:14:07 <kuribas> oh...
09:16:42 <kuribas> glguy: So basicly I need a new operator for foldable structure.
09:17:56 <glguy> If you want it to be an operator. like the fmapDefault example I showed earlier, you could have a unifyFoldable definition
09:18:03 <glguy> and then you could use that to implement various instances
09:19:23 <kuribas> Why doesn't haskell select the instance based on the constraints?
09:19:57 <danilo2> byorgey: sorry I was offline for a moment
09:19:59 <glguy> kuribas: Haskell doesn't even allow you to write an instance for a type like "t f"
09:20:00 <ski> would require backtracking, i think
09:20:07 <ski> what if more than one instance match ?
09:20:08 <tkdlc> how can I pass a tuple of 2 values to function as two different arguments?
09:20:35 <ski> tkdlc : use `uncurry'
09:20:36 <danilo2> byorgey: regarding the problem - importing extra-1.4.10 breaks mutable vecrtors. it is strange. We were only importing Control.Monad.Extra, which (looking at sources) doesnt bring any new instances into the scope
09:20:42 <glguy> kuribas: Haskell instances are supposed to be on a type constructor followed by zero or more distinct type variables
09:20:46 <ski> > uncurry div (16,7)
09:20:48 <lambdabot>  2
09:20:55 <ski> > uncurry divMod (16,7)
09:20:58 <lambdabot>  (2,2)
09:21:16 <kuribas> glguy: hm ok
09:21:18 <niez> hi, I want to serialize System.Statgrab.Host to json, https://hackage.haskell.org/package/statgrab-0.1.3/docs/src/System-Statgrab-Internal.html#Host, I want to derive instance using generics, so I've added just 'instance ToJSON Host', but I get 'No instance for (ToJSON Data.ByteString.Internal.ByteString)', is it possible to serialize data with ByteString's ?
09:21:25 <glguy> and solving them involves considering that outermost type constructor alone
09:23:04 <ertes> is there a way to tell cabal/Setup repl to unhide all packages used by any component?  it seems like haskell-mode doesn't tell repl which component the loaded file is from, so i get hidden package errors
09:27:29 <tkdlc> ski: tnx
09:27:41 <hackrilege> ok so it works, does this seem like a reasonable implementation of type level Nats http://lpaste.net/348222
09:28:35 <glguy> No, that doesn't appear to be an implementation of type-level Nats, but value-level Nats
09:29:58 <hackrilege> damn!!
09:30:13 <hackrilege> but i can patern match on them....
09:30:27 <glguy> Yeah, that's how you know they're values
09:30:32 <hackrilege> oh
09:30:53 <hackrilege> maybe i never needed type level nats
09:31:04 <hackrilege> how would i know?
09:31:15 <glguy> You'd use them in *types*
09:31:44 <glguy> something like:  myVectorOfTenInts :: Vector 10 Int
09:31:57 <Xnuk> Is there any Cabal's VersionRange parser?
09:32:02 <hackrilege> eg a int parametrised vector?
09:32:11 <glguy> or a nat parameterized one
09:32:14 <dcoutts> Xnuk: sure, in the Cabal lib
09:32:34 <glguy> dcoutts: That sounds like cheating
09:33:12 <hackrilege> is there a package for such types glguy?
09:33:19 <Xnuk> dcoutts: Where can I find it?
09:33:42 <dcoutts> Xnuk: the Text instance for VersionRange, so look at the Distribution.Text package
09:33:46 <dcoutts> erm module
09:33:54 <glguy> http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html
09:34:01 <hackrilege> thanks
09:34:07 * hackagebot bytestring-handle 0.1.0.5 - ByteString-backed Handles  https://hackage.haskell.org/package/bytestring-handle-0.1.0.5 (GaneshSittampalam)
09:34:30 <EvanR> can someone tell me why the title of section 7.4 in this PDF makes any sense? (if at all) http://blog.higher-order.com/assets/trampolines.pdf
09:34:37 <EvanR> "The expression problem"
09:34:57 <Xnuk> dcoutts: Thank you
09:35:02 <hackrilege> i need to specify the depth of nesting of Free, i guess i can addapt the TypeList implementation, but is there a package for that also?
09:37:39 <EvanR> its a short paragraph with only like 2 sentences
09:37:55 <hackrilege> typelit*
09:39:07 * hackagebot cspretty 1.0 - AST and pretty printer for CSPm  https://hackage.haskell.org/package/cspretty-1.0 (ccasin)
09:39:38 <cocreature> EvanR: the mentioned „data types a la carte” paper is about solving the expression problem iirc
09:42:22 <hackrilege> thanks again! i go now
09:46:23 <joe9> What is the proper way to read from a pipe (unix) from haskell? I use Data.ByteString.hGetSome binaryModeHandle 8192 - and I notice that the haskell process is not actually blocking until data is available. But, making multiple calls to read the pipe. That makes me suspect that there is some kind of timeout used by hGetSome while waiting for data.
09:47:08 <joe9> I want something that just blocks until there is data and not timeout and make multiple reads.
09:49:14 <joe9> System.IO.hGetChar and hGetLine read the character and decipher it.
09:49:46 <joe9> I am looking for something that just passes the data read in that call as-is without any buffering.
09:51:01 <wz1000> Is there any library that provides a single DSL to simultaneously specify serializers and parsers, such that parse . serialize = id and serialize . parse = id are enforced?
09:52:42 <wz1000> The second constraint can be relaxed a bit to something like serialize . parse = prettyPrint
09:55:02 <zipper> Which is the prefeered way of writing this partially applied function `(1 ==)` `(== 1)`  or `((==) 1)` ?
09:55:26 <zipper> the second is cool and lispy/lambday
09:55:28 <kadoban> probably the middle one
09:55:38 <zipper> kadoban: Thanks
09:56:13 <zipper> kadoban: Ok and why are we not wrapping this infix function in braces yet it's being used in a prefix manner?
09:56:35 <kadoban> (== 1) is a section, it's special syntax
09:56:40 <jedai42> zipper: this is an operator section
09:56:50 <joe9> wz1000: aeson?
09:56:54 <jedai42> zipper: you can do the same with other operators (+5)
09:57:15 <AndreasK> I think it works with every infix expression
09:57:17 <jedai42> zipper: or (2:)
09:57:26 <jedai42> AndreasK: It does
09:58:05 <jedai> zipper: (a +) == (+) a
09:58:09 <Myrl-saki> zipper: The last one is death-tier writing..
09:58:19 <jedai> zipper: (+ a) == flip (+) a
09:59:09 <jedai> zipper: it works with any operator (even with (`div`5))
09:59:13 <zipper> death-tier? section?
09:59:37 <zipper> Looks like we can write haskell as lisp :D
09:59:42 <zipper> So nice
09:59:45 <zipper> *a lisp
10:00:10 <jedai> zipper: operator section is just the name of this particular syntax sugar and Myrl-saki probably meant you really shouldn't use ((==) 1) (too many parens)
10:00:12 <wz1000> joe9: But in aeson you have to provide ToJSON and FromJSON instances seperately, and its not at all enforced that decode . encode = id
10:01:32 <ertes> wz1000: you mean something like the boomerang library?
10:01:42 <ertes> @package boomerang
10:01:42 <lambdabot> http://hackage.haskell.org/package/boomerang
10:02:51 <ertes> wz1000: it composes parsers and printers from a single specification, but still doesn't enforce statically that the individual components are actually inverses of each other (that's very difficult in haskell)
10:02:52 <wz1000> ertes: Ah thanks, sounds exactly like what I'm looking for
10:03:27 <ertes> wz1000: caveat: the boomerang library is mostly used in the context of URL paths, so it's a bit biased in that direction
10:04:43 <zipper> Thanks
10:04:53 <wz1000> ertes: I wasn't looking for actual mathematical verification. But I wonder why libraries like cereal and aeson don't use a similar approach.
10:05:50 <ertes> wz1000: i think the abstraction only allows for a rather narrow subset of all grammars, but i couldn't tell you which one
10:06:33 <jedai> There's also the fact that you often want a more liberal parser than your serializer (if there are other source for your data)
10:06:57 <mmalone> hey does anyone know if there's a clean way to resolve ambiguous type variable problems without resorting to type annotations when you have OverloadedStrings enabled, as in this example: https://gist.github.com/mmalone/059d90a38002050852dcbc9398b4ac93
10:07:06 <ertes> wz1000: although it does have both Applicative and Category, so it's probably not even that limited
10:07:22 <ertes> wz1000: wait, i'm wrong
10:07:26 <ertes> it's indeed Category only
10:07:28 <HelgeS> Many code examples I look at use the operator <$>. My GHCi, version 7.6.3 doesn't have it unless I load something. What do I need to load, and how can I find out?
10:07:45 <EvanR> its there is more recent versions of GHC
10:08:08 <EvanR> but you can get it by importing Data.Functor
10:08:09 <ertes> wz1000: so indeed composition is very limited (and understandably so)
10:08:10 <AndreasK> try Data.Functor
10:08:32 <ertes> HelgeS: what you need is a more recent GHC =)
10:08:38 <EvanR> 7.6.3 is kind of ancient
10:09:20 <HelgeS> Thanks EvanR OK. I'm on Mac, and I don't remember how I got ghci into my computer.
10:09:29 <EvanR> i have the same issue
10:09:57 <EvanR> the time scales on which i upgrade GHC are longer than the timescale of GHC on OSX rearranging its preferred installation details
10:09:58 <HelgeS> If I do :m Data.Functor, then I have <$>
10:10:24 <jedai> HelgeS: ghc 7.6.3 is more than three year old
10:10:47 <AndreasK> HelgeS: Not sure if your ghc version supports it but new ones also allow regular import syntax in ghci
10:11:01 <joe9> EvanR, ertes, do you know if there is a proper blocking read function for haskell. Even hWaitForInput seems to be doing multiple reads.
10:11:06 <jedai> HelgeS: 7.6.1 the first in the 7.6 version is more than 4 year old
10:11:26 <EvanR> joe9: are you at least using Data.ByteString for I/O ?
10:11:38 <joe9> EvanR: yes, that is what I am trying.
10:11:49 <joe9> EvanR: I thought that hGetSome would be blokcing
10:11:57 <EvanR> hGetSome
10:12:02 <joe9> but it is not. It is doing multiple read calls
10:12:07 <EvanR> eh?
10:12:09 <HelgeS> I'm gonna upgrade my ghci.
10:12:19 <EvanR> im not sure i understand this venn diagram, blocking vs number of read calls
10:12:24 <EvanR> do you mean its doing read in an infinite loop?
10:12:32 <ertes> HelgeS: … which wouldn't be a problem, if we were keener on maintaining compatibility, but there have been quite a few drastic changes since 7.6, so you might find that a lot of code won't compile for you
10:12:53 <jedai> joe9: did you try hGet ?
10:13:12 <EvanR> ah, ^
10:13:20 <EvanR> hGetSome is specifically non blocking
10:13:38 <glguy> It's still blocking
10:13:59 <ertes> joe9: what's "proper"?
10:14:01 <EvanR> ah
10:14:04 <joe9> EvanR: I implemented a 9pfs file server. When there is no data to be read currently, it just blocks the read syscall. my client is in haskell. I am trying to figure out how to work with that from haskell. When I do a "cat <file>", it works perfectly. one read syscall waits until it reads data.
10:14:23 <joe9> EvanR: ertes, jedai, I thought that hGetSome is blocking.
10:14:28 <joe9> that is what the docs say.
10:14:37 <ertes> joe9: what behaviour do you want?
10:14:38 <EvanR> but it doesnt act like read
10:14:57 <EvanR> hGet seems to look like read
10:14:59 <jedai> joe9:  hGetSome only blocks if there is no data available that does not seems blocking to me
10:15:10 <joe9> but, in practice, I see that it is doing multiple read syscalls. I suspcet that there is some kind of timeout when making the read syscall.
10:15:34 <EvanR> the I/O manager is probably multiplexing everything on one select
10:15:35 <joe9> ertes, do a read , wait until the response is received
10:15:39 <jedai> joe9: " shorter ByteString may be returned if there are not enough bytes immediately available to satisfy the whole request"
10:15:41 <joe9> ertes, ^^ is what I want.
10:15:43 <jedai> simukis__:
10:15:57 <EvanR> er... nvm
10:16:04 <joe9> ertes, from a haskell perspective, hGetSome is blocking as it does not execute the next line.
10:16:05 <simukis__> jedai: ?
10:16:10 <mmalone> bump ;< -- anyone have any idea how to avoid ambiguous type variable errors when using OverloadedStrings?
10:16:10 <jedai> oops joe9: hGetSome is not blocking
10:16:11 <ertes> joe9: what is "the response"?  is it a fixed-length ByteString?
10:16:29 <jedai> simukis: sorry a misclick
10:16:31 <joe9> ertes, but, from a syscall's perspective, it is not. it seems to be using read + timeout
10:16:42 <simukis> jedai: okay :(
10:16:44 <EvanR> mmalone: use type signatures
10:16:55 <joe9> ertes, no, the response is a variable length bytestring.
10:16:56 <ertes> joe9: haskell's I/O functions generally don't map exactly to syscalls, because they have extra semantics like buffering, but if you're just specific about the behaviour you want, we can tell you how to get it
10:17:05 <mmalone> EvanR: thanks, googling that.
10:17:12 <ertes> joe9: ok, how far do you want to read?
10:17:19 <EvanR> ertes: well, that shouldnt apply to ByteString
10:17:21 <ertes> joe9: until a certain delimiter?
10:17:27 <joe9> ertes, yes, that is what I need help with. how to get the specific behaviour to haskell.
10:17:39 <jedai> joe9: more precisely it isn't blocking to wait for all the data you asked to be there, it only blocks if there's no data, if not he goes and read the data there is, even if it is not enough
10:18:08 <hexagoxel> mmalone: {-# LANGUAGE ExtendedDefaultRules, OverloadedStrings #-}; default (String)
10:18:13 <joe9> ertes: the 9p2000 protocol specifies a response to be "size + bytes of that size"
10:18:24 <mmalone> hexagoxel: o nice, that looks more like what I'm looking for!
10:18:31 <joe9> ertes, so when responding to the read syscall, I send a response with the above message.
10:18:36 <jedai> joe9: Well I guess if your problem is the syscall side, hGet may not work
10:18:44 <wespiser> does anyone know of a haskell project that renders javascript on websites into html?
10:18:47 <ertes> joe9: if you're expecting to read multiple of those in sequence, you should use a stream abstraction
10:18:54 <wespiser> (for web scraping)
10:18:59 <joe9> ertes, what happens with cat, is that it sends a read syscall and waits until the read is serviced. -- Does this make sense?
10:19:04 <ertes> joe9: unless you want to read byte for byte, which is probably a bad idea
10:19:06 <jedai> joe9: But did you try hGet ?
10:19:44 <joe9> jedai: let me try with hGet. I tried hWaitForInput, hGetSome
10:19:50 <ertes> joe9: my mental picture of your application is:  1. do request, 2. receive response (but nothing extra), 3. repeat
10:19:54 <ertes> joe9: is that accurate?
10:20:10 <joe9> ertes, yes.
10:20:22 <joe9> ertes, that is accurate.
10:20:23 <EvanR> really hGetSome makes more sense to me, since you dont know how much you need until you buffer enough and see a delimeter
10:20:23 <ertes> joe9: then i recommend a stream abstraction, because you have the leftover problem
10:20:28 <EvanR> delimiter
10:20:38 <ertes> joe9: like pipes
10:20:42 <ertes> @package pipes
10:20:42 <lambdabot> http://hackage.haskell.org/package/pipes
10:20:44 <ertes> @package pipes-bytestring
10:20:44 <lambdabot> http://hackage.haskell.org/package/pipes-bytestring
10:20:46 <ertes> @package pipes-network
10:20:46 <lambdabot> http://hackage.haskell.org/package/pipes-network
10:21:02 <jedai> EvanR: but wouldn't the size be in a fixed amount of bytes ?
10:21:09 <maerwald> "hGetSome", lol
10:21:14 <EvanR> jedai: in general?
10:21:27 <joe9> ertes, I am talking about something more low-level than pipes . something that can map to the syscall level. as pipes, (I assume) would just be using hGet or some such call.
10:21:43 <jedai> EvanR: in most binary protocols
10:21:54 <BaneAliens> I’m trying to make sense of this function signature “f :: Int -> [Int] -> [Int]”  Does this mean f takes an integer and array and returns an array?
10:22:09 <EvanR> theres hGetBuf :: Handle -> Ptr a -> Int -> IO Int
10:22:35 <EvanR> enjoy!
10:22:51 <ertes> joe9: that's correct…  the way pipes works is that it just reads in fixed-size chunks (but doesn't mind receiving less), and it buffers until you ask…  so you can say: "ok, i need another response", and it will give you the next response and keep the leftover buffered until you ask again
10:23:41 <jedai> EvanR: hGet is directly implemented in term of (one) hGetBuf so it won't help (if hGet doesn't work, joe9 doesn't seem to have tried it)
10:23:48 <joe9> jedai: no, Data.ByteString.hGet is not doing a "read" only.
10:24:07 <ertes> joe9: that's the haskell way of solving the leftover problem without sacrificing performance
10:25:04 <ertes> (or at least *one* haskell way)
10:25:09 <joe9> ertes, what bytestring library does "pipes" use?
10:25:11 <EvanR> joe9: i think ghc does i/o multiplexing to not block when not using -threaded
10:25:42 <ertes> joe9: none…  it isn't specific to any chunk type, but there is pipes-bytestring, which uses the bytestring library
10:25:47 <joe9> EvanR, this is from the cabal file:   ghc-options:         -Wall -threaded -rtsopts -with-rtsopts=-N
10:25:48 <jedai> joe9: Given hoiw GHC io manager works I fear you may not have much luck with this
10:26:12 <EvanR> though this still doesnt make too much sense to me, i want to see the log of reads
10:26:12 <ertes> joe9: hint: you don't need -rtsopts for -N (and generally you shouldn't use -rtsopts)
10:27:01 <EvanR> joe9: i dont think its different for -threaded, Handle stuff is still managed together
10:27:14 <EvanR> but that doesnt explain reads, only selects
10:27:54 <jedai> joe9: though anyway, looking at the hGetBuf code, it use several read call anyway
10:28:22 <joe9> EvanR: http://codepad.org/dwg9zUWW output of cat command, server response: http://codepad.org/ctzWuOuN . server response when using Data.ByteString.hGet: http://codepad.org/Am7ZSbAS
10:30:11 <joe9> or, maybe, there are multiple read syscalls with different offset's.
10:30:33 <EvanR> what is this
10:31:19 <EvanR> i dont get how this is implying multiple read calls per hGet
10:31:36 <ertes> joe9: why do you even fixate so much on syscalls?  is there a specific reason why you need syscall-level control?  it's just a network protocol, isn't it?
10:32:03 <EvanR> ertes: the server log indicates that the number of read calls is somehow visible in the response behavior
10:32:13 <EvanR> but i dont get why
10:32:26 <EvanR> and if so, thats just bad
10:32:59 <ertes> this doesn't seem right…  how would a remote server even see individual read calls?
10:33:01 <EvanR> a place where number of reads would matter is when using file system notifications
10:34:19 <EvanR> joe9: are you basing all this on a trace of syscalls somehow?
10:35:32 <joe9> EvanR: good point, I should use strace to see the actual syscalls made.
10:36:37 <joe9> ertes: 9pfs is similar to fuse. you implement the client in user space
10:37:01 <joe9> ertes: and the client responds to the file read,write,open, etc. syscalls.
10:37:22 <buttbutter> I'm working on some code that labels data. So it could be data Label = Dog | Cat | Snake or something. But the data that I want to work on may change. So, maybe later I'll want data Label = Mouse | Bird | Fish | Fly. Is there an elegant way to encorporate this or should I just manually edit the Label type each time?
10:37:26 <ertes> joe9: sure, but what kind of protocol is that?  isn't it just a network protocol?
10:37:27 <nitrix> This is amazing. I couldn't compile an old project which needed GHC 7 and stack is unable to compile GHC 7 on this machine because of wrong fPIC flags... then I built it with the stack --docker build feature and it worked :D
10:37:45 <ertes> joe9: in other words: wouldn't you just write to and read from a socket on some level?
10:37:48 <nitrix> I love stack & docker! Yay for reproducible build environments :]
10:38:17 <EvanR> nitrix: impressive
10:38:26 <ertes> buttbutter: it depends on how you use that type
10:39:09 <joe9> ertes: http://man2.aiju.de/5/0intro . yes. it is just socket read and write for the server
10:39:27 <kuribas> Are implicit callstacks still supported?
10:39:28 <EvanR> joe9: so im not sure what youre basing your problem's existence on?
10:39:28 <joe9> ertes: but, the socket read and writes go through the kernel
10:39:55 <joe9> ertes http://man2.aiju.de/5/0intro
10:40:05 <joe9> ertes, oops, sorry duplicate paste
10:40:37 <ertes> nitrix: nix-build --argstr compiler ghc704
10:40:40 <ertes> nitrix: no docker needed =)
10:41:09 <ertes> and replace "ghc704" by "ghcjs" for some extra fun =P
10:41:12 <jedai> kuribas: they better "still" be since they're so very new ! ?
10:41:48 <kuribas> jedai: there's not much information in https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Stack.html
10:42:13 <ertes> nitrix: bonus: most of the stuff is in the build cache, so you probably don't even have to build GHC or dependencies =)
10:42:33 <jedai> kuribas: What do you want to do with callstack ?
10:42:54 <kuribas> jedai: generate errors for my DSL
10:43:20 <kuribas> jedai: with correct source locations etc.
10:44:17 <kuribas> I guess "(?loc :: CallStack) => a " isn't supported anymore?
10:45:03 <jedai> kuribas: I think it still is but it's not recommended since the implementation could change so now you should rather use the HasCallStack constrain
10:45:32 <kuribas> jedai: alright
10:47:26 <ertes> joe9: yeah, looks like i'd use pipes for that
10:47:26 <wz1000> Is product :: f a -> f b -> f (a,b) as powerful as (<*>) :: f (a -> b) -> f a -> f b?
10:48:08 <ertes> wz1000: exercise: implement (<*>) in terms of product
10:48:24 <ertes> wz1000: (keep in mind that 'f' is a functor)
10:49:18 <joe9> jedai: I think your observations are correct. I think there is something in how the GHC IO Manager works that has a timeout or some such functionality to cancel a pending read.
10:50:18 <EvanR> joe9: do you have evidence of this?
10:51:17 <jedai> joe9: After looking into the entrails of the beast, I don't think it has so much to do with the IO manager but more with the fact that IO are buffered in GHC by default and hGetBugf is indeed reading several time from a buffer that is probably filled automatically without your control (and thus doesn't wait for your number of bytes to be available at all)
10:51:19 <joe9> EvanR: yes, I am typing up some notes on this to help. Thanks for taking an interest on this. I will post it in a few minutes.
10:51:23 <EvanR> that mechanism specifically doesnt make much sense to me, reads cant be cancelled by user code
10:51:41 <wz1000> ertes: Its just \a b -> fmap (uncurry id) $ product a b
10:51:54 <ertes> wz1000: does that answer your question?
10:52:12 <wz1000> ertes: But I'm reading a paper where they say they can define product but not (<*>) for a given type
10:52:27 <wz1000> ertes: http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf
10:53:16 <wz1000> ertes: Look at section 3.2
10:54:04 <ertes> wz1000: note my hint in parentheses
10:54:21 <wz1000> ertes: Ah, got it
10:54:44 <ertes> wz1000: a haskell Functor is an endofunctor on Hask, but they are using a different notion of functors, which is incompatible with Functor (and thus Applicative)
10:55:08 <EvanR> i want different notions of Functor, Category, etc
10:55:17 <EvanR> for christmas
10:55:22 <kuribas> I have "newtype MFAction e r a = MFAction (ReaderT r (StateT (MFState e) (Either String)) a)", how do I create an error?
10:55:28 <ertes> EvanR: haskmas!
10:55:43 <kuribas> Or do I have the Either in the wrong place?
10:56:00 <joe9> EvanR: jedai, ertes, https://gist.github.com/073d42375e12acf3a8716a700055809c is the communication from the haskell client when using Data.ByteString.hGet.
10:56:00 <geekosaur> joe9, jedai: sockets are unbuffered by default. on stream sockets, multiple reads may be performed (in part to allow other stuff to run); if your protocol assumes one write == one read, it's not just the I/O manager that will break it but every router on the path and even the OS on both sides,
10:56:07 <geekosaur> if it's a datagram socket, it should be one read
10:56:17 <EvanR> kuribas: maybe, lift (Left "fffffuuuuuuuuuuu")
10:56:51 <ertes> i didn't even consider datagram protocols
10:57:45 <[exa]> Hi everyone! Anyone knowledgeable about how typechecking of haskell's typeclasses' instance members works?
10:57:57 <EvanR> if its a datagram socket with a datagram small enough?
10:58:04 <grazie>  1/5 - "Hi everyone, I'm back with a question I started to ask yesterday but better prepared"
10:58:07 <ertes> kuribas: the MonadError class (from mtl) should help you
10:58:12 <EvanR> joe9: i still dont understand where these print outs are coming from
10:58:23 <EvanR> and how it knows how many syscalls are happening, or implies
10:58:31 <joe9> EvanR: ertes, jedai: this is when I do cat on a file: https://gist.github.com/840cd4c2b3259d36935e830c07b94f9e
10:58:32 <grazie> 2/5 this is the 100 line implementation to a Sudoku solver done by someone else https://gist.github.com/40913e9c3c59dc48209614e87838ccd1
10:58:59 <joe9> EvanR: I am running a socat on the communication from the kernel to the 9pfs user space server.
10:59:07 <ertes> joe9: is this TCP or UDP or something else?
10:59:10 <joe9> EvanR: This is from the socat logs.
10:59:18 <joe9> ertes: it is based on TCP.
10:59:26 <grazie> 3/5 for learning purposes, I'm trying to refactor it: this is my solution where I make changes from lines 80 to 109, essentially dividing `eliminate` func into 4 parts
10:59:36 <EvanR> joe9: and socat is guaranteeing you one read call?
10:59:37 <kuribas> ertes: right, thanks!
10:59:38 <geekosaur> then you do not care how many reads happen, and you *must* not care how many reads happen
10:59:43 <geekosaur> socat can't guarantee that
10:59:56 <geekosaur> the kernel doesn't guarantee it. the network doesn't guarantee it.
10:59:57 <grazie> 4/5  you can run the original solution in ghci like this: `solve ".......2143.......6........2.15..........637...........68...4.....23........7...."` and it will return a solved sudoku
11:00:03 <joe9> geekosaur: EvanR: socat is just to see the communication.
11:00:06 <EvanR> so yeah i was right to be hung up on this terminology, its not really about number of read calls
11:00:15 <EvanR> never was
11:00:30 <EvanR> you have some other issue
11:00:55 <grazie> 5/5 if you do it with my script, however, it just hangs.  Can you either tell me why or how I can figure out why it's broken. In an imperative lang, I just log everything and it usually works, with haskell, I don't know how to do that
11:00:56 <ertes> i'm still not sure what the issue even is
11:00:57 <joe9> geekosaur: EvanR, my issue is not about the number of read calls. it makes a read, (times out I think), flushes the read, sends another read. --- goes on when doing from haskell
11:01:17 <joe9> geekosaur: EvanR, from cat, it is just : read - response - read
11:01:23 <glguy> [exa]: You should just ask your actual question
11:01:25 <EvanR> sends a read... is sounds liky oure still talking about number of calls
11:01:29 <joe9> geekosaur: EvanR, ertes , does that make sense?
11:01:32 <EvanR> no
11:01:33 <geekosaur> joe9, nothing does blocking reads. it does a epoll/poll/select for data
11:01:49 <geekosaur> *files* work differently, you can't poll for data ready, you just read
11:01:50 <grazie> 6/5 sorry, this is my broken solution (didn't post earlier) https://gist.github.com/6625d0e785356405bd36c572f34696f0  
11:01:57 <ertes> joe9: not really…  you don't *send* reads…  the socket receives and buffers data, and you just read it…  it's a local process
11:02:17 <EvanR> no one knows what your actual question / problem is
11:02:29 <grazie> if my question is too long for this forum, where should I ask it. thanks
11:02:30 <EvanR> everyone is just correcting your understanding on internal stuff
11:02:37 <[exa]> Well. I'm trying to determine how the instance members are typechecked. Let's assume I have class X a with member fn :: a->a, datatype D a, and instance Y a => X (D a).
11:02:53 <ertes> joe9: i really don't understand what the problem is…  just read using a streaming abstraction (or even an ad-hoc loop for leftover handling)
11:02:55 <[exa]> Materials suggest that instance members should get transformed to toplevel function and typecheck "as usual"
11:02:57 <geekosaur> grazie, it's too split up, certainly; a single lpaste would have been better. but really you probably want the haskell-cafe list or stackoverflow
11:03:17 <[exa]> Q: What type should I explicitly assign the toplevel function so that it typechecks correctly?
11:03:43 <joe9> geekosaur: "cat" seems to do something similar to a blocking read.
11:03:52 <geekosaur> [30 19:01:26] <geekosaur> *files* work differently, you can't poll for data ready, you just read
11:03:56 <geekosaur> also cat is not haskell
11:04:06 <EvanR> also why would cat on a file need to do a blocking read
11:04:07 <grazie> geekosaur: ok, thank you
11:04:07 <[exa]> My best guesses are: 1] X (D a) => D a->D a 2] the same with (Y a) also in qualifier
11:04:52 <geekosaur> all reads/writes done from ghc-compiled haskell code go through the I/O manager, which knows which Handles correspond to disk files (which must do normal reads) and which to network sockets (which can poll for available data)
11:05:28 <geekosaur> (if you try to poll a disk file, the OS always returns "data available")
11:06:25 <joe9> geekosaur: oh, ok. if the IO manager sees that it is a disk file and has not responded to a read within a certain time, it assumes some system fault, etc and tries reading again (?)
11:06:52 <ertes> file reads don't time out
11:07:01 <geekosaur> no. perhaps yu're being confused by the master timer tick (see +RTS --help, look for -V)
11:07:50 <geekosaur> the ghc runtime interrupts *everything* every 0.01 seconds by default, and does housekeeping (profiling if enabled, gc checks, etc.)
11:08:20 <freshPrinceOfLam> the best things in life are Free (monads)
11:08:21 <AhmadArshad> http://databrary.org/about/jobs/back-end.html     Databrary project at NYU is looking for an enthusiastic haskeller, if interested..
11:08:21 <EvanR> wait... is that real. 
11:08:23 <geekosaur> you can disable that with +RTS -V0 but things like thread scheduling will be delayed
11:08:39 <EvanR> geekosaur: i thought you could lock up the system by writing a loop that doesnt do allocation
11:08:52 <EvanR> because allocation is when housekeeping happens
11:09:05 <joe9> geekosaur: oh, ok. I have profiling enabled. my issue is that when I try to read from the file (served by 9pfs) using haskell, it just sends quite a bit of messages to the server. read, flush, read, flush, etc.
11:09:06 <geekosaur> I think that's only with non-threaded or with -V0. in threaded mode, there's more triggers
11:09:07 <maerwald> I wonder if there are (useful) functional languages without GC
11:09:30 <EvanR> maerwald: how about Ur/Web
11:10:17 <geekosaur> also, because signals can happen at any time, it can't do a lot in a signal handler, so most things are just setting flags to be checked in the main sequence of evaluation instead of the thread handler (so, it can't GC but it can set the GC-needed flag which is checked the next time normal code allocates)
11:10:39 <grazie> I'll try an lpaste -- can anyone tell me why my refactor of the eliminate function (breaking it into 4 parts) doesn't work? http://lpaste.net/348290
11:10:42 <carado> since IO takes real time into consideration and the universe is, from what we know, finite, can we assert that any IO action halts ?
11:11:13 <EvanR> no
11:12:05 <EvanR> but you could assert that any IO action completes as part of your hypotheses
11:12:21 <EvanR> and you dont even need a weird reason!
11:12:58 <mizu_no_oto_work> carado: particular IO actions, or every IO action?  obviously because of the halting problem, there are non-terminating IO actions that you can't determine if they'll halt.
11:13:54 <EvanR> you dont even need to halting problem to just show an IO action that is written to freeze up, but thats probably not what carado was getting at
11:14:12 <carado> right, but when I do the IO action "please run this bash infinite loop", am I not guaranteed that the system hosting a bash implementation will at some point break down ?
11:14:25 <the_2nd> foo >> bar >> return baz   I can make sure that baz is only returned if both foo and bar were valid. How can I enfore that either one of them has to be true?
11:14:28 <nshepperd1> carado: you can assert even stronger: every program eventually ends
11:14:42 <nshepperd1> Due to the computer running it getting trashed
11:14:48 <geekosaur> carado, yes, but only by thermodynamics :)
11:15:04 <nshepperd1> In the biannual hardware refresh :)
11:15:07 <the_2nd> with alternative foo <|> bar <|> return baz   I only return baz if neither of foo and bar worked
11:15:12 <EvanR> carado: people live in abstract worlds, youre trying to get out, i think youll find this hard
11:15:12 <carado> well, if I stay outside of IO, I’d say my program is still in the theoritical realm of mathematics, in which case I think of it as non-halting
11:15:12 <carado> see what I mean ?
11:15:14 <the_2nd> so I need something else
11:15:45 <mizu_no_oto_work> (foo <|> bar) >> return baz ?
11:15:47 <dmwit> Why does the instance for `Default (XConfig a)` not appear in the documentation here? http://hackage.haskell.org/package/xmonad-0.12/docs/XMonad-Config.html
11:15:56 <ertes> maerwald: not sure how that would work…  even unlambda and lazy k need GC, and those are rather straightforward implementations of the SKI calculus
11:16:04 <dmwit> If you click the "Source" link at the top of the page you can see the instance is defined in that module, so it's definitely "in scope" so to speak.
11:16:11 <EvanR> ertes: Ur/Web
11:16:19 <EvanR> "need" GC is the question here
11:16:30 <the_2nd> foo <|> bar >> return baz  ?
11:16:40 <geekosaur> dmwit, haddock has bugs. even the documentation for Prelude has missing instances
11:17:09 <EvanR> "The Ur/Web compiler also produces very efficient object code that does not use garbage collection."
11:17:39 <joe9> geekosaur: I can see that the behaviour is different with -V0, I just see a read -> response -> read, cycle. and not the , read -> flush -> read -> response -> read -> flush, cycle
11:17:39 <dmwit> geekosaur: dang
11:18:23 <ertes> EvanR: how does that work?  doesn't it have, say, partial application?
11:18:38 <joe9> geekosaur:  but, I also notice that the other threads are getting blocked
11:18:42 <geekosaur> carado, generally we just accept that such code isn't *really* non-halting. the actual guarantee made is that you cannot *observe* it from pure code, not tht it doesn't happen
11:18:45 <joe9> geekosaur: as you mentioned.
11:18:56 <geekosaur> (i.e. you need to be in IO)
11:19:29 <EvanR> ertes: i actually dont know what the language is like, except that it embraces dependent types. But what I heard was that it simply doesnt try to reclaim any memory until after a request is totally over, which is guaranteed to happen, and by the sensibilities of web programmer, guaranteed to happen soon
11:19:46 <EvanR> web programming*
11:20:25 <ertes> EvanR: that sounds like GC to me
11:20:41 <ertes> except that it all happens at one point
11:20:46 <EvanR> ertes: in the sense that C is garbage collected
11:20:48 <EvanR> by the OS
11:21:00 <EvanR> which i dont think maerwald would agree with
11:21:18 <ertes> perhaps…  but then you better don't do anything complicated using FP
11:21:25 <ertes> because it will blow up your memory
11:21:42 <EvanR> good question, how much memory would a typical web request allocate?
11:22:07 <geekosaur> you could think of that as "cooperative gc", like cooperative threading where everything has to explicitly yield to let something else run
11:22:08 <joe9> geekosaur: Is there a way to bypass the IO manager ?
11:22:10 <ertes> it depends…  imagine reading a bunch of data sets from the DB and transforming them, then rendering them, etc.
11:22:33 <geekosaur> joe9, you could probably do evil things with the FFI --- but forget about multiple threads if you do
11:22:52 <geekosaur> it's not just "oh I'll just do a hard blocking read now", you WILL break the runtime
11:22:54 <EvanR> ertes: i think of that as mostly streaming... i wonder if Ur optimizes that
11:23:09 <geekosaur> if you really need syscall level control, write in C or Rust and nothing else
11:23:40 <joe9> geekosaur: yes, that is what is happening. it is blocking up the runtime/(or, other threads)
11:23:46 <ertes> EvanR: exactly…  streaming allocates a lot and basically just gets rid of it again quickly…  you lose the benefits of streaming, if you have no GC…  or you end up manually freeing memory
11:24:15 <geekosaur> (but I see no evidence that you do, and I don't know what you think is a flush, and generally I suspect you are confused on multiple levels at least one of which is how the *network* works)
11:24:15 <ertes> EvanR: especially if your streaming abstractions look anything like haskell's
11:24:22 <EvanR> honestly, i wonder if Ur code takes more memory per request than a rails suite of processes does long term
11:24:30 <ertes> hehe
11:24:35 <geekosaur> if you actually need one write to be one read, use datagram sockets
11:24:50 <geekosaur> TCP *will not give you that*, no matter how you write your code
11:25:41 <ertes> also is ur really dependently typed?  i remember reading somewhere that ur actually has lightweight dependent types similar to haskell
11:26:02 <peddie> from http://www.impredicative.com/ur/? : "The Ur/Web compiler also produces very efficient object code that does not use garbage collection. . . . For example, the standalone web server generated for the demo uses less RAM than the bash shell."
11:26:04 <joe9> geekosaur: ok, thanks. tcp is used to implement 9pfs on linux, I think. I cannot change that.
11:26:26 <EvanR> ertes: i see theres a reference manual, with 61 pages
11:26:27 <geekosaur> then restructure your code properly, or possibly 9pfs is broken by design
11:26:59 <geekosaur> the *definition* of a network stream is that it is unstructured --- you cannot know how many writes or reads are performed, it's just a stream of octets
11:27:33 <joe9> geekosaur: ok, Thanks.
11:27:50 <geekosaur> I think it more likely that it has a packet protocol somewhere, and you need a protocol layer to reassemble packets and pass them up
11:28:20 <ertes> subseven (that ancient windows backdoor) used TCP as a datagram protocol, and it was horribly broken =)
11:28:26 * slack1256 wants to thanks to whomever implemented -XType
11:28:40 <slack1256> -XtypeApplications, makes teaching typeclasses a lot easier
11:29:17 <slack1256> also, check instances
11:29:39 <geekosaur> network filesystems are a bit of a screw case. reads/writes matter because the interface is block based, but if you use datagrams you have to implement packet reassembly, retransmissions, etc. yourself
11:30:06 <geekosaur> and if you use tcp you need extra logic to reconstruct the block structure the filesystem interface expects
11:30:29 <geekosaur> every network filesystem has to make choices, and all choices are bad in one way or another
11:31:02 <geekosaur> (this is basically because filesystem interfaces were designed for local hard drives, not network)
11:31:34 <EvanR> ertes: i cant find anything to confirm or deny the level of dependent types in ur
11:32:06 <EvanR> so its support is currently a wide interval of certainty
11:32:08 <ertes> (… or: how i learned to stop worring and love the sync)
11:32:22 <peddie> EvanR: from the front page, it says "Ur supports a powerful kind of metaprogramming based on row types." but it never mentions dependent types
11:32:24 <joe9> geekosaur: I think this is also because of how 9pfs was implemented on linux. I think some of the assumptions that work on plan 9 did not carry over well.
11:32:39 <EvanR> peddie: yeah it says "type level computation"
11:33:03 <slack1256> how be saying, as a rule of a thumb for control space in lazy data structures: "don't force the spine, but if you did and you know the leaf will be simple, eval them"?
11:33:46 <geekosaur> joe9, IIRC plan9 actually changed how the filesystem interface works so it's more network-friendly. this makes it hard to interface with traditional block-based filesystems like unixes expect
11:34:07 <WzC> two quick questions: is there something that does linear time median finding in "the standard libraries" (i.e. base or containers or so)? 
11:34:08 <ertes> slack1256: i'd be careful with rules of thumb in that case
11:34:28 <joe9> geekosaur: makes sense. Thanks.
11:34:35 <slack1256> I feel we need good rules of thumb
11:34:45 <WzC> second q: is there something that gracefully interpolates between linear time median finding and sorting? i.e. if I access k elements gets something like O(n + klog n) running time? 
11:34:52 <geekosaur> but if you redesign the filesystem interface as network friendly, this ends up changing how applications are coded --- no code that reads a disk file expects it to delay on network retransmissions, or produce short reads for any reason other than end of file
11:34:59 <WzC> these things should be possible somewhat easily I would guess
11:35:03 <ertes> slack1256: and that's a problem, because any rule of thumb will be good in one case and terrible in another
11:35:06 <geekosaur> and you can hide only so much of that in a library or toolkit
11:35:24 <nshepperd1> TCP seems somewhat suboptimal for network fs, due to forcing a sequential order you maybe don't need
11:35:43 <EvanR> slack1256: it would be nice to have examples of usage and proper ways to handle it
11:35:56 <nshepperd1> Then you get head of line blocking if a single packet is lost somewhere
11:35:58 <geekosaur> correct, but UDP is also suboptmal because you have to handle dropped packets yourself
11:36:18 <EvanR> slack1256: and a selection of pitfalls and why they are pitfalls
11:36:23 <geekosaur> look at the history of NFS
11:36:23 <ertes> slack1256: a better solution would be to train your audience in making the right decisions
11:36:46 <joe9> geekosaur: on a different note, any comments on plan 9? like it or hate it?
11:36:49 <slack1256> the thing is even seniors can't agree on what are right decisions
11:37:06 <ertes> slack1256: the right decisions depend on the use case
11:37:12 <nshepperd1> Yes. And congestion control
11:37:19 <slack1256> you're right
11:37:20 <joe9> geekosaur: it seemed great when I read the manuals, etc. but, there is no ghc on plan 9 and that has been holding me up.
11:37:32 <EvanR> slack1256: for lazy data, generate it lazily and consume it strictly
11:37:55 <ertes> slack1256: i found it most helpful not to talk about laziness at all, but instead talk about definitions and pattern-matching, and how they interact
11:38:27 <geekosaur> joe9, not really. it's different, it's a bit like Haskell in that the mainstream finds it "too different" --- they reimagined a lot of things in ways that work better, but require you to do things differently
11:38:39 <ertes> slack1256: "ones = 1 : ones;  so if we match ones against x:xs, what is xs?  xs = ones, because that's how ones is defined"
11:38:45 <geekosaur> and in the end, nobody really likes having to learn how to do things differently
11:39:40 <joe9> geekosaur: it would be a marriage of similar's then, if ghc can work on Plan 9/9front.
11:41:59 <geekosaur> joe9, unfortunately it's a category theory kind of similarity :)
11:42:48 <EvanR> slack1256: heres a situation where its ambiguous what the right way is... lets say you have a normal-form Map of data, of Ints. you already decide that its a strict map because unevaluated Ints are probably not space and time efficient (from another rule of thumb). but now you have to decide whether inserting should be forced now or left lazy (slowing down future lookups)
11:42:52 <slack1256> EvanR: that is an good axis to consider. There is also the one of single/multiple readers
11:43:26 <EvanR> and what you should do depends on if you write more or read more and how often
11:43:35 <xcmw> It is possible to write a more generic type for z (line 61)? http://lpaste.net/348013
11:43:41 <EvanR> maybe you should just force it always
11:44:13 <EvanR> (actually i dont know how to force a map insert completely...)
11:45:36 <slack1256> at least Map is spine strict, so you have enforce (on your version of insert if needed) that if the spine if evaluated, then this value also is with `seq`
11:45:43 <slack1256> that should be enough I guess
11:47:20 <slack1256> I got this rule of thumb in my head: for data that will be read, be as strict as you can. For data structures that are really control structures you should be lazy
11:47:37 <slack1256> the problem is for data that also serve as control because is not gradual
11:47:38 <slack1256> lol
11:48:16 <slack1256> I am thankful for the existence of .Strict and .Lazy modules for this. 
11:53:02 <EvanR> slack1256: maybe im weird, but "for data that is really a control structure" isnt helping me understand when or what to do, because that characteristic doesnt make sense to me in haskell
11:53:27 <EvanR> control structure sounds to me like javascript or lua manual generator management, which is too hard for me to understand
11:55:23 <EvanR> i mean if youre using them at the scale of haskell
11:56:03 <slack1256> I guess the most common control structure is the usage of list. It is common (at least in my ST vectors) to do forM_ [1..100] $ do ...
11:56:08 <ggVGc> it's pretty discouraging that after writing haskell for almost a year, I feel like I know about 2% of it
11:56:38 <slack1256> the main usage of the list is as a pure generator
11:56:39 <EvanR> when you get to 100% completion, you probably dont play anymore
11:56:58 <ggVGc> EvanR: wish I'd been at least around 20%
11:56:59 <slack1256> most of the idioms with traverse also follow this rule
11:57:21 <EvanR> list is a special case
11:57:29 <EvanR> which no one wants to admit! ;)
11:57:47 <EvanR> list or anything one dimensional like that makes laziness work the best
11:57:47 <slack1256> I fully admit it ! xD
11:58:02 <EvanR> lazy text is basically a list of chunks
11:58:47 <EvanR> trees dont let you be as lazy, but they have other benefits
11:59:14 * hackagebot lua-bc 0.1.0.3 - Lua bytecode parser  https://hackage.haskell.org/package/lua-bc-0.1.0.3 (EricMertens)
11:59:26 <c_wraith> lazy trees are beat when you'll only ever follow a limited selection of paths in them. 
11:59:26 <jedai> ggVGc: Well 2% of full Haskell GHC with the extensions or 2% of Haskell 2010 ?
11:59:36 <c_wraith> *best
12:00:47 <EvanR> trees can be parallelized, lists cant
12:01:52 <EvanR> i was thinking, what else is there... ah ha! graphs: http://blog.higher-order.com/blog/2016/04/02/a-comonad-of-graph-decompositions/
12:02:13 <EvanR> (introduction and destruction of inductive graphs)
12:02:13 <slack1256> I was thinking on trees of trees... which reached graphs for me
12:03:44 <EvanR> ah and a fourth "class" of datastructures could be, functions
12:04:24 <EvanR> functions also need to have laziness in mind because of partial application
12:04:36 <EvanR> apply now or apply later
12:04:44 <joe9> Is there any trick to step into a library module's function?
12:04:57 <joe9> using ghci
12:05:14 <slack1256> Mmm this is difficult, because you have to think *globally* how your application will use this specific instance of the data...
12:05:23 <slack1256> sometimes I am in no mood to do that
12:05:40 <slack1256> joe9: did you compile with profiling enabled?
12:05:40 <EvanR> is that different from OOP ?
12:06:02 <EvanR> you can only have one "innards" of a particular object
12:06:11 <joe9> slack1256: yes, error about not being an interpreted file
12:12:25 <EvanR> each class of "functional" data structures comes with an inductivey interface, like, graphs could be implemented however behind the scenes, but that decomposition view lets you treat it as "functional"
12:12:32 <EvanR> is there something like this for arrays
12:15:15 <johnw_> hmm... magit has stopped showing me when files are changed within submodules
12:15:26 <johnw_> it shows when the submodule's commit is different
12:15:39 <johnw_> but not when there are dirty files... which git diff-index HEAD _does_ show
12:24:53 <shapr> koala_man: My employer started using shellcheck, thanks!
12:44:43 <buttbutter> Is there any function that generates permutations of this sort: [a, b, c], [c, a, b], [b, c, a] (but no others)? Is there a name for that sort of permutation?
12:45:45 <geekosaur> some languages/libraries call that "rotor"
12:46:06 <buttbutter> Oh, that's a nice name :)
12:46:35 <kadoban> Yeah, I think those are called the rotations
12:48:26 <buttbutter> Hm. I bet you could do it with repeat. For a list of size n, just take n elements, then shift over 1, take the next n, until you've shifted n times.
12:48:37 <buttbutter> Anyone have better ideas?
12:48:46 <kuribas> > let rotations l = zipWith (++) (tails l) (inits l) in rotations [1..10]
12:48:48 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,1],[3,4,5,6,7,8,9,10,1,2],[4,5,6...
12:49:01 <koala_man> shapr: nice! which employer?
12:49:12 <shapr> koala_man: pindrop in atlanta
12:49:37 <shapr> I do wish shellcheck worked for zsh, but I don't wish it enough to put up PRs :-)
12:49:42 <buttbutter> kuribas: I would've never thought of using tails/inits :(
12:49:54 <buttbutter> nice solution :D
12:51:01 <koala_man> shapr: it did for a while, but it required a ton of new syntax for very few users
12:51:40 <koala_man> unlike e.g. ksh, which also has few users but not a lot of new syntax
12:52:34 <shapr> koala_man: sensible decision
12:54:16 * hackagebot katip 0.3.1.2 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.3.1.2 (MichaelXavier)
12:55:39 <kuribas> > let rotation l = take (length l) $ map (take $ length l) $ tails $ cycle l in rotation [1..10] -- buttbutter like this?
12:55:42 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,1],[3,4,5,6,7,8,9,10,1,2],[4,5,6...
12:56:57 <kuribas> buttbutter: probably more efficient, since it has more sharing.
12:58:59 <kuribas> erm no, forget that...
12:59:14 <buttbutter> I was having difficulty parsing it :P
12:59:16 * hackagebot blosum 0.1.1.4 - BLOSUM generator  https://hackage.haskell.org/package/blosum-0.1.1.4 (GregorySchwartz)
13:06:33 <buttbutter> > let foo ls = map (\k -> take (length ls) . drop ((length ls) - k) . cycle $ ls) ls in foo [1..4]
13:06:36 <lambdabot>  [[4,1,2,3],[3,4,1,2],[2,3,4,1],[1,2,3,4]]
13:06:38 <buttbutter> :D
13:07:27 <buttbutter> kuribas: I still prefer your initial solution, though.
13:08:29 <kuribas> > let foo ls = map (\k -> take (length ls) . drop ((length ls) - k) . cycle $ ls) ls in foo [2, 1, 3, 4]
13:08:32 <lambdabot>  [[3,4,2,1],[4,2,1,3],[1,3,4,2],[2,1,3,4]]
13:09:48 <MarcelineVQ> alternatively: foo xs = let l = length xs in take l . map (take l) . iterate (drop 1) . cycle $ xs
13:10:24 <buttbutter> Oh wait, it's wrong isn't it
13:11:10 <buttbutter> Wait, nevermind. 
13:11:45 <kuribas> > let foo ls = map (\k -> take (length ls) . drop ((length ls) - k) . cycle $ ls) ls in foo [2..5]
13:11:48 <lambdabot>  [[4,5,2,3],[3,4,5,2],[2,3,4,5],[2,3,4,5]]
13:12:02 <kuribas> buttbutter: the last one isn't right
13:12:19 <buttbutter> [2,3,4,5]?
13:12:27 <buttbutter> Oh, right. Repeated.
13:12:29 <kuribas> buttbutter: it's there twice
13:12:39 <kuribas> also:
13:12:46 <kuribas> > let foo ls = map (\k -> take (length ls) . drop ((length ls) - k) . cycle $ ls) ls in foo [a, b, c, d]
13:12:48 <lambdabot>  error:
13:12:48 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Expr’
13:12:48 <lambdabot>      • In the expression: a
13:13:47 <buttbutter> Why is that happening?
13:20:32 <EvanR> the matrix rebooted
13:20:49 <MarcelineVQ> you are waiting for a train
13:22:05 <byorgey> buttbutter: because dropping a negative number of elements behaves the same as dropping 0
13:22:20 <byorgey> buttbutter: (length ls) - k == -1  when  ls = [2,3,4,5] and  k = 5
13:22:22 <geekosaur> buttbutter, if you meant the error involving Expr, maybe you wanted to quote a, b, c, d there
13:22:43 <geekosaur> or bind them to something
13:29:02 <buttbutter> Ah, ofc. 
13:29:34 <kuribas> Is this function possible?  Show b => StateT (Either b) a -> StateT (Either String) a?
13:29:39 <buttbutter> geekosaur: And yes, that too. Somehow I assumed they were already bound. :)
13:29:49 <geekosaur> they are, just not usefully to you :)
13:30:17 <geekosaur> @hackage simple-reflect
13:30:17 <lambdabot> http://hackage.haskell.org/package/simple-reflect
13:32:07 <byorgey> kuribas: that doesn't seem to be well-kinded.
13:32:26 <byorgey> kuribas: in particular the first argument to StateT must have kind *, but Either b :: * -> *
13:32:50 <lyxia> kuribas: b is invariant in stateT, show gives you b -> String, you are missing String -> b.
13:32:53 <kuribas> byorgey: right
13:33:28 <kuribas> Show b => StateT MyState (Either b) a -> StateT MyState (Either String) a
13:34:14 <lyxia> oh wait I tought Either b was the state
13:34:30 <kuribas> I guess this needs to be unwrapped and wrapped again?
13:35:17 <lyxia> lift (first show)
13:36:19 <kuribas> byorgey: the problem is the functions from MFSolve take "MonadError (DepError v n) m", but I have now "MonadError String m"
13:36:27 <lyxia> :t lift . Data.Bifunctor.first show
13:36:29 <lambdabot> (MonadTrans t, Bifunctor p, Show a1, Monad (p String)) => p a1 a -> t (p String) a
13:36:48 <lyxia> almost...
13:37:20 <glguy> :t \m -> StateT $ \s -> either (Left . show) Right (runStateT m s)
13:37:21 <lambdabot> Show a1 => StateT s (Either a1) a -> StateT s (Either [Char]) a
13:37:48 <glguy> (using first is fine, I just didn't import it when I typed that in)
13:39:18 * hackagebot flat-mcmc 1.4.0 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.4.0 (JaredTobin)
13:39:24 <glguy> mapStateT (first show) :: Show b => StateT s (Either b) a -> StateT s (Either String) a
13:40:54 <kuribas> glguy: wow, that's nice
13:52:31 <EvanR> can someone explain how church encoding data structures as a newtype over a higher rank polymorphic function improves performance
13:54:31 <johnw> EvanR: there are no constructors involved
13:54:54 <johnw> you have something which is equivalent to structured data, and yet there is no layout cost
13:55:16 <EvanR> does it improve performance for recursion? or is that some other technique
13:55:19 <nitrix> EvanR: As opposed to a data type?
13:55:40 <johnw> it can improve the speed of folding, because no case discrimination is required
13:55:47 <johnw> it's just functions calling functions
13:56:04 <johnw> there is a downside: you lose the thing you just lost: constructors :)
13:56:26 <EvanR> i heard something about ghc not efficiently compiling recursion
13:56:35 <EvanR> and some trick gets around it, recursion without recursion
13:56:43 <johnw> anyone who says that in a general way does not understand what GHC does
13:57:26 <johnw> i think you might be referring to the fact that GHC can sometimes more easily optimize and inline in the absence of recursion
13:57:35 <EvanR> ah
13:57:49 <johnw> which is what makes the flat evaluators in the "recursion schemes" approach sometimes win
13:58:06 <EvanR> oh, are recursion schemes inlinable?
13:58:15 <johnw> recursion schemes move the recursion out of the evaluator
13:58:31 <johnw> by separating evaluation into two parts: the spine and the content
13:58:38 <johnw> the spine evaluator is still recursive
13:58:49 <johnw> but the content evaluator is not, and so can be optimized better (sometimes)
13:59:10 <EvanR> so if i write a recursion combinator, which is recursive, and its expecting to a non-recursive function argument, will that increase performance?
13:59:11 <johnw> it's hard to come up with general rules about these things, GHC is very smart and circumstances vary
13:59:30 <nitrix> Is this a good moment to bring equirecursive/isorecursive?
13:59:33 <johnw> EvanR: I don't know without looking at your code
14:00:28 <EvanR> my example is implementing Nat as a newtype over a function of type a -> (a -> a) -> a
14:01:38 <johnw> and what's the combinator?
14:01:55 <EvanR> so, lets say i want to implement addition
14:01:58 <nitrix> I think with a bit of hackery, you can build dependent types and have the type checker unroll the church encoding as a final dependently typed number >:)
14:02:25 <johnw> nitrix: Nats are not dependently typed
14:02:57 <nitrix> Are you sure (: ?
14:03:06 <EvanR> hrm
14:03:24 <johnw> nitrix: yep
14:03:31 <EvanR> im kind of lost now, think about two esoteric techniques plus performance ;)
14:03:38 <johnw> he wrote the type of Nat just now, without any dependency :)
14:03:53 <nitrix> I have a cool trick in mind with a typeclass and defining an instance on ((->) r), but you'd need two types for that, as you lost your constructor.
14:04:47 <johnw> EvanR: maybe: add x y = \z s -> y (x z s) s
14:05:00 <johnw> not sure about that, but the idea is for "s" to be called x + y times
14:05:41 <EvanR> ah the recursion is built into the numbers
14:05:49 <carado> is there anything that instances Functor but not Applicative ?
14:05:53 <johnw> yes, that's the core of the Church technique
14:05:58 <nitrix> carado: Void
14:06:22 <carado> I mean Functor but not Traversable *
14:06:39 <johnw> (,) s is only a Functor, if nothing is known about s
14:06:43 <nitrix> carado: Not Haskell's Void, but a different Void define as `data Void a` would be a valid functor but with no inhabitant for it to be able to implement `pure`.
14:07:22 <nitrix> Oh nevermind then :P
14:08:13 <EvanR> so theres no point in a separate recursion scheme for nats, in this case
14:08:34 <johnw> the Nat you gave is the closure of a recursion scheme :)
14:09:02 <johnw> it's the type of a fold function applied to a given number
14:09:19 * hackagebot dresdner-verkehrsbetriebe 1.0.0 - Library and program for querying DVB (Dresdner Verkehrsbetriebe AG)  https://hackage.haskell.org/package/dresdner-verkehrsbetriebe-1.0.0 (meoblast001)
14:10:03 <EvanR> right newtype Nat = forall a . Nat { recN :: a -> (a -> a) -> a }
14:10:12 <EvanR> recN :: Nat -> a -> (a -> a) -> a
14:10:34 <EvanR> so this will be fast? ;)
14:11:39 <EvanR> i can imagine applying this compute an actual answer on some real domain, and no checks need to be done during the loop
14:11:45 <EvanR> to compute*
14:14:20 <nitrix> What about something like `2 :: Nat (Nat (Nat End))`,   add :: Nat a -> Nat a -> Nat a ?
14:14:40 <nitrix> err.
14:15:01 <nitrix> Nat a -> Nat b -> Nat c, presumably.
14:15:18 <EvanR> how would you produce any c whatsoeve!
14:15:35 <ggVGc> lift . lift . life . weights
14:15:42 <ggVGc> s/life/lift
14:15:50 <EvanR> LIFT LIFE
14:15:57 <ggVGc> agreed
14:16:05 <nitrix> EvanR: If you want 5, you can produce  undefined :: Nat (Nat (Nat (Nat (Nat End)))) :/
14:16:08 <ggVGc> IO Life
14:16:13 <EvanR> nitrix: what if you want Char
14:16:31 <nitrix> EvanR: Add a constraint :P
14:16:56 <nitrix> instance Nat a => Nat a  ahah
14:17:22 <lyxia> carado: IO, (->) a
14:17:32 <EvanR> IO is applicative
14:17:43 <EvanR> so is function
14:18:08 <lyxia> he corrected to "Functor but not Traversable"
14:18:12 <EvanR> oh
14:19:09 <nitrix> EvanR: How about  `add :: (Nat a, Nat b, Nat c) => Nat a -> Nat b -> Nat c` :P ?
14:19:54 <nitrix> EvanR: I haven't put much thought into it really, I just like the thought experiment.
14:19:56 <jmorris> https://www.youtube.com/watch?v=LnX3B9oaKzw
14:19:56 <EvanR> stuff better start making sense REAL FAST
14:20:32 <dolio> How is Nat both a class and a normal parameterized type in the signature?
14:21:21 <nitrix> I have a feeling if you solve that problem, you also solve his :P
14:21:44 <EvanR> because it would be like constructing Void and this solve anything?
14:22:36 <nitrix> Fine, challenge accepted; I'll play with my idea tonight :P
14:23:03 <nitrix> The goal is using a newtype, no data type (which would lead the the constructor overhead, right?)
14:23:38 <EvanR> nitrix: i think we already solved that, ill do an lpaste
14:24:53 <johnw> I don't think nitrix has shown us the typeclass he has in mind yet
14:25:50 <lpaste> glguy pasted “Nat as Constraint and Type” at http://lpaste.net/348395
14:25:57 <glguy> dolio: ^ :)
14:27:25 <johnw> what does that have to do with natural numbers, aside from the name?
14:27:39 <glguy> It has to do with dolio's question
14:27:42 <johnw> seems like a fancy and highly restrictive way to write id
14:27:54 <johnw> ah
14:28:07 <glguy> I have no idea what nitrix is up to
14:28:31 <EvanR> nitrix: http://lpaste.net/348397
14:29:53 <EvanR> and i fixed a missing recN. heh i was sort of hoping that lpaste would give me a suggestion leading me to the next tier of esoteric math
14:30:10 <EvanR> "please lookup <something> encoding"
14:32:39 <EvanR> johnw: maybe a stupid question, what do you lose when you lose constructors, practically
14:32:58 <johnw> the ability to discriminate between values
14:33:12 <johnw> you can ask "is this zero or not zero" without going through the entire fold
14:33:18 <johnw> can't*
14:33:40 <ggVGc> well you can always ask...
14:33:58 <johnw> btw, this is also sometimes called a "final encoding", or a "final tagless representation"
14:34:01 <EvanR> does "is this zero or not zero" make sense?
14:34:03 <ggVGc> haskell is a little bit like quantum physics. Before you've asked for the results, anything is possible!
14:34:07 <EvanR> johnw: oh!
14:34:18 <johnw> EvanR: case x of Z -> ...; S _ -> ...
14:34:30 <johnw> that's what you cannot do
14:34:35 <EvanR> i see that, but does it make sense with this representation, they are all functions
14:34:46 <johnw> you can tell, but you can't do it in one step
14:34:53 <EvanR> or is it the case that everything you can ever write is equivalent to z or s
14:34:57 <EvanR> ah
14:35:08 <johnw> you have to do something like use the closure to count the numbers, converting them to the initial encoding
14:35:45 <EvanR> so it might make some operations less efficient
14:35:54 <johnw> some less, some more
14:36:20 <EvanR> ggVGc: with the functional future values thing... its like the exact opposite philosophy
14:36:36 <EvanR> nothing you can do now can change what the future value will be
14:36:51 <EvanR> but you dont have to look at it ;)
14:41:08 <jmcarthur> I don't think it's completely correct to say that you "can't" scrutinize the value. You could, for example, just Scott encode the constructors.
14:42:25 <johnw> that's a different type, or something you'd have to convert to, no?
14:43:01 <jmcarthur> Sorry, a different type from what? I thought we were just talking about what happens when you remove constructors from the language.
14:43:10 <jmcarthur> Maybe I missed some context.
14:43:14 <johnw> this is was specifically about a Church encoding of Nats
14:43:17 <jmcarthur> Ah
14:43:39 <jmcarthur> Yeah, you can't in general scrutinize a single level of a church encoding.
14:43:52 <jmcarthur> newtype Nat = Nat (forall r. r -> (Nat -> r) -> r)  -- the scott encoding
14:44:21 <jmcarthur> Also I maybe cheated, depending on what is meant by "constructor"
14:44:26 <jmcarthur> Since the newtype has a constructor
14:44:52 <EvanR> doesnt count
14:45:02 <jmcarthur> Correction: You can scrutinize one level of a church encoding, but to keep the tail you have to reconstruct it.
14:45:57 <johnw> EvanR: you might like: http://homepage.cs.uiowa.edu/~astump/classes/185/archon.pdf
14:46:02 <jmcarthur> But that might not be true for some evaluation strategies.
14:46:31 <johnw> section 5.3 "Comparison of the Church and Scott Encodings"
14:46:33 <EvanR> scott encoding you sy
14:47:48 <EvanR> nice
14:51:24 <hololeap> > negate minBound == (minBound :: Int)
14:51:26 <lambdabot>  True
14:55:20 <EvanR> the reason i started looking into this is because of the inductive graph decomposition on runar bjarnson's blog
14:55:37 <EvanR> can inductive graphs be church encoded?
14:56:03 <EvanR> bjarnarson*
14:56:07 <EvanR> bjarnason*
14:57:04 <hololeap>  > toEnum 0
14:58:33 <hololeap> > mempty
14:58:35 <lambdabot>  ()
14:58:41 <hololeap> > toEnum 0
14:58:41 <johnw> EvanR: exercise: try it :)
14:58:43 <lambdabot>  ()
14:59:14 <EvanR> everybody loves graphs, if that works i would be the life of the party
14:59:16 <wespiser> hey guys, what are some good tutorials that need to be written for haskell libraries?
14:59:37 <wespiser> i'm trying to find a new project with a coding and communication component
15:01:18 <peddie> wespiser: the `ad` library could use a tutorial
15:01:49 <wespiser> oh, good point. I've seen a couple posts on that. 
15:01:57 <wespiser> peddie: thanks
15:02:07 <suzu> lens? :D :D :D :D: D:
15:02:55 <wespiser> It would be cool to combine `ad` with a linear regression function to get functionality similar to R
15:03:45 <dgpratt> not sure if lots of :D or lots of D:
15:03:51 <peddie> @hackage numerical-optimization-ad  -- wespiser 
15:03:51 <lambdabot> http://hackage.haskell.org/package/numerical-optimization-ad  -- wespiser
15:04:14 <peddie> @wespiser there are other libraries like `levmar` and `hmatrix-gsl` that could benefit from the same combination
15:04:14 <lambdabot> Unknown command, try @list
15:04:14 <wespiser> peddie: you mean: https://hackage.haskell.org/package/ad ?
15:04:20 <kuribas> Anyway to simplify this?  http://lpaste.net/348404
15:04:31 <peddie> wespiser: nope, I meant nonlinear-optimization-ad actually
15:04:37 <peddie> sorry, I mistyped the name
15:04:40 <wespiser> np
15:05:14 <wespiser> oh man, I haven't played with this stuff since grad school!
15:07:19 <peddie> wespiser: have fun, looking forward to seeing what you come up with :)
15:08:58 <wespiser> peddie: thanks, I'm in the scouting stage right now. Other ideas are a mandelbrot set generator using Repa, automated content extraction on webpages, or an LLVM backend to an interpreter project 
15:09:23 <EvanR> mandelbrot set using real numbers!
15:11:02 <wespiser> https://en.wikipedia.org/wiki/Mandelbrot_set#Escape_time_algorithm makes all the difference!
15:14:30 <wespiser> there's always the elusive, let's make ggplot2, grammer of graphics in Haskell
15:14:49 <wespiser> I've heard 3 or 4 people tell me about that in the last year
15:19:56 <suzu> okay so
15:19:58 <suzu> no joke
15:20:04 <suzu> gpg is fucking trash
15:20:24 <glguy> Nope nope nope, this channel is for discussion of Haskell
15:20:26 <suzu> it would be cool there were a project to put it to rest and make something way friendlier to use
15:20:31 <suzu> .. in haskell
15:20:35 <suzu> it'd be so good you couldnt ignore haskell.
15:20:43 <suzu> like xmonad
15:21:18 <kuribas> numerical code isn't safe in haskell either
15:21:27 <EvanR> itll be like, haskells, deadly app or something
15:21:37 <suzu> i'd say haskells deadly app at the moment is pandoc
15:21:38 <thomasd> Is there any way to force that a result from `parseJSON` has a `toJSON` constraint on it, and if not, then fail?
15:21:51 <Shockk> there's also git annex 
15:21:53 <suzu> :t parseJSON
15:21:55 <lambdabot> error: Variable not in scope: parseJSON
15:22:12 <suzu> oh i did not know git annex was in hs
15:22:22 <EvanR> not everyone likes git annex
15:22:27 <EvanR> so it cant be deadly
15:23:06 <suzu> thomasd you could write a function that has the constraint in it's type
15:23:14 <suzu> and so it'd be a type error should you use it incorrectly
15:23:27 <thomasd> suzu: well, that's the problem
15:23:33 <thomasd> I get a type error 
15:23:40 <suzu> then.. it's working. no?
15:23:50 <thomasd> well, I want it to fail at runtime, not compile time
15:23:59 <thomasd> having trouble figuring out how to specify this in the type system
15:24:01 <suzu> there's a compiler flag that can do that
15:24:07 <suzu> but its not what you want
15:24:07 <Koterpillar> thomasd: -defer-type-errors, or make a typeclass with a default instance that errors out
15:24:12 <suzu> yeah ^ defer type errors
15:24:24 <suzu> thomasd what are you /actually/ trying to do?
15:24:36 <thomasd> I have a constructor:
15:24:47 <thomasd> QId :: ToJSON a => a -> Query f a
15:25:00 <thomasd> now, I'm writing a FromJSON instance for Query f a
15:25:18 <thomasd> oh, Query f a is a GADT
15:25:30 <thomasd> so, I'm doing something like
15:26:26 <thomasd> getting the tag from the object value, like `parseJSON o = do { val <- tag .: o ... }
15:26:32 <thomasd> the tag is a string
15:26:38 <thomasd> that determines the constructor
15:26:48 <thomasd> then I do a case match on constructor names
15:26:52 <thomasd> so then I have
15:27:07 <thomasd> "QId" -> Qbox . QId <$> parseJSON val
15:27:35 <thomasd> Qbox :: ToJSON r => Query f a -> Qbox (because you can't return something polymorphic from parseJSON
15:27:41 <suzu> so similar to how the To/FromJSON typeclasses are autoderived
15:27:47 <suzu> for GADTs
15:27:55 <thomasd> yes
15:28:03 <thomasd> turns out, I'm using TH ;)
15:28:06 <thomasd> but writing by hand first
15:28:20 <suzu> and so
15:28:22 <thomasd> can't get hand written to typecheck
15:28:26 <suzu> you dont want to use a constructor
15:28:30 <suzu> that doesnt have a ToJSON here
15:28:35 <suzu> you want to throw an error or something
15:29:09 <thomasd> well, I want to force the constraint that the resulting "a" from (parseJSON val :: Parser a) has an instance of ToJSON
15:29:19 <thomasd> because typechecker complains that it doesn't
15:29:50 <suzu> are you saying the typechecker is wrong in this case?
15:29:58 <thomasd> see my problem? like, how do I say that "parseJSON should only succeed if the resulting "a" type has ToJSON instance"
15:30:05 <thomasd> no, typechecker is correct
15:30:13 <thomasd> I just don't know how to write it
15:30:28 <suzu> you could write your own typeclass, perhaps
15:30:34 <ab9rf> thomasd: how would parseJSON have a type that is not a ToJSON instance?
15:30:55 <thomasd> suzu: because of that "QId :: ToJSON a => a -> Query f a"  ToJSON constraint
15:31:11 <thomasd> ab9rf: FromJSON instance does not force ToJSON instance
15:31:16 <suzu> perhaps you could try
15:31:19 <thomasd> you can define FromJSON without ToJSON
15:31:31 <ab9rf> thomasd: the type of a function can only have one type.
15:31:37 <suzu> QId :: (ToJSON a, FromJSON a) => a -> Query f a
15:31:43 <ab9rf> sorry, the return value ofa  function can only have one type
15:31:43 <suzu> if im understanding this correctly
15:31:49 <thomasd> suzu: I have tried that XD
15:31:54 <suzu> i figured you did
15:31:56 <suzu> so why doesnt that owrk?
15:31:58 <suzu> work *
15:32:32 <thomasd> suzu: look at this:
15:32:42 <thomasd>         Could not deduce (ToJSON a) arising from a use of ‘parseJSON’
15:32:46 <thomasd>         from the context (ToJSON a1, FromJSON a1)
15:32:47 <thomasd> lol
15:32:58 <ab9rf> you cannot write haskell code that returns one type with some inputs, and a different type with other inputs
15:33:10 <suzu> that's not what he's asking for ab9rf 
15:33:13 <suzu> umm
15:33:19 <thomasd> yeah, tricky :/
15:33:22 <suzu> well
15:33:25 <ab9rf> suzu: that's what it feels like
15:33:29 <suzu> maybe you are wrong thomasd 
15:33:37 <suzu> and you actually dont have a ToJSON here
15:33:39 <suzu> :P
15:33:43 <suzu> double check?
15:33:45 * suzu shrugs
15:33:49 <ab9rf> you want parseJSON to return a variably-typed object based on the string parseJSON is asked to parse
15:34:02 <thomasd> I tried a `instance (FromJSON a, ToJSON a) => FromJSON Qbox` with ScopedTypeVariables
15:34:17 <thomasd> and then explicit type annotations in body
15:34:23 * hackagebot csound-expression-dynamic 0.2.0 - dynamic core for csound-expression library  https://hackage.haskell.org/package/csound-expression-dynamic-0.2.0 (AntonKholomiov)
15:34:25 * hackagebot csound-expression-typed 0.1.0.0 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.1.0.0 (AntonKholomiov)
15:34:27 * hackagebot csound-expression 5.1.0 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-5.1.0 (AntonKholomiov)
15:34:29 * hackagebot csound-sampler 0.0.7.0 - A musical sampler based on Csound  https://hackage.haskell.org/package/csound-sampler-0.0.7.0 (AntonKholomiov)
15:34:34 <thomasd> sorry, stick a "forall a." infront of the To/FromJSON qualifiers
15:35:03 <thomasd> ab9rf: I want parseJSON to return a `Parser a`, yes
15:35:05 <thomasd> BUT
15:35:14 <thomasd> I want to say that the 'a' must have ToJSON instance
15:35:30 <codygman> ertes or anyone else that knows about rapid, are you meant to write your development code within the rapid block? I notice that "value" isn't in scope automatically and I don't see a way to "get" it from my library code. I'm guessing you develop your library code and then put the invocation within the rapid block?
15:35:58 <ab9rf> so parseJson :: (ToJSON a) => (...) -> Parser a
15:36:05 <thomasd> suzu: what do you mean I might not have a ToJSON?
15:36:18 <ab9rf> where (...) is whatever parseJson takes as input, a bytestring or something i guess
15:36:19 <suzu> that error you posted
15:36:24 <suzu> do you have more lines of it?
15:36:45 <thomasd> yeah, it says type var 'a' is ambiguous
15:36:52 <thomasd> and that there are many potential instances
15:36:53 <suzu> in what context?
15:37:22 <thomasd> in the context of the body of FromJSON instance, parseJSON function
15:37:33 <suzu> can you paste the whole error
15:37:42 <ab9rf> lpaste please
15:37:43 <thomasd> hmmm, can I do it without line by line?
15:37:45 <thomasd> yes
15:37:46 <suzu> lpaste
15:37:50 <suzu> in the topic
15:39:23 * hackagebot csound-catalog 0.6.0 - a gallery of Csound instruments.  https://hackage.haskell.org/package/csound-catalog-0.6.0 (AntonKholomiov)
15:39:25 * hackagebot aeson-filthy 0.1.1 - Several newtypes and combinators for dealing with less-than-cleanly JSON input.  https://hackage.haskell.org/package/aeson-filthy-0.1.1 (AlecHeller)
15:39:53 <thomasd> wait... perhaps I figured it out
15:40:07 <thomasd> give me few mins. thanks for listening to my problem :)
15:40:31 <suzu> :)
15:42:44 <sbidin> Is Cai Lei, github.com/ccll, author of `sdl2-image`, perhaps here?
15:44:16 <ertes> codygman: you can either do that, or you can use 'rapid' on the fly
15:44:24 * hackagebot pandoc 1.19 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.19 (JohnMacFarlane)
15:44:32 <codygman> ertes: oh, so with a rapid block I can use "value"
15:44:57 <ertes> codygman: you can return the value from the rapid block, too
15:45:00 <codygman> ertes: actually I think I'm not quite sure how you mean I can use rapid on the fly. Is it because createRef only creates if it doesn't exist?
15:45:18 <ertes> codygman: yeah
15:45:18 <codygman> ertes: To be clear I'm using rapid to load an expensive resource
15:45:29 <codygman> ertes: Okay, I think I understand
15:45:30 <shapr> sbidin: do you have a particular question?
15:46:55 <sbidin> shapr: I've been trying to contact him for the last month with regards to updating the outdated `sdl2-image` on Hackage. Details here: https://github.com/sbidin/sdl2-image/issues/3
15:47:04 <ertes> codygman: yeah, i remember your use case…  if you use the value mainly on GHCi, you can just use 'rapid' there to access the value (or put a little helper action in the dev module)
15:47:49 <thomasd> suzu: still there/
15:48:23 <codygman> ertes: Alright cool, thanks for the help.
15:48:31 <codygman> and thanks for rapid ;)
15:48:45 <ertes> glad you find it useful =)
15:50:55 <ertes> codygman: i don't encounter your use case a lot in my own development, so if there is something you would like to have in rapid, just create a feature request, or even just write the code and send a patch/PR
15:51:26 <ertes> the rapid code is very simple, so it's easy to get into
15:51:34 <buttbutter> What's that GHCI option again that allows you to load a module even if there are errors (so you can access types, etc)?
15:51:48 <codygman> buttbutter: :set -fdefer-type-errors
15:52:27 <codygman> ertes: Alright. I will if I can. I know if Haskell becomes popular for data science then an easy way to use rapid to cache expensive resources will be very valuable.
15:52:32 <buttbutter> codygman: Thanks! :)
15:52:43 <codygman> np buttbutter :)
15:54:02 <suzu> thomasd yeah on and off
15:54:04 <suzu> sup
15:54:24 * hackagebot rerebase 1.0.1.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.0.1.1 (NikitaVolkov)
15:54:36 <thomasd> suzu: well, I was reducing the code as much as I could when talking about it here
15:54:44 <thomasd> but I'm afraid if I give you a gist it will be overwhelming
15:55:19 <thomasd> so, no worries, I'll try to figure it out
15:56:09 <suzu> kk
15:56:34 <lpaste> xcmw pasted “Are there any downsides to using GADTs as records?” at http://lpaste.net/348411
15:56:34 <glguy> xcmw: Hello, you around?
15:56:48 <xcmw> glguy: Yes
15:57:06 <lpaste> glguy annotated “Are there any downsides to using GADTs as records?” with “relevant?” at http://lpaste.net/348411#a348412
15:57:32 <glguy> I made that last night around the time you left and I thought it possible you'd find it interesting
15:58:18 <grazie> Is there a way to skip all breakpoints in ghci and run program or do I have to delete each one and hit :continue
15:59:57 <xcmw> glguy: Thank you. It is interesting. I will look at the differences between yours and mine.
16:05:43 <xcmw> glguy: Does what you wrote have any advantages over what I posted?
16:06:24 <jchia_> In my stack.yaml, I'm using packages off of github and in my project cabal, I specify certain extensions for certain libraries. I'm getting ghci errors when I start it. Why does ghci care about the extension for my library when it tries to build some package from github source? How do I fix the problem? http://lpaste.net/348414
16:06:54 <jchia_> ghci fails to build the the github packages
16:08:07 <MarcelineVQ> jchia_: those pckages should probbaly have   extra-dep: true under them so stack knows they're not really part of your project
16:10:06 <MarcelineVQ> those seem like reasonable warnings for ghci though
16:10:30 <lpaste> MarcelineVQ annotated “stack.yaml "packages" vs cabal "default-extensions"” with “stack.yaml "packages" vs cabal "default-extensions" (annotation)” at http://lpaste.net/348414#a348415
16:10:45 <jchia_> MarcelineVQ: Thanks, that fixed the problem.
16:10:48 <MarcelineVQ> awesome
16:26:06 <xcmw> Is there away to write data AField = X | Y | Z without creating without creating value level X, Y, Z and type level AField?
16:27:18 <xcmw> Just creating kind level AField and type level X, Y, and Z
16:57:05 <hololeap> when is implementing Monoid more useful than implementing (someFunc :: a -> a -> a) and using someFunc/(foldr1 someFunc) instead of mappend/mconcat?
16:57:18 <erisco> Int can be unboxed. Can a pair of Ints be unboxed?
16:57:50 <hololeap> erisco: who are you asking
16:57:56 <erisco> #haskell
16:58:02 <hololeap> oh
16:58:37 <hpc> asking the hard questions ;)
16:58:58 <hpc> erisco: do you mean does there exist a function (Int, Int) -> UnboxedTupleOfSomeSort Int# Int#?
16:58:58 <Squarism> erisco, what class accomplishes unboxing?
16:59:06 <hpc> or something generic?
16:59:20 <hpc> because there's (# #)
16:59:30 <hpc> which is a bit quirky
16:59:32 <suzu> hololeap: well you can use things that need monoids if you have a monoid
16:59:49 <hololeap> suzu: can you give me a good example of one?
16:59:51 <erisco> something you can stick in an unboxed array
17:01:16 <kuribas> erisco: you can have an unboxed vector
17:01:39 <erisco> is the vector itself unboxed?
17:01:54 <kuribas> erisco: no, the elements
17:02:16 <kuribas> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html
17:02:19 <erisco> I am seeing that the answer is "no"
17:02:23 <suzu> hololeap well for instance, Monoid b => Fold a b
17:02:43 <erisco> the language is clumsy with memory layouts then
17:02:55 <suzu> so you can use sum / maximum / minimum / minimumBy , etc
17:03:03 <kuribas> erisco: why would the vector be unboxed?
17:03:07 <suzu> find, index, elem
17:03:16 <erisco> I am asking for an unboxed pair of Ints
17:03:49 <erisco> struct A { int x; int y; }
17:04:49 <kuribas> erisco: at least say why you need it
17:05:01 <erisco> memory locality
17:05:04 <hololeap> suzu: that's lenses, which i know nothing about
17:06:08 <kuribas> erisco: then use unboxed vectors.
17:06:45 <erisco> that isn't what I am asking for
17:06:49 <kuribas> erisco: if you need speed, you can use mutable vectors, in the st-monad 
17:07:18 <kuribas> erisco: memory locality isn't something that you usually have to worry about.
17:10:36 <erisco> I can jam stuff into a large word, and that is the best I can seem to do
17:11:28 <kuribas> erisco: lazyness comes with a price.
17:11:28 <nshepperd1> You can stick tuples in unboxed vectors. But they're represented as (vector a, vector b)
17:12:15 <erisco> yes, but when you want to iterate on the pairs they are not local
17:12:57 <erisco> presumably is a bit of compiler that hasn't been done to support this
17:14:21 <jmcarthur> erisco: Just use Storable if you want array-of-structs instead of struct-of-arrays
17:15:25 <erisco> meh, so it copies the data to a new location on a heap? defeats the point of it
17:15:43 <jmcarthur> ?
17:16:37 <erisco> the data is stored in a way such that Haskell does not understand it
17:16:54 <erisco> so you're going to have to copy the data to a new structure which it does understand
17:17:20 <jmcarthur> Inlining will often eliminate that allocation.
17:18:34 <jmcarthur> Well, this may not be as true for reading from ptrs as for other kinds of operations... I've been meaning to better understand what optimizations apply in this area.
17:19:54 <jmcarthur> I also misstated; I meant that optimizations that apply *after* inlining can eliminate a lot of these allocations.
17:28:17 <Squarism> Im curious what you people are working on - discussing all these nisched matters. 
17:29:05 <amx> https://www.youtube.com/watch?v=A9aDSRufG7g
17:29:10 <amx> sorry, wrong window
18:06:46 <jchia> stack build question: I have some "extra-dep" github package in my stack.yaml that needs a .so file that I've installed in a non-standard location (/opt/llvm/lib/libclang.so.3.9), so build fails. I'm thinking that passing -optl-Wl,-rpath=/opt/llvm/lib to ghc may help. How do I write my stack.yaml or .cabal file so that ghc get that option?
18:08:42 <jchia> I think stack.yaml has a ghc-options. I'm going to try that
18:50:40 <SteinsGate[m]> Hahaha
18:58:34 <dfeuer> xcmw, no, I'm pretty sure that's not possible.
18:59:15 <dfeuer> xcmw, it *might* work to define the kind in a separate module and export it with the type keyword.
19:03:32 <dfeuer> xcmw, actually, that doesn't seem to work.
19:38:24 <dfeuer> Has anyone seen cmccann this year? Is he still around?
19:43:47 <chachi> I'm working on the NICTA course, and managed to do something strange.  When I do "sequence (Full 7 :. Full 8 :. Full 9 :. Nil)", I get Full [7,8,9] as expected.  Then when I do parse (sequence (is 'a' :. is 'b' :. is 'c' :. Nil)) "abc", I get unexpected character 'a'.  When I try to parse "cba", I get the result I expected with "abc" -- in other words, my parser is running backwards from what I expected.  Any thoughts?
19:44:16 <dibblego> chachi: show your code to sequence please
19:45:29 <lordcirth> dibblego, what do you mean?
19:45:38 <chachi> foldRight (lift2 (:.)) (pure Nil) -- I wrestled with that and eventually probably lifted it from the answers. :)
19:45:45 <dibblego> lordcirth: I mean what I asked
19:45:51 <dibblego> chachi: that is a correct answer
19:46:07 <dibblego> chachi: please show your instance Applicative Optional
19:47:14 <chachi> pure = Full, (<*>) = applyOptional
19:47:35 <dibblego> ok, please show instance Monad Parser
19:47:41 <dibblego> the (=<<) implementation
19:48:19 <chachi> (=<<) = bindParser
19:48:28 <dibblego> show bindParser
19:50:19 <chachi> here's where it gets ugly.  bindParser f (P g) = P $ \i -> case g i of Result i' a' = parse (f a') i' (omitting the error case)
19:51:15 <dibblego> that looks fine
19:51:27 <dibblego> is your code on github somewhere?
19:52:25 <joe9> geekosaur: I can work around my earlier problem of multiple reads by having a cat from the 9pfs file to a named pipe and haskell read from the named pipe.
19:52:42 <chachi> No.  I'm considering downloading again and working through these parts -- clearly some repetition would do me good anyway.
19:53:13 <dibblego> chachi: that is common for NICTA/course, but finding your bug is also helpful
19:53:35 <joe9> geekosaur: I think the GHC IO manager treats pipes differently from files.
19:54:08 <joe9> geekosaur: or, if not, the GHC IO manager is dealing with a linux mechanism instead of a 9pfs object.
19:56:15 <chachi> dibblego: Yeah, I ran into a problem previously that was user error, and have already started again from scratch once.  I got a lot further this time. :)  This one seems like a real head-scratcher to me, i.e. good learning opportunity.  Given that we've already looked at a few things and nothing obvious jumped out, I'll do that unless you have other suggestions.
19:56:39 <dibblego> chachi: in which city do you reside?
19:57:00 <chachi> Cleveland, USA
19:57:26 <dibblego> ok, coming to .au any time soon? :)
19:57:33 <dibblego> we run the course (for free) regularly
19:57:45 <chachi> dibblego: I wish.  Do you ever stream or record it?
19:58:11 <dibblego> I have once, and with someone familiar with the course helping on the other end
20:00:18 <chachi> dibblego: Not sure what video production costs, but it's less than a flight to Australia for something low-end.  I might be interested in helping to fund a video for Youtube posterity if that's of interest to you guys.
20:00:37 <dibblego> it is, but I would need someone on the other end to help out
20:00:48 <dibblego> tryin to think who lives in Cleveland
20:06:47 <chachi> dibblego: what do you mean by help out?  I have more patience than intelligence, so I am more than happy to rewatch where needed.
20:07:05 <dibblego> I mean someone who knows all the traps in the coure
20:07:15 <dibblego> so that I don't have to debug remotely, like I am doing now :)
20:07:22 <dibblego> if I saw your code, I'd find the bug in 3 seconds
20:07:44 <amx> my god, I just realised ScopedTypeVariables needs ExplicitForAll
20:20:43 <martinium> can you use the range operator ".." outside of a list in haskell?
20:21:12 <martinium> I want to specify a number range from 1..300 and assign to a variable
20:21:43 <MarcelineVQ> what's the type of a number range?
20:22:16 <martinium> 1..300
20:22:34 <martinium> I want them to be Double precision if possible
20:23:24 <Koterpillar> martinium: what do you want to do with this value later?
20:23:49 <Koterpillar> martinium: data Range a = Range { rangeMin :: a, rangeMax :: a }
20:24:18 <martinium> I created a fahrenheit to celsius calc in Rust and am trying to learn haskell and figured it would be good practice
20:24:55 <martinium> well not calc but its a app that lists them in columns with the corresponding values etc
20:29:17 <chachi> dibblego: Fair enough.  I'd put my code on Github but you would definitely regret it.  :)  This won't be the last time I bang my head, certainly not the first.  Thanks again for your help, and for writing the course.  It may not be super-visible to you, but I'm learning a lot from it. 
20:29:38 * hackagebot itemfield 1.1.0.1 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.1.0.1 (KevinQuick)
20:31:03 <exio4> chachi: naw! don't be scared to put your code online
20:31:56 <dibblego> chachi: I bet I've seen worse
20:32:52 <chachi> dibblego: I'm not a programmer so I didn't expect you'd be willing to look at it.  I'm more than happy to put it up there, I just don't want to abuse your hospitality.
20:33:38 <exio4> if you wanna see worse code, I can just link you to my github ;)
20:35:23 <dibblego> chachi: it's fine
20:46:41 <glguy> martinium: No, you can't take the .. out of [_ .. _]
20:47:04 <martinium> glguy so it has to be in a list
20:47:15 <martinium> got it
20:47:17 <glguy> but you can use ... or whatever else you might want
20:47:28 <martinium> ... as in 3 dots?
20:47:35 <martinium> is that another operator
20:48:05 <glguy> Yeah, most arrangements of symbols are available for you to define, like (...)
20:48:45 <glguy> > let x ... y = "from " ++ show x ++ " to " ++ show y in 5 ... 10
20:48:48 <lambdabot>  "from 5 to 10"
20:49:32 <martinium> interesting
20:50:25 <martinium> in the imperative program I wrote I have  a while loop that goes through the conversion from 0 through 300
20:50:57 <martinium> using a \t I have a second column for the temp conversion and it displays vertically
20:51:58 <martinium> so far I have the heading the same way in haskell but am trying to rap my head as to how to iterate the range for it to appear in that order vertically or if that doesn't matter and can be horizontal also
20:52:17 <nshepperd> martinium: some other languages have a special type for "ranges" that is distinct from lists. is that what you are talking about? in haskell we just use a list, because the compiler is smart enough to optimise it into whatever the special "range" type would have done anyway
20:53:05 <martinium> in the previous lang I am trying to convert the small program from I use a while loop to iterate the values and calc
20:53:27 <martinium> maybe I should post it to gist
20:54:46 <martinium> https://gist.github.com/martinium/09d4564efde104ab646a9db11af2c6ee
20:54:54 <martinium> this is code I am trying to convert
20:58:35 <brunofp> why is it called haskell
20:58:44 <johnw> it's named after Curry Haskell
20:58:54 <johnw> originally the name they thought of was Curry, but there were obvious problems...
20:59:04 <johnw> sorry, Haskell Curry
20:59:16 <pikajude> haskell is apparently an actual name
20:59:20 <johnw> https://en.wikipedia.org/wiki/Haskell_Curry
20:59:21 <pikajude> that's what I'm gonna name my kid
20:59:27 <brunofp> i never bothered to learn this language
20:59:30 <brunofp> but i should right?
20:59:37 <johnw> well, of course _we_ think so
20:59:38 <brunofp> it sounds like hassle to me
20:59:44 <johnw> now go ask in #javascript
20:59:52 <brunofp> but i'm not trolling 
20:59:57 <pikajude> yeah, they'll tell you to learn haskell too
21:00:03 <brunofp> i'm just giving you my brutally honest answer
21:00:06 <johnw> if you're interested learn it; otherwise, learn something more useful to you
21:00:17 <pikajude> learning haskell is quite complicated so be prepared
21:00:37 <brunofp> is it complicated like php?
21:00:49 <pikajude> no. is PHP complicated?
21:00:59 <brunofp> php is complicated
21:01:13 <pikajude> ok, we may be operating under different definitions of complicated
21:01:36 <johnw> :)
21:01:41 <johnw> complicated vs. complex
21:01:53 <pikajude> pshh
21:01:55 <nshepperd> martinium: so you want a table with two columns, fahrenheit and celsius? a good intermediate step there would be a list of pairs of Doubles (fahrenheit, celsius) representing each row
21:03:19 <martinium> nshepperd yeah table with two columns
21:03:25 <nshepperd> [(0, -17.7), (1, -17.2), ...]
21:03:48 <martinium> I want the program to do the conversion just like in the above gist
21:03:50 <nshepperd> then you can format each row as a string separately with map
21:04:20 <martinium> I am basically trying to see what that program looks like in haskell as I am still learning
21:04:54 <lpaste> glguy pasted “for martinium” at http://lpaste.net/348462
21:05:00 <glguy> It could look like that
21:05:40 <brunofp> stupid question but what do people use haskell for usually?
21:06:00 <nshepperd> oh yeah, glguy's version is a more direct conversion of the imperative program
21:06:10 <systemfault> brunofp: It's a general purpose language... but seems to be somewhat popular for web services
21:06:11 <nshepperd> you can iterate over a list imperatively with for_
21:06:39 <brunofp> systemfault: please don't call me a troll, but why use haskell when node.js exists?
21:06:52 <brunofp> i'm a novice developer who has a lot to learn
21:06:54 <monochrom> No, why use node.js when Haskell exists?
21:07:18 <systemfault> brunofp: Why, nodejs has pretty much no advantage over anything... except perhaps PHP
21:07:24 <martinium> glguy thanks. I wanted to see how it would look and that does the trick
21:07:33 <brunofp> monochrom: i think because so you don't have to learn other languages as you can do javascript for everything
21:07:34 <johnw> brunofp: I use Haskell for most things
21:07:38 <nshepperd> why use X when Y exists!
21:07:44 <systemfault> brunofp: When JavaScript was created, it was basically ignored for 10 years before people started using it.
21:07:46 <martinium> I may have tainted my brain by learning some basic imperative concepts
21:07:51 <glguy> Haskell's good for prototyping and experimentation, the type system helps make it easy to refactor my code as requirements change and we learn more about the problem
21:07:53 <exio4> brunofp: i am more productive with haskell, therefore i use haskell.
21:08:32 <monochrom> Javascript has its pros and limitations. I want to learn Haskell for a complement.
21:08:46 <brunofp> i'm interested in learning this language because i think it will make me more impressive as a job candidate and a human being, but now that i know what it's generally used for i can start gearing my thinking towards making those types of applications
21:09:35 <brunofp> i don't really like javascript all that much mostly because i don't know it very well
21:10:17 <monochrom> I hate stereotyping programming languages like this.
21:11:11 <monochrom> In the #benedict-cumberbatch channel, a beginner enters and ask, "What is Cumberbatch used for? Shakespean stuff?"
21:11:38 <monochrom> And yet Cumberbatch just did a commercial Marvel movie, and beautifully.
21:12:22 <kadoban> Was that any good? The trailers looked interesting
21:12:31 <monochrom> Yes. IMO anyway.
21:12:33 <brunofp> stereotyping a language gives you a great starting off point and when you master the language you can do other stuff too and see its limitations... i'm not quite there yet
21:12:45 <kadoban> Cool. He should do more sherlock though, heh.
21:13:30 <monochrom> I agree to disagree.
21:14:54 <monochrom> (About stereotyping being a great beginning. Of course Cumberbatch should do more everything.)
21:15:17 <JuanDaugherty> is it like a man crush or wat?
21:15:36 <monochrom> what is man crush?
21:15:38 <chachi> dibblego: I have pushed my broken code to https://github.com/HaskellOpenBSD/NICTA.  Unfortunately I have to go to bed as it's midnight here.  Any suggestions would be very much appreciated, and by all means when you've had enough of my questions don't hesitate to let me know.  Thanks again, I very much appreciate it.
21:15:54 <JuanDaugherty> cumberb*tch
21:16:34 <monochrom> I don't understand. Nevermind.
21:16:54 <JuanDaugherty> (didn mean just you, but generally)
21:17:50 <JuanDaugherty> baritone igess
21:22:56 <martinium> glguy I get a compile error when I try to compile with GHC
21:23:00 <martinium> for the example
21:23:04 <martinium> parse error
21:23:50 <martinium> actually nevermind found the problem
21:24:41 * hackagebot itemfield 1.1.0.2 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.1.0.2 (KevinQuick)
21:27:22 <Guest82498> I'm getting the following error when "stack build" attempts to build http-api-data-0.2.4:
21:27:24 <Guest82498>  Module Distribution.Package does not export PackageName(PackageName)
21:28:07 <Clinton_> I suspect this has something to do with cabal but I'm not sure how to fix it
21:28:15 <Clinton_> it's unusual because stack usually works magically
21:44:41 * hackagebot itemfield 1.2.0.0 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.2.0.0 (KevinQuick)
21:53:57 <mbuf> Is there a way to do test finite state machine using QuickCheck?
22:18:25 <fikse> the first example at https://wiki.haskell.org/Foldr_Foldl_Foldl' states that evaluating try1 will fail with a stack overflow, but in ghci, it computes 500000500000
22:18:42 <fikse> something has changed since the writing of that article it seems
22:18:45 <EvanR> yes
22:18:53 <EvanR> the default stack size has been increased a lot
22:19:12 <EvanR> but it can be manually changed back to small to detect "bugs"
22:26:50 <yootis> If I install something in ~/.cabal with cabal install, what paths do I need to set in order to use it?  is there anything else special I need to do?
22:27:49 <yootis> I'm trying to use ihaskell, but the kernel dies a few seconds after I open the window.
22:30:57 <yootis> Anyone have experience with ihaskell?  The jupyter/ipython module?
22:38:52 <fikse> yootis: are there any errors in your console?
22:39:59 <yootis> ihaskell: /home/matt/.cabal/lib/x86_64-linux-ghc-7.10.3/cryptonite-0.20-3GlBmd19Ac6HL22WzgQpUI/libHScryptonite-0.20-3GlBmd19Ac6HL22WzgQpUI.a: unhandled ELF relocation(RelA) type 42  ihaskell: ihaskell: unable to load package `cryptonite-0.20'
22:41:03 <yootis> I'm new to Haskell, so I don't really know my way around Cabal.  It doesn't behave like I expect it to :)
22:41:43 <fikse> yootis: which operating system are you on?
22:41:58 <yootis> Fedora 25
22:42:45 <fikse> i don't use iHaskell, but looking at the readme, i'd personally go with the docker installation since it's almost guaranteed to work
22:43:42 <yootis> fikse: the docker install has other issues, unfortunately.
22:44:20 <fikse> i don't actually know which problems you're experiencing
22:44:30 <fikse> you don't know where executables are located?
22:44:44 <yootis> But I think my issue is actually more general.  Any cabal thing I install doesn't work.
22:44:53 <fikse> hah :)
22:45:18 <fikse> yootis: stack does resolve some of the circulard dependencies which cabal might not be able to resolve
22:45:36 <fikse> looking at iHaskell's readme, there's a command for installation with stack. have you tried that?
22:46:04 <fikse> "circular dependencies" probably isn't the correct term
22:46:23 <yootis> for example, I have cabal from an rpm, version 1.22.  I did "cabal install Cabal", and it builds cabal 1.24.  But when I run cabal --version, it still gives me version 1.22
22:46:50 <yootis> Not sure how to install stack.  
22:47:53 <yootis> Cabal seems like "pip --user" for python, but pip just works. 
22:48:19 <fikse> yootis: sounds like you don't have cabal in your PATH
22:48:22 <fikse> https://docs.haskellstack.org/en/stable/README/#how-to-install
22:49:12 <glguy> yootis: When you install a new version of Cabal, you're installing a library. That doesn't affect the executable you're running if you don't recompile the executable against the new library
22:49:27 <glguy> The "cabal" executable comes from the "cabal-install" package
22:51:04 <yootis> ok.  Running "cabal install Cabal-install" now...
22:51:22 <glguy> cabal-install isn't capitalized
22:53:01 <yootis> well, that built it...  
22:53:02 <yootis> Building cabal-install-1.24.0.1... Installed cabal-install-1.24.0.1 [matt@matt-laptop ~]$ cabal --version cabal-install version 1.22.9.0 using version 1.22.5.0 of the Cabal library 
22:53:42 <glguy> It installs into your home directory, so you'll need to update your PATH variable if you want it to be in your path
22:54:10 <haskell361> is there a fancy type to express a value that is necesseraly inside a range, other than LiquidHaskell?
22:54:13 <glguy> The default is ~/.cabal/bin
22:54:32 <yootis> I think this is all a path issue.  I set the .cabal/bin directory in my path, but the libs in .cabal don't seem to get found
22:54:56 <glguy> libraries are a separate question from executable search path
22:55:40 <glguy> and it matters that the $HOME/.cabal/bin appears before wherever the previous cabal executable was installed. Additionally bash (and other shells) cache executable paths
22:56:07 <glguy> so if you installed it into a directory different from the one you were using even if the new one is leading in the search path, bash can keep using the old one
22:56:23 <glguy> In bash you can reset that with: hash -r
22:56:36 <yootis> You're right about the order of the path, my bad.  Now I get the new version of cabal running.  But even with the path set, the ipython kernel still dies because it can't run cryptonite
22:58:23 <yootis> I'm running the stack install in parallel.  It is making me install ghc 8.0.1
23:01:21 <yootis> stack is generating all sorts of exceptions.  It basically says the version of ghc is too new, but it just forced me to get the new version...
23:02:31 <lpaste> glguy pasted “simple program that uses kryptonite” at http://lpaste.net/348498
23:02:52 <glguy> yootis: You could try building this simple program that uses cryptonite to help pin down if it's a GHC issue or an iHaskell one
23:05:51 <yootis> ran it.  It prints "Tiger".
23:07:13 <glguy> Well, that means that your cryptonite install works at some level, obviously not a very interesting test case, but it's installed
23:11:45 <yootis> Weird.  I checked and the version of cryptonite installed is the same (0.20).  Maybe that library just isn't found by the ihaskell kernel, which leads me back to the library search path.  
23:34:18 <joe9> http://codepad.org/7iHcUY0l code, output: "Wed, 17 Nov 1858 00:00:00 UTC"
23:34:40 <joe9> anyone knows if there is a haskell constant for 1970-1-1, I think this is the unix epoch
23:36:07 <systemfault> I'd probably try 0 :/ (I'm a date/time noob)
23:36:41 <joe9> got it: https://github.com/haskell/time/blob/52e0f5e85ffbaab77b155d48720fb216021c8a73/lib/Data/Time/Clock/POSIX.hs#L36
23:38:25 <systemfault> Nice :)
23:51:12 <bolly> hey all
