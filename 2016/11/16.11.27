00:07:42 * hackagebot hamilton 0.1.0.0 - Physics on generalized coordinate systems using Hamiltonian Mechanics and AD  https://hackage.haskell.org/package/hamilton-0.1.0.0 (jle)
00:07:42 * hackagebot aivika-distributed 0.3 - Parallel distributed discrete event simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-distributed-0.3 (DavidSorokin)
00:24:23 <ertesx> so many authors use the word "interestingly" when they mean "inconsistently"
00:26:41 <tsahyt> Hello! I'm implementing an algorithm that mutates a graph structure in memory, which is represented with pointers in the original (C++) code. I've tried mapping this onto tables that I can "mutate" (State monad) without having to resort to actual mutability, but that's not particularly fast as I lose quite a lot of time doing the lookups. Is there any better way to do this than resorting to ST?
00:28:39 <tsahyt> tying the knot doesn't seem to work that well when everything hinges on mutability
00:29:50 <alexknvl> tsahyt: You might want to take a look at https://hackage.haskell.org/package/fgl
00:29:57 <tsahyt> I've tried doing it with fgl, it's hopelessly slow
00:30:39 <ertesx> tsahyt: what's the type of your tables?
00:30:41 <tsahyt> the graph structure is implicit to the data, and making it explicit unfortunately comes at a cost
00:31:10 <tsahyt> ertesx: used to be IntMaps, but I'm trying to do away with the integer based references as well
00:31:50 <ertesx> tsahyt: well, there is no concept of identity for haskell values, so if you want to get the speed of pointers, you will have to use actual pointers and therefore use IO
00:32:11 <benzrf> j
00:32:13 <tsahyt> doesn't ST have something that is analogous?
00:32:15 <ertesx> tsahyt: another option is to use STRefs, which do have identity
00:32:15 <benzrf> crap
00:32:26 <tsahyt> ok, then at least I wasn't wrong about that
00:32:37 <alexknvl> tsahyt: https://wiki.haskell.org/The_Monad.Reader/Issue5/Practical_Graph_Handling
00:32:49 <osa1> I'm not sure you could use pointers even if you had access to them as the GC moves values
00:33:47 <tsahyt> I think using ST will also save me from the headaches I got last time trying to shoehorn this algorithm into a more functional approach
00:34:45 <ertesx> osa1: there is a difference between the memory area pointed to by a Ptr (as e.g. allocated by 'alloca') and the value that you get from 'peek'
00:35:04 <tsahyt> ertesx: so if I create an STRef, and pack it into two different records, that's still the same STRef, i.e. when I change data behind one, the data behind the other one also changes?
00:35:05 <ertesx> semantically 'peek' really gives you a *copy* and, that one can be moved by GC
00:35:13 <ertesx> -,
00:35:31 <alexknvl> tsahyt: yes
00:35:31 <osa1> thallada: yes
00:35:43 <tsahyt> good, I think I can make this work then
00:36:00 <ertesx> tsahyt: one caveat though: STRef stores boxed values
00:36:37 <tsahyt> that one layer of indirection should still be faster than traversing a tree to find my data though
00:37:45 <alexknvl> tsahyt: you can think of STRef as a unique pointer (a number) and ST as a monad that keeps a table of all valid pointers and their values
00:38:34 <tsahyt> seeing as I essentially implemented a (bad) number based reference system over IntMaps myself, I think ST kinda makes sense
00:38:44 <ertesx> tsahyt: it the C++ code actually uses standard 'new' (or malloc), then there is a good chance that your haskell version with STRef gets close to C++ performance, because both will be rather cache-missy
00:39:10 <ertesx> if you want to optimise for cache usage you should work with mutable vectors
00:39:20 <tsahyt> it allocates everything in advance, and no new data is allocated during execution of the algorithm
00:39:37 <ertesx> oh!
00:39:43 <ertesx> so the graph doesn't actually change?
00:40:09 <tsahyt> it does change, but what changes are edges between nodes and some labels.
00:41:01 <tsahyt> and the edges aren't explicitly allocated. they exist by virtue of a pointer from one node to its predecessor
00:41:02 <ertesx> well, in that case a mutable vector may actually be a good idea, depending on the algorithm…  for example a connectivity matrix
00:41:13 <ertesx> how many vertices do you have?
00:41:20 <tsahyt> potentially 10s of thousands
00:41:53 <ertesx> well, if you use a matrix and your graph is directed, then every edge takes 1 bit
00:42:14 <ertesx> if it's undirected you need only 1/2 bits per edge
00:42:50 <ertesx> how densely is your graph connected on average?
00:43:46 <tsahyt> I don't think it's very dense
00:44:28 <tsahyt> I'm actually not sure if the edge count stays the same through all iterations
00:44:37 <tsahyt> I don't think it does though
00:47:24 <ertes-t6v> tsahyt: if you really want to optimise this (perhaps past the C++ program), you need more domain-specific information…  there are lots of considerations, and in fact at some point a tight linear search loop can be faster than a tree lookup
00:47:37 <ertes> it depends on many factors
00:49:29 <tsahyt> from a high level, it goes as follows. build an initial graph. then do two depth first explorations to determine a cut, i.e. a list of edges. now the topology is changed and then next iteration starts, until no more valid cut can be found. the tricky step is the updating of the topology. it's essentially a push style dynamic programming algorithm, which performs a forward exploration (sorta dijkstra like)
00:49:30 <tsahyt> and changes the graph as it goes
00:50:01 <tsahyt> becuase this needs quite a bit of associated information with each node and edge that it passes over, I don't think I get to win much from using a matrix to represent the graph, because I'll need to do a lot of lookups regardless
00:50:23 <tsahyt> i.e. I need to access and change that associated information with the nodes
00:53:03 <tsahyt> the depth first explorations are trivial. it's the updating step that is tricky.
01:15:18 <tsahyt> In the process of making my depth first search accept monadic successor functions, I noticed that it now is no longer tail recursive. i.e. before I had something like n : dfs (suc n ++ ns). now I need to use bind to get the recursive call and then patch it back together. Is there a way to make monadic functions like that tail recursive? or is this even an issue?
01:32:40 * hackagebot aivika 4.6 - A multi-method simulation library  https://hackage.haskell.org/package/aivika-4.6 (DavidSorokin)
01:32:42 * hackagebot aivika-transformers 4.6 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.6 (DavidSorokin)
01:37:40 * hackagebot aivika-realtime 0.1.2 - Soft real-time simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-realtime-0.1.2 (DavidSorokin)
01:43:54 <mpickering> What is the safe version of !! called?
01:45:15 <tsahyt> mpickering: there's atMay in the safe package
01:45:36 <tsahyt> also atDef for when you have a default value
01:46:42 <grantwu> Is it possible to have a heterogenous list where every value in the list has a type which is an instance of a particular typeclass?
01:46:56 <grantwu> say, a "list of showables"
01:47:19 <tsahyt> grantwu: you can use existential quantification for that
01:47:52 <tsahyt> e.g. data Showable = forall a. Show a => MkS a. Make that an instance of Show. now you can have a [Showable]
01:49:02 <tsahyt> I'm not sure whether GHC can derive the Show instance but it's not hard to write it by hand. show (MkS x) = show x
01:49:13 <cocreature> you could just as well call "show" when you put things in the list
01:49:30 <tsahyt> yes, that's the better option most of the time
01:50:03 <tsahyt> existentials cause all sorts of headaches down the line if you're not careful or you're trying to do anything non-trivial
01:50:32 <jle`> grantwu: it's possible, but it's probably not what you want
01:50:54 <grantwu> Yeah, I just did [show a, show b, show c]
01:50:58 <jle`> but yeah, a list of "anything as long as you know that it's showable" is pretty much the same as [String]
01:51:08 <cocreature> existentials are mostly useful if you can recover the type by pattern matching in a gadt. most other cases can be solved easier
01:51:19 <grantwu> It's probably not what I want for debugging
01:51:24 <jle`> because if the only thing you know about the thing is that it's an instance of Show, then the only thing you can do with it is 'show' it
01:51:30 <jle`> because of parametric polymorphism
01:51:34 <grantwu> Yeah
01:51:46 <grantwu> I was basically printing out the arguments of a function
01:51:49 <jle`> and also type erasure and fun stuff like that
01:51:54 <grantwu> well, not printing, but
01:52:04 <grantwu> applyBinop tag bo i1 i2 =     error $     "Bad applyBinop call: " ++ unwords [show tag, show bo, show i1, show i2]
01:52:26 <jle`> yeah, it is admittedly a little annoying
01:52:37 <jle`> hm
01:53:07 <jle`> there are some ways to make that a little nicer
01:53:15 <jle`> using type level trickery/hacks
01:53:25 <jle`> but overall not worth it if it's just for that specific case, heh
01:55:44 <tsahyt> grantwu: for that kind of trace debugging, there's Debug.Trace
01:55:59 <tsahyt> when you're done, just remove the import and GHC will tell you where you have to clean up
01:56:39 <grantwu> Meh, I'm not actually debugging per se, this is just a case that should be impossible and I wanted something sensible to put there
01:57:00 <tsahyt> right. impossible cases are one of the few valid use cases of error imo
01:57:02 <tsahyt> so that's fine then
02:10:51 <ertes> @let xs !!? n = foldr (const . Just) Nothing (drop n xs)
02:10:52 <lambdabot>  Defined.
02:11:20 <ertes> > iterate (2*) 1 !!? 16
02:11:22 <lambdabot>  Just 65536
02:11:40 <ertes> mpickering: ^ if you don't want a new dependency
02:12:10 <mpickering> I ended up actually needing "find"
02:13:38 <ertes> and i just found out that 'drop' is implemented recursively, so it probably wouldn't have fused with the foldr
02:15:28 <osa1> :t listToMaybe . drop 10
02:15:30 <lambdabot> [a] -> Maybe a
02:15:43 <ertes> seems like for some reason a lot of base list functions are implemented recursively, even things like 'iterate' and 'repeat'…  that's quite puzzling
02:17:29 <ertes> oh, nevermind
02:17:54 <ertes> the recursive things are translated to build/foldr via RULES, which is quite puzzling in its own right =)
02:22:42 * hackagebot datasets 0.2 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.2 (glutamate)
02:42:17 <seafood> Anyone here know the internals of the Data.Text package well? 
02:42:34 <seafood> I’d like to ask why indexing of a strict Text value is an O(n) operation
02:43:03 <seafood> Actually, I’d like to know more about the underlying stream data structure and why it was chosen.
02:43:08 <seafood> Is there a paper about Data.Text?
02:43:31 <cocreature> seafood: because Text uses utf16 and that is not fixed width so you need to check the width of each character
02:43:48 <seafood> cocreature: Thanks! So it was as simple as that :-) 
02:44:10 <cocreature> yep :)
02:46:58 <seafood> Hmmm, so I’m looking at this paper https://www.cs.ox.ac.uk/files/4455/paper.pdf
02:47:18 <seafood> It seems to conflict with the current implementation of Data.Text. Any papers on the current implementation? 
02:49:43 <ertes> seafood: if you need O(1) indexing you can use Vector Char from Data.Vector.Unboxed…  it does stream fusion, too
02:49:58 <seafood> Thansk
02:50:02 <seafood> Thanks, rather
02:50:58 <ertes> seafood: if you handle lots of text in memory, keep in mind that Vector Char is most likely 4 bytes per character
02:51:12 <seafood> Okay.
03:07:09 <boxscape> hi, I'm trying to figure out whether there's a function :: f (c -> b) -> f (a -> b) -> f (a -> c)... I found \f g x -> f <*> (g <*> x), but that's `f a -> f c` instead of `f (a -> c)`. Is it possible to do this? and if so, what are the prerequisites/typeclasses that are needed?
03:07:33 <lyxia> :t liftA2 (.)
03:07:35 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
03:07:42 <boxscape> ah
03:07:43 <boxscape> of course
03:07:44 <boxscape> thanks
03:07:51 <lyxia> yw
03:25:58 <nilof> Would it be correct to see recursion as a computation using a stack for the order of computation, and corecursion as a computation ordered using a queue?
03:30:05 <hrk> Is there a way to include parser input text in the parsec's error message? I'm parsing lots of small pieces of text and occasionally I get parse error, but since I don't see the input it's rather useless..
03:34:35 <lyxia> nilof: that doesn't sound right
03:37:40 <lyxia> hrk: you can get the source position and then find the corresponding text after running the parser and getting an error.
03:37:45 * hackagebot multirec 0.7.7 - Generic programming for families of recursive datatypes  https://hackage.haskell.org/package/multirec-0.7.7 (AndresLoeh)
03:38:12 <lyxia> I hear megaparsec has much better error handling
03:45:56 <ertes> trifecta has the best error diagnostics, but megaparsec can at least reproduce the input at that point
03:46:13 <ertes> i think parsec can do that, too, but only if there is no tokenisation
04:00:41 <pavonia> ertes: You can do it with a custom token stream too (if you mean that), but it requires rewriting the tokenPrim parser by storing parts of the input in the user state
04:06:16 <boxscape> Just discovered that by defining `show f = show $ f succ 0` for the Show instance of `(a -> a) -> (a -> a)` I can print church numerals as numbers without much boilerplate. That's kind of fun
04:06:37 <boxscape> I hadn't really realized you could define instances for functions like that
04:28:07 <stalk> hello
04:28:30 <stalk> Is there a prefered module for working in the filesystem structure?
04:29:03 <stalk> For instance, I want a function that gives all the files/directories that lie (recursively) in a given folder
04:29:44 <stalk> So, I used System.Directory.doesDirectoryExist and getDirectoryContents, but I guess there are libraries that already do that better, aren't there?
04:38:41 <c821> hi, i have a question, is this recursion? http://pastebin.com/hzJVkvny
04:39:10 <dibblego> c821: Yes.
04:40:13 <c821> can you help me think of a test for that? 
04:46:35 <pavonia> c821: You usually should have the function's behaviour in mind before writing the function and tests
04:51:43 <shlevy> If I have a type synonym associated with a class, can I put a class constraint on that type? e.g. could I have a class with associated type Foo a such that Foo a always has a Show instance?
05:08:37 <exfalso> Hi, why does (round 112.5) give 112? how would i go about debugging this? should i dump stg?
05:09:14 <ahihi> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:round
05:09:30 <shlevy> http://stackoverflow.com/questions/40829314/require-a-typeclass-instance-for-a-haskell-associated-type-synonym
05:10:21 <raibutera> Hello to all you who have walked the path of learning Haskell before me 
05:10:36 <raibutera> this is my first functional programming language :D
05:12:13 <raibutera> I'm using GHCI and trying to load a haskell file in my google drive, but escaping the space in ~/Google\ Drive/ isn't working, and my google-fu is too weak right now :<
05:12:25 <the_2nd> are similar methods to fold bound monads / alternatives defined somewhere already? http://lpaste.net/5167670634406215680
05:14:11 <raibutera> nevermind, I just had to wrap the path in double-quotes
05:14:37 <raibutera> @the_2nd I'm scared of monads and functors, I don't think i'll understand them when I get there :<
05:14:37 <lambdabot> Unknown command, try @list
05:20:41 <Rembane> raibutera: Are you using Linux or Mac OS X?
05:29:22 <suzu> raibutera: you'll understand them, dw :)
05:35:36 <the_2nd> I'm currently using wreq to read files from urls. Can it somehow also support https or do I need another package for that?
05:42:08 <EvanR> the_2nd: it says on the front page of the package "early TLS support via the tls package"
05:42:17 <EvanR> so it might work
05:44:55 <EvanR> try just using https:// in the uri
05:48:22 <lyxia> shlevy: I think you can write class (Show (Foo a)) => C a where type Foo a :: * ...
05:51:08 <the_2nd> EvanR, my bad. I tested some websites with my algorithm and only the https one failed. I can read it, tho. So the problem is somewhere else
05:52:03 <the_2nd> is it possible to make stack repl auto reload on changes?
06:17:30 <mettekou_> Aren't pattern synonyms available everywhere in the module where they're declared? 
06:18:44 <mettekou> I've declared pattern synonyms for prisms generated by makePrisms in the same module as my data type, so it might be due to Template Haskell?
06:22:07 <shlevy> lyxia: Perfect, thank you!
06:22:13 <lyxia> mettekou: yes template haskell separates declarations
06:32:52 * hackagebot heterocephalus 1.0.1.0 - A type safe template engine for collaborating with front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.1.0 (arowM)
06:33:09 <ertes> pavonia: yeah, you could do that, but i'd rather not call that parsec supporting it
06:33:50 <pavonia> True
06:36:15 <Berra> If I have a data type data Foo = Bar Double | Baz Double deriving(Eq, Ord). How can I given an Foo compare it without explicitly having to construct a new Foo with a constructor. myFoo > (Baz 0) for example.
06:39:01 <hpc> Berra: make a Num instance for Foo?
06:39:31 <hpc> but then you have to write a bunch of other stuff, so you should make sure it's appropriate for your type first
06:42:05 <Berra> hpc: Should I try DeriveAnyClass?
06:42:58 <hpc> i don't know how deriving works for Num, so i wouldn't
06:43:22 <Berra> hpc: I copy pasted the instance from https://wiki.haskell.org/Num_instance_for_functions and it works well now.
06:43:29 <hpc> you're probably better off being explicit
06:44:04 <Berra> How do I go about knowing what I need?
06:44:10 <Berra> In terms of implemented methods
06:44:11 <orionz> Hello, everyone! I'm new here, and haskell is such a cool language! :)
06:44:34 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num
06:45:05 <hpc> those are what you need to define to have a valid Num instance
06:45:20 <Berra> hpc: So all the ones I copied.
06:45:47 <hpc> yeah
06:46:31 <hpc> i couldn't say if that's what you need without a clearer picture of what you need this for
06:46:59 <hpc> but a Num instance would definitely get you to writing "myFoo > 0"
06:47:31 <Berra> hpc yes that's what I want
06:47:36 <Berra> And it works
06:52:53 * hackagebot datasets 0.2.0.1 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.2.0.1 (glutamate)
06:54:44 <EvanR> sometimes i pretend Num is (+) (*) and fromInteger
06:55:09 <EvanR> the other stuff is a pain to remember and is inapprpriate from often than not
06:55:18 <EvanR> more often*
06:56:15 <EvanR> any idea what the laws for abs and signum would be in Num
06:57:19 <EvanR> ah, abs x * signum x == x
06:57:31 <EvanR> so yeah putting them in another class would make sense
06:57:39 <EvanR> and idris puts negation in another class
06:57:53 * hackagebot aws-simple 0.1.0.0 - Dead simple bindings to commonly used AWS Services  https://hackage.haskell.org/package/aws-simple-0.1.0.0 (AlexanderThiemann)
07:00:54 <Berra> hpc: So would you say DeriveAnyClass is a bad choice in general?
07:02:53 * hackagebot datasets 0.2.0.2 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.2.0.2 (glutamate)
07:03:30 <persik> @help
07:03:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:03:41 <persik> @lisst
07:03:41 <lambdabot> What module?  Try @listmodules for some ideas.
07:03:44 <persik> @list
07:03:44 <lambdabot> What module?  Try @listmodules for some ideas.
07:03:56 <EvanR> try @listmodules in a PM window
07:04:34 <persik> thx
07:10:44 <Berra> hpc: If I want to implement the Num instance using those methods I need to also implement Applicative Functor. And if I want to avoid that do I need to write out the pattern matching for all constructors in Foo?
07:16:10 <ongy> brick forces -threaded RTS? I remember it's prefered, but force it?
07:18:01 <Adeon> hmm, I think there are some things that just don't work well without although I'm not 100% sure
07:18:05 <Adeon> some ffi stuff
07:18:11 <Adeon> that call back to haskell and you must not block and all that
07:18:19 <Adeon> that is, without -threaded
07:19:02 <Adeon> on the other hand, what are the reasons not to use -threaded?
07:19:13 <Adeon> if you don't want many threads you can just do -threaded and not specify -N or do -N1
07:22:05 <EvanR> ongy: i have noticed non -threaded causes a lot of things to act funny, the only reason it still exists that i can tell is
07:22:19 <EvanR> that non -threaded may have slightly better computational throughput
07:22:46 <EvanR> (if youre using only 1 thread)
07:22:55 <EvanR> or 1 core
07:22:58 <stalk> Hi
07:23:02 <ongy> I'm just to lazy to add compiler arguments. if -threaded went to default and we'd have -no-threaded I wouldn't even notice
07:23:06 <stalk> Shouldn't this run quickly http://lpaste.net/6930527273716023296 ?
07:23:23 <EvanR> i agree thats how it should be
07:23:37 <Adeon> I think -threaded should be default...not sure if by default it should use many threads though
07:23:55 <ongy> stalk: I think the compare in line 10 is useless, and pretty expensive
07:24:13 <EvanR> Adeon: well, -N is number of capabilities. i dont know what the default is, but making higher than number of cores makes no sense
07:24:21 <stalk> ongy: ah, good point
07:24:34 <stalk> because it makes each call unroll the whole listis
07:24:37 <stalk> *lists
07:24:38 <Adeon> just -N might be bad, if you have a machine with lots of cores haskell can't always scale efficiently depending on your app
07:25:04 <Adeon> I've had to limit number of threads on big ec2 instances because performance starts tanking at 16+ cores on these machines
07:25:14 <EvanR> the number of OS threads used by the runtime depends on the wacky ffi things you do and doesnt correlate to capabilities
07:25:17 <stalk> but still, I thought using this memoize function, it would be quick. I wonder if it really does memoize
07:26:47 <ongy> stalk: I haven't used memoization, but it doesn't look like you are taking any advantage of it here. You are recursing in levenshtein, not levenshtein'
07:27:23 <EvanR> Adeon: are those ec2 16+ cores real? or 
07:27:30 <EvanR> virtual
07:27:38 <Adeon> I'm not actually sure
07:27:40 <stalk> ongy: ah, I thought memoize was pretty much drop in
07:28:12 <Adeon> I assume the hardware does actually have at least that many cores and they get virtualized for you
07:28:15 <danilo2> Hello guys! Is there or will it theoretically be possible in Haskell to declare a newtype which will guarantee GHC that its type params met some constraints, like `newtype Foo a = Typeable a => Foo a` ? I know I can create existential, but I dont want to carry the runtime dict.
07:28:52 <stalk> ongy: https://stackoverflow.com/questions/23214296/how-to-use-the-memoize-function-in-data-function-memoize
07:28:56 <stalk> seems like you're right
07:29:02 <danilo2> I just want later to be able to use it like: `test :: forall a. Foo a -> TypeRep ; test (Foo _) = typeRep (Proxy :: Proxy a)` - without constraitn on a
07:35:16 <hpc> danilo2: unconstrained Data/Typeable is maaaaaaaaaybe happening soon?
07:35:20 * hpc doesn't remember
07:35:36 <hpc> i remember it being a thing that was wanted though
07:36:43 <hpc> oh, misread
07:36:52 <hpc> danilo2: you can write a GADT that introduces constraints
07:37:09 <hpc> data Foo a where Foo :: Typeable a => a -> Foo a
07:37:50 <hpc> (also unconstrained Data/Typeable is probably a bad idea overall, for parametricity reasons)
07:38:36 <danilo2> hpc: yeah, yesterday was discussion here about unconstrained Typeable and that its a bad idea
07:38:57 <hpc> ah cool
07:39:02 <danilo2> hpc: anyway are you sure it will be happening? I know that every datatype will be Typeable, but I didnt know the constraint would be off
07:39:16 <hpc> oh, maybe that's what it was
07:39:29 <danilo2> hpc: GADTs solution equals to exystentials, so the runtime dict will be carried along :/
07:40:28 <hpc> ah, then just deal with having the constraint on everything i suppose
07:41:14 <danilo2> hpc: I cannot, I need to satisfy typeclasses that cannot have constraint on argument. I just want to assure GHC that if anybody have constructed this data, then the constraint HAD TO be met, so I dont need to pass it along
07:45:13 <hpc> smart constructor maybe?
07:45:31 <hpc> hide the constructor and smartFoo :: constrained type of Foo; smartFoo = Foo
07:46:57 <hpc> and then you wouldn't be able to get that constraint back out i suppose, so you'd have to write the constraint on things that use Foo where it matters
07:48:46 <lyxia> With what danilo2 is proposing, you could write    newtype Foo a = Ord a => Foo a   , and    instance Ord (Foo a)    without a constraint on a.
07:50:33 <danilo2> lyxia: yep
07:50:38 <lyxia> and without any overhead due to carrying the runtime constraint, hopefully
07:50:47 <danilo2> lyxia: yep
07:53:35 <hpc> you still have to write Ord (Foo a) everywhere
07:53:39 <hpc> i think
07:54:41 <danilo2> hpc, it doesnt matter,. In this example yes, but consider my last comment here: https://ghc.haskell.org/trac/ghc/ticket/12882#comment:6
08:06:31 <tnks> I'm still new to Haskell pragmatics.  I see that calls to "error" have a callstack, but a lot of normal IOExceptions seem to not report a callstack.
08:08:29 <tnks> I know GHC 8 has had some changes regarding stack traces, but I didn't find any incantation to get the behavior most people would expect coming from other languages (all runtime exceptions with call stacks)
08:08:41 <tnks> did I miss something?
08:27:56 * hackagebot aivika-transformers 4.6.1 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.6.1 (DavidSorokin)
08:27:58 * hackagebot aivika-distributed 0.3.1 - Parallel distributed discrete event simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-distributed-0.3.1 (DavidSorokin)
08:28:24 <earthy> tnks: no; it is very hard to generate a 'useful' stack in the face of laziness
08:32:44 <tnks> earthy: okay, that makes sense.
08:33:05 <tnks> earthy: are there some work-arounds?
08:33:57 <tnks> actually, I'm just doing the "right" thing of pulling all my exceptions into the type system with explicit error types.
08:34:42 <tnks> but I'm kind of confused by how other people deal with just "letting exceptions happen"
08:35:04 <tnks> in a large application, that seems like it would just lead a ton of mystery low-level IOExceptions of unknown origin.
08:35:37 <tnks> I guess people have the exception type.
08:35:52 <tnks> and they can wrap the exception types to make new ones with more context.
08:36:10 <tnks> sorry, thinking out loud; in retrospect, this is all kind of obvious.
08:36:42 <akfp`> how do I know which compilers stack can give me under os x sierra?
08:36:48 <maerwald> you are right, exceptions are sort annoying in haskell, you also don't know at all whether you "catched" all of them
08:37:16 <dfeuer> maerwald, exceptions are annoying in every programming environment.
08:37:27 <maerwald> no
08:37:33 <hpc> these are all pretty universal problems with exceptions
08:37:43 <hpc> including stacktraces, in languages with lambdas
08:37:44 <tnks> maerwald: yeah, I think there's two annoyances: 1) keeping up with context 2) knowing if you're dealt with them completely.
08:38:00 <lyxia> what about the +RTS -xc option mentionned here https://wiki.haskell.org/Debugging
08:38:01 <tnks> either way (look, a pun), I'm using ExceptT.
08:38:08 <hpc> in java it's fine because the language is so weak, but in others you get a stack that's nothing but unnamed functions that take varargs
08:38:33 <hpc> and it can hide the true source of the problem when that lambda is being generated somewhere outside the trace
08:38:55 <tnks> hpc: I agree it can hide it, but it's often enough information to get started thinking about the problem.
08:38:59 <lyxia> -xc gives non-zero information about where an exception comes from
08:39:54 <hpc> tnks: sometimes i just like to complain about exceptions ;)
08:41:04 <maerwald> tnks: also, you can hardly verify what kind of exceptions are possible when your function ends in IO ()
08:41:14 <maerwald> all things that are actually better in java
08:41:42 <tnks> maerwald: you mean with Java's checked exceptions?
08:41:47 <maerwald> yeah
08:42:08 <tnks> but that world is dieing, because everyone in Java considers checked exceptions a "failed experiment"
08:42:19 <tnks> so it's all RuntimeException for everything.
08:42:30 <dfeuer> maerwald, Java and the like all offer a uniform way to raise exceptions, but then give you no guidance as to how to handle them.
08:42:57 * hackagebot datasets 0.2.0.3 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.2.0.3 (glutamate)
08:43:26 <dfeuer> In Haskell, exceptional conditions are "raised" in different ways (annoying at the raising site), and the handling approach generally has to be chosen in advance.
08:43:47 <dfeuer> (Is this an exception we'll likely recover from? If so, where?)
08:44:43 <dfeuer> I've started to think that the Haskell way, while certainly not perfect, is probably better in the long run.
08:45:06 <dfeuer> Because figuring out what you want to do with exceptions is typically a lot harder than figuring out that you have an exceptional condition.
08:45:31 <dfeuer> Languages that make easy things easier don't tend to help anyone in the end.
08:45:50 <maerwald> dfeuer: haskell neither
08:46:17 <tnks> lyxia: I don't see an -xc RTS flag in 8.0.1
08:48:01 <lyxia> It's still there though.
08:48:10 <lordcirth> So I'm trying to use composition to create Player and Monster, each of which contains a CreatureInfo.  Is there a way I can have a getter function/lens cInfo common to both without colliding?
08:48:53 <lyxia> lordcirth: you can use a typeclass to overload the lens
08:49:12 <lordcirth> lyxia, that sounds overcomplicated?
08:49:15 <lyxia> class HasCInfo a where cInfo :: Lens' a CreatureInfo
08:50:16 <lordcirth> lyxia, oh ok.  Do I then need to prevent makeLenses'' from conflicting with that, or will it figure it out?
08:50:45 <lyxia> you will need to prevent conflicts yourself
08:51:38 <lyxia> Actually I think lens has a way to generate those typeclasses too
08:52:13 <lyxia> makeClassy
08:52:14 <tnks> lyxia: sorry, it's still there?
08:52:19 <lordcirth> That would make sense
08:52:24 <tnks> lyxia: I tried this:  stack ghc -- -prof -fprof-auto -fprof-cafs -rtsopts +RTS -xc -RTS hello.hs
08:52:44 <tnks> where ghc is at 8.0.1
08:52:46 <lyxia> tnks: you must pass +RTS -xs to the executable
08:53:02 <tnks> oh, sorry, I forget that.
08:53:39 <lyxia> ghc -prof -whatever -rtsopts hello.hs ; ./hello +RTS -xc
08:53:52 <tnks> lyxia: right, thanks.
08:53:55 <lyxia> yw
08:54:09 <tnks> shows how much I compile programs, and how much less I run them.
08:56:36 <lyxia> you can also pass the option at compile time: ghc -with-rtsopts=-xc
08:57:34 <tnks> ah lyxia yeah, that's what the Stack template does, I realize now.
08:57:39 <lordcirth> lyxia, makeClassy seems like what I want, but I don't think I understand how to use it
08:57:53 <mettekou> How can I import a pattern synonym from another module?
08:58:53 <danilo2> import (pattern (...))
09:02:58 * hackagebot pvss 0.1 - Public Verifiable Secret Sharing  https://hackage.haskell.org/package/pvss-0.1 (VincentHanquez)
09:13:47 <mettekou> danilo: I used that syntax, but I forgot the LANGUAGE pragma. Thanks!
09:13:51 <mettekou> danilo2 **
09:14:59 <lyxia> lordcirth: makeClassy will basically just define the HasCreatureInfo class, I can't find a way to define instances for the other types.
09:15:13 <lyxia> apart from doing it by hand
09:15:19 <danilo2> mettekou: np :)
09:16:12 <lyxia> lordcirth: but    makeFields ''Player ; makeFields ''Monster    seems to do something similar
09:19:16 <lordcirth> lyxia, ok, I'll look into it, thanks
09:22:59 * hackagebot wl-pprint-annotated 0.0.1.0 - Wadler/Leijen pretty printer with annotations  https://hackage.haskell.org/package/wl-pprint-annotated-0.0.1.0 (minad)
09:33:00 * hackagebot hint-server 1.4.3 - A server process that runs hint.  https://hackage.haskell.org/package/hint-server-1.4.3 (CorentinDupont)
09:47:56 <bollu> in a monad transformer, effect "flow" inside to outside right?
09:48:26 <bollu> like, WriterT … Maybe  … would mean that first the Maybe effect happens, and then depending on Maybe semantics, Writer happens?
09:48:55 <Hafydd> It depends on the transformer, surely.
09:49:43 <bollu> I see
09:53:18 <raibutera> anyone here good with binary and signed/unsigned integers/chars?
09:53:38 <Tuplanolla> How is that a skill? Just ask your question, raibutera.
09:54:02 <raibutera> well, its not even Haskell, i finished my haskell assignment and I'm doing C xD
09:54:08 <bollu> if I want to write logfn :: Data ->  MaybeT (Writer Log) Data, where I just want it to append "show data" to the Log  and then return Just data
09:54:09 <nshepperd> bollu: it is often the case that a transformer FooT m a will unwrap into something looking like x -> m (FooStuff y). having m on the "outside". but of course it depends
09:54:11 <bollu> how would I do this?
09:54:48 <nshepperd> it does mean you usually want MaybeT Foo a rather than FooT Maybe a
09:55:53 <bollu> right, right
09:56:08 <nshepperd> eg. WriterT w Maybe a = Maybe (w, a) which is not too useful, the writer log will be lost as soon as a Nothing happens
09:56:09 <bollu> but, like, I'm not sure what the correct way to define said logfn is
09:56:14 <bollu> nshepperd: exactly
09:56:29 <hexagoxel> bollu: lift . tell . data2Log
09:57:05 <bollu> hexagoxel: oh, so I need the lift
09:57:12 <hexagoxel> lift might be unnecessary
09:57:30 <bollu> oh, oh
09:57:36 <bollu> right, okay, now I understand what's happening
09:57:38 <nshepperd> MaybeT Writer should have a MonadWriter instance, so you can just do 'tell (show data) >> return data'
09:57:41 <bollu> fuck, transformers are weird
09:59:04 <raibutera> but I have files in binary format. It contains multiple bytes, each byte is an individual instruction. The first 2 bits are an opcode, and the last 6 bits are an operand. Here is part of my assignment's description: "byte 0x7D (which is 01111101) means DY -3". The 'DY' is the opcode (first 2 bits = 01 = DY). I cannot for the life of me figure out why the remaining 6 bits make -3. The 6 bits are supposed to be a signed number
09:59:05 <raibutera>  of pixels (-32..31) but when I convert them to decimal in my calculator it comes out as 61 not -3.... so confused 
10:00:53 <Tuplanolla> > 61 - 32 * 2
10:00:55 <lambdabot>  -3
10:01:17 <hexagoxel> 111101 is two complement representation for -3
10:01:17 <Tuplanolla> Is this enough?
10:06:46 <raibutera> 'two complement representation'
10:06:59 <raibutera> now i know what i have to google :D
10:07:05 <hexagoxel> https://en.wikipedia.org/wiki/Two%27s_complement
10:31:18 <bollu> if I have a writer with value () as a, how do I actually put in a value?
10:31:52 <bollu> or should I be using State for this with get and put?
10:33:06 <hexagoxel> :t tell
10:33:08 <lambdabot> MonadWriter w m => w -> m ()
10:34:31 <hexagoxel> and you can compose `m ()`s via (>>) or such
10:37:24 <hexagoxel> (there is some argument for using State for purposes of Writer to avoid leaking that can happen with regular writer)
10:37:36 <hexagoxel> e.g. @hackage stateWriter
10:40:03 <hexagoxel> (but not sure if applicable for your code - in general Writer at least has the purpose of implicit documentation that you won't normally delete stuff from the state)
10:42:06 <shapr> Is there a guide for upgrading from the old-time package to the time package?
10:44:40 <tnks> regarding my earlier question about getting stack traces, I just found out about "stack build --trace"
10:44:54 <tnks> does anyone know which flags that compiles in?
10:45:14 <tnks> I don't see that in the build output.
10:45:24 <shapr> tnks: http://dev.stephendiehl.com/hask/#stack-traces
10:45:38 <shapr> tnks: I think you'll like that whole document, it'll save you much time.
10:47:46 <tnks> shapr: I just revisted that section earlier.
10:53:31 <hackrilege> What is the (:-) operator?
10:53:45 <lyxia> hackrilege: from where
10:54:04 <lyxia> Have you asked hoogle
10:54:29 <lyxia> http://hoogle.haskell.org/?hoogle=%3A-
10:54:35 <hackrilege> Ekmett uses it in one of his talks, I have never seen it so I had to pause it...
10:54:46 <pikajude> use hayoo, hoogle doesn't have very many things indexed
10:54:55 <lyxia> I guess it's the one from constraints then
10:54:59 <hackrilege> Yeh
10:55:35 <lyxia> hackrilege: the type c :- b means that the constraint c implies the constraint b
10:56:09 <shapr> Has anyone seen QuickCheck instances for IETF datatypes? For example, URIs, email addresses, MIME types, etc?
10:56:18 <lyxia> hackrilege: If you can provide the constraint c, unwrapping a value of that type gives you the constraint b.
10:56:55 <hackrilege> unwrapping?
10:58:14 <tnks> just to sanity check my intuition, is the reason people don't turn on profiling/tracing by default compile-time slowdown?  runtime slowdown?  or both?
10:59:39 <lyxia> hackrilege: pattern match
11:00:01 <hackrilege> I guess I can't think of an example where I could infer a constraint. Perhaps since I have e.g. (Eq a,Eq b) => Eq (a,b) then I could write (Eq a,Eq b) :- Eq (a,b) is that right?
11:00:03 <AndreasK> tnks: Profiling at least has a runtime overhead
11:00:15 <lyxia> hackrilege: right
11:00:52 <hackrilege> I'm not sure I understand about Dict and how (:-) is used there
11:01:46 <tnks> I'm just wondering if people compile production code with tracing to get stack traces upon exceptions.
11:01:55 <tnks> even if it's slower.
11:02:18 <tnks> and curious what they're sacificing performance-wise if they are.
11:03:03 * hackagebot nvim-hs 0.1.0 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.1.0 (saep)
11:03:28 <hackrilege> Ah, more generally any subclass entails it's superclass
11:04:08 <AndreasK> If in doubt benchmark :D I found that for profiling not only the performance changes, but also things which are slower without became faster and the other way around
11:04:16 <AndreasK> Not often but it happens
11:05:01 <AndreasK> If you decide to run a benchmark i would be interested in the result.
11:06:44 <tnks> AndreasK: yeah, doing a benchmark like that well is non-trivial.
11:06:52 <tnks> so I'll take hearsay for now.
11:07:34 <AndreasK> I'm a fan of avoiding premature optimization. Especially since refactoring is comperativly easy in Haskell
11:08:17 <hpc> you get 95% of the way there anyway just by knowing your data structures and algorithms
11:08:31 <hpc> and most of the rest is reducing IO
11:10:28 <hackrilege> Im still having trouble understanding the type of the function (\\) :: a => (b => r) -> (a :- b) -> r
11:12:35 <hpc> hackrilege: i think the idea is to take a value of type (b => r)
11:12:45 <hackrilege> I can't seem to get lambdabot to recognise it either....
11:12:50 <hpc> which is a thing constrained by some relatively specific class b
11:13:02 <hpc> and then take a choice of more generic class a
11:13:07 <hpc> and produce a value of type (a => r)
11:13:13 <hpc> or something
11:14:03 <hpc> it probably needs ConstraintKinds at the very least
11:14:18 <hpc> maybe KindSignatures too
11:14:28 <hackrilege> I thought that if a constraint requires a superclass that a subclass would satisfy it anyway
11:14:28 <hpc> for it to be nice to use
11:14:38 <lyxia> notice that if you confuse => and :- with ->, it looks like function composition
11:15:05 <lyxia> hackrilege: a :- b can model relationships other than superclass
11:15:20 <hpc> with a at the front only because you can't put (a => r) at the end and still reference a earlier
11:15:39 <lyxia> It's actually not useful for these cases that the compiler handles anyway
11:17:08 <hackrilege> Ok I think I get it now, I'll continue watching the talk. Thanks!
11:17:58 <hackrilege> https://youtu.be/hIZxTQP1ifo
11:18:03 * hackagebot nvim-hs-contrib 0.1.0 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-contrib-0.1.0 (saep)
11:21:07 <xcmw> geekosaur: I was told by #ghc that it was not a bug since it could not unify because TK3 is a type family
11:21:55 <geekosaur> yes, glguy and I were discussing it after you left the channel (and talking with ezyang in #ghc)
11:23:12 * geekosaur suspects ghc 7.10 would have produced a better error message; 8.0 with TypeInType confuses things a bit because it doesn't distinguish type and kind level in the same way 7.10 did
11:23:23 <geekosaur> there are a few cases of error messages becoming more confusing with that change
11:25:14 <xcmw> Why can't GHC unify whenever type families are present? What does unify mean? Are there any work arounds other than newtypes.
11:25:55 <hpc> unify refers to unification - https://en.wikipedia.org/wiki/Unification_(computer_science)
11:26:15 <hpc> basically solving systems of equations automatically
11:26:23 <geekosaur> so, the root of the problem is that you are at some level confusing kinds (the "type" of a type) with types (the "type" of a value)
11:26:28 <hpc> the equations being generated by the relations between types and values
11:27:29 <geekosaur> you used DataKinds, which produces kinds (not types), and then you were treating them as types. ghc8 lets you do this to some extent because the two levels were collapsed together --- but treating them as identical leads to the variety of error that you got
11:28:08 * geekosaur is ... not great at kind level stuff, so is not really the person to be trying to analyze this
11:28:50 <geekosaur> anyway I think it might be possible to do what you are trying to do, but not in the way you were doing it; that way confuses levels
11:29:08 <xcmw> geekosaur: AField is a kind and X, Y, and Z are types of that kind
11:29:44 <xcmw> XF, YF, and ZF are values
11:30:02 <geekosaur> yes. that's not the confusion
11:30:23 <geekosaur> and like I said, I am not the right person to be trying to figure this out
11:33:10 <xcmw> geekosaur: Do you know of any person or place to ask crazy type questions?
11:34:35 <geekosaur> this is one of the places but I am not the person. don't know offhand who might be active in here who could help; you could also ask on stackoverflow or on the haskell-cafe mailing list, both of which reach people who are not active on IRC (or on the other, for that matter)
11:34:48 <MarcelineVQ> possibly best asked first is what is your end goal, then people who do know things to try can suggest them
11:36:17 <xcmw> I can show you what I want in javascript. Just a second.
11:36:20 <geekosaur> (I get lost real fast with this stuff...)
11:41:09 <lpaste> xcmw pasted “No title” at http://lpaste.net/347198
11:41:43 <xcmw> There are alot more than x and y in the real thing
11:42:24 <xcmw> I got it working in haskell but it took about 100 lines
11:43:14 <xcmw> And it required boxing and unboxing of x and y
11:45:02 <xcmw> I was searching for a better. ertes told me that GADTs might help because they have type refinement.
11:45:03 <hackrilege> I can't understand what you're asking xcmw
11:46:53 <geekosaur> xcmw, I think you need to explain what you are actually trying to accomplish, not how you want to do it (in whatever language). what is the high level problem description?
11:48:15 <xcmw> I am writing a microdata recipe parser. Each recipe has properties like title, author, ingredients, cooktime, tags, ..
11:48:31 <xcmw> The properties are of many different types
11:49:28 <xcmw> Almost every property has a function that takes [HTMLElement] -> JSM a
11:50:30 <xcmw> And there is a map with an array of microdata properties to query for each property.
11:51:56 <xcmw> There is another function that takes an array of microdata properties and returns [HTMLElement]
11:53:01 <xcmw> I am trying to write a function that takes something that identifies the property, looks that property up in the microdata mapping table, gets the elements using those strings, and runs it though the processing function for that element
11:54:34 <xcmw> I can't use a map because I can't gerantee that a key will exist
11:55:07 <xcmw> records don't let have have the same key for different records
11:55:39 <xcmw> even with makeFields from lens
11:55:58 <berndl> I wonder if that will ever get fixed.
11:57:01 <xcmw> Does that make any sense? I am currenly going to use the long method with template haskell to reduce boilerplate
11:57:19 <glguy> xcmw: did you see the resolution of your TK3 issue last night?
11:57:55 <xcmw> glguy: I never managed to fix it. I was told it was not a bug.
11:58:40 <glguy> OK, did you understand why the type was ambiguous?
11:58:58 <xcmw> No
11:59:07 <xcmw> If d1 = {x: "5", y: "Hi"}
11:59:07 <xcmw> d2 = {x: _ => parseInt(_, 10), y: _ => _}
11:59:07 <xcmw> d3 = ["x", "y"].reduce((obj, prop) => {obj[prop] = d2[prop](d1[prop]); return obj}, {})
11:59:19 <xcmw> Sorry wrong thing
11:59:51 <xcmw> If TK3 t0 = k0 t0 then k0 = TK3?
12:00:28 <xcmw> I can't understand why k0 is ambiguous
12:00:53 <glguy> since TK3 is an understated type family it's not a valid instantiation for k
12:01:00 <glguy> unsaturated*
12:01:47 <xcmw> What does that mean?
12:02:29 <glguy> TK3 expects an argument in order to figure out what type it will evaluate to
12:02:42 <xcmw> Yes
12:02:47 <glguy> it doesn't have its own identity
12:02:56 <glguy> you can use it without an argument
12:03:01 <glguy> cant
12:03:27 <xcmw> That argument is t0
12:03:49 <glguy> data families ,however, do create new, distinguishable types
12:03:59 <glguy> no, the question is what k should be
12:04:11 <glguy> t doesn't factor in at this point
12:04:43 <xcmw> If I replace k with TK3 it works. Doesn't that mean TK3 is a valid initiation of k?
12:04:49 <glguy> no
12:05:46 <hackrilege> Still not clear what's being asked here
12:06:21 <glguy> you can't use TK3 without applying it to some other type , so k can't be TK3
12:07:01 <xcmw> glguy: Why can't you use TK3 without applying other type?
12:07:21 <glguy> it's a type family declared with 1 parameter
12:07:31 <glguy> so it needs to be applied to one type
12:08:02 <glguy> this is a restriction of type synonyms and type families
12:08:16 <xcmw> Why can't the parameter be applyed later? Like in value level haskell
12:08:25 <glguy> they're merely "aliases" for other types
12:08:44 <glguy> not distinct types themselves
12:08:50 <ckubrak> Hi guys, is there any "exist" function for lists?
12:09:16 <Tuplanolla> :t elem
12:09:17 <geekosaur> find, lookup, elem
12:09:18 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
12:09:24 <geekosaur> among others
12:10:08 <xcmw> glguy: Ok, thanks
12:10:38 <xcmw> I will use newtype + type family
12:10:55 <glguy> xcmw: or perhaps a data family
12:11:41 <hackrilege> Is there a function that will allow me to access the records of a datatype using an int as a label?
12:11:44 <xcmw> glguy: I could not use the data family in a type class
12:12:08 <glguy> why not?
12:12:12 <ckubrak> Tuplanolla: Im actually looking for something like this: exist a in (x:xs) so that a>2
12:12:48 <xcmw> GHC said something about data families not being supported in a type family
12:13:19 <xcmw> type class not type family
12:13:37 <Tuplanolla> :t isJust .: find
12:13:39 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:13:43 <glguy> you'd have to put a data family in the type class instead of a type family
12:14:21 <xcmw> glguy: I meant to write type class. GHC did not like it
12:14:59 <glguy> xcmw: it works you just have to declare the type class appropriately
12:16:38 <hackrilege> Is there a function that will rewrite a datatype as a tuple?
12:17:27 <berndl> hackrilege: what do you mean by rewrite?
12:19:02 <hackrilege> Output
12:19:25 <hackrilege> I guess I wouldn't be able to give this function a type...
12:19:35 <ckubrak> Tuplanolla: thanks
12:24:04 <lpaste> xcmw pasted “glguy: Example of error I was talking about” at http://lpaste.net/347235
12:24:22 <xcmw> glguy: What am I doing wrong ^
12:27:14 <glguy> xcmw: you put a value constructor where a type constructor was needed
12:28:04 <glguy> the type's name is TK3
12:28:21 <xcmw> glguy: I see that now
12:29:22 <xcmw> glguy: Do I need to write a seperate instance for TK3 X and Y?
12:30:19 <glguy> you do if you want to vary the implementation depending on what type it has
12:30:32 <xcmw> glguy: No
12:30:45 <glguy> if TK3 was a GADT you could pattern match it
12:30:58 <glguy> or even just a normal ADT
12:31:34 <the_2nd> glguy, mind typing these out? just wondering
12:32:44 <xcmw> glguy: How would I do that?
12:34:05 <hexagoxel> :t any -- Tuplanolla, ckubrak 
12:34:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:34:26 <Tuplanolla> I completely forgot about this one.
12:36:46 <glguy> xcmw: It kind of depends on what the goal of all of this and how it needs to be able to be extended
12:37:22 <glguy> If you want to be able to write   TK3 a -> someType  for unbox, you'd need someTime to be a type family parameterized by X and Y
12:37:47 <glguy> Whether TK3 is a GADT or a type family is a question of if it's intended to support additional cases later
12:38:53 <xcmw> I want to be able to write TK3 a -> someType for unbox
12:39:06 <the_2nd> http://lpaste.net/8726109918848876544  are these already defined somewhere? Or how could I use fold here (if possible)
12:39:40 <xcmw> newtype + type family still seems easier
12:39:46 <glguy> Yeah, for this is looks like it is
12:40:55 <lpaste> xcmw pasted “Newtype + type family” at http://lpaste.net/347243
12:41:21 <vktr> hi
12:41:55 <xcmw> glguy: That works but it is very complicated
12:43:07 * hackagebot wl-pprint-annotated 0.0.1.1 - Wadler/Leijen pretty printer with annotations and slightly modernized API  https://hackage.haskell.org/package/wl-pprint-annotated-0.0.1.1 (minad)
12:43:08 <glguy> cool
12:43:58 <glguy> allF = flip (foldM (flip id)) :: [a -> Maybe a] -> a -> Maybe a -- haven't thought of a nice way to do it with fold just yet
12:47:00 <glguy> au (mapping (_Wrapping Alt)) foldMap :: [a -> Maybe a] -> a -> Maybe a
12:50:40 <lyxia> allF = ala Kleisli foldMap
12:52:10 <glguy> Yeah, but it doesn't have the Monoid instance to make that work
12:52:44 <lyxia> oops :)
12:53:29 <dfeuer> I'm trying to figure out a good way to implement a level-wise traverse for Data.Tree.
12:54:19 <lyxia> :t foldr (>=>) pure
12:54:20 <lambdabot> (Foldable t, Monad m) => t (c -> m c) -> c -> m c
12:55:34 <dfeuer> The trouble is that I need to build up a new tree of the correct shape.
12:56:55 <dfeuer> It's going to be a bit horrible, actually.
12:57:40 <hackrilege> How do you mean?
12:58:04 <lyxia> seems like fun
12:58:49 <dfeuer> hackrilege, if I want to fold a tree level-wise, that's not too bad. At each step, I can merge the forests below and not have to care how many there were or how many elements each had.
12:59:04 <dfeuer> To traverse a tree level-wise, I need to be able to rebuild the original structure.
12:59:42 <hackrilege> Have you looked at zippers for trees?
13:00:20 <hackrilege> They keep the structure and allow element wise access...
13:00:24 <dfeuer> So I guess I can just convert the tree to a list, traverse the list, and then traverse the tree in StateT.....
13:00:40 <dfeuer> hackrilege, what do zippers have to do with this?
13:01:09 <hackrilege> If you were worried about losing the structure, a zipper would preserve it
13:01:29 <dfeuer> Hrmm....
13:01:57 <dfeuer> hackrilege, I'm not seeing it.
13:02:09 <lyxia> Me neither.
13:02:13 <dfeuer> How would you use a zipper to implement level-wise traverse? 
13:02:16 <dfeuer> I'm not saying it's impossible.
13:02:19 <dfeuer> I'm just not seeing it.
13:02:24 <newhoggy> In http://book.realworldhaskell.org/read/profiling-and-optimization.html under "Advanced techniques: fusion", there is some code using Data.Array.Vector from the deprecated uvector library.  Does anyone know how to fix it to not use deprecated libraries?
13:03:07 * hackagebot scotty-format 0.1.0.0 - Response format helper for the Scotty web framework.  https://hackage.haskell.org/package/scotty-format-0.1.0.0 (potomak)
13:03:10 <dfeuer> newhoggy, does the uvector deprecation message point to any alternatives?
13:03:27 <newhoggy> Yes, it does.
13:03:32 <dfeuer> Well ....
13:03:37 <newhoggy> But I couldn't get it to behave as expected.
13:03:38 <dfeuer> That might be your best bet?
13:03:38 <hackrilege> I would navigate to each element I was including in the traverse, basically like traversing all elements above the level of interest to get to the nodes at that level and only retaining then. Maybe I have the wrong idea
13:03:53 <newhoggy> My version consumes a lot of memory.
13:04:29 <newhoggy> For example, I have this:
13:05:14 <newhoggy> https://github.com/haskell-works/hw-tutorial-performance/blob/master/hw-tutorial-performance-rwhe/Main.hs
13:05:40 <dfeuer> hackrilege, maybe I'm missing something, but I still don't see it. I could imagine it better if I had a Monad constraint so I could use StateT to hold the zipper.
13:05:50 <dfeuer> But I just have Applicative.
13:06:02 <newhoggy> With that code, I get "1831 MB total memory in use", which is terrible
13:06:07 <dfeuer> Ouch.
13:06:30 <maerwald> dfeuer: Zippers are just tuples, why would you need StateT for that?
13:06:33 <lyxia> dfeuer: is your tree just a rose tree
13:06:42 <dfeuer> lyxia, yes. Data.Tree.
13:06:46 <newhoggy> Build run steps I used were:
13:06:46 <newhoggy> stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto -rtsopts -auto-all -caf-all -fforce-recomp"
13:06:55 <dfeuer> maerwald, I'm probably thinking stupid.
13:06:55 <newhoggy> time /Users/jky/wrk/haskell-works/hw-tutorial-performance/.stack-work/install/x86_64-osx/lts-7.10/8.0.1/bin/hw-tutorial-performance-rwhe +RTS -sstderr -p -hy -RTS 1e7
13:07:46 <dfeuer> maerwald, could you sketch out how to use a zipper to implement a Traversable instance?
13:07:47 <hackrilege> I don't see where state comes into this either. I only mentioned zippers because they retain structure which you said you were concerned about using. If you could post some code I could have a go doing it with zippers...
13:07:57 <dfeuer> hackrilege, yeah, I probably got mixed up.
13:08:52 <lyxia> I want to solve that with some continuation passing spaghetti.
13:09:02 <dfeuer> hackrilege, but ... er ... the "zipper" would have to have some very strange types.
13:09:19 <hackrilege> Really?
13:09:29 <hackrilege> How so?
13:09:31 <newhoggy> I get very large numbers of allocations of Pair and Double.
13:09:53 <hackrilege> Just nested lists for rose tree...
13:10:19 <newhoggy> There is also a very large upfront allocation ARR_WORDS, which I feared would happen when using Data.Vector
13:10:21 <dfeuer> hackrilege, if I pass in (a -> f b), I need things above and things to the left to have type a,
13:10:25 <dfeuer> Sorry, type b,
13:10:39 <dfeuer> and things to the right, and below, and below things to the left, to have type b.
13:11:09 <dfeuer> hackrilege, yes, I have a general sense of how to make a zipper, but no sense at all of how that will help me.
13:12:05 <maerwald> dfeuer: you have the context of the whole tree and where you are
13:12:15 <hackrilege> Oh I see yes I think I remember that problem about not being able to change types while zipping
13:12:51 <dfeuer> maerwald, and ..... what do you do with it?
13:13:13 <maerwald> derive the tree-level you are in or whatever
13:13:18 <dfeuer> ?
13:13:40 <lyxia> Are we still talking about making a tree traversal
13:13:40 <hackrilege> Well, not with complex navigation (potentially repeated traversal of a subsection) but for just a single complete pass its ok
13:14:03 <dfeuer> Yes, lyxia.
13:14:12 <dfeuer> Specifically breadth-first.
13:14:26 <dfeuer> Or level-wise, or however you want to call it.
13:14:29 <maerwald> dfeuer: I don't understand the question. It seems to me you might want to read a tutorial on zippers to get a better understanding
13:14:54 <hackrilege> But isn't there a problem if you change the type of only the "upper" portion of a tree...
13:15:09 <dfeuer> maerwald, I've read zipper tutorials. I've implemented a few simple zippers. I don't understand how they relate to this problem.
13:15:12 <dfeuer> (yet)
13:15:26 <hackrilege> You would have to cast to an extra nesting of Either each time...
13:15:34 <dfeuer> Ewww.
13:16:04 <hackrilege> Are you sure a traversal at a set depth is well posed?
13:16:22 <hackrilege> Have you been able to do it?
13:17:15 <maerwald> I don't really understand what information is missing to implement the desired functionality, except for "no one has given me a concrecte implementation yet"
13:17:17 <lyxia> hackrilege: it's not at a set depth
13:18:59 <dfeuer> hackrilege, It's well-posed.
13:19:06 <dfeuer> I could write something. It would be horrible.
13:19:13 <maerwald> do it
13:19:33 <dfeuer> OK.
13:19:37 <lyxia> I think the key word in dfeuer's question is "a good way".
13:19:49 <maerwald> first, find a way, then, find a good way
13:19:52 <maerwald> it's called prototyping
13:20:27 <dfeuer> maerwald, all right. I just feel like none of the ideas I've run into have the right overall "shape", which makes me hesitant to spend time on them.
13:20:28 <maerwald> otherwise you'll waste more thoughts on the problem than might be required
13:20:31 <dfeuer> But I'll do it anyway.
13:21:21 <maerwald> it's also a much better basis for discussion if you have something that doesn't "feel right"
13:27:11 <hackrilege> Could you give a specification so I could have a go as well?
13:29:39 <int-e_> dfeuer: I'm wondering, do you have a use case for such a traversal?
13:30:11 <dfeuer> int-e, no, not particularly. But Data.Tree does offer a level-wise monadic *unfold*
13:30:29 <dfeuer> So I figure it should also offer a level-wise traverse.
13:31:17 <glguy> newhoggy: You needed to mark "mean" for inlining to get the vector to fuse away
13:32:00 <lyxia> hackrilege: define a traversal of  data Tree a = Tree a [Tree a]  that accesses elements closer to the root first.
13:32:47 <newhoggy> glguy, thanks for your help.  I tried {-# INLINE mean #-} just now.
13:32:53 <newhoggy> Same result so far.
13:33:06 <glguy> Then you need to make sure you've turned on optimizations
13:33:33 <hackrilege> Doesn't the one from the traversable documentation do that?
13:33:36 <hackrilege> traverse f (Node l k r) = Node <$> traverse f l <*> f k <*> traverse f r
13:34:08 <dfeuer> hackrilege, wrong kind of tree.
13:34:10 <hackrilege> (Not a rose tree...)
13:34:12 <dfeuer> And no.
13:34:17 <dfeuer> Definitely no.
13:34:36 <hackrilege> What's wrong in that example?
13:34:57 <glguy> Then you need to make sure you've turned on optimizations
13:35:02 <int-e> dfeuer: ugh, the code for that is not really pretty either
13:35:16 <glguy> With GHC 8.0.1, vector-0.11.0.0, and testing with -O2 the vector fuses away
13:35:16 <thepreacher> I have a minor issue with emacs indentation of haskell code ie. for an expression with multiple guards, the second guard doesn't line up below the first one. I have to manually tab to indent it. I thought it was my emacs setup playing up so I switched to spacemacs haskell layer and they have the same issue. Is this as good as it gets in emacs?
13:35:28 <dfeuer> hackrilege, the point is that given a tree like  Node 1 [Node 2 [Node 4 [], Node 5 []], Node 3 [Node 6 [], Node 7 []]]
13:35:28 <lyxia> hackrilege: you want Tree 1 [Tree 2 [Tree 4 []], Tree 3 []] traversed in this order: 1, 2, 3, 4
13:35:43 <dfeuer> Like lyxia said.
13:36:06 <dfeuer> int-e, nope, not at all.
13:37:09 <newhoggy> I'm using these: -threaded -rtsopts -with-rtsopts=-N -O2 -Wall -msse4.2 -funbox-strict-fields
13:37:23 <newhoggy> -O2 is in there.
13:38:08 <dfeuer> int-e, the Foldable instance is pretty reasonable.
13:39:06 <lpaste> glguy pasted “for newhoggy” at http://lpaste.net/347262
13:39:14 <newhoggy> Hmmm, could it be that the profiling I've turned on is defeating optimations?
13:39:27 <newhoggy> I get this without profiling:
13:39:55 <newhoggy> real  0m0.034s, user  0m0.021s, sys 0m0.013s
13:41:51 <implementation> thepreacher: afaik, emacs' haskell-mode has different indentation behaviours you can choose from. have a look at the settings category.
13:41:55 <newhoggy> Even just this is slow: stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto -rtsopts"
13:43:33 <newhoggy> This is slow too: stack build --executable-profiling
13:44:01 <glguy> Perhaps investigate what arguments stack is passing to ghc that's getting you the slower behavior
13:44:08 <newhoggy> i.e 10 seconds.
13:44:19 <newhoggy> Yeah, that could be it.
13:44:38 <newhoggy> With just "stack build", it runs in 0.049s
13:44:58 <newhoggy> Thanks for your help.
13:45:05 <shlevy> Are there any guarantees about the Fingerprint of a TypeRep?
13:45:07 <newhoggy> Maybe I'll go ask the stack people.
13:51:31 <hackrilege> dfeuer, I'm even having trouble writing the foldable instance... http://lpaste.net/347269
13:52:37 <lpaste> dfeuer pasted “Level-order fold” at http://lpaste.net/7468300343596548096
13:53:16 <dfeuer> hackrilege, you can use the `levels` function to do it, or you can do something slightly fancier like what I just pasted.
13:53:24 <hackrilege> Where do I get the basecase for folding each of the branches if I can't fold up a branch to get a value (as that's depth first)?
13:54:04 <dfeuer> Look at the levels function for the general idea.
13:54:34 <dfeuer> I don't know if using that or doing what I pasted is faster.
13:54:36 <implementation> thepreacher: this page lists many different modes for indenting haskell in emacs, they're all slightly different
13:54:45 <implementation> thepreacher: https://www.reddit.com/r/haskell/comments/2vwv77/how_should_i_indent_my_code_in_emacs/
13:55:24 <```a> is it ok to paste a two line snippet in here?
13:55:30 <thepreacher> implementation: Funny you sent this link, I'm reading it now :)
13:56:24 <hackrilege> Go ahead ```a
13:56:52 <```a> instance Monad m => Monad (MaybeT m) where
13:56:58 <```a> (indent) return  = MaybeT . return . Just
13:57:27 <```a> I'm trying to understand monad transformers, and I don't really get how/why return is in its own definition. 
13:57:40 <```a> Is it the return function for monad "m" here?
13:57:45 <lyxia> yes
13:57:56 <```a> And it knows to do this through the magic autoresolving type system thing?
13:58:07 <lyxia> type inference, yes
13:58:14 <```a> neat..
14:00:10 <hackrilege> Indeed! Super useful
14:00:39 <```a> makes it a bit harder to reason about for the untrained eye, however 
14:03:25 <hackrilege> Actually it forces you to understand and keep track of your types
14:04:14 <hackrilege> You can always define a synonym if you wish to remove the polymorphism
14:05:54 <hackrilege> dfeuer, sorry I'm not getting very far with helping you on this
14:06:17 <dfeuer> hackrilege, maerwald, I just came up with a simple lousy reference implementation.
14:06:35 <hackrilege> Let's see
14:08:04 <lpaste> dfeuer pasted “level-order traversal” at http://lpaste.net/2107164032623443968
14:08:17 <dfeuer> There you go, hackrilege 
14:08:24 <hackrilege> Thanks!
14:12:02 <hackrilege> I'm trying to get my head round that, let me read it again
14:12:11 <javjarfer> anyone knows the categorical name for a function that returns a functor?
14:13:10 * hackagebot hip 1.1.0.0 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.1.0.0 (lehins)
14:13:26 <dfeuer> javjarfer, isn't that a morphism in a functor category, or a functor into a functor category? I'm no category theorist though.
14:15:35 <hackrilege> Ok I get what your doing, I can't figure how to use that in a traversal though...
14:17:00 <javjarfer> dfeuer, but a morphism in a functor category is a map between functors, not something that lifts a morphism into a functor. Am I wrong?
14:17:26 <javjarfer> dfeuer, sorry "lifts a object into a functor"
14:18:06 <dfeuer> javjarfer, again, I don't know, but I suspect a discrete category could help?
14:20:08 <lyxia> are you asking what to call a morphism a -> f a for a functor f?
14:20:27 <lyxia> *endofunctor
14:20:40 <adiabat_> endocardium
14:24:09 <javjarfer> dfeuer, no idea xD. I'm looking at it, but I'm getting no conclusions. I have reached some point in a lib design in which I wanted to compair the strong and weakness of applicative functors combinators with combinators for functions
14:24:46 <javjarfer> lyxia, but... endofunctors map a category to itself, not objects in a category to the category of functors no?
14:25:57 <lyxia> javjarfer: I was making my statement about f more precise, not proposing a name
14:26:56 <dfeuer> javjarfer, you have a function  a -> Q, where Q represents functors from C to D, right?
14:27:20 <lyxia> ok you're actually looking for something that has the category of functors as the codomain...
14:27:45 <dfeuer> javjarfer, so what if you make the discrete category, A, over A?
14:28:11 * hackagebot serokell-util 0.1.2.1 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.1.2.1 (gromak)
14:28:13 * hackagebot scotty-format 0.1.0.1 - Response format helper for the Scotty web framework.  https://hackage.haskell.org/package/scotty-format-0.1.0.1 (potomak)
14:28:15 * hackagebot scotty-format 0.1.0.2 - Response format helper for the Scotty web framework.  https://hackage.haskell.org/package/scotty-format-0.1.0.2 (potomak)
14:28:22 <javjarfer> lyxia, sorry bad reading... yes, that was the question.
14:28:40 <dfeuer> javjarfer, are these functor endofunctors, or arbitrary ones?
14:29:07 <javjarfer> dfeuer, for simplicity lets say endofunctors
14:29:34 <dfeuer> Anyway, now the function maps objects in A to functors from C to D, and morphisms in A (all of which are identities) to (trivial) natural transformations between functors. 
14:29:35 <dfeuer> I think.
14:29:52 <dfeuer> But I'm officially way beyond what I know.
14:29:59 <dfeuer> Now if the functors are endofunctors,
14:30:14 <dfeuer> then they should form some sort of nice category, right?
14:30:38 <dfeuer> Actually, you don't need that.
14:30:44 <dfeuer> I'm thinking in the wrong direction, I believe.
14:31:11 <dfeuer> I *guess* probably you have a category of functors from C to D whose morphisms are the natural transformations, right?
14:31:44 <dfeuer> Now if you map each object in the discrete category A to a functor, and each (identity) morphism in A to the natural transformation from that functor to itself,
14:31:57 <dfeuer> don't you get a functor from A?
14:32:21 <dfeuer> That's gotta be right, javjarfer, because it sounds good :-)
14:33:05 <javjarfer> dfeuer, sorry I need more than a second for thinking about all of this... I'm still learning and I'm slower than a snail
14:34:33 <javjarfer> dfeuer, I think you are totally right... so it's a natural transformation
14:34:44 <dfeuer> javjarfer, I think it's a functor.
14:34:57 <dfeuer> javjarfer, a functor from a discrete category to a functor category.
14:35:41 <javjarfer> dfeuer, that makes even more sense
14:35:47 <dfeuer> So then generalizing, you can imagine a functor from an arbitrary category to a functor category, mapping objects to functors and morphisms to natural transformations.
14:38:00 <javjarfer> dfeuer, makes lot of sense, please explain me your mental process for this... because I'm way beyond that reasoning 
14:38:51 <dfeuer> javjarfer, piecing together ideas I'm only very vaguely familar with. I know that the idea of a "function" often ends up turning into a functor from a discrete category because edwardk told me so.
14:39:18 <dfeuer> I know there's such a thing as a functor category because I've heard of it, and I vaguely recall it involving natural transformations as morphism.
14:39:20 <dfeuer> *morphisms.
14:39:23 <dfeuer> So .... boom.
14:41:07 <javjarfer> dfeuer, okay... that key point of functions turning functors from a discrete category, omg... how much I need to learn of all of this
14:41:53 <javjarfer> dfeuer, thanks you a lot
14:42:06 <dfeuer> javjarfer, thank *you* for making me think about it.
14:42:17 <dfeuer> And you're welcome, of course.
14:46:37 <javjarfer> dfeuer, hahaha *you are welcome too* now I can at least make a model, getting conclusions... well that is another topic xD
14:49:19 <ertes> javjarfer: a function that returns a functor is just a function that returns a functor…  without more information there is nothing special or even categorical about it (it's just some morphism in Sets)
14:49:40 <ertes> or whatever foundation you're using in place of Sets
14:50:07 <monochrom> yeah, you have only specified the codomain. you should probably specify the domain too.
14:52:03 <ertes> javjarfer: actually i'm even hesitant to say that it's a morphism in Sets, because Sets doesn't have constraints, but it's definitely a morphism in the category of *types* in type theory
14:52:54 <javjarfer> ertes, monochrom, okay, my fault the full type of the combinators is: <|> :: f a -> f a -> f a *vs* <|> :: (s -> f a) -> ( s -> f a) ->  (s -> f a)
14:53:23 <manek> Hello! :) What is the type of such lens construction? I cannot get it right. `foo :: Lens' a (Map b c); bar :: Lens' c d; tst = foo . ix val . bar ; tst :: ?`
14:54:12 <ertes> javjarfer: i haven't read the full backlog, but s -> f a ≃ ReaderT s f a
14:54:20 <ertes> if that's of any use
14:55:19 <javjarfer> the point is that the second version, preserve the structure of the inner functors so, you don't loose the functor structure, but it should be differences, differences that I don't see, because it's taking me the life to model that in category theory xD
14:55:30 <javjarfer> ertes, it isn't exactly that
14:56:38 <ertes> manek: what do you think it is?
14:57:01 <ertes> javjarfer: what are you trying to model anyway?
14:57:08 <manek> ertes: it behaves somehow like `Lens' a d`
14:57:15 <ertes> manek: not quite
14:57:20 <manek> ertes: I know
14:57:29 <manek> ertes: but hmm, I cannot express it
14:57:30 <ertes> manek: do you see why this can't be a lens?
14:57:45 <manek> ertes: because the value could not exist there
14:57:58 <javjarfer> the point is, using full functors doesn't allow me to difference the type the things I combine so I can't distingish "incomplete" "f a", but using (s -> f a) as the parameter for the combinators, allows me to know that that are incomplete "f a" that needs to rececieve "s"
14:58:12 <manek> ertes: so theoretically it could be lens but unsafe one. Anyway, thats the reason I think
14:58:25 <ertes> manek: yeah…  and there is a generalisation of that: an optic that points to something that may be absent is a special case of an optic that points to arbitrarily many things
14:58:46 <ertes> manek: those optics are called traversals
14:58:57 <javjarfer> ertes, I'm modeling parser combinators (an applicative parser combinator)
14:59:08 <ertes> manek: every lens is a traversal, but not every traversal is a lens
14:59:37 <manek> ertes: yep, I understand it now, thanks! So hmmm, I'll try to use Travesal type then
14:59:43 <Jello_Raptor> So I'm trying to figure out how to make a monad to generate a SMT problem that gathers information about all its inputs as it goes along http://hastebin.com/cepecidahu.hs
14:59:46 <manek> I wish Ive got time to really deeply dig into lenses
15:00:10 <ertes> manek: you should invest that time =)
15:00:42 <ertes> javjarfer: what's wrong with the state model?
15:00:43 <manek> ertes: definitely, thank you for your help!
15:01:20 <javjarfer> ertes, the state model is monadic, i'm using a pure applicative approach 
15:02:32 <ertes> javjarfer: ok, but why?  do you have a particular reason to use the applicative approach?  i mean: there is good reasons why *users* would want to use the applicative interface, but do you have a reason specifically to make it a non-monad?
15:02:54 <ertes> javjarfer: (there are some valid reasons to do that…  i just want to make sure you have one) =)
15:06:20 <javjarfer> ertes, one principal reason is to have a pure parallel parser, another one, is that I don't really need the flexibility of a monad for the type of parsing I'm doing, I don't really need to being able to "change the grammar", and also, I was thinking in a special type of error reporting with "full backtrace"
15:07:25 <javjarfer> ertes, It was a small proof of concept library with those things in mind, I didn't want to complicate it using the state model
15:07:53 <javjarfer> ertes, model that I didn't need also xD
15:08:08 <ertes> javjarfer: consider that only a very narrow class of grammars can be parsed in parallel…  even regular languages are too dynamic
15:08:41 <ertes> javjarfer: "i don't need a monad" is not a good reason to *avoid* monads…  it's a good reason not to use their monadic interface…  if it's a monad, let it be a monad
15:09:00 <ertes> javjarfer: full backtraces are possible with monadic parsers
15:09:07 <ertes> (see trifecta)
15:09:55 <ertes> in general parsing is a stateful process…  if you want to go without state, you basically have to restrict yourself to fixed-width grammars
15:10:07 <Jello_Raptor> Is there a standard place to ask for longer form help for haskell stuff? Like a haskell stack overflow that the ommunity actually hangs out on? 
15:10:45 <ertes> Jello_Raptor: this is a good place…  just be patient =)
15:11:41 <dfeuer> Jello_Raptor, there are a good number of Haskellers on StackOverflow. There are also mailing lists (haskell-cafe and haskell-beginners)
15:11:42 <Tuplanolla> There's Stack Overflow and Reddit for blog-post-length questions, Jello_Raptor.
15:11:45 <javjarfer> ertes, I know that you would say trifecta... xD. Yes very few grammars can be parsed in pararallel, but this is for fixed grammars as you said, I didn't have any other thing in mind. Just regular logs formats and JSON files. Also, I wanted to see how much could I keep it pure applicative.
15:12:04 <dfeuer> Jello_Raptor, don't email haskell@haskell.org though. That's for announcements.
15:12:23 <javjarfer> ertes, I agree with you, in all about monadic parsers, but I simply didn't need all its features, so I decided to keep it more simple
15:13:03 <Jello_Raptor> ertes: its a matter of interaction modes. It's a realtively ocmple problem and I'd rather a mailing list of Q&A format. 
15:13:04 <ertes> javjarfer: a typical log file couldn't be parsed like that, and JSON is even worse
15:13:05 <javjarfer> ertes, maybe this experiment goes wrong xD and I end with a very limited parsing lib, but in that case, I would have learned a lot
15:13:25 <ertes> Jello_Raptor: ah, i see
15:13:32 <Jello_Raptor> dfeuer, Tuplanolla: cool, thank you. 
15:13:57 <ertes> javjarfer: so the way i would design this (and it would indeed be Applicative-only – no Monad):
15:14:45 <manek> Hmm, is there in haskell any combinator similar to monadic binding for Maybe, which will result `Just fv`, where `fv` is the first Just-value form list of Maybes or Nothing if everything was Nothing ?
15:15:33 <ertes> javjarfer: data Parser a = Parser Int (ByteString -> Maybe a)  -- here is a base design…  no error diagnostics, and limited to ByteString…  the Int specifies how much of the given string the parser uses
15:15:56 <ertes> javjarfer: then (<*>) would break the string apart and give each subparser the requested size of the input
15:16:08 <Jello_Raptor> manek: are you looking for something like `head . catMaybes :: [Maybe a] -> a' ? 
15:16:27 <Koterpillar> :t listToMaybe -- manek
15:16:28 <lambdabot> [a] -> Maybe a
15:16:32 <ertes> javjarfer: (i would have gone with Text, but unfortunately splitAt is O(n) for Text)
15:16:51 <javjarfer> ertes, no error diagnostics?? how would you know what has happened if that fails?
15:17:06 <manek> Jello_Raptor: nope, because it will not work if there everytihng is Nothing
15:17:08 <Tuplanolla> :t foldr (<|>) Nothing -- Here's a do-it-yourself version, manek.
15:17:10 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
15:17:13 <ertes> javjarfer: you can add error diagnostics by changing the Maybe into a suitable Either
15:17:20 <ertes> javjarfer: it's just to communicate the basic idea
15:17:20 <javjarfer> ertes, also I wanted to do a version in Applicative that is sequential and another one that is parallel
15:17:28 <Jello_Raptor> manek: ahh, I imsread `listToMaybe . catMaybes` then
15:17:57 <Jello_Raptor> :t listToMaybe . catMaybes
15:17:58 <lambdabot> [Maybe a] -> Maybe a
15:18:23 <ertes> javjarfer: i've used this design for genetic algorithms in the past, as an applicative language to design the population array
15:18:58 <manek> Tuplanolla: oh, alternative, yep that is what im loking for I think. Hmm, I've got to be tired to not figure it instantly by myself, thanks
15:19:18 <manek> Jello_Raptor: yep, but I was just looking for <|> ! thnk tyou guys! :)
15:19:31 <javjarfer> ertes, actually the type is  (Stream s) => Parser a =  s -> (Either a ParseError, s) being s a typeclass that represent a generic Stream
15:20:37 <ertes> javjarfer: you can parameterise it as you wish:  data ParserT e s m a = ParserT Int (s -> m (Either e a))
15:21:15 <javjarfer> ertes, haha yes, but that is already a monad, no monads allowed
15:21:21 <ertes> no, it's not
15:22:05 <javjarfer> ertes, what is "m" there? And Applicative Funtor?
15:22:12 <ertes> no, that one is a monad
15:22:36 <javjarfer> ertes, okay, I'm lost
15:22:50 <ertes> javjarfer: instance (Applicative m) => Applicative (ParserT e s m)
15:22:55 <ertes> m may very well be a monad
15:23:06 <ertes> but (ParserT e s m) isn't one
15:23:24 <javjarfer> ertes, ah okay okay I spot the difference, I keep that more simple
15:23:54 <int-e> dfeuer: I think the whole queue business is a bit too cute, and inherently monadic. http://lpaste.net/6407259987726303232 tries to keep things simple.
15:24:25 <int-e> dfeuer: warning I didn't test this and I'm about to go to bed
15:24:44 <dfeuer> int-e, I have already thoughct about ditching the queue.
15:24:51 <dfeuer> And wrote code to do so.
15:25:06 <dfeuer> But the performance implications are a bit hard for me to consider.
15:26:10 <javjarfer> ertes, where I found the issue, where when I wanted to develop a way to distingish the "parsers" from the parts they are made. Let me explain that, when you use the combinators to create a bigger parser, that bigger one isn't called the same, doesn't have the same error message, etc. In fact, is another "step" in the backtrace.
15:26:24 <dfeuer> int-e, that splitByLength is cool. It does have some risk of leaking space, no?
15:26:39 <dfeuer> (I mean the general approach of keeping the original tree around for its lengths)
15:26:52 <dfeuer> Oh, but I guess you can fill it with ()?
15:27:00 <dfeuer> Feh.
15:27:14 <dfeuer> Or not worry about it
15:27:15 <int-e> dfeuer: yeah, I don't want to guess about the impact either. the old code has the same space problem. and actually one should compress this down to list lengths.
15:27:28 <int-e> (if one worries about memory usage)
15:27:32 <javjarfer> ertes, so there in when I started to think about, which is the difference (the categorical one), between using the combinators to create bigger parsers from parsers or from the functions that would represent incomplete parsers
15:27:36 <ertes> javjarfer: you should keep in mind that (<*>) cannot introduce names anyway…  you need a special combinator for that (commonly named (<?>))
15:28:11 <int-e> dfeuer: those lengths could be produced as a byproduct of an adapted version of "concat".
15:28:17 <dfeuer> int-e, the old code is disgusting. I just need some benchmarks (preferably based on actual use-cases).....
15:28:29 <dfeuer> int-e, yes, that makes good sense.
15:28:35 <int-e> dfeuer: but I didn't want to go there, especially after midnight.
15:28:39 <dfeuer> :)
15:29:07 <javjarfer> ertes, yes, I know, but I have an issue with that combinator. An issue I can't renember right now... I'm going to see the notes xD
15:29:07 <dfeuer> int-e, this all looks similar to the code I wrote, but maybe somewhat cleaner.
15:29:53 <ertes> javjarfer: in general there is no need for a first class representation of this information…  what i would do is to make the error type a tree type and make (<?>) just wrap that tree in failure cases…  that gives you a full backtrace
15:30:06 <dfeuer> int-e, really, I should get back to integrating your Integer-parsing code....
15:30:16 <dfeuer> That's probably bigger-impact.
15:30:30 <alx741> hello everyone
15:30:56 <alx741> If I have a matrix [[Int]] How could I replace an element at a specific index (x,y)?
15:31:28 <Koterpillar> alx741: take a square root of your problem
15:31:33 <ertes> javjarfer: for example let the error type be a simple list of names
15:31:42 <Koterpillar> alx741: if you have a list of type [a], how do you replace an element at index x?
15:31:47 <ertes> javjarfer: ParserT n f <?> name = ParserT n (\s -> either (name :) id <$> f s)
15:31:58 <ertes> javjarfer: this gives you a full backtrace
15:32:02 <ertes> (on error)
15:32:32 <javjarfer> ertes, I renember! If you introduce a combinator like that doesn't change the type, and inyect something into it, you can't difference by type from a full parser, to and "incomplete" one
15:32:53 <ertes> javjarfer: what is an "incomplete" parser?
15:32:53 <javjarfer> ertes, that was my main issue with the use of such combinator
15:32:59 <alx741> Koterpillar: hmm a recursive function? I'm trying that, but a bit stuck with it
15:33:17 <alx741> The actual matrix is a [[Cell]] where Cell is an ADT
15:34:00 <alx741> so I have a function replaceNth :: Int -> Cell -> [Cell] -> [Cell]  for replacing a single elment in a [Cell], but then extending it to the matrix gives me problems
15:34:00 <javjarfer> ertes, a parser with no "correct error info" for example the result of mixing parsers throught the option combinator <|> could lead a parser that could need a totallly different error message.
15:34:07 <int-e> dfeuer: anyway, thanks for the puzzle and good night
15:34:30 <Koterpillar> alx741: does your replaceNth have to work with Cells? Maybe it can be generalized?
15:34:32 <ertes> javjarfer: what semantics would (<|>) have in the case of ParserT?
15:34:42 <Koterpillar> alx741: Int -> a -> [a] -> [a]
15:34:56 <ertes> javjarfer: example:  ParserT 0 f <|> ParserT 1 g = ParserT n _  -- what is n?
15:34:57 <javjarfer> ertes, but you can't spot the difference between that "full parser" and another one that only has a list of the probed options as error message, because they have the same type!
15:35:20 <alx741> Koterpillar: ooh.. I see where that is going... will try that out, thanks!
15:36:09 <javjarfer> ertes, 1 || 0 
15:36:21 <ertes> javjarfer: that's a type error
15:37:22 <dfeuer> Night, int-e 
15:37:33 <javjarfer> ertes, omg I see, you are produccing a newtype each type you use that combinator?
15:38:18 <ertes> javjarfer: not at all…  the point is that you are not *supposed to* be able to tell the difference between a parser that used (<|>) and one that didn't – from outside
15:39:12 <javjarfer> ertes, okay, but that is the point I'm not happy with
15:41:24 <ertes> javjarfer: why would you care?
15:42:34 <ertes> javjarfer: (p1 <?> "variant 1") <|> (p2 <?> "variant 2")  -- that's how it's done normally
15:42:46 <ertes> and you can give the whole thing a name, too
15:42:54 <javjarfer> ertes, because, I don't want that anyone can write a parser which lacks of "complete debugging info" if I can't see the differente by type, I can't do that
15:43:07 <ertes> (p1 <?> "variant 1") <|> (p2 <?> "variant 2") <?> "two variants"
15:43:21 <javjarfer> ertes, yes, that was the current approach in my lib
15:44:42 <ertes> on a more pragmatic note: do you really expect your users to screw up writing a fixed-width grammar to such an extent that you need super-fancy error reporting?  i mean syntax is rarely the main issue from a user perspective =)
15:45:26 <ertes> you couldn't even parse a number, unless you enforce a certain number of digits
15:47:52 <javjarfer> ertes, I know that those are the consecuences xD, and that is a drastic approach. But it's normally the way I write things and I wanted something to enforce me to write that way
15:48:27 <ertes> i really wonder what your haskell code looks like =P
15:49:00 <ertes> anyway, (<|>) has monoid laws, so you (pretty much) can't introduce new information using it
15:49:56 <javjarfer> ertes, hahaha I promise isn't that extrange soon I will open this lib so anyone can see it
15:50:20 <ertes> (<*>) has similar laws to make it…  i'd call it "natural"
15:51:23 <ertes> so any parser-specific information you want to introduce you have to introduce by separate combinators
15:51:37 <javjarfer> ertes, I didn't want to make that thourgh that combiantors, I wanted to make it using the combinator combine funcitons (s -> Parser)  to produce another parser, and then feed that function with the mensaje
15:51:49 <javjarfer> message*
15:52:13 <ertes> javjarfer: i'm not sure what that means…  i suggest you just try to implement it now and see how far you get
15:53:39 <javjarfer> ertes, okay, but that was an idea, that is why I was wondering, how looks both ways in a cathegorical model
15:53:56 <javjarfer> "how both ways look"
15:54:35 <xocolatl> what's a good way to add \n to a list of strings?  intercalate "\n" lst  works but I need one on the end, too
15:55:36 <Koterpillar> xocolatl: do you need a list of strings in the end?
15:56:03 <xocolatl> a single string is fine
15:56:30 <xocolatl> basically, I have a grid represented as [[t]] and I want to print it
15:57:19 <javjarfer> ertes, also, the other thing means I thought on combinators having types <|> :: (em -> Parser a) -> (em -> Parser a) -> (em -> Parser a), so, all of those parsers need their "Error message" to be complete, and then, after combining them, you feed them the error message
15:57:27 <xocolatl> I made a function to turn t into a string, and a function to turn [t] into a string, now I'm working on the final part
15:58:00 <xocolatl> hmm.  I guess intercalate with putStrLn should work
15:58:24 <xocolatl> and it does
15:59:25 <ertes> javjarfer: the type system will tell you when you have a conceptual error…  just try it =)
15:59:44 <pavolzetor> I am trying to read BIL files (essentially binary array of int16). Is there a simple way to read them into array? The bil files are heightmaps
15:59:56 <ertes> > foldr (\xs ys -> xs ++ '\n' : ys) [] ["abc", "def", "ghi"]
15:59:58 <lambdabot>  "abc\ndef\nghi\n"
16:00:01 <MarcelineVQ> xocolatl: that's a solution, concatMap (++"\n") or unlines both will add \n to every item and concat the result as well
16:00:04 <ertes> javjarfer: like this?
16:00:11 <ertes> whoops
16:00:15 <ertes> xocolatl: like this?
16:00:20 <xocolatl> MarcelineVQ: ah!  forgot about unlines
16:00:44 <ertes> yeah, concatMap is nicer
16:01:31 <ertes> i recommend concatMap (++ "\n") over unlines
16:01:55 <Axman6> depends what behaviour you want
16:02:24 <tnks> hmm, just tried to run the haskdogs command to generate a TAGS file.
16:02:26 <ertes> oh wait
16:02:28 <tnks> it's still running.
16:02:37 <ertes> unlines actually adds a '\n' at the end
16:02:43 <ertes> scratch everything i wrote =)
16:02:57 <javjarfer> ertes, ok! I will try! I'm normally insecure in doing things different than normal haskell patterns because the usually came from category theory, and it's a field in which I barely can read about xD
16:03:03 <pavolzetor> also, should I use Array or Vector?
16:03:47 <ertes> pavolzetor: you can easily go from Ptr/ForeignPtr to storable Vector
16:04:17 <pavolzetor> how? currently I use data.binary
16:04:22 <tnks> I have a feeling it's markedly less efficient than aloiscochard's codex project.
16:04:44 <ertes> pavolzetor: if by any chance those heightmaps are in an image format, you can save yourself a lot of trouble by using JuicyPixels
16:04:49 <tnks> I was just seeing how long I could delay having to dig into that code to get codex working with multiple Stack projects.
16:04:51 <pavolzetor> (they are 2d arrays)
16:05:28 <ertes> pavolzetor: JuicyPixels goes from image file to raw Vector and back full-cycle
16:06:12 <ertes> https://hackage.haskell.org/package/JuicyPixels
16:06:55 <pavolzetor> hmm, why do they use vector instead of array?
16:07:24 <ertes> likely because the vector library is a lot more versatile and has a nicer stream-fusing API
16:08:39 <pavolzetor> I see, I searched the foreign ptr
16:08:51 <pavolzetor> I will change the code to it
16:39:48 <grazie> if you call minimum func on this list as in -- `minimum [(9,(('A','1'),"123456789")),(8,(('A','2'),"12356789"))]` -- what is minimum using to determine the minimum value?
16:40:30 <Koterpillar> grazie: Ord
16:40:32 <geekosaur> the definition of (<) for each type (see the Ord typeclass)
16:40:46 <grazie> so, in the list I presented, it's the 8 ?
16:40:56 <grazie> and not the list of "12356789"
16:41:01 <Koterpillar> it wouldn't be
16:41:09 <Koterpillar> just 8 is the wrong type
16:41:15 <Koterpillar> it's the tuple starting with 8
16:41:18 <hackrilege> > minimum [(9,(('A','1'),"123456789")),(8,(('A','2'),"12356789"))]
16:41:21 <lambdabot>  (8,(('A','2'),"12356789"))
16:41:44 <geekosaur> and for tuples, Ord sorts them in order so the second element would be sorted inside the first, a third element inside the second, etc.
16:42:02 <geekosaur> (presuming preceding elements are the same)
16:42:07 <grazie> Koterpillar: ok, but to determine that, it's using the fst element of the tuple (i.e. the 8)?
16:42:18 <hackrilege> > minimum [(2,1),(1,50)]
16:42:20 <Koterpillar> what geekosaur said
16:42:20 <lambdabot>  (1,50)
16:42:45 <grazie> geekosaur: not sure what that means i.e. "so the second element would be sorted inside the first"
16:42:46 <Koterpillar> > minimum [(2,1), (1,40), (1,20)]
16:42:48 <lambdabot>  (1,20)
16:42:49 <Cale> grazie: It's using the lexicographic order, so it compares the first components, and if they're equal, it compares the second, and so on
16:43:12 <geekosaur> if you have two tuples whose first elements are equal, the second elements will be compared.
16:43:38 <geekosaur> if the first and second elements are equal and they have 3 elements, the third will be compared
16:43:47 <geekosaur> but if the first element differs between them, they will be ordered by that
16:44:11 <grazie> geekosaur: so 8 is less than 9, that's why my example returns the tuple starting with 8. is that correct?
16:44:17 <geekosaur> yes
16:44:22 <grazie> ok, thank you
16:44:23 <hackrilege> > minimum [(a,b)|a<-[2..10],b<-[1..10]]
16:44:26 <lambdabot>  (2,1)
16:45:06 <buttbutter> I'm looking to potentially use haskell for some basic scientific computing stuff for my machine learning class. I was wondering if anyone had any input if this was a good idea (I also want to use it as an opportunity to get better at Haskell) and what packages I might want to look at. HaskellR seems compelling (but I don't know R!). Any other suggestions?
16:45:20 <hackrilege> That was supposed to illustrate how generators spin the leftmost value first...
16:45:28 <grazie> would you call this a tuple inside a tuple? (9,(('A','1'),"123456789"))
16:45:40 <grazie> snd (9,(('A','1'),"123456789"))
16:45:46 <LordBrain> looks like it
16:45:48 <grazie> > snd (9,(('A','1'),"123456789"))
16:45:51 <lambdabot>  (('A','1'),"123456789")
16:46:20 <grazie> okok, thank you all
16:46:47 <hackrilege> I'm not sure about machine learning but Haskell should be perfect
16:47:02 <grazie> hackrilege I'm missing the point (if your example was directed at me) minimum [(a,b)|a<-[2..10],b<-[1..10]]
16:47:32 <wespiser> hackrilege: yea, it should, but its behind in terms of libs compared to R, python, and Julia
16:47:37 <wespiser> Scala too
16:47:57 <wespiser> Haskell is just bad for data science, sucks to say
16:48:31 <wespiser> try doing a Cholesky decomposition in Haskell
16:49:09 <buttbutter> :(
16:49:29 <buttbutter> wespiser: So...suck it up and use NumPy?
16:49:47 <wespiser> haha
16:50:01 <hackrilege> Haskell has outperformed all other languages in all my applications to scientific data, I'll look into that decomposition now
16:50:14 <wespiser> where is that data coming from?
16:50:23 <grazie> I'm a little confused by the pattern matching in this code excerpt. if it's not an empty list, then it matches the `ls` but why isn't the ls inside a `[ls]` to show it's a list? https://gist.github.com/4631b851ae09a02a993043671f195abd
16:50:50 <hackrilege> https://hackage.haskell.org/package/hmatrix-0.15.0.1/docs/Numeric-LinearAlgebra-Algorithms.html#g:7
16:50:54 <wespiser> don't get me wrong, I love Haskell, and I'm Data Scientist that uses Haskell at work, but we have a very very very long way to go
16:51:08 <Gurkenglas_> grazie, [ls] would mean it's a list with the single element ls
16:51:32 <hackrilege> Oh I think it uses ffi, my bad
16:51:52 <hackrilege> I can't think why it would be hard in Haskell
16:51:55 <wespiser> the matrix manipulation is Haskell isn't great, its really clunky
16:52:05 <grazie> Gurkenglas: ok, so [] is an empty list, and `ls` is any other kind of list, including a list with one element?
16:52:10 <hackrilege> I wrote a nice stencil convolution
16:52:31 <wespiser> historically, all the matrix manipulation code was written in the 1950s and 60s, and all other languages just call that code
16:52:43 <wespiser> we are pretty much black boxing it
16:52:48 <Gurkenglas> grazie, yep. The lists that aren't empty would have form x:xs, where x is the first element and xs the list of remaining elements
16:52:55 <wespiser> and that shit is central to data science 
16:53:02 <hackrilege> Blas they call em
16:53:13 <Gurkenglas> grazie, ls can also be the empty list, but that's caught by the previous cae
16:53:15 <Gurkenglas> *case
16:53:41 <grazie> ok, thank you
16:53:56 <wespiser> Haskell would be incredible at closing the gap between data exploration and production deployment in data science
16:54:02 <hackrilege> That's definitely part of my job to address, and no, I have not had trouble using Haskell, Repa is pretty good.
16:54:47 <xcmw> Why does GHC say it does not support imprecative polyphism when it does if you enable imprecative types?
16:55:38 <hackrilege> I wrote a mhd solver in matlab once and inheritance was simply a nightmare
16:55:49 <wespiser> matlab is less than ideal
16:56:30 <Axman6> wespiser: that's not exactly an accurate description of things like BLAS, their interfaces are as old as time, but their implementations are constantly improved to use new CPU features
16:56:42 <geekosaur> xcmw, because ImpredicativeTypes doesn't really work
16:57:15 <geekosaur> it's a hack, it breaks very often (and in fact is broken again in 8.0.2 but nobody cares because it's going away), it was never reliable
16:57:29 <hackrilege> My reason for using Haskell for crunching was to reduce reliance on opaque overhead, then I discovered lens...
16:58:24 <wespiser> Axman6: yea, I'm actually roughly aware of the numerical stability algorithms used in the decompositions
16:59:29 <xcmw> geekosaur: Will there be a replacement?
16:59:50 <Gurkenglas> Why would Impredicative Types be hard to implement, when you can reduce each use of them by a newtype that goes away at compile-time anyway?
17:00:16 <geekosaur> you can do most of it with VisibleTypeApplication now, there will be some enhancements to that as I understand it
17:00:18 <geekosaur> if needed
17:00:37 <Gurkenglas> -reduce+replace
17:01:38 <xcmw> geekosaur: It worked for me. I was able to make Lens' (forall t. A t -> k t) (k Z) were A is a GADT
17:03:04 <geekosaur> https://mail.haskell.org/pipermail/ghc-devs/2016-October/012963.html
17:03:19 <geekosaur> xcmw, that's nice. don't rely on it
17:03:34 <pavolzetor> is there intmap or graph that supports 64 bit keys?
17:04:08 <Axman6> IntMap should
17:04:18 <Axman6> @hoogle IntMap
17:04:20 <lambdabot> module Data.IntMap
17:04:20 <lambdabot> Data.IntMap.Lazy data IntMap a
17:04:20 <lambdabot> Data.IntMap.Strict data IntMap a
17:04:45 <Axman6> also HashMap - which you use probably depends on if you need ordering of keys
17:05:10 <Axman6> (since Hashable's hasn just returns an Int as the hash)
17:05:30 <pavolzetor> both intmap and datagraph use int which on hoogle it says is Int
17:05:53 <Axman6> Int is 64 bit on 64 bit systems
17:06:01 <pavolzetor> oh
17:06:06 <xcmw> geekosaur: I was trying to see if I could emulate a record with a GADT. It ended up working. It just requires boxing and unboxing of every field.
17:06:10 <pavolzetor> that solves it
17:06:13 <pavolzetor> thanks
17:06:55 <geekosaur> note that IntMap isn't always better than Map anyway, so Map Int64 whatever is portable to 32 bit and might not cost you much if anything
17:07:58 <grazie> If I run this command (from yesod quickstart) is it going to install ghc again on my system:   stack build yesod-bin cabal-install --install-ghc
17:08:18 <Axman6> I would be pretty surprised if it did
17:08:34 <grazie> I'm worried about it using all my remaining disk space (which isn't much)
17:08:36 <MarLinn> grazie, it will install a second ghc in the project folder only for this project
17:08:38 <Gurkenglas> Why would Impredicative Types be hard to implement, when seeing every type constructor as its CPS'd form turns everything into RankNTypes?
17:08:50 <Axman6> usually running `stack setup` is how you'd install the appropriate GHC if necessary
17:09:18 <grazie> MarLinn: if I leave it off, will it default to my ghc that I have globally installed?
17:09:20 <Axman6> MarLinn: eh? got some docs for that?
17:10:00 <MarLinn> Axman6, not off hand, but I've tried it on several systems
17:10:28 <grazie> ok, i have 4.82 gb remaining before running... here goes...
17:10:40 <Axman6> are you sure it's project specific and not user specific? there's no reason to have a project specific ghc installed
17:10:52 <grazie> it seems to be project specific: "Preparing to install GHC to an isolated location...
17:11:09 <grazie> seems wasteful
17:11:18 <grazie> but I guess tehre's good reasn.
17:11:19 * Koterpillar checks
17:11:25 <MarLinn> Uhm... Ok, that could be
17:11:26 <geekosaur> Gurkenglas, I suggets you talk to the GHC devs
17:11:36 <Koterpillar> it's per-user
17:11:58 <geekosaur> also check the history of the extension, since you seem to think it is simple and there is a lot of ugly past history including multiple rewrites to try to make it behave
17:12:02 <grazie> "This will not interfere with any system-level installation"
17:12:08 <MarLinn> But if the system ghc is the right version you can convince stack to use that, too
17:12:10 <geekosaur> if you're really so much smarter, maybe you can fix it
17:12:26 <Axman6> grazie: it you leave it off, it'll just use the system ghc, if it's the right version
17:12:33 <grazie> MarLinn: how? it would just default  to system?
17:12:37 <Axman6> yes
17:12:53 <Axman6> if it's the right version for the lts you're using
17:13:56 <nshepperd> Gurkenglas: for a start you can't just CPS type constructors when there are GADTs involved, I think
17:13:57 <grazie> so when I scrap the project, and I delete the folder, then this version of ghc will be hidden in some other folder (/private/var/folders/5y/ ...) I've probably forgotten about
17:14:47 <geekosaur> probably under ~/.stack or ~/.stack-work. but note that stack doesn't really "reinstall" most things, it caches them and uses those
17:15:24 <nshepperd> Gurkenglas: I don't know if newtypes can do everything that impredicative can, but even there it's not necessarily true that you can type check it (let alone type inference) without the information from explicit use of the newtype constructor
17:16:16 <begriffs> Is this not a real extension? NewQualifiedOperators
17:17:04 <begriffs> A certain library defines its own (<>) and I want to use that specific one infix like `PP.(<>)` where I imported the module as PP.
17:17:04 <MarLinn> Just watch what it says. GHC will take long enough to install that you should be able to read where it writes its stuff
17:17:22 <nshepperd> like, using a newtype constructor clearly delimits where the polymorphism is being used in a way that impredicative does not
17:18:03 <nshepperd> begriffs: I think the syntax for that is 'foo PP.<> bar'
17:18:31 <Axman6> or (PP.<>) in prefix IIRC
17:18:42 <geekosaur> yes
17:18:52 <grazie> I had  4.82 gb before install, now I'm down to 3.21
17:19:53 <Koterpillar> grazie: stack path | grep compiler-exe
17:20:21 <Koterpillar> actually, just stack path, it'll list all of the things that you'll likely want to know anyway
17:20:43 <grazie> Koterpillar: thank you, so this would be the isolated version of ghc that I should delete later (and not the system level): .stack/programs/x86_64-osx/ghc-7.10.3/bin/ghc
17:21:25 <Koterpillar> yes, and probably the other directories mentioned in stack path too
17:23:56 <MarLinn> grazie, if you absolutely need that space, you can build yesod apps with system ghc and system cabal only, completely without stack. But it's not really fun
17:24:53 <grazie> MarLinn: ok, thank you, it's still nto finished building, and now I'm down to 2.72 gb -- i.e. it's taken more than 2 gb of space to download build all dependencies
17:25:30 <Koterpillar> grazie: I don't think system GHC, dumping stack for cabal, or anything else will save you there
17:26:17 <grazie> where will all these packages be installed to that are being installed for this demo project?  http2-1.6.2: build wai-extra-3.0.19: copy/register http2-1.6.2: copy/register warp-3.2.9: download warp-3.2.9: configure warp-3.2.9: build
17:26:38 <Koterpillar> stack path
17:26:58 <Koterpillar> local-pkg-db
17:27:12 <Koterpillar> or possibly snapshot-
17:27:36 <grazie> ok, thank you
17:42:14 <grantwu> If I have a data Foo bar baz
17:42:29 <grantwu> can I instance Show Foo?
17:42:59 <grantwu> Like, all I need is for bar and baz to be types that are instances of show
17:43:04 <geekosaur> if bar and baz have Show instances (i.e. you need to add that is a constraint)
17:43:35 <geekosaur> instance (Show bar, Show baz) => Show (Foo bar baz) where ...
17:43:49 <geekosaur> if you use deriving, it adds those constraints automatically
17:47:23 <grantwu> I knew deriving would do it automatically; thanks geekosaur for the syntax for adding the constraints
17:48:07 <grantwu> I needed a custom instance
17:51:44 <pavonia> Don't misuse Show for anything other than converting to a Haskell representation of your values
17:53:00 <grantwu> Yeah, it's for debugging output 
17:53:17 <jle`> grantwu: do you mean 'data Foo bar baz', actually?
17:53:29 <jle`> because i think that Show instance can be generated even if bar and baz arne't instances of Show
17:53:35 <jle`> @let data Foo bar baz deriving Show
17:53:37 <lambdabot>  .L.hs:165:27: error:
17:53:37 <lambdabot>      • Can't make a derived instance of ‘Show (Foo bar baz)’:
17:53:37 <lambdabot>          ‘Foo’ must have at least one data constructor
17:53:42 <jle`> ah hm
17:53:51 <jle`> that's odd
17:53:55 <jle`> i'd expect for that to work
17:53:56 <grantwu> as geekosaur said, deriving adds the constraints automatically
17:54:05 <jle`> i mean, it depends on what the data type actually is
17:54:07 <grantwu> But I need a custom instance so I need to add the constraints myself too
17:54:20 <jle`> if you never have any values of type 'bar' or 'baz', you wouldn't need a Show instance for them
17:54:25 <grantwu> True, yeah
17:54:33 <grantwu> that would be... a phantom type?
17:54:37 <jle`> yeah
17:55:18 <grantwu> Yeah it turned out I didn't need the constraint on baz either, I ignore those in my custom show instance
17:56:01 <jle`> nice :)
17:56:11 <geekosaur> why would that work without data constructors? doesn't that make it hard to have values to use Show on? much less figure out how to build the instance...
17:56:49 <grantwu> I have data constructors, I just left them out
17:57:37 <jle`> geekosaur: well, the show instance is unique
17:57:42 <jle`> er, the implementation of 'Show' is unique
17:57:46 <jle`> s/Show/show
17:58:13 <jle`> there is only one unique implementation of a forall bar baz. Foo bar baz -> String
17:58:20 <jle`> so it would make sense to have Show
17:58:34 <jle`> that is, show = absurd
17:58:48 <jle`> there is a Show instance for 'Void' after all
17:59:04 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Void.html#t:Void
17:59:27 <jle`> meant to link to http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Void.html#line-50
18:07:46 <meissa> I kept my eye on the two frp books in the wiki, but just found out they are written for languages I don't know (scala), barely used (javascript), or dislike (java). Are there any FRP books for haskell ?
18:08:07 <grantwu> > show ("test" :: ShortByteString)
18:08:09 <lambdabot>  error:
18:08:09 <lambdabot>      Not in scope: type constructor or class ‘ShortByteString’
18:08:19 <grantwu> hrm...
18:08:20 * hackagebot line 1.0.1.0 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-1.0.1.0 (noraesae)
18:11:05 * geekosaur thought that type was not supposed to be exposed anywhere...
18:11:24 <grantwu> Which type?
18:11:41 <geekosaur> ShortByteString
18:11:47 <geekosaur> so it wouldn't be in the bot
18:12:09 <geekosaur> and may have pieces missing
18:12:46 <grantwu> ah
18:12:51 <grantwu> well, it's in Data.Bytestring.Short
18:13:38 <qmm> what is it about certain symbols which allow them to be used in an infix style such as (*) ?
18:13:51 <qmm> in an infix style without requiring ticks
18:14:05 <Koterpillar> :t isAlpha
18:14:06 <lambdabot> Char -> Bool
18:14:13 <Koterpillar> > isAlpha '*'
18:14:15 <grantwu> How do I convert a ByteString to a String?
18:14:15 <lambdabot>  False
18:14:20 <Koterpillar> :t isLetter
18:14:22 <lambdabot> Char -> Bool
18:14:26 <Koterpillar> qmm: ^
18:14:47 <Axman6> grantwu: that depends on what sort of data is contained in the bytestring.
18:14:55 <grantwu> Assume UTF-8
18:15:07 <qmm> thanks Koterpillar 
18:16:15 <geekosaur> qmm, more precisely the Haskell Report says Unicode codepoints with a Symbol Unicode attribute can be used as part of infix operators
18:16:26 <Koterpillar> :t isSymbol
18:16:27 <lambdabot> Char -> Bool
18:16:42 <Koterpillar> > filter isSymbol [chr 0..]
18:16:45 <lambdabot>  "$+<=>^`|~\162\163\164\165\166\168\169\172\174\175\176\177\180\184\215\247\7...
18:16:55 <grantwu> Axman6: I think Data.ByteString.UTF-8 does what I want
18:17:52 <geekosaur> grantwu, I think the preferred way is via Text then Text.unpack to String.
18:18:10 <Axman6> grantwu: generally Text would be a better option here
18:18:21 <geekosaur> @hoogle decodeUtf8
18:18:22 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
18:18:22 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
18:18:22 <lambdabot> Data.Conduit.Text decodeUtf8 :: MonadThrow m => Conduit ByteString m Text
18:19:16 <lordcirth> Is it possible / a good idea to generate a record-style datatype with a custom constructor?
18:20:07 <grantwu> Hrm... well, this is a weird codebase.
18:20:13 <Axman6> "a custom constructor"?
18:20:36 <Axman6> > text $ filter isSymbol [chr 0..]
18:20:39 <lambdabot>  $+<=>^`|~¢£¤¥¦¨©¬®¯°±´¸×÷˂˃˄˅˒˓˔˕˖˗˘˙˚˛˜˝˞˟˥˦˧˨˩˪˫˭˯˰˱˲˳˴˵˶˷˸˹˺˻˼˽˾˿͵΄΅϶҂֍֎֏...
18:21:06 <lordcirth> Axman6, basically I want a record-style datatype, but some of the fields will always have the same starting values, so they shouldn't need to be specified
18:21:33 <lordcirth> Or rather, they will always start the same as another field
18:21:40 <geekosaur> sounds like smart constructor time to me
18:21:44 <Axman6> yeah
18:21:53 <geekosaur> which may be what you meant
18:22:04 <Koterpillar> lambdabot has broken line wrapping
18:22:14 <Koterpillar> > text $ reverse $ filter isSymbol [chr 0..]
18:22:16 <lambdabot>  🢭🢬🢫🢪🢩🢨🢧🢦🢥🢤🢣🢢🢡🢠🢟🢞🢝🢜🢛🢚🢙🢘🢗🢖🢕🢔🢓🢒🢑🢐🢇🢆🢅🢄🢃🢂🢁🢀🡿🡾🡽🡼🡻🡺🡹🡸🡷🡶🡵
18:22:17 <lambdabot> 🡳🡲🡱🡰🡯🡮🡭🡬🡫🡪🡩🡨🡧🡦🡥🡤🡣🡢🡡🡠🡙🡘🡗🡖🡕🡔...
18:22:31 <geekosaur> heh
18:23:01 <lordcirth> If I am understanding https://wiki.haskell.org/Smart_constructors correctly, they are just normal functions, which happen to wrap constructors?
18:23:06 <Koterpillar> yes
18:23:07 <geekosaur> yep
18:23:21 <geekosaur> but usually used without exporting the real one, so it becomes the de facto constructor
18:23:30 <lordcirth> Right
18:23:34 <grantwu> Oh, darn, you are right, Data.ByteString.UTF8 is not a standard package
18:32:07 <MarLinn> Actually, it's often best to export smart constructors instead of real constructors even if you don't "need" them now. That makes it easier to change the API later.
18:32:46 <lpaste> xcmw pasted “Any way to make this code shorter” at http://lpaste.net/8053454659462889472
18:33:49 <qmm> when is something considered an operator and when is it considered a function?
18:34:06 <lpaste> xcmw revised “Any way to make this code shorter”: “Any way to make this code shorter” at http://lpaste.net/8053454659462889472
18:35:42 <Axman6> qmm: there's no actualy difference, but operators are generally written infix and don't start with an alpha character
18:36:13 <glguy> qmm: operator and function are n different categories of terminology
18:37:49 <glguy> operators are backticked names or symbols names
18:37:55 <glguy> like `this` or +-*
18:38:15 <glguy> functions are values with types (a -> b) for some a and b
18:38:46 <glguy> operator has to do with syntax, function has to do with type
18:39:18 <qmm> operators are functions in haskell, right?
18:39:30 <qmm> but functions aren't necessarily operators :)
18:39:52 <glguy> and operator symbols aren't necessarily functions
18:39:59 <qmm> oh
18:41:21 <qmm> > (>|<) = 3
18:41:23 <lambdabot>  <hint>:1:7: error:
18:41:23 <lambdabot>      parse error on input ‘=’
18:41:23 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:41:29 <qmm> > let (>|<) = 3
18:41:32 <lambdabot>  <no location info>: error: not an expression: ‘let (>|<) = 3’
18:41:56 <geekosaur> lambdabot is not ghci, it wants complete expressions
18:42:00 <Koterpillar> @let (>|<) = 3
18:42:02 <lambdabot>  Defined.
18:42:03 <hnewbie> having a problem installing present
18:42:10 <Koterpillar> (>|<) + (>|<)
18:42:12 <Koterpillar> > (>|<) + (>|<)
18:42:15 <lambdabot>  6
18:42:41 <qmm> if >|< is defined to represent 3, is it still considered an operator?
18:42:54 <glguy> >|< is an operator symbol
18:43:11 <hnewbie> I ran  sh install-to-glob sh and got ghc-pkg: /var/lib/ghc/package.conf.d/: openTempFileWithDefaultPermissions: permission denied (Permission denied)
18:43:17 <grantwu> Has anyone else using ghc-mod with Atom had things that should be errors turn into Warnings?
18:43:22 <glguy> You won't be able to use it with infix application if it doesn't have a function type though
18:43:25 <grantwu> s/Warnings/warnings/
18:43:26 <qmm> ah, operators are functions, but an operator symbol isn't necessarily a function
18:43:34 <grantwu> It's quite annoying
18:43:37 <qmm> thank you for the clarification!
18:43:51 <xcmw> Do you know why set2 works but set3 fails even tough they operate the same?
18:44:05 <lpaste> MarLinn annotated “Any way to make this code shorter” with “Any way to make this code shorter (annotation)” at http://lpaste.net/8053454659462889472#a347325
18:44:09 <geekosaur> hnewbie, it's trying to install info your global package database. you might want to see if it will install to the user db, since it's best practice to avoid putting packages that don't come with the compiler into the global db
18:44:37 <geekosaur> if you want to risk conflicts in the future and install in the global db anyway, you need to install it as root
18:45:56 <hnewbie> I'm trying to follow the instructions at: https://github.com/chrisdone/present
18:46:30 <hnewbie> I understand that installing to the global database may be dangerous
18:46:59 <geekosaur> it says "via stack" (that sounds even riskier, mucking with stack's global db can confuse it)
18:47:01 <hnewbie> I tried to install as root, got "You are not the owner"
18:47:17 <geekosaur> stack exec -- sh install-to-global-db.sh
18:47:40 <hnewbie> Again, I'm trying to follow instructions -- I'm new at this, and just trying to get a working emacs configuration from tutorials
18:48:04 <xcmw> MarLinn: The first one worked
18:48:06 <geekosaur> yes, the instructions assume you know what "(via stack)" meams
18:48:16 <geekosaur> since you don't, I told you what it means
18:48:38 <geekosaur> if this means to you that you are not following directions, then file an issue against that project
18:50:35 <lpaste> xcmw revised “Any way to make this code shorter”: “Any way to make this code shorter” at http://lpaste.net/8053454659462889472
18:51:55 <xcmw> MarLinn: Where to I put Eq? I added the definitions
18:53:22 * hackagebot kafka-device-joystick 0.1.5.0 - Linux joystick events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-joystick-0.1.5.0 (BrianBush)
18:53:24 * hackagebot kafka-device 0.1.5.0 - UI device events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-0.1.5.0 (BrianBush)
18:53:26 * hackagebot kafka-device-leap 0.1.3.0 - Leap Motion events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-leap-0.1.3.0 (BrianBush)
18:53:28 * hackagebot kafka-device-glut 0.1.3.0 - GLUT events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-glut-0.1.3.0 (BrianBush)
18:53:30 * hackagebot kafka-device-spacenav 0.1.5.0 - Linux SpaceNavigator events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-spacenav-0.1.5.0 (BrianBush)
18:55:20 <lpaste> xcmw revised “Any way to make this code shorter”: “Any way to make this code shorter” at http://lpaste.net/8053454659462889472
18:58:16 <MarLinn> xcmw, huhm... you would need a way to say "I can compare any A u to any A t regardless of u and t" in a constraint, right? There are ways to add Forall in constraints, but I must say I never used them
18:58:32 * hackagebot kafka-device-vrpn 0.1.5.0 - VRPN events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-vrpn-0.1.5.0 (BrianBush)
18:58:38 <MarLinn> not successfully, that is
18:59:03 <hnewbie> Thanks geekosaur, I'm learning.
18:59:27 <geekosaur> well, you should probably report that anyway
18:59:54 <geekosaur> although I am wondering if chrisdone left that off because the stack folks will be grumpy if they see him recommending people do that
18:59:56 <qmm> one more question does the arrow type operator represent function application in fmap :: Functor f => (a -> b) -> f a -> f b
19:00:06 <hnewbie> Finally got it. Had to edit the install shell script to insert --allow-different-user, and sudo to force present into the global database.
19:00:09 <hnewbie> Thanks for the help.
19:00:28 <lpaste> glguy annotated “Any way to make this code shorter” with “for xcmw , better?” at http://lpaste.net/8053454659462889472#a347331
19:00:55 <Axman6> qmm: not sure what you mean
19:01:05 * geekosaur also...
19:01:08 <Axman6> firstly, which arrow are you referring to? => or ->?
19:01:47 <qmm> i need a better example, one second
19:02:55 <qmm> > :t mappend
19:02:57 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
19:03:00 <qmm> :t mappend
19:03:01 <lambdabot> Monoid a => a -> a -> a
19:03:05 <xcmw> glguy: MarLinn already gave me that. He gave me a second even shorter one that did not work.
19:03:14 <qmm> the thin arrows in the type signature for mappend
19:03:17 <glguy> I could give you a really short one that doesn't work
19:04:02 <qmm> do they represent function application?
19:04:24 <MarLinn> hnewbie, note that that combination pushes dependencies to /root/.stack instead of ~/.stack, which might come back to bite you one day
19:05:05 <MarLinn> anything that's not force-pushed to global I mean
19:05:15 <geekosaur> so why was it modifying /var/lib/ghc the first time?
19:05:50 <geekosaur> (I suspect there's actually a bit of setup missing from the install section...)
19:07:08 <geekosaur> qmm, mappend takes two parameters, both of some type that has a Monoid instance, and produces a third value of that same type
19:07:09 <lpaste> glguy annotated “Any way to make this code shorter” with “using equality for xcmw” at http://lpaste.net/8053454659462889472#a347333
19:07:28 <glguy> xcmw: You can't use == from Eq, the type is too constrained. You need something like that paste instead
19:07:38 <geekosaur> the reason we write it that way is because of partial application. that does not mean that partial application is actually happening in the type signature
19:08:24 <geekosaur> :t mappend
19:08:26 <lambdabot> Monoid a => a -> a -> a
19:08:33 <geekosaur> :t mappend "x"
19:08:34 <lambdabot> [Char] -> [Char]
19:09:15 <Axman6> qmm: a -> b -> c means a -> (b -> c), or, a function which, when given an a, returna a function which, when given a b, returns a c
19:09:42 <xcmw> glguy: Thanks
19:17:55 <qmm> Axman6: that's exactly my understanding
19:18:14 <hnewbie> Well, I have been bit. I'm using ghc 8.0.1, and the present source is set for 7.10.3. So, I succeeded in pushing to the 7.10.3 global database, but, of course, I can't see it from an 8.0.1 ghci.
19:18:28 <grantwu> I'm now able to know precisely when oom-killer kills ghc-mod by when youtube pauses for a moment >.>
19:18:53 <qmm> geekosaur: that's the higher level understanding that i have as well
19:19:12 <hnewbie> chrisdone wrote that present needed 7.10.3. I thought that meant for compilation only. I think I'll call this one, rather than try to build present on 8.0.1.
19:19:26 <qmm> i guess my understanding is good enough for now
19:20:38 <qmm> i have another pedantic question: are arguments and parameters interchangeable terms?
19:21:19 <qmm> i've always thought they were, i'm just peering behind every corner with the help of everyone here and a search engine :)
19:21:52 <geekosaur> pedantry gets you in trouble here :p a common understanding is that parameters are in the definition of a function and arguments are at call sites for it
19:22:00 <geekosaur> but others used them interchangeabily
19:22:40 <qmm> geekosaur: glad i asked! :)
19:22:47 <qmm> ty
19:22:52 <glguy> qmm: in f x, x is the argument of the function application
19:23:06 <geekosaur> (well, pedantically the first one is a "formal parameter". but that term has its own issues in haskell, since you may never see the formal parameter itself if you use a pattern to deconstruct it...)
19:23:49 <geekosaur> pr more correctly you may never name a formal parameter in that situation
19:24:11 <geekosaur> so we're somewhat more lax on that terminology than some
19:24:21 <LordBrain> maybe we should call them victims instead of arguments :P
19:25:01 <LordBrain> then we'd say x is the victim of f, in f x, which makes sense since f is doing something to it... sure its imperfect, but so is 'argument'
19:25:17 * geekosaur is now imagining a new terminology taken from Paranoia
19:25:32 <LordBrain> probably there is an even better word than victim if we think long enough
19:28:04 <geekosaur> "test subject" (think Bunsen and Beaker from the Muppets)
19:28:23 * hackagebot acme-year 2016 - Get the current year  https://hackage.haskell.org/package/acme-year-2016 (JoeyAdams)
19:28:29 <grantwu> Hrm... I have an issue with overlapping instances
19:28:31 <LordBrain> victim is pretty good tho, since its not used for anything else mathematically
19:28:42 <JoeyAdams> Sorry for the delay guys.  Haven't been in the Haskell loop for a while.
19:29:51 <grantwu> http://lpaste.net/2794383637779316736
19:29:54 <MarLinn> So... if I can't get an Eq (f a) constraint because there's no Eq a instance is that victim blaming?
19:29:56 <grantwu> What's the best strategy to resolve this?
19:30:33 <LordBrain> you could call it 'direct object' in analogy to english grammar
19:30:34 <glguy> grantwu: If you want to write your own instance for M.Map Ident FDefn, you'll need a newtype
19:30:44 <geekosaur> grantwu, newtype or data instead of type
19:31:16 <geekosaur> a `type` is a type alias, you can't change existing instances and the compiler will complain if you define a new one because it would actually apply to the aliased type
19:31:17 <grantwu> I mean, I turned on FlexibleInstances to allow writing instances for type synonyms... I guess I will need a newtype, sigh
19:31:37 <grantwu> Wait, that *is* one of the things FlexibleInstances allows, right?
19:31:49 <geekosaur> it turns off the error when you define an instance
19:31:49 <glguy> If you need a particular output format you might actually just want a different class than Show, which is for generating Haskell source code output for debugging
19:32:02 <geekosaur> the instance still applies to the original type, not specifically to your alias
19:32:23 <geekosaur> and it is still an overlap if the original type has a matching instance already
19:33:30 <grantwu> made it a newtype, now I have to go fix the entire codebase
19:33:37 * grantwu == sadness
19:38:33 <glguy> You could also just not use Show for the custom rendering of a EffectsIsolatedIR
19:38:51 <glguy> but having a newtype for that is probably a win in general, independent of Show
19:40:09 <solrize> should   parMap rpar func [1,2,3,4,5]   run func in parallel on the list elements or do I have to do something else?  i'm compiling with -threaded and +RTS -N   but i'm only using 1 core on a quad core machine
19:40:25 <MarLinn> JoeyAdams, thank you for the hard work. Looks like many people had problems properly handling that particular year, so props to you!
19:42:49 <solrize> oh +RTS is not a compile flag, i have to put it on a.out.  that fixed it   sorry
19:45:49 <grantwu> glguy: It's just debug output
19:46:10 <xcmw> How would I write Lens' (forall t. A t -> k t) (k X) without imprecative types? 
19:46:38 <glguy> xcmw: Make a newtype Thing k = Thing (forall t. A t -> k t)
19:46:47 <glguy> and then write Lens' (Thing k) (k X)
19:47:13 <Koterpillar> xcmw: I believe they are called impredicative types
19:48:13 <xcmw> Ok. I finally run into a case were they broke.
19:48:52 <geekosaur> "imprecative" would be what happens when someone finds yet another case where they don't...
19:50:30 <coms> Is there a common functional programming convention for taking a list of booleans and applying logical-and so that I get a final scalar boolean with a single function call with a list of functions as an argument?
19:50:52 <Koterpillar> :t all --coms
19:50:54 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
19:51:22 <coms> Thank you
19:51:27 <byorgey> coms: I don't understand your question.  Do you have a list of booleans, or a list of functions?
19:51:30 <byorgey> or both?
19:51:43 <geekosaur> :t all (?f $)
19:51:45 <lambdabot> (?f::a -> Bool, Foldable t) => t a -> Bool
19:51:49 <Axman6> > all $ ($) <$> [(<=3),(<=5)] <*> [3,4,5]
19:51:52 <lambdabot>  error:
19:51:52 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
19:51:52 <lambdabot>                    with actual type ‘[Bool]’
19:51:57 <Axman6> > and $ ($) <$> [(<=3),(<=5)] <*> [3,4,5]
19:51:59 <lambdabot>  False
19:52:07 <Axman6> > and $ ($) <$> [(>=3),(<=5)] <*> [3,4,5]
19:52:10 <lambdabot>  True
19:53:00 <coms> It appears foldable is what I am looking for. Let me check.
19:53:02 <geekosaur> actually I think I got the backwards one
19:53:12 <geekosaur> :t all ($ ?x)
19:53:14 <lambdabot> (?x::a, Foldable t) => t (a -> Bool) -> Bool
19:54:41 <coms> It is indeed fold, thanks all.
19:55:30 <Axman6> yeah foldMap (And . f)
19:55:37 <Axman6> if you only have one function
19:59:22 <solrize> is there a good channel to talk about SAT solvers?  this isn't it, but i dunno where else to look
20:06:04 <MarcelineVQ> solrize: possibly ##algorithms
20:08:25 * hackagebot wembley 0.1.0.0 - Pretty-printing of codebases  https://hackage.haskell.org/package/wembley-0.1.0.0 (lovasko)
20:11:27 <SolitaryCypher> Hey, so I have a 5,000,000 line text file full of words. Is there a structure that can hold all of that in memory in a nice and searchable way? 
20:12:30 <SolitaryCypher> Right now I am using a list, it works in a streamable way but it freezes my computer when I do (last list)
20:13:03 <Maxdamantus> SolitaryCypher: possibly some sor of trie-like structure.
20:13:13 <Axman6> hmm. a Data.Sequence might be useful if you need to index into specific indicex
20:13:17 <Axman6> indices*
20:13:32 <Maxdamantus> depending on what you mean by "searchable"
20:14:02 <Maxdamantus> (with a trie, you can easily look things up with a given prefix)
20:14:51 <athan> Does anyone here know if stack can be restricted to invoking only one GHC process at a time?
20:15:00 <athan> er build dependencies one at a time, really
20:15:01 <Maxdamantus> it's also effectively sorted, so you can easily look up the first or last things.
20:15:25 <SolitaryCypher> Right now I don't care about sorting, but it just kinda freezes everything because I _think_ its choking on holding all the data
20:15:41 <SolitaryCypher> I can make it a tree later. Now I want it not to die
20:16:36 <Maxdamantus> Are you using ByteStrings at least?
20:17:19 <SolitaryCypher> No, but I am splitting into lines. Would bytestrings work differently?
20:17:34 <SolitaryCypher> I'm doing hGetContents
20:17:40 <Koterpillar> take less space
20:18:05 <Maxdamantus> You'd use them similarly, but they're quite different in representation.
20:18:20 <SolitaryCypher> hGetContents works when I take 100000 items
20:18:28 <Axman6> ByteString or Text would definitely use a lot less space
20:18:29 <Maxdamantus> You still have most typical String/list operations.
20:18:44 <Axman6> String has a huge space overhead if you load the whole thing
20:19:29 <SolitaryCypher> I don't think its trying to load the whole thing at once, but I'll try bytestrings
20:19:44 <SolitaryCypher> I want lazy ones, probably?
20:19:44 <Axman6> well, is the data text or binary?
20:19:54 <SolitaryCypher> text
20:21:19 <Axman6> depends how you're using it. I would personally use a strict Text
20:21:32 <Axman6> that way it can all be loaded into memory in one contiguous chunk
20:26:05 <SolitaryCypher> works for head, checking the tail now
20:26:07 <jle`> are there any resources on numeric bidirecitonalization
20:26:09 <SolitaryCypher> *last
20:26:19 <jle`> there's the bff and bff-mono packages on hackage which are nice
20:26:27 <jle`> but you can't do it with numeric functions i think
20:29:19 <SolitaryCypher> Axman6: crashed. It appears to be using way more memory than it should be. I think I have a leak in my list code
20:29:21 <solrize> MarcelineVQ, thanks, will try there
20:29:38 <Axman6> SolitaryCypher: feel free to share the code
20:32:38 <SolitaryCypher> I know this code isn't the _best_, but I want to get it working before refactoring http://pastebin.com/tDPkXftG 
20:35:02 <Axman6> uh, don't read the contents as a String and then pack it as a Text, use Data.Text.IO
20:35:06 <MarcelineVQ> might want to use text's getContents so you don't need to pack what you're reading, not sure how mch it matters
20:35:06 <SolitaryCypher> I have this file that contains lines like "0 DOC1  1 1 someword 19", wher 0 and DOC1 are repeated for every word in the document. I am collecting all the words per document and putting them in a list
20:35:14 <SolitaryCypher> hmm. OK
20:37:03 <Axman6> I would probably make the fields in DocWords strict and unpack them: Number :: {--# UNPACK #-} !Int; docid :: {-# UNPACK #-} !T.Text...
20:37:33 <SolitaryCypher> What does that do?
20:38:02 <Axman6> it means things like the Int get turned into an inline Int#, so it's not lazy and there's no pointer overhead
20:38:30 <Axman6> with the Text, it'll pit the Ints and pointer to the array of characters into the constructor directly too
20:39:13 <Axman6> basically, it means you use less RAM and code will probably run faster
20:39:24 <Axman6> I have a feeling you might be having problems with laziness
20:40:55 <SolitaryCypher> Yeah; I think that's it. Or combineWords is using a bunch of extra memory
20:41:33 <SolitaryCypher> I don't mind speed right now, just memory
20:41:37 <SolitaryCypher> I can optimize for speed later
20:42:11 <SolitaryCypher> Ok, I can get the last element
20:42:20 <SolitaryCypher> which is good
20:44:58 <SolitaryCypher> Spoke too soon. crashed right after I said that
20:45:09 <SolitaryCypher> giving up for now. I'll come back tomorrow, or just write it in C
20:54:55 <Axman6> SolitaryCypher: we can make this work, it's not like it's a lot of data :)
21:05:05 <confused_functor> Question about free monads - I wrote my interpreter and it's working. Is there a neat way to optimize the AST? That is, changing Free (Add 1 (Free Add 1 (Pure ()))) to Free (Add 2 (Pure ()))
21:06:12 <Axman6> well, you can pattern match on its structure, so sure, you could pretty easily write optimisation passes like that
21:19:28 <jle`> there migt be a way to abstract over the explicit recursion with some recursion-schemes-like techniques
21:20:37 <bollu> so, I'm trying to grok monad transformers
21:20:43 <bollu> I "understand" how to write them
21:20:47 <bollu> but I don't grok them
21:20:54 <bollu> particularly, 1. the order of effects
21:21:49 <bollu> 2. are there situations where you get RunM2 . RunM1 $ <weirdStack>?
21:22:44 <bollu> 3. too much "lift" is possible right?
21:22:56 <bollu> if I have a monad transformer thats like, 5 levels deep
21:23:04 <bollu> I may need to lift . lift . lift . lift?
21:27:16 <grantwu> bro do you even lift
21:27:45 <grantwu> (I too don't really understand how to work with deeply nested monad transformer stacks)
21:28:40 <geekosaur> bollu, this is why we use newtype deriving and typeclasses that have the actual implementation
21:28:59 <bollu> geekosaur: can you expand on that?
21:29:04 <geekosaur> newtype deriving just adds an instance on top that does a `lift`
21:29:34 <geekosaur> so we make the compiler generate just the right number of `lift`s to reach the part of the transformer that handles whatever we're trying to do
21:29:41 <bollu> ah, okay. so NewtypeDeriving implements the correct MonadState, MonadReader, … on your newtype based on the layers in your transformer stack?
21:29:43 <bollu> that's so cool
21:29:53 <bollu> geekosaur: is there an example of this?
21:30:26 <bollu> geekosaur: its weird, I've used monad transformers before in the context of yesod, but I've never looked into them in a principled way. I should spend some time properly grokking this
21:30:33 <geekosaur> @google monad transformers step by step
21:30:34 <lambdabot> https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
21:30:54 <geekosaur> hm, no, that doesn't really cover the deriving part
21:31:29 <geekosaur> but, the basic plan is that when you create something like State/StateT, you also create MonadState and put the functionality in that, then declare instances for your actual type
21:31:39 <geekosaur> then enable GeneralizedNewtypeDeriving
21:32:01 <bollu> I see, ty
21:32:19 <bollu> also, another question: where should the "m" in the transfomer go?
21:32:39 <bollu> eg. StateT s m a, WriterT w m a, .
21:32:48 <bollu> should always be right before the concrete type?
21:33:38 <geekosaur> well, that's the convention. I think it's usually thought of in the other direction, though: it goes right after the components that are used by the transformer itself
21:33:39 <Axman6> not sure what you mean
21:34:01 <geekosaur> but it ends up just before the result type because there usually isn't any reason to have anything else in it
21:35:38 <bollu> ah, I see
21:35:45 <geekosaur> actually I did leave one thing out: if it is a transformer, you also need a MonadTrans instance that defines "lift" for a given transformer
21:36:01 <geekosaur> you can take a look at what MonadState has in the way of instances, for a starter
21:36:07 <bollu> geekosaur: there's no "real" that stops me from defining StateT m s a?
21:36:59 <geekosaur> there is something preventing that, yes
21:37:11 <bollu> what is?
21:37:23 <geekosaur> you need to be able to talk about the type and its parameter without needing to apply a transformed monad or a result
21:37:37 <bollu> ahh
21:37:39 <bollu> I see
21:37:48 <geekosaur> the MonadState instance for StateT needs to talk about StateT s
21:38:08 <geekosaur> (think of it as partial application at the type level)
21:38:20 <geekosaur> you can't partially apply that s if the m is in the way
21:38:56 <bollu> right, right
21:40:01 <bollu> geekosaur: let me write out monad transformer instances
21:40:05 <bollu> I think it shall be clear for me then
21:40:08 <bollu> thanks a lot :)
21:41:36 <bollu> what's the "smallest" way to write a webapp in haskell? (equivalent of flask for haskell?) right now I'm looking at snap
21:41:41 <bollu> is that a good choice?
21:42:24 <geekosaur> snap is commonly recommended
21:42:45 <geekosaur> (but I'm not the one to talk to about it, all I know is what I see recommended when other people ask...)
21:42:46 <Axman6> scotty is probably smaller/easier to understand
21:42:52 <Axman6> probably a lot more like flask
21:43:10 <bollu> I see
21:43:12 <bollu> lemme do that then
21:44:08 <bollu> what does "stack build —fast —pedantic" do exactly?
21:44:31 <Axman6> builds without optimisations (-O0) and -Wall, -WError
21:55:36 <bollu> Axman6: oh, I see, ty
21:56:32 <bollu> why is spock not on Stackage?
21:57:06 <MarcelineVQ> capital S
21:58:03 <bollu> ohh
21:58:14 <MarcelineVQ> type the package you're after in here if you have that problem again https://www.stackage.org/
21:58:52 <bollu> MarcelineVQ: haha, thanks :)
22:06:13 <stalk> hi
22:06:21 <stalk> Can someone tell me what's wrong here http://lpaste.net/8093219906230681600 ?
22:06:50 <stalk> this function should return all files under the given folder (not just direct children)
22:06:57 <stalk> instead, it only gives me the direct ones
22:07:44 <bollu> why is stack not able to find Web.Spock.Config? I've added "Spock" to my build-depends
22:08:45 <jle`> bollu: try adding the specific version? Spock-0.11.0.0 ?
22:08:49 <bollu> oh, hm, right
22:08:54 <jle`> oh wait you mean the build-depends
22:09:00 <jle`> er, what's the stack error?
22:09:18 <bollu> jle`:     Could not find module ‘Web.Spock.Config’
22:09:20 <jle`> you'd have to add it to extra-deps if it's not in the snapshot
22:09:24 <jle`> ah
22:09:31 <jle`> but it installed the spock package properly?
22:09:44 <bollu> yes
22:09:49 <bollu> I guess I need bounds (>=0.11) 
22:09:55 <jle`> yeah, it looks like Web.Spock.Config is not in any spock version less than 0.11
22:10:03 <jle`> mhm
22:11:13 <bollu> ah, I see, stackage does not have the newer Spock which is why they ask you to pull from git
22:12:29 <MarcelineVQ> the Spock on stackage has Web.Spock.Config, what lts are you using?
22:12:51 <bollu> 6.26
22:12:54 <bollu> that's too old?
22:13:09 <bollu> also, "atomicModifyIORef" is fine for me, but, like, how would you ELI5 that to newbies? :P
22:13:18 <bollu> I'm a newbie too, but just less so
22:13:56 <MarcelineVQ> too old to have Web.Spock.Config yes, this is what lts-6.26 has https://www.stackage.org/lts-6.26/package/Spock-0.10.0.1
22:15:33 <bollu> I see, thanks
22:18:05 <glguy> stalk: you need to build up a new path
22:18:21 <glguy> stalk: f </> child
22:19:21 <Cale> Whoops, I was going to say that, but got distracted by another message, sorry!
22:19:41 <stalk> mmh, now that I look at the output, yes
22:19:43 <Cale> stalk: Also, use foldr there, not foldl, it'll perform a lot better
22:20:06 <Cale> xs ++ ys takes O(length xs) steps to fully evaluate
22:20:16 <Cale> So if you left-associate, you'll end up doing O(n^2) work
22:21:09 <stalk> ah, yes
22:21:42 <Cale> (or you could just use concat, which uses foldr)
22:22:00 <stalk> concat concats all elements of a string?
22:22:05 <stalk> *list
22:22:11 <Axman6> :t concat
22:22:12 <lambdabot> Foldable t => t [a] -> [a]
22:22:26 <Axman6> (aka, [[a]] -> [a])
22:23:50 <stalk> ok, good
22:23:52 <stalk> thanks
22:25:50 <stalk> and what's he standard module I should import </> from?
22:26:40 <stalk> mmh, I think it's in System.Filepath.Posix
22:28:31 <stalk> I'm still a bit confused on how modules relate to package, and why some things are at some places
22:28:31 <MarcelineVQ> importing System.FilePath will give you the appropriate </>   it's from the filepath package
22:28:42 <MarcelineVQ> http://hackage.haskell.org/package/filepath-1.4.1.1/docs/System-FilePath.html
22:29:44 <stalk> ok, nice, it works now :)
22:29:53 <stalk> Thanks guys!
22:33:17 <MarcelineVQ> two possibly useful things, combine is the non-operator version of </> and listDirectory does what getDirectoryContents does excluding the . and .. for you
22:33:23 <MarcelineVQ> ohhesgone
22:47:02 <bollu> how do I download documentation for all haskell libraries?
22:47:08 <bollu> or is that too ambitious?
22:48:24 <Cale> bollu: cabal can build documentation for all the libraries you have installed if you have documentation: True in your ~/.cabal/config
22:48:40 <bollu> Cale: oh, but I don't think I've installed with docs
22:48:46 <johnw> there are a few ways to download documentation for lots of them, to be sure
22:48:56 <johnw> I have local documentation for several hundred
22:48:59 <bollu> Cale: is there a way I can just download the docs? like, from stackage or something?
22:49:57 <bollu> oh neat, I can just spin up hoogle
22:50:26 <bollu> hm, but it links to hackage
22:50:30 <bollu> johnw: how do you download docs?
22:51:06 <johnw> using Nix and its ghcWithHoogle feature
22:51:14 <johnw> or, if you use Docker, I have a container you can run
22:51:32 <bollu> johnw: I don't use docker, but I wouldn't mind running a container for docs
22:51:53 <johnw> https://hub.docker.com/r/jwiegley/hoogle-local/
22:52:03 <johnw> I'm unable to update that right now, due to a Hoogle bug I'm waiting on
22:52:09 <johnw> but it's not too old yet
22:53:09 <bollu> thanks!
23:08:11 <bollu> what does this mean "data Path as pathState :: [https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Kind.html#t:-42-] -> https://hackage.haskell.org/package/reroute-0.4.0.1/docs/Web-Routing-Combinators.html#t:PathState -> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Kind.html#t:-42-"
23:08:31 <bollu> data Path as pathState :: [*] -> PathState -> *
23:09:55 <bollu> I've never seen the data x as y
23:12:25 <jle`> bollu: it's a normal type variable
23:12:37 <jle`> @let data Maybe' as = Nothing' | Just' as
23:12:39 <lambdabot>  Defined.
23:12:52 <jle`> like that
23:13:19 <jle`> > let foo as = length as in foo [1,2,3]
23:13:22 <lambdabot>  3
23:16:34 <bollu> oh, it's.. "as" sa in "xs"?
23:17:55 <solrize> yeah
23:17:57 <solrize> not a keyword
23:18:44 <solrize> > let isn't = (/=) in 3 `isn't` 4
23:18:46 <lambdabot>  True
23:18:51 <ab9rf> there's no magic to "xs"
23:18:57 <jle`> bollu: yup
23:19:23 <jle`> bollu: like xs, ys, za, as
23:19:25 <ab9rf> or to 'as" :)
23:19:25 <jle`> s/za/zs
23:19:31 <bollu> ab9rf: yes, I know :) was so confused thinking "as" was new syntax :P
23:19:31 <jle`> as, bs, cs
23:19:34 <ab9rf> za!
23:19:38 <bollu> right, right
23:19:38 <ab9rf> i want za now.
23:19:40 <bollu> xD
23:33:15 <bollu> http://lpaste.net/870795797401174016#line63 I'm trying to understand where a MonadLogger constraint is coming into my application 
23:33:18 <bollu> I'm a little lost
23:33:30 <bollu> there are a lot of types floating around, and I don't know why MonadLogger is being imposed
23:33:33 <bollu> can I have some help please?
23:42:04 <Shoggoth-> does anyone have a good example of how to use the lattices package (https://hackage.haskell.org/package/lattices) ?
