00:01:58 <haskell298> Hi, using stack is there a way of filing the "exposed-modules" field in the .cabal file?
00:03:12 <dmj`> haskell298: no
00:03:52 <dmj`> afaik, it's not
00:05:15 <haskell298> thanks, I guess I'll write them all :(
00:05:59 <Axman6> at least stack tells you which ones you're missing IIRC
00:06:57 <haskell298> it's weird that we don't have to write it for ghci
00:07:41 * hackagebot language-c-inline 0.7.10.0 - Inline C & Objective-C code in Haskell for language interoperability  https://hackage.haskell.org/package/language-c-inline-0.7.10.0 (ManuelChakravarty)
00:07:41 * hackagebot from-sum 0.2.0.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.2.0.0 (cdepillabout)
00:07:45 <jeltsch> In the past, there where generic binary packages (*.tar.bz2) of GHC on the GHC website, but now there only seem to be source packages and distribution packages (*.deb, *.rpm, etc.). Am I overlooking something?
00:09:09 <Axman6> I don't think there's ever been binary packages on hackage
00:09:19 <dmj`> jeltsch: https://www.haskell.org/ghc/download, they're still there
00:10:06 <Axman6> oh, sorry, misunderstood the question
00:10:21 <jeltsch> dmj`: Ah, I was mislead by the fact that you have subsections with headlines like “Debian 8”, which suggested that these were distribution packages.
00:10:53 <cocreature> jeltsch: the distro is mentioned because linux binaries don’t tend to be completely portable
00:11:22 <jeltsch> What is the difference between the Debian 7 and Debian 8 builds? Which one should I use on Ubuntu 16.04.1 LTS?
00:11:33 <jeltsch> The GMP version needed is the same.
00:11:46 <cocreature> probably the debian 8 one
00:15:53 <haskell298> what's the currently used pretty printing in haskell?
00:24:16 <cocreature> haskell298: I’ve used ansi-wl-pprint in the past and was quite happy with it
00:25:33 <haskell298> thanks!
00:31:14 <jmorris> Axman6: I logged out, (https://github.com/joshua-morris/hpass/blob/master/src/Hpass.hs)
00:32:58 <Axman6> jmorris: looks good to me. now time to use some crypto to look after those usernames and passwords! :P
00:34:01 <jmorris> Axman6: yeah
00:36:13 <fred-fri> Are there any resources on idiomatic, project centered Haskell? I find many resources on Haskell are kind of list of features of the language, like "look you can do this isn't it cool" "uuh yeah cool I guess". (not hating, just saying) I'd like to see idiomatic use of the features in an actual project, what tools to use for and how to structure actual projects.
00:38:05 <cheater> fred-fri: why don't you look at snap, it's large enough to be interesting
00:57:38 * hackagebot ntrip-client 0.1.3 - NTRIP client.  https://hackage.haskell.org/package/ntrip-client-0.1.3 (markfine)
01:19:36 <tsahyt> are there any tools to help determining which types are used in which modules? Right now I've got most of them in a (rather messy) *.Internal.Types module, but I want to refactor types that are only used locally in one module into the module where they are used.
01:22:38 * hackagebot concurrent-split 0.0.0.2 - MVars and Channels with distinguished input and output side  https://hackage.haskell.org/package/concurrent-split-0.0.0.2 (HenningThielemann)
01:27:10 <bollu> what's a good reference on indexed monads?
01:27:14 <bollu> I want to learn about them
01:29:10 <cocreature> bollu: I found the answer in https://stackoverflow.com/questions/28690448/what-is-indexed-monad to be quite good but it’s been a while since I’ve read them and I forgot most of it :)
01:32:39 * hackagebot stm-split 0.0.0.2 - TMVars, TVars and TChans with distinguished input and output side  https://hackage.haskell.org/package/stm-split-0.0.0.2 (HenningThielemann)
01:33:15 <bollu> cocreature: ty :)
01:33:19 <bollu> cocreature: much appreciated
01:33:36 <bollu> is there a list of haskell papers that are must read?
01:33:42 <bollu> can I start such a list if it doesn't exist?
01:34:02 <cocreature> https://www.reddit.com/r/haskell/comments/2blsqa/papers_every_haskeller_should_read/
01:34:09 <bollu> ooh :D
01:34:11 <bollu>  brilliant
01:34:19 <bollu> I've been trying to aim for a-paper-a-week
01:34:43 <bollu> I can't read Conor's papers a lot of the time I find
01:34:52 <bollu> it goes from "ooh, cool" to "what the FUCK is happening" way too fast
01:39:05 <ongy> I prefer when it goes the other way around. from "what the?" to "ohhh, cool"
01:39:18 <bollu> ongy: I do too :P
01:43:50 <damian_> hello ppl, I have some problems with hdevtools for a project that is configure using stack... it looks like it's using the global ghci when I setart the server ... when I run "hdevtools check -d app/Main.hs" it gives me the following error "Cabal error: '/usr/bin/ghc' exited with an error: /usr/lib/ghc/settings: openFile: does not exist (No such file or directory)"
01:46:21 <tdammers> I'm not familiar with hdevtools; does it automatically defer GHC invocations to stack? Because the GHC installed through stack is only used if you go through stack (stack ghci / stack repl / stack exec / ...)
01:46:40 <tdammers> it's not like a python virtualenv where your $PATH gets adjusted to resolve to a different binary
01:49:09 <ongy> hdevtools does have stack integration, but I haven't tried it
01:50:01 <ongy> but /usr/bin/ghc doesn't sound like a stack path to me
01:51:18 <damian_> tdammers: yes, it has stack integration... sometimes it works
01:51:31 <damian_> but when I update sometimes the stack.yml file it stop working
01:51:44 <damian_> but it should detect use the correct ghc in theory
02:01:44 <bollu> how do I use Qt in haskell?
02:01:51 <bollu> what's the most stable bindings that exists?
02:07:40 * hackagebot multifile 0.1.0.3 - create many files from one  https://hackage.haskell.org/package/multifile-0.1.0.3 (AlanHawkins)
02:09:43 <ninjazoe> Guys I tried to set up Travis with my github haskell repo and I am having trouble understanding this
02:09:55 <ninjazoe> cabal: At least the following dependencies are missing:
02:09:56 <ninjazoe> base ==4.9.*
02:10:30 <ninjazoe> my <package>.cabal has dependency: base=4.9.* because I changed it to and still Travis cabal build exits with 1 and errors out
02:10:47 <ninjazoe> and on my local machine cabal built builds without problems
02:11:56 <ninjazoe> What am I missing? cabal version is good, travis.yml is just - cabal update; cabal build
02:16:17 <ongy> damian_: there's a github page for hdevtools. if you can build something reproducable it would be best to report as bug
02:16:57 <damian_> ongy: thanks, will do.. not sure the problem is with hdevtools or stack.. trying to identify it
02:17:43 <ongy> ninjazoe: base==4.9 requires ghc 8.0, travis does not have that by default. So you have to either use the multi-ghc travis.yml template (should be easy to find) or have travis test with older ghc (last I checked most recent was 7.8)
02:19:02 <ninjazoe> ongy: so I should better build with lower Haskell right?
02:19:52 <ninjazoe> thank you for help
02:20:09 <ongy> ninjazoe: there's also https://github.com/hvr/multi-ghc-travis which can be used to use multiple/newer ghc. I think it's the better solution. 
02:21:29 <ongy> But I would say it's generally a good idea to make sure older GHC are still supported. I would support down to 7.8 and 7.6 if easy (7.6 is debian jiessie) but that's highly subjective
02:26:35 <ninjazoe> now I am thinking where does it specify that it has to be 8
02:26:46 <ninjazoe> I will figoure it out :) thank you again
02:31:46 <cheater> do people in the us work on 1 nov?
02:32:36 <jle`> for the most part
02:38:50 <ongy> ninjazoe: base is shipped with ghc. so when you depend on base-4.9 you depend on ghc-8.0
02:58:45 <unclechu> hey guys, is there any pre-built ready-to-use binaries of haskell platform with ghc 6 version? I want to build old app but pretty confused how I can get ghc6 for that, I even tried to install it in debian 6 inside docker container but debian repos answers with 404 and I can't install anything 
02:59:16 <heebo> use stack , i think you can specify the version of ghc to use in the config file
03:00:26 <unclechu> heebo: I tried it too, but without any success, look at error that I get from it:
03:00:28 <unclechu> "stack will almost certainly fail with GHC below version 7.8"
03:00:35 <unclechu> blabla and it doesn't help
03:00:43 <heebo> oooh 
03:01:02 <heebo> sure there are binaries, ill try and find the link
03:01:31 <unclechu> my imagination isn't getting me anything new about how I can solve it :(
03:01:55 <heebo> https://www.haskell.org/ghc/
03:03:41 <heebo> if you are using debian, its probably best to install the haskell platform tied to a specific version
03:04:35 <unclechu> heebo: yeah I tried this too with this link: https://www.haskell.org/ghc/dist/6.12.3/ghc-6.12.3-x86_64-unknown-linux-n.tar.bz2
03:05:18 <unclechu> but I didn't see any binaries inside, I saw `Makefile`, `configure` so I realized it need compilation
03:07:52 <unclechu> heebo: and I don't see ghc below 7 in debian packages
03:07:52 * hvr points out there's also http://downloads.haskell.org/debian/
03:07:55 <unclechu> https://packages.debian.org/search?suite=jessie&searchon=names&keywords=ghc
03:08:33 <cheater> jle`: thanks
03:08:40 <unclechu> and `jessie` (7th debian) is lowest that I see in this resource
03:08:56 <hvr> (but I didn't build any  GHC 6.12  package for Deb8)
03:09:05 <heebo> https://www.haskell.org/ghc/download_ghc_6_10_1#x86_64linux has a heading entitled 'binary packages'
03:11:09 <ph88> hi guys, i have made a data type which can be joined together with itself .. would it be a good idea to make a monoid instance ?
03:11:28 <hvr> ph88: if it satisfyies the monoid laws, then sure
03:11:30 <heebo> https://downloads.haskell.org/~platform/
03:11:35 <ph88>  \(Algo2 a b c) (Algo2 d e f) -> Algo2 (a # d) (b # e)) (c + f)
03:12:01 <hvr> ph88: or maybe it only satisfies the semigroup laws, then it's merely worth a Semigroup instance
03:13:10 <hvr> ph88: if (#) satisfies the monoid laws, then Algo2 likely will to
03:13:16 <ph88> if i make it a monoid what does that actually give me? implementation of fold is then automatic ?
03:14:08 <hvr> ph88: well, basically it allows you to use functions & APIS which require a Monoid instance with your type
03:14:26 <ph88> hvr, https://hackage.haskell.org/package/bv-0.4.1/docs/Data-BitVector.html#v:-35-
03:15:18 <hvr> ph88: a type with  concatenation usually forms a monoid
03:15:37 <hvr> and in fact, BV has a Monoid instance
03:15:59 <hvr> which means you could have used `<>` or `mappend` instead of (#)
03:17:32 <hvr> ph88: as for Foldable, yes, this enables you to use your type as result type of `fold` or `foldMap`
03:17:35 <ph88> hvr, like this ?  https://paste.fedoraproject.org/467193/47799542/
03:18:10 <hvr> ph88: the mappend line is missing the 3rd field
03:18:11 <ph88> oh i forgot    (c + f)   at the end
03:18:28 <hvr> ph88: but other than that: looks right
03:18:28 <ph88> now that i wrote this, how can i use this for fold ?
03:18:37 <ph88> <>  ?
03:18:42 <hvr> ph88: if you have e.g. [Algo3]
03:18:46 <hvr> you can apply fold to that
03:19:03 <ph88> but the function i have to apply is (<>) or mappend ?
03:19:23 <hvr> ph88: if you look at http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html
03:19:33 <hvr> you may notice that `fold` is defined as
03:19:34 <hvr>  fold :: Monoid m => t m -> m
03:19:50 <hvr> so 't' is e.g. a list, then this specialises to
03:19:58 <hvr>  fold :: Monoid m => [m] -> m
03:20:25 <hvr> and the fold is then basically more or less the same as 'mconcat'
03:20:46 <hvr> (which is part of the Monoid API)
03:21:14 <hvr> ph88: does this make any sense? :)
03:21:45 <ph88> noes :/
03:22:01 <ph88> i never use fold, only foldl' and foldr
03:22:36 <hvr> ok, fold is basically a foldl/foldr combined with (<>) and mappend
03:23:04 <ph88> ah ok ^^
03:23:06 <hvr> s/combined/applied/
03:23:20 <ph88> so it's like   fold xs = foldr <> xs    ?
03:23:32 <jle`> > fold ["hello","world","how","are","you"]
03:23:35 <lambdabot>  "helloworldhowareyou"
03:23:35 <lambdabot>  
03:23:45 <hvr> ph88: + mappend
03:23:47 <hvr> ph88: + mempty
03:24:03 <hvr> foldr needs an initial element (i.e. mempty)
03:24:14 <jle`> fold = foldr (<>) mempty
03:25:51 <tsahyt> using the exceptions package, can I have a monad stack with IO at the bottom which still handles exceptions in pure code?
03:26:19 <ph88> ah ok i get it now
03:26:41 <tsahyt> e.g. ExceptT e IO
03:27:04 <jle`> tsahyt: what do you mean by 'handles exceptions in pure code'
03:27:57 <tsahyt> jle`: catch an exception thrown by throwM (MonadThrow) as an Either for example
03:28:41 <jle`> as long as it's an instance of MonadCatch
03:29:08 <ph88> hvr, this is how i use my type now with monoid https://paste.fedoraproject.org/467196/96102147/ fold is on line 25
03:29:16 <tsahyt> jle`: but there are two ways to get such an instance here I think
03:29:26 <tsahyt> either let IO handle it, or actually use the ExceptT transformer
03:30:44 <jle`> sure, that's why there's a newtype wrapper that gives an instance for both behaviors
03:31:43 <jle`> or well, an alternative ExceptT with an alternative instance
03:32:11 <tsahyt> jle`: you mean CatchT?
03:33:35 <jle`> yes, CatchT's MonadThrow and MonadCatch instances work together so that its catch only catches things explicitly thrown with throw, ignoring the base monad
03:34:34 <tsahyt> but the documentation says that it should never be used together with IO
03:34:40 <unclechu> heebo: https://downloads.haskell.org/~platform/2011.2.0.0/ only from this version there's linux tarball
03:34:40 <unclechu> and it requires ghc7
03:35:02 <jle`> yeah, because it doesn't add anything.  you can already do this behavior normally with ExceptT e IO
03:36:00 <tsahyt> ah, so what I'd want is ExceptT e IO then
03:36:15 <jle`> still not completely sure what you mean by handling exceptions in pure code, though
03:36:22 <jle`> cna you give a more concrete example?
03:36:31 <jle`> 'ExceptT e IO' is itself an IO action
03:36:41 <tsahyt> the reason I'm asking is really because over the last few weeks I've written a lot of functions constrained over (MonadIO m, MonadThrow m) and I was wondering whether giving the option of MonadThrow rather than just using exceptions in IO is even worth it
03:36:42 <jle`> it describes an IO action
03:36:58 <ph88> if i have a function   foo x = blabla  and x is an int .. if i put the same number there twice will it cache the result ?
03:37:41 <jle`> no
03:37:54 <jle`> sounds like a really easy way to get huge space leaks
03:38:32 <jle`> although interestingly, a lot of new haskellers get the impression that functions are automatically cached/memoized
03:38:38 <jle`> i'm not sure where this comes from
03:38:54 <ph88> bcz haskell is magic :P
03:38:59 <tsahyt> I thought it was guaranteed to be evaluated only once in a lambda though. i.e. if I have \x -> foo x + foo x for example
03:39:00 <jle`> i think i actually believed it too when i started with haskell, but i don't ever remember actually reading something that would make me think so
03:39:13 <tsahyt> at least I remember reading something like that on stackoverflow once
03:39:18 <jle`> i don't think ghc guaruntees CSE
03:39:33 <tsahyt> CSE?
03:39:47 <jle`> common subexpression elimination
03:40:22 <jle`> https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination
03:40:51 <jle`> it's not something you should rely on
03:40:59 <tsahyt> I don't, I use a let binding when I want to make sure
03:41:17 <exio4> ph88: in that situation - it will be optimized
03:42:03 <jle`> well, of you're talking about foo x = blahbla, and blahbla is some constant, then yes
03:42:09 <jle`> but not if blahbla depends on x
03:42:44 <exio4> oh, read wrong, assumed he meant if `x` would be cached
03:43:23 <jle`> ph88: you can test this in ghci using Debug.Trace to have GHC emit a signal whenever it tries to (re-)evaluate something
03:43:35 <jle`> foo x = trace "hi" (x + 1)
03:43:46 <jle`> call foo 1 twice, and it'll output "hi" both times
03:46:18 <srhb> jle`: Hmm, but shouldn't `bar = foo 1` only emit it on first evaluation?
03:46:44 <jle`> you might have to add a type signature to foo because of polymorphism, heh
03:46:50 <srhb> Yeah.
03:55:29 <srhb> Speaking of the topic, do any of the memoize libraries provide a cache that can auto expire for garbage collection?
03:55:44 <srhb> It doesn't seem trivial.
03:56:22 <srhb> I suppose memoize and auto expiry is really mutually exclusive, caching is probably a better word.
03:57:44 * hackagebot vector-sized 0.4.0.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.4.0.0 (jophish)
03:57:48 <lyxia> Hmm that sounds like an interesting thing to do.
04:00:55 <Grisha> Dear haskellers, I fail to understand the implementation of foldlM: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Foldable.html#foldlM
04:01:19 <Grisha> what puzzles me is: 1) they define foldlM in terms of foldr and 2) the return xs part of the definition
04:04:08 <jophish> Grisha: it might help to 'evaluate' the definition on pen and paper for a few steps to see what's going on
04:04:50 <Grisha> jophish, ok, will do
04:05:12 <Grisha> jophish, but this density of code definitely looks intimidating to me
04:07:28 <Grisha> jophish, could you give me a hint about the precedence of things in the line with "foldr f' return xs z0"
04:07:45 <Grisha> foldr expects three arguments, and here there are four
04:07:51 <johnw> jophish: one thing to bear in mind is that the foldr is producing a function
04:08:03 <mauke> a b c means (a b) c
04:08:04 <Grisha> this return thing gives me headache
04:08:23 <johnw> jophish: oops, I mean, Grisha 
04:08:36 <Grisha> johnw, hm, ok
04:10:04 <ahihi> it may also help to work out the type of f'
04:10:41 <Grisha> I've got to start with the normal foldr I'm afraid
04:13:13 <Grisha> ok, we have f' x k z = f z x >>= k
04:13:27 <Grisha> f z x is of type m b
04:13:42 <Grisha> we shove m b into k
04:13:48 <lyxia> Grisha: foldr f' return xs z0 is foldr applied to 4 arguments.
04:14:28 <johnw> or you can say that it's foldr applied to 3 arguments, whose resulting function value is applied to the last argument
04:14:36 <Grisha> hmmm
04:14:58 <Grisha> ah, ok
04:15:03 <Grisha> if it's a function
04:15:04 <Grisha> sure
04:15:36 <ahihi> or it's foldr applied to one argument, and the result is applied to another argument, and so on :)
04:16:27 <Grisha> so f' applies f to z x and shoves the result into k
04:16:35 <Grisha> k being return from the definition of foldlM
04:16:44 <johnw> 'k' keeps changing
04:17:02 <Grisha> oh, sorry
04:17:26 <Grisha> it's x in the definition of f' that is initialized by return
04:17:37 <johnw> no, you're right that it's k
04:17:47 <johnw> it's going to end up being a chain of >>= calls, with the last k being return
04:17:49 <Grisha> ok, f' is under foldr
04:17:56 <johnw> f ? ? >>= f ? ? >>= f ? ? >>= return
04:18:13 <Grisha> I think I'm getting the idea, but it's still very vague
04:19:11 <johnw> what's happening here is that a left-fold is being encoded using foldr (in order to get a better association for >>=).  This is not a trivial thing at all, so don't feel badly that it doesn't make intuitive sense.  Grokking this construction represents a fairly advanced understanding of higher-order functions.
04:19:52 <johnw> if you were to ever try defining foldl using foldr, you'd use a similar trick
04:19:58 <Grisha> johnw thanks for supporting words.
04:20:05 <Grisha> exactly, I just thought about looking into that
04:22:11 <wagnerf> hi, i'm a haskell newbie
04:22:34 <wagnerf> i'm tring to define a Point structure for holding n-dimensional (usually 2 or 3) points
04:23:22 <wagnerf> up to now i've been using type Point = [Double]
04:23:39 <srhb> wagnerf: Do you really need arbitrary dimensionality?
04:23:46 <srhb> wagnerf: If so, you probably want something that's length indexed.
04:23:57 <wagnerf> well I don't reall need it
04:24:03 <wagnerf> my dimension is bounded by 3
04:24:22 <wagnerf> the trick is that this allows me to map on the coordinates
04:24:29 <wagnerf> which I like somehow
04:24:43 <srhb> wagnerf: You'll get nicer and simpler guarantees if you do data Point = D2 Double Double | D3 Double Double Double
04:24:55 <srhb> YOu'd have to implement your own coordinate maps though
04:25:21 <wagnerf> well, that's basically my question
04:25:48 <wagnerf> i need a type instance 
04:26:14 <wagnerf> (a Displayable class) and I need the Point to implement it
04:26:30 <srhb> Why?
04:26:52 <wagnerf> ok, bear with me
04:26:55 <srhb> Sure :)
04:27:00 <wagnerf> I'm porting one of my code
04:27:01 <srhb> It just sounds very OOP'y
04:27:06 <wagnerf> yes I know
04:27:07 <srhb> Hence my skepticism ;-)
04:27:26 <wagnerf> it is a geometry code
04:27:35 <wagnerf> I have points, segments, arcs, ...
04:27:47 <wagnerf> each shape can be displayed in 2d in svg files
04:28:19 <wagnerf> in my old python code i used to call display(point1, segment1, point2)
04:28:38 <wagnerf> so I was thinking of doing that also in haskell
04:28:44 <srhb> You don't need a class for that though.
04:28:48 <wagnerf> well
04:29:00 <wagnerf> I found some post explaining me how to do it
04:29:23 <wagnerf> to display something it needs to provide two functions
04:29:50 <wagnerf> one is giving me a rectangle containing the shape
04:30:02 <wagnerf> the other is turning the shape into an svg string
04:30:14 <wagnerf> so the haskelly solution I found
04:30:33 <wagnerf> so the haskelly solution I found
04:30:42 <wagnerf> was to declare a shape
04:30:55 <wagnerf> as two functions
04:31:12 <wagnerf> one returning a box and the other returning a string
04:31:17 <wagnerf> then a
04:31:27 <wagnerf> then I can build a list of shapes
04:31:33 <wagnerf> and pass it to display
04:32:13 <wagnerf> I could write : display_shapes [point_to_shape point1, segment_to_shape segment1, point_to_shape point2]
04:32:42 <wagnerf> so if I'm not wrong that would be the way to go
04:32:50 <srhb> oh, okay, so you want to make a Shapable class
04:32:57 <Grisha> wagnerf, make a Shapable class
04:33:44 <wagnerf> yes
04:34:03 <wagnerf> but I cannot do it on my current points
04:34:08 <Grisha> why not?
04:34:22 <wagnerf> because they are an alias for [Double]
04:34:30 <wagnerf> type Point = [Double]
04:34:45 <Grisha> data Point = Point [Double]
04:34:59 <wagnerf> ooh, this works ?
04:35:16 <wagnerf> oh thanks, this is exactly what I was looking for
04:35:24 <Grisha> instance Shapable Point where toShape = ...
04:35:50 <Grisha> where toShape (Point ds) = ...
04:35:52 <Grisha> sorry
04:36:13 <wagnerf> yes I think I can try continuing from there
04:37:05 <Grisha> wagnerf, it's a bit like abstract classes / interfaces / traits / etc. in oop
04:37:11 <wagnerf> Grisha: I did not find examples of "data" with lists so I was wondering if I could do it
04:37:30 <wagnerf> Grisha: actually I'm not really sure how to use it
04:37:46 * hackagebot chronos 0.2.0 - A time library, encoding, decoding, and instances  https://hackage.haskell.org/package/chronos-0.2.0 (andrewthad)
04:38:05 <Grisha> wagnerf, there are many good books online, Learn You A Haskell is a good one
04:38:15 <wagnerf> yes, I read this one
04:38:27 <Grisha> explaining how to define new types with data and making them instances of type classes
04:38:49 <wagnerf> yes but in this book, data is not with lists
04:39:20 <wagnerf> i mean it is difficult to cover all possible examples
04:39:40 <wagnerf> so he declared Points with a constructor and two values
04:39:51 <Grisha> wagnerf, lists are just another data types
04:40:04 <Grisha> *another data type
04:41:02 <Grisha> data User = User String [Users] -- that would be a user with a user name and a list of ``friends''
04:41:21 <Grisha> a FB user record, for example
04:42:00 <Grisha> not only does it have list as a part of the type, it's recursive, having a list of Users
04:43:02 <wagnerf> Grisha: well thanks again. I'll carry on a little bit and surely come back later
04:44:49 <Grisha> wagnerf, you're definitely on a right track trying to figure out the data types before coding anything - didn't happen to me very soon
04:47:57 <Grisha> johnw, is my intuition correct that expressing foldl through foldr builds a long composition chain?
04:49:24 <johnw> Grisha: yes
04:51:16 <Grisha> thanks
04:52:47 * hackagebot lens-xml 0.1.0.0 - Lenses for the xml package.  https://hackage.haskell.org/package/lens-xml-0.1.0.0 (NickPartridge)
04:57:13 <joe9> where is the bytestring openFile that returns a Handle? Is it the System.IO.openFile?
04:58:44 <lyxia> It is. Whether you use a bytestring or not does not affect the choice of handle.
04:58:59 <nathdwek> Hi there, does anyone have hints on how to get something similar to haskell platform going on ubuntu 16.10?
04:59:17 <nathdwek> Because of this: https://wiki.ubuntu.com/SecurityTeam/PIE
05:07:19 <Grisha> foldl as foldr is tough...
05:07:45 <joe9> lyxia: ok, Thanks.
05:09:36 <joe9> wagnerf: there is a haskell library that defines Point and Vector's. I think gloss and diagrams use them too.
05:12:17 <byorgey> if you want a package that defines points and vectors, I recommend vector-space
05:13:02 <joe9> wagnerf: byorgey is the author of diagrams, so, he knows what he is talking about.
05:13:13 <byorgey> though actually diagrams now uses linear instead of vector-space, but vector-space is much friendlier for beginners.  and I don't think gloss uses either one, it uses types defined in the OpenGL packages
05:14:28 <ggVGc> is there anything planned or available in haskell for "extending ADTs"
05:14:54 <wagnerf> byorgey: thanks for the tip. actually for now I' discovering the language with some simple constructs. but for sure a bit later on I'll take a look.
05:15:01 <ggVGc> e.g I have a type with constructors A and B, and I write a function which takes this type and returns a type with A, B and X
05:15:06 <byorgey> wagnerf: sure, makes sense
05:15:29 <byorgey> ggVGc: no, but are you familiar with Wouter Swierstra's paper "Data Types a la Carte"?
05:15:46 <ggVGc> I might have seen the name around, yeah
05:15:49 <ggVGc> but haven't looked at it
05:16:01 <ggVGc> can I accomplish something similar in current haskell?
05:16:18 <ggVGc> I guess this is essentially ADT inheritance, that I'm talking about
05:16:22 <ggVGc> or, subtyping I guess
05:22:11 <byorgey> ggVGc: yes, this is essentially what the "a la Carte" technique allows you to achieve (in current Haskell)
05:24:43 <ggVGc> ah, nice, thanks
05:35:46 <jchia_1> I want to serialize a function call (which function to call with what simple arguments), send the serialized bytes to another Haskell program (that shares some of the same source code) by some medium, and let that program execute the function call, without manually defining the serialization for each individual function or the serialization/deserialization protocol. If I try to serialize an invalid call (e.g. non-existent function or wrong argument type/arit
05:37:24 <liste> jchia_1: cloud haskell does just that
05:37:26 <liste> https://ghc.haskell.org/trac/ghc/blog/simonpj/StaticPointers
05:40:07 <jchia_1> liste: Thanks, I'll check it out.
05:40:45 <liste> jchia_1: also https://haskell-distributed.github.io/
06:02:50 * hackagebot ginger 0.3.5.1 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.5.1 (TobiasDammers)
06:08:43 <allenj12> what do I do if i need a package thats newer than the latest lts-resolver has for stack?
06:11:55 <Squarism> Anyone familiar with differences between Eta and Frege? (haskell jvm compilers)
06:13:24 <liste> allenj12: https://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-different-version-of-a-package-than-what-is-provided-by-the-lts-haskell-snapshot-im-using-what-should-i-do
06:13:29 <sbrg> frege is not exactly a Haskell->JVM compiler
06:13:37 <sbrg> it's A haskell-ish language to JVM compiler
06:13:40 <sbrg> i don't know anything about eta
06:13:54 <allenj12> liste: thank you
06:16:30 <hodapp> yeah, Frege is seeking to be a Haskell implementation, but Eta is just ghcvm
06:17:50 * hackagebot ginger 0.3.5.3 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.5.3 (TobiasDammers)
06:26:55 <hexagoxel> recommendations for libraries with printf-type functionality with indexed/named parameters?
06:27:28 <liste> @hackage formatting -- hexagoel (this does only indexed though)
06:27:29 <lambdabot> http://hackage.haskell.org/package/formatting -- hexagoel (this does only indexed though)
06:28:03 <liste> unless you liftA and use records
06:29:04 <hexagoxel> wait, that supports indexing? does it contain any examples of this in the docs?
06:30:00 <liste> hexagoxel: oh, you mean something like "{0} {0} {1}"
06:30:05 <liste> no, it doesn't do that
06:30:08 <liste> so never mind (:
06:30:45 <hexagoxel> yes, i mean anything that supports usecases where e.g. different languages have different orders for the parameters
06:31:15 <hexagoxel> so probably in the direction of i18n; shakespeare seems to be a candidate.
06:42:34 <ertesx> hexagoxel: one option would be gettext, if you don't mind the foreign library dependency
06:52:41 <tdammers> IIRC, becoming an actual Haskell compiler is a current goal for Frege
06:52:51 * hackagebot haskell-src-exts 1.19.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.19.0 (mpickering)
06:57:12 <hexagoxel> ertes: right, thanks. could it be that hgettext does not expose the full interface of gettext?
06:59:07 <hexagoxel> just comparing the length of the gettext manual and hgettext haddock.. it does not add up, heh.
07:10:08 <nathdwek> Hi there, does anyone have hints on how to get haskell platfrom going on ubuntu 16.10?
07:10:10 <nathdwek> I'm having issues linked to this: https://wiki.ubuntu.com/SecurityTeam/PIE
07:12:19 <hexagoxel> nathdwek: have you seen https://mail.haskell.org/pipermail/haskell-cafe/2016-October/125391.html
07:12:28 <allenj12> so the state monad is now a StateT with the identity? if I have pop :: State Stack Int, pop = State $ \(x:xs) -> (x,xs). what is the new type signature of the function afterv converting it to state $ ...
07:13:55 <nathdwek> hexagoxel: Thanks for your help, but what about project specific ghc installed by stack?
07:14:32 <nathdwek> I'm very new to this environment, but I'd imagine I'd have to replicate this change in every project that has a specific ghc?
07:15:32 <hexagoxel> nathdwek: probably needs similar changes to the settings for the ghc installed below `stack path --ghc-paths`
07:15:43 <lyxia> allenj12: either you have   pop = State $ \(x : xs) -> Identity (x, xs)   or   pop = state $ \(x : xs) -> (x, xs)   both with the same type.
07:16:04 <lyxia> allenj12: State Stack Int
07:16:36 <nathdwek> hexagoxel: ok thanks. This is only temporary though, right? Do you know when a more robust fix is coming up?
07:16:46 <allenj12> lyxia: in your first option, dont you mean StateT?
07:17:23 <hexagoxel> nathdwek: this probably should be fixed by stack itself too, but i have not looked into how the stack people handle this.
07:17:32 <hexagoxel> probably worth having a look at their issue tracker
07:17:46 <nathdwek> yup there's an issue on github that I read
07:18:08 <nathdwek> But didn't help me at the time, I'll reread to see how they're planning to tackle this
07:19:04 <lyxia> allenj12: oops yes
07:19:22 <allenj12> lyxia: cool thanks
07:22:24 <lyxia> allenj12: you can have a more general type   pop :: Monad m => StateT Stack m Int   with    pop = State $ \(x : xs) -> return (x, xs)    or    pop = state $ \(x : xs) -> (x, xs) -- the same as above
07:23:34 <tsahyt> I have some functions in this codebase that take lists as inputs, and I was thinking that changing [a] to Foldable t => t a would probably make for a better interface. is there a reason why I shouldn't do this?
07:23:51 <tsahyt> also, does it makes sense to add specialize pragmas for list versions or will GHC figure that out?
07:24:40 <tsahyt> the semantics of these functions allow "list-like of a" or "collection of a"
07:27:32 <hackal> Hi, can if-then-else expression work with integers?
07:27:42 <srhb> hackal: "work with" ?
07:28:43 <hackal> I know this is not haskell syntax but something like this if (1) then ... else ...
07:28:58 <srhb> hackal: With literals, you sort of could, but the real answer is "no"
07:29:43 <hackal> Alright, I am doing simple typechecker and was not sure if that is valid or no
07:29:58 <srhb> It is not. The value after "if" must be of type Bool
07:29:58 <allenj12> lyxia: ahh, alright
07:29:59 <daey_> hackal: how i understand it you need a bool for that
07:30:11 <daey_> you could compare the integer to something then you get a bool
07:33:01 <spiek> Hi guys, I need to extract Letters from a String and put only the numbers in a List. E.g. "a16B008Lk1234n1151248cvK" ->> ["16","008","1234","1151248"]
07:33:13 <spiek> I currently have this http://lpaste.net/7752879963186921472
07:33:48 <shapr> spiek: could you use filter instead?
07:34:23 <spiek> shapr: what should I filter? I tried with isDigit and isAlpha
07:34:36 <shapr> spiek: What was the result?
07:35:44 <spiek> I can't remember sry.. I tried it now for 3 hours nearly :D
07:36:22 <damian_> does anyone experience with hdevtools and stack?
07:37:03 <ongy> :t groupBy
07:37:04 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:37:08 <c_wraith> damian_: it doesn't make much sense to use both
07:37:46 <ongy> c_wraith: why would it not? hdevtools and stack have different goals
07:37:54 <spiek> spiek: But I know that the function "words" is good for my problem. Sadly I cant combine the functions together, because it always throws an error
07:37:56 <damian_> c_wraith: why not? I am developing a project using stack and want to use hdevtools in vim 
07:38:08 <c_wraith> Oh.  I mistook hdevtools for henv
07:38:24 <c_wraith> Incorrect information, carry on
07:38:54 <sbrg> > let foo _ [] = []; foo f xs = takeWhile f xs : foo f (dropWhile (not . f) . dropWhile f $ xs) in foo isDigit "a16B008Lk1234n1151248cvK" 
07:38:56 <lambdabot>  ["","16","008","1234","1151248"]
07:38:57 <lambdabot>  
07:39:08 <sbrg> something along those lines
07:39:38 <shapr> spiek: I'd use filter and isDigit, I think that will work.
07:39:41 <ongy> > words . map (\x -> isDigit x then x else ' ') $ "a16B008Lk1234n1151248cvK"
07:39:44 <lambdabot>  <hint>:1:30: error: parse error on input ‘then’
07:39:44 <lambdabot>  
07:39:51 <ongy> > words . map (\x -> if isDigit x then x else ' ') $ "a16B008Lk1234n1151248cvK"
07:39:53 <lambdabot>  ["16","008","1234","1151248"]
07:39:54 <lambdabot>  
07:39:56 <shapr> spiek: one thing that helps me is to look at the types of the functions to see how to plug them together
07:39:58 <sbrg> that's neater
07:40:07 <ongy> when did lambdabot switch to printing the newline?
07:40:24 <spiek> shapr: it should be extractNumerals :: String -> [String]
07:41:19 <lyxia> > wordsBy isDigit "a1b2"
07:41:21 <lambdabot>  ["a","b"]
07:41:21 <lambdabot>  
07:41:39 <ongy> @hoogle wordsBy
07:41:42 <lambdabot> Data.List.Split wordsBy :: (a -> Bool) -> [a] -> [[a]]
07:41:42 <lambdabot> Data.List.Split.Internals wordsBy :: (a -> Bool) -> [a] -> [[a]]
07:41:42 <lambdabot> Text.XML.HaXml.Schema.NameConversion wordsBy :: (a -> Bool) -> [a] -> [[a]]
07:41:48 <shapr> oh, didn't know about wordsBy
07:42:00 <sbrg> > wordsBy (not . isDigit) "a2b2"
07:42:02 <lambdabot>  ["2","2"]
07:42:03 <lambdabot>  
07:42:06 <ongy> is that in base? I searched for it at some point, but don't remember it
07:42:09 <shapr> Is wordsBy in MissingH ?
07:42:23 <c_wraith> Looks like it's in split
07:42:54 <shapr> That's handy
07:43:19 <sbrg> no need to pull that package in when you have a simple solution using prelude/Data.List stuff
07:43:25 <sbrg> like ongy's solution
07:45:24 <c_wraith> that's the issue with the whole split package - everything in it is relatively easy to do without.  You have to decide at some point that you'd rather have convenience.
07:45:50 <allenj12> lyxia: is there a way to avoid what seems to be a constant need for flexibleContexts with the State Monad (assuming because its multiparameter). for example I think I should be able to do something like 'get pop' but it errors saying i need flexibleContexts
07:46:52 <lyxia> I think FlexibleContexts comes fairly naturally with mtl, and more generally multiparameter typeclasses.
07:47:25 <lyxia> I don't think you can or should avoid it here.
07:47:30 <c_wraith> allenj12: You should basically never hesitate to enable FlexibleContexts or FlexibleInstances
07:47:40 <allenj12> Ok
07:47:51 <allenj12> how to enable it in the repl?
07:48:00 <c_wraith> :set -XFlexibleContexts
07:48:14 <c_wraith> Or just -XFlexibleContexts when you start it up
07:48:36 <allenj12> gotcha, thanks!
07:49:07 <john_a> http://pastebin.com/KuGDdYi1 why does this give an error saying it expects Array (Int, Int) Int, but the actual type is Array Int Int?
07:49:07 <allenj12> lyxia: also what is mtl? monad transformer library?
07:49:07 <lyxia> I think there are times where you don't need it and GHC's suggestion to turn it on is in fact a red-herring.
07:49:29 <lyxia> allenj12: yes, aren't you depending on it? since you use get.
07:49:46 <c_wraith> lyxia: could just be using transformers.
07:49:54 <allenj12> yea, just sometimes forget :D
07:49:57 <john_a> (if Config had the signature Config (Array (Int, Int) Int), forgot to change it
07:50:15 <lyxia> oh for some reason I thought get was an mtl thing.
07:50:42 <c_wraith> lyxia: get belonging to MonadState is an mtl thing.
07:50:45 <lyxia> allenj12: then it sounds a bit odd that you have a need for FlexibleContext
07:51:16 <c_wraith> lyxia: but transformers also has get for the concrete types
07:51:24 <lyxia> c_wraith: I thought it had another name in transformers.
07:51:40 <lyxia> Ok.
07:52:14 <allenj12> lyxia: well in short Im trying to understand this function someone posted on the subreddit ill paste if your interested
07:52:46 <lpaste> allenj12 pasted “pairs” at http://lpaste.net/321971
07:55:27 <john_a>  /j #haskell-beginners
07:55:45 <spiek> Thanks guys for your help :)
07:57:07 <drninjabatman> hello
07:58:34 <drninjabatman> Is there a way when tell ghci "A \10781 B" for it to print back the actual unicode symbol instead of \10781?
07:58:37 <shapr> hi drninjabatman 
07:58:56 <shapr> huh, would that depend on your font?
07:58:57 * shapr tries
07:59:31 <shapr> For some reason I thought that would work, and I don't know why it doesn't
07:59:42 <drninjabatman> shapr: if i do `putStrLn "A \10781 B"` it does the right thing
08:00:10 <shapr> but print doesn't do the right thing
08:00:16 <drninjabatman> the problem is mostly the exceptions that refuse to generate utf8 strings
08:00:25 <shapr> huh?
08:00:33 <drninjabatman> shapr indeed
08:00:52 <shapr> Wait, exceptions won't generate utf8 strings? I'm confused.
08:01:07 <tdammers> the reason print doesn't do the right thing is because it calls show
08:01:11 <hexagoxel> @src print
08:01:12 <lambdabot> print x = putStrLn (show x)
08:01:12 <lambdabot>  
08:01:26 <Tuplanolla> The `Show` instances for `Char` and `String` convert special characters into a form that is guaranteed to not get lost in the way.
08:01:32 <hexagoxel> if print does not do the right thing, you apparently don't want `show`
08:01:42 <Tuplanolla> > show '\NUL'
08:01:44 <lambdabot>  "'\\NUL'"
08:01:44 <lambdabot>  
08:01:49 <tdammers> and the Show instance for strings produces the right thing, namely a Haskell string literal with most non-ascii stuff escaped
08:02:23 <tdammers> show does the right thing, fsvo "right"
08:02:37 <drninjabatman> that sounds like a sound design decision. Is there a way to override it?
08:02:48 <Cale> By using putStrLn instead of print
08:02:57 <tdammers> not that I know of, and you shouldn't override it anyway
08:03:11 <tdammers> Show is not intended for anything user-facing
08:03:17 <tdammers> it's more or less a debugging aid
08:03:28 <drninjabatman> because I am stuck with either useless errors or ascii characters
08:03:43 <Cale> Where is this showing up?
08:03:44 <tdammers> the solution is not to use print
08:04:12 <Cale> You should always be able to avoid applying show to the String in question...
08:04:19 <drninjabatman> I am building an expression rewrite system
08:04:21 <tdammers> if your error is just a string, use putStrLn; if it's some other data structure, then destructure it and feed the parts to printf
08:05:15 <drninjabatman> is there a way to tell ghci to use putStrLn instead of print?
08:05:24 <drninjabatman> actually
08:05:29 <drninjabatman> that would make no sense
08:05:32 <drninjabatman> hmm
08:05:32 <Cale> drninjabatman: By... applying putStrLn
08:05:45 <Cale> If you give an IO action to ghci, it will execute that IO action.
08:06:25 <ab9rf> ghci just lives to execute IO actions
08:06:33 <Cale> If you give basically anything else to ghci, it will try applying print to it to turn it into an IO action that it can carry out.
08:07:32 <Cale> (it will also capture the results of IO actions it runs, and whenever they're of a non-() type which is an instance of Show, it will apply print to those too)
08:07:38 <hexagoxel> there is one hack.. write a custom Show instance for your error or a custom new wrapper around errors, which behaves more like id than show does
08:08:30 <hexagoxel> presuming that your error fundamentally wraps a String already.
08:09:17 <drninjabatman> ugh.. I will just use "\join" in `show`
08:09:47 <drninjabatman> or make show print out s-expressions or sth
08:10:57 <Cale> Generally, you want show to produce valid Haskell code for reconstructing the value.
08:11:24 <Cale> (Or if this isn't possible, something as close to that as you can get)
08:11:51 <Cale> If you want to do other sorts of prettyprinting, invent another function for that
08:25:11 <ocramz> does a "Sparse" container class exist somewhere already? I.e. for which the number of elements is in general smaller than the container's size
08:33:51 <jchia_1> What does single quote mean in haskell other than for enclosing a Char? For example, in the "remotable [ 'f, 'g, ... ]" on this page: http://hackage.haskell.org/package/distributed-process-0.6.6/docs/Control-Distributed-Process-Closure.html
08:34:06 <Cale> int-e: lambdabot is producing a newline after each evaluation response now...
08:34:11 <Cale> > 1 + 1
08:34:13 <lambdabot>  2
08:34:13 <lambdabot>  
08:34:25 <sbrg> lol
08:34:28 <Tuplanolla> There's also a leading space for some reason.
08:35:28 <ertes> hexagoxel: i don't know, sorry…  the one time i needed i18n i just used a class- and reflection-based approach
08:35:33 <nitrix> IRC logs seems to hint it's since midnight EST.
08:36:09 <grazie> from `Real World Haskell` I'm not sure why the String instance is illegal but not the Bool instance  http://imgur.com/a/Q1TmY Can you explain?
08:36:48 <ertes> jchia_1: single quotes are used in template haskell to refer to identifiers
08:36:58 <tsahyt> grazie: it's only illegal in haskell98, you can write this in today's GHC haskell
08:37:52 <grazie> tsahyt I understand that, but I don't understand why the String instance is illegal while the Bool is legal. Is the Bool not a "type in place of a type parameter" like the String instance?
08:38:28 <ertes> grazie: type String = [Char]
08:38:33 <ertes> [Char] = [] Char
08:38:35 <glguy> grazie: Did you read the explanation that you pasted?
08:38:40 <tsahyt> grazie: in haskell98, an instance head must have form C (T u_1 .. u_k) where T is some type constructor (like []) and the u_i are distinct type variables
08:38:47 <grazie> glguy Yes, I read it, but I didn't understand the explanation
08:38:54 <tsahyt> so JSON [a] is fine of course, because you have a type constructor [] and a type variable a there
08:39:07 <tsahyt> JSON Bool is fine too, because Bool itself is a type constructor
08:39:43 <tsahyt> [Char] is the same as [] Char and Char is not a type variable.
08:39:46 <ertes> instance JSON (List Char)  -- bad, because Char is concrete
08:39:48 <tsahyt> so that's illegal
08:40:00 <ertes> instance (JSON a) => JSON (List a)  -- good, because a is a type variable
08:40:34 <glguy> grazie: instance need to be on types of the form:   CapitalizedThing lowercase lowercase1 lowercase2...
08:40:40 <tsahyt> FlexibleInstances isn't bad per se, but usually it's not what you want. you want the more general version, like the one ertes wrote down
08:40:48 <tsahyt> FlexibleContexts are more useful imo
08:40:49 <glguy> [] is a special case of a type constructor, most are capitalized names
08:40:53 <grazie> tsahyt thank you that helps a lot. but why is Bool a type variable but not Char ?
08:41:00 <tsahyt> grazie: neither is a type variable
08:41:21 <tsahyt> both are type constructors. but you need ONE type constructor with the type variables that it takes
08:41:59 <grazie> tsahyt so what is the type variable in the Bool case? 
08:42:04 <tsahyt> grazie: there is none
08:42:12 <tsahyt> Bool is Bool, it has kind * -> *
08:42:14 <tsahyt> no
08:42:16 <tsahyt> *
08:42:18 <tsahyt> sorry
08:42:19 <grazie> tsahyt but don't you need a type variable ?
08:42:24 <tsahyt> so Bool :: *. we're done here
08:42:41 <glguy> grazie: You're allowed to apply the type to type variables, you don't have to
08:42:47 <tsahyt> no, type variables are only required for type constructors that have kinds like * -> *, or * -> * -> *, etc.
08:43:17 <tsahyt> required is the wrong word here, let's say they only make sense for such type constructors
08:43:54 <grazie> ertes thank you for your explanation as well
08:44:15 <ertes> grazie: [A] = [] A  -- do you understand this?  note that [] is a *type* here; all of this is on the type level
08:44:46 <grazie> ertes [] is the type constructor, A is the type variable (but why is it capitalized?)
08:45:05 <ertes> grazie: A is a concrete type (i didn't pick any one in particular)
08:45:13 <ertes> think A = Integer or something
08:45:17 <ertes> or Char in this case
08:45:27 <grazie> ok
08:46:00 <ertes> every type has a kind like (Char :: *), where '*' is the kind of concrete types
08:46:18 <tsahyt> a kind is like the "type of a type"
08:46:20 <ertes> and type constructors like [] and Maybe are of kind * -> *, they take a type as argument
08:46:54 <ertes> so if (A :: *), then ([] A :: *); just like you apply functions you apply type constructors
08:47:03 <grazie> ok, it's starting to make sense. The book certainly doesn't explain it in this much detail
08:47:40 <ertes> grazie: it probably will later…  unfortunately most learning materials delay talking about kinds
08:48:20 <ertes> grazie: in any case, if you want to write an instance when a type constructor is involved, then all its arguments must be type *variables*
08:48:36 <ertes> instance C ([] a)  -- this one is fine
08:48:41 <ertes> instance C ([] A)  -- this one isn't
08:48:50 <grazie> gotcha
08:48:55 <tsahyt> (unless you enable FlexibleInstances)
08:49:11 <ertes> instance C A  -- this one is fine again, because A is just a concrete type (*), not a type constructor (* -> *)…  it doesn't expect any arguments
08:49:45 <tsahyt> ertes: couldn't you say A is a type constructor that is fully applied already?
08:49:57 <tsahyt> all the type variables that it could possibly take (i.e. none) have been applied
08:50:10 <ertes> tsahyt: that brings us into "nullary functions" territory, and i don't like to go there =)
08:50:32 <ertes> a function takes exactly one argument, and similarly a type constructor takes exactly one argument
08:50:51 <tsahyt> well that does make things easier
08:51:14 <ertes> i like to think of type constructors just as functions one level up
08:51:33 <tsahyt> me too. they're just type level functions for me
08:51:43 <tsahyt> of a particular flavor
08:51:56 <grazie> everyone here's been so helpful (I've asked a few questions recently) thank you very much
08:52:15 <tsahyt> once you start thinking of them as type level functions, the bridge from haskell functors to categorical functors is also much easier
08:53:01 <tsahyt> then F A is just A under the functor F, fmap f is just f : A -> B under the functor F, i.e. F A -> F B
08:53:10 <tsahyt> and I can free myself of all burrito analogies
08:53:36 <ph88> data Count = One | Node [[Count]] deriving (show)   Illegal deriving item ‘show’   In the data declaration for ‘Count’    why i can't derive show ?
08:53:51 <tsahyt> ph88: because it needs to be capitalized
08:53:53 <ertes> ph88: you don't derive functions, you derive classes
08:54:03 <tsahyt> typeclasses start with capital letters, e.g. Show
08:54:16 <ph88> oooh
08:56:05 <lpaste> slack1256 pasted “linker failing” at http://lpaste.net/322096
08:56:29 <slack1256> can anyone help me with that failing linker stage? I am on nixos
08:56:32 <tsahyt> ertes: So I've got some configuration object, basically a tagged tree that can be accessed using mutation inside some C library. To make this more usable I was thinking of creating an ADT + lenses, and functions that get this representation and set it back into the state, or even just a modify function like in MonadState. Am I somewhat on the right track here?
08:57:03 <tsahyt> ertes: I've been asking this here last week already, but now I'm at the point where I've abstracted the worst C-isms away, i.e. everything's memory managed, exceptions are reintroduced etc
08:57:15 <tsahyt> so I've got a somewhat safe interface at this point, but it's still not very haskell-y
08:58:41 <tsahyt> I think if I go for a modify :: (Conf -> Conf) -> IO () function, I can get away with reading the tree out using unsafeInterleaveIO too, so I can utilize laziness. Since the modification must happen in one step and everything else blocks in the meanwhile, the data can't mutate under my nose
08:58:43 <dolio> ertes: Why would you think of them that way when value constructors aren't necessarily functions?
08:59:17 <dolio> And not all value functions are constructors.
08:59:34 <glguy> "type constructor" is a category of names; it doesn't pertain to the kind of a type
09:00:24 <ertes> tsahyt: if you can make the conversion from the C structure to an ADT sufficiently lazy, then it seems like a good approach to go from C to haskell, but as soon as you need to go back, you need to do a full write again
09:01:08 <ertes> tsahyt: if you really need the C library to do modifications, i suggest just staying mutable, unless there is a major payoff making a pure wrapper
09:01:22 <tsahyt> that is correct. unless I can somehow mark what is dirty
09:01:38 <ertes> dolio: i never thought of value constructors and type constructors as similar things…  "constructor" is just an overloaded name
09:01:55 <ertes> tsahyt: yeah, dirty-marking could work
09:01:58 <tsahyt> ertes: the C library underneath shouldn't make modifications. As a config object it *should* be read-only for the C library.
09:02:15 <ertes> tsahyt: but remember that dirty-marking violates the lens laws, so you can only do it, if you make the ADT abstract
09:02:17 <ph88> this code works as i expect but i find it just utterly confusing, any suggestions on how i can refactor this?   https://paste.fedoraproject.org/467374/47801610/
09:03:24 <ph88> wtf the pastebin removes part of the output -___-
09:03:27 <dolio> ertes: But there is a class of type-level things that are very similar. And type classes match on them as if they were constructors of *, like case statements match on constructors of a type.
09:03:42 <dolio> And it's unnecessary to have another name for 'type function'. :)
09:03:45 <tsahyt> I guess it's not strictly necessary to provide a nice interface, but the stateful one that the library provides is just spectacularly ugly in the context of Haskell
09:04:10 <grazie> can someone explain why the first instance of Foo uses the => (arrow) while the others don't? http://imgur.com/a/diHq0
09:04:30 <Cale> ph88: http://lpaste.net/
09:04:32 <ertes> dolio: well, since closed type synonym families i don't feel too bad calling them "type functions" anyway =)
09:04:52 <tsahyt> grazie: on the left-hand side of => there's a context. the implementation for [a] uses the implementation for a.
09:05:09 <tsahyt> I read these as "given a Foo instance for a, there's a Foo instance for [a]"
09:05:25 <tsahyt> it's the same as => in function type signatures really
09:05:29 <Cale> grazie: Yeah, only that instance requires another instance to exist
09:05:50 <grazie> ok, so how would you read the instances without the arrow?
09:05:59 <ph88> Cale, http://lpaste.net/5147108431231975424
09:06:09 <tsahyt> grazie: "Char is an instance of Foo"?
09:06:12 <tsahyt> for example
09:06:23 <tsahyt> or "there's a Foo instance for Char" to stay consistent with above
09:06:25 <grazie> ok
09:06:38 <ertes> "there is an instance (Foo Char)"
09:06:43 <Cale> ph88: there you go... do you have an English language description of the problem you're trying to solve?
09:07:02 <ertes> "given any instance (Foo a), here is an instance (Foo [a])"
09:09:48 <ertes> i think except for some implicit "for all"s and the "=>" symbol, haskell instances read almost like plain english
09:10:28 <slack1256> I remember there was a web ide for haskell (fp complete?) I can find anything on duckduckgo. Anybody with the link?
09:10:59 <slack1256> oh, nvm
09:11:19 <ph88> Cale, i will type it .. moment plz
09:14:53 <lpaste> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/5147108431231975424#a322130
09:15:08 <zomg> slack1256: I think they phased it out
09:15:18 <Cale> ph88: There's my attempt at cleaning it up a bit without really understanding what you're computing
09:21:02 <ph88> Cale, https://paste.fedoraproject.org/467379/47801722/
09:23:18 <ph88> nice one-liner here ^^     new len = Node $ [map new (lenParts len x) | x <- [2..len]]
09:24:43 <Tuplanolla> You don't need a list comprehension for that, ph88.
09:26:09 <ph88> new len = Node $ map new (lenParts len [2..len])    ?
09:26:23 <ph88> don't think that will work
09:27:00 <xa0> xa0
09:27:04 <xa0> xa0:
09:27:06 <byorgey> you can always write anything without a list comprehension, I'm not sure what Tuplanolla means in this case
09:27:22 <byorgey> looks like a sensible use of a list comprehension to me
09:27:55 <byorgey> without the list comprehension you would need >>= or something
09:28:03 <Cale> ph88: This sounds vaguely like you want to compute (all?) the partitions of a positive integer.
09:29:01 <Tuplanolla> You have `[map f x | x <- xs]`, so you might as well write `(map . map) f xs`.
09:29:27 <ph88> Cale, there needs to be a sequence .. if you test a large partition and all are True then i can skip all the partitions you could have made out of that large partition
09:29:36 <slack1256> Can anybody help me out? I got a linking error building this https://github.com/RubenAstudillo/proyecto-lena which I think is nixos fault instead of haskell
09:29:49 <slack1256> can anybody build and see if it crashes?
09:30:24 <ertes> slack1256: make sure shell.nix is up to date (it really shouldn't be part of the repo!)
09:30:36 <Cale> ph88: ah, okay
09:30:37 <slack1256> you're right
09:30:46 <ph88> by the way   data Count is just an intermediate type ... i still have to extract the actual combinations out of that
09:30:47 <ertes> slack1256: most likely:  cabal2nix --shell . > shell.nix
09:31:09 <ertes> slack1256: then you can use nix-build and nix-shell with it
09:31:33 <Tuplanolla> Where would you use `>>=`, byorgey?
09:31:47 <slack1256> still, bringing shell.nix up to date shows the weird linking error
09:32:40 <slack1256> (I would be really thankful if somebody on a FHS distro compiled it and compared)
09:32:46 <ertes> slack1256: if it still happens, the next thing i'd do is make sure that the channel is up to date, and if it still fails, paste the error (but most likely it's something bug-report-worthy)
09:33:10 <ertes> slack1256: how are you compiling?  do you use nix or just GHC/cabal?
09:33:42 <slack1256> http://lpaste.net/322096
09:34:10 <slack1256> I launch a nix-shell environment and do `cabal configure && cabal build`
09:34:32 <geekosaur> that is a module that needed to be listed in other-modules
09:34:38 <slack1256> WEIRD
09:35:01 <slack1256> it compiles if I do `cabal configure` instead of `cabal configure --disable-optimization` (testing build)
09:35:37 <ertes> slack1256: what geekosaur said
09:35:46 <ertes> slack1256: one module is not listed at all in the cabal file
09:36:14 <ertes> (cabal should really warn about something like this…  it has happened to me a few times, too)
09:36:32 <slack1256> Oh
09:36:56 <geekosaur> that's potentially Hard. if it changes with optimization, then the cabal file is conditionally including modules (probably thinking that is only used for e.g. testing)
09:37:27 <geekosaur> and as such a perfect example of why checking can only really be done by building a dependent and seeing if it links
09:38:06 <slack1256> geekosaur: thanks you, I was going nuts on this!  
09:38:12 <slack1256> thanks ertes too
09:38:12 <ertes> well, at some point in time cabal certainly has a module dependency graph, and it could just warn about any modules that it would build that aren't listed in the cabal file
09:38:20 <geekosaur> otherwise it'd have to force you to list every module in the project somewhere even if it's only relevant to some special case, which is dumb and sometimes impossible (e.g. different impl moduless for unix v windows)
09:38:43 <ertes> at least for the library section
09:39:21 <ertes> even if it's only dynamic (it only warns about missing windows modules when building on windows)…  it doesn't have to be perfect
09:47:51 <mohsen_> I run this code: https://ptpb.pw/TMxt but I get these two errors: https://ptpb.pw/Njxy
09:49:01 <mohsen_> Where am I doing wrong?
09:49:42 <geekosaur> the first one is missing parentheses
09:50:09 <geekosaur> ``appendFile "data" firstName++lastName++phoneNumber++"\n"'' means (appendFile "data" firstName) ++ lastName ++ ...
09:51:03 <geekosaur> and the second is a knock-on error from the first
09:52:30 <mohsen_> Oh I see
09:54:39 <mohsen_> problem solved
09:54:55 <mohsen_> geekosaur: Thank's friend
09:57:58 * hackagebot download 0.3.2.5 - High-level file download based on URLs  https://hackage.haskell.org/package/download-0.3.2.5 (psibi)
10:00:31 <int-e> Cale: hmpf, thanks.
10:01:37 <tabaqui1> I have "data Foo = {x :: Int, y :: Int}"
10:01:48 <tabaqui1> and x = Foo {x = 1, y = 2}
10:02:20 <tabaqui1> *a = Foo {x = 1, y = 2}
10:02:38 <tabaqui1> how can I change a, alike b = a {x = 3}?
10:03:16 <tabaqui1> oh, I get it_
10:03:17 <tabaqui1> )
10:03:34 <tabaqui1> hm, I should check it next time by myself
10:03:54 <monochrom> :)
10:08:28 <allenj12> can someone explain me a part of this function http://lpaste.net/321971 . mapMaybeM returns an m [b] but if monad is the State monad, how can this apply if State a b takes two parameters?
10:09:45 <icosane> allenj12: lpaste says lpaste is down for maintenance
10:09:59 * geekosaur still trying to load, but in general m there is State a
10:10:04 <kadoban> allenj12: Page won't load at the moment, but with stuff like state, the Monad is actually "State a", so technically State isn't a Monad. You give it one more type variable and then it's a Monad.
10:10:33 <kadoban> This is similar to Either, if you're familiar with that.   Either isn't a Monad.  Either e   is though.
10:11:51 <allenj12> kadoban: o weird ok
10:12:01 <allenj12> so only State s is a monad?
10:12:06 <allenj12> i guess that makes sense
10:12:14 <kadoban> Yes
10:12:41 <kadoban> In fact, all Monad instances (or Functor or Applicative as well) are of kind  * -> *, if you're familiar with kinds.
10:12:54 <kadoban> (If not ... it's pretty much the same thing said in a different way)
10:12:58 <allenj12> kadoban: just leaned them, so yea :D
10:13:08 <geekosaur> think of it as partial application at the type level. (State s) similar to (1+)
10:13:26 <geekosaur> or (map toUpper)
10:14:13 <allenj12> so when i mapMaybeM f where M is the State s, so I get a State thats waiting for the other parameter?
10:14:49 <geekosaur> guh, lpaste still returning the maint page :(
10:14:57 <allenj12> :(
10:15:37 <icosane> In the meantime, you can use this paste server: https://paste.fedoraproject.org/
10:15:37 <kadoban> allenj12: Is mapMaybeM :: (Monad m) => (a -> m (Maybe b)) -> [a] -> m [b]   -- or something?
10:15:54 <allenj12> kadoban: yes exactly that 
10:16:06 <allenj12> λ> :t mapMaybeM
10:16:06 <allenj12> mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]
10:16:12 <kadoban> allenj12: Then the 'm', everywhere in there is "State s" for whatever s you've picked
10:16:44 <allenj12> kadoban: ooo so its a State s [b]
10:16:48 <kadoban> Yep
10:16:52 <allenj12> that makes total sense 
10:16:55 <allenj12> lol thank you
10:16:56 <allenj12> !
10:16:59 <kadoban> Anytime
10:17:19 <allenj12> gotta play csgo with distracting dev partner..... be back later
10:17:29 <kadoban> Haha, have fun
10:17:57 <tabaqui1> library already has definition of instance type
10:18:07 <tabaqui1> but I want my own definition
10:18:18 <tabaqui1> so instance Foo Bar where... but
10:18:34 <tabaqui1> error:
10:18:36 <tabaqui1>     Duplicate instance declarations:
10:18:43 <kadoban> tabaqui1: You'll probably have to make a newtype wrapper and give an instance to that
10:19:23 <icosane> this is because a type may have at most one instance declaration for a given class
10:21:25 <tabaqui1> icosane: yeah, but maybe I could hide something?
10:22:13 <icosane> tabaqui1: Well, there was something written about that on the haskell wiki. Instance declarations of one module leak into other modules.
10:22:38 <kadoban> tabaqui1: In short: no
10:22:48 <icosane> tabaqui1: But if you wrap the type (newtype), you can add an instance declaration for the wrapper
10:23:48 <byorgey> you can hide types, but you cannot hide type class instances
10:24:01 <tabaqui1> kadoban: hm, but hack with newtype looks working
10:24:28 <kadoban> tabaqui1: It's not really a hack, it's intended.
10:24:31 <tabaqui1> well, anyway I should refactor it later, when I'll understand this monad
10:25:09 <icosane> tabaqui1: As a rule of thumb: only add instance declarations for types of other packages within your packages if you wrote the class yourself, adding instance declarations to your own types is ok in general
10:26:44 <icosane> newtype's intended usage is wrapping another type, such that represented the same in memory, but with the two types (wrapper and wrapped) actually being different for the type system
10:30:22 <allenj12> kadoban: btw (in a match might not respond) here is the code https://www.reddit.com/r/haskell/comments/5a57ck/pairs_of_10_in_a_list/d9g55jt/
10:32:35 <balshazar> Hi folks, an executable generated via Stack/Cabal is generating .tix files after execution in whatever directory it was invoked from. My understanding is that Stack is implicitly adding -fhpc to my GHC options when building. Is there a way to disable this behavior (e.g. for app/Main.hs)? A minimal representation of my Cabal file is here: https://gi
10:32:35 <balshazar> st.github.com/anonymous/2860861a422892114f565802eeb1b2c9
10:34:42 <hrk> Hello. I'm getting lexical error "lexical error at line 47, column 14
10:34:42 <hrk> CallStack (from HasCallStack):" thrown while parsing java file using language-java package. It seems to be thrown from here https://www.stackage.org/haddock/lts-7.7/language-java-0.2.8/src/Language.Java.Lexer.html#alex_action_14
10:35:01 <hrk> Is there a way to catch the error? With something like Control.Exception.catch?
10:37:20 <cocreature> > error "hello world" `catch` \((SomeException e) :: SomeException) -> print (typeOf e)
10:37:23 <lambdabot>  <IO ()>
10:37:25 <cocreature> meh
10:37:36 <cocreature> hrk: catch ErrorCall
10:38:07 <cocreature> the line I tried to execute above shows you the type of the exception (if you run it in ghci) which can be helpful to figure out which exception you want to catch
10:38:51 <cocreature> hrk: and make sure that the error string is the one you expect, otherwise you will catch all calls to error
10:41:13 <hrk> cocreature: cool, thanks! That was helpful
10:41:55 <cocreature> why anybody would use "error" to signal lexing errors is beyond me
10:43:16 <geekosaur> because they don't know the difference between error and fail
10:43:30 <geekosaur> which arguably is part of why fail is a bad thing
10:45:50 <cocreature> can you run fail in that context? I’ve never worked with alex
10:46:56 <geekosaur> iirc alex added a monadic lexer framework some versions back, so yes
10:47:09 <geekosaur> at least potentially
10:58:51 <bollu> how does intero pull type information? I want to write a sublime text plugin that uses the infrastructure
11:00:44 <monochrom> it calls GHC API
11:01:18 <monochrom> actually I am not sure about that. But there are only two ways. call GHC API. harness ghci.
11:02:34 <geekosaur> ghci is a wrapper for ghc-api :)
11:03:03 <monochrom> yes that too :)
11:03:07 <geekosaur> anyway, intero, ghc-mod, etc. all wrap ghc-api in various ways to get that information
11:03:32 <geekosaur> (sadly this is also why they break so often. ghc-api is not exactly stable)
11:04:13 <bollu> god damn
11:04:16 <bollu> hm
11:04:23 <bollu> I was hoping to not have to do so much work
11:04:26 <acowley> A smart thing Intero does is install itself fresh for every project
11:04:40 <acowley> I mean, it's a shocking inefficiency, but also super effective
11:05:06 <geekosaur> it has to build against the same ghc your project is using. makes sense
11:05:44 <acowley> bollu: I think you could use Intero out of the box, you just talk it's protocol via pipes
11:05:48 <allenj12> alright im back, lets see if lpaste is still down
11:06:41 <acowley> Unfortunately, it is likely the case that the required documentation for that protocol is written in elisp.
11:06:50 <acowley> But I think it's quite minimal
11:06:59 <bollu> acowley: I see
11:07:02 <bollu> acowley: interesting
11:07:53 <acowley> bollu: Check this out https://github.com/commercialhaskell/intero/blob/master/elisp/intero.el#L1148
11:08:01 * hackagebot rss2irc 1.1 - watches an RSS/Atom feed and writes it to an IRC channel  https://hackage.haskell.org/package/rss2irc-1.1 (SimonMichael)
11:08:27 <slack1256> Hi, why does `fft :: (Vector v a, a ~ Complex Double) => v a -> v a` type-checks (with TypeFamilies) but `fft :: (Vector v (Complex Double)) => v (Complex Double) -> v (Complex Double)` doesn't?
11:08:28 <acowley> bollu: There's some elisp-ism there, but you can see it's building a relatively simple string to send to the intero process
11:08:51 <slack1256> in the first case requiring FlexibleContexts?
11:09:15 <icosane> lpaste.net is online again
11:09:18 <bollu> acowley: ty
11:09:51 <geekosaur> slack1256, what's the error you get with the second?
11:10:22 <geekosaur> "with TypeFamilies" makes me think there is additional information not present here, because nothing there stands out as a type family
11:10:31 <allenj12> heres the lpaste http://lpaste.net/321971 , so the only line I dont get now is the function f
11:11:10 <slack1256> geekosaur: I enabled TypeFamilies to use (~). The error in the second is "Non type-variable argument" which is correct, yet I remember being able to do this
11:11:47 <geekosaur> FlexibleInstances I think? it's a Haskell '98 restriction
11:11:59 <slack1256> semantically, both seems to denote the same  expression
11:12:04 <geekosaur> yes
11:12:27 <geekosaur> H'98 only allows type variables, not actual type constructors.
11:12:35 * slack1256 reading FlexibleInstances
11:13:16 <geekosaur> this is one of the H98 restrictions that is pretty much harmless to disable
11:13:43 <geekosaur> and as such is so widely disabled that people forget it exists until they forget to disable it on creating a new project
11:14:29 <jmnoz> so I found this library Text.Blaze.Truncate, but found no examples or code using it. How can I test that it works?
11:15:24 <slack1256> Mmm seems what I need is FlexibleContexts instead of FlexibleInstances
11:15:54 <slack1256> But the same idea applies, It lets me but (Vector v (Complex Double)) in functions where Complex Double isn't a type variable
11:16:04 <slack1256> *lets me put
11:16:23 <geekosaur> possibly, yes
11:16:43 <slack1256> thank you geekosaur
11:17:22 <geekosaur> anyway this is one of the things that the haskell prime committee should be re-evaluating, since the H98 restriction didn't encourage other Haskell implementations and the restriction is now so widely ignored that there's no longer a point to it
11:17:38 <geekosaur> so hopefully the next standard will make it unnecessary
11:18:24 <slack1256> checking out some projects, they always enabled it in their cabal files. It really seems to be one of those "unofficial defaults"
11:18:59 <geekosaur> exactly
11:19:07 <slack1256> btw, which is the tiniest LANGUAGE pragma that enables (~) synxtax for type equality?
11:19:27 <geekosaur> jmnoz, I think you need to contact the author of that library. and encourage them to provide more information
11:20:20 <kuribas> allenj12: you are trying to solve that silly reddit problem?
11:20:48 <allenj12> kuribas: im the one who actulaly posted the problem lol.
11:21:21 <kuribas> I see...
11:21:55 <kuribas> allenj12: wasn't there a solution already?
11:22:16 <allenj12> kuribas: yea, im just trying to understand the State monad version for fun
11:23:48 <kuribas> ok, I see
11:24:00 <Lokathor> my program crashes :(
11:25:25 <MarcelineVQ> have you tried turning it off and on again?
11:25:36 <Lokathor> ah, well, you might say that's the problem :P
11:26:51 <chnli> I want to learn functional programming, but I am confused between Scheme, Racket and Haskell.
11:27:01 <Lokathor> Haskell is the most functional
11:27:29 <Lokathor> Scheme and Racket don't really concern themselves with being functional, they are just used in a functional style some of the type
11:27:31 <Lokathor> time*
11:27:54 * geekosaur finds a couple of bugs in the ghc manual... one of which is the failure to document what extensions enable type equality
11:27:55 <kuribas> MarcelineVQ: lol
11:28:02 <chnli> But haskell has a steep learning curve, as I have heard
11:28:12 <geekosaur> (the other is a reference to ghc 7.8 as if it were the current version...)
11:28:27 <Tuplanolla> It does, but it's not insurmountable, chnli.
11:28:27 <kuribas> Lokathor: scheme is pretty functional, but not purely.
11:28:52 <chnli> also which is used more in the industry, which could also help me get a job
11:29:18 <kuribas> chnli: haskell
11:29:25 <nitrix> chnli: It's not steep. It's barely even a curve. The only difference is that, yes, you'll truly need to learn new concepts, as opposed to other languages where only the syntax might differ.
11:29:56 <kuribas> chnli: you can learn both, they share many concepts.
11:30:36 <chnli> kuribas: by both you mean Haskell and Scheme/Racket?
11:30:55 <kuribas> chnli: scheme.  AFAIK racket is just scheme in another syntactic jacket.
11:31:17 <chnli> yes indeed.
11:31:29 <dolio> Racket is PLT Scheme wanting to do their own thing regardless of what the Scheme standard says.
11:31:37 <dolio> More or less.
11:31:53 <kuribas> I think LISP is used much more than scheme.
11:32:11 <kuribas> but haskell has more momentum
11:32:16 <chnli> which is best place to start learning haskell, LYAH or something else
11:32:41 <MarcelineVQ> @where learnhaskell
11:32:42 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:33:10 <kadoban> chnli: Something else, IMO.
11:33:20 <kadoban> I like http://haskellbook.com/
11:34:09 <kuribas> They should update "realworld haskell", I really liked that book.
11:34:39 <MarcelineVQ> the comments on it help a lot
11:34:43 <glguy> The new edition of "Programming in Haskell" is out now
11:36:02 <jackhill> Hi, In a GHC type erro like "• Couldn't match type ‘MarshalMode b0 ICanReturnTo ()’ with ‘Yes’
11:36:04 <jackhill> "
11:36:29 <bollu> I'm writing a plugin for sublime text that queries using intero and should hopefully show types
11:36:32 <bollu> this is fun :)
11:36:53 <jackhill> I assume that one of the types is what a function expects and the other is what GHC has inferred the value being passed to be.
11:37:04 <jackhill> If that's true, which is which?
11:37:17 <Tuplanolla> Isn't it followed by two lines telling you about it, jackhill?
11:37:40 <kuribas> > length 10
11:37:43 <lambdabot>  error:
11:37:43 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘length’
11:37:43 <lambdabot>        prevents the constraint ‘(Foldable t0)’ from being solved.
11:37:50 <kuribas> > length True
11:37:53 <lambdabot>  error:
11:37:53 <lambdabot>      • Couldn't match expected type ‘[a0]’ with actual type ‘Bool’
11:37:53 <lambdabot>      • In the first argument of ‘length’, namely ‘True’
11:37:56 <bollu> kuribas: wha are you aiming for? :)
11:38:10 <kuribas> bollu: error message :)
11:38:23 <bollu> kuribas: ahh :)
11:38:49 <jackhill> Tuplanolla: it is. I guess I didn't find that helpful enough. I can post the whole thing I was trying to do, but it looks like kuribas's simpler example is helpful
11:39:27 <lpaste> jackhill pasted “hsqml demo” at http://lpaste.net/322419
11:39:46 <jackhill> I was trying for follow along with the hsqml intro
11:39:58 <kuribas> jackhill: expected type is the type the function "expects", actual type is the type that you passed.
11:40:15 <kuribas> Actually that sounds pretty logical...
11:41:41 <lpaste> Tuplanolla pasted “Expected and Actual” at http://lpaste.net/322433
11:42:10 <Tuplanolla> That's what it usually looks like and I think there's a ticket for changing the wording a little too.
11:43:55 <kuribas> Tuplanolla: like "couldn't match given type 'Bool' with type infered from context '[a0]'"?
11:44:38 <Tuplanolla> The proposal was to change them to something like "inferred" versus "found".
11:45:01 <kuribas> Tuplanolla: IMO that's more clear
11:45:34 <Lokathor> MarcelineVQ, well it went from crashing instantly after a resize to crashing upon the next key press
11:46:49 <jackhill> kuribas, Tuplanolla: thanks!
11:48:16 <bengt__> does the IO monad immediately execute the io operation (and wrap the result) or defer it and just guarantee the order of operations? still trying to wrap my head around how they're implemented
11:48:47 <bengt__> haven't been able to find that anywhere everyone just talks about weird analogies :p
11:49:01 <ongy> usually the advice for that is "don't"
11:49:05 <Cale> bengt__: Apart from a limited number of magical operations, the actions you list in a do-block, when the do-block is being executed, are being carried out immediately.
11:49:26 <Tuplanolla> ...and then there's `unsafeInterleaveIO`, bengt__.
11:49:47 <geekosaur> usually it's best not to think about the actual implementation, which often cheats in various ways
11:49:48 <geekosaur> but
11:49:52 <Cale> bengt__: There's readFile and getContents and hGetContents which are somewhat magical exceptions to this that give you String values that, when evaluated, actually carry out the IO
11:49:53 <geekosaur> @where IO Inside
11:49:53 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
11:49:53 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
11:50:14 <geekosaur> hm, no. think someone spiked the reference
11:50:27 <bengt__> I was reading SPJs awkward squad paper
11:50:31 <geekosaur> come to think of it, I am now recalling it was out of date
11:50:38 <Lokathor> when my program crashes it doesn't show any error output, is Control.Exception.bracket_ suppressing that?
11:50:42 <bengt__> ok guys, thanks
11:50:54 <Cale> bengt__: The way in which stuff is deferred is that execution of IO actions isn't the same thing as evaluation.
11:51:10 <Cale> bengt__: *Evaluating* an IO action doesn't do much apart from making your CPU a bit warmer
11:51:14 <glguy> bracket_ doesn't eat exceptions
11:51:29 <Lokathor> :/
11:51:33 <Cale> (it just puts it internally into some standard form where the steps it describes are a bit more ready to be carried out)
11:51:49 <geekosaur> you looked at the impl several hours ago, no? it reraises it
11:52:04 <geekosaur> so if an exception is being eaten, it's happening elsewhere
11:52:10 <glguy> Lokathor: If your main thread is returning successfully then the other threads will stop running.
11:52:10 <Cale> Executing the action is where all the real stuff happens, and evaluation doesn't in general cause execution to occur.
11:52:19 <Lokathor> geekosaur, you might be thinking about someone else, i didn't examine the implementation earlier
11:52:33 <Cale> (apart from those lazy I/O bits like getContents which are weird)
11:53:03 <Lokathor> glguy, the main thread is doing curses, and then i'm trying to get it to handle a signal for the window being resized
11:53:19 <Lokathor> before it crashed instantly, now it refreshes and then crashes as soon as you read the next key
11:53:20 <nitrix> What would happen if we could represent strictness/lazyness at the type level?
11:54:11 <nitrix> Is this even do-able?
11:55:12 <nitrix> foo :: !Int -> ... or someting.
11:55:32 <bollu> if there's a haskell file, is it possible to run each expression and get a value?
11:55:33 <geekosaur> Lokathor, run it under gdb. high probability that it is crashing inside the ncurses library and calling exit() or abort()
11:55:39 <bollu> like, for expressions with concrete types?
11:55:55 <bollu> basically, if there's a .hs file, and if there are top-level values
11:56:00 <bollu> I want the computed value
11:56:06 <bollu> so if I write x = 10 * 20
11:56:13 <bollu> I want an API call that returns 200 :: Num a 
11:56:16 <geekosaur> bollu, I think we call that ghci
11:56:16 <bollu> or something of the sort
11:56:22 <dolio> nitrix: There's been some discussion about expanding the strictly evaluated portion of things in GHC.
11:56:24 <bollu> geekosaur: I want an API :)
11:56:30 <bollu> geekosaur: I'm integrating this into sublime text
11:56:42 <bollu> geekosaur: so (hopefully), you can do quick list stuff and math stuff inside sublime text
11:56:57 <bollu> geekosaur: also (hopefully), allow support for Diagrams
11:57:01 <geekosaur> take a look at hint, then?
11:57:05 <dolio> I think it's even split up a bit now.
11:57:06 <bollu> what's hint?
11:57:13 <geekosaur> @hackage hint
11:57:13 <lambdabot> http://hackage.haskell.org/package/hint
11:57:21 <bollu> geekosaur: oh, thank you!
11:57:22 <nitrix> dolio: I'm guessing the complicated part is how verbose things would become?
11:57:39 <bollu> geekosaur: oh fuck, I need Haskell <—> Python interop
11:57:45 <bollu> geekosaur: any idea how to do this?
11:57:55 <Lokathor> geekosaur, i must leave for work, but for whatever reason it did NOT crash when run through gdb, it only crashes when run on its own
11:58:10 <bollu> geekosaur: …does spinning up a local server on the Haskell side sound halfway reasonable?
11:58:12 <nitrix> dolio: I find the idea of knowing the evaluation strategy of a function or a given value very interesting. Right now, it's a lot of "look at the implementation and you'll know".
11:58:13 <geekosaur> well, my point was that technically it was not a crash
11:58:21 <Cale> nitrix: I mean... would something of type Int -> ... not be able to evaluate its argument?
11:58:33 <Cale> nitrix: It's a little unclear what the ! means there.
11:58:33 <geekosaur> it was a controlled exit on the C side, so you can't trap it from Haskell
11:58:44 <dolio> So there's, like, `Type LiftedPtr` which has things that are lazily evaluated by default (this is *), `Type UnliftedPtr` which has similarly represented things that are strictly evaluated (and cannot be bottom; this is part of what was #).
11:58:47 <bengt__> Cale: thanks I think I got a clearer picture now
11:58:51 <Lokathor> geekosaur, it did not perform an unexpected controlled exit either
11:58:57 <geekosaur> odd
11:59:34 <dolio> nitrix: And my favorite version of the proposal would be to make `!t` be `Type UnliftedPtr` if `t` is `Type LiftedPtr`.
11:59:47 <dolio> Which makes the `!t` in data definitions more first-class.
11:59:54 <nitrix> Cale: I agree. I haven't given much thought, I was just bringing the subject. Having functions type signatures telling you that, "from this point", this variable isn't an Int but an !Int, thus, all the call sites that are going to supply that function are therefore strict now.
12:00:04 <Lokathor> https://github.com/Lokathor/fullainth geekosaur feel free to examine it yourself and leave an issue or whatever if you figure it out :3
12:00:15 <nitrix> dolio: Yes. I like that very much.
12:00:28 <geekosaur> bollu, if you need this from Python then you probably need to use the hs_main stuff. or you can see if MissingPy has what you need
12:00:37 <dolio> Cale: Putting the ! in the type changes the calling convention of the function, so it would know that the Int it's receiving is already evaluated.
12:00:44 <geekosaur> (probably the python side binding, rather than the hackage one)
12:00:45 <bollu> geekosaur: okay, thanks
12:00:59 <bollu> geekosaur: I was thinking of just spinning up a web server in haskell and using HTTP to communicate
12:01:12 <bollu> geekosaur: will the overhead be very large? I don't think so, right?
12:01:26 <Cale> dolio: ah, that's a reasonable interpretation I suppose
12:01:29 <geekosaur> that probably depends on the webserver etc. :)
12:01:34 <EvanR> nitrix: what does it mean for a call site to be strict
12:01:34 <bollu> geekosaur: :)
12:01:38 <bollu> geekosaur: warp?
12:01:58 <geekosaur> no idea, sorry
12:02:10 <geekosaur> warp will probably depend onw hat exactly you do with it
12:02:19 <geekosaur> but, I have no direct experience
12:02:29 * geekosaur mostly tries to avoid web stuff...
12:02:37 <nitrix> dolio: Cale Do you think this would clarify the whole lazy/strict edged cases like getContents or will it just be another additional mental burden?
12:02:43 <Cale> nitrix: It does seem more like a value-level thing to me though
12:02:48 <bollu> geekosaur: haha, okay
12:02:55 <Cale> Oh, that doesn't help getContents be any less weird
12:03:11 <dolio> I don't think it helps that.
12:03:21 <Cale> getContents is weird because it produces a magical String which, when evaluated, causes effects to occur.
12:03:42 <Cale> (using unsafeInterleaveIO)
12:03:43 <dolio> Also making an entire data type strict recursively is quite different than changing the top calling convention.
12:04:09 <dolio> Unless list is polymorphic in its strictness, which is even more complicated.
12:04:13 <nitrix> Cale: To be fair, in a lazy language, that's the behavior I'd expect.
12:04:32 <icosane> bollu: Communicating from python to haskell over http is relatively cheap (at least, it should be responsive), although I won't send my hard disk image over it or watch movies through it. I would recommend using a unix pipe if that is available, else a plain socket on localhost or loopback.
12:04:43 <bollu> I always find it so amusing including servant. You turn on so many high powered extensions for it :D it tickles me
12:04:44 <Cale> nitrix: Even if evaluation is lazy, it's really weird
12:04:51 <bollu> icosane: nice, I hadn't considered pipes.
12:05:05 <dolio> It's not really that weird.
12:05:09 <bollu> icosane: I was also thinking of many using a lower-level thing like ZMQ if performance became an issue
12:05:18 <Cale> If all I/O worked that way, things would be pretty incomprehensible.
12:05:52 <nitrix> Are IO stricts?
12:06:13 <nitrix> Shouldn't be. I thought the only guarantee you had was the ordering.
12:06:14 <Cale> IO actions aren't evaluated for their effects, so evaluation order usually has no impact on what occurs
12:06:35 <Cale> (outside of stuff like hGetContents)
12:06:48 <Tuplanolla> Imagine a Haskell video player that stops rendering once you hide the window and tries to catch up when you reveal it again.
12:06:49 <EvanR_> nitrix: evaluation causing side effects? thats not what i would expect in a "pure" language. clojure is a good example of what goes wrong when you combing lazy and effects
12:06:51 <nitrix> So the problem with getContents is actually that it can get re-ordered.
12:06:55 <nitrix> (Interleaved)
12:07:03 <nitrix> Not that it's lazy, right?
12:07:18 <Cale> yeah -- when the effect happens depends on when the rest of the program evaluates its magical result
12:07:36 <icosane> bollu: Well, you were going to use haskell ‘binding’ for evaluating haskell expressions and adding a scripting language, if I guess correctly, so I would send serialized commands over a pipe or a socket as fallback. Serialization doesn't need to be fancy, a simple toBytestring and fromBytestring is enough, I think.
12:07:39 <dolio> Cale: hGetContents starts a thread that reads from a file and fills in IVars, which are read from the main thread (because reading from an IVar is pure) to construct a string.
12:07:49 <bollu> icosane: hm, that is faie
12:07:50 <geekosaur> whichis why one of the more common errors is hGetContents and then closing the handle
12:07:51 <bollu> fair*
12:07:52 <kuribas> Why can I not leave a field unnamed in a struct?
12:08:05 <dolio> And the scheduling happens so that everything works very nicely.
12:08:17 <geekosaur> since nobody triggered hGetContents to actually do anything, it produces an empty string later when it does get forced
12:08:24 <kuribas> data MyStruct = MyStruct {namedOne :: Int, namedTwo :: Bool, String}
12:08:25 <Cale> For some value of very nicely :)
12:08:59 <Cale> Don't get me wrong, lazy I/O is handy sometimes
12:09:15 <nitrix> It seems like it rarely ever is with files though.
12:09:19 <Cale> Especially for small programs with simple but potentially long inputs
12:09:31 <nitrix> Oh.
12:09:38 <Cale> Nah, it's useful for files too
12:09:40 <nitrix> Sorry, nvm. I'm in potatoes :)
12:09:56 <icosane> it is part of the syntax, I think. You can do MyStruct {namedOne = x, namedTwo = True, s = "a"}, or MyStruct {x, True, "a"}, it is just not part of the standard syntax
12:10:07 <Cale> But not if something might happen to the file when you're in the middle of reading it
12:10:47 <nitrix> I'd love if all that could be clarified with types or annotations in a really predictable way.
12:10:53 <nitrix> Rather than this mental burden everytime :/
12:11:05 <Cale> nitrix: Use pipes instead?
12:11:07 <icosane> There is no obstacle in implementing such thing though, although it is unlikely to be done because the parsers need to support some extra syntax and it is not really needed.
12:11:29 <nitrix> Cale: Is that what people do? I have a look eventually.
12:11:32 <nitrix> *I'll
12:11:33 <Cale> That's a different mental burden, but it's sane all the way through
12:11:47 <EvanR_> dolio: reading from an IVar is pure?
12:12:00 <dolio> Cale: I feel like if you explain it the way I did, with concurrency, the downsides and 'confusing' parts become obvious.
12:12:18 <dolio> Cale: Like, don't fork a thread to read a file and then close the handle in the main thread.
12:13:15 <geekosaur> dolio, fwiw I realized that also. might help also if you think of "thread" there in the same sense as ST, as opposed to forkIO
12:13:56 <nitrix> Linear types would disapprove :P
12:13:58 <geekosaur> (not that the forkIO view is wrong, but it helps rationalize the use of "thread" to people who do know what is going on)
12:14:04 <nitrix> Or Rust's borrow checker :P
12:14:27 <dolio> EvanR_: Yes. An IVar is a write once variable. So it can be something that makes sense to read from in pure code.
12:14:45 <dolio> As long as the read blocks until the value is written.
12:15:00 <nitrix> dolio: That's very cool.
12:15:11 <dolio> So that you don't read in one spot and get an exception, and then in another spot you get a real value, or something.
12:15:35 <Cale> dolio: Well, sure, it does help to know how these things actually happen, but you still have this value whose type is String, but whose evaluation is caught up in a fundamental way with I/O
12:15:37 <dolio> EvanR_: It's kind of like A par ~A in linear logic.
12:15:50 <Cale> and that is a bit of an extra burden of sorts
12:16:56 <Cale> It's possible to write programs using interact (or just getContents and putStr directly) where the strictness of pure functions has an impact on how your program responds interactively to user input.
12:17:23 <Cale> Without lazy I/O, that doesn't really happen.
12:18:39 <dolio> Sure it does.
12:19:51 <dolio> If I do 'ack n `seq` getNextInput' where `n` comes from the first input, there may be a noticeable difference.
12:19:57 <Cale> hah, fair enoug
12:19:58 <Cale> h
12:22:12 <dolio> Also I think the concurrency metaphor is a good model for what degree evaluation is 'caught up' in IO.
12:22:34 <EvanR_> dolio: i have thought of this before, its used in some libraries
12:22:48 <dolio> Like, no one thinks twice about concurrent threads having IO actions happen in various orders.
12:23:00 <dolio> And evaluation probably affects scheduling of the threads, even.
12:23:03 <EvanR_> however, shouldnt a pure computation be independent of its environment... it only depends on its inputs
12:23:55 <EvanR_> like, you set up an IVar, now you have it. then you fork a thread that writes to it based on the time of day
12:23:58 <EvanR_> then you read the IVar
12:24:05 <EvanR_> doesnt seem pure
12:24:28 <dolio> What lazy I/O is doing is picking a schedule that is 'optimal' in the sense that everything is scheduled just as you need the answer.
12:26:31 <EvanR_> this is sort of the same gripe i think conal mentioned in a blog post about a top level pure value called operatingSystem :: String
12:26:55 <dolio> EvanR_: What's the difference between being passed an IVar and being passed the time that the forked thread writes to the IVar?
12:26:56 <EvanR_> its value is fixed but depends on the computer you compiled the program on (or run it on?)
12:27:10 <kuribas> why is there fromInteger?
12:27:13 <eacameron> For Optparse Applicative. Can you build nested structures like `(ConnectInfo, (String, Int))` in your options parser?
12:27:24 <geekosaur> kuribas, because of Num literals
12:27:26 <kadoban> kuribas: For integer literals
12:27:32 <EvanR_> because you werent passed the time that the thread writes to the IVar
12:27:40 <dolio> So?
12:27:56 <kuribas> why not fromIntegral?
12:28:09 <EvanR_> so thats the difference, and the point of purely functional programming?
12:28:19 <ertes> kuribas: because you need a concrete type with concrete operations to make sense of conversion
12:28:19 <ongy> @src fromIntegral
12:28:20 <lambdabot> fromIntegral = fromInteger . toInteger
12:29:07 <EvanR_> the sense of pure used for the IVar is "its value cannot change, its fixed, perhaps to a value we dont know yet, and this can just be interpreted as being inefficient"
12:29:12 <dolio> No, it's not the point. It's the means to the point.
12:29:25 <EvanR_> that seems pretty different from "pure, no side effects or suffering from context dependence"
12:29:55 <kuribas> > fromInteger 289204 :: Word16
12:29:56 <lambdabot>  27060
12:30:01 <kuribas> > fromIntegral 289204 :: Word16
12:30:03 <lambdabot>  27060
12:30:06 <kuribas> same thing...
12:30:58 <EvanR_> so if this works out, i need to come to terms with how its not context dependent
12:31:15 <dolio> So, here's a similar example.
12:31:37 <dolio> Classical logic corresponds to a type system.
12:31:54 <dolio> It's like a concurrent programming language.
12:32:17 <dolio> But the problem with classical logic is that it is nondeterministic.
12:32:28 <dolio> Using intuitionistic logic doesn't have this problem.
12:32:44 <dolio> And it's the normal system we're used to.
12:33:07 <dolio> But, classical _linear_ logic (without the modalities at least) also doesn't have this problem.
12:33:09 <EvanR_> classical logic is non deterministic because LEM?
12:33:12 <kuribas> geekosaur, kadoban: what's an example where you can use fromInteger, but no fromIntegral?
12:33:53 <dolio> EvanR_: Yeah, the way you interpret LEM or things equivalent to it means you get answers that depend on the exact way you reduce things, I believe.
12:34:22 <dolio> So, linear logic has something that looks like LEM, A par ~A, where par is multiplicative disjunction.
12:34:51 <dolio> And it is a concurrent/parallel construct.
12:35:30 <ertes> kuribas: that's not the point…  fromInteger is used specifically to convert integer literals to the instance type
12:35:56 <dolio> You fork a thread that gets a spot to plug in an A, and you get an A to use, and when you need to use the A, the other thread must have plugged in the A already.
12:36:07 <ertes> kuribas: if you're defining an instance (Num Blubb), you are defining how to interpret (15 :: Blubb) in source code
12:36:09 <dolio> Because you get the thing it plugged in.
12:37:02 <dolio> Now, you could just run that sequentially, but you could also run things concurrently, as long as you don't get to the spot that needs the A.
12:37:37 <dolio> Or you could wait to only run the part that plugs in the A once you get to the part of the other thing that needs the A.
12:37:47 <dolio> Which is like what lazy I/O does.
12:38:20 <dolio> The linearity keeps this deterministic. Actually it's probably overkill.
12:38:20 <kuribas> ertes: hm, so fromInteger is used to define the typeclass.  Does ghc do magic to make conversion more efficient that a roundtrip via integer?
12:38:24 <geekosaur> kuribas, I think the point is (a) fromInteger is required by the standard (b) given the default impl of fromIntegral uses fromInteger, no extra cost
12:38:47 <dolio> Because it also ensures that you definitely use the A, so that the opposite computation will have to happen at some point.
12:39:00 <dolio> So no parallel effort will ever be wasted, either.
12:39:14 <geekosaur> and not requiring compilers to do the kind of heavy optimization ghc will do to turn a generated fromIntegral into direct fromInteger (or into id, then nothing, if appropriate)
12:39:39 <geekosaur> ghc has a bunch of RULES for fromIntegral, yes
12:39:56 <dolio> But IVars (with pure reads) are a similar device, without the latter guarantees.
12:39:57 <geekosaur> and probably some for fromInteger when it's a no-op
12:40:13 <kuribas> geekosaur: thanks, it makes sense now
12:40:35 <dolio> If your only use of the IVar is for reading, it's like you have an A, but the value is getting filled in while you're also doing something.
12:41:28 <dolio> And all you've done is made it so that the entire computation of the A you have doesn't have to happen before the spot where took it as an argument.
12:42:20 <EvanR_> what is confusing to me is that the A is being filled in, but by IO code
12:42:44 <EvanR_> its not like running two pure computations in parallel
12:44:12 <ertes> kuribas: the roundtrip is only semantical…  for the most part GHC will just optimise it away
12:44:13 <muzzle> hi
12:44:21 <muzzle> using ftphs I get this IOError: getProtocolByName: does not exist (no such protocol name: tcp)
12:44:31 <dolio> The A you have might be computed by IO code, which isn't in the lambda calculus, so it's not like pure computations.
12:44:37 <ertes> kuribas: but yes, semantically you always go through Integer, because that's the type of integer literals
12:44:37 <EvanR_> if you had done the IO first then passed in the value, it could have errored
12:44:44 <EvanR_> but because you didnt and waiting, then it may not error
12:44:54 <muzzle> dies anyone know what could cause this
12:44:55 <EvanR_> based on the ordering you chose
12:45:27 <ertes> kuribas: in the (Num Word8) instance you could still write literals like (-1) or 256, and fromInteger specifies how to read them
12:45:48 <kuribas> > fromInteger (-1) :: Word8
12:45:51 <lambdabot>  255
12:45:57 <EvanR_> or based on a random variable
12:46:13 <kuribas> ertes: I think it simply truncates
12:46:22 <kuribas> (the bits)
12:46:24 <EvanR_> i guess its hard to formulate a complaint against this, so that intuitively gives evidence to support it
12:46:32 <ertes> kuribas: it does, but it has to be specified
12:46:50 <dolio> If you always fork a thread, the computation erroring won't cause your main thread to error.
12:47:03 <icosane> muzzle: I don't know ftphs, but this error probably means you used the wrong function, or used a wrong value
12:47:06 <dolio> Except that erroring is equivalent to waiting forever.
12:47:21 <EvanR_> you could have filled in the IVar from the main thread first, no fork
12:47:28 <EvanR_> but thats a different program
12:47:40 <icosane> muzzle: But getProtocolByName is of Network.BSD, not of ftphs (https://www.haskell.org/hoogle/?hoogle=getProtocolByName)
12:48:02 <ertes> kuribas: whenever you write a literal like 255, the compiler will create an actual Integer, let's call it 'lit255' with the value 255, and read that literal as "fromInteger lit255"
12:48:04 * hackagebot cayley-client 0.2.1.0 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.2.1.0 (MichelBoucey)
12:48:14 <icosane> muzzle: so it is could be a bug in ftphs
12:48:16 <eacameron> For Optparse Applicative. Can you build nested structures like `(ConnectInfo, (String, Int))` in your options parser? 
12:48:17 <muzzle> icosane: I can write some files via ftp
12:48:24 <muzzle> icosane but then i get this error
12:48:28 <EvanR_> maybe i need someone to tell me "dont worry, the value it will have has been predetermined at the beginning of the universe and nothing could have stopped it or changed its value"
12:48:35 <EvanR_> "or stopped the fact that it errored"
12:48:51 <muzzle> icosane: even if i quit an FTP connection and reopen a new ftp connection
12:48:58 <EvanR_> but id rather a math explanation
12:49:25 <icosane> muzzle: would you paste your code on http://lpaste.net/? Then I can look at it and try to see what went wrong?
12:50:06 <EvanR_> "its the same in some sense as having done the computation with the same result in the main thread, wrapped the value or error in a thunk, and passing that into the function instead of the IVar"
12:50:32 <EvanR_> which seems wrong to me only because of the time-dependence, but i guess we never use those semantics with IO anyway
12:50:56 <dolio> Well, if you care about the time, then concurrency is probably wrong.
12:51:09 <dolio> That doesn't mean concurrency is always wrong.
12:51:15 <EvanR_> time and concurrency is wrong?
12:51:36 <dolio> If 'X Before Y' matters, then running X and Y concurrently is a mistake.
12:52:07 <EvanR_> i was talking about what the clock says in the two scenarios when the IO code decides what the value is
12:52:19 <EvanR_> so X could happen before Y in both cases, if necessary
12:52:25 <EvanR_> or not
12:52:48 <EvanR_> when you rerun the program, the IVar will have different values, but thats not new...
12:53:05 * hackagebot direct-sqlite 2.3.18 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  https://hackage.haskell.org/package/direct-sqlite-2.3.18 (JanneHellsten)
12:53:10 <dolio> EvanR_: Here is another analogy.
12:53:26 <dolio> We have throwing and catching exceptions in IO.
12:53:32 <dolio> We also have throwing exceptions in pure code.
12:53:35 <icosane> muzzle: do you have posted your code? I will shut down my computer in the near future.
12:53:38 <dolio> And you can catch those in IO.
12:53:56 <dolio> So in some sense, throwing exceptions is more pure than catching them, if you allow them to be divided up.
12:55:35 <dolio> And the IVar argument is that reading from a variable that may only be written to once is more pure than writing to it (in part because there's no enforcement that only one write happens, so they may have to blow up).
12:56:10 <muzzle> icosane sorry, i have to leave, someone's come into my office, will you be here tomorrow?
12:57:04 <icosane> muzzle: probably. I'm frequently hanging around in the morning and the evening (local time zone does not differ much from UTC)
12:57:39 <hal_> Heya, when I try to run a criterion benchmark that I have defined for a project with `stack bench`, it compiles, but it doesn't show me any output. Is there anything obvious I could be doing wrong?
12:58:26 <EvanR_> now that we cleared that up, i feel like the concern is theological
12:59:00 <EvanR_> is reading from IVar pure, how many angels can dance on a pinhead
12:59:18 <EvanR_> i need to absolve myself by getting my notes out and reviewing the math/engineering reason why we care about purity
12:59:23 <ongy> @hoogle IVar
12:59:25 <lambdabot> Language.Haskell.Exts.Syntax IVar :: l -> (Name l) -> ImportSpec l
12:59:25 <lambdabot> Control.Monad.Par data IVar a
12:59:25 <lambdabot> Control.Monad.Par.IO data IVar a
12:59:34 <dolio> Right. That's the real question: why do you care?
13:00:09 <EvanR_> "spooky action at a distance"
13:00:37 <EvanR_> and we overlook "really slow" as being also bad
13:00:43 <EvanR_> which is what this does
13:00:51 <dolio> The answer is something like: I don't want the exact order my pure code happens in to matter.
13:00:55 <EvanR_> if not also spooky action at a distance
13:01:29 <dolio> In the case of lazy I/O, in a sense it does matter, because the scheduling is affected by the exact order. But probably scheduling already is affected by that.
13:02:04 <dolio> In the IVar case it really "doesn't matter" as long as your machine is infinitely parallel or something.
13:02:13 <dolio> Something that isn't really true. :)
13:02:47 <dolio> But you also have to decide to what degree you care about your pure code's execution order mattering.
13:03:05 <dolio> Because it always matters for some thing.
13:03:06 <EvanR_> another one, if we hold a program, we want the answer to be the same each time we run it
13:04:23 <kuribas> isn't mapAccumL just mapM in the state monad?
13:04:34 <dolio> Yes.
13:04:44 <dolio> And mapAccumR is mapM in a backwards state monad.
13:04:59 <kuribas> what's a backwards state monad?
13:05:08 <dolio> Threads the state backwards.
13:05:25 <kuribas> right
13:06:45 <kuribas> is there a preference?
13:07:21 <dolio> (m >>= f) s2 = let (s0, a) = m s1 ; (s1, b) = f a s2 in (s0, b)
13:07:39 <EvanR_> just to be sure, would you say that a "DatabaseIVar" which is pointing to a particular time and place in a temporal database somewhere on the internet, if that time hasnt passed yet (in the database) it blocks, is reading from this pure?
13:11:28 <dolio> EvanR_: If the database were really an immutable resource that grows in time, I don't really see anything wrong with just making it available in pure code, except that 'on the internet' probably has stuff you have to deal with.
13:11:45 <EvanR_> right
13:12:10 <dolio> Like, I don't want 'f (db x) (db x)' to pass one real thing and one 'couldn't connect' exception.
13:13:21 <EvanR_> does it make sense for (db x) to complete is 1s, and the second (db x) to complete in 10s, or just freeze forever?
13:14:15 <dolio> Freeze forever is a problem.
13:14:34 <dolio> I mean, in some sense we don't really even have that property.
13:14:53 <whittle> So, I foolishly upgraded to macOS 10.12, and am getting hit with https://ghc.haskell.org/trac/ghc/ticket/12479
13:14:54 <EvanR_> its possible the database in question has been destroyed
13:15:06 <dolio> Exact evaluation time isn't something I care about.
13:15:13 <whittle> Is there a workaround prior to the release of GHC 8.0.2? 
13:15:31 <dolio> EvanR_: Then it's not truly an immutably growing resource.
13:15:47 <EvanR_> its possible the undersea cables have been severed
13:16:10 <dolio> Effectively the same.
13:16:20 <EvanR_> ok
13:16:29 <EvanR_> not immutable by our perspective
13:16:34 <dolio> Right.
13:17:32 <EvanR_> but it would manifest as freezing forever, if we didnt want to return an exception
13:17:54 <EvanR_> and you kind of cant tell the difference if we dont care about time
13:18:39 <dolio> People usually consider freezing forever the same as throwing an exception for the sort of semantics we're talking about here.
13:19:00 <EvanR_> so the DatabaseIVar thing is just broken
13:19:04 <dolio> That's why you can optimize 'let x = x in x' into an exception.
13:20:39 <dolio> EvanR_: If creating the IVar from the details of indexing into the database were in IO, it would be the same workaround of these issues as a lot of other stuff.
13:21:05 <dolio> Like getting the contents of a file as a string.
13:21:25 <dolio> If you do it more than once, it may have disappeared in the mean time.
13:21:29 <dolio> Etc.
13:22:21 <dolio> The internet database can just mutate in fewer ways.
13:23:31 <EvanR_> do what more than once
13:23:58 <dolio> Get the contents of a file as a string.
13:24:10 <EvanR_> so run hGetContents more than once
13:24:27 <dolio> No, readFile.
13:24:36 <EvanR_> not look at the returned strings more than once, or look at different parts of the string
13:24:48 <dolio> I mean, hGetContents also is different if you do it twice, because the second one will bomb.
13:25:09 <whittle> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.2 says there should be a release candidate for 8.0.2. by mid-October. Does anyone know if there’s an update on that status? 
13:26:18 <EvanR_> do lazy I/O might actually make more sense if you had some degree of control of this hypothetical thread producing the data
13:26:27 <dolio> But yes, the point is 'readFile :: String -> IO String' not 'readFile :: String -> String'. So 'db :: ??? -> IO DatabaseIVar' or something.
13:28:01 <EvanR_> yes... if you manually construct the DatabaseIVar with a uuid and some query data, then it might evaluate to different things
13:28:06 * hackagebot brick 0.13 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.13 (JonathanDaugherty)
13:28:44 <EvanR_> but the IO is a scapegoat, now you can explain why the "same" reference now appears as an error when it didnt before
13:28:59 <EvanR_> because its not the same
13:29:44 <dolio> The point is that you have some thing where 'doing this twice might give different results' but the result it gives once you do it doesn't change.
13:30:38 <EvanR_> lazy I/O now seems less spooky with this thread thing, but we still cant control how that thread works... 
13:30:47 <dolio> Initializing with the same data might give different IVars, but one IVar will give the same answer no matter how many times you read it.
13:30:58 <EvanR_> sees an error, just disappears silently
13:31:26 <dolio> Well, not putting the error into the value is a choice that hGetContents makes.
13:31:40 <dolio> Maybe the wrong choice.
13:33:08 <EvanR_> can you explain multiplicative disjunction, i see the inference rule here, or whatever its called, but
13:33:09 <dolio> I think someone proposed changing it, but people didn't like it.
13:33:32 <EvanR_> its upside down &
13:33:37 <dolio> Yeah.
13:34:12 <dolio> So, it's easier to explain the other connectives.
13:34:16 <EvanR_> whats the diff between |- G, A, B and |- G,A and |- G,B
13:34:23 <EvanR_> whats the diff between |- G, A, B and (|- G,A and |- G,B)
13:35:38 <nitrix> ⅋ (par)
13:36:29 <dolio> So, in sequent calculus, multiple things on the right separated by commas are already disjoined.
13:36:37 <dolio> And par is just internalizing that as a connective.
13:36:44 <dolio> But that doesn't tell you much.
13:37:08 <dolio> Like, in classical logic sequent calculus, you have multiple things on the right as well.
13:37:28 <dolio> And the rule for \/ is the same as par, I think.
13:37:50 <dolio> The other tricky part with what you're looking at is that there's duality in linear logic.
13:38:08 <dolio> Which is why they _only_ use the right hand side of the turnstile.
13:38:32 <dolio> But that also means that one of the other rules is secretly a rule about multiplicative disjunction.
13:39:08 <dolio> Because in classical logic there would be two rules, a left and a right rule.
13:39:47 <EvanR_> |- G,A  ------------- |- G, A or B
13:40:07 <dolio> That one's the right rule.
13:40:20 <dolio> |- G, A, B --- |- G, A or B
13:40:33 <heebo> hello whats faster to index a list or sequence?
13:40:49 <heebo> I've heard sequence but my tests say its untrue
13:40:56 <dolio> I think you can deduce: |- G, A --- |- G, A, B
13:40:59 <dolio> In classical logic.
13:41:29 <EvanR> heebo: in your test, remember to fully construct the sequence before doing the test
13:41:47 <EvanR> instead of runnning it on a fromList [.....] each time
13:42:18 <EvanR> dolio: so whats |- G, A, B, A AND B are in the context?
13:42:20 <eacameron> does anyone use a string quasiquoter that produces IsString a so I don't have to convert it after the fact?
13:42:30 <dolio> EvanR: So, things on the right of the turnstile are like a bunch of parallel processes.
13:42:39 <eacameron> for just normal text , like a big paragraph of prose
13:43:22 <dolio> And moving everything to the right is like, instead of having processes with a _premise_ A, you have another parallel process doing dual-A.
13:43:26 <EvanR> eacameron: heres one... https://hackage.haskell.org/package/heredoc-0.2.0.0/docs/Text-Heredoc.html
13:43:56 <EvanR> dual -A ?
13:44:33 <dolio> Yeah, every connective has a dual, which should be somewhere on that page.
13:44:43 <eacameron> EvanR: Nice. I'd love for it to support interpolation too.
13:45:25 <dolio> And a dual variable could be thought of as a continuation that takes an A, I guess.
13:45:37 <dolio> A being the variable.
13:46:08 <bodisiw> will i be able to understand linear logic before i understand haskell? vice versa? :-)
13:46:31 <dolio> So, A |- A in intuitionistic logic becomes |- ~A, A in this style of linear logic.
13:46:36 <heebo> EvanR: https://gist.github.com/gregnwosu/432a0e493e5aa520270a354e60c9d70e is this right?
13:47:16 <EvanR> so a parallel process that expects an A
13:47:35 <EvanR> ~A is A -> False ?
13:48:02 <dolio> Yeah. Out of whole cloth, you can introduce an A and a hole to fill in with an A, that run in paralle.
13:48:15 <dolio> When you fill in the hole, it will pop out into the positive A.
13:48:42 <EvanR> oh, ~ is dual
13:48:46 <heebo> dolio: what subject are you discussing?
13:49:08 <dolio> Yeah.
13:49:37 <dolio> Linear logic.
13:49:44 <dolio> As a computational system.
13:50:19 <younder> Linear?
13:50:41 <heebo> dolio: do you have a link which introduces this, it sounds interesting
13:50:50 <dolio> EvanR: So, that's what gets you the excluded middle type thing, and then par just lets you wrap it into a connective so that you can do higher-order stuff with it.
13:50:58 <bodisiw> dolio and EvanR i have to say i'm enjoying your conversation, although i don't totally follow (but i don't follow this 'taste of linear logic' paper well either)
13:51:32 <EvanR> so... par, its the dual of ~A x ~B, whats x ?
13:51:45 <EvanR> and?
13:52:19 <dolio> That's multiplicative conjunction, which is like a pair where you have (and must use) both an A and a B.
13:52:41 <EvanR> i see
13:53:10 <dolio> So ~A x ~B is like an obligation to provide both an A and a B.
13:55:15 <dolio> Also the resources you use to provide the A must be separate from the ones for the B (otherwise you'd be using resources twice).
13:55:47 <EvanR> is there a copy
13:55:57 <EvanR> A -> (A,A)
13:56:05 <dolio> Whereas additive disjunction, A & B, the resources are shared, because having an A & B is like having a choice of whether you want an A or a B.
13:56:33 <dolio> So depending on the choice, the same resources will be used to construct the differing thing.
13:56:39 <EvanR> A or B but not both?
13:56:45 <dolio> EvanR: You can only copy !A.
13:57:06 <dolio> And only forget ?A.
13:58:14 <dolio> I mean, in a programming language maybe you could have A -> A x A for particular A, like if you divided the elements of a list into two lists.
13:59:04 <EvanR> er, i see |- G, ?A, ?A -------------- |- G, ?A
13:59:13 <EvanR> doesnt this imply you can freely copy
13:59:20 <dolio> EvanR: Yeah, another way to think about it is that A x B lets you do a pattern match (x, y), whereas A & B lets you do `fst p` or `snd p`, but not both (because you'd be using p twice).
14:01:11 <dolio> EvanR: That's kind of an artifact of the duality. Like 'copying' is like taking two premises and reducing them to one premise (that you use twice).
14:01:29 <dolio> And if you move those ?As to the left, they'd be !As that you'd be copying.
14:01:47 <EvanR> to the left of what
14:01:51 <dolio> The |-
14:02:05 <EvanR>  ihavent seen anything to the left of |- yet
14:02:22 <dolio> Right, because this presentation is putting everything on the right because of duality.
14:03:43 <EvanR> so what is ?A ?
14:03:53 <EvanR> the formal dual of !
14:04:09 <ertes> > [ x | x <- [0..9] | y <- [x..] ]
14:04:11 <lambdabot>  *Exception: not an integer: x
14:04:15 <dolio> Well, yes.
14:04:26 <ertes> > [ xx | xx <- [0..9] | yy <- [xx..] ]
14:04:28 <lambdabot>  error:
14:04:29 <lambdabot>      • Variable not in scope: xx
14:04:29 <lambdabot>      • Perhaps you meant one of these:
14:04:51 <ertes> in GHCi it says: <interactive>:40:27: error: • Variable not in scope: x • Perhaps you meant ‘x’ (line 40)
14:04:59 <ertes> that's a bug, isn't it?
14:06:59 <dolio> EvanR: So, earlier I said that in classical logic, if you had '|- G, A' you could go to '|- G, A, B' and then to '|- G, A \/ B', so the latter part is the one rule you'd need.
14:07:16 <dolio> Instead of two rules, one for A and one for B.
14:07:40 <dolio> But you can't do the first part in linear logic.
14:07:54 <dolio> Except, you _can_ do it for ?B instead of B.
14:08:42 <dolio> And there's a dual to contraction, too.
14:09:17 <EvanR> A -> A or ?B ?
14:09:45 <dolio> Where in classical logic, concluding A \/ A lets you conclude A, but you can't do that in linear logic.
14:10:08 <MarcelineVQ> ertes: same error here, it seems to be referring to the x fro the first 'draw' as well
14:10:46 <ertes> yeah, looks like a bug to me
14:10:50 <ertes> a funny one at least
14:11:19 <ertes> "i don't know london…  did you perhaps mean london?"
14:11:30 <MarcelineVQ> man ​I wish I knew about ParallelListComp earlier, I reallllly need to rtfm
14:11:56 <ertes> MarcelineVQ: well, you probably knew about zipWith, so nothing lost =)
14:12:01 <zzq> I was going through http://dlaing.org/cofun/ and realized I'm not clear on the benefits of a comonadic interpreter. So I wrote up an example with a comonadic interpreter http://lpaste.net/322001 and the same example with an interpreter that uses natural transformations http://lpaste.net/321999. Why would I want the comonadic version?
14:12:21 <dolio> EvanR: Also, if you think about the duality thing, `|- G, ~A, ~A` two parallel processes that have holes to fill, which correspond to two A values that will go somewhere else. So if you made that equivalent to one ~A, that would be duplicating.
14:12:53 <dolio> You've taken two A continuations and linked them together so that the value goes into two places.
14:13:31 <dolio> Which is like reducing two A premises to one A premise and using it twice.
14:14:32 <EvanR> so you can introduce an A and a ~A together, what does this mean computationally
14:15:10 <jophish> What's the mnemonic behind Biff and Tannen?
14:15:49 <dolio> Start two processes, one which has an A, and one which has a hole to fill with an A. And the A that the first one has is the one that gets filled in the second's hole.
14:16:36 <EvanR> and when that happens, they both go poof?
14:18:40 <dolio> I mean, you're probably going to do further deductions to make a more complicated program.
14:19:46 <dolio> `|- A, ~A` is like a different way to think about a function.
14:19:48 <EvanR> does that means elaborating on where A comes from or where ~A is going to send it
14:21:39 <dolio> So, like, `A |- A` is the identity function. `|- A, ~A` is like an identity channel between parallel processes.
14:21:40 <EvanR> A, ~A is a cps'd function?
14:21:44 <EvanR> oh
14:22:08 <dolio> A is the out end and ~A is the in end.
14:23:20 <dolio> And these channels are used to build functions.
14:23:31 <dolio> A -o B = ~A par B
14:27:47 <dolio> So if you start with `|- ~A, A` and then describe how to derive the A into a B, that's the same as the process of starting with `A |- A` and then describing how to get `A |- B`.
14:28:24 <MarcelineVQ> @tell heebo The test seemed accurate with sequence well ahead when I did it, are you perhaps mixng up ns and μs? https://en.wikipedia.org/wiki/International_System_of_Units#Prefixes
14:28:25 <lambdabot> Consider it noted.
14:29:34 <EvanR> so a rule like A .... ------- B
14:38:23 <Boarders> Hi I don't really know haskell and I am approaching it from a mathematical perspective
14:38:48 <Boarders> I was reading in a book that non-strictness or laziness means that functions don't need to be pointed where I take bottom to be the basepoint for any type 
14:39:24 <Boarders> and we don't have to have f(_|_) = _|_ e.g. you can have the function const_a x = a
14:40:23 <Boarders> the book said as an example that we have the non-strict function on tuples snd (x,y) = y 
14:40:42 <Boarders> non-strict because we can have something like snd (1/0, 3) = 3 
14:40:53 <Boarders> and that makes intuitive sense as a lazy computation 
14:41:05 <Boarders> but it doesn't make sense with a definition that says strictness is about pointed things 
14:41:06 <c_wraith> technically, snd is strict... 
14:41:33 <EvanR> > snd undefined
14:41:35 <lambdabot>  *Exception: Prelude.undefined
14:41:50 <Boarders> right, yeah the problem is you have _|_, (_|_, a), (a, _|_) and (_|_, _|_) 
14:41:56 <Boarders> what am I to make of that mathematically 
14:42:11 <ab9rf> the type contructor for (,) is lazy
14:42:14 <c_wraith> the non-strict function is the data constructor (,) 
14:42:20 <Boarders> is it even the case that (_|_,b) : (A,B)?
14:42:20 <ab9rf> sorry, data constructor
14:42:22 <ertes> Boarders: a function f is only strict, if f ⊥ = ⊥
14:42:41 <EvanR> :t (undefined, 'b')
14:42:42 <lambdabot> (t, Char)
14:43:36 <ertes> Boarders: take this for example:  sndM (x, y) = Just y  -- this function is strict
14:43:51 <ertes> Boarders: but this one isn't:  sndM2 ~(x, y) = Just y
14:44:21 <ertes> similarly this one isn't:  sndM3 xy = Just (snd xy)
14:44:33 <ab9rf> ertes: sndM2 simply fails to match if its argument isn't a tuple?
14:44:33 <c_wraith> Boarders, if you're looking for a mathematical treatment, https://en.m.wikibooks.org/wiki/Haskell/Denotational_semantics is a decent starting point.  
14:45:14 <Boarders> c_wraith: will this explain mathematically what it means for a type constructor to not be strict 
14:45:23 <ertes> ab9rf: sndM2 doesn't insist that the tuple is defined in order for its result to be defined at least up to the first constructor layer
14:45:33 <c_wraith> Boarders, it'll make an attempt. 
14:45:34 <ertes> ab9rf: sndM2 ⊥ = Just ⊥
14:45:43 <Boarders> the vague model I had in mind was some category of pointed types for Hask, but that is clearly not quite right
14:45:44 <ertes> ≠ ⊥
14:46:22 <ab9rf> ertes: huh, ok
14:46:31 <ab9rf> i'm not good with refutable patterns
14:47:30 <glguy> ab9rf: ~ patterns are the *irrefutable* ones
14:47:30 <Boarders> ertes: could you just remind me what ~ is (sorry I am not actually up to speed with basic haskell yet)
14:47:56 <ertes> Boarders: it's an irrefutable pattern, one that is matched lazily
14:48:05 <EvanR> ~ is "lazy pattern match"
14:48:36 <ertes> > case Just () of ~Nothing -> "good"
14:48:36 <ab9rf> glguy: i told you i wasn't good with them
14:48:38 <lambdabot>  "good"
14:48:42 <ertes> > case Just () of Nothing -> "boom"
14:48:44 <lambdabot>  "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
14:51:47 <Boarders> what about the stuff with product types 
14:52:12 <Boarders> e.g. in type theory or category theory we have the inference rule for product types as something like a:A, b:B |- axb: AxB 
14:52:21 <Boarders> but in Hask that is not true or?
14:52:53 <Boarders> I suppose that is will be explained when I try to read that wiki page
14:57:27 <EvanR> Boarders: bottom : A, also bottom : B, it inhabits every type
14:57:45 <EvanR> its quite promiscuous
14:58:06 <Boarders> yeah I was just wondering what that means for which things are in type AxB 
14:58:31 <Boarders> like (a,bottom), (bottom,b), (bottom bottom) and bottom :AxB 
14:58:35 <EvanR> yeah
14:59:08 <EvanR> a:A, b:B -> (a,b) : AxB
15:00:05 <EvanR> > ('a', undefined)
15:00:07 <lambdabot>  ('a',*Exception: Prelude.undefined
15:00:33 <EvanR> its not all-or-nothing in haskell
15:00:35 <ertes> Boarders: is the question whether (,) is an actual product in Hask?
15:00:49 <Boarders> I was wondering a bit about that, yeah 
15:01:08 <Boarders> e.g. the product in pointed sets is actually the smash product iirc 
15:01:17 <Boarders> whereas Hask is something pretty weird 
15:01:38 <EvanR> types in haskell are domains, so its harrier
15:01:51 <Boarders> analogous to adding a disjoint basepoint after taking an unpointed product
15:02:15 <EvanR> you can also ignore bottom and re-ask the question
15:02:30 <EvanR> pretend that cant happen
15:02:44 <Boarders> pretend what can't happen? 
15:02:49 <EvanR> bottom
15:03:12 <EvanR> like if Char is unicode characters, think of it as literally unicode characters not unicode characters plus bottom
15:03:43 <Boarders> well if the language is actually strict then it should just be the product type and that is the end of it 
15:03:44 <Boarders> no?
15:04:12 <EvanR> the language isnt really a category, you have to decide what to take with you into category land
15:05:04 <Boarders> yeah sorry I have a cognitive bias to mathematise which I think is the wrong intuition to approach as a beginner 
15:05:28 <Boarders> go with what ya know, ya know
15:06:55 <ertes> Boarders: just having a strict language doesn't eliminate bottom…  it just flattens the partial order induced by non-strict constructors
15:07:15 <ertes> it collapses into two layers: the fully defined values and ⊥
15:07:21 <EvanR> ah right, that too
15:07:57 <Boarders> oh yeah, ok 
15:08:03 <EvanR> (,) adds more layers to the domain, newtypes dont, but you cant still have bottom
15:08:10 <EvanR> you CAN...
15:08:42 <EvanR> but for some purposes you could get away with assuming there are no bottoms
15:09:05 <EvanR> like telling your boss what the program will do, assuming there are no bottoms (which people might be assuming anyway)
15:09:13 <Boarders> :)
15:09:20 <Boarders> thanks for the answers 
15:09:45 <Boarders> one more way more practical/ sordid question, if I wanted to train towards getting a job writing in a functional language for a bank/whatever what would be the best sort of preparation 
15:09:46 <EvanR> youre thinking of a total language
15:09:51 <EvanR> that actually wouldnt have bottoms
15:09:59 <Boarders> after I am more familiar with the basics, would it just be taking on a more serious project or what?
15:10:08 <tdammers> I think this day and age, real-world computer users are expecting bottoms left and right
15:10:36 <ongy> or bottomless pits
15:10:37 <EvanR> at least its not as bad as bottom = win98 is no longer responding
15:10:57 <tdammers> blue screen of bottom :D
15:11:33 <EvanR> a giant blue screen with the bottom symbol only... would be tight
15:11:46 <Boarders> https://twitter.com/GabrielG439/status/778012684784586752
15:18:58 <ongy> at least better than giant blue screen with :(
15:19:13 <ongy> should be reasonably easy to mod it in
15:33:21 <zyla> hi
15:33:55 <zyla> Why do family applications have to be saturated (fully applied)? What's the theoretical reason?
15:35:26 <ertes> zyla: in what context?  and are you talking about type synonym families?
15:35:46 <zyla> yes, i think
15:36:17 <ertes> type synonyms in general have to be fully applied in many contexts like instances
15:40:44 <geekosaur> zyla, no theoretical reason, but type lambdas make type inference difficult to impossible
15:41:14 <geekosaur> type lambdas are supported in GHC Core but not currently (unless there's some new TypeInType trick) exposed at the level of Haskell
15:41:22 <ertes> even type checking becomes undecidable i think
15:42:03 <geekosaur> ok, that'd be a theoretical reason
15:42:14 * geekosaur thought it was just practical...
15:42:30 <zyla> hmm, thanks
15:42:33 <geekosaur> since they do talk about ho they might expose type lambdas at the Haskell level
15:42:38 <geekosaur> *how they
15:42:38 <ertes> hardUnit :: (F ~ G) => ()
15:42:39 <zyla> Is there any paper that explains this?
15:43:01 <ertes> now the type checker needs to check whether F and G (now arbitrary functions) are equal
15:43:15 <zyla> Ok, I see
15:44:18 <zyla> But would it be practical to just assume they are not equal?
15:45:01 <ertes> it would be wrong to assume that
15:45:18 <ertes> (~) is an equivalence relation
15:45:47 <ertes> which means that F ~ F for all F
15:46:38 <ertes> (or rather a family of equivalence relations)
15:50:13 <zyla> Specifically, I would like things like http://lpaste.net/322988 to work
15:50:41 <zyla> the usual (I think - seen it in HList source code) trick is this: http://lpaste.net/323010
15:50:46 <zyla> but it's ugly
15:53:35 <zyla> geekosaur, ertes: Thanks for help!
15:55:05 <geekosaur> zyla, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#liberalised-type-synonyms ?
15:55:09 <jmnoz> could anyone look at https://github.com/mruegenberg/blaze-html-truncate/blob/master/Text/Blaze/Truncate.hs and tell me if this seems like a good, well written solution (95 lines)
15:55:22 <geekosaur> although the comment about kind checking may apply here :(
15:58:08 <zyla> geekosaur: unfortunately it doesn't apply to type families
15:58:33 <zyla> My example is quite bad, because I could do Id as just ordinary type synonym
15:58:52 <geekosaur> wonder if you could cheat and make a type synonym referencing the type family and that would defer checking,,,
16:01:39 <zyla> like this? http://lpaste.net/323048
16:03:15 <zyla> ah, "You can apply a type synonym to a partially applied type synonym"
16:03:28 <zyla> So I still can't apply a type family (`Map` in this case)
16:04:11 * geekosaur shakes fist weakly at ghc :/
16:05:15 <zyla> btw, I removed the check from GHC just to see what happens
16:05:30 <zyla> All test passed, except those testing this particular check
16:10:18 <zyla> I wonder how wrong would it be to implement this as an extension
16:10:35 <zyla> (MoreLiberalTypeSynonyms?)
16:11:02 <geekosaur> might ask in #ghc
16:13:46 <geekosaur> or perhaps on the glasgow-haskell-users list
16:13:52 <geekosaur> come t think of it
16:17:44 <muyfine> I'm trying to write a pass through conduit
16:17:54 <muyfine> and then a conduit that is "time-limited"
16:17:59 <muyfine> http://lpaste.net/323078
16:18:17 <muyfine> I'm taking the basic "nop", and then adding a time limit around it
16:18:37 <muyfine> not sure that that's the right thing to do - or if there's a better way to express that in conduit
16:21:12 <muyfine> (I know this code could get stuck waiting forever on empty input)
16:28:12 * hackagebot byline 0.2.3.0 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-0.2.3.0 (PeterJones)
17:39:41 <knx32542> I have a question about data files.
17:39:50 <knx32542> I have added Data-dir and Data-files to my .cabal,
17:40:20 <knx32542> and have added foo <- getDataFileName "test" t my .hs
17:40:48 <knx32542> but `stack build` returns, among much else,
17:41:08 <knx32542> 'gcc' failed in phase 'Linker' . (Exit code: 1)
17:41:11 <knx32542> any ideas?
17:41:31 <knx32542> I will answer any clarifying questions
17:42:16 <knx32542> I have tried removing references to the data files and stack build works fine, so the problem is in how I handle the data files.
17:43:05 <geekosaur> did you add Paths_<packagenamehere> to other-modules?
17:43:55 <knx32542> I added `import Paths_package-name`
17:44:05 <knx32542> I mean `Paths_package_name`
17:45:41 <geekosaur> not the literal string 'package_name', but the actual name of your package with any - changed to _
17:46:02 <geekosaur> (just making sure)
17:46:28 <knx32542> No problem, I have it as my actual package name with dashes instead of underscores
17:46:38 <knx32542> I mean vice-versa, underscores instead
17:46:44 <geekosaur> then I think we'd need to see the actual link error
17:46:57 <knx32542> I will do a pastebin
17:47:56 <knx32542> its quite cryptic,but here it is: http://pastebin.com/qZXUFAPs 
17:49:19 <knx32542> My uneducated guess is that I am missing a few binaries that Stack uses, but I am not sure where to go from there.
17:50:25 <knx32542> never mind that guess, ld returning 1 exit status means that ld is installed (i think), but I have an error somewhere.
17:50:56 <geekosaur> Paths_mental_math.getDataDir2 and Paths_mental_math.getDataDir3
17:51:01 <geekosaur> er
17:51:14 <geekosaur> _mental_math_gui
17:51:25 <geekosaur> but I don't think such names get defined
17:51:50 <knx32542> You may be on to something
17:52:10 <knx32542> By that do you mean I have to set DataDir2 in my .cabal? (pardon my lack of experience)
17:52:49 * geekosaur is looking at a generated Paths module. it has getDataDir but not getDataDir2 or getDataDir3
17:53:42 <geekosaur> apparently used in MultGui.hs
17:54:39 <c_wraith> I wonder if those only appear if there is a situation where the package is configured with multiple data directories.
17:54:41 <knx32542> I only have 1 data dir, at least to my knowledge set to `qml`, but I am not sure where to go from there.
17:54:47 <c_wraith> If so..  That's really hard to use in Haskell
17:55:01 <c_wraith> You can't just test for the existence of a function at runtime. :(
17:55:59 <knx32542> The lines of concern (I think) are 
17:55:59 <knx32542> Data-dir:            qml
17:55:59 <knx32542> Data-files:          *.qml
17:56:42 <geekosaur> well, the real question is why something in MultGui.hs is trying to use getDataDir2 and getDataDir3
17:56:43 <knx32542> c_wraith: As I am new to using data directories, I feel blindfolded either way :)
17:57:16 <knx32542> MultGui imports other module modules, but I thought that inconsequential
17:57:53 <knx32542> However, what you said means something because it references a module that references another module, so 2 extra modules and 2 extra datadirs
17:58:07 <geekosaur> no, modules do not have data dirs, packages do
17:58:17 <knx32542> Ah
17:58:42 <geekosaur> if a different package had a data dir, it would be Paths_thatpackage.getDataDir --- but the Paths_ module is in other-modules, so you would not be able t import it anyway
17:58:52 <geekosaur> only yours can be imported
17:59:17 <geekosaur> if some other package wanted to make its available, it would have to expose a module that called its internal getDataDir and returned the result
18:00:16 <knx32542> Oh. So if I understand correctly my own data dir conflicts with two other packages?
18:01:34 <geekosaur> ...np
18:01:35 <geekosaur> no
18:01:43 <knx32542> Oh
18:01:50 <geekosaur> your code is using two functions that *do not exist*
18:02:17 <geekosaur> (well, "your" --- I have no idea if this is actually yours or you are trying to build someone else's code)
18:02:23 <knx32542> I see
18:02:29 <geekosaur> not documented, no reason to believe they would exist
18:02:29 <knx32542> It is indeed mine.
18:03:20 <geekosaur> if you want to get a file from the (not "a" --- there is only one per library) data directory, use getDataFileName "filebasenamehere"
18:03:29 <geekosaur> if you want the directory itself, it's getDataDir
18:03:41 <geekosaur> I don't know where you got getDataDir2 or getDataDir3 from
18:04:42 <knx32542> I certainly am using getDataFileName for a file. However, I think I have a much better feel of what the problem may be.
18:05:19 <knx32542> You have more helpful than I would have been, so thank you.
18:06:14 <knx32542> I will call the discussion good for now and chew on this for a while onger.
18:08:06 <geekosaur> the only thing I have to go on is the linker error which tells me that getDataDir2 and getDataDir3 are being called from MultGui.hs
18:08:36 <geekosaur> using getDataFileName shouldn't put them there, since at most cross-module inlining would put getDataDir there
18:08:41 <geekosaur> unless something is going really weird
18:09:00 <Koterpillar> they passed through the compiler stage somehow
18:09:02 <geekosaur> but then I'd need to see the generated Paths_mental_math_gui.hs and MultGui.hs to know
18:09:41 <geekosaur> (and worst case also see the result of dumping their respective .hi files, but if we get *there* then we have either a Cabal or a ghc bug)
18:12:23 <geekosaur> actually now I wonder if something caused those to be generated, but not rebuilt (which would be either a Cabal or stack bug... but as far as I can see nothing would generate them)
18:33:50 <grantwu> Re: discussion from a couple days ago of usuals
18:34:11 <grantwu> Userspace PRNGs getting things wrong: http://www.pl-enthusiast.net/2016/11/01/prng-entropy-loss-and-noninterference/
18:36:06 <yulax> hardware rng is not expensive though...
18:36:27 <yulax> i use an stm32 nucleo board to run Neug.
18:37:29 <grantwu> Err
18:37:38 <grantwu> Well then you need a hardware rng
18:38:49 <yulax> what?
18:38:57 <yulax> i don't need one...
18:39:03 <c_wraith> Even using a hardware RNG doesn't mean you can ignore these issues.
18:39:08 <yulax> i just like collecting electronics
18:39:13 <yulax> oh definitely
18:39:34 <c_wraith> You should be passing its output through a whitening/stretching algorithm anyway, which..  hey, happens to describe a PRNG anyway.
18:39:50 <eacameron> Oh dear...what does one do when they want to use MonadMask's bracket function in a Servant handler...which is ExceptT Err IO
18:39:53 <c_wraith> A hardware RNG just lets you reseed more frequently with higher-quality seed material.
18:40:46 <grantwu> Actually, i believe the libgcrypt bug arose from trying to just that, c_wraith.
18:41:05 <c_wraith> grantwu: well, you still have to do it *correctly*. :)
18:41:48 * geekosaur waits for someone to throw that tech at split
18:42:01 <grantwu> Yes.  I think my argument is that implementing RNG for crypto should be treated as crypto, and therefore a similar amount of care needs to be taken
18:49:00 <eacameron> Does anyone have a good solution for using MonadMask's bracket in an ExceptT monad?
18:49:09 <eacameron> ExceptT Error IO that is
18:52:44 <knx32542> I am back about the data files stuff. Turns out the problem was me not putting the data reference in the Main.hs.
19:13:57 <RoboLettuce> Where does cabal install the "snap" binary? It's not in ~/.cabal
19:14:18 <Axman6> which OS?
19:14:22 <RoboLettuce> OS X
19:14:30 <RoboLettuce> or macOS I guess now
19:14:40 <Axman6> on OS X it's in ~/Library/Haskell/bin (or something similar)
19:15:15 <RoboLettuce> ~/Library/Haskell/bin/ has a bunch of stuff but no "snap"
19:15:42 <RoboLettuce> same with  /Library/Haskell/bin/
19:16:33 <Axman6> have you specified somewhere weird in your cabal config? also the cabal install command should have told you where it installed the binaries IIRC
19:17:04 <RoboLettuce> That would have been some time ago. I don't think I have anything weird in my cabal setup.
19:17:23 <monochrom> perhaps you erased it later
19:17:36 * geekosaur has seen it put the versioned binary in the package dir, and then fail to symlink that into ~/Library/Haskell/bin
19:17:38 <RoboLettuce> It is possible. Any way to make Cabal reinstall just the binary part?
19:18:06 <benzrf> nix is better than plain cabal install :3
19:18:40 <RoboLettuce> So are there like 3 different package managers now?
19:19:29 <monochrom> there are always more package managers
19:19:41 <monochrom> package managers are like standards
19:19:44 <Cale> We need a package manager manager
19:21:08 <monochrom> be careful what you wish for. it may become true multiple times. you may get a multitude of package manager managers.
19:21:43 <geekosaur> stack and cabal new-build both know how to drive nix
19:22:37 <geekosaur> ...but you probably already have multiple package managers anyway (since you probably have either homebrew or macports, because apple doesn't ship much or provides only old versions)
19:32:49 <benzrf> we need a package manager manager manager
19:32:53 <benzrf> wait , hold on 
19:33:07 <benzrf> we need an ω-package manager
19:33:18 <benzrf> now just nobody say ω+1 and it'll all be OK
19:34:28 <nitrix> Is modifyMVar atomic?
19:35:00 <nitrix> That is, can I have two threads modifying the same MVar?
19:35:20 <glguy> yeah, that's the point of mvars
19:35:24 <Cale> No
19:35:32 <Cale> (it's not atomic)
19:35:33 <geekosaur> "In particular, the "bigger" functions in this module (readMVar, swapMVar, withMVar, modifyMVar_ and modifyMVar) are simply the composition of a takeMVar followed by a putMVar with exception safety. These only have atomicity guarantees if all other threads perform a takeMVar before a putMVar as well; otherwise, they may block."
19:36:12 <nitrix> geekosaur: I can read, the confusion over the terminology is why I'm stuck and asking.
19:36:50 <nitrix> In the version I'm checking it says "This function is only atomic if there are no other producers for this MVar."
19:37:04 <Koterpillar> nitrix: producer == putMVar
19:37:23 <Cale> For example, one thread can try to putMVar a full MVar, and another thread can try using modifyMVar on the same, and the take will happen, and perhaps the putMVar from the first thread will complete, filling the MVar before the modifyMVar can.
19:37:30 <nitrix> Oh I see.
19:37:49 <geekosaur> I would say that if you are not certain, then use an MVar as a semaphore protecting some other thing
19:38:41 <nitrix> So you lose atomicity if you mix put and modify; but if I only have modifys, I'll be just as fine as IORef ?
19:39:03 <Cale> yeah
19:39:31 <nitrix> Now I'm really curious why they chose MVar and not IORef.
19:39:40 <Cale> Though if you only have straight modifyMVars, you should probably just use IORef
19:40:22 <Cale> One advantage of MVar is that you can take an MVar over a longer period of time and do a bunch of actions before putting it back.
19:40:23 <nitrix> Cale: https://github.com/jaspervdj/websockets/blob/master/example/server.lhs
19:40:32 <nitrix> Cale: It's on the websockets library server example.
19:41:31 <nitrix> Yeah, my understanding is you typically use MVar for putting/removing values which will make other regions of the program to block and wait for the value to come back to continue execution.
19:41:40 <Cale> Hehe, please don't ask me about Jasper's decisions :)
19:42:11 <nitrix> Okay cool. That cleared some confusion.
19:42:28 <nitrix> Cale: geekosaur glguy Appreciated.
19:42:31 <Cale> I spent several days fighting with the websockets library trying to get it to handle concurrent loads better. There are some subtle race conditions which I removed in some rather un-subtle ways in my fork.
19:42:47 <nitrix> That's worrysome ;-;
19:42:54 <nitrix> I'll pretend I didn't hear that.
19:43:43 <nitrix> One thing I noticed with the implementation is what happens if nagle's algorithm decides to merge two frames.
19:44:03 <eacamero_> Is there an alternative way nowadays to pull off the lifted-base, lifted-async stuff? It seems I've been reading things about moving away from monad-control.
19:45:14 <Cale> nitrix: In particular, this IORef here: https://github.com/jaspervdj/websockets/blob/master/src/Network/WebSockets/Stream.hs#L70
19:45:41 <Cale> nitrix: Every access to that IORef is behind a lock in the form of a withMVar, but there are two different locks.
19:46:17 <Cale> and so if you have a lot going on, you can end up inside the assertNotClosed for both send' and receive'
19:46:23 <Cale> at the same time
19:46:59 <nitrix> Cale: Was your fix merged upstream?
19:47:02 <Cale> Er, and the thing can get closed.
19:47:10 <Cale> No, because my fix was to remove this module completely
19:47:28 <Cale> and replace it with like 5 dependencies on pipes-* packages.
19:47:49 <Cale> https://github.com/obsidiansystems/websockets/tree/master/src/Network/WebSockets
19:48:10 <Cale> and I'm still not really happy with where I left it
19:48:32 <Cale> but it seems to be hanging in there in performance/load tests now
19:50:20 <nitrix> Since I'm not doing anything crazy, I'll give yours a shot.
19:50:24 <Cale> (But there are still some weird problems on the test client's side when the number of threads gets really high -- I'm not sure the websockets library has anything to blame for that though...)
19:50:35 <nitrix> (Sounds contradictory I know)
19:50:56 <Cale> There's also a snap module to go with it
19:51:04 <Cale> https://github.com/obsidiansystems/websockets-snap
19:51:17 <nitrix> Using wai
19:51:55 <nitrix> (warp)
19:51:56 <Cale> In that case, you'll have to do something similar to what I did in there.
19:52:14 <Cale> Since probably I killed the binding to websockets
19:52:31 <nitrix> Heh. Okay, we'll see how it goes. 
19:52:36 <Cale> I realised after I did this that I could have left the Stream abstraction in more.
19:52:51 <Cale> and just replaced it internally with some pipes shenanigans
19:53:02 <Cale> Might've turned out more compatible
19:53:42 <cath_> I'm trying to access a record field but running into hole-related error:  let ttl = (_tTitle pt) yeilds:  "Found hole: _tTitle :: PostedText -> Text Or perhaps ‘_tTitle’ is mis-spelled, or not in scope"
19:53:47 <Cale> Or rather, I could have replaced it with a record of how to parse/write
19:54:26 <cath_> Could anyone advise?
19:54:33 <Cale> cath_: Where's the data declaration?
19:54:35 <Koterpillar> cath_: more context, please
19:55:14 <Cale> cath_: If it's in a separate module, when you imported it, did you remember to add "(..)" after the name of the type to import the constructor and fields too?
19:56:14 <cath_> data PostedText = PostedText
19:56:14 <cath_>   { _time :: UTCTime
19:56:15 <cath_>   , _tTitle :: Text
19:56:16 <cath_>   , _body :: Text
19:56:18 <cath_>   } deriving (Eq, Show, Generic)
19:56:20 <cath_> I've imported /exported the constructors, the data dec is as follows: 
19:56:29 <cath_> well, I got that backwards.  sorry.
19:56:57 <Cale> Try _time and _body, are they in scope?
19:57:24 <cath_> ghc extensions are : FlexibleContexts, TypeOperators, TemplateHaskell, TypeFamilies and RankNtypes
19:57:55 <Cale> The error message really just means that they don't exist -- the fact that the names begin with underscores mean they double as named holes when not in scope, so the compiler has a different error message that lets you know the expected type when you use them.
19:58:50 <cath_> Ah, ok.  That part makes sense.  why the don't exist, I'm not sure . . . 
19:59:03 <cath_> _time and _body also don't exist
19:59:22 <cath_> maybe this is an intero bug and not actually source related
19:59:38 <Cale> Oh, definitely try the real compiler
19:59:51 <kirillow> When writing a point free function like `f = read . show`, why does one have to specify a parameter in the typeclass? Isn't this returning a (composed) function which in turn takes an argument?
20:00:31 <Cale> @let foo = read . show
20:00:34 <lambdabot>  Defined.
20:00:41 <Cale> :t foo
20:00:42 <lambdabot> (Show a, Read c) => a -> c
20:00:56 <geekosaur> kirillow, you don't. I wonder if you are actually asking about the monomorphism restriction though
20:01:15 <cath_> shi . . . ghc doesn't complain.  thanks.  that was only an hour of life . . . 
20:02:13 <Cale> I don't really bother with the fancy editor things, but ghcid is quite nice
20:36:28 <eacamero_> http://stackoverflow.com/questions/40372087/what-is-the-best-way-to-manage-resources-in-an-monad-stack-like-exceptt-a-io
20:41:21 <Axman6> eacamero_: what sorts of resources are you dealing with? are they things which can be allocated outside of the execution of the server?
20:42:59 <eacamero_> Axman6: Well...maybe. Specifically I'm thinking of a Database connection. So yes I could create that before starting the server. But that would mean my server can't do concurrent db transactions. So I would use a pool. But in order to borrow/replace to a pool, you need backet still.
20:43:03 <eacamero_> *bracket
20:43:43 <Axman6> basically all database libraries support a "single" connection allowing concurrent database access
20:43:58 <Axman6> you can often specify how many connections are allowed
20:45:11 <eacameron> Axman6: I don't even understand how that could work. If two threads open two different transactions on the same connection, how would they be differentiated?
20:45:51 <Koterpillar> eacameron: the DB would multiplex your packets for you
20:45:55 <Koterpillar> AFAIU
20:46:21 <eacameron> Koterpillar: But how would one thread's packets not get sent to the other thread? Neither thread is uniquely identified to the DB.
20:47:16 <eacameron> The DB just sees a bunch of requests on "Connection 10" but can't tell if they came from thread 1 or thread 2. 
20:47:34 <Koterpillar> each thread can append its ID to all packets
20:47:51 <Axman6> this is standard behaviour for network based database connection libraries...
20:47:54 <glguy> creating a transaction could allocate a new transaction id
20:48:05 <Axman6> it works, people rely on this working and use it daily
20:48:33 <eacameron> Axman6: So you're saying that Haskell's db libraries support this with only a single "Connection"?
20:48:51 <eacameron> At least...most of them? I'm using Postgres.
20:49:51 <eacameron> The MySQL bindings had this *all* messed up for like the last 5 years.
20:50:01 <eacameron> Just a few weeks ago did the patch finally get merged.
20:50:27 <Axman6> Persistent definitely supports a connection pool. postgresql-simple doesn't appear to, but it shouldn't be too hard to use one of the existing pool libraries to make it happen
20:50:42 <eacameron> Axman6: The main one uses monad-control
20:51:01 <eacameron> Which is sort of why I'm asking that question. Is that just, "the" route to go?
20:51:09 <Axman6> hasql (which is supposed to also be super fast) has a connection pool package too
20:52:29 <Axman6> see http://hackage.haskell.org/package/hasql-pool-0.4.1/docs/Hasql-Pool.html for example
20:52:40 <kinghussien_> can somebody explain why haskell exists?
20:52:48 <Axman6> (hasql is a bit weird, but both fast and quite nice to use once you understand it)
20:52:59 <Axman6> kinghussien_: because some people said it should
20:53:09 <Koterpillar> kinghussien_: because some people made it
20:53:14 <Axman6> why do you exist?
20:53:32 <kinghussien_> those people are clearly mentally deficient
20:54:02 <kinghussien_> there is no reason for haskell to exist
20:54:09 <Koterpillar> some people with mental disabilities make excellent programmers
20:54:16 <Axman6> you're not very good at this trolling business
20:54:30 <kinghussien_> im not trolling
20:54:35 <Koterpillar> kinghussien_: do you have an assignment you're frustrated with, or something like that?
20:54:36 <kirillow> give them a chance
20:54:42 <Axman6> at the very least you could give some reasons why you think what you do
20:55:11 <kinghussien_> if C didnt exist, I could see a reason for haskell but thats not the case
20:55:43 <Axman6> what does C have to do with anything?
20:55:49 <Koterpillar> kinghussien_: what makes C a replacement for Haskell?
20:55:52 <kinghussien_> this is why academia should be banned from the internet
20:56:06 <Axman6> if silicone didn't exist, we wouldn't be having this conversation, what's your point?
20:56:31 <Axman6> Well, I get paid to write Haskell every day, and I'm definitely not an academic
20:56:44 <kinghussien_> C is not a replacement. C is the only language with purpose. Haskell was a shitty idea born from shitty academics that couldnt write C
20:57:06 <Koterpillar> kinghussien_: you might be delighted to know that some of, for example, Facebook's spam filtering (close to banning, right?) is implemented in Haskell
20:57:08 <Axman6> I think you'll find all the people who defined Haskell could write C very well
20:57:27 <Axman6> GHC's runtime system relies on their ability to write very high quality C in fact
20:57:53 <Axman6> why would anyone chose C anyway? it provides essentially no mechanism for abstraction
20:58:04 <joe9> I want to step through haskell code. using traceShow is getting frustrating. Is that possible?
20:58:30 <Axman6> joe9: GHCi does have an interractive debugger, but basically no one uses it
20:58:52 <joe9> Axman6: ok Thanks. This ? https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/ghci-debugger.html
20:58:59 <kinghussien_> Use gdb
20:59:04 <kinghussien_> oh wait nvmind
20:59:14 <Axman6> yep (though you might want a more up to date version of the docs)
20:59:44 <Axman6> GDB can in theory be used for Haskell, but it tends to get confused, even when using DWARF
21:00:17 <Koterpillar> kinghussien_: by the way, have you been following the latest C standard revisions, where they add lambdas and such?
21:00:36 <Axman6> joe9: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/ghci.html#the-ghci-debugger for the GHC 8 docs
21:00:56 <Axman6> kinghussien_: pfft, Apple added lambdas years ago :P
21:01:01 <Axman6> uh, Koterpillar 
21:01:53 <Koterpillar> ...so maybe Apple should be banned from the Internet too?
21:02:08 <kinghussien_> OO programming is a worthless paradigm. No need for abstraction if you know how to program without
21:02:28 <kinghussien_> Yes apple has partly destroyed the greatness of the internet
21:02:34 <Axman6> kinghussien_: many in here would agree OO isn't particularly useful. Good thing Haskell isn't an OO language
21:02:41 <Koterpillar> kinghussien_: please note that I didn't say C++
21:02:55 <Koterpillar> also, "no need for seatbelts if you know how not to crash into things"
21:03:25 <kinghussien_> I agree. Seatbelts causes shitty driving
21:03:41 <joe9> http://codepad.org/QGlBnFFc the State is from the library. Is this possible?
21:03:46 <phanimahesh> abstractions are useful. Essential, even. But not all abstractions are made equal.
21:04:06 <Axman6> kinghussien_: so, you still haven't come up with any reasons why Haskell shouldn't exist
21:04:31 <Axman6> plenty for why C shouldn't, because we can do everything we do in C easily in assembly, so no need for the "abstractions" it provides either
21:05:22 <kinghussien_> I agree. Hopefully all languages get banned and people are required to write asm
21:05:38 <Koterpillar> kinghussien_: Haskell makes a much better educational language than C, too: "And here's printf, which is named like that for no good reason, and you must add \n which is magic but don't worry about it"
21:06:08 <phanimahesh> asm is a wortless abstraction. writing machine codes directly in binary should be fun. :P
21:06:30 <kinghussien_> You don't have to add \n dipshit...and who gives a shit what its named...go back to stackoverflow 
21:06:54 <Malkrith> printf means "formatted print"
21:07:22 <Axman6> but is written in that order because it's french
21:07:24 <systemfault> Programmable computers are worthless abstractions, ASIC all the things.
21:08:07 <Malkrith> It's written that way because fprint is a thing
21:08:09 <phanimahesh> Actually, I wish people took that ^ more seriously instead of trying to shoehorn general purpose devices everywhere
21:09:26 <Koterpillar> kinghussien_: I'm not sure that lexicon you use would have helped you if you tried to teach C
21:11:06 <kinghussien_> Why would I teach C!? If you cant figure it out, you shouldnt be anywhere near a computer
21:11:18 <Malkrith> destination-verb-adjective
21:11:29 <kirillow> this is good clean fun
21:11:30 <Malkrith> file print formatted
21:11:34 <Malkrith> fprintf
21:12:08 <Axman6> ok, this is getting tiresome. I don't mind if you want to actually give some sensible reasons why you have your opinion, but you've devolved into acting like a 12 year old
21:12:11 <Axman6> @where ops
21:12:12 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
21:12:55 <dibblego> wot?
21:13:16 <Malkrith> Either way everything has its place so arguing about which is better is going to go nowhere 
21:13:19 <dibblego> Aviation Security Identification Card all the things? Woss going on?
21:13:41 <Clint> i certainly don't know
21:14:01 <Malkrith> Application-specific integrated circuit 
21:17:55 <kirillow> why is this `f = (read::String->Int) . show` still telling me i should use a type annotation to specify what `Read a0` is?
21:18:55 <jle`> kirillow: where are you using this?
21:19:28 <kirillow> `print (f 4)` in `main`
21:19:55 <kirillow> ........
21:20:33 <pavonia> I think it's more like it doesn't know what the input type for show is
21:20:59 <Koterpillar> also, paste the full error message
21:21:11 <Koterpillar> it won't be show if it's asking for Read a0
21:21:42 <geekosaur> that expands to putStrLn . show . read . show
21:22:10 <geekosaur> which is probably a bit more barely restrained polymorphism than it's prepared to solve even with defaulting
21:22:23 <geekosaur> hm
21:22:50 <deeplearner> hello
21:25:05 <Lokathor> so why would running a haskell program by itself let a crash happen, but running it through gdb doesn't cause a crash in the same circumstances
21:25:18 <Lokathor> i am so very confused by that particular detail
21:25:28 <Clint> that happens with non-haskell programs too
21:25:57 <Lokathor> so when i'm using curses, if i resize the terminal, for a while it crashed instantly, and i have it at least now it crashes after the next keypress
21:26:21 <Lokathor> but if you run it through gdb, you can resize the terminal with no crash at all
21:26:32 <kadoban> Yay heisenbug
21:26:45 <geekosaur> gdb may not forward the SIGWINCH the same way
21:26:53 <Lokathor> quite possible
21:27:09 <Clint> or ptrace magic
21:27:29 <Lokathor> https://github.com/Lokathor/fullainth if anyone would care to clone and see if they can reproduce the bug, and/or simply boggle at it
21:27:35 <kirillow> http://pastebin.com/scktyLdp
21:27:53 <kirillow> this is it
21:28:34 <geekosaur> get rid of the annotation on read, first of all; it's just making things worse because it doesn't match your type signature
21:28:57 <geekosaur> yes, I saw you were having the problem without it, but right now the added errors from the mismatch are not helping diagnosis
21:29:21 <Koterpillar> and that will get rid of both errors
21:30:19 <Koterpillar> :t (read :: String -> Int) . show
21:30:20 <lambdabot> Show a => a -> Int
21:31:01 <kirillow> ???
21:31:10 <kirillow> Sorry I dont understand
21:31:21 <Koterpillar> kirillow: the type you put for f is wrong
21:31:31 <geekosaur> a type signature specifies what the caller can ask for
21:32:00 <geekosaur> the caller gets to pick any a, and any b, provided they have (respectively) Show and Read instances. then you try to force b to be Int
21:32:13 <geekosaur> which is the first error message
21:32:22 <deeplearner> friends... got any recommendation for learning haskell for newbies? i come from c# background
21:32:57 <Clint> Lokathor: valgrind also works around the problem
21:32:59 <kirillow> Im working through a book and the exercise is about leaving the type class as is and merely using paranthesis and `::` to fix this.
21:33:07 <deeplearner> learn you a haskell for great good <-- is this good? or got other better recomendations?
21:33:36 <geekosaur> deeplearner, it will teach you to read Haskell code. it has no exercises to speak of, so you won't really learn how to *write* Haskell code
21:33:44 <geekosaur> @where learnhaskell
21:33:44 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:33:46 <Axman6> deeplearner: #haskell-beginners is likely to have better recommendations. 
21:33:53 <geekosaur> ^ collection of learning resources
21:33:58 <Lokathor> Clint, i'm not familair with valgrind. Does that give a clue about how i should change the program to make it not crash? I tried installing a signal handler at the C level and it didn't help, and I then tried at the Haskell level and it helped about 1%
21:34:05 <Axman6> (learn haskell is the current most popular resource)
21:34:24 <deeplearner> thanks @geekosaur
21:34:59 <Lokathor> deeplearner, cis194 spring13 edition is the best free option. HaskellBook.com is the best version for 60$
21:35:00 <geekosaur> Lokathor, curses already installs a handler, you may actually be breaking it
21:35:05 <kirillow> im using "Haskell Programming from First Principles." Its the first book that actually ...works for me
21:35:42 <Lokathor> geekosaur, if i install no handler at all it also crashes. http://stackoverflow.com/q/13707137/455232 the answers on this question said that the curses handler is only sometimes a thing
21:35:46 <geekosaur> because if curses's handler doesn't get invoked because you handled the signal elsewhere, its allocations for stdscr and curscr will be incorrect and it will write out of bounds
21:36:36 <geekosaur> also calling refresh() from a signal handler is way scary
21:37:16 <Lokathor> should i perhaps have a handler that writes a flag, and then every action i check the flag before i actually do things?
21:37:52 <Lokathor> that seems... obtuse
21:37:55 <geekosaur> yes, actually
21:38:03 <geekosaur> signal handlers happen whenever
21:38:09 <geekosaur> let's say it happens while something has called malloc()
21:38:38 <geekosaur> what happens at the point you call refresh()? malloc() is not reentrant; the application crashes inside of the new malloc() call
21:38:48 <Lokathor> yeah. i also thought that using FFI in an async thread might be the problem
21:38:54 <geekosaur> (it's regenerating stdscr and curscr at that point)
21:40:28 <clever> Lokathor: last i looked, haskell's signal handling mechanics will just post a message to a queue and sig_return asap, then the haskell core handles it outside of the signal context
21:40:38 <geekosaur> this is not your problem, most likely; it's the kind of thing that works 90% of the time and the other 10% you can't figure out why it crashed in malloc with an invalid memory arena, or something similar with some other non-reentrant function
21:40:56 <geekosaur> which includes refresh() itself if it was already doing refresh() when the signal arrived
21:42:34 <Lokathor> clever, yes. the docs say that haskell's version of signal handling puts things into a queue and then runs the handler in an async thread at the first opportunity
21:42:44 <geekosaur> basically almost nothing is safe to use inside a signal handler, except setting a variable *that can be set atomically* (e.g. an int, but not a struct) and making a very limited set of syscalls
21:43:29 <Lokathor> could i write to an IORef Bool within a handler set at the haskell level?
21:43:38 <geekosaur> also, all versions of (n)curses handle SIGWINCH. delivering KEY_RESIZE is what is conditionally compiled
21:43:46 <Lokathor> oh
21:43:53 <geekosaur> haskell runtime deals with this for you
21:44:07 <Lokathor> well, if i don't set a handler, it crashes
21:44:28 <geekosaur> C signal handlers are much more restricted. the one in that stackoverflow will work most of the time and die a fiery death occasionally
21:44:51 <geekosaur> the correct thing to do in C is set a variable and check it in the mainline after the handler returns
21:45:09 <clever> a related problem ive run into, haskell implements its light weight threading and context switching by firing off SIGALARM at regular intervals
21:45:22 <clever> so a single OS thread can multitask between many haskell threads
21:45:39 <geekosaur> yep. +RTS -V0 will suppress this if you think it's the problem
21:45:48 <clever> that signal will cause many thing to fail with EINTR
21:46:07 <clever> and some stuff you FFI into, isnt expecting EINTR, and doesnt handle it correctly
21:46:24 <clever> which has led to PAM returning an error 99% of the time, because haskell sends alarm so often
21:46:31 <geekosaur> (may need to compile with -rtsopts)
21:46:52 <clever> i had to wrap all of the FFI code with something to temporarily disable those signals
21:46:57 <clever> and re-enable after the ffi returns
21:48:35 <geekosaur> actually that default handler might be the problem if something is then getting interrupted with SIGALRM...
21:48:46 <geekosaur> so yes, try it with +RTS -V0
21:48:59 <clever> there is an option to pause handlers, without adding a default
21:49:09 <clever> so it will just run the handler later, after the ffi is done
21:51:39 <cheater> hey
21:52:02 <cheater> i have a blender that's been standing in the kitchen connected to the outlet but unused for half a year and now it doesn't start up, any ideas what happened?
21:54:12 <Koterpillar> cheater: this is a channel about a programming language called Haskell
21:54:22 <cheater> duh, wrong window, sorry
21:54:37 <cheater> that was for ##electronics :)
22:06:57 <Lokathor> geekosaur, i tried the example program in just C (http://lpaste.net/323686) and it resized properly :/
22:29:30 <Lokathor> well
22:30:08 <Lokathor> the quick fix is to have the library just crash cleanly if they resize the window and write to disk a lot so that you can always restore the state when they restart the progrm
23:11:36 <metl> does anyone know if "attribute grammar" is closely related to "attribute-oriented programming" or if they are different concepts?
