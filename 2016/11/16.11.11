00:07:38 * hackagebot pgdl 10.3 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.3 (sifmelcara)
00:07:38 * hackagebot ginger 0.3.7.1 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.7.1 (TobiasDammers)
00:12:33 * hackagebot regex-do 2.3 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.3 (procione)
00:17:44 <piyush-kurur> grayhatter: no problem just make sure that you understand why it works.
00:18:22 <grayhatter> the constant shorthand syntax is confusing, but I understand why it works
00:37:34 * hackagebot classyplate 0.1.0.0 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.1.0.0 (lazac)
00:39:20 <liste> constant shorthand syntax?
00:45:39 <ania123> http://pastebin.com/5M91v92N
00:45:45 <ania123> can one see this hw-s
00:45:51 <ania123> how hard it is to give studnets?
00:49:20 <ania123> can one help me?
00:52:11 <liste> ania123: what do you want to know exactly?
00:53:34 <ania123> liste: whether exercises are stated correctly and clear way
00:57:43 <ongy> ania123: have you defined "the higher-order functions"?
00:58:26 <ongy> oh, I should read more carefully. But filter is just one function, so either you got he count wrong, or are missing something (I guess map)
01:01:02 <ania123>  liste: whether exercises are stated correctly and clear way
01:02:31 <younder> Seems that the eclipse plugins for Haskell are a bit dated. I am having trouble makeing them work. I am switching back to an emacs environment.
01:03:01 <merijn> younder: Pretty sure the (vast) majority of people here use either emacs or vim :)
01:05:09 <liste> ania123: I see
01:05:52 <ania123> thx
01:06:31 <liste> ania123: ongy already gave you feedback, I didn't see anything major apart that
01:06:54 <ania123> really?
01:07:00 <ania123> could you please paste it?
01:07:04 <ania123> i can not see it
01:07:14 <liste> 08:53 < ongy> ania123: have you defined "the higher-order functions"?
01:07:21 <liste> 08:54 < ongy> oh, I should read more carefully. But filter is just one function, so either you got he count wrong, or are missing something (I guess map)
01:07:51 <ania123> ah ok
01:07:52 <ania123> thx
01:48:22 <Aleksej> hi, I need some simple templating system that would generate static html from templates. I tried hakyll but I don't understand why it asks to install 123 packages for simple static web page
01:48:26 <lpaste> ongy pasted “Can I do this nicer (style)” at http://lpaste.net/335215
01:48:50 <ongy> any suggestions? I could use 'maybe', but I'm not sure if it looks that much better
01:52:54 <merijn> Aleksej: Hakyll is a library for writing "static html generating programs", it doesn't do that directly
01:53:09 <cordawyn> Aleksej: did you try HSML? (https://github.com/Palmik/HSML)
01:53:12 <merijn> Aleksej: Also, Haskell projects tend to have large numbers of dependencies to begin with
01:54:06 <merijn> I would say HSML (from having a quick look at it) is completely uncomparable to Hakyll
01:54:37 <cordawyn> depends on what Aleksej is trying to achieve :)
01:54:46 <merijn> Which is fine if HSML is the only thing you need :)
01:56:50 <merijn> I'm just saying it's unfair to compare two frameworks and go "Why does this one have a bajillion dependencies?!" if they're not remotely doing the same thing :)
01:57:48 <Aleksej> cordawyn: for example I have a template file with something like "<div>{include subtemplate.html}</div>" with some variables, I need package that would compile static html files from these templates
02:01:30 <lpaste> lyxia annotated “Can I do this nicer (style)” with “to ongy” at http://lpaste.net/335215#a335216
02:02:59 <merijn> fromLeft :((((
02:16:38 <ertes> Aleksej: there are packages that do *templating*, so they take templates and fill in the variables, like heist
02:17:04 <ertes> Aleksej: these don't generate static sites for you, you still have to write the results to files
02:18:46 <merijn> ertes: Hakyll also doesn't generate static sites :p
02:19:11 <merijn> Hakyll is more of a "static site generator"-generator
02:21:55 <ertes> yeah…  recently i started my blog again, and i wished that there is a simple static blog engine…  i ended up using pandoc and a Makefile =)
02:22:21 <maerwald> ertes: I hope you're using autotools to generate the Makefile
02:22:36 <merijn> ....
02:22:41 <merijn> God, please no
02:22:42 <maerwald> you could also wrap it with some python scripts
02:23:07 <ertes> maerwald: i actually used M4 in the past for static web generation =)
02:23:14 <merijn> ertes: You disgust me
02:23:17 <maerwald> o_O
02:23:21 <ertes> but it's a long time ago, and i still wish i won't go to hell for it
02:23:42 <merijn> ertes: My main obstacle to building a blog is that I'd have to design a webpage :p
02:23:53 <ertes> merijn: the answer is: don't
02:24:19 <ertes> merijn: someone recently gave me this link: http://motherfuckingwebsite.com/ =)
02:24:59 <merijn> Right now I'm designing file formats anyway, because I like pain :p
02:25:25 <maerwald> all haskellers do :D
02:27:01 <ertes> i'm happy when *haskellers* design file formats, because at the very least they have in mind that they need to write a parser for it…  the descent starts when VBA programmers "design" file formats
02:27:02 <ongy> my biggest obstacle is that I would want my blog content to be good. And I'd never be content with what I do
02:27:13 <merijn> I'm using ABNF to document it, but I have difficulty with how to encode conditional parts. I suppose I'll just have to describe how the conditional parts work in plain text intermixed with the ABNF
02:27:52 <merijn> ertes: Not just having to write a parser, but one that's future compatible. Rule 1: File formats and protocols must ALWAYS have a version field :p
02:28:15 <maerwald> ongy: the point of a blog is that you throw out stuff that's not perfect
02:28:34 <ertes> merijn: a parsec "specification" works, too, and has the semantics right there as well =)
02:28:58 <merijn> ertes: Binary file, parsec is not gonna happen
02:29:07 <ertes> merijn: an attoparsec "specification" works, too, and has the semantics right there as well =)
02:29:47 <merijn> ertes: Not very useful if you want people to be able to write parsers in other languages :)
02:30:45 <merijn> ertes: One of my examples are the ZMQ RFCs, I looked at them a lot while working on a ZeroMQ implementation and the fact that everything they implemented had (albeit it casual and hacky) RFCs was great
02:30:48 <ertes> merijn: one interesting feature of applicative/arrow parsers would be that we could generate ABNF automatically…  perhaps someone should write a library
02:32:25 <merijn> ertes: Just the ABNF without specification isn't useful (which is my original problem)
02:32:34 <merijn> Since ABNF is context-free, which most formats are not :)
02:34:22 <ertes> i think even that one can be generated to some extent…  you would have to stop yourself from using something like 'guard', and use parser-specific things instead
02:34:30 <ertes> this may be worth researching
02:34:55 <ertes> ('guard' doesn't work anyway, but there is an Arrow equivalent)
02:52:39 * hackagebot mustache 2.1.1 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-2.1.1 (justus)
02:57:39 * hackagebot mustache 2.1.2 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-2.1.2 (justus)
03:25:04 <ongy> :t 1e5
03:25:06 <lambdabot> Fractional t => t
03:26:03 <ongy> does GHC support a way to format number literals? I usually do something like '100 * 1000' because (at least to me) it's more readable than "100000". But that leads to problems in sections.
03:26:11 <Tuplanolla> Enable `NumDecimals`, ongy.
03:26:48 <ongy> ah, nice. thanks
03:27:21 <ertes> ongy: alternatively GHC computes something like 10^9 at compile time for me
03:27:42 <Tuplanolla> Why not enable `NegativeLiterals` and `BinaryLiterals` too while you're at it.
03:27:48 <ongy> > 10^9
03:27:51 <lambdabot>  1000000000
03:27:56 <ongy> :t 10^9
03:27:57 <lambdabot> Num a => a
03:28:10 <ertes> :t (^)
03:28:12 <lambdabot> (Num a, Integral b) => a -> b -> a
03:28:34 <Tuplanolla> Using `^` is annoying, because you get a defaulting warning for the exponent.
03:28:40 <merijn> > 10e6 :: Int
03:28:43 <lambdabot>  error:
03:28:43 <lambdabot>      • No instance for (Fractional Int) arising from the literal ‘10e6’
03:28:43 <lambdabot>      • In the expression: 10e6 :: Int
03:28:53 <ongy> the (^) gives me a "defaulting to integer" warning, so I'll go with NumDecimals
03:29:03 <merijn> ongy: There's an extension that allows scientific float notation for integers
03:29:13 <ertes> Tuplanolla: solution, use -W, because -Wall is really obnoxious =)
03:29:35 <ertes> ongy: solution, use -W, because -Wall is really obnoxious =)
03:30:17 <ongy> I'm so used to -Wall -Wextra from gcc... Maybe I'll build my own set of warnings at some point
03:30:20 <merijn> Use -Wall and explicitly disable annoying ones
03:30:48 <merijn> Tuplanolla: If you add a type annotation the defaulting goes away
03:31:06 <merijn> > 10 ^ (5 :: Int) -- this should never give a defaulting warning
03:31:09 <lambdabot>  100000
03:31:18 <ertes> better use Integer
03:31:23 <merijn> Sure
03:31:27 <merijn> Just an example
03:31:37 <Tuplanolla> Why bother with either when you can just enable an extension, merijn?
03:31:43 <ertes> the rule that makes this compute at compile time may rely on Integer
03:31:44 <ongy> why would you use Integer there?
03:31:57 <merijn> Tuplanolla: Sure, NumDecimals is better
03:32:19 <merijn> Speaking of extensions that should go into Haskell Prime, NumDecimals and BinaryLiterals
03:32:37 <ertes> and many more
03:32:59 <ertes> TupleSections, TypeOperators, ScopedTypeVariables, …
03:33:19 <merijn> TypeOperators I'm not 100% sold on, it's not as consistent as I'd like
03:33:21 <tabaqui1> :i over
03:33:25 <tabaqui1> :i over each
03:33:27 <tabaqui1> :t over
03:33:29 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
03:33:35 <ertes> merijn: which is unfortunate, because it used to be
03:33:42 <merijn> ertes: Don't forget FlexibleInstances/FlexibleContexts
03:34:00 <merijn> ertes: I'd rather have the consistent version in Report and keep TypeOperators for the current behaviour
03:35:13 <ertes> GADTs, KindSignatures, …
03:35:57 <Tuplanolla> `NegativeLiterals`, `InstanceSigs`, `KindSignatures`, `PostfixOperators`, `MonadComprehensions`, `ArgumentDo`, ...
03:36:01 <merijn> GADTs isn't happening
03:36:16 <ertes> and honestly the whole library of Derive* extensions, except the GHC-specific ones
03:36:31 <merijn> ertes: GADTs requires existential quantification and that's too controversial to get in
03:36:34 <ongy> are Generics standard or GHC?
03:36:46 <ertes> ongy: GHC
03:37:25 <merijn> quchen: I see you've been busy submitting RFCs for Haskell Prime. You should keep up the job of writing stuff I say out for me by proposing those ;)
03:37:36 <tabaqui1> :t both
03:37:38 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
03:39:14 <tabaqui1> :i both
03:39:41 <Tuplanolla> You can send private messages to our robotic maid, tabaqui1.
03:44:03 <ongy> NumDecimals is even smart enough to see what's Num, is there any reason not to use it?
03:44:56 <merijn> ongy: tbh, that's trivial :)
03:45:56 <merijn> In a.xey if length of 'x' <= 'y', then it's always an integer, otherwise a float
03:47:01 <ongy> after parsing and removing trailing 0
03:47:10 <merijn> oh, right
03:48:10 <ongy> also
03:48:27 <ongy> > 15600e-2
03:48:27 <lambdabot>  156.0
03:52:41 * hackagebot regex-do 2.4 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.4 (procione)
04:22:24 <kuribas> Is there a lens that returns the whole when the part matches?
04:22:38 <kuribas> mistery (_1._Left) (Left 1, "a") = Just (1, "a")
04:23:12 <kuribas> lens function better
04:29:19 <ertes> merijn: what's controversial about existentials in the GADT setting?
04:29:52 <ertes> merijn: i'd propose a variant of GADTs that doesn't come with ExistentialQuantification
04:30:56 <merijn> ertes: existentials *in general* are controversial
04:31:21 <ertes> merijn: but why?
04:32:16 <merijn> ertes: AFAICT the type theory folks aren't entirely settled on how they should behave, how they impact the type system and how this affects, e.g. type inference and soundness
04:32:46 <merijn> ertes: Since you can't have GADTs without also having existential quantification GADTs are also theoretically controversial
04:32:59 <Fairy> I want to filter a list of strings by checking the the type of the second word, and provided its the correct type, check it against a Bool function and return a Just list of all Strings that returned true for the Bool function, or Nothing if the type of the second word in any of the strings was incorrect. Is there a good way of accomplishing this?
04:33:54 <Maxdamantus> existential quantification → subtyping, pretty much
04:34:04 <merijn> Maxdamantus: Is it?
04:34:07 <endregalaczi> Hello Haskell people, I am confused by why this expression typechecks:    Nothing >>= id
04:34:16 <ertes> Fairy: by "type" i assume you mean something like "word category", i.e. not haskell type?
04:34:19 <Maxdamantus> merijn: aaui, yes.
04:34:36 <quchen> merijn: Huh?
04:34:36 <Maxdamantus> You have an actual function value that works on any given type.
04:34:43 <ertes> merijn: i'm pretty sure this was proposed before, but why not model them as a restricted form of sigma types from type theory?
04:34:49 <quchen> merijn: I wasn’t that busy doing that because I was busy doing other things lately, but yes :-)
04:35:00 <merijn> quchen: It was a joke about you writing out my complaints in your FAQ :p
04:35:05 <quchen> Ah, right.
04:35:09 <quchen> The FBUT.
04:35:09 <merijn> ertes: Out of my league
04:35:21 <quchen> FAQs are not meant to be read. Their purpose is served by just being somewhere.
04:35:58 <ertes> "Where is the FAQ?" – "Here."
04:36:07 <Fairy> ertes correct, it's a seperate function that checks, say if the second word is a number, for example
04:36:26 <merijn> :t filterBy -- does this exist?
04:36:28 <lambdabot> error:
04:36:28 <lambdabot>     • Variable not in scope: filterBy
04:36:28 <lambdabot>     • Perhaps you meant one of these:
04:36:38 <merijn> oh, actually, that's not really relevant
04:37:02 <merijn> Fairy: Write a function that does your check and then use filter?
04:37:03 <merijn> :t filter
04:37:05 <taktoa> endregalaczi: that is very strange. I'd also like to know why that typechecks
04:37:05 <lambdabot> (a -> Bool) -> [a] -> [a]
04:37:20 <merijn> taktoa: It makes a lot of sense, actually :)
04:37:23 <taktoa> I tried `Nothing >>= (id :: _)` but it just gives `a -> a`
04:37:30 <taktoa> oh
04:37:30 <merijn> taktoa: First question: What's the type of Nothing? :)
04:37:34 <taktoa> Maybe (Maybe a)
04:37:39 <merijn> taktoa: Ding ding :)
04:37:46 <endregalaczi> what doesn't make sense to me is that if I define my own id function then it behaves differently
04:37:52 <ertes> Fairy: the 'traverse' function may be handy
04:37:52 <merijn> taktoa: You have now discovered:
04:37:54 <merijn> :t join
04:37:56 <lambdabot> Monad m => m (m a) -> m a
04:38:14 <ertes> Fairy: traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
04:38:23 <endregalaczi> looking at the source it seems that if is just id :: a -> a  ; id x = x
04:38:31 <merijn> ertes: That fails if any entry fails, though
04:38:43 <endregalaczi> but if I implement that myself it breaks Nothing >>= myid
04:38:53 <merijn> Fairy: Try mapMaybe?
04:38:58 <ertes> merijn: i understood that it *should*
04:39:07 <merijn> ertes: oh? I didn't read to closely :)
04:39:16 <ertes> "or Nothing if the type of the second word in any of the strings was incorrect"
04:39:32 <merijn> endregalaczi: What's your implementation *exactly?*
04:39:54 <endregalaczi> myid2 :: a -> a
04:39:54 <endregalaczi> myid2 x = x
04:39:54 <endregalaczi> main = print $ (Nothing >>=- myid2 )
04:40:21 <endregalaczi> actually this may be wrong
04:40:26 <endregalaczi> apologies
04:40:44 <ertes> that reminds me of something…  pretty much all words for categorisation are already used and sometimes even overloaded in haskell =)
04:40:51 <ertes> "type", "class", "category", "group", …
04:42:04 <endregalaczi> ok I take it back, it does typecheck, it just complains about not knowing what the a is in Maybe a
04:42:11 <endregalaczi> so it cannot show that
04:42:51 <ertes> (not a complaint, just an observation)
04:43:55 <endregalaczi> so in the end Nothing >>= id does typecheck
04:43:59 * Maxdamantus is happy to complain about the overloading of "type".
04:44:05 <endregalaczi> and I don't see why
04:44:23 <merijn> endregalaczi: Right, so first question: What is the type of Nothing? :)
04:44:30 <endregalaczi> Maybe a
04:44:56 <merijn> endregalaczi: And 'a' can be anything, right?
04:45:03 <merijn> :t id
04:45:05 <lambdabot> a -> a
04:45:07 <endregalaczi> yes
04:45:08 <merijn> :t (>>=)
04:45:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:45:22 <merijn> endregalaczi: So, when is id a valid argument to >>= ? :)
04:45:39 <merijn> (For simplicity, let's use 'id :: x -> x')
04:46:23 <endregalaczi> if (a -> m b) is (a -> Maybe b)
04:46:50 <merijn> endregalaczi: No
04:47:10 <merijn> endregalaczi: Note that 'a' in type of '>>=' can be *anything*
04:47:15 <endregalaczi> so a is m b?
04:47:16 <merijn> endregalaczi: *including* 'm b'
04:47:16 <taktoa> endregalaczi: `(x -> x) ~ (a -> m b)`, so `x ~ a` and `x ~ m b` so `a ~ m b` so `(>>= id) :: m (m b) -> (m b -> m b) -> m b`
04:47:20 <merijn> endregalaczi: Right!
04:47:32 <taktoa> oops `(>>= id) :: m (m b) -> m b`
04:47:39 <endregalaczi> that is crazy
04:47:39 <nevere> How should I read a typeclass (MonadRead w m), as "the pair w m forms a MonadReader" or as "M is a MonadReader w"?
04:47:41 <endregalaczi> :)
04:47:52 <endregalaczi> ok thank you, that does clear it up
04:48:03 <merijn> endregalaczi: So, if 'a = m b', then 'm a' must be 'm (m b)' :)
04:48:15 <ertes> nevere: the former
04:48:34 <endregalaczi> merijn: thanks
04:48:47 <ertes> nevere: there is an instance (MonadReader w m), or in other words: "w and m are in a MonadReader relationship"
04:49:01 <Maxdamantus> :t join
04:49:03 <lambdabot> Monad m => m (m a) -> m a
04:49:07 <Maxdamantus> @src join
04:49:07 <lambdabot> join x = x >>= id
04:49:41 <Maxdamantus> oh, already mentioned.
04:50:00 <ertes> nevere: in some cases (namely when there is a functional dependency (m -> w), which is the case), you can also say:  "m is a MonadReader with w"
04:53:09 <nevere> ertes: Yes. Thankyou.
05:02:40 <mettekou> When using DataKinds and GADTs to define a Vector (n :: Nat) (a :: *) type for lists dependent on their length, how can I instruct GHC to reduce n + m so it unifies in the type signature for append :: Vector n a -> Vector m a -> Vector (n + m) a?
05:03:12 <merijn> mettekou: It's rather tricky to get GHC to do that
05:03:28 <merijn> mettekou: I usually end up using Peano arithmetic/numerals for that
05:03:43 <merijn> mettekou: It's work in progress to have a Nat arithmetic solver, afaik
05:03:58 <mettekou> merijn: So GHC's Haskell is nowhere near Coq yet when it comes to dependent typing?
05:04:11 <ania123> http://pastebin.com/zfYWA7Td
05:04:12 <merijn> mettekou: GHC doesn't have dependent typing at all yet
05:04:22 <merijn> mettekou: This is merely type level computation
05:04:27 <ania123> here is a definition of safediv
05:04:43 <merijn> mettekou: And even there it's tricky to get it to solve even rather simple things
05:04:49 <ania123> which return Nothing in the case of invalid arguments, rather than producing an error
05:05:07 <ania123> what is a pros having such types?
05:05:15 <mettekou> merijn: In my example Vector is a type depending on a value n of type Nat, not of kind * (analogous to Coq's Set/Prop/Type), right?
05:05:21 <merijn> ania123: Can't forget to deal with Nothing
05:05:25 <ania123> I can have a div function with buitlin type
05:05:31 <merijn> ania123: While it's easy to forget catching exceptions
05:05:31 <mettekou> Seems like a dependent type to me, don't know where it differs.
05:05:36 <ania123> which returns error
05:05:46 <merijn> mettekou: Having kinds other than * is not dependent
05:06:02 <ania123> forget? how?
05:06:02 <merijn> mettekou: Dependent would mean the type depends on some value. But Nat types are not values
05:06:12 <mettekou> Oh, I thought they were.
05:06:33 <ski> merijn : the type should be able to depend on a value that is the input to a function
05:06:35 <merijn> mettekou: No, types of kind Nat are hard-wired types
05:06:43 <ski> er
05:06:45 <ski> mettekou
05:07:07 <merijn> ania123: Well, suppose you write "f x y = x + (x / y)" <- forgot to check if y was zero!
05:07:38 <ania123> and?
05:08:12 <ania123> if i have type like that
05:08:12 <ski> (or `x / (x + y)', forgot to check `x /= -y')
05:08:17 <ania123> what happens in this case
05:08:23 <ski> type error
05:08:37 <ania123> in compile time?
05:08:52 <ski> yes, because you didn't tell how to handle the error case
05:09:00 <ania123> ok 
05:09:01 <ania123> thx
05:09:11 <jedai> ania123: with the "safe" version yes because you can't divide by a Maybe Double
05:11:05 <Maxdamantus> mettekou: it would be dependent if you could use an actual function argument in a type.
05:11:12 <Maxdamantus> eg, (n :: Nat) -> v -> Vector n v
05:11:35 <ski> (`replicate')
05:12:05 <Maxdamantus> notice that in `Vector (n :: Nat) (a :: *)`, `Vector` is only a type-level function.
05:12:59 <ski> (namely `Vector :: Nat -> * -> *', no dependency of the kind we're talking about in there)
05:13:16 <ania123> f x y = x 'div' x+y
05:13:21 <Maxdamantus> hehe, "kind".
05:13:46 <ania123> if I have this function and we want to compute f a -a
05:14:03 <ania123> it will returns what?
05:14:15 <mettekou> Maxdamantus ski: But can n be used in the codomains for that function? Because that would be exactly a dependent product, even though you can't use n in the function's body.
05:14:27 <mettekou> Well, if Nat :: * anyway.
05:14:35 <ski> > let f x y = x `div` x+y in "Ok : " ++ show (f 3 (-3))
05:14:37 <lambdabot>  "Ok : -2"
05:14:47 <ski> > let f x y = x `div` (x+y) in "Ok : " ++ show (f 3 (-3))
05:14:50 <lambdabot>  "Ok : *Exception: divide by zero
05:15:32 <ski> gio123 : it doesn't return a proper result, it raises/signals/throws an exception
05:15:41 <Maxdamantus> mettekou: what `n`?
05:15:52 <Maxdamantus> mettekou: the point is the `n` should come from an argument.
05:16:07 <ski> mettekou : no, it can't
05:17:00 <Maxdamantus> mettekou: if you just have something like `Vector n a -> Vector m a -> Vector (n + m) a`, `n` and `m` are not value-level arguments.
05:17:08 <ania123> ski, if we define it using /
05:17:13 <ania123> ski, if we define it using maybe
05:17:14 <ania123> ?
05:17:17 <ania123> what will hapens?
05:18:20 <ski> using `Maybe', or using `maybe' ?
05:18:27 <ania123> Maybe
05:19:13 <ski> ania123 : then you can't use `f 3 (-3)' as an `Int'
05:19:32 <ski> if you want to e.g. add something to it, you need to handle the `Nothing' (and the `Just') case
05:19:35 <ongy> can I tell stack not to download GHC into my $HOME but use the current directory?
05:20:04 <ania123> not clear :(
05:20:53 <mettekou> Maxdamantus: Yes, but with explicit binders that becomes: forall (n :: Nat) (m :: Nat) (a :: *). Vector n a -> Vector m a -> Vector (n + m) a, so my point was, if in that case Nat :: *, then this is a dependent product type, because you can use n and m in the codomain (Vector m a -> Vector (n + m) a). So if you say that it's not a dependent product, then Nat :: * does not hold, which is what you said earlier. Then it all
05:20:54 <mettekou>  makes sense.
05:21:50 <ski> mettekou : `forall (n :: Nat).' is not `(n :: Nat) ->'
05:22:07 <ski> mettekou : also, `Nat' here is a kind, not a type, yes
05:22:25 <ania123> ski: what is a type f f 3 (-3)
05:22:28 <ania123> ski: what is a type f 3 (-3)
05:22:29 <ania123> ?
05:22:42 <ski> depends on how you've defined `f'
05:22:59 <mettekou> ski: So what you're saying is that for some sort s, Nat :: s and * :: s?
05:23:02 <ania123> if we have defined f with Maybe type
05:23:25 <ski> @let safeDiv :: Int -> Int -> Maybe Int; safeDiv _ 0 = Nothing; safeDiv m n = Just (m `div` n)
05:23:28 <lambdabot>  Defined.
05:23:32 <Maxdamantus> mettekou: * and Nat are both kinds.
05:24:02 <Maxdamantus> That's why you can say `Vector (n :: Nat) (a :: *)`
05:24:02 <ania123> in this case
05:24:05 <jedai> ongy: you can change the stack root
05:24:05 <ski> @let foo :: Int -> Int -> Maybe Int; f x y = x `safeDiv` (x+y)
05:24:07 <lambdabot>  .L.hs:166:1: error:
05:24:07 <lambdabot>      The type signature for ‘foo’ lacks an accompanying binding
05:24:09 <ski> @let foo :: Int -> Int -> Maybe Int; foo x y = x `safeDiv` (x+y)
05:24:11 <lambdabot>  Defined.
05:24:14 <Maxdamantus> `Nat` and `*` are the same sort of thing; namely kinds.
05:24:19 <mettekou> Maxdamantus: Yeah, that's what my question to ski was, whether they both live in the same sort.
05:24:30 <ski> yes
05:24:36 <mettekou> I just didn't know what Haskell/GHC calls that s.
05:24:40 <jedai> ongy: but stack will still put ghc under a certain architecture and version dependent path under your new stack root
05:24:49 <mettekou> What is the kind of kinds in Haskell/GHC?
05:24:56 <ania123> what will happen if u write f 3 (-3)
05:24:58 <ski> gio123 : then `f 3 (-3)' has type `Maybe Int'
05:24:59 <ania123> ?
05:25:04 <ongy> I'm ok with that, I just don't want it in $HOME
05:25:09 <ski> @type f 3 (-3)
05:25:10 <lambdabot> FromExpr t => t
05:25:14 <ski> er, `foo'
05:25:16 <ski> @type foo 3 (-3)
05:25:18 <lambdabot> Maybe Int
05:25:21 * ski nods
05:25:47 <jedai> ongy: ok, then you must modify the STACKROOT variable (and make it permanent in your bashrc or equivalent in your OS)
05:26:01 <ania123> ski, if f: Int->int->int 
05:26:11 <ania123> f 3 (-3)  has type Int
05:26:11 <ski> that's another thing
05:26:19 <ania123> and now
05:26:22 <ania123> what we conclude?
05:26:29 <ski> you were talking about if you used `safeDiv', no ?
05:26:35 <ania123> right
05:26:36 <jedai> ongy: note that this doesn't only affect the ghc emplacement, everything stack does is done under STACKROOT (almost everything)
05:26:40 <ania123> I want to compleare
05:26:44 <ania123> safeDiv with div
05:26:49 <ania123> tp see cons and pros
05:27:03 <ania123> what is safeDiv better
05:27:43 <ongy> STACKROOT=/tmp/stack stack setup still created $HOME/.stack
05:28:13 <ongy> jedai: ^
05:28:21 <jedai> ania123: safeDiv is better if you're in a context where you don't manage your inputs and know you may have division by zero and you want to force handling of this case in place rather than have an exception
05:28:56 <ania123> I see
05:28:58 <ski> gio123 : better for what ?
05:29:22 <ania123> ski, I meant, why we have to use safeDiv, what we gain
05:29:30 <ania123> jedai answered I think it
05:31:02 <younder> ania123,  Does that measan exceptions in Hasmkell are expensive?
05:31:15 <younder> (time vise)
05:31:49 <jedai> ongy: STACK_ROOT
05:32:18 <ski> younder : i think it's more about seeing in the interface (the type) where an exception might be expected
05:32:36 <ongy> ah better, thx jedai 
05:32:51 * ski idly wonders whether there's an implementation of restartable conditions in Haskell
05:32:59 <ania123> safediv 0 = Nothing
05:33:06 <ania123> still it returns Nothing
05:33:15 <Maxdamantus> mettekou: also, to try to be clearer, if you have `Vector n a -> Vector m a -> Vector (n + m) a`, once you've decided on `n` (eg, 3), `m` (eg, 2) and `a` (eg, Int), there are lots of different values you can apply to the function.
05:33:17 <ania123> unsafe div returns errir
05:33:30 <Maxdamantus> [1, 2, 3]; [5, 6, 9]; [0, 0, 0; ..
05:33:31 <ania123> what is deferent between error and nothing?
05:33:37 <ski> gio123 : it doesn't at all
05:33:49 <ski> `Nothing' is a value
05:33:53 <younder> Ininiate is hardly nothing
05:33:58 <Maxdamantus> whatever value you pick, you always get back a `Vector 2 Int -> Vector 5 Int`
05:34:02 <younder> infinate
05:34:46 <Maxdamantus> if you have something like `(n :: Nat) -> a -> Vector n a`, you have a different type for every value.
05:34:47 <ski> @type Nothing  -- gio123 was talking about this, not "returning nothing" in a colloquial sense
05:34:49 <lambdabot> Maybe a
05:34:50 <jedai> younder: No, but you don't *have* to handle an exception. Using Maybe in the return type of a function that may fail not only signal that it may fail in the type, it also ensure that nobody can use this function without handling the error case
05:35:09 <ania123> ski: what is ERROR?
05:35:19 <ski> @type error
05:35:20 <lambdabot> [Char] -> a
05:35:27 <Maxdamantus> If you apply `5`, you get back an `Int -> Vector 5 Int`. If you apply `10`, you get bac an `Int -> Vector 10 Int`
05:35:36 <ski> ania123 : a function that doesn't return
05:36:08 <Maxdamantus> So the former example doesn't have any types dependent on arguments. The latter does.
05:36:42 <jedai> ania123: error is a Prelude function that throw an exception
05:36:57 <ania123> ok
05:37:00 <ski> jedai : .. of course you can "handle" it by using e.g. `do' in the `Maybe' monad
05:37:11 <ski> @free error :: String -> a
05:37:11 <lambdabot> f . error = error
05:37:34 <jedai> ski: sure, you may even handle it by throwing an error in the Nothing case !!
05:38:12 <ski> (fwiw, i also use the word "exception" to describe (some) uses of `Maybe' and `Either e')
05:38:15 * Maxdamantus sleeps.
05:38:20 <jedai> ski, younder: Of course Haskell has excellent ways to make handling a Maybe painless, so it's not as annoying as in some other languages
05:39:43 <ski> in e.g. SML/NJ, you could implement exceptions by monadic reflection on an `either' monad
05:40:18 <ShootLikeCurry> I've taken the leap and decided to learn Haskell after lots of reading. Should I be hacking away with a single file or learning to use stack?
05:40:20 <kuribas> > mapMaybe (_1 (previews _Left (+1))) [(Left 2, "a"), (Right 3, "b")]
05:40:21 <ski> (or any other monad that you can define. in that way you could add custom side-effects to the language. e.g. parsing effects, or angelic nondeterminism, &c.)
05:40:23 <lambdabot>  [(3,"a")]
05:41:12 <jedai> ShootLikeCurry: that's not an either/or
05:41:55 <jedai> ShootLikeCurry: you may want to use other packages in your single file, then you'll have to install them, at this point you may use stack to do so
05:42:19 <ShootLikeCurry> Ah, thanks for the advice. Makes sense
05:42:23 <jedai> ShootLikeCurry: see https://haskell-lang.org/tutorial/stack-play
05:44:11 <ShootLikeCurry> What are some general hints as to the popularity/maturity of a Haskell library?
05:45:03 <ShootLikeCurry> I've read a little about Parsec, Lens and Yesod and they seem pretty cool. Do I just count GitHub stars?
05:45:16 <ski> (e.g., you can make it so that `reify (fn () => let val c = reflect (enumFromTo 1 9); val b = reflect (enumFromTo 1 c); val a = reflect (enumFromTo 1 b) in if a*a + b*b = c*c then (a,b,c) else reflect [] end)' returns `[(3,4,5)]')
05:45:23 <ski> > [(a,b,c) | c <- [1 .. 9],b <- [1 .. c],a <- [1 .. b],a*a + b*b == c*c]
05:45:26 <lambdabot>  [(3,4,5)]
05:46:20 <jedai> ShootLikeCurry: That's a good first approximation
05:46:24 <jophish> ShootLikeCurry: That's quite hard to do in general
05:46:28 <ski> (here, we have the signatures :  val reflect : 'a list -> 'a; val reify : (unit -> 'a) -> 'a list  )
05:46:29 <jophish> This might be useful http://packdeps.haskellers.com/reverse
05:46:54 <jophish> but it's certainly not the only factor to consider!
05:46:58 <jedai> also you have "are they on stackage, do they have good documentation/tutorial, how old are they (but do they have a recent version)
05:47:22 <jophish> ShootLikeCurry: looking at the github repo is a good start too
05:47:46 <jophish> ShootLikeCurry: anything on this page is probably good!
05:47:47 <jophish>  http://www.haskellforall.com/2015/08/state-of-haskell-ecosystem-august-2015.html
05:48:58 <ShootLikeCurry> Thanks! These ideas are very helpful!
05:49:09 <jedai> ShootLikeCurry: current version : https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
05:55:05 <ShootLikeCurry> A question about stack/cabal - as I understand it, stack wraps cabal. Does that mean (as a beginner) I should avoid directly invoking cabal?
05:55:25 <ShootLikeCurry> For context - I'm looking to install ghc-mod
05:55:38 <delYsid> What are the advantages of LogicT over ListT?  I currently use ListT, but I wonder if LogicT would give me better performance?
05:55:56 <kuribas> Is there a hack to get the line number where a function is called?
05:56:09 <jedai> ShootLikeCurry: you should do that with stack
05:57:24 <jedai> ShootLikeCurry: stack wrap Cabal the library that read the .cabal file format which describe a package, but it doesn't wrap cabal-install the package that provides the cabal binary that was the standard way to install Haskell package until recently 
05:58:07 <jedai> cabal-install had several problems that stemmed of its model (and some GHC deficiencies) that stack alleviated
05:59:14 <jedai> recently cabal-install seems to be overcoming these problems but I would still wait some times before it is stabilized and I'll recommend it again for some uses (stack doesn't cover everything)
06:00:22 <hvr> I'd also point out that there's a few parts of the .cabal format that Stack doesn't yet implement
06:01:22 <jedai> hvr: sure but for a beginner I think stack is a better bet for good long while currently. Don't you think so ?
06:01:57 <kuribas> ah, CallStack is what I need...
06:02:00 <ShootLikeCurry> So am I supposed to add ghc-mod inside the .cabal file, under library build-depends?
06:02:10 <ShootLikeCurry> Then do stack build?
06:02:21 <dxtr> Sigh.. I'm having more strange issues now
06:02:27 <dxtr> internal error: multiple ACQUIRE_LOCK: rts/Task.c 225
06:02:34 <jedai> ShootLikeCurry: ghc-mod is a binary, you should just install it outside your project
06:02:36 <delYsid> I am a beginner, I tried cabal and stack, and found stack too involved.  I am totally happy with cabal!
06:03:01 <jedai> ShootLikeCurry: except if you're actually hacking on ghc-mod, but if you're a beginner, don't do that...
06:03:40 <jedai> ShootLikeCurry: so "stack install ghc-mod" outside your project directory
06:04:19 <ShootLikeCurry> Aha! Thanks... I was skimming through the stack docs but I must have missed that command
06:05:29 <jedai> ShootLikeCurry: note that stack put them in ~/local/bin so either you add that to your PATH or you move the binary afterwards
06:06:05 <ShootLikeCurry> Makes sense. I was wondering why stack wanted me to add that path when it didn't exist yet
06:06:10 <jedai> ShootLikeCurry: even if you didn't add it to your PATH "stack exec -- ghc-mod" would work though
06:08:45 <jedai> delYsid: stack is really not that hard... and you'll avoid lots of problems
06:12:16 <jedai> delYsid: though cabal new-build is nice, using stackage prevents many compatibility problems
06:13:06 <hpc> stackage on its own doesn't really do much for compatibility
06:13:23 <hpc> it's more the ability to pick specific dependency versions
06:13:35 <hpc> so you get reproducible builds
06:14:33 <jedai> hpc: it's a curated collection of packages, compared to hackage it *has* to have less compatibility problems between packages (though of course you lose the constant up-to-date versions if thought possible)
06:14:33 <hvr> jedai: you can use stackage very easily w/ new-build; it's orthogonal 
06:14:42 <jedai> hvr: True
06:15:24 <hpc> jedai: it does have a non-zero contribution, but not nearly as much as you would expect imo
06:16:25 <hpc> cabal's dependency resolver is not easily predictable
06:16:56 <vukovinski> anyone know if there is a really good CI pipeline for Haskell. I don't want to meddle with running stack install on my local machine anytime soon again? I'm quite good at docker and would even love to collaborate on an open source project for building such a workflow if it doesn't exist already.
06:17:18 <hpc> just use jenkins?
06:17:35 <hpc> it'll already take any job you throw at it
06:18:18 <vukovinski> hpc: can I ssh into it while building?
06:19:52 <hpc> i mean, it doesn't turn off sshd :P
06:20:17 <hvr> hpc: well, by design, any solution which satisfies the constraints is a valid one... there's no explicitly stated optimization algorithm/heuristic
06:21:15 <hpc> indeed
06:22:12 <hpc> it perhaps needs to be easier to check that all constraints are valid, since they are pretty non-local once you account for dependencies
06:22:50 <hpc> then cabal is safer in acting on that assumption
06:24:01 <ertes> delYsid: if cabal-install works for you, use it…  you will know when you need something like stack (in most cases "i need stack" is equivalent to "i'm using yesod")
06:24:24 <hvr> lol
06:26:11 <dxtr> How would I put a timeout on recv?
06:26:25 <dxtr> System.Timeout?
06:26:44 <hvr> dxtr: that should work in theory
06:27:10 <dxtr> So how do I do it in practice? :)
06:27:14 <ertes> dxtr: ideally you use a recv function that can do timeout, but otherwise System.Timeout is fine
06:27:18 * hvr always thought that the GHC IO manager should have builtin support for read timeouts
06:27:36 <dxtr> ertes: There's a recv function that can do timeouts?
06:27:43 <ertes> dxtr: in the latter case (and possibly even in the former) you need the -threaded run-time
06:28:14 <dxtr> I'm running -threaded
06:28:21 <hvr> dxtr: usually, in C-land, you have poll(2) or select(2) which takes care of the timeout 
06:28:29 <dxtr> Yeah exactly
06:28:33 <merijn> You can write one using STM
06:28:48 <merijn> Although a primitive one would probably be cheaper
06:28:56 <hvr> dxtr: however, with GHC, the RTS does the poll/select for you
06:29:08 <merijn> registerDelay + threadWaitReadSTM
06:29:32 <ertes> dxtr: you could set SO_RCVTIMEO
06:29:42 <hvr> merijn: any experience how well the stm variant works if you have thousands of fds?
06:30:58 <merijn> hvr: Should be fairly cheap in case of the threaded runtime, I think?
06:31:12 <ertes> another option is to create a thread that just periodically throws timeout exceptions at all threads
06:31:17 * ertes ducks and runs
06:31:29 <hvr> ertes: I think I've seen something like that in snap
06:31:49 <hvr> ertes: i.e. a thread that takes care of managing timeouts for several connection threads
06:32:07 <ertes> yeah, but "managing" is not what i just suggested =)
06:32:14 <hvr> it's a real problem to get this done efficiently if you have a network server which needs to handle 10k connections
06:32:20 <merijn> hvr: The code for STM and non-STM blocking looks mostly identical
06:32:27 <mnoonan> this is a super long shot, but is anybody familiar with the hburg package (a code generator generator)?
06:32:34 <dxtr> ertes: An alternative to that could be to have a thread that periodically connects to the sockets and sends some junk data 
06:32:46 <merijn> hvr: It basically calls "atomically writeTVar" instead of "putMVar"
06:32:47 <ertes> sad part: i've actually seen such a "timeout" "solution" in practice
06:32:54 <merijn> hvr: So afaict that's pretty cheap
06:33:12 <merijn> hvr: Compare threadWait and threadWaitSTM: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Event.Thread.html#threadWait
06:33:24 <hvr> mnoonan: is that some tree grammar thingie?
06:33:32 <ertes> a cronjob that periodically kills a background worker written in PHP, because it was so buggy that it needed to be killed from time to time
06:33:35 * hvr remembers looong time ago having used 'burg'
06:33:42 <mnoonan> hvr: right
06:34:03 <hvr> but unfortunately, that's almost 20 years ago :-)
06:34:18 <dxtr> I'm actually having a different issue with this code: https://github.com/dxtr/hsidentd/blob/master/src/Lib.hs
06:34:30 <dxtr> in handleClient
06:34:37 <dxtr> It's not closing the socket after sending the data
06:35:04 <merijn> dxtr: What do you mean?
06:35:23 <dxtr> "close client" doesn't seem to actually be run
06:35:54 <merijn> dxtr: How do you detect this?
06:36:16 <dxtr> Connect -> send some data -> receive the data -> The socket is still open because I can keep sending junk to it
06:37:49 <merijn> dxtr: Is your client actually reading data?
06:38:16 <merijn> It might be stuck trying to send data to the client, therefore not reaching the close
06:38:50 <dxtr> Yeah, it's netcat :p
06:39:02 <dxtr> nc 127.0.0.1 1130
06:39:46 <dxtr> Actually, nevermind me
06:40:02 <dxtr> Not enough coffee today I think
06:40:28 <ertes> dxtr: note that your code is not exception-safe, which is important in haskell (async exceptions)
06:40:40 <ertes> dxtr: learn about 'bracket' and 'finally'
06:40:53 <ertes> (and 'catch', if you actually want to catch)
06:40:54 <merijn> ertes: Almost no code in existence is async exception safe
06:41:12 <merijn> ertes: It's not even possible (in general) to ensure async exception safety
06:41:35 <ertes> merijn: yeah, but this one is at the bottom of the safety spectrum =)
06:41:52 <ertes> doStuff >> close socket  -- bad
06:42:00 <ertes> doStuff `finally` close socket  -- better
06:42:09 <dxtr> ertes: Exceptions are for people who decided to fail from the start, am I not right?
06:42:12 <ertes> bracket openSocket close doStuff  -- best
06:42:32 <ertes> dxtr: hmm?
06:42:37 <dxtr> It was a joke
06:42:53 <ertes> sad joke, because that's how most programmers program
06:43:02 <dxtr> I know I'm not handling any exceptions but that's because I actually couldn't find anything about it in the functions I use
06:43:33 <dxtr> The documentation I looked at never stated what exceptions they are throwing and when
06:44:00 <ertes> if all you want is proper cleanup, you don't need to know that
06:44:21 <ertes> just make sure you use 'finally' (to close) or better 'bracket' (to open and close)
06:45:02 <dxtr> Is there anywhere I can read up on this?
06:46:28 <dxtr> ertes: So where would I put bracket, if we take my code as an example?
06:47:18 <ania123> data Tree a = Leaf a             | Node (Tree a) a (Tree a)
06:47:23 <ertes> dxtr: i have to leave now, but i'm happy to help you later (in a few hours)
06:47:43 <ania123> what 'a'  mean between double (Tree a)
06:47:44 <ania123> ?
06:48:03 <ertes> dxtr: in the meantime you may want to read the documentation for 'throwTo', 'finally' and 'bracket' here: https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html
06:48:24 <dxtr> I could do that and actual work :p
06:48:39 <ania123> Node (Tree a) a (Tree a)  here what is "a"
06:48:44 <ania123> I can not figure :(
06:48:58 <mauke> ania123: the same thing it is everywhere else
06:49:24 <ania123> so, Leaf a is a binary tree
06:49:50 <ania123> or recursively left hand side 
06:49:54 <ania123> and right hand side
06:50:07 <ania123> of a Node is binary tree
06:50:13 <ania123> but what is 'a'
06:50:14 <mauke> a Node contains a subtree, an element, and another subtree
06:50:26 <mauke> 'a' is a type variable
06:50:28 <ania123> ah, element in the node
06:50:32 <ania123> itslev
06:50:33 <ania123> no?
06:51:49 <Shou> dxtr, there's section 3.3 in Simon Marlow's Concurrent Haskell explaining exceptions quite succinctly.
06:52:28 <dxtr> Shou: I have that one!
06:52:38 <dxtr> In dead tree format
06:59:11 <joe9_> dxtr: also check out safe-exceptions
06:59:48 <hipsuy> hi
07:00:07 <hipsuy> is anybody there?
07:00:08 <tabaqui1> I have "let !foo = (a,b)"
07:00:21 <tabaqui1> but it won't evaluate "a" and "b" strictly
07:00:22 <hipsuy> .
07:00:22 <tabaqui1> why?
07:00:47 <tabaqui1> and how can I force it?
07:01:05 <Squarism> how do you prefer to run your haskell daemons?
07:01:59 <merijn> tabaqui1: Because it's strictly evaluating the match with foo, i.e., just the outer tuple constructor
07:02:19 <merijn> tabaqui1: Why is this a problem?
07:05:44 <tabaqui1> merijn: hm
07:05:56 <tabaqui1> ok, actually I have next problem:
07:06:09 <tabaqui1> !smth < readFile "foo"
07:06:24 <tabaqui1> let !(a,b) = decode smth
07:06:36 <tabaqui1> handle <- openFile "foo" WriteMode
07:06:49 <tabaqui1> and I get error when trying to open it for writing
07:07:01 <tabaqui1> why GHC doesn't deal this problem by itself
07:07:12 <tabaqui1> IO manager sees that resource is locked
07:07:30 <tabaqui1> it could force all evaluation correspond to this resource
07:07:58 <tabaqui1> *looks like I can fix it with let (!a, !b) = ...
07:08:36 <merijn> tabaqui1: Is that the lazy readFile or the strict one?
07:09:19 <tabaqui1> merijn: lazy
07:09:44 <tabaqui1> I understand why problem occures, but GHC could solve it, but doesn't
07:10:11 <mauke> no, it couldn't
07:10:11 <tabaqui1> *occurs
07:10:25 <tabaqui1> "foo" is locked while reading
07:11:14 <tabaqui1> when I try open it, manager could force all evaluation before drop an error
07:11:25 <mauke> 1) no, it couldn't
07:11:32 <mauke> 2) that would break other code
07:11:37 <mauke> 3) it wouldn't fix the problem in general
07:12:06 <tabaqui1> explain
07:12:39 <mauke> how would it know what to evaluate?
07:13:29 <tabaqui1> all deferred operations with this resource
07:13:45 <tabaqui1> it doesn't have such table?
07:14:08 <mauke> why would it?
07:14:15 <wobble> Is there a way when executing ghici, to execute a function after loading all the modules?
07:14:29 <wobble> That would be stack ghci*
07:15:35 <tabaqui1> mauke: dunno, if you've seen ghc source code, you can tell me if it hasn't
07:15:44 <tabaqui1> *that
07:18:07 <byorgey> tabaqui1: when Haskell code (as compiled by GHC) is executing it essentially has a graph where each unevaluated expression refers to other unevaluated expressions it needs
07:18:33 <ongy> Squarism: I'm going with process in tmux for now
07:18:34 <byorgey> tabaqui1: what you are proposing would require to also store the reverse of all the edges
07:19:06 <byorgey> this would use a lot of space and probably make execution much less efficient
07:20:09 <byorgey> also, it would make lazy I/O even more magical.  It is already too magical by half.
07:20:27 <ongy> Squarism: are you bound to a platform?
07:20:40 <byorgey> by "magical" I mean it is difficult to understand/predict the runtime behavior of code that uses it.
07:20:43 <Squarism> ongy, yes. Im on ubuntu 16.04
07:21:32 <merijn> Anyone who likes that sorta thing willing to proof-read my description of a binary file format and give me feedback on clarity or other comments on potential issues?
07:21:51 <ongy> then for daemons you want to run all the time, I'd go with the normal init-system way
07:22:18 <Welkin> ongy: what are you running?
07:22:43 <tabaqui1> byorgey: I thought that haskell RT cannot be so obvious
07:22:46 <tabaqui1> ok then
07:22:53 <Welkin> I ran my web server inside screen one time for several months
07:23:08 <Welkin> before I knew how to deploy properly
07:25:48 <ongy> Welkin: I don't have any hacky daemon that's not dependant on X currently, had something earlier don't quite remember what it was
07:26:25 <Welkin> ongy: using upstart?
07:26:54 <ongy> nah, I'm on arch/debian. Using systemd. but I login via text
07:33:06 <sm> Squarism: I use supervisord, but should probably move to systemd
07:33:41 <Welkin> didn't ubuntu switch to something else recently? or something?
07:33:53 <sm> there's also http://hackage.haskell.org/package/angel or http://hackage.haskell.org/package/keter
07:34:01 <Welkin> I use keter
07:34:07 <Welkin> but you need to have a daemon watch keter too
07:34:10 <Welkin> which I use upstart for
07:34:14 <sm> ah
07:35:04 <ongy> with systemd you can just run it as normal foreground process and systemd will do a pretty ok job
07:35:10 <ongy> so I get lazy daemonizing things
07:35:14 <Squarism> ongy, thanks.. heard that from 2 now so thats what ill use
07:35:30 <Squarism> other question
07:35:37 <Squarism> what happened to stack run?
07:36:18 <Squarism> "stack run" that is
07:36:56 <sm> did it exist ? dropped in favour of "stack exec -- ..." ?
07:37:37 <sm> http://stackoverflow.com/questions/34842333/is-there-a-stack-run-similar-to-cabal-run
07:37:39 <Squarism> in 1.0.4 it exists. In 1.2.0 not so
07:38:48 <Squarism> ...or i had some wierd tweak going on
07:38:58 <sm> running a stack script achieves something similar
07:39:30 <sm> perhaps you had the stack-run package installed, and stack recognised that
07:39:56 <Welkin> what does `cabal run` do?
07:40:19 <ongy> compile (if necessary) and runa binary from the current project
07:40:30 <Welkin> I always just run the binary dirctly
07:40:54 <Welkin> oh yeah
07:40:59 <ongy> doesn't force recompiliation. also you don't have to go through that awkward path to the binary
07:41:00 <Welkin> I remember using `cabal run` before
07:41:09 <Welkin> to run different executables listed in the .cabal
07:46:11 <paolino> hello, I'm trying to pass a constructor for pattern matching to an ExpQ http://lpaste.net/335327
07:46:28 <paolino> As it is now, I have to pass a Name as second parameter
07:46:52 <paolino> it works but I'd like to know if there is a nicer way
08:04:40 <kuribas> merijn: I can skip over it if you like.
08:05:22 <ongy> kuribas: he posted the link in -offtopic: See here: https://gist.github.com/merijn/0f2468630641646c8a19b9747e34d7fd
08:08:04 <Tuplanolla> Strings with terminating characters sounds like a terrible idea, but it seems otherwise reasonable, merijn.
08:12:04 <Welkin> why not give the length of the string at the beginning instead?
08:13:09 <ongy> he does a mix. Length of string+padding first, then have the padding (at least first char) be '\0'. But I agree, giving length and calculate padding (aligned to 64bits) may be better
08:20:56 <lpaste> lyxia annotated “passing a constructor for a pattern matching to TH” with “reply to paolino” at http://lpaste.net/335327#a335357
08:22:47 <paolino> thanks lyxia , still the p parameter is a Name
08:23:32 <paolino> so I have to issue an expr [|C|] (mkName "C")
08:28:08 <lyxia> I did not understand
08:28:54 <joe9_> I am using safe-exceptions. When I send a TERM does that raise an async exception?
08:29:12 <joe9_> I seem to notice that it just kills the app without raising an async exception.
08:29:29 <joe9_> not sure if I am missing something or if it is expected behaviour.
08:34:35 <sm> hi joe9_, what does the doc for the function you're using say ?
08:38:33 <sm> oh, you mean send SIGTERM to the program eg with ctrl-c ?
08:39:13 <sm> I think that would, yes
08:41:00 <sm> how do you know it doesn't raise an async exception ?
08:48:40 <jvanbure> i have a list/seq/whatever of items for which i need to "statefully" map over them a la mapM with State so that i get both a list of mapped values and a final state
08:49:25 <jvanbure> it would be nice if i could find a suitable 'purely functional'  way of doing this
08:50:07 <ongy> mapM in state is purely functional. You could also go with fold and (:) them back into a list
08:50:41 <jvanbure> simply because i need to do stuff inside the computation that requires treating the state in an immutable way... if that makes any sense
08:51:37 <jvanbure> Now that i've actually typed this out i'm thinking i could just get the state and then runState inside my stateful function with that
08:52:28 <ongy> that sounds weird
08:52:52 <jvanbure> it is weird
08:52:55 <grantwu> jvanbure: wot
08:53:04 <jvanbure> grantwu: typechecker
08:53:08 <grantwu> Yes but still
08:53:11 <grantwu> wot
08:53:51 <jvanbure> when i typecheck an if, i need to typecheck each branch with the state independently, the first branch cant modify the state of the second
08:54:14 <jvanbure> * an if-else
08:54:26 <grantwu> Is traverse useful here?
08:54:43 <grantwu> It should be equal to mapM though...
08:55:07 <jvanbure> yeah
08:55:12 <jvanbure> it's kinda the same
08:55:49 <jvanbure> oh, mapAccumL
08:55:58 <jvanbure> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Traversable.html#v:mapAccumL
08:56:35 <grantwu> Hrm?  I was under the impression that for reasonable monad instances, mapM = traverse
08:56:59 <jvanbure> but if the whole thing is in ExceptT then this is just the same
08:56:59 <grantwu> Or maybe I'm confused
08:57:09 <jvanbure> yes the problem is i don't want mapM
08:57:33 <jvanbure> i'll try doing the runState idea and if it's too horrible i'll come back
08:57:46 <grantwu> oh so you basically want to like
08:57:47 <jvanbure> ongy: thanks for the suggestions!
08:57:49 <grantwu> "fork" the state?
08:57:51 <jvanbure> yes
08:58:23 <grantwu> Hrm
08:58:34 <grantwu> Well good thing we have reified state then lol
08:58:43 <ongy> :t mapM
08:58:45 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:59:19 <jvanbure> grantwu: what?
08:59:31 <grantwu> jvanbure: Like, state is just a value, so we can pass it around
08:59:39 <grantwu> If we were using actual mutable state this would be hard
08:59:51 <jvanbure> oh, yes. that's what i was thinking when i said i could just runState inside my monad
09:00:54 <quchen> Does anyone know a formatter for auto-derived Show strings? I think they’re pretty hard to read, so I wrote my own. Takes a Shown String and reformats it nicely. http://lpaste.net/335421
09:01:05 <quchen> Now I’m wondering whether I duplicated some work here.
09:03:46 * grantwu stares at his code suspiciously
09:04:20 <grantwu> I wish ghc-mod exposed more of its internal state, i.e. what dependent files it's waiting on to typecheck a file
09:05:55 <jvanbure> quchen: there are a few haskell pretty-printers out there, I haven't really used any of them but you could check them out
09:06:42 <supki> quchen: https://hackage.haskell.org/package/pretty-show seems relevant
09:14:04 <dfeuer> I just roughed out some basics for using TypeLits to do possibly-useful things. Does this make sense? Is there a better approach? http://lpaste.net/335455
09:14:32 <lpaste> dfeuer revised “Faking induction with TypeLits”: “Faking induction with TypeLits” at http://lpaste.net/335455
09:16:19 <dfeuer> Is there already a library shim somewhere to match code using typelits to code using real naturals?
09:28:46 <haskell683> why isn't my nub working for returning a list?
09:28:52 <haskell683> I want to remove dups
09:28:55 <haskell683> from the list
09:29:15 <ongy> haskell683: we need a bit more information
09:35:13 <dfeuer> You should use something like Data.Set
09:40:06 <lpaste> dfeuer pasted “nub” at http://lpaste.net/7043940369112760320
09:40:20 <dfeuer> haskell683, that's one possible implementation.
09:40:40 <dfeuer> If this is for a class, though, I wouldn't recommend submitting my code as your own.
09:42:57 <lpaste> dfeuer revised “nub”: “nub” at http://lpaste.net/7043940369112760320
09:43:09 <dfeuer> Changed my mind about one thing.
09:43:29 <dfeuer> Could've gone either way....
09:43:36 <dfeuer> But mixing them was silly.
09:47:53 <k0ral> Hello, is there a haskell library to draw vector graphics that isn't a mere low-level binding to a C library ?
09:47:54 * hackagebot json-bytes-builder 0.5 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.5 (NikitaVolkov)
09:48:29 <davean> k0ral: https://hackage.haskell.org/package/diagrams?
09:49:42 <ertes> dfeuer: as in reflection and reification for Natural?
09:49:59 <vukovinski> does stack/cabal have a CPU core usage limit config?
09:50:11 <vukovinski> draining all my CPU power
09:50:34 <Tuplanolla> How about `nice`, vukovinski?
09:50:47 <davean> vukovinski: you can set it to single core
09:50:51 <davean> vukovinski: use -j
09:51:02 <k0ral> davean: I overlooked that one due to its name, it's kinda misleading as it's not just meant to draw diagrams
09:51:11 <k0ral> davean: looks very interesting actually, thanks for the pointer
09:51:18 <davean> k0ral: I mean, whats a diagram? I think you might have a weird definition
09:51:52 <vukovinski> davean: Tuplanolla: thanks, will try now
09:52:10 <davean> nice lowers the priority, not how much it uses BTW
09:52:12 <k0ral> davean: a graphical representation of data ?
09:52:50 <davean> k0ral: thats a weird definition, a pretty rare one I think, and also that fits all vectors?
09:52:59 <byorgey> davean: I would call that a 'data visualization'
09:53:03 <byorgey> I mean k0ral 
09:53:13 <davean> byorgey: I'd agree
09:53:38 <davean> byorgey: possibly a chart, but thats one very specific subcase of a chart
09:53:51 <k0ral> byorgey, davean: I guess I'm biased because of my native language in which "diagram" semantically means graphical representation of data
09:53:52 <davean> since charts are also navigational, etc
09:54:11 <davean> k0ral: Thats almost never what I'd expect diagram to mean
09:54:19 <dfeuer> ertes, I think I may not have thought through the use cases enough.
09:54:20 <k0ral> davean: then you're probably not french
09:54:31 <byorgey> k0ral: fair enough!  in any case, if you do give diagrams a try, feel free to come ask questions in #diagrams
09:54:44 <k0ral> byorgey: I'll keep that in mind, thank you :)
09:54:47 <davean> k0ral: lucky me :)
09:54:54 <Tuplanolla> I don't think of arbitrary vector graphics when someone mentions diagrams either.
09:55:11 <byorgey> k0ral: we are friendly and we like to help (though if you ask a question you might have to be patient)
09:56:02 <byorgey> I have considered many times whether 'diagrams' was a good choice of a name.  But it's far too late now =)
09:56:13 <johnw> it's a great name
09:56:42 <byorgey> usually I agree. =)
09:56:43 <Tuplanolla> I would've personally chosen `squiggles`.
09:56:53 <byorgey> but no name is perfect.
09:56:57 <k0ral> byorgey: don't let a french fool put you in doubt :)
09:57:07 <byorgey> k0ral: no worries =)
09:57:21 <ongy> vukovinski: if you are on a somewhat recent linux, you can use cgroups to limit CPU time
09:57:47 <byorgey> Tuplanolla: 'squiggles' makes me think of https://en.wikipedia.org/wiki/Bird%E2%80%93Meertens_formalism
09:58:12 <Tuplanolla> Without knowing better, I'd expect `diagrams` to come from Kmett and feature functors from index categories.
09:58:21 <dfeuer> Tuplanolla++
09:59:50 <Tuplanolla> (The unexpected part is finding a library written by someone else.)
10:02:16 * ski . o O ( "Algebra of Programming" by Richard Bird,Oege de Moor )
10:10:22 <nevere> How can I use readerT and writerT in the same do block?
10:10:42 <mmaruseacph2> is there a way to specify a text file (template) in cabal such that when only that file changes the whole executable is rebuilt? I'm using template haskell reading from that file and want to be able to recompile the application
10:11:23 <dcoutts> mmaruseacph2: there's a TH feature to do that
10:11:41 <dcoutts> mmaruseacph2: and then you'd also need to list that file in the extra-source-files in the .cabal file
10:11:50 <dcoutts> since both cabal and ghc need to know to rebuild
10:11:56 <mmaruseacph2> thanks
10:12:12 <mmaruseacph2> what's the TH feature? I seem to be unable to find it
10:12:27 <dcoutts> there's a TH function called something like dependsOnFile
10:12:30 <dcoutts> or something like that
10:12:41 <dcoutts> you'll know it when you find it in the TH API docs
10:12:41 <mmaruseacph2> oh, thanks
10:15:37 <nevere> How can I use a 'tell'  function in the "readAndSum" function here, http://lpaste.net/335621 ?
10:18:56 <mmaruseacph2> it was addDependentFile, now all seems to work, thanks dcoutts 
10:19:54 <dcoutts> mmaruseacph2: great, do include it in the extra-source-files though, as cabal new-build and probably stack too will not notice the file change without that
10:19:56 <c_wraith> nevere, you'd need to change the type. 
10:20:23 <nevere> c_wraith: Yes. I know. But I can't figure out what that would be. 
10:24:03 <c_wraith> nevere, there isn't one right answer. a lot depends on how you want to compose things. 
10:25:14 <nevere> c_wraith: Say, I just wanted to add logging to that readAndSum function, how can I call "tell" to log to a string?
10:25:22 <ytrewq> HI!!!
10:25:51 <c_wraith> nevere, do you care what can call it? 
10:27:26 <nevere> c_wraith: Didn't get you. 
10:28:06 <jackID> hallo
10:32:09 <c_wraith> nevere, what you make the type affects the contexts in which it can be used. 
10:32:54 <c_wraith> nevere, what you're asking is a design choice with all kinds of consequences. 
10:33:46 <c_wraith> nevere, so answering the question well requires knowing what you're doing with the answer. 
10:35:13 <nevere> c_wraith: Ok. I don't care what can call it. I am looking for just one example where these two work together.
10:36:02 <c_wraith> nevere, so what is your goal? are you learning how a specific library works? are you looking for good design patterns? and what is your type-level complexity comfort, anyway? 
10:37:41 <nevere> c_wraith: My goal is to find out how I can wrap a reader in a writer (or the other way), and use both in a do block. I think I understand most of the type level stuff, though I am not really fluent in it.
10:38:43 <c_wraith> you can trivially combine the transformers in either direction, as those two commute with each other. 
10:39:56 <c_wraith> ReaderT [(String, Int)] (WriterT String IO) Int
10:40:02 <c_wraith> that's one direction 
10:40:29 <c_wraith> it's just a trivial substitution. 
10:42:33 <c_wraith> but there are so many other things that could be mentioned, like how WriterT is 1. Broken and should not be used,  2. especially for logging, since it associates the wrong way most of the time. 
10:43:45 <c_wraith> Or how you if you want something more usable, you should be going with the class-based interface it provides. 
10:43:54 <c_wraith> err, the mtl provides. 
10:44:18 <c_wraith> that requires more knowledge of the type system to make sense of, but it's definitely more flexible. 
10:45:01 <c_wraith> whether details like that are important depend on the motivation for asking the question. 
10:45:59 <c_wraith> which is why people often ask what you're doing when you ask a question.. there are many nuances of answer available, and it'd be nice to respond with the correct level of nuance. 
10:50:05 <nevere> c_wraith: Ok. I understand. I actually tried something like "ReaderT [(String, Int)] (WriterT String IO) Int". But for the other function, doSum, http://lpaste.net/335735
10:51:35 <c_wraith> nevere, well, you might need to add additional calls to lift.. remember that there are now two levels between IO and the do block. 
10:52:09 <c_wraith> lift . lift $ putStrLn "..." 
10:52:12 <c_wraith> and so on. 
10:52:25 <johnw> or liftIO
10:52:56 * hackagebot git-annex 6.20161111 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20161111 (JoeyHess)
10:53:19 <johnw> git-annex is awesome
10:53:47 <c_wraith> someday I'll figure out what it does. 
10:54:07 <johnw> it records links into a "file store"
10:54:16 <johnw> where the contents of that store can be spread among multiple machines
10:54:22 <johnw> and/or replicated
10:54:38 <johnw> so, the links are tracked in Git, but the file store is managed separately using checksums and various provided backends
10:54:42 <nevere> c_wraith: so can I access the inner writer using lift, something like 'lift $ tell "log message"'?
10:54:50 <c_wraith> nevere, yes
10:55:08 <Tuplanolla> Sounds like a good way to accidentally lose the only copy, johnw.
10:55:20 <johnw> Tuplanolla: it will not let you drop the last copy of any entry
10:55:39 <c_wraith> nevere, there are tools to make this less verbose in the mtl library, but they are a bit more complex 
10:55:40 <johnw> Tuplanolla: not saying you couldn't find a way to lose it, but you can't lose it using its interface
10:56:02 <johnw> and you can say things like, "There should always be 2 extant copies of this entries"
10:56:32 <Tuplanolla> It's more on me breaking machines than the program losing copies.
10:56:52 <Tuplanolla> I'll have to try it sometime.
10:56:59 <johnw> Tuplanolla: so, I have a file server that is my "canonical file store" for git-annex, and then multiple machines (desktops, laptops) which each have all or some of that store's contents
10:58:13 <johnw> it's a great way to associate metadata (like, build tools or digit assets) with a project, so that people can pull the ones they need when they need them, without bloating Git
10:58:52 <c_wraith> git repos with less than 20 gigs of history? what? 
10:59:02 <johnw> :)
10:59:11 <johnw> my git-annex filestore is just over 1 TB
10:59:42 <Tuplanolla> My entire hard drive with all my works is smaller.
10:59:48 <nevere> c_wraith: It worked. Thank you :) 
11:07:57 * hackagebot git-repair 1.20161111 - repairs a damanged git repisitory  https://hackage.haskell.org/package/git-repair-1.20161111 (JoeyHess)
11:13:26 * hackagebot torrent 10000.0.1 - BitTorrent file parser and generater  https://hackage.haskell.org/package/torrent-10000.0.1 (JoeyHess)
11:20:46 <mariothemad> hello all, has anyone had any trouble with stack and ghc recently? I'm getting the following error: http://lpaste.net/335819
11:25:36 <geekosaur> that's the no-PIC issue
11:25:46 <mariothemad> googling
11:26:01 <geekosaur> er, no-pie
11:26:48 <mariothemad> found it: https://github.com/commercialhaskell/stack/issues/2712
11:26:54 <hpc> if you're in the US, no-pie issues should resolve themselves in a week or two
11:27:06 * Clint snorts.
11:27:16 <mariothemad> What...exactly is the issue?
11:27:21 <mariothemad> how do I get the pie?
11:27:46 <Clint> mariothemad: gcc -v 2>&1 | grep --color default-pie
11:28:39 <ongy> it's empty :(
11:30:20 <mariothemad> This is what I get for using testing I suppose.
11:30:50 <Clint> mariothemad: ghc in unstable and ghc in experimental both work
11:30:59 <Clint> won't help you with your stack problem, i guess
11:32:27 <mariothemad> That's the strange thing. GHC and ghci both work.
11:32:27 <hvr> hpc: always looking on the bright side, eh? ;)
11:33:59 <geekosaur> that would be because you are getting an already fixed ghc from the command line, but the ghc that stack has squirreled away for its own use does not have the fix
11:50:47 <ryandevilla> @pl \x -> x
11:50:47 <lambdabot> id
11:50:58 <ryandevilla> @pl \x y z -> f x y z
11:50:59 <lambdabot> f
11:52:44 <hpc> @pl \a b c d -> b d e c b a
11:52:44 <lambdabot> flip (flip . (flip .) . (flip =<< (flip .) . flip . flip flip e))
11:54:42 <nitrix> Aka (╯°□°）╯︵ ┻━┻
11:56:34 <lgstate> how close is haskell to Backus Turing Lecture style FP of "manipulate functions; few variable names" ?
11:56:44 <nitrix> hpc: Make that infix and you're good to go :D
12:01:04 <hpc> lgstate: technically zero variable names, they're all constants ;)
12:01:27 <lgstate> hpc: I thought you were going to maked a pointfree joke
12:01:30 <lgstate> but this is also valid
12:02:20 <Tuplanolla> Damn, it took Vim four minutes to fold a 580-line paragraph. I can't wait until Yi becomes usable.
12:02:30 <Tuplanolla> Does anyone use it here?
12:05:34 <hpc> Tuplanolla: i think you'll find a lot of people use vim here ;)
12:06:21 <eacameron> Does GHC float String literals to CAFs when you use things like Text.pack?
12:06:36 <eacameron> I.e. does Text.pack allocate every time you use it, or only once?
12:06:43 <eacameron> For *literals*
12:07:02 <eacameron> Particularly when using OverloadedStrings...
12:07:59 * hackagebot clustering 0.3.1 - High performance clustering algorithms  https://hackage.haskell.org/package/clustering-0.3.1 (kaizhang)
12:08:07 <kzhang> \join #haskell-cn
12:10:39 <subleq> I'm trying to design a data type to store a table: it has a list of header names, a list of columns names, and a value for each row-column intersection. Is there a good way to do that, in a way that prevents inconsistencies?
12:11:15 <jvanbure> If i have a stack of ExceptT String (State MyState) MyVal, and i run the stack with runState (runExceptT stuff) statestuff, I'll get a tuple of (Either String MyVal, MyState)
12:11:37 <subleq> the headers and columns are not statically known, but It'd be nice to ensure that the number of columns of data matches the number of column names, etc
12:11:40 <jvanbure> this seems intuitively not quite right, as i would expect to have the entire result in an either
12:11:57 <hpc> :t runState
12:11:59 <lambdabot> State s a -> s -> (a, s)
12:12:16 <hpc> runState foo bar = (something, something else)
12:12:30 <hpc> and your expression matches that
12:13:12 <jvanbure> hpc: I get that the types of the functions give this, but it just seems odd to me that having ExceptT on the outside doesn't mean that the result of running the stack is wrapped in an Either
12:13:12 <hpc> monad transfomers are a little bit inside-out from what your intuition would think in a couple of places
12:13:53 <bollu> what is LogicT useful for?
12:14:09 <jvanbure> hpc: so if i wanted the behavior where I got an Either on the outside, would it be appropriate to swap the order of the transformers?
12:14:36 <hpc> yes
12:14:50 <jvanbure> cool, thanks!
12:15:01 <hpc> in general, FooT Bar a = Bar (Foo a)
12:15:07 <hpc> which you can see from the type of lift
12:15:08 <hpc> :t lift
12:15:10 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
12:15:17 <hpc> or well, sort of
12:15:24 <ski> @unmtl ErrorT String (State MyState) MyVal
12:15:24 <lambdabot> MyState -> (Either String MyVal, MyState)
12:15:25 <hpc> it's almost visible ;)
12:16:13 <jvanbure> hrm, that is a little counterintuitive lol. Thanks again!
12:16:22 <hpc> bollu: LogicT is a lot like ListT, except commutative
12:16:52 <bollu> hpc: hm, I don't know a lot about ListT except that "it's hard to get right"
12:16:55 <hpc> bollu: er, rather it doesn't care about commutativity
12:17:08 <bollu> hpc: I'd imagine ListT gives me the ability to have non-determinism?
12:17:09 <hpc> bollu: the hard part of ListT is that in ListT m a, m has to be a commutative Monad
12:17:17 <hpc> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-List.html#t:ListT
12:17:38 <hpc> and it has some performance problems iirc
12:17:57 <hpc> LogicT is sort of a CPS transformation of it
12:18:26 <implementation> https://wiki.haskell.org/ListT_done_right
12:20:22 <erisco> :t foldr (flip (>>=))  -- is there not a standard name for this?
12:20:25 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
12:20:47 <hpc> that looks Applicative-y
12:21:00 <ski> not really
12:21:52 <hpc> :t foldr (=<<)
12:21:54 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
12:22:24 <hpc> hmm
12:23:08 <ski> @type foldr (<=<) return
12:23:13 <lambdabot> (Foldable t, Monad m) => t (b -> m b) -> b -> m b
12:27:33 <bollu> how do I use "deriving Show" on a GADT?
12:27:54 <johnw> you write a Show instance
12:28:07 <johnw> deriving doesn't work so well for GADTs
12:28:17 <bollu> johnw: oh, I see. is there a fundamental reason as to why?
12:28:51 <johnw> it's easy to write a GADT that wouldn't have an automated show instance, but I'm not sure if that's the reason
12:29:02 <bollu> hm, okay :)
12:29:36 <hpc> probably a combination of that and nobody wanting to actually write it
12:29:41 <ski> (you write the `Show' instance by defining `showsPrec' .. using that, `shows',`showParen',`showChar',`showString',...)
12:30:02 <hpc> and it not being easy to figure out in general what derivations are safe to make
12:31:50 <bollu> hm, is there a "scammy" way to show a ProgramT?
12:33:00 * hackagebot ghcid 0.6.6 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.6.6 (NeilMitchell)
12:33:11 <erisco> writing fib in State is a bit overkill ^.^
12:37:44 <mmaruseacph2> indeed
12:42:08 <Profpatsch> @pl \x -> sin x
12:42:08 <lambdabot> sin
12:42:26 <Profpatsch> @pl \x y -> x + y
12:42:26 <lambdabot> (+)
12:49:55 <bollu> how do I get data out of a ProgramT?
12:51:16 <nitrix> What do you mean by "out" ?
12:51:55 <bollu> I don't understand the philosophy of operational
12:52:03 <bollu> do you make a "monad of instructions" (like an ADT)
12:52:19 <bollu> nitrix: I'm rephrasing my questoin
12:53:37 <nitrix> I think you're supposed to use `view`.
12:53:45 <bollu> nitrix: hm
12:53:50 <nitrix> Which gives you your first instruction of your program.
12:53:55 <jle`> bollu: you can think of State as operational over Get and Put
12:54:09 <jle`> and it gives you tools to sequence them
12:55:36 <bollu> nitrix: thanks :) 
12:55:40 <bollu> jle`: hmm
12:55:49 <bollu> jle`: so the GADT defines your operations, right?
12:55:54 <bollu> jle`: but where are the semantics?
12:56:54 <jle`> there are no extra semantics besides the gadt, it's a free construction
12:57:03 <jle`> those come when you interpret it
12:57:21 <nitrix> bollu: `view` results in a ProgramViewT which you further use with :>>=, which borrows the same idea as >>=, it lets you chain a function which will receive the instruction and can perform work, but that work is necessarily part of the program, as you're in a monadic context.
12:57:30 <jle`> you interpret the big chain that it builds up and that's when the actions/operations are given their meaning
12:57:46 <bollu> jle`: so it's sorta like the free monad right?
12:57:53 <bollu> jle`: what's the difference between the two approaches?
12:58:30 <bollu> nitrix: I see :) I'm playing around with it right now
12:58:32 <jle`> operational actually abstracts over a common usage pattern of Free
12:58:45 <jle`> a lot of things people use Free for can be abstractec over using operational
12:59:34 <jle`> most "free for dsl's" tutorials all follow a certain pattern, and Operational abstracts over it pretty well
12:59:43 <bollu> ah, I see
13:00:07 <jle`> "turning operations into functors" is kind of unnatural to me even
13:00:36 <jle`> (in the Free approach)
13:01:01 <johnw> whereas Free abstract "pure" and "join", operational's ProgramT abstracts "pure" and ">>="
13:01:33 <jle`> you can write Free over >>= though, tho
13:01:38 <johnw> note that you can play this same game with any type classes, reifying it as a term in some DSL.  This lets you define free applicatives, free anything.
13:01:49 <johnw> I like the way 'streaming' abstracts Free
13:01:50 <mmaruseacph2> free Frees
13:01:55 <johnw> and also the van Laarhoven Free is very nice
13:02:10 <johnw> semantically, they all preserve the same information; it's just different encodings
13:04:26 <bollu> thanks :) I'm playing aronund with operational right now
13:04:33 <bollu> van Laarhoven next I suppose
13:04:33 <bollu> :)
13:05:16 <johnw> van Laarhoven free is pretty awesome when FreeT is really what you needed, and you also want to compose multiple effect algebras
13:05:51 <jle`> bollu: for example, there's the common Free example, data StateF s a = Get (s -> a) | Put s a   -- a lot of Free-based dsl's have a base functor of this type, with an 'input' (like s in Put) and 'output' (like s in Get)
13:06:26 <jle`> bollu: once you see that most Free-based dsl's have this pattern, you can abstract over it with a general type with general inputs and general outputs
13:06:46 <jle`> where Get would have () as input and s for outpt, and Put has s for input and () for output
13:09:21 <jle`> oh wait maybe i'm thinking of something else
13:10:43 <bollu> ?
13:16:43 <Apocalisp> So, Cloud Haskell seems cool, but are there any higher-level abstractions that let me write a system declaratively and then "compile" to Cloud Haskell actors?
13:16:44 <bollu> where can I learn to do coinduction proofs?
13:16:55 <bollu> I know how induction proofs work. what about coinductive?
13:18:17 <bitemyapp> Apocalisp: not that I'm aware of. I know you're probably working from Akka -> ?Haskell? but be aware CH isn't widely used.
13:18:39 <bitemyapp> Apocalisp: I've known people to successfully use it, but most people will mix up pipes/conduit, some TCP sockets, cereal, etc.
13:18:48 <bitemyapp> That doesn't make it a bad idea, just the path less taken.
13:18:55 <Apocalisp> yeah, I'm working with people coming from Akka who think CH is a good idea for some reason
13:19:10 <bitemyapp> I'd push back on that.
13:19:21 <bitemyapp> CH is more, uh, typed although I must confess to not looking at Typed Akka much.
13:19:29 <bitemyapp> but yeah, I'd push back on it. KISS.
13:19:53 <bitemyapp> Apocalisp: I've gotten pretty far (streaming analytics in adtech) with: http://hackage.haskell.org/package/slave-thread Pipes, cereal.
13:19:55 <Apocalisp> good plan
13:20:58 <joeyh> I have some functions that intentionally add contstraints that the new default -Wredundant-constraints warns about. Is there a good way to disable such a warning for a single function
13:20:59 <johnw> bitemyapp: how does slave-thread differ from what async does?
13:21:22 <joeyh> I worry that disabling it module-wide is too broad and the function might get moved to another module and the constraint removed..
13:21:37 <bitemyapp> johnw: you don't explicitly block on a single thread or a collection of threads.
13:21:55 <johnw> oh, I see it
13:21:58 <bitemyapp> it's doing the ascription and exception floating for you.
13:21:59 <johnw> management behind the scenes?
13:22:07 <bitemyapp> yes, you could write it in terms of Async, but if it already exists...
13:22:11 <johnw> got it
13:22:17 <bitemyapp> we used Async for shorter lived stuff.
13:22:37 <bitemyapp> slave-thread was more of our "10% of supervisor trees" thing.
13:23:40 <bitemyapp> we made some kind of minor modification to slave-thread, but I cannot for the life of me remember what it was.
13:24:28 <bitemyapp> https://github.com/nikita-volkov/slave-thread/issues/3 ah there it is
13:31:43 <joeyh> oh my, -fno-warn-redundant-constraints breaks building with ghc 7.10.
13:32:54 <hexagoxel> yay for conditional ghc-options..
13:33:35 <joeyh> some way to only disable it with the new version? 
13:33:50 <joeyh> (other than making a cabal build flag on the version of base or some such mess)
13:34:04 <Tuplanolla> How does it break? Sounds like a GHC bug.
13:34:44 <joeyh> well, the old ghc just does not have that option. It was added to the new version
13:35:06 <Tuplanolla> Oh, like that.
13:36:03 <Apocalisp> bitemyapp: how about using Servant as the protocol layer between conduits at different locations?
13:36:22 <Apocalisp> and do you pipe rather than conduit?
13:37:03 <hexagoxel> joeyh: you don't need a flag to do "if impl(ghc >= 8.0)" in .cabal
13:37:28 <hexagoxel> joeyh: https://github.com/search?p=1&q=-fno-warn-redundant-constraints+extension%3Acabal&ref=searchresults&type=Code&utf8=%E2%9C%93
13:41:48 <bitemyapp> Apocalisp: we used pipes because of accumulated institutional expertise, it wasn't my decision but I do have more experience with Pipes.
13:42:23 <bitemyapp> Apocalisp: I've only attempted (and given up 4 times) to use Servant for backend web apps. Coworker is successfully using it as a frontend app router right now.
13:44:26 <Apocalisp> why'd you give up?
13:44:56 <bitemyapp> simple stuff like, "A handler which optionally sets the user session header" was impossible given the types.
13:45:10 <tnks> We're using Servant, but only because our endpoints are simple, and with these small services it's not that much of a commitment LOC-wise.
13:45:11 <bitemyapp> Arni quickly patched up the most recent example I just gave you, but I only have so much time to patch up basic functionality.
13:45:22 <Welkin> bitemyapp: so what do you use?
13:45:25 <bitemyapp> tnks: this was in a <1000 LOC app that just needed auth.
13:45:26 <Welkin> yesod?
13:45:28 <Welkin> wai?
13:45:32 <bitemyapp> why what?
13:45:58 <tnks> bitemyapp: yeah, we're not dealing with session/auth, and are just enjoying the pleasures of Servant as an API.
13:46:18 <bitemyapp> everytime I tell people what we use, they go, "EW GROSS TEMPLATE HASKELL", whether I'm talking about the DAL or the web stack.
13:46:19 <Welkin> I have been using servant with elm recently and it works great
13:46:21 <bitemyapp> so, I don't really care any more.
13:46:26 <Welkin> except for some pains getting cors working
13:46:43 <Welkin> bitemyapp: you never mentioned what you are using, and I just asked
13:46:54 <Welkin> I haven't tried added auth yet though
13:46:58 <Welkin> adding*
13:46:59 <bitemyapp> Yes, I use Yesod generally.
13:47:03 <tnks> bitemyapp: if Servant really reaches a limit, I think Sooraj and I are open to bumping to Yesod in all it's glory.
13:47:05 <bitemyapp> usual WAI+Warp deal.
13:47:07 <Welkin> I previously used yesod for everything
13:47:27 <bitemyapp> I usually sit it behind nginx or haproxy.
13:48:08 <Welkin> why not use warp by itself?
13:49:32 <bitemyapp> warp isn't really an abstraction layer for writing web applications?
13:49:35 <bitemyapp> Yesod saves a lot of labor?
13:50:11 <Welkin> no
13:50:19 <Welkin> I meant why not run yesod/warp by itself
13:50:32 <Welkin> no need for nginx
13:51:12 <bitemyapp> I don't expose PL-specific web servers to the public internet.
13:51:21 <bitemyapp> that's just basic ops hygiene.
14:00:02 <younder> You can use fastcgi to run it under apache I think.
14:01:50 <johnw> I have to agree with bitemyapp on that one
14:02:01 <vukovinski> why not a docker orchestration distributed architecture?
14:02:02 <johnw> nginx gets like 100,000x more daily vetting than warp does
14:03:03 * hackagebot propellor 3.2.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.2.2 (JoeyHess)
14:10:11 <ryandv> @pl \(x, y, z) -> f x y z
14:10:12 <lambdabot> (line 1, column 9):
14:10:12 <lambdabot> unexpected "z"
14:10:12 <lambdabot> ambiguous use of a non associative operator
14:10:30 <ryandv> @pl \(x, y) -> f x y
14:10:31 <lambdabot> uncurry f
14:10:36 <ryandv> @pl \(x, y, z) -> f x y z
14:10:36 <lambdabot> (line 1, column 9):
14:10:37 <lambdabot> unexpected "z"
14:10:37 <lambdabot> ambiguous use of a non associative operator
14:12:10 <Tuplanolla> If you call it directly, you'll get an unsupported constructor error on `PTuple Boxed [PVar (Ident "x"), PVar (Ident "y"), PVar (Ident "z")]`, ryandv.
14:12:35 <joeyh> bitemyapp: hope your esqueleto takeover can proceed, situation is getting increasingly complicated with debian shipping a modified version..
14:13:32 <Tuplanolla> The problem is that the thing doesn't know about `fst3` etc.
14:19:55 <joncol> Is there any established conventions on using spaces around the lens operators. I'm looking at the hoogle documentation and at one place it says `V2 1 2 ^._y` followed immediately by `V2 1 2 & _y .~ 3`.
14:20:05 <joncol> *Are there
14:20:20 <bitemyapp> joeyh: yikes, I didn't know Debian had done that.
14:20:51 <joeyh> well, it's common for debian to apply patches temporarily as needed. May cause a chain of follow-on patching in this case
14:20:58 <Tuplanolla> I always put spaces around things, joncol.
14:21:25 <bitemyapp> joeyh: nice seeing you in here by the way. Always admired you from afar, since I read your usesthis/The Setup interview.
14:21:57 <joeyh> well, I keep meaning to read your book, so there
14:21:57 <bitemyapp> but uh, yeah, pretty much every project I work on uses Esqueleto as do past projects I've worked on for clients. I'd be pretty upset if that fell apart in my wake.
14:21:57 <Clint> joeyh: git-annex is the only actual package affected
14:22:07 <joeyh> Clint: lucky me
14:22:10 <Tuplanolla> Otherwise you end up with unpleasant corner cases like `\~(x, y) -> x` being a parse error or `(##)` not being what you expect.
14:22:25 <joncol> Tuplanolla: Yes, I used to as well. Lately I've been experimenting with *not* having spaces around (+) and (*) if it makes the code read nicer. Didn't think I'd ever do anything like that :)
14:22:32 <bitemyapp> joeyh: I'd be very honored if you found the time to do so. I know you're busy.
14:33:57 <orion> bitemyapp: What's the "DAL"?
14:34:26 <bitemyapp> Data access layer
14:34:42 <bitemyapp> It usually implies you're trying to maintain one consistent'ish layer of the app that talks to the database
14:34:51 <bitemyapp> as opposed to weaving it throughout your logic
14:35:08 <orion> Ah.
14:36:43 <bitemyapp> In this case, I'm talking about what libraries I use to describe the database schema and read from/write to the database
14:37:03 <orion> bitemyapp: "PL-specific"?
14:38:15 <bitemyapp> programming language specific
14:38:23 <bitemyapp> they get scrutinized less than widely used web servers like nginx and apache.
14:38:44 <orion> Ah.
14:39:06 <bitemyapp> you make a hackers job a lot easier, even if you're using setcap, by exposing less audited web servers publicly.
14:39:31 <wespiser> hello, I have a problem figuring out how a variable assignment is happening inside one of my files. Could any one help me with this? I just need an expert to take a look. 
14:39:33 <bitemyapp> for one thing, even if they don't get root, ostensibly your PL-specific server will have access to SSL certs or the database.
14:39:42 <bitemyapp> you want to at least shift the former out of its locus of control.
14:40:14 <geekosaur> @paste
14:40:15 <lambdabot> Haskell pastebin: http://lpaste.net/
14:40:18 <geekosaur> wespiser, ^
14:40:43 <wespiser> how's this: https://github.com/write-you-a-scheme-v2/scheme/blob/master/src/Parser.hs#L38
14:41:06 <mauke> pattern binding
14:41:20 <mauke> using record destructuring
14:41:32 <`lm`> Folks, I have an odd question that may be a result of me abusing typeclasses. This code doesn't compile; how can I make it compile? http://lpaste.net/670845411707060224
14:41:42 <wespiser> okay, so its mapping the fields of the data constructor to new variables?
14:41:52 <geekosaur> yes
14:42:07 <wespiser> thanks, I wasn't 100% sure, and I need to be for this project!
14:42:37 <ski> (wespiser : it's not assignment)
14:42:42 <mauke> the problem with 'show empty' is it doesn't know which empty you want
14:43:11 <wespiser> if its not assignment, what is it?
14:43:16 <`lm`> mauke: is there a generic way to tell it that? (empty :: a) doesn't work either
14:43:18 <ski> variable binding
14:43:27 <wespiser> the difference being?
14:43:34 <geekosaur> you can't change a binding
14:43:34 <ski> (there is no variable assignment in Haskell)
14:43:42 <mauke> `lm`: (empty `asTypeOf` x)
14:43:46 <mauke> also, your nick is annoying
14:43:49 <wespiser> that sounds like a semantic difference
14:43:51 <geekosaur> once you make it, it's permanent; you could shadow it with a different binding, but you can't update it
14:43:56 <wespiser> not to be rude
14:43:56 <ski> (however, there is assignment into reference cells)
14:44:02 <mauke> most differences are semantic
14:44:06 <mauke> the rest are syntactic
14:44:07 <Hafydd> /nick `asTypeOf`
14:44:07 <wespiser> inorite
14:44:23 <kwantam> if you'd prefer a syntactic difference, I'm sure the statement can be rephrased
14:44:25 <ski> wespiser : yes, the semantics, iow the meaning, of the two concepts, are different
14:44:38 <kwantam> :)
14:44:40 <mauke> it's almost like different words mean different things
14:44:42 <geekosaur> this is more than just playing with words; if you assume it's something you can update, you will get into trouble
14:45:12 <`lm`> mauke: ahh, cool. Thanks! (and, sorry for the annoying nick)
14:45:28 <wespiser> I'm well aware, thank you!
14:45:29 <geekosaur> (people get really confused about how `let y = y + 1` is an infinite loop, not updating the value of y)
14:45:31 <mauke> `lm`: (empty :: a) probably works if you enable ScopedTypeVariables
14:45:52 <ski> wespiser : anyway, that pattern-binding is similar to being able to say `(front,back) = splitAt 3 "foobar"', e.g.
14:46:08 <geekosaur> and `let y = x + 1` only lasts in the scope of the new y, it doesn't change an outer y
14:46:09 <ski> > let (front,back) = splitAt 3 "foobar" in front ++ " " ++ back
14:46:11 <lambdabot>  "foo bar"
14:46:20 <wespiser> If you would like to criticize me, please take a look at https://github.com/write-you-a-scheme-v2/scheme/ 
14:46:22 <geekosaur> these are real differences, not word games
14:46:31 <`lm`> mauke: cool. I've got some reading to do now!
14:47:00 <ski> wespiser : in your case, instead of the pattern being a pair `(front,back)', it is a record, with fields of various names, where the contents are being named `m_parens',`m_identifier',&c.
14:47:01 <wespiser> yea, but the word "assignment" and "binding" could just as well refer to the other thing
14:47:10 <joncol> I'm looking at linear. I want a function that returns the "major axis" of a `V3 Double`. Can the E newtype be used for this? Or what is that used for? 
14:47:20 <mauke> without ScopedTypeVariables, the compiler assumes you meant (empty :: forall a. a)
14:47:23 <wespiser> except for the fact the we standardized the meanings. the words are not inherent to our field
14:47:30 <mauke> i.e. the 'a' is a new (local) type variable
14:48:08 <erisco> in wespiser's arena they are interchangeable words and in other's arenas they are not
14:48:11 <`lm`> mauke: hmm, alright. I had thought that it would bind 'a' to the class type variable
14:48:21 <wespiser> yea, guys, it doesn't really matter
14:48:32 <erisco> it matters to them… matters to me
14:48:56 <wespiser> what matters to me is how the compiler actually implements it
14:48:58 <ski> what matters is that you understand the difference in the concepts
14:48:59 <wespiser> that's my world right now
14:49:02 <wespiser> i do
14:49:06 <wespiser> take a look at my project
14:50:28 <erisco> binding, reference, definition
14:50:46 <ski> wespiser : hm, immutable lists ?
14:50:51 <ski> not even improper lists ?
14:50:57 <mauke> a program is what you give the audience. a script is what you give the actors.
14:51:06 <wespiser> not dotted lists
14:51:07 <ski> no `eq?'
14:51:20 <ski> tail calls ?
14:51:33 <ski> first-class continuations ?
14:51:39 <wespiser> its a tutorial
14:51:48 * ski nods
14:52:00 * mauke winds dynamically
14:52:01 <wespiser> alright, any advice for extending it?
14:52:14 <erisco> well if you were choosing a word for a tutorial do not use "assign"
14:52:21 <wespiser> okay
14:52:35 <wespiser> thanks
14:52:51 <ski> is there any `set!' ?
14:53:05 * hackagebot hsc2hs 0.68.1 - A preprocessor that helps with writing Haskell bindings to C code  https://hackage.haskell.org/package/hsc2hs-0.68.1 (HerbertValerioRiedel)
14:53:07 <erisco> evidently some people take "assign" to mean different things, but we should be less confused on "bind" or "references" or "definition" or something like this
14:53:51 <wespiser> no set!
14:54:14 <wespiser> i'm starting from "Write You a Scheme in 48 hours"
14:54:47 <isd> Hey all, a few days back I was talking about a module I was writing for tracking resource usage; the library is roughly working now, and is located at https://github.com/zenhack/haskell-quota
14:55:08 <isd> but I'm trying to parametrize the quota value so it works for number types besides just Int
14:55:15 <isd> and I'm hitting some problems
14:55:44 <isd> Here's the diff so far: http://lpaste.net/7044476591484698624
14:55:55 <isd> And the compile error I'm getting: http://lpaste.net/8942366530134343680
14:56:12 <ski> wespiser : in `Eval.hs', `(:)(Atom "begin") rest' could be `Atom "begin" : rest'
14:56:25 <isd> First, I feel like there needs to be a good way to do this without AllowAmbiguousTypes
14:56:35 <erisco> the report calls them bindings
14:56:37 <isd> and I'm a bit unhappy about how many language extensions I'm pulling
14:56:56 <ski> wespiser : in `LispVal.hs', `(Atom atom)' could be `Atom atom'
14:56:57 <erisco> the name of >>= is a bit unfortunate
14:57:16 <isd> But, I'm also just a bit stumped trying to get it to build
14:57:39 <wespiser> thnx ski
14:57:54 <isd> Any ideas?
14:58:05 * hackagebot wordpass 1.0.0.7 - Dictionary-based password generator  https://hackage.haskell.org/package/wordpass-1.0.0.7 (MichalGajda)
14:58:26 <jmorris_> if i do x^(-1) why do i get this error, *** Exception: Negative exponent
14:58:30 <c_wraith> isd, what is the quota type going to vary with? 
14:58:45 <isd> (also if people have general feedback on the design it would be welcome)
14:59:19 <c_wraith> isd, is it a function of the type of m, or is it independent? 
14:59:43 <ski> wespiser : `getEven [] = []; getEven (x:xs) = x : getOdd xs; getOdd [] = []; getOdd (x:xs) = getEven xs'
14:59:46 <geekosaur> jmorris_, there are 3 different exponentiation operators, each with different type constraints and restrictions
14:59:48 <isd> c_wraith: I want to be able to use anything that's an instance of both Num and Ord
14:59:53 <geekosaur> :t (^)
14:59:55 <lambdabot> (Num a, Integral b) => a -> b -> a
14:59:59 <geekosaur> :t (^^)
15:00:00 <lambdabot> (Integral b, Fractional a) => a -> b -> a
15:00:05 <geekosaur> :t (**)
15:00:06 <lambdabot> Floating a => a -> a -> a
15:00:12 <c_wraith> isd, for the exact same type m? 
15:00:27 <ski> jmorris_ : use `^^', `^' isn't defined for negative exponents
15:00:45 <jmorris_> ski: thanks that worked
15:00:51 <ski> jmorris_ : or, you could use `recip x'
15:01:02 <c_wraith> isd, what happens when someone invoices an Int and a Double in successive actions? 
15:01:15 <isd> c_wraith: no, I don't want that to be possible
15:01:39 <c_wraith> isd, then you want the invoice type to be fixed for a particular type of m? 
15:02:53 <isd> c_wraith: yes
15:03:04 <c_wraith> isd, you want a functional dependency then. 
15:03:22 <ski> wespiser : in `let1', instead of doing `env <- ask; local (const $ Map.insert atom val env) (eval expr)', you can just use `local (Map.Insert atom val) (eval expr)'
15:03:37 <isd> I will look into that, thanks.
15:03:53 <redmq> recommendation for a paper which analysises hierarchical caches?
15:04:04 <c_wraith> isd, class (Ord n, Num n, Monad m) => MonadQuota n m | m -> n where... 
15:04:23 <redmq> i'm trying to find one which compares metrics used to evaluate performance
15:05:23 <ski> wespiser : in the `let' case, i think you could do `local (Map.fromList (Prelude.zipWith ((,) . extractVar)) <>) (eval expr)' (skipping the `ask' as before)
15:05:25 <c_wraith> isd, that tells the compiler that n depends on m. it lets it infer the type of n from m, and it prevents conflicting instances 
15:06:24 <isd> c_wraith: yeah, that sounds like what I want. And it fixes the error. thanks.
15:07:00 <c_wraith> isd, you're welcome. 
15:07:13 <ski> wespiser : hm, though instead of calling both `getEven' and `getOdd' on the same list, possibly it's better to simply define `halve [] = ([],[]); halve (x:xs) = (x:zs,ys) where (ys,zs) = halve xs', and call that once on the list
15:07:30 <isd> By the way, shapr, mmaruseacph2, you had expressed interest ^
15:08:50 <wespiser> thanks ski, nice gem!
15:08:57 <ski> wespiser : reflecting more on it, i think you have the wrong syntactic format for `let'. it should be `(let ((<id> <expr>) ...) <body>)', not `(let (<id> <expr> ...) <body>)'
15:09:05 <wespiser> i do
15:09:09 <wespiser> i'm going with it for now
15:09:23 <wespiser> "letb" is the semanticly correct one
15:09:37 <wespiser> (letb (x 1 y 2) (* x y)) will work
15:10:02 * ski doesn't understand
15:10:17 <wespiser> That's how I remember Clojure doing it
15:10:30 <ski> yes, but Scheme is not Clojure :)
15:10:43 <Welkin> I thought I was in #emacs
15:10:45 <wespiser> i konw
15:11:04 <wespiser> its on a list of things somewhere, but there are bigger fish to fry atm
15:11:10 <wespiser> like writing the actual tutorial
15:11:36 <Welkin> are you writing a scheme interpreter?
15:11:39 <ski> anyway, you could possibly skip `Fun', using `Lambda' with an empty `EnvCxt'
15:11:57 <ski> Welkin : some kind of lispy thing, at least ..
15:12:20 <wespiser> Welkin, yeah, a tutorial on how to write a scheme interpreter is industrial strength Haskell !
15:12:42 <ski> hm, `return $ val' is simpler written as just `return val', imho
15:12:55 <wespiser> yea, there is still some sloppiness
15:13:03 <ski> (and `(eval ant)' as `eval ant')
15:13:05 <jmorris_> is there a standard way of representing equations like this with only one letter http://www.glicko.net/glicko/glicko2.pdf
15:13:25 <jmorris_> for example E in step 3
15:13:44 <jmorris_> what should the function be named?
15:13:46 <Welkin> what do you mean?
15:13:51 <Welkin> you can use unicode names
15:14:04 <Welkin> or just spell out the greek letter or whatever
15:14:07 <jmorris_> not the greek letters
15:14:12 <ski> wespiser : some of the things i've mentioned applies in many more cases in your source. i just don't bother to mention all similar cases :)
15:14:16 <jmorris_> the one lettered equations
15:14:24 <jmorris_> like E or g
15:14:36 * ski is more or less randomly jumping around a bit in the code
15:14:47 <Welkin> equation_E?
15:14:57 <wespiser> ski : thanks, you don't have to go through and mark every case of unneeded syntax. Its more the big picture stuff, like the "let" thing
15:15:20 <wespiser> i've used Haskell in production and had some asshole co-workeers criticize me, so I know what to look for
15:15:41 <jmorris_> Welkin: i think ill call it eq_E
15:15:45 <jmorris_> thanks
15:16:36 <erisco> give me something to @pl
15:17:37 <joncol> Can anyone explain what the E newtype in linear does? For V3 vectors for instance.
15:17:43 <isd> By the way, could I bother anyone to look at that package and give general feedback? I still consider myself a haskell beginner, would like to know if I'm doing something silly.
15:17:55 <ski> wespiser : i think `evalBody' looks strange
15:18:06 * hackagebot spatial-math 0.4.0.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.4.0.0 (GregHorn)
15:18:08 * hackagebot unix 2.7.2.1 - POSIX functionality  https://hackage.haskell.org/package/unix-2.7.2.1 (HerbertValerioRiedel)
15:19:49 <wespiser_> ski: thank you, PM me if you want to be credited in the case I use your code
15:20:00 <ski> (`evalBody' is also doing that strange combination of `ask', followed by `local' with `const')
15:21:36 <wespiser_> I can't think of another way to do scoping
15:22:33 <wespiser_> for a define, run the value, get the environment, then insert the value into that environment as the reader monad, and eval the next part of the expression
15:22:53 <mauke> isn't that what local does? what do you need the ask/const for?
15:23:03 <erisco> clumsy that to find the smallest and largest key in an IntMap you have to convert to list oO
15:23:04 <wespiser_> ask gets the EnvCtx
15:23:15 <mauke> and local doesn't?
15:23:36 <wespiser_> local sets the new EnvCtx to have the new var/value pair and run the next expression
15:23:38 <mmaruseacph2> erisco: that's my bane lately almost daily
15:23:40 <ski> wespiser_ : what is strange is that sometimes you call `evalBody' with a single form to be evaluated, sometimes with a list of forms to be evaluated
15:23:53 <wespiser_> well, it's consuming input
15:24:04 <wespiser_> evalBody is used for the begin statement
15:24:12 <erisco> at least we are not alone ♥
15:24:18 <ski> mauke : i mentioned how to fix it, in one instance of it
15:24:21 <wespiser_> the begin statement is used to wrap programs, so that define statements can be used in programs
15:24:38 <wespiser_> so it has to consume a list of S-Expressions
15:24:49 <wespiser_> but yea, there is actually an Issue out for the "begin" statement
15:24:54 <ski> `evalBody' is called both for `begin', and for `letb'
15:25:16 <wespiser_> that's in the R5RS, the body of both lambda and let functions has defines
15:25:21 <ski> in one case of `begin', it's called on a single expression. in the other case of `begin', it's called on a list
15:25:39 <soorya> /close
15:25:47 <ski> i suggest you change it so that `evalBody' takes a `[LispVal]' as input, not a `LispVal'
15:25:54 <wespiser_> (begin 1) must work, as well as (begin '(1  2 3 4))
15:26:07 <ski> i'm not disputing that
15:26:32 <mmaruseacph2> erisco: but on the other hand, it makes sense, since you still need to traverse the entire structure to find those
15:26:42 <wespiser_> so wrap the program in a List?
15:26:50 <ski> i'm not sure there's any reason for `begin' to handle the singleton case specially, though
15:27:00 <ski> also, `begin' doesn't accept `defines' inside it
15:27:21 <wespiser_> what do you mean?
15:27:27 <erisco> mmaruseacph2, not linearly though
15:27:28 <ski> wespiser_ : i'm not talking about `fileToEvalForm'
15:27:35 <wespiser_> okay
15:27:35 <erisco> mmaruseacph2, the keys are ordered
15:27:44 <ski> wespiser_ : `(begin (define a 0) a)' is not valid Scheme
15:28:10 <ski> wespiser_ : `lambda' and `let' allow `define's at the start of their bodies, `begin' doesn't
15:30:13 <ski> (clarification, it's not a valid Scheme *expression*. however, it can be used on the top-level of a source file)
15:30:41 <wespiser_> so how should I handle the evaluation of Scheme programs in a source file?
15:30:45 <ski> (because there `begin' will "splice", so `begin' means a different thing there)
15:30:48 <erisco> they have functions for working with the min and max element (according to key) but nothing to know what the keys are
15:31:25 <ski> wespiser_ : but since you're already deviating, you could decide to allow `define's in `begin', just like in `let' ..
15:31:39 <ski> wespiser_ : however, i still think `evalBody' should take a `[LispVal]' as input
15:31:39 <erisco> oh I am wrong ^.^ it is hiding with minViewWithKey and maxViewWithKey
15:31:48 <wespiser_> if you look at the first, write you a scheme, it deviates as well
15:31:53 * ski nods
15:32:10 <wespiser_> the question is how well can we demonstrate Haskell is a language ready for industry
15:32:18 <wespiser_> and capable of powerful and succint expressions
15:32:39 <ski> the point is that currently, `evalBody' is confused about what it wants to do
15:32:47 <wespiser_> yea, I agree
15:33:04 <wespiser_> it gets smoked on the "begin" function
15:33:30 <wespiser_> https://github.com/write-you-a-scheme-v2/scheme/issues/7
15:34:01 <ski> in the first `begin' case, you could call `evalBody [rest]', and in the second case, you could call `evalBody rest' (and then perhaps rename one or both of those `rest's, to avoid confusion)
15:35:33 <ski> in the `letb' case, either use `evalBody [expr]' or (better, imho), change it to accept any number of forms in the body
15:35:48 <ski> (iirc, Clojure does allow that)
15:36:16 <ski> (oh, and `lambda' also ought to allow multiple forms in the body)
15:36:55 <wespiser_> ski: awesome, thanks!
15:37:08 <ski> oh, `write' is not side-effecting ?
15:37:38 <wespiser_> its just takin the LispVal, not eval'ing it, then printing it out
15:37:46 <wespiser_> isn't that what its supposed to do?
15:37:50 <wespiser_> lol, I
15:37:55 <ski> anyway, you should be able to merge the first two cases of `evalBody' (Don't Repeat Yourself)
15:38:02 <wespiser_> right!
15:38:10 <delYsid> Typeclassopedia says: "Control.Applicative exports the WrapMonad newtype, which makes any Monad into an Applicative."  I'm confused.  Isn't any Monad already an Applicative?
15:38:59 <ski> `write' in Scheme will output a string representation of the argument (evaluated normally) to the current output port
15:39:03 <ezyang> delYsid: It didn't used to be the case 
15:39:03 <geekosaur> delYsid, in 7.10 and later, yes
15:39:20 <ezyang> Additionally, the monad instance can behave differently (read, more inefficiently) than applicative 
15:39:22 <geekosaur> in older ghc versions, not all Monad-s were necessarily Applicative-s, so that was provided as a workaround
15:40:11 <wespiser_> ski: is there a way to print the argument w/o evaulting it?
15:40:13 <delYsid> ok, so another case of "for historical reasons"
15:40:16 <wespiser_> ski: without macros?
15:41:35 <ski> wespiser_ : if you want to avoid evaluating it, then it must be a "special form", aka syntax. either primitive syntax, like your `let',`if',`lambda',`quote',&c. or user-defined syntax, iow macros
15:41:48 <wespiser_> ski: thanks1
15:44:12 <ski> wespiser_ : all your calls to `evalList' appears to ensure that you pass a `List (...)', so change it to accept a `[LispVal]' instead of a `LispVal' (then you can remove that internal error case)
15:44:30 <mmaruseacph2> erisco: the keys are ordered, but not the values
15:44:34 <ski> wespiser_ : sorry, `evalToList'
15:44:36 <mmaruseacph2> and there's no relationship between them
15:45:27 <ski> wespiser_ : though after doing that, perhaps it's easier to just use `mapM eval' directly, unless you feel the name `evalToList' adds clarity to the code
15:45:32 <erisco> the relationship is the map!
15:45:41 <wespiser_> ski: thanks!
15:45:42 <erisco> but I was looking for the min and max keys
15:46:00 <wespiser_> ski: I need to run, thank you for your effort, the coffee shop is about to close
15:46:28 <ski> wespiser_ : you seem to have a habit of using `@' in many cases where it's not needed
15:46:43 <ski> wespiser_ : ok. best of luck with it. have fun
15:46:54 <wespiser_> wait, `@ ?
15:47:00 <ski> yes, "as"-patterns
15:47:11 <ski> naming a part, and then not using that name
15:47:24 <ski> or, in `binop', matching twice on the same thing
15:47:32 <wespiser_> oh, yea, the eval function has undergone like 5 or 6 revisions, no joke
15:47:51 <ski> (also `binop' will error out if you don't have two elements .. probably not intended)
15:47:54 <wespiser_> so different things were needed at different times, thanks for the observation, i've been so used to it
15:48:02 <wespiser_> okay
15:48:41 <wespiser_> yea, binop should error out w/o two args
15:49:02 <ski> you never reach the `case' in that case
15:49:10 <ski> so you don't get to `throwError'
15:49:40 <wespiser_> oh no, I'm sorry. binop is redefined in src/Prim.hs
15:49:51 <wespiser_> I think its time to call it a day!
15:49:56 <ski> oh .. strange
15:49:58 <ski> mm
15:50:00 <wespiser_> let me delete all that
15:50:08 <wespiser_> i just transfered it to a new file
15:50:24 <wespiser_> fudge
15:51:04 <wespiser_> the idea is to try to have individual files for each chapter, or as close to that as i can get
15:51:24 <ski> for some strange reason, your `cons' also appears to work with one and zero arguments
15:51:30 <wespiser_> it works for the first 7 or so chapter
15:51:57 <ski> similarly `car' and `cdr' working on empty list is strange .. at least from a Scheme perspective
15:52:22 <ski> (also them working on zero arguments is strange)
15:52:30 <Welkin> wespiser_: literal haskell?
15:52:34 <Welkin> literate*
15:52:42 <wespiser_> no, pandoc
15:52:49 <wespiser_> and hakyll 
16:01:06 <M0b10s> anyone has a idea how to turn a big int to a smaller int (nº chars) and be able to turn it back in to the original again?
16:01:40 <Clint> M0b10s: what?
16:03:56 <geekosaur> I can think of lots of ways to do that, but which one I'd use depends on why I'm doing that
16:04:13 <geekosaur> and possibly what form it has originally
16:05:33 <Tuplanolla> How big, M0b10s?
16:05:42 <M0b10s> so you have like a 100+ chars int...
16:05:50 <Tuplanolla> That's not big.
16:06:06 <M0b10s> i'm being nice x)
16:06:10 <ertes> M0b10s: "digits"
16:06:16 <M0b10s> yes digits sry
16:06:26 <Rembane> "You call that an int? This is an int!"
16:06:45 <ertes> M0b10s: do you have the integer in decimal form?  or do you have an actual Integer?
16:06:51 <M0b10s> mathematically there is no "formula" to do this
16:06:57 <M0b10s> an integer
16:07:13 <ertes> M0b10s: then you need more information, otherwise it's impossible to compress it
16:07:29 <ertes> you need to know the distribution of the process that created it
16:10:52 <M0b10s> yes...my 1st thought was like so i divide it by 2 if it's a even number and keep on going till it's odd then if odd i'll succ that int and reset the counter and would get something like 3 4 2 122 (like (122 *2*2) *2*2*2*2)*2*2*2 but haskell returns a floating point on big ints =s
16:11:20 <ertes> M0b10s: that's called run-length encoding, and you're already making assumptions on the distribution
16:11:33 <ertes> if the integer is random, you will end up with a *bigger* one
16:11:55 <ertes> M0b10s: https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem
16:12:04 <M0b10s> that's the deal....i want to encode and get a smaller =s
16:12:36 <Tuplanolla> Too bad.
16:13:11 <ski> M0b10s : "haskell returns a floating point on big ints" -- huh ?
16:14:12 <M0b10s> 65465454/2=3.2732727e7  -- example
16:14:25 <ertes> M0b10s: those aren't integers
16:14:38 <ertes> > (65465454 :: Integer) / 2
16:14:41 <lambdabot>  error:
16:14:41 <lambdabot>      • No instance for (Fractional Integer) arising from a use of ‘/’
16:14:41 <lambdabot>      • In the expression: (65465454 :: Integer) / 2
16:14:47 <M0b10s> help me out...i'm starting here =)
16:14:58 <ertes> M0b10s: numeric literals are overloaded
16:15:14 <ertes> M0b10s: if you write "3" in source code, it has the type ((Num a) => a)
16:15:23 <ertes> the way you use it determines its actual type
16:15:28 <Tuplanolla> @let rlEncode = fmap (length &&& head) . group
16:15:30 <lambdabot>  Defined.
16:15:43 <M0b10s> easy there
16:16:26 <grantwu> M0b10s: I'm pretty sure what you're asking for is fundamentally impossible in general.
16:16:26 <Tuplanolla> > (rlEncode . factor) 18349276
16:16:29 <lambdabot>  [(2,2),(1,11),(1,101),(1,4129)]
16:16:54 <M0b10s> i could map and tried it but the result isn't has good as i wanted to
16:17:07 <M0b10s> group*
16:17:18 <ertes> M0b10s: i'm assuming you're doing this for fun…  would you like a challenge you can actually solve? =)
16:17:42 <M0b10s> it's not fun...it's for work
16:17:45 <M0b10s> x)
16:17:53 <grantwu> It's not possible!
16:18:08 <M0b10s> imagine a list of strings with multiple chars...
16:18:10 <ertes> it is possible, but only if you know more about the integers you're trying to compress
16:18:28 <M0b10s> all of them turned to one string
16:18:52 <M0b10s> then all get ord function
16:18:56 <grantwu> A list of string strings with multiple chars?
16:19:03 <grantwu> er, a list of strings with multiple chars?
16:19:04 <M0b10s> now all are 2 digit long
16:19:07 <grantwu> What does that mean
16:19:11 <ertes> M0b10s: why don't you just give us a concrete example?
16:19:25 <M0b10s> [String] -> String
16:19:45 <M0b10s> just a sec
16:20:37 <ertes> (i'm getting a feeling that this has little to do with compression, just with encodings)
16:20:55 <M0b10s> it's encoding =)
16:21:40 <M0b10s> fase1 ["#####","! 1 1","* 2 3 1 2 10","* 5 2 2 10","0 0 0 ++","1 1 1 +!!","2 2 1 +!"] returns -> "353535353533324932494232503251324932503249484232533250325032494848324832483243434932493249324333335032503249324333"
16:21:55 <M0b10s> ok that string is biger that the original
16:22:17 <M0b10s> but now i want to encode it
16:22:34 <ertes> ok, it's translating characters into their decimal unicode representation
16:22:45 <ertes> first question:  what does it return for ["z"]?
16:23:03 <M0b10s> https://thepasteb.in/p/Y6hkKqEGqQvh7
16:23:32 <M0b10s> it will be the ord "z"
16:23:41 <ertes> ok, that's not good, because you have an ambiguous encoding
16:24:24 <M0b10s> i noticed and i'm kinda stuck now x)
16:24:57 <ertes> 109123:  is that 109, 123?  or 10, 91, 23?
16:25:42 <ertes> the best way to come up with an unambiguous encoding is to make sure that you can invert it
16:26:02 <M0b10s> in my case ( all chars in the string are 2 digit long) so would be 10 91 23
16:26:48 <ski> > ord 'z'
16:26:49 <ertes> there is a guarantee that fase1 will never see a character larger than chr 99?
16:26:51 <lambdabot>  122
16:26:53 <M0b10s> ertes you have a tip on how to go that way? that's what i'm going for
16:27:06 <ertes> M0b10s: write two functions: fase1 and unfase1
16:27:06 <hpc> > ord 'd'
16:27:08 <lambdabot>  100
16:27:15 <M0b10s> yes it will never be biger than 99
16:27:23 <hpc> any lower-case letter past 'd', or {}[]~ will be > 99
16:27:46 <M0b10s> i will not get 'd' on the [String]
16:27:58 <M0b10s> it will never be biger than 99
16:27:59 <ski> how about control characters ?
16:28:12 <hpc> you should make it error if it sees those
16:28:14 <ertes> M0b10s: the overall problem is solved by identifying the size of your alphabet n, then using a base-n encoding
16:28:22 <hpc> so it's at least explicitly obvious that it's partial
16:28:22 <ski> > ord '\t'
16:28:25 <lambdabot>  9
16:28:29 <hpc> instead of just breaking invariants
16:29:06 <ertes> M0b10s: here is the encoding of four values in base 21:  5 * 21^0 + 8 * 21^1 + 19 * 21^2 + 17 * 21^3
16:29:37 <ertes> M0b10s: this encoding is unique, as long as all individual values are non-negative and smaller than n
16:30:30 <M0b10s> ertes but i will get a biger digit that the original?
16:31:02 <hpc> a bigger digit?
16:31:25 <M0b10s> total number of digits in the int
16:31:42 <M0b10s> from the original to the encode...
16:32:36 <ertes> say that you want to encode a word with 100 lower-case letters…  your alphabet is of size n = 26, and you map each letter to a value between 0 and 25
16:32:50 <ertes> > zip ['a'..'z'] [0..]
16:32:53 <lambdabot>  [('a',0),('b',1),('c',2),('d',3),('e',4),('f',5),('g',6),('h',7),('i',8),('j...
16:33:19 <ertes> the resulting value looks like:  x0 * 26^0 + x1 * 26^1 + …
16:33:21 <ertes> up to 99
16:33:30 <ertes> the resulting value is smaller than:
16:33:32 <ertes> > 26^100
16:33:35 <lambdabot>  3142930641582938830174357788501626427282669988762475256374173175398995908420...
16:33:48 <M0b10s> zip or group will do a really small encode =s
16:33:58 <ski> > length (show (26^100))
16:34:01 <lambdabot>  142
16:34:02 <ertes> > 100 * logBase 2 26  -- or this many bits
16:34:04 <lambdabot>  470.0439718141093
16:34:18 <ertes> > 100 * logBase 10 26  -- or this many decimal digits
16:34:21 <lambdabot>  141.4973347970818
16:34:22 <ertes> you get the idea
16:34:32 <M0b10s> i see
16:35:20 <M0b10s> give me some hours to test that out =) ty for all the help m8ts
16:35:44 <ertes> have fun =)
16:42:34 <BenTheNovice> I have a datatype that has many constructors, but I would like to pattern match based only on the constructor name. How can I do this?
16:42:56 <rafal1> Hello !
16:43:04 <Welkin> BenTheNovice: RecordWildCards
16:43:14 <Welkin> data A = B | C | D
16:43:24 <Welkin> match on B{}
16:43:28 <Welkin> er
16:43:43 <Welkin> data A a = B a a a | C a a | D a
16:43:46 <Welkin> match on B{}
16:43:49 <Welkin> match on C{}
16:43:50 <Welkin> etc
16:43:55 <monochrom> Yes, B{} works. Also, do not need RecordWildCards for this.
16:43:57 <BenTheNovice> Woah, that awesome
16:44:02 <BenTheNovice> *that's
16:44:12 <monochrom> > case Just undefined of Just{} -> ()
16:44:14 <lambdabot>  ()
16:44:45 <rafal1> block_data = self.data + [
16:44:47 <rafal1>             ('confirm', 'true'),
16:44:49 <rafal1>             ('ban_user', '1')
16:44:52 <BenTheNovice> @Welkin I'll go try that out
16:44:52 <lambdabot> Unknown command, try @list
16:45:36 <BenTheNovice> Welkin: I'll go try that out
16:45:39 <Welkin> lol
16:48:00 <gabluc> Today I studied making your own data types by making a recursive data structure such as a binary tree.
16:48:25 <gabluc> I'm just beginning to comprehend what a powerful tool I have in my hands.
16:48:29 <nitrix> How does one obtain an Addr# or a Ptr to pass to a foreign library?
16:48:50 <monochrom> allocate memory to obtain a Ptr.
16:49:10 <Welkin> data Stream a = ConsStream (Stream a)
16:49:12 <Welkin> like that? :D
16:49:20 <nitrix> monochrom: Marshall?
16:49:36 <monochrom> what marshall?
16:49:43 <monochrom> allocate memory to obtain a Ptr.
16:49:45 <nitrix> monochrom: https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Marshal-Alloc.html
16:49:59 <monochrom> yes
16:50:08 <nitrix> monochrom: Is this what's intended to be used in c-- okay thanks.
16:50:30 <monochrom> Nothing to do with C--.
16:50:56 <nitrix> I was just interrupting my sentence :)
16:51:03 * ski . o O ( Marshall Stone )
16:51:23 <BenTheNovice> Welkin: What is the name of this concept so I can further research it?
16:51:24 <nitrix> Is it a single L? Ah, my bad.
16:51:43 <monochrom> record syntax
16:51:43 <ski> Welkin : phantom ?
16:51:57 <geekosaur> (one reason I always use 3 ---. the other is being an old tex hack :p )
16:52:17 <BenTheNovice> Welkin: I'm trying to do something like:  match(given:rest) expected =
16:52:21 <Welkin> ski: forgot an `a`
16:53:00 <monochrom> So write match(given:rest) expected =
16:53:09 * hackagebot rattletrap 0.4.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.4.0 (fozworth)
16:53:13 <BenTheNovice> Welkin: so maybe like match(given{}:rest) expected{} =
16:53:25 <BenTheNovice> Welkin: if given{} == expected{}
16:53:33 <ski> `given' and `expected' needs to begin with upper case letters
16:53:33 <monochrom> OK that can't be done.
16:54:06 <BenTheNovice> Ski: Why is that? I was just trying to use them as generic variable names, are those keywords?
16:54:13 <ski> no
16:54:34 <ski> you can't use record update syntax in patterns. but you can use record construction syntax in patterns
16:54:56 <ski> so `match (B {} : rest) B {} = ...' would be ok
16:56:32 <ski> writing literally `given {}', that'd be syntax for extending `given', belonging to a data type with record syntax for some constructor(s), replacing zero fields of it
16:56:45 <ski> and you can't use that construction in patterns
16:57:55 <BenTheNovice> Ski: then maybe this isn't what I want to be using. I'm writing a parser for a small subset of Java. Write now I'm trying to match the datatype Token
16:57:57 <ski> (well, as an expression, it also works, even if there's no record syntax, because there's zero fields being updated in there)
16:58:22 <ski> match, how ?
16:58:42 <ski> `match (Token {} : rest) Token {} = ...' or something else ?
16:58:48 <BenTheNovice> Ski: And I only want to to see if the Token constructor name given is equal to what was expected, without checking if the other constructor values are the same
16:59:06 <BenTheNovice> Ski: Oh.... haha that's probably what I want
16:59:13 <monochrom> I do not think your envisioned match function is actually helpful.
16:59:22 <ski> how many arguments does `Token' have ?
16:59:35 <Welkin> parameters*
16:59:49 <monochrom> You may think it's pretty general, but you never need its generality.
17:00:45 <monochrom> I certainly never needed it when I parsed a simple lambda calculus or a dumb imperative language or ...
17:01:04 <BenTheNovice> Some Tokens only have (Int,Int) for the row and column they were found at by the lexer
17:01:11 <BenTheNovice> *All tokens have that
17:01:23 <BenTheNovice> Some also have a string field
17:02:12 <ski> hm. is `Token' a data constructor, or a type constructor ?
17:02:25 <BenTheNovice> ski: a data constructor
17:02:41 <monochrom> I don't trust that answer. Show actual code.
17:03:18 <BenTheNovice> monochrom: Are you talking to me?
17:03:22 <monochrom> yes
17:03:22 <ski> yes
17:03:32 <BenTheNovice> Okay
17:04:24 <isd> Are there no monad transformers corresponding to MonadGet/MonadPut?
17:05:14 <isd> Can't find them, which I find surprising.
17:05:51 <monochrom> I think people use FreeT for that (and custom-write a PutGet type)
17:07:33 <MarcelineVQ> BenTheNovice: They're asking for the data declaration for the Token you're talking about, or the link to the library you're using if you're using one to provide Token
17:08:43 <nitrix> How common is it for an Haskell game to end up being wrapped in some sort of MonadIO ?
17:09:02 <isd> monochrom: happen to know of any examples I could look at to get a feel for how that works?
17:09:22 <BenTheNovice> ski: http://pastebin.com/ZGt1vw15
17:09:29 <nitrix> I tried really hard to keep the network & renderer (impure stuff) outside the game logic, but I'm getting really stuck.
17:09:32 <monochrom> No, but maybe search for FreeT examples 
17:09:57 <ski> BenTheNovice : ok, so `Token' is a *type* constructor, not a data constructor
17:10:00 <Tuplanolla> It gets disgusting when you need to take loading times into account, nitrix.
17:10:26 <ski> BenTheNovice : `A',`B',`C' are the data constructors belonging to it
17:10:38 <BenTheNovice> ski: Oh, I will have to research the difference between data and type constructors. My apologies
17:11:06 <ski> BenTheNovice : type constructors are types. data constructors are values
17:12:45 <ski> BenTheNovice : so you *could* go `match (A {} : rest) A {} = rest' and so on ..
17:13:22 <ski> BenTheNovice : but that would only check that both are constructed using `A', it wouldn't check that the two `(Int,Int)' pairs are the same
17:13:50 <BenTheNovice> ski: I'm not trying to check the (Int,Int) pairs or anything else, only the constructor type
17:13:59 <ski> BenTheNovice : with your `x == z', it will check that all the components are also the same
17:14:02 <ski> ok
17:14:05 <BenTheNovice> ski: But I would like to be able to reference them for an error message
17:14:26 <BenTheNovice> ski: Perhaps I can use as-pattern?
17:14:39 <ski> not checking "constructor type" but "constructor tag/alternative" or just plain "constructor"
17:14:46 <ski> BenTheNovice : yes
17:15:24 <ski> (the type of the data constructor `A' is `(Int,Int) -> Token' .. that's probably not what you meant)
17:15:57 <BenTheNovice> ski: Yes, I meant the "constructor" or "constructor tag"
17:16:01 <ski> BenTheNovice : .. and those brackets wrapping the `show' calls there are redundant
17:23:11 <BenTheNovice> ski: so I attempted to use   match (x@(Token{}):y) z@(Token{}) =
17:24:07 <monochrom> Token is not a data constructor. You cannot use it in a pattern. This is again mixing up the type level with the value level.
17:24:53 <BenTheNovice> monochrom: Exactly, so I'm not sure how I can make this general
17:25:02 <monochrom> Cannot.
17:26:49 <BenTheNovice> monochrom: so is Token the type, and A, B, and C are all just values?
17:27:40 <monochrom> yes
17:30:41 <ski> BenTheNovice : you can have `match (x @ A {} : rest) z @ A {} = ...', and then similar cases for `B' and `C'
17:30:52 <BenTheNovice> monochrom: So I am trying to match only the first value
17:31:31 <BenTheNovice> ski: the problem is that there are about 70 different Token value types :b
17:31:40 <monochrom> I don't understand that sentence.
17:32:00 <monochrom> And I still maintain my prophecy that this match function will be useless.
17:32:11 <BenTheNovice> Token = T1 | T2 | T3 ... T70
17:32:14 <monochrom> Because I have experience writing simple parser exercises.
17:33:14 <BenTheNovice> The intended use is in recursive descent parsing, while reading in a list of tokens and creating an AST
17:33:48 <monochrom> Yes, I have experience using recursive descent to write simple parser exercises.
17:33:51 <BenTheNovice> I would like to be able to know the exact token that does not match.
17:35:17 <monochrom> That can still be done without the "match" function.
17:36:08 <monochrom> In fact eventually the "match" question begs more questions than answers.
17:36:50 <ab9rf> i do not understand this discussion
17:36:55 <BenTheNovice> I was using it in a previous version where I didn't keep track of (row,col) for tokens at all
17:37:18 <monochrom> The short story is that there is simply no correct value you can pass to the parameter z, even after you know which data constructor you're going for.
17:37:40 <BenTheNovice> I could say match allTokens ImportToken
17:37:59 <BenTheNovice> ** ts1 = match allTokens ImportToken
17:38:13 <BenTheNovice> ts2 = match ts1 MainClassToken
17:38:26 <ski> presumably `ImportToken' would need to be provided with some arguments ?
17:38:46 <monochrom> yes yes, ImportToken and MainClassToken are the trivial cases that makes you think it generalizes very well.
17:38:47 * ski . o O ( state effects )
17:38:48 <BenTheNovice> and so on, and let 'match' handle error( ) calls
17:39:06 <monochrom> ski: no, ImportToken stands for the fact that the keyword "import" is seen.
17:39:14 <ab9rf> i don't undertsad why you don't just wrap your existing token type with a wrapper that carries the row and column data
17:39:20 <ski> monochrom : it's not associated with a location ?
17:40:21 <monochrom> ski: As another example the string "f(x)" is tokenized as the list [IdentToken "f", OpenParenToken, IdentToken "x", CloseParenToken]. (I'm making up the tag names, but otherwise this is textbook tokenizatin.)
17:40:39 <monochrom> Oh OK yes add location info.
17:41:04 <ab9rf> data TokenPlus = TokenPlus Token FileLocation
17:41:10 <monochrom> If you add location info, the "match" function is even worse.
17:41:40 <ski> <http://pastebin.com/ZGt1vw15> seemed to include location info on every token
17:42:00 <ab9rf> ther eis no reason to shove location information intot he token ADT
17:42:01 <monochrom> because the call site is going to be "match input (ImportToken what?)"
17:42:13 * ski nods
17:42:19 <ab9rf> since it's the same for all tokens, push it out, rather than pushing it in
17:42:30 <monochrom> "match input (ImportToken (0,0))" is wrong
17:42:35 * ski . o O ( "factor it out" )
17:42:39 <monochrom> "match input (ImportToken (0,1))" is also wrong
17:42:48 <monochrom> "match input (ImportToken (undefined, undefined))" is also wrong
17:43:01 <monochrom> Nothing is right. "match" is wrong in the first place.
17:43:58 <monochrom> ab9rf: That is good and standard, but it still doesn't help the "match" function.
17:44:04 <BenTheNovice> monochrom: I had deriving(Eq) on the Token
17:44:16 <monochrom> Eq is not going to help.
17:44:24 <BenTheNovice> monochrom: Is there simply no way to only compare the first value?
17:44:42 <monochrom> There is simply no way the "match" function will be useful, even if you can write it.
17:45:13 <monochrom> You can bite the bullet and write the 70 lines required by all the limitations of Haskell.
17:45:42 <monochrom> It will not save you from the fact that, at call sites, "match input (NumToken what?)" is wrong.
17:46:02 <monochrom> "match input (NumToken 0)" is wrong
17:46:07 <monochrom> "match input (NumToken 1)" is still wrong
17:46:12 <monochrom> "match input (NumToken undefined)" is still wrong
17:46:20 <monochrom> And this is even if you have no location info
17:47:25 <Welkin> O.o
17:47:27 <Welkin> wtf is this?
17:47:28 <Welkin> https://github.com/yav/monadlib
17:47:33 <Welkin> 9 years ago?
17:47:53 <monochrom> is it on hackage?
17:48:11 <Welkin> yeah
17:48:11 <Welkin> http://hackage.haskell.org/package/monadLib
17:48:42 <sungrrl> hello
17:48:46 <monochrom> upload date was 2014
17:49:05 <ab9rf> monochrom: i don't understahd the match function that is being proposed
17:49:13 <monochrom> oh heh cabalized in 2014
17:49:15 <ab9rf> monochrom: it doesn't make sense to me
17:50:06 <monochrom> ab9rf, there are exactly two reasonable positions for this. "It makes no sense" and "I see what you're thinking but it's a bad idea"
17:51:22 <ab9rf> monochrom: i'm well-known to have a very small brain, so i'm happy falling into slot (a) above
17:52:11 <MarcelineVQ> what would be a good idea?
17:52:11 <BenTheNovice> monochrom: so how else would you suggest going about comparing these different tokens?
17:53:06 <ab9rf> i don't understand why you want to compare tokens
17:54:04 <monochrom> A good idea is to forget "match" and just go ahead write your various parser parts.
17:56:06 <monochrom> Suppose I'm tasked to write a dumb parser for a dumb lambda calculus.
17:56:32 <monochrom> The input, after tokenization, may go like this: [Lambda, Var "x", Dot, Var "x", Var "x"]
17:57:04 <BenTheNovice> I think the problem I'm having may stem from the fact that I associated the location information directly in the token
17:57:16 <monochrom> my main parser is going to go like: lambda (Lambda : rest) = lambda1 rest; lambda _ = error "boo"
17:57:57 <monochrom> lambda1 (Var v : rest) = lambda2 rest; lambda1 _ = error "boo"
17:58:15 <monochrom> lambda2 (Dot : rest) = expr rest; lambda2 _ = error "boo"
17:58:17 <monochrom> etc etc
17:58:51 <ski> `lambda2 v rest' ?
17:58:52 <monochrom> You can further nitpick me on how I lost the v, how I have poor error reporting, how I'm using error instead of Maybe/Either etc.
17:59:11 <monochrom> These issues can be fixed and you know how. I'm too lazy to do it.
17:59:34 <monochrom> But I got rid of "match" which is the biggest, unsolvable issue.
18:00:10 <monochrom> BenTheNovice: No, wrong assessment. You run into the same problem when you have NumToken 4.
18:00:32 <monochrom> Or in other words the data constructors B and C in your simpler example.
18:00:38 <BenTheNovice> There are only a handful of tokens that have an Int, or a String associated with them
18:00:51 <BenTheNovice> I already wrote match functions specifically for them
18:00:53 <monochrom> If you get rid of locations, you still have "B Int" and "C String" and they are going to bite you.
18:01:18 <BenTheNovice> it was the other 66-ish types I was trying to use with my old match function. But I think if I do what you all said
18:01:38 <BenTheNovice> and just associate the location information in a different way, then I can avoid this whole mess
18:01:56 <BenTheNovice> In the meantime, thank you so much monochrom, ski, and Welkin!
18:02:31 <BenTheNovice> I also learned the difference between a data constructor and a type constructor, I appreciate the time you've spent teaching me
18:56:42 <vijay-anant> Hi, can someone point me to a good resource(s) to understand GADTs (and how they are used) ? 
18:58:13 * hackagebot runtime-arbitrary 0.1.0.6 - Runtime generation of Arbitrary values  https://hackage.haskell.org/package/runtime-arbitrary-0.1.0.6 (chriswarbo)
19:12:30 <MarcelineVQ> vijay-anant: most of the top google links for gadts are pretty informative, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts is a really good short introduction
19:23:37 <clmg> Heya. Any alternatives to the numerals package? It won't install, I'm guessing because it hasn't been updated in a year.
19:23:58 <clmg> I need to turn "1234" into "one-thousand two-hundred four"
19:24:37 <davean> clmg: have you tried "--allow-newer"?
19:24:56 <davean> clmg: most things don't NEED to be updated except to allow newer dependancies
19:25:00 <davean> theres no reason for them to stop working
19:25:13 <clmg> that did indeed work. thanks
19:25:33 <clmg> I don't really understand cabal. it's very different from most package managers
19:25:44 <Elcrist> Hey 
19:25:45 <davean> Its not a package manager?
19:25:50 <clmg> what is it?
19:25:57 <davean> a build tool
19:26:14 <davean> and its actually rather similar in the ways you just ran into to things like apt
19:26:21 <davean> I'm not sure what package managers you're refering to actually
19:26:23 <Elcrist> I'm completely new, was just looking for some info on programs to start coding
19:27:15 <clmg> davean: gem, npm, snow, pip
19:27:37 <davean> clmg: yah, look at actual package managers like apt then
19:29:25 <clmg> davean: how do you classify pacman/apt vs npm/gem?
20:18:25 <ania123> hi
20:19:26 <ania123>  Define a function indices  that takes a list and returns list of indicies:
20:19:35 <ania123>  indices [4,5,6] = [0, 1, 2] 
20:19:42 <ania123>  indices "woof" = [0, 1, 2, 3] 
20:19:43 <ania123>  indices [] = []
20:19:51 <ania123> is the question well stated?
20:21:48 <johnw> are you asking us to write such a function for you?
20:21:52 <johnw> that sounds like a homework problem
20:24:00 <ania123> I want to give it students
20:24:12 <ania123> and I am interesting whether it is well stated
20:24:13 <ania123> :)
20:24:38 <johnw> I understand what you want from the examples, but not the English question
20:24:53 <johnw> it doesn't say how the list of indices is related to the input
20:25:38 <ania123> ok
20:25:40 <ania123> thx
20:27:39 <ania123> johnw:  Define a function 'indices' that takes a list and returns list of its elements indicies:
20:27:46 <ania123> is it correctly written?
20:30:26 <grantwu> Wouldn't this end up being a one-liner
20:30:52 <ania123> Define a function that takes a list and returns list of its elements indicies:
20:31:06 <ania123> is it written correctly in english?
20:31:43 <byorgey> I would say "Define a function that takes a list and returns the list of its indices"
20:32:00 <grantwu> indices xs = [0.. length xs - 1]
20:32:18 <grantwu> Did you intend for your students to solve it that way...?
20:32:40 <byorgey> grantwu: sure, but there are lots of different one-liners that work.  these sorts of simple one-liner exercises are good for beginning students.
20:33:03 <MarcelineVQ> grantwu: indices = zipWith const [0..] :D
20:33:03 <byorgey> Many would probably get it to work recursively, and then you can talk about library functions that exist to do stuff they have reimplemented
20:33:17 * hackagebot hailgun-simple 0.1.0.0 - Easy-to-use wrapper for the hailgun package  https://hackage.haskell.org/package/hailgun-simple-0.1.0.0 (cdepillabout)
20:33:20 <byorgey> see what I mean =)
20:33:51 <ania123> I want student to use recursion...
20:34:27 <grantwu> To be honest I would be confused by all of the previously given wordings of the question
20:34:55 <grantwu> I don't know how to better word it though
20:35:22 <MarcelineVQ> ania123: I'm assuming english isn't your first language, are these exercises for just english speakers or would these students know your language as well? You might find simpler to write in a language you know best if they know it too
20:36:49 <byorgey> indices l = evalStateT (traverse (const tick) l) (-1) where tick = modify succ >> get       -- an overengineered version just for fun
20:37:20 <MarcelineVQ> is that what they call those :>
20:43:16 <crucify_me> hi noob here trying to setup ide-haskell on atom (dialed in nicely) with stack. I'm trying to run stack exec greet-exe but get this error still after checking that executable is indeed in the first path listed. please take a look:  https://www.refheap.com/123791
20:46:32 <MarcelineVQ> what does your .cabal file look like?
20:47:07 <crucify_me> MarcelineVQ, thanks one moment
20:47:35 <ania123>  Define a function mysum that takes list of integers and returns sum of its elements:  mysum [1,2,3]= 6
20:47:49 <ania123> is it well state in english?
20:48:47 <crucify_me> MarcelineVQ, here is the cat output : https://www.refheap.com/123792
20:49:04 <MarcelineVQ> ania123: yes, but mention what should happen with mysum [] as well or students will ask about it.
20:49:14 <ania123> ok
20:49:32 <MarcelineVQ> crucify_me: ah alright, your exectuable is called greet not greet-exe
20:49:38 <ania123>  Define a function mysum that takes list of integers and returns sum of its elements: mysum [] =0 mysum [1,2,3]= 6
20:50:10 <MarcelineVQ> try `stack exec greet` or `stack build --exec greet`
20:50:39 <crucify_me> oh MarcelineVQ I thought that suffix would be appended during $ stack build. so you mean just make the project again?
20:52:27 <MarcelineVQ> the -exe suffix is just part of the default `stack new` template, the name of your executable is whatever is determined by the word after executable in your cabal file, "executable greet" in this case
20:53:37 <MarcelineVQ> *the name of your executable is determined by
20:53:51 <crucify_me> ok yeah stack exec greet did work. so when I'm naming the project should I append -exe for good practice ?
20:54:00 <crucify_me> MarcelineVQ, ^
20:54:28 <MarcelineVQ> Completely up to you :>
20:57:10 <MarcelineVQ> you'll probably want it at least a little different than your library name though, which is the word after "name:" at the top of your cabal-file. I havent' made a ton of projects so I'm not sure what's best in practice
20:57:14 <crucify_me> its just that I'm following a tutorial, the project name is helloworld with no suffix, but after $ stack setup and $ stack build the suffix is added and it is run $ stack exec helloworld-exe  MarcelineVQ . this tutorial is from the User guide. just wondering
20:58:43 <crucify_me> ok thanks a lot MarcelineVQ 
20:58:45 <MarcelineVQ> it's `stack new helloworld` that sets the executable's name to helloworld-exe
20:59:29 <MarcelineVQ> that's just what the default new project template does, appends -exe to your project name to use as the executable name
20:59:31 <crucify_me> yeah that is how I did it $ stack new greet . but that didn't work for me
21:00:31 <crucify_me> I think I used the "simple" template
21:00:57 <MarcelineVQ> it did, that's odd
21:01:37 <crucify_me> $ stack new greet simple    -   is what I did .
21:02:48 <ania123> Define a function 'delete_all' that takes an element and list, and returns a list where each occurrence of the element is removed.
21:02:49 <MarcelineVQ> Oh you did that :>
21:02:53 <ania123> is it well written?
21:03:53 <grantwu> Seems fine, but this is an application of filter, so if you wanted your students to use explicit recursion...
21:04:08 <ania123> ok
21:04:10 <ania123> thx
21:04:44 <athan> is it pretty easy to make an irc bot like lambdabot?
21:04:56 <athan> now, I mean, since lambdabot has been made :v
21:04:59 <MarcelineVQ> how much like lambdabot?
21:05:24 <jle`> well
21:05:28 <jle`> irc bots are pretty easy
21:05:29 <athan> nothing like it, just an interface into irc as a bot
21:05:38 <jle`> lambdabot functionality itself is probably not easy to implement
21:05:39 <athan> one that could just scan all lines or something
21:05:53 <athan> ahh sweet
21:06:13 <jle`> i wrote a blog post about doing one with a library i wrote a year ago but there are also a lot of simple ways to hook in
21:06:15 <MarcelineVQ> athan: https://wiki.haskell.org/Roll_your_own_IRC_bot is a great little thing to play with, you could move into irc libs after/instead
21:06:21 <jle`> irc itself is a very simple protocol
21:06:32 <athan> :O thanks MarcelineVQ!
21:06:51 <athan> I still need to learn it jle` :\ too newb
21:07:02 <MarcelineVQ> crucify_me: Are you all sorted out?
21:07:12 <jle`> athan: there are a lot of libraries on ackage that abstract over it pretty well :)
21:07:27 <athan> sweet :-)
21:09:04 <crucify_me> MarcelineVQ, thanks so much. not really . now $ stack test returns nothing in that project.
21:10:56 <MarcelineVQ> if it's the same project you defined with simple it won't have a test-suite defined, I'd remake it without 'simple' or with 'new-template' best to follow tutortials exactly the first time
21:11:24 <crucify_me> oh that is logical thanks a lot. more drama later
21:11:32 <MarcelineVQ> I assume you're doing this one or a version of it https://docs.haskellstack.org/en/stable/GUIDE/#hello-world-example
21:12:16 <crucify_me> MarcelineVQ,   yeah its this page https://docs.haskellstack.org/en/stable/GUIDE/
21:12:54 <crucify_me> I picked up the idea for 'simple' somewhere else 
21:14:07 <crucify_me> but MarcelineVQ if I write something in atom, how do I add it to a project ? I've used ruby on rails but this seems different.
21:16:53 <MarcelineVQ> A basic stack project will create a Lib.hs file and an App.hs file you can play in to get started but you'll want to learn about Modules, which are a part of haskell, wherever you're learning haskell from will cover them
21:17:46 <crucify_me> oh so just add code to the App.hs file for now ?
21:19:52 <MarcelineVQ> You can, or open `stack ghci` and use that to learn with since most teaching material will start with that
21:21:19 <crucify_me> very sorry MarcelineVQ I cannot find the App.hs file . only Main.hs which has the helloworld
21:21:38 <MarcelineVQ> that's my mistake, it is Main.hs
21:22:04 <crucify_me> excellent thanks kindly MarcelineVQ 
21:22:43 <ajp> is there template haskell somewhere to derive GEq instances?
21:23:00 <ajp> I think I remember seeing something in the docs but now I can't find it
21:38:19 * hackagebot debian 3.91.2 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.91.2 (DavidFox)
22:04:38 <bollu> where did "monad" come from
22:04:38 <bollu> the name?
22:04:43 <bollu> is it from philosphy?
22:06:13 <jmorris_> https://en.wikipedia.org/wiki/Monad_(functional_programming)#History
22:06:45 <bollu> so there is no overlap from the philosophy "monad"?
22:07:11 <jmorris_> I'm not the one to ask, that's just what i found
22:07:46 <geekosaur> no overlap, no
22:08:29 <geekosaur> there was a discussion about this several years back, I don't think we reached a conclusion about where CT got the name but the philosophical one is pretty unrelated
22:09:00 <bollu> I see. so there was no motivation to name it based on the philosophy idea, right?
22:09:09 <bollu> (I'm arguing with a friend about the origin :P)
22:09:27 <jle`> you picked a weird fight
22:09:33 <geekosaur> suspicion is that it's derived from monoid
22:09:35 <bollu> jle`: :)
22:09:55 <bollu> geekosaur: yes me too! "monoid of endofunctors" ~> "monad" sounds plausible
22:10:24 <jle`> they were originally called triples right
22:11:15 <jle`> oh they were originally called "standard construction"
22:11:17 <jle`> what a great name
22:11:33 <bollu> xD
22:11:42 <jle`> "The notion of monad was invented by Roger Godement in 1958 under the name "standard construction." In the 1960s and 1970s, many people used the name "triple." The now standard term "monad" is due to Saunders Mac Lane."
22:11:53 <jle`> ^ the mathematical monad
22:12:02 <bollu> I see, thanks :)
22:12:27 <jle`> from https://en.wikipedia.org/wiki/Monad_(category_theory) , but i can't find a citation on the last sentence
22:13:47 <geekosaur> right, that was where the old discussion I'm remembering fell apart; nobody could find anything saying why Saunders Mac Lane picked it
22:14:23 <bollu> what's an interesting monad to model in operational?
22:15:30 <bollu> wait, can I encode *any* machine using operational?
22:15:32 <bollu> say, SECD?
22:15:40 <bollu> what about g-machine? :O
22:21:33 <geekosaur> so fwiw it looks like he introduced it in _Category Theory for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be understood to imply a sort of cross between "monoid" and "triad"
22:23:01 <geekosaur> (p 138 at www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
22:23:08 <geekosaur> er. thanks google
22:23:14 <geekosaur> (p 138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
22:24:57 <jle`> cute
22:25:12 <bollu> heh, neat :)
22:25:28 <jle`> i wonder what a "working mathematician" is
22:25:36 <bollu> how do you save that using @quote?
22:25:36 <bollu> that'd be nice to have a stable refrence 
22:25:36 <bollu> in lambdabo
22:25:41 <bollu> lambdabot*
22:25:49 <jle`> lambdabo is my cousin
22:26:30 <jle`> @help quote
22:26:30 <lambdabot> quote <nick>: Quote <nick> or a random person if no nick is given
22:26:38 <jle`> @help addquote
22:26:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:26:49 <geekosaur> @help remember
22:26:49 <lambdabot> remember <nick> <quote>: Remember that <nick> said <quote>.
22:27:34 <bollu> @remember geekosaur so fwiw it looks like he introduced it in _Category Theory for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be understood to imply a sort of cross between "monoid" and "triad". (p 138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
22:27:34 <lambdabot> Done.
22:28:23 <geekosaur> guh. _Categories for the Working Mathematician_
22:28:42 <geekosaur> what I get for trying to pull it from memory while looking at the text without the title on screen :/
22:29:33 <geekosaur> anyway that book would have been from the time when most mathematicians still considered CT to be weird and esoteric and unrelated to "real" math
22:31:52 * geekosaur wonders if he's allowed to @remember himself in order to fix that
22:32:19 <geekosaur> @help forget
22:32:19 <lambdabot> forget nick quote.  Delete a quote
22:32:30 <geekosaur> @remember geekosaur wibble
22:32:30 <lambdabot> Good to know.
22:32:32 <geekosaur> ok, yes
22:32:40 <geekosaur> @forget geekosaur wibble
22:32:40 <lambdabot> Done.
22:32:52 <geekosaur> @forget geekosaur so fwiw it looks like he introduced it in _Category Theory for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be understood to imply a sort of cross between "monoid" and "triad". (p 138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
22:32:52 <lambdabot> Done.
22:33:18 <geekosaur> @remember geekosaur so fwiw it looks like [Mac Lane] introduced it in _Categories for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be understood to imply a sort of cross between "monoid" and "triad". (p.138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
22:33:18 <lambdabot> It is forever etched in my memory.
22:33:53 <mauke> rewriting history, eh
22:34:14 <ab9rf> history was made to be rewritten
22:34:14 <geekosaur> lambdabot isn't pure :p
22:34:43 <geekosaur> but, what really annoyed me was "he" instead of specifying Mac Lane
22:35:29 <geekosaur> since I wasn;t exactly expecting to turn into a reference there :)
22:40:04 <geekosaur> probably the real place to put that info is on wikipedia in place of the referenceless claim
22:40:36 <geekosaur> although the monoid/triad part would probably get flagged :)
22:41:36 <bollu> geekosaur: why?
22:42:15 <geekosaur> if you put it in without "perhaps can be understood" it gets flagged for not providing a reference to it. if you do include it, someone will flag it [weasel words]
22:43:06 <geekosaur> depending on how "just the facts, ma'am" whoever's editing it is feeling
22:44:47 <monochrom> put it in, use the citation http://www.vex.net/~trebla/humour/lmcify.html?t=monad+comes+from+%22monoid%22+and+%22triad%22
22:58:22 * hackagebot jsaddle 0.6.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.6.0.0 (HamishMackenzie)
23:03:22 * hackagebot jsaddle-warp 0.6.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-warp-0.6.0.0 (HamishMackenzie)
23:08:23 * hackagebot jsaddle-wkwebview 0.6.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-wkwebview-0.6.0.0 (HamishMackenzie)
23:11:41 <haskell256> I have some issues designing my program errors. Right now, I'm using ExceptT with a different error type per module. I was wondering if there was a better way
23:14:43 <haskell256> For example, a function from Module A will returns "Except ErrorModuleA a", and another function from module B will returns "Except ErrorModuleB a". This kinda put some boilerplate when I want to chain them.
23:26:13 <jle`> it's a bit of a boilerplate, yes
23:26:34 <jle`> you can wrap it up/abstract it away in a nice way
23:28:23 * hackagebot jsaddle-dom 0.6.0.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.6.0.0 (HamishMackenzie)
23:30:09 <haskell256> could you provide some example? I'm not sure that I see how
23:32:21 <jle`> haskell256: make a unifying error type that encompasses all errors or is the one you want to write your final program in
23:32:39 <jle`> then write a combinator errA :: Except ErrorModuleA a -> Except BigError a
23:32:49 <jle`> errB :: Except ErrorModuleB a -> Except BigError a
23:33:15 <Rotaerk> I kind of like this approach:  if you have a function a -> b, and you need to add a failure case, change it to:  (x -> e) -> a -> Either e b
23:33:37 <Rotaerk> where x is the details describing the error
23:33:52 <Rotaerk> gives the caller the control over what the error type is
23:34:16 <Rotaerk> you can even extend that with multiple kinds of errors:  (x1 -> e) -> (x2 -> e) -> a -> Either e b
23:35:50 <Rotaerk> now if you have one function that can fail for reasons X1 and X2 (and thus a type data E = X1 | X2 might make sense), and another function that can fail for reasons X2 and X3 (for which type E2 = X2 | X3 might make sense), with this approach, you have the ability to unify all your error types after the fact...
23:37:24 <Rotaerk> I just never liked the idea of having a function return a hard-coded Error type that was defined as the union of all possible errors, when the function itself may only fail for a subset of them
23:38:19 <Rotaerk> nor is it fun to build an error type *per* function that contains *only* the failures that function can have
23:38:49 <haskell256> It's a compiler, so if like my type checking module fail, I want the user to get the message and then stop right there
23:39:57 <haskell256> I like your idea though
