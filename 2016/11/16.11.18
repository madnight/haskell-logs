00:07:05 <roberth> Hafydd, EvanR: the point is really exploring practical functional programming. No exploitation in this case because they will be implementing some sort of 'hello world' project
00:11:49 <roberth> pikajude: the plan is to (re)implement parts of https://github.com/microservices-demo/microservices-demo
00:12:16 <roberth> in a 'shiny' functional programming language
00:13:16 <pikajude> if haskell is shiny, javascript must be an O-type supergiant
00:13:24 * hackagebot stable-marriage 0.1.2.0 - algorithms around stable marriage  https://hackage.haskell.org/package/stable-marriage-0.1.2.0 (KatsutoshiItoh)
00:14:05 <roberth> good point. shininess is probably not an actual requirement
00:16:15 <voltz> Ok so, I started playing around with monad stack transformers
00:16:35 <voltz> seeing lift $ lift $ lift etc seems very non-haskell to me 
00:16:58 <Axman6> where are you seeing lift used more than once?
00:17:09 <voltz> maybe I'm using it wrong
00:17:12 <Axman6> usually you'd use type classes
00:17:28 <Axman6> like, MonadIO provides liftIO :: MonadIO m => IO a -> m a
00:17:36 <voltz> hmm....
00:17:47 <Axman6> what are you lifting?
00:19:45 <voltz> I'm not even sure I'm using this write, just sort of playing around, had a stateT readerT writerT IO, couldn't figure out how to get the writerT working 
00:19:57 <voltz> write...
00:20:00 <voltz> what is wrong with me
00:20:02 <Axman6> this is where mtl comes in
00:20:15 <voltz> What is mtl?
00:20:18 <ogkloo> iirc iterate usually works if you're typing lift $ lift $ lift...
00:20:23 <voltz> monad transformer lenses?
00:20:25 <ogkloo> could be wrong though
00:21:02 <Axman6> it provides the classes for monad transformers, like MonadState, MonadIO, MonadWriter
00:21:21 <Axman6> ogkloo: all those lifts will have a different type, so that can't work
00:21:45 <wespiser> I'm using (ReaderT Env (ExceptT ErrorType IO Mytype)), is there a better way to handle errors?
00:21:49 <Axman6> :t get
00:21:50 <lambdabot> MonadState s m => m s
00:22:00 <voltz> is there some set order for the monad stack?
00:22:02 <wespiser> i'm trying to figure out monadTHrow, but there are like 6 different packages
00:22:04 <voltz> or a common order:
00:22:09 <wespiser> for exceptions, that is
00:23:54 <Axman6> voltz: the idea with mtl is that you don't write for a specific monad, you write functions with the class constraints you need: foo :: (Monadstate MyState m, MonadReader MyConfig m, MonadWriter MyLogging m,MonadIO m) => m Foo, instead of StateT MyState (ReaderT MyConfig (WriterT MyLogging IO Foo)))
00:24:33 <Axman6> (you can use ConstraintKinds to give that big constraint a name, like: type MyAppConstraints m = (Monadstate MyState m, MonadReader MyConfig m,(WriterT MyLogging IO Foo)))
00:24:39 <Axman6> uh
00:25:26 <Axman6> (you can use ConstraintKinds to give that big constraint a name, like: type MyAppConstraints m =  (Monadstate MyState m, MonadReader MyConfig m,MonadWriter MyLogging m,MonadIO m), and then use MyAppConstraints m => m Foo
00:25:28 <voltz> is there some paper on this? 
00:25:46 <ogkloo> Axman6: ah that makes sense. Thanks.
00:25:57 <voltz> I'm just starting with Monad stacks 
00:26:14 <Axman6> according to the MTL docs, the paper is: http://web.cecs.pdx.edu/~mpj/pubs/springschool.html
00:26:35 <Axman6> docs for mtl are at https://hackage.haskell.org/package/mtl
00:37:38 <wespiser> I'm running a Lisp interpreter with an mtl stack using ExceptT MyError IO a antipatter, is Control.Exception is suitable alternative?
00:38:36 <wespiser> I need a safe way to handle my limited IO activity, reading library files
00:41:46 <EvanR> wespiser: i like dialog monads
00:42:22 <wespiser> https://hackage.haskell.org/package/dialog-0.3.0.0/docs/Dialog.html
00:42:23 <wespiser> ?
00:42:43 <EvanR> thats a bit more concrete
00:42:55 <wespiser> i'm a little bit confused
00:43:11 <wespiser> This needs to be cleared up, super confusing
00:43:24 <EvanR> another way to describe this is coroutines
00:43:40 <EvanR> and finally they are all (by definition) kinds of a free monad
00:44:13 <wespiser> free monads are the "f Fix f" forms?
00:44:49 <EvanR> lets concentrate on what a dialog looks like
00:44:57 <wespiser> alright
00:46:03 <wespiser> we start with the "DialogT m a" data type
00:46:12 <EvanR> ignore that package
00:46:20 <wespiser> okay
00:47:20 <EvanR> runDialog :: Dialog a -> Either (Request, Response -> Dialog a) a
00:48:18 <EvanR> so it either completes with some answer, or it is stuck asking a questionand waiting for the response
00:48:25 <EvanR> you can only continue by providing a response
00:48:34 <wespiser> right
00:48:48 <EvanR> but its up to you, as the driver, how to do that
00:49:03 <EvanR> now you dont have to be stuck with standard IO behavior
00:49:05 <Guest86433> is there anyway for me to access the element of an array with this type? [(Int,Int)]
00:49:14 <wespiser> the input Dialog a results in Either "a", or "(Request, Respose -> Dialog a)"
00:49:48 <wespiser> How are we avoiding standard IO? we still must wait for a response?
00:49:58 <EvanR> theres no IO involved necessarily
00:50:26 <wespiser> okay
00:50:31 <EvanR> but you can choose to make that one of the requests
00:50:36 <pavonia> EvanR: Shouldn't Request be part of the input?
00:50:37 <Guest86433> find2D '4' ["4---","3-4-","--24","2-3-"]  [(0,0),(1,2),(2,3)] i need to check to see if that array contain the same given value
00:50:51 <EvanR> what are you calling input here?
00:51:31 <pavonia> I imagine the function too look somehting like runDialog :: Dialog a -> Request -> Either (Response -> Dialog a) a
00:51:43 <EvanR> wespiser: since IO itself is abstract, picking IO leaves you with the option of either ignoring it or actually executing it
00:52:15 <EvanR> pavonia: er, then you as the driver is making a request somehow, thats not what i was intending. the program itself may make a request
00:52:25 <wespiser> EvanR: I see, depending on the "Dialog a", we have the choice of action
00:53:03 <wespiser> EvanR, or rather, the program computes the action based on dialog a
00:53:17 <EvanR> Dialog a is the program
00:53:41 <EvanR> complete with whatever starting environment you gave it
00:53:43 <wespiser> EvanR: I'm beginning to see, when I pick IO, I could just as well pick a program error
00:53:54 <pavonia> Guest86433: What would be the result of that function call? (And again, it's not an array, it's a list)
00:54:49 <EvanR> wespiser: this doesnt explain how youd do errors
00:54:53 <Guest86433> the find2D function is a provided function when I give it an array and a value it will return the row col of that value
00:54:57 <EvanR> its a regular non transformer monad
00:55:21 <wespiser> EvanR: yes, but wouldn't the same concept apply if you worked with "lift" ?
00:55:45 <wespiser> this is what I'm trying to understand better
00:55:52 <EvanR> you could transformerize this thing, but until you do, lift doesnt apply
00:56:08 <wespiser> yes
00:56:27 <EvanR> to do "could fail" with this witout transformers, itd be, Dialog (Either Error a)
00:56:32 <Guest86433> it would return something like [(row,col),(row,col)....]
00:56:56 <pavonia> Guest86433: So what are you looking or then?
00:57:30 <wespiser> EvanR, why wouldn't it be Either (Dialog a) Error ?
00:57:34 <EvanR> no
00:58:14 <wespiser> @unmtl DialogT (Either Error a)
00:58:14 <lambdabot> DialogT (Either Error a)
00:58:29 <EvanR> do you mean something like DialogT (Either Error) a
00:58:29 <Guest86433> so i need to use that output to check to see if any of those row or col is the same as mine row or col
00:58:35 <wespiser> @unmtl Either (DialogT Error a)
00:58:36 <lambdabot> Either (DialogT Error a)
00:58:44 <EvanR> its not defined
00:58:50 <EvanR> its not mtl
00:59:14 <EvanR> i avoided talking about how to transformerize this because as it stands Request and Response arent very polymorphic, so its not compelling as a library 
00:59:28 <wespiser> is Either :: * -> * -> * ?
00:59:29 <Guest86433> it will return true as long as row or col matches
00:59:32 <EvanR> fixing that is another topic
00:59:46 <wespiser> EvanR: I see
01:00:23 <EvanR> wespiser: Either Error (Dialog a) is just literally an error or a valid dialog program, it wouldnt help you express failure inside a dialog
01:00:55 <wespiser> EvanR: okay, not very helpful when you are in the business of running Dialog!
01:01:39 <EvanR> whereas Dialog (Either Error a) would either a) get stuck waiting b) error out or c) give the final succcessful value
01:02:00 <EvanR> wwhen you run it
01:02:11 <wespiser> yea, that would make sense, and error could be handled within the Dialog context
01:02:43 <wespiser> and a (Request, Response -> Dialog a) could be retured?
01:03:19 <EvanR> in this first approximation, pretty much, a (Request, Response -> Dialog (Either Error a))
01:05:33 <wespiser> okay, would it make sense to make "a" into "IO a" ?
01:05:39 <EvanR> nope
01:05:42 <wespiser> to say, read from a file?
01:05:44 <wespiser> okay
01:06:16 <EvanR> you could have data Request = ... | ReadFile FilePath | ... 
01:06:44 <EvanR> to enable ... | ExecIO (IO a) | ... we need to fix the polymorphism
01:07:34 <wespiser> okay, I sort of have an error/exception problem right now
01:08:53 <wespiser> thanks for walking me through that, I want to write a guide on error handling in Haskell. Its a mess right now.
01:09:32 <wespiser> I think the problem is the mtl examples use ExceptT w/ IO, but the best practices advice is to avoid that
01:09:38 <EvanR> yeah especially when exception transformer of the week comes out and declares itself to be the most recommended
01:10:00 <EvanR> theres a blog post that makes ExceptT the best practices 
01:10:07 <EvanR> pretty slick
01:10:43 <wespiser> this is what I've found: https://github.com/write-you-a-scheme-v2/scheme/blob/master/docs/04_errors.md#alternative-exceptions
01:10:47 <wespiser> its a mess
01:11:38 <EvanR> for specifically doing errors during evaluating a lisp, i would just do Either
01:11:57 <wespiser> yea, I'm gunning to make an argument for Either or ExceptT
01:12:02 <EvanR> but if you are expecting heavy IO usage, and you used a transformer over IO, just throw IO exceptions
01:12:07 <wespiser> in the Lisp evaluator situation
01:12:23 <wespiser> yea, use ReasourT w/ monadThrow monadCatcth
01:12:36 <EvanR> ExceptT lets you catch inside the transformed monad
01:12:43 <EvanR> is that what youre trying to do
01:13:19 <wespiser> yea, 3 error types,parser, IO, and evaluation, something like 90% are from evaluation, and like 7% are from parsing
01:13:33 <EvanR> parser errors seems unrelated
01:13:48 <EvanR> that error would happen long before you get to the evaluation process
01:13:54 <wespiser> the go into the Eval monad 
01:14:06 <wespiser> which wraps the message they display
01:14:57 <EvanR> doesnt need to be complected with evaluation
01:15:10 <EvanR> evaluation happens on a completed program, not text
01:15:31 <wespiser> correct
01:16:03 <EvanR> so evaluation would have dynamic errors or IO errors
01:16:08 <wespiser> https://github.com/write-you-a-scheme-v2/scheme/blob/master/src/Eval.hs#L45
01:16:24 <wespiser> basically the parser returns "either ParserError AST"
01:17:16 <wespiser> and the accepting function is "either (throwError $ ParserError . show) eval $ textToAST inputText"
01:18:10 <wespiser> I'm satisfied with dynamic errors, its the IO errors i don't like
01:18:23 <EvanR> comes with the territory
01:18:36 <EvanR> if youre doing IO you have to accept IO exceptions
01:18:46 <wespiser> i check if the file exists, if not throw, if so, read. Plenty of room for unchecked errors
01:19:02 <EvanR> checking for existence and then reading doesnt really help
01:19:13 <EvanR> it could disappear in the meantime, might as well just read
01:19:40 <wespiser> its a static library, it *should* never move
01:19:57 <wespiser> its like the configuration settings
01:20:04 <EvanR> even if it doesnt, that doesnt mean you wont get an error
01:20:15 <wespiser> what about using "catchAny"?
01:20:46 <EvanR> you can catch IO exceptions and try to convert them to a local value if you want
01:20:55 <EvanR> a local error type
01:21:15 <wespiser> https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
01:21:28 <EvanR> catch literally all exceptions is not a good idea
01:21:37 <wespiser> why not?
01:21:56 <EvanR> because you want bugs to crash instead of hang or loop
01:22:02 <wespiser> If you were getting paid to do this, and were working on the project for the next year, what would you do?
01:22:03 <EvanR> so you can fix them
01:22:16 <EvanR> whats the goal?
01:22:35 <wespiser> demonstrate "good" industry haskell
01:23:10 <wespiser> ie, no tricky type theory, keep things simple, show off powerful abstractions but keep it readable
01:23:20 <EvanR> the simplest possible thing that will work ;) for some value of work
01:23:48 <EvanR> luckily in haskell, stupid tricks end up not actually working very much and youre encouraged to do it right
01:24:09 <wespiser> yea, and they are very hard to read
01:24:37 <EvanR> well im talking about catching weird kinds of exceptions, youre talking about using super advanced haskell
01:25:07 <wespiser> yea, the question, is what is the best way to catch exceptions when reading a static file
01:25:18 <EvanR> specifically catch IO exceptions
01:26:01 <wespiser> my current solution is the "ExceptT IO" antipattern
01:26:26 <EvanR> well... you can still do it despite the presence of ExceptT
01:26:38 <wespiser> with Either, i could
01:26:56 <EvanR> either way, IO Exceptions are a separate thing from "pure exceptions"
01:27:12 <EvanR> Control.Exception
01:27:15 <wespiser> yea, that's the tricky thing I'm trying to understnad
01:27:20 <gaqwas> good morning
01:27:59 <wespiser> can I used Control.Exception to catch IO exceptions thrown from pure IO ?
01:28:09 <EvanR> pure IO ?
01:28:29 <Axman6> yes, that's what Control.Exception is all about
01:28:42 <wespiser> does it work with mtl transformer stacks?
01:28:50 <EvanR> you can catch any kind of Exception you want, but some are not recommended, like calls to error or undefined
01:29:10 <Axman6> you can do things like: liftIO $ try (readFile foo) :: MyMonad (Either IOException String)
01:29:14 <wespiser> yea, they should go through
01:29:21 <wespiser> my system doesn't need to stay up
01:38:27 * hackagebot classy-prelude 1.0.1 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-1.0.1 (MichaelSnoyman)
01:38:29 * hackagebot classy-prelude-conduit 1.0.1 - classy-prelude together with conduit functions  https://hackage.haskell.org/package/classy-prelude-conduit-1.0.1 (MichaelSnoyman)
01:38:31 * hackagebot classy-prelude-yesod 1.0.1 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-1.0.1 (MichaelSnoyman)
02:02:45 <runeks> How can I make a class for types that have their type name available as a String? I would think the following should work, but it doesn't
02:02:52 <runeks> https://www.irccloud.com/pastebin/F5Vs5Z0s/
02:13:48 <EvanR> runeks: the name as a string is already available through Typeable
02:14:01 <EvanR> or Data.Data one of them
02:14:30 <EvanR> > show (typeOf (3 :: Int))
02:14:32 <lambdabot>  "Int"
02:15:40 <EvanR> or, what is wrong with what you wrote
02:16:09 <lieven> runeks: and otherwise, since you have an argument of type a available, why make one with undefined?
02:23:20 <runeks> Thank you all. "show . typeOf" is just what I needed
02:38:19 <ongy> > show $ typeOf 3
02:38:21 <lambdabot>  "Integer"
02:38:36 <ongy> > show . typeOf $ fromIntegral 3
02:38:38 <lambdabot>  "Integer"
02:39:01 <EvanR> in defaulting we trust
02:39:43 <EvanR> > (show . typeOf . read) "hmm"
02:39:45 <ongy> > show . typeOf $ fromIntegral
02:39:46 <lambdabot>  error:
02:39:46 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
02:39:46 <lambdabot>      • In the first argument of ‘(.)’, namely ‘typeOf’
02:39:47 <lambdabot>  "Integer -> Integer"
02:39:54 <ongy> very useful
02:40:52 <EvanR> > typeOf (undefined :: Int)
02:40:55 <lambdabot>  Int
02:42:23 <sbrg> :t typeOf
02:42:25 <lambdabot> Typeable a => a -> TypeRep
02:42:27 <sbrg> ah yeah
02:43:09 <EvanR> the best dynamically typed language
02:43:10 <ongy> > typeOf typeOf
02:43:12 <lambdabot>  error:
02:43:12 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
02:43:12 <lambdabot>      • In the expression: typeOf typeOf
02:43:30 <sbrg> > typeOf (+)
02:43:30 <EvanR> its not going to default for Typeable
02:43:32 <lambdabot>  Integer -> Integer -> Integer
02:43:35 <sbrg> huh
02:43:45 <sbrg> > typeOf ((+) :: Num a => a -> a -> a)
02:43:46 <lambdabot>  Integer -> Integer -> Integer
02:43:51 <EvanR> > typeOf (typeOf `asAppliedTo` (3 :: Int))
02:43:53 <lambdabot>  Int -> TypeRep
02:44:14 <EvanR> > typeOf id
02:44:15 <lambdabot>  error:
02:44:16 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
02:44:16 <lambdabot>      • In the expression: typeOf id
02:44:22 <EvanR> it doesnt work for polymorphic things
02:44:34 <sbrg> understandable
02:45:47 <EvanR> we have Typeable imported but not Dynamic :(
02:46:14 <bollu> how do I write haskell code in a .lhs file that should not be compiled?
02:47:09 <EvanR> https://wiki.haskell.org/Literate_programming#Hiding_code_from_Haskell
02:47:42 <sbrg> that reminds me. I need to look into that. writing solutions to exercises as long-ass comments for exercises that aren't about writing code isn't quite optimal
02:48:23 <bollu> EvanR: thanks, lemme check it out
02:49:58 <wilornel__> Hey guys! are there tools to help you manage the version of ghc? Im looking to use Cairo to render some 2D animations. Cairo rquires the glade package. glade requires 
02:50:04 <wilornel__> glib, but ghc 7.10
02:50:20 <sbrg> wilornel__: yes, stack does that for you, if I understand you correctly
02:50:31 <wilornel__> .3 wont compile it. ghc 7.8 will compile it, as I can see online
02:50:42 <wilornel__> alright! getting stack! :) 
02:50:43 <sbrg> stack allows you to specify the version of the compiler you need to build the project and will fetch it and install it locally(inside your project)
02:50:56 <EvanR> cairo doesnt require glade
02:51:00 <wilornel__> now I need to get rid of cabal and everything related
02:51:09 <EvanR> but the haskell bindings are tied up intimately with the gtk universe somehow
02:51:19 <EvanR> which.... sucks
02:51:33 <sbrg> wilornel__: no need. you actually need a .cabal file as well. stack still uses cabal(-the-library)
02:51:44 <wilornel__> good! 
02:52:37 <sbrg> wilornel__: the easiest way to get that running would be to see if there isn't a snapshot on stackage that includes cairo. if there is, then that should mean that it can be built properly, against the other packages in the snapshot, etc. 
02:57:17 <MarcelineVQ> if you really need 7.8 the oldest stack lts (snapshot) for ghc 7.8 is called lts-2.22 when you get to that point. cairo is on the latest lts though so I'm not convinced you need older ghc
02:58:54 <bollu> EvanR: app/Main.lhs line 251: unlit: spurious \end{code}
02:59:01 <bollu> EvanR: I tried adding the % comment at the end
02:59:06 <bollu> doesn't seem to work
02:59:23 <EvanR> should it be at the beginning
02:59:30 <EvanR> \begin{code} % hoho!
02:59:30 <sbrg> i think it's supposed to be at the \begin{code}
02:59:33 <sbrg> yeah
02:59:50 <bollu> I mean
03:00:07 <bollu> \begin{code} % ignore
03:00:07 <bollu> info :: Parser a -> InfoMod a -> ParserInfo a
03:00:07 <bollu> \end{code}
03:00:10 <bollu> that's what I did
03:00:11 <EvanR> that lhs info on the wiki could also be insanely out of date
03:00:12 <wilornel__> hmmm there's no apt-get package for stack
03:00:13 <bollu> it errors out
03:01:05 <bollu> so what's the right solution?
03:01:30 <EvanR> try... # ?
03:01:36 <lieven> wilornel__: haskell-stack is in sid
03:02:02 <wilornel__> ah, yes! thanks
03:02:34 <bollu> EvanR: what do you mean?
03:02:40 <EvanR> % -> #
03:02:51 <EvanR> just a random experiment
03:02:57 <bollu> EvanR:  nope :(
03:03:03 <EvanR> bollocks
03:03:53 <lieven> bollu: and the \begin{spec} \end{spec} suggestion?
03:04:34 <ongy> :t (#)
03:04:36 <lambdabot> error: parse error on input ‘)’
03:05:03 <bollu> lieven: it doesn't render, 
03:07:39 <bollu> I'm using pandoc for rendering
03:09:18 <bollu> soo
03:09:23 <bollu> any solutions to lhs?
03:10:27 <sbrg> pandoc from lhs to tex? 
03:10:40 <sbrg> maybe you can use something else like verbatim or other similar latex envs
03:17:02 <wilornel__> hmmm so I now have stack and I can run `stack ghc` if I need
03:17:12 <wilornel__> so `ghc` and `stack ghc` are two different ghc
03:18:26 <wilornel__> I cannot import module 'Graphics.UI.Gtk'
03:18:41 <wilornel__> with cabal I tried installing it before I had stack
03:18:50 <wilornel__> stack can't find `gtk` of `gtk2hs-buildtools`
03:28:07 <damian_> hello guys..... is there any way to include packages with stack/cabal from github (as I want to use this particular commit from git as a dependency) instead of using releaseses?
03:28:15 <damian_> this is to test a possible fix to an issue
03:28:36 <lyxia> bollu: use markdown code blocks
03:28:40 <sbrg> damian_: https://docs.haskellstack.org/en/stable/yaml_configuration/
03:28:46 <sbrg> scroll down a bit
03:29:11 <damian_> sbrg: amazing... thank you very much
03:29:13 <hvr> damian_: with cabal you can simply add it as a git submodule
03:29:19 <sbrg> yw
03:29:41 <hvr> damian_: and point e.g. http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html to the folder as a local package
03:29:44 <bollu> lyxia: yes, I realised :) I'm doing that now
03:29:50 <bollu> lyxia: ### doesn't work though
03:29:55 <wilornel__> I did `stack upgrade --git` 
03:30:06 <lyxia> bollu: what doesnt?
03:30:12 <wilornel__> (still running, but it should but from 0.1 to 1.*)
03:30:21 <hvr> damian_: you can have any local modifications to a package that way in your project
03:31:14 <hvr> damian_: i.e. doens't even have to be committed to git
03:32:38 <damian_> hvr: thanks for that... very usefulll.... althought it's already commited to git, so I will try to use sbrg approach and if not I will try to use it as you describe
03:32:39 <kuribas> what's the difference between existential quantification and rank-N types?
03:32:39 <damian_> many thanks
03:32:51 <lyxia> bollu: I personally use RST, so code that should be compiled goes under "\begin{code}", and code that shouldn't goes under ".. code:: haskell". Pandoc Markdown has "```haskell" blocks as an alternative.
03:36:06 <kuribas> > let f :: (forall a. a -> a) -> (Int, String) ; f x = (f 2, f "2") in f id
03:36:08 <lambdabot>  error:
03:36:08 <lambdabot>      • Couldn't match expected type ‘Int’
03:36:08 <lambdabot>                    with actual type ‘(Int, String)’
03:36:53 <kuribas> > let f :: (forall a. a -> a) -> (Int, String) ; f g = (g 2, g "2") in f id
03:36:55 <lambdabot>  (2,"2")
03:38:10 <athan> Can djinn solve Rank2Types?
03:39:00 <athan> @djinn f :: (forall a. a -> z) -> (b, c) -> (z, z)
03:39:00 <lambdabot> Cannot parse command
03:39:22 <kuribas> are they solvable?
03:39:23 <athan> @djinn (forall a. a -> z) -> (b, c) -> (z, z)
03:39:24 <lambdabot> -- f cannot be realized.
03:39:54 <kuribas> @djinn (forall a. a -> a) -> (a, b)
03:39:54 <lambdabot> -- f cannot be realized.
03:40:00 <athan> rank2 I "know" is inferrable, although I feel like terms should be decidable like rank 1
03:51:10 <IngoB> Hi there. A quick question on a Haskell exercise I'm doing. Trying to build own version of enumFromTo, using a recursive go function accumulates into the list. However, since I have to go forward (from element definitely in, to element not, at least if one generalises to a then step), cons-ing makes a reverse list to : to -1 : .. : from+1 : from : []. I can reverse the whole thing at the end, but I'm wondering if I am missing some tri
03:52:24 <kuribas> IngoB: you don't need to reverse the list
03:53:16 <IngoB> kuribas: because?
03:53:28 <kuribas> because you can build it in order?
03:53:56 <IngoB> kuribas: how? cons adds to head, not tail
03:55:08 <kuribas> Are you using an accumulator?  Don't use an accumulator.
03:55:32 <kuribas> > enumFromTo 1 10
03:55:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:55:38 <lyxia> instead of   go acc (K x) = ... go (y : acc) z ; go acc _ = reverse acc   you can write   go (K x) = ... y : go z ; go _ = []
03:56:13 <IngoB> kuribas: uhh, yeah, I know that I can *use* enumFromTo. The exercise is however to build your own version of enumFromTo. 
03:56:14 <liste> IngoB: you can use difference lists to append to a list efficiently http://stackoverflow.com/q/13879260/1283954
03:56:40 <kuribas> IngoB: also using an accumulator wouldn't support lazyness, which you need to implement enumFromTo
03:57:50 <kuribas> > let enumFrom i = i : enumFrom (i+1) in enumFrom 20
03:57:53 <lambdabot>  [20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,...
03:58:00 <kuribas> IngoB: ^^
03:58:14 <kuribas> IngoB: Now implement a stop condition, and there you go!
03:58:45 <IngoB> liste & kuribas: thanks
04:00:03 <kuribas> IngoB: head (enumFrom n m) should be O(1), not O(m-n).
04:01:45 <IngoB> kuribas: I don't know what that means. if i means operation count, then your statement makes no sense to me
04:02:11 <wilornel__> hm... I thought `stack upgrade --git` would upgrade my version of stack. I still get "Version 0.1.10.0 x86_64"
04:03:02 <sbrg> wilornel__: it did. but it's installed in ~/.local/bin
04:03:04 <bollu> for a non-deterministic *polynomial* turing machine, if the input is n, can I create n! branches that take O(1) time?
04:03:06 <MarcelineVQ> wilornel__: make sure you don't have stack in two places for some reason
04:03:06 <wilornel__> I see people resorving the issue with "Invalid package ID: "array-0.5.1.1" with
04:03:08 <wilornel__> oh! let's see
04:03:10 <sbrg> you need to add that to your $PATH
04:03:13 <kuribas> IngoB: do you understand lazyness?
04:03:15 <MarcelineVQ> ah there we go
04:03:19 <wilornel__> I did `whereis stack` and only saw one installation
04:03:44 <kuribas> > head [1..] -- Ingo: this works
04:03:47 <lambdabot>  1
04:03:47 <sbrg> wilornel__: if you installed stack via your package manager, you can safely remove it via the package manager after adding ~/.local/bin to your $PATH, and just use stack to manage itself
04:04:00 <kuribas> > head $ reverse $ reverse [1..] -- Ingo: this doesn't
04:04:05 <wilornel__> woot! It works! :)
04:04:08 <lambdabot>  mueval: ExitFailure 1
04:04:12 <IngoB> kuribas: yes. OK, I didn't see the "head" there
04:05:13 <wilornel__> MarcelineVQ, sbrg: Thanks!
04:06:08 <wilornel__> I read Learn You a Haskell for Great Good! 
04:06:29 <wilornel__> I feel like this is an intro book, because now, when I look at any documentation I always see concepts or tools that have not been convered in that book
04:06:30 <kuribas> IngoB: In general, don't use an accumulator in haskell, unless you want it to be strict!
04:06:34 <bollu> for a non-deterministic *polynomial* turing machine, if the input is n, can I create n! branches that take O(1) time? as in, can the amount of branching be more than polynomial in the input?
04:06:40 <wilornel__> What should I read next?
04:06:44 <MarcelineVQ> wilornel__: awesome, check out https://github.com/bitemyapp/learnhaskell next if you like
04:07:51 <lyxia> bollu: what's a branch
04:07:58 <bollu> lyxia: like, a choice
04:09:53 <kuribas> Why does HashMap evaluate keys to WHNF?  Doesn't hashing require HNF?
04:11:30 <lyxia> bollu: at every step you can make a choice. There is a polynomial number of steps in any execution. So the "tree of executions" is a tree of depth P(n) and with bounded arity. This is 2^O(P(n)).
04:13:18 <bollu> lyxia: right
04:13:25 <lyxia> I mean, its size (number of choices, or number of leaves)
04:13:31 <bollu> lyxia: hm, interesting
04:13:37 <bollu> lyxia: so that's exponential then?
04:13:43 <bollu> I can branch exponentially?
04:13:54 <lyxia> yeah
04:14:18 <bollu> interesting, as long as the height is polynomial, it works out.
04:14:20 <bollu> thanks :)
04:16:49 <wilornel__> thanks MarcelineVQ 
04:17:10 <IngoB> kuribas: OK. I'm using a guard to catch the "To" case ... is there anything more efficient? Also, I seem to need three entries (<: succ to next element, ==: include element and stop recursion, > : empty list and stop recursion) so that I can have max max -> [max] but max smaller-than-max -> []. Works but seems a bit complicated. (If I have something with finite range and succ on the max I get an exception, that's why I seem to need th
04:17:37 <kuribas> IngoB: paste the code?
04:17:50 <kuribas> IngoB: http://lpaste.net/
04:18:27 <squall> im reading "monadic combinators for "putback" style bidirectional programing", trying to get to grips with the lens framework. i was wondering if anyone could help me digest or sumarise the main aspects of lenses (sorry its a common question)
04:19:01 <squall> https://pdfs.semanticscholar.org/4dad/ed563c43e8e8d7362f5d0f96a7c425b11f4b.pdf
04:19:13 <squall> (let me know if tyhat link is broken)
04:19:38 <IngoB> kuribas: http://lpaste.net/342526  (it's for Boolean there, as the simplest limited case...)
04:20:36 <kuribas> IngoB: that looks fine
04:21:16 <kuribas> @src enumFromTo
04:21:16 <lambdabot> Source not found. Maybe you made a typo?
04:21:26 <kuribas> :t enumFromTo
04:21:28 <lambdabot> Enum a => a -> a -> [a]
04:21:41 <kuribas> lambdabot: I didn't
04:22:02 <IngoB> kuribas: lol
04:22:05 <lyxia> squall: isn't that what the introduction does
04:22:55 <squall> kuribas, i think you need the instance defined for list
04:23:41 <squall> *Int
04:23:45 <squall> sorry, its early here
04:24:40 <liste> squall: lenses can peek into a single part of a compound data structure, and return a modified part of that structure by replacing that part
04:24:46 <kuribas> @src Data.List.enumFromTo
04:24:47 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
04:25:08 <liste> squall: s/modified part of that structure/modified structure"
04:25:15 <kuribas> lambdabot: @#&¼@% - bot
04:25:15 <lambdabot> Unknown command, try @list
04:27:00 <kuribas> lambdabot: @src GHC.Enum.EnumFromTo
04:27:00 <lambdabot> Source not found.
04:27:06 <kuribas> Maybe it's an internal function
04:28:08 <squall> @let eftInt f t =if (f /= t) then f : (eftInt (f+1) t) else [t]
04:28:10 <lambdabot>  Defined.
04:28:25 <squall> > eftInt 2 7
04:28:28 <lambdabot>  [2,3,4,5,6,7]
04:28:38 <wilornel__> mappend Sum 3 Sum 5 tries to evaluate `Sum 3 Sum 5` first? 
04:29:43 <kuribas> > eftInt 8 2
04:29:47 <lambdabot>  [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33...
04:29:48 <IngoB> kuribas: I guess here: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Enum.html#enumFromTo though that definition doesn't exactly enlighten me
04:29:54 <squall> kuribas: maybe you could define it using succ, idk why Enum is different to Ord...
04:30:31 <ski> wilornel__ : presumably tou meant `mappend (Sum 3) (Sum 5)' ?
04:30:33 <squall> > [8..2]
04:30:37 <lambdabot>  []
04:30:45 <ski> s/tou/you/
04:31:02 <kuribas> IngoB: it seems enumFromTo is defined in terms of list enum syntax, rather than the opposite way.
04:31:58 <squall> liste: that sounds like what i think of as a modifier... i suppose the magic is making them composable...
04:32:04 <ski> kuribas : in the report, or in the implementation ?
04:32:10 <kuribas> ski: implementation
04:32:24 <wilornel__> ski: Ah, yes!
04:32:55 <ski> wilornel__ : `mappend Sum 3 Sum 5' would parse as `(((mappend Sum) 3) Sum) 5'
04:32:59 <kuribas> ski: I guess I'd better say "implemented" in terms of...
04:33:05 <IngoB> kuribas: I don't know how to search hoogle for .. or [ .. ] or some such 
04:33:14 <squall> is it worth looking into arrows as composable modifiers before diving into lenses? is it possible that arrows might actually provide enough functionality, so then i should ask why the fasion has shifted away from arrows to lenses
04:33:16 <ski> wilornel__ : iow, "curriedly", pass four separate arguments to `mappend'
04:33:19 <kuribas> IngoB: it's syntax
04:33:34 * hackagebot rawstring-qm 0.2.3.0 - Simple raw string quotation and dictionary interpolation  https://hackage.haskell.org/package/rawstring-qm-0.2.3.0 (tolysz)
04:33:37 <liste> squall: I don't think it's really magic, it's pretty straightforward to compose (b -> a, a -> b -> b) and (c -> b, b -> c -> c)
04:33:47 <lyxia> squall: arrows as in Control.Arrow? arr makes them not bidirectional.
04:34:12 <ski> `arr' is the main problem of `Arrow', yes
04:34:29 <ski> also the products being in the class is arguable
04:34:30 <squall> im confuesd
04:34:57 <IngoB> kuribas: meaning ultimately this is not defined in Haskell, but mapped to some machine code operation?
04:35:28 <ski> IngoB : iirc, in the report, `[a .. b]' is specified in terms of `enumFromTo'
04:35:35 <kuribas> IngoB: meaning it's not a function or operator you can hoogle.
04:35:53 <squall> ski, its just syntactic sugar i think
04:36:03 <IngoB> ski: this is getting a bit circular then?
04:36:09 <kuribas> IngoB: It's defined in the haskell report
04:36:35 <ski> IngoB : in such case, `enumFromTo' wouldn't be specified in terms of `[a .. b]'
04:37:01 <kuribas> ski: does it matter, since they're equivalent?
04:37:11 <ski> IngoB : an implementation is free to implement it in another way, as long as it behaves "as if" it followed the definition in the report/standard
04:39:34 <squall> am i right in thinking that the difference between Ord and Enum is that Enum requires the specification of a mapping from Int, while Ord does not
04:40:25 <ski> `Ord' also allows dense ordering (e.g. `Rational')
04:40:35 <IngoB> well, when all is said and done I just wanted to know whether this http://lpaste.net/342526 is the most efficient implementation on a bounded range (here for Bool, which is obviously a bit silly as an example). it does not look like we are getting an answer for that from the Haskell documentation, right?
04:41:19 <squall> I guess Enum is kind of a subsection of Num, which requires fromIntegral is provided
04:41:48 <squall> i wonder why Enum is not a superclass of Num...
04:41:57 <kuribas> squall: Enum isn't Num
04:42:06 <squall> i didnt say it was
04:42:08 <kuribas> > True + False
04:42:10 <lambdabot>  error:
04:42:11 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘+’
04:42:11 <lambdabot>      • In the expression: True + False
04:42:16 <ski> i don't think `Enum' makes much sense on e.g. `Complex Rational'
04:42:19 <hpc> there's lots of numbers that can't be enumerated
04:42:21 <hpc> like that
04:42:25 <squall> what are you talking about!?
04:42:39 <hpc> strictly speaking, floating point numbers can't be enumerated
04:42:50 <squall> i mean that Num implicitly requires Enum as a superclass
04:42:54 <hpc> the distance between elements isn't the same
04:43:16 <kuribas> squall: Ord and Enum are have different functions.  Ord is for comparison, Enum for conversion to a Int.
04:43:19 <ski> squall : no, `Complex Rational' is in `Num', but wouldn't make sense to be in `Enum', imho
04:43:47 <squall> in that Num requires fromIntegral, as does Enum require toEnum
04:43:55 <squall> :t fromInegral
04:43:57 <lambdabot> error:
04:43:57 <lambdabot>     • Variable not in scope: fromInegral
04:43:57 <lambdabot>     • Perhaps you meant ‘fromIntegral’ (imported from Prelude)
04:44:05 <squall> :t fromIntegral
04:44:07 <lambdabot> (Num b, Integral a) => a -> b
04:44:11 <squall> :t toEnum
04:44:13 <lambdabot> Enum a => Int -> a
04:44:14 <EvanR> squall: the key being fromEnum
04:44:21 <EvanR> not all Nums have toInteger
04:44:26 <squall> aha ok
04:45:07 <IngoB> squall: you cannot define pred and succ for floating point, there is not a specific "previous/next number" on the real number line
04:45:13 <ski> > range (0,3)
04:45:15 <lambdabot>  [0,1,2,3]
04:45:17 <ski> > range ((0,0),(1,3))
04:45:19 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3)]
04:45:29 * ski stirs the pot a bit
04:45:34 <EvanR> theres not a sane next number for floats, but there sort of it for non infinite non nan
04:46:13 <hpc> EvanR: what's the sane next number for non-inf and non-nan?
04:46:22 <EvanR> theres not one
04:46:33 <hpc> you just said there sort of is
04:46:33 <EvanR> but you can still define it as incrementing the mantissa
04:46:39 <hpc> oh, i see
04:46:58 <IngoB> actually, I guess since float and double are finite precision, one could Enum them in theory... 
04:47:00 <EvanR> im glad they didnt though
04:47:10 <EvanR> IngoB: on 32-bit... it wouldnt work for Double
04:47:12 <hpc> that makes it impossible to define enumFromThenTo
04:47:13 <wilornel__> Ach, `stack install cairo` does this: http://paste.ubuntu.com/23495298/ and it seems like it's a bug 
04:47:14 <ski> > succ 10e30 == 10e30
04:47:17 <lambdabot>  True
04:47:19 <kuribas> hpc: The smallest representable number larger than this one?
04:48:15 <EvanR> morally Double is supposed to be a "continuous type"
04:48:29 <EvanR> so enumming doesnt make sense
04:48:45 <kuribas> EvanR: wouldn't that be an arbitrary precision float?
04:48:58 <EvanR> it wouldnt be any more continuous if it were
04:49:06 <MarcelineVQ> wilornel__: do it a few more times and see if it gets farther each time, I had an issue like that once as well iirc
04:49:09 <hpc> Enum documents that for numeric types the increment is always 1
04:49:20 <hpc> the default increment, when you aren't EnumFromThen*-ing
04:49:35 <IngoB> EvanR: I don't see what the number of bits has to do with it, as long as it's a finite representation. I'm not saying it's a bright idea to Enum finite precision floating points, just that it could be done
04:49:45 <MarcelineVQ> wilornel__: try a `stack update` first as well possibly
04:49:50 <wilornel__> lol :P
04:49:54 <wilornel__> Alright, trying that update
04:49:58 <EvanR> IngoB: the idea with Enum is the mapping is reversible, which cant work if theres more Doubles than Int
04:50:13 <EvanR> its just an artifact of choosing Int for the basis of Enum class
04:50:30 <IngoB> EvanR: there are not more Doubles than Ints
04:50:30 <hpc> IngoB: the problem is that Double/Float don't have a linear mapping between elements and the values they map to
04:50:35 <EvanR> IngoB: on 32-bit there are
04:50:40 <MarcelineVQ> you shouldn't need it so it probably won't help, allthough `stack setup` may if your cabal version is somehow off
04:50:48 <hpc> IngoB: stepping between the nearest discrete values of Double could increment by 0.1 or 10,000
04:50:54 <EvanR> thats another problem
04:51:04 <EvanR> specified step size doesnt make sense
04:51:24 <hpc> IngoB: currently the step size is 1.0, but at a certain point in the float/double ranges x + 1.0 = x
04:51:31 <IngoB> hoc: no, you would step by the smaller eps that satisfies f+eps>f for f fixed precision floating point
04:51:34 <kuribas> EvanR: I don't think Double is supposed to be continuous.
04:51:39 <EvanR> but the classic use of Enums is to represent them with Ints
04:52:05 <kuribas> EvanR: More like having enough precision.  But that can still be dangerous with subtraction etc...
04:52:15 <EvanR> kuribas: "continuous type" isnt even a real concept... so i wouldnt expect it to really be. but the docs for random informally refer to as such and i think its ok
04:52:19 <hpc> IngoB: floating point isn't fixed precision
04:52:56 <hpc> unless you mean let the increment change depending on the value, which breaks the expectation of relationship between enumFromTo and enumFromThenTo
04:53:09 <EvanR> kuribas: it explains why were having these issues
04:53:11 <kuribas> EvanR: IMO that's a dangerous way to approach floating point.
04:53:29 <IngoB> hpc: true, that indeed means that there is not well-defined smallest step - fair enough
04:53:41 <EvanR> how is it dangerous when "continuous" doesnt even have a meaning here ;)
04:54:02 <EvanR> it implies nothing, as usual, floats have no laws
04:54:06 <EvanR> except commutativitiy
04:54:16 <kuribas> EvanR: Being able to reason about floating is important for numerical application.
04:54:42 <hpc> do floats have commutativity?
04:54:48 <EvanR> yeah
04:55:04 <kuribas> EvanR: They have laws, but they're different from mathematical real numbers.
04:55:06 <IngoB> hpc: though arguably you could still do succ f = f + eps, where eps is the smallest floating point for which f+eps>f is true - it's just that your step size eps is not universal
04:55:38 <EvanR> kuribas: agreed, identifying something as real numbers carries a lot of baggage to check
04:56:15 <EvanR> none the less people treat floats as something similar, square roots, trig, zeta function etc
04:57:38 <EvanR> IngoB: that is why i was pointing out, but given the enumFromThenTo that doesnt even help
04:57:51 <EvanR> re: incrementing mantissas
04:58:40 <kuribas> EvanR: They do, but it's an approximation that falls appart when doing complicated numerical work that requires precision.
04:59:21 <kuribas> Numerical computing is a whole study on it's own.
04:59:28 <IngoB> one can define "proper" arbitrary precision floating point with continuous fractions, in which case numerics becomes asymptotically correct - unfortunately, that's too slow for most purposes
05:00:00 <EvanR> arbitrary precision floats is something different from exact reals
05:00:04 <kuribas> IngoB: It would be a good use for haskell lazyness :)
05:00:15 <EvanR> for example 1/3 is still not representable with arbitrary precision floats (in base 2)
05:00:57 <IngoB> EvanR: 1/3 is exactly representable in continuous fractions (basically, it becomes a list with two Integer elements)
05:01:05 <EvanR> well, i havent seen a lazy implementation yet which does transcendentals
05:01:25 <EvanR> any all lazy implementations i found are exponentially slow for simple things
05:01:36 <EvanR> IngoB: yeah thats not "floating point"
05:02:08 <IngoB> kuribas: there is an incomplete continuous fractions lib in Haskell already
05:02:11 <EvanR> i.e. x*b^k
05:03:28 <EvanR> the best performing exact reals ive seen recompute the answer entirely from scratch when asked for precision N
05:03:42 <EvanR> using fast cauchy series
05:03:50 <IngoB> EvanR: well, if you define "floating point" to be "the sort of thing that is Float and Double", then you are right, but that's trivial. if you mean by floating point that you try to capture real numbers on the computer, then I would say continuous fractions are that
05:04:21 <kuribas> IngoB: IMO Double has enough precision for the majority of calculations, but it requires care for avoiding catastrophic cancelation.
05:04:54 <EvanR> IngoB: floating point, as opposed to fixed point, specifically refers to a class of number types characterized by a moving "decimal" point that depends on the scale in question
05:05:42 <EvanR> exact reals go further and dont use that representation
05:06:42 <EvanR> theres signed digits, continued fractions, irrational bases, cauchy sequences, mobius transformations, ... 
05:08:04 <EvanR> thats all i know
05:09:28 <ocramz> hullo!
05:10:31 <ongy> Hello ocramz!
05:26:27 <wilornel__>  MarcelineVQ  It does not seem to help
05:26:34 <wilornel__> both methods
05:26:57 <MarcelineVQ> what resolver are you using?
05:27:58 <wilornel__> 2016-11-18 05:27:22.178779: [debug] Using resolver: lts-7.9 from implicit global project's config file: /home/kevin/.stack/global-project/stack.yaml
05:28:21 <wilornel__> ah, we want 7.8 for this one, right?
05:28:59 <wilornel__> hmmm it does not get listed here: "option --resolver: Invalid resolver value: 7.8. Possible valid values include lts-2.12, nightly-YYYY-MM-DD, ghc-7.10.2, and ghcjs-0.1.0_ghc-7.10.2. See https://www.stackage.org/snapshots for a complete list"
05:30:32 <wilornel__> woot! It's building the lts-7.8 build plan now
05:30:35 <wilornel__> no it failed!
05:30:52 <MarcelineVQ> it depends a bit, if you're thinking of ghc 7.8 it's just coincidence that that current resolver is close in number, ghc 7.8 is lts-2.22, resolver lts-7.8 is ghc 8.0.1
05:31:11 <wilornel__> huh
05:31:43 <wilornel__> trying it!
05:31:54 <MarcelineVQ> something else is amiss though, I was able to stack install cairo with lts 7.8 and 7.9
05:32:14 <wilornel__> To install the correct GHC into /home/kevin/.stack/programs/x86_64-linux/, try running "stack setup" or use the "--install-ghc" flag.
05:32:41 <wilornel__> `stack upgrade --resolver lts-7.8 --install-ghc` it says I am already at the latest version
05:32:46 <wilornel__> oh wait, let me move that flag over
05:33:02 <MarcelineVQ> upgrade is for stack iself, you want setup
05:33:15 <MarcelineVQ> it would be `stack setup --resolver lts-2.22` to install ghc 7.8.4
05:33:47 <wilornel__> oh, I messed up my command
05:33:50 <MarcelineVQ> if you wanted that one, I'm not suggesting you do, just showing how you would
05:33:52 <wilornel__> I wanted to install cairo with that flag
05:34:02 <wilornel__> I don't know if I want that one :o 
05:34:08 <wilornel__> alright, paused the install
05:34:11 <wilornel__> why would I not want it?
05:34:42 <wilornel__> `stack install -v cairo --resolver lts-2.22 --install-ghc`
05:34:58 <joe9> any experiences with this: https://github.com/RazvanRanca/GenericPretty . I am looking for a generic pretty printer that can print to text.
05:36:26 <NickHu> @djinn (a -> b -> b) -> b -> [a] -> b
05:36:26 <lambdabot> Error: Undefined type []
05:36:45 <NickHu> Is there no way to make Djinn understand lists?
05:41:49 <kuribas> EvanR: If you are interested in the laws for floating point numbers, you should read Volume 2 of "The art of computer programming".
05:42:46 <kuribas> @djinn (a -> b -> b) -> b -> list a -> b
05:42:46 <lambdabot> f _ a _ = a
05:43:24 <kuribas> That's anticlimactic
05:44:09 <NickHu> lol
05:44:43 <hodapp> :P
05:45:17 <hodapp> I suppose one could devise something more complex, like only applying the initial function if the list is non-empty
05:46:21 <kuribas> @djinn (a -> b -> b) -> list a -> b
05:46:21 <lambdabot> -- f cannot be realized.
05:47:14 <NickHu> kuribas: Makes sense, foldr1 isn't total
05:48:37 * hackagebot BlogLiterately 0.8.4.2 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.4.2 (BrentYorgey)
05:48:47 <hodapp> @djinn (a -> b -> b) -> a -> list a -> b
05:48:47 <lambdabot> -- f cannot be realized.
05:48:59 <hodapp> @djinn (a -> b -> b) -> a -> list a -> b -> b
05:48:59 <lambdabot> f a b _ c = a b c
05:49:11 <quchen> NickHu: Djinn cannot deal with recursive data types
05:49:29 <NickHu> I see
05:49:44 <quchen> It can deal with Maybe, which has a couple of elements less
05:49:52 <NickHu> I just saw on this page: http://lambda-the-ultimate.org/node/1178 it seems to be doing fine with lists
05:49:55 <quchen> ?djinn (a -> b -> b) -> b -> Maybe a -> b
05:49:55 <lambdabot> f a b c =
05:49:55 <lambdabot>     case c of
05:49:55 <lambdabot>     Nothing -> b
05:49:55 <lambdabot>     Just d -> a d b
05:50:11 <ski> (it can't deal with higher-rank either, otherwise you could try to simulate them that way)
05:50:34 <ski> @where floating-point
05:50:35 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
05:50:35 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
05:53:37 <Myrl-saki> quchen: That's pretty cool.
05:58:04 <kuribas> ski: Numerical Methods by Richard Hamming also has a lot of information on Floating Point
05:58:27 <kuribas> ski: it's cheap (but dead tree)
05:58:29 <ertes> > 0.03 - 0.02 - 0.01 == 0
05:58:31 <lambdabot>  False
05:58:37 * hackagebot Lazy-Pbkdf2 2.1.1 - Lazy PBKDF2 generator.  https://hackage.haskell.org/package/Lazy-Pbkdf2-2.1.1 (Ofenhed)
05:59:36 <ski> kuribas : ok
05:59:57 <kuribas> ski: I still prefer books (for anything in-depth).
06:00:54 <Tuplanolla> Then there's this guy, if you're looking for frustration: https://www.cs.berkeley.edu/~wkahan/
06:02:00 <ski> kuribas : usually ditto
06:02:12 <ski> ah, Kahan :)
06:02:45 <carter> It's a very example driven book. But yeah
06:03:17 <kuribas> lol: “No virgin need be found and sacrificed to the gorgon who guards the gate to level seventeen;  she will go catatonic if offered exactly  $13.875.”
06:03:34 <carter> There's some crazy stuff I wanna do to make floats in haskell super nice while still technically ieee compliment
06:03:37 <carter> Compliant.
06:04:14 <carter> Namely work out signaling nan rts support and turning sigfpe into exceptions :)
06:08:37 <kuribas> carter: that'd be nice
06:09:23 <carter> kuribas: I'll be doing a bunch of stuff once I take some time off.  After week one or two of vacay
06:11:36 <kuribas> carter: wouldn't it break compliance with the report?
06:11:52 <carter> Nope
06:12:07 <kuribas> ah, great!
06:12:10 <carter> That could be an rts flag
06:12:46 <carter> There's some ways to also make rounding mode kinda static too
06:13:04 <carter> At least with hardware that supooorts avx
06:13:20 <carter> Ish
06:13:35 <carter> kuribas: hit me up in a few days :)
06:13:38 * hackagebot async 2.1.1 - Run IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/async-2.1.1 (SimonMarlow)
06:13:42 <kuribas> ok :)
06:16:27 <ertes> carter: without giving up performance?
06:16:50 <carter> ertes: depends. 
06:17:02 <carter> There's some approaches I need to investigate
06:17:39 <carter> Cause that ultimately depends on a few details
06:18:10 <carter> Roughly: for quiet nans and avx512 yes you can. More generally not sure
06:19:34 <kuribas> carter: and performance the same with the rts flag off?
06:19:59 <ertes> carter: as long as it doesn't cost performance, i'm all for it =)
06:20:20 <carter> Kuribas ... why would signaling nans be slower. Circuits are circuitry
06:20:44 <carter> Should only be slow when it's throwing an exception. Or I'll have fucked up :)
06:20:55 <kuribas> sounds good :)
06:20:57 <ertes> wow, you need a membership to read the IEEE 754 standard…  and nothing guarantees that after signup you don't have to pay anyway
06:21:12 <carter> Ertes I have the PDF
06:21:16 <carter> Google is your friend
06:21:25 <carter> 2008 one is all over the web
06:21:56 <ertes> yeah, sure, but why does one have to rely on unofficial sources?  that's stupid
06:22:04 <carter> Signaling floats dodge a lot of the gross bits of ieee that in retrospect are dumb
06:22:13 <carter> Ertes patch the ieee
06:22:23 <carter> Otherwise grousing is lame
06:22:24 <carter> :)
06:22:40 <ertes> hehe
06:22:42 <Tuplanolla> Nothing prevents a scientific journal from charging one billion dollars per paper either.
06:22:57 <ertes> i don't think anyone is going to pay me for that =)
06:23:16 <drninjabatman> is there a way to do `Rep1 a b -> Rep1 a b'`?
06:23:30 <ertes> Tuplanolla: papers are different…  i don't mind when people charge for their work
06:23:46 <Tuplanolla> I do.
06:23:52 <drninjabatman> since in `Rep1 a b`, the b part seems to be phantom
06:24:38 <carter> Fun fact : there's no rounding error in reading or writing floating point if you just write your numbers in base 16 notation.
06:25:36 <ertes> carter: except that base 16 notation for floating point numbers isn't supported by most languages
06:25:45 <ertes> > 0x0.F
06:25:45 <kuribas> ertes: you mean the authors actually receive money?
06:25:47 <lambdabot>  error:
06:25:47 <lambdabot>      Data constructor not in scope: F :: a -> b0
06:26:25 <jchia_3> TH question: What's the difference between a varT and a conT? I'm trying to implement a th :: Name -> Q [Dec] using [d|...|]. When spliced, th makes a function whose name is 'do' followed by the argument to th.
06:26:30 <ertes> kuribas: i would hope so…  even musicians receive a tiny fraction of the income =)
06:26:31 <lyxia> drninjabatman: why do you want that
06:27:44 <drninjabatman> lyxia: http://stackoverflow.com/questions/40641141/ghc-generics-for-default-methods-of-sum-types (I am the OP)
06:27:47 <kuribas> > (0 + (0xF000 `shift` (-16))) :: Double
06:27:47 <lyxia> drninjabatman: are you talking about GHC generics
06:27:49 <lambdabot>  error:
06:27:49 <lambdabot>      • No instance for (Bits Double) arising from a use of ‘shift’
06:27:49 <lambdabot>      • In the second argument of ‘(+)’, namely ‘(61440 `shift` (- 16))’
06:27:55 <drninjabatman> lyxia yes
06:28:18 <kuribas> > (0 + (0xF000 / 2^(-16))) :: Double
06:28:21 <lambdabot>  *Exception: Negative exponent
06:28:24 <Tuplanolla> My point was that you can claim that a standard or paper is publicly available, but charge an indefinitely large amount of money for it to make it effectively unobtainable, ertes and kuribas.
06:28:42 <Tuplanolla> Is the existence of such a publication then even worth acknowledging?
06:28:47 <kuribas> > (0 + (0xF000 / 2**(-16))) :: Double
06:28:49 <lambdabot>  4.02653184e9
06:29:09 <lyxia> drninjabatman: a is not phantom in Rep1 f a
06:30:20 <Polymorphism> haskell community is the best
06:30:26 <Polymorphism> and no OOP? 
06:30:28 <Polymorphism> I like the sound of this
06:33:04 <lyxia> drninjabatman: this looks like a recursion-scheme thing by the way
06:34:49 <drninjabatman> lyxia: I just found out about recursion-schemes about an hour ago 
06:35:52 <kuribas> let base16 m e = realToFrac m * (2**realToFrac e); base16 :: Integer -> Int -> Double in base16 0xF000 (-16)
06:36:08 <kuribas> > let base16 m e = realToFrac m * (2**realToFrac e); base16 :: Integer -> Int -> Double in base16 0xF000 (-16)
06:36:10 <lambdabot>  0.9375
06:36:46 <drninjabatman> New workflow for solving related type related problms in haskell: fight GHC >> google >> search Ed's github account
06:37:20 <drninjabatman> if it's hard, Kmett has tried it
06:39:34 <Rembane> :D
06:40:01 <kuribas> drninjabatman: And there's a solution in lens
06:40:55 <lyxia> drninjabatman: it seems quite tricky to do with GHC.Generics
06:42:23 <lyxia> Because you need to find the fields which have the same type
06:43:20 <carter> ertes: good point.  That's also worth fixing.
06:43:39 <lyxia> Does it have to involve generics? I think it would be much easier to come up with something like recursion-schemes, where you take the fixed point of a functor.
06:45:11 <lyxia> Maybe not.
06:47:21 <lyxia> drninjabatman: Ah, I just realized it's not recursive...
06:48:47 <mpickering> Can anyone enlighten me why this program is not accepted? https://www.irccloud.com/pastebin/G0df7mR2/
06:49:27 <lyxia> monomorphism restriction?
06:49:43 <ab9rf> does look like DMR
06:50:19 <lyxia> What's D for?
06:50:24 <ab9rf> what is the error from the compiler? maybe repaste that on hpaste
06:50:25 <Reisen> With TypeInType, numbers like 3 have type (Num t => t), standard, but have kind Nat, is this a special case in the compiler?
06:50:27 <ab9rf> lyxia: "damned"
06:50:37 <mpickering> I added the errors
06:50:43 <mpickering> It doesn't compile with NoMonomorphismRestriction 
06:50:53 <Reisen> Rather than a concrete type like Int having :t Int and Int having kind Nat (:k Int is still *)
06:51:07 <mpickering> No..
06:51:15 <mpickering> This is nothing to do with TypeIntype
06:51:29 <mpickering> 3 and 3 are two different things. One is a type and one is a value
06:51:36 <Reisen> Well TypeInType implies DataKinds right
06:51:41 <Reisen> I should've just said DataKinds, sorry
06:51:49 <ab9rf> mpickering: "type variable 'f' would escape its scope"
06:52:36 <Reisen> mpickering, that answers my question though, thanks, seems really obvious when you put it like that
06:53:24 <mpickering> ab9rf: Could you explain more please? 
06:53:41 <ab9rf> mpickering: i'm not quite sure how, in part because i don't understand what you're trying to do here
06:54:13 <ab9rf> but it's definitely related to using a quantified type expression in the definition of F
06:55:52 <Geraldus> Hi friends!
06:56:00 <lyxia> for some reason I can compile it just fine
06:56:27 <ab9rf> you're asking GHC to make a type inference about a higher-rank type. GHC can't do that; higher-rank type inferences are undecidable (rank > 2) or potentially undecidable (rank == 2), and ghc thus refuses to do that
06:56:30 <lyxia> and that's because I've enabled NoMonomorphismRestriction
06:57:23 <Geraldus> Sorry, my question is about stack, so it may be a bit off–topic, but I've never got a response on #haskell-stack channel
06:58:54 <ongy> Geraldus: just ask, we get stack questions often-ish and usually somebody knows (I don't)
06:59:14 <Geraldus> My Travis build fails to boot GHCJS, I use stack to install it, the reason of failure that `hsc2hs` can't find default template.  `hsc2hs` is also installed by stack.  I suppose the issue occurs because of missing hsc2hs' data dir in path.  
07:00:00 <lyxia> mpickering: eta expand t x = fmap f x
07:00:02 <mpickering> lyxia: ok great, if I turn on GADTs then it fails
07:00:13 <mpickering> can you reproduce that?
07:00:42 <lyxia> I can.
07:00:52 <lyxia> I mean I get an error now too.
07:01:44 * lyxia is puzzled.
07:03:04 <mpickering> lyxia: It is because GADTs implies MonoLocalBinds
07:03:24 <lyxia> OH
07:04:28 <lyxia> I didn't know that was a thing.
07:05:56 <lyxia> mpickering: the other day my advisor Meng Wang gave me a paper you wrote about Profunctor Optics, is it actually published anywhere?
07:06:15 <mpickering> oh right, we're working on something now which is why I asked about this
07:08:16 <lyxia> Oh cool.
07:09:07 <mpickering> With a clearer and more direct exposition ;) 
07:15:01 <mpickering> Are you a PhD student or? I don't think we have met before
07:15:54 <Cleverson> Hello all, please what is the recommended way to set up WXWidgets and WXHaskell for the 8.0.1 Haskell Platform on Windows? I tried using the Achelanne installer, but it gives errors apparently related to packages versions incompatibilities.
07:16:41 <lyxia> mpickering: we haven't. I'm doing an internship with Meng.
07:17:03 <mpickering> The combination of GUI and Windows makes it sounds difficult!
07:17:07 <mpickering> lyxia: What are you working on?
07:28:07 <lyxia> mpickering: I'm doing bidirectional programming with monads and profunctors. Seeing what I can make of the fact that this type http://hackage.haskell.org/package/codec-0.1.1/docs/Data-Codec-Codec.html originally meant for bidirectional serialization, is Applicative, and can be fixed to be a Monad.
07:28:40 * hackagebot hscrtmpl 1.5 - Haskell shell script template  https://hackage.haskell.org/package/hscrtmpl-1.5 (DinoMorelli)
07:30:20 <mpickering> ok great, maybe we will run into each other. How long are you in the UK for?
07:31:26 <lyxia> Until January, I'm leaving when POPL starts.
07:39:08 <kuribas> > foldr (\x cont -> (+cont x)) id [1, 2, 3] 0
07:39:11 <lambdabot>  6
07:40:06 <kuribas> > foldr (\x cont -> if even x then (+x) else (+cont x)) id ([1, 5, 3, 7, 2]++[2..]) 0
07:40:08 <lambdabot>  18
07:42:05 <kuribas> Right fold makes a good combination with CPS.
07:50:33 <geppettodivacin> That's one of the strangest looking folds I've seen.
07:54:16 <kuribas> It allows early exit.
07:54:51 <ski> @where evolution
07:54:52 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
07:55:12 <ski> geppettodivacin : see "leaned so far right they came back as left" ^
07:55:23 <ski> (or something like that)
07:56:20 <Tuplanolla> That's such a great trick the first time you see it. How does this thing take three arguments?
07:56:49 * EvanR looks at origamist haskell programmer
07:57:03 <kuribas> Tuplanolla: Because it folds a function.
07:57:21 <EvanR> fold c n [] = n
07:57:28 <EvanR> fold c n (x:xs) = c x (fold c n xs)
07:57:44 <Tuplanolla> I know, kuribas.
07:57:48 <EvanR> is this the lost fold
07:57:56 <geppettodivacin> I didn't know (n + 1) patterns were a thing you could do.
07:57:58 <EvanR> or just foldl
07:58:08 <ski> geppettodivacin : been deprecated
07:58:11 <Rembane> Is there a middle fold?
07:58:28 <ski> you could do associative tree fold
07:58:42 <Tuplanolla> Repa has those, Rembane.
07:58:51 <ski> iow, trying to make the calling tree of the binary operation as balanced as possible
07:59:35 <Rembane> Tuplanolla, ski: Awesome! :D
07:59:59 <ski> (or sometimes, it's better to weight it on some aspect of the intermediate results. e.g. adding floating-point numbers of roughly the same magnitude together)
08:00:24 <Rembane> So it kinda sorts the result first?
08:00:44 <ski> that'd be one possibility
08:01:00 <Tuplanolla> I think Repa just does work sharing without looking inside.
08:01:20 <EvanR> ah its just foldr
08:01:21 <ski> Tuplanolla : "those" being exactly ?
08:02:27 <Tuplanolla> :t Data.Array.Repa.foldP
08:02:29 <lambdabot> error:
08:02:29 <lambdabot>     Not in scope: ‘Data.Array.Repa.foldP’
08:02:29 <lambdabot>     No module named ‘Data.Array.Repa’ is imported.
08:03:15 <ski> > let pred (n + 1) = n in pred 7  -- `NPlusKPatterns' not being enabled in lambdabot, geppettodivacin
08:03:19 <lambdabot>  <hint>:1:11: error: Parse error in pattern: n + 1
08:03:34 <ski> @let import Data.Array.Repa
08:03:35 <lambdabot>  .L.hs:68:1: error:
08:03:35 <lambdabot>      Failed to load interface for ‘Data.Array.Repa’
08:03:35 <lambdabot>      Perhaps you meant
08:03:42 * hackagebot git-annex 6.20161118 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20161118 (JoeyHess)
08:03:42 <Tuplanolla> That would be `(Shape sh, Source r a, Elt a, Unbox a, Monad m) => (a -> a -> a) -> a -> Array r (sh :. Int) a -> m (Array U sh a)`. There's `foldAllP`, `sumP`, `equalsP` and others too.
08:03:44 <ski> hmhm
08:04:17 <ski> m, right, an associative (presumably parallel) fold
08:05:56 <kuribas> ah, it's here: https://wiki.haskell.org/Foldl_as_foldr
08:07:43 <ski> also see
08:07:46 <ski> @type foldM
08:07:48 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
08:07:48 <joe9> is wl-pretty-print still the best option to pretty print in text?
08:07:53 <ski> @src foldM
08:07:54 <lambdabot> foldM _ a []     = return a
08:07:54 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
08:08:17 <ski> (which is an instance of `foldr', but which one thinks of as being "`foldl'-like")
08:08:28 <mettekou> Is there a difference between GADTs and data families in Haskell?
08:08:37 <ski> yes
08:08:44 <ski> a GADT is a single new data type
08:09:25 <ski> a data family is a type function, which can return different data types in different cases (and always a new data type)
08:09:37 <geppettodivacin> @src foldr
08:09:37 <lambdabot> foldr f z []     = z
08:09:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:09:59 <ski> geppettodivacin : exercise : figure out how to define `foldM' in terms of `foldr'
08:10:33 <geppettodivacin> ski: I'm still working on the continuation passing. :) I'll take a look at that in a bit, maybe.
08:10:45 <mmaruseacph2> isn't (almost) anything definable using foldr? I recall reading a blog post about this some years ago
08:11:27 <ski> geppettodivacin : also realize that `foldlMaybe' on the wiki page kuribas mentioned *is* `foldM', for the case of using the `Maybe' monad
08:11:28 <Tuplanolla> If you're using "almost" like a mathematician, no, mmaruseacph2.
08:11:39 <ski> geppettodivacin : *nod*, it's just a suggestion :)
08:11:54 <switte> pt
08:12:21 <ski> mmaruseacph2 : a fun exercise is defining `zip' (or `zipWith') using `foldr' as sole means of looping and analyzing the two input lists
08:12:45 <ski> (mmaruseacph2 : .. possibly a relatively hard exercise, though)
08:12:56 * ski looks at switte
08:12:56 <Tuplanolla> I've seen that and it was disgusting, ski.
08:13:07 <ski> disgusting, how ?
08:13:24 <circ-user-YRR1g> What is p ‘bind‘ f = \inp -> concat [f v inp’ | (v,inp’) <- p inp] doing?
08:13:32 <Tuplanolla> Long and meandering.
08:13:39 <circ-user-YRR1g> You can find it on page 5 of http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
08:13:46 <mettekou> ski: Yeah, I should've at least reread the wiki for GADTs before asking that question. GADTs allow the parameters of a higher-order type to vary per data constructor, while data families provide data constructors indexed by types.
08:13:57 * ski idly wonders how the solution Tuplanolla saw looked like
08:14:24 <ski> circ-user-YRR1g : defining a "monadic bind" operation, for parsers, it looks like
08:14:49 <circ-user-YRR1g> It says that concat flattens the (v, inp) pairs. I wonder how does it do that and which array is he talking about? I see only two paris at max.
08:15:00 <ski> circ-user-YRR1g : used for "concatenating" parsers, while allowing the latter one to make decisions based on what the former one actually parsed
08:15:26 <circ-user-YRR1g> What is role of concat in that
08:15:45 <ski> without the `concat' you get a list of lists
08:15:49 <circ-user-YRR1g> Isn't it f that decides how to merge the results?
08:16:04 <ski> while you want a single flat list of partial-result & remaining-input pairs
08:16:13 <mettekou> ski: Though if I'm correct, in a dependently-typed language with inductive families such as Coq, Agda or Idris; GADTs, data families and type families are covered by those inductive families.
08:16:22 <ski> `f' is the latter parser
08:16:32 <ski> circ-user-YRR1g : i'm not sure what you mean by "merging results"
08:16:46 <circ-user-YRR1g> Because, you know, you can combine them in may different ways and I wonder how concat knows what I have in mind.
08:17:34 <ski> mettekou : i don't think you can have data nor type families in Agda, i.e. in the case where you're indexing by types
08:17:49 <circ-user-YRR1g> p converts input into v and f does something on v. Why concat?
08:17:53 <ski> mettekou : if you're indexing by values, then it's just an ordinary function that happens to return a type
08:18:06 <ski> mettekou : GADT would (more or less ..) corresponds to indexed data types
08:18:39 <geppettodivacin> Figured out that foldr, anyway. My misconception was that the id argument was eventually used. In actuality, it's only used if you evaluate all the way to the end of the list.
08:18:59 <ski> circ-user-YRR1g : `p' might be able to parse the input in say three different ways (so a list of three pairs)
08:19:50 <ski> circ-user-YRR1g : then `f', for the first pair, might fail parsing completely; for the second pair, might succeed parsing the rest in two different ways; for the third pair, might succeed parsing the rest in only one way
08:19:56 <mettekou> ski: That's weird, I thought Agda was based on UTT. In Coq GADTs correspond to inductive types with parameters of type Set/Type/Prop of which the constructors return different applications of the inductive type, type families are inductive families which only operate on types and data families um... Not sure on those yet.
08:20:20 <ski> circ-user-YRR1g : so you get `concat [[],[((x,rest0),(y,rest1)],[(z,rest2)]]' in that case
08:20:41 <ski> circ-user-YRR1g : yielding `[(x,rest0),(y,rest1),(z,rest2)]'
08:20:52 <circ-user-YRR1g> wow. Indeed, he says about that later. I came from the practical peg parsers and overlooked this option. Thanks for pointing it out.
08:20:58 <ski> (sorry, a stray `(' in the former snippet there)
08:21:59 <mettekou> ski: Oh wait, you're right, indexing by types doesn't work, because you can't pattern match on universes because they're open to extension at any time by defining new types.
08:22:19 <ski> mettekou : right
08:23:42 <ski> mettekou : however, if you have something like `data Foo :: Bool -> * where FooA :: Foo False; FooB :: Nat -> Foo True', an important difference is whether you're able to match on something of type `Foo b' (and in the process discover what `b' is), or if you can only match if you *already* know whether `b' is `False' or `True'
08:24:17 <ski> mettekou : with GADTs, you can discover `b' in this way. at least in Agda1, you can't, atm i can't recall whether you can in Agda2
08:24:28 <joe9> is it possible to derive pretty instances to use wl-pprint-text?
08:24:41 <joe9> s/to use/when using/
08:25:25 <dolio> Discovering b is what inductive families gives you, and Agda 2 has inductive families.
08:25:35 <ski> mettekou : also, being able to match on types would be problematic in case we want the option of adding univalence, since then one'd need to make sure (iow prove, manually or automatically) that one's function give equivalent results for equivalent inputs
08:25:48 <ski> dolio : ty
08:26:40 <dolio> Also called, 'indexed inductive types.'
08:26:58 <mmaruseacph2> ski: I'll give it a thought
08:27:45 <ski> (cf. the "nonsense" (?) about roles, <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#roles>)
08:28:14 <mmaruseacph2> (it = implementing zip in terms of foldr)
08:28:18 * ski nods
08:29:08 <ski> mmaruseacph2 : to clarify, `null',`head',`tail' are of course barred, and you can only use `(:)' and `[]' to produce the output list (if you prefer, you could use `GHC.Exts.build' instead)
08:31:20 <ski> (mmaruseacph2 : .. and reimplementing `null',`head',`tail' in terms of e.g. `foldr' is also not what's intended -- i know the specification of the exercise is a bit vague, but i'd like to not hint too much about the proper solution)
08:34:55 <mmaruseacph2> should provide a good time-filler while flying to defend my thesis
08:34:57 <mmaruseacph2> or from the defense
08:35:00 <mmaruseacph2> thanks
08:35:12 <joe9>  I am trying to understand this article http://www.stephendiehl.com/posts/strings.html , section "Pretty Printers" . I do not understand why the author wants to  "write a new typeclass," instead of using the Pretty type class provided by wl-pprint-text. Any ideas, please?
08:37:17 <MikeyRawks> :t filp
08:37:19 <lambdabot> error:
08:37:19 <lambdabot>     • Variable not in scope: filp
08:37:19 <lambdabot>     • Perhaps you meant ‘flip’ (imported from Data.Function)
08:37:30 <MikeyRawks> :t Monad
08:37:31 <lambdabot> error: Data constructor not in scope: Monad
08:37:39 * ski looks at MikeyRawks
08:37:54 <mpickering> joe9: Isn't he explaining how you would implement a class for pretty printing?
08:38:07 <mpickering> Which bit are you exactly referring to?
08:43:22 <joe9> mpickering: ok, Thanks. I want to use pretty printing and I am trying to understand if I can use the Pretty type class defined in wl-pprint-text?
08:43:43 <mpickering> Yes. I don't see why not.
08:44:22 <joe9> mpickering: I use protolude too and wanted to understand why the author thinks that there is a need for a new type class instead of just using the Pretty defined in wl-pprint-text
08:44:37 <joe9> mpickering: ok, Thanks. I should be able to just use the Pretty then.
08:44:43 <EvanR> theres actually several pretty printers
08:44:58 <EvanR> not sure which one is considered more standard
08:44:59 <joe9> EvanR: I want something that output to Text
08:45:12 <joe9> EvanR: I think wl-pprint-text is the only option for that scenario
08:45:43 <joe9> EvanR: I use groom normally but it does not seem to be a performant solution.
08:48:43 <bitemyapp> sm: just me
08:52:04 <glguy> Interesting change in async-2.1.1, cancel now blocks until the thread finishes
08:53:43 * hackagebot th-inline-io-action 0.1.0.1 - Simple inline IO action into compiled code using TH  https://hackage.haskell.org/package/th-inline-io-action-0.1.0.1 (tolysz)
08:55:33 <geppettodivacin> :t \f b cs -> foldr (\s g x -> f s x >>= g) return cs b
08:55:34 <lambdabot> (Foldable t, Monad m) => (t1 -> b -> m b) -> b -> t t1 -> m b
08:55:41 <geppettodivacin> ski: ^
08:56:04 <MikeyRawks> Just (+1) <*> Just 2
08:56:21 <MikeyRawks> :t
08:56:27 <MikeyRawks> :t Maybe
08:56:28 <lambdabot> error:
08:56:29 <lambdabot>     • Data constructor not in scope: Maybe
08:56:29 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
08:56:40 <MikeyRawks> :t Data.Maybe
08:56:42 <lambdabot> error:
08:56:42 <lambdabot>     Not in scope: data constructor ‘Data.Maybe’
08:56:42 <lambdabot>     No module named ‘Data’ is imported.
08:57:35 <geppettodivacin> ski: I did have to look at foldlMaybe, mostly because I hadn't considered free variables in the definition.
08:57:35 <ski> geppettodivacin : yep :)
08:58:43 <ski> geppettodivacin : note how it's strictly speaking not tail-recursive, since `(>>=)' is "outside" `g'
08:59:01 <ski> this is what enables e.g. early exit with `Maybe'
08:59:15 <geppettodivacin> Although, looking at it again, I think the standard foldM uses (b -> a -> m b), so I think I got the arguments of f backwards.
08:59:34 <geppettodivacin> I didn't realize that a lack of tail recursion was necessary for early exit.
08:59:39 <ski> mm, possibly
08:59:55 <geppettodivacin> :t \f b cs -> foldr (\s g x -> f x s >>= g) return cs b
08:59:56 <lambdabot> (Foldable t, Monad m) => (b -> t1 -> m b) -> b -> t t1 -> m b
09:00:11 <ski> well, `foldl' is tail-recursive, so you can't stop it from going on 'til the end, by providing some particular callback
09:00:18 <ski> which you *can* do that with `foldr'
09:00:21 <ski> that was my point
09:00:56 <ski> (of course, in general, you could have tail-recursion inside a conditional which could alternatively exit early. but `foldl' doesn't allow that)
09:01:16 <geppettodivacin> Is that true of all tail-recursive higher-order functions?
09:01:32 <ski> it's because of how `foldl' is defined
09:01:34 <ski> @src foldl
09:01:34 <lambdabot> foldl f z []     = z
09:01:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:01:58 <ski> in the recursive case, it unconditionally continues by tail-calling itself
09:02:13 <geppettodivacin> Because it won't evaluate the f until the very end, right?
09:02:29 <ski> if there was some extra condition which could make it sometimes do something else, then it wouldn't insist on going on 'til the end
09:02:40 <ski> well, that too
09:02:49 <geppettodivacin> Kind of seems backwards how foldl goes to the end before evaluating, while foldr evaluates starting from the left.
09:03:00 <EvanR> makes sense to me
09:03:07 <ski> but it will always evaluate the recursive call as a consequence of evaluating the current call
09:03:12 <EvanR> you can always find a way to interpret it backwards
09:03:12 <ski> (as opposed to the case with `foldr')
09:03:39 <EvanR> foldr folds "to the right"
09:03:44 * hackagebot git-repair 1.20161118 - repairs a damanged git repisitory  https://hackage.haskell.org/package/git-repair-1.20161118 (JoeyHess)
09:03:46 * hackagebot github-backup 1.20161118 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20161118 (JoeyHess)
09:03:57 <EvanR> > foldl (:) [] [1,2,3,4]
09:03:59 <lambdabot>  error:
09:03:59 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
09:03:59 <lambdabot>        Expected type: [a] -> [a] -> [a]
09:04:13 <EvanR> > foldl (flip (:)) [] [1,2,3,4]
09:04:16 <lambdabot>  [4,3,2,1]
09:04:23 <ski> (with  foldl'  you'd presumably evaluate the `f' call before, but you'd still always do the recursive call, so it's "effectively tail-recursive", or how one'd like to say it)
09:05:44 <ski> > foldl (**) z [a,b,c,d]
09:05:46 <lambdabot>  (((z**a)**b)**c)**d
09:05:49 <ski> > foldr (-) z [a,b,c,d]
09:05:51 <lambdabot>  a - (b - (c - (d - z)))
09:05:54 <stalek> hi
09:05:58 <ski> hello stalek
09:43:45 * hackagebot geo-uk 0.1.0.2 - High precision conversion between GPS and UK Grid  https://hackage.haskell.org/package/geo-uk-0.1.0.2 (tolysz)
10:03:46 * hackagebot vgrep 0.1.4.1 - A pager for grep  https://hackage.haskell.org/package/vgrep-0.1.4.1 (fmthoma)
10:16:11 <xenon-> i want to change small snippets of haskell code after compilation without having to recompile entire program. there seem to be several haskell interpreters that could potential be used for that. which one (if any?) would be suitiable for this?
10:16:24 <xenon-> potentially*
10:18:12 <geekosaur> that's not actually simple... the interpreters run in their own environments, *not* the compiled environment of your program. (they can't share data etc. unless you specifically pass it between them)
10:18:47 * hackagebot pretty-display 0.1.9 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.9 (jsermeno)
10:19:01 <johnw> after I use Network.Socket.send, is it possible to "flush" to ensure that all bytes are sent before I shutdown the sending side of the socket?
10:20:29 <xenon-> i see.. i have a web scrapping program, and every now and then web site changes its layout and my program stops working until i change the code and recompile it. would it be feasible to put the web scrapping code into a haskell script that is loaded at runtime?
10:21:22 <lyxia> sounds fine
10:21:28 <geekosaur> johnw, if the Haskell handle is set nonbuffered (or you use hFlush), you have done everything you need to before shutdown.
10:21:43 <johnw> xenon-: to be really smple about it, you could put the scraping code into its own process and use runghc for that process
10:21:51 <geekosaur> you can't control the kernel side, largely because that also implies control of the remote system which may be throttling for some reason
10:21:57 <johnw> just have it output the scraped data as JSON or something you can easily feed back into the parent app
10:22:08 <johnw> geekosaur: how do I use hFlush with a socket?
10:22:12 <geekosaur> but the kernel will deal with sending the last packets
10:22:23 <johnw> if I convert it into a Handle, then won't that break my future use of the receiving side of the socket?
10:22:40 <xenon-> johw not a bad idea
10:22:45 <mlehmk> all you need is flush the buffers of the library whatever it is that sits on top of the sockets
10:22:51 <sm> xenon-: what john said, also there's packages like hint and plugins which could help
10:23:02 <geekosaur> johnw, if it's not already a Handle then you don't need to do anything
10:23:14 <johnw> geekosaur: hmm
10:23:26 <mlehmk> the remaining part is OS implementation dependent, but a shutdown should still properly send the remaining bytes from the kernel side buffers to the destination
10:23:36 <geekosaur> all buffering would be kernel side and not under your control; and shutdown does not delete the kernel unsent data, it will still be sent
10:23:49 <xenon-> one issue though - my program would need ghc installation to work
10:24:14 <mlehmk> so all you really need before shutdown is to flush the buffers that might still be in the haskell libraries
10:24:25 <geekosaur> you would anyway, the only question would be whether it's a full standalone or importing most of it into your program in the form of ghc-api
10:27:12 <sm> xenon-: true
10:27:40 <dmj`> what would be the easiest way to apply some function (a -> Identity a) to all items in an arbitrary-sized tuple (up to 20 something)
10:28:07 <sm> xenon-: I *think* that's true no matter what you do
10:28:35 <geekosaur> dmj`, arbitrary tuples can't be deconstructed in a normal fashion. lens should be able to do this with some hacking, generics can do it, otherwise no
10:28:39 <lyxia> dmj`: coerce
10:29:01 <sm> web-plugins is another one. Used by clckwrks, which is the only GHC-haskell program that reloads code this way AFAIk
10:29:35 <johnw> geekosaur: my problem is this code: https://gist.github.com/jwiegley/11492486e72432b3c7f0a9d5f49bd7ce
10:30:12 <johnw> if I use socat to do what this code seems to be saying, it works.  So maybe shutting down like this is the problem
10:30:36 <dmj`> lyxia: heh, it’s a possibility
10:32:02 <geekosaur> johnw, in theory that should work. In practice I expect it could be vulnerable to the "open3 problem": you need to have something reading *in another thread* or buffers somewhere outside your control --- quite possibly on the remote system --- fill and deadlock.)
10:32:41 <johnw> geekosaur: I'm sending from one machine to another running "socat tcp-listen:8000,fork exec:foo"
10:32:50 <johnw> is my "foo" process on that server which is exiting early with SIGTERM
10:32:55 <dmj`> geekosaur: trying to avoid dragging all of lens in, generics might work
10:33:11 <johnw> but it doesn't happen if on the sending side I use: socat - tcp:<server>:8000
10:33:15 <geekosaur> SIGTERM wouldn't be a normal result of something closing too early?
10:33:32 <geekosaur> SIGPIPE or SIGHUP would be. SIGTERM makes me think something else is somehow interfering
10:34:02 <johnw> in the bash script I'm running I have "trap finish INT TERM EXIT"
10:34:08 <johnw> and it's this that's being triggered
10:34:09 <mlehmk> how many bytes is your content?
10:34:20 <johnw> mlehmk: I'm sending 10 bytes, waiting for several hundred back
10:35:06 <mlehmk> yeah, but you only receive once
10:35:30 <johnw> correct
10:35:40 <geekosaur> if it's TCP. only one is needed
10:35:40 <mlehmk> this can be any beginning part of what has been sent, from 0 bytes to 8192
10:35:45 <johnw> in the receiving side bash script, the line that it's in when it gets the trap is "read filename"
10:35:52 <geekosaur> well, yes, up to 8192
10:36:10 <johnw>  so the script is waiting for input from standard in, but before it receives that input in order to continue on with the script, the trap is signaled
10:36:17 <geekosaur> johnw, ... does the pathname end with a newline?
10:36:38 <geekosaur> if not, bash's read will not finish (unless you use one of the variant modes that doesn't do line mode reads)
10:36:41 <johnw> I'm not sure, let me make sure of it
10:37:05 <geekosaur> (although I think the only real option there is end with NUL instead of \n, so that wouldn
10:37:06 <geekosaur> t help
10:37:07 <geekosaur> )
10:37:24 <dmj`> lyxia: coerce works I guess
10:37:27 <johnw> I think I'm just sending the ByteString "foo"
10:37:33 <johnw> without any terminators within the ByteString
10:37:35 <geekosaur> ok, the read never finishes
10:38:01 <geekosaur> bash is line mode, you *must* send a newline --- or use read in NUL-terminated mode and send \0 after
10:38:13 <johnw> let me try the newline
10:38:21 <geekosaur> otherwise the script will abort because it's still looking for the terminator when the connection closes
10:38:21 <mlehmk> also make sure you receive from the socket until you receive a message of 0 bytes length
10:38:39 <johnw> mlehmk: hmm?
10:39:04 <mlehmk> sockets are weird, even on stream sockets if the sender sends the message in pieces, it might arrive in pieces
10:39:10 <geekosaur> well, when it receives EOF on the read side from the shutdown you did write-side. then bash will abort because the read didn't finish with the terminator it was looking for
10:39:43 <johnw> geekosaur: I've added a newline, trying now
10:39:53 <geekosaur> johnw, mlehmk is pointing out that you have few guarantees that, even on shorter data, a single recv will be sufficient
10:39:53 <mlehmk> so a read usually returns once there's data in the receive buffers
10:40:08 <geekosaur> it *probably* is in this case, but it is not *certain*
10:40:33 <mlehmk> if you have a shortened message from what you expect, this might be the case
10:40:40 <johnw> nothing is shortened
10:40:40 <geekosaur> networks do what netrworks do, neither your program(s) nor the machines you are using can do much about it, program defensively
10:41:14 <johnw> if I print input/output on both sides, I see what I expect; it's the terminating read that so far is my problem; the terminator explanation sounds good, so trying now
10:41:24 <johnw> (by read there I mean bash "read")
10:42:40 <mlehmk> this is also the weird bugs when in another language wrapping a NetworkStream inside a DeflateStream will result in garbled data. As a NetworkStream ensures neither filling the read buffer completely nor actually sending all bytes from a buffer given
10:43:18 <mlehmk> so, a send of 614 bytes might return that 512 bytes have been sent
10:43:53 <mlehmk> then the remaining 102 bytes have to be sent with another call to send
10:49:02 <mlehmk> this would happen if Haskell uses non-blocking sockets
10:50:05 <geekosaur> ghc's runtime sets things non-blocking, yes. but it should also handle much of this for you instead of forcing you to deal
10:50:55 <geekosaur> (handles too much in fact; I still need to file that bug report about this on fifos/pipes...)
10:53:29 <geekosaur> well, correct that slightly. it it does a short write then it gets descheduled waiting for poll to return ready-for-write then resumed to write the rest (or at least the next chunk).
10:54:01 <geekosaur> this leads to an edge case where you might need to detect that case but cannot in user code, and end up deadlocked on something that will never unblock :/
11:05:03 <kirillow> Can i pattern match on a range? ([a..b] of [1..1000])
11:05:21 <glguy> What happened when you tried?
11:06:06 <kirillow> i have no haskell here...this just crossed my mind
11:06:22 <Tuplanolla> Only on constructors, kirillow.
11:06:38 <kirillow> that seems odd
11:06:45 <Tuplanolla> How so?
11:07:21 <kirillow> wait Im not sure I understood what you mean
11:07:45 <Clint> go on
11:08:12 <Tuplanolla> You can only pattern match on data constructors, not arbitrary expressions.
11:10:26 <allenj12> why dont they call Functors in haskell Endofunctors? isnt that what they are in haskells context?
11:10:51 <grantwu> couldn't you say the same for monads
11:10:54 <lyxia> Well that's 4 more characters
11:11:01 <Tuplanolla> You'd have an awful lot of endo on your hands, allenj12.
11:12:05 <EvanR> well, its not wrong to say Functor
11:12:22 <ogkloo> isn't Hask like technically not a category? I keep seeing papers saying that.
11:12:39 <EvanR> youd have to specify what Hask is
11:12:51 <ogkloo> the category of Haskell types
11:12:52 <absence> is anyone using ResourceT? i'm trying to use runResourceT, but it wants a very specific transformer stack, i.e. ResourceT m a, whereas I only have a MonadResource m => m a. i guess it needs some lifting, but i can't figure out how
11:13:20 <EvanR> more importantly, what are the arrows
11:13:22 <ezyang> You can't run an abstract monad like that 
11:13:30 <ezyang> absence: You need to know the exact type to run it 
11:14:05 <lyxia> well if you have a MonadResource m => m a, you can instantiate m with ResourceT m'
11:14:11 <allenj12> grantwu: I thought monads by definition where "endoMonads"
11:14:44 <grantwu> I don't know that much about the category theory aspect of monads.  All I know is that I heard that they were not strictly identical to the category theoretical monad
11:14:46 <lyxia> so you can apply runResourceT to it, and you need to specify the rest of the stack m'
11:14:52 <byorgey> allenj12: indeed, by definition monads are endofunctors with some extra properties
11:15:09 <byorgey> allenj12: and you're right that Haskell Functor instances can be thought of as endofunctors on the Hask category
11:15:21 <absence> ezyang: i'm trying to use it with writeFile from streaming-bytestring, which has the signature MonadResource m => FilePath -> ByteString m r -> m r
11:15:28 <absence> ezyang: not sure how to get the exact type from that
11:15:40 <ezyang> absence: writeFile is polymorphic, you can instantiate it to the stack you want 
11:15:45 <byorgey> allenj12: as for why they are not called Endofunctors, probably just because that would be long, confusing, and unnecessarily pedantic.
11:16:23 <EvanR> also Category, you could get more specific and say InternalCategory
11:16:40 <allenj12> byorgey: gotcha, thanks for clearing that up! I guess i was wondering tho if normal Functors had computational relevance in haskell
11:16:50 <absence> ezyang: ah, so it depends on the context in which i use it. does that mean all the involved monad actions have to be converted from MonadResource to ResourceT?
11:17:02 <EvanR> you have functors between two internal categories
11:17:20 <EvanR> not necessarily endo
11:17:22 <ezyang> absence: No "conversion" necessary 
11:17:25 <allenj12> byorgey: but now that i think about it, it seems it can be represented easily without a class
11:17:35 <byorgey> allenj12: well, there are ways to encode other sorts of functors other than endofunctors on Hask
11:19:17 <lyxia> allenj12: http://hackage.haskell.org/package/invertible-0.1.2/docs/Control-Invertible-Functor.html for example, Functors from the category of types and bijections to types and functions (Hask).
11:19:47 <allenj12> lyxia: ah thanks!
11:20:19 <augur_> a beautiful video featuring Graham Hutton about selection sort and insertion sort https://www.youtube.com/watch?v=pcJHkWwjNl4
11:20:28 <augur_> ht ilan godik for tweeting it
11:20:32 <augur_> this is really beautiful
11:20:38 <absence> ezyang: the monadic action where i want to use runResourceT currently has the signature specified with MonadResource. if i understand correctly it has to be changed to a specific stack with ResourceT to be able to call runResourceT?
11:24:48 <ezyang> absence: Well yes, but that will happen automatically, just in the same way if you want to show True, show has type Show a => a -> String but a will be changed to a specific a 
11:26:35 <sm> what's the way to cumulatively apply a list of functions to a value ?
11:27:06 <systemfault> A fold with ($) perhaps
11:27:43 <absence> ezyang: by changing i meant alter the signature in my source code. since you say "automatic", i guess i shouldn't need that then :)
11:27:56 <Tuplanolla> Rather `($ x) <$> fs` if there's only one value, sm.
11:27:57 <systemfault> sm: Like foldr ($) 2 [(*2), (+4)] ?
11:29:26 <sm> I always forget this, and have to think just to evaluate your answers, so thanks in advance
11:29:57 <sm> I'm looking for some _ so that _ [f,g,h] x = h $ g $ f x
11:30:14 <absence> ezyang: a "hoist lift" did the trick. kinda confusing, but i guess it will make sense if i ponder it enough
11:30:39 <cocreature> :t foldr (.) id
11:30:41 <sm> systemfault: that gives 8, uh, which seems other than what I want
11:30:41 <lambdabot> Foldable t => t (b -> b) -> b -> b
11:30:43 <cocreature> ^ sm
11:30:57 <ski> looks like `sm' wanted `foldl' ?
11:31:05 <cocreature> oh right, I can’t read
11:31:06 <sm> sorry, I mean your code gives 12 
11:31:43 <sm> oh, and I mistyped foldl as foldr. Never mind!
11:34:15 <systemfault> ski: It would be uglier with foldl though, right? You'd have to flip ($)
11:34:19 <ski> @tell augur : oh, sorting circuits :)
11:34:19 <lambdabot> Consider it noted.
11:34:29 <sm> do any of your answers so far fit  _ [f,g,h] x = h $ g $ f x  ? If so I don't see it
11:34:34 <EvanR> flip ($) has a symbol... &
11:34:54 <systemfault> EvanR: What import?
11:35:02 <EvanR> Control.Lens ...
11:35:06 <johnw> geekosaur: you hit the nail on the head :)
11:35:18 <EvanR> so in reality, define it yourself ;)
11:35:19 <Tuplanolla> Also `Data.Function`, EvanR.
11:35:23 <EvanR> oh?
11:35:25 <augur> ski: oh hello
11:35:27 <systemfault> EvanR: At your level, you probably expect everyone to use lenses.. :(
11:35:27 <augur> just in time! :)
11:35:57 <EvanR> i cant lens, but what if youre right!
11:36:03 <EvanR> everyone should use lens
11:37:10 <systemfault> Eventually, when I'll suck less at Haskell, I will definitely do it :)
11:37:17 <ski> > foldl (flip ($)) x [f,g,h]
11:37:19 <lambdabot>  h (g (f x))
11:37:22 <ski> > foldl (flip (.)) id [f,g,h] x
11:37:25 <lambdabot>  h (g (f x))
11:37:25 <ski> > foldr (flip (.)) id [f,g,h] x
11:37:27 <lambdabot>  h (g (f x))
11:37:29 <ski> sm ^
11:37:41 <ski> hello augur
11:37:54 <systemfault> ski: Cute :)
11:38:17 <augur> ski: the sorting circuit diagram makes me wonder if there's a programmatic way to show the picture
11:38:47 <augur> like.. probably you can make a fold of one sort, that builds up the triangle, and prove something about a transpose
11:39:08 <sm> ski: thanks! that does it.
11:39:08 <ski> sm : without the `flip's you'll get it in the opposite order (you'll need `foldr' for the first one, for that)
11:39:17 <tdammers> lens the concept isn't too difficult
11:39:29 <tdammers> lens the library however can be a bit overwhelming
11:39:30 <Tuplanolla> Would the sorting programs look the same if your language couldn't express evaluation order?
11:39:49 <ogkloo> what exactly _is_ a lens
11:39:56 <ski> sm : perhaps pause to reflect on why the latter two, differing only in `foldl'/`foldr', gives the same result
11:40:00 <sm> and incidentally is lambdabot doing symbolic evaluation there ? that's quite nifty
11:40:03 <EvanR> you could have invented them
11:40:07 <johnw> ogkloo: semantically, a lens is a pair of a getter and a setter function
11:40:11 <tdammers> ogkloo: conceptually, a record that contains a getter and a setter
11:40:17 <ogkloo> ooooh okay
11:40:45 <tdammers> the lens library just takes it to whole new generalized levels
11:40:56 <ogkloo> immutable though, right? So like it returns a new record?
11:41:10 <tdammers> yes
11:41:11 <EvanR> settering is immutable yeah
11:41:21 <ogkloo> ah okay thank you
11:41:24 <ski> augur : i wonder how it'd compare to stuff like Batcher's bitonic merger, &c.
11:41:26 <EvanR> but its not limited to records
11:41:36 <tdammers> that's why I said "conceptually"
11:41:38 <sm> ski: weell.. that might be a long pause. I assume they could have different runtime characteristics ? I've been conditioned to use foldl' only
11:42:00 <EvanR> tdammers: er, the getter and setter dont need to be in a record either... 
11:42:21 <ski> sm : neither  foldl  nor  foldl'  can work on an infinite list, so that's a case where  foldr  is to be used instead
11:42:33 <ski> sm : they are to be used in different circumstances
11:43:04 <ski> sm : when you want/need to produce a large structure incrementally, `foldr' is probably nicer
11:43:16 <sm> right, ok. I should remember that.
11:43:23 <EvanR> ogkloo: you could also have a setter into a list, a Map, a view of a structure (brain explode?) such as the bits of a number
11:43:50 * hackagebot bibdb 0.5.3 - A database based bibliography manager for BibTeX  https://hackage.haskell.org/package/bibdb-0.5.3 (cacay)
11:44:24 <ogkloo> EvanR: I can see how that gets abstract fast. I remember watching the library's author give a talk on it and it just went straight over my head. 
11:44:27 <EvanR> certainly setters for record fields are really handy
11:44:43 <EvanR> and the big deal is that all of these things are composable
11:45:49 <ogkloo> so like, if you'll forgive the pseudocode, something like (((set a 5) . (set b 4)) record)? 
11:46:36 <EvanR> well, yeah you could repeat a sets on the same thing, but no i meant you could reach deeply into a structure and set that part
11:46:47 <ogkloo> oh
11:46:50 <EvanR> like in oop dot notation
11:47:02 <ogkloo> that makes sense
11:47:24 <EvanR> but its more powerful than that, since the thing you set doesnt need to be a point, or even exist really
11:48:18 <EvanR> go to fieldX, index 3, key "foo", and set all records matching a predicates Z field
11:48:34 <EvanR> set Z field of all records matching predicate
11:49:35 <EvanR> or, flip the prime-number-indexed bits of an Int
11:49:49 <EvanR> very handy
11:52:15 <ski> augur : hm, it also reminds me of how two different approaches to generating a permutation are basically the same thing
11:54:18 <acowley_> With a multi-ghc travis setup, I see this error when trying to use GHC-7.8.4: http://lpaste.net/342736
11:54:55 <acowley_> Is there a way of avoiding that? The matrix entry says CABALVER=1.18
11:55:44 <NemesisD> i'm about to ask a pretty poor quality question but i don't know the right terminology: is there such a thing a an operator for composing types? i need a way to express ReaderT Foo (ReaderT Bar m) in a way thats kind * -> * (i.e. partially applied on the m
11:55:55 <ezyang> NemesisD: Unfortunately no 
11:56:18 <ski> augur : (a) you can select an element as the head; then permute the remaining, becoming the tail; or (b) you can permute the tail, and then insert the head into that
11:56:23 <ezyang> There are no type level lambdas; you can only get * -> * via some sort of generative type, like data Maybe a = ... 
11:57:03 <NemesisD> damn, that's going to make writing this MonadTransControl instance very difficult
11:57:21 <ezyang> NemesisD: you should make a newtype 
11:57:26 <augur> ski: interesting!
11:58:15 <NemesisD> ezyang: like newtype ComposedFooBar m a = ComposedFooBar (ReaderT Foo (ReaderT Bar m) a) ?
11:58:42 <ski> augur : in Prolog, (a) is `permutation([],[]). permutation(Xs0,[Y|Ys]) :- select(Y,Xs0,Xs),permute(Xs,Ys).', while (b) is `permutation([],[]). permutation([Y|Ys]) :- permute(Ys,Xs),select(Y,Xs0,Xs).', running select/3 in the backwards (+,-,+) mode where it inserts an element
11:58:45 <Tuplanolla> There's `TypeOperators` that allows a bit nicer syntax too, NemesisD.
11:59:05 <NemesisD> Tuplanolla: yeah that's why i was thinking there would be something generally available with type operators to get this
11:59:09 <ski> augur : so, these are really the same, only flipping the argument order, and flipping the order of the conjunction
11:59:34 <augur> ski: right, yeah
12:00:07 <augur> the whole thing is just the exact same relational composition but the inputs and outputs / direction of use is swapped
12:00:31 <augur> i'm sure Bird and some others would say "well yeah, there's lots of stuff like this! learn to calculate!" :)
12:00:32 <ezyang> yes 
12:05:44 <ski> in Haskell, (a)'d be `permute [] = [[]]; permute xs0 = [y:ys | (y,xs) <- select xs0,ys <- permute xs]' with `select [] = []; select (x0:xs0) = (x0,xs0) : [(x,x0:xs) | (x,xs) <- select xs0]'; while (b)'d be `permute [] = []; permute (y:ys) = [xs0 | xs <- permute ys,xs0 <- insert y xs]' with `insert x0 ys0 = (x0:ys0) : case ys0 of [] -> []; y:ys -> [y:xys | xys <- insert x0 ys]'
12:08:51 * hackagebot haskelisp 0.1.0.1 - Write Emacs module in Haskell, using Emacs 25's Dynamic Module feature  https://hackage.haskell.org/package/haskelisp-0.1.0.1 (shintak)
12:09:28 <ski> (for completeness, select/3 is defined as `select(X0,[X0|Xs],Xs). select(X0,[X|Xs0],[X|Xs]) :- select(X0,Xs0,Xs).')
12:11:03 <Welkin> ski: erlang, lol
12:13:08 <ski> Welkin : Prolog, not Erlang
12:17:05 <sm> omg
12:17:24 <sm> haskell in emacs
12:19:07 <ski> augur : <http://www.cse.chalmers.se/edu/year/2016/course/pfp/Material/DataParallel/slides.pdf>,<http://www.cse.chalmers.se/edu/year/2016/course/pfp/Material/GPUProgramming/slides.pdf> mentiones the bitonic merger thing, briefly, btw
12:19:32 <augur> cool
12:19:56 * ski perhaps should ask Sheeran for what's a better reference ..
12:20:12 <Clint> sm: too bad the source/homepage links are broken
12:25:57 <sm> I've noticed a bunch of hackage uploads with boilerplate metadata recently
12:26:43 <Clint> there are boilerplate github links?
12:26:47 <sm> hackage's package linter and/or cabal check could catch those, methinks
12:27:16 <sm> I'm assuming "githubuser" is boilerplate. Yesterday there was several stack-generated synopses
12:28:08 <hvr> sm: https://github.com/commercialhaskell/stack/issues/2786
12:28:31 <sm> nice hvr
12:54:16 <daey_> where exactly lies the difference between "function $ function 5" and "(function . function) 5" ?
12:54:42 <implementation> they do exactly the same.
12:55:14 <daey_> then why does the "." operator exist?
12:55:23 <geekosaur> well, in that case they do. but they're not actually the same thing
12:55:38 <ogkloo> >>= forcefully taught me that
12:55:40 <geekosaur> $ is a precedence hack that lets you do away with some parentheses
12:55:52 <geekosaur> function $ function 5       is function (function 5)
12:56:23 <implementation> and (function . function) 5  is function (function 5), too
12:56:41 <geekosaur> (function . function) 5      in this situation does the same, but in more complex cases does not; you have composed two functions, but if either takes more than one parameter then the result is quite different
12:58:24 <geekosaur> also, the (function . function) is a distinct unit that you can pass as a parameter to a higher order function. you cannot break the other down in the same way; (function $ function) does not have the same meaning
12:59:07 <dolio> If 2 + 2 = 4, and 2 * 2 = 4, then what's the point of *?
12:59:15 <ogkloo> for instance: Just 5 >>= (Just . f)
12:59:21 <geekosaur> implementation, they have the same effect, they do not have the same meaning
12:59:47 <ogkloo> but Just (\n -> n+1)
12:59:51 <ogkloo> throws an error
13:00:57 <implementation> geekosaur: looking at the definition, yes they do. (function . function) is nothing else than \x -> (function $ function x); if a term is applied on it, like 5, (function $ function 5) remains.
13:01:54 <implementation> there's a difference between ($) and (.), but not really between f $ f a and (f . f) a
13:02:00 <geekosaur> implementation, how do you break (f $ g 5) so you can pass the f and g without the 5?
13:02:35 <ogkloo> I wonder if it has more to do with the type system?
13:02:51 <geekosaur> *that* is the core here, and why (.) is different from ($). you can surely get the same result on the value level, the distinction is the type level indeed and how you can split the types up
13:02:56 <implementation> geekosaur: same for (f . g) 5. it's already fully applied.
13:02:58 <geekosaur> and package them. also how functions *are values(
13:03:28 <ogkloo> that makes sense, because like I was saying for >>= it wouldn't make a lot of sense if (f $ g x) = (f . g) x
13:03:34 <Wizek_> Anyone knows if a Yesod Handler can be called directly from within a test? I know about `get SomeRouteR`, but what if I have a more generic piece of code (:: Handler Html) that doesn't have its own specific route, but rater called from more than once routes? 
13:09:11 <geekosaur> implementation, you probably see that there is a distinction, but can't see why anyone would care. (if you can't even see that there is a distinction at all, you're going to have a lot of trouble understanding actual Haskell code)
13:09:56 <geekosaur> thing is, with functional programming, that distinction gives you flexibility you can't get the other way
13:12:36 <implementation> i do see that one notation is more practical than the other, but it both resolves to exactly the same thing. (f . g) a = (\x -> f (g x)) a = f (g a) = f $ g a, regardless on how f and g work, and regardless of what a is. it's the same thing in any case.
13:13:10 <ogkloo> right, but what he's saying is they don't do that at the type level
13:13:22 <geekosaur> right, you are stuck on the exactly evaluates that way, that is all that matters
13:13:51 <ogkloo> M (f) is :: M (a -> b)
13:14:02 <ogkloo> M . f is :: a -> M b
13:14:09 <geekosaur> so, can you recognize *when* one lets you do something you can't do easily (or at all) with the other? Can you think in terms of higher level combinators, or only at a brute force evaluation level?
13:14:26 <geekosaur> s/think/reason effectively/
13:16:55 <implementation> sure, i can eta-reduce (\x -> (f . g) x) to (f . g), while I cannot eta-reduce (\x -> f $ g x). and again, there too, it's only a matter of notation.
13:17:07 <geekosaur> f $ g x -- the packaging here does not allow you to split f and g off as a single entity.
13:17:21 <geekosaur> (f . g) x -- the packaging here gives you f . g as a single entity you can reuse
13:17:46 <geekosaur> (f $ g) x -- is not the same as f $ g x, nor is (f $ g) the same as (f . g)
13:18:15 <ogkloo> I think someone did some sort of differentiation thing that way
13:18:21 <geekosaur> sometimes you don't care about reuse, or want to reuse with the grouping f $ g x gives you, and those are reasonable cases to use it
13:18:23 <ogkloo> because you can essentially modify functions with /
13:18:26 <ogkloo> .*
13:18:41 <geekosaur> if you want the f and g as something you can reuse elsewhere, $ won't get you there but . will
13:18:53 <ogkloo> whereas just stacking functions on top of one another will return their last value instead of (a -> b)
13:18:56 <ogkloo> oh that's how to think of this
13:19:25 <geekosaur> it's not just about whether they evaluate the same way, it's about which parts are grouped for reuse
13:19:49 <implementation> I think we're talking about different things. I'm comparing "(f . g) x" to "f $ g x", not "f . g" to "f $ g x". "(f . g) x" is fully applied, and there's no way getting (f . g) back.
13:19:57 <ogkloo> f :: a -> b, g :: b -> c, f $ g x  will give you a b and requires an x, (f . g) will give you an a -> c 
13:20:30 <geekosaur> implementation, actually you have just made the point I was trying to make. yes, if all you can think about is the end result, your response is correct
13:20:38 <dolio> Why are you comparing those?
13:20:52 <geekosaur> now think higher order. how do I reuse *parts* of this, rather than reconstituting it each time>?
13:22:20 <implementation> they're both reusable in the same way. i can always write (\x -> f $ g x), or (\x -> (f . g) x). The practical thing about the latter one is that i can eta-reduce it to (f . g), which is prettier, but just a different notation.
13:23:17 * geekosaur sees this will go nowhere and gives up
13:28:14 <Welkin> geekosaur: just go play nethack or crawl
13:28:59 * daey_ recommends a MUD
13:29:32 <hexagoxel> (hard to convince anyone that a/=b when the other side has a different, (equally) unspecified interpretation of equality in mind.)
13:29:33 <Welkin> or you could play that one text-based game in emacs
13:29:39 <Welkin> the one where I always eat the shovel and die
13:30:03 <Welkin> M-x dunnet
13:30:11 * sm tries that. Ouch.
13:31:24 <Welkin> http://lpaste.net/934434675718356992
13:31:27 <Welkin> there
13:31:29 <Welkin> I just did it
13:32:05 <daey_> have you tried drinking it? 
13:32:37 * hexagoxel wonders if the shovel is some kind of metaphor for monads to get back on topic
13:33:16 <Rembane> Do not eat monads!
13:33:22 <Rembane> Functors are alright though
13:33:24 <sm> there needs to be a haskell tutorial adventure game 
13:33:27 <hiptobecubic> I'll do as i please
13:33:54 * hackagebot cmark 0.5.4 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.4 (JohnMacFarlane)
13:33:56 <sm> (tryhaskell is not that far off)
13:34:52 <asdikf> Hi! I have a question regarding an error I cant decipher. The code is the following:   instance Num (Numeral) where ....  signum (Num (a,b)) = ...
13:35:07 <asdikf> The definition of Numeral is:    newtype Numeral = Num (Sign, Digits)
13:35:36 <geekosaur> @paste
13:35:36 <lambdabot> Haskell pastebin: http://lpaste.net/
13:35:47 <asdikf> And the error that I get is: Implementation of signum requires extra context
13:35:49 <geekosaur> full code, full error messages
13:35:54 <asdikf> O thanks
13:40:17 <lpaste> asdikf pasted “An undecipherable error” at http://lpaste.net/342805
13:40:39 <geekosaur> oh, hugs, no wonder I didn't recognize the error message :/
13:41:24 <asdikf> O yes. I didn't mention it, it is hugs
13:41:30 <ezyang> asdikf: You've provided an implementation of the instance whose type needs the Num instance on lists 
13:42:00 <ezyang> because you used a 0 where [Digit] was expected 
13:42:46 <geekosaur> ah, right, because Num (Pos, 0) and later Num (a, 1) and 0 and 1 are inferred to be Digits aka [Digit]
13:42:58 <asdikf> O that easy. Now I feel stupid. The most simple errors are often the hardest to find! Thank you very much!
13:43:51 <Tuplanolla> Does Hugs give you the line and column numbers, asdikf? They're usually the most useful part of any error message.
13:45:06 <Welkin> it gives you a hug
13:45:32 <monochrom> yes, it has line numbers
13:45:37 <asdikf> It gave me the correct number. I still overlooked the source of the error. But thanks to ezyang already solved the problem for me!
13:48:00 <monochrom> Haskell Self-Adventure Game, excerpt: Page 14: You now have to create a representation for binary trees. If you decide to use an algebraic data type, turn to page 28; if you decide to use a Church encoding, turn to page 7.
13:49:14 <sm> there should be a haskell tutorial adventure game, and we should be able to write it incrementally from #haskell
13:49:56 <Tuplanolla> We could call it Confuse 7.
13:50:06 <sm> and send newcomers in there for answers
13:50:31 <sm> and give them beer and new weapons if they come out
13:50:39 <monochrom> I have subconsciously chose my page numbers to be multiples of 7.
13:56:25 <Welkin> sm: start a repo
13:56:37 <Welkin> sm: you can base it on nethack maybe?
13:56:40 <Welkin> is that what you had in mind?
13:57:36 <sm> no, more like zork/MUDs (interactive fiction)
13:58:09 <sm> there are some on hackage, someone just needs to plug it into lambdabot
14:00:09 <sm> https://hackage.haskell.org/package/EtaMOO ! simple matter of programming :)
14:00:51 <Clint> so that's what happened to rob leslie
14:01:18 <Polymorphism> http://www.tiobe.com/tiobe-index//
14:04:01 <c_wraith> tiobe's methodology is so suspect that we care as little when it ranks haskell high as we do when it ranks haskell low. 
14:05:28 <monochrom> We should care so little that: 1. We never mention it; 2. When someone mentions it, we ignore.
14:12:35 <joe9> just want to check if there is any technical hurdle to having a generic text pretty printing mechanism? such as that provided by Groom for String?
14:12:56 <joe9> I see wl-pprint-text but there is no deriving mechanism for Pretty.
14:14:04 <joe9> geekosaur: any kind comments on ^^, please?
14:15:33 <monochrom> I don't know what is a technical hurdle. If you want to write "data XXX = ... deriving Pretty" you have to build it into the compiler. If you can't build it into the compiler your next best option is Template Haskell.
14:16:11 <Xnuk> Can I turn on warnings when I enable -XOverloadedStrings and use Unicode string literal but it's ByteString?
14:16:56 <monochrom> I don't think there is such a warning.
14:17:16 <geekosaur> one can sort-of autoderive using generics; aeson does this
14:17:47 <joe9> geekosaur: yes, using generics. Is that possible?
14:18:06 <monochrom> Ah I forgot generics.
14:18:13 <geekosaur> extensible deriving is a work in progress in ghc (not something that will show up soon, although things needed for it to happen may; look for "deriving strategies")
14:18:30 <joe9> geekosaur:  ok, Thanks.
14:18:32 <Polymorphism> is haskell less practical than python?
14:18:42 <Polymorphism> I want to quickly write powerful applications, and I'm terrible at maths
14:18:54 <geekosaur> also there's more prettyprinting libraries, some of which may offer things like that already
14:18:56 <geekosaur> [18 18:18:25] * hackagebot pretty-display 0.1.9 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.9 (jsermeno)
14:19:06 <monochrom> but you still want to involve Template Haskell so that the user can just write "$(derivePretty XXX)" and be done.
14:19:09 <Welkin> Polymorphism: no, it is more practical
14:19:14 <geekosaur> this has seen quite a few updates over the past few days according to hackagebot
14:19:26 <joe9> geekosaur: Thanks. will check on pretty-display.
14:19:28 <Polymorphism> I'm coming from a C++ background
14:19:34 <Polymorphism> with some C and C#
14:19:36 <geekosaur> monochrom, actually if you derive Generic, aeson will figure it out
14:19:40 <Polymorphism> and looking to go deep into a useful next language
14:19:41 <geekosaur> don't need anything else
14:19:44 <monochrom> Oh!
14:19:47 <Welkin> Polymorphism: I have written haskell programs out on paper first, then typed them into emacs, and they worked on the first try
14:20:02 <monochrom> Yeah, I saw that in aeson and then forgot.
14:20:20 <geppettodivacin> Polymorphism: to add to Welkin's comment, that basically never happens in Python.
14:20:23 <Welkin> Polymorphism: I don't even consider another language when writing web applications; I always use haskell
14:20:24 <geekosaur> I suspect for prettyprinting you don't want to go that way, because it's all or nothing. whereas with prettyprinting you often want some control over the result
14:20:51 <geppettodivacin> Polymorphism: What do you want to do with a new language?
14:21:14 <Polymorphism> write web and console applications, as well as firmware for devices
14:21:25 <Tuplanolla> You will not encounter any practicality problems, unless you're planning on doing high-performance computing or targeting weak embedded platforms, Polymorphism.
14:21:36 <Welkin> your best bet for firmware is using haskell to write in a DSL that compiles to embedded C
14:21:43 <Welkin> or using C directly, if you really want to
14:21:47 <Tuplanolla> Then again, Python is even worse at both.
14:21:53 <monochrom> No, I'm wondering which one people want to control more and automate less: pretty-printing? json-printing? :)
14:22:05 <Welkin> something like Ivory
14:22:11 <Polymorphism> what does haskell excell at?
14:22:22 <Welkin> http://hackage.haskell.org/package/ivory
14:22:34 <Welkin> Polymorphism: for me, web applications
14:22:37 <geppettodivacin> Polymorphism: writing code that works, and telling you how to fix it when it doesn't.
14:22:41 <Welkin> it is the best. no contest
14:22:45 <Tuplanolla> Pretty much everything else than what I mentioned, Polymorphism: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
14:22:49 <joe9> geekosaur, pretty-display seems to be built upon String
14:23:15 <geppettodivacin> One of the best thins about Haskell is that the compiler does a lot of the legwork in error checking your code.
14:23:18 * geekosaur is wondering how he got to be your primary interface to channel resources...
14:23:25 <mmachenry> Polymorphism: I'll say that I think many conversations about what a language is good or bad at are usually flawed in that most programming languages are trying to be good at writing most software. 
14:23:46 <mmachenry> That said, Haskell does excel at write robust code that is easy to maintain. 
14:24:00 <monochrom> I would bet that json-printing is actually the one people want to fine-tune more manually, because there is high chance the exact json format is rigidly tied to external interfacing requirements.
14:24:03 <geekosaur> I don't use prettyprinters in general, so all I can point out is stuff I see in passing
14:24:29 <joe9> geekosaur: ok, Thanks.
14:24:37 <monochrom> Whereas people who ask for "deriving Pretty" seem to be "I'm lazy, just give me something".
14:24:39 <Polymorphism> lots of stuff to think about here, ty
14:25:04 <joe9> monochrom: I agree. It should be easier to use derive generic for Pretty than for json.
14:25:26 <joe9> monochrom: let me check on how aeson does it and then maybe I can leverage that to deriving Pretty too.
14:27:05 <monochrom> People stereotype programming languages like they stereotype movies, actors, and actresses.
14:27:18 <dolio> I think deriving pretty printing is basically impossible, and people who say 'just give me something' seem confused, and don't actually want pretty printing.
14:28:14 <dolio> Groom will do pretty layout of Haskell source, but it is not a pretty format for your type if you're just deriving what you see from Show.
14:29:41 <dolio> The pretty part of the former is seeing `\x -> x` instead of `Lam (VarName "x") (BoundVar 0)` though. :)
14:29:46 <monochrom> If there were an IRC channel for #benedict-cumberbatch, someone is bound to join and ask, "I'm trying to pick the next actor/actress I watch. Is Cumberbatch good at Marvel comic movies? Or is he just an academic type?"
14:30:04 <monochrom> And yet Cumberbatch just did a Marvel comics movie beautifully.
14:30:33 <monochrom> In addition to also being the voice of the wolf in Penguins of Madagasca.
14:30:56 <monochrom> All despite of his academic, theatre stereotype
14:33:01 <Welkin> he played in Sherlock for years o.o
14:33:06 <Welkin> and was also in the hobbit
14:38:04 <MarcelineVQ> But is Sylvester McCoy better for my specific needs and also in general?
14:38:20 <monochrom> :)
14:57:05 <joe9> which is recommended? DeriveGeneric or DeriveAnyClass? It appears that DeriveAnyClass is newer and better(?)
14:58:41 <Polymorphism> The stuff I read in here makes less sense than any other
15:06:55 <geekosaur> joe9, they do different things
15:19:18 <absence> anyone familiar with json-stream? i try to install it with stack, and get "fatal error: sys/uio.h: No such file or directory"
15:22:58 <geekosaur> absence, on what platform?
15:23:05 <geekosaur> (OS, not haskell)
15:23:47 <Polymorphism> sm if I reach the challenge and get stuck, start over?
15:26:51 <absence> geekosaur: windows
15:27:10 <geekosaur> that would be why, then. that's a unix/linux kernel header
15:27:30 <n_blownapart> https://www.refheap.com/123907 hi how do I print out x number of primeO inputs here?
15:32:51 <geekosaur> absence, so for what it is worth, I am going through the package source and don't see anything that actually requires <sys/uio.h> except maybe that they are getting C types from it that should come from somewhere portable
15:33:31 <geekosaur> none of the C code is platform specific
15:33:53 <geekosaur> so you might want to file a bug against json-stream that it is pointlessly POSIX specific and they should get their types from portable headers
15:34:39 <geekosaur> (or possibly it is a leftover because they pulled this out of some other package that did have POSIX specific operations)
15:37:52 <geekosaur> heh, right, they pulled this out of something that was using iovecs. but this is just parsing and doesn't handle input. possibly you could just remove the reference to <sys/uio.h> in lexer.c and it would work
15:39:20 <compsci_student> Which package should one use for using regex? Lazy evaluation is not needed and performance is not really an issue
15:39:25 <absence> geekosaur: can i do that locally and have stack use that instead of downloading?
15:40:19 <geekosaur> you'd have to pull the package from somewhere (don't know offhand if stack has a "get" operation or if you'd need to use "cabal get", but then just "stack install" without a package name, from the directory with the cabal file and/or stack.yaml
15:45:01 <monochrom> compsci_student: I can't say "should", but worth considering are these two: rex, regex-applicative
15:45:47 <compsci_student> monochrom: ooh, regex-applicative looks interesting. Thanks for the suggestions!
15:54:18 <Polymorphism> toUpper map "Chris"
15:54:25 <Polymorphism> why cant I just pass "Chris to toUpper
15:54:29 <Polymorphism> what is this map all about
15:54:48 <Polymorphism> map toUpper "Chris"
15:54:59 <Polymorphism> why not toUpper "Chris"
15:55:01 <Welkin> ...what?
15:55:06 <Welkin> :t toUpper
15:55:08 <lambdabot> Char -> Char
15:55:11 <Welkin> that's why
15:55:23 <Polymorphism> I dont understand map
15:55:28 <Polymorphism> Im at step 20
15:55:32 <Polymorphism> I went through twice
15:55:35 <Welkin> and you don't "pass arguments"
15:55:39 <Welkin> you apply functions over parameters
15:55:50 <Welkin> :t map
15:55:52 <lambdabot> (a -> b) -> [a] -> [b]
15:55:53 <Polymorphism> I dont pass arguments?
15:55:53 <compsci_student> map applies a function over every element in a list
15:55:55 <monochrom> "Chris" is syntax sugar for list-of-Chars, ['C', 'h', 'r', 'i', 's']
15:55:56 <Welkin> :t map toUpper
15:55:57 <hpc> Polymorphism: "Chris" :: [Char]
15:55:57 <lambdabot> [Char] -> [Char]
15:56:02 <hpc> toUpper :: Char -> Char
15:56:16 <hpc> Polymorphism: so you want something that can turn toUpper into something that acts on the type that "Chris" is
15:56:19 <hpc> and that thing is map
15:56:20 <hpc> :t map
15:56:21 <lambdabot> (a -> b) -> [a] -> [b]
15:56:27 <monochrom> toUpper is for Char not for list-of-Chars.
15:56:30 <hpc> Polymorphism: which takes a function that acts on elements
15:56:36 <hpc> Polymorphism: and produces a function that acts on lists
15:56:50 <Welkin> @let toUpperString = map toUpper
15:56:52 <lambdabot>  Defined.
15:56:52 <athan> Welkin: Those two ideas are isomorphic! :v
15:57:01 <Welkin> > toUpperString "Habari"
15:57:04 <lambdabot>  "HABARI"
15:57:28 <Welkin> athan: is it webscale too?
15:57:29 <xenon-> Poly, toUpper accepts a Char. "Chris" is a list of chars. map toUpper applies toUpper to every char and collects and returns the results
15:57:37 <monochrom> yeah there is not much need to draw a line between "pass" and "apply". at least for now.
15:57:38 <athan> Polymorphism: Technically, someone should say "apply f to x", not "apply x to f", even though I use the latter :x
15:58:09 <monochrom> but yeah beware of subject vs object
15:58:12 <xenon-> athan i always confuse the order
15:58:18 <monochrom> bloody transitive verbs :)
15:58:29 <athan> arrows ftw
15:58:29 <Welkin> under over on inside
15:58:30 <Polymorphism>  I'm not sure if I'm more confused or less
15:58:37 <Polymorphism> is map just for toUpper?
15:58:41 <Polymorphism> or does it work with other funcs
15:58:49 <Welkin> Polymorphism: have you read any haskell material at all?
15:58:53 <athan> to the part with the thingy
15:58:53 <monochrom> no, map f [a,b,c] = [f a, f b, f b]
15:58:55 <Welkin> @learnhaskell
15:58:55 <lambdabot> Unknown command, try @list
15:58:55 <Polymorphism> I'm following the tutorial Welkin
15:58:57 <Polymorphism> starting at step 1
15:58:58 <Welkin> @where learnhaskell
15:58:59 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:59:02 <Welkin> what tutorial?
15:59:03 <Polymorphism> https://tryhaskell.org/
15:59:05 <xenon-> there isn't a function that doesn't work with map
15:59:07 <Welkin> I have no idea what you are talking about
15:59:08 <monochrom> err, map f [a, b, c] = [f a, f b, f c].  This is general.
15:59:09 <Welkin> I never used that
15:59:16 <Welkin> use the link I provided
15:59:16 <Polymorphism> see how far you can get
15:59:20 <Welkin> it is a real university course
16:00:04 <Polymorphism> I'll take a look
16:00:12 <monochrom> what does tryhaskell suggest for reading material?
16:00:38 <Welkin> it doesn't suggest anything
16:00:47 <Welkin> it looks useless to me
16:01:00 <monochrom> Oh, it is its own reading material, it already explains answers.
16:01:07 <Welkin> it's just an embeded terminal with a subset of ghci
16:01:21 <monochrom> no, it explains little
16:01:48 <Polymorphism> I'm using it to learn haskell
16:01:52 <Welkin> don;t
16:01:56 <Welkin> it looks horrible
16:01:59 <Welkin> you need a *real* course
16:02:12 <Welkin> which is even more obvious from your questions
16:02:22 <Welkin> otherwise you'll never understand a thing
16:02:29 <Polymorphism> I'll try the link you sent
16:02:52 <Polymorphism> it just seems odd, someone here advised me to go with that
16:02:56 <Welkin> even Learn You a Haskell is a better resource
16:03:00 <athan> bitemyapp has spent a lot of love and time making that course Polymorphism, you'll be in good hands
16:03:30 <xenon-> Polymorphism what languages are you coming from?
16:03:38 <athan> also consider their book, but imo you should support diversely :)
16:03:39 <monochrom> It does explain map toUpper "chris".  "You just passed toUpper to map".
16:03:48 <monochrom> (There is more.)
16:04:10 <monochrom> visit this url http://tryhaskell.org/#step20 to see how it explains it.
16:04:15 <Polymorphism> xenon-: C++/C#/Python
16:04:33 <xenon-> python has map. C# has something similar
16:04:35 <MarcelineVQ> athan: course?
16:04:37 <monochrom> I do not imagine any IRC conversation that says anything more.
16:04:58 <monochrom> And books and courses cannot say more either. What they can do is to repeat it more times.
16:05:48 <Polymorphism> how does it work?
16:05:50 <Polymorphism> its just magic?
16:05:55 <xenon-> @src map
16:05:55 <lambdabot> map _ []     = []
16:05:55 <lambdabot> map f (x:xs) = f x : map f xs
16:06:04 <Welkin> it is all recursive function definitions
16:06:05 <Welkin> everything is
16:06:06 <xenon-> no magic
16:06:09 <monochrom> But it's true that many students don't need extra information, they just need repetition.
16:06:21 <xenon-> it just applies function to every element in a list, and accumulates results into a new list
16:06:39 <Welkin> in this case it builds the list in place
16:06:44 <Polymorphism> xenon-: why didnt the tut just say that
16:07:36 <xenon-> no clue. explanation it has for map is pretty lame
16:07:56 <MarcelineVQ> because it's a tutorial for a tool, allthough this isn't a bad tutorial from what I can see. A little too informal
16:08:32 <xenon-> perhaps it assumes you know map from other languages
16:15:00 <stobix> If I have a 2x2 grid in which I want to move a pointer freely in all four directions, is there a good functional data structure to model this? Imperatively, I'd just have a mutable matrix.
16:16:31 <dibblego> but each cell has only two directions
16:18:51 <stobix> Depends on how you view it. Has a single linked list one or two directions?
16:19:34 <stobix> But, yeah, two axes of movement.
16:20:10 <johnw> stobix: the "pointer" can just be a pair of x,y coordinates?
16:20:20 <Welkin> stobix: just use a map indexed by (Int, Int)
16:20:28 <Welkin> and wrap the Int based on the size of the grid
16:21:08 <stobix> johnw: Yes, that's the plan. :)
16:21:46 <stobix> Welkin: What is a map in this case?
16:22:00 <Welkin> stobix: Data.Map
16:22:18 * stobix reads up on Data.Map
16:45:28 <Xyliton> ertes: Did you "update" the "guessing game" challenge last time?
16:46:23 <Welkin> Xyliton: your name is one letter away from being an artificial sweetener
16:46:37 <Xyliton> Welkin: really? xD
16:46:45 <Welkin> xylitol
16:47:54 <Xyliton> lol
16:58:00 <Xyliton> Is working on the "99 questions" a good start at learning Haskell, or should I do some other stuff?
17:01:46 <Welkin> no, it's not
17:02:03 <Welkin> that is possibly the worst way anyone ever thought of
17:02:17 <Welkin> those exercises are taken directly from lisp
17:02:31 <Welkin> @where learnhaskell -- Xyliton use this
17:02:31 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:02:48 <ggVGc> 99 bootles of beer on the wall!
17:02:49 <ggVGc> though
17:02:54 <ggVGc> is probably a good excercise
17:03:06 <ertes> Xyliton: i saw your solution, and together with everything that was said in response, i think it's pretty much solved now =)
17:03:11 <ertes> Xyliton: and good work!
17:03:29 <ertes> Xyliton: now i would upgrade it to a hangman game
17:03:44 <ertes> Xyliton: *if* you still want to do games
17:04:20 <ertes> hangman adds data structure considerations and slightly more complicated control
17:04:23 <Welkin> ertes: which reminds me, is netwire/wires dead?
17:04:43 <Xyliton> ggVGc: can't you solve that in... two lines? 
17:04:50 <ertes> Welkin: netwire is in maintenance mode, i.e. only bug fixes and contribution reviews/applications
17:05:19 <ggVGc> Xyliton: not if you've never written any haskell before
17:05:25 <sm> Xyliton++! game completed
17:05:34 <ggVGc> or, well, yes, it might be two lines anyway. But those two lines might take a while to write
17:05:42 <ertes> Welkin: wires is in slow development mode and is the successor of netwire
17:06:37 <Xyliton> Is it possible to generate a random word in Haskell?
17:06:56 <Xyliton> If that isn't possible, is it possible to fetch a website using Haskell?
17:06:56 <ertes> Welkin: (not in that it replaces netwire (it doesn't), but in that it's the abstraction i'm going for in the future)
17:06:57 <grantwu> yes
17:07:18 <ertes> Xyliton: https://hackage.haskell.org/
17:07:48 <Welkin> Xyliton: yes, using Random
17:07:58 <Welkin> there are also several http clients in haskell
17:08:09 <Xyliton> Welkin: but would that actually return a (real) world?
17:08:13 <ertes> Xyliton: here is the full list of packages on hackage (the main hub for haskell packages): https://hackage.haskell.org/packages/
17:08:13 <Xyliton> *word
17:08:16 <grantwu> Why do you think these things might be impossible?
17:08:16 <grantwu> Haskell is a general purpose programming language used in both academia and industry.  Why would basic things be impossible
17:08:25 <ertes> Xyliton: to get an overview of what is currently implemented
17:08:38 <grantwu> Xyliton: Define real word?  A word in a dictionary?
17:08:43 <Welkin> lol
17:09:01 <Xyliton> yea
17:09:06 <ertes> Xyliton: for specific applications it's a good idea to ask here about which library you should use, because we tend to have multiple libraries for most things, each with unique strengths and weaknesses
17:09:23 <Xyliton> Unless you want to play hangman with made-up words :P
17:09:29 <Welkin> Xyliton: if you have lots of experience with web apps, use yesod, or perhaps servant
17:09:29 <grantwu> Yes, you can store a list of words, generate a random number n, and you get the nth word
17:09:47 <Welkin> Xyliton: if you are new to web apps, start with scotty and go from there
17:09:50 <ertes> Xyliton: you can do the random word part later, if you want…  the most important part is the game logic
17:10:04 <Xyliton> ertes: Okay
17:10:28 <Xyliton> How do I rewrite the current line (or one above) in the shell?
17:10:35 <ertes> (the random word part is interesting though, not as a *haskell* challenge, but as a more generic programming challenge) =)
17:10:49 <ertes> rewrite?
17:11:19 <Welkin> ertes: "generic programming" challeng?
17:11:36 <Xyliton> if you use wget it shows a loading bar for example; it appears to be in the same line although it changes
17:11:37 <ertes> Welkin: generic (programming challenge)
17:11:44 <ertes> not (generic programming) challenge
17:11:58 <Welkin> lol
17:12:00 <ertes> Xyliton: ah, you just print \r
17:12:25 <ertes> Xyliton: try this:  putStrLn "hello world!\rbye  "
17:12:44 <Xyliton> (generating words (which are nonsense though) is as easy as adding a vocal and a consonant together and reapeating that :D)
17:13:20 <ertes> Xyliton: i'd use a markov chain for that =)
17:13:25 <Xyliton> ertes: thanks ^^
17:13:54 <ertes> if you make the chains long enough, it tends to generate bullshit text, but with almost real words =)
17:14:26 <ertes> Xyliton: that wasn't a suggestion, because a markov chain-based text generator is actually a bit challenging to implement properly =)
17:14:42 <ertes> but if you want to do it, go ahead!
17:15:31 <Xyliton> first I'm going to get the actual game working. Then I can decide about the source of the string :) 
17:15:48 <Dang> hey guys
17:16:16 <lambdabot> Hello.
17:16:52 <Welkin> AH!
17:16:54 <Welkin> it's alive
17:17:09 <Guest62519> http://lpaste.net/342866
17:17:14 <Guest62519> would anyone help me with this error
17:17:41 <Guest62519> scroll all the way down for the error
17:17:49 <Welkin> exactly what it says
17:17:56 <Welkin> you didn't match all the possible patterns
17:17:59 <ertes> Guest62519: compile/interpret your code with the -Wall flag
17:18:01 <Welkin> you forgot the empty list case
17:18:19 <ertes> Guest62519: the compiler will emit helpful warnings
17:18:22 <Guest62519> so should i handle the empty list in the function that call get1d ?
17:18:32 <Guest62519> or in the get1D itself
17:18:42 <ertes> get1D itself
17:25:35 <Xyliton> How do I go up one line in the shell?
17:26:22 <Welkin> what shell?
17:26:41 <Welkin> it depends on your terminal emulator
17:26:44 <Xyliton> oh
17:26:58 <Welkin> what do you mean y go up?
17:27:17 <Welkin> if you press the up arrow, you can usualy access your previous commands
17:27:34 <Xyliton> I want to modify some line I printed to the terminal earlier 
17:27:36 <glguy> I expect Xyliton is trying to draw his Hangman UI and wants to move the cursor around a bit
17:28:03 <Welkin> Xyliton: you just keep the state in your program and redraw the entire screen
17:28:16 <Welkin> there is curses/ncurses or something that can do it for you I think though
17:28:30 <Xyliton> how do I clear the terminal then?
17:28:42 <Guest62519> *Main> get1D [1,2,3] 2 3 *Main> get1D [1,2,3] 3 *** Exception: csce322hw03pt02.hs:(72,1)-(74,44): Non-exhaustive patterns in function get1D
17:28:47 <Guest62519> is that mean its out of bound
17:29:29 <geekosaur> Xyliton, generally you use a library like brick or hscurses
17:30:19 <geekosaur> you could blindly send the ANSI up sequence, but note that the program does not know what it is modifying in that case; libraries will keep track of that
17:30:49 <Guest62519> how can I implement the library? 
17:31:43 <Guest62519> arr nvm you wasnt talking to me lol
17:33:02 <glguy> terminfo for simple things like clearing the screen or setting some colors or moving the cursor  http://hackage.haskell.org/package/terminfo-0.4.0.2/docs/System-Console-Terminfo-Edit.html#v:clearScreen
17:33:32 <geekosaur> Guest62519, as to yours, note that indexes usually start from 0, so you asked for the 4th item in a 3-item list and it hit the [] case and crashed because you don't handle []
17:33:39 <glguy> Guest62519: It means you didn't handle the empty list case in your definition of get1D
17:33:56 <Guest62519> how can I handle the [ ] ?
17:34:19 <glguy> Guest62519: like you did on line 81 in find2D
17:34:55 <Guest62519> csce322hw03pt02.hs:74:7: error: parse error on input ‘|’ 
17:35:01 <Guest62519> that gave me an error
17:35:05 <Guest62519> get1D _ [] = []        | ind == 0	= col       | otherwise	= get1D cols (ind-1)
17:35:29 <glguy> I don't mean try to copy and paste exactly what you wrote in that case without thinking about what it means
17:35:53 <glguy> I mean that on line 81 you provided a case for [], so that's an example of how one handles the [] case
17:44:03 * hackagebot users-mysql-haskell 0.5.0.0 - A mysql-haskell backend for the users library.  https://hackage.haskell.org/package/users-mysql-haskell-0.5.0.0 (DanielDiazCarrete)
17:44:48 <Xyliton> Where is the executable located when building with stack? I searched through the dist folder but I can't find anything :/
17:45:44 <MitchellSalad> Xyliton: do "stack exec which <exe>"
17:45:59 <MitchellSalad> or, "stack path | grep bin", or something
17:46:08 <ertes> Xyliton: if you want to give your name a fancy UI and use pretty much anything other than windows, you can use the 'vty' library
17:46:20 <ertes> s/name/game/
17:46:27 <Welkin> Xyliton: .stack-work/........./dist/build/projectname/projectname
17:46:37 <Welkin> that is where `stack build` puts it
17:46:42 <Welkin> that is in your porject directory
17:46:53 <Welkin> if you use `stack install` it copies it to ~/.local/bin/projectname
17:47:53 <Xyliton> ertes: I decided to use brick because it looked rather easy to use
17:49:02 <ertes> Xyliton: yeah, brick is based on vty
17:49:28 <Xyliton> Okay, after reading the examples I decided to "nope" out of it. That looks like way too much boilerplate to me
17:52:27 <Xyliton> the docs seem so confusing to me ;-;
17:54:03 * hackagebot users-mysql-haskell 0.5.0.1 - A mysql-haskell backend for the users library.  https://hackage.haskell.org/package/users-mysql-haskell-0.5.0.1 (DanielDiazCarrete)
18:05:04 <jval> I'm trying to use the sdr library on hackage, but when I build my project with stack it gives me Missing C library: fftw3 for the fftwRaw package, even though I have it installed (I'm on macOS). Any suggestions? 
18:06:22 <ishiz> Why do trivial recursive functions in GHCi on Mac hang followed by Stack Overflow?
18:06:48 <athan> ishiz: It depends on the function
18:06:49 <Welkin> ishiz: the website?
18:07:04 <athan> > let fix f = let x = f x in x in fix id
18:07:05 <ishiz> Welkin: lol no, sorry, don't know why I capitalized
18:07:09 <lambdabot>  mueval-core: Time limit exceeded
18:07:21 <Welkin> > 0/0
18:07:23 <lambdabot>  NaN
18:07:46 <athan> jval: At what point in compilation? Linking, or source compiling?
18:07:54 <Welkin> > show 0/0
18:07:56 <geekosaur> jval, how did you install it?
18:07:57 <lambdabot>  error:
18:07:57 <lambdabot>      • No instance for (Fractional String) arising from a use of ‘/’
18:07:57 <lambdabot>      • In the expression: show 0 / 0error:
18:08:07 <ishiz> athan: I figured out my problem, I'm an idiot. Defining it all in one line fixes the problem.
18:08:16 <athan> :)
18:08:20 <athan> good luck!
18:08:48 <jval> geekosaur: with homebrew
18:10:53 <Welkin> > (++ "... BATMAN!") . concat . replicate 10 . show $ 0/0
18:10:57 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaN... BATMAN!"
18:10:58 <Welkin> :D
18:11:05 <athan> rofl
18:11:19 <athan> m-m-megakill
18:11:24 <geekosaur> you might have to point to /usr/local/include and /usr/local/lib specifically; they are not part of the standard include and library search paths in Apple's compilers any more
18:11:29 <jval> athan: um, when I run stack build on my project it says: While building package fftwRaw-0.1.0.1 ....  * Missing C library: fftw3 so I guess linking?
18:11:48 <athan> jval: No, I think that means it can't find the .h include files
18:12:24 <athan> shoot, does osx have locate? Have you tried searching for fftw3's header files etc.?
18:12:27 <jle`> ishiz: what version of ghc are you using?
18:12:31 <jle`> ghc hasn't stack overflowed in a long time
18:12:49 <ishiz> jle`: was my fault, not ghci
18:12:50 <Welkin> jval: install everything you need with homebrew
18:12:55 <Welkin> it will put it on your path
18:13:10 <jle`> ishiz: i mean, it's weird to see a "stack overflow" error on ghci
18:13:16 <jle`> like, it doesn't print that out anymore
18:13:26 <jle`> even if you have an infinite loop bug
18:13:56 <jval> athan: ok, but I'm not sure what to do. In my stack.yaml I added the folder location in extra-include-dirs for the missing library
18:13:57 <Welkin> > foldl (+) 0 [1..1000000]
18:14:00 <lambdabot>  *Exception: stack overflow
18:14:02 <ishiz> jle`: installed with homebrew. ghc-8.0.1.20161022
18:14:02 <Welkin> :D
18:14:50 <Welkin> > foldr (+) 0 [1..1000000]
18:14:52 <lambdabot>  *Exception: stack overflow
18:14:55 <Welkin> lol
18:15:00 <Welkin> > foldl' (+) 0 [1..1000000]
18:15:02 <lambdabot>  500000500000
18:15:29 <Welkin> just add a golem (') to theend of it and it works
18:16:06 <Hafydd> A golem?!
18:16:10 <Welkin> yeah
18:16:27 <Welkin> https://nethackwiki.com/wiki/Golem
18:16:36 <Hafydd> I see...
18:17:03 <jval> Welkin: I did install the c libraries with homebrew but stack can't find them
18:18:32 <Welkin> I have use this on osx to have my program find sdl `pkg-config --cflags --libs sdl2`
18:18:33 <geekosaur> you need extra-lib-dirs to point to /usr/local/lib as well
18:18:38 <Welkin> as part of the compile command
18:18:55 <geekosaur> and make sure that libfftw3.so and/or libfftw3.a are present there
18:29:18 <Lerrpy> I have a question that might be a little dumb but I've been wondering
18:29:32 <Lerrpy> when is functional programming used?
18:30:18 <peddie> Lerrpy: you might as well ask "when is programming used?"
18:30:52 <peddie> "usually when people have a problem they want to solve with computers"
18:31:19 <Lerrpy> that's a really good answer
18:33:57 <Lerrpy> I just started studying cs and it's all very interesting but my uni doesn't really teach any fp
18:38:42 <jval> Welkin: now I get Failed to load interface for ‘Gtk2HsSetup’
18:49:05 * hackagebot users-mysql-haskell 0.5.1.0 - A mysql-haskell backend for the users library.  https://hackage.haskell.org/package/users-mysql-haskell-0.5.1.0 (DanielDiazCarrete)
18:50:57 <joe9> What does DeriveAnyClass do? I cannot seem to find any simple explanations to it. I am trying to create a typeclass with derive'able instances. Am I better off learning about DeriveGeneric or can DeriveAnyClass help?
18:55:25 <ertes> Lerrpy: that's weird, because CS usually touches at least things like lambda calculus
18:56:10 <Lerrpy> well it's not exactly "CS", I meant the field in general. I don't know what program is equivalent to mine
18:56:32 <Lerrpy> I'm in QC, canada, and I'm taking "génie logiciel", software engineering
18:57:19 <Lerrpy> we do see a little bit of stuff like that but so far it's been in passing
18:57:46 <ertes> much of the software engineering world seems to focus mainly on OOP
18:58:16 <Lerrpy> yea
18:58:40 <Lerrpy> I think there are optional classes that deal with fp 
18:58:55 <geekosaur> joe9, DeriveGeneric derives instances for the Generic typeclass. it does nothing else, in particular it does not in and of itself derive any other instances. But other typeclasses may have instances conditional on a Generic instance that act like they are automatically deriving instances of their own
19:00:26 <ertes> Lerrpy: disclaimer: i view OOP is the worst possible solution for any problem that you could consider throwing at it…  but i recommend taking those classes for another reason: to know an alternative
19:01:01 <Lerrpy> hahah I think OOP is neat right now. But My view is really narrow
19:01:04 <ertes> in software engineering it can be expensive to know only one way
19:01:10 <geekosaur> DeriveAnyClass just lets you list any class to be derived, and generates a stub instance with no implementation. This is useful when the default implementation falls back to generics, as those classes would otherwise need to use overlapping instances to add an instance that uses generics
19:01:30 <Lerrpy> I definitely WANT to know other ways. FP just seems so, so elegant
19:01:38 <geekosaur> So they are often used together, but each one does something distinct, they are not alternatives
19:01:43 <ertes> it is =)
19:01:52 <Lerrpy> I've been reading learn you a haskell in my spare time
19:01:56 <Lerrpy> which is not a lot right now
19:02:03 <Lerrpy> it wows me
19:02:38 <geekosaur> joe9, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-instances-of-extra-classes-data-etc for DeriveGeneric, and https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class for DeriveAnyClass
19:02:43 <Lerrpy> so if my university won't teach me, I'll learn me a haskell anyway
19:03:23 <joe9> geekosaur:  Thanks.
19:03:28 <lambda-11235> I think the most beutiful example of functional programming's elegance if Okasaki's paper on red black trees.
19:03:52 <juri_> ok, i stared at it for more than five minutes...
19:04:17 <ertes> i'm glad you pointed out a legitimate example, and not the terrible quicksort or the fake prime sieve =)
19:04:17 <geekosaur> (note also that DeriveAnyClass is potentially dangerous because it really does mean *any* class; but any class that has required type family or method implementations will not work well with this, and you probably need to compile with full warnings to find out you did this)
19:05:16 <juri_> I've got a data, with two constructors. I'd like to seperate a list of that type into two seperate lists, based on which constructor was used.
19:06:19 <Lerrpy> lambda-11235, the things linux uses for scheduling processes?
19:07:30 <ertes> juri_: do you have a question?
19:07:34 <juri_> [ x | Tris x <- sqTris ] seems to work, but... oh, i think i see.
19:07:46 <juri_> explaining the problem sometimes helps. ;)
19:08:06 <joe9> juri_ check out partitionEithers
19:08:08 <lambda-11235> Lerrpy: Isn't that a heap? Red black trees are usually used to implement maps or sets.
19:08:16 <ertes> juri_: note that it uses the list comprehension feature of treating pattern mismatch as *empty*
19:08:31 <ertes> > [ x | Just x <- Nothing ]
19:08:34 <lambdabot>  error:
19:08:34 <lambdabot>      • Couldn't match expected type ‘[Maybe t]’
19:08:34 <lambdabot>                    with actual type ‘Maybe a0’
19:08:40 <ertes> > [ x | Just x <- [Nothing] ]
19:08:44 <lambdabot>  []
19:09:17 <Lerrpy> https://en.wikipedia.org/wiki/Completely_Fair_Scheduler lambdabot 
19:09:20 <Lerrpy> oops
19:09:23 <Lerrpy> lambda-11235, 
19:09:37 <geekosaur> lambda-11235, a priority search queue can be implemented as a heap and associated tree, and is useful for scheduling
19:09:48 <juri_> yea, i'm having a problem with constructors that are complicated.
19:09:58 <juri_> i had run across that construct already.
19:10:16 <geekosaur> can you show an example?
19:10:23 <ertes> juri_: what makes a constructor complicated for you?
19:11:31 <lambda-11235> Lerrpy: Ah, ok. Yeah, that thing.
19:11:48 <geekosaur> also, you can do that without having to deconstruct: [x | x@(C1 {}) <- theList ] pulls the items whose constructor is C1
19:11:52 <Lerrpy> not that I know anything about red-black trees
19:12:22 <ertes> geekosaur: that does something different though
19:12:23 <geekosaur> and doesn't require you to know what's inside a C1 constructor; it just sends the values over, whatever they are
19:12:23 <Lerrpy> it was mentioned in passing during in computer structure class
19:12:26 <Lerrpy> like many things
19:12:43 <geekosaur> it does, which is correct if C1 is not wrapping a single value
19:13:05 <geekosaur> un less you're replacingt he constrctor with a tuple, which is somewhat dubious
19:13:37 <ertes> geekosaur: i think in the cases when you're actually splitting a list in this way, you're interested in removing uncertainty
19:13:46 <ertes> like:  [Either e a] -> ([e], [a])
19:13:55 <ertes> so a tuple, in some cases, may be the right choice
19:14:17 <lambda-11235> Lerrpy: I tried learning from imperative examples on my own, but they were very complicated, which is probably why they probably weren't mentions in data structures.
19:14:40 <Lerrpy> learning red-black trees?
19:15:14 <geekosaur> I;m not asserting this is Always The Right Way, ertes. I'm pointing that for some uses (and they did not say *what* they are doing but "complicated constructors" makes me suspicious) this may work better
19:15:19 <juri_> ok, i'm completely screwing up my types.. but i'm making the problem 'move'. i'll figgure this out.
19:15:21 <Lerrpy> I loved the tiny bit of graph theory we did so far. I'm kind of excited for more "theoric" computer science 
19:15:29 <geekosaur> @paste
19:15:29 <lambdabot> Haskell pastebin: http://lpaste.net/
19:15:45 <geekosaur> juri_ ^ pasting actual code and perhaps example uses and expected results might help
19:16:02 <geekosaur> right now e can only guess and toss out random constructs that might or might not help
19:16:06 <geekosaur> *we can
19:16:13 <juri_> sure.
19:16:15 <ertes> geekosaur: actually they did further above =) though only in prose
19:16:17 <juri_> 1 sec.
19:17:52 <lambda-11235> Lerrpy: I'm actually taking a data structures class now. However, it's in C++, so I find myself studying persistant data structures and implementing some of them in haskel.
19:18:06 <lambda-11235> (outside of class)
19:18:15 <Lerrpy> hahah nice
19:18:22 <Lerrpy> do you dislike c++
19:18:44 <Lerrpy> ...does anyone like C++?
19:18:49 <juri_> http://lpaste.net/342897
19:19:17 <xcmw> If I have a type G a how can I reprentent a list of G a. a varies throughout the list.
19:19:25 <Xandaros> Is there some kind of “dependent maybe” type? Basically, I have a value where the value might not be present, but the present-ness should be known at compile-time
19:19:41 <juri_> reload that. forgot a line.
19:19:51 <ertes> Lerrpy: i wouldn't say that i *like* it, but i don't mind it either…  at least it has enough language support to work with algebraic abstractions, if you torture it long enough
19:19:55 * geekosaur kinda gets tired of having to hunt through standards references to figure out if something can be safely simplified or if it has to be done the long way to make sure the right initializers run >.>
19:20:00 <juri_> that's after i've been butchering it.
19:20:03 <geekosaur> (this actually came up elsechannel last night)
19:21:10 <ertes> juri_: i recommend that you follow the convention of naming lists with an "s" at the end to indicate plural
19:21:30 <ertes> juri_: like this: [ xs | Tris xs <- sqTris ]
19:21:36 <geekosaur> xcmw, you can't do that without an existential wrapper, which has its own problems.
19:21:42 <Lerrpy> ertes, again, this might be a fussy inexperienced opinion but C++ hasn't been any fun to me so far
19:21:44 <juri_> ok, that makes sense. :)
19:21:47 <geekosaur> a list has to have a concrete type, not "forall a. G a"
19:22:29 <ertes> juri_: also write a type signature for 'triTriangles' on line 9
19:22:34 <Lerrpy> it's so tortuous and freeform
19:22:43 <xcmw> geekosaur: If I enable ImprecativeTypes is that restriction removed?
19:22:44 <ertes> juri_: do you think it should be [Triangle]?
19:22:52 <geekosaur> xcmw, no
19:22:53 <juri_> yes.
19:23:12 <ertes> juri_: that's what i thought =)
19:23:22 <juri_> i'm getting [[triangle]], according to the compiler.
19:23:34 <ertes> juri_: and that's what you should be getting
19:23:38 <ertes> juri_: do you see why?
19:23:44 <juri_> no. :)
19:24:07 * hackagebot users-mysql-haskell 0.5.2.0 - A mysql-haskell backend for the users library.  https://hackage.haskell.org/package/users-mysql-haskell-0.5.2.0 (DanielDiazCarrete)
19:24:08 <ertes> juri_: you have a value (Tris blah), what's the type of 'blah'?
19:24:22 <juri_> oh.
19:24:27 <juri_> ok, that makes sense.
19:24:53 <juri_> so, how do i unwrap it?
19:25:05 <ertes> juri_: either never wrap it in the first place, or use 'concat'
19:25:20 <ertes> > concat [[1,2,3], [4,5,6], [7,8,9]]
19:25:22 <lambdabot>  [1,2,3,4,5,6,7,8,9]
19:25:37 <juri_> ok, that makes sense.
19:25:46 <ertes> juri_: another thing you can do, because you're in a list comprehension, is:
19:26:05 <ertes> [ tri | Tris tris <- sqTris, tri <- tris ]
19:26:28 <geekosaur> xcmw, there is the HList (heterogeneous list) library on hackage, but that has other complications. in any case, you can't make a normal list of polymorphic type
19:26:43 <Xandaros> Guess I'll just define my own DependentMaybe type for now
19:26:54 <geekosaur> (HList is not a Haskell list and none of the standard list operations work with it, you need to use HList's accessors)
19:26:56 <juri_> so that unwraps the 'data'.
19:27:05 <juri_> that makes sense.
19:27:20 <ertes> Xandaros: i'm not sure what you mean?
19:27:45 <ertes> juri_: in list comprehensions you can refer to earlier values bound by "<-"
19:28:07 <geekosaur> Xandaros, compile time makes me think you want a phantom type
19:28:16 <geekosaur> possibly in the form of a Proxy
19:28:19 <ertes> > [ (x, y) | x:ys <- tails "abcdef", y <- ys ]
19:28:21 <lambdabot>  [('a','b'),('a','c'),('a','d'),('a','e'),('a','f'),('b','c'),('b','d'),('b',...
19:29:04 <geekosaur> (but note that you run then into xcmw's issue; you can't make a single list of them if you are differentiating them at the type level instead of the value level)
19:29:05 <Xandaros> geekosaur: Kinda... What I have now is a type "DependentMaybe Bool a", with the Bool type-argument detailing whether the value is present or not
19:29:56 <Xandaros> Can't I make a list of `DependentType p a`? (I don't need lists of them, though)
19:30:33 <ertes> Xandaros: DepMaybe False a ≃ (); DepMaybe True a ≃ a  -- do you really need such a type?
19:30:54 <ertes> i guess it could make sense, if you do type-level computation with the boolean
19:32:19 <Xandaros> Well... I have a record with a field that could be absent. However, I know statically where it is absent and where it isn't. I'd like to use this fact and not use a plain Maybe
19:32:52 <ertes> Xandaros: you can abstract this way:  data MyType f = A (f Int) (f Bool) …
19:32:56 <Xandaros> My first thought was actually to have two records, one with the field present and one without... but that seems pretty bad to me :D
19:33:03 <juri_> ok, that's solved half of my problem (and taught me something. :)
19:33:15 <ertes> Xandaros: then you can use MyType Identity, MyType (Const ()), MyType Maybe
19:33:47 <ertes> would that help?
19:34:31 <Xandaros> I thought about that, but... I don't know. Seems a bit too general to me
19:35:07 <ertes> Xandaros: the more general something is, the more you can rely on parametricity (and as a bonus the longer it takes before you hit the expressivity wall) =)
19:36:19 <ertes> the other useful thing is that you would never need to specify Identity on construction…  you would just use an (Applicative f) constraint
19:36:28 <Xandaros> Here's another thought: In my example, I only have one such field. But what if I have multiple? I'd have to either have a type parameter for each such field, or require they all be present/absent simultaneously
19:36:42 <ertes> then your smart constructor works with Identity and Maybe
19:37:05 <ertes> sure, you would have that with the dependent Maybe, too
19:37:10 <juri_> ertes: got it. :)
19:37:32 <ertes> juri_: great =)
19:37:46 <Xandaros> I think I'll try the dependent Maybe - it seems to most obvious solution to me
19:38:07 <ertes> Xandaros: is this about run-time configuration?
19:38:11 <juri_> ertes: reload http://lpaste.net/342897
19:38:54 <juri_> bonus, i actually know what i did. \o/
19:39:22 <Xandaros> It's actually a servant API, where I have id fields for some data types. The user has to supply such Objects in the request body at times, but never supplies an id. However, when I retrieve things from the DB, I know the id to always be there
19:39:23 <ertes> juri_: note:  concat (map f xs) = concatMap f xs  -- it's common enough that we have a function for that =)
19:40:03 <Xandaros> Thinking about it, I don't actually know whether I can make use of knowing statically whether it's there or not... maybe a plain Maybe would suffice
19:40:05 <ertes> Xandaros: oh!  in that case i found it more useful not to have the id field in the record at all
19:40:25 <Xandaros> Well... it's also used in responses :P
19:40:40 <juri_> :D
19:40:57 <ertes> Xandaros: nothing wrong with that…  respond with a tuple
19:41:12 <ertes> (the haskell representation doesn't have to match the JSON/XML)
19:41:23 <Xandaros> Hmm, that is true
19:41:54 <Xandaros> Though I don't know how to tell servant that
19:42:17 <juri_> ertes: thanks again. :)
19:42:18 <Welkin> Xandaros: what are you usin for the database?
19:42:26 <Xandaros> Welkin: acid-state
19:42:28 <ertes> Xandaros: well, you can make a separate type WithId
19:42:45 <Welkin> if you use Persistent, it gives you an Entity which contains the id (from the table) and the other row data
19:43:30 <Welkin> Entity Int64 TableRow
19:43:47 <shubhaml> i'm writing an interpreter using this monad: newtype Interpreter a = Interpreter (StateT Vars IO a)
19:43:54 <ertes> Xandaros: WithId k a ≃ (k, a)  -- but with aeson instances that add the id field in ToJSON and correspondingly intercept it in FromJSON
19:44:13 <Welkin> I ran into issue with what to provide from my api when I wrote the whole app in the client
19:44:21 <Welkin> RESTful apis are a fantasy
19:44:36 <Welkin> I had to modify it to make it work for what the client needed
19:45:05 <Xandaros> Yeah, REST certainly has its shortcomings
19:45:50 <shubhaml> it's a brainfk interpreter, Vars is set of records. is it the idiomatic way to use monads/StateT?
19:47:12 <ertes> shubhaml: it's a common way to use StateT, and since brainfuck is highly stateful, that's basically how i would have done it (except perhaps without the Interpreter wrapper)
19:47:52 <Xandaros> Probably would've done it like that, but I agree with the wrapper :P
19:47:58 <Xandaros> s/but/and
19:48:31 <Welkin> does it make sense to open another port (besides port 80) to run another web server, because keter is already using port 80 for all my haskell apps? (and this other one will be a non-haskell app)
19:48:48 <ertes> the problem is: as soon as you create such a wrapper type you pretty much commit to writing/deriving all those instances =)
19:48:48 <Welkin> and then have to access it using domain.tld:port
19:49:40 <Xandaros> Welkin: Either that, or find some way of routing it all through 80. (e.g. web server [apache/nginx/...] config and use different internal ports which are not accessible from outside)
19:50:38 <Xandaros> I personally would use nginx and have it redirect depending on subdomain or uri
19:50:40 <Welkin> I'm wonder if there is even an easy way to run this thing using keter
19:50:40 <Welkin> https://posativ.org/isso/docs/configuration/server/
19:50:50 <shubhaml> ertes: didn't try using the newtype without the wrapper, seems like a good idea
19:50:55 <Welkin> I'd hate to have to install all sorts of extra stuff just to run this python server
19:51:17 <Welkin> keter needs to pass the app the port through the environment though
19:51:41 <ertes> shubhaml: i meant: i'd just use StateT
19:51:44 <Xandaros> The problem with not using the wrapper: You end up with functions like "get" and "put" that don't make any semantic sense. (Although in this case, it's not too bad)
19:51:58 <ocramz> hullo
19:52:15 <ertes> shubhaml: StateT is a tool, and if you create a wrapper type every time you use it, you kinda defeat its purpose
19:52:48 <ertes> wrapper types are useful in the context of a reusable DSL
19:52:56 <shubhaml> ertes: ok, makes sense
19:56:24 <ocramz> I have a typeclass design question: let's say we need to blend two or more classes, but actually we only need a single free parameter (let's say of kind *). What's better, to provide the other parameters as typeclass constraints or method constraints?
19:56:26 <glguy> Wrapping StateT in a newtype certainly doesn't defeat the purpose of having StateT in general
19:59:00 <glguy> It's a good idea to wrap StateT in a newtype, hiding its typeclasses like MonadState which generally aren't appropriate for the problem at hand though they might be helpful in implementing the problem specific operations you'll need
19:59:18 <glguy> The functor, applicative, monad instances can be passed through with GeneralizedNewtypeDeriving
20:00:43 <ertes> but if you use it for turning state from explicit arguments to implicit state, you probably should just use StateT
20:01:14 <Xandaros> Yeah, in this case you could probably just use StateT. In general, I agree with you, though, glguy
20:01:36 <ertes> if you're actually designing a DSL (whether for yourself or as part of a library), then yes, wrap it
20:01:45 <ertes> GND makes it easy enough
20:03:17 <ertes> (or use effect classes, something i like to do, because very often you can get away without the wrapper type while keeping the language safe)
20:03:29 <ertes> in other words:  instead of writing Interpreter, write MonadInterpreter
20:12:23 <Supcat> Im new to haskell, any one know how to define a function not use filter but return a same result?
20:17:14 <Lerrpy> you can use list comprehensions with predicates to filter
20:18:18 <Supcat> Can you give a function sample use filter and please explain to me in the other way?
20:18:30 <Welkin> or you can just write the definition of filter out in your function
20:18:31 <Welkin> o.o
20:18:36 <Welkin> sounds like some dumb homework question
20:19:09 <Supcat> Yes Welkin I'm dump :D
20:21:32 <Welkin> @src filter
20:21:32 <lambdabot> filter _ []     = []
20:21:32 <lambdabot> filter p (x:xs)
20:21:32 <lambdabot>     | p x       = x : filter p xs
20:21:32 <lambdabot>     | otherwise = filter p xs
20:21:34 <Welkin> there you go
20:22:05 <systemfault> Hmm, not implemented in terms of a fold
20:25:22 <Supcat> thanks alot
20:25:22 <ertes> Supcat: there are about a million ways to write it without using explicit recursion
20:25:25 <Xandaros> F it - I'm just using a normal Maybe. I run into the same problems I predicted with your approach ertes, which, in retrospect, should have been obvious...
20:26:42 <ertes> Supcat: a simple example is concatMap
20:27:25 <ertes> personally i'd probably write it in terms of foldr
20:27:51 <ertes> Xandaros: which one?  i gave you two
20:27:59 <Xandaros> The functor one
20:30:09 <ertes> Xandaros: i still recommend the other one, because the Maybe can get in your way
20:30:15 <ertes> and fromJust doesn't exist
20:30:38 <Polymorphism> I count up randomly by 1 or 2 every second. I count to 120. I would expect this to take between 1 and 2 minutes. Where have I gone wrong in my logic that the result is 2 minutes every time?
20:31:05 <Welkin> Polymorphism: you probably are using the same seed every time
20:31:13 <Welkin> or generated one Random value and keep reusing that
20:31:41 <Welkin> you have to pass along the new generator to produce a new random value
20:32:03 <Lerrpy> would haskell be considered... declarative?
20:32:16 <Welkin> Lerrpy: yes, I would say so
20:32:38 <Lerrpy> I think that's what blew my mind the most
20:32:45 <Lerrpy> it makes so much sense
20:32:49 <Xandaros> ertes: Yeah, I'll just make a WithID wrapper. Not sure how to serialise it yet - I might just make it have fields "id" and "data"... Getting tired of this
20:33:00 <grantwu> not as declarative as some other languages, but it's closer than most
20:33:06 <Welkin> Xandaros: take a cue from Persistent
20:33:31 <Xandaros> Welkin: ?
20:33:58 <Lerrpy> grantwu, what would be the "most declarative" language?
20:34:11 <Xandaros> Something like prolog, methinks
20:34:23 <Welkin> http://hackage.haskell.org/package/persistent-2.6/docs/Database-Persist-Types.html#t:Entity
20:34:31 <Welkin> Xandaros: that's exactly what Entity is
20:34:32 <ertes> Xandaros: once i made a type family instead of a custom tuple type, and it was good enough…  i needed an extra type class though…  today i'd just write a custom tuple type WithId
20:34:36 <grantwu> That would probably be logic progamming languages like prolog and friends
20:35:43 <Xandaros> Welkin: It doesn't seem to have From-/ToJSON instances, though, so I don't see how that's supposed to help
20:35:52 <Welkin> Xandaros: huh?
20:36:06 <Welkin> I am talking about the concept
20:36:13 <Xandaros> Well, yeah
20:36:16 <Welkin> you are using acid state right?
20:36:26 <Welkin> and From/ToJSON is trivial
20:36:28 <Xandaros> Well, not yet, but that's the plan, yes
20:36:37 <Welkin> just throw it in a tuple
20:36:48 <Welkin> which turns into a 2 element js array
20:37:07 <Xandaros> Nah, I don't like that
20:37:08 <Welkin> unless you want to have a record
20:37:19 <Welkin> that's trivial too though
20:37:39 <Xandaros> Ideally, it would modify the "inner" object to add the id field. I think I'll just have it nested, though
20:38:05 <ertes> Lerrpy: "most declarative" doesn't really mean anything
20:38:46 <Lerrpy> hence the heavy quotation marks
20:38:52 <Lerrpy> I'm basically poking around in the dark here lol
20:43:05 <ouyout> hey guys - I have a problem stack, is this a good place to ask?
20:43:12 <jle`> just ask :)
20:44:33 <ertes> a problem stack?  that sounds awful =)
20:44:55 <ouyout> with stack**, sorry x) great : I'm part of a team that's building a project on Linux, and it's my job to make it cross-platform - meaning I have to make it play nice with Windows.
20:45:45 <ouyout> however, whenever I try to build the project, stack complains about a missing package that's a dependency of one of our tools, 'double-conversion-2.0.1.0'. Even after I try to install it with either stack or cabal.
20:46:11 <Welkin> add it to your extra-depends in your stack.yaml
20:47:18 <ouyout> hm.. that's definitely one thing I haven't tried, I'll check back after trying. thanks Welkin .
20:51:50 <ouyout> Welkin, didn't work. This is a linking problem, if I'm not mistaken, I get about 20 or 30 occurences of 'Could not on-demand load symbol '_ZNSt9exceptionD2Ev'' (for example)
20:52:51 <glguy> ouyout: Instead of revealing the problem piecewise, perhaps just paste the actual output to a pastebin
20:53:20 <Xandaros> Hmm... I need a directed, connected, acyclic graph. (Though it can, and will, have more than one root) - Any ideas that are better than containers/Data.Graph? :D
20:53:27 <ouyout> I forgot this is how we did things in this channel, my bad. Give me a minute.
20:54:28 <ouyout> here it is: http://pastebin.com/71xKZPC1
20:59:34 <ouyout> I've tried many different approaches, and I've lost count of how many reinstalls I had to do because of this.
21:00:12 <ouyout> Can I just build the package manually and put the binaries somewhere?
21:00:56 <glguy> ouyout: Looks like you're encountering a problem with double-conversion package using C++ and how that interacts with Windows
21:01:13 <glguy> https://github.com/bos/double-conversion/issues/7 https://github.com/fpco/minghc/issues/5
21:01:53 <glguy> https://github.com/bos/double-conversion/pull/13/files might be related. I'd poke around these and see if you can't make sense of things
21:02:29 <ouyout> I will, thanks glguy 
21:23:31 <ouyout> glguy, just a quick update before I log out - it appears 'double-conversion' is not Windows friendly at all, and stack even dropped its 'formatting' dependency because of this. I think we'll just find another way to do text-formatting. Once again, thanks.
22:19:49 <STOP_nwo> "they" chipped people in secret with rfid microchip!  4this is CRIME  of the highest order  !!!!!!!!!!!!!!!!!!!!!!
22:20:20 * EvanR looks at STOP_nwo 
22:21:33 <Lerrpy> EvanR, that was a killer look
22:23:23 <EvanR> microchip upgrade
22:46:07 <laudiacay> y i k e s
23:11:46 <afidegnum> hello, what's hte best tool to build an android app using haskell?
23:11:56 <laudiacay> afidegnum: your own tears
23:12:06 <laudiacay> honestly though is there even haskell for JVM?
23:12:41 <laudiacay> afidegnum: google says frege
23:12:50 <laudiacay> it runs on JVM
23:13:22 <afidegnum> what about playing with NDK ?
23:13:55 <laudiacay> i mean that looks usable as well
23:14:21 <laudiacay> but frege runs on the JVM, so it compiles down to java machine code, so it would probably interface better with all the other stuff
23:14:24 <laudiacay> im looking at NDK
23:14:32 <Xandaros> Relevant: http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/
23:14:49 <afidegnum> what about ios?
23:14:56 <laudiacay> NDK looks like just c/c++
23:15:02 <laudiacay> frege is proooobably what you want
23:15:09 <laudiacay> ios i wouldn't even try
23:15:15 <laudiacay> their environment is an airlock
23:15:25 <laudiacay> they don't even let other people's headphones and USBs in
23:15:49 <laudiacay> https://wiki.haskell.org/IPhone doesn't this make you want to cry
23:16:25 <afidegnum> hahaha
23:16:56 <afidegnum> in this case, i need to buy a MAC Pro and start building my custom IOS on it, right?
23:17:08 <afidegnum> and learn SWift or cocoa right?
23:17:17 <laudiacay> just like obj-c
23:17:53 <Xandaros> Sounds like a brilliant plan. To be honest, I sometimes wonder how they got anyone to write iOS apps
23:18:12 <laudiacay> idk my iOS experience is literally a guy i rock climbed with hitting on me by saying "hey you code right come teach me ios" and i didn't know ios but i felt bad so i bullshitted my way through helping him make a magic the gathering life counter
23:18:44 <laudiacay> it was terrible and but obj-c + iOS was honestly very similar to developing on android
23:19:08 <Xandaros> !!! I never even considered making an app to count life! That's bloody brilliant! :D
23:19:16 <laudiacay> if you can tolerate android, you can tolerate dev-ing for iOS. I'm unfortunately allergic to both and use MIT app inventor whenever i have a custom smartphone app need
23:19:32 <afidegnum> Xandaros: there are huge team of developpers
23:19:58 <afidegnum> obj-c is not a one day affair, it took long time to build on, just like other languages
23:20:39 <afidegnum> and i believe they have been doing close testing on close hardwares as well
23:20:49 <laudiacay> idk man i had one year of advanced high school level data structures in java and i was able to get proficient-ish in an hour of looking over this guy's shoulder
23:20:57 <laudiacay> oh you mean making obj c, not learning obj c
23:21:26 <afidegnum> making obj-c
23:21:28 <laudiacay> (it's trash stick to haskell <3)
23:21:34 <Xandaros> I'm confused... Sorry, afidegnum, but what are you on about? :D
23:21:40 <laudiacay> Xandaros: the making of obj-c
23:21:51 <Xandaros> Yes, but... why‽
23:22:04 <laudiacay> idk it's terrible and complaining is cathartic
23:22:30 <Xandaros> I wasn't complaining about ObjC. I've never tried it (and never will, since I don't use apple product)
23:22:59 <laudiacay> yeah that's a good plan
23:23:04 <laudiacay> can we talk about how bad java is though
23:23:04 <afidegnum> Xandaros:    !!! I never even considered making an app to count life! That's bloody brilliant! :D
23:23:25 <afidegnum> laudiacay: since day1 java demotivates me, 
23:23:29 <Xandaros> Bleh, I'll just make it a responsive web app
23:23:43 <laudiacay> afidegnum: i learned to code in java and it was rough (TM)
23:23:56 * Xandaros started with Visual Basic 6
23:24:19 <afidegnum> well being rough on OOP concept, it created a memory hog on my p4 those days
23:24:25 <laudiacay> my friend was whining about not being able to map streams into chars and i got stressed out just /thinking/ about java generics to primitives
23:24:41 <afidegnum> but i did learn few concept of system analysis and design using oop though 
23:24:44 <laudiacay> i think i need to shower lmao java is so nasty
23:25:13 <Xandaros> Well, which OOP language do you prefer?
23:25:17 <laudiacay> python
23:25:27 <laudiacay> but i seriously just kinda avoid OOP
23:25:40 <laudiacay> like i dont think i've written a python class more than.... once?
23:25:45 <afidegnum> well python was simpler 
23:25:47 <Xandaros> My experience with python: "Alright, let's try this. *program runs for 5 minutes* Oh dang, had a typo"
23:25:48 <afidegnum> with php
23:26:03 <afidegnum> in fact getting python concept of oop made me undestand php better, 
23:26:27 <afidegnum> hence java will then be easy to code as well by i m still shying away from it,     "once bitten!"
23:26:46 <afidegnum> Xandaros: typo LD
23:26:48 <afidegnum> :D
23:26:54 <laudiacay> i learned data structures and algo in java, discrete and web design in python, data analysis in mathematica, and i guess functional programming in haskell
23:27:03 <glguy> Python, PHP, Java, Swift and Objective C are off topic in #haskell. you can continue the conversation in #haskell-offtopic however
23:27:09 <laudiacay> ok
23:27:22 <afidegnum> ok ok, 
23:27:28 <laudiacay> haskell is fantastic and it's the only truly pleasant experience i have had in a programming language
23:27:45 <laudiacay> let's just circlejerk about haskell's superiority because that's what i was getting to anyway
23:29:27 <afidegnum> well, i do love haskell too, imagine, you plan app properly and you write only the important funcitonality in less than 100 lines, including comments
23:51:19 <wespiser> laudiacay: did I miss the self-congratulatory circle jerk?
23:52:05 <wespiser> well, we really are 20 years ahead of the industry standards, so we can just jerk off until the world catches up to us
