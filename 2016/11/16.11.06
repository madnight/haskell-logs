00:00:06 <LordBrain> cabal is like upstream in a way, and stack is like a distro
00:00:11 <EvanR> that blog post reminds me i have no idea what cabal is
00:00:44 <adam00> qq, I'm using `stack build --haddock --file-watch` to build docs but not seeing the modules for the project that stack is building for, what would be some obvious blunders? 
00:02:36 <adam00> nm, found the ticket https://github.com/commercialhaskell/stack/issues/729
00:02:51 <hvr> wespiser: so basically cabal & stack are in competition now, which is both good and bad; good because it gives users more choice, bad because it divides the community into two camps, and  we're spread thin already re development power
00:03:06 <wespiser> yea, we are a small community
00:03:26 <wespiser> commercially, its even smaller
00:03:45 <hvr> wespiser: and then there's the thing about cabal/hackage being haskell.org's baby, while stack/stackage is fpco's baby
00:03:57 <hvr> so there's some tension there
00:04:04 <LordBrain> we must proselytize the computer language of haskell as being holy
00:04:10 <wespiser> i've only used stack in production, and use it for all my side projects. Never had an issue. Why should I try cabal to manage my next project?
00:04:11 <LordBrain> :)
00:04:22 <kadoban> They're not that separate. Every stack project is also a cabal project, and stackage is a curated copy of hackage. So it's not really as bad as it sounds ...
00:04:43 <hvr> kadoban: that's not accurate
00:04:56 <LordBrain> whats wrong with it hvr?
00:05:04 <wespiser> lol, scroll up
00:05:10 <hvr> kadoban: cabal proejcts have a 'cabal.project'; stack projects use 'stack.yaml' file ;-)
00:05:11 <kadoban> hvr: What part isn't?
00:05:36 <LordBrain> you mean 'project.cabal' don't you?
00:05:58 <hvr> LordBrain: nope, "foo.cabal" describes a cabal package, not a cabal project
00:06:13 <hvr> LordBrain: cabal projects are a recent thing since cabal 1.24
00:06:17 <LordBrain> oh
00:06:18 <kadoban> I probably meant to say package
00:06:28 <kadoban> I never have any idea which one is which, w/e.
00:06:28 <EvanR> er, i dont have any .projects
00:07:02 <LordBrain> did they release 1.24?
00:07:16 <hvr> LordBrain: http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
00:07:32 <hvr> LordBrain: yeah, cabal 1.24 is the one that goes along w/ GHC 8.0
00:07:54 <begriffs> I've used cabal in the past, and I must admit that stack has been pretty nice. It usually installs what I want, does it quickly, reuses pre-built code, allows convenience flags like --file-watch. It's also easier for me to instruct new Haskellers how to build my code since it installs GHC and everything for them. It's also possible to force package versions with extra-deps in the stack yaml
00:07:55 <hvr> LordBrain: and the next major release is going to be cabal 2.0
00:08:41 <begriffs> But I do appreciate the conceptual idea of using constraints to drive how things are built.
00:08:44 <hvr> begriffs: the thing is, that "old-build" cabal is really less nice than stack
00:09:09 <begriffs> What is old-build cabal?
00:09:11 <hvr> begriffs: but that's what the nix-style new-build is addressing
00:09:19 <hvr> begriffs: it's the cabal you're used to
00:09:27 <LordBrain> i have a patched version of cabal where i make the default info less verbose
00:09:32 <hvr> begriffs: new-build is http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
00:09:50 <hvr> begriffs: the next-gen cabal that's being worked on
00:09:57 <begriffs> Well dang, I'll have to check that out!
00:10:32 <hvr> begriffs: in a nutshell: no more reinstalls, no more broken pkg db, no more weird stateful install-plans
00:11:08 <hvr> and sharing of common libs
00:11:09 <begriffs> I'm really glad I asked about cabal to learn about this new development.
00:11:12 <LordBrain> they also precompiled the packages, at least thats how it was last i looked at a devel branch which was admittedly quite some time ago
00:11:38 <hvr> begriffs: I guess we need to advertise it more... this has been blogposted about already for about a year... :-)
00:12:22 <hvr> LordBrain: what do you mean by 'precompiled the packages'?
00:12:24 <LordBrain> i looked at some post 1.23 git branch a while back
00:12:42 <LordBrain> i mean when i said cabal install, it downloaded, but didnt have to compile
00:12:53 <LordBrain> it was super fast
00:13:21 <LordBrain> i was using sandboxes... maybe it was copying binaries that i compiled prior?
00:13:49 <hvr> LordBrain: that doesn't sound like a feature that went in
00:13:53 <LordBrain> oh
00:14:02 <LordBrain> like its still in devel, that makes sense
00:14:07 <hvr> LordBrain: there was some experimental patch which implemented caching for old-style sandboxes, but we didn't go that route
00:14:11 <LordBrain> because they hadn't fully worked the security out i htink
00:14:19 <hvr> LordBrain: since old-style sandboxes are going away
00:14:35 <LordBrain> okay, i'm not sure t hat is what it was tho
00:14:35 <Lokathor> seems you can just wget an arm build of ghc
00:14:46 <LordBrain> but you maybe keep updated more than I do, and know better
00:15:09 <hvr> LordBrain: ...I guess so... I push commits to cabal's git repo from time to time :)
00:15:23 <LordBrain> well it was from the git repo that i built
00:15:42 <laudiacay> hey, I'm struggling with lambdas for a school assignment, and i don't really want to paste homework in channel... would anyone be willing to help me out in PM for a few?
00:15:52 <hvr> begriffs: fwiw, you can easily use stackage snapshots with new-build; I do so e.g. here: https://travis-ci.org/hvr/cassava/builds/169807732
00:15:56 <laudiacay> er not lambdas monads
00:16:14 <LordBrain> it looked like they were moving toward having binary distribution and having reproducible builds
00:16:30 <hvr> begriffs: it's just the ui-porcelaine that needs to make it a bit more convenient
00:16:37 <wespiser> laudiacay, pm me
00:16:43 <laudiacay> wespiser: thanks dude :D
00:17:45 <hvr> LordBrain: the big problem with binary distributions for haskell packages is that you need one for each linux distro and ghc flavour
00:17:53 <hvr> LordBrain: and of course the security aspect
00:18:06 <hvr> you'd need a big buildfarm
00:18:29 <hvr> otoh, we can easily give you the tools for maintaing a global shared bin-cache within your workgroup which you trust
00:18:38 <Lokathor> http://lpaste.net/329533 is all this debug-ish stuff new to the latest ghc?
00:18:44 <Lokathor> or have i just never noticed before?
00:18:52 <LordBrain> yeah, but if builds are reproducible security is much easier, and the build farm could actually be the developers ultimately
00:19:16 <begriffs> hvr: cool, I've made a note to give new-build a try.
00:20:12 <hvr> begriffs: if you try it and run into problems, feel free to join #hackage and pester us
00:20:59 <kadoban> Lokathor: Looks about the same as the stuff I get on 7.10.3
00:21:07 <Lokathor> hmm
00:24:28 <Lokathor> frick
00:24:30 <Lokathor> no cabal >_>
00:47:03 <laudiacay> anyone else willing to help?
00:47:10 <laudiacay> wespiser went to bed :(
00:47:52 <cocreature> laudiacay: what is your question?
00:48:18 <Lokathor> i'm also about to go to bed sadly, but asking the questions directly in the channel seems the best way to get back on track
00:48:35 <laudiacay> cocreature: I have some monad type issues, and it's on homework :( which I don't feel comfortable pasting into channel, but also don't feel like I can explain well without showing y'all the code
00:49:36 <laudiacay> basically it's of type Monad m => m (Maybe a) -> (a -> m b) -> m (), and instead of returning m (), I keep accidentally returning Maybe (), and I have no idea where I went wrong
00:50:15 <laudiacay> like, if I unbox the first argument with <- twice, i should just have something of type a, right?
00:50:17 <EvanR> glguy: if i hypothetically decide whatever i just uploaded is really better being forgotten (though i think what happened is still technically following the version policy rules) is there a process to delete that version from hackage?
00:50:18 <japesinator> I have a question about happstack and digestive-functors
00:50:40 <japesinator> basically, I'm trying to have two forms, the second of which depends on results from the first
00:50:47 <laudiacay> then if i apply the second argument to that thing of type a, I should have something of type m b.
00:51:02 <cocreature> if you instantiate m with Maybe you get a Maybe ()
00:51:02 <japesinator> so I pretty much have two functions like https://github.com/jaspervdj/digestive-functors/blob/master/examples/tutorial.lhs#L205-L222
00:51:09 <laudiacay> and if i run that in a do loop, then recursively call the function itself in the same do loop, it should be ok right?
00:51:21 <laudiacay> cocreature: m is an IO when the function is called
00:51:30 <laudiacay> so the fact that it's returning maybe is a me problem
00:51:30 <japesinator> the second of which :: String -> ServerPart Response
00:51:41 <cocreature> laudiacay: could you show us the code and the error you’re seeing?
00:51:47 <laudiacay> cocreature: can I pm it to you?
00:51:57 <japesinator> and then the first, if it gets (_, Just release) calls the second with release
00:52:16 <cocreature> laudiacay: throw it on lpaste http://lpaste.net/ but sure if it’s confidential pm me the link
00:52:28 <japesinator> but whenever I do this, it acts like I just submitted the second form, just completely empty
00:53:27 <laudiacay> cocreature: check PM :D
00:55:29 <cocreature> laudiacay: alright, let me answer here anyway. the problem is that in the inner do you are first using "<-" on a Maybe and thereby forcing this do block to be in Maybe, then you are using "<-" on the result of func. since this is the same do block the result has to be of type Maybe which means m ~ Maybe
00:55:34 <cocreature> which is why you are getting the error
00:56:03 <laudiacay> cocreature: so I'm really not sure how to avoid using that though?
00:56:52 <laudiacay> I mean i guess I could do some sorta >>= with maybeVal and func?
00:56:57 <cocreature> laudiacay: just use "case" on the Maybe. you might want to look at https://hackage.haskell.org/package/monad-loops-0.4.3/docs/src/Control-Monad-Loops.html#whileJust which is pretty close to what you are trying to implement
00:57:16 <laudiacay> oh wow
00:57:18 <laudiacay> cool thanks
00:57:33 <cocreature> you can’t mix multiple monads in the same do block
00:57:48 <cocreature> you can layer them using monad transformers which does a similar thing but that’s not worth it for this usecase
00:58:36 <laudiacay> ohh yeah 
00:59:04 <cocreature> ah whileJust_ is exactly what you are trying to do
00:59:12 <cocreature> it’s right below the other function I linked to
00:59:26 <laudiacay> okie so the type of something of the sort f a <- m f a would be m () ?
00:59:35 <laudiacay> oh nooo i cant loook
01:00:38 <cocreature> if m has type m (f a) (the parenthesis matter) and you have "x <- m" in a do block, x has type "f a"
01:00:50 <laudiacay> ohhh cool okay
01:01:00 <cocreature> you can’t directly talk about the type of something involving "<-" because it’s a syntax construct and not an expression
01:01:10 <laudiacay> but when you "do" the entire expression, that has type.... m ()?
01:02:01 <cocreature> that depends on what the last statement in your do block is. "<-" can’t be the last statement. but it will definitely be of type m a for some a which could be ()
01:03:15 <laudiacay> ok thank you so much
01:08:18 <athan> what's `Negate a` again? Void -> a?
01:08:49 <athan> and does this actually mean something like "a lack of proof for `a`" props-as-types style?
01:09:27 <cocreature> "Negate a" should probably be "a -> Void"
01:09:54 <cocreature> at least that’s how you define negation in something like coq
01:11:09 <cocreature> so if you had a proof for a (i.e. a value of type a) you have a proof of Void which is impossible so there can be no proof of a
01:14:19 <athan> ahh okay, that makes sense. Thank you.
01:14:32 <EvanR> Not a = a -> Void
01:14:49 <athan> you can't really disable someone's capacity to make a proof though, huh
01:14:57 <EvanR> not in haskell
01:15:01 <athan> hm
01:15:55 <EvanR> :t let f x = let y = y in y in f
01:15:57 <lambdabot> t -> t1
01:16:09 <EvanR> you can pick t1=Void
01:16:39 <athan> heck yes
01:16:43 <athan> okay :)
01:17:23 <athan> oh wait isn't that just const (fix id)?
01:17:33 <EvanR> its unsafeCoerce
01:17:39 <athan> :O
01:17:58 <EvanR> actually not, since unsafeCoerce doesnt freeze
01:18:17 <EvanR> :t const (fix id)
01:18:18 <lambdabot> b -> a
01:18:21 <EvanR> right
01:18:22 <athan> well wait yeah that's what I mean
01:18:30 <athan> sorry haha
01:18:43 <athan> sweet, so `in` can be used as infix const maybe...?
01:18:49 <athan> :t (in 1)
01:18:52 <lambdabot> error: parse error on input ‘in’
01:18:55 <athan> :(
01:19:02 <athan> :t (let in 1)
01:19:06 <EvanR> what... in is part of let syntax
01:19:06 <lambdabot> Num t => t
01:19:15 <EvanR> lol
01:19:18 <athan> er.. x_x
01:19:25 <EvanR> empty bindings
01:19:48 <EvanR> id x = let in x
01:20:00 <EvanR> let in for good measure
01:24:11 <athan> lord, i didn't see the first let
01:24:19 <athan> my goodness my head hurts now
01:25:06 <athan> I thought EvanR was pulling some houdini
01:26:35 <EvanR> > let id x = let in x in id 9
01:26:38 <runeks> What's the idea behind warning about orphan instances? Surely, we can't define all possible instances of a type in the library that defines the type, or that library would depend on all libraries that may want to derive an instance.
01:26:38 <lambdabot>  9
01:26:42 <EvanR> haha
01:27:20 <EvanR> runeks: the other option, is to define the instance in the library which defines the type
01:27:41 <EvanR> anything besides those 2 is an orphan and it warns you because they have issues
01:28:34 <EvanR> its reasonable to expect the instance to be in the library that defines the type, .... until its not. and its essentially a question of package maintenance
01:29:31 <runeks> EvanR: so the base library, which defines Integer, should depend on http-media, such that the MimeRender instance of it (for rendering it to an URL path) is defined in the same module as the type itself?
01:29:59 <ongy> or http-media has to depend on the library that defines Integer
01:30:08 <EvanR> no, in that case youd argue the other way. Integer's instance should be in http-media
01:30:26 <EvanR> http-media definitely depends on base, so you need a better example
01:30:34 <runeks> Right.. but I still get an orphan warning right?
01:30:38 <EvanR> no
01:30:45 <runeks> Oh..
01:30:56 <EvanR> thats one of the two ways you dont get the warning
01:30:58 <runeks> I don't understand the distinguishing difference then
01:31:16 <EvanR> instance is by the class, or by the type who is becoming an instance
01:31:25 <amalloy> an orphan instance is one which is neither in the module defining the type nor the module defining the class
01:31:35 <ongy> where "by the" is "defined in the same module"
01:31:54 <runeks> Ok, so either type/instance or class/instance or all three?
01:32:11 <EvanR> either type/instance or class/instance or orphan
01:32:23 <ongy> or type/class/instance
01:32:27 <EvanR> oh right, they can all be in the same module
01:32:28 <runeks> Right
01:32:41 <runeks> I now understand
01:33:05 <amalloy> it's okay to define instances for your own class, or instances for your own type, but defining instances of someone else's class for someone else's module is fraught with peril
01:33:24 <amalloy> er, for someone else's type
01:33:30 <ongy> there's no-warn-orphans, if you really need it. If it's not to much effort, newtype can help out aswell
01:33:31 <runeks> How much peril, roughly?
01:33:58 <runeks> And of what nature is this peril, exactly?
01:34:01 <EvanR> if youre working on an application, orphan instances shouldnt be a big deal
01:34:04 <amalloy> runeks: i mean, if you do it, what's to stop ten other people from doing it? how will you resolve that conflict?
01:34:28 <EvanR> no one will be depending on your code in the end
01:34:41 <ongy> also have fun finding your error that something is not a instance, where you know there is a instance, but it's not included because it's in another module
01:36:29 <runeks> amalloy: Which conflict?
01:36:40 <soLucien> hello guys ! I'm kind of stuck with parsec , in escaping characters
01:36:55 <EvanR> runeks: theres can be only at most 1 instance of a given class for a given type
01:37:10 <EvanR> the compiler stops that for non orphan instances
01:37:27 <EvanR> but the problem is deferred with orphans
01:37:43 <runeks> EvanR: I am building an application, so that's probably why I see them so often. Like defining MimeRender instances of types from libraries that would seem weird if they depended on http-media.
01:37:46 <EvanR> error-at-a-distance
01:38:00 <EvanR> you should be ok
01:38:26 <soLucien> EvanR can I PM you ?
01:38:28 <EvanR> though for Integer it shouldve been done for you
01:39:04 <EvanR> no because i am going unconscious
01:39:09 <runeks> Yeah that's true. It's mostly for types in otherwise obscure libraries (mostly related to Bitcoin)
01:39:10 <soLucien> me too
01:39:17 <soLucien> it's 10 AM already
01:39:35 <soLucien> and i still haven't figured out how to escape the strings
01:40:48 <athan> Is there something like {- NOLANGUAGE Safe -}?
01:43:47 <athan> and inherit a set from the cabal file as usual. If NOLANGUAGE was forced in the header of the file, too, you could have {-# LANGUAGE x #-} {-# NOLANGUAGE x #-} {-# LANGUAGE x #-} ... still "make sense" [tm]
01:44:36 <athan> soLucien: haskell Strings are utf8
01:45:07 <athan> what are you trying to escape?
01:46:03 <athan> @check \(s :: String) -> read (show s) == s
01:46:03 <lambdabot>  <unknown>.hs: 1: 16:ScopedTypeVariables language extension is not enabled. P...
01:46:13 <soLucien> athan i am trying to create escape sequences in parsec
01:46:20 <athan> @check \s -> read (show s) == (s :: String)
01:46:23 <lambdabot>  +++ OK, passed 100 tests.
01:46:37 <athan> soLucien: for terminals?
01:46:43 <athan> like the ANSI stuff?
01:46:43 <soLucien> yes
01:46:46 <athan> O_O
01:46:49 <athan> out of my leauge
01:47:05 <athan> soLucien: God speed
01:47:16 <soLucien> think of something like a parser for haskell
01:48:00 <athan> like haskell-src-exts?
01:48:01 <soLucien> "something \\\n something\\something" is a string split over 2 lines
01:48:07 <soLucien> it
01:48:18 <athan> sure
01:48:19 <soLucien> it is "something something\something"
01:48:25 <athan> totally
01:48:45 <athan> > show "something \nsomething\something"
01:48:47 <lambdabot>  <hint>:1:29: error:
01:48:47 <lambdabot>      lexical error in string/character literal at character 's'
01:48:50 <athan> :|
01:48:54 <athan> > show "something \nsomething\\something"
01:48:56 <lambdabot>  "\"something \\nsomething\\\\something\""
01:49:08 <athan> > show "something \\\nsomething\something"
01:49:10 <lambdabot>  <hint>:1:31: error:
01:49:10 <lambdabot>      lexical error in string/character literal at character 's'
01:49:11 <athan> :v
01:49:14 <athan> :|
01:49:53 <athan> wait that cannot happen
01:50:15 <soLucien> show "something \\\n something\\something"
01:50:42 <soLucien> > show "something \\\n something\\something"
01:50:44 <lambdabot>  "\"something \\\\\\n something\\\\something\""
01:50:51 <soLucien> oh
01:50:59 <soLucien> it only makes it worse
01:51:00 <MarcelineVQ> > show "some​thing" -- spam night in #haskell woo!
01:51:02 <lambdabot>  <hint>:1:11: error:
01:51:02 <lambdabot>      lexical error in string/character literal at character '\8203'
01:51:12 <athan> > read "something \\\n something\\something" :: String
01:51:15 <lambdabot>  "*Exception: Prelude.read: no parse
01:51:17 <athan> :)
01:52:48 <ongy> MarcelineVQ: why did yours not parse?
01:52:58 <athan> because you can't unescape \\
01:52:59 <MarcelineVQ> I'm a bad person.
01:53:05 <athan> > read "\\" :: String
01:53:08 <lambdabot>  "*Exception: Prelude.read: no parse
01:53:10 <athan> :)
01:53:25 <ongy> unicode ""?
01:54:20 <athan> > "\2008"
01:54:23 <lambdabot>  "\2008"
01:54:25 <athan> er
01:54:46 <Xnuk> 1> read "\"something \\n somethingsomething\"" :: String
01:54:49 <Xnuk> > read "\"something \\n somethingsomething\"" :: String
01:54:52 <lambdabot>  "something \n somethingsomething"
01:00:01 <athan> > putStrLn "\8203" -- ongy
01:00:04 <lambdabot>  <IO ()>
01:00:07 <athan> :|
01:00:23 <athan> er wait lol
01:00:40 <athan> V_V
01:01:20 <MarcelineVQ> > text "\8023"
01:01:22 <lambdabot>  ὗ
01:01:48 <julianleviston> Does anyone know if there’s an already developed set of Aeson instances for Language-Haskell-Exts-Syntax ?
01:05:14 <athan> julianleviston: that would be interesting to see
01:05:38 <thatguy> I have some function f and want to compute f(f(f(....f(a)))) where I call f n times (e.g. 10000) and throw away all but the last 100 results. What would be the haskell way to do that?
01:06:22 <julianleviston> thatguy: you mean like a scan, but you only want the last 100?
01:06:22 <pavonia> drop 9900 . iterate f $ a
01:07:00 <julianleviston> pavonia: ah that makes more sense :)
01:07:31 <thatguy> pavonia, thanks, I am pretty much a beginner but that looks as if it does what I need
01:09:44 <julianleviston> thatguy: might need a take 100 . in front of that too ;-)
01:12:50 <gfixler> > take 5 . drop 9995 . iterate (*1.1) $ 2
01:12:52 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity]
01:19:12 <julianleviston> athan: guess I’m going to have to try to build it then LOL. wish me luck :)
01:19:39 <julianleviston> Feels like maybe this is insane
01:19:44 <athan> ?
01:20:05 <athan> oh sorry
01:20:46 <athan> if it's just an ADT, it should be pretty easy
01:21:34 <athan> "easy"
01:21:58 <athan> julianleviston: I think it's a cool idea kinda haha
01:22:30 <athan> are you writing an alternative parser or something web app esque?
01:22:47 <julianleviston> athan: think the only reason it’s even vaguely necessary is I want to build a semantic editor around some stuff - some of which needs to be Haskell
01:23:01 <MarcelineVQ> There should be Generic instances for all of them so it may be straightforward to make Aeson instances
01:23:11 <athan> you might also just consider this: parseHaskell <$> (parseJSON x Data.Aeson.Types.Parser String)
01:23:27 <athan> ahh cool :)
01:23:35 <julianleviston> MarcelineVQ: oh yeah there are generic instances! nice
01:23:50 <athan> julianleviston: like.. HaRe?
01:24:11 <julianleviston> athan: yeah it occurred to me that pretty-printed haskell might be the best way to “store” it ;-)
01:24:36 <athan> yeah haha. But if you're running in the browser it might not be that easy
01:25:04 <athan> er, modulo ghcjs :s
01:25:06 <athan> :x*
01:25:34 <julianleviston> athan: how do you mean?
01:31:18 <julianleviston> athan: more interested in not using text anymore
01:32:29 <julianleviston> athan: also allowing semantic intent-based tranformations (ie semantic transformations) rather than textual ones.
01:33:22 <julianleviston> athan: HaRe seems aimed squarely at providing a specific set of transformations (aimed at refactoring, obviously)
01:33:47 <julianleviston> athan: I’d like them to be extensible from within the system itself (if this makes sense)
01:38:25 <julianleviston> MarcelineVQ: thanks very much.
01:39:53 <MarcelineVQ> have fun!
01:41:15 <sleblanc> @pl \p s -> fmap fst (runSomething p s)
01:41:15 <lambdabot> (fmap fst .) . runSomething
01:46:58 <ertesx> you could use the ultimate super-hack:  -XDeriveGeneric and -XStandaloneDeriving together with -Wno-orphans
01:47:09 <ertesx> force aeson instances down haskell-src-exts' throat
01:48:22 <ertesx> (please read this as a proper joke, not one that "could actually work")
01:51:15 <ertesx> actually that isn't even that stupid
01:51:21 <Galt> Here’s a question. If functional programming is so good, why is it said that languages like Haskell have very little use in commercial software and are mainly useful for rapid prototyping only?
01:51:59 <ertesx> julianleviston: all you need is a newtype wrapper, because Generic instances for haskell-src-exts types are prederifined
01:52:29 <ertesx> then you can do it without an orphan instance
01:53:31 <sleblanc> Galt, likely because it has not gained enough popularity in a commercial setting. Not a lot of tooling available, not many options for commercial support, etc. Compare that to "enterprise" Java, for instance.
01:54:29 <Galt> sleblanc: So it is not something missing in the language or way of programming itself? Only something that can eventually be fixed?
01:56:16 <sleblanc> if it "can", sure. If it "will", not so sure. The way I see it, Haskell is much more popular among academics than people with commercial interests, although GHC has been proven (not formally) to be reliable enough for "serious" commercial endeavors
01:57:14 <Monoide> there is also a very few people that can dev in Haskell / OCaml / whatever functionnal langage
01:57:14 <sleblanc> in my opinion (if it's worth anything) it seems like Haskell / GHC is mainly used by academics to improve the field of functional programming, while corporate players like F# and Scala reap the benefits from that research
01:57:35 <Monoide> but there is qualities of functionnal programming that are wanted, and used in the commercial world
01:57:45 <Monoide> it is not the main langage but it is definitely used in a lot of industries
01:59:20 <ertesx> Galt: businesses generally take the "initially cheap" route and eliminate the business risk of doing something obscure when something widely used is "good enough"
02:00:34 <Galt> I was originally under the impression that there is something about functional programming that renders it less usable for industrial applications.
02:00:46 <sleblanc> Galt, I'd say this is entirely false
02:00:47 <Monoide> I do think this impression is very wrong
02:00:58 <ertesx> Galt: no, it's just simple business logic/game theory
02:01:22 <sleblanc> this misconception might come from the fact that some "functional" languages might be toy, or limited, domain-specific languages
02:01:23 <Galt> Hmm.. I am glad I am wrong.
02:02:00 <ertesx> Galt: and most of them are aware of the potential extra cost (not just related to FP, but really anything modern), though often the extra cost may not be in the constant factors, but the shape of the curve
02:03:25 <ertesx> in other words: i'll confidently assert that haskell tends to be *more expensive* initially, but the curve is much flatter, so eventually it will always catch up and stay way below the cost curve of most other languages
02:04:15 <sleblanc> also, if your market is niche, it might be very hard to start. Try writing Haskell code for an embedded microcontroller, for instance
02:04:22 <sleblanc> hard or costly
02:05:59 <ongy> do we sitll have a haskell compiler that targets C? otherwise that may be harder to do that expected
02:06:20 <cocreature> I think ghc still has a c backend but I’m not sure how well maintained it is
02:06:30 <free_beard> hi guys, I'm having trouble finding which module exports HttpExceptionRequest while following https://hackage.haskell.org/package/http-conduit-2.2.3/docs/Network-HTTP-Conduit.html, the cookie example
02:07:16 <cocreature> free_beard: https://hackage.haskell.org/package/http-client-0.5.3.3/docs/Network-HTTP-Client.html#t:HttpException does
02:07:40 <cocreature> Network.HTTP.Conduit does to
02:07:42 <cocreature> *too
02:07:47 <cocreature> you probably want the latter
02:08:11 <free_beard> cocreature: that's weird, I have Network.HTTP.Conduit imported
02:09:06 <cocreature> free_beard: are you using an old version?
02:09:09 <free_beard> cocreature: thanks, It seems I had some build errors and some dependencies didn't get installed
02:09:27 <free_beard> cocreature: nope, just created the project with stack new, ghc 8.0.1 and all that
02:10:53 <free_beard> cocreature: so I just have a project with the cookie example in a Main.hs
02:11:26 <free_beard> I get not in scope data constructor HttpExceptionRequest
02:12:36 <free_beard> stack lts-7.7 if it helps in any way
02:13:34 <cocreature> free_beard: try "stack list-dependencies | grep http-conduit"
02:13:40 * hackagebot yesod-static 1.5.1.1 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.1.1 (MichaelSnoyman)
02:14:24 <free_beard> http-conduit 2.1.11
02:14:46 <lyxia> https://www.stackage.org/haddock/lts-7.7/http-conduit-2.1.11/Network-HTTP-Conduit.html#t:HttpException
02:14:53 <cocreature> then look at the docs for that version instead of 2.2.3, HttpExceptionRequest is not present in that one
02:14:58 <cocreature> or use the new version :)
02:15:24 <lyxia> 2.1.11 doesn't have that constructor
02:15:28 <free_beard> cocreature: yeah, I just opened the stackage page, the docs look different
02:15:56 <free_beard> lyxia: thanks, I fail to remember how i got to follow that hackage page
02:17:27 <octarin> Why can’t I multiply an Int with a Double, although they are both instances of Num ?
02:17:54 <ertesx> octarin: because:
02:17:58 <ertesx> :t (*)
02:17:59 <free_beard> would you recommend using stackage nightly for learning, and playing around with libraries?
02:18:00 <lambdabot> Num a => a -> a -> a
02:18:12 <ertesx> octarin: do you see why?
02:18:32 <ertesx> octarin: ignore the "Num a =>" bit for a moment
02:18:50 <octarin> because of the a, it has to be the same type ?
02:18:54 <ertesx> yes
02:19:15 <mauke> similarly, you can't == an Int and a String despite them both being instances of Eq
02:19:17 <octarin> but if it was (Num a, Num b, Num c) => a -> b -> c it would have been possible ?
02:19:31 <mauke> octarin: then the result type would have been ambiguous, but yes
02:19:34 <ertesx> octarin: yes, but that function itself is not possible
02:19:42 <octarin> okay, I got it
02:19:51 <octarin> thanks
02:20:03 <lyxia> free_beard: that's fine. You'll also likely have to manually add packages that are not on stackage that you want to try out.
02:33:05 <maerwald> free_beard: you can use plain cabal for learing and playing around with libraries as well
02:46:49 <heebo> hello im trying to profile using the command `stack ghc -- -prof -fprof-auto -rtsopts -O2 ./src/VectorExercise.hs`
02:47:25 <heebo> however i keep getting `Failed to load interface for ‘Data.Vector’`
02:49:07 <oherrala> heebo: maybe add -package vector to args for ghc
02:49:16 <oherrala> I'm not sure
02:49:57 <heebo> oherrala: thanks
03:19:22 <Paprikachu> hi, i'm reading a reddit post about what people hate about haskell, and as someone not as familiar with it i'd like to know what they're referring to
03:19:28 <Paprikachu> https://www.reddit.com/r/programming/comments/5ba964/what_are_five_things_you_hate_about_your_favorite/d9n0exe/
03:19:56 <Paprikachu> this post and the one after it has things like "gets records completely wrong" and "modules suck terribly"
03:20:05 <Paprikachu> what exactly are the problems with those?
03:20:26 <NickHu> Paprikachu: They aren't the same semantics as what people coming from Java, Ruby etc expect
03:21:02 <NickHu> It's annoying how you can't hide typeclass implementations on module imports
03:21:15 <NickHu> Character lists are a quite inefficient ways to do strings
03:21:36 <Paprikachu> so "modules suck terribly" because you can't not export some things?
03:21:36 <NickHu> Partial functions (incomplete pattern matches) can cause your logic to blow up
03:21:44 <ania123> map :: (a -> b) -> [a] -> [b]
03:21:49 <ania123> if i write
03:22:00 <ania123>  map :: (a -> a) -> [a] -> [a]
03:22:03 <NickHu> Paprikachu: There's probably other reasons; modules aren't flawless but they are okay I guess
03:22:10 <ania123> does it changes anything
03:22:11 <ania123> ?
03:22:16 <NickHu> ania123: That's unifying a = b, it's a specific case of map
03:22:44 <NickHu> The first signature is more general than the second
03:22:45 <ania123> ok
03:22:46 <ania123> thx
03:23:07 <NickHu> In fact it is the most general signature possible for map to have
03:23:43 <Paprikachu> NickHu: as someone who's building their own language, i've always viewed the haskell modules to be one of the best. the ability to precisely control which symbols to import, renaming to avoid collisions, etc.
03:23:58 <Paprikachu> so this statement threw me off quite a bit and it seemed to have some consensus
03:24:42 <NickHu> You can't hide typeclass instances
03:24:57 <NickHu> So you don't quite have precise control on what you're importing
03:25:11 <Paprikachu> right
03:25:12 <NickHu> Haskell is pretty good as it goes for module systems, but it's no panacea
03:25:40 <NickHu> Also "modules suck" could refer to cabal which is painful++ to use
03:25:50 <heebo> i think theres a setting to enforce strict matching
03:26:58 <heebo> saying it "get records completely wrong" isnt clear
03:27:56 <NickHu> That's probably more that people don't understand how they work and they aren't like records/dicts in other languages
03:28:29 <heebo> haskell isnt like other languages.
03:28:48 <NickHu> well yeah, but that doesn't mean people who complain about Haskell don't expect it to be like other languages
03:28:54 <ph88> hi
03:28:57 <NickHu> I agree about the :: and : thing though
03:29:05 <NickHu> I wonder why that came about in the first place
03:29:13 <NickHu> iirc SPJ is a mathematician by training
03:30:03 <NickHu> oh when they say modules suck they are talking about the backpack thing
03:30:07 <ph88> i have   data MyType = MT Int | MTb My2Type deriving (Show, Generic)   ghci gives :kind! = D1 ('MetaData "MyType" "Main" "main" 'False) (C1 ..)   Where does this 'MetaData come from? I can't find it in documentation or source code
03:30:26 <osfameron> the first of these points is a *much* worse thing, I think: https://www.reddit.com/r/programming/comments/5ba964/what_are_five_things_you_hate_about_your_favorite/d9nbdlb/
03:30:31 <NickHu> http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
03:31:24 <NickHu> osfameron: I have mixed feelings about people pushing Haskell as a production language tbh
03:32:40 <ph88> NickHu, what's that backpack  ?
03:32:56 <NickHu> ph88: look at the ezyang blog post
03:33:04 <heebo> isnt :: proper mathematical notation?
03:33:04 <ph88> tl
03:33:16 <NickHu> heebo: for what?
03:33:19 <ph88> trying skip to the sentence where it says what it is
03:33:27 <NickHu> A new module system
03:33:35 <ongy> documentation for haskell libraries is weird. But undocumented haskell is still more readable at times than documented code in other language....
03:33:40 <ph88> oh ok
03:33:46 <osfameron> NickHu: it's a shame though. Sometimes writing Haskell code can be *so easy*, and then you get to a point where you need a library for something really basic (for DateTime for example) and then run into a wall because there is literally no useful documentation on it.
03:34:02 <int-e> . o O ( repeating ocaml's worst mistakes in Haskell )
03:34:22 <NickHu> osfameron: I'm probably the wrong person to talk to about this because I'm only interested in Haskell from an academic context haha
03:34:40 <osfameron> :-)
03:34:51 <NickHu> I don't entirely understand what problem backpack is trying to solve, but then again I've never thought/worked on a large architecture software project
03:34:55 <NickHu> (in Haskell)
03:36:12 <ertesx> my biggest complaint about haskell is that it isn't agda
03:36:25 <NickHu> ertesx: I've only really looked at Idris, how does it compare to Agda?
03:37:08 <ggVGc> can I somehow do this without creating temporary variable names for the MVars? https://gist.github.com/fbdffe5af1242b8b2f114f30ba1c7821
03:37:19 <ertesx> NickHu: idris is more focussed on programming, and in general i prefer how idris does things, but i'd really like to have some agda features in haskell, and this time i'm not talking about dependent types
03:38:15 <NickHu> ertesx: What specifically, then?
03:38:29 <ertesx> for example agda's module system is to haskell's module system as a woodin cardinal is to the number 5
03:39:03 <ertesx> (and probably to most other module systems as well)
03:39:05 <heebo> ggVGc:  >>= ?
03:40:34 <ggVGc> heebo: well, I did this now, https://gist.github.com/6b1a2367ba899c3f8982e4b8fef54a0a
03:40:47 <ggVGc> but I would have wanted to keep the explicit name assignments
03:41:00 <NickHu> ggVGc: lenses?
03:41:31 <ggVGc> NickHu: I was thinking that. How would it look?
03:41:48 <NickHu> I have no idea haha - I just know lenses are used for `this kind of thing'
03:42:15 <NickHu> Applicative style is generally okay I think, but you probably ought to comment it to make your intentions clear
03:43:01 <ggVGc> basically I would have wanted something like this, https://gist.github.com/b34529998d8e4356fbc6a7e7b482108c
03:43:12 <ggVGc> which obviously doesn't work since they're in IO
03:43:28 <ph88> when i do :kind! in ghc and see strings what does that mean? strings have their own type ??
03:43:49 <NickHu> ggVGc: The closest thing to that is your gist in applicative style
03:44:01 <ggVGc> yeah, I know
03:44:12 <ggVGc> but, yeah, it misses the clearness of having the names of assigned fields
03:44:20 <ggVGc> comments aren't really a good compromise I feel
03:44:23 <NickHu> ph88: iirc 'Type is a value-to-type promotion thing
03:44:40 <ph88> 'Type ?
03:44:56 <NickHu> 'MetaData "MyType" ...
03:45:07 <NickHu> creates some kind of type based on the string values
03:45:13 <NickHu> (I think)
03:45:27 <ph88> how can i match on this type ?
03:46:37 <NickHu> ggVGc: Why not just do what you did in your first gist but compact the record syntax?
03:48:20 <ertesx> ggVGc: i like to use -XApplicativeDo in that case
03:48:47 <ggVGc> NickHu: because, as with my applicative one, it now depends on ordering of record fields
03:48:55 <ggVGc> which is undesirable
03:49:08 <ggVGc> ertesx: ah yeah, I've never used applicativedo
03:49:12 <ggVGc> will give it a sho
03:49:13 <ggVGc> t
03:49:15 <ggVGc> thanks
03:49:55 <ertesx> ggVGc: alternatively, if the type that defines MainVars happens to be an Applicative, you can derive Traversable for it, write a record of actions and then 'sequenceA' it
03:50:16 <ggVGc> wait, that will make me end up wth order sensitivity too
03:50:37 <ertesx> huh, why?
03:50:50 <ggVGc> well, I don't think I know how to use applicativedo correctly
03:50:58 <ggVGc> let me play around
03:51:00 <ertesx> do x1 <- c1; x2 <- c2; pure (MainVars { _x1 = x1, _x2 = x2 })
03:51:13 <ggVGc> ertesx: yeah, but that's what I had at first
03:51:16 <ertesx> you just pretend that it's a Monad, and ApplicativeDo does the right thing
03:51:17 <ggVGc> which is what I wanted to avoid
03:51:31 <ertesx> oh
03:51:47 <ertesx> well, there is the Applicative/Traversable idea
03:51:49 <ggVGc> ertesx: the point is I don't want to create an x1 binding to assign to _x1
03:52:01 <ertesx> data MyRec a = MyRec { _blah :: a, _blubb :: a }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
03:52:17 <ertesx> sequenceA (MyRec { _blah = blahAction, _blubb = blubbAction })
03:52:47 <ertesx> but of course that one doesn't *always* make sense
03:53:30 <ggVGc> yeah that's too intrusive
03:54:08 <ggVGc> anyway, seems applicative style is my best bet, or temporaries
03:54:58 <ertesx> if all you have is a sequenceA, every problem looks like a Traversable
03:58:44 <ph88> i see this code http://stackoverflow.com/a/13598640/1833322 the guy wrote   instance Conv f1 f2 => Conv (M1 i1 c1 f1) (M1 i2 c2 f2) where   why is it needed to put the constraint there? Conv f1 f2 =>
04:00:58 <pavonia> Is there a way to make these two instances not overlap? http://lpaste.net/329620
04:01:14 <pavonia> I don't really see why they are even overlapping
04:03:02 <ongy> ph88: I haven't used generics yet, but you need the constraint if you use a function from the type class in your instance
04:03:05 <phadej> pavonia: everything overlaps the first instance
04:03:48 <pavonia> Can you explain why? You can't unify the first and the second instance
04:04:10 <ph88> ongy, how do you know that ?
04:04:16 <phadej> pavonia: but the functional dependency says, that you don't need to consider second argument
04:04:51 <pavonia> Ahh, I see
04:05:23 <ongy> that's just the way things work. Another example: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-314 here the mappend is used, so the contrained is required
04:07:35 <ph88> ongy, i was not doubting that, i just ask how you know it so maybe i can learn from the same resource ^^
04:08:44 <ongy> remove the constraint and look at error messages? I don't remember to be honest
04:09:10 <ph88> ok
04:10:03 <ph88> ongy, the example with Monoid .. the constraint seems to be on  a  but the code on SO looks more like   instance Monoid a => Monoid a where  ..
04:10:38 <ph88> instance Conv f1 f2 => Conb f3 f4 where
04:11:32 <ongy> not really. Conv f f2 => Conf (M1 .. f1) (M1 .. f2)
04:12:00 <ongy> - typos
04:12:27 <ph88> UPS
04:12:31 <ph88> ok i see it now !
04:12:35 <AndreasK> Can someone help me out with using the llvm backend on Windows with GHC 8.0.1? I get failures in the assembler phase which dont make sense for me: https://nopaste.linux-dev.org/?1120183
04:12:47 <ph88> didn't even notice those f1 and f2 on the right side of =>   -____-
04:12:49 <ph88> thx ongy 
04:17:45 <ggVGc> so, I've got this atm, https://gist.github.com/9ae92155c57d52b918708410d76c3f12 . Basically just using an MVar to signal another thread to do an action when it can. Is there a better way to model this, where "triggerSongrender" would get a more descriptive time signature than just IO()
04:20:48 <napbagh> Hi!
04:35:50 <a6a3uh> aeson and uniplate question. I'm doing transform of aeson Value. {transform f j} where f is function and j is Value. f could be something like this {f (String s) = String (reverse s)}. What if I want substitute {s} with its key name? 
04:41:26 <cocreature> a6a3uh: sorry I don’t understand what you are trying to do. could you give an example?
04:43:02 <a6a3uh> for example I had json like {"s":"v"} and I'll get {"s":"s"} 
04:43:23 <cocreature> tbh I would just manually recurse on the object
04:43:44 <a6a3uh> this is some simplification. that is required for more complex stuff
04:43:45 * hackagebot MBot 0.1.0.0 - Haskell interface for controlling the mBot educational robot  https://hackage.haskell.org/package/MBot-0.1.0.0 (cfscholl)
04:44:09 <Phyx-> AndreasK: that looks weirdl wonder why it's using GCC in the assembler phase.. Hop into #ghc, you'll likely get a better answer there
04:45:21 <cocreature> a6a3uh: uniplate is nice if your operations fit into the patterns supported by it but if they don’t trying to make it work using uniplate is not worth the trouble
04:45:55 <cocreature> but I’m not too familiar with uniplate so maybe there is a nice way to make it work but recursing manually is only a few lines anyway
04:46:25 <a6a3uh> ok. so having value and its key in one place is not what uniplate could give me? because it helps me nicesly just changing values.
04:48:07 <aminadav_> I'm trying to solve the knight tour problem. It is working well, if I limit to 40 steps. If I try the whole boards(64 steps), it never finish? What do you think? Do you have and recommendation how to make it work faster?
04:48:07 <aminadav_> http://pastebin.com/bavRKXdm
04:51:29 <opqdonut> aminadav_: consider building the list in reverse order. accessing the front of a list and adding to the front of the list are more efficient than the end
04:52:05 <aminadav_> Can you show me waht do you mean?
04:52:09 <aminadav_> @opqdonut
04:52:09 <lambdabot> Unknown command, try @list
04:52:27 <cocreature> aminadav_: it looks like m1,…,m8 always have the same length so one of those guards should be enough
04:52:35 <cocreature> oh no sorry
04:52:38 <opqdonut> cocreature: they can be [] if the check fails
04:52:40 <cocreature> I didn’t see the move
04:53:10 <cocreature> still you don’t want to call length all the time, try storing the length separately
04:53:21 <opqdonut> aminadav_: so "m1 = move ((lastX+1,lastY+2):list)" and "lastMove = head list"
04:53:45 <aminadav_> opqdonut: You can see it here http://stackoverflow.com/questions/40449556/haskell-knight-tour-never-finish-if-i-try-more-than-55-steps
04:53:47 <cocreature> or even better, just pattern match on list instead of using head
04:54:11 <aminadav_> Do you think, that length take lot of time?
04:54:33 <aminadav_> I'm not using HEAD
04:54:38 <cocreature> length takes O(n) time if your list has length n and you are calling it repeatedly
04:54:57 <cocreature> no you are using last, but if you reverse the lists like opqdonut explained you’re calling head
04:56:33 <aminadav_> Good idea use head. And keep the length. I will share you the result
04:57:54 <aminadav_> How I get all element except first one? (opposite of init)
04:58:01 <cocreature> tail
04:58:14 <cocreature> but really just pattern match on list instead of calling head and tail
04:58:45 * hackagebot MBot 0.1.0.1 - Haskell interface for controlling the mBot educational robot  https://hackage.haskell.org/package/MBot-0.1.0.1 (cfscholl)
04:58:48 * hackagebot clay 0.12 - CSS preprocessor as embedded Haskell.  https://hackage.haskell.org/package/clay-0.12 (seanparsons)
04:59:21 <aminadav_> Where to implement this pattern match? Creaet a function for that?
05:00:11 <AndreasK> You can have pattern matches in where clauses as well, really depends on style preference
05:00:12 <cocreature> use "move (first:rest)" in line 3, that will bind first to the first element of the list and rest to the tail
05:00:40 <cocreature> note that this will not work if your list is empty but that’s a problem that already exists in your code because head doesn’t work in that case either
05:05:56 <aminadav_> I'm made two changes: Reverse the order, and add the length as a paremter: http://pastebin.com/NGg0RRjz
05:06:01 <int-e> aminadav_: I believe the knight tour problem requires some heuristic to finish in reasonable time... the problem with the naive search is that it tends to explore positions in which some nodes have been completely cut off; checking how many vacant neighbours the neighbours of the current node have left helps a lot.
05:06:06 <aminadav_> It is still slow, which list more than 59 elements
05:07:13 <cocreature> aminadav_: that won’t improve your performance (significantly) but instead of [x] ++ y you can use x : y
05:07:18 <aphorisme> At the moment I'm trying to experiment with a recursive AST where I get the recursion of the AST via data Fix = Fx (f (Fix f)). Following this construction is there a common way of folding such a fixed-pointed ADT?
05:07:21 <int-e> aminadav_: this will gain much more speed than the factor of 5 (here) that turning the list will yield. It will help more than using a bit mask.
05:07:32 <cocreature> and you are still calling length
05:08:01 <int-e> (right I also changed the length tests to checking for emptiness instead; that's part of that factor 5)
05:08:29 <int-e> another constant factor could be gained by using some sort of bit mask for tracking which board positions have been visited.
05:08:46 * hackagebot type-level-kv-list 1.0.0 - A module for hash map like object with type level keys.  https://hackage.haskell.org/package/type-level-kv-list-1.0.0 (arowM)
05:09:08 <int-e> but heuristics will win the game (there are good admissible ones... admissible meaning that they don't lose any solutions)
05:09:32 <haasn> TIL: in GHCi 8, you can just enter statements without needing to write `let` before them!
05:09:36 <haasn> definitions, that is
05:09:44 <cocreature> haasn: yeah that’s pretty nice :)
05:10:03 <cocreature> although I tend to just not write definitions in ghci these days
05:13:16 <mpickering> aphorisme: Yes: cata :: (f a -> a) -> Mu f -> a; cata alg = alg . fmap (cata alg) . unFx
05:19:38 <aminadav_> init-e: What do you mean heuristics. What type of heuristics?
05:19:50 <aminadav_> Another things. I made new code:I made all the changes: (reverse order, fixed the bug, and don't use length). If I try more than 62 steps, it never finish: http://pastebin.com/0nZeTjVa
05:20:03 <aminadav_> It run much faster. But for 62  steps and above, it never finish
05:24:23 <int-e> aminadav_: well, for each square of the board you can compute how many neighbours have not yet been visited... and then you can observe two things: a) if an unvisited square has no neighbours left then the search will fail b) if *two* unvisited squares have only one neighbour left, then the search will fail as well... this can be used to prune the search tree
05:25:23 <aminadav_> init-e Sounds smart. 
05:25:34 <int-e> aminadav_: you can also priotize the search by visiting squares with few neighbours first.
05:27:16 <aphorisme> Mu is the fixed-pointed?
05:27:25 <aphorisme> @mpickering  : )
05:27:25 <lambdabot> Unknown command, try @list
05:29:49 <mpickering> Yes
05:30:21 <mpickering> In general search for "recursion schemes" 
05:32:32 <aphorisme> thanks a lot!
05:50:30 <joncol> Are there tools to visualize the output of a program that is built with profiling? I have a .prof file with several thousand lines, which would be nice to be able to sort etc.
05:51:11 <joncol> (Built using `stack build --profile`.)
05:51:58 <joncol> Erhrm. Visualize the profile, that is.
05:57:26 <AndreasK> joncol: There is at least a heap visualizer, note sure about execution time
05:57:43 <joncol> AndreasK: Any idea of where to find it?
05:58:47 * hackagebot regex-do 1.1 - PCRE regex funs  https://hackage.haskell.org/package/regex-do-1.1 (procione)
05:59:07 <AndreasK> joncol: http://book.realworldhaskell.org/read/profiling-and-optimization.html hp2ps seems to be the name. Although I think I used a different one because that one didn't build under windows iirc
05:59:22 <joncol> AndreasK: OK thanks
06:00:20 <Gurkenglas> What site allows me to write a simple haskell program and then let it be used by people I link it to?
06:01:10 <mauke> like a pastebin?
06:01:18 <Gurkenglas> Interactive pastebin
06:01:40 <mauke> a collaborative editor?
06:01:58 <joncol> ideone.com is good, but doesn't seem to have Haskell.
06:02:00 <Gurkenglas> No, the site compiles the program and the site visitor trades stdin for stdout
06:02:47 <mauke> I don't think that exists
06:03:24 <Clint> coderpad.io has haskell but i dunno about "stdin"
06:08:48 * hackagebot type-level-kv-list 1.1.0 - A module for hash map like object with type level keys.  https://hackage.haskell.org/package/type-level-kv-list-1.1.0 (arowM)
06:09:59 <Gurkenglas> Yep coderpad treats stdin as empty.
06:12:52 <Gurkenglas> For those also looking, say through the #haskell logs, rextester.com needs all stdin before the program runs
06:15:18 <Gurkenglas> ideone does have Haskell but also wants stdin up front
06:20:02 <Narfinger[m]> is there a good way to debug wai middleware static stuff? I think I am doing everything correctly but it is not serving my static files
06:20:40 <Gurkenglas> I don't seem to be able to run the code snippets schoolofhaskell generates like https://www.schoolofhaskell.com/tutorial-preview/7627/DPlgvClaBO
06:23:50 <stevenxl> Hello folks.
06:24:32 <joncol> Just found https://www.fpcomplete.com/blog/2015/04/ghc-prof-flamegraph, which was nice for visualizing run time in .prof files.
06:25:00 <stevenxl> I'm trying to verify my mental model of how fromIntegral works. When I apply fromIntegral to a value of type Integer, is it basically striping that value of its concrete data type and returning a value with a typeclass constraint of Num.
06:26:33 <Gurkenglas> I could setup a thing where people can say "@@ @url coin Session10 12" to interact with the thing I wanted them to be able to interact with. Is it okay if I take up (1+(number of players)) @where slots for that?
06:26:35 <jedai> stevenxl: fromInteger does that (but it's not a cast, it create a new value of "type" Num a => a)
06:26:52 <Gurkenglas> *in a query to lambdabot
06:26:59 <jedai> stevenxl: fromIntegral is basically fromInteger . toInteger
06:28:41 <Gurkenglas> Oooooh @dice lets you see who posed the query to lambdabot :D I don't even need to have "Session10" in there
06:29:55 <stevenxl> jedai: Thank you. 
06:29:58 <Taneb> The array library does not make it easy to make new array types :(
06:30:26 <stevenxl> I was just wondering what was actually going on since I couldn't make sense of it at first. But then I wrote this gist https://gist.github.com/StevenXL/64bc48d78f5fa205cf4e379506f60cd3 and the inklings of an answer came to me
06:30:57 <stevenxl> thanks again
06:32:20 <Gurkenglas> Actually, one where slot is enough, session state doesn't need to persist through @undefined I think
06:37:57 <jedai> stevenxl: From your gist, I see what was problematic to you. fromInteger do a conversion, it doesn't "change" any type, it really convert a value of type Integer to a value of a type that is an instance of Num. 
06:39:33 <jedai> That conversion is different depending on which exact type you're trying to convert to (Double, Float, Int, Complex....) which is why fromInteger must be a method of the Num class (for every type that is made an instance of Num, fromInteger exact action must be redefined)
06:41:31 <jedai> stevenxl: I will advance that one of the thing that troubled you is the fact that typeclass method can depend on the type of the return value, not the type of the value to which they are applied. This works thanks to type inference, for example in your gist you said that avgDb must returns a Double so the type of the results of dividend / divisor is inferred to be Double
06:42:32 <jedai> and in turns dividend and divisor are inferred to be Double, which means that this fromInteger is determined to be the one from the Double instance of Num
06:44:00 <stevenxl> jedai: But isn't a value of Type integer already an instance of Num? (I don't mean to be pedantic, but I find that if I don't learn the right mental model now i'll have problems down the line).
06:44:16 <ertesx> stevenxl: keep in mind that all types are static in haskell, and type classes like Num are *not* types, but they are extra information associated with a type (in most cases a bunch of functions like Num brings you fromInteger)
06:44:25 <ertesx> :t (+)
06:44:26 <jedai> on the other hand you're using fromIntegral, not fromInteger. that means you also have a toInteger in there, which is a method of the Integral class. for dividend you're starting from an Integer so your toInteger is just id but for divisor there is actually a conversion since length returns an Int
06:44:27 <lambdabot> Num a => a -> a -> a
06:45:10 <ertesx> the (+) function takes two arguments of the same type and returns another value of that same type, provided that there is a Num instance for that type
06:45:10 <jedai> stevenxl: sure Integer is an instance of Num but Double is too and here you want Double
06:45:15 <jedai> :t fromInteger
06:45:17 <lambdabot> Num a => Integer -> a
06:45:50 <jedai> stevenxl: see how the type that is any instance of Num in fromInteger is the return type ?
06:46:08 <stevenxl> jedai: I do see that yes. 
06:46:21 <jedai> stevenxl: this is what can change and will determine which fromInteger will be picked concretely in a given program
06:47:17 <stevenxl> jedai: I think that my confusion now stems from this: fromInteger will return a value whose type is an instance of Num. However, fromInteger can only be applied to a value whose type is already an instance of Num (namely, an Integer). 
06:47:49 <ertesx> fromInteger can literally only be applied to Integer
06:48:01 <ertesx> it has nothing to do with the fact that Integer is a Num
06:48:02 <jedai> stevenxl: an Integer is a concrete type, it doesn't matter that it is an instance of Num in this particular case
06:48:53 <jedai> stevenxl: each instance of Num must come with a way to convert from an Integer to a concrete value of this type which is an instance of Num
06:50:10 <jedai> stevenxl: for the Integer instance of Num, this is just id (the identity function) but for Int, the real Integer value must be potentially truncated and repackaged. for Double the conversion is even more radical
06:50:57 <nitrix> > (fromIntegral 9999999999999999999999999999999999999999999999999999999999999) :: Int
06:50:59 <lambdabot>  -6917529027641081857
06:51:02 <nitrix> > (fromIntegral 99999999999999999999999999999999999999999999999999999999999999) :: Int
06:51:05 <lambdabot>  4611686018427387903
06:51:11 <nitrix> I'm guessing it wraps around?
06:51:24 <ertesx> nitrix: modulo (maxBound + 1)
06:51:31 <Adeon> it wraps around but I'm not sure if that's, pedantically speaking, defined behaviour in haskell
06:51:34 <ertesx> uhm, no
06:51:34 <Adeon> I know it's not in C
06:51:43 <ertesx> but yeah, it does what C does =)
06:51:48 <ertesx> > (-1) :: Word
06:51:51 <lambdabot>  18446744073709551615
06:51:52 <jedai> and so on. for exemple here is the definition of fromInteger for the Complex instance of Num : fromInteger n       =  fromInteger n :+ 0
06:51:54 <Adeon> even in C it's undefined behaviour
06:51:56 <ertesx> that's 2^64 - 1
06:52:00 <Adeon> although in practice afaik it wraps around usually
06:52:07 <Adeon> and things can weird with some optimizations
06:52:20 <ertesx> Adeon: is it?  i'm pretty sure the wrapping is well-defined
06:52:34 <Adeon> let me double-check from the internetz
06:52:35 <stevenxl> jedai: Oh I think I see now. Each type that implements Num must have a way to convert from an Integer to that type. 
06:52:37 <Adeon> maybe I'm wrong
06:52:39 <nitrix> ertesx: Only is for unsigned int.
06:52:41 <jedai> stevenxl: Right
06:53:01 <stevenxl> So an instance of double has to be able to take an Integer and turn it into a double.
06:53:04 <Adeon> Signed integer variables do not have wrap-around behavior in C language. Signed integer overflow during arithmetic computations produces undefined behavior.
06:53:13 <Adeon> so it's just signed integers that get undefined behaviour I guess?
06:53:15 <ertesx> i see, interesting
06:53:16 <jedai> stevenxl: because a typeclass is not a type, it is only a set of types that each implements some specific methods
06:53:20 <Adeon> no idea if this applies to haskell
06:53:43 <ertesx> that's a good question, but i would expect at least Word* types to have modulo arithmetic standard
06:53:45 <jedai> stevenxl: Right
06:53:54 <stevenxl> jedai: awesome! 
06:53:57 <stevenxl> thank you very much
06:54:02 <ertesx> stevenxl: i suggest that you implement a numeric type yourself, just to see how type classes work
06:54:13 <stevenxl> ertesx: that is a great idea, i will do that.
06:54:23 <ertesx> stevenxl: here is an idea: data HalfInteger = Whole Integer | HalfPlus Integer
06:54:40 <ertesx> (Whole x) represents x, while (HalfPlus x) represents x + 1/2
06:54:50 <ertesx> oh, wait…  there is no (*)
06:55:31 <jedai> ertesx: Even may be a better bet
06:55:47 <ertesx> then there is no fromInteger
06:56:05 <ertesx> how about Word24?
06:56:14 <jedai> ertesx: like there is no fromInteger for Int, Double or other limited types ?
06:56:27 <ertesx> newtype Word24 = Word24 { fromWord24 :: Integer }
06:56:50 <ertesx> jedai: i think modular arithmetic is well defined, but fromInteger 1 :: Even is…  odd =)
06:57:30 <jedai> ertesx: well modular arithmetic is actually the best I think but I don't know stevenxl antecedent in Maths
06:57:44 <ertesx> well…
06:58:02 <ertesx> stevenxl: does "24-bit unsigned integer" type make sense to you?
06:58:14 <ertesx> or equivalently:  does "modulo 2^24" make sense to you?
06:58:19 <jedai> ertesx: anyway for 1, you either fail explicitly or you just say it is equal 0... given what happen with Int this is not so egregious
06:58:38 <stevenxl> ertesx: No. I don't have a math / cs background.
06:58:40 <stevenxl> :-(
06:59:22 <ertesx> stevenxl: ok, let's do this:  data Bit = Zero | One
06:59:40 <ertesx> addition is the same as exclusive or (One + One = Zero + Zero = Zero;  everything else = One)
06:59:57 <ertesx> multiplication is the same as 'and' (One * One = One, everything else = Zero)
07:00:31 <ertesx> fromInteger maps every even Integer to Zero and every odd one to One
07:00:42 <ertesx> stevenxl: did that make sense?
07:00:50 <stevenxl> ertesx: Yea. that sounds like a great exercise!
07:00:56 <ertesx> have fun =)
07:01:10 <stevenxl> Thank you. I'm saving this convo now but will certainly get back to it tonight. 
07:01:17 <stevenxl> Thank you both ertesx  / jedai! 
07:03:42 <jedai> stevenxl: By the way one reason fromInteger is so important is that it allows Haskell to have overloaded integer literals.
07:03:45 <jedai> :t 3
07:03:46 <lambdabot> Num t => t
07:04:58 <jedai> This will work even with your Num instance, you'll be able to use 0 and 1 instead of Zero and One
07:06:33 <ertesx> stevenxl: i forgot something: write this instead:  data Bit = Zero | One  deriving (Show)  -- that will allow you to see results of your Bit functions
07:08:06 <ertesx> (you could derive Eq and Ord as well, but don't…  the best haskell code is written on types that don't have Eq instances) =)
07:08:32 <Rembane> ertesx: Example needed! :D
07:08:47 <ertesx> Rembane: for what?
07:09:11 <Rembane> ertesx: The lack of derived Eq. :D
07:09:46 <ertesx> Rembane: i mean beginners often use (==) when they should be using pattern matching…  that's why i generally write Eq instances last =)
07:11:14 <ertesx> Rembane: but if you want an example anyway:  newtype Vec i a = Vec { fromVec :: i -> a };  instance (Num a) => Num (Vec a)
07:11:16 <ertesx> have fun =)
07:11:56 <stevenxl> jedai / ertesx  thank you both for the help. I have to go offline now but saving this convo for later reference. 
07:12:09 <stevenxl> ertesx: I'll get back to your exercise. Thanks for the homework. ;)
07:12:18 <ertesx> my pleasure =)
07:16:54 <Rembane> ertesx: Ah, indeed. Thank you!
07:18:03 <ertesx> Rembane: (all applicative functors have corresponding num instances, so if you need more examples, there is a template)
07:18:35 <ertesx> (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); abs = fmap abs; …; fromInteger = pure . fromInteger
07:18:57 <Rembane> There are quite a few of them. Nice!
07:19:25 <ertesx> yeah, you will run out of known universe before you run out of applicative functors =)
07:22:59 <kirillow> elemIndex returns a `Just a` - how do i extract only a since at that point in my function i already know that `x` is an element of `ls`? Or am I doing something really wrong if that is the case?
07:26:49 <twanvl> kirillow: How do you know that x is an element of the list? Did you test it with `elem`, or do you know because it is an invariant?
07:33:34 <kirillow> argh i got disconnected
07:34:50 <kirillow> I'm using `elemIndex` - how do I extract `a` from `Just a` since at that point in my function I already know `x` to be an element of `ls`? Or did i do something terribly wrong if that is the case?
07:35:13 <twanvl> How do you know that is an element? Did you check that first?
07:35:38 <kirillow> yea
07:36:21 <twanvl> Then you shouldn't do that. Instead, use elemIndex, and if it is (Just i) you know that x is in the list, and also its position, and if elemIndex returns Nothing, you know that x is not in the list
07:38:10 <kirillow> ...
07:38:13 <kirillow> of course
07:38:17 <kirillow> thanks!
07:39:28 <kuribas> :t elemIndex
07:39:30 <lambdabot> Eq a => a -> [a] -> Maybe Int
08:05:51 <maerwald> :t \x -> fromJust . elemIndex x
08:05:53 <lambdabot> Eq a => a -> [a] -> Int
08:08:55 <maerwald> kirillow: fromJust is your friend
08:09:16 <kuribas> > fromJust Nothing
08:09:19 <lambdabot>  *Exception: Maybe.fromJust: Nothing
08:09:23 <kuribas> not so friendly
08:09:32 <maerwald> kuribas: you didn't listen to what he said then
08:09:52 <kuribas> I did
08:10:10 <kuribas> It's better to rewrite with pattern matching, and use fromJust only for edge cases.
08:10:27 <maerwald> using fromJust is fine and common practice when you have proof that it's safe
08:10:49 <maerwald> just because haskell lacks a proper SMT solving/proof concept doesn't mean you have to abuse the type system for everything
08:11:02 <maerwald> that's just silly
08:12:27 <JonReed> Hi, does anybody know an easy way to render .hs source as HMTL with type annotations? Similar to how it's done here, where you get type information when when you hover your mouse: https://obsidian.systems/reflex-nyhug/#/step-21
08:12:57 <JonReed> #reflex-frip
08:13:08 <JonReed> Ups, lol
08:13:20 <JonReed> Wrong terminal
08:14:04 <kuribas> maerwald: I thought most haskellers dislike partial functions.
08:14:14 <maerwald> whatever that means
08:14:56 <latro`a_> kuribas: in general you want to avoid them because they require you, rather than the compiler, to reason about them, but they're not inherently harmful. Also, sometimes fromJust . f is total even though fromJust is not.
08:15:55 <latro`a_> related example: Map.! is a thing because sometimes you already know the thing you're looking for is a key
08:15:59 <kuribas> latro`a_: the problem is that when the code changes the invariant may change, and the typesystem will not complain.
08:16:41 <maerwald> the problem is that it's totally unrealistic in real-world code to taint all of your algorithms with Maybe/Either crap just in case you will refactor it in the future without thinking about correctness
08:16:44 <latro`a_> indeed...but if there's nothing you can actually do with a Nothing then the best you can do is make a custom fromJust with a more detailed error message
08:16:52 <maerwald> there's only so much the type system can actually tell you about correctness
08:17:12 <latro`a_> i.e. fromJust (Just x) = x, fromJust Nothing = error "this particular function tried to inspect a Nothing"
08:17:20 <latro`a_> er
08:17:21 <maerwald> in fact, haskell functions called "total" may not be actually total
08:17:26 <latro`a_> myFromJust, or whatever
08:17:46 <Hafydd> What is an example of a Haskell function called "total" which is not total?
08:18:19 <maerwald> Hafydd: a function that does not terminate
08:18:24 <liste> > sum [1..]
08:18:33 <lambdabot>  mueval: ExitFailure 1
08:18:42 <kuribas> maerwald: if you read twanvl's response, you see that he didn't need a partial function.
08:18:49 <latro`a_> we also like to pretend that floating point arithmetic works way better than it does
08:19:12 <jmcarthur> This line of conversation leads to pedantic arguments about what it means for a function to be total in the presence of infinite data structures and _|_
08:19:38 <maerwald> jmcarthur: the whole "most never use fromJust" is pedantic nonsense already 
08:19:47 <maerwald> *must
08:20:04 <jmcarthur> I never use fromJust.
08:20:10 <kuribas> I try to rewrite most code that uses head/tail
08:20:19 <obiwahn> I have a .cabal and .ghc dir in my home. The .ghc just contains some conf files. Why isn't that data in .cabal? Is all data in .cabal compatible with other compilers?
08:20:35 <kuribas> Though I do use "tail $ scanl" often
08:20:37 <jmcarthur> Even when I "know" it's safe, I always at least have an error with a better message than fromJust's.
08:20:39 <Hafydd> maerwald: a specific example.
08:20:46 <maerwald> Hafydd: ?
08:21:10 <jmcarthur> So I at least stand a chance of tracking down the bug if it bites me.
08:21:13 <Hafydd> maerwald: what is a specific example of a Haskell function called "total" which is not total?
08:21:26 <maerwald> Hafydd: a function that does not terminate
08:21:27 <latro`a_> sum
08:21:33 <Hafydd> ("A function that does not terminate" is almost just a synonym for "not total".)
08:21:36 <latro`a_> in that it can be passed an infinite list of Nums
08:21:41 <jmcarthur> id doesn't terminate by that definition
08:22:01 <kuribas> tail $ scanl is total (even if tail isn't).
08:22:01 <jmcarthur> *is not total
08:22:04 <latro`a_> eh...then you get into further pedantry because of laziness
08:22:05 <jmcarthur> > id undefined
08:22:08 <Hafydd> maerwald: I'm asking for a concrete example of a such a function.
08:22:08 <lambdabot>  *Exception: Prelude.undefined
08:22:15 <latro`a_> because id [1..] can be inspected even though
08:22:19 <latro`a_> it doesn't "terminate"
08:22:30 <latro`a_> sum [1..] can't be inspected
08:22:45 <jmcarthur> A meaningful conversation about this would bring up productivity.
08:23:42 <Hafydd> I don't think "sum" is "called total".
08:23:50 <Hafydd> Anybody calling it total is wrong.
08:25:38 <kuribas> maerwald: I used to use head/tail a lot.  Pedantic people here convinced me otherwise.  Now the only occurence of tail in my code is (tail $ scanl f x y)
08:25:53 <maerwald> fantastic
08:26:01 <kuribas> maerwald: my code isn't worse
08:26:52 <exio4> it is easier to read, I bet )
08:26:54 <exio4> :) 
08:27:47 <kuribas> yeah
08:28:09 <kuribas> I'd actually prefer scanl not to include the first element.
08:29:08 <kuribas> maerwald: but I agree that in some edge cases fromJust may be useful.
08:38:01 --- mode: ChanServ set +o glguy
08:38:01 --- mode: glguy set +b-o *!*@c-68-47-216-166.hsd1.tn.comcast.net glguy
08:43:12 <ertesx> 'filter' is not total
08:43:31 <ertesx> foldr might be total, depending on whether we view unfoldr as total
08:44:09 <ertesx> if unfoldr is total, then foldr is not total, and vice versa
08:44:31 <ongy> filter is not total?
08:44:39 <ertesx> > filter odd [2,4..]
08:44:45 <lambdabot>  mueval-core: Time limit exceeded
08:45:28 <nitrix> ertesx: As far as I know, filter's is defined on the entire domain there; it's supposed to be viewed as total.
08:45:51 <ertesx> nitrix: i just showed you that it isn't defined on the entire domain
08:46:17 <ongy> does total require to compute in finite time?
08:46:22 <nitrix> That doesn't demonstrate mch.
08:46:50 <nitrix> > take 0 $ odd [2,4..]
08:46:53 <lambdabot>  error:
08:46:53 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Bool’
08:46:53 <lambdabot>      • In the second argument of ‘($)’, namely ‘odd [2, 4 .. ]’
08:46:59 <kuribas> @hoogle Functor f => Int -> f a -> f [a]
08:47:02 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
08:47:02 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
08:47:02 <lambdabot> GHC.OldList splitAt :: Int -> [a] -> ([a], [a])
08:47:07 <nitrix> > take 0 $ filter odd [2,4..]
08:47:10 <lambdabot>  []
08:47:23 <ertesx> nitrix: 'take' is non-strict
08:47:27 <ertesx> > take 0 undefined
08:47:29 <lambdabot>  []
08:47:44 <ertesx> it has absolutely nothing to do with whether 'filter' is total or not
08:48:07 <ertesx> and 'filter' is definitely not total, because given the total arguments i applied it to, it gave me a bottom
08:49:35 <nitrix> ertesx: I was just showing you could misguide people easily by deguising what happens. What's the domain of filter? [2,4..], thus its total. Termination is an unrelated issue.
08:49:52 <nitrix> A smart enough compiler could rewrite `filter odd [2,4..]` as `[]`.
08:50:51 <kuribas> isn't filter odd [2, 4..] bottom?
08:50:55 <ertesx> that would be a dumb compiler, because it would change semantics!
08:51:07 <ertesx> filter odd [2,4..] is *supposed* to be undefined
08:51:25 <ertesx> (at least on Integer)
08:52:02 <nitrix> I think you're mixing termination wrongly into the concept of totality.
08:52:27 <maerwald> I don't really care if every single function I use is total or not. I care if the use of non-total functions is safe in my context. Because that's something haskell cannot properly assist you with, ppl tend to think it's better to not think about your code, but stuff everything full with immediate error-handling regardless of context.
08:52:47 <ertesx> nitrix: if you really think that 'filter' is total, then implement it in agda for Colist
08:52:53 <maerwald> but that's a decision the programmer makes and shouldn't be dictated
08:53:01 <kuribas> why is replicateM in Control.Monad, not in Control.Applicative?
08:53:04 <ertesx> nitrix: and if you manage to do it, please report a bug
08:53:10 <maerwald> it's sufficient to point out potential problems, not claim that some policy is the right one
08:53:25 <LKoen> maerwald: but you do need to think about your code, in order to know where to put the error-handling
08:53:49 <maerwald> LKoen: if you handle failure immediately everywhere, you don't really need to think about the context, no
08:54:10 <ertesx> nitrix: totality is related to proof consistency…  if you accept any bottom as a total result, you immediately make the underlying logical calculus inconsistent
08:54:22 <ertesx> nitrix: and that's why totality *is* strongly linked with termination
08:54:27 <nitrix> ertesx: I'm not involving bottom at all.
08:54:40 <ertesx> nitrix: then please define what "total" means
08:54:46 <ertesx> i'm using the common definition
08:54:50 <kuribas> :t replicateM
08:54:52 <lambdabot> Applicative m => Int -> m a -> m [a]
08:55:08 <nitrix> ertesx: Consider the infinitely large domain [2,4..]
08:56:09 <ertesx> nitrix: before we start…  in which framework are we working?  ZFC set theory?  type theory?
08:56:17 <osfameron> is there a function like "isInfixOfBy" ?
08:56:21 <nitrix> ertesx: Consider this domain cannot possibly contain odd values; if filter would receive additional help from the compiler, let's say it's intrinsic or dependent types are used, you could make it total.
08:56:33 <maerwald> sure, but we don't have it
08:56:39 <nitrix> I think saying `filter` is partial is contraining yourself to operational semantics.
08:57:00 <osfameron> e.g. that would return the elements of list, but do the matching as if on map f list
08:57:28 <nitrix> ertesx: We don't need to go really far. I have no intention to prove something you'd already know.
08:57:29 <ertesx> nitrix: no, any way to define filter will never yield a result for those two arguments, and a compiler that would make it result in [] would change semantics, so would be buggy
08:58:00 <nitrix> ertesx: Why couldn't it?
08:58:12 <ertesx> nitrix: because there is no way to define it in a way that it does
08:58:16 <kuribas> could haskell add refinement types?
08:58:18 <ertesx> nitrix: you're welcome to try
08:58:25 <kuribas> So you can use head only when it's safe to do so?
08:58:37 <johnw> kuribas: LiquidHaskell does this
08:58:46 <maerwald> and it's very complicated to use
08:58:54 <maerwald> pretty experimental
08:58:54 <johnw> not necessarily
08:59:00 <johnw> all depends on what you're trying to prove
08:59:09 <ertesx> kuribas: you could just use Data.List.NonEmpty =)
08:59:27 <nitrix> ertesx: Make it compiler intrinsic and it could.
08:59:28 <osfameron> hmm, there's an isPrefixOfBy in HaRe https://hackage.haskell.org/package/HaRe-0.6.0.2/src/tools/base/tests/HbcLibraries/Subsequences.hs  but that looks a bit specialist to import just for that one function
08:59:31 <maerwald> kuribas: I don't even think it will fit nicely into the language, because it would come pretty late
08:59:37 <ertesx> nitrix: i don't know what that means
08:59:59 <ertesx> nitrix: haskell *semantics* *dictate* that the result is undefined
08:59:59 <nitrix> ertesx: Implemented by GHC, rather than in user library.
09:00:11 <ertesx> nitrix: any "optimisation" that would change it would be a bug
09:00:32 <nitrix> ertesx: How can the result be undefined? If it were to ever come up with a result, you'd get [], not undefined.
09:00:47 <ertesx> but it won't ever come up with one…
09:00:55 <ertesx> to yield [], it has to see a []
09:01:02 <ertesx> but since it will never see [], it will never yield []
09:01:03 <kuribas> does liquidhaskell support ghc extensions?
09:01:23 <nitrix> A compiler that'd be able to observe the infinite range of [2,4..] would conclude that apply `filter odd` will result in [].
09:01:45 <ertesx> nitrix: what would that compiler do with a more complicated sequence than [2,4..]?
09:01:54 <ertesx> or a more complicated predicate?
09:02:00 <ertesx> clearly it doesn't solve the halting problem
09:02:06 <srk> :D
09:02:10 <srk> ertesx: try it :D
09:02:25 <nitrix> ertesx: "Try in it agda?". I don't know.
09:03:24 <ertesx> nitrix: let's say that we use a different kind of 'filter', most likely with a different kind of list that has some domain-specific knowledge (perhaps it knows something about the bounds of the numbers it contains)
09:03:40 * geekosaur is looking at this and wondering how long before people who get their magic not just proof solving but proof generating compiler complain that it hasn't solved the collacz conjecture yet
09:03:45 <nitrix> We can't adapt the definition of functional totality just to conveniently fit Haskell's semantics :/
09:03:46 <hpc> the real question here is, are you willing to have your compiler produce non-standard results for a function that basic
09:04:04 <hpc> or would you standardize it, and then what would you standardize on?
09:04:08 <ertesx> nitrix: then *in some cases* it could actually replace a bottom by an empty result, but then it would do so *within* haskell semantics
09:04:30 <ertesx> nitrix: a compiler that changes applied this optimisation to 'filter', the one for haskell lists, would be wrong
09:04:31 <hpc> some magic specific to filter and [Integer], or something more general, and what would that general something be
09:04:34 <joncol> I just realized that random number generation takes far too much time in my ray tracer. I'm trying out System.Random.MWC which seems to run faster. Is it a good idea to store the generator that I get from `createSystemRandom` in my ReaderT environment? So that I can avoid calling it multiple times.
09:04:50 <twanvl> The issue with filter is that haskell doesn't make a distinction between inductive data types and coinductive types. filter is total when applied to inductive lists, but not when applied to coinductive lists, since the latter can potentially be infinite
09:04:53 <hpc> and would every other compiler now have to spend a whole ton of effort implementing it just to produce a non-bottom result nobody cared about anyway
09:05:27 <nitrix> ertesx: I don't think there's a particuliar constraint in the Haskell language that prevents you from doing exactly that, other than GHC not being at that stage yet.
09:05:34 <ertesx> nitrix: what twanvl said…  that why i also said that you get to choose whether foldr or unfoldr is total, but never both at the same time
09:05:48 <nitrix> twanvl: But is this a Haskell issue or GHC issue?
09:05:54 <hpc> nitrix: the semantics of evaluation with respect to bottom demand that it be the way it is
09:06:04 <hpc> so yes, there is that particular constraint
09:06:30 <ertesx> nitrix: and the constraint makes sense, too…  it's like you would replace (sum (cycle [-1,1])) arbitrarily by 0
09:06:32 <hexagoxel> is there a short term for "total given termination"? i.e. to distinguish head/fromJust/.. from filter
09:06:41 <ertesx> undefined is the *proper* result
09:06:58 <hpc> hexagoxel: "unproductive" perhaps
09:07:12 <ertesx> hexagoxel: filter and head are actually non-total in the same way
09:07:25 <hpc> hexagoxel: to contrast with the concept in agda that lets you use codata, which is the productivity checker
09:07:26 <ertesx> given total arguments, they give bottom
09:09:19 <kuribas> > and $ zipWith (==) [1, 2, 3] [1, 2, 3, 4] -- osfameron 
09:09:22 <lambdabot>  True
09:09:33 <ertesx> hexagoxel: you could perhaps say explicit-error-non-total vs. non-termination-non-total
09:09:44 <nitrix> I now understand your point; but now it just appears even more arbitrary that optimization like these cannot be fulfilled.
09:09:56 <bobajett> noobie stupid question: foldr takes 3 arguments f, inital_value, xs. But in the definition of foldl' it has 4 args? 
09:09:57 <bobajett>  foldl' f z0 xs = foldr f' id xs z0
09:09:57 <bobajett>       where f' x k z = k $! f z x
09:10:00 <Lokathor> can i force stack to just use the local ghc and ignore a version mismatch?
09:10:17 <ertesx> nitrix: optimisations must not change the meaning of the program
09:10:22 <hpc> Lokathor: yes, --use-local-ghc or something like that
09:10:25 <osfameron> kuribas: ooo!
09:10:56 <hexagoxel> ertesx: head may not terminate on a non-bottom argument?
09:11:26 <ertesx> hexagoxel: … inverse-respectively =)
09:11:27 <hpc> Lokathor: though i would expect it to still choke on versions of things, usually you want to change stack.yaml
09:11:35 <ertesx> head would be explicit-error-non-total
09:11:39 <ertesx> > head []
09:11:41 <lambdabot>  *Exception: Prelude.head: empty list
09:12:10 <Lokathor> well i have an ARM device with GHC marked as 8.1.0, and it wants 8.0.1, and i want it to just stop being so pedantic and just make the things i want
09:12:18 <hpc> :t foldr -- bobajett
09:12:20 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:12:23 <hpc> :t foldl' -- bobajett 
09:12:24 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:12:36 <hpc> bobajett: maybe that helps answer your question?
09:12:38 <twanvl> bobajett: in that case, the result of foldr is itself a function, and that function is applied to the 'fourth' argument
09:12:49 <Lokathor> Invalid option `--use-local-ghc'
09:12:50 <Lokathor> :(
09:12:59 <hpc> oh no wait, read it wrong
09:13:17 <hpc> bobajett: what twanvl said, the result of that foldr is a function which is then given a parameter
09:13:19 <iphy> JuicyPixels is failing to build on travis: https://travis-ci.org/iphydf/yst#L284
09:13:22 <nitrix> ertesx: Agreed, that's obviously be very terrible otherwise, but still... I can't help but think it's the semantics you mentioned that prevents `filter` from terminating. Because of our choice of undefined and evaluation strategy, type system and whatnot. Would some of those be relaxed a bit, is there a future where `filter` _could_ be total? It seems to me like I'm able to reason that it's a total function,
09:13:25 <nitrix> just unable to be observed within Haskell's framework.
09:13:25 <bobajett> twanvl: ah! makes sense! thanks!
09:13:32 <iphy> but I see no error message
09:13:34 <hpc> bobajett: so specializing foldr to the case where b = (c -> d) of some sort
09:13:37 <iphy> any idea what could be happening here?
09:13:51 <iphy> the only idea I have so far is that it's running out of memory during compilation and gets killed
09:14:00 <ertesx> nitrix: the change that would make filter terminate is to limit lists to finite ones =)
09:14:07 <ertesx> nitrix: (or solve the halting problem)
09:14:13 <hexagoxel> ertesx: but filter restricted to all arguments where it terminates is total, right?
09:14:36 <geekosaur> iphy, that's what it looks like to me
09:14:38 <ertesx> hexagoxel: yeah, let's call that one totalFilter
09:14:38 <nitrix> ^ That was going to be my next question.
09:15:01 <hpc> iphy: try running a build with the exact same versions of everything on a local machine?
09:15:06 <ertesx> reason is that totalFilter has a different type (or is written in a different language)
09:15:55 <iphy> hpc: I don't have a linux machine
09:16:06 <iphy> I could try setting up a travis docker image
09:17:48 <nitrix> ertesx: Presumably filterTotal ~ (a -> Bool) -> InfiniteRange StartsAt2 IncrementsOf2 a -> [] :) ?
09:18:14 <ertesx> nitrix: yeah, something like that could work =)
09:18:17 <hpc> iphy: theoretically you should be able to do it with stack, just reproducing the exact versions of everything
09:18:25 <ertesx> because now you can do that optimisation *within* haskell semantics
09:18:27 <hpc> which isn't hard to use on windows
09:18:33 <nitrix> ertesx: Mhm.
09:18:41 <iphy> hpc: ah, I can try that
09:18:46 <nitrix> ertesx: That was insightful. Thanks for bearing with me :)
09:18:59 <iphy> right now I'm trying to run the same thing on one of travis' GCE VMs
09:19:09 <hpc> just getting a positive result there would confirm juicypixels isn't totally broken
09:19:29 <ertesx> nitrix: no worries…  there was actually a paper on implementing exhaustively searchable infinite sets in haskell…  just search for it, and you should find it quickly
09:19:41 <ertesx> i think an implementation is even on hackage
09:19:48 <hpc> seemingly impossible functions was the blog post
09:20:03 <ertesx> of cource that set type is not built around []
09:20:09 <ertesx> course
09:20:11 <nitrix> ertesx: Of course, there's probably a GHC extension that already breaks Haskell's semantics and does that x] ?
09:20:27 <ertesx> nitrix: i doubt it, because that would be considered a bug
09:21:03 <ertesx> in general GHC goes with:  optimise all you want, but changing semantics is out of the question
09:22:15 <hpc> the most ghc will do normally is changing bottoms into different bottoms
09:22:20 <monochrom> yes, to the point it is reluctant to do "f ↔ \x -> f x" (either direction) because seq makes them different
09:22:20 <hpc> but semantically bottoms are all the same ;)
09:22:59 <nitrix> I think the consequences (of rewriting some bottoms) would be minor; I haven't seen too much code rely on them.
09:23:13 <monochrom> yes, true too, but they're reluctant
09:23:43 <hpc> there were some cases of list fusion way back where bottoms were being eliminated
09:23:52 <monochrom> Oleg did complain about being so conservative. Because his code doesn't get optimized.
09:23:54 <hpc> and it was a bit of a problem for things that wanted to deliberately fail
09:24:15 <hpc> (waaaaay back)
09:24:21 <ertesx> nitrix: i'm not sure about that…  it can break in subtle ways…  for example rewriting the above filtering to a [] could trigger all kinds of other optimisations and rewrite rules, and before you know it, you end up with a program that might be surprising…  in good or bad ways
09:24:50 <twanvl> nitrix: you might end up with code that only works when compiled with optimizations enabled, and only on a certain version of ghc
09:25:01 <exio4> then we would need -Ounsound-optimizations
09:25:58 <hpc> ultimately it's because of the adherence to semantics that ghc works so well
09:26:06 <monochrom> Another incident was that a long time ago GHC did "(x +) = (+) x" and then one day someone noticed that the Haskell reports said "(x +) = \y -> x + y" and now once again seq can tell the difference and GHC had to go with "\y -> x + y".
09:26:16 <nitrix> I see it break when you're relying on that bottom for sure; but otherwise, I see it as a very neat optimization.
09:26:33 <geekosaur> I thought that one was fairly recent actually?
09:26:48 <hpc> nitrix: then you're relying on the absence of bottom
09:27:06 <hpc> nitrix: or you aren't relying on it in which case why have the "optimization" at all?
09:27:19 <ertesx> as soon as you go from bottom to a more defined value You Are Relying On -O
09:27:28 <hpc> (if you can even call changing denotational semantics an optimization)
09:27:55 <hpc> the best case scenario of this change is that it never happens
09:28:02 <ertesx> someone using GHCi may think that the interpreted code is much slower and wait for hours before realising that without -O it actually gives the expected result:  an infinite loop
09:28:22 <ertesx> and that -O does some magic to make the infinite loop go away
09:28:43 <ertesx> the bad kind of magic…  black magic if you will =)
09:28:54 * hackagebot rattletrap 0.2.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.2.0 (fozworth)
09:29:15 <ertesx> they say that black magic is the most persuasive…  and has the worst consequences =)
09:29:58 <nitrix> I've already signed the blood pact with Haskell anyway.
09:30:08 <hpc> or to quote doctor strange, "they should really put the warnings before the spells"
09:30:21 <MarcelineVQ> said as though there were only one
09:31:07 <kuribas> I like haskell because it _lacks_ magic. (unlike ruby, perl, etc...)
09:31:13 <exio4> monochrom: isn't that one of the "Known WONTFIX bugs"? 
09:31:37 <monochrom> which one? but both were fixed.
09:32:15 <monochrom> OK, I should do a test and look at core code to check.
09:33:03 <exio4> (x+) vs (\y -> x+y)
09:33:38 <Tuplanolla> There's `PostfixOperators` too.
09:35:47 <Tuplanolla> That's another extension I find more reasonable than the default behavior.
09:38:55 * hackagebot tw 0.1.0.0 - Trailing Whitespace  https://hackage.haskell.org/package/tw-0.1.0.0 (lovasko)
09:45:04 <monochrom> This is sad. I tried to test with "main = print (map (4 +) [1,2,3::Int])". GHC optimized it to "main = print [5,6,7]".
09:45:15 <kadoban> Haha
09:45:58 <kadoban> I wonder how complicated the mapped function can get before it doesn't do that at compile time
09:47:04 <hexagoxel> try 1:2:3:filter odd [2,4..] :D
09:47:46 <geekosaur> main = error "..." -- :p
09:47:54 <geekosaur> (yes, I know)
09:49:01 <ertesx> try this one (it will actually <<loop>>):  main = print (1 : 2 : 3 : filter odd (repeat 2))
09:49:02 <ertesx> =)
09:51:41 <monochrom> but "do { x <- readLn; print (map (4 +) (x::[Int])) }" compiles (4 +) to \x -> case x of I# y -> I# (4# +# y)
09:52:05 <monochrom> so yeah today's GHC does (4 +) = \y -> 4 + y. (This test uses -O.)
10:13:56 * hackagebot bibdb 0.5.2 - A database based bibliography manager for BibTeX  https://hackage.haskell.org/package/bibdb-0.5.2 (cacay)
10:14:24 <tong> .
10:20:05 <kuribas> :t uncurry . flip . curry
10:20:07 <lambdabot> ((a, b) -> c) -> (b, a) -> c
10:21:15 <glguy> > (() `undefined`) `seq` ()
10:21:18 <lambdabot>  *Exception: Prelude.undefined
10:21:19 <glguy> > (`undefined` ()) `seq` ()
10:21:22 <lambdabot>  ()
10:26:34 <glguy> So we can see that today's GHC doesn't
10:27:36 <glguy> > (\x -> () `undefined` x) `seq` ()
10:27:38 <lambdabot>  ()
10:28:50 <kuribas> Why isn't replicateM in Control.Applicative?
10:28:54 <kuribas> :t replicateM
10:28:56 <lambdabot> Applicative m => Int -> m a -> m [a]
10:28:56 <monochrom> exio4: ooohhh, the plot turns out to be very thick and full of twists. The short summary is that GHC seems to choose between "(+) x" and "\y -> x+y" depending on which one it thinks is more efficient.
10:29:20 <cocreature> kuribas: iirc it had a monad constraint until recently and moving it would probably have broken some code
10:29:30 <cocreature> I guess Control.Applicative could reexport it as well
10:29:34 <monochrom> So firstly I had a test case that gave \y -> x+y above. But that is not the end.
10:29:37 <Clint> :t replicateA
10:29:39 <lambdabot> error:
10:29:39 <lambdabot>     • Variable not in scope: replicateA
10:29:40 <lambdabot>     • Perhaps you meant one of these:
10:29:41 <kuribas> cocreature: why not replicateA
10:30:32 <cocreature> not sure why that wasn’t added
10:30:46 <Tuplanolla> Follow-up question: does this mean one should prefer `(x *)` over `(* x)` when `*` is symmetric?
10:31:01 <juri_> I've got a function that works when a variable is zero. I'd like to error for other cases. how do i write a function declaration for x!=0?
10:31:20 <glguy> f x | x /= 0 =
10:31:20 <ongy> depends on how you want to error
10:31:30 <monochrom> So next I was thinking "Int's (+) is strict, could that be a factor?"  So I tried the not-always-strict-and-not-always-nonstrict (&&). The boring result is that we still get (x &&) = \y -> x && y. The Surprising result is that "(&&) x" gets compiled to "\y -> x && y" too, in the context of "map ((&&) x) list"
10:31:47 <glguy> Or, just: f 0 = stuff; f _ = errorstuff
10:32:33 <juri_> glguy: thanks. ;)
10:32:49 <juri_> ongy: I'll move to justs and nothings later.
10:33:25 <monochrom> So I finally theorize that maybe GHC is making efficency judgment calls left right and centre, so a really good test case should be an operator that really is better off kept as "f x" rather than "x `f`". So I invented:
10:33:56 <monochrom> gib :: Int -> Int -> Int; gib c = fib where { fib 0 = 0; fib 1 = c; fib n = fib (n-1) + fib (n-2) }
10:35:07 <monochrom> Oh nevermind I misread core code. It still compiles to \y -> gib x y
10:36:23 <monochrom> But the surprising thing is again "gib x" also gets compiled to \y -> gib x y
10:36:53 <monochrom> OK let me try a test that really matters. "gib c = if c == 0 then undefined else fib where ..."
10:39:31 <ongy> why does it matter there?
10:40:53 <monochrom> seq can tell the difference
10:42:33 <Squarism> which has more momentum. Spock or Scotty?
10:42:35 <monochrom> ohh this is evil. I have "bomb f x = seq f (f x)".
10:44:55 <glguy> when is seq f (f x) different from f x ?
10:46:00 <monochrom> Oh! Heh.
10:46:00 <hpc> when f = tail, and x is [something]
10:46:10 <juri_> ok, that didn't make my warnings go away. :/
10:46:22 <ongy> > seq tail (tail ['a'])
10:46:25 <lambdabot>  ""
10:46:36 <ongy> > let f = tail in seq f (f ['a'])
10:46:38 <lambdabot>  ""
10:46:51 <hpc> oh wait, i misread that
10:47:52 <monochrom> I should have kept my "map f". "bomb f x = seq f (map f x)" is better.
10:53:50 <monochrom> OK, with that, both "x `gib`" and "gib x" get compiled to "\y -> gib x y"
10:55:20 <ongy> so ghc checks?
11:03:29 <monochrom> oh haha ErrorCall's documentation hasn't been updated for the newly added location information.
11:04:00 <monochrom> "This is thrown when the user calls error. The String is the argument given to error."  Note "The" String.
11:04:26 <monochrom> Then it goes on with the constructors: "ErrorCallWithLocation String String". two Strings. :)
11:04:46 <glguy> monochrom: "The" string is referring to the string in the ErrorCall fake constructor pattern ErrorCall :: String -> ErrorCall
11:05:55 <glguy> Though I agree that it would be good to document the new actual constructor
11:08:06 <monochrom> Ooohhh!!! So great pain was taken to invent and implement pattern synonyms because they just wanted backward compatibility? XD
11:09:00 <ongy> how do pattern synonyms play into this?
11:09:23 <monochrom> The old constructor was "ErrorCall". The new constructor is "ErrorCallWithLocation".
11:10:23 <monochrom> To trick user code into thinking that nothing has changed, introduce new constructor, remove old constructor, but create a pattern synonym with the old name "ErrorCall". user code is none the wise.
11:10:28 <monochrom> s/wise/wiser/
11:11:19 <ongy> oh, when catching the error?
11:11:28 <monochrom> yeah
11:14:22 <monochrom> or when creating an error yourself. (the code makes an explicit bidirectional pattern.)
11:15:26 <ongy> but for creating a normal function should work aswell
11:16:22 <monochrom> user code notices uppercase vs lowercase. This happened when State became state.
11:16:35 <ongy> oh right, forgot about that
11:17:12 <glguy> Unless you run the code on a default install of macOS ;-)
11:17:24 <ongy> what?
11:17:31 <monochrom> Hahaha yes I was thinking of that too
11:17:44 <ongy> does OSX GHC behave differntly?
11:17:59 <glguy> What's OSX?
11:18:09 <monochrom> So for example LYAH has sample code "x = State (\s -> ...)" and we have to tell readers to lowercase that, because LYAH was written before mtl changed.
11:18:17 <monochrom> hahaha
11:18:22 <ongy> unless I'm mistaken the marketing name of the operating system distributed by apple
11:18:34 <iphy> hpc: using GCE works
11:18:41 <iphy> hpc: so it's an OOM thing
11:19:04 <monochrom> So in an alternate universe, pattern synonyms happened before mtl changed, so readers of LYAH could keep the "State (\s -> ...)" code just fine. :)
11:19:04 <glguy> You're mistaken; Apple has purged OS X from memory, it's macOS now
11:19:06 <ongy> I have seen that LYAH problem be mentioned here a few times
11:19:18 <ertesx> i love how often OOM comes up here
11:19:22 <geekosaur> my recollection is it's still valid for *older* versions
11:19:28 <ongy> I thought it was always macOS and became OSX in version 10, well how mistaken I am
11:19:29 <geekosaur> 10.12 is macOS. 10.11 is still OS C
11:19:32 <geekosaur> OS X
11:19:37 <ongy> the question stands
11:20:24 <geekosaur> and if you go far enough back you have MacOS (applying to 9.x and early 10), and before that an *unofficial* MacOS (officially it was just System x.x)
11:20:57 <geekosaur> because if people knew the actual name of it, they might be able to control it, or something >.>
11:21:02 <monochrom> I go so far back, there was Apple DOS, then ProDOS, then SOS.
11:21:04 <ongy> still, why does it matter for case in GHC?
11:21:46 <monochrom> I actually liked ProDOS. But it needed more RAM then its time.
11:22:10 <grantwu> Would it be reasonable to have an extension for this? http://stackoverflow.com/questions/17241491/haskell-hide-specific-functions-in-module-exports
11:22:24 <monochrom> You know what, Apple DOS did not have subdirectories but ProDOS added that, and it was a big deal for me.
11:22:36 <ongy> subdirs? In file systems?
11:22:43 <monochrom> yeah
11:23:01 <ongy> with the amount of files I have today...
11:23:15 <kadoban> No subdirs, sounds so crazy. But then again you only had room for like 12 files on some of those old systems.
11:23:18 <maerwald> wait, is this -offtopic?
11:23:52 <grantwu> No, this is not offtopic
11:23:55 <daedra> Hello everyone, I'm currently learning Haskell with Learn You a Haskell book. However, I have a doubt with lists, more specifically concatenation. Let's say I have a list that contains lists of numbers like this:
11:24:02 <coleman> What would you guys build a small website in? Haskell? Scotty? Or some other language?
11:24:19 <daedra> let b = [[1,2,3],[4,5,6]]
11:24:25 <coleman> How do people here feel about servant?
11:24:27 <kadoban> coleman: hakyll usually
11:24:30 <ongy> it's pretty offtopic, but not -offtopic
11:24:42 <monochrom> well yeah back then you had 5.25" floppies (and, I forgot, less than 300KB each?). with the amount of files you have today, you would not need subdirectories back then, you just needed hundreds of floppies and your own boxing system for categorizing your floppies.
11:24:55 <coleman> kadoban: what about if you needed a db?
11:25:06 <daedra> And I want to concatenate another list to the end of that list of numberes like this: b ++ [[7,8,9]]
11:25:11 <coleman> kadoban: would you depart from haskell or would you go with yesod or something?
11:25:48 <kadoban> coleman: Depends how complicated, if it was tiny I might just do some PHP nonsense if it's a one-liner essentially. Otherwise, I'm probably not the best to answer, but I'd probably do yesod.
11:25:50 <daedra> It works however, why do I have to add the double brackets to concatenate it to the end of the list but I don't have to add double brackets to concatenate them to the begining of the list?
11:26:04 <ongy> :t (:)
11:26:05 <lambdabot> a -> [a] -> [a]
11:26:06 <ongy> :t (++)
11:26:08 <lambdabot> [a] -> [a] -> [a]
11:26:10 <ongy> daedra: do you see the difference?
11:26:18 <coleman> kadoban: okay, thanks.
11:26:21 <glguy> daedra: You do have to use the backets if you're appending to the front of the list using ++
11:26:31 <glguy> [1] ++ x;   x ++ [1]
11:26:37 <daedra> I mean lie this: [3,4,5]:b
11:26:42 <ongy> if you used (++) to prepend, then you will need double brackets
11:26:43 <daedra> That works without double brackets.
11:26:46 <ertesx> daedra: concatenation is not the same as "consing"
11:26:50 <geekosaur> so you don't see the difference there?
11:27:20 <ertesx> daedra: (:) prepends an *element*, and your elements happen to be lists
11:27:26 <ertesx> > 1 : [2,3,4]
11:27:28 <lambdabot>  [1,2,3,4]
11:27:30 <geekosaur> data List a = [] | a : List a
11:27:56 <monochrom> daedra, I suggest working out the types rather than trusting intuitive.
11:28:00 <monochrom> s/intuitive/intuition/
11:29:07 <monochrom> To be sure, the types still don't tell you what is done. But if your code doesn't type-check, then nothing is done, there is no "what is done?" question.
11:30:10 <daedra> Oh than ks.
11:30:18 <daedra> Thanks*
11:30:24 <daedra> I didn't understood the difference.
11:30:40 <daedra> Yeah, I see the difference now.
11:30:48 <amx> daedra: You could write an appending operator for practice.
11:31:14 <daedra> I was mixing conses with appends.
11:31:23 <daedra> That's why it was different.
11:31:47 <daedra> That's a great idea amx.
11:31:49 <daedra> :)
11:32:12 <daedra> Thanks everyone. :)
11:32:41 <clmg> coleman -> clmg
11:33:00 <kuribas> Will mapM, liftM, etc ever be deprecated?
11:33:10 <grantwu> What's wrong with them?
11:33:31 <kuribas> grantwu: they are too specific
11:33:42 <grantwu> What should I be using instead?
11:33:53 <kuribas> fmap, traverse
11:34:26 <kuribas> grantwu: you can use them if they aren't deprecated :-)
11:34:55 <kuribas> :t fmap
11:34:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:35:00 <kuribas> :t liftM
11:35:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:35:38 <ezyang> Hi #haskell, convince me out of writing my own test framework runner 
11:35:40 <grantwu> Oh, lol, I thought you meant that fmap was a replacement for mapM just then
11:36:05 <ezyang> We're currently using tasty but (1) I don't like the cli and (2) my tests are all in files, and I don't want the runner to do a full scan of all the directories when I ask for a single file 
11:36:49 <hpc> ezyang: just use makefiles ;)
11:36:56 <ezyang> ugh that's even worse lol 
11:36:58 <monochrom> oh haha "import Data.Maybe(pattern Just)" is for importing the data constructor Just
11:37:35 <kuribas> grantwu: no liftM = fmap and mapM = traverse
11:38:02 <amx> kuribas: hlint is actually complaining when you use liftM
11:38:18 <monochrom> ezyang: I convince you to write your own cli wrapper instead.
11:38:20 <kuribas> amx: ah, I didn't know :)
11:38:34 <maerwald> amx: not the only thing that makes it annoying though
11:39:03 <amx> it is annoying at times, but it also taught me a lot
11:39:09 <ezyang> monochrom: Ugh, then I have to learn how Tasty is modularized here 
11:39:17 <monochrom> I also convince you to use SSD and a lot of RAM-based disk cache to mitigate problem #2
11:39:19 <maerwald> why would personal preference teach you anything
11:40:09 <amx> because when I started out my code was just objectively bad ;)
11:40:17 <monochrom> ezyang: Like the other conversation says, it's annoying but you'll learn something :)
11:40:32 <maerwald> linters should be configurable, otherwise they are useless
11:40:40 <ezyang> ok FINE :) 
11:41:32 <amx> I think it is somewhat configurable, though I never bothered
11:42:45 <maerwald> I don't mean configurable in the xmonad sense ;)
11:44:24 <geekosaur> hlint can be configured... via annotations
11:44:52 <ertesx> or you use hlint as part of a test-suite, then it makes sense that it's configurable in the xmonad sense
11:45:03 <monochrom> w00t, that will be useful. what is the annotation for "turn off everything" so I can use it on lpaste?
11:46:10 <amx> try: {-# ANN module "HLint: ignore" #-}
11:46:13 <maerwald> geekosaur: useful linters can be configured with a configuration file where I can define the ruleset
11:46:27 <maerwald> turning stuff on and off is not really configuration
11:46:51 <monochrom> No, let's cut to the mustard.
11:46:58 <ertesx> philosophy time!
11:46:59 <monochrom> Useful linters are written by me.
11:47:03 <ertesx> what is real configuration?
11:47:12 <maerwald> I just told you
11:47:23 <kadoban> maerwald: You can customize hlint a lot more than you seem to think
11:47:39 <kadoban> You can specify hint package(s), write your own, all kinds of stuff.
11:47:58 <clmg> Is it possible to use `let` variables a component of a list comprehension?
11:48:23 <kadoban> And yes you can do it in a config file, not just inside source files too.
11:48:40 <clmg> like: `[x | x <- [1.10], y <- [1..a], let a = x * 2]`?
11:48:47 <clmg> or something similar?
11:49:20 <maerwald> kadoban: that's writing modules, not configuration files
11:49:21 <kadoban> clmg: Ya. Pretty sure that's the syntax, definitely something like that
11:49:39 <clmg> kadoban: it says var not in scope `a`.
11:49:42 <ertesx> http://lpaste.net/329757
11:49:44 <ertesx> it works!
11:49:47 <amalloy> you have to let the a before you use it
11:49:49 <kadoban> maerwald: Which differs how? You can choose which hints you like and don't, what else would you want?
11:49:50 <clmg> kadoban: because it's defined after?
11:50:22 <kadoban> Ya, looks like it
11:50:52 <maerwald> kadoban: writing configuration files and code is pretty different, which is why I said I do not mean the "xmonad" style configuration
11:51:39 <ertesx> what's the difference between "xmonad style" and…  uhm…  "non-xmonad style"?
11:51:46 <maerwald> ertesx: I just told you
11:52:05 <ertesx> maerwald: hmm?
11:52:23 <maerwald> ertesx: maerwald: kadoban: writing configuration files and code is pretty different, which is why I said I do not mean the "xmonad" style configuration
11:52:35 <ertesx> yeah, but what is the difference?
11:52:39 <maerwald> erm
11:52:40 <kadoban> Every config file has syntax you have to follow. How do you differentiate some DSL vs "configuration files"?
11:52:55 <maerwald> kadoban: the difference is the complexity
11:53:13 <maerwald> coming up with a configuration file format that doesn't require someone to learn a whole new DSL is more challenging
11:53:16 <maerwald> and that exists
11:53:16 <kadoban> maerwald: How would you specify hints to operate on haskell code in a simple fashion?
11:53:22 <hexagoxel> "do you need a compiler/interpreter other than the program being configured"
11:53:43 <grantwu> kadoban: I mean... presumably the way other language's linters do it?
11:53:49 <maerwald> exactly
11:53:51 <kadoban> grantwu: Which is?
11:53:57 <maerwald> what I just said
11:54:18 <ertesx> where is the line?  i mean a configuration language good enough to specify linter settings is going to be complex
11:54:22 <grantwu> A list of rules.  "Replace liftM with fmap" could be a rule.  "Suggest Control.Arrow" functions coudl be another one.
11:54:37 <grantwu> er, "Suggest Control.Arrow functions"
11:54:42 <maerwald> ertesx: complexity, as I already said
11:55:04 <maerwald> if every app out there would have it's own DSL you have to learn before you can configure anything, oh boy... have fun
11:55:11 <kadoban> grantwu: Those are pretty much what the config files are, AFAIK ...
11:55:16 <hexagoxel> of course that distinction becomes vague too once you incorporate the compiler into the program.
11:55:20 <ertesx> there is a point where, "learn this configuration language" becomes similar in complexity to "learn haskell", except that the users of a linter are already haskell programmers, so if you just use haskell, they don't have to learn another language
11:55:35 <grantwu> kadoban: Config files for which program?
11:55:42 <maerwald> learning haskell is more complicated than configuration format
11:55:43 <kadoban> grantwu: We've been talking about hlint
11:55:53 <ertesx> maerwald: not for people who are already haskell programmers
11:55:56 <ertesx> i.e. the users of hlint
11:56:37 <grantwu> kadoban: Can you point to the documentation for the hlint configuration file
11:57:00 <kadoban> grantwu: https://hackage.haskell.org/package/hlint the very bottom of this is most I know of. I'm sure there's more somewhere
11:57:32 <ertesx> i can see how xmonad could use a different language, but then you would basically invent a programming language…  instead xmonad says: "screw it, we're just gonna reuse haskell"
11:57:44 <ertesx> and i'm glad that it does =)
11:57:49 <maerwald> ertesx: that's more or less an assumption even. In the real world, someone who isn't a haskell programmer might actually be the one who's defining the ruleset based on information he has been given. But that's not even the point
11:57:57 <grantwu> http://community.haskell.org/~ndm/darcs/hlint/hlint.htm Seems to suggest that hlint uses straight .hs files
11:58:13 <ertesx> maerwald: that's a reality i have yet to experience =)
11:58:49 <grantwu> You don't really need to 'invent a programming language" to configure most things
11:58:58 <kadoban> grantwu: It's just a really simple replacement format though. Would it somehow be magically easier if it didn't use haskell syntax? (how?)
11:58:59 <grantwu> Most configuration things are nowhere near turing complete
11:58:59 * hackagebot MBot 0.1.0.2 - Haskell interface for controlling the mBot educational robot  https://hackage.haskell.org/package/MBot-0.1.0.2 (cfscholl)
11:59:01 <maerwald> I think there's actually laziness behind that "let's reuse haskell" argument, because coming up with a powerful and easy configuration language is magnituted harder
11:59:28 <grantwu> kadoban: What is the format?  I don't see it documented anywhere
11:59:56 <grantwu> http://community.haskell.org/~ndm/darcs/hlint/hlint.htm just says 'use the hlint.hs file".
12:00:20 <ertesx> if haskell were a lot more like C or fortran, i would agree, but haskell is a decent configuration language, and you can even teach the relevant parts of it without teaching full haskell…  i think reusing haskell is a brilliant choice
12:00:24 <ertesx> also haskell is far from alone
12:00:30 <ertesx> in python land reusing python is all over the place
12:00:53 <kadoban> grantwu: The vast majority of what I've ever done is just the last thing it lists, you just write    error = something ==> somethingelse   with single lettle variables allowed
12:00:54 <maerwald> grantwu: same for "hsimport"... poorly documented and you end up with sth like https://git.io/vX4NB ...tell me that's easy configuration
12:00:56 <maerwald> it's not
12:01:26 <kadoban> I dunno, whatever, there's no progress to be made in this conversation, I'm going to do something else.
12:02:13 <grantwu> So, I found the default https://github.com/ndmitchell/hlint/blob/cdbe8d7ae05635b560c81d0224932159fb885466/data/Default.hs
12:02:56 <grantwu> This seems very magical to me
12:03:29 <lpaste> monochrom pasted “section vs lambda” at http://lpaste.net/329764
12:03:35 <grantwu> warn = putStrLn (show x) ==> print x
12:03:38 <grantwu> Where is x defined here?\
12:04:19 <kadoban> grantwu: It's not. It's just a variable for substitution. It's pretty much a forall or something.
12:04:33 <grantwu> Okay, where does this variable come from
12:04:42 <Tuplanolla> I get the feeling that this module isn't compiled, but fed to TH, grantwu.
12:05:02 <grantwu> -_- ah.
12:05:07 <kadoban> grantwu: So now the complaint is that this isn't sufficiently close to haskell code? Can't win.
12:05:30 <maerwald> kadoban: the complaint seems to be that's hard to understand what's going on and documentation is largely missing
12:05:46 <kadoban> maerwald: Your complaint was actually not that though, are you changing it?
12:05:56 <maerwald> kadoban: no, I am interpreting what grantwu said
12:06:04 <maerwald> "the complaint seems to be"
12:06:09 <monochrom> yes, the question is how do you know that "x" is a dummy variable but "show" is not.
12:06:46 <grantwu> Well, I am saying that 'hard to understand what's going on and documentation is largely missing" is a consequence of reusing a full blown general purpose programming language - in this case, something that ends up being fed through TH - as a configuration language
12:06:58 <monochrom> and of course most of the time you can answer "there is already a show in scope because Prelude is pervasive"
12:07:07 <maerwald> and now you probably need to understand TH to write stuff as well?
12:07:26 <monochrom> but in principle it is still risky
12:07:31 <kadoban> I have no godly idea how to use TH and I've personally configured hlint hints fine. *shrug*
12:07:48 <ertesx> this is hlint's fault for not documenting (or does it?  i haven't checked)
12:07:49 <grantwu> Fwiw, when Python utilities reuse Python, I've only ever seen them basically use a very restricted subset
12:07:54 <ertesx> not for using haskell
12:08:02 <MarcelineVQ> kadoban: You should chekc out TH, it's really quite fun
12:08:09 <grantwu> There's https://github.com/ndmitchell/hlint/issues/160
12:08:15 <maerwald> ertesx: yeah, this argument would apply to any configuration format as well
12:08:23 <ertesx> correct
12:08:42 <kadoban> MarcelineVQ: I tried a couple of times, but I think I lacked a sufficiently compelling use-case.
12:09:56 <ertesx> would grantwu's problem disappear, if they had used YAML?  no, because there still wouldn't be documentation…  and now you are faced with a language that doesn't even have the concept of scope, so if you see an "x" you couldn't even reason: "huh?  that must be out of scope"
12:10:25 <grantwu> Actually, presumably, if it was YAML, it would be ruleNameHere = On or ruleNameHere = Off
12:10:44 <ertesx> grantwu: you can have that in haskell
12:10:51 <maerwald> ertesx: with java linters there's a huge set of predefined rules you can configure, so most of the time you're not actually writing a rule from scratch
12:10:54 <ertesx> but hlint's rules are more complicated
12:11:00 <maerwald> and that's hard to do
12:11:13 <ertesx> maerwald: i agree that hlint could do a better job
12:11:21 <grantwu> Yes, well, I argue that since hlint decided to use Haskell as a configuration language, it was tempting for them to just put the rules in the configuration file.
12:11:23 <maerwald> I'm not saying it's easy 
12:11:28 <grantwu> as in the definition of the rules
12:11:28 <ertesx> but i assert that the language choice is irrelevant
12:12:17 <maerwald> ertesx: I disagree on that, unless you define a very strict subset as grantwu said, otherwise the complexity of the haskell language leaks in
12:12:33 <grantwu> So I can kind of see what ertesx is saying here
12:12:34 <maerwald> and you really only want to set a few stupid rules, not make configuring it another project :P
12:12:51 <grantwu> But I do believe that choosing Haskell makes it tempting to put too much complexity in the config file
12:13:16 <grantwu> Also, can I reconfigure hlint without recompiling it o.o
12:13:31 <osfameron> obviously the correct choice is XML, with a schema to make sure you do it in the right format!
12:13:34 * osfameron ducks
12:13:42 <kadoban> grantwu: Yes
12:13:56 <grantwu> How does that work...
12:14:20 <ertesx> maerwald: there is nothing wrong with documenting/using that strict subset and still just reuse haskell, unless you start complaining about the necessary noise in the context of on/off switches:  config = Config { blah = True, blubb = False, emperor'sNewGroove = HellYeah, … }
12:14:32 <kadoban> No idea how it's implemented if that's what you mean. You just point at the file, or I think you can name it something magical in the current directory and it works too
12:14:37 <maerwald> ertesx: well, in that case you can call it a configuration format
12:14:41 <ertesx> maerwald: and i think we're in agreement now =)
12:14:47 <maerwald> probably
12:15:09 <grantwu> kadoban: Well, is hlint like, recompiling this .hs file everytime you change it? Or is it parsing Haskell source...
12:15:37 <kadoban> nfc. It's fast whatever it's doing, at least I recall no annoying slowdowns.
12:15:46 <sm> hledger uses a custom DSL for configuring CSV conversion, haskell would be way too high a bar for plenty of users
12:16:46 <Tuplanolla> If only GHC was in `Prelude`...
12:16:53 <ertesx> sm: "pretend that this is JSON with slightly different syntax and some extra noise at the top"
12:17:22 <sm> I don't think that makes them the same
12:17:41 <sm> imagine yourself as a non-programmer, walk through both scenarios
12:17:42 <ertesx> there are many xmonad users who are not haskell programmers and have no knowledge of types or laziness
12:18:05 <grantwu> Yeah, I know one, she just asks her boyfriend whenever she needs to change the config...
12:18:13 <ertesx> hehe
12:18:14 <sm> just ensuring a toolchain to run or compile it is too high a bar already
12:18:33 <ertesx> sm: that one is a valid point
12:18:38 <ongy> I more or less started to get more into haskell because of xmonad. because I didn't want to just copy+paste configure it
12:19:00 * hackagebot stt 0.2.0.0 - A monad transformer version of the ST monad  https://hackage.haskell.org/package/stt-0.2.0.0 (mckeankylej)
12:19:16 <ertesx> the interesting part of that is that you *can* copy/paste-configure xmonad =)
12:19:52 <ongy> I kinda failed at that. but that's because I'm dumb
12:20:37 <maerwald> ongy: I don't use xmonad because it's too tempting to over-configure it and waste time with the power you've been given. That's also one of the reasons I don't like that "configuration" style.
12:21:58 <maerwald> imagine i3 did the same and you'd be required to go full-C just to configure basic stuff. Thank god that's not the case :P
12:22:18 <ongy> maerwald: you are going to like https://github.com/monky-hs/monky :P. but yeah, I have moved (most) of my background setting into my xmonad config. It's more code than the actual config
12:23:13 <ongy> I think awesome does most with lua, which also works pretty well
12:23:28 <maerwald> yes, which is why I've never used awesome
12:23:33 <ongy> but the i3 environment is just pretty well made, including the config
12:23:38 <ongy> but this is getting offtopic
12:23:43 <maerwald> slightly
12:23:54 <Tuplanolla> Ideally you wouldn't need to configure anything.
12:23:57 <maerwald> we can still consider this a proposal for improving hlint config
12:24:00 * hackagebot language-javascript 0.6.0.9 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.9 (ErikDeCastroLopo)
12:24:19 <ongy> how is hlint configured?
12:24:23 <maerwald> Tuplanolla: make the haskell comittee decide on coding style? :o
12:24:37 <bas__> Hello there!
12:24:41 <ongy> hi
12:25:09 <bas__> would it be ok if I asked a beginner question here?
12:25:23 <bas__> I have done my research, but getting a bit stuck
12:25:25 <ongy> Tuplanolla: imo everything should work without an initial config in some way, but people want different things, so configuration is pretty important
12:25:29 <ongy> sure
12:25:31 <Tuplanolla> It's definitely a terrible fit for Haskell, but I'd like to see a language with a canonical isomorphism between source code and syntax trees. Anything else would be wrong.
12:25:47 <ongy> bas__: the "sure" was for you
12:26:22 <bas__> I just wrote my first and very simple custom Eq (so without deriving) in the Eq MyType where fashion
12:26:56 <bas__> all fine, and it worked and it worked without me having to define an instance of the (=/) function
12:27:14 <ertesx> Tuplanolla: i *really* don't want to program in such a language
12:27:27 <ertesx> every time i see people starting lines with commas it makes my stomach turn
12:27:54 <kadoban> , why?
12:27:54 <bas__> I suspect that is due to the fact that the Eq class in prelude has a default if (==) is false return true
12:27:59 <Tuplanolla> If it happened to J, nobody would even notice.
12:28:06 <ertesx> so i'm glad not to be forced to commit such a typographical atrocity
12:28:29 <bas__> My question is: where do I find the prelude source code? I have been searching for a while... (I am aware of hoogle and hackage)
12:28:54 <EvanR> bas__: look in base (the package)
12:29:08 <bas__> I did EvanR 
12:29:16 <ertesx> bas__: a git repo is linked there
12:29:34 <glguy> bas__: the haddock documentation has source code links
12:29:38 <ertesx> bas__: alternatively you can also look into the Prelude documentation and follow the "Source" link in the upper right
12:29:41 <kadoban> bas__: Exactly. It has defaults of: a == b = not $ a /= b    and   a /= b = not $ a == b, or something to that effect.  https://www.stackage.org/haddock/lts-7.8/ghc-prim-0.5.0.0/src/GHC-Classes.html#Eq for example. If you look up Eq in hackage, it'll have a Source link next to it too
12:29:41 <MarcelineVQ> bas__: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html for each item there's a link on the right that says Source, it's grey so it's hard to see, alternatively on the top right of the page is a link that says Source
12:29:46 <EvanR> bas__: https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html
12:29:51 <ongy> haddock is missing source link for Eq and Ord
12:30:10 <maerwald> haddock doesn't work well with CPP, so I'd look up the source repo
12:30:47 <ongy> Eq needs cpp?
12:31:04 <maerwald> I don't know, this wasn't a specific response to you
12:31:43 <Tuplanolla> It should be in `GHC.Base`.
12:31:45 <bas__> okay guys, I have been on that page of prelude and at the Eq section, the source link does not seem to work
12:32:03 <EvanR> class Eq isnt in there
12:33:02 <Tuplanolla> How about `GHC.Classes`?
12:33:04 <bas__> EvanR, okay. The link of kadoban gave me my answer
12:33:14 <bas__> Tuplanolla, yep there it is indeed
12:33:46 <Tuplanolla> You can follow the leads from `Prelude`, but it's not easy to guess where to go.
12:33:53 <kadoban> bas__: If one of hackage or stackage isn't working, you can always try the other. I usually try stackage first, hackage is borked more often IME.
12:34:02 <clmg> How efficient is (reverse [1..10]) to get a descending list?
12:34:05 <ongy> ok, Eq is a bit hard to find
12:34:14 <clmg> any superior construct?
12:34:23 <ongy> > [10, 9 .. 1]
12:34:25 <kadoban> clmg: In general, reverse is O(n) in the size of the list
12:34:26 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
12:34:36 <maerwald> in this case, it's O(1) though :P
12:34:49 <ongy> how? is there a rule?
12:34:51 <clmg> ongy: wow, I didn't realized it worked that way
12:34:52 <EvanR> reverse [1..10] is as fast as possible: O(1)
12:35:04 <EvanR> until they invent O(0)
12:35:09 <bas__> Tuplanolla, indeed kadoban and ongy it is quite hard to find. Thanks for the stackage tip, I was not yet aware of that. However: thus far Haskell is making me as happy as a child and finding things is sure more easy than with other PL
12:35:55 <kadoban> Why is reverse [1..10] O(1) ? A RULES directive or something?
12:36:06 <ongy> 'grep -re "class.*Eq" .' in the base source just confused me. kadoban how did you find it?
12:36:22 <kadoban> ongy: Looked up Eq on stackage and clicked the link for Source
12:36:41 <EvanR> it finishes in constant time
12:36:50 <EvanR> no matter how big 10 gets
12:36:58 <ongy> ohh, it's in prim, not base. that explains things
12:37:18 <bas__> Thanks guys!
12:37:19 <kadoban> EvanR: Annoyingly pedantic
12:37:21 <EvanR> lol
12:37:43 <ongy> but correct
12:38:01 <ongy> or would "O(x) is not applicable here" be more correct?
12:38:30 <kadoban> Yes. Or just answering the implied question, which is otherwise annoying to specify such that a pedantic answer isn't possible.
12:38:39 <kadoban> But fair enough.
12:39:24 <maerwald> haha
12:39:37 <maerwald> -Wall -Werror -Wextra -pedantic
12:40:44 <ongy> ghc has -pedantic?
12:40:53 <maerwald> -.-
12:41:07 <kadoban> I think those were flags to the current instance of #haskell
12:41:07 <ongy> but EvanR has
12:44:52 <EvanR> actually, what was the implied question?
12:46:26 <EvanR> ongy: well, its a good question when O( ) does apply. And its easy to be fooled into thinking that it does apply, for example if someone decided to use a bounded functional queue, and set the length to 100.
12:46:48 <EvanR> sometimes the questionable conclusion is that 100 is long enough to be N
12:48:19 <ongy> does it need to be high? with amortised costs I see why, but without?
12:48:47 <EvanR> when its unbounded, thats something else
12:48:49 <kadoban> EvanR: The implied question would IMO be: what is the cost of reverse, in terms of the input size, assuming the result is actually used, compared to the same thing without using reverse, only considering the added evaluations needed to reverse the list, assuming the GHC cost model. Probably a few other caveats.
12:49:07 <EvanR> yeah i didnt infer all that
12:50:20 <EvanR> ongy: actually i was thinking of using a linked list with (:) and init as a queue
12:50:25 <EvanR> but bounded to 100
12:50:54 <EvanR> for the sake of wondering if O matters
12:50:57 <ongy> and the "head" of the queue as last?
12:51:21 <EvanR> yeah
12:53:17 <ongy> and compare that against e.g. the amortised O(1) queue from okasaki?
12:54:54 <EvanR> both use the same sort of boundedness assumption
12:55:10 <EvanR> both O(1)
12:55:13 <maerwald> are we still nitpicking on complexity?
12:55:21 <EvanR> yes maerwald 
12:55:37 <EvanR> but no fair nitpicking nitpicking since its not a monad
13:09:01 * hackagebot stt 0.2.1 - A monad transformer version of the ST monad  https://hackage.haskell.org/package/stt-0.2.1 (mckeankylej)
13:14:43 <nshepperd> pedantically, O(·) never matters
13:15:12 <Tuplanolla> Usually it's not even written correctly.
13:15:13 <nshepperd> because you don't actually care about asymptotic running time / space, but running time with realistic inputs
13:16:08 <theduke> Is there a good way to get the utf8 encoded byte length of a string?
13:17:32 <theduke> I've tried `import qualified Data.ByteString.Char8 as BS; BS.length $ BS.pack ""`
13:17:44 <theduke> which gives 1, but it's 2 bytes in utf-8
13:18:04 <Clint> thunderrd_: Char8 does horrible things
13:18:12 <Clint> only ever use it for ascii
13:18:33 <Clint> er
13:18:36 <Clint> theduke: ^
13:19:44 <geekosaur> char8 is fine for going bytestring to string, dangerous for the other way
13:20:24 <nshepperd> if you're using a linked list with cons and init as a bounded queue, and your realistic queue size is always less than the bound, it may be useful to know that the running time of 'push' is approximately linear in queue size
13:20:36 <dubbelosix> hey all...new to haskell here. have a question around cabal...what exactly is the difference between cabal build and cabal install?
13:21:23 <sm> cabal install fetches (haskell) dependencies, does a cabal build, and copies executables to a cabal bin directory
13:22:04 <theduke> Good to know. ^^ I wouldn't want to use it anyway, I just need to get the byte length
13:22:06 <dubbelosix> i see...so cabal build assumes that all the dependencies are already present?
13:22:09 <theduke> ah I found away
13:22:13 <sm> yes
13:22:21 <sm> cabal new-build may be different
13:22:36 <dubbelosix> i see...thanks
13:23:12 <theduke> Data.ByteString.length $ (Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "")
13:23:35 <sm> a typical workflow would be cabal install --only-dep (installs deps only), cabal build (build in place), and optionally cabal install (install to bin dir)
13:23:40 <theduke> I can live with that ^^
13:24:34 <sm> stack build, on the other hand, does fetch deps if needed
13:26:20 <dubbelosix> ah...so the second time you do install, it copies the executables ?
13:27:11 <sm> that would be the case in this example, yep
13:40:03 <soLucien> hello guys ! is it possible in Parsec to get the contents of the Right as well as the Left upon an error ?
13:40:16 <geekosaur> no
13:40:26 <geekosaur> if it is a Left, it does not have a Right
13:40:31 <geekosaur> if it is a Right, it does not have a Left
13:40:48 <soLucien> i want to see how far the parser went into the input, and the tokens it was able to go through
13:40:54 <soLucien> is it possible?
13:40:55 <soLucien> ok 
13:43:51 <nomotif> Dumb question: Is there an agreed upon HTTP library for Haskell?
13:44:43 <hpc> http-conduit is pretty alright
13:45:03 <hpc> to some extent there's a proliferation because there's a few different levels of abstraction you might want
13:45:04 <maerwald> it gets more opinionated once you ask for web frameworks
13:45:24 <nomotif> Yeah.
13:45:27 <hpc> also because there's some weird historical stuff like libraries that wrap around wget and curl
13:45:56 <nomotif> Got it.
13:46:04 <nomotif> Thanks
13:46:06 <nomotif> !
13:53:47 <smelcome> I'm trying to use reads :: ([Int, String]) for getting an integer from the user, and asking the user again if there is a parse error. The problem is that I'm having an issue figuring out how to do proper pattern matching for an error. Should I use a case statement?
13:54:44 <Koterpillar[99]> > reads "15" :: ReadS Int
13:54:47 <lambdabot>  error:
13:54:48 <lambdabot>      • Couldn't match type ‘[(a0, String)]’
13:54:48 <lambdabot>                       with ‘String -> [(Int, String)]’
13:54:58 <Koterpillar[99]> > (reads :: ReadS Int) "15"
13:55:03 <lambdabot>  [(15,"")]
13:55:07 <Koterpillar[99]> > (reads :: ReadS Int) "blah"
13:55:12 <lambdabot>  []
13:55:17 <Koterpillar[99]> > (reads :: ReadS Int) "15 and then blah"
13:55:20 <lambdabot>  [(15," and then blah")]
13:55:57 <Koterpillar[99]> smelcome: yes, you can use a case statement, matching with either [(x, "")] or [(x, _)] depending on how strict you want to be
13:56:17 <smelcome> Thanks. That's what I was looking for. I'll try that.
14:07:54 <NickHu> I have a MaybeT IO action; how can I run it over and over until I get a Just value?
14:08:07 <NickHu> (It uses random so it can fail)
14:10:44 <EvanR> NickHu: write a one-off recursive function for it
14:11:18 <hpc> take a look at (<|>) as well, for writing it
14:11:39 <hpc> possibly
14:11:44 <hpc> not sure how that'll deal with IO
14:12:25 <lyxia> fix (action <|>)
14:13:15 <Myrl-saki> If you do a compare of 2 sorted lists, and you know that length xs > length ys
14:13:30 <Myrl-saki> Is the complexity just O(n)?
14:13:46 <kuribas> mfix?
14:13:48 <kuribas> :t mfix
14:13:50 <lambdabot> MonadFix m => (a -> m a) -> m a
14:13:56 <hpc> the complexity's O(n) anyway
14:14:07 <Myrl-saki> Err
14:14:11 <Myrl-saki> Oh wait, not a compare!
14:14:16 <Myrl-saki> A batch membership check.
14:14:27 <hpc> mfix isn't quite it, the effects of the (a -> m a) only happen once
14:14:30 <Myrl-saki> Or sublist.
14:14:39 <Koterpillar[99]> Myrl-saki: sublist or membership?
14:14:49 <Koterpillar[99]> Myrl-saki: consider batch_membership a (reverse a)
14:14:56 <Myrl-saki> Koterpillar[99]: True.
14:15:35 <Myrl-saki> Basically, `a `elem` powerlist b`
14:15:43 <Myrl-saki> I think
14:16:05 <Myrl-saki> Oh wait. powerlist doesn't take account for the different permutations. Just ignore that. I haven't slept yet.
14:16:25 <Myrl-saki> So, yeah. I'm confused if it's O(n) or O(n + m).
14:16:40 <Myrl-saki> Looking at Data.Set makes me think of O(n + m).
14:16:47 <NickHu> I did this in the end: http://lpaste.net/329798 is there a neater way?
14:18:02 <Myrl-saki> NickHu: As the error says. Use maybe.
14:18:07 <Myrl-saki> :t maybe
14:18:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:18:12 <Myrl-saki> :t isNothing
14:18:14 <lambdabot> Maybe a -> Bool
14:18:53 <lyxia> Or just pattern matching.
14:18:56 <Myrl-saki> NickHu: `maybe (dontFail x) return`
14:19:04 <Myrl-saki> NickHu: `maybe (dontFail x) return r`
14:19:19 <Myrl-saki> Or use mfix.
14:19:22 <Myrl-saki> Probably.
14:19:29 <Myrl-saki> mfix, First?
14:19:35 <ertesx> Myrl-saki: what's the type of the function you're trying to figure out?
14:20:02 <Myrl-saki> ertesx: :: Eq a => [a] -> [a] -> Bool.
14:20:07 <Myrl-saki> ertes: Both lists are sorted.
14:20:31 <Myrl-saki> Errr
14:20:33 <ertes> Myrl-saki: ok, and it returns True iff …
14:20:41 <Myrl-saki> ertesx: :: Ord a => [a] -> [a] -> Bool.
14:20:59 <Myrl-saki> ertes: if all elements of ys is an element of xs.
14:21:16 <Myrl-saki> The recursive case is
14:21:22 <ertes> Myrl-saki: O(max (length xs) (length ys))
14:21:33 <Myrl-saki> ertes: Yeah, that's what I was thinking too.
14:21:46 <Myrl-saki> ertes: And since we have n > m. It becomes O(n)?
14:22:02 <Myrl-saki> Or length xs > length ys.
14:22:11 <ertes> yeah, i don't see opportunities to stop early in general
14:22:41 <NickHu> Myrl-saki: Can you show me how to do it with mfix? I don't really know how
14:22:54 <ertes> Myrl-saki: you can drop to logarithmic, if you use Set
14:23:08 <Myrl-saki> NickHu: I'm not sure myself. Wait, I'll give it a try.
14:23:43 <Myrl-saki> :t fix
14:23:45 <lambdabot> (a -> a) -> a
14:23:47 <Myrl-saki> :t mfix
14:23:49 <lambdabot> MonadFix m => (a -> m a) -> m a
14:23:58 <ertes> hmm, scratch that
14:24:17 <ertes> if the lists are sorted, there is no advantage to using Set
14:24:38 <Myrl-saki> :t mappend
14:24:40 <lambdabot> Monoid a => a -> a -> a
14:25:07 <dubbelosix> so i'm just looking at the differences between cabal and cabal-install...when i do cabal init, it created the .cabal files and the setup.hs...now if i didnt want to do cabal install or cabal build (which if i understand correctly are from cabal-install), how would i create executables manually? i.e. without using cabal-install...and just plain old cabal
14:25:45 <Myrl-saki> :t \m -> mfix (\x -> mappend x <$> m)
14:25:47 <lambdabot> (Monoid b, MonadFix m) => m b -> m b
14:25:53 <ertes> dubbelosix: cabal is a library for distributing and combining haskell packages…  you don't use it directly
14:26:04 <Myrl-saki> NickHu: I have a feeling that will work?
14:26:08 <ertes> dubbelosix: cabal-install is one interface, and another is your Setup.lhs, if you have one
14:26:10 <Myrl-saki> I don't trust my feelings.
14:26:16 <hpc> cabal-install is the cabal command
14:26:17 <glguy> dubbelosix: you'd compile the a Setup.hs and use similar commands to cabal-install
14:26:18 <Myrl-saki> @pl \x -> mappend x <$> m
14:26:18 <lambdabot> (<$> m) . mappend
14:26:24 <Myrl-saki> Okay. That's ugly.
14:26:28 <hpc> Cabal is the base library for cabal-install and some other tools
14:26:32 <hpc> and there's no package named cabal
14:26:41 <hpc> it's not the most intuitive thing
14:27:04 <joncol> What does `f X {..} = ` mean on the left side of a function definition? 
14:27:22 <joncol> I've never seen the `{..}` syntax before.
14:27:29 <ertes> joncol: see -XRecordWildcards
14:27:39 <joncol> ertes: OK, thanks
14:27:49 <NickHu> Myrl-saki: Does that have the right type?
14:27:58 <ertes> joncol: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-wildcards
14:28:23 <joncol> ertes: Nice
14:28:41 <hpc> for a slightly more explicit variation on that syntax, take a look at record puns
14:28:56 <hpc> but it's a very rare thing to end up needing
14:28:57 <joncol> hpc: Yes NamedFieldPuns I'm familiar with
14:29:23 <ertes> joncol: {..} is basically a pun wildcard: "don't make me write those 20 fields, just pun all of them"
14:29:47 <joncol> Nice stuff! I think I've been missing something like that.
14:29:58 <Myrl-saki> NickHu: Ish.
14:30:06 <ertes> it goes with the constructor written before it:  "f X {..}" = "f (X {..})"
14:30:17 <Myrl-saki> NickHu: You'll want to work with...
14:30:46 <Myrl-saki> NickHu: Question. Can you change the type of the monad?
14:30:53 <Myrl-saki> NickHu: Change it to...
14:31:28 <Myrl-saki> NickHu: `:: IO (First (Maybe a))`
14:34:11 <ertes> :t fix (\again -> runMaybeT >=> maybe again pure)
14:34:12 <lambdabot> error:
14:34:13 <lambdabot>     Variable not in scope: runMaybeT :: a -> a -> Maybe c
14:34:13 <lambdabot> error:
14:34:24 <ertes> @let import Control.Monad.Trans.Maybe
14:34:26 <lambdabot>  Defined.
14:34:28 <ertes> :t fix (\again -> runMaybeT >=> maybe again pure)
14:34:30 <lambdabot> error:
14:34:30 <lambdabot>     • Occurs check: cannot construct the infinite type: c ~ m c
14:34:30 <lambdabot>       Expected type: m c
14:34:47 <ertes> :t \c -> fix (\again -> runMaybeT c >>= maybe again pure)
14:34:49 <lambdabot> Monad m => MaybeT m b -> m b
14:34:56 <ertes> NickHu: like that?
14:35:04 <ertes> Myrl-saki: you can't use mfix there
14:36:45 <NickHu> Nice!
14:37:16 <ertes> be careful with fix though, it can lead to mandelcode
14:37:27 <ertes> if in doubt, write it recursively
14:37:30 <joncol> Has anyone used repa? I'm trying to get it to work on Debian, but ran into compiler bugs with ghc-8.0.1. I'm now trying 7.10, but I have a hard time finding the correct llvm version (3.7) on Debian... (I can find 3.8, but not 3.7)...
14:37:37 <NickHu> What's mandelcode?
14:38:43 <Myrl-saki> ertes: Really?
14:40:28 <Myrl-saki> ertes: I got ` Exception: thread blocked indefinitely in an MVar operation` :C
14:40:29 <ertes> mandelcode = recursive spaghetti…  hacktals…  the big sister of foolia code
14:40:39 <Myrl-saki> ertes: This makes me sad. ;~;
14:41:19 <ertes> Myrl-saki: mfix is for *value* recursion…  you can't have recurring *actions*, just refer to values defined down the line
14:41:52 <ertes> mfix (\r -> action1 r >> action2)  -- r is the result of action2, and action1 can refer to it
14:42:07 <Myrl-saki> Oh.
14:42:23 <Myrl-saki> No wonder my gut feeling..
14:42:36 <ertes> like the famous thread that kills itself:  mfix (\tid -> forkIO (killThread tid))
14:43:01 <Gurkenglas> :t fmap (fromJustNote "desperately") . runMaybeT . asum . repeat :: Monad m => MaybeT m a -> m a
14:43:02 <Tuplanolla> I've had a good time with Repa, except for the time I found a new strictness analyzer bug, joncol.
14:43:03 <lambdabot> Monad m => MaybeT m a -> m a
14:43:17 <Myrl-saki> ertes: How would I do recurring actions?
14:43:28 <ertes> Myrl-saki: fix
14:43:34 <Myrl-saki> Ohhh
14:43:42 <Gurkenglas> Or https://hackage.haskell.org/package/pointedalternative-0.1.0.0/candidate/docs/Control-Alternative-Pointed.html#v:desperately :P
14:44:02 <ertes> main = fix (\again -> putStrLn "Hello world!" >> again)
14:44:18 <Tuplanolla> I used Repa 3.4.0.1 with GHC 7.10.2 and LLVM 3.4, joncol.
14:44:18 <ertes> sometimes 'fix' is nice for embedding recursive parts in larger code without having to name it explicitly
14:44:22 <dubbelosix> where do i specify dependencies in my cabal file? i'm trying to use the postgresql-simple library..where do i specify it so cabal downloads it before building my package
14:44:29 <Myrl-saki> ertes: Oh. I see what you did now, thought that' just a "direct translation" of recursion, isn't it?
14:44:40 <ertes> Myrl-saki: it is =)
14:45:07 <Gurkenglas> (Both at NickHu)
14:45:27 <Myrl-saki> ertes: I like that you didn't need to use First though.
14:45:33 <ertes> dubbelosix: generate a new project with 'cabal init', and let it comment the cabal file…  the comments explain every field, including the one you need: build-depends
14:46:02 <dubbelosix> oh nice..ty
14:46:52 <ertes> Myrl-saki: uhm…  i didn't even consider it…  where would you have used it?
14:47:41 <Myrl-saki> ertes: I was thinking of using the Monoid instance of First with mfix. I don
14:47:50 <Myrl-saki> I don't know if there's a way to do it with fix though.
14:47:55 <joncol> Tuplanolla: OK, thx
14:49:26 <ertes> Myrl-saki: i think i see what you were thinking, but mfix probably doesn't do what you thought it did
14:49:32 <Myrl-saki> 2:i liftM2
14:49:37 <Myrl-saki> :i liftM2
14:49:39 <Myrl-saki> ertes: Yeah.
14:49:59 <joncol> Tuplanolla: Any idea of what llvm binaries should be in my path? I made an ugly install from old Debian sid packages but ghc cannot find my llvm version.
14:50:04 <Myrl-saki> Here's to hoping that this one works.
14:50:12 <ertes> it's actually a rather boring function and i've only ever used it in the context of FRP =)
14:50:24 <Tuplanolla> The problem is usually the lack of `opt`, joncol.
14:50:40 <joncol> Tuplanolla: Hmm, I already ln -s:ed that.
14:50:51 <kuribas> :q
14:51:05 <kuribas> oops, sorry
14:51:22 <geekosaur> the "opt" one is usually from trying to use apple's incomplete llvm
14:51:24 * kuribas confusing ghci with irc...
14:51:34 <Myrl-saki> Oh.
14:51:52 <Myrl-saki> ertes: I have a proper version, but it doesn't work either.
14:52:20 <Myrl-saki> Hmmm
14:53:13 <joncol> geekosaur: But I'm not on a Mac now
14:53:24 <ertes> a proper version that doesn't work?
14:53:54 <Tuplanolla> I had an `opt` problem with Debian earlier, joncol and geekosaur.
14:54:26 <geekosaur> hm/ debian's more likely to just have split executables and libs into different packages
14:54:31 <ertes> you mean like that one time when we created the natural number between 4 and 5? =)
14:55:02 <geekosaur> so installing llvm could get you opt and lld but you'd also need libllvm-x.x-dev or something for the rest
14:55:20 <hpc> ertes: do i detect an scp reference?
14:55:24 <Tuplanolla> Indeed. What packages did you install, joncol?
14:55:36 <Myrl-saki> ertes: Got an actual one, but it's very ugly. xD
14:55:38 <ertes> hpc: what's scp?
14:57:34 <hpc> http://www.scp-wiki.net/
14:58:36 <Myrl-saki> ertes: http://ix.io/1CYr
14:58:43 <ertes> hpc: ah, that one…  if yes, then unintentionally =)
14:58:53 <geekosaur> (got an actual what? natural number between 4 and 5? >.> )
14:59:01 <Myrl-saki> ertes: Not a direct recursion translation. :D
14:59:33 <ertes> Myrl-saki: if you rewrite 'foo', you can write your 'dontFail' in a way that doesn't need fromJust
14:59:35 <joncol> Tuplanolla: I installed llvm-3.7, llvm-3.7-tools, llvm-3.7-runtime. But I'm trying 3.5 now
14:59:55 <ertes> foo :: (Monad m) => m (Maybe a) -> m a -> m a
14:59:55 <Myrl-saki> ertes: I was thinking of doing IO a.
15:00:02 <Tuplanolla> I need to take a nap now. I hope you get it working, joncol.
15:00:44 <joncol> Thanks Tuplanolla 
15:00:55 <Myrl-saki> ertes: Oh wow. It actually works.
15:01:02 <Myrl-saki> xD
15:01:17 <ertes> Myrl-saki: in fact you can then use that 'foo' in finite compositions by making it: infixr 1 `foo`
15:01:28 <ertes> action1 `foo` action2 `foo` action3 `foo` …
15:01:43 <geekosaur> oh fun. different naming convention for these, it seems... I see libllvm3.x (no hyphen or -dev) and llvm-3.x-dev (not lib!)
15:01:46 <Myrl-saki> ertes: You're right...
15:02:13 <ertes> Myrl-saki: with the new type the result will not be Maybe-wrapped, so no fromJust
15:02:16 <Myrl-saki> ertes: Omg. That's genius.
15:02:24 <Myrl-saki> ertes: Yeah, I get it now.
15:02:34 <Myrl-saki> ertes: Thanks. :o
15:02:55 <Myrl-saki> Oh wait...
15:03:27 <Myrl-saki> I'm pretty sure there's a function for `maybe f return`
15:03:57 <Myrl-saki> Oh wait. I'm wrong.
15:03:57 <ertes> Myrl-saki: yeah: traverse
15:03:59 <Myrl-saki> xD
15:04:01 <Myrl-saki> Oh
15:04:09 <Myrl-saki> :t traverse
15:04:12 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:04:20 <joncol> geekosaur: Tuplanolla: Niceness, llvm-3.5 works!
15:05:02 <ertes> Myrl-saki: wait, i'm stupid
15:05:09 <Myrl-saki> :t just
15:05:12 <lambdabot> error:
15:05:12 <lambdabot>     • Variable not in scope: just
15:05:12 <lambdabot>     • Perhaps you meant data constructor ‘Just’ (imported from Data.Maybe)
15:05:17 <Myrl-saki> Hmmm
15:05:23 <ertes> Myrl-saki: no, there is no such function…  there is only fromMaybe, but it doesn't fit
15:05:30 <Myrl-saki> :t fromMaybe
15:05:32 <lambdabot> a -> Maybe a -> a
15:05:35 <ertes> just use 'maybe', it's fine
15:06:29 <Myrl-saki> ertes: Thanks. This was a great exercise with `fix`. :D
15:07:56 <ertes> Myrl-saki: exercise: write a program that prints the numbers from 0 upward in terms of fix
15:08:35 <Myrl-saki> Seems easy.
15:08:49 <ertes> template:  main = fix (\… -> print … >> …) …
15:09:01 <ertes> (i.e. don't just cheat by traversing a list)
15:09:27 <Myrl-saki> main = fix (\x -> print x >> return (succ x)) 
15:09:30 <Myrl-saki> oh wait.
15:09:32 <Myrl-saki> I see now.
15:09:48 <Myrl-saki> How do I put in the 0, yeah.
15:10:01 <Myrl-saki> Mmmm
15:10:31 <ertes> it's not too easy, but solvable…  take your time =)
15:10:41 <Myrl-saki> Yeah.
15:12:59 <Myrl-saki> :t fix
15:13:02 <lambdabot> (a -> a) -> a
15:13:28 <Myrl-saki> :: ((a -> b) -> a -> b) -> a -> b
15:14:02 <Myrl-saki> Hah
15:14:26 <Myrl-saki> fix (\m x -> print x >> m (succ x)) 0
15:14:28 <Myrl-saki> :3
15:14:34 <ertes> Myrl-saki: well done =)
15:15:14 <Myrl-saki> ertes: Following the type of `fix` really helps things. xD
15:15:32 <Myrl-saki> ertes: Also, I think `foo` can be done using Alt(ernative)
15:24:54 <Gurkenglas> foo x y = runIdentity $ x <|!> IdentityT y, still using https://hackage.haskell.org/package/pointedalternative-0.1.0.0/candidate/docs/Control-Alternative-Pointed.html
15:25:04 <Gurkenglas> I wonder if there's a way to use those without all the wrapping
15:26:15 <Myrl-saki> Oh
15:27:02 <Myrl-saki> That.
15:27:03 <Myrl-saki> Is.
15:27:05 <Myrl-saki> Cool.
15:27:12 <hpc> :t lift
15:27:14 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
15:27:43 <Myrl-saki> @coerceToNonempty empty == _|_
15:27:43 <lambdabot> Unknown command, try @list
15:27:46 <Myrl-saki> What does @ mean?
15:27:54 <Welkin> it's a fancy hat
15:28:18 <hpc> it's that thing you use on twitter to do things
15:28:23 <Myrl-saki> {
15:28:26 <Myrl-saki> :c
15:28:32 <Myrl-saki> ;~;
15:28:33 <Gurkenglas> Supposed to be a link to that definition :/
15:29:06 <Myrl-saki> Anyways.
15:29:25 <Gurkenglas> @letlpaste 150858
15:29:29 <lambdabot>  Defined.
15:29:53 <hpc> wait what
15:30:18 <heebo``> hello im getting the following error when trying to profile my program with stack
15:30:39 <hpc> :t desperately
15:30:42 <lambdabot> PointedAlternative f g => f a -> g a
15:30:49 <hpc> !!
15:30:52 <heebo``> Failed to load interface for ‘Data.Vector’
15:30:52 <heebo``>     Perhaps you haven't installed the profiling libraries for package ‘vector-0.11.0.0’?
15:30:56 <Gurkenglas> > (`evalState` 3) $ manyLazy $ do i <- get; put (i+1); guard (i>2); return i
15:31:00 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
15:31:01 <hpc> i really need to remember that now
15:31:08 <heebo``> im not sure what im doing wrong
15:32:08 <hpc> you probably need to tell stack to build dependencies with profiling enabled
15:32:26 <Myrl-saki>  (Functor m, Monad m) => PointedAlternative (MaybeT m) (IdentityT * m)
15:32:28 <hpc> it'll be somewhere in stack.yaml probably
15:32:36 <Myrl-saki> Isn't (IdentityT * m) just m?
15:32:47 <Myrl-saki> or am i missing something
15:33:02 <heebo``> hmmm think i may have found the answer
15:33:10 <hpc> what's type-level (*)
15:33:11 <Gurkenglas> > fromJustNote "many" $ (`evalStateT` 3) $ many $ do i <- get; put (i+1); guard (i>2); return i -- too strict
15:33:15 <lambdabot>  *Exception: stack overflow
15:33:22 <ertes> Myrl-saki: it's isomorphic to m
15:33:39 <ertes> Myrl-saki: the type checker will not accept them as equal, but you can map between them without information loss
15:33:41 <Myrl-saki> ertes: Yeah. I'm more concerned as to why it was done like that.
15:34:13 <ertes> not familiar with that library
15:34:22 <exio4> hpc: in that case - I think it is just kind application 
15:34:31 <hpc> ah
15:35:08 <hpc> ill have to look at the semantics of that sometime
15:35:19 <hpc> it sounds like the next baby step towards DT
15:36:21 <Gurkenglas> Myrl-saki, just like StateT s m a is just s -> m (a, s)
15:36:58 <Gurkenglas> MaybeT corresponds to IdentityT like Maybe to Identity, and I need to wrap the m in IdentityT so my fundeps work
15:37:17 <Welkin> how can I access IO from inside a wai middleware without fucking everything up?
15:37:21 <ertes> please don't add dependent types to haskell…  i'll rewrite every single line of code…
15:37:23 <Gurkenglas> If you see a better way, I'm all ears ^^
15:38:02 <heebo``> anyone know how to get stack to add profiling to a projects dependencies?
15:38:05 <hpc> ertes: i think it'll work out well
15:38:18 <hpc> ertes: it definitely won't come out looking like agda, if that's your worry ;)
15:38:37 <Myrl-saki> Gurkenglas: Why do the fundeps not work without the IdentityT?
15:38:54 <Myrl-saki> Gurkenglas: I'm not really that familiar with Haskell's type(instance?) system.
15:38:54 <EvanR> ambiii
15:39:16 <hpc> ertes: have you tried idris? it's much closer to what a general-purpose DT language would look like
15:39:20 <ertes> Welkin: you're already in IO: Middleware = App -> App = (Request -> (Resp -> IO Recv) -> IO Recv) -> Request -> (Resp -> IO Recv) -> IO Recv
15:39:50 <EvanR> i think thats the issue, if it could look like agda, youd want to rewrite all lines of code ;)
15:40:21 <ertes> hpc: yeah, i know…  but DTs are DTs…  i'll use them
15:40:36 <hpc> oh, it's more of an "ooh shiny" kind of rewriting your code
15:40:40 <Lokathor> i don't even know what dependent types are
15:40:45 <Gurkenglas> Myrl-saki, making MaybeT m correspond to m means that many could produce any m from MaybeT m, so it could not deduce its argument type from its output type
15:40:45 <ertes> hpc: i've last tried idris a few months ago, and only briefly…  i do use agda regularly though
15:40:46 <Welkin> ertes: I'm still confused by it
15:40:47 <Lokathor> but people seem to feel very strongly about them a lot of the time
15:40:56 <ertes> hpc: (as a proof assistant, not a programming language)
15:40:56 <hpc> Lokathor: have you ever wanted to know the size of an array?
15:41:07 <Gurkenglas> Which means type signature annotations whenever mtl style is used in many's argument
15:41:43 <ertes> Lokathor: dependent types basically turn a language into a fully fledged logical calculus…  you can do arbitrary proofs about all of your code
15:41:44 <Lokathor> hpc, uhm, yes?
15:41:45 <hpc> Lokathor: you can write things like append :: SizedList a n -> SizedList a m -> SizedList a (n + m)
15:41:59 <Lokathor> yikes
15:42:10 <hpc> and much more, but that's the most digestable form of it
15:42:34 <EvanR> Lokathor: they kind of are the most amazing thing ever, in theory
15:42:38 <hpc> imo dependent types are going to be the next 20 years of features that get added to programming languages
15:42:46 <hpc> or they should be
15:43:02 <hpc> the amount of compile-time reasoning you can get out of them is unreal
15:43:02 <ertes> Welkin: myMiddleware app req k = … app (f req) (\resp -> … k (g resp) …) …
15:43:04 <exio4> dependent tzpes will be the functional programming of 2030 
15:43:05 <Lokathor> EvanR, but will they prevent things from crashing unknown reasons when an FFI signal comes in?
15:43:11 <EvanR> in practice its much more of a mix of "wtf" and "it should be working but isnt"
15:43:12 <ertes> Welkin: i've marked the parts where you can use IO…  it's just continuation passing style
15:44:21 <EvanR_> Lokathor: thats more of a function of how exceptions and signals works than type systems
15:44:29 <Lokathor> :(
15:44:34 <EvanR_> SIGPIPE etc
15:44:41 <ertes> Lokathor: you can express assumptions about your code and build theorems based on those assumptions…  if you assumed that some FFI code won't crash, and it crashes, your assumption is broken
15:44:45 <EvanR_> all you have to do is make that not a thing to solve that
15:44:45 <Welkin> ertes: I'm getting all kinds of type errors
15:44:49 <ertes> no amount of logic can help you out of that =)
15:44:54 <hpc> Lokathor: http://docs.idris-lang.org/en/latest/tutorial/index.html#tutorial-index - spend a month or two going through this tutorial and picking up theory
15:45:18 <EvanR_> ertes: thinking more 2130s
15:45:23 <ertes> Welkin: does Application make sense to you?
15:45:28 <Welkin> yes
15:45:35 <ertes> does Middleware?
15:45:37 <Welkin> I am using modifyResponseHeaders
15:45:42 <Welkin> er
15:45:42 <Lokathor> hpc but i don't think idris solves my problems either
15:45:59 <Welkin> mapResponseHeaders :: (Response -> Response) -> Middleware
15:46:17 <Welkin> er...
15:46:27 <Lokathor> i will bookmark this though
15:46:28 <Welkin> modifyResponse :: (Response -> Response) -> Middleware
15:46:38 <hpc> probably not, there's very little help you can get from the type system when doing FFI stuff, even on the best of days
15:46:43 <Welkin> mapResponseHeaders :: (ResponseHeaders -> ResponseHeaders) -> Response -> Response
15:46:46 <ertes> Welkin: where do you want the IO to happen?
15:47:04 <hpc> it has to interface with C and /that/ is a language with very few static guarantees
15:47:07 <ertes> Welkin: as part of the response modification?
15:47:09 <Welkin> do { <some IO here>; modifyResponse ... }
15:47:27 <Lokathor> i made a library that's 99% reliable at least :P
15:47:28 <Welkin> and the whole function needs to have type Application
15:47:55 <Lokathor> well, 100% reliable in a sense... it always works..  until you resize the screen, then it's guranteed to crash after the next key press
15:48:05 <hpc> did you write it in C?
15:48:16 <Lokathor> Haskell bindings over curses
15:48:18 <ertes> Welkin: well, the mapResponseHeaders function isn't sufficient for that…  you need:  mapRespIO :: (Response -> IO Response) -> Middleware
15:48:20 <hpc> oh yeesh
15:48:29 <Lokathor> i've tried about 3 ways to handle the SIGWINCH, none have helped
15:48:38 <Lokathor> mysteriosuly, it works if you run it through gdb
15:48:53 <hpc> hah
15:49:02 <Lokathor> some time i'll have my C friend go over a core dump of it, until then it's all a mystery
15:49:04 <hpc> yeah, you definitely have C problems
15:49:09 <hpc> or you have terminal problems, and gdb masks them by wrapping around the program
15:49:23 <Lokathor> could be terminal problems
15:49:40 <Welkin> I am using `do { a <- someIO ; modifyResponse $ mapResponseHeaders (f a) app }`
15:49:46 <Lokathor> what i know for sure is that nethack and crawl and vim all manage to resize the window without crashing
15:50:04 <Welkin> I am using `do { a <- someIO ; modifyResponse (mapResponseHeaders (f a)) app }`
15:51:11 <ertes> Welkin: \req k -> do …; app req (\resp -> k (f resp))
15:51:13 <Welkin> I get "expected IOResponseReceived, actual type Application"
15:51:50 <Koterpillar[99]> Welkin: when do you want this IO action to run?
15:51:56 <Koterpillar[99]> Welkin: just once when app starts?
15:52:11 <Welkin> before anything else in this function
15:52:32 <Gurkenglas> "Well, first I code this nethack, then I erase some of the more detailed features, and one, two, three - a window resize... thingy."
15:52:54 <ertes> Welkin: yeah, that's what that code does…  it runs "…" for each request, then hands control to the 'app', but modifies its response using 'f'
15:52:55 <Koterpillar[99]> Welkin: how many times during the lifetime of the server?
15:53:12 <ertes> Welkin: it runs for every request
15:54:59 <Welkin> Koterpillar[99]: every time it needs to build headers
15:55:13 <Welkin> ertes: thanks for the example, it gives me something to think about
15:55:23 <Welkin> maybe my function is just a little too complex and that is messing me up
15:56:56 <Welkin> ertes: although I am still not clear on it
15:57:09 <Welkin> it's definitely the middleware that is messing me up
15:57:20 <Welkin> where does modifyResponse fit in here
15:57:51 <ertes> Welkin: just remember: you don't *return* the result, you pass it to 'k'
15:57:53 <Welkin> it has to wrap the whole thing, right?
15:58:04 <ertes> read 'k' as 'send(Response)'
15:58:37 <ertes> but 'app' also wants a 'sendResponse', because it too does not *return* its response
15:58:57 <Welkin> oh, I need to use the result of the IO inside the first parameter to modifyResponse though
15:59:45 <grantwu> How do I construct a singleton nonempty list?
15:59:49 <ertes> \req send -> do myIO; app req {- the following is our version of 'send' that we give 'app' -} (\resp -> send (f resp))
16:00:10 <ertes> Welkin: any modification to the response before sending it belongs into 'f'
16:00:47 <ertes> either purely:  (\resp -> send (f resp))  -- i'm sure right now someone is terribly itching to rewrite this
16:01:05 <ertes> or effectfully:  (\resp -> f resp >>= send)  -- and yes, this can be rewritten, too
16:01:29 <ertes> in either case 'f' is the response modification
16:02:21 <ertes> Welkin: if you take 'f' and 'app' as arguments, this is actually a middleware
16:02:29 <ertes> \f app req send -> …
16:02:38 <JonReed> Does anybody know how to get where a declaration ends when using haskell-src-exts? It seems that `parseFile` returns data which contains Module, which contains a list of [Decl] but each Decl only has SrcLoc, which only tells where declaration started and not where it ends. A function could be one line or it could span the rest of the file, and you 
16:02:38 <JonReed> never know.
16:02:39 <heebo``> grantwu: [v] where is the singleton value
16:02:54 <heebo``> where v is the singleton value
16:03:38 <geekosaur> I think they want Data.List.NonEmpty
16:03:41 <JonReed> What is worse, you can't even feed the declaration to parseDecl, because it throws when in sees multiple declarations.
16:03:44 <geekosaur> (ghc8.0.1)
16:04:49 <heebo``> geekosaur: that wasnt apparent
16:04:53 <grantwu> geekosaur: yeah
16:05:16 <grantwu> https://hackage.haskell.org/package/semigroups-0.18.1/docs/src/Data.List.NonEmpty.html#NonEmpty seems to indicate it should be [v] as well... but that doesn't make sense
16:05:36 <geekosaur> well, a singleton list is by definition non-empty, so "nonemoty" must have meant D.L.NonEmpty (which is in base in 8.0.1)
16:05:55 <grantwu> Am I supposed to do v :| []?
16:06:14 <lyxia> JonReed: I see it uses SrcSpan
16:06:45 <grantwu> Oh, hrm.  that does work.  That's cute
16:07:15 <grantwu> Ah, so the definition of a nonempty list is just something cons'd onto a regular list
16:07:16 <lyxia> JonReed: the latest version does
16:07:19 <geekosaur> pure a = a :| []
16:07:21 <geekosaur> looks like it
16:07:42 <grantwu> That's prety cute, I can convert a regular list of any length into a nonempty list by consing something onto it
16:08:01 <volhovm> Hey guys
16:08:02 <JonReed> lyxia: Hm, let me check what version I use. So far I've been stuck on this: http://lpaste.net/329824
16:08:13 <JonReed> where it has SrcLoc
16:08:14 <volhovm> anyone experiencing problems building cairo w/ gtk2hs-buildtools on nixos?
16:10:27 <lyxia> JonReed: Can you upgrade to >=1.18
16:11:31 <lyxia> I'm not sure what you can do otherwise... traverse the declaration to find the farthest location?
16:11:31 <heebo``> ls
16:11:32 <Welkin> ertes: I'm still lost
16:12:19 <JonReed> lyxia: Yeah. I just checked that I'm on 1.17. I'll try the latest.
16:13:15 <Welkin> http://lpaste.net/3892356073830481920
16:14:18 <Welkin> can anyone take a look?
16:14:35 <Welkin> I'd like to get this working so I can move on
16:15:20 <Welkin> too damn tired
16:15:52 <grantwu> I suggest sleep
16:17:01 <Welkin> it's 4 lines of code
16:18:02 <hpc> have you tried turning it off and on again?
16:24:07 * hackagebot rating-systems 0.1 - Implementations of several rating systems: Elo, Glicko, etc  https://hackage.haskell.org/package/rating-systems-0.1 (DougBeardsley)
16:24:09 * hackagebot egison 3.6.1 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.6.1 (SatoshiEgi)
16:26:09 <soLucien> is there anything that will apply a parsec parser a single time ?
16:27:59 <Rotaerk> soLucien, the parser itself?
16:28:15 <Rotaerk> as in, on its own, it will be applied once
16:30:40 <soLucien> yes i realized
16:31:00 <soLucien> i was trying to return a parser instead of doing var <- parser ; return var
16:31:08 <soLucien> rookie mistake
16:32:49 <grantwu> Huh, is that not equivalent to parser
16:34:38 <geekosaur> if they did `return parser` instead of `parser`...
16:37:39 <yulax> hi, i am wondering how i can unload a module from ghci
16:38:06 <yulax> i wrote a small function to replace div with /, but there is a clash when i load it in ghci
16:38:49 <yulax> and i can't use it in my program since the interpreter chokes when it finds it
16:38:50 <hpc> try :r
16:39:02 <hpc> what do you mean, function to replace div with /?
16:40:41 <yulax> i write this function :
16:40:51 <yulax> (/) :: a -> a -> a
16:40:54 <yulax> (/) p q = p `div` q
16:41:00 <yulax> it is so i can type quicker
16:41:07 <yulax> i thought this would be easy.
16:41:39 <hpc> oh, that won't typecheck even a little bit
16:41:51 <yulax> why is that?
16:42:21 <Koterpillar[99]> yulax: because you say this is possible: "why" / "that" 
16:42:31 <hpc> (/) is already defined elsewhere, and div's type means it can't be used on the arguments it is given
16:42:54 <hpc> or (/)'s type means it can't feed those arguments to div, pick your poison
16:52:08 <Axman6> yulax: (/) is already defined in the Prelude and is used for fractional division (div is used for integer division)
16:52:11 <Axman6> :t (/)
16:52:13 <lambdabot> Fractional a => a -> a -> a
16:58:40 <yulax> ok
16:58:45 <yulax> makes sense
16:58:48 <yulax> thanks folks
17:00:18 <alasi> I feel kinda stupid right now... converting to binary is easy but what if I just wanted the binary factors recursively? i,e instead of [1, 0, 1] [4, 0, 1]
17:01:49 <fabianhjr> Hello, quick question. As far as I understand typeclasses/typevariables:
17:01:49 <fabianhjr> https://gist.github.com/fabianhjr/47cfd0bd58afd1d3240cc41986fe0dd5
17:01:49 <fabianhjr> this should work, but it doesn't.
17:01:49 <fabianhjr> (Even if it was just example :: a it would complain)
17:02:52 <geekosaur> fabianhjr, you misunderstand something critical
17:03:06 <geekosaur> the "a" in example is set by *the caller*
17:03:30 <geekosaur> think of it as a contract: "for any type a that has an Eq instance, I promise to produce a value of that type"
17:04:13 <geekosaur> if you then produce an Int, you have violated your contract with the caller
17:05:24 <fabianhjr> Ok, because if they "call" the 0-ary function example I wouldn't return the same type with which it was called? (Sort of like [] :: [Int] not being the same as [] :: [Char]?)
17:05:56 <geekosaur> the context the caller uses it in determines the type "a".
17:06:07 <geekosaur> (yes, haskell can do return type polymorphism)
17:06:46 <geekosaur> with the signature `example :: Eq a => a` I am permitted to use (example :: Char) or (example :: Double) or even (example :: Ordering)
17:06:59 <geekosaur> because all of those have Eq instances
17:07:36 <grazie> anyone use a Mac here, know where I'd find source code that comes with install of Haskell? or for libraries such as Text.ParserCombinators.ReadP
17:07:44 <geekosaur> therefore example must be able to produce a value in all of those cases. (which it cannot. the only "value" in common with those is bottom)
17:08:48 <Welkin> god damn it
17:09:00 <Welkin> it swas that stupid `modifyResponse` function that was fucking me up
17:09:20 <Welkin> I copied the source for it and made one change
17:09:21 <Welkin> and now it works
17:10:06 <geekosaur> grazie, cabal get base-4.9.0.0
17:10:24 <geekosaur> or for ghc 7.10.3 you may prefer base-4.8.2.0
17:11:06 <grazie> geekosaur so what will that do? download all the code that's installed with native Haskell install? is that the only way I can read source for packages on my computer?
17:11:38 <geekosaur> that gets you the source for the base package, which is most but not all of the libraries that come with ghc
17:11:52 <geekosaur> you can also look things up on hoogle or hayoo and follow the source links
17:12:12 <geekosaur> @where hayoo
17:12:12 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
17:13:03 <geekosaur> or look up packages at http://hackage.haskell.org/packages and optionally download source
17:14:13 * hackagebot htoml 1.0.0.2 - Parser for TOML files  https://hackage.haskell.org/package/htoml-1.0.0.2 (cies)
17:14:34 <grazie> geekosaur: I did this:    hoogle "<|>"   but it's not that helpful becuase it doesn't tell me what the func does. for example, 
17:14:35 <grazie> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
17:15:48 <geekosaur> that's Parsec's version. the one used by ReadP (which you asked about originally) is actually defined in Control.Applicative. and it's rather generically described because Alternative is a rather generic typeclass
17:15:51 <grazie> oh, hayoo is nice, provides more info
17:16:45 <grazie> geekosaur: well, that's another problem, I saw that function here (in the first code sample) but wasn't sure if it was from the imported library or in standard library http://book.realworldhaskell.org/read/using-parsec.html
17:16:59 <geekosaur> in fact it's one of the more poorly documented things if you are not familiar with it. "A monoid on applicative functors"
17:17:29 <geekosaur> now you get to look up what monoid and applicative functor are (at least for that second one you just go to the top of the page...)
17:17:55 <geekosaur> where I started at http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative which is what defines <|>
17:18:12 <geekosaur> (the Parsec one is the same thing, but Parsec predates Applicative and Alternative so it defines its own)
17:18:32 <grazie> geekosaur i know generally what applicative functor's are (at least I've read a couple haskell books) but I'm still lost reading source code
17:18:34 <geekosaur> (with its typical documentation which assumes you read the original Parsec paper)
17:19:13 * hackagebot htoml 1.0.0.3 - Parser for TOML files  https://hackage.haskell.org/package/htoml-1.0.0.3 (cies)
17:19:28 <grazie> I'm using ghc version 8.0.1, so I'll do cabal get base-4.9.0.0? 
17:19:45 <geekosaur> yes
17:19:58 <geekosaur> whch will give you a directory base-4.9.0.0 with the source to the base package in it
17:20:02 <grazie> geekosaur did you install hayoo on your own computer or just use it online?
17:20:09 <geekosaur> I just use it online
17:20:47 <grazie> geekosaur, so do you read the downloaded source in your .cabal folder in home dir?
17:20:48 <geekosaur> hoogle is nbetter suited for local installs; hayoo is a full search engine framework, a bit like installing google on your own machine >.>
17:21:07 <geekosaur> it creates that directory in whatever directory you are in
17:21:10 <geekosaur> it's not like install
17:21:45 <grazie> oh, i see, good to know, thank you
17:22:06 <geekosaur> I'd normally stick it in ~/Sources/hs/ because that's how I organize things
17:23:43 <grazie> hayoo is nice because it actually describes in words what the function does
17:26:03 <geekosaur> only to the extent that the original haddocks do. there's a lot of haddocks out there that assume you already know the details, sigh
17:28:53 <grantwu> If there's a bit I need in a State-ful computation, is it bad practice to just stick it in the state
17:28:56 <grantwu> Even if I never mutate it
17:29:07 <grantwu> er, a bit of info*
17:29:30 <soLucien> hello guys ! I want to disambiguate a data that looks like this : data Taste
17:29:31 <soLucien>  = Taste [Sweet] [Sour] [Sour]
17:29:48 <soLucien> i want to return Taste into a monadic context . as in Parser Taste
17:31:03 <soLucien> i parse the arrays , sweets <- parseSweets , sourFoods <- parseFoods , sourFruits <- parseFruits
17:31:06 <soLucien> so far so good
17:31:39 <Koterpillar[99]> return $ Taste sweets sourFoods sourFruits
17:31:50 <soLucien> then i try do do this : return $ Taste (sweets sourFoods  sourFruits )
17:32:00 <Koterpillar[99]> why the brackets?
17:32:04 <glguy> No, don't apply sweets to sourFoods, it's not a function
17:32:52 <soLucien> ok i see . i removed the parentheses and it started working again
17:32:55 <soLucien> great , thanks !
17:34:13 * hackagebot flat-mcmc 1.2.1 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.2.1 (JaredTobin)
17:36:44 <jle`> grantwu: usually it's better to just write it in a natural way
17:36:49 <geekosaur> the left paren would have gone before "Taste" (which is what the $ is doing by precedence)
17:36:51 <jle`> and then "lift" it to 'State' when you use it in state
17:37:04 <grantwu> jle`: What do you mean?
17:37:06 <jle`> grantwu: for example, say you have a complicated function to update a counter
17:37:15 <jle`> instead of making it updateCounter :: State Counter ()
17:37:20 <jle`> you can just write updateCounter :: Counter -> Counter
17:37:29 <jle`> and use it with modify :: (s -> s) -> State s ()
17:37:36 <jle`> whenever you watn to use it in a state context
17:37:42 <jle`> sort of like using 'fmap'
17:37:52 <grantwu> That's useful, but not really waht I was asking
17:38:02 <jle`> can you explain more about what you want?
17:38:26 <jle`> or maybe you have a complicated non-stateful function, (a -> b) -- instead of writing an `State s a -> State s b`, just write the (a -> b) and use 'fmap'
17:38:35 <grantwu> *what.  Basically, I have a value I need to use throughout a complicated computation that's already in State.
17:39:04 <grantwu> Would it be nonidimatic to just stick it in the state and get it when I need it
17:39:04 <jle`> ah, you have a 'read only' portion of your state type?
17:39:09 <grantwu> yeah
17:39:29 <grantwu> I could of course just thread it as a parameter to all of the various functions I use in my computation
17:39:31 <jle`> might make more sense to just use it as a parameter to your functions
17:39:46 <jle`> or, you can use something like RWST/StateT s (Reader r)/ReaderT r (State s)
17:40:02 <jle`> but using it as a parameter is probably the simplest way.  there is a trade-off
17:40:27 <jle`> if it's only a couple of functions deep then passing a parameter isn't too bad; if it's several and pervasive, you can consider maybe using a State-with-Reader type
17:43:28 <grantwu> Forgive me, for I am going to sin and just stick it in the state
17:43:50 <Lokathor> 10 Hail Adas
17:44:01 <jle`> grantwu: you could also just write it polymorphically over MOnadState/MOnadReader
17:44:07 <jle`> so you don't have to worry/care
17:44:34 <grantwu> Uh... sorry, I don't really know what you mean
17:44:39 <jle`> just use (MonadState s m) => ... when you only want the State, (MonadReader r m) => ... when you only want the environment
17:44:46 <grantwu> oh
17:44:49 <jle`> and if you watn to do both, (MonadState s m, MonadReader r m) => ...
17:44:58 <jle`> that way your state part doesn't have to worry about your reader part and vice versa
17:45:30 <grantwu> I never quite understood what MonadState was for
17:45:43 <jle`> it's to write polymorphically over monads that have an 's' state
17:45:53 <jle`> when you don't want to care about any other properties it might have
17:46:29 <jle`> sort of like writing functions (Ord a) => ..., you write polymoprhically over types that are comparable
17:46:37 <jle`> and you want to explicitly say that you are ignoring any other properties about that type
17:47:43 <jle`> an `(Ord a) => a -> a -> a` can do a lot less than, say, a `String -> String -> String`
17:48:11 <jle`> the first might be 'const' or 'flip const' or 'max' or 'min'
17:48:16 <jle`> but the second can be \_ _ -> "hello"
17:48:33 <jle`> and an Int -> Int -> Int might be (+)
17:48:56 <jle`> but if you write an (Ord a) => a -> a -> a, you're saying that the only thing you're going to "do" to inputs is compare them, or do nothing at all
17:49:14 * hackagebot flat-mcmc 1.2.2 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.2.2 (JaredTobin)
17:49:16 <ertes> grantwu: classes like MonadState are often called *effect classes*, because they allow you to assume that certain effects are available with no further assumptions (other than the usual monad laws)
18:28:32 <clmg> Any clue why I have to (drop 3 primes) to get the right answer here? http://lpaste.net/329841
18:28:54 <clmg> If I use the whole set of primes, I get an answer exactly 10 too great each time.
18:29:18 <clmg> But if I drop 3 primes, I get the right answer no matter what `limit` is
18:31:08 <jaziz> MX Blues or MX Browns?
18:31:57 <bsmt> is it strictly limited to those two?
18:32:09 <jaziz> I *think* so
18:32:18 <jaziz> I haven't considered the other ones
18:32:23 <jle`> clmg: what's the difference in the answers?
18:32:24 <jle`> oh, 10
18:32:34 <bsmt> I mean, obviously it's best to try them out, but I prefer brown
18:32:44 <bsmt> I really like clears too
18:32:47 <jaziz> For everyday coding and stuff?
18:32:51 <jaziz> What're clears like?
18:32:54 <jle`> clmg: can you document what consecutivePrimeSum, zs, and ps aer supposed to be
18:32:59 <bsmt> just a little "stiffer" than brown
18:33:06 <jaziz> mmmmm
18:33:10 <jle`> it's probably literally impossible to answer otherwise
18:33:11 <jaziz> but otherwise the same?
18:33:13 <bsmt> kind of uncommon though
18:33:23 <clmg> jle`: jle` here: http://www.mathblog.dk/project-euler-50-sum-consecutive-primes/
18:33:44 <jle`> without any other information i could just say something like "just subtract 10"
18:34:34 <clmg> jle`: ps is his first for loop, zs is his second for loop, with x being the outer and y being the inner.
18:35:21 <clmg> jle`: yeah. I basically just tried to implement his algorithm, but it's always off by 10!
18:40:26 <buglebudabey> could someone help me fix my code so that "m" is proper converted to an integer? http://lpaste.net/329842
18:43:35 <clmg> buglebudabey: you need to (round m) on line 5 to convert the float back to an int
18:44:39 <clmg> buglebudabey: you can't have a non-integer-length list, basically
18:44:50 <buglebudabey> yup, mankes sense - thanks clmg 
18:49:32 <clmg> jle`: I found out you can also fix it by taking (ps!!(x+3)) and (pss!!(y+3)). So it has to do with the indices generated by scanl
19:00:08 <Morton> hello bois 
19:00:20 <clmg> hi :3
19:00:25 <hodapp> O HAI!
19:02:05 <NaOH> I tried hoogling to no avail: is there something among the lines of f (a -> f b) -> a -> f b ? More concrete, I have a Maybe (Double -> Maybe Point) and I want to apply the inner function to a Double if it's a Just, or return Nothing
19:04:12 <Koterpillar[99]> @pl \f x -> f >>= \g -> g x
19:04:12 <lambdabot> (. flip id) . (>>=)
19:07:26 <hodapp> :t (fromMaybe $ const Nothing)
19:07:28 <lambdabot> Maybe (b -> Maybe a) -> b -> Maybe a
19:07:48 <hodapp> NaOH: does that get you your specific case?
19:09:24 <jle`> NaOH: sounds just like fmap ($)
19:09:51 <jle`> oh, maybe bind
19:10:06 <hodapp> :t bind
19:10:09 <lambdabot> error:
19:10:09 <lambdabot>     • Variable not in scope: bind
19:10:09 <lambdabot>     • Perhaps you meant one of these:
19:10:19 <Koterpillar[99]> all those are defined for Monad but this one requires at least MonadPlus
19:10:46 <jle`> :t \f x -> ($ x) =<< f
19:10:49 <lambdabot> Monad m => m (a -> m b) -> a -> m b
19:11:12 <Koterpillar[99]> ...I was wrong
19:11:20 <jle`> :t \f x -> func <- f; func x
19:11:22 <lambdabot> error:
19:11:22 <lambdabot>     Parse error in pattern: \ f x -> func
19:11:22 <lambdabot>     Possibly caused by a missing 'do'?
19:11:28 <jle`> :t \f x -> do func <- f; func x
19:11:30 <lambdabot> Monad m => m (t -> m b) -> t -> m b
19:12:50 <NaOH> Thanks for all the answers, I'm trying to understand them, but I think I'm most likely overcomplicating things here...
19:18:04 <NaOH> jle`: thanks, you inspired me to use do notation, which greatly simplified the issue
19:30:02 <EvanR> so, storable Vector Word8, ByteString
19:30:47 <EvanR> is there a list of pros and cons
19:31:21 <EvanR> ill also accept an apology of somesort for why they both exist
19:34:11 <EvanR> is it still standard procedure to do some sort of hack to convert between them
19:50:22 <EvanR> bytestring has IO, storable vector doesnt
19:51:35 <seafood> Hi all, I’m wondering if you can help me out with a little problem here. I’m using an API to retrieve a JSON object. What I want to do is add an extra field to the JSON object to record the time at which I made the API call. My problem is that, in a way, this is a new type. It seems I have to write 2 ToJSON and 2 FromJSON instances, one for the type from API and one for type with the timestamp. Is there a better way? 
19:52:25 <Koterpillar[99]> seafood: data AtTheTime a = AtTheTime { when :: UTCTime, what :: a }
19:52:46 <seafood> Yes, I thought of that. I’m not sure that will interact well with Persistent which I hope to use as well.
19:53:27 <Koterpillar[99]> there are extensible record libraries
19:53:48 <seafood> But do they play well with persistent?
19:54:00 <Koterpillar[99]> don't think so
19:54:31 <Koterpillar[99]> and finally, in any case, the instance for the dated type can piggyback on the instance for the simple one
19:55:13 <seafood> Yes, it could and that would be nice!
20:00:18 <glguy> seafood: you could have a single type with a field Maybe UTCTime, it would be a Nothing when received and you could set it
20:08:21 <seafood> glguy: That’s an okay idea.
20:15:16 <EvanR> ad hoc fields is simultaneously a huge source of bugs and surprisingly cheap way to some random feature delivered
20:18:48 <hodapp> ad hoc fields?
20:32:07 <_cyril_> Hi #haskell, I'm trying to work on https://github.com/jaspervdj/hakyll/issues/479 since it's labeled as "beginner". My first step is to change this https://github.com/jaspervdj/hakyll/blob/master/src/Hakyll/Check.hs#L136 into some form of asynchronous call. I want to use forkIO, but it has type IO () -> IO ThreadId. I would like Checker () -> IO (), I think.
20:33:35 <_cyril_> I'm stuck on trying to combine forkIO and checkUrl, basically. Would anyone have tips? Not the solution, but directions I should explore?
20:35:13 <Koterpillar[99]> _cyril_: where's the definition of Checker?
20:35:25 <geekosaur> several lines up in the same file
20:35:43 <_cyril_> Koterpillar[99]: It's just above, line 92
20:35:44 <Koterpillar[99]> ah
20:35:50 * geekosaur wonders if runChecker is threadsafe enough
20:35:58 <geekosaur> but that won't integrate well anyway
20:36:27 <geekosaur> hm, or maybe it will
20:36:42 <Koterpillar[99]> _cyril_: each checker modifies the CheckerState, so they can't be (trivially) run asynchronously
20:37:15 <_cyril_> Koterpillar[99]: That's one thing I wasn't sure about actually, thanks for clarifying that
20:37:38 <Koterpillar[99]> _cyril_: maybe the only way CheckerState is modified is with new elements added, then it's simpler
20:37:40 <_cyril_> Since the issue is labeled as "beginner", I thought it would be trivial :)
20:38:57 <_cyril_> More generally though, how would I go about giving forkIO something else that is not exactly IO (), but something that "has it" such as Checker?
20:39:32 <Koterpillar[99]> give it a runChecker
20:39:54 <_cyril_> Because that's what RWST ... IO a means right? A combination of RWS monad and IO monad?
20:40:03 <Koterpillar[99]> yes
20:40:15 <Koterpillar[99]> but forkIO starts an IO action
20:40:37 <Koterpillar[99]> if you have a Checker, you don't have an IO action; you must provide configuration, logger and state to it
20:42:02 <_cyril_> Hmm, so my problem is that if I start doing checks concurrently I would have to merge the output of each individual check to get the overall result
20:42:20 <Koterpillar[99]> yes
20:42:31 <Koterpillar[99]> look at runChecker though
20:42:50 <_cyril_> Koterpillar[99]: I'm going to go do that now, thanks!
20:42:57 <Koterpillar[99]> it seems that it's easier to do so than in a generic RWST case
20:43:22 <Koterpillar[99]> maybe just change Checker to a Free something ;)
20:54:10 <_cyril_> Koterpillar[99]: By a "Free something", do you mean making Checker an instance of a certain type class?
20:55:28 <Koterpillar[99]> :i FreeT
20:55:37 <Koterpillar[99]> :t FreeT
20:55:39 <lambdabot> error: Data constructor not in scope: FreeT
20:55:52 <Koterpillar[99]> http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html#t:FreeT
20:55:54 <Koterpillar[99]> that
20:56:02 <_cyril_> Thanks
20:57:01 <Koterpillar[99]> that probably takes it out of beginner, but it didn't look much like one to start with
21:29:12 <jchia1> Is there a quick way to find out whether a set of modules have any conflicting names among themselves and what they are? E.g. Data.ByteString.readFile and Data.Text.IO.readFile.
21:38:30 <Cale> jchia1: hm, I don't know a *quick* way... but you could use hint (https://hackage.haskell.org/package/hint-0.6.0) to load the modules and get the lists of things exported from them
21:38:53 <Cale> (and then turn those into Data.Sets and take their intersection)
21:39:57 <Cale> jchia1: Mostly it's not all that necessary to worry about it, because GHC will let you know when there's a problem with ambiguity.
21:40:12 <Cale> (and you can just adjust your imports then)
21:41:42 <jchia1> Cale: Thanks. I'm trying to avoid intermittently having to add new imports when writing new code and the approach I'm considering is to import the things I commonly use minus the conflicts.
21:42:07 <jchia1> then when i'm done, i trim the imports
21:43:15 <Cale> Well, with respect to Text and ByteString, what most people do is to import those ones qualified, and then secondarily import a few things from them unqualified (usually just the type itself)
21:43:21 <Cale> e.g.
21:43:27 <Cale> import qualified Data.Text as T
21:43:32 <Cale> import Data.Text (Text)
21:43:48 <Cale> Otherwise, they just overlap with everything horribly.
21:43:59 <jchia1> Cale: There are other modules that I'm considering, like Data.Either.Combinators and Control.Monad.Loops.
21:44:10 <Cale> It's mostly Text, ByteString, Map and Set that get used like that
21:44:28 <Axman6> I added a snippet to the SublimeText Haskell package that would do that for you (impq<tab>)
21:44:55 <Cale> hehe, the first thing I did when I installed SublimeText was delete all the snippets
21:45:32 <Axman6> well, that one was handy >_>
21:45:33 <Cale> (Might've been overkill, but they were really annoying)
21:45:48 <Cale> Or at least, some of them were
21:46:28 <Cale> Probably that one wouldn't have bothered me since I'm unlikely to type that by accident
21:46:45 <Axman6> yeah some of them were really annoying
21:58:32 <seafood> What do people use for BigDecimals in Haskell these days?
21:59:10 <seafood> Something that is compatible with Persistent would be great
22:02:57 <c_wraith> seafood: do you have a use Rational doesn't work for?
22:04:11 <c_wraith> There are definitely uses rational doesn't work for.  But when it does work, might as well keep things simple.
22:08:10 <dmwit> What's a BigDecimal?
22:09:10 <c_wraith> it's a vague term for any unbounded non-integral type
22:09:55 <c_wraith> Sometimes Rational suffices.  Sometimes you want more performance or operations Rational doesn't provide.
22:10:30 <dmwit> We have some nice libraries for fixed-point numbers, too, which are another good choice for some things.
22:12:53 <c_wraith> Oh, there is the scientific package.  Maybe that's what seafood is really after.
22:13:20 <seafood> I’m really looking to use it for financial applications.
22:13:29 <seafood> And I have a fixed number of decimal places I want to use it for.
22:13:35 <seafood> I think Data.Decimal might be what I’m looking for.
22:16:03 <dmj`> seafood: that, or represent your decimals as whole numbers. 
22:16:40 <lpaste> jvanbure pasted “Type synonym argument restriction” at http://lpaste.net/329924
22:17:07 <jvanbure> Why is it that the above^ example behaves as it does?
22:17:19 <c_wraith> jvanbure: type synonyms must have all arguments applied to them
22:17:33 <jle`> you cannot partially apply type synonyms in haskell
22:17:35 <jvanbure> c_wraith: but what's the reasoning behind it?
22:17:55 <grantwu> Makes unification hard I think
22:18:20 <grantwu> It makes TypeSynonymInstances work, at least that's what the web
22:18:26 <grantwu> *page on it says
22:18:45 <jle`> typesynonyminstances already works
22:18:47 <c_wraith> I'm not sure if this is why, but...  Type families make no sense whatsoever if you can partially apply them.
22:18:57 <jle`> just not with partially applied type synonyms
22:19:18 <c_wraith> and type  families are just special type synonyms
22:22:54 <jvanbure> mmkay, thanks!
22:24:07 <dmj`> jle`: o/
22:24:17 <jle`>  \o
22:32:56 <grantwu> Can someone explain the relationship between traverse and mapM?
22:33:14 <grantwu> I read http://stackoverflow.com/questions/7460809/can-someone-explain-the-traverse-function-in-haskell but I don't quite understand when their behavior can differ.
22:34:12 <johnw> they should be the same nowadays
22:34:13 <grantwu> Why does traverse prevent you from doing the thing where the effects could depend on the previous results?
22:34:19 <johnw> it's just a difference in typeclass requirement
22:34:29 <johnw> because traverse only uses Applicative
22:34:44 <johnw> anywhere you can use mapM, you can use traverse; but not vice versa
22:34:52 <johnw> (so, they are not "the same nowadays" as I mistakenly said above)
22:36:22 <grantwu> I should read up on Applicative, blegh
22:36:46 <johnw> do you know what it means by "effects can depend on previous results"?
22:36:55 <grantwu> I think so
22:37:00 <johnw> with Monad, you can do this: x <- foo; if x then bar else baz
22:37:03 <jle`> grantwu: their behavior is the same when using for a specific type
22:37:43 <grantwu> Hrm, so looking at the definition of Applicative - it just seems like <*> doesn't give you access to the previous result?
22:38:13 <jle`> if you have a specific instance in mind, then using traverse and mapM won't make a difference
22:39:23 * hackagebot monad-logger 0.3.20.1 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.20.1 (MichaelSnoyman)
22:41:59 <dmj`> traverse is cool
22:42:23 <dmj`> great when used on 'run-*' or 'un-*' records in newtypes
22:42:28 <dmj`> :t traverse runIdentity (undefined :: [Identity (IO Int)])
22:42:30 <lambdabot> IO [Int]
22:49:23 * hackagebot resourcet 1.1.8.1 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.8.1 (MichaelSnoyman)
23:21:26 <jmorris> How could I make this so that is continues if the user inputs yes but cancels if the user inputs no? http://lpaste.net/329951
23:22:31 <Axman6> what do you mean by "cancels"?
23:23:41 <Shou> Is there an infixl ($)?
23:24:27 <lyxia> whitespace
23:24:30 <jmorris> Cancels just ends the program without doing anything, when it continues i want to prompt for a file name to create
23:25:11 <jle`> jmorris: you can use an if/then/else
23:25:18 <jle`> or 'when' if you want nothing to happen
23:26:29 <liste> > do { r <- getLine; when (r == "y") (putStrLn "hi") }
23:26:32 <lambdabot>  <IO ()>
23:28:45 <jle`> continueOn :: IO (), and then you have `when (r == "y") continueOn`
23:30:38 <Shou> lyxia, it doesn't really exist in any popular libraries?
23:36:05 <jmorris> ok thanks jle`
23:37:42 <jle`> no problem!
23:45:37 <grantwu> Shou: Not really sure what the use case for infixl $ would be
23:45:43 <grantwu> It would make having multiple be weird
23:46:10 <grantwu> Perhaps you might want something like F#'s |>, which is & from Data.Function?
23:46:11 <Axman6> there's a proposal to change it, it lets yoy write things like foo $ x $ y $ z
23:46:20 <Axman6> where foo a -> b -> c -> d
23:46:22 <grantwu> see http://stackoverflow.com/questions/1457140/haskell-composition-vs-fs-pipe-forward-operator
23:46:23 <Axman6> ::*
23:46:48 <Shou> grantwu, it'd be something similar to Applicative's <*> that allows you to remove parentheses from arguments to a function e.g. "(:) -*- head as -*- tail as"
23:46:53 <grantwu> Surely that breaks a bunch of other use cases o.O
23:46:59 <Shou> Where -*- is infixl ($)
23:48:20 <saurabhnanda> okay, how inappropriate would it be to comment on this again: https://mail.haskell.org/pipermail/haskell-community/2015-September/000027.html (the Haskell.org Downloads page fiasco)
23:49:07 <zyla> Hi, I just got this error message when experimenting: http://lpaste.net/329953
23:50:05 <zyla> Adding the type signature `foo :: ()` fixes the problem, but I don't know why; `()` doesn't mention any `t`
23:50:18 <Axman6> o.O
23:53:17 <dmj`> untouchable
23:54:39 <zyla> Found this in GHC docs:
23:55:06 <zyla> >> [When pattern matching on GADTs] the type of the entire case expression must be rigid
23:56:35 <Axman6> saurabhnanda: it would probably be unadvisable
23:56:38 <zyla> but this compiles without type signature: foo = case Foo () of Foo () -> ()
23:57:01 <Axman6> what about Foo (1::Int)?
23:57:40 <saurabhnanda> Just reading through the mailing list archives. strangely, I didn't know the mailing list was an active discussion forum. 
23:58:04 <saurabhnanda> is there any history to the rationale behind why HP was built in the first place? What problems is it trying to solve?
23:58:06 <Axman6> it's too high traffic for me to pay attention to
23:58:38 <jle`> zyla: it's not possible to infer the type
23:58:41 <Axman6> the experience of just providing GHC and cabal wasn't exactly optimal, people thought a "batteries included" thing would be useful
23:59:16 <jle`> zyla: well, in this case, it's possible to infer
23:59:18 <grantwu> Hrm, it seems to me like the pain mostly comes from cabal, not from not having already downloaded libraries
23:59:22 <jle`> zyla: but there's no general algoritm
23:59:26 <saurabhnanda> Axman6: been bitten by that bug myself. 
23:59:38 <jle`> zyla: ghc can't infer these types of situations in general
23:59:43 <saurabhnanda> Axman6: and stack solves those problems, albeit, with an extra step.
