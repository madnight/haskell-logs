00:53:33 * hackagebot quiver-interleave 0.2.0.2 - Interleave values from multiple Quivers  https://hackage.haskell.org/package/quiver-interleave-0.2.0.2 (IvanMiljenovic)
01:11:17 <Paprikachu> is there a function that takes two arguments and returns the first, discarding the second?
01:11:52 <Paprikachu> > (curry fst) 1 2
01:11:54 <lambdabot>  1
01:13:17 <jle`> Paprikachu: 'const'
01:13:23 <jle`> > const 1 2
01:13:25 <lambdabot>  1
01:13:28 <jle`> it's in Prelude :)
01:13:41 <Paprikachu> oh interesting, thanks
01:13:56 <jle`> no problem! it actually comes up a lot in haskell, surprisingly
01:14:46 <jle`> note that it's lazy in its second argument
01:14:50 <jle`> > const 1 (sum [1..])
01:14:52 <lambdabot>  1
01:15:36 <jle`> > foldr1 const [1..]
01:15:39 <lambdabot>  1
01:17:00 <Paprikachu> :t foldr1
01:17:02 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
01:17:06 <Paprikachu> :t foldr
01:17:08 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:17:38 <Paprikachu> so foldr1 is a more specialized version of foldr?
01:20:20 <fnurglewitz> Paprikachu, foldr1 has no base case
01:20:39 <Paprikachu> > foldr1 (+) []
01:20:42 <lambdabot>  *Exception: Prelude.foldr1: empty list
01:20:47 <Paprikachu> > foldr1 (+) [1]
01:20:48 <fnurglewitz> Paprikachu, it's not just about the type, you cannot apply an empty Foldable to it
01:20:50 <lambdabot>  1
01:20:54 <Paprikachu> i see
01:26:12 <Paprikachu> wait, how does a right fold even work on an infinite list
01:26:32 <Paprikachu> > foldr (+) [1..]
01:26:35 <lambdabot>  error:
01:26:35 <lambdabot>      ‚Ä¢ No instance for (Typeable t0)
01:26:35 <lambdabot>          arising from a use of ‚Äòshow_M363368024787033739611053‚Äô
01:26:58 <Paprikachu> > foldr (+) 0 [1..]
01:27:01 <lambdabot>  *Exception: stack overflow
01:27:12 <Paprikachu> > foldr (const) 0 [1..]
01:27:14 <lambdabot>  1
01:27:28 <Paprikachu> am confused
01:27:47 <Paprikachu> ohhh, nevermind
01:55:19 <puregreen> why ‚Äòsum‚Äô doesn't have SPECIALIZE annotations in base-4.9, but ‚Äòmaximum‚Äô still does? has GHC optimiser got selectively smarter or something?
01:55:40 <nibble0x> It's magic! :I
01:55:40 <mpickering> What is the recommended way to "stream" from a postgresql database using postgresql-simple?
01:55:55 <mpickering> I don't mind which streaming library 
01:56:09 <mpickering> puregreen: What were the SPECIALIZE pragmas?
01:56:22 <mpickering> It probably gets specialized at call site anyway
02:02:23 <puregreen> mpickering: okay, I looked at older base and apparently I misremembered :/ ‚Äòsum‚Äô isn't specialised there either, ‚Äòmaximum‚Äô and ‚Äòminimum‚Äô still are.
02:02:48 <mpickering> What are they specialised to?
02:03:10 <puregreen> Int, Integer
02:03:36 * hackagebot quiver-instances 0.2.0.1 - Extra instances for Quiver  https://hackage.haskell.org/package/quiver-instances-0.2.0.1 (IvanMiljenovic)
02:04:01 <stalk> hi
02:04:40 <stalk> I'm trying to add a module to the `Data.FileStore` package, that would allow setting up a remote repository. Here is what I have so far http://lpaste.net/2948785251054256128
02:05:47 <stalk> My goal is to eventually have it merged upstream, so I'd welcome criticisms making this possible
02:05:58 <nibble0x> I haven't understood yet where you use Haskell really except from academic work like sorting binaries and doing math related stuff, what are some real life scenarios?
02:06:43 <puregreen> nibble0x: I'm writing a cryptocurrency in it, does it count as a real-life scenario?
02:06:57 <JSharp> nibble0x: as just one example: <https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/>
02:07:39 <nibble0x> I'm not trying to be negative about Haskell, sorry if it seemed like that, and cool!
02:07:57 <JSharp> no worries and yeah, it is
02:08:01 <JSharp> :)
02:08:27 <mpickering> It's a general purpose language, you can use it for whatever you want
02:10:20 <nibble0x> Mhm, but there must be scenarios where it's not that practical to use, or?
02:10:23 <nibble0x> Like games?
02:11:11 <JSharp> nibble0x: it might be better to ask a more concrete question, if you're looking for answers about performance... the question of 'practicality' is far too vague.
02:12:04 <nibble0x> Okey, why'd you use Haskell instead of C++ for a game?
02:13:34 <JSharp> That's going to depend far too much on the person and/or team developing the application. If you're asking about the existence of libraries and other supporting code, again, that's going to depend on what kind of game is being written. In terms of available code libraries, you can start by looking at <https://hackage.haskell.org/packages/#cat:Game%20Engine>
02:13:34 <JSharp> for what's out there.
02:15:06 <nibble0x> Thanks
02:17:58 <JSharp> Again, performance wise -- that's going to depend on what kind of game you're writing. As mpickering said, it's a general language so if C++ can implement it, Haskell should be able to do so as well; the concerns are in the details (behaviour of the GC, performance of the optimiser, etc).
02:18:30 <nibble0x> Interesting 
02:18:37 * hackagebot quiver-binary 0.1.1.1 - Binary serialisation support for Quivers  https://hackage.haskell.org/package/quiver-binary-0.1.1.1 (IvanMiljenovic)
02:20:07 <JSharp> but the languages are rather different in terms of their construction, advantages and disadvantages... you might take a look at <https://wiki.haskell.org/Why_Haskell_matters#Haskell_vs_OOP> as well.
02:21:06 <JSharp> and the section above as well
02:21:57 <lyxia> stalk: if status == ExitSuccess   I'd pattern match status directly instead
02:25:42 <JSharp> moreover, one can combine the two as facebook has done (see the previous link I posed)
02:26:41 <JSharp> so one doesn't have to make an all-or-nothing decision
02:28:29 <JSharp> which, as one might imagine, is a very good thing for practical projects.
02:29:20 <stalk> lyxia: ah, sorry I missed your comment
02:30:15 <stalk> concerning "status == success", I took it from the original source https://github.com/jgm/filestore/blob/master/Data/FileStore/Git.hs
02:30:25 <lyxia> oh
02:30:33 * lyxia shrugs.
02:30:39 <stalk> huh?
02:31:28 <stalk> As can be seen, I pretty much just adapted the Git.hs source "superficially"
02:33:54 <stalk> lyxia: Is "status == ExitSuccess" bad practice?
02:36:05 <stalk> I think I'll define a "refresh rate" so that `git pull` is not executed before each command
02:42:43 <lyxia> It's not really bad practice. I find it odd to pattern match on something else when you can just pattern match on status directly
02:43:38 * hackagebot quiver-sort 0.2.0.1 - Sort the values in a quiver  https://hackage.haskell.org/package/quiver-sort-0.2.0.1 (IvanMiljenovic)
02:47:25 <stalk> lyxia: Ok, thanks. I think I'll leave it as-is for the sake of consistency
02:47:37 <lyxia> sure
02:51:20 <suppi> a bit of an off topic question. does anyone read papers on a kindle? does it work well?
02:51:43 <jophish> suppi: It doesn't work very well :)
02:52:17 <SAL9000> suppi: the large PocketBook has a special mode for 2-column documents, which makes it particularly suitable to that kind of thing
02:52:37 <jophish> well, it didn't when I last tried to several years ago. It was a bit of a pain to get them onto the kindle and A4 PDFs don't map well to the small screen
02:53:06 <suppi> thank you! sad to hear that though :(
02:53:33 <jophish> yeah, nothing beats paper yet
02:53:33 <suppi> SAL9000: do you recommend the pocketbook?
02:54:01 <suppi> currently i read on my phone and it's not very comfortable...
03:08:19 <stalk> I don't get why A4 e-ink readers don't exist already, to be honest 
03:14:34 <ongy> stalk: they do, they are just $1k+
03:16:07 <stalk> ongy: does e-ink technology scale this badly, or is it just that there is no demand?
03:16:53 <ongy> they are pretty proud to have 13" in an affordable range these days, so I think it just doesn't scale. But it's not really on topic here
03:19:51 <huskyyy> any simple styleguide references?
03:20:03 <huskyyy> cause I'm kinda lost even when it comes down to indentation
03:20:27 <ongy> indent with spaces, I recommend 4. Others I can't say much
03:20:56 <huskyyy> ongy: I know compiler shouts when you indent with tabs too :P
03:22:06 <ongy> I think only if you mix it
03:22:59 <huskyyy> Also is there an alternative to zipWith (:)
03:24:54 <vitamin-q> Hi all, sorry to be that guy but I'm learning the language and have encountered an error in a program I am writing: http://lpaste.net/6399075974788415488 A lot of googling hasn't helped my understanding so would anyone be able to understand how to fix my compiler error?
03:28:41 <dibblego> does there exist FilePath -> FilePath -> FilePath that will take "/tmp/abc/ghi" "/tmp/abc/def/ghi" to "../../ghi" ?
03:36:31 <srhb> dibblego: That would be unsafe, so I'm guessing not.
03:36:48 <dibblego> why unsafe? Just in IO is fine
03:37:15 <srhb> dibblego: Because it's not necessarily true: http://neilmitchell.blogspot.dk/2015/10/filepaths-are-subtle-symlinks-are-hard.html
03:38:40 * hackagebot opaleye 0.5.2.2 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.5.2.2 (tomjaguarpaw)
03:39:40 <Gurkenglas_> vitamin-q, replace line 30 with "parseBrainfuck xs = BrainfuckSource (mapMaybe charToBF xs)" or "parseBrainfuck = BrainfuckSource . mapMaybe charToBF"
03:41:18 <Gurkenglas_> (The current line eta-expands to "parseBrainfuck xs = (BrainfuckSource (mapMaybe charToBF)) xs", which is "parseBrainfuck xs = BrainfuckSource (mapMaybe charToBF) xs", so it complains about BrainfuckSource getting two arguments
03:41:22 <Gurkenglas_> *)
03:42:38 <vitamin-q> Gurkenglas_: I see, it works now. Thank you so much! :)
03:48:12 <kuribas> I need to support default values in a structure.   I could make fields with defaults a Maybe type, and replace Nothing with the default.  Is there a better way?
03:49:40 <kuribas> Some fields depend on other fields.
03:56:04 <MarLinn> kuribas, you could use Data.Default to define defaults, but some frown upon that
03:56:17 <kuribas> what does it do?
03:56:19 <opqdonut> kuribas: one idea is to define "data MyData f = MyData {normalfield :: Int, optionalfield :: f Bool}"
03:56:36 <opqdonut> kuribas: and then use "MyData Maybe" when building, and "MyData Identity" afterwards
03:56:41 <kuribas> opqdonut: Ah, use a functor instead of Maybe
03:56:48 <kuribas> that's clever 
03:56:54 <opqdonut> might be too clever
03:57:27 <MarLinn> Default basically just gives you a class. class Default a where def :: a
03:57:30 <kuribas> It can garantuee all the fields to be filled in...
03:58:06 <kuribas> MarLinn: then has every float the same default?
03:58:16 <cocreature> yes
03:59:13 <kuribas> opqdonut: well MyData Maybe == some optional fields not filled in, MyData Identity == all optional fields filled in.  I like that solution.
03:59:32 <Shockk> hello, I'd asked about this issue a week or so ago but I'm still having it;  if I start with no ghc/stack/anything, I download the stack 64-bit installer for windows and run it, then I run `stack build GLFW-b`, I get the following error from ghc:
03:59:36 <Shockk> unknown symbol `strdup'
04:02:58 <Shockk> the best that I can figure out is that it's possibly related to this same issue
04:03:01 <Shockk> https://github.com/bsl/bindings-GLFW/issues/27
04:03:38 <Shockk> but that was resolved last year and it is getting the latest version of bindings-GLFW, which should have that fix
04:12:02 <Shockk> I just tested with lts-6.25 (ghc 7.10.3) and interesting I don't have the same issue with that
04:12:47 <cocreature> it looks like the strdup definition has moved to a separate header that is only included when _GLFW_WIN32 is defined
04:13:46 <cocreature> I‚Äôm not sure if that is done automatically by glfw or if you need to do so yourself
04:13:57 <Shockk> hmm I see
04:14:33 <haskell4144> Hello every one i am a newbie in haskell and i was wondering if i can get help from you
04:14:47 <cocreature> haskell4144: sure just ask your question
04:15:03 <cocreature> helping people is what this channel is for :)
04:17:18 <Shockk> hmm no that doesn't seem like the issue cocreature, I just checked which versions of bindings-GLFW and GLFW-b are in each respective lts
04:17:31 <Shockk> the versions are the same in lts-6.25 and in lts-7.10
04:17:47 <Shockk> but lts-7.10 is the one getting this error
04:18:02 <cocreature> Shockk: lts 7 uses ghc 8, so that might be the issue
04:18:07 <Shockk> right
04:18:23 <Shockk> that's what I thought, but I'm not sure
04:18:34 <Shockk> and I'm not really sure how to debug this further
04:18:56 <cocreature> sorry not sure either
04:18:56 <haskell4144> I have a relation set {0,1,2,3} and it contains ordered paired {0,1},{1,1},{1,2},{2,0},{2,2},{3,0} and i am supposed to create a function to determine a reflexive and symmetric closure of that set R
04:19:14 <Shockk> oh someone has my same issue :D
04:19:16 <Shockk> https://github.com/bsl/bindings-GLFW/issues/48
04:19:24 <Shockk> that's good to know, apparently related to 64-bit
04:20:17 <cocreature> Shockk: the solution is obviously to use sdl2 :)
04:20:35 <Shockk> hmm....
04:21:08 <cocreature> haskell4144: where are you stuck?
04:21:48 <haskell4144> what is sdl2?
04:23:04 <cocreature> sdl2 is a library mostly for creating games which handles window creation and keyboard/mouse events for you (and a bunch of other things)
04:27:44 <Shockk> I mean, I really wouldn't like to switch library
04:27:57 <cocreature> Shockk: yeah I was mostly kidding
04:28:05 <Shockk> I realized, although
04:28:12 <Shockk> if it can't be solved, I would have to switch 
04:28:23 <Shockk> time for me to dive in and try and find the issue
04:28:25 <Shockk> :D
04:28:50 <cocreature> good luck :)
04:28:53 <Shockk> thanks
04:29:26 <Shockk> I need to solve this by dec 9th too :D
04:29:39 <Shockk> I'm going to try and write something for ludumdare
04:34:26 <Phyx-> Shockk: strdup doesn't exist on Windows
04:34:33 <Phyx-> Shockk: the name on windows is _strdup
04:34:52 <Shockk> Phyx-: from what I could tell the glfw code in bindings-GLFW #defines it though
04:35:09 <Phyx-> Shockk: can you give me a link?
04:35:12 <Shockk> one sec
04:35:43 <Shockk> https://github.com/bsl/bindings-GLFW/blob/8f0b2834f97c3ebdbca88ce53dcedd044a6b6460/glfw/src/win32_platform.h#L71
04:36:52 <kuribas> opqdonut: I am getting: "Expecting one more argument to Maybe"
04:37:14 <kuribas> opqdonut: for my function "fontInfoDefaults :: GlyfTable -> FontInfo Maybe -> FontInfo Identity"
04:37:35 <Phyx-> Shockk: that macro is only defined when the Microsoft compiler is used. GHC uses GCC so that macro will never be defined.
04:38:34 <Phyx-> Shockk: when I rewrote the linker in GHC 8 I stopped exporting deprecated names. This is turns out was a mistake as lots of packages don't correctly import the non-deprecated name.
04:38:56 <Shockk> Phyx-: hmm I see
04:39:08 <Shockk> that makes sense
04:39:12 <Phyx-> I've added a redirection for 8.0.2 which should be out soon. Until then, You'll have to edit that package to #define strdup _strdup unconditionally
04:39:14 <Shockk> I was about to ask "how did it ever work"
04:39:36 <kuribas> Why doesn't haskell allow f :: * -> * in "data MyData f = MyData {normalfield :: Int, optionalfield :: f Bool}"?
04:40:37 <Phyx-> Shockk: it works compiled, but not interpreted in GHC 8.
04:41:07 <Shockk> Phyx-: it seems like checking for MSC_VER is the wrong behaviour regardless though, so waiting for 8.0.2 wouldn't be the correct thing to do right?
04:41:15 <kuribas> opqdonut: never mind, I hadn't filled in any fields in my datatype, so haskell assumed it was *
04:41:26 <Shockk> is there a correct compile-time flag to check for on windows?
04:42:39 <Phyx-> Shockk: _WIN32
04:42:58 <Shockk> oh of course, okay, thanks
04:43:09 <Shockk> I'll try that and maybe throw a pull request at it
04:43:44 <Phyx-> Shockk: now that I recall, you'll never get GLFW to work with < 8.0.2, there's another bug that will cause random segfaults https://ghc.haskell.org/trac/ghc/ticket/12031
04:43:51 <Phyx-> so you'll need 8.0.2. 
04:44:33 <Phyx-> well, interpreted, compiled it should work fine
04:44:45 <Shockk> ah :(
04:45:11 <Shockk> hmm is interpreted the default behaviour? I'm not sure if I understand what interpreted means in this context
04:45:25 <Phyx-> interpreted means if you open it in GHCi
04:45:39 <Phyx-> or use TH.
04:45:53 <Shockk> oh, I'm actually getting the strdup issue when compiling though
04:46:29 <Phyx-> yeah, then it's because of Template Haskell. GLFW must use it somewhere
04:46:38 <Shockk> ah right I see
04:47:02 <Shockk> hmm oh right, that would explain perfectly why bindings-GLFW itself doesn't have the error, but GLFW-b has the error trying to load the package
04:47:47 <Phyx-> everything should work out of the box on 8.0.2, which should be due soon
04:47:56 <Shockk> right
04:48:39 <Shockk> would the answer to "when will 8.0.2 be released" be "when it's ready"?
04:49:11 <Phyx-> I don't know the final date, but the first release candidate is out, so barring any show stoppers, should be soon.
04:49:21 <Shockk> great, thanks
04:49:31 <Phyx-> in the mean time, if you just want to compile. you can edit the file and fix the strdup
04:49:39 <Shockk> right that's true
04:49:47 <Phyx-> as long as it's just compiled (no ghci) you won't hit the relocation bug
04:50:04 <Shockk> ah okay, but will I hit that if GLFW-b is using th?
04:50:29 <Shockk> TH*
04:51:48 <Phyx-> no, that should be fine, it's a bit of a complicated story, but in GLFW's care it should be ok.
04:51:52 <Phyx-> for compiling
04:52:00 <Shockk> hmm okay I'll give it a try
04:52:02 <Shockk> thanks very much 
04:52:12 <Phyx-> np
04:52:20 <Phyx-> case*
05:02:00 <Shockk> Phyx-: just an update; I checked (by adding a #warning inside the #if #end), and it definitely doesn't enter that condition,
05:02:15 <Shockk> also instead of checking if defined(_WIN32)
05:02:25 <Shockk> I used the feature test stuff from https://linux.die.net/man/3/strdup
05:02:30 <Shockk> but negated it
05:05:35 <Phyx-> Shockk: I would just check for _WIN32, glibc isn't used on Windows, we use the microsoft c runtime.
05:06:06 <Shockk> Phyx-: that's true but I'm thinking more for submitting that to glfw itself though, or something
05:06:28 <Shockk> I assume the issue also exists in upstream glfw
05:07:10 <Shockk> it does yep
05:08:03 <Phyx-> Shockk: checking for _WIN32 is still the correct thing, on windows you *always* want _strdup.
05:08:14 <Shockk> hmm ah right
05:08:56 <Phyx-> also we've taken particular care in 8.0.2 that if you do use the correct symbol names such as_strdup we won't break and give you a duplicate symbol error.
05:11:14 <Phyx-> Shockk: https://ghc.haskell.org/trac/ghc/ticket/12497 for details
05:11:52 <Shockk> right that sounds good
05:32:31 <Berra1> If I have a WriterT ((), [String]) and I want to mapM_ over the [String]. There must be some better way than doing (go . snd)  ?
05:35:16 <Berra1> Sigh, sorry. I just use execWriterT instead of runWriterT
05:36:11 <volhovm> Hi! I have a problem with yesod -- this message: http://pastebin.com/6nx6YZH3
05:36:27 <volhovm> My main yesod datatype is ioref on map that represents state.
05:36:42 <volhovm> I'm following this manual: http://www.yesodweb.com/book/visitor-counter
05:46:32 <jchia_1> do i need to know category to effectively use arrows in haskell?
05:46:38 <jchia_1> i mean "category theory"
05:46:45 <Tuplanolla> No.
05:46:58 <Tuplanolla> Every bit of math helps, but none of it is necessary.
05:47:26 <jchia_1> What's the advantage of using arrows?
05:47:35 <jchia_1> Does code become simpler?
05:47:56 <Tuplanolla> They're less expressive than monads and thus supposedly easier to reason about.
05:48:34 <jchia_1> Doesn't sound too diffficult, then
05:48:57 <Tuplanolla> Some also consider arrows sans `arr` to be more useful.
05:49:40 <jchia_1> Because they think arr is complicated?
05:50:06 <Tuplanolla> Because `arr` gives the user too much power.
05:50:11 <Tuplanolla> See Conal's From Haskell to Hardware for example.
05:50:21 <jchia_1> Well, ghc-mod suggested using Control.Arrow.first in my code, so that got me thinking about arrows.
05:50:44 <jchia_1> Tuplanolla: Thanks, I think I'll spend 15 minutes and see how much I can understand.
05:50:48 <Tuplanolla> Most commonly `Control.Arrow` is just used to glue functions together like that.
05:51:05 <Tuplanolla> You don't really need arrows for that.
05:51:17 <Tuplanolla> > (sum &&& zip <*> tail) [1 .. 4]
05:51:19 <lambdabot>  (10,[(1,2),(2,3),(3,4)])
05:51:37 <jchia_1> Found:
05:51:37 <jchia_1>   \ (sym, config) -> (Sym . encodeLatin1 $ sym, config)
05:51:38 <jchia_1> Why not:
05:51:38 <jchia_1>   Control.Arrow.first (Sym . encodeLatin1)
05:52:13 <MarLinn> volhovm, I think the YesodDispatch instance should be created by the mkYesod TH. I'd wager some precondition is missing because you changed the contents of the IORef?
05:52:29 <Tuplanolla> That's just because `first f = bimap f id`.
05:52:44 <jchia_1> So, I could use bimap instead of arrow?
05:52:49 <volhovm> MarLinn: already solved, i've forgot to add it. 
05:53:04 <Tuplanolla> It's a property of bifunctors that just so happens to be shared by arrows and lives in `Control.Arrow`.
05:53:09 <volhovm> BTW yesod IOref-style storage is kinda strange. I added my own MonadState innerstate instance
05:53:19 <volhovm> via ioref dispatching. But that's hacky.
05:54:15 <jchia_1> Tuplanolla: You mean (&&&)?
05:54:40 <jchia_1> bimap is in Data.Bifunctor
05:55:48 <Tuplanolla> I meant `first`, but `(&&&)` as used on functions doesn't relate to arrows either.
05:55:59 <MarLinn> jchia_1, depending on the use case you can use applicatives, bifunctors, arrows-without-arr... Arrows can do all of those, which is what makes it so uber-powerful
05:57:11 <jchia_1> thanks
06:02:32 <MarLinn> Tuplanolla, you mentioned arrows without arr. Have you seen a general library that implements that pattern?
06:02:32 <maerwald> IO should be renamed to ArbitraryIO
06:03:45 * hackagebot socket-sctp 0.3.0.0 - STCP socket extensions library.  https://hackage.haskell.org/package/socket-sctp-0.3.0.0 (shlevy)
06:04:18 <shlevy> How often does hackage update its package list?
06:04:50 <Tuplanolla> Unfortunately not, MarLinn.
06:04:59 <stalk> hello
06:09:06 <MarLinn> Tuplanolla, I must admit I had little hope, but you never knowÖ
06:09:40 <MarLinn> Last time I tried to implement something like that it forced me to think more about category theory hierarchies than I was comfortable with at the time
06:53:15 <lyxia> shlevy: isn't it updated as soon as you upload a package
06:53:44 <shlevy> lyxia: cabal update says no :)
06:53:58 <lyxia> oh
06:54:03 <lyxia> no idea then
06:54:08 <shlevy> I'm sure if I just waited 10 minutes it would be fine I'm just impatient :D
06:54:14 <shlevy> Installed via the URL for now
06:58:09 <jgertm> im attempting to use intero inside emacs on nixos. when starting the process, it fails with this error: /nix/store/526zk5ixdxbkcf1zja33y469f2ijdvp1-ghc-8.0.1/lib/ghc-8.0.1/settings: openFile: does not exist (No such file or directory). wat do?
07:02:30 <shlevy> What's the simplest way to convert a NominalDiffTime to an Int in useconds? (to use with threadDelay)
07:09:45 <MarcelineVQ> shlevy: good question, one of the RealFlrac class methods possibly, such as round or floor
07:09:57 <MarcelineVQ> *RealFrac
07:10:35 <shlevy> I'm testing round (d * 10 ^ 6) now
07:12:44 <joe9> What am I missing here? source: https://github.com/joe9/streaming-betfair-api/blob/master/src/TimeUnitsJSONInstance.hs#L21 error: http://lpaste.net/346357
07:13:15 <joe9> https://github.com/acw/time-units/blob/master/Data/Time/Units.hs#L136 is the relevant definition of Microsecond
07:13:26 <mettekou> What's an acceptable way of configuring Cabal and Stack for builds with multiple GHC versions?
07:13:38 <_temp_> @pl p x y z = (x + y) >= z
07:13:38 <lambdabot> p = ((>=) .) . (+)
07:14:25 <_temp_> @pl p x y z = x <= (y + z)
07:14:25 <lambdabot> p = (. (+)) . (.) . (<=)
07:17:11 <lyxia> joe9: the error message says the data constructor of Microsecond is not in scope
07:25:10 <dkk> hello all
07:25:16 <NibbleNinja> hola
07:25:41 <dkk> is there some one who has used the brick library .....
07:27:13 <dkk> i need some code to refer to brick library for understanding how to use it ...... is there some one to help me 
07:27:17 <lyxia> I've played a bit with it.
07:28:06 <lyxia> Have you read the user guide?
07:29:00 <lyxia> dkk: if you have questions about some specific points I can try to answer them
07:29:55 <dkk> lyxia : can you share with me ... actually i am doing my college assignment to implement a toy editor in favour of vi and i prefer haskell then i got to know about brick .... but even after going through docuentation 4-5 times i can't get how to start exactly ... can you help me plzz .. i have 10 days only to do it.
07:30:08 <MarLinn> mettekou, No guarantees but if stack doesn't support it natively I would try to have my build system switch a symlinked .stack-work and copy the stack.yaml between builds
07:30:50 <Tuplanolla> @hackage brick
07:30:50 <lambdabot> http://hackage.haskell.org/package/brick
07:30:59 <lyxia> dkk: brick has a whole lot of demos actually
07:31:11 <dkk> lyxia : yes i have got that also 
07:31:43 <mettekou> MarLinn: Well, if by build system you mean something like Travis CI, I push to GitHub but I haven't set up Travis CI to use Stack, it uses Cabal for multiple compiler versions.
07:31:48 <Tuplanolla> This looks pretty fun. Has it been painless, lyxia?
07:32:12 <dkk> but what i want is something how to use it in real situation not isolated as in demo ..
07:33:12 <dkk> lyxia : what you have done with brick ~~Q
07:33:27 <MarLinn> mettekou, I was thinking of local builds. Not sure about Travis, sry. But maybe look what big projects like Pandoc do with it?
07:33:47 <dkk> Tuplanolla : have you also used brick ~~Q
07:34:07 <Tuplanolla> No, but I might eventually, dkk.
07:34:28 <dkk> Tuplanolla : ohk
07:34:33 <mettekou> MarLinn: Yeah, I had already quickly read Idris's Cabal and Stack files, but hadn't looked into them further. I was hoping there was a tutorial out there somewhere. üòú
07:35:28 <dkk> lyxia : can you guide me a little bit ..~~Q
07:36:30 <joe9> lyxia: Thanks.
07:37:51 <oherrala> mettekou: I have just done "stack test --resolver=lts-{6,7}"
07:38:15 <oherrala> mettekou: lts-6 uses GHC 7.10 and lts-7 uses GHC 8.0
07:38:29 <lyxia> Tuplanolla: I found it pretty easy to get something running. It's quite neat, though the docs may be a bit dry.
07:38:33 <oherrala> mettekou; then project default lts is selected in stack.yaml
07:39:29 <dkk> lyxia : can you help me a little .... i am running out of time
07:39:43 <Tuplanolla> I've had my share of ncurses modes not being reset correctly and legacy problems being all around incoherent, so I'm a bit wary of things built on top of it, lyxia.
07:40:26 <oherrala> mettekou: I have shellscript to do: for resolver in "lts-6 lts-7 nightly"; do stack test --fast --resolver=$resolver; done
07:41:07 <lyxia> Tuplanolla: vty is not built on top of ncurses, but I haven't enough experience with it to say whether there are such issues with it.
07:42:00 <Tuplanolla> Oh, I misread "in the niche of ncurses" there.
07:42:42 <MarcelineVQ> Tuplanolla: I think vty has a writeup about it in its docs section, can't remember if it's super relevant but might be an interesting read
07:42:44 <dkk> lyxia : whether i should wait for your help or move ahead ~Q
07:42:51 <lyxia> dkk: I didn't do anything too serious with it, I'm not sure you would get anything out of that. I was just trying to see whether I could build an IRC client with it.
07:44:00 <dkk> lyxia : have you used it for user-interface ~~Q
07:44:18 <lyxia> That's what the library's about.
07:44:23 <Tuplanolla> DCSS comes with a 16-color terminal graphics toolkit that works identically on Windows as well. I've looked at it a couple of times, but never made much sense of it.
07:45:22 <lyxia> dkk: You should experiment with the demos
07:47:10 <lyxia> dkk: http://hackage.haskell.org/package/pgdl this package uses brick if you insist on looking at "real" code
07:47:21 <dkk> lyxia : actually i am facing difficulty  in that how i should model multipane widgets , something like an extra pane appears in vim when we press (Ctrl + p) say
07:49:09 <zipper> Is there a better Arrow tutorial than https://wiki.haskell.org/Arrow_tutorial
07:49:43 <MarcelineVQ> do you need that level of complexity? you're short on time
07:50:07 <zipper> MarcelineVQ: Talking to me?
07:50:15 <dkk> MarcelineVQ : yes i have to ..
07:50:22 <MarcelineVQ> zipper: no sorry, to dkk
07:52:24 <ocramz> hi all!
07:52:46 <ocramz> anyone has experience with `sparse` ? I'm wondering how to perform inserts and lookups
07:53:07 <dkk> so once again is there some one who has experience with brick library ...~~Q
07:55:15 <dkk> lyxia : thanks i would try to make some sense out of the link provided by you 
07:58:49 * hackagebot hbro 1.7.0.0 - Minimal extensible web-browser  https://hackage.haskell.org/package/hbro-1.7.0.0 (koral)
07:58:51 * hackagebot hbro-contrib 1.7.0.0 - Third-party extensions to hbro.  https://hackage.haskell.org/package/hbro-contrib-1.7.0.0 (koral)
07:58:54 * hackagebot dmenu 0.3.1.0 - Complete bindings to the dmenu and dmenu2 command line tools.  https://hackage.haskell.org/package/dmenu-0.3.1.0 (m0rphism)
08:03:26 <Adeon> anyone happen to know what exactly does `NoStream` mean in https://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html#t:StdStream ?
08:03:50 * hackagebot lambda-sampler 1.0 - Boltzmann sampler utilities for lambda calculus.  https://hackage.haskell.org/package/lambda-sampler-1.0 (mbendkowski)
08:03:51 <Adeon> the launched process has no files open at 0, 1, 2 (standard outputs and inputs?(
08:04:15 <Tuplanolla> Yes?
08:04:51 <geekosaur> yes, sadly
08:05:03 <geekosaur> they apparently think that's correct behavior
08:05:12 <vctr> hi everybody
08:05:29 <Adeon> I think it may be for some cases...I was thinking do I need to explicitly open "/dev/null" for the streams I want to discard
08:05:52 <geekosaur> there are very good security reasons to ensure that 0,1,2 are open on /dev/null instead of closed.
08:06:11 <Adeon> yeah that makes sense
08:11:28 <lyxia> dkk: http://lpaste.net/346397 press a key and a new widget appears
08:13:11 <Adeon> are there any libraries for dynamically binding to ffi
08:13:16 <Adeon> that is, I don't know the type of C function at compile type
08:13:24 <Adeon> like cffi in python
08:14:27 <Adeon> hmm, I do see how I would work around not having features like that but it would be convenient
08:14:39 <AndreasK> Adeon: http://stackoverflow.com/questions/6740850/call-c-functions-from-haskell-at-runtime
08:15:03 <AndreasK> Adeon: Might be a good starting point
08:15:27 <Adeon> if it didn't have condition that I have to know all possible function types beforehand...
08:16:20 <Adeon> for my specific use case I can do a little C shim that can deal with it
08:16:29 <AndreasK> Adeon: Out of interest what are you doing where you don't know the interface?
08:16:40 <Adeon> generating compiled C code on fly that is dlopen()d to the process
08:17:04 <kuribas> Adeon: https://hackage.haskell.org/package/plugins-1.5.5.0
08:17:49 <AndreasK> Cool good luck :) 
08:18:21 <Adeon> plugins looks nice but I'm not sure if it's solving my problem, got to dig more through the docs
08:18:50 * hackagebot dmenu-pmount 0.1.0.0 - Mounting and unmounting linux devices as user with dmenu and pmount.  https://hackage.haskell.org/package/dmenu-pmount-0.1.0.0 (m0rphism)
08:23:49 <Adeon> yeah I think I'll just shim it
08:23:50 * hackagebot dmenu-pkill 0.1.0.0 - dmenu script for killing applications. Sortable by process id or CPU/MEM usage.  https://hackage.haskell.org/package/dmenu-pkill-0.1.0.0 (m0rphism)
08:24:16 <Adeon> it's this machine learning numeric thing so there's a limited number of ways you can give arguments even though you may in theory have 1000 arguments
08:25:03 <Adeon> I can make it so that from haskell side the function signatures are predictable and C side deals with it
08:26:23 <dkk> lyxia : thanks .... a lot 
08:28:51 * hackagebot dmenu-search 0.1.0.0 - dmenu script for searching the web with customizable search engines.  https://hackage.haskell.org/package/dmenu-search-0.1.0.0 (m0rphism)
08:33:10 <awkure> yep
08:33:28 <kuribas> Adeon: Can you recommend a handbook for machine learning?
08:33:47 <Rotaerk> pfft, machines can't read handbooks
08:34:11 <Tuplanolla> That might change soon.
08:35:35 <cocreature> Adeon: libffi seems like it might be what you are looking for https://hackage.haskell.org/package/libffi-0.1/docs/Foreign-LibFFI.html
08:35:39 <cobreadmonster> kuribas: How much math do you kno?
08:36:03 <kuribas> cobreadmonster: some statistics, basic calculus
08:36:28 <Adeon> machine learning is a little fuzzy term
08:36:39 <Adeon> what I have is a bayesian inference thing so it crosses a bit on statistics side
08:37:10 <cobreadmonster> kuribas: multivariate calculus?
08:37:44 <kuribas> cobreadmonster: yeah, but not the advanced stuff
08:37:56 <Adeon> I don't think you actually need to know much mathematics for some of the cool stuff
08:38:06 <Adeon> like neural networks are not some supercomplicated thing you need advanced mathematics for
08:38:12 <cobreadmonster> kuribas: can you do Stokes theorem?
08:38:20 <kuribas> no..
08:38:31 <Adeon> except maybe backpropagation or some of the advanced gradient descent methods
08:38:42 <AndreasK> There is a big difference between a handbook on how to use ML stuff and how to implement it.
08:38:45 <cobreadmonster> Adeon: you need it for SGD
08:38:48 <cobreadmonster> exactly.
08:39:26 <kuribas> cobreadmonster: so basicly brush up my math first?
08:39:55 <LKoen> I've been in a computer science school for one year and I must say, the lack of mathematics knowledge of the students was a huge impediment
08:40:44 <joe9> how to convert NominalDiffTime to Integer?
08:41:06 <joe9> NominalDiffTime seems to be a wrapper over Pico, which is Fixed.
08:41:06 <Adeon> floor and ceil I think work on NominalDiffTime
08:41:07 <kuribas> LKoen: wouldn't they be "required" to know the math?
08:41:22 <Adeon> I think floor and ceil get you seconds though
08:41:23 <cobreadmonster> kuribas: There's Andrew Ng's lecture notes.
08:41:24 <LKoen> required? how so?
08:41:49 <Adeon> for theoretical computer science maybe
08:41:55 <Adeon> I'm not sure how many universities make the distinction
08:42:05 <Adeon> for me 'computer science' by itself should mean mathematical side of CS
08:42:56 <kuribas> LKoen: from entrance exam.
08:43:07 <alx741> hello everyone
08:43:09 <LKoen> the entrance exam was about programming, not math
08:44:08 <alx741> how could I restrcit with the type system the integers bound in a pair of Int. I have type Position = (Int, Int), I would like to restrict those Ints between 0 and 8
08:44:19 <kuribas> LKoen: strange, I'd say math knowledge is more usefull than programming knowledge.
08:44:36 <dkk> is there some who have experience with brick library ~~Q 
08:44:51 <dkk> is there some one who have experience with brick library ~~Q 
08:44:56 <Tuplanolla> Nobody's going to do your homework for you, dkk.
08:45:12 <Tuplanolla> You need to ask more specific questions.
08:46:10 <dkk> Tuplanolla : ok , how to handle multiple widgets in brick ... can someone help me 
08:46:39 <dkk> how to handle multiple widgets in brick ... can someone help me 
08:47:29 <EvanR> alx741: one way is to make a newtype, hide the constructor, expose a function to construct the pair that checks the numbers for validity
08:49:56 <EvanR> you can then define a "pair view" which exposes the pair for pattern matching, and view patterns extension can then make the syntax for doing the pattern match more convenient
08:53:51 <ocramz> is there an array-like datastructure that has efficient inserts as well? e.g. faster than O(N)
08:54:03 <ocramz> bulk inserts I mean
08:55:26 <ocramz> I'd like constant time access and O(log N) updates, if physically possible
08:55:51 <AndreasK> ocramz: Have you looked at Vector already?
08:56:01 <osa1> ocramz: you need a mutable structure for that
08:57:16 <AndreasK> Vector claims bulk update is O(m+n) (length of vector + number of inserts).
08:57:56 <osa1> that sounds like a functional update.
08:57:59 <AndreasK> ocramz: Or do you really need a insert?
08:58:09 <AndreasK> Yeah it's for the pure vector
08:58:24 <cocreature> ocramz: by array-like you mean O(1) update & index?
08:58:43 <ocramz> cocreature AndreasK yes indeed, like `vector`
08:59:20 <cocreature> you can get amortized O(1) append on vectors, but I don‚Äôt think you can get good inserts at arbitrary positions
09:01:47 <absence> are the reasons why packages are removed from stackage lts documented somewhere?
09:01:48 <lpaste> xcmw pasted ‚ÄúType family‚Äù at http://lpaste.net/346428
09:02:06 <ocramz> cocreature yep I was looking for something with intermediate properties between a tree and an array. I read the "revisiting matrix multiplication" by EK and didn't understand the magic involved in converting between stream types for fusion
09:03:17 <cocreature> ocramz: if you find something let me know :)
09:03:52 * hackagebot stratosphere 0.2.1 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.2.1 (jdreaver)
09:04:09 <ocramz> cocreature will do :)
09:04:12 <AndreasK> Can there be such a thing? A structure at least if it's manfisted in memory is either flat (so array-like) or nested (so tree-like). I don't see how something could be in between
09:04:26 <AndreasK> Finger Trees maybe
09:04:33 <AndreasK> But their still a kind of tree
09:05:18 <xcmw> Any way to avoid type RecipeTF on every line (other than TH)? http://lpaste.net/346428
09:06:00 <kuribas> ocramz: IntMap has O(1) acces, for a large value of 1 :)
09:10:04 <ocramz> kuribas : heh :)
09:10:45 <kuribas> "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64)."
09:14:59 <lyxia> Map Int too
09:15:21 <lyxia> since Int is finite
09:15:26 <ertesx> ocramz: finger trees
09:15:30 <AndreasK> If your keys are finite your map is always O(1) in a way
09:15:45 <AndreasK> Which is fun but useless :D
09:16:00 <lyxia> Thus, Vector is O(1) append
09:16:21 <ertesx> ocramz: they have O(1) access in the best case and tend toward O(log n) as you do more and more inserts, but at any point they allow you to "defragment" (at some extra cost) to return closer to O(1)
09:17:25 <ertesx> AndreasK: everything is O(1), if you don't parameterise ;)
09:18:53 * hackagebot oanda-rest-api 0.3.0.0 - Client to the OANDA REST API  https://hackage.haskell.org/package/oanda-rest-api-0.3.0.0 (jdreaver)
09:19:21 <ertesx> cocreature: ^
09:21:17 <cocreature> ertesx: yeah I know about fingertrees
09:21:44 <ertesx> one nice thing about finger trees in particular (as opposed to, say, binary trees) is that they also start at O(1) at the edges and tend toward O(log n) (where n number of chunks) as you get closer to the middle (of the tree, not the vector it represents)
09:22:08 <ertesx> so at the edges you're always at O(1)
09:22:16 <ocramz> ertesx: thanks for the pointers, but I really need fast random access
09:22:23 <ocramz> it's for a numerical application
09:22:56 <ertesx> ocramz: you get have that by making sure that you never overfragment‚Ä¶  keep the fragmets about the size of a cache line perhaps
09:23:03 <ertesx> s/get/can/
09:23:25 <AndreasK> You probably want a mutable vector then if you never use the old versions
09:23:43 <ertesx> mutable vectors don't have cheap inserts though
09:24:03 <ertesx> ocramz: if finger trees aren't good enough you should try to avoid needing inserts
09:24:31 <ertesx> but if you absolutely need them, i don't think you can get much better than finger trees
09:24:58 <ocramz> ertesx: yes that's a complex design decision: to switch between data representations before executing certain functions
09:25:42 <cocreature> you can also try accumulating updates and only pay the price for allocating a new vector once
09:25:48 <AndreasK> Guess you could use a list of mutable vectors if the size of the individual fragments don't change. But at the level of optimization it depends far to much on the use case to give general advice imo
09:26:27 <ertesx> a finger-tree of mutable vectors would also work =)
09:26:36 <EvanR> i have a O(1) insertable data structure here
09:26:58 <EvanR> [(k,a)], you insert by prepending a new (k,a)
09:27:20 <AndreasK> EvanR: That doesn't have fast random access though
09:27:45 <EvanR> well ill be darned if the goal posts keep moving out from under me!
09:28:04 <AndreasK> Would leak memory too I think
09:28:16 <EvanR> how many requirements do we really have!
09:28:36 <AndreasK> Nothing big, just solving the halting problem really :p
09:28:44 <ocramz> EvanR : O(1) random access and better than O(N) bulk inserts
09:28:55 <EvanR> cant be done
09:29:43 <EvanR> however the array-mapped tries does perform well on bulk inserts and is "effectively O(1)" lookup
09:30:37 <ocramz> EvanR : could you point me to an implem?
09:31:57 <EvanR> unordered-containers HashMap is the goto thing like that now
09:32:59 <EvanR> but depending on what you are doing IntMap might be faster
09:34:53 <ocramz> EvanR : sparse inner products, sparse matrix-vector products. The insert requirement arises due to a number of matrix factorization algorithms: I don't know in advance the sparsity pattern of the resulting matrices
09:35:12 <ertesx> i wish software engineering problems were as easy as math problems‚Ä¶  "i need the continuum hypothesis to be true for this one" ‚Äì "oh?  no problem, just assume it's true"
09:35:33 <ocramz> ertesx: yeah :D wishful thinking is not enough in this case
09:35:47 <EvanR> ocramz: right so, to take your requirement literally, insert is log n, so "bulk" insert is m log n
09:36:21 <EvanR> and lookup in IntMap and HashMap Int are "effectively O(1)"
09:36:35 <EvanR> does this mean itll be fast enough? no, does it mean itll be too slow? no
09:36:46 <ertesx> i'm assuming that by "i need O(1)" ocramz means "i need it to be cheap"
09:37:09 <shapr> Is there a package of common IETF quickcheck instances?
09:37:32 <EvanR> is it cheap enough? no is it too expensive? not necessarily
09:38:11 <ocramz> EvanR : a number of riddles :)
09:39:35 <EvanR> HashMap Int lookups use the hash of the Int (identity function) to jump a small number of levels down
09:39:41 <ertesx> with the little detail about the problem that ocramz has provided, i would most likely go with finger trees of (immutable) vectors, perhaps together with cocreature's suggestion to accumulate changes, and with a suitable insertion algorithm that keeps fragments as large as possible
09:40:00 <shapr> simpler, how do I quickcheck an Applicative instance?
09:40:02 <EvanR> and has been carefully optimized, as i understand it
09:40:04 <ertesx> this problem is very similar to what efficient filesystems have to deal with
09:41:00 <bonnie> hey guys, im haskell beginner and i wanted to ask about this error:
09:41:06 <bonnie> <interactive>:59:1: error:     ‚Ä¢ Non type-variable argument in the constraint: Num ([t1] -> t)
09:41:10 <ocramz> ertesx EvanR : thanks for all the pointers, I'll meditate on this
09:41:14 <ertesx> shapr: if you can generate F in general, you can also generate F (A -> B) using Coarbitrary‚Ä¶  if you have Eq or Eq1 for F, you can just use (==)
09:41:26 <alx741> EvanR: will try that, thanks!
09:41:26 <ocramz> bonnie: you forgot to give an argument somewhere
09:41:31 <shapr> I've probably said this already, but I love this document "What I Wish I Knew When Learning Haskell" : http://dev.stephendiehl.com/hask/
09:41:41 <ocramz> \paste
09:41:45 <ocramz> oops
09:41:48 <bonnie> ocramz can i send u 
09:41:52 <bonnie> ?
09:42:00 <ocramz> bonnie: paste the code in lpaste
09:42:02 <ertesx> @lpaste
09:42:02 <lambdabot> Haskell pastebin: http://lpaste.net/
09:42:08 <EvanR> alx741: as a side remark, the type Fin 8 in dependently typed languages is the type of numbers 0 to 7
09:42:16 <bonnie> okay ill try :)
09:43:14 <bonnie> ocramz i did 
09:43:21 <bonnie> but what should i do now?
09:43:26 <ocramz> paste the link here
09:43:29 <ertesx> alx741: you could not restrict them and just choose a more suitable equivalence relation than equality
09:43:32 <bonnie> http://lpaste.net/346451
09:43:38 <bonnie> okay thank you :)
09:43:46 <ertesx> alx741: interpret all numbers modulo 8, for example
09:45:12 <ertesx> bonnie: you say:  kopf = head (y:ys)
09:45:19 <ertesx> bonnie: therefore kopf = y
09:45:27 <ocramz> bonnie: what was it supposed to do? it compiles fine
09:45:31 <ertesx> you don't need to separately extract it
09:45:56 <bonnie> ectresx yes i know it was just because i did it with a constant list before 
09:45:58 <ertesx> also i love the language mix =)
09:46:55 <bonnie> oh i think it actually works!!!! i forgot to put the name of the function in the compiler !!!! oh my god, so ashamed....
09:47:01 <bonnie> thank you guys!!
09:47:03 <bonnie> haha
09:47:15 <ertesx> bonnie: i don't know if it works, because 'rest' looks very suspicious
09:47:28 <ertesx> kopf = head (3 : [4,5,6])
09:47:35 <bonnie> ertesx let me check!
09:47:41 <ertesx> rest = drop 3 (3 : [4,5,6])
09:47:51 <ertesx> rest = [6]
09:48:15 <bonnie> retest does drop drop the last element?
09:48:27 <ertesx> > drop 1 [1..9]
09:48:30 <lambdabot>  [2,3,4,5,6,7,8,9]
09:48:30 <ertesx> > drop 2 [1..9]
09:48:33 <lambdabot>  [3,4,5,6,7,8,9]
09:48:44 <shapr> What's the most popular testing framework that wraps both quickcheck and hunit?
09:49:22 <AndreasK> init [1,2,3]
09:49:28 <bonnie> ertesx but thats what i need
09:49:39 <AndreasK> When does lambda bot execute statements?
09:49:40 <ertesx> shapr: i don't know about *most* popular, but tasty is both popular and wraps QuickCheck and HUnit
09:49:56 <geekosaur> AndreasK: "> " prefix or @run command
09:50:06 <AndreasK> >init [1,2,3]
09:50:08 <ertesx> bonnie: ah, then that's fine
09:50:14 <AndreasK> > init [1,2,3]
09:50:15 <geekosaur> the space is not optional
09:50:16 <lambdabot>  [1,2]
09:51:29 <bonnie> retest it doesn't work :( look:  *** Exception: √ú3.hs:(23,1)-(27,47): Non-exhaustive patterns in function chosencoin
09:51:50 <ertesx> bonnie: do you see what that error means?
09:52:02 <bonnie> ertesx no :/
09:52:13 <ertesx> bonnie: what's chosencoin 0 []?
09:52:31 <bonnie> []
09:52:34 <bonnie> no
09:52:39 <bonnie> just 0
09:52:41 <geekosaur> where do you say that in the definition?
09:52:47 <bonnie> i suppose
09:52:57 <ertesx> bonnie: unfortunately GHC can't read your mind =)
09:53:11 <ertesx> it gets close sometimes, but it's still just an interaction of the type system with your code =)
09:53:22 <bonnie> thats my problem :)
09:53:54 <bonnie> yes i still have to learn to interact with a program and its language ...
09:53:57 <geekosaur> ```chosencoin s (y:ys) =``` this only handles non-empty lists
09:55:58 <vctr> anyone doing gamedev in haskell?
09:56:10 <vctr> w/ ghcjs / reflex?
09:57:33 <iomonad> vctr: We can make games w/ helm ?
09:58:13 <vctr> iomonad i thought helm was kinda dead
09:58:49 <vctr> people seem to prefer alternative FRP like reflex, reactive-banana
09:59:00 <vctr> i've yet to see anything released with helm and it's been out for a while
10:00:26 <iomonad> checked reactive-banana, look nice
10:02:52 <ertesx> vctr: reactive-banana and reflex aren't "alternative FRP"
10:02:56 <ertesx> in fact helm isn't FRP
10:03:17 <vctr> i thought it was based on elm's frp 
10:03:26 <ertesx> well, elm isn't FRP either =)
10:03:28 <vctr> + some sdl bindings on top
10:03:38 <vctr> elm's frp interpretation...
10:03:54 <vctr> which itself has evolved. as i understand it it's no longer part of the core language
10:05:42 <maerwald> yeah, I've yet to see a proper technical explanation. I just hear people saying it
10:05:52 <ertesx> vctr: anyway, i don't know about gamedev, but there is certainly UI dev going on with reflex-dom
10:06:44 <maerwald> in fact, I see a thesis that explains the FRP parts of Elm (the old elm)
10:06:49 <neonfuz> ertesx: elm used to be frp
10:07:54 <ertesx> neonfuz: it used to be "signal-based reactivity", but not FRP according to the original formulation‚Ä¶  it has a unified discrete type of "signals" instead of FRP's separate types for discrete events and continuous behaviours
10:08:05 <ertesx> now it's not even that anymore
10:08:22 <neonfuz> I'm currently planning on using haskell for gamedev
10:08:32 <neonfuz> I think helm was weird because it focused on vector graphics
10:08:48 <neonfuz> I was planning on either writing a small c/c++/rust program that actually does the drawing, that just talks to a haskell program doing the logic
10:08:55 <neonfuz> or using sdl + haskell
10:09:42 <ertesx> neonfuz: use sdl2 + haskell, perhaps with OpenGL‚Ä¶  there is no reason to do the drawing in another language
10:09:44 <maerwald> ertesx: well, you are talking about classical FRP then, but that's not the only semantics
10:10:49 <pyrtsa> Elm's version of FRP also had no means for switching, so the whole graph existed in memory all the time.
10:10:54 <vctr> i think it'd be interesting to go the ghcjs route
10:11:02 <ertesx> maerwald: oh, of course!  when you do FRP wrong, just justify yourself by splitting the world into "classical FRP" and, oh, let's also do some marketing to call the wrong one "modern FRP" =)
10:11:12 <maerwald> *sigh*, whatever
10:11:17 <vctr> for gamedev, but i've yet to see anyone try it
10:11:22 <maerwald> nothing technical or useful in that statement
10:12:05 <ertesx> pyrtsa: no, switching wasn't the problem‚Ä¶  you can have switching in elm-style reactivity (see e.g. bacon.js)‚Ä¶  they chose to go without switching, because first-order reactivity is much easier to implement
10:12:14 <vctr> can agree to have separate definitions but arguing about definitions is only so useful
10:13:00 <ertesx> pyrtsa: (and also you can actually get surprisingly far without switching)
10:13:02 <pyrtsa> ertesx: Not saying it wasn't *the* problem. But the lack of it limits what you can do, while at the same time it gave the possibility to do cool live updating of code.
10:14:05 <ertesx> anyway, i generally recommend reflex or AFRP for games, potentially even a combination of both (they work well together)
10:14:27 <pyrtsa> Ditto.
10:20:41 <conal> maerwald: maybe what ertesx was saying is that much of what people call "FRP" these days isn't just an alternative semantics, but no precise semantics/denotation/specification at all. 
10:22:28 <conal> maerwald: and, lacking a specification, "It is not only not right, it is not even wrong." - Wolfgang Pauli
10:25:29 <EvanR> all of those bacon like things listed in FRP-zoo do have semantics, operational semantics of a kind not usually explicitly explained
10:26:14 <EvanR> for each one you need to go on a quest to get the library author to give you clues to understanding how to use it
10:26:25 <conal> EvanR: yep. just operational. and quite messy at that. 
10:27:51 <EvanR> there does seem to be a unifying force though, pretty much everyone in here agrees, for better or worse, that there exists an important object called "the graph" which needs to be understood to predict what will happen
10:28:51 <conal> EvanR: not at all. there is no graph other than in some operational/implementation notion.
10:29:04 <EvanR> this the-graph thing has never sat well with me, it doesnt seem very haskelly
10:29:04 <maerwald> conal: to me it sounds like he wants copyright on the terminology. It's like saying "language XY is not functional because it's not <insert your favorite GHC feature>". Ofc there has been more research on the topic and interpretations of what it is and how it should be done deviate. And those are scientific sources, not IRC opinions.
10:29:12 <conal> EvanR: and a graph is usually a pretty bad choice of implementation.
10:29:28 <alcuadrado> how can this type? [putChar 'a', readLn ] :: [IO ()]
10:29:28 <maerwald> and they have sufficiently precise terminology
10:29:43 <alcuadrado> it types in GHCi, but I don't get how
10:29:59 <ertesx> i was really just saying: if you don't do XML right (perhaps you're doing CSV), don't say that others do "classical XML"‚Ä¶  there is a reason why it's called XML, and one of them is that it has a tree structure and CSV doesn't
10:30:12 <EvanR> :t [putChar 'a', readLine >> return ()]
10:30:14 <lambdabot> error:
10:30:14 <lambdabot>     ‚Ä¢ Variable not in scope: readLine :: IO a0
10:30:14 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
10:30:30 <ertesx> FRP's main motivation is to have continuous time semantics
10:30:38 <EvanR> :t [putChar 'a', getChar >> return ()]
10:30:40 <lambdabot> [IO ()]
10:31:20 <ertesx> to have semantics in the first place might be called the conal principle, and it's a good one, but that's not what i was saying earlier =)
10:31:23 <EvanR> alcuadrado: Read class constraints default to ()
10:31:30 <EvanR> > read "()"
10:31:33 <lambdabot>  ()
10:31:37 <conal> maerwald: FRP was well-defined in the scientific literature. recently the term was misunderstood in confusion with "reactive extensions" (which also never had a denotation), and that confusion spread. Elm's use of the term was another confusion springing from an experimental offshoot of FRP.
10:31:48 <alcuadrado> oh, that's it! Thanks EvanR!
10:32:27 <absence> was there versions of when and guard for Applicative/Alternative before AMP?
10:32:34 <conal> ertesx: thanks, though I'd credit Peter Landin (grandfather of Scheme, ML, Haskell, and the person who realized that lambda calculus was good for programming).
10:32:47 <conal> Peter Landin and Chris Strachey.
10:34:01 <ertesx> conal: perhaps we could come up with a transitive model of crediting =)
10:34:49 <conal> ertesx: yes. FRP from the start was about (a) continuous time with (b) simple, precise denotation.
10:36:49 <hackrilege> Is there a function which returns a tuple of the records? (using Either for | )
10:37:14 <ertesx> hackrilege: huh?  do you have an example?
10:37:40 <maerwald> conal: no, look at the actual thesis, it's properly defined
10:37:45 <type_hole> The "~" character in type class constraints... what does it mean?
10:37:59 <ertesx> hackrilege: you want to translate algebraic types to (,) and Either?
10:38:01 <lyxia> type_hole: "equal"
10:38:08 <MarLinn> mhh... it sounds like people realized that in practice it was useful to think of a graph of reactions ñ which then overshadowed the simplistic beauty of the FRP semantics because graphs can be complicated?
10:38:25 <maerwald> conal: and it has a clear reference to the original paper
10:38:30 <maerwald> so there is literally _no_ confusion
10:38:34 <ertesx> hackrilege: if yes, generics do pretty much exactly that, although they use fancier versions of (,) and Either called (:*:) and (:+:) resp.
10:38:35 <type_hole> ertesx: THank you.
10:38:43 <ertesx> type_hole: that wasn't me
10:39:16 <conal> maerwald: i know what it came from: "EFRP", which was an implementation experiment, inspired by FRP but discarding FRP's two fundamental principles. 
10:39:26 <hackrilege> data Free_ f a = Free_ (Either a (f (Free_ f a))
10:40:00 <conal> do we really have a #haskell member named "implementation"? i imagine s/he gets a lot of notifications.
10:40:16 <ertesx> lyxia: thank you (i'll just forward type_hole's gratitude) =)
10:40:28 <hackrilege> Thanks ertesx! Now I can see what motivates these fundamental constructors, maybe I can learn about generics now...
10:41:06 <lyxia> ertesx: you're welcome! :D
10:41:21 <maerwald> conal: "FRP" has become a term of programming paradigm, not a term of specific implementation and that's fine. If you want to refer to something specific, you can still do that.
10:41:23 <EvanR> /nick typeclass
10:41:30 <ertesx> type_hole: you're welcome! :D  (forwarded)
10:42:31 <conal> MarLinn: FRP is no more (or less) about graphs than arithmetic is. sure one can give a sort of syntactic representation for lots of things, but they're not about syntax. and sure one can use graphs as one implementation model in many cases, but graphs are rarely the essence. 
10:42:41 <EvanR> maerwald: different people mean different things, or nothing in particular. i think this argument is about mindshare, how to influence what conjures what in new visitors minds
10:43:17 <maerwald> EvanR: I call that political crap... trying to influence what people think about what ;)
10:43:18 <EvanR> regulars know what each other are talking about
10:43:29 <hackrilege> Can i get an example of using (:+:) and (:*:) with a recursive call, e.g. To define a synonym of Free?
10:43:30 <EvanR> but argue anyway for the above reason
10:43:55 <ertesx> i think for the most part "FRP" is just a marketing term these days, just like "REST" and even "relational"
10:43:55 <maerwald> if you follow the scientific terminology trail, there's no problem with a broader definition of FRP
10:43:56 <conal> EvanR: for me, the tragedy of discarding clear definitions for fuzzy ones is that people can no longer think or communicate (collaboratively think) clearly.
10:44:37 <ertesx> i consider that an abuse, and therefore i'm not happy about people generalising "FRP" to something that is ultimately meaningless
10:44:43 <maerwald> conal: wrong, you can come up with terms that refer to specific concepts
10:44:46 <hackrilege> Canonical axioms ftw!
10:44:53 <maerwald> conal: it might just be one char difference...
10:45:10 <MarLinn> ertesx, lyxia: building a transitive graph of thank-events, are you? ;)
10:45:12 <pyrtsa> maerwald: I suggest RP for you.
10:45:18 <ertesx> =)
10:45:44 <ertesx> in particular that paradigm maerwald referred to already had a name: reactivity or reactive programming
10:46:02 <EvanR> theres not too much FRP collaboration i think, everyone goes off on their own and refuses to agree on anything
10:46:13 <EvanR> except on the name
10:46:13 <maerwald> ertesx: it's defined as Concurrent FRP
10:46:16 <maerwald> not RP
10:46:23 <ertesx> maerwald: "it"?
10:47:17 <maerwald> the Elm approach
10:47:18 <maerwald> and referring to how Elm was scientifically defined as is more useful than coming up with random interpretations
10:47:19 <lyxia> hackrilege: Free f a = Free ((Rec0 a :+: Rec0 (f (Free f a))) ())
10:47:37 <hackrilege> What's Rec0?
10:48:18 <lyxia> hackrilege: it's a Generic datatype equivalent to Const c a = Const c
10:48:28 <hackrilege> Oh it's like a one tuple...
10:49:11 <EvanR> youd think Rec0 would be an empty record
10:49:33 <mpickering> Are there some instructions somewhere about how to do profiling with stack?
10:50:13 <hackrilege> :t (:+:)
10:50:15 <lambdabot> error:
10:50:15 <lambdabot>     ‚Ä¢ Data constructor not in scope: :+:
10:50:15 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äò:+‚Äô (imported from Data.Complex)
10:50:16 <conal> maerwald: i still dont know what i said about FRP that you think you're arguing with.
10:52:59 <conal> maerwald: sorry. i meant that I don't know what I said about *Elm* that you think you're arguing with.
10:53:02 <ertesx> maerwald: i see that pattern of building meaningless terminology upon other meaningless terminology just to justify more and more meaningless arguments everywhere, especially in OOP‚Ä¶  ultimately none of these terms have any real meaning, but the original FRP does
10:53:21 <ertesx> therefore i don't really care what people, especially during marketing, redefined "FRP" to be
10:53:33 <hackrilege> What's FRP?
10:53:44 * EvanR stuffs hackrilege into a box
10:53:56 <hackrilege> Axiomatically...
10:54:05 <conal> hackrilege: see http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 and follow links
10:54:30 <Lokathor> FRP is short for "frappe", it's a kind of iced coffee drink
10:54:36 <ertesx> hackrilege: functional reactive programming‚Ä¶  it's a paradigm for expressing interactions using a semantics with continuous time, first-class time-varying values, first class events
10:54:37 <conal> hackrilege: also https://github.com/conal/talk-2015-essence-and-origins-of-frp
10:54:47 <hackrilege> denotative, continuous-time programming
10:55:16 <hackrilege> I don't get it
10:55:32 <MarLinn> Not to be confused with Concurrent Applicative Reactive Programming
10:55:38 <hodapp> whaaa
10:55:45 <conal> hackrilege: keep reading, and check out that keynote talk. they're exactly addressing your question of "what is frp"
10:55:47 <absence> hackrilege: give it another couple of minutes ;)
10:56:08 <conal> hackrilege: if you have specific questions about what you read or see, i'm happy to try answering them.
10:56:16 <ertesx> hackrilege: it's quite a mouthful to really summarise on a few lines of IRC =)
10:56:53 <ertesx> hackrilege: but in simple terms: it's a paradigm for interactive applications like interactive user interfaces, servers or even bots
10:58:15 <EvanR> what use does a server have for continuous time
10:58:29 <ertesx> EvanR: think of a game server =)
10:58:29 <EvanR> client server, request response model
10:58:35 <hackrilege> From what I can tell it's essentially compositional semantics¬† somehow related to "continuous time"
10:58:51 <ertesx> i just wanted to get across that "interactive" doesn't mean: "there is a user", but really just: "stuff happens over time" =)
10:59:28 <pyrtsa> hackrilege: The being "somehow related" in practice means that you can selectively carry state over time from past to future.
10:59:36 <hackrilege> I figured computations would happen in order, I was just using list... What does it matter what time it is?
10:59:41 <ertesx> hackrilege: the continuous time part is purely semantical‚Ä¶  it means for example that you can't ask a time-varying Bool value at which exact point it switches from False to True
11:00:08 <EvanR> why not?
11:00:26 <EvanR> (several libraries let you do this)
11:00:45 <MarLinn> I do have an FRP-based web server on my overflowing list of things I want to try to build some dayÖ
11:00:58 <conal> hackrilege: think about images as functions over space. For modularity via spatial transformations (rotation, scaling, etc), use *continuous* space as in vector graphics. FRP is the same idea but varying over "time" instead of "space", ie "dynamic information".
11:01:46 <EvanR> those spatial transformations are point-wise though
11:01:55 <Tuplanolla> Is this the "preserves limits" kind of continuous?
11:01:57 <ertesx> EvanR: do we agree that (Behaviour = (->) Time) is an implementation of FRP behaviours?
11:02:02 <hackrilege> Sounds like a way to jam computations which would happen in order under recursive evaluation
11:02:09 <pyrtsa> Another way to put it: the time points at which something happens aren't pretermined in continuous-time FRP.
11:02:19 <EvanR> ertesx: i thought that was the denotation
11:02:19 <conal> hackrilege: so imagery is space-varying info, while frp is time-varying info. both can be given simple & precise math meanings, independent of implementation/operational notions
11:02:43 <EvanR> not sure if thats a good implementation though
11:03:07 <Tuplanolla> If so, what are the limits?
11:03:11 <conal> pyrtsa: no. event times are precisely well-defined in frp (though not in many recent systems that people call "frp").
11:03:12 <EvanR> Tuplanolla: right, as far as i learned so far, functions are continuous, not spaces
11:03:12 <ertesx> EvanR: then try to write a function:  nextFlip :: Behaviour Bool -> Time -> Time  -- this function is supposed to figure out at which point starting from the given point in time the Bool flips
11:03:31 <EvanR> ertesx: fran had this
11:03:49 <EvanR> and newer libs have it in form of notifications
11:04:12 <conal> EvanR: yes, Time -> a is a denotation/specification. it also can be an implementation, but not an efficient one.
11:04:20 <ertesx> conal: is that true?
11:04:29 <EvanR> the only thing you can do with a function is apply it to Time, that is what that denotation is telling me
11:04:44 <pyrtsa> conal: I'm not sure I said something that disagrees with you.
11:04:45 <johnw> it also says that there is a value for any Time
11:04:56 <ertesx> EvanR: you can't write that function
11:05:06 <johnw> and that there is only one value for any instant in Time
11:05:10 <johnw> as a denotation, it says a fair bit :)
11:05:14 <ertesx> so fran probably had something which looked like this, but wasn't it =)
11:05:33 <EvanR> ertesx: it converged to the right answer
11:05:37 <conal> pyrtsa: ah, okay. maybe i just didn't understand what you were trying to say there.
11:06:25 <ertesx> hah!  now we're getting into ZFC vs. constructive mathematics territory‚Ä¶  i was waiting for that to happen =)
11:06:37 <EvanR> ertesx: youre asserting that it implies some operation you *cant* do, but then all the libs do it anyway, and people want it to , so whats the point
11:06:59 <monochrom> I go with ZFCC --- ZF with choice and continuum-hypothesis
11:07:00 <ertesx> EvanR: reactive-banana and reflex don't do it
11:07:07 <conal> johnw: indeed. an important part of the art of denotation is to keep it as simple (while precise) as possible.
11:07:22 <EvanR> reflex will tell you when a bool behavior flips
11:07:28 <EvanR> using "dynamic"
11:07:28 <ertesx> EvanR: nope
11:07:37 <conal> johnw: stating just the essence, without biasing implmementation.
11:07:38 <ertesx> Dynamic is a behaviour coupled with an event
11:07:42 <monochrom> clearly, there exists a way to duplicate a ball by partition and rotation :)
11:07:50 <johnw> conal: yes, that's a rather subtle point I've learned
11:07:53 <ertesx> that one can tell you when it flips, because it has an event that will tell you =)
11:08:00 <johnw> conal: choosing the right representation type feels a bit artform-y
11:08:02 <conal> johnw: indeed. and a hugely important one.
11:08:11 <ertesx> but you can't write that function for a reflex Behavior
11:08:24 <ertesx> neither can you write it for (->) Time
11:08:28 <conal> johnw: it sure is. (i assume you mean "right denotation".)
11:08:34 <absence> :t \f -> sequenceA . (=<<) f
11:08:35 <lambdabot> (Traversable t, Applicative f, Monad t) => (a1 -> t (f a)) -> t a1 -> f (t a)
11:08:44 <johnw> conal: as an example, a few months ago I chose mathematical sets for my representation type, and then bent over backwards to ensure they had all the properties I needed.  Later I discovered that simply by using lists, I gained all the requirements I needed, but nothing extra.
11:08:53 <absence> is there a monadic traverse defined anywhere?
11:09:05 <ertesx> absence: traverse
11:09:07 <EvanR> ertesx: in frans case... it used interval analysis, so there was an added constraint that Bool was equipped with intervals (true, false, and false-true)
11:09:08 <mpickering> :t mapM
11:09:10 <johnw> conal: by representation type I mean: the fundamental object your denotations are expressed in terms of
11:09:10 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
11:09:12 <conal> ertesx: :)
11:09:18 <pyrtsa> ertesx: Out of curisity, what's an example where a function telling when a behaviour flips would be problematic?
11:09:36 <EvanR> ertesx: so if a function instantly flipped to true and back, that would be detected
11:09:37 <ertesx> pyrtsa: well, it can't be done =)
11:09:47 <pyrtsa> ertesx: Depends on the implementation.
11:09:58 <ertesx> EvanR: yeah, of course‚Ä¶  but you do need additional constraints
11:09:59 <pyrtsa> Doesn't it?
11:10:13 <absence> ertesx, mpickering: look carefully at the type signature for the expression i fed to lambdabot. it's not traverse/mapM
11:10:17 <ertesx> EvanR: and that's what continuous time is about‚Ä¶  you can't do it for a general behaviour
11:10:40 <ertesx> pyrtsa: try to write it
11:10:44 <EvanR> ertesx: yeah. when you get down to it, a -> b has a very simple interface, application. you can destruct it, rearrange it, optimize it, nothing else
11:10:53 <EvanR> you cant*
11:10:58 <ertesx> pyrtsa: assume Time = Rational
11:11:06 <EvanR> in haskell you cant even debug show it ...
11:11:09 <ertesx> a sufficiently "continuous" type
11:11:34 <EvanR> do we have a real definition or precise notion of what a continuous type is ? i only know continuous functions
11:12:08 <pyrtsa> ertesx: If I can limit the functions (behaviours) to a subspace of `Time -> a`, I can.
11:12:09 <monochrom> Agreeing on Time->a is the easy part. But hard part is agreeing on Time=what? (I guess which is what ertesx said :) )
11:12:09 <EvanR> for example is Rational continuous or not, it seems ambiguous at this point
11:12:25 <monochrom> My stance is that we just need Time to be dense.
11:12:41 <ertesx> EvanR: well, one way to define it is: there is a point between each pair of distinct points
11:12:50 <ertesx> yeah, "dense" may be a better term
11:12:52 <EvanR> isnt density a relative notion? dense as a subspace of what?
11:13:13 <monochrom> No, density isn't a relative notion.
11:13:23 <EvanR> order dense?
11:13:30 <monochrom> yes.
11:13:36 <hackrilege> Just ordered it's sufficient, rational numbers are dense
11:13:49 <EvanR> so now we require ordering
11:14:18 <ertesx> if you bring topology into this, then i would also require that every point in time is topologically distinguishable from every other point (there is probably a name for that property)
11:14:21 <lyxia> there is a point between each pair of points in union({0}, (1, 2)) ...
11:14:42 <monochrom> Oh yeah, Hausdorff or something
11:14:50 <EvanR> theres like 5 kinds of that
11:14:51 <hackrilege> Countable
11:14:55 <EvanR> but why do we care?
11:14:58 <monochrom> More precisely, Hausdorff +/- 1 :)
11:15:16 <EvanR> if we dont have a topology, we cant really care about topologically distinguishability
11:15:28 <monochrom> Perhaps we do want to impose a topology.
11:15:46 <EvanR> at one point conal was all about literally the real numbers, with their usual topology i assume
11:16:01 <EvanR> we know that rationals have their limitations
11:16:04 <monochrom> The question "Time = what?" is best answered by "how will you use Time actually?"
11:16:11 <EvanR> yes!
11:17:18 <monochrom> I want density (and total order) because when given x,y :: Time, I tend to ask "what happened between x and y?"
11:17:27 <hackrilege> rather than being defined on a¬†countablelinearly ordered¬†set, a net is defined on an arbitrary¬†directed set.
11:17:37 <conal> monochrom: some uses: derivative, integral, time transformation.
11:17:38 <ertesx> and FRP's answer is: "a lot" =)
11:18:30 <monochrom> oh, you want derivative. that's why you want the reals.
11:18:52 <hackrilege> You can define derivatives over interpolating meshes
11:20:43 <conal> hackrilege: and in doing so, the semantics becomes more complex and arbitrary.
11:21:08 <hackrilege> To some O(). What order are your continuous derivatives in frp!?
11:21:20 <EvanR> lets do smooth
11:21:26 <EvanR> all derivatives
11:22:05 <monochrom> I am happy with smooth. Then we can do differential geometry.
11:22:28 <monochrom> Then we can do general relativity...
11:22:36 <talzs> Anyone have any thoughts on a good priority queue implementation?
11:22:50 <hackrilege> You can do that stuff with finite difference schemes
11:22:52 <EvanR> i have no problem with that
11:23:24 <EvanR> talzs: i have used a list with attached priority to each element
11:23:44 <monochrom> conal would be amused when one day someone proved that FRP admits black holes :)
11:24:48 <EvanR> you dont even need GR for stuff like that, theres "off to infinity in finite time" behavior in newtonian physics
11:25:04 <hackrilege> At the moment my spacial coordinates are labeled by ints, being Euclidean. I don't see how it would make sense to define my function being accessed by a real number unless it was partitioned into finite elements
11:25:14 <monochrom> talzs: Do you like http://hackage.haskell.org/package/pqueue ?
11:25:16 <EvanR> which you would be able to observe if your FRP was based on reals
11:25:42 <monochrom> talzs: Actually http://hackage.haskell.org/packages/search?terms=priority+queue and go wild
11:25:55 <conal> hackrilege: Euclidean ==> Int ???
11:26:04 <hackrilege> Tuple of
11:26:21 <conal> hackrilege: oh, an n-tuple where n is integral?
11:26:26 <monochrom> probably the "Euclidean doman" kind of Euclidean
11:26:29 <talzs> Thanks guys, currently using aivika but not sure how I feel about it. I'll take a look at those two links monochrom :)
11:26:42 <hackrilege> Exactly
11:26:58 <monochrom> a special case of ring
11:27:15 <conal> hackrilege: same for FRP time, which is one-dimensional
11:28:45 <monochrom> (Int, Int) has an algebraic side (it's a Euclidean domain) and a topology side (it's discrete etc). Actually you will find the topology side more important.
11:28:57 <monochrom> or rather s/Int/Integer/
11:29:17 <EvanR> (Int,Int) could wrap around a torus
11:29:50 <stalk> hi jedai 
11:29:51 <monochrom> because you will keep asking "what are the colours of my neighbours" all the time when smoothing an image
11:30:43 <EvanR> or what is the integral in a neighborhood around me
11:30:52 <EvanR> which is how smooth-life works
11:31:07 <EvanR> performance isnt bad either
11:31:35 <EvanR> it uses integral of lifeness in a region, and the evolution is an integral over time
11:31:37 <conal> EvanR: nice!
11:32:00 <EvanR> yeah the paper is pretty cool
11:32:07 <hackrilege> I was trying to write a connected darboux frame over a Free []
11:32:24 <conal> continuous time & space ftw
11:33:42 <EvanR> you get life-like gliders, thats surprising, but even more surprising are "oscillators" which seem to be rotating in a stable configuration until something runs into them
11:34:22 <conal> EvanR: references?
11:34:37 <EvanR> https://arxiv.org/abs/1111.1567
11:34:58 <hackrilege> conal, I read about well posedness proofs using smooth particle hydrodynamics, that's what your spactime oriented functions remind me of
11:35:02 <stalk> (smoothlife is awesome)
11:35:03 <conal> EvanR: thx!
11:35:05 <EvanR> https://www.youtube.com/watch?v=KJe9H6qS82I
11:35:20 <pyrtsa> Cool!
11:35:49 <conal> EvanR: lovely!
11:36:02 <monochrom> this is scary
11:36:14 <conal> hackrilege: how about simply newton? 
11:37:27 <EvanR> at 2:16 in that video you can see a stable rotating thing
11:37:37 <conal> i suspect that *continuous* space or time is more controversial to programmers than to scientists & mathies. which is probably an artifact of operational (especial sequential/imperative) thinking.
11:38:25 <EvanR> and at 3:18
11:39:43 <conal> "We shape our tools and afterwards our tools shape us." - Marshall McLuhan
11:40:14 <hpc> when you gaze into the tool, it gazes back or something
11:40:35 <conal> hpc: :)
11:40:40 <conal> "Language etches the grooves through which your thoughts must flow." - Noam Chomsky
11:40:59 <hackrilege> Well in chemistry you have graphs of interacting simplified subunits, continuous is a bit of a leap, it's all balls and springs
11:41:59 <hackrilege> It's more like an Int Map
11:42:30 <EvanR> i took quantum physics, we dont want to ask what chemistry is really doing! (before lunch)
11:42:37 <hackrilege> I was embedding them over Cartesian space for an adaptive nearest neighbor cutoff
11:43:13 <Tuplanolla> I made peace with infinity when I realized continuous things are analogous to infinite collections of discrete things.
11:43:16 <geekosaur> chemistry only obeys that up to a point though. quantum physics tends to become key in organic chemistry...
11:43:59 <hackrilege> But the small scale calculations just tune molecular dynamics interactions
11:44:16 <EvanR> Tuplanolla: no! pointless topology ftw
11:44:20 <pyrtsa> Tuplanolla: Oh, but there's this thing with aleph-0 and aleph-1 though.
11:44:57 <EvanR> infinities bigger than the naturals are silly
11:45:27 <Tuplanolla> Just consider the less infinite the new discrete and repeat the analogy, pyrtsa. Discreetly change the subject if it doesn't work.
11:45:30 <hackrilege> And the idea of pauli exclusion for fermions is an artifact of using a multipole expansion
11:46:06 <pyrtsa> :)
11:48:15 <EvanR> hackrilege... no its a geometric axiom
11:48:27 <EvanR> the antisymmetrization requirement
11:48:48 <Tuplanolla> He's gone, EvanR.
11:50:58 <geekosaur> hackrilege makes about as much sense in the physical sciences as they do in haskell...
11:52:34 <monochrom> conal: That's a more generalized McLuhan quote than his "the TV is the message" :)
11:54:17 <jmnoz> Can anyone recommend me a "good enough" way to (as a beginner) do error handling / exceptions for my command line tool which does a bunch of IO?
11:54:50 <monochrom> yes, we can recommend three ways
11:55:20 <Tuplanolla> By "we" he means monochrom.
11:55:33 <EvanR> polychrom
11:55:44 <EvanR> press B to stop evolution
11:55:55 <monochrom> yes, we are King Monochrom
11:55:55 <niez> hi, I have problems with latest groundhog and groundhog-utils (both from latest git commit), I get: 'Not in scope: type constructor or class ‚ÄòPhantomDb‚Äô' when building groundhog-utils (I'm building with stack using lts-7.10 resolver - which includes ghc-8.0.1), anyone can help?
11:56:32 <lyxia> jmnoz: just return Either String values
11:57:01 <EvanR> you can use IO exceptions
11:57:06 <EvanR> :t throwIO
11:57:07 <lambdabot> Exception e => e -> IO a
11:57:40 <hpc> :t bracket
11:57:43 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:57:58 <hpc> bracket action handler finalizer
11:58:44 <hpc> or something like that
11:59:15 <EvanR> setup handler body teardown
11:59:34 <EvanR> oh theres only 3 args
11:59:41 <hpc> setup handler body, i suppose
11:59:50 <EvanR> no finalizer
11:59:52 <jmnoz> thanks folks. I got confused reading about eitherT, exceptT and so forth
12:00:48 <hpc> jmnoz: you may find yourself writing repetitive exception handling code, and then those types will make all the sense in the world
12:01:19 <jmnoz> hpc: do you have any public code which you can recommend inspecting?
12:01:22 <hpc> but yeah, it takes perspective or just staring at stuff that uses it for a while
12:01:37 <hpc> nothing offhand
12:02:41 <conal> EvanR: in that SmoothLifeL video, it looks like the range (of the function from continuous space/time) is still discrete rather than continuous.
12:04:15 <conal> EvanR: i wonder if it's less pretty & interesting with continuous range values
12:06:09 <EvanR> conal: the field there looks black and white, but it takes values between black and white, grays
12:07:16 <EvanR> there is a smooth transition at the interfaces into saturated regions, and how this ends up working or how thick that region is, id need to go back and reread the paper
12:07:44 <EvanR> the software that you can download for that lets you tweak the rules too
12:07:49 <cocreature> how does criterion decide how often it runs a benchmark? I assume it has some measure of how often a test needs to run depending on the total runtime of the test and the difference between the runs but there is probably some statistical model behind this?
12:08:27 <lyxia> I think it's actually a fixed number
12:08:52 <cocreature> lyxia: oh it is? that‚Äôs way less clever than I thought
12:08:59 * hackagebot sproxy2 1.91.0 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.91.0 (ip1981)
12:09:41 <conal> EvanR: neat. i'd love to see it without the thresholding.
12:10:16 <EvanR> like, bigger dynamic range?
12:10:17 <conal> EvanR: i especially like the few seconds starting at https://youtu.be/KJe9H6qS82I?t=192 
12:11:34 <conal> EvanR: with the grays shown
12:13:03 <EvanR> i think they are shown, but almost all the regions of the picture are saturated
12:14:20 <conal> EvanR: ah.
12:15:01 <EvanR> the boundedness seems to be built into the model
12:16:04 <EvanR> ah you can see gray in the glider image on page 4 of the paper
12:16:24 <Myrl-saki> yay
12:16:37 <cocreature> looks like criterion runs a benchmark for 5 seconds in most cases
12:16:38 <Myrl-saki> taught someone haskell
12:16:42 <cocreature> expect when ‚Äúmore data is needed‚Äù
12:17:51 <EvanR> Myrl-saki: success baby .jpg
12:19:50 <Athas> Are repa array shapes read right-to-left?
12:20:22 <pyrtsa> conal: Hmm, I was left thinking... Would it be a terrible idea if the denotation of `Behavior a` were piecewise constant functions (which they in many implementations end up being)?
12:21:29 <conal> pyrtsa: yes, it would be a terrible idea. most operations don't preserver piecewise constantness. 
12:21:55 <conal> pyrtsa: and in general, it's a terrible idea to drive specifications from implementations rather than the reverse.
12:22:44 <pyrtsa> My thinking is while `Behavior a` wouldn't support most functions, something like `Behavior (Spline a)` could.
12:23:13 <conal> functional/denotative programming is one of the few endeavors in which we can have practicality, elegance, and rigor. let's not abandon those principles in FP as well.
12:23:49 <conal> pyrtsa: same problem, but subtler. most operations don't preserve piecewise-splineness as well.
12:24:16 <EvanR> pyrtsa: an interesting subset of (Time ->) functions is continuous functions
12:24:32 <EvanR> but you need a suitable target type
12:24:37 <conal> pyrtsa: these suggestions sacrifice simplicity *and* expressiveness.
12:24:43 <EvanR> for example, hilbert space ;)
12:25:16 <conal> pyrtsa: do you have a sense of what you're looking for with those ideas?
12:26:18 <pyrtsa> Trying to think of compromises to your push-pull FRP that would allow an efficient implementation.
12:28:15 <conal> pyrtsa: ah. i made a very efficient faithful FRP implementation in 1999. ran hundreds or thousands of frames per second on common PCs.
12:28:27 <conal> pyrtsa: i often hear people claim that something about continuous time leads to inefficiency. my reasoning and experience says exactly the opposite.
12:29:00 * hackagebot amby 0.3.2 - Statistical data visualization  https://hackage.haskell.org/package/amby-0.3.2 (jsermeno)
12:29:04 <tdammers> probably the "nobody has ever done it, so it must be impossible" fallacy
12:29:32 <nshepperd> where are all the faithful frp implementations in haskell?
12:29:35 <pyrtsa> Oh, sorry for missing that. Do you have more comprehensive numbers? Did the performance scale as the number of values grew?
12:29:47 <conal> pyrtsa: as an *implementation* trick, piecewise-simple can be handy. but not in  the specification. the exactness of specification is exactly what allows one to reason about implementation tradeoffs and get the most accuracy for the cost.
12:31:19 <conal> pyrtsa: see http://conal.net/papers/padl99/ for a description of that efficient FRP implementation. denotation-based optimization, continuous time.
12:31:24 <EvanR> conal: now, i think this flies in the face of peoples idea of a specification, its a thing the implementation must follow exactly or you and the implementation go to hell. like web standards, web browsers
12:31:50 <EvanR> if its not exactly faithful to the spec, then its wrong
12:32:15 <conal> piecewise constant is the worst choice one can make without really trying. and sadly, it's the choice that all of these "discrete time" systems make. :(
12:32:35 <conal> EvanR: what's "this"
12:33:03 <EvanR> what you just said, come up with a precise elegant specification, and then perhaps tweak the implementation and made trade offs for practicality later
12:33:06 <conal> worst choice in that it's likely to be the least accurate.
12:33:10 <EvanR> hopefully without sacrificing too much 
12:33:53 <EvanR> the idea that we have some wiggle room with implementation i think is going over everyones head
12:33:54 <pyrtsa> conal: How about piecewise-constantly `Behavior (Time -> a)`?
12:33:56 <EvanR> and mine
12:34:15 <conal> EvanR: got it.
12:34:57 <conal> pyrtsa: that last implementation/representation is what i used in my push-pull frp paper. http://conal.net/papers/push-pull-frp/ . 
12:35:27 <pyrtsa> I know.
12:35:34 <conal> pyrtsa: i used that same trick in TBAG, which was the immediate predecessor to ActiveVRML, which was the first FRP system.
12:36:08 <pyrtsa> I'm trying to understand why it would be a bad idea to allow a function `Behavior a -> Event a` telling when the behavior switches into a new function of time.
12:36:15 <conal> pyrtsa: oh. are you asking something?
12:36:26 <pyrtsa> Now I am. ^
12:36:34 <conal> pyrtsa: are you asking about denotation/specification or implementation?
12:37:39 <pyrtsa> Indeed, denotation. Because if the denotation is `Behavior a` ~ `Time -> a`, then that function can't exist. So the question is why not try a different denotation?
12:38:09 <EvanR> it might be seen as an abstraction leak
12:38:19 <conal> pyrtsa: i guess from your question that you mean specification. if you tried to define that operation rigorously (not implement it), I think you'll soon see why not.
12:39:01 <EvanR> pyrtsa: wouldnt you rather an event that responds to the behavior itself not the details of how its implemented?
12:39:20 <pyrtsa> EvanR: You lost me.
12:39:35 <EvanR> like, an event when a numeric value crosses a certain threshold, upward
12:39:38 <conal> EvanR: exactly. just like we don't want operations that extract the addends that combined for form the number 7.
12:39:52 <pyrtsa> conal: Thank you for the advice. I'm a slow thinker, but I'll try to think it through.
12:40:14 <conal> pyrtsa: you're welcome.
12:41:11 <conal> programmers often think they want mechanisms that come from operational thinking. part of the art of API design is saying "no" at the right times, when it's more helpful for the programmers to change their thinking.
12:41:39 <tdammers> nicely put
12:41:49 <conal> tdammers: :)
12:42:23 <tdammers> now extend the thought to users of your code in general
12:42:27 <tdammers> :)
12:44:42 <pyrtsa> conal: Hmm, so what I'm thinking of push-pull FRP called it `Reactive a`. And `Behavior` was defined as `type Behavior = Reactive . Fun Time`. So in that paper, there indeed exists a function from `Reactive a` to `Event a`, isn't there?
12:45:09 <conal> For instance, the deceptively named "monadic IO" made a comfortable home for imperative thinking & programming in Haskell. Creative inquiry into denotative ("genuinely functional") alternatives slowed down considerably.
12:45:47 <conal> pyrtsa: i think you're mixing specification/denotation with implementation. maybe my paper didn't make that distinction clear enough.
12:46:28 <conal> pyrtsa: ie Reactive . Fun Time is an *implementation* of behaviors, while behaviors keep their simpler denotation/specification.
12:46:28 <pyrtsa> Ah, it's been a while since I read the paper with thought, just skimming through it now.
12:47:46 <conal> some so-called "FRP" systems include the notion of an event that says when a behavior "changes", but they don't really mean "changes". they also report "changing" from 1 to 1.
12:48:14 <conal> which is an abstraction leak.
12:48:36 <pyrtsa> I can think of one (Sodium) and they call it "updates", which isn't that bad, IMO.
12:49:36 <pyrtsa> Yes, it's an abstraction leak, but I fail to see an example where it's severe in any way.
12:50:14 <conal> pyrtsa: depends on whether you care about precise & elegant, implementation-independent specifications and the practical & dependable reasoning that results.
12:50:50 <pyrtsa> Right, elegance is probably the first victim. :/
12:51:12 <conal> pyrtsa: you might get something out of https://github.com/conal/talk-2015-essence-and-origins-of-frp and the other talks linked from there. i tried to explain there why rigor and simplicity matter to me.
12:51:52 <conal> pyrtsa: specifically, the other LambdaJam 2015 talks linked there
12:51:53 <pyrtsa> Thanks, I think I've seen them all. :)
12:52:17 <conal> pyrtsa: okay. then they might not help. :)
12:53:30 <conal> one message there is that approximation composes badly, while exactness/correctness composes well. and that composition is the heart of programming.
12:53:51 <pyrtsa> That's a very good one.
12:54:01 * hackagebot pretty-display 0.1.10 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.10 (jsermeno)
12:54:15 <conal> combine enough heuristics and/or approximations, and the result is not "close enough" or "probably true".
12:54:44 <conal> but compose all the exact and correct you want, and the result is still exact and correct. 
12:55:25 <conal> it's our ambitions and potential that make rigor so important. and our cognitive limitations that make elegance/simplicity important.
12:56:15 <conal> as in Dijkstra's "The Humble Programmer".
12:56:27 <mpickering> Does anyone know why stack recompiles all my deps when I turn off profiling flags?
12:57:01 <tdammers> most people are pretty quick with settling for "close enough"; meanwhile, some keep asking "why settle for good enough when I can get perfect"
12:57:09 <hvr> mpickering: you're the 2nd one to mention that limitation of stack
12:57:23 <hinaciaj> hello guys
12:57:57 <EvanR> pyrtsa: reacting to updates that dont change anything could be anything from harmless, to inefficient, to incorrect. imagine a reaction automatically sends an email
12:58:00 <tdammers> mpickering: I can only guess, but I'd think it's because it sees you've changed the compiler flags and so everything needs to be rebuilt
12:58:13 <mpickering> But I built the project before with these flags
12:58:27 <hinaciaj> Humm
12:58:30 <mpickering> I thought it cached build products?
12:58:50 <pyrtsa> EvanR: Right, but those updates don't happen spontaneously; there's still a push somewhere that triggers it.
12:58:54 <conal> tdammers: yep. i wonder if the "close enough" folks don't plan on composing or don't realize that composition does not preserve "close enough" or what.
12:59:09 <EvanR> pyrtsa: not necessarily, imo
12:59:14 <tdammers> conal: I think they just don't realize the fundamental benefits of perfection
12:59:19 <pyrtsa> EvanR: Example?
12:59:20 <conal> and a funny thing is that without being rigorous about the exact right answer, we can't know whether some implementation is really close enough.
12:59:37 <hvr> tdammers: it may be surprising to ppl used to cabal new-build, which handles caching better when switching between profiling <-> non-profiling builds
12:59:43 <EvanR> pyrtsa: i specifically do see spontaneous as important to interactive programs
12:59:46 <conal> tdammers: could be, though i'm suggesting that close enough really isn't, and they just don't know it yet.
13:00:05 <EvanR> pyrtsa: but thats really not related to what you were talking about
13:00:06 <tdammers> conal: "close enough" is temporary and situational
13:00:12 <hinaciaj> lol
13:00:41 <hvr> mpickering: https://github.com/commercialhaskell/stack/issues/2684
13:01:09 <pyrtsa> EvanR: Guess so. Anyway, thank you for your time! conal too! Gotta go.
13:01:09 <conal> tdammers: perhaps so. but even then, i bet the claim is often a wild guess or bluff. one could ask "oh? close enough to what? and how do you know?"
13:01:19 <koz_> byorgey: Just wondering about the changes to MonadRandom - will you release a new version on Hackage with those applied soon?
13:01:25 <conal> pyrtsa: take care!
13:01:35 <pyrtsa> You too!
13:01:48 <tdammers> conal: definitely. although such questions will often get you nothing but blank stares
13:01:53 <mpickering> hvr: thanks
13:02:39 <byorgey> koz_: yes, it's on my list. I'm still working on incorporating more changes.
13:03:38 <EvanR> conal: so are you serious about loosely following specifications? or do we require at least some verifiable margin of error for the implementation
13:04:01 * hackagebot libmolude 0.12.3 - Prelude based on protolude for GHC 8 and beyond.  https://hackage.haskell.org/package/libmolude-0.12.3 (misandrist)
13:04:07 <EvanR> that could be non zero
13:04:42 <tdammers> hmm, is writing your own prelude a rite of passing now?
13:05:16 <hvr> tdammers: writing a new prelude is is what writing a  monad-tutorial was a few years ago
13:05:47 <ertesx> hvr: what are you saying?  we can write monad tutorials now?
13:06:21 <hvr> ertesx: if you feel like it... :-)
13:06:22 <hpc> soon it'll be lens tutorials
13:06:33 <johnw> One's ability to write a monad tutorial is complete, if they can write a tutorial on writing monad tutorials, that by the end is just a monad tutorial.
13:06:37 <conal> EvanR: i'm interested in two variations: one is a question of how far (via a well-defined metric) an implementation comes from an well-specified ideal. another is to give an exact specification implying infinite computation, but carefully design the API so that questions can be answered in finite time (unless genuinely bottom). lazy functional programming is full of the latter, using infinite representations. exact real computation is a special case.
13:06:39 <ertesx> i was waiting for that to happen!
13:06:45 <ertesx> i have the perfect metaphor for monads!
13:06:47 <tdammers> maybe it means you should write a new slightly different monad tutorial for every project
13:07:19 <ertesx> johnw: so monad tutorials form a monad themselves?
13:07:29 <johnw> the Tutorial monad, sure!
13:07:29 <ertesx> or is every individual monad tutorial a monad?
13:07:53 <ertesx> or perhaps every tutorial monad is an individual?
13:08:12 <ertesx> or every individual monad monad is a tutorial
13:08:12 <tdammers> you can also use the Free Tutorial to write a tutorial without worrying what it's about; you can plug in any subject you like later
13:08:27 <EvanR> conal: er, the specification is something besides the API ?
13:08:37 <ertesx> haha
13:08:54 <conal> EvanR: the first variation can be trickier. for instance, if you compare two almost-accurate approximations for equality, the resulting boolean can easily be *entirely* inaccurate.
13:09:24 <conal> EvanR: the specification is, for instance, a (precise) denotation for the API (types & operations).
13:09:39 <ertesx> to be or not to be, that is the Maybe monad
13:10:01 <ertesx> (, that is the list monad) (not to be or to be and (not to be or to be and (not to be or to be and (not to be or to be and ‚Ä¶
13:10:18 <EvanR> conal: and so you mean, the answers you get in finite time are exactly right ?
13:10:52 <hpc> ertesx: clearly what the world needs is something using Data and Typeable that translates data types to shakespeare
13:11:11 <conal> EvanR: yes. the promise is that i (the API designer & implementor) will correctly answer every question you can ask.
13:11:22 <ertesx> hpc: i prefer lucid or blaze
13:11:27 <hpc> haha
13:13:23 <EvanR> sounds good to me
13:13:27 <EvanR> ship it ;)
13:14:09 <Nolaan[m]> Posted a File: https://matrix.org/_matrix/media/v1/download/matrix.org/ScsYVSzUlReDPyntxoYwoOtU - VectorBugReport-1480194827179-Nolaan_matrix.org.zip (37KB)
13:14:32 <EvanR> its a trap
13:14:35 <Nolaan[m]> Sry mistyped
13:14:46 <conal> i'm working on it! :) i'm having a great time at Target. my management is astonishingly supportive (even enthusiastic) about elegance & rigor.
13:15:29 <EvanR> Target?
13:16:14 <conal> EvanR: yeah. i joined in June.
13:16:44 <EvanR> the retail box store?
13:17:09 <hpc> believe it or not, target consists of more than just cashiers and baggers
13:17:12 <conal> EvanR: yeah. surprised me, too! 
13:17:14 <hpc> (conal stocks shelves)
13:17:39 <conal> hpc: even better than my job at winchell's donuts, but i was 15 or so at the time.
13:17:42 <EvanR> ive heard some horror stories about the front end management policies, but i guess that has nothing to do with your job
13:18:54 <conal> EvanR: i haven't heard those stories. from what i've seen, they appear to be a fairly humane, caring company (as companies go).
13:19:19 <hpc> not hard when your competition is walmart ;)
13:19:27 <tdammers> EvanR: I believe most of retail is structured such that you have coporate HQ, which works more or less like a normal reasonable office place, and individual stores, where it's down to local management, more or less
13:19:51 <hpc> what hard problems does target have that only the great conal can solve, anyway?
13:20:07 <EvanR> they want to upgrade to selling an infinite amount of items in finite time
13:20:24 <fluffy0x> target is good at targetting people to spend the $ :)
13:20:45 <systemfault> We had Target in Canada for about a year :?
13:21:43 <conal> hpc: we'll see ;)
13:21:59 <systemfault> I would kill (...not really) for nice Haskell job where I live... 
13:22:24 <EvanR> i might go for a terrible haskell job
13:22:49 <hpc> it'd be nice if shops weren't dominated by single languages so it was more feasible to find a good job and convert it
13:23:01 <systemfault> A terrible Haskell job could still be more fulfilling than a good PHP/Java job..
13:23:10 <EvanR> i wouldnt doubt it
13:23:26 <hodapp> I was at a terrible Haskell job, sort of
13:24:02 * hackagebot stratosphere 0.2.2 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.2.2 (jdreaver)
13:24:14 <conal> lunch time for me. afk for a while.
13:24:41 <osfameron> I think that's probably nonsense.  A job where you have a good team and a sane management structure will make up for poor technical choices much more than the other way around
13:26:32 <hpc> it depends on how bad the language is, and how fixable the bad management is
13:26:59 <hpc> or how fixable the bad development around the language is
13:27:52 <osfameron> "terrible" implies non-fixable
13:32:43 <ertesx> well‚Ä¶  would you do a $2000/month haskell job over a $10000/month PHP job?  be honest ;)
13:33:12 <hpc> shit for 10k a month i would write excel
13:33:44 <hpc> ... maybe for 15k
13:33:54 <ertesx> love for tools can only go so far =)
13:34:24 <systemfault> A dilemma like that is unlikely though...
13:34:33 <osfameron> ertesx: oh, I hadn't even thought about "terrible" meaning "badly paid"... but yeah, I guess that's a factor too -)
13:34:36 <osfameron> ;-) even
13:35:49 <medaz_23421> what this channel about ??
13:36:00 <osfameron> my current considered opinion is:  sanity/environment  >  pay  > tech
13:36:18 <systemfault> The Haskell Programming Language.
13:36:53 <systemfault> I wouldn't mind being paid a little less if I could use Haskell..
13:37:17 <ertesx> yeah, a little less to keep your sanity
13:37:25 <ertesx> but not a lot
13:37:35 <systemfault> A little doesn't mean $2k vs $10k
13:37:59 <systemfault> But I would personally take $8k instead of $10k to work with Haskell
13:38:07 <systemfault> At least for a year.
13:38:30 <osfameron> yeah, that seems like a valid tradeoff if it works for you
13:38:46 <medaz_23421> Oh i see , what different between it and other languges
13:39:22 <lordcirth> medaz_23421, lots XD
13:39:37 * osfameron doesn't understand people who turn up on random irc channels expecting everyone to just stop what they're doing to talk to them :-(
13:39:37 <lordcirth> medaz_23421, http://learnyouahaskell.com/introduction#about-this-tutorial
13:40:07 <medaz_23421> is it public ?
13:40:13 <medaz_23421> can i learn it ?
13:40:28 <lordcirth> medaz_23421, seeing as I just linked you a tutorial, yes, and yes
13:40:43 <medaz_23421> thankx
13:41:08 <medaz_23421> you're good poeple
13:42:37 <ertesx> osfameron: i don't mind it‚Ä¶  i think IRC browsing is a thing =)
13:42:40 <medaz_23421> i go to other channel before , when i ask no one respond and if they respond they swearing on me
13:42:55 <monochrom> Learn You a Haskell is not going to be enough. You will need https://github.com/bitemyapp/learnhaskell and more
13:43:36 <monochrom> Learn You a Haskell is like a movie preview except it's as long as a movie.
13:43:46 <systemfault> medaz_23421: Depends on the channel...
13:43:49 <geekosaur> LYaH is good at teaching how to read Haskell source. but doesn't do anything to help you write it...
13:44:10 <systemfault> geekosaur: I couldn't have said it better.
13:44:42 <nitrix> I like the movie preview analogy.
13:44:55 <medaz_23421> thaank you all
13:46:26 <osfameron> ertesx: yeah, but do people not know how to a) google b) read the /topic or c) lurk? ;-P
13:48:48 <monochrom> osfameron: I have nothing to do, so there is no "stop what I'm doing to talk"
13:49:17 <ertesx> osfameron: refutations: a) https://lmgtfy.com/, b) medaz_23421, c) medaz_23421
13:50:03 <osfameron> good points both :D
13:51:01 <ertesx> those are even constructive refutations, so there is really nothing else you could have said =P
15:57:03 <grazie> no results from hoogle on this: hoogle >>=
15:57:42 <grazie> ok, on the online version (but not my local version) it gives a result: (>>=) :: Monad m => m a -> (a -> m b) -> m b  
15:57:43 <Lokathor> try (>>=) maybe
15:58:10 <Lokathor> yeah, symbol functions have to have () around them when you name them prefix style
15:58:19 <grazie> actually only this worked hoogle ">>="
15:58:35 <Lokathor> hmmm
15:58:51 <EvanR> @hoogle (>>=)
15:58:53 <lambdabot> Prelude (>>=) :: forall a b . Monad m => m a -> (a -> m b) -> m b
15:58:53 <lambdabot> Control.Monad (>>=) :: forall a b . Monad m => m a -> (a -> m b) -> m b
15:58:53 <lambdabot> Control.Monad.Instances (>>=) :: forall a b . Monad m => m a -> (a -> m b) -> m b
15:59:06 <MarcelineVQ> hoogle "(>>=)" should also work
15:59:13 <MarcelineVQ> they're using cli Lokathor
15:59:52 <Lokathor> oh i see, yes the terminal itself will also eat a lot of symbol characters up if you don't use double quotes
16:00:13 <geekosaur> you need to quote from the shell because shells (including cmd.exe) use < and > to mean things alreadt
16:00:26 <geekosaur> specifically, file redirection
16:00:28 <lordcirth> Yes, escaping is important
16:02:19 <Lokathor> bash eats up parens as well, (cargo) is the same as cargo
16:02:34 <Lokathor> it wants to do subexpressions and stuff
16:06:56 <grazie> thank you
16:07:57 <MarcelineVQ> you can call hoogle from ghci if you like as well https://wiki.haskell.org/Hoogle#GHCi_Integration
16:22:01 <ertesx> hoogle a `shutdown` b -> b `shutdown` a
16:32:23 <Berra1> Anyone know of some good example code using ValidationT ?
16:38:52 <lyxia> Berra1: it's the same as ExceptT
16:47:48 <Berra1> lyxia: That doesn't help me but thanks
17:01:50 <ertesx> Berra1: ExceptT is basically a transformer variant of Either, so you use it whenever you want exception handling
17:02:25 <ertesx> Berra1: look at the MonadError class in https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
17:04:10 <ertesx> Berra1: YMMV, but to many people it's not that useful in general, because for the most part it's redundant‚Ä¶  i think most people rarely use a transformer stack that doesn't have IO at the bottom, and when it's not IO, you can probably just have Either at the bottom
17:04:24 * hackagebot fold-debounce 0.2.0.4 - Fold multiple events that happen in a given period of time.  https://hackage.haskell.org/package/fold-debounce-0.2.0.4 (debugito)
17:04:43 <lyxia> Berra1: https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
17:07:24 <Berra1> ertesx: lyxia Thanks. Reading
17:09:24 * hackagebot wikicfp-scraper 0.1.0.6 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.6 (debugito)
17:15:34 <mnoronha> Does anyone have any suggestions for a good "practical" learning project?
17:15:59 <mnoronha> I've more or less finished learn you a haskell, and will work through real world haskell
17:16:14 <maerwald> weird choice of learning material
17:16:20 <maerwald> both are outdated
17:17:02 <xocolatl> mnoronha: there is no up-to-date documentation or tutorials about haskell
17:17:10 <maerwald> and since lyah has exactly zero exercises, I suggest you try something with exercises
17:17:12 <xocolatl> mnoronha: the only way to learn is in a classroom or on the job
17:17:19 <maerwald> wat?
17:17:23 <maerwald> no
17:17:26 <mnoronha> xocolatl, Oh, i'm learning in the classroom as well
17:18:39 <lpaste> xcmw pasted ‚ÄúNo title‚Äù at http://lpaste.net/346672
17:19:12 <mnoronha> maerwald, What material would your recommend? Also, I've not noticed much out-of-date from lyah, though I haven't looked to closely at all of it
17:19:39 <maerwald> @where learnhaskell
17:19:39 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:19:45 <xcmw> Why isn't k = TK3 in http://lpaste.net/346672?
17:19:55 <maerwald> that's free material, there's some non-free as well, but I don't know how good it is (since it's non-free)
17:24:25 * hackagebot wild-bind-x11 0.1.0.3 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.1.0.3 (debugito)
17:32:43 <roboguy`> xcmw: did you try giving r a type signature?
17:34:16 <xcmw> roboguy`: Yes
17:34:56 <xcmw> roboguy: Same problem
17:37:29 <roboguy`> xcmw: did you try eta-expanding r?
17:37:35 <roboguy`> (with a type signature)
17:38:08 <xcmw> roboguy`: What do you mean by eta-expanding?
17:38:25 <roboguy`> xcmw: r is a function. Explicitly naming and using the argument
17:39:49 <xcmw> roboguy`: Same error
17:40:43 <xcmw> When I replace k with TK3 in the type signature of SetY it works.
17:42:41 <xcmw> roboguy`: My guess if ghc is just mad that TK3 is a type family
17:44:16 <roboguy`> xcmw: what version of GHC are you using? I get another error as well
17:45:38 <xcmw> roboguy`: 8
17:45:48 <roboguy`> hmm, me too
17:54:18 <xcmw> Do you think it is a bug in ghc?
18:05:16 <shapr> how do I make a functor instance for this? newtype TestAction a = TestAction{runTest:: TestEnv -> IO (a, TestEnv)}
18:09:51 <ski>   instance Functor TestAction
18:09:54 <ski>     where
18:09:55 <ski>     fmap f (TestAction test) = TestAction (liftM (\(a,tenv) -> (f a,tenv)) . test)
18:11:16 <ski>     fmap f (TestAction test) = TestAction ((runStateT . fmap f . StateT) test)  -- or this
18:11:24 <shapr> ski: ah, thanks!
18:11:43 <ski>     fmap f = TestAction . runStateT . fmap f . StateT . runTest  -- this is the same thing, perhaps it looks nicer (?)
18:11:55 <shapr> I like the explicit form you wrote first.
18:13:16 <ski> one alternative would be to have `newtype TestAction a = TestAction {runTest :: StateT TestEnv IO a}', then you could just add `deriving Functor', if you have `GeneralizedNewtypeDeriving' enabled
18:13:33 <shapr> oh, I'll try that in the future, thanks!
18:13:45 <ski> np :)
18:15:10 <ski> one possibility then, would be to rename `runTest' to perhaps `unTest', and define `runTest = runStateT . unTest'
18:21:25 <shapr> ski: to unwind that, it must be wrapped in TestAction because that's the record, and liftM wraps the result in IO, and the rest is just applying f to the fst part of the tuple, yes?
18:25:53 <ski> shapr : aye
18:28:55 <danilo2> Hello guys! Is GHC smart enough to optimize in general something like data Lst (ls :: [*]) where El :: l -> Lst ls -> Lst (l ': ls); Nil :: Lst '[]  the same way as just tuple ?
18:28:56 <ski> (now that `Functor' is a superclass of `Monad', some would perhaps prefer to use `fmap' instead of `liftM' (it would have worked before that change as well, in specific cases like this, but not in polymorphic cases). a possible argument for not doing that is to try to use the most specific operation, in order to attempt to help the reader. a style/taste issue, probably doesn't make a big difference here)
18:29:48 <ski> danilo2 : i'd doubt it
18:44:17 <ottanta> hi! I'm trying to learn haskell, and I'm trying to code a function that returns the average value of a list, the signature I tried to use was listMean :: [Num a] -> Double, but I get an error like Expected kind ‚Äò*‚Äô, but ‚ÄòNum a‚Äô has kind ‚ÄòConstraint‚Äô
18:44:36 <ski> danilo2 : .. in particular cases, where `Lst' is applied to a list of known length, then perhaps. but probably not in polymorphic cases like `foo :: forall ls. Blah ls => Lst (Bool ': ls) -> ..ls..'
18:45:27 <ski> ottanta : yes, `Num' isn't a type, it's a "type class", a property shared by all "numeric" types (meaning they have to support `+',`-',`*', and a few more operations)
18:46:09 <ottanta> yeah ski I thought that meant that if I made a function that takes a member of that typeclass, that + would be supported? like
18:46:15 <ski> ottanta : either pick a specific type, like `Double' or `Rational', perhaps `listMean :: [Rational] -> Double'
18:46:16 <ottanta> ski: I'm trying to make my function as generic as possible
18:46:32 <danilo2> ski: Hmm why forall could break it? I' masking out of curiosity right now, cause in my code `ls` is always known, but hmmm, forall ls. should not make any difference cause it would be resolved earlier or later
18:46:37 <ski> ottanta : or write it like `listMean :: Num a => [a] -> Double'
18:46:38 <ottanta> I can't say that it accepts a generic type from a class?
18:46:41 <ottanta> OHH
18:46:45 <ottanta> ski: THANK YOU
18:47:28 <ski> ottanta : the `Num a' is a constraint, without it this `listMean' would have to work for *any* type at all that you can replace the type variable `a' with. with the constraint, it only has to work for types in the type class `Num'
18:47:46 <ski> (`=>' separates the constraint(s) from the type, proper, in the type signature of `listMean')
18:48:03 <ski> ottanta : however, consider
18:48:10 <ski> @type (+)
18:48:12 <lambdabot> Num a => a -> a -> a
18:48:12 <ski> @type (/)
18:48:14 <lambdabot> Fractional a => a -> a -> a
18:48:38 <xcmw> Why isn't k = TK3 in http://lpaste.net/346672?
18:48:44 <ottanta> ski: ooh
18:48:55 <qmm> is https://wiki.haskell.org/Generics not referring to generic classes? i'm guessing https://downloads.haskell.org/~ghc/7.0.4/docs/html/users_guide/generic-classes.html and the paper mentioned there are the best sources for learning about generic classes?
18:49:00 <ottanta> I didn't really put together that => separates the constraints from the types, thanks ski 
18:49:27 <ski> ottanta : so, if you want to do division (exact, or as near as it gets, in case of floating-point .. as opposed to *integral* division (`div'), which truncates away the remainder (`mod')), then perhaps you'd like to have instead `listMean :: Fractional a => [a] -> a'
18:49:46 <ottanta> ski: fractional implies num?
18:49:55 <ski> in that case, if you have a list of `Integer's, then you'd need to convert it to a list of, say, `Double's, before being able to apply `listMean' to it
18:49:59 <ski> ottanta : right
18:52:01 <ski> danilo2 : well, separate compilation, `ls' might not be picked (decided upon) in the module which defines `foo'. even worse, it might not be picked until run-time. do you expect `foo' to get a custom, type-specialized, version generated at run-time (RTCG, Run-Time Code-Generation. in this case specialization) ?
18:52:33 <ski> danilo2 : it's something one could perhaps imagine, but i think it's relatively advanced, and i doubt GHC implements it
18:54:13 <danilo2> ski: hmm, Im using it this way that `ls` is either always known or used as a variable in functions that are set to be inlined. However I understand that it could be "too advanced" for the current state of the optimizations possibilities.
18:54:50 <ski> danilo2 : an alternative would be to have type-passing (as opposed to type-erasure), where corresponding to `forall ls.', some information about the layout of stuff related to `ls' would be picked at run-time. i'm not sure if that would work in this case in particular, though (it would work for operations polymorphic over unboxed types, e.g. used in lists of those types)
18:55:33 <ski> danilo2 : perhaps something is done in the case of fully (statically) known. maybe you could ask #ghc
18:56:18 <danilo2> ski: I just did it. I'll make some tests later and inspect generated core. I'm very interested what can be done here
19:00:29 <ski> xcmw : have you tried adding a type signature on `r' ?
19:12:41 <ottanta> oh god it's exploded
19:12:48 <ottanta> I'm getting so many errors
19:22:01 <xcmw> xcmw: Yes
19:22:14 <xcmw> ski: Yes
19:23:13 <xcmw> ski: Same error
19:26:38 <Berra1> Could someone take a quick peek and point out if there's something really odd about this implementation: http://lpaste.net/4281242697940860928
19:29:30 <ottanta> how do I use hoogle to search for a function by its type signature?
19:29:56 <ottanta> I want something like Fractional a => a -> Double 
19:31:19 <clmg> How would one do some sort of boolean fold? (x -> a -> a -> x) -> [a] -> x?
19:31:42 <clmg> I want to make sure each element in a list is greater than the previous: [1,2,3] -> True
19:31:51 <clmg> but [1,3,2] -> False
19:32:02 <jle`> clmg: zipWith _ xs (tail xs)
19:32:07 <jle`> or zipWith _ xs (drop 1 xs)
19:32:34 <jle`> ottanta: does `Fractional a => a -> Double` not return anyhting useful?
19:32:52 <clmg> jle`: awesome
19:33:05 <jle`> > zipWith (<) [1,2,3] (drop 1 [1,2,3])
19:33:08 <lambdabot>  [True,True]
19:33:18 <jle`> > and $ zipWith (<) [1,2,3] (drop 1 [1,2,3])
19:33:21 <lambdabot>  True
19:33:25 <clmg> makes sense. ugh how do you learn these patterns!
19:33:48 <jle`> honestly i saw this one form lurking on #haskell a lot haha
19:34:01 <jle`> but it's actually a common type of thing that happens a lot
19:34:14 <jle`> you pic up things like this after a while/with experience, heh
19:34:39 <wespiser> is anyone using hakyll with nginx to serve? I'm trying to host my blog w/ support for https
19:35:00 <jle`> doesn't hakyll just generate the html files?
19:35:07 <wespiser> affirm
19:35:08 <jle`> should be the same with or without https
19:35:14 <wespiser> affirm
19:35:23 <wespiser> that's the plan, I was just seeing if there was a guide
19:35:35 <wespiser> I'm back end/data scientist
19:35:40 <jle`> ah.  well, it'd probably be the same as a nginx guide on https for static web pages
19:35:49 <wespiser> roger, that's the plan
19:35:52 <jle`> my blog is hakyll but i just put it on github pages
19:36:00 <jle`> and then point a domain to it
19:36:08 <wespiser> this: https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04
19:36:15 <jle`> and then use amazon's CDN to provide https
19:36:28 <wespiser> ohh, not bad
19:36:45 <jle`> yeah, since it's a static website, github pages just hosts the static pages
19:37:16 <Shockk> jle`: that's basically what I do
19:37:19 <wespiser> and you use your website to organize the articles
19:37:31 <Shockk> except I use jekyll because of github pages auto deploying it
19:38:11 <jle`> yeah, hakyll can create/dump whatever html files youwant it to, and you can just push it to github
19:38:21 <jle`> i forgot how much amazon's CDN costs
19:38:28 <Shockk> it's pretty cheap
19:38:36 <jle`> yeah i hardly notice it on my bills
19:38:43 <Shockk> it's charged per access, and I did calculates a little while ago
19:38:50 <Shockk> a million hits per months is ridiculously cheap
19:38:54 <hodapp> One may also set up Travis CI to automatically generate HTML and push to GitHub
19:39:13 <hodapp> via Hakyll that is
19:39:15 <wespiser> I"m running GCE, and its about the same
19:39:23 <wespiser> tiny amount per page
19:39:23 <jle`> yeah, i hear people do that.  i just have a simple haskell deploy script i run locally
19:39:50 <hodapp> wespiser: what are you using GCE for?
19:39:54 <wespiser> "let's encrypt" is giving out free certs
19:40:09 <wespiser> for a server instance
19:40:22 <wespiser> to host my hakyll/nginx
19:40:26 <wespiser> wespiser.com
19:40:45 <hodapp> wespiser: is it basically a VPS?
19:40:56 <jle`> so yeah my last month's amazon cdn bill was about 30 cents
19:41:12 <wespiser> VPS stands for?
19:41:18 <hodapp> virtual private server
19:41:23 <wespiser> yes, exactly
19:41:40 <jle`> oh, 40 cents
19:41:48 <hodapp> but you pay 'per page'? do you also pay just to have the instance?
19:41:51 <Shockk> for my other website I'm actually hosting the files in amazon s3
19:41:54 <jle`> i'm not sure if i'm admitting that my blog barely gets any viewers or if i'm proving that it's cheap
19:42:00 <wespiser> i build haskell stuff on it, its my preferred dev environment to my laptop, i find it easier to collaborate when I develop on a VPS
19:42:00 <Shockk> as reduced redundancy
19:42:13 <wespiser> i pay for the cycles + outgoing data
19:42:39 <Shockk> and then I've got the domain managed by route 53 and then it's all sitting behind cloudfront 
19:42:40 <wespiser> I'm sure there is a better way to do it via google
19:42:52 <hodapp> jle`: do you have a similar arrangement on Amazon?
19:42:56 <hodapp> EC2 or something?
19:43:26 <jle`> a few years ago i invested in building a server that i physically co-locate with
19:43:45 <jle`> and run the ssh through my home router, so i do that for all my dev/storage stuff
19:44:37 <Shockk> I wonder if it's possible to have an amazon lambda be triggered on a repository push, and then rebuild the site and deploy to s3
19:44:47 <mrkgnao> jle`: I was reading your posts on Huffman. your blog is really great :D
19:45:01 <wespiser> probably, I think amazon firebase can have code-based triggers
19:45:06 <jle`> thanks :)
19:45:20 <wespiser> jle`: what is your blog?
19:45:27 <jle`> http://blog.jle.im
19:45:27 <wespiser> *URL?
19:45:30 <wespiser> thanks!
19:45:30 <jle`> haven't posted in a while though
19:45:33 <jle`> no problem!
19:45:35 <wespiser> np
19:46:04 <jle`> probably relavant to the discussion is the github repo w/ github pages that it's hosted off of - https://github.com/mstksg/inCode
19:46:14 <jle`> so yeah hakyll just builds everything and i push to the gh-pages branch
19:46:21 <wespiser> nice, there's a great computational/structural biology program at your uni
19:46:28 <wespiser> one of the worlds greatest
19:46:35 <jle`> i have a build script that builds the purescript/front-end javascript as well as the hakyll html
19:46:44 <jle`> oh wait no i lied, hakyll builds the purescript too i think
19:47:08 <jle`> wespiser: are you talking about UCSD, or Chapman? :o
19:47:20 <wespiser> UCSD, I'm pretty sure :)
19:47:34 <wespiser> its been a while since i left the field for industry, though
19:49:02 <nitrix> jle`: I'm a proponent of your https://blog.jle.im/entry/io-monad-considered-harmful.html
19:59:08 <grantwu> What is the bit size of Int on x86-64?
20:04:29 <nitrix> > finiteBitSize (0 :: Int)
20:04:31 <lambdabot>  64
20:17:46 <jle`> nitrix: thanks for appreciating my most clickbait post :)
20:18:49 <grantwu> oh
20:19:10 <grantwu> nitrix: Where is finiteBitSize defined?
20:19:23 <grantwu> Not showing up on hoogle...
20:19:30 <grantwu> @src finiteBitSize
20:19:30 <lambdabot> Source not found. Whoa.
20:20:06 <nitrix> instance FiniteBits Int where finiteBitSize _ = WORD_SIZE_IN_BITS
20:20:44 <jle`> grantwu: http://hoogle.haskell.org/?hoogle=finiteBitSize&scope=set%3Astackage
20:21:03 <jle`> fyi the official hoogle on http://haskell.org/hoogle is out of date by several years
20:21:07 <jle`> ok not several years maybe just a few
20:23:26 <jle`> updates to the hoogle index have been suspended in preparation for the official hoogle 5 release, but the hoogle 5 release has been stalled for a few years now
20:24:21 <jle`> in the meanwhile hoogle.haskell.org runs an up-to-date index on a pre-release version of hoogle 5 i think
20:24:32 * hackagebot line 1.0.0.0 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-1.0.0.0 (noraesae)
20:30:41 <kahnpro> wait, what? so that's why the official Hoogle doesn't know about Servant
20:32:30 <nitrix> Curiously, why don't we update or replace it?
20:33:10 <nitrix> Is it hard to be hayoo behind haskell.org' ?
20:33:16 <nitrix> s/be/put/
20:54:33 * hackagebot line 1.0.0.1 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-1.0.0.1 (noraesae)
21:09:05 <xcmw> Does haskell have a type level case statement?
21:09:24 <xcmw> like \case
21:11:06 <johnw> no, the closest you can get (if I understand what you want to do) is to use a type family
21:14:12 <lpaste> xcmw revised ‚ÄúNo title‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/346746
21:14:36 <xcmw> Do you know why that errors?
21:21:47 <geekosaur> the fact that it invented a new type variable means it thinks that k can't unify with the original one
21:22:55 <geekosaur> but you didn't forall it inside the parentheses, so it has no grounds to assume that. you may have a compiler bug where the t is somehow "tainting" the k
21:23:18 <geekosaur> the rest of the error message might possibly help figure out where it's getting confused
21:23:41 <danilo2> Hello guys! Is there any trich / magic to make everything Typeable and just throw away the Typeable constraint? I need even some unsafe way cause it wil be guaranteed
21:24:35 <geekosaur> there could be, but as far as I know there is no way to expose it. (every type *is* Typeable, because the compiler uses it internally)
21:25:56 <geekosaur> ...but, come to think of it, that may not reflect into the actual program, it may only exist while compiling unless there is an explicit Typeable request. in that case you would need something that tweaks the compiler itself
21:26:31 <EvanR> i think everything is Typeable, but you still need the constraint when you want to exploit the fact
21:26:33 <geekosaur> (actually that is not fully true, it needs the Typeable constraint at runtime for certain things even if it is not declared. but that may only actually happen for the things where it does need it)
21:26:39 <danilo2> geekosaur: I saw a ticket: https://ghc.haskell.org/trac/ghc/wiki/Typeable
21:26:49 <danilo2> geekosaur: which will make everything typeable in ghc 8.2
21:26:52 <EvanR> that is how it knows to pass the dictionary around
21:26:57 <danilo2> thats interesting
21:26:59 <xcmw> geekosaur: Should I file a ghc bug report?
21:27:38 <EvanR> adding implicit support to access runtime type information for literally everything would be insane
21:27:43 <geekosaur> xcmw, you might ask in #ghc first
21:27:53 <EvanR> i wouldnt be surprised if it broke laws
21:27:55 <geekosaur> although at this current time I don't know if anyone will be around
21:28:00 <xcmw> geekosaur: Ok
21:28:31 <geekosaur> EvanR, I can see reasons why it might be needed though
21:28:49 <danilo2> EvanR: i dont see a point wy it'd be insane
21:28:57 <EvanR> im talking about being able to write typeOf x without putting the constraint
21:29:10 <danilo2> EvanR: why?
21:29:27 <EvanR> so a function of type forall a . a -> a becomes "theres only one thing you can do" -> "you can do anything, like java"
21:29:54 <EvanR> a value of type forall a . a cant do anything, except give you access to a magic "Object" like suite of functions
21:29:57 <geekosaur> given that it's used to ensure type safety in various contexts related to other typeclasses, and it can't know at compile time if some other future module will get access to a type that it might need the hash in the Typeable dictionary to safely distinguish
21:30:43 <EvanR> isnt that why you have to have the constraint?
21:31:47 <geekosaur> I don't think you currently have to derive Typeable for anything that has a non-default type role, which iirc is one of the cases where it needs Typeable behind the covers
21:32:20 <EvanR> that makes sense, and is convenient. i like to not have to derive Show either
21:33:07 <EvanR> but if you cant tell from the type that something is exploiting Typeable, that is the sad land of PHP or ruby
21:33:48 <geekosaur> well. requiring everything to have a Typeable dictionary at runtime /= allowing arbitrary code to access it
21:33:57 <EvanR> right
21:34:17 <geekosaur> and the ticket is for the former, whereas danilo2 wants the latter
21:34:24 <EvanR> right
21:34:34 * hackagebot hamilton 0.1.0.0 - Physics on generalized coordinate systems using Hamiltonian Mechanics and AD  https://hackage.haskell.org/package/hamilton-0.1.0.0 (jle)
21:34:35 <geekosaur> I would suspect that the devs would be hesitant to allow that exposure
21:34:52 <geekosaur> even if it's technically simple
21:34:55 <glguy> xcmw: What type were you hoping to instantiate 'k' to in your definition of 'r'?
21:35:12 <danilo2> EvanR, geekosaur : yep, that makes sense
21:35:19 <EvanR> what i was calling insane was, to implement danilo2's suggestion, the module would need to be compiled with typeable dictionaries for everything in every function just in case
21:35:26 <geekosaur> glguy, the error is triggered by a use that instantiates it at TK3
21:35:32 <geekosaur> (line 47)
21:35:34 <EvanR> which seems like a performance drain
21:35:37 <glguy> Tk3 isn't an option
21:35:42 <EvanR> its the opposite of type erasure
21:36:50 <geekosaur> btw ezyang already looked at it and agreed that it looks like a compiler bug
21:37:04 <geekosaur> from what I see, only t is forall-d, k should be unified
21:37:05 <danilo2> hmm, EvanR, geekosaur, ok so another way around: is there any way in GHC to tell: forall a. if a is Typeable then Uni a is also Typeable, where Uni is a type family. I suspect no, because it will require foralls in context which is not yet allowed
21:37:20 <glguy> you can't unify k with TK3, TK3 is a type family expecting to be applied to some other type
21:37:20 <geekosaur> but it's not unifying them as demonstrated by the k0 reference
21:38:18 <glguy> so TK3 isn't a valid unification for k
21:39:14 <geekosaur> hm. not clear with TypeInType collapsing kind and type level together (Y is a promoted kind)
21:39:23 <EvanR> danilo2: but Uni will be defined for a finite number of types
21:39:23 <glguy> Nothing to do with type in type
21:39:27 <glguy> or with datakinds
21:39:34 <EvanR> all of which are typeable
21:39:42 <danilo2> EvanR: no, that doesn tsuit my needs :(
21:40:07 <EvanR> what is the point of a fully polymorphic type family
21:40:09 <glguy> You just can't instantiate a type variable to an unsaturated type family
21:40:49 <danilo2> EvanR: it allows users of a particular API to write custom instances
21:40:51 * geekosaur admits to being a bit too tired to follow this fully at the moment
21:41:36 <EvanR> ok so its not forall a
21:41:47 <EvanR> its an open type family
21:42:37 <EvanR> at the use site, maybe Typeable (Uni a) => ... will work
21:43:19 <EvanR> or, (Uni a ~ b, Typeable b) =>
21:47:10 <danilo2> EvanR: it iwll work, but I dont want to put `a` in the constraint. In fact I just want to tell that if something has type instance for Uni then the result is also typeable and ont have to inform about it in the context of every use of Uni
21:47:46 <EvanR> then write that in the kind of the type family
21:48:24 <danilo2> EvanR: how? If thats possible then its what im looking for
21:48:54 <EvanR> i dont know if its possible, i have a hard time guessing the allowed syntax for type family signatures
21:49:40 <danilo2> EvanR: ugh, I doubt it is possible because kinds cannot put constraitns on types, like the Typeable constraints, can they ?
21:50:26 <glguy> geekosaur: Ed tells me that he hadn't notice that TK3 was a type family earlier
21:50:39 <EvanR> im not sure. but maybe there is a hack with DataKinds
21:50:56 <EvanR> define a data-kind which wraps any type that has Typeable
21:52:47 <EvanR> erm that might be the same issue
21:53:09 <danilo2> EvanR: hmm, brb
21:56:50 <danilo2> EvanR: no, it doesnt work, if you try to put constraints in datatypes that you later use as DataKinds, youve got error from GHC "Illegal constraint in a type"
21:57:10 <danilo2> EvanR: but again, that would solve my problem
22:02:16 <danilo2> EvanR: I think some juggling with newtypes could solve the problem in my use case. Id be happy if that true, but ive got to go to sleep cause i dont see letters on the screen right now ;) thank you fr help! 
22:06:56 <danilo2> Hmmm, why in this code snippet: http://lpaste.net/346768, GHC tells me that function `ttt` needs constraint Typeable t? The newtype tells it will be there so it shouldnt be needed, shoudl it ?
22:08:13 <glguy> danilo2: That newtype doesn't say that you have a "Typeable (Abstract t)", it says you need one
22:09:14 <danilo2> glguy: that newtype tells that if I want to construct it, then the inner object have to have such constraint. So when I use such newtype it is guaranteed that its inner object meets this constraint, am I wrong ?
22:09:28 <glguy> Yeah, that's wrong
22:09:42 <ertesx> is there a good explanation online why left-associated (++) is bad while right-associated (++) is fine that i can link to?
22:09:56 <glguy> Using ExistentialQuantification you could have: data Definition2 t = forall t. Typeable t => Definition2 (Definition t), which is what I think you're expecting
22:10:01 <ertesx> ideally one that simply explains this fact without explaining DList
22:10:37 <danilo2> glguy: hmm, but that would create the runtime dict, wouldnt it?
22:10:39 <glguy> Note that unlike Hugs, GHC doesn't allow for newtypes with ExistentialQuantification
22:11:14 <danilo2> glguy: I didnt know that hugs allow them, thats pretty interesting
22:11:41 <glguy> I think that it allowed it as long as you didn't have any constraints on the existentiallyquantified types
22:11:50 <danilo2> glguy: anyway, would it involve the runtime dict when it isnt theoretically necessary? I just want to tell that when this data is constructed, ghc could be sure that this contraint is met
22:12:03 <mrkgnao> can someone explain what Typeable is?
22:12:14 <danilo2> glguy: oh I love it. I would love it in ghc
22:12:17 <ottanta> hello!  how come the type of 1.2 is 'Fractional a'?
22:12:23 <ottanta> isn't Fractional a typeclass?
22:12:30 <mrkgnao> it's Fractional a => a
22:12:33 <danilo2> mrkgnao: typeable is just runtime type information
22:12:39 <jle`> ottanta: your skepticism is well-founded
22:12:45 <jle`> ottanta: the type of 1.2 is indeed not 'Fractional a'
22:12:47 <glguy> ottanta: The type of 1.2 isn't Fractional a
22:12:58 <mrkgnao> i.e. any type a that "is" a Fractional, or that has a Fractional instance
22:13:37 <jle`> mrkgnao: imagine i made a typeclass that was like
22:13:40 <EvanR> 1.2 is polymorphic
22:13:45 <jle`> class TypeString a where
22:13:50 <jle`>   stringType :: p a -> String
22:13:57 <jle`> and wrote instances like:
22:14:01 <jle`> instance TypeString Bool where
22:14:06 <jle`>   stringType _ = "Bool"
22:14:14 <jle`> and one for a bunch of different types
22:14:17 <jle`> that's basically what Typeable is
22:14:26 <mrkgnao> okay, let me parse that
22:14:31 <EvanR> :t fromRational (12 % 10)
22:14:32 <danilo2> glguy: anyway, this doesnt work either: http://lpaste.net/346772
22:14:32 <jle`>  + some help from the compiler to auto-generate instances
22:14:33 <lambdabot> Fractional a => a
22:14:34 <ertesx> mrkgnao: as an alternative to explanation here is a *use case*: Data.Dynamic
22:14:36 * hackagebot aivika-distributed 0.3 - Parallel distributed discrete event simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-distributed-0.3 (DavidSorokin)
22:15:20 <jle`> mrkgnao: Typeable carries around a runtime token of "what type it is" (like the string in TypeString) that can get
22:15:22 <ertesx> mrkgnao: normally type information is erased in haskell, but Typeable preserves it, so dynamic typing becomes possible
22:15:39 <mrkgnao> that sounds like a bad idea
22:15:44 <mrkgnao> or, at least, difficult
22:15:47 <jle`> whatIsTheType :: TypeString a => p a -> String
22:15:53 <wespiser> curl -sSL https://get.haskellstack.org/ | sh 
22:15:57 <ertesx> mrkgnao: no, sometimes dynamic typing is just what you need‚Ä¶  it's rare, but it happens
22:15:58 <wespiser> is this a joke?
22:15:58 <jle`> whatIsTheType p = "It is a " ++ stringType p
22:16:19 <mrkgnao> jle`: ah, I get it now
22:16:23 <ertesx> mrkgnao: note that Either is also an instance of dynamic typing
22:16:31 <ottanta> OH thanks jle` glguy mrkgnao 
22:16:47 <ottanta> so it's basically saying 'I don't know what this is yet, but it follows the rules of Fractional thusfar'
22:16:48 <glguy> danilo2: Perhaps you want:  ttt (Definition2 t) = typeOf t
22:16:52 <jle`> mrkgnao: basically, if you see a 'Typeable a => ...' constraint, it just means that you also have the run-time TypeRep (representaiton of the type) you can access
22:16:57 <jle`> in the way that i used 'stringType' up there
22:17:17 <jle`> mrkgnao: one useful thing i've used this for is for networked applications when i want to send serialized data over a channel
22:17:20 <mrkgnao> um, but you're wrapping the types up in Left/Right to sort of make it static typing, isn't it?
22:17:23 <jle`> like, from a server and a client
22:17:27 <glguy> danilo2: Also note that you've shadowed 't' here data Definition2 t = forall t. Typeable t => Definition2 t
22:17:29 <mrkgnao> for serialization?
22:17:33 <mrkgnao> oh, I see you wrote that
22:17:51 <jle`> i can receive a binary blob, attached with a serialization of the type rep, and it'll tell me what type to deserialize it as
22:17:54 <danilo2> glguy: ah, right
22:17:57 <jle`> or also, if it's a type of something i'd want to ignore
22:18:07 <ertesx> mrkgnao: Typeable isn't different, except that you can't pattern-match directly
22:18:34 <ertesx> mrkgnao: think of Dynamic as data Something = AnInt Int | ABool Bool | AFloat Float | ‚Ä¶
22:18:40 <ertesx> except with infinitely many such constructors =)
22:18:44 <ottanta> you guys are great, btw
22:18:48 <ottanta> not to derail
22:18:52 <mrkgnao> like, ranging over all of Hask?
22:19:09 <mrkgnao> ottanta: I'm constantly surprised by how nice people are here, maybe it just rubs off :)
22:19:17 <ottanta> :)
22:19:22 <ertesx> mrkgnao: over all types that have a Typeable instance (which in GHC is all types, so for GHC the answer is yes)
22:19:49 <mrkgnao> that data "declaration" is clever
22:20:48 <jduan> question: how do I iterate a list two items at a time? given a list of [1..10], I‚Äôd like to visit them in pairs of (1,2), (3,4), (5,6), (7,8), and (9,10)
22:21:01 <danilo2> Ok so in fact there is no possibility in GHC to create a datatpe like `data Definition2 t = Definition2 (Typeable t => t)` (without hiding `t` from it) to tell it that when it will be constructed then the constraint would be met and this constraint isnt reuired when using it later?
22:21:33 <Cale> You can use an existential
22:21:41 <ertesx> jduan: either write a function that transforms the list (exercise!), or explain how you are going to use those pairs (perhaps there is a simpler method)
22:22:03 <ottanta> I'm trying to figure out, I was doing a problem from Real World Haskell, where it says to calculate the mean of a list.  I made a complicated one, which fails miserably, and a simple one, which works wonderfully 
22:22:06 <nshepperd> danilo2: that would be a GADT
22:22:11 <ottanta> but the issue is, I have no idea why the more complicated one fails
22:22:35 <Cale> Yeah, GADT syntax will make that happen:  data Definition2 t where Definition2 :: Typeable t => t -> Definition2 t
22:22:36 <ottanta> so the simple one is (sum (x:xs)) / (fromIntegral (length (x:xs)))
22:23:03 <ottanta> the complicated one, I tried to define my own sum and length functions, but the types don't seem to line up
22:23:06 <jle`> jduan: you can get a list of those pairs, and iterate/map over that list
22:23:41 <Cale> If you delete the t parameter and just let it be properly existential, that'll give you effectively a reimplementation of Dynamic
22:23:43 <mrkgnao> ottanta: maybe showing someone here the code would help
22:23:46 <ertesx> ottanta: that simple one is problematic though
22:24:07 <ottanta> ertesx: it's type signature is :: Fractional a => [a] -> a
22:24:22 <ottanta> mrkgnao: I'll use the lpaste from the channel topic if that's cool
22:24:24 <jduan> ertesx: I‚Äôm working on a problem ‚Äúwrite a recursive function that takes a string, breaks it into words, and counts the number of instances of ‚Äúthe‚Äù followed by a vowel-initial word‚Äù. It seems a good idea to iterate a list two items at a time.
22:24:27 <mrkgnao> ertesx: because you should probably just traverse the list once?
22:24:37 <ertesx> ottanta: you are referring to 'xs' twice, which means that sharing will kick in, and i'm not entirely sure if GC will be able to keep up
22:24:48 <jle`> jduan: you should probably iterate over consecutive items, instad
22:24:50 <jle`> *instead
22:25:07 <mrkgnao> ertesx: oh? can you explain?
22:25:15 <danilo2> nshepperd: right! `data Definition2 t where Definition2 :: Typeable t => t -> Definition2 t` creates it and doesnt shadows `t`, thanks!
22:25:17 <mrkgnao> about the GC?
22:25:18 <ertesx> jduan: in that case you probably just need 'tails'
22:25:22 <jle`> jduan: ["foo","the","aardvark","is"] would give you ("foo,"the") and ("aardvark","is")
22:25:31 <ertesx> > tails "abcde"
22:25:34 <lambdabot>  ["abcde","bcde","cde","de","e",""]
22:25:55 <ertesx> mrkgnao: what?
22:26:08 <ertesx> mrkgnao: the sharing thing?
22:26:08 <danilo2> Cale: existential will shadow the type variable, like `data Definition t = forall t. Typeable t => Definition t`, but GADTs (like nshepperd suggested) doesnt suffer form it
22:26:12 <mrkgnao> I mean what you said about GC being able to keep up.
22:26:34 <lpaste> ottanta pasted ‚Äúch3exercise3.hs‚Äù at http://lpaste.net/1102090274600910848
22:26:42 <ertesx> mrkgnao: f x + f x  -- computed twice
22:26:49 <ottanta> http://lpaste.net/1102090274600910848
22:26:51 <ottanta> oh
22:26:52 <ertesx> mrkgnao: let y = f x in y + y  -- computed once
22:26:58 <ottanta> it told you all about it
22:27:17 <ertesx> the latter is a case of sharing‚Ä¶  now imagine that y is a long list‚Ä¶  sharing it means that it will stay in memory
22:27:53 <mrkgnao> isn't the second better?
22:28:04 <mrkgnao> and will it stay in memory indefinitely?
22:28:17 <ertesx> i'm almost certain that ottanta's example will build and keep the list in memory, because it doesn't do the folds concurrently
22:28:41 <ertesx> mrkgnao: sometimes the second one is better, sometimes the first one
22:28:43 <ertesx> example:
22:28:56 <jduan> jle: yes, how do I iterate consecutive items like you said?
22:29:05 <jle`> ertesx gave a nice way up there
22:29:07 <Cale> danilo2: Right, I think you can just not write the forall, and it'll work too though
22:29:17 <jle`> but there's also zip xs (drop 1 xs)
22:29:23 <jle`> > zip [1..10] (drop 1 [1..10])
22:29:23 <ertesx> > sum [1..10000] / length [1..10000]  -- not shared
22:29:26 <lambdabot>  error:
22:29:27 <lambdabot>      ‚Ä¢ No instance for (Fractional Int) arising from a use of ‚Äò/‚Äô
22:29:27 <lambdabot>      ‚Ä¢ In the expression: sum [1 .. 10000] / length [1 .. 10000]
22:29:27 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
22:29:35 <ertesx> > sum [1..10000] / fromIntegral (length [1..10000])  -- not shared
22:29:39 <lambdabot>  5000.5
22:29:47 <Cale> @let data Defn t = Typeable t => Defn t
22:29:50 <lambdabot>  Defined.
22:29:53 <Cale> :t Defn
22:29:55 <ottanta> hm
22:29:55 <lambdabot> Typeable t => t -> Defn t
22:29:56 <ertesx> > let xs = [1..10000] in sum xs / fromIntegral (length xs)  -- shared
22:29:59 <lambdabot>  5000.5
22:30:00 <ottanta> I don't understand
22:30:20 <danilo2> Cale: I was sure it will not be accepted, but yeah, it workds too. Hmm, why I was thinking it is not allowed? thanks! :)
22:30:23 <ottanta> I think I'm working too closely from examples I've seen so like
22:30:28 <Cale> @let defnTypeOf (Defn x) = typeOf x 
22:30:30 <lambdabot>  Defined.
22:30:31 <ottanta> I think I have to engage with you all to really learn what's going on
22:30:36 <Cale> :t defnTypeOf
22:30:37 <lambdabot> Defn t -> TypeRep
22:30:38 <ertesx> mrkgnao: notice that in the former case the list [1..10000] is traversed, and since it's not shared, it will be produced *and discarded* lazily as the fold goes on
22:30:48 <mrkgnao> ah
22:30:49 <ertesx> mrkgnao: then the same thing repeats for 'length' (or in the other order)
22:30:52 <Cale> ^^ no Typeable constraint, because it unpacks one from the constructor
22:30:57 <mrkgnao> ertesx: now I get it
22:30:57 <nshepperd> Cale: huh. is that still a GADT, but just in ADT syntax?
22:31:37 <Cale> Well, I'm not sure it's proper to call it a GADT, as you're not introducing any type equalities
22:32:03 <Cale> But you are storing a Typeable dictionary in a hidden constructor field.
22:32:06 <mrkgnao> thanks, ertesx
22:32:17 <ertesx> ottanta: that explanation may be interesting for you, too
22:32:57 <nshepperd> well, if it was something else than Typeable it could end up containing an inequality?
22:33:38 <ottanta> ertesx: so, like, if you define something 2x it's 'not shared' and so the list is constructed twice?
22:33:46 <ottanta> I'm trying to keep up, lol
22:34:29 <ertesx> ottanta: something is shared, if: 1. it has a name, 2. it is not a function, 3. it has no type class constraints on its type variables
22:34:51 <ottanta> ertesx: Fractional a isn't a typeclass constraint?
22:35:11 <ertesx> ottanta: let me just show you a few examples:
22:35:13 <ertesx> x :: Integer  -- shared
22:35:18 <ertesx> x :: Double  -- shared
22:35:28 <ertesx> x :: [Integer]  -- shared
22:35:40 <ertesx> x :: [Integer -> Double]  -- shared (it's still not a function!)
22:35:52 <ertesx> x :: Integer -> Double  -- not shared (it's a function)
22:36:04 <ottanta> ohhh that's a list of functions so it's shared? hm
22:36:09 <ertesx> x :: Maybe a  -- shared
22:36:21 <ertesx> x :: (Fractional a) => Maybe a  -- not shared (has a class constraint)
22:37:17 <ertesx> if you refer to a variable twice, GHC decides whether it will be shared or not
22:37:36 <ottanta> hm
22:37:46 <ottanta> so instead of x:xs I replaced it with xs, will that probably be shared?
22:37:54 <ertesx> for the most part, if you refer to a non-function twice, it will probably be shared
22:37:56 <ottanta> like, I'm not using the head of the list anyway
22:38:27 <ottanta> wait sharing is bad? I'm not sure
22:38:35 <ottanta> I'm confused*
22:38:49 <ertesx> ottanta: normally sharing is good, but in this case it's bad, but don't worry‚Ä¶  the real answer in this case is: don't fold the list twice =)
22:39:10 <ertesx> you can compute both the sum and the length in one go
22:39:34 <EvanR> to ensure sharing, use let x = shareMe in ... x used many times ...
22:40:58 <nshepperd> oh, putting an equality as context to a class requires -XGADTs, ok
22:41:30 <jduan> ertesx: I didn‚Äôt know ‚Äútails‚Äù before. Thanks!
22:46:02 <ottanta> ertesx: I have no idea how I'm going to do that tbh 
22:46:17 <ottanta> like define a local function which returns a tuple?
22:46:27 <ottanta> I'll go do that
22:53:20 <ertesx> ottanta: yeah, that would be a good first version
22:55:52 <ottanta> yeah I have no idea what I'm doing
22:59:09 <nshepperd> "find . -type d \( -path ./.git -o -path ./.svn -o -path ./_darcs -o -path ./.stack-work -o -path ./dist -o -path ./.cabal-sandbox \) -prune -o -type f \( -name '*.hs' -or -name '*.lhs' -or -name '*.hsc' \) -not \( -name '#*' -or -name '.*' \) -print0 | xargs -0 hasktags -e -x" <-- wtf, no wonder emacs freezes up when writing hasktags on save, it's trying to search my entire home directory tree every time
22:59:43 <nshepperd> synchronously, no less
23:01:07 <MarcelineVQ> you're working where . is your home?
23:01:12 <ertesx> ottanta: just try it
23:01:29 <ottanta> I'm trying :)
23:05:09 <nshepperd> MarcelineVQ: yes, I often open test files in random directories just to write things to test in ghci
23:05:48 <nshepperd> generally, I would run emacs from anywhere
23:22:26 <nerglish> hey, i'm trying to learn haskell but i'm having trouble trying to parse stdin
23:25:17 <nerglish> i'm expecting to receive n pairs of integers
23:26:36 <lpaste> nerglish pasted ‚Äúread pairs‚Äù at http://lpaste.net/346799
23:29:35 <nerglish> i'm not sure how to get this to work
23:30:07 <nerglish> or how to interpret these errors
23:30:08 <nerglish> Couldn't match expected type ‚Äò[Int]‚Äô with actual type ‚Äòa0 -> [b0]‚Äô
23:37:09 <grantwu> [278330.853821] Out of memory: Kill process 17256 (ghc-mod) score 518 or sacrifice child [278330.853824] Killed process 17256 (ghc-mod) total-vm:1074350712kB, anon-rss:2206968kB, file-rss:0kB
23:37:16 <grantwu> I should really submit a ticket...
23:37:25 <grantwu> er, an issue
