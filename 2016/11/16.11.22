00:00:09 <liste> oh wait
00:00:49 <liste> I misread
00:02:18 <ski> EvanR : "using racing", yes. you could use threads and `unsafePerformIO' to implement it (often called `por', "parallel or") in Haskell
00:02:43 <ski> (can't be defined in a plain sequential model)
00:03:59 <chpatrick> > let foo a b c d = [ ( ( a, x ), ( b, y ) ) | x <- [ c, d ], y <- [ c, d ] ] in foo "a" "b" "c" "d"
00:04:02 <lambdabot>  [(("a","c"),("b","c")),(("a","c"),("b","d")),(("a","d"),("b","c")),(("a","d"...
00:04:05 <chpatrick> Cipher: ^
00:04:59 <Cipher> WOW,that's cool!
00:05:20 <Cipher> Thanks 
00:07:48 <Cipher> What's the meaning of the abbreviation "foo" ? I always see it.
00:08:26 <chpatrick> Cipher: https://en.wikipedia.org/wiki/Metasyntactic_variable
00:09:55 <Cipher> oh i see, thank you!
00:22:20 <nshepperd1> EvanR: i would think if you could semidecide /= for Integer you could write a halting oracle somehow
00:22:52 <ski> for the domain `Integer', or for `|Z' ?
00:23:30 <nshepperd1> For Haskell Integers
00:27:58 <wespiser> instead of monad transformers, why don't we just make a Product data type with each monad type inside?
00:28:08 <nshepperd1> diverges p = apart 1 (seq p 1)
00:29:01 <nshepperd1> (implement seq p 1 with some arithmetic shenanigans to avoid including seq in the language i guess)
00:29:03 <lyxia> wespiser: what do you mean
00:29:36 <lyxia> wespiser: how do you write StateT s (Either e) as a "product"
00:30:26 <wespiser> data M = M { S :: State s a, E :: Either e a }
00:30:46 <wespiser> it sort of conflates the values
00:30:59 <lyxia> this does not represent the same thing
00:31:03 <wespiser> yea
00:31:14 <wespiser> the StateT s (Either e) target
00:31:22 <wespiser> has target in one place
00:31:42 <wespiser> data M = M { S :: State s target, E :: Either e target } has target in two
00:32:31 <lyxia> I mean there is no way this type is going to replace monad transformers
00:32:51 <wespiser> I know, I'm just trying to think about it
00:33:10 <nshepperd1> Product monads just aren't very useful, since a computation in them can't combine the effects
00:33:11 <wespiser> for some cases, like, say, ResourceT, it might make sense
00:33:20 <lyxia> okay I misinterpreted your use of "instead"
00:33:35 <wespiser> np
00:33:55 <lyxia> that Product type already exists BTW
00:34:15 <nshepperd1> Like, you can produce an Either e a in your example but you have to do so without knowing what was the outcome of any state operations
00:34:23 <lyxia> wespiser: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Product.html
00:34:27 <wespiser> yea, example
00:34:31 <wespiser> *exactly
00:36:12 <wespiser> Is that design pattern ever used?
00:36:24 <wespiser> multiple monads in an ADT?
00:36:58 <wespiser> i'm mostly interested in industry use cases/best practices
00:39:21 * hackagebot config-ini 0.1.0.0 - A library for simple INI-based configuration files.  https://hackage.haskell.org/package/config-ini-0.1.0.0 (gdritter)
00:40:20 <EvanR> diverges p = apart 1 (seq p 1)
00:40:26 <EvanR> brilliant...
00:40:52 <EvanR> the proof reduces to a proof of the halting problem
00:42:12 <chpatrick> wespiser: http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
00:42:22 <chpatrick> but according to kmett mtl is the best "effect system"
00:42:30 <chpatrick> I agree
00:43:17 * edwardk looks up, agrees, then goes back to reading his book.
00:43:26 <chpatrick> o/
00:43:31 <edwardk> o/
00:44:33 <jle`> wespiser: well, there's the data types a la carte style, which sort of is similar
00:44:56 <wespiser> chpatrick: thanks, I like that. Is there academic source/white paper for a GADT evaluator?
00:45:10 <wespiser> sort of like the paper, but with words, too
00:45:13 <jle`> oh someone just mentioned it
00:45:34 <jle`> there are a couple of demos/tutorials in various blog posts
00:45:50 <wespiser> alright, I'll hunt down the citations from the paper
00:46:32 <EvanR> a subspace of a datatype A is called compact if the "all" function :: (A -> S) -> S is continuous/definable in the language. does this correspond in any way to compactness in regular topology?
00:47:09 <EvanR> if the "all" is semidecidable
00:47:44 <wespiser> https://cs.appstate.edu/~johannp/popl08.pdf
00:48:11 <bollu> what is a good book for an intro to model theory?
00:48:23 <EvanR> any open cover of A has a finite subcover
00:49:08 <EvanR> i named it wrong, subspace X of datatype A... 
00:49:16 <bollu> EvanR: ? why are you stating compactness?
00:49:35 <EvanR> i was asking a question
00:49:52 <wespiser> http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=377367442590667EB79A9970C1DCD683?doi=10.1.1.85.1152&rep=rep1&type=pdf
00:49:53 <EvanR> ah you walked in right after i asked it
00:56:06 <erisco> glguy, ever figure it out
01:02:25 <erisco> the question is: what is an example of partial type synonym application, not involving circularity, that leads to trouble?
01:04:38 <django_> hey all
01:04:41 <django_> is this a good website: https://www.fpcomplete.com/haskell-syllabus
01:04:48 <django_> to learn haskell
01:05:44 <erisco> there is potentially trouble when deciding equality of * -> * kinds, but then I ask: what is an example of deciding this equality where type synonyms are involved?
01:09:12 <erisco> it seems to me that you can normalise any type synonym to a data type or ->
01:10:59 <EvanR> aiui partially applied type synonyms is equivalent to type lambdas
01:11:11 <EvanR> so you have lambda calculus
01:11:23 <erisco> sorry I asked the wrong second question
01:11:36 <erisco> the question I meant to ask is: when is deciding equality of * -> * kinds relevant?
01:12:22 <erisco> EvanR, I am just struggling to drum up any examples of this
01:12:24 <EvanR> deciding equality is inherent in unification?
01:12:57 <EvanR> and we have polykinds, so that has to be done
01:13:07 <erisco> give any example
01:13:48 * EvanR looks up the Category docs..
01:14:34 <EvanR> :k Category
01:14:35 <lambdabot> (k -> k -> *) -> Constraint
01:16:17 <erisco> type Foo f = f; type Bar f = f; x :: Foo a; y :: Bar b; z :: f a -> f b -> c; z x y
01:16:32 <erisco> seems to ask Foo ~ Bar
01:17:23 <EvanR> that involves equality of *'s
01:17:30 <EvanR> Foo a and Bar b
01:18:11 <erisco> yes
01:18:20 <EvanR> so its not looked at Foo and Bar is isolation
01:18:26 <EvanR> looking*
01:18:30 <erisco> that is non-example I brought up the other day
01:18:42 <EvanR> and any value level thing isnt going to exhibit it
01:18:49 <EvanR> because its always involving *'s
01:18:56 <erisco> really, Foo a reduces to a and thus x :: a and y :: b
01:19:11 <EvanR> so the example needs to be totally at the type level
01:19:19 <ertesx> erisco: i think equality is fine (recursive type synonyms aren't allowed anyway), but instance resolution may get confused
01:19:38 <ertesx> @let Flip f a b = f b a
01:19:40 <lambdabot>  .L.hs:161:1: error:
01:19:40 <lambdabot>      Not in scope: data constructor ‘Flip’
01:19:40 <lambdabot>      Perhaps you meant variable ‘flip’ (imported from Data.Function)
01:19:45 <ertesx> @let type Flip f a b = f b a
01:19:47 <lambdabot>  Defined.
01:20:02 <ertesx> :k Free (Flip Either a)
01:20:04 <lambdabot> error:
01:20:04 <lambdabot>     Not in scope: type constructor or class ‘Free’
01:20:04 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
01:20:10 <EvanR> recursive type synonyms arent allowed but youd get the same thing with not-fully-applied ones
01:20:45 <ertesx> EvanR: how?
01:20:48 <erisco> well I keep hearing that and I don't see any examples
01:20:50 <EvanR> with a Y combinator
01:21:07 <ertesx> you don't have Y
01:21:23 <EvanR> you would if synonyms were first class at the type level
01:21:43 <ertesx> but they aren't, which is the point =)
01:21:49 <EvanR> yes
01:22:10 <EvanR> im not sure if erisco is asking the question that this answers or not
01:22:12 <erisco> assume they are, then what is the example
01:22:33 <EvanR> type Y x = ... 
01:22:34 <ertesx> > (Flip Either ~ Flip Either) => ()
01:22:36 <lambdabot>  <hint>:1:29: error: parse error on input ‘=>’
01:22:43 <ertesx> > () :: (Flip Either ~ Flip Either) => ()
01:22:45 <lambdabot>  error:
01:22:46 <lambdabot>      • The type synonym ‘Flip’ should have 3 arguments, but has been given 1
01:22:46 <lambdabot>      • In an expression type signature:
01:23:03 <ertesx> @let {-# LANGUAGE LiberalTypeSynonyms #-}
01:23:03 <erisco> lets go simpler, first lets get self-application defined
01:23:06 <lambdabot>  Defined.
01:23:08 <erisco> how do you define self-application?
01:23:08 <ertesx> > () :: (Flip Either ~ Flip Either) => ()
01:23:10 <lambdabot>  error:
01:23:10 <lambdabot>      • The type synonym ‘Flip’ should have 3 arguments, but has been given 1
01:23:10 <lambdabot>      • In an expression type signature:
01:23:17 <ertesx> ah, you can't define extensions for lambdabot
01:23:21 <ertesx> but it wouldn't help
01:23:26 <ski> nshepperd1 : well, for Haskell `Integer's, including or not including bottom ?
01:23:34 <EvanR> ski: including
01:23:45 <EvanR> erisco: so is the question to define Y with type synonyms?
01:23:53 <EvanR> i see it will take some doing
01:23:53 <erisco> type F x = x x   is an error
01:24:09 <erisco> just define self-application, which Y requires
01:24:25 <ski> nshepperd1, wespiser : actually i've used product monads
01:24:27 <EvanR> oh youre right, since its typed that wont work
01:24:53 <ertesx> defining Y is strictly disallowed
01:25:10 <erisco> but it isn't due to partial application, it is due to kinds
01:25:16 <EvanR> right
01:25:26 <EvanR> it would have an infinite kind
01:25:29 <ertesx> however, the question was why, say, (Flip Either ~ Flip Either) doesn't check
01:25:39 <ertesx> which is a good question
01:25:59 <ertesx> even with -XLiberalTypeSynonyms it doesn't check
01:26:18 <erisco> the question is why we do not have partial application with type synonyms. specifically: give an example of a problem
01:26:29 <EvanR> ertesx: because you dont have all the arguments applied
01:26:35 <ski> EvanR : "does this correspond in any way to compactness in regular topology?" -- i believe so (given continuous as computable)
01:27:16 <EvanR> open cover, finite subcover... and "forall"... not sure the connection
01:28:15 <erisco> ertesx, in regards to that, which I can see as a problem, the question is: when is equality of * -> * or greater arity kinds required?
01:28:16 <ertesx> erisco: i can see one such case with -XTypeSynonymInstances
01:28:53 <ertesx> erisco: if you could write an instance Category (Flip (->)), then instance resolution could no longer figure out what (.) means for functions
01:29:33 <erisco> though even in the Flip Either example, my guess is that kinds guarantee a unique normal form
01:29:42 <ertesx> or worse:  instance (Category cat) => Category (Flip cat)
01:29:49 <erisco> so these could be unified anyhow
01:30:03 * EvanR looks up the particular issue
01:30:09 <EvanR> i dont think they would have a normal form
01:30:33 <ertesx> erisco: i think (~) could work with partially applied synonyms
01:30:49 <ertesx> it's instance resolution which has a problem with them
01:31:17 <EvanR> ah
01:31:34 <ertesx> (it doesn't work right now, but it could in principle)
01:32:21 <ertesx> (~) would run into trouble, if we had general recursion, but we don't have that
01:32:23 <EvanR> erisco: heres something, type synonyms dont have a fixed kind. type F f = f, f could be any kind
01:32:44 <EvanR> its not even a type level thing because they are expanded before anything else happens
01:32:59 <ertesx> EvanR: it's just polykinded
01:33:08 <EvanR> theres no kind at all
01:33:16 <ertesx> @let type PolyId x = x
01:33:17 <lambdabot>  Defined.
01:33:19 <ertesx> :k PolyId
01:33:21 <lambdabot> k -> k
01:33:23 <ertesx> yes, there is =)
01:33:56 <EvanR> wurb... i have it backwards
01:34:08 <EvanR> LiberalTypeSynonyms proposes to reverse that
01:34:15 <EvanR> expand before doing kind checking
01:34:55 <erisco> ertesx, instance resolution is interesting. I can see one solution is to give up if the type cannot be normalised to a data type
01:35:08 <ski> with `LiberalTypeSynonyms', type synonyms act like higher-order macros
01:35:40 <thepreacher> Haskell noob here, trying for the countless time to learn haskell using the 2nd edition of Programming in Haskell. I'm stuck trying to understand how the && operator could return a Bool or b according to the following definitions: True && b = b, False && _ = False. On one definition it return b which I'm assuming is non Bool then the next one returns Bool.
01:35:58 <tdammers> oh shoot
01:36:03 <ski> tdammers : `b' is a `Bool'
01:36:14 <ski> er
01:36:16 <tdammers> Data.HashMap.Strict.HashMap and Data.HashMap.Lazy.HashMap are the same type
01:36:18 <tdammers> ouch
01:36:19 <ski> thepreacher : `b' is a `Bool'
01:36:27 <tdammers> fml
01:36:43 <ski> thepreacher : both arguments (left and right) to `&&' is a `Bool' (and the result is, as well)
01:36:47 <erisco> ertesx, another possibility is to require an explicit instance
01:36:56 <thepreacher> ski: oh I see. It wasn't clear to me in the book. Thanks then.
01:37:20 <erisco> for whatever the normal form is, so you would write an instance for Flip (->) if you could
01:37:22 <EvanR> erisco: so is the question, when is * -> * done?
01:37:48 <EvanR> or are you wondering whether eq for * -> * is actually undecidable
01:37:55 <ski> thepreacher : in the former case, `True && b = b', we're checking whether the left argument is specifically `True', while the right argument could be any `Bool', we just name it `b' to be able to refer to it later (in the body, which in this case is also just `b')
01:38:06 <ertesx> erisco: i'm not really the right person to talk to, because i'm not familiar with all the details of instance resolution, but at least intuitively i would expect partially applied type synonym instances to be a major problem, specifically because of the example i gave earlier…  the Flip would cycle forever
01:38:22 <erisco> I am not sure if it is decidable
01:38:33 <ertesx> erisco: so instance resolution and partially applied type synonyms can lead to infinite cycles → undecidable
01:38:40 <EvanR> it would be undecidable with first class synonyms
01:38:51 <erisco> if there is not recursion then I suspect so, but I don't know for sure
01:38:51 <EvanR> not even just because of instance resolution
01:38:57 <ski> thepreacher : while in the latter case, `False && _ = False', this says what should happen if the left argument is instead `False'. in this case we don't care about naming the right argument, so we just use a "wildcard/anonymouns" pattern, `_' in the place of the right argument there
01:38:57 <thepreacher> ski: Thanks its clear now :)
01:39:07 <EvanR> erisco: without recursion of any sort
01:39:08 <ertesx> erisco: in principle that could be allowed with -XUndecidableInstances, but there are probably other reasons why it shouldn't be
01:40:03 <ski> thepreacher : btw, note that if you write `False && (div 1 0 == 2)', then the division by zero in the right argument won't happen, because that argument isn't evaluated in this case
01:40:03 <erisco> EvanR, can you find an example of two terms which are functionally equivalent but do not have the same normal form?
01:40:29 <EvanR> or there would be no normal form
01:40:50 <ski> thepreacher : so, you can automatically get short-circuiting behaviour like this, by not using an argument (or part of an argument), in some cases of a definition
01:41:41 <ertesx> erisco: instance resolution requires type classes to form something similar to a partial order (perhaps an actual partial order) regarding class dependencies
01:41:59 <ertesx> *instance* dependencies
01:42:04 <erisco> well if there are normal forms then instance resolution can happen
01:42:05 <EvanR> erisco: lets say you have a type (synonym) family of kind F :: f -> f -> *, then you pass in Foo and Bar 
01:42:27 <EvanR> which are both kind * -> *
01:42:31 <thepreacher> ski: Cool, I get it now.
01:42:33 <ertesx> erisco: or rather just a lattice
01:42:34 <EvanR> you cant decide the equality
01:42:42 <ertesx> semilattice
01:43:04 <ertesx> in any case:  if you allow cycles, then instance resolution can loop
01:43:18 <erisco> EvanR, why not?
01:43:24 <ertesx> example:  instance (Category cat) => Category (Flip cat)
01:43:51 <EvanR> because Foo and Bar could encode the same function in a different way
01:44:01 <ertesx> this is completely well-formed, except that Flip is a partially applied type synonym
01:44:02 <erisco> do you have such an example? that is what I am looking for
01:44:27 <EvanR> ok
01:45:14 <erisco> ertesx, what is the problem there?
01:45:56 * ski . o O ( `Flip (Flip f) = f' )
01:45:57 <EvanR> Foo f x = f x, Bar y = y
01:46:36 <EvanR> not the same kind...
01:46:48 <ski> add kind annotation ?
01:47:14 <EvanR> ah
01:47:45 <EvanR> Foo :: (* -> *) -> * -> *, Bar :: (* -> *) -> (* -> *)
01:48:02 <erisco> Flip (Flip f) = f  is why I don't see the problem in instance resolution there
01:48:31 <EvanR> same kind, same function, but they didnt dare ask ghc to figure out if they are the same
01:48:59 <ski> well, any type of the right kind would match `Flip f'
01:49:15 <ski> (making `f' be `Flip g', `g' being the original type)
01:49:36 <erisco> f and Flip f get separate instances
01:49:53 <erisco> I think EvanR just showed that we don't have such a normal form to rely on though
01:50:21 <ertesx> erisco: moreover f and Flip (Flip f), which *are* the same type, could now have two instances
01:50:40 <erisco> ertesx, why? they have to have the same instance because they are both f
01:50:49 <ski> i suppose the instance resolution mechanism doesn't know that applying the transformation from `Category cat' to `Category (Flip cat)' twice, will yield an equivalent method dictionary
01:50:54 <EvanR> erisco: heres something, answer with 9 points on stackoverflow http://stackoverflow.com/questions/4922560/why-doesnt-typesynonyminstances-allow-partially-applied-type-synonyms-to-be-use
01:51:11 <EvanR> it mentions instance resolution but the example doesnt mention it
01:51:20 <EvanR> its just a type inference problem
01:51:20 <ertesx> (.)  -- GHC: "should i select the instance for (->), or the one for Flip (Flip (->))?"
01:51:48 <ertesx> GHC: "is there an instance of the latter form?  how do i even know there is such an instance without looping potentially forever?"
01:52:14 <EvanR> erisco: you could say that Foo and Bar are obviously different and dont unify... except that requires newtypes
01:52:30 <EvanR> with type synonyms you only have the body to go by
01:52:45 <ski> *nod*, it requires knowing that some paths in the deriving of instances is actually cycles
01:52:46 <EvanR> if they are partially applyable, then you have lambda calculus and cant decide the equality
01:53:04 <ertesx> erisco: now for *any* category, instance resolution would find infinitely many instances, each with potentially different semantics
01:53:17 <erisco> (\f a b -> f b a) ((\g c d -> g d c) z) = (\f a b -> f b a) (\c d -> z d c) = \a b -> (\c d -> z d c) b a = \a b -> z a b
01:53:23 <ertesx> cat, Flip (Flip cat), Flip (Flip (Flip (Flip cat))), …
01:53:32 <erisco> though now we have to suppose in finding normals that we eta-reduce
01:53:35 <EvanR> instance resolution is borked but, unification is borked first
01:53:45 <erisco> to get back to z
01:54:23 <ertesx> erisco: is this convincing enough?
01:54:28 <erisco> what if we eta-reduce with \f x -> f x  and  \y -> y  ?  then  \f x -> f x = \f -> f
01:54:29 <ertesx> regarding resolution
01:54:41 <erisco> so then: can we just involve eta-reduction in normalisation?
01:55:02 <EvanR> guess we need another example
01:56:58 <ski> EvanR : .. i wonder whether one could allow L-lambda matching for cases such as Barton mentioned on that SO answer
01:57:20 <ski> erisco : or perhaps eta-expand
01:57:26 <ski> (eta-long form)
01:57:40 <EvanR> http://cstheory.stackexchange.com/questions/21614/algorithm-to-determine-function-equality-on-the-simply-typed-lambda-calculus
01:58:47 <ski> one problem with L-lambda unification is that there's no longer a single most general unifier
01:59:19 <ski> (so you get backtracking / multiple solutions)
01:59:44 <EvanR> the kinded ness of first class synonyms complicateds the question of why equality still isnt decidable
01:59:59 <EvanR> but the SO answer there indicates that it is so
02:00:37 <EvanR> the counter example involves encoding the lifetime of a turing machine run on the empty input
02:00:48 <EvanR> as a function
02:21:39 <danilo2> Hello guys! I've got a strange problem. I need to use some simple Data.Map.Lazy function but in a monadic context. Why such basic library doesnt provide monadic operators? Didnt anybody need them so far? 
02:21:59 <danilo2> In particular I need: insertWithKeyM :: Ord k => (k -> a -> a -> m a) -> k -> m a -> Map k a -> m (Map k a)
02:23:41 <mpickering> Can't you easily implement it yourself?
02:25:47 <danilo2> mpickering: sure I can. Not very easily (it will be about 4 functions that call themselves - look at the implementation in Data.Map). Still it shoudl be included. Anyway I understand that if I write it, I should make pull request to Data.Map with it, shouldnt I /
02:26:28 <danilo2> mpickering: by "not very easily" I ean that there is no problem with implementing it, however forcing users to implement that by themselves is just wrong in my opinion
02:26:40 <lyxia> alterF is pretty close
02:27:36 <danilo2> lyxia: I'm looking for lazy version
02:27:38 <mpickering> No.. Data.Map shouldn't include every variant you can ever think of.
02:27:45 <mpickering> I see that this is a bit awkward to implement yourself though
02:27:54 <EvanR> pretty awesome haskell performance question: http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell
02:28:21 <lyxia> danilo2: what do you mean a lazy version
02:28:55 <danilo2> lyxia: alterf is available for Data.Map.Strict but not for Data.Map.Lazy
02:29:12 <lyxia> http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Lazy.html#v:alterF
02:31:06 <danilo2> lyxia: oh, I had to either be blind or looked at old docs. Thanks, that suits my needs!
02:31:27 <lyxia> yw
02:32:07 <mpickering> tm
02:36:18 <kadoban> EvanR: Always fun to see haskell do well in tests
02:39:15 <grantwu> What is the worker/wrapper optimization?
02:40:25 <kadoban> grantwu: The 'go' thing in factorCount'
02:43:48 <grantwu> oh.  this is just a case of CSE.
02:43:58 <MarcelineVQ> what is faster about rem?
02:44:23 <kadoban> MarcelineVQ: Less checks. mod is implemented in terms of rem, I believe, it just has an extra if or two.
02:45:16 <grantwu> I believe rem maps more directly to the hardware instruction
02:45:41 <grantwu> And mod requires "emulation" with branches
02:50:11 <EvanR> whats interesting is that it only took a couple tweaks to get it to go faster, the original program written by someone not especially entrenched in GHC lore
02:50:20 <MarcelineVQ> I see, the difference really is just an extra if, thank you kadoban
02:51:58 <MarcelineVQ> at least in the class, I should check instances too
02:52:30 <EvanR> generated code for mod vs rem cant be that different, one instruction vs two
02:55:41 * EvanR looks up -fforce-recomp
02:55:43 <grantwu> https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Classes.hs It looks like more than one instruction
02:56:49 <EvanR> ah just forces compilation
02:58:24 <EvanR> i wonder if that nest of isTrue#, <# ># and ||-not-# is somehow optimized
02:58:36 <EvanR> during compilation
02:59:35 <grantwu> I would hope so, there are probably things that can be done with x86 flags
02:59:37 <EvanR> and the nested ifs
03:01:29 <EvanR> but just looking at the code, its obvious that rem is the way to go if it would work
03:02:19 <muzzle> Hi, is there a name for a datatype that has only functions in it's constructor?
03:02:51 <muzzle> something like DBInterface a = DBInterface {getValue :: String -> IO a, storeValue :: (String, a) -> IO ()}
03:03:49 <muzzle> And is there a resource for haskell - related terminology in general?
03:03:57 <EvanR> its a record of functions
03:04:34 <EvanR> you might call it an object type, drawing from OOP
03:05:54 <EvanR> but record of functions is too specific, you might have a field launchMissiles :: IO (), which isnt a function
03:06:36 <grantwu> has anyone done any work surveying how commonly referential transparency is broken via unsafePerformIO and friends
03:06:42 <grantwu> in common libraries
03:07:05 <muzzle> EvanR could I use "interface type"?
03:07:53 <grantwu> is there a reason why you need a name
03:08:08 <EvanR> interface type sounds right
03:08:38 <muzzle> grantwu it's for my master's thesis
03:09:03 <muzzle> i implemented it in haskell and now i have to write about it. But i find the terminology to use a bit unclear sometimes
03:10:41 <quchen> muzzle: We sometimes call these records dictionaries, when they serve a similar purpose to "explicit type classes".
03:11:03 <quchen> A dictionary does not have to contain only functions, though.
03:12:40 <ertesx> muzzle: i'd call it "record type", or in some cases "vector type"
03:12:45 <EvanR> you could say a record of operations
03:13:01 <muzzle> ertesx why "vector type"?
03:13:17 <ertesx> muzzle: if all members are of the same type
03:13:46 <ertesx> muzzle: background: i have seen record types that only contained integers and not bothered giving them special names, so why would i do it for functions? =)
03:14:11 <muzzle> ertesx my type contains different functions and one value
03:14:38 <muzzle> it's for operating on source code in different programming languages
03:14:48 <muzzle> operations like tokenization, etc.
03:15:01 <ertesx> quchen suggested "dictionary", which seems like a good fit
03:15:38 <ProofTechnique[m> Does that break down into something meaningful?
03:15:39 <ProofTechnique[m> It also helps to read <$> as fmap
03:15:40 <ProofTechnique[m> Isn't there a Canberra in Ohio?
03:15:40 <ProofTechnique[m> It's type equality. Whatever e is, it needs to unify with SomeException, if I'm phrasing it correctly
03:16:00 <anononon[m]> oh baby!
03:16:11 <vuamitom[m]> Morning
03:16:30 <muzzle> ertesx isn't a dictionary usually something like a map (e.g. in python?)
03:16:48 <ertesx> muzzle: no, we use "map" (as a noun) for that
03:17:07 <ertesx> (although the python thing is something different: it's mutable)
03:17:13 <xss[m]> hello 
03:17:13 <xss[m]> cipher
03:17:23 <quchen> muzzle: “Dictionary” is how type classes are implemented internally, so we reuse the term if we recreate similar behaviour explicitly in our code.
03:17:49 <ertesx> muzzle: BTW, is there a reason why you don't write a type class?
03:18:22 <quchen> A dictionary associates a class with its concrete functions, for example "Bool" with BoolDict { (==) :: Bool -> Bool -> Bool; True == True = True; False == False = True; _ == _ = False}.
03:18:53 <muzzle> ertesx, it kind of seems redundant to implement a type that i'm only ever going to use as an implementation of a type class
03:18:55 <quchen> So it is a sort of lookup, just not in a binary tree or something, but in the abstract “give me the correct implementation” way.
03:19:26 <muzzle> ertesx so i just skipped the typeclass part and write the different implementations directly as values?
03:19:27 * hackagebot hasql-class 0.0.1.0 - Encodable and Decodable classes for hasql  https://hackage.haskell.org/package/hasql-class-0.0.1.0 (jkarni)
03:19:32 <ertesx> muzzle: no, i mean: don't bother writing the type, and only write a type class
03:20:00 <ertesx> muzzle: nothing wrong with that, i've done that in some cases, too…  just for the most part type classes are more convenient
03:20:01 <muzzle> ertesx but wouldn't i need to have a type, that i can write the instance for?
03:20:17 <quchen> Usually, we use type classes. But sometimes, explicitly writing dictionaries is preferrable. There’s a nice article by Simon Meier about this, https://www.schoolofhaskell.com/user/meiersi/the-service-pattern
03:20:23 <muzzle> ertesx is that considered bad practice?
03:20:23 <ertesx> muzzle: without code i'm imagining that you're doing something like this:
03:20:36 <ertesx> muzzle: data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }
03:20:45 <ertesx> mconcat :: Monoid a -> [a] -> a
03:20:54 <ertesx> the type class variant looks like this:
03:21:03 <ertesx> class Monoid a where mappend :: a -> a -> a; mempty a
03:21:09 <ertesx> mconcat :: (Monoid a) => [a] -> a
03:22:08 <ertesx> the difference is that in the latter case the instance to 'mconcat' (which you can imagine being an implicitly passed value of the former Monoid *type*) is selected by instance resolution based on the type 'a'
03:22:22 <muzzle> ertesx http://lpaste.net/344778
03:23:40 <ertesx> hmm…  although it does look like a type class, there is a complication
03:23:58 <ertesx> does 't' by any chance follow from 'l'?
03:24:16 <ertesx> i mean: is it the case that to every 'l' there is an associated 't'?
03:24:55 <muzzle> ertesx not necessarily
03:25:15 <muzzle> they are currently associated
03:25:24 <muzzle> but they very likely won't be in the future
03:25:38 <muzzle> i.e. there will be multiple token types for single languages
03:25:59 <ertesx> hmm…  i would still go for a type class, but it does come with complications
03:27:03 <ertesx> class LanguageInfo l where languageFileExtension :: proxy l -> FilePath; languageName :: proxy l -> Text; …
03:27:44 <ertesx> class (LanguageInfo l) => Language t l where tokenize :: LanguageText l -> Maybe (TokenVector t l)
03:27:47 <ertesx> something like that
03:28:07 <ertesx> though with more domain-specific knowledge i would probably refactor it differently
03:28:21 <muzzle> ertesx, any tips?
03:29:05 <muzzle> i couldn't really find any useful resources on design decisions like this
03:29:18 <muzzle> so I just went with what "felt right"
03:29:18 <ertesx> muzzle: i think if the current (record-based) approach works for you, keep it for now, until you get more comfortable with designing type classes
03:29:42 <ertesx> i'm just telling you what *i* would have done =)
03:33:31 <muzzle> ertesx shouldn't typeclasses be used to capture one aspect of type's functionality? Like appendability with monoids? Or "orderability" with Ord?
03:33:54 <muzzle> so when my type really only has one functionality it would be less useful to make a typeclass?
03:34:40 <EvanR> i found type classes can get in the way when its a simple single record of operations with more than one implementation
03:35:36 <EvanR> to manage collections of such things with type classes, you have to use existentials, and in the worst case to manage them first class you need reflection
03:35:49 <ertesx> muzzle: in general for a type class to be useful there should be at least two instances and at least one function in terms of the class
03:36:10 <ertesx> muzzle: Monoid satisfies that:  it as [a] and () as instances, and there is mconcat
03:36:16 <EvanR> one thing you can easily do if you dont use type class is hide state behind the record, using a closure
03:36:31 <ertesx> Num satisfies that:  there are Integer and Double, and there is (^)
03:36:47 <EvanR> like those IO functions could be closing over IORefs, good luck doing that with a type class
03:37:03 <muzzle> ertesx My type would definitely fulfill those requirements for a typeclass. But the implementations are not really useful except as an instance of the class
03:37:28 <ertesx> muzzle: i don't know what that means
03:38:02 <quchen> What does ⊢_D usually mean? The Wikipedia article on HM uses it in the block on the right, https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Deductive_system
03:38:04 <muzzle> ertesx, sorry english isn't my native language :P
03:38:20 <ertesx> muzzle: i understood the words, just not what you're trying to communicate =)
03:38:34 <muzzle> i could make my language type a typeclass
03:38:40 <muzzle> and then write several implementations
03:38:57 <muzzle> but the types that implement the class are not useful on their own 
03:39:11 <muzzle> only as implementations of the typeclass
03:39:26 <EvanR> that, and the closure thing are good reasons not to use a typeclas
03:39:27 <ertesx> muzzle: ah, you mean your 'l' is just a dummy type?
03:39:34 <muzzle> yes
03:39:35 <EvanR> the only thing you get with the typeclass in this case is the auto-passing behavior
03:39:40 <muzzle> it's just a phantom type
03:40:01 <EvanR> oh and if you have to use proxy... thats even worse
03:40:01 <ski> quchen : (syntactically) entails ?
03:40:03 <ertesx> muzzle: that's fine…  view it as a "configuration" type, and most languages have no configuration =)
03:40:21 <quchen> ski: What’s the difference to ⊢ alone?
03:40:27 <EvanR> muzzle: i avoid typeclasses unless its obvious they are beneficial
03:40:59 <locallycompact> I have a related question, what's the advantages of implementing a Poset as a type class versus a data constructor like in these two things ->
03:41:01 <locallycompact> https://hackage.haskell.org/package/altfloat-0.3.1/docs/Data-Poset.html
03:41:02 <ertesx> EvanR: muzzle said that Language would satisfy the two constraints, which means that there is at least one function that abstracts over Language
03:41:05 <locallycompact> https://hackage.haskell.org/package/HaskellForMaths-0.4.8/docs/Math-Combinatorics-Poset.html
03:41:07 <ski> quchen : the `D' index is just to distinguish it from the "algorithmic" version mentioned later (for some reason called "syntactic")
03:41:20 <ertesx> EvanR: that makes the Language type class "useful" =)
03:41:26 <EvanR> i dont think so
03:41:53 <EvanR> if the constraint is "has an operation" then its not necessarily beneficial as a type class
03:42:03 <Aleksejs> Hi, is there any difference between map f a and [f x | x <- a]? I know that results will be the same, but is there any difference in performance etc?
03:42:11 <EvanR> think of a function that takes a String vs "the constraint" that it HasSomeString
03:42:24 <quchen> ski: Oh, it’s different ways of looking at HM, one is logically correct but not suitable as an algorithm, and Algorithm W is a good alogrithm but logically not as concise?
03:42:25 <ertesx> EvanR: the constraint is: has a function (usually outside of the class) that abstracts over instances
03:42:25 <ski> @undo [f x | x <- a]
03:42:25 <lambdabot> concatMap (\ x -> [f x]) a
03:42:28 <quchen> That would make sense
03:42:31 <ertesx> EvanR: like Monad and replicateM
03:42:40 <ski> Aleksejs : probably not any big difference
03:42:55 <ski> quchen : yeah, something like that
03:42:59 <EvanR> abstracts over instances?
03:43:10 <quchen> ski: I see, thanks.
03:43:12 <ertesx> EvanR: replicateM :: (Monad m) => …
03:43:18 <ertesx> it abstracts over monads
03:43:54 <EvanR> are you say Language has the constraint that it supports replicateM, or how confused are you making me
03:44:15 <ertesx> EvanR: counter-example (a class that isn't "useful" in this sense): Default
03:44:19 <ski> quchen : i suppose the algorithmic version there is called "syntactic", because it's syntax-driven, each rule has a different case of expression in the conclusion of the rule
03:44:29 <EvanR> if we dont have enough information and are making wild suggestions biased toward type classes ok, going back to this paper
03:44:34 <ski> quchen : as opposed to the `Inst' rule in the declarative formulation
03:44:57 <ertesx> EvanR: Default has many instances, but does not provide any functions that abstract over Default
03:45:25 <ertesx> therefore it's only defined for the sake of overloading 'def'
03:45:57 <ski> .. in Cryptol, `zero' can assume any type, so is a bit like a `default' value
03:46:45 <ski> (`zero' on function types constantly give `zero' on the result type, e.g.)
03:46:51 <Aleksejs> ski: so, LC is just a sugar for a >>= return . f ?
03:47:16 <ertesx> ski: i like to use mempty as a more principled 'def'
03:47:17 <ski> Aleksejs : that list comprehension, yes
03:47:33 <ski> ("LC" is usually expanded as "Lambda Calculus" around here, i think)
03:48:17 <ski> Aleksejs : you could probably check generated core from GHC, and see if there's any relevant difference
03:49:05 <EvanR> ertesx: writing functions that operate on any object satisfying interface X is completely a use case for not type classes
03:49:26 <EvanR> so i defer back to use typeclasses when its obviously beneficial
03:50:34 <EvanR> there are things records can do and typeclasses cant do (easily or at all), there are things typeclasses can do but records cant, like the instance resolution thing for type level programming
03:50:50 <EvanR> but the interface pattern comes up in both
03:52:06 <ertesx> EvanR: the two criteria i presented are criteria for "a type class is not useless", not "you should define a type class"
04:04:29 * hackagebot log 0.5.6 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.6 (MikhailGlushenkov)
04:09:29 * hackagebot log 0.5.7 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.7 (MikhailGlushenkov)
04:15:35 <linduxed> hey guys, i'm wondering if there's some standard (maybe even simple) way to do certain function executions concurrently
04:15:42 <linduxed> an example would be to do something like `map (\x -> show $ x * x) [1..100]`
04:15:46 <linduxed> there's no need for that to only run on one core
04:17:01 <linduxed> i get it that it interacting with a list means that things need to run sequentially, but this is why i'm wondering whether there's some monad or whatever that would give me that `mapC` or something
04:17:30 <dsub> linduxed: Take a look at http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
04:18:14 <linduxed> dsub: thanks!
04:22:45 <dsub> np!
04:24:34 <michael[m]1> does anyone have a simple example of using stack to install outside deps either from local directories or git URLs?
04:24:43 <michael[m]1> i've looked at the docs, stack overflow questions, etc. but I just can't get it to work
04:24:54 <michael[m]1> and a correct working example would be really helpful
04:25:38 <liste> michael[m]1: https://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
04:25:58 <michael[m]1> yeah that isn't working for some reason
04:26:17 <michael[m]1> oh nvm. wow. this is stupid.
04:26:43 <michael[m]1> there was just a second "packages" section in my config. I uncommented the example code but also left the blank packages section alone
04:28:48 <sbrg> anyone that can tell me what a BCO is in the context of haskell internals?
04:29:10 <sbrg> aah, i found it. byte-code object, it seems
04:37:32 <dsub> The Math.Statistics lib only work on lists, is there similar libraries for foldables or Data.Sequence's? Or do I need to use toList here? Seems like calculating on sequences would be more efficient than on lists.
04:47:49 <ertesx> dsub: it depends
04:49:05 <ertesx> dsub: the main drawbacks of lists are that they can only be read in order, and that you don't know their length
04:50:03 <ertesx> if that doesn't matter for the algorithm, then lists are probably the best choice (note that you can turn any other structure into a list "for free")
04:51:10 <ertesx> remember that in haskell lists aren't necessarily data structures that live in memory…  in fact, if they do live in memory, you're probably doing something wrong
04:53:22 <dsub> ertesx: thanx. Well, I have a bunch of `Sequence Double` and want to summarize them with some statistics. Going from Sequence to List feels awkward, but might be necessary then.
04:53:39 <ertesx> dsub: what kind of statistics?
04:54:03 <dsub> Means, variance, quantiles. But perhaps some more in the future.
04:55:21 <ertesx> dsub: why Seq?  (i'm assuming Sequence = Seq)
04:56:55 <dsub> Yes Seq. Its because the data is within the state monad wich continually changes from both ends, so need Seq to effectively access both the beginning and end, both for adding and removing elements.
05:10:30 <hexagoxel> is there a specific channel for shake? i wonder if there is a dependencyOnly (the "opposite" of orderOnly) that only cares about the existence of the dependency.
05:11:05 <Guest81360> Hello, simple syntax question: Can I do like this in Haskell (1,2 :xs) with a list where I'm trying to speciy that the first element is 1, the second element is 2 and the rest being the tail?
05:11:25 <hexagoxel> > (1:2:[])
05:11:27 <lambdabot>  [1,2]
05:11:37 <hexagoxel> > (1:2:[3,4,5])
05:11:40 <lambdabot>  [1,2,3,4,5]
05:11:48 <Guest81360> but what if I don't know the tail
05:11:53 <Guest81360> so I want the xs part to be uknown
05:12:19 <Guest81360> I'm writing a lisp interpreter in Haskell which admittedly I don't know too well, thought I could take this chance to learn more Haskell
05:12:21 <Guest81360> Anyway
05:12:57 <Guest81360> i have it in this form eval List(Atom "Lambda", Params []:xs) = eval xs
05:13:28 <hexagoxel> Guest81360: you can always replace [] or [3,4,5] with `xs` given that such binding is in scope..
05:13:46 <Guest81360> Ahh cool, thanks guys:)
05:13:54 <hexagoxel> > let x = [42] in (1:2:x)
05:13:56 <lambdabot>  [1,2,42]
05:14:03 <Guest81360> then I'll try eval... [lambda, params[]: xs]
05:14:11 <Guest81360> thanks alot hex, lambda :)
05:14:52 <hexagoxel> you still have a comma instead of a cons (:)
05:15:11 <hexagoxel> > 1:(2:[])
05:15:13 <lambdabot>  [1,2]
05:15:16 <Guest81360> But won't that mean that my list must be of size 3?
05:15:28 <hexagoxel> :t (:)
05:15:28 <mlehmk> it's e:e:e:l
05:15:30 <lambdabot> a -> [a] -> [a]
05:15:45 <mlehmk> evaluated e:(e:(e:l))
05:16:28 <mlehmk> 1:2:3:[] = 1:2:[3] = 1:[2,3] = [1,2,3]
05:16:55 <hpc> :t (:)
05:16:57 <lambdabot> a -> [a] -> [a]
05:16:59 <ertesx> > you've been thanked
05:17:00 <Guest81360> Right, so [1, 2 : xs] means that xs can be an arbitrary list
05:17:01 <lambdabot>  oh, you're welcome!
05:17:19 <mlehmk> uhm, that syntax seems odd
05:17:27 <mlehmk> 1:2:xs would be what you want I guess
05:17:32 <kuribas> > [1, 2 : []]
05:17:34 <lambdabot>  error:
05:17:35 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M587447728726...
05:17:35 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:17:38 <Guest81360> yup!
05:17:46 <Guest81360> Right awesome, thanks! :d
05:18:09 <Guest81360> Yes there we go!
05:18:11 <Guest81360> Thanks a lot
05:18:16 <ertesx> Guest81360: [x,y,z] = x : y : z : []
05:18:18 <mlehmk> x:xs, where x :: a, xs :: [a]
05:18:33 <Guest81360> Right!
05:18:35 <ertesx> Guest81360: the bracket notation (except the [] case) is syntactic sugar
05:18:51 <Guest81360> Yeah, I actually knew that
05:19:07 <Guest81360> I suppose I just didn't connect the pieces together to use the syntax (1:2:xs)
05:20:36 <kuribas> :i (:)
05:24:31 * hackagebot cryptonite-openssl 0.3 - Crypto stuff using OpenSSL cryptographic library  https://hackage.haskell.org/package/cryptonite-openssl-0.3 (VincentHanquez)
05:28:36 <GLaDER> I am trying to construct an interpreter and I want to create function which takes (among other things) an operator (please see -> http://sprunge.us/TNZB ), however, ghci returns the following -> http://sprunge.us/NWXQ , could someone shed light upon my issue?
05:30:27 <liste> GLaDER: let's look at the type signature, Env -> Exp -> Exp -> (a -> a -> a) -> IO (Value, Env)
05:31:03 <liste> GLaDER: what if I pass (++) as the operator?
05:31:59 <GLaDER> Then another part of the interpreter takes care of that.
05:32:54 <GLaDER> liste: The expression would already be parsed as an EPostIncr.
05:33:04 <hexagoxel> what is the type of `Vint` ?
05:33:12 <liste> GLaDER: but the function tries to do "return (Vint (op a b), renv)" where a and b are Ints
05:33:12 <GLaDER> hexagoxel: Value
05:33:26 <hexagoxel> GLaDER: not _ -> Value?
05:33:37 <GLaDER> hexagoxel: data Value = Vint Integer | Vdouble Double | Vbool Bool | Vvoid                 
05:33:39 <liste> GLaDER: and (++ a b) doesn't type check if a and b are Ints, does it?
05:33:44 <hexagoxel> so Integer -> Value
05:33:51 <liste> GLaDER: ((++) a b) *
05:34:07 <hexagoxel> yet you write (Vint (op _ _))
05:34:12 <GLaDER> liste: ++ a b would not pass the typechecker, no.
05:34:22 <liste> GLaDER: and that's why your function doesn't type check
05:34:39 <pavonia> Also, "res <- op a b" indicates that the result type of op must be monadic (IO in that case), but its type doesn't say so
05:34:40 <hexagoxel> and (op _ _ :: a), not (op _ _ :: Integer)
05:34:46 <GLaDER> liste: Wo. I think we're talking about different things.
05:34:56 <liste> GLaDER: are we?
05:35:09 <liste> GLaDER: if there's a part in your function that doesn't type check, it doesn't type check
05:35:17 <liste> and that line doesn't type check if op == (++)
05:35:20 <GLaDER> liste: When I said that the typechecker won't let it through I meant the TypeChecker I've written that is run before the Interpreter.
05:35:35 <liste> GLaDER: but the compiler doesn't know that
05:35:37 <dxtr> Let's say I have a list of stuff and I basically want to run "foo <$> (first in list) <$> (second in list) .... <$> (last in list)"
05:35:40 <dxtr> How would I do that?
05:35:50 <GLaDER> liste: True
05:35:53 <hexagoxel> liste: whether something typechecks does not depend on the value you pass
05:36:07 <byorgey> GLaDER: the problem is that the type   (a -> a -> a) ...  means that your function can accept *any* argument of type  (a -> a -> a), for any type a
05:36:14 <mlehmk> dxtr, sounds like you just want to map
05:36:23 <GLaDER> byorgey: Why is that a bad thing?
05:36:41 <hexagoxel> GLaDER: because Vint expects and Integer, but all you have is some a
05:36:46 <dxtr> mlehmk: You might be correct, I thought about map but it didn't "feel" right
05:36:55 <liste> hexagoxel: exactly, and that's why if the function doesn't type check if op = (++), it never type checks
05:36:56 <hexagoxel> s/and/an/
05:37:12 <byorgey> GLaDER: because you try to call that function on two ints, but the function might not work on ints, because it could be anything
05:37:18 <mlehmk> dxtr, anyway, <$> doesn't seem right there
05:37:28 <yulax> i'm looking for a 2d image library
05:37:28 <dxtr> mlehmk: It isn't
05:38:16 <yulax> tge task is to draw fractals. the tutorial uses glut, but i need something more customisable, mainly because glut is horrific
05:38:18 <mlehmk> dxtr, also, what shall the result be? [foo (first in list), foo (second in list), foo (third in list)...]
05:38:43 <MarcelineVQ> yulax: are you rendering for real-time or making some image file?
05:38:49 <byorgey> GLaDER: consider this simplified example:   foo :: (a -> a) -> Int -> Int;  foo g = g 3
05:39:09 <dxtr> mlehmk: Actually what I want to do is take a list of names that acts like a hierachy and use xml-conduit to do "child (fromDocument doc) >>= element (first in list) >>= child >>= element (second in list)" and so on
05:39:15 <byorgey> GLaDER: see if you can understand why foo does not type check.  It is the same problem.
05:39:20 <GLaDER> liste, byorgey, hexagoxel: So... I think I get the issue. Is there a simple way around it or do I have to make separate functions for the different types of Value?
05:39:32 * hackagebot obdd 0.5.0 - Ordered Reduced Binary Decision Diagrams  https://hackage.haskell.org/package/obdd-0.5.0 (JohannesWaldmann)
05:39:50 <byorgey> GLaDER: you either have to make separate functions for the different types of value, or use a GADT so that Exp values are indexed by their type.
05:39:57 <mlehmk> dxtr, ahh, that question is better, but that's too much for me for now
05:40:07 <byorgey> GLaDER: the second is cooler but the first is simpler, especially if you don't know about GADTs yet.
05:40:09 <GLaDER> byorgey: wo, GADT, that sounds above my level of Haskell...
05:40:17 <GLaDER> byorgey: Noted!
05:40:53 <hexagoxel> what about RankNTypes?
05:40:54 <MarcelineVQ> yulax: have a look at JuicyPixels and see if that's near what you'd like, it can load and save various formats but also provides methods for working with an image directly
05:40:55 <dxtr> mlehmk: I didn't quite know how to formulate my question :p
05:41:11 <hexagoxel> byorgey: or is this not a good suggestions?
05:42:22 <hexagoxel> evalArithmetic :: Env -> Exp -> Exp -> (forall a . Num a => a -> a -> a) -> IO (Value, Env)
05:43:01 <pavonia> hexagoxel: That won't work with Bool
05:44:17 <hexagoxel> yeah, for the second function the constraint would be Ord instead of Num
05:44:52 <GLaDER> hexagoxel: What does the forall part do?
05:45:13 <GLaDER> I get an error w/ ghci asking me if I'm intending to use RankNTypes, but it claims '.' is illegal.
05:45:41 <liste> that forall requires RankNTypes
05:48:01 <hexagoxel> GLaDER: RankNTypes (the forall in the signature) changes who gets to choose the specific type. so where you have an error because the caller determines `a`, the forall in this position lets you decide (but now the caller has to provide a function that works with all a).
05:48:18 <hexagoxel> which is fine, because
05:48:20 <hexagoxel> :t (*)
05:48:21 <lambdabot> Num a => a -> a -> a
05:48:30 <hexagoxel> is already polymorphic
05:49:13 <GLaDER> hexagoxel: but (/) seems to cause issues due to being Fractional?
05:49:15 <GLaDER> :t (/)
05:49:16 <lambdabot> Fractional a => a -> a -> a
05:49:34 <hexagoxel> good point
05:50:09 <GLaDER> hexagoxel: Well, maybe I wanted to be cooler than I could handle :D
05:50:19 <hexagoxel> so replace Num with Fractional
05:50:50 <hexagoxel> no that won't work, oops
05:50:55 <GLaDER> hexagoxel: That'll cause issues for the ins.
05:51:00 <hexagoxel> right
05:51:01 <GLaDER> ints*
05:51:43 <pavonia> Why no just drop the constraint?
05:52:03 <hexagoxel> because the caller will have to provide (a -> a -> a) then
05:52:34 <hexagoxel> (which has no sensible implementations)
05:55:31 <hexagoxel> GLaDER: even though my suggestion was not thought through, it at least points to the interesting question: what _do_ you want to happen for "division" on Integers?
05:56:14 <GLaDER> I want to use (div).
05:56:27 <GLaDER> So that is a flaw in my original code.
05:56:28 <hexagoxel> which won't work for Doubles
05:56:50 <GLaDER> hexagoxel: Exactly. Which makes me more and more sure that my "general function" approach is biting back at me.
05:58:12 <hexagoxel> (for evalComparison the RankNTypes path still seems to work, though.)
05:58:30 <GLaDER> That might do!
05:58:39 <GLaDER> Thank you for your help (all of you) regardless!
06:02:15 <hexagoxel> :t [((+), (+)), ((-), (-)), ((*), (*)), ((/), div)]
06:02:17 <lambdabot> (Integral a1, Fractional a) => [(a -> a -> a, a1 -> a1 -> a1)]
06:14:34 * hackagebot yeshql 0.3.0.3 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-0.3.0.3 (TobiasDammers)
06:14:52 <mlehmk> How could I develop in a language that is intrinsicly monadic all that time?
06:20:29 <quchen> mlehmk: Put everything in Identity.
06:23:22 <hexagoxel> all "imperative" languages are implicitly monadic all the time. here it is explicit, and only where necessary.
06:23:59 <mlehmk> hexagoxel, indeed
06:28:14 <sm> mlehmk: very.. carefully..
06:28:31 <okuu> hexagoxel: All strict languages are intrinsically monadic, even if they have no effectful operations.
06:28:51 <ski> okuu : even total ones ?
06:29:04 <okuu> ski: Then the monad is the identity monad.
06:29:10 <okuu> the monad in* question*
06:29:18 <ski> that's trivial
06:29:22 <okuu> Dunno the situation for non-strict languages, though.
06:29:34 <ski> you could just as well say that it's comonadic, with the `Identity' comonad
06:29:58 <tdammers> all the "strict" languages I can think of have at least some non-strict features
06:30:30 <ski> "non-strict features" being what ? `if' and short-circuiting boolean operators ?
06:30:45 <ski> by-name arguments ?
06:30:59 <okuu> I wouldn't call “if” a non-strict feature. “if” isn't a function. It's syntactic sugar for pattern-matching on “bool”.
06:31:01 <ski> backtracking ?
06:31:10 * ski agrees with okuu
06:40:08 <kuribas> is there a lightweight parsing library?  Or do I need parsec to parse a simple string?
06:40:29 <kuribas> Perhaps Text.Regex...
06:41:12 <EvanR> parse, simple, lightweight, regex (?)
06:41:28 <bartavelle> kuribas, takeWhile :)
06:41:40 <EvanR> would be surprised if that was the answer
06:41:51 <bartavelle> well, that sure is lightweight!
06:42:05 <kuribas> bartavelle: yeah, maybe just Data.Char and Data.List
06:42:38 <ski> @type span
06:42:39 <bartavelle> I often use break and span
06:42:39 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
06:43:08 <bartavelle> then there is ReadP
06:43:13 <bartavelle> which is in base, and nobody uses
06:43:52 <MarcelineVQ> I used reads once, had a good time
06:44:39 <sm> kuribas: if you need actual regexps, regexpr is not bad
06:45:07 <kuribas> I need to parse "unixxxx", where x is a hex-number.
06:45:21 <byorgey> I think ReadP in base is actually a good choice for a very lightweight parsing library
06:45:28 <kuribas> it seems overkill to import parsec just for this.
06:46:16 <ski> @hackage parsek
06:46:17 <lambdabot> http://hackage.haskell.org/package/parsek
06:46:29 <byorgey> I used it in an xmonad module: http://hackage.haskell.org/package/xmonad-contrib-0.12/docs/src/XMonad-Util-EZConfig.html#parseKey
06:47:52 <bartavelle> kuribas, what kind of string is that ? String or Text ?
06:48:03 <kuribas> String
06:48:15 <bartavelle> ah, not as easy
06:48:50 <ocramz> hi all!
06:49:50 <kuribas> I'll just go with isPrefixOf, and foldl, drop, length, etc...
06:50:47 <ski> @type stripPrefix
06:50:49 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
06:50:59 <ski> > stripPrefix "foo" "foobar"
06:51:01 <lambdabot>  Just "bar"
06:51:50 <kuribas> :i stripPrefix
06:52:19 <bartavelle> :t stripPrefix "unix" >=> fmap fst . headMay . readsPrec 0
06:52:21 <lambdabot> error:
06:52:21 <lambdabot>     Variable not in scope: headMay :: [(a0, String)] -> Maybe (c, b0)
06:52:25 <bartavelle> ah :(
06:53:38 <bartavelle> also it should include something like "filter (null . snd)"
06:57:14 <ski> @src reads
06:57:14 <lambdabot> reads = readsPrec minPrec
06:57:17 <ski> @src minPrec
06:57:17 <lambdabot> Source not found. You type like i drive.
06:57:21 <ski>   minPrec = 0
06:57:26 <bartavelle> ah that would be nicer yes
06:57:51 <ocramz> How are Arrays from GHC.Arr represented in memory? Do they have O(1) read access like Vector?
07:15:31 <byorgey> ocramz: yes, they have O(1) read access
07:17:05 <kuribas> can haskell character represent characters from the SMP?
07:17:44 <kuribas> > chr 0x10000
07:17:46 <lambdabot>  '\65536'
07:19:02 <EvanR> yes
07:19:04 <tdammers> yes, it covers the entire range of code points
07:19:17 <EvanR> all of unicode, but no more
07:19:25 <tdammers> obviously
07:19:29 <EvanR> heh
07:19:58 <EvanR> > chr 1114111
07:20:00 <lambdabot>  '\1114111'
07:20:02 <EvanR> > chr 1114112
07:20:04 <lambdabot>  *Exception: Prelude.chr: bad argument: 1114112
07:20:53 <tdammers> in a way you could say that they *can* represent more than Unicode, but they don't *want* to
07:20:58 <EvanR> one might think a Char is just a word in sheeps clothing, but luckily its done right and were protected from clever usage of 1114112
07:21:40 <tdammers> > Data.Text.pack [chr 1114111]
07:21:42 <lambdabot>  error:
07:21:42 <lambdabot>      Not in scope: ‘Data.Text.pack’
07:21:42 <lambdabot>      No module named ‘Data.Text’ is imported.
07:22:20 <EvanR> > 2^21
07:22:23 <lambdabot>  2097152
07:22:27 <EvanR> > 2^20
07:22:29 <lambdabot>  1048576
07:22:32 <EvanR> hrm
07:23:11 <EvanR> > 17 * 65536
07:23:12 <lambdabot>  1114112
07:23:13 <MarcelineVQ> @define import Data.Text
07:23:15 <lambdabot>  Defined.
07:23:33 <tdammers> oh, that's how that works
07:23:38 <tdammers> > Data.Text.pack [chr 1114111]
07:23:40 <lambdabot>  "\1114111"
07:23:54 <tdammers> > Data.Text.take 1 $ Data.Text.pack [chr 1114111]
07:23:55 <MarcelineVQ> yes, though I'm not sure why you have to now, I feel like there used to be more available in scope by default
07:23:55 <EvanR> wtf is up with the number 17 here
07:23:56 <lambdabot>  "\1114111"
07:24:44 <EvanR> were they like... well we already have a plane, might as well add a round number 16 more
07:24:58 <byorgey> EvanR: it's something to do with how UTF-16 can start with any of 00..10 (hex)
07:25:01 <kuribas> EvanR: probably :)
07:25:17 <kuribas> byorgey: right :)
07:25:33 <EvanR> utf16 explains all the things
07:29:01 <kuribas> Does anyone happen to know a database of unicode ligatures?
07:33:58 <EvanR> the unicode site has "databases" in the form of PDFs for anything unicode
07:34:04 <EvanR> at least
07:35:20 <EvanR> https://en.wikipedia.org/wiki/List_of_precomposed_Latin_characters_in_Unicode
07:36:28 <EvanR> ligated forms of indian scripts... not in unicode
07:39:27 <bl1nd-tmux> I'm learning Haskell with a course that is mainly theoretical. There's a lot of content before getting to the monads part that will let me make real programs so, which set of online exercise would you recommend me to do?
07:39:37 * hackagebot propellor 3.2.3 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.2.3 (JoeyHess)
07:40:01 <bl1nd-tmux> I want to do exercises mainly for keeping the course stuff fresh
07:43:08 <ski> @where CIS194
07:43:08 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
07:43:16 <ski> bl1nd-tmux ^ perhaps
07:44:25 <ski> @where Typeclassopedia
07:44:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:44:33 <ski> could also be useful, later
07:45:40 <sm> bl1nd-tmux: exercism.io is good
07:45:43 <ski> bl1nd-tmux : also this channel (and #haskell-beginners) would possibly be good to frequent
07:45:52 <sm> also project euler
07:55:54 <yulax> MarcelineVQ: thanks
07:56:10 <yulax> i do need to export images, so it looks ok
07:56:42 <bollu> how do I make an Int into a CInt?
07:59:32 <pavonia> bollu: toEnum
08:00:03 <bollu> pavonia: wait, what?
08:00:04 <bollu> seriously?
08:00:14 <bl1nd-tmux> sm, ski: thank you
08:00:36 <pavonia> bollu: At least that's what I've seen being used for the various C types
08:00:41 <bollu> pavonia: huh, wow, what the hell
08:00:50 <sm> bl1nd-tmux: np
08:00:58 <bollu> pavonia: thanks :)
08:01:33 <pavonia> I hope someone corrects me if this is actually is bad practice
08:01:52 <UnrealQuester> i think fromIntegral works as well
08:03:00 <bollu> also, if I'm binding to a C library that returns error codes (think OpenGL for an example)
08:03:05 <bollu> what is the best way to report errors?
08:03:08 <bollu> custom Either monad?
08:03:14 <bollu> some form of Exception monad?
08:03:17 <bollu> MonadThrow?
08:03:30 <bollu> I need help with API design
08:05:27 <bartavelle> it really depends on the kind of API this is :/
08:05:48 <bartavelle> readFile throws exceptions because you don't have to deal with all the possible errors with open and the all the reads
08:05:57 <bartavelle> s/the/then/
08:06:17 <bollu> this is a symbolic math library, where you maybe interested in handling things like divide-by-zero and stuff
08:06:24 <bollu> (I'm binding symengine)
08:07:11 <EvanR> bollu: heh, opengl doesnt return error codes... it sets a global errno-like thing that you ambiguously should and shouldnt constantly check
08:07:40 <bollu> EvanR: right, borked example, sorry
08:07:59 <bartavelle> bollu, there seems to be bindings already ( https://github.com/symengine/symengine.hs )
08:08:15 <tsani> Is there a standard trick for simulating product kinds?
08:08:40 <bollu> bartavelle: yes, I'm authoring them :)
08:09:02 <bollu> bartavelle: it was supposed to be my gsoc project this year, but things got in the way :P now that college is winding down, I'm re-starting the bindings
08:09:05 <tsani> Actually, with TypeInType, do we even have to simulate them?
08:09:06 <bollu> I want to bind this: https://github.com/symengine/symengine/blob/master/symengine/cwrapper.h#L473
08:09:23 <c_wraith> tsani: you can promote the type (,) to the kind level.  Does that not serve your needs?
08:09:36 <bollu> bartavelle: https://hackage.haskell.org/package/symengine
08:09:53 <bartavelle> ah!
08:09:55 <tsani> c_wraith: I think that's all I need actually.
08:09:58 <tsani> Thanks
08:10:11 <c_wraith> tsani: you only need -XDataKinds for that.
08:11:48 <[exa]> Hm guys. I recently came back to an idea of type tags, similar to this old post: https://mail.haskell.org/pipermail/haskell-cafe/2009-December/070579.html
08:12:08 <bartavelle> bollu, I would say it's ok to expose raw bindings, that return error code and work on pointers, in some sort of .Foreign module, then write a higher level interface on top of this
08:12:33 <[exa]> Basically, letting the compiler check "this string was checked" or "this type is meant to be a number, whatever it has inside"
08:13:12 <[exa]> Q: it has been 8 years since the post, what would you recommend to use now to gain this functionality?
08:13:25 <bartavelle> bollu, I kind of did that in hruby (except I think nobody uses this module but me), where Foreign.Ruby has easy to use functions that are made with groups of functions from Foreign.Ruby.Bindings
08:14:27 <[exa]> at the moment I've got just a "marker" datatype, like data Checked a = Checked a , but struggle when I need functions to work "transparently" on Checked values
08:15:01 <c_wraith> [exa]: In general, I'd argue that it's a good thing that those are different types that aren't compatible. It prevents you from doing the wrong things with them.
08:15:42 <c_wraith> [exa]: In the case you suggest, though, it's trivial to create a Functor instance for Checked and then use it to perform operations under the Checked type constructor.
08:16:05 <[exa]> c_wraith: from a practical perspective, checked and unchecked strings can be manipulated the same way, and writing 2 versions of _all_ string functions only increases the chance to err.
08:16:27 <c_wraith> [exa]: that's why you don't write two versions, you just use fmap.
08:16:42 <bartavelle> [exa], well for number-like things you have a hierarchy of type classes
08:17:50 <[exa]> bartavelle: typeclasses aren't sufficient for this case AFAIK, both "string" versions need to have the same type classes. I'd need typeclasses with granularity to variables.
08:17:52 <bartavelle> bollu, my "design principle" was to start with the raw bindings, and factor out the patterns I noticed in my own code into the library. The API of hruby is terrible, so that might not be awesome ;)
08:18:02 <c_wraith> [exa]: and for more complex cases, you can use things like ala from lens to operate under multiple values with wrappers.
08:18:14 <[exa]> c_wraith: hmm that'd probably do
08:18:22 <c_wraith> [exa]: But in reality, I would use exactly none of those techniques.
08:19:21 <c_wraith> [exa]: it's more important to provide semantic operations that make sense on Checked values - I'd move away from manipulating them arbitrarily, and just provide a limited number of semantically-valid primitive transformations on them
08:20:26 <[exa]> c_wraith: that's a valid point as well. But let's say that eg. (Checked a) ++ (Checked b) would produce an unchecked value.
08:21:03 <lgstate> "lein localrepo" <-- localrepo is not a task <-- how do I install localrepo ?
08:21:24 <c_wraith> [exa]: There's another option, though.  You could go really exotic and use Liquid Haskell to create a custom measure for Checked, and then document what transformations preserve it, remove it, and introduce it.  If liquid haskell was more solid, that'd be a really pleasant approach, but it's not exactly production quality yet.
08:21:26 <[exa]> (I'm not trying to be practical yet, I'm just trying to design some other type system... take this more like a type-system-limitation discussion :] )
08:21:35 <c_wraith> lgstate: this isn't a clojure channel.
08:21:48 <lgstate> c_wraith: this is #haskell; sorry
08:22:05 <[exa]> whoa, didn't know about Liquid.
08:22:07 <c_wraith> [exa]: in that case, you should definitely look at refinement types, like liquid haskell or F*
08:22:39 <c_wraith> Refinement types are really cool, especially when combined with an SMT solver to make them easier to use.
08:22:49 <c_wraith> But they're still rather experimental.
08:23:06 <bollu> bartavelle: interesting, I'll try that
08:24:00 <[exa]> c_wraith: I'm reading the Liquid tech report... it seems quite related to Henk2000 and sage maybe
08:24:41 <c_wraith> sadly, liquid haskell has issues in that the integration between refinement types and type classes doesn't have a good solution yet.
08:26:33 * [exa] stashes up new reading material
08:26:38 <[exa]> c_wraith: thanks a lot! :]
08:27:28 <javjarfer> hi there! I have found myselft writing the same thing at both sides of a "case of" any syntactic sugar for avoid such repetition??
08:27:29 <c_wraith> [exa]: yeah, misunderstood your goal initially.  There's definitely room to improve upon what Haskell does for that in a different type system.
08:28:00 <c_wraith> javjarfer: usually there is, but the mechanism will depend on what type it is.
08:28:17 <ahihi> as-patterns often help
08:28:43 <bollu> javjarfer: PatternSynonyms?
08:28:50 <[exa]> c_wraith: I'm actually implementing a compiler of something like "functional C"
08:29:09 <javjarfer> c_wraith, the problem is that is a tuple with a Either inside, so... I haven't found anything for that
08:29:57 <[exa]> c_wraith: it already works with no garbage collector, can run any lambda-based computation, but the added level of complexity (hidden allocations etc) are placing new requirements on the type system
08:30:46 <c_wraith> [exa]: are you also taking into account how Rust does things?  That seems relevant for some of those issues.
08:31:46 <[exa]> c_wraith: yeah, but rust is not a good way. They had to sacrifice safety for performance
08:32:02 <javjarfer> bollu, of course that could be a solution... but I wanted to go for standard Haskell, because the only extension I needed for the tiny parser I'm writing have been FlexibleInstances... I wouldn't like to need a second one just for syntax... xD
08:33:30 <bollu> javjarfer: get with the times, DataKinds, GADTs, MultiParamTypeClasses, I'm sure PatternSynonyms won't hurt ;)
08:34:08 <c_wraith> javjarfer, have you looked at Data.Bifunctor?
08:34:41 <c_wraith> javjarfer, it seems likely to be able to help, as both (,)  and Either are instances of it. 
08:35:35 <javjarfer> bollu, yes... it isn't  for anything in special, just for portability reasons, when I found things like this "https://github.com/purescript/purescript/issues/1667" I feel like... ish... maybe I could go without it 
08:36:12 <javjarfer> c_wraith, wow! I'm going to look thanks!
08:42:23 <danilo2> Hello guys! Could anybody explain to me why existential datatypes cannot be newtypes? Why cannot I have sometihngl ike newtype Hidden where Hidden :: a -> Hidden  ?
08:44:39 * hackagebot config-ini 0.1.1.0 - A library for simple INI-based configuration files.  https://hackage.haskell.org/package/config-ini-0.1.1.0 (gdritter)
08:44:46 <paolino> danilo2, that's GATDs syntax
08:45:16 <danilo2> paolino: I know, I was asking why GHc doesnt allow newtypes with existential qualification. This gadts syntax is equivalent to it
08:45:26 <danilo2> paolino: I think syntax doesnt matter here, does it ?
08:45:39 <paolino> newtype H = forall a . H a 
08:46:37 <danilo2> paolino: it is exactly the same, thats just another sytnax for the same thing
08:46:48 <danilo2> paolino: and its not allowed 
08:47:00 <glguy> danilo2: There doesn't seem to be any particular theoretical reason that newtypes can't have existentially quantified type variables in them : http://stackoverflow.com/questions/5890094/is-there-a-way-to-define-an-existentially-quantified-newtype-in-ghc-haskell?rq=1
08:47:14 <glguy> and in fact Hugs allows it
08:47:45 <danilo2> glguy: hmm, very interesting! In fact it would be very usefull, because it would allow us to hidesome variables without any runtime overhead
08:48:16 <danilo2> glguy: do you know if it is planned for ghc? I see myself looking for something like that several times in the pas, always defaulting to just datatypes
08:48:36 <glguy> danilo2: I haven't heard a thing about it being considered or not
08:48:37 <danilo2> glguy: I'd be happy to describe it on track if not only me thinks it is useful
08:49:35 <javjarfer> c_wraith, ... ish, not so useful in this case, I would need to much reformatting to use that properly
08:50:14 <glguy> danilo2: More important than someone asking for it will be someone implementing it. People have talked about it in the past
08:51:02 <danilo2> glguy: I dream to have some more time in my life than ive got currently and I really love the idea to contribute to ghc 
08:51:19 <danilo2> I've done it al ittle in the past, still I'm running a startup and putting all my time in it
08:51:41 <danilo2> glguy: when we release things to the public (and a lot of people are waiting for it) I hope to find more time
09:20:31 <cloudhead> is it possible to make a functor instance of a type 'Rect f a = (f a) (f a)' that operates on the (f a)s instead of the 'a's?
09:21:44 <Cale> cloudhead: no. If there's to be a Functor instance for Rect f, it has to act on the a's
09:22:21 <Cale> But also, that line isn't quite syntactically correct in the first place, I'm assuming you meant to write something like  data Rect f a = Rect (f a) (f a)
09:22:57 <Cale> You could write  data Pair t = Pair t t
09:23:33 <Cale> and then the Functor instance for Pair will apply the function to the two components, and Pair (f a) will be isomorphic to the type you wanted.
09:24:50 <cloudhead> Cale: yeah sorry that's what I meant
09:25:30 <cloudhead> Cale: hmm ok that's what I thought, thanks
09:30:16 <Cale> cloudhead: If we could deal better with functors between other categories in Haskell (like with Ed Kmett's experimental Hask library), then there would be a more interesting answer than that.
09:30:46 <Cale> You could imagine applying a *natural transformation* f -> g to obtain a map Rect f a -> Rect g a
09:32:45 <Cale> which would itself give the components of a natural transformation Rect f -> Rect g
09:33:47 <cloudhead> Cale: right, that's kind of what I was hoping for, since 'Rect f a' has more information than 'Rect a' where 'a' is 'f a'
09:34:11 <Cale> So, Rect can be viewed as a functor, not on the category Hask of Haskell types and functions, but on the category of endofunctors on Hask and natural transformations between them.
09:34:13 <cloudhead> or at least it seems less generic of a type
09:34:45 <Cale> However, talking about that kind of thing involves a bunch of fancy machinery which we don't have in the Prelude, to say the least
09:35:18 <Cale> (and Ed's been working hard to get GHC bugs fixed so that his Hask library will actually typecheck :D)
09:35:20 <Cale> https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs
09:35:24 <cloudhead> aha I see
09:36:49 <Cale> (What I linked there is some arbitrary version, I have no idea if it's really the most current or what)
09:38:16 <cloudhead> it's all pretty much over my head at the moment anyway :)
09:38:38 <napping> Is anyone here using gi-gtk, especially with glade?
09:39:32 <MarcelineVQ> cloudhead: I've seen Rect asked about recently, is this an exercise?
09:40:01 <cloudhead> MarcelineVQ: heh no, it's part of a game I'm building
09:40:39 <cloudhead> not sure what exercise that could be, but I guess it's pretty common to call rectangles 'rect' in graphics programming
09:42:28 <MarcelineVQ> I could imagine "`data Rect a = a a a a` implement a Functor instance for Rect" as an exercise
09:43:05 <MarcelineVQ> someone'd probably call it Quad or something though :>
09:43:10 <MarcelineVQ> or Four
09:43:42 <Cale> Yeah, this was a different one, data Rect f a = Rect (f a) (f a)
09:44:42 <MarcelineVQ> Yep was asking in case it was an exercise that was being approached oddly
09:47:15 <napping> cloudhead: what are you using for graphics?
09:49:41 * hackagebot electrum-mnemonic 0.1.3 - easy to remember mnemonic for a high-entropy value  https://hackage.haskell.org/package/electrum-mnemonic-0.1.3 (JoeyHess)
09:51:59 <cloudhead> napping: I have a library wrapping openglraw at the moment
09:53:17 <cloudhead> I'm using bits and pieces from ekmett's quine library too
09:56:32 <andrei_> test
09:57:13 <andrei_> Hi! Di you know which companies uses Haskell in production ?
09:59:36 <glguy> andrei_: You can start with the wiki https://wiki.haskell.org/Haskell_in_industry
10:00:08 <andrei_> thanks !
10:03:01 <mmaruseacph2> some of them are also mentioned in HCAR
10:03:11 <mmaruseacph2> (which I should release by end of week, hopefully)
10:16:03 <sm> thanks mmaruseacph2 
10:19:43 * hackagebot log 0.6 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.6 (MikhailGlushenkov)
10:23:12 <orion> https://riot.im/app/#/directory <-- #haskell shows up here as the number one result.
10:25:23 <orion[m]> test
10:25:31 <orion> test
10:26:13 <glguy> orion: This isn't a test channel
10:28:02 <orion> glguy: Apparently #haskell is the most popular channel on Riot, and I find that interesting.
10:29:06 <wamaral> orion: it's the most populated among the linked ones
10:32:28 <stevenxl> what's riot?
10:33:18 <orion> It's a messaging application. Not really relevent to the topic of this channel (except for the fact that it's the #1 result in their directory).
10:34:43 * hackagebot ua-parser 0.7.2 - A library for parsing User-Agent strings, official Haskell port of ua-parser  https://hackage.haskell.org/package/ua-parser-0.7.2 (MichaelXavier)
10:40:23 <ph88> does anyone know if it's possible to use GHC.Generics to figure out which types are used in a product type ?
10:40:25 <joe9> is it possible to derive Arbitrary on Generics? generate different types of data types?
10:40:54 <joe9> ph88: I think you have to drill down to conName or selName
10:41:12 <ph88> joe9, it's possible to automatically derive Arbitrary
10:42:21 <joe9> ph88: as you are working with generics, https://www.andres-loeh.de/DGP-Intro.pdf is awesome.
10:42:23 <ph88> can GHC.Generics provide the same information as SYB ?
10:42:43 <ph88> cool
10:43:12 <joe9> ph88: https://github.com/joe9/GenericPretty/blob/master/src/Text/PrettyPrint/GenericPrettyStructure.hs this might help.
10:44:40 <joe9> ph88, https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Generics.html is also very helpful. you can get DataType from D, Constructor from C, and Selector from C
10:44:52 <geekosaur> one would hope so, since SYB is implemented on top of them
10:45:12 <geekosaur> as is explicitly stated at the top of the haddock for GHC.Generics
10:45:39 <ph88> eh SYB was before GHC.Generics afaik
10:45:56 <geekosaur> it was, yes. as ghc's support has evolved, SYB has evolved to use that support
10:46:16 <joe9> ph88: this is good too http://dev.stephendiehl.com/hask/#generics
10:46:21 <geekosaur> ...in fact SYB drove that evolution
10:46:25 <ph88> so SYB is as fast as GHC.Generics now or what ?
10:46:44 <ph88> (on runtime)
10:47:20 <ertesx> edwardk: ad question: i understand that the the .Rank1.* variants have less type-level protection, but why are they so much faster, too?  the automatic derivative of the logistic function using .Rank1.Forward.Double is almost as fast as a hand-written implementation (167ns vs. 126ns)
10:48:42 <napping> geekosaur: it doesn't look like it's very closely implemented on GHC.Generics
10:48:43 <geekosaur> ph88, it should be. basically "so how do we make this faster? we need support from GHC" (develops first generation of GHC generics) "this is good but it could be better" (develops current generation)
10:49:00 <ertesx> edwardk: with the safer variants i get 860ns (Numeric.AD) and 350ns (.Forward.Double)
10:49:02 <geekosaur> hm. maybe the comment is out of date and they split with it then. which would be their loss...
10:49:05 <napping> Data.Data still explicitly defineds gunfold on a lot of types and such
10:49:11 <geekosaur> (or, they haven't updated)
10:49:46 <ph88> i only care for runtime performance atm
10:49:53 <ertesx> "gunfold" =)
10:50:09 <geekosaur> ah, make sure that's actually relevant. syb explicitly supports older ghcs that do not have GHC.Generics
10:50:28 <geekosaur> it may still implement gunfold for ghcs that can't derive it
10:50:53 <napping> syb-0.6?
10:51:13 <geekosaur> (and potentially it wraps the derived one to make supporting older ghcs a bit less insane)
10:51:19 <geekosaur> yes
10:51:38 <napping> It's entirely based on Data.Data
10:51:47 <geekosaur> syb-0.6 README: "Scrap Your Boilerplate (SYB) is a library for generic programming in Haskell. It is supported since the GHC >= 6.0"
10:52:12 <geekosaur> Data.Data wasn't around in 6.6 iirc, and was more limited than the current implementation for several versions
10:52:24 <napping> It's a different system than GHC.Generics
10:54:10 <ph88> what do they mean here with "typeclasses are usually implemented as dictionaries"  https://www.andres-loeh.de/DGP-Intro.pdf
10:55:18 <geekosaur> uh. you were not aware of that? how did you think typeclasses work?
10:55:54 <napping> a typecase is possible too
10:56:04 <joe9> ph88: also check out cooking-generics blog post of sdiehl. it is good.
10:56:21 <geekosaur> only if the types are statically known. since you can compile a library and then add an instance later, that's not possible
10:56:30 <ph88> oh they talking about ghc details or what ?
10:56:51 <napping> "dictionary" for typeclasses means making a record holding a function for each of the methods
10:57:04 <napping> and turning typeclass constraints into passing around dictionary argumetns
10:57:09 <geekosaur> when you write (Foo x) => ..., there's a reason it looks a bit like a parameter: it is. the parameter is a dictionary: a map from (type, class function) to implementation
10:57:38 <napping> hopefully it gets optimizied and inlined away once you know the types
10:57:39 <geekosaur> or, since it knows the methods statically, it can use a record (but types can't be known statically since typeclasses are open)
10:58:06 <geekosaur> sometimes it can be; often it can't
10:58:20 <geekosaur> unless you go the whole-program-compiler route
10:58:44 <napping> or the other way, when definitions are inlined
10:59:20 <c_wraith> even if you go for whole program compilation, sometimes you need to pass a dictionary anyway, thanks to polymorphic recursion 
10:59:52 <geekosaur> yep
11:00:28 <roboguy`> c_wraith: I've heard there''s a non-dictionary passing way to do that, but I've never quite understood how it works (maybe I haven't heard a complete explanation, actually)
11:00:57 <joe9> Is it possible to derive Arbitrary instances for Rep a? I wrote a generic pretty printing library. I am wondering if I can generate the data types using quick check for the test cases.
11:01:27 <c_wraith> I'm sure you can optimize it cleverly, but it's still going to be some sort of behavior parameterized on a runtime value. 
11:02:17 <roboguy`> c_wraith: well, I mean not using dictionaries to implement type classes at all
11:02:21 <ph88> joe9, you see any reason that's not posslbe? i think it's possible
11:02:51 <roboguy`> I think augustss said one of his Haskell compilers didn't use dictionary passing for type classes at all
11:02:57 <napping> geekosaur: -ddump-deriv shows GHC implementing Data and Generic independently
11:03:20 <napping> roboguy`: I think that compiler dropped laziness or polymorphic recursion or something
11:03:20 <c_wraith> roboguy`, I suspect it'd break down when combined with higher-rank polymorphism 
11:03:43 <napping> I think JHC did something different
11:03:55 <napping> The runtime value you pass can be an explicit representation of a type
11:04:38 <c_wraith> I don't think you can do higher-rank polymorphism over an ad-hoc polymorphic type variable without something equivalent to dictionary passing. 
11:05:25 <napping> and yes, that needs at least some sort of fancy linking and maybe open types, and probably whole-program compilation
11:06:00 <napping> c_wraith: If you just need polymorphic recursion, it doesn't need to be very equivalent
11:07:09 <napping> data Type = ListOf Type | Char | ...; showImpl :: (t:Type) -> t -> String; showImpl (ListOf t') l = showList (showImpl t') l; showImpl Char c = showChar c; ...
11:07:34 <c_wraith> but when you want RankNTypes, I think you do end up equivalent to dictionary passing. 
11:08:08 <napping> It would need a trickier type represenation, if you can even expect instances on explicitly quantified types to work properly
11:08:32 <joe9> ph88: the Rep a is distinct for every data type. I doubt it can be generated using Arbitrary.
11:08:33 <napping> I think it's still pretty different to pass one representation of a type, rather than a vector of functions
11:09:21 <napping> joe9: You would make instances of the specific types that are used to define type instance Rep t = ... for your types
11:09:28 <ph88> joe9, i wrote a polymorphic instance of Arbitrary .. when you have Rep a then you need to make sure that there is an instance Arbitrary a
11:11:46 <joe9> ph88: napping, ok. Thanks. will try it.
11:12:13 <ph88> joe9, Arbitrary a needs to be constrained by a typeclass
11:12:15 <napping> the GHC.Generics haddocks have a decent example
11:13:02 <napping> you'll end up with somethig like genArbitrary :: (Generic a, Arbitrary (Rep a)) => Gen a
11:13:16 <napping> probably already defined somewhere, actually
11:14:01 <napping> given instances like (Arbitrary a, Aribtrary b) => Aribitrary (a :+: b), the constraint Arbitrary (Rep a) should basically simplify down to requiring Arbitrary on each type contained in the value
11:14:11 <ph88> joe9, i am/was using uniplate but it gets stuck so now i'm looking at GHC.Generics
11:14:17 <joe9> napping found it. The instance is defined.
11:14:19 <napping> or rather, each type mentioned in the type
11:14:34 <napping> oh, where is it?
11:14:37 <joe9> http://codepad.org/NSKbzX4m
11:14:43 <joe9> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/src/Test-QuickCheck-Arbitrary.html#Arbitrary
11:14:45 * hackagebot rotating-log 0.4.2 - Size-limited, concurrent, automatically-rotating log writer.  https://hackage.haskell.org/package/rotating-log-0.4.2 (MichaelXavier)
11:17:31 <napping> I don't see it
11:18:48 <napping> There are genericCoarbitrary and genericShrink functions, but I don't see one for arbitrary
11:18:59 <ph88> joe9, do you know if it's possible to use GHC.Generics to implement something like biplate ?
11:19:40 <napping> ph88: You can probably hope for better performance with GHC.Generics
11:19:59 <ph88> well uniplate is not performing reliable atm
11:20:26 <napping> In particular, if you define another typeclass, and have helper functions (or default instances) for implementing that class from Generic, you can check that those instances are optimizing down to reasonable code
11:21:34 <ph88> napping, i was looking for a way to traverse a structure and only change one particular type
11:22:03 <napping> That I don't remember, I think deciding whether you have reached that type can be tricky
11:22:57 <atum> https://thepasteb.in/p/wjh05BXyglrfv
11:23:23 <ph88> napping, joe9 was saying earlier i could look at selName or conName ..
11:23:33 <joe9> napping: yes, the arbitrary instance for U1 is not there. It is defined with #def no_generics section
11:23:37 <ph88> i only wonder .. will i be comparing strings at that point ?
11:23:59 <napping> Did you try the functions from lens to check performance?
11:24:19 <atum> my code is giving parse error input in the first !
11:24:22 <atum> |
11:24:27 <joe9> napping http://codepad.org/KbhN3w9P
11:24:32 <ph88> napping, are you talking to me ?
11:24:44 <napping> no, ph88
11:24:50 <napping> you have bad indentation
11:25:06 <joe9> ph88: yes, the conName and selName are String's
11:25:13 <atum> so what is wrong with napping
11:25:31 <napping> having | at the same indentation level as "ins" means it looks like an independent line under "where"
11:25:34 <joe9> ph88, Check out teh GHC.Deriving . There are some useful functions there.
11:26:04 <napping> ph88: in particular, the traversals in Data.Data.Lens are supposedly more efficient
11:26:19 <ph88> joe9, you have a link to that ?
11:26:34 <ph88> napping, how can i use Lens ?
11:26:53 <napping> atum: here's the full description: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
11:27:16 <joe9> ph88: http://hackage.haskell.org/package/generic-deriving-1.11.1/docs/Generics-Deriving-ConNames.html
11:28:37 <joe9> napping, if they provided Arbitrary instances for U1 , :*: with no generics, why would they not provide it with generics. Does it mean that it is not possible?
11:29:18 <napping> ph88: there's a lot of stuff in lens, but if you just want to map a function you can use "over" with a Traversal
11:30:21 <ph88> napping, but i don't know upfront how the structure will look like
11:30:53 <joe9> or, maybe I should use coarbitrary
11:31:18 <napping> ph88: If you have been using the uniplate library, you can try the uniplate/template from lens
11:31:31 <ph88> napping, you have a link to that ?
11:32:04 <napping> http://hackage.haskell.org/package/lens-4.15.1/docs/Data-Data-Lens.html
11:32:56 <napping> Here's over: http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Setter.html#v:over
11:33:10 <napping> over template :: (Typeable a, Data t) => (a -> a) -> t -> t
11:33:47 <napping> various combinators are defined in different modules because they can work with weaker or stronger kinds of lenses
11:34:55 <napping> Setter < Traversal < Lens, basically
11:37:24 <napping> The main page at the haddock "Contents" seems have some decent links and description now
11:42:01 <joe9> anyone used this http://www.cs.kun.nl/~pieter/gentest/GastIFL02.pdf http://www.cs.kun.nl/~pieter/gentest/GastIFL02.pdf was interesting on how they tested generic functions
11:49:46 * hackagebot drawille 0.1.2.0 - A port of asciimoo's drawille to haskell  https://hackage.haskell.org/package/drawille-0.1.2.0 (yamadapc)
11:54:34 <joe9>  instance Arbitrary (U1 a) where arbitrary _ = QC.arbitrary :: () -- does not compile
11:59:21 <glguy> Yay, the type system saved you from a bad implementation of arbitrary!
12:01:59 <jmnoz> how can i conditinally add something to my parser with Options.Applicative?
12:02:06 <jmnoz> *conditionally
12:02:55 <EvanR> "who tests the tests.. and the testing framework"
12:02:56 <joe9> glguy: I am trying to figure out if I can generate data types for quick check tests. Is that possible?
12:03:02 <EvanR> types! thats what 
12:03:39 <joe9> GAST supposedly did it for CLEAN and proposed changes to QuickCheck to enable that.
12:03:46 <joe9> Not sure if anyone knows more about it.
12:03:56 <Xyliton> EvanR: Meta-tests
12:04:17 <joe9> so, you could test (read . show) of any number of types.
12:09:49 <slack1256> How do I avoid the "import chasing" where you use stuff but don't remember in which module it is?
12:10:17 <Xyliton> slack1256: either write comments or just import the stuff you need
12:10:47 <Xyliton> I belive you can do stuff like "import Foo (method1, method2)"
12:11:29 <kadoban> slack1256: I almost exclusively use either qualified imports or explicit imports like that ^
12:14:01 <slack1256> no no, I mean using 'ask' in code that I know must be in Control.Monad.Reader.Class, and thus my editor (with help) suggest "Should I import Control.Monad.Reader.Class"?
12:17:21 <kadoban> Not quite seeing the problem there yet?
12:18:42 <slack1256> it is not a problem, is just me being lazy and not wanting to state explicitly each import
12:18:48 <hexagoxel> if the imports themselves are an issue, the only "solution" is some custom Prelude
12:19:23 <kadoban> slack1256: Get better editor integration I guess? (not sure what exists, I do imports manually)
12:19:47 * hackagebot cron 0.4.2 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.4.2 (MichaelXavier)
12:20:06 <slack1256> hexagoxel: I wonder if I use a custom prelude, but use just 98% of the imports, should GHC strip the unneeded ones at the end?
12:21:26 <Xyliton> I would do imports on my own too. That makes you more aware of what's going on inside your program after all which is, at least from my understanding, what Haskell aims for
12:22:19 <Xyliton> Could anyone help me with developing an algorithm?
12:23:51 <Xyliton> nitrix: did you finish your version of my task, or did you drop it? :D
12:24:55 <kadoban> Xyliton: Probably someone can.
12:25:42 <Xyliton> I'll just write it down and hope someone answers, I guess
12:26:41 <kadoban> A good plan in general, yeah. Also there's ##algorithms , but don't take that as meaning you have to move there to ask.
12:31:10 <jmnoz> anyone have an idea how I can add definition to my Options.Applicative Parser based on some condition? beginner
12:34:13 <Xyliton> Here it is: http://lpaste.net/344911
12:34:14 <Xyliton> This is my current "problem". I already implemented some helper functions and some "data" which represents Storages etc. http://lpaste.net/344905
12:39:05 <kadoban> Is the "storages" thing part of the problem itself, or is that part of what you've made up to solve it?
12:40:13 <Xyliton> they are part of the original description. You could call them "variables" too, but they should be unique so I made them have an ID and their content
12:40:55 <ertesx> jmnoz: like a flag that is only there based on a condition?
12:42:53 <kadoban> Xyliton: It's not really clear to me what's going on there. The outputs are single elements or not?
12:43:03 <jmnoz> ertesx: precisely
12:43:56 <ertesx> jmnoz: well, there is the empty parser:  pure ()
12:44:25 <Xyliton> kadoban: the output of what?
12:45:04 <ertesx> jmnoz: for example if (p :: Parser Bool) is a command line flag that would allow the user to switch on/off some option, then you could do something like:  if blah then p else pure False
12:46:07 <ertesx> jmnoz: caveat: decisions can only be meta, which means that they have to happen during the construction of your Parser…  they cannot happen dynamically (while parsing)
12:47:38 <jmnoz> ok that's fine I think. In this case I want to add <> value defaultValue to my parser if was provided in user config file
12:48:12 <jmnoz> ..but if it isn't there I want there to be no default value and thus require it as input
12:49:17 <ertesx> jmnoz: you may find this interesting: http://ertes.eu/tutorial/config-monoids.html
12:50:02 <jmnoz> ertesx: great, thanks!
12:58:03 <jmnoz> (?<>) 
12:59:25 <surina> can I make a binary function inside foldr, that would be like "++ "\n" ++"?
12:59:44 <surina> So it would add a line break between strings
13:02:30 <roboguy`> surina: have you tried?
13:02:46 <ertesx> surina: only if you add a line break either at the beginning or the end, too
13:03:01 <surina> I'm not sure which way the parantheses should be
13:03:09 <roboguy`> which parentheses?
13:03:28 <sbrg> you can use foldr1
13:03:29 <sm> I had a bunch of haskell videos in browser tabs, particularly a recent one by don stewart about "haskell at scale" or something. Darned if I can find it in browser history or on youtube. Any pointers welcome!
13:03:29 <sbrg> or foldl1
13:03:34 <ertesx> surina: have you written it recursively first?
13:03:37 <surina> I mean, I would like to make that act like a infix operator
13:04:29 <sbrg> surina: the best thing you can do is try. try and see what happens just using foldl/foldr, and then see what happens with foldl1 or foldr1
13:05:11 <ertesx> (foldl* are definitely the wrong choice here, and it's not obvious to see that, because they could appear to work)
13:05:13 <sm> ha finally. https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems 
13:05:25 <ertesx> also avoid foldr1 for this one
13:05:29 <roboguy`> surina: if you are asking if you can literally use "(++ "\n" ++)", no that is invalid syntax
13:05:52 <roboguy`> operator sections aren't complex enough to allow for things like that
13:07:53 <surina> I have list of strings, and I would like to combine them to one string, but with "\n" between them
13:08:06 <Welkin> surina: lines
13:08:08 <Sonolin> unlnes ?
13:08:11 <Welkin> er
13:08:12 <Welkin> unlines
13:08:14 <roboguy`> surina: have you tried using a lambda
13:08:14 <surina> Oh
13:08:16 <surina> Right
13:08:17 <Welkin> or,
13:08:40 <Welkin> > intercalate "\n" ["你好", "吗"]
13:08:42 <lambdabot>  "\20320\22909\n\21527"
13:08:45 <Welkin> lol
13:09:53 <surina> unlines did the job
13:10:12 <surina> Welkin: Thanks!
13:10:17 <Welkin> unlines = intercalate "\n"
13:11:14 <ertesx> @let mintercalate cs xss = foldr (\xs ys i -> i (cs <> xs <> ys const) (xs <> ys const)) mempty xss (const id)
13:11:17 <lambdabot>  Defined.
13:11:21 <ertesx> :t mintercalate
13:11:23 <lambdabot> (Monoid b, Foldable t) => b -> t b -> b
13:11:32 <ertesx> > mintercalate "," ["abc", "def", "ghi"]
13:11:35 <lambdabot>  "abc,def,ghi"
13:12:09 <Welkin> > mintercalate "," $ Data.Sequence.fromList ["abc", "def", "ghi"]
13:12:12 <lambdabot>  "abc,def,ghi"
13:12:14 <Welkin> lol
13:13:37 <ncl28> what would be the best way to go from cp1250 encoded file to Text? T.readFile obviously fails, I can read it as ByteString but how to convert cp1250 to utf8?
13:18:50 <geekosaur> text-icu package?
13:19:01 <geekosaur> cp1250 should be a recognized encoding
13:19:37 <Profpatsch> Is it just me or is the “not possible to depend on directories” rule of shake extremely arbitrary and counter-intuitive?
13:19:51 <Profpatsch> I stumble on it in almost anything I do.
13:21:12 <ncl28> geekosaur: thanks, I will try that
13:22:14 <Boomerang> Profpatsch: just create a file inside the directory when you create it and depend on that. I think the restriction is to do with the ambiguity of doing diff between directories (what if there are files that don't matter inside?)
13:23:14 <Xyliton> Anyone has an idea on how to solve my problem?
13:23:23 <geekosaur> there's a number of not at all intuitive edge cases in directory dependencies
13:23:32 <ertesx> in GHCi is there a variant of `:set +s` that prints the maximum memory in use instead of the total allocated memory?
13:24:40 <geekosaur> ...and some of those edge cases change depending on what filesystem is in use, whether it is remote vs. local, etc.
13:24:50 * hackagebot oeis 0.3.8 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  https://hackage.haskell.org/package/oeis-0.3.8 (niteria)
13:27:31 <dacto> how to change Data.Text.readFile to not convert line endings to host OS?
13:28:02 <dxtr> Sounds to me like you want to use ByteString instead
13:28:11 <MarcelineVQ> ertesx: Not that I've seen
13:28:17 <Profpatsch> geekosaur: Hm, okay.
13:29:00 <ertesx> MarcelineVQ: couldn't find anything on my own either; too bad…  thanks
13:30:00 <glguy> dacto: There is no "Data.Text.readFile" and "Data.Text.IO.readFile" doesn't appear to reinterpret line endings
13:30:21 <dacto> I meant Data.Text.IO.readFile :) sorry
13:30:48 <geekosaur> ...binary mode?
13:32:10 <dacto> readFile is just calling System.IO.openFile which i guess defaults to text mode
13:32:14 <Profpatsch> geekosaur: Is it just me, or is linking files with shake almost always not a good idea and one should copy instead?
13:32:56 <geekosaur> I haven't used shake so couldn't say specifically. also do you mean hard or symbolic link?
13:33:43 <Profpatsch> symbolic
13:34:21 <Profpatsch> Boomerang: You have used shake, right?
13:34:37 <ezyang> Profpatsch: What do you mean by "linking with shake"? 
13:35:00 <Profpatsch> ezyang: creating symlinks in a shake bulid.
13:35:02 <Profpatsch> *build
13:35:10 <Boomerang> Profpatsch: I have used shake a bit. Did I say something wrong?
13:35:26 <dacto> dxtr: unlines in bytestring looks to assume '\n'
13:35:42 <geekosaur> symlinks to a product won't necessarily be noticed by most build systems, since they don't specifically check for symlinks that act as implicit dependencies
13:35:58 <ezyang> Profpatsch: It is possible that shake doesn't "understand" symlinks 
13:36:44 <Profpatsch> Boomerang: I have a rule like this now, do you think it’s “how it should be done”? http://lpaste.net/344923
13:36:51 <Boomerang> Profpatsch: Oh I didn't see your earlier question. Copying seems to be the way to do it!
13:37:12 <Profpatsch> Especially on copy-on-write filesystems I realized.
13:37:32 <ertesx> Profpatsch: copying is probably not a good solution either…  (disclaimer: i have only played briefly with shake) if it doesn't understand symlinks, e.g. by confusing which mtimes to use, you could create an extra file
13:38:03 <Profpatsch> Well, since it’s incremental there will always be caching errors I think.
13:38:10 <geekosaur> most things handle symlinks by how the basic OS facilities do, so you get the modtime of the linked-to file
13:38:19 <geekosaur> it's rare for things to specifically check for symlinks
13:38:36 <maerwald> file managers do :P
13:38:37 <Boomerang> Profpatsch: At the company I worked for last summer, we copied the static files on build
13:38:41 <Profpatsch> geekosaur: Which is how it’s intended to be I think.
13:38:57 <geekosaur> otoh if they actually want to handle the case I described earlier, they must check specifically for symlinks (but then still want to use the mtime of the linked-to file)
13:38:57 <ertesx> if you want to depend on the symlink 'blah', depend on 'blah.dep' instead, and create it as a byproduct of creating the symlink…  it's an ugly solution, but it works
13:38:59 <lpaste> jmnoz pasted “Applicative conditional definition” at http://lpaste.net/344924
13:39:13 <jmnoz> ertesx: I'm not grokking it
13:39:23 <ertesx> jmnoz: "it"?
13:39:24 <Profpatsch> ertesx: The symlinks seem to wark.
13:39:26 <Profpatsch> *work
13:39:58 <jmnoz> ertesx: couldn't figure out how to..conditionally define a parser
13:40:26 <ertesx> jmnoz: could you paste your current (unconditional) code?
13:40:43 <geekosaur> 344924, above
13:40:50 <ertesx> oh
13:40:52 <jmnoz> ertesx: yeah please see it :)
13:42:34 <ertesx> jmnoz: example: parseShow mdef = … (metavar "UID" <> maybe mempty value mdef)
13:42:50 <ertesx> mdef :: Maybe TheTypeOfDefaultUser
13:43:09 <ertesx> if it's Just, use it as the default value, if it's Nothing, set no default value
13:45:53 <ertesx> jmnoz: more generally parseShow has to be a function of enough information to decide whether and which defaults to set
13:50:07 <jmnoz> ertesx: this solves my problem beautifully, thanks a lot
13:54:14 <dxtr> Is it worth converting a potentially large amount of String to Text, returning that and hope that the GC takes care of the Strings?
13:55:27 <maerwald> how would we know what you do with it?
13:55:32 <roboguy`> dxtr: where does the String come from?
13:56:15 <dxtr> It's mainly file paths
13:56:31 <maerwald> file paths as Text don't make sense anyway, use ByteString instead
13:56:43 <dxtr> Alright!
13:57:42 <maerwald> dxtr: and where do the filepaths come from?
13:57:44 <roboguy`> dxtr: if you are combining them together in your program (instead of having the whole String provided to you by something else), you might want to look into something like ByteString Builder
13:57:54 <maerwald> if you receive them as String, you're already on a wrong route
13:58:00 <maerwald> you must receive them as ByteString
13:58:04 <maerwald> not convert them post-receiving
13:58:15 <dxtr> Hmm, okay
13:58:41 <dxtr> I'm using conduit-combinators to get all files in a directory and filter out the files I want
13:58:59 <dxtr> and sourceDirectoryDeep returns [FilePath]
13:59:05 <maerwald> file a bug
13:59:08 <dxtr> But that feels like a waste considering there can be A LOT of files
13:59:35 <maerwald> that's not the issue with String here. The issue is that filepaths are really just BYTES
13:59:55 <maerwald> as soon as you convert them to something like String, Text etc. you get into weird encoding issues
14:00:10 <maerwald> you might say those are edge cases, but please tell that to japanese haskell users
14:00:10 <dxtr> right
14:00:29 <dxtr> Wait, there are people in Japan? :)
14:00:35 <maerwald> -.-
14:01:11 <maerwald> also see https://ghc.haskell.org/trac/ghc/wiki/Proposal/AbstractFilePath which provides further reasoning
14:01:13 <dxtr> Why is FileString the same as [Char], by the way?
14:01:15 <nut> how to print the type of somevalue in my main function?
14:01:17 <dxtr> Right
14:01:20 <maerwald> dxtr: it was simply a mistake
14:01:48 <lyxia> nut: print somevalue
14:02:06 <nut> What if that value is not of Show class?
14:02:16 <nut> you will get an error
14:02:50 <roboguy`> nut: print *the type*? What are you trying to do? Usually you know the type...
14:02:58 <roboguy`> if you
14:03:02 <roboguy`> if you're in the main function
14:03:20 <nut> I am not sure of the type
14:03:24 <nut> of my value
14:03:27 <nut> that's why
14:03:31 <roboguy`> nut: can you use GHCi to find out?
14:03:47 <maerwald> nut: my editor can do that, but I don't know your editor
14:03:52 <roboguy`> If not, you can always use a type hole. Give the thing you're not sure what type it is the signature "somevalue :: _"
14:03:53 <nut> it's some local value
14:04:01 <joe9> dxtr, System.Posix.ByteString.FilePath , System.Posix.FilePath might help too. They are bytestring file paths.
14:04:02 <roboguy`> nut: try a type hole
14:04:23 <nut> ok if i do that, what will happen?
14:05:10 <lyxia> ghc will tell you the type it inferred
14:05:19 <sbrg> nut: the compiler will say "I found a type hole and the type of that hole is .."
14:06:37 <dxtr> maerwald: So maybe it'd be better to use System.Posix.Directory.Traversals.allDirectoryContents (from posix-paths) and filter the resulting list instead?
14:06:47 <maerwald> dxtr: posix-paths is unmaintained
14:06:57 <maerwald> therefore I forked it, but my fork has slightly more dependencies
14:07:19 <maerwald> @hackage hpath
14:07:19 <lambdabot> http://hackage.haskell.org/package/hpath
14:07:21 <EvanR> i wonder if theres something as convenient as the glob feature of ruby
14:07:30 <joe9> Is optparse-applicative the recommended approach for parsing options.
14:07:42 <lyxia> it is
14:07:51 <dxtr> maerwald: Oh cool! Will definitely use that
14:08:09 <SrPx> I've been writing a lot of things using morte and Idris, I understand refl, dependent pairs, I can quite well see it and what it is doing, but I still don't "get" it... there is something fundamental there that I just can't see
14:08:17 <ezyang> joe9: It is certainly a very reasonable choice 
14:08:41 <EvanR> SrPx: morte?
14:08:42 <SrPx> it just doesn't make sense to me that type theory as presented can somehow be a good candidate to formalize all of math... so many things look so specific and arbitrary
14:09:03 <SrPx> EvanR the pure calculus of constructions without anything else
14:09:36 <SrPx> I don't know, what now? Send me some books that will make me understand why type theory is so fundamental and natural as you claim?
14:09:38 <joe9> SrPx: your intuition is correct. check out HoTT.
14:10:20 <EvanR> SrPx: undergrad math would have you believe set theory makes more sense, but if you look at it, its a pile of symbols just like type theory
14:10:33 <EvanR> just type theory gives you typed symbols
14:10:35 <SrPx> joe9 how does HoTT help? As I've seem it is just the same thing as type theory just with some additional things 
14:10:36 <joe9> SrPx: type theory based on sets does not make sense.
14:11:03 <joe9> SrPx: the problem is the use of sets to describe types (imho)
14:11:07 <EvanR> the hott book at least goes into a lot of math, in a univalent foundation
14:11:18 <EvanR> so you can see how it would look
14:11:37 <SrPx> joe9 I really need to read hott, it will be my next book definitely... I'll start dedicating some hours to it every day now
14:12:05 <joe9> SrPx: The first chapter was an eye opener for me. It highlights the issues with using sets to describe types.
14:12:20 <EvanR> in the cases where it delves into areas usually requiring axiom of choice, you may not see much point
14:12:34 <EvanR> all the same results are there
14:12:38 <SrPx> that is good to hear, hopefully it will be to me now
14:13:29 <ertesx> SrPx: have you tried to define some algebraic structures?
14:13:53 <ertesx> SrPx: for example monoids or groups, or even categories or groupoids
14:15:16 <ertesx> SrPx: something as simple as proving that for groups/groupoids left inverses follow from right inverses (but not for monoids/categories), then proving that integers with addition form a group/groupoid, can be eye-opening
14:16:20 <SrPx> ertesx why those things in particular could be eye-opening?
14:16:44 <ertesx> SrPx: because you will learn how reasoning works, especially equational reasoning
14:16:50 <EvanR> x is an example of named thing y, is sort of dull math-wise and programming-wise (youd have to do this just to write code satisfying an interface)
14:17:14 <SrPx> I think one of the hard things for me to grasp intuitively is the seemingly huge gap between everything I see people doing in haskell, idris, etc., and the math I see in school 
14:17:44 <SrPx> there it is all about integrals, real numbers, data analysis which again is all about real numbers, ton of matrices of real numbers, real numbers are everywhere
14:18:03 <EvanR> the hott book constructs real numbers in a few ways
14:18:04 <ertesx> SrPx: there are two reasons for this: school generally does not prove or even talk about important properties
14:18:05 <SrPx> and it seems that they never ever show up in any of those 
14:18:21 <EvanR> and this paper im reading is all about haskell and topology
14:18:31 <EvanR> ski linked in yesterday: https://mail.haskell.org/pipermail/haskell/2004-June/014134.html
14:18:33 <ertesx> SrPx: did you consider the 'cong' law for equality in school?  you probably didn't…  you just intuitively assumed that you can freely substitute in equations
14:18:56 <ertesx> SrPx: the second difference is that you're not doing classical math, but constructive math, which *is* different
14:18:59 <SrPx> I haven't ever even read that word
14:19:28 <t7> i think vim over ssh will be better than vscode on windows
14:19:35 <SrPx> I still feel like there is a huge educational gap between whatever they teach me there and what is really worth learning
14:19:37 <EvanR> SrPx: we have exact real numbers, two separate libraries for it
14:19:39 <t7> i wont be able to run any decent extensions :'(
14:19:50 <SrPx> I wish you guys could compile a list of books for the self taught or something ): 
14:19:52 * hackagebot hbro 1.6.0.0 - Minimal extensible web-browser  https://hackage.haskell.org/package/hbro-1.6.0.0 (koral)
14:19:53 <joncol> I'm playing with megaparsec. I get problems when trying to test it on the repl. I try simple examples from the docs like: `parseTest (string "lex") "lexical"`, but this results in an error: Ambiguous type variable ‘e0’ arising from a use of ‘string’ prevents the constraint ‘(ErrorComponent e0)’ from being solved. Probable fix: use a type annotation to specify what ‘e0’ should be. I'm not really sure what this means and how 
14:19:53 <joncol> it...?
14:19:54 * hackagebot hbro-contrib 1.6.0.0 - Third-party extensions to hbro.  https://hackage.haskell.org/package/hbro-contrib-1.6.0.0 (koral)
14:20:09 <ertesx> SrPx: my way of learning (agda, not idris) is to write my own standard library =)
14:20:18 <SrPx> EvanR you mean in Idris or Haskell?
14:20:30 <EvanR> haskell
14:20:38 <ertesx> SrPx: https://github.com/esoeylemez/agda-simple
14:20:39 <EvanR> in idris i havent even seen rationals yet ;)
14:20:40 <joncol> (when using runParse from a source file and pattern matching on Left/Right it works...)
14:21:04 <SrPx> ertesx that is quite what I've done, just that it wasn't as insightful as I thought... I'm in a state of "ok I get Idris and dependent types, but I don't get how it connects to all of math"... perhaps for lacking on the math myself
14:21:22 <EvanR> SrPx: agda is probably better for math
14:21:29 <ertesx> SrPx: have you proved something about integers?
14:21:31 <SrPx> EvanR ah but then Haskell isn't really used for formalizing math, right?
14:21:47 <dacto> sweet, figured out the newline translation thing. handles controls the newline treatment when reading and writing
14:21:55 <EvanR> SrPx: in the paper i linked, it proves theorems from topology with haskell... its kind of surprising to me
14:22:21 <EvanR> and its classical logic, not intuitionistic
14:22:25 <kadoban> joncol: Do you have the full error message?
14:22:43 <SrPx> ertesx yes but I also think most things I proved are stupid and I didn't really gain an insight from that... in fact it seems that everything just boils down to writing two different things that normalize to the same term, then you put both things in Reft and that is called a "proof"
14:23:08 <SrPx> and is somehow magical
14:23:18 <SrPx> I see no magic there though, it just normalized to the same term
14:23:26 <EvanR> its not magic, look at how the hott book works
14:23:57 <SrPx> I was actually going to ask this: is there any case where you prove x == y without both sides having the same normal form?
14:23:58 <EvanR> you declare constructors, induction principle for each kind of data type, this lets you define functions
14:24:05 <joncol> kadoban: http://lpaste.net/344927
14:24:17 <EvanR> equality types are no different
14:24:21 <ertesx> SrPx: that *is* the magic in a sense…  what is a mysterious, purely intuitive concept in classical mathematics boils down to this simple mechanical (indeed *computational*) thing in type theory
14:25:00 <EvanR> induction on naturals is a special case of induction on whatever data structure / space you just invented
14:25:14 <ertesx> SrPx: and no, both sides must be the same, which is of course the point of equality =)
14:26:13 <EvanR> SrPx: yes, univalence is one example
14:26:35 <ertesx> SrPx: (i'm talking about regular type theory, not HoTT)
14:26:50 <SrPx> then what is the point in proving things with dependent types? you could as well just pick two untyped terms, check they reduce to the same thing and call that a "proof"... :/ not trying to start this flame but I still don't see what is magical about those dependent types
14:26:53 <kadoban> joncol: Give it a type annotation like uhm ...  parseTest (string "lex" :: Parsec Dec String) "lexical"
14:26:55 <SrPx> I mean I quite get it but not really, you know what I mean?
14:27:14 <sm> joncol: sometimes when testing small chunks of code in GHCI you need to provide type hints to help it out
14:27:25 <ertesx> SrPx: there is nothing magical…  you're doing constructive mathematics, and a computer is actually checking your proofs
14:27:39 <EvanR> SrPx: without types you could be fooled into asking if PI is equal to a certain group homomorphism, because its all just nested sets of sets of ... empty sets in the end
14:27:55 <EvanR> which is silly
14:28:11 <surina> How do I use lambdabot in offline mode?
14:28:16 <ertesx> SrPx: try to prove 3 = 4
14:28:20 <SrPx> EvanR okay that is fair 
14:28:56 <joncol> Ah kadoban, thanks. Needed an extra String there :: Parsec Dec String String worked...
14:29:33 <kadoban> Ah, ya
14:29:42 <joncol> Not exactly nice when you just want to do some quick and dirty tests :/
14:29:53 <dacto> is there a more elegant way to write 'r2' @ http://lpaste.net/1691721488282943488
14:30:01 <SrPx> but also, why that specific system consisting of a method of substituting trees into trees (lambdas), and a method of defining shapes of trees using a different method of substituting trees into trees (Pi)...
14:30:16 <SrPx> why *that*, why that specific thing we call type theory is so special? 
14:30:24 <kadoban> joncol: You could make a util function that makes it easier, just remove the 'e' part from the type, fix it as Dec specifically.
14:30:40 <roboguy`> surina: the easiest thing to do is send an IRC message to it with /msg
14:30:55 <SrPx> why not something else with lists rather than trees, why not some kind of type theory on top of automatas, or turing machines, or neural networks... why *that* specific way of doing things is so special
14:30:56 <ertesx> SrPx: because we can write computer programs that implement it
14:31:15 <joncol> kadoban: True.
14:31:28 <EvanR> SrPx: thats not specific to type theory, you also have that in things that compute logic
14:31:36 <EvanR> untyped too
14:31:43 <EvanR> like the metamath database
14:32:27 <EvanR> thats just the nature of syntax, its a tree
14:32:30 <SrPx> hey what a cool site
14:32:36 <roboguy`> SrPx: probably because it captures the essence of the idea of "substitution" in the context of a string of symbols
14:33:17 <EvanR> mathematica's internal language is just rose tree of symbols
14:34:02 <ertesx> SrPx: the thing is: we want to write proof assistants, and set theory (even without choice) won't get us there…  type theory is a working alternative with the property that proofs are mathematical objects, and not just intuitive arguments between humans
14:34:21 <ertesx> SrPx: there is a well-understood, mechanical process of *checking* proofs that a computer can perform
14:34:28 <nut> could anyone show a oneliner how to user hashmap insert?
14:34:35 <nut> i alway get error
14:34:41 <Jello_Raptor> I'm genuinely stumped why this class declaration isn't working :/ http://lpaste.net/344930 
14:34:53 <nut> when i do inser "complexity" 5
14:35:03 <EvanR> ertesx: metamath actually is also checked
14:35:10 <Jello_Raptor> nevermind ... 
14:35:19 <EvanR> and there are other mechanical formalization projets
14:35:20 <Jello_Raptor> I used a class declaration instead of an instance :V
14:35:26 <roboguy`> nut: what sort of error?
14:35:49 <nut> Ambiguous type variable ‘k0’ arising from a use of ‘HM.insert’
14:35:59 <ertesx> EvanR: i don't know how well those work, and how general they are
14:36:05 <nut> I'm inserting into an exiting json object
14:36:14 <EvanR> type theory combines (conflates?) logic with objects were talking about
14:36:20 <nut> there is no error if i insert into HashMap.empty
14:36:26 <EvanR> instead of keeping them separate
14:36:38 <ertesx> EvanR: in general i'm in favour of having proofs as first-class objects
14:37:03 <EvanR> it means you dont have to duplicate work
14:37:09 <SrPx> in HoTT are graphs represented with a layer of indirection like in haskell (sorry if nonsense question)?
14:37:13 <roboguy`> nut: try adding a type signature
14:37:23 <EvanR> graphs ?
14:37:48 <SrPx> yep, graphs in general, anything that isn't a tree
14:37:49 <roboguy`> nut: also, if you don't already, make sure all of your top-level definitions have explicit type signatures. that makes errors *way* easier to read
14:37:50 <EvanR> SrPx: how would you describe a graph
14:38:10 <dacto> anyone have a more elegant way of writing 'r2'? http://lpaste.net/1691721488282943488
14:38:50 <SrPx> EvanR a set of nodes and a set of edges between them
14:39:06 <EvanR> yeah, now check this out
14:39:21 <ertesx> dacto: yes, use do-notation
14:40:26 <dacto> ertesx: thx for the feedback - for my knowledge, is there a function (operator) that captures the specific pattern highlighted by the comment?
14:40:46 <EvanR> SrPx: actually, before i go on, do you allow or disallow multiple edges between the same pair
14:41:01 <SrPx> whatever is easier
14:41:06 <EvanR> alright
14:41:08 <ertesx> dacto: nope, because it is a very specific pattern…  you could at best get rid of the 'return'
14:41:09 <EvanR> then ill allow
14:41:16 <ertesx> dacto: c >> return x = x <$ c
14:41:41 <athan> What's the difference between typed-holes and type wildcards?
14:41:41 <ertesx> dacto: also that code looks horribly unsafe and resource-leaky
14:41:45 <SrPx> EvanR I see what you're doing, though... but see, you wouldn't implement trees as sets of edges, even though you could... they have a more natural representation. I find it interesting that trees have, but graphs don't
14:42:15 <dacto> ertesx: which, all? that is the readFile function adapted from Data.Text.IO
14:42:17 <EvanR> Graph : (node : Type) -> (edgesBetween : node -> node -> Type) -> Type
14:42:24 <ertesx> athan: they are unrelated…  typed holes are unspecified values, and by type wildcards i assume you mean partial type signatures, which mean: "infer the rest"
14:42:55 <athan> ertesx: unspecified values? You mean like term inference?
14:43:00 <roboguy`> no
14:43:10 <roboguy`> oh, term inference
14:43:21 <ertesx> dacto: use withFile, which closes the file after reading
14:43:22 <EvanR> in this case a graph is a dependent pair 
14:43:24 <athan> I've just seen stuff like `Foo _ _ _` a lot in purescript etc
14:43:26 <roboguy`> athan: well, they are generally not allowed to compile
14:43:28 <ertesx> dacto: the file handle is leaked in your code
14:43:35 <EvanR> well, two dependent pairs
14:43:41 <athan> ahh okay, that makes sense roboguy`
14:43:53 <dacto> ertesx: thx, i'll look into fixing that up
14:44:10 <roboguy`> athan: in Haskell, they are usually used to ask the compiler what the type of the term in that spot should be
14:44:15 <EvanR> SrPx: i left the representation undefined, its up to the particular graph
14:44:28 <ertesx> athan: f x = x + _  -- dear compiler, please tell me what the type of _ is
14:44:46 <EvanR> SrPx: i basically just said "its a category but without the laws" 
14:44:50 <athan> ertesx: That's a typed-hole?
14:44:51 <ertesx> athan: f x = x + _  -- with -fdefer-typed-holes: dear compiler, please tell me what the type of _ is, and compile this code anyway with _ = undefined
14:44:59 <athan> ahh!!
14:45:01 <ertesx> athan: that ^
14:45:01 <athan> wow that's awesome
14:45:19 <ertesx> in both cases _ is a typed hole
14:45:27 <ertesx> or _anyNameStartingWithUnderscore
14:45:29 <EvanR> this is actually all there is the idea of a (multi-)graph
14:45:38 <EvanR> all implementations follow this interface
14:45:39 <athan> ahh perfect
14:45:44 <athan> that's brilliant ertesx, thank you
14:46:13 <dacto> ertesx: Data.Text.IO.hGetContents appears to close the handle when finished reading - is this understanding correct?
14:46:29 <SrPx> I'm confused with what you wrote 
14:46:32 <EvanR> if you use sets of nodes and edges, suddenly you have to wonder about cardinalities and axioms of choice
14:47:04 <surina> If it's said that haskell program must "type check", does that mean same as that it must compile?
14:47:04 <ertesx> dacto: use withFile anyway
14:47:18 <EvanR> SrPx: well, let me write it like this, which wont parameterize it... Graph = Sigma (node : Type) (node -> node -> Type)
14:47:42 <EvanR> a type of nodes, and for each pair of nodes, a type of edges between them (possible empty)
14:47:56 <ertesx> dacto: there is a gap between opening the file and reading it, and if there is an exception, the handle is leaked and floats somewhere in the ether until GC notices it
14:48:22 <SrPx> I see
14:48:28 <ertesx> dacto: keep in mind that in haskell exceptions can happen (almost) *anywhere*, because we have async exceptions
14:48:47 <dacto> ertesx: ah ok
14:48:54 <dacto> I'll switch it use withFile
14:48:57 <SrPx> so, a table... just what I said... there isn't a direct representation of a graph like we have direct representation of any kind of tree as an ADT 
14:48:58 <dacto> thx
14:49:03 <glguy> Keep in mind mixing withFile and hGetContents is inviting new errors into your program
14:49:17 <glguy> unless it's one of the strict hGetContents
14:49:38 <dacto> glguy: it the strict version
14:49:42 <EvanR> SrPx: its not a table, or a tree, and inductive types arent necessarily implemented as trees either
14:50:33 <dacto> glguy: if it was the lazy one, what type of errors are you referring to?
14:50:38 <EvanR> in the nlab page on SEAR (a categorically inspired set theory), it defines a tabulation, which is different from a relation
14:51:00 <koala_man> surina: type checking is one step of compilation, so it won't compile if it doens't type check. 
14:51:27 <EvanR> a tabulation is a set of pairs, while a relation is undefined. and both are different from a Pi type
14:51:36 <EvanR> which is a function
14:52:44 <surina> koala_man: I see, thanks :)
14:52:54 <SrPx> EvanR an adjacency table, I mean... yes you have arbitrary implementations but you still defined it as a list of edges so that is an adjacency table
14:52:55 <EvanR> i just found and lost a quote about the utility of keeping certain things separate...
14:53:05 <EvanR> SrPx: i did? no
14:53:09 <glguy> dacto: The exceptions you get if you try to use more of the lazily read file content after closing the handle that wasn't yours to close (since you gave it to hGetContents already) 
14:53:09 <glguy> Prelude System.IO> withFile "/dev/zero" ReadMode hGetContents
14:53:10 <glguy> "*** Exception: /dev/zero: hGetContents: illegal operation (delayed read on closed handle)
14:53:44 <SrPx> EvanR yes, how not? You used edges in your definition
14:54:02 <dacto> glguy: ah yes - i was reading about some others talk about that, makes sense. Thanks for the additional details :)
14:54:19 <koala_man> surina: if you run code in ghci or runghc, code is type checked and interpreted without being compiled
14:54:40 <SrPx> a direct definition wouldn't use edges, just something like `data Graph label = Node label [Graph]` (the edges "implicit" / borrowed from the language itself - not sure how to express that)
14:54:48 <EvanR> SrPx: theres an edge type for each pair of nodes, yes. its a family of types indexed by a pair of nodes
14:55:04 <EvanR> its not a list
14:55:48 <EvanR> we called it edges just for sake of intuitive interpretation
14:56:11 <EvanR> SrPx: im thinking your original definition and mine are both more "direct"
14:56:20 <surina> koala_man: Ok. I think I got now a little bit better understanding about the topic
14:56:49 <SrPx> EvanR than that second one? How so? It seems much more direct to me...
14:56:52 <EvanR> in the sense that defining natural numbers as certain shapes of nested braces is indirect
14:57:31 <SrPx> EvanR nats as shapes of nested braces?
14:57:41 <EvanR> to get directly to the important properties of the object, we just use the properties
14:57:57 <EvanR> SrPx: yeah in the old style encoding of natural numbers
14:58:13 <EvanR> {}, {{}}, {{}, {{}}}}, ...
14:58:15 <SrPx> ah
14:59:18 <EvanR> more direct, "a natural number is either Zero or the successor of a natural number, and these are the only ways to construct a natural number"
14:59:37 <Welkin> can you use pred?
14:59:42 <SrPx> yes but `data Nat = Succ Nat | Zero` is better than representing numbers as a set of nodes, and a set of edges between nodes, with the constraint that all nodes must connect and each node must have exactly 2 edges?
14:59:50 <Welkin> pred (succ Z)
15:00:02 <Welkin> = Z
15:00:03 <EvanR> you can define pred for any successor
15:00:15 <Welkin> `pred Z` would be an error though
15:00:20 <EvanR> or you could use a saturating pred, but thats a defining property of nats
15:00:28 <EvanR> but its not a defining property
15:00:44 <EvanR> ... errors arent on topic here ;)
15:01:13 <EvanR> SrPx: wait, what constraint?
15:01:27 <EvanR> thats weird
15:03:39 <EvanR> defining characteristic of semigroup: you have a type A and an operation op : A -> A -> A, and op is associative
15:03:52 <EvanR> the graph definition earlier follows this pattern
15:04:09 <SrPx> EvanR I mean defining numbers as graphs forming a circle of N nodes
15:04:35 <Jello_Raptor> Is there a standard inline todo that people use? I tend to just leave unfinished functions defined as "undefined" but I'd prefer something like "todo <string with task info>" that acts the same way but for the runtime error
15:04:40 <SrPx> that would be an indirect definition which is worse than the usual inductive definition, and that is how I feel about the edge-based graph definition
15:04:45 <EvanR> ah. your construction could be seen as a mapping of numbers into ring-shaped graphs
15:04:50 <SrPx> yes
15:05:01 <EvanR> the source is something else
15:05:11 <Koterpillar> Jello_Raptor: error has the right signature
15:05:22 <SrPx> the whole point is, would be nice to somehow have a representation of graphs which didn't involve dealing with edges, but I know there isn't
15:05:44 <EvanR> i didnt get that that was your point... nevermind then
15:05:52 <Jello_Raptor> Koterpillar: thanks 
15:05:57 <SrPx> okay!
15:06:03 <SrPx> sorry for not expressing myself clearly
15:07:54 <EvanR> efficient representations of things is interesting but not really the same as how to use dependent types to express ideas
15:10:39 <wirebrush456> g
15:10:42 <wirebrush456> hi
15:19:54 * hackagebot obdd 0.6.0 - Ordered Reduced Binary Decision Diagrams  https://hackage.haskell.org/package/obdd-0.6.0 (JohannesWaldmann)
15:34:35 <ertesx> Jello_Raptor: you can use typed holes with -fdefer-typed-holes, then the compiler will emit warnings for all to-do items
15:35:21 <Koterpillar> ertesx: what do they do at runtime?
15:35:22 * Koterpillar tries
15:35:31 <ertesx> Koterpillar: they crash
15:35:44 <ertesx> like 'error' pretty much
15:36:47 <Koterpillar> the good thing is the error location is in the output
15:36:54 <Koterpillar> the bad thing is there's nowhere to put a message
15:37:05 <ertesx> well, there is one interesting difference: the exception tells you the full compiler error, including the type
15:37:19 <ertesx> well, there is: the name of the hole =)
15:37:29 <ertesx> myFunc = _myFunc
15:38:07 <Koterpillar> indeed! that's nice
15:39:46 <ertesx> you can also combine both approaches
15:39:58 <ertesx> myFunc = error "my message" `asTypeOf` _myFunc
15:40:03 <dacto> if using withTempFile, how does one copy/rename(mv) the tempfile?
15:43:05 <nut> how to redirecto ghci output to a file?
15:44:08 <nut> how to redirect ghci command output to a file?
15:44:25 <Koterpillar> nut: why not just use runhaskell?
15:44:37 <Koterpillar> nut: runhaskell mything.hs > output_file
15:44:41 <nut> im inside a ghci
15:44:47 <nut> dont want to getout
15:44:57 <Koterpillar> use a file-writing function?
15:45:39 <nut> too clumsy i think
15:45:49 <EvanR> nut: you cant move it, to be able to move it, use openTempFile
15:46:15 <EvanR> now the question is, how to create a bracket construction which correctly deletes the file in case of an (async) exception!
15:46:22 <dacto> EvanR: yes, exactly
15:46:26 <EvanR> sounds hard
15:46:32 <Koterpillar> well, you can close stdout and reopen it with a file, but that's also hard
15:47:39 <dacto> can we close a handle if it is already closed?
15:48:07 <EvanR> thats kind of scary
15:48:33 <EvanR> if you wait long enough, the fd could be in use by a new legit file
15:49:06 <ertesx> dacto: Handle is different though, and the RTS doesn't mind closing twice
15:49:06 <EvanR> and you close the wrong thing
15:49:21 <grantwu> http://stackoverflow.com/questions/12782768/do-multiple-close-calls-for-one-fd-in-the-same-function-matter
15:49:39 <ertesx> Fd ≠ Handle
15:49:49 <dacto> ertesx: Yes, I mean Handle
15:49:50 <grantwu> oh, nvm
15:50:11 <ertesx> dacto: close as often as you want, as long as you don't use the handle after closing
15:50:37 <EvanR> hClose three times in succession, just to make sure!
15:50:42 <dacto> ertesx: right - i just need to close it so i can move the file if no exception happens
15:51:26 <ertesx> dacto: ideally you use bracketing
15:51:33 <dacto> ertesx: and still have "after"thing work fine
15:51:59 <dacto> ertesx: yeah, im adapting withTempFile's use of bracketing
15:52:33 <ertesx> hopefully at some point we get linear types, then there will be no more uncertainty about how often you can close a handle =)
15:54:17 <dxtr> Is there something like a boolean monad?
15:54:29 <roboguy`> dxtr: what would that mean?
15:54:42 <roboguy`> or how would you see that working, I guess?
15:55:39 <dxtr> I'd like to run a bunch of functions sequentially and short-circuit when the first fails
15:55:44 <roboguy`> the real answer is "no, because that doesn't make sense and here's why it doesn't make sense in technical terms ...", but I suspect that answer won't fully help you understand the misconception you're having
15:56:01 <roboguy`> dxtr: have you looked into the Maybe monad?
15:56:38 <ertesx> dxtr: add an Alternative constraint to whathever constraint you already have
15:56:49 <ertesx> then 'empty' is failure
15:57:08 <ertesx> if this didn't make sense to you, use Maybe
15:57:37 <ertesx> if you have an IO at the bottom, consider using IO exceptions
15:57:51 <sbrg> wooo category composition
15:57:52 <sbrg> how did I not know about this
15:58:01 <dxtr> ertesx: Yeah, this is an IO 
15:58:19 <erisco> ertesx, empty would not satisfy the criteria of "short-circuit when the first fails"
15:58:51 <erisco> empty over <|> particularly
15:58:58 <ertesx> erisco: it doesn't have to…  if that's the semantics wanted, you can use Maybe
15:59:19 <erisco> it can't if it wants to be law-abiding
15:59:44 <ertesx> > empty >> Just ()
15:59:46 <lambdabot>  Nothing
16:00:01 <ertesx> that looks like short-circuiting on failure
16:00:11 <erisco> empty over <|> particularly
16:00:29 <ertesx> (<|>) is not sequence, it's choice
16:00:56 <roboguy`> sbrg: category composition?
16:01:09 <sbrg> :t (>>>) -- roboguy`
16:01:11 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
16:01:20 <ertesx> you're basically saying that 'throwIO' is not short-circuiting in the presence of 'catch'
16:01:26 <erisco> whatever you want to take "sequence" to mean
16:01:27 <roboguy`> sbrg: ahh, *that* category composition
16:01:28 <dacto> thx all, i got bracket working together with the renaming of the tempfile - bracket is pretty cool actually.
16:01:35 <sbrg> yeah
16:01:37 <roboguy`> sbrg: I thought you meant somehow composing two categories =)
16:01:51 <sbrg> probaby my bad for butchering the terminology
16:01:58 <erisco> I didn't make any comments about throwIO or catch
16:02:03 <sbrg> maybe i should read up on some category theory at this point
16:02:05 <ertesx> erisco: honestly i have no idea what you're saying…  are you arguing against using 'empty' as generalised failure?
16:02:11 <sbrg> just some abstract algebra in general
16:02:21 <erisco> I said that empty over <|> does not satisfy the criteria
16:02:38 <ertesx> erisco: so?
16:02:58 <roboguy`> sbrg: it can be interesting stuff!
16:03:14 <roboguy`> sbrg: there are some good books and youtube videos on it too
16:03:28 <sbrg> i have looked into a bit. took half a course, but was overloaded so i dropped that course
16:04:05 <erisco> you can choose MonadPlus
16:04:06 <sbrg> but i suspect there is still far from being proficient at abstract algebra to immediately spotting how to apply these concepts in haskell, like the wizards are capable of
16:06:59 <roboguy`> sbrg: have you read the paper Monoids: Theme and Variations? It's pretty readable and introduces some abstract algebra (particularly some ideas with monoids and semigroups) and applies them in a practical setting to a library that makes diagrams of shapes
16:07:20 <roboguy`> http://ozark.hendrix.edu/~yorgey/pub/monoid-pearl.pdf
16:08:13 <sbrg> roboguy`: oh monoids and semigroups are no problem for me. neither are categories as such. the issue is the gap between understanding those concepts at some (relatively) superficial level and being able to spot things that act like that and implement them. 
16:08:15 <sbrg> if that makes sense.
16:08:39 <sbrg> and yep, i have read that
16:09:19 <sbrg> i should probably read it again, though.
16:11:24 <ertesx> erisco: why would you choose MonadPlus?  you're artificially restricting semantics at the definition site, when that restriction should be made at the usage site (e.g. by choosing Maybe)
16:12:10 <ertesx> unless the *definition* requires annihilating mzero use Alternative
16:13:15 <erisco> MonadPlus stipulates the identity laws we are looking for. I do not understand the rest of your question
16:13:58 <ertesx> identity laws?  are we even talking about the same thing?
16:13:58 <erisco> not the identity laws, the absorption laws, I mean
16:14:04 <ertesx> ah
16:14:51 <ertesx> well, "we" aren't really looking for anything…  Maybe was suggested for short-circuiting failure, and i suggested Alternative as something much weaker
16:16:24 <erisco> if you have confidence that the laws hold with empty rather than mzero, then sure
16:16:49 <ertesx> x :: A -> Maybe B  -- you could write this, which is very restricted, but if it turns out that you can express the same thing using, say, Monad and Alternative, then you should do so
16:17:34 <ertesx> x :: (Alternative f, Monad f) => A -> f B  -- now the *user* gets to choose whether annihilation should be part of the semantics
16:17:51 <ertesx> x :: (MonadPlus f) => A -> f B  -- at this point you have deprived the user of that privilege
16:19:23 <erisco> I don't see what changes, other than there may be more types with both Alternative and Monad instances than types with MonadPlus instances
16:19:45 <ertesx> that's exactly what changes
16:20:47 <erisco> okay, well, then if I understand what you're saying, you are saying that less laws should be involved
16:20:55 <erisco> but then why Alternative and Monad at all
16:21:04 <ertesx> f x = 2*x + 3  -- you wouldn't require Fractional, would you?  *even if* at the usage site you require Fractional, you would still define 'f' using Num
16:21:25 <marcx> offtopic, but we are all computer nerds in here so what the hell.. does vive blackfriday discount apply to european union? is it US-only? I accept PMs as well
16:21:39 <Clint> ...
16:22:18 <ertesx> that's the dumbest spam attempt i've seen this year
16:22:24 <ertesx> @where ops
16:22:24 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
16:22:28 <marcx> dumb would be calling that spam
16:22:43 --- mode: ChanServ set +o dibblego
16:23:10 <dibblego> sup?
16:23:16 <marcx> i asked one OT  question. if that deserved instant ban then so be it. but don't call it spam
16:23:26 <dibblego> marcx: ok no problem, but please stop :)
16:23:32 <marcx> sure
16:23:35 <dibblego> thanks mate
16:23:41 <erisco> you start with a specification of what the program is supposed to do
16:23:43 <geekosaur> I agree it's not a spam attempt. It is offtopic though
16:23:58 --- mode: dibblego set -o dibblego
16:24:10 <geekosaur> (and perhaps some people are a bit too itchy on the ops trigger finger...)
16:24:24 * dcoutts_ is bemused
16:24:35 <erisco> the specification is to sequence functions and short-circuiting should one fail. Though imprecise, we can find a precise meaning in MonadPlus with mzero and >>= and >>
16:24:54 <Axman6> marcx: there are plenty of off topic channels for that, such as #haskell-blah and #haskell-offtopic (IIRC)
16:25:17 <marcx> Axman6 ok noted
16:25:22 <erisco> the same cannot be said with empty because there are no assumed laws with this and >>= or >>
16:26:18 <erisco> so you can write something with empty and >>= and >>, but you cannot say it satisfies the specification
16:26:23 <erisco> so it is not a correct implementation
16:32:36 <ertesx> sorry for the noise…  normally i would have just ignored it
16:33:23 <erisco> we were on defcon 2 for a minute there
16:34:34 <ertesx> i've been on defcon -G today, but it has nothing to do with #haskell
16:36:40 --- mode: ChanServ set +o glguy
16:36:46 <glguy> I'm here!, What'd I miss??
16:37:27 --- mode: glguy set -o glguy
16:38:10 <grantwu> lol
16:39:25 <roboguy`> ha
16:47:55 <Geraldus_> Hi friends!
16:48:13 <Geraldus_> I'm trying to solve Travis timeout issue when booting GHCJS.  With GHC 8 it have no chance to boot in 50 minutes.  It is suggested to try run Travis builder locally in Docker  https://docs.travis-ci.com/user/common-build-problems/#Running-a-Container-Based-Docker-Image-Locally
16:48:28 <Geraldus_> They say I must choose appropriate Docker image, I wonder should I use Travis-Haskell or other image, e.g. Travis-base?
16:48:38 <Geraldus_> Because suggested Travis script uses `language: c`, not haskell
16:49:57 * hackagebot money 0.1.0 - Money  https://hackage.haskell.org/package/money-0.1.0 (jpvillaisaza)
16:50:15 <EvanR> you wouldnt download money would you
16:50:53 <Koterpillar> Geraldus_: I think they are only different in pre-installed packages
16:51:01 * geekosaur remembers Microsoft Money...
16:51:04 <acowley> I'd be so proud if we could maintain that joke as a community
16:51:59 <acowley> Maybe we should have acme-car that can't be downloaded
16:57:11 <Geraldus_> Koterpillar: ok, thanks
16:58:20 <EvanR> acowley: you probably wouldnt have to go that far, because probably ... literally no one would download it
16:59:46 <andrei_> Hi! When we iterate through a list, how do we know when we are on the first position ?
17:00:06 <EvanR> youre always at the first position of the rest of the list
17:00:44 <pavonia> How do we iterate through a list?
17:00:47 <EvanR> to do something different with the very beginning, you have to do the worker/wrapper thing
17:01:09 <andrei_> Write a function capitalised :: String -> String which, given a word, capitalises it. That means that the rst character should be made uppercase and any other letters should be made lowercase. For example, capitalised "mELboURNe" == "Melbourne" Your denition should use a list comprehension and the library functions toUpper and toLower that change the case of a character. Use the internet to nd out which library module they are in 
17:01:55 <EvanR> oh, you have to use a very specific method...
17:01:59 <andrei_> and I don't know how to toUpper the first letter
17:02:08 * Koterpillar wonders if "ask on IRC" counts as "use the internet"
17:02:10 <EvanR> instead of \(x:xs) -> toUpper x : map toLower xs
17:02:17 <Axman6> I guess you could use zip xs (True:repeat False) or something. having to use a list comprehension seems a bit weird
17:02:18 <dfeuer> Ping conal
17:02:25 <conal> dfeuer: hi
17:02:26 <lgstate> can haskell be viewed as the worlds most popular function-level programming language?
17:02:32 <lgstate> map/filter -> function level forms
17:02:39 <kadoban> Koterpillar: It does, why?
17:02:42 <dfeuer> conal, did you have a chance to look at that MemoTrie thing I submitted?
17:02:43 <lgstate> typeclasses: monads, functors, applicatives, ... <- more function level things
17:02:54 <lordcirth> andrei_, avoiding total spoilers, I'd recommend splitting the string into a list of words
17:02:55 <lgstate> lenses <-- also function level ish?
17:03:13 <Koterpillar> kadoban: nvm
17:03:14 <grantwu> lordcirth: ? The problem seems to indicate that the input is a single word
17:03:20 <geekosaur> SPJ once quipped that excel was the most popular functional programming language. not sure how seriously it was meant...
17:03:25 <andrei_> This s the requirement of the problem, I have to do the function as it's written
17:03:30 <dfeuer> All around the word.
17:03:34 <EvanR> lordcirth: hrm it says youll be given a word
17:03:34 <andrei_> yes, it's just a word
17:03:38 <lordcirth> grantwu, andrei_ oh, oops, I didn't read. thought it was a sentence
17:03:41 <kadoban> Koterpillar: Oh I see, I missed it in the question, heh.
17:03:51 <conal> dfeuer: i haven't. sorry. head down in my haskell-to-hardware (etc) compiler. soon, though. feel free to ping me again if I haven't replied in a few days.
17:03:52 <andrei_> so should I use map ?
17:03:55 <grantwu> andrei_: Well, do you know how to get the first element of a list?
17:04:02 <dfeuer> geekosaur, that sounds likely.
17:04:03 <andrei_> using head ?
17:04:12 <mmaruseacph2> andrei_: you could repalce map f list with [f x | x <- list]
17:04:20 <mmaruseacph2> and ask your prof if that is acceptable
17:04:30 <grantwu> andrei_: I mean with pattern matching
17:04:34 <andrei_> I don't know what [f x | ..] means ...
17:04:56 <mmaruseacph2> "Your deLnition should use a list comprehension...." <-- there
17:05:03 <lordcirth> andrei_, f is a function and x a value
17:05:06 <Axman6> > zipWith ($) (toUpper:repeat toLower) "mELbOurNe"
17:05:08 <grantwu> andrei_: Try http://learnyouahaskell.com/starting-out#im-a-list-comprehension
17:05:09 <lambdabot>  "Melbourne"
17:05:11 <conal> dfeuer: i just scanned your patch. looks very appealing.
17:05:29 <MarcelineVQ> Axman6: neat :>
17:05:34 <dfeuer> Got it, conal. It's a pretty simple idea. It depends very heavily on my conjecture that really good generics support is much more important in this context than being able to work easily with the trie representations by hand.
17:05:34 <lordcirth> Axman6, that's clever
17:06:11 <Koterpillar> Axman6: and can be rewritten with a comprehension, too
17:06:24 <Koterpillar> although I wonder whether this is the intended spirit
17:06:25 <dfeuer> If that's wrong, it's all a no-go.
17:06:32 <pipescsvhelp> In the pipes-csv example '->' is used but I get a syntax error, relevant line:         loop = await >>= s -> case s of
17:06:44 <conal> dfeuer: makes a lot of sense to me. i also have a functor-level associated trie type family (not data), which is more elegant. needs some attention as well.
17:06:54 <dfeuer> conal, where's that?
17:07:00 <grantwu> andrei_: So I think this problem is kind of ugly if they truly intend for the entire body of the function definition to be a list comprehension
17:07:18 <Koterpillar> pipescsvhelp: I think it's missing a lambda before s (\s)
17:07:18 <conal> dfeuer: in a neglected old package functor-combo.
17:07:30 <conal> dfeuer: associated with some of my old blog posts.
17:07:39 <grantwu> but I can envision taking the first character off, doing toUpper on it, and then using a list comprehension for the rest of the string
17:07:52 <dfeuer> I'll take a look at it, conal 
17:08:18 <pipescsvhelp> Koterpillar: You are right. There are other problems with the persons definition, but I can figure those out
17:08:19 <conal> dfeuer: the memo functor tries are described in http://conal.net/blog/posts/elegant-memoization-with-higher-order-types
17:08:23 <dfeuer> conal, the NonstrictMemo thing?
17:08:36 <conal> dfeuer: no. that's another experiment. also intriguing.
17:08:49 <dfeuer> conal, so ... where in that package?
17:09:05 <conal> dfeuer: oh -- you were right: NonstrictMemo
17:09:13 <dfeuer> Oh, okay.
17:09:18 <pavonia> grantwu: When you say kind of ugly, do you still see a solution that would only use a list comprehension
17:09:31 <conal> dfeuer: StrictMemo is another experiment.
17:09:37 <grantwu> pavonia: ?
17:09:49 <grantwu> What do you mean do I still see a solution that would only use a list comprehension
17:10:03 <grantwu> I can probably do something with enum
17:10:13 <grantwu> er, hold on
17:10:19 <pavonia> By not decomposing the string with head/tail, I mean
17:10:20 <conal> dfeuer: oops. no. see StrictMemo. It's *NonstrictMemo* that's the other experiment.
17:10:28 <dfeuer> Oooookay.
17:10:32 <ertesx> {- good night! -} let x1 = "{- good night! -} let x1 = "; x2 = " in putStrLn $ x1 ++ show x1 ++ \"; x2 = \" ++ show x2 ++ x2" in putStrLn $ x1 ++ show x1 ++ "; x2 = " ++ show x2 ++ x2
17:10:42 <conal> dfeuer: i was exploring how to correctly memoize functions that are not hyperstrict.
17:10:53 <dfeuer> conal, did you find a solution?
17:10:54 <grantwu> pavonia: You could do something with zip [0 ..]
17:11:38 <pavonia> Yeah, but zip isn't a list comprehension either
17:12:07 <conal> dfeuer: yes, i think so, but it depends critically on lub, for which there isn't yet a robust & efficient implementation. see http://conal.net/blog/posts/nonstrict-memoization
17:12:09 <Koterpillar> what do you mean by only?
17:12:27 <pavonia> Something of the form [ ... | ... c <- "mELbOurNe" ...]
17:12:44 <dfeuer> conal, I'll have a look-see when I can. And adding generics support for FunctorCombo.StrictMemo looks likely not to be too terribly hard.
17:12:55 <Koterpillar> pavonia: taking Axman6's solution: [f c | (f, c) <- zip (toUpper: repeat toLower) str]
17:13:16 <pipescsvhelp> Anyone here used any libraries for doing things like inner/outer joins on two Haskell collections, or perhaps any other type of relational stuff?
17:13:25 <pavonia> Koterpillar: But that has a zip in it
17:13:32 <conal> dfeuer: probably so, and maybe even more straightforward, since Generics are functor-level. 
17:13:36 <Koterpillar> oh, sorry, it doesn't have "c <- ..." part as you specified
17:13:57 <Axman6> pipescsvhelp: there's a language extension for list comprehensions which allow that I believe
17:14:05 <conal> dfeuer: functor-combo is waiting to be chopped up for parts. it was there to support some blog posts.
17:14:08 <Koterpillar> pavonia: I'm pretty sure anything of that form is impossible to write
17:14:14 <dfeuer> *nod*
17:14:32 <pavonia> I think so too
17:14:50 <pipescsvhelp> Axman6: Hm, a language extension adding relational querying to collections sounds too good to be true.
17:15:29 <Axman6> see Generalised (SQL-Like) List Comprehensions on https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/syntax-extns.html
17:17:31 <dfeuer> conal, one obvious thing is to replace most of FunctorCombo.Functor with stuff from GHC.Generics.
17:17:52 <dfeuer> Or maybe from transformers?
17:18:01 <dfeuer> GHC.Generics may still be missing a lot of instances.
17:18:14 <dfeuer> :q
17:19:13 <EvanR> for christmas i would like GHC generics to handle GADTs
17:19:38 <pavonia> Of course, GHC has an extension for everything:
17:19:40 <pavonia> > [ f c | c <- "mELbOurNe" | f <- toUpper : repeat toLower ]
17:19:42 <lambdabot>  "Melbourne"
17:19:53 <Koterpillar> meh
17:19:59 * hackagebot casadi-bindings 3.1.0.2 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.1.0.2 (GregHorn)
17:20:07 <grantwu> which extension is that?
17:20:20 <pavonia> ParallelListComp
17:20:53 <pavonia> There are also some others: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/list-and-comprehension-extensions
17:23:16 <surina> Any tips for Exercise 1, fun2?
17:23:19 <surina> http://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
17:23:55 <surina> I have been scratchig my head quite a long time with this one
17:25:58 <grantwu> that second one is kind of strange
17:26:13 <grantwu> almost collatz
17:27:14 <surina> Yeah, I would guess that first you should use iterate (\n -> 3 * n + 1)
17:30:43 <conal> dfeuer: definitely. i want to overhaul functor trie completely and see if there's still a library worth doing. probably best tackled after i process your patches. i like GHC.Generics very much and use them in a lot of new code these days.
17:30:45 <surina> But I don't know for sure.
17:32:26 <dfeuer> conal, I don't like them very much, and there are an awful lot of things I don't know how to do with them. But they seem like a good start, and hopefully the next major overhaul will be closer to fine.
17:32:54 <dfeuer> The fact that I'm limited to * and *->* is ... annoying.
17:33:09 <dfeuer> The fact that I can't deal with GADTs is pretty lousy.
17:33:25 <EvanR> yes!
17:33:48 <dfeuer> Whether any such overhaul is in the pipeline, I don't know.
17:34:07 * EvanR calls down the gods of GHC to bring forth GADT support
17:40:12 <grantwu> *GHC gods add 5% to compile times*
17:40:40 <surina> Is anyone able to help with my problem? I'm so confused. :D
17:41:47 <ezyang> surina: What have you tried so far 
17:41:50 <ezyang> and why didn't it work 
17:42:08 <surina> This is what I currently have: map (iterate (\n -> n `div`2)) . iterate (\n -> 3 * n + 1)
17:42:39 <surina> That will make an infinite list so far
17:43:14 <surina> I think there will be a final case where all the elements i a sublist are even
17:43:23 <surina> in*
17:43:43 <surina> then you could just sum them
17:44:07 <c_wraith> eventually all the elements of the inner lists are 0
17:44:21 <c_wraith> So the sum is also 0
17:44:53 <surina> not necessarily
17:45:14 <c_wraith> surina: no, it's definitely necessary with what you've written.
17:45:35 <c_wraith> Did you mean to generate the collatz sequence for each number instead?
17:46:03 <EvanR> the exercise has a shifted collatz sequence
17:46:19 <EvanR> the above is missing the shift
17:47:04 <surina> map (takeWhile (1 <)) . map (iterate (\n -> n `div` 2)) . iterate (\n -> 3 * n + 1)
17:47:41 <c_wraith> Ah.  that is different.
17:47:59 <surina> This is what I ment to write
17:48:01 <surina> :D
17:48:16 <c_wraith>  But it's still not the collatz sequence, or anything even fitting its general structure.  Are you sure you're generating the right things?
17:48:27 <surina> No at all
17:48:45 <surina> I don't know even how to start with that function
17:48:55 <surina> I just tried something
17:49:12 <grantwu> I think the general pattern is to ignore the base case
17:49:23 <grantwu> and deal with it later with the takeWhile
17:49:35 <surina> I think so too
17:49:54 <c_wraith> The big thing is that you need to branch when generating the next number of the sequence.
17:50:18 <surina> the base case adds zero to the sum, so we can just use takeWhile (1 <), I guess
17:52:38 <surina> the branching happens in the iterate?
17:53:43 <EvanR> > iterate (`div` 2) 99
17:53:45 <lambdabot>  [99,49,24,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
17:54:10 <EvanR> theres no case analysis anywhere so... no branching
17:55:39 <surina> I mean when you nest the iterate functions, of course you would need something else, so the iterate won't keep going with zeros
17:55:51 <EvanR> surina: is the exercise asking you to replace the even/otherwise guard with a case analysis on an Even/Odd view of the number
17:56:27 <EvanR> and then use iterate on that
17:57:08 <EvanR> one iterate
17:58:09 <surina> I don't know if that's allowed in the exercises
17:58:38 <EvanR> i was thrown off by the motivational reference to "more idiomatic haskell"
17:58:48 <surina> Or is that even possible to do without case analysis?
17:59:07 <Cale> You should still do the case analysis on whether something is even
17:59:19 <Cale> But the function which does that should not be recursive
18:00:00 <surina> Ok maybe I'll do that
18:00:11 <Cale> You could actually capture fun2 as an application of unfoldr to an appropriate function, followed by sum
18:00:24 <Cale> (which is itself an application of foldr)
18:00:35 <Cale> (or foldl really, but you can imagine that it's foldr for these purposes)
18:01:13 <Cale> So you're building up a list, and then collapsing it again
18:02:30 <surina> That could work
18:03:01 <dxtr> how would I do x == y if x is IO Bool and y is Bool? I thought it was something like 'liftM2 (==) x y' but maybe I'm complicating things?
18:03:31 <Koterpillar> fmap (== y) x
18:03:40 <c_wraith> dxtr: fmap (y ==) x will give you an IO Bool
18:03:42 <ezyang> liftM2 (==) x (return y) 
18:04:10 <Cale> dxtr: I think it's important to understand how to write this using do-notation first, before looking at the fancy solutions
18:04:32 <Koterpillar> @undo { x' <- x; x == y }
18:04:32 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
18:04:33 <Cale> So if x :: IO Bool, that means that x is an action which, each time it is executed, will produce a Bool result.
18:04:38 <Koterpillar> @undo do { x' <- x; x == y }
18:04:38 <lambdabot> x >>= \ x' -> x == y
18:04:49 <Cale> Koterpillar: that won't typecheck
18:04:59 <Cale> You'll want a return in there
18:05:16 <Koterpillar> @undo do { x' <- x; return (x == y) }
18:05:16 <lambdabot> x >>= \ x' -> return (x == y)
18:05:32 <Cale> So, we don't really want to compare x and y for equality, we want to compare the result of executing x with y
18:05:57 <Cale> So, do r <- x; ... -- we write an action which will first execute x, obtaining some result r
18:06:39 <Cale> So, do r <- x; return (r == y) -- and then compare the result to see if it's equal to y, returning that as its result
18:07:04 <Cale> So, this is an IO Bool action, as it may produce a different result each time it's run (and hence x gets run)
18:07:49 <Cale> heh, too much line editing, I left that "So, " in :)
18:08:03 <Cale> dxtr: Does that make sense?
18:08:32 <Cale> It's very important to understand that an IO String is very much not like a String, in the same way that /bin/ls is very much not like a list of files in your home directory
18:09:32 <Cale> (to use an analogy with unix)
18:09:38 <dxtr> Cale: Yeah
18:10:40 <Cale> Sometimes the answer will really be not to write this action that runs x and makes the comparison, but instead just to run x from elsewhere, and then make the comparison in-place
18:11:39 <surina> lol, i think i got it now
18:14:56 <dfeuer> conal, you seem to have a dependency bound issue with TypeUnary. Specifically, TypeUnary.Nat seems to rely on Prelude exporting <$>, but doesn't bound it appropriately for that.
18:35:12 <dogbitsman> Is there a way to make this work?   error couldn't match `IO a0' with actual type `[IO ()]'                                   do liftIO $ (Prelude.map (\dat -> writeFile (dat !! 0) (dat !! 1) ) links)
18:36:31 <Koterpillar> :t mapM
18:36:33 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
18:36:43 <Koterpillar> dogbitsman: you need that instead of Prelude.map
18:37:10 <dogbitsman> thks
18:37:21 <Koterpillar> or sequence
18:38:48 <grantwu> :t traverse
18:38:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:39:23 <Koterpillar> right, that one
18:44:21 <justdev987> Is there an easy way to trim whitespace from a string in Haskell? Preferably without converting to Text, and even nicer without pulling in extra third party libs
18:45:52 <MarcelineVQ> > (unwords . words) "  depends       exactly what you mean "
18:45:54 <lambdabot>  "depends exactly what you mean"
18:53:11 <lordcirth> justdev987, yeah, you'll need to be more specific
18:53:39 <lordcirth> > filter (/= ' ') " depends       exactly what you mean "
18:53:41 <lambdabot>  "dependsexactlywhatyoumean"
18:57:23 <justdev987> trim leading+trailing whitespace. " a b " -> "a b"
18:57:30 <lordcirth> ah, ok
18:57:33 <roboguy`> the answer is "yes" either way =) Of course, to really suggest something we do need specifics
18:57:52 <lordcirth> justdev987, only spaces, or all whitespace characters?
18:58:14 <justdev987> spaces + tabs. I just wrote an isWhiteSpace function
18:58:19 <roboguy`> :t dropWhile
18:58:20 <lambdabot> (a -> Bool) -> [a] -> [a]
18:58:21 <Koterpillar> :t isSpace
18:58:22 <lambdabot> Char -> Bool
18:58:35 <justdev987> dropWhile will do trimLeft easily.
18:58:51 <justdev987> how about trimRight? reverse, dropWhile, reverse back?
18:59:39 <roboguy`> :t takeWhile
18:59:41 <lambdabot> (a -> Bool) -> [a] -> [a]
18:59:56 <roboguy`> I guess you need to know if it ends or not though
19:00:00 <Koterpillar> > filter isSpace [chr 0..]
19:00:04 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
19:00:16 <Koterpillar> > length $ filter isSpace [chr 0..]
19:00:18 <lambdabot>  22
19:02:35 <justdev987> Jeez, the #haskell channel can't do rtrim? That is baby stuff
19:03:10 <grantwu> Well, you chose an unfortunate string representation.
19:03:32 <Koterpillar> you can'
19:03:35 <grantwu> It is always going to be inefficient to access the end of a string
19:03:39 <Koterpillar> you can't do better than O(n^2)
19:03:44 <Koterpillar> so do your reverse
19:03:56 <grantwu> wait, what, n^2?
19:03:58 <grantwu> That sounds wrong
19:04:10 <lordcirth> shouldn't it be O(n) ?
19:04:23 <roboguy`> yeah, I think it should be O(n) if you traverse it once
19:04:30 <Koterpillar> actually, yes
19:04:45 <grantwu> It's O(n) if you traverse it any constant number of times
19:04:50 <roboguy`> true
19:04:54 <Koterpillar> > len $ head $ filter (all isSpace) $ tails " dsafdsf a      "
19:04:56 <lambdabot>  error:
19:04:57 <lambdabot>      • Variable not in scope: len :: [Char] -> t
19:04:57 <lambdabot>      • Perhaps you meant one of these:
19:05:00 <Koterpillar> > length $ head $ filter (all isSpace) $ tails " dsafdsf a      "
19:05:02 <lambdabot>  6
19:05:23 <Koterpillar> that's O(n), now drop (length s - it)
19:05:29 <exio4> > (reverse . dropWhile isSpace . reverse . dropWhile isSpace) "  a b c d   "
19:05:31 <lambdabot>  "a b c d"
19:05:41 <exio4> the easy solution >:P
19:06:40 <systemfault> Wouldn't the easy solution to... use Text.Regex or something ugly like that?
19:07:07 <lordcirth> Regexes would certainly do it
19:08:15 <lordcirth> If you needed to do different types of string manipulation as well, import Text.Regex would probably be the way to go
19:09:10 <Profpatsch> How do I test if a bytestring is valid UTF-8?
19:09:24 <Profpatsch> Or better: How do I test when I load a file if it is?
19:09:28 <justdev987> exio4: thanks. I'll use that
19:09:45 <Profpatsch> There’s some CSV data, and I want to use cassava to parse it.
19:10:26 <exio4> Profpatsch: I would use Data.Text.Encoding.decodeUtf8'
19:10:55 <Profpatsch> exio4: You mean check for Left?
19:11:12 <exio4> yeah
19:11:25 <Profpatsch> I’m not sure if that’s particularly fast, but I just saw the cassava Parser instances assume UTF-8 everywhere.
19:11:38 <Profpatsch> So that question is probably moot anyway.
19:12:12 <exio4> does it matter for CSV?
19:13:19 <Profpatsch> exio4: Well, yes, of course.
19:14:05 <exio4> I thought the data between commas wasn't extremely important for the parsing
19:14:12 <Profpatsch> If I don’t parse it with the correct encoding, the result will probably be garbage (except if I’m lucky and it’s only ASCII, then UTF-8 will work as well afaik)
19:14:24 <Koterpillar> the quotes are encoded, too
19:14:40 <Profpatsch> exio4: I’m parsing it into Text, Integers and structured datatypes.
19:14:53 <Profpatsch> Not just into ByteStrings.
19:19:20 <monochrom> IIRC you can tell cassava to give you vectors of vectors of bytestrings. that may sidestep the not-UTF8 issue.
19:19:32 <exio4> Profpatsch: you mean the instances in https://hackage.haskell.org/package/cassava-0.4.5.1/src/Data/Csv/Conversion.hs ?
19:19:52 <exio4> that's the only thing I see that assumes UTF-8
19:20:10 <monochrom> But then you will have to roll your own "if it turns out to be funny, what do I do?"
19:20:32 <exio4> only accepting UTF-8 files seems to be the sane way here :)
19:20:44 <monochrom> But then there may be some less-well-known functions in cassava that may help you.
19:21:12 <monochrom> Overall do read the doc completely to see all your options.
19:21:28 <monochrom> Or pay money to hire someone to do it for you.
19:22:49 <Koterpillar> the 2 most universal answers
19:24:21 <monochrom> well yeah you have to invest a convex linear combination of time and money. what else is there anyway. :)
19:26:58 <monochrom> to be fair, sometimes haddock docs are hard to read because in some cases the real information is in the instances.
19:28:32 <monochrom> For example in the time library, you see many time types and you don't see many explicitly listed functions that work on them. That's because the most important functions are hidden behind "but I'm an instance of Num!"
19:32:07 <monochrom> Similarly in cassava you have to look at the long list of "instance FromField XXX" and "instance FromField a => FromRecord (YYY a)" for what is already done for you.
19:40:51 <Profpatsch> monochrom: That’s why instances should have documentation as well!
19:41:19 <Profpatsch> The only time I open LYaH is when I forget the syntax for pattern guards again.
19:41:37 <Profpatsch> Because I need them maybe once a month.
19:41:56 <Profpatsch> Boolean simply never happens. :P
19:45:35 <dfeuer> monochrom, time doesn't give enough instances to be able to actually manage well, IIRC.
19:45:52 <dfeuer> Num, but not RealFloat, I believe?
19:46:11 <dfeuer> It ends up being nasty.
19:46:18 <dfeuer> Maybe not even RealFrac?
20:04:02 <codygman> Is there a template haskell function that will tell you the name of bindings in scope?
20:06:25 <codygman> for instance if I generate a type synonym with template Haskell how would I avoid later generating that type synonym, where not attempting to generate the same things isn't an option.
20:06:54 <Koterpillar> I think there is a function that gets you a new, unique identifier
20:08:31 <neoc> hey, does someone know how to do the NICTA course? I have a ghci with it, but I don't know what to do now
20:09:22 <systemfault> I haven't done NICTA but IIRC... NICTA is recommended after CIS194
20:09:32 <neoc> yes, I did cis194
20:10:03 <dibblego> neoc: Yes.
20:10:11 <dibblego> The first thing to do is the exercises in List.hs
20:10:12 <systemfault> Ah sorry. From what you said, I thought you didn't know how to do ghci. Sorry
20:10:22 <systemfault> *to work with ghci
20:11:33 <neoc> Ah I see. I thought I start with Course.Id, but there is nothing in it like exercises. Thanks.
20:12:02 <dibblego> that's just looking at .hs syntax
21:53:14 <jdw> Hello
21:53:24 <jdw> Anyone familiar with ReadP?
22:01:45 <jle`> jdw: just ask your question :)
22:16:16 <Profpatsch> Nothing. The End.
22:20:10 * hackagebot pid1 0.1.0.1 - Do signal handling and orphan reaping for Unix PID1 init processes  https://hackage.haskell.org/package/pid1-0.1.0.1 (MichaelSnoyman)
22:21:41 <mrkgnao> how do I simplify this State code?
22:21:44 <mrkgnao> http://lpaste.net/344994
22:21:48 <mrkgnao> <http://lpaste.net/344994>
22:23:17 <jle`> mrkgnao: the "point" of State is actually to avoid manual tuple manipulation and assignment
22:24:36 <Axman6> yeah you're definitely not using State how it's supposed to be used. 
22:25:11 * hackagebot bgmax 0.2.0.1 - Parse BgMax-files  https://hackage.haskell.org/package/bgmax-0.2.0.1 (petterb)
22:25:13 <mrkgnao> yep, it almost feels like like I'm rewrite
22:25:25 <mrkgnao> rewriting the >>= instance for State
22:25:30 <jle`> M-krsiehl: http://lpaste.net/344994
22:25:41 <Axman6> I think that basically amounts to: get >>= \s -> let (xs,ys) = splitAt n in put ys >> return xs
22:26:18 <Axman6> there's definitely no need to use the state function here
22:26:22 <jle`> mrkgnao: replicateM is basically the pattern that i wrote there
22:26:27 <Axman6> use get, put and modify
22:27:08 <mrkgnao> jle`: I didn't see you write anything
22:27:24 <mrkgnao> Axman6: whoa, that looks like magic to me
22:27:25 <jle`> mrkgnao: refresh the lpaste
22:27:33 <Axman6> hmm, I think I'm misunderstanding what that code actually does now...
22:27:34 <jle`> http://lpaste.net/344994
22:27:49 <mrkgnao> oh, you can do that with lpaste? neat
22:27:54 <Axman6> yeah that's definitely replicateM n pop
22:28:17 <Axman6> (or even replicateA? is that a thing?)
22:28:21 <Axman6> :t replicateA
22:28:22 <lambdabot> error:
22:28:23 <lambdabot>     • Variable not in scope: replicateA
22:28:23 <lambdabot>     • Perhaps you meant one of these:
22:28:26 <Axman6> :(
22:29:13 <mrkgnao> I wonder if you can use State to replicate the functionality of Writer. But then I guess Writer wouldn't be a separate thing.
22:29:14 <jle`> unfortunate
22:29:28 <jle`> you can use state to replicate the funtionality of Writer
22:29:45 <mrkgnao> for some reason I find Writer and State much easier to understand than Reader
22:29:57 <Axman6> tell x = modify (<> x)
22:30:10 <Clint> :t Data.Sequence.replicateA
22:30:11 <lambdabot> Applicative f => Int -> f a -> f (Seq.Seq a)
22:30:13 <Axman6> Reader is just passing configuration around
22:30:29 <jle`> mrkgnao: Reader is like State, except there's no state modification
22:30:30 <Axman6> yeah that's not quite the right replicateA
22:30:39 <jle`> compare: Reader r a = r -> a
22:30:51 <jle`>          State  s a = s -> (a, s)
22:31:02 <jle`> just the same thing w/o the final new 's'
22:31:13 <mrkgnao> huh.
22:31:19 <jle`> so the "input state" is the same every time; it's "non-changeable"
22:31:30 <jle`> Reader r can be thought of an immutable State s
22:31:36 <jle`> you have 'get', but not 'modify'/'put'
22:31:43 <jle`> s/immutable/read-only
22:32:02 <geekosaur> mrkgnao, iirc Writer and State are closely related (one is the CPS transform of the other)
22:32:17 <geekosaur> (continuation-passing style, if you hadn't encountered that)
22:32:23 <mrkgnao> I don't understand continuations (in Haskell) yet
22:32:38 <mrkgnao> although it's on my list as being some kind of really powerful idea
22:32:54 <mrkgnao> (aka "mother of all Monads" according to sigfpe)
22:32:59 <mrkgnao> s/M/m
22:33:00 <jle`> lol
22:33:19 <jle`> claims like those are nice but they usually don't help you understand the thing itself
22:33:28 <jle`> they're usually only useful for people who already understand the thing
22:34:20 <mrkgnao> I've found the same to be true for things like "Reader
22:34:24 <mrkgnao> "Reader
22:34:53 <mrkgnao> "Reader's just passing configuration around" -- no offense, Axman6 :)
22:35:10 <mrkgnao> but that kind of thing is super helpful once you kinda sorta get it
22:35:25 <mrkgnao> just not when you're confused
22:35:25 <neoc> hey, is it possible to check if a function parameter refers to a particular infinite list without comparing elements (which causes infinite recursion...)? It's a problem in the NICTA course I can't figure out
22:35:28 <geekosaur> @unmtl Reader r a
22:35:28 <lambdabot> r -> a
22:35:29 <systemfault> reader is still not intuitive for me...
22:35:47 <mrkgnao> @unmtl
22:35:47 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
22:35:56 <mrkgnao> @help unmtl
22:35:56 <lambdabot> unroll mtl monads
22:36:03 <geekosaur> that's what a Reader r a is under the covers. just a function that takes an r and produces an a, and the Reader provides the r automatically
22:36:07 <mrkgnao> :t Reader r a
22:36:09 <lambdabot> error:
22:36:09 <lambdabot>     • Data constructor not in scope: Reader :: Expr -> Expr -> t
22:36:09 <lambdabot>     • Perhaps you meant one of these:
22:36:13 <mrkgnao> ...
22:36:19 <geekosaur> it's a type not a value
22:36:31 <mrkgnao> I know, I tend to use :t instead of :info
22:36:33 <Axman6> mrkgnao: if you've written any sort of app in haskell that has some kind of config, you'll find yourself passing it around all over the place explicitly - Reader lets you pass around that config implicitly. Many people don't understand reader because they don't see how it is useful - this is how it's useful
22:36:35 <jle`> neoc: comparing two infinite lists is in general undecidable
22:36:40 <geekosaur> there's no :info here anyway
22:37:22 <neoc> @jle` darn
22:37:23 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
22:37:41 <mrkgnao> Axman6: yes, I've been meaning to write a little interpreter for a while. if I have mutable variables, I guess State is what I want?
22:37:58 <jle`> neoc: one thing you might think about trying is reference equality, but that's in general a lie in haskell
22:38:21 <Axman6> I guess so
22:38:38 <geekosaur> but, when you write some function that produces Reader r a, you're just saying it is a function that is passed r and produces an a. You specify that r by using runReader, and the function can use ask to retrieve it (or asks to retrieve part of it) or call another function that produces Reader r a and it will also be passed that same r
22:38:57 <geekosaur> so it's shorthand for passing a parameter r to things
22:39:01 <Axman6> jle`: well, it's not a lie when two references are equal, but it can be a lie when you're told they aren't equal
22:39:19 <mrkgnao> one question though. it seems like you can "modify" the r with ... local I think it was called?
22:39:32 <jle`> i feel like i've seen a case where reference equality could be a false positive
22:39:34 <Axman6> s/when the two references are equal/when asking if two references are equal returns true/
22:39:41 <mrkgnao> geekosaur: an "r"-dependent a?
22:39:46 <Axman6> :t local
22:39:50 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
22:40:00 <geekosaur> there's also a "primitive Reader" ((->) r) which is more explicitly passing r to things
22:40:08 <Axman6> local lets you run a sub computation with a modified configuration
22:40:29 <geekosaur> local just calls some Reader r a with a different value for r instead of forwarding the one your current Reader r a has
22:40:29 <mrkgnao> so it lifts a modification of the config to a modification of config-dependent a's
22:41:09 <geekosaur> local (function that modifies or replaces a copy of your current r) (some Reader r a that should use the new value instead of the one you started with)
22:41:12 <Axman6> say I had Reader LoggingLevel a, and was running using runReader foo Normal, but wanted to run some part of my code with Debug logging, you could use local (\_ -> Debug) meBuggyCode
22:41:29 <jle`> https://www.reddit.com/r/haskell/comments/4ivvge/why_no_reference_equality/
22:41:33 <Axman6> but after the call to local, the r is what is was before
22:41:40 <jle`> suggests that a reference equality test can be a false positive
22:43:18 <geekosaur> if there's a gc that moves things around, yes potentially
22:43:41 <mrkgnao> Axman6: hmm
22:43:47 <Profpatsch> When I have a big sum type, is there a way to guarantee that I use all fields?
22:44:03 <mrkgnao> I'll go for now, bye people
22:44:03 <jle`> Profpatsch: what do you mean by use?
22:44:22 <okuu> Profpatsch: All fields or all constructors?
22:44:29 <geekosaur> local is relatively less used, but nice when you need to make a temporary change to something. often this is running a computation with different flags. in one program I used it to control caching
22:44:32 <Profpatsch> data Foo = Foo { a :: Int, b :: Maybe String, c … …}     someFunc Foo{..} = …
22:44:44 <Cale> That's a product type
22:44:44 <Axman6> Profpatsch: there's a warning for unmatches fields in case statements - but using _ -> anywhere stops that working nicely
22:45:09 <Profpatsch> I want to make sure that I get a warning when I add a field to Foo and don’t adjust the function that uses the fields.
22:45:11 * hackagebot http-client 0.4.31.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.31.2 (MichaelSnoyman)
22:45:59 <Cale> Profpatsch: Well, the point of that syntax is partly to *allow* you to not have to adjust the function when it doesn't involve the new fields.
22:46:00 <jle`> Profpatsch: if you pattern match, then you'll get an error
22:46:14 <Cale> But I suppose it's possible to see it the other way
22:46:27 <Cale> If you don't use the record syntax, it will definitely complain
22:46:32 <Cale> But then you don't get the named fields
22:47:11 <Profpatsch> Hm, maybe I should switch to some other kind of type.
22:48:12 <Profpatsch> data BusinessData = BusinessData (Map Text a)
22:48:22 <Cale> Profpatsch: What's an example of someFunc?
22:48:55 <Cale> Usually if you were able to write a function before with only some of the fields, that function will still do something meaningful when you add additional fields to the record
22:49:06 <Cale> It's adding new cases to case analysis which is the problem
22:49:29 <Profpatsch> I’m probably using the wrong abstraction here anyway.
22:49:30 <Cale> But I'm not sure how you're using the records
22:49:40 <Profpatsch> I have a big record with a lot of fields in it.
22:49:48 <Profpatsch> It’s entries for a database.
22:50:12 <Profpatsch> But I’m thinking it would be nicer to have the type be something like above.
22:50:47 <Profpatsch> How would I make it that data BusinessData = BusinessData (Map Text a) can have different types of a?
22:50:49 <Cale> So like, if I have a function which computes something about the salary of an Employee, and I add a phone number field to my Employee records, that shouldn't usually affect the function which calculates the salary thing.
22:51:27 <Cale> I'm just curious about what the real world use case is
22:51:59 * geekosaur can guess several... all of which have better solutions, like records
22:52:14 <Profpatsch> Cale: I have an Html table. When I add a new field to my business type, I don’t want to forget about the missing field.
22:52:41 <Cale> Ah, for *display*
22:52:43 <Cale> okay
22:53:14 <Cale> That's reasonable
22:53:28 <Cale> One thing you could do, is for that display function, don't use the record syntax
22:53:38 <Cale> Just pattern match with positional arguments
22:53:46 <Cale> and then when you add new fields, it will annoy you
22:53:46 <Profpatsch> Ah, I can still do that.
22:53:48 <Profpatsch> Right.
22:53:51 <Profpatsch> Cool!
22:53:55 <Profpatsch> I forgot about that.
22:54:07 <Profpatsch> I still wonder if that’s the best representation.
22:54:30 <Profpatsch> The thing is, those fields don’t all have the same type.
22:54:41 <Cale> Maybe we ought to have a syntax for complete record matches
22:55:02 <Profpatsch> But it looks more like a Map with heterogenous values (with certain attributes) than a record to me.
22:55:03 <Cale> Though it's hard to say what it ought to look like
22:55:11 <Cale> There's DMap
22:55:30 <Cale> But those won't complain at you, it's perfectly all right not to supply every possible key
22:55:35 <mrkgnao> how big is the jump from monads to monad transformers, anecdotally?
22:55:55 <Cale> mrkgnao: It can be pretty smooth, depending on the route you take
22:56:33 <Cale> mrkgnao: Monad transformers are just type level constructions which make new monads from existing ones. So they're primarily just more examples of monads
22:57:13 <Cale> mrkgnao: and then in addition to that, you need to provide a function called lift :: m a -> t m a, where t is your transformer, and m is the monad being transformed
22:57:28 <Cale> which turns an action in the original monad, into an action in the new monad somehow
22:57:38 <Profpatsch> Cale: Maybe just something like Foo {| a = a |}
22:58:07 <jle`> like monads, the best way to understand monad transformers is probably to just look at individual instances/specific examples
22:58:14 <jle`> and then see a common pattern after seeing lots of them
22:58:20 <Cale> yeah
22:58:20 <Profpatsch> Foo {|..|}: The compiler errors when not all arguments are used.
22:58:36 <Cale> Well, one particular route I like to take is to talk about Parser
22:58:45 <Cale> Because it's a great example of a monad to begin with
22:59:10 <Cale> By that, I mean  newtype Parser a = P { runParser :: String -> [(String, a)] }
23:00:03 <Cale> and then when you go about writing the instance of Monad for that, if you do it just so, and make use of the list monad, you'll realise that your definition doesn't actually involve anything specific to lists or strings
23:00:36 <Cale> and from that realisation, you can abstract it to  newtype StateT s m a = StT { runStateT :: s -> m (s,a) }
23:01:09 <Cale> I'd go over all the details with you, but it's a bit late here
23:02:46 <Cale> Maybe ping me about it some other time -- I like to give this lecture which starts out with the list and State monads, and then does Parser, and then from there, abstracts to StateT :)
23:21:10 <mthek> Hi everyone, curious to understand why this throws an indention/brackets error: http://lpaste.net/4322866802259394560
23:21:46 <Cale> mthek: Because of the second let without an 'in'
23:23:08 <Cale> you could have typed three spaces in place of that second let, and it would have given you the obvious type error instead
23:23:20 <mthek> Cale: thank you
23:23:39 <mthek> I see the type error btw. already corrected it
23:24:00 <Cale> But really, just make a .hs file and put your definitions in there
23:24:32 <mthek> I have but was just playing with somethng in the repl 
23:25:12 <Cale> Yeah, if anything I'm doing in the repl won't fit on a line, I will just shove it into whatever I'm working on, at least temporarily.
