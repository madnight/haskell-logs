00:02:44 <kadoban> athan: Most obviously, bitcoins are created when you mine a block. When you mine a block you are allowed to include a transaction that pays you BTC from nowhere. Slightly more obscurely, bitcoin transactions include arbitrary scripts. When you spend a coin, you write a script such that anyone who can "solve" it (finish the program with some conditions holding), has the ability to spend *your* spend. So you could spend some coins you got, and in that 
00:02:45 <kadoban> spend make it a math problem, so anyone who knows what 2+2 is gets to spend in. In no sense did that transaction go to an address at all.
00:04:46 <athan> ! thanks kadoban
00:05:29 <kadoban> Anytime
00:12:57 <kirillow> Why is a point free style preferable? (If it is?)
00:15:11 <EvanR> i would only prefer it when its a simple sequence of composed functions, or its obvious that you can eta reduce a lambda
00:15:13 <cocreature> kirillow: I don’t think it’s always preferable. it depends on which version is more readable and that’s a very subjective decision that needs to be made separately for each definition
00:16:02 <kirillow> what do you mean by "its obvious that you can eta reduce a lambda", EvanR?
00:16:11 <EvanR> map (\x -> f y x) foos
00:16:20 <EvanR> map (f y) foos
00:16:36 <athan> kirillow: it's closer to being an arrow than something that churns things
00:16:43 <platz_> is there a way to convert "do x <- liftIO a; y <- b; z <- liftIO c"  to something like "do x <- a; z <- lower? b; z <- c" ?
00:17:34 <athan> platz_: you'd need to have a function `IO a -> m a` where the monadic state is retained :)
00:17:47 <athan> i think monad-control might tickle something along this line, but I never use it :\
00:18:21 <cocreature> monad-control will still require more plumbing until it gets more complicated than the liftIO version
00:18:23 <platz_> ah, i see.. thanks.   all roads eventually lead to monad-control !
00:19:33 <platz_> right, probably not worth it for style alone
00:20:20 <ania123> how is type declaration defined?
00:20:31 <ania123> using type command or data command?
00:20:56 <cocreature> ania123: sorry I don’t understand your question
00:21:00 <athan> types are just macros
00:21:05 <ania123> for example
00:21:09 <ania123> type String = [Char]
00:21:10 <ania123> and
00:21:11 <athan> data is where you can make an algebraic data type ania123 
00:21:16 <ania123> data String = [Char]
00:21:21 <ania123> what is deferent?
00:21:27 <cocreature> data String = [Char] is not valid syntax
00:21:32 <cocreature> you need a constructor name
00:21:36 <athan> type is just saying `String is an abbreviation for [Char]`
00:21:38 <cocreature> data String = String [Char]
00:22:11 <ania123> data Bool = True | False
00:22:14 <ania123> is correct?
00:22:19 <EvanR> [ ] is a constructor name ;)
00:22:36 <ania123> type Bool = True | False
00:22:45 <cocreature> "type" does not create a new type. this means that you can use any value of type [Char] where a String is required and the other way around
00:22:58 <cocreature> EvanR: yeah but it’s already used for lists (and you can’t define it yourself)
00:23:17 <liste> ania123: "data Bool = True | False" is valid syntax, "type Bool = True | False" isn't
00:23:23 <cocreature> "data" on the other hand does create a new type. this means that you can’t use a value of type [Char] where a String is required and the other way around
00:23:31 <EvanR> data String = Maybe Char would work if you forgot the prelude
00:23:42 <EvanR> and be confusing as hell
00:23:51 <pavonia> ania123: The righthand side for "type" must ba a type
00:24:34 <cocreature> type synonyms (i.e. the things defined by "type") are very similar to typedefs as you can find them in c or c++ (obviously that only helps if you are familiar with one of those languages)
00:24:43 <EvanR> we really should have gone with type for new data type and "alias" or "synonym" or something for type synonyms
00:25:15 <EvanR> i guess it was inspired by how "typedef" also doesnt define a new type in C
00:26:51 <EvanR> in miranda it was like: String = [Char], and its also like this in idris
00:29:29 <ezyang> Help me name a short combinator which, in a test suite, says, "This subcommand is expected to fail" 
00:29:49 <ezyang> Old name is shouldFail but it's too long ^^" 
00:29:58 <bas__> I wanted to say exactly that
00:30:03 <bas__> shouldFail
00:30:05 <bas__> :'(
00:30:10 <ezyang> ok fine we'll keep shouldFail haha 
00:31:21 <cocreature> ezyang: don’t have tests that fail and you don’t need to write it that often :)
00:31:31 <ezyang> I wonder if I can write a constraint polymorphic function that makes different choices based on the constraints a passed in function needs 
00:31:52 <ezyang> cocreature: No, I'm testing that the command does fail! (if it doesn't fail, that's a bug) 
00:32:03 <cocreature> oh ok
00:32:16 <tdammers> ezyang: depends how the rest of your lingo works - if you word your assertions as factual descriptions of the desired situation, you could name your combinator just "fails"
00:32:33 <ezyang> oh, fails is nice 
00:33:14 <tdammers> (along with "holds", "equals", etc.)
00:40:36 <ezyang> So, here is a piece of code which tracks what is "needed", and then does type-based dispatched based on that http://lpaste.net/330233 
00:40:50 <ezyang> I'm wondering, is there a way to do this with constraints, instead of a phantom type variable in M? 
00:43:21 <ezyang> I can certainly do it with separate runners for needs_x and needs_y but it doesn't seem possible to overload 
00:44:20 <afidegnum> hello good morning, all, i have been reading about haskell, which i seems to grasp a litle even though there is more to lean 
00:44:23 <afidegnum> learn
00:44:28 <afidegnum> however i have a pertinent question
00:44:36 <afidegnum> what's the best principle to follow to design a functional program ? in order to follow the type signatures, to know the right key functions to use to make it a sucessful written program? 
00:45:39 <Cale> afidegnum: I'm... not sure what an answer to that question would look like
00:46:19 <cocreature> refactor until you are happy :)
00:49:26 <Cale> afidegnum: you might find this talk helpful though http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
00:49:53 <afidegnum> Cale: ok, thanks, let me look at that, 
00:50:12 <Cale> It's just *a* technique, but it's one where when it works, it tends to work really well.
00:50:16 <gry_> Hello, friends.
00:50:23 <Cale> Hello!
00:51:11 <joncol> Hi, can I use `fromFunction` (from repa) when the second argument (a function :: sh -> a) returns a monadic value? I.e. is it a good idea to have delayed arrays (in repa terminology) of monadic values? 
00:51:22 <afidegnum> well i thought initially, when i started to read about FP, i could write few math Formulas to deduct what i need to achieve but i notice there is more than that, because if we are going to develop some application as the user wanted it, some doean't even thold in an algebraic domains
00:51:56 <afidegnum> and secondly, chaining funcitons and other syntaxes inside the program must follow some principles, 
00:52:13 <afidegnum> in OOP world we have UML which we rely on, but along the line they don't fit rather, 
00:52:34 <Cale> afidegnum: Type signatures are our equivalent of UML, I think.
00:52:51 <Cale> Except it works better than UML, because it's machine checked
00:53:42 <Cale> and for various other reasons (it allows discussion of some higher order things which are difficult to describe in UML diagrams)
00:55:07 <Cale> joncol: You could perhaps store a bunch of IO actions in a delayed repa array, but it's not exactly the sort of thing that repa is trying to help you do.
00:55:45 <kadoban> Will it even let you? I thought stuff you stored had to belong to that one typeclass that pretty much means it can be stored unboxed or something.
00:56:00 <gry_> Quick question. Am I allowed to post a link to my blog in here? I recently published my first blog post (incidentally about Haskell!) and I'd like some feedback about it.
00:56:17 <Cale> kadoban: I think delayed arrays get around that restriction
00:56:26 <Cale> gry_: sure, if it's about Haskell, go for it
00:56:31 <kadoban> Ahh
00:57:05 <gry_> Cool. Here it is https://kai-sassnowski.com/haskell/2016/11/06/understanding-filterm.html
00:57:42 <gry_> The working title was "filterM fuckery" but I didn't think that would make for a very good title, heh.
00:58:00 <Cale> I like to read that filterM thing as "for each element of the list, take it or leave it"
00:58:07 <Cale> (in all possible ways)
00:58:21 <joncol> Cale: I'm trying to use it on my ray tracer. My tracePixel function is of the type ~ :: (MonadIO m, MonadReader m) => DIM2 -> m RGB8. (I'm using random grid generation for supersampling, that's why i need IO.) It seems repa should be useful here...
00:58:42 <joncol> (MonadReader is for reading in the scene)
00:58:53 <gry_> Cale: It just blew my mind when I first saw it
00:58:54 <Cale> joncol: ah, hmm
00:59:04 <Cale> gry_: Yeah, I think it does the same for everyone
01:00:04 <joncol> kadoban: If you were asking me (if it works), then I think not. I've tried but got type errors I couldn't really get around (or fully understand)
01:00:52 <gry_> (also feel free to correct my english)
01:00:59 <sdx23> joncol: do you need random by IO in there? Not pass a generator?
01:01:03 <kadoban> gry_: You note that ghci gives you a different type signature. That likely depends on what version of GHC you have (Applicative vs Monad, right?)
01:01:15 <gry_> kadoban: Exactly
01:01:22 <gry_> That really confused me (still does)
01:02:07 <gry_> Because doesn't that sort of change the function? Like isn't a function that's working with a Monad type constraint more .. well constrained than one that's operating on applicatives?
01:02:11 <gry_> Or am I missing something?
01:03:01 <kadoban> gry_: Yes, Monad is a stronger requirement than Applicative, all Monads are Applicative. So the function type was made more general somewhat recently, so it can be used with more possible actual types (there's more Applicatives than Monads)
01:03:09 <kadoban> As far as I know its behavior didn't otherwise change at all.
01:03:27 <Cale> joncol: I'm not an expert on repa, but I don't know that it has anything like sequence or traverse which would help you turn an array of actions into an action that computes an array
01:03:40 <EvanR> gry_: i read the post. this is great because i was just complaining about haskell blog posts usually being way too advanced for most people
01:03:45 <gry_> kadoban: I see, interesting.
01:03:57 <Cale> (the "Traversal" stuff that it does have seems to be using that word in a different way)
01:04:14 <gry_> EvanR: Happy to hear that. This really just a brain dump of me trying to understand this weird filterM function!
01:04:33 <EvanR> gry_: near the end, you say something about evaluating left-to-right or right-to-left, and ive heard others say something similar, but i think thats a misunderstanding in how things are getting evaluated
01:04:51 <EvanR> haskell doesnt evaluate left to right or right to left
01:05:12 <kadoban> gry_: I like the post too. By the way though: "I’m leaving of the map call and only focus on the filterM expression here."  s/of/off/ s/focus/focusing/
01:05:19 <Cale> gry_: It's just like the usual filter function, except the results of the conditional are allowed to come from executing an action in whatever monad. For the list monad instance, "running" a list means picking an element from it in all possible ways (and in the end, we collect up a list of all the possible results)
01:06:03 <Cale> So our conditional here says, no matter what the element is, we're going to try both options of either keeping it, or throwing it away
01:06:11 <Cale> We could also do something more interesting...
01:06:35 <Cale> > filterM (\x -> if even x then [True, False] else [True]) [1,2,3,4,5]
01:06:38 <lambdabot>  [[1,2,3,4,5],[1,2,3,5],[1,3,4,5],[1,3,5]]
01:06:55 <Cale> Now we have to keep the odd elements, but we may or may not keep the even ones.
01:07:08 <joncol> sdx23: Yes, that should be possible. And I *could* change all my calls to explicitly take a Scene parameter instead of relying on MonadReader, but it feels a bit ugly.
01:07:46 <gry_> EvanR: Hm. What I was trying to get at is basically foldl vs foldr. The way I evaluated it (manually) I stepped through the list from left to right. The the function is implemented (both the Monad as well as the Applicative version of it) go from right to left. 
01:07:57 <kadoban> gry_: Also "Sf b is True"
01:08:41 <Cale> joncol: The general idea of repa though I think is that you're meant to be doing computations not in an element-by-element fashion -- it's supposed to get you better performance through the fact that the computation of the elements is independent and can be done in parallel.
01:08:43 <EvanR> gry_: not sure thats right either, the particular way to describe evaluation is kind of tricky to get precisely right in haskell
01:08:44 <gry_> kadoban: Whoops. Thanks for pointing that out. I was so excited to publish it I sort of skipped proof reading it!
01:08:51 <Cale> joncol: For IO actions, that generally wouldn't be true.
01:09:20 <gry_> EvanR: Hm. Better to leave that whole part out maybe? Since it doesn't really matter as much anyways?
01:09:28 <Cale> gry_: Both foldl and foldr process the list from left to right, because you basically can't process a list in any other way.
01:09:34 <kadoban> gry_: Anytime. It's hard when you write it yourself, you tend to read it the way you meant it, hehe. I think that's all I saw though.
01:09:48 <Cale> @src foldl
01:09:49 <lambdabot> foldl f z []     = z
01:09:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:09:50 <Cale> @src foldr
01:09:50 <lambdabot> foldr f z []     = z
01:09:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:09:59 <EvanR> i dont know, im just mentioning it for your own benefit and whoever you talk to next at your haskell meetup!
01:10:03 <Cale> They both start out pattern matching on the beginning of the list
01:10:58 <gry_> Cale: I see. The difference between the folds are still kind of vague to me. Like I usually don't see whether foldl or foldr is needed in a particular case
01:10:58 <tdammers> yeah, it's just that one of them starts applying the accumulation function right away, while the other goes on to find the end of the list first
01:10:59 <joncol> Cale: I see your point
01:11:07 <Cale> But while foldr immediately passes control to f in the recursive case (which allows it to potentially do some work or even produce a final result before it needs to examine its second argument so the foldr continues)
01:11:24 <Cale> foldl by contrast just applies itself to new parameters until it reaches the end of the list
01:11:39 <gry_> Same thing that I mention about monads. I understand the theory behind them. I'm just lacking "intuition" if you will
01:11:55 <gry_> (Not sure if that's really the right word for it)
01:12:00 <tdammers> intuition comes with exposure
01:12:08 <Cale> This means that foldl will never work on an infinite list, because those don't have an end :)
01:12:19 <Cale> on the other hand, foldr will:
01:12:35 <Cale> > foldr (\x xs -> x : 10*x : xs) [] [1..]
01:12:38 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,14...
01:12:48 <EvanR> fold examples that produce lists ;_;
01:12:57 <EvanR> do a foldr example that implements `and'
01:13:04 <kadoban> gry_: Keep writing blog posts like this (actually using and exploring stuff) and you'll understand them in no time (as a hint which helped me: there's little there to actually understand, except that (>>=) and 'return' exist and some laws that make them behave sanely)
01:13:15 <Cale> EvanR: What's wrong with those?
01:13:38 <Cale> When I think about foldr, the canonical starting point for me is this:
01:13:41 <gry_> Thanks a lot for the feedback guys!
01:13:42 <Cale> > foldr (:) [] [1..]
01:13:42 <joncol> Cale: So how should I think about this when I want pseudo random numbers for my pixel processing? Should I pregenerate a large enough array of random numbers and pass that to my tracePixel function?
01:13:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:13:47 <gry_> Man, this channel really _is_ nice.
01:13:51 <Cale> (well, with an arbitrary list argument)
01:14:02 <EvanR> Cale: ... that isnt illuminating at all, since it does nothing
01:14:12 <Cale> That's exactly why it *is* illuminating
01:14:15 <EvanR> its certainly not "folding" in the intuitive sense
01:14:19 <Cale> foldr f z replaces each (:) in the list with f, and the [] at the end with z
01:14:20 <kadoban> gry_: Ya, #haskell is my favorite place on IRC
01:14:39 <Cale> and so replacing each (:) with (:) and the [] with [] will always do nothing
01:14:54 <EvanR> yeah, but explaining foldr as "imagine foldr (:) [] xs as replacing every : with a :"
01:15:04 <Cale> So, from there, we can try replacing them with similar things, perhaps changing one of the two a little
01:15:10 <EvanR> i wouldnt be able to take myself seriously
01:15:12 <Cale> > foldr (:) [4,5,6] [1,2,3]
01:15:15 <lambdabot>  [1,2,3,4,5,6]
01:15:26 <Cale> Replacing the [] at the end with another list will result in concatenation.
01:15:53 <Cale> > foldr (\x xs -> 2*x : xs) [1,2,3]
01:15:55 <lambdabot>  <[Integer] -> [Integer]>
01:16:02 <Cale> oops
01:16:05 <Cale> > foldr (\x xs -> 2*x : xs) [] [1,2,3]
01:16:07 <lambdabot>  [2,4,6]
01:16:32 <Cale> Replacing each (:) with a function that multiplies the number by 2 before adding it to the list will multiply all the elements by 2
01:16:44 <EvanR> also, the example is used way too much, so were not helping anyone learn non-list ways to use foldr
01:17:15 <EvanR> and you just implemented map
01:17:21 <Cale> Right, we did
01:17:31 <Cale> map f = foldr (\x xs -> f x : xs) []
01:17:32 <EvanR> so its like... weve covered three things which seem pointless uses of foldr
01:17:53 <gry_> Wait, the foldr example on an infinite list behaves exactly the opposite way than I'd expect it..
01:17:56 <Cale> We can also do filter rather nicely
01:18:12 <gry_> I thought foldr doesnt start applying f until the end of the list is reached
01:18:15 <Cale> filter p = foldr (\x xs -> if p x then x : xs else xs) []
01:18:20 <Cale> @src foldr
01:18:20 <lambdabot> foldr f z []     = z
01:18:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:18:26 <Cale> ^^ it applies f immediately
01:18:52 <gry_> But wouldn't the argument to f, i. e. the recursive call be evaluated first?
01:18:55 <Cale> no
01:19:03 <Cale> Lazy evaluation, remember?
01:19:12 <gry_> Right.. that
01:19:13 <Cale> Lazy evaluation is outermost-first
01:19:25 <kirillow> why cant I check whether "Nothing `elem` xs" where "xs" is a "[Maybe a]"
01:19:37 <gry_> That's wrinkling my brain.
01:19:44 <EvanR> > foldr (&&) True [False..]
01:19:47 <lambdabot>  <hint>:1:25: error: parse error on input ‘]’
01:19:48 <Cale> So this argument is supplied to f unevaluated, and only if f pattern matches on it (or it's returned as part of the result to be evaluated later) will the evaluation of the foldr proceed
01:20:01 <EvanR> > foldr (&&) True (repeat False)
01:20:04 <lambdabot>  False
01:20:33 <EvanR> > foldr (&&) True [True,True,True]
01:20:34 <gry_> Ok, I believe I need to play around with this for a bit later.
01:20:36 <lambdabot>  True
01:20:36 <Cale> gry_: Here's the standard tutorial I like to give
01:20:50 <Cale> gry_: Let's consider the following function: double x = x + x
01:21:02 <Cale> and suppose we want to evaluate the expression  double (double 5)
01:21:32 <Cale> Under innermost-first evaluation that you're probably used to from other languages, it would go like this:
01:21:37 <Cale> double (double 5)
01:21:43 <Cale> -> double (5 + 5)
01:21:46 <Cale> -> double 10
01:21:49 <Cale> -> 10 + 10
01:21:50 <Cale> -> 20
01:21:56 <Cale> right?
01:22:23 <Cale> Now, we might also try just evaluating everything outermost-first in a naive way, and that would look like this:
01:22:28 <Cale> double (double 5)
01:22:34 <Cale> -> double 5 + double 5
01:22:42 <Cale> -> (5 + 5) + double 5
01:22:46 <Cale> -> 10 + double 5
01:22:50 <gry_> Right
01:22:52 <Cale> -> 10 + (5 + 5)
01:22:55 <Cale> -> 10 + 10
01:22:57 <Cale> -> 20
01:23:16 * hackagebot hreader-lens 0.1.2.0 - Optics for hreader package  https://hackage.haskell.org/package/hreader-lens-0.1.2.0 (dredozubov)
01:23:28 <Cale> But you'll notice this took more steps: when we substituted double 5 into the body of the definition of double, we duplicated the work we'd have to do later on
01:23:33 <gry_> Is that analogous to call-by-name vs call-by-value in scala?
01:23:47 <gry_> i.e. only evaluate an argument when it is actually needed?
01:23:58 <Cale> I can never remember which way around the call-by-X things go because in my head functions are not called, they're applied
01:24:36 <EvanR> not to be confused with pass-by-value and pass-by-reference
01:24:44 <Cale> I believe call by value is innermost-first?
01:24:51 <gry_> Cale: Correct
01:24:53 <EvanR> which i always do when that comes up
01:25:18 <gry_> In my mind, call-by-name = lazily evaluate that parameter
01:25:39 <EvanR> but youre not even calling the parameter.... i dont get these jargons
01:25:46 <Cale> Ah, yeah, looking them up on wikipedia, call by name is plain outermost-first evaluation
01:25:50 <gry_> Yeah, me neither
01:25:55 <Cale> while call by need means lazy evaluation
01:26:05 <gry_> Alright, just wanted to clarify
01:26:09 <Cale> Yeah, these terms don't really make any sense to me
01:26:12 <Cale> heh
01:26:15 <Cale> anyway
01:26:25 <Cale> in lazy evaluation we make one extra rule:
01:27:00 <Cale> whenever a variable is bound to an expression, any evaluation done to that expression is shared between the occurrences of the variable
01:27:26 <Cale> We can represent that sharing using let-expressions, so the reduction would then look like this:
01:27:29 <Cale> double (double 5)
01:27:45 <Cale> -> let x = double 5 in x + x   -- note here that we're still reducing the outermost double first
01:27:56 <Cale> -> let x = 5 + 5 in x + x
01:28:00 <Cale> -> let x = 10 in x + x
01:28:03 <Cale> -> 10 + 10
01:28:04 <Cale> -> 20
01:28:14 <Cale> So this solves our duplication of work problem
01:28:28 <gry_> Right
01:28:30 <Cale> Under innermost-first evaluation, each argument to a function is evaluated exactly once.
01:28:31 <EvanR> that seems too eager
01:28:44 <Cale> Under outermost-first evaluation, each argument to a function is evaluated zero or more times.
01:29:01 <Cale> Lazy evaluation sort of gets the best of both worlds, and each argument gets evaluated zero or one times.
01:29:18 <EvanR> let x = exp in body(x), doesnt mean exp gets evaluated next, in general
01:29:20 <Cale> EvanR: Well, (+) is strict
01:30:00 <Cale> We want to evaluate x + x, but we can't because (+) can't do any work without knowing what both its arguments are (at least in this scenario)
01:30:25 <EvanR> + is a special case
01:30:41 <Cale> Well, any function that pattern matches on its argument is similar
01:30:55 <Cale> It's just, I didn't care to unfold the (+) into some sort of case expression
01:43:17 * hackagebot tcp-streams 0.6.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.6.0.0 (winterland)
01:43:19 * hackagebot elm-export 0.5.0.2 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.5.0.2 (krisajenkins)
01:48:17 * hackagebot tcp-streams-openssl 0.6.0.0 - Tcp streams using openssl for tls support.  https://hackage.haskell.org/package/tcp-streams-openssl-0.6.0.0 (winterland)
01:54:37 <ania123> type Pos = (Int,Int)
01:54:43 <ania123> is syntactically ok?
01:55:26 <lyxia> Yes, you can just try it in ghci BTW.
01:58:11 <ania123> lyxia: what Pos abreviation means? I found it in the web
02:00:25 <lyxia> "Position" I guess
02:03:32 <reygoch> hi, anyone here working on a windows machine?
02:30:17 <joncol> reygoch: If I must
02:30:36 <joncol> Oh, he already left :)
02:50:40 <kuribas> :t fromRational . toRational
02:50:42 <lambdabot> (Real a, Fractional c) => a -> c
02:50:53 <kuribas> @hoogle (Real a, Fractional b) => a -> b
02:50:56 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
02:50:56 <lambdabot> Data.GI.Base.ShortPrelude realToFrac :: (Real a, Fractional b) => a -> b
02:50:56 <lambdabot> CorePrelude realToFrac :: (Real a, Fractional b) => a -> b
02:53:20 * hackagebot servant-elm 0.2.0.0 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.2.0.0 (mattjbray)
02:57:25 <kuribas> xb
03:03:48 <jle`> uguhghhhg just spent six hours until 3 am tracking down a bug that was just a recursive call where i forgot to subtract 1 from an Int v.v
03:04:16 <ongy> that's why you get yourself a rubber ducky
03:04:26 <jle`> it's actually the point where i turned Int's into inductive type-level nats so literally the most error prone point in dependently typed haskell code v.v
03:04:45 <jle`> it was mostly printf debugging lol
03:06:32 <ongy> I hope you know of Debug.Trace
03:07:03 <jle`> yeah, that was what i was using ._.
03:07:30 <jle`> how else would you do printf debugging in haskell lol
03:07:38 <jle`> maybe with unsafePerformIO i guess heh
03:07:49 <geekosaur> that's what you *are* doing :p
03:08:10 <jle`> i mean, naked unsafePerformIO's :o
03:08:52 <ongy> @src trace -- I highly doubt it
03:08:52 <lambdabot> Source not found. Take a stress pill and think things over.
03:09:01 <jle`> maybe i should use liquid haskell to help with these moments
03:09:16 <jle`> ongy: trace is implemented using unsafePerformIO, or if not, could be, heh
03:09:34 <ongy> I doubt that lambdabot has the source. not that it's unsafePerformIO
03:09:37 <jle`> trace str x = unsafePerformIO (putStrLn str) `seq` x, or something like that
03:09:42 <jle`> ah
03:10:07 <geekosaur> you actually didn't test that though, @src is dumb and looked for the comment too :)
03:10:17 <ongy> really?
03:10:27 <ongy> @src head -- does it?
03:10:28 <lambdabot> Source not found. Abort, Retry, Panic?
03:10:29 <ongy> @src head
03:10:30 <lambdabot> head (x:_) = x
03:10:30 <lambdabot> head []    = error "Prelude.head: empty list"
03:10:40 <geekosaur> actually it looked for a method -- in the typeclass trace
03:10:53 <geekosaur> er, nit quite.
03:11:00 <geekosaur> @src List fmap
03:11:00 <lambdabot> Source not found. Just try something else.
03:11:09 <geekosaur> @src [] fmap
03:11:09 <lambdabot> fmap = map
03:11:17 <jle`>  @src isn't that smart heh
03:11:25 <jle`> the text file literally has a line saying "[] fmap"
03:11:52 <jle`> so it would treat it like any other lookup i believe
03:12:01 <geekosaur> so yes, anyway, it's dumb about such things
03:12:36 <jle`> time to add a feature to lambdabot to append to the @src file
03:13:50 <jle`> oh wait that's just @quote isn't it
03:14:17 <kuribas> jle`: must of the bugs in my code now are stupid logic mistakes (|| instead of &&) and one off errors.
03:14:25 <marble_visions> hi all, I don't see why I can't do: http://pastebin.com/rU0KQcy2 - ghci tell me I've got multiple declarations of A and B
03:14:49 <kuribas> marble_visions: ghci is right
03:15:21 <marble_visions> kuribas: does that mean that the record definitions need to be inside C?
03:15:41 <marble_visions> i think i'm not understanding something fundamental
03:15:59 <kuribas> marble_visions: it means you cannot have both a constructor A :: Int -> String -> A and A :: C
03:16:26 <kuribas> marble_visions: so you need to rename A :: C , for example C_A :: C
03:17:10 <kuribas> marble_visions: "data C = C_A A | C_B B"
03:17:53 <kuribas> marble_visions: sorry, make that C_A :: A -> C
03:20:00 <kuribas> marble_visions: you could put the record inside C, but then you have partial accessor functions.
03:20:07 <kuribas> Which is bad
03:20:54 <marble_visions> kuribas: ah. C_A :: A -> C should work for me but it seems a bit strange.. Is there a better way to describe that a type is composed of values from one type and values from another, or is this the straightforward way?
03:21:07 <kuribas> no this is the way
03:22:21 <marble_visions> kuribas: thanks a bunch for the help! :)
03:22:55 <kuribas> np
03:28:43 <abbe> Hi
03:30:12 <abbe> I watched a talk about Lenses, and Monad Transformers, and was trying to implement something to understand it. I am wondering if someone could help understanding why this is not working.
03:30:13 <abbe> https://pastebin.com/ZT4pmh4T
03:31:07 <abbe> line 96, when i uncomment it, i get: Could not deduce (MonadError DbError m) arising from a use of ‘throwError’
03:32:49 <lyxia> you're missing the MonadError DbError m constraint in the type signature line 92
03:33:11 <abbe> hmm
03:33:54 <abbe> lyxia: although 'AsDbError e' is there, and DbError is an instance of AsDbError
03:34:28 <lyxia> Oh. Well throwError will not automatically convert its argument.
03:34:57 <abbe> Okay, so then maybe I'm not doing it the right way.
03:35:08 <abbe> What is the right way ?
03:35:29 <lyxia> you just need to apply the _DbError prism to your error
03:36:47 <lyxia> AsDbError provides you a way to convert DbErrors to e, but you still have to apply that conversion explicitly at some point
03:38:21 * hackagebot cufft 0.7.5.0 - Haskell bindings for the CUFFT library  https://hackage.haskell.org/package/cufft-0.7.5.0 (RobEverest)
03:43:45 <abbe> thanks lyxia, that was it.
04:16:34 <blue1234> this is more of a Maths question but
04:17:22 <blue1234> how on earth do you calculate the size of a pizza when the diameter is 10cm and the pizza base costs 0.001cm^2 and the toppings are 0.002 cm^2?
04:17:55 <lyxia> blue1234: join ##math
04:18:11 <blue1234> k thanks
04:18:22 * hackagebot regex-do 1.5 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.5 (procione)
04:22:33 <merijn> I'm looking for something similar to Levenshtein distance, but for rankings. i.e. I'm trying to compare two rankings for similarity. The problem with Levenshtein distance is that it includes insertions/deletions which can introduce duplicate elements, which isn't possible for a ranking
04:23:10 <blue1234> lyxia: don't suppose you can help me out?  Math isn't helping
04:24:32 <grantwu> merijn: Would something like https://en.wikipedia.org/wiki/Cycle_sort be useful?  Sorting one ranking in terms of another
04:35:56 <joco42> any comments on this ? http://stackoverflow.com/questions/40487132/what-would-be-the-type-of-react-createclass-in-haskell
04:36:01 <kuribas> Can I skip to an address in a file, and read a chunk into a lazy bytestring?
04:36:41 <kuribas> Nevermind, hGet should work.
04:39:05 <rightfold> joco42: the () => included a hidden "this" parameter not present in the Haskell translation
04:39:18 <rightfold> This "this" parameter in turn provides access to component state and refs
04:39:34 <rightfold> These should be available to the Haskell render function as well
04:41:58 <tdammers> javascript's "this" is weird
04:42:20 <tdammers> if it were just a hidden argument, translating it to Haskell would be straightforward
04:42:34 <rightfold> I wish TypeScript encoded type of this in a function type
04:42:42 <joco42> rightfold:  hmmm
04:42:49 <joco42> interesting
04:43:16 <tdammers> I'm actually amazed that typescript doesn't do that
04:43:20 <rightfold> If you look at some of the PureScript react bindings, they pass state to the render function as Ana rgument
04:43:32 <janika99> szia
04:43:33 <janika99> paj
04:43:35 <janika99> mizu
04:44:02 <joco42> so, rightfold , you say that the original definitions here are wrong too ? https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589#formal-type-definitions 
04:44:03 <tdammers> rightfold: yes, that's how it's "supposed" to work, and it's as close as you'll get to how "this" is generally intended to be used
04:44:09 <rightfold> tdammers: function types in TS are weird anyway, for example parameter names are required in them (why??) and they're bivariant
04:44:15 <joco42> szia janika99  (in Hungarian) :)
04:44:31 <tdammers> rightfold: vOv - typescript feels a lot like "lipstick on a pig" to me
04:44:48 <joco42> I mean these 
04:44:48 <merijn> kuribas: Note also hSeek to skip directly to the relevant chunk
04:44:52 <joco42> https://www.irccloud.com/pastebin/KzYdvszI/
04:45:00 <joco42> i mean these ^
04:45:16 <kuribas> merijn: yeah, hSeek + hGet should work.
04:45:24 <joco42> is this  also flawed ?
04:45:35 <kuribas> merijn: and be efficient I suppose
04:46:08 <merijn> grantwu: Perhaps, not entirely sure how I could directly apply that
04:46:41 <merijn> grantwu: Maybe I should just do custom Levenshtein without insert/delete (just swaps and replaces)
04:46:58 <rightfold> joco42: they are correct somewhat, but not very precise, you should think of type .. = { .. } like a Java interface; "this" implicit. However in this type definition it seems you can't distinguish between records and interfaces, so how to use "this" relies on informal documentation
04:47:17 <joco42> omg... thanks !
04:47:47 <joco42> so a proper way to describe that i haskell might clarify things...
04:48:38 <joco42> this looks interesting https://github.com/purescript-contrib/purescript-react/blob/master/src/React.purs
04:50:04 <rightfold> joco42: the key thing there is:
04:50:11 <rightfold> type Render props state eff =
04:50:11 <rightfold>   ReactThis props state ->
04:50:54 <stobix> Heh. I just told lambdabot to make my expression pointfree. Now I'm trying to get the type of (.map) . Is there some document somewhere that can help me understand why (.map) has the type (([a] -> [b]) -> c) -> (a -> b) -> c?
04:51:11 <joco42> thanks rightfold , i look into that
04:51:42 <shlevy> I'm adding to the sctp bindings in socket-sctp, and I need a haskell representation of sctp_assoc_t, which is an implementation-specific integral type. Is there some hsc magic to say "whatever kind of int sctp_assoc_t is, give me the corresponding haskell integral type"?
04:52:29 <merijn> shlevy: I forgot the details of HSC, but is sctp_assoc_t a struct or a pointer to a struct?
04:52:48 <shlevy> it's an int, e.g. on linux it's int32_t
04:53:10 <rightfold> CInt
04:53:22 <merijn> Ah, then my advise is useless. I recall there being a "get whatever this type is" thing in hsc, but forgot how
04:53:30 <merijn> rightfold: Terrible idea, not portable
04:53:35 <shlevy> rightfold: There's no guarantee it's going to be int
04:53:40 <merijn> rightfold: Also, no guarantee that CInt is int32_t
04:54:51 <merijn> On x64 linux CInt is likely to be 64bit, whereas on 64bit OSX CInt is 32bit, which leads to fun portability issues with people coding carelessly
04:54:57 <hpc> stobix: not that i know of, but the steps you follow are individually pretty simple
04:55:02 <jarlg> Anyone know an elegant and efficient way of extracting the language of a parser?
04:55:04 <hpc> stobix: so let's start with the type of (.)
04:55:05 <hpc> :t map
04:55:06 <lambdabot> (a -> b) -> [a] -> [b]
04:55:08 <hpc> er
04:55:09 <hpc> :t (.)
04:55:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:55:29 <hpc> stobix: we have (. map), which is also \x -> x . map
04:55:48 <hpc> stobix: so we unify the type of map with the second parameter of (.) which is (a -> b)
04:56:12 <hpc> stobix: and get (with some non-standard notation to disambiguate)
04:56:24 <hpc> (.).a = (map.a -> map.b)
04:56:38 <hpc> (.).b = ([map.a] -> [map.b])
04:57:01 <hpc> now substitute in those more specific versions of a and b into (.)'s type signature
04:57:12 * stobix tries to readjust his thinking 
04:57:35 <shlevy> "Actually hsc2hs does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run." Is that true? Doesn't that break in cross-compilation?
04:57:48 <kuribas> Why doesn't binary have an runGet equivalent to runPut?  Like runGet :: Get a -> Bytestring -> Either String a
04:58:00 <merijn> shlevy: THat's true, and yes cross-compilation is a mess
04:58:26 <Myrl-saki> I showed some people Haskell and NixOS.
04:58:35 <srhb> kuribas: It doesn;t?
04:58:40 <merijn> kuribas: You mean 'runGetOrFail' ?
04:59:15 <kuribas> merijn: it does?  I must have missed it, sorry.
04:59:20 <merijn> And/or runGetIncremental
04:59:27 <shlevy> merijn: Does it even work at all? It would have to somehow include the relevant headers as if it were compiling for the target but have main compile for host right?
04:59:30 <merijn> runGetOrFail :: Get a -> ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)
04:59:46 <merijn> shlevy: You have to have a C cross-compiler, yes
04:59:49 <kuribas> merijn: right, thanks!
05:00:07 <stobix> hpc: maybe it's the unification step that I don't get. It feels like I need to learn the right way to see stuff like this so it becomes evident to me as well.
05:00:30 <shlevy> merijn: But that's not enough if you need to run the program to get the haskell code out, right? Maybe I'm misunderstanding what the C program hsc2hs outputs is specifically doing
05:00:40 <hpc> stobix: the secret to it is that unification is the process of solving systems of equations
05:00:46 <shlevy> ah
05:00:52 <hpc> stobix: it's just like if you ever learned in school how to deal with things like
05:00:55 <hpc> x = 3y + 2
05:00:58 <hpc> y = x - 8
05:01:02 <shlevy> "--cross-safe" "Restrict the .hsc directives to those supported by the --cross-compile mode"
05:01:13 <hpc> and then find where x = y
05:01:35 <shlevy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html#hsc2hs-cross <- rtfm, I guess
05:01:39 <kuribas> stobix: looking into logic programming language can help (but is not necessary though).
05:01:42 <hpc> or something like that, i think i gave it one too many equations
05:02:15 <stobix> hpc: Hmkay. Still not sure how (a->b) could be unified with (a->b)->[a]->[b] or how to see it as a set of equations.
05:02:29 <stobix> kuribas: nice tip. I'll look into it. 
05:03:07 <kuribas> stobix: or if you know scheme you could look at kanren: http://minikanren.org/
05:03:14 <hpc> stobix: thanks to currying, (a -> b) -> [a] -> [b] is the same as (a -> b) -> ([a] -> [b])
05:03:57 <stobix> hpc: ah!
05:04:26 <stobix> Yeah, so then (a->b) becomes ((a->b) -> ([a] -> [b])?
05:04:44 <hpc> yep
05:05:21 <stobix> Nice, that explains a lot; I was wondering where all those extra arguments went.
05:05:49 <hpc> now you also have some knowledge about a and b too
05:05:52 <stobix> Didn't think of the possibility of a and b being functions.
05:06:08 <hpc> which you can use in other places they appear
05:06:34 <hpc> stobix: welcome to functional programming :D
05:06:49 <stobix> hpc: Heh, yeah, I guess. :)
05:07:05 <kuribas> stobix: think of a type variable as an element of a set.  A plain type variable means the set of all possible types.  A typeclass means the set of all instances of that typeclass.
05:07:26 <kuribas> stobix: Unification means making the set smaller and smaller.
05:07:56 <shlevy> #type ⟨C_type⟩ is what I wanted
05:08:26 <hpc> kuribas: the system of equations method is closer to how ghc's algorithm works though ;)
05:08:41 <stobix> kuribas: that's a nice way to think of it
05:08:51 <kuribas> stobix: for example "id 2": id :: a -> a, and 2 :: Int, so the set of types to which a belongs is reduced to {Int} a singleton set.
05:09:14 <hpc> stobix: a fun tangental bit of history, type theory came out of set theory as a way to resolve some of its paradoxes
05:09:21 <stobix> I guess I'd better stop thinking of the type variables as, well, "variables". ;)
05:09:25 <kuribas> hpc: a system of equation does the same thing basicly.
05:09:32 <hpc> so they're extremely similar in a number of ways
05:09:50 <kuribas> stobix: yeah, they are more like variables in a logic language than in a functional language.
05:10:12 <hpc> maybe split the difference between "variables" and "unknowns"
05:10:56 <kuribas> And variables in haskell aren't even variable, they don't vary at all!
05:11:13 <stobix> I think I need to expand my thinking from "this is an a. it can contain something" to "this is an a. It can be almost anything until restricted."
05:11:25 <grantwu> Don't we not call them variables
05:11:27 <stobix> kuribas: haha, true that.
05:11:33 <grantwu> And instead call them bindings
05:12:29 <hpc> lambda calculus calls them variables too iirc
05:12:49 <hpc> or at least the bit of the theory distinguishing bound and free variables does
05:13:41 <grantwu>  Isn't that for type variables
05:14:11 <lpaste> slack1256 pasted “different existentials” at http://lpaste.net/330303
05:14:16 <hpc> grantwu: oh just you wait until you discover they're the same thing ;)
05:14:33 <slack1256> how should I read this existential types? http://lpaste.net/330303
05:14:36 <hpc> (types and values)
05:15:49 <stobix> We could start calling all variables "constants" instead, just to confuse the heck out of people.
05:16:13 <hpc> if we were extra evil we would call every definition a variable
05:16:23 <hpc> map would be a variable, (+) would be a variable, False would be a variable
05:16:29 <hpc> everything would be global variables
05:17:02 <stobix> That's kinda akin to calling every type of executable an "app". Good thing nobody does that.
05:17:24 <hpc> yes, thank goodness that's not a thing >.>
05:17:26 <hpc> :D
05:18:14 <lyxia> slack1256: the second one would be equivalent to SList { run :: exists r. ... }
05:18:59 <lyxia> but exists is not a haskell keyword.
05:19:27 <hpc> there's some reasons for why it can't be, but i would have to go looking for them
05:19:36 <hpc> higher-ranked types were never my strong suit
05:20:04 <hpc> something to the extent of not being able to write certain very simple existential types
05:20:12 <hpc> *write values of
05:20:53 <stobix> Could "if then else" be seen as variables, or would "keyword" still sometimes be a thing?
05:21:19 <hodapp> I believe Bob Harper has an ivory-tower explanation about how "variable" for things that don't vary is actually the correct term...
05:21:20 <stobix> Maybe rather s/keyword/special construct/
05:23:51 <slack1256> 'exists a. a' is equivalent to 'forall r. (a -> r) -> r'. So in this case, the (a -> r) is being played by the constructor...
05:24:05 <stobix> (In newLisp things get even more blurry, where funtions are actually stored as a lisp list of instructions. So I can go into the list and change how the function is executed. While it is executed. From the function itself. Eh, not really about variables, but functions ≡ data.)
05:25:04 <slack1256> I still don't know "how to use" each case :-D
05:30:35 <lyxia> slack1256: you can't use the second one. You have a function with some argument type, but there is no way to know what that type is.
05:31:41 <lyxia> slack1256: and the first one is a wrapper around a polymorphic function... so you can use it like a polymorphic function.
05:32:14 <bollu> where do I learn to use recursion schemes/
05:32:24 <bollu> is there a book or something? like a cookbook of recursion schemes?
05:32:29 <bollu> minimally, I want cata, ana, hylo
05:33:25 * hackagebot modify-fasta 0.8.2.2 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.2.2 (GregorySchwartz)
05:33:38 <amx> bollu: I found this in my bookmarks: https://www.youtube.com/watch?v=Zw9KeP3OzpU
05:33:52 <bollu> amx: thanks!
05:42:24 <merijn> tbh, I've tried understanding recursion schemes at least 5 times, I still get lost
05:43:26 * hackagebot blosum 0.1.1.3 - BLOSUM generator  https://hackage.haskell.org/package/blosum-0.1.1.3 (GregorySchwartz)
05:43:37 <merijn> hodapp, stobix: The tl;dr summary of "why are variables called variables if they don't change?" comes from the math origin of the term variable.
05:44:29 <merijn> hodapp, stobix: In "f(x) = x^2 + x -1" 'x' is a variable, because in different contexts/uses of 'f' it takes a different value. i.e. it varies across uses. As opposed to '1', '2', etc. in that expression which are constant across uses
05:45:07 <merijn> hodapp, stobix: So variables don't 'vary' within an expression. They vary across multiple occurences of the same expression
05:47:42 <merijn> stobix: As for if/then/else being keywords/special constructs. I would qualify if/then/else as syntactic sugar/special case of case-of :)
05:47:59 <sphinxo>  /join #datadog
05:48:23 <hodapp> #datadog?
05:48:35 <sphinxo> well that's embarrassing
05:48:42 <merijn> stobix: And in most common implementations of functional language case-of is indeed a builtin primitive.
05:49:00 <stobix> merijn: fair enough. :)
05:49:03 <sphinxo> note to self, check for spaces before typing irc commands
05:49:26 <stobix>  /me thinks sphinxo is on to something. ;)
05:50:29 <merijn> stobix: Incidentally, it seems like you're curious about the implementation side of this stuff, so let me recommend the STG paper as an excellent and readable introduction to compiling something haskell-like to machine code :)
05:50:33 <stobix> sphinxo: Seen this one? http://bash.org/?362137
05:50:51 <ertes> merijn: did you try understanding recursion schemes based on bird's paper or the recursion-schemes library?  because the latter is actually pretty simple
05:51:03 <ertes> if you understand free monads, you also understand recursion-schemes
05:51:08 <merijn> ertes: The banana, barbed wire, etc. paper
05:51:19 <ertes> yeah, try the recursion-schemes library
05:51:21 <merijn> ertes: Also, I'm still not convinced I understand Free ;)
05:51:35 <ertes> ok, then try the recursion-schemes library =)
05:51:50 <stobix> merijn: Well, it's more that my intuition seems to be off, and I strive to correct it to better and faster understand code. Stil, reading a paper to level up is Haskelling seems to be the way to go... ;)
05:51:52 <merijn> ertes: Can't right now, have to write broken python >.>
05:52:07 <ertes> my condolences
05:52:11 <merijn> stobix: https://pdfs.semanticscholar.org/5c70/ed80977204a5b84f1f02764d6c3b5d9b8185.pdf
05:53:20 <merijn> stobix: Prereqs: Very basic haskell (basically case-of and functions) + basic C (and/or a bit of ASM), overall very readable. It's a bit outdated and not necessarily the only way to compile things, but it gives a decent enough intuition
05:53:26 * hackagebot simple-effects 0.4.0.1 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.4.0.1 (darwin226)
05:53:28 * hackagebot simple-effects 0.5.0.0 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.5.0.0 (darwin226)
05:53:37 <ertes> stobix: i think modern haskell self-education gravitates more toward reading good blog posts
05:53:56 <merijn> ertes: There's good old papers too, but those tend to be more general than just Haskell
05:54:15 <stobix> merijn: heh, seems nice (and long) enough. The thing that finally got me to grok monads was a paper on categories vs functons vs monoids etc.
05:54:44 <merijn> stobix: imo people overestimate the difficulty of papers (there are some really difficult ones, but also lots of very readable ones) and this one is especially readable
05:54:46 <ertes> sure…  i don't mind reading papers, and most of them i honestly just skim to get the most important parts
05:56:23 <ertes> BTW, my new article may be a good opportunity to announce that i have a homepage again: http://ertes.eu/tutorial/config-monoids.html
05:56:51 <ertes> it's a little technique that i've been using for a while now that doesn't seem to be well known, if at all
05:57:46 <kuribas> merijn: I learned monads from SPJ paper, and I could read it without any degree...
05:58:11 <merijn> Also, for the difficult papers, the degree doesn't help :p
05:58:26 * hackagebot rebase 1.0.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.3 (NikitaVolkov)
05:59:01 <stobix> What I want to be able to do when I'v understood enough, is to see that of course what is missing from my ((.map).) is to do (.map).(.) to then get my (.map).(.).foldl1 which obviously does the same as \f g h -> foldl1 f (map g h)
06:00:11 <merijn> stobix: tbh, that's not obvious to me either :p
06:00:51 <merijn> Composing with (.) is messy and I'd usually work it out by hand...
06:02:22 <merijn> stobix: Especially without intermediate type annotations
06:02:23 <stobix> I just used a four color pencil to work out the type of ⟪((.map).)⟫ . ⟪(.map).(.)⟫ I had neither colors nor understanding enough to get.
06:02:59 <stobix> Heh. ⟪⟫ to encapsulate code didn't turn out as clear as I hoped. Oh, well.
06:03:19 <merijn> stobix: anyway, I think trying to understand code like that is overrated :)
06:04:14 <stobix> merijn: well, maybe. But I think it would help immensely when trying to get what e.g an ⟪fmap fmap⟫ does in a particular context.
06:04:25 <stobix> s/e\.g/&./
06:04:51 <merijn> That one is much easier, tbh :)
06:05:02 <merijn> :t fmap fmap
06:05:03 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
06:05:57 <cocreature> I still don’t think fmap fmap is particularly useful
06:06:09 <stobix> Heh, yeah, I guess. Don't even need my four color pencil for that one.
06:06:15 <merijn> cocreature: I've used it a few times :)
06:06:54 <cocreature> I would probably just first pull the function out using do notation and then apply fmap
06:06:59 <cocreature> that’s a lot easier to read for me
06:07:06 <merijn> cocreature: Only works if you have a monad :)
06:07:11 <cocreature> fair enough
06:07:46 <cocreature> merijn: btw I think ApplicativeDo also works if you only have a Functor and it can desugar to that
06:07:53 <cocreature> so that’s no longer true if you allow extensions :)
06:08:11 <merijn> cocreature: If you allow extensions AND assume only the latest GHC :p
06:08:17 <elfeck> is list-comprehension checking null [x | x <- xs, f x] worse than implementing it recursive performance wise?
06:08:17 <merijn> I'm still using 7.10, tyvm
06:08:37 <stobix> Heh. Maybe I should try to grok whatever cocreature just said instead. ;)
06:08:42 <merijn> elfeck: Presumably not significantly so
06:09:13 <ski> @undo null [x | x <- xs, f x]
06:09:14 <lambdabot> null (concatMap (\ x -> if f x then [x] else []) xs)
06:09:50 <stobix> @help undo
06:09:50 <lambdabot> undo <expr>
06:09:50 <lambdabot> Translate do notation to Monad operators.
06:09:53 <stobix> lol
06:09:56 <ertes> elfeck: that's just null xs
06:10:19 <merijn> ertes: Is not
06:10:27 <ertes> oh
06:10:28 <merijn> ertes: More like 'any'
06:10:29 <cocreature> stobix: I was talking about http://lpaste.net/330455
06:10:30 <merijn> :t any
06:10:31 <ertes> sorry, i misread
06:10:33 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:10:45 <merijn> elfeck: Incidentally, probably should use any :)
06:10:46 <ertes> yeah, any
06:11:04 <merijn> > any even [1,2,3,4,5]
06:11:07 <lambdabot>  True
06:11:17 <merijn> > any even [1,3,5]
06:11:20 <lambdabot>  False
06:11:31 <elfeck> hm
06:12:11 <elfeck> I guess I'll have to profile it. The expression I have scales in O(n^3) so I need it to be as fast as possible
06:12:12 <ski> stobix : also list comprehensions, as you saw ..
06:12:28 <ertes> elfeck: that is as fast as possible
06:12:37 <elfeck> ertes: any that is?
06:12:39 <cocreature> stobix: if you don’t know about ApplicativeDo, it basically allows you to use do notation using only Functor or Applicative constraints if it is possible to desugar your code in such a way
06:12:43 <merijn> elfeck: O(n^3)? No other algorithm?
06:12:45 <ertes> elfeck: yeah
06:13:07 <elfeck> merijn: testing associativity
06:13:22 <elfeck> ertes: hm okay
06:13:24 <ertes> elfeck: the list comprehension is desugared into a more complicated expression, which might be reduced by rewriting, but you may be unlucky
06:13:56 <stobix> cocreature: I suspected as much. And I don't understand Applicative yet.
06:14:00 <ertes> elfeck: depending on how you wrote 'xs' the whole thing may be reduced to a tight loop
06:14:11 <merijn> stobix: Are you familiar with phantom types?
06:14:23 <cocreature> tbh it’s pretty weird that ApplicativeDo desugars to Functor if you use pure
06:14:42 <stobix> merijn: nope
06:14:45 * ski . o O ( reflective syntax )
06:14:55 <stobix> cocreature: is that code really clearer to you than fmap fmap?
06:14:56 <ertes> cocreature: weird but useful…  i don't mind if desugaring relies on laws
06:15:00 <merijn> stobix: Does the following type make sense? "data Const k a = Const k"?
06:15:24 <cocreature> stobix: yes, but that’s obviously subjective
06:15:38 <stobix> merijn: seems like a type that has an a that is never used.
06:15:43 <stobix> cocreature: true. :)
06:15:55 <merijn> stobix: Correct, hence 'phantom type', it has no "body" :)
06:16:03 <stobix> oh
06:16:24 <stobix> merijn: My first reaction is "well, is that ever useful?", but I'm sure Haskell has found a way.
06:17:01 <cocreature> more types mean that less things fit together. ideally the things that don’t fit together are programs that you shouldn’t write
06:17:26 <Rembane> stobix: You can save metadata using phantom types. Like for instance, has this thing been through the validator or could it still be nasty from user input.
06:17:29 <merijn> stobix: Well, imagine wanting to encode the unit of a value (weight, etc.) in a type
06:17:41 <stobix> cocreature: love that explanation :)
06:18:10 <merijn> stobix: "data Weight; data Unit t = Unit Int; foo :: Unit Weight; foo = Unit 5"
06:18:21 <stobix> Oh, so basically you encode state in the type of functions?
06:18:33 <merijn> stobix: Right
06:19:03 <stobix> Interesting approach
06:19:14 <merijn> stobix: Anyway, to get back to the initial question. One enlightening exercise is to try and implement Functor, Applicative and Monad for "data Const k a = Const k" and try to proof the laws hold
06:19:15 <sbrg> stobix: I used phantom types recently in a program that emulates a CPU for a simple assembly language. However, before I could run the programs after parsing them, I needed to collect information (like labels and their locations, so that jumps would work). to make sure it was impossible to run programs where the labels had been "resolved", I used phantom types. something like data Resolved; data Unresolved; data Program a = .. where a
06:19:15 <sbrg> was either
06:19:27 <merijn> stobix: Hint: Some implementations require additional constraints to be lawful :)
06:19:55 <merijn> sbrg: Nowadays I prefer DataKinds for that :)
06:20:05 <tdammers> to elaborate on cocreature's remark: the ideal would be that everything that fits together is a program that you might want to write, and any program that you don't want to write would be something that doesn't fit together
06:20:17 <merijn> sbrg: "data State = Resolved | Unresolved; data Program (a :: State) = ..." :)
06:20:27 <tdammers> i.e., the type system would allow all desirable programs, and disallow all undesirable programs
06:20:43 <stobix> merijn: that approach seems so much more sensible to me. But maybe that's just me. :)
06:20:46 <sbrg> merijn: hm. How do you write a function that only takes programs that have been resolved, then? 
06:21:06 <merijn> stobix: Yes, but it relies on an extension to haskell's type system that's only in GHC :)
06:21:18 <tdammers> the crux is that this ideal cannot be reached, only approached
06:21:26 <stobix> sbrg: is it that you want the compiler to fail if you have some line that tries to feed an incomplete program forward?
06:21:29 <merijn> sbrg: You can still explicitly write "foo :: Program Unresolved -> Program Resolved" that way
06:21:38 <merijn> sbrg: The difference is that "Program Int" is now a kind error
06:21:44 <stobix> merijn: oh no, and I who use happy all the time. ;)
06:21:48 <sbrg> merijn: oh? aaaah, very nice. that is much better indeed.
06:21:52 <tdammers> at some point you have to decide that you want to either allow some nonsensical programs, or to disallow some sensical ones, or both
06:21:57 <merijn> sbrg: Because "Int :: *" and "Unresolved :: State"
06:22:05 <tdammers> most programming languages do both
06:22:16 <sbrg> stobix: the idea is that if I, the programmer, make an error, I cannot pass a program where symbols haven't been resolved yet to the "runProgram" function
06:22:23 <sbrg> merijn: wow, how did I not know about this
06:22:36 <sbrg> merijn: thanks!
06:22:55 <merijn> sbrg: Basically DataKinds lifts all datatypes to the type level so that value constructors == type constructor and type constructor == kind
06:23:05 <ab9rf> i think it's rust that uses type like that to ensure memory safety
06:23:14 <merijn> sbrg: See GHC manual for details :)
06:23:20 <sbrg> yeah, I could see that by your example. that's exactly what I wanted when I wrote it that way
06:23:24 <sbrg> I'm reading it now
06:23:37 <merijn> sbrg: Yes, I know, because I've been using DataKinds to do the exact same thing :p
06:51:02 <grazie> in Real World Haskell, number 2 (see attached) is presented as the monadic version of #1 for a divby function. Is it SOLELY the use of mapM that makes #2 monadic? https://gist.github.com/a86f334c2d29f687ef43bf0389f04cf6
06:54:27 <merijn> grazie: tbh, I think that's a pretty poor description of what's going on. I would only call code monadic if it works for *all* monads. This is just a special case of using a general (monadic) function to work with Maybe
06:55:01 <merijn> grazie: So I wouldn't focus on that naming too much
06:55:53 <grazie> merijn: ok, thank you, but just for the sake of understanding the author's intention (however correct it is), is it merely the use of mapM that would make #2 monadic
06:56:01 <merijn> grazie: I would guess so
06:57:29 <grazie> merijn: thank you
06:58:25 <merijn> It's clearly the more general version of the two in terms of implementation :)
06:58:28 * hackagebot takusen-oracle 0.9.4.1 - Database library with left-fold interface for Oracle.  https://hackage.haskell.org/package/takusen-oracle-0.9.4.1 (PavelRyzhov)
06:59:04 <stobix> Hm. I've been playing around with phantom types, DataKinds etc. If I have a data OneOrTwo = One | Two; data Foo (a::OneOrTwo), is there a way to do something like instance Show (Foo One) where ... ?
06:59:28 <merijn> stobix: Eh, yes, literally that :p
06:59:42 <stobix> merijn: Oh? I get tons of errors.
06:59:53 * stobix redoes it so he can specify "tons of errors" better.
07:00:19 <grazie> merijn so do you think by monadic the author meant or should have rather said "the more general implementation"
07:00:54 <merijn> grazie: The author is clearly trying to show how the monad interface provides access to general functions, such as mapM
07:01:26 <stobix> I get an "Illegal instance declaration for 'Show (Foo 'One)'"
07:01:35 <merijn> grazie: And how it takes care of all the plumbing for you
07:01:45 <merijn> stobix: And probably something about FlexibleInstances? :)
07:01:58 <grazie> I found this free book on Haskell to be quite good https://upload.wikimedia.org/wikipedia/commons/2/26/Haskell.pdf but it doesn't get recommended much (from what I've seen)
07:02:12 <stobix> ooh. Heh. Apparently, I missed the fifth line of the error message every time I read it.
07:02:16 <grazie> anyone know why?
07:02:43 <merijn> stobix: The Haskell report is, in common opinion, overly conservative in what it allows for instance declarations
07:03:13 <merijn> stobix: It only allows type of the form "Foo ..." where Foo is a type constructor and ... is zero or more type variables.
07:03:45 <merijn> stobix: There's not really any good reason for this (and I would expect the new Haskell Prime committee to get rid of this). In fact, it's such a bogus restriction I usually forget it exists :)
07:03:55 <stobix> My file now has 21 lines, and four language extensions so far. :)
07:04:53 <merijn> stobix: If you like to explore examples of different extensions, I wrote up some gists with examples using some of them in neat ways
07:05:22 <merijn> stobix: https://gist.github.com/merijn/6130082 https://gist.github.com/merijn/dc00bc7cebd6df012c5e and https://gist.github.com/merijn/39dc86e345e87276c523
07:05:24 <ski> .. *distinct* type variables
07:06:13 <merijn> ski: Even worse!
07:06:41 <merijn> I reall hope FlexibleInstances and FlexibleContexts get (at least partially) standardises by Haskell Prime
07:09:29 <stobix> merijn: hehe, nice
07:12:12 <ski> merijn ?
07:12:48 <merijn> ski: Is there any reason to keep them as extension in the next report?
07:13:08 <ski> not that i know ?
07:13:22 <ski> (just wondering what was even worse)
07:13:23 <stobix> maybe to prevent user error or something?
07:13:47 <stobix> (which isn't a good reason in this case, but still)
07:16:05 <grazie> this exception handling code from Real World Haskell produces an error in my ghci. #1 in link is how it's supposed to work from book #2 is my ghci https://gist.github.com/61dcf1bebb7617bd1cfac4152d141507
07:16:24 <grazie> can anyone explain why?
07:17:28 <tdammers> because exception handling has been overhauled rather massively since RWH was written, I presume
07:18:06 <grazie> tdammers: thanks, just found a comment to that effect
07:20:02 <aphorisme> Has anyone build a parsec-based parser with implicit recursion? I somewhat cannot figure out how to manage precedence since `chainl1` cannot be used in this setting.
07:20:08 <tdammers> grazie: in a nutshell, I'd start reading here: http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html
07:20:42 <tdammers> grazie: with the caveat that exceptions are often not what you want
07:20:51 <grazie> tdammers thank you
07:21:15 <tdammers> you may also want to look into http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
07:21:42 <tdammers> which is not actual exceptions (as in, throw from anywhere and bypass the normal evaluation order / control flow)
07:21:51 <tdammers> but a somewhat saner but also more limited thing
07:22:11 <tdammers> they just use plain old monad semantics to implement exceptions as short-circuiting errors
07:22:24 <merijn> ski: That it's not just type variables but even only distinct ones :)
07:22:49 <quchen> Is there a smart way to check which of two fractions (of integers) is bigger without converting to float or cross-multiplying?
07:23:21 <ski> (merijn : oh, you were just confirming, rather than claiming it was even worse than what i said, i see)
07:23:35 <merijn> quchen: convert to ratio and compare?
07:23:49 <quchen> merijn: Well, that just does the cross-multiplication.
07:23:52 <tdammers> merijn: isn't that cheating?
07:23:56 <mlehmk> I thought exceptions were basically Either
07:24:00 <merijn> quchen: Which probably boils down to cross-multiplying but at least the logic has been written for you :p
07:24:09 <tdammers> mlehmk: the ones in Control.Monad.Except are, yes
07:24:15 <merijn> mlehmk: No, Haskell has regular (unchecked) runtime exceptions
07:24:23 <merijn> mlehmk: Also, Either isn't always exceptions
07:24:24 <mlehmk> that's how I imagined exceptions in Java, C# and C++ as well
07:24:27 <quchen> I think I’m capable of implementing it, yes, but I’d like to avoid it ;-)
07:24:30 <tdammers> mlehmk: the ones in Control.Exceptions are not, they're magic built into the compiler :P
07:24:42 <merijn> quchen: Right, so then by going through ratio you avoid implementing it :p
07:24:57 <tdammers> mlehmk: the nasty thing about Exceptions is that they bypass the type system
07:25:00 <quchen> merijn: THANKS
07:25:14 <merijn> quchen: Because I don't see how you could compare without either cross-multiplying or going to float 
07:25:22 <tdammers> you can throw anything from anywhere, and in order to catch, all you need is IO
07:25:32 <mlehmk> tdammers, type system in how types are understood in Haskell?
07:25:34 <quchen> merijn: Hence you mean to say "dunno" :-þ
07:25:40 <tdammers> mlehmk: yes, obviously
07:26:13 <merijn> quchen: Well, the workaround is using Ratio to outsource the implementation of cross-multiplying. Since actually having fractions implies not wanting to deal with floating point and rounding :p
07:26:19 <tdammers> mlehmk: with Either / Except, you have to be explicit about the fact that a bit of code may throw; with Exception, you can just throw nilly-willy
07:26:38 <tdammers> which is arguably acceptable for things that are actually exceptional
07:26:47 <mlehmk> in Haskell?
07:26:51 <tdammers> yep
07:27:20 <tdammers> I would counter-argue that if it's exceptional enough to throw like that, it's probably also exceptional enough for the only valid response to be a hard crash
07:27:28 <merijn> Note that using throw instead of throwIO is super-terribad and you will regret it
07:35:49 <nevere> Why can I access the Lens accessors in all files execpt one. In that file, it says the variable is out of scope, even after importing the file that calls makeFields TH call...
07:40:41 <grazie> I'm using version 8.0.1 of GHC, when trying to import System.Cmd into ghci, I'm told it's deprecated and I should use System.Proceo ss. If I want to look at source, inn  Base.-4.9.0, there is no System.Process  http://imgur.com/a/ju6UL what version of Base should I look at? 
07:45:06 <grazie> or is System.Process not part of the Base install and I must have installed it some other way to have it in ghci?
07:45:33 <grazie> ok, found my answer https://hackage.haskell.org/package/process-1.4.2.0
07:47:07 <kuribas> > minBound :: Int
07:47:10 <lambdabot>  -9223372036854775808
07:47:21 <kuribas> Is there a garantee for the size of Int?
07:47:28 <mlehmk> no
07:47:30 <nevere> Why is my lens accessors available in all modules except one?
07:47:37 <ania123> if I define
07:47:38 <ania123> data Answer = Yes | No | Unknown
07:47:56 <kuribas> or a minimum size?
07:48:06 <kuribas> I assume Int shouldn't be 8 bits...
07:48:11 <ania123> and write: answers :: [Answer]
07:48:28 <ania123> it means, answers has type [Answer]
07:48:31 <ania123> is not?
07:48:33 <mlehmk> There are no guarantees about the bounds of Int
07:49:20 <kuribas> Ah, base says: "A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]."
07:49:39 <mlehmk> ohh
07:50:01 <kuribas> ania123: yes
07:50:14 <merijn> If you want fixed size Int you can import Data.Int for Int8, Int16, Int32 and Int64
07:50:27 <ania123> if I write answers = [Yes,No,Unknown]
07:50:34 <ania123> does it means same?
07:51:02 <merijn> ania123: Does it mean the same? No. Does it result in the same type for 'answers'? Yes.
07:51:32 <merijn> ania123: The first simply states 'answers has type [Answer]' whereas the second states 'answers is the following specific list'
07:52:20 <ania123> merijn: behavour of answers is same? in both cases?
07:52:32 <kuribas> merijn: I am currently using Int as "big enough Int", but maybe that's not very portable...
07:52:45 <merijn> kuribas: Integer is a "big enough Int" :)
07:52:59 <kuribas> merijn: right :)
07:53:01 <merijn> kuribas: Integer is surprisingly well-performing
07:53:05 <kuribas> xb
07:53:16 <merijn> kuribas: Or rather, GHC's bindings to GMP are surprisingly well-performing
07:53:19 <kuribas> Isn't there overhead?
07:53:52 <kuribas> I might use Int64 instead
07:53:52 <merijn> kuribas: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
07:54:04 <merijn> kuribas: Overhead? Sure. Enough to care about? It depends
07:54:09 <lgstate> is haskell ghcjs still "download this binary blob from either aws or luite.com "
07:54:10 <lgstate> ?
07:54:16 <lgstate> is the ghcjs from github still broken?
07:54:43 <kuribas> merijn: that's very curious
07:56:02 <merijn> kuribas: What is? :)
07:56:13 <kuribas> merijn: I would expect other GMP implementations to have similar results.
07:56:49 <merijn> kuribas: Not if their runtime introduces too much overhead or is very inefficient in how they call GMP
07:58:26 --- mode: shapr set -o shapr
07:58:57 <shapr> Any exciting code today?
07:59:10 <merijn> kuribas: Just trying to stop the myth that you need Int64 for performance. Realistically, unless you have experience writing HPC code and know what you're doing your default should probably be Integer
07:59:26 <ab9rf> iow, do not prematurely optimize
07:59:34 <kuribas> merijn: you mean Integer will be faster than Int64?
07:59:48 <stobix>  /foreach window /window level MSGS PUBLICS NOTICES CTCPS ACTIONS JOINS PARTS QUITS KICKS MODES TOPICS NICKS CLIENTCRAP
07:59:55 <stobix> oh, hello space
07:59:57 <ab9rf> ha
08:00:01 <merijn> kuribas: No, but it won't be much slower, because Integer uses Int64 for small values :p
08:00:11 * stobix fails at copypaste
08:00:12 <merijn> kuribas: It only switches to using GMP if the values no longer fit into Int64
08:00:39 <kuribas> merijn: In most tests I did, changing Integer with Int made a big difference.
08:01:22 <merijn> kuribas: Define big? What kinda code are you writing? Is it all numerical? Is Integer in your inner-loop?
08:01:30 <merijn> Do you know what your inner-loop is?
08:02:08 <xcmw_> How can I type m? http://lpaste.net/330878
08:02:10 <merijn> kuribas: If Only 10% of your runtime is numerical operations, then even if you *double* the performance of your numerical operations your reducing your total runtime by only 5%
08:02:14 <kuribas> merijn: like summing a vector
08:02:39 <nevere> Why is my lens accessors available in all modules except one?
08:02:56 <kuribas> merijn: In my numerical library I have specialized all functions to Double, for performance.
08:03:00 <merijn> nevere: Is the module where it's not available the one where you use TH to generate it?
08:03:17 <nevere> merijn: No. 
08:03:39 <merijn> kuribas: Right, but this brings us back to "whether Integer is too slow depends on what you're doing"
08:04:05 <kuribas> merijn: I would only use Integer if I needed very large, or unbounded integers.
08:04:43 <merijn> kuribas: You should be using Integer by default, unless you know you're writing a tight inner-loop with some guarantees about the size of your int :)
08:07:48 <kuribas> merijn: sure
08:11:40 <pchiusano> basic haskell question - I notice that if main bombs with an error, that gets reported, but what happens to errors raised in threads spawed via forkIO? are they logged in any way (by default)?
08:14:50 <joe9_> pchiusano:  use async instead of forkIO
08:15:05 <joe9_> pchiusano: for errors/exceptions, check out safe-exceptions
08:15:28 <pchiusano> joe9_: yeah, I have used that, but just wanted to make sure my understanding is correct - uncaught errors in a thread aren't logged by default
08:15:33 <pchiusano> is that right?
08:15:36 <srhb> pchiusano: "logged"?
08:15:45 <pchiusano> like, printed to the console, say
08:15:51 <srhb> pchiusano: Yes, they are.
08:16:04 <joe9_> pchiusano: uncaught errors are propogated.
08:16:05 <c_wraith> pchiusano: there's actually a global handler, iirc.  You can set it to something else, if you want
08:16:30 <joe9_> pchiusano: when main ends with an uncaught exception, it will be be written to the terminal, I think.
08:16:52 <srhb> joe9_: main does not end with an uncaught exception if a forkIO errors out.
08:17:01 <pchiusano> do a <- forkIO $ do fail "die"; b
08:17:14 <pchiusano> will "die" be logged to the console
08:17:18 <pchiusano> no, right
08:17:54 <srhb> pchiusano: Yes.
08:17:55 <merijn> pchiusano: There is a default handler for other threads
08:18:03 <merijn> pchiusano: You can overwrite it if you want
08:18:29 <pchiusano> merijn: so main has a default uncaught error handler, which is different from other threads
08:18:34 <merijn> pchiusano: Right
08:18:56 <pchiusano> merijn: there is a way to set the default handler for all spawned threads globally?
08:19:18 <pchiusano> how?
08:19:22 <merijn> pchiusano: See GHC.Conc
08:19:25 <merijn> pchiusano: setUncaughtExceptionHandler
08:19:57 <grazie> is there a way to run this test suite after cloning (and not installing) the repo https://github.com/haskell/primitive/blob/master/test/main.hs
08:20:57 <pchiusano> merijn: cool, thanks
08:22:00 <merijn> pchiusano: I can recommend browsing through GHC.Conc and other GHC.* libraries in base, lots of cool stuff
08:23:18 <srhb> Cool demonstration use of a top level unsafePerformIO too
08:24:47 <dolio> grazie: `cabal test`
08:24:50 <grazie> for example, loading the test file into ghci and calling main didn't give any output https://gist.github.com/e13f6ce261e21036a93f1a7d6a5970c2
08:24:51 <dolio> Hopefully.
08:25:13 <grazie> dolio: so you have to install with cabal? can't just clone a repo?
08:25:30 <dolio> `cabal test` doesn't install the package.
08:25:52 <grazie> dolio: ok, thank you, got it working
08:26:01 <sm> generally you'd probably need to at least install dependencies though
08:26:35 <ertes> grazie: for packages with larger dependency trees you may want to create a sandbox first
08:26:41 <ertes> cabal sandbox init
08:26:57 <ertes> then everything happens in the project directory (even installation)
08:27:21 <grazie> ertes: so clone the repo, then do cabal sandbox init?
08:27:36 <grazie> ertes: then run cabal test?
08:28:22 <dolio> If you use a sandbox, you probably have to install dependencies in the sandbox as well.
08:29:49 <sm> [cabal sandbox init &&] cabal install --only-dep && cabal test
08:30:11 <sm> or maybe.. [cabal sandbox init &&] cabal install --enable-test --only-dep && cabal test
08:30:19 <nevere> Why is my lens accessors available in all modules except one?
08:31:02 <sm> stack test
08:31:18 <sm> also works if you have a stack.yaml
08:31:27 <ertes> grazie: i'd generally do that, yeah
08:32:15 <ertes> grazie: note: "for packages with larger dependency trees"
08:32:20 <ertes> 'primitive' isn't one of those
08:32:50 <glguy> nevere: You're unlikely to get someone to guess the issue; you should should the problem code
08:35:07 <jarlg> Anyone know of an elegant and efficient way of extracting the language of a parser? Or modifying (e.g. Parsec's) parsers to keep track of their language?
08:37:24 <glguy> It’s not generally possible to do that for parsec.
08:38:11 <jarlg> glguy: Didn't think so, and I expect not for any other parser-combinator libraries?
08:38:44 <sbrg> there was a post recently that delved into representing BNF grammars and converting them to parsers(IIRC). that may take you some of the way?
08:38:47 <sbrg> let me see if I can find it
08:38:56 <glguy> If you’re interested in that kind of output you should take a look at parser generators like happy. It's possibly that you could do it with the Earley package, too
08:38:58 <merijn> jarlg: I remember seeing a paper on doing that
08:41:02 <sbrg> hmm, can't seem to find it
08:41:27 <glguy> jarlg: It's not an issue of parser combinators, but of the Monad interface
08:41:38 <sbrg> jarlg: http://www.joachim-breitner.de/blog/710-Showcasing_Applicative there
08:41:49 <sbrg> I read it on the go and it was 2 weeks ago so I may have remembered incorrectly
08:41:52 <glguy> jarlg: Libraries like optparse-applicative are able to recover descriptions of the parsable flag sets
08:42:31 <ertes> jarlg: arrow-based parsers can do it, too, if Applicative is too restrictive
08:42:40 <ertes> but i'm not aware of any good ones
08:44:34 <amx> If I want to use the clock package in my application, do I need to do anything more than add clock to build-depends? Because I get linker errors on install/run: ld: library not found for -lHSclock-0.7.2-B4mVOPupVFiEpg2GTovUbG_p
08:44:40 <jarlg> sbrg: Thanks, I'm having a look.
08:45:27 <amx> (on OS X that is)
08:46:48 <glguy> amx: If you want to use the profiling version of the package you'll have to install the profiling version of the package
08:50:11 <amx> right, that appears to be the problem, thx
08:52:54 <cinnamonbuns> Hello Haskell people, I have a question for people using vim and hdevtools: randomly this causes vim to hang, does anyone know of a fix for that?
08:53:59 <younder> (use emacs...)
08:54:34 <Rotaerk> lol
08:55:02 <glguy> Less lol, more unproductive
08:57:07 <cinnamonbuns> I don’t have a response to that
08:58:33 * hackagebot time-warp 0.1.1 - Disctributed systems execution emulation  https://hackage.haskell.org/package/time-warp-0.1.1 (jagajaga)
08:59:05 <glguy> cinnamonbuns: You'll probably have to hang around a while to see if there's someone who both uses hdevtools and has anything to say about it lagging
08:59:20 <jarlg> sbrg, ertes: I don't think Applicative suffices, since I need later parsers to depend on earlier ones. I'm not familiar with arrows; would they address this?
08:59:36 <cinnamonbuns> glguy: thanks for the advice
09:00:31 <ertes> jarlg: arrows allow later parsers to refer to results of earlier ones, but not structurally (because then you have Monad)
09:00:56 <jarlg> ertes: What do you mean "structurally"?
09:01:09 <jarlg> mean by*
09:02:28 <ertes> jarlg: p2 . p1  -- p2 can use the result of p1, but you can't have a function that constructs the following parser arbitrarily
09:02:48 <ertes> p1 >>= f  -- f can choose which parser to use by examining the result of p1
09:03:33 * hackagebot time-warp 0.1.1.1 - Distributed systems execution emulation  https://hackage.haskell.org/package/time-warp-0.1.1.1 (jagajaga)
09:05:05 <jarlg> ertes: Is this right: arrows doesn't permit to e.g. choose to start parsing a number or a string based on previous parser, but I would be able to e.g. concatenate results of composed parsers?
09:05:21 <jarlg> (if concatenation makes sense.)
09:07:22 <np356> hello, I have this code snippet: http://lpaste.net/225546745805799424 is there a way to make the syntax in "function" a little less awkward?
09:07:35 <ertes> jarlg: it's possible, but you would have to write a special parser that does just that
09:07:45 <np356> Is there a way in haskell to access nested objects using dots or something more elegant?
09:07:56 <ertes> jarlg: not being able to do that at all gives you applicative parsers
09:08:08 <mlehmk> instead of a ( b ( c ( d ) ) ) I've seen a $ b $ c $ d
09:08:33 <ertes> np356: "access"?  read?  modify?  …?
09:08:44 <ggVGc> I've started thikning that it's weird having type classes, GADTs, functional dependencies etc... It seems to all be approaching having a type-level haskell, but with different syntaxes
09:08:48 <np356> ertes: read
09:09:03 <ggVGc> why can't we just have a type level haskell with the same syntax, but where values are types instead
09:09:06 <mlehmk> although, making it point-free, it could simply be function = show . port . interface . serviceSettings, I think
09:09:12 <ggVGc> maybe that's kind of what TH is?
09:09:19 <ertes> np356: you can use a flat style by using function composition
09:09:30 <ertes> np356: f (g (h x)) = (f . g . h) x
09:09:46 <ertes> np356: and you can get rid of those final parentheses by using ($):  f . g . h $ x
09:09:59 <ertes> definition: f $ x = f x
09:10:19 <np356> don't you think that its awkward that I have to start with the innermost member and end with the root type?
09:10:36 <ertes> np356: it's only awkward when you're used to OO style =)
09:10:46 <jarlg> ertes: Yes, thank you for explaining.
09:11:03 <ggVGc> I sometimes use (>>>) from Control.Arrow for this reason
09:11:16 <ertes> i recommend getting used to it
09:11:23 <ggVGc> e.g (appenSomething >>> transformFoo) someValue
09:11:37 <ertes> ggVGc: you probably want dependent types, but don't hold your breath…  we're *sloooowly* getting there
09:11:43 <kadoban> You probably have to get used to it, but I too sometimes use (>>>), or a relabel of it because it's kinda long.
09:12:19 <ggVGc> ertes: well, what I mean is that type classes are essentially type level records, right? Why don't we just have type level records in the first place
09:12:41 <ertes> ggVGc: huh?  not sure what you mean
09:12:47 <ggVGc> I mean, why can't we just execute first a type level haskell program
09:12:59 <ggVGc> maybe I'm just being dumb
09:13:00 <ertes> ggVGc: my first approximation to type classes would be implicitly passed values
09:13:15 <ertes> data Monoid a = Monoid { mappend :: a -> a -> a; mempty :: a }
09:13:37 <ertes> mconcat :: Foldable f -> Monoid a -> f a -> a
09:13:44 <ggVGc> ertes: I mean, the same way I can express a relationship between values with a function, I can express a relation between types using type constructors. But why even have two different syntaxes and evaluations for this
09:13:53 <ertes> with the difference that the arguments are chosen by instance resolution instead of function application
09:14:28 <ertes> ggVGc: because haskell is not a dependently typed language…  the type language is different from the value language
09:14:46 <kuribas> ggVGc: you should look at idris
09:15:08 <ertes> ggVGc: languages like agda and idris use the same language for all levels (of which both have infinitely many)
09:16:04 <ania123> data Bool = False | True  
09:16:32 <ania123> can one tell me which one is type here and which one is constructor
09:16:40 <ertes> ggVGc: if you review the release highlights for GHC 8, you will notice a small innocent new extension called TypeInType…  it's another milestone on our way to reach a dependently typed haskell, but it's still a long way to go
09:16:47 <glguy> Bool is a "type constructor", False and True are "data constructors"
09:17:40 <xcmw> How can I type m? http://lpaste.net/330878
09:17:53 <mlehmk> So, what is the actual type then?
09:18:01 <ertes> ggVGc: in standard haskell we actually have *three* languages:  the term language, the type language and the kind language…  TypeInType unifies the latter two, but unifying the term language with the resulting type-and-kind-language is a much more complicated story
09:19:11 <ggVGc> hm, I see
09:19:21 <glguy> xcmw: m :: (forall r a. (CCC (r b) a) => Lens' (A r) a) -> (String, b)
09:19:35 <ggVGc> I guess I didn't think this through very well. I didn't think we needed dependent types to do what I am talking about
09:19:44 <ggVGc> but maybe we are misunderstanding eachother a bit too
09:19:47 <glguy> xcmw: When you wrote this one: m :: (CCC (r b) a) => (forall r. Lens' (A r) a) -> (String, b)
09:19:54 <glguy> You had two different 'r' variables
09:20:03 <ggVGc> is the term language "value level"?
09:20:16 <ggVGc> what's the kind language?
09:20:28 <xcmw> glguy: Thanks
09:20:34 <ggVGc> ah, the type of type level functions
09:20:45 <ertes> ggVGc: yes
09:20:49 <ania123> glguy: http://pastebin.com/0pwC1B2z
09:20:50 <ertes> :k Maybe
09:20:53 <lambdabot> * -> *
09:20:55 <ertes> that's the kind language
09:20:57 <ggVGc> right
09:21:01 <theduke> hey there. how much memory does a data instance with no attacked items use? like Nothing for example?
09:21:10 <ania123> I think it is not written in the book. I am pasting a sentence from the book
09:21:16 <ggVGc> how does TypeInType unify it?
09:21:29 <ggVGc> I can't even find TypeInType through google :/
09:21:44 <ertes> ggVGc: by assuming * :: *
09:22:10 <boxscape> ggVGc: here is a bit of a reddit discussion https://www.reddit.com/r/haskell/comments/4180k3/what_is_typeintype/
09:22:13 <ertes> ggVGc: in fact the use of "*" is deprecated when you use TypeInType, so let's use the proper name:  Type
09:22:26 <ertes> ggVGc: Type :: Type  -- the type Type is a member of the type Type
09:22:38 <ggVGc> theduke: I think that's very implementation specific, and also not something you should generally care about when writing haskell
09:22:41 <ertes> 15 :: Int, Int :: Type, Type :: Type, Type :: Type, …
09:23:20 <glguy> ania123: In that book the word "constructor" is refering to the data constructors True and False
09:23:34 * hackagebot opaleye 0.5.2.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.5.2.0 (tomjaguarpaw)
09:24:10 <ania123> glguy: http://pastebin.com/bs52P73y
09:24:14 <ania123> could you please see this
09:24:20 <ania123> what I do not udnerstand is
09:24:30 <ertes> ggVGc: this may sound like a small detail, but actually it changes a lot, because now things like the following make sense:  forall k (a :: k). …
09:24:34 <ania123> data A = B | C
09:24:35 <ania123> and 
09:24:43 <ania123> data Bool = True | False
09:24:46 <ania123> how can be same?
09:25:01 <ania123> since True and False has predifined meaning for haskell?
09:25:05 <boxscape> they just mean that True and False are not built in names
09:25:15 <glguy> They're the "same" in that they are defining a new data type which is comprised of two distinct values neither having any fields
09:25:19 <boxscape> they are not predefined, they are defined in a library that's automatically imported
09:25:24 <ertes> ggVGc: for more information see: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeInType
09:25:29 <ggVGc> ertes: what practical problems are now easier to implement because of TypeInType?
09:25:34 <mlehmk> the answer is in the text itself
09:26:40 <xcmw> glguy: I can't call the function. I posted the error in the lpaste
09:26:42 <ertes> ggVGc: anything that involves type-level calculation, singleton types and proofs
09:27:18 <ania123> glguy: B and C does not have any meaning there, is not? while True and False has predifined meaning
09:27:20 <ggVGc> hm, I think this is a bit over my head :)
09:27:22 <ggVGc> thanks anyway
09:27:25 <ggVGc> I'll try to wrap my head around it
09:27:30 <ertes> ggVGc: we had kind polymorphism before (via PolyKinds), but now there is no difference between kind polymorphism and type polymorphism…  you can abstract over kinds the same way you abstract over types
09:27:34 <jle`> i like that i can universally quantify over kinds now
09:27:39 <ggVGc> ahhh
09:27:41 <jle`> forall k (a :: k) b. ..
09:27:42 <ggVGc> I think I get it
09:27:43 <ggVGc> that's nice
09:28:04 <ggVGc> personally my programs contain barely any type level programming yet though
09:28:25 <ggVGc> haskell at the value level is powerful enough already compared to anything else I've worked with
09:28:34 * hackagebot convert-annotation 0.4.0.0 - Convert the annotation of a gene to another in a delimited file using a variety of different databases.  https://hackage.haskell.org/package/convert-annotation-0.4.0.0 (GregorySchwartz)
09:28:46 <ertes> ggVGc: remember all those nice things you had for types?  like type families and type classes?  now you have them for kinds as well, because "kind" and "type" are the same thing =)
09:28:49 <ania123> glguy: could you please tell me briefly?
09:28:54 <jle`> ania123: what predefined meaning do you think True and False have?
09:28:59 <ggVGc> ertes: yeah, that's nice
09:29:11 <ggVGc> although, I can't come up with a use case for myself for ityet
09:29:30 <ania123> jle`: we know that True is 'true' in any interpretation
09:29:32 <jle`> ania123: True and False do not have predefined meanings.  their meaning is social construct/convention
09:29:35 <ggVGc> I haven't been able to find a good use case for type classes in my own work yet
09:29:55 <jle`> ania123: are you just saying that it's that way because of the letters in the constructor?
09:30:10 <jle`> of course then any two constructors with different names would be different things
09:30:25 <ania123> data A = B | C
09:30:29 <jle`> to Haskell, it doesn't matter
09:30:37 <jle`> haskell doesn't care about what name you give the constructors
09:30:39 <ania123> data Bool = True | False
09:30:42 <jle`> they're basically bland identifiers
09:31:10 <ania123> aha
09:31:12 <jle`> data Foo = Bar | Baz
09:31:17 <glguy> xcmw: You'll need to provide a type signature for o1 and o2
09:31:21 <jle`> to Haskell, they're just types with two constructors
09:31:23 <glguy> xcmw: For example "o1 :: (String, Int)"
09:31:24 <ertes> ggVGc: just to give you a small example: i wrote this code in 2014 when PolyKinds was still rather new and shiny: <http://lpaste.net/109388>, and it has all this ugly explicit type/kind communication and this super-ugly KProxy type…  they can now all disappear
09:31:39 <glguy> xcmw: By using RankNTypes like this you've giving up some type inference
09:31:48 <jle`> haskell doesn't assign True/False any predefined meaning.  it's in your head
09:32:11 <ania123> jle`: because in objct level, if we have True constant and False constant True && False haskell retunrs False, it means Haskell distinguishs ...
09:32:12 <boxscape> except for the if statement, right?
09:32:13 <glguy> True / False is a slightly bad example because Haskell does assign some built-in meaning regarding if then else and guards
09:32:26 <boxscape> ah right, guards too
09:32:31 <jle`> ania123: (&&) is a not built in function
09:32:34 <jle`> you can define it yourself
09:32:41 <jle`> (&&&) :: A -> A -> A
09:32:50 <ania123> && is builtin function
09:32:56 <xcmw> glguy: Thanks. It works now.
09:33:00 <ertes> ania123: predefined, not built-in
09:33:04 <ertes> it's a library function
09:33:05 <jle`> it's just a normal function you could define
09:33:08 <jle`> it's not special
09:33:22 <jle`> A &&& y = y
09:33:25 <jle`> B &&& _ = B
09:33:33 <boxscape> ania123: && is defined in this file: https://downloads.haskell.org/~ghc/7.6.3/docs/html/libraries/ghc-prim-0.3.0.0/src/GHC-Classes.html
09:33:47 <jle`> ania123: it's not a special function, it's just a library function
09:34:10 <Tehnix`> glguy: isn't that just if/else being syntatic sugar for case on a Bool match?
09:34:29 <jle`> ania123: it's mostly there for convenience
09:34:34 <jle`> but it isn't a fundamental part of Haskell
09:34:35 <ania123> anyway, Haskell system system know interpetation of True and False
09:34:36 <ania123> no?
09:34:51 <glguy> Tehnix`: even if it was, the resulting case match would use True and False patterns in a particular way
09:35:15 <jle`> just some cases of syntactic sugar for convenience
09:35:22 <jle`> but otherwise they are normal data types
09:35:38 <jle`> the type system and haskell core do not distinguish
09:35:47 <jle`> there is just some syntactic sugar for convenience
09:36:04 <Tuplanolla> Doesn't `RebindableSyntax` change that too?
09:36:10 <jle`> like how we can write "hello" instead of ['h','e','l','l','o']
09:36:20 <jle`> well
09:36:26 <ReinH> Haskell knows about booleans, but && is not evidence of this.
09:36:28 <jle`> that actually might be different, because Char is special
09:36:36 <ReinH> if/then/else and guards are evidence
09:36:42 <ggVGc> ertes: I think I understand the problem superficially, but this level of type programming is still over my head. thanks for the example!
09:36:55 <ggVGc> Idris seems really interesting
09:37:08 <ggVGc> it might be time I take a real look at it out of curiosity
09:37:11 <ania123> if I define Bool following way
09:37:18 <jle`> there are a lot of special types in Haskell, that can't be defined within haskell
09:37:19 <ania123> data Bool = A | B
09:37:24 <jle`> but Bool is not one of them
09:37:27 <ania123> and use this type 
09:37:47 <ggVGc> ertes: do you think Idris has a chance of overtaking Haskell at some point?
09:37:57 <ggVGc> it in many ways seems like haskell 2.0
09:38:10 <ggVGc> without the legacy of early haskell developments
09:38:12 <boxscape> that's explicitly not Idris's goal, and I'm pretty sure it's supposed to be a research language, ggVGc 
09:38:19 <ggVGc> hm
09:38:32 <johnw> more practically oriented than pure research, I'd say
09:38:35 <ertes> ggVGc: i don't think so, because idris is a very different language
09:38:36 * hackagebot rss 3000.2.0.6 - A library for generating RSS 2.0 feeds.  https://hackage.haskell.org/package/rss-3000.2.0.6 (BasVanDijk)
09:38:45 <jle`> i wouldn't consider idris a direct improvement on haskell.  it's a different language
09:38:50 <jle`> it's not meant to be haskell-but-better
09:38:51 <ertes> ggVGc: it has the potential to become a good alternative, not a successor
09:38:53 <ggVGc> boxscape: I hear a lot of people name idris as a language for writing "real software"
09:38:54 <jle`> it's meant to be not-haskell
09:39:07 <johnw> for one thing, Haskell was intended from the beginning to explore the notion of lazy functional
09:39:22 <boxscape> ggVGc: It's designed to be able to write real software in, yeah. I'm not sure whether it's *intended* to write real software in, though, if that makes sense
09:39:35 <ggVGc> yeah fair
09:40:29 <ertes> it has some nice features which i hope haskell will copy some day like idiom brackets
09:40:34 <ggVGc> jle`: yeah, but my question was more like, If I want to write a program with high type safety in the future, might I choose Idris over Haskell
09:40:45 <ggVGc> the same way, today people might choose node.js over php
09:40:48 <ggVGc> for the same tasks
09:40:56 <ggVGc> even though they are vastly different languages
09:41:00 <ertes> but the number one feature from another language i'd like to see in haskell is still agda's record and module system
09:41:15 <ggVGc> ertes: I'd be happy if haskell gets a record system at all!
09:41:32 <ggVGc> (maybe that's a bit harsh)
09:41:34 <ertes> hmm?  the current one is not that bad
09:42:05 <ggVGc> I think it's quite bad, if it weren't for lenses
09:42:17 <ertes> especially with some of the newer extensions like DuplicateRecordFields
09:42:43 <ania123> is it allowed to define data A = B|C  and data A = D | M
09:42:54 <jle`> not in the same module
09:43:01 <jle`> that's like defining two values with the same name
09:43:12 <jle`> you can't have foo = 1 and foo = 10 in the same scope
09:43:27 <jle`> well, in the same module at the top level
09:43:50 <jle`> ania123: but, you can define them in different modules and Haskell won't mind
09:45:01 <boxscape> interestingly, Haskell will know if you try to use your own Bool for an if statement instead of GHC.Types.Bool, and complain, which I suppose makes sense, but also makes it more than syntactic sugar, right?
09:46:03 <ggVGc> ania123: think about it. What would "data A = B|C followed by data A = D|M" mean?
09:46:07 <ggVGc> how would you use this?
09:46:15 <ertes> boxscape: all syntactic sugar is like that, but you can actually relax it by using -XRebindableSyntax
09:46:16 <mlehmk> or just data A = B | C | D | M
09:46:24 <boxscape> ertes: I see, interesting
09:46:34 <jle`> just tried it, RebindableSyntax does work
09:46:48 <jle`> it lets you define your own type to useinstead of Bool
09:47:08 <ertes> RebindableSyntax desugars if/then/else into a function application, but i don't remember the name
09:47:13 <boxscape> ifThenElse
09:47:28 <ania123> clear
09:47:41 <jle`> you can define your own ifThenElse :: A -> a -> a -> a
09:47:49 <jle`> so if A then "hey" else "hi" => whatever you want
09:48:07 <jle`> *if B
09:48:09 <ertes> it actually makes if/then/else completely unrelated to booleans =)
09:49:04 <boxscape> I see, so you could simply say something like ifThenElse = const
09:49:22 <sm> woah.. a sneaky rebinding of that in base could mess with a lot of packages 
09:49:23 <jle`> yeah, and i suppose it'd be completely polymorphic over the "test" then
09:49:36 <ggVGc> uhm
09:49:39 <ggVGc> why would I want to do this?
09:49:41 <hodapp> I think I recall seeing some EDSLs making use of this
09:49:55 <boxscape> no reason, just interesting that you can make it polymorphic
09:49:56 <hodapp> ones meant for code generation
09:50:25 <ania123> data Move = Left | Right | Up | Down
09:50:26 <jle`> oh yeah, it'd be nice to be able to reify if/then/else for a dsl
09:50:32 <ania123> here Left, etc
09:50:44 <ania123> ara just constructors is not?
09:50:50 <jle`> yes
09:50:59 <jle`> you can pick whatever name you want for them
09:51:05 <ania123> is constructor same as variable?
09:51:10 <ania123> i meant type variable
09:51:11 <mlehmk> I'd call it Orientation
09:51:11 <jle`> not quite
09:51:19 <mlehmk> or Direction
09:51:23 <jle`> data constructors like Left aren't types
09:51:25 <jle`> they're values
09:51:32 <jle`> if anything they're the...opposite of variables
09:51:36 <ggVGc> can I make ifThenElse have side effects also?
09:51:51 <jle`> because when using them in a function, you'd pattern match on them as arguments
09:52:08 <jle`> mkMove m = case m of Left -> ...; Right -> ...; Up -> ...; Down -> ...;
09:52:09 <boxscape> ggVGc: I would think that if you still want to be able to use it like before, you'd have to use something like unsafePerformIO
09:54:53 <ania123> jle`: not clear... 
09:55:06 <jle`> ania123: do you know what types are?
09:55:07 <ania123> jle`: let me write smt
09:55:11 <jle`> and, do you know what values/terms are?
09:55:18 <jle`> an example of a type would be something like 'Bool', 'Int'
09:55:23 <ania123> I know types from simple typed lambda calculus
09:55:24 <jle`> and example of a value would be something like True or 10
09:55:26 <ertes> ggVGc: ifThenElse :: m (Maybe a) -> (a -> m r) -> m r -> m r
09:55:33 <jle`> data constructors like Left/Right aren't types
09:55:33 <ertes> + Monad
09:55:35 <jle`> they're values/terms
09:56:01 <jle`> so, they're closer to things like 10, "hello", True, [7,8,9], and not things like Int, [Bool], String
09:56:10 <jle`> and they are definitely not type variables :)
09:56:37 <ania123> :)
09:56:39 <ania123> hehe
09:56:46 <ania123> I am reading now section
09:56:51 <ania123> chapter
09:57:02 <jle`> type variables are a completely different concept; they let you write polymorphic functions
09:57:09 <ania123> Declaring types and classes
09:57:12 <jle`> by letting them work over types polymorphically
09:57:38 <jle`> map :: (a -> b) -> [a] -> [b], 'a' and 'b' are type variables, meaning that you can pick any type you want for them, and map will work for those types
09:57:44 <jle`> map :: (Int -> Bool) -> [Int] -> [Bool]
09:58:55 <ggVGc> ertes: nice
09:59:06 <ania123> jle`: types and polimorfism is cllear for me
09:59:10 <ania123> totally
09:59:17 <M0b10s> good afternoon everyone =)
09:59:20 <ania123> type declaration is not clear at all
09:59:35 <ggVGc> polymorphism in haskell is really not clear to me
09:59:37 <jle`> do you  mean like, type signatures
09:59:43 <jle`> or defining your own data types?
10:00:17 <ania123> data Bool = True | False
10:00:22 <ania123> Bool is here type
10:00:25 <ania123> is not?
10:00:31 <jle`> yes; that's definining a new type called 'Bool'
10:00:40 <jle`> with two constructors: True and False
10:00:47 <jle`> so, there are two values of type Bool, True :: Bool, and False :: Bool
10:00:49 <ania123> this is clear
10:01:21 <M0b10s> kinda quick Q here... about filter (((( filter (\x -> isDigit x == True) ["0 4 2 !!!"]
10:01:22 <M0b10s> )))))) any brave soul could give me a tip?
10:01:34 <ania123> why did u say Bool is close to value then to type?
10:01:45 <jle`> i didn't say that :o
10:02:03 <jle`> M0b10s: what kind of tip are you looking for?\
10:02:18 <ania123> [21:55] <jle`> data constructors like Left/Right aren't types
10:02:20 <haskell_newbie> excuse me, i'm looking for a way to calculate the maximum distance between two neighbored numbers in a list.. can anyone help?
10:02:24 <ania123> [21:55] <jle`> they're values/terms
10:02:31 <jle`> ania123: yeah, so True and False are values/terms, there
10:02:33 <jle`> Bool is a type
10:02:39 <ania123> aha
10:02:39 <jle`> True and False are the data constructors
10:02:42 <jle`> Bool is the type constructor
10:02:52 <M0b10s> well that (code) doesn't work....but i want something like that...is is expecting char's but is getting strings =s
10:03:03 <jle`> M0b10s: btw, if you mean to filter over the Char's, then you should be filtering "0 4 2 !!!"
10:03:05 <ania123> Bool is a type
10:03:08 <jle`> that's a list of Char's
10:03:15 <jle`> M0b10s: ["0 4 2 !!!"] is a list of strings
10:03:20 <jle`> :t ["hello","world"]
10:03:23 <lambdabot> [[Char]]
10:03:30 <M0b10s> hmmm
10:03:31 <jle`> in an ideal world that would say [String], heh
10:03:39 <jle`> ["hello","world"] :: [String]
10:03:42 <jle`> "hello" :: [Char]
10:03:53 <M0b10s> xD jeee
10:03:58 <jle`> also, i'm sure you are aware that 'x == True' is just x :)
10:03:58 <M0b10s> my bad there
10:04:01 <boxscape> M0b10s: "(\x -> isDigit x == True)" is equivalent to writing "isDigit"
10:04:03 <ania123> jle`: do we need type declaration? is it necessary to program in haskell?
10:04:23 <jle`> ania123: those aren't type declarations, those are type definitions, i'd say
10:04:28 <jle`> they're not necessary, just very useful
10:04:33 <jle`> defining your own types is pretty useful
10:04:39 <xcmw> It is possible to use $ in a type signature? A $ B C = A (B C)
10:04:39 <jle`> you usually do it all the time
10:04:46 <jle`> xcmw: only if you define it
10:04:52 <jle`> it doesn't come in any standard libraries
10:04:54 <M0b10s> i know but sometime we get errors over bad "("'s it's was just that
10:04:57 <jle`> type f $ x = f
10:05:28 <jle`> er, type f $ x = f x
10:05:30 <ania123> could you please give me an example?
10:05:40 <jle`> ania123: i'm sure the book you use will give examples coming up :)
10:05:50 <ania123> ok
10:05:52 <ania123> :)
10:06:00 <M0b10s> but yeaa sry....maybe too many hours in front of the pc is the responsible x)
10:06:22 <M0b10s> tnks all for the help =D
10:06:33 <jle`> ania123: there are more examples for new types than just simple enumerators like what you've shown
10:06:35 <xcmw> jle`: Thanks
10:06:36 <haskell_newbie> -> still looking for a way to calculate the maximum distance between two neighbored numbers in a list.. can anyone help?
10:06:36 <jle`> M0b10s: no problem!
10:06:55 <jle`> ania123: but, if you've ever programmed in any other languages, data A = B | C | D ... is an enumerator pattern
10:07:02 <jle`> so if you've ever used an enumerator in another language, this is that
10:07:17 <ania123> I use prolog
10:07:24 <jle`> data Grade = A | B | C | D | F
10:07:27 <ania123> it does not have types
10:07:32 <jle`> calculateGrad :: Double -> Grade
10:07:40 <jle`> ah, ok
10:07:45 <jle`> types are neat, you'll see soon :)
10:07:54 <ertes> haskell_newbie: do you need the elements themselves as well, or just the distance?
10:08:22 <ania123> do hope
10:08:34 <haskell_newbie> @ertes: just the distance
10:08:34 <lambdabot> Unknown command, try @list
10:08:37 * hackagebot purescript 0.10.2 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.10.2 (PhilFreeman)
10:09:01 <ertes> haskell_newbie: do it in steps; first step: write a function that goes from lists to lists of neighbouring pairs
10:09:16 <ertes> haskell_newbie: it should have the following type:  neighbours :: [a] -> [(a, a)]
10:09:51 <ertes> test case: neighbours [1,2,3,4] = [(1,2), (2,3), (3,4)]
10:11:56 <haskell_newbie> @ertes ok, the final function should have a list given and maximum distance as output .. e.g. [1,2,5,7,0,9] -> 7
10:11:56 <lambdabot> Unknown command, try @list
10:12:25 <ertes> haskell_newbie: not 9?
10:13:13 <ertes> haskell_newbie: (also don't type the @, because that triggers lambdabot)
10:13:15 <haskell_newbie> @ertes: oh.. sure, 9. sorry.
10:13:15 <lambdabot> Unknown command, try @list
10:13:23 <haskell_newbie> sorry
10:13:43 <ertes> haskell_newbie: yeah, do it step by step
10:14:03 <ertes> step 1:  [1,2,5,7] → [(1,2), (2,5), (5,7)]
10:14:20 <ertes> step 2: [(1,2), (2,5), (5,7)] → [1, 3, 2]
10:14:28 <ertes> step 3: [1, 3, 2] → 3
10:14:50 <ertes> write individual functions for each step, then just use them together at the end
10:15:21 <ania123> data Move = Left | Right | Up | Down
10:16:02 <ania123> from this defination, we can conclude function can not have Move type, so we can not have an function with type Move
10:16:05 <ania123> is not?
10:16:27 <ania123> f : Move  
10:16:40 <ertes> ania123: something of type Move is not a function…  it's just a value of type Move
10:16:43 <ania123> f can not be applied in any value
10:16:48 <ania123> ok
10:16:57 <ertes> x :: Move
10:17:00 <ertes> x = Up
10:17:34 <ertes> ania123: (also choose different names for Left and Right, because those are predefined for Either)
10:18:02 <ertes> Forward/Backward, Left'/Right', …  use your imagination
10:18:19 <ania123> ok
10:18:41 <Tuplanolla> Just append `ward` to the names.
10:18:42 <haskell_newbie> ertes: thanks, I will think about these functions now.
10:22:36 <joncol> OK, so I changed my ray tracer to use repa, and it's very cool and all to get parallel processing almost for free! But how can I combine this with a nice progress bar to show how long time it's left before my picture is rendered? Before trying out repa, I used System.Console.AsciiProgress to get a very useful indication of running time. But this, of course, requires the IO monad. And to use repa, I had to 
10:22:42 <joncol> make all my functions pure. How can I proceed?
10:23:36 <Lokathor> you could chop up the ray tracing into segments
10:23:43 <kadoban> joncol: Make a spinner instead? Lazy solution is best solution.
10:23:51 <Lokathor> and push an IO update every time a segment is done
10:23:56 <Lokathor> but i think you lose a lot of speed there
10:24:03 <joncol> Lokathor: What's a segment?
10:24:08 <joncol> kadoban: What's a spinner
10:24:10 <joncol> :)
10:24:41 <Lokathor> like, say you know you have 1000 rays to compute, you could manually compute 10 rays at a time, then say "+1%" to the screen or whatever
10:24:45 <Lokathor> and then compute 10 more rays
10:25:06 <kadoban>  / then - then \ then - then /, the ascii version of those little loading graphics from youtube and everywhere.
10:25:40 <joncol> kadoban: Ah, but I need to get an estimation of how much time left.
10:25:44 <joncol> Lokathor: Good idea.
10:25:48 <dmiles> have people here used ETA (haskell on jvm) ?  What are the drawbacks?
10:26:11 <ab9rf> well, you're using the JVM, so that's one big drawback....
10:26:23 <Lokathor> joncol, you'll probably lose a ton of speed though, since you'll be starting and stopping repa, well, 100x as often
10:26:47 <joncol> Lokathor: True. Shouldn't there be a "good way" to do this?
10:26:47 <dmiles> ab9rf: hehe well ....
10:27:25 <a6a3uh1> Hi! what is the type of function that takes something of IsString typeclass and something char-like and puts char at the begining of IsString? f :: IsString s => s->c->s; f s c = (c:s). Is there any typeclass fo 'c' for this to work?
10:27:32 <Lokathor> probably not. the point of repa is to throw all the data at the GPU and let it go as fast as possible. telling it to stop all the time to report its progress just slows that down
10:27:57 <joncol> Lokathor: Is repa using the GPU? Didn't even know.
10:28:02 <ab9rf> you have to ahve some thing that collects results, let that component update the progress bar
10:28:11 <ab9rf> joncol: that's the whole point of repa
10:28:24 <Lokathor> joncol, i may be confusing repa with accelerate
10:28:29 <joncol> ab9rf: I thought it just made use of all CPUs
10:28:34 <joncol> All cores
10:29:03 <Tuplanolla> Repa does not interface with peripherals without extra packages.
10:29:18 <joncol> ab9rf: Well, how can I collect the results from repa, I don't know how to do this?
10:30:16 <joncol> Tuplanolla: Do you have any ideas up your sleeve perhaps? :)
10:30:24 <Lokathor> my mistake then. However, either way, telling a process that you want to move as fast as possible to stop and keep reporting progress will take time. In the case of repa, the moving of the data between ram and cpu is the time drag
10:30:29 <Tuplanolla> What are you after, joncol?
10:30:34 <ab9rf> indeed, i had it confused with accelerate
10:30:56 <joncol> Tuplanolla: I need to create a progress bar for my repa ray tracer, but I'm not sure on how to approach this.
10:31:03 <kadoban> joncol: That does seem like an interesting issue. I wonder if anyone else has done something for it.
10:31:38 <dmiles> i guess a question i have with ETA is if the language is way too differnt for someone good at Haskell 
10:31:51 <joncol> I guess it's worth trying out Lokathor's straightforward solution with segments if there's no alternative.
10:32:08 <Tuplanolla> That's quite difficult if you have parallel work.
10:32:34 <Tuplanolla> No work is done until you force the `D` representation into something concrete.
10:32:43 <Athas> joncol: I am very sure there is no other way than manually chunking the work.
10:33:16 <joncol> OK, thank's for the feedback!
10:33:21 <joncol> *thanks
10:33:38 * hackagebot gloss-rendering 1.10.3.4 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.10.3.4 (BenLippmeier)
10:34:11 <joncol> Tuplanolla: There's a lot of overhead in forcing this 'D -> U' conversion several times just to get progress?
10:35:14 <Tuplanolla> I can't tell, but I would expect that to be the case.
10:35:42 <joncol> kadoban: Yes, it seems like something many people would need!
10:36:01 <Athas> joncol: why do you need that conversion?  Can't you just divide the image into 100 sections and perform the raytracing for each of them separately?
10:36:01 <joncol> Tuplanolla: I guess I'll just have to measure.
10:37:18 <Tuplanolla> It's much better to do what Athas said and use sequential evaluation on the chunks, because there are so few of them, joncol.
10:37:18 <joncol> Athas: But then I'd have to do the conversion once for each section anyway, no?
10:37:41 <Lokathor> yes, you'd have to convert each section manually
10:38:00 <Tuplanolla> Try it and see what happens, joncol.
10:39:49 <Athas> joncol: that might not be too expensive.  100 is a low number for a computer.  Maybe you can concatenate the 'D arrays before the conversion; not sure.
10:40:15 <joncol> Athas: So let me see if I understand what you mean. 10: Split the work into several "chunks". 20: Do all the work within one chunk in parallel. 30: Print some progress. 40: Proceed to the next chunk. 50: Goto 20
10:41:48 <Athas> joncol: yes, although you can also task-parallelise the chunks if you wish.  But as long as each chunk is big enough, that should not be necessary (and it would make a progress bar less reliable).
10:42:01 <Athas> However, I admit I have a poor intuition for the computational behaviour of a ray tracer.  Is it mostly compute bound?
10:42:31 <Tuplanolla> I'm not sure if this is possible, but could you produce the chunks in `D` rep and then interleave `foldS` with your reporting until you run out of dimensions, joncol?
10:43:03 <joncol> Athas: As opposed to memory access bound? I have to do some more profiling, but mostly compute bound I would say, yes.
10:44:08 <Tuplanolla> If that's not the case, you'll have to force each chunk out of `D` with `computeP` and `foldl'` over them by hand.
10:44:38 <joncol> Tuplanolla: I don't know `foldS`, but I'm using `fromFunction` to produce the `D` arrays currently..
10:46:48 <JerinPhilip[m]> !nick jerin[m]
10:50:03 <squidz> If a OOP class is immutable, how much can I think of classes as an analog to haskell types?
10:51:10 <EvanR> classes are used for a lot of things
10:51:20 <EvanR> for each thing, theres something in haskell thats more specifically for that
10:51:31 <shapr> squidz: I see a method on an object as being a chunk of code that associated with a particular type. For that, typeclasses match perfectly.
10:52:07 <EvanR> a record of functions / lazy values in haskell corresponds to an object type in a hypothetical OOP language
10:52:24 <EvanR> type classes are fancy sugar for passing the records around
10:52:48 <EvanR> OOP classes in some sense are functions to produce objects, which are values of that object type
10:53:01 <EvanR> unless you use classes as modules, in which case you have modules in haskell
10:53:15 <squidz> shapr: so an objects methods wouldn't fit as good to the metaphor as typeclass functions that a type belongs to?
10:54:12 <shapr> squidz: It's hard for me to map directly between OOP in Python and code in Haskell. I can always do the same thing, but not always the same  way.
10:54:31 <shapr> squidz: so most of my "This in Haskell does that in Python" comparisons are still somewhat hand wavy.
10:55:10 <shapr> like what EvanR just said, an instance is an actual type in OOP, you don't really get that at all in Haskell.
10:55:27 <shapr> You could talk about typeclass instances, I guess that would work. But I'm sure it breaks down somewhere.
10:55:58 <shapr> squidz: are you writing an intro to Haskell for people who understand OOP? or expanding your personal understanding? What's your goal?
10:56:00 <squidz> right, I think the whole question is a little hand-wavy, but I thought about it when wondering if it would be a good aproach to use a lot of simple classes in OOP, and then wondered what the analog for object methods should be
10:56:33 <squidz> shapr: I'm just trying to understand how to write good code regardless of it being OOP or functional
10:56:41 <EvanR> you can try to emulate ADTs with simple classes in OOP, its not very popular to do, and its a little awkward
10:57:01 <EvanR> for example, you can hide the constructor of the class, and expose two "smart constructors" for Left and Rgiht, now you sort of have Either
10:57:12 <EvanR> its not very popular
10:57:16 <shapr> I just recently figure out that objects in OOP are also a stand-in for ADTs in Haskell.
10:57:22 <squidz> EvanR: do you think its unpopular because it's akward, or do you think that there is something fundamental in OOP that makes it harder in the long-run
10:57:46 <EvanR> its not popular because most people never heard of ADTs
10:57:48 <shapr> You can force a particular datatype structure in OOP by only allowing methods to set properties, and they only allow certain shapes.
10:57:54 <EvanR> when you try it, its awkward, doesnt help
10:58:06 <shapr> Oh, EvanR already said that.
10:58:53 <squidz> in the case of a simple either class, what would the two constructors perform for left and right? 
10:58:57 <shapr> It's hard to do ADTs in OOP
10:59:00 <EvanR> in ruby and javascript, its almost impossible to explain the utility of Maybe and Either
10:59:26 <EvanR> but there are newer languages which have a step in that direction, that have the Option return type either built in or as a library, but thats it
10:59:28 <squidz> yeah i'm wondering if it might be feasable in some cases for java because it's also statically typed
10:59:30 <Lokathor> I'd rather be able to chain maybe than get stuck with a null
11:00:15 <EvanR> but no one calls that OOP
11:00:41 <mlehmk> isn't any return from a function in ruby and javascript implicitly an Either where handling of one case is implicit?
11:01:00 <EvanR> no, its implicitly a JSVal
11:01:02 <mlehmk> thinking of the builtin exception handling happening under the hood
11:01:09 <EvanR> exceptions are another story
11:01:16 <shapr> mlehmk: that sounds like Go
11:01:28 <shapr> if result != nil // we got a result
11:01:51 <EvanR> swift and elixir have the notion of a chainable option return type
11:02:04 <EvanR> not sure about go
11:02:07 <Tuplanolla> One of the problems there is your mental state. When you pretend you're writing Haskell in another language, your expectations are lined up accordingly. However you'll be constantly disappointed and the exercise will feel unpleasant.
11:02:22 <mlehmk> more like, if an exception is happening, it skips all expressions and statements till a finally or catch and then eventually executes it
11:02:44 <shapr> exceptions as control flow?
11:02:46 <Tuplanolla> The same works in the other direction too.
11:02:54 <EvanR> exceptions as control flow, in ruby yes
11:03:01 <mlehmk> That's how those languages are doing it
11:03:02 <EvanR> but you also have nils being returned
11:03:08 <EvanR> accidentally
11:03:12 <EvanR> or on purpose
11:03:13 <mlehmk> nils are a value
11:03:14 <shapr> I like to learn how to think in new languages, it's always fun.
11:03:30 <mlehmk> nils, null, it's all of type reference
11:03:32 <EvanR> in js you probably want to avoid exceptions entirely
11:03:39 * hackagebot opaleye 0.5.2.1 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.5.2.1 (tomjaguarpaw)
11:03:41 * hackagebot gloss-rendering 1.10.3.5 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.10.3.5 (BenLippmeier)
11:03:43 <squidz> Tuplanolla: I have no problem with writing OOP-flavored code, but I'm trying to analyze when favoring different programming 'styles' fit better to certain situations
11:03:43 * hackagebot gloss-raster 1.10.2.4 - Parallel rendering of raster images.  https://hackage.haskell.org/package/gloss-raster-1.10.2.4 (BenLippmeier)
11:04:07 <EvanR> mlehmk: nil isnt a reference in these dynamic languages, its an artificial emulation of the NULL pointer from previous messed up languages
11:04:27 <mlehmk> still accepted for a reference
11:04:43 <EvanR> ... nah, in many popular languages now you dont even have a reference
11:04:53 <EvanR> well except PHP
11:04:55 <mlehmk> although it causes an error value if dereferenced
11:05:07 <EvanR> ah no, youre mixing it up
11:05:08 <systemfault> For some reason, in Java, they call what we would call "pointer", reference
11:05:16 <mlehmk> it's more references than you think
11:05:20 <EvanR> no its not
11:05:43 <EvanR> nil does not cause an error if you do anything with it in ruby, js, clojure, whatever
11:05:51 <EvanR> you can pass it around and look at it
11:05:54 <mlehmk> yep, it's called reference there. It's like a different language
11:06:19 <mlehmk> of course, but applying the dereference causes the error value
11:06:23 <EvanR> more often in the dynamic languages a reference is a thing that lets you mutate variables from a distance
11:06:30 <newscripter> If you were to create a GUI game of tic tac toe in a functional paradigm: you input the game state and output the game state on your screen. Is that right? If it is, isn't it just a "backwards" way of keep track of state? Why is that better design than OOP? (not trying to flame, I'm trying to understand the virtues of functional/Haskell)
11:06:44 <EvanR> low level pointers are not on topiic
11:06:58 <EvanR> its all boxed
11:07:16 * shapr boxes up EvanR 
11:07:19 <jedai> newscripter: The argument is that by making state explicit you're containing it and can't have it spill out unexpectedly
11:07:44 <jedai> newscripter: it's often easier to test the program too
11:07:53 <Tuplanolla> Take a look at how Gloss does it if you want to see it in action, newscripter.
11:07:54 <mlehmk> tic tac toe in haskell... that sounds interesting to learn something new
11:07:56 <shapr> newscripter: if you've ever had mock objects take over your entire test suite, you might understand why explicit state promotes sanity.
11:07:58 <Tuplanolla> @hackage gloss
11:07:58 <lambdabot> http://hackage.haskell.org/package/gloss
11:08:32 <joe9_> gloss is awesome, simple and powerful.
11:08:40 <jedai> newscripter: also you can easily get several tic-tac-toes going simultaneously (if you're coding a Masiively multiplayer Tic-Tac6toe !! ;)
11:09:01 <squidz> newscripter: if you separate the state and the rules it makes it easier if you want to suddenly extend the game to display in another GUI, or if you want to add more logic rules. The concerns are already separated
11:09:10 <Tuplanolla> That reminds me of a patch I've planned for Gloss...
11:09:24 <EvanR> gloss is nice... but for the question about state, its a really annoying example: either you have the pure functions pass the state around *but you cant do any IO on the side*... OR you use the IO version which has the same shape, but now you probably dont even need the state passing because its IO
11:09:32 <mlehmk> you can even keep a history of states around and could try every possible move in any state
11:09:45 <shapr> newscripter: overwhelmed yet? :-)
11:10:18 <jedai> mlehmk: or implement a "take back your move" trivially
11:10:56 <mlehmk> backtracking...
11:11:18 <newscripter> no, I'm loving it. I've tried re-writing some of my apps in purely functional and agree with: 1) easier to test 1) effortless multithreading. I can't wrap my head around making large apps like games which keep track of tons of states and writing it in functional tho
11:12:02 <EvanR> in clojure they take this seriously, the large app has 1 large value of the state and you keep immutably updating it
11:12:09 <jedai> newscripter: lens helps
11:12:17 <shapr> EvanR: that's how I see Haskell apps too
11:12:25 <EvanR> you can do it that way in haskell too
11:12:26 <newscripter> yeah, that sounds like immense overhead thought isn't it?
11:12:35 <EvanR> but there are other ways 
11:12:59 <EvanR> newscripter: for a tree, its not that bad. for a giant array, yes
11:13:01 <jedai> newscripter: not that much, if your state is intelligently done, you're sharing the immense majority of it from one state to the next
11:13:15 <EvanR> so we like trees more
11:13:37 * shapr hugs a tree
11:13:39 * hackagebot sibe 0.2.0.2 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.2 (mdibaiee)
11:13:51 <Lokathor> MMO Tic Tac Toe
11:13:56 <shapr> "persistent data structures"
11:13:57 <Lokathor> the ads practically write themselves
11:15:18 <jedai> Lokathor: Sure, but they're gibberish !! :)
11:17:08 <EvanR> newscripter: there are some problems which are more obviousyl solvable with functional programming, like, imagine a web app request handler. This thing is specifically tasked with taking the input, validating it, generating a transaction (not necessarily applied yet) and some HTML view of the results
11:17:20 <EvanR> more obviously functional
11:17:44 <newscripter> absolutely, I've found it very hard to force myself to one paradigm. Some problems are easier solved one way
11:17:48 <EvanR> but a desktop GUI window with animations and extra windows popping up, and async requests going on that needs to be cancelled sometimes
11:18:11 <EvanR> as a whole thats not obviously functional
11:18:32 <EvanR> but you could coordinate all the pieces with concurrency and STM
11:18:39 * hackagebot gloss-examples 1.10.2.4 - Examples using the gloss library  https://hackage.haskell.org/package/gloss-examples-1.10.2.4 (BenLippmeier)
11:18:45 <EvanR> which has haskell good support for
11:19:18 <Lokathor> blessed be STM, lemme tell ya
11:20:25 <shapr> yeah, STM is so awesome
11:21:46 <bitemyapp> Lokathor: composable correctness wheeeeee
11:22:08 <EvanR> otoh there are those who seem to have gone outside the cave and see that huge gui app as obviously functional nonetheless hehe
11:22:59 <Tuplanolla> If natural numbers don't look like functions to you, you're simply not looking hard enough.
11:23:12 <Tuplanolla> I guess the same works for anything.
11:23:52 <Lokathor> appFunction :: AppInput -> AppState -> IO AppState
11:23:52 <Lokathor> whe
11:24:18 <EvanR> appFunction :: () -> IO () ...
11:24:27 <EvanR> you can get the input with IO ;)
11:25:25 <Lokathor> well, doThing :: IO () -- not a very informative type
11:25:51 <jedai> I still believe in FRP...
11:26:53 <Lokathor> I have never managed to learn FRP despite several faint efforts
11:27:02 <Lokathor> i get lost among too many options
11:27:17 <Lokathor> also they're usually stuck to a GUI, and I basically want headless FRP
11:28:52 <jedai> Lokathor: Well you need to stick them to "something" which generate the primitive events and behaviour
11:29:12 <Lokathor> but i want FRP hooked into an IRC bot, not to a GUI
11:29:31 <EvanR> an IRC bot is kind the obviously functional web requester thing i mentioned
11:29:54 <jedai> Lokathor: most FRP libraries allows you to define new primitives
11:29:55 <EvanR> Line -> Maybe Response
11:30:36 <jedai> Lokathor: but really IRC doesn't have Behaviour, only Events so it doesn't seem a really good field for FRP
11:30:36 <Lokathor> jedai, can you point at a particular suggested FRP library and particular tutorial to go with it?
11:30:52 <Lokathor> the IRC bot would manage an idle game :3
11:31:06 <shapr> newscripter: trying to convert a particular chunk of code? Or just write a game? How are you approaching learning Haskell?
11:31:25 <Cale> Lokathor: Pretty soon I'll be able to start putting some of my paid time toward creating instructional material for Reflex :)
11:31:51 <Lokathor> Cale, and at that time I will read every word
11:31:58 <Lokathor> and them use them to make yet another dumb idle game
11:32:03 <jedai> Cale: Good ! When I tried Reflex it seemed like something nice
11:32:16 <EvanR> idle games are a good example of where its not just reactive
11:32:24 <EvanR> the bot is spontaneously emitting events
11:32:26 <Cale> (but right now, if you're not interested in using the web stuff at all... well, it's not the easiest thing to get started with)
11:32:49 <Lokathor> EvanR, how do you mean spontaneously?
11:33:08 <EvanR> you know, everyone is idle an suddenly the game produces an event
11:33:09 <Cale> I would actually say if you want to make an idle game, give reflex-dom a try -- at least, most of the idle games I've ever seen have been web UIs
11:33:24 <EvanR> are we talking about IRC idle games?
11:33:28 <jedai> EvanR: isn't that fine if you model it as a random list of Events ?
11:33:38 <Lokathor> EvanR, no like cookie clicker and candy box and those kinds of idle games
11:33:46 <jedai> EvanR: or rather a random Event
11:33:46 <EvanR> oh... why is that called that...
11:33:48 <Lokathor> where a meter fills up, and then the user can convert resources between types
11:34:22 <Lokathor> it's called that because generally they're made in JS and you let them idle in a background tab and check on them every so often
11:34:25 <EvanR> jedai: real life frp's are reactive only, they dont let you arbitrarily position events in time, as per the denotation
11:34:57 <Cale> EvanR: Well, there are ways to manage that in practice too...
11:35:11 <Cale> Like, pure reflex doesn't have a delay operator
11:35:14 <Cale> But reflex-dom does
11:35:19 <jedai> EvanR: that would have to be created at the primitive level but I don't see any reason you couldn't have a "random" Event
11:35:34 <EvanR> jedai: right, hypothetically
11:35:50 <Cale> http://web.mit.edu/greghale/Public/reflex-dom-new/html/reflex-dom/Reflex-Dom-Time.html
11:36:12 <Cale> heh, someone also added inhomogeneous Poisson event generators
11:36:43 <Lokathor> Cale, I don't wanna make a web page though :P
11:36:47 <Cale> (Somehow I'm thinking that was probably Greg... but I could be wrong)
11:36:53 <Cale> Lokathor: Fair enough :)
11:37:31 <EvanR> and a simple delay is not really enough, because you might want to cancel
11:37:48 <Cale> EvanR: If the event hasn't occurred yet, you can certainly cancel
11:38:00 <EvanR> how?
11:38:19 <Cale> For instance, you can have a Behaviour which gates the Event
11:38:43 <Cale> http://web.mit.edu/greghale/Public/reflex/html/reflex/Reflex-Class.html#v:gate
11:38:47 <EvanR> do you pump all delayed events you ever wrote through the gate?
11:38:54 <EvanR> even if they are periodic
11:39:03 <jedai> Right, most FRP I know have a way to "filter" an Event
11:39:15 <EvanR> it doesnt sound efficient
11:39:16 <Cale> You can also switch
11:39:43 <Cale> switch :: Behavior t (Event t a) -> Event t a
11:39:55 <Cale> If the Behavior changes to never, then the output doesn't fire
11:40:08 <EvanR> and the timers are cancelled?
11:40:22 <Cale> and if there's no way for it to switch back, then perhaps the other Events are GCed.
11:41:24 <Cale> If you're starting the timer each time the event fires, then just not firing again is enough to shut it off.
11:42:14 <Cale> That sort of thing depends on how you engineer the interaction with the lower level stuff
11:42:33 <EvanR> how i?
11:42:37 <Cale> (rather than something that the FRP system internally is going to care about)
11:44:08 <Cale> Yeah, or how the author of whatever thing you use to start external timers does it.
11:44:13 <EvanR> it sounds like something uniquitous and low level enough that i dont want to be dealing with it
11:44:27 <Cale> Timers are I/O
11:44:43 <EvanR> yes not even having to think about timers would be nice
11:45:33 <EvanR> time is supposed to be built into the semantics
11:45:36 <Cale> Well, you only have to think about it once. If you're using them enough that you care about not starting too many.
11:45:38 <Cale> ..
11:45:50 <Cale> then you should take a moment to care about how you're doing that
11:46:04 <EvanR> if i wrote my own FRP i supposed id have to
11:46:26 <Cale> Reflex doesn't have a very refined intrinsic notion of time.
11:46:34 <Cale> Internally to reflex, time is totally ordered and that's all.
11:46:50 <EvanR> im not sure how time even factors into reflex at all?
11:46:51 <Cale> It might be continuous, it might be discrete, you can't know.
11:47:05 <EvanR> it seems to be just a thing to build a network of observers which react right now
11:47:52 <EvanR> when does time or its ordering get used
11:47:53 <Cale> Yeah, and this is intentional -- it's because different applications have different needs with respect to their model of time, while there's a lot of stuff you can do without specifying that.
11:48:43 <Cale> Well, because you can write accumulators and merge things and tell when one occurrence of an event happened before another.
11:50:13 <ab9rf> i remember one FRP implementation i was looking at did not handle simultaneously events well
11:50:13 <soLucien> hello guys ! It's me again , with my Graph question . So my question is how to represent a directed cyclic graph using Haskell  (i got some suggestions yesterday from erisco)
11:51:19 <squidz> What's yalls opinion on Kotlin vs Scala? For some reason scala always seems to be a big bag of everything, but I think it supports more functional programming than Kotlin
11:51:21 <soLucien> how can i construct/represent it , how do i walk it
11:51:21 <blackgnezdo> soLucien: FGL is an option.
11:51:24 <Cale> ab9rf: Reflex's stance is that any given Event occurs at most once at any moment in time
11:51:31 <ab9rf> soLucien: really that depends on what you plan to use the graph for. 
11:51:33 <glguy> squidz: That question is offtopic in #haskell
11:51:40 <johnw> soLucien: i'd use fgl as a place to start
11:51:57 <johnw> it makes working with adjaceny lists very easy
11:51:58 <squidz> glguy: I just wanted to know haskellers opinions, which is why I am asking
11:52:06 <glguy> squidz: Nonetheless it's offtopic
11:52:11 <ab9rf> squidz: my opinion is that you should use haskell :)
11:52:14 <EvanR> Cale: what about a diamond shape? e2 = fmap f e1 <> fmap g e1 ?
11:52:21 <squidz> ab9rf: that's clear
11:52:23 <Cale> ab9rf: But if someone really wanted their events to occur multiply at each moment, it may be possible to add that in the future with timeline transformers, which are a possibility that hasn't really been exploited yet.
11:52:44 <soLucien> ab9rf it's a task scheduler 
11:52:59 <soLucien> so task a dependsOn task b
11:53:07 <EvanR> Cale: so its more like a stream of occurrences, the left one happens, then the right
11:53:15 <ab9rf> soLucien: probably adjacency lists, then
11:53:20 <Cale> EvanR: Where <> is (Monoid a, Reflex t) => Monoid (Event t a)?
11:53:45 <EvanR> sure
11:53:56 <soLucien> ab9rf yes, adjacency lists is what i also thought of
11:53:56 <Cale> fmap f e1 and fmap f e2 are going to occur simultaneously every time
11:54:01 <Cale> er, sorry
11:54:08 <Cale> fmap f e1 and fmap g e1 are going to occur simultaneously every time
11:54:08 <EvanR> thats what id think
11:54:12 <soLucien> then erisco suggested using Maybe a -> a -> Bool
11:54:14 <ab9rf> Cale: i haven't looked much at reflex, so i'll have to do that (provided i don't kill myself watching tonight's election results)
11:54:29 <Cale> EvanR: and so that'll be the same as fmap (\x -> f x <> g x) e1
11:54:40 <EvanR> oh... it merges simultaneous
11:54:43 <Cale> or we could simply write that  fmap (f <> g) e1
11:55:03 <jedai> EvanR: Well the Monoid a constraint wouldn't make sense if it didn't ?
11:55:08 <Cale> ab9rf: I hope you stocked up on potable water
11:55:18 <soLucien> i don't see how this can be instantiated
11:55:19 <ab9rf> Cale: we have 30 gallons of distilled
11:55:31 <Cale> lol
11:55:32 <EvanR> jedai: the extra constraint right. but i was thinking Events were monoids apriori, but not in reflex
11:55:34 <ab9rf> Cale: also have almost a gallon of gin
11:55:57 <glguy> The election and coping mechanisms are better for #haskell-offtopic
11:56:05 <ab9rf> i'm done :)
11:56:18 <ab9rf> just trying to remind myself to look at reflex tomorrow
11:56:49 <soLucien> if i have 3 nodes "foo" dependsOn "bar" dependsOn "baz"
11:57:11 <Cale> ab9rf: Feel free also to join #reflex-frp -- ryantrinkle (among others) hangs out there but not here
11:57:24 <ab9rf> Cale: so noteed
11:57:47 <Cale> ab9rf: Also, just in case, the easiest way for you to get started is probably to grab reflex-platform
11:57:48 <soLucien> how can this be represented in Haskell ? a list of type Graph a = Maybe a -> a -> Bool
11:57:55 <Cale> https://github.com/reflex-frp/reflex-platform
11:58:05 <ab9rf> Cale: i saw that the other day, it's on a bookmark list of "thigns to do"
11:58:10 <Cale> okay, cool
11:58:16 <soLucien> how can i somehow store it in the memory ?
11:58:25 <EvanR> soLucien: i think graphs are commonly represented as an index of adjacencies
11:58:30 <EvanR> in haskell
11:58:34 <Cale> It's just because it otherwise takes a bunch of time and effort getting ghcjs set up, and that can save you a bunch of trouble
11:58:47 <soLucien> EvanR a list of adjacencies ? Would you give me an example ? 
11:58:52 <EvanR> not a list
11:58:55 <EvanR> that would be slow
11:59:01 <ab9rf> Cale: i'm vaguely looking at doing some fairly serious game development in haskell, and figure some sort of FRP will play into that in some useful way
11:59:19 <ab9rf> Cale: it's slow going because real life constantly intrudes
11:59:23 <Myrl-saki> EvanR: `Map k (k,a)` ?
11:59:41 <Cale> soLucien: Usually I like  Map Vertex (Set Vertex)  or Map Vertex (Map Edge Vertex)  or something like that
12:00:15 <Cale> ab9rf: Ali Abrar and I have been working on a hex-grid strategy game engine using Reflex
12:00:20 <EvanR> Map Vertex [Edge], Map Edge (Vertex,Vertex)
12:00:25 <Cale> (also Dan Haraj, I shouldn't forget :)
12:00:30 <EvanR> for undirected
12:00:37 <soLucien> Nothing -> "foo" -> True , Just "foo" -> "bar" -> False , Just "bar" -> "baz" ?
12:01:04 <infandum> I have x :: Maybe a and f :: a -> IO (Maybe a). How can I bind them? x >>= f?
12:01:07 <EvanR> i did not understand this Maybe function formulate you all were discussing
12:01:13 <soLucien> me neither
12:01:14 <Cale> ab9rf: My first hope is to remake XBattle, which is a *really* old game for the X Window System
12:01:17 <infandum> that is, the Maybe (Maybe a) would resolve
12:01:28 <kadoban> Is there a common way to see where <<loop>> originates, for simple cases?
12:01:47 <Cale> and we've got it as far as needing some kind of backend to make the multiplayer work
12:02:00 <Myrl-saki> infandum: You can't do that. Check the types.
12:02:00 <EvanR> soLucien: a graph is a set of vertexes and a set of edges between them. you can then *index* these sets, by making Data.Maps in whichever way you will want to do fast lookups
12:02:01 <soLucien> EvanR i don't need to represent edges , because they have no value
12:02:16 <EvanR> well, the edges are there nonetheless
12:02:23 <Myrl-saki> :t (f :: a -> IO (Maybe a)) <$> (x :: Maybe a)
12:02:25 <infandum> Myrl-saki: Yeah, but is there a way around it?
12:02:26 <lambdabot> error:
12:02:26 <lambdabot>     • Couldn't match expected type ‘Maybe a1’ with actual type ‘Expr’
12:02:26 <lambdabot>     • In the second argument of ‘(<$>)’, namely ‘(x :: Maybe a)’
12:02:30 <infandum> I know bind won't work
12:02:37 <Myrl-saki> :t fmap (f :: a -> IO (Maybe a)) (x :: Maybe a)
12:02:39 <lambdabot> error:
12:02:39 <lambdabot>     • Couldn't match expected type ‘Maybe a1’ with actual type ‘Expr’
12:02:39 <lambdabot>     • In the second argument of ‘fmap’, namely ‘(x :: Maybe a)’
12:02:46 <Myrl-saki> :t fmap
12:02:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:03:00 <Myrl-saki> Eh...
12:03:17 <Myrl-saki> @let f :: a -> IO (Maybe a)
12:03:19 <lambdabot>  .L.hs:239:1: error:
12:03:19 <lambdabot>      The type signature for ‘f’ lacks an accompanying binding
12:03:19 <lambdabot>        (The type signature must be given where ‘f’ is declared)
12:03:26 <Myrl-saki> @let f :: a -> IO (Maybe a); f = undefined
12:03:29 <lambdabot>  Defined.
12:03:45 <Myrl-saki> @let x :: Maybe a; x = undefined
12:03:47 <lambdabot>  Defined.
12:03:52 <Myrl-saki> :t f <$> x
12:03:53 <Cale> Perhaps I'll grab Will Fancher's https://github.com/ElvishJerricco/reflex-websockets thing and see how well he's done with that :)
12:03:54 <lambdabot> error:
12:03:55 <lambdabot>     Ambiguous occurrence ‘f’
12:03:55 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
12:03:59 <Myrl-saki> my god.
12:04:12 <Myrl-saki> @let floof :: a -> IO (Maybe a); floof = undefined
12:04:15 <lambdabot>  Defined.
12:04:16 <Cale> :t (<$>) -- perhaps you meant this?
12:04:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:04:22 <Myrl-saki> :t floof <$> x
12:04:24 <lambdabot> error:
12:04:24 <lambdabot>     Ambiguous occurrence ‘x’
12:04:24 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
12:04:33 <Tuplanolla> What a nice module.
12:04:34 <MarcelineVQ> :>
12:04:39 <Myrl-saki> ihatelife
12:04:41 <infandum> it's amazing that x is previously defined
12:04:48 <Myrl-saki> @let bax :: Maybe a; bax = undefined
12:04:51 <lambdabot>  Defined.
12:04:52 <Myrl-saki> :t floof <$> bax
12:04:54 <lambdabot> Maybe (IO (Maybe a))
12:04:56 <Cale> infandum: It's not that amazing
12:04:56 <EvanR> > replicate 3 x
12:04:57 <Myrl-saki> Okay, good.
12:04:59 <lambdabot>  error:
12:04:59 <lambdabot>      Ambiguous occurrence ‘x’
12:04:59 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
12:05:02 <Cale> @undefine
12:05:03 <lambdabot> Undefined.
12:05:09 <Cale> > foldr f x [1,2,3]
12:05:12 <lambdabot>  f 1 (f 2 (f 3 x))
12:05:12 <Myrl-saki> did you just...
12:05:17 <Myrl-saki> :t floof <$> bax
12:05:19 <lambdabot> error:
12:05:19 <lambdabot>     • Variable not in scope: floof :: a0 -> b
12:05:19 <lambdabot>     • Perhaps you meant ‘floor’ (imported from Prelude)
12:05:22 <Myrl-saki> ;~;
12:05:23 <Cale> hah, sorry
12:05:23 <infandum> haha
12:05:28 <Cale> use let expressions :P
12:05:32 <Myrl-saki> Yeah.
12:05:36 <Myrl-saki> :t sequence
12:05:39 <Myrl-saki> :t traverse
12:05:39 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
12:05:40 <EvanR> develop this grand magnum opus in PM and get back to us
12:05:41 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:05:43 <Myrl-saki> Okay.
12:05:51 <Cale> :t (?f :: a -> IO (Maybe a)) <$> (?x :: Maybe a)
12:05:52 <infandum> Myrl-saki: So I would need a monad transformer?
12:05:53 <lambdabot> error:
12:05:53 <lambdabot>     • Unbound implicit parameter ?f::a1 -> IO (Maybe a1)
12:05:53 <lambdabot>         arising from a use of implicit parameter ‘?f’
12:05:54 <Myrl-saki> infandum: ^
12:06:00 <Cale> tsk, really?
12:06:08 <ab9rf> Cale: i remember XBattle
12:06:20 <Cale> ab9rf: :D
12:06:26 <Myrl-saki> infandum: Nah.
12:06:31 <Myrl-saki> infandum: Just traverse.
12:06:38 <Cale> ab9rf: So yeah, we've got the fluid flowing around on a hex grid and you can direct it continuously
12:06:48 <Myrl-saki> @let floof :: a -> IO (Maybe a); floof = undefined
12:06:50 <lambdabot>  Defined.
12:06:55 <Myrl-saki> @let bax :: Maybe a; bax = undefined
12:06:56 <lambdabot>  Defined.
12:07:00 <Myrl-saki> :t traverse floof bax
12:07:02 <lambdabot> IO (Maybe (Maybe a))
12:07:05 <Myrl-saki> infandum: ^
12:07:30 <sm> ooh, I also remember xbattle
12:07:36 <Myrl-saki> infandum: No way to remove IO, btw.
12:07:52 <Myrl-saki> There's no escape from IO.
12:08:07 <Cale> :t let ff = undefined; xx = undefined in (ff :: a -> IO (Maybe a)) <$> (xx :: Maybe a)
12:08:09 <lambdabot> Maybe (IO (Maybe a))
12:08:22 <infandum> ugh
12:08:32 <infandum> ooooh
12:08:38 <infandum> huh, ok
12:08:40 <Myrl-saki> :t (ff :: a -> IO (Maybe a)) <$> (xx :: Maybe a)
12:08:42 <lambdabot> error:
12:08:42 <lambdabot>     • Variable not in scope: ff :: a1 -> IO (Maybe a1)
12:08:42 <lambdabot>     • Perhaps you meant one of these:
12:08:43 <Cale> infandum: Sorry, what was your original question?
12:08:43 <infandum> :t traverse
12:08:46 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:09:03 <Myrl-saki> Yeah, really requires a let binding. TIL.
12:09:12 <Cale> infandum: Usually when you have something of type IO t, and you want something of type t, the answer is "you need to execute that IO action"
12:09:28 <Myrl-saki> Oh cool.
12:10:03 <infandum> Cale: I don't want t, I want IO t
12:10:13 <infandum> it's just inside of another monad
12:10:14 <Cale> infandum: and the basic way to do that is just to write another IO action using a do-block, and writing   v <- x   which means "execute the action x :: IO t, and call its result v :: t"
12:10:24 <Myrl-saki> infandum: Yeah, what I demonstrated earlier does what you said.
12:10:26 <Cale> ah, which monad?
12:10:41 <Cale> (not all monads are alike)
12:10:44 <Myrl-saki> infandum: There's also `sequence` to swap the monads.
12:10:49 <Myrl-saki> :t sequence
12:10:51 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
12:11:03 <infandum> I wanted (Maybe a -> (a -> IO (Maybe a)) -> IO (Maybe a))
12:11:05 <Cale> If you have Maybe (IO t), for example, probably you just want to case
12:11:13 <Myrl-saki> Oh
12:11:20 <Myrl-saki> infandum: Then you could join the inner.
12:11:25 <infandum> yeah
12:11:40 <Myrl-saki> Anyways
12:11:42 <infandum> but it's a function for the second argument
12:11:49 <Myrl-saki> In that case, I'd rather do something like...
12:12:06 <Myrl-saki> :t maybe floof return bax
12:12:08 <lambdabot> a -> IO (Maybe a)
12:12:09 <infandum> which is messing me up, as I usually would just bind, but the two layers are getting to me
12:12:15 <Cale> (\mx f -> case mx of Nothing -> return Nothing; Just x -> f x)
12:12:17 <Myrl-saki> Errr
12:12:18 <Cale> :t (\mx f -> case mx of Nothing -> return Nothing; Just x -> f x)
12:12:19 <lambdabot> Monad m => Maybe t -> (t -> m (Maybe a)) -> m (Maybe a)
12:12:25 <soLucien> okay EvanR so let's say i use Map Vertex [Edge], Map Edge (Vertex,Vertex) . I want to represent the cycle "a" -> "b" -> "c"
12:12:31 <infandum> haha that was the last case scenario
12:12:38 <infandum> manually writing out the cases
12:12:49 <Cale> Always do that first, then simplify it
12:13:03 <infandum> :(
12:13:05 <Cale> :t (\f -> maybe (return Nothing) f)
12:13:06 <lambdabot> Monad m => (a -> m (Maybe a1)) -> Maybe a -> m (Maybe a1)
12:13:10 <infandum> but...it's pretty when it's short
12:13:20 <infandum> yeah
12:13:23 <infandum> that'll do
12:13:24 <infandum> haha
12:13:25 <infandum> thanks
12:13:47 <Cale> Almost every time I use the maybe function though, I end up replacing it with a case expression later.
12:14:08 <infandum> ah, I started going the opposite way
12:14:10 <Cale> Because one or both of the branches gets more complicated than what it was originally, and it ends up being unreadable
12:14:11 <Myrl-saki> Anyways, traverse does what you need.
12:14:18 <infandum> I used to do case before I discovered the maybe function
12:14:25 <infandum> thanks
12:14:25 <infandum> !
12:14:34 <Cale> Well, if the code isn't going to change much
12:14:34 <soLucien> then it would be something like Map [a (a,b) , b (b,c) ]
12:14:37 <Myrl-saki> :t maybe (return Nothing)
12:14:39 <lambdabot> Monad m => (a -> m (Maybe a1)) -> Maybe a -> m (Maybe a1)
12:14:42 <Myrl-saki> :t traverse
12:14:44 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:14:46 <Cale> Then maybe or something like it would be tidier
12:14:51 <Cale> (perhaps traverse, sure)
12:15:03 <Myrl-saki> Oh.
12:15:08 <Cale> But yeah, it depends on what kind of code it is :)
12:15:13 <Myrl-saki> Cale: ++
12:15:46 <Myrl-saki> I was thinking about how it'd be nive to have a joinMap, then I realized I'm stupid.
12:15:49 <Myrl-saki> nice*
12:16:00 <Cale> :t (=<<)
12:16:01 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:16:08 <Myrl-saki> exactly. xD
12:16:30 <newscripter> After thinking about it, since functional is incredibly well suited for multi-threading applications, the overhead is not too bad. I am starting to see the virtues of functional :)
12:17:23 <johnw> functional is beautiful
12:17:27 <Cale> newscripter: The thing is, all the advantages of functional programming that make it possible to manage multithreaded applications are also advantages when it comes to understanding and debugging single threaded applications
12:17:31 <Myrl-saki> johnw: your beautiful.
12:17:37 <newscripter> I was thinking too linearly. If you were to create an enormous game and constantly input one massive array every frame, the overhead is obv ridiculous
12:17:37 <sbrg> no, my beautiful
12:18:55 <Myrl-saki> sbrg: where beautiful
12:21:40 <EvanR> newscripter: well, its just that arrays dont give you the structure to do efficient immutable updates
12:23:03 <EvanR> with a tree, you only need to copy the nodes on the path to the part you change, and for some kinds of trees, the max depth is really low
12:25:04 <joco42> is there something like this for haskell ? https://tonyhb.gitbooks.io/redux-without-profanity/content/normalizer.html
12:25:12 <joco42> how is this different from lenses?
12:25:16 <joco42> is it any better ?
12:25:35 <joco42> can lenses subsititute for a normalizer ?
12:26:40 <joco42> https://hackage.haskell.org/package/happstack-data-6.0.1/docs/Happstack-Data-Normalize.html
12:28:42 * hackagebot simple-effects 0.5.0.1 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.5.0.1 (darwin226)
12:30:01 <johnw> joco42: so this is rendering a data set into a certain normal form?
12:30:09 <johnw> this is not the same as lenses
12:30:36 <johnw> but, I could see it being used profitably in conjunction with lenses
12:30:40 <joco42> but they somehow solve the same problem right ?
12:31:02 <johnw> no
12:31:21 <johnw> lenses give you a way of visualizing a construct as (part of interest, parts not of interest)
12:31:29 <joco42> i kinda understand what problem lenses solve
12:31:35 <johnw> normalizer is rewriting the data set into normal form
12:32:23 <johnw> for that to be equivalent to lenses, you'd need the process to be bidirectional
12:32:39 <johnw> and even then, it's just one example of a "view", in order to define "part of interest" differently
12:33:10 <johnw> think of it as the difference between accessing a list element, and sorting the list
12:33:11 <joco42> what is the problem that normalizer solves ? that lenses cannot ?
12:33:19 <joco42> in practice ?
12:33:36 <johnw> normalizer is just shuffling the data around to make certain queries easier
12:33:42 * hackagebot convert-annotation 0.5.0.0 - Convert the annotation of a gene to another in a delimited file using a variety of different databases.  https://hackage.haskell.org/package/convert-annotation-0.5.0.0 (GregorySchwartz)
12:34:00 <johnw> it's the same reason why you use these normal forms in databases: query efficiency
12:34:47 <joco42> hmm
12:35:24 <joco42> lenses are good if i need to update a deeply nested state
12:35:30 <johnw> yes
12:35:37 <joco42> isnt that what normalizer solves too?
12:35:38 <johnw> it gives you a way of "addressing" the deeply nested part
12:35:46 <johnw> normalizer is helping you query, not update
12:36:18 <joco42> i think here it helps both https://tonyhb.gitbooks.io/redux-without-profanity/content/normalizer.html
12:36:37 <johnw> where in that post does it update?
12:36:39 <joco42> not sure thought
12:36:44 <joco42> need to check
12:36:45 <johnw> i see only queries
12:37:49 <joco42> yes
12:37:55 <joco42> true
12:40:09 <joco42> need to think about this... thanks johnw , let's get back to this, after i figured out what i really wanna ask
12:40:19 <johnw> yeah, I guess that helps too :)
12:42:31 <joco42> yeah, i think i know it, if the data structure is cyclic...
12:42:54 <joco42> for example many to many
12:43:51 <joco42> anyway, i am bycicle...
12:43:57 <joco42> too tired
12:44:00 <joco42> need to sleep
12:44:16 <joco42> bicycle, i mean
12:44:26 <laudiacay> b 2
12:44:54 <kuribas> lenses for datatypes is like XPath for XML
12:45:39 <johnw> can XPath "write back" to the XML document?
12:46:21 <shapr> XPath is really for selecting, XSLT is for transforming XML
12:46:40 <johnw> yeah, I'd say XPath is more akin to Getters, not Lenses
12:47:04 <johnw> what they do share is the compositional language for building up the accessor
13:18:44 * hackagebot regex-do 1.6 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-1.6 (procione)
13:21:51 <nitrix> Is there such thing as data Something = Foo | Bar Int | Baz,  class Random Something where random :: Something ?
13:22:02 <nitrix> Assuming there are Random instances for Something and Int.
13:22:46 <glguy> Is your goal to implement this comic? https://xkcd.com/221/
13:22:50 <nitrix> It seems simple enough that there's probably a library doing this.
13:22:59 <geekosaur> nitrix, Arbitrary?
13:23:13 <glguy> instance Random Int where random = 4
13:23:14 <nitrix> geekosaur: More like just the random generation part of quickcheck.
13:23:21 <nitrix> It's for genetic programming.
13:23:22 <geekosaur> exactly
13:23:37 <nitrix> geekosaur: Is there a standalone version of it though?
13:23:50 <geekosaur> not so far as I am aware
13:24:45 <nitrix> It's a good starting point still. I appreciate :)
13:25:25 * geekosaur wouldn't consider QC for Arbitrary too onerous a dependency
13:25:34 <nitrix> glguy: I also now see where the joke comes from. Clearly it doesn't be very random if it had type :: Something :P 
13:25:49 <nitrix> *wouldn't.
13:28:44 * hackagebot simple-effects 0.5.0.2 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.5.0.2 (darwin226)
13:33:22 <nitrix> geekosaur: glguy How does one implements `shrink`?
13:33:52 <nitrix> http://lpaste.net/332296
13:33:58 <geekosaur> if you're not actually using QC, probably undefined would do?
13:34:13 <geekosaur> shrink is about minimizing test cases, not actually part of item selection
13:34:45 <nitrix> I see. Might as well learn about it now that I asked though.
13:35:11 <geekosaur> basically you see it there though, and I think there may be a default for e.g. Enum
13:35:20 <nitrix> Is see that elements are eliminated from the set of possible solutions, but wouldn't the ordering matter here?
13:36:39 <nitrix> What if `False` is being eliminated first, you'd obtain `[]` skipping entirely `True`.
13:37:30 <nitrix> The ordering seems very sensible. How does it work? What is it based on?
13:38:11 <geekosaur> http://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html#v:shrink
13:38:56 <geekosaur> I am not sure the Ordering one is actually a good shrinker
13:38:58 <nitrix> The tree example provided doesn't help simplying the concept.
13:39:36 <nitrix> geekosaur: Those two are extracted from QC's implementation.
13:39:56 <geekosaur> also it depends on what you want. the default doesn't shrink, which means you would run more test cases than are strictly necessary but is not necessarily wrong/bad
13:40:02 <geekosaur> I figured
13:40:21 <geekosaur> I feel like someone said "eh, good enough"
13:40:51 <nitrix> As in, if the LT case works, presumably the GT case must work too as they're opposites.
13:41:22 <jle`> nitrix: there's the random package
13:41:24 <nitrix> (I can see a problem with that. I've written incorrect broken asymetric instances of Ord before)
13:41:26 <jle`> that offers a Random typeclass
13:41:43 <jle`> and i think that there are also packages that can auto-derive instances of Random or Arbitrary
13:42:30 <jle`> nitrix: the random package is pretty standard, and has random :: (Random a, RandomGen g) => g -> (a, g) or something like that
13:43:12 <geekosaur> jle`, I don't think it can generate for an arbitrary ADT though, just Enum
13:44:25 <nitrix> I don't even think it relies on Enum, I see no constraint.
13:45:05 <nitrix> jle`: That's helpful too. Appreciated.
13:46:39 <jle`> should be possible to do it for an arbitrary ADT w/ GHC.Generic
13:47:46 <kadoban> That was interesting ... using 'stack runghc' ran a thing, it was taking forever and too much memory so I killed it, and the ghc processed just kept chugging along.
13:53:25 <isd> Hey all. I'm dealing with a file format that can contain cyclic and/or overlapping, which means that traversing the data structure in it can be superlinear time in the size of the binary blob, creating a risk of DoS vulnerabilities. The standard approach with this format is to keep track of how many bytes have been accessed and start throwing errors when the number exceeds some limit.
13:53:45 * hackagebot pinboard 0.9.11 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.11 (jonschoning)
13:53:47 * hackagebot tianbar 1.2.1.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.2.1.0 (AlexeyKotlyarov)
13:55:10 <isd> I have a mostly-written module than handles this via a MonadCursor type class that can be used to deduct values from a quota, and uses a MonadThrow instance to stop the computation when the limit is exceeded. But, before I continue re-inventing the wheel I wanted to see if there is already a decent library out there that does something similar. I didn't find anything searching hackage. Does anyone of something like that?
13:55:44 <isd> *know of
13:56:44 <shapr> isd: sounds interesting, is your code on github?
13:57:11 <shapr> isd: I know lambdabot's haskell plugin has computation limits, but that's the only thing that comes to mind
13:57:24 <isd> shapr: this module isn't yet; the codebase is but I haven't pushed the relevant bit yet.
13:58:29 <isd> shapr: thanks; I will have a look to see how lambdabot does this. I bet it's just a simple timeout or something, but worth a look
14:05:32 <geekosaur> it's a timeout,yes. mueval package
14:05:44 <geekosaur> I don't think it gives you a quota mechanism
14:07:05 <isd> geekosaur: thanks; it looks like I'm perhaps not re-inventing something established then. That's a first for haskell.
14:07:26 <isd> Maybe I'll make it a separate package then.
14:07:58 <isd> (first for generic libraries rather, not applications)
14:11:01 <ezyang> Does anyone know how to, in Tasty, allocate n resources based on the passed in -j parameter? 
14:28:40 * mmaruseacph2 looks forward to isd's package as he needs some type of quota for some resources
14:29:35 <isd> mmaruseacph2: will let you know.
14:40:22 <sbrg> ezyang: Maybe getNumCapabilities?
14:42:03 <amx> ezyang: AFAICT you can get only get numThreads from IngredientOptions
14:42:07 <MarcelineVQ> ezyang: not really sure how to use tasty but it seems like you can use askOption, or possibly lookupOption. there's an example here allthough it's not quite what you're after https://ro-che.info/articles/2013-12-20-tasty-custom-options.html
14:43:20 <ezyang> the trouble with askOption is I'm already in the TestTree at that point, too late to allocate resources 
14:45:17 <isd> mmaruseacph2, shapr: haven't pushed anything yet, but it will live here soonish: https://github.com/zenhack/haskell-quota
14:47:10 <MarcelineVQ> ezyang: Can you query with a first group then allocate for the next?
14:48:48 <ezyang> ugh mutable state :^) 
14:49:31 <MarcelineVQ> the suggestions I'm seeing are ioref :(
14:49:39 <ggVGc> ezyang: how do you signal between threads without mutation!
14:50:42 <ezyang> ggVGc: Well, the defaultMain API could have had the foresight to let me see the options before it started running... 
14:50:51 <ezyang> I ended up just reimplementing a test runner from scratch 
14:54:00 <sbrg> ezyang: you can't use getNumCapabilities and then pass that on? 
14:54:14 <ezyang> I could, but if the user specifies a different -j value then I won't get it 
14:54:31 <sbrg> ah, i thought it reflected the value of -j
15:01:46 <joncol> Hi, I'm working with parallelizing a ray tracer using repa. To be able to show progress, I'm now "chunking" the ray tracing into individual 32x32 pixel `D`-arrays. I'm putting them in a strict Map (Data.Map.Strict) to be able to stitch all of them together to form a complete image at the end. My current problem is that it seems that most of the work is not being done until the final stitching-together, 
15:01:52 <joncol> which somewhat defeats the purpose of my progress bar. Shouldn't all the work be done when I call `computeUnboxedP` (repa) and "extract" the result from the monadic return value, and put it in my map?
15:03:22 <sbrg> joncol: sounds like you aren't doing any evaluation until you force the contents of the map. I think Data.Map.Strict is strict in the values
15:03:32 <geekosaur> joncol, one thing to watch out for is to make sure you are using the operations from Data.Map.Strict and not just the type. there is no difference between the types. the only difference is in the functions
15:04:00 <joncol> I'm only importing stuff from Data.Map.Strict.
15:04:02 <geekosaur> another might be that "strict" is only up to the first constructor. Control.Deepseq may be your friend here
15:04:09 <joncol> Ahh
15:04:18 <joncol> Is it easy to use?
15:05:45 <sbrg> you could also possibly use BangPatterns to force it before inserting it into the map
15:05:49 <geekosaur> sorry, Control.DeepSeq. the deepseq combinator is like seq but forces full evaluation instead of only to the first constructor
15:08:33 <joncol> sbrg: A bang pattern before my Map argument didn't seem to help.
15:08:41 <sbrg> probably the same problem as before
15:08:46 <sbrg> insufficiently strict evaluation
15:09:46 <joncol> I'll try deepseq
15:12:49 <joncol> I'm unfamiliar with seq. How would a call look (to deepseq), when what I currently have is something like: img <- computeUnboxedP blabla; return $ M.insert (x, y) img acc (I'm in a foldM)
15:13:48 * hackagebot safe 0.3.10 - Library of safe (exception free) functions  https://hackage.haskell.org/package/safe-0.3.10 (NeilMitchell)
15:13:55 <mmaruseacph2> return $! ...
15:14:14 <mmaruseacph2> actually, wait, if the Map is strict, I don't think that helps
15:14:43 <joncol> mmaruseacph2: No, it didn't
15:15:42 <mmaruseacph2> so you want to force the img
15:15:46 <joncol> yes
15:16:01 <mmaruseacph2> hmm, I'd try with return $ img `seq` M.insert ...
15:16:12 <mmaruseacph2> or return (img `seq` M.insert ...)
15:16:27 * mmaruseacph2 needs to remind himself the priority of operators in this case
15:16:54 <joncol> Damn, no instance of Control.DeepSeq.NFData for the U-Array...
15:17:03 <mmaruseacph2> :(
15:17:47 <mmaruseacph2> try force img
15:18:01 <mmaruseacph2> so, return $ M.insert (x, y) (force img) acc
15:18:19 <joncol> That also requires a NFData instance, right?
15:18:23 <boxscape> Not that this has any practical use, but do you think that an Eq instance of "data Void" should always return True, always return False, or always be bottom?
15:18:24 <joncol> Hoogle says so
15:18:39 <mmaruseacph2> actually, force2 if it's 2D
15:19:09 <mlehmk> Isn't there already the trivial type ()?
15:19:11 <mmaruseacph2> force2    :: Elt a => Array DIM2 a -> Array DIM2 a
15:19:42 <boxscape> mlehmk: was that in reply to me?
15:19:59 <mmaruseacph2> wait, that's an old type :(
15:20:06 <mmaruseacph2> boxscape: I think so
15:20:08 <mlehmk> why Void? An Eq to Void should error to my feeling. Or a Maybe Void being Nothing
15:21:12 <boxscape> mlehmk: Not sure what this has to do with Maybe Void
15:21:32 <monochrom> boxscape: In an ideal world, I would make it top. Consider: bottom is when neither True nor False is a right answer. The dual is that top is when both True and False are right answers. True is a right answer because "forall x::Void. x==x" is vacuously true. False is a right answer because "forall x::Void x/=x" is vacuously true.
15:22:13 <boxscape> yeah, that sounds reasonable
15:22:50 <mmaruseacph2> joncol: try now https://hackage.haskell.org/package/repa-3.4.1.2/docs/src/Data.Array.Repa.Eval.html#now
15:23:15 <mmaruseacph2> or deepSeqArray
15:23:37 <mmaruseacph2> I don't see them requiring NFData instance
15:23:48 <joncol> mmaruseacph2: ahh, nice! I will
15:25:32 <mlehmk> can you equal a Vacuous truth with a truth?
15:25:34 <hpc> both of those break the expectations of an Eq instance
15:26:20 <hpc> (it's not a law because floating point numbers break it even harder, but still)
15:26:39 <Koterpillar> how does the first one break anything?
15:26:47 <mlehmk> Considering it True would give it a meaning
15:26:57 <joncol> mmaruseacph2: Very strange, no difference still.
15:27:34 <mlehmk> There is no meaning inferred by comparing Void instances with each other
15:27:35 <hpc> they both break (x == y) = not (x /= y)
15:27:49 <lyxia> Floating point numbers are an exception IMO.
15:27:55 <mlehmk> well, thankfully the Void type has no values
15:28:06 <lyxia> I mean it's fine to call that a law.
15:28:15 <boxscape> hpc: since there are no Void values, isn't that law still true for all possible inputs?
15:28:25 <lyxia> Double and Float are outlaws in so many ways
15:28:43 <hpc> lyxia: oh, also it's not documented as one in haddock
15:29:04 <hpc> which was the real reason, i just assume it's because they can't just say "except for floating point" with a straight face
15:30:47 <mlehmk> Well, there is .0 and -.0, they are not exactly equal but meant to be equal. This is not a problem. The problem would be NaN, which always satisfies the condition of x /= y even if x and y are an identical NaN value
15:30:59 <mlehmk> Although, I guess that wasn't meant
15:31:16 <hpc> no, those are it
15:31:25 <hpc> you can write them in ways that more obviously break the laws
15:31:32 <hpc> > let x = (0/0) in x == x
15:31:34 <lambdabot>  False
15:31:41 <mlehmk> although, they don't break the law (x == y) = not (x /= y)
15:31:44 <hpc> that breaks reflexivity, which i guess would have been another law
15:31:51 <mlehmk> ohh, yes
15:32:04 <mlehmk> the (x == x) = True
15:32:07 <boxscape> the hackage void package apparently has _ == _ = True
15:32:59 <mlehmk> Well isNan x = not (x == x)
15:33:36 <younder> Nu function over a  poset can be described by recursion unless it has an upper bound. A derived result from Domain theory.
15:33:41 <mlehmk> that doesn't even make sense, but works
15:33:43 <mmaruseacph2> joncol: sorry, I never played with repa, just random guesses from looking at the lib
15:34:13 <joncol> mmaruseacph2: Thanks anyway. I'll sleep on it :)
15:34:37 <mlehmk> Haskell has recursive functions without an upper bound
15:34:51 <mlehmk> they generate infinite lists for example
15:35:22 <younder> mlehmk, but you get a finite number of elements with take fes
15:35:35 <ezyang> I finished this cool little library that reuses a GHCi session to run multiple scripts on the same GHC interpreter, saving about 0.5s for each script 
15:35:58 <ezyang> unfortunately, it never reaps the GHC processes in the end :< 
15:38:25 <mlehmk> ohh... quantum mechanics is just lazy evaluation?
15:38:34 <monochrom> No.
15:38:34 <mlehmk> just being funny
15:38:41 <monochrom> OK haha.
15:39:03 <mlehmk> but somehow... that might explain the collapse of the wave function
15:39:48 <monochrom> No, you would then have to explain where did evaluation come from.
15:40:12 <EvanR_> the prime evaluation at the beginning of time
15:40:18 <mlehmk> although for the world inside itself it doesn't need the evaluation as all possible states are just possible
15:40:40 <mlehmk> for every possible state it seems that evaluation has happened, even if no evaluation happens at all. It's indifferent
15:40:48 <EvanR_> where the original RealWorld value came in
15:41:54 <ertes> you know what happened to homotopy theory when we stripped away the…  you know…  actual "continuous function" bit?  i bet if we strip quantum mechanics of vectors and linear operators, we will finally understand that our universe is made of haskell
15:42:35 <mlehmk> or just being descibable in functions
15:42:47 <EvanR_> lets hope someone doesnt try to evaluate bottom somewhere in the universe
15:42:49 <monochrom> But I don't know what happened to homotopy theory when stripping away continuous functions.
15:43:03 <mlehmk> though I wonder how the quantum monoid behaves, it isn't quite the monoid as time is not happening as that
15:43:46 <ertes> monochrom: it became really hott
15:43:49 * hackagebot ginger 0.3.7.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.7.0 (TobiasDammers)
15:44:00 <mlehmk> you can't say that a state is exactly that one state and the next state for the next planck second is calculated from it... the universe doesn't work like that
15:44:02 <EvanR_> no, hott has continuous functions
15:44:20 <ertes> it has…  something like that…
15:44:40 <EvanR_> its even more continuous than usual
15:44:46 <EvanR_> infinity functors
15:45:19 <mlehmk> not really, the photon is what makes time happen
15:45:40 <EvanR_> mlehmk: enough nonsense
15:45:43 <mlehmk> okay
15:47:35 <mlehmk> where's the hate?
15:47:41 <ertes> i can't wait for the day physicists chase arrows instead of solving differential equations…  not because arrows are more elegant, but because we can finally make fun of them for abusing Hask to explain the universe
15:48:09 <mlehmk> Haskell is just an application of language
15:49:04 <EvanR_> they already do
15:49:39 <EvanR_> https://ncatlab.org/nlab/show/higher+category+theory+and+physics
15:50:17 <daedra_> Hello everyone. I'm trying to understand the recursive factorial function which is like this:
15:50:21 <daedra_> factorial :: Int -> Int                                                          
15:50:21 <daedra_>  14 factorial 0 = 1                                                                  
15:50:21 <daedra_>  15 factorial n = n * factorial (n - 1)  
15:50:41 <daedra_> My doubt here is, where is the value stored after multiplicating it?
15:50:51 <Koterpillar> why do you need to store it?
15:50:55 <daedra_> I mean, if n = 4, then we would have:
15:51:06 <daedra_> factorial 4 = 4 * factorial (4 - 1)
15:51:12 <daedra_> Where is the 12 stored?
15:51:16 <Koterpillar> why do you need to store it?
15:51:18 <daedra_> Or how does Haskell manage this?
15:51:20 <boxscape> it's not, just keep expanding it
15:51:35 <ertes> daedra_: think in terms of rewriting expressions, not storing memory
15:51:46 <daedra_> I don't want to store it, I just want to know where is Haskell storing the value.
15:51:57 <ezyang> Is there a way to turn of GHCi's handling of SIGINT, so that ctrl-c kills it? 
15:52:07 <Koterpillar> daedra_: something tells me you aren't interested in GHC implementation details
15:52:24 <daedra_> I am, interested.
15:52:28 <EvanR_> daedra_: its in memory somewhere, unless its been optimized away
15:52:32 <daedra_> But I'm trying to understand it works.
15:52:41 <Koterpillar> daedra_: is there a language you're more familiar with than Haskell?
15:52:50 <daedra_> C
15:52:59 <ertes> daedra_: it uses a low-level representation of what is basically the expression you are evaluating, and it substitutes parts of it by results as needed
15:53:36 <daedra_> So it basically creates a variable to represent it?
15:53:37 <ertes> (fact 4) becomes (4 * fact 3), which becomes (4 * 3 * fact 2), which becomes …
15:53:45 <daedra_> Ohhhh
15:53:47 <daedra_> I see.
15:53:56 <ertes> daedra_: the code produced by GHC is *very* different from what a C compiler would produce
15:54:09 <ertes> it uses a highly efficient representation for this kind of evaluation strategy
15:54:16 <daedra_> I get it... n = 4 would become n = 4 * 3 after the 2nd iteration and so on?
15:54:31 <Koterpillar> they are different n's
15:54:33 <ertes> no, it literally stores the expression in this case
15:54:53 <ertes> (which is why this is actually a rather poor implementation of the factorial function)
15:55:16 <mlehmk> well, factorial 4 = 4 * factorial 3, then factorial 3 = 3 * factorial (3 - 1), then factorial 4 = 4 * 3 * factorial 2, then factorial 2 = ... a.s.o.
15:55:42 <ertes> daedra_: imagine the compiler literally writing down the expression and then repeatedly substituting parts of it
15:55:45 <mlehmk> at the end you get factorial 4 = 4 * 3 * 2 * 1 * 1
15:55:56 <EvanR_> daedra_: keyword you might be interested in searching is graph reduction machine
15:56:20 <EvanR_> its applicable to the recursive factorial function example
15:56:22 <mlehmk> although the runtime might already substitute constant expressions like 4 * 3 = 12
15:56:27 <geekosaur> ezyang, I don't think so. you may be able to use System.Posix.Signals to reset SIGINT to SIG_IGN, but I don't know if it re-establishes its handler when it shows the prompt
15:56:28 <isd> My head is starting to go fuzzy trying to do type-jigsaw. I've written something that has MonadState and MonadThrow constraints on it, and I want to run this through a concrete monad stack jusing using ExceptT and StateT, with Identity as the base monad. And I'm having a hard time figuring out how to combine them. Um... help?
15:56:33 <boxscape> I might just be conflating high-level with low-level stuff here, but since (*) is infixl, wouldn't it multiply 4*3 before expanding the factorial 2 call?
15:56:36 <geekosaur> (to recover in case the expression changed the handler)
15:56:44 <daedra_> Oh, that makes it clear for me. :)
15:56:59 <daedra_> Thanks everyone for the help, and I will check that out EvanR_
15:57:01 <ertes> boxscape: the infixl-ity of (*) is irrelevant here
15:57:04 <daedra_> Thanks. :)
15:57:04 <EvanR_> boxscape: it cant
15:57:08 <boxscape> okay, fair enough
15:57:13 <Koterpillar> boxscape: no, it's 4 * (everything else)
15:57:17 <boxscape> ahh
15:57:20 <boxscape> yeah, okay
15:57:21 <Koterpillar> with explicit brackets
15:57:31 <EvanR_> 4 * (3 * (2 * ...
15:57:31 <mlehmk> I thought multiplication went left to right
15:57:37 <Koterpillar> an optimizer might, if it knows that (*) is associative
15:57:37 <ertes> boxscape: infixl means that if you *write* (in source code) something like x * y * z, the compiler will read that as (x * y) * z
15:57:44 <Koterpillar> mlehmk: then put brackets back in
15:57:54 <mlehmk> ahh!
15:58:01 <mlehmk> there's implicit brackets
15:58:04 <Koterpillar> factorial 4 = 4 * (factorial 3) = 4 * (3 * ...)
15:58:26 <EvanR_> to do 4 * factorial 3, it needs to know 4 (check) and factorial 3
15:58:39 <EvanR_> theres no opportunity to settle up early
15:59:10 <EvanR_> so this is a pretty bad factorial function
15:59:43 <boxscape> so you could already just get a pretty significant improvement just by counting up instead of counting down?
15:59:45 <ertes> isd: you just apply run* in the appropriate order, which unifies the type variables accordingly
16:00:07 <ertes> boxscape: now, you need an accumulator to implement factorial properly
16:00:09 <EvanR_> boxscape: dont think just do the same thing counting up would work
16:00:11 <ertes> s/now/no/
16:00:25 <Myrl-saki> To do factorial, one must know how to do factorial.
16:00:34 <ertes> i.e. don't write the factorial function, the function that computes x!
16:00:41 <ertes> instead write the function that computes k * x!
16:00:52 <EvanR_> heres a better one: fact n = product [1..n] ;)
16:00:56 <younder> factorial lends itself well to memonization
16:01:02 <ertes> f k 0 = k
16:01:32 <ertes> f k x = let !k' = k*x in f k' (x - 1)
16:01:44 <boxscape> fac acc max k = if k == max then acc else fac (acc*k) max (k+1)
16:01:53 <EvanR_> > product [1..0]
16:01:55 <lambdabot>  1
16:01:58 <EvanR_> hehe
16:01:59 <ertes> (but really, just use foldl') =)
16:02:02 <Myrl-saki> fact n = foldl (*) 1 [x | x <- [1...]]
16:02:10 <Myrl-saki> jk
16:02:14 <boxscape> @source foldl
16:02:15 <lambdabot> Unknown command, try @list
16:02:17 <ertes> [1.................]
16:02:19 <boxscape> what was the command for that?
16:02:26 <Myrl-saki> @src
16:02:26 <lambdabot> src <id>. Display the implementation of a standard function
16:02:28 <boxscape> @src foldl
16:02:28 <lambdabot> foldl f z []     = z
16:02:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:02:29 <boxscape> thanks
16:02:35 <ertes> boxscape: we're programmers…  we don't type vowels
16:02:43 <boxscape> right... I should've known
16:02:43 <Myrl-saki> oh wait what
16:02:47 <Myrl-saki> that's how foldl is done
16:02:48 <Myrl-saki> ???
16:02:51 <Myrl-saki> waaaaaat
16:03:02 <Myrl-saki> I thought it was something along the lines of
16:03:23 <Myrl-saki> foldl f z (x:xs) = foldl f..
16:03:25 <Myrl-saki> oh wait
16:03:36 <Myrl-saki> hmmm
16:03:36 <hpc> were you about to write out the same thing? ;)
16:03:42 <Myrl-saki> hpc: Yeah
16:03:48 <hpc> haha, i do that sometimes
16:03:48 <ertes> Myrl-saki: that's a good sign =)
16:04:20 <ertes> @src foldl'
16:04:21 <lambdabot> foldl' f a []     = a
16:04:21 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:04:38 <ertes> that's the almost perfect foldl'
16:04:58 <hpc> a perfect foldl' would be foldr because left folds are conceptually gross :P
16:05:10 <Myrl-saki> Ohhh
16:05:24 <Myrl-saki> Oh wait. Nope.
16:05:24 <ertes> they're fine, but i'm hesitant to call them "folds" =)
16:05:41 <Myrl-saki> It's weird.
16:06:11 <amx> ezyang: it is my understanding this is not about SIGINT as Ctrl+c rather results in a UserInterrupt async exception. The only solution I could think of is running your code with an exception handler that exits.
16:06:12 <Myrl-saki> Like, for most use-cases, shouldn't foldr be the default?
16:06:29 <ertes> Myrl-saki: foldr is for different things
16:06:29 <Myrl-saki> > foldr (:) [] [1..]
16:06:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:06:32 <Myrl-saki> ertes: I know
16:06:57 <Myrl-saki> How do I say this
16:07:04 <younder> folds are just like loops, execpt the invariant or fixpoint is more explicit
16:07:04 <Myrl-saki> When working with commutative functions?
16:07:21 <boxscape> @src product
16:07:21 <lambdabot> product = foldl (*) 1
16:07:25 <boxscape> ugh
16:07:38 <ezyang> amx: GHCi tries really hard not to die though :^) 
16:07:39 <Myrl-saki> @src sum
16:07:39 <lambdabot> sum = foldl (+) 0
16:07:55 <ezyang> OK, I'm going to try a different strategy: try to actually get my bracket closers to run when main dies 
16:08:05 <hpc> :t map (+) 0
16:08:06 <lambdabot> (Num [a], Num a) => [a -> a]
16:08:11 <ertes> Myrl-saki: if functions are truly commutative, you should probably always use foldl'
16:08:17 <hpc> ah, much better
16:08:41 <hpc> i would still use foldr so it can be productive
16:08:45 <ertes> Myrl-saki: commutative and strict: use foldl'
16:08:49 <geekosaur> amx, the signal handler is what generates UserInterrupt
16:08:52 <hpc> oh, and strict
16:09:10 <geekosaur> the OS does not know about Haskell exceptions, it knows about signals (or one specific "signal" in the case of Windows)
16:09:34 <Myrl-saki> Oh true.
16:09:38 <hpc> windows has signals?
16:09:50 <hpc> for all i knew it was passing around COM objects instead or some nonsense
16:09:57 <Myrl-saki> @let sum' = ala Sum foldMap
16:09:59 <lambdabot>  Defined.
16:10:04 <Myrl-saki> > sum' []
16:10:07 <lambdabot>  0
16:10:09 <ertes> :t ala
16:10:11 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
16:10:14 <Myrl-saki> > sum' [1..10]
16:10:17 <lambdabot>  55
16:10:27 <mlehmk> windows has more than signals
16:10:29 <boxscape> :t ala
16:10:31 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
16:10:36 <boxscape> aha
16:10:46 <Myrl-saki> lol
16:10:50 <ertes> that's lens stuff, isn't it…
16:10:51 <hpc> :t ala
16:10:53 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
16:10:56 <hpc> oh, that's what the type is
16:11:00 <MarcelineVQ> ertes: Control.Lens.Wrapped
16:11:14 <geekosaur> Lens provides that but there's an independent implementation
16:11:19 <Myrl-saki> Yeah
16:11:29 <geekosaur> that got absorbed by lens
16:11:41 <glguy> :t au -- is the one to look at
16:11:43 <lambdabot> Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
16:11:46 <ertes> i like the lens library, but it has the tendency to be useless with :t
16:11:53 <glguy> ala is au with a helper to look up well-known Isos
16:12:16 <Myrl-saki> Lens types will s t a b you in the back.
16:12:32 <Myrl-saki> Okay. THat was very bad.
16:13:00 <kadoban> Very
16:13:30 <Myrl-saki> Dammit. I scared everyone away.
16:13:44 <hpc> the next iteration of lens will be a template haskell library that sends your types to google engineers for hand-written optimized definitions
16:13:56 <amx> geekosaur: right, for some reason installing your own signal handler in ghci doesnt work, maybe it is overwritten on every prompt
16:14:27 <Myrl-saki> hpc: But your types will have spyware in it.
16:14:41 <hpc> amx: or before maybe
16:15:10 <hpc> since it'd be used to interrupt the current computation and go back to a prompt
16:15:32 <hpc> actually ignore that, i am derp
16:15:48 <boxscape> @let sum'' = getSum . foldMap Sum
16:15:51 <lambdabot>  Defined.
16:15:54 <boxscape> sum'' [1..10]
16:16:00 <boxscape> > sum'' [1..10]
16:16:03 <lambdabot>  55
16:16:31 <ezyang> Augh, this is frustrating, why aren't my finalizers getting caled 
16:17:16 <EvanR> before the program ends?
16:17:44 <ertes> ezyang: because they aren't guaranteed to be called
16:17:58 <ezyang> my bracket finalizers 
16:18:07 <EvanR> ah
16:18:12 <ezyang> I shouldn't say finalizer because that's not what they are ^^" 
16:18:46 <ertes> ezyang: in the main thread or in another thread?
16:19:03 <ezyang> other threads, but I spawned them using withAsync 
16:19:15 <ertes> ezyang: you still need to 'wait'
16:19:39 <ezyang> I am waiting! 
16:19:49 <hpc> technically the end of a bracket isn't guaranteed to be called either
16:20:05 <ertes> ezyang: withAsync c (\s -> d `finally` (cancel s >> wait s))  -- like this?
16:20:19 <hpc> but for pedantic reasons like cutting power to a machine
16:20:51 <ezyang> ertes: so what I have is 
16:20:58 <ezyang> withAsync c (\s -> wait s) 
16:21:07 <ezyang> (but iterated, since it would pointless to only do one 
16:21:22 <ertes> that *should* work, as long as the waiting thread is not itself killed
16:22:04 <ertes> wait is interruptible
16:22:08 <ezyang> well, if it's a normal async exception, it should unwind 
16:22:47 <geekosaur> also if you are not doing that from the main thread, make sure the main thread has some way to wait for that thread to finish
16:23:02 <geekosaur> because exiting the main thread kills everything else without waiting or checking
16:23:09 <ezyang> nope, that's the main thrad 
16:23:28 <ezyang> let's post some code, I guess 
16:23:43 <ezyang> http://lpaste.net/332999 
16:24:05 <ezyang> withNewServer calls bracket, and its destructor is not called on ctrl-c 
16:24:22 <ezyang> OH. I just had a horrible realization 
16:25:17 <ezyang> I might be deadlocking in the finalizer 
16:25:33 <EvanR> isnt ctrl C going to kill the process
16:25:57 <ezyang> EvanR: Nope, it's ghci, which swallows it 
16:26:39 <ezyang> well, I removed the potential deadlocker, no change 
16:27:17 <ezyang> oh! Now one of them is getting called 
16:27:19 <younder> ctrl-c sends sigterm which allows for cleanup. sigkill kills the process at os level.
16:27:49 <ezyang> Try pkill -SIGKILL ghc on a GHCi process 
16:27:52 <EvanR> either way, a normal program not in ghci would die and not necessarily run any finalizers of any sort
16:28:10 <EvanR> but this is ghci so that doesnt apply
16:29:52 <geekosaur> younder, ctrl-c sends SIGINT
16:30:51 <ezyang> ok, I guess I've fixed it 
16:31:07 <geekosaur> tty driver intercepts it and SIGINT-s the pgrp that currently owns the terminal (tpgrp). likewise for ctrl-\ and SIGQUIT; both controlled by `isig` termios setting
16:31:18 <ezyang> instead of trying to gracefully shut down ghci, I'm calling terminateProcess now 
16:33:12 <slack1256> how are different Scott encodings than ADTs? both seems to proceed by case-analysis. At least on the List example they look similar
16:33:39 <boxscape> oh, I just realized that you don't need to use "let" anymore to define bindings in ghci. How long has that been the case?
16:34:01 <hpc> it's pretty recent
16:34:07 <geekosaur> boxscape, ghc8.0.1
16:34:11 <boxscape> I see, thanks
16:36:44 <asdfasdf01> guys, a quick question: how to make ghci do `:m +A +B +C` automatically after i run `ghci A.hs B.hs C.hs`?
16:37:48 <hpc> what are you trying to do with it?
16:40:43 <blackgnezdo> speaking of strange signal handling, anybody running stack --file-watch from emacs *compile*? I had to restart it ('g') a few times and then noticed a bunch of stack processing hanging around.
16:43:33 <delYsid> I have a s -> [([a],s)] type of parser that I managed to parallelize in the C implementation.  How would I go about doing something similar in Haskell?
16:43:47 <ezyang> blackgnezdo: Probably some sort of Stack bug 
16:43:51 * hackagebot simple-effects 0.5.0.3 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.5.0.3 (darwin226)
16:43:55 <ezyang> hard to get this right :( 
16:47:31 <Sindriava> Is anyone aware of a library for parsing doxygen-like comments?
16:48:52 * hackagebot cereal 0.5.4.0 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.4.0 (TrevorElliott)
16:58:37 <monochrom> ezyang: ghci is friendly to SIGTERM, it will clean up (remove its tmp directory) properly. It's why when I use emacs haskell-mode I can just quit emacs and confirm "yes kill ghci" and everything is clean. :)
17:00:27 <ezyang> monochrom: Then this is very confusing: based on my examination terminateProcess (which allegedly sends a SIGTERM) doesn't kill GHCi 
17:01:07 <monochrom> eww
17:01:30 <monochrom> linux?
17:01:34 <ezyang> yep 
17:02:30 <monochrom> I just manually tried, it worked. "ghc: signal: 15 \n Leaving GHCi."
17:04:07 <monochrom> ah! let me try to confound its rmdir logic
17:05:23 <monochrom> no, I cannot confound rmdir
17:13:55 <seafood> What would be a good way to perform an action every 15 seconds in Haskell, preferably in its own thread without using too many CPU resources.
17:14:21 <monochrom> sleep for 15 seconds. action. repeat.
17:14:41 <monochrom> use threadDelay 15000000 to sleep 15 seconds
17:15:39 <ezyang> seafood: yeah just make a thread to do it 
17:15:51 <ezyang> or not. If that's the only thing you want to do 
17:15:52 <seafood> Thanks!
17:21:38 <sm> but also, think about termination (of child when parent exits) and exception propagation (from child to parent). The async library may be useful
17:22:31 <sm> s/termination/graceful termination/
17:31:25 <daedra_> Hello everyone.
17:32:05 <daedra_> How can I add a catch-all pattern for a char?
17:32:11 <daedra_> I have the following code:
17:32:14 <daedra_> charName :: Char -> String                                                       
17:32:14 <daedra_>  18 charName 'a' = "Albert"                                                          
17:32:15 <daedra_>  19 charName 'b' = "Broseph"                                                         
17:32:15 <daedra_>  20 charName 'c' = "Cecil"                                                           
17:32:15 <daedra_>  21 charName x = "x"
17:32:19 <daedra_> However, it's not working.
17:33:07 <monochrom> That looks right. The cause is elsewhere.
17:33:27 <daedra_> If I, for example, use charName 'h'
17:33:30 <daedra_> It does not work.
17:33:39 <monochrom> What does "work" mean?
17:33:52 <daedra_> Getting the right output.
17:33:58 <daedra_> It's working now...
17:34:00 <monochrom> What is the right output?
17:34:04 <daedra_> I don't know what happened.
17:34:09 <daedra_> The right output is "x"
17:34:17 <daedra_> But, another question.
17:34:22 <monochrom> OK, cosmic ray. Buy ECC RAM.
17:34:34 <geekosaur> what happened when it wasn't working?
17:35:05 <daedra_> When it was not working I got this error:
17:35:09 <daedra_> <interactive>:20:10: error: Variable not in scope: 'h' :: Char
17:35:10 <geekosaur> (note, if you tried to define that in ghci, you have to do it as a single binding group with :{ :} or with semicolons on one line)
17:35:25 <daedra_> I was loading the function from an archive.
17:35:25 <geekosaur> sounds to me like you forgot to quote it
17:35:53 <daedra_> I did, it's weird, I know... And I'll get ECC RAM ASAP hehe.
17:36:54 <daedra_> If I want to, for example print x next to a String, how would I be able to do that?
17:37:19 <daedra_> Like, print "You used 'x' which is not valid"
17:37:22 <geekosaur> hm, actually that looks even weirder because the error message doesn't normally include quotes like that. trying to use this with mueval or something, and it somehow got confused?
17:37:22 <monochrom> "hi" ++ "x" ++ "hello"
17:37:53 <monochrom> or even just "hixhello"
17:38:00 <geekosaur> ^ but beware that function application binds tighter than any operator so `putStrLn x ++ "foo"` does not do what you intend
17:38:14 <daedra_> That inputs "x" and I want to print the value of x.
17:38:26 <monochrom> "hi" ++ [x] ++ "hello"
17:38:28 <daedra_> Like if x = h it would be "hihhello
17:39:36 <daedra_> That works, thank you very much, so it basically is creating a list with only 1 element which is the variable.
17:39:42 <daedra_> Thanks. :)
17:39:56 <daedra_> Oh, and geekosaur, I was using only GHCI
17:40:00 <daedra_> In Arch Linux.
17:40:28 <geekosaur> yes, I was talking about at the prompt, not in a loaded file or module
17:40:57 <geekosaur> the prompt is not smart, if you enter something on multiple lines the later lines shadow the earlier ones
17:41:33 <monochrom> However, the presence of line numbers "18" "19" etc shows that the code was in a file already.
17:41:42 <daedra_> That may be the cause of the problem, it works like a charm now, but it was weird...
17:41:48 <daedra_> Yeah, I copied it straight from Emacs.
17:52:20 <lpaste> aphorisme pasted “Mutual implicit recursion in monadic parsing?” at http://lpaste.net/333360
17:53:11 <aphorisme> I'm trying to understand how to use ASTs in which the recursion is generalized... but I've trouble parsing into such an AST. Maybe someone has already solved this?
17:53:26 <aphorisme> (see lpaste above)
18:07:47 <pavonia> aphorisme: I think you need some fixpoint type there
18:08:20 <pavonia> Such that exprTermFactor :: Parser (Fix AST)
18:08:23 <aphorisme> so let the parsers work on `Fix AST` ?
18:08:32 <pavonia> Yeah
18:09:05 <monochrom> I recommend sticking to the original "data AST = Add AST AST | etc".
18:09:47 <monochrom> There is no need to do both value-fix and type-fix at the same time.
18:10:27 <ctesiphon__> hey guys, question about QuickCheck testing - how do I test for probabilistic events? i.e. checking that a function which returns some result with x% probabability does indeed do so with reasonable certainty (I know it'll be impossible to have guarantees)
18:10:29 <aphorisme> monochrom: well, I was heading towards supporting a general interface for annotating terms.
18:11:00 <aphorisme> monochrom: The basic idea was obtained from http://blog.callcc.name/posts/free-sourcepos.html -- but there no mutual recursion needs to take place.
18:11:21 <monochrom> OK, but value-fix and type-fix are orthogonal. You cannot code up one and expect the one to happen automatically.
18:11:42 <monochrom> s/expect the one to/expect the other to/
18:12:20 <aphorisme> I see.
18:13:35 <Koterpillar> ctesiphon__: besides generating a list of 1000 events and seeing that approximately 1000*x passed?
18:14:28 <aphorisme> I'm not sure about acting on the Fix AST here, if my goal is to allow annotation. But maybe I can abstract it in a suitable way.
18:14:31 <ctesiphon__> @Koterpillar yes, besides that - such a test is what I'll use in case there's nothing else
18:14:31 <lambdabot> Unknown command, try @list
18:15:38 <Koterpillar> ctesiphon__: I don't think QuickCheck lets you correlate the results of individual tests
18:16:01 <LinuxSTAIN> Election Day!!
18:16:03 <ctesiphon__> Koterpillar: because in "approximately 1000*x passed", "approximately" is quite broad in meaning, so I was looking for other opinions before I committed to this approach. Maybe choosing some epsilon such that with an increasing number of tests must come an increasingly precise result?
18:17:25 <Koterpillar> ctesiphon__: well, if you want your tests pass 99.999% of the time, you can calculate a trust interval d such that for 1000 events, the result will be between [1000*x - d, 1000*x + d]
18:17:51 <Koterpillar> where d depends on both the sample size and the allowed false positive rate
18:18:13 <LinuxSTAIN> @Koterpillar what r u working on
18:18:13 <lambdabot> Unknown command, try @list
18:18:27 <Koterpillar> LinuxSTAIN: sadly, not Haskell at the moment.
18:21:06 <LinuxSTAIN> looking for some good irc for the network security crowd
18:23:17 <aphorisme> anyways, it's quite late ... again. Thanks, monochrom and pavonia.
18:36:11 <soLucien> is tehre a built-in function to remove an element from al ist ?
18:36:21 <monochrom> No.
18:36:38 <monochrom> Actually maybe yes. Look for "\\"
18:36:40 <verement> > [1..10] \\ [5]
18:36:43 <lambdabot>  [1,2,3,4,6,7,8,9,10]
18:36:57 <monochrom> It is in Prelude or Data.List
18:37:13 <Koterpillar> [1..10] \\ [4,3]
18:37:15 <Koterpillar> > [1..10] \\ [4,3]
18:37:17 <lambdabot>  [1,2,5,6,7,8,9,10]
18:37:35 <Koterpillar> > [1,1,1] \\ [1,1]
18:37:38 <lambdabot>  [1]
18:38:49 <MarcelineVQ> > delete 'c' "characters" -- also
18:38:52 <lambdabot>  "haracters"
18:39:39 <ctesiphon__> Koterpillar: I think I'll do just that. I'll tinker a bit with the constants and see which magic numbers to use.
18:39:42 <ctesiphon__> thanks.
18:39:57 <Koterpillar> there's no magic
18:40:26 <Koterpillar> https://en.wikipedia.org/wiki/Confidence_interval
18:48:01 <laudiacay> b 2
19:11:02 <dyreshark> b 4
19:17:52 <soLucien> so i can do map +1 fst on a list , but i can't do map -1 fst
19:17:57 <soLucien> map ( (+1) . fst) [(2, [1,2,3]), (4, [1,2]), (6, [1,2,3,4]) ,(3,[1,2]),(1,[1,2,3]),(5,[1,2,3,4])]
19:18:10 <soLucien> if i change it to - i ger some weird error
19:18:17 <Koterpillar> -1 is a literal
19:18:22 <Koterpillar> :t -1
19:18:23 <soLucien> what can i do? i want to decrement
19:18:24 <lambdabot> Num a => a
19:18:28 <byorgey> soLucien: that's because -1 parses as negative one
19:18:31 <Welkin> soLucien: subtract
19:18:44 <Koterpillar> > map (- 1) [1,2,3]
19:18:44 <byorgey> > map ((subtract 1) . fst) [(2, [1,2,3]), (4, [1,2])]
19:18:48 <Welkin> > (- 1) 3
19:18:51 <lambdabot>  [1,3]
19:18:51 <lambdabot>  error:
19:18:51 <lambdabot>      • Could not deduce (Num a0)
19:18:51 <lambdabot>        from the context: (Num (a -> b), Num a)
19:18:58 <lambdabot>  error:
19:18:58 <lambdabot>      • Could not deduce (Num t0)
19:18:58 <lambdabot>        from the context: (Num (t -> t1), Num t)
19:19:02 <soLucien> okay sorry .. i understand
19:19:04 <soLucien> my bad
19:19:04 <Welkin> > (subtract 1) 3
19:19:07 <soLucien> thanks !
19:19:07 <lambdabot>  2
19:19:20 <byorgey> soLucien: nothing to apologize for, this is a weird corner case of Haskell syntax
19:20:37 <soLucien> what if i want to return the list
19:20:44 <soLucien> of tuples
19:20:50 <soLucien> instead of the list of fst values
19:20:57 <soLucien> what do i have to use instead of map ?
19:21:38 <monochrom> map (\(x,y) -> (x+1, y))
19:28:13 <soLucien> I can't really use if statements inside a lambda , so what can i use instead ? i want to do something like 
19:28:15 <soLucien> map ( \(x,y) -> if x <= p then (x-1,y) )
19:28:29 <Koterpillar> else?
19:28:50 <Koterpillar> also consider a list comprehension
19:29:11 <Koterpillar> [ (x + 1, y) | (x, y) <- ..., x <= p ]
19:33:27 <byorgey> soLucien: haskell does not have if statements, but it does have if *expressions*, which must always have an 'else'.  And you can definitely use them inside a lambda, or anywhere.
19:33:42 <soLucien> yes i solved it
19:44:05 <asdfasdf> @lamdabot help
19:44:05 <lambdabot> Unknown command, try @list
19:44:11 <asdfasdf> @lambdabot @list
19:44:11 <lambdabot> Unknown command, try @list
19:44:14 <asdfasdf> @lambdabot list
19:44:14 <lambdabot> Unknown command, try @list
19:44:21 <asdfasdf> @list
19:44:21 <lambdabot> What module?  Try @listmodules for some ideas.
19:44:28 <asdfasdf> @help
19:44:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:44:49 <Koterpillar> asdfasdf: you can ask lambdabot in private, too: /msg lambdabot @help
19:47:21 <asdfasdf_> @pl \x -> x + 1
19:47:22 <lambdabot> (1 +)
20:09:32 <jle`> odd that it doesn't return (+ 1)
20:33:46 <mikeplus32> anyone used full-text search with persistent on postgres?
21:12:43 <benzrf> @pl \x -> x *& 1
21:12:43 <lambdabot> (*& 1)
21:12:46 <benzrf> weird
21:20:22 <jle`> might be a special rule for (+)
21:20:30 <jle`> @pl \x -> x * 1
21:20:30 <lambdabot> id
21:20:42 <jle`> lol
21:35:31 <benzrf> is that true for all numeric types?
21:35:36 <benzrf> do floats do that correctly, for example
21:36:25 <kadoban> Probably? Can't think of a case they wouldn't
21:38:58 <jle`> "lawful" Num's
21:47:15 <Cale> Floating point operations *are* commutative
21:47:15 <alok_> hey, has anyone ever had an issue with hdevtools in vim where globally installed packages are not found?
21:48:14 <kadoban> alok_: Is there a stack.yaml or something?
21:49:19 <lpaste> alok_ pasted “stack.yaml” at http://lpaste.net/334250
21:49:27 <benzrf> alok_: are you using nix by any chance
21:49:37 <alok_> osx 10.11.6
21:49:45 <nevere> Can a lens be made to do a polymorphic update, for example from, "User String String" to "User Text Text" ?
21:50:09 <benzrf> nevere: yes!
21:50:22 <benzrf> well - it depends on the type of the lens, of course - but you can certainly make a lens that does that
21:50:23 <alok_> running latest version of hdevtools
21:52:14 <nevere> benzrf: I am using the Control.Lens module. By type of lens, do you mean the types that can be made by configuring the Preconfigured Lens Rules?
21:52:26 <benzrf> hold on - how is User defined?
21:53:01 <jle`> nevere: the type of the lens shows what it can change
21:53:16 <nevere> benzrf: I am talking about the lens rules in this page https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:camelCaseFields
21:53:16 <jle`> _1 :: Lens (a, b) (c, b) a c
21:53:27 <jle`> nevere: means that _1 can change the first field from 'a' to 'c'
21:53:33 <jle`> but it won't change the type of the second field of a tuple
21:53:53 <jle`> nevere: ah no, not types as in "sort of things", types as in, haskell type.  like Int, Bool
21:53:59 <nevere> jle`: Can use TH to make those for my records?
21:54:00 <jle`> lenses have types
21:54:09 <jle`> nevere: it depends on the record ofc
21:56:40 <jle`> nevere: if you had record data Foo = F { fooString :: String }, then it can't change fooString to a Double
21:56:42 <nevere> jle`: What if the record is something simple like "data User name age = User name age"
21:56:56 <jaziz> So who's moving to Canada with me?
21:57:07 <jle`> the TH can probably generate lenses for the name and age fields
21:57:14 <jle`> if they are records
21:57:23 <jle`> what you posted is not a record so i'm unsure about what you're asking
21:57:46 <systemfault> jaziz: I hope you like "cold" :) If so, welcome
21:58:05 <jaziz> systemfault, I hear the people are nice
21:58:07 <nevere> jle`: Sorry. I meant something like this  "data User name age = User {name :: name, age:: age}"
21:58:09 <jaziz> So that's good
21:58:14 <ab9rf> jaziz: off topic
21:58:17 <jaziz> Apparently my country is majority asshole
21:58:19 <jle`> yeah
21:58:22 <jaziz> ab9rf, you are right, sir
21:58:24 <jaziz> or ma'am
21:58:25 <jaziz> apologies
21:58:47 <jle`> nevere: the usual convention is to call them _name :: ... and _age :: ...
21:58:51 <jle`> which will create lenses 'name' and 'age'
21:59:13 <jle`> and also to maybe prefix them with _userName sometimes
21:59:29 <jle`> name :: Lens (User n a) (User m a) n m
21:59:58 <jle`> over name length :: User String a -> User Int a
22:00:32 <jle`> set name "foo" :: User n a -> User String a
22:01:05 <nevere> jle`: Yes. But can the lenses created by the lens.TH module do that?
22:01:31 <jle`> yes, they're meant to be as polyorphic as possible for the most part
22:04:04 <nevere> jle`: The lens I currently, named "name", has got the type, :: HasName t a => a -> t -> t
22:04:22 <nevere> I mean, that is the type of (set name)...
22:04:55 <jle`> huh
22:04:58 <jle`> what did you use to make it?
22:05:21 <nevere> jle`: makeLensesWith abbreviatedFields....
22:06:15 <jle`> oh huh
22:10:56 <nevere> jle`: ?
22:13:15 <soLucien> is it possible to somehow print functions in a partially applied function ?
22:14:08 <kadoban> soLucien: Not entirely clear what you mean
22:14:29 <soLucien> map (\ (Foo a) -> match a ) [Foo "foo", Foo ".c"]
22:15:11 <soLucien> this is a partially applied function : it results in a list of functions
22:15:38 <soLucien> [match "foo", match ".c"]
22:16:42 <kadoban> And you want to print them out, for debug or something?
22:16:48 <soLucien> exactly
22:20:29 <soLucien> i have to write a quite complex function with a lot of lambdas to extract Strings from data types, run the match function between 2 lists of strings
22:20:39 <soLucien> it's too complex for me to write it in a single line
22:20:51 <soLucien> so i want to do it step-by-step
22:21:04 <soLucien> and i want to debug what is happening
22:21:21 <soLucien> is it possible to somehow print these partially applied functions ?
22:21:43 <kadoban> Hmm, I don't know any way to do that unfortunately. Maybe somebody else does, or a specific trick here.
22:26:05 <jle`> soLucien: partially applied functions are functions
22:26:08 <jle`> and you can't print functions
22:26:22 <jle`> partially applied, or unapplied :)
22:27:28 <soLucien> jle' ok i made it work somehow
22:27:31 <soLucien> but i have a problem
22:27:39 <soLucien> i am running an applicative between 2 lists
22:27:56 <soLucien> and it places the results in a single list
22:28:09 <soLucien> is there some trick that you know of
22:28:28 <soLucien> that will allow me to distinguish between these results ?
22:29:39 <soLucien> distinguish between applications of the applicative
22:31:06 <soLucien> for example if i do (,) <$> [1,3] <*> [2,4]
22:34:50 <nevere_> jle`: There?
22:47:15 <Perce> hi haskell! i'm beginning to learn haskell, only a bit of c++ under my belt so still a noob really. so far really liking it, my question is though is it only different from other programming languages in that variables can't be assigned another value? why would that be a benefit?
22:48:07 <ongy> it's not the only difference, but one of the most notable differences
22:48:46 <ongy> the main reason this is good, is that we don't have as much mutable state, which is nice for reasoning about applications, parallelizing, and modularity
22:49:28 <johnw> Perce: when we say "variable", we don't mean "a mutable slot in memory", we mean it in the mathematical sense, of a name associated with a value
22:49:59 <benzrf> well, in the mathematical sense, i think variable normally means paramter
22:50:02 <benzrf> *parameter
22:50:37 <Perce> so what i understand it as is that in the function (name = "Perce") that can never change right?
22:51:06 <johnw> it's definition does not change, correct
22:51:36 <Perce> so what if i had a function which uses (name) but i want it to be able to use multiple names, how would that work?
22:51:39 <johnw> now, you can still have a name for a mutable memory cell in Haskell too, using an IORef accessed from the IO monad.  In that case, the cell is "constant", but what it refer to can change.
22:51:49 <Perce> ah okay
22:52:02 <ongy> recursion, mainly. Or building a list of names and iterating the list
22:53:24 <Rotaerk> not that said IORefs are used anywhere near as frequently as mutable variables are in a procedural language
22:54:09 <johnw> right, the freedom you think you gain for mutation is not so valuable when structures are immutable and there is much data sharing as a result
22:54:54 <johnw> you start to think in terms of "generations", as you progress a value from one form to another.  Each form is a new value, with a new name, but it can share storage and computation with what has preceded it.  Haskell makes this model quite efficient.
22:55:53 <johnw> plus, our strategy for relying on functional composition means that many of these intermediate values do not need names at all, but rather "flow" through a sequence of function calls
22:56:36 <nevere> jle`: There?
22:57:01 <Perce> so you would take the user input of multiple strings and put those inside of a list to manipulate instead of assigning the first one to (name) using it in whatever function and then assigning the second string to (name) and reusing it?
22:57:35 <johnw> you'd make an initial list with the user's input
22:57:44 <johnw> and then you'd "modify" it by generating a new list subject to that modification
22:57:47 <johnw> and so on, and so on
22:57:56 <johnw> but you're not copying the whole list each time you do this, as you might in C++
22:58:11 <Rotaerk> once the functional approach is ingrained, people tend to start (informally) using mutability terminology like "modifying" "setting" etc to really just refer to the relative difference between an input value and an output value of a function, rather than an actual mutation
22:58:26 <Perce> okay, haha this is definitely making me think differently than c++
22:58:29 <Perce> in a good way though
22:58:33 <johnw> oh, certainly
22:58:34 <Rotaerk> which might be misleading to someone who takes the terms literally
22:58:38 <johnw> C++ has taught you to think like a computer
22:59:05 <Perce> and what will haskell turn me into then?
22:59:10 <Perce> for analogies sake
22:59:11 <Rotaerk> a god !
22:59:13 <Rotaerk> err
22:59:14 <Perce> haha
22:59:15 <johnw> Haskell will teach you to think in terms of ideas, not so much how they are represented
22:59:42 <johnw> there is much mental freedom in this approach, even though there will still be days when you need to understand the nitty gritty in order to get just the efficiency characteristics you need
23:00:28 <johnw> but one cool thing: often in Haskell you'll be using lists, and transforming lists, but when you look at the optimized code coming out of the compiler, there's no list to be found!  It has understood what you meant to say, and turned your computation in a highly optimized tight loop, just as you might have written in C++. :)
23:01:18 <Perce> so its not so much thinking of how to get from point a to b by running steps but by making conclusions so to speak?
23:01:57 <Rotaerk> understanding procedural code is often a matter of mentally going through all the steps/statements, and for each, understanding the effect that the step had on the state.  from this you try to piece together an understanding of what's trying to be accomplished
23:02:01 <johnw> Perce: exactly!!
23:02:20 <Perce> okay thank goodness i'm kinda understanding the theory of the language
23:02:24 <johnw> Perce: using a logical model in your mind will serve you much better than an operational, impretaive model of how to tell the computer how to get there
23:04:34 <Perce> i'm understanding the theory behind the programming, but how does haskell manage to come to conclusions without a complex system of (ifs) (then) (else) and running through them until it comes to the right conclusion?
23:04:50 <Perce> like how does this process actually implemented
23:04:59 <grantwu> In a sense, Haskell does have a lot of ifs, thens, and elses
23:05:04 <Rotaerk> whereas functional code it's more like getting a very high level view of the goal up-front, and gradually filling in the details
23:05:13 <Rotaerk> as you read it
23:05:24 <grantwu> The thing is that Haskell treats switches and ifs as expressions
23:06:02 <johnw> Perce: every time you case analyze a value, to determine how it was constructed, you're branching.  every time you construct a value, you're creating a future opportunity to branch on it.  Add function calls and this is much of the essence of Haskell's underlying logic.
23:06:56 <johnw> The Haskell code you write is boiled down into an enriched form of the lambda calculus called System FC, and it's quite a simple system to understand in its entirely.
23:07:07 <sm> Perce, another way to answer your earlier q: we can't change a variable's value in the current scope, but we can easily enter a new scope where it is bound to a new value (by calling a function)
23:08:07 <johnw> now, how GHC turns System FC into optimal assembly language, that's can seem like wizardry sometimes.  There's a lot of research in this area, if that's what you're interested in.
23:08:27 <Perce> okay to be perfectly honest i'm really confused right now, if a computer takes input and then gives output, doesn't it have to go through all the prelimanary steps before coming to the conclusion? from what i understand from your explanations haskell seems to reach a value and then jump to the appropriate place skipping seemingly necessary steps
23:08:52 <johnw> functions in math take input and give output :)
23:09:05 <johnw> it never skips a semantically meaningful step
23:09:16 <Perce> so is it just that the functions can account for multiple results?
23:09:17 <johnw> it is just free to rewrite it into any other form that preserves those semantics
23:09:45 <johnw> in C++, the semantics of code order are very rigid, so there is a lot less opportunity for rewriting
23:10:12 <johnw> so you lose intelligent in the compiler, and make up for it by learning to understand what the machine needs to perform
23:11:17 <johnw> Perce: if you're asking how a Haskell program can have effects on the outside world, that's a another discussion.  I've been talking mostly about "pure" functions, or those that compute answers strictly from inputs.
23:11:19 <Perce> sm: okay that's cool so sort of opening another program and then using whatever result from there in the main one?
23:11:57 <johnw> the Haskell runtime happens to be written largely in C, if that helps at all
23:12:00 <sm> yes, loops with changing variables are done with recursive function calls instead (as ongy said)
23:12:08 <erisco> Perce, your premise is just that of structured and procedural programming, neither of which Haskell is
23:12:43 <erisco> Perce, Haskell does not execute a sequence of statements
23:12:59 <Rotaerk> well, the computer itself sure does
23:13:01 <sm> (in haskell, a function can keep calling itself with new argument values for ever - "tail-call optimization")
23:13:02 <Perce> yeah i know, i'm trying to get out of that framework but i guess its hardgrained into me now :(
23:13:16 <erisco> Perce, this answer may help you http://stackoverflow.com/a/40132517/260584
23:13:23 <Perce> okay thanks
23:13:28 <Rotaerk> it's just the compiler's responsibility to translate from haskell into a sequence of statements
23:14:23 <erisco> you are already familiar with expressions, you're just not used to using them in more advanced ways
23:14:55 <Perce> erisco: so haskell falls under the "what to do" umbrella right?
23:15:04 <grantwu> Perce: So, the translation from Haskell to assembly is arguably a lot bigger of a leap than that from C++ to assembly
23:15:14 <erisco> but you will find it not so troublesome in the end. If you understand ternary, i.e. p ? x : y  then you're on your way
23:15:38 <grantwu> ternary can have effects :'(
23:16:32 <ongy> we need more languages with a stronger sense of purity in expressions...
23:16:39 <grantwu> (but normally even in imperative code it's illadvised to have effects in ternaries)
23:16:48 <erisco> Perce, well as I try to explain the "what to do" and "how to do it" explanations are not good. Instead I make the separation on statements versus expressions and denotational semantics versus operational semantics
23:17:30 <erisco> yes ternary can have effects but I think that isn't what draws people to them
23:17:49 <erisco> it is that they want to make a decision and have a value based on it
23:18:02 <erisco> not something you can do with if/then/else !
23:18:27 <erisco> you have to do the disgusting thing of declaring a variable in the outer scope and assigning it in the inner scope
23:18:46 <grantwu> In my compiler we elaborate ?: to if then else
23:18:48 <grantwu> feelsbadman
23:19:04 <erisco> even imperative programmers wince at variables assigned like that
23:19:20 <grantwu> Although, hrm, I recently added purity analysis so
23:19:36 <Rotaerk> the goal of a statement is to describe an action to be carried out.  the goal of an expression is to be evaluated, or reduced to a value.  (that said, not all expressions *do* fully evaluate, just like not all loops terminate)
23:20:22 <Perce> so let me know if this sounds right to you guys or not     i have a imperative program which does gets two adds three to it and gets five, in a declarative program though i would state 5 = 2 + 3 and then i would ask for five?
23:21:05 <lpaste> insitu pasted “Using types for annotating dimensions” at http://lpaste.net/334270
23:21:34 <erisco> I don't think there is any difference in the example. You would write "var x = 2 + 3;" in one language and "let x = 2 + 3" in Haskell
23:21:38 <insitu> is there a better way to achieve type safety on dimensions
23:22:12 <Perce> erisco: haha darn it i thought i had an eureka moment but i guess not
23:22:37 <insitu> what I tried to achieve was simplifying the code that uses `scale` but at the expense of complexifying the needed machinery... Wondering if using simple data type with constructors for dimensions would not be enough... 
23:22:46 <Rotaerk> though, in the former case, "var x = 2 + 3;" is a statement in the sense that it indicates an *action* of computing 2 + 3, and assigning the result to a new variable x
23:23:13 <Rotaerk> whereas "let x = 2 + 3" is defining an expression, not necessarily evaluated yet, and calling it x
23:23:14 <insitu> I am esp. worried about the duplication in scale's code between instances
23:23:31 <erisco> *shrug* it could be lazy though I am not aware of such a language
23:23:59 <Rotaerk> true, you could do:  var x = new Lazy(() => 2 + 3);
23:24:00 <Rotaerk> in C#
23:24:08 <Rotaerk> Lazy<int> *
23:24:17 <erisco> yes, though I think you have to give type params in constructors
23:24:26 <Perce> Rotaerk: and then when you wanted x you would just call it correct? rather than computing it and getting the result?
23:24:27 <erisco> so more like  var x = Lazy.Create(() => 2 + 3);  heh
23:24:37 <Rotaerk> ah right
23:25:00 <Perce> okay then, well i'm going to call it a night guys, i'm going to record the logs though so i can try and make sense of it all, thanks a lot for you help guys really appreciate it
23:25:06 <erisco> but then there are strict functional languages as well, so
23:25:26 <Rotaerk> pfft, those aren't proper functional languages
23:25:28 <Rotaerk> *cough*
23:26:17 <erisco> ;) well the significant aspect you mentioned is that x is the same as 2 + 3, which is what we call referential transparency
23:27:17 <erisco> so you can write  var x = 2 + 3; x = 9;  in one language, but  let x = 2 + 3; x = 9;   doesn't make any sense
23:29:48 <erisco> if we played the game then it would be like you wrote  let 9 = 2 + 3
23:30:03 <erisco> and it isn't wrong because 9 is not equal to 2 + 3, it is wrong because 9 is not defined as 2 + 3
23:30:22 <erisco> so  4 + 1 = 2 + 3   is nonsense as well
23:31:30 <erisco> in C# there is nothing like this because variables are boxes to stuff values in, not names with definitions
23:32:17 <Rotaerk> time for me to hit the hay; night
23:35:14 <nevere> How can I make lenses that can make polymorphic updates (using Control.Lens.TH module)?
23:41:22 <johnw> do you mean, you want to generate lenses for some record, such that you can change the type of the elements in that record?  or did I misunderstand?
23:42:13 <nevere> johnw: Yes. For parametric types.
23:42:27 <johnw> I think all you need is for your record element to be parametric
23:42:47 <johnw> data Foo a = Foo { someElement :: a }; makeLenses ''Foo
23:43:49 <nevere> johnw: Yes. That is what I want. But it does not work when I make lenses with "makeLensesWith abbreviatedFields"
23:44:02 <johnw> hmm.. never tried that
23:47:12 <nevere> johnw: it works with makeLenses.
23:51:28 <johnw> ok, sanity restored somewhat :)
23:51:35 <johnw> maybe #haskell-lens might know
23:53:49 <meditans> hi, I have a question on the generics-sop approach:
23:53:57 <srhb> nevere: Did you prefix the names with _ ?
23:54:08 * hackagebot sibe 0.2.0.3 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.3 (mdibaiee)
23:54:21 <kosmikus> meditans: yes?
23:54:23 <srhb> Oh, nevermind, if none of them are prefixed, all are still given lenses. Hm.
23:54:32 <nevere> srhb: Lenses are getting created. But they are not type changing ones.
23:54:34 <srhb> Ah
23:54:44 <meditans> is it possible to have a class that has an associated type constructor constructed generically?
23:54:48 <meditans> like for example
23:55:01 <meditans> class HasError a where
23:55:01 <meditans>   type LinkedError a :: *
23:55:01 <meditans>   fun :: a -> LinkedError a
23:55:24 <kosmikus> in principle yes
23:55:47 <kosmikus> associated types are just type families
23:55:58 <kosmikus> and you can define them in terms of Code a
23:56:17 <meditans> kosmikus: do you happen to have some code demonstrating that? I wondered why this isn't a more widespread approach, it seems a very useful technique
23:57:12 <kosmikus> meditans: I can look
23:57:18 <kosmikus> but what do you want LinkedError to be?
23:58:47 <meditans> good question, so here's the problem: let's say that I have a type a, and I want another type to have all the fields in a replaced by something, for example a concrete type (say Text), or a function (b -> Either Text Something)
23:59:01 <meditans> of course I could just parametrize the datatype with a functor
23:59:34 <meditans> but then, instead of eg. User, I'm forced to write User Identity everywhere to talk about the datatype
