00:01:44 <jle`> oh they have github oauth
00:04:37 <jle`> oh
00:04:40 <jle`> MonadIO is in 'base' now
00:04:56 <jle`>  ... when did this happen?
00:06:35 <MarcelineVQ> 4.9 it seems
00:07:03 <MarcelineVQ> leme doublecheck that I might put a wrong number in
00:07:22 <jle`> made a darcs account for nothing ;_;
00:07:37 * hackagebot persistent-parser 0.1.0.2 - Parse persistent model files  https://hackage.haskell.org/package/persistent-parser-0.1.0.2 (mchaver)
00:07:37 * hackagebot from-sum 0.2.1.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.2.1.0 (cdepillabout)
00:08:16 <MarcelineVQ> Control.Monad.IO.Class doesn't exist before 4.9, according to the docs at least, so it looks like a new addition
00:09:10 <jle`> neat
00:09:36 <jle`> although that was not at the top of my things i would have thought were high-priority to be in base
00:09:38 <jle`> it's neat
00:11:46 <grayhatter> jle` thanks for you help mate!!
00:13:56 <jle`> no problem!
01:16:07 <stobix> Axman6: That Haxl talk was quite an interesting ride! I'm not sure I understand it fully yet, but I guess that the gist is that >>= forces an "unpacking" of the abstraction layer that <*> doesn't, right?
01:18:43 <earthy> stobix: it collapses the waveform, yes.
01:19:07 <earthy> *wave function
01:22:24 <stobix> heh, nice way of viewing it, I guess
01:22:34 * hackagebot haskelisp 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/haskelisp-0.1.0.0 (shintak)
01:22:47 <hvr> *sigh*
01:26:18 <quchen> Haxl is a very dangerous balance between practicality and violating the monad laws.
01:26:40 <quchen> And a fairly interesting one :-)
01:29:05 <tdammers> stack upload should have a check to reject projects with the scaffolded default synopsis
01:30:35 <hvr> tdammers: + the scaffoleded default description
01:30:57 <hvr> which is similiarly useless
01:30:57 <James123> From what I found on the internet, `type' is used for type synonyms (which are replaced by the compiler) and `data' is to create new types. What is `newtype' then?
01:32:02 <hvr> tdammers: haskelisp being case in point
01:33:28 <phadej> James123: to create new types which has the same representation as old ones
01:34:03 <mpickering> It's funny that the default description is a pointer to the README I guess.
01:34:18 <hvr> mpickering: ...which doesn't appear to exist
01:34:22 <mpickering> Well, funny is perhaps the wrong word. 
01:34:46 <hvr> mpickering: but it's useless anyway for hackage, since if you don't have any useful description field, it's better to leave it away altogether
01:34:59 <liste> James123: newtype works like data, but it's restricted to a single constructor with a single field. its semantics are also a bit different - newtype creates a wrapper type that's erased at runtime
01:35:02 <hvr> otherwise hackage assumes the description field actually contains a description
01:35:17 <liste> James123: s/wrapper type/wrapper
01:35:32 <James123> phadej, liste Thank you both :) Now I get it
01:38:26 <quchen> James123: https://github.com/quchen/articles/blob/master/fbut.md#data-newtype-type
01:40:12 <James123> quuxman, very nice guide. Thank you
01:40:20 <James123> sorry
01:40:46 <James123> ( quchen I meant, autocomplete problem )
01:46:57 <angerman> anyone got any suggestions for profiling a webapplication? 
01:47:34 <angerman> (optimally I'd like to collect something like heap profiles per url)
01:50:11 <James123> I created a new type data mytype = Map Int ( Set Int ). To construct, I started with Map 5 [1], but it doesn't work. Any ideas?
01:50:48 <liste> James123: [1] isn't of type Set
01:51:12 <James123> liste: So the only way for it to work is to start with Set.empty?
01:51:13 <liste> James123: I suppose you're defining your own Map and Set types?
01:51:28 <liste> James123: yes, or Set.singleton
01:51:36 <liste> James123: or other ways to construct Sets
01:51:48 <James123> liste, no I just want a hash that keys are ints, and values are sets
01:53:32 <liste> James123: "data MyType = Map Int (Set Int)" defines a *new* constructor Map, along with a new type MyType
01:54:09 <liste> James123: are you sure you don't want "data MyType = MyType (Map Int (Set Int))" ?
01:54:21 <James123> liste, I have imported Map and Set
01:54:25 <liste> or "data MyType = MkMyType (Map Int (Set Int))"
01:54:58 <James123> Ah, ok now I understand. Thanks!
02:18:00 <xenon-> hi. I have this parse :: Parser (Maybe Integer)\n parse = readMaybe <$> many digit
02:18:28 <xenon-> type is Parser (Maybe Integer), which seems a bit redundant.. how could I just have it return Integer or fail
02:19:20 <lyxia> parse >>= \x -> ...pattern match on x...
02:19:35 <liste> xenon-: how about read <$> some digit ?
02:19:57 <xenon-> liste won't that throw exception?
02:20:30 <liste> xenon-: read throws an exception if it's given something that doesn't parse as a number
02:20:47 <liste> xenon-: but strings of 1-N digits all parse as numbers
02:20:49 <xenon-> not what i wanted
02:21:00 <xenon-> oh you're right
02:21:32 <xenon-> but generally, how would I indicate fail in a parser, so that I get Left error when using it
02:21:39 <xenon-> failure*
02:21:59 <pavonia> What parsing library are you using?
02:22:02 <xenon-> parsec
02:22:37 <pavonia> It as several parsers that produce a failure
02:22:52 <pavonia> fail "..." should work too
02:23:12 <xenon-> parseInteger = read <$> many digit   and then   parse parseAnyInteger "" "asdf"  gives me exception
02:23:26 <liste> xenon-: you used many, not some
02:23:48 <liste> many is 0-N, some is 1-N
02:24:52 <xenon-> i see
02:25:06 <xenon-> yeah that worked
02:29:35 <xenon-> I still don't get why parseAnyInteger = read <$> many digit doesn't work. shouldn't parser stop at "many digit", since that condition wasn't met? when given "asdf" input
02:30:50 <pavonia> Then it calls read with an empty string
02:31:14 <pavonia> Also, the condition *is* met
02:31:27 <xenon-> ah
02:31:29 <xenon-> i wanted many1
02:32:42 <xenon-> naming is not very intuitive.. parse (some digit) "" "asdf"   fails,  parse (many digit) "" "asdf" doesn't fail
02:33:18 <xenon-> and it seems that some and many1 do the same thing
02:56:30 <stobix> oh, so parsers actually use some/many. I was kinda wondering when/if those were ever used...
02:59:34 * stobix kinda timed out, so he's blissfully unaware of whatever was said in here for the last half hour since xenon got his thing to work
02:59:37 <phadej> they do. 
03:00:13 <phadej> it's like kleene star in regexps
03:00:40 <stobix> like the * in .* ?
03:00:45 <phadej> yeah
03:01:38 <phadej> it's less powerful than being able to say A := A | x in EBNF
03:01:39 <stobix> I tried using some/many on Maybe and lists. I got it to fail, but not to return anything sensible.
03:03:09 <stobix> phadej: I kinda think I understant what the name implies that they want to return, but I don't see how they do it, or what a structure needs to do to return something useful when using them.
03:03:19 <stobix> s/nt/nd/
03:04:22 <phadej> i think, that many for `Maybe` isn't overriden
03:04:26 <xenon-> :t many digit
03:04:28 <lambdabot> error: Variable not in scope: digit :: f a
03:04:39 <stobix> many Nothing returns Just []
03:04:51 <stobix> many $ Just "whatever" returns in an infinite loop
03:04:57 <lyxia> many/some for Maybe and List are not useful.
03:05:13 <phadej> it could return an Just ["whatever", "whatever", ..."
03:05:26 <phadej> but I dunno if that would be useful anywhere
03:05:29 <stobix> Hm, maybe that's what it's (almost) doing
03:05:30 <phadej> Maybe
03:05:49 <lyxia> you need a context in which applying the same action twice may yield different results.
03:06:24 <stobix> yeah, I guess. Like division?
03:06:50 <phadej> some stateful operation
03:07:10 <phadej> e.g. StateT Int Maybe Int
03:07:51 <phadej> or just State Int Int
03:08:02 <stobix> Yeah, I'm probably thinknig too small.
03:09:58 <phadej> > evalStateT (many $ do x <- get; put (x `div` 2); lift $ if x == 0 then Nothing else Just x) 10
03:10:00 <lambdabot>  Just [10,5,2,1]
03:10:39 <phadej> Identity isn't Alternative (no `empty`)
03:11:02 <ertesx> phadej: an infinite loop is the correct result
03:11:30 <stobix> phadej: ah, yeah, that example makes more sense
03:11:31 <phadej> ertesx: so would be many (Just 1) = Just [1,1...]
03:11:38 <xenon-> many <parser> returns a parser that, if successful, will return a list of whatever parser parses
03:11:49 <stobix> So many collects values until it gets an "empty" value
03:11:50 <ertesx> phadej: still an infinite loop, because there are infinitely many (<|>)
03:12:01 <xenon-> digit :: Parser Char;  many digit :: Parser String
03:12:14 <phadej> ertesx: infinite, but productive
03:12:20 <phadej> currently it isn't
03:12:42 <stobix> Why doesn't ⟪ take 3 .fromJust $ many $ Just 3 ⟫ work?
03:12:46 <ertesx> phadej: an unproductive infinite loop is the correct result
03:13:21 <phadej> ertesx: why?
03:13:47 <ertesx> > foldr (\x ys -> Just (x :) <*> ys) (Just []) [1..]
03:13:50 <lambdabot>  error:
03:13:50 <lambdabot>      Ambiguous occurrence ‘foldr’
03:13:50 <lambdabot>      It could refer to either ‘Data.List.foldr’,
03:13:59 <ertesx> @undef
03:14:00 <lambdabot> Undefined.
03:14:02 <ertesx> > foldr (\x ys -> Just (x :) <*> ys) (Just []) [1..]
03:14:05 <lambdabot>  *Exception: stack overflow
03:14:15 <lyxia> phadej: a productive many for Maybe wouldn't fit the spec of Alternative here http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative
03:14:27 <ertesx> phadej: that's why…  each individual (<*>) checks whether there is a Nothing
03:14:31 <ertesx> and there are infinitely many
03:14:40 <lyxia> I guess we could argue that that spec is annoying.
03:15:29 <lyxia> we could relax it to some and many just satisfying an inequality.
03:15:41 <xenon-> what is parse equivalent that returns parsed value (if any) and also the remaining non-parsed string?
03:16:30 <ertesx> xenon-: which parser library?
03:16:36 <xenon-> parsec
03:16:58 <stobix> "If defined, some and many should be the least solutions of the equations:" <-- this is where my brain exploded a few weeks ago.
03:18:30 <ertesx> xenon-: runParsecT returns the remainder in the success case
03:18:47 <lyxia> stobix: it's a domain-theoretic way of saying that the definitions of some and many must be equivalent to these equations.
03:19:22 <stobix> lyxia: to my surprise, I actually understood the equations now - which is something I wouldn't have done 3 hours ago.
03:19:46 <lyxia> stobix: to these equation, understood as haskell definitions.
03:19:47 * stobix thinks he just leveled up somewhat
03:20:08 <Guest8342> hello everyone!
03:20:12 <xenon-> I don't have runParsecT, only runParsec
03:20:23 <xenon-> and runParsec doesn't return remaining string
03:20:25 <ertesx> xenon-: it's in Text.Parsec.Prim
03:20:48 <stobix> hello mr/ms/mrs Guest8342!
03:21:19 <phadej> ertesx, lyxia, so you say that 'repeat x = x : repeat x' isn't enough to satisfy the laws? ?
03:21:22 <Guest8342> I'll try to add a nickname, new to irc. But thank you, I'm a mister 
03:21:52 <ertesx> phadej: hmm?
03:22:08 <xenon-> doesn't work? runParserT digit () "" "123asdf" returns Right '1'
03:22:17 <stobix> Guest8342: Welcome to irc, and to #haskell. :)
03:22:25 <gaqwas> hi
03:22:30 <ertesx> xenon-: runParsecT
03:22:34 <phadej> because if you define many (just x) = some (Just x) = Just (repeat x), it would satisfy alternative equations
03:22:37 <xenon-> heh
03:22:45 <phadej> given `repeat x = x: repeat x`
03:22:48 <lyxia> ertesx: Currently there is one "correct" definition but why wouldn't you allow more defined definitions?
03:23:15 <ertesx> lyxia: *i* would =)
03:23:26 <xenon-> what do I put as State s u?
03:23:45 <lyxia> Great, so we agree.
03:24:07 <lyxia> phadej: it satisfies the equations but it's not the least solution.
03:24:10 <ertesx> xenon-: in other words: you basically have to learn how parsec works now =)
03:24:39 * stobix just stumbled upon generic interface classes. Why is there always something totally new to learn?
03:25:01 <stobix> s/interface/constructor
03:25:24 <phadej> lyxia: I'm confused, what's "least"
03:25:24 <xenon-> i pretty much know enough to create any parser I wanted so far.. but apparently a parse equivalent that returned (String, <result>) was too simple
03:25:53 <xenon-> No instance for (Show (Consumed ([Char] -> Reply s0 u0 Char)))
03:25:58 * xenon- cries
03:26:46 <ertesx> lyxia: by law: many c = many (liftA2 (:) c (many c)) <|> pure []
03:27:14 <ertesx> infinite recursion with (<*>) on Maybe will *always* loop
03:27:32 <ertesx> so there is no solution that doesn't loop, not the least, and not any other
03:28:08 <ertesx> this is a basic property of any monad with a left-catching (<*>)
03:28:17 <ertesx> s/monad/applicative/
03:28:27 <lyxia> oh
03:28:49 <stobix> > many Nothing
03:28:50 <lyxia> wait no I disagree.
03:28:51 <lambdabot>  Just []
03:28:54 <stobix> look, it stopped
03:28:55 <stobix> :p
03:29:08 <ertesx> because you hit the left-catch case
03:29:18 <stobix> yeah
03:29:31 <ertesx> yeah, it doesn't always loop, but you need to hit the failure case
03:29:55 <stobix> "No non-trivial solutions" as one would say in mathematics
03:30:01 <ertesx> try this with your favourite parser library:  many (pure ())
03:30:22 <phadej> parsec would throw a runtime error
03:30:28 <phadej> so not a good example ;)
03:30:40 <ertesx> phadej: i'm pretty sure that wouldn't be parsec
03:30:53 <ertesx> it might be the RTS that throws a "<<loop>>" at you
03:31:02 <phadej> ertesx: no, parsec throws a runtime error
03:31:20 <phadej> "many called on an parser accepting empty input"
03:31:20 <ertesx> phadej: i don't see why it would
03:31:21 <phadej> etc.
03:31:25 <ertesx> ah
03:31:41 <ertesx> ok, so parsec's 'many' is incorrect then =)
03:31:46 <phadej> so if parsec bends the laws, why wouldn't Maybe
03:32:20 <ertesx> i think parsec should be fixed instead
03:32:24 <phadej> I'm still don't get how _|_ is least than Just [x,...]
03:32:25 <lyxia> ertesx: it will always loop for Maybe if you just use the equations as Haskell definitions.
03:32:51 <xenon-> Ambiguous occurrence 'try' ... It could refer to either 'Text.ParserCombinators.Parsec.try',  or 'Text.Parsec.Prim.try',
03:32:53 <phadej> so, if someone understands it. please make the documentation in base clearer
03:32:53 <xenon-> is this a bug?
03:33:07 <ertesx> lyxia: any definition that satisfies this equation will loop
03:33:35 <ertesx> the problem is that (<*>) is strict in its right argument
03:34:12 <ertesx> it's basically the same reason why (foldl' (+) 0) can't return on an infinite list
03:34:17 <ertesx> even if that list happens to be (repeat 0)
03:34:42 <ertesx> and it would be equally wrong to say: "oh, come on, (foldl' (+) 0 (repeat 0)) is just 0!"
03:36:40 <ertesx> (actually foldr would be better in this case, so replace every foldl' by foldr)
03:37:18 <Gilgames1> Hello, is there anyone who knows if there is a built in function that finds a sequence in a list then replace the sequence with a function (given as arguement)?
03:37:40 <ertesx> Gilgames1: with a function?
03:37:41 <Gilgames1> By that I mean replace the sequence with the output of a function 
03:37:45 <ertesx> ah
03:37:55 <ertesx> Gilgames1: what type would that function have?
03:37:59 <Gilgames1> Sorry should have specified
03:38:15 <EvanR> so like a string replace
03:38:17 <Gilgames1> Well I'm trying to make an evaluator for a subset of lisp
03:38:43 <xenon-> any issues with this parser that i am missing? it seems to work fine. http://lpaste.net/340433
03:38:49 <Gilgames1> So (+ (- 1 2) 3) I want to be evaluated as 1-2 + 3
03:38:50 <phadej> ertesx: why? assume there is infiniteSum :: a -> a, which says "if defined infiniteSm should be the .. solution of the equation infiniteSum x = x + infiniteSum x"
03:38:57 <ertesx> Gilgames1: i'm pretty sure it doesn't exist predefined in base, but it's easy enough to define yourself
03:39:05 <Gilgames1> I see, thanks mate
03:39:14 <phadej> than why it's incorrect to define `infiniteSum 0 = 0; infiniteSum x = error "divergence"`
03:39:23 <phadej> it's not useful, but is it incorrect?
03:39:28 <ertesx> Gilgames1: wait, you want to write an *interpreter*?
03:39:29 <EvanR> thats.. not solvable with a sequence replace
03:39:42 <dibblego> FWIW, I fixed reverse.
03:39:42 <Gilgames1> Pretty much
03:39:43 <dibblego> > length . take 1223 . reverse . reverse $ ['a'..]
03:39:43 <dibblego> 1223
03:39:43 <EvanR> you want to evaluate an expression tree 
03:39:46 <lambdabot>  1223
03:40:06 <Gilgames1> Not an expression tree, Lisp takes operators as Atoms it seems
03:40:06 <ertesx> Gilgames1: in that case i suggest that you read the expression into an AST first
03:40:12 <MarcelineVQ> dibblego: :O
03:40:24 <xenon-> also, given an integer part and decimal part (as Integer) of a float, how do i construct a Double?
03:40:31 <Gilgames1> So I'm not constructing an AST
03:40:38 <lyxia> ertesx: http://lpaste.net/340435
03:40:53 <EvanR> Gilgames1: it would be much simpler if you did
03:41:15 <ertesx> phadej: and how would (foldr (+) 0 (repeat 0)) be replaced by that?  you can't *ask* whether a list is infinite
03:41:34 <Gilgames1> I know, but I sort of want to stay true to Lisp, either way I'll give a couple of ideas a shot. Let's see where that takes me. 
03:41:40 <phadej> ertesx: I don't mention a foldr nor infinite list
03:41:46 <EvanR> thats the thing
03:41:51 <Gilgames1> EVanR: Thanks for the help though!
03:42:03 <phadej> ertesx: I just say that infiniteSum should satisfy the equation
03:42:10 <EvanR> lisp lore often confuses people because they arent explicit about what things are, even though thats what they are
03:42:12 <BartAdv> I've got some external lib, built by external tool, now I want to write some glue code and use it via FFI. Everything builds fine, but when I try to run GHCi, it complains: first about missing -fPIC, and when I recompile it with -fPIC, it says "Loading archives not supported"
03:42:28 <EvanR> (+ (- 1 2) 3) is denoting a tree
03:42:28 <BartAdv> The files where I repro this case are here: https://gist.github.com/BartAdv/c09007da15c12e92ef0db1cc17fbcc45
03:42:58 <EvanR> evaluation is an operation on the tree, not that pretty printed string
03:44:03 <EvanR> so if staying true to lisp lore means doing things in an adhoc oddball manner, go ahead
03:44:04 <MarcelineVQ> dibblego: SnocBuilder?
03:44:15 <xenon-> this seems rather lame.. but google gave me similar answer. constructDouble x y = read $ show x ++ "." ++ show y
03:44:20 <ertesx> phadej: but infiniteSum diverges on Integer *by definition*
03:44:22 <lyxia> phadej: The ordering is defined with _|_ being less than any other value, and a value x is more defined than another y if, informally, it replaces occurences of _|_ in y with more defined values.
03:44:29 <ertesx> phadej: regardless of its argument
03:44:49 <dibblego> MarcelineVQ: rev xs = let go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in go xs (rev xs)
03:45:22 <Gilgames1> Hmm.. I'll at least look into the documentation of lisp again
03:45:22 <Gilgames1> Thanks mate, I appreciate you taking the time to give me a hand
03:46:10 <ertesx> lyxia: do we agree that (forall v. many v = ((:) <$> v <*> many v) <|> pure []) is a law?
03:46:29 <lyxia> ertesx: sure
03:47:31 <ertesx> lyxia: then your proof has to be incorrect, because by that law 'many' for Maybe *has to* diverge
03:47:39 * hackagebot bgmax 0.2.0.0 - Parse BgMax-files  https://hackage.haskell.org/package/bgmax-0.2.0.0 (petterb)
03:47:41 <lyxia> ertesx: No it doesn't have to.
03:47:49 <ertesx> lyxia: how?
03:50:42 <MarcelineVQ> dibblego: that's really neat, I'll have to examine it closer, I'm having trouble finding a reverse like that in base src though, or rewrite rules that would produce it
03:50:46 <lyxia> ertesx: what you proved is that if we interpret these equations as Haskell definitions, then it diverges. Because the least solution is bottom and in Haskell equations pick the least solution.
03:51:02 <dibblego> MarcelineVQ: I write my own base functions.
03:53:09 <MarcelineVQ> Oh I'm an idiot, I thought the list was infinite
03:53:58 <James123> I have a type data MyType a = MkMyType (Map.map a (Set.Set a)), and I want a function myinsert mytype key val with signature MyType a a -> MyType, but I am not sure how to do that. Any hints?
03:54:39 <James123> Signature should be MyType a (Set a)
03:55:13 <dibblego> MarcelineVQ: it still works if the list is infinite
03:55:37 <dibblego> > let rev xs = let go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in go xs (rev xs) in length . take 1223 . rev . rev $ [1..]
03:55:41 <lambdabot>  1223
03:56:47 <quchen> James123, first pattern match on the MyType to gain access to the contained Map, then insert your element into that one.
03:58:28 <MarcelineVQ> I was confused because just trying `length . take 1223 . reverse . reverse $ ['a'..]` in a fresh ghci session worked, and it should, but I was also thinking it was [1..] which shouldn't
04:03:30 <ertesx> lyxia: the only way i see to interpret these equations differently is by applying other laws to rewrite them, and i see no way to get rid of the infinite (<*>)
04:04:25 <ertesx> a simple rewrite that puts a (<|>) after finitely many steps would be enough
04:04:31 <lyxia> ertesx: there's no infinite (<*>). I'm not sure how to explain that.
04:04:49 <ertesx> lyxia: what does "=" mean to you?
04:05:23 <ertesx> to me it loosely means: "semantically indistinguishable"
04:06:10 <lyxia> Perhaps a more concrete meaning is equal denotations?
04:06:38 <ertesx> yeah, that would work
04:07:56 <ertesx> and we agree that "=" acts like equality, so we can rewrite?  (forall f x y. x = y -> f x = f y)
04:08:25 <lyxia> okay
04:09:30 <ertesx> then 'many' has to be denotationally equal to an infinite expansion of (<*>)
04:09:36 <ertesx> and that one, for Maybe, loops
04:09:51 <lyxia> No.
04:10:55 <lyxia> How do you get that infinite expansion
04:11:39 <ertesx> many v = ((:) <$> v <*> many v) <|> pure []
04:11:41 <lyxia> you can rewrite one side of the equation to have arbitrarily many nested occurences of (<*>), but that doesn't implu any "infinite expansion"
04:12:08 <ertesx> = ((:) <$> v <*> (((:) <$> v <*> many v) <|> pure [])) <|> pure []
04:12:16 <ertesx> = ((:) <$> v <*> (((:) <$> v <*> (((:) <$> v <*> many v) <|> pure [])) <|> pure [])) <|> pure []
04:12:18 <ertesx> etc.
04:12:40 * hackagebot if 0.1.0.0 - (?) and (?>) conditional operator  https://hackage.haskell.org/package/if-0.1.0.0 (winterland)
04:13:29 <lyxia> yeah you get infinitely many equations, none of which contradict the fact that many v can be defined.
04:14:05 <ertesx> we still seem to disagree on what "=" means
04:16:30 <ertesx> anyway, this discussion is pointless…  i'm glad the Alternative laws force us to agree on the implementation anyway =)
04:16:51 <lyxia> :(
04:17:00 <phadej> I still disagree
04:17:29 <phadej> e.g. in regex-applicative, it's essential that many is special case
04:17:40 * hackagebot cielo 0.1.2.0 - Cielo API v3 Bindings for Haskell  https://hackage.haskell.org/package/cielo-0.1.2.0 (yamadapc)
04:17:43 <phadej> denotationally they are the same, but operationally no
04:18:23 <ertesx> phadej: that's fine, because at some point the parser will fail
04:18:42 <ertesx> otherwise that one would have to loop as well
04:18:55 <ertesx> again, try this:  many (pure ())
04:19:21 <Squarism2> Maybe a stupid question; does there exist some translation of haskell code into something that is more close to human language?
04:19:56 <phadej> ertesx: 
04:19:56 <phadej> λ Prelude Text.Regex.Applicative > match (many (pure ())) ""
04:19:56 <phadej> Just []
04:20:02 <ertesx> the difference between parsers and Maybe is that parsers have state, so at some point the 'p' in (many p) will fail, leading the whole chain of (<|>) to collapse into a defined value
04:20:12 <ertesx> phadej: then that implementation is incorrect
04:20:34 <liste> Squarism2: do you mean a tool that converts Haskell code to natural language?
04:21:03 <phadej> I'm leaning to the fact that alternative laws are stated in a way, which makes you interpret them over strictly
04:21:13 <phadej> otherwise there is no reason to have many or some in the Alternative
04:21:22 <phadej> if they have to behave as default implementation
04:21:33 <Squarism2> liste, yes exactly. (i would be suprised if there was)
04:23:27 <ertesx> phadej: they can be made a lot more efficient, especially because by the default definition (which is just the laws themselves) the (<|>) never get to be evaluated until the parser fails…  this can be optimised away
04:23:31 <mmachenry> Squarism2: The only thing I know of, is a program that does this for C. Maybe there's more than one but if I recall one of them was created as a protest and demonstration of the failability of wording in the Digital Millenium Copyright Act.
04:24:14 <ertesx> phadej: it's the same reason (*>) and (>>) are class members: you don't get to choose what they do, just how they do it
04:24:57 <mmachenry> Squarism2: It does not produce English that is more readable than the C code though. It's terrible for readability. It's a joke as well as a political point. But if you're desperate for a Haskell -> English compiler right now, you could tie together an existing Haskell->C compiler and this. The resulting English would be so far from your Haskell, though that it'd be totally alien. 
04:26:33 <phadej> also
04:26:34 <phadej> λ Prelude Text.Trifecta > parseTest (many $ pure ()) ""
04:26:34 <phadej> (interactive):1:1: error: 'many' applied to a parser that accepted an empty string
04:26:37 <phadej> <EOF> 
04:26:59 <ertesx> phadej: that one is correct
04:27:21 <ertesx> it's bottom
04:27:58 <phadej> > parseTest (pure () <|> undefined) ""
04:27:58 <phadej> ()
04:28:01 <lambdabot>  error:
04:28:01 <lambdabot>      Variable not in scope: parseTest :: f0 () -> [Char] -> t
04:28:44 <ertesx> phadej: try this:  many (pure False) <|> pure True
04:28:48 <ertesx> uh, wait
04:28:51 <ertesx> phadej: try this:  many (pure False) <|> pure [True]
04:29:03 <phadej> that will fail too
04:29:27 <phadej> same message
04:29:40 <ertesx> if 'many' is implemented correctly, then yes…  but it could be implemented in a way that it's a parse failure instead of bottom, which is wrong
04:29:52 <ertesx> yeah, i don't expect edwardk to violate laws =)
04:30:26 <Squarism2> mmachenry : heh.. that does sound like reciepe for disaster. My idea was that some math can be easily "translated" into natural language. I figured that haskell beeing lambda calculus beeing math-ish, someone clever had found a nice mapping =D
04:31:08 <ertesx> phadej: in other words: so far trifecta is the only library that does the right thing
04:31:32 <phadej> I still think that the law should be relaxed, if I have an overly smart implementation of parser library should be able to return an infinite list
04:31:58 <ertesx> what would that law look like?
04:32:15 <ertesx> you would have to downright declare that this is an alternative correct implementation
04:32:30 <phadej> take the "least" out of current definition
04:33:14 <ertesx> it wouldn't change anything for parsers or Maybe, because (<*>) would still be strict
04:33:21 <phadej> I disagree
04:33:35 <ertesx> if a function is strict, then most defined = least defined
04:33:47 <phadej> I want be able to rewrite "many (pure x)" into "pure (repeat x)"
04:34:09 <lyxia> I still have this proof to be proven incorrect http://lpaste.net/340435
04:34:10 <phadej> ah, that doesn't make sense
04:34:20 <phadej> (my line)
04:34:34 <phadej> or does it
04:34:37 <phadej> I'm not sure anymore :P
04:35:52 <phadej> I agree with lyxia, imho some (Just x) = Just (repeat x) is lawful
04:36:32 <phadej> maybe I have to write a mail to libraries to propose the change (or first dig if it was already proposed and rejected)
04:37:47 <lpaste> ocramz pasted “Polymorphism over Double and Complex Double” at http://lpaste.net/340455
04:38:20 <ocramz> ^ can I get some help here please? A typeclass design problem
04:39:30 <lyxia> ocramz: why not dot :: f e -> f e -> e
04:39:46 <ertesx> lyxia: i see how your proof works, but either it is wrong, or somehow we have to reject the congruence law for equality
04:40:13 <ocramz> lyxia: the inner product should return a real number
04:40:27 <ocramz> and e can be Complex, in general
04:42:41 <lyxia> ertesx: How is your reasoning different from, "f = id <*> f" is a law, therefore "f = id <*> f = id <*> (id <*> f) = id (id <*> (id <*> f)) = ..." and we have a problem
04:43:18 <lyxia> s/id/pure id/
04:44:18 <ertesx> lyxia: you're right
04:44:32 <lyxia> ocramz: dot will not work for all a. The real scalar type will depend on e
04:45:12 <xenon-> is use of try appropriate in here? http://lpaste.net/340456
04:45:43 <ocramz> lyxia: yes indeed. I'll try with TypeFamilies. Thanks!
04:46:16 <ertesx> lyxia: my reasoning error is that i applied the congruence law infinitely often
04:46:18 <lyxia> ocramz: or "Hilbert f e a"
04:47:45 <lyxia> xenon-: depends on whether you have other tokens to parse that start with digits.
04:48:41 <xenon-> lyxia but that parser is self containing, it shouldn't matter how it is used
04:48:55 <xenon-> i'm just not entirely sure if I should use try within it, or let the caller decide whether to use it
04:50:15 <ggVGc> I've been trying to understand what this conversation is about for the past 10 minutes
04:50:18 <ggVGc> but I'm still not sure
04:59:19 <phadej> lyxia, ertesx: so we could define some and many as in http://lpaste.net/340435
04:59:43 <James123> Does anyone remember how to have a name for the pattern match? It was something using `@', but I can't find it online
05:00:02 <ertesx> phadej: yeah, if the law would be relaxed
05:00:19 <phadej> ertesx: ... to without "least" 
05:00:21 <phadej> ertesx: ... to without "least" ?
05:00:25 <ertesx> yeah
05:00:49 <ertesx> James123: example: f xs@(x : _) = …
05:01:06 <James123> ertesx: thank you :)
05:01:20 <phadej> cool, good our opinions converged at the end. thanks you both :)
05:01:22 <Netwolf>  telnet 201.232.104.108 21
05:01:22 <Netwolf> Trying 201.232.104.108...
05:01:22 <Netwolf> Connected to 201.232.104.108.
05:03:12 <ertesx> phadej: it's less a matter of converging opinions, and more a matter of me being an idiot and finally realising it…  sorry for wasting your time
05:05:37 <stobix> why is it called "pure"? My memory thinks it's stupid and does not wanna remember it.
05:05:44 <phadej> ertesx: no time wasted. TIL what's the "least" means there.
05:06:27 <phadej> > The idea is that pure embeds pure computations into the pure fragment of an
05:06:29 <phadej> effectful world
05:06:30 <lambdabot>  <hint>:1:71: error: parse error on input ‘of’
05:06:56 <phadej> from http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
05:07:24 <ertesx> stobix: the applicative laws pretty much guarantee that 'pure' can't have effects
05:07:41 <wagnerf> hi, I changed my linux distribution today and now stack cannot build my project anymore
05:07:49 <stobix> oh. heh. well then. I guess.
05:08:16 <ertesx> stobix: also try to come up with a better name =)
05:08:18 <wagnerf> i get a lot of  relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC
05:08:38 <wagnerf> this seems to be a known problem
05:09:01 <stobix> ertesx: elevate. Or any other thing that is a verb. :p
05:09:16 <ggVGc> ertesx: why "pretty much"?
05:09:18 <ertesx> stobix: is a verb really a good idea?
05:09:38 <stobix> ertesx: map, lift, return, pure. Spot the odd one.
05:09:39 <ggVGc> a verb is a very bad idea, imo
05:09:47 <ggVGc> since you're wrapping a value in a context
05:09:54 <ertesx> ggVGc: i bet there is some super-weird Applicative somewhere that somehow manages to sneak effects into 'pure' without breaking the laws =)
05:10:14 <ggVGc> fair
05:10:21 <stobix> ggVGc: oh. I think "wrap" would be an excellent word for it then.
05:10:32 <ggVGc> stobix: well, but that's way too general
05:10:50 <wagnerf> is there a way to pass compiler flags to "stack build" ?
05:10:58 <stobix> ggVGc: Ah. Yeah, let's go for something more specific. Like "pure". :p
05:11:13 <ggVGc> stobix: pure makes sense to me, tbh
05:11:15 <ertesx> stobix: i think the other ones are odd
05:11:22 <ggVGc> it's the pure value in the computation context
05:11:33 <hpc> wagnerf: look in stack.yaml
05:11:40 <ertesx> stobix: sin, sqrt, abs, map, spot the odd one
05:11:40 <ggVGc> the one without side effects, in a context where things can have side effects
05:11:58 <hpc> wagnerf: stack does reproducible builds so anything you do that modifies how it builds needs to go in there
05:12:12 <stobix> ertesx: I'd like to see you sin over a list.
05:12:13 <hpc> (to keep that guarantee)
05:12:28 <stobix> (Or, no, don't. That sounded kinky.)
05:12:58 <ertesx> stobix: the point is: we don't have any consistency in our naming, not even in something like Num:  abs vs. negate
05:13:05 <ertesx> hehe
05:13:09 <stobix> But, yeah, sure. If return et al were adjectives as well I'd be less bugged about it.
05:13:55 <ertesx> in general i prefer nouns, because then i can say "of"
05:14:04 <ertesx> sin 3: "the sine of 3"
05:14:38 <ertesx> adjectives are fine, too, but verbs are weird
05:14:58 <ertesx> they make sense in the context of monads
05:15:01 <hpc> ertesx: abstractMorphismLifter :: Functor f => (a -> b) -> f a -> f b
05:15:02 <hpc> ;)
05:15:22 <wagnerf> hpc: yeah I thought so but since i'm not sure about the flag to give and the field to change in the file this leaves a lot of uncertainties
05:16:06 <hpc> ah yeah
05:16:11 <stobix> So, basically, "action; x <- question; pure x" is better than "do; x <- ask; return x"?
05:16:12 <hpc> i don't know enough about PIC to help you there
05:17:39 <wagnerf> hpc: ok, thanks anyway
05:19:01 <stobix> ertesx: For me it's the other way around; Mathematical functions tend to have their own names, for historical/hysterical reasons - like sin, abs et al - but new things that denote actions seem weird if they are not verbs. I mean, we're not programming java here. 
05:19:44 <ggVGc> today I think I'm gonna write my first ever actual Applicative. I want to return a result, but also generate a list of actions(ADT instances). Is this the right fit for an Applicative instance?
05:19:56 <MarcelineVQ> wagnerf: the only one I know to try is -no-pie
05:20:18 <hpc> ggVGc: so basically ([action], result)?
05:20:29 <ggVGc> hpc: yeah, but I want to be able to build it in a better way
05:20:44 <ggVGc> hpc: that's what I'm doing right now, but the code isn't very nice to write. Since actions can be generated at any point
05:20:47 <hpc> should be doable
05:20:50 <ggVGc> while building the result
05:21:00 <hpc> pure x = ([], x)
05:21:26 <hpc> it's basically Writer actually
05:21:32 <ggVGc> hm, that's true
05:21:34 <ertesx> stobix: i dislike names like "return" for the same reason i dislike "getName"
05:21:34 <hpc> with the [a] Monoid
05:21:35 <ggVGc> I should use writer
05:21:38 <ggVGc> yeah, thanks
05:21:58 <ggVGc> turns out today is not when I write my first Applicative
05:23:17 <MarcelineVQ> wagnerf: https://github.com/corsis/clock/issues/43 mentions adding "adding cc-options: -fPIC to the cabal file" until the issue has been resolved
05:24:26 <squall> ggVGc: its normal that common patterns are already in existence, its nice to find your use case is actually a common function. its probably more helpful to find where the literature that supports your concept is by identifying its name...
05:24:27 <stobix> ertesx: Having classes named as nouns and adjectives makes sense to me. Those are things. That which you do with things I'd like verby. But, yeah getFoo is just a way to put extra strain on your fingers by overtyping. Would you rather have state than runState?
05:24:54 <squall> better than reinventing the wheel...
05:25:01 <ggVGc> squall: sure, that's why I've never writte any type class myself yet, and never a monad or applicative instance
05:25:23 <ggVGc> if I can go through my whole haskell career without ever writing a type class, that'll be great
05:25:43 <ggVGc> actually, I just realised I hve written one. But I'm pretty sure it's a very bad use of type classes
05:25:50 <squall> which one is that?
05:26:27 <wagnerf> MarcelineVQ: thanks for the tip. it's not working but i'll further down the thread
05:26:48 <ggVGc> oh, ehm, it doesn't really matter. I've been trying to build a way generically combining sequencers
05:26:56 <ggVGc> and I used a type class for the common interface between them
05:27:04 <ggVGc> but I should maybe go back to just using a record of functions
05:28:00 <ertesx> stobix: it's a matter of intuition, because variable names are the most apparent connection between programming languages and natural languages…  since i like to say "f of x", nouns make a lot more sense to me, and "do f to x" is a more imperative intuition, which i don't have
05:28:28 <kuribas> What's better design, to include lenses in the package, or in a separate package?
05:29:16 <ertesx> kuribas: same package…  note that you can define lenses without a dependency on a lens package
05:29:55 <squall> ertesx, am i right in thinking its basically a getter and a setter?
05:30:01 <kuribas> ertesx: th is convenient, because I have a lot of fields.
05:30:25 <ertesx> squall: "it"?  lenses?
05:30:34 <squall> yea
05:30:51 <MarcelineVQ> wagnerf: the last post could be relevant to you, https://github.com/commercialhaskell/stack/issues/2712
05:31:14 <ertesx> kuribas: see microlens-th
05:31:20 <ertesx> @package microlens-th
05:31:20 <lambdabot> http://hackage.haskell.org/package/microlens-th
05:31:42 <stalk> jedai: hi
05:31:46 <ertesx> squall: basically yeah…  it's a first-class field accessor (getter + setter)
05:31:58 <stobix> ertesx: so you don't map functions over collections, but rather... have mappings of functions over collections?
05:33:44 <wagnerf> MarcelineVQ: yes, this seems exactly it
05:33:48 <wagnerf> MarcelineVQ: thanks
05:34:00 <kuribas> ertesx: If I define them in the same package, are the fields supposed to be with underscores?
05:34:41 <ertesx> stobix: i don't really know…  if i visualise it, it's still like "doing", but it's more like me mapping the function over the collection than 'map' doing it
05:35:05 <ertesx> kuribas: that's a common convention
05:35:25 <kuribas> hm, okay
05:35:33 <stobix> ertesx: ah, maybe there is where we think differently. I see it as telling the computer to do it.
05:38:02 <squall> i had a look at microlens but its not so straightforward...
05:38:24 <wagnerf> MarcelineVQ: hey it works ! thanks a lot ! i'm back to coding 
05:38:25 <ertesx> stobix: i think i thought the same way a few years ago, but back then my mind was more C++-oriented, where i would literally tell the computer to do things
05:38:55 <MarcelineVQ> wagnerf: awesome!
05:39:06 <ertesx> stobix: now it's more like rewriting expressions to me, but the reason is not FP, but rather laziness
05:39:52 <ertesx> squall: microlens is not *easier*, it's just lighter…  you should learn with the lens package
05:40:16 <squall> its a lot to digest
05:40:35 <stobix> ertesx: hm. Yeah, I guess that helps in a Haskell setting if you don't wanna get surprised. There are still a lot of "magic" things I have a hard time grasping right now, like ArrowLoop.
05:40:37 <ertesx> squall: https://github.com/ekmett/lens#lens-lenses-folds-and-traversals
05:41:36 <squall> i guess its just difficult to understand how those operators are implemented
05:41:40 <ertesx> stobix: ArrowLoop is best understood by working with it, especially with AFRP, because then causality plays a role
05:41:51 <squall> im used to simple recursive definitions without a lot of class overhead
05:42:05 <ertesx> squall: do you typically learn better bottom-up or top-down?
05:42:39 <squall> the former
05:43:08 <ertesx> squall: then perhaps you might find this easier: https://github.com/ekmett/lens/wiki/Derivation
05:43:47 <squall> i have a good deal of intuition, but its really hard to see eg how composition of accessors works under the hood, and without this it feels a little uncomfortable to use
05:46:21 <stobix> ertesx: googling on AFRP gives me "Animal Friends Rescue Project", "American Federation of Ramallah, Palestine", and "Afro". I might need some clarification here.
05:46:48 <ertesx> stobix: FRP = functional reactive programming, and A = arrowised
05:47:01 <stobix> Oh.
05:48:57 <ertesx> squall: yeah, lenses aren't super-easy to understand, but i still recommend learning them, if necessary by implementing everything yourself
05:49:40 <ertesx> squall: (you'll see that they're far more than just getters and setters)
05:50:09 <squall> this package looks good... is there an overlap between the arrows formalism and lenses?
05:50:10 <squall> http://hackage.haskell.org/package/Animas-0.2/docs/FRP-Animas.html
05:50:12 * stobix puts (A)FRP on his list of to-learn's
05:50:34 <ertesx> i recommend yampa over animas
05:50:57 <ertesx> or you can use my own library: https://hackage.haskell.org/package/wires
05:51:15 <ertesx> it's similarly sparsely documented =)
05:51:40 <EvanR> basic lenses of the form (A -> B) -> C -> C are easy to understand
05:52:02 <EvanR> lens then goes further and does acid / steroids
05:52:22 <squall> ertesx: oh i remember, the reactive bit is about real time modification right? i have been using stm for that...
05:52:31 <EvanR> well, (A -> A) -> C -> C
05:54:13 <squall> is that the smae kind of wire as in bananas lenses and barbed wire? in which case what are bananas?
05:54:15 <ertesx> squall: i don't think there is any formal definition of "reactive", but it's more like: "get rid of callbacks"
05:54:28 <ertesx> squall: however, FRP is something very specific
05:54:33 <EvanR> squall: no
05:54:43 <squall> oh ok
05:54:45 <ertesx> so you will notice similarities between all FRP and AFRP libraries
05:54:59 <squall> ill pop back in soon
06:02:50 <EvanR> its a good point, what is the reactive aspect supposed to be about
06:04:46 <EvanR> the concrete focus has been really about denotativeness
06:06:26 <EvanR> speaking of which i just found out about this: https://github.com/witheve/Eve
06:08:39 <EvanR> if you squint, the program on the edittable page is denoting something, the state of a collection of databases. editing the code immediately has an effect on the reports, but theres more because the programs contain update blocks
06:09:44 <EvanR> it seems to break down when it introduces "#time" and "#click" records which are sort of magical
06:11:07 <EvanR> the flappy bird demo makes use of a fast tick event, so its not continuous time
06:22:28 <joel__> help
06:22:35 <joel__> \help
06:31:11 <dsub> Regarding managing of stack projects. Sould i put the .stack-work dir in .gitignore?
06:31:24 <dsub> Or rather, is that the reasonable thing to do?
06:33:26 <BartAdv> dsub: of course. this folder grows like crazy, you'd kill your repository commiting it
06:34:17 <lyxia> dsub: put it in your global gitignore
06:44:58 <dsub> Ok, thx. New to stack so... :)
06:45:32 <Tuplanolla> I'd advise against global git ignores.
06:46:12 <Tuplanolla> What you want to commit varies wildly by technology.
06:47:17 <Tuplanolla> It's also a burden to require all contributors to write their own git ignores per project.
06:48:07 <Glitchy> Tuplanolla: Global ignores can be useful for some things (IDE tempfiles, for example, which differ between users)
06:48:27 <Tuplanolla> That I can agree with.
06:48:52 <drdo> What's the easiest way to get ghci to print every time a certain function is called (and in particular print the argument)?
06:48:52 * Glitchy can't stand it when the gitignore includes .ds_store, and tempfiles from 12 different editors :D
06:50:09 <Tuplanolla> Perhaps `Debug.Trace` would serve you better, drdo.
06:56:04 <ggVGc> would it be possible to embed this in the type system: Something like a writer, but the written value can only be set once?
06:56:28 <ggVGc> e.g a writer, but where the compiler complains if tell is called twice, essentially
06:56:46 <Tuplanolla> This sounds like linear types, ggVGc.
06:56:55 <younder> I take it Linear Logic never took off. People discovered modads instead. Would that be a fair aceccment?
06:57:24 <ggVGc> but monads don't solve this, afaik?
06:57:57 <ongy> GHC people are working on linear types iirc
06:58:01 <hodapp> ongy: link?
06:58:06 <Tuplanolla> They are still useful for resource management, younder.
06:58:09 <quchen> younder: Rust is heavily based on linear logic.
06:58:26 <hodapp> Yeah, I was going to say, Rust makes use of it, and the lesser-known-but-older ATS does too, doesn't it?
06:58:40 <ertesx> EvanR: i just had to… https://github.com/witheve/Eve/pull/567
06:58:49 <hodapp> trying to recall if Idris does or not
06:58:49 <ongy> I was thinking of https://ghc.haskell.org/trac/ghc/wiki/LinearTypes but may only be proposal
06:58:53 <EvanR> someone sent me a paper that I think people might find interesting! http://andreasholmstrom.org/wp-content/2016/05/article-cicm-new-heading-May2016.pdf
06:59:05 <ggVGc> hm, how does this look in rust?
06:59:19 <ggVGc> I mean, what part of rust can I read about to see it in action
06:59:22 <quchen> hodapp: http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html
06:59:29 <hodapp> quchen: thanks!
06:59:31 <EvanR> ertesx: excellent work
07:00:05 <ertesx> EvanR: read the name of the head branch =)
07:00:08 <EvanR> ggVGc: you can do it with an indexed monad
07:00:17 <younder> Tuplanolla, I suggested yesterday they might be usefull for verifying streams where you have a ring buffer and, assuming no drop's, a producer-consurer model.
07:00:33 <younder> consumer
07:00:40 <EvanR> ertesx: which one?
07:00:49 <James123> In my cpp version I have bool table[ MAX_SIZE ] as a global array. Is the haskell equivalent Data.Array?
07:00:50 <ertesx> EvanR: the source branch
07:00:57 <EvanR> awkward?
07:01:12 <Tuplanolla> Use `Data.Vector.Unboxed.Vector`, James123.
07:01:27 <James123> Tuplanolla, this is not in the base version, right?
07:01:47 <Tuplanolla> It's in `vector`, but that might as well be standard.
07:01:50 <EvanR> ggVGc: another name floating around outside haskell for this is "type state" or "keeping state in the type" in your case itd be an extra phantom type which is either DidntWriteYet or Written (singleton types)
07:02:03 <EvanR> extra phantom parameter
07:02:43 <EvanR> all operations would work on any type in that position, except for writing, which requires DidntWriteYet and results in changing the type to Written
07:02:45 <ertesx> EvanR: literally the first thing i noticed on that github page was the typo in their own URL
07:03:03 <ertesx> nothing earth-shattering, but it bothered me
07:03:03 <EvanR> heh yeah as i understand it its not fully baked yet
07:03:08 <quchen> EvanR: A singleton type is one with only one value. Phantom types need not be singleton, they can be anything (often the empty type).
07:03:21 <ggVGc> EvanR: hm, yeah, but a phantom type seems like it would make it quite cumbersome working with it?
07:03:30 <EvanR> indexed monads are pretty cumbersome
07:03:43 <EvanR> quchen: really, empty types work here?
07:03:51 <quchen> EvanR: As phantoms? Sure
07:03:54 <EvanR> ok
07:04:11 <quchen> When I’m lazy I use Symbol as phantom types, that works too
07:04:29 <quchen> ?let data QuchenVoid
07:04:31 <lambdabot>  Defined.
07:04:40 <quchen> :t Proxy :: Proxy QuchenVoid
07:04:41 <lambdabot> Proxy QuchenVoid
07:04:43 <EvanR> ggVGc: the main thing i ran into was, besides do notation not working anymore (but it does in idris), looping constructs must begin and end in the same "type state"
07:04:56 <ggVGc> yeah...
07:04:59 <EvanR> since we cant know what the body of the loop is going to do
07:05:04 <ggVGc> this seems like more trouble than it's worth for my specific use case
07:05:07 <ggVGc> but good to keep in mind
07:05:26 <ggVGc> would be nice to have it work with do notation
07:05:32 <EvanR> so, a loop wouldnt be able to decide to do a write at some point
07:05:35 <ggVGc> but this seems fairly difficult to implement
07:05:52 <EvanR> idris has something similar, "effects".
07:06:16 <EvanR> each effect action can modify the type state, for lack of a better word
07:06:35 <ggVGc> sounds nice
07:06:35 <lyxia> ggVGc: you can make it work with RebindableSyntax
07:06:45 <ggVGc> I kind of want to get into idris more and more every time I hear about it
07:07:03 <ggVGc> lyxia: you mean I should reimplement do-notation?
07:07:56 <EvanR> as much of a pain in the ass it sounds for such little gain... "just dont freaking write twice!"... putting all this in the type does have a compelling story to me: the operational semantics are going to be visible in the type signatures, so you might not even need docs to know wtf crazy API they set up
07:08:02 <lyxia> in the sense that you provide your own version of (>>=)
07:08:27 <ggVGc> EvanR: yeah, it's a really nice thing in many ways
07:08:46 <ggVGc> but I can see how it gets hairy to get it formalised into a type system
07:09:00 <EvanR> also this whole thread has a great moral, this is what you get when you make an API which involves "heres a variable, you may only write to it once"
07:09:13 <ggVGc> haha
07:09:15 <EvanR> its complicated
07:09:17 <ggVGc> good point
07:09:58 <EvanR> it really makes you appreciate the grocery basket of "so simple it cant fail" patterns we normally use
07:10:10 <EvanR> like map, filter, etc
07:12:18 <ertesx> the problem starts much earlier
07:12:33 <jerin> http://mathb.in/106577
07:12:34 <jerin> Can someone help me with this?
07:12:49 <ertesx> "here's a variable [and by the way, by 'variable' i mean mutable memory cell]"
07:14:07 <lyxia> jerin: there's an eta-reduction.
07:14:24 <jerin> And it one reduces to id?
07:14:30 <jerin> lyxia: 
07:14:57 <EvanR> ertesx: right
07:15:13 <lyxia> jerin: yeah
07:15:34 <Tuplanolla> @pl \ x -> x
07:15:34 <lambdabot> id
07:15:34 <Tuplanolla> @pl \ f -> \ x -> f x
07:15:34 <lambdabot> id
07:15:43 <EvanR> ertesx: but in this case, it might be simpler than that, because write-once variables can be pure
07:15:58 <EvanR> i.e. immutable variables
07:16:01 <James123> I installed 'vector', and there is either Data.Vector.Unboxed.Base or Data.Vector.Unboxed.Mutable. I should use mutable, right?
07:16:30 <maerwald> mutable variables are fine, if you can prove memory safety or other properties (like information flow control)
07:16:47 <Tuplanolla> Use `Mutable` if you're working inside `ST` or equivalent, James123. You can always go between the two types.
07:17:11 <James123> Tuplanolla, thank you
07:17:24 <Tuplanolla> See `create` for example, James123.
07:17:46 * hackagebot ginger 0.3.7.2 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.7.2 (TobiasDammers)
07:19:53 <Rag1212> guys I just updated to mac os seria and I am unable to execute `stack setup`
07:19:59 <Rag1212> to install ghc
07:20:33 <ertesx> jerin: f isn't necessarily equal/equivalent to (λ x. f x)…  you should be more specific about what you mean by "equal/equivalent"
07:21:05 <younder> Rag1212, Have you installed stack
07:21:20 <EvanR> eta conversion
07:21:36 <Rag1212> yes I installed stack using homebrew
07:21:37 <younder> Rag1212, and haskell platform
07:21:38 <tabaqui1> are there any other tls libraryies except of tls and HsOpenSSL?
07:21:40 <jerin> ertesx: Okay, the question is if the expression is eta reducible
07:21:44 <tabaqui1> *libraries
07:22:12 <tabaqui1> maybe bindings with nss or gnutls?
07:23:12 <sm> Rag1212: there's an open issue with GHC and OSX Sierra, it's probably in the stack bug tracker
07:23:37 <Rag1212> sm: what I can do to fix this?
07:23:43 <Rag1212> I'm unable to do anything :(
07:23:52 <maerwald> tabaqui1: not a real answer, but mbedTLS has a cleaner and simpler API than openssl. There are no bindings for it though
07:24:05 <sm> I don't know what this is, you could look for that issue and see if it is your problem
07:24:09 <jerin> ertesx: and how is it not necessarily equal? Can you expand when it's not?
07:24:48 <quchen> > undefined `seq` () -- jerin 
07:24:49 <Tuplanolla> They're only equal in the lambda calculus context, where all things are lambda terms, jerin. They're not equal in, say, Haskell, because types complicate the matter.
07:24:50 <lambdabot>  *Exception: Prelude.undefined
07:24:53 <quchen> > (\x -> undefined x) `seq` () -- jerin 
07:24:56 <lambdabot>  ()
07:25:13 <ertesx> jerin: there are at least three kinds of equivalence:  alpha-equivalence (by which they are different), beta-equivalence (by which they are different) and eta-equivalence (by which they are equivalent)
07:25:17 <EvanR> jerin: none of those can be beta reduced, or eta converted. they dont have the right shapes
07:25:43 <EvanR> er oh
07:25:56 <EvanR> the second one can be eta reduced, in the inner lambda
07:26:11 <EvanR> and then youll need to do alpha conversion
07:29:12 <tabaqui1> maerwald: dunno, I know that haskell can call C code
07:29:21 <Rag1212> sm: I could install stack, but i cant run stack setup or stack build or anything else
07:30:04 <mooobo> can somebody explain why the following implementation of 'any' short-circuits (as intended) and thus works for infinite lists?
07:30:12 <maerwald> tabaqui1: I'd probably write the desired functionality in C around e.g. mbedTLS and the only write bindings to my "high-level C API". I did that with e.g. Swift.
07:30:33 <sm> Rag1212: ok, but that could men many things. Give precise details and we may know more
07:30:57 <sm> eg paste the command and full error output at http://lpaste.net
07:31:19 <mooobo> myAny f xs = foldr (\x y -> f x || y) False xs
07:31:33 <Rag1212> sm: when I execute `stack setup`, it gets stuck on this line
07:31:35 <Rag1212> http://lpaste.net/340498
07:31:44 <EvanR> mooobo: look at the definition of foldr
07:31:48 <EvanR> @src foldr
07:31:48 <lambdabot> foldr f z []     = z
07:31:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:32:02 <Rag1212> sm: It doesn't move forward at all. it's just stuck at that point
07:32:18 <EvanR> now imagine something is True first thing in the list
07:33:05 <EvanR> the second use of foldr to come will never be used
07:33:32 <younder> lazy indeed :)
07:33:32 <EvanR> this relies on the short circuiting of || which should be checked as well
07:34:10 <younder> Actually that is a kinda cool example
07:34:57 <sm> Rag1212: hmm. I would try adding --verbose (or whatever debug options you find in --help) and ask again on #haskell-stack
07:35:06 <ongy> I don't really like the || example. The logic || is short circuited in most languages
07:35:13 <EvanR> it is
07:35:17 <ertesx> :t foldr (\x next -> print x *> next) (pure ())  -- here is a cooler one
07:35:18 <lambdabot> (Foldable t, Show a) => t a -> IO ()
07:35:19 <sm> and check your network connectivity is good
07:35:20 <EvanR> but its not a special case in haskell
07:35:54 <younder> log it under gotcha's
07:36:30 <EvanR> @src (||)
07:36:30 <lambdabot> True  || _ = True
07:36:30 <lambdabot> False || x = x
07:36:57 <EvanR> so thats non-strict
07:37:37 <EvanR> though (False ||) is strict
07:38:09 <EvanR> not sure the right way to say it for 2-arg functions
07:38:23 <mooobo> alright... got it!
07:38:27 <Rag1212> sm: I get no errors. it's just stuck. I think the problem could be with git. Since i'm having the same issue with cargo Rust
07:38:29 <pchiusano> i really despise the name `listToMaybe`, is there a place I can get that function (preferably where it is called `head`)?
07:38:46 <EvanR> headMay
07:38:50 <EvanR> heh
07:38:51 <maerwald> heh, cargo has its own ways to be broken
07:38:52 <ertesx> pchiusano: while we're on the topic of foldr…
07:38:59 <ertesx> :t foldr (\x _ -> Just x) Nothing
07:38:59 <maerwald> Rag1212: does cabal even work?
07:39:00 <lambdabot> Foldable t => t a -> Maybe a
07:39:12 <pchiusano> headMay??? seriously
07:39:27 <Rag1212> maerwald: I have not install cabal yet
07:39:34 <younder> foldr has horrible runtime efficeency. use foldl'
07:39:34 <pchiusano> good thing they saved on those extra two characters
07:39:44 <ertesx> younder: what?
07:39:49 <EvanR> foldl' wont work there
07:39:53 <Rag1212> maerwald: I just did a fresh installation of macOS sierra.
07:39:55 <tabaqui1> maerwald: ok, what about portablity? I have to support my code on different platforms
07:39:59 <ertesx> > foldr (\x _ -> Just x) Nothing (repeat 0)
07:40:01 <lambdabot>  Just 0
07:40:06 <ertesx> younder: ^
07:40:08 <pchiusano> younder: foldr is preferred if your function is non strict in its second arg
07:40:16 <EvanR> also you should check the results of compiling a foldr like that with -O2
07:40:29 <EvanR> the results may shock you
07:40:41 <ertesx> pchiusano: i usually just use foldr there, but there is listToMaybe in Data.Maybe, i think
07:40:44 <sm> Rag1212: you haven't said if you tried what I suggested. Add --verbosity=debug maybe
07:40:52 <maerwald> tabaqui1: C is the most portable language, you just have to write the portability yourself ;)
07:40:56 <younder> but you are asking for a eager evaluation. With the worst possible heap memory allocation policy. Rewrite the algorithm
07:41:14 <EvanR> huh
07:41:15 <pchiusano> ertesx: yeah i was looking for something that wasn't horribly named
07:41:21 <maerwald> Rag1212: how do you use stack without cabal?
07:41:28 <maerwald> well, I better not ask
07:41:38 <sm> yes, don't make things worse maerwald :)
07:41:39 <ertesx> younder: foldr (\y _ -> Just y) Nothing (x : xs) = (\y _ -> Just y) x = Just x
07:41:46 <pchiusano> like, yes, I can read the type signature, I don't need the function named after the type signature, thanks :)
07:41:58 <maerwald> sm: testing cabal separately makes sense
07:42:17 <maerwald> this is about finding the source of the problem
07:42:18 <sm> sure, agreed
07:42:19 <Rag1212> sm: I get this when I execute with --verbose http://lpaste.net/340501
07:42:34 <mooobo> The || short-circuiting was obvious to me (as mentioned, it's like this in most languages). I was familiar with Clojure's 'reduce'. The short-circuiting turns out to be one of the differences between the latter and foldr.
07:42:57 <ertesx> pchiusano: depending on how you're going to use the resulting Maybe you can really use any of the Foldable functions after (take 1)
07:43:20 <Rag1212> sm: and it's just stuck at that point since forever
07:43:25 <ertesx> mooobo: note that haskell's (||) is different from most other languages in that it's a function
07:43:27 <sm> Rag1212, maerwald: ok how about git clone https://github.com/commercialhaskell/all-cabal-hashes.git
07:44:58 <mooobo> yes, I'm seeing this now. It looks like the pattern matching makes possible what other languages need 'special forms' for
07:45:11 <maerwald> we could even go further: does curl work?
07:45:15 <tabaqui1> maerwald: fine, thanks)
07:45:20 <Rag1212> sm: ok I started cloning that repo
07:45:22 <EvanR> mooobo: its the lazy evaluation, thats the secret sauce
07:45:41 <EvanR> f x y z doesnt necessarily evaluate x y or z
07:46:10 <EvanR> so everything can act like if-then-else or || if it wants
07:46:20 <mooobo> something like weak-head-normal-form..?
07:46:50 <EvanR> not sure if thats relevant here
07:47:32 <EvanR> pattern matching is actually what causes stuff to be evaluated
07:47:33 <quchen> ongy: Here’s a foldr without booleans, it checks whether the sum of all positive numbers is more than 5.
07:47:37 <quchen> http://lpaste.net/340503
07:47:41 <quchen> ?letlpaste http://lpaste.net/340503
07:47:41 <lambdabot>  Invalid paste ID.
07:47:44 <quchen> ?letlpaste 340503
07:47:46 <EvanR> rather than being responsible for not being evaluated
07:47:47 <lambdabot>  Defined.
07:47:52 <quchen> > test
07:47:56 <lambdabot>  True
07:48:03 <quchen> ^ yes, it’s more than 5.
07:48:28 <quchen> Uses “foldr (+) 0”.
07:48:54 <mooobo> yes, sounds reasonable, that the lazy evaluation is the secret. the pattern matching makes the second case untouched, and the lazy evaluation causes that what is untouched stays unevaluated..
07:48:55 <ertesx> mooobo: there is a really simple way to think about all this:  it's a game of saying, meaning and asking
07:49:12 <ertesx> mooobo: not False = True  -- if i say (not False), i mean True
07:49:13 <EvanR> mooobo: if f deconstructs x y or z to some extent, then x y or z needs to be evaluated to that depth to decide which case to go with, then that branch evaluated to WHNF will be the answer
07:49:37 <ongy> quchen: I wasn't saying that it's wrong or anything, I just don't like the || example, because that kinda works with other languages. And quite cool example
07:49:54 <Rag1212> sm: what should I do after I cloned the repository?
07:50:01 <ertesx> mooobo: case not False of True -> …  -- figure out what is meant by saying (not False) using the definitions in scope, but only up to the patterns asked for
07:50:18 <ertesx> ones = 1 : ones  -- when i say (ones) i mean (1 : ones)
07:50:39 <ertesx> case ones of x : xs -> …  -- this matches, and according to the definition x = 1 and xs = ones
07:50:45 <ertesx> because that's how ones is defined
07:50:53 <ertesx> that's a non-operational way to think about laziness =)
07:51:30 <EvanR> yeah its nice how you can get away with not thinking operationally when its lazy
07:51:42 <EvanR> but you should anyway so you dont get memory leaks
07:52:21 <ertesx> if you think like this, then "memory leaks" are wildly growing expressions
07:52:31 <EvanR> yeah
07:52:35 <ertesx> so you don't become oblivious to them
07:52:42 <ertesx> in fact perhaps it even helps one to see them
07:52:57 <EvanR> but its operational to think "if i look at this wildly growing expression, itll collapse" 
07:53:20 <EvanR> but its what you have to do
07:53:29 <ertesx> sure
07:53:53 <EvanR> quantum-mechanics like
07:54:16 <quchen> Not everything that collapses is quantum-mechanical.
07:54:35 <ongy> sometimes it's drunk people
07:54:47 <younder> lol
07:55:03 <sm> Rag1212: that was just a test. Seems like your network is fine. I would delete the repo you just cloned, and ask #haskell-stack. Or if you want to dig deeper, you could run the stack command with strace
07:55:05 <Zekka_> well I understand some things that collapse, but I *really* don't understand quantum mechanics
07:55:17 <EvanR> dont worry i also believe in classical physics, we like fantasies here
07:55:19 <Zekka_> so if you compare a collapsing thing to quantum mechanics, I probably understand it less
07:55:27 <sm> also check the stack bug tracker in case someone else has had the same problem
07:55:33 <Rag1212> sm: Okay, I'll ask the question in #haskell-stack
07:55:35 <younder> Zekka_,  Noone does !
07:55:36 <Rag1212> thanks for your replies
07:55:46 <sm> sure, good luck
07:56:09 <EvanR> Zekka_: specifically it collapses in response to your probe, thats what made me think of it. a building might "just collapse" for no reason
07:56:26 <Zekka_> oh yeah, sure
07:56:33 <younder> Zekka_,  I cn do the math. But in the end that is just bok ceeping. There is no dynamic explanation of QM.
07:56:39 <younder> book
07:56:51 <mooobo> interesting comparison. So for instance the fact that an undefined value can be around in the programm and nothing happens if nobody looks at it, e.g. tries to access it..
07:57:07 <Zekka_> > take 2 [1, 2, undefined]
07:57:09 <lambdabot>  [1,2]
07:57:15 <Zekka_> > take 3 [1, 2, undefined]
07:57:16 <younder> I find programming without mysteries.
07:57:17 <lambdabot>  [1,2,*Exception: Prelude.undefined
07:57:18 <mooobo> exactly
07:57:52 <EvanR> > take 3 [1, 2, let x = x in x]
07:57:53 * younder wonders abit about whereter P =/= NP
07:57:58 <lambdabot>  mueval-core: Time limit exceeded
07:58:00 <EvanR> :(
07:58:02 <Zekka> > foldr1 (\x y -> x) [1, 2, undefined]
07:58:05 <lambdabot>  1
07:58:10 <Zekka> > foldl1' (\x y -> x) [1, 2, undefined]
07:58:13 <lambdabot>  1
07:58:18 <EvanR> my last example should have printed 1 and 2
07:58:28 <EvanR> but lambdabot disagrees
07:58:33 <Zekka> oh hey! that's not what I expected at all! I am bad and should expand foldl1' manually
07:58:45 <younder> EvanR,  You have three arguments
07:59:08 <younder> EvanR,  so the second evaluation is left as a curry
07:59:14 <Cale> EvanR: Yeah, something might be line-buffered
07:59:24 <EvanR> younder: ghci produces this: [1,2,*** Exception: <<loop>>
07:59:25 <Zekka> yeah, in an ideal world it owuld have said the same
07:59:25 <quchen> Zekka: foldl' forces the *result* of the function you hand to it, not its arguments
07:59:41 <quchen> ?src foldl'
07:59:42 <lambdabot> foldl' f a []     = a
07:59:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:59:42 <Zekka> quchen: yeah, and I totally suspect that would have been obvious if I manually expanded it
07:59:48 <Cale> (and lambdabot is using the threaded runtime, so you might not get <<loop>> exceptions)
08:00:15 <EvanR> ah -threaded invalidates the <<loop>> trick?
08:00:42 <Cale> Yeah, to some extent. It still tries to catch them somewhat, but it has to do something more involved.
08:01:31 <Cale> Basically, in a threaded program, something might be a black hole because some other thread is evaluating it, not because you're already evaluating it.
08:02:04 <Cale> So black holes are replaced by grey holes, which in their original formulation just blocked indefinitely and waited for the value to become available
08:03:05 <Cale> Now I think there's some interaction where eventually it can detect that it's really the case that no other thread is going to be evaluating this thing, but I forget exactly how it works. It might wait for the next GC to happen.
08:03:59 <dolio> One of the papers on GHC has even black hole detection waiting for GC, I believe.
08:04:45 <dolio> Because if you're looping through a black hole, you'd be allocating stack, and would be able to detect the loop by looking at the stack.
08:04:56 <dolio> Something like that.
08:05:12 <younder> finalizing is a big mystery for me. Why would you want it. It is too unpredicayttable.
08:05:30 <Cale> younder: You're talking about ForeignPtr?
08:05:39 <younder> yes
08:06:02 <EvanR> yeah the finalizer might never get called, practically because the program might end sooner than that
08:06:23 <Cale> younder: You want it because often C libraries will allocate something in memory on your behalf and then expect you to tell them when you no longer need it any longer and want to clean it up.
08:06:43 <ongy> but if it's only internal state (memory, FDs) it will get called "at some point", which will be fine if you don't have resource problems
08:06:45 <Zekka> (if the program terminates, you probably don't care that your call to free() went forgotten)
08:07:05 <younder> Cale, But the OS cleans it up on exit.
08:07:09 <EvanR> Zekka: possibly
08:07:15 <Cale> younder: The program might not exit.
08:07:24 <EvanR> if its a fildesystem mutex, then youre kind of screwed
08:07:35 <Zekka> EvanR: yes!
08:07:35 <younder> ahh I see
08:07:38 <Cale> younder: The important case is when the ForeignPtr gets garbage collected in the middle of the program running
08:07:57 <Zekka> (disclaimer: I don't know how most OSes expose that functionality but I fully believe you that they don't clean it up on process close)
08:08:02 <Cale> younder: I'm not even sure the finalizers are guaranteed to run if the program exits.
08:08:13 <Zekka> 90% of resources are memory though
08:08:34 <younder> Zekka, OS does clean memory and close file handles
08:09:02 <Zekka> younder: i actually have to go all of a sudden, but yeah
08:09:10 <EvanR> we have atexit bindings, but i dont know if they work
08:09:26 <Zekka> i don't know about advanced file system features like locks and things though
08:09:28 <younder> In haskell :)
08:09:28 <EvanR> Cale: theyre not
08:09:35 <Zekka> it sounds like evanr is speaking from an existing bad experience so I believe him
08:09:37 <Cale> I seem to recall Ryan Trinkle needing that, and not having it. :)
08:09:49 <Zekka> the bad case: your program runs for 200 hours, and C allocates and (hopefully) frees a megabyte of memory every 10 minutes
08:09:52 <Cale> I forget what his solution was, but I believe he got it upstreamed in some form.
08:10:01 <Zekka> finalizers hypothetically make it easier to guarantee you don't just leak that megabyte
08:10:06 <Zekka> (vanishing now!)
08:12:11 <younder> Anyhow there are many forms of memory leeks. Lets ltalk about the Java mistake. a GC solves all. NO In fact you have to have a limited scope for GC to work efficiently. Early vrsions of Swing were ridden with Megabytes being wasted by pointers in downstream functions that never terminated.
08:13:02 <younder> The copied Lisp which because of the functiaonal scome (like Haskell) it worked fine. 
08:13:03 <EvanR> the more memory you have, the more efficient the GC is ;)
08:13:23 <EvanR> but latency is not necessarily good
08:14:02 <ertesx> and before you know it byorgey writes about abstraction, intuition and the quantum mechanics tutorial fallacy
08:14:22 <Tuplanolla> "Before garbage collection, data would pile up until the computer got full and you had to throw it away."
08:14:31 <EvanR> tutorials are a giant fallacy it turns out
08:14:36 <ertesx> "ooooh!  particles are like burritos!"
08:17:10 <hodapp> tutorials can be useful, the same way turn-by-turn directions can be useful
08:17:13 <younder> If you are realy intrested in Quantum Mechanics you might wana look at "Quantum computing since Democritus by Scott Arenson" A personal and informal account from a bberkley professor who teaches quanum computing.
08:17:28 <hodapp> but tutorials are sorely lacking when a map is what you need
08:18:09 <EvanR> younder: i just bought it
08:19:00 <younder> EvanR, I love the 'no coning' "theorem" ;)
08:19:05 <younder> ccloning
08:19:15 <EvanR> why scare quotes
08:19:44 <Xyliton> Hello o/
08:19:47 <younder> EvanR, Have you read it yet?
08:20:47 <EvanR> no cloning theorem is undergrad physics
08:21:11 <Xyliton> Is there anyone who could give me some tips on what I might implement in haskell to train (and get used to Haskell, actually)? I only did simple stuff like cat yet :/
08:21:33 <ertesx> Xyliton: did you do my challenge?
08:21:41 <Xyliton> the number guesser?
08:21:45 <Xyliton> *guessing game
08:21:47 <EvanR> cat is better than nothing! people get stuck writing fibbonaccis over and over
08:21:48 <ertesx> yep
08:21:57 <EvanR> or project euler
08:22:17 <Xyliton> kinda, It won't exit though
08:22:20 <hodapp> Xyliton: implement Scheme!
08:22:27 <ertesx> Xyliton: then fix it =)
08:22:58 <ertesx> Xyliton: as another challenge consider learning how to use libraries by implementing a real command line interface for your cat
08:22:58 <Tuplanolla> Every time someone asks, I suggest Risch integration, Xyliton.
08:23:08 <younder> Euler can keep you occupied fora lifetie, he wrote 100 books on matematics.
08:23:11 <ertesx> the…  the program…
08:23:34 <ertesx> Xyliton: you can use e.g. the optparse-applicative library…  it has a learning curve, but it should be easy enough
08:23:50 <ertesx> Xyliton: https://hackage.haskell.org/package/optparse-applicative
08:24:50 <Tuplanolla> As for something useful, we could do with a package to generate pathological data sets like Anscombe's quartet, Xyliton.
08:25:04 <younder> There is a new biography of Euler that came out last year which I can recommend. "Leonard Euler. Mathematical genius in the enlightenment" by Ronald S. Calinger
08:27:35 <mmaruseacph2> thanks for sharing that
08:29:36 <ski> ertesx : "abstraction, intuition and the quantum mechanics tutorial fallacy" ?
08:29:53 <ertesx> "… when he made his groundbreaking discovery…" – "ok, what did he discover?" – "it would change the world of mathematics forever" – "alright, what did he discover?" – "it all started in a little village…" – "what did he discover?!" – "this equation would become one of the most impor…" – "WHAT'S THE FUCKING EQUATION?!" – …
08:29:56 <ertesx> i can't read biographies =)
08:30:13 <ertesx> ski: you have to scroll further up for the context
08:30:23 <mooobo> is there a website that writes out evaluation steps of haskell expressions?
08:30:52 <Xyliton> ertesx: I fixed the "won't exit" problem. Now I want some text preceding the input but "putStr" doesn't seem to output anything and putStrLn adds a new-line char at the end
08:30:57 <ski> how far back (i scrolled perhaps 30 mins back)
08:31:16 <ertesx> ski: it was about learning QM and how it's contra-intuitive
08:31:24 <jedai> Xyliton: That's not really Haskell related but you're discovering the joy of buffering modes
08:31:32 <ertesx> ski: which reminded me of monads
08:32:06 <jedai> Xyliton: basically your stdout is set in lineBufferingMode which means it won't really output unless it encounter a \n
08:32:16 <jedai> Xyliton: or you flush it manually
08:32:17 <ertesx> Xyliton: import System.IO
08:32:22 <stalk> jedai: hey, was it you that commented on the issue?
08:32:31 <ertesx> Xyliton: and then (hFlush stdout) after you wrote
08:32:37 <jedai> stalk: Right, Chaddai that's me
08:32:57 <stalk> mmh, ok
08:33:00 <ertesx> Xyliton: you have to do that, because the default buffering mode of stdout for terminals is line buffering in most platforms
08:33:04 <Xyliton> ertesx: wow. that's... interesting
08:33:10 <stalk> mind discussing how to implement that?
08:33:52 <jedai> stalk: I don't have a clue, I was talking in the perspective of a package user
08:34:10 <stalk> My idea was essentially to have two modes, "slave" or "master" (but I guess naming it "follower" vs "leader" would be better)
08:34:19 <Xyliton> ertesx: I how this is random enough for you: http://lpaste.net/340521 :P
08:34:50 <Xyliton> *hope
08:34:55 <stalk> and just do git push and git push before and after each action as needed, and configure those to make the local versus remote data take precedence in function of the mode.
08:34:56 <Tuplanolla> Splice the number in with TH to make it seem more legitimate, Xyliton.
08:35:22 <stalk> jedai: ok then. I have only a vague idea of haskell programming, but I'll try to put something up
08:35:25 <ertesx> Xyliton: that doesn't really match the specification though =)
08:35:45 <ertesx> Xyliton: it should let the user know whether the guessed number is too large or too small
08:35:56 <jedai> stalk: that seems reasonable but really you should have a mode that just throw an exception if there is a conflict
08:36:03 <ertesx> Xyliton: however, i do like how you solved the comparison problem ;)
08:36:19 <stalk> jedai: yeah, possibly
08:36:36 <stalk> I'll keep you updated if you want
08:36:38 <ertesx> Xyliton: it's a good start, but it needs more work
08:36:48 <stalk> even if you don't anyway ;)
08:36:53 <Xyliton> is it possible to generate one random number at startup and keep it, even when I recall main?
08:37:11 <ertesx> Xyliton: if you want to learn libraries now, you can now use the 'random' library
08:37:26 <ertesx> Xyliton: it comes with a module called System.Random, which exports a function you might find useful:  randomRIO
08:37:28 <ertesx> :t randomRIO
08:37:30 <lambdabot> Random a => (a, a) -> IO a
08:37:30 <jedai> stalk: I'm subscribed to the issue :)
08:37:47 <EvanR> ertesx: i dont even know what intuitive is anymore
08:37:49 <ertesx> Xyliton: you give it a range, and it gives you an action back that generates a random number in that range (closed)
08:38:09 <ertesx> Xyliton: n <- randomRIO (1, 100)  -- between 1 and 100, inclusive
08:38:13 <stalk> yeah, I don't know if I should answer again, knowing that the probabilities that something happens are really thin
08:39:10 <amx> Xyliton: did you see this? https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
08:39:23 <ertesx> Xyliton: the way to use the random library is to add it to your cabal file under 'build-depends', for example:  build-depends: base >= 4.8 && < 4.10, random >= 1.1 && < 1.2
08:39:35 <jedai> Xyliton: don't do that (you can, using an IORef) but rather write another function that'll take the target number as parameter and can call itself if necessary
08:39:51 <ski> ertesx : ok
08:40:08 <Xyliton> ertesx: but how do I keep the it the same number for the whole game? Do I have to store it somewhere else? Or should I stop recursive-calling main and relocate everything into a different function?
08:40:25 <ertesx> Xyliton: you don't store it, but you write a function of it
08:40:39 <jedai> Xyliton: in other words, it is very rare to have your main call main recursively, generally you have main call another recursive function after the setup is done
08:40:44 <ertesx> Xyliton: main = randomRIO (1, 100) >>= guessGame
08:40:51 <ertesx> Xyliton: guessGame :: Integer -> IO ()
08:41:02 <Xyliton> Oh, I see
08:41:06 <boxscape> hi, I have custom print function in my ghci.conf, that depends on certain packages. When I start ghci inside a stack project, however, ghci complains that it can't find those packages. Is there a way to tell ghci to load those packages without adding them to any of the stack config files (since they're only needed for ghci, not for installation)
08:41:17 <boxscape> (or rather, it complains that those packages are hidden)
08:42:49 * hackagebot workdays 0.1.1 - Workday calculations  https://hackage.haskell.org/package/workdays-0.1.1 (jpvillaisaza)
08:44:54 <sm> boxscape: where is ghci.conf, and how do you start ghci ?
08:45:11 <boxscape> sm: in ~/.ghc, and I start it with 'stack ghci'
08:48:35 <sm> boxscape: how about stack ghci --package PKG ...
08:49:45 <boxscape> sm: yes, that seems to work, thank you
08:50:26 <sm> also, I think you can add packages from within your ghci.conf, maybe like http://stackoverflow.com/a/24767649
08:50:51 <boxscape> okay, interesting
08:53:17 <Xyliton> ertesx: what about this one? http://lpaste.net/340525
08:54:34 <ertesx> Xyliton: now we're getting somewhere =)
08:55:06 <ertesx> Xyliton: next implement the other limitation: don't use (<), (<=), (>), (>=), (==) or (/=)
08:55:13 <ertesx> Xyliton: instead use the 'compare' function
08:56:40 <stalk> If a module only exports certain functions, can you still import others?
08:56:58 <jedai> stalk: No, not from another module
08:57:34 <stalk> mmh, that's a bad start
08:57:39 <mmaruseacph2> I'd use fmap read getLine instead of converting x to String for one comparison and read-ing x for the others
08:57:50 * hackagebot say 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/say-0.1.0.0 (MichaelSnoyman)
08:58:11 <stalk> I want to make a module that wraps around another one, ie implements the ~same functions and uses the original ones, how do I do that?
08:58:50 <jedai> stalk: since you're acting "from the inside", you can modify the export list (or relocate such function to an ".Internal" module then just write the "public" module as a wrapper/reexporter)
08:59:08 <stalk> ok
09:00:13 <jedai> stalk: so you have Stuff.Internal which does the heavy lifting and export many thing you don't want your user to see by default and then Stuff import Stuff.Internal and reexport just what you want your public interface to be
09:00:24 <jedai> stalk: it's a common pattern in Haskell packages
09:00:50 <mmaruseacph2> why doesn't stack play nicely with libreadline for tab-completion :(
09:01:02 <Xyliton> ertesx: Is it possible to achieve something like > and < using compare without ==? Don't I have to check if it's equal to LT or GT?
09:01:25 <jedai> :t Ordering
09:01:27 <ertesx> stalk: module Mine (myFunc1, myFunc2, T.theirFunc1, T.theirFunc2) where import qualified Theirs as T
09:01:28 <lambdabot> error: Data constructor not in scope: Ordering
09:01:30 <ertesx> stalk: like this?
09:01:34 <stalk> jedai: I think I'll just not restrict the export list while trying to work on it, and then care about having clean export. That's reasonable I expect?
09:01:36 <mmaruseacph2> stack exec executable -- -f /path/to/somewhere/deeply/nested/where/I/d/like/to/use/tab/completion.txt requires me to type that path manually :(
09:01:38 <jedai> @src Ordering
09:01:38 <lambdabot> data Ordering = LT | EQ | GT
09:01:42 <ertesx> Xyliton: yes, use 'case'
09:01:42 <kuribas> > let elementOf n l f s = evalStateT (l (StateT . (\e i -> if i==n then return (e, i+1) else (,i+1) <$> f e )) s) n; elementOf :: (Num s, Monad m, Eq s) => s -> ((t -> StateT s m t) -> t1 -> StateT s m a) -> (t -> m t) -> t1 -> m a; in preview (elementOf 3 (traverse.traverse)) [[1, 2], [3, 4]]
09:01:44 <lambdabot>  error:
09:01:45 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M387509624915...
09:01:45 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
09:01:53 <kuribas> why doesn't this work?
09:03:05 <geekosaur> mmaruseacph2, that sounds like a bug in bash completion (if stack provides a bash completion module then the bug is there; otherwise it may be a bug in some other module inappropriately being applied to stack)
09:03:13 <stalk> ertesx: I'm not sure, but you're talking about what I *export* from my module, and I'm talking about what I *use*, no?
09:03:28 * geekosaur generally doesn't even use bash completion, because he keeps running into bugs of that sort x.x
09:03:39 <mmaruseacph2> I'll look into it some weeks down in the future
09:03:53 <mmaruseacph2> first I have to finish my thesis, then the hcar, then some other bug blocking me and then this
09:04:10 <ertesx> stalk: i'm really talking about both…  Theirs has a function f, and Yours is supposed to use f using Theirs.f?
09:04:27 <ertesx> s/to use/to define/
09:04:31 <geekosaur> the native behavior is less fancy (no smart completion of long options, completion of option values baed on what the option expects, etc.) but path completion doesn't get unexpectedly turned off
09:05:04 <stalk> ertesx: yes
09:05:11 <stalk> and f is not exported by Theirs
09:05:30 <jedai> stalk: as I said you can't access it in this case
09:05:39 <jedai> stalk: it's just impossible
09:05:41 <ertesx> stalk: oh, i see…  well, then as far as Yours is concerned, f doesn't exist
09:06:11 <jedai> stalk: what you _can_ do is modify Theirs so that it export f
09:06:52 <younder> sigh: the stuff I can reproduce with a finit amout f memory is made of fully orderedsets. Which if not fr the 'full' part woud be qyuivalent to sets and thus coud express all orf math. How to express all of math with sequences. And how to label the limits issued by the Top and Bottom limits set by the computer.
09:07:23 <jedai> stalk: eventually if it doesn't seem that f is really a public part of the interface, you should write a Theirs.Internal module that is essentially the current Theirs and replace Theirs by a wrapper around Theirs.Internal that only export the "public" functions
09:07:41 <ertesx> stalk: background: if a function is not exported, the compiler may choose to inline it in its module and not even emit code for it
09:08:00 <stalk> ertesx: oh, interesting
09:08:02 <ertesx> so it literally might not exist
09:08:17 <stalk> jedai: Yeah, I'm just exporting everything for now, tidyness will come later
09:09:45 <younder> Further the issue of termination. Reduction, upper limit mu, and the mysteriious Tarsky mid point theorem
09:11:18 <younder> is Template Haskell still working?
09:12:08 <ertesx> stalk: a three-module system is quite common:  a core module (.Core or perhaps .Internal) that exports everything of internal interest (still not necessarily *everything*), individual user modules that use the core module, and a convenience module that reexports the user modules
09:13:00 <ertesx> stalk: example: https://hackage.haskell.org/package/pipes
09:13:30 <ertesx> Pipes.Internal exports *everything*, Pipes.Core exports everything of core interest, but not necessarily everything a user would need
09:13:36 <ertesx> and most modules use Pipes.Core
09:13:45 <ertesx> and finally there is Pipes, which reexports a common interface
09:16:03 <joe9> Is it a space leak when I write to a TQueue and noone is listening on the other end?
09:16:21 <joe9> or, will it garbage collected as a broadcast chan?
09:17:44 <jedai> stalk: filestore seems to be more or less two-tiered, you have the convenience module https://github.com/jgm/filestore/blob/master/Data/FileStore.hs FileStore and you have the individual modules Filestore.git and so on that implement the functionality. But you don't have the "Internal" tier (for now)
09:19:05 <stalk> jedai: I just remove the restricted export from Git.hs for now
09:25:58 <stalk> gtg, thanks for the help jedai  and ertesx 
09:29:37 <leshow> i often see mvars used for simple thread communication. the book parallelism and concurrency in haskell even referred to a mvar example as 'channels'
09:29:49 <leshow> are mvars actually channels or are they locking/unlocking some memory location
09:29:53 <younder> Why is haskell-blah ssh only?
09:30:31 <glguy> That's a good question to ask in #haskell-blah
09:30:55 <younder> glguy, I would if I could get in
09:33:00 <geekosaur> #haskell-blah is not maintained by the same folks as the other haskell channels, and the channel maintainers thinks everyone should be strongly encouraged to use SSL for everything
09:33:30 <geekosaur> #haskell-offtopic is the offtopic channel managed by the #haskell ops
09:34:59 <acowley> leshow: They are sometimes thought of as channels with a buffer size of 1
09:35:30 <younder> thx, offtopic works fine. And i get on NSA surveilance :)
09:35:56 <acowley> leshow: You can use such a thing as a lock, so they're not really contradictory views
09:36:37 <leshow> i ask because it changes the design of a program if you expect things in the channel to be memcpy to another location
09:36:43 <leshow> as in another kind of channel
09:36:47 <leshow> vs being locked/unlocked
09:36:52 <leshow> like a mutex
09:37:33 <leshow> when i write programs using mvar, should i think of it as closer to a mutex?
09:37:52 <codedmart> I want to use cabal-dependency-licenses and it says I need to run cabal configure first. How do I do that with stack?
09:38:12 <ertesx> leshow: remember that values are still immutable, so takes and puts are basically just pointer updates (a bit more though, because MVar provides a few extra guarantees)
09:38:27 <ertesx> leshow: in other words: definitely no memory copying
09:39:03 <younder> ertesx, my linear logic ..
09:39:04 <leshow> if everything is still immutable doesnt that mean it has to be copied, say if i have an mvar of a map
09:39:13 <leshow> Map
09:39:18 <leshow> Data.Map or whatever
09:39:28 <ertesx> leshow: no, why?
09:39:41 <leshow> how else would it update the map if map is immutable
09:40:00 <ertesx> "update the map if the map is immutable"?
09:40:06 <acowley> Immutability means that things aren't copied very often because a pointer to some immutable data will never get messed up
09:40:23 <terzs_> Anyone have any experience using aivika's parallel priority queue? Wondering if it's any good or if there is a better alternative I should be considering
09:40:31 <ertesx> leshow: updating a map creates a new map that shares most of the memory of the old one
09:40:44 <leshow> ertesx, ah ok, that makes more sense
09:41:15 <ertesx> leshow: so there is really no "updating" going on…  you're really calculating a new map from the old one
09:41:35 <leshow> right, but because you can count on everything being immutable you can make certain optimizations
09:41:51 <leshow> so just to backtrack and clarify, the mvar in that case is sending a ptr to the map?
09:42:07 <leshow> not the map itself
09:42:15 <ertesx> yeah, and those aren't even optimisations, those are just the evaluation strategy of GHC (it uses sharing)
09:42:25 <younder> Certain optimations usually means at tree as in "Purly functional data strucures"
09:42:40 <ertesx> putting something into an MVar is very similar to applying a function: you could call it "pointer"
09:42:44 <ertesx> but i'd just call it "value"
09:43:20 <ertesx> leshow: in haskell that *is* the map itself
09:43:22 <leshow> whatever we call it, it's not containing the entirety of the Map
09:43:40 <leshow> like if my map is 10k elements, and i insert a new one through an mvar
09:44:50 <leshow> its sending a ptr to the map, not the entire map..?
09:44:54 <ertesx> it is containing the entire map, but it's shared…  if two threads are using the map, and it's also in an MVar, there are three maps, which are semantically independent, but all three use the same memory
09:45:05 <ertesx> you really should think of it as *sharing*, not as *pointers*
09:45:45 <leshow> how do you make assumptions about how the program is going to run if you don't know whether you're sending 10k elements through a channel for an update
09:46:14 <ertesx> you assume that MVar uses sharing
09:46:27 <mmaruseacph2> you profile
09:47:05 <leshow> like is Mvar the concurrent version of an IORef?
09:47:09 <ertesx> leshow: if you pass a 10k Map to a function, you don't assume that it's copied either, do you?
09:47:40 <ertesx> but you don't think of it as passing a pointer to the function…  you're passing the value, and sharing makes sure that nothing is copied needlessly
09:47:55 <leshow> ertesx, right. i guess people calling it a 'channel' sort of through me off
09:48:10 <leshow> threw*
09:48:54 <ertesx> it's ok to think of it as a channel, if you're using it like one, but since it is used between threads that use shared memory, the value doesn't have to be copied (like it would be if you used an actual OS pipe between different processes)
09:49:01 <leshow> like in rust, if i use channels i assume it copies the actual values as in a memcpy unless i explicitly pass a reference type
09:49:35 <EvanR> an MVar is a bounded channel with a very low bound
09:49:45 <younder> On unix you want dbus on W$ com(+)
09:50:37 <EvanR> leshow: rust maybe have to do copying in order to deal with the fact that its not garbage collected
09:50:40 <geekosaur> concurrency, not ipc
09:50:52 <ertesx> leshow: yeah, that doesn't happen in haskell, where everything is immutable
09:51:04 <EvanR> mutable immutable is a different issue
09:51:28 <leshow> what about tvar vs mvar
09:51:38 <leshow> i had read mvar is faster
09:51:42 <leshow> somewhere...
09:51:42 <ertesx> TVar is like transactional IORef
09:52:11 <ertesx> MVar is almost definitely not faster =)
09:52:25 <EvanR> which one is faster in what circumstances isnt as important as the fact that TVars are transactional and always have a value, theyre not empty
09:52:30 <leshow> really? i thought it was much faster at lock/unlocking
09:52:40 <EvanR> TVars dont have locking
09:52:59 <leshow> they share memory like mvars don't they?
09:53:02 <EvanR> you can have many transactions going at once
09:53:14 <ertesx> leshow: you can assume that in general
09:53:23 <EvanR> but they may trample each other and some will be rebooted
09:53:32 <ertesx> leshow: there isn't even a straightforward way to *copy* values in the first place
09:53:36 <glguy> MVar and TVar do different things, but when used to do the same thing, MVars are faster
09:54:16 <leshow> when would i use a tvar over and mvar? like what sorts of things would i want to be 'transactional'
09:54:27 <leshow> like accessing a database?
09:54:39 <ertesx> glguy: i did a benchmark a few months ago that showed that TVar used in a non-transactional way is as fast as IORef
09:54:46 <EvanR> if you have multiple TVars you can look at them all at once as a snapshot or modify them atomically as a group
09:55:13 <EvanR> with MVars the only way to do this is have everything in one MVars
09:55:16 <EvanR> MVar
09:55:27 <EvanR> or use a mutex
09:56:18 <glguy> ertesx: If you're considering a use-pattern where an IORef is appropriate then an IORef might be the way to go
09:56:41 <leshow> IORef is non-thread safe right?
09:57:08 <ertesx> leshow: you need to be careful to use atomic functions with IORef in a multi-threaded setting
09:57:10 <geekosaur> atomicModifyIORef is a thing
09:58:30 <ertesx> leshow: you should read The Book: http://chimera.labs.oreilly.com/books/1230000000929/
09:58:58 <leshow> this is actually the book i was talking about that did an mvar example calling it 'channels'
09:59:04 <leshow> at the start of this convo
09:59:06 <Polymorphism> is haskell certified for medial uses
09:59:06 <ertesx> ah
09:59:09 <Polymorphism> medical
09:59:18 <leshow> the first mvar ex about a logging service
10:04:21 <EvanR> i support medical haskell
10:04:34 <leshow> lol
10:04:44 <sm> recreational haskell, coming soon!
10:05:03 <sm> Polymorphism: no it isn't
10:05:03 <leshow> how does a language get 'certified' for 'medical use'
10:05:11 <raichoo> legalize haskell!
10:06:22 <kadoban> Polymorphism: Never heard of that, I suspect it doesn't actually exist?
10:06:51 <geekosaur> java infamously has a big disclaimer about medical use, because a gc at the wrong time can cause problems
10:06:52 <ertesx> Polymorphism: i remember these people looking for haskell developers: https://www.checkpad.de/en
10:06:57 <geekosaur> (or perhaps had)
10:07:51 <geekosaur> (medical device control applications)
10:08:33 <younder> sounds more like mathematica(wolfram) to me
10:08:40 <leshow> maybe Rust is 'certified' then lol
10:08:47 <leshow> no GC there
10:09:14 <kadoban> geekosaur: That seems to be granting the premise that there is such a thing as being certified for "medical use", which I think I would have heard of. If nothing else, I suspect whatever languages were certified would have fanboys spouting this news often and with glee.
10:09:39 <codedmart> How can I print a list of all dependencies and there license for my project with stack?
10:09:40 <younder> With all the inmaging sofwtware buildt in there is a better ROI on the mathematica approach
10:09:47 <kadoban> It'd be kind of weird too, wouldn't it be a property of an implementation?
10:10:47 <younder> But you might differ. I don't remeber any good imaging processing lib's for haskell though. Though you can always call IageMagic
10:10:54 <younder> ImageMagic
10:11:09 <geekosaur> yes, it's actually about implementations
10:11:31 <geekosaur> and I should have said either JVM or Oracle Java to be specific about that
10:11:38 <kadoban> younder: I think it's actually ImageMagick
10:11:44 <ezyang> I'm debugging a mysterious waitForProcess deadlock, and as far as I can tell, it deadlocks when I createPipe and pass it to the process with UseHandle, and not if I use CreatePipe directly with System.Process 
10:11:55 <younder> kadoban, yes, thx
10:12:32 <kadoban> geekosaur: Wasn't that just Sun deciding that it shouldn't be used for such things though? Maybe I misremember, but I thought it was about implementations relating to nuclear power; or maybe both.
10:12:57 <younder> Anyhow steep initial investment. But then It would benefit the haskell libs
10:13:12 <younder> if shared
10:13:39 <geekosaur> nuclear control was also mentioned. but no, it wasn't "we think those are Evil" it was "beware, our implementation is not suitable for hard realtime"
10:14:27 <geekosaur> with a side of "we'd prefer not to be sued because someone ignored that"
10:14:48 <geekosaur> (and someone died as a result)
10:14:55 <kadoban> geekosaur: Right, the latter was my understanding as well. But my point is ... that's not the same as such a thing as a certification existing. That's just one language implementor saying *hey don't use us for this*.
10:15:03 <EvanR> i wonder how seriously engineers take such gotchas when they really implement nuclear nowadays
10:15:31 <EvanR> is it cheaper to give a low% chance of failure due to java than to not use java
10:16:12 <younder> EvanR, Norwegian scientist are actually resposible for writing the software that controls nuclear reactors. And yes it is mathematically verified.
10:16:22 <EvanR> i can imagine bringing up the possible issue and being laughed at "so naive"
10:16:32 <geekosaur> in the case of nuclear, there is ... perhaps not formal certification of language implementations as such, but certification of installations as a whole that must provide trustworthy maximum chances of failure
10:16:34 <EvanR> ah so norway is serious
10:17:29 <younder> I can say as much as the uS millitary takes security. Tat is from intrusion. But also against mal performance very seriously.
10:17:36 <geekosaur> low maximums that is
10:17:40 * sm wonders if Fukushima's software was mathematically verified
10:18:13 <EvanR> it was, but they hardcoded the change of that tidal wave wrong in the axioms
10:18:20 <EvanR> fml
10:18:57 <younder> sm, it was. Noone culd account for so many failures uccuring at once. The backup genereator flooding. The main grid down.
10:19:37 <geekosaur> btw I;m being lax about the terminology because the asker was --- and that makes it hard for me to take it too seriously; if they really cared, they would know what they were talking about and be precise, because it *matters*
10:21:25 <kuribas> younder: They knew they should have build better defense against tsunamis, they just though it would never happen.
10:22:20 <younder> kuribas, In all fairness, the did build tsunami walls. But this was much bigger than they designed for
10:23:04 <kuribas> so they designed wrong
10:23:42 <EvanR> you have to balance the expected cost of a disaster with the estimated chance with the known cost of setting it up for what level of storm
10:24:02 <geekosaur> well, another contributory factor iirc is that the numbers got bigger
10:24:04 <sm> they balanced wrong
10:24:17 <younder> yes, they did, in hindsight
10:24:27 <glguy> Nuclear power plant disasters are offtopic in #haskell
10:24:32 <geekosaur> likewise there's a lot of flood defenses in the US that were appropriate for 1900 sea level and are becoming fairly dangerous now
10:24:34 <younder> agreed
10:25:09 <EvanR> so haskell for nuclear plant control
10:25:12 <mspo> glguy: are you saying you wouldn't trust haskell to power a nuclear power plant?
10:25:16 <younder> If we move over to verifiable programming we can stil save the day though.
10:25:32 <EvanR> programmable flood walls
10:25:52 <sm> younder: not really, we have to expect black swan events no matter what
10:26:10 <younder> I would like to mention Haskebell/Isabell a most hapy aligance which I have the privilige of using.
10:26:24 <mspo> "would you trust.." is a great quote by Joe Armstrong talking about erlang
10:27:01 <younder> Verifiable is not a panacea. Butt it is a step in the right direction
10:27:19 <sm> agreed
10:27:28 <younder> buttwise ;)
10:27:49 <younder> sorry for the typo
10:30:08 <sm> younder: haskebell ? got a link ?
10:30:23 <sm> ah https://isabelle.in.tum.de/haskabelle.html
10:30:25 <schoppenhauer> hi. why is http://uxul.de/~schoppenhauer/bla1.hs not working, but http://uxul.de/~schoppenhauer/bla2.hs is?
10:30:28 <ongy> isn't it called haskabell? also last I asked they told me its sorta unsupported these days
10:30:30 <schoppenhauer> in the sense that it compiles
10:30:36 <schoppenhauer> I do not really understand the error here
10:30:55 <younder> https://isabelle.in.tum.de/haskabelle.html
10:31:28 <geekosaur> schoppenhauer, you should really include the full error message
10:32:09 <Cale> schoppenhauer: Because that isn't the same 'a'
10:32:40 <schoppenhauer> Cale: why isn't it?
10:32:42 <geekosaur> the scope of a type variable in a signature is the signature itself
10:32:48 <Cale> schoppenhauer: Ordinarily, when you write a type signature in Haskell, any type variables are forall'ed implicitly at that signature's level, and don't scope over other parts of your definition
10:33:01 <ongy> younder sm: I know some people at the tum chair taking care of isabelle, and when I asked about haskabelle they said the current (and future) intended way is writing in isabelle/HOL and exporting to haskell.
10:33:06 <Cale> If you turn on the ScopedTypeVariables extension with {-# LANGUAGE ScopedTypeVariables #-}
10:33:08 <geekosaur> unless you (a) enable ScopedTypeVariables (b) "declare" the type variable as having a wider scope by explciitly "forall"-ing it
10:33:24 <Cale> and add  resolve :: forall a. Int -> a -> Pipe (BR a) a IO ()
10:33:36 <geekosaur> otherwise you run into problems with code that uses type variables that might collide with ones you are already using elsewhere in that equation
10:33:44 * sm wonder if #haskell be using a bot to save and answer FAQs more efficiently
10:33:47 <geekosaur> (if you are e.g. copy-pasting code)
10:33:49 <sm> should be
10:33:53 <Cale> The explicit forall there will trigger the extension and cause the variable a to scope over the rest of the definition
10:34:35 <schoppenhauer> Cale: how would I do such a thing without a language extension?
10:34:40 <geekosaur> although to be honest, the secon d one should also fail if it's STV --- even though it's not used, it's declared as effectively a different type
10:34:56 <Cale> schoppenhauer: But basically, without that, you can't write that type signature.
10:35:12 <schoppenhauer> Cale: what would I have to write?
10:35:12 <Cale> You'll just have to write enough code elsewhere to pin down what the type of history is.
10:35:21 <schoppenhauer> ah.
10:35:27 <schoppenhauer> m(
10:35:34 <schoppenhauer> ok then I use the language extension
10:35:39 <geekosaur> usually its easier to just use the extension. and this looks like the pipes package, so extensions are pretty much a given >.>
10:35:51 <Cale> Yeah, there shouldn't be any worry about using language extensions -- the language is just very modular
10:36:17 <Cale> Most of the code I work on uses at least a half dozen extensions :P
10:36:20 <schoppenhauer> thx.
10:38:07 <younder> ongy: about Haskell/isabelle that makes sense to me. Hasellis evolving more quickly that isabelle 
10:38:24 <younder> haskell
10:38:41 <geekosaur> the haskell standard is rather conservative. partially this is fear of breaking existing code (as with STV), partially because of what could be called theoretical concerns (e.g. functional dependencies)
10:39:22 <ongy> also the manpower behind isabelle isn't that great, it's just easier that way around
10:39:25 <geekosaur> (or even practical in that case since fundeps effectively introduce a limited scope logic language into the type system)
10:39:35 <pavonia> geekosaur: What is STV?
10:39:38 <sm> lambdabot: why aren't you responding to my privmsg
10:39:39 <younder> geekosaur, Honestly  the haskell standard prods on breaking anything in it's (no imidiate) pase
10:39:43 <geekosaur> ScopedTypeVariables
10:39:46 <younder> past
10:39:51 <pavonia> Ah
10:40:17 <Cale> I actually think we might not even want to fold all this stuff into basic Haskell, and instead it would be good enough if the Haskell Report just described a bunch of the extensions.
10:40:36 <ezyang> omg why is System.Process so bad :( 
10:40:47 <ezyang> why do we use Handles at all 
10:40:50 <Rembane> ezyang: How is it so bad?
10:41:13 <Cale> ezyang: what's wrong with Handles?
10:41:18 <Rembane> ezyang: I like handles, they make the C-daemon that has posessed my brain happy.
10:41:20 <geekosaur> generally the answer is "portability". which is Hard given that the POSIX and Windows process models are very, very different
10:41:28 <ezyang> I just fixed a deadlock caused by forgetting to close a pipe I had passed to a subprocess 
10:41:58 <ezyang> and I fixed another deadlock caused by closing a handle too early 
10:42:03 <Cale> Oh, in that case, the reason System.Process is so bad is that processes themselves are bad?
10:42:04 <geekosaur> ...and *that* is probably less a Haskell issue than one of the lovely corner cases of the POSIX process model
10:42:06 <younder> Have you looked at 1950's fortran compared to modern Fortran? It is hard to see they are the same language. So too with haskell. It is mooving and this is good
10:42:21 <ezyang> But that's what Haskell is for: smoothing over terrible abstractions, right? :) 
10:42:25 <younder> It's a survivor
10:42:36 <Rembane> ezyang: So you need a couple of with*-functions that make sure that you don't shoot yourself in the foot with handles?
10:42:44 <ezyang> yes exactly 
10:42:54 <Rembane> ezyang: Maybe ResourceT can help you.
10:43:02 <younder> Every language has it's warts
10:43:09 <Rembane> ezyang: If you like Monads more than functions.
10:43:19 <sm> ezyang: yes, what about resourcet ?
10:43:25 <younder> Is not it is not generally applicabe
10:43:31 <younder> applicable
10:43:51 <Rembane> younder: What?
10:44:14 <ezyang> Well, I don't need fancy region style dealloc 
10:44:34 <ezyang> like, bracket would work perfectly well, if it existed to begin with 
10:45:22 <Rembane> ezyang: It looks like you need a more general withFile.
10:46:00 <ezyang> I guess a big problem is createPipe is not bracketed 
10:46:23 <ezyang> and it is a bit difficult to bracket because in the standard use case (passing it to a subprocess) one end will get closed for you 
10:46:33 <Rembane> What about System.Process.Pipe? https://hackage.haskell.org/package/Pipe-2.1.2/docs/System-Process-Pipe.html
10:46:37 <younder> Rembane,  Every language has it's warts, if not it is not generally applicable. That was my statement
10:47:26 * younder thinks of Perl, Basic, 
10:47:51 <ezyang> working with a pretty limited dep set. I'd have to audit the Pipe package 
10:48:17 * sm thinks Haskell might be perl, awaiting its ruby
10:48:33 <Rembane> younder: Ah. MAke them few and predictable.
10:48:40 <drninjabatman> hello, is there a way to get the definition of a type synonym from GHCi?
10:48:46 <Rembane> ezyang: Copy paste them! :D
10:48:53 <Rembane> ezyang: them = the functions you need!
10:48:58 <ezyang> heh 
10:49:05 <geekosaur> drninjabatman, :info?
10:49:19 <Rembane> ezyang: Go programmers says that this is the best way to handle dependencies, so it must be so!
10:49:23 <geekosaur> (note that lambdabot is not ghci, and :info does not work here)
10:49:35 <ezyang> I mean, there is a grain of truth there... 
10:50:05 <Xyliton> ertesx: http://lpaste.net/340676 Sorry for the delay. Is this the correct usage of compare and case?
10:50:09 <drninjabatman> geekosaur: Right! thnx
10:53:13 <lpaste> glguy annotated “No title” with “Minor cleanup” at http://lpaste.net/340676#a340690
10:53:17 <sm> > 1
10:53:19 <lambdabot>  1
10:53:36 <glguy> Xyliton: The use of compare and case there is fine
10:53:48 <sm> hmm. Is it just me who's not seeing privmsg responses from lambdabot
10:53:49 <glguy> Xyliton: You don't need to use >> when you're using do-notation
10:55:44 <dmwit> sm: I just got a reply from lambdabot in privmsg.
10:56:01 <dmwit> ?botsnack
10:56:01 <lambdabot> :)
10:58:22 <sm> ah finally. You have to use bot prefixes even in direct chat, eg /msg lambdabot @help
10:58:53 <boxscape> makes sense, otherwise it wouldn't know whether you wanted help or call a function called help
10:59:14 <sm> > is the prefix for the REPL
10:59:16 <lambdabot>  error:
10:59:17 <lambdabot>      • Variable not in scope:
10:59:17 <lambdabot>          is
11:01:12 <sm> is one of these lambdabot modules good for storing faqs ?
11:02:54 <mspo> sm: perl 6 is the ruby of haskell? :)
11:02:54 * hackagebot pretty-display 0.1.0 - Initial project template from stack  https://hackage.haskell.org/package/pretty-display-0.1.0 (jsermeno)
11:03:38 <schoppenhauer> I now have defined a "Pipe". how can I make something out of it that just converts a list of inputs to a list of outputs? (for testing purposes)
11:05:04 * sm rashly decides running random lambdabot commands to see what they do is safe
11:06:12 <sm> "<sm> bf <lambdabot>  Done."  Great. Missiles launched
11:08:29 <lyxia> schoppenhauer: make a producerm make a consumer, compose with >->, run with runEffect
11:09:17 <schoppenhauer> lyxia: is there one already defined?
11:09:27 <schoppenhauer> lyxia: also: the problem is that a list ends.
11:09:32 <schoppenhauer> lyxia: what do I do in that case?
11:10:10 <sabra> 12http://pastebin.com/ZkfnyyeZ Is there a way to say that the options to ToJSON should apply recurively to all the fields(?) of the datatype A?
11:11:12 <schoppenhauer> lyxia: so if I write a producer, what do I do when the input list ends?
11:12:34 <lyxia> schoppenhauer: http://lpaste.net/340761
11:12:55 * hackagebot pretty-display 0.1.1 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.1 (jsermeno)
11:12:57 <lyxia> You must handle termination conditions yourself
11:15:25 <schoppenhauer> lyxia: ok. hm. still your code does not typecheck, but I will try to figure this out myself.
11:17:55 * hackagebot pretty-display 0.1.2 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.2 (jsermeno)
11:17:59 <lyxia> hm. my result type is wrong
11:19:05 <lyxia> http://lpaste.net/340785 maybe?
11:20:19 <lyxia> you get an empty list if for some reason your pipe doesn't match the input and expected output length.
11:23:19 <schoppenhauer> lyxia: nope: http://lpaste.net/3014663800197480448
11:26:38 <ertesx> Xyliton: yeah, apart from what glguy already noted, this looks great
11:28:20 <ertesx> Xyliton: next task: make it so that 1. it doesn't crash and 2. the user has a native way to abort the game
11:28:41 <ertesx> Xyliton: like by entering 'q' or an empty line
11:29:38 <ertesx> Xyliton: if you import Text.Read, you will get access to readMaybe, which will help you
11:29:45 <ertesx> > readMaybe "15" :: Integer
11:29:47 <lambdabot>  error:
11:29:47 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Integer
11:29:55 <ertesx> @let import Text.Read
11:29:57 <lambdabot>  Defined.
11:29:58 <ertesx> > readMaybe "15" :: Integer
11:30:02 <lambdabot>  error:
11:30:02 <lambdabot>      • Couldn't match expected type ‘Integer’
11:30:02 <lambdabot>                    with actual type ‘Maybe a0’
11:30:06 <ertesx> > readMaybe "blah" :: Maybe Integer
11:30:09 <lambdabot>  Nothing
11:30:13 <ertesx> > readMaybe "15" :: Maybe Integer
11:30:16 <lambdabot>  Just 15
11:30:18 <ertesx> (sorry for the noise)
11:30:21 <ertesx> Xyliton: ^
11:30:51 <lyxia> schoppenhauer: ah, that's because of monomorphism restriction. eta-expand: void x = fmap (const []) x
11:31:10 <lyxia> schoppenhauer: Sorry I don't have a compiler to use right now.
11:31:23 <schoppenhauer> lyxia: ok, I added an "End" to my structure now.
11:32:04 <jmorris> Should to main for functions be defined all together like this (https://github.com/joshua-morris/hpass/blob/447238fc369ac035ca0dbcf81b04ea566032a476/src/Hpass.hs)
11:32:12 <jmorris> or each in their modules
11:33:13 <lyxia> sabra: Unfortunately there is no direct way. You can define ToJSON2 which will help.
11:35:18 <sabra> @lyxia thanks . But that will help me only for binary constructors . isn’t it. 
11:35:19 <lambdabot> Unknown command, try @list
11:35:29 <lyxia> jmorris: what do you think should go in other modules
11:35:41 <sabra> #lyxia thanks . But that will help me only for binary constructors . isn’t it.
11:36:03 <jmorris> lyxia: I was wondering if the main for each function should go in the Hpass.hs file or a main in each file
11:36:28 <lyxia> sabra: right
11:36:56 <lyxia> jmorris: I see only one main
11:37:18 <jmorris> yes, should it be in the Hpass.hs file
11:37:33 <jmorris> or should each module have it's own main
11:37:47 <jedai> jmorris: main is only a special function name in the Main module of an executable
11:37:55 * hackagebot pretty-display 0.1.3 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.3 (jsermeno)
11:38:07 <jedai> jmorris: we generally avoid defining a main() in any other module
11:38:17 <jmorris> ok
11:38:23 <jmorris> that's what I was wondering
11:39:50 <jedai> jmorris: though the "Main" module can have another name if you specify it with the Main-is directive in your .cabal but there still would only be one "Main" module per executable
11:39:58 <younder> #offttopic-haskell has unamouly voted that this.  ==:)  -  -  is the new copy operator.
11:40:43 <jedai> younder: and what does it do ? (apart from being an abomination) 
11:41:40 <younder> well A infereents B using a function sp
11:41:47 <younder> inferments
11:43:56 <sm> ah yes, totally clear now :)
11:44:24 <younder> One to one and onto and totally close.
11:44:33 <younder> closed
11:44:34 <ongy> I read that STM can observe pointer equivalence in GHC. so I was wondering, what preservers it and where we lose it. 
11:45:48 <ongy> so I would guess that with 'let z = (\y -> y) $ x' z ptr_e y ptr_e x. What about 'let z = (\Just y -> Just y) $ Just x' will z be ptr equal to the input Just x? 
11:52:56 * hackagebot pretty-display 0.1.4 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.4 (jsermeno)
11:55:00 <younder> Wooah I'm not ready for primetime yet. Still gotta hit them maths
11:55:25 <younder> CA in the nXt Year
11:57:23 <Tertain> Anyone know if there is a way to get sized images working in the READMEs of both github and hackage? Or if you can specify different READMEs for each somehow? Github works with html markup, but Hackage doesn't.
11:57:24 * younder waves goodbye
12:02:56 * hackagebot shakespeare 2.0.11.2 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.11.2 (MichaelSnoyman)
12:02:58 * hackagebot pretty-display 0.1.5 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.5 (jsermeno)
12:05:36 <younder> Tertain, Why do you want that? If so you want a indexx.html instead.
12:05:55 <younder> index.html
12:06:10 <younder> So you have a reader that can handle it
12:06:25 <lyxia> Tertain: lens adds its image in the .cabal description, would that work for you
12:06:54 <lyxia> it's actually also in the README
12:07:24 <younder> czat'ing a readme and finding all sorts of binary junk would just irritate me
12:07:54 <younder> expectations
12:09:09 <Tertain> younder: on github the only way to specify a width and height is to use html mark up.
12:09:12 <lyxia> oh it's such a hack, .cabal links to imgur
12:09:41 <Tertain> lyxia: Thanks, but the lens images don't provide a width and a height, so the images end up being blurry.
12:09:51 <lyxia> I see.
12:10:37 <younder> Tertain, spesify it in CSS and you are made
12:11:20 <younder> One of the WEB replubic
12:11:53 <Tertain> younder: Thanks, I'll give that a shot.
12:22:58 * hackagebot pretty-display 0.1.6 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.6 (jsermeno)
12:26:26 * sm tries a thing
12:26:50 <sm> @remember FAQ faq-help: @remember FAQ topic: some info , @forget FAQ topic: some info , @quote topic:
12:26:50 <lambdabot> It is forever etched in my memory.
12:26:56 <sm> @remember FAQ details: When asking for help, give details such as platform, GHC version, cabal or stack, exact command line, source code, full output, urls. If it's long, paste at http://lpaste.net
12:26:57 <lambdabot> I will never forget.
12:27:37 <younder> curse you!
12:27:45 <geekosaur> we tend to overload @where instead...
12:27:58 * hackagebot pretty-display 0.1.7 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.7 (jsermeno)
12:27:59 <geekosaur> but
12:28:00 * hackagebot amby 0.2.0 - Statistical data visualization.  https://hackage.haskell.org/package/amby-0.2.0 (jsermeno)
12:28:02 <geekosaur> @where faq
12:28:02 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:28:12 <sm> @quote details:
12:28:13 <lambdabot> FAQ says: details: When asking for help, give details such as platform, GHC version, cabal or stack, exact command line, source code, full output, urls. If it's long, paste at http://lpaste.net
12:28:34 <Welkin> @quote sm
12:28:35 <lambdabot> sm says: if this url is infinite, I'm screwed :(
12:29:06 <sm> can we not waste valuable infrastructure on that :)
12:29:23 <younder> for math stuff us mathb.in
12:29:33 <sm> @forget sm if this url is infinite, I'm screwed :(
12:29:33 <lambdabot> Done.
12:30:02 <Welkin> what!
12:30:08 <Welkin> blasphemy
12:32:16 <monochrom> I'm pretty sure no one will actually think of @quote when looking for an FAQ answer. So, speaking of wasting valuable infrastructure, an answer stored at a place no one searches is wasted valuable infrastructure.
12:32:39 <jmorris> I'm trying to generate a password and return it with type string
12:32:51 <ongy> that mostly requires getting used to. But I prefer the more personal way we have here over just letting lambdabot quote.
12:32:52 <jmorris> this is what i have http://lpaste.net/341027 but I cant return a string
12:33:08 <jmorris> because getStdGen only works in IO
12:33:21 <monochrom> FAQ answers belong to @where. Jokes belong to @quote.
12:33:22 <ongy> jmorris: that's because of your type, you want IO (String)
12:33:33 <ongy> scrap the parens btw. no idea why I put them in
12:34:00 <jmorris> how do I make it return the string?
12:34:51 <ongy> return password
12:35:03 <jmorris> oh ok
12:35:04 <jmorris> thanks
12:36:29 <ongy> jmorris: I'm not 100% sure, but you should check if 2 invocations of this function will give you the same output
12:37:08 <jmorris> ongy: how can i use the returned password as a string?
12:37:17 <jmorris> ie. (generatePassword 10) ++ "A"
12:37:23 <ongy> jmorris: do you know what IO is and generally how to use it?
12:37:34 <jmorris> :/
12:37:46 <jmorris> i think so
12:39:11 <tdammers> you have three things
12:39:29 <tdammers> their types are: 1. IO String; 2. String -> String -> String; and 3. String
12:39:49 <jmorris> ok
12:39:58 <tdammers> that's your jigsaw puzzle; you need two extra pieces to put them together
12:39:59 * hodapp restricts the urge to put type annotations in his Python code...
12:40:10 <tdammers> but let's start with what we can put together already:
12:40:16 <tdammers> (++) :: String -> String -> String
12:40:19 <tdammers> and "A" :: String
12:40:35 <tdammers> we can put these two together into (++ "A") :: String -> String
12:40:51 <tdammers> so we need a way to put IO String and String -> String together
12:41:04 <jmorris> ok
12:41:09 <tdammers> fortunately, there is (>>=)
12:41:12 <tdammers> :t (>>=)
12:41:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:41:16 <ongy> hodapp: python 3.5 supports type annotations
12:41:38 <Welkin> ongy: still garbage
12:41:48 <kadoban> ongy: Don't they do like nothing though?
12:41:52 <tdammers> IO has a Monad instance, so we can substitute: m ~ IO, a ~ String, b ~ String
12:42:10 <tdammers> giving us: (>>=) :: IO String -> (String -> IO String) -> IO String
12:42:19 <maerwald> why not use fmap?
12:42:25 <tdammers> maerwald: getting there
12:42:38 <ongy> afaik they do nothing for the interpreter (compiler? what's python?), there's seperate tools that can check it, or can't not 100% sure
12:42:51 <tdammers> maerwald: actually, valid complaint
12:42:53 <tdammers> :t fmap
12:42:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:43:07 <tdammers> same idea: (String -> String) -> IO String -> IO String
12:43:08 <maerwald> > fmap (++ "abc") $ (return "abc" :: IO String)
12:43:11 <lambdabot>  <IO [Char]>
12:43:21 <maerwald> sth like that
12:44:14 <jmorris> ok i think i understand
12:46:16 <sm> monochrom: the main users would be channel regulars who know the topics well, not the newcomers who need answers
12:47:59 <sm> it's more direct than @where, I think. I thought there was a module for faqs, using @quote is a hack
12:48:04 <sm> worth a try
12:48:51 <allenj12> so if the all monads are of kind *->* and there is State s a, is the state the "fixed" parameter, or is the a
12:49:11 <geekosaur> s is fixed
12:49:38 <allenj12> geekosaur: thats what i thought, is there an 'opposite' where a is fixed?
12:49:51 <geekosaur> type application works like value application:  * -> * means it is partially applied and expecting one more parameter, which therefore is the last
12:50:13 <geekosaur> and, a fixed would be less than useful, it seems to me.
12:50:21 <allenj12> ooo, i guess thats obvious isnt it? :P
12:50:31 <geekosaur> whereas s fixed means everything shares the same state
12:50:38 <geekosaur> which is what you want, generally
12:51:01 <younder> my favorite these days. Linear logic
12:51:03 <geekosaur> (everything in a given expression, that is)
12:51:19 <allenj12> is there an opposite monad where \s -> (a,s) where a is fixed?
12:53:26 <Tuplanolla> There's `(,) a`, but it's not quite a `Monad`, allenj12.
12:53:45 <Tuplanolla> You can get up to `Applicative` with a `Monoid a` constraint.
12:53:57 <jle`> allenj12: you mean a Monad instance for Foo s a = F (\a -> (s, a)) ?
12:55:02 <allenj12> jle`: yes that works, does it exist?
12:55:46 <jle`> i don't think it's possible
12:55:56 <jle`> because 'a' is in both the negative and positive position
12:56:02 <jle`> how would you even write a Functor instance?
12:56:27 <jle`> you'd have to turn an (a -> (s, a)) into a (b -> (s, b)), with only an (a -> b)
12:56:55 <jle`> but 'a' is an argument, so you can't turn a function taking an 'a' into a function taking a 'b' w/o a (b -> a)
12:57:11 <jle`> allenj12: it's similar to trying to write a Functor for data Endo a = Endo (a -> a)
12:58:26 <jle`> allenj12: try writing fmap :: (a -> b) -> (a -> a) -> (b -> b)
12:58:45 <jle`> (which is fmap :: (a -> b) -> Endo a -> Endo b)
12:58:51 <allenj12> jle`: ahh that makes sense.
12:58:59 <allenj12> why it would be impossible
13:00:03 <jle`> see this neat recent article for more info https://www.fpcomplete.com/blog/2016/11/covariance-contravariance
13:07:45 <allenj12> jle`: actually started to go overe it :D i was watching a youtube playlist on category theory where we went over covariance-contravarience, I got a little lost and looked at that resource :D
13:08:10 <allenj12> which made me ask these questions lol
13:12:31 <Xyliton> ertesx: http://lpaste.net/341151 This now checks if the input is a number and otherwise it checks if it is equal to "quit". If that isn't true it will tell the user about their mistake. I hope my code doesn't look too messy 😁
13:15:55 <kadoban> Xyliton: What happens if someone inputs -1 ?
13:17:36 <Xyliton> kadoban: umm... it will tell the user that it's not a number. hm...
13:17:49 <Xyliton> maybe I should limit the input to positive numbers
13:18:23 <kadoban> Xyliton: You can fix that part by doing a case on the maybeInt itself, instead of using fromMaybe. If you want to, just a thought.
13:18:53 <kadoban> case maybeInt of Nothing -> ...   Just x -> ...
13:23:15 <Xyliton> can I pattern match EQ and LT in one case?
13:23:56 <ongy> kinda, you can match GT and _
13:26:48 <younder> <=
13:27:07 <geekosaur> that'd be a guard though... but yes
13:27:37 <Xyliton> What about this? http://lpaste.net/341202
13:27:47 <Xyliton> Is this considered okay syntax, at least?
13:27:55 <Xyliton> */code-style
13:28:00 * hackagebot sqlite-simple 0.4.10.0 - Mid-Level SQLite client library  https://hackage.haskell.org/package/sqlite-simple-0.4.10.0 (JanneHellsten)
13:29:02 <younder> Cute, there is an even cruder game than my russian roulette.
13:29:49 <ongy> Xyliton: I would go with 'if n < 0' for detecting negative numbers
13:30:22 <younder> it is more readble
13:30:52 <geekosaur> it is? even `compare` 0 and LT would be more readable, you at least lose the extra line noise around Haskell negative literals >.>
13:31:10 <Xyliton> i only did that because ertesx's challenge was to not use any >,<,>=,<= and ==
13:31:33 <younder> I see
13:31:37 <geekosaur> you don't lose that with mine, and it gets you to one pattern instead of two
13:32:28 <Xyliton> Where is an extra line noise for negative numbers?
13:32:29 <younder> Well you bettertell us the rues first or our advice will be noncense
13:32:42 <geekosaur> having to wrap them in parens (-1)
13:33:30 <Xyliton> it's a simple number guessing game: the game generates a number between 0 and 10 and the player tries to guess it. exiting it should be implemented as a "command".
13:34:09 <Xyliton> I block negative numbers because they make no sense in that context
13:35:10 <ongy> you could also mod 10 all numbers
13:35:45 <geekosaur> oh, I seem I conflated the two case exprs, whoops
13:35:45 <Xyliton> why mod 10?
13:36:00 <geekosaur> but you can still combine those two cases by using _ instead of separate LT and GT matches
13:36:27 <Xyliton> geekosaur: just saw that too after compiling. Fixed it exactly like that :)
13:39:07 <younder> NO, You are NOY in the Integer Category
13:39:52 <younder> I knew there had to be a simple check.
13:40:24 <younder> Perhaps too much minchraft handed it to me
13:41:59 * younder dreasms of blocks
13:42:35 <younder> <<<:->-
13:44:32 <younder> The review  'Review of introductin to lattces and ordre' by joe chen is booring kills the material.
13:44:41 <younder> cohen
13:45:51 <younder> sigh! and that is an important book!
13:46:24 <younder> well I orderedit.
13:50:55 <Fuuzetsu_> Hey, playing with conduit and I'm confused about dropC. “Prelude Conduit> runConduitPure $ yieldMany [1..10] .| dropC 1 .| sinkList” gives “[]”. What am I missing?
13:51:21 <Fuuzetsu_> “Prelude Conduit> runConduitPure $ yieldMany [1..10] .| takeC 5 .| sinkList ” does what I'd expect, “[1, 2, 3, 4, 5]”…
13:54:28 <dmwit> Xyliton: Perhaps `inRange` would be preferable. After all, why reject negative numbers but not numbers greater than 10?
13:54:38 <Polymorphism> haskell reads like a foreign language, python reads like a book
13:56:16 <jle`> now to figure out if writing books is the best way to write a readable and maintainable computer program
13:56:58 <sm> jle`: oh I like that. What's process are you thinking of ?
13:57:21 <jle`> it was a rhetorical question and my implied answer is no :p
13:57:46 <dmwit> Writing Haskell is like putting together a puzzle, with each piece telling you a lot about what other pieces it can interlock with. Writing Python is like sticking two pieces of soap together; they pieces always glom, but you're never sure just when they'll break apart again.
13:58:22 <Polymorphism> can you do anything in haskell that you can do in c++?
13:58:36 <jle`> haskell is a general purpose programming languages
13:58:36 <Koterpillar> do you want to?
13:58:49 <dmwit> Yes, most modern languages are Turing complete.
13:58:53 <jle`> the only difference you'd probably find is in the available libraries
13:59:07 <jle`> haskell might have some libraries that aren't available for C++ and vice-versa
13:59:17 <jle`> but code written in haskell tends to be more maintainable, verified, safe, correct
13:59:18 <jle`> and easier to write
14:03:04 <Berra> I have m(Response ByteString) and Lazy.putStr is ByteString -> IO. What's the best to actually use putStr with the ByteString?
14:03:06 <monochrom> what is "anything"?
14:03:54 <monochrom> And what is with lousy analogies "foreign language" and "book"?
14:04:16 <monochrom> Of course every language you haven't learned reads like a foreign language. It's called a tautology.
14:04:20 <mmaruseacph2> Berra: is m IO?
14:04:50 <Berra> mmaruseacph2: It's MonadIO
14:04:53 <dmwit> Berra: Use `(>>=)` to turn a `ByteString -> m a` function into a `m (Response ByteString) -> m a` function. Use `liftIO` to turn an `IO a` action into a `MonadIO m => m a` action. Dunno much about `Response`, but presumably it exposes its constructors or some accessor functions that you can pattern match on.
14:05:12 <mmaruseacph2> then what dmwit says
14:05:23 <dmwit> Sorry, that first sentence should read "turn a `Response ByteString -> m a` function into a `m (Response ByteString) -> m a` function", of course.
14:05:25 <Fuuzetsu_> IIRC ‘responseBody’ or something along those lines in one of the constructors gives you what you need (HTTP package I think?)
14:05:35 <mmaruseacph2> except that most likely you don't need the liftIO since m is already MonadIO
14:05:51 <dmwit> mmaruseacph2: `liftIO` is for the `putStr`
14:06:02 <mmaruseacph2> oh, my bad
14:06:09 <monochrom> MonadIO is why you need liftIO :)
14:06:24 <mmaruseacph2> I parsed that line the other way round
14:19:40 <Berra> dmwit: Sorry, I don't see it. http://lpaste.net/341375
14:24:47 <glguy> Berra: Don't worry about <$> and <*>, then aren't applicable there
14:25:19 <glguy> Berra: You can look at http://hackage.haskell.org/package/http-conduit-2.2.3/docs/Network-HTTP-Conduit.html to see some examples of how httpLbs, parseRequest, and newManager fit together
14:25:29 <Berra> But I don't want to use do notation.
14:25:46 <glguy> <$> and <*> aren't replacements for do notation
14:25:58 <glguy> They can only handle a subset
14:26:08 <Berra> Well it should work in this case should it not?
14:26:11 <glguy> no
14:26:19 <Berra> Why so then?
14:26:48 <glguy> If you want to avoid do-notation, you'll need to learn about >>=
14:27:27 <Berra> Yes I know how to convert do to bind but it appeared like <$> should function here
14:28:17 <Berra> Is the difference that httpLbs is constructed with the a and b in m a and m b ?
14:30:14 <glguy> The difference is that in 'MonadIO m => Request -> Manager -> m (Response ByteString)' you have an: 'm (Response ByteString)' instead of just 'Response ByteString'
14:31:28 <Berra> Sorry I don't see why it should not be m(Response ByteString)
14:31:37 <Berra> That's what the signature says
14:31:57 <glguy> :t putStrLn <$> getLine
14:31:59 <lambdabot> IO (IO ())
14:32:01 <glguy> :t putStrLn =<< getLine
14:32:03 <lambdabot> IO ()
14:32:08 <glguy> consider this simpler example
14:32:25 <glguy> In one case the result of executing action is to return a new action
14:33:03 <glguy> in the second case is an action that both gets a line and prints it straight away when exeuted
14:33:51 <Berra> Hm, thanks.
14:33:53 <glguy> The code you pasted is computing a new action that should it ever be executed would perform an httpRequest
14:33:56 <glguy> but it's not executing it
14:34:00 <Berra> Yes rewriting
14:34:07 <n_blownapart> hi does anyone know if the author of ' Haskell: from first principles ' hang out in this chatroom?
14:34:52 <sm> bitemyapp is here, yes (for some value of "here")
14:35:14 * sm doesn't know if the other author is here
14:35:40 <n_blownapart> oh you recommended me the book yesterday? just curious  .. pleased to meet you.
14:35:52 <sm> hi n_blownapart 
14:36:20 <n_blownapart> cool I took a look and read some good reviews
14:36:22 <sm> there's a lot of readers of that book in #haskell-beginners also
14:36:43 <n_blownapart> good to hear about that channel
14:37:22 <n_blownapart> 1000 pages, is , long ... :)
14:37:35 <sm> I did say it was thorough :)
14:38:03 * hackagebot isobmff-builder 0.11.2.0 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.11.2.0 (SvenHeyll)
14:38:33 <sm> I hear it started out much shorter but expanded to clarify everything raised in feedback
14:39:20 <sm> there's plenty of shorter learning materials, this one is for people who want smooth step by step guidance
14:44:32 <mekeor> is it common to be stuck at some point of learning haskell? like, i started learning haskell ~5 years ago, and i still don't really know how to use lenses, parsers, and so so *so* much more :O ;(
14:45:02 <maerwald> yes
14:45:05 <monochrom> It is common to be stuck when learning anything.
14:45:21 <maerwald> people usually downplay the huge amount of concepts haskell has
14:45:23 <mekeor> i gotta admit tho, i didn't code continuisly; also, i spent ~3 years on coding calculators and my own little RPN language lol
14:45:28 <monochrom> I certainly got stuck in the middle when learning economics, and still scheduling a future time to retry.
14:45:29 <maerwald> but it's still a difference to most other languages
14:45:52 <sm> mekeor: very common
14:46:09 <wespiser> I'm using the ExceptT MyError IO a anti-pattern as a stack for my programming language, but all I am doing is reading in files after checking to make sure the file exists, is this an okay usage of ExceptT, or should I bump up to using (monadThrow/Catch, resouceT IO), or catchAny?
14:46:21 <maerwald> also, one doesn't even need to know all concepts
14:46:27 <maerwald> pick the ones that are useful
14:46:30 <maerwald> to you
14:46:33 <monochrom> Actually I don't understand why everyone expects only successes and triumps in learning.
14:46:38 <sm> yes, I wish this was more widely understood 
14:46:47 <sm> (not needing to know all of it)
14:47:02 <maerwald> monochrom: yes, but I don't think that's the problem here though
14:47:14 <Berra> glguy: I don't get what I'm supposed to liftIO http://lpaste.net/341447 ?
14:47:40 <glguy> Berra: What's the question?
14:48:13 <ongy> the desire to know all is, that I don't even know what I don't know that could help me
14:48:15 <Berra> glguy: Now I just have an IO(Response ByteString) instead. Still don't know how I'll be able to ByteString -> IO
14:48:37 <monochrom> Oh and I'm still stuck at grade 3 in my lift of learning the piano.
14:48:44 <monochrom> s/lift/life/
14:48:46 <glguy> Berra: With more >>=, and looking up how Response works
14:48:52 <maerwald> mekeor: if you face a problem you feel you can only awkwardly solve, then that's a hint that you might have to ask if there's some concept that can aid you
14:48:53 <glguy> Berra: liftIO doesn't feature
14:49:10 <sm> ongy: but you wouldn't attempt to "eat" all of medicine if you wanted to become a doctor, would you ?
14:49:21 <sm> I suppose it's a problem in how we present it
14:49:28 <wespiser> is it ever okay to use the "ExceptT myError IO a" antipattern?
14:49:38 <monochrom> wait, I have to eat my Haskell code? :)
14:49:46 <mekeor> maerwald: ic
14:49:59 <ongy> sm: I think that's a pretty bad analogy. I think it's more like trying all the hammers for a carpenter
14:50:08 <mekeor> stop eating code, people use it
14:50:08 <sm> yes, we might code a bit differently if we had to eat it :)
14:50:19 <ongy> less smelly
14:50:25 <glguy> Tying all the hammers *to* a carpenter might make for a strong carpenter
14:50:44 <wespiser> well all you have is a hammer everything starts looking like a nail
14:50:48 <wespiser> *when
14:50:48 <monochrom> that is not a carpenter. that is a demolisher.
14:51:00 <wespiser> that's a huge problem with haskell
14:51:12 <maerwald> E.g. I know the State monad, I can implement it and have heard people like it and stuff, but I've never actually used it. For anything. Even stateful problems. Have used STArray though
14:51:27 <monochrom> no, when all you have is Thor's hammer, everyone starts to think you're Thor
14:51:29 <glguy> When you have a general purpose programming language you think all your problems can be solved with a program?
14:51:34 <wespiser> State monad would work well for implementing a programming language 
14:51:44 <sm> ongy: well you can pick the metaphor that you like. Should a would-be carpenter need to understand how to do every carpentry task with every tool and every kind of wood ?
14:52:00 <monochrom> or alternatively everyone starts to think you're still doing your Halloween thing
14:52:14 <wespiser> yea, Haskell does not solve all problems as well as any other possible language
14:52:16 <maerwald> monochrom: there are such people :P
14:52:35 <mekeor> Q: what open source projects are you guys hacking on these days?
14:52:45 <maerwald> my own one-man projects lol
14:52:52 <wespiser> https://github.com/write-you-a-scheme-v2/scheme/
14:53:06 <ongy> sm: not in the NxNxN kind, but I think a good carpenter should try to work at least once with every tool/wood to get familiar with it and know it when they can use it
14:53:07 <maerwald> 99% of opensource projects are one-man projects
14:53:13 <maerwald> (I made that number up)
14:53:17 <wespiser> no shit
14:54:45 <sm> mekeor: hledger and misc. stuff
14:54:49 <wespiser> maerwald: if you look at my project, I am using a `ReaderT` monad to implement lexical scope. I could just as well be using a `StateT` monad. 
14:55:09 <maerwald> I hate monad transformers
14:55:19 <wespiser> dude, they took me so long to grok
14:55:34 <maerwald> I consider them an anti-pattern, but others might disagree
14:55:39 <wespiser> why?
14:55:39 <mekeor> sm: wow, looks like a very nice project, cool
14:56:12 <maerwald> because they are clumsy, mess up your API, are not dynamic, awkward to write, annoying to understand, not declarative in any way
14:56:40 <wespiser> yea, its super tricky to have them as the backend to an API
14:56:46 <maerwald> use ee, freer or mtl
14:56:59 <maerwald> although mtl is just a wrapper around transformers in a way
14:56:59 <wespiser> mtl is a monad transformer?
14:57:04 <wespiser> lol
14:57:06 <maerwald> @hackage mtl
14:57:06 <lambdabot> http://hackage.haskell.org/package/mtl
14:57:12 <wespiser> @hackage ee
14:57:12 <lambdabot> http://hackage.haskell.org/package/ee
14:57:43 <imprecise> Can anyone point me to criticisms or what is wrong with the denotational semantics of FRPNow? It appears to have very clean semantics but I can't find much discussion of it anywhere... especially what Conal Elliot thinks about it?
14:57:45 <maerwald> @hackage extensible-effects
14:57:46 <lambdabot> http://hackage.haskell.org/package/extensible-effects
14:57:49 <maerwald> @hackage freer
14:57:49 <lambdabot> http://hackage.haskell.org/package/freer
14:58:01 <sm> mekeor: it is! jump in! B-)
14:58:20 <conal> imprecise: i haven't looked at it carefully
14:58:49 <wespiser> maerwald: ee, freer: are they ready for industry?
14:59:16 <maerwald> mh, ee is based on the old paper (but somewhat mature I think), freer is rarely used I think
14:59:38 <wespiser> alright, it seems like everyone is using mtl
14:59:43 <wespiser> or at least the companies I know are
15:00:02 <maerwald> it's the most popular one, but I still would prefer an ee approach
15:00:11 <maerwald> all the lifting is annoying and clumsy
15:00:22 <imprecise> conal: Oh, well it would be interesting to hear your thoughts on it if you have some time in the future. It's described in the paper http://www.cse.chalmers.se/~atze/papers/prprfrp.pdf
15:00:33 <maerwald> with freer, some of the things can be properly inferred without lifting
15:02:05 <wespiser> interesting. I think I'm going to stick with mtl.
15:02:06 <imprecise> conal: Somewhat related, I see events defined as [(Time, a)].. but why not Time -> [a] ? In other words, why aren't events just behaviors of a list?
15:03:06 <conal> imprecise: i now prefer that denotation, especially in the isomorphic form [] . (-> Time)
15:03:29 <conal> imprecise: since the homomorphisms work out nicely.
15:03:54 <conal> *semantic* homomorphisms
15:03:54 <imprecise> cool :)
15:06:14 <conal> imprecise: i'm glad that you're interested in elegant, precise denotation. to me (and Peter Landin, afaiu), elegant, precise denotation is what distinguishes genuinely functional from merely technically "functional". that crucial distinction has gotten obscured even in haskell.
15:06:33 <jle`> conal: isn't that the 'Wire' denotation?
15:06:55 <conal> jle`: i don't know
15:07:08 <jle`> where Event a ~ Behavior [a]
15:07:14 <jle`> s/Wire/Signal
15:12:27 <imprecise> conal: I hope for and encourage more discussion of different denotations between researchers, authors, and API programmers. It's amazing how little we actually understand concepts we assume are precise.
15:14:45 <conal> imprecise: amen! "It is foolish to answer a question that you do not understand." - George Polya
15:14:57 <conal> imprecise: which describes most programming
15:16:32 <monochrom> No.
15:17:01 <monochrom> 99% of the time, I don't understand a beginner question, but I can still safely answer "don't do that" and it is the right answer. :)
15:24:41 <Hafydd> I would be concerned about the 1%.
15:29:53 <jle`> 4/b 30
15:34:13 * dedgrant suddenly commits to a lifetime vow of silence.
15:41:21 <jle`> using ' to syntactically denote lifted data constructors is gonna be awkward if we ever get lifted Char's
15:42:19 <apple335> hello
15:42:27 <jle`> hi apple335 !
15:42:47 <yulax> hej apple335 !!!
15:43:07 <apple335> hi nice to meet you
15:44:30 <apple335> new to irc
15:47:08 <mekeor> hi apple335
15:47:34 <mekeor> apple335: how is it going?
15:47:42 <apple335> hi mekeor
15:47:55 <apple335> not bad wbu ?
15:48:39 <mekeor> i feel alright, i should sleep
15:49:34 <apple335> what time is it there ?
15:49:42 <mekeor> 00:48
15:50:10 <dmwit> jle`: `''a'`, what's the problem? =P
15:50:36 <jle`> lol
15:50:54 <jle`> i guess 'A' would be ambiguous...?
15:51:17 <monochrom> Symbol already lets you write "abc" without prepending '
15:51:18 <jle`> is it a ticked promoted A' , or an unticked promoted 'A' ?
15:51:26 <apple335> cool is 23:50 here
15:51:35 <jle`> you can always leave off ' if it's not ambiguous
15:51:55 <monochrom> Ah
15:52:46 <jle`> i guess you won't be allowed to use A' in its ticked form
15:52:51 <jle`> but, what about something silly like data A' = A'
15:53:21 <jle`> how would A' be distinguished between the type and lifted constructor type, if both are in scope
15:53:50 <dmwit> Wouldn't always requiring ticks on promoted `Char`s remove the ambiguity?
15:54:09 <jle`> hm, i suppose that'd work
15:54:25 <jle`> s/suppose/think
16:00:54 <parsecUser> I am using Parsec because I want nice error messages, and I know attoparsec is not appropriate for my scenario. That said, does anyone know whether parsing strings or text tends to be faster with parsec?
16:01:36 <ezyang> the default assumption to make is that text will be faster 
16:02:09 <jle`> are you asking if parsec parses strings & text faster than attoparsec, or if parsec parses strings or text better?
16:02:23 <jle`> s/better/faster
16:02:40 <parsecUser> jle`, the latter
16:02:57 <parsecUser> ezyang, but I suspect uncons is pretty bad on Text
16:03:04 <parsecUser> So I'd like to have some data
16:03:27 <parsecUser> Before doing a relatively expensive exploration
16:03:54 <parsecUser> https://hackage.haskell.org/package/parsec-3.1.2/docs/Text-Parsec-Prim.html#t:Stream
16:03:58 <jle`> if text is an array, uncons should be cheap i think
16:04:04 <mzabani> hi everyone. Anyone knows how to receive a list of something (Text or Int, for instance) through Yesod's routing mechanism?
16:04:08 <jle`> but also, i'm pretty sure you could just write your parsers without caring
16:04:14 <jle`> and pick the stream type later
16:04:16 <ezyang> parsecUser: Yes, it depends on how Parsec implemented it 
16:04:46 <parsecUser> ezyang, how do I find that out?
16:04:56 <ezyang> you could do some benchmarks 
16:05:04 <jle`> when in doubt, benchmark :)
16:05:11 <parsecUser> jle`: a lot of primitives assume strings I believe, so it's more than it sounds
16:05:28 <parsecUser> Sure, but I'm wondering if someone already tested this
16:05:38 <parsecUser> I assume it has come up before for folks
16:05:44 <jle`> i feel like those primitives would asusme string even if you're using Text
16:05:47 <parsecUser> So I don't want to do the work again for no reason
16:06:04 <jle`> s/asusme/use
16:07:01 <parsecUser> jle`: ah, it looks like things are generic! https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#string
16:09:27 <jle`> :D
16:09:42 <grantwu> Why would uncons be expensive for Text?
16:10:19 <parsecUser> grantwu, I figure it is not a linked list, and I'm not sure how a smarter data structure would handle uncons in a nice way
16:10:25 <jle`> uncons should be O(1)
16:10:36 <grantwu> For an array, you just keep a start index and you increment that
16:10:38 <jle`> because it just shifts the pointer one box down
16:10:51 <parsecUser> In Haskell?
16:10:54 <parsecUser> Or in general?
16:11:04 <jle`> for arrays in general
16:11:19 <parsecUser> Sure, but I am using Parsec in Haskell specifically :P
16:11:20 <jle`> assuming arrays are implemented as contiguous blocks of stuff in memory + a pointer to the beginning of that block
16:11:31 <parsecUser> yeah, then it might be pretty awful
16:11:38 <Axman6> this all applies to Haskell too
16:11:48 <jle`> parsecUser: in that way, uncons is O(1)
16:11:54 <jle`> because all you do is shift the pointer one block down
16:12:05 <jle`> s/block/address
16:12:05 <Axman6> uncons should be very efficient
16:12:21 <Axman6> like, 6 instructoions or something 
16:12:25 <parsecUser> jle` that is exactly how things work with Text?
16:12:28 <jle`> you can use the same contiguous block of memory, and just (+1) the pointer
16:12:30 <grantwu> https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text.html#uncons
16:12:42 <jle`> parsecUser: yeah, Text is an array of bytes
16:12:47 <Axman6> well, more for creating the new "Text" object, but that's just pointing to the same memory and incrementing an integer
16:13:03 <jle`> it's kind of nicer in Haskell actully because everything is immutable
16:13:08 <jle`> uncons can be done w/o copying
16:13:20 <jle`> but yeah, if you're in doubt, you can just look up the docs for uncons like grantwu posted :)
16:13:38 <parsecUser> Axman6: thanks for the link!
16:13:45 <grantwu> I don't quite know what an Iter is, (it appears to be from Data.Text.Unsafe)
16:13:45 <parsecUser> oops, thanks grantwu 
16:13:48 <grantwu> ohhh, right.
16:14:08 <grantwu> some codepoints might be 2 16 bit values
16:14:16 <parsecUser> And Text is UTF 16 right?
16:14:27 <grantwu> Yes.  I wish it was UTF-8.
16:14:33 <parsecUser> So in theory ~2x more dense
16:14:37 <parsecUser> than String
16:14:46 <grantwu> Far more dense, I belive.
16:14:49 <parsecUser> (perhaps more because of the linked list pointers
16:14:53 <grantwu> yeah, that.
16:15:23 <geekosaur> also each cons cell and each Char has a constructor tag; a Text has a single constructor tag for the whole thing
16:15:50 <parsecUser> Hmm, so in theory, it should just be way better. Curious if that'll match reality :)
16:15:58 <geekosaur> ob a 64-bit system String is *really* wasteful for more than a couple characters
16:17:02 <davean> parsecUser: Text trashes String basicly all the time
16:18:16 <parsecUser> I believe it, but I'd love to see concrete evidence. For example, it'd be quite helpful if this kind of info was in the Parsec docs
16:18:45 <Welkin> don't listen to people who talk badly about String
16:18:55 <davean> Welkin: ...
16:18:55 <Welkin> I have used String for plenty of things and it works perfectly fine
16:19:00 <parsecUser> Anyway, thanks for pointing me to some source code that made it clearer that things would be nice!
16:19:02 <Welkin> it depends on what you are doing
16:19:09 <Welkin> String is convenient
16:19:10 <grantwu> I have used Python for plenty of things and it works perfectly fine
16:19:36 <Welkin> grantwu: no it doesn't
16:19:39 <davean> I've also done a lot of things by hand, it was about as fast as using String.
16:19:49 <davean> Welkin: yes, and neither does String
16:19:55 <davean> Welkin: which is kinda the point
16:20:12 <Axman6> each character in a String takes up something like 4 words plus the size of the Char's value itself. on a 64 bit system, that makes each _character_ take up yp to 36 _bytes_. in Text, it's 2 byte4s per character plus 4-5 words for the whole Text
16:20:16 <Welkin> it's like saying you want to use HashMap instead of Map because you think it will be a million times faster
16:20:49 <davean> Welkin: No, String is far worse then that comparison
16:21:23 <Axman6> calculation is roughtly: 1 word header for list cons, 1 word pointer to character value, one word pointer to the tail of the list, then one word header for the character itself, and (probably) 4 butes for the Char data
16:21:55 <grantwu> And worse memory locality...
16:21:57 <davean> Plus String cache misses like crazy in practice
16:22:07 <grantwu> Hrm, there should be a way to like, provide a list like view for Text right?
16:22:10 <Axman6> Text is 1 word header, one inlined Int for array lengrth, one inlined Int for array offset, and n*2 bytes for the character data
16:22:16 <Welkin> if you don't care about performance
16:22:18 <davean> Meaning you process at the speed of memory latency on moderate sized strings
16:22:19 <Welkin> then none of that matters o.o
16:22:32 <davean> The Intel predictor does not seem to work on Haskell's code for String
16:22:39 <Welkin> if you just need to write a script that you will run a couple times in a month or year
16:22:42 <Axman6> I care about not needing 32GB ram to run my program :P
16:22:53 <grantwu> Sure, but like, that's implicit
16:23:08 <grantwu> that being "the criticisms of String are about performance"
16:24:07 <davean> Welkin: they were also SPECIFICLY asking about performance
16:26:05 <geekosaur> performance actually varies wildly. if the compiler can fuse the list away then it's very fast. if not... it sucks
16:26:31 <sm> parsecUser: I switched a bunch of String parsers to Text and it didn't make a big difference in typical cases
16:26:40 <sm> you have to measure
16:26:55 <sm> it's also hard to get rid of String completely
16:27:45 <parsecUser> sm: I have heard the same thing
16:27:53 <parsecUser> about it being about the same
16:28:09 <parsecUser> I'm looking into why, and I think part may be that the `string` primitive uses uncons
16:28:12 <sm> it wasn't the same, but not the huge difference you might think
16:28:21 <parsecUser> instead of grabbing N characters
16:28:37 <parsecUser> So what should be one operation becomes N operations
16:28:59 <xcmw> Any not painful way to write this javascript in haskell? http://lpaste.net/341707 In the real code there are more properties than just x and y. I managed to get q typed in haskell but it required boxing and unboxing of variables, type families, and a bunch of other advanced features.
16:29:57 <jle`> xcmw: what's the result?
16:31:12 <xcmw> jle` z = {x: "HiW", y: 5}
16:32:13 <coms> Inductive types are intensional by necessity?
16:32:26 <xcmw> [] means property access by string and object.assign means make a copy
16:37:06 <xcmw> jle`: http://lpaste.net/341750 is my attempt in haskell. q works with correct typechecking
16:37:14 <pikajude> Is there a haskell PCRE regex library that doesn't have C dependencies?
16:38:12 <Axman6> a better question is, do you really need regexes?
16:38:30 <pikajude> swagger "patterns" are regular expressions
16:38:36 <pikajude> so i can either tell users to piss off or support them in my code
16:39:26 <sm> pikajude: regex-tdfa is good
16:39:34 <pikajude> and is posix only
16:39:46 <pikajude> cmon #haskell D:
16:40:06 <sm> regex-posix ?
16:40:12 <pikajude> is also posix only
16:40:27 <sm> oh I thought you were requiring posix only. regex-tdfa is not
16:40:57 <pikajude> oh is that so
16:41:15 <sm> well.. it's POSIX ERE. What do you mean ?
16:41:37 <pikajude> POSIX and PCRE regexes are the same?
16:41:48 <Axman6> wait, are you allowing the execution of arbitrary regular expressions in your code?
16:41:55 <pikajude> i can't possibly avoid it
16:42:00 <Clint> pikajude: no
16:42:15 <sm> I guess not. I think see what you mean, and I guess no there's no native PCRE lib
16:44:24 <sm> regexpr is a bit perl-like, and native
16:47:04 <glguy> xcmw: You just generally wouldn't do something this unstructured in Haskell
16:48:10 <glguy> xcmw: If it's what you want to do you can model the same kind of javascript values with data Value = Int Int | Object (Map String Value) | Function (Value -> Value) and go from there
16:50:02 <xcmw> glguy: Then it would not be type safe. I have q working with type safetly. I think I get get g working. z will be difficult
16:50:25 <mlehmk> I think I found a bug in lambdabot
16:50:43 <mlehmk> @pl \f x y -> f <$> x <*> y
16:50:43 <lambdabot> (. (<*>)) . (.) . (<$>)
16:50:57 <mlehmk> but: ((<*>) .) . (<$>)
16:51:21 <Koterpillar> :t ((<*>) .) . (<$>)
16:51:23 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
16:51:31 <Koterpillar> :t (. (<*>)) . (.) . (<$>)
16:51:32 <lambdabot> Applicative f => (a1 -> b) -> f (a -> a1) -> f a -> f b
16:52:00 <Koterpillar> mlehmk: looks different
16:52:16 <mlehmk> to \f -> (<*>) . ((<$>) f) was easy
16:52:51 <mlehmk> but then I added () to \f -> ((<*>) .) ((<$>) f) and then I could remove the point f to the final
16:53:54 <phong> I'm new to Haskell, any one please me with 2d array list comprehension problem?
16:55:41 <ezyang> Is there any standard libraries of "missing" System.IO functions? 
16:56:52 <mlehmk> what would be "missing"?
16:57:08 <sm> http://hackage.haskell.org/package/MissingH ?
16:57:16 <phong> Does any one know how 4x4 sudoku solver with haskell?
16:58:18 <mmaruseacph2> just like the 9x9 one
16:59:22 <phong> yes, but the problem have constraint of sign in vertical and horizontal which is "greater than sudoku" 
16:59:51 <phong> like -1 is decreasing and 1 increasing
17:00:05 <phong> between row and column
17:01:13 <mmaruseacph2> that's not sudoku anymore, but just another constraint satisfaction problem
17:01:17 <mmaruseacph2> looks like homework
17:01:53 <phong> yes
17:02:04 <Welkin> yes
17:02:11 <Welkin> all of your questions sound like homework exercises
17:02:13 <phong> its is one of my homework in functional programming class
17:02:31 <Welkin> this is not a place where you ask other people to do your homework for you
17:03:04 <phong> im not asking to do my homework
17:03:20 <phong> if anyone know there is a way
17:03:48 <phong> idk this channel for other purpose
17:03:50 <Welkin> phong: show us your work, and if you run into a specific problem, ask for help
17:04:14 <Welkin> but no one is going to do your homework for you
17:04:34 <grantwu> Is there a way?  yes, there is a way.
17:06:39 <phong> i was using remainder to find cell position in js and it work well. I do the same thing in haskell, it turned out does work
17:06:47 <mlehmk> sudoku solver in Haskell. sounds interesting
17:07:36 <mlehmk> the fun thing, you don't need to write all that code to find patterns... there's pattern matching
17:11:18 <kadoban> Bird wrote up an interesting way to handle that, I think it's free online somewhere, an excerpt from uhm Pearls of Functional Algorithm Design, or whatever that's called.
17:16:48 <mlehmk> solve (Just a1:Just a2:Just a3:Just b1:Just b2:Just b3:Nothing:Just c2:Just c3) = (Just a1:Just a2:Just a3:Just b1:Just b2:Just b3:Just (45 - a1 - a2 - a3 - b1 - b2 - b3 - c2 - c3):Just c2:Just c3)
17:17:01 <mlehmk> I guess something like that could be one thing of it
17:17:19 <mlehmk> that'd be a lot of repetitive code
17:19:17 <phong> thanks mlehmk
17:19:28 <mlehmk> that code doesn't even work
17:19:51 <Tuplanolla> I'd just use a SAT solver.
17:20:35 <mlehmk> and maybe making it monadic might help with all the transformations and iterations
17:28:48 <Tuplanolla> Is there a collection of answers to homework problems, but with time complexities like O(2^n!) instead of something reasonable?
17:31:51 <hpc> you wouldn't really learn much from them
17:32:26 <grantwu> I think Tuplanolla was saying the channel could use them to troll people doing homework
17:33:09 * hackagebot pretty-display 0.1.8 - Typeclass for human-readable display  https://hackage.haskell.org/package/pretty-display-0.1.8 (jsermeno)
17:34:51 <mlehmk> sum $ (2^) <$> [0..] = -1
17:35:32 <grantwu> > sum $ (2^) <$> [0..]
17:35:38 <lambdabot>  mueval-core: Time limit exceeded
17:35:40 <mlehmk> haha
17:35:49 <mlehmk> you know Ramanujan sums?
17:35:52 <grantwu> hrm, is ^ exponentiation?
17:36:01 <grantwu> I do not, but I've heard that that's how you can get -1
17:36:07 <geekosaur> one of them
17:36:08 <grantwu> > 2^100
17:36:11 <lambdabot>  1267650600228229401496703205376
17:36:12 <geekosaur> ^, ^^, **
17:36:22 <geekosaur> different constraints, different limitations
17:36:26 <mlehmk> ^ returns Integer, ^^ returns Fraction
17:36:37 <grantwu> :t (^, ^^, **)
17:36:38 <mlehmk> although... uhm...
17:36:39 <lambdabot> error: parse error on input ‘,’
17:36:44 <grantwu> hrm
17:36:53 <grantwu> :t ((^), (^^), (**))
17:36:54 <lambdabot> (Num a, Integral b1, Integral b, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
17:38:23 <mlehmk> anyways, given that sum of all 2^ end in -1, it looks like the universe works in 2-complement
17:38:53 <mlehmk> or we just haven't defined exactly (-0) being different from 0
17:39:12 <mlehmk> ;)
17:40:27 <mlehmk> it's still fun how this correlates in a finite subset
17:41:51 <Tuplanolla> Ramanujan sums, you say?
17:42:06 <Tuplanolla> > ѕum [1 ..]
17:42:09 <lambdabot>  (-1) % 12
17:42:58 <grantwu> wat
17:43:05 <grantwu> > sum [1 ..]
17:43:13 <lambdabot>  mueval: ExitFailure 1
17:43:23 <grantwu> are you controlling lambdabot or something
17:43:26 <Koterpillar> is that the "redefine stuff in /msg" again?
17:43:38 <grantwu> oh, probably
17:43:40 <Tuplanolla> Yes.
17:43:56 <Tuplanolla> The puzzle is to figure out how I did it.
17:44:52 <grantwu> > sum undefined
17:44:54 <lambdabot>  error:
17:44:55 <lambdabot>      Ambiguous occurrence ‘sum’
17:44:55 <lambdabot>      It could refer to either ‘Data.List.sum’,
17:45:03 <grantwu> -_-
17:45:07 <byorgey> > ѕum [1 ..]
17:45:10 <lambdabot>  (-1) % 12
17:45:13 <byorgey> works OK for me.  you must be doing it wrong.
17:45:23 <mlehmk> > sum [0 ..]
17:45:26 <lambdabot>  error:
17:45:26 <lambdabot>      Ambiguous occurrence ‘sum’
17:45:26 <lambdabot>      It could refer to either ‘Data.List.sum’,
17:46:13 <Koterpillar> one part is surely
17:46:14 <Koterpillar> > Blah
17:46:16 <lambdabot>  error: Data constructor not in scope: Blah
17:46:23 <Koterpillar> wait, where's my blah
17:46:54 <grantwu> I ate it.
17:47:16 <Koterpillar> oh, unicode too
17:47:17 <mlehmk> sum cycle [1,-1]
17:47:54 <grantwu> > sum cycle [1, -1]
17:47:55 <Koterpillar> > "ѕum"
17:47:56 <lambdabot>  error:
17:47:56 <lambdabot>      • Couldn't match type ‘[a0]’ with ‘[t0] -> t’
17:47:56 <lambdabot>        Expected type: [a0] -> [t0] -> t
17:47:57 <lambdabot>  "\1109um"
17:48:06 <Tuplanolla> The plot thickens!
17:48:38 <mlehmk> > ѕum [0 ..]
17:48:40 <lambdabot>  error:
17:48:40 <lambdabot>      • Variable not in scope: ѕum :: [Integer] -> t
17:48:40 <lambdabot>      • Perhaps you meant one of these:
17:50:12 <mlehmk> @let 🤚 = "Stop!"
17:50:13 <lambdabot>  Parse failed: Illegal character ''\129306''
17:50:29 <geekosaur> :t sum
17:50:31 <lambdabot> (Foldable t, Num a) => t a -> a
17:50:34 <Tuplanolla> Turns out lambdabot allows a few of the Unicode characters GHC does, but not all of them.
17:50:42 <mlehmk> @let _🤚 = "Stop!"
17:50:42 <lambdabot>  Parse failed: Illegal character ''\129306''
17:50:46 <mlehmk> koay
17:50:51 <geekosaur> yeh, mueval has some limits iirc
17:51:17 <Tuplanolla> Otherwise I would've shown off my Akkadian cuneiform `fold`.
17:51:37 <mlehmk> > "🤚"
17:51:38 <lambdabot>  <hint>:1:2: error:
17:51:38 <lambdabot>      lexical error in string/character literal at character '\129306'
17:52:06 <mlehmk> > ['\129306']
17:52:08 <lambdabot>  "\129306"
17:52:18 <mlehmk> well... that's for today
17:52:43 * geekosaur should really report ghc rejecting Char and String literals with Private Use Area characters in them, since xmonad folks periodically trip over it. (escape forms work, the UTF8 doesn't)
17:57:16 <dmwit> > "ѕum"
17:57:18 <lambdabot>  "\1109um"
17:57:33 <geekosaur> > text "\1109"
17:57:34 <Tuplanolla> The types match the intuition perfectly: http://users.jyu.fi/~sapekiis/tmp/cuneiform.png
17:57:35 <lambdabot>  ѕ
17:58:25 <dmwit> There's something delightful about "please" as a prompt.
17:58:50 <hpc> gotta say the magic word
18:00:03 <geekosaur> ok, why the Macedonian "s" in the Cyrillic block?
18:00:29 <geekosaur> oh, I guess that's just messing around :p
18:03:55 <byorgey> Tuplanolla++
18:04:48 * geekosaur eyes 1970s throwback display >.>
18:05:13 <geekosaur> actually that can't be true, it's too crisp >.>
18:27:04 <Squarism> ive got this threaded app that throws around a "Config" parameter to every function. most functions have result IO x. Ive seen alot of api's that rely on their own monad type (deriving MonadIO) where they encode extra fields etc. Is that how i should do to avoid throwing config around everywhere?
18:34:06 <geekosaur> it does sound like a good use for a ReaderT Config IO deriving MonadIO
18:34:17 <Axman6> that's one way yes. there's MonadFork (https://hackage.haskell.org/package/monad-fork-0.1/docs/Control-Monad-Fork-Class.html) which might make things less painful too - if you're using something like ReaderT Config IO, then you should be able to use its fork function instead of forkIO and get the same behaviour
18:34:35 <geekosaur> (actually I think MonadIO is already derived for MonadReader IO)
18:34:50 <Axman6> yes
18:40:10 <Squarism> Geekingfrog, Axman6, thanks 
18:40:39 <Squarism> so ReaderT is the conventional approach to this situation?
18:43:12 * hackagebot stm-supply 0.1.0.0 - STM wrapper around Control.Concurrent.Supply.  https://hackage.haskell.org/package/stm-supply-0.1.0.0 (jmc41493)
18:44:18 <EvanR> can anyone tell me what this letter is http://i.imgur.com/1vgBolx.png
18:45:38 <EvanR> Squarism: compare and contrast the difference between doing that and just passing the config directly 
18:45:59 <grantwu> \say \varrho
18:46:04 <grantwu> ...well, it's \varrho
18:46:13 <grantwu> I think?
18:47:32 <Axman6> Squarism: yeah, Reader is the canonical answer to "how do I pass around configuration" question
18:47:32 <Squarism> EvanR, It was more a "revelation/insight" than a question maybe. Or NOW i can see the real benefit of Reader monad
18:48:21 <geekosaur> yeh, that's \varrho
18:48:35 <grantwu> I used detexify for it, lol
18:48:36 <Axman6> if you find yourself using State and or Writer too, take a look at the RWST transform
18:51:10 <Squarism> im starting to see the point of crazy looking types like : newtype ActionCtxT ctx m a
18:51:11 <Squarism>     = ActionCtxT
18:51:11 <Squarism>     { runActionCtxT :: ErrorT ActionInterupt (RWST (RequestInfo ctx) () ResponseState m) a }
18:51:28 <Squarism> *englightment*
18:51:59 <EvanR> ah so its a funny rho
18:52:37 <EvanR> Squarism: well... its certainly in use, but enlightened...
18:53:27 <EvanR> you have to do stuff like that to use certain libraries
18:53:49 <EvanR> when you write it all yourself, then you have the choice to not have a jungle of transformers in every level
18:54:35 <geekosaur> (A wild ExceptT appears!)
18:55:27 <Squarism> EvanR, from POV it looked like joke seeing them for the first time. "Am i really supposed to understand that" or "Im inferior" or "Severe case of overengineering"
18:56:13 <geekosaur> one gets tired of typing those things all the time
18:56:25 <Squarism> im glad it starts to make some sense anyway
18:56:59 <Squarism> geekosaur, i bet
19:02:55 <EvanR> if you write it yourself, then you can choose to set up an API that your huge monad will satisfy, and then implement it with a custom monad, a tower of transformers on IO, or just IO by itself
19:03:04 <EvanR> and the choice can be made or changed later
19:04:03 <EvanR> you have to come up with this API at some point anyway because explicit use and selection of the 5 MonadState functions is verbose and a pain
19:04:17 <EvanR> so im saying it makes sense to do it first instead of last
19:04:26 <EvanR> not starting with the transformer stack implementation by default
19:04:53 <EvanR> i meant to say, the 5 kinds of monadstate monads that are included somewhere in the stack
19:09:31 <slack1256> I am reading some code that is really easy to follow because it just uses IO everywhere and the uses of monad stacks is localized and concrete instantiated.
19:10:09 <slack1256> My code always uses mtl constrains and thus usually lives in the union of all monads.
19:10:45 <slack1256> (even if only 1 function of the whole, uses a certain layer of the stack)
19:11:07 <slack1256> how do I remain polymorphic and maintain local concrete stacks without boilerplate?
19:11:31 <Rotaerk> example WITH boilerplate?
19:13:28 <slack1256> newtype LocalMonad a = LM (StateT Int (ReaderT Double IO) a) + GenerilizedNewtypeDeriving
19:14:01 <slack1256> yet this monad will be probably used *once* and thus only exists for code clarity purposes
19:18:05 <Rotaerk> hmm, not clear on whether I understand the question, but what about: (MonadState Int m, MonadReader Double m, MonadIO m) => m a
19:18:50 <Axman6> that's what you'd use for the types of the functions using thi monad
19:19:22 <Rotaerk> right
19:19:34 <Axman6> so, you'd use foo :: (MonadState Int m, MonadReader Double m, MonadIO m) => m a; foo = ... and then your app would instantiate it with LocalMonad 
19:20:23 <slack1256> somehow, I end up with whole applications living in the union of all monads in the code
19:20:50 <Axman6> GHC 8 will tell you about redundant constraints luckily
19:21:53 <glguy> slack1256: Maybe show the actual code you're looking at and what boilerplate it is you're trying to get rid of?
19:23:49 <slack1256> just the guy I wanted to talk about
19:24:01 <slack1256> I was reading code of yours when I reached this conclusion :-D
19:25:39 <slack1256> I was reading the Client.Network.Async module in glirc v2 branch and saw you never define weird monad transformers anywhere. Just plain IO, and is perfectly clear
19:25:50 <slack1256> mine degenerates in stuff like this 
19:27:41 <slack1256> (sorry, I got no old projects in this computer)
19:28:43 <Polymorphism> whats a monad
19:29:04 <Polymorphism> !monad
19:29:05 <Cale> Polymorphism: Are you familiar with types that have type parameters?
19:29:22 <glguy> I generally don't write code in terms of various Monad-like constraints unless I know I'm going to need them at multiple types, and when I do I don't expose mtl classes, I expose classes specific to the problem at hand
19:29:28 <Cale> A monad is a parametric type m which comes equipped with some operations:
19:29:34 <Cale> return :: a -> m a
19:29:36 <Cale> and
19:29:39 <glguy> I think once you start needing FlexibleContexts with mtl's typeclasses you're doing something wrong
19:29:41 <Cale> (>>=) :: m a -> (a -> m b) -> m b
19:29:51 <Cale> and those have to satisfy some conditions
19:30:26 <Polymorphism> ty
19:31:43 <Cale> Polymorphism: You can really only get a sense for what this means by looking at examples, but practically all of the examples we care about will have an interpretation where m a will be some type of "computations" or "actions" or "descriptions of something to be done" whose result will have type a
19:32:11 <Cale> and then return v will be the action which "does nothing" (whatever that means), except to always produce v as its result
19:32:22 <slack1256> glguy: I guess I define newtypes for monads when I will use them just once. The payoff isn't really big then
19:32:46 <Cale> and x >>= f will be the action which will first perform the action x, and then if its result is v, will then perform f v, producing the result of that second action as its own
19:33:46 <glguy> slack1256: like this? https://github.com/glguy/irc-core/blob/v2/src/Config/FromConfig.hs#L54
19:34:47 <Cale> Polymorphism: So for example, a parsing library might define a monad called Parser such that a value of type Parser t will be something that looks at the beginning of whatever remains of the input, and attempts to produce a result of type t (possibly in many ways, if it's a parser with backtracking)
19:35:23 <Cale> and then return v will be the parser which always accepts in a unique way, without consuming any input, producing the result v
19:35:36 <Cale> i.e. if v :: a, then return v :: Parser a
19:36:21 <Cale> and  p >>= f  will be the parser which parses the initial part of the input with the parser p, and then takes the result of that parsing, and applies f to it to obtain a parser with which to parse the rest of the input
19:37:19 <Cale> (and if the second parser fails, it might go back and get a second result of the parser p, apply f to that and try to proceed again from there)
19:37:57 <Cale> and the result(s) of the combined parser will be the results of the parser(s) that f produces
19:39:08 <Cale> Polymorphism: make some sense? I know it's a bit of a mouthful, depending on what you've seen before.
19:40:18 <slack1256> glguy: like that, yet I don't constrain them to a sole module, they end up prograpagating everywhere
19:40:22 <slack1256> I need more discipline
19:40:53 <slack1256> I need to explicitly runParser, runMyMonad at well defined boundaries (that match module descriptions)
19:41:52 <Polymorphism> taking it all in
19:50:45 <Cale> Polymorphism: I have an article here which explains it more carefully https://wiki.haskell.org/Monads_as_computation
19:52:47 <Koterpillar> I want to change the version numbering scheme for a package from A.B.C.D to just A.B.C; for future releases only. Will there be any problems with doing that on Hackage?
19:55:34 <pavonia> Koterpillar: There seem to be cases where some tools are taking a.b.c.0 and a.b.c for different version numbers
19:55:49 <kadoban> Koterpillar: I don't think so, but you may want to make sure you increment versions the first time you do so so it's unambiguous.
19:56:11 <Koterpillar> Yes, I'll do that (from A.B.C.0 to A.B.(C+1))
20:04:06 <Polymorphism> I will read it, ty cale
20:05:41 <tsani> cabal considers 5.0 distinct from 5 iirc
20:05:55 <tsani> which bit me when recursion-schemes went to version 5
20:06:44 <tsani> So I wouldn't be surprised if cabal considers a.b.c.0 distinct from a.b.c
20:08:00 <Koterpillar> as long as A.B.(C+1) > A.B.C.0, I should be fine
20:08:05 <Koterpillar> is it?
20:08:12 <kadoban> It seems fine if it considers it distinct, the more important question would be which it considers "newer"
20:08:54 <kadoban> As long as it doesn't magically condsider anything with 4 numbers "newer" than anything with 3, should be fine. Which I'm fairly sure it'd treat it the expected way.
20:11:32 <tsani> iirc I had specified recursion-schemes >=5.0 && <5.1, and cabal rejected recursion-schemes 5
20:11:53 <tsani> so it seems zero is newer than nothing
20:12:48 <tsani> but I would be surprised if a.b.(c+1) wheren't considered newer than a.b.c.0
20:20:02 <haskell534> I have a recursively defined datatype and I want to add information to each constructor, is there a better way of doing than that? http://lpaste.net/340384
20:24:35 <glguy> haskell534: you can use pattern synonyms to hide the unit when not using the annotations
20:28:22 <haskell534> glguy could you provide an example? I'm not sure I'm understanding the documentation
20:29:59 <glguy> pattern A' x = A x ()
20:31:14 <haskell534> so in my case, I would use "pattern FooA = Foo ()"?
20:32:45 <bollu1> for ghcjs, do I always need reflex platform installed?
20:33:17 <pikajude> other way around
20:33:33 <pikajude> wait no, that's not even true. you can use the GTK one
20:33:34 <bollu> hmm
20:33:36 <pikajude> bollu: no
20:33:42 <pikajude> they're independent
20:36:33 <pikajude> is leksah reliable? i'm wanting to use a decent IDE after having started using one for java at work, and vim isn't cutting it
20:37:24 <Koterpillar> at least the versions on Hackage are listed in the right order, hopefully it'll work. Thanks everyone!
20:38:16 * hackagebot tianbar 1.2.4 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.2.4 (AlexeyKotlyarov)
21:08:25 <EvanR> pikajude: i would like to know the answer to that, i mentioned leksah to someone in my haskell meetup who is interested in IDEs, maybe they will report back. so far intelliJ isnt cutting it for them
21:09:59 <ania123> exprs :: [Int] -> [Expr]
21:10:00 <ania123>  exprs []  = []
21:10:04 <ania123> this program
21:10:09 <ania123> for the input
21:10:26 <ania123> exprs []  <interactive>:191:1: error:     • No instance for (Show Expr) arising from a use of ‘print’     • In a stmt of an interactive GHCi command: print it
21:10:33 <ania123> givs this error, why?
21:11:32 <EvanR> it wants to show you the result but that requires a Show instance
21:11:42 <EvanR> specifically for the type Expr
21:11:51 <glguy> because there's no instance for (Show Expr)
21:12:12 <glguy> and one was needed from your implicit use of print
21:12:45 <ania123> data Expr = Val Int | App Op Expr Expr
21:12:53 <ania123> i have defined Expr type
21:12:58 <Clint> did you derive a Show instance?
21:13:03 <EvanR> try adding: deriving (Show) 
21:13:15 <ania123> how can I add it?
21:13:29 <ania123> what show instance means?
21:13:35 <EvanR> :t show
21:13:37 <lambdabot> Show a => a -> String
21:13:49 <EvanR> its a class for converting stuff to a string
21:14:50 <ania123> why do I need show function?
21:14:56 <EvanR> :t print
21:14:58 <lambdabot> Show a => a -> IO ()
21:15:12 <EvanR> ghci uses this to show you the result
21:15:37 <ania123> so,
21:15:51 <ania123> is not show builtin?
21:16:22 <EvanR> theres not a way to show every type
21:16:51 <EvanR> like IORefs, IO actions, functions, opaque abstract data types
21:17:04 <kadoban> ania123: The Show typeclass is builtin, in a sense. But a type must still implement it, or it can't be used on that type.
21:19:19 <ania123> :(
21:19:30 <ania123> can one tell me what I have to add exactly ?
21:19:34 <ania123> not clear
21:19:37 <ania123> sorry :(
21:19:39 <ezyang> The Show class is not a builtin 
21:19:41 <EvanR> a deriving clause
21:19:44 <ddere> for the most part you can just add `deriving (Show)`
21:19:53 <EvanR> data Foo = Bar deriving (Show)
21:20:20 <kadoban> ezyang: It's as close as it gets in haskell, it's in the report even, isn't it? It's part of the language.
21:20:44 <EvanR> its just another class
21:20:55 <ezyang> The report defines it, but only because the language report discusses some types that should be defined 
21:21:02 <ania123> i still get error
21:21:16 <ania123> exprs []  <interactive>:196:1: error:     • No instance for (Show Expr) arising from a use of ‘print’     • In a stmt of an interactive GHCi command: print it
21:21:43 <ezyang> ania123: pastebin your code 
21:21:57 <EvanR> @where lpaste
21:21:57 <lambdabot> http://lpaste.net/
21:22:23 <ania123> http://pastebin.com/00mMrjnA
21:22:33 <MarcelineVQ> :>
21:22:46 * Clint chuckles.
21:22:47 <ania123> this small sample
21:22:54 <ania123> for example
21:22:55 <EvanR> pastebin ;_;
21:23:04 <ezyang> that's not your full code 
21:23:09 <ezyang> put the deriving (Show) on your data Expr definition 
21:23:47 <Koterpillar> ania123: https://en.wikipedia.org/wiki/Foobar
21:24:04 <ania123> http://pastebin.com/JF5b2UA9
21:24:45 <ddere> `data Expr = Val Int | App Op Expr Expr  deriving (Show)`, probably have to add it to `Op` too
21:27:33 <ania123> ddere: does not work
21:28:08 <EvanR> lpaste your code and the error message
21:30:21 <ania123> http://lpaste.net/4143352261801672704
21:30:56 <EvanR> wheres the data Expr ?
21:31:04 <EvanR> ah i see it
21:31:10 <EvanR> you didnt put the deriving clause
21:31:24 <ania123> ah sorry
21:31:30 <ania123> in this version I did not
21:32:02 <ddere> did you add it to `Op` too>
21:34:33 <ania123> http://lpaste.net/5561317267691536384
21:35:41 <pavonia> There's an extra '|'
21:36:44 <ania123> data Op = Add | Sub | Mul | Div deriving (Show)
21:36:58 <ania123> data Expr = Val Int | App Op Expr Expr deriving (Show)
21:37:02 <ania123> like this?
21:37:06 <ddere> yeah that would be right ^
21:37:06 <ania123> has to be?
21:37:30 <ania123> sum.hs:15:42: error: parse error on input ‘deriving’
21:37:38 <ania123> i get this error
21:38:22 <pavonia> It's the very same error there
21:38:42 <ddere> yeh you have not removed the `|` yet
21:38:44 <ania123> what it means?
21:38:49 <ania123> why I get it?
21:39:16 <pavonia> A '|' is not allowed directly before a "deriving"
21:39:35 <ddere> because after the `|` it is expecting another case, (i.e another name with a capital letter e.g "Bar")
21:39:36 <ania123> I removed it
21:39:38 <ddere> remove the `|`
21:39:43 <ania123> I did
21:39:48 <ania123> data Expr = Val Int | App Op Expr Expr deriving (Show)
21:39:49 <ddere> try compiling it one more time
21:39:50 <ezyang> arrrgh why isn't Haskell reaping my subprocesses when I ctrl-C 
21:39:50 <EvanR> it works for me when I remove the |
21:39:52 <ania123> data Op = Add | Sub | Mul | Div deriving (Show)
21:39:53 <ezyang> driving me batty 
21:40:03 <ania123> now is like this
21:41:00 <ania123> thx
21:41:02 <ania123> it works
21:41:07 <ania123> thank you very much!
21:41:11 <ania123> all of you
21:41:14 <EvanR> haskell wouldnt be doing that, the OS would if the processes had the parent child relationship
21:41:36 <EvanR> but when you simply fork, I dont think thats how it gets set up
21:41:58 <ania123> deriving (Show)
21:42:06 <ania123> is to derive output
21:42:14 <ania123> it is needed only for it
21:42:15 <ania123> is not?
21:42:34 <EvanR> it derives an instance of the Show class, you could also write it yourself
21:42:43 <EvanR> instance Show Expr where ...
21:42:56 <EvanR> maybe you should read a guide on type classes
21:43:18 <ania123> ok
21:43:20 <ania123> thx
22:02:36 <Guest86433> would you guys help me with this error in haskell
22:02:49 <Guest86433> would you guys help me with this error in haskell
22:03:13 <Koterpillar> not until you show us what the error is
22:03:18 <Guest86433> *Main> set2D ["0000","0000","0000","0000"] 0 0 0  <interactive>:349:41: error:     • No instance for (Num Char) arising from the literal ‘0’     • In the fourth argument of ‘set2D’, namely ‘0’       In the expression: set2D ["0000", "0000", "0000", "0000"] 0 0 0       In an equation for ‘it’:           it = set2D ["0000", "0000", "0000", ....] 0 0 0
22:03:55 <Koterpillar> what's set2D?
22:03:57 <Guest86433> i'm trying to add element into a character 2d array
22:04:12 <Guest86433> set2D :: [[a]] -> Int -> Int -> a -> [[a]] set2D (row:rows) ro co el       | ro == 0	       = (set1D row co el):rows       | otherwise      = row:(set2D rows (ro-1) co el)   set1D :: [a] -> Int -> a -> [a] set1D (col:cols) co el       | co == 0		= el:cols       | otherwise	= col:(set1D cols (co-1) el)
22:04:17 <Guest86433> here is the code
22:04:21 <Koterpillar> please use lpaste.net to paste
22:04:33 <Guest86433> it only work if the array is all Int
22:04:48 <Koterpillar> that's because the type of the last argument doesn't match
22:05:00 <Koterpillar> :t 0
22:05:02 <Koterpillar> :t "0"
22:05:02 <lambdabot> Num t => t
22:05:05 <lambdabot> [Char]
22:05:12 <Guest86433> http://lpaste.net/342454
22:06:20 <Koterpillar> still what I said; the element has to match the type of the elements in the list
22:06:50 <Guest86433> so the element is Int then the array must be int ?
22:07:00 <Koterpillar> yeah
22:07:09 <Koterpillar> and if your array is of chars, then the element must be a char
22:07:19 <Koterpillar> set2D :: [[a]] -> Int -> Int -> a -> [[a]]
22:07:23 <Koterpillar> that's what you wrote
22:07:31 <Guest86433> is there any way that I can convert int to char?
22:07:39 <Koterpillar> :t chr
22:07:41 <lambdabot> Int -> Char
22:08:10 <Koterpillar> :t show
22:08:11 <lambdabot> Show a => a -> String
22:08:18 <Koterpillar> :t show `asAppliedTo` "a"
22:08:19 <lambdabot> [Char] -> String
22:08:22 <Koterpillar> :t show `asAppliedTo` 0
22:08:23 <lambdabot> (Show a, Num a) => a -> String
22:08:56 <bollu1> :t asAppliedTo
22:08:57 <lambdabot> (a -> b) -> a -> a -> b
22:09:07 <Guest86433> should I write a separate function that will convert int to char and char to Int
22:09:10 <bollu1> hahaha, clever
22:09:24 <Guest86433> I will need lots of conversion for those 2 type 
22:09:29 <Koterpillar> why?
22:09:51 <Koterpillar> particularly, how would you convert "哈" to Int?
22:10:09 <Guest86433> i have no idea lol
22:10:24 <Koterpillar> then... what do you really want to do?
22:10:52 <kadoban> > ord '哈'
22:10:53 <lambdabot>  21704
22:11:08 <Guest86433> this is getting confusing
22:11:32 <Koterpillar> > (const 42) '哈'
22:11:34 <lambdabot>  42
22:11:41 <Koterpillar> kadoban: there are many ways
22:11:53 <Guest86433> so i can just add :t show 'asAppliedTo' in my code to convert the element I want to insert into Char?
22:12:09 <kadoban> Koterpillar: Sure
22:12:29 <Koterpillar> don't worry about asAppliedTo
22:13:08 <Koterpillar> yes, you will need to write a function to convert Int to Char if you want to insert it into a Char array
22:13:09 <Guest86433> how can I do it Koterpillar
22:13:35 <Koterpillar> well, which Ints do you want to convert to which Chars?
22:14:04 <Guest86433> the 'el' in my code need to be char
22:14:16 <Koterpillar> yes, but which char?
22:14:30 <Guest86433> number 0-4
22:14:32 <Koterpillar> what do you want 0 to convert to?
22:14:48 <Guest86433> Int 0 to Char 0
22:15:05 <Koterpillar> '0'?
22:15:23 <Guest86433> yes
22:15:27 <EvanR> Guest86433: unless theres a good reason not to, decide on a single type for all this, like Int, and stick with it
22:15:46 <EvanR> only convert to Char on display, unless you are doing computations on the character itself
22:16:01 <ongy> is there an invers operation to ord?
22:16:06 <EvanR> chr
22:16:07 <Guest86433> because I need to use '-' for empty spot in my array 
22:16:13 <Guest86433> so i need the array to be char
22:16:18 <Koterpillar> maybe you'll be interested in Maybe?
22:16:27 <EvanR> for empty spots, you can do Maybe Int
22:16:28 <Koterpillar> (oops. pun unintended)
22:16:42 <EvanR> Nothing counts as empty
22:16:46 <Koterpillar> :t [Just 0, Nothing, Just 1]
22:16:48 <lambdabot> Num a => [Maybe a]
22:17:08 <Koterpillar> :t mapMaybe
22:17:09 <lambdabot> (a -> Maybe b) -> [a] -> [b]
22:17:45 <Guest86433> so i will do set2D :: [[a]] -> Int -> Int -> num a => [maybe a] -> [[a]]
22:18:32 <Koterpillar> no, you'll have an array of Maybe Int
22:18:50 <Koterpillar> set2D :: [[a]] -> Int -> Int -> a -> [[a]]
22:18:54 <Koterpillar> but a ~ Maybe Int
22:20:05 <Guest86433> ok let me try the maybe Int
22:21:32 <Guest86433> set2D :: [[a]] -> Int -> Int -> a~(Maybe Int) -> [[a]] this give me an error
22:21:54 <Koterpillar> no, leave the type alone
22:22:16 <Koterpillar> 'a' here can be any type: Int, Char, Maybe Int
22:22:23 <Koterpillar> and set2D will still work without modification
22:22:44 <Guest86433> let me give you the example of what the code is doing
22:23:56 <Guest86433> *Main> set2D [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]] 0 0 1 [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]] *Main> 
22:24:22 <Koterpillar> so, that  works
22:24:38 <Guest86433> *Main> set2D [[-,-,-,-],[0,0,0,0],[0,0,0,0],[0,0,0,0]] 0 0 1  <interactive>:362:10: error: parse error on input ‘,’
22:24:43 <Koterpillar> but if you want to represent absence of values in that array, it should be
22:24:47 <Guest86433> it give me an error if the array is Char
22:24:54 <Guest86433> it give me an error if the array contain Char
22:25:11 <Koterpillar> set2D [[Nothing, Nothing, Nothing, Nothing], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0]] 0 0 (Just 2)
22:25:23 <Guest86433> also this *Main> set2D ["0000","0000","0000","0000"] 0 0 1  <interactive>:363:41: error:     • No instance for (Num Char) arising from the literal ‘1’     • In the fourth argument of ‘set2D’, namely ‘1’       In the expression: set2D ["0000", "0000", "0000", "0000"] 0 0 1       In an equation for ‘it’:           it = set2D ["0000", "0000", "0000", ....] 0 0 1 *Main> 
22:25:39 <Guest86433> *Main> set2D ["0000","0000","0000","0000"] 0 0 1  <interactive>:363:41: error:     • No instance for (Num Char) arising from the literal ‘1’     • In the fourth argument of ‘set2D’, namely ‘1’       In the expression: set2D ["0000", "0000", "0000", "0000"] 0 0 1       In an equation for ‘it’:           it = set2D ["0000", "0000", "0000", ....] 0 0 1 *Main> 
22:25:40 <EvanR> you could also save time and space, and increase weirdness by using -1 instead
22:25:57 <Koterpillar> try that last example of mine
22:26:12 <Guest86433> ok let me try
22:26:29 <Koterpillar> EvanR: we don't know if -1 is a valid value
22:26:39 <EvanR> '-1' sure isnt
22:26:39 <Guest86433> *Main> set2D [[ , , ,],[0,0,0,0],[0,0,0,0],[0,0,0,0]] 0 0 1  <interactive>:365:10: error: parse error on input ‘,’
22:26:44 <Guest86433> also get an error
22:27:07 <Guest86433> but I will need the '-' for empty spot it an requirement
22:27:23 <EvanR> thats not a good representation
22:27:34 <Koterpillar> set2D [[Nothing, Nothing, Nothing, Nothing], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0]] 0 0 (Just 2)
22:27:38 <EvanR> you would rather show '-' later when you display the matrix
22:27:43 <EvanR> its not the underlying data
22:28:00 <Koterpillar> > map (map (maybe "-" show)) [[Nothing, Nothing, Nothing, Nothing], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0]]
22:28:02 <lambdabot>  [["-","-","-","-"],["0","0","0","0"],["0","0","0","0"],["0","0","0","0"]]
22:28:08 <Koterpillar> will that suffice?
22:28:44 <Guest86433> *Main> set2D [[Nothing, Nothing, Nothing, Nothing], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0]] 0 0 (Just 2) [[Just 2,Nothing,Nothing,Nothing],[Just 0,Just 0,Just 0,Just 0],[Just 0,Just 0,Just 0,Just 0],[Just 0,Just 0,Just 0,Just 0]]
22:28:47 <Guest86433> that worked
22:28:52 <EvanR> > map (map (maybe '-' intToDigit)) [[Nothing, Nothing, Nothing, Nothing], [Just 0, Just 0, Just 0, Just 0], [Just 0, Just 0, Just 0, Just 0], [Just 0,Just 0, Just 0, Just 0]]
22:28:54 <lambdabot>  ["----","0000","0000","0000"]
22:28:57 <EvanR> hehe
22:29:02 <Koterpillar> :t digitToInt
22:29:04 <lambdabot> Char -> Int
22:29:17 <Koterpillar> digitToInt '哈'
22:29:22 <Koterpillar> > digitToInt '哈'
22:29:24 <lambdabot>  *Exception: Char.digitToInt: not a digit '\21704'
22:29:52 <Guest86433> i would do digitToInt '-'?
22:29:59 <EvanR> no
22:30:25 <EvanR> do your computations on Ints and then display characters later if you want to
22:30:34 <Guest86433> sorry i'm really new with haskell so i'm kinda lost on all of this variable types
22:30:37 <EvanR> which intToDigit does
22:31:05 <EvanR> in haskell Char and Int arent the same type
22:31:19 <EvanR> you cant add chars or print out Ints as if they were chars
22:31:38 <EvanR> so you need to be more thoughful about which one you are using for what purpose
22:34:11 <Lokathor> so i have a setup where users connect to a server and enter rooms to play game
22:34:30 <Lokathor> but different rooms can be different games, so the "state" of the room will mean totally different things from room to toom
22:34:32 <Lokathor> room to room*
22:34:48 <Guest86433> is there any way I can insert Int into Char array?
22:35:00 <Lokathor> should Room be a typeclass in this sort of situation perhaps?
22:35:27 <Lokathor> Guest86433, you can use show on the int, and that turns it into a String
22:35:36 <Lokathor> then you could stick that string to your other string
22:35:57 <Lokathor> > (show 3) ++ "foo"
22:36:00 <lambdabot>  "3foo"
22:37:36 <EvanR> Guest86433: you cant put an Int into a Char array, sorry
22:37:50 <EvanR> think of it like the round hole square peg game
22:38:10 <Guest86433> set1D :: [a] -> Int -> a -> [a] set1D (col:cols) co el       | co == 0		= el:cols       | otherwise	= col:(set1D cols (co-1) el)
22:38:22 <pavonia> Guest86433: Note that in Haskell [a] denotes a *list* of values of type 'a', not an array. There's a type String which is short for [Char]
22:38:31 <EvanR> but you can have an array of Either Int Char, or an array of Int whose numbers correspond to the Chars you want
22:38:35 <Guest86433> so that is my code how can i convert el to Char
22:38:52 <EvanR> > digitToInt '0'
22:38:54 <lambdabot>  0
22:39:22 <Guest86433> set1D (col:cols) co digitToInt el
22:39:24 <Guest86433> would that work?
22:39:37 <EvanR> no because digittoInt is a function
22:39:42 <Guest86433> set1D (col:cols) co (digitToInt el)
22:39:50 <EvanR> ah
22:39:54 <Guest86433> hummmm
22:40:19 <pavonia> digitToInt converts from Char to Int
22:40:32 <EvanR> > intToDigit 0
22:40:34 <lambdabot>  '0'
22:40:37 <Guest86433> ohhh ok
22:41:39 <pavonia> > intToDigit 10
22:41:41 <lambdabot>  'a'
22:41:45 <EvanR> o_O
22:41:50 <Guest86433> @@
22:41:50 <pavonia> > intToDigit 20
22:41:52 <lambdabot>  *Exception: Char.intToDigit: not a digit 20
22:42:02 <Guest86433> set1D (col:cols) co (intToDigit el) this give me an error
22:42:05 <EvanR> > intToDigit 16
22:42:07 <lambdabot>  *Exception: Char.intToDigit: not a digit 16
22:42:08 <Guest86433> -_-
22:42:12 <EvanR> apparently it works for hex
22:42:21 <pavonia> Yeah
22:42:28 <Guest86433> error: Parse error in pattern: intToDigit
22:43:36 <Guest86433> arggg this data type is giving me a headache
22:46:37 <pavonia> You can't use function application in patterns
22:47:42 <mnoronha> Hey, if anyone's around was hoping for for general project advice
22:48:21 * hackagebot amby 0.2.1 - Statistical data visualization  https://hackage.haskell.org/package/amby-0.2.1 (jsermeno)
22:48:42 <Guest86433> would anyone help me with this error http://lpaste.net/342472
22:48:56 <Lokathor> mnoronha, better to just go ahead and ask, then people might know if they can help or not
22:50:12 <mnoronha> Lokathor, It's not really specific. I've just been working in haskell in class and don't have a great grasp of monads, etc. yet. I haven't learned anything practical yet, and I think trying to build somethign in haskell would help be shore up my foundation
22:50:13 <glguy> Guest86433: change the last 0 to '0'
22:50:34 <Guest86433> ok let me try
22:50:35 <mnoronha> (at a hackathon this weekend)
22:50:39 <glguy> you need a Char but provided a number literal
22:50:48 <Guest86433> wow that worked
22:51:58 <Guest86433> would you guys give me an example of passing variable from 1 function to the other function?
22:52:31 <Guest86433> onePlayerOneMove :: [[Char]] -> [[Int]] -> [[Int]] -> Int -> Int -> [[Char]]
22:52:36 <Guest86433> onePlayerOneMove ga ve ho sp va = ga
22:52:45 <Guest86433> here is my function
22:52:45 <Guest86433> getCol :: Int -> Int
22:52:50 <Guest86433> getCol sp = ceiling ((fromIntegral sp)/4) - 1
22:53:03 <Guest86433> so how can i pass 'sp' into getCol ?
22:53:48 <Guest86433> can i just call getCol sp from the onePlayerOneMove function?
22:54:42 <pavonia> Sure
22:57:03 <Guest86433> ok take a look at this http://lpaste.net/342474
22:57:56 <Guest86433> how do I pass those variables from onePlayerOneMove to other function
22:58:14 <Guest86433> otherwise = set2D ga (getRow sp) (getCol sp) va this gave me an error
22:59:30 <Guest86433> i need to add a given element with a given space into the Char array
23:01:11 <pikajude> EvanR: i'm trying it in a VM
23:01:18 <pikajude> since all the GTK crap can't be convinced to build on my mac
23:01:52 <pikajude> wonder if you have to build it with the same version of GHC you intend to use
23:04:11 <EvanR> pikajude: oh yeah... if you cant even install it that might be an issue
23:04:29 <EvanR> on OSX youre supposed to be provided with an "App"
23:04:33 <pikajude> it's because i dogmatically cling to nix when someone has probably packaged gtk in a satisfactory way using homebrew
23:04:34 <EvanR> you double click it
23:05:07 <pikajude> i can't think of a reason not to use that convention
23:06:08 <pavonia> Guest86433: What's the error message?
23:06:27 <Guest86433> csce322hw03pt01.hs:19:80: error:     • Couldn't match expected type ‘Char’ with actual type ‘Int’     • In the fourth argument of ‘set2D’, namely ‘va’       In the expression: set2D ga (getRow sp) (getCol sp) va       In an equation for ‘onePlayerOneMove’:           onePlayerOneMove ga ve ho sp va             | otherwise = set2D ga (getRow sp) (getCol sp) va
23:07:55 <pavonia> Guest86433: It's the same problem as before, you're passing it an Int where it expects a Char
23:08:00 <pikajude> ok, leksah doesn't quit on its own
23:08:12 <EvanR> thats probably GTKs fault
23:08:13 <pikajude> doesn't autodetect my packages sadly
23:08:27 <Guest86433> otherwise = set2D ga (getRow sp) (getCol sp) 'va' 
23:08:43 <Guest86433> so how can I convert va into char?
23:08:57 <EvanR> 'va' is incorrect syntax
23:09:05 <EvanR> 'x' is syntax for Char literals
23:09:11 <EvanR> that is, single chars
23:09:17 <pavonia> :t intToDigit
23:09:17 <Guest86433> ohhhh
23:09:18 <lambdabot> Int -> Char
23:09:58 <Guest86433> otherwise = set2D ga (getRow sp) (getCol sp) (:t intToDigit va) like this
23:10:10 <Axman6> without the :t
23:10:49 <Guest86433> arr i will need to create intToGigit :: Int -> Char then call it right?
23:11:12 <Axman6> no, intToDigit comes from Data.Char
23:11:54 <Guest86433> ohhh lol its working now
23:12:02 <Guest86433> i didnt import Data.Char
23:12:08 <Guest86433> -_-
23:13:15 <Guest86433> thank you so much guys
23:20:16 <Lokathor> http://lpaste.net/342483 welp this is my first iteration on the setup
23:33:13 <ongy> > intToDigit 12
23:33:15 <lambdabot>  'c'
23:33:30 <ongy> > intToDigit 42
23:33:33 <lambdabot>  *Exception: Char.intToDigit: not a digit 42
23:34:06 <roberth> Hello haskellers! I have a two opportunities for you. Software Circus is organising an FP microservice hackathon in Amsterdam, December 9!
23:34:44 <roberth> They are looking for a language and volunteers for coaching related to the language during the event.
23:35:41 <roberth> If you would like to participate, or if you know any good introductory resources into {web/micro}service programming in Haskell, assuming an OOP background, please let me know!
23:36:46 <roberth> Reddit: https://www.reddit.com/r/haskell/comments/5dl7cm/requesting_resources_and_volunteers_for_amsterdam/
23:36:52 <roberth> Meetup.com: https://www.meetup.com/Software-Circus/events/235459993/
23:45:39 <Hafydd> A hackathon for writing microservices in a language you've just learnt and have no background in?
23:48:27 <EvanR> exploitathons
23:50:49 <pikajude> how micro does the service have to be?
23:51:00 <Lokathor> small enough to fit on a 3.5in floppy
23:51:31 <pikajude> can we get integer comparison as a service
23:51:53 <Lokathor> yes, but it's actually an FFI call so it's an IO Bool result
23:52:57 <EvanR> IO (Future (Either Error Bool))
23:53:13 <pikajude> at least it'll be nonblocking?
23:53:23 <EvanR> not guaranteed
23:53:57 <ogkloo> isn't any IO result not guaranteed to be non-blocking?
23:54:17 <EvanR> non IO is not guaranteed to be non-blocking
23:54:30 <pikajude> no, sorry, I meant the Future
23:54:31 <EvanR> like the Future 
23:54:51 <EvanR> force :: Future a -> a
23:59:03 <wespiser> @unmtl MaybeT (State s) a
23:59:03 <lambdabot> s -> (Maybe a, s)
23:59:47 <wespiser> @unmtl  ReaderT EnvCtx (ExceptT LispError IO ) a
23:59:47 <lambdabot> EnvCtx -> ExceptT LispError IO a
