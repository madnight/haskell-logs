00:00:45 <nshepperd> jle`: oh yeah, so it is
00:01:20 <nshepperd> opqdonut: yeah!
00:04:04 <jle`> newtype Apl f a = Apl { runApl :: f a }; instance (Applicative f, Monoid a) => Monoid (Apl f a) where mempty = Apl $ pure mempty; mappend (Apl x) (Apl y) = Apl (liftA2 mappend x y)
00:09:39 <lpaste> jle` pasted “monoid with laws” at http://lpaste.net/339173
00:10:05 <jle`> is there a more "idiomatic" (if such a thing exists) way to implement typeclasses w/ enforced laws in haskell than this?
00:10:44 <jle`> in this example for a Monoid typeclass, it requires both a type family (Mappend) and a value level function (sMappend) to be provided
00:11:09 <jle`> granted, the singletons package can let you write it once and gives you both
00:16:03 <mpickering> I would never recommend anyone does this in Haskell!
00:16:10 <mpickering> So I think you are right to say "idomatic"
00:23:57 <jle`> is there a better way to make a monoid typeclass that allows ghc to enforce that the implementations are lawful at compile-time? :o
00:24:11 <mpickering> Using agda..
00:24:27 <mpickering> I don't think this is something that people should try and do in Haskell. 
00:24:39 <nshepperd> this is a type level monoid, right?
00:24:45 <mpickering> It is too hacky and the support isn't there to prove anything non-trivial
00:25:10 <jle`> it's monoid at both levels
00:25:20 <jle`> well, it's a value-level monoid that is also promoted to the type level
00:25:30 <jle`> they're required to be the same on their respective promoted values
00:27:45 <nshepperd> but the values all have to be singletons?
00:28:32 <jle`> describing a function on singletons also describes a function on the values
00:29:46 <jle`> writing 'add' on Nat singletons is the same as writing 'add' on Nat's
00:30:39 <jle`> add Z y = y; add (S x) y = add (S x y)   ... vs.  sAdd SZ y = y; sAdd (SS x) y = SS (sAdd x y)
00:32:39 <fr33domlover> you don't say
00:33:58 <nshepperd> this hurts my head to think about more than anything
00:34:28 <nshepperd> could you make a Monoid instance like this for HList?
00:34:32 <jle`> in the end you can recover the original value-level function
00:34:44 <jle`> nshepperd: hm, not sure
00:34:55 <jle`> i don't think so, for this one
00:35:00 <jle`> because the two arguments have to be of the same type
00:35:07 <jle`> Nat -> Nat -> Nat
00:35:15 <jle`> appending hlists changes their types
00:39:05 <jle`> made an edit to show the implementations of mempty/mappend explicitly
00:41:27 <MarcelineVQ> what is a singleton? I can't quite tell from your SS example there, a wrapper like newtype?
00:41:43 <jle`> this all can really just be used in the same way as the original Monoid, w/ mappend and mempty
00:41:47 <jle`> except the compiler cheks the laws
00:41:56 <jle`> MarcelineVQ: are you familiar with GADT's? 
00:42:15 <MarcelineVQ> in an introductory fashion, type refinement is new to me
00:42:45 <MarcelineVQ> I've found the paste you wer ejust referring to so I'll have a look at that shortly
00:42:54 <jle`> if you have a data N = Z | S N,  then you can have singletons data Nat :: N -> Type where Z_ :: Nat Z; S_ :: Nat n -> Nat (S n)
00:43:26 <jle`> so if you get a generic value of type 'Nat n', then if you pattern match and get Z_, that means that n ~ Z
00:43:54 <jle`> basically pattern matching on a value of type 'Nat n' gives you access to 'n', at runtime
00:46:06 <MarcelineVQ> thank you jle`
00:46:23 <jle`> it's one way of cheating type erasure
00:47:07 <jle`> it's being used for a different purpose here though
00:48:25 <jle`> i guess here, you implement mempty/mappend on the promoted values, so Mappend N Z y = y; Mappend N (S x) y = S (Mappend N x y), at the type level ... and then you supply the proofs for the laws for those type families
00:49:38 <jle`> and then you provide a function on singletons, sMappend :: Sing x -> Sing y -> Sing (Mappend m x y) ... and the type system enforces that however you manipulate the run-time singletons matches up with how you "promised" mappend would work
00:49:40 <jle`> from the type family
00:50:50 <jle`> sMappend should be implemented identically as the type family instance, and the type system enforces that you implemented it as promised, from the type of sMappend.
00:51:42 <jle`> so i guess the real definition of mempty/mappend happen at the type level, and sMappend/sMempty are just necessary runtime demotions that can be implemented mechanically
00:53:01 <MarcelineVQ> Without gadts would this be something you'd approach with fundeps? They seem related, though I know little about them as well
00:53:32 <jle`> i'm not sure how to go about this with fundeps
01:29:32 <fierce_katie> is there any way to make a string to be parsed by a quasi-quoter in runtime? e.g. there's a function that generates a type signature (funType ["a", "b", "c"] results to "a -> b -> c") and I want smth like [t| <call funType here> |]
01:29:59 <tdammers> quasiquotation runs at compile time
01:30:57 <tdammers> you can of course write a quasiquoter that parses a string and emits TH AST that amounts to any type signature you like
01:33:07 <fierce_katie> that's what I'm up to now, just wanted to know if there's any other obvious and simple way I don't know about
01:33:36 <tdammers> hard to say without more information on the full problem
01:33:44 <athan> why not use a parser combinator that emits function types?
01:50:26 <fierce_katie> That's what I'm actually trying to do: there's a data structure similar to a binary tree, I'm collecting the types along the branches and then I want to use TH to generate function declarations of those types:
01:50:26 <fierce_katie> data a <|> b =  (<|>) a b
01:50:26 <fierce_katie> data a > b = (>) a b
01:50:26 <fierce_katie> type T = (Int > Int > Char) <|> (String > String)
01:50:26 <fierce_katie> The result I want after running $(magic (Proxy :: Proxy T)) is:
01:50:26 <fierce_katie> f :: Int -> Int - >Char
01:50:27 <fierce_katie> g :: String -> String
01:51:05 <fierce_katie> (ignore function names, they are not the problem now)
01:52:09 <lyxia> why does that have to happen at runtime
01:54:18 <fierce_katie> It does not, I misused "runtime" for the time when the quasi-quoter is run, which is certainly compile time of the program itself, sorry for that mess :)
01:57:08 <lyxia> what should those functions do
02:00:00 <lyxia> This is too confusing.
02:04:46 <fierce_katie> anyway, the main question is, are there any existing parsers that make TH ASTs (especially for type signatures)?
02:12:51 <amx> there is no equivalent for Show with Data.Text?
02:15:03 <jle`> amx: do you mean (T.pack . show) ?
02:18:26 <amx> ok I suppose it doesn't make too much sense since Text is not part of the standard, disregard that question
02:22:07 <fr33domlover> amx, iirc there is, maybe even more than one
02:22:08 <mpickering> There is a text-show package amx 
02:22:14 <fr33domlover> yeah that :P
02:22:33 <fr33domlover> there is also the formatting package
02:22:51 <fr33domlover> (which works with lazy Text internally iirc)
02:26:22 <amx> thx
02:28:32 * hackagebot genifunctors 0.4 - Generate generalized fmap, foldMap and traverse  https://hackage.haskell.org/package/genifunctors-0.4 (DanRosen)
02:44:57 <jle`> hey
02:45:07 <jle`> with TypeInType, a lot of silly types are now valid
02:45:17 <jle`> x :: Bool, x :: Nat ...
02:45:32 <jle`> er wait
02:45:47 <jle`>  yeah, x :: Nat, x :: Type
02:46:01 <jle`> @let huh :: *; huh = undefined
02:46:02 <lambdabot>  Parse failed: Parse error: *
02:46:42 <jle`> i guess Nat is not that weird, the only thing kinda weird is x :: Type, nvm.
02:50:42 <athan> jle`: :)
02:51:05 <athan> I haven't messed with it yet, I'm excited to though. So you can create terms which look like types?
02:51:38 <athan> and now undefined is `undefined :: forall (a :: forall k. k). a`?
02:51:56 <athan> (and up?)
02:58:24 <nevere> Is it possible to wrap a record in a Writer monad and create lenses that writes to the Writer, instead of setting the record fields directly?
02:58:33 * hackagebot foundation 0.0.2 - Alternative prelude with batteries and no dependencies  https://hackage.haskell.org/package/foundation-0.0.2 (VincentHanquez)
03:05:32 <athan> nevere: well setting record fields could also be stateful
03:05:47 <athan> but you can also $(makeLenses) or something iirc
03:06:46 <athan> I've seen a lot of stateful cool lensy stuff from edwardk too, Zooming or something
03:07:07 <nevere> athan: Can you please point me somewhere ?
03:11:20 <athan> nevere: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Zoom.html
03:11:28 <athan> don't ask for my interpretation though :v
03:11:46 * athan doesn't have a typechecker module in his brain compartment yet
03:19:43 <nevere> athan: Did you send something. I just got disconnected a bit.
03:27:55 <hppavilion[1]> Would there happen to be an alternative nick lambdabot is usually run under? Specifically, is there any instance possibly running on Foonetic under a different nick?
03:28:34 * hackagebot http-link-header 1.0.3 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  https://hackage.haskell.org/package/http-link-header-1.0.3 (myfreeweb)
03:29:59 <MarcelineVQ> possibly. anyone at all can run one
03:30:34 <byorgey> nevere: athan sent https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Zoom.html
03:30:58 <nevere> byorgey: Thankyou!
03:31:25 <lyxia> nevere: This combinator seems quite relevant http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Setter.html#v:.-61-
03:33:15 <hppavilion[1]> MarcelineVQ: Yes, I figured
03:33:36 <hppavilion[1]> WOW this channel is high-level
03:33:41 <nevere> lyxia: Yes. it does..Thank you.
03:33:46 <athan> nevere: oh yes, sorry
03:33:55 <athan> https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Zoom.html
03:34:02 <athan> @tell nevere https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Zoom.html :D
03:34:03 <lambdabot> Consider it noted.
03:34:49 <nevere> athan: Hey... What cool trick is that?
03:35:44 <athan> lambdabizzot dawg!
03:35:52 <athan> it's awesome on too many levels to measure
03:36:03 <nevere> athan: Yes.  lol :)
03:38:19 <athan> @djinn a -> b -> (b -> a -> b)
03:38:20 <lambdabot> f _ _ a _ = a
03:38:39 <athan> @djinn a -> b -> (b -> a -> b) -> (b -> a)
03:38:39 <lambdabot> f a _ _ _ = a
03:38:43 <athan> :v
03:39:34 <ongy> @pl \x y f -> flip f y
03:39:34 <lambdabot> const (flip flip)
03:39:46 <ongy> :t flip flip
03:39:48 <lambdabot> b -> (a -> b -> c) -> a -> c
03:41:32 <athan> @quote ongy
03:41:32 <lambdabot> No quotes match. :(
03:41:36 <athan> dawww
03:41:38 <athan> @quote
03:41:39 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
03:41:45 <athan> rofl
03:42:07 <ongy> why would you want to quote me?
03:42:16 <tabaqui1> :t sendAll
03:42:18 <lambdabot> error: Variable not in scope: sendAll
03:42:48 <athan> sorry, just wanted to see if you had any :x
03:53:26 <__monty__> Is this a good explanation of how haskell is still pure even though it allows i/o or is it misleading? https://wiki.haskell.org/IO_inside
03:53:35 * hackagebot gssapi 0.1.0.0 - libgssapi and libkrb5 bindings for haskell  https://hackage.haskell.org/package/gssapi-0.1.0.0 (ondrap)
03:55:30 <athan> __monty__: It's somewhat misleading. IO is actually not necesarilly like this (I'm not an expert on the underpinnings), but it's a nice article for explaining how evaluation order shouldn't matter
03:56:00 <athan> Simulating an IO monad would work like that, though (iirc)
03:59:52 <ertes> __monty__: i think the article does not match modern quality standards of explaining IO
04:00:07 <ertes> __monty__: try this one instead: https://www.vex.net/~trebla/haskell/IO.xhtml
04:01:51 <ertes> __monty__: and follow this general rule:  if you are a user, try not to reduce "IO a" to something else…  leave it abstract: it's the type of I/O actions that produce values of type 'a' on execution
04:08:18 <__monty__> ertes: This seems like a good explanation of how to use IO in haskell, an expanded version of the introduction to IO on the wiki if you will but I'm actually looking for more abstract information. Why IO doesn't undermine haskell's purity to be precise.
04:16:14 <ertes> __monty__: yeah, see the link i gave you
04:17:24 <ertes> the more abstract way to understand IO would be to understand monads as an abstraction for computation, but i generally recommend not to understand IO as a *monad* at first, but just as a type for composable I/O actions
04:18:09 <__monty__> ertes: I was talking about the link you gave me.
04:19:10 <__monty__> I understand monads enough to understand that the fact that IO is a monad doesn't solve the purity issue.
04:19:24 <ertes> __monty__: if you understand (IO A) as the type of I/O actions that produce A, together with the composition operation (>>=) that constructs larger I/O actions from smaller ones, the purity of IO should be self-evident, don't you think?
04:19:46 <ertes> note that you can't actually *run* IO actions from within haskell
04:21:17 <ertes> that's why the entry point into any haskell program that is supposed to do something has to be an IO action (main): your program *is* an IO action
04:21:50 <ertes> think of "running" as an outside interpreter reading your program and executing its steps
04:26:05 <__monty__> That's the thing I'm trying to understand, why does saying "Morally haskell doesn't perform IO but the RTS does." make referential transparency happen? You can't optimise away calls to random for example so how can it be a pure function?
04:26:44 <mauke> :t random
04:26:46 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
04:27:01 <mauke> takes a RNG state, returns a value and a new RNG state
04:27:08 <mauke> perfectly pure
04:27:28 <__monty__> Yeah, bad example but I think you know what I mean.
04:27:35 <mauke> I don't
04:28:36 * hackagebot gssapi-wai 0.1.0.0 - WAI Middleware for SPNEGO authentiaction  https://hackage.haskell.org/package/gssapi-wai-0.1.0.0 (ondrap)
04:28:40 <mniip> surely you mean
04:28:43 <mniip> :t randomIO
04:28:44 <MarcelineVQ> Hopefully this isn't far off: a random number generator, say IO Int, will give you a different random Int when executed but the instruction "give me a random number" is pure
04:28:45 <lambdabot> Random a => IO a
04:28:50 <mniip> it's not a function
04:28:57 <mniip> it's an io action
04:29:11 <mniip> an instruction to the RTS to generate a random value
04:31:17 <ertes> (i'd keep the RTS out of it)
04:31:59 <ertes> __monty__: do you accept that (getLine :: IO String) is an IO action, and not a string?
04:32:03 <__monty__> Let me try to describe better what I don't understand. Why is the haskell program that I'd write to generate a random value and print it any more pure than an ML program that does the same?
04:32:31 <bartavelle> to me it's basically semantics, I don't find it helpful to reason about my program when in IO land
04:32:34 <__monty__> I realize that purity probably doesn't make sense at the level of programs.
04:32:36 <mniip> referential transparency is, by definition, ability to substitute a name with its definition
04:32:47 <ertes> __monty__: you are conflating two incompatible notions here: the *language* haskell is pure
04:32:55 <ertes> the programs it compiles to is obviously not
04:33:14 <mniip> let x = random in (x, x)
04:33:18 <fr33domlover> __monty__, is Haskell impure code is marked as such
04:33:22 <fr33domlover> *in
04:33:24 <mniip> in ML that's different from (random, random)
04:33:35 <mniip> i.e referentially intransparent
04:33:49 <mauke> impure Haskell code is marked by not existing
04:34:03 <ertes> =)
04:34:14 <fr33domlover> mauke, I mean there's a separation between I/O and pure functions :P
04:34:20 <fr33domlover> using the type system
04:34:24 <mniip> mauke, err
04:34:33 <mniip> I wouldn't say that
04:34:38 <ertes> fr33domlover: there is a separation, but it's actually not in the types
04:34:48 <bartavelle> but that could be done in other MLs, it's "just" that they should rewrite their libraries
04:34:58 <bartavelle> and that they don't have do notation
04:35:19 <ertes> fr33domlover: as long as you are typing haskell code (and not use any of the unsafe stuff that doesn't exist), you are in pure land, *even with* IO
04:35:22 <bartavelle> which would make it cumbersome
04:36:01 <ertes> the transition from pure to impure happens outside of code
04:36:46 <ski> ertes : it'd regard "the programs it compiles to is obviously not [pure]" as meaningless ..
04:37:11 <fr33domlover> ertes, agreed. i just mean there's separation between things that interact with the system (like IO actions) and things that don't
04:37:12 <ski> __monty__ : ".. doesn't make sense at the level of programs" -- well, that's exactly where it *makes* sense
04:37:14 <ertes> ski: "it"?
04:37:32 <fr33domlover> but yeah, when you write a program you just build one big IO action...
04:37:45 <fr33domlover> and it interacts with the system behind the scenes
04:38:09 <ski> ertes : it's a property of the language you're using and reasoning in
04:38:46 <ertes> ski: "it'd"?  i suppose you mean "i'd"
04:39:58 <ski> sorry, yes
04:40:18 <__monty__> ski: Do you mean it makes sense to say of a program, let's say firefox, whether it's pure or not?
04:40:47 <bartavelle> __monty__, RMS would probably think so :)
04:40:52 <ski> __monty__ : not without referring to the language it's written it
04:41:15 <ertes> ski: yeah, the problem is that we (again) conflate notions here: there is the "purity" of the langugage haskell (which may or may not line up with "referential transparency" from linguistics – i don't know), and then there is the rather questionable concept of "program purity"
04:41:38 * ski isn't sure what "program purity" would mean
04:41:43 <ertes> exactly
04:41:52 <e> is it even questionable?
04:41:55 <__monty__> ski: That was what I was getting at, purity applies to functions but not programs.
04:42:20 <ertes> __monty__: the "purity" of haskell refers to the language
04:42:29 <mniip> purity applies to definitions
04:42:31 <e> which does beg the question: why did you ask your question in terms of the purity of programs
04:42:33 <bartavelle> "program purity" sounds like something *insert open source license* zealots say
04:42:42 <ski> __monty__ : well, i was assuming by "program" you meant "a collection of source code files that fit together" .. but it appears i was wrong (?)
04:43:56 <e> ski: can a collection of source code files be pure?
04:43:57 <ertes> __monty__: purity establishes a few basic language properties that let you do equational reasoning
04:44:12 <ertes> example: (let x = y in f x x) is semantically equal to (f y y)
04:44:25 <ski> e : in case the constructions made in them are ?
04:45:03 <e> ski: but in a language like haskell that'd be all of them
04:45:09 * ski emphatically agrees with ertes
04:45:15 <ski> e : sure
04:45:28 <mniip> well
04:45:34 <mniip> except it's not
04:45:53 <mniip> only if you forget about unsafe stuff that doesn't exist
04:46:05 <e> yes, we're forgetting about unsafe stuff that doesn't exist
04:46:32 <ski> (or treating them as coming with proof obligations that are assumed to be met by the programmer)
04:49:01 <ertes> (which are hard to meet, because unsafe stuff is weird to reason about)
04:57:45 <bbear> Heyhttp://pastie.org/10962062
04:57:49 <bbear> Hey http://pastie.org/10962062
04:58:00 <bbear> I want to create a binary tree API but I am stuck
04:58:19 <bbear> It seems I don't quite understand how to work with algebraic data types
04:58:30 <bbear> could you debug me (I think the purpose here is clear)
04:58:38 * hackagebot modbus-tcp 0.3 - Communicate with Modbus devices over TCP  https://hackage.haskell.org/package/modbus-tcp-0.3 (RoelVanDijk)
04:58:51 <mauke> what's the problem?
04:58:51 <bbear> especially the function getNode, I don't know how it should be written
04:59:16 <bbear> I have "parse error in pattern x"
04:59:22 <bbear> 5:10
04:59:34 <ertes> bbear: you have defined exactly one type in your code: BTree
04:59:39 <ertes> Node is not a type
04:59:46 <mauke> getNode (Node x _ _) = x
04:59:46 <bbear> Ok
04:59:59 <mauke> but wait, that's a type error
05:00:04 <bbear> but it seems to be implicitely defined
05:00:10 <ertes> bbear: nope
05:00:15 <bbear> I need to define it ?
05:00:19 <ertes> bbear: nope
05:00:32 <ertes> bbear: what is getNode supposed to return?
05:00:37 <bbear> the content of a Node
05:00:45 <ertes> which node?  it receives a tree
05:00:47 <bbear> Node could be any type
05:01:11 <bbear> So I need to define Node
05:01:20 <ertes> bbear: example: getNode Empty = ?
05:01:37 <ertes> bbear: don't jump to conclusions
05:01:45 <bbear> So I actually need to better define my nodes
05:02:04 <bbear> getNode Empty should be "Nothing"
05:02:17 <ertes> bbear: ah, now we're getting somewhere
05:02:20 <bbear> "Nothingness" , "empty set", whatever
05:02:39 <ertes> bbear: what if the argument is not Empty, but of the form (Node x ls rs)?
05:02:49 <bbear> Then it should return x
05:02:58 <ertes> bbear: are you familiar with Maybe?
05:03:02 <bbear> no
05:03:06 <bbear> but I intend to be
05:03:17 <ertes> ok, this is the definition:  data Maybe a = Nothing | Just a
05:03:20 <ertes> it's predefined
05:03:28 <ertes> example values:
05:03:32 <ertes> Nothing :: Maybe Int
05:03:33 <ertes> Nothing :: Maybe Bool
05:03:38 <ertes> Just 3 :: Maybe Int
05:03:42 <ertes> Just True :: Maybe Bool
05:04:02 <ertes> bbear: given this information, what do you think the type of getNode should be?
05:04:19 <bbear> getNode should be type of a
05:04:30 <mauke> definitely no
05:04:32 <mauke> that's not even a function
05:04:33 <ertes> nope, getNode is still a function, so it has a (->) somewhere
05:04:53 <bbear> getNode :: BTree b -> Node a
05:05:05 <ertes> bbear: Node is not a type
05:05:18 <bbear> I don't quite understand what is Node in my example
05:05:39 <ertes> bbear: listen: "getNode takes a tree and returns the value of the root node, if any"
05:06:01 <ertes> bbear: getNode :: BTree a -> _something
05:06:22 <mauke> bbear: Node is a constructor
05:06:23 <ertes> normally that _something would be 'a', but that's not possible, because there may be no value of type 'a' (the Empty case)
05:06:26 <mauke> a data constructor
05:06:35 <__monty__> bbear: Node is a type constructor it takes three values and returns a value of type BTree a
05:06:42 <mauke> __monty__: no
05:06:48 <ertes> __monty__: Node is not a *type* constructor
05:07:20 <__monty__> Excuse me.
05:07:21 <ertes> bbear: let's say that you write an integer square root function with the following characteristics:
05:07:30 <ertes> isqrt 0 = Just 0
05:07:35 <ertes> isqrt 1 = Just 1
05:07:40 <ertes> isqrt 2 = Nothing
05:07:41 <ertes> …
05:07:44 <ertes> isqrt 4 = Just 2
05:08:00 <ertes> bbear: its type would be:  isqrt :: Integer -> Maybe Integer
05:08:31 <ertes> its result is not an Integer, because there may be no such integer
05:08:59 <ertes> bbear: did that make sense?
05:15:56 <pavonia> Is there a flipped version of (<$) somewhere in base?
05:16:14 <pavonia> Or "near" base
05:16:29 <mauke> :t (<$)
05:17:12 <pavonia> It's \x y -> y >> return x
05:17:37 <liste> though for Functor
05:17:49 <pavonia> Right
05:17:50 <liste> (<$) :: Functor f => a -> f b -> f a
05:17:58 <bartavelle> it's fmap (const x) y
05:17:59 <ertes> pavonia: (<$) x = fmap (const x)
05:18:12 <gaqwas> hallo pavonia :)
05:18:26 <pavonia> O hai :)
05:19:14 <mauke> Data.Functor.$>
05:21:00 <pavonia> Oh, there's Data.Functor
05:21:06 <pavonia> Thanks
05:23:53 <bbear> sorry I got a fone call
05:24:33 <bbear> ertes
05:24:38 <bbear> yeah I got the idea
05:24:49 <bbear> still fuzzy in how to use it
05:25:05 <bbear> I need to go to the doctor
05:26:52 <ertes> bbear: now you need to apply the same logic to getNode
05:27:09 <ertes> s/now/once you're back from the doctor/ =)
05:31:23 <__monty__> ertes, mauke, ski, mniip: Thanks btw, I understand IO better now.
05:31:43 <tabaqui1> I have "data Foo = Foo Int | Bar Int"
05:32:13 <tabaqui1> and I want to extract Int, but don't want to write
05:32:24 <tabaqui1> func (Foo a) = a; func (Bar a) = a
05:32:35 <ski> should work
05:32:36 <tabaqui1> because there are more data constructors
05:32:44 <tabaqui1> can I write something simplier?>
05:32:51 <ski> oh, then you need to say what to do in case you get any of them
05:32:53 <mniip> data Foo = Foo { func :: Int } | Bar { func :: Int }
05:33:21 <tabaqui1> hmm
05:33:39 <ski> perhaps you should aim for `func :: Foo -> Maybe Int' ?
05:33:40 <tabaqui1> mniip: and if I want func2 :: Foo -> Bool
05:33:51 <tabaqui1> ah yeah
05:33:56 <tabaqui1> ok, that's enough
05:33:58 <tabaqui1> thank you
05:34:04 * ski sees no `Bool' mentioned previously
05:34:14 <tabaqui1> :t Bool
05:34:15 <lambdabot> error:
05:34:15 <lambdabot>     • Data constructor not in scope: Bool
05:34:15 <lambdabot>     • Perhaps you meant variable ‘bool’ (imported from Data.Bool)
05:34:20 <tabaqui1> :i Bool
05:34:34 <ski> (there is no `:i', nor `@info', in lambdabot)
05:34:39 <tabaqui1> ski: data Bool = False | True
05:34:54 <tabaqui1> anyway
05:35:00 <tabaqui1> *afk
05:35:01 <ski> i know, but you didn't mention it, e.g. in your data declaration, or elsewhere in your problem description
05:37:03 <ertes> tabaqui1: if the field of every constructor is of the same type, consider abstracting over that type:  data Foo a = Foo a | Bar a
05:37:21 <ertes> tabaqui1: then you can derive Functor, Foldable and Traversable, which may be handy
05:37:21 <ski> (or perhaps factor)
05:37:36 <ertes> yeah, or factor:  data Foo = Foo | Bar
05:37:42 <ertes> (Foo, Int)
05:37:57 <tabaqui1> what is a factor?
05:38:22 <ertes> tabaqui1: a factor in this case is one of the tuple components
05:38:55 <tabaqui1> ah, mm, doesn't look pretty, imo
05:40:03 <__monty__> There's no programming pageant you know.
05:40:24 <ski> tabaqui1 : factoring is e.g. going from `Int * String + Int * Bool * [Double]' to `Int * (String + Bool * [Double])'. concretely, it might look like going from `data T = A Int String | B Int Bool [Double]' to `data T = MkT Int AB' together with `data AB = A String | B Bool [Double]'
05:40:39 <ertes> tabaqui1: you should read "data types a la carte" at some point…  you will find tuples a lot prettier after that =)
05:40:45 <byorgey> __monty__: no, but code beauty correlates very well with readability, maintainability, flexibility...
05:41:09 <tabaqui1> __monty__: what are we doing here in that case?
05:41:39 <tabaqui1> ertes: I'll take a look
05:42:04 <__monty__> byorgey: That's a can of worms I don't want to touch. Saying tuples are ugly is not a good reason for avoiding their use when they seem more appropriate.
05:42:36 <ertes> tabaqui1: the essence of the paper is that types form a semiring with Either and (,) with respect to isomorphism
05:42:48 <bartavelle> __monty__, that's like saying you shouldn't use newtypes ? In those cases I write my specific tuple like data type
05:43:00 <ertes> Foo = Int + Int
05:43:12 <ertes> Foo ≃ 2 * Int ≃ (2, Int)
05:43:22 <ertes> 2 is any type with two inhabitants (disregarding bottom)
05:44:04 <mniip> Int ≃ (2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)
05:44:26 <ertes> Int ≃ 2^32 ≃ 32 -> 2
05:44:54 <ertes> in turn: 32 ≃ 2^5 ≃ 5 -> 2
05:45:02 <ertes> so 2^32 ≃ (5 -> 2) -> 2
05:45:03 <__monty__> bartavelle: I don't know what koolaid you're drinking but I said you should use tuples when appropriate. There are exactly zero judgements on whether you should use newtypes in that statement.
05:45:17 <mniip> ((2 -> 2) -> 2) -> 2 -> 2
05:45:43 <bartavelle> __monty__, I though that was an advice for the use case that was given by tabaqui1, I didn't realize it was a general observation
05:45:50 <ski> @djinn ((Bool -> Bool) -> Bool) -> Bool -> Bool
05:45:50 <lambdabot> f _ a = a
05:45:50 <mniip> no wait
05:46:01 <mniip> ((1 + (2 -> 2)) -> 2) -> 2
05:46:03 <mniip> that sounds bettere
05:46:30 <ski> @djinn (Maybe (Bool -> Bool) -> Bool) -> Bool
05:46:30 <lambdabot> f a = a Nothing
05:46:53 <bartavelle> __monty__, re-reading your sentence, it's pretty obvious I drew false conclusions
05:47:07 <mniip> let's build the isomorphism using the order in which djinn generates the 2^32 different functions
05:47:16 <ertes> or: (Maybe (Bool, Bool) -> Bool) -> Bool
05:48:04 <Adeon> @djinn (Maybe (Bool -> (Bool -> Bool) -> Bool) -> Bool) -> Bool
05:48:04 <lambdabot> f a = a Nothing
05:54:55 <Profpatsch> @djinn MonadPlus m => (a -> Bool) -> a -> m a
05:54:55 <lambdabot> Error: Class not found: MonadPlus
05:56:04 <hexagoxel> :exf "MonadPlus m => (a -> Bool) -> a -> m a"
05:56:05 <exferenceBot> \ f1 -> mfilter f1 . pure
05:57:03 <Morgawr> Hello, I have an IO function that I need to stall for a few seconds, I wanted to use threadDelay 60 to stall it for (at least) a minute
05:57:19 <hexagoxel> 60000000
05:57:28 <byorgey> Morgawr: threadDelay takes an argument measured in microseconds
05:57:32 <Morgawr> Oh wait
05:57:34 <Morgawr> it's microseconds
05:57:37 <Morgawr> derp
05:57:46 <Morgawr> I swear I read seconds
05:57:55 * Morgawr headdesks 
05:58:04 <byorgey> =)
05:58:05 <Morgawr> I've been on this for the past ~1 hour trying to figure out why it wasn't working... thanks
05:59:01 <ertes> seconds would be a bit coarse
06:00:23 <Morgawr> ertes: Yeah, which is why I was thinking "it's weird it takes seconds..." but I swear to god I read "seconds" the first time I skimmed through the doc
06:00:26 <macalimlim> is there a web api to get the latest stackage lts version?
06:00:29 <Morgawr> Should've done a double check
06:01:14 <ggVGc> if you need good time accuracy though, I usuaally put a threadDelay 1, and use a time counter to trigger when X has elapser
06:01:17 <ggVGc> elapsed*
06:01:23 <ggVGc> not sure that's relevant for you
06:01:28 <ggVGc> not sure if there's an even better way
06:01:34 <MarcelineVQ> macalimlim: idk about wep api, https://www.stackage.org/lts points to the latest lts though
06:01:43 <ggVGc> I'm using that for midi sequencer output and it's stable enough
06:01:55 <ggVGc> but just threadDelay would never work
06:02:51 <MarcelineVQ> macalimlim: so you could check that link then check for a redirect and you'd have the latest lts version as the end of your url
06:03:41 <macalimlim> ok thanks :)
06:04:18 <MarcelineVQ> I'm sure there's much better ways to do that though  so it might be worth asking about later on today when more people are awake
06:05:24 <Morgawr> ggVGc: Interesting, ty. I just needed to block/stall a process while performing some debugging diagnosis, no biggie :) 
06:07:22 <ggVGc> Morgawr: yeah, then it doesn't matter. But, if you wanted something exactly 10 times a second, using threadDelay 100000 won't be very stable
06:07:46 <ggVGc> it might trigger on average 10 times a second, but the spacing between those triggers won't be good
06:08:40 * hackagebot heterocephalus 0.1.0.0 - A flexible and type safe template engine for Haskell.  https://hackage.haskell.org/package/heterocephalus-0.1.0.0 (arowM)
06:08:41 <b_jonas> Hi all. I'd like to ask something about the type system.
06:08:46 <ggVGc> then ask
06:09:15 <ggVGc> know that the answer has a 96% chance of leading you down a type theory rabbit hole
06:09:33 <Morgawr> The best type of rabbit hole
06:09:56 * hodapp smacks Morgawr
06:10:09 <ggVGc> is the kind of a type theory rabbit hole * -> *
06:11:15 <b_jonas> There's three hypothetical classes, and for each of them, I'd like to ask whether the haskell type system (with some usual set of ghc extensions considered safe these days) allows that class to exists, and also whether there's a name for the property of the type system that this class doesn't exist.
06:11:51 <ggVGc> b_jonas: when you say "class", what do you mean?
06:11:57 <ggVGc> when we hear class, we think type classes
06:12:13 <b_jonas> ggVGc: yes, I mean a Haskell type class, introduced in Haskell with the class keyword
06:12:18 <ggVGc> god
06:12:20 <ggVGc> good*
06:12:29 <LordBrain> god would be the swedish spelling
06:12:36 <ggVGc> no, that would be "bra"
06:12:43 * ski . o O ( "god afton" )
06:12:49 <ggVGc> okay
06:12:51 <ggVGc> fair
06:13:02 <LordBrain> they're both swedish
06:13:12 <LordBrain> if there's a difference i don't know, ask a swede
06:13:16 <ggVGc> <-- swede
06:13:35 <ggVGc> anyway, that's fairly non-haskell related
06:13:37 * ski . o O ( #haskell.se #haskell.scandinavian )
06:13:41 <ggVGc> I'm curious what b_jonas wants to know
06:14:01 <LordBrain> so you spelt it 'god' but that had nothing to do with your native language interesting
06:14:07 <b_jonas> class W0 a where { t : a -> Bool; }; such that W0 a for every type a, and if a is the () type then t _ = true; but for any other type t _ = false;
06:14:44 <bbear> few
06:14:45 <ggVGc> SCHAAP137: nice! I've actually been wondering the past weeks if there was any active scandinavian online community I could join. There's a meetup group here in gothenburg for functional programming but they don't seem that active
06:14:49 <ggVGc> eh, sorry
06:14:51 <bbear> came back
06:14:53 <ggVGc> ski: that was for you ^
06:15:04 <bbear> it was a real hassle to do 100 meters in my square
06:15:11 <ski> b_jonas : with `OverlappingInstances', i think, but that's considered questionable
06:15:11 <opqdonut> b_jonas: that's possible at least with OverlappingInstances
06:15:26 <LordBrain> i wish i was scandinavian
06:15:40 * ski <- in gbg
06:15:45 <b_jonas> class W1 a where { t : a -> (); }; such that W0 a for every type a, and if a is not the () type then t _ = (); but if a is the () type t _ must diverge. (W1 can be implemented from W0 easily.)
06:16:29 * ski gotta go ..
06:16:40 <bartavelle> "for every type" meaning all Haskell types, or those where you write the class instance ?
06:16:41 <b_jonas> class W2 a where {}; such that W2 a for every type a other than (), but not W2 ().  
06:16:46 <ggVGc> LordBrain: I'm just very bad at hitting keys. the "god" in "god afton" is the "good" in "good evening", but it wouldn't be used to say "that thing is good", not in modern swedish anyway. In that case we would say "gott", meaning "that's good and well", but that's also old fasioned, and something my grandfather used to say
06:16:57 <b_jonas> bartavelle: for every haskell type of the * kind
06:16:59 <ggVGc> that's all for that topic from me though
06:17:56 <opqdonut> b_jonas: I don't know of a way to make W2 work, but all sorts of weird stuff is possible with type families...
06:18:02 <b_jonas> (W0 can be implemented from W0 so the numbering is messed up.)
06:18:11 <b_jonas> um
06:18:22 <b_jonas> W0 cna be implemented from W2 so the numbering is messed up.
06:19:39 <b_jonas> opqdonut: basically, if W0 shouldn't exist, then W2 shouldn't exist either, becuase you could write class W0 a where { t :: a -> Bool; }; instance (W2 a) => W0 a where { t _ = false; }; instance W0 Bool where { t _ = true; };
06:20:07 <opqdonut> yeah
06:20:13 <ggVGc> so, that W0 is like function overloading at the type level, eh?
06:20:18 <ggVGc> I've been wondering similar things myself
06:20:24 <ggVGc> unless I misundestand
06:20:41 <LordBrain> we have W0 with overlapping instances, but so far, if there is a way to do W2, we nobody's figured it
06:21:33 <b_jonas> LordBrain: I'm not really just asking if it's possible to define now, but whether it's something that shouldn't exist in the sense that if you tried to add it to the compiler than it caused all sorts of troubling consequences and break apart the type system
06:21:44 <ggVGc> so, how would it be done with overlapping instances? Wouldn't you still need to definen instance for every other type except ()?
06:21:48 <b_jonas> and also what the name for these are so it's possible to search
06:21:59 <LordBrain> well, i'd avoid it yeah
06:22:33 <opqdonut> hmm, so if you can define the type-level function "f a = ()", "f Bool = Bool", then you could define something like "instance (f a ~ ()) => W2 a"
06:24:05 <opqdonut> but I don't think that function is possible, since
06:24:06 <opqdonut> > The instance declarations of a type family used in a single program may only overlap if the right-hand sides of the overlapping instances coincide for the overlapping types.
06:24:08 <b_jonas> opqdonut: yes, that type family f looks like it has roughly the same power as W2, provided you allow fundeps and type families
06:24:09 <lambdabot>  <hint>:1:5: error: parse error on input ‘instance’
06:24:19 <opqdonut> oh heh > is a bad quote char here
06:24:44 <ggVGc> \> (escape the quote char!)
06:24:46 <b_jonas> opqdonut: but the function shouldn't actually have an arm like f a = ()
06:24:57 <opqdonut> b_jonas: yeah
06:25:35 <b_jonas> it's more like that for any type constructor T that isn't (), there should be an arm like f (T x0 ... xk) = ()
06:26:07 <opqdonut> no f :: * -> *, it's a type family
06:26:20 <opqdonut> or that's what I had in mind
06:26:27 <b_jonas> yeah, something... I don't know how type family syntax works
06:26:34 <jchia_3> I'm using stack lts-7.9 and looking for a way to import the layout of C++ structs from C++ header files so that my Haskell program can read the structs from a file. c2hs doesn't understand "#pragma pack", so I thought I could use clang. However, clang-pure doesn't seem to expose the offset of some field in a struct and LibClang has old dependencies that are incompatible with lts-7.9. Any ideas what else I could do?
06:26:36 <b_jonas> let me try with that class notation instead
06:26:51 <bbear> http://lpaste.net/339287 so what's wrong with my code
06:27:02 <ggVGc> b_jonas: have you been in a situation where you needed W2? or is it just speculation/curiosity?
06:27:23 <b_jonas> there's an instance W2 (T x0 ... xk) where {}; for every type constructor T other than ()
06:27:32 <ggVGc> from my limited knowledge, it seems like most actual use cases of this type would be solved by type families?
06:28:16 <b_jonas> ggVGc: no, I don't need that class. I think it might not exist in Haskell. But I'd like to be able to talk about the property of the type system that it doesn't exist, and ask whether that property is true in some other type system.
06:28:22 <b_jonas> I'd like googlable terms.
06:30:54 <lpaste> hexagoxel pasted “W2” at http://lpaste.net/339288
06:31:09 <hexagoxel> b_jonas: ^
06:32:45 <hexagoxel> opqdonut had the same idea already, i see..
06:34:07 <b_jonas> hexagoxel: hmm. but isn't it supposed to be possible to desugar any type family syntax to class (with fundep) syntax?
06:34:46 <b_jonas> or is that true only backwards?
06:36:43 <ertes> ggVGc: (threadDelay 1) is most likely pretty much just 'yield'
06:37:29 <ertes> ggVGc: if you need good accuracy, consider using my timelike library…  it has a high-precision waiting function that doesn't waste your CPU cycles for most of the wait
06:37:40 <ggVGc> cool
06:37:42 <ggVGc> I'll check that
06:37:59 <ertes> ggVGc: https://hackage.haskell.org/package/timelike-0.2.2/docs/Data-Time-Class.html#g:5
06:38:18 <ggVGc> ertes: I figured there was a better way. And yes, I am using threaddDelay 100 currently to essentially be yield, because I need good timing
06:38:35 <ggVGc> ertes: are you using the FFI for this?
06:39:08 <tabaqui1> did anyone here work with Yampa?
06:39:33 <tabaqui1> I have a question about somewhat
06:39:38 <ertes> ggVGc: no…  say you want to wait until 3:00:00, and it's 2:59:50
06:40:04 <hexagoxel> b_jonas: fundeps have some overlapping in expressiveness with associated types, but afair there are cases for each not expressible in the other.  think there is no subsuming in either direction. and type families (esp. closed ones like here) are even a step further. (but i am no expert, what i say might be rather imprecise.)
06:40:20 <ertes> ggVGc: if you say (delayUntil 3 t), it will wait 3 seconds three times, then 1 second
06:40:34 <ertes> ggVGc: if you say (busyDelayUntil 0.1 3 t), it will wait the last 0.1 seconds using busy-waiting
06:40:37 <b_jonas> hexagoxel: ok
06:40:50 <bbear> http://pastie.org/10962114 hello I'm back
06:40:53 <bbear> I advanced a little
06:40:53 <ertes> ggVGc: i.e. a busy loop
06:40:55 <ggVGc> ertes: yeah, I just read the comments. That sounds good
06:40:58 <ggVGc> Iäll give it a go
06:41:04 <ggVGc> cheers :)
06:41:07 <bbear> but it seems to be full of errors still.
06:41:13 <ertes> you're welcome =)
06:41:26 <b_jonas> This means in haskell all three of these are definable, using type families, and maybe I should search for "closed type families"
06:41:34 <ertes> tabaqui1: i've worked with yampa a few years ago
06:41:51 <bbear> http://lpaste.net/339290
06:42:09 <tabaqui1> ertes: well, maybe you could remember
06:42:25 <bbear> • Data constructor not in scope: Maybe :: a -> Maybe a
06:42:37 <tabaqui1> I have a long computation, and want to do such thing:
06:42:41 <ggVGc> ertes: hm, is multiple threadDelay really more accurate than a single longer one?
06:42:52 <ggVGc> I never looked into it, but I assumed the opposite
06:43:01 <tabaqui1> one SF inside the chain send it's output
06:43:12 <ertes> ggVGc: it's not more accurate, but it accounts for changes in system time
06:43:22 <tabaqui1> and then send another, without waiting for an input
06:43:38 <ggVGc> ah, yeah, I get it
06:43:54 <tabaqui1> can I implement this or have to send List?
06:44:00 <ertes> ggVGc: actually i wouldn'tbe surprised if it actually was more accurate, too
06:44:09 <ggVGc> ertes: I might just steal your busyDelayUntil..
06:45:05 <ertes> ggVGc: sure, i have granted you an apache v2 license =)
06:45:17 <ertes> (though future releases will be BSD3)
06:45:30 <ertes> tabaqui1: sorry, i don't know what you mean
06:45:55 <__monty__> bbear: Did you import Data.Maybe?
06:46:03 <bbear> yes
06:46:06 <bbear> now I did it
06:46:11 <bbear> but that's the least of my problems.
06:46:25 <ertes> bbear: you don't need Data.Maybe, you just need to keep the value level separate from the type level
06:46:26 <bbear> I try to do if l==Empty
06:46:54 <ertes> bbear: Maybe is a *type*, while Nothing and Just are on the *value* level
06:46:54 <tabaqui1> ertes: all right
06:47:19 <bbear> No instance for (Eq a) arising from a use of ‘==’
06:47:36 <ertes> bbear: don't use (==), but use pattern matching
06:48:38 <ertes> bbear: also keep in mind that 'bool' is not the same as 'Bool'…  the latter is the type of booleans, while the former is a type variable that you named "bool"
06:48:49 <ggVGc> ertes: what prompted you to write this library?
06:48:53 <bbear> yeah I saw that
06:49:17 <bbear> it compiles :)
06:49:24 <ertes> ggVGc: i needed it for a project where i had to do time arithmetic and long-term waiting
06:49:40 <dxtr> Is there any performance difference between 'head lst' and 'lst !! 0'?
06:49:57 <bbear> http://lpaste.net/339290
06:50:10 <ertes> dxtr: perhaps a tiny constant one
06:50:31 <ggVGc> ertes: I once wrote a calendar thing with event notifications for a client, and didn't have a library such as this :( And it was not a very nice experience
06:50:56 <EvanR> dxtr: you can check this by writing it both ways in the context you will use it in, then looking at generated core
06:50:57 <ggVGc> it kept breaking at random dates because of time arithmetic bugs that I'd accidentally made
06:51:00 <ertes> ggVGc: yeah, it was basically the same thing in my case, except on a systems level =)
06:51:02 <ggVGc> because it turns out it's not that easy
06:51:25 <EvanR> dxtr: of course use -O2 when compiling to see if that makes a difference
06:51:58 <EvanR> at the language level theres not much you can say about the detailed performance of head vs !!
06:52:33 <ggVGc> other than probably don't use it
06:52:35 <ggVGc> because :(((
06:52:38 <ggVGc> runtime errors suck
06:53:07 <EvanR> right i was going to say that (!! 0) is stylistically worse than just doing head, but both are worse than doing pattern matching on the list
06:53:39 <ertes> ggVGc: the time arithmetic of timelike is still not fully correct…  you need to fix conventions in applications like: what happens when the user specifies a date that happens after a time zone switch?  (e.g. daylight savings time)
06:53:54 <ertes> ggVGc: if you want to account for that, use the timezone-series package
06:54:07 <ggVGc> ertes: if I can help it, I'm never writing anything time related again
06:54:08 <EvanR> specifying a date shouldnt be a problem
06:54:12 <ggVGc> rather, date related
06:54:15 <ertes> time is ugly
06:54:22 <ertes> well
06:54:33 <ertes> conventional time is ugly (physical time is fine)
06:54:46 <EvanR> theres no such thing as physical time in programming
06:54:56 <bbear> physical time is physical time 
06:54:59 <EvanR> everyone has always exited in a time fantasy land
06:55:04 <bbear> yes
06:55:14 <ertes> EvanR: there are approximations like the monotonic clock that you can access with the 'clock' package
06:55:18 <EvanR> which is good because in haskell we like fantasy
06:55:32 <EvanR> ertes: none of this should be necessary for just doing dates
06:55:40 <ertes> sure
06:56:00 <ggVGc> the application I was writing had countdown timers for events that ticked every minute, and events could be set days/weeks/months in the future. It also kept passed events in history, and it played an optional alarm when events triggered. Turns out, that wasn't very easy at all to get right
06:56:14 <ggVGc> at various dates, something messed up for some reason
06:56:27 <EvanR> ggVGc: you tried to write cron, a non trivial thing that already exists
06:56:33 <EvanR> also there are libraries which emulate it
06:56:39 <ggVGc> and it was always something that I could have probably thought about beforehand, but wasn't at all immediately evident
06:56:58 <ertes> ggVGc: you could hand-wave over the issue by insisting that all dates must be specified in UTC =)
06:57:07 <ggVGc> EvanR: wrong. My client forced me to write a cron, in javascript, to run on a tablet, with an interface for very old or disabled people
06:57:20 <EvanR> ... dates dont have a timezone
06:57:21 <kadoban> Everyone assumes that either time is simple, or that the special cases that make it unsimple don't come up in practice. That goes ... badly.
06:57:28 <ggVGc> ertes: that's not so great for disabled swedish people who have trouble even using a touch screen
06:58:16 <EvanR> ggVGc: lovin it
06:58:18 <ertes> "solve" time zones the way americans initially "solved" character sets: "there is no outside of america"
06:58:33 <ggVGc> anyway, I should have been using some time middleware, but I didn't know th extend of my clients demands at first, and also I don't actually know of a good time/date library for javascript
06:59:01 <ggVGc> I got it working fine in the end, but yeah, I realised I never want to touch date related code again
06:59:04 <ggVGc> it's hard.
06:59:20 <EvanR> say it with me, dates are easy
06:59:21 <mspo> the only good date library I've ever seen was perl DateTime
06:59:33 <ggVGc> also, no, it most certainly doesn't work fine if you set a date a few years ahead, or even one year ahead
06:59:39 <frontendloader> ggVGc: moment.js
06:59:41 <ggVGc> but I'm not working on it anymore!
06:59:45 <ertes> it's not just a library issue
06:59:48 <EvanR> but random stews of time related features that people come up with may require serious research
06:59:51 <ertes> date/time is just hard in general
07:00:13 <ertes> there was this website with a long list of false assumptions programmers have about time, but i can't remember where it was
07:00:21 <EvanR> ertes: libraries do contribute to the problem, since 99.9% of them do it wrong, no one knows what to think
07:01:06 <ggVGc> the best part was in the middle of dealing with the time stuff, I got hit by rookie mistake of calling from parseInt(x) and not parseInt(x, 10), which at one point messed up because apparently if you call parseInt without specifying base, and the string starts with 0, then it gets parsed as octal!
07:01:07 <EvanR> at one point, if you had a recommended library with a name, it was probably good
07:01:10 <ertes> like: "every minute has 60 seconds" =)
07:01:11 <ggVGc> <-- didn't know
07:01:23 <EvanR> but js/php/ruby have deleted that
07:02:34 <ggVGc> "If the input string begins with "0", radix is eight (octal) or 10 (decimal).  Exactly which radix is chosen is implementation-dependent."
07:02:37 <ggVGc> ^ best part of javascript
07:02:50 <EvanR> yes that used to be a huge gotcha
07:02:59 <ggVGc> well, I'll never forget it now!
07:03:13 <ertes> that's…  stupid
07:03:18 <ertes> even PHP doesn't do that
07:03:26 <EvanR> now chrome just doesnt do octal
07:03:41 <EvanR> unless you pass in the second param
07:03:52 <ggVGc> EvanR: which is even nicer, since I was developing on chrome, and my client was testing on iPad
07:04:03 <EvanR> ;_;
07:04:45 <ggVGc> software development is pretty sweet
07:05:47 <Pikarupa> Hello everyone. I'm having trouble finding a way to compile Haskell and it'd be nice if someone could help
07:05:51 <Pikarupa> I've already made a thread
07:05:55 <Pikarupa> https://www.reddit.com/r/haskell/comments/5cvtf3/how_to_get_geany_or_notepad_to_compile_haskell_on/
07:07:08 <ggVGc> Pikarupa: you should probably use stack
07:07:26 <ggVGc> it has worked well for me on windows
07:07:40 <ggVGc> Pikarupa: https://docs.haskellstack.org/en/stable/README/
07:07:41 <Pikarupa> stack? Do you mean stack overflow or sth else?
07:08:07 <ggVGc> Pikarupa: it's a solution to the problem of "It's very hard to get haskell stuff to build and packages to agree with eachother"
07:08:09 <ertes> the way i see it, this isn't about the haskell side, but the editor side
07:08:10 <ggVGc> and it works very well
07:08:16 <ertes> and stack is just going to make it more complicated in the end
07:08:17 <Pikarupa> Thanks, I'll try it out!
07:08:18 <ggVGc> oh, maybe I misunderstood
07:08:38 <sdhand> Pikarupa: I'm confused, do you want your text editor to run your program for you?
07:08:49 <sdhand> It sounds like you're looking for an IDE
07:09:04 <Pikarupa> Putting in a simplified way I want to write code, press f5 and run it immediately.
07:10:11 <ertes> Pikarupa: most editors have haskell support these days
07:10:29 <kuribas> Pikarupa: use emacs?
07:10:30 <ertes> Pikarupa: so they probably have a wiki page or something that explains it
07:11:02 <ertes> if all else fails, you can go with one of the traditional editors that many people here use, like emacs or vim
07:11:24 <kuribas> Pikarupa: you can try out yi or leksah
07:11:33 <Pikarupa> I've googled and I haven't been able to find much ertes
07:11:36 <Pikarupa> How is emacs any better?
07:11:42 <Pikarupa> But i can try it
07:11:54 <kuribas> Pikarupa: emacs is great if you are used to it.
07:12:06 <ggVGc> emacs seems to be basically the main haskell dev environment nowadays
07:12:12 <Pikarupa> I mean, I know emacs is amazing but is it any easier to configure haskell in?
07:12:16 <ggVGc> I am a vim user, but it seems to me emacs support is a lot better
07:12:25 <Pikarupa> *configure haskell to run in
07:12:40 <implementation> the best features of emacs includes: controlling your coffee machine and providing a psychotherapist when a bug drives you crazy
07:12:40 <ggVGc> yes, it has a lot of work done for it to make haskell development nice
07:12:41 <kuribas> Pikarupa: probably not...  But it's much easier nowadays with package management.
07:12:42 <ertes> Pikarupa: no, i don't think you could call it easy, if you have no emacs experience
07:12:47 <ggVGc> Pikarupa: but it's gonna be a project in itself getting into emacs
07:12:49 <ertes> Pikarupa: it has a learning curve of its own
07:13:46 <Pikarupa> I see, well emacs is on my to-do list but unless it helps this issue I'll postpone it
07:14:30 <ertes> Pikarupa: you should see if you can find an IRC channel related to your particular editor then
07:14:42 <Pikarupa> that's a really good idea
07:14:49 <Pikarupa> I'll try it, thank you
07:15:03 <ggVGc> Pikarupa: I think you're gonna have a hard time getting a decent workflow in notepad++. But maybe look at Atom
07:15:22 <EvanR> to configure geany to do haskell, you must first configure emacs
07:15:31 <ggVGc> Pikarupa: Atom is a fairly powerful editor, and I found this, https://github.com/simonmichael/haskell-atom-setup
07:15:45 <ggVGc> and it's very much easier to get into than vim or emacs
07:16:52 <ertes> i have found a very efficient way to write any configuration file of any size just by typing simple prose
07:16:57 <Pikarupa> do you think stack and atom are any easier to configure for haskell than geany or notepad++?
07:17:23 <ertes> write a stackexchange question with some randomly generated bullshit solution and a question why it doesn't work
07:17:38 <EvanR> Pikarupa: is this windows?
07:17:52 <Pikarupa> lol
07:17:53 <liste> Pikarupa: someone has already written Haskell integrations into Atom
07:17:53 <Pikarupa> yep, w10
07:18:00 <ertes> if stackexchange doesn't work, just try the next MMORPG
07:19:04 <ggVGc> ertes: should I automate the process for you?
07:19:08 <ggVGc> maybe there's a market for it
07:19:16 <ertes> i bet there is =)
07:20:24 <Pikarupa> I mean, that'd be really nice, but if you can how come someone hasn't donei t?
07:20:55 <ggVGc> Pikarupa: I linked you a github repo with haskell integration for Atom
07:20:59 <ggVGc> you should try it I reckon
07:21:13 <ggVGc> Atom is easy to use, and quite good
07:21:15 <Pikarupa> I'm on it
07:21:24 <ggVGc> :)
07:21:25 <ggVGc> good luck
07:21:32 <EvanR> Pikarupa: haskell in general on windows, most people dont know how to
07:21:38 <EvanR> unfortunately
07:21:46 <EvanR> atom might be a good route
07:21:47 <Pikarupa> thank you!
07:22:02 <ggVGc> EvanR: I was amazed a few months ago when I opened a windows install, pulled down stack, checked out my project, ran stack build, and it just built
07:22:12 <ggVGc> and then it also ran!
07:22:22 <ggVGc> and communicated with my midi controllers correctly
07:22:25 <ggVGc> it was great
07:22:57 <EvanR> i dont believe this story
07:23:01 * EvanR leaves for coffee
07:23:32 <ggVGc> IT'S THE TRUTH
07:23:36 <ahihi> I did not enjoy atom on windows, kept running into weird bugs
07:23:40 <ggVGc> wish I had recorded it
07:23:43 * hackagebot regex-do 2.6.2 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-2.6.2 (procione)
07:23:58 <ggVGc> ahihi: yeah, but given the choice notepad++ or atom?
07:24:09 <ggVGc> or, well, what other decent editor has some haskell integration
07:24:12 <ahihi> emacs.
07:24:17 <ggVGc> that doesn't have the learning curve of emacs or vim
07:24:32 <ahihi> I just spent my first weekend with emacs and I'm already convinced it's the best thing out there :P
07:26:18 <EvanR> "no learning curve" is an interesting selling point
07:26:42 <EvanR> its why UIs are generally stuck with a row of click buttons
07:28:38 <dxtr> EvanR: Btw, regarding my head vs !! earlier
07:29:02 <dxtr> https://github.com/dxtr/hagento/blob/master/src/Magento.hs#L51 <- I feel like doing something more complicated than that gives little benefit
07:29:18 <dxtr> Maybe I'm wrong, though :p 
07:29:20 <gaqwas> ggVGc: have you ever tried sublime text?
07:30:03 <EvanR> dxtr: erm... well youre doing to some length to return Nothing, but this could could very well crash without further information
07:30:42 <dxtr> What would be a better way to do this then?
07:31:09 <EvanR> you could use a safe version of !! that returns a Maybe, then chain the Maybes together
07:31:26 <dxtr> There's a safe version of !! that returns a Maybe?
07:31:41 <ahihi> @hoogle atMay
07:31:43 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
07:31:43 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:31:43 <lambdabot> Test.QuickCheck suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
07:32:23 <ahihi> they should have called it ‽
07:33:20 <EvanR> or !?
07:33:40 <EvanR> now its even more questionable!
07:34:11 <ggVGc> gaqwas: no, and I haven't really tried Atom either since I've been a vim user for a decade. But afaik sublime isn't free, and Atom is
07:34:14 <ggVGc> and they both seem fine to me
07:34:20 <ggVGc> and lots of people around me seem happy with Atom
07:34:42 <ggVGc> I think it's a good middle ground when you don't have the time/interest to get into emacs or vim
07:37:29 <gaqwas> yeah, that's exactly the reason why i didn't try sublime the first time i saw it on the net, because, unfortunately, it isn't free. but after having tried all the others i decided to give sublime a try and ended up being my favored text editor. Sublime's trial version is fully functional and doesn't expire with time, though, so if i were in your shoes, i'd give it at least a try and see if it fits your needs
07:37:49 <ahihi> it does nag at you sometimes when you save though
07:37:53 <gaqwas> yeah
07:37:55 <gaqwas> i hate that too
07:38:01 <gaqwas> i'll probably switch to atom when it's mature enough
07:39:32 <ggVGc> I will die in vim
07:42:11 <ahihi> I wish I had learnt emacs 10 years ago rather than going through... five? different "middle ground" editors
07:53:34 <mspo> ggVGc: at least your carpal tunnel will be slightly less worse
07:55:33 <unclechu> I had seen a lot of editors, some ide-s, but when I met vim I stopped on this for years, it's exactly what I need, and I don't see any replacement for vim this days. I also tried emacs but decided that I don't want to injure my fingers with five-step chords
07:56:30 <ahihi> I appreciate what vim is doing, but I was never able to get comfortable with it
07:56:58 <ahihi> as an aspiring pianist I don't mind chords ;)
07:59:16 <byorgey> ahihi: seriously, as an aspiring pianist, you should be especially worried about chords & RSI
07:59:32 <unclechu> It takes time, different reflexes and stuff (also may be you should have right keyboard first, without big right block of arrows and numpad, that prevents keeping your hands on the ASDF/HJKL), I had never seen editor so comfortable for 10-fingers typing like vim
07:59:35 <byorgey> I am a pianist, and I use emacs, but I am careful about using a nice ergonomic keyboard etc.
07:59:59 <byorgey> with modifier keys under the thumbs.
08:01:44 <ahihi> is there any actual data on the effects of editors, chords, keyboard types et cetera on RSI?
08:02:11 <JonReed> vim + programmer's dvorak + kinesis keyboard = finger heaven
08:03:37 <ggVGc> uhm
08:03:45 <ggVGc> never got the point of alternative keyboard layouts
08:03:52 <ggVGc> especially if you didn't start out with it
08:03:59 <ggVGc> what gain is there really to use dvorak?
08:04:05 <bodisiw> i definitely noticed less strain after switching to dvorak
08:04:24 <ggVGc> bodisiw: how long did it take you to get comfortable?
08:04:27 <bodisiw> its nice for musicians
08:04:31 <bodisiw> 2 weeks
08:04:34 <ggVGc> I can't see I could ever retrain my muscle memory
08:04:35 <myfreeweb> colemak is awesome, i can *feel* that my fingers use the home row much more than on qwerty, much less weird movement
08:04:37 <ggVGc> okay, maybe I should give it a try
08:04:59 <ggVGc> so, how do I decide regarding colemak or dvorak?
08:07:09 <myfreeweb> colemak is more similar to qwerty in terms of shortcuts (qwzxcvba are the same as in qwerty), and apparently (according to the website) it uses the home row 14% more than dvorak (122% more than qwerty)
08:08:38 <JonReed> Dvorak just feels more natural and better. Qwerty was specifically designed to be difficult to type
08:08:45 <ahihi> too bad stats like that don't mean much if you type in other languages besides english
08:11:20 <JonReed> What is the best testing framework in Haskell, in particular for step workflows, where you want to test several steps and feed result of one step into another? Is Tasty good?
08:12:09 <JonReed> hspec looks pretty, but it seems that it's going to be painful to write tests which depend on one another
08:12:14 <sm> doctest is nice and simple, and can build up context across tests
08:12:29 <sm> I would have thought all the others are about equivalent in power ?
08:13:45 * hackagebot show-prettyprint 0.1.2 - Robust prettyprinter for output of auto-generated Show  instances  https://hackage.haskell.org/package/show-prettyprint-0.1.2 (quchen)
08:16:03 <daey> JonReed: it wasnt designed to be difficult to type on...
08:16:08 <lwm> Could you clarify what a 'step workflow' is?
08:16:51 <lwm> JonReed: ^^
08:17:53 <lwm> Damn. Question - if I get a 'no instance of MonadReader', what should I think of doing?
08:18:20 <JonReed> lwn: You test one function, it returns something you then supply that value to another function. In other words, you preserve some context.
08:18:23 <lwm> I think this is my vaguest question yet
08:18:26 <mmaruseacph2> make an instance for it? or check type signatures, maybe you have a mistake
08:18:27 <JonReed> lwm: Like http://stackoverflow.com/questions/4430831/testing-a-multi-step-workflow-in-rspec
08:20:51 <lwm> JonReed: Any test framework handles this. Depends on your preference. Tasty can run a bunch of types of tests. So maybe try that.
08:23:25 <lwm> mmaruseacph2: Makes sense. Only thing is, I am trying to write a hspec for a function which has a MonadReader constraint
08:26:26 <JonReed> lwm: Can you post a function or it's proprietary?
08:26:53 <JonReed> lwm: I could look at it.
08:26:57 <Cale> lwm: I don't think HSpec or QuickCheck do that.
08:28:25 <sm> JonReed: did you see my suggestion ? If that's not what you want, let us know why. More context = better help
08:28:39 <byorgey> lwm: well, you will have to test your function at a particular type which has an instance of MonadReader
08:29:50 <JonReed> sm: I'm looking at doctests right now. It seems a bit weird though to write tests in comments.
08:30:11 <Cale> I think what JonReed wants is for the test framework to be able to report intermediate results as the test runs. Personally, I would just write an IO action which does a bunch of stuff and outputs intermediate results by hand, and then look to see if I was doing anything repetitive, and factor that part out.
08:30:48 <Cale> Like, some initial portion may succeed or fail, but it will also have computed some values which will be required by later parts
08:31:02 <lwm> JonReed: Here's my test: https://git.io/vXPC1. I am trying to test this function: https://git.io/vXPC7
08:31:24 <lwm> Trying to close a PR for the Stack tool
08:32:17 <lwm> Cale: Oh, why do you say that?
08:32:32 <Cale> lwm: Why do I say what?
08:33:05 <Cale> lwm: Tests in HSpec and QuickCheck don't have results other than whether the test succeeded or failed.
08:33:10 <subleq> Is there a nice way to model tabular data that preserves invariants? I'm using a list of lists, but that doesn't ensure that all the lists have the same length
08:33:56 <Cale> subleq: You could use a rectangular array
08:34:26 <Cale> (i.e. one which is indexed by pairs)
08:34:43 <sm> JonReed: the idea of doctest is to encourage examples in docs, that are also tested. It's also just an easy low-boilerplate way to write tests, and all the tests can share state, as you asked for. If your test code is very large, maybe in docs is not the best place (though you can make haddock hide it by default)
08:35:46 <sm> haskell developers often test things first by hand in GHCI, and you can just copy/paste that to make a doctest
08:36:24 <sm> advantages for non-doctest tests.. I think they run faster (no parsing overhead)
08:37:11 <JonReed> Eh, so much choice
08:37:29 <sm> yeah :) try the simplest thing that can possibly work
08:39:27 <JonReed> lwm: It seems that you need to run the monad somehow. You can't just <- cfgCmdSetValue, because the context of `it` is not the monad that this function expects to run in.
08:42:19 <lwm> JonReed: OK, I understand that at least
08:42:51 <JonReed> lwm: Probably this is the function to do it: https://github.com/commercialhaskell/stack/blob/ccca86d73cf1008edb37f75560f9470e9da9aa82/src/System/Process/Run.hs#L53
08:42:59 <JonReed> lwm: But it also needs context
08:45:57 <lwm> JonReed: Thanks, will keep messing around with it then.
08:48:46 <JonReed> lwm: Actually this seems more like it: https://github.com/commercialhaskell/stack/blob/b6a65189f4d7fffd13c1d77c5e1a74945b90fe41/src/Stack/Types/StackT.hs#L108
08:48:52 <JonReed> Only IO context
08:53:46 * hackagebot hpp 0.4.0 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.4.0 (AnthonyCowley)
08:56:39 <insitu> hello, has anybody had some experience using Concurrent ML in Haskell (http://www.cs.umd.edu/~avik/projects/cmllch/) ?
08:56:49 <insitu> or even Concurrent ML in ML...
08:57:25 <insitu> For some reason I have never had any clue this ever existed and I found the CML approach really interesting
08:58:43 <insitu> being able to compose events then synchronize at later stage, and having a way to choose one outcome would really be useful to simplify some code I am writing
08:59:05 <insitu> but there does not seem to have been any further development on this library and I am curious as to why
09:01:30 <tmciver> Hello. Anyone here familiar with the crypto library cryptonite? I'm trying to use GCM authenticated encryption but I'm not entirely sure how to use the lib. Here's what I have right now: http://lpaste.net/339323 but there's some kind of pattern match error.
09:05:15 <JonReed> tmciver: lpaste seems to be down
09:06:52 <tmciver> JonReed: :( I should have known. It said it was down for maintenance when I tried to edit the paste but I could view it fine.
09:11:28 <tmciver> How about this: https://gist.github.com/tmciver/cd294f1e7d6e31bd0a0dc37756ffcfaa
09:17:24 <JonReed> tmciver: Instead of using `let` try use a case expression like "case throwCryptoError $ aeadInit AEAD_GCM cipher iv of; (AEAD impl st) -> return iv;"
09:19:25 <tmciver> JonReed: Is this because AEAD is an existential or GADT (I'm not even sure if it is). But Haskell can normally do that sort of pattern matching, right?
09:21:48 <JonReed> tmciver: I don't know how that works, to be honest. For some reason, sometimes it just can't pattern match on GADT and existentials inside a `let` expression, but can match them in, e.g., a case expression.
09:23:47 * hackagebot test-simple 0.1.9 - Simple Perl inspired testing  https://hackage.haskell.org/package/test-simple-0.1.9 (BorisSukholitko)
09:23:55 <tmciver> JonReed: Thanks, I'll try that.
09:30:50 <nshepperd> i bet it's because let bindings are recursive
09:31:19 <nshepperd> and the whole interaction with bringing GADT constraints into the context
09:32:41 <tmciver> I'm not even sure if it is a GADT. Can someone confirm?  This is the type in question: https://github.com/haskell-crypto/cryptonite/blob/master/Crypto/Cipher/Types/AEAD.hs#L28
09:36:00 <ezyang> tmciver: It's existentially quantified, which is a less strong extension than GADT 
09:36:04 <ezyang> (but subsumed by GADTs) 
09:38:41 <tmciver> ezyang: Because of the 'forall st .' part presumably?
09:38:50 <ezyang> that's right 
09:43:25 <byorgey> but the existential quantification is exactly the part that makes it impossible to pattern-match on it in a 'let'
10:03:27 <stoopkid> hello, i'm having trouble understanding the "Storable" class definition
10:04:27 <stoopkid> it only takes a parameter "a", but then it has the member "peekByteOff :: Ptr b -> Int -> IO a"
10:04:53 <stoopkid> i don't understand what the parameter "b" is or where it comes from
10:07:34 <Tuplanolla> It can be anything, stoopkid. For example `void*` may point to some data, but have the type `Ptr ()`.
10:08:08 <lyxia> it means peekByteOff can accept a pointer of any type to read a value of type a.
10:08:32 <lyxia> peekByteOff :: forall b. Ptr b -> Int -> IO a   if you prefer.
10:08:33 <stoopkid> hrm
10:08:49 * hackagebot test-fixture 0.4.2.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.4.2.0 (lexi_lambda)
10:08:56 <lyxia> The type here is not required because the offset is given in bytes.
10:09:53 <lyxia> I mean, b is not required to be equal to a.
10:10:13 <Tuplanolla> In foreign lands, types are mere suggestions.
10:10:39 <stoopkid> hrm
10:11:33 <tabaqui1> when I'm doing cabal install text, it uses /usr/lib while compiling
10:11:40 <tabaqui1> how can I force it to use /usr/lib32?
10:12:07 <lyxia> stoopkid: The use case is that "a" may be a field of a record type "b". So if you have a pointer to "b", you can access "a" given some constant offset.
10:13:00 <stoopkid> ah, i guess that makes decent sense
10:18:45 <bbear> what do you advice me to do to practice over the monads and hard stuff like that ?
10:20:16 <Tuplanolla> I'd start by not calling monads hard stuff. It's a simple concept, but takes some time and examples to get used to.
10:20:35 <sm> bbear: write a bunch of simple programs, read the typeclassopedia
10:21:20 <sm> listen to the bartosz milewski episode of functional geekery podcast
10:22:04 <bbear> yes
10:22:10 <bbear> I need more examples
10:22:20 <bbear> like if I had to relearn how to program
10:22:33 <bbear> that is fun. I am currently writing a simple Huffman encoder.
10:23:34 <ahihi> I recommend typeclassopedia as well
10:23:44 <sm> hmm. Where can one find a large number of small, complete, maintained haskell examples in one place ?
10:24:21 <bbear> but hard
10:24:47 <sm> because it's true, studying the right examples is often the quickest way to learn this stuff
10:25:01 <bbear> yes
10:25:43 <bbear> someone needs a safari tour into haskell but the examples are really really scattered all over the place. I think it is normal, there is a lot to learn and being synthetic is hard on this topic.
10:26:08 <sm> bbear: haskell.org and haskell-lang.org have good starting pages
10:26:12 <Tuplanolla> LYaH is kind of a tour, but a different kind at that.
10:28:30 <JonReed> bbear: http://dev.stephendiehl.com/hask/#monads
10:28:45 <bbear> http://the-27th-comrade.appspot.com/blog/ahJzfnRoZS0yN3RoLWNvbXJhZGVyDAsSBUVudHJ5GOFdDA
10:35:35 <bbear> hey ya If I understand correctly a functor is just a function that takes as arguments a function (a->b), a list [a] and returns a list [b]
10:35:38 <bbear> so map is a functor
10:35:40 <bbear> right ?
10:35:59 <ezyang> bbear: It doesn't have to be a list ;) 
10:36:30 <bbear> okay so a functor is just a function that applies another function
10:36:49 <bbear> to an argument.
10:37:01 <amx> a functor is a thing for which a function like map exists
10:37:01 <bbear> but I don't understand what is <$.
10:37:12 <ezyang> :t (<$) 
10:37:13 <lambdabot> Functor f => a -> f b -> f a
10:37:30 <ezyang> imagine someone asked you to write a -> [b] -> [a] 
10:37:32 <ezyang> how would you do it 
10:37:43 <ezyang> you're only allowed to use map 
10:38:41 <glguy> bbear: fmap is a function that takes a function (a -> b) and returns a function (f a -> f b), but that's not what a "functor is", that's the type of fmap
10:39:07 <bbear> what is a class anyway ?
10:41:19 <ezyang> Haskell's way of doing overloading ;) 
10:41:31 <bbear> A thing I can't quite well understand is in type definitions of functions, is it only one and only final answer ?
10:42:02 <bbear> ezyang: for example "write a->[b]->[a]" means write a function taking a and [b] as arguments and returns [a]
10:42:18 <bbear> f a [b] = [a]
10:42:34 <ezyang> bbear: I told you, you can only use map. No pattern amtching! 
10:42:59 <bbear> if you use map you do it with a list so it makes me think kind of a inverse function
10:43:16 <bbear> map reciprocalF [b]
10:43:19 <bbear> but there is no a
10:43:31 <PhsShft> how do you eta reduce    char :: Char -> Parser Char
10:43:32 <PhsShft>     char c = satisfy (c==)   to char = satisfy . (==)
10:43:44 <PhsShft> like how do you get rid of c in this case?
10:43:55 <bbear> :t map
10:43:56 <lambdabot> (a -> b) -> [a] -> [b]
10:44:32 <ezyang> PhsShft: That is a confusing property of composition operator and binary functions 
10:44:51 <mauke> PhsShft: (c ==) is (==) c
10:44:52 <ezyang> bbear: No inversing 
10:45:11 <bbear> map f (map first (zip (repeat a) [b]))
10:45:21 <bbear> map first (zip (repeat a) [b])
10:45:24 <PhsShft> ezyang: why is it confusing
10:45:34 <ezyang> > 3 <$ [1,2,3,4,5] 
10:45:36 <lambdabot>  [3,3,3,3,3]
10:45:39 <bbear> :t map first (zip (repeat a) [b])
10:45:41 <lambdabot> error:
10:45:41 <lambdabot>     • No instance for (Arrow (,)) arising from a use of ‘first’
10:45:41 <lambdabot>     • In the first argument of ‘map’, namely ‘first’
10:45:49 <ezyang> bbear: no repeat, no zip, no first! 
10:46:08 <bbear> > 3 <$ [1,2,3,4,5]
10:46:10 <lambdabot>  [3,3,3,3,3]
10:46:22 <bbear> Ezyang my function is doing exactly what you just did
10:46:47 <ezyang> bbear: Yes, but <$ is a function that works on any functor, which means you have to limit yourself to using map (the only operation available on functors) 
10:46:57 <ezyang> PhsShft: Well, I find it confusing 
10:47:43 <PhsShft> mauke: but satisfy takes a predicate 
10:47:50 <bbear> I think I get it
10:47:56 <PhsShft> how can you have statisfy (==) c?
10:48:04 <bbear> map a [b]
10:48:09 <bbear> that's what you wanted ?
10:48:16 <ezyang> > map 3 [1,2,3,4,5] 
10:48:18 <lambdabot>  error:
10:48:18 <lambdabot>      • Could not deduce (Num a0)
10:48:18 <lambdabot>        from the context: (Num (a -> b), Num a)
10:48:19 <ezyang> you're close :) 
10:48:50 * hackagebot d-bus 0.1.5 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.5 (PhilippBalzarek)
10:48:52 <bbear> without a lambda ?
10:49:00 <ertes> bbear: write an action function:  f x xs = …
10:49:07 <mauke> PhsShft: satisfy ((==) c)
10:49:07 <ertes> bbear: not just an expression
10:49:15 <ezyang> bbear: lambda ok 
10:49:18 <ertes> bbear: s/action/actual/
10:49:24 <PhsShft> mauke: then how do you reduce c if it’s in parens
10:49:41 <mauke> PhsShft: f (g x) = (f . g) x
10:49:47 <PhsShft> oh!
10:50:00 <PhsShft> thanks
10:50:35 <bbear> map (\x -> 3) [1,2,3,4,5]
10:50:42 <bbear> > map (\x -> 3) [1,2,3,4,5]
10:50:45 <lambdabot>  [3,3,3,3,3]
10:50:46 <ezyang> dingdingding! 
10:50:55 <ezyang> ok so do you know more about what <$ does now? :) 
10:50:59 <bbear> I'm afraid it works.
10:51:20 <bbear> no idea what it does -- especially I am not seeing what purpose it could have.
10:51:25 <ezyang> So, if c is a container, x <$ c says "replace all the slots in the container with x" 
10:51:51 <bbear> with all due respect, itsounds like a major loss of information
10:52:04 <ertes> bbear: (<$) works for all functors, not just lists, and we have *lots* of functors…  for lists it's not that useful, but there are many functors where it is
10:52:04 <ezyang> it is! 
10:52:14 <ongy> is it equivalend to 'const x <$> c' ?
10:52:24 <ertes> ongy: yeah
10:53:05 <ertes> bbear: (<$) is the "i don't care about the actual result…  replace it by this value everywhere" function
10:53:26 <bbear> > 3 <$ [1,2,3]
10:53:29 <lambdabot>  [3,3,3]
10:53:34 <ertes> it's useful in the context of things that look more like "actions" than "containers"
10:54:08 <bbear> a yes so if I want to read 3 bytes I can do readBytes <$ [1..3]
10:54:15 <ertes> nope
10:54:29 <bbear> no I suppose I can't but that's an idea.
10:55:10 <ertes> bbear: have you had first-hand experince with IO?
10:55:17 <bbear> not at all
10:55:22 <bbear> oh yes a little bit 
10:55:23 <Tuplanolla> This `<$` often comes up with parser combinators, bbear.
10:55:26 <bbear> but it's hard
10:55:43 <ertes> bbear: getLine :: IO String  -- this is an action that, when executed, produces a String
10:55:59 <ertes> now IO is also a functor, so you can use (<$) to ignore its result
10:56:21 <ertes> () <$ getLine :: IO ()  -- this is the same action, but with the resulting string replaced by ()
10:56:33 <ertes> (<$) :: b -> IO a -> IO b
10:56:56 <bbear> really I just wanna troll but I can't 
10:57:04 <bbear> it's too much of time wasting
10:57:13 <bbear> but there is no case 
10:57:21 <ertes> bbear: you will encounter them =)
10:57:23 <bbear> where <$ can be *really* useful.
10:57:42 <wespiser> all the trolls have been slain
10:58:00 <wespiser> errr, they took jobs in industry and we haven't heard from them
10:58:06 <ertes> bbear: remember when you first saw the () type and thought: "wow, what's the point of that one?" =)
10:58:16 <ertes> just to find that it's used all over the place
10:58:16 <ongy> bbear: I didn't know it and just thought "whow, that's cool I can replace X with it"
10:58:17 <hodapp> or *have* they? Did I learn Haskell just to execute a very long-term trolling operation in #haskell?
10:58:18 <bbear> yes
10:58:19 <Tuplanolla> Let's say you have a parser `p` that extracts an address from some headers. If you only care about whether the headers contain an address, you can use `() <$ p`, which then combines nicely with other decision parsers like `eof`.
10:58:38 <wespiser> hodapp: I'd respect that
10:58:45 <hodapp> \o/
10:58:52 <Tuplanolla> That's a common use case for `<$`, bbear.
10:58:53 <lgstate> backus' turing award lecture was on functional programming -- what happened to that style of fp ? it seems like no one still uses it?
10:58:56 <ongy> I have code that's somewhere around "replicate (length xs) a" which I can replace by "a <$ xs" which also has the advantage that it can deal with infinite lists
10:59:16 <mauke> lgstate: sorry, we're all using OO now
10:59:29 <bbear> ongy ha yes, it's really cool
10:59:37 <wespiser> lol, lets build an OO language in HASKELL!
10:59:40 <hodapp> lgstate: Wasn't Backus' lecture on function-level programming, which is not precisely functional programming?
10:59:54 <hodapp> The only modern language I'm aware of using FLP is J
11:00:09 <bbear> ongy, so what makes your expression so special that you can use <$ ? It is because xs is a list ?
11:00:10 <mauke> wespiser: has been done before, see oleg
11:00:31 <wespiser> mauke: thanks!
11:00:47 <bbear> (and list is a functor)
11:00:49 <ertes> bbear: most useful examples come up in the context of parsers
11:01:00 <ertes> or FRP
11:01:09 <ongy> it's code where I handle some IO, I read in N files and need to set up N initial states. It's not really special, but it looks nicer. I have had a few cases where I did fmap (const x) or similar before
11:01:21 <lgstate> hodapp: yes, "functional level" programming
11:01:24 <ertes> () <$ myEvent  -- i don't care about the payload, i just want the occurrences
11:02:22 <hodapp> lgstate: he didn't call it functional-level though, he called it function-level, and it wasn't meant to be identical to FP
11:02:40 <bbear> when you write : class Functor f => Applicative f where
11:02:49 <lgstate> hodap: yes, I was confused, but either way, why is backus style FLP not used today?
11:02:51 <bbear> it means that for your f to be an Applicative, it has to be a Functor ?
11:03:01 <ongy> yes
11:03:12 <hodapp> lgstate: I don't know. The misunderstanding between FP and FLP is perhaps part of it.
11:03:36 <hodapp> lgstate: do you use J already?
11:04:01 <lgstate> hodapp: no, I just finisyhed studying clojure/minikanren, was about to look at forth
11:04:09 <lgstate> but then somehow got interested in backus style fp
11:04:26 <hodapp> lgstate: J is an interesting language that draws a lot from FLP. I'd recommend learning it if you have a chance.
11:04:27 <lgstate> I don't know APL, J, or K
11:04:39 <bbear> really need to do math to learn Haskell
11:04:40 <Tuplanolla> I've used J a bit, but I fail to see the beauty, hodapp.
11:04:42 <lgstate> is tehre a good resource on writing a mninimal J interpreter ?
11:04:49 <ongy> forth. I have to check if I can find some useful resources on it. last time that was really hard
11:04:57 <shapr> bbear: Nah, I had a Haskell job before I ever took a college math or CS course.
11:04:57 <lgstate> I feel like I don't get these langs until I can simulate how they work by writing an interpreter
11:04:58 <sm> bbear: nah
11:05:08 <bbear> is it something we can/must prove in teh Haskell world ?
11:05:22 <bbear> at least some set theory
11:05:28 <sm> nope :)
11:05:33 <shapr> If you really want to learn that stuff, it is fun?
11:05:53 <bbear> when they write : (<*>) :: f (a -> b) -> f a -> f b
11:05:57 <bbear> what does it mean exactly ?
11:06:05 <bbear> I don't really get it
11:06:15 <bbear> f (a->b) looks like function composition
11:06:20 <sm> well alright, it depends what you mean by "learn Haskell"
11:06:25 <bbear> if g:: a->b
11:06:26 <ongy> I don't know what the math behind it is, but I know how to use it :)
11:06:47 <bbear> ongy: that's the only thing that matters but how do you come to really use it
11:07:04 <ongy> hanging around in here and just working on a haskell project
11:07:23 <ongy> > [not, id] <*> [True, False]
11:07:25 <lambdabot>  [False,True,True,False]
11:07:41 <bbear> : t [not, id] <*> [True,False]
11:07:45 <bbear> :t [not, id] <*> [True,False]
11:07:47 <lambdabot> [Bool]
11:07:48 <wespiser> ongy: anything you would like to share? I'm doing exactly the same thing, lol
11:08:06 <ongy> wespiser: my project?
11:08:07 <bbear> :t <*>
11:08:09 <lambdabot> error: parse error on input ‘<*>’
11:08:11 <wespiser> ya
11:08:13 <ertes> bbear: blame most programming languages for trying to pretend that they are *not* math, thus making everything needlessly difficult =)
11:08:17 <wespiser> i don't really care about u
11:08:31 <ertes> so yes, you should learn math along with haskell, not because you have to, but because it will help you
11:08:41 <bbear> yes I know math a little bit
11:09:01 <bbear> but the real deal is like our friend (lost conversation history sorry) said, to be expressive with it.
11:09:05 <ongy> The main project is https://github.com/monky-hs/monky I outsourced a few libraries from it. netlink/pulseaudio/ibus-hs on hackage, they should all link to the repos
11:09:10 <bbear> without unnecessary complications.
11:09:29 <bbear> and using the fundamental power of the language without twisting it to no end.
11:09:53 <bbear> :t [not, id] <*> [True,False]
11:09:54 <lambdabot> [Bool]
11:10:05 <bbear> :t not
11:10:06 <lambdabot> Bool -> Bool
11:10:07 <bbear> :t id
11:10:09 <lambdabot> a -> a
11:10:17 <Tuplanolla> You can send private messages to lambdabot, bbear.
11:10:22 <bbear> ok
11:10:35 <bbear> sry
11:11:13 <sm> bbear: many folks learn lazily, just enough to get things working. Avoiding the things that don't make sense yet. Haskell is a big language so this is a good idea
11:11:18 <ertes> bbear: interestingly haskell is actually very natural…  it's all just symbolic manipulation and equational reasoning
11:11:52 <bbear> I'll agree with you. Haskell programs should be easy to prove, far easier than any program written in any other language.
11:12:11 <bbear> I think that's the killing feature of programing, to be able to easily prove programs.
11:12:26 <wespiser> bbear: "killer feature" ?
11:12:31 <bbear> yes more of a killer featuer
11:12:37 <ertes> bbear: not to prove, but even just to write
11:12:54 <bbear> many programs don't need to be proven because they are doing trivial stuff
11:12:57 <wespiser> provable program features are what we will one day have
11:13:02 <Tuplanolla> If you fancy writing proofs, take a look at Coq, bbear.
11:13:10 <ongy> bbear: if you like provable, you may want to have a look at Coq or isabelle/hol
11:13:12 <wespiser> for right now, we just get amazing abstractions and a very helpful type system
11:13:30 <wespiser> Coq and isabelle/hol aren't ready for production
11:15:17 <ertes> bbear: this really isn't about proofs…  this is about constructions and transformations
11:15:49 <nmattia> here's a snippet I just grabbed from haskell.org: http://lpaste.net/339387 however it won't compile. any hints why?
11:16:19 <nmattia> ah ha, forgot one extension. nevermind!
11:18:52 * hackagebot NetSNMP 0.3.2.3 - Bindings for net-snmp's C API for clients  https://hackage.haskell.org/package/NetSNMP-0.3.2.3 (PavloKerestey)
11:26:23 <kuribas> proving a program correct is difficult for low level stuff, like parsing a binary file format.
11:28:31 <ertes> proving a program from the ground up is unrealistic
11:28:45 <ertes> most proofs are predicated on assumptions
11:31:23 <orion> Does anyone else want to see linear types added?
11:31:24 <dedgrant_> Selecting good axioms in math is just as much a creative design problem as building a program, or developing a useful model.
11:32:15 <JonReed> orion: Of course.
11:32:49 <ertes> orion: me, me, me!
11:33:43 <JonReed> orion: But each time I check this and see that it wasn't updated, I don't get my hopes up: https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
11:34:07 <orion> :(
11:34:34 <JonReed> I mean that it was last updated two month ago, near the time that it was proposed, so probably development did not went further than proposal
11:34:46 <orion> I want linear types to prevent catastrophic key reuse with certain cryptographic ciphers.
11:36:01 <orion> Do you think the ST monad is a good workaround for the time being?
11:37:06 <ertes> orion: affine types would suffice for that
11:37:30 <nmattia> JonReed: it's being developped, don't worry :)
11:37:50 <orion> ertes: Does Haskell support Affine types?
11:38:12 <ertes> i'd like to have linear types, because it would basically replace all .Mutable modules of the vector package by .Linear that doesn't rely on any monad
11:38:16 <ertes> orion: no
11:38:40 <ertes> mutable arrays with a pure interface
11:38:47 <ertes> i'd kill for that
11:38:52 * hackagebot NetSNMP 0.3.2.4 - Bindings for net-snmp's C API for clients  https://hackage.haskell.org/package/NetSNMP-0.3.2.4 (PavloKerestey)
11:39:01 <orion> ertes: Ah, so I guess I can't use Affine types then. :)
11:39:13 <ertes> orion: i didn't say you could =)
11:39:39 <orion> But, do you think that the ST monad is good enough for my use case?
11:40:33 <ertes> orion: you want to ensure that a key is never used twice?  in other words: you want to make sure that a value is used with a certain function at most once?
11:42:01 <ertes> orion: you can't ensure that statically without at least affine types, but what you can do is to wipe out the key memory after usage, so if it's ever used twice, it doesn't come with a devastating security hole
11:42:22 <ertes> orion: i'm assuming that this is about a stream cipher key or something like that where reuse is catastrophic
11:43:53 * hackagebot clang-pure 0.2.0.2 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.2.0.2 (PatrickChilton)
11:44:08 <ertes> orion: like this: data Key s = Key { fromKey :: STRef s (Maybe (MVector s Word8)) }
11:44:30 <ertes> after encryption overwrite the array with zeroes and replace the STRef value by Nothing
11:44:51 <ertes> you probably need IO in order to be able to throw an exception on failure
11:59:17 <orion> ertes: I defined a data type that represents my cryptographic state.
11:59:46 <orion> In order to encrypt anything, you pass the state and your message-to-be-secured. The function returns an encrypted message and a mutated state.
12:00:16 <orion> Linear types would do exactly what I want: To prevent that previously used cryptographic state from being used again.
12:00:40 <ertes> orion: for security reasons i would recommend using a primitive state monad in this case
12:00:53 <orion> The user is unable to construct a state by themselves. It's essentially a black box that the end-user should never be able to muck with.
12:01:16 <ertes> like ST or IO
12:01:41 <orion> ertes: 14:39:17 < orion> But, do you think that the ST monad is good enough for my use case? <-- So you're agreeing with me.
12:04:53 <ertes> orion: yeah…  though as said you probably need IO to report failure
12:06:29 <orion> What do you think of the Catch Monad though?
12:06:34 <orion> (To report failure)
12:09:45 <ertes> i'm not familiar with it
12:17:30 <laudiacay> any good tutorials on monads/state monads/parsers? specifically parsers? and ones with a lot of exercises?
12:17:34 <pranz> how can I tell stack to ignore a build-tool dependency? more specifically, it complains that no lib in the snapshot provides llvm-config, but I have that binary already
12:18:31 <pranz> laudiacay: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
12:19:00 <pranz> It isn't that comprehensive, but it covers a nice real-world use case
12:19:56 <hololeap> is there a way to define this function as a one liner using basic prelude functions: https://dpaste.de/4LSv
12:22:59 <ertes> > [ (x, y) | (x:ys) <- tails [1..4], y <- ys ]
12:23:00 <lyxia> That doesn't need an Eq constraint
12:23:01 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
12:23:14 <ertes> hololeap: however, 'tails' is not from Prelude
12:23:53 <hololeap> ok, i guess i don't understand what prelude is then. but my question should still be understandable
12:24:31 <ertes> > [ (x, y) | (x:ys) <- foldr (\a ass -> [a] : map (a :) ass) [] [1..4], y <- ys ]
12:24:33 <lambdabot>  [(1,2),(1,2),(1,3),(1,2),(1,3),(1,4)]
12:24:45 <davean> Prelude is a Haskell module that exports some common base functions that were decided on back in an ancient Haskell standard thats pretty out of data now but the prelude has had only changes that were really required it keep it working Haskell code
12:24:58 <ertes> > foldr (\a ass -> [a] : map (a :) ass) [] [1..4]
12:25:00 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4]]
12:25:05 <ertes> whoops
12:25:05 <davean> Prelude: A weird piece of strange history
12:25:32 <hololeap> i need to turn off emoticons
12:26:10 <hololeap> foldr (\a ass -> [a] : map (a :) ass) [] [1..4]
12:26:13 <hololeap> ok, that's better
12:26:20 <ertes> hololeap: that's not correct
12:26:41 <hololeap> i know, but the :) was showing up as a smiley so i couldn't understand it
12:26:58 <ertes> > [ (x, y) | (x:ys) <- tails [1..4], y <- ys ]  -- i'd just use 'tails' from Data.List
12:27:00 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
12:27:26 <seanthedon> Wassup
12:28:03 <hololeap> ok, so tails may have been the missing piece that i was looking for
12:28:09 * younder thinks outerproducts have the potential to make some REALLY big computations. Use sparingly.
12:29:02 <hololeap> ertes: thank you
12:29:19 <younder> Some thimes I think list comprehentions are a bit to easy..
12:29:58 <ertes> i avoid them most of the time, but sometimes they just fit like a glove =)
12:30:58 <ertes> :t foldr (foldr (:)) []
12:30:59 <lambdabot> Foldable t => t [a] -> [a]
12:31:27 <ertes> foldr (foldr (:)) [] ["abc", "def", "ghi"]
12:31:35 <ertes> > foldr (foldr (:)) [] ["abc", "def", "ghi"]
12:31:38 <lambdabot>  "ghidefabc"
12:31:47 <ertes> uhm…  not quite =)
12:31:59 <ertes> > foldr (flip (foldr (:))) [] ["abc", "def", "ghi"]
12:32:00 <lambdabot>  "abcdefghi"
12:40:55 <Jello_Raptor> If anyone's around I'd appreciate some help designing an interface. 
12:41:54 <Jello_Raptor> Basically, I've got a problem which I want to be able to evaluate within haskell, as well as convert into a representation that I can trow at a SAT solver.  
12:42:34 <zv> SAT or SMT?
12:42:34 <grazie> question: ghc-pkg list tells me that `repa-3.4.1.1` is installed, but :l or `:load repa` in ghci does nothing. Why?
12:42:42 <Jello_Raptor> SMT
12:42:59 <zv> CVC or z3
12:43:08 <Jello_Raptor> z3 via SBV 
12:44:00 <zv> in general, it is easiest to try to write a datalog representation of problems when you cannot directly use z3's api
12:45:01 <zv> you can do something with the 'amb' operator to express a whole host of problems in a form that most SAT solver's naturally express the problem
12:45:11 <zv> err 'solvers'
12:45:17 <Jello_Raptor> yup
12:45:27 <grazie> what should I do to load this in ghci in order to call functions from the module?  :load repa-3.4.1.1
12:46:02 <geekosaur> :load would be the wrong thing regardless.
12:46:17 <zv> sicp basically describes such an architecture in it's 'logic evaluator'
12:46:22 <zv> but thats a lot of work
12:46:53 <geekosaur> if you are lucky, `:seti -XPackageImports` then `import "repa-3.4.1.1" whichever.Module.here`
12:47:03 <zv> you can take a look at the implementation of the python API in z3 and you'll see just how much 'manual work' this problem is
12:47:16 <geekosaur> I don't know if ghci is smart enough to apply PackegImports at the prompt though
12:47:23 <davean> geekosaur: I'd guess he wants to load a specific module from it and probably actually doesn't care about that specific version?
12:47:24 <geekosaur> *PackageImports
12:47:43 <zv> ignore the very wierd, graduate-student code-grind code (like concatenating a bunch of templates for python code????!?!??!?), and focus on the connection between internal APIs and the exposed APIs
12:47:47 <geekosaur> if so then just "import That.Module" or ":m +That.Module"
12:48:05 <geekosaur> packages are not modules, you import modules
12:48:15 <younder> Doesn't repa require a spesific version of the CUDA lib?
12:48:34 <zv> there's essential a totally manual mapping between the SAT solver's internal state and the solver literals
12:48:41 <geekosaur> if all you have is the package name, use hackage.haskell.org or hayoo to look up the package and get the modules it provides
12:48:55 <geekosaur> (or stackage, etc.)
12:49:02 <zv> there is something written in racket that does a pretty good job of extracting this but I forget what it's called 
12:49:53 <Jello_Raptor> zv: the thing that I'm not sure how best to do is the coversion from haskell to datalog for a set of objects. One example is that my system uses the string equality relationship all over the place. In order to convert an entire problem into a capatible datalog format I need to assign all the strings UIDs, and then use those UIDs as bitvectors or integers within the SMT sovler. (yes,yes, hashing is an option, but there's a dozen 
12:49:53 <Jello_Raptor> other similar elements in my system that doesn't work for) In effect I need global knowledge of the particular instance of the problem (set of all used strings) before I can generate the "strA == <UID representing 'foo'>" datalog constraint 
12:50:07 <grazie> import repa-3.4.1.1 produces <interactive>:11:8: error: parse error on input ‘repa’
12:50:38 * geekosaur apparently said nothing whatsoever
12:50:44 <Jello_Raptor> Because, other than those global pieces of information, there's a really straightforward bottom up translation of my problem into datalog
12:51:08 <grazie> ok, some progress, I've found the names of the modules, but trying to load one does: Could not find module ‘Data.Array.Repa.Base’     it is a hidden module in the package ‘repa-3.4.1.1@repa-3.4.1.1-8WegHPlyLUhBnx1jAMPd7t’
12:51:35 <grazie> thank you geekosaur, got it  :m Data.Array.Repa
12:51:40 <athan> lol
12:52:03 <cocreature> grazie: add repo to the build-depends in your cabal file
12:54:09 <cocreature> *repa
12:54:31 <cocreature> oh should have read your last message first
12:54:37 <Jello_Raptor> I'm looking for the standard haskell way to encode the "basically a bottom up transformation from one type into another, but occasionally requires global information about the original type" 
12:56:10 <grazie> cocreature: thank you 
12:58:52 <Veltas> Getting a syntax error on line 9: http://pastebin.com/esAxGQZ7
12:59:42 <chreekat> Jello_Raptor: would it work to include a Reader/ReaderT as part of your transformation's type? (which is different from the type being transformed, of course)
12:59:49 <Veltas> "error: parse error on input ‘|’"
13:00:46 <Veltas> Also, slightly off-topic, is there a way to get GHC to give slightly more helpful error messages?
13:01:54 <kadoban> Parse errors aren't all that easy to give much info about. Its error messages are generally quite good, the non-parse-error kind anyway.
13:01:55 <chreekat> Veltas: ghc does the best it can, though improvements are possible
13:02:03 <geekosaur> Veltas, "where" attaches to declarations, not expressions. the "where sumYearDays" terminates the definition of daysBefore
13:02:32 <geekosaur> so the following "| month ..." is no longer part of it and is an error
13:08:22 <athan>  /window 11
13:08:25 <athan> :|
13:08:50 <hololeap> does it take more work for the compiler to write "sum . map abs $ [x,y,z]" rather than "abs x + abs y + abs z". i'm just wondering if there is any overhead for constructing a list 
13:11:19 <Veltas> geekosaur: Ah right okay thanks!
13:11:31 <geekosaur> hololeap, remember that Haskell is lazy. many lazy lists never actually get made
13:11:53 <joe9> Does anyone know if ghc compiles on 9front?
13:13:49 <mnoonan> Suppose I have a typeclass TC with an instance method foo, and I want to define an instance of TC in a module that happens to also have a function called foo. How can I do it?
13:14:00 <mnoonan> (I'm modifying somebody else's code here, so please don't judge my character :)
13:14:21 <geekosaur> hololeap, although in that particular case it is probably a wash (and the list probably needs to be made, unless there's some really clever rewriting going on)
13:14:25 <ertes> mnoonan: it should work just like that
13:14:38 <ertes> mnoonan: the ambiguity arises when you *use* foo
13:14:55 <geekosaur> mnoonan, within an instance definition the class's stuff is in a more local scope than the file level bindings, so it should just work
13:15:10 <geekosaur> when using it at file scope, you need to qualify
13:15:21 <mnoonan> ertes: oh shoot, sorry! you're right, I did "import TC as TC" but forgot 'qualified'
13:15:47 <ertes> mnoonan: "import TC as TC" = "import TC"
13:16:09 <mnoonan> well, it was really "import Emit as E", but yeah..
13:17:02 <Tuplanolla> I sometimes wonder if mathematical reasoning could be extended to create a complete and consistent import-export system.
13:17:34 <Tuplanolla> These things often feel like an afterthought.
13:19:02 <geekosaur> it could be complete and self-consistent but quite unlike what people actually expect, though
13:20:38 <Jello_Raptor> chreekat: That's the current plan, though I would like to ahve some sort of lazy cache for this sort of thing. 
13:22:15 <Tuplanolla> Maybe being useful would be a good goal as well.
13:22:32 <Jello_Raptor> which I suppose a ReaderT holding a lazy map is v0v
13:25:23 <Tuplanolla> (I forget that's not a given around here.)
13:33:57 * hackagebot http-api-data 0.3.3 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.3.3 (NickolayKudasov)
13:34:12 <maerwald> xD
13:38:52 <ertes> Tuplanolla: agda gets very close to that…  the only missing part is that modules are still not first class
13:39:48 <ertes> you can really see that the module system was part of the concept from the beginning or at least very early on
13:40:14 <Tuplanolla> Where can I read about it without having to learn all of Agda?
13:40:51 <Tuplanolla> I'm saving that for later.
13:59:47 <ertes> Tuplanolla: imagine that you can import modules anywhere (e.g. let/where blocks), that you can define them anywhere, that they can be nested, that they can be parametric, that each record type has a corresponding module (which makes lexical scoping of module namespaces possible)
14:00:34 <Tuplanolla> That sounds like a static analysis nightmare.
14:00:41 <Tuplanolla> Surely there must be some tradeoffs.
14:00:51 <ertes> none that i know of
14:00:54 <geekosaur> also conflicts with Haskell's semantics re instances
14:01:01 <geekosaur> (always global)
14:01:05 <ertes> yeah, haskell can't have all features of it
14:01:23 <ertes> however, i wouldn't mind giving up the open world assumption too much
14:02:06 <Tuplanolla> Alright, that's it. We're procrastinating by learning about Agda.
14:05:33 <ertes> well, when a lot of people talk about SomethingCool, eventually we may get -XSomethingCool =)
14:05:54 <geekosaur> some things would have to be redesigned though. like, you could trivially hide two maps inside a Map by introducing a local Ord instance
14:06:08 <miscyb> does anyone here have experience with the galois curl binding?
14:06:44 <miscyb> it's behaving strangely for an ftp transfer
14:07:41 <ertes> geekosaur: i guess it really only makes sense when we have -XDependentTypes
14:08:15 <ertes> Map :: (a :: *) -> {Ord a} -> *
14:09:35 <ertes> although that part is actually possible with -XTypeInType, i think
14:14:46 <Tuplanolla> Is Agda's module system the best we can do or do we simply not know?
14:16:17 <ertes> Tuplanolla: nope, the ultimate module system would probably make modules just record types or something
14:16:55 <Tuplanolla> I just worry that things would become undecidable at some point before that.
14:18:00 <ertes> yeah, that's probably unavoidable
14:23:58 * hackagebot filepath 1.4.1.1 - Library for manipulating FilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-1.4.1.1 (NeilMitchell)
14:32:10 <miscyb> has anyone here used ftphs before?
14:32:17 <miscyb> how are the speeds if you have?
14:45:45 <dxtr> Are there any good HXT resources I can read?
14:46:44 <laudiacay> does anyone have a really good explanation for (<++)? I just don't get it at all
14:47:34 <lyxia> laudiacay: where does that come from
14:48:03 <laudiacay> lyxia: that's from the ReadP parser library. we're studying it in my class, and I have to re-implement it for our baby parser library assignment
14:48:16 <lyxia> "This is a bar chart comparing the proportions of boys and girls
14:48:19 <lyxia> between 5 and 14 year old participating in various leisure
14:48:30 <lyxia> oops
14:48:35 <cpdean> can you define a type in haskell that's like "even numbers" or "numbers between 1 and 10" ?
14:48:54 <byorgey> cpdean: no, not easily
14:48:56 <lyxia> "Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used.Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used."
14:48:59 <laudiacay> cpdean: nah but you could like make a list with those
14:49:11 <jle`> cpdean: there are some libraries that offer things like that
14:49:13 <jle`> using smart constructors
14:49:36 <jle`> constructors for your types that only let you "create" them if they satisfy an arbitrary predicate
14:49:41 <jle`> they basically just wrap normal types
14:49:45 <cpdean> ah hmm
14:49:48 <laudiacay> lyxia: so like: try left parser, if it gives you anything, ignore right parser and keep parsin' with whatever comes next. if left parser gives you nothing, do the right parser.
14:49:53 <cpdean> but then the error happens at runtime for a user?
14:49:58 <lyxia> laudiacay: right
14:50:13 <jle`> cpdean: well, only if there is unconstrained input
14:50:13 <laudiacay> lyxia: yuck, my code is going to be disgusting
14:50:29 <jle`> cpdean: the smart constructor returns something in something like 'Maybe'
14:50:32 <cpdean> yes i would think types could constrain the input
14:50:42 <jle`> and it's up to you to pattern match and figure out what to do from there
14:50:48 <jle`> cpdean: well, what if you ask for a number from stdin?
14:50:48 <cpdean> mm
14:50:55 <jle`> are you going to magically force the user to only give even numbers?
14:51:00 <ph88> hello :)
14:51:00 <jle`> social engineering, maybe?
14:51:09 <jle`> you're going to have to handle "unparseable" input either way :)
14:51:11 <cpdean> ah
14:51:11 <jle`> ph88: hi!
14:51:22 <cpdean> yeah i guess users writing code don't supply literals that often
14:51:32 <Koterpillar> miscyb: used ftp, but for small files so can't vouch for speeds
14:51:33 <_cyril_> I'm very tempted to buy "Haskell Programming from First Principles" as I keep on reading raving reviews about it. I'd prefer a hardcopy though, does anyone know if it will be available as a hard copy soon? Or at least if I'd get a discount on the future purchase of a hard copy if I buy the ebook now?
14:51:35 <cpdean> users of software more so
14:51:38 <jle`> it's not like you can ensure at compile-time that the user will be coerced by threat of violence into only giving even numbers
14:52:05 <dxtr> jle`: not with that attitude you can't
14:52:20 <jle`> cpdean: these are runtime errors that are unavoidable...kind of like parse errors
14:52:26 <jle`> dxtr: :P
14:52:39 <cpdean> jle`:  mm… yeah that makes sense
14:52:54 <jle`> what other type of runtime errors were you thinking of?
14:53:32 <cpdean> you know i have no idea
14:53:42 <jle`> of course, with things like "numbers between 0 and 10", they wouldn't be super useful because they don't have meaningful Num instances
14:53:47 <cpdean> i hadn't thought far enough ahead on this one
14:53:47 <jle`> and other useful things you'd want to do with numbers
14:54:14 <kuribas> jle`: modulo 10?
14:54:46 <jle`> ah, yeah, i tink that might be ok if you don't think too hard about properties
14:54:56 <jle`> but, no signum or fromInteger i guess
14:55:06 <jle`> but those are problems with the Num typeclass
14:55:18 <kuribas> signum = 0 or 1
14:56:32 <_cyril_> I should have read the FAQ better: the answer to my question is on the book's website...
14:58:11 <Jello_Raptor> is there a less annoying way to write line 2 of this http://lpaste.net/339507 ? just so that I don't ahve a pile of different constraints on type families mixed together with the constraints on the actual type?
14:59:36 <Jello_Raptor> err, line 3 of that paste
15:01:49 <miscyb> Koterpillar: how large were the files? I was trying to use the galois curl binding earlier and it was giving me weird problems with files that were a few hundred megs.
15:02:09 <Koterpillar> miscyb: <10K
15:02:49 <miscyb> Koterpillar: alright, well it looks like i'll have to test myself
15:03:06 <jle`> cpdean: one lib that implements things like what you mentioned is http://hackage.haskell.org/package/refined , although like i noted, you should be aware that without dependent types, operations on such refined types are often limited/partial
15:04:59 <c_wraith> Jello_Raptor, if an instance (Eq t) => Eq (Constraints t) is possible, it would remove one of the constraints. 
15:05:27 <Jello_Raptor> c_wraith: sadly nope, not in this case 
15:08:07 <Jello_Raptor> c_wraith: sadly nope, not in this case 
15:14:49 <Profpatsch> @djinn [minBound..maxBound]
15:14:49 <lambdabot> Error: Undefined type []
15:15:02 <Profpatsch> Ah, right
15:15:11 <Profpatsch> It’s from types to function. Hm.
15:15:32 <Profpatsch> @djinn Enum a => [a]
15:15:32 <lambdabot> Error: Undefined type []
15:15:39 <geekosaur> that and djinn can't handle recursive types
15:16:38 <geekosaur> Jello_Raptor, I would not say that mixing constraints like that is necessarily wrong or even "messy". the only real confusion is that the type family otherwise doesn't show up in the head, but in the body. (potentially a reason to prefer functional dependencies...)
15:16:45 <hexagoxel> and the trivial implementation would be [] anyways :)
15:22:43 <Profpatsch> geekosaur: There is an other @ command that is more advanced than the djinn, but I forgot what it’s called.
15:22:44 <Profpatsch> @help
15:22:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:22:49 <Profpatsch> @help list
15:22:49 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
15:22:52 <geekosaur> it's not an @
15:22:58 <geekosaur> you're thining of :exf
15:23:08 <geekosaur> @hackage exference
15:23:08 <lambdabot> http://hackage.haskell.org/package/exference
15:23:14 <kadoban> Profpatsch: You mean the exferenceBot ?
15:23:20 <Profpatsch> :exf Enum a => [a]
15:23:20 <exferenceBot> maybeToList Nothing
15:23:39 <geekosaur> (but, be careful what you ask for :p )
15:25:34 <hexagoxel> note that enum is not bounded, so the only implementations other than [] would involve toEnum on random Ints.
15:29:38 <Ste1891> Hey guys.  I've just bumped into an odd problem.  I'm working on a 3D game engine and in my main module I import Data.Matrix.  I've already compiled previous versions numerous times, which have included functions from this module and compiled OK.  I've just introduced a call to "inverse" and GHC says it's not in scope.
15:29:55 <Ste1891> Any idea what stupid thing I could have done?
15:30:15 <yulax> ggVGc: i use dvorak, and it is more comfortable for me
15:31:12 <yulax> this may be because i type in a more rigid position with my wrists, but it is definitely true that it makes your fingers move as little as possible from the middle row
15:32:05 <yulax> it also prevents people who don't know dvorak from peeping over your shoulder to find out your passwords :-P
15:32:41 <kadoban> yulax: Not really though, heh
15:32:50 <hexagoxel> Ste1891: you are building against matrix<=0.3.5.0
15:32:58 <Cale> Ste1891: Well, first of all, check that the whole module is imported, secondly check that the correct version of the correct package is being used -- depending on how you build, you might have to turn up the verbosity.
15:33:00 <MarcelineVQ> Ste1891: only the latest Data.Matrix (0.3.5.0) has inverse so you might not have that version
15:33:19 <hexagoxel> MarcelineVQ: :p
15:34:22 <MarcelineVQ> it might exist in earlier versions, I don't know anything about matrices, but that's the only one with that name
15:40:38 <Ste1891> OK.  I've got version 0.3.4.4 so that must be it.  I'm a bit surprised it only just got added as it seems like a pretty mainstream thing to do on a matrix.  To be fair I haven't gone to the effort of writing it though.  Thanks.
15:45:43 <yulax> kadoban: im drunkw,this is what i think, as a drunk person!
15:51:47 <ggVGc> yulax: have you given colemak a real try?
15:52:50 <yulax> ggVGc: nope, although i have heard it is closer to qwerty so might be easier to learn
15:52:59 <laudiacay> / b2
15:53:24 <yulax> ggVGc: i was able to learn dvorak in 2 weeks by doing exercises and typing in nothing but dvorak.
15:53:41 <ggVGc> yulax: what resources did you use?
15:53:43 <johnw> this discussion should be taken to #haskell-offtopic
15:53:44 <ggVGc> I might give it a 2 week spin
15:53:47 <ggVGc> johnw: sorry
15:53:50 <ggVGc> yeah
15:53:50 <johnw> n/p
15:54:04 <johnw> we all forget, so I just act as your subconscious reminding you :)
16:09:46 <jle`> is there a common (Maybe a, b) -> Maybe (a, b) in base?
16:10:00 <jle`> i know about sequence :: (a, Maybe b) -> Maybe (a, b)
16:10:08 <jle`> but i wonder if there's something for the first
16:10:15 <parsnip> i tried to describe on of haskell's learning curves at a meetup, but i think i got the words wrong. i said "higher-kinded types", but i was trying to refer to the theme in functor, applicative, monad. i mean, Maybe is higher kinded too right? what differentiates a thing like Functor from Maybe? 
16:10:56 <parsnip> especially applicative and monad i think, are harder than functor. 
16:11:25 <kadoban> Well, Maybe is a type constructor, Functor and friends are typeclasses. Somehow I don't think that's what you're looking for though.
16:11:32 <johnw> jle`: that's strength
16:11:38 <parsnip> higher-kinded typeclasses? 
16:11:43 <jle`> parsnip: i wouldn't consider Maybe to be higher-kinded ...
16:11:56 <jle`> Maybe is like negate, abs, etc.
16:11:59 <johnw> jle`: it's not in base, though, but in various edwardk libraries
16:12:05 <jle`> higher-order functions would be like map, foldr, etc.
16:12:19 <jle`> parsnip: higher-kinded types are type functions that take type functions
16:12:28 <Rembane> jle`: What about first in Control.Arrow?
16:12:29 <jle`> but Maybe doesn't take any type functions, it just takes *'s
16:12:46 <jle`> Rembane: not sure that works
16:13:02 <jle`> i guess i could fmap swap . sequence . swap, heh
16:13:15 <pgiarrusso> Maybe is a type constructor (a kind of type function), of kind * -> *, while Functor, Applicative, Monad are type classes that abstract over type constructors
16:13:15 <jle`> parsnip: Functor :: (* -> *) -> Constraint
16:13:26 <jle`> parsnip: Num :: * -> Constraint
16:13:32 <jle`> Functor would be higher-kinded, but Num would not
16:13:36 <pgiarrusso> that is, when you say Functor f, f has kind * -> * like maybe
16:13:38 <jle`> to compare apples to apples
16:13:55 <jle`> Maybe :: * -> *, and MaybeT :: (* -> *) -> * -> *
16:14:00 <Rembane> jle`: The more fmaps the merrier! :D
16:14:07 <jle`> Maybe is not higher-kinded, but MaybeT is 
16:14:19 <jle`> see how MaybeT takes a type function as an input?
16:14:23 <parsnip> so higher-kinded typeclass is an okay abbreviation for that learning curve? 
16:14:38 <jle`> an abbreviation for a learning curve?
16:14:44 <jle`> are learning curves abbreviatable?
16:15:07 <pgiarrusso> parsnip: those are IIRC constructor type classes
16:15:09 <jle`> not sure what you're asking for
16:17:19 <pgiarrusso> jle` parsnip: I think one question is, of what concept are Functor, Applicative and Monad an instance?
16:17:37 <pgiarrusso> or in particular, what's the name for that stage in Haskell's learning curve
16:18:06 <hpc> denial :P
16:18:42 <MarcelineVQ> everything-after-pattern-matching
16:19:21 <jle`> oh, you're trying to describe the stage in haskell of learning about typeclasses like functor/applicative/monad ?
16:19:40 <pgiarrusso> If I had to, I'd say "abstracting over type constructors"
16:19:49 <sm> type abstractions
16:21:55 <pgiarrusso> but there are also other concepts there (Applicative and Monad are also used to write effectful programs, and that's one thing which is harder than Functor)
16:23:26 <sm> program structure abstractions ?
16:25:55 <Squarism> I have a thread that receives input from a websocket. I would like the thread had some timeout trigger that would tear it down but first do some persisting. Any hints on what approach to use?
16:30:34 <johnw> by "do some persisting", do you mean writing out some data to disk?
16:42:14 <Squarism> johnw, yep
16:42:52 <johnw> so, you can use "timeout", and then do your saving after that block completes
16:43:27 <Squarism> johnw, is that in some thread api?
16:43:33 <johnw> it's in Control.Exception
16:43:54 <johnw> it terminates an IO block if it hasn't completed in a certain length of time
16:44:53 <Squarism> johnw, https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html ?
16:44:59 <Squarism> cannot find timeout
16:45:21 <johnw> sorry, System.Timeout
16:47:48 <om-foxy> is there a known problem with cabal in that `pkgconfig-depends` option does not get used with `cabal repl`?  I can link a C program with the library I am binding to but it the symbol does not get found with `cabal repl`.
16:49:26 <om-foxy> The library file is in "/usr/libx86_64-linux-gnu/"
17:07:15 <glguy> om-foxy: No, that doesn't appear to be an issue with Cabal in general
17:08:33 <glguy> om-foxy: I made a quick test package that had pkgconfig-depends: lua, (and I have a /usr/local/lib/pkgconfig/lua.pc) and the correct flags are passed to GHCi when I run cabal repl
17:13:28 <glguy> om-foxy: Make sure you're looking for a .pc file, not the library itself when using pkgconfig-depends
17:16:30 <om-foxy> glguy: thanks.  pkg-config --list-all lists the package I am wanting to link against.
17:25:38 <blankstare> Hi, I wrote code to convert from a hexadecimal string to base64. If anyone would like to read it and give me tips on how to make it more idiomatic, I would appreciate that. https://gist.github.com/msvbg/19a2ebc743eeb77a4daa4d8a8c443d25
17:29:05 * hackagebot cgi 3001.3.0.2 - A library for writing CGI programs  https://hackage.haskell.org/package/cgi-3001.3.0.2 (cheecheeo)
17:30:18 * hodapp blinks
17:30:27 <hodapp> people still use CGI on web servers?
17:31:27 <hpc> fastcgi
17:31:39 <hpc> also it's easy mode for web services
17:38:52 <hodapp> I actually quite liked the modularity that CGI and FastCGI provided
17:39:05 * hackagebot bond 0.7.0.0 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.7.0.0 (chwarr)
17:40:01 <hpc> i liked knowing that the only thing behind my code that i didn't write was apache
17:40:25 <hpc> (unless i went out of the way to find other libraries)
17:40:34 <hodapp> yeah, that's worth something
17:43:34 <johnw> is there a lens equivalent to to (fmap (view _2))?
17:43:48 <nevere> I have automatically generated lenses and associated type classes (HasId, HasName) for a record. I am wrapping this record in a wrapper datatype. Is there a way to easily make the wrapper, instances of all typeclasses that the wrapperd data is an instance of?
17:47:53 <Paprikachu> hi, what would be the signature of a function that raises an error
17:48:02 <Paprikachu> like raiseFooError = error "foo"
17:48:09 <Koterpillar> :t error
17:48:11 <lambdabot> [Char] -> a
17:48:25 <Koterpillar> :t error "foo"
17:48:25 <Paprikachu> -_-
17:48:26 <lambdabot> a
17:48:55 <Koterpillar> Paprikachu: maybe you want something from Control.Exception?
17:49:10 <Paprikachu> no, i have to use error
17:49:25 <Koterpillar> why?
17:49:26 <Paprikachu> but i don't want to write the error message multiple times
17:49:32 <Paprikachu> because that's what the assignment ays
17:49:35 <Paprikachu> says
17:49:48 <Paprikachu> what's that "a"
17:49:49 <Koterpillar> well, you can assign 'error "foo"' to a variable
17:49:52 <Koterpillar> a is any type
17:50:09 <Koterpillar> sorry, give 'error "foo"' a name
17:50:21 <jle`> Paprikachu: `foo = error "foo"` is basically treating foo as undefined
17:50:32 <jle`> foo :: Int; foo = error "foo" is an undefined Int
17:50:43 <jle`> so it can take on any type you want
17:50:49 <jle`> cause you aint gonna be able to use it
17:50:56 <Paprikachu> i see
17:51:06 <jle`> this is a little different than "raising an error"
17:51:08 <Paprikachu> that makes a surprising amount of sense, though it still feels weird
17:51:32 <jle`> raising an exception in the context of Haskell is an IO action
17:51:41 <jle`> it's the IO action of throwing an exception
17:51:52 <jle`> but 'error "foo"' is more or less denoting that that value is undefined
17:53:02 <jle`> head (x:_) = x; head [] = error "empty list" is basically saying that head [] is undefined
17:53:07 <jle`> and head (x:_) is x
17:53:35 <Paprikachu> gotcha
18:02:03 <jle`> Paprikachu: if you loosely interpret error, you can think of a function returning 'Maybe a' as returning an 'a' with a potential error/Nothing
18:04:28 <jle`> :t listToMaybe
18:04:29 <lambdabot> [a] -> Maybe a
18:04:32 <jle`> > listToMaybe [1,2,3]
18:04:34 <lambdabot>  Just 1
18:04:35 <jle`> > listToMaybe []
18:04:37 <lambdabot>  Nothing
18:29:21 <Paprikachu> is there an operator for composing predicates
18:29:45 <Paprikachu> i.e. given f and g, i want to compose them such that i get f x && g x
18:31:26 <monochrom> you may like liftA2 (&&)
18:31:38 <Welkin> Paprikachu: apply a list of predicates over the value and then And them together
18:31:43 <Welkin> :t all
18:31:45 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:32:42 <Welkin> :t zipWith ($ 4) [(<5), (>3), (`mod 2` == 0)]
18:32:43 <lambdabot> error: parse error on input ‘2’
18:32:50 <Welkin> > zipWith ($ 4) [(<5), (>3), (`mod 2` == 0)]
18:32:52 <lambdabot>  <hint>:1:34: error: parse error on input ‘2’
18:33:03 <Welkin> > zipWith ($ 4) [(<5), (>3), (`mod` 2 == 0)]
18:33:05 <lambdabot>  error:
18:33:05 <lambdabot>      The operator ‘mod’ [infixl 7] of a section
18:33:05 <lambdabot>          must have lower precedence than that of the operand,
18:33:11 <Welkin> > zipWith ($ 4) [(<5), (>3), ((`mod` 2) == 0)]
18:33:12 <Welkin> o.o
18:33:13 <lambdabot>  error:
18:33:13 <lambdabot>      • Couldn't match type ‘Bool’ with ‘b -> c’
18:33:13 <lambdabot>        Expected type: Integer -> b -> c
18:33:38 <Welkin> > zipWith ($ 4) [(<5), (>3), (\a -> a `mod` 2 == 0)]
18:33:40 <lambdabot>  error:
18:33:40 <lambdabot>      • Couldn't match type ‘Bool’ with ‘b -> c’
18:33:40 <lambdabot>        Expected type: Integer -> b -> c
18:33:42 <Welkin> lol
18:35:40 <jle`> Paprikachu: you can use sequence to sequence a bunch of predicates
18:35:56 <jle`> :t sequence [(<4), even, (> 10)]
18:35:58 <lambdabot> Integral a => a -> [Bool]
18:36:01 <roboguy`> > map ($ 4) [(<5), (>3), (\a -> a `mod` 2 == 0)]
18:36:03 <lambdabot>  [True,True,True]
18:36:13 <Welkin> wow
18:36:18 <Welkin> I am burned out tonight
18:36:19 <Welkin> yeah
18:36:21 <Welkin> I meant map
18:36:23 <jle`> > sequence [(<5),(>3),even] 4
18:36:25 <Paprikachu> i like a solution i found on so, defining .&&.
18:36:26 <lambdabot>  [True,True,True]
18:36:35 <Paprikachu> (.&&.) f g a = f a && g a
18:36:55 <mmaruseacph2> I usually do and . map ($ a) $ [f, g]
18:37:04 <Welkin> > and $ map ($ 4) [(<5), (>3), (\a -> a `mod` 2 == 0)]
18:37:06 <lambdabot>  True
18:39:06 <roboguy`> > foldMap (Any .) [(<5), (>3)] 4
18:39:08 <lambdabot>  Any {getAny = True}
18:39:35 <roboguy`> foldMap is kinda fun =)
18:44:27 <Paprikachu> so, i'm supposed to implement a tree data structure and a function to flatten it; i figured that flattening a tree is essentially folding it using :, right?
18:44:39 <Welkin> yes
18:44:40 <Paprikachu> so is there a way to make foldl/foldr work with my tree data structure?
18:44:56 <Welkin> define a Functor instance
18:44:59 <Welkin> first
18:45:28 <Welkin> you will need to define Foldable
18:45:29 <Welkin> yes
18:45:45 <Paprikachu> hmm
18:46:21 <Welkin> Functor, Applicative, and Foldable
18:47:09 <Welkin> well, I guess not quite though
18:47:29 <Welkin> you could just write a function "pre/post/level/in-order"
18:47:32 <Paprikachu> :t foldl
18:47:34 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:47:36 <Welkin> that will flatten it to a list or sequence
18:47:43 <Welkin> I've done both
18:48:43 <Welkin> I used Seq to do this `inOrder (Bin k left right) = inOrder left >< SQ.singleton k >< inOrder right`
18:50:08 <Welkin> you can jjust do it with Functor and Foldable though too
18:50:25 <Paprikachu> yeah, i'd prefer to do it with the standard fold
18:51:14 <Welkin> actually, I think you don't even need the functor instance
18:51:17 <Welkin> but it's nice to have
18:51:47 <Welkin> you'll probably want to define foldMap though
18:51:53 <Welkin> it's simpler than defining foldr/l
18:52:02 <Welkin> then you can still use any of the methods from Foldable
18:52:29 <Welkin> :t foldMap
18:52:31 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
18:57:25 <Paprikachu> hm, i don't quite get what foldMap does
18:58:21 <Welkin> Paprikachu: it just uses the Monoid instance to fold it
18:58:46 <Welkin> `t a` could be your `Tree a`
18:58:53 <Welkin> for which you need a Foldable instance
18:59:19 <Welkin> `(a -> m)` is a function from that `a` to a Monoid m
18:59:26 <Welkin> in this case, a list
19:04:28 <Paprikachu> so, right now i'm fighting with the syntax
19:04:42 <Paprikachu> how do i define an instance of Foldable for Tree?
19:04:53 <Paprikachu> i tried "instance Foldable Tree where"
19:05:30 <Paprikachu> i also tried "instance Foldable Tree a where" and "instance Foldable (Tree a) where"
19:05:40 <Koterpillar> how is your Tree defined?
19:05:51 <Paprikachu> data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Eq, Ord, Show)
19:06:07 <Koterpillar> the first one is right
19:06:26 <Koterpillar> what's it telling you?
19:07:19 <Tuplanolla> No, it's `instance Foldable Tree where`.
19:07:28 <Koterpillar> er, I meant that
19:07:43 <Paprikachu> http://ideone.com/rHw2wG
19:08:09 <Koterpillar> Paprikachu: just remove the foldMap type
19:08:15 <Koterpillar> Paprikachu: the typeclass defines what it is
19:08:35 <Paprikachu> oh..
19:11:13 <Paprikachu> so in my foldMap i'm supposed to do what?
19:11:21 <Welkin> use the monoid
19:11:41 <Welkin> foldMap _ Empty = mempty
19:11:57 <Welkin> foldMap _ (Tree a left right) = ?
19:11:59 <Welkin> er
19:12:03 <Welkin> foldMap f (Tree a left right) = ?
19:12:13 <Welkin> fill in the `?`
19:12:42 <Welkin> `a` is your node's value, and `left` and `right` are subtrees
19:13:11 <Welkin> look up the Monoid typeclass
19:13:31 <Welkin> the methods you need to know are `mempty` and  `mappend` (<>)
19:19:02 <Paprikachu> foldMap f (Node a l r) = foldMap f l <> f a <> foldMap f r
19:19:04 <Paprikachu> so like this?
19:20:32 <Welkin> exactly
19:24:00 <Paprikachu> hm, this still isn't working somehow
19:24:44 <Paprikachu> first of all, i'm getting an ambiguity on ideone for foldl/foldr and i don't know how to fix that
19:26:02 <Paprikachu> http://ideone.com/LWv9PX
19:27:59 <roboguy`> Paprikachu: ahh, it is using a version older than (I think) ghc 7.10. Try hiding the foldl/foldr from Prelude by putting "import Prelude hiding (foldl, foldr)" at the top
19:28:16 <roboguy`> Prelude used to have specialized versions of foldr and foldl
19:28:24 <roboguy`> (specialized to lists)
19:28:46 <Paprikachu> ok, but now everything works on ideone, but not here
19:28:58 <roboguy`> what's wrong?
19:29:41 <geekosaur> I think they're still in Data.List but now use Foldable
19:29:52 <geekosaur> not in Data.Foldable
19:30:04 <geekosaur> before 7.10 Foldable was much more limited
19:30:43 <Paprikachu> http://ideone.com/np7bZo
19:30:46 <Paprikachu> i'm getting this error
19:31:19 <geekosaur> oh, nope, that'd be something different
19:33:11 <Paprikachu> line 84 in that error message corresponds to line 81 here: http://ideone.com/iZJuIP
19:33:49 <Paprikachu> also, i didn't need to hide foldl/foldr locally
19:34:34 <Welkin> Paprikachu: upgrade to ghc 8
19:34:35 <Welkin> :S
19:34:36 <Welkin> :D
19:34:52 <Welkin> :t foldr
19:34:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:34:56 <Paprikachu> the code is supposed to run under hugs
19:35:02 <Welkin> haha
19:35:15 <monochrom> so use hugs. why use ideone.
19:35:27 <Paprikachu> i have ghc here
19:35:45 <monochrom> that is still not a reason to use ideone.
19:35:53 <Paprikachu> eh?
19:36:02 <monochrom> or rather to care about ideone errors.
19:36:17 <monochrom> OK, I'm being a logician, OK?
19:36:30 <monochrom> The objective is to get code to work to hugs.
19:36:38 <monochrom> So what's the relevance of ideone?
19:36:41 <roboguy`> Paprikachu: with "foldl (:) []", look at which argument the [] will be passed as
19:36:47 <monochrom> And what's the relevance of GHC?
19:38:29 <monochrom> And hugs doesn't have Data.Foldable.
19:38:43 <Paprikachu> seriously?
19:38:47 <Welkin> so just do it old school
19:38:53 <Welkin> and write the function directly
19:38:53 <Paprikachu> ._.
19:38:58 <monochrom> I was there when hugs was popular.
19:38:58 <Welkin> like I showed before
19:39:22 <Welkin> I used Seq to do this `inOrder (Bin k left right) = inOrder left >< SQ.singleton k >< inOrder right`
19:39:41 <Paprikachu> why are we supposed to use hugs anyway
19:39:47 <Paprikachu> this is stupid.
19:39:47 <Welkin> for lists it would be (++) and [k]
19:39:52 <Welkin> lol Paprikachu no idea
19:39:55 <Welkin> is this for a class?
19:39:55 <monochrom> I don't know. Not my problem.
19:39:58 <Paprikachu> yeah
19:40:00 <Welkin> Hugs is dead
19:40:37 <Paprikachu> i just wanna write proper haskell and not this crap
19:40:57 <monochrom> I only know that there is a shitload of logical contradictions among the requirement "use hugs, and have Data.Foldable, and make ideone happy"
19:41:08 <Paprikachu> monochrom: what is your purpose?
19:41:24 <monochrom> To make you disappear in a poof of logic?
19:41:35 <Paprikachu> ok, experiment failed
19:41:36 <Welkin> @let data Tree a = Empty | Bin a (Tree a) (Tree a)
19:41:37 <lambdabot>  .L.hs:178:22: error:
19:41:37 <lambdabot>      Ambiguous occurrence ‘Tree’
19:41:37 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
19:41:54 <Welkin> @let data BinTree a = BinEmpty | Bin a (BinTree a) (BinTree a)
19:41:56 <lambdabot>  Defined.
19:42:08 <Welkin> @let inOrder BinEmpty = []; inOrder (Bin k left right) = inOrder left ++ [k] ++ inOrder right
19:42:09 <lambdabot>  Defined.
19:42:45 <Welkin> inOrder (Bin 3 (Bin 4 BinEmpty (Bin 4 BinEmpty BinEmpty)) (Bin 5 BinEmpty BinEmpty))
19:42:48 <Welkin> > inOrder (Bin 3 (Bin 4 BinEmpty (Bin 4 BinEmpty BinEmpty)) (Bin 5 BinEmpty BinEmpty))
19:42:50 <lambdabot>  [4,4,3,5]
19:43:29 <Paprikachu> Welkin: i know how to write it this way, i just wanted to be clever about it..
19:43:38 <Paprikachu> did i mention i hate hugs
19:45:52 <Paprikachu> does anyone write 'literal haskell scripts' in practise?
19:45:59 <Welkin> yes
19:46:08 <Welkin> usually when you want to write it as a teaching tool
19:46:11 <Welkin> like a tutorial
19:46:24 <Welkin> or if you have far more comments than code
19:46:25 <Paprikachu> 'cause i'm supposed to submit it as such and it's annoying
19:47:16 <nitrix> As much as it must be really annoying for teachers to update the material; I for one, am very pleased by Haskell's evolution.
19:47:54 <kwantam> Surely there is something to the notion that one can learn how the machinery is built before stuffing it all under the hood...
19:47:55 <Welkin> lol nitrix 
19:47:58 <Welkin> it is funny actually
19:48:25 <Welkin> there was some professor who was fueding with bitemyapp, gabriel, jle`, and others on twitter
19:48:25 <Paprikachu> so if hugs doesn't have Data.Foldable
19:48:29 <Paprikachu> how/where is it defined?
19:48:36 <Welkin> and sayin that haskell should be more like SML
19:48:46 <Welkin> an should not use typeclasses
19:49:11 <kwantam> Harper is, depending who you ask, either a hero or a known crazy who should be ignored
19:50:09 <kwantam> (the truth, of course, is neither... but extremism is cool)
19:50:38 <monochrom> I actually have doubt that "foldl (:) []" type-checks, regardless of compiler or library versions.
19:50:57 <Welkin> :t foldl (flip (:)) []
19:50:58 <lambdabot> Foldable t => t a -> [a]
19:51:19 <nitrix> Or foldr.
19:51:31 <Welkin> you mean in Hugs?
19:51:36 <monochrom> yeah, if anything, you have to use flip(:) instead
19:51:57 <Welkin> > foldl (flip (:)) [] [1..5]
19:51:57 <roboguy`> nitrix: foldr (:) [] is ok. it's a nop
19:52:00 <lambdabot>  [5,4,3,2,1]
19:52:13 <Welkin> > foldr (:) [] [1..5]
19:52:16 <lambdabot>  [1,2,3,4,5]
19:52:34 <Welkin> > foldl (++) [] [1..5]
19:52:36 <lambdabot>  error:
19:52:36 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M485808840313...
19:52:36 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
19:52:46 <roboguy`> kwantam: well, I certainly wouldn't go so far as to say he is crazy and should be ignored. I disagree with him on several things (especially related to Haskell), but he's a smart guy
19:52:55 <roboguy`> there's a middle ground
19:53:05 <Welkin> > foldl ((++) . pure) [] [1..5]
19:53:07 <lambdabot>  error:
19:53:08 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
19:53:08 <lambdabot>        Expected type: [a] -> [a] -> [a]
19:53:16 <monochrom> I have just tried both hugs's ancient foldl and lambdabot's modern foldl
19:54:08 <Welkin> > foldl (\acc x -> acc ++ pure x) [] [1..5]
19:54:10 <lambdabot>  [1,2,3,4,5]
19:54:18 <monochrom> and yeah I agree with Harper on several points and disagree on several others
19:54:45 <monochrom> and agnostic on several yet others
19:56:26 <tnks> so, it dawned on me that maybe I could use the same hs-source-dirs for both my library and each of my executables?
19:56:36 <tnks> is this a bad idea?
19:56:42 <tnks> or does it not work?
19:56:43 <ezyang> tnks: Yes, but then shared files will be rebuilt multiple times 
19:57:08 <tnks> ezyang: ah, well then that's motivation not to do it.
19:57:37 <ezyang> it is occasionally useful, mostly when you have modules you don't want to export, but you want the test to use them 
19:57:50 <ezyang> if you run cabal HEAD you can use a private library equivalently 
19:58:35 <tnks> ezyang: interesting (regarding tests)
19:58:36 <Welkin> @pl \acc x -> acc ++ pure x
19:58:36 <lambdabot> (. pure) . (++)
19:58:40 <Welkin> ew
20:17:37 <kwantam> roboguy`: 100% agree, hence my follow-up :)
20:47:42 <jle`> was i involved in a twitter feud?
21:44:06 <slack1256> I want to do a haskell script where my host is linux and will run on windows. Is is possible and is it easy?
21:44:36 <Koterpillar> yes; no; what you are thinking of is called "cross-compiling"
21:45:24 <Paprikachu> turns out, hugs does support Data.Foldable
21:45:34 <slack1256> I thought cross-compilation was about different computer architectures....
21:45:36 <Paprikachu> so i made my flatten work with that
21:45:58 <MarcelineVQ> it depends what you mean by script and run, use as much detail as you used in offtopic :>
21:46:35 <slack1256> Better question. If I compile my script on a windows WM. I can I make it statically linked everything such that I can give the binary to a friend and he just runs it?
21:48:26 <slack1256> Basically we have a program written on AMPL for optimization, we need to run it on different problem sizes and plot them. I want to script this in haskell and have to worry about the lack of printf in cmd.exe
21:48:37 <slack1256> *and not have to 
21:48:51 <slack1256> yet my friend uses windows
21:50:17 <Koterpillar> slack1256: you can use http://dependencywalker.com/ to find out
21:51:17 <Koterpillar> slack1256: https://www.reddit.com/r/haskell/comments/4shcin/whats_the_best_way_to_create_prebuilt_binaries_of/
21:51:27 * slack1256 realizes you don't have ldd on win by default
21:53:33 <AbelianGrape> There's a library I want to use in my Stack project, but the code for the library is slightly out of date and needs to be fixed up a tiny bit (typeclass stuff). If I git-clone and fix the library, how do I tell stack to build and include it?
21:54:00 <lambdacat> Under packages: in your stack.yaml.
21:54:08 <Koterpillar> AbelianGrape: you can include the path (local or remote) for the library in extra-deps
21:54:34 <lambdacat> You can add the path to the local copy (to the directory containing the .cabal file).
21:54:49 <kadoban> You can also reference it as a specific commit in a git repo, which is helpful if other people will be using it.
21:55:02 <Koterpillar> I think you even have to
21:55:37 <MarcelineVQ> you at least have to when you're fetching from a remote
21:56:05 <AbelianGrape> lambdacat: Koterpillar: Is packages or extra-deps preferred?
21:56:45 <Koterpillar> depends on whether the library is developed together with your thing or not
21:56:53 <AbelianGrape> No, it's a separate library
21:57:17 <AbelianGrape> I think it's just pre-AMP code, so I have to add some extra deriving clauses
21:57:40 <Koterpillar> then I'd say extra-dep
21:57:42 <lambdacat> If it’s something in stack, you probably will need to use extra-deps.
21:58:06 <AbelianGrape> What's the syntax for adding a path to extra-deps?
21:58:08 <MarcelineVQ> I've used packages for that previously, but tagged it as extra-dep :> which is just  `extra-dep: true` under the relevant `- location: ` section in packages
21:58:09 <lambdacat> If it’s a local package you’re developing that you want to reference, packages.
21:59:21 <Koterpillar> AbelianGrape: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
21:59:35 <lpaste> MarcelineVQ pasted “example of a previous use” at http://lpaste.net/339575
22:00:06 <lambdacat> For extra-deps you can reference the library like you would in your cabal file.
22:00:21 <lambdacat> For example, I’m using it for a GHCJS project
22:00:25 <lambdacat> That has - react-flux-1.2.3
22:00:33 <lambdacat> as its value
22:01:34 <lambdacat> MarcelineVQ also mentioned another way you can do it, in packages, but with the extra flag.
22:02:14 <Koterpillar> it's always in packages, and the difference is "extra-dep: true"
22:03:54 <AbelianGrape> Here's what I have in stack.yaml:
22:03:54 <AbelianGrape> packages:
22:03:54 <AbelianGrape> - location: '.'
22:03:55 <AbelianGrape> - location: 'lib/filemanip' extra-dep: true
22:04:12 <AbelianGrape> There's a newline between those last two, not sure why it didn't paste
22:04:27 <AbelianGrape> anyway, "stack build" doesn't seem to be building filemanip
22:04:44 <Koterpillar> you have to depend on it
22:04:51 <AbelianGrape> extra-deps: [heist-1.0.1.0, map-syntax-0.2.0.1, filemanip-0.3.6.3]
22:05:09 <Koterpillar> and in whatever.cabal?
22:05:19 <AbelianGrape> d'oh
22:05:37 <kadoban> AbelianGrape: It should not also be in extra-deps, only in the other part.
22:05:44 <Koterpillar> ^
22:07:35 <AbelianGrape> Thanks!
22:08:35 <AbelianGrape> Do you guys know why when I build with cabal or stack, I have to double-indent under a "let" binding in a "do" block, but not if I use ghc?
22:09:06 <EvanR> i think you are experiencing something else
22:09:22 <EvanR> like you changed the variable name in the process, which determines how far you need to indent
22:11:24 <kadoban> The only possible parsing difference would be if they were using different versions of GHC or something, but even that seems quite unlikely.
22:11:31 <AbelianGrape> EvanR: No, this constantly bothers me when I switch from GHC to Cabal
22:11:49 <EvanR> lpaste the offending code
22:11:57 <AbelianGrape> just closed it, one sec
22:13:34 <AbelianGrape> http://lpaste.net/339579
22:13:50 <AbelianGrape> That's fine with ghc, but cabal or stack makes me put another indent on y and z
22:14:32 <AbelianGrape> My guess is it's something to do with specifying Haskell 2010 on the command line versus not specifying anything
22:15:50 <MarcelineVQ> well what are the relevant lines you're entering in the shell to do each
22:16:41 <AbelianGrape> MarcelineVQ: "ghc Main.hs" versus "stack build"
22:16:56 <AbelianGrape> it's hard to post my exact situation because it's an entire project
22:17:11 <AbelianGrape> Anyway, it's building now, so thanks for the help y'all
22:24:47 <EvanR> yep still skeptical
22:45:30 <jle`> the secrets of this mystery will be lost in the sands of time
22:45:49 <jle`> hello future readers of #haskell chat logs
22:54:17 * hackagebot egison 3.6.2 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.6.2 (SatoshiEgi)
23:34:18 * hackagebot egison-tutorial 3.6.2 - A tutorial program for the Egison programming language  https://hackage.haskell.org/package/egison-tutorial-3.6.2 (SatoshiEgi)
23:58:32 <lpaste> kirillow pasted “QuickCheck First'” at http://lpaste.net/4885608780479332352
