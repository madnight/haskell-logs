00:41:54 <cheater> [1000] >>= return [1..5]
00:42:00 <cheater> > [1000] >>= return [1..5]
00:42:03 <lambdabot>  [1,2,3,4,5]
00:42:33 <cheater> see what it does? the elements of the list on the left don't matter, just the holes they leave behind.
01:00:20 <jle`> that's...a really weird way to use return
01:00:30 <jle`> you're using it as const basically
01:00:38 <jle`> but to see it next to >>= is confusing, heh
01:01:12 <jle`> > [1000] >>= \_ -> [1..5]
01:01:15 <lambdabot>  [1,2,3,4,5]
01:03:28 <maerwald> @hoogle for
01:03:32 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
01:03:32 <lambdabot> Text.Blaze.Html4.FrameSet.Attributes for :: AttributeValue -> Attribute
01:03:32 <lambdabot> Text.Blaze.Html4.Strict.Attributes for :: AttributeValue -> Attribute
01:04:54 <maerwald> boring... anyone has a complete replica of imperative for-loop? This is what I would quickly come up with https://git.io/vXCpC
01:05:01 <maerwald> but doesn't feel right yet
01:06:28 <maerwald> stuff that's missing: 1. initializer can be a list of stuff, 2. the body must be able to mutate the loop state, 3...
01:11:06 <jle`> maybe the body can be (a -> IO a) ?
01:11:39 <jle`> also as you have it now, it should work for all Applicative f
01:11:49 <jle`> if you allow the body to mutate the loop state then it has to be Monad m
01:12:02 <jle`> but if not, what you wrote is polymorphic over all Applicative's
01:12:23 <maerwald> I don't care about abstraction at this point, only about integrity
01:12:39 <maerwald> might as well use IORefs all over the place
01:13:00 <jle`> using IORefs directly would be the most faithful translation
01:13:16 <jle`> but i think if you modified your (a -> IO ()) to be (a -> IO a), that'd work too
01:14:34 <jle`> in an imperative language for loop, the condition may involve IO
01:14:41 <jle`> and so might the incrementor
01:15:01 <jle`> actually the incrementor isn't even an (a -> a), it's a stateful mutation
01:19:06 <jle`> maerwald: commented with my interpretation
01:20:15 <maerwald> I was trying to go for: for :: Num a => IORef [a] -> (IORef [a] -> IO Bool) -> (IORef [a] -> IO ()) -> (IORef [a] -> IO ()) -> IO ()
01:20:55 <maerwald> but it would in fact have to be a polymorphic list
01:22:06 <maerwald> funny is that incrementor and body have the same type
01:23:56 <jle`> actually, the initializer, incrementor, and body all have the same type in an imperative for loop
01:24:04 <jle`> they're all IO ()
01:24:09 <jle`> (if you could meaningfully assign a type)
01:24:59 <jle`> so i commented a more faithful way, for :: IORef a -> (IORef a -> IO ()) -> (IORef a -> IO Bool) -> (IORef a -> IO ()) -> (IORef a -> IO ()) -> IO (), similar to what you wrote, yeah
01:25:17 <maerwald> this is going a funny way :D
01:25:37 <jle`> not sure why you need a Num a or [a]
01:25:51 <maerwald> well, probably not
01:26:21 <jle`> yeah, the initialiser should be IORef a -> IO ()
01:26:34 <jle`> because the initializer can perform arbitrary side-effects
01:27:05 <jle`> this is close to the block described in this reference -- http://www.w3schools.com/js/js_loop_for.asp
01:27:14 <jle`> for (statement 1, statement 2, statement 3) { statement 4; }
01:27:30 <jle`> s/statement 4/body
01:28:11 <jle`> the initializer and incrementor don't have to initialize or increment in js, they're just arbitrary statements
01:28:11 <arzav> hi
01:28:28 <jle`> the only difference is the order/number of times in whcih they are executed
01:28:30 <jle`> arzav: hi!
01:28:56 <maerwald> jle`: this is moer accurate https://github.com/SonarSource/sonar-java/blob/master/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/ForStatementTree.java#L31
01:29:50 <jle`> hm, yeah, this seems to be similar to the first reference.  take three statements and a body
01:30:13 <maerwald> well, initializer and update are lists of statements
01:30:27 <jle`> sure, and IO () can represent a list of statements
01:30:36 <jle`> you can provide [IO ()] but you're just going to sequence it anyways
01:31:07 <jle`> if you take a list of statements [IO ()], you're oging to immediately sequence_ :: [IO ()] -> IO () anyway, so it's not too different
01:31:24 <arzav> h
01:31:51 <sbrg> Anyone happen to know the default location for .ghci(or equivalent) on Windows? Don't have access to a windows machine but need to know.
01:31:59 <jle`> but yeah, the initializer, updator, and body all have the same type; the condition is also a statement/list of statements, but is understood to return Bool
01:32:12 <jchia1> So, a few hours ago I was asking about catching signals (particularly SIGINT) and throwing exceptions. The regular (seemingly to me) approach of just throwing an IOException from the signal handler didn't work. Meanwhile, my main thread was blocking in waitForProcess. After the discussion and reading http://blog.ezyang.com/2010/08/interrupting-ghc/ , I did some experiments and it turns out that throwing to the main thread using throwTo works, it least in my 
01:32:40 <maerwald> and the condition is not a statement, but an expressiontree that evaluates to a boolean primitive
01:33:08 <maerwald> but yeah, the type signature looks fine so far
01:33:30 <jle`> hm
01:34:20 <maerwald> the problem here is, what the java AST allows doesn't mean the type checker allows
01:34:23 <jle`> the condition can do arbitrary IO and depend on global state, so .. -> IO Bool is probably the moth faithful way to reproduce it
01:34:37 <jle`> s/moth/most
01:35:56 <Cale> jle`: Your secret worship of moths is safe with us.
01:36:05 <maerwald> lol
01:36:13 <jle`> all hail the moth-faithful
01:36:27 <maerwald> only 1480 ppl witnessed your secret
01:37:04 <jle`> :p
01:37:21 <chrissound> Does anyone know a nice way of "printing" Nodes / Cursors from Text.XML? Relating to the xml-conduit package
01:38:02 <chrissound> So ideally I'm looking to print the content / attributes of a node and it's children (1 level deep).
01:39:54 <maerwald> jle`: doesn't make much sense to duplicate the IORef a argument though, does it? 
01:41:27 <Cale> chrissound: Which of the XML packages is that?
01:41:46 <Cale> chrissound: xml-conduit?
01:48:11 <chrissound> Cale: Yes xml-conduit
01:50:23 <maerwald> jle`: because the way you use it, you're in IO anyway and can pass the initial IORef to any of the loop part, so a type signature: for :: IORef a -> IO () -> IO Bool -> IO () -> IO () -> IO () -- might actually make sense
01:53:53 <maerwald> that might make it more awkward to use functionally though
01:54:05 <maerwald> but hey, it isn't anyway :P
01:54:25 <Cale> If you have that many arguments, make a record type to organise them
01:54:36 <maerwald> why
01:54:47 <Cale> So you don't get them the wrong way around :)
01:55:36 <Cale> chrissound: hmm -- it does seem like this cursor stuff ought to make it reasonable to extract the names of elements along an axis or something
01:56:09 <maerwald> Cale: that's not very imperative though
01:56:31 <Cale> Perhaps I'm missing some context :)
01:57:12 <maerwald> I was trying to replicate imperative for loops as close as possible (with the body, condition and incrementor having access to the loop state etc)
01:58:03 <maerwald> this is what jle and me have come up with https://git.io/vXCpC
01:58:13 <chrissound> Cale: It does seem simple enough yes, just thought I'd ask in the chance something is out there. 
01:59:27 <Cale> chrissound: Or I wonder if a good approach would actually be to delete all the children of the children, and replace them with text nodes ("..."), hmm
01:59:41 <Cale> (and then render the resulting document)
02:01:04 <maerwald> Cale: and that for-definition is also a pretty good argument for showing people the alternative traversable/monadic "equivalent" functions and why the imperative approach is rather awkward
02:01:28 <maerwald> because I guess most people don't realize how bad imperative for loops actually are
02:01:34 <Cale> ahh, okay
02:02:40 <Cale> But I think this also isn't quite faithful -- the imperative for loop isn't really parameterised over an IORef...
02:02:51 <Cale> (or anything like a specific mutable variable)
02:02:57 <maerwald> yeah, it's more like you have a whole environment
02:03:15 <Cale> Perhaps have the init produce a result which is available to the following parts?
02:03:18 <chrissound> Hmm interesting approach. I've already got a basic command line printer though so will probably stick with it for now. Thank you!
02:03:34 <maerwald> Cale: that's what I did first and we didn't think it's faithful :P
02:03:50 <Cale> heh
02:03:53 * hackagebot concurrent-split 0.0.1 - MVars and Channels with distinguished input and output side  https://hackage.haskell.org/package/concurrent-split-0.0.1 (HenningThielemann)
02:03:56 <maerwald> because we don't really pass stuff around, but mutate stuff in-place
02:04:11 <Cale> I mean, you'd create an IORef there, usually
02:04:22 <maerwald> I think this would actually boil down to a monad transformer with state inside IO
02:04:26 <Cale> and then do stuff with that IORef in the subsequent bits
02:04:57 <maerwald> ah, you mean the init thing is "IO (IORef a)"?
02:05:18 <Cale> Yeah, there's no need to specifically require it to be an IORef
02:05:36 <maerwald> that's a point
02:05:39 <Cale> But whatever it produces gets passed along
02:05:53 <maerwald> however... the ini can also be empty in an imperative for loop
02:05:56 <maerwald> *init
02:06:01 <Cale> (simulating the fact that things defined in that part in C are in scope later on)
02:06:07 <maerwald> but I still want to be able to pass "environment" to the for loop
02:06:20 <Cale> Well, the environment is accessible regardless
02:06:25 <maerwald> but I guess that's what can I implicitly assume from it being in IO
02:07:23 <maerwald> however, from an AST point of view, the init isn't an expression, it's just a statement
02:08:12 <Cale> Right, well, we can't really get away from translating it into something that will be an expression in Haskell I think
02:08:35 <Cale> The real question is, can you define new things in the cond and incr part, and how does the scope work if you do?
02:08:48 <maerwald> I think the most faithful thing is just: for :: IO () -> IO Bool -> IO () -> IO () -> IO () -- init, cond, incr, body
02:08:57 <Cale> and is anything defined in the body available in the incr?
02:09:23 <maerwald> so we more or less translate the AST into haskell types and don't care about environmental stuff or input parameters
02:09:29 <maerwald> the user can do that in IO manually
02:12:50 <maerwald> everything else is usability stuff
02:13:12 <Cale> Well, how does the scope work in C if I try to declare something inside the cond part?
02:13:32 <Cale> (or inside the incr part)
02:13:53 * hackagebot stm-split 0.0.1 - TMVars, TVars and TChans with distinguished input and output side  https://hackage.haskell.org/package/stm-split-0.0.1 (HenningThielemann)
02:13:55 <Cale> It's been long enough since I cared about languages which have a loop like this that I forget those details.
02:16:03 <maerwald> in java, I'm unable to declare something in the condition, because it's an expressiontree, not a statement
02:17:18 <maerwald> so it can be just "true" or a random function that returns true or some binary operator
02:17:54 <lpaste> Cale pasted “Perhaps this?” at http://lpaste.net/328613
02:18:41 <Cale> We *could* make something defined in the cond available to the body though.
02:18:45 <maerwald> well, there we represent cond, incr and body as functions with input parameters
02:18:47 <Cale> Because that has to run first.
02:19:07 <Cale> Yeah, I'm assuming here that a and b are potentially IORefs or ()
02:19:52 <Cale> Note that the 'a' which is produced in begin doesn't ever actually change afterward
02:20:03 <Cale> So it needs to be an IORef if it's going to be updated
02:20:29 <maerwald> but from a scope point of view, it makes more sense
02:20:34 <Vyn> a____ptr
02:20:35 <Vyn> > map (\n -> sum [(-1)^i * (n - i) | i <- [0..n]]) [1..10]
02:20:36 <Cale> That is indeed a little silly, but it's the same kind of silly as it is in C
02:20:38 <lambdabot>  [1,1,2,2,3,3,4,4,5,5]
02:21:05 <Vyn> > map (\n -> sum [(-1)^i * (n - i)^2 | i <- [0..n]]) [1..10]
02:21:07 <Vyn> Right
02:21:08 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
02:21:09 <Cale> (silly because we could always pull that out and put it before the for loop)
02:21:51 <maerwald> so we basically abuse the IO "output" as scope handler
02:22:10 <Cale> yeah
02:22:50 <bollu> this is kinda off-topic, but I'll be spending the next 6 months (from january) at ETH. Is there some sort of functional programming community there?
02:22:55 <bollu> or HoTT
02:22:56 <maerwald> the alternative would probably be some weird transformer/mtl thing, which might be worse
02:23:04 <bollu> I want to take some time during the internship and study
02:23:10 <Cale> I'm not sure about the 'b' in the thing I pasted
02:23:27 <bollu> so, well, does anyone know of such a community / course / people at ETH?
02:23:36 <Cale> Like, if we define new things in the body, are they available to the immediately subsequent incr?
02:23:55 <Cale> (and then get trashed by the next iteration)
02:24:02 <maerwald> Cale: nope, only if they are defined beforehand
02:24:14 <Cale> ah, okay, so we could drop that for a closer simulation
02:24:36 <a____ptr> Vyn: it works now?
02:24:50 <Vyn> Yes, it does
02:24:56 <a____ptr> Cool
02:25:49 <Cale> (though I do kind of like that the extra type parameter makes it slightly clearer what's going on)
02:26:18 <Cale> Though I suppose, making it clear what's going on isn't the goal if we're trying to reproduce C's for loop :P
02:26:30 <maerwald> haha
02:27:00 <maerwald> Cale: now we are actually close to what we had before, except that instead of 'a' we were using "IORef a"
02:27:57 <maerwald> and because we wanted to make in-place mutation explicit, we used IORef I guess
02:28:01 <maerwald> now it's sort of implicit
02:29:39 <maerwald> for :: IO a -> (a -> IO Bool) -> (a -> IO ()) -> (a -> IO ()) -> IO ()
02:29:39 <maerwald> vs
02:29:39 <maerwald> for :: IO (IORef a) -> (IORef a -> IO Bool) -> (IORef a -> IO ()) -> (IORef a -> IO ()) -> IO ()
02:30:45 <Cale> So with the new one, like with C, we can neglect to define anything in the begin part
02:30:53 <maerwald> I guess you could argue that one can work with final/const/static/whatever-the-language things, so IORef can't be assumed
02:31:22 <Cale> and instead just put  return ()  there to simulate the cases in C where it gets left blank
02:31:34 <maerwald> yeah
02:31:58 <Cale> Or I suppose we could define multiple things... though I don't think I've ever seen someone do that in C.
02:32:02 <maerwald> I doubt anyone will understand that when I explain that in a presentation lol
02:32:29 <maerwald> but it's still useful for a comparison
02:32:37 <Cale> actually, is that possible? Can you separate variable declarations with comma or something in C?
02:33:02 <maerwald> yeah
02:33:14 <maerwald> int x = 3, z = 5;
02:33:27 <Cale> ah, like that
02:33:36 <Cale> I was thinking like  int x = 3, char z = 5;
02:33:43 <Cale> They're not expressions though
02:33:46 <Cale> I think
02:33:59 <maerwald> lists of statements
02:34:10 <Cale> Oh, maybe with braces?
02:34:16 <maerwald> https://github.com/SonarSource/sonar-java/blob/master/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/ForStatementTree.java#L31
02:34:20 <Cale> er, no, that wouldn't do
02:34:28 <maerwald>   ListTree<StatementTree> initializer();
02:34:31 <maerwald> whatever that actually is
02:34:48 <maerwald> I think we are close enough though, aren't we?
02:35:03 <maerwald> IO sort of implies a list of statements
02:35:34 <bollu> maerwald: what about non-sequential code?
02:35:46 <maerwald> screw it
02:36:43 <Cale> Yeah, we're close enough
02:36:53 <Cale> It's just we overshot slightly
02:37:12 <Cale> In that we can put something like  liftM2 (,) (newIORef 0) (newIORef 'a')
02:37:19 <Cale> into the begin part :)
02:37:30 <maerwald> yep
02:37:34 <maerwald> I did that in my example
02:37:50 <maerwald> functionality-wise it's already complete this way
02:38:04 <maerwald> anything else is equivalence or usability tweaking
02:41:55 <maerwald> https://git.io/vXWT6 so this would be it
02:43:11 <lpaste> Cale revised “Perhaps this?”: “Haha, let's go all-out” at http://lpaste.net/328613
02:43:34 <maerwald> oh noes, I triggered Cale :P
02:44:25 <maerwald> now you're pretty close to C in the sense that's not really clear anymore what input and output parameters are actually for :P
02:44:54 <Cale> Well, now the order in which stuff gets run is made clearer by the typed
02:44:56 <Cale> types*
02:46:36 <maerwald> I think this experiment could be documented in the haskell wiki, actually 
02:46:44 <Cale> Like, you start out with nothing, so all you can do is to run the begin part, and that gets you an 'a', so you can't run the body or incr yet, but you can run the cond part
02:47:04 <Cale> and then running the cond part gets you a 'b' (along with the boolean result)
02:47:17 <Cale> and that lets you run the body to get a 'c' and that finally lets you run incr
03:30:12 <grantwu> I'm a bit late to the discussion, but you can elaborate for loops to a statement + a while loop, right?
03:33:27 <ineb> i dont understand, why this line works: echoes = foldr (\ x xs -> (replicate x x) ++ xs) [] 
03:33:48 <ineb> foldr is defined as (a -> b -> b) -> b -> [a] -> b, but all i can see here is giving it a function and an empty list
03:34:59 <grantwu> Because of partial application
03:35:27 <ineb> ahh
03:37:11 <ineb> so, first argument is the anonymous function, second one is [] start value und third argument is, whatever echoes takes. that makes sense
03:40:05 <NickHu> grantwu: For loops are equivalent to while loops, yeah
03:40:26 <grantwu> The first argument doesn't need to be anonymous
03:40:27 <NickHu> I'm not sure that it has anything to do with partial application so much as a for loop is generally sugar around a while loop
03:41:42 <grantwu> I was responding to ineb
03:42:01 <grantwu> With regards to partial application
03:46:15 <dreamspy> Morning. Is this the proper place to receive newbie help for Haskell?
03:49:11 <srhb> dreamspy: Among other places, yes! :-) And welcome.
03:49:32 <dreamspy> Great. Thanks :) I’ll be lurking around here for a while then!
03:49:56 <srhb> dreamspy: There's also #haskell-beginners if this channel is very busy (which it is, occasionally)
03:50:02 <srhb> dreamspy: And feel free to lurk :-)
03:50:39 <dreamspy> Ahh I’ll check that out as-well. Thanks!
04:44:01 * hackagebot haskell-tools-ast 0.3.0.1 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-0.3.0.1 (lazac)
04:44:03 * hackagebot haskell-tools-backend-ghc 0.3.0.1 - Creating the Haskell-Tools AST from GHC's representations  https://hackage.haskell.org/package/haskell-tools-backend-ghc-0.3.0.1 (lazac)
04:44:05 * hackagebot haskell-tools-prettyprint 0.3.0.1 - Pretty printing of Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-prettyprint-0.3.0.1 (lazac)
04:44:07 * hackagebot haskell-tools-rewrite 0.3.0.1 - Facilities for generating new parts of the Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-rewrite-0.3.0.1 (lazac)
04:44:09 * hackagebot haskell-tools-refactor 0.3.0.1 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-refactor-0.3.0.1 (lazac)
04:49:11 * hackagebot haskell-tools-cli 0.3.0.1 - Command-line frontend for Haskell-tools Refact  https://hackage.haskell.org/package/haskell-tools-cli-0.3.0.1 (lazac)
04:49:13 * hackagebot haskell-tools-demo 0.3.0.1 - A web-based demo for Haskell-tools Refactor.  https://hackage.haskell.org/package/haskell-tools-demo-0.3.0.1 (lazac)
04:50:57 <xpika> Is it possible to parse an argument without a corresponding flag using optparse applicative? I tried creating a parser using mempty but I got 'invalid argument'.
04:53:30 <lyxia> xpika: "argument"? http://hackage.haskell.org/package/optparse-applicative-0.13.0.0/docs/Options-Applicative-Builder.html#v:argument
05:07:56 <xpika> lyxia: That worked but it looks like a bug
05:15:38 <lyxia> what does
05:16:55 <lyxia> xpika: What did you try?
05:21:07 <xpika> lyxia: strOption mempty
05:22:26 <merijn> xpika: You mean you just want positional arguments? i.e. "./foo bar baz" and get "bar" and "baz"?
05:22:43 <lyxia> it's part of the deifinition of an option that it should have a flag name
05:23:07 <merijn> lyxia: Options have flag names, but options are not arguments
05:23:26 <merijn> If he wants *arguments* to the command you need strArgument
05:23:53 <merijn> Normally, if you want, say, a list of file arguments to a command you'd finish your parser with
05:24:25 <merijn> many (strArgument (metavar "FILES" <> help "Files to open"))
05:25:30 <xpika> merijn: lyxia: ah I see thanks
05:27:41 <xpika> merijn: lyxia: it still looks like undesired behavior because using strOption mempty adds to the help but strArgument does not
05:30:21 <pavonia> What does "Create a mutable vector of the given length. The length is not checked." mean for Data.Vector.Mutable.unsafeNew? How does it check or not check then length when creating a new vector?
05:31:25 <merijn> pavonia: Writing elements doesn't check for out of bound
05:31:54 <Adeon> I guess you can call unsafeNew with negative length maybe?
05:32:07 <pavonia> merijn: But that's wat unsafeWrite does, no?
05:32:23 <pavonia> Adeon: Ah, that would make sense
05:32:27 <merijn> oh, actually, I guess Adeon might be on to something
05:37:27 <kirillow> If I have a list `[a1,a2,a3]` where a1,a2,a3 are of type `A { name :: String, value :: Int }`, how do I return the item with the highes `value` from the list?
05:41:22 <zaquest> kirillow, maximumBy (compare `on` value) xs, where `maximumBy` is from Data.List and `on` is from Data.Function
05:41:33 <lyxia> :t maximumBy . comparing
05:41:35 <lambdabot> (Foldable t, Ord a) => (b -> a) -> t b -> b
05:49:05 * hackagebot grid 7.8.7 - Tools for working with regular grids (graphs, lattices).  https://hackage.haskell.org/package/grid-7.8.7 (AmyDeBuitleir)
06:14:54 <kuribas> :t map
06:14:55 <lambdabot> (a -> b) -> [a] -> [b]
06:15:11 <kuribas> @hoogle [a] -> (a -> b) -> [b]
06:15:14 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:15:14 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:15:14 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
06:19:07 * hackagebot gray-extended 1.5.2 - Gray encoding schemes  https://hackage.haskell.org/package/gray-extended-1.5.2 (AmyDeBuitleir)
06:42:16 <nesqi> Is meaningfull to use Except from Control.Monad.Trans.Except even though I'm not transforming any monads or should I just use Either instead?
06:44:11 <lyxia> Just use Either
06:46:12 <nesqi> Yeah... I think I get it now.
06:46:34 <nesqi> If not used as a transform it only adds bulk.
06:46:42 <nesqi> Thanks for your answer.
06:49:28 <kuribas> How do I tell haddock not to document hidden modules?
07:08:10 <kuribas> Is it better to use Vector instead of Array?
07:09:10 * hackagebot serokell-util 0.1.1 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.1.1 (jagajaga)
07:11:14 <Squarism> what is the "goto" http client?
07:11:50 <lyxia> wreq?
07:14:10 * hackagebot serokell-util 0.1.1.1 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.1.1.1 (jagajaga)
07:14:12 * hackagebot mathexpr 0.2.0.0 - Parse and evaluate math expressions with variables and functions  https://hackage.haskell.org/package/mathexpr-0.2.0.0 (mdibaiee)
07:16:20 <hexagoxel> kuribas: just hide your modules better! in seriousness, in what way are you hiding the modules currently?
07:16:51 <kuribas> hexagoxel: they are not exposed in cabal
07:18:32 <merijn> Out of curiosity, should Alternative.empty == MonadPlus.mzero?
07:19:07 <hexagoxel> kuribas: there is `{-# OPTIONS_HADDOCK hide #-}`, although i observe that a module in other-modules does not show up in the docs already.
07:19:53 <byorgey> merijn: I would expect so, for types with both instances
07:19:59 <lyxia> merijn: I would say MonadPlus = Alternative + Monad, is that not the case?
07:20:36 <merijn> lyxia: Documentation doesn't mention it
07:20:47 <fryguybob> ezyang: I don't know if anyone answered your question, but there is this: https://hackage.haskell.org/package/diagrams-graphviz
07:20:50 <kuribas> hexagoxel: ah other-modules is what I need, thanks!
07:21:04 <merijn> byorgey: Then why does mzero still exist inside MonadPlus?
07:21:18 <merijn> byorgey: Or is the plan to delete it like return?
07:21:22 <byorgey> hysterical raisins.  Why does return still exist inside Monad?
07:21:46 <merijn> byorgey: Right
07:21:58 <byorgey> I don't know specifically if there are plans to do this with MonadPlus.  I'm not sure there is enough agreement about what the laws for Alternative/MonadPlus should be
07:22:04 <merijn> byorgey: Sounds like I should file a ticket to document that empty = mzero
07:22:18 <byorgey> sure, can't hurt
07:22:40 <byorgey> fryguybob: what question did ezyang ask?  I missed it
07:23:00 <byorgey> oh, I see it now
07:29:39 <fryguybob> byorgey: I can only imagine he is making some thing amazing :D
08:14:13 * hackagebot glabrous 0.1.3.0 - A template DSL library  https://hackage.haskell.org/package/glabrous-0.1.3.0 (MichelBoucey)
08:23:23 <Thignsome> If I have a bunch of methods with type `(Monad m) => m (Either a b)`, where the `a` types are different, what's the best way to group these into a single ExceptT monad. Right now it seems I need to prepend each operation with `(withExceptT (const Error) . Except)`
08:23:35 <Thignsome> But it feels clunky
08:23:42 <blah012> is it possible to enable/disable the existence of a test suite with a flag, so that i can run e.g. "stack test" or "stack test --flag mypackage:myflag" and get different results?
08:23:56 <blah012> i'd like to hide my integration test suite under a flag
08:25:23 <blah012> Thignsome: make your 'a' a sum type with different constructors for different kinds of errors
08:25:58 <Thignsome> blah012, these come from distinct libraries where I don't really care about the return type, I just want to unify the response into my own singleton "Error" constant
08:26:43 <blah012> Thignsome: then "withExceptT (const Error) . Except" is the way to go ;)
08:27:47 <Thignsome> blah012: ouch, ok, thanks :)
08:29:21 <blah012> Thignsome: no prob, but why ouch? "m (Either a b) -> ExceptT (Either Error) m b" really couldn't be much shorter :D
08:29:40 <blah012> err, ExceptT Error m b
08:30:20 <Thignsome> blah012: http://ideone.com/jNLXFr
08:30:32 <Thignsome> I'd just much rather be able to just write exampleA/B/C without the long lifting function in front of each
08:30:33 <mehryar> in the Base Prelude, "sequence" is defined as, sequence = sequenceA;  sequenceA = traverse id;  traverse f = sequenceA . fmap f;  is that mutual recursion going on in the defn of sequenceA and traverse? Seems to me there isn't enough information there to do mutual recursion? (http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Traversable.html#sequence)
08:31:05 <blah012> Thignsome: Pull the lifting function out to a helper function!
08:32:34 <glguy> mehryar: Those are the default definitions of a typeclass. The  {-# MINIMAL traverse | sequenceA #-} pragma indicates that you'll need to override at least one of them
08:32:41 <glguy> when you implement an instance of this typeclass
08:32:57 <mehryar> glguy: ah got it, makes sense now. Thanks!
08:34:09 <mehryar> so if I do sequence [print 1, print 2]. Which typeclass should I look at to find the implementation of sequence? 
08:34:21 <glguy> :t sequence
08:34:23 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
08:34:37 <glguy> sequence is part of the Traversable typeclass, so we need to consider the type t there
08:34:49 <glguy> your argument :: [IO ()]
08:34:59 <glguy> so therefore t is [] and m is IO and a is ()
08:35:05 <glguy> so you need to look at the Traversable [] instance
08:35:18 <mehryar> Nice! makes so much sense now. I really appreciate it!
08:37:53 <hellertime> can I somehow get ghc to import an unexposed package module? 
08:40:37 <glguy> Generally no. It's possible you can do something with the GHC API, but I don't actually know about that. With Template Haskell you can extract some things from a hidden module, but not everything.
08:41:15 <hellertime> yeah, thats more hackish than I was hoping for. I'll go about things a different way then
08:44:15 * hackagebot rattletrap 0.1.6 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.1.6 (fozworth)
09:00:38 <athan> Has anyone here ever had a build failure with the `p-0.1.0.0` package?
09:00:44 <athan> (when compiling cabal-install)
09:00:49 <athan> (.... on ARMv7)
09:01:17 <athan> It's a really trivial failure, too - the LICENSE file can't be found in it
09:01:54 <athan> but, the package doesn't exist on hackage :x
09:07:14 <lyxia> glguy: I'm trying to implement a WeeChat relay client, and since it's basically yet another IRC client I figured I might reuse the UI logic of glirc. A ClientState contains a map of NetworkState, which contain a field _csSocket :: !NetworkConnection, and I can't populate it. Do you think it is possible to somehow make that field optional, as long as I write my own networking handlers?
09:09:06 <glguy> lyxia: That field is used in two places, one to kill a connection and another to transmit on it
09:09:21 <glguy> I suppose we could replace that field with two fields, one that was an action to kill the connection
09:09:35 <glguy> and another that was a function for transmitting
09:11:44 <mehryar> could someone help me understand "bind". Specifically how should I read the evaluation order of this function "orderedPairs" where:
09:11:48 <mehryar> orderedPairs xs = 
09:11:53 <mehryar>   xs >>= \x1 ->
09:11:53 <mehryar>   xs >>= \x2 ->
09:11:53 <mehryar>   if x1 < x2 then [(x1,x2)] else []
09:11:56 <mehryar>  
09:13:13 <Hafydd> mehryar: what do you mean by "evaluation order"?
09:13:16 <lyxia> glguy: I see, I think I could go on if I could ignore it.
09:14:31 <mehryar> Hafydd: I think Im just confused about reading these chains of >>= and don't understand what gets evaluated first and whose result is passed on to which function first?
09:14:45 <athan> mehryar: monads are still an equation :)
09:15:02 <athan> mehryar: check out "IO Inside"
09:15:11 * athan ducks and runs before someone gets a pitchfork
09:15:27 <implementation> mehryar: in haskell you never know what is evaluated first; because all evaluation orders are equivalent and give the same resul
09:15:28 <Hafydd> mehryar: what gets evaluated first is whatever is necessary to run the program - it could be that nothing is evaluated at all.
09:16:11 <xa0> kinda wanna create a monad transformer called "EIE" just so I can have EIE IO a
09:16:13 <Hafydd> mehryar: however, speaking in terms of monadic "effects", in so far as that makes sense for lists, the binding of x1 takes place before the binding of x2.
09:17:12 <glguy> lyxia: It would probably be better if I didn't have the network connection in that data type at all
09:17:51 <Hafydd> For each element of xs bound to x1, that function chooses another element of xs, bound to x2, and for each of those it "runs" the last line.
09:18:00 <mehryar> Hafydd: so it correct to read that function as: instance Traversable [] where
09:18:01 <mehryar>     {-# INLINE traverse #-} -- so that traverse can fuse
09:18:01 <mehryar>     traverse f = List.foldr cons_f (pure [])
09:18:09 <mehryar> oops crap - sorry bad paste.
09:19:34 <mehryar> Hafydd: ah ok that makes sense. Thanks!
09:19:49 <mehryar> athan: thanks I didn't know about "IO Inside" I'll also read that now.
09:20:36 <Hafydd> It is equivalent to: orderedPairs xs = do { x1 <- xs; x2 <- xs; if x1 < x2 then [(x1,x2)] else [] }
09:24:17 * hackagebot tasty-discover 1.0.0 - Automatically discover and run Tasty framework tests.  https://hackage.haskell.org/package/tasty-discover-1.0.0 (lwm)
09:24:38 <kuribas> Why is there "for == flip tranverse", but nothing for "flip map"?
09:25:06 <athan> mehryar: it's really hard to force evaluation imperatively
09:25:20 <xa0> tranverse?
09:25:24 <xa0> :t tranverse
09:25:29 <lambdabot> error:
09:25:29 <lambdabot>     • Variable not in scope: tranverse
09:25:29 <lambdabot>     • Perhaps you meant one of these:
09:25:31 <hiptobecubic> traverse?
09:25:37 <xa0> thought so
09:26:33 <bno1> !note
09:26:43 <bno1> wrong channel
09:26:50 <xa0> !ok
09:26:54 <nitrix> @let foreach = flip fmap
09:26:54 <lyxia> :t (<&>)
09:26:56 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:26:57 <lambdabot>  Defined.
09:27:19 <nitrix> :t foreach
09:27:21 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:27:30 <nitrix> kuribas: There, a cute prefix name for <&> :P
09:27:55 <Hafydd> Also relevant:
09:28:02 <Hafydd> :t (<**>)
09:28:06 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
09:28:14 <kuribas> nitrix: thanks :)
09:28:19 <kuribas> :t fmap
09:28:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:28:34 <kuribas> @hoogle Functor f => f a -> (a -> b) -> f b
09:28:37 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
09:28:37 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
09:28:37 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
09:29:02 <lyxia> the hoogle database might be a bit old
09:30:35 <nitrix> kuribas: `map` is `fmap` speciaized to lists. And <&> is the flipped version of <$>, which is just fmap as an infix operator.
09:31:05 <kuribas> I see.  I'll obfuscate my code with more arcane combinators ;-)
09:31:06 <Hafydd> I thought that <$$> would make more sense, to be consistent with <**>.
09:31:12 <Hafydd> But apparently that does not exist.
09:31:23 <kuribas> nitrix: I like your suggestion more actually
09:31:29 <nitrix> kuribas: May I ask what makes them arcane?
09:31:56 <kuribas> nitrix: well, you cannot guess the meaning from looking at it.
09:32:36 <nitrix> You cannot guess the meaning of almost anything Haskell without learning about it first or looking at its type signature.
09:33:02 <kuribas> foreach makes more sense
09:33:19 <nitrix> It doesn't to me. foreach to me implies a monadic context.
09:33:22 <nitrix> (forM)
09:33:49 <kuribas> nitrix: true.  Maybe overeach?
09:33:58 <Hafydd> overreach
09:34:16 <nitrix> kuribas: What about fmap ?
09:34:34 <kuribas> lens is the worst.  But fortunately it has sensible names for most combinators.
09:34:39 <kuribas> nitrix: you mean flip fmap?
09:34:46 <nitrix> You rarely ever need to flip fmap.
09:35:39 <nitrix> A partial function that applies a transformation of your choice on a given list, and you'd presumably feed it different transformations and collect the results? All on that same list?
09:36:18 * Hafydd . o O (lip map)
09:36:19 <kuribas> nitrix: no, it's useful for a lambda: flip fmap list $ \el -> do stuff...
09:36:42 <kuribas> nitrix: if it's a long lambda...
09:36:43 <nitrix> kuribas: You can't `do`.
09:36:54 <nitrix> kuribas: It's precisely the argument being made.
09:36:59 <kuribas> nitrix: that was figure of speach.
09:37:13 <kuribas> flip fmap list $ \el -> transform stuff...
09:37:18 <kuribas> fixed it ^
09:37:28 <KaneTW> flip fmap list $ \case -> { cases }
09:37:39 <kuribas> yeah
09:39:46 <nitrix> kuribas: This would have to be binded via let, a where clause or wrapped in parens.
09:40:31 <kuribas> why?
09:40:34 <hexagoxel> list <&> \el -> _ el
09:41:04 <nitrix> kuribas: Because it's not monadic. It yields a value and using that result leads to one of those.
09:41:32 <kuribas> nitrix: yes
09:42:10 <nitrix> kuribas: The only way to keep it clean is to bind the whole expression as a nice, at which point you might as well extract that transaformation `fmap transformation list` and give it its own name.
09:42:35 <nitrix> kuribas: forM doesn't have this issue because it's monadic. But I really don't see any good or clean uses of `flip fmap`.
09:42:45 <nitrix> s/nice/name/
09:43:38 <kuribas> nitrix: you know programmers hate namings ;-)
09:44:39 <nitrix> I know nothing about that.
09:46:02 * hexagoxel is using <&> regularly
09:46:40 <nitrix> hexagoxel: Mind sharing some of the code where it's used?
09:47:12 <nitrix> I'm curious to see if it's more or less readable.
09:48:18 <will-133> Can anyone help me?  Working through some exercises in "Haskell programming from first principles" - I have to implement the following function, but why does it require (Applicative f) ?
09:48:19 <will-133> filterF :: (Applicative f, Foldable t, Monoid (f a)) => (a -> Bool) -> t a -> f a
09:49:24 <hexagoxel> nitrix: perhaps https://github.com/lspitzner/brick/blob/master/programs/reflex/ReflexDemo.hs#L32
09:50:54 <kuribas> I find that very readable
09:53:48 <hexagoxel> yes, you could give that a name, but in FRP this is a pattern that happens a _lot_. you some Event a, a non-trivial expression that does (a->b) and some short "user" of Event b (here the foldDyn).
09:55:27 <nitrix> Is eventE a lens?
09:55:40 <hexagoxel> you can see the same pattern in lines 42, 44 and even 46 (fforMaybe is like catMaybes . flip fmap, morally).
09:56:24 <nitrix> ffor, flipped version of fmap.
09:56:57 <nitrix> Shouldn't they be using Reflex's `ffor` then ?
09:57:19 <hexagoxel> no, it is a Reflex Event.
09:57:20 <DrDeath> I have a question about ddos.
09:57:54 <DrDeath> If I am being ICMP flooded. Once the threshold is reached does it block me from connecting to anything?
09:58:55 <glguy> DrDeath: This channel is about Haskell programming
09:59:03 <DrDeath> oh sorry gl.
09:59:10 <DrDeath> I had no idea what haskell even was lol
09:59:16 <DrDeath> Just heard this was a very helpful channel.
10:01:02 <hexagoxel> nitrix: ffor and (<&>) have exactly the same type, and this usecase requires an infix operator.
10:01:41 <hexagoxel> also i'd consider <&> more "standard"
10:01:42 <nitrix> hexagoxel: As opposed to chaining multiple $ ?
10:02:44 <kuribas> :t ffor
10:02:46 <lambdabot> error:
10:02:46 <lambdabot>     • Variable not in scope: ffor
10:02:46 <lambdabot>     • Perhaps you meant one of these:
10:03:10 <hexagoxel> (ffor is defined in the `reflex` package)
10:03:27 <nitrix> hexagoxel: That's actually the first time I see \case and then immediatly a newline. What's that?
10:03:53 <hexagoxel> -XLambdaCase
10:04:24 <Cale> Is there a reflex question?
10:04:58 <nitrix> hexagoxel: Thanks.
10:10:33 <kirillow> Is there a way to make this more consice (bundle the `a <- bo..` `b <- bo..` .. or something?): `[((Yes,a),(No,a),(Both,a)) | a <- boolArray, b <- boolArray, c <- boolArray]` (where boolArray is `[True, False]`)
10:11:45 <kadoban> kirillow: b and c aren't used?
10:11:49 <kirillow> oops
10:12:16 <glguy> > zip ["Yes","No","Both"] <$> replicateM 3 [True, False]
10:12:19 <lambdabot>  [[("Yes",True),("No",True),("Both",True)],[("Yes",True),("No",True),("Both",...
10:12:48 <kirillow> uuuh apparently it doesnt matter
10:13:07 <glguy> It matters because it changes the result
10:13:56 <kirillow> not from a version where it's (Yes,a),(No,b),(Both,c)
10:14:38 <glguy> You have to look past the first element of the resulting list to see the difference
10:14:59 <kirillow> m(
10:15:03 <kirillow> yes okay
10:34:21 * hackagebot digestive-functors-aeson 1.1.20 - Run digestive-functors forms against JSON  https://hackage.haskell.org/package/digestive-functors-aeson-1.1.20 (OliverCharles)
10:34:23 * hackagebot libsystemd-journal 1.4.1 - Haskell bindings to libsystemd-journal  https://hackage.haskell.org/package/libsystemd-journal-1.4.1 (OliverCharles)
10:40:36 <hrk> Hello. I'd like to parse several hundreds of files using language-java package. Unfortunately it uses Alex which for java source files (with unicode chars) throws an error (from here https://www.stackage.org/haddock/lts-7.7/language-java-0.2.8/src/Language.Java.Lexer.html#alex_action_14). I tried several ways to catch the error, but it doesn't work - the error crashes the program. Any idea how to catch it?
10:40:59 <hrk> Here's my code with unsuccessfull catch at line 31: http://lpaste.net/328880
10:43:07 <geekosaur> withFile is lazy --- unless you force processing the whole file, the exception will likely happen outside of the catch (probably in parseResult)
10:43:54 <ezyang> fryguybob: Actually... that is amazingly close to what I need 
10:43:58 <glguy> withFile isn't lazy, TO.hGetContents isn't either
10:44:15 <glguy> But the parseCU is a pure function that isn't being evaluated until outside of withFile
10:45:38 <glguy> hrk: It'd probably help to see the actual error
10:47:05 <hrk> glguy: I updated the paste, exception at the bottom: http://lpaste.net/328880
10:50:51 <hrk> glguy: You seem to be right. How would you propose to force the evaluation inside of withFile?
10:51:17 <lpaste> glguy annotated “Catching Error witch Control.Exception.catch?” with “Catching Error witch Control.Exception.catch? (annotation)” at http://lpaste.net/328880#a328892
10:51:29 <glguy> hrk: something like that (I didn't try loading it, just edited it on lpaste)
10:51:42 <glguy> You don't actually need withFile, so I pulled that out
10:51:54 <glguy> but the important thing is that you'll need to force evaluate on the parse result
10:52:24 <glguy> evaluate only forces the outer most constructor, but hopefully forcing that is enough because it will need to know if lexing succeeded to produce a Right or Left
10:52:31 <glguy> and that has to depend on actually lexing the file
10:55:41 <glguy> I guess we could tighten that up a bit by moving the exception handler just to wrap the (evaluate res) portion
10:55:45 <dfeuer> Wait, what?
10:55:54 <dfeuer> Lexing is usually token by token, right?
10:56:06 <dfeuer> Streaming?
10:56:19 <glguy> You'd have to look at the paste in question first to see what's actually happening
10:56:22 <dfeuer> OK.
11:00:45 <hrk> glguy: Cool, thanks for the idea, it worked. I fixed some type errors and it works :) Here's your modified version http://lpaste.net/328880
11:07:33 <buttbutter> Does Haskell have a function to find a substring in a string?
11:08:51 <hrk> buttbutter: String = [Char]. Use Data.List.isInfixOf
11:09:26 <Tuplanolla> I've seen more efficient search algorithms somewhere too, buttbutter.
11:09:33 <buttbutter> hrk: Perfect, precisely what I need. Thanks. :)
11:10:16 <Tuplanolla> @hackage stringsearch
11:10:17 <lambdabot> http://hackage.haskell.org/package/stringsearch
11:12:36 <mutantmell> buttbutter: If/when you're using text, it also has isInfixOf
11:12:48 <vu699> hi
11:12:55 <Cale> Hello!
11:13:18 <vu699> how are you
11:13:19 <buttbutter> Now that I consider more carefully, I'd actually like a function that returns the index of that substring. Does that exist?
11:13:42 <Tuplanolla> That sounds like a job for `Vector`, buttbutter.
11:13:56 <EvanR> stringsearch package also does that
11:14:04 <EvanR> check the dox
11:14:28 <EvanR> indices :: ByteString -> ByteString -> [Int]
11:14:30 <buttbutter> EvanR: Tuplanolla Thanks for the recs, I'll take a look. 
11:15:40 <Cale> :t findIndex
11:15:42 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
11:16:06 <Cale> > findIndex (isPrefixOf "cad") "abracadabra"
11:16:09 <lambdabot>  error:
11:16:10 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
11:16:10 <lambdabot>        Expected type: [[Char]]
11:17:32 <Cale> > findIndex (isPrefixOf "cad") (tails "abracadabra")
11:17:32 <Cale> lambdabot y u so slow today
11:17:35 <lambdabot>  Just 4
11:17:49 <Cale> lol
11:17:58 <Cale> Must be something going on with lambdabot's machine
11:18:25 <Cale> ... or the network
11:18:50 <Cale> > findIndex (isPrefixOf "cad") (tails "fish")
11:18:52 <lambdabot>  Nothing
11:19:00 <Cale> buttbutter: ^^
11:19:01 <mutantmell> It was speedier when /msg-ing it
11:19:13 <mutantmell>  /shrug
11:19:24 * hackagebot github 0.15.0 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.15.0 (phadej)
11:22:59 <tomjaguarpaw> Is it just me or is the CPP in the Monad instance here completely nuts?
11:23:01 <tomjaguarpaw> https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.State.Lazy.html#State
11:23:12 <tomjaguarpaw> Why is it 'return' that is #if'ed out, rather than fail???
11:25:54 <int-e> tomjaguarpaw: because `return` has a sensble default implementation, but `fail` doesn't.
11:27:02 <int-e> (return = pure by default in base-4.8)
11:27:16 <tomjaguarpaw> Ah!
11:31:29 <fryguybob> ezyang: :D
11:32:19 <tomjaguarpaw> Would have been nicer to see return = pure explicitly I think.  Oh well.
11:33:29 <mutantmell> probablt didn't want to do an #ELSE :P
11:34:37 * hackagebot semiring-num 0.3.0.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.3.0.0 (oisdk)
11:35:59 <akfp> how can I find out why fast-logger is being built by `stack test`?
11:37:58 <joe9_> Is there something like this for Text FilePath? https://hackage.haskell.org/package/posix-paths-0.2.1.0/docs/System-Posix-FilePath.html
11:49:39 <lifter> Given that the function functor is just function composition, and we already have (.), is there a common/novel use of the function functor using fmap? Do ppl often use applicative style to take advantage of the function functor?
11:50:56 <amalloy> lifter: liftA2 (&&) is a good example
11:53:22 <lifter> amalloy: Could you please show me an example?
11:53:31 <EvanR> lifter: one "novel" use would be to gratuitously use fmap alot
11:53:36 <EvanR> :t fmap fmap fmap fmap
11:53:38 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
11:53:38 <amalloy> :t liftA2 (&&)
11:53:40 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
11:54:00 <phadej> liftA2 (&&) even odd 1
11:54:03 <phadej>  > liftA2 (&&) even odd 1
11:54:06 <phadej> > liftA2 (&&) even odd 1
11:54:09 <lambdabot>  False
11:54:21 <EvanR> applicative is reallly useful yeah
11:54:22 <phadej> not very interesting example, but hopefully you get a point
11:54:40 <amalloy> > liftA2 (&&) even (> 4) $ 9
11:54:43 <lambdabot>  False
11:54:44 <amalloy> > liftA2 (&&) even (> 4) $ 10
11:54:47 <lambdabot>  True
11:55:17 <lifter> Ok I understand that, I guess I didn't make the connection between applicative style and the function functor
11:55:48 <EvanR> specifically the applicative function is S combinator
11:56:02 <EvanR> f <*> g x = f x (g x)
11:56:34 <phadej> otoh, it might be a bit write-only style
11:56:34 <EvanR> it comes up often enough we can confuse a surprising number of people with haskell code
11:56:55 <EvanR> but it is useful in defining function-like applicatives
11:57:22 <Cale> @quote zip`ap`tail
11:57:23 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:57:46 <Cale> > (zip`ap`tail) [1..10]
11:57:49 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
11:58:18 <mutantmell> > join (*) 3
11:58:20 <lambdabot>  9
11:58:26 <lifter> haha
12:02:27 <EvanR> useful for more than consecutive numbers, you could use that to fun a function on consecutive pairs of any list elements
12:02:38 <EvanR> to fun a function? might as well make that the verb
12:02:55 <EvanR> ah, run
12:03:30 <lifter> > let tryMe = do { a <- (*2); b <- (+1); return (a+b) } in tryMe 10
12:03:32 <lambdabot>  31
12:03:38 <lifter> That is really something.
12:04:01 <mutantmell> > :t do { a <- (*2); b <- (+1); return (a+b) }
12:04:04 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:04:18 <mutantmell> :t do { a <- (*2); b <- (+1); return (a+b) }
12:04:19 <lambdabot> Num b => b -> b
12:04:27 * hackagebot mathexpr 0.2.0.1 - Parse and evaluate math expressions with variables and functions  https://hackage.haskell.org/package/mathexpr-0.2.0.1 (mdibaiee)
12:04:39 <implementation> why exactly does this yield 31? o_O
12:05:16 <implementation> ah, understood, nevermind
12:09:27 * hackagebot mathexpr 0.3.0.0 - Parse and evaluate math expressions with variables and functions  https://hackage.haskell.org/package/mathexpr-0.3.0.0 (mdibaiee)
12:21:24 <amx> I seem to have my head so far down an object-oriented hole that I need some help to get it unstuck
12:21:36 <amx> http://lpaste.net/328939
12:22:08 <amx> https://github.com/linearray/alegria/blob/master/src/FSMApi.hs       this is the current interface to my library
12:23:42 <amx> I want to refer to type variables in the class declaration, which leads to ambiguity. Something tells me I approach this the wrong way.
12:24:14 <ania123> I need a chess program written in haskell
12:26:56 <barrucadu> amx: Could you just have a record type 'FSMStore' (with all the appropriate type variables), rather than a separate type for each store?
12:27:52 <barrucadu> And the 'FSMHandle' contains the 'FSMStore' value
12:29:57 <amx> the appeal of using a typeclass was that the correct function for the particular store is picked by the compiler
12:30:05 <amx> could I somehow get that without?
12:31:07 <athan> amx: Without a typeclass you mean?
12:31:33 <athan> But you're right, if the typeclass specifies a term that has universally quantified type variables, they can't be messed with
12:31:41 <athan> a great example of this is why Set isn't a Functor
12:31:57 <athan> because then `fmap :: (Ord b) => (a -> b) -> Set a -> Set b
12:32:25 <athan> which isn't legitimate, because the Functor definition should work _for all b's_, not for "most" that happen to also be orderable
12:34:00 <ania123> I need a chess program written in haskell
12:34:16 <ab9rf>  why?
12:34:17 <Tuplanolla> That's oddly specific, ania123.
12:34:27 <ania123> what?
12:34:36 <amx> I also wondered if type families could help, but I'm still reading up on them
12:34:52 <ania123> why?
12:35:06 * ab9rf resists the urge to ask how? and where?
12:35:42 <Tuplanolla> If you want to play chess, it doesn't have to be written in Haskell; if you want to study a Haskell game, it doesn't have to be chess. That's why, ania123.
12:36:10 <ania123> i need tp study haskell
12:36:17 <ania123> by intuitive examples 
12:36:26 <ab9rf> also, do you simply want a program to mediate a chess game b etween two players, or od you want a program that will actually play competitively? if the latter, how good does it have to be? :)
12:37:21 <ania123> ab9rf: later one
12:37:53 <ab9rf> ania123: unless you're alerady an experienced game AI engine progarmmer, i'd strongly urge you to choose a simpler game
12:37:54 <athan> amx: Open type families and associated types are nice for "pointing" to a type constructor from another
12:38:21 <ania123> ab9rf: can u tell me a simple game
12:38:28 <athan> like a convenient referece. With associated types, they let the person writing the typeclass instance to declare what (monomorphic ?) type the family references
12:38:28 <ab9rf> tic tac toe is popular :)
12:38:34 <ab9rf> connect four
12:38:37 <ab9rf> nim
12:38:56 <athan> closed type families are crazy though, they kinda sorta pattern match on type constructors, allowing you to be recursive and do fun stuff
12:39:14 <ab9rf> all of these have fairly readily identified winning strategies, which will let you readily test if your best-move search algorithm works correctly
12:39:24 <ab9rf> with chess, it's harder to tell that you're making the "right" move
12:49:30 * hackagebot publicsuffix 0.20161104 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161104 (wereHamster)
12:50:28 <polo> Hello, I wrote the following function that handles two lists:sp = zipWith wavg where wavg x y = (x + y + (max x y))/3 .I want to modify the function so that it handles a matrix (list of three lists)
12:51:16 <polo> for example: supersuperimpos [[1,2,3,4],[6,4,5,6],[1,2,3,4]] [[7,8,9,10],[9,10,2,9],[7,8,9,10]] -> [[5.0,6.0,7.0,8.0],[8.0,8.0,4.0,8.0],[5.0,6.0,7.0,8.0]]
12:54:10 <joe9_> any feedback on this, please? https://github.com/joe9/logger-thread/blob/master/src/LoggerThread.hs usage: https://github.com/joe9/logger-thread/blob/master/app/Main.hs
12:54:10 <Hafydd> > let wavg x y = (x + y + (max x y))/3 in zipWith (zipWith wavg) [[1,2,3,4],[6,4,5,6],[1,2,3,4]] [[7,8,9,10],[9,10,2,9],[7,8,9,10]] -- polo 
12:54:12 <lambdabot>  [[5.0,6.0,7.0,8.0],[8.0,8.0,4.0,8.0],[5.0,6.0,7.0,8.0]]
12:55:17 <Hafydd> polo: for practical purposes, you might want to consider using a specialised matrix type, rather than lists of lists.
12:55:39 <Hafydd> (There are a number of libraries for this; I'm not sure what the best one is.)
12:56:08 <Tuplanolla> Repa 3 is nice at least.
13:02:52 <polo> Hafydd : I did ssp = zipWith (zipWith wavg where wavg x y = (x + y + (max x y))/3) but getting parse error in where  
13:03:15 <Hafydd> polo: you omitted a parenthesis.
13:04:55 <polo> Hafydd: where did I omit parebthesis please?
13:05:27 <Hafydd> polo: compare what I wrote with what you wrote. Can you not see where they differ?
13:06:33 <polo> Hafydd: but you hardcoded two lists.I want function to take any matrix list. 
13:08:48 <amalloy> polo didn't omit a parenthesis, but rather misplaced the where clause
13:09:15 <amalloy> where is only valid attached to a pattern-match, not an arbitrary place in the middle of an expression
13:09:41 <amalloy> you could move the where to the end, or just embed a lambda if you want it inline
13:10:10 <Tuplanolla> ...or use `let`, which is valid anywhere.
13:11:30 <Hafydd> Oh, yes. Well, at any rate, it should be like this: ssp = zipWith (zipWith wavg) where wavg x y = (x + y + (max x y))/3
13:13:26 <joe9_> I use this package https://hackage.haskell.org/package/template-default but, for some reason the maintainers do not seem to respond. Any suggestions on what I can do?
13:13:41 <joe9_> I cannot figure out if it is obsolete.
13:14:10 <joe9_> and, if there is any other package that can provide similar functionality.
13:15:05 <joe9_> I raised an issue last year and no response https://github.com/haskell-pkg-janitors/template-default/issues/4
13:15:30 <joe9_>  haskell-pkg-janitors -- Does it mean the package is dead?
13:15:54 <Tuplanolla> Send an email to the author, joe9_.
13:19:02 <joe9_> Tuplanolla: Is there some kind of deriving mechanism that can supersedes this? such as deriving (Default)?
13:19:13 <Tuplanolla> Not that I know of, joe9_.
13:22:13 <joe9_> when I try to compile with ghc 8 http://codepad.org/jZD1RzLn Do the errors appear trivial to fix?
13:22:52 <Tuplanolla> Trivial doesn't mix with template Haskell.
13:23:51 <Tuplanolla> You could try downloading the package and trying your hand regardless.
13:25:22 <glguy> joe9_: Do you even need to use template haskell for this? Are the GHC.Generics derived instances not good enough?
13:27:34 <joe9_> glguy: I did not even know that GHC.Generics had derived instances. Let me figure out how to use them. Thanks a lot.
13:28:03 <joe9_> glguy: That was the info I was looking for. an alternative that works.
13:28:04 <glguy> The changes shouldn't be very hard, if you do find that you want to fix up the TH. Even better is not using the Default class which would even save you from having to do either
13:28:59 <joe9_> glguy: what do you mean by not using the default class? Is there a better alternative? I have default values and it is mostly the first constructor.
13:29:35 <glguy> The Default class is an unprinipled way to get lots of things to reuse the name "def"
13:29:46 <glguy> even better is not reusing the name def
13:30:24 <Tuplanolla> I've noticed that use cases for `Default` tend to disappear after refactoring.
13:33:51 <joe9_> It is so convenient when you have a lot of data types and the first is mostly the default value.
13:34:50 <joe9_> I can get rid of deriveDefault by handcoding the default value. but, to get rid of the Default class (I think) makes things harder
13:35:06 <Tuplanolla> Is that really the only thing the types have in common?
13:35:11 <joe9_> as you would have to keep all the default values in your head instead of just usin def.
13:35:57 <joe9_> Tuplanolla: yes, https://github.com/joe9/betfair-api/search?utf8=%E2%9C%93&q=derivedefault
13:36:05 <joe9_> glguy: ^^
13:36:22 <joe9_> glguy: Tuplanolla, any suggestions to work around it would be very helpful.
13:38:40 <nitrix> Hi. What would be the best data structure to allow arbitrary tagging some values and looking up these values by building tag algebras? (Has tag A, but not tag B, "and/or" logic)
13:39:20 <joe9_> nitrix: IxSet?
13:42:09 <nitrix> Can you arbitrarily add new indexes?
13:44:01 <nitrix> Seems like you need to know them ahead of time to make a type indexable.
13:44:27 <nitrix> In my case, it's freely creating new tags, tagging/untagging things, deleting tags.
13:44:37 <nitrix> And searching by a tag algebra.
13:46:05 <joe9_> if tag == Word?, then I think you can add new words or delete, etc.
13:46:14 <joe9_> s/Word/String/
14:06:32 <sunakshi_> Hii all
14:21:06 <__monty__> Is there a good guide to how experienced haskellers use ghci while writing haskell?
14:27:41 <suppi> __monty__: i only remember this one: http://chrisdone.com/posts/haskell-repl
14:33:04 <__monty__> Thanks, suppi.
14:33:06 <monochrom> I don't write such a guide because there are only a handful of commands to remember: :load, :reload, :info, :type, :module, :browse, :quit
14:33:36 <monochrom> And also because the GHC User's Guide already contains the desired guide.
14:33:58 <monochrom> because that's where I learned everything from.
14:34:04 <__monty__> I'm not really looking for how ghci works but rather the workflow one follows with it.
14:34:19 <monochrom> Sure, but the GHC User's Guide does that too.
14:34:36 * hackagebot sparse-linear-algebra 0.2.1.1 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.1.1 (ocramz)
14:37:22 <monochrom> which is really just :load and :reload
14:38:09 <__monty__> It looked like a straightforward explanation of the features of ghci when I skimmed it. I'm really looking for a "Here's how I use ghci during development." kind of thing but if :load is all there's to it that's fine I guess.
14:39:25 <athan> aie karumba, StateT doesn't work well with -threaded applications? :(
14:40:38 <monochrom> StateT and -threaded are orthogonal
14:41:02 <athan> monochrom: I'm getting very strange behavior then o_O
14:41:16 <athan> I can write to a file with liftIO, but my `put` and `get` aren't "saving"
14:41:21 <monochrom> but if you sprinkle some "par"s here and there, and turn on -threaded, and turn on -RTS +N, things will get parallelized
14:41:22 <athan> er sorry, just put :x
14:41:34 <athan> yeah, it's in a warp server
14:41:46 <athan> ST?
14:42:31 <monochrom> ST is orthogonal to -threaded too, unless and until one day someone invents "forkST"
14:43:12 <monochrom> "put" and "get" are still pure functions and unaffected by multithreading and singlethreading
14:43:53 <athan> monochrom: Hrm, well I guess we'll see :s
14:44:24 <monochrom> Do you already agree that StateT has no "state", only passing parameters around?
14:45:08 <barrucadu> athan: Do you have a small bit of code which is not behaving in the way you expect?
14:45:09 <monochrom> Because merely passing parameters around is not going to magically cause "shared memory" to happen.
14:47:48 <athan> monochrom: I entirely aggree with that, but for some reason my transformer stack isn't behaving as it should
14:48:12 <athan> literally in the same transformer expression, I write to a file, and `put`, then `get` right after to log the change (or really, lack thereof)
14:48:20 <athan> it's a pretty big app though :\
14:49:10 <coleman> What would you use in haskell instead of a doubly-linked list?
14:49:13 <monochrom> The cause is elsewhere
14:49:54 <athan> monochrom: yeah :\
14:50:17 <amalloy> coleman: what would you use to eat dinner instead of chopsticks? it depends
14:50:21 <alx741> guys, I can't remember the word for declaring a function "not defined yet" so I can compile, which was it?
14:50:35 <__monty__> undefined?
14:51:02 <alx741> __monty__: oh, I was using "Undefined" (╯°□°）╯︵ ┻━┻  , thanks!
14:52:50 <coleman> amalloy: I want the cartesian product of two lists, but afterwards I want to be able to travel backwards
14:53:13 <coleman> (from any point in the list)
14:53:21 <amalloy> a zipper
14:53:52 <coleman> amalloy: thanks
14:53:56 <monochrom> or use an array
14:54:50 <onintza> I'm trying to find an elegant way of writting a function Eq a => [a] -> Maybe a that takes a list of a-s and gives back Just x where x is the value for all a-s, or Nothing if the list is empty or the a-s have not the same value
14:55:23 <onintza> Now I use recursion
14:55:59 <joe9_> I think there is listToMaybe
14:56:17 <onintza> I would still need to make sure all the elements are the same
14:56:23 <amalloy> i think you can just do some simple pattern matching and filter
14:56:48 <xa0> there is
14:56:52 <xa0> :t listToMaybe
14:56:54 <lambdabot> [a] -> Maybe a
14:57:09 <amalloy> collapse [] = Nothing; collapse (x:xs) | all (== x) xs = Just x; otherwise = Nothing
14:57:26 <onintza> amalloy: that's what i have now
14:57:51 <onintza> err, sorry, no, that's better
14:57:56 <onintza> cheers!
15:10:18 <geppettodivacin> I've got some Applicative code that I'm using to show results of a function on some lists. The form is very much like this: http://lpaste.net/328884
15:11:05 <geppettodivacin> I'd really like to put spacers (in this case, newlines) between the different applications, as written in the comments of the paste.
15:11:18 <geppettodivacin> Is there a way to do that in an applicative style?
15:13:25 <joe9_> Is Integer a recommended way to store time?
15:13:39 <Clint> i can't imagine it would be
15:13:48 <davean> joe9_: What type of time?
15:14:03 <davean> There are a whole lot of types of time
15:14:16 <Tuplanolla> If you want a tacit solution, use `chunksOf` from `Data.List.Split`, geppettodivacin.
15:15:14 <davean> Integer is a pretty good version of time for a lot of distributed systems algs. Most human-style time is better handled by TAI, but we don't get to use that, so use the UTC time from the 'time' package :(
15:15:37 <davean> If you want to know about compture time theres 'clock'
15:15:50 <geppettodivacin> Tuplanolla: I could do that. I was trying to avoid that, though, because it loses its applicative prettiness.
15:15:55 <athan> monochrom: ST fixed it >:D
15:15:59 <athan> purity be damned
15:16:10 <davean> Integer is well recomended for weak ordinal time.
15:16:13 <Tuplanolla> Why would that be the case, geppettodivacin?
15:16:14 <joe9_> davean:  ok, Thanks found this https://two-wrongs.com/haskell-time-library-tutorial
15:17:08 <geppettodivacin> Tuplanolla: Because then I have to muck around with knowing the lengths of lists so that I can break the newly constructed list into rows and then recombine it.
15:17:37 <Tuplanolla> You want each row to have the same length, geppettodivacin?
15:17:39 <davean> joe9_: Come back in a month when you realize how fucked you are bot TAI.
15:17:55 <davean> joe9_: Come back in a month when you realize how fucked you are its not TAI.
15:19:19 <geppettodivacin> Tuplanolla: I think that's how the Applicative instance of lists works.
15:19:41 <Tuplanolla> Oh, now I see what you're after, geppettodivacin.
15:20:53 <Tuplanolla> You'd indeed have to pass the initial length through or use `integerSqrt` on the final length.
15:22:34 <hexagoxel> geppettodivacin: if you use fmap twice, you can end up with a list (of lines) each containing a list (of items). This sounds rather close to what you want, and does not even need Applicative.
15:22:51 <amx> davean: can you explain why you would use TAI instead of UTCTime?
15:23:26 <c_wraith> TAI is monotonic in the face of leap seconds. 
15:23:29 <geppettodivacin> hexagoxel: I'm not sure how I would do that.
15:23:33 <c_wraith> UTCTime is not. 
15:24:20 <davean> amx: Because you can calculate the distance between TAI instances, no TAI tiems are duplicated, TAI never runs backwards, you can convert from TAI to UTC but not the other way around
15:24:30 <davean> amx: Because UTC is just broken as a time basis
15:24:37 <davean> amx: and should never have been used in computers
15:24:44 <davean> Its a fine display format, but nothing more
15:24:53 <davean> The selection of UTC was absolutely braindead
15:25:03 <davean> I'm actually baffled as to how it happened
15:25:25 <c_wraith> well, the braindeadedness was originally in POSIX time. 
15:25:25 <hexagoxel> > map (\x -> map (\y -> (x,y)) [1,2,3]) [4,5,6] -- geppettodivacin 
15:25:28 <lambdabot>  [[(4,1),(4,2),(4,3)],[(5,1),(5,2),(5,3)],[(6,1),(6,2),(6,3)]]
15:25:47 <c_wraith> UTCTime just inherited it from there. 
15:26:14 <davean> c_wraith: huh, what? no
15:26:22 <nshepperd1> Would you believe that Microsoft uses local time in its computers
15:26:23 <geppettodivacin> hexagoxel: Yeah, that looks like what I'm looking for.
15:26:44 <nshepperd1> In the rtc i mean
15:26:55 <amx> ok thanks
15:27:20 <c_wraith> oh, I have that backwards? whoops. 
15:27:32 <davean> c_wraith: You realize UTC Time existed before POSIX, right?
15:27:42 <davean> c_wraith: Yah, by like a decade
15:27:48 <c_wraith> in any case, I think the real problem is that time is *really* hard to do get right. 
15:27:53 <davean> c_wraith: POSIX selected UTC as its basis, instead of n actual TIME standard
15:27:59 <davean> c_wraith: no its not!
15:28:03 <davean> time is pretty easy
15:28:09 <c_wraith> or at least, calendar tracking is super hard. 
15:28:10 <davean> We just have weird ways to display it
15:28:15 <nshepperd1> I've usually seen UNIX time defined as the number of seconds since the epoch
15:28:21 <davean> nshepperd1: its not
15:28:29 <davean> nshepperd1: thats just wrong
15:28:31 <nshepperd1> Except it's not
15:28:33 <nshepperd1> Yeah
15:28:36 <c_wraith> nshepperd1, only by people who haven't looked at the definition. :) 
15:29:00 <hexagoxel> > [[show (x,y) | y <- [4,5,6]] | x <- [1,2,3]] -- geppettodivacin: list comp is nice, too.
15:29:03 <lambdabot>  [["(1,4)","(1,5)","(1,6)"],["(2,4)","(2,5)","(2,6)"],["(3,4)","(3,5)","(3,6)"]]
15:29:46 <Tuplanolla> I once ran `ntpdate` on a server to adjust its clock, which had drifted a few minutes. All connections were promptly dropped. I was overcome by confusion and, after a while, enlightened disappointment.
15:30:12 <c_wraith> davean, the problem is that most people want easy calendar tracking, and don't care how poorly that matches reality. 
15:30:22 <davean> c_wraith: Display from TAI is easy
15:30:38 <davean> c_wraith: infact, its a subset of what is required to keep time in UTC
15:30:42 <davean> so ...
15:30:48 <c_wraith> davean, so any interface that exposes them to the true complexity of the problem is rejected. 
15:31:02 <davean> c_wraith: They already do local conversion
15:31:15 <davean> It can be just handled in there as part of that
15:31:19 <hexagoxel> geppettodivacin: i'll leave it to you to produce a string from that; hint: you do not need any additional `map`ping.
15:31:54 <davean> Tuplanolla: Yah, a relative time basis is better 
15:31:58 <davean> Tuplanolla: for that
15:32:08 <davean> Tuplanolla: which is why I mentioned 'clock' to amx 
15:32:22 <polo_> I need to define length function using lambda expression.Also I cannot define the arguments of the function.I did the following:lengthLambda = (\ (x:xs) -> 1 + \ (xs) But getting error.
15:32:45 <c_wraith> davean, people do t just want display, they want arithmetic. "same time tomorrow" is far easier I  UTCTime than TAI
15:33:07 <c_wraith> wow, typos abound. don't. in. 
15:34:06 <nshepperd1> Unless there's a dst change tonight
15:34:22 <davean> nshepperd1: right
15:34:31 <Tuplanolla> People want all formal languages to be regular too.
15:34:32 <davean> Thats already fucked in UTC
15:34:42 <davean> you already need proper calculation functions
15:34:47 <davean> again, you saved nothing
15:34:52 <nshepperd1> Then you have to think about whether you want "approximately 24 hours" or "same local time tomorrow"
15:35:04 <Tuplanolla> Why does parsing have to be so hard? Maybe it wouldn't be if we wanted hard enough.
15:35:09 <davean> nshepperd1: and both of those are easy to do
15:35:52 <joe9_> davean: so, where do I find more info on TAI?
15:36:31 <davean> joe9_: Uh, you aren't going to end up using it. YOu'll just spend the rest of your programming life regretting that its too hard. The problem is the system clock is in UTC so you can't know what time it actually is so you can't work in TAI
15:36:32 <joe9_> davean: is there a recommended haskell library providing TAI?
15:36:38 <davean> joe9_: 'time' does
15:36:49 <davean> joe9_: but again, you're computer can't actually tell you the time because its already converted it to UTC
15:37:08 <davean> and lost that information
15:37:18 <davean> well, the kernel sorta knows but has no API for informing you
15:37:28 <joe9_> davean: what do you recommend I do? just use UTCTime of Data.Time?
15:37:42 <davean> joe9_: yah, and be aware of everything that will break
15:38:23 <Tuplanolla> If you want the future to come after the past, use a monotonic clock, davean. For other kinds of timekeeping, use UTC.
15:38:38 <davean> Tuplanolla: I already mentioned 'clock' ;)
15:38:58 <joe9_> Tuplanolla: So, where do I find how to use the monotonic clock? "clock" package?
15:39:08 <davean> joe9_: yes
15:39:10 <polo_> Hello, I'm trying to make a length like function using lambda expression: lengthLambda = (\ (x:xs) -> 1 + \ (xs))
15:39:13 <Tuplanolla> Yes, but I wanted to point out that you hardly ever need to mix relative high-precision clocks with "absolute" clocks.
15:39:13 <davean> but that only gives you relative time
15:39:16 <polo_> please sb help me
15:39:47 <joe9_> https://hackage.haskell.org/package/clock correct? davean?
15:39:59 <davean> joe9_: basicly theres 3 types of time: Ordinal (Integer is good for this), Relative (Use 'clock'), and Absolute (TAI, but you'll use UTC - both in 'time')
15:40:02 <davean> joe9_: yes
15:41:46 <joe9_> what does "TAI" stand for? if you do not mind me asking.
15:41:56 <Tuplanolla> https://en.wikipedia.org/wiki/International_Atomic_Time
15:42:01 <davean> joe9_: Time Atomic International
15:42:22 <davean> joe9_: Its 19 seconds off of GPS time, which is basicly the same
15:42:37 <joe9_> davean: there is no mention of TAI here https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/time-1.2.0.3/Data-Time-Clock.html . I understand that TAI /= UTCtime.
15:42:37 <Tuplanolla> Crafty Frenchmen have permuted the words again.
15:42:44 <davean> joe9_: look up
15:42:59 <davean> joe9_: hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Clock-TAI.html
15:43:16 <davean> joe9_: time has a lot of modules, you just looked in the one not named "TAI"
15:43:19 <younder> ghc -fllvm is the way to opimize ghc. (as methioned to me yesterday -fvia-C is dosen't work)
15:43:37 <joe9_> davean: got it, I was looking at an older version.
15:43:43 <geppettodivacin> hexagoxel: Tuplanolla: I got it working! Thanks so much! http://lpaste.net/328884
15:43:45 <davean> joe9_: ... how old?
15:44:00 <Tuplanolla> Take a look at `unlines`, geppettodivacin.
15:44:01 <joe9_> 1.2 Thanks a lot for correcting it.
15:44:02 <davean> joe9_: TAI has always been in 'time'
15:44:08 <davean> 1.2 has TAI also
15:44:13 <davean> same place infact
15:44:45 <davean> joe9_: You'll note theres also a "POSIX" module
15:44:53 <joe9_> davean: my mistake. I was looking here https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/time-1.2.0.3/Data-Time.html
15:45:10 <davean> Yes, its not exported by default, always look at the actual module listing
15:45:20 <davean> hackage.haskell.org/package/time
15:45:31 <davean> Rarely will you find a package that exports all its modules from one top level module
15:45:39 <joe9_> davean: ok, Thanks.
15:45:56 <joe9_> davean: why do you mention the POSIX module?
15:46:07 <joe9_> davean: Is there anything that you recommend using from that module?
15:46:10 <davean> joe9_: Because often one has to work in POSIX time
15:46:20 <davean> joe9_: well, if you have to work in POSIX time, all of it?
15:46:34 <nshepperd1> I guess in practice tai vs utc isn't going to matter, since the local system clock is only going to be "approximately" correct "most" of the time anyway
15:46:47 <davean> nshepperd1: oh no
15:46:50 <amx> so for a monotonic clock you always need kernel support, otherwise the kernel might just change the system clock in the meanwhile, right?
15:46:58 <davean> nshepperd1: it causes massive problems on leap seconds
15:47:05 <davean> amx: yes
15:47:18 <davean> amx: well, mostly
15:47:24 <davean> distributed systems just use Ordinal time a lot
15:47:32 <davean> which is just "happened after" semantics
15:47:45 <davean> in which case theres no actual "distance" between time points and you don't need kernel support
15:47:51 <amx> yeah
15:47:55 <davean> you just have "time 1" then "time 2"
15:48:01 <davean> but otherwise you are correct
15:48:43 <nshepperd1> davean: yeah but when the network breaks and ntp updates the time by 5 seconds it should break too
15:48:44 <davean> nshepperd1: There have been a large number of high profile failures due to this issue
15:48:58 <Tuplanolla> Then there's Boolean time, which divides into "bad time" and "good time". 
15:49:04 <davean> nshepperd1: no, leap seconds happen with no breakage
15:49:09 <nshepperd1> So as long as you expect the system time to be wrong, you won't be disappointed :)
15:49:35 <joe9_> davean, taiEpoch for getting the current time, correct? the only reason I ask is that it is a pure function
15:49:46 <davean> joe9_: no
15:50:08 <davean> joe9_: an "Epoch" is a begining of a timebasis
15:50:17 <joe9_> no, that is just a constant.
15:50:28 <davean> right
15:50:28 <joe9_> davean:  Thanks. How do I get the current time?
15:50:31 <davean> epochs always are
15:50:52 <joe9_> like the getCurrentTime of UTCTime?
15:50:56 <davean> joe9_: as I said, thats the problem, since your system is in UTC and theres no way to convert to TAI from UTC because UTC is lossy you simply can't
15:51:16 <davean> a given UTC time can be multiple TAI times, since UTC can repeat time
15:51:18 <davean> etc
15:51:21 <joe9_> davean: How do I use it then?
15:51:30 <davean> joe9_: as I said, its too hard
15:51:39 <davean> joe9_: The only real way to use it ... well
15:51:46 <nshepperd1> Google's problem was having a too well configured ntp setup, so that programmers started expecting system time to not suddenly be wrong by a few seconds
15:52:03 <nshepperd1> Damn them, expecting quality
15:52:11 <davean> theres utcToTAITime
15:52:29 <davean> joe9_: but to use that you have to download a leapsecond file and to use it RIGHT you have to actually run NTP yourself
15:52:45 <davean> joe9_: as I said, you simply won't use TAI
15:52:48 <joe9_> I am running an ntp-client .
15:52:52 <davean> no, no
15:52:55 <davean> a client isn't enough
15:53:13 <davean> you have to have your program actually run the protocol
15:53:23 <davean> because it has to know what UTCTime it is *and* if its a leap second currently
15:53:33 <davean> or you ahve to at least wait untill after the leap second
15:53:39 <davean> which you can do with the leap second table
15:53:49 <nshepperd1> Trying to set up a Linux system running a tai system clock sounds like a fun project
15:53:54 <davean> so you might end up with startup delays of up to 2 seconds
15:54:25 <joe9_> davean, if it is such a pita to use, it appears UTCTime is the solution(?)
15:54:35 <davean> joe9_: yes
15:54:41 <davean> joe9_: you're basicly stuck with UTCTime
15:54:49 <joe9_> davean: ok,Thanks.
15:54:51 <davean> I tried to say that early to save you some headache :)
15:54:53 <davean> sorry
15:55:05 <nshepperd1> Yes, utctime is the answer. We're just griping really
15:55:16 <davean> nshepperd1: Oh no, I use TAI
15:55:43 <davean> nshepperd1: I also have some libraries that work around the leapsecond problem to various degreed
15:56:06 <nshepperd1> davean: in your system clock? Or do you do an embedded ntp client?
15:56:37 <davean> nshepperd1: the later, and I also have the 'delay' package that "shits its self less"
15:57:35 <davean> nshepperd1: though I couldn't decide what the "correct" functionality should be
15:58:09 <hololeap> say there is a data declaration like `data Day = Sunday | Monday | Tuesday | ... | Saturday`. is there a function to repeat them infinitely in a list ([Sunday, Monday, ... Sunday, Monday, ...])
15:58:38 <davean> hololeap: see "cycle" in Data.List?
15:59:33 <hololeap> davean: cool, is there an easy way to iterate over the elements in a data type like that (where each constructor takes no arguments)
15:59:36 <davean> nshepperd1: I'm mildly insulted you thought I'd actually write software so poorly as to use UTCTime :-p
15:59:44 <davean> hololeap: hum? What do you mean?
15:59:50 <nshepperd1> Lol
16:00:02 <davean> nshepperd1: I have low standards, but they're not THAT low
16:00:17 <gu_______> hi guys. am i able to ask questions about haskell here?
16:00:22 <barrucadu> hololeap: If your type is Enum and Bounded, you can use [minBound..maxBound]
16:00:24 <hololeap> like `getElems Day` returns `[Sunday, Monday, ...]` ... something like that
16:00:24 <davean> gu_______: you just did
16:00:37 <nshepperd1> davean: is there a pure Haskell ntp client?
16:01:24 <davean> nshepperd1: I think theres an sntp one
16:01:39 <davean> nshepperd1: I need to put together a good haskell library that makes using TAI sane
16:01:50 <Monoide> hololeap: deriving (Enum)
16:01:56 <Monoide> and then cycle [Monday .. Sunday]
16:02:20 <hololeap> davean: barrucadu: Monoide: ok, thanks
16:02:41 <onintza> Is there some (Applicative f, Applicative g) => f (g (a -> b) -> f (g a) -> f (g b)?
16:02:51 <davean> Monoide: That assumes the order
16:02:59 <Monoide> indeed
16:03:03 <davean> hololeap: so, if Sunday isn't the ned of your week theres a problem there
16:03:08 <Monoide> indeed ²
16:03:28 <younder> sntp is just a text protocol. Just open the socket and read the string
16:03:30 <davean> We can use Bounded to solve this
16:04:00 <davean> "cycle $ enumFrom minBound"
16:04:23 <davean> hololeap: This way it asks for a list of all the days coming after the first day in the week
16:04:38 <davean> hololeap: this won't break if you change the week bounds
16:04:53 <davean> Monoide: Do you agree thats better?
16:04:58 <MarcelineVQ> onintza: you are missing a ) somewhere
16:05:19 <onintza> MarcelineVQ: oh, sorry! (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)?
16:06:58 <davean> nshepperd1: theres ntp-control
16:07:02 <Tuplanolla> :t fmap (<*>)
16:07:03 <Tuplanolla> :t fmap . (<*>)
16:07:06 <lambdabot> (Applicative f1, Functor f) => f1 (a -> b) -> f (f1 a) -> f (f1 b)
16:07:07 <lambdabot> (Applicative f1, Functor f) => f (f1 (a -> b)) -> f (f1 a -> f1 b)
16:07:08 <onintza> The reason for this being I'm using applicative style to write point free functions which need to handle Maybes
16:07:09 <davean> nshepperd1: which has the leap info
16:07:12 <Monoide> davean: I guess it is
16:07:34 <jle`> onintza: (liftA2 . liftA2) ($)
16:07:48 <jle`> :t liftA2 ($)
16:07:54 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
16:07:55 <jle`> :t (liftA2 . liftA2) ($)
16:07:58 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> c)) -> f (f1 a) -> f (f1 c)
16:08:02 <jle`> :t (liftA2 . liftA2 . liftA2) ($)
16:08:04 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => f (f1 (f2 (a -> c))) -> f (f1 (f2 a)) -> f (f1 (f2 c))
16:08:11 <onintza> wohow!
16:08:15 <jle`> you can go as deep as you want with more liftA2's :)
16:08:19 <onintza> Thanks both
16:08:22 <jle`> liftA2 lifts an (a -> b) to f a -> f b
16:08:30 <jle`> er, an (a -> b -> c) to f a -> f b -> f c
16:08:36 <onintza> I'm trying to get my head around fmap . (<*>)
16:08:38 <jle`> so it lifts it up one layer
16:08:55 <jle`> (liftA2 . liftA2) lifts two layers, (liftA2 . liftA2 . liftA2) lifts three layers, etc.
16:09:04 <jle`> it's analogous to (fmap . fmap . fmap) and friends
16:09:13 <jhartley> exit
16:09:24 <jhartley> woops, sorry
16:09:41 <pakettiale> :))
16:09:51 <jle`> @unpl fmap . (<*>)
16:09:52 <lambdabot> (\ x -> fmap ((<*>) x))
16:10:11 <onintza> What's unpl?
16:10:14 <jle`> i don't think it's the same thing as what you wanted
16:10:25 <jle`> onintza: it adds the points back to functions made with (.) and friends
16:10:33 <jle`> @unpl f . g
16:10:33 <lambdabot> (\ x -> f (g x))
16:10:39 <onintza> Oh, handy
16:10:40 <jle`> @pl \x -> f (g x)
16:10:40 <lambdabot> f . g
16:10:55 <jle`> fmap . (<*>) isn't what you want
16:11:00 <jle`> but liftA2 (<*>) would work
16:11:13 <jle`> that's because (<*>) = liftA2 ($)
16:11:31 <jle`> so (liftA2 . liftA2) ($)  => liftA2 (liftA2 ($)) => liftA2 (<*>)
16:11:35 <onintza> My god
16:11:40 <jle`> but i think (liftA2 . liftA2) ($) is a bit more readable
16:11:48 <jle`> it just means that you're lifting function application two levels
16:12:07 <onintza> :t liftA2
16:12:09 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:12:14 <jle`> just like how (fmap . fmap) negate is liftning 'negate' two levels
16:12:24 <jle`> > (fmap . fmap) negate [Just 3, Nothing, Just 2]
16:12:27 <lambdabot>  [Just (-3),Nothing,Just (-2)]
16:13:11 <onintza> :t (liftA2 . liftA2)
16:13:13 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
16:13:43 <onintza> Hah
16:13:59 <jle`> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
16:14:08 <jle`> (liftA2 . liftA2) :: (a -> b -> c) -> f (g a) -> f (g b) -> f (g c)
16:14:28 <onintza> :t (liftA2 . liftA2) ($)
16:14:28 <jle`> (liftA2 . liftA2 . liftA2) :: (a -> b -> c) -> f (g (h a)) -> f (g (h b)) -> f (g (h c))
16:14:29 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> c)) -> f (f1 a) -> f (f1 c)
16:14:48 <jle`> it'it's a little eaiser to see what it's doing if you add the redundant parentheses, too --
16:14:55 <onintza> it slooowly starts to sink in…
16:15:04 <jle`> liftA2 :: (a -> b -> c) -> (f a -> f b -> f c)    -- turn a (a -> b -> c) into an (f a -> f b -> f c)
16:15:28 <jle`> so if you liftA2 something that's already been liftA2'd, you are turning an (f a -> f b -> f c) into a (g (f a) -> g (f b) -> g (f c))
16:15:42 <jle`> and if you liftA2 *that*, it'd be h (g (f a)) -> h (g (f b)) -> h (g (f c)), etc.
16:15:46 <onintza> That makes sense
16:16:28 <onintza> is it sensible to define <**> as (liftA2 . liftA2) ($)?
16:16:59 <jle`> locally, maybe, but it's not a common idiom
16:17:08 <onintza> why not?
16:17:16 <onintza> i mean, are there better workarounds?
16:17:26 <jle`> fairnbarn threshold or something like that
16:17:44 <glguy> There's already a <**>
16:17:54 <jle`> the need is rare enough that the convenience of having it outweighs the cost of having to look it up
16:17:57 <jle`> every time you use it
16:18:01 <hololeap> https://wiki.haskell.org/Tying_the_Knot is helping me understand some things
16:18:12 <onintza> glguy: is there a <$$>?
16:18:17 <jle`> also point-free code in general is not super idiomatic
16:18:27 <jle`> just specific cases
16:18:29 <hololeap> it's really weird to me that you can define variables in terms of each other
16:18:42 <jle`> fun, isn't it? :)
16:18:43 <glguy> onintza: No, but there is a <&>. Also the actual <**> doesn't do what yours does
16:18:53 <onintza> oh, okay
16:19:10 <jle`> onintza: basically the need is so rare that it would take more time to look it up and remember it than to just use the easily understandable implementation
16:19:18 <jle`> and also it clutters up namespace/operatorspace
16:19:25 <jle`> and nobody likes adding more operators too, heh
16:19:45 <onintza> jle`: yeah, now that i know it is possible to do i'm trying to figure out how i could rewrite it to not need it
16:19:47 <jle`> but yeah, same reason there's no "takeFourPlusOne = take 5" in the library.   it's easier and more readable to just write take 5
16:20:15 <jle`> and the need to take exactly 5 is pretty rare
16:20:36 <jle`> better to just offer simple combinators like 'take' and 5 to let users express the code they want using simple building blocks
16:21:06 <suppi> why doesn't `:sprint x` show `1` after doing `seq x ()` where x = 1 in ghci?
16:21:10 <jle`> onintza: are you trying to obfuscate code?
16:21:18 <suppi> this is ghci 8.0.1
16:21:25 <jle`> suppi: DMR perhaps
16:21:32 <jle`> or, lack of
16:21:38 <onintza> jle`: haha no
16:21:42 <suppi> jle`: what is DMR?
16:21:54 <suppi> dreaded monomorphism restriction?
16:22:00 <jle`> yeah.  except in ghci it's turned off
16:22:09 <jle`> so the lack-of-dreaded-monomorphism-restriction is what's causing your problems
16:22:18 <jle`> if you let x = 1 in ghci, x :: Num a => a
16:22:42 <jle`> so if you seq x (), you're seqing x for a specific instance of Num
16:22:45 <suppi> jle`: thanks
16:22:55 <jle`> and ghc doesn't cache every single possible answer for every possible instance for obvious reasons
16:23:12 <jle`> it's a really easy way to get massive space leaks
16:23:34 <suppi> this solves my problem. thanks again :)
16:23:36 <jle`> this is actually one of the main reasons why the MonomorphismRestriction is enabled by default in haskell source files
16:23:50 <jle`> perhaps *the* main reason actually, heh
16:23:57 <jle`> no problem!
16:44:01 <dgpratt> I'm trying to ask some CT questions in #Haskell-blah, but no bites so far
17:04:31 <dgpratt> you around Cale ?
17:13:45 <gues_____> can someone explain what this type declaration even means? eitherMap :: (a -> c) -> (b -> d) -> Either a b -> Either c d
17:14:45 * hackagebot lin-alg 0.1.0.3 - Low-dimensional matrices and vectors for graphics and physics  https://hackage.haskell.org/package/lin-alg-0.1.0.3 (JasonDagit)
17:15:07 <Tuplanolla> :t Data.Bifunctor.bimap -- It's a special case of this, gues_____.
17:15:10 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
17:17:07 <c_wraith> I don't think that's likely to help. 
17:17:36 <Tuplanolla> It provides a search term for further reading.
17:17:57 <gues_____> i just tried to search the difference between => and ->, but nothing came up
17:18:04 <c_wraith> gues_____, it is a function that takes functions that operate on each side of the Either, and returns a function that uses them to transform the Either. 
17:18:40 <geekosaur> gues_____, given a function that can produce a c from an a, and a function that can produce a d from a b, this function changes an Either a b (a value Left a or Right b) to an Either c d (a value Left c or Right d)
17:19:54 <gues_____> hmm ok i think i understand. another question though, how does it know it takes 3 arguments?
17:20:47 <onintza> Some shortcut to "\(n, cs) -> (,) n <$> (f cs)" ?
17:21:25 <gues_____> huh.... ok thanks
17:22:04 <dgpratt> gues_____: are you asking why eitherMap is a function of three arguments?
17:22:08 <nitrix> quit
17:22:40 <gues_____> i'm just wondering how it knows to take 3 and 3 only. is that from the type declaration?
17:22:46 <dgpratt> you can't quit us nitrix 
17:22:57 <gues_____> or perhaps it's defined somewhere else in my file
17:23:14 <onintza> gues_____: you know it from the type declaration
17:23:23 <dgpratt> 1. (a -> c), a function from a to c, 2. (b -> d), a function from b to d, and 3. Either a b, the Either data type parameterized by types a and b
17:24:16 <gues_____> hmm ok thanks
17:24:31 <onintza> gues_____: if you pass it only one argument, it will return a function :: (b -> d) -> Either a b -> Either c d
17:24:46 * hackagebot tianbar 1.2.0.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.2.0.0 (AlexeyKotlyarov)
17:24:54 <onintza> if, to that function, you pass a parameter :: (b -> d), you will get a funtion :: Either a b -> Either c d
17:24:54 <gues_____> i see
17:24:57 <onintza> and so forth
17:25:19 <onintza> you can give it 0, 1, 2 or 3 arguments
17:25:31 <gues_____> so the a -> c is passed in as b?
17:25:42 <onintza> No
17:25:54 <onintza> (a -> c) is the type of the first parameter it expects
17:26:13 <onintza> So it expects a function from as to cs as the first parameter
17:26:13 <gues_____> and that is a function?
17:26:16 <onintza> yes
17:27:15 <gues_____> i see thanks
17:27:16 <dgpratt> that means that eitherMap is a "higher order" function: a function that takes other functions as inputs
17:27:30 <dgpratt> not at all unusual in Haskell
17:28:04 <gues_____> hmm yes that makes sense
17:28:08 <geekosaur> moreover, you can argue that it *produces* a function
17:28:45 * dgpratt loves to argue
17:29:00 <dgpratt> or so my wife tells me
17:29:08 <geekosaur> the fully parenthesized form of its type is (a -> b) -> ((c -> d) -> (Either a b -> Either c d))
17:29:15 <geekosaur> (this is how partial application works)
17:29:29 <gues_____> that makes more sense
17:29:31 <geekosaur> but you can read that as: (a -> b) -> (c -> d) -> (Either a b -> Either c d)
17:29:41 <onintza> type declarations are right associative
17:29:56 <onintza> function application is left associative
17:30:30 <geekosaur> so give it two functions to convert each "side" of the Either, and it gives you a function that converts the whole Either
17:30:31 <onintza> function application "undoes" the type declaration
17:31:11 <dgpratt> ah, that's an interesting point
17:31:47 <younder> accelatete-cuda filas to buid. reports ... Data/Array/Accelerate/CUDA/Analysis/Launch.hs:91:3: Not in scope: ‘CUDA.optimalBlockSizeBy’
17:32:06 <younder> s(/ilas/fails/
17:33:07 <younder> Has anyone else experienced problems building this package?
17:34:55 <geekosaur> "All reported builds failed as of 2016-10-26" (hackage)
17:35:08 <geekosaur> it has only a lower bound on the cuda package, which probably changed incompatibly
17:36:43 <younder> geekosaur, Sounds reasonable. Cuda 8.0 was just released. (needed for the NV 1000 series)
17:43:49 <gues_____> is there a way to compare types? like :t 5 == :t 4?
17:44:06 <gues_____> it seems like there isn't from what i searched, but just want to confirm
17:44:20 <geekosaur> types are not values, so you can't compare them that way
17:44:22 <geekosaur> *but*
17:44:29 <geekosaur> see Data.Typeable
17:44:49 <jle`> > typeOf True == typeOf "hello"
17:44:51 <lambdabot>  False
17:44:56 <jle`> > typeOf True == typeOf Bool
17:44:58 <lambdabot>  error:
17:44:58 <lambdabot>      • Data constructor not in scope: Bool
17:44:58 <lambdabot>      • Perhaps you meant variable ‘bool’ (imported from Data.Bool)
17:45:02 <jle`> heh
17:45:05 <jle`> > typeOf True == typeOf False
17:45:07 <lambdabot>  True
17:45:14 <jle`> ^ gues_____ 
17:45:26 <geekosaur> ...note that this describes a type as a value, which means that description can't be used as a type
17:45:29 <c_wraith> Or...  https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Type-Equality.html  If you want to get really deep into it.  Though that's probably too much to take in all at once.
17:46:03 <onintza> gues_____: there is no common need to compare types in haskell
17:46:21 <gues_____> oh
17:46:33 <jle`> but yeah, i've very very rarely had to compare types like this
17:46:37 <c_wraith> In general, you either know what type something is, or you don't care.
17:46:44 <jle`> it's usually a sign that you are approaching things the wrong way
17:46:48 <c_wraith> There are exceptions, but they are rare.
17:46:53 <gues_____> ok i will avoid doing that thanks
17:47:00 <jle`> XY problem etc.
17:48:22 <c_wraith> Man, the implementations for everything in Data.Type.Equality are kind of hilarious.  If you have GADTs, I guess there's no real difficulty in doing what it does.
17:49:20 <jle`> heh
17:49:23 <jle`> yeah most of them are useful combinators
17:49:29 <jle`>  /utility functions
17:50:47 <c_wraith> Everything is like..  foo Refl Refl = Refl
17:51:07 <c_wraith> All the action is happening in the type signature and in the type refinement when matching a GADT
17:53:36 <maerwald> amazing
18:06:14 <Cale> dgpratt: hi
18:06:38 <dgpratt> hi Cale
18:06:46 <Cale> What's up? :)
18:06:54 <hpc> c_wraith: i hope someday haskell gets "IDE" support as good as agda's
18:07:03 <hpc> (in quotes because it's really just text editor plugins)
18:07:08 <dgpratt> I had a CT question and...I thought of you :)
18:07:44 <Cale> If ever I'm not around, ##categorytheory might know :)
18:07:45 <dgpratt> Cale: would you be willing to pop over to #Haskell-blah for a few minutes?
18:08:00 <Cale> If they'll switch off encryption
18:08:01 <dgpratt> oh, didn't know about that one
18:08:09 <Cale> Otherwise, we'll have to use #haskell-offtopic ;)
18:34:49 <gues_____> guys i'm confused. a return type of Either a b is just something like Left a or Right b?
18:35:26 <hpc> yep
18:35:36 <c_wraith> gues_____: Either is a type.  Left and Right are constructors for values of that type
18:35:48 <c_wraith> gues_____: remember to keep type and value levels separate.
18:35:48 <hpc> (Left a) is a value, as is (Right b), assuming values a and b
18:36:14 <hpc> or yeah, to disambiguate (Left va) is a value of type (Either ta tb)
18:36:19 <hpc> as is (Right vb)
18:36:25 <hpc> if va :: ta, vb :: tb
18:37:03 <c_wraith> @src Either
18:37:04 <lambdabot> Source not found.
18:37:14 <c_wraith> Huh.  Didn't expect that.
18:37:28 <hpc> data Either a b = Left a | Right b
18:37:45 <hpc> or if it might make things easier, in GADT syntax:
18:37:48 <hpc> data Either a b where
18:37:53 <hpc>   Left :: a -> Either a b
18:37:58 <hpc>   Right :: b -> Either a b
18:38:10 <hpc> they're both the same, pick whichever confuses you less ;)
18:38:26 <gues_____> that is even worse. i was looking at that earlier
18:38:29 <gues_____> hah
18:40:17 <gues_____> ugh i don't know why this is confusing me. if i make a data type: data Tree = Empty | Node, I understand a Tree can contain Empty or Node. but if i did: data Tree a b = Empty | Node. what do a and b represent
18:40:41 <hpc> gues_____: right now, they're phantom types
18:40:50 <hpc> gues_____: they're part of the type, but have no bearing on anything at the value level
18:43:28 <gues_____> hmm all right thanks lol
18:44:56 <hpc> gues_____: eventually you'll find there are some pretty neat things to be done with phantom types, but for now you can look at them like the type-level version of const
18:45:11 <hpc> like, data Tree _ _ = Empty | Node
18:45:26 <gues_____> ah
18:46:31 <gues_____> do the variables in type declarations need to match the ones in patterns?
18:46:49 <hpc> yeah
18:47:01 <gues_____> ok thanks
18:47:03 <coleman> any convenient way to turn [1,2,3] into [[1,2],[1,3],[2,3]]?
18:47:56 <hpc> > join (liftA2 (\x y -> [x, y])) [1, 2, 3]
18:47:58 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
18:48:33 <hpc> coleman: what do you want it to do on longer lists?
18:48:39 <hpc> or just in general
18:48:54 <latro`a_> looks like, pick any one value and then any one value that falls after it
18:49:19 <coleman> hpd: same thing [1,2,3,4] -> [[1,2],[1,3],[1,4],[2,3],[2,4]....
18:49:34 <coleman> hpd: maybe your liftA2 will do it?
18:50:30 <hpc> is it actually something like [1 .. n] or is it any list of things?
18:51:04 <hpc> > [[x, y] | x <- [1 .. 3], y <- [x .. 3]]
18:51:06 <lambdabot>  [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
18:51:19 <coleman> hpc: finite list of anything
18:51:19 <hpc> > [[x, y] | x <- [1 .. 3-1], y <- [x+1 .. 3]]
18:51:21 <lambdabot>  [[1,2],[1,3],[2,3]]
18:51:28 <hpc> ah, hmm
18:52:05 <hpc> you'll have to write something for it
18:52:06 <coleman> hpc: I need all possible combinations in groups of two
18:54:17 <hpc> i would expect it to be a 4-line function or so, and it'd be involved on the last line but not terrible
18:54:37 <hpc> cases for [], [_], [x, y], and x:y:xs
18:59:28 <gues_____> so i'm trying to make a function that will pass this test case Left 15 ~=? eitherMap add10 take2 (Left 5). i have a pattern that basically does, if it's asking for Left, i will do either add10 add10 (Left 5) again. does this seem reasonable?
19:00:30 <gues_____> OH i didn't realize the test case asked for Left 15 instead of just 15
19:03:26 <gues_____> ok so i don't really understand what's the point of maybe. at first, i thought it was smart, and it allowed you to input any of the two types, without including "Left" or "Right", and it would know which function to apply. but if you have to say either "Left" or "Right", couldn't you just apply the function directly?
19:03:40 <gues_____> err not maybe, i meant either
19:06:26 <vikraman> hello, is it possible to write something close to this in ghc 8.0?
19:06:28 <vikraman> f1 :: Bool -> *
19:06:30 <vikraman> f2 :: b:Bool -> f1 b
19:16:40 <hrqaa> I'm working on extracting data from a tries I built. Could I get some high-ish level guidance on the approach?
19:17:15 <hrqaa> the form of my tries are data Trie = Root [Trie] | Node Char Int [Trie]
19:19:46 <dmj`> hrqaa: interesting representation
19:20:30 <dmj`> hrqaa: might get better asymptotics on lookups if you go with a Map
19:20:35 <dmj`> data Trie a = Trie { value :: Maybe a , children :: M.Map Char (Trie a) } deriving (Show, Eq)
19:21:02 <dmj`> hrqaa: but go ahead and ask your questions
19:21:51 <hrqaa> So i'm not entirely sure how to do lookups or retrieve values at all. Like I want to pass through the trie recurively somehow to build out a list of strings again
19:23:23 <pavonia> vikraman: What does "b : Bool" denote in that type?
19:23:27 <hrqaa> Should I be modifying the list? Just loop until I find positive values and then decrement their values n on the way out?
19:24:03 <hrqaa> I'm not sure how I'd modify the, since this function returns strings not another Trie
19:24:18 <hrqaa> Or maybe that's the point, I need to return a tuple with the list i've built so far the the remaining trie?
19:24:20 <vikraman> pavonia: well, I guess I meant b :: Bool -> f1 b
19:24:43 <vikraman> I just saw on the ghc wiki that pi will be available in phase 2 of dependent types, so that answers my question 
19:26:05 <hrqaa> @dmj` you still around?
19:26:05 <lambdabot> Unknown command, try @list
19:26:14 <hrqaa> dmj`,  you still around?
19:27:06 <dmj`> hrqaa: yea
19:28:17 <dmj`> hrqaa: if you go with the representation I have above, lookups are very simple, and you can take advantage of the maybe monad very nicely
19:28:42 <hrqaa> dmj`, a bit too new with monads
19:28:49 <hrqaa> dmj`, Learning :/.
19:29:25 <dmj`> hrqaa: the best way to learn monads in practice is to implement a lot of different monad instances, starting with the simplest
19:29:55 <hrqaa> dmj`, And also time constraint :/ Is it possible to do what I'm looking at with my constructor?
19:30:45 <dmj`> hrqaa: it seems like you're trying to implement `elems` on your representation, Trie a -> [a], where all entries are returned
19:31:10 <hrqaa> dmj`, What do you mean by that?
19:31:22 <hrqaa> Oh wait, never mind I understand
19:31:32 <hrqaa> Not sure how to implement though
19:32:16 <dmj`> hrqaa: Is Root [Trie] necessary?
19:32:29 <Welkin> damn it keter
19:32:44 <Welkin> does anyone know if keter has trouble with filenames that include "-" in them?
19:32:47 <dmj`> hrqaa: I guess you can build a trie in terms of a rose tree
19:32:49 <Welkin> it says it can't find the file
19:32:54 <hrqaa> dmj`, I don't think so but the root of the tree doesn't hold a char and an int
19:32:54 <Welkin> but it is right there
19:33:38 <dmj`> hrqaa: have you considered Data.Trie
19:34:30 <hrqaa> no. i'll look at how it's implemented in there for guidance
19:35:14 <hrqaa> I'm not sure I have enough time to change the entire structure at this point
19:36:43 <Welkin> god damn
19:37:02 <dmj`> hrqaa: is this homework
19:37:03 <Welkin> I've been writing shell scripts and doing other hacky things for hours now
19:37:37 <hrqaa> dmj`, Yes
19:37:47 <hrqaa> dmj`, It's part of a project
19:38:07 <Welkin> a porject
19:38:43 <Welkin> dmj`: did you go to the parade?
19:39:45 <hrqaa> dmj`, Is what I said about a tuple with the list I've build and the trie valid??
19:39:59 <hrqaa> built*
19:41:44 <dmj`> Welkin: I'm in #haskell-offtopic
19:42:08 <hrqaa> dmj`, Any chance you could answer that question?
19:42:18 <hrqaa> dmj`, I'm not looking for answers, just guidance
19:43:40 <dmj`> hrqaa: If it's not imperative you build a trie from scratch, I'd use Data.Trie, otherwise, I'd take a look at my ref. implementation
19:43:42 <dmj`> hrqaa: https://gist.github.com/dmjio/eba15496984682e10ef57356fb4b59bf
19:44:16 <dmj`> hrqaa: I can't speak to the validity of using a tuple
19:45:04 <hrqaa> dmj`, You just have a lookup, not a function that would reconstruct the list, right?
19:45:25 <dmj`> hrqaa: I bet I can implement to list
19:45:26 <dmj`> one second
19:50:06 <Welkin> why is this happening???
19:50:12 <Welkin> why can't keter find the file?
19:51:10 <Welkin> Data.Conduit.Process.monitorProcess: [...]: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
19:58:55 <xpika> when using optparse applicative and a subparser, how do you display the subparser flags by default in the initial --help screen?
20:00:36 <Clint> xpika: be more specific
20:01:53 <Welkin> fucking keter
20:02:07 <Welkin> wtf is going on
20:04:49 <xpika> Clint: I'm using the subparser function in optparse applicative and it shows (Available commands: <COMMAND> desc) but those commands have flags you can only see if you run  ./binary <COMMAND> --help and not just ./binary --help
20:06:21 <xpika> Clint: in my case I have a subcommand "edit" which has a strOption (long "editor") which cannot be seen just when typing ./binary --help but when you type ./binary edit --help it shows you the --editor option
20:08:03 <athan> rofl Welkin 
20:08:07 <athan> I've never used it :x
20:08:21 <athan> why not nginx? does keter do some kind of scaling too?
20:11:37 <Welkin> scaling?
20:11:42 <Welkin> I'm just trying to get it *running*
20:14:56 * hackagebot stt 0.1.0.0 - A monad transformer version of the ST monad  https://hackage.haskell.org/package/stt-0.1.0.0 (mckeankylej)
20:15:07 * geekosaur tempted to ask if it's finding the ld.so... that's a stealth way to get that particular error
20:15:26 <Welkin> I have it set up to run two applications
20:15:29 <Welkin> it runs the first just fine
20:15:34 <Welkin> the second one gives an error
20:15:42 <geekosaur> (just like the program in a #! line of a shell script being missing. an errno isn't enough data for it to indicate which part failed...)
20:15:53 <Welkin> it's just a tar that it unpacks into a temp directory and then runs the application from there
20:20:45 <Welkin> even when I cd into the directory and run ./server, it tells me that the file doesn't exist
20:20:48 <Welkin> O.o
20:21:00 <Welkin> but it is right there when I `ls`
20:23:06 <geekosaur> run ldd on it
20:23:18 <geekosaur> this really does sound like the ld.so is missing/wrong
20:23:54 <Welkin> what do I look for?
20:24:32 <Welkin> I can run the file perfectly fine on my local machine
20:24:45 <Welkin> but one I scp it to the server it doesn't work
20:24:50 <Welkin> once*
20:24:53 <geekosaur> it should report an error if it can't find the ELF interpreter, which it normally lists last
20:25:08 <Welkin> there were no errors
20:25:11 <Welkin> let me try on the server
20:25:23 <geekosaur> alternately "strings - theprogram" (note bare - with spaces around it) and check the first line of output
20:25:37 <geekosaur> and yes, this on the server. you already know it works on the local machine
20:26:00 <Welkin> no errors there either
20:26:06 <Welkin> but that is strange
20:26:07 <geekosaur> wrell, the strings you can do locally and then check the server machine to see if that file exists
20:26:12 <Welkin> my server does not have nix on it
20:26:45 <geekosaur> like when I use "strings -" on a program on my desktop the first line is /lib64/ld-linux-x86-64.so.2
20:26:53 <geekosaur> which is the ELF interpreter/dynamic loader
20:26:57 <Welkin> but in the ldd output, the last line (glibc) lists a nix store location?
20:27:05 <geekosaur> oh, dear
20:27:18 <geekosaur> yes, that's your problem
20:27:40 <geekosaur> hm, no, glibc is the last line? no ld(something).so?
20:28:25 <Welkin> yeah, ld-linux-x86-64.so.2
20:28:42 <geekosaur> the ELF interpreter would be output by ldd with a full pathname and no =>, because at that point it can't search for it and must have a full path
20:28:52 <geekosaur> and the full path must exist on the server
20:28:59 <Welkin> my other app binary lists it as `/lib64/ld-linux-x86-64.so.2`
20:29:03 <geekosaur> yes
20:29:06 <geekosaur> that's the standard path
20:29:35 <geekosaur> if the ELF interpreter in the other one got pathed as a nix location then you will have problems on machines without nix
20:29:52 <Welkin> this one is prefixed with a nix store location and => 
20:30:02 <geekosaur> ummm
20:30:26 <Welkin> that doesn't make sense... does it?
20:30:43 <Welkin> I should just switch to nixos already for deployment...
20:31:31 <Welkin> geekosaur: any advice? or am I screwed here?
20:33:18 * geekosaur is digging...
20:33:23 <Welkin> okay
20:34:42 <geekosaur> well... this is a thing with nix, it seems
20:35:02 <geekosaur> and they have a program to adjust the interpreter (which they use to point things *to* nix, but you can use it to go the other way)
20:35:20 <geekosaur> patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2
20:35:29 <Welkin> that seems broken
20:35:42 <Welkin> how are you supposed to push binaries to a server from nix then?
20:35:48 <Welkin> include that line every time?
20:36:00 <Welkin> or expect the server to run nixos
20:36:04 <geekosaur> I have no idea. they probably expect you use nix everywhere, or something
20:36:07 <Welkin> huh
20:36:47 <geekosaur> I'd not be surprised if it then reports failure to load a bunch of other shared objects it thinks it should get from nix... although the same patchelf program can be used to edit its rpath to something more standard as well, if the libs are standard
20:37:19 <geekosaur> http://nixos.org/patchelf.html btw
20:38:21 <geekosaur> have fun storming the castle >.>
20:38:51 <Welkin> lol
20:38:53 <Welkin> thanks geekosaur 
20:38:54 <geekosaur> ...or this patchelf is specifically their solution to the problem
20:39:00 <Welkin> I'm trying to just install nix on the server now
20:50:38 <ezyang> Agh, I was so excited about GraphViz+diagrams but it turns out we use graphviz for the edge layout and so now I need to figure out how to get graphviz to lay things out the way I want 
20:50:38 <Welkin> oh wow
20:50:50 <Welkin> I just realized that *all* of the outputs from ldd are nix stores
20:52:48 <geekosaur> yes, whence my comment about rpath
20:53:48 <geekosaur> also, it might just work anyway --- unlike the interpreter/loader, those are looked for in the rpath which has a component in the binary itself and otherwise from /etc/ld.so.conf and/or $LD_LIBRARY_PATH
20:54:26 <geekosaur> so if the libs exist in a different place, ld.so.conf might deal with it for you. this won't work for the intepreter though since that has to be an absolute path
20:56:40 <Welkin> geekosaur: installing nix (and the nix glibc) worked
20:56:44 <Welkin> thanks for the help
21:09:02 <definedwheel> Hello everyone. Is it possible to write a Comonad instance for Maybe?
21:13:05 <jle`> definedwheel: nope
21:13:17 <jle`> not a total one at least
21:13:21 <jle`> what would 'extract' be?
21:14:00 <Welkin> well, it's still not actually working
21:14:10 <Welkin> somehow the applicaton fails to start up reliably
21:14:14 <Welkin> no idea what's wrong
21:14:19 <Welkin> maybe other packages are missing still
21:14:56 <Welkin> dmj`: how do you deploy applications you developed with nix?
21:15:05 <dmj`> Welkin: with nix ops
21:15:16 <Welkin> what if your server does not have nix?
21:15:59 <dmj`> Welkin: tough then
21:16:17 <Welkin> ...
21:16:22 <dmj`> Welkin: are you using AWS or GCE?
21:16:28 <Welkin> digital ocean
21:16:52 <definedwheel> jle: Yeah, extract for Nothing in my code is undefined. I just want to understand, how comonads and OOP are related, and how I can write something like Car class in haskell
21:17:00 <dmj`> Welkin: don't think there's nixops support for DO yet. Why not just switch to GCE
21:17:12 <Welkin> why would I?
21:17:13 <jle`> definedwheel: there's that Tekmo article about how comonads are related to objects in OOP, but i don't really buy it
21:17:17 <Welkin> I'm already set up on DO
21:17:19 <jle`> i think it's not a mainstream opinion
21:17:20 <Welkin> and it's cheap
21:17:43 <dmj`> Welkin: AWS has very small instances now, very cheap. Could use nixops for that
21:17:57 * geekosaur has heard various refutations of the Tekmo article
21:17:59 <Welkin> I hate using ec2
21:18:03 <geekosaur> apparently it's a bit of a stretch
21:18:31 <Welkin> dmj`: so really, that's it then?
21:18:45 <Welkin> you have to use nix everywhere for it to work?
21:18:53 <jle`> definedwheel: in case you haven't seen it, it's http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html , but
21:18:57 <jle`> its premise is highly contested
21:19:06 <Welkin> because I installed all the same nix packages on my server and it still won't actually work
21:19:25 <dmj`> Welkin: let's go offtopic
21:19:55 <definedwheel> jle: I know about that article, in fact, thats why I am interested. I kinda don't care about opinions and holywars, I seek an understanding of comonads. 
21:20:28 <jle`> definedwheel: the best way is to just look at specific instances
21:20:31 <jle`> same way as you'd learn about monads
21:21:01 <jle`> the problem with comonads that you don't have with monads is that there aren't as many popular instances that you might have run into while doing normal haskell
21:21:36 <jle`> work with them, write programs with them, etc.
21:21:44 <jle`> and eventually you'll build up an intuition :)
21:22:09 <jle`> one of my favorite instances is 'Store', but that's not one that you would have run into normally
21:22:28 <definedwheel> jle: Yeah, I just tried to implement them first. Like yeah, comonads are dual to monads, and map fancy to non-fancy, but I wanna use that in my code, and understand, why would I do that.
21:22:43 <jle`> definedwheel: this article is a nice application of Store
21:22:44 <definedwheel> jle: In two words, what is Store instance?
21:23:07 <jle`> definedwheel: if you use it in your program, it's because STore is usfeul
21:23:10 <jle`> not because comonads are useful
21:23:18 <jle`> just like if you ever decide to use lists in a program, it's because lists are useful
21:23:20 <jle`> not because monads are useful
21:23:30 <jle`> same for IO -- you use IO becuase IO is useful, not because monads are useful.  Maybe, too
21:24:06 <jle`> so just looking to add "comonads" to help your program is not really a fruitful path
21:24:27 <Rotaerk> the whole point of an abstraction, like monads, is so that you can write generic functions that work for every instance of it
21:24:44 <hrqaa> How could I find all possible pairings of the elements in a list? I have a list of strings and I want to create a new list of lists, each of which contains tuples of pairings of strings of the same length
21:24:46 <Rotaerk> but it's not what makes those concrete things useful
21:24:55 <definedwheel> jle: oh cmon, I didn't speak clearly enough, and you got it wrong. How do I explain, what I am interested in
21:25:09 <hrqaa> With all possible pairings represented in the tuples, but with order being unimportant ("a","b") and ("b","a") is not good
21:25:14 <jle`> definedwheel: there's another article on using the Store comonad for cellular automata by edwardk , but it's slightly less accessible than the first one -- https://www.schoolofhaskell.com/user/edwardk/cellular-automata
21:25:18 <hrqaa> (This is why a list comprehension doesn't seem good)
21:25:32 <jle`> definedwheel: i'll wait for you to explain :)
21:26:20 <jle`> another issue with comonads that monads don't have is that there are very few useful "comonad-polymorphic" functions you can write.  but for monads, there are several (ie, the entire Control.Monad module)
21:26:26 <jle`> so it's a little less useful of an abstraction
21:27:08 <definedwheel> It was quite a thing, when someone discovered, that you can map side-effects to monads. I wanna understand, what you can map to comonads. brb reading this article
21:27:18 <ania123> guards and guarded equations are deferent things?
21:27:47 <jle`> definedwheel: ah.  but, side effects aren't a fundamental property of monads.  monads can be used to implement working with side-effects.  monads don't "map to effects"
21:27:57 <hrqaa> (Or is there an easy way if I can tell if values in a trie are permutations of one another)?
21:28:46 <definedwheel> jle: My category-theory-fu is weak =)
21:29:18 <jle`> definedwheel: what i'm saying i guess is that "monads => effects" isn't quite true.  effects aren't a fundamental peoperty of monads
21:29:51 <jle`> it's just that a monadic interface is a useful way to work with effects
21:30:15 <hrqaa> Can either of you offer any guidance? :p 
21:30:16 <jle`> an analogy might be that, say, machine learning isn't a fundamental property of Double's.  Double's don't "map to machine learning"
21:30:19 <hrqaa> Sorry to interrupt
21:30:27 <jle`> but Double's are pretty useful when doing ML stuff
21:30:32 <jle`> Double's, Floats too.  also arrays, matrices
21:31:12 <jle`> definedwheel: but along this line, if you're looking for something to fit the analogy, "monads : effects :: comonads : ???"
21:31:32 <jle`> definedwheel: as in, monads can be used to model effects, can comonads be useful for something similar?"
21:31:41 <jle`> then the answer might be "coeffects"
21:32:03 <definedwheel> jle: you mean pure computations? =)
21:32:04 <jle`> here's a nice writeup on the concept of co-effects, and how a comonadic interface could be useful
21:32:05 <jle`> http://tomasp.net/academic/theses/coeffects/
21:32:09 <jle`> not pure computations :O
21:32:23 <jle`> er wait, wrong link
21:32:29 <jle`> here it is http://tomasp.net/blog/2016/coeffects-playground/
21:32:44 <jle`> sorry, wrong again, http://tomasp.net/coeffects/
21:33:20 <jle`> the paper talks about the idea of coeffects, and how comonads as a concept can fit into the picture
21:33:31 <jle`> by paper i mean interactive js demos, heh
21:33:52 <definedwheel> jle: Thank you, gotta go wrap my head around all of these
21:34:25 <jle`> hrqaa: you can probably write a recursive function to do this?
21:34:54 <hrqaa> jle`, I've written a recurvie function to build the lists
21:35:10 <jle`> hrqaa: but if 'equality' is something important (that is, if the original list has repeate items, and you want those to go away), you can have it go trhough Data.Set
21:35:25 <hrqaa> jle`, But I want to write a function that takes these sublists and creates tuples representing all possible non-order-specific pairs
21:36:21 <jle`> @let allPairs [] = []; allPairs (x:xs) = map (x,) xs ++ allPairs xs
21:36:24 <lambdabot>  Defined.
21:36:25 <jle`> > allPairs "hello"
21:36:28 <lambdabot>  [('h','e'),('h','l'),('h','l'),('h','o'),('e','l'),('e','l'),('e','o'),('l',...
21:36:39 <jle`> might have been a bad exmaple, heh
21:36:42 <jle`> > allPairs "abc"
21:36:44 <lambdabot>  [('a','b'),('a','c'),('b','c')]
21:37:27 <hrqaa> Dang, quick. I have a long way to go with haskell
21:37:37 <jle`> hrqaa: well, it's not a haskell thing
21:37:47 <jle`> once you think about the algorithm, it's straightforward to implement :)
21:37:50 <hrqaa> Computer science/programming, etc.
21:38:00 <jle`> i'd say it is a math thing
21:38:09 <jle`> combinations is something that they taught in high school
21:38:34 <jle`> https://en.wikipedia.org/wiki/Combination
21:38:42 <jle`> not that they teach it well though, heh
21:38:58 <jle`> but if you want to get all combinations of "abcd", it's ab, ac, ad ... then bc, bc ... then cd
21:39:22 <jle`> all combinations of "abcde", you'd do ab, ac, ad, ae, and bc, bd, be, and cd, ce, and de
21:39:33 <definedwheel> I would do that with a list comprehension, its a oneliner
21:40:03 <jle`> not sure if it's possible to do with a list comprehension directly
21:41:24 <hrqaa> Do I need some module that's not in Prelude to use tuple sectons like that?
21:41:38 <jle`> {-# LANGUAGE TupleSections #-}
21:41:45 <jle`> at the top of your file
21:41:53 <jle`> or :set -XTupleSections in ghci
21:44:27 <cwyang> @let foo s = [ (x,y) | xs <- tails s, not $ null xs, y <- tail xs,  let x = head xs]
21:44:29 <lambdabot>  Defined.
21:44:37 <cwyang> > foo "abc"
21:44:39 <lambdabot>  [('a','b'),('a','c'),('b','c')]
21:45:05 <jle`> haha
21:45:21 <cwyang> :-)
21:45:31 <definedwheel> damn, lambdabot is cool
21:46:10 <definedwheel> its like I dont even need ghci, I can just use this channel
21:47:12 <jle`> you could also use it in private message ^^
21:48:32 <definedwheel> jle: coeffects is just what I searched for, thanks =)
21:51:04 <jle`> no problem!
21:55:36 <dmj`> jle`: o/
21:55:58 <jle`> dmj`:  \o
21:56:03 <jle`> ready to change the world
21:56:04 <jle`> ?
21:56:32 <dmj`> "make haskell web dev great again"
21:59:01 <dmj`> jle`: unsure why the ghcjs implementation of websocket neglects the onerror and onopen events
22:00:51 <jle`> i think it's incomplete
22:01:02 <jle`> that's what liute told me i think
22:03:02 <dmj`> mm
22:07:24 <dmj`> jle`: this one has all 4 events and a nice FromJSON/ToJSON thing
22:08:37 <dmj`> jle`: the singularity is near
22:25:09 <hrqaa> I have a list of tuples of String ( :t is [(String,String)]). Can I easily alphabetize them based on the first string value
22:25:54 <hrqaa> Maybe I'll make a newtype and declare an ord instance?
22:25:58 <hrqaa> so I can just use sort
22:26:41 <geekosaur> sortBy (comparing fst <> comparing snd) ?
22:27:23 <geekosaur> or, what did you mean by "based on the first string value". ignore the second entirely?
22:27:29 <geekosaur> sortBy (comparing fst)
22:27:37 <ab9rf> if you want ot ignore the second just do what he said\
22:27:43 <ab9rf> i type slow
22:30:31 <geekosaur> (or: sortOn fst)
22:30:40 <hrqaa> Yes
22:30:57 <hrqaa> Oh no, that wasn't necessary lol
22:31:00 <hrqaa> darnnnnn
22:31:17 <jle`> 'sort' should still work if you don't care about preserving the order of things with the same first value but different string value
22:31:25 <geekosaur> default sort for a tuple would be the first one I gave you, so it effectively sorts by the first one anyway
22:31:25 <jle`> > sort [("hello","world"),("abc","def")]
22:31:28 <lambdabot>  [("abc","def"),("hello","world")]
22:31:31 <jle`> ta dah
22:31:56 <hrqaa> What do you mean by different string value?
22:32:10 <jle`> *different second value
22:32:27 <jle`> it'd be an "unstable" sort, if you don't mind
22:32:40 <jle`> > sort [("hello","world"), ("hello","susan")]
22:32:43 <lambdabot>  [("hello","susan"),("hello","world")]
22:32:45 <hrqaa> I did waste my time there lol
22:32:47 <hrqaa> making a newtype
22:33:11 <jle`> > sort [("hello","world"),("abc","def"),("ghi","jkl"),("hello","susan")]
22:33:12 <hrqaa> good to know though. I guess that's a result of the way the ord instance for tuple is defined?
22:33:15 <lambdabot>  [("abc","def"),("ghi","jkl"),("hello","susan"),("hello","world")]
22:33:18 <jle`> yup
22:33:18 <geekosaur> yes
22:33:45 <jle`> note that the sort is unstable, so even though "hello","world" came before "hello","susan" in the original list, it comes after in the "sorted" list
22:34:03 <jle`> for a stable sort you could do sortBy (comparing fst)
22:34:17 <jle`> or sortOn fst
22:34:30 <jle`> > sortOn fst [("hello","world"),("abc","def"),("ghi","jkl"),("hello","susan")]
22:34:33 <lambdabot>  [("abc","def"),("ghi","jkl"),("hello","world"),("hello","susan")]
22:41:07 <cheater> hi
22:56:28 <jle`> hi cheater 
