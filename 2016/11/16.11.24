00:00:05 <kinda> actually that's not my real code
00:00:13 <lyxia> actually it's a super-awkward version of '2'
00:00:24 <kinda> I just removed all extra things to fall back on a very simple not working example
00:00:55 <kinda> something I could easily present on irc with just few lines of code
00:01:08 <c_wraith> kinda: so the basic problem is that print's argument is polymorphic.
00:01:29 <c_wraith> kinda: That doesn't give the compiler enough information to figure out the type of its argument from context.
00:01:33 <kinda> ok this makes sense
00:01:35 <ertes> kinda: the problem is that you were assuming that Integer is the only possible base case, because it's the only one you defined
00:01:49 <kinda> so I could for example
00:02:11 <kinda> write my own print function which only takes Integer as input
00:02:18 <kinda> and this would desambiguate 
00:02:18 <ertes> kinda: but instance resolution follows what we call the *open world assumption*, so the fact that there is only one instance in scope does *not* mean the compiler will just pick it
00:02:49 <ertes> and in fact in this case even both instances would fit, even though we don't have Show instances for functions
00:02:55 <ertes> :t print
00:02:57 <lambdabot> Show a => a -> IO ()
00:03:00 <kinda> ok
00:03:08 <kinda> that's very clear now
00:03:09 <c_wraith> kinda: well, that would solve the type of the full expression.  Depending on how the instances are set up, it might be enough to figure out the types of the arguments too
00:03:23 * hackagebot data-has 0.2.1.0 - Simple extensible product  https://hackage.haskell.org/package/data-has-0.2.1.0 (winterland)
00:03:32 <kinda> thank you all
00:03:53 <ertes> kinda: i recommend a combinator style instead of the variadic hack
00:04:08 <kinda> what is a combinator ?
00:04:37 <ertes> if you need an example, look at any pretty-printing library (e.g. wl-pprint-text) or HTML combinator library (e.g. blaze-html/lucid)
00:05:29 <kinda> ok, i will take a look
00:05:45 <kinda> thanks very much
00:08:49 <kinda> so I need to go. thanks again and see you soon
00:10:14 <quchen> edwardk: With Cabal sandboxes yes, with Stack … also yes, because everything is always bumped. But still!
00:10:17 <quchen> :-S
00:10:53 <quchen> So it stays as it’s always been: when I need a tiny dep footprint I’ll just hack it together myself, otherwise import lots of things.
00:11:06 <ertes> quchen: nix actually fixes that
00:11:26 <ertes> quchen: it uses sharing
00:11:46 <hvr> quchen: what do you mean "everything is always bumped"?
00:11:52 <quchen> I don’t use Nix, but I’ve been interested in trying for a long time.
00:12:21 <hvr> quchen: you don't have to go full nix, you can also just try the cabal subset of it: http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
00:12:35 <hvr> to get a hang for it
00:12:44 <quchen> hvr: Well, Stack tries to sell good sharing among libraries. The problem is that even the smallest version bumps in libraries between Stackage snapshots result in recompilation.
00:12:59 <quchen> So when you have lots of dependencies, then switching snapshots usually means lots of building.
00:13:05 <hvr> quchen: cabal is more clever about it then, it only does so when it's unavoidable
00:13:10 <quchen> Yup.
00:13:30 <hvr> by considering the nix-store as a shared cache among *all* install-plans
00:13:44 <ertes> oh yeah, new-build actually does a lot of what nix does
00:13:58 <hvr> of course, if something very low in the dep-graph such as 'text' is bumped.... 
00:14:12 <quchen> hvr: Exactly. Containers, text, lens, …
00:14:18 <hvr> lens is not that low
00:14:22 <hvr> it's quite high-level
00:14:26 <quchen> Really?
00:14:27 <quchen> Hm.
00:14:34 <ertes> quchen: lens depends on all of those
00:14:45 <ertes> to give you many predefined instances for At, Ix, etc.
00:14:54 <hvr> quchen: lemme produce a dep-tree to show you
00:14:56 <quchen> I can’t remember my last project with lens not as a (transitive) dep.
00:15:13 <quchen> hvr: Dependency trees reminds me to update hackage-everything one day ;-)
00:17:08 <hvr> quchen: https://gist.github.com/hvr/fe244b2f88e2705117056627bd691a31
00:17:55 <hvr> it would look prettier if I hadn't had to run it through a de-ansi'fier
00:18:24 * hackagebot json-extra 0.2.0.0 - Utility functions to extend Aeson  https://hackage.haskell.org/package/json-extra-0.2.0.0 (TobiasDammers)
00:20:38 <quchen> hvr: Pipe your ANSI output to     nc termbin.com 9999
00:22:57 <ertes> didn't quite work
00:23:00 <ertes> http://termbin.com/63at
00:23:18 <ertes> % echo -e "test\e[1mtest\e[33mtest\e[mtest" | nc termbin.com 9999
00:24:08 <ertes> ah, it doesn't *render*, it just *reproduces* fully
00:25:37 <quchen> Strange.
00:25:42 <quchen> I thought it would render.
00:26:06 <quchen> Ah, now I remember, and I thought wrong.
00:26:15 <ertes> well…  curl -s "http://termbin.com/63at"
00:26:17 <ertes> =)
00:27:48 <ertes> (letting strangers send arbitrary strings to your terminal can be a security risk though)
00:28:02 <hvr> quchen: http://termbin.com/ytyb
00:28:22 <quchen> Termbin makes a very useful shell alias,    alias -g TB=" | nc termbin.com 9999 | clipboard "
00:28:33 <quchen> echo "foo" TB     -> Link to the paste in my clipboard
00:36:45 <Ulrar> Hi, so I made a few tools for work and I have a few files common to all "projects". I'd like to package that to keep only one copy updated, so I think I should package it, just for me. Is there a simple howto for that ? I've fiddled with stack for a while and I just can't figure out a simple way to do it
00:37:11 <Ulrar> The dependencies are a nightmare
00:37:51 <hvr> Ulrar: you common files = common .hs modules?
00:38:01 <hvr> or something else?
00:38:16 <tdammers> I figured out yesterday that it is possible to have multiple projects under one stack project
00:38:36 <tdammers> put stack.yaml in the project root, then make a bunch of subdirs, each with a separate .cabal file in them
00:38:46 <Ulrar> hvr: Yes a "main" .hs file with a few helper modules
00:38:49 <tdammers> and then just configure stack.yaml to look at all of them
00:38:53 <hvr> tdammers: works with cabal new-build as well, you don't even need a cabal.project file for that
00:39:14 <Ulrar> It's an API implementation
00:39:15 <hvr> tdammers: since currently the implicit default is to have 'packages: . ./*/'
00:39:24 <Ulrar> And I have a few tools using that API to do stuff
00:39:42 <tdammers> hvr: yeah, anyway, I never realized that this would work, and just found it incredibly useful
00:39:47 <Ulrar> I'm about to write a new one and I don't want to keep copying those files everywhere ..
00:39:49 <hvr> tdammers: but you still want a one-liner cabal.project so that cabal knows where to find the project root
00:40:22 <hvr> tdammers: http://cabal.readthedocs.io/en/latest/nix-local-build.html#developing-multiple-packages :-)
00:40:48 <hvr> Ulrar: you can put all common .hs modules in the pacakge's library
00:40:57 <hvr> Ulrar: lemme find an example
00:41:20 <tdammers> hvr: well, sticking with stack for the time being
00:41:33 <tdammers> hvr: but good to know cabal has made such leaps
00:42:02 <hvr> Ulrar: https://gist.github.com/hvr/46496a45ea41fa1734be170b630eb589
00:42:27 <hvr> Ulrar: while that requires a bleeding edge cabal, the basic idea also applies for older cabal
00:42:52 <hvr> Ulrar: you can have a 'library' section (but use "library" rather than "library matrix-lib")
00:43:28 <hvr> Ulrar: and have the executables build-depend on the library; that way you avoid each executable recompiling the same .hs (as well as having to specify it redundantly)
00:44:04 <Ulrar> Mh, so I'd make a big project named something like "tools" and define the library and each executable on this
00:44:10 <Ulrar> Seems great
00:44:21 <hvr> Ulrar: so e.g. if you package is called 'my-cool-tools', the `libary` stanza is referred to in the executable stanzas by `build-depends: my-cool-tools` 
00:45:00 <Ulrar> I understand
00:45:20 <Ulrar> As for the cabal file itself, how do you generate it ?
00:45:22 <hvr> Ulrar: in future cabal versions you can have multiple internal libraries; (that's why there's a name in that example,  "library matrix-lib"))
00:45:28 <hvr> Ulrar: cabal init
00:45:31 <Ulrar> Everytime I tried I never could get the dependencies to work right
00:45:50 <hvr> Ulrar: well, `cabal init` has some heuristics to scan your .hs files and generate build-deps
00:46:12 <hvr> however, it will probably not get it right for a more complex source-tree
00:46:35 <Ulrar> Well there isn't much code, but it depends on wreq which seems to depend on half the existing packages
00:46:49 <hvr> Ulrar: you only specify your direct dependencies
00:47:04 <hvr> Ulrar: i.e. those whose modules you import directly
00:47:07 <hvr> in your code
00:47:29 <Ulrar> So I create a directory, copy my .hs files in it and run cabal init, is that it ?
00:47:35 <hvr> basically, yes
00:47:38 <Ulrar> Should I split them in directories at least ?
00:47:45 <hvr> lateron
00:47:52 <Ulrar> Allright, let's try that then
00:48:02 <hvr> it may make sense to move all .hs into a src/ folder
00:48:10 <hvr> cabal init will ask you a couple of questions
00:48:53 <hvr> there'll be a question where you're asked whether you're building a library or an executable
00:49:09 <hvr> I'd try both, and see which one gives you a better result
00:49:39 <hvr> and from there on you'll have to modify your .cabal file and split it up manually into library & executable stanzas
00:50:27 <Ulrar> Mh, it asks for the main module
00:50:37 <Ulrar> I have two of them currently, since there is two tools
00:50:46 <Ulrar> Guess that's one of the things I'll have to change in the file
00:58:16 <hvr> yeah, just point it to one
00:58:28 <hvr> it's about getting an initial .cabal to go from
01:03:53 <Ulrar> Mh "broken due to missing package"
01:04:08 <Ulrar> Guess I did something wrong trying to make stack work last  time
01:17:19 <Ulrar> hvr: So I cleaned-up my system and now when I do a "cabal build" I get this :
01:17:23 <Ulrar> "cabal: At least the following dependencies are missing: [...]"
01:17:32 <Ulrar> Isn't cabal supposed to install those itself ?
01:17:50 <Ulrar> Or does it mean in the cabal file ?
01:19:43 <ongy> you need to do cabal install (that will install the package you are building) or cabal install --dependencies-only (installs dependencies, but not the current project)
01:22:58 <Ulrar> Ha perfect, thanks
01:50:05 <Ulrar> And that's it, works perfectly !
01:50:16 <Ulrar> Thanks a lot for the help, it's much better now :)
02:02:17 <bollu> how do I send an enum over the haskell FFI? AFAIK. the size of an enum is not "defined"  (http://stackoverflow.com/questions/8115550/what-is-the-size-of-an-enum-type-data-in-c)
02:02:25 <bollu> so what size do I use in the Storable instance?
02:21:22 <lyxia> bollu: it's the size of whatever representation you choose for it
02:22:32 <lyxia> ah you meant a C++ enum... nvm
02:23:14 <bollu> lyxia: yes :)
02:26:50 <lyxia> Perhaps you can define that size as sizeof(your_enum)?
02:27:01 <lyxia> basically implement Storable in C++.
02:38:23 <bezirg> hello, is there any performance benefit of using (Rat Int) instead of the standard type Rational = Ratio Integer    ?
02:40:02 <muzzle> hi
02:40:18 <muzzle> is there any disadvantage (performance or otherwise) of using MonoFoldable instead of Foldable?
02:40:22 <ongy>  Hi muzzle
02:41:37 <muzzle> the background is that I want to write an implementation of suffix trees that needs to be very fast
02:41:58 <muzzle> and I would like to use ByteStrings, Vectors, Lists and possibly sequences as the edge labels
02:42:10 <muzzle> but there is no foldable instance for Bytestring
02:43:42 <pavonia> bezirg: Where is Rat from?
02:44:24 <bezirg> pavonia: Data.Ratio.Rat
02:44:50 <bezirg> sorry I mean Ratio Int
02:45:01 <bezirg> Data.Ratio.Ratio
02:46:08 <pavonia> Integer uses Int internally for small numbers, IIRC, so probably no performance gain here
02:46:26 <bezirg> pavonia: ok, thanks for this
02:46:34 <sdx23> pavonia: does it?
02:47:12 <lyxia> Rational numbers quickly explode in size, so using Rat Int isn't a good idea anyway.
02:48:28 <sdx23> ah, it indeed does. Nice to know.
02:49:36 <lyxia> muzzle: you don't lose much http://stackoverflow.com/questions/39634504/is-there-anything-we-lose-with-monofoldable
02:50:09 <muzzle> lyxia
02:50:10 <muzzle> thx
02:50:59 <bezirg> lyxia: interesting, didn't think of that
03:08:31 * hackagebot jsaddle-wkwebview 0.7.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-wkwebview-0.7.0.0 (HamishMackenzie)
03:15:55 <bollu> I'm having cabal link to a C library. However, even after deleting the C library, my tests still run! I'm using stack. What the hell is going on?
03:16:04 <bollu> how is it that even after deleting the static library, my code runs?
03:16:42 <bollu> ah, interesting, haskell dynamically links?
03:17:11 <James123> I have created a custom data type and I want to map integers to these custom types. I am between Data.Map and Data.Vector. What would you recommend?
03:18:56 <bollu> James123: have you seen the Enum typeclass?
03:19:51 <James123> bollu: No, I will look into it, thank you
03:28:21 <lyxia> Vector is faster than Map at indexing, but much slower at updating.
03:28:48 <folsen> has anyone here ever implemented MonadTransControl for a nested monad stack?
03:31:32 <lyxia> what's the problem?
03:35:31 <bollu> whats the etiquette when it comes to implementing instances of things outside prelude? eg: Ix? 
03:35:43 <James123> lyxia, is there anything that is fast both at indexing and updating? Array possibly?
03:35:46 <bollu> I need to include ix in my dependencies right?
03:36:07 <muzzle> is the Connection-type in the postgresql-simple package thread safe?
03:36:19 <muzzle> I.e. will I mess something up when using one connection in several threads?
03:38:17 <lpaste> paolino pasted “how does work StateT s []” at http://lpaste.net/345378
03:39:43 <paolino> hello, I was expeting a help from the evalStateT in avoiding duplicates but doesn't work
03:40:38 <paolino> I guess the state gets resetted but I can't figure out
03:43:48 <pavonia> paolino: What's the problem exactly?
03:47:37 <lyxia> James123: Array is just like Vector.
03:47:57 <paolino> pavonia the state seems not updated
03:48:12 <paolino> by modify
03:49:09 <paolino> I always get False in the trace even if the 'x' are the same in two cycles
03:49:24 <lyxia> James123: Mutable vectors are fast at modifying a value, but you can't remove or add an index. There has to be a value for every index between 0 and (length v-1).
03:49:59 <paolino> pavonia, I added the state to check that I don't do the same computation twice
03:50:13 <lyxia> James123: And mutable vector operations are not pure.
03:50:30 <lyxia> you must run in ST or IO
03:50:37 <pavonia> paolino: You don't use the stat anymore after modify, do you?
03:50:50 <James123> lyxia: Ok, I see. Thank you for your answer!
03:52:00 <paolino> pavonia that's the point I thought consume was happening inside a kind of cycle
03:52:37 <paolino> but probably I miss the logic of StateT s []
03:52:48 <pavonia> But consume is used before modify
03:54:33 <paolino> so a ListT (State s) could work for it ?
03:56:01 <pavonia> Not sure. Do you want to use the current state in the recursive call of search?
03:56:17 <paolino> I'd say no
03:56:27 <paolino> it's just for that layer
03:57:11 <pavonia> So I don't understand why you change the state and then don't use it anymore
03:57:55 <paolino> I was hoping to reuse it with the *next* gets
03:58:41 <paolino> but I see the point, there is no next
04:00:00 <pavonia> Yes, that's what I meant with recursive calls. You probably want something like search = evalState search' where search' is a State action that does all the calculations
04:01:14 <paolino> thanks, I fix consume to produce the right list , I don't need the state common to all the search
04:16:37 <ertesx> imagine you're in an alien world, far removed from your home, the land of haskell…  you see weird creatures all around with weird structures and lots of braces, a world of uncertainty, where everything changes all the time
04:16:50 <SAL9000> lots of braces? sounds more like lisp :-)
04:18:32 <Rembane> This is the dark side of Haskell where you are not allowed to use $ nor .
04:18:47 <ertesx> but then you notice that there are other people there…  these people aren't from your home; they were here for a very long time…  you get to know these people, communicating with them in what you thought to be the only language you have in common with them: commit messages
04:19:46 <ertesx> and then you see this: "Fixed point data type"…  and you think: "could this be someone from where i came from?!"
04:19:49 <muahah>  /part
04:21:10 <ertesx> but your hopes are shattered when you find out that there was an actual Point type that needed to be fixed
04:21:22 <SAL9000> X)
04:23:25 <lyxia> hahaha
04:32:25 <tdammers> sometimes, a little dash makes all the difference
04:33:01 <tech2006> hi
04:35:38 <tech2006> can anyone help me with the raplace function?
04:40:32 <ertesx> tech2006: likely, but you should explain the problem
04:42:04 <tech2006> im trying to use the replace function but getting alot of errors, i checked stack overflow and many others, i tried importing Data.List, Data.List.Split 
04:42:44 <lyxia> you should read the errors
04:43:27 <ertesx> @lpaste
04:43:27 <lambdabot> Haskell pastebin: http://lpaste.net/
04:43:40 <ertesx> tech2006: paste your code on lpaste
04:43:58 <tech2006> the online tutorials say to import Data.List.Utils but haskell tells me no suck module found
04:44:14 <tech2006> such*
04:44:33 <ertesx> which online tutorials?
04:45:02 <tech2006> the ones on stack exchange
04:46:23 <ertesx> tech2006: well, there is no 'replace' function for lists (i seem to recall that there used to be)
04:46:39 <ertesx> tech2006: what semantics do you need?  i.e. what do you want to do with it?
04:46:54 <tech2006> import Data.List.Utils  replace "," "." "127,195,0,0,1"
04:47:11 <ertesx> tech2006: have you tried 'map'?
04:47:14 <tech2006> it should replace the comma with periods
04:47:54 <tech2006> no i havn't tried map
04:48:11 <ertesx> 'map' is your generalised per-item replace function
04:48:26 <ertesx> > map toLower "Hello World!"
04:48:28 <lambdabot>  "hello world!"
04:48:47 <Bor0> >map (\x -> if x == ',' then '.' else x) "127,195,0,0,1"
04:48:52 <tech2006> ok
04:48:58 <Bor0> > map (\x -> if x == ',' then '.' else x) "127,195,0,0,1"
04:48:59 <lambdabot>  "127.195.0.0.1"
04:49:21 <ertesx> of course it would have been better if you had given tech2006 the opportunity to figure it out by themselves =)
04:49:25 <tech2006> ok
04:49:31 <tech2006> checking up on it now
04:49:38 <Bor0> :t replace
04:49:39 <lambdabot> error:
04:49:39 <lambdabot>     • Variable not in scope: replace
04:49:39 <lambdabot>     • Perhaps you meant ‘replay’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
04:49:44 <Bor0> does that even exist?
04:50:49 <mniip> @let replace x y = liftA3 bool (const y) id (== x)
04:50:51 <lambdabot>  Defined.
04:51:56 <phanimahesh> And therefore it exists
04:55:38 <ggVGc> I'm using monad transformers for the first time, and I'm not too happy about this, https://gist.github.com/d008fb728bc11af5b71060b7d4e5e51d
04:55:58 <ggVGc> what can I do differently? These nop/yep things aren't great
04:56:27 <ggVGc> (I will be using the writer instance, just not in this example currently)
04:57:32 <oisdk__> ggVGc maybe wrap it in a MaybeT and then unwrap it at the top level? http://www.parsonsmatt.org/2016/11/18/clean_alternatives_with_maybet.html
04:58:19 <ertesx> ggVGc: use 'empty' instead of (lift (lift Nothing)), and 'pure' instead of (lift . lift . Just)
04:59:05 <ertesx> 'empty' is a member of Alternative from Control.Applicative
04:59:53 <ggVGc> ertesx: thanks!
05:00:19 <ertesx> ggVGc: also you can save yourself the trouble to bind 'nop', because you will never use that value =)
05:00:28 <ertesx> (i assume that that's just a mistake)
05:05:48 <ertesx> @let replace' x y = foldr const id [ const y | x == y ]
05:05:50 <lambdabot>  Defined.
05:09:26 <ertesx> that…  type-checked?  doesn't GHC read my mind anymore?
05:10:37 <Hi-Angel> I couldn't figure out, neither to google it — how do I pattern match a result of a function (e.g. "Either Foo Bar") in a do-notation, for example to "return ()" for a bad value?
05:12:21 <mpickering> Say you have a value, v :: Either Foo Bar, then you can write "case v of..." like normal
05:13:34 <mpickering> https://www.irccloud.com/pastebin/e4KLSsJy/
05:13:43 <Hi-Angel> Oh, thank you, let me try
05:14:04 <mpickering> There are two forms for each line of a do-block, v <- e or just e
05:14:23 <mpickering> each line can be any expression as long as it has the right type
05:20:03 <oisdk__> ggVGc https://gist.github.com/oisdk/2dd0eaafd915308dee227ca2ee219302
05:21:43 <ertesx> Hi-Angel: in this particular case you could also use 'either'
05:21:46 <ertesx> :t either
05:21:48 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:23:02 <Hi-Angel> Thank you!
05:25:26 <Hi-Angel> Why do I get "Failed to load interface for ‘Samples" in ghci for ":load Main.hs", even though the Samples.hs is in the same directory as Main.hs, and its module called "Samples"? Acc. to this http://stackoverflow.com/a/1438500/2388257 it should work :/
05:26:44 <lyxia> Hi-Angel: It might also mean that there is an error in Samples
05:27:05 <Hi-Angel> lyxia: nope, ":l Samples.hs" worked
05:27:26 <lyxia> hm
05:27:46 <Hi-Angel> I didn't export anything from Samples.hs though (I forgot), but from the error it seems it doesn't even see it
05:27:50 <lyxia> and I was wrong I don't get such an error if the module I depend on is broken
05:28:08 <lyxia> You sure it's called Samples.hs with a capital S
05:28:13 <Hi-Angel> Yep
05:28:36 * hackagebot fclabels 2.0.3.2 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.3.2 (ErikHesselink)
05:29:04 <lyxia> oh, is there a line module Sample where in your file
05:29:20 <Hi-Angel> Yep, there is
05:29:30 <Hi-Angel> module Samples where
05:29:38 <lyxia> hm this is odd
05:30:42 <pavonia> Hi-Angel: What exactly did you do to get the error?
05:32:04 <Hi-Angel> Just issuing in the ghci ":l Main.hs". The Main.hs has "import Samples" on the 7-th line, and GHCi outputs the error "Main.hs:7:1: error: Failed to load interface for ‘Samples’ […snip…]"
05:33:37 * hackagebot HDBC-odbc 2.5.0.1 - ODBC driver for HDBC  https://hackage.haskell.org/package/HDBC-odbc-2.5.0.1 (anton_dessiatov)
05:34:52 <ggVGc> oisdk__: thanks! Unfortunately guard won't work for me for this, since the actual function I'm writing is more involved than what I posted as an example
05:38:41 <Hi-Angel> Hmm, interestingly, if I execute the GHCi of the distro, and move "import Samples" to be the first import (because unlike the "stack ghci" I'm using, there're modules missing, like "Matrix"), it tries to load the Samples! I.e. I see an error about missing module Matrix in the Samples.hs
05:38:48 <Hi-Angel> Perhaps stack ghci is broken?
05:40:50 <lyxia> mine works
05:42:22 <Glooomy> Hi :) sorry for the slightly off-topic question, anyone here uses vim to develop with haskell?
05:42:38 <Glooomy> I tried setting this up
05:42:39 <Glooomy> https://github.com/sdiehl/haskell-vim-proto
05:42:52 <Glooomy> But syntax checking doesn't seem to happen
05:43:33 <tdammers> I use vim, but with a fairly vanilla config
05:44:16 <StoneToad> same
05:46:24 <Glooomy> So you don't have any kind of syntax/type checking inside the editor ?
05:46:32 <ggVGc> I've got a Maybe a in a function returning a Writer a b, and I want to 'tell' the a from the Maybe if it's there. How do I best do that?
05:48:01 <oisdk__> ggVGc traverse_ tell
05:48:49 <ggVGc> hm, I just did mapM_ and it worked fine
05:49:36 <ggVGc> why traverse_?
05:49:56 <athan> same difference :)
05:50:11 <athan> :t traverse_
05:50:12 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
05:50:14 <athan> :t mapM_
05:50:16 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
05:50:32 <athan> traverse_ is more general :x
05:50:55 <lyxia> it has a prettier name :3
05:51:24 <ggVGc> ah, thanks
05:53:11 <the_2nd> I wrote Filter functions of type
05:53:26 <the_2nd> type Filter = Maybe String -> Maybe String
05:53:40 <the_2nd> and would like to chain them
05:54:06 <oisdk__> :t (<=<)
05:54:07 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:54:10 <the_2nd> I tried (paste comming)
05:55:01 <the_2nd> http://lpaste.net/5179319543490674688
05:55:03 <berndl> Wouldn't a simple composition work?
05:55:14 <the_2nd> Bu this seems to only test for the last in the do notation
05:55:22 <the_2nd> so it seems like im doing something wrong
05:55:23 <athan> the_2nd: They should be `a -> Maybe b`
05:55:40 <athan> and you should use mapMaybe if you're doing something like that (maybe?)
05:56:18 <athan> oh hm yeah that looks fine
05:56:28 <kuribas> @pl (\x -> f =<< x)
05:56:28 <lambdabot> (f =<<)
05:56:37 <athan> what's the type of dropContains?
05:56:43 <lyxia> you just need (.)
05:57:02 <the_2nd> athan, String -> String -> Maybe String
05:57:37 <the_2nd> String -> Filter would be correct, I guess
05:57:45 <the_2nd> so one more maybe
06:02:09 <guillaum2> Hello. I'm looking at a way to convert any string to a valid haskell identifier for type constructor. Example, the string "Hello" is valid, so keep it as is. But the string "C++" is not valid, we can convert it to "CPP". I don't really care about a logic, but the conversion must be as close to the original as possible for characters which are already valid.
06:02:10 <wagnerf> hi, i'm starting to debug my code and was wondering if there is an easy way to trace at function call both arguments and results
06:05:50 <lyxia> wagnerf: use Debug.Trace
06:06:26 <wagnerf> lyxia: well, that's what i'm using
06:06:34 <wagnerf> i can easily show all arguments
06:06:44 <wagnerf> but for return values it's more tough
06:06:52 <lyxia> how so
06:06:54 <wagnerf> like if I have a guard 
06:07:05 <wagnerf> do i need to put a trace in each branch
06:07:32 <guillaum2> wagnerf: create a wrapping function
06:07:54 <lyxia> wagnerf: yes if you want to print the result in both branches
06:08:13 <guillaum2> wagnerf: wrap2 f x y = let res = f x y in traceShow (x, y, res) res
06:08:26 <guillaum2> wagnerf: then, you can wrap your function f using "wrap2"
06:08:30 <lyxia> yes to that too ^
06:08:38 <wagnerf> guillaum2: oh that seems nice
06:08:46 <wagnerf> merci
06:09:14 <guillaum2> wagnerf: if you want a function with a different arity, you can create "wrap1, wrap3, ..." or lost your soul in doing the same thing using typeclass ;)
06:09:17 <guillaum2> de rien ;)
06:09:41 <lyxia> guillaum2: if the first character is upper case, keep it as is, otherwise if it's a lower case letter, upper case it, otherwise replace with a default upper case letter. apply a similar logic to the tail.
06:09:58 <wagnerf> I see. I just lost it this morning in fact, so enough soul losing for today
06:11:18 <guillaum2> lyxia: this is a solution, yes. I was looking more for something more generic (because identifiers can accept some punctation and unicode chars) ;)
06:11:40 <erisco> you cannot RELEASE yourself, you cannot REGAIN yourself
06:11:59 <the_2nd> athan, dropInvalid still only seems to use the last function witin the do
06:13:08 <the_2nd> shouldnt only strings pass through, which pass all the tests? I'm really confused
06:14:02 <erisco> the_2nd, repeat your question for me
06:15:17 <the_2nd> erisco, on it
06:16:53 <the_2nd> http://lpaste.net/3449596133033115648
06:17:12 <the_2nd> I want dropInvalid to only return Just if all its functions are valid
06:17:18 <the_2nd> but it seems to only check the last
06:17:30 <erisco> making a Hakyll blog?
06:18:06 <the_2nd> erisco, me? no
06:18:33 <erisco> do you know what that do-block is equivalent to?
06:18:57 <the_2nd> yes
06:18:59 <tabaqui1> :t egal
06:19:00 <lambdabot> error: Variable not in scope: egal
06:19:19 <Hi-Angel> :t Hi-Angel
06:19:21 <lambdabot> error:
06:19:21 <lambdabot>     • Data constructor not in scope: Hi
06:19:21 <lambdabot>     • Perhaps you meant one of these:
06:20:05 <the_2nd> erisco, ah, damn. I mistook it for >>= binding instead of >> between lines
06:21:08 <erisco> the_2nd, or you can view it as promoting f to _ <- f and then joining with >>=
06:21:49 <Hi-Angel> Why doesn't "stack ghci --ghci-options '--help'" prints help? Or rather: can there be some option not working if I make a script called "ghci" passing all options into the quotes"
06:22:00 <the_2nd> erisco, how would I achieve my "and"?
06:22:35 <erisco> the_2nd, what does a Filter do?
06:22:47 <the_2nd> returns the input if fine or Nothing
06:22:50 <Ulrar> Mh, how exactly do you use _List from Lens ?
06:22:59 <Ulrar> Seems to be a "hole", whatever that is
06:23:04 <erisco> hm, why not Bool?
06:23:08 <the_2nd> erisco, I use alternative <|> for or
06:23:18 <the_2nd> which seems to work fine
06:23:38 * hackagebot rebase 1.0.5 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.5 (NikitaVolkov)
06:23:48 <the_2nd> allow = allow1 <|> allow2 <|> allow 3
06:24:04 <the_2nd> *allow3
06:25:14 <erisco> I don't think functions are Alternative
06:25:17 <lyxia> Ulrar: where is that in lens
06:25:35 <the_2nd> erisco, my bad
06:25:40 <lyxia> Ulrar: I can only see _ListE/_ListP/_ListT
06:25:46 <the_2nd> allow x = allow1 x <|> ...
06:25:54 <lyxia> Ulrar: though servant has _List
06:26:00 <erisco> ah well then we are using Alternative Maybe
06:26:10 <Ulrar> Not sure ..
06:26:23 <Ulrar> wreq has examples for strings but not for lists
06:26:28 <Ulrar> I'm trying to figure it out
06:26:29 <erisco> do you see that dropInvalid is using Monad ((->)a) ?
06:26:40 <lyxia> Ulrar: can you show code using it
06:27:35 <the_2nd> erisco, yes
06:28:18 <erisco> (a -> b) -> (a -> c) -> (a -> c)  this is what >> is
06:28:36 <Ulrar> Well it doesn't compile so I'm clearly wrong :). I get a responseBody = Object (fromList [("ipReverse",String "42.42.42.42"),("reverse",String "domain.tld.")]) from getWith (from wreq) and I need to access the "reverse" value
06:28:40 <erisco> so you are just yielding the second argument
06:28:41 <Ulrar> I'm trying to figure out a way to get it
06:29:14 <the_2nd> erisco, how to do it correctly?
06:29:28 <Ulrar> On other functions I use _Array and _String without a problem, but I can't figure out how to use that list
06:29:46 <lyxia> Ulrar: it's not a list, Object contains a HashMap
06:29:51 <erisco> you probably intended to use Monad Maybe as well, so an option is monad transformers, but that is overly complicated for this
06:30:05 <erisco> it seems more natural to me that you use Bool predicates
06:30:12 <erisco> type Filter = String -> Bool
06:30:45 <lyxia> Ulrar: _Array and _String most likely come  from here http://hackage.haskell.org/package/lens-aeson-1.0.0.5/docs/Data-Aeson-Lens.html
06:31:06 <lyxia> Ulrar: you would need _Object here
06:31:13 <lyxia> but lenses are perhaps overkill
06:31:22 <lyxia> just pattern match on responseBody
06:32:03 <lyxia> case responseBody of Object obj -> HashMap.lookup "reverse" obj
06:32:33 <Ulrar> lyxia: Oh, you're right
06:33:02 <Ulrar> I don't know why this fromList bothered me so much, r ^. responseBody . key "reverse" . _String works fine
06:33:11 <erisco> the_2nd, another option is to use asum
06:33:13 <Ulrar> Guess that's on me, should have tried it
06:33:19 <tabaqui1> :t left
06:33:20 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
06:33:22 <Ulrar> Well thanks a lot !
06:35:02 <erisco> this sort of thing  asum . ($ [dropCss, dropTooShort, dropTooLong]) . fmap . flip ($)
06:35:20 <jchia_1> question about Network.Socket: How do I make a socket? Do I have to use MkSocket? Where do I get the first argument (file descriptor) from?
06:35:54 <jchia_1> If i want to receive UDP broadcast, is there a high-level package to use?
06:37:21 <jchia_1> nevermind, i found the 'socket' function
06:38:20 <praveen> what does the `|` operator do on LHS when defining a function defination? e.g loop r i | i>n = readIORef r
06:39:13 <erisco> or  asum . flip ((<**>) . pure) [...]
06:39:49 <lieven> praveen: it introduces a guard. loop r i = readIORef r when i>n
06:40:06 <erisco> a much better form indeed
06:41:00 <praveen> Liven. thanks. I will look for guards.
06:41:28 <Tuplanolla> Also a minor correction: it's syntax, not an operator, praveen.
06:42:20 <the_2nd> Is there a way to define this chain method in a nicer way? Or is there some function for it already?  http://lpaste.net/4398832820831649792
06:42:26 <the_2nd> erisco, I generalized the problem
06:43:16 <erisco> the_2nd, <=< i.e. Kleisli arrow
06:44:02 <Tuplanolla> @hoogle (a -> m a) -> a -> [m a]
06:44:04 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
06:44:05 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
06:44:05 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
06:44:34 <erisco> that is a curious signature Tuplanolla
06:44:39 <Tuplanolla> I was expecting to find `iterateM` for the_2nd, but was left disappointed.
06:44:57 <Tuplanolla> Then you could `iterateM foo x !! 3`.
06:45:00 <erisco> ah, repeated application
06:45:06 <hpc> @hoogle (a -> b) -> a -> [b]
06:45:06 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
06:45:06 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
06:45:06 <lambdabot> GHC.OldList iterate :: (a -> a) -> a -> [a]
06:46:30 <erisco> you can join the filters together with >=> or <=< and this will use Monad Maybe
06:47:07 <erisco> it is really both a filter and map, so if you need both then this is fine
06:47:31 <erisco> otherwise I am a bit perplexed as to why you wouldn't write filters as Bool predicates
06:48:08 <Tuplanolla> Looks like `monad-extras` has `iterateM :: Monad m => (a -> m a) -> a -> m [a]`.
06:48:40 <the_2nd> Tuplanolla, sorry, I wrote foo foo foo, but it's actually f1 f2 f3
06:49:15 <erisco> that aint the same thing I was thinking Tuplanolla
06:50:02 <erisco> I was thinking [f, f >=> f, f >=> f >=> f, ...]
06:50:23 <Tuplanolla> Well, there are many ways to do this.
06:52:21 <erisco> :t scanl1 (>=>) . pure
06:52:23 <lambdabot> Monad m => (a -> m a) -> [a -> m a]
06:53:19 <erisco> or flip (scanl (>=>)) [] for the squeamish
06:54:38 <erisco> not sure if scanl or scanr is the better choice
06:55:31 <erisco> oh derp, scan isn't doing what I thought it was XD I was thinking of unfolding
06:57:51 <erisco> :t scanr1 (>=>) . repeat  -- works I suppose
06:57:53 <lambdabot> Monad m => (a -> m a) -> [a -> m a]
06:59:00 <erisco> > zipWith ($) ((scanr1 (>=>) . repeat) Just) [1..] !! 3
06:59:06 <lambdabot>  mueval-core: Time limit exceeded
06:59:12 <erisco> > zipWith ($) ((scanl1 (>=>) . repeat) Just) [1..] !! 3
06:59:14 <lambdabot>  Just 4
06:59:49 <erisco> if you're an idiot just use process of elimination XD
07:03:39 * hackagebot string-random 0.1.0.0 - A library for generating random string from a regular experession  https://hackage.haskell.org/package/string-random-0.1.0.0 (hiratara)
07:06:33 <kuribas> :t \f i -> iterate i ((>>=).f)
07:06:35 <lambdabot> Monad m => (a -> m a1) -> ((a -> (a1 -> m b) -> m b) -> a -> (a1 -> m b) -> m b) -> [a -> (a1 -> m b) -> m b]
07:07:10 <Tuplanolla> Nice type.
07:07:13 <kuribas> :t \f i -> iterate i (f.(>>=))
07:07:14 <lambdabot> Monad m => (((a -> m b) -> m b) -> c) -> ((m a -> c) -> m a -> c) -> [m a -> c]
07:07:20 <kuribas> wat
07:07:32 <Tuplanolla> Perhaps you wanted fish instead.
07:07:54 <kuribas> :t \f i -> iterate i (>>= f)
07:07:56 <lambdabot> Monad m => (a -> m b) -> ((m a -> m b) -> m a -> m b) -> [m a -> m b]
07:08:00 <ongy> :t (><>)
07:08:02 <lambdabot> error:
07:08:02 <lambdabot>     • Variable not in scope: ><>
07:08:02 <lambdabot>     • Perhaps you meant one of these:
07:08:08 <ongy> :( no fish operator in scope?
07:09:05 <wagnerf> quick question about evaluation order
07:09:10 <wagnerf> i have this function
07:09:14 <wagnerf> http://pastebin.com/rWh5pujn
07:09:26 <wagnerf> which takes forever 
07:09:41 <wagnerf> i guess the array is created before the assertion is evaluated
07:09:50 <erisco> :t iterate . flip (>>=)  -- did you mean?
07:09:52 <lambdabot> Monad m => (a -> m a) -> m a -> [m a]
07:09:57 <wagnerf> which doesn't make sense for me
07:10:06 <lyxia> wagnerf: "traceShow x x" is "traceShowId x", that makes much shorter code
07:10:24 <wagnerf> lyxia: ok cool
07:10:57 <kuribas> erisco: ah, nice!
07:13:40 * hackagebot quickcheck-string-random 0.1.0.0 - Helper to build generators with Text.StringRandom  https://hackage.haskell.org/package/quickcheck-string-random-0.1.0.0 (hiratara)
07:13:55 <erisco> struggling to get the m off the second arg, though id ~> return ~> id is one way
07:14:08 <erisco> struggling to do in a nice way
07:15:06 <Tuplanolla> :t \ f x -> sequence (iterate (>>= f) (return x))
07:15:08 <lambdabot> Monad m => (a -> m a) -> a -> m [a]
07:15:32 <Tuplanolla> Leave out the `sequence` if you want `[m a]` instead.
07:15:41 <EvanR> so I'm thinking theres no way to make a monad instance for unordered pair
07:15:46 <lyxia> wagnerf: I'm not sure what's going on, there's also no array here.
07:15:52 <erisco> well yeah, but that's the duct tape method ;)
07:16:34 <wagnerf> lyxia: actually I get the trace for the bounding box
07:16:39 <EvanR> http://lpaste.net/345422
07:16:49 <wagnerf> lyxia: but not the trace for the slicesNumber
07:18:10 <erisco> EvanR, do you know the laws stated in join?
07:18:40 * hackagebot formatting 6.2.4 - Combinator-based type-safe formatting (like printf() or FORMAT)  https://hackage.haskell.org/package/formatting-6.2.4 (ChrisDone)
07:19:07 <lyxia> wagnerf: have you disabled any optimization
07:19:18 <wagnerf> I don't know
07:19:28 <wagnerf> i use stack to build the code
07:19:32 <wagnerf> just "stack build"
07:19:36 <EvanR> join . fmap join     ≡ join . join
07:19:41 <EvanR> join . fmap return   ≡ join . return = id
07:19:57 <wagnerf> is there a special way to compile for debug ?
07:20:14 <EvanR> hrm, wikipedia.. not sure this makes sense
07:20:24 <EvanR> erisco: why?
07:20:43 <lyxia> wagnerf: is there -O in the .cabal file
07:20:44 <erisco> well, you are defining join, so I just thought it would help to look at it from that perspective
07:20:53 <erisco> and join is simpler for me to think about than bind
07:20:57 <ssarah> why is this wrong ? https://gist.github.com/fullmooninu/06675e01e735e8057dbb6ac2b4f7d303 I can't seem to figure out pattern matching with types very well.
07:21:13 <erisco> what is your plan for UP (UP a) -> UP a? you have 4 values, which 2 do you keep?
07:21:13 <wagnerf> lyxia: no
07:21:15 <EvanR> erisco: thats why im implementing it that way, but first thing i ran up against is the UP laws... 
07:21:35 <dcoutts> lyxia, wagnerf: don't put -O in the .cabal file, use cabal build -O / -O0 (or stack equivalent)
07:21:55 <EvanR> you have 4 values... you have to end up with 2, theres no way to choose and respect "unordering"
07:22:02 <EvanR> that i can see
07:22:13 <dcoutts> wagnerf: note that -O is the default, use -O0 to turn down optimisations
07:22:36 <EvanR> if there was a way to take 2 and get 1, that would work
07:23:03 <EvanR> but UP has no comonad instance either
07:24:20 <Sulijen> Bonjour!
07:25:08 <lyxia> Hello
07:25:10 <wagnerf> dcoutts: well thanks, but it didn't change anything
07:25:14 <Sulijen> Hello
07:25:32 <wagnerf> anyway I would expect the assertion to work even with -O
07:25:34 <Sulijen> lyxia: I have a problem, I would multiplicate a function
07:25:41 <athan> How does fmap work for ContT? :s
07:25:56 <athan> if `ContT r m a = (a -> m r) -> m r`
07:26:01 <erisco> EvanR, a take first or take second policy screws up on  join . fmap return ≡ id
07:26:11 <Sulijen> lyxia: I would like to do this -> "4 * delete '!' a"
07:26:24 <EvanR> take first one which one
07:26:39 <EvanR> it would screw up not depending on unordering
07:26:43 <lyxia> @djinn (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
07:26:44 <lambdabot> f a b c = b (\ d -> c (a d))
07:26:45 <erisco> EvanR, you secretly have an order, so you use that when deciding what is first and second
07:26:57 <athan> thanks lyxia 
07:27:02 <lyxia> yw
07:27:08 <athan> oh!! okay, sweet
07:27:10 <athan> wow
07:27:10 <lyxia> Sulijen: what does that mean
07:27:15 <EvanR> the secret is not observable, if its true
07:27:16 <dfeuer> Ping glguy
07:27:29 <EvanR> erisco: see the recUP operation, you have to use a commutative operation
07:27:31 <Sulijen> lyxia: delete four times '!' symbol
07:27:44 <EvanR> erisco: monad does work for ordered pairs that way you said though
07:27:45 <erisco> (1,2) ==fmap return==> ((1,1),(2,2)) ==join==> (1,1)
07:27:54 <Hi-Angel> mpickering: cool, thank you, that's worked!
07:27:56 <lyxia> Sulijen: what are you having trouble with
07:28:02 <EvanR> you mean (1,2)
07:28:13 <athan> the resulting continuation contains the negative part
07:28:16 <erisco> oh derp :)
07:28:21 <athan> er something
07:28:25 <athan> so it's not contravariant
07:28:35 <dfeuer> Wait, how do you join a pair?
07:28:38 <Sulijen> lyxia: I would like to delete punctuation from text
07:29:12 <erisco> so it seems fine wrt monad laws, then what laws are you breaking?
07:29:30 <lyxia> athan: it's a negative position within a negative position, so it is overall a positive position.
07:29:37 <dfeuer> erisco, you can't be mapping over the first component....
07:29:47 <thomasd> anyone here familiar with template haskell differences between 2.10 and 2.11?
07:29:54 <EvanR> erisco: the one in the comment of recUP
07:29:55 <dfeuer> Unless you're talking about some non-Haskell version.
07:30:03 <erisco> dfeuer, I was abusing tuple notation to mean something else
07:30:07 <dfeuer> Oh.
07:30:27 <EvanR> (a,a) has a sane monad instance
07:30:36 <lyxia> thomasd: what about them
07:30:43 <thomasd> For instance, there was an added constructor to the `Con` datatype: `GadtC [Name] [BangType] Type`
07:30:59 <erisco> or  Join (,)  partial application instances *cough*
07:31:04 <wagnerf> lyxia: ok if I replace the "assert" with "traceShow" it works ; so I guess the compiler is disabling them and since slicesNumber is only used there it doesn't get evaluated
07:32:08 <erisco> EvanR, I don't see the problem still
07:32:20 <thomasd> in 2.10, you can represent constructors for GADTs with `NormalC Name [BangType]`, but in 2.11 the `GadtC [Name] [BangType] Type` constructor seems to fill this role
07:32:44 <EvanR> erisco: the type UP a is abstract, it consists of two a without any particular order
07:33:07 <thomasd> lyxia: and I was wondering what the `[Name]` represents, since in the previous case `NormalC Name ...` there is a single name, the name of the constructor
07:33:21 <thomasd> but in `GadtC` fields there is a list of Names
07:33:22 <EvanR> the only thing you can do with it is apply the recursion principle which says if you have f : a -> a -> b such that f x y = f y x, then you can have a b
07:33:38 <erisco> recUP (\p1 p2 -> fromPair (recUP const p1, recUP const p2))
07:33:45 <EvanR> that would break that law
07:33:51 <erisco> lets see
07:33:59 <EvanR> also const doesnt have the right type
07:34:18 <erisco> how not?
07:34:30 <EvanR> er
07:34:34 <EvanR> nevermind
07:34:58 <EvanR> const has the right type, and breaks the law
07:35:04 <EvanR> > const 'a' 'b'
07:35:06 <lambdabot>  'a'
07:35:09 <EvanR> > const 'b' 'a'
07:35:12 <lambdabot>  'b'
07:36:11 <erisco> ah, yes, but, wait a minute
07:37:55 <stephen_> hi all, I'm a Haskell newbie with a probably dumb question. I'm trying to write a function that takes three 2-tuple coordinates as arguments and returns the length of the longest side using let or where to store each side's length, and I keep getting errors that it won't compile. First I tried where and that didn't work so then I tried let and that's not working either. Here's the text of the functions: http://lpaste.net/345425
07:38:04 <erisco> recUP const p1  and recUP const p2  are not law abiding, but  \p1 p2 -> fromPair (recUP const p1, recUP const p2)  is
07:40:59 <erisco> because it doesn't matter if we end up with (x,y) or (y,x) after projecting the (secret) first element, these pairs are equivalent
07:41:00 <EvanR> its not a legal function as it
07:41:02 <EvanR> as is
07:41:35 <EvanR> your argument is that \p1 p2 -> fromPair x y is commutative no matter what x y is
07:41:51 <EvanR> even if its invalid
07:42:13 <erisco> no it matters what it is, it is contingent on the fact we're projecting the first element
07:42:13 <Sulijen> join #esperant
07:42:31 <erisco> so the inner recUPs are wrong, but the outer recUP is fine
07:42:34 <berndl> stephen_: what is the error?
07:42:39 <EvanR> it doesnt matter what it is, your making the goal "make a commutative function at all"
07:42:40 <kuribas> stephen_: should you use square instead of abs?
07:42:58 <kuribas> :t sqrt
07:42:59 <hpc> stephen_: the let version works for me
07:43:00 <lambdabot> Floating a => a -> a
07:43:03 <erisco> yes, it is commutative, that is my point
07:43:09 <kuribas> stephen_: also you're missing a Floating constraint.
07:43:10 <EvanR> its preetty vacuous
07:43:13 <hpc> stephen_: i wrote it to test.hs and ran "ghci test.hs"
07:43:15 <thomasd> yeah
07:43:30 <thomasd> stephen_: look at the type of `sqrt` and then look at the type of your function
07:43:36 <thomasd> there is something missing
07:43:56 <thomasd> sqrt :: Floating a => a -> a
07:43:56 <EvanR> its doing something completely illegal and then effectively hiding any consequences
07:44:01 <EvanR> moving on to the monad instance
07:44:03 <erisco> I don't know if breaking the law in that spot matters
07:44:09 <stephen__> berndl: it's telling me tut02.hs:45:28: parse error on input ‘=’ Failed, modules loaded: none.
07:44:12 <EvanR> it doesnt
07:44:30 <erisco> well if you're sure it doesn't then I don't see what the issue is
07:44:38 <stephen__> (when I try to load it into ghci)
07:44:40 <Squarism> What consequences will these instructions have: 
07:44:41 <Squarism> Compiler version mismatched, found ghc-7.10.3 (x86_64), but expected minor version match with ghc-8.0.1 (x86_64) (based on resolver setting in /home/karlw/Documents/src/labs/tmp/leksahlab/leksah/stack.yaml).
07:44:41 <Squarism> Try running "stack setup" to install the correct GHC into /home/karlw/.stack/programs/x86_64-linux/
07:44:43 <EvanR> we can move on to see the monad laws break
07:44:50 <erisco> the new pair is constructed with a commutative function
07:44:53 <EvanR> but you might not care about that either ;)
07:44:55 <Squarism> ...when building with stack
07:45:05 <erisco> where do the monad laws break?
07:45:32 <EvanR> it breaks the return law by observing the unobservable ordering
07:45:56 <erisco> this one?  join . fmap return   ≡ join . return = id
07:46:02 <erisco> which equivalence specifically?
07:46:04 <EvanR> i dont even know what that means
07:46:14 <EvanR> a function is equal to an equation
07:46:17 <erisco> you posted that... it is one of the laws stated with join
07:46:28 <EvanR> thats wikipedia
07:46:44 <erisco> I am pretty sure the second = is supposed to be ≡
07:46:50 <EvanR> oh the parens are around the ≡
07:47:04 <EvanR> that law holds
07:47:13 <Squarism> Can i have multiple GHC versions installed with stack?
07:47:21 <lyxia> thomasd: I think it comes up in data declarations, you can write data D where D, C :: D
07:47:22 <erisco> that is the law involving return… so are we good then?
07:47:32 <EvanR> theres 2 involving return
07:47:37 <EvanR> using the bind version...
07:47:47 <lyxia> thomasd: that translates to a DataD with a single Con, containing both names
07:47:47 <erisco> okay, which law is broken?
07:49:19 <EvanR> ok both return laws seems fine
07:49:28 <EvanR> now for assoc
07:51:08 <thomasd> lyxia: ahh, ok. thanks, that makes sense!
07:51:10 <EvanR> now im thinking about how its breaking the pair law... you can use it to find out which element is first
07:51:29 <erisco> how so?
07:51:48 <thomasd> I didn't know you could declare those unary constructors in GADTs like that
07:51:50 <erisco> that supposes you use recUP with a non-commutative function
07:51:59 <EvanR> which you do
07:52:06 <erisco> which you do in join but it is then guarded by UP again
07:52:08 <lyxia> thomasd: that's a possibility, I haven't checked it.
07:52:23 <erisco> there is no way to get fst :: UP a -> a
07:52:38 <lyxia> thomasd: I mean, checked that such a declaration is translated that way to template-haskell.
07:52:45 <EvanR> if you follow the laws, correct
07:52:55 <thomasd> lyxia: no worries, thanks again!
07:53:10 <erisco> yes, well, the external explanation for join is that it chooses some element of each sub-pair
07:53:22 <erisco> you cannot know which one
07:53:54 <erisco> is that unpleasant? maybe
07:53:55 <EvanR> fromPair (1,2) >>= id = (1,1)
07:54:37 <EvanR> er, (2,2)
07:54:44 <EvanR> no (1,1)
07:54:57 <erisco> yeah
07:54:58 <EvanR> recUP const (1,2) = 1
07:55:30 <EvanR> x >>= id is supposed to be return x
07:55:33 <EvanR> er
07:55:34 <erisco> choosing an element from an unordered pair may not be something you want, though you can have it if you want
07:55:44 <EvanR> is supposed to be x
07:56:16 <EvanR> {1,2} >>= id = {1,1}, breaking the monad laws (by breaking the pair laws)
07:56:26 <erisco> you are thinking of  x >>= return
07:56:42 <EvanR> oh
07:57:08 <EvanR> {1,2} >>= return = {1,2}
07:58:29 <erisco> make a deterministic choice from an unordered pair at your peril, I guess ;)
07:58:41 <EvanR> ... thats impossible
07:58:54 <EvanR> now im trying to figure out whats wrong with it
07:58:55 <erisco> it satisfied the laws
07:59:10 <erisco> the principle of it is wrong, if you consider it so
07:59:15 <EvanR> we failed to show why its broken, not really a proof
07:59:32 <haskell540> hello. how do you convert Html to PDF with pandoc? makePDF "works" with writeLaTex writer but it seems to expect latex not html. outputed pdf ignored css
08:00:01 <erisco> there is nothing impossible about it unless you stipulate such
08:00:19 <sm> haskell540: did you see http://pandoc.org/MANUAL.html#creating-a-pdf ?
08:00:30 <erisco> so you may exclude a Monad instance for that reason
08:01:02 <erisco> this is at the foundation of what you mean by unordered pair
08:01:08 <EvanR> this is hardly a rigorous proof of the monad laws
08:02:00 <erisco> there is nothing wrong with choosing an element from each sub-pair, you just don't know which
08:03:08 <haskell540> sm: no. is this solution with executing external pandoc binary? is there a solution with only using library?
08:03:24 <erisco> let ∈ be the relation of elements to pairs with that element, then if (x,y) ∈ p and (a,b) ∈ p there exists a q such that (x ∈ q ∨ y ∈ q) ∧ (a ∈ q ∨ b ∈ q)
08:03:52 <erisco> this is an axiom if you wish it to be
08:03:52 <sm> ah, I don't know but I would guess it can't be done 100% with the lib and you will have to run some external tools. 
08:04:08 <erisco> if the concept defies what you want to mean by unordered pair then you don't include it
08:04:11 <sm> FYI there is also #pandoc and the mail list archives
08:04:19 <erisco> and then the Monad instance goes away
08:05:03 <erisco> join is that axiom incarnate
08:10:17 <erisco> EvanR, I may have thought of a contradiction… will think about it while washing dishes
08:10:46 <thomasd> lyxia:
08:10:58 <thomasd> lyxia: I have another quick question that could use your input
08:12:15 <thomasd> let's say I'm forced to use template-haskell-2.10.0.0. Do you have any idea how I can get the resulting type of a GADT constructor when pattern matching on `NormalC Name [BangType]`?
08:12:36 <thomasd> I think this was the reason `GadtC` constructor was introduced
08:13:06 <tsahyt> I have some heuristics for STRIPS planning implemented here, and at the moment they operate over a fixed representation of the underlying planning task. I thought I would like to make them polymorphic over that representation, so my first attempt is a typeclass. http://lpaste.net/6988197062319800320 However I'm not sure whether this is the best solution. The alternative would be a record of functions, with
08:13:08 <tsahyt> the associated types becoming type parameters. I'm not sure what the pros and cons of either approach are, can someone help me with this?
08:14:04 <tsahyt> i.e. I'd have a record data STRIPS o f s = STRIPS { operators :: [o], ... }
08:14:25 <tsahyt> but since there are laws governing what constitutes a valid task representation, a class doesn't sound too wrong either
08:16:35 <lyxia> thomasd: Hmm good question. Try to reify the constructor. DataConI seems to contain the type of the constructor.
08:17:48 <thomasd> lyxia: thanks! I'll try that
08:18:10 <thomasd> will require some non-trivial refactoring :(
08:20:10 <erisco> the problem I was thinking of ended up not being a big deal
08:20:27 <erisco> the axiom as I stated it is weaker than what we're doing with join
08:20:40 <erisco> to tighten it up it is more complicated
08:24:01 <erisco> let ∈ be the relation of elements to pairs with that element, then if (x,y) ∈ p then (if (∃ (a,b) ∈ p such that (x,y) ≠ (a,b)) then there exists a q such that (x ∈ q ∨ y ∈ q) ∧ (a ∈ q ∨ b ∈ q) ∧ ¬(x ∈ q ∧ y ∈ q) ∧ ¬(a ∈ q ∧ b ∈ q) else there exists a q such that x ∈ q ∨ y ∈ q
08:24:09 <erisco> )
08:24:13 <tsahyt> I think my question really boils down to when to use a typeclass and when to use a simple type
08:24:29 <tsahyt> in this instance I have associated types too
08:27:01 <erisco> whoops, the exclusives are not needed… drop that
08:27:24 <erisco> the weaker one says (1,2) exists because ((1,2),(3,4)) exists, which isn't wrong, it is just weaker than what join is saying
08:27:47 <erisco> join is specifically about choosing one element from each sub-pair
08:28:32 <lpaste> jerbome pasted “combinations” at http://lpaste.net/6176125197410631680
08:28:41 <lpaste> jerbome revised “combinations”: “combinations” at http://lpaste.net/6176125197410631680
08:29:17 <jerbome> hi, haskeel beginner here, could someone have a look at http://lpaste.net/6176125197410631680
08:29:35 <jerbome> and tell me if there is a nicer way of writing possibleKeys, without using the do notation below
08:30:04 <erisco> EvanR, Axiom of choice ;)
08:31:26 <AndreasK> jerbome: let lowercases = ['a'..'z'] in return [lowercases, lowercases, lowercases] ?
08:31:46 <AndreasK> Could probably use replicate instead of writing it thrice as well
08:31:56 <erisco> jerbome, is the ordering significant?
08:32:37 <jerbome> erisco, not at all, what I want to achieve is building all combinations of 3 lowercases characters
08:33:16 <erisco> yes, you want the Cartesian product, right?
08:33:28 <AndreasK> try a list comprehension
08:33:32 <jerbome> AndreasK, ["abc..z", "abc..z", "abc..z"]
08:34:03 <AndreasK> jerbome: do you want [aaa,aab,aa....,zzz]?
08:34:14 <jerbome> AndreasK, yeah that's what I want
08:34:34 <jerbome> and yeah, list comp should have been the first idea
08:35:12 <Adeon> > let letters = ['a'..'z'] in [ [x, y, z] | x <- letters, y <- letters, z <- letters ]
08:35:14 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
08:35:42 <jerbome> Thanks!
08:35:46 <ahihi> > replicateM 3 ['a'..'z']
08:35:46 <pavonia> > sequence $ replicate "abc"
08:35:48 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
08:35:50 <lambdabot>  error:
08:35:50 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
08:35:50 <lambdabot>      • In the first argument of ‘replicate’, namely ‘"abc"’
08:36:10 <pavonia> Ah, replicateM is even better
08:36:22 <erisco> way to go :)
08:36:37 <jerbome> ah yeah, replicateM is definitely the prettier version
08:38:41 <stephen__> Hey all, I'm trying to learn where clauses and I can't figure out where I'm going wrong in this code. Could someone take a look? http://lpaste.net/345446
08:39:18 <stephen__> When I try to load it into ghci I get: "tut03.hs:9:44: parse error on input ‘=’ Failed, modules loaded: none."
08:40:18 <sm> hi stephen__, probably best to paste the full code
08:40:27 <Adeon> at least RealFloat is typoed, you have Realfloat
08:40:34 <Adeon> but that's not what would cause that error
08:40:41 <stephen__> That is the full code actually
08:41:15 <stephen__> It's not part of a project or anything, I was just trying to write that function to make sure I understood where clauses
08:41:33 <Adeon> fixing Realfloat it opens for me in ghci
08:41:41 <ph88^> does anyone know how the uniplate package compares to Data.Data.Lens ?
08:41:42 <Adeon> you sure you passed the same code to ghci as in that paste?
08:41:53 <AndreasK> I assume replicateM depends on the Monad instance for Lists? Some Haskell oneliners like that still look like magic to me
08:42:21 <Adeon> yeah
08:42:35 <Adeon> if you look at the list comprehension you might notice it's sort of like monad use in do notation
08:42:38 <sm> stephen__: when I save that to a file and load it in GHCI (8) with :load, I get a different error (line 4)
08:42:50 <Adeon> except I wrote it out because I was not smart enough to immediately see you can use replicateM
08:42:52 <stephen__> Adeon, I just fixed RealFloat and it's still giving the same error
08:43:15 <Adeon> the error is puzzling, it says syntax error on line 9, column 44 but your code has only 8 lines
08:43:31 <stephen__> I just double checked and it is loading the same as what was posted in the pastebin
08:43:35 <AndreasK> Maybe a encoding issue or something like that?
08:43:36 <sm> what command(s) are you running ?
08:43:40 <stephen__> I'm very confuse
08:43:44 <stephen__> d
08:43:53 <stephen__> That could be it
08:44:30 <AndreasK> Regard list monad, I looked at the Monad instance and >>= is actually defined as a list comprehension. Never used the list Monad so far so thats interesting
08:44:35 <stephen__> Does it look right to you all? I think I'm following some examples from the web exactly, so I'm not really sure what the problem is
08:44:53 <Adeon> yeah the code you pasted is entirely correct (except for the Realfloat typo) so problem is somewhere else
08:45:02 <stephen__> huh
08:45:13 <sm> what command(s) are you running ?
08:45:15 <stephen__> Could it be a problem with my ghci?
08:45:25 <stephen__> sm, I'm not sure what you mean by commands
08:45:30 <Adeon> I just saved it to LPaste.hs and then ran ghci LPaste.hs
08:45:35 <sm> what do you do to see that error ?
08:45:40 <stephen__> Oh
08:45:54 <stephen__> I'm trying to load it into ghci running in the same directory
08:45:56 <stephen__> so:
08:46:01 <stephen__> :l tut03.hs
08:46:29 <stephen__> ghci replies with:
08:46:30 <stephen__> [1 of 1] Compiling Main             ( tut03.hs, interpreted )  tut03.hs:7:44: parse error on input ‘=’ Failed, modules loaded: none.
08:46:30 <sm> ok, same here. To check encoding, maybe "file tut03.hs" at the shell prompt
08:46:55 <stephen__> It says it's ASCII
08:47:45 <stephen__> Weirdly enough I'm able to load other hs files into ghci with no problems
08:47:50 <sm> I see what you did there (different line number now)
08:49:09 <nitrix> stephen__: wget http://lpaste.net/raw/345446 && mv 345446 345446.hs && ghci 345446.hs
08:49:48 <nitrix> (I fixed the RealFloat typo in the lpaste)
08:49:48 <sm> stand up, turn around, touch your toes, deep breath, double-check everything :)
08:51:32 <sm> if that doesn't work, have you tried rebooting your... never mind
08:51:38 <nitrix> stephen__: If you're still having an issue; we'll need more info, like your version of GHC or else; but I highly suspect that your issue happened during copy-pasting and the identation.
08:51:46 <stephen__> wow this is weird
08:51:59 <stephen__> I think it's a problem with the way vim is doing indentation
08:52:14 <stephen__> when I do cat on my file the indentation is all weird
08:52:25 <stephen__> that must be it
08:52:47 <nitrix> stephen__: If we came to the same conclusion, it probably increases the likelihood :)
08:53:11 <stephen__> i've messed with the indentation settings in vim so I'm pretty sure that's it
08:53:17 <nitrix> stephen__: http://lpaste.net/345457
08:54:11 <stephen__> Thanks nitrix that's helpful
08:54:16 <sm> FYI, tabs are very seldom used in haskell code and AFAIK generally not recommended
08:54:22 <nitrix> stephen__: The haskell report mendates that tabs are 8 spaces, but you can configure vim to expand them as spaces and to tab stop at 4 spaces if you're like me :p
08:54:51 <erisco> those are some notepad tabs
08:55:40 <erisco> amusing to see first year students using notepad and having a horizontal scrollbar
08:56:08 <stephen__> Thanks for your help everyone, thought I was going crazy seeing code exactly like mine in examples lol
08:56:50 <AndreasK> Tabs vs Spaces, the neverending story
08:57:03 <nitrix> stephen__: In general, the community seems to agree that tabs are a big no-no. Cabal and GHC will give you warnings about them if it stumbles on one.
08:57:19 <nitrix> Cabal's parser*
08:57:23 <Adeon> isn't that only if you enable the warning, although it'll be in -Wall
08:57:42 <Adeon> which you should use
08:57:44 <nitrix> You should really always have -Wall. It catches so many things :P
08:57:45 <Adeon> warnings for everybody
08:57:47 <Adeon> warn about all the things
08:58:01 <sm> if there are tab-using haskellers here, no offense intended. I figured since haskell's indentation rules are a bit tricky, tabs might add confusion for beginners
08:58:11 <Adeon> I usually put -fno-warn-name-shadowing after -Wall though
08:58:14 <Adeon> please don't pitchfork me
08:58:37 <nitrix> I just try to be more creative with naming when I need to shadow.
08:59:13 <nitrix> It's not frequent enough to be annoying, and it's easier to reason about the memoization.
09:00:14 <nitrix> (e.g. I'm I borrowing this variable from another lexical scope, does it becomes shared, etc)
09:01:08 <nitrix> "I'm I", that's cute.
09:01:34 <ph88> "template, uniplate, and biplate each build up information about what types can be contained within another type to speed up Traversal." from https://hackage.haskell.org/package/lens-4.15.1/docs/Data-Data-Lens.html   My question: is it possible to do Traversal without deriving Data and Typeable
09:03:44 * hackagebot median-stream 0.7.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.7.0.0 (jmc41493)
09:07:14 <lyxia> :t traverse
09:07:16 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:07:42 <lyxia> that doesn't involve Data nor Typeable. ph88
09:07:52 <jedai> ph88: You sure can write Traversal(s) for type that aren't instance of Data and Typeable
09:08:20 <jedai> ph88: Data and Typeable are only necessary for Uniplate/Biplate to derive a Traversal autimatically
09:08:35 <jedai> *automatically
09:08:44 * hackagebot serokell-util 0.1.2.0 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.1.2.0 (gromak)
09:10:27 <ph88> with Traversal can i search a structure of multiple types for a specific type and once i found it change just that one type's value ?
09:13:33 <ph88> or is that a Biplate only thing ?
09:15:16 <jedai> ph88: if you have a Traversal for that type you can. Biplate role is to write those for you.
09:16:01 <jedai> a Traversal of your datatype for this particular constituent type
09:16:52 <ph88> jedai, of that type? i mean a structure such as     let foo = Foo (Bar "hello")   then search for all Bar's in the data structure with root node Foo and change the string
09:18:32 <jedai> ph88: I lack information here. What's the type of foo ? of Bar "hello" ?
09:22:27 <ph88> data Foo = Foo Bar     data Bar = Bar String
09:25:10 <jedai> ph88: Well you certainly can do what you want with transformBi (works on Biplate Foo Bar) but of course if that was your whole type you really wouldn't need this (you generally use Uni/Biplate on recursive types)
09:29:35 <ph88> jedai, ok but can i do this without using the uniplate package? I was looking at Data.Data.Lens .. it doesn't use uniplate right ?
09:29:43 <ph88> i mean it doesn't use the uniplate package
09:30:25 <jedai> ph88: sure it does
09:31:07 <jedai> ph88: it doesn't have the same UI but it's realizing your operation using uniplate bilate or template underneath
09:32:18 <ph88> damn it :/
09:32:31 <ph88> there is a bug in the uniplate package so i can't use it
09:33:28 <jedai> ph88: gtraverse is what you want from Data.Data.Lens I think
09:33:31 <ph88> i don't see an import on the uniplate package though    https://hackage.haskell.org/package/lens-4.15.1/docs/src/Data.Data.Lens.html#template
09:34:13 <ph88> all uniplate stuff https://hackage.haskell.org/package/uniplate starts with Data.Generics .. that import is not there
09:34:58 <jedai> butph88: Oh, it seems to reproduce the biplate strategy "from scratch", more or less
09:35:07 <MarcelineVQ> "/lens.cabal:    build-depends: uniplate >= 1.6.7 && < 1.7"
09:35:40 <jedai> ph88: though lens definitely use uniplate, that may only be in the .Plated module, I don't know
09:36:02 <jedai> ph88: You could always try using gtraverse on your type and see if it works
09:37:08 <ph88> ok thx i will take a look at gtraverse then
09:37:40 <ph88> so i understand generics bring stuff to compile time right? Is gtraverse all runtime ?
09:39:18 <jedai> ph88: hmm gtraverse only maps over the immediate subterms...
09:45:38 <lucky__> Hello world!
09:47:26 <lyxia> ph88: generic functions execute at runtime
09:47:40 <lyxia> they have quite some overhead
09:47:47 <glguy> jedai: Lens only uses uniplate for benchmarking against it
09:47:57 <ph88> jedai, what are immediate subterms ?
09:48:12 <glguy> GHC.Generics derived values don't necessarily have runtime overhead
09:48:13 <jedai> glguy: Ok, then using Control.Lens.Plated should be good idea ph88
09:48:19 <ph88> glguy, whao good to know ! so Data.Data.Lens can be free from using the uniplate package !
09:48:58 <ph88> lyxia, i never suspected it to be 100% free of overhead .. just thought it would be able to optimize something in comparison to non-generic approaches
09:49:07 <jedai> ph88: it is (I thought Control.Lens.Plated used it but apparently not)
09:50:46 <ph88> alright so Data.Data.Lens is still on the table :P
09:54:53 <jedai> ph88: this works with your example : foo & partsOf biplate %~(\_ -> [Bar "Goodbye"])
09:56:28 <jedai> ph88: or even foo & traverseOf biplate %~ (\s -> B "goodbye")
09:57:09 <ph88> jedai, thank you :)
09:57:28 <ph88> if this works it would bring an end of my 2 months search for a solution that works :)
09:57:54 <ph88> lyxia, i tried uniplate Direct .. it works .. but the boilerplate is just getting out of control
10:00:50 <ph88> jedai, just a question about gtraverse .. i'm thinking about how it compares to Data.Data.Lens .. maybe gtraverse uses GHC.Generics ?
10:01:14 <jedai> ph88: No it's a Data based solution
10:01:26 <jedai> ph88: and a quite primitive one I think
10:02:46 <ph88> jedai, when i look at the docs  https://hackage.haskell.org/package/generic-deriving-1.11.1/docs/Generics-Deriving-Traversable.html  i just see Generic1 which is of GHC.Generics. Source code page seems to be down
10:05:21 <jedai> ph88: note that I was talking about the gtraverse from Data.Data.Lens
10:05:59 <ph88> oh i just search for haskell and gtraverse and this was the first result ^^ 
10:06:02 <ph88> what's this thing i found ?
10:06:30 <jedai> https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Generics.html
10:06:58 <ph88> i mean the gtraverse in specific
10:07:15 <jedai> ph88: something else, from a package destined to ease the derivation of instances for a type instance of Generic (from GHC) I guess ?
10:07:38 <ph88> o_O
10:07:48 <jedai> ph88: "If you're using GHC.Generics, you should consider using the http://hackage.haskell.org/package/generic-deriving package, which contains many useful generic functions."
10:08:03 <jedai> that's the first line of GHC-Generis docs
10:08:08 <ph88> i couldn't get generic-deriving to work
10:10:39 <ph88> traversable is one thing though .. being able to change a specific value of 1 type is another i think
10:11:35 <ph88> yeah ok so says the describtion "A generic applicative transformation that maps over the immediate subterms."
10:12:42 <ph88> thanks guys
10:13:46 * hackagebot gnss-converters 0.1.20 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.20 (markfine)
10:24:10 <James123> (in vim, is there any plugin that displays the type of a function at the cursor in the status bar?)
10:28:24 <nitrix> James123: I use hdevtools with great success.
10:29:20 <James123> nitrix, thank you :)
10:29:51 <nitrix> It keeps a GHCi instance running in the background and feeds what you need to know to it. It's really fast. I had trouble setting it up the first time but now it's painless. Let me know how it turns out :)
10:38:47 * hackagebot writer-cps-transformers 0.1.1.0 - WriteT and RWST monad transformers  https://hackage.haskell.org/package/writer-cps-transformers-0.1.1.0 (minad)
10:42:02 <paolino> are implicitparameters going to stay ?
10:42:56 <paolino> it seems they are incompatible with ViewPatterns
10:43:47 * hackagebot writer-cps-mtl 0.1.1.0 - MonadWriter orphan instances for writer-cps-transformers  https://hackage.haskell.org/package/writer-cps-mtl-0.1.1.0 (minad)
10:45:59 <James123> nitrix, amazing plugin. Exactly what I was looking for. Thanks again!
10:46:21 <sm> how do you get the canonical non-symlink form of a FilePath ?
10:47:35 <sm> ah, canonicalizePath. I was mixing that up with normalise
10:49:55 <glguy> paolino: How are they not compatible? Also they probably aren't going anywhere
10:50:35 <paolino> glguy, the view pattern can't use the parameter
10:50:53 <paolino> not in scope error
10:51:00 <glguy> I've used them with ViewPatterns so maybe you can show what you've tried
10:51:59 <nitrix> James123: There's also syntax/error checking if you plug Syntastic to it. It'll tell you what lines and what errors you have.
10:52:25 <James123> nitrix, yes I already did that :)
10:52:57 <paolino> glguy: f :: (?conf :: a -> Bool) => a -> Bool ; f (conf -> r) = r
10:53:11 <glguy> paolino: "conf" isn't an implicit param
10:55:44 <paolino> the syntax seems correct
10:55:56 <glguy> No, implicit params use the ? sigil
10:56:12 <paolino> isn't it there ?
10:56:23 <glguy> No, it's not there
10:56:51 <paolino> mh, I use lpaste then
10:57:27 <paolino> oh you mean in the viewpattern
10:57:30 <paolino> my bad
10:58:16 <paolino> thanks, it's first time I try them
11:00:53 <paolino> yep, they work :-)
11:07:03 <paolino> glguy, do they imply additional costs ?
11:07:41 <paolino> at runtime
11:08:15 <glguy> They act like a function argument
11:09:16 <paolino> ok, like any other constraint I guess
11:17:31 <MarcelineVQ> jle`: Did you find a satisfactory answer for your question about (Maybe a, b) -> Maybe (a,b) in base?
11:19:16 <ongy> @hoogle (a, b) -> (b, a)
11:19:17 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
11:19:17 <lambdabot> Text.XML.HXT.DOM.Util swap :: (a, b) -> (b, a)
11:19:17 <lambdabot> Data.Tuple.HT swap :: (a, b) -> (b, a)
11:20:27 <MarcelineVQ> ongy: sure you could use swap, that'd be `fmap swap . sequenceA . swap` I think
11:20:34 <ongy> :t fmap swap . sequence . swap
11:20:36 <lambdabot> Monad f => (f b, a) -> f (b, a)
11:20:41 <ongy> just tried it in the query
11:21:15 <jedai> > uncurry (liftA2 (,)) . second pure $ (Nothing, 6)
11:21:17 <MarcelineVQ> Maybe is an applicative so there's also \(a,b) -> (,) <$> f a <*> pure b
11:21:18 <lambdabot>  Nothing
11:21:36 <jedai> MarcelineVQ: This version seems fine, no ?
11:21:43 <jedai> Yours I mean
11:22:20 <MarcelineVQ> Yep also a great option
11:22:35 <ongy> MarcelineVQ: I think we can even do it on the functor
11:22:44 <ongy> :t \(a, b) -> (, b) <$> a
11:22:46 <lambdabot> Functor f => (f t, t1) -> f (t, t1)
11:23:14 <MarcelineVQ> :D
11:23:16 <ongy> but I think tuplesections is an Extension
11:23:47 <jedai> ongy: it is, but a pretty natural one I think
11:23:56 <jedai> I like it a lot :)
11:24:40 <ggVGc> how do I turn ['a','b','c','d'] into ['a', 'c'] and ['b', 'd']?
11:24:52 <ggVGc> partution based on list position that is
11:25:02 <ggVGc> zip . partition?
11:25:04 <jedai> ggVGc: there's a nice foldr
11:25:04 <Rembane> ggVGc: splitAt I think
11:25:05 <MarcelineVQ> there's a cool foldr trick for that
11:25:20 <ggVGc> Rembane: how would splitAt work?
11:25:38 <ggVGc> where can I find the foldr trick :)
11:25:46 <jedai> ggVGc: foldr (\~(xs,ys) x -> (ys, x:xs) ) ([],[])
11:26:04 <jedai> > foldr (\~(xs,ys) x -> (ys, x:xs) ) ([],[]) [1..4]
11:26:06 <lambdabot>  <hint>:1:20: error: parse error on input ‘->’
11:26:22 <Rembane> ggVGc: Like this: splitAt :: Int -> [a] -> ([a], [a]) or this: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#splitAt
11:26:30 <jedai> > foldr (\x ~(xs,ys) -> (ys, x:xs) ) ([],[]) [1..4]
11:26:35 <lambdabot>  ([2,4],[1,3])
11:26:59 <jedai> ggVGc: see ?
11:27:28 <ggVGc> yep, thanks
11:27:31 <ggVGc> but, hm
11:27:32 <jedai> Rembane: he don't want to split the list at one position, he want to separate odd and even indexed elements
11:27:34 <ggVGc> what is ~?
11:27:43 <jedai> ggVGc: it's a lazy pattern
11:27:50 <Rembane> jedai: Oh. I see.
11:27:56 <jedai> ggVGc: it works without that but is much less efficient
11:27:56 <jle`> MarcelineVQ: i think i just wrote it out manually using fmap and tuple sections
11:28:14 <Rembane> ggVGc: zip xs $ tail xs
11:28:50 <jedai> ggVGc: because to ascertain you really have a pair as second element it must be evaluated and so on until the end of the list
11:29:43 <jedai> ggVGc: basically the ~ tells the code "don't worry it will be a tuple when you need it you don't need to check before you need xs or ys)"
11:30:00 <jedai> > foldr (\x ~(xs,ys) -> (ys, x:xs) ) ([],[]) [1..]
11:30:03 <lambdabot>  ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
11:30:12 <jedai> > foldr (\x (xs,ys) -> (ys, x:xs) ) ([],[]) [1..]
11:30:14 <lambdabot>  *Exception: stack overflow
11:30:41 <MarcelineVQ> jle`: good stuff
11:30:52 <jedai> ggVGc: see how the first one is perfectly fine on an infinite list but the second don't produce anything before it overflow the stack ?
11:31:37 <ggVGc> ah, right
11:31:43 <ggVGc> jedai: yeah, now I remember
11:31:51 <ggVGc> I forgot ~ is about laziness
11:32:15 <jedai> Rembane: that don't work, first its type is [(a,a)] instead of ([a],[a])
11:32:39 <jedai> Rembane: plus even if you use unzip on it afterward it still isn't right (both sides contains successive elements regardless of their index evenness)
11:33:38 <jedai> ggVGc: Not useful very often but sometimes you have to use it (or you could keep a p pattern then use fst and snd but that's ugly)
11:33:52 <jedai> ;)
11:34:03 <ggVGc> jedai: where can I find actual refence reading about ~
11:34:06 <ggVGc> I can't google it :(
11:34:08 <Rembane> jedai: Ach. :D
11:35:11 <glguy> ggVGc: They're called "equality constraints
11:35:20 <ggVGc> thanks
11:35:39 <jedai> ggVGc: https://wiki.haskell.org/Lazy_pattern_match
11:35:49 <jedai> glguy: he is talking about lazy patterns here
11:35:56 <ggVGc> I feel these are not the same thing :)
11:35:56 <ggVGc> yeah
11:35:57 <ggVGc> hah
11:36:12 <MarcelineVQ> jedai, ongy: you guys probably knew already but recently I found out that tuple sections allow you to match arbitrary positions in larger tuples as well, so you could even have something like \(a,b,c) -> (a, ,c) <$> b
11:36:23 <glguy> ggVGc: Those are called "irrefutable patterns"
11:36:50 <glguy> ggVGc: Patterns are documented in section 3.17 of the Haskell Report 2010
11:37:03 <jedai> ggVGc: glguy was talking about using ~ in a constraint (like a typeclass constraint) to assert that two types must be equals
11:38:09 <jedai> glguy: Right, I forgot this name, apparently the wiki of haskell.org is calling them lazy pattern match
11:40:11 <jedai> MarcelineVQ: Right, I really like TupleSections though it can get a bit crazy on big tuples (but then using big tuples in manually generated code is a bit crazy itself ;)
11:40:29 <joncol> Is it possible to use Trifecta with the Lexer package from another parsing library such as Parsec or Megaparsec?
11:41:55 <MarcelineVQ> jedai: I think sectioning even a 3-tuple is pushing it, in terms of being able to miss seeing an argument, but it's pretty neat
11:43:02 <erisco> 2-tuples in a pinch but more than that and you're hurting yourself
11:45:27 <xcmw> How can I generate lenses from a record constructed in template haskell?
11:48:19 <glguy> The same way as a normally defined record type.
11:49:30 <xcmw> glguy: I am trying to do it in the TH function
11:49:33 <ineedsleep> Hey guys I'm learning haskell and I heard this was a good place for help? Im learning the servant library and it's tuorial has this line
11:49:34 <ineedsleep> data Verb method (statusCode :: Nat) (contentType :: [*]) a
11:49:42 <ineedsleep> what does [*] ean
11:49:44 <ineedsleep> mean
11:50:10 <glguy> ineedsleep: That's enabled by the DataKinds extension, it's a list of types
11:50:19 <ineedsleep> also shouldn't a typeclass like Verb have an equals sign in it?
11:50:21 <xcmw> glguy: I get ‘RecordName’ is not in scope at a reify
11:50:23 <ineedsleep> oh ok
11:50:27 <ineedsleep> thanks
11:50:32 <erisco> '[a] has the kind [*]
11:50:54 <glguy> '[Int,Char] :: [*]
11:51:27 <erisco> my bad, it is polymorphic
11:51:56 <lpaste> glguy pasted “TH generated lenses for TH generated data types for xcmw” at http://lpaste.net/345523
11:52:14 <jedai> ineedsleep: here that allows one to specify a list of content-types (JSON, Html....) that can be returned from this request
11:52:54 <jedai> ineedsleep: (http allows the client to specify what content-type he wants in the headers of the request)
11:53:41 <jedai> ineedsleep: so the same request can return different content-type depending on the headers
11:53:50 <ineedsleep> Thanks for all the help guys. Im loving haskell so far, makes c# look so bad
11:53:59 <ineedsleep> glad to be moving on to haskell
11:54:12 <xcmw> glguy: Got it. I will use declareLens
12:00:56 <erisco> C# is the best language I have used professionally though
12:03:46 <fnurglewitz> erisco, C# is Java++ :)
12:04:19 <erisco> it is more verbose, and missing some features, but you can borrow many functional styles in C#
12:04:40 <erisco> I'd recommend Haskell to any C# programmer
12:05:31 <AndreasK> I do still miss the tooling available for C#/Java :(
12:05:40 <kuribas> erisco: C# is better than java
12:05:56 <erisco> yes
12:06:01 <kuribas> or less bad
12:06:08 <AndreasK> But it has gotten better by a lot in the last year or two though.
12:16:25 * earthy has not regretted moving to C# from Haskell
12:16:33 <earthy> which is saying a *lot*
12:16:55 <earthy> (haskell I still use for hobby stuff, but professionally C# is *much* easier to deal with)
12:19:57 <maerwald> earthy: not F#?
12:20:09 <maerwald> they are (to some degree) interoperable
12:20:44 <erisco> you aren't the only one who has to read the program, is the problem
12:21:47 <Rembane> So, you need a F# -> C# compiler and a C# -> F# compiler.
12:22:03 <NextHendrix> the key of D major
12:22:14 <Rembane> Or just do everything in the LINQ-monad.
12:22:14 <earthy> Rembane: not quite.
12:22:17 <maerwald> F# compiles to CIL, like C#
12:22:18 <earthy> maerwald: what erisco said
12:23:07 <earthy> it's *way* easier to find C# programmers than it is to find F# programmers
12:23:16 <JohanOS> lol k
12:23:17 <Rembane> earthy: This is so that other people can read your code.
12:23:24 <earthy> and that was very much more the case 3 years ago when I was hiring.
12:24:04 <erisco> I have the problem where I write C# code and it looks alien anyways
12:24:18 <earthy> Rembane: I prefer to write idiomatic C# with a functional slant so my coworkers can follow and improve their capabilities
12:24:31 <Rembane> earthy: How sneaky of you!
12:25:15 <osfameron> and it's not feasible to hire C# programmers and retrain them in F#?
12:25:17 <earthy> it's taken a couple of years of pushback but they're finally coming 'round to appreciating it :)
12:25:34 <earthy> it might be now
12:26:02 <earthy> osfameron: wasn't 3 years ago. we had quite some development pressure.
12:26:32 <osfameron> ah
12:26:54 <earthy> and I was still getting my bearings as I was just thrust into the tech lead role.
12:27:50 <earthy> and there was way way more that I needed to accomplish in fixing internal issues that changing languages seemed to me to be of lesser importance ;)
12:28:19 <earthy> ofcourse, knowing Haskell *did* help a lot
12:29:58 <maerwald> I'd rather write C than C#, because I'm very bad at any form of OOP
12:30:50 <earthy> maerwald: our C# code base looks pretty much like ADT's and functions.
12:31:00 <erisco> just interfaces are enough from OOP
12:31:47 <osfameron> earthy: oh sure.  Changing a team culture is a totally different question to choosing a language ;-)
12:33:48 <earthy> we *are* experimenting with FAKE though, so that's one step towards F#. :)
12:34:22 <erisco> with all these Haskell programmers looking for jobs you think it'd be easy to find them
12:34:37 <maerwald> lol
12:38:50 <hackrilege> when i type cabal install usb it fails, can anyone help?
12:39:24 <osfameron> earthy: FAKE?
12:39:53 <hvr> hackrilege: we need a bit more information
12:40:02 <osfameron> ah, http://fsharp.github.io/FAKE/
12:40:42 <erisco> hm, it would be nice to have non-total orders in Haskell
12:42:24 <hackrilege> usb-1.3.0.3 depends on bindings-libusb-1.4.5.0 which failed to install.
12:43:52 * hackagebot hoogle 5.0.5 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.5 (NeilMitchell)
12:52:26 <Rumia> Is the hackage package list page being weirdly slow for anyone else?
12:52:40 <kuribas> I am working on a parametric type editor.  If I could get funding, would anyone want to participate?
12:53:28 <erisco> what is a parametric type editor?
12:53:46 <kuribas> erisco: creating font-families from a single source.
12:53:52 * hackagebot telegram-api 0.5.1.2 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.5.1.2 (klappvisor)
12:55:06 <kuribas> erisco: like metafont, but interactive :)
12:55:17 <erisco> are there any examples? I don't understand
12:56:39 <erisco> does it interpolate curves from your drawing?
12:56:40 <kuribas> https://vimeo.com/123813231
12:57:01 <kuribas> erisco: more than that.
12:57:45 <kuribas> erisco: you can specify constraints, solve equations, draw using predefined pens, etc...
12:59:23 <kuribas> erisco: You can basicly parametrize anything.
13:01:34 <kuribas> erisco: In current font-design programs you have to work with the constraints of the fontfile format, like no overlapping curves, control points at extremes.
13:01:44 <kuribas> erisco: I want a program that does that for you.
13:02:01 <erisco> kuribas, sounds interesting
13:02:53 <kuribas> I used a bit of fontforge, but I found it rather tedious.
13:03:12 <tmobile> kuribas: Have you tried MetaFont?
13:03:18 <kuribas> tmobile: yeah
13:03:30 <kuribas> tmobile: https://github.com/kuribas/hmetafont
13:04:03 <kuribas> tmobile: I am rewriting metafont in haskell, so it can generate opentype fonts instead of bitmaps :)
13:05:09 <kuribas> And use a good language.  Metafonts unhygienical macro-expansion system is overly complex.
13:05:39 <kuribas> Since it defines both syntax and semantics at runtime!
13:07:04 <erisco> it starts as a simple macro system and snags features along the way
13:07:37 <tmobile> kuribas: That sounds like a really cool project!
13:07:57 <kuribas> erisco: for example inmetafont you could define + as a number, and - as a closing paren...
13:08:22 <kuribas> tmobile: I hope I can get output in less than a month.
13:08:43 <tmobile> kuribas: Is your work hosted anywhere? I'd be interested in following.
13:08:58 <kuribas> https://github.com/kuribas/hmetafont
13:09:45 <kuribas> https://github.com/kuribas/haskell-opentype, https://github.com/kuribas/mfsolve, https://github.com/kuribas/cubicbezier
13:10:26 <monochrom> yeah, I dislike latex because it's so bloody leaky macros.
13:11:34 <ggVGc> someone should reimplement tex in haskell
13:11:40 <ggVGc> type safe type setting!
13:12:16 <tmobile> I think a new language entirely would be required. TeX has a huge amount of superfluous cruft.
13:12:46 <kuribas> monochrom: plain tex is very lightweight.  It's latex and modern distributions that carry cruft.
13:13:12 <kuribas> And the monstruous kpathsearch path searching system.
13:13:20 <Tuplanolla> It may be lightweight, but it's still inadequate.
13:13:20 <monochrom> but plain tex is also pretty primitive
13:13:58 <monochrom> the cruft of latex etc is directly caused by the quirky macro spirit of tex.
13:14:33 <osfameron> my favourite thing about latex is when you make a mistake and you're dumped into an incomprehensible debugger :-)
13:14:34 <monochrom> i.e., if tex had real abstraction constructs, latex would be clean, and adding your own commands would be clean.
13:15:00 <ggVGc> osfameron: and can't exit!
13:15:11 <kuribas> Plain TeX isn't so bad.  In fact it makes more sense that LaTeX once you know it.
13:15:32 <osfameron> ggVGc: preach it
13:15:47 <monochrom> remember that the exit command is X :)
13:15:54 <ggVGc> to be fair though, my few ueses of latex has provided me some pretty nice documents
13:15:58 <ggVGc> that are very easy to modify
13:16:13 <ggVGc> rather than opening word docs in a stupid editor that I don't know how it'll mess up my layout
13:16:17 <kuribas> books made with latex look so ugly...
13:16:29 <kuribas> ggVGc: it's great for papers and documents.
13:17:03 <ggVGc> I use it to generate invoices, and for my CV. And it's great, since it's easy to modify the parts I need when I need it, and I never have to think about the layout again
13:17:07 <ggVGc> because I did it once at some point
13:17:18 <kuribas> Why do most publisher still use low resolution bitmap fonts with LaTeX?
13:17:22 <ggVGc> but if I ever have to actually work on the layout again, I cry
13:17:35 <tmobile> I'd agree that TeX is probably the best thing out there for preparing documents.
13:17:37 <Tuplanolla> Writing papers with LaTeX is not fun either.
13:17:39 <monochrom> P.S. You see my beef because I actually use latex in anger. You wouldn't see me talking about shortcomings of WordPerfect because I simply don't care.
13:17:48 <tmobile> But best =/=> good.
13:18:04 <Tuplanolla> The moment you need to automate plotting, loops, build automation, data acquisition, ...
13:18:05 <kuribas> Math stands out in LaTeX
13:18:21 <ggVGc> I write all my software in latex macros actually
13:18:26 <monochrom> But this is a lesson that the smartest guy does not invent the most usable tool. Because he's too smart.
13:18:40 <ggVGc> is he really that smart?
13:18:41 <xcmw> glguy: http://lpaste.net/345523 breaks the constructor. Try V1 { _field3 = 5, _field4 = 6 }
13:18:43 <ggVGc> I don't even know
13:18:46 <ggVGc> everyone says he is
13:18:49 <kuribas> Knuth is defenitely too smart.
13:18:53 <ggVGc> but I'm not sure what that means
13:19:10 <monochrom> To him, a leaky macro system is not a problem.
13:19:38 <glguy> xcmw: Yeah, declareLenses removes the fields, they're only used for naming the lenses
13:20:05 <ggVGc> wow, I just realised how off topic we were
13:20:08 <ggVGc> sorry :(
13:20:20 <erisco> it is only wrong if you look
13:20:23 <kuribas> ggVGc: he contributed to many algorithms and computer science.
13:20:29 <erisco> now you've spoiled it
13:20:36 <manek> Hello! :) I've got a question about compilers and wording. Namely what group of elements could we label as "term"? We've got "expression terms" for example. Could we label "function", "module", "library" also as terms in some IR (intermediate representation) ?
13:20:39 <osfameron> Schroedinger's topic?
13:20:47 <monochrom> :)
13:21:28 <monochrom> expression = term
13:21:33 <erisco> manek, declarations
13:21:36 <xcmw> glguy: Any way to keep the field names? If I declare it again with field names it complians that it is duplicated.
13:21:50 <erisco> manek, or the names specifically you can call symbols
13:22:20 <Tuplanolla> Type theory has an interpretation or two, but you can have your terms be anything you want, manek.
13:22:21 <kuribas> ggVGc: tex in haskell isn't off-topic :)
13:23:20 <erisco> there are at least as many type theories as denotations for x : T
13:24:27 <manek> monochrom, erisco, Tuplanolla : hmm, thanks, I've got to think about it a little bit!
13:25:40 <erisco> manek, I misunderstood your question a bit. I don't know what else is a term in this context. I consider "expression" and "term" synonymous, but I could be wrong
13:29:07 <manek> erisco: yeah, thats the question in fact - if term == expr 
13:29:19 <erisco> maybe they are using "term" as in a sentence/word of the language, and then "expression term" are a subset of those sentences
13:29:53 <manek> erisco: exactly, then the question is, what else could term be. Could we have "function term" or "module term" ? 
13:30:13 <erisco> if "term" means a sentence of the language, then yes
13:32:01 <erisco> I use the declaration/definition terminology for these kinds of top level constructs
13:33:16 <xcmw> glguy: Poking around the Control.Lens source code it looks like I need makeFieldOpticsForDec :: LensRules -> Dec -> DecsQ from Control.Lens.Internal.FieldTH
13:34:37 <glguy> xcmw: If you use that module just make sure your version bounds are fairly restrictive, it doesn't promise not to change
13:38:01 <monochrom> manek: Consider this line of code: "f x = Just (x + 1) :: Maybe Int". "Just (x+1)" is a term. "Maybe Int" is a type. the whole equation is a declaration.
13:38:54 * hackagebot vector-sized 0.4.1.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.4.1.0 (jophish)
13:39:11 <monochrom> See for example Haskell 2010 chapter 4 for all kinds of things under the umbrella of "declaration"
13:46:27 <justin_> can I have hints on making this faster? [(a,b,c) | a<-[1..], b<-[1..],c<-[1..], a+b+c==1000, a^2 + b^2 == c^2] ?
13:47:13 <erisco> how to determine if the components of one vector are less than the respective components of another
13:47:38 <nshepperd> justin_: you could obtain c by arithmetic instead iterating over all numbers?
13:47:42 <rjeli> a and b are interchangeable
13:47:54 <rjeli> so don't do a=1,b=2 and a=2,b=1
13:47:59 <monochrom> clearly you do not want [1..].
13:48:33 <xcmw> glguy: I give up. I got it to generate code but I the variables names in the data declarartion and lens code don't match. Is there a way to insert a template haskell call into the AST?
13:48:50 <monochrom> there is also a formula that generates pythogaream triples without brute force like this
13:48:54 * hackagebot datasets 0.1.0 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.1.0 (glutamate)
13:49:18 <erisco> does it enumerate them?
13:49:20 <nshepperd> oh yeah, also does [(a, b) | a <- [1..], b <- [1..]] even give an enumation of [1..]×[1..]?
13:49:35 <erisco> no it doesn't nshepperd
13:49:54 <monochrom> https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple
13:50:01 <justin_> monochrom: I'm trying to solve a problem with minimal help to try to get better
13:50:06 <nshepperd> I assume it results in the same as [(1, b) | b <- [1..]]
13:50:32 <grantwu> You can naively bound a, b, c, by 1000
13:50:42 <Tuplanolla> justin_: The key observation is that `x + y + z = n` implies `z = n - x - y` and with it `x^2 + y^2 = z^2` implies `z^2 = x^2 + y^2 = (n - x - y)^2 = n^2 + x^2 + y^2 + 2 x y - 2 n x - 2 n y`. This leads to the implicit equation `2 n (x + y) - 2 x y = n^2`, which has the solution `y = n (2 x - n) / 2 (x - n)` when the remainder is zero. Therefore, when `n` is fixed, both `y` and `z` are fully determined by `x` and there is only
13:51:07 <monochrom> > [(a,b) | a<-[1..], b<-[1..]]
13:51:10 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
13:51:17 <monochrom> You will never hit a=2
13:51:22 <Tuplanolla> With this you can write a list comprehension that only draws values from one list, justin_.
13:51:24 <monochrom> never
13:51:47 <monochrom> Tuplanolla, the long sentence got chopped at "and there is only"
13:51:48 <erisco> you and your digital computers
13:52:13 <Koterpillar> monochrom: so, the answer to making it faster is: putStrLn "Time limit exceeded"
13:52:25 <Tuplanolla> Thanks, monochrom. The end was "only one degree of freedom".
13:52:32 <monochrom> oh yikes, Euclid's formula generates the primitive triples only.
13:52:43 <justin_> okay thanks everyone!
13:54:23 <monochrom> Overall you should do what Tuplanolla says. Do math, use math to solve 99% of the problem before sending the remaining 1% to the computer.
13:54:49 <monochrom> which is what the Project Euler website says too.
13:55:02 <monochrom> I fail to understand why so many players ignore that advice.
13:55:12 <xcmw> Is there away to include a template haskell call in the AST?
13:55:28 <erisco> do it will there's still money in it
13:55:30 <monochrom> they seem to think "this site is a good excuse for brute-forcing everything!"
13:55:46 <erisco> while*
13:56:01 <Tuplanolla> Project Euler is basically number theory appreciation with some programming sprinkled on top.
13:56:12 <Tuplanolla> > triplets 1000
13:56:15 <lambdabot>  [((200,375),425),((375,200),425),((500,0),500),((600,-250),650),((750,-1000)...
13:56:34 <erisco> that was a bit frustrating when I did those… felt like all the math courses I failed in
13:57:10 <Tuplanolla> I see some negative triplets there, but I guess that's fine.
13:57:35 <erisco> the problem didn't state it has to make sense geometrically
13:58:25 <lykos_> I'm really rusty with Haskell-- cleaning up an old project I wrote. I'm curious if there's a cleaner way to do this:
13:58:30 <lpaste> lykos_ pasted “example” at http://lpaste.net/345568
13:58:50 <monochrom> number theory is harder because it ends up needing more ad-hoc techniques. compared to other areas or other courses
13:58:54 * hackagebot hlint 1.9.38 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.38 (NeilMitchell)
13:59:19 <lykos_> basically composing a function of type "IO String" with a function of type "String -> IO()". It seems like I should be able to flatten this somehow?
13:59:32 <monochrom> in most math courses, each course has a lot of related questions and the solution techniques are also related.
13:59:57 <monochrom> in a number theory course, only the questions are related, the solution techniques look like totally out of the blue
14:00:02 <catalin> What completion plugins do you guys use in vim? 
14:00:51 <erisco> lykos_, f $> "hello world"  perhaps
14:01:07 <xcmw> lykos_: randomString >>= putStrLn
14:01:40 <erisco> I mean  f x $> "hello world"
14:01:46 <maerwald> lykos_: keep it as it is
14:01:51 <erisco> or  f x $> x  possibly
14:01:55 <maerwald> there's nothing useful to change
14:02:07 <monochrom> I use emacs haskell-mode
14:02:18 <monochrom> oh oops, you want vim, I don't know.
14:02:33 <maerwald> catalin: youcompleteme
14:02:49 <maerwald> that's a plugin, not a statement
14:03:08 <Tuplanolla> I don't use anything, catalin.
14:03:27 <lykos_> erisco, what exactly does that do?
14:03:40 <monochrom> why does "youcompleteme" sound more like a dating website than a programming plugin? :)
14:03:51 <erisco> it gives you something of type IO String if f has type String -> IO () and x has type String
14:04:03 <catalin> i tried youcompleteme with neco-ghc but i get not type info on completion which sucks. Neco ghc by itself it's able to provide completion for local functions.
14:04:18 <maerwald> monochrom: I don't know, google employee with a drunk idea and started hacking up the most useful vim completer?^^
14:04:41 <k0ral> Hello
14:04:47 <osfameron> and yet it's *still* not quite as bad a name as cap'n'proto...
14:05:03 <srk> catalin: oh wow, was looking for such thing for vim last week. thanks!
14:05:22 <k0ral> has someone already implemented a Haskell type for Z/nZ (the quotient type) ?
14:05:31 <k0ral> or do I have to roll my own ?
14:06:18 <monochrom> I suspect it's on hackage but I don't know for sure
14:07:42 <erisco> lykos_, maybe you're just looking for >>=. I don't fully understand your question
14:09:40 <lykos_> yeah I was looking at it a bit more
14:10:13 <lykos_> basically, I'm just trying to directly chain together a function of "IO String" with a function from "String -> IO ()"
14:10:35 <lykos_> in a do block, without first using "<-" to convert from IO String to String
14:10:47 <lykos_> As I said, super rusty with Haskell
14:11:00 <erisco> IO String is not a function type. You are probably looking for >>=
14:12:18 <lykos_> okay, thanks for the help
14:13:50 <nitrix> lykos_: (>>=) @IO @String @String :: IO String -> (String -> IO String) -> IO String
14:13:55 * hackagebot datasets 0.1.0.1 - Classical data sets for statistics and machine learning  https://hackage.haskell.org/package/datasets-0.1.0.1 (glutamate)
14:14:13 <nitrix> I really wish lambdabot would have TypeApplications.
14:14:18 <erisco> sure lets dump type applications on there too :P
14:14:50 <erisco> :t (>>=) :: IO String -> (String -> IO String) -> IO String -- I just do this
14:14:51 <lambdabot> IO String -> (String -> IO String) -> IO String
14:15:07 <erisco> look to see if there is an error or not
14:16:43 <k0ral> I found https://github.com/mstksg/quotiented but it's not on hackage, maybe I should ask the author
14:16:54 <xcmw> lykos_: randomString >>= putStrLn     Does that work?
14:17:34 <erisco> and :t [x,y]  for unification
14:18:12 <erisco> :t [flip(<*>),(>>=)]
14:18:14 <lambdabot> [(a -> a) -> (a -> a -> b) -> a -> b]
14:23:33 <nitrix> int-e: How often have we seen pattern matching here lately with whitespaces? e.g. let f a @ (x:xs) = undefined in f
14:26:07 <nitrix> int-e: If I submit a patch to GHC where this conflict is resolved, would it now become a valid candidate for lambdabot's prestine?
14:27:08 <nitrix> As per TypeApplications, what follows up @ needs to be a type (not a type variable), and since types are uppercase to simplify the lexer, it could be easily determinable and the conflict avoided entirely.
14:29:20 <nitrix> I think they simply forgotten that case because I don't see a "should-fail" test on it.
14:30:01 <nitrix> https://github.com/ghc/ghc/blob/46b78e604c06c8878e436fea93729158dcf55269/compiler/parser/Lexer.x#L556
14:30:07 <nitrix> This is the only relevant comment I found.
14:31:55 <nitrix> I wonder if GHC's parser allows look-ahead.
14:32:07 <Tuplanolla> I'd be fine with as-patterns requiring spaces when using `TypeApplications`.
14:58:57 <delYsid> erisco: What exactly did that last expression do? It puzzles me.
14:59:29 <erisco> it is asking lambdabot for the type of the expression
15:01:18 <delYsid> nah, not :t, the [f,g] syntax.
15:01:31 <erisco> that constructs a list
15:01:40 <erisco> > [1,2,3]
15:01:43 <lambdabot>  [1,2,3]
15:02:16 <osfameron> ooi, why can't (,) be used infix without parens?
15:02:40 <delYsid> yes, but why is the result not [f a -> f (a -> b) -> f b, m a -> (a -> m b) -> m b]
15:02:47 <erisco> osfameron because *waves hands*
15:02:54 <osfameron> erisco: yeah, that's as far as I got :D
15:03:29 <MarcelineVQ> probably the same reason [foo,bar] needs [ ]
15:03:40 <erisco> delYsid, well think of this. Does [1,2] have the type [Int,Int]?
15:04:05 <delYsid> hmm, no :-)
15:04:19 <erisco> all elements have the same type
15:04:21 <delYsid> oh!!!
15:04:29 <delYsid> unification, now I get the meaning of the word :-)
15:04:44 <delYsid> thanks, that was quite enlightening.
15:06:22 <delYsid> sometimes it really sucks not to be a native english speaker, some things could be sooo obvious without the damn language barrier.
15:07:01 <erisco> yes, it is asking the compiler to solve the problem of finding a common type between the two
15:07:46 <erisco> by instantiating variables if necessary
15:08:13 <osfameron> delYsid: heh, I'm not sure being a native speaker always helps - you often don't notice the etymology/root meaning of words because you're so used to them
15:08:14 <delYsid> Put in my own words, putting several polymorphic values into a list can be used to check if they have a common, ohhh, unification ... :-)
15:09:07 <erisco> the solution is f = m = (->) a
15:09:17 <kirillow> When do I use coarbitrary instead of Fun?
15:10:14 <lyxia> What's fun?
15:10:22 <Rotaerk> haskell's fun
15:10:42 <hpc> @quote defun
15:10:43 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
15:10:49 <hpc> :(
15:11:02 <hpc> that was supposed to be the lisp quote
15:11:47 <kirillow> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Function.html
15:13:44 <odites> Hi to everyone. I want to store efficiently a two dimensional (immutable) word8 array. Do you suggest repa or something else?
15:14:01 <Rumia> @type foldr
15:14:03 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:14:26 <jle`> odites: vector or array should be fine
15:14:39 <Tuplanolla> Just store, odites?
15:14:40 <jle`> array has 2d-ability built into the api
15:14:56 <jle`> vector you might have to do some arithmetic to do 2d indexing
15:15:06 <jle`> or just use the Data.Ix API included in 'base'
15:15:08 <lyxia> kirillow: they have quite different roles, why do you think you would use one *instead* of the other
15:15:32 <kirillow> que
15:15:39 <kirillow> both generate functions?
15:15:44 <erisco> I hope to one day invent something so useful that people who don't even know my name receive it — incorrectly copied and misunderstood, but there in spirit.
15:15:44 <lyxia> No.
15:15:57 <odites> Tuplanolla: Initially store, after filter and then IO
15:16:38 <Tuplanolla> Then I'd probably use `Vector` and deal with the manual striding, odites.
15:16:39 <kirillow> actually yes
15:16:51 <kirillow> it says right there
15:17:04 <kirillow> coarbitrary: "Used for random generation of functions."
15:17:17 <Rumia> Where is "Fun" from?
15:17:26 <kirillow> quickcheck.function: "Generation of random shrinkable, showable functions."
15:17:40 <lyxia> "used for" is subtly different from "does".
15:17:53 <Rumia> ???
15:17:56 <kirillow> *rolling eyes*
15:18:19 <Rumia> I assume one uses the other?
15:18:22 <lyxia> Fun uses Coarbitrary too, like regular functions
15:18:51 <lyxia> it's a wrapper that allows you to also show functions
15:19:11 <Rumia> Wait..that doesn't make sense.
15:19:23 <lyxia> what doesn't
15:19:28 <Rumia> How can you show coarbitrary generated functions?
15:19:49 <lyxia> in general you can't
15:19:57 <odites> Tuplanolla: Thank you :) Can I use vector with 2-dimensional array? I'm n00b :(
15:20:27 <Tuplanolla> No; hence the remark about striding, odites.
15:21:49 <Tuplanolla> You have ``(row, column) = index `quotRem` stride`` or `index = stride * row + column`, odites.
15:22:26 <jle`> you can also leverage http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ix.html to calculate indices and rows/columns for you :)
15:24:16 <odites> :)
15:24:26 <odites> thank you, i'm watching :D
15:25:06 <yulax> hej, i have a problem
15:25:24 <Rumia> @lyxia then how can Fun use CoArbitrary?
15:25:24 <lambdabot> Unknown command, try @list
15:25:31 <yulax> the exercise i have involves finite state machines.
15:29:41 <lyxia> Rumia: you start by generating a function, which you can't show, but you can shrink it by restricting it to a function with finite support (defaulting to a constant on the rest of the domain), if you keep track of how that simplified function was constructed, you can show it.
15:30:06 <Rumia> Ah, that makes sense.
15:32:11 <yulax> https://paste.debian.net/hidden/4f5cdd05/
15:32:43 <yulax> the exercise wants me to use Eq q => q as one part of the function.
15:33:18 <yulax> i can make one version of my function work, but when i add == in the list comprehension, bad things happen.
15:33:39 <yulax> i would like to be pointed in the right direction regarding the format of this use of typeclasses please!
15:36:12 <lyxia> yulax: what's the type of iiiSnd
15:36:26 <geekosaur> what is the exact type of those? was it specified explicitly, or inferred?
15:36:56 <geekosaur> (those being iiiFst, iiiSnd, iiiThd)
15:40:59 <yulax> iiiFst, iiiSnd, iiiThd :: (a, a, a) -> a
15:41:15 <yulax> this may be the point of contention.
15:41:50 <Rumia> It is. Transition q =/= (q,q,q) .
15:42:19 <erisco> going to be in trouble at 5
15:42:37 <geekosaur> right, a must be the same in all of those, but Transition q is (q,Char,q) not (q,q,q) as that type signature requires
15:44:31 <Rumia> As a hint, you want iiiFst iiiSnd iiiThd to have /different/ types.
15:45:32 <yulax> oh, yea
15:45:43 <yulax> how silly of me
15:49:47 <yulax> it works now.
15:50:55 <yulax> but, i think i don't quite understand how we are implementing typeclasses, in this case "Eq q => q", in functions. 
15:51:40 <yulax> am i correct that this Eq is similar to a constraint of some sort?
15:52:05 <yulax> i know my funtion works, but how exactly is it satisfying the use of Eq a => a?
15:52:11 <yulax> thanks folks
15:53:47 <geekosaur> it is a constraint, and what it does is make sure that the function has access to the Eq instance and therefore knows *how* to do (==)
15:53:49 <Rumia> "Eq q" is a constraint.
15:54:31 <lordcirth> yulax, "Eq q => q" means "any q, where q is Equatable"
15:54:45 <yulax> right ok
15:54:59 <geekosaur> since it's a type variable and not a type, there is no guarantee that (==) is defined. unless you include that constraint, which tells callers to also pass along what (==) to use on the type they're using
15:55:26 <yulax> i was using instance Show Colour ... to allow me to show names of the type Colour that i had defined, which made good sense
15:56:01 <yulax> so when we are using "derives Ord, Show, Eq" etc at the end of functions, it is a similar concept?
15:56:09 <lordcirth> yulax, Indeed.  Show is the typeclass for which the function 'show' is defined, ie, things which can be turned into strings
15:56:47 <yulax> right, but since it isn't knowing what my colours are, that's why i have to define things like show Red = "red"?
15:57:54 <geekosaur> deriving is just telling the compiler to use what it knows to write instances for you
15:58:00 <lordcirth> yulax, data Color = Red | Green deriving Show
15:58:07 <geekosaur> it's a convenient shorthand
15:58:29 <yulax> ah, cheers
15:58:36 <lordcirth> So long as you don't mind the string being exactly the same as the value, 'derive' can automatically do it
15:58:47 <lordcirth> If you want to customize, yeah, you do it yourself
15:59:03 <yulax> ok, so presumably it would produce "Red" and "Green". clever.
15:59:11 <lordcirth> yulax, yes
15:59:26 <lordcirth> Similar with Eq - if you make a datatype using record syntax, and all the contents are Eq, you can derive Eq
15:59:49 <lordcirth> The automatic method being, if all contents are equal, the whole thing is
16:00:04 <geekosaur> even more cleverness may eventually show up; there's a proposal in the works for deriving strategies, and in theory that could include telling it to downcase the constructor names for derived Show instances someday
16:00:58 <lordcirth> so you could do 'deriving Show with downcase' and it would print "red" ?
16:01:15 <hpc> or you could use it to make deriving logic for your own classes
16:01:46 <hpc> (which there's a bit of now, but it depends on Data and Typeable and isn't tremendously good-looking)
16:01:53 <geekosaur> potentially, although the syntax would be a bit different. however note that that violates a sort of community guideline for Show instances (they should match Read instances and the result *should* try to be valid Haskell source)
16:02:22 <geekosaur> it's not a law as such, but a guideline that iirc is specified in the language report
16:02:32 <lordcirth> It seems a good guideline
16:02:39 <hpc> and the guideline for using Show/Read in general of do the bare minimum to make the output human-readable because it's not meant for logic
16:02:39 <Tuplanolla> Lisp envy.
16:03:55 <Rumia> Eh, its really only used for ghci, afaik. But is very useful there.
16:03:59 <geekosaur> and what hpc said about deriving strategies is what is driving them, but once you get there it's a short distance to being able to customize existing instances
16:04:19 <lordcirth> I love ghci
16:04:46 <hpc> ghci does so many little things compared to other repls, like :q instead of exit() or ^D
16:05:17 <lordcirth> lol I never knew that :q worked.  I always used ^D
16:05:26 <hpc> and :print, :set +s
16:05:36 <hpc> and :r
16:05:42 <hpc> :r is the biggest thing
16:05:59 <Tuplanolla> Just `:` too.
16:06:02 <hpc> you can also do multi-line commands with :{ and :}
16:06:28 <lordcirth> Is : the same as :r ?
16:06:43 <hpc> : seems to do nothing for me, but i might have a ghci that predates it
16:07:06 <hpc> my only wish is that :? would use a pager
16:07:14 <geekosaur> I think : might just rerun the previous command?
16:07:17 <hpc> because i don't know how to look at scrollback in screen
16:07:25 <Axman6> it annoys me that :Q and :R don't work, I manage to type them all the time
16:07:25 <lordcirth> Anyone know why, when I'm importing Brick.Types (Location) I get Not in scope: data constructor ‘Location’ 
16:07:44 <hpc> lordcirth: does Brick.Types define Location?
16:07:44 <lordcirth> Is there a gotcha I'm missing?
16:07:49 <geekosaur> you told it to import only the type constructor
16:07:56 <geekosaur> try Location(..)
16:07:58 <hpc> oh, or that
16:08:25 <lordcirth> geekosaur, got it.  So that's Location + all data constructors for it, right?
16:08:29 <geekosaur> yep
16:13:59 * hackagebot manifold-random 0.3.0.0 - Sampling random points on general manifolds.  https://hackage.haskell.org/package/manifold-random-0.3.0.0 (leftaroundabout)
16:26:29 <lordcirth> How am I getting "Pattern match(es) are non-exhaustive" when I'm using guards on a boolean?  I have one for true, and one for false.  Too many layers for the compiler to see, maybe?
16:26:53 <Koterpillar> lordcirth: what do your guards say?
16:27:18 <lordcirth> Koterpillar, | not (result^.costsTurn)   = , and | result^.costsTurn         =
16:27:33 <lordcirth> they are identical except for 'not'
16:29:17 <Axman6> not is just another function, ghc doesn't take its definition into account
16:29:28 <lordcirth> At least, I assume it's talking about the guards.  "In an equation for ‘fullGameTurn’: Patterns not matched: _ _"
16:29:44 <lordcirth> Axman6, Ah, I see. So should I use '== False' or something?
16:29:59 <Koterpillar> two arguments
16:30:01 <Axman6> I don;t think that's your problem at all. can you share the code?
16:30:13 <Koterpillar> please paste the whole definition
16:30:17 <surina> missing "otherwise", maybe?
16:30:20 <lordcirth> ok
16:30:52 <lordcirth> https://gist.github.com/lordcirth/3c2d9a0ad60dc0ee786db2654183b0c3
16:31:12 <lordcirth> Does the _ _ mean that the function args aren't fully matched?  Seems fine to me
16:31:32 <Koterpillar> I'm guessing what Axman6 said
16:31:35 <lordcirth> Also, this does work so far, it's just -Wall that complains
16:31:42 <lordcirth> So I use == ?
16:31:46 <Koterpillar> otherwise
16:31:55 <lordcirth> oh, true and otherwise. right
16:32:55 <lordcirth> yeah no warning now. Thanks
16:33:16 <lordcirth> I'm going through my code file by file with -Wall now
16:38:03 <surina> Why this gives an error: "flipMod7 = ((flip mod) 7) . (+)"?
16:38:11 <surina> I don't get it
16:38:28 <Tuplanolla> @unpl ((flip mod) 7) . (+)
16:38:28 <lambdabot> (\ x -> mod ((+) x) 7)
16:39:03 <surina> oh rigth
16:39:47 <Axman6> please don't write code like that :(
16:39:52 <Tuplanolla> :t ((flip mod) 7) .: (+)
16:39:54 <lambdabot> Integral c => c -> c -> c
16:40:03 <surina> Tuplanolla: Is it possible to run that "@unpl" in GHCi?
16:40:18 <hpc> it's a lambdabot thing
16:40:23 <Tuplanolla> You can `:!pointful '...'`, surina.
16:40:39 <Tuplanolla> It needs to be installed first though.
16:40:47 <surina> Yeah that is what I was after
16:41:01 <surina> ok
16:43:01 <surina> How can I then form a function, that first evaluates the (+) and then (flip mod) 7?
16:45:11 <Axman6> f x y = ((x+y) `mod` 7)?
16:45:47 <surina> lol true, I'm so stupid :D
16:51:53 <ggVGc> everytime I don't write haskell, I wish I was writing haskell
16:52:34 <lordcirth> Usually when I write in other languages, I wish I had some haskell function.  Usually map
16:52:42 <Moto-chan> Pretend you're writing haskell, mark everything const :P
16:53:03 <grantwu> I'm writing haskell right now and I wish I wasn't writing haskell
16:53:10 <grantwu> I wish I was eating pie ;-;
16:53:21 <Moto-chan> lordcirth: Most languages have a map, or an equivalent...
16:53:25 <Tuplanolla> I recently had the opposite experience with `quotRem` not working with `Fractional` things.
16:53:32 <Moto-chan> lordcirth: If your language doesn't have map, you probably aren't looking hard enough
16:53:50 <grantwu> I don't think C has a map
16:54:07 <Moto-chan> C is pretty much the only one I could think of.
16:54:19 <grantwu> x86_64 has no map :^)
16:54:25 <Moto-chan> Map in C would add needless complexity though
16:54:36 <grantwu> Wait, hrm, some of the SIMD instructions might qualify
16:55:38 <Moto-chan> Even C++ has map type functions. About 2 or 3 actually, depending exactly what you want it to do.
16:55:39 <ertesx> i wish "using haskell" was just about "having map"
16:57:41 <ertesx> if that were true, i'd probably still be a C++ programmer today, because: "we have map and filter" – "uhm, sure…  so?  i have those, too"
16:58:12 <Moto-chan> ertesx: It was just because one guy said he missed map in other languages... But I'm not aware of any language that doesn't have a map, or something similar.
16:58:15 <Koterpillar> the killer function is (.)
16:58:32 <Moto-chan> Currying is something that is missed
16:59:02 <ertesx> well, if the language has foldr, then i'll be a lot more interested in it…  i mean the real foldr, not some finite-list only-returns-when-base-case-reached approximation =)
16:59:11 <cloudhead> Moto-chan: Go doesn't have map either :/
16:59:28 <MarLinn> I think JavaScript doesn't have a map in general. And if it hasn't got something in general, you can't use it at all.
16:59:28 <Moto-chan> Never used Go
16:59:41 <grantwu> I believe JavaScript has some sort of map
16:59:46 <Moto-chan> ertesx: C++ has foldr :P It's just called std::accumulate
16:59:52 <grantwu> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
16:59:57 <ertesx> Moto-chan: is that the real foldr?
16:59:57 <Moto-chan> Or std::reduce if it's allowed be out of order
17:00:15 <ertesx> > take 1 (foldr (:) [] [0..])  -- can it do this?
17:00:18 <lambdabot>  [0]
17:00:20 <Moto-chan> ertesx: It uses a binary function to collapse the list in order, what's not foldr about it?
17:00:33 <grantwu> ertesx wants lazy streams
17:00:43 <Moto-chan> That's displaying laziness, not foldr :P
17:01:05 <ertesx> well, the real foldr needs laziness =)
17:01:17 <Moto-chan> The real foldr doesn't have laziness :D
17:01:19 <Moto-chan> Haskell does
17:04:21 <ertesx> "having foldr" is more involved than "has laziness":  more importantly it has a concept of algebraic data types, pattern-matching, and most importantly it allows equational reasoning without having to think about operational details
17:05:29 <ertesx> take 1 (foldr (:) [] [0..]) = take 1 (foldr (:) [] (0 : [1..]) = take 1 (0 : foldr (:) [] [1..]) = 0 : take 0 _ = [0]
17:05:42 <ertesx> this process of reasoning i would never trust in a C++ program
17:05:56 <Moto-chan> What does it know, exactly?
17:06:03 <Moto-chan> That the operations have to be in order?
17:06:58 <ertesx> well, in haskell foldr is a set of equations, but in C++ it's an operational piece of code
17:07:36 <MarLinn> grantwu: huh, I thought I remembered the support in JS was worse. But it seems it's even in IE 9!
17:08:01 <Maxdamantus> Well, you're never going to get a result from foldr on an infinite list if you don't have laziness.
17:08:42 <Maxdamantus> (that is, the ability for the result of foldr to be lazy in some way)
17:09:34 <Maxdamantus> and the "equations" and "operational piece of code" are equivalent.
17:09:53 <Maxdamantus> The real distinction is that one is defined in a lazy language, the other isn't.
17:10:10 <ertesx> in haskell the answer to "what is X?" is often: "well, it's defined as Y"
17:10:35 <ertesx> "what is (take 1 [0..])?" – "well, it's defined as (0 : take 0 [1..])"
17:12:21 <ertesx> i don't really think much about "laziness"…  i think in terms of these kinds of questions (together with pattern-matching) and their answers
17:12:45 <ertesx> why doesn't it loop?  well, because it's defined in such a way that the answer is finite
17:12:57 <ertesx> i hope this makes sense
17:13:47 <ertesx> in particular "doesn't loop" is a feature of the *question*, not a feature of lists or 'take' or 'foldr'…  that's the beauty of haskell
17:28:29 <jeezy_>  Hi all, I'm trying to finish my coursework to detect whether or not there is a path between two nodes but whenever i detect a node with a cycle my recursive search enters an infinite loop. I'm trying to fix this by tracking visited nodes but i'm struggling to implement this, any advice? (my node data type is: data Node :: Node Char [Node] ; where [Node] is the node's connected & Char is the label)
17:30:58 <mpickering> jeezy_: What do you have so far?
17:31:23 <mpickering> @lpaste
17:31:23 <lambdabot> Haskell pastebin: http://lpaste.net/
17:32:40 <jeezy_> mpickering: http://lpaste.net/5630717140261666816
17:34:23 <mpickering> Ok, then what happens 
17:34:52 <Tuplanolla> Does this function have a name: `\ x y -> x - y * fromIntegral (round (x / y))`
17:34:58 <jeezy_> mpickering: Link to CA: https://gyazo.com/1395bdb2d44e7e2d0c7002c958688c74
17:34:58 <mpickering> What are you calling reachable with?
17:35:10 <jeezy_> mpickering: reachable nodeA nodeH is infinite
17:35:45 <mpickering> ok I see what is happening I think
17:37:05 <jeezy_> mpickering: whenever it has to choose between two choices it always chooses the former. I need to implement a way to check all other connections
17:37:32 <mpickering> jeezy_: Well, the problem is a bit subtle
17:37:58 <mpickering> if you change "nz" to "reverse nz" on the last line then "reachable nodeA nodeH" works
17:38:52 <mpickering> But what is happening is, on the first call you get 
17:39:40 <mpickering> reachable nodeA nodeH ---> reachable nodeC nodeH || reachable nodeD nodeH 
17:40:01 <mpickering> then because of how || is defined, it checks to see if the lhs is true first, you get a loop
17:40:22 <mpickering> So I think the right way to fix this would be to keep track of which nodes you have visited
17:40:34 <mpickering> and return False if you loop back on yourself
17:40:51 <mpickering> any ideas how to do that?
17:41:17 <jeezy_> mpickering: yeah thats what i've been trying to implement. Also, reverse isnt working for me. 
17:41:28 <mpickering> ok, ignore that comment then
17:41:46 <mpickering> What have you tried to do?
17:42:32 <jeezy_> mpickering: i tried creating another function which calls reachable and has a third variable which is a list i can append the label of the current node to
17:42:46 <mpickering> that sounds right
17:43:13 <jeezy_> mpickering: i then thought i could have another guard to check if that node has been traversed but i don't know how to go back and select the other option
17:43:31 <jeezy_> mpickering: (inside of the original reachable)
17:43:59 <mpickering> Well, think about what happens
17:44:18 <mpickering> after the first call you have: reachable nodeC nodeH || reachable nodeD nodeH
17:44:33 <mpickering> so if the result of evaluating reachable nodeC nodeH is False
17:44:46 <jeezy_> mpickering: i think i understand
17:44:50 <mpickering> then you have to evaluate reachable nodeD nodeH in order to evaluate the ||
17:45:00 <mpickering> False || reachable nodeD nodeH
17:45:04 <mpickering> it sounds like you nearly have a solution
17:45:14 <jeezy_> mpickering: i know! thats the frustrating part
17:46:39 <jeezy_> mpickering: i did also post this on beginner haskell but no one responded. 
17:47:17 <mpickering> I am responding now to you
17:47:21 <mpickering> fear not
17:47:21 <jchia> I need to store an array of bytes of a fixed size that I read from a file. Should I use Data.Vector.Fixed.Unboxed, Data.Array.Unboxed or something else? What's the difference?
17:47:36 <mpickering> if you want more help post what code you have that doesn't work though
17:48:21 <jeezy_> mpickering: thanks!
17:51:03 <jeezy_> mpickering: last question, what code would i write after the otherwise guard to add a char to a list? (other than list ++ n) functional programming is still difficult to grasp.
17:51:41 <mpickering> You probably want something like c : list
17:51:46 <Cale> jeezy_: if you don't care what end of the list you're adding the character to, add it to the beginning using :
17:51:51 <mpickering> which will add the character c to the start of the list of characters
17:53:07 <MarLinn> Has someone here ever tried to install GHC on Red Hat/CentOS? I have no idea what to try any more...
17:53:18 <jeezy_> basically, i'm a lil' haskell baby. I don't know how to also say "perform function addToList after the otherwise"
17:54:03 * hackagebot htn 0.1.0.0 - resolver using htn algorithm  https://hackage.haskell.org/package/htn-0.1.0.0 (uj)
17:54:25 <mpickering> So your reachable function probably now has type "reachable :: Node -> Node -> [Node] -> Bool"
17:54:36 <jchia> MarLinn: I can build using stack on CentOS
17:54:39 <mpickering> you want to call reachable recursively 
17:55:03 <mpickering> and modify the list of visited nodes appropiately
17:55:15 <mpickering> but post some code and you will get accurate answers
17:55:35 <mpickering> I installed ghc using the generic bindist on centos
18:00:51 <MarLinn> jchia: I tried that, but I got the same error as when I tried to install it manually.
18:01:05 <MarLinn> And the error message basically just states that make has no executable to copy.
18:01:41 <jchia> MarLinn: I don't know what you're talking about. error message from where when you tried what? I can install stack on Centos 6.
18:02:12 <jchia> Install it from RPM as described on the stack webpage
18:02:29 <jchia> add the repo and yum install stack
18:06:46 <MarLinn> Ah, sorry. Installing stack worked, but stack couldn't install ghc.
18:07:55 <MarLinn> So I tried to use the "complete build", did "./configure", then "make install", as instructed. Then I see that some stuff is done in /usr/local/bin, but the step that is supposed to copy the ghci executable there fails because it has nothing to copy for some reason. That's all I could gather from the output.
18:09:03 * hackagebot concrete-haskell 0.1.0.1 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.1 (TomLippincott)
18:09:05 * hackagebot concrete-haskell 0.1.0.2 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.2 (TomLippincott)
18:10:03 <MarLinn> I suppose I might be missing build tools or dependencies, but it's not obvious what. I do have gmp-devel, zlib-devel, and glibc-devel
18:12:58 <MarLinn> Welp... thx for telling me it's at least possible, I was worried about that
18:15:29 <geekosaur> a log file might help
18:16:00 <geekosaur> for ghci in particular, you need ncurses-devel
18:17:55 <geekosaur> quite possibly others as well, that's just one I know off the top of my head. try to find stack's log file for thebuild (hopefully there is one) or see if you can get it to do the build in a verbose mode
18:20:48 <lpaste> MarLinn pasted “config.log (GHC on CentOS)” at http://lpaste.net/345612
18:21:45 <MarLinn> So that's one log I have. I'm having another go at "stacking" and will see if it creates a log as well
18:23:23 <riaqn> Hey guyes.
18:23:37 <riaqn> Any free lancer here? I was looking for a nice platform.
18:23:44 <riaqn> I mean, I want to be a haskell free lancer.
18:27:09 <ertesx> is {-A-} a standard comment?  i'm always worred when leaving out the spaces
18:27:11 <jchia> MarLinn: I think stack just downloads the ghc from somewhere
18:27:29 <MarLinn> riaqn: The best tip I can give you is try to be a freelancer first, Haskeller second. Start with the "easy" part of it if you will
18:28:03 <jchia> MarLinn: But after that maybe it tries to build a newer ghc? I'm not sure
18:28:18 <jchia> but i remember there are certainly libraries that are needed, like geekosaur said
18:29:05 <geekosaur> ertesx, the only space related worry is you need a space between a comment-start/end hyphen and another symbol-class char
18:29:09 <geekosaur> letters are fine
18:31:23 <ertesx> geekosaur: thanks!
18:34:44 <riaqn> MarLinn: Well I think being a haskeller is the easier part, if you will.
18:35:18 <riaqn> being a freelancer involves a lot of human interaction, software engineering stuff, which is hard.
18:39:59 <MarLinn> jchia: It looks like stack only downloads one GHC, probably the binary distribution. These downloads are easy to spot on a slow connection
18:40:27 <Axman6> it'll download the latest version needed for the specified LTS release
18:40:52 <Axman6> so if you're using lts-2.x, it'll download GHC 7.8.y IIRC
18:42:06 <MarLinn> riaqn: Haskeller < freelancer < Haskell freelancer, with two huge gaps ;)
18:45:07 <lordcirth> How would I call M.insert on a map, using a list of keys?
18:45:12 <lordcirth> a Map, rather
18:45:26 <Axman6> are there any values?
18:45:39 <MarLinn> Axman6: That confirms what I thought I learned through to this ordeal. (educational) Success!
18:45:49 <lordcirth> Axman6, the value I am inserting is the same
18:46:09 <Axman6> you could use foldl pretty eailiy for that
18:47:07 <lordcirth> prelude foldl or M.foldl?
18:47:07 <MarLinn> If you have key-value-pairs, I think there's a "fromList"
18:47:29 <lordcirth> MarLinn, If I understand correctly, fromList constructs a new map.  I need to modify one
18:48:46 <Axman6> prelude's foldl, you're folding over a list
18:49:20 <Axman6> I'm trying not to give you the answer because the learning is important and fundamental
18:49:51 <lordcirth> Axman6, yeah I will think about it a bit, thanks
18:51:32 <Axman6> :t foldl
18:51:34 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:52:16 <lordcirth> Axman6, yeah I'm looking at Hoogle.  Do I use the map insert as the accumulator?
18:52:21 <Axman6> :t foldl :: (Map String Int -> String -> Map String Int) -> Map String Int -> [String] -> Map String Int
18:52:22 <lambdabot> error:
18:52:22 <lambdabot>     Not in scope: type constructor or class ‘Map’
18:52:22 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
18:52:48 <Axman6> (assuming String keys and Int values, subsitiute as necessry)
18:53:11 <nitrix> Hi, how would I compile my application in a docker container and create an image of it?
18:53:19 <Axman6> can you write a function of yupe Map key value -> key -> Map key value?
18:53:34 <nitrix> `stack image container` seems to do the compilation, but then the image is destroyed.
18:53:39 <nitrix> I want to keep it to deploy that.
18:53:46 <Axman6> nitrix: you can compile it in a docker container using stack --docker build
18:54:05 * hackagebot pinboard 0.9.12 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.12 (jonschoning)
18:54:15 <Axman6> the docker integration in stack seems to be much more aimed at building than making images
19:19:06 * hackagebot pinboard 0.9.12.1 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.12.1 (jonschoning)
19:30:50 <ertesx> lordcirth: use foldl' instead of foldl
19:31:04 <lordcirth> ertesx, performance?
19:31:14 * Axman6 way going to say that too, but wanted lordcirth to get the solution first
19:31:24 <Axman6> yes, it is likely to perform better
19:31:25 <ertesx> lordcirth: foldl' does what foldl should do
19:31:36 <lordcirth> drop-in replacement, right?
19:31:40 <Axman6> yes
19:32:05 <ertesx> in general i wouldn't recommend using foldl at all…  there is no reason not to recommend foldl' right away
19:32:44 <ertesx> in fact just pretend that foldl doesn't exist…  it has no legitimate use cases
19:33:44 <glguy> Better than only using one would be just to understand the difference and use the one appropriate in each situation
19:33:51 <Axman6> I believe there are some, but they are few and far between
19:34:43 <ertesx> Axman6: i can't think of any that wouldn't be better handled by using foldr
19:35:04 <Axman6> I have seen examples before, but don't remember what
19:39:36 <ertesx> Axman6: a common example is 'last', because foldl' would insist on evaluating the element, but that one is better written using foldr, because foldl still builds the expression tree
19:49:07 <glguy> Functions like "reverse" implemented with foldl don't benefit from foldl'
19:49:33 <glguy> You end up doing an extra no-op case on something that's already not a thunk
19:52:34 <glguy> But at worst it's just slower, it doesn't compute the wrong thing
19:53:03 <ertesx> glguy: well, this is another case of: use foldr
19:53:32 <ertesx> foldl will always do twice the work
19:54:25 <glguy> What's the 2x work for a foldl reverse?
19:54:46 <Axman6> foldl is definitely the right tool for writing reverse
19:55:23 <dibblego> foldl does a loop, foldr does constructor replacement
19:57:35 <ertesx> indeed, foldl does the right thing here…  i'll give you one edge case of foldl usefulness =)
20:02:33 <ertesx> (actually foldr is even worse for that one, unless i do foldl in terms of foldr)
20:04:16 <ertesx> > foldr (\x -> (. (x :))) id "abc" []
20:04:19 <lambdabot>  "cba"
20:23:35 <talzs> Any suggestions for an editor on windows?
20:25:22 <JuanDaugherty> you mean if ur on windows all the time? I normally use VS but i avoid the platform these days outside paid work
20:25:45 <JuanDaugherty> eclipse is an option
20:26:16 <talzs> Mostly I use nvim and linux, but I have a desktop that runs windows that i'd like to program on
20:26:30 <Axman6> I usually just download sublime text.
20:26:41 <Axman6> atom has pretty decent ghc-mod integration
20:26:58 <JuanDaugherty> also if you have a unix in dos like mingw or whatitsname emacs and so forth
20:27:05 <JuanDaugherty> cygwin
20:27:28 <JuanDaugherty> and isn't the current dos dev working on linux?
20:27:49 <JuanDaugherty> by dos I mean MS
20:28:08 <sm> IDEA
20:30:23 <talzs> I tried messing around a bit with the ubuntu windows, but I ran into a few issues with it and stopped. Thinking about it though I'm going to give it another shot. I'll checkout sublime and idea also. If nothing else it adds a good bit of procrastination for me heh
20:33:19 <ertesx> talzs: note: both emacs and vim are available natively for windows
20:34:00 <ertesx> at least emacs works well enough, because it makes the peculiarities of windows largely invisible
20:35:09 <talzs> yeah, I've had gvim setup a number of times. My last adventure was trying to get nvim working with python, but that didn't work out. Currently messing about with spacemacs but I can't say I'm too big of a fan
20:35:15 <codygman> Is there any way to force garbage collection of something in ghci? Any proposed work on things like that or persisting data across ghci?
20:35:58 <ertesx> codygman: if you import System.Mem, you can invoke the GC explicitly, but it's unlikely to do anything
20:36:21 <ertesx> codygman: you can persist values between reloads using 'rapid'
20:36:25 <ertesx> @package rapid
20:36:26 <lambdabot> http://hackage.haskell.org/package/rapid
20:36:37 <ertesx> but not between invocations of GHCi
20:36:49 <ertesx> you need some kind of serialisation for that
20:36:55 <codygman> ertesx: Thank you! That is exactly what I'm looking for
20:38:49 <codygman> ertesx: Yeah, I was trying serialisation with binary-serialise-cbor but it takes around 1m30s with my data set. I thought maybe I can mmap it but I'm currently struggling to get a storable instance for my bytestrings, trying to use vector-bytestring which is already storable. If you want to check it out: https://github.com/codygman/cache-csv-bytestring-mmap 
20:39:25 <ertesx> codygman: dynamic-length strings should not be Storable anyway
20:39:42 <codygman> tl;dr I want to read csvs of data with ints, dates, and bytestrings into memory, mmap the parsed value into memory, then read it back from the mmapped file.
20:40:11 <codygman> ertesx: I don't need the strings to be dynamic length actually. They are typically under 100 characters
20:40:17 <codygman> couldn't I just use some data type to always take that amount of space
20:40:32 <codygman> then upon reading the mmap do a transformation to turn them back into bytestring or whatever?
20:40:33 <ertesx> sure, if you write a safe wrapper around ByteString
20:40:42 <talzs> ahh I found my issue with bash on windows again, no timer_create, stack throws an error because of it =/
20:40:59 <codygman> I thought maybe I could naively use vector-bytestring which stores bytestrings as a Storable.Vector Word8
20:41:09 <ertesx> codygman: i'm not entirely sure about the CSV thing…  is this only about keeping the CSV in memory?
20:41:54 <ertesx> codygman: because if you process it in a streaming fashion, just reading it from a file every time should be good enough…  the OS cache takes care of keeping it in RAM
20:42:05 <codygman> ertesx: parsing the csv takes 2m30s. I want to do iterative development on it from the point right after parsing it. So I'll try something, get an answer, and repeat 10 times per minute or so.
20:42:07 <ertesx> if you need dynamic access, then that's a different story
20:42:20 <ertesx> hmm?  how much RAM do you have?
20:42:34 <codygman> I have 16GB
20:43:01 <hodapp> ertesx: thanks for mentioning that, that looks like a handy package
20:43:03 <codygman> I am tryingout just keeping all data loaded in a ghci session, which led to my first question.
20:43:23 <ertesx> i see…  yeah, you can benefit from rapid then
20:44:01 <codygman> my memory usage right now is 20GB for the data but is apparently only 300MB compressed, though I'm not sure what is meant by compressed. I know my computer isn't going slowly even though more memory is being used than I have ram.
20:44:13 <codygman> ghci seems a little delayed
20:46:06 <codygman> ertesx: Yeah, I think I'll play with rapid more and see how that works.
20:53:59 <chink> a 
20:54:03 <chink> hello
20:55:48 <ertesx> cool, i didn't know about zram
20:56:05 <ertesx> hi chink!
21:02:18 <augur> what the hell is going on with parsec
21:02:30 <augur> *Main> main
21:02:30 <augur> x where
21:02:30 <augur>  x = (y + 
21:02:33 <augur> z)
21:02:34 <augur> Left (line 3, column 2):
21:02:36 <augur> unexpected ")"
21:02:38 <augur> expecting " ", "\n" or ")"
21:02:42 <geekosaur> @paste
21:02:42 <lambdabot> Haskell pastebin: http://lpaste.net/
21:02:51 <augur> yes parsec you saw a ")" and you were expecting one, what the hell
21:03:12 <augur> geekosaur: ooooh fiiiine i'll use this in the future for my little pastes :P
21:03:29 <geekosaur> 3 lines is outside "little paste" in genera
21:03:55 <geekosaur> but, parsec is prone to produce that kind of weird error when some production that should have been in a "try" parsed too much
21:04:16 <augur> geekosaur: i see
21:04:26 <geekosaur> it doesn't know that happened, it knows something failed on a ')' and that the whole expression should have been one of those things, but can't tell that it actually failed in a sub-branch
21:04:56 <geekosaur> usually but not always because a missing try caused an alternative to not see what it expected
21:05:16 <geekosaur> because it was partially eaten by the failed first alternative
21:05:38 <geekosaur> (in this case, possibly it consumed the 'x' and the alternative wanted that name before the ')')
21:06:10 <geekosaur> sometimes refactoring the grammar helps avoid this too
22:33:31 <mrkgnao> can I specify some "default" dependencies for stack to include in cabal files/
22:33:35 <mrkgnao> ?*
22:33:35 <lambdabot> Maybe you meant: v @ ? .
22:33:57 <mrkgnao> I'm talking about mtl, containers, transformers, and the like
22:34:06 <mrkgnao> or would I need to create a new template?
22:49:14 * hackagebot freer 0.2.4.0 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.4.0 (alcabrera)
22:52:16 <ania23> ones :: [Int ]
22:52:18 <ania23>  ones = 1 : ones
22:52:43 <ania23> may I refer "ones" as function?
22:52:58 <jle`> it's not a function in the haskell sense
22:53:08 <jle`> in the way that "functions" is defined in haskell
22:53:28 <jle`> so, no, you can't
22:53:47 <jle`> but at the same time, it's not like people will arrest you if you do :)
22:54:25 <glguy> Will they arrest me if I call it a Float?
22:55:06 <glguy> I guess what I really want to know is when does the arresting start
22:55:49 <ania23> so, without abusse of notation, may i refer it as function?
22:56:37 <glguy> It's an abuse of notation, you'd just free to call it whatever you want, function, tree, video
22:58:57 <jle`> ania23: you're free to call it whatever you want, but that doesn't mean that it'll be correct, or useful, or helpful
22:59:05 <jle`> calling it a function is neither correct, nor useful, nor helpful
22:59:11 <ania23> cann i call it list
22:59:15 <jle`> yes you can
22:59:21 <ania23> thx
22:59:27 <jle`> not only can you, but it's also correct :)
22:59:34 <ania23> :)
23:00:38 <ania23> lazy evaluations is outermost evaluation
23:00:49 <jle`> ania23: in haskell, functions are values whose types are created using the (->) type constructor
23:00:49 <ania23> how is refered innermost evaluation?
23:01:12 <jle`> like how lists are values whose types are made from the [] constructor
