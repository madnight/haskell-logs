00:00:23 <peddie> zd234: I don't think it only provides a heterogeneous list
00:00:42 <zd234> peddie: yeah, so question is: what else is it providing :-)
00:01:06 <peddie> zd234: it probably also seems really complicated because there is not a lot of documentation -- you just have to power through a lot of class definitions I guess :)
00:01:20 <zd234> peddie: I'm starting to learn type functions, so I do not mind
00:01:29 <liste> Tendies: you mean the where block?
00:01:30 <zd234> but I do want to understand what the purpose of hlist is
00:01:45 <Tendies> no in combining the list comps on line 5 & 7
00:02:51 <merijn> zd234: HList predates a lot of fancy stuff like GADTs
00:03:04 <peddie> zd234: just from looking at the documentation index, it seems it provides some kind of record system with tagged variants, an array, type-level currying, keyword arguments . . .
00:03:09 <zd234> merijn: oh, so with haskell 7.10.*, it should be much shorter ?
00:03:10 <liste> Tendies: you're combining the two definitions into one?
00:03:18 <Tendies> or i suppose to otherwise prevent use of 2 list comps, when i wrote it i knew it wasnt the most concise
00:03:53 <merijn> zd234: With GHC 7.10 and liberal application of extensions you can easily write it in a few lines of code (see: https://gist.github.com/merijn/dc00bc7cebd6df012c5e)
00:04:19 <Tendies> since fp2 is only a list comp, doesnt take arguments
00:04:30 <zd234> merijn: this is closer to what I saw in the CTRex paper; thanks for clarifying this :-)
00:04:37 <liste> Tendies: more concise isn't always better
00:04:39 <peddie> oh fantastic, thanks for explaining this history, merijn -- I had no idea
00:04:49 <merijn> zd234: The other thing is that HList has a ton more features like labels, etc.
00:05:22 <zd234> merijn: can you explain to me where '[] and ': comes from? I see it alot but I don't see where its defined; and it looks like some type of type level computation; but I haven't inferred anything else
00:05:38 <merijn> zd234: That's from DataKinds
00:06:03 <zd234> merijn: https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/kind-polymorphism-and-promotion.html <-- is that what I should be reading, or something else?
00:06:05 <merijn> zd234: Basically DataKinds lifts every value to the type level, this lets you write "type level lists"
00:06:14 <merijn> zd234: Yeah, that's the one
00:06:17 <liste> Tendies: hint: you can do [x |Â a <- [1..10], x <- [1..a]]
00:06:26 <merijn> zd234: the apostrophe is disambiguation
00:06:35 <liste> > [x | a <- [1..10], x <- [1..a]]
00:06:37 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,2...
00:07:29 <merijn> zd234: Because "[Int]" could be either 1) "[Int] :: *" i.e. a type of kind * which is a value level list of Int, or 2) "[Int] :: [*]" a type of kind [*] (i.e., a list of types) which is a type level list of types
00:09:24 <zd234> merijn: I apprecaite your help
00:09:30 <zd234> but I think this is where I go and pore over the docs
00:09:37 <zd234> any other suggested reading for data kinds?
00:12:02 <Tendies> ah i guess i shouldnt do that liste, it flattens the list
00:13:18 <Tendies> what does Eta reduce mean?
00:13:31 <merijn> zd234: tbh, I don't really know any good basic intros
00:13:43 <liste> Tendies: turning "f x = a b x" into "f = a b"
00:14:06 <liste> ie. removing unnecessary variables
00:15:40 <Freundlich> Tendies: It states a denotational equivalence: If you have an implementation i of function f, then \x -> i x is also an implementation of f (and vice versa).
00:16:21 <Freundlich> You basically surround a function by another function.
00:16:32 <Tendies> oh my, where blocks make my work look so much cleaner
00:18:07 <merijn> Tendies: Word
00:18:35 <merijn> Tendies: Step 1) muck about for 2 hours and create unbearable mess, Step 2) refactor liberally using where block, Step 3) elegance
00:18:59 <Tendies> i was wondering why my code looked gross when i was composing functions which i heard was sort of one of functional programming's THINGS
00:19:15 <Tendies> the composition part is a functional THING i mean
00:30:24 <scop2229> Hello, How is everyone!
00:32:06 <liste> hello scop2229! I'm fine, thank you (:
00:32:07 <scop2229> anyone know any good channels to get some javascript help
00:32:14 <liste> scop2229: maybe #javascript ?
00:32:20 <liste> or ##javascript, whichever exists
00:32:29 <scop2229> there a bit quiet 
00:32:45 <Tendies> How do I take a string "test" and a list ["X","X","X","X","X"] and produce "testXXXXX"? ive tried like, "test" ++ foldl (:) ["X"...]
00:32:56 <liste> scop2229: just be patient, maybe they're asleep
00:33:49 <merijn> > concat ["X","X","X","X","X"]
00:33:51 <lambdabot>  "XXXXX"
00:34:06 <Tendies> why didnt that work on mine ._.
00:34:13 <merijn> Tendies: Note that "X" is just syntactic sugar for ['X'] (i.e., a list of Char
00:34:21 <merijn> Tendies: Did you have "X" or 'X'?
00:34:36 <Tendies> oops wrong replicate arg
00:34:42 <Tendies> :)
00:34:43 <merijn> :)
00:34:55 <merijn> :t "X"
00:34:56 <lambdabot> [Char]
00:34:59 <merijn> :t 'X'
00:35:00 <lambdabot> Char
00:35:11 <Tendies> > replicate 5 "X"
00:35:12 <lambdabot>  ["X","X","X","X","X"]
00:35:18 <Tendies> is what i did
00:35:29 <merijn> > concat (replicate 5 "X")
00:35:30 <lambdabot>  "XXXXX"
00:35:32 <merijn> But note
00:35:37 <merijn> > replicate 5 'X'
00:35:38 <lambdabot>  "XXXXX"
00:35:58 <Tendies> yeh i put singles instead of double
00:36:15 <merijn> > "test" ++ replicate 5 'X'
00:36:16 <lambdabot>  "testXXXXX"
00:39:39 <zd234> merijn: okay, so 7.8.2.2 basically says '[], ': and '(tuples) are special cases
00:40:02 <merijn> Yes and no
00:40:10 <zd234> merijn: for the sake of education, could you rewrite just these three lines: https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L13-L15
00:40:13 <merijn> Imagine if I write "data Foo = Foo" I run into the same issue
00:40:15 <zd234> without the use of '[] and ': ?
00:41:55 <merijn> zd234: That would end up like: http://lpaste.net/152731
00:43:00 <zd234> merijn: another dumb question "List * -> *" should NOT be read as "List of Anything to Anything" but "List of Types to Types" ?
00:43:20 <zd234> this http://lpaste.net/152731#line2 is just standard list definition
00:43:22 <zd234> yet you're stuffing types into it
00:44:07 <merijn> zd234: Hold on, lemme introduce some fictional syntax
00:45:07 <merijn> zd234: Does the following fictional syntax make sense? "kind Nat = Zero | Succ Nat" (i.e. "Zero :: Nat" and "Succ :: Nat -> Nat"), where Nat is a kind and "Zero" and "Succ" are types?
00:45:36 <zd234> sure, the only thing "fictional" is that you wrote "kind Nat =" instead of "data Nat ="
00:45:54 <merijn> zd234: Yes, but that means they're very different in what they mean :)
00:46:12 <zd234> so with "data", Zero/Succ = constructors, and Nat = type; with "kind" , Zero/Succ = types, and Nat = kind ?
00:46:22 <merijn> zd234: Now, what DataKinds basically does is: Whenever you write "data ...." it copies/duplicates all of that with "kind" too
00:46:28 <merijn> zd234: Yes
00:46:41 <zd234> whoa, mist lifted
00:47:10 <zd234> they should put that as the first line of https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/kind-polymorphism-and-promotion.html
00:47:23 <merijn> zd234: Note, that all values in haskell have types that have kind *, therefore you cannot have a value that has kind Nat (or [*], or...)
00:47:57 <zd234> merijn: I'm going to admit, I still don't know what the word "kind" means
00:48:02 <Tendies> what is the equivalent of "continue()" in haskell? i have a then case where i dont want it to do anything
00:48:11 <merijn> zd234: "kind" just means "type of type"
00:48:20 <zd234> merijn: okay
00:48:25 <merijn> zd234: types are to values as kinds are to types
00:49:05 <merijn> zd234: A simple example would be, "Why is 'Maybe Int Char' a compile error?"
00:49:14 <zd234> "Maybe Int" is a type
00:49:21 <zd234> you can't apply it to Char
00:49:32 <zd234> Maybe is :: somethign -> something
00:49:35 <merijn> zd234: Right, which is what the kind system is for in the compiler :)
00:49:52 <merijn> "Maybe :: * -> *" (i.e. it takes a type of kind * and returns a type of kind *)
00:49:53 <zd234> is "kind" different from just "arity" ?
00:50:17 <merijn> zd234: Yes, because, let's consider: "data Foo f a = Foo (f a)"
00:50:29 <merijn> zd234: We get "Foo :: (* -> *) -> * -> *"
00:50:36 <jle`> Tendies: what do you mean?
00:50:50 <zd234> merijn: I see, okay
00:50:59 <merijn> (The 'f' must have "* -> *", because we're applying 'f' to 'a')
00:51:03 <zd234> right
00:51:18 <jle`> Tendies: x = if p then "hello"  -- that doesn't make sense, what would x be if p was False?
00:51:19 <Tendies> if (xs is a certain length) then <do nothing> else <concat crap onto it>
00:51:30 <zd234> let's unravel some of this stack, so DataKind = whenever we write "data Foo ... ", we also duplicate a "kind Foo ... "
00:51:32 <merijn> zd234: And if you're now thinking "type constructors look a lot like value constructors/functions..." you'de be right
00:51:44 <jle`> remember that if-then-elses aren't "doing" anything
00:51:53 <jle`> they are just returning expressions
00:52:06 <jle`> if True then x else y is *literally* just equivalent to x
00:52:08 <Tendies> so "then xs" if i want it unmodified
00:52:12 <jle`> yes
00:52:28 <jle`> what expression do you want your statement to evaluate to if it's True?
00:52:35 <jle`> if you want it to evaluate to xs, then yeah, put xs there
00:52:42 <jle`> > if True then "hello" else "goodbye"
00:52:43 <lambdabot>  "hello"
00:52:52 <merijn> zd234: Incidentally, if you wanna dive deeper into this stuff I can recommend getting a copy of TaPL (Types and Programming Languages)
00:52:55 <jle`> the statement evaluates to a value -- it doesn't "do" anything
00:53:08 <jle`> so it wouldn't really make sense to say "do nothing"
00:53:08 <merijn> jle`: s/statement/expression
00:53:12 <jle`> yeah :)
00:53:40 <jle`> thanks
00:55:13 <zd234> merijn: another dumbass question, if we DataKind duplicates things, why are we using 
00:55:18 <zd234> '[] and ': ?
00:55:49 <merijn> zd234: Because sometimes it's ambiguous whether we mean the data or the kind version
00:56:04 <merijn> zd234: i.e., note that "[Int]" is legal in both interpretations :)
00:56:19 <merijn> Could "[Int] :: *" or "[Int] :: [*]"
00:56:25 <zd234> [1, 2, 3] :: [Int]
00:56:27 <zd234> hmm
00:56:45 <merijn> ' is just an annotation that tells GHC "I meant the kind version"
00:56:50 <merijn> :k []
00:56:51 <lambdabot> * -> *
00:56:53 <zd234> now I'm confused, how does ': vs : help us separate [Int] :: * vs [Int] :: [*] ?
00:56:54 <merijn> :k '[]
00:56:55 <lambdabot> [k]
00:57:12 <Tendies> :k []
00:57:12 <zd234> :t []
00:57:13 <lambdabot> * -> *
00:57:13 <lambdabot> [t]
00:57:18 <merijn> zd234: I'm not 100% it's needed there
00:57:27 <merijn> I just kept it for consistency
00:57:30 <Tendies> why are you typing '[]
00:57:51 <zd234> we're studying https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L13-L15
00:57:58 <zd234> or more like I'm studying https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L13-L15 and merijn is enlightening me
00:58:21 <zd234> :t 
00:58:22 <lambdabot> <no location info>: not an expression: ââ
00:58:23 <zd234> :t '[]
00:58:24 <lambdabot>     Syntax error on '[]
00:58:24 <lambdabot>     Perhaps you intended to use TemplateHaskell
00:58:24 <lambdabot>     In the Template Haskell quotation '[]
00:58:49 <merijn> Note that the following is also legal in haskell (and many people forget)
00:58:50 <jle`> '[] is not a value, it's a type
00:58:56 <merijn> > [1..10] :: [] Int
00:58:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
00:59:18 <merijn> Hence the difference between ":k []" and ":k '[]"
01:00:11 <zd234> wtf, how is "[] Int" legal?
01:00:16 <zd234> it means the same as "[Int]" ?
01:00:21 <zd234> [] a = list of a ?
01:00:21 <merijn> zd234: Yes
01:00:26 <zd234> thus, a * -> * okay
01:00:53 <zd234> this is like taking the redpill
01:00:57 <merijn> :)
01:01:08 <jle`> [a] is syntactic sugar for [] ... that's why we can say instance Functor [] where ...
01:01:14 <jle`> :t fmap
01:01:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:01:25 <jle`> fmap :: (a -> b) -> [] a -> [] b
01:01:32 <jle`> (the f is [])
01:01:48 <jle`> *`[a]` is syntactic sugar for `[] a`
01:02:54 <zd234> so back in this land https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L13-L15 ... the "value of HNil is a Type, a Type with value HList '[]; and HCons is a function of type :: Type -> HList ... -> HList
01:02:58 <zd234> okay, this is sorta making sense now
01:03:30 <jle`> `HList as` is a type
01:03:35 <merijn> zd234: Close, but not quite
01:03:54 <merijn> HNil is a value (not a type) that has type "HList '[]"
01:04:10 <merijn> Well, I guess that technically, with DataKinds HNil could also be a type ;)
01:04:24 <jle`> only 8.0+ ;_;
01:04:25 <lpaste> dnivra pasted âQuickCheck sample programâ at http://lpaste.net/152736
01:05:07 <lpaste> dnivra pasted âQuickCheck errorsâ at http://lpaste.net/152737
01:05:30 <merijn> zd234: Basically it's making GHC track the types of individual elements in the type of the HList
01:05:52 <merijn> zd234: As you can see on e.g. line 50
01:06:14 <jle`> zd234: the types of the constructors are already pretty clear from the GADT syntax, though
01:06:21 <zd234> yeah, this is starting ot make snese
01:06:27 * hackagebot elm-init 1.0.4 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.4 (justus)
01:06:33 <zd234> (was reading CTrex paper earlier, and this HList stuff makes more sense as merijn explains it)
01:06:37 <jle`> Nil :: HList '[], you can read it right off of line 14
01:06:46 <dnivra> Hello everyone! I'm working my way through the testing hapter of haskellbook and trying out a small QuickCheck program from the book(http://lpaste.net/152736). However, I get an error: http://lpaste.net/152737. Could someone help me understand why there's a type mismatch and how I could fix it?
01:06:47 <zd234> so with this, we can actually do a "typed jquery selector" of sorts I feel
01:06:55 <jle`> Cons :: a -> HList as -> HList (a ': as)
01:07:04 <jle`> see, the type is not a mystery
01:07:06 <jle`> it's right there :)
01:07:17 <merijn> zd234: Yes, one paper I can recommend to understand, e.g. the Zip stuff later on is the "Fun with Type Functions" paper
01:07:30 <merijn> zd234: Which explains the "type family" stuff fairly well
01:07:59 <zd234> ha, was just reading that
01:08:04 <merijn> :)
01:08:06 <zd234> about 40 pages of cool stuff
01:08:20 <MasseR> ohh. Oleg paper
01:08:29 <merijn> MasseR: Surprisingly readable Oleg paper :p
01:09:17 <merijn> zd234: Incidentally, as I said before TaPL starts from untyped lambda calculus and explains how this stuff (and more) works and can be implemented (including example type checker implementations)
01:10:26 <zd234> its also 600 some pages :-)
01:10:56 <merijn> Sure, but I'd say you need less than half of the book to be able to implement something equivalent to, say, Haskell98
01:11:27 * hackagebot reflex-dom-contrib 0.4.1 - A playground for experimenting with infrastructure and common code for reflex applications  https://hackage.haskell.org/package/reflex-dom-contrib-0.4.1 (DougBeardsley)
01:11:30 <merijn> It also covers way complex stuff like java/c++ style inheritance and dependant types, etc. :)
01:11:40 <merijn> dependent, even
01:11:49 <Tendies> > concat [3,7]
01:11:50 <lambdabot>      No instance for (Show a0)
01:11:50 <lambdabot>        arising from a use of âshow_M622699612522550696810491â
01:11:50 <lambdabot>      The type variable âa0â is ambiguous
01:11:52 <zd234> dependent types = good, coq style types
01:11:57 <zd234> java/c++ style inheritance = not sure I want to learn about that
01:12:17 <merijn> zd234: It provides a solid/correct theoretical foundation for reasoning about them :)
01:12:21 <merijn> It's just a pain todo :p
01:12:49 <merijn> There's a dependency flowchart in the book on which chapters require which others as prerequisite knowledge :)
01:13:02 <Tendies> > (\[a,b] -> (a,b)) [3,5]
01:13:03 <lambdabot>  (3,5)
01:13:10 <zd234> if someone reworte the book as a series of haskell exercises, I'd pay for it
01:14:22 <merijn> zd234: It should be easy enough to do yourself. The book has exercises and while the example code uses ocaml it should be trivial to understand for even beginner haskellers, since it only uses very basic ocaml
01:15:05 <scop2229> Could someone help me with this. http://pastebin.com/SRqPe78n  when ever i use the function box (option) i always  get property x undefined but i dont use option its  fine
01:15:25 <scop2229> its javascript by the way 
01:16:23 <zd234> scop2229: this is #haskell ....
01:16:55 <Cale> zd234: Yeah, there's only a small amount of code in TaPL and it's all pretty much ignorable. The book is really more like a math book than a book about programming.
01:17:11 <scop2229> hahaha oops  well if anyone can help itsthere
01:18:15 <merijn> I just implemented System F_Ï based on my first read (well, almost, my ADT type checking is broken, but I finally know how to fix it!)
01:20:28 <fr33domlover> In yesod, if I have a route /new and a route /#!Text, is there a way to prevent /new from creating a new object named "new"? Sure I can hard-code a check but what if I change the route to /create and forget to update the check?
01:23:49 <Tendies> what would i want to do with only prelude to divite a list into equal sized sub-lists (input string will be divisible)
01:24:24 <Cale> > iterate (drop 3) [1..21]
01:24:25 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],[4,5,6,7,8,9,10,11,...
01:24:31 <Cale> > iterate (drop 3) [1..9]
01:24:33 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[4,5,6,7,8,9],[7,8,9],[],[],[],[],[],[],[],[],[],[],[],...
01:24:45 <Cale> > takeWhile (not . null) . iterate (drop 3) $ [1..9]
01:24:47 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[4,5,6,7,8,9],[7,8,9]]
01:24:53 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..9]
01:24:55 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
01:25:11 <Tendies> fricken wizardry
01:27:10 <Cale> fr33domlover: Perhaps just define the handler to look for 'new'?
01:28:29 <fr33domlover> Cale, but then I have 'new'in 2 places, what if forget to keep them in sync etc. also in the real case i have much more than 1 such check so it's hard to sync mnually etc.
01:28:46 <fr33domlover> just wondering if there's an automatic way
01:28:51 <Cale> fr33domlover: No, only one place. You only have the one route, which is handled by something which looks for that Text value.
01:29:22 <Cale> Oh, looking more closely at what Yesod does...
01:29:34 <Cale> It seems like only the handler for the first route is run
01:29:41 <Cale> So you don't have to worry about it
01:30:00 <Cale> Just let them overlap, and make sure they're listed with the more specific things first.
01:33:02 <jophish> Cale: thanks, I've (somewhat) sorted things now with HXT's issueError
01:33:50 <jophish> What I don't really like about HXT is that everything's all in this huge type XmlArrow, failure is represented as an arrow returning nothing, so is the empty list or a missing element
01:34:02 <jophish> and it makes distinguishing between these quite tricky
01:36:39 <fr33domlover> Cale, having 2 separate routes allows new to be POST while the other is only GET etcThe problem is that /new has an HTML form which could potentially create an object named /new, which woud then be inaccessible
01:37:35 <fr33domlover> so I have "new" in 2 places: in the routes file, and a string in the postNewR handler function
01:38:32 <fr33domlover> now suppose there is also /delete ...
01:39:31 <fr33domlover> i think yesod's solution is to use HTTP verbs and REST, but not sure exactly
01:40:21 <Cale> Well, it's only going to run the first handler which matches, no?
01:40:44 <Cale> So the /#!Text route doesn't apply to /new if you put it second.
01:41:51 <Cale> Oh, I see what you mean -- you actually *want* the /#!Text route to apply
01:42:04 <Cale> In that case, I think the best thing is just to add a path element
01:42:20 <Cale> Because that'll sidestep the whole problem with overlapping altogether.
01:43:59 <jatani> Hi! Is there such a thing as a 'data constructor constraint' so that I can write functions only for specific constructors? Or do I always have to pattern match (potentially against all constructors)?
01:45:15 <Taneb> jatani: you could do something hacky with GADTs, but I wouldn't recommend it in 95% of use cases
01:46:03 <jatani> Taneb, alright, hacky doesn't sound good. :) I take it that it is an okay (read: idiomatic) approach then to simply pattern match?
01:46:25 <Taneb> Yeah! Why do you only want to operate on one constructor?
01:47:23 <jatani> Taneb, I kind of light the idea of having specific 'sub-functions' for specific constructors, i.e. smaller building blocks. But it probably isn't justified.
01:47:45 <jatani> *liked, whops
01:48:39 <Taneb> jatani: you could change something like data Shape = Square SideLength | Circle Radius to data Shape = Square' Square | Circle' Circle; data Square = Square SideLength; data Circle = Circle Radius
01:49:21 <Taneb> That is, split your data type up
01:50:39 <jatani> Taneb, ah, that looks kinda neat. I think I like that, thank you!
01:50:45 <Taneb> :)
01:55:42 <Tendies> i got this to take every 7th element; each n = map head . takeWhile (not . null) . iterate (drop n); I'm not sure how to make it then return a list of every element whos index = (pos `mod` 7)+1
01:56:47 <Tendies> or like, [[ elements where pos % 7 = 0],[elements where pos % 7 = 1] ... ]
01:57:45 <liste> :t zip [1..] -- Tendies
01:57:46 <lambdabot> (Enum a, Num a) => [b] -> [(a, b)]
01:57:58 <liste> > zip [1..]Â [6513,635,12,5,613,53,13613]
01:57:59 <lambdabot>  [(1,6513),(2,635),(3,12),(4,5),(5,613),(6,53),(7,13613)]
01:59:25 <Tendies> given [1,2,3,4,5,6,7,8,9] say i want every 3rd, [[1,4,7],[2,5,8],[3,6,9]]
02:00:21 <Tendies> so the first sublist were position % 3 == 0, then second sublist are position % 3 == 1
02:00:39 <liste> Tendies: zip, filter and fst
02:00:46 <liste> is one possible solution
02:02:01 <liste> or a list comprehension with zip'
02:02:07 <liste> zip *
02:06:29 * hackagebot second-transfer 0.10.0.2 - Second Transfer HTTP/2 web server  https://hackage.haskell.org/package/second-transfer-0.10.0.2 (dsign)
02:08:15 <jophish> Where do people generally advertise Haskell job openings aside from /r/Haskell?
02:08:48 <merijn> jophish: Here, the haskell-cafe mailing list, twitter
02:08:58 <merijn> jophish: http://www.haskellers.com/
02:10:24 <jophish> merijn: thanks! haskellers.com looks pretty good
02:23:12 <Tendies> ok liste i got it to get them based on the pattern, now im trying to make a list where each sublist is generated by one of [0..m-1] where m was the modulo number
02:24:30 <Tendies> yey :D
02:25:43 <liste> \o/
02:40:35 <Tendies> omg you compiler you
02:42:38 <Tendies> "Cant match expected type `a -> [t1]' with actual type `[char]'" then i force it to [Char] and it cant match expected [Char] with a -> [t1]
02:42:55 <Tendies> 1s
02:44:10 <Tendies> http://lpaste.net/152740
02:44:42 <Tendies> im getting that error from line 16 and 18
02:46:12 <zd234> https://gist.github.com/a8eb6a217d7f4bfd9ca6 <-- how do I make this compile
02:46:16 <zd234> trying to learn how to use type families
02:48:13 <liste> Tendies: you seem to be missing a $ in line 2
02:48:40 <Tendies> or i have a . instead of $?
02:48:48 <liste> alternatively
02:48:58 <liste> you could also eta reduce
02:50:08 <Tendies> that got two of them
02:51:07 <Tendies> you said i can leave the . if i Eta reduce, right?
02:53:56 <liste> yes, use . with eta reduce
02:54:27 <Tendies> realized i need to replace tail with last, didnt change errors however
03:00:19 <ocharles_> Any GHC 8 users know why the following doesn't work with -XTypeInType? data ColumnDefinition :: dbType -> (colType :: dbType) -> Type where  -- 'Expected a type but colType has kind dbType'
03:00:41 <ocharles_> If I remove the kind annotations, I can later do:   ColumnDefinition :: String -> ColumnDefinition dbType (colType :: dbType)  with -XGADTs
03:00:51 <ocharles_> Just seems I can't specify that exactly in the type of the data type itself
03:20:32 <gracefu> hm, i know it's not really related to haskell but i don't know where i could ask about algorithms anyway
03:20:32 <gracefu> I need something like sweep and prune, except i only need to detect a collision between one AABB and every other AABB
03:20:32 <gracefu> the other AABBs can overlap, etc. since we're incrementally adding objects and this is for broadphase collision
03:20:32 <gracefu> from what i saw, sweep and prune is for detecting all pairs of collisions...
04:12:04 * hackagebot rank1dynamic 0.3.2.0 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  https://hackage.haskell.org/package/rank1dynamic-0.3.2.0 (FacundoDominguez)
04:12:06 * hackagebot distributed-static 0.3.4.0 - Compositional, type-safe, polymorphic static values and closures  https://hackage.haskell.org/package/distributed-static-0.3.4.0 (FacundoDominguez)
04:27:04 * hackagebot json-pointer 0.1.1 - JSON Pointer parsing and interpretation utilities  https://hackage.haskell.org/package/json-pointer-0.1.1 (NikitaVolkov)
05:00:23 <jophish> hmmm, someone's squatting on this package name https://hackage.haskell.org/package/Vulkan
05:00:40 <jophish> I want to release my vulkan bindings
05:01:08 <jophish> I suppose I could use another name, but nothing says "vulkan" quite like "vulkan"
05:02:07 <lonokhov> HsVulkan is always an option
05:02:19 <cocreature> jophish: vulkan is still available, package names are case sensitive :)
05:02:26 <mniip> >module Graphics.Vulkan where
05:02:27 <mniip> >EOF
05:02:30 <mniip> great package
05:02:39 <mniip> would compile again
05:02:49 <jophish> cocreature: hmm, that feels pretty gross
05:02:54 <cocreature> mniip: finally a package where nobody complains about the compile times
05:03:19 <cocreature> jophish: squatting package names is gross, you could also ask some of the hackage admins to kill that package
05:04:23 <mettekou> Is anyone familiar with dealing with variable binding when implementing programming languages in Haskell? I am currently using unbound (from the paper Binders Unbound), but it does not work for a term type which takes type parameters. Can anyone recommend an alternative? The only other library I immediately find on Hackage is bound.
05:06:28 <fizruk> mettekou: have you seen this? https://hackage.haskell.org/package/bound
05:06:30 <cocreature> mettekou: Iâve used bound in the past and was quite happy with it, but I donât remember if it solves your problem
05:06:57 <jophish> mettekou: I've used bound too, it was really nice
05:07:47 <mettekou> fizruk cocreature jophish: It seems to be nice, I'll check out Edward Kmett's presentation on it and take it for a spin. Thanks!
05:08:05 <jophish> mettekou: good luck
05:17:00 <Maplicant> Does anyone know how I could create a function that returns the represented binary of a character? For example f 'a' = "01100001"
05:18:12 <fr33domlover> Maplicant, start with Data.Char.ord
05:18:51 <pippijn> hi, what is the best way to start a process, write something to its stdin and then read its stdout?
05:19:10 <Maplicant> That converts it to decimal, and if you convert that to binary you wouldn't get the correct response
05:19:42 <pippijn> I want a program that starts "cat", writes "hello" to it, and reads back the output, and checks that the output was "hello"
05:20:00 <fr33domlover> Maplicant, convert the decimal to binary then, find or write showBin :: Int -> String etc.
05:20:16 <liste> Maplicant: why not?
05:20:16 <fr33domlover> pippijn, see 'process' package
05:20:43 <fr33domlover> pippijn, iirc also 'unix' if you aren't targetting losedows
05:21:06 <pippijn> fr33domlover: I tried something with createProcess, but "cat" never exits
05:21:15 <liste> Maplicant: you mean the leading spaces, as in "1100001" vs "01100001"
05:21:16 <Maplicant> fr33domlover, liste: Oh wait, thanks for your help!
05:21:40 <pippijn> on the command line, I do: "cat", then type "hello", press Return, then ^D, and cat terminates
05:21:51 <pippijn> how do you send EOF to the process?
05:22:03 <liste> > "\EOF"
05:22:04 <lambdabot>  <hint>:1:3:
05:22:04 <lambdabot>      lexical error in string/character literal at character 'E'
05:22:12 <liste> > "\EOT"
05:22:13 <lambdabot>  "\EOT"
05:22:20 <liste> that's ^D
05:22:24 <pippijn> hmm
05:22:32 <liste> not sure how it works outside a tty though
05:22:44 <pippijn> I don't think that works
05:22:52 <cocreature> you might just want to close the handle
05:23:32 <liste> -- dare I do > text "\EOT" :D
05:23:56 <pavonia> Maplicant: Have a look at the Numeric module from base, it has showIntAtBase
05:24:56 <pippijn> I closed all handles except the stdout "read" end after writing to stdin "write" end
05:30:29 <merijn> liste: You don't "write" EOF, you simply close the pipe
05:31:54 <kjh> hey
05:32:21 <kjh> with servant, how do I capture two values separated by somethig other than a /
05:32:50 <kjh> for example http://foosite/bar/2..5
05:34:58 <zyxoas> Peepmeisters!
05:35:40 <zyxoas> Does anyone know how I can get formatTime to display milliseconds nicely? That is, 15:35:26.342?
05:36:22 <zyxoas> So I want: milliseconds, three decimal places, padding to the left with zeros, rounded off (although this is not necessary). Is this doable?
05:42:47 <merijn> Gah
05:43:12 <merijn> I'm trying to show/trace some value in typeclass function, but I can't prove a show constraint on it there :\
05:43:29 <merijn> Don't we have like a conditional trace? :(
05:50:58 <merijn> edwardk: Ping?
05:55:03 <KaneTW> merijn: unless you know at compile-time that it has a SHow constraint, no
05:55:53 <merijn> I know it has that constraint at the place where I call it, but I don't inside the Eq instance I'm trying to look into
05:59:07 <Philonous> merijn, You could reify the Show dict, put it into a global variable and retrieve it inside the eq instance 
05:59:51 <merijn> By now I've already found the bug, but it's annoying nonetheless
06:24:16 <bennofs> merijn: do you only want it for one special type, or all types that have show instances? 
06:25:35 <bennofs> merijn: because if it's only for one type, perhaps a class like  'class MyTmpShow a where myShow :: a -> Maybe String; instance MyTmpShow SpecialType where myShow = Just . show; instance MyTmpShow a where myShow = Nothing' with OverlappingInstances should (?) be possible to prove anywhere?
06:25:38 <merijn> bennofs: I only wanted it for one. Basically I had a functor type and wanted to see what was going on in it's Eq instance, showing the contents of it obviously only works if the contents are Show, but that's not a prerequisite for the Eq instance
06:27:26 <bennofs> merijn: perhaps you could also make a more general version of this, like a class TypeEq SomeType a, that gives you Maybe a proof that a ~ SomeType which you can then use to do something special for SomeType
06:29:11 <bennofs> merijn: oh, that already equality http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Type-Equality.html#t:TestEquality
06:29:18 <bennofs> exists*
06:29:51 <merijn> huh
06:29:59 <merijn> That doesn't seem remotely related to what I wanted?
06:30:33 <Guest61615> @pl \x y -> x . f . y
06:30:33 <lambdabot> (. (f .)) . (.)
06:30:54 <Guest61615> @pl \f m1 m2 -> flip (>>=) (\a1 -> flip (>>=) (\a2 -> (return . Free) (f a1 a2)) m2) m1
06:30:54 <lambdabot> flip . ((=<<) .) . flip . (((=<<) . ((return . Free) .)) .)
06:31:05 <merijn> I have "data Foo a = ??" and something funky and unexpected is happening with the implementation of "Eq a => Eq (Foo a)", so inside the definition of "Eq (Foo a)" I wanted to trace stuff
06:31:46 <merijn> But, since I don't have a Show constraint on 'a' I can't do that, even though I know that where I *use* the Eq instance of "Foo a" 'a' is Showable
06:32:08 * hackagebot scotty-params-parser 0.3 - HTTP-request's query parameters parser abstraction for "scotty"  https://hackage.haskell.org/package/scotty-params-parser-0.3 (NikitaVolkov)
06:32:14 <bennofs> merijn: well, I thought that you know what the type of 'a' is in the case that you want to trace 'a'?
06:32:43 <merijn> Yes, but the trace call should be in the Eq instance, where I *don't* know what 'a' is
06:33:35 <bennofs> merijn: so, you would use `case testEquality (Proxy :: Proxy a) (Proxy :: Proxy TypeYouWantToTrace) of Just Refl -> traceShow aValue  ; _ -> id`
06:34:23 <bennofs> merijn: that traceShow will work, because the compiler knows at that point that a ~ TypeYouWantToTrace, so it can resolve Show a even without adding it as an instance constraint
06:37:48 <phadej> bennofs: won't change requirement of Show to requirement of something else?
06:39:52 <phadej>     No instance for (TestEquality Proxy)
06:40:41 <bennofs> oops, i might have misunderstood how testEquality worksa
06:41:53 <phadej> bennofs: it works for example for testEquality (SNat 1) (sing :: SNat n) ...
06:42:09 * hackagebot scotty-params-parser 0.4 - HTTP-request's query parameters parser abstraction for "scotty"  https://hackage.haskell.org/package/scotty-params-parser-0.4 (NikitaVolkov)
06:42:17 <phadej> but not really for open kind '*'
06:44:59 <bennofs> phadej, merijn: ok, let me write an example that actually compiles ;p
06:44:59 <phadej> bennofs: http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:eqT I guess is most general you can get
06:45:12 <phadej> which will trade Show for Typeable
06:48:45 <bennofs> phadej: you can trade Show for a constraint which is always satisfiable
06:49:33 <phadej> bennofs: like what?
06:53:23 <meditans> hi, I have a question on overlapping instances: let's say I have both a `instance Foo a => Foo (Maybe a)` and a `instance Foo (Maybe Bar)`
06:54:18 <meditans> but I don't have an `instance Foo Bar`, so there is only one sensible choice for the `Maybe Bar` instance
06:55:12 <meditans> is there a way to convince the compiler not to produce an OverlappingInstances error?
06:56:25 <meditans> (I know I can use OverlappingInstances as a pragma, but is there another way?)
06:57:05 <bergmark_> meditans: from GHC 7.10 you can mark individual instances as {-# OVERLAPPING #-}
06:57:27 <bergmark_> or you can mark the overlapped instance with {-# OVERLAPPABLE #-}
06:57:30 * hackagebot ghc-session 0.1.2.1 - Simplified GHC API  https://hackage.haskell.org/package/ghc-session-0.1.2.1 (PiotrMlodawski)
06:57:32 * hackagebot grid 7.8.5 - Tools for working with regular grids (graphs, lattices).  https://hackage.haskell.org/package/grid-7.8.5 (AmyDeBuitleir)
06:58:14 <lpaste> bennofs pasted âConditional traceShow â at http://lpaste.net/152742
06:58:24 <meditans> bergmark: is there any difference between the two way of doing things (overlapping/overlappable)?
06:58:27 <bennofs> phadej: ^^^
06:59:01 <bennofs> meditans: you can also use closed type families if you want to avoid overlapping instances. Although they only exists since GHC 7.8 (afaik) as well
06:59:05 <bergmark> meditans: the only difference is that if you have several overlapping instances the former needs you to annotate each instance, while the latter only needs one pragma
06:59:18 <solder66> hello
07:00:08 <mnoonan> bennofs: whoa, neat :)
07:00:36 <meditans> bennofs: thanks, I'm on 7.10 so that's not a problem; in this case, as I'm reviewing code written by others, I'll stick to the overlapping pragmas, but that's nice to know!
07:00:54 <meditans> bergmark: ok, thank you, that's what I needed
07:01:07 <ggVGc> I still don't fully understand what overlapping instances are
07:01:53 <bennofs> ggVGc: for example, if you have class C a where ..., then  instance C Int and instance C x are overlapping, because the instance C x could also be used for Int
07:02:10 <ggVGc> ah yeah, okay
07:02:11 <ggVGc> thanks
07:03:25 <bennofs> ggVGc: basically, anytime that instance selection is not fully unambiguous, the instances are overlapping. The way that the extension OverlappingInstances works is that it choses the "most specific" one in that case (so for example, choosing C Int for Int because it's more specific than the general C x instance)
07:05:24 <phadej> bennofs: 
07:05:53 <phadej> yeah, so you kind of carry the type "identity" thru everything :)
07:06:22 <phadej> and it works, as eventually you'll have a concrete type
07:06:30 <bennofs> right
07:06:40 <mnoonan> bennofs: are there consequences to breaking type-level parametricity that way?
07:07:02 <phadej> mnoonan: you aren't "breaking" it
07:07:12 <bennofs> mnoonan: idk. I do have to add an additional constraint, so I'm not really breaking that
07:07:21 <phadej> you say it in the type that you carry that extra bit of information
07:08:06 <phadej> so you see from the type "it works uniformly for a, but does something tricky with Int"
07:08:13 <mnoonan> hmm
07:08:38 <mnoonan> wait, I'm talking about the overlapping instances, not the traceShow trick
07:09:08 <phadej> but however, it doesn't help the original problem (adding traceShow without adding any constraints to instance contexts)
07:10:44 <mnoonan> overlapping instances feels like defining both "foo :: a -> a" and a specialization "foo :: Int -> Int"
07:11:05 <bennofs> mnoonan: it's basically the same argument for overlapping instances though. If you want to use any methods of the class C, you still have to write C a => ..., which says "this function can do something different based on the type of a" in general
07:12:01 <mnoonan> but presumably there are free theorems associated with an instance declaration like "instance Foo a => Bar a", yeah?
07:14:28 <bennofs> mnoonan: why would there? each instance of Foo can do something completely different for each possible type a
07:14:43 <phadej> mnoonan: not more then with functions 'quux :: Foo a -> Bar a'
07:18:24 <ocharles_> kosmikus: Does generics-sop have anything that will let me turn `NP I [f a, f b]` into `NP f [a, b]`? I see most things keep xs fixed, so I'm somewhat expecting to have to roll that myself
07:19:21 <ocharles_> cc edsko 
07:21:16 <phadej> ocharles_: IIRC there aren't `Map` as the domain type would need to be `NP I (Map f xs)`
07:21:48 <lpaste> bennofs pasted âWhy does GHC accept this without OverlappingInstances?â at http://lpaste.net/152743
07:22:16 <bennofs> anyone got an idea about the above paste? ^^^
07:22:30 * hackagebot aeson-value-parser 0.11.2 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.11.2 (NikitaVolkov)
07:24:15 <bennofs> seems GHC is happy to resolve (eqProofClass :: TypeEq a Int => Maybe (a :~: Int)) using the TypeEq a b instance, without even asking for a constraint on the instance or requiring OverlappingInstances
07:27:15 <kosmikus> ocharles_: I don't think there is. How do you end up with a "NP I [f a, f b]" in the first place?
07:27:33 <ocharles_> kosmikus: by having data Foo f = Foo (f Int) (f String), for example
07:27:45 <kosmikus> I see.
07:27:48 <ocharles_> I need to change f to g
07:27:53 <ocharles_> but no problem, I can write this myself
07:27:58 <ocharles_> just wanted to make sure I wasn't overlooking anything
07:28:19 <kosmikus> I'm not opposed to adding some of these.
07:28:36 <ocharles_> ok, I'll see if I can come up with something suitably reusable
07:28:40 <phadej> I'm pretty sure you can easily run into need of injective type families with those
07:28:47 <ocharles_> no problem, I'm on GHC 8 :)
07:28:57 <ocharles_> That was my feeling, too
07:28:59 <phadej> (i.e. Map over type list)
07:29:03 <E4xoi> bennofs: woah. what?!
07:30:05 <E4xoi> bennofs: it doesn't seem to work, either
07:30:23 <kosmikus> phadej: why?
07:30:32 <E4xoi> bennofs: might it be that the "a" there is a "new" one?
07:31:13 <bennofs> E4xoi: it does throw an 'please enable OverlappingInstances' error if I add TypeEq a Int to the context of that instance
07:31:47 <kosmikus> phadej: ok, for using it conveniently, perhaps. OTOH, if the result is NP f xs, the f can be inferred.
07:33:58 <E4xoi> bennofs: try writing an eq_foo function (and forall, thus using scopedtypevariables) and it'll also give an error
07:35:05 <bennofs> E4xoi: a1 == (undefined :: a) does typecheck though, so it can't really be a "new" a
07:35:07 <phadej> kosmikus: let me try
07:35:09 <E4xoi> bennofs: wait, it's asking for IncoherentInstances 
07:35:41 <E4xoi> bennofs: er, where are you using undefined like that?
07:35:48 <bennofs> E4xoi: i just tested it
07:36:01 <bennofs> E4xoi: replacing the second branch with     Nothing -> a1 == (undefined :: a)
07:36:32 <bennofs> E4xoi: or making it even more obvious: replace the first branch with     Just Refl -> traceShow (a1 :: Int,a2) (a1 == a2)
07:36:43 <bennofs> E4xoi: so it really does have evidence that a ~ Int at that point
07:36:48 <phadej> kosmikus: there is sequence_NP  :: (SListI xs,  Applicative f) => NP  f xs  -> f (NP  I xs)
07:36:49 <bennofs> E4xoi: so this cannot be a new a
07:36:54 <phadej> but no other way around
07:37:23 <E4xoi> bennofs: hm, you're right 
07:37:28 <phadej> that's a bit wront though
07:37:31 * hackagebot diagrams 1.3.0.1 - Embedded domain-specific language for declarative vector graphics  https://hackage.haskell.org/package/diagrams-1.3.0.1 (jeffreyrosenbluth)
07:42:16 <phadej> kosmikus:     Could not deduce (xs ~ '[]) from the context (Map f xs ~ '[])
07:42:28 <phadej> kosmikus: that's why you need injectivity
07:48:12 <phadej> kosmikus: wait, you can teach GHC by using SListI
07:52:31 * hackagebot distributed-process 0.6.0 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.6.0 (FacundoDominguez)
07:52:33 * hackagebot distributed-process-tests 0.4.4 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.4 (FacundoDominguez)
07:53:17 <kmelva> does putting TVars inside State monad make sense? trying to refactor something, and that seemed like it may work... 
07:53:26 <kmelva> I'm just wondering if i'm trying to do something silly :)
07:56:06 <bennofs> 2
07:57:55 * hackagebot distributed-process-async 0.2.3 - Cloud Haskell Async API  https://hackage.haskell.org/package/distributed-process-async-0.2.3 (FacundoDominguez)
07:57:57 * hackagebot distributed-process-extras 0.2.1.2 - Cloud Haskell Extras  https://hackage.haskell.org/package/distributed-process-extras-0.2.1.2 (FacundoDominguez)
07:57:59 * hackagebot distributed-process-simplelocalnet 0.2.3.2 - Simple zero-configuration backend for Cloud Haskell  https://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.2 (FacundoDominguez)
07:58:49 <phadej> kosmikus, ocharles_ https://gist.github.com/phadej/4778ace5fd574367182a
07:59:36 <ocharles_> phadej: thanks, that's basically what I have written :)
07:59:49 <phadej> but adding those is a slippery slope
08:00:09 <phadej> foo :: NP (f :.: g) xs -> NP f (Map g xs)
08:00:40 <ocharles_> though I hadn't done NS, so good work there
08:01:05 <ocharles_> yours doesn't seem to type check under my GHC 8 though
08:01:16 <phadej> ocharles_: there are still SOP and POP ;)
08:02:18 <c_wraith> kmelva, it does seem a bit odd. but not necessarily wrong. but it only makes sense if you have a good reason to change the TVar being passed around between different places. 
08:02:55 * hackagebot distributed-process-client-server 0.1.3.2 - The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-client-server-0.1.3.2 (FacundoDominguez)
08:03:15 <frontendloader> phadej: is :.: a real operator
08:04:07 <kmelva> c_wraith: Now that I'm thinking about it - the TVar is the same, but I modify it with modifyTVar... so then I should use Reader monad?
08:04:16 <bergmark> kmelva: right
08:04:23 <c_wraith> kmelva, that's much more common
08:04:39 <combinator> @pl \f -> liftF . f
08:04:39 <lambdabot> (liftF .)
08:04:43 <kmelva> Thanks guys!
08:07:41 <phadej> frontendloader: it's a Compose from generics-sop
08:09:46 <phadej> ocharles_: how your version looks
08:10:21 <phadej> ocharles_: I'm not sure whether I trigger a bug in GHC 8.0 or made some stupid mistake
08:10:43 <ocharles_> phadej: I ended up getting yours (well, just fromNPI) to work with this variation: http://lpaste.net/152748
08:12:18 <phadej> ocharles_: ah, it was my mistake. Had to add type annotation to fromNPI' but made a mistake there
08:12:24 <ocharles_> ah
08:12:31 <phadej> which triggered a not so nice behaviour in GHC
08:12:52 <phadej> as it checked kinds before types, the error was far from helpful :(
08:14:07 <phadej> i.e. Expected kind â[*]â, but âxsâ has kind â[k]â
08:14:17 <phadej> and you wonder why...
08:17:17 <phadej> ocharles_: yet, if you have to change NP f xs to NP g xs, can't you do that directly?
08:17:46 <ocharles_> phadej: I don't want to change NP f xs to NP g xs, I want to change NP I [f a, f b]  to NP I [g a, g b]
08:17:46 <phadej> ocharles_: there is hmap
08:17:59 <phadej> ocharles_: ah true. sorry.
08:18:01 <ocharles_> :)
08:18:06 <ocharles_> np!
08:18:56 <phadej> i wonder if using 'unsafeCoerce' for toNPI/fromNPI would be cheating...
08:18:57 <mnoonan> bennofs, phadej: I think I can clarify my thought about overlapping instances and parametricity a bit better
08:19:36 <mnoonan> say you have "class Organize a where organize :: [a] -> [a]", and "instance Ord a => Organize a where organize = foo"
08:20:07 <mnoonan> foo has to be polymorphic of type (a -> a -> Bool) -> [a] -> [a], so it satisfies the free theorem
08:20:34 <phadej> mnoonan: you cannot have any other instance of Organise
08:20:36 <mnoonan> so from that instance, I can conclude that if f is order-preserving, organize . f = f . organize
08:21:07 <mnoonan> phadej: why not? can't I overlap an instance of Organize Int that just has organize = const []?
08:21:50 <phadej> mnoonan: it won't be only overlapping, it will be incoherent
08:22:08 <phadej> mnoonan: and incoherency is "throw all reasoning power into /dev/null"
08:22:42 <mnoonan> I've never understood incoherent instances, so perhaps that is my problem :)
08:23:23 <phadej> mnoonan: say you have class C a where ...
08:23:55 <phadej> mnoonan: you can write two instance, instance Odd a => C a where ... and instance Even a => C a  where
08:24:01 <bennofs> phadej: why not? of course you can have instance Organize Int where organize _ = const [] with only OverlappingInstances
08:24:02 <phadej> they are obviously overlapping
08:24:34 <phadej> but if you want to write a function "c :: C a => ..." you'd need to enable IncoherentInstances
08:25:10 <phadej> mnoonan: and it's now your job to verify that if there is a satisfying both Even a and Odd a, that the results of functions in C a agree
08:25:11 <bennofs> phadej: they aren't even incoherent. they are duplicate
08:25:26 <bennofs> phadej: instance resolution will *never* look at instance contexts
08:25:35 <bennofs> (before committing to a choice)
08:27:28 <phadej> bennof, mnoonan a second.
08:28:33 <Athas> Is there a package containing standard deviation calculation functions on Stackage?
08:30:01 <bergmark> Athas: `statistics'?
08:30:07 <mnoonan> phadej: so with overlapping instances, is it correct to say that there will always be just one way to select an instance definition?
08:30:34 <Athas> bergmark: hm, yes, it looks a little more heavyweight than what I was looking for, but I suppose I will survive.
08:30:36 <mnoonan> and if I had defined Even Foo in a library, and a user comes along and defines Odd Foo, it'll become an incoherent instance?
08:32:30 <bergmark> mnoonan: you need to mark an instance as incoherent to be able to use it with other incoherent instances
08:35:11 <bennofs> mnoonan, phadej: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-overlap see the description under "The search works like this."
08:35:48 <phadej> bennofs: yes, I have read one. It's not that easy to digest :(
08:36:24 <bennofs> I guess IncoherentInstances is evil anyway, so I don't really have to know how it works :p 
08:36:30 <phadej> mnoonan: maybe better example is class Foo, and instance Foo (Either Int a) and Foo (Either b Int)
08:36:52 <phadej> as long as you don't want Foo (Either Int Int) or write function with (Either a a ) => then you are ok
08:36:57 <bennofs> (seriously, if you need IncoherentInstances in real code, rethink what you're doing)
08:36:58 <phadej> otherwise compiler cannot pick unique instance
08:37:34 <phadej> bennofs: i.e. don't write instance Foo String and instance Foo a => Foo [a] ;)
08:37:45 <bennofs> phadej: that doesn't need IncoherentInstances, does it?
08:37:57 * hackagebot feed-collect 0.2.0.2 - Watch RSS/Atom feeds (and do with them whatever you like).  https://hackage.haskell.org/package/feed-collect-0.2.0.2 (akrasner)
08:38:03 <bennofs> phadej: only overlapping
08:38:49 <phadej> bennofs: if somewhere is user with 'Foo a => ...' but uses it for [a]
08:41:28 <bergmark> bennofs: https://github.com/bos/aeson/issues/351
08:42:45 <lisbeth> let sort' x:xs y:ys = if y < x then y:(sort' (x:xs) ys) else x:(sort' (x:xs) ys)
08:43:19 <phadej> lisbeth: merge?
08:43:33 * hackagebot distributed-process-registry 0.1.0.2 - Cloud Haskell Extended Process Registry  https://hackage.haskell.org/package/distributed-process-registry-0.1.0.2 (FacundoDominguez)
08:43:35 * hackagebot distributed-process-supervisor 0.1.3.2 - Supervisors for The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-supervisor-0.1.3.2 (FacundoDominguez)
08:43:37 * hackagebot distributed-process-execution 0.1.2.2 - Execution Framework for The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-execution-0.1.2.2 (FacundoDominguez)
08:43:39 * hackagebot distributed-process-task 0.1.2.2 - Task Framework for The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-task-0.1.2.2 (FacundoDominguez)
08:44:22 <bennofs> bergmark, phadej: oh, I guess you're right
08:45:18 <lisbeth> what module is merge in?
08:47:19 <phadej> lisbeth: http://haddock.stackage.org/lts-5.3/extra-1.4.3/Data-List-Extra.html#v:merge
08:47:43 <{AS}> Is it possible to define a generic monadtransformer run function?
08:48:10 <{AS}> Instead of runEitherT, runOptionT, etc.
08:48:25 <phadej> {AS}: how'd you generalise over their types? :)
08:48:36 <{AS}> I was thinking something like
08:48:46 <{AS}> t m a -> m (t Identity a)
08:49:10 <ski> lisbeth : fwiw, you're missing brackets, and also you have redundant brackets
08:49:23 <glguy> {AS}: Yeah. It ends up looking like this: http://hackage.haskell.org/package/monadLib-3.7.3/docs/MonadLib.html#t:RunM
08:49:36 <{AS}> Thanks
08:50:17 <lisbeth> phadej: how to I attain merge?
08:51:40 <hyperpixel56> aye
08:51:42 <{AS}> glguy: Do you know if there is one the other way around?
08:51:54 <hyperpixel56> who here plays csgo?
08:52:11 <phadej> {AS}: lift?
08:52:15 <glguy> hyperpixel56: This channel is for discussing the Haskell programming language.
08:52:23 <hyperpixel56> ooohhhhh
08:53:07 <phadej> {AS}: or you mean m (Either e a) -> ExceptT e m a like?
08:53:14 <{AS}> Yeah
08:53:20 <{AS}> exactly
08:54:06 <{AS}> I basically want to make a function (m a -> m (f b)) -> t m a -> t m b
08:54:22 <{AS}> given a function wrap : m (f a) -> t m a
08:54:33 <{AS}> and a function unwrap : t m a -> m (f a)
08:54:43 <{AS}> or generalized run for the latter :)
08:55:01 <{AS}> err (m (f a) -> m (f b))
08:55:15 <amf> is there an idiomatic way to check if a list of Maybe a's are all Justs? Data.List.all isJust [ thing1, thing2, ] didnt work
08:55:28 <glguy> > sequence [Just True, Just False]
08:55:30 <lambdabot>  Just [True,False]
08:56:06 <glguy> > sequence [Just True, Nothing]
08:56:07 <lambdabot>  Nothing
08:56:24 <amf> and if the items in the list arent all the same type?
08:56:36 <phadej> {AS}: so f and t are related, i.e. Either and ExceptT ?
08:56:43 <{AS}> Yes, exactly
08:56:44 <glguy> Then you'll get a type error because lists doesn't work like that
08:57:17 <amf> glguy: i know, but i thought ghc wouldnt care if i never inspect the contents only the Maybe part
08:57:29 <ahihi> > all iJust [Just 1, Just 2] -- works fine as well
08:57:30 <lambdabot>      Not in scope: âiJustâ
08:57:31 <lambdabot>      Perhaps you meant one of these:
08:57:31 <lambdabot>        data constructor âJustâ (imported from Data.Maybe),
08:57:36 <ahihi> > all isJust [Just 1, Just 2]
08:57:37 <lambdabot>  True
08:57:39 <glguy> amf: Nope, the whole program has to be type correct
08:57:47 <bennofs> amf: you can't even create that list in the first place
08:58:01 <{AS}> basically it would be wrap . f . unwrap
08:58:14 <bennofs> amf: the problem is not with checking if everything in that list is Just, it is with creating the list (to create a list, all elements of the list must have the same type)
08:58:17 <{AS}> but it would be nice to generalize it to have it work for 2, 3, n arguments :)
08:58:22 <{AS}> like liftA*
08:58:25 <{AS}> phadej: ^
08:58:26 <phadej> {AS}: over _Wrapped f action
08:58:33 <amf> ultimately i'm trying to avoid something like: if isJust thingy1 && isJust thingy2 ... (i have quite a few)
08:58:40 <{AS}> phadej: Ah thanks
08:58:43 <sbrg> amf: pattern matching
08:59:02 <{AS}> phadej: does that work?
08:59:29 <{AS}> > over EitherT (EitherT (Right 2)) (+ 2)
08:59:31 <lambdabot>      Not in scope: data constructor âEitherTâ
08:59:31 <lambdabot>      Perhaps you meant variable âeitherâ (imported from Data.Either)    Not i...
08:59:31 <lambdabot>      Perhaps you meant variable âeitherâ (imported from Data.Either)
09:01:01 <bergmark> > sequence [Just 1, Just 2] -- amf
09:01:03 <lambdabot>  Just [1,2]
09:03:43 <amf> bergmark: right... was hoping for the easy way out. thanks all for the help
09:06:22 <ahihi> amf: do you intend to use the values inside the Justs?
09:11:43 <amf> ahihi: eventually, i settled with: allJusts :: [Maybe a]; if allJusts [ Just 1, Just 2 ] && allJusts [ Just "", Just "blah" ] 
09:12:42 <quchen> :t all (/= Nothing) -- amf :-)
09:12:43 <lambdabot> (Eq a, Foldable t) => t (Maybe a) -> Bool
09:14:24 <glguy> quchen: Using isJust instead of (/= Nothing) avoids the Eq a constraint
09:14:27 <hvr> quchen: if you used isJust you'd avoid that 
09:14:37 <hvr> heh... same thought
09:15:00 <dave23> is there a way to reconfigure and rebuild a specific package in stack
09:15:11 <quchen> Hm, right.
09:15:20 <quchen> dave23: Why do you want to do that?
09:15:24 <dave23> i have a project where one of the dependencies is configured wrong
09:15:52 <quchen> Oh. I was hoping that only the Haddocks were missing, because that would have been much easier to fix. :-)
09:15:54 <ahihi> amf: as long as you're not using fromJust afterwards, that should be fine :P
09:16:02 <dave23> ie: extra-include-dirs was wrong. and now I can't link it.
09:16:08 <ahihi> (if you are, you should go with pattern matching instead)
09:18:31 <dave23> can I safely delete the .stack-work/install/arch-os/lts-x.x directory?
09:22:19 <luigy> dave23 yeah I believe that is part of what `stack clean` does for you
09:23:01 <dave23> luigy: i don't think it does, stack clean does not cause a rebuild of deps
09:23:19 <dave23> I just went and completely removed stack
09:23:31 <luigy> is it a snapshot dep?
09:23:46 <dave23> I think so
09:23:57 <phadej> {AS}: http://lpaste.net/4562894391080910848
09:24:18 <luigy> there is no blessed way to do that, but you could of `stack exec -- ghc-pkg unregister --force package-name`
09:24:24 <{AS}> phadej: Thanks
09:24:31 <{AS}> from where is wrapped?
09:24:36 <phadej> {AS}: lens
09:24:44 <{AS}> great
09:25:26 <dave23> luigy: its fine, I just removed everything. Just have to wait for it to rebuild
09:25:40 <{AS}> Is Unwrapped and Wrapped automatically implemented for MaybeT?
09:26:34 <phadej> {AS}: yes
09:26:35 <phadej> http://hackage.haskell.org/package/lens-4.13.2/docs/Control-Lens-Wrapped.html#t:Wrapped
09:26:35 <{AS}> I see it is
09:26:40 <{AS}> Thanks :)
09:27:29 <{AS}> although the types became complex quickly
09:41:15 <phadej> {AS}: you are the one, who wanted general version :)
09:42:30 <{AS}> phadej: Could one have (Unwrapped (f a) -> Unwrapped (f b)) -> f a -> f b?
09:43:09 <phadej> {AS}: of course, but I just wanted the type specific to monad transformers
09:44:08 <{AS}> phadej: I was just wondering what the most general type for this operation could be :)
09:44:22 <{AS}> I guess (Unwrapped a -> Unwrapped b) -> a -> b
09:44:43 <phadej> {AS}: yes. But sometimes you want to be more specific, to get more specific  type errors
09:44:46 <phadej> when they don't match
09:44:53 <{AS}> Ah
09:45:08 <{AS}> Yeah, that might be a good idea I guess
09:45:27 <phadej> e.g. the use of runM mentioned above
09:45:42 <phadej> or to help compiler
09:45:46 <phadej> pick right instances
09:46:00 <phadej> it's easy to get
09:46:07 <phadej> > show . read "1"
09:46:08 <lambdabot>      Could not deduce (Read (a -> a0))
09:46:08 <lambdabot>      from the context (Read (a -> a1), Show a1)
09:46:08 <lambdabot>        bound by the inferred type for âe_11â:
09:46:13 <phadej> > show . read $ "1"
09:46:14 <lambdabot>  "*Exception: Prelude.read: no parse
09:46:25 <phadej> (it defaulted to ())
09:46:42 <{AS}> interesting
09:46:56 <glguy> You missed a chance to use $, ($) show . read $ "1" 
09:47:21 <{AS}> > ($) show . read $ "1"
09:47:23 <lambdabot>  "*Exception: Prelude.read: no parse
09:47:26 <CICCIO2HD> !list
09:48:10 <phadej> {AS}: I usually write foo :: (MonadReader MyEnv m, MonadError MyError m) => m Foo functions
09:48:34 <{AS}> phadej: Yeah, same here :)
09:48:38 <phadej> and to unwrap them, runM doesn't help that much. I guess.
09:48:48 <{AS}> The problem is that I needed to unwrap in a particular case
09:49:14 <{AS}> because I needed to have the error not affect the underlying monad for that operation
09:49:48 <{AS}> e.g. I had something equivalent to EitherT List a 
09:49:57 <{AS}> and I wanted errors to be local in the list
09:50:31 <{AS}> No, wait that does not make sense
09:50:50 <{AS}> Oh, I wanted to use something else than concat for join
09:52:04 <{AS}> e.g. If I had (op : EitherT List Int) and I want to add the two lists together while staying in the monad
09:52:34 <{AS}> I would normally have to do EitherT (runEitherT op ++ runEitherT op) which is not nice
09:52:38 <{AS}> or so I think :)
09:58:16 <phadej> {AS}: ExceptT is an Alternative
09:58:33 <phadej> so you could just have 'm1 <|> m2'
09:58:42 <{AS}> Is that the same?
09:58:56 <phadej> then you just need to be careful that you unwrap the stack in right order, I guess.
09:59:58 <{AS}> phadej: OK, thanks agan
10:00:01 <{AS}> again*
10:00:27 <phadej> > throwError [1] <|> throwError [2] :: ExceptT [Int] Identity ()
10:00:31 <lambdabot>  mueval-core: Time limit exceeded
10:00:35 <phadej> > throwError [1] <|> throwError [2] :: ExceptT [Int] Identity ()
10:00:37 <lambdabot>  ExceptT (Identity (Left [1,2]))
10:04:13 <Franciman> Hello
10:04:46 <Franciman> is there a function with a signature of this kind: Monad m => (a->b) ->a -> m b
10:04:47 <Franciman> ?
10:05:04 <Franciman> or even weaker constraints like Applicative or Functor
10:05:42 <glguy> ?type \f -> pure . f
10:05:43 <lambdabot> Applicative f => (a -> a1) -> a -> f a1
10:06:18 <Franciman> oh, great thanks a lot
10:06:24 <Franciman> totally forgot about it :(
10:08:21 <hppavilion[1]> Ugh
10:08:31 <hppavilion[1]> How do I return an [Int] from an IO-doing function?
10:08:35 <hppavilion[1]> Specifically, the tail of a list
10:08:36 * hackagebot hsdev 0.1.6.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.3 (AlexandrRuchkin)
10:09:12 <hppavilion[1]> Specifically, the function is of type execute :: String -> [Int] -> [Int]
10:09:25 <dedgrant> hppavilion[1]: Where does IO come in?
10:09:50 <hppavilion[1]> dedgrant: It's the print function for a simple concatenative language I'm making
10:10:06 <hppavilion[1]> dedgrant: Does IO have to be part of the arguments for some reason?
10:10:28 <hppavilion[1]> It just takes the head of an [Int], turns it into a character, and calls putChar on it
10:10:35 <hppavilion[1]> Then I want it to return the tail of the [Int]
10:10:47 <hppavilion[1]> Thus making a stack (or, later, deque)
10:10:54 <Shockk> hppavilion[1]: the return type would need to be IO [Int]
10:11:01 <hppavilion[1]> Shockk: Ah.
10:11:12 <hppavilion[1]> Shockk: That'll probably be a problem
10:11:15 <hppavilion[1]> Oh, classes are ending
10:11:17 <hppavilion[1]> I'll have to go
10:13:52 <kwstas> hi all! when I use pattern match on a list monad/comprehension , even if the pattern fails (e.g. (x:xs <- []), computation does not fail. Is this because of the "fail _ = []" in the monad implementation of the list?
10:14:19 <Cale> kwstas: yeah
10:15:36 <kwstas> :Cale thx! I just needed a confirmation :)
10:15:37 <dedgrant> hppavilion[1]: One way to think about this: write some function (myPrint :: [Int] -> IO ()) that performs the required print action. The point is that in Haskell, IO can be tagged onto types, but not removed (barring awful hacks). All execution of IO is bundled up by (main :: IO ()).
10:17:24 <hppavilion[1]> Shockk: So what I want to do is print a character then discard the IO object. Is that impossible?
10:17:59 <Shockk> discard?
10:18:54 <hppavilion[1]> Shockk: I don't want to use the IO event, I just want to print something and ignore that part. Is that stupid?
10:19:08 <maerwald> unsafeperformIO?
10:19:13 <maerwald> or debug stuff?
10:19:22 <kadoban> hppavilion[1]: I'd be reluctant to call it stupid, but it doesn't sound like it makes a lot of sense.
10:19:30 <maerwald> there is Debug.Trace
10:19:48 <kadoban> hppavilion[1]: If you're talking about printing stuff, you're in IO, there's no escaping that (sanely).
10:20:14 <kadoban> Note that that should only be used for Debug, hence the name ^   and unsafePerformIO is not generally to be used.
10:20:39 <maerwald> it can also be used for calls to pure C functions
10:21:21 <kadoban> That doesn't sound like what they're asking about though.
10:23:18 <mnoonan> hppavilion[1]: you can think of your execute function as taking whatever internal representation of your language you have, and interpreting it as real instructions to the computer. the "as real instructions" part is why you have the IO value.
10:28:55 * hackagebot twitter-feed 0.2.0.5 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.5 (sestrella)
10:38:58 <jle`> hackagebot: you can't write an IO [Int] -> [Int]
10:39:01 <jle`> er, hppavilion[1] 
10:39:42 <jle`> hppavilion[1]: an `IO [Int]` is a description of an IO action that will produce an [Int]
10:40:09 <jle`> there is no "IO object" that the [Int] comes attached with
10:40:17 <jle`> there is no [Int] inside an IO [Int]
10:40:43 <hppavilion[1]> jle`: I'm confused. I haven't read any messages since I last left because I'm in class
10:40:53 <hppavilion[1]> And I still can't, probably
10:40:56 <jle`> it's coo
10:44:24 <hexagoxel> is there a summary/write-up somewhere for the haskell-cafe thread "Language complexity & beginners" / the ($) discussion?
10:49:54 <johnw> I think it's that levity info will not be shown by default?
11:03:57 * hackagebot svg-builder 0.1.0.1 - DSL for building SVG.  https://hackage.haskell.org/package/svg-builder-0.1.0.1 (jeffreyrosenbluth)
11:14:51 <osfameron> is there a typeclass for Stringification?  e.g. that defaults to Show, but could be a human-readable, rather than a Haskell-readable string ?
11:15:17 <nineonine> > let fun f a = return $ f a
11:15:18 <lambdabot>  <no location info>: not an expression: âlet fun f a = return $ f aâ
11:15:22 <nineonine> > :t fun
11:15:24 <lambdabot>  <hint>:1:1: parse error on input â:â
11:15:56 <liste> > :t let fun f a = return $ f a in fun
11:15:57 <lambdabot>  <hint>:1:1: parse error on input â:â
11:16:06 <liste> :t let fun f a = return $ f a in fun
11:16:07 <lambdabot> Monad m => (t -> r) -> t -> m r
11:16:14 <nineonine> got it ! :)
11:17:24 <geekosaur> osfameron, no common one, and I doubt a common one would be used; nobody would agree on output formats...
11:17:26 <MrTrump> is life really better with haskell??
11:18:08 <osfameron> geekosaur: ah ok.  I wasn't really worried about a default format.  More "I declare that I want my object X to have a 'stringify' function"
11:18:22 <osfameron> I'll create my own typeclass I guess
11:18:24 <MrTrump> any happstack.com user in here?
11:18:59 --- mode: ChanServ set +o mauke
11:18:59 --- mode: mauke set +b $a:Mitzelflick
11:19:07 --- kick: MrTrump was kicked by mauke (no)
11:19:50 <osfameron> mauke: ?!
11:20:56 <johnw> osfameron: ban evasion
11:21:06 <osfameron> ah
11:21:07 --- mode: mauke set -o mauke
11:21:28 <osfameron> he did seem quite annoying :-)  but I was impressed it only took 2 lines (I hadn't seen the previous context with different name)
11:21:53 <johnw> this one goes back a long time
11:21:56 <mauke> he's been here before under that name
11:23:01 <mauke> you may also have heard of protontorpedo, azathoth99, darkpaladin, gavino, ion_cannon, lawful_evil, republican_devil, shemale_magic, ...
11:23:46 <niez> hi, I have some troubles with groundhog, here is my code: http://lpaste.net/152759, and here is the error: http://lpaste.net/152760
11:24:21 <niez> No instance for (Eq (DefaultKey Area))
11:25:46 <liste> niez: is DefaultKey some groundhog type?
11:25:57 <hppavilion[1]> jle`: So what I'm trying to do is execute a simple concatenative language
11:26:01 <niez> liste, yes
11:26:43 <hppavilion[1]> I have a function called `execute` with arguments `com` and `stack` that is supposed to return the new stack
11:27:16 <hppavilion[1]> jle`: So it does it recursively by taking the program, reversing it, and executing the last instruction with the second to last as its stack argument in the same way
11:27:34 <osfameron> mauke: hah.  I can't understand what fun it is to troll a technical channel (especially when you get re-banned so efficiently)
11:28:00 <hppavilion[1]> So then the second to last uses the stack generated by the third to last as its stack argument
11:28:01 <hppavilion[1]> etc.
11:29:00 <hppavilion[1]> jle` (or if jle` is AFK, Shockk): So how should I restructure my program to allow for IO
11:29:59 <hppavilion[1]> My first instinct is to have some instructions use a different function with those instruction IDs held in a list
11:30:00 <jle`> hppavilion[1]: what's the type of execute that you want?
11:30:03 <hppavilion[1]> But that doesn't seem right
11:30:15 <hppavilion[1]> jle`: String -> [Int] -> [Int]
11:30:34 <hppavilion[1]> The first argument is the instruction, the second is the start stack, the output is the result stack
11:30:45 <hppavilion[1]> result/new stack
11:31:13 <jle`> then, how about, instead of returning a new stack, return a descirption of an IO computation that would produce your new stack
11:31:18 <jle`> execute :: String -> [Int] -> IO [Int]
11:31:45 <jle`> execute str (x:xs) = do ...
11:31:58 <hppavilion[1]> jle`: OK...
11:32:04 <hppavilion[1]> But why do that for only one instruction?
11:32:18 <jle`> well, you can recurse
11:32:20 <jle`> on xs
11:32:26 <hppavilion[1]> jle`: Yes, that's what I'm doing :)
11:32:35 <jle`> so you can recurse in your do block
11:32:45 <jle`>    res <- execute str xs   -- or whatever call to execute you want
11:32:53 <hppavilion[1]> jle`: But why have an IO type when only one instruction does IO?
11:32:53 <jle`> do you know how do blocks work?
11:33:08 <hppavilion[1]> jle`: Not really; I'm doing this project to help myself learn Haskell xD
11:33:18 <jle`> well, you're returning an IO action that produces an [Int]
11:33:18 <niez> liste, when I derive Eq, Ord and Show like this: http://lpaste.net/152761 then it compiles
11:33:29 <jle`> even if one instruction does IO, then your whole thing still is an IO action in the end
11:33:33 <hppavilion[1]> Ooooooh
11:33:39 <hppavilion[1]> I see
11:33:48 <jle`> you don't return an [Int], you describe IO actions that would create your [Int]
11:34:02 <hppavilion[1]> I've decided that Esolang implementation is actually an ideal project for an experienced programmer to learn a new language
11:34:06 * hackagebot gore-and-ash-glfw 1.1.0.0 - Core module for Gore&Ash engine for GLFW input events  https://hackage.haskell.org/package/gore-and-ash-glfw-1.1.0.0 (NCrashed)
11:34:07 <hppavilion[1]> Interesting
11:34:26 <liste> niez: then do it that way. non-standalone deriving can get hairy with data families
11:34:27 <jle`> do blocks are a nice sugar for you to describe complex IO actions
11:34:51 <jle`> every "line" is an IO action that you want to sequence one-after-the-other
11:34:54 <hppavilion[1]> jle`: So currently, the 0 instruction is defined as (head dq * 10 + 0):(tail dq). How do I change that to produce an IO object?
11:35:13 <hppavilion[1]> (I discovered a nice algorithm for using instructions to write numbers- that's what that is)
11:35:15 <jle`> `do action1; action2` describes an IO action that consists of doing action1, then action2
11:35:28 <hppavilion[1]> jle`: Uhuh...
11:35:43 <hppavilion[1]> jle`: So I just define it with do?
11:35:45 <jle`> well, in that case, your IO action is basically a no-op
11:35:47 <hppavilion[1]> At the beginning?
11:35:58 <jle`> it's a no-op that produces (x*10+0):xs
11:36:05 <hppavilion[1]> jle`: Yes
11:36:06 <jle`> it's a no-op IO action that produces that as its result
11:36:12 <hppavilion[1]> jle`: OK
11:36:12 <jle`> ther's a function that gives you such an action: return
11:36:18 <jle`> `return :: a -> IO a`
11:36:25 <niez> liste, what is the difference between data MyData =  MyData { ... } deriving Eq, deriving instance Eq MyData and instance Eq MyData ?
11:36:34 <jle`> `return x` gives you a no-op IO action whose result is just x
11:36:50 <niez> liste, I see I have 3 options
11:37:03 <hppavilion[1]> So `execute "0" dq = (head dq * 10 + 0):(tail dq)` is my definition for the 0 instruction. How do I make that produce an IO object instead?
11:37:09 <hppavilion[1]> DO I just put "do" after the =?
11:37:13 <liste> niez deriving instance ... is basically same as data ... deriving ...; just "instance Foo Bar" is differeent
11:37:19 <jle`> ah you wouldn't need 'do'
11:37:21 <jle`> you can just do return
11:37:23 <hppavilion[1]> jle`: Ooooh
11:37:24 <liste> the last one uses GHC Generics
11:37:24 <hppavilion[1]> I see
11:37:36 <liste> or actually, whatever the default implementation is
11:37:37 <jle`> execute "0" (x:xs) = return ((x*10 + 0) : xs)
11:37:57 <liste> there can be default implementations for typeclass methods
11:38:12 <liste> "deriving Foo Bar" uses them
11:38:20 <niez> liste, ok, I see, instance Foo Bar uses default implementation
11:38:38 <jle`> this means that execute "0" (x:xs) is an IO no-op whose result is (x*10+0) : xs
11:38:48 <niez> liste, so what is the difference between deriving in data definition and standalone deriving?
11:38:49 <jle`> your other instructions might be IO actions that do things that aren't no-op
11:38:51 <jle`> s
11:39:27 <liste> niez: nothing really, except in standalone deriving you can specify more things, like multiple type class parameters
11:40:18 <axm> What would you use for dynamically loaded, precompiled plugins? plugins seems to have some unexpected problems - is this still the way? I had a quick look at the GHC API, but only found loading of source code and what I have is object code ...
11:40:40 <niez> liste, so why the compiler rejected my program when I derived Eq in data definition and accepted when I used standalone definition? standalone definition was without any additional parameters
11:42:03 <hppavilion[1]> jle`: I don't do it with x:xs form because of instructions like DUP
11:42:13 <hppavilion[1]> Though I suppose I could do it like that
11:42:25 <jle`> you can chooose a different pattern for every instruction
11:42:33 <jle`> execute "DUP" xs = ...
11:42:48 <jle`> although, i'd recommend against using strings for your instructions
11:43:01 <jle`> use an enumerable/adt instead?
11:43:10 <jle`> data Instruction = Dup | AnotherInstruction | Zero | ...
11:43:23 <jle`> so execute :: Instruction -> [Int] -> [Int]
11:43:32 <jle`> er, Instriction -> [Int] -> IO [Int]
11:44:12 <Kaidelong> if this is an implementation of FORTH shouldn't that be something like "step :: [Instruction] -> IO [Instruction]"?
11:45:40 <axm> niez: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html explains it better than I could ...
11:48:13 <niez> axm, the docs says: You must supply an explicit context, but I didn't supply any context
11:48:41 <hppavilion[1]> YES!
11:48:42 <hppavilion[1]> IT WORKS!
11:48:51 <hppavilion[1]> `# 3 6 .` prints "$"
11:49:06 * hackagebot logict-state 0.1.0.0 - Library for logic programming based on haskell package logict  https://hackage.haskell.org/package/logict-state-0.1.0.0 (AtzeDijkstra)
11:49:49 <niez> liste, axm, thanks for your time, I will use what works for now and leave the details
11:50:00 <axm> niez: I assume you do not have any extensions activated? I have not yet run into that problem, so my understanding is limited as well.
11:50:17 <hppavilion[1]> jle`: Thanks for the help :)
11:50:21 <jle`> hppavilion[1]: congrats :)
11:50:31 <hppavilion[1]> jle`: Why not use strings for my instructions?
11:50:37 <niez> axm, yes, I have many: {-# LANGUAGE GADTs, TypeFamilies, TemplateHaskell, QuasiQuotes, FlexibleInstances, StandaloneDeriving, DeriveGeneric #-}
11:50:45 <jle`> although, once you finish your program, it might be worth taking a high-levle look and seeing how to factor out IO actions out of your program
11:50:55 <hppavilion[1]> jle`: Perhaps
11:50:57 <jle`> for example, think about the type of IO actions that you are likely to execute
11:51:08 <jle`> and then maybe, instead of usiong IO a to describe them, describe them with normal data
11:51:21 <jle`> for example, if all you ever do is print out strings to the screen, then maybe return an ([Int], String)
11:51:28 <jle`> where String is the strings you're planning on printing
11:51:33 <hppavilion[1]> Maybe
11:51:40 <jle`> but this is easier to do once you've written everything out
11:51:57 <jle`> hppavilion[1]: don't use strings as instructions because then your function is partial
11:52:06 <jle`> it's not defined for all inputs, and the types don't tell you what is "allowed"
11:52:22 <jle`> for execute :: String -> ..., the type doesn't tell you anything about what sort of strings are allowed to be put in
11:52:42 <jle`> execute :: Instruction -> ..., it tells you that you only want an instruction from a certain set/type of instructions
11:52:53 <jle`> and also, you can't pass in any illegal instructions
11:53:02 <jle`> or well, at least, any strings that don't correspond to an instruction
11:53:22 <jle`> it's the Haskell Way(tm)   -- let your types say as much as possible
11:54:29 <Gurkenglas> Where do his instructions originally come from? If it's user input, he'll still have to write a parser to translate it into Instructions
11:55:05 <hppavilion[1]> Gurkenglas: The parser is basically just split from Data.Text
11:55:12 <hppavilion[1]> Gurkenglas: It's not a practical language
11:55:19 <jle`> yeah; or a simple parser might be stringToInstruction :: String -> Maybe Instruction
11:55:26 <jle`> stringToInstruction "DUP" = Just DUP   -- etc.
12:01:00 <GGuy> hi, I'm looking for a mapM function with Monadic result, does this already exist and I'm missing it? (Monad m, Monad n) => (a -> m (n b)) -> [a] -> m (n b)
12:01:19 <jle`> um
12:01:25 <jle`> do you really want it to be polymorphic over all Monad n ?
12:01:34 <jle`> how would it behave?
12:01:48 <jle`> is there a specific n you're trying to use it with?
12:02:33 <Gurkenglas> :t ala Compose traverse
12:02:35 <lambdabot> (Applicative f', Applicative g', Traversable t) => t (f' (g' a')) -> f' (g' (t a'))
12:02:53 <Gurkenglas> :t alaf Compose traverse -- Oh wait you want a hook too.
12:02:54 <lambdabot> (Applicative f', Applicative g', Traversable t) => (a -> f' (g' a')) -> t a -> f' (g' (t a'))
12:03:08 <Gurkenglas> Note that it's [b] in the result, not b
12:03:28 <Gurkenglas> jle`, mapM is really traverse and Applicatives compose
12:03:35 <jle`> sure
12:03:41 <jle`> but that might not be the behavior they want
12:03:55 <GGuy> Well in my case it'll be a lucid "Html ()"
12:04:12 <Gurkenglas> It's the only possible behavior of that type, right?
12:04:39 <jle`> if it's an `a -> m [b]`, then they might want to concatenate the results, for instance
12:04:55 <GGuy> jle`: yes
12:05:13 <Gurkenglas> Okay, not of the type they provided, but my type :P
12:05:58 <GGuy> (Monad m) => (a -> m (Html ()) -> [a] -> m (Html ())
12:06:09 <Gurkenglas> Is Html MonadPlus?
12:06:12 <jle`> there are some other, more degenerate behaviors possible with that type :O
12:06:23 <jle`> hm, in this case, it looks like Compose and traverse really would work
12:06:29 <jle`> because Html () is a Writer, I think
12:06:41 <jle`> or you could mapM and sequence
12:06:59 <jle`> sequence =<< mapM f xs
12:07:03 <jle`> sequence_
12:07:20 <axm> niez: the documentation lists exceptions for the behavior of standalone deriving when some of these (at least FlexibleInstances) are active, this might explain the difference
12:08:05 <jle`> but yeah, Compose and traverse would actually work here, heh :)  runCompose . traverse (Compose . f)
12:08:33 <niez> axm, thanks
12:08:59 <GGuy> jle`: thanks
12:09:22 <Gurkenglas> *traverse_, if he wants () instead of [()]
12:09:35 <jle`> i'd probably sequence and mapM myself, but compose/traverse is cool too
12:09:37 <jle`> yeah, thanks :)
12:10:26 <jle`> oh, that'd be sequence <$> mapM f xs
12:10:34 <jle`> *sequence_
12:10:48 <jle`> which I guess is a bit confusing because the sequence and mapM/<$> instances are different
12:11:24 <GGuy> jle`: yeah, i thought a sequence mapM would be common and a utility already in existence but i guess not that common?
12:13:05 <Ralith> are there any decent gui libraries on stackage?
12:13:39 <Ralith> ah, gtk2hs is there
12:16:23 <rpglover64> Anyone here knowledgeable in either `synthesizer-core` (the Haskell package) or proxychains (the command line program)?
12:16:59 <rpglover64> I'm trying to implement PSOLA (or find an implementation) in Haskell (hence `synthesizer-core`)
12:17:30 <rpglover64> and I ran into a very strange behavior using proxychains with a Haskell script (curl, wget, and aria2c do not exhibit this behavior)
12:18:35 <rpglover64> In particular, if I don't do DNS lookup over the proxy (either the url I access is an IP address or I pass the option to proxychains to do DNS locally), all proxies time out immediately.
12:19:22 <rpglover64> I'm using `scalpel` to try to do web scraping; I think it's using curl as a backend.
12:28:23 <LambdaNoob> What's the correct way of specifying a list of different datatypes and processing each element on that list slightly differently? Each element of that list is part of the same typeclass.
12:28:36 <LambdaNoob> Or is there a better design?
12:28:42 <shachaf> There probably is.
12:28:48 <shlevy> Is there any way to have an associated type be polymorphic? e.g. if I have class Foo a where type Bar a :: *, can I have instance Foo Int where type Bar Int = (Monad m) => m Int?
12:29:03 <shlevy> (I'm getting Illegal polymorphic or qualified type currently)
12:29:05 <LambdaNoob> What would be a better design?
12:29:21 <LambdaNoob> I'm not sure how to approach this problem.
12:30:54 <LambdaNoob> Lets say I have a bunch of datatypes wrapping a different URL in each case, and for each of these datatypes, I have to scrape the URL differently, how can I store them all in one list or what is the correct approach for this?
12:31:02 <ggVGc> LambdaNoob: probably an ADT? Type classes are not polymorphic in that way afaik, i.e the way classes in C++ are
12:31:03 <rpglover64> LambdaNoob: One way to do it is to suck it up and write the boilerplate to convert them all to a single data type
12:31:16 <rpglover64> Another way is to process them before putting them into the list
12:31:16 <ggVGc> you can't have a list of "Stuff of the same type class"
12:31:18 <dmj`> LambdaNoob: you could use a typeclass
12:31:26 <rpglover64> and have laziness save you extra work
12:31:38 <LambdaNoob> They're all instances of the same typeclass, but I don't know how to do it the right way.
12:32:03 <rpglover64> there's the existential type class antipattern: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
12:32:10 <dmj`> LambdaNoob: class Fetch a where fetch :: a -> IO Either SomeException ByteString
12:32:11 <rpglover64> (provided for mostly for reference)
12:32:22 <dmj`> IO ( .. ) *
12:33:03 <rpglover64> shlevy: I don't think so
12:33:21 <rpglover64> An explicit forall or an explicit parameter might save you
12:33:53 <rpglover64> (shlevy: are you who I think you are?)
12:34:23 <axm> for the record: dynamic-loader does the job of loading object code directly (previously I skipped over that package)
12:35:12 <LambdaNoob> Hmm, thanks. I'll have to rethink my design, still not sure it's a good one.
12:35:52 <dfeuer> Is there a polykinded version of Compose somewhere?  newtype ComposeP (f :: k2 -> *) (g :: k1 -> k2) (a :: k1) = ComposeP (f (g a))   ?
12:35:58 <shlevy> rpglover64: No dice :(
12:36:49 <phaazon> @index Constraint
12:36:49 <lambdabot> GHC.Exts
12:39:39 * hackagebot hcoap 0.1.2.0 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.2.0 (lulf)
12:40:03 <dfeuer> phaazon, you can get Constraint from Data.Constraint if you don't mind the dependency.
12:54:39 * hackagebot elision 0.1.3.0 - Arrows with holes.  https://hackage.haskell.org/package/elision-0.1.3.0 (jacrough)
12:54:41 * hackagebot elision 0.1.3.1 - Arrows with holes.  https://hackage.haskell.org/package/elision-0.1.3.1 (jacrough)
12:55:00 <`Guest00000> hello. i want to evaluate a table (0,999) -> Double once and memoize it. am i doing it right? http://lpaste.net/152767
12:59:40 * hackagebot elision 0.1.3.2 - Arrows with holes.  https://hackage.haskell.org/package/elision-0.1.3.2 (jacrough)
13:00:29 <phaazon> dfeuer: I do
13:00:32 <phaazon> GHC.Exts is fine
13:01:03 <lpaste> glguy annotated âNo titleâ with âNo title (annotation)â at http://lpaste.net/152767#a152770
13:03:05 <glguy> `Guest00000: You needed extra parentheses in the last line assuming I understood what you were doing. You can use range to enumerate the indexes in the order listArray expects in general, and you should use explicit conversions between types to turn the Int indexes into Doubles
13:03:43 <`Guest00000> ah sorry
13:04:04 <`Guest00000> i thought ! has precedence less than 9
13:04:08 <glguy> A sorry certainly isn't needed :)
13:04:10 <`Guest00000> it's not really my code
13:04:24 <glguy> `mod` has precedence 7
13:04:31 <glguy> infixl 7 `mod`, specifically
13:04:35 <Hummer12007> hi, what reading would you suggest as an introduction to lambda calculus (more theoretically(mathematically), than practically oriented)?
13:05:05 <`Guest00000> wait...
13:05:18 <`Guest00000> `foo` can have precedences less than 9?..
13:05:20 <EvanR> heh you cant x & h >>> g >>> f 
13:05:26 <glguy> `Guest00000: Yup!
13:05:26 <EvanR> no java for me
13:05:29 <Hummer12007> is Church's 'Calculi of lambda-conversion' ok for the purpose?
13:05:46 <glguy> `Guest00000: a "fun" one to know is that infix 4 `elem`
13:06:21 <glguy> `div`, `mod`, `quot`, `rem` are all 7
13:07:14 <`Guest00000> learn something surprising every day... .
13:09:08 <Gurkenglas> Consider "thisIsCalledFrequently = memoize sin . (`mod` sinTableSize)"
13:10:52 <Gurkenglas> thisIsCalledFrequently = memoize (sin . fromInteger) . (`mod` sinTableSize) -- i guess
13:13:34 <puregreen> a Template Haskell related question: why doesn't reify list the derived classes? E.g. here's what reify ''Maybe returns:
13:13:45 <puregreen> TyConI (DataD [] GHC.Base.Maybe [KindedTV a_1627404853 StarT] [NormalC GHC.Base.Nothing [],NormalC GHC.Base.Just [(NotStrict,VarT a_1627404853)]] [])
13:14:21 <puregreen> the last â[]â should've been [Eq, Ord]
13:22:35 <`Guest00000> how range is different from enumFromTo
13:22:59 <`Guest00000> ?
13:23:18 <Cale> `Guest00000: range uses the convention of Ix, which may be different
13:23:35 <Cale> > range ((0,0),(3,3))
13:23:37 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
13:25:16 <Cale> There isn't an Enum instance for pairs, so that wouldn't even work there.
13:26:01 <`Guest00000> nice
13:26:41 <dedgrant> Oh that is interesting. Where is range defined?
13:29:05 <`Guest00000> dedgrant: Data.Ix
13:29:45 <dedgrant> cheers
13:36:31 <siriusbtx> Did anyone here participate in google hashcode using haskell?
13:39:41 * hackagebot hcoap 0.1.2.1 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.2.1 (lulf)
13:52:17 <LambdaNoob> How do you parse a string and return a type depending on the contents of the string?
13:53:24 <Zekka|Sigfig> You canât really return a type. Do you mean return a value whose type depends on that?
13:53:29 <LambdaNoob> yeah
13:53:31 <LambdaNoob> that's what i mean
13:53:35 <geekosaur> you don't, since you have to know the type that is being retued at compile time
13:53:40 <Zekka|Sigfig> Because if so, you first need to define a type that can contain any of the types you would be producing
13:53:41 <koala_man> LambdaNoob: you can return a type similar to  Either String Int, which can be Left String or Right Int  but not both or neither
13:54:18 <Zekka|Sigfig> you can do this with a type having multiple constructors like Either, or with existentials. (multiple constructors is usually preferred)
13:54:43 <LambdaNoob> Hmm, i just can't figure out a clean design for my system.
13:55:07 <kadoban> LambdaNoob: Can you explain more about it?
13:55:20 <LambdaNoob> I'll have a list of URLs which are only available at runtime, I'll need to parse these and perform slightly different behaviour based on whatever URL I have.
13:55:34 <LambdaNoob> So I decided to make different data types for each class of URL.
13:55:41 <LambdaNoob> and have a common typeclass over all these types.
13:55:52 <Zekka|Sigfig> Sounds like a case where multiple data constructors is more appropriate
13:56:12 <Zekka|Sigfig> data URL = URLKind1 String | URLKind2 String | URLKind3 â¦
13:56:16 <kadoban> LambdaNoob: Why not data MyUrl = AUrl String | BUrl String
13:56:41 <Zekka|Sigfig> You could also make AUrl and BUrl refer to a separate type if you want to write functions that can only operate on a certain kind of URL
13:57:02 <Zekka|Sigfig> data AUrl = AUrl String; data BUrl = BUrl String; data Url = A AUrl | B Burlâ¦
13:57:24 <kadoban> Alternatively you could do    data UrlType = A | B      data MyUrl = MyUrl UrlType String
13:57:49 <Zekka|Sigfig> Yeah, provided each URL is a string and the only difference is the type tag
13:57:57 <kadoban> Yes
13:58:38 <LambdaNoob> Hmm, that makes sense, can define a different instance for each type of URL?
13:59:15 <Welkin> it doesn't look like there are any forum/message board applications in haskell (everything is in php)
13:59:19 <Welkin> I wonder why that is
13:59:44 <Welkin> all the popular forum software is in php of all things
14:00:03 <kadoban> LambdaNoob: In which formulation? Usually you shouldn't need a typeclass for this â¦ beginners tend to use them where they're not actually helpful. Though I don't really understand your problem exactly enough to tell for sure.
14:00:06 <Welkin> forums are used by everyone though, even huge companies, so what's with that
14:00:37 <niez> I have my data defined like this: http://lpaste.net/152771, I have problems with groundhog, http://lpaste.net/152772, No instance for (Show (DefaultKey Area)), it looks like DefaultKey is the problem, how can I fix that? I get similar errors when I derive Ord and Eq
14:00:42 <Welkin> I am not satisfied with any of them, so I considered writing my own in haskell (perhaps in the near future)
14:01:47 <LambdaNoob> kadoban: I'm going to parse a bunch of URLs which are only available at runtime, and create different types based on the contents of the URL. I'll have to operate on each of these types slightly differently, though the parameters and return type will be common for the operation.
14:02:13 <Zekka|Sigfig> LambdaNoob: Why is it necessary to represent separate types?
14:02:17 <kadoban> LambdaNoob: Yes I got that part, but the details beyond that seem important towards answering the question of which way to model it and if a typeclass is needed or not.
14:02:30 <Zekka|Sigfig> er, represent them as separate types*
14:02:44 <LambdaNoob> Maybe I'm using terminology wrongly.
14:02:46 <Zekka|Sigfig> We gave you a few designs that represent them as the same type, with multiple constructors. Would any of those work?
14:03:01 <LambdaNoob> Yeah, i think I am.
14:03:30 <LambdaNoob> data SomeType = A a | B b is the same type right?
14:04:06 <kadoban> Yes, that is one type.
14:04:06 <LambdaNoob> How would I operate on things of the same type, but different data constructor?
14:04:39 <kadoban> LambdaNoob: Pattern matching, fundamentally. Though you can write helper functions or whatever.
14:04:59 <kadoban> f (A a) = stuff  <new line> f (B b) = other stuff
14:05:24 <hexagoxel> could somebody upload the docs for the latest transformers to hackage already? thanks.
14:06:36 <Welkin> hexagoxel: they are uploaded automatically
14:06:44 <Welkin> sometimes it seems to not upload properly
14:07:00 <Welkin> you can switch to the previous versio to see the docs usually
14:08:45 <hexagoxel> i know. it just requires more than 3 clicks *whine whine*
14:08:49 <LambdaNoob> kadoban: Ok, I think I understand now, seems like I don't need typeclasses. When would you use typeclasses then? Only for abstracting across commonalities between types?
14:09:30 <Welkin> LambdaNoob: write your own typeclass you mean?
14:09:35 <LambdaNoob> Yeah
14:09:39 <Welkin> almost never
14:10:00 <EvanR> LambdaNoob: its kind of tough to see where type classes are useful without a lot of examples
14:10:16 <LambdaNoob> So typeclasses aren't really analogous to interfaces in OO?
14:10:19 <EvanR> the standard classes are all kind of magic sweet spots in convenience or part of a larger mathematical framework
14:11:08 <EvanR> LambdaNoob: you can think of type class constraints as being an extra parameter of the functions to operate on your type. you can do the same thing as type classes in all cases by passing that set of operations yourself
14:11:21 <EvanR> so Num, Ord etc can be seen as a convenience
14:11:30 <ski> (plus extra guarantees)
14:11:34 <EvanR> but theres a limit to the convenience
14:11:40 <EvanR> it can get in the way
14:12:22 <LambdaNoob> Are they at all similar to traits?
14:12:49 <EvanR> i havent figured out what traits are yet
14:13:19 <ski> LambdaNoob : i suppose one way to think about it is that you often have to resort to interfaces (or just subclasses) in languages like Java, due to the lack of sum types
14:15:24 <ski> we typically say that type classes are for overloading in Haskell. preferably where the diverse implementations of the overloaded operation set all satisfy some common set of reasonable laws
14:21:08 <EvanR> LambdaNoob: theres a video with a comparison between type classes and other things, including scala implicits. https://www.youtube.com/watch?v=hIZxTQP1ifo
14:25:45 <fr3tz0r> how do i get right indentation for haskell code in emacs using ghc as compiler? I tried haskell-mode-stylish-buffer but it misses some stuff
14:25:58 <Welkin> haskell-mode
14:26:37 <fr3tz0r> yes?
14:26:42 <fr3tz0r> nothing changes
14:26:51 <verement> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
14:27:22 <fr3tz0r> thought i done that must recheck
14:29:32 <fr3tz0r> yeah done that before
14:29:39 <Welkin> and then restart emacs or use M-x load-file on your .emacs
14:29:43 <LambdaNoob> Thanks for the help guys!
14:30:11 <fr3tz0r> yeah
14:35:21 <LambdaNoob> Is it possible to split up your data constructors for a sum type into different modules?
14:35:26 <niez> groundhog expert needed, how to serialize data with foreign key (DefaultKey) to json (using aeson)?
14:38:31 <Hijiri> LambdaNoob: no
14:38:55 <Hijiri> that would defeat part of the purpose too, since constructors of a sum type are supposed to be closed
14:39:25 <LambdaNoob> how about into separate statements?
14:39:46 <Hijiri> they all have to be defined in the data declaration
14:40:10 <mniip> you can cps-transform your whole type away
14:40:18 <mniip> then you can have constructors in different module
14:40:19 <mniip> s
14:40:23 <mniip> but that's kinda moot
14:40:48 <LambdaNoob> Like data SomeTypeA = TypeA String, data SomeTypeB = TypeB String, data Type = TypeA | TypeB
14:40:52 <LambdaNoob> not possible?
14:41:15 <mniip> then TypeA would be a constructor for both SomeTypeA and Typ
14:41:16 <mniip> e
14:41:29 <rod_> I run out of memory ..... http://lpaste.net/152774 where am i to lazy ..... ? tags: recursion, State Monad, 
14:42:17 <LambdaNoob> or could you do data Type = SomeTypeA | SomeTypeB?
14:42:28 <rod_> f' is the original function ... to speed up f' , f uses State (Data.Map) to store function (argument,result) to cut branches of recursive call tree .... even with no State "put" ... i run out of memory ...
14:42:36 <mniip> LambdaNoob, not really no
14:42:47 <mniip> you can however do: type Type = Either SomeTypeA SomeTypeB
14:42:55 <mniip> but then it's not really a data
14:43:03 <mniip> though,
14:43:07 <mniip> what are you trying to do
14:43:18 <LambdaNoob> What happens when I do though, ghci allows me to do data Type = SomeTypeA | SomeTypeB
14:43:33 <`Guest00000> LambdaNoob: that's different names
14:43:40 <LambdaNoob> Oh
14:44:01 <`Guest00000> a name in constructor namespace and a name in type namespace
14:44:41 <LambdaNoob> So there is no alternative to a really long data declaration if you have lets say 10+ constructors?
14:45:29 <geekosaur> you can put each one on a separate line, but still part of the same declaration
14:45:42 <geekosaur> (you need to indent the addtional lines)
14:46:21 <kadoban> LambdaNoob: They can be on separate lines. It'd have to be a pretty insane type definition for being on separate lines to not be enough splitting stuff up to make it intelligible.
14:46:34 <glguy> rod_: On these programming practice problems where they ask for the final answer MOD "bignumber" you can't wait until the end to do the MOD
14:46:45 <LambdaNoob> Ok, sweet. Thanks!
14:47:43 <LambdaNoob> Does record syntax work with sum types?
14:48:01 <kadoban> LambdaNoob: Yes â¦ but it's usually not a good idea to mix the two.
14:48:16 <kadoban> At least you have to be careful with how you do.
14:48:54 <jle`> yeah, it's easy to make partial functions :O  typically a lot of people just avoid it
14:48:57 <jle`> or they write prisms instead
14:49:08 <jle`> or manual Maybe-like accessors
14:49:17 <mniip> 1455835384 [01:43:04] <LambdaNoob> So there is no alternative to a really long data declaration if you have lets say 10+ constructors?
14:49:18 <mniip> why not
14:49:24 <mniip> consider
14:49:25 <mniip> https://downloads.haskell.org/~ghc/7.6.2/docs/html/libraries/ghc-7.6.2/src/HsExpr.html#HsExpr
14:49:57 <rod_> glguy: so i have to mod inside the function kernel ?
14:50:09 <LambdaNoob> thanks for the example mniip
14:50:19 <glguy> rod_: Yeah. the main problem with your program is that it's accumulating HUGE numbers that take a lot of memory to store
14:51:08 <fr3tz0r> it's enough to compile the "main"-file with main if i have multipe .hs files that this file uses
14:51:11 <fr3tz0r> ?
14:51:33 <mniip> hmm that's slightly outdated, a newer version: http://downloads.haskell.org/~ghc/8.0.1-rc2/docs/html/libraries/ghc-8.0.0.20160204/src/HsExpr.html#HsExpr
14:52:03 <rod_> yes ... it says i run out of memory ...  but not to use +RTS -KXXX -RTS to increase stack ..... , however the f' function is doing the same computation without State Monad and it doesnt acuumulate memory ...
14:52:25 <LambdaNoob> Oh, cool, they use record syntax with their sum type.
14:52:28 <LambdaNoob> For some things.
14:55:23 <rod_> i know about x^(a+b) mod bignum == (x^a mod bignum) * (x^b mod bignum) ...   
14:56:49 <LambdaNoob> mniip: In the latest example I see some declaration of constructors like OpApp  (LHsExpr id)  
14:57:08 <mniip> right
14:57:11 <LambdaNoob> what do they parentheses do? Seems like it would be named fields, but ghci doesn't let me do that.
14:57:19 <glguy> rod_: Modifying  your program like this seems to resolve your space leak: http://lpaste.net/152774
14:57:27 <mniip> OpApp is a constructor with 4 arguments
14:57:40 <mniip> 3 of type 'LHsExpr id' and one of type 'PostRn id Fixity'
14:57:55 <mniip> parentheses are to disambiguate the fact that 'LHsExpr id' is one type and not 2
14:57:56 <LambdaNoob> You can have types with spaces in them?
14:58:01 <mniip> no
14:58:04 <mniip> well
14:58:21 <mniip> yes, but I don't think you're thinking of the right thing
14:58:38 <LambdaNoob> 'LHsExpr id' is one type?
14:58:42 <mniip> consider data Foo = FooCon (Maybe Int)
14:58:46 <mniip> 'Maybe Int' is one type
14:58:47 <mauke> > sqrt 2  -- look, a number with a space in it
14:58:48 <lambdabot>  1.4142135623730951
14:58:50 <LambdaNoob> Ahh
14:58:53 <LambdaNoob> I see
14:59:04 <mniip> what mauke said
14:59:35 <mniip> 1455836122 [01:55:22] * mauke (~mauke@p3m/member/mauke) has left (""i need an OP. no one that is a regular user can help." riiiiigh")
14:59:37 <mniip> lmao
14:59:39 <dfeuer> Weird...  Data.Vector.Fusion.Stream.Monadic doesn't seem to be very consistent about where it's strict (pushing returns into case branches, for instance) and where it's lazy (liftM, return . step, etc.) Is there some sort of sense to it?
15:00:46 <glguy> rod_: specifically the return$! in the main body of 'f' was important
15:00:54 <rod_> glguy, thanx i ll give it a try ....
15:01:30 <dfeuer> Anyone know the story?
15:01:45 <LambdaNoob> mniip for types like that, are only applicatives the only instance of that kind of type?
15:01:55 <mniip> what
15:01:56 <rod_> yes ... i already grasp that i was "too lazy" .... inserted the $! bang at the (put) .... 
15:02:13 <rod_> glguy, wait ... i try 
15:02:16 <LambdaNoob> Like (Maybe Integer)
15:02:46 <mniip> what does Applicative have to do with this?
15:03:06 <LambdaNoob> in the lhs of that expression, does that type have to be an applicative?
15:03:43 <mniip> no?
15:03:45 <glguy> rod_: the put $! was making the Dict value strict, not the values contained within
15:04:06 <mniip> data declarations are largely unrelated to any typeclasses
15:04:43 <dfeuer> <$!> can be useful. It's a bit weird though, since it does things in a very different order than $!.
15:09:04 <rod_> glguy , tried it ... stilll ... after 5,6 seconds consumed all mem and all swap and my machine doesnt react anymore :(
15:09:31 <glguy> rod_: I tried it and it kept memory under 2.6 MB
15:09:47 <glguy> so we must have tried different things. I used GHC 7.10.3 with -O2
15:09:59 <glguy> :(
15:10:05 <rod_> #yes ...
15:10:47 <rod_> you used Map.Strict ... and i changed State.Strict to State .... my fault ... wait again ....
15:11:36 <fr3tz0r> never experienced this berfore. Code runs fine on one system but not on the other even if both system uses ghc
15:12:12 <fr3tz0r> is there known problems in haskell/ghc differences
15:12:17 <lpaste> glguy annotated âout of memory .....â with âout of memory ..... (annotation)â at http://lpaste.net/152774#a152781
15:12:20 <fr3tz0r> ?
15:12:24 <glguy> rod_: ^ That's the one I used
15:12:33 <rod_> have to cabal install Map.Strict
15:12:37 <rod_> ....
15:12:40 <glguy> rod_: NO
15:12:44 <glguy> err, just regular "No"
15:12:48 <rod_> why ?
15:12:53 <glguy> Because it's in the same package
15:13:07 <glguy> 1. That doesn't matter for this 2. It's Data.Map.Strict, not Map.Strict
15:13:20 <rod_>  Could not find module `Data.Map.Strict'
15:13:20 <rod_>     Perhaps you meant
15:13:20 <rod_>       Data.Strict (from strict-0.3.2)
15:13:20 <rod_>       Data.HashMap.Strict (from unordered-containers-0.2
15:13:33 <kadoban> rod_: How old is your GHC?
15:13:40 <glguy> Wow, what version of containers are you using?
15:14:06 <rod_> ghc 7.4.1
15:14:26 <kadoban> That's a *really* old version.
15:14:57 <rod_> k ...
15:15:17 <kadoban> You'll have to upgrade GHC to use Data.Map.Strict I believe.
15:15:35 <glguy> In any case you don't need that module to use the version I pasted
15:16:25 <jle`> wow
15:16:30 <jle`> how did you even find 7.4 out in the wild
15:16:44 <jle`> sorry, that wasn't meant to offend ... i'm genuinely curious
15:17:11 <rod_> Linux ristretto 3.2.0-4-686-pae #1 SMP Debian 3.2.73-2+deb7u2 i686 GNU/Linux
15:17:24 <rod_> no prob ...
15:17:37 <Hafydd> I recently discovered (to my displeasure) that the default version of GHC on AWS EC2 machines is 7.0.4.
15:17:50 <kadoban> Lol, wow â¦
15:17:51 <rod_> do you know the first eeepc from asus ... the 701 version ....
15:17:56 <kadoban> How old even is that?
15:18:13 <geekosaur> oh dear
15:18:29 <kadoban> 7.0.4 is apparently June 2011. I would have thought older, but even that's a long time.
15:19:41 <rod_> ... my working "machine"
15:19:43 <geekosaur> (that said, I'm using an eeepc netbook as a fileserver :p )
15:20:23 <rod_> installed libghc-strict-dev ... no Data.Map.Strict ... think i have to somehow upgrade my environment
15:21:27 <kadoban> rod_: If you want to use updated stuff, just install 'stack', that's the new and easy way to get stuff done. It can handle installing GHC for you as needed and handles dependencies and everything, it's quite nice.
15:21:44 <rod_> geekosaur, yeah i had a more advanced eeepc version with quad core n stuff and bigger screen ... it broke and now i am on my old 
15:22:30 <rod_> rootfs                                                  3,5G    3,3G  8,0K  100% /
15:22:30 <rod_> udev                                                     10M       0   10M    0% /dev
15:22:30 <rod_> tmpfs                                                   101M    684K  100M    1% /run
15:22:30 <rod_> /dev/disk/by-uuid/6efa4ce3-b69b-46e9-bc7b-2c501c7aec08  3,5G    3,3G  8,0K  100% /
15:22:30 <rod_> tmpfs                                                   5,0M       0  5,0M    0% /run/lock
15:22:30 <rod_> tmpfs                                                   242M       0  242M    0% /run/
15:22:37 <rod_> :(
15:23:23 <rod_> it only has 4G of internal ssd memory
15:23:52 <synergistics> What's the best way to map over something that stores two values? I have a Point2D data type that holds an "x" and a "y" value and in mapping over a point, transformations to both the x and y values are made.
15:24:09 <geekosaur> :t bimap
15:24:10 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
15:24:40 <synergistics> Oh!
15:24:45 * hackagebot multistate 0.7.0.0 - like mtl's ReaderT / WriterT / StateT, but more than one  contained value/type.  https://hackage.haskell.org/package/multistate-0.7.0.0 (lspitzner)
15:24:46 <dmj`> :t (&&&)
15:24:47 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:26:02 <rod_> kadoban, is stack like cabal only diffrent ... is it more advanced/newer/bugfixed ?
15:26:22 <kadoban> rod_: It's like cabal-install but better.
15:26:24 <synergistics> geekosaur: I'm guessing there's no general solution for mapping on different numbers of values? Like for three values, would you need a Trifunctor?
15:26:49 <geekosaur> Applicative, maybe?
15:26:49 <synergistics> I guess you could apply a list of functions to something
15:26:57 <johnw> synergistics: lens
15:27:33 <johnw> though you'd still need to define a version of 'both' for various numbers of arguments
15:27:36 <dmj`> > over both (+1) $ (1,1)
15:27:38 <synergistics> Well I thought applicative was more for functions that take multiple values and compute one thing, rather than multiple functions that take multiple values and each compute one thing
15:27:38 <lambdabot>  (2,2)
15:27:53 <mniip> :t both
15:27:54 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
15:28:08 <Zekka|Sigfig> Lens has good support for accessors that target multiple things, is what theyâre getting at afaik
15:28:12 <mniip> ah, a bitraversable traversal
15:28:15 <Zekka|Sigfig> `both` is a particular example of that
15:28:25 <synergistics> Ah I've never heard of lenses
15:28:30 <Zekka|Sigfig> (Although personally I think lens is kind of a sledgehammer for this problem)
15:28:53 <Zekka|Sigfig> Itâs not too hard to write a lens that maps over all three elements of a tuple, or all four
15:29:15 <Zekka|Sigfig> (such a lens is actually a Traversal or a Prism IIRC, but donât quote me)
15:29:46 * hackagebot generic-deriving 1.10.1 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.1 (ryanglscott)
15:29:51 <mniip> it can't be a lens
15:30:03 <synergistics> :t over
15:30:04 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:30:05 <Zekka|Sigfig> Pretty sure itâs a Traversal come ot think of it. Prism doesnât make much sense here
15:30:27 <mniip> you can't join multiple 'f b' together into an 'f s'
15:30:31 <Zekka|Sigfig> But this wonât mean anything to you unless you know stuff about lens, which you donât. The gist: Lens defines a bunch of types representing different stles of accessor
15:30:31 <mniip> without an Applicative constraint
15:31:06 <mniip> it is a traversal
15:31:22 <mniip> \c (a, b) -> (,) <$> c a <*> c b
15:31:31 <mniip> :: Traversal (a, a) (b, b) a b
15:31:59 <rod_> glguy, thank you for your help ... 
15:32:07 <rod_> i am going to bed 
15:32:16 <rod_> bye all
15:33:45 * mniip . o O ( \t c -> forwards . t (Backwards . c) )
15:35:11 <synergistics> So would I need to convert my Point2D to a tuple to use lens?
15:35:25 <mniip> no
15:35:34 <mniip> you can write a lens for your Point2D
15:35:44 <fr3tz0r> what are the differences between running Haskell IO programs that read and writes to textfiles on Linus vs Windows? On Windows the program works fine on Linux it does not. It seems like it sometimes meanwhile running the program cannot always access the textfile but sometimes it can and the operations are just read all the time. The file has fully read and write abilities 
15:36:08 <kadoban> Linus gets annoyed if you run programs on him I'm sure.
15:36:13 <mniip> fr3tz0r, case sensitivity?
15:36:55 <kadoban> fr3tz0r: Windows handles files being open multiple times differently from how linux does I believe, I don't particularly remember the details though.
15:36:59 <EvanR> fr3tz0r: also "text mode" file handles have different interpretations
15:37:10 <EvanR> and yeah you cant open the same file more than once
15:37:32 <EvanR> and also on any two systems linux or not the locale determines how the runtime reencodes stdio
15:37:45 <EvanR> which could differ
15:38:50 <synergistics> johnw: So acting as a getter, is "both" a lens that returns both parts of a data type?
15:39:18 <johnw> both is a traversal, not a lens
15:39:24 <johnw> in particular, it's a bitraversal
15:39:34 <synergistics> Hmm, ok
15:39:46 * hackagebot lambdacube-compiler 0.4.0.1 - LambdaCube 3D is a DSL to program GPUs  https://hackage.haskell.org/package/lambdacube-compiler-0.4.0.1 (CsabaHruska)
15:39:48 * hackagebot proxied 0.1.1 - Make functions consume Proxy instead of undefined  https://hackage.haskell.org/package/proxied-0.1.1 (ryanglscott)
15:39:55 <Zekka|Sigfig> lens and traversal are both types of accessor
15:39:57 <mniip> 1455838092 [02:28:12] <mniip> it can't be a lens 1455838128 [02:28:48] <mniip> you can't join multiple 'f b' together into an 'f s'
15:40:11 <johnw> so you could say:
15:40:12 <johnw> > (1,2) ^.. both
15:40:14 <lambdabot>  [1,2]
15:40:22 <Zekka|Sigfig> a lens is a traversal thatâs only allowed to peek at one thing. (or closer to the actual formulation, a traversal is a lens with a provision to peek at multiple things)
15:40:50 <mniip> a traversal is a lens whose functor has been loosened to an applicative :p
15:40:53 <fr3tz0r> mniip: some letters are actually "Big letters"
15:41:00 <johnw> > (1,2) & both .~ 3
15:41:01 <lambdabot>  (3,3)
15:41:28 <Zekka|Sigfig> mniip: An applicative is just a provision to peek at multiple things! Ho ho ho!
15:41:32 <mniip> no
15:41:47 <mniip> it's a way to combine results of multiple functor-ed values
15:41:52 <Zekka|Sigfig> mniip: Yeah, thatâs more specific, not less specific than what âapplicativeâ means
15:42:05 <Endofunctors> Is there any easier to use than cabal? Something like pip from python?
15:42:10 <Zekka|Sigfig> âa provision to peek at multiple thingsâ that is
15:42:11 <crough> Stack
15:42:16 <kadoban> Endofunctors: stack
15:42:22 <Zekka|Sigfig> since it assumes the context has something to do with peeking. (Which for lenses is true)
15:42:27 <Endofunctors> Does it automatically update your dependencies if you install new ones?
15:42:33 <mniip> Zekka|Sigfig, the best advice to understanding lens I could personally give,
15:42:44 <mniip> try implementing lens, view, and over
15:42:47 <Endofunctors> something like pip install requests --save
15:42:57 <mniip> like, look at the type, and try doing what it says
15:43:07 <Zekka|Sigfig> mniip: I actually implemented a lens library a while back in another language, originally according to Haskellâs formulation and then late rto a simpler one that didnât require HKT
15:43:22 <kadoban> Endofunctors: You should look up how it works, it's not the same model as how pip works, but it's pretty nice.
15:43:28 <Zekka|Sigfig> Iâm pretty familiar with Haskellâs formulation but Iâm trying to lie cutely in a way that will make it more learnable for newbies
15:43:37 <mniip> eh
15:43:41 <mniip> not a useful lie IMO
15:43:48 <Zekka|Sigfig> although like I said I think lens the library is basically a sledgehammer for accessor problems
15:43:52 <kadoban> Endofunctors: I say that not to be a jerk, just because I'm going to have a hard time remembering how pip works well enough to explain the differences.
15:44:08 <Endofunctors> No offense taken :)
15:44:22 <kadoban> :)
15:45:37 <mniip> Zekka|Sigfig, I was very bored once and started reimplementing lenses on a piece of paper,
15:45:48 <mniip> that's when I was like, wow, so this is what lens is all about
15:47:05 <Zekka|Sigfig> My actual intuition for lens is that itâs a bunch of different specializations of Profunctor p => p s t -> p a b, where a profunctor is a slighlty more general way to talk about mappings. (itâs a way to talk about things with fmappability properties similar to (->))
15:47:28 <Zekka|Sigfig> er, I may have gotten my s t/a b backwards, but the notion still applies
15:47:28 <mniip> right
15:47:32 <mniip> that's basically Iso
15:47:36 <kadoban> I keep meaning to look into lens more, but I never seem to get around to it.
15:47:41 <GGuy> does it make sense to have an instance for "Monad ()"?
15:47:42 <Zekka|Sigfig> you are turning a mapping into a small part of the structure into a mapping over the whole structure
15:47:48 <mniip> except we go for Star instead of (->)
15:48:01 <kadoban> GGuy: An instance of Monad for () ?
15:48:08 <johnw> GGuy: wrong kind
15:48:10 <kadoban> GGuy: The 'kind' isn't right.
15:48:35 <mniip> Zekka|Sigfig, yeah it goes p a (f b) -> p s (f t)
15:48:59 <Zekka|Sigfig> One of the fun ways to specialize that mapping is \a b -> (a -> f b), where f is Functor or Applicative â f is a context that usually describes a particular way of peeking
15:49:21 <Zekka|Sigfig> either peeking and ignoring the thing already inside or gobbling up the thing inside to produce elsewhere
15:49:21 <shachaf> That's what it is in lens, but it *should* be p a b -> p s t.
15:49:31 <mniip> welll
15:49:52 <mniip> it's that way because substituting p~(->) lines up with lens
15:50:00 <mniip> so you don't have to mess around with buncha newtypes
15:50:16 <Zekka|Sigfig> Well, interspersing an additional f on the right side of p still gets you a profunctor, right? Itâs just that (->) is already a profunctor a different way, and youâd have colliding instances
15:50:20 <shachaf> lens is that way because it unifies with the type of traverse.
15:50:25 <mniip> I do realize we can use a fancier profunctor instead
15:50:46 <Zekka|Sigfig> It never seemed that important whether we map into f b/f t vs b/t
15:51:02 <mniip> though,
15:51:36 <mniip> can you place a good enough restriction on p to guarantee what (p ~ Star f, Functor f) guarantees?
15:51:49 <mniip> or Applicative f, for that matter
15:52:55 <shachaf> You can can put exactly that constraint on p if you want.
15:53:04 <shachaf> Or, y'know, representability by f.
15:53:19 <mniip> well,
15:53:27 <shachaf> (forall f. Functor f => (a -> f b) -> s -> f t) and (forall p. Strong p => p a b -> p s t) are isomorphic, anyway.
15:54:16 <dedgrant> What are Strong and Star constraints here?
15:54:24 <deech> I'm probably missing something super-obvious but how do I get cabal/stack to show me continuous output like it did a couple of versions ago?
15:54:25 <mniip> :k Star
15:54:26 <lambdabot> Not in scope: type constructor or class âStarâ
15:54:38 <mniip> :t Data.Profunctor.Star
15:54:40 <lambdabot> (d -> f c) -> Data.Profunctor.Star f d c
15:55:10 <dedgrant> oic
15:55:23 <luigy> deech you probably weren't working a multi-package project previously ?
15:55:35 <shachaf> You probably want to use a Represenable profunctor, not Star.
15:56:52 <deech> luigy: I guess not. So there's no way?
15:57:17 <luigy> deech this is the related issue https://github.com/commercialhaskell/stack/issues/426
15:58:11 <luigy> hmm invoking your packages individually which is kind of blows? stack build package; stack build other-package
15:58:29 <mniip> shachaf, interesting
15:58:35 <deech> luigy: On the one hand, I kind of happy I wasn't missing something huge. :)
15:58:43 <deech> OTOH, sigh.
15:59:42 <luigy> indeed the behavior is not obvious :)
16:00:07 <mniip> shachaf, have you seen my feeble attempts at lensing btw :p http://lpaste.net/152598
16:01:32 <shachaf> What's the goal?
16:02:07 <mniip> I don't know, some excercise?
16:02:19 <mniip> learning via experimentation?
16:03:09 <shachaf> OK.
16:03:13 <shachaf> I've done lots of those.
16:03:31 <shachaf> For a good time p a b -> p s t
16:03:57 <hpc> data P a b s t = Terrible
16:04:51 <mniip> data Endocokmettoid i s o g r a m = b a c k s t a b
16:05:12 <dedgrant> luigy: (and deech) isn't this possibly a case where the async log streams might be recombined in different ways depending on the client need? is each process streamed to a different log that can be tailed or combined?
16:07:04 <nineonine> > "\x27"
16:07:06 <lambdabot>  "'"
16:07:21 <nineonine> > length "\x27"
16:07:23 <lambdabot>  1
16:07:48 <mniip> crazy, huh
16:08:03 <nineonine> is there a way to ignore that hex encoding and count everything like chars ?
16:08:19 <nineonine> > length $ show "\x27"
16:08:20 <lambdabot>  3
16:08:21 <dedgrant> > "\\x27"
16:08:23 <lambdabot>  "\\x27"
16:08:42 <dedgrant> > length "\\x27"
16:08:43 <lambdabot>  4
16:08:57 <dedgrant> > head "\\x27"
16:08:59 <lambdabot>  '\\'
16:09:11 <geekosaur> nineonine, the hex encodiing is used in string literals (including those read by `read` and generated by `show`)
16:09:29 <nineonine> and if i have smth like "\x27abc\x28"
16:09:44 * mniip . o O ( show ever produces hex? )
16:10:02 <geekosaur> if it's a string literal then they are translated by the compiler. if it's a string you got e.g. over the network then they are not translated
16:10:18 <nineonine> if i get it from file ?
16:10:30 <nineonine> it will be string literal, right ?
16:10:34 <mniip> then you get the backslash symbol in your string
16:10:35 <geekosaur> same, unless you're using `read` :: String -> String
16:10:59 <geekosaur> er, without the `` there
16:12:08 <nineonine> > show "\x27"
16:12:09 <lambdabot>  "\"'\""
16:13:03 <nineonine> > :t "\x27"
16:13:05 <lambdabot>  <hint>:1:1: parse error on input â:â
16:13:19 <nineonine> :t "\x27"
16:13:20 <lambdabot> [Char]
16:13:42 <nineonine> is there any function to detect those hex encodings in strign literals ?
16:14:40 <dedgrant> nineonine: That would be a very triccky problem. Simple case, if I have two characters, literally '//', is tht two slashes, or one?
16:15:22 <geekosaur> did you mean \\ ?
16:15:35 <dedgrant> Yes I did sorry :) Also, I cannot type
16:15:46 <geekosaur> in any case, by the time the program sees it, the compiler has long since translated it
16:16:22 <mniip> something tells me you don't understand the distinction between string data and string representation in code/show/read
16:17:44 <geekosaur> > chr 92:chr 120:chr 50:chr 55:[]
16:17:45 <lambdabot>  "\\x27"
16:17:49 <Sourcent_> /clear/clear
16:17:56 <Sourcent_> Oops. Sorry.
16:18:23 <mniip> > text $ chr 92 : []
16:18:25 <lambdabot>  \
16:19:42 <nineonine> someone on Starckoverflow mentioned that you can distinguish between string and
16:19:50 <nineonine> "raw" string so to speak
16:19:56 <nineonine> eg prepending @ in C#
16:19:58 <nineonine> source -> http://stackoverflow.com/questions/3792267/haskell-do-literal-backslashes-always-have-to-be-escaped-in-a-string
16:21:11 <EvanR> this sort of thing makes strings so much worse as data for soemthing
16:21:25 <EvanR> its using itself as a carrier for meta encoding
16:21:42 <nineonine> but in terms of implementation this desn't seem to be tricky
16:21:44 <EvanR> this is not lisp
16:21:52 <EvanR> we can do better
16:24:15 <nineonine> so is there a way to get the length of the actual string literal, not its representation in memory ?
16:24:34 <nineonine> so length "\x27" = 6
16:24:36 <geekosaur> ...
16:25:20 <hpc> > length (show "\x27")
16:25:21 <lambdabot>  3
16:25:41 <hpc> > "\x27"
16:25:42 <lambdabot>  "'"
16:25:53 <hpc> > length (show "\x275")
16:25:54 <lambdabot>  6
16:26:03 <hpc> > "\x275"
16:26:04 <lambdabot>  "\629"
16:26:13 <hpc> nineonine: sort of
16:26:51 <nineonine> how then ?
16:26:53 <nineonine> :)
16:26:56 <EvanR> unless youre processing raw haskell source 
16:27:13 <EvanR> you might want to make your own encodable string type / newtype
16:27:48 <EvanR> because haskell literals have a ton of features
16:45:05 <dedgrant> nineonine: As far as I know there is no specifically targeted verbatim string notation in GHC, but Template Haskell quasiquotes should do what you need-- they are rather more complicated than what you're expecting I think.
16:45:36 <nineonine> will take a look into it
16:45:38 <nineonine> thanks !
16:46:47 <dedgrant> nineonine: Or maybe it's already simpler than I thought?  http://www.rosettacode.org/wiki/Literals/String#using_raw-strings-qq_package
16:46:53 <dedgrant> huh
16:47:30 <dedgrant> caveat emptor.. this is not familiar territory
16:48:57 <nineonine> that looks interesting
16:49:04 <nineonine> might be exactly what I want !
16:51:49 <nineonine> yay !! that wokred !!!
16:51:52 <nineonine> many thanks ^_^
16:52:28 <nineonine> length [|\x27|] gives me 4
16:52:30 <nineonine> awesome
16:52:52 <dedgrant> Yay (...he says warily). Interpreting escapes is tricky to begin with, and this is a form of escaping to avoid escaping. (Not unlike @ in C#.)  There may be some unexpected consequences with certain strings.
16:55:52 <nineonine> I will be very cautious %)
16:56:25 <dedgrant> heh
16:56:49 <nineonine> btw can I somehow refer to some bindings inside quasiquotes ?
16:56:58 <nineonine> let a = "123"
16:57:08 <nineonine> [r| a|]
16:57:14 <nineonine> like that
16:59:26 <dedgrant> It doesn't do that.  See: http://hackage.haskell.org/package/raw-strings-qq-1.0.2/docs/src/Text-RawString-QQ.html#r
16:59:40 <dedgrant> Specifically: quoteExp  = return . LitE . StringL
17:04:38 <dedgrant> How about ([r|123|] ++ [r|etc...|])?
17:05:44 <montanonic> bitemyapp: http://bitemyapp.com/posts/2014-12-03-why-are-types-useful.html
17:05:55 <montanonic> bitemyapp: "In practice, inheritance is easy to abuse though.'In practice, this car may explode'"
17:06:03 <montanonic> I lol'd so hard at that.
17:06:05 <montanonic> Thank you.
17:15:32 <fr33domlover> In a RESTful web app, I want /user/new to GET a user registration form, and the input should be PUT to e.g. /user/john . But how do I make the action URL of the form variable i.e. contain the username?
17:15:44 <fr33domlover> (I'm using Yesod)
17:16:45 <fr33domlover> I could POST the form input to /user/new easily, but that isn't exactly RESTful
17:18:19 <dramforever> Yeah it's not RESTful, but neither is /user/john iirc. You are supposed to just post to /user/ and let the server redirect
17:18:53 <mick_> Hi
17:19:17 <dramforever> there's a rule like "POST to a collection -> create a new resource in the collection"
17:20:06 <mick_> hi
17:20:30 <dramforever> mick_: just ask your question, people will respond if they are able to
17:22:11 <fr33domlover> dramforever, i want to PUT to /user/john
17:22:26 <fr33domlover> which means update john, or create if doesn't exist
17:22:35 <EvanR> you said rest...
17:22:43 <EvanR> thats not how its supposed to work
17:22:46 <mick_> There's been a lot of debate in the Scala community recently over Dotty vs Scala. To me it seems that Typesafe have realised the type system is a big mess in Scala and so are revamping it from ground up using Dot Calculus. This is a fundamental change and will break existing systems when these changes are moved over to Scala. Understandably this has pissed off alot people. My question is what has been the biggest upset (if e
17:23:19 <johnw> please update me, or create me if I don't exist
17:23:25 <fr33domlover> EvanR, then how is it supposed to work? I read in the Yesod book and in Wikipedia
17:23:39 <EvanR> "My question is what has been the biggest upset (if e"
17:23:50 <EvanR> fr33domlover: like dramforever said, post to /user
17:23:55 <mick_> My question is what has been the biggest upset (if ever) in Haskell's history?
17:24:18 <dramforever> fr33domlover: if you want to make the form also do updates, just change the url and method of the form
17:24:46 <dramforever> post /user/ -> new user
17:24:59 <dramforever> put /user/john -> update john
17:25:01 <EvanR> to update john if he exists you would have had to get the form from /user/john which wouldve had to exist already
17:26:31 <fr33domlover> dramforever, EvanR, thanks. So I can use POST. But how would I implement a RESTful PUT? i.e. create or update /user/john by PUTing to it?
17:26:42 <EvanR> you dont do create or update
17:26:54 <EvanR> you have to decide by choosing where to get the form from
17:27:12 <montanonic> mick_: that's an interesting question; I'm quite new to the language (< 8 months with it), but it doesn't really seem like the language has gone through something like that.
17:27:18 <montanonic> Granted, it is several decades old.
17:27:26 <EvanR> yeah scala has some issues going on
17:27:35 <dramforever> that's strange for a RESTful app, but I could be wrong...
17:28:23 <EvanR> you have to know what resource youre updating if updating, by querying for it first
17:28:39 <crough> montanonic, mick_: Foldable/Traversable made a lot of people angry.
17:28:46 <EvanR> then you get the "state representation" to update it
17:28:50 <EvanR> which is a put
17:28:59 <fr33domlover> EvanR, both the Yesod book and Wikipedia say: Update the resource, or create if doesn't exist
17:29:07 <EvanR> you can do anything you want
17:29:21 <dramforever> I think quite a number of issues of Haskell are left largely unresolved so far, but things are improving
17:29:26 <fr33domlover> I just wonder how the create part would work
17:29:48 <EvanR> just saying its not coinciding with "rest" dogma
17:30:06 <dramforever> For example, people have been waiting for proper tooling for really long
17:30:17 <mick_> Yeah, my point is that the industry was quick to jump onto the Scala bandwagon with little thought on whether this language was suitable for adoption. It's only until people started using it in anger did the warts present themselves (just look at the bug count).
17:30:56 <EvanR> levity revolution!
17:31:02 * EvanR rages
17:31:05 * EvanR flips cars
17:31:19 <johnw> mick_: nearly every language goes through that
17:31:28 <johnw> how do you get users to find the warts until you've had users find the warts?
17:31:36 <mick_> crough : what happened there? I'm new to Haskell (4 months old)
17:31:44 <montanonic> crough: that's interesting. I'd like to know too. 
17:31:52 <dramforever> And nobody seemed happy to throw away post.author.name and write userName (postAuthor post)
17:32:18 <crough> mick_, montanonic: basically, functions in the prelude didnât used to be defined in terms of Foldable and Traversable
17:32:18 <mick_> dramforever : tooling is one thing but if your type system is busted then that is a whole different ball game
17:32:49 <EvanR> :t forM_
17:32:50 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
17:32:52 <crough> mick_, montanonic: but everyone was using it and it gave us some really nice idioms. However, a bunch of people *HATE* that things like:
17:32:57 <mick_> ok crough
17:32:58 <crough> > length (1, 2)
17:33:00 <lambdabot>  1
17:33:11 <EvanR> lol wut
17:33:15 <crough> > length (Right True)
17:33:17 <lambdabot>  1
17:33:19 <mick_> but still i would say that is not as severe as having a busted type system
17:33:43 <EvanR> mick_: the foldable traversable thing was really a gripe over what type sigs look like for beginners
17:33:47 <crough> mick_: Oh yeah, I actually donât think itâs bad at all but people still regularly fight about this
17:34:01 <EvanR> but wait until levity!
17:34:02 <montanonic> Interesting. I didn't realize.
17:34:05 <crough> > Length Nothing
17:34:06 <lambdabot>      Not in scope: data constructor âLengthâ
17:34:06 <lambdabot>      Perhaps you meant one of these:
17:34:06 <lambdabot>        variable âlengthâ (imported from Data.List),
17:34:13 <crough> > length Nothing
17:34:14 <lambdabot>  0
17:34:15 <crough> (oops)
17:34:20 <crough> > Length (Just 100)
17:34:22 <lambdabot>      Not in scope: data constructor âLengthâ
17:34:22 <lambdabot>      Perhaps you meant one of these:
17:34:22 <lambdabot>        variable âlengthâ (imported from Data.List),
17:34:25 <crough> > length (Just 100)
17:34:27 <lambdabot>  1
17:34:37 <EvanR> Maybe is like a list of length 0 or 1
17:34:43 <EvanR> whats the problem!
17:34:55 <johnw> > length Nothing
17:34:56 <crough> Ha, the problem is when you go back to product types that are foldable
17:34:56 <lambdabot>  0
17:34:59 <johnw> yeah, I don't see the issue
17:35:07 <crough> like tuplesâ¦ people tend to get uppity about those :)
17:35:16 <crough> > length (1, 5)
17:35:17 <lambdabot>  1
17:35:26 <EvanR> how does that even work ;)
17:35:29 <dramforever> OTOH why will you ever get the length of a tuple
17:35:41 <dramforever> > toList (1, 5)
17:35:42 <lambdabot>      Ambiguous occurrence âtoListâ
17:35:43 <lambdabot>      It could refer to either âData.Foldable.toListâ,
17:35:43 <lambdabot>                               imported from âData.Foldableâ at /tmp/mueval124...
17:35:44 <johnw> and of course, they always use a tuple with two members of the same type
17:35:49 <johnw> > length ("Hello", 5)
17:35:51 <lambdabot>  1
17:35:59 <johnw> such a tuple has a 1 Int in it
17:36:00 <EvanR> numbers are foldable O_O ?
17:36:09 <crough> Nope, tuples are
17:36:13 <EvanR> why?
17:36:14 <crough> With the right value
17:36:18 <crough> Just like 
17:36:21 <mick_> The Functor-Applicative-Monad Proposal maybe a biggie
17:36:26 <crough> > fmap not (1, False)
17:36:27 <lambdabot>  (1,True)
17:36:28 <dramforever> > Data.Foldable.toList (1, 5)
17:36:29 <lambdabot>  [5]
17:36:34 <mick_> but even then it was a positive change IMHO
17:36:37 <EvanR> mick_: nah... that makes sense
17:36:53 <dramforever> mick_: not exactly a car flipping change IMHO
17:36:56 <crough> Once again, I was very pro Foldable/Traversable
17:37:02 <mick_> lol
17:37:06 <EvanR> maybe if fail is deleted, thatll start the process of fixing the profusion of error monadss
17:37:13 <crough> but this thing comes up quite a bitâ iâm just echoing the naysayers 
17:37:16 <dramforever> it'a just because Monad came before Applicative
17:37:22 <mick_> yep
17:48:37 <Ralith> Is there a cleaner way to ensure a computation is performed fully in some thread than running evaluate . force in that thread before passing it out?
17:48:49 <EvanR> cleaner than what
17:49:01 <EvanR> oh evaluate .force
17:49:04 <alkabetz> Ralith: deepseq?
17:49:07 <EvanR> deepseq
17:49:15 <Ralith> force is deepseq.
17:49:57 <EvanR> there might be a higher performance way, but it wont be clean
17:50:00 <alkabetz> IIRC some of the data-parallelism libraries have mechanisms to automate running deepseq in the appropriate places; have you looked at those?
17:50:17 <EvanR> make sure you use bang or seq during the construction of the object instead of waiting until later to depseq
17:50:32 <alkabetz> Ralith: Iâm thinking of https://hackage.haskell.org/package/parallel in particular.
17:50:59 <Ralith> alkabetz: I'd rather use deepseq directly, tbh
17:51:59 <EvanR> or strict ctors
17:52:07 <alkabetz> Ralith: What exactly about 'evaluate . force' makes you unhappy?
17:53:15 <Ralith> alkabetz: I guess I just feel like I should be doing something like EvanR's describing (and thereby save excess tree walking and remove dependency on NFData), but I haven't had much success attempting that.
17:53:49 <EvanR> whats the problem
17:54:26 <Ralith> I just don't have enough experience dealing with explicit strictness
17:54:30 <Ralith> I'll probably get it eventually if I keep at it
17:54:56 <Ralith> I'm also not totally clear on when evaluate is necessary
17:55:04 <EvanR> BangPatterns, strict fields, etc
17:55:54 <Ralith> right
17:55:56 <EvanR> evaluate lets you cause evaluate between two IO actions
17:56:02 <EvanR> cause evaluations
17:56:10 <Ralith> I have read the documentation, yes
17:56:37 <EvanR> so if evaluating would crash, you can use it to cause the crash to happen at a particular point
17:56:50 <EvanR> it sucks if that is whats gonig on though
17:56:52 <dedgrant> crough: Strongly implying a structural meaning by relating (e,a), Either e a, Maybe a and [a] has been rather contentious, because it stymies teh effectiveness of common (informal) language. The argument over common language shouldn't be surprising especially as the nunmber of voices grows.. there's always the question of exhaustion and diplomacy.
17:57:43 <EvanR> its much nicer when pure code doesn't crash
17:58:01 <Ralith> nothing is crashing.
17:58:02 <EvanR> and to crash in IO you use IO exceptions
17:58:14 <Ralith> I'm trying to force computation to happen in a particular thread.
17:58:16 <EvanR> if you always have NF values, you dont need evaluate
17:58:36 <Ralith> then how do I ensure something is evaluated before passing it out of the thread?
17:58:46 <Ralith> oh, I gues seq $ pure would work fine
17:58:59 <EvanR> bang patterns, seq, strict fields
17:59:23 <EvanR> or -XStrict ;)
17:59:41 <montanonic> Ralith: you can also use ($!)
17:59:46 <montanonic> or is it (!$)?
18:00:09 <montanonic> anyways, that's just strict function application, so if you wanted to write, \x -> pure $! x
18:00:12 <montanonic> instead of using seq
18:06:24 <EvanR> montanonic: or \!x -> pure x
18:06:56 <montanonic> Oh yeah! Good stuff. Does that work in do notation? Can you bind to strict vars?
18:07:29 <montanonic> do { !x <- pure blah; return x } ?
18:07:54 <EvanR> yes
18:07:59 <montanonic> swaaank
18:09:24 <EvanR> i like my values shaken not strict
18:20:25 <Lokathor> i was just thinking of that myself
18:20:41 <Lokathor> i've got a strict smart constructor, and i'm thinking maybe it doesn't have to be strict
18:23:02 <montanonic> Can someone explain to me why `State s a` returns an `(a, s)`?
18:23:12 <montanonic> I have always thought that (s, a) makes more sense
18:23:37 <montanonic> especially in terms of, for example, Functors, in which case `a` seems like the more appropriate value to map over, is it is the return value
18:24:02 <EvanR> > fmap (+1) (1,1)
18:24:03 <lambdabot>  (1,2)
18:24:06 <montanonic> s/is it is/as it is
18:24:54 <EvanR> > fmap (+1) (return 4 :: State Int Int)
18:24:55 <lambdabot>      No instance for (Show (StateT Int Identity Int))
18:24:56 <lambdabot>        arising from a use of âshow_M39941572022020454027601â
18:24:56 <lambdabot>      In the expression:
18:25:36 <montanonic> > fmap (+1) $ runState (return 4 :: State Int Int) 0
18:25:38 <lambdabot>  (4,1)
18:25:45 <EvanR> you dont have to worry because State is not a tuple at all its StateT something ;)
18:26:04 <montanonic> EvanR: right, I know that State s m a behaves that way
18:26:10 <montanonic> in that case, `a` is mapped over
18:26:20 <montanonic> that's why I'm confused by why it's return value would invert that
18:26:29 <montanonic> and make `s` the value that's mapped over
18:28:19 <GGuy> given we have sequence and sequence_ would it make sense to have a sequenceMonoid = foldr (\m m' -> do { x <- m; xs <- m'; return (x `mappend` xs) }) (return mempty)?
18:28:36 <EvanR> :t foldMap
18:28:37 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:29:46 <EvanR> im not sure that sequenceMonoid makes any sense as written
18:32:30 <EvanR> montanonic: where is it being mapped?
18:32:52 <montanonic> I mean that, if you fmap over a state, you alter the return value
18:33:11 <montanonic> if you fmap over the result of runState, you map over the state value
18:33:22 <EvanR> yes they are two different types
18:33:31 <montanonic> mapping in terms of the Functor instance of Tuples vs the Functor instance of a State monad
18:33:39 <EvanR> Functor (State s), Functor (e,)
18:33:49 <montanonic> I would just expect there to be uniformity is all
18:33:57 <EvanR> how is it not uniform?
18:34:27 <montanonic> fmap (a -> b) (State s a) = State s b
18:34:35 <EvanR> er
18:34:49 <EvanR> fmap :: (a -> b) -> State s a -> State s b
18:34:52 <montanonic> fmap (a -> b) (runState (State s a) s) = nope
18:35:01 <montanonic> (sorry, psuedocodeing it up)
18:35:16 <EvanR> thats an odd requirement
18:35:34 <montanonic> but if `runState (State s a) s` return (s,a) instead, it would be uniform
18:36:17 <montanonic> Yeah, I'm more just trying to understand the motivation of always having state monads return (a, s) values
18:36:24 <EvanR> i think of the state as being secondary, but i guess the choice of return value of run is arbitrary
18:36:32 <montanonic> It seems to me to be mostly just arbitrary
18:36:36 <montanonic> yeah, okay, I'm fine with that
18:36:51 <EvanR> the choice of fmapping over tuples isn't, it has to be the second term
18:37:42 <EvanR> the implementation of State as either (a,s) or (s,a) or something else is also arbitrary
18:37:46 <mattn> does anybody have experience with llvm-general on OS X?
18:38:22 <montanonic> EvanR: okay; thanks; that just assures me that there's no hidden magic reason why it's always implemented as (a, s)
18:38:33 <EvanR> its not ;)
18:40:54 <GGuy> EvanR: sequenceMonoid [Just [1],Just [2]] == Just [1,2]... is there something wrong with the definition above?
18:42:39 <EvanR> GGuy: you said x <- m, xs <- m'
18:42:50 <EvanR> but the second one wont get "the rest", just the second
18:42:59 <EvanR> in whatever monad
18:43:16 <EvanR> x <> xs doesnt imply anything sensible
18:43:51 <GGuy> oh yes, sorry m'
18:44:23 <EvanR> can you write the type sig of sequenceMonoid?
18:45:37 <GGuy> sequenceMonoid :: (Monad m, Foldable t, Monoid t1) => t (m t1) -> m t1
18:46:03 <EvanR> @djinn (Monad m, Foldable t, Monoid t1) => t (m t1) -> m t1
18:46:03 <lambdabot> Error: Class not found: Foldable
18:46:29 <geekosaur> :exf (Monad m, Foldable t, Monoid t1) => t (m t1) -> m t1
18:46:32 <EvanR> yeah im just not sure doing pairs of monad actions and combining them makes much sense
18:46:40 <exferenceBot> \ a -> pure (fold (a, mempty))
18:46:47 <EvanR> :t liftM2
18:46:48 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:47:17 <EvanR> oh a more powerful bot
18:51:28 <GGuy> I guess it'd be similar to a "mconcat <$> sequence"
18:52:33 <EvanR> i dont see the point of the accumulator being monadic
18:52:42 <EvanR> its always of the form return x
18:52:53 <EvanR> that threw me off
18:55:23 * hackagebot graphmod 1.2.9 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.2.9 (IavorDiatchki)
18:59:21 <Ralith> How do you install gtk2hs on windows with stack?
19:00:54 <Ralith> I get errors about pkg-config not existing
19:07:13 <pavonia> Ralith: You have to install pkg-config first
19:07:44 <Ralith> pavonia: ...on a windows host, in a DOS shell?
19:07:59 <Ralith> isn't stack supposed to wrap all that stuff up in an internally-managed msys instance?
19:08:03 <pavonia> Yep, using MinGW or Cygwin
19:08:40 <pavonia> I don'T know stack well enought, but I don't think it can handle all that kind of external programs
19:09:48 <Ralith> pavonia: stack certainly manages the mingw stuff itself, I don't really see any way to get access to it...
19:10:38 <dgpratt> in an expression like "[1, 2.0]", how does type inference work out the type?
19:10:55 <DogCat> any have experience loading about 50 Mb into a Data.Map.Lazy structure?
19:11:09 <DogCat> I'm doing it for work, and it seems really slow
19:11:20 <DogCat> I'm wondering if there is a better alternative
19:11:23 <DogCat> thanks!
19:12:31 <dmj`> DogCat: can you paste your code
19:12:55 <EvanR> you can load the ByteString first, strictly, then create the lazy structure from it
19:13:37 <anohigisavay> how to implement a mapM for HashMap?
19:13:50 <anohigisavay> mapM :: (a -> m b) -> HashMap k a -> m (HashMap k b)
19:14:56 <EvanR> do you want to traverse a hashmap?
19:15:15 <EvanR> :t mapM
19:15:16 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
19:15:23 <DogCat> :dmj`, not easily(we're closed source, atm) I should make this into a reproducible example
19:15:48 <anohigisavay> EvanR: by all means xD
19:15:57 <EvanR> anohigisavay: its already traversable ...
19:17:01 <anohigisavay> EvanR: _(:Ð·ãâ )_ silly me
19:17:11 <EvanR> lol
19:17:11 <anohigisavay> EvanR: Thanks :D
19:17:14 <DogCat> but it sort of looks like this:  dataBeforeMap :: [(Obj.Int,  Day, Maybe Dobule)] <- liftIO fromResultSet getRows
19:18:36 <DogCat> then something liek this : let table' = toValue . fmap toValue . fmap2 mkFloat $ dataBeforeMap
19:19:20 <mattn> anybody know how I can make a stack build on OS X see a keg-only dylib installed by homebrew?
19:19:27 <taktoa> anyone know why parseTest (from trifecta) might hang on invalid input?
19:19:56 <taktoa> this is the source https://github.com/taktoa/mltt/tree/parser
19:19:59 <Ralith> pavonia: yeah, stack explicitly already installs its msys2 somewhere apparently private
19:20:11 <taktoa> specifically: library/MLTT/Parser.hs
19:20:17 <Ralith> anyone here use stack on windows? any idea how to get at its environment?
19:20:17 <automata_> What's <*> function called?
19:20:36 <taktoa> automata_: "ap" I think?
19:20:47 <DogCat> :t (<*>)
19:20:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:20:53 <pavonia> Ralith: Okay, I didn't know that
19:20:59 <DogCat> :t (<$>)
19:21:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:21:06 <taktoa> :t ap
19:21:08 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:21:08 <EvanR> theres also an ap function
19:21:21 <automata_> <$> is infix fmap right?
19:21:23 <EvanR> better not try to pronounce haskell ;)
19:21:27 <taktoa> automata_: yes
19:21:59 <DogCat> (Just (\x -> x + 1)) `ap` (Just 4) 
19:22:07 <automata_> Why doesn't monad just use <*> instead of ap?
19:22:07 <DogCat> :t (Just (\x -> x + 1)) `ap` (Just 4) 
19:22:08 <lambdabot> Num b => Maybe b
19:22:22 <automata_> Isn't monad a subclass of applicative functor?
19:22:23 <EvanR> hysterical raisins
19:22:50 <taktoa> I think it would probably we acceptable to pronounce (<*>) as ap when talking about an Applicative that is also a Monad
19:22:52 <taktoa> *be
19:22:54 <DogCat> it's an endofunctor in the category Hask...
19:23:41 <Guest6991> Hi, I'm considering to use Wires for my game because I'm facing really hard issues to deal with in Haskell.
19:23:41 <mattn> ah, seems like my stack/dylib issue has to do with OS X intentionally not passing certain environment variables to child processes: https://github.com/commercialhaskell/stack/issues/1161
19:23:42 <EvanR> the list of endofunctors on hask is very lon g;)
19:23:47 <geekosaur> automata_, Monad and is ap predate Applicative by something over a decade
19:23:56 <geekosaur> *its ap
19:24:01 <Guest6991> Are wires based on time too, as much ac FRP ?
19:24:22 <EvanR> wires? netwire?
19:24:25 <taktoa> Guest6991: are you talking about Wires from the library "netwire"?
19:24:35 <Guest6991> I don't feel enthusiant about FRP, but the idea of chaining wires for a cascading events would be great I think.
19:24:39 <Guest6991> yes, netwire
19:24:44 <Guest6991> Let me fix that nick
19:25:11 <nitrix> there :)
19:25:35 <DogCat> :nitrix, what's your concern with FRP?
19:26:19 <nitrix> DogCat: My understanding is that the main driving thing in FRP is time. I feel like my game has very little going on without the using adding entropy.
19:26:29 <nitrix> *user 
19:26:38 <EvanR> so maybe reactive banana is better
19:26:41 <nitrix> It's almost all event user driven :/
19:26:56 <rcyr> I thought that Reflex was the way to go for FRP
19:27:06 <nitrix> I don't even understand why I'd want FRP.
19:27:21 <Cale> nitrix: Well, "time" can mean a lot of things. Reflex's notion of time is particularly abstract -- it must be totally ordered, but that's pretty much it.
19:27:32 <DogCat> yea, I'm not seeing the clear the clear use case for it...
19:27:55 <nitrix> On the other hand, netwire feels more like pipes from what I've seen.
19:28:04 <EvanR> nitrix: time usually creeps into sufficiently complex desktop apps
19:28:14 <taktoa> nitrix: do you mean the library "pipes" or just unix pipes
19:28:17 <EvanR> progress bar, animation... dialog that has a lifetime
19:28:21 <nitrix> taktoa: The library pipes
19:28:45 <EvanR> if its just handling events then you might not need anything
19:29:02 <nitrix> EvanR: It's a isometric 2d game.
19:29:18 <Cale> Well, FRP is pretty good whenever you have a lot of state which needs to remain up to date, and which changes in response to other bits of state. It's a nice way to organise your program in a way that you can't miss updates, and you get to let the library handle propagation of changes.
19:29:33 <taktoa> speaking of which, does anyone know if there's a library that is like pipes-attoparsec, except it uses the "parsers" typeclasses
19:29:38 <Cale> Games tend to have a fair amount of that.
19:30:01 <nitrix> Cale: EvanR: Mind if I show you what I've got so far and what the problems are?
19:30:10 <Ralith> also, how do I get stack to build dependencies in parallel?
19:30:15 <Ralith> I've got a 12 core machine here and it's using 1 :/
19:30:17 <EvanR> lets see the goods
19:31:14 <nitrix> So far, I think I've done good to keep the code super clean and idiomatic. 
19:31:15 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Main.hs
19:31:19 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Game.hs
19:31:42 <taktoa> I find the fact that conal just missed the discussion of FRP amusing
19:31:45 <Cale> (On the other hand, our tutorial materials and documentation for reflex are still a bit thin, so especially if you're a relative beginner to Haskell, it might be a bit overwhelming for a good while.)
19:32:28 <nitrix> Then, I started to work on having actual objects in the game, and, so, you think one big Object record and you add and add and add thing, then you realise not every objects uses all the fields, and also the functions all look like :: Object -> Object and doesn't give much insight on what's going on.
19:32:43 <nitrix> So I scratched my head a little bit and came up with this very clever thing:
19:32:59 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Object/Box.hs
19:33:20 <Tendies> do list comprehensions count as recursion :O
19:33:31 <EvanR> nitrix: so youre trying to have separate types for each kind of game object
19:33:40 <Cale> Tendies: not usually
19:33:43 <EvanR> that might get to be a burden
19:33:54 <nitrix> Notice how all the Box operations are typed as such, and then there's this :: Box -> Object function that traps the box in a closure to allow future updates.
19:33:59 <Cale> Tendies: Though it depends on how deeply you look into them./
19:34:25 <Tendies> man i got my game on with list comps and havent used plain old recursion at all
19:34:28 <EvanR> ah yeah, the OOP hiding patterns
19:34:36 <nitrix> EvanR: Having one Object type for all possible objects is equally bad imo.
19:34:39 <Cale> Tendies: list comprehensions use concatMap, which is ultimately implemented using recursion (if not immediately, then one of the things it's made from will be).
19:35:13 <Tendies> ah i think my prof wont be getting that specific, so ill try and just convert what i've got
19:35:26 <EvanR> nitrix: so... it might make more sense to not have either... instead you could split up all the aspects of objects into equally handling/managing bins, sort of like looking at the whole problem at 90 degrees...
19:35:39 <EvanR> in another dimension ;)
19:36:00 <nitrix> EvanR: So anyway, this is what I have. It works, I can send messages to objects, I can have objects that are connected to various functions that handles the object in specific manners, it keeps states and stuff, it works... but...
19:36:01 <Tendies> does this look correct for determining if one list is a subset of another
19:36:17 <EvanR> in oop you try to put all functionality of all objects in one place, and some functionality doesnt make sense for some things so you have null checks and such
19:36:32 <EvanR> but it can be decomposed and regrouped
19:36:52 <Tendies> > let fn xs ys = [ x `elem` ys | x <- xs ] where xs = [1,2,3], ys = [1,2,3,4,5,6,7]
19:36:54 <lambdabot>  <hint>:1:60: parse error on input â,â
19:36:54 <nitrix> EvanR: But the problem is, one object doesn't have access to the whole world game state. So now I'm thinking, maybe the object should receive messages and return a list of messages, then I can have something at a higher level (in the StateT monad) do the actual transformations.
19:37:01 <Tendies> > let fn xs ys = [ x `elem` ys | x <- xs ] where xs = [1,2,3] ys = [1,2,3,4,5,6,7]
19:37:03 <lambdabot>  <hint>:1:64: parse error on input â=â
19:37:22 <DogCat> yea, in OOP you are also unable to express the core pattern idiom using the language itself, and must relay on "Design Patterns" of accepted composition...
19:37:26 <Tendies> dammit
19:37:46 <EvanR> nitrix: sounds like its getting complex
19:37:54 <Tendies> > and [x `elem` [1,2,3,4,5,6,7] | x <- [1,2,3]]
19:37:56 <lambdabot>  True
19:37:58 <geekosaur> Tendies, lambdabot is not ghci
19:38:13 <EvanR> nitrix: how about allowing access to the world state everywhere?
19:38:21 <geekosaur> you can't use do-style let, nor can you use `where` which is part of declaration syntax
19:38:52 <Tendies> cale used it last night i am pretty sure, but anyway is the function i just typed agreeable as finding if xs is subset of ys
19:39:21 <geekosaur> > let fn xs ys = [ x `elem` ys | x <- xs ]; xs = [1,2,3]; ys = [1,2,3,4,5,6,7] in fn xs ys
19:39:23 <lambdabot>  [True,True,True]
19:39:53 <EvanR> nitrix: another way is, for any feature which needs to access datasets X Y and Z, then make that its own module, and give it access to those parts of the data (all of it)
19:40:11 <nitrix> EvanR: I like the idea that objects can message other objects. The problem is, what if I have some sort of game mechanic that are a limited storage; by using message passing, I wouldn't be able to know if I can add one more item to that storage before it's too late.
19:40:15 <geekosaur> cale may have used @let, which adds a declaration to a sort of custom prelude for the bot (and gets wiped periodically)
19:40:27 <nitrix> EvanR: The message would be sent and I cannot wait for the response.
19:40:29 <Tendies> oh i see
19:40:33 <geekosaur> s/periodically/occasionally/
19:40:37 <EvanR> yes message passing is quite complex
19:40:42 <Cale> What did I use?
19:40:50 <Cale> oh, @let
19:41:29 <EvanR> nitrix: for example if you have this thing "objects can be in objects", then you can support this in the containment code which has access to all containment data (a Map of containment relationships)
19:41:32 <nitrix> EvanR: But lets say I figure this out, there's the remaining issue of saving and loading the world; which means serialization. I can easily have the objets serialize themselves with a message...
19:41:39 <nitrix> I can't do the deserialization though.
19:41:40 <EvanR> containment being its own thing
19:42:23 <nitrix> I'd need to give the objects some kind of ObjectType... at which point, I end up with a glorified sum type...
19:42:37 <EvanR> objects serializing them selves is a oop thing...
19:42:42 <ggVGc> I think I asked this before, but what do I gain by having a function like FooState -> Action -> FooState, where Action can be various instances of an ADT, instead of having multiple functions of FooState -> FooState where each of them does an action
19:42:51 <nitrix> data Object = Table CommonData TableData | Chair CommonData ChairData | ...
19:42:53 <EvanR> if you have it split up into data sets, you can serialize it all together
19:42:55 <ggVGc> I forgot the answer, and now I'm in the same situation again
19:42:58 <ggVGc> and can't decide
19:43:02 <EvanR> by putting the N (different) sets together
19:44:11 <asnell> so with GHC 8 i can use DuplicateRecordFields and defined my types with the same fields...but how to I use (disambiguate) the field?
19:44:34 <EvanR> ggVGc: at least do Action -> FooState -> FooState so they can be chained
19:44:34 <glguy> pattern matching
19:44:37 <automata_> anyone got a good recommendation for a url parsing library?
19:44:47 <ggVGc> avocado: ah yeah, true
19:44:51 <ggVGc> EvanR: ^
19:44:53 <asnell> i can't just do (Myrec.name x) ?
19:44:53 <ggVGc> sorry, wrong hl
19:45:08 <ggVGc> EvanR: but what do I gain by having the ADT for actionsa at all?
19:45:13 <automata_> Currently using https://hackage.haskell.org/package/url-2.1.3/docs/Network-URL.html but it doesn't seem to do very much, can't even get the host from a URL instance.
19:45:14 <ggVGc> I think there are benefits to it, but can't see them
19:45:15 <DogCat> :asnell, would pattern matching on an accessor function work?
19:45:21 <EvanR> ggVGc: but separate functions is better unless you need to dynamically decide which function to use (even then ... you dont need it for that)
19:46:32 <asnell> does patter matching work outside of a function definition?
19:46:41 <EvanR> nitrix: i can see complications from both approaches, separate data sets for different features (sharing object IDs), but empircally the universe of half-functioning object values is definitely going to suck
19:46:59 <DogCat> asnell: in a case expression it will
19:47:02 <nitrix> EvanR: This honestly makes me want to give up.
19:47:04 <glguy> asnell: Sure, let expressions and case expressions both use patterns
19:47:30 <asnell> i was expecting something like idris where records get their own namespace and it can be disambiguated easily with .
19:47:53 <ggVGc> asnell: this is one of my main gripes with haskell
19:48:01 <ggVGc> and something I like in Elm
19:49:08 <nineonine> TH help needed please
19:49:11 <nineonine> 8)
19:49:22 <nineonine> im using Text.RawString.QQ
19:49:35 <nineonine> can i evaluate the passed term in quotes ?
19:49:37 <EvanR> nitrix: i have good feelings about the flatter database idea, basically sacrificing strict object types for uniform treatment of game data, also did you know about #haskell-game
19:49:49 <nineonine> so i have smth like (\x -> [r|x|])
19:50:18 <nitrix> EvanR: Yeah, maybe I should ask there.
19:50:33 <nitrix> I learned haskell with the intention to write a game.
19:50:50 <EvanR> the video game is really the final frontier of haskell...
19:51:05 <EvanR> it seems to have resisted "principled" implementations so far
19:51:24 <Cale> nineonine: That x inside the [r|x|] has as much to do with the bound variable x as (\x -> "x")
19:51:38 <nitrix> Is it because we're used to implement games in ways that aren't idiomatic for Haskell?
19:51:40 <nineonine> what do you mean ?
19:51:48 <nitrix> Or is it really that Haskell makes the process terribly painful?
19:51:49 <nineonine> it will always return "x"
19:51:54 <nineonine> whatever i pass there
19:51:59 <Cale> nineonine: That's correct.
19:52:00 <DogCat> haha, Haskell has a lot of frontiers right now: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
19:52:16 <EvanR> nitrix: well IO is kind of painful, and a lot of what we want to do is in IO
19:52:27 <nineonine> because name name of the argument is x
19:52:28 <EvanR> because theres no better place for it really
19:52:41 <nineonine> if it is a it will return "a"
19:52:53 <EvanR> nitrix: i think game programmers are generallized used to doing horrible things to get the job done
19:52:55 <Cale> nineonine: hm?
19:52:57 <nineonine> i just want this passed term to be evaluated first
19:53:04 <EvanR> generally*
19:53:16 <Cale> nineonine: no, (\k -> [r|x|]) would also always produce x
19:53:17 <rcyr> EvanR: IMHO, you can remove the word "game" from that sentence...
19:53:24 <rcyr> (sadly..)
19:53:32 <nineonine> yeah right
19:53:33 <Cale> nineonine: rather, it would always produce "x"
19:53:35 <nineonine> thats correct
19:53:36 <nineonine> sorry
19:53:36 <EvanR> s/game/game + paid/
19:53:41 <nineonine> yeah
19:53:46 <nineonine> always x
19:53:46 <EvanR> game | paid
19:53:57 <Cale> The lambda bound variable is unused
19:53:59 <nineonine> andi want it to be evaluated
19:54:04 <nineonine> true
19:54:12 <nineonine> any way around ?
19:54:17 <Cale> Around what?
19:54:25 <Cale> What function are you trying to write?
19:54:26 <glguy> nineonine: The r quasiquoter has nothing to do with expressions, it's just for raw string literals
19:54:45 <nineonine> i have [String]
19:54:54 <DogCat> > force x
19:54:55 <lambdabot>  Not in scope: âforceâ
19:55:00 <nineonine> and i want to map it 
19:55:09 <nineonine> with that kind of function
19:55:15 <nineonine> so it transforms everything to raw
19:55:20 <Cale> nineonine: huh?
19:55:34 <DogCat> > x `deepSeq` x  -- will make sure all of x is evaluated, removing all laziness
19:55:36 <lambdabot>  Not in scope: âdeepSeqâ
19:55:47 <Cale> nineonine: That... doesn't make sense.
19:55:51 <nineonine> why ?
19:56:02 <Cale> nineonine: Take a step back, what got you here?
19:56:06 <glguy> nineonine was struggling with escaping in string literals earlier today
19:56:22 <glguy> iirc template haskell quasiquoters were offered as an alternative to escaping
19:56:26 <nineonine> i just want to count the length of a raw string including all escaping chars and hex encodings
19:56:35 <nineonine> i cant do it with length
19:56:38 <geekosaur> you are not doing this right
19:56:41 <nineonine> > length "\x27"
19:56:43 <lambdabot>  1
19:56:46 <Cale> nineonine: Because there's no difference between a raw string and any other string. The difference is in the syntax you use to write the string.
19:56:50 <geekosaur> you cannot do it within the language
19:56:55 <Cale> (in your Haskell source)
19:57:03 <geekosaur> *only the compiler* sees the escapes
19:57:06 <Cale> nineonine: There's nothing *to* map
19:57:30 <Cale> If you already have a list of Strings, those are whatever they are.
19:57:39 <nineonine> should i say ... map over ? did you mean that ?
19:57:44 <geekosaur> no
19:57:56 <geekosaur> you cannot see the escapes within the languge
19:57:57 <Cale> I don't understand what function you expect to apply to your list of strings
19:58:28 <Cale> nineonine: What is your program supposed to do?
19:58:40 <Cale> What aspect of it are you having trouble with?
19:58:49 <nineonine> http://adventofcode.com/day/8
20:00:10 <glguy> nineonine: For this problem you have to write a function that figure out how long a string would be if it was encoded using the scheme defined in the problem
20:00:56 <Cale> Yeah, there's nothing Haskell-specific you can use. You could almost use the read instance for String, but that handles many other sorts of character escapes which will likely screw things up for you.
20:01:16 <nineonine> the biggest problem is hex
20:01:23 <nineonine> i can deal with escapes using show
20:01:55 <Cale> show will escape things, but it doesn't use the scheme described in that document
20:02:12 <Cale> So it wouldn't be correct to use it.
20:02:39 <Cale> The goal of this assignment is to write a parser for string literals.
20:03:12 <glguy> Or at least part of one :) https://github.com/glguy/advent2015/blob/master/Day8.hs
20:03:59 <Cale> Yeah, you could obviously fuse the parser in with the part which is calculating the difference in length between the representation and what string is being represented.
20:04:35 <Tendies> what builtin/prelude fn will work to reverse the order of each pair in a list? map, foldl arent playing nice
20:04:55 <Cale> Tendies: map (\(x,y) -> (y,x))
20:05:01 <Tendies> derp
20:05:14 <shanemikel> who's a derp?
20:05:21 <Tendies> o/
20:07:00 <Tendies> (me)
20:07:22 <Tendies> so its not working because reverse is for lists not tuples, cale?
20:07:43 <Tendies> as far as the attempt at using reverse and map
20:07:52 <Cale> If you apply reverse to a pair, it will give you a type error for that reason
20:08:40 <nineonine> ok guys thanks for help
20:09:58 <shanemikel> flip works for pairs, but there is no such type describing an arbitrary size tuple
20:10:26 * hackagebot riemann 0.1.1.0 - A Riemann client for Haskell  https://hackage.haskell.org/package/riemann-0.1.1.0 (JosephAbrahamson)
20:15:00 <Cale> flip swaps the order of function arguments, not pairs
20:15:08 <MarcelineVQ> :t swap
20:15:09 <lambdabot> (a, b) -> (b, a)
20:15:23 <Tendies> and everything is a function in haskell right
20:15:44 <mjrosenb> Is it possible to have conditional compilation based on what packages are visible?
20:15:59 <dmj`> Tendies: there's values
20:16:55 <Tendies> Making a function to determine if a is a subset of b is giving me some trouble, what would be the base case? am i removing elements that arent in the subset to check from the superset until superset == subset?
20:17:09 <Tendies> making it recursively, i mean
20:17:31 <Cale> Tendies: check that every element of a is a member of b
20:17:36 <mjrosenb> e.g. I have a utils module that is being shared by two apps, with different dependencies, and I don't want to be forced to pull in dependencies from the other just because of the util module.
20:17:48 <Tendies> oh 
20:17:49 <Cale> Tendies: Have you seen the function 'all'?
20:17:52 <Tendies> i think i can get this
20:18:34 <dmj`> > S.isSubsetOf (S.fromList [1,2]) (S.fromList [1,2,3])
20:18:35 <lambdabot>  True
20:18:50 <Tendies> i cant use subset to write subset :P
20:19:09 <dmj`> Tendies: ah, homework?
20:20:05 <Tendies> wait.. so if i wasnt constrained by a type declaration i see how i'd make it recurse
20:21:02 <Tendies> subset [x:xs] ys = elem x ys && subset xs ys
20:21:02 <dmj`> why would a typeclass constraint keep you from recursion
20:21:28 <Tendies> because the intermediary return types need to match it 
20:21:42 <Tendies> or i assumed they did
20:21:55 <geekosaur> did you mean (x:xs) instead of [x:xs]?
20:22:25 <Tendies> um well i am using type Set a = [a], so its really just a list
20:22:32 <geekosaur> yes
20:22:43 <geekosaur> (x:xs) is the desugared form of a list
20:22:56 <Tendies> oh, then yeah :|
20:23:04 <geekosaur> [x:xs] is a single-elemet list containing another list which you are decomposing into head and tail
20:23:30 <geekosaur> (this confuses a lot of people)
20:23:53 <dmj`> Tendies: it's balanced binary tree, but yea, it can be converted to a list
20:24:05 <dramforever> geekosaur: Just the "[] is singly-linked list" confuses a hell lot of people
20:24:19 <dmj`> data Set a = Bin Size a (Set a) (Set a) | Tip
20:25:05 <dramforever> dmj`: See above "type Set a = [a]".
20:25:47 <dmj`> dramforever: Ah, I see 
20:26:52 <Tendies> ok i did it
20:26:57 <Tendies> that wasnt so bad
20:27:35 <Beelsebob> random observation: the YMCA likes writing haskell while standing on their heads
20:29:20 <Tendies> does this cover the cases? http://lpaste.net/152790
20:31:37 <dramforever> @let type Set a = [a]
20:31:38 <lambdabot>  Defined.
20:31:47 <dramforever> @letlpaste 152790
20:31:48 <lambdabot>  Defined.
20:32:52 <Tendies> > subset [1,2,3] [1,3,4,5]
20:32:54 <lambdabot>  False
20:33:42 <Tendies> > subset [1,2,3,4] [1,2]
20:33:44 <lambdabot>  False
20:34:06 <dramforever> @check (\x y -> (S.fromList x `S.isSubsetOf` S.fromList y) == x `subset` y)
20:34:07 <lambdabot>  +++ OK, passed 100 tests.
20:34:23 <dramforever> @check ((\x y -> (S.fromList x `S.isSubsetOf` S.fromList y) == x `subset` y) :: [Int] -> [Int] -> Bool)
20:34:25 <knx32542>  /part
20:34:25 <lambdabot>  +++ OK, passed 100 tests.
20:34:36 <Tendies> whoa thats pretty sweet
20:35:04 <dramforever> https://hackage.haskell.org/package/QuickCheck is especially nice for checking these sorts of stuf
20:35:34 <dramforever> It (basically) generates random inputs for your function and check that it returns true
20:36:08 <dramforever> I find it useful when you have a known correct implementation ready and want to check yours against it
20:36:58 <dramforever> invariants like "x is always a subset of x" are also nicely handled
20:37:20 <Tendies> seems like i done good
20:37:58 <dmj`> Tendies++
20:41:36 <Tendies> although i didnt use that type definition at all
20:45:06 <dramforever> Tendies: I defined it for you, see "@let type Set a = [a]"
20:45:41 <Tendies> i mean, in the code i typed i didnt do anything differently than if there wasnt that type definition
20:45:58 <dramforever> you mean the subset :: ... part?
20:46:26 <Tendies> does that suffice as utilizing it :O
20:46:50 <dramforever> Tendies: yep, it's checked against your defined function
20:54:39 <clahey> edwardk: do you have the link for that gist you showed us? I want to use some of the features that I didn't know about so I need to know what extensions they live in.
21:05:43 <YellowOnion> How do you pattern match on an arg inside a monad (e.g. IO)?
21:06:19 <YellowOnion> should I just rewrite it using a case statement?
21:07:24 <monochrom> I would write a case-of
21:24:36 <clahey> How do you mean, YellowOnion? You want to pattern match on the result of an IO action?
21:25:35 <YellowOnion> Yeah, I ended up rewriting it as a case statement, but it has me curious.
21:26:04 <clahey> If you have an IO a and you want to do different things based on the value of a, write a function a -> IO b and use join.
21:26:47 <YellowOnion> ahh right, well I think this looks better then.
21:28:49 <clahey> Alternatively, if you're using do notation, write val <- ioAction and then pass val to a function a -> IO b.
21:29:10 <clahey> You can define that function in a where clause or at top level.
22:19:14 <liste> LambdaCase also works fine with >>=
22:20:27 <liste> as in "getLine >>= \case { "foobar" -> return "Yeah!"; _ -> return "Nay!" }"
22:31:18 <bitemyapp> montanonic: :)
22:34:51 <Tendies> hi im trying to partition a set and i'm getting 3 of the 5 sets needed on a 3 element set, but im stuck on the last 
22:34:56 <Tendies> 2 partitions
22:35:56 <kadoban> Tendies: {} and {} ?
22:36:05 <Tendies> http://lpaste.net/152795
22:37:13 <Tendies> on [1,2,3] i get [[[1,2,3]],[[1],[2],[3]],[[1],[2,3]]
22:37:40 <Tendies> but not [[1,2],[3]],[[2],[1,3]]
22:38:22 <mniip> just as your code says
22:38:44 <mniip> every time you either append a single-element list, or use the whole remainder of the list
22:41:28 <Tendies> every other order i put it in give me infinite type errors
23:05:51 <Tendies> infinite type, every damn time
23:20:39 <EvanR> Tendies: do you know about type holes
23:21:11 <Tendies> well i got it to generate more than the number of partitions i need
23:21:21 <Tendies> now i need to filter it down
23:42:42 <Tendies> now i can generate all the set partitions but i dont know how to filter out equal sets http://lpaste.net/152799 i.e. [[1],[2],[3]] == [[2],[1],[3]]. I set up the function to let me filter though - its just finding the right filter
23:44:17 <abuibrahim> exit
23:44:23 <adelbertc> what is the idiomatic way folks achieve the moral equivalent of ML modules? how do you program against some API and then freely be able to swap implementations without changing any client code (save for the point where you actually inject the implementation)
23:45:37 <Tendies> i've updated my paste to show the two functions i think ill need to use to filter the results
23:46:47 <adelbertc> something like http://lpaste.net/1990259858959499264
23:46:50 <adelbertc> where the 'request' type is hidden
23:47:08 <shanemikel> where is this :-> operator coming from in the shake build system?
23:49:14 <jle`> shanemikel: did you look in the documentation?
23:53:10 <Tendies> anyone?
23:53:22 <fuzion> anyone?
23:53:54 <liste> adelbertc: type classes, type families, the `reflection' package, etc...
23:54:14 <Tendies> @loadlpaste 152799
23:54:14 <lambdabot> Unknown command, try @list
23:54:18 <Tendies> @list
23:54:19 <lambdabot> What module?  Try @listmodules for some ideas.
23:54:38 <liste>  @letlpaste ?
23:55:01 <Tendies> @letlpaste 152799
23:55:02 <lambdabot>  .L.hs:164:1:
23:55:02 <lambdabot>      Multiple declarations of âSetâ
23:55:02 <lambdabot>      Declared at: .L.hs:160:1
23:55:14 <Tendies> :o
23:55:46 <liste> @undefine
23:55:46 <lambdabot> Undefined.
23:55:53 <liste> @letlpaste 152799
23:55:54 <lambdabot>  Defined.
23:56:38 <Tendies> > partitionSet "abc"
23:56:40 <lambdabot>  [["a","b","c"],["a","bc"],["a","c","b"],["ab","c"],["abc"],["ac","b"],["b","...
23:57:13 <liste> :t nub -- Tendies
23:57:14 <lambdabot> Eq a => [a] -> [a]
23:57:20 <Tendies> see what i want to do is filter the ["a","c","b"] since set wise its the same as ["a","b","c"]
23:57:33 <liste> > nub "abcdabccdabacd"
23:57:35 <lambdabot>  "abcd"
23:57:49 <Tendies> :m nub
23:58:10 <liste> though you'd need to sort the inner lists too
23:58:44 <Tendies> > setEqual "abc" "bca"
23:58:46 <lambdabot>  True
23:58:54 <liste> then you can use nubBy
23:58:56 <liste> :t nubBy
23:58:57 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
23:59:23 <Tendies> that would be what id use but i dont know how to run it compared to rest of list
23:59:24 <liste> > nubBy setEqual ["abc", "ac", "bca", "ab", "ca", "ba"]
23:59:25 <lambdabot>  ["abc","ac","ab"]
