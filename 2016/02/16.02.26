00:00:07 <EvanR> by memoizing with unsafePerformIO
00:00:08 * hackagebot freer 0.2.2.3 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.2.3 (alcabrera)
00:00:10 * hackagebot freer 0.2.2.4 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.2.4 (alcabrera)
00:00:43 <levi> Lokathor: The point is, you need a Numerical Methods textbook if you're going to do serious floating point calculations on a computer, and you're going to have to think carefully about how you compare numbers *for your particular problem*, so providing a generalized Eq for floating point is just wrong.
00:01:24 <Lokathor> fair
00:01:39 <Lokathor> that's why i stick to integrals
00:01:43 <Lokathor> they make sense
00:02:12 <levi> Since the library doesn't provide the Eq instance, *you* can write one for your program as long as you don't let it escape. ;)
00:02:49 <EvanR> > 1.0 == 1.0 -- huh
00:02:55 <lambdabot>  True
00:03:08 <EvanR> what doesnt have Eq
00:03:57 <Lokathor> i don't even have a program that's using floating points right now really
00:04:03 <Lokathor> i noticed when i wrote this
00:04:04 <Lokathor> boolOf :: (Functor f, Eq a, Num a) => f a -> f Bool
00:04:04 <Lokathor> boolOf x = fmap (/= 0) x
00:05:08 * hackagebot plan-b 0.1.1 - Failure-tolerant file and directory editing  https://hackage.haskell.org/package/plan-b-0.1.1 (mrkkrp)
00:08:02 <levi> I thought someone was saying it'd been removed; I guess it hasn't been.
00:08:06 <levi> But you shouldn't use it.
00:09:10 <EvanR> not there in my ghci 7.10
00:09:32 <levi> I guess it was the Show and Eq constraints on Num itself rather than on Float, Double, etc.
00:10:08 * hackagebot brainfuck-tut 0.7.0.1 - A simple BF interpreter.  https://hackage.haskell.org/package/brainfuck-tut-0.7.0.1 (alcabrera)
00:10:09 <merijn> The report requires a Show and Eq superclass on Num, but GHC does not
00:10:30 <merijn> It's one of the few places were GHC doesn't follow the report without extensions
00:11:11 <merijn> Oh, and Eq for floating points isn't going anywhere
00:11:25 <levi> There's the silly Enum for floats, too.
00:11:39 <merijn> The problem with Eq is that it doesn't obey reflexivity, it follows the IEEE754 behaviour
00:11:47 <merijn> And the Enum for floats is downright evil
00:13:16 <levi> Floats don't generally provide much in the way of the standard algebraic properties of numbers. :(
00:13:48 <merijn> They actually do, but people confuse them with reals, which are different
00:13:56 <levi> You have to be careful about associativity even.
00:15:08 * hackagebot wai-request-spec 0.10.2.1 - Declarative request parsing  https://hackage.haskell.org/package/wai-request-spec-0.10.2.1 (alcabrera)
00:32:45 <osfabibisi> morning
00:33:21 <osfabibisi> I'm trying to connect to an https host that requires a certificate using wreq
00:33:57 <osfabibisi> doing a simple `get` gives me a TlsExceptionHostPort (HandshakeFailed ...) failure.  That's without cert though (as the tutorial doesn't cover that...) any suggestions where to start?
00:46:54 <nomeata> Tring to build hakyll on travis. It‚Äôs going to be interesting whether it finishes within the timeout...
00:47:56 <liste> nomeata: can it be run in containerized mode (non-root) ?
00:48:10 <nomeata> liste: it is
00:50:07 <kadoban> nomeata: Can't you get it to cache certain things, so even if it doesn't finish you could try again until it does and then it should work from there? (don't really know travis that well)
00:52:41 <nomeata> kadoban: usually, the cache is only written back if the build (or the setup phase) succeeds, but yes, that‚Äôd be something I‚Äôll look into if it does time out. Still 30 minutes left :-)
00:52:51 <nomeata> oh, nevermind, the build failed
00:53:12 <kadoban> nomeata: Ah :-/
00:53:34 <nomeata> cabal install --bindir=. works fine. unless network is not yet installed. then it breaks.
01:28:49 <Aleksejs> hello, what would be a monadic case .. of? I need something like this: if a and b then action elseif a then otherAction else defaultAction
01:31:17 <Cale> Aleksejs: You don't need a special monadic thing for that. Just determine which action based on the condition using ordinary if/then/else or case/of
01:32:22 <Aleksejs> Cale: ok, I'll try
01:32:49 <Cale> Aleksejs: There's an extension called MultiWayIf which can help avoid the nesting
01:32:56 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#multi-way-if
01:33:02 <Cale> But you could also write
01:33:04 <Cale> case () of
01:33:16 <Cale>   _ | a && b -> action
01:33:27 <Cale>     | a -> otherAction
01:33:36 <Cale>     | otherwise -> defaultAction
01:33:48 <srhb> Any recommendations for simple "search-in-Text" libraries able to find "haystack haystack needle=\"needleval\" haystack" ?
01:33:55 <Cale> Or indeed, just
01:34:02 <Cale> if a && b
01:34:05 <Cale>   then action
01:34:17 <Cale>   else if a
01:34:23 <Cale>           then otherAction
01:34:33 <Cale>           else defaultAction
01:34:57 <jophish> ¬° AHH ! someone announced my package on reddit before me!
01:35:12 <Cale> jophish: That's kinda rude
01:35:28 <jophish> Stealing precious upvotes!
01:35:45 <jophish> oh no, /r/vulkan too!
01:41:19 <srhb> jophish: All too late for precious karma.
01:46:43 <jophish> my heart skipped a beat when I saw the announcement; I thought someone else had released a package with the same (or similar) name
01:51:55 <ski> Aleksejs : .. or `if a then if b then action else otherAction else defaultAction'
01:54:59 <Aleksejs> ski: thanks! But I used case () of construction
01:58:27 <Codex_> hello
01:59:06 * ski blinks
01:59:23 <ski> Aleksejs : if `a' is a complicated expression, then my version would probably avoid recomputing it (if it's just a variable name, then it doesn't matter much)
02:34:19 <inad922> Hi
02:34:44 <inad922> Is there a version of bind(>>=) which I can use as a 2 variable function?
02:36:19 <srhb> inad922: What? It is.
02:36:28 <srhb> :t (>>=)
02:36:30 <inad922> ah ok
02:36:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:36:39 <inad922> srhb: Thanks
02:36:42 <srhb> First argument is m a, second is (a -> m b) :)
02:37:55 <inad922> srhb: I just wanted to make this work: foldl >>= [5, 6] [(return . \x -> x * 3)| y <- [1..3]]
02:38:06 <inad922> apparently bracing >>= works fine
02:38:28 <srhb> inad922: Oh, yes, putting an operator name in paranthesis makes it a prefix function rather than an infix operator :)
02:38:41 <srhb> > (+) 1 2
02:38:42 <srhb> etc.
02:38:47 <inad922> ah I see
02:38:47 <lambdabot>  3
02:45:13 * hackagebot hsdev 0.1.6.5 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.5 (AlexandrRuchkin)
02:48:36 <sphinxo> In the same way you could describe monad as chainable, how would you describe applicative?
02:48:43 <sphinxo> and currying?
02:49:09 <liste> chainable?
02:49:47 <sphinxo> also chainable?
02:50:01 <liste> sphinxo: no, I was just confused
02:50:23 <liste> about describing monads as chainable
02:50:30 <liste> is there more info somewhere about that?
02:50:34 <sphinxo> Or say as you could say functor as mappable
02:50:57 <sphinxo> or monoid as aggregatable
02:51:45 <sphinxo> or catamorphism as collapsable
02:52:00 <sphinxo> or foldable
02:52:23 <sphinxo> liste: Do you understand what I mean?
02:54:57 <mniip> sphinxo, literally that, applicative
02:55:21 <mniip> it lets you *apply* N-ary functions under a functor
02:55:28 <sphinxo> oh ok, and what about currying?
02:55:34 <mniip> currying?
02:55:42 <sphinxo> I guess currying is currying
02:55:45 <sphinxo> also
02:56:51 <mniip> hmm
02:57:06 <mniip> :t liftA2 id
02:57:12 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
02:57:14 <mniip> fun
03:00:10 <liste> sphinxo: I guess so. though I think "chainable" is a confusing term
03:00:16 <liste> to describe a monad
03:00:59 <liste> I can chain functions by composing them
03:03:14 <sphinxo> liste: What do you think would be a better term?
03:03:37 <ski> sphinxo : how about "monad" ?
03:03:49 <sphinxo> accessable to no fp programmers but still descriptive
03:04:16 <sphinxo> ski: :) Possibly :)
03:04:29 <ski> "still descriptive" while also still lightweight is possibly asking too much
03:04:58 <sphinxo> Maybe a little less lightweight then?
03:06:30 <deni> how would you go along modeling something like an api wrapper that has type level guarantees that if your function is accessing endpoint A it needs to have reponse A instead of B ?
03:06:46 <ski> better then with an unfamiliar term, not attempting to appeal to previous understanding, than appropriating a more familiar-sounding term with a specific technical meaning that is hard to guess and possibly hard to explain why this particular concept gets the more familiar-sounding term
03:08:25 <ski> ("monad" also has the advantage of agreeing with the CT use of the term. if you don't know CT, then no matter, just treat it as a (previously) unfamiliar term)
03:08:34 <sphinxo> CT use?
03:08:44 <ski> Category Theory
03:08:47 <sphinxo> Ahh ofc
03:09:31 <sphinxo> so what about monad -> computation builder
03:10:02 <sphinxo> or  way of chaining operations together
03:10:30 <liste> how about Bindable ?
03:10:40 <mniip> that doesn't say anything about its abilities
03:11:15 <sphinxo> Monads - way to wrap things and provide methods on wrapped things without unwrapping it?
03:11:16 <ski> (no need to know CT to understand how "functor","monad" or even "natural transformation" (not that common) is used in (a few) FP languages. of course, if you find learning CT fun, then it may help a little (but not *that* much more), e.g. getting a broader view)
03:11:20 <mniip> whereas Monad refers to a categorical Monad, which hints at existence of return and join
03:12:14 <ski> sphinxo : "computation builder" -- depends on what interpretation (like how wide) you assign to "computation"
03:12:54 <sphinxo> Monads are to control flow what abstract data types are to data
03:13:04 <mniip> no?
03:13:47 <ski> sphinxo : is a list a "computation" ? is a tree with elements at the leaves a "computation" ? is an expression possibly including variables a "computation" (the sense meant is probably not the one you may think of at first) ?
03:14:06 <sphinxo> Good point, ski
03:14:53 * ski would btw answer "yes" to all these three questions
03:15:32 <mniip> to be fair, 'id ()' is a computation ;)
03:18:35 <ski> sphinxo : perhaps one could describe applicative functors as being about "static sequencing", while monads would then be about "dynamic sequencing". however, one has to elaborate this to explain what is meant
03:19:59 <mniip> referring to the fact that monads let you change the effect depending on the value, where in applicative functors the effect is constant
03:20:31 <sphinxo> Good idea
03:20:38 <ski> sphinxo : consider `f' a functor. then given an `f a', we can convert this into an `f b', provided we can convert `a's to `b's (iow, provided a function of type `a -> b'), which works for any types `a',`b'. this is the type `forall a b. (a -> b) -> (f a -> f b)' of `fmap' (for a particular `f' in `Functor')
03:21:23 <ski> sphinxo : so in some sense, we can "operate inside" a *single* `f' "wrapper" in the type
03:22:59 <ski> sphinxo : ok, so far ?
03:23:16 <lonokhov> is there a way to get "unique" int or safe filepath string from ThreadId? I want to use it for per thread temp file. Parsing "show <$> myThreadId" does not sound right
03:24:03 <jophish> lonokhov: can you coerce it?
03:24:04 <mniip> you could spin up an RNG with that seed
03:24:10 <lonokhov> I also don't want to implement dirty hacks with rts ffi and GHC.Prim like hashable does
03:24:13 <lonokhov> jophish: nah
03:24:28 <sphinxo> what do you mean by  we can "operate inside" a *single* `f' "wrapper" in the type
03:24:29 <jophish> ah yes, I see it's a data around ThreadId#
03:24:42 <mniip> oh
03:24:50 <mniip> yeah the problem is,
03:25:02 <mniip> representation of ThreadId is platform-dependent
03:25:29 <mniip> might be an int on one, a pointer on another, and a struct of pointers on third platform
03:26:27 <jophish> lonokhov: why not just get the hash
03:26:30 <jophish> and use that
03:26:39 <lonokhov> I guess hash would be unique enough :P
03:26:48 <jophish> :D
03:27:04 <ski> sphinxo : we get a single `f', wrapped around `a', one "`f'-thing" (`f'-action/computation), and given an `a -> b', we can transform this single `f a' into an `f b'. makes sense ?
03:27:17 <sphinxo> ah yes now, thanks
03:27:27 <parsecChar> in ghci, is there a easy way to *remove* a module? i.e. the opposite of ":add ... "
03:27:28 <ski> (the "single" will possibly may better contrast with the following)
03:27:45 <ski> sphinxo : now assume an applicative functor / idiom `i' (which is also a functor). what this buys us is that we can also build functions of types `forall a. a -> i a' (`pure',"liftA0"),`forall a b c. (a -> b -> c) -> (i a -> i b -> i c)' (`liftA2'),`forall a b c d. (a -> b -> c -> d) -> (i a -> i b -> i c -> i d)' (`liftA3'),&c. in addition to the functorial `forall a b. (a -> b) -> (i a -> i b)' (which `fmap' ("liftA1") gives us)
03:27:46 <lonokhov> oh, there is Data.Unique
03:28:19 <sphinxo> functorial?
03:29:47 <ski> we can build `forall a b. (a -> b) -> (i a -> i b)' already because `i' is also a plain functor (and more). in fact `fmap' has exactly that type. i called it "functorial" since it depends (only) on `i' being a functor, not on `i' also being an applicative functor / idiom
03:30:07 <sphinxo> Are monoids foldrightable?
03:31:11 <sphinxo> are monads flatmappable?
03:32:15 <parsecChar> I'm using stack. How do I install ghc-mod or hdevtools?
03:32:26 <sphinxo> parsecChar: stack install?
03:32:50 <parsecChar> sphinxo: that appears to work
03:35:26 <ski> sphinxo : sorry, got occupied for a little bit
03:35:48 <sphinxo> How about: Functors transform values inside containers, while applicatives and monads combine values inside containers
03:36:31 <parsecChar> is "stack install hdevtools" ==> installing Cabal1.22.7.0 ==> supposed to take forever?
03:36:33 <parsecChar> where forever = minutes
03:36:54 <jophish> parsecChar: hse takes its time
03:37:05 <jophish> haskell-src-exts*
03:37:19 <ski> sphinxo : continuing with applicative functors. given any number of `f'-actions, of types `f a',`f b',...,`f y', we can *combine* them into `f (a,b,...,y)' -- alternatively, given a function `a -> b -> ... -> y -> z', we can *combine* them into `f z'
03:37:24 <happy0> hi, i was wondering if someone could explain to me what this slide means when it says 'won't know what structure (m b) will be returned until the code is run' and what significance that has compared to a functor? ;x
03:37:38 <happy0> http://www.scs.stanford.edu/16wi-cs240h/slides/fb-slides.html#(22)
03:37:43 <happy0> sorry, ^ that slide
03:37:54 <ski> er, replace `f' with `i' there, which was the name i was using for applicative functors
03:37:59 <happy0> in relation to concurrency / batching in haxl
03:38:20 <parsecChar> jophish: thanks for confirming; just switched from cabal to stack, and wasn't sure if this was normal behaviour or if I was doing something wrong
03:38:27 <sphinxo> ski: that makes sense
03:39:27 <ski> sphinxo : if we just have a functor `f', then without knowing anything more about `f', then only thing we can do is take a *single* `f a' "computation", and "change" the `a' "inside" to a `b', using any `a -> b' we like. possibly later continuing by changing `b' to `c' using `b -> c', and so on
03:39:51 <jophish> parsecChar: I've never had any package hang forever while building
03:39:53 <ski> sphinxo : but at each point in such a sequence, we have just a single `f'-action/computation to play with
03:40:02 <parsecChar> jophish: it finished now :-)
03:40:14 <jophish> in future you could probably pass --verbose and see the progress
03:40:40 <parsecChar> jophish: yeah, a little progress bar, even if it lies to me, makes me feel better
03:41:25 <parsecChar> hmm, does hdevtools work with stack?
03:41:34 <parsecChar> I just ran "hdevtools check Main.hs" and it's complaining about ghc not being found
03:41:43 <parsecChar> well turns out, the only ghc I have is the one via stack, not any ghc on my system
03:41:50 <unit73e> hey
03:42:07 <ski> sphinxo : while with an applicative functor `i', we can combine *multiple* `f'-actions, in order/*sequence*, provided only that we can combine the respective "innards" ("innards" or worse, "contents", isn't a very good intuition here. e.g. with `Parser Int' or `IO Int', the action of that type does not "contain" an `Int' in any useful sense. a recipe/description of how to bake a cake doesn't contain a cake)
03:42:47 <ski> (or, `i'-actions)
03:43:08 <unit73e> why doesn't cabal-install simply become more of a fully featured package manager with upgrade and uninstall?
03:43:40 <dramforever> IIRC cabal would do concurrent compiling, so the progress could be seriously messed up with -v
03:43:40 <parsecChar> without cabal hell, how do we find who the true devots are ?
03:44:21 <liste> parsecChar: see https://github.com/hdevtools/hdevtools#text-editor-integration
03:44:29 <ski> sphinxo : in general, combining an `i a' and an `i b' into an `i (a,b)', and then using `(a,b) -> (b,a)' to convert that into `i (b,a)' may be *different* from combining the original `i a' and `i b' directly, in the opposite order. the order/sequence in which you combine actions, using applicative functor operations, may matter !
03:44:31 <unit73e> you start an inquisition? lol
03:45:44 <dramforever> OTOH a progress bar sounds really nice :)
03:45:44 <ski> sphinxo : but for some particular applicative functors, it turns out not to matter. e.g. `Reader rho' or `Maybe'. but in general, order may matter. hence applicative functors describe (static) *sequencing*
03:45:49 <parsecChar> liste: ha, my exact issue, thanks!
03:47:35 <liste> parsecChar: you're welcome (:
03:48:19 <dramforever> I guess the word "off-line" describes Applicative well
03:49:00 <ski> sphinxo : "Are monoids foldrightable?" -- i presume you are thinking of `Data.Foldable.foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b' ?
03:49:01 <dramforever> As you give me an F a, I (may choose to) know that it's constructed with primitives in a particular order
03:49:14 <sphinxo> ski: yes
03:49:30 <ski> sphinxo : "are monads flatmappable?" -- are you thinking of `(=<<) :: Monad m => (a -> m a) -> (m a -> m b)' ?
03:49:44 <sphinxo> oh yes
03:50:39 <ski> i'm not really seeing the (supposed ?) analogy between those two operations here
03:51:03 <sphinxo> oh ok
03:51:49 <ski> @type Data.Foldable.foldMap
03:51:53 <ski> @type Data.Traversable.mapM
03:52:02 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:52:03 <mniip> are traversables traversable?
03:52:07 <mniip> hahah
03:52:12 <lambdabot> Plugin `type' failed with: <<timeout>>
03:52:17 <ski> @type Data.Traversable.mapM
03:52:22 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
03:52:38 <happy0> never mind my earlier question regarding HAXL, it's just clicked =p
03:52:40 <ski> these two would perhaps exhibit a more useful analogy (?)
03:52:42 <happy0> and it feels good that it's clicked :D
03:53:06 <ski> however
03:53:10 <ski> @type Data.Traversable.traverse
03:53:17 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:53:29 <ski> is as good as `mapM', so it's not really about monads there
03:55:11 <ski> sphinxo : anyway, for monads `m', the power of the `(>>=)'/`(=<<)' "flatmap" operation can also be expressed as the `join :: Monad m => m (m a) -> m a' operation
03:56:33 <liste> at least in Scala, flatMap is (=<<)
03:58:12 <ski> sphinxo : consider an action `m (m a)' that when "executed" will yield another action `m a' (that when "executed" will yield an `a'). what `join' (or `(>>=)'/`(=<<)') gives us is the possibility to convert such an `m (m a)' to a plain `m a', such that when that latter action is executed, it will first execute the "outer" action `m (m a)', yielding a result action of type `m a', *then* continue by also executing this (*dynamically* computed) action, yielding
03:58:29 <ski> er, cut off near ".., *then* continue by also executing this (*dynamically* computed) action, yielding the desired `a' result value"
03:59:30 <ski> so `join' allows us to "collapse" several nested layers of `m' into a single one (and `return' allows up to conjure up a trivial `m' layer, getting an `m a' from an `a' with zero `m' layers around)
04:01:24 <ski> sphinxo : alternatively, in terms of `(>>=)', we have an `m a', and this time not an `a -> b', but an `a -> m b', but we still get back an `m b', that when executed will execute the `m a' action, getting a (dynamically computed) `a' result, which is passed into `a -> m b' getting a *dynamically* computed `m b' which is then executed, and which yields our desired `b' result
04:02:28 <ski> sphinxo : the important point here is that the decision of *what* action to take in a later part of a "computation"/"action" may *depend* on values dynamically computed earlier in the "computation"/"action"
04:03:26 <sphinxo> ski: I understand, thanks for the explanation
04:03:52 <ski> sphinxo : while, in the case of applicative functors, as soon as you start "executing" an action, the whole "structure" of it is *fixed*, it can't depend on the "dynamics" of earlier parts of the computation, which is what may happen in the monadic case
04:04:49 <parsecChar> is there a Parsec.parse which operates on Lazy Text instead of [Char] ?
04:06:20 <ski> sphinxo : however, remember that every monad is also an applicative functor. whether a particular action that you build may exhibit this sort of "dynamic scheduling" may depend not only on whether you use specifically monadic operations like `join' or `(>>=)' (or `do'-notation), but other "primitive" actions that you also use to be able to do anything useful at all, may also introduce this kind of dynamicism
04:07:23 <lpaste> dramforever pasted ‚ÄúHello, does anyone know a nice way to parse this sort of indentation-aware documents? Thanks in advance‚Äù at http://lpaste.net/153396
04:08:04 <ski> sphinxo : this post "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <http://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> is talking about the same distinction
04:09:16 <ski> sphinxo : anyway, hopefully you should have a somewhat better understanding now of what i meant when saying that the applicative functor concept expresses static sequencing, while the monad concept expresses dynamic sequencing
04:09:35 <sphinxo> Yeah, thanks
04:11:08 <ski> sphinxo : one final point. one can build applicative parser types (some of which can't even be made into monads). however they still have an alternation operation `(<|>)', which can produce effects that to a first look may feel like the "dynamic structure/sequencing" above
04:11:52 <hvr> jophish: does vulkan-1.0 still need 24GiB ram to compile w/ -O1?
04:12:24 <ski> sphinxo : consider a parser like `(string "a" *> foo) <|> (string "b" *> bar)' which will either parse an `a' and then parse according to `foo', or parse a `b' and then parse according to `bar'
04:13:06 <Ashy> does anyone use codex with stack?
04:13:20 <Ashy> ive got it telling me to run cabal configure first
04:13:51 <Ashy> but cabal is not really in a working state (outside of using it through stack i guess)
04:14:07 <Ashy> is there some magic stack incantation i can use to get codex to work?
04:14:16 <ski> sphinxo : this may feel like "what action to do next depending on the dynamic result of what was done earlier". in fact, if we reexpress it like `anyChar >>= \case 'a' -> foo; 'b' -> bar; _ -> mzero', then it will conform to this monadic "dynamicism" pattern
04:14:52 <jophish> hvr: not quite that much, but splitting up the modules didn't help as much as I had hoped. I'm pretty sure that the problem is with using Data.Vector.Fixed with really big lengths (256 elements)
04:15:11 <ski> sphinxo : however, what you can express using `(<|>)' is still weaker than a full `join'/`(>>=)' operation, so it's not the full "dynamicism" of monadic structuring
04:15:40 <ski> sphinxo : and with that, i think i'll stop here. have fun
04:15:55 <sphinxo> ski: I certainly will :) thanks 
04:17:45 <jophish> hvr: I think I'll replace using that package with a newtype around ordinary vectors, tagging them with the size
04:18:06 <dramforever> Hello, does anyone know a nice way to parse this sort of indentation-aware documents? Thanks in advance. This is a more detailed description http://lpaste.net/153396
04:18:07 <jophish> or petition fixed vector to switch to type level nats for ghc 8
04:18:36 <dramforever> (Bumping in case anyone didn't notice that it was a question)
04:19:28 <jophish> dramforever: You might want to look into trifecta, the Idris compiler uses it
04:19:29 <parsecChar> in vim, how do I map Ctrl-P to :GhcModCheck ?
04:19:40 <jophish> I'm sure you can get some kind of indentation aware parsing using TokenParser
04:20:21 <mniip> jophish, type nats are broken though
04:20:39 <jophish> mniip: I thought that ghc 8 made this a lot better
04:20:39 <dramforever> jophish: ooh thanks for that
04:21:10 <mniip> I didn't see anything in the change list
04:21:21 <jophish> parsecChar: probably something like: nnoremap <C-p> :GhcModCheck!<CR>
04:22:29 <jophish> mniip: or, there are plugins making them nicer to use
04:22:45 <jophish> mniip: I assumed injective type families would make things nicer
04:23:01 <jophish> although I suppose they'd have to be sorted out specifically for Nats
04:23:21 <mniip> well, jle` (iirc) made a thing that makes it easier
04:23:51 <mniip> nat-witnesses or something
04:24:11 <parsecChar> monads-tf vs mtl
04:24:14 <parsecChar> which one should I be using?
04:25:42 <jophish> parsecChar: mts, considering monads-tf is a replacement for a deprecated package
04:25:45 <jophish> mtl*
04:26:44 <parsecChar> jophish: thanks
04:27:26 <bgamari> jophish, yes, I think you really need to get rid of these peanos if you want reasonable compilation times
04:27:39 <hvr> bgamari: + reasonable mem usage ;)
04:28:03 <bgamari> replacing fixed-vector would be easy and should help tremendously
04:28:08 <jophish> That probably implies lowering the error in incorrect array lengths to runtime :(
04:28:10 <H4x00m> yop
04:28:19 <bgamari> jophish, I'm looking at the core2core at the moment
04:28:53 <bgamari> and much of the program is just coercions
04:29:02 <jophish> I'm sure I saw something a while ago about dumping ghc compile time and memeory statistics, but I can't remember what it was
04:29:11 <bgamari> between these massive peano types
04:29:23 <bgamari> jophish, +RTS -s is a good place to start
04:29:26 <jophish> bgamari: hahah, I'll take a look, it sounds like a spectacle 
04:29:43 <bgamari> I'm looking at DeviceInitialization
04:30:07 <bgamari> jophish, that's a good word for it
04:30:20 * hackagebot hasql 0.19.9 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.9 (NikitaVolkov)
04:30:34 <dramforever> Arrgh, that looks like a huge complexed system of parsers :P
04:30:52 * hvr will wait for the 'most efficient PostgreSQL driver' instead
04:31:13 <bgamari> jophish, why do you think you will need to sacrifice runtime checking?
04:31:21 <bgamari> bah
04:31:24 <bgamari> s/runtime/compile-time/
04:33:01 <Aleksejs> http://vpaste.net/U5hCB is there any way to make this shorter? Or should I try TH?
04:33:30 <dramforever> jophish: Do you have any tutorial handy? I'm having trouble finding "haskell parsers tutorial" because of the bad name :(
04:33:48 <jophish> bgamari: If I switched to tagging a regular vector with a Nat? couldn't one pass in any vector at runtime. Vector.Fixed is pretty nifty at making sure one can only construct correct length vectors (or marking things as unsafe)
04:35:20 <bgamari> jophish, you only expose a smart constructor which verifies the length
04:35:43 <jophish> dramforever: hmm, was asked here without many results https://www.reddit.com/r/haskell/comments/2uc6kp/are_there_any_tutorials_or_introductions_to_the/
04:35:47 <bgamari> fromVector :: KnownNat n => Vector a -> Maybe (Vec n a)
04:35:50 <jophish> the top comment is useful though
04:36:19 <bgamari> jophish, so yes, that smart constructor involves a runtime check
04:36:25 <bgamari> but everything thereafter is statically verified
04:36:36 <jophish> bgamari: that's probably the best solution. I'll try and get that done this evening
04:37:51 <dramforever> jophish: That's exactly what I'm having problems with
04:38:07 <dramforever> because I can't seem to google "haskell parsers tutorial"
04:38:18 <jophish> Wow, I just looked at -ddump-simpl. It makes very nice patterns when I scroll my terminal quickly as the indentation rushes from side to side
04:38:56 <jophish> dramforever: try "haskell parsec tutorial". Most of these monadic parsers have a very similar interface
04:39:11 <jophish> and parsec's been around for a long time, so I'm sure plenty has been written about it
04:40:10 <dramforever> jophish: "Most of these monadic parsers have a very similar interface" that's great!
04:40:19 <dramforever> I already know a bit of parsec
04:42:45 <dramforever> Arrgh, that thing happened again. It always happens when I get ekmett packages...
04:43:10 <dramforever> You know, the huge load of dependencies
04:54:40 <dramforever> Hmm... After some thought, I think I could go with a two-pass parser, the first of which just reads in the structure
04:54:52 <dramforever> and the second of which processes line folding, and command parsing
05:03:09 <Grisha> Hi everyone
05:03:22 <hodapp> hi
05:03:25 <Nilabhra> hi
05:03:33 <Grisha> I'm wondering whether there is something like bytestring.char16 for wchar_t
05:03:46 <Grisha> *for strings consisting of wchar_ts
05:04:26 <Grisha> I'm reading a certain file format (binary) and some of it contents is 16bit/char strings
05:12:33 <jophish> Grisha: 'text' probably has something for that
05:12:50 <Grisha> jophish, thanks, I'll look into that
05:13:41 <jophish> Grisha: https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-Encoding.html
05:13:46 <jophish> spacex
05:13:48 <jophish> oops
05:14:21 <Grisha> ok
05:15:59 <Grisha> hm
05:16:26 <Grisha> I'm not quite sure about the relation between wchar_t strings and UTF
05:17:59 <jophish> wchar_t isn't even guaranteed to be 16 bits btw
05:18:00 <barrucadu> Grisha: The encoding of wchar_t isn't specified, just that it's capable of representing all of the characters in the extended character set
05:18:58 <Grisha> that's exactly my problem I guess
05:25:22 * hackagebot pipes-bzip 0.1.0.0 - Bzip2 compression and decompression for Pipes streams  https://hackage.haskell.org/package/pipes-bzip-0.1.0.0 (chemist)
05:28:27 <Grisha> decodeUtf16Be from Data.Text.Encoding seems to be doing what I want
05:29:40 <jophish> Grisha: yeah, that's not surprising. You might want to find out in more detail what encoding is used in that format though
05:30:53 <Grisha> the online manual says
05:30:54 <Grisha> :
05:31:06 <Grisha> This format was also developed to support localization. Strings stored within the file are stored as 2 byte UNICODE characters.
05:31:27 <Grisha> A UNICODE string. A string object is stored as an INT (to store the string length) followed by the WCHAR array (to store the string contents).
05:33:53 <mniip> 2 byte unicode characters
05:34:03 <mniip> what an oxymoron
05:34:29 <Grisha> that's exactly the reason I feel lost
05:34:37 <Grisha> there is utf8, utf16, utf32
05:34:44 <Grisha> should I assume it's utf16?
05:36:42 <jophish> Grisha: there doesn't seem to be another reasonable choice. Text is pretty robust and will tell you if there's an error
05:37:57 <Grisha> jophish, I guess you're right and that's the only choice
05:38:02 <Grisha> jophish, thanks for your thoughts
05:38:08 <pavonia> Grisha: My guess would be it's UCS-2
05:38:09 <jophish> np
05:39:01 <Grisha> pavonia, the code that generates the files was developed under Windows
05:39:27 <pavonia> Yeah, makes sense then
05:47:26 <dramforever> So it didn't quite work out.
05:47:58 <dramforever> Question: does anyone know how to make the indentation-aware feature of megaparsec also "empty-lines aware"?
05:48:30 <dramforever> I mean, if I have an empty line in the middle of a list of indented stuff, I should be able to know about it
05:49:20 <dramforever> currently I am able to hack the space consumer to eat up at most one eol, but the indentation in the empty line is still required/significant, which is bad
06:15:01 <trudi> hi having a question about trees 
06:15:03 <trudi> http://lpaste.net/7841057939581304832
06:15:30 <trudi> I trie to get all edges from root to leaf with given function
06:16:20 <trudi> but getting " is a rigid type variable bound by  the type signature for paths "  on compilation
06:18:56 <dramforever> @letlpaste 7841057939581304832
06:19:03 <lambdabot>  .L.hs:146:29:
06:19:05 <lambdabot>      Ambiguous occurrence ‚ÄòTree‚Äô
06:19:07 <lambdabot>      It could refer to either ‚ÄòL.Tree‚Äô, defined at .L.hs:146:1
06:19:20 <dramforever> forget about it
06:19:46 <trudi> ?
06:20:05 <dramforever> trudi: don't worry forget about it
06:20:23 <trudi> ah okay
06:21:54 <dramforever> trudi: Some generic advice: You seem to have posted the part of the error message you don't understand, that's wrong, because if you don't understand it, it's probably not very useful
06:22:18 <trudi> i did not want to spam the chan
06:22:22 <dramforever> in this case, the first line of the error should give you enough hint
06:22:43 <dramforever> trudi: yes, and IMHO you picked the least useful line
06:22:47 <geekosaur> generally you append the full error message to the paste, in a {- long comment -}
06:23:03 <trudi> aok @ geekosaur
06:23:15 <dramforever> The first line says Couldn't match expected type ‚Äòe‚Äô with actual type ‚Äò[e]
06:23:21 <dramforever> does it make any sense?
06:23:25 <quchen> ?undef
06:23:27 <lambdabot> Undefined.
06:23:30 <quchen> Try again.
06:23:54 <dramforever> trudi: ^ does it make any sense?
06:25:02 <trudi> shure
06:25:14 <trudi> but i dont knwo where this is happening?
06:25:41 <dramforever> trudi:     In the expression: x : z
06:26:04 <trudi> ah
06:26:12 <dramforever> Which is near the bottom of the message
06:26:13 <trudi> I think I get it
06:26:28 <trudi> so i am delivering [e] instead of [[e]]
06:26:30 <trudi> right?
06:26:51 <dramforever> trudi: wait a sec, I didn't really read the code :P
06:29:47 <dramforever> trudi: yep
06:29:56 <trudi> but why?
06:30:34 <trudi> the first map expects a list of [(e, Tree v e)]
06:31:05 <dramforever> yes, and the function passed to the first map is supposed to return a...
06:31:05 <trudi> and the result of this map is a list of [e]
06:31:45 <dramforever> the function should return [e]
06:31:53 <trudi> no
06:32:02 <trudi> i want the distinct paths from root to leaf
06:32:05 <dramforever> :)
06:32:18 <dramforever> trudi: that's the problem, bingo :)
06:33:24 <dramforever> so the first map is not really what you want
06:33:44 <dramforever> it's ((e, Tree v e) -> [e]) -> [(e, Tree v e)] -> [[e]]
06:34:08 <dramforever> where you actually want the first [e] to be [[e]], to be able to return multiple paths
06:34:36 <trudi> one moment
06:34:42 <trudi> just to get it right
06:35:08 <trudi> "paths y " returns [[e]] accoring to spec
06:35:18 <dramforever> yep
06:35:19 <trudi> the second map works on each [e]
06:35:26 <trudi> and prepends the current e
06:35:30 <trudi> right so far?
06:35:34 <dramforever> yeah
06:36:01 <trudi> than y isnt the wirst map resulting of [[e]]?
06:36:07 <dramforever> The (\(x, y) -> ...) itself is nothing wrong
06:36:17 <dramforever> it just doesn't fit into the first map
06:36:42 <dramforever> (Interestingly confusing error message, I must say)
06:37:10 <trudi> so the problem is the input list for the map?
06:37:19 <dramforever> um, not quite
06:37:36 <dramforever> how many edges are you returning from (\(x, y) -> ...)?
06:37:41 <dramforever> one? multiple?
06:38:28 <dramforever> how many does map expect?
06:38:30 <dramforever> :t map
06:38:34 <trudi> one edge
06:38:44 <dramforever> how many are you returning?
06:39:09 <dramforever> anyway, it seems that it's a list of paths
06:39:27 <trudi> multiple edges
06:39:38 <dramforever> mismatch!
06:40:00 <trudi> ahh
06:40:02 <trudi> I get it
06:40:21 <trudi> so i am violationg the map contract?
06:40:40 <dramforever> um, if you call the type of map the "contract", yes
06:40:41 <trudi> map :: (a -> b) -> [a] -> [b] wont allow me to  do ->[[b]]
06:41:15 <trudi> so how could I circumvent it?
06:42:12 <srhb> trudi: Yes it will.
06:42:27 <dramforever> trudi: from what you have, you just need to apply a function to the expression. like ??? (map (\(x, y) -> ...) xs)
06:42:32 <srhb> As long as the first argument is (a -> [b])
06:42:56 <trudi> srhb yes, but in my case it isnot :)
06:43:02 <srhb> Right. :)
06:43:36 <dramforever> More Hint: the first map gives a result of [[[e]]]
06:44:14 <dramforever> a list of list of paths. i.e. a list of [list of paths from each subtree]
06:45:41 <trudi> one moment
06:48:25 <trudi> I still am not fully understanding it
06:48:50 <trudi> the type  of map (\ (x, y) -> map (\ z -> x : z) (paths y)) xs
06:49:12 <dramforever> is [[[e]]], list of list of paths.
06:49:24 <dramforever> because you are returning a [[e]] from each map
06:49:34 <dramforever> *from the (\(x, y) ...)
06:49:42 <trudi> is ((e, Tree v e)->[e]) ->[(e, Tree v e)] -> [[e]]
06:50:42 <dramforever> trudi: that's a bit wrong. it should be ((e, Tree v e)->[[e]]) ->[(e, Tree v e)] -> [[[e]]]
06:50:56 <dramforever> see the "->[[e]]"?
06:51:04 <dramforever> That's where you return multiple paths
06:52:10 <trudi> so the inner map is resulting in [[e]]?
06:52:18 <dramforever> yes
06:52:29 <dramforever> that's also the type of (paths y).
06:53:08 <trudi> so the inner map is wrong
06:53:30 <trudi> no it is not ;)
06:53:39 <dramforever> trudi: yeah it's correct
06:53:52 <trudi> so i hav to flatten the map?
06:53:54 <dramforever> the entire expression is correct, it just needs more post-processing
06:54:14 <dramforever> It's easy, but you see, I want to make sure you know what you are doing
06:54:27 <trudi> just one more question
06:54:36 <trudi> the [[[e]]] map
06:54:47 <trudi> will not only contain one item?
06:55:04 <trudi> err i meant [[[e]]] list
06:55:24 <dramforever> not quite
06:55:32 <dramforever> you get an item for each subtree
06:55:55 <trudi> but i just want those leading in a leaf
06:56:25 <dramforever> all of them lead to a leaf
06:57:06 <dramforever> I wonder if you get this: the [[[e]]] is a list of [ list of paths of each subtree, prepended with the edge to the subtree ]
06:57:15 <dramforever> one, for each subtree
06:57:24 <trudi> ah so
06:57:29 <dramforever> get it?
06:57:31 <trudi> i want only thes starting with root
06:57:42 <dramforever> oh, not quite
06:58:07 <dramforever> How about this: what is the return value of the (\(x, y) -> ...)?
06:58:25 <dramforever> what's it supposed to do?
06:59:28 <trudi> when I implemented it, I thought it would retourn a List of Lists of edges
06:59:34 <trudi> so [[e]]]
06:59:43 <dramforever> yes that's right
06:59:44 <trudi> *[[e]]
07:00:13 <dramforever> after the first map, you have a [[e]] for each subtree
07:01:21 <trudi> which than is also put into a list?
07:01:47 <dramforever> yes, that's where the outmost layer of [[[e]]] comes from
07:02:24 <trudi> but will the outmoust map contain of multiple items of type [[e]] or will ther ebe only one?
07:02:41 <dramforever> multiple items. One for each subtree
07:06:14 <trudi> and each element of [[[e]]] starts contains what?
07:06:54 <dramforever> each element contains the paths of the corresponding subtree
07:07:05 <dramforever> prepended with the edge to the subtree
07:07:14 <dramforever> as you did with  "map (\z -> x : z)"
07:07:20 <trudi> yes
07:07:37 <lingxiao> hey all
07:07:47 <lingxiao> would someone like to answer a couple of questions for me over at #coq
07:07:51 <lingxiao> really just one queestion
07:08:22 <trudi> but than
07:08:23 <dramforever> trudi: so you have the answer for each subtree, and already processed it a bit. What do you want to do to combine them?
07:08:55 <trudi> some kind of merge
07:09:19 <dramforever> a very easy kind of merge
07:09:27 <trudi> append?
07:09:31 <dramforever> almost
07:09:33 <trudi> concat?
07:09:37 <dramforever> bingo
07:10:05 <trudi> just concat?
07:10:16 <dramforever> yes
07:10:21 <dramforever> it will work, try it
07:11:06 <trudi> hm 
07:11:32 <trudi> it did work
07:13:44 <trudi> so for a map of [[[1,2,3,4,5],[6,7,8,9]],[[-1,-2,-3],[-4,-5-6]]]
07:13:51 <trudi> what exactly does concat do
07:14:12 <mick_> Hi, I'm a FP noob. What is the equivalent of writing mocks in FP programs?
07:14:43 <dominik_> trudi: it concatenates all the innter maps together
07:14:47 <dominik_> *inner
07:14:51 <dominik_> *lists
07:15:08 <dramforever> > concat [[1,2], [], [3, 4, 5]]
07:15:29 <dramforever> Is it just me, or is lambdabot a bit slow today?
07:16:59 <Lokathor> dramforever, has been for a few days now
07:17:15 <trudi> dreamforever: thank you very kind for the time and endurance :)
07:17:33 <dramforever> :) you're welcome
07:17:52 <dramforever> And you just hinted me, it's probably time to leave
07:18:35 <trudi> I did write an exam yesterday and hadn't time left to complete the exercise. Since then the answer to the question (how to implement paths) was wondereing within my head
07:18:41 <Stoert3beker>  Since then the answer to the question (how to implement paths)
07:18:42 <trudi> thanks for the reliev
07:18:49 <Stoert3beker> woops, sorry
07:19:09 <Stoert3beker> nb: dont use mouse in terminal to highlight stuff while reading
07:19:21 <Hafydd> mick_: what does "writing mocks" mean?
07:22:16 <zomg> Hafydd: sounds like test-doubles (ie. for unit testing)
07:22:50 <lingxiao> anyone here know coq and would like to help me over at #coq?
07:25:42 <saurabhnanda> can anyone help me with this error related to Yesod/Persistent? http://lpaste.net/153411
07:25:51 <saurabhnanda> I'm trying to define my own PersistField for a custom data-type
07:26:55 <Hafydd> zomg: it's a good thing we have the asker of the question here to ask, rather than just guessing.
07:38:22 <tekkkz> Is it possible to declare a new datatype called AnimalType with elements NORMAL, FIRE, WATER ... where every element stands for a number, e.g. NORMAL (=0), FIRE (=1) ... ?
07:38:58 <geekosaur> data AnimalType = ... deriving Enum?
07:39:35 <tekkkz> hm
07:39:40 <tekkkz> let me have a look
07:39:45 <tekkkz> at Enum type again
07:39:45 <geekosaur> if you wanted them to automatically become numbers, then not really (not unless you want to deal with some really obnoxious type inference behavior)
07:40:21 <geekosaur> fromEnum would get you a number from the value
07:40:32 <tekkkz> no i need to do following: I have a string of the type, and i need to calculate a position , so i need the number of that type you understand?
07:40:59 <mauke> fromEnum . read
07:41:07 <geekosaur> ^
07:41:23 <geekosaur> although you probably need a type constraint on read
07:41:57 <geekosaur> fromEnum . (read :: String -> AnimalType)
07:43:15 <tekkkz> OKAY THANKS
07:43:18 <tekkkz> upps sry for caps
07:46:58 <hexagoxel> int-e: lambdabot seems overloaded.
07:50:53 <tekkkz> geekosaur, btw, why read?
07:51:05 <geekosaur> you said you had a String
07:51:17 <geekosaur> presymably this is something like "NORMAL"
07:51:24 <tekkkz> yep
07:51:37 <bernalex> I would suggest readMaybe over read.
07:54:28 <tekkkz> :t read
07:54:41 <lambdabot> Read a => String -> a
07:54:44 <tekkkz> geekosaur, which read do you mean? from which library?
07:55:13 <bernalex> they probably mean read from Prelude. I would suggest using readMaybe instead.
07:55:14 <geekosaur> sorry on phone
07:55:25 <bernalex> readMaybe is in Text.Read.
07:55:52 <tekkkz> ok
07:55:55 <tekkkz> :t readMaybe
07:56:08 <lambdabot> Not in scope: ‚ÄòreadMaybe‚Äô
07:56:10 <geekosaur> so (read :: String -> AnimalType) gets you NORMAL, a constructor for AnimalType; then fromEnum gets a numeric value
07:56:26 <geekosaur> and I meanr reewad but yes, readMaybe would be better if you haven't already vetted the String
07:56:32 <geekosaur> (still on phone)
07:58:11 <saurabhnanda> anyone familiar with the yesod/persistent library? If I'm defining wrappers over the core persistent functions, is there an easier way to write type signatures?
07:58:13 <lingxiao> hey would someone like to answer a question for me over at #coq?
07:58:16 <saurabhnanda> sample -- selectFirst :: (MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => [Filter val] -> [SelectOpt val] -> ReaderT backend m (Maybe (Entity val))
07:58:47 <tekkkz> geekosaur, your idea isn't working: No instance for (Read AnimalType) arising from a use of ëreadí
07:59:11 <geekosaur> yes, you also need to derive Read along with Enum
07:59:23 <geekosaur> generally I will derive (Show, Read, Enum, Bounded) for a type like that
07:59:25 <tekkkz> Read? yeah thought so already when i had a look at hackage
08:00:35 <mauke> ... Eq, Ord
08:00:55 <tekkkz> Eq yes, Ord not necessary for me at this point
08:01:17 <mauke> ... Typeable, Data
08:01:37 <tekkkz> btw, why is read AnimalTpye not enoughgt? why :: String -> AnimalType?
08:01:49 <bernalex> tekkkz: so it knows what to read to
08:01:54 <bernalex> > read "123" :: Int
08:02:03 <lambdabot>  mueval-core: Time limit exceeded
08:02:06 <bernalex> eh
08:02:07 <tekkkz> lol
08:02:37 <bernalex> point is, look at the type of read. it can read String -> anything with a Read instance. it needs to know which instance to choose.
08:03:08 <tekkkz> but why is the instance, e.g. AnimalType, not enought?
08:03:22 <bernalex> tekkkz: oh. it should be.
08:03:32 <tekkkz> nah
08:03:36 <tekkkz> let me have a try again
08:03:41 <bernalex> tekkkz: well not if it is pointfree like above
08:03:56 <geekosaur> tekkkz, how does it know?
08:03:59 <tekkkz> oh it works
08:04:03 <tekkkz> i misspelled
08:04:05 <tekkkz> :D
08:04:05 <bernalex> 'read "123" :: Int' is sufficient; 'read :: Int' otoh makes no sense.
08:04:06 <geekosaur> read does not deciude the type based on what the string looks like
08:04:13 <geekosaur> it decides based on what is requested
08:04:17 <geekosaur> > read "1"
08:04:21 <geekosaur> oh
08:04:29 <lambdabot>  mueval-core: Time limit exceeded
08:04:31 <geekosaur> :t read "1"
08:04:41 <geekosaur> siiigh
08:04:59 <geekosaur> oh, so read "1" --- what type is it? Can't be decided from the string
08:05:31 <geekosaur> not that that is the actual problem, Haskell does nto do dynamic types
08:05:52 <geekosaur> we have to know AnimalType at com,pile time so the right read and right fromEnum can be used
08:05:56 <tekkkz> ahh yeah i understood now
08:05:56 <tekkkz> ty
08:05:59 <geekosaur> sorry still on phone
08:06:12 <tekkkz> thanks
08:06:36 <bernalex> geekosaur: Haskell can have dynamic types. I think you mean something else.
08:06:53 <bernalex> like dynamic dispatch.
08:07:50 <geekosaur> yeh
08:08:01 <geekosaur> sopeaking short, need concentrate on call
08:11:28 <geekosaur> ok, no longer getting questions fired at me over the phone at the same time >.>
08:17:44 * geekosaur was trying to answer questions here while simultaneously explaining to coworkers the complexities of designing an ACL system that a customer has requested. multitasking doesn't quite go that far >.>
08:33:29 <jackhill> join #vertx
08:34:52 <triyo> How would I go about creating a generator in QuickCheck that sets the data range? For instance I want it to be of type [[Int]] that limits the Int to a [1..5] range.
08:41:29 <shapr> Dang, I can't remember Vulpyne's real name, and I want to contact him.
08:46:45 <dmwit> triyo: Make a newtype for `Int` with a custom `Arbitrary` instance, then unwrap it after generation.
08:47:37 <triyo> dmwit: Thanks. I also just tried something along these lines: `generate $ vectorOf 5 (choose (1, 5)) :: IO [Integer]`
08:48:02 <triyo> Just need that first param of vecorOf to not be hardcoded and to vary. 
08:48:10 <triyo> *vectorOf
08:50:44 <triyo> Ok, `listOf` does the trick 
08:53:39 <statusfailed> Was QuickSort the first O(n log n) complexity sorting algorithm?
08:54:02 <Freundlich> QuickSort is O(n^2)
08:55:48 <statusfailed> Freundlich: average case is O (n log n)
08:56:39 <nitrix> Who to contact about lambdabot ?
08:56:47 <nitrix> It's ded.
08:57:15 <statusfailed> > putStrLn "cogito ergo sum"
08:57:26 <lambdabot>  mueval-core: Time limit exceeded
08:57:36 <statusfailed> wat
08:57:38 <quchen> Cale, I think.
08:57:48 <nitrix> Cale: ping, lambdabot died.
08:58:13 <c_wraith> I think int-e runs lambdabot now
08:58:26 <nitrix> int-e: ping, lambdabot died ;-;
08:58:26 <c_wraith> @version
08:58:29 <lambdabot> lambdabot 5.0.3
08:58:33 <lambdabot> git clone https://github.com/lambdabot/lambdabot
08:59:01 <c_wraith> not dead, but it looks like the VM it's running on is overloaded. 
08:59:27 <ackthet> the lambdabot github readme needs a ton of work
08:59:29 <ackthet> imo
08:59:42 <nitrix> c_wraith: The poor robot needs help.
09:01:57 <mauke> quchen: no, not Cale
09:04:06 <quchen> statusfailed: Since O(n^2) is a superset of O(n log(n)), Quicksort is O(n^2) even in the average case.
09:04:25 <quchen> It's true that it's also (or "even") O(n log(n)) of course.
09:06:27 <dmwit> Next you'll be telling people that if they care about constants that's okay, just don't use O.
09:06:44 * dmwit mumbles something deprecatory about "crazy theoreticians"
09:06:53 <c_wraith> most algorithms are O(n^n) 
09:07:53 <statusfailed> huh, I guess I actually have no idea what "average case" means
09:08:08 <c_wraith> well. maybe I should limit that to "most published algorithms" 
09:08:14 <dmwit> No, you understand average case. It's O notation you're confused about.
09:09:27 <statusfailed> Ehm, well it's either both or just average case, because I definitely don't understand average case
09:09:33 <statusfailed> Is it defined in terms of Big-O or not?
09:10:05 <dmwit> no
09:10:33 <dmwit> You just define a probability distribution over inputs, and take the expectation of running time.
09:11:12 <statusfailed> and then say it's in a particular complexity class
09:11:33 <dmwit> I... don't think complexity classes are related.
09:11:39 <dmwit> You just say it has a particular complexity.
09:11:41 <statusfailed> err, sorry I mean like "O(n log n)"
09:11:42 <statusfailed> yeah that ^
09:12:04 <dmwit> I mean, you *can* say that if you want. But you're definitely not obligated to.
09:12:14 <dmwit> You can just state the value if you want.
09:12:18 <statusfailed> (actually, aren't complexity classes just names for particular.. complexity... values(?))
09:12:38 <dmwit> Complexity classes are a bit different, I think? e.g. NP is a complexity class
09:13:17 <dmwit> Like, a complexity class is a collection of problems, not a collection of runtimes.
09:14:39 <statusfailed> dmwit: ooh, I see
09:14:51 <statusfailed> so, the set of problems that can be solved in a certain time/space
09:14:51 <statusfailed> right
09:18:12 <Zekka|Sigfig> it looks suspiciously like no one actually said this, so just being clear : Theta(n) means ‚Äúin the long run, always takes on the order of n time/memory/etc.‚Äù (it takes within-a-particular-pair-of-constant coefficients of n) ‚Äî Omega(n) says ‚Äúit won‚Äôt take less‚Äù and O(n) says ‚Äúit won‚Äôt take more‚Äù
09:19:08 <dmwit> Theta, Omega, and O actually mention nothing at all about time or memory.
09:19:31 <Zekka|Sigfig> dmwit: No, they‚Äôre not *specific* to that. In practice that‚Äôs what people frequently use them to talk about
09:19:46 <dmwit> This is another common misconception. It just so happens that we almost always use it for functions that describe runtimes, but they can be used for any real-valued functions and probably generalized away from reals without too much trouble.
09:20:08 <Zekka|Sigfig> I can rattle off a formal definition but I don‚Äôt think it would be useful to people who just want to understand why the pedants are telling them ‚Äúit‚Äôs not O(n log n), it‚Äôs average-case n log n‚Äù
09:23:29 <edwardk> O(f(n)) just means that there exists a C such that as n -> infinity, the result is bounded above by Cf(n). Technically big-O notation can be used to talk about limits as you go to 0 as well, Knuth is even a big proponent of teaching calculus that way.
09:24:48 <dmwit> The notation itself is atrocious, of course. We should say $f \in O(g)$, not this ridiculous $f(n) = O(g(n))$.
09:27:18 <niez> hi, is there any library that with some TH magic generates field names? for example from: data MyType = { field1 :: String, field2 :: Int } I want: data MyTypeField = Field1 | Firld2 or something like that
09:28:55 <dmwit> niez: lens does something similar.
09:29:30 <dmwit> niez: Given `data MyType = { _field1, _field2 :: String }` it will give you values `field1` and `field2` that can be used to both read and write the appropriate fields.
09:29:44 <niez> dmwit, but only internally, no? does it expose some of this functionality?
09:29:46 <dmwit> niez: Though you wouldn't be able to introspect lenses quite as easily.
09:30:06 <danza> i think that this is a task for generic programming, isn't it?
09:30:06 <dmwit> niez: What do you mean by "expose"? It doesn't hide anything as far as I know.
09:30:09 <quicksilver> I think he wants an 'enumerated' type which represents his constructors
09:30:18 <glguy> (fields)
09:30:19 <niez> quicksilver, yes
09:30:23 <quicksilver> no, represents his fields, sorry
09:30:31 <quicksilver> I've wanted it for constructors before, but never for fields.
09:30:59 <dmwit> quicksilver: The question is what he's going to do with that representation. Most (I agree: not all) of the things I can think of to do with the representation are also served well by lens.
09:31:06 <quicksilver> lens gives you a way of referring to fields but not one that you can (for example) put in a list or a map
09:31:15 <quicksilver> because you can't get Eq or Ord instances for them
09:31:18 <niez> well, it will be easy to write TH function for my use case, but I'm wondering id there exist allready something for that
09:31:25 <Zekka|Sigfig> dmwit: How about persisting a ref to a field?
09:31:45 <dmwit> Right. Introspecting is slightly harder, as I believe I mentioned.
09:32:19 <dmwit> But I'd like to hear what niez wants to do with them, not what quicksilver and Zekka|Sigfig are guessing he wants to do.
09:33:01 <niez> dmwit, I want to use that in servant api type description for query parameters
09:33:26 <niez> dmwit, for example I want sorting
09:33:33 <dmwit> Okay. I don't know much about servant, but I would bet lens will not serve that need well, and I don't know of anything that does exactly what you ask.
09:34:42 <niez> dmwit, here is an example from srvant docs: http://lpaste.net/153421
09:35:17 <niez> dmwit, I want the 'SortBy' type to be auto generated
09:35:41 <niez> dmwit, based on 'User' type
09:36:35 <niez> dmwit, does it make sense what I'm tryig to do?
09:36:54 <dmwit> This doesn't actually tell me what I would need to know to decide whether lens would work here, since it says almost nothing about how the `SortBy` type is consumed in the library.
09:37:22 <dmwit> Yes, it makes sense. Yes, it should be pretty easy with TH.
09:37:29 <lpaste> glguy pasted ‚ÄúFor niez‚Äù at http://lpaste.net/153422
09:38:21 <niez> glguy, thanks
09:38:24 <Zekka|Sigfig> I would feel bad recommending him lens if this was the only thing he would be using it for
09:40:30 <niez> it will be used like: myEndpointHandler :: SortBy -> Server UserApi (servant serializes that QueryParam to SortBy value and I can do whatever I need based on that value, sorting in this example - in a type safe way)
09:51:34 <joeyh> !h <- hasher <$> L.readFile file
09:51:47 <joeyh> somehow adding the ! there makes it malloc the whole file size
09:52:01 <joeyh> can anyone see how that could be? This is lazy bytestring..
09:53:38 <joeyh> also while I have root caused it to that in my program, when I build an isolated test case, it doesn't happen
09:53:54 <joeyh> some kind of failure of stream fusion or something, maybe?
09:54:44 <mniip> lazy bytestring doesn't do what you think it dos
09:57:02 <joeyh> well, hasher is L.ByteString -> String, so I don't see how forcing it would keep it buffered
10:12:41 <x77686d> Maybe a little OT but does anybody know if there's name for an infinite string of this form: "abaabbaaabbb..."
10:13:27 <runeks> Why can't I do this? http://pastebin.com/c5UvZhg9
10:14:31 <runeks> "Couldn't match type ‚Äòa‚Äô with ‚ÄòPromissoryNoteOrder‚Äô" But 'a' IS a PromissoryNoteOrder, is it not?
10:14:37 <monochrom> why is pastebin redacting your string literal?
10:15:31 <runeks> monochrom: I set it to Haskell highlighting. Perhaps that's how it looks.
10:21:02 <djbeau> runeks: your function has to be able to return *any* a - literally
10:21:12 <djbeau> the caller gets to decide what 'a' is
10:22:00 <djbeau> the signature of idToDeserializer is really 'forall a . MessageType a => Int -> Get a'
10:22:01 <pdxleif_> a is something that has a PromissoryNoteOrder instance
10:22:17 <djbeau> (I should have said "any a which is an instance of MessageType")
10:23:35 <djbeau> runeks: are you supposing that since PromissoryNoteOrder is the only instance of MessageType, that the compiler should infer that 'a' must be PromissoryNoteOrder?
10:25:06 <runeks> djbeau: No I think I get it now.
10:25:10 <runeks> Thanks :)
10:25:15 <djbeau> np
10:26:32 <haskell> I'm having trouble organizing all of my classy-lens classes.. anyone know of a project that uses them extensively that I can refer to?
10:27:50 <broma0> I'm having trouble organizing all of my classy-lens classes.. anyone know of a project that uses them extensively that I can refer to?
10:27:54 <broma0> I'm having trouble organizing all of my classy-lens classes.. anyone know of a project that uses them extensively that I can refer to?
10:28:49 <runeks> So what would be a good way to deserialize a type "MessageContainer a" where the first byte read determines the type of the 'a' to be deserialized? I need to read a byte, and then get the deserializer function for the relevant type, in a pretty way, preferably.
10:30:32 * hackagebot lens 4.13.2.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.13.2.1 (EricMertens)
10:32:19 <dedgrant> runeks: There's no getting away from the fact that the type will have to be concrete. For instance, if a call site is expecting a concrete type Foo, it can request Foo, and the deserializer can check whether the header is has the correct constant to identify a Foo.
10:32:56 <dedgrant> runeks: There are other strategies as well.
10:41:31 <runeks> Now that I think of it, that makes perfect sense.
10:44:06 <runeks> I'm thinking I will have to read that byte, and then pass the rest of the byte stream on to the appropriate deserializer for the type in question.
10:47:11 <runeks> I guess I was hoping I could catch the logic in a generic way with the type system, rather than inside a function.
10:48:59 <dedgrant> runeks: Well if it suits your model, you can write a simple AST of sorts and have the caller provide the parser for the data.
10:50:14 <runeks> dedgrant: I think I will try out the simpler model to begin with.
10:50:21 <dedgrant> runeks: It's a slightly more abstract way to interpret of the same problem.
10:52:44 <dedgrant> That's cool.
11:25:33 * hackagebot aws-route53 0.1.2.2 - Amazon Route53 DNS service plugin for the aws package.  https://hackage.haskell.org/package/aws-route53-0.1.2.2 (DavidTerei)
11:30:33 * hackagebot memcache 0.1.0.1 - A memcached client library.  https://hackage.haskell.org/package/memcache-0.1.0.1 (DavidTerei)
11:45:34 * hackagebot folds 0.7.1 - Beautiful Folding  https://hackage.haskell.org/package/folds-0.7.1 (EricMertens)
12:06:35 <John[Lis`> if I say let avariable = 1, is avariable a monad and does it have state?
12:08:33 <Hafydd> John[Lis`: no. It does not make any sense to say that a value (or a variable) is "a monad". That's something you can say about a type (or a type-class instance). It's unclear what you mean by "state," but the answer is also probably negative.
12:09:24 <John[Lis`> by state I mean state as in the sense that object oriented langauges contain objects which have state and therefore produce lots of errors
12:11:05 <Cale> John[Lis`: A monad is something at the type level -- specifically, it's a type constructor M for which there exists an implementation of the functions  return :: a -> M a  and  (>>=) :: M a -> (a -> M b) -> M b  (and such that these satisfy a few conditions)
12:11:07 <Hafydd> John[Lis`: if this answers your question, the binding "let avariable = 1" (which I assume is in a do block) is immutable, so it doesn't have "state" in this sense; but it can be shadowed by another binding with the same name in a more specific lexical scope (e.g. below it in the same do block).
12:11:57 <Hafydd> If you set a flag in GHC like -Wall, you will be warned about such occurrences, unless the name starts with an underscore (signifying that it is intended to be shadowed).
12:12:20 <Cale> John[Lis`: If you define avariable = 1, then either numeric defaulting happens and you end up with avariable being an Integer, or the most general type it can have is (Num a) => a which means that it can have any type which is an instance of Num.
12:12:51 <Cale> John[Lis`: In either case, the value is fixed -- that equation will continue to hold so long as avariable remains in scope.
12:12:53 <John[Lis`> BUt there are no monads in the memory management or anything along the way to compile that avariable = 1
12:13:27 <Cale> Don't worry about monads. Monads actually have very little to do with statefulness in general. The list type constructor is a monad, for example.
12:14:16 <Cale> If you defined, say, avariable = product [1..100] then there would be some rewriting and mutation under the covers the first time that the value of avariable gets used
12:14:20 <Hafydd> John[Lis`: it could be that an implementation of Haskell did in fact use Monads for "memory management", but I can't imagine what use that information would be to you.
12:15:13 <Cale> When the product [1..100] expression gets evaluated, the code pointer that avariable represents will be updated to point at a shorter piece of code which just returns the result of that evaluation
12:15:21 <Hafydd> John[Lis`: for the semantics of let bindings in do statements, see: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
12:15:56 <John[Lis`> I am coaxing the hypothetical potentiality of a functional c
12:16:12 <John[Lis`> perhaps not purely functional
12:16:33 <refefer> anyone know how to cross compile a binary to OS X from linux?
12:17:25 <John[Lis`> what sort of binary are we discussing here?
12:17:29 <Cale> John[Lis`: I think that a "functional C" would be a very different language from C itself.
12:17:55 <geekosaur> refefer, not without violating a bunch of Apple licenses, at minimum
12:18:00 <John[Lis`> if you can get lambdas in there you should be good
12:18:03 <geekosaur> you can;t even run OS X in a VM :(
12:18:09 <geekosaur> (legally)
12:18:34 <refefer> geekosaur: bah.  is it fairly easy for folks to install stack on OSX?
12:18:38 <Cale> It's hard to even really express what the goals would be there -- yes, you could just add some sort of lambdas and call it a day, but C makes it normal to do things which spoil a lot of the nice properties of functional languages.
12:18:55 <refefer> I run linux everywhere and have only bad experiences getting anything working correctly on apple software
12:19:11 <Cale> The main thing which Haskell gives you isn't lambda, it's the ability to understand what code does by substituting parts of expressions for their definitions
12:19:39 <Cale> Lambda is a good start though
12:19:40 <geekosaur> it should be just a download, like for any other platform. that said I haven't actually used stack on OS X, by the time stack was a thing I was mostly migrated to Linux locally
12:20:11 <Hafydd> our expert consultants will give you end-to-end support in deploying lambda across your enterprise programming language environment
12:20:35 <John[Lis`> as long as you have lambdas you can in theory do things less painfully than in c without lambdas
12:20:36 <Hafydd> years of experience have taught us that lambda is what a programming language needs to succeed
12:20:41 <Cale> We've understood how to implement lambdas reasonably efficiently for decades now, and we've understood their importance and usefulness to abstraction since before electronic computers existed. It's really not very excusable not to have it.
12:21:22 <geekosaur> even C++ has them after a fashion these days
12:21:27 <John[Lis`> or simply, it is very excuseable to have it
12:21:36 <Cale> Dually, yeah
12:21:54 <John[Lis`> I think C++ gets them through objects like c# though
12:21:59 <geekosaur> nope
12:22:01 <John[Lis`> correct me if I am wrong but they use something called linuq
12:22:02 <John[Lis`> linq
12:22:26 <John[Lis`> also what is the mathematical concept behind lambda
12:22:39 <John[Lis`> what it's it's implementation in a post-calculus world called
12:22:41 <Hafydd> LINQ in C# is a useful abstraction, but I believe it's orthogonal to anonymous functions.
12:23:06 <geekosaur> [](params){body} roughly, with extra stuff if there's a non-inferrable return type or to modify how it captures
12:23:40 <jle`> what's a post-calculus world?
12:23:49 <Hafydd> John[Lis`: what makes you think there's a mathematical concept behind anonymous functions? Although the colloquial "lambda" makes a reference to Alonzo Church's lambda calculus, the idea itself is not very complicated.
12:23:56 <John[Lis`> I mean what would they call lambdas some time after isaac newton died
12:24:42 <jle`> what makes you think there is a connection between anonymous functions and isaac newton?
12:25:24 <jle`> i...can't imagine that there is any
12:25:40 <Hafydd> The notation in mathematics for expressing a function without giving it a name (e.g. x 
12:25:44 <z16_> C++ needed to use lambdas through objects before C++11 (through functors)
12:25:57 <jle`> Hafydd: oh neat
12:25:58 <z16_> Since C++11 they have native lambda functions and a dedicated std::function type
12:26:10 <Hafydd> (e.g. x |-> x^2) probably existed before the lambda calculus, but I doubt there was a special name for it.
12:27:27 <z16_> And as was said, C#'s LINQ is an abstraction layer on top of lambda functions
12:27:40 <jle`> John[Lis`: in any case, anonymous functions don't really have anything too deep in common with newton's calculus
12:27:45 <z16_> I don't know of any production-grade language these days that does not support lambda functions
12:27:47 <dedgrant> John[Lis`: I think the lambda calculus was invented in the 1920s, no?
12:27:50 <z16_> Even Java has them since version 8
12:28:14 <geekosaur> C is still a production language, sadly
12:28:42 <dedgrant> John[Lis`: Seems to back this claim up: http://www.users.waitrose.com/~hindley/SomePapers_PDFs/2006CarHin,HistlamRp.pdf   --- Prehistory section there as well
12:28:47 <Hafydd> John[Lis`: wait, are you conflating the lambda calculus with the infinitesimal calculus? The word "calculus" is all they have in common, and just refers to formal systems of performing calculations.
12:28:57 <z16_> geekosaur: Eh... only Linus Torvalds still thinks so :)
12:29:09 <bobajett> how can I "break" up lists like [1,5,9,2,3] into ([1,5,9], [2,3])? Where the criteria to break up the list is that the first part is an increasing sequence. In other words when the list stops increasing monotonically, we break?
12:30:20 <tekkkz> I have a list: [1.0,0.5,0.5,2.0,2.0,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,1.0] ... how to filter it so that I receive a new list with the position numbers of the elements 2.0? e.g. for this example list i wanna receive [4,5]
12:30:21 <tekkkz> ?
12:30:42 <dedgrant> bobajett: Is Data.List.Split useful to you? https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
12:31:09 <Jinxit> tekkkz: zip it with [0..], filter it
12:31:39 <Hafydd> > let xs = [1.0,0.5,0.5,2.0,2.0,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,1.0] in [i | (i,x) <- zip [0..] xs, x == 2.0]
12:31:47 <dedgrant> bobajett: one option would be to 'zip xs (tail xs)' and apply splitWhen..
12:31:52 <tekkkz> thanks
12:32:06 <bobajett> dedgrant: Im a noob, and the trouble I have with this question/function is that "break" or "splitOn" usually take one element on which they decide to do the break and split, where as I need to compare two consecutive elements of the list.
12:32:08 <mnoonan> there is also elemIndices in Data.List
12:32:25 <jle`> bobajett: you can do it on zip xs (tail xs), maybe
12:32:37 <jle`> > let xs = [1,5,9,2,3] in zip xs (tail xs)
12:32:38 <mnoonan> > elemIndices  [1.0,0.5,0.5,2.0,2.0,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,1.0]
12:33:12 <Hafydd> (But beware that == for floating point types is not reliable for arithmetic results.)
12:33:14 <bobajett> jle`: dedgrant - cool that gives me something to work with.
12:33:16 <jle`> bobajett: then you can use break on that
12:33:28 <dedgrant> bobajett: kk
12:33:30 <jle`> oh i didn't even notice it being mentioned before
12:34:38 <dedgrant> jle`: I didn't even know Data.List.break existed :)
12:37:02 <bobajett> looking at the Data.List page - what does this mean? "Note that tails has the following strictness property: tails _|_ = _|_ : _|_
12:37:52 <Cale> John[Lis`: Well, the lambda calculus was originally constructed as a system of mathematical logic in the 1930s by Alonzo Church
12:38:38 <Cale> John[Lis`: There's a connection between how lambda abstraction and function application work together and how proving implications and using modus ponens works in mathematics.
12:39:58 <Cale> Church's original lambda calculus was not very good as a logic regarding truth, because it was Turing complete -- you could write the Y combinator which would let you ask for a fixed point of "not".
12:40:08 <Cale> (and all sorts of other problematic things)
12:40:18 <hpc> > null []
12:40:22 <Cale> Type systems of various sorts eventually fixed that problem.
12:40:31 <hpc> lambdabot?
12:40:41 <hpc> ?lagcheck
12:40:51 <hpc> bobajett: anyway
12:41:06 <hpc> null (undefined : undefined) = false
12:41:10 <hpc> null undefined = undefined
12:41:13 <hpc> so
12:41:18 <hpc> null (tails undefined) = false
12:41:40 <hpc> but head (tails undefined) and tail (tails undefined) are both also undefined
12:43:02 <hpc> null [] = True
12:43:08 <hpc> null (_:_) = False
12:43:11 <hpc> is the definition of null
12:43:26 <hpc> note it inspects the spine of the list but not its elements
12:46:43 <tekkkz> when i have a list ["hello", "world"] ... is it possible to print all strings of this list with putStrLn via mapping: map (\x  -> putStrLn x) ["hello", "world"] ? no it isnt .. any idea how to do that?
12:46:46 <tekkkz> > map (\x  -> putStrLn x) ["hello", "world"]
12:46:58 <lambdabot>  mueval-core: Time limit exceeded
12:47:34 <lyxia> bobajett: tails produces at least one cons even if the argument is undefined
12:47:49 <lyxia> tekkkz: mapM_
12:47:53 <lyxia> traverse_
12:47:55 <hpc> tekkkz: when you map that over the list, you get
12:48:00 <hpc> :t map (\x  -> putStrLn x) ["hello", "world"]
12:48:01 <tekkkz> :t mapM_
12:48:10 <hpc> D:
12:48:13 <tekkkz> lol
12:48:29 <hpc> well, you get [IO ()]
12:48:34 <tekkkz> ok
12:48:45 <tekkkz> but I need IO ()
12:48:46 <hpc> and then sequence (when used in this particular context)
12:48:52 <hpc> :: [IO ()] -> IO ()
12:48:56 <hpc> so you would sequence the resulting list
12:48:59 <hpc> except!
12:49:09 <hpc> er
12:49:12 <lyxia> sequence_ :)
12:49:16 <hpc> that
12:49:22 <hpc> except!
12:49:24 <tekkkz> hm up to i receive [IO ()] i've understood what you mean, but then ... explain more detailedp lease
12:49:31 <hpc> mapM_ = map, then sequence
12:49:41 <tekkkz> ok
12:49:44 <hpc> replace "map" with "mapM_" and you'll have what you want
12:50:16 <hpc> there's also a function, "forM_" which has the arguments reversed
12:50:35 <hpc> put some thought into it and you'll see why that's handy
12:50:51 <hpc> that's your extra credit homework
12:51:45 <hpc> this is a lot easier when lambdabot is working
12:52:25 <tekkkz> yeah
12:52:36 <tekkkz> thanks, works fine with mapM_
12:52:52 <tekkkz> ill have a detailed look later, now focusing on finishing the main functions
12:52:53 <tekkkz> thanks
13:00:37 * hackagebot hlint 1.9.30 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.30 (NeilMitchell)
13:07:15 <acertain> is there any way to get a see variables from the call stack in ghci's :history ?
13:10:21 <mniip> what do you mean call stack
13:10:33 <mniip> aaaand what do you mean variables
13:12:06 <orion> What's the status of the "make Haskell strict" debate?
13:12:18 <acertain> yeah, :history isn't really what I want
13:12:27 <mniip> orion, was there ever one?
13:12:33 <mniip> are you talking about StrictHaskell?
13:12:37 <acertain> is there a way to :back <n> (repeat :back n times)?
13:12:44 <mniip> in which case that's not a debate
13:12:49 <mniip> just a compiler flag
13:12:53 <mniip> or rather, extension
13:14:31 <acertain> of go to a entry in :history by number
13:14:34 <acertain> *or
13:22:57 <nitrix> Does that instantly gives you SML :P ?
13:23:36 <orion> MAybe I'm mistaken. Was there a debate about making IO strict?
13:23:45 <Cale> acertain: The awkward thing is that there isn't *really* a call stack, and so anything that looks like one is a bit fake.
13:25:22 <sm> yeah, "seeing a stack trace" is really quite complicated in haskell
13:26:42 <sm> but if you read the GHCI debugger's docs, you'll find useful things
13:28:17 <sm> or did you see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html#tracing already ?
13:28:54 <sm> oh :history, I guess you did
13:34:21 <lynn_> How come stack traces are hard in Haskell?
13:34:35 <acertain> laziness and tail calls
13:35:34 <glen> Can anybody help me out?  I'm trying to evaluate an expression in ghci but its giving me the following error: `No instance for (transformers-0.4.2.0:Data.Functor.Classes.Show1 IO) arising from a use of ‚Äòprint‚Äô`
13:36:43 <Cale> glen: Try :t <that same expression>
13:37:11 <Cale> Same error?
13:37:41 <glen> cale: No, it gives me the type of the expression correctly
13:37:54 <Cale> What's the type?
13:38:59 <glen> Cale: ExceptT String IO (Value, LispEnv)
13:39:20 <Cale> glen: Yeah, that's not printable. You'll want to run the ExceptT transformer
13:39:36 <Cale> So probably your expression type checks, there's just no way to turn that into a String to display it
13:39:58 <Cale> If you get it as far as an IO action, ghci will notice that and execute the action, and print its result automatically.
13:40:11 <glen> Cale: Oh, gotcha
13:44:42 <lpaste> miscyb pasted ‚ÄúAeson errors‚Äù at http://lpaste.net/5625372873800548352
13:44:45 <yeyeyo> hey! 
13:45:13 <miscyb> i am trying to use aeson's featurethat generates default from/toJSON instances and i go these errors
13:45:26 <yeyeyo> i wrote a piece code that try to find moves of hanoi towers
13:45:35 <yeyeyo> but i dont know it is true or wrong
13:45:38 * hackagebot hs-duktape 0.1.2 - Haskell bindings for a very compact embedded ECMAScript (JavaScript) engine.  https://hackage.haskell.org/package/hs-duktape-0.1.2 (myfreeweb)
13:45:44 <MitchellSalad> can someone explain how `reflection` solves the implicit configuration problem? it seems like if I have some "foo = take n [0..1]", where n is implicit, how is "foo p = take (reflect p) [0..1]" any better than "foo n = take n [0..1]"
13:45:45 <yeyeyo> what should i do?
13:45:47 <miscyb> saying that the names are not in scope, anyone know why?
13:46:03 <dedgrant> Cale: Hey a few days ago you shared an implementation of a function to generate all set partitions. It led me down some interesting tracks in discrete math, and I ended up in stirling number land.. currently interested in methods for sparse sampling of set partitions. Just want to say thanks for the direction..
13:46:06 <johnw> MitchellSalad: because the dependency might be in places where you can't add parameters
13:46:14 <johnw> like inside of a Monoid instance, for example
13:46:15 <Cale> dedgrant: nice!
13:46:39 <Cale> dedgrant: I can give you some possibly relevant things to read... just give me a moment
13:46:46 <dedgrant> Cale: Much obliged
13:47:01 <Cale> (perhaps not directly, but stuff on related combinatorics)
13:47:19 <MitchellSalad> so with reflection, I can write a function like "foo m = m <> m <> m", and have the caller control its behavior?
13:47:29 <dedgrant> Cale: Definitely.. I think I'd like to find a good beginners course on discrete math to audit
13:47:36 <miscyb> if i happen to open ghci and import Data.Aeson it works, but for some reason stack is mad
13:47:52 <johnw> MitchellSalad: you can reify your 'n' within your definition of mappend
13:47:58 <johnw> there's an example in the tarball that does this
13:48:16 <johnw> (or I guess, reflect your 'n')
13:49:28 <MitchellSalad> hm, ok. not sure if I quite understand. I should poke through the example code, I guess. it's dense
13:50:02 <MitchellSalad> johnw: is modifying typeclass methods at runtime the canonical use case?
13:51:23 <johnw> I wouldn't go that far, it's just a rather compelling one, since there's no other way to accomplish that without using implicit arguments, and they have their own problems
13:52:07 <johnw> the basic idea is that the type of your constraint is rich enough that you can derive a value from it; in runtime terms, you're tucking data into the instance dictionary that you can then extract
13:53:24 <MitchellSalad> right, but who cares if your constraint is so rich that it contains data, if you could just pass the data in in the first place ;)
13:53:32 <MitchellSalad> your point about not always being able to do that still stands, though
13:53:33 <johnw> but sometimes you can't
13:53:46 <johnw> you might have no control over the place where you want to inject the value, other than a constraint on the type being used
13:54:00 <MitchellSalad> can you give an example?
13:54:34 <johnw> does this help? https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
13:54:47 <johnw> and also https://www.reddit.com/r/haskell/comments/3hw90k/what_is_the_reflection_package_for/
13:55:33 <MitchellSalad> i actually just read over austin's tutorial, but i'd like to know if there are useful and simple things reflection can accomplish that doesn't involve unsafe coercing constraints
13:56:27 <johnw> the unsafeCoerce is principled, and I think it can just be coerce at some point
13:56:48 <johnw> because all its doing is taking advantage of the equivalence between a typeclass constraint, and passing a dictionary as an argument
13:57:02 <MitchellSalad> i don't mean the unsafeCoerce inside of reify, i mean the monoid example later on in the article
13:57:07 <johnw> ah
13:57:51 <johnw> another article http://comonad.com/reader/2009/clearer-reflection/
13:58:07 <johnw> note that I've never needed this package in reality
13:58:11 <johnw> but edwardk uses it
13:58:14 <tekkkz> i have formatted my output like following ªputStrLn $ ("\t\t" ++ show (fst typeSpecAtk) ++ "\t-> " ++ show x ++ "\t: 2.0")´ but it generates some formatting issues: https://bpaste.net/show/1f125e487776 how to fix that?
13:58:33 <MitchellSalad> that's exactly what I'm trying to figure out - what *actual* real world code is it used in
13:58:42 <MitchellSalad> it has about 100k hackage downloads, somehow
13:59:05 <johnw> I think it's the sort of thing that when you need it, it'll be perfect; but until that day, you might never need it
14:03:45 <MitchellSalad> :) probably
14:05:06 <thoughtpolice> MitchellSalad: A real example I had recently, is that I actually needed the original example from the "Implicit Configurations" paper, which was modular numbers to implement an elliptic curve diffie hellman algorithm.
14:05:34 <MitchellSalad> and reflection simply saves you from using the wrong modulus, yeah?
14:06:18 <thoughtpolice> Yes, but it also means I don't have to specialize my modulus and the instance to any particular prime or whatever. I can just choose it at runtime; in this sense, it provides a type-class instance that is dispatched at compile time, but dependent on a runtime value.
14:07:16 <MitchellSalad> and is the basic idea to parameterize your type classes by 's', with Reifies s Foo as a superclass?
14:07:18 <thoughtpolice> This API has some trade offs, but overall I was quite happy with it. And thanks to those instances, my 'point doubling' and 'point addition' routines for elliptic curve points are literal copy/pastes of some text I found on the internet implementing the algorithms in psuedo code.
14:07:45 <thoughtpolice> (Not even a joke, I actually copy/pasted and just changed the upper-case variable names to lower-case ones)
14:08:21 <thoughtpolice> MitchellSalad: Yes. I have an alias that looks like 'type Modulo s = Reifies s Integer', and then I have 'instance Modulo s => Num (Mod s) where ...'
14:08:38 <MitchellSalad> i see. ok, just like from the paper
14:08:59 <MitchellSalad> seems super powerful, I wonder if I can sneak it into my day job, somehow
14:09:38 <MitchellSalad> to better understand how it works and also put my coworkers through hell
14:10:19 <johnw> "You've been Kmetted"
14:10:26 <thoughtpolice> Once you wrap your head around the basic idea that 'reify' just creates a constraint (which we think of as a type) out of a value (which we think of as, uh, a value), and we can get that value back with 'reflect', you can wield it fairly easily, keeping in mind the rank2 thing.
14:11:35 <thoughtpolice> The fact we tend to think of constraints as some purely-compile time thing is part of the confusion, I imagine; the compiler always translates 'f :: C a => ...' into something like 'f :: C a -> ...', so it moves the constraint "across the =>", so it's just abusing this implementation detail. Type classes are always dispatched based on a value, although we
14:11:36 <thoughtpolice> 'think' of them as being purely driven at compile time.
14:12:25 <thoughtpolice> Mostly because it's not something exposed to the surface, for good reason. The rank 2 thing is almost the more difficult aspect of the whole API, once you have this in mind.
14:12:49 <MitchellSalad> yeah, I do understand how it works internally, and also I understand the rank 2 type
14:13:06 <thoughtpolice> Because once you begin parameterizing things over 'Modulo s' in the example above, you often need to unify other 's' type variables with that quanitifed 's' from 'Modulo'. So you end up having to use ScopedTypeVariables and local clauses a lot, IME.
14:13:11 <MitchellSalad> thoughtpolice: are you austin seipp?
14:13:22 <thoughtpolice> I managed to keep it pretty clean, but abstracting is uglier in some of my attempts.
14:13:35 <thoughtpolice> MitchellSalad: The one and (presumably) only!
14:14:05 <johnw> thoughtpolice plays Austin on TV
14:14:13 <thoughtpolice> IRL TV
14:14:21 <MitchellSalad> ah, thought so :) I just read over your reflection tutorial on SoH. Made it about 75% of the way through before coming to IRC to be spoon fed
14:14:27 <thoughtpolice> That's the name of my new VC startup, dibs.
14:14:55 <thoughtpolice> MitchellSalad: Uh, truthfully someone came up to me recently in NYC and asked me about this tutorial, and I had forgotten a lot of the later magic :)
14:15:07 <thoughtpolice> It was all in my head at one point, though.
14:15:13 <MitchellSalad> haha
14:15:29 <MitchellSalad> that's encouraging :)
14:15:37 <Rembane> Now I go all curious. what's the URL to the tutorial?
14:15:52 <Rembane> Hang on, it was in the backlog. Thanks! :D
14:15:54 <MitchellSalad> Rembane: https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
14:16:04 <MarcelineVQ> most people that come up to me in NYC want to ask about my spare change
14:16:19 <Rembane> MitchellSalad: Thanks again!
14:27:04 <del> Quick question regarding curried functions:  Curried functions are what make partial function evaluation possible, yes?
14:27:27 <del> curryied*?
14:28:43 <shachaf> I don't think partial evaluation has much to do with it.
14:29:12 <byorgey> del: curried functions make partial function evaluation syntactically convenient.
14:29:22 <byorgey> but you can perfectly well have partial application without currying.
14:29:30 <siriusbtx> I learned the basics of haskell but never came much further than programming some basic math stuff. Do you guys think programming ai bots(https://www.codingame.com) is a good way improve my haskell skills?
14:29:46 <byorgey> sorry, partial function *application,  not partial function evaluation
14:29:48 <shachaf> byorgey: Wait, partial evaluation and partial application aren't the same thing.
14:29:50 <byorgey> partial evaluation is something else
14:29:54 <byorgey> yes, sorry
14:30:08 <shachaf> "partial application" isn't even really a thing in Haskell.
14:30:13 <zomg> siriusbtx: I think programming anything as long as it's nontrivial would help learn a new lang :) So that certainly sounds like it would help
14:30:17 <Profpatsch> You certainly know about the Haskell Community Report https://www.haskell.org/communities/11-2015/html/report.html
14:30:18 <byorgey> I assume (perhaps wrongly) that del is actually asking about partial application and just used the wrong term.
14:30:25 <shachaf> It's more something going on in your head than something going on in the language.
14:30:33 <del> byorgey: yes
14:30:37 <siriusbtx> zomg: my problem with haskell I mostly get stuck trying real stuff :p
14:30:43 <Profpatsch> We‚Äôve got a Meetup group in Augsburg and want to make a contribution to that.
14:30:53 <byorgey> shachaf: well, that's true.  I guess the way to say it is "with currying, you don't even need partial application".
14:30:55 <Profpatsch> Does anyone here know whom to write to?
14:31:07 <shachaf> byorgey: ddarius had a good definition of partial application.
14:31:11 <byorgey> i.e. you get all the benefits of partial application in other languages, without needing it to be a speical thing at all.
14:31:14 <shachaf> @quote partial.application
14:31:17 <lambdabot> ddarius says: (f x) is a partial application iff f x == (curry (uncurry f) x)
14:31:23 <zomg> siriusbtx: yeah had the same problem :) Just gotta start from somewhere and can always ask for help here
14:31:40 <byorgey> shachaf: I like that.
14:31:53 <siriusbtx> zomg: do you know google hashcode?
14:32:04 <shachaf> byorgey: This mostly has to do with effects. In Haskell the only effect is nontermination.
14:32:24 <shachaf> Those two expressions can be different in the case of bottom.
14:33:31 <byorgey> shachaf: sure, but I thought the main point is that they might not both type check.
14:33:48 <shachaf> Oh, right, that's the other thing.
14:33:55 <shachaf> Also a sort of effect from one perspective. :-)
14:34:02 <byorgey> =)
14:34:14 <shachaf> In a langauge with I/O side effects the difference is even more blatant.
14:34:57 <zomg> siriusbtx: nope
14:36:05 <siriusbtx> zomg: well it was a programming contest from google some weeks ago. Given a list of drones,warehouses and customers you had to optimize the delivery routes for the drones.
14:36:46 <siriusbtx> zomg: we wrote it in python because you only had 3h to submit a solution, so after the contest I wanted to try it in haskell
14:37:20 <zomg> oh nice :)
14:37:37 <zomg> I did some basic AI stuff with haskell too, actually... for Hello World Open
14:37:56 <zomg> ( https://2014.helloworldopen.com/ )
14:38:06 <siriusbtx> zomg: nice :), but the problem I had with haskell was that I didnt know how to handle mutability
14:38:22 <zomg> yeah that can be a bit of a hassle when you start out
14:38:57 <siriusbtx> zomg: for example having a list of drones I had to select a drone from the list, remove it from the list, do some checks, and perhaps add it back or keep it out of the list forever
14:39:25 <siriusbtx> zomg: how would stuff like that be done in haskell?
14:40:02 <siriusbtx> zomg: return the selected drone and the list with the other drones?
14:41:42 <zomg> some options are the State monad, IORef and STM
14:42:05 <zomg> you can use those almost like any imperative lang in some cases
14:42:21 <siriusbtx> ill look into that
14:42:54 <siriusbtx> but is it worth going through all that? I've also looked into ocaml which allows me to use mutation when I need it.
14:43:01 <siriusbtx> (not saying ocaml is better than haskell) :p
14:43:21 <barrucadu> Generally there is a more functional approach to the problem
14:44:24 <siriusbtx> barrucadu: the problem I am having, is that theres not much stuff to learn from
14:44:56 <barrucadu> It's really just practice
14:47:07 <siriusbtx> barrucadu: any reason why for example github as almost no real haskell projects?
14:47:29 <lyxia> there's only ghc on github of course
14:47:37 <lyxia> and it's a mirror
14:47:42 <siriusbtx> barrucadu: a language I use allot now is go, which has way more projects on github with only 1k users in its irc channel. This 1 has 1.5k
14:47:58 <zomg> Interesting question
14:48:00 <zomg> https://github.com/jhartikainen/hwo2014bot
14:48:07 <zomg> this is my hello world open 2014 AI btw
14:48:15 <zomg> it's.. maybe not the best haskell codebase
14:48:28 <zomg> because it was written in a hurry and tbh I'm not *that* great at it, but it works
14:48:31 <zomg> :D
14:48:41 <siriusbtx> zomg: thx
14:48:48 <siriusbtx> zomg: i rather look into that kind of code
14:48:50 <zomg> (it uses State for mutability and Lens)
14:49:06 <siriusbtx> zomg: than some phd guy's code
14:49:10 <zomg> heh
14:49:34 <siriusbtx> do you guys use haskell for real world projects?
14:49:50 <Clint> yes
14:49:54 <barrucadu> I use Haskell to power a couple of websites
14:49:59 <zomg> I used it at work for a small one off web service
14:50:03 <zomg> normally we do nodejs
14:50:08 <siriusbtx> barrucadu: was intrested in that aswell
14:50:29 <verement> siriusbtx: I am writing https://github.com/verement/etamoo
14:50:31 <siriusbtx> barrucadu: but because I come from Go, I rather not use frameworks :)
14:50:41 <siriusbtx> zomg: and it worked out ok?
14:50:48 <zomg> yeah it was really stable
14:50:51 <zomg> no issues
14:51:36 <lyxia> siriusbtx: I did the hashcode in Haskell (well... the extended round) and the core of the program doesn't use mutation.
14:51:48 <siriusbtx> lyxia: cool
14:51:56 <siriusbtx> lyxia: this year?
14:52:16 <lyxia> right
14:53:51 <siriusbtx> barrucadu: what libraries do you use for the websites?
14:55:25 <barrucadu> siriusbtx: For static sites, hakyll is pretty good. Otherwise I wrote my own thing using wai and web-routes for my book database: https://github.com/barrucadu/bookdb (if you look at it, ignore the css issue‚Ä¶ that seems to be an nginx configuration issue I'm trying to fix now)
14:56:29 <siriusbtx> barrucadu: k
14:56:46 <jle`> siriusbtx: i use it for lots of real world projects, it's actually my main 'real world' language/platform :)
14:58:23 <dmj`> haskell... of the real world
15:01:13 <barrucadu> Of course, there's also Facebook who use Haskell to power their spam fighting system
15:02:02 <barrucadu> Naturally the entire system isn't on github, but the library they wrote to manage concurrent data access is: https://github.com/facebook/haxl
15:04:42 <siriusbtx> barrucadu: graphical games arent rly haskell's strength I suppose? :p
15:04:58 <siriusbtx> barrucadu: I try to learn new languages by writing web apps or games :p
15:05:00 <barrucadu> I don't think there are many people making graphical games in Haskell, no
15:05:12 <barrucadu> But you shouldn't let that stop you! There are opengl bindings!
15:05:37 <hiptobecubic> siriusbtx, haskell has a lot of good options for (backend) web development
15:05:46 <siriusbtx> barrucadu: well I rather use the right tool for the job. Especially since I dont know how to use haskell correctly atm.
15:06:19 <siriusbtx> hiptobecubic: do you recommend scotty for a beginner?
15:06:21 <hiptobecubic> siriusbtx, yesod is more or less the django/rails/giantframework of the haskell world, but there are others. Snap, Servant, Scotty, Spock....
15:06:44 <hiptobecubic> siriusbtx, sure why not
15:07:11 <siriusbtx> well thx guys, you got me intrested in haskell again :p
15:10:46 <karoal> exit
15:10:53 <karoal> whoops sorry :)
15:14:57 <thoughtpolice> Profpatsch: There is an email address, hcar@haskell.org, that you submit to (plain text or latex or some otherwise transcriptable format). But there will be a call for contributions, when the editor will have time to amass them all. Wait until then to send it; it will be soon.
15:15:08 <thoughtpolice> The next call for contributions should be in late March, early April
15:17:34 <Profpatsch> thoughtpolice: Thanks. where will the call be made?
15:17:47 <Profpatsch> I don‚Äôt think I can handle haskell-cafe. :)
15:17:54 <thoughtpolice> There will be an email sent to haskell@haskell.org and haskell-cafe.
15:18:26 <thoughtpolice> Here's the email for the November issue: https://mail.haskell.org/pipermail/haskell/2015-October/024708.html
15:18:36 <thoughtpolice> The haskell@ address is low-volume, announcements only.
15:19:20 <Profpatsch> thoughtpolice: Good to know, will sub.
15:20:45 <Profpatsch> Love the new Site by the way.
15:20:52 <Profpatsch> Great job @whoever did it.
15:25:47 * hackagebot warp-tls 3.2.1 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.1 (KazuYamamoto)
15:47:35 <jle`> i wonder how ghc 8 is doing
15:47:41 <gibson_> does fibs = 0 : 1 : zipWith (+) fibs (tail fibs) create a lot of thunks?
15:47:50 <jle`> gibson_: it creates one
15:47:51 <monochrom> it can
15:48:13 <gibson_> only one?
15:48:33 <jle`> yeah, and resolving it yields (0 : another thunk)
15:48:48 <jle`> but only when that first one is resolved
15:49:15 <jle`> resolving the first N items in the list only involves resolving N thunks
15:49:17 <jle`> so that's pretty neat
15:49:26 <gibson_> I see, thanks! it just seems like a lot of complicated structure goes on behind the scenes
15:49:28 <jle`> unlike N^2 for the naive recursive implentation
15:49:42 <monochrom> 2^N
15:49:47 <jle`> thanks, yeah :)
15:50:10 <jle`> gibson_: you can play around on ghci by using :sprint and taking more and more items one at a time
15:50:17 <monochrom> but it is not that simple. arithmetic doesn't get done until you actually ask for a number.
15:50:23 <jle`> :sprint fibs   => fibs = _
15:50:54 <gibson_> never heard of sprint, ill try it now
15:51:02 <jle`> (oh, you have to give fibs an explicit type signature for it to work)
15:51:27 <jle`> the underscore is a stand-in for an unevaluated thunk, so if you do 'head fibs', that'll force the first thunk
15:51:34 <jle`> and you :sprint again, you'll see fibs = 0 : _
15:51:40 <monochrom> in other words, suppose your main program is "main = print (fibs !! 10000)". then a network of approximately 10000 arithmetic thunks is built first, before getting collapsed to the final answer.
15:51:42 <gibson_> its polymorphic right now
15:51:54 <jle`> yeah, you need to monomorphisize it
15:52:40 <monochrom> to put it into perspective, suppose your main program is instead "main = mapM_ print fibs". then there is only an interleaving between building a tiny arithmetic thunk and printing its answer.
15:52:42 <jle`> yeah, finding the Nth item requires walking through/allocating/building N thunks, which is *probably* the answer you wer originally asking for
15:53:50 <tinco> hey guys what is this syntax, I don't recognize it: 
15:53:51 <tinco> data Named a  = Name := a
15:54:09 <gibson_> im confuse monochrom
15:54:11 <tinco> apparently I should be able to use it for some sort of side effect
15:54:19 <lyxia> tinco: It's an infix constructor
15:54:35 <lyxia> data Named a = (:=) Name a
15:54:44 <gibson_> let me just try sprint now
15:54:48 <monochrom> the data constructor is ":=". it has two fields. the first field has type "Name", the second field has type "a"
15:54:56 <tinco> ah right
15:55:48 * hackagebot hsdev 0.1.6.6 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.6 (AlexandrRuchkin)
15:56:08 <monochrom> gibson_: read my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:57:39 <gibson_> ok, will do, for now, what to exactly type for sprint
15:58:46 <monochrom> I don't know. haven't used it for a long time.
15:59:56 <monochrom> ever since I nailed lazy evaluation, :sprint is harder to use than my mind
16:01:04 <gibson_> why do people say laziness is a failure
16:01:18 <monochrom> and :sprint has limited benefit too. it is almost irrelevant to compiled code with -O
16:02:23 <monochrom> therefore these days I either make my own predictions or read Core code. :sprint is harder than the former and less predictive than the latter.
16:04:04 <gibson_> thanks for the help monochrom
16:05:00 <gibson_> also, if you're an expert, what libraries are worthwhile learning for haskell?
16:08:50 <barrucadu> gibson_: Depends on what you want to do
16:09:32 <gibson_> the things I wanna work have non working libraries
16:09:55 <gibson_> maybe yesod is what I should
16:10:54 <chreekat> gibson_: what sorta things?
16:11:07 <gibson_> ncurses programs
16:12:09 <gibson_> i was gonna learn C and learn ncurses from the pdf, so that then I can use it in haskell, but it doesn't even work
16:13:09 <barrucadu> I played around with brick a bit a few months ago. Granted, I only did very basic things, but it seemed nice for making aterminal UI: https://hackage.haskell.org/package/brick
16:14:15 <gibson_> seems promising
16:29:31 <monochrom> circumvent ncurses. use vty directly.
16:30:53 * hackagebot blatex 0.1.0.6 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.6 (2016rshah)
16:43:05 <bobajett> noob question: when I evaluate: e1 = Left "Foo"; e2 = Left "Bar"; and check e1 == e2 in ghci I get False, but when I put this in a file and try to load it into ghci I get a:  No instance for (Eq b0) arising from a use of `==' The type variable `b0' is ambiguous
16:47:02 <dedgrant> bobajett: It sounds like that should work?  I think some context is missing from this error. Can you paste the failing code somewhere and link here?
16:48:21 <dedgrant> bobajett: Either String has an Eq instance
16:49:00 <bobajett> dedgrant: I have literally only 3 lines in my file:
16:49:01 <dedgrant> Ohhhh
16:49:04 <bobajett> e1 = Left "Foo"
16:49:04 <bobajett> e2 = Left "Bar"
16:49:04 <bobajett> whatsThis = e1 == e2
16:49:13 <dedgrant> Right monomorphism
16:49:48 <dedgrant> It's not 'Either String' it's 'Either String a' ... if you're defining this in a source file, you're going to have to be explicit about the 'a'
16:50:05 <MarcelineVQ> There's no gurantee that e1 or e2 will always be Left, so it wants an Eq instance for the Right possiblity as well when you say e1 == e2, the b in this case. I'm not sure why that's different in ghci
16:50:46 <chreekat> ghci has some quirky defaults
16:50:49 <dedgrant> Gotcha that makes sense.
16:51:55 <chreekat> I wonder if the error message could be improved..
16:52:26 <dedgrant> I'd love to know what quirk permits this to slip by in GHCi
16:53:03 <MarcelineVQ> you have give e1 a signature like, e1 :: (Eq b) => Either String b, or just choose something for b that has an Eq instance, like Int or String
16:53:58 <MarcelineVQ> `e1 :: (Eq b) => Either String b` constrains the `b` (the Right) to have an Eq signature so the compiler knows it'll work with ==
16:54:15 <MarcelineVQ> *to have an Eq instance
16:54:58 <bobajett> So I was reading the new Haskell Book and trying to derive instance Eq for it's example of type EitherOr. So I thought that:
16:55:02 <bobajett> instance (Eq a, Eq b) => Eq (EitherOr a b )
16:55:07 <bobajett> (==) (Left a1) (Left a2) = a1 == a2
16:55:09 <bobajett>  (==) (Right b1) (Right b2) = b1 == b2
16:55:14 <bobajett> (==) _ _ = False
16:55:56 <bobajett> would have been enough for haskell to be able to compare Left/Right values.
16:56:26 <dedgrant> Yea it's definitely interesting that there is a different result in GHCi.
17:00:54 * hackagebot ltk 0.15.0.5 - Leksah tool kit  https://hackage.haskell.org/package/ltk-0.15.0.5 (HamishMackenzie)
17:00:55 * hackagebot leksah-server 0.15.2.0 - Metadata collection for leksah  https://hackage.haskell.org/package/leksah-server-0.15.2.0 (HamishMackenzie)
17:00:57 * hackagebot leksah 0.15.2.0 - Haskell IDE written in Haskell  https://hackage.haskell.org/package/leksah-0.15.2.0 (HamishMackenzie)
17:05:35 <geekosaur> is this one of those situations where ExtendedDefaultRules will let ghc infer () as the missing type instead of leaving it generic, then using the Eq from that?
17:07:06 <geekosaur> :seti -XNoExtendedDefaultRules in ghci and see if it still works
17:13:48 <dedgrant> Interesting
17:13:53 <dedgrant> Trying that now
17:14:15 <dedgrant> Yup that restored parity
17:14:19 <dedgrant> Thank you!
18:04:29 <int-e> > 1
18:40:57 * hackagebot hesh 1.0.0 - the Haskell Extensible Shell: Haskell for Bash-style scripts  https://hackage.haskell.org/package/hesh-1.0.0 (ChrisForno)
18:41:32 <int-e> hexagoxel, nitrix: thanks for the notice... lambdabot got spammed :/
18:51:08 <Narfinger> hiho, i am using acid-state but now i want to change a type (aka change the structure to include one more thing) but keep the data, what should i search for, to find it?
18:51:34 <Ralith_> what do people like for visualizing digraphs? is calling out to an external graphviz process the only decent option?
18:53:00 <Ralith_> maybe something with diagrams?
18:53:50 <Ralith_> getting edges not to overlap and so forth by hand sounds like no fun at all
19:17:42 <alokbeniwal> does anyone know of an implementation of neighbor joining (from biology) in haskell?
19:54:06 <pavonia> alokbeniwal: Have you seen https://github.com/linduxed/progp-molbio ?
19:56:43 <centrica_> is there a floor function that "stays" in Double type
19:58:36 <centrica_> floor gives back Integral, which would result in loss of precision when converted back via fromIntegral
20:02:32 <verement> :t fromInteger . floor
20:02:34 <lambdabot> (Num c, RealFrac a) => a -> c
20:03:11 <centrica_> verement: yeah, but isn't that double -> int -> double, causing loss of precision? am i missing something?
20:03:24 <verement> Integer, not Int
20:03:42 <centrica_> ok, so no loss of precision, but possibly slower?
20:03:48 <verement> sure
20:04:02 <centrica_> there's no double -> double direct floor?
20:04:29 <verement> not that I'm aware of
20:06:22 <centrica_> verement: ok, thanks!
20:07:06 <pavonia> > (\x -> x - snd (properFraction x)) 12.345
20:07:08 <lambdabot>  12.0
20:08:18 <centrica_> pavonia: ok, that's a good start, thanks!
20:13:23 <pavonia> @check \x -> x - snd (properFraction x) == fromInteger (floor x)
20:13:25 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 1073 shrinks):
20:13:25 <lambdabot>  -0.5302090662020804
20:16:35 <dramforever> > properFraction (-0.5)
20:16:37 <lambdabot>  (0,-0.5)
20:22:38 <verement> it seems properFraction is using Integer internally anyway, so I'm not sure it's going to be any faster
20:23:21 <verement> I suppose you could FFI down to C's floor()
20:24:34 <centrica_> verement: there's https://hackage.haskell.org/package/cmath-0.3/docs/src/Foreign-C-Math-Double.html#floor
20:25:03 <centrica_> anyway, isn't it strange that Math doesn't have floor :: Double -> Double?
20:25:09 <centrica_> or is it just me?
20:25:54 <Adeon> I think it makes sense, it always results in a value that is an integer
20:26:12 <Adeon> if it was Double -> Double the type suggests it might not be an integer
20:26:34 <Adeon> :t floor
20:26:35 <lambdabot> (Integral b, RealFrac a) => a -> b
20:30:36 <Maxdamantus> `floor :: Double -> Double` to me suggests that Double is a reasonable type to represent integers in.
20:30:37 <centrica_> Adeon: ok, i guess that makes sense from type perspective
20:31:13 <Adeon> ah yeah I'm ignoring performance aspect entirely
20:31:39 <Maxdamantus> Floating point should be used for approximations. That's why it should always feel weird using (/=) or (==) on them.
20:31:43 <centrica_> Maxdamantus: i guess my line of thinking is - floor can be considered a) function that converts Double to Integral or b) function that removes decimals from a Double
20:32:33 <centrica_> while you end up with an integer logically, you might still want to be in Double world
20:33:02 <Maxdamantus> But it wouldn't be an integer logically. It would be an approximation of some number.
20:33:39 <Maxdamantus> You can do things like multiply or add approximations together to get other approximations, and compare approximations using (>) and (<).
20:34:05 <Maxdamantus> (where the result of the comparison should also be considered approximate)
20:36:02 <Maxdamantus> Where would you use an approximate floor from?
20:36:06 <Maxdamantus> s/ from//
20:39:26 <centrica_> currently playing with some angle calculations, so have radians -> degree conversions
20:39:45 <centrica_> so i calc radians, then floor to get degrees
20:40:02 <centrica_> within [0, 360)
20:40:23 <parsecChar> sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442 Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.Wu0ra4wTER --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442 gpg: requesting key 9BEFB442 from hkp server keyserver.ubuntu.com
20:40:27 <parsecChar> and then it hangs
20:40:32 <parsecChar> (trying to install stack on ubuntu)
20:40:35 <parsecChar> is this normal behaviour ?
20:40:37 <Maxdamantus> radians = degrees*2*pi/360
20:41:11 <centrica_> no, what i'm doing is getting any angle (e.g. 88 * pi) into [0, 2*pi) range
20:42:40 <Maxdamantus> but 88*pi radians is already the same as 0 radians.
20:42:42 <centrica_> using floor for that: rad - (fromInteger (floor (an / 2 / pi))) * 2 * pi
20:43:05 <Maxdamantus> Depending on the context.
20:43:09 <centrica_> logically, but i then say "if rad == 0" and that obviously says False if it's 88 * pi :)
20:43:22 <centrica_> so need to push it from anything outside [0, 2pi) to that
20:43:35 <Maxdamantus> rad == 0 is a meaningless operation in any case when you're representing your radians with floating point.
20:44:02 <centrica_> ok, but rad >= 0 && rad < pi is not
20:44:18 <centrica_> i understand there are approximation issues
20:44:38 <centrica_> but they don't go away by converting to integer - precision is lost before that
20:44:50 <DogCat> hey, anyone ever use Haskyll?
20:45:04 <DogCat> is there a way to modify the css files generated for pages
20:46:05 <Maxdamantus> There's apparently Data.Fixed.mod' anyway.
20:46:07 <parsecChar> https://gist.github.com/anonymous/563acff5c9b332d43c49 <-- how do I get stack ?
20:46:58 <montanonic> DogCat: Don't you just edit the CSS files?
20:47:07 <montanonic> DogCat: https://github.com/jaspervdj/jaspervdj/tree/master/css  <-----
20:47:18 <lvella> Vulkan is a new graphics API from the people behind OpenGL, and it is different because it offers no canonical high level language for shaders (like OpenGL have GLSL), but instead, it has a binary intermediate assembly-like language (somewhat like LLVM intermediate language) for shader input. So, if I am going to compile haskell for it, what is the way to go?
20:47:23 <dramforever> > mod' 7.7 3.5
20:47:24 <lambdabot>  0.7000000000000002
20:48:02 <DogCat> yea, i'm just getting oriented, trying to fix someone's website
20:48:21 <mgsloan> parsecChar: Looks like ubuntu's keyservers are having issues.  Use the generic linux install here http://docs.haskellstack.org/en/stable/install_and_upgrade/#linux
20:50:05 * Maxdamantus wonders what's up with the `HasResolution` class.
20:50:09 <centrica_> Maxdamantus: thanks for the hint - i'm @ the beginning, so good to learn about options now :)
20:50:38 <Maxdamantus> resolution :: forall p. p a -> Integer
20:51:05 <Maxdamantus> Maybe they prefer writing `[]` over `undefined`
20:52:13 <dramforever> :t Proxy :: Proxy Int -- this is probably what the "p" is
20:52:14 <lambdabot> Proxy Int
20:52:24 <parsecChar> mgsloan: okay, I can un targz and run stack; but how do I install it?
20:52:32 <parsecChar> I don't wnat it to be ~/Downloads/stack/stack
20:52:50 <dramforever> as you can see it matches p a, and one need not import Data.Proxy to accept a proxy
20:52:51 <mgsloan> > Extract the archive and place stack somewhere on your $PATH (see Path section below)
20:52:52 <lambdabot>  Not in scope: data constructor ‚ÄòExtract‚ÄôNot in scope: ‚Äòthe‚ÄôNot in scope: ‚Äòar...
20:52:52 <lambdabot>      Perhaps you meant ‚Äòplate‚Äô (imported from Control.Lens)    Not in scope: ...
20:52:52 <lambdabot>      Perhaps you meant ‚Äòstock‚Äô (line 146)Not in scope: ‚Äòsomewhere‚ÄôNot in scop...
20:53:05 <mgsloan> Heh, my bad for using markdown syntax with lambdabot around
20:53:19 <dramforever> interesting thing it parsed
20:53:38 <mgsloan> Yes, a lot of miscellanious text is valid haskell code
20:53:53 <mgsloan> (syntactically)
20:54:12 <Narfinger> hiho, i am looking for a function (a, IO b) -> IO (a,b) or something similar
20:54:36 <mgsloan> parsecChar: You should probably add something like "PATH=~/.local/bin:$PATH" to your .bashrc
20:54:41 <glguy> sequence :: (a , IO b) -> IO (a,b)
20:54:46 <dramforever> :t sequence 
20:54:47 <Maxdamantus> > let hello, world, this, is, a, test = id in hello world this is a test 42
20:54:47 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
20:54:48 <lambdabot>  <hint>:1:37: parse error on input ‚Äò=‚Äô
20:54:51 <mgsloan> parseChar: Then, put stack there
20:55:20 <Narfinger> oh
20:55:23 <Narfinger> that makes sense
20:55:44 <dramforever> con
20:55:52 <parsecChar> mgsloan got it working; thanks!
20:55:54 <Adeon> lvella: probably the most practical way is to embed a DSL in haskell and compile that to vulkan
20:55:54 <dramforever> oops sorry
20:56:15 <mgsloan> parsecChar: Welcome!
20:56:44 <Maxdamantus> > let [hello, world, this, is, a, test] = replicate 6 id in hello world this is a test 42
20:56:46 <lambdabot>  42
20:57:09 <fr33domlover> I just updated stack from the debian package and suddenly building my yesod app fails. I deleted some dirs like dist/ but doesn't help
20:57:10 <Adeon> lvella: practical as in if we put the constraint that it must all be in haskell
20:57:21 <fr33domlover> what do i need to delete that stack needs to rebuild? :-/
20:57:30 <lvella> Adeon, well, I was thinking in making Haskell (or a subset of it) a DSL language that could be used to create shaders
20:58:01 <Adeon> it's probably difficult to compile actual haskell to SPIR-V
20:58:03 <mgsloan> fr33domlover: "stack clean --full" should remove all .stack-work state
20:58:08 <Adeon> I don't think the computational model they have there is suitable at all
20:58:14 <mgsloan> fr33domlover: That's really curious, though, how is it failing?
20:58:41 <mgsloan> AFAIK we have not intentionally introduced any changes that would cause projects that did build to no longer build
20:58:44 <fr33domlover> mgsloan, fails when linking the executable, looking for functions that it can't find in the lib
20:59:09 <fr33domlover> this also happened in the past when i upgraded ghc and cabal-install
20:59:11 <mgsloan> That probably means you are missing some "other-modules" in your cabal file.  Are there any warnings about that?
20:59:16 <fr33domlover> but deleting dist/ helped then
21:01:22 <mgsloan> Note that that all that linking stuff is all handled by Cabal / ghc.  Stack really doesn't have much to do with it except running the Cabal library with the right arguments
21:01:38 <mgsloan> So when you run into linking issues it's rarely a stack problem..
21:07:10 <fr33domlover> mshenrick, hmmm looks like i indeed apt-upgraded cabal-install too
21:07:18 <fr33domlover> oops i mean mgsloan 
21:07:29 <geekosaur> cabal-install is not Cabal
21:10:33 <mgsloan> Yeah, your cabal-install really doesn't matter to stack, except for "stack solver"
21:10:40 <mgsloan> (and "stack init --solver")
21:12:17 <minn> I have a few types that should satisfy the same algebraic laws, and so admit simplification according to the same rules. However, I'm having trouble writing generic smart constructors (and so forth) for that class of types. Is there a way to pattern match on 'similar' constructors of a class of types (modulo some similarity relation)?
21:21:51 <fr33domlover> mgsloan, didn't help :-/
21:22:11 <mgsloan> What didn't?
21:22:46 <mgsloan> Oh, "stack clean --full"?
21:24:06 <fr33domlover> mgsloan, yeah. It builds the library part of the yesod app, then the executable, and fails to link them
21:24:20 <mgsloan> Please post a log
21:27:19 <fr33domlover> mgsloan, http://paste.rel4tion.org/269
21:30:09 <mgsloan> Is "Vervis.Form.Repo" mentioned in your cabal file?
21:31:19 <fr33domlover> mgsloan, oops, it isn't :P
21:31:58 <mgsloan> Yes, that's what I meant earlier when I said "That probably means you are missing some "other-modules" in your cabal file.  Are there any warnings about that?"
21:32:38 <mgsloan> It's strange that there aren't warnings about it.  I think because the warnings get generated after build
21:32:44 <mgsloan> So if the build fails the warnings don't happen
21:32:47 * mgsloan makes a TODO
21:33:40 <fr33domlover> mgsloan, it did warn about "Vervis.Field.Repo" earlier, dunno why it didn't with the .Form. module
21:34:29 <mgsloan> It's probably because stack detects such dependencies via metadata produced by GHC
21:34:43 <mgsloan> but if compilation does not succeed, the metadata isn't generated
21:34:46 <mgsloan> or something like that
21:34:53 <mgsloan> Dunno, pending further investigation
21:37:10 <jle`> i wonder how ghc 8 is doing
21:50:20 <pavonia> Hey, I could need some help with designing data types for server requests and responses
21:51:06 <pavonia> So I'm sending JSON requests to a server which include a field call "id", and the server responds with another object with the same field and value and extra data
21:52:02 <pavonia> My problem is, I cannot parse the server request without knowing which request belongs to this specific response, because the JSON objects all look almost the same
21:53:23 <pavonia> So I would have to store the id with the request type somehow and look it up somewhere when a response should be parsed to know which response object to parse to
21:54:46 <solidsnack> Can the request be part of a type class like `Respondable` and have an associated type that is the type of the response?
21:55:37 <solidsnack> Then store the request (which will have the ID embedded in it) and join requests to responses and then use the type class to handle deserialization.
21:55:45 <pavonia> You mean having one data type for each response and request?
21:56:19 <solidsnack> One for each type of response ‚Äî but I assume there are a few kinds of requests, and each one knows which kind of response it wants.
21:56:50 <pavonia> Yes, each request can have exactly one type of response
21:57:13 <orion> What can cloud-haskell do that JSON-RPC + RabbitMQ can't?
21:57:14 <solidsnack> So then you can have a type class that pairs them. And then dispatch with the type class.
21:58:33 <pavonia> Hhm, let me think about this for a moment
22:00:41 <mgsloan> orion: They cannot serialize an unevaluated thunk and send it to a different computer to work on
22:01:19 <mgsloan> Not that I think that's something that's a crucial requirement of distributed Haskell, but that's one of the big things Cloud Haskell brings to the table AFAICT
22:03:04 <orion> ha, oh wow. I thought cloud haskell was just an RPC protocol.
22:04:25 <pavonia> solidsnack: Thanks, I think this could work. I'm trying to implement a prototype to see how far I get
22:06:12 <mgsloan> orion: Nah, it's a collection of packages, and it motivated the StaticPointers ghc extension which allow serializing this stuff
22:06:29 <mr1holmes> i'm using weighted arithmetic mean of 5 factors to rank items. Can you tell me what other alternatives are available for ranking algorithm with multiple factors?
22:11:22 <mr1holmes> i'm using weighted arithmetic mean of 5 factors to rank items. Can you tell me what other alternatives are available for ranking algorithm with multiple factors?
22:13:30 <atondwal> How do I get a UTF8 bytestring from a latin1 encoded file? It's some sort of magic with pack and unpack...
22:14:14 <mgsloan> http://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-Encoding.html#v:decodeLatin1  + encodeUtf8
22:14:23 <jle`> text to the rescue
22:15:00 <jle`> the text package is truly a marvel of software engineering
22:21:10 <mgsloan> I'd say that "encodeUtf8 . decodeLatin1" is a pretty freaking beautiful answer to that question :)
22:24:56 <atondwal> oh duh
22:26:12 <saurabhnanda> hi, can someone please help me understand the type signature of this function? (from yesod/persistent) -- insert :: (MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => val -> ReaderT backend m (Key val)
22:26:34 <saurabhnanda> specifically the return type: ReaderT backend m (Key val)
22:31:59 <mgsloan> That type means that you can use 'ask' to get the 'backend' value, which is likely info about the DB connection
22:32:12 <mgsloan> Or err, rather
22:32:38 <mgsloan> That means that the 'insert' function needs to know about your connection to the backend in order to function
22:32:45 <mgsloan> You probably want yesod's 'runDB' function
22:33:31 <mgsloan> The type "YesodDB site" is "ReaderT (YesodPersistBackend site) (HandlerT site IO)" https://hackage.haskell.org/package/yesod-persistent-1.4.0.3/docs/Yesod-Persist-Core.html#t:YesodDB
22:33:45 <mgsloan> runDB :: YesodDB site a -> HandlerT site IO a
22:34:09 <mgsloan> In other words, if your site has a YesodDB instance, indicating it has a default database connection, then you can use runDB to run database actions
22:35:08 <saurabhnanda> actually, I not sure how this is possible
22:35:08 <mgsloan> ReaderT is just saying "this monadic action needs some extra information to run"
22:35:14 <saurabhnanda> val -> ReaderT backend m (Key val)
22:35:44 <saurabhnanda> how can 'backend' & 'm' be created out of thin air. They aren't being passed INTO the function
22:36:26 <mgsloan> Right, that is return type polymorphism, a really cool feature of haskell
22:36:36 <mgsloan> consider (read "12" :: Int)
22:36:57 <mgsloan> @type read
22:36:58 <lambdabot> Read a => String -> a
22:37:08 <mgsloan> How does it know 'a' if it is not being passed in?
22:37:10 <jle`> saurabhnanda: it can take on whatever type you request, as long as it satisfies the constriants
22:37:18 <jle`> > return 10 :: Maybe Int
22:37:20 <lambdabot>  Just 10
22:37:23 <jle`> > return 10 :: [Int]
22:37:26 <lambdabot>  [10]
22:37:26 <jle`> :t return
22:37:27 <lambdabot> Monad m => a -> m a
22:38:32 <dmj`> :t return return id id id return id
22:38:33 <lambdabot> Monad m => m (a -> a)
22:38:39 <mgsloan> TBH if that is the confusing part, you probably shouldn't be jumping in to persistent quite yet, but jumping into the deep end can be a good strategy :D
22:39:12 <mgsloan> Just don't get demoralized if you end up struggling with it.  Best to start simple and properly grok how this stuff works
22:39:35 <Maxdamantus> > "{" ++ read "\"foo\"" ++ "}"
22:39:36 <lambdabot>  "{foo}"
22:40:39 <Guest55914> I wish to connect to MySQL with my haskell program. I used 'defaultMySQLConnectInfo' to provide data that are required. But the reply from MySQL is always 'Access denied for user root@localhost (using password:YES)'. Could anyone help me in finding the cause of it?
22:41:09 <mgsloan> Guest55914: Is "YES" the password? XD
22:41:18 <mgsloan> Perhaps it is hunter2
22:41:40 <Guest55914> No. But I've set the right password in my haskell program.
22:42:44 <mgsloan> Ohh I see
22:43:41 <mgsloan> I have only used persistent, I have no knowledge of HDBC
22:44:03 <Guest55914> I guess this was just to confirm that I've given the password when connecting.
22:44:12 <Guest55914> Thank you, however :)
22:50:47 <m-renaud> Hey, I was wondering if it's possible to put constraints on a type family defined in a typeclass.
22:51:38 <m-renaud> I would like to do something like: class C c where type E c :: (Num a) => a
22:51:43 <mgsloan> m-renaud: I think it is probably possible.  Do you get errors if you put such constraints in the instance head?
22:52:20 <mgsloan> How about "class (Num (E c)) => C c where type E c"
22:52:33 <m-renaud> Let me try that
22:54:49 <m-renaud> No such luck. "Non type-variable argument in the constraint: Num (E c). (Use FlexibleContexts to permit this)"
22:55:11 <mgsloan> Then add {-# LANGUAGE FlexibleContexts #-} to the top of your file
22:55:26 <m-renaud> It that a "safe" extension?
22:55:30 <mgsloan> Yes, very safe
22:55:47 <mgsloan> Almost all type system extensions are safe except for UndecidableInstances and IncoherentInstances
22:56:26 <m-renaud> Good to know, thanks. How likely is it for many of these extensions to make it into the language?
22:56:38 <mgsloan> OverlappingInstances is also a dubious thing, but not nearly as bad as undecidable or incoherent
22:57:26 <mgsloan> Probable, but it will take a while.  The process of updating the language spec is laborious and thankless
22:57:29 <Drezil> o/ is there a way to prevent GHC from generating record-accessors automatically?
22:57:40 <mgsloan> There isn't much incentive for it, so it gets delayed
22:58:15 <mgsloan> m-renaud: You can also put extensions in your cabal file, to avoid sticking language pragmas all over the place
22:58:37 <m-renaud> Ah, yeah that makes sense.
22:58:39 <mgsloan> I'll often start a project with a cabal file that has a slew of extensions
22:58:58 <m-renaud> Also, unfortunately the type error if you use something that isn't an instance of Num when making an instance of C doesn't mention the lack of a Num instance, it complains about something else.
23:00:07 <mgsloan> Yeah, I agree that is not ideal
23:00:38 <mgsloan> not a fundamental limitation of GHC, but it's tough to figure out the balance of what to include in errors and what to omit
23:01:02 <mgsloan> IMHO type systems are such a rich thing, our errors need to be interactive interrogatable objects
23:01:43 <m-renaud> That would be fantastic!
23:03:03 <mgsloan> Agreed!  And such a thing is not so far fetched.  Idris already has something like this, due to the excellent work of David Christiansen
23:03:10 <m-renaud> You get the nice type error of "Missing instance of Num" if you have the simple case like the example I made, but my more complex case just gives an error at the use site.
23:03:28 <m-renaud> I'm not familiar with the work, do you have a link?
23:04:32 <mgsloan> Looks like his blog is down but google has it cached http://webcache.googleusercontent.com/search?q=cache:8Nv1iEOdpQkJ:www.davidchristiansen.dk/2014/09/06/pretty-printing-idris/+&cd=3&hl=en&ct=clnk&gl=us&lr=lang_de%7Clang_en%7Clang_hr&client=ubuntu
23:05:03 <m-renaud> Neat, I'll have to give it a read.
23:05:21 <m-renaud> or watch
23:05:44 <mgsloan> I've been intending to implement something like this for nearly 2 years now, I came up with a very similar idea independently of David
23:06:14 <m-renaud> How much progress have you made towards your goal?
23:06:31 <mgsloan> Not much :/  I got stuck augmenting the GHC pretty printer, which is surprisingly complicated
23:06:48 <mgsloan> Other things have been occupying my time.  I hope someone takes a swing at it
23:06:56 <mgsloan> If not I bet I'll have a go at it sometime
23:07:27 <Drezil> hmm.. noone has an idea?
23:09:26 <mgsloan> Drezil: I don't know why you wouldn't want GHC to generate a record accessor
23:09:41 <m-renaud> Drezil: Not that I know of, what's your use case?
23:09:50 <mgsloan> You either have a record type or you don't
23:11:15 <Drezil> i am generating Haskell-Code for a json-API i cannot control.
23:11:30 <Drezil> and i want to have json-objects as records ..
23:11:38 <Drezil> but the field-names clash occasionally.
23:11:59 <mgsloan> Put them in different modules?
23:12:39 <mgsloan> Alternatively, start using GHC 8 (nearly released), and use OverloadedLabels
23:12:41 <m-renaud> Or prefix each of the names?
23:12:42 <Drezil> i want to have 1 module per API-Page ..
23:12:52 <Drezil> m-renaud: i think i prefix them ..
23:13:48 <EvanR> so Ord...
23:13:58 <EvanR> whats this, a total order?
23:14:01 <dmj`> @package json-autotool
23:14:01 <lambdabot> http://hackage.haskell.org/package/json-autotool
23:14:13 <EvanR> whats with the Eq constraint
23:14:58 <mgsloan> EvanR: Yes, it's a total order, which is why an Eq constraint is sensible
23:15:15 <EvanR> is there a class for <
23:15:58 <mgsloan> Best one I can think of is https://hackage.haskell.org/package/lattices-1.5.0/docs/Algebra-PartialOrd.html
23:16:03 <mgsloan> Which provides (<=)
23:16:09 <mgsloan> (leq)
23:16:12 <xecycle> There is contramap :: (a -> b) -> f a -> f b; I want to generalize the first (a -> b), which is also ((->) a b), to some category C a b, so that the contramap becomes C a b -> f a -> f b.  Is there a name for this combination of such a category and a contrafunctor-like thing?
23:16:32 <EvanR> yeah it also has a Eq constraint...
23:16:34 <xecycle> ah sorry, I got it flipped, should be f b -> f a
23:16:54 <mgsloan> EvanR: Hah, doh, that sucks
23:17:10 <EvanR> time for a nonsense Eq instance ;0
23:17:33 <mgsloan> I imagine there're a few classes here and there that have what you want, but none that I know of that are blessed as standard
23:17:39 <xecycle> summing up it should be something like (Category c, CategoryContraFunctor f) => c a b -> f b -> f a.  is there already a name for this?
23:19:35 <mgsloan> xecycle: I don't understand what I'm looking at, but perhaps https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L152
23:19:57 <mgsloan> AFAIK this is the most permissive and powerful "category theory in haskell" package out there
23:24:21 <EvanR> ... class Real a ... fromRational :: a -> Rational... "the rational equivalent of its real argument with full precision"
23:24:22 <xecycle> mgsloan: I need some time to fully comprehend that; but if I want to stay with that limit, that is just to be able to "contramap" a "contrafunctor" with a category, is there a name for it?  Quotes added because it is not really a contrafunctor.
23:24:28 <EvanR> what a contradiction!
23:25:13 <mgsloan> EvanR: Hahah, well we are dealing with computers
23:25:51 <mgsloan> 'fromRational' could never return if it truly is a real unrepresentable by a rational
23:26:03 <mgsloan> Not that that's a very good excuse for the naming choice
23:26:43 <EvanR> the documentation there is the nail in the coffin
23:27:07 <Cale> Yeah, the naming is pretty bad. But if you think real vs. complex rather than real vs. rational, it makes slightly more sense.
23:27:12 <shachaf> xecycle: You should generalize both sides, and map from (c a b) to (d (f a) (f b)) or something.
23:27:43 <shachaf> Or (c a b) to (d (f b) (f a)) if you prefer, but once you've generalized it like this, covariant and contravariant functors are the same thing.
23:27:53 <EvanR> class (Real a, Enum a) => Integral a
23:28:06 <EvanR> so this says to me that Real isnt really for reals anyway
23:28:28 <xecycle> shachaf: thanks for the advice, will reconsider about this.
23:28:32 <EvanR> its anything embeddable in rationals
23:28:57 <mgsloan> Should be called "Rationable" ;)
23:29:02 <EvanR> ok good, Real isnt required by anything geniuinely fractional
23:29:21 <EvanR> ... except RealFrac >_<
23:29:24 <shachaf> A lot of category packages, like the one mgsloan linked to but also others that might be simpler, define this sort of Functor.
23:29:32 <EvanR> and so RealFloat
23:29:55 <EvanR> time for more awkward instances
