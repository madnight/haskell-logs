00:01:50 <`Guest00000> about the monomorphism restriction... why can't we just memoize for multiple instances?
00:03:30 * hackagebot relational-postgresql8 0.2.0.0 - PostgreSQL v8.x driver for haskell-relational-record  https://hackage.haskell.org/package/relational-postgresql8-0.2.0.0 (yuga)
00:08:33 <jle`> it's not really obvious how much should be memoized
00:08:54 <jle`> and how many instances, etc.
00:08:57 <jle`> sounds kind of like magic
00:09:08 <jle`> it'd be nicer to be able to predict/reason about memory usage
00:09:25 <jle`> sort of the same reason why all Int -> Int's aren't automatically memoized
00:18:25 <EvanR> jle`: i get the feeling that the way haskell prefers is to sacrifice memory for speed when possible but yeah
00:18:55 <jle`> well, it'd still be nice to be able to reason about memory usage
00:19:28 <jle`> memory is often sacrified for speed, but in predictable ways, for the most part :)
00:20:32 <jle`> there's a difference between deterministic memory/speed tradeoffs and magical, tricky-to-predict ones
00:21:47 <jle`> Int -> Int's being magically memoized behind the scenes seems a little too much magic to me ;_;
00:21:54 <jle`> sorry user magically
00:22:58 <EvanR> jle`: im suspicious that would even help on average
00:23:41 <jle`> i suppose that the compiler might be able to find places where it would help in specific, but even in that case, it's better to let the user explicitly specify that they want things to be memoized
00:23:52 <EvanR> yeah i really like only doing optimization tricks when its 100% going to be beetter
00:24:16 <EvanR> 100% certain
00:24:36 <EvanR> not throwing optimization spaghetti at a wall
00:28:31 * hackagebot atlassian-connect-descriptor 0.4.3.1 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.3.1 (RobertMassaioli)
00:33:31 * hackagebot oi 0.4.0 - Library for purely functional lazy interactions with the outer world.  https://hackage.haskell.org/package/oi-0.4.0 (NobuoYamashita)
00:36:00 <kadoban> mehhh - Library for lazy interactions with the nearest couch.
00:39:37 <EvanR> runInteraction :: (OI a -> b) -> IO b
00:39:45 <EvanR> curious
02:10:59 <tomjaguarpaw> Hello everyone.  How do I get headers in Haddock?  Using '=' as documented in https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810712272 doesn't  work
02:21:01 <kadoban> tomjaguarpaw: What leads you to believe it's not working?
02:22:21 <tomjaguarpaw> It's not working because the output is paragraph-level text containing the following "= Heading level 1 with some __bold__ Something underneath the heading. "
02:23:10 <kadoban> tomjaguarpaw: This is when you're using exactly the code copied from the example?
02:25:49 <`Guest00000> i want something which is like type holes but should act "after" choosing default instances
02:27:20 <tomjaguarpaw> kadoban: Well yes, the first part of it:
02:27:21 <tomjaguarpaw> -- |
02:27:21 <tomjaguarpaw> -- = Heading level 1 with some __bold__
02:27:21 <tomjaguarpaw> -- Something underneath the heading.
02:28:12 <kadoban> Dunno then.
02:33:25 <montanonic> Operational is such a great library
02:33:31 <montanonic> http://lpaste.net/152875
02:41:54 <`Guest00000> ugh
02:42:04 <`Guest00000> BasicPrelude
02:43:16 <dzelzs>  good day everyone, I'm a Haskell newcomer and I'm experiencing troubles. I'm currently using the 'Options' package for parsing cmd-line arguments and I've wanted to encapsulate interaction with it in my own module. And there is a 'runCommand :: (MonadIO m, Options opts) => (opts -> [String] -> m a) -> m a' function which I want to wrap for my custom instance of Options, but I just can't come up with the right type.
02:45:50 <tomjaguarpaw> What's your type?
02:48:03 <dzelzs> my type of what? I just want
02:48:03 <dzelzs> myRunCommand = runCommand
02:48:03 <dzelzs> but haskell want me to be precise about Options
02:48:39 <`Guest00000> fun: open GHCi, type "import Prelude ()" and hold Tab
02:49:10 <vkt> how come haskell doesn't recognize the (T Int) constructor within Cons dispite it being declared just before? data Test = T Int | Cons (T Int) Test
02:49:43 <tomjaguarpaw> Did dzelzs go?
02:49:47 <lyxia> vkt: you declared T as a data constructor, not a type constructor
02:49:56 <gfixler> `Guest00000: does the same thing if I type "import" and press tab
02:50:27 <vkt> thx lyxia 
02:52:09 <vkt> lyxia:  so data constructors only accept type constructors as parameters. is that correct?
02:54:03 <vkt> also data = value right? not to be mistaken with data X = bla bla in which X is a type constructor
02:54:57 <sternenseemann> hey there!
02:55:49 <vkt> hi sternenseeman 
02:56:00 <lyxia> vkt: right, T is used to construct values. In the declaration you gave, Cons expects the types of its fields as arguments.
02:57:32 <lyxia> vkt: But (T Int) is not a valid type.
02:59:07 <vkt> lyxia:  alright that makes sense thank you :)
03:03:54 <sternenseemann> Any ideas why I can't import Data.Set.Base even though I've added containers to dependencies?
03:04:08 <sternenseemann> Is it prohibited from importing?
03:06:34 <kadoban> sternenseemann: Never heard of it … that exists?
03:07:18 <doomrobo> is there a cleaner way to write (\x y -> compare (snd x) (snd y)) ?
03:07:19 <kadoban> sternenseemann: It doesn't appear to be in any of the docs. Do you just mean Data.Set ?
03:08:32 <tomjaguarpaw> sternenseemann, kadoban: It's a hidden module.
03:08:50 <tomjaguarpaw> doomrobo: compare `on` snd?
03:09:03 <doomrobo> oh cool!
03:09:27 <tomjaguarpaw> doomrobo: import Data.Function (on)
03:09:35 <kadoban> :t (\x y -> compare (snd x) (snd y))
03:09:36 <lambdabot> Ord a => (a1, a) -> (a2, a) -> Ordering
03:09:43 <kadoban> :t comparing snd
03:09:44 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
03:10:14 <sternenseemann> then how can I import it to make the Constructors visible? Any other way than setting TESTING?
03:10:32 <sternenseemann> or I'll have to fold over it or something…
03:10:34 <doomrobo> kadoban, ah nice
03:10:51 <kadoban> sternenseemann: Why are you trying to do that?
03:11:06 <sternenseemann> kadoban: hashing
03:11:29 <tomjaguarpaw> sternenseemann: Hashing what?
03:11:29 <kadoban> sternenseemann: Hashing what? Why?
03:13:34 <sternenseemann> I have a Monad and Typeclass for hashing and want to implement it for Sets
03:14:53 <kadoban> I don't really understand. There must be some other way than poking at the internals though.
03:15:22 <sternenseemann> yes,, some kind of mapM would be enough
03:15:23 <tomjaguarpaw> Definitely.  Going into the internals is a very bad idea.
03:15:38 <tomjaguarpaw> sternenseemann: Perhaps you could share your code.
03:16:28 <kadoban> sternenseemann: Will Data.Set.toList help you do what you want perhaps?
03:17:54 <sternenseemann> tomjaguarpaw: https://github.com/factisresearch/large-hashable
03:18:10 <sternenseemann> kadoban: I am worrying about the overhead of that :/
03:19:36 <tomjaguarpaw> What should I be looking at specifically?
03:20:10 <tomjaguarpaw> Class.hs, perhaps?
03:20:27 <tomjaguarpaw> You want to write a LargeHashable instance for Dict?
03:20:34 <sternenseemann> tomjaguarpaw: yes
03:20:34 <tomjaguarpaw> Err, for Data.Map?
03:20:40 <tomjaguarpaw> Yes, just use toList
03:20:45 <sternenseemann> Set, Map and so
03:23:40 <sternenseemann> as pointed out I worry that toList has a to harsh memory and performance overhead :/
03:24:35 <tomjaguarpaw> Why do you worry that? 
03:24:46 <tomjaguarpaw> Do you have some reason to believe that's the case?
03:25:39 <tomjaguarpaw> You can also just use foldl'
03:25:48 <sternenseemann> I see
03:25:53 <tomjaguarpaw> which may be suitable for iteratively computing a small hash.
03:26:02 <sternenseemann> I will look into that, thanks for your help!
03:26:11 <tomjaguarpaw> You're welcome.  Good luck.
03:38:38 * hackagebot mwc-random 0.13.4.0 - Fast, high quality pseudo random number generation  https://hackage.haskell.org/package/mwc-random-0.13.4.0 (AlexeyKhudyakov)
04:01:04 <prygan> Hi everyone ! I'm currently in a CS engineering school and i want to learn haskell. I've find some good tutorial/guide like learn you a haskell for great god. I try to find "real" project ideas (i don't find the 99 hs problems really motivating :/). Do you have any cool ideas ? :) 
04:02:25 <muzzle> hi
04:02:35 <muzzle> is there a library for implementing shell REPLs?
04:02:39 <Lowl3v3l> prygan, lyah is nice, you should read it^^ and you may like : https://lotz84.github.io/haskellbyexample/
04:03:42 <muzzle> my usecase is that i'm implementing a small database and i want to implement a repl for querying it 
04:03:57 <prygan> Thanks Lowl3v3l that seems nice ^^
04:04:06 <`Guest00000> can hoogle/hayoo search for type families?
04:07:12 <montanonic> prygan: how much do you want to learn Haskell?
04:07:21 <montanonic> prygan: like, what level of priority is it for you?
04:07:43 <montanonic> prygan: and have you done Functional Programming before?
04:08:01 <montanonic> prygan: also, hi!
04:09:20 <prygan> Hi montanonic, i've went throught an introduction to FP in school with Haskell. It was really cool and a now want to learn it by myself with some side projects 
04:09:54 <montanonic> prygan: okay, cool; I know you're asking for a motivating project, but can you think of at least one thing that sounds interesting to you?
04:10:04 <montanonic> prygan: I'm trying to understand what you mean by "project"
04:10:26 <montanonic> do you just want a goal? Or do you want an idea for programming a piece of software? how big are we talking?
04:11:59 <montanonic> prygan: also: https://github.com/bitemyapp/learnhaskell  <------------- ; these are better than Learn You
04:12:09 <prygan> Ok, i understand. I'm talking for a project that may take some month. I've seen some projects like bittorent client in haskell but i was wondering if it is not a little bit hard for a first real project 
04:12:57 <montanonic> prygan: are you comfortable with using monads and writing monads?
04:13:53 <montanonic> prygan: also, what you said helps clarify a lot; the answer to the next question will help me even more
04:13:55 <prygan> Not really even if i know it's a big part of haskell programming. Do you think i should stay with tutorials first ? 
04:14:53 <montanonic> prygan: okay, cool; that's helpful to know. Yes, you should stick to the tutorials.
04:15:00 <ggVGc> :/
04:15:02 <montanonic> prygan: but more than that: here's my project recommendation
04:15:04 <muzzle> so implementing it myself is the way to go?
04:15:14 <ggVGc> why would you mention monads to a person who is just expressing interest in learnign haskell
04:15:29 <ggVGc> that's essentailly the one biggest failure of the haskell comminity all over the internet
04:15:38 <ggVGc> and who the hell needs to write a monad themselves ever
04:15:41 <montanonic> ggVGc: they're asking for a project; I'll respond to you in a sec
04:15:43 <ggVGc> in normal everyday work
04:16:11 <montanonic> prygan: study the tutorials until you've gotten through Functor, Applicative, and Monads, and are comfortable with them
04:16:27 <Hafydd> ggVGc: it's very difficult to avoid mentioning monads, when the type of a Haskell program is IO ().
04:16:30 <montanonic> prygan: that as a "project" could easily take a month or more
04:17:11 <prygan> 'K montaninic thanks (and thanks for the tutorial link :p )
04:18:10 <montanonic> prygan: now, the reason I'm recommending you do this is because, from my experience and from talking to other people in #haskell-beginners, it's just really, really hard to make a project without running into things like Monads and Functors
04:18:44 <montanonic> prygan: so you'll feel much more comfortable with those things after you've spent some time with the course(s) in the link I sent you
04:19:33 <montanonic> prygan: and then if you still can't think of a project, come back and ask us again, but I'm really confident that you'll learn more and have a better time if you start simpler first
04:19:35 <aarvar> Hafydd: how so?
04:19:55 <Hafydd> aarvar: as it happens, IO is itself a monad.
04:20:02 <aarvar> Is a hard to talk about adding numbers without mentioning Orders?
04:20:03 <montanonic> prygan: you should give this a look: http://bitemyapp.com/posts/2015-08-23-why-we-dont-chuck-readers-into-web-apps.html
04:20:03 <prygan> montanonic: yeah i see thanks for the advice 
04:20:11 <aarvar> Hafydd: no it isn't
04:20:20 <aarvar> "is a monad" is an abuse of terminology here
04:20:22 <montanonic> prygan: you're welcome! I'm very excited for you; I love that you're interested in learning Haskell
04:20:32 <Hafydd> aarvar: moreover, its monadic nature is central to most non-trivial uses of it.
04:20:42 <aarvar> "monadic nature"
04:20:45 <aarvar> what does that even mean?
04:20:48 <montanonic> prygan: I know that if you stick with it, you'll have a blast and learn a ton
04:21:10 <aarvar> do lists have a monadic nature?
04:21:19 <Hafydd> aarvar: in what way is it an abuse of terminology? Would you say that "The real numbers are an ordered field" is an abuse of terminology?
04:21:55 <aarvar> Hafydd: because IO is a type constructor, and a monad is a type constructor + bind + return
04:21:59 <Hafydd> aarvar: when considered in the context of their Monad instance, they obviously do.
04:22:03 <montanonic> ggVGc: This basically sums up my reasons: http://bitemyapp.com/posts/2015-08-23-why-we-dont-chuck-readers-into-web-apps.html
04:22:59 <Hafydd> aarvar: there is a standard Monad instance for IO, and it's disingenuous to imply that anybody would not assume that's what is being discussed.
04:23:11 <aarvar> now, you could say that in haskell a type constructor technically also includes all the instances on it, because instances are globally non-overlapping, but I think that's a different matter
04:23:19 <prygan> I have to go, thanks again montanonic ! 
04:23:43 <aarvar> if IO is a monad, then does putStrLn use monads?
04:23:47 <montanonic> ggVGc: Monads aren't scary. But I don't think I *really* got a taste of Haskell until I got comfortable with them and started writing "monadic code".
04:24:09 <aarvar> I mean, it returns an IO value, and IO is a monad, so putStrLn returns a monad, and so you have to understand monads to use putStrLn, right???
04:24:55 <Hafydd> aarvar: for non-trivial uses, you do.
04:25:00 <aarvar> no, you don't
04:25:39 <Hafydd> aarvar: unless you include "uses" such as copying and pasting code that some teacher has provided.
04:25:49 <montanonic> As someone who hasn't been Haskelling for very long, understanding Functors and Monads make working with IO much more intelligible 
04:26:54 <montanonic> Without a comfort with the standard Haskell typeclasses it's hard to get very far with IO code (without a lot of pain and unDRY code)
04:27:05 <montanonic> Basic stuff though, sure, no prob. 
04:27:13 <Hafydd> Also known as "wet code."
04:28:29 <aarvar> why do you need to understand an abstraction to use a concrete instance of it?
04:29:19 <aarvar> and what's special about monads and IO
04:29:36 <Freundlich> aarvar: You have to at least understand IO's monad instance in order to use functions that require their arguments to be a monad.
04:29:47 <aarvar> I've never seen anyone say that you have to learn about groups first to program with numbers
04:31:05 <montanonic> aarvar: that's not the same thing as saying Haskell will not get you very far until you are "comfortable" with using monads
04:31:08 <Hafydd> aarvar: given that you're using the symbols >>= and return, or, equivalently, using do notation, you do in fact have to understand the Monad typeclass in order to use the IO type without being in the unfortunate state of not knowing what you're doing. That's not to say that you have to understand all possible instances of Monad.
04:31:54 <montanonic> We should probably stick to using words like "comfort" instead of "understand"; I think it's clearer to what we mean (or ought to mean)
04:32:21 <Hafydd> Many people feel comfortable when they don't understand what they should; so that's not what I mean.
04:32:24 <aarvar> bindIO :: (a -> IO b) -> IO a -> IO b; bindIO = (=<<) returnIO :: a -> IO a; returnIO = return
04:32:36 <aarvar> did I get rid of the monads yet?
04:33:12 <Hafydd> aarvar: but that code itself uses >>= and return. The user either has to write it, or (as I mentioned before) have it provided by a teacher.
04:33:35 <aarvar> okay, I just provided it
04:33:39 <montanonic> I just mean to criticize the idea of "understanding Monads"; it's a bit too final. My experience with abstractions like Monads are that I get increasingly comfortable with the ideas circling around it. It's a continual work in progress.
04:33:43 * hackagebot stack 1.0.4 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.0.4 (borsboom)
04:33:44 <Hafydd> And the easiest way to explain the type signature of bindIO is probably through Monad.
04:33:57 <aarvar> and they have to understand how those two functions work when specialized to a certain type, okay
04:34:07 <aarvar> Hafydd: uh, how?
04:34:45 <Hafydd> aarvar: it seems to me that it's easier to understand when viewed more abstractly (as things sometimes are).
04:35:11 <montanonic> Well, isn't the strongest point of abstractions like Monad the fact that even if you don't understand the instances, the properties of it are understood? Yeah, as Hafydd said.
04:35:12 <aarvar> okay, explain bindIO to me in terms of "Monad"
04:35:41 <Freundlich> When I started using Haskell, IO seemed like a big mystery to me. I really was in the uncomfortable position of not knowing what I was doing. Looking at >>= and return didn't help either.
04:35:44 <montanonic> aarvar: it's bind, for IO values
04:35:48 <montanonic> :)
04:35:56 <aarvar> montanonic: which tells you absolutely nothing
04:36:03 <Freundlich> Then I started with "easier to understand" Monads like Maybe, [], and so on, which finally also made me comfortable using IO.
04:36:22 <aarvar> and obviously understanding abstractions is useful, but you can say that about any abstraction
04:36:24 <montanonic> I disagree. It tells you that you can sequence the values of two IO monads
04:36:30 <aarvar> what's special about Monad and IO
04:36:37 <aarvar> "sequence the values"
04:36:39 <aarvar> what does that mean?
04:36:47 <aarvar> it does tell you about some laws though, if you explain the laws
04:36:48 <montanonic> the `a` in IO a
04:36:58 <aarvar> but you could explain the laws for the specialized instance just as easily
04:36:59 <montanonic> gets fed into the (a -> IO b)
04:37:01 <montanonic> essentially
04:37:03 <aarvar> montanonic: um, what?
04:37:15 <Freundlich> The thing is, IO is probably one of the more difficult types to understand and it certainly helps to know about Monads beforehand.
04:37:49 <aarvar> montanonic: that has nothing to do with monads, and what does it mean to say there's an `a` in an `IO a`
04:37:54 <montanonic> Freundlich: I hardly understand IO, but I agree, being comfortable with monads helps a lot
04:38:13 <montanonic> aarvar: ? that's one of the most valuable aspects of monads: they allow for sequencing of computations
04:38:19 <montanonic> that's abstract, I know
04:38:20 <aarvar> montanonic: that's false
04:38:58 <montanonic> aarvar: false in the sense that Monads aren't necessary for sequencing? if so, that's not what I meant
04:39:09 <aarvar> well, maybe not false
04:39:11 <aarvar> more like meaningless
04:39:18 <aarvar> I have no idea what it means
04:39:44 <aarvar> I don't think it can have any useful meaning
04:39:46 <montanonic> aarvar: right, hence the call to spend time playing around with monads until there's a comfort
04:39:58 <aarvar> um, I understand monads
04:40:10 <montanonic> aarvar: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
04:40:35 <montanonic> that's one of the ways that I think about the sequencing
04:40:55 <montanonic> Free Monads basically just do the sequencing part and nothing else
04:41:09 <aarvar> uh, no
04:41:14 <aarvar> makes no sense
04:41:26 <montanonic> aarvar: what do you mean, no?
04:41:41 <aarvar> I mean, what does that even mean?
04:42:59 <montanonic> forcing things to happen one after the other, creating variable scope through functions that only apply to future computations
04:43:19 <montanonic> \x -> this part can use x but not y, \y -> this part can use x and y
04:43:27 <aarvar> but monads aren't about computations or sequencing
10:47:31 <hiptobecubic> ggole, you have to have not used them to appreciate them
11:47:05 <SomeT> How do I use map to remove the first character from each of a list of words?
11:48:30 <kadoban> SomeT: You get lunch, wait until you have time to focus on this, and then ask again.
11:48:51 <SomeT> lunch?
11:49:05 <kadoban> Well, whatever meal is appropriate for your local time of day.
11:50:45 <SomeT> why?
11:51:05 <mniip> well you seem to be extremely hungry
11:51:17 <mniip> I guess that affects your ability to reason
11:52:03 <SomeT> I just got told to come here instead
11:52:10 <SomeT> all I need is one piece of syntax
11:52:21 <EvanR> do you know how to remove the first character from 1 word
11:53:01 <SomeT> yes
11:53:11 <SomeT> -1 [list] etc...
11:53:16 * Clint squints.
11:53:25 <EvanR> does look quite right
11:53:30 <EvanR> does not*
11:53:39 <SomeT> ok
11:53:40 <EvanR> you need to solve this sub problem first
11:53:47 <SomeT> what sub problem?¬
11:53:57 <EvanR> how to remove the first character from 1 string
11:55:57 <SomeT> ok but if I don't know how to do this in haskell how can I possibly know then what is the point of me asking the question?
11:56:17 <EvanR> once you figure out the first part, then use map to do it on everything in a list
11:56:25 <EvanR> which is what map does
11:56:33 <EvanR> does soemthing to everything in a list
11:56:36 <Jinxit> maybe it's time to read some basic haskell resources, like a book
11:57:15 <mniip> SomeT, you're making no sense right now
11:57:35 <SomeT> all haskell books I read don't explain things well at all
11:57:45 <Lokathor> SomeT, it may seem unhelpful to hear, but you have to slow down and learn the basics yourself for a bit. if we just told you the answer you'd just get stuck on the next problem
11:57:46 <EvanR> "if i dont know, how can i possible know"
11:57:54 <EvanR> very philsophical
11:58:01 <Jinxit> I can't imagine you've read them very well if you can't remove the first character of a string
11:58:17 <Lokathor> SomeT, the book you're using to learn haskell is not the best book on Haskell. Have you tried any other books?
11:58:33 <EvanR> LYAH has got to cover this
11:58:39 <SomeT> no I can't afford to
11:58:41 <suppi> Lokathor, which one is it?
11:58:56 <SomeT> I give up to be honest
11:58:57 <SomeT> thanks anyway
11:59:07 <Lokathor> http://www.tech.dmu.ac.uk/~drs/ctec1901/fp/H6.html is the homework, the page lists "Graham Hutton, Programming in Haskell" as the book
12:00:04 <mniip> which reminds me
12:00:12 <mniip> bitemyapp, haskellbook for btc when
12:00:34 <mniip> :D
12:01:19 <Kang0> (Kang0) Which are more popular free vpn used by irc users???
12:01:35 <monochrom> off-topic
12:01:46 <mniip> Kang0, this is #haskell
12:02:09 <EvanR> this is sparta
12:06:29 <Kang0> Noted
12:14:15 <doomrobo> lambdabot, let sum_sq :: [Int] -> [Int] -> Int; sum_sq = sum . zipWith (\x y -> (x - y)^2)
12:14:22 <doomrobo> whoops, not a bot
12:14:45 <kadoban> > let blahblah = "wheee" in blahblah
12:14:47 <lambdabot>  "wheee"
12:15:05 <doomrobo> > let sum_sq :: [Int] -> [Int] -> Int; sum_sq = sum . zipWith (\x y -> (x - y)^2)
12:15:06 <lambdabot>  <no location info>:
12:15:06 <lambdabot>      not an expression: ‘let sum_sq :: [Int] -> [Int] -> Int; sum_sq = sum . ...
12:15:37 <doomrobo> Anyway, can anyone tell me why ghci thinks the above code is actually of the type [Int] -> [Int] -> [Int]?
12:16:07 <mniip> doomrobo, it's @let
12:16:13 <mniip> it doesn't react to its nickname
12:16:31 <kadoban> > let {sum_sq :: [Int] -> [Int] -> Int; sum_sq = sum . zipWith (\x y -> (x - y)^2)} in undefined
12:16:32 <mniip> doomrobo, it could be
12:16:32 <lambdabot>      Couldn't match type ‘[Int]’ with ‘[Int] -> Int’
12:16:32 <lambdabot>      Expected type: [Int] -> [Int] -> [Int] -> Int
12:16:32 <lambdabot>        Actual type: [Int] -> [Int] -> [Int]
12:17:20 <mniip> doomrobo, zipWith takes 2 arguments
12:17:29 <mniip> so . doesn't do the thing you think it does here
12:17:35 <mniip> er
12:17:42 <mniip> zipWith (\x y -> (x - y)^2)
12:17:43 <doomrobo> 3
12:17:45 <mniip> that takes 2 arguments
12:17:49 <doomrobo> yes
12:18:08 <mniip> it is, quite literally,
12:18:20 <mniip> \x -> sum (zipWith (...) x)
12:18:25 <mniip> so you're summing a function
12:18:47 <doomrobo> oof. how do I get the composition to work after the 2 args come in?
12:20:55 <lyxia> I'd write the function pointfully.
12:22:21 <mniip> if you don't like what lyxia said,
12:22:23 <lyxia> doomrobo: It's also possible to define an operator to compose with a 2 argument function: (..) = (.) (.) (.)
12:22:28 <mniip> (sum .) . zipWith (...)
12:22:38 <doomrobo> > let {sum_sq :: [Int] -> [Int] -> Int; sum_sq xs ys = sum $ zipWith (\x y -> (x - y)^2) xs ys} in undefined
12:22:39 <lyxia> or that :)
12:22:40 <lambdabot>  *Exception: Prelude.undefined
12:23:56 <doomrobo> mniip, can you explain how that works? Also would that be not recommended because of poor readability?
12:25:19 <EvanR> :t let (:.) = (.) . (.) in (:.)
12:25:20 <lambdabot>     Not in scope: data constructor ‘:.’
12:25:20 <lambdabot>     Perhaps you meant one of these:
12:25:20 <lambdabot>       ‘:+’ (imported from Data.Complex),
12:25:31 <mniip> we apply (sum .) to the result of zipWith (...)
12:25:31 <EvanR> :t let (.:) = (.) . (.) in (.:)
12:25:33 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:25:33 <mniip> that is, a function
12:25:45 <lyxia> :t fmap fmap fmap
12:25:46 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:25:47 <mniip> so we compose sum with that function
12:26:18 <mniip> more formally,
12:26:23 <mniip> (sum .) . zipWith f
12:26:53 <mniip> \x -> sum . zipWith f x
12:27:08 <mniip> \x y -> sum (zipWith f x y)
12:27:34 <doomrobo> oh I see. thanks!
12:39:44 <doomrobo> mniip, I'm pretty new to haskell. Is there any clearer or terser way to write this function? hamming :: String -> String -> Int; hamming a b = sum $ zipWith (\x y -> fromBool $ x /= y) (ord <$> a) (ord <$> b)
12:40:25 <mauke> why ord?
12:40:37 <mniip> why not move the ords into the predicate
12:40:47 <mniip> and then eliminate them because that's what /= does anyway
12:41:07 <doomrobo> good point. I had that because I was experimenting with a few different distances
12:41:21 <mniip> also I am slightly tempted to rewrite that in terms of length+filter+zip
12:43:37 <Wizek_> Hey! Is there a way to see reverse dependencies on Hackage? (What packages depend on a given package.)
12:44:02 <mniip> http://packdeps.haskellers.com/reverse
12:44:51 <dedgrant__> mniip: That's cool
12:45:21 <doomrobo> let {hamming :: String -> String -> Int; hamming a b = length $ filter (\x -> fst x /= snd x) $ zip a b} in hamming "hello" "yellq"
12:45:25 <doomrobo> > let {hamming :: String -> String -> Int; hamming a b = length $ filter (\x -> fst x /= snd x) $ zip a b} in hamming "hello" "yellq"
12:45:26 <lambdabot>  2
12:45:43 <niez> stack setup issue: safecopy: needed (>=0.8 && <0.9.0.1), 0.9.0.1 found (latest applicable is 0.9.0), what does 'latest applicable' mean?
12:45:53 <doomrobo> mniip, I assume that's what you mean by length filter zip. I like that too. I think I can do better with the fst /= snd though
12:46:03 <Wizek_> mniip, Thanks!
12:46:16 <mniip> doomrobo, uncurry (/=)
12:46:25 <mniip> but that's slightly hacky
12:46:44 <mniip> you can also filter id . zipWith (/=)
12:46:53 <mniip> er, .:
12:46:54 <mniip> :)
12:47:07 <mniip> yeah
12:47:10 <geekosaur> niez, note that "<0.9.0.1" excludes 0.9.0.1
12:47:16 <mniip> length $ filter id $ zipWith (/=) a b
12:47:17 <mniip> seems cool
12:47:21 <geekosaur> (it's not <=)
12:47:24 <niez> geekosaur, ah! :)
12:47:49 <doomrobo> yeah, nice
12:48:01 <hsk3> Is there a standard Haskell function to repeat a list? For example, "asdf" -> "asdfasdfasdfasdf..."
12:48:07 <mniip> :t cycle
12:48:08 <lambdabot> [a] -> [a]
12:48:12 <hsk3> thanks brother
12:50:30 <rui> Is there some place where the community shows its interest in ideas for new libraries, votes, problems to be solved, coordinates efforts, etc?
12:51:40 <ocharles_> tomjaguarpaw: I emailed one of your many aliases
12:51:47 <ocharles_> I think your -2015 address
12:52:06 <doomrobo> I have a list of Strings that I get certain properties from. These properties are a min and max of some operation applied to the string. I want to filter out the ones with min < 3 and sort the rest by their max. Right now I'm doing that by storing a list like [("hello", (3,4)), ("hellq", (4, 4))...] and then filtering and then sorting. is there a nicer way?
12:53:29 <mniip> a record?
12:54:21 <doomrobo> oh I thought maybe a way to avoid storing anything, but that might not be possible
12:55:02 <kadoban> > sortBy (comparing length) . filter (\x -> length x > 3) $ ["hi", "wowww", "hello"]  -- something like this?
12:55:04 <lambdabot>  ["wowww","hello"]
12:56:05 <doomrobo> no, more like sortBy (comparing foo) . filter (\x -> bar x > 3) $ ["hi", "wowww", "hello"]
12:56:29 <prooftechnique> What do you mean by "storing anything"?
12:56:31 <doomrobo> actually, no. it's one function run on each x that returns 2 values
12:56:33 <johnw> sortBy (comparing length) == sortOn length
12:57:16 <doomrobo> prooftechnique, doing the filtering and sorting without having to put the numbers explicitly in my list. Ya know what, let me just paste the code
12:57:47 <danilo2> Hello guys! We (I and guys we form a company with) are just releasing our long awaited baby - a new visual programming language, completely written in Haskell! I don't think it woud be possible without you, because your support was and is always great. So first of all thank you all, very, very much! :) And here it is: http://www.luna-lang.org ! :) If you like to ask any questions, I would always love to answer them! :)
12:58:25 <prooftechnique> Certainly a flashy site. :)
12:58:29 <danilo2> We're just releasing it as private alpha and will open source it shortly
12:59:09 <doomrobo> My main concern is the ugliness of min_max, best_candidate, and derive. http://lpaste.net/152898
12:59:51 <danilo2> prooftechnique: if you've got any hints regarding the website, I would be happy to apply them too :)
12:59:57 <kadoban> danilo2: The title "Why software development is just broken by design?" seems really clunky to me, if you're looking for constructive criticism
13:00:30 <doomrobo> the program starts with a list of strings (starter) that have a minimum pairwise hamming with each other of 3. It then searches all possible binary strings of length 6 and finds another one such that, when added to the list, the minimum pairwise hamming distance is still at least 3, and the maximum pairwise hamming distance is minimized
13:02:53 <danilo2> kadoban: I'm always looking for constructive critism. Why it looks clunky to you? We want to express that "writing so many lines of code scattered over so many files" is just "broken", because it is unreadable and hard to maintain in comparison to modern hybrid visual - textual programming.
13:04:17 <prooftechnique> Well, hlint gives one nice cleanup you can do
13:04:49 <prooftechnique> zipWith foo (repeat x) xs == map (foo x) xs
13:05:33 <kadoban> danilo2: Something about the wording. My improvement suggestions would be: "Why is software development broken?" "Why is software development broken by design?" or "Software development is broken by design"  The last is probably my favorite. Not sure I can quantify why it sounds clunky.
13:06:04 <prooftechnique> Question headlines always seem a bit odd. Don't invite speculation, tell the consumer what's wrong
13:06:33 <doomrobo> prooftechnique, ah, I thought it was mistaken but I see what it means now. thanks
13:07:07 <kadoban> "Do you want to learn even more?" also sounds a bit odd to me, though slightly less obviously
13:07:50 <danilo2> kadoban: I see, ok that sounds ok. By the way we were also thinking about describing the textual software develoment as "old-school" and I'm also considering the following title here: "Old-school software development is broken by design" - does it sounds even better to you?
13:08:25 <kadoban> Yes, that sounds fine to me.
13:08:52 <kadoban> Possibly "Traditional" instead of old-school, depends on the tone you want.
13:10:15 <prooftechnique> doomrobo: You could also rewrite min_max as liftA2 (,) maximum minimum . all_dists
13:10:41 <prooftechnique> Though that's not actually more readable unless you're used to that style
13:11:17 <danilo2> kadoban: you're right. Traditional fits better in the tone here. Thank you! It's fixed now! :)
13:11:35 <kadoban> :)
13:11:58 <doomrobo> prooftechnique, interesting. yeah that works
13:12:43 <osfameron> oh.  when I run `cabal update` I get: cabal: out of memory (requested 1048576 bytes)
13:12:49 <osfameron> that's... er...
13:14:54 <kadoban> osfameron: Are you low on free memory?
13:16:24 <osfameron> well, `free` says 741M
13:16:47 <osfameron> it's in a VM.  That seems plenty to me
13:17:27 <osfameron> here's exactly the same issue https://ghc.haskell.org/trac/ghc/ticket/9904
13:17:54 <osfameron> on OpenBSD rather than ubuntu though.  The reporter has closed the issue as if it's their fault
13:17:59 <osfameron> whereas it's clearly a bug :-(
13:18:16 <doomrobo> prooftechnique, also something someone mentioned earlier, I can change sortBy (comparing (snd . snd)) into sortOn (snd . snd)
13:18:27 <prooftechnique> Yes, indeed
13:19:22 <prsteele> Hello everyone. I'm just starting to use Lens, and I'm wondering how to do the following properly. I have code like "map (^. someField) (x ^. fieldThatIsAList)" to get a list of things from x, and then get a field from each element of x. Any idea how to write this mor idiomatically?
13:22:32 <puregreen> x ^.. fieldThatIsAList . each . someField
13:22:53 <prsteele> puregreen: thanks, I'll start parsing that
13:26:51 <preyalone> what's the haskell equivalent of python `pass`, to legally note an incomplete function def?
13:27:00 <johnw> undefined
13:27:03 <preyalone> thx
13:27:17 <johnw> it will raise an exception if you try to use that function
13:28:49 <mauke> (pass is more like return ())
13:29:05 <nitrix> :t undefined
13:29:06 <lambdabot> t
13:29:13 <nitrix> preyalone: undefined :: t
13:29:38 * osfameron runs `cabal install cabal cabal-install` to see if that fixes the cabal update memory bug...
13:32:33 <osfameron> apparenly not :-(
13:32:54 <osfameron> does cabal really need more than 1GB just to curl a list of packages?
13:33:59 <kadoban> You could just switch to stack ;) Though stack probably uses more memory than it needs to also. It doesn't sound right that cabal would be using that much at all.
13:34:13 <kadoban> osfameron: Does it take a while and then fail, or is it immediate?
13:35:36 <osfameron> kadoban: trying to upgrade cabal installed up to [33 of 81] before the "ghc: out of memory (requested 1048576 bytes)" error
13:36:48 <Wizek_> Has anyone some ideas on how to simply unit tests in Haskell while mocking some dependencies? E.g. a using dependency injection that's more consice than 'ad-hock parameter abstraction' (https://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/) or defining records?
13:36:54 <kadoban> osfameron: Oh, well that's obviously doing more than just downloading something, that's GHC building stuff. I wouldn't be surprised if it takes more than 1GB of RAM to build stuff with GHC.
13:37:33 <kadoban> osfameron: I usually don't even try without at least 2GB, personally. It's unfortunate, but … RAM is pretty plentiful these days.
13:37:41 <osfameron> ok, it failed before doing a cabal update too though
13:37:48 <osfameron> hmmm, and now cabal update works
13:37:58 <osfameron> I'll add another GB to the VM I guess
13:40:00 <kadoban> osfameron: Not that it'll save you from having to add RAM, but stack really is a nice improvement over cabal-install if you haven't tried it yet.
13:40:10 <Wizek_> On a related note: might anyone here be familiar with Angular.js' (1.x) Dependency Injection system?
13:41:26 <osfameron> kadoban: ah, I was just reading about it today -- it looked like it was more an equivalent to virtualenv/Bundler/perlbrew/etc. ?  is it also an installer then?
13:41:48 <preyalone> what's the inline equivalent of ; in other words, inlining two sequential but data-independent actions?
13:42:59 <preyalone> ah, double greater than! >>
13:43:00 <kadoban> osfameron: It's somewhat closer to those, yeah, but it has a different model IIUC. It can install haskell programs, yeah. It manages GHC and downloading dependencies for projects and sandboxes for you, it's pretty nice once you figure it out (which isn't too hard)
13:44:19 <osfameron> Wizek_: I've briefly used Angular 1, it was quite cute (though I don't think I'd use it again, largely because of the support issue with all dev moving to Angular 2)
13:45:36 <osfameron> kadoban: ok, I'll have a play.  I don't think http://docs.haskellstack.org/ clearly described what it's supposed to do
13:45:48 <Wizek_> osfameron, Have you had a chance to try out how mocking works with the depencdency injector in a unit test? I'm looking for something similar in Haskell.
13:45:50 <osfameron> e.g. I didn't get from reading that that I should be using it *instead* of cabal...
13:46:16 <kadoban> osfameron: Ah, yeah it's a replacement for cabal-install.
13:46:44 <osfameron> Wizek_: sorry, no.  (But the dependency injection stuff in Angular 1 was somewhere between "impressive" and "frightening" if I remember correctly ;-)
13:47:16 <Wizek_> osfameron, Impressive, I understand. Frightening, in what way? :)
13:49:06 <osfameron> Wizek_: it wasn't very clear how it decided which dependency was being passed in which order.  I eventually had the idea that it parses the function body to find out the name of the expected parameters, which rather frightened me
13:49:15 <EvanR> Wizek_: re: byorgy's post about deeper customizable functions... besides make separate top level functions to control the (one) lowest level super customizable function... you can do optional named parameters using a configuration monoid
13:49:28 <EvanR> mempty is the default configuration and you can mappend custom choices on that
13:49:41 <osfameron> kadoban: interesting.  Could you have figured that out from e.g. http://docs.haskellstack.org/en/stable/README/ ?
13:49:42 <Wizek_> osfameron, I can also recommend giving `stack` a try. I'm not imressed by it's concept, but in day-to-day development it has made my life easier definitely.
13:50:18 <preyalone> is there an integral version of take?
13:51:02 <EvanR> :t genericTake
13:51:03 <lambdabot> Integral i => i -> [a] -> [a]
13:51:03 <kadoban> osfameron: Not sure, it could probably say something more concrete instead of "for developing Haskell projects"
13:51:53 <EvanR> preyalone: though you might want to use take and fromIntegral instead
13:52:06 <EvanR> depending on how this generic stuff is implemented
13:52:14 <kadoban> osfameron: If you have an idea for how it should be worded better, or what specifically would have helped you understand, I'm sure the suggestion would be strongly considered.
13:53:23 <osfameron> kadoban: I'm not sure.  Part of the problem may be that I've been dipping in and out of Haskell for last 10 years, so perhaps if I'd been reading the *current* tutorials I wouldn't have been confused :D
13:53:48 <osfameron> but certainly something like "This is a replacement for cabal-install, and can be used to install Haskell modules" would have been clearer for me.
13:54:18 <osfameron> as I literally had no idea that it could do that from the front page of the docs
13:54:22 <preyalone> EvanR: are Int's 64 bit by default now?
13:55:03 <kadoban> Not a bad suggestion. If you feel like it, there's a github repo you can open issues, or I'll do it myself later when I figure out what I'd say. https://github.com/commercialhaskell/stack/issues
13:55:08 <Wizek_> EvanR, Hmm, interesting idea. Might you have an example on that?
13:55:13 <osfameron> it mentions cabal only a) as a means to install it and b) with regards to the ".cabal" file (which I don't understand - if we're not using cabal-install, why do we need a .cabal file?)
13:55:53 <kadoban> osfameron: It uses the same .cabal file format, because it'd be pretty horrible having to change every package ever to use it with stack
13:55:58 <osfameron> kadoban: good idea, I'll create an issue now, 1 sec
13:56:33 <EvanR> Wizek_: yes i believe they use it in the library optparse-applicative
13:56:34 <EvanR> https://hackage.haskell.org/package/optparse-applicative
13:56:54 <EvanR> preyalone: Int is 64bit on 64bit machine
13:57:35 <Wizek_> What a coincidence. I've been meaning to try out that lib for a little while. One more reason to do so.
13:58:21 <swizzard> hey all, i'm feeling very beaten down by State monads and I need some help
13:59:01 <quazimodo> people
13:59:36 <quazimodo> I want to write a small userland driver/daemon to get input from a particular usb device and do stuff with it. Not sure yet what stuff
14:00:02 <quazimodo> i can do it in ruby (already have a partial implementation) or i could learn more haskell with it, or I can try Rust
14:00:18 <quazimodo> not sure if it makes sense to use haskell for this
14:00:39 <prsteele> swizzard: if you have a question, feel free to ask
14:00:42 <monochrom> certain more sense than ruby. for better type safety.
14:01:10 <EvanR> quazimodo: what is the interface to this usb thing, blocking read from a device file?
14:01:15 <quazimodo> monochrom: the ruby daemon i have is nice, it's doing it's job
14:01:23 <quazimodo> but yeah, i like to try haskell or rust tbh
14:01:30 <swizzard> prsteele: I've got something like this: https://gist.github.com/swizzard/a08982d6c1f05ad26a9e
14:01:45 <quazimodo> EvanR: that's what I'm doing now, setting a long timeout and grabbing chunks of input
14:01:46 <Wizek_> quazimodo, I'm not sure about the other parts of your project, but making a daemon is as easy as for instance calling the `deamonize` function from https://hackage.haskell.org/package/hdaemonize-0.5.0.1/docs/System-Posix-Daemonize.html
14:01:48 <quazimodo> using libusb
14:01:58 <osfameron> kadoban: https://github.com/commercialhaskell/stack/issues/1816 not sure if that makes sens?
14:02:01 <osfameron> *sense
14:02:26 <EvanR> quazimodo: so far that part, you can do it the same way in haskell
14:02:38 <EvanR> as a thread
14:02:43 <prsteele> swizzard: okay, so what state are you trying to track?
14:03:01 <kadoban> osfameron: Seems fine as a way to start discussion, I think. I'll chime in if I think of anything interesting to say.
14:03:06 <osfameron> thanks :-)
14:03:10 <swizzard> prsteele: the state would be a value of type C
14:03:12 <quazimodo> EvanR: I'm not sure how I'd do async to be honest. Would I have to use ffi or something to leverage libusb?
14:03:16 <kadoban> osfameron: Thanks for helping out :)
14:03:31 <EvanR> quazimodo: theres a bindings lib for libusb
14:03:40 <EvanR> you could check it how it looks and feels
14:04:02 <EvanR> bindings could be very raw (good), very wrapped and nice (good) or a mishandled mismash ;)
14:04:11 <swizzard> prsteele: i've tried to do `type CS = State C Bool`
14:04:11 * hackagebot hpdft 0.1.0.2 - A tool for looking through PDF file using Haskell  https://hackage.haskell.org/package/hpdft-0.1.0.2 (keiichiroShikano)
14:05:08 <quazimodo> EvanR: lol
14:05:11 <monochrom> swizzard: if you now add this definition "xxx = state countdown", then xxx will have type State C Bool. "state" is in Control.Monad.State, look for its type there
14:05:17 <EvanR> quazimodo: oh interesting... http://hackage.haskell.org/package/usb
14:05:43 <quazimodo> on an entirely unrelated note, my arms are extremely sore 
14:06:01 <monochrom> and I wouldn't introduce any type synonym of my own. adding more names serves only to procratinate understanding.
14:06:26 <prsteele> swizzard: to start you'd want "Type Cs = State C" probably; one sec, writing a paste
14:06:41 <swizzard> prsteele: oh word
14:06:46 <EvanR> quazimodo: and the homepage for that lib seems to have examples and stuff
14:06:51 <hsk3> Is there an opposite function to elemIndices? Something that takes indexes, splits a list at those indexes, and returns a list of lists?
14:07:27 <kadoban> :t elemIndicies
14:07:28 <lambdabot>     Not in scope: ‘elemIndicies’
14:07:28 <lambdabot>     Perhaps you meant one of these:
14:07:28 <lambdabot>       ‘BS.elemIndices’ (imported from Data.ByteString),
14:07:41 <lpaste> prsteele pasted “swizzard” at http://lpaste.net/152901
14:07:54 <puregreen> hsk3: there's probably something in split
14:07:59 <puregreen> @hackage split
14:07:59 <lambdabot> http://hackage.haskell.org/package/split
14:08:05 <EvanR> quazimodo: and on that note bbl
14:08:36 <puregreen> hsk3: “splitPlaces” looks like what you want
14:08:48 <prsteele> swizzard: pretty sure that's what you're looking for
14:09:03 <puregreen> (well, almost – you still have to turn indexes into lengths)
14:09:18 <hsk3> puregreen: yeah, thanks!!
14:09:36 <hsk3> oh yeah..
14:10:54 <hsk3> i found one splitByIndices but it's in anothe rpackage
14:10:58 <hsk3> i can copy that source code
14:10:59 <quazimodo> EvanR: cheers
14:11:07 <swizzard> prsteele: hm, thanks
14:11:39 <akfp> There's no Text -> ByteString decoding of base64?
14:12:14 <prsteele> swizzard: so I think the main observation is that your state should accept one type parameter (i.e. kind * -> *) because your functions can return any value independently of the type of your state
14:16:30 <swizzard> prsteele: right, that makes sense. that snippet was helpful, thank you
14:16:42 <prsteele> swizzard: you're welcome!
14:16:57 <srpx> Anyone has a short name for this structure? `data BinaryUntaggedTree a = Node (BinaryUntaggedTree a) (BinaryUntaggedTree a) | Leaf a`. Tree is already on Hackage and has any number of children.
14:17:07 <swizzard> prsteele: the only thing is that `put (Wait (i - 1)) >> countdown` means it recurs all the way to `(True, Go)` every time you run it
14:17:56 <swizzard> prsteele: & when i get rid of the `>> countdown` part, i get an err about '()' isn't 'Bool'
14:18:09 <kadoban> srpx: LeafTree ?
14:21:39 <prsteele> swizzard: ya. You've stated "countdown :: State' Bool"
14:21:45 <prsteele> swizzard: so you need to return a Bool
14:22:01 <swizzard> prsteele: right
14:22:18 <prsteele> but "put :: State' ()" here
14:22:28 <swizzard> prsteele: right, that makes sense
14:22:51 <swizzard> prsteele: what i'd like is `countdown (Wait 10) = (False, Wait 9)`
14:23:38 <srpx> kadoban maybe
14:23:50 <prsteele> you want to return False, and store Wait 9?
14:24:03 <prsteele> put (Wait 9) >> return False
14:26:01 <prooftechnique> danilo2: Tried to sign up for the alpha, but I didn't get any feedback from the form. Can't tell if my application actually went through
14:27:54 <swizzard> prsteele: so `put` affects the state, and `return` affects the value?
14:28:51 <danilo2> prooftechnique: yes I know, mailchimp is down for 10 minutes right now - we use it to gather mails (https://status.mailchimp.com/messages) I'm sorry I cannot do anything aobut it right now :( You can sign aup as fast as it gets online, or just send me an email with the responses if you want to do it now :) (wojciech <dot> danilo) at newbyteorder.com . :)
14:29:00 <prsteele> yes. return :: a -> m a, and works for all monads. put :: a -> m (), and is specific to the State monad
14:29:27 <prooftechnique> danilo2: Oh, okay. I knew it was MailChimp, I just didn't realize they were down :D
14:29:31 <prooftechnique> I'll try again in a little while
14:29:59 <prooftechnique> Bad timing :)
14:30:13 <danilo2> prooftechnique: They broke down 10 minutes after we told about our release, heh :D
14:30:19 <danilo2> yep
14:31:47 <tippeneinn> Anyone have a pattern for abstracting away the connection pool for use with persistent postgresql?
14:32:39 <tippeneinn> for example, I want to migrate and seed in Main.hs but do database queries in Database.hs. how do I use the pool across modules
14:33:25 <swizzard> prsteele: ok great! thank you!
14:33:40 <shapr> danilo2: nodelab looks nifty
14:34:32 <dmj> tippeneinn: could use (MondIO m, MonadReader ConnPool m => Query -> m ByteString
14:34:32 <dmj> Do you know how to write a swagger `Schema` for non-json files?
14:35:01 <dmj> disregard that last comment
14:35:41 <danilo2> shapr: I'm glad to hear that! :) It's look is a "part of the visual language" so we put great effort to make it look good :)
14:36:03 <prooftechnique> tippeneinn: Could you use createPostgresqlPool and then have your functions take a pool as an argument?
14:36:56 <prooftechnique> You take the burden for cleaning up at the end, but you should be able to reuse it, anyway
14:37:40 <tippeneinn> prooftechnique: that's what I have now, but I don't like passing around a pool
14:37:46 <prooftechnique> Ah
14:39:18 <prooftechnique> danilo2: Any support for something like typed holes? Say I set up a node to compute the nth prime. Do I get a nice little anchor on one end that says something like "n : Integer"? Or some other way to indicate visually what sort of type it's expecting?
14:41:00 <danilo2> prooftechnique: sure, the edge colors indicate types - our interpreter runs constantly in the background and infers as much as possible to give the best hints its able to give. But thats goodpoint, its not stated clearly enough in the website!
14:42:34 <danilo2> prooftechnique: If you put a node (in fact nodes are methods) and you connect something to it, than outputs get collored (and you can also display types they get) as fast as we are able to infer them
14:42:51 <prooftechnique> Oh, that sounds great, then
14:44:44 <prooftechnique> And I assume there's a glossary of colors or some kind of legend displayed as well, yes?
14:51:41 <danilo2> prooftechnique: Ok, you can use google-form instead, we've replaced mailchimp with it until mailchimp gets back online :)
14:52:13 <adas> how big of a problem are the slow compilation times that seem to have surfaced in the newer version of GHC?
14:53:15 <prooftechnique> danilo2: Signed up. :)
14:53:40 <prooftechnique> adas: Depends how big your projects are
14:53:54 <danilo2> great! Thank you! :)
14:54:08 <adas> prooftechnique: are there any efforts to address that problem?
14:54:30 <srpx> K = constant, I = id. what is the intuitive name for S?
14:55:12 <prooftechnique> adas: There are, though they're not written in stone, yet. Austin Seipp was talking about it on Reddit recently
14:55:20 <monochrom> sublime
14:56:42 <adas> i see. it would be a sad state of affairs if folks stop using haskell in industry or in production due to its long compile times
14:59:12 <preyalone> what's the easiest builtin way to print (string label) ++ ": " ++ (Showable value)?
14:59:19 <preyalone> right now i use this snippet
14:59:23 <preyalone> shout :: (Show a) => String -> a -> IO ()
14:59:23 <preyalone> shout label value = putStrLn (label ++ ":") >> print value
15:00:39 * puregreen unashamedly uses printf for such things
15:01:06 <preyalone> what's the printf directive for big Integers?
15:01:14 <preyalone> still %d?
15:01:16 <puregreen> yeah
15:07:14 <swizzard> prsteele: i'm sorry to keep bothering you, but i'm still really not sure about what's going on w/state monads
15:07:40 <glguy> adas: Don't worry, compile times haven't gotten any slower since you asked about it earlier
15:08:17 <adas> glguy: if there was a new release in the past few minutes, it's possible it might have
15:09:32 <prsteele> swizzard: okay, do you have any specific questions?
15:09:41 <dmj> adas: until you hit a certain number of modules it's not a problem, ghci rebuilds incrementally anyways, and in principle builds are asynchronous, you can start building and still work on other things
15:09:54 <Lokathor> swizzard, also, are you working with a particular book / guide?
15:09:59 <swizzard> prsteele: yes and no? i'm not sure how to make use of that match function you gave me
15:10:14 <swizzard> Lokathor: i'm most of the way through LYaH
15:10:24 <Lokathor> dmj, i thought i read that only pacakages are build side by side, but each module within a package build is done in sequence?
15:10:37 <prsteele> swizzard: I'm not sure what you mean by 'match'
15:10:42 <adas> dmj: when folks are complaining about slow build times I though they were talking about the compiler "ghc". Isn't that what does the compiling?
15:10:45 <swizzard> prsteele: sorry, countdown
15:10:47 <Lokathor> swizzard, well... might i suggest cis 194? it's got a lot of practice problems that help you learn quite a bit
15:10:53 <Lokathor> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
15:11:06 <prsteele> ah. Perhaps if would help if you state what you want to do with that function in high-level terms.
15:11:38 <dmj> adas: yes, but for development you'll probably use ghci. Having a build server that automatically checks out a branch on each commit, solves a lot of these problems
15:12:05 <adas> so are folks complaining about slow build times with ghc or ghci?
15:12:09 <adas> or both?
15:12:27 <dmj> both probably
15:12:28 <adas> im sorry if my question does not make sense or not valid
15:12:57 <adas> i just saw a couple of threads on the haskell subreddit this morning about slow compilation times and got curious.
15:13:15 <swizzard> prsteele: honestly at this point i'm not even sure anymore, haha
15:13:32 <Lokathor> adas, ghci can usually do a fast incrimental reload, but it's just interpreting things, and so ghc is still slower because it takes time to optimize down and link and such
15:14:04 <hexagoxel> Lokathor: modules are built in parallel when you `cabal build`. they may be sequential as you say when installing multiple packages.
15:14:31 <swizzard> prsteele: part of what i want to be able to do is have an array of states, and be able to call countdown on different ones at different points, and then branch based on the results
15:14:48 <adas> so the threads on the haskell subreddit and elsewhere about slow compilation times were about ghc and not ghci?
15:14:48 <Lokathor> hexagoxel, do you know if stack also builds individual modules in parallel?
15:15:00 <dmj> adas: there's been a few
15:15:56 <adas> and so it seems the tenet is develop with ghci and compile and release with ghc
15:15:56 <prsteele> swizzard: it sounds like maybe your state should be "type MyState a = State [C] a" then? So you track a list of your C types?
15:16:20 <Lokathor> if possible, that's a good idea, yes
15:16:45 <Lokathor> not always so easy though
15:19:13 * hackagebot hjsmin 0.1.5.3 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.5.3 (ErikDeCastroLopo)
15:21:34 <mgsloan> Lokathor: It doesn't by default, it would be cool to do that automatically.  GHC supports "-j", but the performance boost doesn't seem very large.  One trickiness is that there is package level parallelism, so you have to cleverly choose the "-j" passed to ghc in order to not overwhelm your system with build tasks
15:22:02 <hexagoxel> Lokathor: stack does not seem to do, at least by default. (i'm not a heavy stack user)
15:22:09 <mgsloan> You can do 'stack build --ghc-options "-j2"' or something like that
15:22:32 <mgsloan> to get module level build parallelism
15:22:46 <mgsloan> But in my experience the speedup isn't as good as one would hope :/
15:23:42 <Lokathor> well, can't you jsut set -j to your cores count? or like one less than that?
15:24:14 * hackagebot oi 0.4.0.1 - Library for purely functional lazy interactions with the outer world.  https://hackage.haskell.org/package/oi-0.4.0.1 (NobuoYamashita)
15:24:50 <kadoban> Lokathor: The problem is that stack will build multiple packages at once, so if GHC also does multiple modules at once, you end up with more things getting done in parallel than you intended, probably like n^2 threads instead of n threads for n cores.
15:25:05 <Lokathor> oh my
15:25:26 <Lokathor> sounds like the reverse should happen, given that i expect the common case is to rebuild only a single package at once
15:26:06 <monochrom> yes but history doesn't work like that. history works by first-to-market not first-to-do-it-right
15:26:15 <Lokathor> :(
15:26:29 <monochrom> ghc devs were slower than cabal devs or stack devs in adding -j
15:26:57 <monochrom> indeed, ghc devs always prioritize fixing bugs and "one more type system extension"
15:27:10 <kadoban> I haven't timed it or anyhing, but I get the sense that doing multiple packages at once makes a bigger difference than GHC doing multiple modules at once.
15:27:14 <Lokathor> but stack could adjust perhaps?
15:27:18 <Lokathor> or maybe a new flag?
15:27:27 <Lokathor> i dunno
15:27:32 <Lokathor> i gotta go do a thing though
15:27:43 <kadoban> Lokathor: Well, it's a bit hard to say what should even happen.
15:27:54 <hexagoxel> but normally i am working on a single package, not multiple packages at once.
15:46:45 <mgsloan> Lokathor / hexagoxel - discussion of parallelism here https://github.com/commercialhaskell/stack/issues/644  I thought there was a more detailed discussion of figuring out appropriate "-j" levels to pass to ghc, but I can't find i
16:00:28 <montanonic> http://okmij.org/ftp/Computation/free-monad.html
16:00:48 <montanonic> Oleg keeps saying "The Haskell 2015 Paper". Which one is he referring to?
16:01:19 <montanonic> Oh.... I guess he means this one: http://okmij.org/ftp/Haskell/extensible/more.pdf . I couldn't tell; sorry.
16:04:41 <sm> just one more type system extension.. JUST ONE MORE
16:14:18 <enthropy> hi there, I discovered putQ / getQ in template haskell, but it seems they don't work: http://lpaste.net/152928
16:14:59 <enthropy> in the source code, it looks like putQ is defined in terms of qPutQ which is defined in terms of putQ which is ...
16:15:34 <enthropy> http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/src/Language.Haskell.TH.Syntax.html#putQ
16:22:10 <EvanR> enthropy: whether that makes sense depends on what Q does
16:23:22 <EvanR> enthropy: without knowing too much about TH, it seems to be defining an infinite sequence of Q's with x at each point
16:24:40 <EvanR> well a loop of the same x
16:25:12 <EvanR> newtype Q a = Q { unQ :: forall m. Quasi m => m a }
16:25:50 <EvanR> a hidden Quasi monad
16:26:20 <monochrom> no, it's the opposite of hidden.
16:27:14 <monochrom> "data E a = forall m. Quasi m => Q (m a)" would be hidden, i.e., existential type
16:28:11 <monochrom> but "Q (forall m. Quasi m => m a)" is the opposite. it's polymorphic.
16:28:35 <monochrom> the contrast is exactly that of "caller chooses" vs "callee chooses"
16:31:10 <EvanR> oh i still havent figured out old style data foralls
16:32:27 <Ralith> hamishmack: you around?
16:32:29 <EvanR> in both examples m doesnt appear in the type variables so i figured it was hidden
16:35:34 <EvanR> unQ :: forall m a . Quasi m => Q a -> Q (m a) ?
16:37:27 <monochrom> forall m a . Quasi m => Q a -> m a
16:37:44 <EvanR> oh
16:37:59 <EvanR> excellent
16:38:14 <EvanR> and "outer" foralls in a GADT ctor would also be polymorphic
16:38:44 <EvanR> is it possible to do existential as a gadt?
16:39:02 <monochrom> yes
16:39:16 * hackagebot uri-bytestring 0.2.0.0 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.0.0 (MichaelXavier)
16:39:26 <hchau> I'm reading the typeclassopedia which says [] can be made an Applicative in two ways, the second of which defines gs <*> xs = [ g x | g <- gs, x <- xs]
16:39:37 <hchau> would gs <*> xs = [g x | x <- xs, g <- gs] also work?
16:39:50 <shachaf> That's another way, yes.
16:40:21 <hchau> So I'm guessing I'd get a valid Applicative no matter what order I apply the gs to the xs?
16:41:53 <shachaf> There's always https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Applicative-Backwards.html
16:43:35 <Xal> hey I'm a transitioning lisper, where should I start learning haskell?
16:44:18 <shachaf> @faq might be able to answer some of your questions.
16:44:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
16:44:36 <monochrom> data Z where C1 :: forall a. a -> Z; C2 :: (forall a. a) -> Z
16:44:45 <Xal> alright, I've been poking around the tutorials right now, looks interesting
16:45:23 <EvanR> i see
16:45:41 <hchau> What does the * in Functor f => Functor (Backwards * f) mean?
16:46:11 <shachaf> hchau: * is the kind of types that can have values, like Int and Maybe Char.
16:46:13 <glguy> hchau: It means that Backwards is polykinded, and * is a kind argument
16:46:21 <shachaf> As opposed to Maybe, which is :: * -> *
16:46:24 <shachaf> And then what glguy said.
16:47:55 <hchau> Ah, okay, got it. Thanks.
17:07:00 <zd234> people tell me that haskell is a great language for writing compilers; so where are all our "here's how to do an EDSL -> Javascript in Haskell" tutorials? The best I have foudn so far is sunroof
17:08:06 <hpc> zd234: there's one that walks you through writing an entire lisp (scheme?) interpreter
17:09:43 <zd234> hpc: scheme in 24 hours?
17:09:55 <zd234> hpc: but it doesn't handle typing and it isn't embedded in haskell
17:10:01 <montanonic> zd234: there's Write Yourself a Scheme
17:10:01 <zd234> it's more like "here's how you use parsec + monads"
17:10:06 <zd234> yeah; taht one
17:10:16 <montanonic> but it has difficulty spikes
17:10:46 <hpc> by and large, compilers and interpreters aren't a terribly tutorial-able topic
17:11:22 <zd234> hpc: what are you talking about? I'm waiting for write yourself a GHC in 21 days
17:13:02 <shachaf> @google typing haskell in haskell
17:13:03 <lambdabot> https://web.cecs.pdx.edu/~mpj/thih/thih.pdf
17:13:13 <phasnox> Helloo, is it true that large Haskell projects take a lot of time to compile?
17:13:38 <zd234> shachaf++
17:13:50 <zd234> phasnox: if you use ghcjs + template haskell, yes
17:14:11 <hpc> phasnox: large projects in general take a lot of time to compile
17:14:35 <phasnox> =) good point
17:15:25 <phasnox> I come from interpreted languages world
17:15:47 <hpc> ah, you'll likely be annoyed, but not too annoyed
17:16:15 <hpc> you get a lot back from the extra up-front time cost
17:16:34 <phasnox> Yeahp I remember how long it was waiting for java
17:17:50 <phasnox> It was kinda painful, a small change and I had to wait 2 minutes 
17:18:14 <zd234> phasnox: are you using ghci? it can only recompile changed modules
17:19:04 <hpc> yeah, was about to mention
17:19:20 <hpc> ghci is very comfortable for people coming from interpreted languages
17:19:34 <phasnox> Hmm I'm new still learning the basics 
17:19:34 <hpc> edit a file, then type :r in ghci
17:19:44 <hpc> and it runs a faster compile to bytecode
17:19:50 <phasnox> So that is a possibility
17:20:03 <phasnox> Ohhh greaat
17:20:06 <hpc> and then repl the day away
17:20:08 <hpc> as one does
17:20:45 <hpc> code that's been compiled to binary will not need to be compiled
17:20:47 <hpc> ghci can mix them
17:21:31 <phasnox> Oh that is great for development
17:32:51 <phasnox> Sorry connection issues
17:32:54 <phasnox> Thanks guys
17:33:03 <phasnox> !
17:42:36 <fr3tz0r> how do you get rid of indentation problems in haskell when the editor displays it right but compiler thinks the lining are another then the lining that are displayed in the editor
17:43:02 <geekosaur> tell your editor to indent with spaces, not tabs
17:43:04 <kadoban> fr3tz0r: Don't use tabs, use spaces.
17:43:12 <shachaf> First you accept that the compiler is right and the editor is wrong.
17:43:21 <fr3tz0r> i already done that
17:43:40 <fr3tz0r> accepting
17:43:44 <geekosaur> (atom gets this wrong, if you set the editing tabstop to 2 then it saves 2-space tabs in the file. ghc expecs tabs to be 8 spaces)
17:43:59 <fr3tz0r> i will change to spaces in editor thx
17:44:50 <fr3tz0r> strange it works all time but all of a sudden problen occours
17:44:58 <fr3tz0r> problem
17:46:11 <kadoban> fr3tz0r: Which editor?
17:47:42 <fr3tz0r> sublime text 2 , (because i need to run code on windows atm, otherwise emacs of course;))
17:48:22 <kadoban> Hmm, that should have sane tab-to-space handling.
17:50:56 <fr3tz0r> it can be another problem but the compiler just say "not in scope" but i cannot believe what can be wrong seems right
17:51:44 <kadoban> fr3tz0r: Can you lpaste the relevent code?
17:52:31 <kadoban> Usually you get parse errors from incorrect indentation, or more interesting errors than "not in scope" I thought.
17:54:30 <fr3tz0r> very similar to this
17:54:38 <fr3tz0r> http://stackoverflow.com/questions/1694097/haskell-compiler-error-not-in-scope
17:55:02 <fr3tz0r> can't paste code for this one sry
17:55:20 <kadoban> Sorry, but "very similar to" doesn't tend to be very helpful. Sure, that's fine.
17:57:45 <fr3tz0r> i have never understand what god indentation "checking" would bring to the world :(
17:58:12 <kadoban> It's not checking indentation to be pedantic, indentation has meaning.
17:58:42 <kadoban> fr3tz0r: https://en.wikibooks.org/wiki/Haskell/Indentation is probably a good summary. The haskell report is fairly readable as well.
17:58:47 <fr3tz0r> sure but so has {, ; etc
17:59:01 <kadoban> fr3tz0r: Sure, you can use those instead if you like.
18:05:12 <fr3tz0r> if a function is faulty would i be able to just get "not in scope" when calling the function
18:05:22 <fr3tz0r> ?
18:05:50 <kadoban> Depends what you mean by faulty, but doesn't sound right.
18:07:02 <deech> Trying to GHCi running on Win64 with my Haskell library and I'm getting an error about not being able to find uuid.dll. Has anyone seen this before?
18:07:06 <adas> I have a type "Agent" with a set of constructors like "Java", "Php", "Python" and so on. I would like a function that only takes `[Agent]` where each agent in that list is only either Java, Php or Python. Not any combination. How can I model this at the type system?
18:07:54 <adas> so its either [Java, Java, Java] or [Python, Python] but never [Java, Python] or [Java, Php] or [Python, Php] or some combination 
18:08:25 <kadoban> adas: Model it instead as (Agent, Int) ?
18:09:02 <adas> kadoban: I could but that looks less elegant. Perhaps unidiomatic
18:09:17 <adas> is there a standard way of accomplishing it?
18:09:19 * hackagebot hpack 0.9.1 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.9.1 (SimonHengel)
18:09:25 <kadoban> Is it? Not sure why it'd be unidiomatic.
18:10:01 <pavonia> adas: You could also make each constructor its own type. Depends on what the semantics of [Agent] is, I guess
18:10:06 <kadoban> I guess it should be (Int, Agent) instead actually, in case you want to use it in typeclassy ways.
18:10:13 <deech> adas: GADT?
18:10:23 <adas> kadoban: what does that Int do there/
18:10:25 <adas> ?
18:10:34 <adas> Is it to identify each agent?
18:10:39 <kadoban> adas: Counts how many of them there are.
18:11:00 <adas> oh .. hmm. but thats not what I want
18:11:11 <kadoban> (5, Java) is isomorphic to [Java, Java, Java, Java, Java]
18:11:13 <kadoban> Oh?
18:11:17 <adas> i think pavonia knows what I'm looking for
18:11:35 <adas> basically, I want to be able to differentiate Java, Php and Python at the type level
18:11:39 <adas> even though they are values
18:12:02 <deech> adas: GADT/Type families are what you're looking for I think ...
18:13:05 <adas> deech: is there a way to do it without type famiiles? GADT i can understand. type families scare me
18:14:01 <deech> GADT would work.
18:14:47 <adas> deech: how might I model it using GADTs? like `data Agent a where Java :: Agent Java` or something like that?
18:16:52 <deech> Yes, like that.
18:20:43 <MarcelineVQ> could also make them seperate types and consolidate them via a class, then your function could require a list of one specific agent like, myFun :: (isAgent a) => [a] -> ... , idk if that's a reccomended route
18:25:17 <adas> MarcelineVQ: yes, that could work as well. 
18:25:32 <adas> I like the fact that there are so many type-correct ways of accomplishing this  = )
18:25:40 <adas> atleast 2 so far
18:26:21 <MarcelineVQ> It's an interesting problem and it's inspired me to try out the DataKinds extension
18:48:31 <prooftechnique> Is there a way to make stack reinstall any binaries after a change of resolver?
18:49:49 <kadoban> prooftechnique: Like, all of them? Don't think so.
18:50:29 <prooftechnique> I mean just the stuff that ends up in ~/.local/bin, but that seems sensible
18:50:40 <prooftechnique> Wouldn't want to break everyone's stuff, after all
18:51:55 <kadoban> prooftechnique: One thing you could do would just be maintain a script listing them all, like a bunch of lines like: stack install hlint; stack install pandoc;, etc. and run that whenever you update your global resolver enough to care
18:57:02 <prooftechnique> Yeah, that's probably what I'll do
18:57:19 <prooftechnique> I just started playing with stack, so I haven't even really settled on it as a thing to use
19:04:37 <ZelteHonor> Hi! I would like some advice for a little chess game I made. 183 line.
19:04:47 <lpaste> ZelteHonor revised “Little chest game”: “No title” at http://lpaste.net/152931
19:06:46 <ZelteHonor> Also I am French so sorry for my poor spelling and grammar.
19:27:16 <nineonine> is it possible to resolve that ?
19:27:17 <nineonine> NB: ‘Scientific’
19:27:17 <nineonine>         is defined in ‘Data.Scientific’ in package ‘scientific-0.3.4.4’
19:27:18 <nineonine>       ‘scientific-0.3.3.8:Data.Scientific.Scientific’
19:27:19 <nineonine>         is defined in ‘Data.Scientific’ in package ‘scientific-0.3.3.8’
19:27:57 <MarcelineVQ> Use sandboxes if you aren't http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
19:28:59 <kadoban> Or just skip the pain and use stack.
19:31:06 <glguy> nineonine: You can unregister the old version, or you can use the -package and -hide-package flags to GHC to control what ghc and ghci see
19:31:18 <glguy> or you can use a .cabal file to configure your project
19:38:13 <nineonine> thanks
19:59:34 * hackagebot list-t 0.4.6.1 - ListT done right  https://hackage.haskell.org/package/list-t-0.4.6.1 (NikitaVolkov)
20:09:35 * hackagebot logging-facade 0.1.1 - Simple logging abstraction that allows multiple back-ends  https://hackage.haskell.org/package/logging-facade-0.1.1 (SimonHengel)
20:13:04 <zd234> if I'm building a compiler that needs to output js, should I write my own code or use something existing )like llvm) ?
20:13:09 <zd234> [compiler is being written in haskell]
20:59:07 <nitrix> Does haskell has a <$> operator with the precedence of $ ?
20:59:42 <shachaf> Not in any standard library.
21:01:36 <kadoban> fmap blahblah $  ?
21:53:08 <pierre_thibault> allo
21:56:57 <hodapp> Let's ask the crowd repeatedly if they're having a good time.
21:58:14 <haskell698> hi
21:58:18 <haskell698>   How can I do ToJSON for Maybe?  data MyData = MyData {   id :: Int,   something :: Maybe String }  instance ToJSON MyData where   toJSON (MyData id something) =     object ["id" .= id       , "something" .= ???     ]
21:58:45 <haskell698> http://pastebin.com/f0pXZdsC
21:59:00 <haskell698> How can I do ToJSON for "Maybe"?
22:04:44 <pavonia> haskell698: What would you like the result to be for Nothing?
22:28:54 <pierre_thibault> hello
22:29:33 <pierre_thibault> what is the difference between (6<) and (<6) ?
22:31:12 <kadoban> > ((6<) 5 , (<6) 5)
22:31:14 <lambdabot>  (False,True)
22:31:59 <pierre_thibault> i would to understand the semantic 
22:32:51 <tac_> pierre_thibault: think of it like (6<) means "Does x satisfy 6<x?"
22:33:04 <kadoban> Operator sections like that basically fill in the argument you give them on whatever side of the argument you give it.
22:33:04 <tac_> and (<6) means "Does x satisfy x < 6"
22:33:26 <kadoban> So think of (< 6) as    (<), but 6 is filled in already on the right side of the <
22:33:59 <pierre_thibault> OK, so is it valid for any function having 2 args?
22:34:03 <kadoban> So (< 6) ====>  \n -> (n < 6)
22:34:27 <kadoban> pierre_thibault: Any operator, which means symbols.    Or you can convert a function into an operator by putting backticks around it.
22:35:02 <kadoban> > let f a b = a + b in (`f' 5) 10
22:35:04 <lambdabot>  <hint>:1:27: parse error on input ‘5’
22:35:23 <pierre_thibault> kadoban: if the function takes more than 2 args?
22:35:24 <kadoban> > let f a b = a + b in (`f` 5) 10
22:35:26 <lambdabot>  15
22:36:10 <kadoban> pierre_thibault: That's a little harder to wrap your head around, but it works fine.
22:36:22 <kadoban> > let f a b c = a + b + c in (`f` 5) 10 1
22:36:24 <lambdabot>  16
22:38:50 <pierre_thibault> kadoban: let f a b c = a + b + c in (5 `f`) 10 1
22:41:10 <pierre_thibault> so can fit the first of second argument if (5 `f`) and (`f` 5)
22:41:37 <kadoban> Sure
22:41:59 <kadoban> It's used idiomatically to avoid using 'flip', by some people
22:42:40 <pierre_thibault> kadoban: how to fit a third arg with the same technique?
22:43:24 <kadoban> Operators are all binary, so you can't. (other than how I showed above … the result is still a function, so you just give it another argument if you want)
22:44:01 <pierre_thibault> OK, thank you
22:44:14 <pierre_thibault> i am pretty new to haskell
22:44:50 <kadoban> Welcome :)
23:23:51 <sm> two very cool things I've got working today: Shake, and Atom + haskell plugins
23:24:40 <sm> and live browser reloading on save. Three very cool things...
23:25:50 <schoppenhauer> https://blog.uxul.de/e?e=linear_arrays_haskell opinions?
23:29:51 <orion> http://lpaste.net/8718240482200649728 <-- These are RTS statistics for a production scotty server. Which values are most relevant for my use case?
