00:01:09 * hackagebot plan-b 0.2.0 - Failure-tolerant file and directory editing  https://hackage.haskell.org/package/plan-b-0.2.0 (mrkkrp)
00:07:41 * hackagebot hesh 1.0.0 - the Haskell Extensible Shell: Haskell for Bash-style scripts  https://hackage.haskell.org/package/hesh-1.0.0 (ChrisForno)
00:07:41 * hackagebot plan-b 0.2.0 - Failure-tolerant file and directory editing  https://hackage.haskell.org/package/plan-b-0.2.0 (mrkkrp)
00:36:26 <pavonia> Is there a way to give associated data types names? Like for "data Type Foo = MkBar" I would like to use "Bar" instead of "Type Foo" when using it in functions/instances
00:36:45 <ggVGc> I need to write a function [Int]->[Int]->[Int] where the first and second argument are vastly different semantically. how can I improve this signature to get some help from the compiler so it's not musisused accidetnally
00:36:50 <ggVGc> ?
00:37:12 <kadoban> ggVGc: newtypes ?
00:38:17 <Cale> pavonia: type synonyms can do that...
00:39:02 <pavonia> Yeah, I meant directly in the instance definition
00:39:18 <Shockk> pavonia: if you enable TypeSynonymInstances then you should be able to
00:39:22 <Shockk> I think that's what the extension is called, at least
00:39:58 <pavonia> But that still requires a type synonym, no?
00:41:27 <Cale> pavonia: I guess I don't understand what you're trying to do then...
00:42:37 * hackagebot distributed-process-ekg 0.1.0.0 - Collect node stats for EKG  https://hackage.haskell.org/package/distributed-process-ekg-0.1.0.0 (AlexanderBondarenko)
00:42:54 <Shockk> I don't think I understand either; if you have a type called (Type Foo), you can put `type Bar = Type Foo`, and if you enable TypeSynonymInstances, then you can write like:
00:43:01 <pavonia> Cale: Naming an associated data type without introducing an extra type synonym basically. But looks like there's no way to do that
00:43:05 <Shockk> instance Show Bar where show blah = etc
00:57:37 * hackagebot second-transfer 0.10.0.4 - Second Transfer HTTP/2 web server  https://hackage.haskell.org/package/second-transfer-0.10.0.4 (dsign)
00:59:51 <parsecChar> is there a version of hoogle pinned to the version of stackage I'm using ?
01:00:13 <parsecChar> I'm using latest stackage
01:02:56 <suppi> parsecChar, https://www.stackage.org/lts-5.4
01:03:21 <parsecChar> ha
01:03:22 <parsecChar> nice
01:03:27 <parsecChar> one more reason to love stack
01:03:28 <suppi> :)
01:03:44 <parsecChar> even allows me to download the hoogle database -- for local use I guess ?
01:03:54 <suppi> that I don't know
01:04:23 <parsecChar> right under the search bar, there is "Download this hoogle database"
01:05:40 <suppi> oh, right.
01:54:34 <lpaste> progato pasted “blubaba” at http://lpaste.net/670558404812472320
01:55:15 <progato> sorry, accidental paste! :)
02:19:41 <pavonia> When using Aeson's fromJSON to parse a Value, what result type do you need to parse an object like { "foo" = 123, "bar" = "blah" }?
02:21:27 <quchen> pavonia: Object is one of Value's constructors
02:21:48 <pavonia> Yes
02:22:21 <ocramz> hullo all
02:24:57 <pavonia> quchen: What I mean is, when you use ``fromJSON (object ["foo" .= 123, "bar" .= "blah"]) :: Result (Int, T.Text)'' the result is an error instead of a pair
02:25:08 <ocramz> I'd like to declare a constraint in a class method, but in a parametric fashion as if using `TypeFamilies`. E.g. `class C x where {constraint W x; method :: W x => x -> Int`
02:25:12 <ocramz> }
02:25:27 <ocramz> is there a lang extension to do this?
02:26:31 <pavonia> ocramz: I think you can use type synonyms for this
02:26:49 <pavonia> Out of the class definition
02:29:17 <quchen> pavonia: You could use a `Result Value` I think. If you write (Int, Text) here, Aeson will be using the Tuple JSON instance, and your object does not decode to a tuple without error.
02:29:41 <quchen> In fact, since JSON objects aren't ordered, you cannot decode an object to a tuple in general.
02:31:07 <pavonia> But Value just gives me the original exppression
02:31:54 <pavonia> Looks like I need a new wrapper type then
02:32:12 <quchen> Yes, that's what you usually do with Aeson.
02:33:35 <quchen> Since fromJSON :: FromJSON a => Value -> Result a, you're bound to getting results of type a, using its FromJSON instance.
02:33:58 <quchen> So if you want a result tuple, you'll implicitly use its default instance.
02:42:40 * hackagebot idris 0.10.2 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.10.2 (EdwinBrady)
02:52:36 <kamilsg> hello?
03:10:46 <Arguggi> Hello, I'm trying to use dbus but when I recieve a message I get a Dictionary where the Key is a Text (as expected) but the value isn't a Dictionary but a Variant and so using fromVariant is useless. I don't understand how to get any information out of the Variant value. Any ideas? (https://hackage.haskell.org/package/dbus-0.10.12/docs/DBus.html#v:fromVariant) 
03:14:08 <dramforever> Arguggi: If you expect the value to be a, say, Double, just case (fromVariant val :: Maybe Double) of Just x -> use x here; Nothing -> error "I thought you said double"
03:14:29 <exio4> hopefully not using error! :P
03:14:45 <dramforever> If from the "use x here" we can infer that x is a Double, the type annotation is not necessary
03:14:50 <dramforever> exio4: good point there :
03:14:52 <dramforever> :P
03:17:42 <Arguggi> dramforever, I tried that but fromVariant x :: Maybe type only gives Just something when I say Maybe Variant and variantType x ==  TypeVariant , thats why i was having problems. I used fromVariant elsewhere but only because variantType x != TypeVariant (https://hackage.haskell.org/package/dbus-0.10.12/docs/DBus.html#t:Type)
03:20:07 <saurabhnanda> hey, I'm back. Trying to grok how this works // insert :: (MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => val -> ReaderT backend m (Key val)
03:20:40 <saurabhnanda> how is "val -> ReaderT backend m (Key val)" possible without passing 'backend' and 'm' into the function
03:21:15 <Arguggi> (this is what dbus is giving me from spotify: http://lpaste.net/6606056040830074880) I can get the "Metadata" text but the value associated to "Metadata" is a Variant and I don't seem to be able to extract any values from there.
03:21:56 <saurabhnanda> the bigger question being, that doesn't the insert function need a database connection as on of the incoming args? Also, how can it conjure up a Reader monad out of nothing? What environment is it constructing?
03:22:34 <pavonia> saurabhnanda: You can use a do-block
03:22:55 <pavonia> ReaderT is a monad, so you can basically build it up from smaller monadic actions
03:23:30 <pavonia> "return (Key someValue)" for the simplest one
03:23:35 <saurabhnanda> pavonia: I forgot to mention, that function is from the yesod/persistent library.
03:24:01 <saurabhnanda> pavonia: in that context, how does that function signature make sense? Why do I not need to pass-in the DB connection to an 'insert' function?
03:24:52 <pavonia> You don't
03:25:09 <pavonia> saurabhnanda: backend is the connection?
03:25:16 <dramforever> Arguggi: that looks like a dictionary
03:25:41 <dramforever> what about fromVariant x :: Maybe Dictionary?
03:26:29 <saurabhnanda> pavonia: backend is the connection, but it's not being passed in to the function
03:27:02 <pavonia> It's a reader, you can access the backend value from the monadic action with ask
03:27:42 * hackagebot hourglass 0.2.10 - simple performant time related library  https://hackage.haskell.org/package/hourglass-0.2.10 (VincentHanquez)
03:28:55 <Arguggi> dramforever, thats what I thought too. The external "Metadata" Variant is a Dictionary and I can get the list of (Variant, Variant) pairs with dictionaryItems (https://hackage.haskell.org/package/dbus-0.10.12/docs/DBus.html#t:Dictionary), But i 
03:29:33 <saurabhnanda> pavonia: I might be grappling with something very basic then. Is there any way to simply run this function?
03:29:58 <saurabhnanda> pavonia: or the only way to run this function is to lift/fmap/bind it into some other monadic context?
03:30:00 <Arguggi> get [("Metadata", Rest :: Variant)] and I don't understand If im doing something wrong or this is a way to go from Variant -> Dictionary
03:30:29 <saurabhnanda> pavonia: can this function be run, but just passing a 'val' to it
03:30:34 <pavonia> saurabhnanda: To run it with runReaderT your need a backend value
03:30:57 <saurabhnanda> pavonia: what would the shape of that code look like?
03:31:30 <Arguggi> ( fromVariant x :: Maybe Dictionary gives me Nothing)
03:31:43 <saurabhnanda> runSqlite ":memory:" $ do // insert $ BlogPost "My fr1st p0st" johnId -- where's the backend in this code?
03:32:12 <saurabhnanda> pavonia: that code snippet is a simplification of the first example at http://www.yesodweb.com/book/persistent
03:32:49 <pavonia> saurabhnanda: What's the type of runSqlite?
03:33:05 <pavonia> It's probably internally running the reader
03:34:26 <saurabhnanda> pavonia: actually the $ before the do changes the whole meaning of that snippet, right?
03:34:45 <pavonia> No, that's just function application
03:35:04 <saurabhnanda> pavonia: the first statement in the do block is "runMigration migrateAll" with the type-sig: runMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()
03:35:57 <saurabhnanda> here's the complete code snippet: http://lpaste.net/153452
03:36:04 <pavonia> So it's one of the smaller actions to build the larger one
03:36:40 <pavonia> I have no idea what the semantics of all this is, I can only tell from the types what values are expected
03:37:16 <saurabhnanda> pavonia: thanks for helping. I'm also trying to grok persistent by understanding the types.
03:37:19 <pavonia> And it seems runSqlite is creating a backend value which you can access from the reader action
03:37:52 <saurabhnanda> how would the 'do' block be getting de-sugared here?
03:38:04 <ahihi> it is perhaps worth noting that SqlPersistT, which runSqlite takes as a parameter, is defined as type SqlPersistT = ReaderT SqlBackend
03:38:13 <ahihi> so there's the reader
03:40:19 <pavonia> saurabhnanda: runMigration migrateAll >> insert ... >>= \johnId -> insert ...
03:40:38 <pavonia> It's the same pattern for all do-blocks
03:41:00 <saurabhnanda> runSqlite :: (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl IO m) => Data.Text.Internal.Text -> SqlPersistT (Control.Monad.Logger.NoLoggingT (Control.Monad.Trans.Resource.Internal.ResourceT m)) a -> m a 
03:41:24 <saurabhnanda> pavonia: ah. I forgot about >> I've always dealt with >>=
03:42:04 <saurabhnanda> so in that code snippet, the entire do block is an argument to runSqlite?
03:42:25 <ahihi> yes
03:43:17 <saurabhnanda> but even then it's not making sense. The type of the do block us supposed to be SqlPersistT (blah), which means the Db connection / reader / whatever, is already inside the do block. Right?
03:45:05 <pavonia> saurabhnanda: It's created when runSqlite is run
03:45:07 <ahihi> the DB connection is supplied by runSqlite
03:46:16 <saurabhnanda> pavonia: ahihi probably that is right. That's what seems to make intuitive sense. But I'm unable to reconcile that with the type signatures
03:46:26 <ahihi> a value of type SqlPersistT doesn't actually do anything until it is run
03:46:41 <ahihi> well, SqlPersistT m a
03:46:51 <pavonia> saurabhnanda: You should probably read about Monad transformers before going on with this library
03:47:46 <saurabhnanda> pavonia: I tried reading about them, but everything has very simply examples, which I can understand. But every time I come back to look at Persistent, nothing about ReaderT/WriterT from the tutorials seems to make sense to me anymore.
03:47:55 <saurabhnanda> *simple examples
03:49:15 <pavonia> Maybe your confusion is because runReaderT isn't called directly but hidden somewhere in runSqlite
03:50:43 <saurabhnanda> pavonia: is there a way to "expand" haskell code?
03:50:59 <saurabhnanda> pavonia: replace function calls with underlying code?
03:51:19 <saurabhnanda> pavonia: in list there's a macro-expand feature
03:51:21 <saurabhnanda> *lisp
03:51:47 <pavonia> Not that I know of, maybe GHCi's debug features provide this
03:52:55 <pavonia> But I don't think the code of a function is still available after bulding the package binaries
03:53:41 <ahihi> hackage docs have links to the source, I tend to just study those
03:57:28 <Arguggi> dramforever, for what it's worth I think i managed to solve this. I have to call fromVariant twice to get the Dictionary (once :: Maybe Variant and the second time with :: Maybe Dictionary) don't really understand why but it seems to work
03:58:20 <dramforever> Arguggi: that was strange, but good for you :)
04:03:28 <saurabhnanda> how does one "create a Reader"
04:04:23 <pavonia> By building it up from smaller readers
04:05:18 <pavonia> :t return 123 :: Monad m => ReaderT () m Int
04:05:19 <lambdabot> Monad m => ReaderT () m Int
04:05:51 <pavonia> > runReaderT (return 123) () :: Maybe Int
04:05:53 <lambdabot>  Just 123
04:06:29 <pavonia> > runReaderT (x <- ask; return $ 2*x) 10 :: Maybe Int
04:06:30 <lambdabot>  <hint>:1:15:
04:06:31 <lambdabot>      parse error on input ‘<-’
04:06:31 <lambdabot>      Perhaps this statement should be within a 'do' block?
04:06:38 <pavonia> > runReaderT (do x <- ask; return $ 2*x) 10 :: Maybe Int
04:06:40 <lambdabot>  Just 20
04:19:08 <saurabhnanda_> pavonia: in https://gist.github.com/egonSchiele/5752172 where is the Reader being created?
04:24:42 <saulzar_> saurabhnanda, Well - for example you can easily create a reader (or any Monad) with return
04:25:09 <saulzar_> :t return 5 :: Reader String Int
04:25:10 <lambdabot> Reader String Int
04:27:00 <saurabhnanda> I'm completely lost
04:27:02 <saurabhnanda> what does this even mean?
04:27:10 <saurabhnanda> let x = return 5 :: Reader String Int
04:27:17 <saurabhnanda> runReader x "abc"
04:27:27 <saurabhnanda> it returns --> 5
04:27:30 <saurabhnanda> what does all of that even mean?
04:29:28 <saulzar_> Sure, so a Reader is essentially a function from something (e.g. String) to a result. 
04:29:45 <saulzar_> So "return 5"  is just like \_ -> 5
04:30:05 <saulzar_> What happens when you use runReader is it provides that argument..
04:30:40 <saulzar_> So 'Reader String Int' is basically like a function String -> Int
04:31:28 <saulzar_> Except you use the fact that it is a Monad as a convenient way of stringing these things together
04:31:38 <saurabhnanda> hang on, reading http://passy.svbtle.com/dont-fear-the-reader which might make things apparent
04:31:46 <saurabhnanda> unable to build an intuition of why Reader is required
04:31:53 <saurabhnanda> I was able to understand why a Functor is require
04:31:59 <saurabhnanda> why an Applicative is required
04:32:07 <saurabhnanda> but unable to understand what a Reader is bringing to the table
04:32:22 <saulzar_> Reader is nice if you want to hide some arguments to a function
04:32:35 <fr33domlover> saurabhnanda, having environment data you don't have to explicitly pass around all the time
04:33:04 <saulzar_> So lets say you have some data you want to pass around to all your functions, but manually passing it around all the time would be a pain
04:33:55 <saulzar_> Reader lets you do this 
04:34:18 <saurabhnanda> saulzar_ fr33domlover -- I've read that. But I cannot believe it. That seems to be going against whatever Haskell otherwise stands for. I should be able to look at a function's signature and get a sense of what it's boundaries are. No globals. No external state, etc. But a Reader seems to be defeating all of that. Every time I look at a function that deals with a Reader I cannot make sense of how it could possibly be working.
04:35:32 <saulzar_> The type shows exactly what's going on though ... it spells it out  Reader String Int   <--- means that there's a String being passed around to the environment
04:37:22 <saulzar_> saurabhnanda, The 'magic' is in how the Monad instance for Reader is written. The (>>=) operator 
04:38:55 <sternenseemann> Do you guys know any good starting point to learn to use TemplateHaskell
04:39:07 <sternenseemann> there seems to be no proper Introduction to me
05:04:32 <quchen> sternenseemann: I don't know a resource, unfortunately. I'd say you should undetstand the idea that you can build Haskell source with the TH DSL, that you can take a value of that DSL and splice it into your code with $(...), and then look at what the standard TH modules provide you with.
05:05:14 <sternenseemann> yeah, I got that Idea
05:05:37 <quchen> sternenseemann: The canonical exercise is writing a TH function that generates you fst/snd/... for tuples of arbitrary sizes, so that $(tuple 3 1) (11,22,33) == 11.
05:06:07 <sternenseemann> but it starts with the reification Info stuff being poorly documented :(
05:06:31 <quchen> I also (ab)used TH to add some supercompilation to programs, detailed here: https://github.com/quchen/articles/blob/master/useful_techniques.md#poor-mans-supercompiler
05:06:43 <quchen> It's not about TH per se, but it uses some basic functions that might help you get started
05:07:11 <bennofs> sternenseemann: what I usually do in that case is just test it out
05:07:29 <bennofs> sternenseemann: just reify some of the stuff mentioned in http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html#t:Info, and see which data is going to which fields
05:08:08 <sternenseemann> „You'll notice this compiles slowly, but runs very fast“ :D :D quchen 
05:08:15 <quchen> :-)
05:08:18 <sternenseemann> had to laugh for some reason
05:08:27 <sternenseemann> bennofs: sounds like an idea
05:08:35 <quchen> The problem with using TH for supercompilation is that TH isn't optimized when run, so you get GHCi-like performance
05:09:54 <bennofs> quchen: hmm, does that still apply if I use a function from an imported module? I'd expected it'd work like -fobject-code for ghci in that case
05:10:25 <quchen> bennofs: I don't know in that case. Might, might not.
05:10:43 <quchen> I always assume it's crazy slow :-D
05:11:40 <quchen> sternenseemann: You can also look at how things look like by quoting expressions you know
05:11:51 <quchen>  > runQ [| let x = 3 in x |]
05:11:57 <quchen>  >>> LetE [ValD (VarP x_0) (NormalB (LitE (IntegerL 3))) []] (VarE x_0)
05:12:32 <quchen> [| x |]    ← gives you the TH expression of x, where x is rather arbitrary correct Haskell
05:12:54 <quchen> … or does it default to expressions? I don't remember. I'd start using it for expressions at least.
05:13:19 <quchen> runQ [| 3 |]      ⇒      LitE (IntegerL 3)
05:13:40 <quchen> So this tells you that "3" is a literal expression (LitE) that contains an integer literal (IntegerL), namely 3.
05:14:29 <quchen> runQ [| \f x -> f x |]  ⇒  LamE [VarP f_2,VarP x_3] (AppE (VarE f_2) (VarE x_3))
05:14:51 <quchen> Play around with this and you'll see how expressions are represented with TH.
05:15:29 <quchen> Next, you could look at some real world use cases of TH, such as Aeson's deriveJSON here: http://hackage.haskell.org/package/aeson-0.11.0.0/docs/Data-Aeson-TH.html
05:15:35 <quchen> sternenseemann: ^ all for you :-)
05:17:27 <quchen> sternenseemann: But I think trying to generate a tuple-access-TH-function is a good start
05:18:09 <quchen> $(2 `access` 1) = fst, $(3 `access` 2) = get 2nd entry of a 3-tuple, and so on
05:32:48 * hackagebot cgrep 6.6.2 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.2 (NicolaBonelli)
05:50:33 <osfameron> does anyone sell Haskell badges?  (e.g. pin-style ones, with a lambda logo on them)
06:02:16 <Can9> кто пранк кс го с сервером?
06:02:41 <mniip> щито?
06:07:39 <padre_angolano> легкая ухрючина и веревку не крутит
06:14:12 * osfameron would suggest #haskell-ru, if any of this actually looked like it was about haskell...
07:00:23 <Denommus> where do I put my migrations in Yesod?
07:00:30 <Denommus> in the scaffold, that is
07:01:28 <the_2nd> how can I parse doubles via https://github.com/pcapriotti/optparse-applicative#supported-options ?
07:01:37 <the_2nd> I only find examples for strings and bool
07:07:51 * hackagebot libjenkins 0.8.3 - Jenkins API interface  https://hackage.haskell.org/package/libjenkins-0.8.3 (MatveyAksenov)
07:28:27 <lyxia> the_2nd: argument auto
07:36:31 <Nublet> yo
07:36:51 <adamCS> sternenseemann: It's hard at first but each small example helps.  The "Lens over tea" TH piece was helpful for me: https://artyom.me/lens-over-tea-6
07:38:09 <Nublet> I was wondering if there exists an idiomatic combine function/operator combination: combine f g h = \x y -> f (g x) (h y)
07:38:11 <adamCS> sternenseemann: Just skip to the middle for a useful quick TH intro.
07:42:24 <aweinstock> :t \f g h -> [f <$> g <*> h, \x y -> f (g x) (h y)]
07:42:25 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ t -> b
07:42:25 <lambdabot>     Expected type: t -> t -> b
07:42:25 <lambdabot>       Actual type: t -> b
07:42:31 <aweinstock> :t \f g h -> [f <$> g <*> h]
07:42:33 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> [f b]
07:43:21 <aweinstock> Nublet: there's probably a way to do it with Applicative, but I can't think of it off the top of my head
07:44:05 <lyxia> this sounds Arrow-y
07:44:14 <Nublet> ^
07:44:25 <geekosaur> yeh
07:45:17 <aweinstock> :t \f g h -> [f <$> (g *** h)]
07:45:18 <lambdabot> (Functor (a (b1, b')), Arrow a) => ((c, c') -> b) -> a b1 c -> a b' c' -> [a (b1, b') b]
07:45:27 <lyxia> :t curry $ uncurry f . (g *** h)
07:45:28 <lambdabot>     Could not deduce (Show a0) arising from a use of ‘f’
07:45:29 <lambdabot>     from the context (Show a, Show b, FromExpr c)
07:45:29 <lambdabot>       bound by the inferred type of
07:45:40 <aweinstock> :t \f g h -> (f .) . (g *** h)
07:45:40 <lyxia> :t \f g h -> curry $ uncurry f . (g *** h)
07:45:42 <lambdabot>     Couldn't match type ‘(c1, c')’ with ‘a -> b’
07:45:42 <lambdabot>     Expected type: (b1, b') -> a -> b
07:45:42 <lambdabot>       Actual type: (b1, b') -> (c1, c')
07:45:42 <lambdabot> (a1 -> b1 -> c) -> (a -> a1) -> (b -> b1) -> a -> b -> c
07:45:49 <lyxia> \o/
07:46:18 <lyxia> looks uglier than the pointful thing
07:53:45 <Nublet> It's possible to do it for the first argument using applicative
07:55:34 <osfameron> I wrote a (fairly silly) thing https://github.com/osfameron/data-stripey/blob/master/stripe.hs
07:55:41 <Nublet> :t \f g h -> flip (flip (f <$> g) <$> h)
07:55:43 <lambdabot> (a1 -> b1 -> c) -> (b -> a1) -> (a -> b1) -> b -> a -> c
07:55:47 <osfameron> is there a better way to assert the type invariant of alternating types?
07:55:50 <Nublet> ew
07:56:02 <osfameron> e.g. other than just not exporting the constructor?
07:58:51 <lynn> osfameron: You could try to define your type in such a way that there can be no non-striped lists!
07:59:04 <lynn> In your case, that works out very nicely:
07:59:35 <lynn> data Stripey a b = Stripey (Maybe b) [(a, b)] (Maybe a)
08:01:57 <lynn> (Also, Stripe is just Either.)
08:02:27 <osfameron> lynn: hmmm.  yeah, that could work.  though it's more awkward to work with then
08:02:34 <lokien> is snake_case for function names considered as bad style?
08:03:03 <lynn> lokien: It's atypical for Haskell, for sure
08:03:05 <sm> lokien: pretty much
08:03:14 <lokien> lynn sm thanks
08:03:15 <osfameron> lynn: I thought it might be just Either (but my knitted cat is Pink and Green, so this amuses me more :-)
08:04:21 <lynn> osfameron: More awkward, but quite fun, I think!
08:05:14 <osfameron> hehe
08:07:31 <lynn> @let data Stripey a b = Stripey (Maybe b) [(a, b)] (Maybe a) deriving (Eq, Ord, Show)
08:07:33 <lambdabot>  Defined.
08:08:49 <osfameron> you can't easily define e.g. head on that
08:09:13 <osfameron> as it could return either a or b
08:09:31 <osfameron> which is where a Pink/Green (or, yawn, Either) would work better
08:11:04 <quchen> Is there a list of all released Stackage LTS versions somewhere?
08:11:22 <lynn> > stripeyToEither (Stripey b x a) = (Right <$> toList b) ++ (concatMap (\(a, b) -> [Left a, Right b]) x) ++ (Left <$> toList a)
08:11:24 <lambdabot>  <hint>:1:33: parse error on input ‘=’
08:11:28 <lynn> @let stripeyToEither (Stripey b x a) = (Right <$> toList b) ++ (concatMap (\(a, b) -> [Left a, Right b]) x) ++ (Left <$> toList a)
08:11:29 <lambdabot>  .L.hs:152:16:
08:11:29 <lambdabot>      Ambiguous occurrence ‘toList’
08:11:29 <lambdabot>      It could refer to either ‘Data.Foldable.toList’,
08:11:41 <lynn> @let stripeyToEither (Stripey b x a) = (Right <$> Data.Foldable.toList b) ++ (concatMap (\(a, b) -> [Left a, Right b]) x) ++ (Left <$> Data.Foldable.toList a)
08:11:43 <lambdabot>  Defined.
08:12:03 <lynn> > stripeyToEither $ Stripey Nothing [(3, True), (4, False)] (Just 5)
08:12:05 <lambdabot>  [Left 3,Right True,Left 4,Right False,Left 5]
08:12:19 <lynn> Cool, cool
08:12:22 <osfameron> :D
08:12:50 <lynn> @let stripeyHead = listToMaybe . stripeyToEither
08:12:52 <lambdabot>  Defined.
08:12:58 <lynn> > stripeyHead $ Stripey Nothing [(3, True), (4, False)] (Just 5)
08:13:00 <lambdabot>  Just (Left 3)
08:13:05 <osfameron> did you really use Data.Foldable.toList a  to save typing  [a] ? ;-P
08:13:17 <lynn> > stripeyHead $ Stripey (Just False) [(3, True), (4, False)] (Just 5)
08:13:19 <lambdabot>  Just (Right False)
08:13:37 <lynn> Oh, they're different
08:13:40 <luigy> quchen https://s3.amazonaws.com/haddock.stackage.org/snapshots.json
08:13:46 <lynn> > Data.Foldable.toList (Just 'x')
08:13:50 <lambdabot>  "x"
08:13:51 <lynn> > Data.Foldable.toList Nothing
08:13:53 <lambdabot>  []
08:14:05 <lynn> Err, Char was a bad example.
08:14:15 <quchen> lynn: Thanks!
08:14:16 <lynn> > Data.Foldable.toList (Just 4) -- You get the idea :)
08:14:17 <lambdabot>  [4]
08:14:18 <osfameron> ah ok
08:14:22 <quchen> lynn: How did you get that URL?
08:14:25 <osfameron> yes, sorry.  I've seen that from Data.Maybe
08:14:46 <quchen> lynn: Wait, that's not complete at all :-(
08:15:20 <lynn> quchen: I'm not luigy :)
08:15:58 <dmj`> it's a me, mario !
08:16:42 <quchen> luigy: (What I said to lynn)
08:16:44 <quchen> lynn: Woops
08:17:24 <lynn> osfameron: a typesafe  reverseStripey :: Stripey a b -> Stripey a b  sounds like a cool exercise
08:20:53 <osfameron> lynn: heh, yeah.
08:21:26 * osfameron runs off to do some errands, will think about it en route :-)
08:23:27 <luigy> quchen oh, true! they get fetched from https://github.com/fpco/lts-haskell https://github.com/fpco/stackage-nightly
08:24:17 <luigy> dmj` "I'm-a luigi, number one!" - mario kart
08:24:33 <quchen> luigy: Fair enough! I can make good use of that list.
08:26:54 <dmj`> luigy: could sure go for some mario party right now, luigy's boilerroom
08:34:31 <lynn> is this a sign I should use lens? :< http://lpaste.net/2497415202203500544
08:35:03 <lynn> These all work fine, but they feel a bit silly...
08:38:28 <dmj`> lynn: lens would be cleaner yea, for example, that first function could just be lastUpdateId .~ i
08:45:50 <quchen> lynn: addUser i u = users %= M.insert i u
09:04:38 <sphinxo> In haskell what is the name for a type in an adt?
09:04:55 <sphinxo> eg data Bool = True | False
09:05:00 <sphinxo> variants?
09:05:08 <sphinxo>  value constructors?
09:05:29 <geekosaur> True and False are not types, they're data constructors. Bool is the type
09:05:47 <sphinxo> ok data constructors, thanks
09:07:50 <sphinxo> What is the name of like:
09:08:07 <sphinxo> data Circle = Circle Int Int
09:08:15 <sphinxo> of the Int, Int part?
09:08:27 <monochrom> you can call them "fields"
09:10:19 <lynn> This page: https://wiki.haskell.org/Constructor   calls the list of types (here, Int Int) the "parameters", and the values of those Ints the "data"
09:41:42 <mpickering> What is the cause of this linker error when building a package? I'm on osx https://www.irccloud.com/pastebin/LfJZgqmk/
09:46:52 <mpickering> I managed to fix it with some combination of these commands - http://stackoverflow.com/questions/16618272/installing-text-icu-on-mac-osx-with-cabal
10:02:15 <Industrial> Hi. Is there a gallery or somesuch with haskell editor/IDE setups? I'm looking for vim/neovim specifically. :-)
10:03:09 <Industrial> I see https://wiki.haskell.org/IDEs#Vim
10:09:58 <Industrial> Hmm
10:10:12 <Industrial> When I try to `cabal install ghc-mod` I get `Failed to install haskell-src-exts-1.17.1`
10:10:28 <hanDerPe1er> in ghci, I can do ':set -Wall', how do I ':unset -Wall' ?
10:10:58 <Industrial> I'd love to get https://github.com/eagletmt/ghcmod-vim and https://github.com/eagletmt/neco-ghc working :-)
10:12:04 <hanDerPe1er> found it; ':set -w'
10:17:08 <freddy_> hi
10:23:33 <Big_G> Has anyone checked out Sparkle yet?
10:27:57 * hackagebot luminance 0.11 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.11 (DimitriSabadie)
10:27:59 * hackagebot luminance-samples 0.11 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.11 (DimitriSabadie)
10:31:43 <freddy_> Sparkle?
10:36:36 <ner0x652> Hi!
10:37:57 * hackagebot bioinformatics-toolkit 0.1.1 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.1.1 (kaizhang)
10:38:10 <ner0x652> does somebody work on an interface for Haskell in TensorFlow? do you have some evidence about such a project?
10:58:16 * hackagebot propellor 2.16.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.16.0 (JoeyHess)
11:08:10 <kscih> Hey guys is there a nice function that will do (MonadPlus m) => (a -> m b) -> [a] -> m b... I want the b returned to be the first 'success'
11:09:22 <kscih> If not, I'm thinking it will involve a fold and mplus, but I'm new to Haskell and can't quite get there
11:09:49 <mniip> define succes
11:09:58 <kscih> not mzero
11:10:05 <kscih> um, perhaps that doesn't make sense
11:10:08 <mniip> MonadPlus doesn't let you test if something is mzero
11:10:14 <kscih> but in the way that guard can return empty
11:10:33 <kscih> that would be a failure
11:10:38 <jmcarthur> :t foldMap . (Alt .)
11:10:40 <lambdabot> forall (k :: BOX) (t :: * -> *) a (f :: k -> *) (a1 :: k). (Foldable t, Monoid (Alt f a1)) => (a -> f a1) -> t a -> Alt f a1
11:10:45 <mniip> you can't check that
11:11:09 <jmcarthur> :t \f -> getAlt . foldMap (Alt . f)
11:11:10 <lambdabot> forall (k :: BOX) (f :: k -> *) (a :: k) (t :: * -> *) a1. (Foldable t, Monoid (Alt f a)) => (a1 -> f a) -> t a1 -> f a
11:11:16 <mniip> :t (sequence .) . map 
11:11:17 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
11:11:39 <mniip> :t (foldr mplus mzero .) . map 
11:11:40 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
11:11:48 <mniip> but that takes all "successes"
11:11:57 <jmcarthur> it depends on the MonadPlus
11:12:17 <jmcarthur> > Just () <|> Nothing
11:12:17 <EvanR> wow
11:12:18 <lambdabot>  Just ()
11:12:31 <jmcarthur> > Just False <|> Just True
11:12:33 <lambdabot>  Just False
11:12:38 <EvanR> polykinded foldable alt
11:12:44 <EvanR> very clear imo
11:12:54 <jmcarthur> yeah I am disappointed in that type
11:13:03 <kscih> Maybe I should just explain what I'm trying to do... I'm parsing something with Aeson. I have a bunch of potential keys I want to look for, I want to return the first one it finds, and lead to a parse failure if no keys are present
11:13:22 <jmcarthur> Well, actually I like the type, I just hate reading it.
11:13:27 <EvanR> this. is. SCALAaaaAaaaA
11:13:28 <mniip> well you can
11:13:37 <mniip> 't write that using the generic MonadPlus interface
11:15:36 <kscih> Well, I'm in the Parser monad
11:20:14 <wagle> i botched it..  how do I uninstall stack itself and try again?
11:22:16 <wagle> ooo..  lookit, a FAQ
11:28:02 <MarcelineVQ> :t (msum .) . fmap -- jmcarthur: This would stop on the first success with Maybe right?
11:28:03 <lambdabot> (Functor t, Foldable t, MonadPlus m) => (a1 -> m a) -> t a1 -> m a
11:28:58 <jmcarthur> MarcelineVQ: I would expect that, yes.
11:29:14 <jmcarthur> > ((msum .) . fmap) id [Just False, Just True]
11:29:16 <lambdabot>  Just False
11:29:25 <MarcelineVQ> it did in ghci but there's often edge cases I forget to consider
11:39:39 <scshunt> hrm. there's no way to do a variadic lift, is there?
11:40:27 <mniip> variadic?
11:41:10 <scshunt> accepting any number of arguments
11:41:29 <scshunt> I have a function (MonadState m) => a -> b -> c -> m ()
11:41:38 <scshunt> I would like to make a helper which pulls the a from the state
11:41:47 <scshunt> so it has type (MonadState m) => b -> c -> m ()
11:42:49 <mniip> such variadicity sounds like it would be ambiguous
11:43:03 <scshunt> mniip: yes, unfortunately
11:43:45 <scshunt> I'm going to reuse this pattern a lot, but can't see any way to do it other than manually invoking the state (or writing out another helper)
11:43:59 <scshunt> another helper is probably best
11:44:20 <nshepperd> \b c -> f <$> geta <*> pure b <*> pure c
11:44:49 <nshepperd> hmm
11:44:53 <nshepperd> @pl \b c -> f <$> geta <*> pure b <*> pure c
11:44:53 <lambdabot> ((f <$>) .) . (. pure) . (<*>) . (geta <*>) . pure
11:45:22 <nshepperd> plain as day
11:45:30 <scshunt> yeah, can't believe I didn't think of that
11:45:40 <scshunt> nshepperd: can't make it work for arbitrarily many args though
11:46:47 <kscih> Is there monadic form of foldr, such as foldrM?
11:46:56 <kscih> In prelude already, I mean
11:47:04 <geekosaur> @index foldM
11:47:04 <lambdabot> Control.Monad
11:47:11 <mniip> scshunt, f <$> geta <*> pure b <*> pure c ...
11:47:16 <mniip> just add more
11:47:22 <kscih> Thanks
11:47:34 <scshunt> mniip: but then I have to write the arguments out
11:47:39 <mniip> sure
11:48:23 * hackagebot blatex 0.1.0.7 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.7 (2016rshah)
11:48:36 <kscih> geekosaur: Isn't that foldlM?
11:48:40 <kscih> rather than foldrM
11:49:12 <scshunt> also this isn't working for me
11:49:15 <enthropy> scshunt: http://lpaste.net/153508
11:49:33 <scshunt> enthropy: yes, I don't want separate helpers thank you
11:50:01 <enthropy> well its the same helper independent of the number of arguments
11:50:21 <scshunt> err, no? f1 and f2
11:50:33 <scshunt> oh you mean scshunt
11:50:34 <scshunt> ok
11:50:37 <scshunt> thanks :)
11:51:19 <scshunt> mniip: nshepperd: <$> doesn't work because my function is still monadic
11:51:31 <scshunt> if it were () rather than m () it would work
11:51:47 <scshunt> though I suppose I could tack a join on
11:52:27 <mniip> \b c -> get >>= \a -> f a b c
11:52:37 <mniip> yeah that's slightly big
12:17:57 <pkkm> hi, assuming that f :: a -> a -> a, can it possibly be anything other than f x y = x or f x y = y?
12:18:38 <shachaf> If you allow for nontermination, it can be a few other things.
12:22:44 <pkkm> anything other than undefined and a computation running forever like f x y = seq (reverse [1..]) x?
12:23:26 <shachaf> Those are the same value.
12:23:38 <shachaf> But you can have f = undefined, f x = undefined, f x y = undefined
12:26:27 <pkkm> thanks
13:00:30 <gipp> 1~
13:03:01 <parsecChar> in parsec, is there something like "peek" ?
13:03:20 <parsecChar> I want something to succeed ONLY if the next char/token is BLAH, but I don't actually want to consume the char/token
13:03:35 <sm> yes
13:03:48 <lyxia> there's lookAhead
13:04:51 <parsecChar> lookAhead
13:04:51 <parsecChar> yeah
13:04:56 <parsecChar> https://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Prim.html#lookAhead
13:05:01 <parsecChar> lyxia: thanks!
13:05:50 <jig123> I am using "#!/usr/bin/env stack" "-- stack --install-ghc runghc --package turtle" to run some scripts, and it is awesome -- but is there a way to to tell it to compile the script and just use the compiled version on subsequent calls?
13:20:16 <sm> jig123: stack ghc SCRIPT 
13:20:41 <sm> but you have to do that yourself, and pick which one to run - so no, it's not automatic like .pyc
13:21:46 <sm> might be a nice feature request
13:23:17 <parsecChar> what is the best way to generate javascript from haskell? I'm not looking for ghcjs/haste/fay -- I have an AST in Haskell. I just need a javascript code generator -- something like LLVM, but for Javascript
13:24:01 <sm> that would be.. ghcjs, no ?
13:24:42 <luite> that if you want to translate the haskell itself
13:25:06 <luite> if you have a DSL that you want to translate to JS, you may want your own translation using perhaps jmacro or language-ecmascript
13:26:59 <jig123> sm: ah, yeah it would be _especially_ cool if it could do it automatically
13:52:13 --- mode: tepper.freenode.net set +o ChanServ
16:38:30 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
16:38:30 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
16:38:30 --- names: list (clog milking doomlord |node tekacs afcondon rodolfowtf Purlox mr_yogurt2 YP-HW7 ninedotnine parsecChar johnzorn low-profile RaceCondition Big_G Guest34101 ype zhulikas eL_Bart0 Eliel sLite dunj3 bcrom_ cnr kier derekv Lutin` Nylidian kgadek predator117 Bez_ mtncoder jackhill isomorphismes obadz hyuke secwang Forkk minsky Jesin codebam jzl bgy kjnilsson fuziontech markus1189 _janne armyriad sanitypassing mietek edwardk mvr_ pfeyz Wizek otterdam AntiSpamMeta)
16:38:30 --- names: list (pimlu eliasr pacak Ewout Wizek__ vin-ivar jonrh terrelln Walther Vbitz Heasummn paf31 recycle sivs huckleberry78 zymurgy Brando753 Guest22161 Guest29773 cjay taruti opqdonut alkabetz jimki Zemyla richi235 gdsx quuxman serutsubi donwilli1m Bane^ funrep ElderFain zxtx sqram binaryplease asthasr karshan1 demilux hydraz Mon_Ouie sjl_ spill4 conal sword_smith kosorith cdg katymoe_ tomboy64 athan nomicflux jlang0 proteusguy_ dschoepe mikeplus64 verement ibid)
16:38:30 --- names: list (exferenceBot no-n kam270 firstdayonthejob dstockwell etcinit bergmark kennyp cjh` watersoul clynamen Sgeo castlelore nathanic tim_s007 mauke MasseR tumdum _flow_ kvieta Johannes13 tinco nchambers cyborg-one dmwit garphy ma489 SenpaiSilver juhp t0mb0 uncle-j_j Sindriava eazar001 etrepum ceverett lieven martintrojer Guest61361 bitonic DrCode zemm knyppeldynan corne_ spicydonuts tjpeden Kahva Cale fabianvf gws xinming Nimatek Oxyd iliastsi Sigyn horlicks_)
16:38:30 --- names: list (maerwald radge_ felixschl Benzi-Junior Scorchin shans_ sisir alexa_ Marqin leather oldmanmike jakutis srajendra pchiusano zerokarmaleft rikkus carlw2 Tritlo xplat bgyss Pucilowski cocreature shelling__ magically kyagrd ocharles_ Vorpal s_e descender lamilami Xeironis iddqd Matajon dan64 sephiap magbo Gurkenglas_ wyvern stephe marcel stasku__ sclv chriswk jessicah` FireFly fionnan aristid louispan phuu Guest26166 kipd hucksy rvncerr Fubar^ alem0lars nakal_)
16:38:30 --- names: list (scshunt 14WAABE54 lf94 marens_ spindas nbouscal arcanine xanadu_ puzza007 tharper Guest29888 AppleJacks24 narendraj9 acfoltzer fboyer x77686d ggherdov marienz yminsky Rembane Cr8- Majiir movedx takeey_ darxun mbrcknl jmct wizonesolutions spaceships Cathy dtulig LeaChim_ magthe kishar orion sepp2k infinity0 pelegreno klarrt tg sajith marr folsen tuple_cat dwn thetallguy Ralith Tene georgew dustinm tessier bartavelle ljhms zv SolarAquarion clahey_ yarou ahf)
16:38:30 --- names: list (surtn kshannon msloma fergusnoble Guest28225 jfokkan__ lpaste kurnevsky froztbyte rossberg ortmage avdi Irrationality zq juri_ heath dmiles hongminhee squisher lambda-11235 cstrahan runeks freekevin levi tych0 magicman cfloare d6e siddhu tedkornish bshelden lep-delete SegFaultAX honkfestival ckw dolio GaveUp mjo Boreeas pootler_ capicue onegeek wookiehangover_ xacktm neshmi amiller zmanian_ brainpro1 radens cansis gniourf otulp Guest85605 trevorriles JPohlmann)
16:38:30 --- names: list (solidsnack mankyKitty vifon imalsogreg sbjorn Belgarion0 Dtgr nwf alpounet_ chelfi jlyndon Rodya koala_man tlevine stux|RC-only lokydor arnihermann Xandaros MorTal1ty jinblack ggVGc Kneiva_ sz0 Elsi_ alang davl_ Tehnix theorbtwo OliPicard lukky513 nicola1 benzrf peddie aaron7 jb55 deko-pyon Pamelloes arianvp chirpsalot fingerzam abh Guest94494 petercommand rkk eyck robogoat Voldenet [swift] jnes exio4 uwap Xorlev supki pompolic mjrosenb staffehn_ Clint XMunkki)
16:38:30 --- names: list (asjo huonw Drezil MarcelineVQ cyberlard Hammy_Work Tertain hausdorff mrd mrlase brixen sleepynate dju codebje karls nurupo greeny Guest3764 wting julienXX Coldblackice pleiosaur Guest12896_ Factionwars caserg bbee2 lancetw nikola opios kjanosz Liskni_si wedify Twey rwiggins Ongy tokik esssing cosban johnw zerowidth Watcher7 tomh- StoneToad tolt heurist indiffernet code_crimes aatxe geppettodivacin cic jomg majjoha justin_smith Copperis lassulus urdh DustyDingo)
16:38:30 --- names: list (xou happy0 callumacrae tumdedum badon leino coeus irishsultan Internet13 jmcarthur marmalodak Guest53587 keemyb SHODAN yeltzooo kakos LoganG albel727 tippenein moei stelleg catern slick saiam FUZxxl carlf_ Desoxy tomjaguarpaw dilinger luxbock ManiacTwister Gothmog_ gpampara Starfire Hafydd nkaretnikov martinbjeldbak subleq ppnkk dkibi ion hanDerPeder pranz aparent Ornedan bd_ AustinMatherne arkarth vodkaInferno LeNsTR mephx eddsteel ChongLi FreeFull siloxid`)
16:38:30 --- names: list (ido tennix dzack drmoob_ _zxq9_ ski_ Wamanuz2 Eiam_ spion Chousuke condy brolin_empey_ askarpo Uakh_ bsermons a__ kfpratt fryguybob pnutus pharaun lstrano_ Sornaensis bergey` timloh bob_vh mrshoe hiratara bsima_ nocturne777 nshepperd tromp_ __rlp shennyg gnusosa codedmart dedgrant_ avn Ariadeno pi___ hive-mind CosmicRay julmac zenzike spock urodna_ kini psftw slaytane_ niklasb yusukesuzuki sm jix mceier gbarboza luzie c_wraith sevas M-Quora1 incomprehensibly)
16:38:30 --- names: list (oherrala Excureo pikajude swistak35 octo dredozubov vic_ mitchty_ irclogger_com Amnez777 Proteus1 joeytwiddle psyq d3lxa shwouchk maartenpi PanicSkittle deni CindyLinz Yuras DANtheBEASTman mpereira_ chu mxf pyrtsa_ andrewsw Yaiyan svp__ RyanGlScott unknownln CoderPuppy eun honza_ padre_angolano pkmx1 TallerGhostWalt_ wagle_ besenwesen ebird tomku|two jliikka telmich gipp inr_ z-nexx_ eagleflo cods M2tias cow-orke1 stvc maxmo mads- stomp fpoee simukis_ woodne_)
16:38:30 --- names: list (archaic Nivim joeyh_ RazorX| NeverDie truncate obcode_ frontend1oader micxjo trillioneyes vmeson M-ou-se syntacticNaCl Ptival mw jud xnull nekomune friden Kris_ takle int-e terlar kritzcreek_ alunduil_ yamadapc zyla Madars tswett humanbsd acro jibi dmh Edoxile Paks Ov3rload saurik sleblanc notdan shachaf Khisanth vpetro Deewiant andreas303 skrio darthdeus Maxdamantus Plastefuchs elgot M-davidar duairc hamishmack danharaj rardiol benonsoftware mechairo` _sjs_)
16:38:31 --- names: list (seliopou_ kalloc_ mj12`_ themagician watabou Kavec goldfire1 koomi orbital dgpratt_ davean biscarch Moto-chan Eric1 flower_snark centrinia fizruk {AS} przembot BlueRavenGT jbalint PHO bind Schrostfutz woffy raek sekrit cmn bananagram srhb agjohnst vkt Guest62564 dicioccio johtso Willis chishiki __name__ Xnuk lpvb jokester Levex ali_bush jlouis ernst guampa pie_ topi kaol Profpatsch sunnid mimi_vx kaste neobrain` rejuvyesh TimWolla ndeine APic hsyl20 dxld)
16:38:31 --- names: list (tismith bencryption gfixler swhalen derdon jre2 Lowl3v3l avocado bernalex mnoonan cjwelborn tomaw jholtom k3d3 solirc icedev tdammers niko fnordbert ephess_ _ashbreeze_ dasmith91 noctux mountaingoat julm qz cdidd kungp monokqr dcoutts Sonderblade edwtjo coddinkn jle` wedens enthropy sys9mm numberten lattenwald OutlawStar foreignFunction Xe Baughn Philonous RouxTheDay edofic platz parsnip RageD ps-auxw Tiktalik nathyong Axman6 Shandy posco elementalest nexsja)
16:38:31 --- names: list (bgamari kloeri_ rootzlevel atomi fortress_ rieper|net Adie_ oisdk_ valdyn negatratoron KorriX_ Lord_of_Life kmicu Saizan mokus bydo_ mtesseract2 jgornick_ [BNC]lokien Mandus_ fullofcaffeine sdx23 Soft spwhitt SLii brisbin dogui cross noexcept_ abrar _guios Igloo_ wolfcore taksuyu luis` Adeon metaf5_ ploopkazoo acommino- sujeet DigitalKiwi whaletechno mshenrick DDR simony vincenz thebnq da-x_ hodapp larsen__ bcoppens lhynes amiri_ Tehnix` lurker6_ thorkilnaur_)
16:38:31 --- names: list (roma naudiz burp rjeli cdk ec\ adarqui_ jameseb s4msung_ myfreeweb_ bjs PlasmaStar korayal jaaket_ unsymbol_ Joanna__ pfoetche1 wrengr_a1ay tzaeru `0660 igniting hemite sellout pgiarrusso niteria_ eyenx mteufel obiwahn xintron andromeda-galaxy bsmt mirsal dsantiag_ d-q-d wayne hvr antoniy_ gseitz_ sleezd nrolland dhrosa_ alevy- amingoia ThePhoeron Ke kosmikus Laney hpc_ juch_top _klm tsani_ jcurbo BigEndia1 Moyst_ tomus Claudius1aximus luigy lispy pydave6377)
16:38:31 --- names: list (WhoA3 jotrk toredl arw_ Speed Natch_ Taneb hiredman davesilva brennie_ anoe_ Keel ddude spacebug_ dlundy crank1988 vqrs jlewis_ mrowe xaimus_ grol zomg_ MindlessDrone luite_ itscaleb amharc_ osfameron justanotheruser optocoup1er irrequietus_ tnks Excedrin_ srcerer_ Myrl-saki dakrone cheater_ z16 sdboyer Boney glckr kyren_ lachenmayer qnikst_ tero- gridaphobe earthy suppi alokbeni_ EvanR_ eacamero_ mach ThreeOfE1ght fmapE_ sku1d_ zeroskil1or mattp__ WzC MoALTz_)
16:38:31 --- names: list (Mr0rris0 t0by anax joachifm tabemann darkbolt Don_John kazagistar pkkm neoncontrails SidelinesDigit plutoniix rkazak happahappa kalail jellytux Stratege sgflt drbean CurryWurst_ Meow-J spopejoy mada LnL Nikotiini ozgura aarvar Sorella hiptobecubic chattered S3bast1 statusfailed croyd a3Dman tv Hugehead Noldorin tmachr QORRiE schlicht majoh OH- Black-Wolf CoconutCrab Ravana proteusguy clion nont_ sdothum Vomit_ Tourist progato rcsgns thunderrd cgfbee SCHAAP137)
16:38:31 --- names: list (hackerfoo raichoo hackagebot IlanGodik dixie ft mpark1_ koz_ otto_s_ benl23 Ring0` ttuegel lambdabot Kindr3d phileas jgertm comboy lpsmith hexagoxel lspitzner Cetusx cognominal dextertzu erikd sohum Zekka dario` leat nuuit acertain zariuq ]OLI[ kipras`away davidthomas ziman fractalcat wamaral niluje k1 geal jamiis Guest33981 ephemeron Akii Athas vh-dib mgaare_ zyoung selckin gargawel_ l3france tippenei1n capisce_ quaestor1 liste_ xeno BillyIII Vq adamCS)
16:38:31 --- names: list (hyPiRion oddasat noplamodo boj moop aulambda agent008 jnoah Ulrar warc Ankhers fyolnish averagehat aerialB beckyconning_ nolsen jokleinn nisstyre_ phaskell jaj hrnz t0m0 Guest62589 RayNbow`TU H3ku hc agrif shesek ackthet cantstanya buoto Quintasan SaidinWoT Chobbes Freundlich brotknust anohigisavay Skuzzzy Nik05 abra0 amatecha so caasih alphonse23_ sparr Jinxit kwantam mpickering caw PotatoGim jorendorff hansihe jcp seanparsons mlhmwglt hegge oberstein abbe)
16:38:31 --- names: list (Simson-san S11001001 Raynos pkogan_ lohkey bkolera rslima_ felixsch_ Enigmagic mudfog SoupEvil MK_FG jcreekmore phadej dfranke tjbp andreass Guest98597 cynick nille m1stermag1c gcollins kriztw Sagi jstolarek ricardo82 noteventime Klumben Jaxan josephle iphy aloiscochard idupree solatis xplat|work danza-cloud ajp flux case39 m1dnight_ Jaak fr33domlover Niamkik_ sbrg canta wolf_mozart carter ircbrowse danclien drdo nemesit|znc dpn` cschneid zph Frankablu stqism)
16:38:32 --- names: list (mikeizbicki greymalkin wjm CARAM__ mno2 TabAtkins trig-ger dmoon1221 nkpart brt1 dsop thoughtpolice drewdavis placer14 thalleralexander bjobjo yorick__ Polarina thomie Xack poga Bigcheese pikhq tarcwynne_ isocliff sbauman xnyhps Saimeidae robertk ddima Ashy xaotuk dpower stoned prooftechnique fiddlerwoaroof gabiruh ajmccluskey AlainODea NemesisD sunfun max-m danieli dbeacham Jello_Raptor toon Eagle_Erwin klugez Nadrieril xa0 iross Atlanis zimp2 robtaylor)
16:38:32 --- names: list (demize jjardon totte nore andirc8000 sternenseemann teqwve dxtr tazjin martingale lingbot cin geekosaur theolaurent Kaini_ Geekingfrog integral Ferdirand brezel kqr pmade jrslepak fengshaun adimit Diabolik Bashmetim BrianHV rom1504 agm_ jrp6 lnx chris2 joedevivo frelux lexi-lambda MelodyKH3 barrucadu Erebe giraffe hbar_ lyxia asm89 ches lahwran statusbot Shockk 6A4AAAIDL ReinH mmaruseacph2 Shapeshifter horatiohb aweinstock shteou japesinator myme marko____)
16:38:32 --- names: list (bogdanteleaga MitchW lyddonb xxpor henrytill amontez Jonno_FTW phaazon quicksilver si14 andreypopp_ wto vigs anachrome gienah alanz killtheliterate nolrai2 vikram_______ dkua banjiewen mindos_cloud____ yaknyasn harmchop theDon sw1nn pdgwien psacrifice whoops icicled Blkt bazzle ixian gothos fall_ ario sewilton carter_cloud jroesch_ haasn zpconn__________ rstone qguv gsingh93 dh owa timrs2991 m4lvin Cerise gratimax __main__ divVerent zaquest rbocquet zopsi)
16:38:32 --- names: list (stass joshc___________ apo_ sgronblo SethTisue YP-Cloud_ milessabin bigs SuperTux88 raid tortal chrzyki alexlord impure_hate sea-gull minad codehero anders0 cbaines sarlalian Dykam keteim nek0 defanor usr GGMethos cursork Reiser zudov relrod thomas moredhel LordDeath mak` wtw shapr troydm mero mniip cbm80 CaptainLex monty epitron saruta ahihi andyo leftylink bounb liszt ollef Hijiri DenSchub Elision arrdem_ _6a68 borkdude_ nyuszika7h kristjansson carc @ChanServ)
16:38:32 --- names: list (orcus skarn pieter_ grandy kaictl nrw_ eikke tgeeky betawaffle)
16:40:30 <Cale> In principle, there perhaps ought to be.
16:40:41 <nshepperd> I don't see why not
16:49:36 <Wizek> Hey! Is there a simple way to redirect one handle to another like `hGetContents stderr >>= hPutStr stdout` without there being a risk of EOF IO exception?
16:50:29 <geekosaur> you can't hGetContents stderr (well, you can if it's a tty but it won't do what you seem to want)
16:53:31 <Wizek> geekosaur, you mean because of the EOFError?
16:53:47 <mniip> stderr is usually an outgoing handle
16:54:13 <geekosaur> what mniip said, it's usually open for write only
16:54:39 <geekosaur> on a terminal it may be open read-write but that still doesn't let you read back what got written to he terminal
16:55:23 <mniip> I think they are looking for a dup2-style redirection
16:55:44 <Wizek> ooh, I see the confusion, the stderr is a handle of a subrprocess
16:55:57 <Wizek> So I am reading from that in the main process
16:56:17 <geekosaur> how are you creating this subprocess?
16:56:26 <mniip> then you should launch your subprocess with the respective handle as stderr
16:56:29 <Wizek> createProcess p{std_out=CreatePipe, std_err=CreatePipe}
16:56:53 <Wizek> hmm, that is an interesting thought
16:57:34 <Wizek> I am not sure if createProcess would allow me that, but either way, I'd like to connect/pipe those two handles conditionally together
16:58:09 <Wizek> i.e. only show on the main process what the stdout and stderr of the child was if it exists with (ExitFailure _)
16:58:17 <geekosaur> so the result oof createPipe will include a pair of Handle-s connected to the other side
16:58:58 <geekosaur> there is no automation there, you need to capture the output (preferably in a forkIO-d thread) and decide to output it based on the final exit status
16:59:43 <geekosaur> note that you cannot safely wait for the process to terminate before reading from the Handle-s, because the pipe only holds so much and if you do not read what is being written then the subprocess will block waiting for you to read and never finish
17:00:17 <geekosaur> (this is not a haskell thing; perl and python call it the open3 problem)
17:00:34 <Wizek> That may very well be, I haven't considered that.
17:01:01 <lambda-11235>  I forget, in haskell 2010 (not specifically GHC) is there any way to create a synonym NumOrd which expands to (Num a, Ord a), so that I can write foo :: NumOrd a => a -> a?
17:01:35 <Wizek> thanks geekosaur, I might some custom logic to handle that then
17:02:07 <geekosaur> lambda-11235, not in haskell 2010
17:03:33 <Cale> I think the best you could do is to make a subclass with no methods, but then you still have to write instances one by one.
17:03:45 <Cale> (though writing each instance is trivial)
17:03:47 <geekosaur> well, I suppose you could have some kind of dummy typeclass: class (Num a, Ord a) => NumOrd a --- and then a dummy instance for all types. not sure how badly that messes with type inference etc, though
17:04:04 <geekosaur> hm, yeh, not sure the all-types instance is valid either
17:04:51 <jle`> i wonder how people got anything done with haskell 2010
17:04:52 <Cale> Yeah, that needs overlapping and undecidable instances.
17:04:56 <geekosaur> h'2010 is really limiting
17:05:35 <Cale> H2010 is basically H98, which very few things complied with 100% even at the time it was written.
17:05:38 <geekosaur> which is why almost every package you'll find on hackage or etc. uses gc extensions
17:05:47 <geekosaur> *ghc
17:06:01 <jle`> is transformers 2010-compatible?
17:06:12 <geekosaur> mptc I think?
17:06:38 <jle`> the only typeclass transformers has is MonadIO iirc
17:07:04 <jle`> hm it uses {-# LANGUAGE CPP #-}
17:07:08 <geekosaur> ah, yeh. transformers is but mtl requires mptc
17:07:14 <geekosaur> heh
17:07:23 <Cale> Many are not *just* GHC extensions though. It's actually kind of a good idea to modularise the language features like that, so that implementors who want to make a new compiler don't have to do everything at once and have clear targets to be able to build various libraries.
17:08:30 <Cale> H2010 includes the {-# LANGUAGE ... #-} pragma, and details a few of the extensions itself.
17:09:55 <geekosaur> (my next question is whether transformers uses cpp as a recent thing to deal with FTP or AMP...)
17:14:07 <Philpax> hi everyone! what's the best way to do dynamic nested iteration? i.e. [(i,j) | i <- [0..10], j <- [0..10]], where the number of variables can be increased (i, j, k, etc)
17:16:24 <mniip> Philpax, recursively
17:16:40 <shachaf> Well, the first thing to do is probably to figure out the type of the thing you want.
17:17:21 <mniip> that too
17:17:25 <shachaf> E.g. the types (Int,Int) and (Int,Int,Int) have nothing to do with each other -- it doesn't really make sense to write something that generalizes over all tuples.
17:17:51 <Philpax> hmph, that makes sense
17:18:29 <shachaf> So you could use [Int], for instance. It depends on what you want to do.
17:20:13 <Philpax> I'm iterating over a search space (and growing it as necessary), so a list of list of Ints would work
17:25:00 <jle`> Philpax: youi could use replicateM
17:25:28 <jle`> replicateM 1 [0..10] is [[i] | i <- [0..10]]
17:25:41 <jle`> replicateM 2 [0..10] is [[i, j] | i <- [0..10], j <- [0..10]]
17:26:04 <jle`> replicateM 3 [0..10] is [[i, j, k] | i <- [0..10], j <- [0..1], k <- [0..10]], etc.
17:26:44 <jle`> > replicateM 4 "01"
17:26:45 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
17:46:15 <Philpax> jle`: awesome, thanks!
18:10:01 <orion> How close are we to a release?
18:11:03 <jle`> of ghc 8?  we're on rc2 i believe
18:11:42 <jle`> it looks like there's still a few bugs to be ironed out https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
18:19:00 <jake`> @help
18:19:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:20:39 <jake`> @help
18:20:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:21:04 <jake`> @pl shouldBeMat a b = a `shouldBe` (arToMatrix b)
18:21:04 <lambdabot> shouldBeMat = (. arToMatrix) . shouldBe
18:27:32 * hackagebot MASMGen 0.3.0.0 - Generate MASM code from haskell  https://hackage.haskell.org/package/MASMGen-0.3.0.0 (petercommand)
18:27:32 * hackagebot MASMGen 0.4.0.0 - Generate MASM code from haskell  https://hackage.haskell.org/package/MASMGen-0.4.0.0 (petercommand)
19:03:36 <mgsloan> Hmm, why aren't implicit parameters allowed in instance constraints?
19:04:44 <mgsloan> The users guide says "Reason: exactly which implicit parameter you pick up depends on exactly where you invoke a function. But the ``invocation'' of instance declarations is done behind the scenes by the compiler, so it's hard to figure out exactly where it is done. Easiest thing is to outlaw the offending types.
19:05:36 <shachaf> mgsloan: That's the reason.
19:06:17 <shachaf> mgsloan: You can use reflection for some of the use cases of ImplicitParams instance constraints.
19:06:18 <mgsloan> Yeah, I guess I just don't see what the tricky case is there.  Seems to me like constraints always come from an identifier
19:06:27 <shachaf> (In fact, exactly the reasonable ones.)
19:06:41 <shachaf> (As long as you use Reifies and not Given.)
19:07:11 <mgsloan> Yeah, I want to do "instance (?callStack :: GHC.Stack.CallStack) => MonadIO (M a)", so no dice
19:07:39 <shachaf> https://mail.haskell.org/pipermail/glasgow-haskell-users/2013-July/024095.html
19:08:19 <shachaf> Sounds like you want to do exactly the evil thing.
19:08:53 <shachaf> Given can do it.
19:11:02 <mgsloan> SPJ knows better than I, but I still don't see what's evil about having op use the ?x = 5 binding
19:11:38 <mgsloan> "Currently the site at which instance declarations are used isn't important" <- seems like something that could be changed
19:11:58 <mgsloan> Not that I think this is an important thing, I never use implicit parameters
19:12:04 <mgsloan> I just want it for this callstack magic
19:12:23 <shachaf> So use Given.
19:12:39 <mgsloan> Maybe callstack is already so magic that we can lift this restriction for it, heh
19:12:39 <shachaf> You can use Symbol to make Given behave nearly the same as ImplicitParams.
19:13:44 <mgsloan> Main issue with that is boilerplate
19:14:56 <mgsloan> Thanks though, good to know the reason
19:40:34 <pikajude> what's the best way to do (RealFloat a, RealFloat b) => a -> b?
19:40:44 <pikajude> fromRational . toRational?
19:41:10 <Ralith> define 'best'
19:41:56 <pikajude> performance is my priority, over precision
19:42:03 <pikajude> i have a Double and I want to convert it into a NominalDiffTime
19:42:16 <pikajude> it's for showing a player how much time is estimated to be left before their objective completes
19:42:23 <pikajude> so precision isn't important
20:19:40 <lispy> I'm getting this duplicate instance error building cabal-install against the 8.0 release candidate: http://lpaste.net/153527
20:19:56 <lispy> Is this a known issue? Is there a cabal-install release candidate to match ghc 8?
20:34:55 <jakeehrlich> Does anyone know of a generic (e.g. not Json specific) library for bidirectinal parsing combinators?
20:36:16 <EvanR_> @hoogle (a -> a) -> a -> [a]
20:36:18 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
20:36:18 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
20:36:18 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
20:47:28 <tsani_> Is there something like `sequence` but for tuples ?
20:48:09 <tsani_> mmm, actually I could just use the applicative instance
20:48:22 <shachaf> That isn't a clear description of the behavior you want.
20:48:56 <tsani_> Something with a signature like (f a, f b, f c, ...) -> f (a, b, c, ...) 
20:49:04 <tsani_> (where f is an applicative in my case)
20:49:40 <tsani_> It'd be nice if there were a somewhat generic way to do it for tuples of arbitrary size, but I doubt that's possible in a clean way
20:53:41 <EvanR_> :t liftA2 (,)
20:53:42 <lambdabot> Applicative f => f a -> f b -> f (a, b)
20:53:50 <EvanR_> :t liftA3 (,)
20:53:51 <lambdabot>     Couldn't match type ‘(a, b)’ with ‘c -> d’
20:53:51 <lambdabot>     Expected type: a -> b -> c -> d
20:53:51 <lambdabot>       Actual type: a -> b -> (a, b)
20:54:01 <EvanR_> etc
20:54:34 <EvanR_> tsani_ with typeclass shenanigans its possible to define computations for (a, (b, (c, (...
20:55:52 <mniip> if you use 4-tuples you are probably doing something wrong
21:44:51 <shachaf> In some sort of typed lambda calculus with polymorphism, you can make make products with polymorphic functions : forall r. (A -> B -> r) -> r. Can this be represented in a category with some sort of end or something like that? What would a type like that mean in a category which isn't cartesian closed?
22:47:35 * hackagebot optparse-generic 1.0.0 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.0.0 (GabrielGonzalez)
23:05:28 <lyxia> http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Sequence.html tsani_ 
23:05:43 <lyxia> look at this monster
23:12:13 <Adeon> my dad writes more tuple instances than your dad
23:12:41 <Cale> lyxia: ;__;
23:13:31 <Cale> Lennart pls why
23:14:57 <Adeon> looking at source, I hope lennart didn't write all that by hand
23:15:46 <Adeon> ah wait, it's machine generated
23:15:57 <Adeon> it says so in a comment
23:16:05 <Adeon> phew
23:18:21 <Cale> Yeah, even so, given that it's rare to see anything larger than a pair, and much rarer still to see anything larger than a triple, it makes you wonder what sort of code needs a library like this.
23:18:28 <srhb> How do people usually do that, anyway? Write some TH to generate it and just stop the process after splicing?
23:19:59 <srhb> Oh, I see he just wrote some Haskell to actually string Haskell Strings together.
23:20:17 <srhb> Feels slightly scary. :-)
23:21:08 <srhb> I suppose one would work with the AST instead and render that to a file. I wonder how much more painful that would be.
23:22:20 <mniip> having worked with TH, I can say, it
23:22:24 <mniip> 's probably the same
23:30:47 <srhb> mniip: Ah. :)
23:31:34 <srhb> Thinking about it, generating the AST and then rendering it seems more correct, considering that at least some constraints of the language would be checked by the structure of the AST itself.
