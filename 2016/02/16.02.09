00:03:02 <ski> Squarism : and what if there's multiple triples with the same ID ?
00:03:12 <ski> or possibly that is assumed not to happen ?
00:03:17 <MarcelineVQ> jle`: Thanks for the explanation, was just working through/with them for a bit
00:04:25 <jle`> np!
00:07:14 <Jinxit> echo-area: in swedish we say "boll", literally "ball" :)
00:07:31 <koz_> Does it make sense for a Stream to be Foldable?
00:07:38 * hackagebot publicsuffix 0.20160209 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160209 (wereHamster)
00:07:38 * hackagebot lit 0.1.10.0 - A simple tool for literate programming  https://hackage.haskell.org/package/lit-0.1.10.0 (cdosborn)
00:09:21 <ski> koz_ : yes, `foldr' will work fine
00:09:39 <ski> `foldr (:) undefined' should convert the stream to an (infinite) list, e.g.
00:10:07 <echo-area> Jinxit: :)
00:10:11 <koz_> ski: But not foldl, right?
00:10:19 * ski nods
00:11:28 <koz_> Ah, it seems like its minimal implementation is either foldr or foldMap.
00:11:33 <ski> Jinxit : hm, har ej h√∂rt "boll" innan. en f√∂rel√§sare l√§ste `g ‚àò f' som "goff", dock
00:11:43 <koz_> Interestingly, it means that Stream is Foldable, but *not* MonoFoldable...
00:12:53 * ski noterar Jinxit ej i #haskell.se
00:19:05 <koz_> ski: foldr f x (Cons y sy) = foldr f (f y x) sy <-- is this right?
00:22:04 <ski> koz_ : that's tail-recursive, so can't be right
00:22:26 <koz_> ski: I'm not sure what I'm missing then.
00:23:40 <ski> <ski> `foldr (:) undefined' should convert the stream to an (infinite) list, e.g.
00:23:43 <ski> consider
00:23:43 <jle`> try getting some inspiration from the definition of foldr for lists
00:23:57 <ski>   from :: Num a => a -> Stream a
00:23:59 <koz_> It's defined using Endo stuff, jle`.
00:24:09 <ski>   from n = Cons n (from (n + 1))
00:24:34 <jle`> @src foldr
00:24:34 <lambdabot> foldr f z []     = z
00:24:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:24:49 <koz_> jle`: Weird - I must be looking at a different foldr definition.
00:24:52 <ski> now, using your suggested `foldr', we get
00:25:01 <jle`> you are, this is foldr from the old days heh
00:25:10 <ski>      foldr (:) undefine (from 0)
00:25:12 <jle`> nowadays the foldr is written polymorphically over all Foldable's
00:25:27 <ski>   =  foldr (:) undefine (Cons 0 (from 1))
00:25:37 <ski>   =  foldr (:) (0 : undefine) (from 1)
00:25:52 <ski>   =  foldr (:) (0 : undefine) (Cons 1 (from 2))
00:25:59 <ski>   =  foldr (:) (1 : 0 : undefine) (from 2)
00:26:07 <ski> clearly this is building the list in the wrong order
00:26:08 <koz_> ski: It's backwards.
00:26:09 <jle`> i also like to think of 'foldr' as a catamorphism on lists.  for `foldr f z`, replace all (:)'s with f, and all []'s with z
00:26:13 <koz_> I think I got it.
00:26:20 <jle`> so foldr for streams should work the same way
00:26:22 <koz_> foldr f z (Cons x xs) = f x (foldr f z xs)
00:26:26 <ski> yep
00:26:31 <koz_> I was *almost* right.
00:26:33 <ski> and now you can see that `z' is dead there
00:26:34 <jle`> mhm
00:26:41 <ski> you might as well say
00:26:51 <ski>   foldr f _ = go
00:26:52 <ski>     where
00:26:57 <jle`> it might be easier to define foldMap, honestly
00:27:03 <ski>     go (Cons x xs) = f x (go xs)
00:27:06 <jle`> foldMap f (x :~ xs) = f x <> foldMap f xs
00:27:24 <koz_> ski: Fair enough.
00:27:31 <jle`> that way you don't have to worry about the silly z business
00:27:50 <jle`> it's a bit clearer how the structure of Stream behaves under folding this way
00:28:50 <koz_> Alrighty, so it's a Functor, and Foldable.
00:28:59 <koz_> So does this mean it can be a Traversable too?
00:29:31 <jle`> you might have that backwards, heh; Traversable implies Functor and Foldable
00:29:33 <jle`> not the other way around
00:29:38 <jle`> but i think there is a sensible Traversable instance
00:29:40 <koz_> Oh yeah, derp.
00:30:31 <jle`> it'd weird though because for most Applicatives, sequence/traverse won't terminate
00:30:36 <jle`> it's
00:30:42 <jle`> but i think it still is lawful
00:30:55 * ski interpreted koz_'s question as noting that it being an instance of `Functor' and `Foldable' *enabling* you to *ask* whether it can also be an instance of `Traversable'
00:31:25 <koz_> So sequenceA for it would have type Stream (f a) -> f (Stream a) ?
00:31:32 <jle`> yes
00:31:46 <jle`> for all Applicative f
00:31:52 <koz_> So wait, you take a Stream of actions on as, and return an action on a Stream of as?
00:32:19 <ski> consider `f' being `Writer w'
00:32:29 <ski> koz_ : yep
00:32:46 <jle`> a stream of actions that produce 'a's, and return an action that produces a stream of a's
00:33:12 <koz_> OK, gotta think about how the fuck to write this.
00:33:28 <jle`> the common interpretation of sequence is execute-every-contained-f a-and-reaccumulate/rebuild-the-results-into-the-original-structure
00:33:47 <ski> `f' being `Either e' might be useful in some cases, but you can't expect to get a `Right' answer then
00:33:54 <jle`> for example, sequence :: Map k (IO a) -> IO (Map k a)
00:33:59 <zipper> OMG I've been tackling this problem for so long I don' know what to do anymore.
00:34:02 <koz_> I find it odd that while Foldable only requires foldr, but MonoFoldable requires the whole spread...
00:34:06 <jle`> execute all of the IO a's in the map, and rebuild the results into a new map
00:34:20 <zipper> That one problem that makes you question your ability to program anything.
00:34:24 <koz_> jle`: But wouldn't a Stream of actions never end?
00:34:32 <jle`> for some Applicatives, yes
00:34:38 <koz_> I'm having a bit of trouble wrapping my mind around how I would implement this.
00:34:52 <jle`> don't worry about whether or not the actions will terminate
00:35:00 <zipper> So I want to do something like print but in the browser.
00:35:04 <jle`> just "execute all of them"
00:35:15 * koz_ needs to look at the definition of Applicative again.
00:35:24 <zipper> I am trying to write a log of a compilation process but in the browser.
00:35:32 <zipper> And do it in real time.
00:35:40 <jle`> when you give up, look at the definition of sequenceA for lists :)
00:35:41 <zipper> I tried websockets which failed terribly.
00:35:59 <koz_> jle`: I get the feeling folding using <*> might be involved.
00:36:27 <zipper> Because a user has to load the page first to start this handshake which is what I don't want because this will block the compilation process.
00:36:54 <koz_> @src sequenceA
00:36:54 <lambdabot> Source not found. Sorry.
00:36:59 <jle`> the way you might have it is to have the server process register a listener to a websocket connection
00:37:04 <koz_> OK, that's nmot gonna work then.
00:37:06 <jle`> @src sequence
00:37:06 <lambdabot> sequence []     = return []
00:37:06 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:37:06 <lambdabot> --OR
00:37:06 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:37:08 <zipper> How would anyone go about printing a log of a build process in a browser?
00:37:11 <jle`> but that's cheaing ::)
00:37:15 <jle`> *cheating
00:37:30 <koz_> Yeah, I thought foldr might be involved here.
00:37:47 <koz_> But obviously, I can't translate the second one directly, because there's no Stream equivalent to [].
00:37:49 <jle`> zipper: websockets would work, but you would have to find a way to register a websocket to the output stream of the builder status
00:38:52 <zipper> hmmmm I'm not sure I get what you mean by register a websocket. You mean carry out the websocket handshake?
00:38:57 <ski> koz_ : the second argument of `foldr', for `Stream', is ignored
00:39:10 <zipper> jle`: See the browser has to start the websocket connection
00:39:26 <zipper> Because http has the client request a page from the browser
00:40:34 <koz_> ski: OK, that helps.
00:40:49 <ski> (remember `z' above ?)
00:41:09 <koz_> Yeah, I remember.
00:41:20 <koz_> So that means I *could* translate that second definition - I just have to think how.
00:42:55 <jle`> you can just put 'undefined' there, which would be fine, but a bit ugly
00:43:35 <koz_> I'm not sure how to do this, honestly. My current thought is something like: sequenceA x = return (foldr <*> x)
00:43:44 <koz_> But obviously, that's not gonna work.
00:44:24 <ski> `foldr' will tear down the input stream. you have to explicitly build a new one
00:45:06 <koz_> But the thing is, how do I 'pull' stuff out of the actions in the input Stream?
00:46:37 <jle`> hm
00:46:43 <jle`> how about looking at the definition of foldMap
00:46:52 <jle`> foldMap f (x :~ xs) = f x <> foldMap f xs
00:47:20 <jle`> or actually, even better
00:47:26 <jle`> fold (x :~ xs) = x <> fold xs
00:47:37 <jle`> if you stare at that long enough, you might start to see how you can translate that to make it 'sequenceA'
00:48:04 <jle`> sequenceA (x :~ xs) = x ??? sequenceA xs
00:48:05 <koz_> jle`: So wait, would it be something like 'return (x <> sequenceA xs)'?
00:48:24 <jle`> try using typed holes in ghci to try to guess what type that operator has to be
00:49:07 <jle`> i won't give it away
00:49:33 <jle`> (if you use typed holes, it'd be as sequenceA (x :~ xs) = _ x (sequenceA xs)
00:50:10 <koz_> :t <>
00:50:12 <lambdabot> parse error on input ‚Äò<>‚Äô
00:50:34 <cocreature> you need parentheses
00:50:36 <cocreature> :t (<>)
00:50:37 <lambdabot> Monoid m => m -> m -> m
00:51:03 <jle`> in sequenceA (x :~ xs) = .., what is the type of x, and what is the type of xs?
00:51:10 <jle`> and what is the type you want to return in the end?
00:51:26 <jle`> oh, i'm using (:~) as Cons, if that wasn't clear
00:51:34 <ski> koz_ : `return (...)' represents a "pure" computation, one with no effects, so that can't be it (it has to combine the effects of all the actions in the stream)
00:51:36 <koz_> jle`: Nope, I got that.
00:51:49 <Nulldata> Hey
00:51:54 <jle`> zipper: what's the problem with that?
00:52:00 <liste> hi Nulldata 
00:52:05 <koz_> Holy shit that signature from the hole...
00:52:06 <jle`> hi Nulldata 
00:52:24 <jle`> the signature shouldn't be too complex actually ....
00:52:27 <koz_> jle`: x is an f a, and xs is a Stream f a.
00:52:39 <zipper> jle`: I would assume users might not want it. Maybe you're right. Nothing is wrong with that.
00:53:05 <koz_> jle`: http://paste.rel4tion.org/245 <-- hole description I'm getting
00:53:11 <jle`> koz_: okay, so we can use `sequenceA` on xs like we did for the fold/foldMap description
00:53:17 <jle`> so what's the type of sequenceA xs ?
00:53:36 <jle`> koz_: you forgot parentheses
00:53:42 <jle`> _ x (sequenceA xs)
00:53:49 <koz_> Oh, ok.
00:54:18 <koz_> OK, it wants 'f a -> f (Stream a) -> f (Stream a)'.
00:54:39 <koz_> Wait, wait, *Cons*?
00:54:45 <jle`> mhm.  you want to execute the first one, then execute the second one, and combine the results
00:55:02 <jle`> sounds like a common pattern for Appliative
00:55:17 <jle`> :t liftA2
00:55:18 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:56:32 <koz_> So it's liftA2 something x (sequenceA xs)?
00:56:40 <Nulldata> Does anybody know why haskell can't match the type-variable `e` in the context of `String -> Free Expression e` with `Free Expression e`. The problem occurs when I'm using a constructor function for my `Free Expression e` which involves constructing it from that same type. It seems like the type-inference can detect that the resulting type is `Free Expression (Free Expression e)` (which is...
00:56:42 <Nulldata> ...correct) but it can't match `e` with that inner `Free Expression e`.
00:57:13 <Nulldata> Where `data Free f a = Free (f (Free f a)) | Pure a`
00:57:39 * hackagebot sampling 0.1.1 - Sample values from collections.  https://hackage.haskell.org/package/sampling-0.1.1 (JaredTobin)
00:57:41 <jle`> koz_: yes
00:57:42 <koz_> Wait, I think I have it!
00:57:51 <koz_> sequenceA (Cons x xs) = liftA2 Cons x (sequenceA xs)
00:58:31 <koz_> Unless I'm totally off-base here.
00:58:47 <koz_> Because the hole in that is a -> Stream a -> Stream a.
00:59:34 <zd234> what are the main downsides of https://github.com/atzeus/CTRex ?
00:59:38 <zd234> this library looks amazing
01:02:40 <koz_> jle`: Did I get it right?
01:02:50 * hackagebot haskellscrabble 2.0.0 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-2.0.0 (happy0)
01:03:42 <jle`> koz_: you got it :)
01:04:12 <koz_> Wow... my head hurts.
01:04:14 <jle`> try sequenceA (repeat Nothing)
01:04:27 <jle`> the traversable instance isn't used a lot in practice
01:04:41 <koz_> jle` and ski: For MonoFoldable, can I just make foldl and friends 'undefined' and call it OK, or should I have it error out?
01:04:49 <koz_> (or define them and have it throw an infinite loop?)
01:05:08 <koz_> (since MonoFoldable requires foldl and friends to be defined even though it makes no sense to do so).
01:08:19 <jle`> it's a toy project or learning, so it's up to you :)  in the real world i'd hope my libraries don't give incomplete instances, and if they do, i'd much rather prefer a nice error message than an infinite loop
01:09:38 <koz_> jle`: OK, erroring it is.
01:09:57 <jle`> but if it's a learning project, implementing the looping one might be more fun :P
01:10:18 <koz_> jle`: I think I'll stick to erroring out - as you said, this is better 'real world' practice.
01:10:42 <koz_> Also, I'm kinda sad that IsSequence can't be implemented for Stream, as it requires it to be a Monoid.
01:10:50 <koz_> And there's no sensible 'mempty' for Stream.
01:17:50 * hackagebot language-thrift 0.8.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.8.0.0 (abhinav)
01:18:32 <shanthakumar> @pl check_ [] actual reverse = actual == reverse
01:18:32 <lambdabot> (line 1, column 27):
01:18:32 <lambdabot> unexpected " "
01:18:32 <lambdabot> expecting operator
01:18:53 <shanthakumar> @pl let check_ [] actual reverse = actual == reverse
01:18:54 <lambdabot> (line 1, column 12):
01:18:54 <lambdabot> unexpected "["
01:18:54 <lambdabot> expecting pattern or "="
01:19:29 <shanthakumar> @pl (\ [] actual reverse -> actual == reverse)
01:19:30 <lambdabot> (line 1, column 4):
01:19:30 <lambdabot> unexpected "["
01:19:30 <lambdabot> expecting pattern
01:21:18 <ski> @pl check_[] actual reverse = actual == reverse
01:21:18 <lambdabot> (line 1, column 26):
01:21:18 <lambdabot> unexpected " "
01:21:18 <lambdabot> expecting operator
01:21:32 <ski> @pl check_empty actual reverse = actual == reverse
01:21:32 <lambdabot> check_empty = (==)
01:21:33 <koz_> jle`: Could there be a way to write a Monoid instance for Streams that meets all the laws without ever defining mempty (except as 'undefined' or something similarly stupid).
01:21:37 <koz_> s/./?
01:22:14 <koz_> Since mappending together two streams x and y is functionally the same as just returning x, right?
01:22:30 <jle`> well, you can write a Monoid instance for Monoid m => Stream m
01:22:34 <koz_> And this doesn't break associativity.
01:22:44 <jle`> and mempty = repeat mempty
01:22:53 <koz_> jle`: Wait, how would *that* work?
01:22:59 <jle`> mappend = zipWith mappend
01:23:23 <koz_> Wouldn't that definition of mempty break associativity?
01:23:24 <jle`> mappending wouldn't be concatenation, it'd be a pair-wise mappending
01:23:56 <jle`> nah, it wouldn't
01:24:11 <jle`> repeat (Sum 0) <> repeat (Sum 1) = repeat (Sum 1), as expected
01:24:21 <ski> basically considering `Stream a' as `Natural -> a', using the environment/coordinatewise/reader monoid on that
01:24:39 <jle`> repeat (Sum 1) <> repeat (Sum 2) <> repeat (Sum 3) = repeat (Sum 6) no matter how you associate it
01:25:27 <koz_> jle`: But would mempty <> repeat (Sum 1) be the same as repeat (Sum 1) <> mempty under that definition?
01:25:33 <jle`> yes
01:25:36 <koz_> Oh!
01:25:39 <koz_> *NOW* I get you.
01:25:45 <koz_> That's genius.
01:25:58 <ski> i suppose this is also called the direct product on monoids
01:26:11 <jle`> it'll make more sense once you look at the Applicative instance
01:26:45 <jle`> but it's likely that an IsSequence instance is intended to have a concatenatey monoid instance
01:27:16 <koz_> jle`: I guessed as much.
01:28:01 <koz_> And there's no way to define a concatenative one...
01:28:15 * hackagebot libgraph 1.10 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.10 (faddegon)
01:28:15 <jle`> nope
01:32:05 <koz_> Also, ClassyPrelude is getting in my way again - it requires an implementation of Zip for Stream to make jle`'s plan work, but hides the necessary package...
01:33:07 <jle`> if you need something from a package, just add it to the build-depends?
01:33:25 <koz_> jle`: Oh, yeah, forgot that one. Derp, let me fix.
01:33:40 <jle`> it's not exactly normal for a module to export every package of every type it uses
01:34:17 <koz_> jle`: I know - you even told me as much recently, but I kinda forgot.
01:36:53 <koz_> It's late, but I'm too excited to stop.
01:39:23 <koz_> jle`: Do the sequence laws here imply that <> is concatenative? https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-Sequences.html#t:IsSequence
01:39:36 <koz_> I assume the answer is 'yes'.
01:40:10 <jle`> yes, fromList (x ++ y) = fromList x <> fromList y
01:40:23 <koz_> Oh well. Guess I'll limit myself to SemiSequence.
01:40:29 <jle`> never mind that you can't even write a sensible fromList :p
01:40:48 <koz_> Oh wait, SemiSequence won't necessarily work either... goddamn reverse.
01:41:05 <koz_> And find might be non-terminating, although I guess that's OK.
01:43:35 <jle`> Nulldata: do you have sample code?
01:45:52 <koz_> I think I'll resume this tomorrow. Thank you ski, jle` and everyone else for the help!
01:46:10 <jle`> have a nice night!
01:46:18 <jle`> congrats on the self-control :)
02:00:26 <koz_> OK, I couldn't help myself - can I make Stream a MonoPointed? https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:MonoPointed
02:00:40 <koz_> I'd make opoint = repeat
02:01:02 <jle`> yes
02:01:12 <jle`> but don't take my word for it
02:01:14 <jle`> verify the law :)
02:01:34 <jle`> using the power of equational reasoning
02:01:40 <koz_> jle`: Well, yeah, obviously, since omap simply applies the function to everything in the Stream.
02:01:51 <koz_> It doesn't matter whether you do it before or after you make your stream of whatevers.
02:01:56 <jle`> that's the intuition.  but you can also prove it
02:01:59 <koz_> You still get a stream of f(whatevers).
02:03:19 <koz_> jle`: I'm also guessing that Stream can be an Applicative?
02:04:12 <Nulldata> jle`: Well the code that causes the error is part of some parser code, so should I try to isolate the problem?
02:04:47 <jle`> koz_: yes! :O
02:04:54 <jle`> Nulldata: that'd probably be the best way to get help :)
02:04:56 <koz_> Well, pure = repeat.
02:05:00 <koz_> <*> is ... more complex.
02:05:16 <Nulldata> jle`: Okay I'll try to reproduce it in a simpler context then
02:05:23 <jle`> just set up your patterns and pattern match and play with typed holes
02:05:25 <jle`> <*> sort of writes itself
02:05:29 <koz_> It takes an infinite stream of functions and an infinite stream of inputs, and spews an infinite stream of outputs.
02:07:21 <merijn> Obligatory comment about the amazing -fdefer-typed-holes for development ;)
02:07:34 <safrol_> intention
02:07:43 <safrol_> is like an hourglass
02:07:49 <safrol_> analogies...
02:08:08 <merijn> @quote analogy
02:08:09 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
02:08:13 <merijn> hmmm, wrong quote
02:08:18 <merijn> @quote mmorrow analogy
02:08:19 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
02:08:25 <koz_> jle`: http://paste.rel4tion.org/246 <-- did I do good?
02:08:51 <jle`> looks good to me
02:08:58 <koz_> Yessssss.
02:09:17 <koz_> OK, now the big one - Monad.
02:09:23 <jle`> another way you can look at 'Stream a' is as a "producer of a's"
02:09:38 <jle`> so <*> takes a producer of (a -> b)'s and a producer of a's, and returns a producer of b's
02:09:54 <jle`> the sort of natural interpretation is that the producer of b's just applies the f's as they come out to the x's as they come out
02:09:56 <koz_> I kinda imagine it as 'pairing off' functions and inputs.
02:10:54 <jle`> the monad instance is the interesting one.  there are a couple of ways to approach it, i think
02:11:16 <jle`> one is to just try out a bunch of different implementations of (>>=) until you get one that follows (join . fmap join) = (join . join)
02:11:39 <koz_> And the other?
02:11:40 <jle`> another is to imagine that `Stream a` is a `Natural -> a`, and ponder the Monad instance for `(->) Natural`
02:11:48 <koz_> I think I'll try the first.
02:13:21 <jle`> koz_: hm, by the first, i meant play with implementations of 'join'
02:13:45 <jle`> so x >>= f = join' (fmap f x) where join' = ...
02:13:51 <jle`> join :: Stream (Stream a) -> Stream a
02:13:55 <koz_> Ah.
02:13:57 * hackagebot json-stream 0.4.1.0 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.4.1.0 (ondrap)
02:13:59 * hackagebot pagerduty 0.0.5 - Client library for PagerDuty Integration and REST APIs.  https://hackage.haskell.org/package/pagerduty-0.0.5 (BrendanHay)
02:14:01 * hackagebot arbtt 0.9.0.8 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.9.0.8 (JoachimBreitner)
02:14:31 <koz_> A Stream of Streams...
02:14:49 <jle`> one naive implementation would be join (xs :~ xss) = xs
02:15:35 <koz_> So just ignore the rest?
02:15:56 <jle`> yeah, but this doesn't quite work
02:16:04 <koz_> Yeah - I thought that was too easy.
02:16:11 <koz_> Let me see if I can figure out what this breaks.
02:16:51 <jle`> even though it does follow (join . fmap join) = (join . join)
02:17:29 <jle`> it doesn't follow join . return = join . fmap return = id
02:17:54 <jle`> it might be useful to think of something else besides 'repeat', like:
02:18:03 <jle`> countFrom i = i :~ countFrom (i + 1)
02:18:57 * hackagebot tttool 1.6.0.1 - Working with files for the TiptoiÆ pen  https://hackage.haskell.org/package/tttool-1.6.0.1 (JoachimBreitner)
02:18:59 * hackagebot postgresql-binary 0.8 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.8 (NikitaVolkov)
02:19:02 <koz_> I think I might have to leave *that* one for a fresher mind. I don't think I can wrap this around my brain right now.
02:19:15 <jle`> join (fmap return (x :~ xs)) = join (return x :~ fmap return xs) = return x
02:19:39 <jle`> so (join . fmap return) (x :~ xs) = repeat xs
02:19:45 <jle`> so this doesn't work :O
02:20:10 <koz_> Are there more typeclasses I can do *after* Monad, I wonder...
02:21:30 <jle`> Comonad :)
02:21:44 <jle`> the Comonad instance is also particularly fun
02:21:52 <koz_> I don't even *know* what Comonads are.
02:22:15 <jle`> Stream is actually one of the famous examples of comonads
02:23:10 <Nulldata> jle`: https://gist.github.com/nulldatamap/575cd5c04ef4024f5a14 here. It complains that it's an infinite type, but isn't that the whole idea behind having a tree structure of `Free`?
02:23:36 <jle`> that's not quite what the infinite in infinite type means
02:23:45 <Nulldata> Haha evidently not
02:23:57 <jle`> it's something similar to:
02:23:58 * hackagebot gipeda 0.2.0.1 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.2.0.1 (JoachimBreitner)
02:23:59 <jle`> > \x -> x : x
02:24:01 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
02:24:01 <lambdabot>      Relevant bindings include x :: a (bound at <interactive>:1:2)
02:24:01 <lambdabot>      In the second argument of ‚Äò(:)‚Äô, namely ‚Äòx‚Äô
02:24:24 <safrol_> lambdabot: u so cute
02:24:29 <safrol_> BMO anyone?
02:24:50 <jle`> what would the first x in x : x be?  if it's 'a', the the second x has to be [a], but then that means it has to be [[a]], which means it has to be [[[a]]] ...
02:25:39 <jle`> the type error sort of tells you how to fix it
02:28:12 <jle`> the problem is that it is trying to unify 'a' such that `a ~ Free f a`, but there isn't any choice of 'a' that will unify it
02:29:17 <Nulldata> Okay, so since there's no "bottom" to this nested type I'd need a placeholder bottom type for actually populating the leaf nodes ( Even though they might end on a non-value storing node )
02:29:18 <jle`> try using 'Ex' directly instead of 'ex
02:29:52 <jle`> problem (x:[]) = Free (Ex (Pure x) Nothing)
02:30:02 <jle`> and try implementing the second case
02:33:23 <Nulldata> That actually compiles!
02:33:32 <jle`> neat!
02:33:42 <jle`> the problem was that your definition of 'ex' was redundantly fmapping when it didn't need to
02:33:49 <jle`> so it didn't do what you wanted
02:36:42 <{AS}> Hi, what is this function called (a -> b -> c) -> (a -> b) -> (a -> c) ?
02:37:09 <jle`> 'ap' ?
02:37:11 <opqdonut> is that the S combinator?
02:37:15 <jle`> or S
02:37:21 <{AS}> Ah, thanks :)
02:37:27 <jle`> :t ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
02:37:29 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
02:37:37 <{AS}> Ah so it is applicative on (->) ?
02:37:45 <jle`> `(->) a`
02:39:19 * hackagebot classy-prelude 0.12.5.1 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-0.12.5.1 (MichaelSnoyman)
02:41:19 <liste> :t <*> :: (a -> b -> c) -> (a -> b) -> (a -> c)
02:41:20 <lambdabot> parse error on input ‚Äò<*>‚Äô
02:41:25 <liste> :t (<*>) :: (a -> b -> c) -> (a -> b) -> (a -> c)
02:41:26 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
02:41:30 <liste> that too
02:44:19 * hackagebot conduit-combinators 1.0.3.1 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.3.1 (MichaelSnoyman)
02:50:08 <Nulldata> jle`: I'm still trying to wrap my head around it, for some reason I'm just not "getting" it
02:51:40 <kostja> how to create a conduit, that yields input inside a pair of values in the stream?
02:52:25 <kostja> do I need to use a state monad?
02:53:53 <kostja> or can a conduit modify itself, like a wire in netwire?
02:54:39 <safrol_> are we able to use infinity in haskell? xD
02:57:30 <pavonia> safrol_: We can use infinite data structures to some extent, e.g. [1..]
02:57:34 <liste> > 1/0
02:57:36 <lambdabot>  Infinity
02:58:13 <safrol_> i see pavonia, thanks.
02:59:32 * hackagebot mandrill 0.5.1.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.1.0 (AlfredoDiNapoli)
03:02:43 <safrol_> So, what's so funny about that?
03:02:53 <safrol_> errr, fun.
03:06:09 <safrol_> Where's the punchline in life?
03:08:10 <obadz> Is there a way to declare a bunch of "unique values" (Ints or otherwise) at the toplevel? like unique1 = makeUniqueValue etc..
03:08:28 <obadz> thought about unsafePerformIO Data.Unique but I'm always afraid it would get evaluated more than once
03:08:50 <obadz> only other solution I can think of is templateHaskell
03:10:04 <liste> obadz: https://wiki.haskell.org/Top_level_mutable_state applies here too
03:10:42 <obadz> liste: will read
03:21:42 <Wizek> Anyone knows the answer to this one? http://stackoverflow.com/questions/35289060/how-to-execute-haskell-code-in-the-context-of-main-with-stack/35289405 Neither of the answers given have worked for me yet.
03:29:33 * hackagebot eventstore 0.10.0.2 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.10.0.2 (YorickLaupa)
03:38:03 <zyxoas> Hey, peeps.
03:39:48 <zyxoas> Is there some way to copy the executable created by stack to some directory of your choosing? The current path has a lot of stuff (LTS version, GHC version, &c) which I do not want to have to remember, and the closest I have seen is the --copy-bins option which copies to a set directory (the bin path). Is there some way to tell stack to copy to a d
03:39:48 <zyxoas> irectory of my choosing?
03:45:40 <liste> zyxoas: there's a --local-bin-path switch
03:46:36 <liste> stack --local-bin-path /where/you/want/it install
03:47:17 <zyxoas> Hmm... That option does not appear when I do "stack build --help". But let me check it out liste.
03:47:49 <liste> zyxoas: it appears when you stack --help
03:49:58 <zyxoas> That works perfectly. Thanks, liste.
03:52:08 <liste> yw (:
03:58:29 <lyxia> Wizek: stack ghc -- app/Main.hs -e "Main.main" ?
04:05:47 <alex-v> @djinn (Monad m) => (a -> b -> m r) -> m a -> m b -> m r
04:05:47 <lambdabot> -- f cannot be realized.
04:06:53 <opqdonut> :t liftM2
04:06:55 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:07:00 <opqdonut> does djinn even do monad stuff?
04:07:32 <alex-v> i don't know
04:07:48 <opqdonut> oh right you need one join in there
04:08:06 <alex-v> :t join $ liftM2
04:08:07 <lambdabot> ((a2 -> r) -> a2 -> r) -> ((a2 -> r) -> a2) -> (a2 -> r) -> r
04:08:20 <opqdonut> or just "f g a b = do x <- a; y <- b; g x y"
04:08:38 <opqdonut> @pl \f a b -> join (liftM2 f a b)
04:08:39 <lambdabot> ((join .) .) . liftM2
04:08:41 <opqdonut> hehe
04:09:14 <alex-v> yes I'm trying to rewrite exactly this pattern  "f g a b = do x <- a; y <- b; g x y"
04:10:08 <alex-v> but it seems way too pointless
04:10:42 <frerich> alex-v: Maybe you'd like 'g <$> a <*> b'
04:10:55 <opqdonut> that still needs a join, right
04:11:02 <opqdonut> because that's just liftM2
04:12:51 <frerich> Hm yeah, in the original case 'g' yields a 'Monad m => m a' but in my proposal, it doesn't.
04:13:50 <alex-v> unfortunatly my `g` is monadic
04:14:34 * hackagebot pusher-http-haskell 0.3.0.2 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-0.3.0.2 (willsewell)
04:15:51 <sena_kun> hi folks. I have a plain task: to walk over a directory tree and insert some files data into database. I did it with pipes, but it seems that making a query every time for only one file(their parsing is cheap) is slow. Can I do something with pipes to send data to consumer with more than one 'chunk' at once? Maybe conduit can make something like I want or no? There are not so many files in directory(~2k).
04:17:24 <_felixsch> hey all. I'm trying to get warm with servant. I try to implement basic authentification for the client module but I fail. Do you see what I'm doing wrong? http://lpaste.net/1120719188441169920
04:18:46 <alpounet> _felixsch: you probably want to ask on #servant
04:19:24 <_felixsch> Ah ok didn't know there is project channel. thanks :)
04:23:18 <sena_kun> Ah, it seems the solution is obvious: collect and yield a sized list of results and consume it appropriately. Will try to do so then.
04:29:35 * hackagebot hasql 0.19.7 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.7 (NikitaVolkov)
04:31:08 <saurabhnanda> Hey, good people. Any haskell-ninjas that can help me wrap my head around GADTs. Here's the original question I asked on StackOverflow:  http://stackoverflow.com/questions/35266143/ghc-compiler-not-complaining-about-incorrect-code-paths/35268192#35268192 , in which I got pointed to GADTs. I'm trying it out at http://lpaste.net/151949 but it doesn't seem to be working. What gives?
04:32:14 <deni> is there any good write up on the differences between Generic and TH?
04:32:26 <barrucadu> saurabhnanda: The type String -> String -> Command p means that the caller gets to choose that the 'p' is, and your function will work for any choice
04:32:46 <deni> as far sa I can tell people don't seem to like TH.....but I don't see that much "not liking" when it comes to Generics. I thought they were basically the same thing (different implementation)
04:35:36 <ironChicken> i have this mostly ffi library i've been working on for ages: <https://github.com/TransformingMusicology/libaudioDB-haskell>
04:36:08 <ironChicken> today i was trying to build it on a fresh computer but it fails to link correctly against the shared library that it's a wrapper over
04:36:59 <ironChicken> it reports that it all the symbols it's supposed to import from the shared library are "undefined reference"s
04:37:32 <ironChicken> the versions of GHC and cabal are behind my development machine
04:38:08 <ironChicken> i have ghc 7.10.3, it has 7.6.3
04:38:30 <ironChicken> would anyone be interested in trying to compile it?
04:38:48 <ironChicken> it also involves compiling the C(++) library
04:39:03 <ironChicken> <https://github.com/TransformingMusicology/libaudiodb>
04:41:28 <kostja> how to filter values between two keywords in a conduit stream?
04:41:45 <hatds> saurabhnanda: maybe try replacing 'authorizeUser :: String -> String -> Command p' with 'authorizeUser :: String -> String -> Command Permission'.  Also it looks like 'line 6' should be 'Unauthorized' btw.
04:41:50 <saurabhnanda> barrucadu: how do I write that function signature in that case? 
04:42:26 <erbse> hi, I'm trying to compile the first example from http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/, but ghc give me this error "No instance for (E.Exception a0) arising from a use of ‚ÄòE.catch‚Äô"
04:42:35 <barrucadu> saurabhnanda: Firstly, I think your GADT definition is wrong, surely it should be UnauthorizedCommand :: Command Unauthorized
04:42:57 <saurabhnanda> barrucadu: go that, hatds pointed it out.
04:43:29 <barrucadu> Secondly, the same way we write any function that can return one of two types in Haskell: Either. authorizeUser :: String -> String -> Either (Command Unauthorized) (Command Authorized), appropriately putting a Left and Right into your function definition
04:44:27 <hatds> Doesn't using an Either defeat the purpose of using a GADT here?
04:44:50 <saurabhnanda> barrucadu: in that case, what's the benefit of using algebraic data types, whether generalized or not?
04:45:21 <barrucadu> This isn't a particularly great example of a use case for GADTs
04:45:23 <saurabhnanda> isn't the "type" of "Command Authorized" and "Command Unauthorized"  "Command p"
04:45:23 <erbse> code: http://pastebin.com/HGaXisR8, this code is just copy and pasted but won't get compile, is my ghc version not right?
04:45:35 <barrucadu> I think they really come into their own when used with polymorphism
04:45:42 <saurabhnanda> I'm coming from a Lisp MOP background here, so trying to derive intuition from there.
04:45:43 <barrucadu> Hang on, let me find a small example
04:46:20 <barrucadu> I've been writing a little unit testing library, where I use a GADT to represent the different types of tests: https://github.com/barrucadu/barometer/blob/master/Test/Barometer/Base.hs#L120
04:46:37 <barrucadu> There are type variables used in the constructors of the GADT that don't appear in its actual type
04:47:08 <barrucadu> If that were an ADT, it'd be defined something like: data TestGroup m a t = ..., and would be much more awkward to compose
04:47:21 <barrucadu> Or I'd have to use ExistentialQuantification to hide the type variables
04:48:45 <hatds> saurabhnanda: there's (I think) two problems with that. 'Command p' in your type signature has an implicit 'forall p'.  You usually wouldn't return a value with a type like that unless one of the inputs to the function also invovles 'p', and in any case this function doesn't return such a value for any type 'p' that the user may instantiate with it.
04:50:59 <hatds> saurabhnanda: the second problem is that DataKinds can be a little funny with type variables.  I haven't used DataKinds recently enough to remember exactly, but I remember problems trying to have type constructors or type variables work for both regular types and the lifted types
04:51:17 <liste> erbse: I don't think the original example code is correct, see https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:catch
04:53:30 <erbse> liste: thanks! compile now
04:55:38 <sena_kun> kostja, why not just use https://hackage.haskell.org/package/conduit-1.2.6.1/docs/Data-Conduit-List.html#v:filter ?
04:58:39 <erbse> liste: can I get the message from exception without use `show`? show will added program name before the message, for I google everybody use show
05:01:06 <liste> erbse: there's also displayException
05:01:32 <liste> :t displayException
05:01:33 <lambdabot> Exception e => e -> String
05:09:59 <saurabhnanda> hatds: where can I read more about DataKinds? Because if I don't include that pragma, this code refuses to compile.
05:10:06 * hackagebot aeson-compat 0.3.1.0 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.1.0 (phadej)
05:11:53 <saurabhnanda> even this is not working (obviously) -- authorizeUser :: (Permission p) => String -> String -> Command p
05:12:40 <hatds> saurabhnanda: ghc user manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
05:13:21 <hatds> saurabhnanda: "String -> String -> Command Permission" didn't work?
05:14:11 <saurabhnanda> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html is too meta for me to understand right now.
05:14:22 <saurabhnanda> hatds: nope that didn't work.
05:15:46 <saurabhnanda> The first argument of ‚ÄòCommand‚Äô should have kind ‚ÄòPermission‚Äô, but ‚ÄòPermission‚Äô has kind ‚Äò*‚Äô
05:16:28 <saurabhnanda> hatds: in this code, which symbol has the "kind" Permission. I tried :k Authorized, but it didn't work. :t Authorized, however does say that it's TYPE is Permission, but that's the TYPE, not the KIND.
05:16:53 <exio4> where's the code?
05:17:01 <saurabhnanda> type, kind. Tomato, Toh-mah-to
05:17:05 <hatds> saurabhnanda: what about "String -> String -> Command 'Permission" with the single tick before the P?
05:17:07 <exio4> I would like to see the datatype definition, you might need an '
05:17:18 <saurabhnanda> let me try the apostrophe
05:18:41 <erbse> can I print a message in function without changing it's return type to IO? like foo :: Int; foo = do { putStrLn "foo called"; 0 }
05:19:11 <liste> erbse: not really. you can trace it for debugging but not for real output
05:20:07 <saurabhnanda> exio4: even that's not working -- http://lpaste.net/151955
05:20:31 <hatds> saurabhnanda: thinking more deeply about this example, I don't think GADTs are really solving any of ideas you were originally getting at.  A GADT with a phantom parameter whose type is essentially an enumeration doesn't have any extra expressive power over a regular algebraic datatype.  I think the answer to your SO question was a knee jerk bias against partial functions.  But a GADT isn't...
05:20:32 <hatds> ...always the answer.
05:20:52 <saurabhnanda> hatds: the single apostrophe doesn't seem to be working -- http://lpaste.net/151955
05:21:01 <exio4> saurabhnanda: you want a "polymorphic" a there
05:21:02 <liste> erbse: Debug.Trace.trace :: String -> a -> a, it prints its first argument whenever it's evaluated
05:21:07 <erbse> liste: thanks! trace work
05:21:21 <erbse> I can use trace("foo called", 0)
05:21:24 <saurabhnanda> hatds: exio4: I'm lost
05:22:07 <merijn> saurabhnanda: Do you have DataKinds enabled?
05:22:13 <saurabhnanda> exio4: where do I want a polymorphic 'a'?
05:22:19 <saurabhnanda> merijn: yep, it's enabled.
05:22:31 <saurabhnanda> merijn: take a look at http://lpaste.net/151955
05:22:31 <exio4> saurabhnanda: if you really want to return both a UnauthorizedCommand and an AuthorizedCommand, you'll need to wrap the type parameter in an existential
05:23:25 <exio4> saurabhnanda: fwiw, the code you have in main doesn't make much sense, and it is partial
05:23:29 <merijn> saurabhnanda: oh
05:23:39 <merijn> saurabhnanda: Line 11, authorizeUser :: String -> String -> Command 'Permission this doesn't make any sense
05:23:52 <saurabhnanda> exio4: I can actually "solve" the problem by using an Either return-type and call it a day. Compile with -Wall where it will tell me about this simple non-exhaustive pattern match. HOWEVER, then I'm not sure what I can use ADTs really for. AND i'm not sure what all this Haskell type magic is really bringing to the table.
05:24:28 <merijn> saurabhnanda: You're saying that "Command :: Permission -> *", so when using "Command" in a type, like on line 11, you have to give it a type with kind "Permission" as argument
05:24:50 <merijn> saurabhnanda: There are only two types with kind "Permission" (i.e. Authorized and Unauthorized)
05:25:07 <merijn> saurabhnanda: The problem you have is that you're trying to, conditionally return a value of a different type
05:25:20 <saurabhnanda> exio4:  please take a look at the original SO question at http://lpaste.net/151955 -- the code in main is not important really. the fact that GHC is not complaining about obviously incorrect code paths is the main problem I have.
05:25:38 <merijn> i.e. authorizeUser can return either "Command 'Authorized", or "Command 'Unauthorized", but this is nonsensical in haskell
05:25:38 <hatds> saurabhnanda: the power of GADTs doesn't come from the datatype you have here.  IMHO, there aren't any interesting functions you can write with this GADT, because it is essentially isomorphic to the record datatype.  GADTs have power when the type variable can be types that have interesting values.  Again, I think you were mislead with that SO answer.
05:26:11 <merijn> saurabhnanda: The short result of this being: "This will never work like you're currently wanting it to work"
05:26:25 <merijn> saurabhnanda: You'd have to existentially hide the Permission parameter
05:26:27 <saurabhnanda> merijn: my original SO question, or the GADT approach?
05:26:33 <exio4> saurabhnanda: that's a paste, not a SO question :)
05:26:38 <merijn> The current GADT approach, I haven't seen the SO question
05:26:48 <saurabhnanda> merijn: http://stackoverflow.com/questions/35266143/ghc-compiler-not-complaining-about-incorrect-code-paths/35268192
05:28:15 <merijn> saurabhnanda: I've done something similar to this (unfortunately the code isn't public yet), and while you COULD do something similar to what you want (i.e. statically validating against invalid code paths), it's not obvious that this is worth the amount of effort and restructuring you'll need to do
05:29:27 <merijn> saurabhnanda: What you want to do really requires dependent types (types depending on values), which is not something GHC supports. There's all sorts of work going into faking dependent types, but there's a reason the paper about that is called "Hasochism", it's not very fun to do...
05:29:39 <exio4> saurabhnanda: fwiw, think of this situation (which may make it clearer), command has to know the type of the parameter at compile, it will only typecheck iff it is an Authorized command, yet, the function might return an Authorized or an Unauthorized Command
05:30:08 <exio4> at compile-time*
05:30:31 <merijn> saurabhnanda: If you're a bit comfortable with Haskell already you might wanna have a look at Idris, which is a dependently typed language aimed at haskell programmers, doing this should be fairly straightforward and simple there
05:30:35 <merijn> http://www.idris-lang.org/
05:31:09 <merijn> See, for example, this type safe printf: https://www.youtube.com/watch?v=fVBck2Zngjo
05:31:32 <saurabhnanda> merijn: hmm, I looked at Idris briefly, but the whole purpose of trying out Haskell is to see if we can use it in production code and whether it brings some safety to our code-writing process. Idris is too immature to try right now, IMO.
05:32:12 <maerwald> it is and it cannot compete even remotely with the library ecosystem of haskell
05:32:20 <exio4> I'd stay away from record in this situation, as it'll lead to partial functions everywhere
05:33:08 <saurabhnanda> exio4: what do you mean when you say "partial functions" ?
05:33:17 <merijn> saurabhnanda: Agreed, but I'd say that doing what you want in haskell, while possible, will probably be about as immature/complicated as Idris is
05:33:22 <exio4> saurabhnanda: if you have things which should only take "AuthorizedCommands", you might want to refactor some stuff and make Command = Unauthorized | Authorized AuthorizedCommand
05:33:22 <merijn> exio4: It's actually not partial
05:33:34 <merijn> I think
05:33:44 <exio4> merijn: it is in the original code (I am assuming he won't use GADTs)
05:33:47 <saurabhnanda> exio4:  and how can I stay away from record? We're going to use Haskell to talk to the DB very often (with large tables). Not having records is going to be VERY painful.
05:34:14 <merijn> saurabhnanda: He doesn't mean "don't use records", but "don't use records for datatypes with multiple constructors"
05:34:15 <exio4> saurabhnanda: one sec.
05:34:40 <merijn> "data Foo = Foo | Bar { myField :: Int }" this gives "myField :: Foo -> Int" and "myField Foo" will crash
05:35:35 <lpaste> EXio4 pasted ‚ÄúAuth ‚Äù at http://lpaste.net/151957
05:35:46 <exio4> saurabhnanda: something closer to this ^ 
05:36:29 <saurabhnanda> merijn: I understand it's not a good idea to do that because it might result in run-time errors, but I'm VERY surprised that Haskell can't complain about it loudly during compile-time itself. Think about introducing new people to Haskell. They're bound to make such mistakes without realising it. The expectation was that, the GHC compiler won't let them shoot themselves in the foot.
05:36:48 * frerich feels left out for not having any opinion on '$' in GHC 8.0
05:37:13 <saurabhnanda> exio4: how does http://lpaste.net/151957 solve the problem?
05:38:26 <merijn> saurabhnanda: It's basically just like using Maybe
05:38:29 <merijn> frerich: Word
05:38:39 <merijn> frerich: Some types are already terrifying nowadays :p
05:38:41 <merijn> :t (.)
05:38:43 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:38:47 <merijn> :t (Control.Category.)
05:38:49 <lambdabot>     Not in scope: data constructor ‚ÄòControl.Category‚Äô
05:38:51 <merijn> eh, whoops
05:38:54 <merijn> :t (Control.Category..)
05:38:55 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
05:39:05 <saurabhnanda> merijn: yup, or like using Either. It forces me to pattern-match to get to the command-record
05:39:10 <exio4> saurabhnanda: you'll have an AuthorizedCommand record which you can pass around for functions which need this information, and you'd have a Command which might be either
05:39:22 <merijn> saurabhnanda: You don't have to pattern match, you can just use the Monad instance of Either?
05:40:00 <merijn> :t (>>=) `asAppliedTo` Right 'c'
05:40:02 <lambdabot> Either a Char -> (Char -> Either a b) -> Either a b
05:40:18 <haskell989> Hi. How can I update inner list of [[a]] with lens? For example [[1,2,3]] replace 1 with 10?
05:40:42 <saurabhnanda> merijn: exio4 let me try this approach
05:41:21 <merijn> saurabhnanda: The most straightforward approach I would use in your case is the Either monad and/or "EitherT MyError IO" (i.e. Either transformer over IO if you wanna do IO)
05:42:12 <merijn> "getCommand :: EitherT AuthorizationError IO Command" and then you can just do "do { cmd <- getCommand; {- stuff with cmd here -} }"
05:42:34 <merijn> saurabhnanda: And the monad instance will short-circuit as soon as anything returns "Left AuthorizationError"
05:49:02 <pavonia> Design question: If each of my data processors can have a pre- and a postprocessor, what type should be preferred for them: preprocess :: input -> input (with preprocess = id for no preprocessing), or :: Maybe (input -> input)? I can't see any obvious disadvantage of either approach
05:49:56 <bergmark> pavonia: so passing id would be the default for the first? I'd go with that, otherwise you have two ways of doing the same thing, Nothing or Just id
05:50:25 <pavonia> Right, id would be the default
05:52:43 <saurabhnanda> i;m still stuck with the philosophical question of why doesn't GHC complain about such stuff. Right now I'm analyzing every  single line of code that I write, which is why I caught this error. When someone is chasing a deadline and has a lot of code to write, such stuff will get missed. I was expecting the compiler to help out here.
05:53:56 <pavonia> bergmark: Your suggestion actually makes applying the processors a bit easier, so I'll go with this. Thanks
05:54:17 <merijn> pavonia: Sounds like you want "Endo" :)
05:54:30 <pavonia> :t Endo
05:54:31 <lambdabot> (a -> a) -> Endo a
05:54:38 <merijn> pavonia: "newtype Endo a = Endo { appEndo :: a -> a }"
05:54:51 <merijn> Which is a monoid with "mappend = (.)" and "mempty = id"
05:55:37 <pavonia> I think that would make things unnecessarily complicated, as the input and output types are different
05:55:56 <merijn> Anyway, I'd use "id" over "Nothing"
05:57:42 <marrrk> Can I have cabal build run whenever I save a file?
05:58:16 <saurabhnanda> merijn: exio4 your thoughts on my existential/philosophical question?
05:58:25 <saurabhnanda> merijn: exio4 i;m still stuck with the philosophical question of why doesn't GHC complain about such stuff. Right now I'm analyzing every  single line of code that I write, which is why I caught this error. When someone is chasing a deadline and has a lot of code to write, such stuff will get missed. I was expecting the compiler to help out here.
05:58:32 <dcoutts> marr: there are generic unix tools that can monitor files in a dir and re-run any command
05:59:40 <geekosaur> saurabhnanda, because the standard Prelude, defined and mandated by the Haskell standard, is *filled* with partial functions
06:00:12 <geekosaur> there are alternative Preludes that don't use partial functions, and then IIRC you can turn on warning options to catch you writing your own
06:01:17 <saurabhnanda> geekosaur: how is this related to prelude and partial functions?
06:02:43 <geekosaur> maybe I misred scrollback,t hat's what I see you complaining about is partial functions
06:03:13 <geekosaur> if you mean something else then perhaps not require people to digest an hour or so of scrollback to figure out what?
06:03:41 <chelfi> saurabhnanda: I'd say historical reasons
06:05:03 <chelfi> there is too much code (and too many tutorials ?) relying on partial functions to sensibly forbid them (or get rid of them in the prelude) today
06:05:20 <geekosaur> yes, that was the point
06:05:52 <geekosaur> Prelude is not something you can say "oh ignore its existence and require that nobody even think about partial functions by efault" 
06:06:00 <saurabhnanda> chelfi: geekosaur philosophical question -- why doesn't GHC complain about incorrect code paths in http://stackoverflow.com/questions/35266143/ghc-compiler-not-complaining-about-incorrect-code-paths/35268192
06:07:01 <geekosaur> oh, partial record constructors. welome to hell.
06:07:17 <geekosaur> Haskell's record syntax is a wart.
06:07:52 <safrol_> ewwww
06:07:53 <chelfi> saurabhnanda: in this example command is a partial function that you get for free
06:08:04 <nshepperd_> warnings for *defining* partial record accessors could be added, couldn't they?
06:08:09 <nshepperd_> without causing too much noise
06:08:28 <geekosaur> I think it's been discussed but it's not quite as simple as it looks
06:09:16 <jellytux> exit
06:09:17 <geekosaur> it may however come along with a full implementation of OverloadedRecordFields
06:09:21 <nshepperd_> or, you could just ban record syntax in multi-constructor types entirely...
06:09:45 <saurabhnanda> okay, I'm getting lost here. What exactly is partial? Everything is complete. No types are ill-defined. Everything is well-defined. What's the definition of "partial" in the haskell world?
06:09:47 <liste> is -Wall enough to show all warnings?
06:10:14 <nshepperd_> saurabhnanda: partial functions are those that return an error for some non-error inputs
06:10:19 <geekosaur> saurabhnanda, id you read any responses to that stackoverflow page?
06:10:19 <saurabhnanda> liste: -Wall doesn't show this as a warning in my case. That's exactly what I want. Help from the compiler to prevent "shot-myself-in-the-foot" syndrome.
06:10:31 <nshepperd_> as opposed to being 'total', defined on every value of its domain
06:11:16 <nshepperd_> oh, functions that loop forever on some inputs are defined as 'partial' too
06:11:35 <nshepperd_> i think
06:11:42 <saurabhnanda> geekosaur: I did. Am I missing something already explained on SO? I thought GADTs was the answer and tried them out, but they don't seem to achieve anything in this particular context, except increasing complexity.
06:12:08 <geekosaur> yet you claim everything is complete and nothing is partial and partial makes no sense
06:12:19 <geekosaur> data Command = UnauthorizedCommand | Command {command :: String, userId :: String}
06:12:19 <chelfi> saurabhnanda: if you define data X = A | X {foo :: Int} for instance, you get a function foo :: X -> Int whose definition is roughly equivalent to foo ( X { foo = x } ) = x
06:13:01 <adamCS> Suppose I have a sum type, S, and all of the fields of all of it's constructors are instances of Default (or I know how to initialize them some other way).  Given a value of type S, is there a way to make a list of values of type S, each one constructed using a different constructor of S?
06:13:14 <geekosaur> `command` and `userI` cannot produce any value at all in the UnauthorizedCommand case, because that is what your dta declaration tells it to do
06:13:20 <chelfi> foo definitely is partial, and I guess you should avoid using it altogether (for instance by providing your own accessor myFoo :: X -> Maybe Int)
06:13:28 <adamCS> I've tried GHC.Generics and can't quite get there.  
06:13:47 <nshepperd_> saurabhnanda: IMO the actual solution here is to define 'data Command = UnauthorizedCommand | Command SubCommand' and then define 'data SubCommand = SubCommand {arguments...}'
06:13:50 <saurabhnanda> chelfi: it's partial BECAUSE it's not defined for all "value types" (using the right term?) of X?
06:14:33 <geekosaur> partial here exactly means that if the value is UnauthorizedCommand, it is not possible for either command or userId to produce any value
06:14:43 <saurabhnanda> nshepperd_: that's what exio4 and merijn were suggesting, but that's not very different from using an Either AuthorizedCommand UnauthorizedCommand
06:15:25 <nshepperd_> saurabhnanda: that way you are first forced to case match on Command and only then can you try to use the argument accessors
06:15:27 <chelfi> saurabhnanda: exactly
06:15:40 <geekosaur> I would probably use data Command = Command (Maybe CommandData)
06:16:02 <geekosaur> and define the record separately as CommandData, and Command Nothing replaces your UnauthorizedCommand
06:17:12 <chelfi> based on your use case you may also totally hide the fact that it is implemented as a record, hide it in another module, and export safer accessors
06:18:00 <nshepperd_> I /am/ surprised that ghc can't complain about partial record accessors
06:18:02 <chelfi> but I guess it is a bit unsatisfactory ans you may have more success with those other approaches
06:18:05 <nshepperd_> they are certainly a code smell
06:18:36 <geekosaur> iirc there are ghc devs who would love to abolish them completely
06:18:56 <liste> the compiler can't catch all partial functions, but partial record accessors it certainly could
06:21:27 <saurabhnanda> geekosaur: got it, understood the definition of partial. Now the philosophical question -- isn't it easy to detect and compile time and complain about it?
06:22:10 <geekosaur> that is not a philosophical question, it is a question of technical implementation and my understanding that it is *not* easy
06:22:25 <geekosaur> at least not if you intend to retain compatibility with the language standard
06:22:59 <geekosaur> there's an increasing number of people who seem to feel that the standard should be completely abrogated
06:23:25 <nshepperd_> does the standard forbid adding warnings?
06:23:26 <geekosaur> (ghc has already lost compatibility in several areas as it is)
06:23:41 <geekosaur> no, but the way it says things should work makes it harder to add them, iirc
06:24:42 <geekosaur> conversely, rewriting the way they are implemented so that warnings can be done properly means introducing edge cases where things don't behave quite according to the Report
06:25:29 <chelfi> I guess a new iteration on the standard would be welcome ?
06:25:49 <geekosaur> this may end up happening anyway --- I mentioned OverloadedRecordFields for a reason, it's touching *all* of this --- but then you'd presumably need to turn on that extension
06:25:56 <nshepperd_> well, you could always add it to hlint
06:25:56 <geekosaur> people keep trying to reboot the standards process
06:27:57 <geekosaur> I don't think it's ever going to happen at this point. given that ghc has already lost compatibility in several areas, at some point I expect ghc to just make a clean break and declare itself the definition of Haskell
06:31:32 <chelfi> having proper standards is a nice selling point though
06:32:06 <chelfi> I mean, I wouldn't mind terribly as long as this "GHC Haskell" is not implementation-defined
06:32:26 <geekosaur> de facto, it has been for years
06:32:37 <geekosaur> I mean, how many other implementations exist?
06:33:10 <geekosaur> and the ones that used to generally had trouble even implementing the full Report, much less many ghc extensions
06:33:32 <geekosaur> (for example, shortcomings in typeclasses)
06:36:15 <chelfi> of course, but even if nobody actually provides another implementation, having a well defined, stable definition is still valuable
06:39:48 <nshepperd_> I must admit I really can't imagine what the difficulty could be, given you can almost pick this up with a regex
06:41:50 <saurabhnanda> hmm, so basically I've hit a sore point
06:42:23 <chelfi> saurabhnanda: yes, a well known one
06:42:32 <saurabhnanda> partial functions wrt records *maybe* easy to detect and complain about, but there's some bureaucracy involved? or is it technically hard to detect these kinds of partial functions? 
06:43:13 <saurabhnanda> any language extension, pragma, library, compiler argument, other haskell-fu that can help me with this? or even a linter?
06:43:43 <saurabhnanda> the thought being, if the main reason for switching to haskell is compile-time checks and safety, it better to a bloody good job of it.
06:45:14 * hackagebot gore-and-ash-network 1.2.0.0 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.2.0.0 (NCrashed)
06:46:23 <saurabhnanda> the other philosophical debate I keep having with myself is whether having errors is a great idea in Haskell.
06:46:41 <exio4> saurabhnanda: which kind of errors?
06:47:25 <arw> saurabhnanda: there is always a class of problems you can only avoid by discipline and reviews, not with the language.
06:47:27 <saurabhnanda> exio4: when I started out, I ran into some standard functions which were throwing errors for regular stuff. For example, read "a" :: Int, IIRC. 
06:47:48 <arw> saurabhnanda: e.g. you could have haskell programs that are stringly-typed throughout and the compiler won't ever complain
06:48:25 <exio4> saurabhnanda: there's quite a bunch of Prelude which is quite crashy, we do have "ways around it", though. read => readMaybe, head/tail => pattern matching, etc
06:48:29 <exio4> @type Text.Read.readMaybe
06:48:31 <lambdabot> Read a => String -> Maybe a
06:48:33 <saurabhnanda> exio4: another one, file-not-found error. When doing file based IO, it's actually a very common case that I would want the compiler to force me to think about while writing the program.
06:49:39 <arw> saurabhnanda: in those cases you usually want to limit yourself to using stuff that returns Maybe or Either something.
06:49:40 <saurabhnanda> exio4: i finally found a better way of doing it, but in a even a 6 member team, not everyone is going to be that careful. On top of that, haddock does not document the errors that a function may throw. You "discover" them during runtime.
06:50:32 <saurabhnanda> arw: exactly. I loved the concept of Maybe & Either in Haskell. Why isn't it MANDATORY to use that for error conditions? Why are library functions throwing errors?
06:50:33 <arw> saurabhnanda: but yes, you are right, exceptions/errors are a problem with haskell and some people (me included) would prefer a language without them
06:50:44 <exio4> saurabhnanda: yeah, unchecked IO exceptions are quite.. a thing on its own
06:51:03 <exio4> arw: well, I'd prefer checked exceptions for IO :P 
06:51:23 <saurabhnanda> exio4: practically Maybe/Either is another way of doing checked exceptions.
06:52:15 <geekosaur> saurabhnanda, I've actually been complaining about those being exceptions instead of Either for several years :(
06:52:18 <exio4> saurabhnanda: quite limited and verbose way of doing checked exceptions :) 
06:52:40 <exio4> saurabhnanda: anyway, you might find `try` useful for now, too
06:52:53 <exio4> @type Control.Exception.try
06:52:54 <lambdabot> Exception e => IO a -> IO (Either e a)
06:54:38 <saurabhnanda> exio4: yup, already started doing that. But most packages don't document the errors that a function will throw.
06:55:06 <exio4> yeah, it's a sad situation :/ 
06:59:18 <saurabhnanda> exio4: can't the compiler tell us what possible errors a function may throw?
06:59:36 <saurabhnanda> exio4: isn't there a compiler switch which may fill-in in the absence of good haddocks?
06:59:48 <saurabhnanda> eg. -Wwarn-unhandled-errors or something like that
07:00:04 <safrol_> still composing...
07:00:14 * hackagebot funcons-tools 0.1.0.0 - A modular interpreter for executing funcons  https://hackage.haskell.org/package/funcons-tools-0.1.0.0 (ltvanbinsbergen)
07:00:26 <exio4> saurabhnanda: there isn't a compiler switch for this, and it'd be quite a hassle to do without language changes
07:15:13 <missingno_> Is this the right place to come to when having problems with stack?
07:15:42 <Cale> missingno_: It's not a wrong place... there might be a stack-specific channel but I'm not sure.
07:16:16 <Cale> It doesn't look like there is to me...
07:16:26 <missingno_> I just try it here then
07:17:04 <frerich> It appears there is #haskell-stack
07:19:04 <missingno_> I'm still new to Haskell and I currently try to install structured-haskell-mode via stack, but when I try to install it I get the following error: http://pastebin.com/FZf4c9G2
07:19:26 <missingno_> Is there a way to install an older version of a package locally with stack?
07:20:03 <missingno_> google hasnt helped me so far
07:23:19 <adamCS> missingno_: You could try the "packages" section.  You can just point it to a directory or a github repo. 
07:23:38 <adamCS> (packages section of the "stack.yaml" file)
07:24:09 <wraithm> Yeah, the packages section of stack.yaml is probably the right place to start
07:37:03 <marrrk> What can I do about this: cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.5.0, now Cabal-1.22.4.0). ?
07:37:31 <marrrk> If I do cabal configure --enable-tests; and then try again I get the same error
07:38:43 <mpickering> marrrk: Try "cabal clean"?
07:38:52 <marrrk> I just tried that.
07:38:57 <marrrk> I get the same error.
07:39:14 <marrrk> I am more or less blindly following this: https://github.com/NICTA/course#running-the-tests
07:39:20 <mpickering> so you run "cabal configure" and then?
07:39:25 <mpickering> cabal test?
07:40:10 <marrrk> I run what's on that page
07:41:14 <mpickering> the configure completes successfully?
07:43:18 <marrrk> yes
07:43:23 <marrrk> the explicit doctest version works
07:43:25 <dcoutts> marrrk: possibly workaround, ghc-pkg unregister Cabal-1.22.5.0 and retry
07:43:29 <marrrk> maybe I'll just use that
07:43:37 <marrrk> Okay I will try that
07:45:16 * hackagebot geoip2 0.2.0.0 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.2.0.0 (ondrap)
07:45:18 * hackagebot Hoed 0.3.5 - Lightweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.5 (faddegon)
07:46:02 <Wizek> Does anyone have some good examples on how to use Either for encoding error states? I'm especially interested in how one would go about boubleing up unhandled Left cases from lower level functions to higher level functions to possibly handle. Would that mean that I need to define error data types for each function that returns an Either?
07:48:06 <crough> Wizek: I'd look into Mtl and MonadError
07:48:25 <crough> It's a typeclass that sends Left values to wherever they can be handled
07:48:35 <crough> Mtl is a useful beast
07:48:39 <marrrk> dcoutts: I did that. Reran everything. Now I get this: cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.7.0, now Cabal-1.22.4.0)
07:50:16 * hackagebot gore-and-ash-demo 1.1.0.0 - Demonstration game for Gore&Ash game engine  https://hackage.haskell.org/package/gore-and-ash-demo-1.1.0.0 (NCrashed)
07:50:25 <dcoutts> marrrk: you've got an interesting environment :-). So yes, there's a bug here I think where test uses something that's not consistent with configure. The workaround is to use the same one. Either by making there be no other choices (which is why I suggested removing the other one from the env) or we can tell it to use a specific one
07:50:52 <marrrk> I don't want the old stuff
07:51:09 <dcoutts> marrrk: but you've apparently got several versions installed. You can either get rid of them, or if you want those then there's another way to tell cabal to use a specific library version for compiling the Setup.hs scripts
07:51:27 <dcoutts> marrrk: ok, ghc-pkg list Cabal
07:51:51 <marrrk>    Cabal-1.22.7.0
07:51:55 <marrrk> Oh
07:51:58 <dcoutts> marrrk: and if you look at cabal --version, and see what version of the lib it reports (almost certainly Cabal-1.22.4.0)
07:51:59 <marrrk>  /usr/local/Cellar/ghc/7.10.3a/lib/ghc-7.10.3/package.conf.d
07:51:59 <marrrk>  /Users/mark/.ghc/x86_64-darwin-7.10.3/package.conf.d
07:52:00 <marrrk>    Cabal-1.22.7.0
07:52:01 <marrrk> I mean
07:52:27 <dcoutts> marrrk: then you'll have fewest issues if the version there matches the only one available in ghc-pkg list Cabal
07:53:10 <marrrk> It says this
07:53:11 <marrrk> cabal-install version 1.22.6.0
07:53:11 <marrrk> using version 1.22.4.0 of the Cabal library
07:53:26 <marrrk> So what do I have to do now?
07:53:41 <safrol_> good one marrrk 
07:53:49 <safrol_> whoops
07:53:56 <safrol_> i should probabbly stop
07:54:06 <dcoutts> marrrk: ok, so currently the only lib version installed is 1.22.7.0, so either rebuild cabal-install against the new one, or go and install the older Cabal lib
07:55:26 <marrrk> I thought 1.22.7.0 was the new one.
07:55:34 <dcoutts> most of the time this isn't vital, but there's a corner case here with custom Setup.hs scripts (that your NICTA package uses), and test which for some reason is using the wrong thing
07:56:23 <marrrk> hmm
07:56:26 <dcoutts> marrrk: right it is, so you can rebuild cabal-install against that version of the Cabal lib. Or, cabal install Cabal-1.22.4.0
07:56:34 <dcoutts> and remove the new one. Pick one.
07:56:48 <marrrk> Or I guess I can just run the doctest command?
07:57:01 <marrrk> And just keep the new version.
07:58:09 <Wizek> crough, So you would recommend against using Either? Do you have some examples showcasing error handling with Mtl and/or MonadError?
08:04:16 <csd_> i'm not groking the wiki explanation: why is seq important?
08:04:50 <EvanR> its a trap door to let you control somewhat when expressions are evaluated
08:04:58 <csd_> because hypothetically some lazy x might be taking up a lot of space when unevaluated and so hence to reduce that cost?
08:05:24 <EvanR> thats one reason
08:05:43 <csd_> why else would you want to use it
08:05:51 <csd_> controlling when IO happens?
08:06:07 <EvanR> if youre using unsafePerformIO, yeah that would do it
08:06:18 <EvanR> but thats a corner case
08:06:42 <EvanR> csd_: another reason is that you want a possibly-crashing expression to crash now instead of later
08:07:05 <csd_> ah
08:07:12 <EvanR> so all of these issues are very practical things, not really math things ;)
08:07:17 <srhb> csd_: Are you just talking about IO and seq, or seq anything? If the latter, perhaps see the canonical foldl (+) explanation
08:07:40 <EvanR> yes foldl is a base where youre trying to reduce memory and thus time 
08:07:44 <EvanR> a case*
08:07:49 <csd_> and what if in seq x y that x is Just bottom; does that crash immediately ?
08:07:58 <EvanR> if y is evaluated, yes
08:08:03 <EvanR> oh Just bottom
08:08:04 <EvanR> no
08:08:37 <csd_> i find the lifted / unlifted bottom thing confusing also
08:09:01 <csd_> srhb: is the foldl explanation when i mentioned above?
08:09:08 <srhb> csd_: seq only evaluates its first argument up to WHNF
08:09:24 <srhb> csd_: Hmm, I don't see it.
08:10:10 <ski> afaiui, `seq x y' doesn't have to reduce `x' to WHNF before `y'. afaiui, `x' may even be reduced after this `seq' call has been reduced, as long as its eventually reduced
08:10:45 <EvanR> csd_: think of constructor expressions like Just bottom as being a box. in the box might be a value or bottom
08:10:53 <srhb> csd_: https://wiki.haskell.org/Stack_overflow -- this one has some bits.
08:12:00 <EvanR> csd_: you can evaluate an expression enough to get to a box, but stop there and dont try to reduce whats in the box to get to the next box
08:12:31 <EvanR> thats what allows streaming and cyclic data structures
08:12:38 <srhb> ski: I suppose it might be HNF in fact...
08:12:40 <csd_> EvanR: you mean that re: laziness? evaluate what you need only ?
08:13:06 <EvanR> csd_: well im just talking about not necessarily evaluating all of it
08:13:31 <EvanR> its kind of orthogonal to strategy of evaluating function applications vs their arguments
08:14:15 <EvanR> csd_: if you do like many languages and construct the entire data structure immediately, then some kinds of structures would crash or freeze up because they are too bi
08:14:18 <EvanR> g
08:14:30 <csd_> sure
08:14:47 <csd_> i think we're saying the same thing
08:15:29 <EvanR> turning to the function application thing, lazy evaluation lets you do computation without necessarily computing some arguments
08:15:29 <crough> Wizek: Either is actually an instance of MonadError
08:15:34 <EvanR> that can be an optimization
08:15:50 <crough> Wizek: You just use `throwError` as a polymorphic version of Left, and you can handle it the same, but it works in any error algebra
08:16:03 <EvanR> "compute only what you need"
08:16:28 <csd_> EvanR: and so when a a History of Haskell talks about strictness analyzers, and that seq was introduced to aid identifying strict functions, what does that mean
08:16:55 <csd_> the paper mentions that certain functions were mostly strict but had to be classed as non-strict ultimately
08:17:03 <EvanR> strictness is talking about whether necessarily f _|_ = _|_
08:17:16 <EvanR> if an optimization would change that fact about a function then you cant do it
08:17:50 <EvanR> even if it would speed up performance on non-bottom
08:19:11 <csd_> ok i think i get it. by using seq to fail fast, you might then be able to write your function such that it is optimizable
08:19:17 <ski> "optimizing" a non-terminating program to terminate could be argued to be undesirable, in that one implementation might apply that modification without you being aware of it, while another implementation (or perhaps just the same implementation, but compiling on a different platform) would have the program hang (or error out)
08:19:22 <csd_> bc you wouldnt be violating that strictness invariant
08:20:07 <ski> (obviously an implementation automatically changing a terminating program to a non-terminating (or aborting one) would be undesirable)
08:20:25 <EvanR> csd_: i guess so... if f is strict, then seq x (f x) is definitely strict
08:20:46 <ski> @src $!
08:20:46 <lambdabot> f $! x = x `seq` f x
08:20:55 <csd_> ski: whether a program crashes or loops forever, isnt that still bottom in the compiler's mind? 
08:21:06 <ski> csd_ : it is
08:21:49 <csd_> so from an optimizer's perspective you wouldnt be doing anything undesirable, no? f bottom still = bottom
08:23:27 <EvanR> if you are definitely going to use the argument then you want it to optimize and evaluate it (to WHNF) eagerly
08:23:35 <EvanR> to reduce memory
08:23:49 <EvanR> aiui this is mostly automatic
08:24:17 <csd_> i imagine that in practice that it's not necessary to understand things in this much detail
08:24:46 <EvanR> not until you start profiling and see something you dont like
08:26:36 <EvanR> csd_: until that point, you can pretend that everything is lazy, even if IRL it wont be ;)
08:26:47 <csd_> ok
08:26:51 <csd_> thank you all
08:30:04 <csd_> @src seq
08:30:04 <lambdabot> Source not found. I feel much better now.
08:30:32 <ski> it's a primitive
08:30:33 <csd_> oh primop
08:30:33 <EvanR> its a primitive
08:30:55 <ski> if you assume the strict pattern extension, you can imagine it being defined as
08:30:59 <ski>   seq !_ x = x
08:31:26 <ski> (but then the strict pattern extension could be explained in terms of translating code using it into code calling `seq')
08:31:28 <Cale> Another way to put it is that  seq _|_ y = _|_, and seq x y = y otherwise.
08:32:06 <EvanR> i have a question about ! in where blocks. i notice that i can put !x = ...'s in a where, and they will all be eagerly evaluated, but im not sure what order
08:32:12 <EvanR> is there a definite ordering?
08:32:20 <ski> yes, that's a mathematical statement (specification) about its meaning (denotation). (but obviously it doesn't suffice as a Haskell implementation)
08:32:27 <csd_> what does this mean: In particular, seq is not de- finable in the lambda calculus, and is the only way to distinguish \x -> ‚ä• from ‚ä• (since seq ‚ä• 0 goes into a loop, while seq (\x -> ‚ä•) 0 does not)‚Äîa distinction that Jon Fairbairn, in particular, was dead set against making
08:32:40 <ski> EvanR : i wouldn't assume there is
08:33:04 <csd_> shouldnt seq ‚ä• 0 = bottom?
08:33:17 <csd_> i guess a loop is bottom, but still, why the loop
08:33:28 <shapr> lorin_edwin: oh hai! Are you learning Haskell?
08:33:32 <EvanR> thats what _|_ is
08:33:39 <EvanR> non termination
08:33:45 <ski> (seeing how `pseq' is what you want if you want ordering guarantees. and seeing how, afaiui, reducing `seq x y' doesn't require reducing `x' before reducing away the `seq' call)
08:33:56 <csd_> i thought it was exception | loop
08:34:07 <EvanR> lambda calculus doesnt have exceptions or errors
08:34:19 <EvanR> or power going out
08:34:20 <EvanR> etc
08:34:21 <kadoban> csd_: It's probably the most obvious (or the only available) ‚ä• available in whatever language was being discussed?
08:35:03 <EvanR> csd_: its all considered the same thing
08:35:10 <ski> csd_ : iirc, in early versions of Haskell, there was an `Eval' class, with `seq' as a method
08:35:39 <ski> (and i assume function types weren't instances of that class)
08:36:41 <lorin_edwin> shapr: yep, you guys might win over another LISPer...
08:37:25 <shapr> lorin_edwin: I'd say instead to learn to love both :-)
08:37:55 * ski . o O ( restartable conditions )
08:38:05 <lorin_edwin> shapr: And, of course, I do!
08:38:27 <shapr> I like lisp for the fact that its syntax is its parse tree, and that makes macros elegant
08:39:01 <shapr> I like Haskell for purity and laziness and typeclasses and more
08:39:02 <EvanR> "syntax = parse tree" confused me very much while learning lisp, because later i found out thats not accurate :(
08:39:21 <EvanR> lisp was full of hyperbolic explanations
08:40:00 <lorin_edwin> I enjoy LISP because it's a challenge to be succinct. I am usually hyperbolic.
08:40:19 <lorin_edwin> I expect similar with haskell
08:40:23 <nitrix> I'm going to propose a strange thing, but would there be an alternative (usable syntax) to declare a type `Maybe a = Just a | Nothing` where the left part of the equality for the definition is simply `Maybe`, yet not change effect? some kind of `Maybe = \a -> Just a | Nothing` ?
08:40:58 <nitrix> Is that even remotely close to something that exists, even if that sounds crazy?
08:41:13 <shapr> lorin_edwin: My Haskell code usually starts out complicated and confused, but quickly gets closer to elegant, I'm curious to see how things work for you as you're learning
08:41:32 <ski> nitrix : do you want `Just a | Nothing' as a first-class type expression ? also `\a -> Just a | Nothing' ? or perhaps just type lambdas like `\a -> IO (Maybe a)' ?
08:41:39 <EvanR> data Maybe = forall a . Just a | Nothing
08:41:57 <ski> EvanR : that's something different :)
08:42:06 <nitrix> ski: I think that's where I'm headed. I've never seen anything like it, but I think I want first-class types, yes.
08:42:16 <ski> nitrix : which alternative(s) ?
08:42:19 <nitrix> ski: Or type lambdasm yea!
08:42:26 <nitrix> lambdas*
08:42:45 <ski> alas, unifying lambdas is undecidable in general
08:43:17 <ski> (lambdaProlog does a subset of that, called L-lambda unification, iirc)
08:44:05 <nitrix> ski: My goal is to get the same type system as haskell within a concatenative language with a very strict syntax.
08:44:10 <lorin_edwin> shapr: exactly. That works better for me than simple --> gigantic ball of knots (which describes my attempts at java, etc -- no offense to java, of course) 
08:44:24 <ski> in Agda1, you could type `Maybe :: * -> * = \a -> data {Just a; Nothing}', i think
08:44:41 <nitrix> ski: foo = ... is a function declaration, Foo = ... is a type declaration. I want to keep it consistent with no arguments, but obvious, I don't want to restrict myself to non-polymorphic types.
08:45:03 <shapr> lorin_edwin: ah, I've had plenty of experience with Java, would rather not do that again
08:45:20 <nitrix> ski: For functions, I can easily write `foo = \a b -> ...` and get the named arguments; with the type declaration, I'm lost to how it'd work.
08:46:07 <ski> nitrix : no pattern-matching like `: nil length = 0 | cons length = drop length 1 + ;' ?
08:46:59 <lorin_edwin> EvanR: point taken, the #lisp is going way existential at the moment...
08:47:09 <nitrix> ski: No pattern matching. Value constructors would generate value destructors where you need to provide a handler function for each types in your sum type.
08:47:38 <nitrix> ski: Kinda like Adga / Idris I think? don't remember which one does it.
08:47:54 <ski> Agda has pattern-matching
08:47:57 <EvanR> lorin_edwin: oh jeez
08:48:46 <infinity0> is there a BinaryMonad or something for doing binary operations on elements of monads
08:49:11 <nitrix> Maybe :: Maybe a -> (Just a -> b) -> (Nothing -> b) -> b
08:49:20 <nitrix> ski: Well not the best example, but it's the idea for now.
08:49:46 <kadoban> :t liftA2 -- this, infinity0 ?
08:49:47 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:50:00 <infinity0> kadoban: ah that sounds like what i needed, thanks!
08:50:43 <safrol_> spacemacs + ?
08:51:10 <ski> nitrix : i assume like a single constructor peeling, rather than a fold/cata
08:51:39 <kadoban> infinity0: For the general case, you should look at Applicative itself, liftA2 is kind of a special case of the  a <$> b <*> c <*> d -- pattern
08:52:10 <infinity0> will do, thanks
08:53:00 <ski> nitrix : hm, so you allow naming arguments at all ?
08:54:37 <nitrix> ski: Since the language is postfix (RPN), function application is equivalent to composition. There's a continuation passed (the stack).
08:54:55 <nitrix> ski: Arguments are typically not named in concatenative languages, but it's nice to have so I'm allowing lambdas.
08:55:15 <ski> (actually, imho, postfix/RPN is different from concatenative)
08:55:39 <nitrix> Well, this one is entirely concatenative.
08:55:52 <ski> nitrix : if it wasn't clear, the pattern-matching example above was assuming only a concatenative syntax
08:56:00 <nitrix> right
08:56:29 <nitrix> Honestly, I kind of like this: Maybe :: * -> * = \a -> data {Just a; Nothing}
08:56:52 <nitrix> Is the kind annotation necessary?
08:57:03 <ski> (so the `cons length = ...' means that if you have `push-my-list push-my-element cons length', you can replace this by `push-my-list push-my-element ...')
08:58:04 <ski> nitrix : well, Agda1 was (also) dependently typed
09:00:14 <ski> for a regular recursive type, they used `List :: * -> * = \a -> data {Nil; Cons a _}', `_' here being used as a placeholder for the recursive type itself
09:01:27 <nitrix> So what feature allows this? First-class types?
09:01:44 <ski> there was an alternative `idata' syntax, that allowed non-regular data something similar to GADTs. iirc, the same was used for non-regular recursive types
09:01:58 <ski> i'm not sure how much first-class these things were
09:03:22 <infinity0> kadoban: oh actually i needed (a -> b -> m c) not just c at the end
09:03:29 <infinity0> sort of like a binary bind i guess
09:03:59 <ski> (anyway, like `Equal :: * -> * -> * = \a -> idata {Refl :: _ a}', which would mean that `Refl' (really `Refl@Equal' iirc) would get type `Equal a a')
09:04:11 <infinity0> i guess i can try to write it myself in general monadic temrs without poking inside
09:05:01 <safrol_> [still bootstrapping]
09:05:08 <EvanR> @djinn Monad m => m a -> m b -> (a -> b -> m c) -> m c
09:05:08 <lambdabot> -- f cannot be realized.
09:05:23 <EvanR> infinity0: seems like liftA2
09:05:52 <infinity0> liftA2 has -> c instead of -> m c
09:05:57 <EvanR> :t liftM2
09:05:58 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:06:05 <EvanR> hrm
09:06:16 <infinity0> i guess i could maybe use liftM2 then join
09:06:32 * ski sometimes calls that `bindM2'
09:08:05 <infinity0> heh, ok i guess it's not common enough to add stdlib, but yeah that's find 2 utils is still better than boilerplate
09:08:59 <ski> @let infixl 4 <*>>; (<*>>) f x = join (ap f x)
09:09:01 <lambdabot>  Defined.
09:09:07 <ski> @type \f a b c d -> f <$> a <*> b <*> c <*>> d
09:09:08 <lambdabot> Monad m => (a4 -> a3 -> a2 -> a1 -> m a) -> m a4 -> m a3 -> m a2 -> m a1 -> m a
09:09:18 <ski> @type \f a b c -> f <$> a <*> b <*>> c
09:09:19 <lambdabot> Monad m => (a3 -> a2 -> a1 -> m a) -> m a3 -> m a2 -> m a1 -> m a
09:09:37 <ski> @type \f a b -> f <$> a <*>> b
09:09:38 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
09:09:48 <ski> infinity0 ^
09:11:04 <infinity0> nice thanks
09:15:17 <safrol_> so... about the Mockingbird
09:15:43 <mniip> ski, about that "impossible" function equality thing
09:17:20 <mniip> what's preventing us from building an injection from N to 2^N, and constructing functions '2^N -> r' from 'N -> r' in a way that will let us reason about the equality of 'N -> r' ?
09:23:41 <dolio> What's r?
09:24:40 <EvanR> some type with equality?
09:25:38 <_felixsch> any idea why this: map (\l -> getAllTextSubmatches $ l =~ "page=([0-9]+)>; rel=\"(prev|next)\"" :: [ByteString]) list -- list is [ByteString]
09:25:42 <_felixsch> is working in ghci
09:26:55 <_felixsch> but when I put it in some file and add a signature ([ByteString] -> [[ByteString]]) fails with: http://lpaste.net/151966
09:38:31 <geoffreyiy> @pl (\f (x1,y1) (x2,y2) -> (f x1 x2, f y1 y2))
09:38:32 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
09:40:05 <geoffreyiy> @pl (\x1 x2 x3 -> x3 x2 x1)
09:40:05 <lambdabot> flip (flip . flip id)
09:40:52 <Welkin> geoffreyiy: just go with what you've got
09:41:54 <geoffreyiy> @pl (\f (x,y) -> (f x, f y)
09:41:54 <lambdabot> (line 1, column 24):
09:41:54 <lambdabot> unexpected end of input
09:41:54 <lambdabot> expecting variable, "(", operator or ")"
09:41:59 <geoffreyiy> @pl (\f (x,y) -> (f x, f y))
09:41:59 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
09:43:02 <mniip> geoffreyiy, join bimap
09:43:03 <mniip> should do it
09:44:47 <ralu> i am missing curry function here
09:45:18 <mniip> ralu, that's not what uncurry does
09:45:23 <mniip> @src uncurry
09:45:23 <lambdabot> uncurry f p = f (fst p) (snd p)
09:51:09 * hackagebot random-tree 0.6.0.5 - Create random trees  https://hackage.haskell.org/package/random-tree-0.6.0.5 (GregorySchwartz)
09:51:11 * hackagebot tree-fun 0.8.1.0 - Library for functions pertaining to tree exploration and manipulation  https://hackage.haskell.org/package/tree-fun-0.8.1.0 (GregorySchwartz)
09:52:01 <geoffreyiy> @let f xp yp = join bimap ($ yp) $ join bimap f xp
09:52:02 <lambdabot>  .L.hs:155:42:
09:52:02 <lambdabot>      Ambiguous occurrence ‚Äòf‚Äô
09:52:02 <lambdabot>      It could refer to either ‚ÄòL.f‚Äô, defined at .L.hs:155:1
09:52:32 <geoffreyiy> @let f'' xp yp = join bimap ($ yp) $ join bimap f'' xp
09:52:33 <lambdabot>  .L.hs:155:44:
09:52:33 <lambdabot>      Ambiguous occurrence ‚Äòf''‚Äô
09:52:33 <lambdabot>      It could refer to either ‚ÄòL.f''‚Äô, defined at .L.hs:155:1
09:55:39 <geoffreyiy> @pl (\(f1,f2) (x1,x2) -> (f1 x1, f2 x2))
09:55:39 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
09:55:58 <geoffreyiy> sigh
09:56:52 <mniip> that's just ***
09:56:55 <mniip> :( they quit
10:00:29 <Ainieco> hello
10:00:35 <Ainieco> hello
10:01:17 <Ainieco> is it just me or allPairs from https://mightybyte.github.io/monad-challenges/pages/ex3-1.html is not really allPairs? allPairs [1,2] [3,4] == [(1,3),(1,4),(2,3),(2,4)] whree is (1,2)?
10:02:05 <Jinxit> Ainieco: pick one element from each list
10:02:06 <Welkin> that is a cartesian product
10:05:13 <EvanR> Ainieco: e.x. ['a','b'] [3,4] -> you could not have both ('a',3) and ('a','b') in the same result list
10:07:37 <dave23> Can I somehow split my stack.yaml configuration. I have it in version control and want to ignore part of it. Things like "extra-lib-dirs" tend to be specific to a particular machine.
10:12:14 <Ainieco> would be cool if one could use env variables withing stack.yaml
10:12:58 <prati> @let myFoldr _ (Leaf n ) = n
10:12:59 <lambdabot>  Defined.
10:13:27 <mjhoy> is there a good/simple codebase for me to look at that uses monad transformers, esp statet?
10:18:32 <Cale> mjhoy: Perhaps look at what xmonad does with its monad, which is called X
10:18:36 <Cale> :)
10:19:10 <Cale> It's not exactly simple, but I really think you need to build up a fairly large number of operations in the monad you're constructing before things like StateT are really a good plan.
10:20:07 <Cale> mjhoy: For a fairly large number of cases, it's better just to stick with using IO directly and passing around IORefs or records containing operations that internally use IORefs or something.
10:20:37 <Cale> (That is, if you'd be using IO anyway)
10:20:40 <Gurkenglas> mjhoy, I've had aha moments with monads when I saw how sequence works with them. Here's three sketchtoys I've made for Maybe, State s and StateT s Maybe http://sketchtoy.com/66039859 http://sketchtoy.com/66039843 http://sketchtoy.com/66462297
10:20:44 <mjhoy> Cale: i'm thinking of it more as a learning opportunity for myself
10:21:47 <Cale> mjhoy: Ah, okay. The main thing to keep in mind is just that as soon as you have a transformer over IO, it becomes annoying to work with things like forkIO or catch which are higher order.
10:22:10 <Cale> So you pay a big price for that first monad transformer and want to make it count.
10:22:33 <dmj> Cale: this is true, it is very annoying, getting around that in a way with monad-control and lifted-base/async
10:22:57 <mjhoy> Cale: i basically have an algorithm that transforms a couple of lists over a series of steps, and also uses a random gen
10:23:22 <Cale> There are things like StateT over [] for instance though, which are quite interesting and useful in themselves.
10:23:54 <mjhoy> Gurkenglas: thanks, interesting
10:23:59 <Cale> (Monads in that vein are really nice for solving puzzles)
10:24:39 <Gurkenglas> Cale, seen https://hackage.haskell.org/package/yoctoparsec-0.1.0.0/src/src/Control/Monad/Yoctoparsec.hs ?
10:25:24 * monochrom has a cunning plan. ant-man parsec.
10:25:35 <Cale> Gurkenglas: No, but someone (might've been you!) mentioned the relationship between FreeT ((->) t) and parsing the other day before I left for my trip to New York.
10:25:47 <mniip> hi
10:26:10 <mniip> (it was me)
10:26:15 <Cale> ah, yeah, that's right :)
10:27:54 <safrol_> (er mah gerd it's alive)
10:37:37 <warbo> hello, I'm hitting "hGetContents: invalid argument (invalid byte sequence)" when trying to read a file in one Haskell program and pass it as stdio to another
10:38:20 <warbo> I've tried invoking with System.Process, with System.Process.ByteString, reading/writing String, ByteString and Text and always seem to hit this issue
10:38:46 <warbo> has anyone hit similar problems with subprocesses and stdio?
10:40:52 <Cale> warbo: Huh, it shouldn't happen with ByteString. That happens when you have the file open in text mode and a binary sequence which is not valid in the text encoding occurs.
10:41:35 <Cale> warbo: If you really are reading text, you should check with hGetEncoding that the encoding is the one that you expect. The default is based on your system locale.
10:41:48 <Cale> warbo: and you can change it with hSetEncoding
10:42:40 <GLM> Any idea why two distinct data types have confilcts when they have fields of the same name?
10:42:55 <warbo> Cale: yeah, my locale is en_US.UTF-8, I tried setting the handles explicitly to utf8 TextEncoding, and even char8
10:44:34 <Cale> warbo: Is it text, or binary data? Try using openBinaryFile or hSetBinaryMode to get a non-encoding handle if it's supposed to be binary data.
10:45:22 <warbo> Cale: it's text (at least it should be, and "file" says "ASCII text, with very long lines"); I'll give openBinaryFile a go  
10:45:27 <Cale> huh
10:45:31 <Cale> That's interesting
10:45:39 <warbo> the error comes from the sub-process
10:46:12 * hackagebot clumpiness 0.17.0.0 - Calculate the clumpiness of leaf properties in a tree  https://hackage.haskell.org/package/clumpiness-0.17.0.0 (GregorySchwartz)
10:46:14 * hackagebot find-clumpiness 0.2.0.1 - Find the clumpiness of labels in a tree  https://hackage.haskell.org/package/find-clumpiness-0.2.0.1 (GregorySchwartz)
10:46:41 <Cale> warbo: Are you executing hClose on the handle which was given to hGetContents?
10:46:42 <warbo> process A reads in a file and calls something like 'readCreateProcessWithExitCode (proc "B" []) contents'
10:47:29 <warbo> Cale: I did have hClose calls scattered around, but lazy IO might not have closed them?
10:47:59 <Cale> You should typically never give hClose the same handle which was given to hGetContents, though I can't say for sure that this could cause that encoding issue...
10:48:11 <Cale> If it's ASCII text, it's hard to imagine how it would...
10:48:57 <Cale> Lazy IO takes responsibility for closing the handle when the file has finished being read.
10:49:28 <Cale> (which is why if you're opening more than a few files, people start recommending not to use lazy IO)
10:49:52 <warbo> Cale: yeah, I only have 3 files
10:49:59 <Cale> Yeah, that should be fine
10:50:34 <EvanR> does it close stdin?
10:51:48 <warbo> the outer process doesn't use its stdin; the inner process uses getContents
10:53:22 <warbo> GLM: if your data types are records, see https://wiki.haskell.org/Name_clashes_in_record_fields
10:53:45 <safrol_> punks
10:54:06 <monochrom> oh, if you hClose prematurely, you will see incomplete utf8 and it will be a decoding error
10:54:59 <warbo> monochrom: hadn't thought of that thanks; although my original implementation was a simple "readFile" (it's been through several iterations now, to try and avoid the issue)
10:55:39 <monochrom> but readFile doesn't hClose prematurely. in fact, it doesn't hClose.
10:57:10 <monochrom> it is never too paranoid to open a hex editor and manually check byte by byte that you have pure utf8
10:57:42 <EvanR> or use utf8decode ?
10:58:54 <monochrom> hell, it is never too paranoid to do that checking on a pristine isolated PC, just in case networked computers have malware
10:59:07 <warbo> heh
10:59:14 <warbo> I tried using literal bytestrings
10:59:19 <warbo> and they don't give a problem
10:59:33 <EvanR> they replaced your hexeditor ;)
11:02:35 <adamCS> Question: Suppose I have a Sum type, S, with constructors S1..Sn.  And every field of every constructor is an instance of Default (or I have some other way of giving it a value).  If I am given a value of type S, or just the type S (via a Proxy or something), is there a way to construct a list of type [S] where each of the constructors of S is used exactly once?
11:03:57 <adamCS> I've tried a little with GHC.Generics but couldn't figure it out.  Template Haskell seems more promising but before I launch into figuring that out, I thought I'd ask and see if there's an easier/better way.
11:03:58 <EvanR> theres Enum
11:04:02 <monochrom> I should manually write "[S1 default, S2 default default default default, S3 default default, ... , Sn default default default]"
11:04:27 <adamCS> But I can't make an instance of Enum for things with fields, can I?
11:04:42 <EvanR> you can
11:05:44 <adamCS> (looking up Enum...)
11:05:53 <EvanR> > [0..]
11:05:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:06:23 <EvanR> [S1 default..] ;)
11:06:35 <KaneTW> adamCS: tried data.data?
11:07:44 <adamCS> KaneTW: Looked at it and I can see that the info is there but I can't find any examples where you don't need to know which constructors you might get.  So I can't figure out how to do it generically.
11:08:16 <EvanR> :t [toEnum 0 ..]
11:08:18 <lambdabot> Enum t => [t]
11:09:05 <KaneTW> data TestD = A Int | B Bool Int | C | D Int Int Char deriving (Show, Eq, Data)
11:09:06 <EvanR> its kind of abusing the spirit of Enum though
11:09:08 <KaneTW> oops
11:09:12 <KaneTW> ?let data TestD = A Int | B Bool Int | C | D Int Int Char deriving (Show, Eq, Data)
11:09:14 <lambdabot>  Defined.
11:09:24 <KaneTW> > dataTypeOf (undefined :: TestD)
11:09:26 <lambdabot>  DataType {tycon = "TestD", datarep = AlgRep [A,B,C,D]}
11:09:57 <adamCS> I will play around with Enum.  I've never seen it used on a class with fields so I hadn't thought there was a way to get a value of something with fields.
11:10:15 <EvanR> well, thats where the defaults come in
11:10:34 <EvanR> KaneTW: whoa, what are A B C and D there
11:10:37 <adamCS> KaneTW: Yes.  I got that far.  But then using those constructors is..complicated. And all the examples involve knowing which one you are using by index.
11:10:53 <KaneTW> hm
11:11:12 * hackagebot haskellscrabble 2.0.1 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-2.0.1 (happy0)
11:14:11 <adamCS> EvanR:  Enum didn't work, at least not using "deriving": Can't make a derived instance of ‚ÄòEnum C‚Äô:
11:14:11 <KaneTW> i think i can build something with GHC.Generics
11:14:11 <adamCS>       ‚ÄòC‚Äô must be an enumeration type
11:14:11 <adamCS>       (an enumeration consists of one or more nullary, non-GADT constructors)
11:14:11 <adamCS>     In the data declaration for ‚ÄòC‚Äô 
11:14:13 <KaneTW> give me a bit
11:14:33 <EvanR> adamCS: no, i doubt you would be able to get deriving to do it. this would be a case-by-case instance
11:14:39 <EvanR> since its a non-standard use of Enum
11:15:04 <warbo> Cale: hmm, looks like openBinaryFile is working
11:15:28 <warbo> (well, avoiding the encoding error, at least; I've hit an actualy bug with my code now, which is refreshing ;) )
11:16:20 <adamCS> KaneTW:  I would be most appreciative.  I've gotten stuck since Generics seems much better suited to traversing one example of the type than all the possible values.  I did see the "conNames" function which does look at all possibilities but I can't mimic the way it does that for a function that returns the type you gave it rather than a String.
11:16:50 <adamCS> EvanR:  I see.  I'll try to figure that out to broaden my understanding of Enum.  But that won't really help since I am hoping for a more generic solution...
11:17:23 <EvanR> well [toEnum 0 ..] is generic, but i guess you mean that you dont want to write any code besides the S type
11:18:23 <EvanR> really the instances are different from just making a list manually
11:18:28 <EvanR> arent different*
11:18:28 <warbo> Cale: I tell a lie
11:18:52 <warbo> I think it might be due to using Cabal's data-files?
11:19:20 <adamCS> Actually, maybe I could use generic to make an instance of enum that would work for any class that can be constructed with Default.  Have to try.
11:21:52 <adamCS> That would be fine.  I just don't want to write different code for each S.  If I had to that I might as well just write the list manually for each S. I'm just trying to extend the domain for which I can make default instances for a class.  It will hit a wall someplace but I thought I might be able to push into sum types a little. 
11:22:39 <EvanR> is default really that useful?
11:23:16 <EvanR> in the case of S, what does it mean for these N values to all be default
11:23:21 <ReinH> Cale: how was the thing?
11:24:02 <graycode1> BD
11:24:09 <adamCS> EvanR:  No. Probably not.  I am trying to make a sort of general editor for a data structure.  So you give it a and you get IO a.  Well, not really IO a, but basically.  You get m a where m is a monad from an FRP-DOM framework.  So you can edit the fields.
11:24:26 <dedgrant> adamCS: Perhaps this a case for indexed types (S i) so that instance Applicative (S i)?  Then each default value might be 'pure default'. Not sure if this is flexible enough for you.
11:25:06 <Cale> ReinH: It was great!
11:25:22 <Cale> ReinH: Nice to meet so many people I've been talking to for 5, 10, 15 years :)
11:25:31 <adamCS> EvanR: So that all works for product types.  But what does it mean to "edit" a sum type?  One thought was a choice among all the constructors.  But then I need some values to put in.  I could also just offer blank fields (using Maybe) but I still need to know all the constructors and be able to apply them.
11:25:59 <EvanR> adamCS: well, drop down the ctor, and then you get different fields depending on the choice
11:26:11 <adamCS> EvanR:  Exactly!
11:26:38 <adamCS> EvanR:  But I need to at least know all the ctors and the types of the fields.
11:26:42 <Cale> ReinH: Hopefully I can make it to more events now that I have a steady income and I've gone through the month-long bureaucratic nonsense involved in obtaining a passport starting with no valid photo id.
11:26:48 <EvanR> and defaults might not make sense so the fields should just be able to be blank
11:26:57 <EvanR> (but you have to fill them in to procede)
11:27:35 <EvanR> yeah i just renewed my passport
11:27:57 <adamCS> EvanR:  Yes to all that.  But I'm still not sure how to go from an a value of type a to all the ctors of the type a and all the field types.
11:28:07 <EvanR> tahiti cruises here i come
11:28:44 <EvanR> adamCS: yeah im not sure but i suspect its possible (not from the value itself by from the TypeRep)
11:29:02 <adamCS> EvanR:  The editor handles blank fields already by putting everything together in the Maybe monad so you just get Nothing if any of the fields is wrong.
11:29:57 <adamCS> EvanR: Yeah.  I was hoping to sidestep some of that by getting a list of one of each and then using the editor almost as is.  But digging into the typerep or the meta-data in one of the generics libs might be the only way.
11:30:29 <adamCS> dedgrant:  I don't understand.  Indexed by what?
11:32:28 <f00f00> Hi!
11:32:42 <joko> Hello, I'm trying to create a func2 :: [a] -> IO [Maybe b] from func1 :: a -> IO (Maybe b) , could you help me?
11:32:43 <f00f00> Is there a way to force Haskell/ghci to display decimal numbers as hexadecimals?
11:34:24 <joko> f00f00: why don't you use an extra function such as showHex as seen there: http://stackoverflow.com/questions/9288883/how-to-override-show-instance-of-some-basic-types-in-haskell ?
11:34:46 <adamCS> joko: sequence (from Control.Monad)?
11:34:50 <jedai> joko: start by translating your [a] to a [IO (Maybe b)] with a map, then use sequence to get the IO out (then replace the combination by mapM)
11:34:58 <jedai> @type map
11:35:00 <lambdabot> (a -> b) -> [a] -> [b]
11:35:03 <jedai> @type sequence
11:35:04 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:35:07 <jedai> @type mapM
11:35:08 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:35:11 <dedgrant> adamCS: Number of arguments in the constructor. Instead of one type with multiple value constructors, each constructor is represented by a distinct type. It might not be what you're after at all.
11:35:18 <joko> adamCS and jedai: roger
11:35:32 <jedai> mapM f = sequence . map f
11:35:37 <f00f00> joko: I'd like to do some on-the-fly testing of a cryptographic functions I wrote
11:35:44 <f00f00> the black box I have outputs hexadecimals
11:36:08 <f00f00> it would be very convenient to be able to do some quick testing right in ghci
11:36:20 <adamCS> dedgrant:  Ah.  That makes sense.  Not quite what I am after since I don't want to have to change the type of S but instead have it work for any sum type S.  
11:36:48 <jedai> f00f00: I don't get it... What do you mean by output hexadecimals ? It output String ?
11:36:56 <warbo> ok, thanks for your help everyone; I've given up on this encoding error and have changed the inner process to accept the filename as a a commandline argument instead
11:37:03 <Gurkenglas> :t traverse :: (a -> IO (Maybe b)) -> [a] -> IO [Maybe b] -- joko
11:37:05 <lambdabot> (a -> IO (Maybe b)) -> [a] -> IO [Maybe b]
11:37:29 <dedgrant> adamCS: Yea, it sounds more like a generative problem. :)
11:37:32 <EvanR> :t showHex
11:37:34 <lambdabot> (Integral a, Show a) => a -> ShowS
11:38:00 <adamCS> dedgrant: Yeah.  But thanks for thinking about it!
11:38:00 <EvanR> f00f00: convert to hex in the wrapper to your functions
11:38:13 <f00f00> jedai: I'd like to have something like [38, 38, 38, 38] printed as  [0x23, 0x23, 0x23, 0x23] in the console
11:38:39 <EvanR> you can also wrap the contents in a newtype with an alternative Show
11:39:15 <schell> has anyone had luck with pandoc‚Äôs link_attributes extension?
11:39:26 <jedai> f00f00: Well I don't think you can do that with GHCi, EvanR solution will be the most "seamless"
11:41:10 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#ghci-interactive-print
11:41:19 <joko> ok, now that I have IO [Maybe b], how I could manage MaybeT? Before the function was returning IO (Maybe b), so it was something like c1 
11:41:37 <joko> c1 <- MaybeT $ func1 a
11:41:45 <jedai> newtype Hex a = Hex a; instance (Integral a, Show a) => Show (Hex a) where showsPrec _ h = showHex h
11:42:45 <jedai> f00f00: something like that, then you do "map Hex" on the output of your function
11:43:09 <f00f00> jedai: that should work
11:43:11 <f00f00> thanks
11:45:37 <EvanR> put a spell on your values
11:51:14 * hackagebot hcoap 0.1.1.0 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.1.0 (lulf)
11:51:19 <Gurkenglas> joko, what's supposed to happen if any Maybe value is Nothing? Should everything fail?
11:51:25 <crough> jedai: It's fine to error on an empty list, but you should return a Maybe, not throw
11:51:41 <megaTherion> Gurkenglas: Spreewald Gurken?
11:51:56 <crough> maximum [] doesn't make sense, but it's not very Haskell to throw exceptions despite what functions in the Prelude like foldl1 do.
11:52:02 <rui2> Anyone uses Nixos in a virtualbox machine?
11:52:35 <EvanR> crough: its impossible, no need to mess with Maybe
11:52:46 <EvanR> i meant to say, IF its impossible (and you can prove it)
11:52:54 <joko> Gurkenglas: nope, it should continue with the Just ones
11:53:25 <Gurkenglas> joko, use mapMaybe then (fmapping it into IO)
11:53:31 <Gurkenglas> *catMaybes
11:53:43 <EvanR> :t catMaybes
11:53:45 <lambdabot> [Maybe a] -> [a]
11:53:50 <jedai> crough: True, though I don't know what his book say the type of maximumBy is
11:54:00 <crough> EvanR: Proving it is using NonEmpty or pattern matching.
11:54:13 <joko> Gurkenglas: I like it, thanks
11:54:15 <EvanR> crough: not everything that is the case can be proven with haskell
11:54:15 <crough> EvanR: Checking the length and then doing foldl1 is hazardous to refactoring
11:54:23 <EvanR> yes
11:54:30 <EvanR> would be better if it was in the type system
11:54:35 <jedai> crough: given that it is just an exercise, I guess the most important thing is respecting the contract of the question
11:55:15 <EvanR> crough: pattern matching with cases which you have nothing to say about will indicate where you need proofs
11:55:22 <EvanR> but may not be able to do it
11:55:29 <EvanR> so error "IMPOSSIBLEEEEE"
11:55:40 <EvanR> as long as it doesnt leak out
11:55:48 <KaneTW> adamCS: turns out it's quite difficult
11:56:41 <adamCS> KaneTW:  That's sort of what I thought but I only just figured out how to do something simple with Generics so I wasn't sure.
11:56:50 <csd_> is hughes' programming with arrows paper a good one to start with
11:57:12 <KaneTW> data doesn't work, but generics might
11:57:36 <crough> error "IMPOSSIBLE" is much better replaced by Void and absurd, though, despite being fundamentally the same. I get the need for proofs, but error algebras are sufficient for beginners as they're easy to understand
11:58:08 <EvanR> crough: using Maybe where Nothing can never happen is really getting in the way and hiding the issue
11:58:14 <EvanR> and annoying
11:58:27 <adamCS> KaneTW:  Thanks for trying!  I'll keep looking around.  It seems like all these packages have the info in some form but getting from the representation of the type back to constructors is hard.
11:58:31 <EvanR> imagine if division was Maybe
11:58:43 <KaneTW> i think i have an idea that might work
11:59:27 <crough> We wouldn't ever divide by zero? Sounds great.
11:59:38 <EvanR> it wouldnt stop you from crashing though
11:59:42 <dolio> No, you would.
11:59:52 <dolio> You'd just have to check after every division that you didn't divide by zero.
12:00:01 <mirari> In Haskell we can declare a type class Eq a and its operations. We can think of Eq as the set of types equipped with equality. What if I want to specify a specific class of functions from some domain to another. Is that possible? 
12:00:14 <adamCS> KaneTW:  Using Generics?  I sort of think there must be a way with template haskell but I have never used it.
12:00:21 <EvanR> you usually know that youre not dividing by zero, so the Nothing case would be error "IMPOSSIBLE"
12:00:26 <Cale> mirari: You can have type classes that have multiple type parameters
12:00:56 <Cale> mirari: It's also possible to specify functional dependencies between these parameters, so that if the compiler knows one of the types, it can infer the others.
12:01:06 <KaneTW> adamCS: generics, yeah
12:01:15 <KaneTW> TH works easily, but i want to try doing it without
12:01:18 <mirari> Cale: Something like Foo a b where f :: a -> b, but that requires me to "name" f. I am sort of looking for something like Foo a -> b
12:01:22 <mirari> Even if that sounds wierd.
12:01:23 <Cale> mirari: In addition, there are associated data types and type synonyms, defined inside the class declaration.
12:01:26 <joko> One more question, in hackage documentation I see some constructors having fields with !data, e.g. xrr_oi_crtc :: !RRCrtc in https://hackage.haskell.org/package/X11-1.6.1.2/docs/Graphics-X11-Xrandr.html#t:XRROutputInfo what's the reason for the exclamation mark?
12:01:58 <Cale> mirari: Well, can you be more specific about what you're trying to abstract over?
12:02:19 <jedai> joko: it indicates this field is *strict√π
12:02:22 <adamCS> KaneTW:  I'd love to see it.  If you can't figure it out with Generics, will you point me in the direction of a TH solution?  I don't know any TH so I'll learn as I go but knowing where to look might help...Thanks!
12:02:23 <thewormkill> joko: it's a strictness annotation
12:02:34 <mirari> Cale: It is pretty abstract, but lets say the set of monotone functions from A to B
12:03:02 <Cale> mirari: That doesn't sound like a type class to me at all.
12:03:10 <mirari> Cale: so there are all kinds of functions from A to B, but I am only interested in certain functions, and I want to be able to express that requirement.
12:03:22 <Cale> mirari: You might have a type class for pairs of types which have a canonical monotone function between them.
12:03:43 <mirari> Cale: Can you show me an example of that
12:03:57 <adamCS> Cale:  Thanks for pointing me in the direction of the VL free monad (a couple of weeks ago).  Didn't quite work out--difficult to combine effects while also having constraints on the monad, at least in the vl-free lib--but it was super interesting to play around with!
12:04:03 <jedai> joko: with "data Thing = Foo Int", you can have "f (Foo _) = True" and do "f (Foo undefined) == True"
12:04:56 <Cale> mirari: Sure... though I sort of doubt its usefulness :)
12:05:13 <jedai> joko: with "data Thing = Foo !Int", the function wouldn't work because you couldn't check you have "Foo _" without forcing the Int, so the undefined would create an exception
12:06:14 * hackagebot remote-json 0.2 - Remote Monad implementation of the JSON RPC protocol  https://hackage.haskell.org/package/remote-json-0.2 (AndyGill)
12:06:31 <mirari> Cale: My inspiration is from here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html (sec 7.6.1.5) where a type class "RiemannHypothesis" is used as kind of a premise. Similarly, I want something so I can write a(higher-order) function requiring the argument to be monotone.
12:06:32 <Cale> mirari: You could just have something like  class Monotone a b where monotone :: a -> b
12:06:43 <Cale> ah, hm
12:07:02 <Cale> Oh, nullary type classes are kind of silly
12:07:10 <mirari> Cale: so that works, but I have to write instance Monotone X Y where monotone = myfunc, right?
12:07:17 <Cale> mirari: yes
12:07:29 <mirari> I guess that is fair
12:07:33 <Cale> mirari: also, it means you have a canonical choice of monotone function between given pairs of types
12:07:54 <Cale> mirari: You probably more likely want something like   newtype Monotone a b = Monotone (a -> b)
12:08:04 <mirari> Cale: It requires that right? That is a problem, because I have many monotone functions between a and b
12:08:21 <Cale> mirari: Right, which is why you probably don't want a type class here.
12:08:33 <Cale> mirari: Type classes constrain types, not values.
12:08:55 <mirari> Cale: I see. hmm.
12:09:45 <Cale> Really, what you want is a dependently typed language, so you could use a type like  Sigma (f : A -> B), Pi (x : A), (x <= y) -> (f x <= f y)
12:09:54 <Cale> But Haskell is not that language :)
12:11:00 <mirari> Cale: True, I am actually sort-of designing such a language. I was trying to understand what was possible in Haskell :)
12:11:03 <Cale> adamCS: Sorry to hear that it didn't quite work out for you. I think it's pretty likely that you could get *something* in that vein to work. I haven't looked at the vl-free library, I basically gave you that name as a way of referring to the approach in general :)
12:11:24 <Cale> mirari: Have you looked at Idris, Coq, and Agda?
12:11:25 <mirari> Cale: Since I find Haskell to be a very solid starting point for many design decisions.
12:11:37 <mirari> Cale: I am aware of all of them, yes.
12:11:42 <ReinH> Cale: excellent news
12:11:57 <ReinH> Cale: now that you're back, can I bother you with a question?
12:12:25 <mirari> Cale: Let me show you some pseudo Haskell, if you are interested, just a sec.
12:12:48 <Cale> ReinH: sure
12:12:51 <adamCS> Cale:  yes.  But I decided trying to figure out a different way with the VLF wasn't quite worth it right now.  And don't be sorry!  It was interesting to play with and much simpler in many ways than the traditional free construction for my case.  So that was informative.
12:14:07 <ReinH> Cale: so I'm writing minimax. I started with a Cofree [] for the game tree but then I wanted to annotate each leaf with the move so I could return a variation (list of moves) with the score. I couldn't figure out how to do this compositionally (i.e., by composing more structure onto []) so I started doing it in an ad hoc way https://gist.github.com/reinh/44b37630e029253298ea
12:14:12 <ReinH> Cale: I'd like to not do it in an ad hoc way.
12:14:14 <ReinH> Thoughts?
12:14:42 <ReinH> Is this list + writer?
12:15:53 <mirari> Cale: http://pastebin.com/Hids1TFP Now, this is just pseudo haskell. But the idea is that when you have a set/type e, you can define a partial order on it with a function leq, but this function has to satisfy certain properties (e.g. reflexivity). Now, expression that "law" as part of the type class seems very reasonable (and works for many of the things I am looking at). The problem is when I have a class
12:15:59 <mirari>  of functions from one domain to another that must satisfy certain properties. And this is where my question came in. 
12:16:38 <edwardk> reinh: did you know the monad generated by an operad has features of both list and writer and the comonad generated by one applies nicely to game trees?
12:16:56 <ReinH> That's the kind of thing I would like to know. :)
12:18:29 <ReinH> edwardk: where can I read more?
12:19:07 <Cale> ReinH: looking
12:19:28 <mirari> Cale: thanks for the insights. I will dwell more on it.
12:21:03 <edwardk> reinh: github.com/ekmett/multicategories and some article by bartosz
12:21:23 <edwardk> his was on operads
12:21:45 <edwardk> and a tictactoe engine we sketched out while i was visiting, that really should be built on a multicategory not an operad
12:21:49 <adamCS> this: http://bartoszmilewski.com/2015/10/07/operads-type-level-nats-and-tic-tac-toe/ 
12:22:06 <ReinH> thanks
12:22:16 <edwardk> yep
12:22:17 <thewormkill> Hello everyone. I am trying to create FFI bindings to capstone on Arch Linux and get "undefined symbol" errors when using stack in the following scenario: src/Test.hs: http://lpaste.net/151972 , hapstone.cabal: http://lpaste.net/151973 , stack.yaml: http://lpaste.net/151974 . I am following the HaskellWiki article on the FFI, and I use the sqlite package as an example. The relevant header file I use is
12:22:19 <thewormkill> available here: https://github.com/aquynh/capstone/blob/master/include/capstone.h
12:23:39 <thewormkill> (Error messages are included above). I suspect that for some reason the needed libcapstone.so file is not properly linked, which I don't think is logical considering the working build-process.
12:23:45 <Cale> ReinH: Yeah, I don't know if I'd generally care to apply any more abstract machinery to the problem than you're already applying here... but it seems Ed's already pointed you towards some stuff to chew on :P
12:23:49 <thewormkill> Anyone having any idea on this?
12:24:19 <ReinH> edwardk: Ah, nice. I'm approaching this from the anti-procrustean perspective ;)
12:24:36 <edwardk> =)
12:24:38 <ReinH> Trying to build up to a structure rather than fit a problem to a structure.
12:24:44 <ReinH> But maybe I can see how to make the two meet in the middle
12:24:49 <edwardk> sure
12:24:51 <edwardk> good luck
12:24:55 <ReinH> yeahhh
12:25:28 <ReinH> Cale: Ok, then can you tell me what would be an elegant way to path annotate the search with the moves from this point?
12:28:04 <Cale> ReinH: Flip the arguments to GameTree, and then GameTree move is a comonad. The fact that it's a comonad isn't interesting, but the duplicate operation is perhaps what you're after?
12:28:05 <safrol_> Woah.... Hi folks, glas to be here.
12:28:10 <safrol_> glad*
12:28:17 <Cale> safrol_: Welcome!
12:28:26 <safrol_> Typos. ^.^ luv em
12:28:45 <ReinH> Cale: let's see.
12:29:12 <safrol_> lelelelelenses
12:29:18 <Cale> ReinH: Did you want the moves which lead up to that state, or the tree of moves below it?
12:29:24 <safrol_> how's you explain them in the shortest path?
12:29:25 <ReinH> @unmtl WriterT m [] a
12:29:25 <lambdabot> [] (a, m)
12:30:04 <safrol_> How is everyone today?
12:30:12 <ReinH> I want the moves from the root to the selected max (or min) leaf
12:30:32 <safrol_> RNNs?
12:30:33 <Cale> safrol_: I usually just start with the very old fashioned record-of-view-and-set sort of lenses, and then generalise that to 4 type parameters, and *then* go after the lens-library's definition.
12:31:24 <Cale> ReinH: ah, okay, then nevermind what I suggested
12:31:28 <safrol_> I suppose the cherry won't drop from itself.
12:31:30 <ReinH> Cale: :D
12:32:13 <Cale> ReinH: Can you fiddle with the move type?
12:32:19 <ReinH> Cale: My intuition is that if I combine the Max/Min monoid with the [] monoid, I should be able to walk and accumulate for free. But I think that's not true, since I have to select which move to accumulate based on which element is selected by max/min.
12:32:24 <Cale> ReinH: turn it into a list of whatever it was you were going to use
12:32:40 <Cale> hm
12:32:49 <Cale> maybe not ideal, given that it labels the transitions too
12:33:14 <safrol_> woah.... too bad i didnt win the contest ]_[
12:33:30 <ReinH> Cale: That's an idea though. If I can relabel each element with the path to it, I can just select the winning element as usual.
12:33:43 <ReinH> and ideally laziness would prevent me from relabeling too much.
12:34:00 <Cale> safrol_: Uh, you're starting to fail the Turing test.
12:34:28 <safrol_> Cale: In Lakesh Alak'In
12:34:31 <safrol_> or sumthin liek dat
12:35:34 <Cale> safrol_: This channel is for discussion of the functional programming language Haskell. Please try to stay on topic here. There are other channels available if you just want to hang out and talk about random other things.
12:35:44 <hexagoxel> thewormkill: i maybe would put the link to the capstone lib as "Extra-libraries:" into the .cabal instead of putting it into the stack.yaml only.
12:36:14 <KaneTW> adamCS: http://lpaste.net/76262427150254080 (this is very much just a proof of concept, it'll fail for plain ''Int) for example
12:36:28 <thewormkill> hexagoxel: I will try. I should add that I did it that way after I read that someone having a remotely similar issue fixed it that way. I'll report back
12:36:38 <KaneTW> Œª> $(mkDefaults ''TestD) evaluates to  [A,B 0,C 'f' 0,D 'f' 0 True]
12:36:39 <hexagoxel> thewormkill: i don't know how stack works in this respects, at all; but this seems the common way to do it.
12:36:48 <thewormkill> yeah
12:37:18 <adamCS> KaneTW: Cool!  That's a great way for me to learn some TH.  And maybe solve my problem...
12:37:27 <adamCS> KaneTW:  Thanks!
12:37:41 <KaneTW> there's a library th-desugar that makes some of the case handling simpler
12:37:55 <hexagoxel> thewormkill: also, have you tried not using ghci (add some dummy executable, compile and run that)?
12:38:00 <KaneTW> https://hackage.haskell.org/package/th-desugar
12:38:03 <KaneTW> no problem
12:38:30 * safrol_ lurks
12:38:31 <thewormkill> hexagoxel: no, but as I use GHCI fairly frequently while developing I didn't think of that :P
12:38:58 <balor> Does `stack install pocket-dns` fail for anyone else?
12:39:31 <thewormkill> hexagoxel: however, adding "  extra-libraries:     capstone" to my cabal file doesn't yield any different result
12:42:23 <ReinH> Cale: Hmm... I don't need to store the positions at all. I can use Free [] move (?) and recover the positions by applying the moves. Maybe this would be easier to path annotate.
12:43:49 <ReinH> Cale: Hmm... then a stateful traversal would update the board and the list of moves for each branch.
12:43:56 <apstroll> Is there any way to remove old GHC-installations in stack? Is it safe to just rm stuff inside .stack/programs/..?
12:43:59 <thewormkill> however, compiling as a normal executable indeed works out, hexagoxel 
12:44:05 <thewormkill> that's a good start at least :)
12:44:38 <hexagoxel> thewormkill: actually using extern functions?
12:44:42 <thewormkill> ye
12:45:00 <thewormkill> print'ing the result of the one function I wrap
12:45:10 <ReinH> Cale: I can treat the move as specifying a semigroup action, i.e., makeMove move :: (pos, [move]) -> (pos, [move])
12:45:20 * equalize is still lurking
12:45:31 <thewormkill> main = print $ cCs_support 2 -- here we use it
12:45:31 <ReinH> Or something.
12:45:36 <ReinH> Something to think about at least.
12:45:57 <KaneTW> adamCS: http://lpaste.net/5042097842349408256 i like this a bit more (moved getDefaultExpr mkDefaults so $(mkDefaults ''Int) works)
12:46:36 <ReinH> Cale: The problem is that in order to generate the tree of moves, I have to generate and then throw away the positions, so I perform duplicate work.
12:46:56 <KaneTW> problem with that version is that it's susceptible to infinite recursion
12:46:58 <ReinH> Maybe I can fuse generation and traversal together somehow.
12:47:31 <ReinH> Hmm, that's exactly what generating (pos, [move]) in the first place does.
12:47:36 <adamCS> KaneTW:  Thanks!  I'll have to look at my use case and try things out to see what I need, exactly.
12:48:14 <KaneTW> kk
12:48:17 <KaneTW> np
12:48:31 <ReinH> Cale: Ok, so I think my plan is to generate a path annotated game tree to begin with, then I can traverse it once and the selected leaf will already contain the resulting position, move list, and score.
12:48:45 <Cale> ReinH: That sounds totally reasonable to me
12:49:11 <safrol> ReinH: playing games ?
12:49:17 <ReinH> Cale: and since in most cases I'm only scrutinizing the head of the move list, laziness will help me avoid unnecessary work.
12:49:23 <Cale> ReinH: Unless you do something insane while building up the tree, the lists should share tails anyway, so it won't be a huge space overhead or something.
12:49:29 <ReinH> That too.
12:49:39 <ReinH> safrol: Sort of.
12:50:15 <thewormkill> hexagoxel: and it matches the output from the C version, so it is safe to assume that everything works fine there, so it is a GHCI specific problem
12:50:49 <hexagoxel> thewormkill: there surely is "stack ghci -v" that actually displays the exact ghc invocation.
12:50:57 <thewormkill> good point
12:51:41 * hexagoxel has no ffi stack project lying around to quickly check..
12:51:41 <safrol> mmm... Enjoying life, anyone ? Never thought it's be that easy..
12:52:15 <hexagoxel> life is full of side effects, meh.
12:53:00 <thewormkill> :D
12:53:12 <thewormkill> well, -lcapstone gets passed... twice
12:53:20 <thewormkill> (once for cabal and once for stack I assume)
12:53:40 <thewormkill> hm
12:53:58 <hexagoxel> yeah.. but i would not assume that to break things.
12:54:14 <hexagoxel> but.. better remove the stack one :p
12:54:18 <thewormkill> obviously :D
12:54:38 <thewormkill> the only thing I can think of it needs is... -fobject-code
12:56:06 <thewormkill> now this is weird
12:56:15 <thewormkill> for some reason my stack ghc command stopped working
12:56:17 <thewormkill> :/
12:56:30 <EvanR> nice... if F a is a contrafuctor then G a = F a -> H is a functor
12:56:39 <EvanR> contrafunctor*
12:56:48 <thewormkill> :O it depends on the directory I build from
12:56:50 <thewormkill> interesting
12:56:57 <thewormkill> thought stack handles that... TIL
12:57:24 <EvanR> because you can define fmap in terms of contramap
12:57:33 <safrol> er mah gerd
12:57:41 <conal> EvanR: and vice versa? if F is a functor, then G is a contrafunctor, I'd guess.
12:58:17 <conal> oh. for a more general reason: contra . func == contra, func . contra == contra.
12:58:27 <conal> and func . func == func, and contra . contra == contra
12:59:03 <conal> positives & negatives with multiplication
13:00:00 <EvanR> yeah so i have two directions i could go with the api, backwards or forwards ...
13:00:08 <thewormkill> hexagoxel: If I run "stack exec ghc -- --interactive src/Main.hs" and run my main in that GHCI, it works
13:00:22 <thewormkill> interesting
13:00:32 <EvanR> start at the end and apply contramaps, or start at the beginning and use fmaps
13:01:23 <thewormkill> Now I need to decide if, where and how I need to file a bugreport
13:01:57 <EvanR> type Driver m s a = Backend m s a -> m (), type Backend = s m a. then if s m is a contrafunctor, Drivers are functors
13:02:32 <schell> does anyone know if there is a stack equivalent to `cabal sandbox add-source` ?
13:03:43 <EvanR> so you can complete the m () by applying a chain of fmapped drivers to a backend, or by applying contramap repeatedly to the backend, and using the resulting backend yourself (youre the driver)
13:03:43 <thewormkill> schell: you can add more than one package in your stack.yaml
13:04:21 <hexagoxel> thewormkill: maybe you need to mention the header file as well in the .cabal?
13:04:45 <EvanR> or half and half
13:04:59 <EvanR> meet in the middle
13:05:20 <thewormkill> hexagoxel: hm, I have never seen any reference to that. How/where would you do that?
13:05:21 <hexagoxel> thewormkill: that seems to be the only difference to a test ffi project where i just used `stack repl` without a problem.
13:05:55 <hexagoxel> thewormkill: smth like "Includes: ode/ode.h"
13:06:06 <thewormkill> in the library section?
13:06:10 <hexagoxel> yes
13:06:20 * hackagebot pong-server 0.0.2.0 - A simple embedded pingable server that runs in the background.  https://hackage.haskell.org/package/pong-server-0.0.2.0 (RobertFischer)
13:06:25 <hexagoxel> s/ode/hapstone/g of course
13:06:28 <schell> thewormkill: ahh - so something like packages: [‚Äò.‚Äô, ‚Äò../otherpackage‚Äô]
13:06:46 <thewormkill> schell: yes
13:06:56 <thewormkill> syntax was just a list tho, schell 
13:07:35 <schell> thewormkill: great, thanks :)
13:07:52 <EvanR> conal: I'm sure those multiplication rules will come in handy at some point
13:08:24 <thewormkill> hexagoxel: having added "includes: capstone/capstone.h" to the library section of my cabal file, still same error
13:08:49 <hexagoxel> (and i assume you did `stack clean`?)
13:09:06 <hexagoxel> cleaning always helps :p
13:09:18 <thewormkill> yes
13:09:22 <thewormkill> nothing :D
13:11:10 <thewormkill> I don't know why I keep grinning like that
13:11:52 <thewormkill> also, all goes to hell if I remove the library line from my stack.yaml
13:11:54 <thewormkill> :P
13:12:19 <MarcelineVQ> :>
13:14:25 <hexagoxel> thewormkill: ah, i can reproduce. hmm.
13:14:43 <thewormkill> what was the difference to your initial setup?
13:15:22 <EvanR> ok its all just contramaps in the end
13:15:22 <hexagoxel> thewormkill: copying over the ghc-options from your stack.yaml.
13:15:30 <hexagoxel> so.. -fobject-code, i guess.
13:16:00 <thewormkill> hm. according to the wikibook, ghci needs that
13:16:07 <safrol> I'm bored... can we not talk about   so much?
13:16:19 <thewormkill> are you linking against capstone as well?
13:16:25 <safrol> Oh... Wait. No. Please dont answer. Thanks. #
13:16:34 <hexagoxel> thewormkill: no, against ode.
13:16:41 <thewormkill> okay
13:16:55 <thewormkill> so it is a problem on the tooling side, as we suspected already
13:16:59 <hexagoxel> but repl worked fine without -fobjectcode.
13:17:09 <thewormkill> hm, I'll remove it and retry
13:17:34 <thewormkill> lol
13:17:36 <thewormkill> it works
13:17:38 <thewormkill> :)
13:17:41 <thewormkill> thank you
13:18:06 <thewormkill> another proof of the KISS principle
13:19:16 <zaquest> is there any reason why cloneTMChan is not provided in stm-chans?
13:19:38 <thewormkill> removing the -lcapstone from the stack.yaml works as well now, hexagoxel 
13:19:41 <thewormkill> thanks again
13:20:14 <geppettodivacin> I've got a State that passes a large record type as its state. Is there some way to easily modify a single field of that record through a different stateful operation?
13:20:15 <thewormkill> and removing the includes line from the cabal file as well
13:20:17 <thewormkill> lol
13:20:21 <tippeneinn> does wai cache responses or would that be a browser thing?
13:20:32 <hexagoxel> thewormkill: the error occurs regardless of using stack or cabal repl, btw.
13:20:35 <geppettodivacin> http://lpaste.net/151979 <- That is a simplified version of what I'm trying to do.
13:20:36 <thewormkill> so, essentially, I broke everything by trying to be too smart
13:20:42 <tippeneinn> I just changed the data type of a response object and it's still returning the old format
13:20:58 <hexagoxel> thewormkill: so if you want to report it, i'd suggest the ghc tracker.
13:21:03 <thewormkill> hexagoxel: removing the -fobject-code is all I needed
13:21:09 <thewormkill> dunno if that's a bug
13:21:22 <adamCS> geppettodivacin: You could use lens and zoom (or magnify.  I can never remember which is which).
13:21:52 <adamCS> sorry
13:21:57 <hexagoxel> thewormkill: the impossible should never happen, even if your invocation is intrinsically wrong.
13:21:57 <adamCS> not zoom/magnify
13:22:00 <hexagoxel> :p
13:22:00 <adamCS> just lens
13:22:08 <adamCS> and "(=%)"
13:22:12 <thewormkill> hexagoxel: I suppose
13:22:17 <geppettodivacin> adamCS: So lens would be the right thing to use. I've looked at those before and wound up confusing myself the last time.
13:22:30 <geppettodivacin> It's been a while, though. I should take another look.
13:22:48 <adamCS> yes.  It's confusing.  But you get some clean looking state code out of it.  
13:23:13 <thewormkill> well, this fits my timing, I'm off for some math. Thank you hexagoxel for your help
13:23:15 <thewormkill> :)
13:23:20 <adamCS> There might be something just as useful in one of the alternative, simpler, lens libs.  I don't know.
13:23:32 <hexagoxel> thewormkill: yw.
13:23:57 <geppettodivacin> adamCS: I'm sure I'll have to learn lenses eventually anyway.
13:24:10 <adamCS> Yes.
13:24:29 <adamCS> Though that's true of so many things (for me), so you have to pick and choose the order...
13:25:12 <lpaste> glguy annotated ‚ÄúComplexState‚Äù with ‚ÄúUsing lens/zoom‚Äù at http://lpaste.net/151979#a151980
13:27:07 <adamCS> geppettodivacin: And I take back my earlier retraction.  Zoom might help too.  Zoom lets you work as if your state is just what the lens picks out.  the (=%) operator lets you modify a field via a lens when operating in the larger state.  They both would work but zoom looks nicer for you because then your stateInt might simplify.
13:27:39 <adamCS> since you would then be in a State Int the whole time.
13:30:56 <adamCS> but the op works too: stateComplex = cxLens =% (+) 1
13:30:58 <adamCS> more or less
13:31:47 <geppettodivacin> Hmm. That's pretty neat, too.
13:31:48 <adamCS> sorry! it's (%=) 
13:32:00 <adamCS> and you can use (+=) to be even more brief
13:32:01 <geppettodivacin> Probably more like what I was looking for than trying to stay in the State Int.
13:33:26 <adamCS> Right.  Depends on the rest of what you are doing.  I've used both depending on how much of the rest of what I'm doing is in which part of the state.  
13:33:28 <adamCS> Good luck!
13:33:43 <geppettodivacin> @info (%=)
13:33:43 <lambdabot> (%=)
13:34:01 <geppettodivacin> How do you get package information about a function again?
13:34:11 <geppettodivacin> Thanks, adamCS!
13:34:24 <conal> EvanR: those four composition rules are in TypeCompose, starting at https://hackage.haskell.org/package/TypeCompose-0.9.11/docs/Control-Compose.html#v:fmapFF
13:34:36 <adamCS> geppettodivacin: np!
13:36:02 <conal> EvanR: oops. looks like i flubbed the haddock comments
13:39:10 <monochrom> w00t, aeson 0.11 is out and fixes regressions
13:39:23 * monochrom switches to 0.11
13:39:30 <Enigmagic> no more bugs!@#*
13:43:42 <Welkin> lol
13:43:53 <Welkin> I think I am still using 0.8 because of stackage
13:46:21 <monochrom> eh? 0.11 adds dependency to fail, tagger, semigroups
13:56:34 <shanemikel> what's the most commonly used arg parser?
13:56:52 <shanemikel> also, with getOpt, does anybody know how to make it accept a space between short opts and their args?
13:57:55 <monochrom> I use optparse-applicative
13:58:34 <catsup> is there a way to put a conditional in .ghci ?
13:59:50 <glguy> shanemikel: To accept a space between the argument and flag the argument must be a "required" argument
14:00:20 <shanemikel> oh.. that makes sense glguy thanks
14:05:36 <shanemikel> how do disable the camelCase suggestion in hlint?
14:07:49 <hpc> why not follow the lint's suggestion?
14:08:08 <hpc> as far as cosmetic changes go, following the language convention is one of the few legitimate ones
14:08:10 <glguy> shanemikel: You can disable hlint's ideas with {-# ANN module "HLint: ignore Eta reduce" #-}
14:08:20 <glguy> for example that disables the Eta reduce message
14:09:22 <shanemikel> i'm creating handlers for command line options, and the handler for flag 'v' should be oh_v or 'f': oh_f .. just so the letter stands out
14:10:08 <shanemikel> since there are case sensitive flags, I don't want to use camel
14:10:18 <shanemikel> unless you have a more aesthetic idea
14:10:32 <shanemikel> (not exporting them anyway)
14:11:12 <glguy> shanemikel: It's perfectly fine to turn off hlint suggestions
14:11:15 <hpc> ah, that makes sense
14:12:40 <shanemikel> is there a list of the rules? how do I know what the rule is called?
14:13:15 <glguy> You put the text of the suggestion in the ignore pragma
14:13:36 <glguy> When hlint suggests to "Use curry", you write {-# ANN module "HLint: ignore Use curry" #-}
14:14:08 <glguy> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Fold.hs#L202
14:15:36 <ReinH> edwardk: So I don't immediately see the benefit of type annotating the number of branches a node has in that tictactoe thing.
14:16:13 <ReinH> It seems like you go to the extra work of making those numbers add up for the various merging operations but don't actually need that information for anything
14:19:32 <augustss> Howdy
14:21:08 <glguy> Hello again
14:24:47 <ReinH> hello goodbye
14:25:16 <safrol> Where is the love ?
14:25:28 * safrol is acting like BMO
14:26:58 * hackagebot smoothie 0.4.2.2 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.2.2 (DimitriSabadie)
14:27:00 * hackagebot pandoc-types 1.16.1 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.16.1 (JohnMacFarlane)
14:28:30 <bernalex> I'm being stupid. if I have [Maybe Int], how do I apply maximum to it?
14:28:46 <bernalex> and get Maybe Int
14:29:07 <crough> bernalex: what should happen on Nothing?
14:29:12 <bernalex> crough: Nothing
14:29:30 <crough> So if any are nothing, then nothing? You can use sequence to turn [Maybe Int] to Maybe [Int] and then fmap maximum
14:29:38 <nitrix> So either a sum if they are all Justs, otherwise Nothing?
14:29:48 <bernalex> nitrix: Just the highest or Nothing
14:29:55 <bernalex> crough: that was my initial thought
14:30:08 <kadoban> > maximum [Just 5, Nothing]
14:30:10 <lambdabot>  Just 5
14:30:24 <crough> Ha, well.
14:30:32 <nitrix> I think Maybe already has an Eq, right?
14:30:40 <bernalex> kadoban: erm oh
14:30:42 <nitrix> @instances Eq
14:30:46 <lambdabot> (), (Seq.Seq a), (Seq.ViewL a), (Seq.ViewR a), (Shrink2 a), (a, b), (a, b, c), All, Any, ArithException, Array i e, ArrayException, AsyncException, Blind a, Bool, CReal, Char, Complex a, Const a b, Constr, ConstrRep, DataRep, Debug.SimpleReflect.Associativity, DefName, Double, Down a, Dual a, Either a b, ErrorCall, Expr, First a, Fixity, Float,
14:30:46 <lambdabot> GeneralCategory, IOException, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Last a, Level i a, MaskingState, Maybe a, Natural, NonEmptyList a, NonNegative a, NonZero a, OrderedList a, Ordering, Positive a, Product a, Ratio a, Small a, Sum a, Sym a, Tree a, TyCon, TypeRep, Word, Word16, Word32, Word64, Word8, ZipList a,
14:30:46 <lambdabot> [a]
14:30:54 <crough> Well, you need an Ord, but I imagine it has that too
14:30:59 <nitrix> `Maybe a`, found it.
14:31:02 <crough> Whoops haha
14:32:24 <nitrix> Yeah it has an Ord too.
14:33:00 <nitrix> So dead simple :P
14:36:51 <crough> If you did want Nothing to short the whole list, then Sequence will work
14:37:03 <shanemikel> any idea why I don't have the 'sandbox' subcmd for cabal?
14:37:13 <crough> > fmap maximum (sequence [Just 2, Just 3])
14:37:15 <lambdabot>  Just 3
14:37:19 <crough> > fmap maximum (sequence [Just 2, Just 3, Nothing])
14:37:20 <lambdabot>  Nothing
14:37:55 <hexagoxel> shanemikel: do you have a 2 year old cabal version? :D
14:38:11 <nitrix> shanemikel: You're probably on ubuntu with a very old cabal.
14:38:29 <shanemikel> yeah, I'm on ubuntu :(
14:39:04 <nitrix> Either drop ubuntu; add new apt sources; or compile stack manually.
14:39:33 <nitrix> Oh wait, 4th, you can install the new stack with your old stack.
14:39:39 <nitrix> *cabal
14:39:45 <nitrix> Then switch to stack :P
14:39:57 <Enigmagic> or just download a precompiled copy of stack? :-)
14:39:59 <hexagoxel> nitrix: ah, i thought that was on purpose :p
14:40:34 <nitrix> hexagoxel: I got  a tiny bit ahead of myself, but yeah. Honestly, stack solves a lot of problems.
14:40:55 <shanemikel> yeah, I've done cabal install cabal-install
14:41:13 <shanemikel> I can keep my world right?
14:43:24 <hexagoxel> shanemikel: sure; that is the manual compilation option. make sure to add $HOME/.cabal/bin to PATH.
14:44:28 <shanemikel> so using a new version of cabal is completely compatible with the cabal packages I have installed already?
14:46:11 <hexagoxel> uhm.. i think so. you have to reconfigure your projects though, probably.
14:46:59 <hexagoxel> and if you start using sandboxes, it won't matter :p
14:47:10 * hackagebot remote-json-client 0.2 - Web client wrapper for remote-json  https://hackage.haskell.org/package/remote-json-client-0.2 (AndyGill)
14:48:55 <shanemikel> is there a command to pull a package into a directory like a git checkout + init a sandbox in it and build it?
14:49:15 <shanemikel> like `cabal checkout leksah && cd leksah && cabal sandbox init && cabal install`
14:49:34 <shanemikel> err.. git clone
14:49:47 <hexagoxel> cabal get foo; cd foo; cabal sandbox init; cabal install --dep; cabal configure; cabal build/run/whatever
14:50:17 <hexagoxel> also `cabal get -shead foo` if there is a repo and you want to clone that.
14:51:30 <hexagoxel> shanemikel: for executables, there also is https://github.com/quchen/cabal-install-bin
14:52:11 * hackagebot HTTP 4000.3.3 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.3 (GaneshSittampalam)
14:52:13 * hackagebot opml-conduit 0.4.0.1 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.4.0.1 (koral)
14:53:25 <hpc> i can't wait for HTTP 9000
14:54:23 <shanemikel> oh.. thanks hexagoxel that's handy
14:55:36 <pumita> Hello, I'm just playing a bit with monad transformers: http://lpaste.net/151981
14:55:53 <pumita> I don't know why I have to redefine `tick` in order to correctly execute inside ReaderT
14:56:36 <pumita> I had thought that with the definition for the Acum monad, it will be OK to just use it inside ReaderT
14:57:14 <pumita> the old tick definition was : tick = Ac ((), 1
14:57:34 <pumita> sorry, tick = Ac ((), 1)
15:03:54 <shanemikel> I don't know exactly, I'm new at this (as of yesterday) and have trouble wrapping my head around the Monad transformers, but in the wikibooks tutorial they use `lift` to lift functions over the 'inner' monad
15:04:29 <shanemikel> which, if the ReaderT uses the same sig as the MaybeT in the wiki would be Env
15:04:44 <shanemikel> err.. I mean Acum
15:09:09 <pumita> Thanks. I could define it though I had to redefine the old `tick`. Perhaps using lift, I'm gonna try it out.
15:12:14 <pumita> `lift` is the way to go :)
15:12:42 <pumita> "Sometimes, we need to access a monad more than one level down the stack, in which case we must compose calls to lift. Each composed use of lift gives us access to one deeper level." from RWH
15:13:02 <hexagoxel> pumita: btw Acum seems to be ~ Writer (Sum Int)
15:14:26 <pumita> hexagoxel: what does `Sum` mean?
15:14:41 <hexagoxel> (and if you use MonadWriter's `tell` for ticking, the lifting is implicit.
15:14:50 <pumita> monoid?
15:14:50 <hexagoxel> pumita: http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#t:Sum
15:15:03 <pumita> ah thanks :), let me check that out
15:16:09 <Phlogistique> hello
15:16:35 <Phlogistique> http://sprunge.us/EbcP I want the a in "items :: a" to be the same a as in my top level signature
15:16:39 <Phlogistique> can I do this?
15:17:02 <hexagoxel> Phlogistique: ScopedTypeVariables extension.
15:17:12 * hackagebot remote-json-server 0.2 - Web server wrapper for remote-json  https://hackage.haskell.org/package/remote-json-server-0.2 (AndyGill)
15:18:33 <hexagoxel> @where ScopedTypeVariables
15:18:33 <lambdabot> https://wiki.haskell.org/ScopedTypeVariables
15:19:56 <Gurkenglas> Wouldnt Phlogistique still need to annotate it "[a]"?
15:21:04 <hexagoxel> i haven't looked that closely.
15:21:28 <Phlogistique> Gurkenglas: indeed, but that's just a typo
15:21:35 <Phlogistique> though it still does not seem to work
15:21:56 <Phlogistique> http://sprunge.us/VLVY
15:21:57 <dmwit> A guess: you turned on STV, but didn't add `forall`.
15:22:07 <Phlogistique> dmwit: heh
15:22:43 <Phlogistique> dmwit: indeed :)
15:22:57 <dmwit> Seems to be everybody's first mistake with STV.
15:23:14 <dmwit> And it makes sense, too: STV's treatment of forall is totally weird.
15:23:28 * hexagoxel remembers to note that right away next time.
15:28:06 <dmwit> bernalex: You may be interested in http://hackage.haskell.org/package/monoid-extras-0.4.0.2/docs/Data-Monoid-Inf.html
15:30:22 <dmwit> i.e. if instead of `[Maybe Int]` you had `[PosInf Int]` or `[NegInf Int]`, then `Prelude.maximum` would Just Work.
15:30:23 <Phlogistique> is there a name defined somewhere for [minBound..maxBound] ?
15:30:30 <dmwit> ?hackage universe
15:30:30 <lambdabot> http://hackage.haskell.org/package/universe
15:31:13 <dmwit> Not identical to `[minBound .. maxBound]`, but better in some senses.
15:32:12 * hackagebot gnss-converters 0.1.3 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.3 (markfine)
15:33:03 <Phlogistique> dmwit: thanks
15:33:35 <dmwit> You might also like universe-base or universe-instances-base for their lighter dependency trees.
15:34:04 <nitrix> That's very cool.
15:34:59 <nitrix> > universe :: [Bool]
15:35:00 <lambdabot>      Couldn't match expected type ‚Äò[Bool]‚Äô with actual type ‚Äòa0 -> [a0]‚Äô
15:35:00 <lambdabot>      Probable cause: ‚Äòuniverse‚Äô is applied to too few arguments
15:35:00 <lambdabot>      In the expression: universe :: [Bool]
15:35:14 <nitrix> Oh.
15:35:28 <dmwit> lambdabot's universe value comes from I think uniplate or biplate or multiplate or something like that.
15:35:47 <nitrix> > universe :: Universe Bool
15:35:49 <lambdabot>      Not in scope: type constructor or class ‚ÄòUniverse‚Äô
15:35:55 <nitrix> Myeah, okay :/
15:36:35 <dmwit> Data.Universe Data.Universe.Instances.Reverse> universe :: [Bool -> Bool]
15:36:35 <dmwit> [[(False,False),(True,False)],[(False,False),(True,True)],[(False,True),(True,False)],[(False,True),(True,True)]]
15:38:20 <dmwit> Another fun example: `universeF :: [(Bool, Ordering)]` => `[(False,LT),(False,EQ),(False,GT),(True,LT),(True,EQ),(True,GT)]`
15:39:15 <dmwit> `take 10 (universe :: [(Integer, Integer)])` => `[(0,0),(0,1),(1,0),(0,-1),(1,1),(-1,0),(0,2),(1,-1),(-1,1),(2,0)]`
15:39:30 <dmwit> Okay, I'm done spamming code. Sorry, I got carried away.
15:39:50 <shanemikel> :t flip id
15:39:51 <lambdabot> b -> (b -> c) -> c
15:39:56 <shanemikel> can somebody explain that?
15:39:57 <shanemikel> :t id
15:39:58 <lambdabot> a -> a
15:40:04 <dmwit> :t id :: (a -> b) -> (a -> b)
15:40:06 <lambdabot> (a -> b) -> a -> b
15:40:20 <dmwit> or, closer to your `flip id` example:
15:40:24 <dmwit> :t id :: (b -> c) -> (b -> c)
15:40:27 <lambdabot> (b -> c) -> b -> c
15:40:49 <dmwit> Is this sufficient explanation? ("No" is a perfectly reasonable answer.)
15:41:09 <shanemikel> oh, yeah
15:41:34 <dmwit> Seems to be a popular question: http://stackoverflow.com/q/12339822/791604
15:42:07 <shanemikel> :t foldl (flip id)
15:42:08 <lambdabot> Foldable t => b -> t (b -> b) -> b
15:42:13 <shanemikel> :t foldl flip
15:42:15 <lambdabot>     Occurs check: cannot construct the infinite type: c ~ b -> c
15:42:15 <lambdabot>     Expected type: (a -> c) -> b -> a -> c
15:42:15 <lambdabot>       Actual type: (a -> b -> c) -> b -> a -> c
15:42:17 <dmwit> ?src ($)
15:42:17 <lambdabot> f $ x = f x
15:42:27 <dmwit> -- OR ($) = id
15:43:24 <portablejim> Ok, so I am trying to get my head around haskell.
15:43:58 <shanemikel> :t ($)
15:43:59 <lambdabot> (a -> b) -> a -> b
15:44:10 <shanemikel> :t (flip ($))
15:44:11 <lambdabot> a -> (a -> c) -> c
15:44:17 <shanemikel> okay
15:44:20 <shanemikel> makes sense
15:45:05 <shanemikel> so the only reason to use (flip id) is to omit the extra parens.. seeing as how it's just a wee bit less clear
15:45:18 <dmwit> not sure about that
15:45:50 <dmwit> It is possible that the author wanted to emphasize something about `id` being an identity.
15:46:02 <dmwit> Though I would bet that in most cases it's as you say.
15:46:39 <shanemikel> :t foldl
15:46:41 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:46:42 <shanemikel> :t foldr
15:46:43 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:47:09 <portablejim> I've seen haskell code with "type CBool = forall r. r -> r -> r" then "CTrue :: cBool" and "cTrue  x y = x" and I'm not sure what it is saying.
15:47:40 <hpc> that's the church encoding of booleans
15:48:54 <dmwit> portablejim: In a sense, the only thing you can do with `Bool` values is to do an if/then/else on them. `type CBool = forall r. r -> r -> r` embodies that observation: instead of storing a `Bool`, you store a function that does the if/then/else.
15:49:19 <dmwit> portablejim: In the sense that instead of `if foo then bar else baz` you would write `foo bar baz`.
15:50:21 <hpc> it's a very old idea, one of the formational concepts of functional programming
15:50:31 <hpc> but nowadays not terribly useful outside some odd cases
15:50:44 <Shockk> I have a question, though I don't know if this is the right place for it, but has anyone here used xmobar and set up its config file (.xmobarrc)?
15:50:46 <hpc> (church encoding, specifically)
15:51:00 <dmwit> Shockk: Probably more on-topic in #xmonad.
15:51:09 <Shockk> dmwit: okay, thanks
15:51:39 <hpc> huh, TIL xmobar is derived from xmonad
15:53:02 <srpx> What is the name of the (Œª x . (x x)) combinator?
15:53:49 <monochrom> I don't know, but I propose "nom nom"
15:54:03 <srpx> that's a good name but I need a single letter :P
15:54:11 <Mon_Ouie> I've seen people represent it as œâ
15:54:15 <dmwit> no
15:54:20 <dmwit> omega is two of those
15:54:22 <monochrom> no, nom nom is something else. (\x. x x) is a selfie.
15:54:34 <Cale> omega^(1/2)
15:54:34 <srpx> I was calling it W, but then I noticed it has another meaning already
15:54:42 <srpx> hahahha
15:54:42 <hpc> i would call it "trouble" ;)
15:55:12 <shachaf> I think people call (\x -> x x) M.
15:55:13 <dmwit> Hrm, maybe I'm wrong about omega.
15:55:16 <shachaf> But not in Haskell, of course.
15:56:10 <mniip> huh
15:56:13 <dmwit> Seems lower-case omega is `\x -> x x` and upper-case omega is that applied to itself.
15:56:21 <mniip> I've only heard (\x -> x x) being called omaega
15:56:24 <mniip> omega even
15:56:51 <EvanR> :t \x -> x x
15:56:52 <lambdabot>     Occurs check: cannot construct the infinite type: r1 ~ r1 -> r
15:56:53 <lambdabot>     Relevant bindings include x :: r1 -> r (bound at <interactive>:1:2)
15:56:53 <lambdabot>     In the first argument of ‚Äòx‚Äô, namely ‚Äòx‚Äô
15:56:59 <EvanR> its nonsense!
15:57:03 <shanemikel> is there a clean way to do (,x) without (flip (,)) x
15:57:09 <shanemikel> :t (flip (,))
15:57:10 <lambdabot> b -> a -> (a, b)
15:57:13 * hackagebot gnss-converters 0.1.4 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.4 (markfine)
15:57:19 <EvanR> > (,x) y
15:57:21 <lambdabot>  (y,x)
15:57:22 <dmwit> shanemikel: enable TupleSections
15:57:25 <mniip> @let omega :: (forall a. a -> a) -> a -> a; omega = \x -> x x
15:57:27 <lambdabot>  Defined.
15:57:28 <mniip> :D
15:57:59 <EvanR> what did you just do o_O
15:58:26 <mniip> the occurs check is only relevant for rank 1 types
15:58:58 <dmwit> He restricted the type so hard that omega lost its meaning.
15:59:07 <mniip> that too
15:59:30 <mniip> :t omega omega
15:59:32 <lambdabot>     Couldn't match type ‚Äòa1‚Äô with ‚Äòa0 -> a0‚Äô
15:59:32 <lambdabot>       ‚Äòa1‚Äô is a rigid type variable bound by
15:59:32 <lambdabot>            a type expected by the context: a1 -> a1 at <interactive>:1:1
15:59:33 <gfixler2> can anyone break down $'s new type for me?
15:59:34 <EvanR> oh so it only accepts the identity function
15:59:34 <mniip> aww
15:59:53 <mniip> gfixler2, it's obvious \o/
15:59:55 <hpc> ooh yes, someone explain this levity thing
16:00:03 <gfixler2> mniip: so easy, a beginner could do it
16:00:11 <gfixler2> there's a video on levity polymorphism
16:00:11 <mniip> forall (w :: Levity) (b :: TYPE w). (a -> b) -> a -> b
16:00:26 <gfixler2> half-hour - haven't watched it
16:00:44 <EvanR> it lets you use $ on functions involving unboxed
16:00:52 <mniip> gfixler2, basically, now there's a datakind Levity = Lifted | Unlifted
16:00:59 <mniip> and datakind TYPE = TYPE Levity
16:01:01 <gfixler2> leviy doesn't mean humor or frivolity
16:01:08 <hpc> type Levity = Whatevs
16:01:10 <gfixler2> it has to do with lifted types
16:01:15 <mniip> and type * = TYPE Lifted; type # = TYPE Unlifted
16:01:29 <gfixler2> is a datakind an adt?
16:01:34 <dmwit> why not just `forall (w :: Levity) (b :: w). (a -> b) -> a -> b`.
16:01:40 <gfixler2> or a kind-level adt?
16:01:40 <dmwit> Why is `TYPE` necessary?
16:01:48 <mniip> TYPE Lifted :: TYPE Lifted
16:01:51 <mniip> * :: *
16:01:51 <EvanR> w isnt the type
16:01:55 <EvanR> its the Levity
16:01:59 <gfixler2> and why not b :: Levity, and leave out the w?
16:02:22 <mniip> Levity is the type (kind)
16:02:32 <mniip> w is a specific levity value (type)
16:02:41 <dmwit> gfixler2: That part I can understand, at least.
16:02:55 <mniip> it's complicated because kinds = types
16:02:57 <dmwit> gfixler2: You want a type whose kind can be one of many things.
16:02:59 <hpc> what does working on unlifted types have to do with the enormous cafe thread about it working on ST?
16:03:00 <EvanR> TYPE :: Levity -> *
16:03:14 <Majiir> Does do-notation ever desugar to applicative operations?
16:03:23 <exio4> it does with ApplicativeDo
16:03:23 <mniip> hpc, nothing
16:03:33 <mniip> hpc, that is an absolutely irrelevant part
16:03:37 <gfixler2> are we in dependent types now?
16:03:40 <exio4> the ST hack is there
16:03:45 <geekosaur> hpc, ST is only in that head because someone asked if the lvity stuff had any impact on or relation to the special typing rule for ($) that makes it with with runST $ ...
16:03:46 <gfixler2> are we working with types as values?
16:03:49 <mniip> gfixler2, dependent kinds yes, dependent types no
16:03:55 <gfixler2> good grief
16:04:03 <geekosaur> (which it doesn't)
16:04:07 <hpc> ah, and then it exploded into "omg what is this type" and then stuff
16:04:13 * hpc now understands
16:04:18 <gfixler2> mniip: feeling parallels between this stuff and the beginner idris book stuff
16:04:20 <EvanR> gfixler2: well something like TYPE already exists as type families
16:04:22 <geekosaur> actually that was th eoriginal question
16:04:43 <geekosaur> somone saw the new type for ($) and blew up at the newuser-unfriendly type
16:04:48 <gfixler2> EvanR: sounds like there are prerequisites I'm missing, like type families
16:04:51 <Majiir> exio4, neat, thanks!
16:04:57 <geekosaur> ST was dragged in later and for no real reason
16:05:08 <EvanR> gfixler2: they are awesome ;)
16:05:18 <gfixler2> EvanR: can you give me the elevator pitch for them?
16:05:26 <mniip> gfixler2, oh yea btw
16:05:29 <dmwit> Did somebody explain why `TYPE` is needed, and we can't just have `data Levity = Star | Hash` or some such?
16:05:35 <mniip> because * :: *, it is also true that * :: *
16:05:39 <mniip> bizzare, I know
16:05:52 <EvanR> gfixler2: you can write functions that take 1 or more types and return a type
16:05:53 <mniip> that is, * is a concrete type
16:05:59 <hpc> mniip: but is * :: *?
16:05:59 <gfixler2> mniip: not because of taut?
16:06:29 <dmwit> mniip: ah, thanks
16:06:44 <gfixler2> EvanR: sounds like dependent types, or part thereof
16:06:46 <dmwit> mniip: so TYPE is a type family?
16:06:50 <mniip> no
16:07:02 <dmwit> whoops, then I didn't understand
16:07:03 <EvanR> gfixler2: not quite, because with dependent types you could write a function that takes a value and returns a type
16:07:06 <mniip> uhhhhh
16:07:13 <mick_> Hi, Haskell noob here. I would like to translate some C code into Haskell. The C code has two for loops (nested). I was thinking of using nested folds here. Is this the right way to go about it?
16:07:26 <mniip> there's TYPE which is a type constructor, and TYPE which is a data constructor
16:07:31 <mniip> both of those are promoted
16:07:38 <dmwit> mick_: If both the loops are folds, then yep.
16:07:49 <jmcarthur> mick_: It depends on what the loops are doing.
16:07:49 <EvanR> gfixler2: such as Fin 4, the type of numbers zero through 3
16:07:52 <mick_> cool! thanks dmwit
16:08:20 <jmcarthur> mick_: Often there is a higher level way to express it than with a bunch of nested folds
16:08:23 <mniip> they are promoted twice even (I think?)
16:08:40 <mniip> so TYPE the data constructor becomes a kind constructor
16:08:44 <mick_> can you elaborate jmcarthur
16:08:45 <mniip> and TYPE Lifted is a kind
16:08:59 <mick_> or point me to an example on the internet
16:09:15 <dmwit> * :: * => TYPE {- data constructor -} Star :: TYPE {- type constructor -} Star
16:09:29 <dmwit> but that can't be right
16:09:30 <mniip> no
16:09:36 <gfixler2> mick_: as a noob, they might just confuse
16:09:54 <mniip> TYPE {- datacon -} Lifted :: TYPE {- promoted datacon -} Lifted
16:10:05 <mick_> oh ok. good point
16:10:14 <jmcarthur> mick_: For example, if one of the loops is just computing a sum, you could just use the sum function.
16:10:16 <gfixler2> mick_: for example, if you're making the lips to create the cartesian product of the two lists, you can use the list applicative
16:10:18 <mick_> will stick to my limits ;)
16:10:18 <mniip> dmwit, imagine instead it said
16:10:34 <dmwit> mniip: ...but also `TYPE {- datacon -} Lifted :: TYPE {- tycon -}`?
16:10:35 <gfixler2> s/lips/loops/
16:10:36 <mniip> data T = TYPE Levity
16:10:38 <pumita> Hello, when I'm not using `<-` inside a `do`, does it mean that I'm using `>>` instead of `>>=`?
16:10:49 <mniip> now, forget about T because it's not used anywhere
16:10:59 <EvanR> mniip: i thought i understood the $ thing, and thanks to you i have no idea anymore ;)
16:11:14 <hpc> pumita: "x <- m" roughly translates to "mm >>= \x ->"
16:11:15 <dmwit> mniip: So if we have a special rule for `TYPE`, why not just have a special rule for `Levity`'s constructors in the first place?
16:11:17 <mick_> it's actually to fill a table of values
16:11:18 <hpc> *m
16:11:25 <mick_> a matrix if you like
16:11:40 <mniip> dmwit, special rule?
16:11:41 <gfixler2> mick_: a lists of lists?
16:11:50 <mniip> lack of special rules is what makes thiis beautiful
16:11:59 <EvanR> dmwit: maybe its just aesthetic
16:12:04 <dmwit> mniip: Yes, although the normal rule would say `TYPE foo :: T`, we in fact say `TYPE foo :: TYPE Star`.
16:12:23 <pumita> hpc: yes, so "do {m;a}" is the same as "m >> a" or "m >>= (\_ -> a)" ? I guess >> definition is >>= (\_ -> ...) though
16:12:27 <hpc> pumita: now for the irrelevant details, there's a special case for when it's at the end of a do-block so you get a nice error message, and when you do pattern matching on the same line it adds _ -> fail "something or other"
16:12:50 <mniip> 1455062981 [03:09:41] <EvanR> mniip: i thought i understood the $ thing, and thanks to you i have no idea anymore ;)
16:12:57 <mniip> this feels suddenly real now o.O
16:13:03 <hpc> ($) is a lie
16:13:09 <hpc> haskell is secretly anti-capitalist
16:13:21 <dmwit> mniip: yay
16:13:29 <gfixler2> I stopped liking US money
16:13:35 <dmwit> mniip: shared confusion is more fun
16:13:36 <EvanR> so about the ST thing, there is a hack to make $ work with it? or to make runST work at all?
16:13:45 <jmcarthur> it's just for ($)
16:13:53 <hpc> EvanR: the hack is specifically for runST $ do ...
16:14:20 <hpc> because of that pesky (forall s. s) which deliberately makes things difficult
16:14:29 <hpc> but in a slightly too broad way
16:14:56 <EvanR> does that mean you cant write your own ST?
16:15:02 <gfixler2> better question from me: what specifics aspects of haskell do I need to understand before ($) will again make sense to me?
16:15:03 <mniip> so wait
16:15:05 <mniip> it's more like
16:15:11 <mniip> data * = TYPE Levity
16:15:23 <gfixler2> e.g. type families
16:15:24 <mniip> where * = TYPE Lifted...?
16:15:38 <megaTherion> Is there an haskell beginner chan?
16:15:39 <dmwit> mniip: I'm not sure that made sense.
16:15:40 <EvanR> gfixler2: well thats unrelated, the Levity thing is a whole new thing
16:15:42 <pumita> do semantics: do {p} = p; do {p; stmts} = p >> stmts; do {x <- p; stmts} = p >>= (\x -> stmts)
16:15:50 <gfixler2> megaTherion: #haskell_beginners
16:15:58 <mniip> OH
16:16:00 <mniip> of course
16:16:04 <mniip> I misiniterpreted everything
16:16:09 <mniip> *now* it makes sense
16:16:12 <dmwit> megaTherion: There is, but it's quite low traffic. Common protocol is to ask here; when other folks are locked in an advanced debate, you can move the discussion of the beginner question there.
16:16:13 <shachaf> megaTherion: This channel is meant to be suitable for beginners.
16:16:16 <dmwit> megaTherion: ...as now =)
16:16:20 <hpc> megaTherion: also to a not quite so gratuitous extent here
16:16:21 <megaTherion> well ok thanks
16:16:24 <jmcarthur> megaTherion: #haskell-beginners is a think, but really, just stay here :)
16:16:24 <mniip> data TYPE (a :: Levity) -- with no constructors
16:16:28 <jmcarthur> *a thing
16:16:33 <shachaf> That other channel is unaffiliated with this one.
16:16:41 <hpc> jmcarthur: no thinking allowed!
16:16:59 <megaTherion> I know how to handle IO( ) but Im not good with understanding monads, I've read about them though - how do I get the contents (state?) of IO(a,b,c) that is how to access these a,b,c variables?
16:17:12 <mniip> EvanR, dmwit, sorry for confusing you
16:17:27 <mniip> I figured it out for real now
16:17:30 <dmwit> mniip: Okay. You still have to have a special rule saying what type to give to liftings, but I guess the point is it can be the same rule for all liftings.
16:17:44 <mniip> yes
16:17:50 <mniip> everything data/newtype is *
16:17:51 <hpc> megaTherion: minor point to start out, it's generally written IO (), and IO (a, b, c)
16:17:53 <pumita> sorry, here they're: do semantics: do {p} = p; do {p; stmts} = p >> do {stmts}; do {x <- p; stmts} = p >>= \x -> do {stmts}
16:18:09 <koz_> OK, jle`, I'm gonna try and make Stream a Monad instance.
16:18:31 <hpc> megaTherion: it'll work the way you wrote it, but sometimes it's indicative of a misunderstanding in how haskell syntax works, so i thought i would mention it
16:18:43 <hpc> and might save you loads of trouble down the line
16:18:58 <megaTherion> hpc: ok thanks, well Im refering to recvFrom inside Network.SOcket
16:19:01 <dmwit> mniip: Okay. Show me the type of ($) again now, please... `forall (w :: Levity) (b :: TYPE w). (a -> b) -> (a -> b)`?
16:19:09 <megaTherion> Im not sure how to evaluate IO (a,b,c) and get its contents (if any)
16:19:10 <mniip> yes
16:19:12 <jle`> koz_: good luck!
16:19:25 <mniip> what we're saying here is that b is either * or #
16:19:30 <hpc> megaTherion: so, you know how to use getLine?
16:19:51 <koz_> jle`: I might need it - I'm still thinking how join would be implemented for it.
16:19:57 <dmwit> mniip: phew, tricky
16:20:01 <koz_> It'd need to go from a stream of streams to a stream...
16:20:01 <jle`> koz_: honestly thinking about it as (Natural -> a) might be the "fastest" way to get the Monad instance, but thinking about it in terms of join and the laws might be more fun/enlightening
16:20:19 <jle`> then afterwards you will look at the (->) Natural formulation and be like, "oh, it's that simple?"
16:20:20 <koz_> jle`: I'm looking for fun and enlightening.
16:20:24 <jle`> wouldn't want to rub you of the fun :)
16:20:29 <megaTherion> hpc: ah with <-?
16:20:37 <megaTherion> hpc: so Im doing let (a,b,c) <- ...?
16:20:40 <hpc> megaTherion: yeah, it's exactly the same
16:20:44 <hpc> with a tuple instead of a string
16:20:47 <megaTherion> oh
16:20:51 <megaTherion> I didnt get it, thanks :D
16:20:53 <EvanR> mniip: so another take away from this is that $ will never work with return types that have no Levity
16:20:53 <dmwit> megaTherion: no `let`
16:20:54 <hpc> :t getLine
16:20:56 <lambdabot> IO String
16:21:06 <mniip> EvanR, "have no levity"?
16:21:15 <EvanR> mniip: if there were such a thing
16:21:22 <dmwit> megaTherion: To a first approximation, `let` is for binding pure values.
16:21:34 <mniip> every inhabited type is a 'TYPE w'
16:21:39 <mniip> fsvo known or unknown w
16:21:48 <EvanR> mniip: doesnt $ work on type ctors?
16:21:55 <mniip> what
16:22:14 <jle`> koz_: so, think of how to Stream (Stream a) -> Stream a, with the caveat that: join . return = id, and join . fmap return = id
16:22:14 <dmwit> EvanR: I don't think so, no.
16:22:16 <EvanR> Maybe $ Int? guess not
16:22:29 <dmwit> EvanR: (And I know some folks that are kind of annoyed by that. ;-)
16:22:34 <megaTherion> dmwit: I see and IO (...) is unpure
16:22:49 <Phlogistique> I want to copy a directory tree. Should I use Shelly, Turtle, or something else entirely?
16:22:52 <dmwit> megaTherion: That's an okay way of thinking about it for now, yeah.
16:22:58 <mniip> yeah no
16:23:02 <koz_> jle`: I'm thinking. Would making a Stream a out of the first elements of the Stream (Stream a) work?
16:23:04 <mniip> ($) :: (k -> l) -> k -> l
16:23:10 <jle`> koz_: that's a nice guess
16:23:10 <EvanR> dmwit: so we got levity-polymorphic functions before kind polymorphic functions
16:23:12 <mniip> (typelevel $)
16:23:14 <Cale> megaTherion: An important distinction in Haskell is the difference between evaluation of expressions, which is the process of reducing expressions to values, and which (generally) has no side effects, and the separate process of execution of IO action values, which carries out the steps they describe, and generally has lots of effects.
16:23:27 <hpc> megaTherion: the pedantic answer is IO (...) is also pure, but you'll learn that silliness later
16:23:33 <jle`> koz_: another law: join . fmap join = join . join
16:23:37 <koz_> jle`: But doesn't this fail the join . return = id test?
16:23:43 <mniip> EvanR, what
16:23:49 <Cale> megaTherion: When you write  v <- x  inside of a do-block for an IO action, it means "execute the IO action called x, and name its result v"
16:23:50 <mniip> pretty sure kind polymorphic functions exist
16:23:56 <jle`> koz_: yes, it does
16:24:03 <koz_> Yeah, I thought as much.
16:24:16 <Cale> megaTherion: The do-block as a whole then describes an IO action (whose result is the result of the last action in it)
16:24:18 <maerwald> for you as a programmer, it is safe to think of IO as "unpure", although it's not technically correct to call it that way
16:24:30 <EvanR> mniip: i mean, i cant have a function such as id which also works on types
16:24:34 <maerwald> but the nitpick doesn't really help you with thinking about it
16:24:34 <EvanR> and data kinds
16:24:37 <Cale> megaTherion: Make sense?
16:24:41 <mniip> EvanR, no you can't promote functions
16:24:52 <mniip> you can write a type family though
16:24:58 <koz_> jle`: OK, I have *absolutely* no clue how to do this.
16:25:05 <koz_> Everything I think of seems to fail some test.
16:25:07 <jle`> an `IO a` is a pure value, but you can say that it *describes* impure operations
16:25:13 <jle`> fsvo 'impure'
16:25:17 <mniip> I even wrote a type family for reducing types to WHNF
16:25:30 <EvanR> an IO a is a command
16:25:40 <megaTherion> Cale: yes I think so, well I've been reading http://learnyouahaskell.com/ a lot - but I still have almost zero experience when to use either of them...
16:25:49 <Cale> megaTherion: *Evaluating* the IO action called getLine will do very little which is visible apart from warming up your CPU ever so slightly (IO is an abstract data type, so it's hard to see what the expressions are reducing to)
16:25:57 <jle`> koz_: try seeing what happens when you 'return' a stream, and how you can get the original stream out of it
16:26:12 <jle`> imagine countFrom n = n :~ countFrom (n + 1)
16:26:21 <jle`> countFrom 1 = 1 :~ 2 :~ 3 :~ 4 ... etc.
16:26:32 <Cale> megaTherion: But *executing* it will cause the program to read a line of text from the terminal, and produce the String that the user typed as the result.
16:26:39 <jle`> if i `return (countFrom 1)`, i get an infinite stream of 1 :~ 2 :~ 3 :~ 4 ... 's
16:26:41 <pavonia> mniip: Could you show this type family?
16:26:42 <koz_> jle`: I assume by 'return a stream' you mean calling 'return x' for some x to produce a Stream of xs?
16:26:52 <jle`> call "return" on a Stream a
16:26:53 <koz_> Or do you mean return on a Stream x?
16:26:54 <koz_> Ah.
16:26:56 <jle`> to get Stream (Stream a)
16:27:04 <jle`> and now, from there, how to get back the original stream using 'join'
16:27:14 <megaTherion> Cale: so <- are only valid inside do blocks?
16:27:21 * hackagebot microlens-aeson 2.1.1 - Law-abiding lenses for Aeson, using microlens.  https://hackage.haskell.org/package/microlens-aeson-2.1.1 (fosskers)
16:27:27 <Cale> megaTherion: yeah, it's part of the syntax of do-notation
16:27:27 <koz_> Well, return on a Stream would just be a repeat of that Stream over and over, right?
16:27:31 <jle`> there's one sort of "obvious" way of doing this: join (xs :~ xss) = xs, but we know that that fails join . fmap join = id
16:27:34 <mniip> Cale, evaluating getLine will do nothing
16:27:34 <koz_> Like, a 2D stream I guess?
16:27:40 <jle`> yes
16:27:41 <mniip>  > getClosureType getLine
16:27:41 <mniip> FUN_STATIC
16:27:50 <Cale> mniip: Fair enough :)
16:27:50 <EvanR> o_O
16:27:51 <koz_> Like the diagonalization tables you see to demonstrate Cantor's diagonal argument.
16:28:02 <jle`> mhm
16:28:10 <jle`> but 'return' on a stream just gives the same stream over and over again ifninitely
16:28:18 <Cale> mniip: getLine might have been defined as a function application though, in which case it might do a little bit of evaluation.
16:28:23 <jle`> okay, try thinking about this: `join . fmap return`.
16:28:29 <jle`> what happens when you call "fmap return" on a Stream?
16:28:38 <hpc> megaTherion: a more interesting example would be something like
16:28:38 <mniip> true
16:28:49 <hpc> let fixIt = putStrLn "there i fixed it"
16:28:50 <mniip> it might be a do-block
16:28:57 <koz_> When you fmap return on a Stream, you get a Stream of Streams, with each 'inner' stream being an infinite sequence of that value.
16:28:57 <Cale> yeah
16:29:01 <jle`> yes
16:29:09 <Cale> mniip: Or defined in terms of hGetLine or something :)
16:29:12 <hpc> fixIt evaluates to "this is a blob of magic that when executed, fixes something"
16:29:15 <hpc> :P
16:29:16 <koz_> So you would go from 1, 2, 3, ... to 1, 1, 1, ...., 2, 2, 2, .... 3, 3, 3, .... etc
16:29:30 <jle`> so, there's one obvious way to get the original stream from *that*, and that's 'fmap head'. 
16:29:34 <EvanR> hpc: but fix error somehow does not
16:29:40 <jle`> but, that fails join . return = id
16:29:41 <koz_> jle`: But that fails a test as well.
16:29:45 <hpc> EvanR: ;)
16:29:46 <jle`> yes, that fails the other test
16:29:51 <jle`> can you think of a way that passes both? :D
16:29:52 <mniip> Cale, sounds like it's inlined into one IO datum (which is a newtype anyway so we see the FUN_STATIC of the underlying State# function)
16:29:56 <EvanR> hpc: haskell is hard
16:30:05 <koz_> jle`: Does it involve diagonalization somehow?
16:30:14 <gfixler2> EvanR: and a little harder now, thanks to $
16:30:15 <koz_> Like, take the 'diagonal' of the 2D stream?
16:30:19 <jle`> 'head' passes join . return = id; 'fmap head' passes join . fmap join = id, but they each fail the other
16:30:23 <jle`> koz_: hm...does that work?
16:30:25 <mniip> pavonia, http://lpaste.net/151837
16:30:53 <Cale> megaTherion: Anyway, implementation details aside, the 'main' of a compiled program will itself be an IO action, which will in turn typically be built up from many other IO actions, executing them in turn and doing things with the results.
16:31:06 <pavonia> mniip: Thanks!
16:31:13 <EvanR> gfixler2: honestly, $ should still work exactly the same. the change to the type was, aiui, to be more honest about what it could do. The only "hard" part is trying to explain to new people how or why you should ignore the type of $
16:31:16 <koz_> jle`: It passes join . return = id *I think*.
16:31:23 <maerwald> I find this distinction somewhat silly to teach newcomers. A regular programmer thinks of a function as a whole, including evaluation *AND* execution. So for him, it's still impure then.
16:31:26 <Cale> megaTherion: You might get some input from the user, process it with some ordinary String -> String function, and then print out the result, as a simple example...
16:31:39 <koz_> And I *believe* it also passes join . fmap join = id.
16:31:39 <gfixler2> EvanR: having people explain things to me is most of my Haskell experience :)
16:31:39 <Cale> main = do v <- getLine; putStrLn (reverse v)
16:31:45 <megaTherion> Cale: yeah thats what I know already, but the mechanics werent so clear yet...
16:32:04 <EvanR> maerwald: but IO a's are not functions
16:32:07 <mniip> EvanR, I think levity polymorphism can be hidden with a flag akin to -fprint-explicit-foralls
16:32:12 <Cale> maerwald: Hm? I think in terms of evaluation and execution being separate processes.
16:32:15 <maerwald> EvanR: did I say that?
16:32:19 <dmwit> koz_: Yes, that's one way.
16:32:27 <Cale> maerwald: I think it's very very helpful to do so consistently.
16:32:32 <EvanR> maerwald: assumed youre talking about distinction between pure functions and IO actions
16:32:41 <maerwald> Cale: maybe it is, but I've seen people being confused about it too
16:32:43 <koz_> dmwit: It actually works?
16:33:18 <mniip> 1455064245 [03:30:45] <EvanR> maerwald: but IO a's are not functions
16:33:20 <mniip> but but but
16:33:24 <dmwit> koz_: Well, prove the laws yourself. =)
16:33:27 <EvanR> no FUNGI-STATIC
16:33:30 <dmwit> koz_: Or what's the point of the exercise?
16:34:51 * mniip refrains on commenting on the internal workings of IO in order to not scare people trying to understand it off
16:34:59 <mniip> s/on/from/
16:35:16 <maerwald> yes, I don't think people should go into compiler details at all when it comes to IO
16:35:17 <EvanR> koz_: yeah i realized this the other day that many join opeations are really traces over the diagonal
16:35:33 <maerwald> but then again, there are pitfalls
16:35:37 <koz_> dmwit: I guess I don't know how I would prove that the laws hold. I strongly feel intuitively they would, but I can't prove it.
16:35:37 <hpc> ghc's IO implementation is pretty great though
16:35:46 <mniip> it is
16:35:48 <maerwald> so IO is really awkward in the end
16:35:50 <hpc> definitely something for a new programmer to get back to later
16:36:00 <mniip> @package acme-timemachine
16:36:00 <lambdabot> http://hackage.haskell.org/package/acme-timemachine
16:36:05 <mniip> still proud of that one
16:36:18 <megaTherion> Cale: I've another question in mind, a thing I cant understand - I have read about how to define data types with data... so far so good, I've read about record syntax to me it seems like data Foo = Foo { a :: Int, b :: Int, c :: Int } could be what a struct in C is...
16:36:41 <mniip> megaTherion, kind-of sort-of
16:36:49 <gfixler2> IO is the trash bag we put the whole world into, because reality is a mess, and we don't want it in our code
16:36:58 <johnw> gfixler2!
16:37:08 <megaTherion> but a, b and c are always in general scope... I can use them anywhere in the file?
16:37:10 <maerwald> gfixler2: or you could design a proper effect system like Idris :P
16:37:20 <gfixler2> maerwald: only a few chapters into the book so far :)
16:37:24 <megaTherion> so they are somehow not related to foo... but I've to give them a foo object(?) to operate on
16:37:30 <mniip> megaTherion, a, b, c are functions
16:37:41 <mniip> they take a Foo object and return the respective field
16:37:46 <megaTherion> mniip: and functions are always global scope?
16:37:53 <mniip> yes
16:38:04 <koz_> megaTherion and mniip: Module scope right?
16:38:05 <latro`a> er, no, but these ones are
16:38:08 <megaTherion> mniip: so I cannot have another data definition with a, b, c?
16:38:13 <mniip> well, unless where- and let-scoped
16:38:18 <mniip> but datas can't do that
16:38:31 <latro`a> you can't locally define types (except local to a module, not any more locally)
16:38:46 <EvanR> maerwald: re: proper effect system... have you had success with that one?
16:38:55 <latro`a> but yes, once you've done that, you've effectively defined a functoin a :: Foo -> Int, so you can't define something else named a within the same scope
16:39:01 <latro`a> *function
16:39:07 <maerwald> EvanR: meaning what?
16:39:51 <dmwit> koz_: Okay. Shall we try to work through one of the laws together?
16:39:56 <Phlogistique> http://sprunge.us/JZTL something looks terribly wrong
16:39:56 <dmwit> koz_: Which law do you want to try to prove?
16:40:01 <maerwald> EvanR: I'm so sick of haskell IO that I am considering to write IO-heavy projects in rust, if that answers your question. Idris is not really there yet.
16:40:03 <koz_> dmwit: If you would, that'd be great. join . return = id please.
16:40:14 <Phlogistique> did I somehow get two different versions of FilePath?
16:40:28 <dmwit> koz_: Okay, cool. Just so we're on the same page, will you show your definitions for `join` and `return`, please?
16:40:48 <gfixler2> maerwald: what about Haskell's IO bothers you?
16:40:54 <koz_> dmwit: I'm trying to think through how to put those into code right now.
16:40:55 <EvanR> maerwald: after reading this http://lambda-the-ultimate.org/node/4525 and being inspired, i found some IO-related situations not feeling quite right
16:41:31 <koz_> The intuition of 'join' is that it diagonalizes over a 2D stream (meaning Stream (Stream a)). So we take the first element of the first stream, second element of the second stream, etc.
16:41:54 <koz_> return is just fmap repeat.
16:41:59 <maerwald> gfixler2: apart from a lot of pitfalls, I dislike the way exceptions work and that IO is exactly that: a trashbag for all kinds of effects. Not really fine-grained.
16:42:04 <mniip> gfixler2, data RealWorld = RealWorld { particles :: [Atom]; fields :: Position -> Field; metric :: Metric }; type IO = State RealWorld
16:42:06 <mniip> :D
16:42:22 <gfixler2> maerwald: sounds like the paper EvanR linked to will explain more of this for me
16:42:23 <mniip> wait, why did I call that Atom
16:42:46 <EvanR> gfixler2: it uses dependent types ;)
16:42:56 <EvanR> goodie goodie
16:43:04 <gfixler2> so much to learn
16:43:22 <mniip> Phlogistique, looks like you did
16:43:22 <EvanR> its not really necessary just the explanatory part of the paper uses it
16:43:32 <jle`> koz_: once you prove join . return = id and (join . fmap join) = id, try (join . join) = (join . fmap join)
16:43:36 <jle`> but
16:43:39 <mniip> some package depending on one version and some on another
16:43:40 <EvanR> to square concepts away properly
16:43:41 <dmwit> koz_: Okay, so let's fix some concrete definitions.
16:43:44 <Gurkenglas> modify (\world -> world{particles = []} -- MWAHAHA
16:43:51 <dmwit> koz_: For simplicity, let's use `type Stream = []`.
16:43:51 <maerwald> and then you have libraries which have their gigantic monad transformer type, which ofc allows IO too, just in case you need it... ugh
16:44:01 <dmwit> koz_: (And we'll just remember that `[]` is not an allowed constructor.)
16:44:02 <koz_> dmwit: OK.
16:44:05 <gfixler2> here's a poll: what action helps you learn these new principles, etc., most quickly?
16:44:12 <mniip> 'action'?
16:44:16 <gfixler2> just reading? pondering? reading hackage?
16:44:22 <gfixler2> mniip: see examples
16:44:24 <mniip> 'return' probably
16:44:25 <dmwit> koz_: So we'll write `return = repeat` or, to flesh that out, `return x = x:return x`.
16:44:45 <mniip> gfixler2, experimenting with it
16:44:46 <koz_> OK.
16:44:50 <mniip> partially reimplementing it
16:44:56 <hpc> my favorite action is (fail "success")
16:44:59 <gfixler2> mniip: that was my guess, and what I'm not doing nearly enough of
16:45:13 <dmwit> koz_: And we'll write `join ((x:xs):xss) = x : join (map (drop 1) xss)`.
16:45:20 <gfixler2> hpc++
16:45:22 <koz_> OK, I follow.
16:45:27 <dmwit> cool
16:45:28 <mniip> I mean, I did show off my getClosureType thing earlier :p
16:45:46 <dmwit> So now let's try evaluating `join (return x)`.
16:46:24 <dmwit> Well, the first thing `join` does is pattern match. So we'll have to expand `return x` a bit to satisfy that match.
16:46:33 <mniip> I also like this one
16:46:35 <mniip>  > subValue (1, "hello", ()) 1 :: String
16:46:35 <mniip> "hello"
16:47:07 <mniip>  > subValue (Just True) 0 :: Bool
16:47:07 <mniip> True
16:47:40 <dmwit> koz_: Ah, by the way: since we know `x` is a `Stream`, let's make it a bit more concrete and say in particular `x = x0:x1:x2:...`.
16:47:55 <koz_> dmwit: OK.
16:48:10 <mniip> hpc, hahahah
16:48:17 <dmwit> koz_: Okay, so now we're ready to evaluate: `join (return x)` = `join (x : return x)` = `join ((x0:...) : return x)`
16:48:25 <mniip> that's mzero though
16:48:30 <mniip> which is kinda... empty :)
16:48:33 <EvanR> gfixler2: honestly i never found a good 1 stop shop to explain all this. but last week i said fuckit and went through each well known extension and did what i couldnt to figure out what it did. i still am not too sure what to do with it all. as for dependent types i recommend playing with idris or agda or coq
16:48:44 <dmwit> koz_: So we've now evaluated `return x` enough to take a step with th edefinition of `join`, which says
16:48:45 <EvanR> s/couldnt/could/
16:49:12 <dmwit> koz_: `join ((x0:...) : return x)` = `x0 : join (map (drop 1) (return x))`
16:49:34 <EvanR> gfixler2: a commonly suggested book is software foundations which uses coq
16:49:57 <koz_> dmwit: OK.
16:50:04 <dmwit> koz_: So now we can observe that `map (drop 1) (return (x0:x1:...))` = `return (x1:x2:...)`
16:50:18 <dmwit> koz_: ...you might not believe this leap, which we can prove separately if you're uncomfortable with it.
16:50:24 <gfixler2> EvanR: thanks - it's been on my list for a while - need to bump it to the front
16:50:26 <koz_> dmwit: No, I believe it.
16:50:58 <dmwit> koz_: Right, so we've now reached the state `join (return (x0:x1:x2:...)) = x0 : join (return (x1:x2:...))`.
16:51:03 <gfixler2> EvanR: I've been planning to 'grok' libraries one at a time - just pick one per night, and try everything in it until all of it makes sense
16:51:15 <gfixler2> maybe a few nights for lens
16:51:37 <maerwald> haha
16:51:38 <koz_> dmwit: The next step would be x0 : x1 : join (return (x2:x3:...)) right?
16:51:41 <dmwit> koz_: And now we appeal to the induction hypothesis that `join (return (x1:x2:...))` = `x1:x2:...`.
16:51:47 <dmwit> koz_: right
16:51:48 <EvanR> gfixler2: good idea, i should really do that
16:52:01 <roboguy`> I'm taking a class that uses Software Foundations and Chlipala's book on coq as its textbooks. Software Foundations at least seems like it has pretty reasonable understandability overall
16:52:07 <mniip> gfixler2, I still find new things in lens every time
16:52:10 <maerwald> "a few nights for lens" -- why do I have the feeling that will not suffice? ;)
16:52:17 <mniip> even in the goddamn Lens type itself
16:52:18 <gfixler2> mniip: and diagrams
16:52:27 <gfixler2> maerwald: :)
16:52:33 <mniip> like recently I think I made another breakthrough in what Lens is
16:52:42 <koz_> dmwit: So basically, that construction would lead to x0 : x1 : x2 ... and so forth?
16:52:50 <dmwit> koz_: Right!
16:52:59 <koz_> dmwit: And that's just our original stream.
16:53:00 <gfixler2> mniip: I've watched SPJ's talk on it a few times now
16:53:10 <gfixler2> each time I understand a few more minutes into it, before I'm lost again
16:53:10 <EvanR> "what is lens really"
16:53:25 <dmwit> koz_: So now we have `join (return (x0:x1:...))` = `x0:x1:...` = `id (x0:x1:...)`.
16:53:31 <dmwit> koz_: That is to say, `join . return = id`.
16:53:36 <maerwald> Just don't use it until you really need it. Probably saves you a lot of time.
16:53:53 <koz_> OK, that makes sense. Thank you for walking me through that. Now I need to try join . fmap join = id.
16:54:03 <dmwit> koz_: g'luck!
16:54:11 <mniip> Lens s t a b, splits s into a, and one-hole context s, which is the same as one-hole context of t. Then it takes a function a -> f b, and plugs b into the one-hole context producting f t
16:54:27 <mniip> of s*
16:54:29 <dmwit> koz_: Oh, and by the way, you should settle on a definition for `fmap` before trying to prove that one, of course.
16:54:31 <koz_> Well, fmap join applies to (Stream (Stream (Stream a))) right?
16:54:46 <koz_> dmwit: There is one already - I defined a Functor instance for Stream.
16:54:55 <dmwit> koz_: Okay, what did you choose as the definition?
16:55:20 <koz_> dmwit: fmap f (Cons x sx) = Cons (f x) (fmap f sx)
16:55:33 <dmwit> I don't think `join . fmap join = id` is a correct statement of a monad law.
16:55:33 <mniip> oh wait
16:55:40 <koz_> Where 'data Stream a = Cons a (Stream a)'.
16:55:42 <mniip> s -> (a, b -> t)
16:55:43 <dmwit> koz_: Yep, that looks perfectly fine!
16:55:44 <mniip> who-a
16:55:52 <gfixler2> the first lens law describes how to go about learning lens
16:55:56 <gfixler2> "You get back what you put in."
16:55:59 <koz_> dmwit: I might be misremembering what jle` said there.
16:56:14 <dmwit> koz_: Perhaps you would like to prove that `join . fmap join = join . join`
16:56:43 <jle`> koz_: yeah, they're join . return = join . fmap return = id, and join . join = join . fmap join
16:56:54 <mniip> now
16:56:54 <koz_> jle`: Yup, was misremembering, sorry.
16:57:22 * hackagebot persistable-types-HDBC-pg 0.0.1.2 - HDBC and Relational-Record instances of PostgreSQL extended types  https://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.1.2 (KeiHibino)
16:57:23 <koz_> OK, so let me see here. join . join would collapse a Stream (Stream (Stream a)) into a Stream a?
16:57:24 <mniip> Applicative in Traversal gives us extra power, we can actually produce a multi-hole context and successfully plug functor-ed values back in
16:57:28 <jle`> koz_: yes
16:57:35 <mniip> :O
16:57:38 <dmwit> koz_: Right. And `join . fmap join` collapses it "in the other way".
16:57:39 <mniip> suddenly everything makes sense
16:57:48 <EvanR> mniip: glad to hear it ;)
16:58:20 <koz_> dmwit: Let me see if I understand you correctly. join . fmap join first diagonalizes the 2D streams into a 2D stream, then diagonalizes that 2D stream.
16:58:20 <EvanR> what is a "one hole context"
16:58:29 <mniip> uhhhh
16:58:51 <koz_> while join . join is 3D stream -> 2D stream -> 1D stream.
16:59:15 <mniip> I don't have a better explanation than 'imagine we took something parametrised over a and took one occurence of a out'
16:59:24 <dmwit> koz_: `join . fmap join` diagonalizes the two inside streams first; `join . join` diagonalizes the two outside streams first.
16:59:42 <EvanR> mniip: ok, what would something like that look like
16:59:49 <dmwit> koz_: Both of them do a 3D stream -> 2D stream -> 1D stream transformation. I think. So I'm not sure what distinction you were trying to draw.
16:59:55 <mniip> it is somehow related to zippers too
16:59:58 <geekosaur> yes
17:00:05 <mniip> one-hole context + extracted value = zipper
17:00:06 <koz_> dmwit: The distinction was exactly what you just described.
17:00:09 <koz_> I just have bad wording.
17:00:12 <EvanR> mniip: jokes to left of me, clowns to the right?
17:00:18 <dmwit> koz_: great =)
17:00:26 <mniip> I haven't read the paper actually
17:00:30 <mniip> is it referring to the list zipper?
17:00:50 <dmwit> mniip: I think it discusses zippers generally.
17:00:50 <EvanR> that paper involves zippers and other things
17:00:54 <koz_> OK, so that object would look like ((x0:x0:x0...), (x1:x1:x1:...), ...).
17:01:02 <mniip> well
17:01:07 <koz_> Wait, that's not deep enough right?
17:01:23 <mniip> ListZipper a = ([a], a, [a])
17:01:31 <koz_> It's a Stream of Streams of Streams.
17:01:35 <jle`> koz_: once you're comfortable with diagonalization, consider how the `(->) Natural` Monad instance works, and how they are linked :)
17:01:40 <megaTherion> btw. why are my generated executables so big, like 1,2MB or more (ghc on linux) - is that normal?
17:01:48 <mniip> take the middle 'a' out and you've got a one-hole context for a list
17:01:51 <dmwit> koz_: You're gonna nead three subscripts instead of just one.
17:02:00 <Gurkenglas> Maybe it just feels like you're understanding more because you're remembering more meaningless terms to attach what you read to?
17:02:00 <dmwit> koz_: I'm terrified of getting the parenthesization right, though... =P
17:02:05 <koz_> dmwit: Likewise.
17:02:13 <jle`> megaTherion: there's sort of a baseline size for the runtime system
17:02:15 <mniip> megaTherion, kinda yes
17:02:24 <koz_> jle`: That would basically take a Natural and output an a, right?
17:02:30 <EvanR> mniip: i see... do you replace it with another variable and abstract over it? Foo a b = ([a], b, [a]) ?
17:02:33 <jle`> koz_: yes
17:02:38 <mniip> EvanR, no
17:02:41 <megaTherion> mniip: why?
17:02:45 <mniip> we get rid of it entirely
17:02:49 <mniip> megaTherion, the RTS is heavy
17:02:54 <dmwit> koz_: (((x000:x001:x002:...):(x010:x011:x012:...):...):((x100:x101:x102:...):(x110:x111:x112:...)):...)
17:02:55 <megaTherion> RTS?
17:02:58 <EvanR> mniip: Foo a = ([a], [a]) ?
17:03:00 <mniip> yes
17:03:05 <megaTherion> RTS stands for?
17:03:16 <Shockk> runtime system
17:03:16 <geekosaur> runtime system
17:03:17 <mniip> RunTime System? iirc?
17:03:21 <megaTherion> I see
17:03:23 <Shockk> ninjas
17:03:25 <jle`> koz_: if Stream a is an infinite line, Stream (Stream a) is an infinite square, you can think of Stream (Stream (Stream a)) as an infinite cube
17:03:25 <megaTherion> and that cannot be a lib?
17:03:29 <mniip> it can
17:03:31 <megaTherion> a DSO
17:03:33 <mniip> but that's not the default
17:03:38 <koz_> jle`: Yeah, that's exactly how I think about it.
17:03:42 <megaTherion> I see
17:03:42 <koz_> Or an infinite 3D table.
17:03:43 <geekosaur> it is sometimes. this can introduce other problems
17:03:54 <glguy> megaTherion: If you want your executables make by GHC to be small like other executables you can cheat like other executables and dynamically link them
17:04:10 <mniip> yeah, GHC uses an interesting address space layout, so it's rather different from glibc executables
17:04:11 <megaTherion> I dont consider dynamic linking cheating
17:04:18 <glguy> not the poitn
17:04:52 <jle`> koz_: so, 'join' on that would get you the 2d plane that is a diagonal of that, and join on that would get the diagonal on that; 'fmap join' woul dget a "different" diagonal, and diagonalize that.  but the resulting single diagonal line will be the same either way
17:05:17 <EvanR> yeah many windows programs come with an EXE and also all the library files it is linked against
17:05:22 <koz_> jle`: Yeah, I see that.
17:05:28 <mniip> EvanR, actually I don't think you need parametricity at all
17:05:34 <mniip> you just need a uniform definition
17:05:36 <geekosaur> one of the problems is that suddenly your programs have a "weird" dependency on part of ghc (the runtime is not in the usual location for shared objects)
17:06:16 <jle`> remember 'join' for functions: join f = \x -> f x x
17:06:28 <jle`> can you see how that relates to your stream join?
17:06:43 <koz_> jle`: No, I can't, sorry.
17:06:48 <jle`> 'Natural -> a' is sort of, 'give me a Natural and i'll index into a stream at that natural
17:06:51 <koz_> :t join
17:06:53 <jle`> sort of like (!! a)
17:06:53 <lambdabot> Monad m => m (m a) -> m a
17:06:55 <mniip> EvanR, so like, a -> [a]
17:06:59 <mniip> but with a catch
17:07:10 <koz_> jle`: Yeah, I get that.
17:07:35 <jle`> koz_: you can imagine any stream as a (Natural  -> a), which is the "index" function on that stream
17:07:42 <dmwit> koz_: Using 2D addressing into our `Stream (Stream a)`s, the result of `join` is the values at indices (1,1), (2,2), (3,3), (4,4), (5,5), ...
17:07:42 <koz_> jle`: Agreed.
17:07:52 <koz_> dmwit: Yep, I understand that too.
17:07:55 <dmwit> koz_: Kind of like applying some function to the same index twice...
17:07:58 <jle`> koz_: so, join :: (Natural -> (Natural -> a)) -> (Natural -> a)
17:08:42 <koz_> jle`: Yeah, it's as dmwit just said.
17:09:02 <koz_> dmwit: And in the 3D case, that'd be (1, 1, 1), (2, 2, 2), etc?
17:09:30 <dmwit> koz_: Well, the burden of your proof is to show that both `join . join` and `join . fmap join` would effectively be using those indices, yes.
17:09:32 <mniip> there is no 3D case
17:09:44 <mniip> join only takes 2 layers
17:09:58 <koz_> And basically, the join . join vs join . fmap join is the difference between that being ((1, 1), 1) etc and (1, (1, 1)) etc ?
17:10:12 <dmwit> koz_: Sort of, yeah.
17:10:34 <dmwit> koz_: Except that even the (1,1) from before was a bit of a lie, since it was really the value at index 1 at the value at index 1, not the value at index (1,1). ;-)
17:11:00 <koz_> dmwit: I understand that - it's just an analogy that makes it easier to imagine for me.
17:11:06 * dmwit nods agreeably
17:11:22 <mniip> ok now
17:11:26 <mniip> what the hell is a prism
17:11:49 <gfixler2> I've heard that lenses worked on sums, and prisms on products
17:11:54 <gfixler2> now to hear how wrong that is...
17:11:54 <mniip> Prism s t a b ~ s -> Either (a, b -> t) t
17:12:10 <koz_> dmwit: OK, I have the proof, but I can best do it by drawing. But I see that they'd both give me the same outcome.
17:12:11 <mniip> no wait
17:12:24 <dmwit> koz_: Drawing is a pretty good way to do it. =)
17:12:57 <koz_> Well, thanks for showing me that. I love diagonalization, and seeing it show up in my programming is ten kinds of awesome.
17:12:59 <mniip> Prism s t a b ~ (s -> Either a t, b -> t)
17:13:00 <dmwit> koz_: As long as you believe you could turn it into careful details when somebody challenged you on it, I see no reason to complain about drawings.
17:13:52 <koz_> Now I just have to write the rest of the instance..
17:14:10 * gfixler2 just finished reading Q.E.D. - mathematical proofs done in drawings
17:14:16 <dmwit> koz_: You might also like: https://byorgey.wordpress.com/2011/05/09/themes-on-streams/ in which I play a costarring role.
17:14:24 <koz_> dmwit: Thanks - will read.
17:14:27 * gfixler2 also owns Proofs Without Words I and II
17:14:39 <mniip> waaaait
17:15:03 <mniip> join xss = (head . map head) xss : (tail . map tail) xss
17:15:37 <dmwit> v. pretty
17:16:02 <mniip> liftA2 (:) (head . map head) (tail . map tail)
17:16:24 <mniip> oh
17:16:25 <mniip> duh
17:16:29 <mniip> I forgot the recursive join
17:16:42 <mniip> liftA2 (:) (head . map head) (join . tail . map tail)
17:16:47 <mniip> not so very pretty now
17:17:25 <mniip> 1455066631 [04:10:31] <gfixler2> I've heard that lenses worked on sums, and prisms on products
17:18:04 <mniip> ok so a prism cosplits a ntainer into a cone-hole ntext and a covalue
17:18:15 <EvanR> -_-
17:18:20 <gfixler2> obviously
17:18:34 <Enigmagic> two cone holes
17:18:43 <hpc> ntainer
17:18:43 <hpc> lol
17:19:00 <mniip> this is coconuts
17:19:01 <hpc> mniip: you might like my comonad module
17:19:04 <hpc> Ntrol.Monad
17:19:05 <EvanR> whats the problem?
17:19:27 <mniip> EvanR, understanding lens in the most generic way
17:19:29 <mniip> fsvo most
17:19:49 <EvanR> whats a covalue?
17:19:50 <mniip> in a more generic way than before, I should say
17:19:54 <shachaf> Prisms are easy.
17:19:57 <mniip> EvanR, I was mostly kidding
17:19:59 <EvanR> or what would it be if it wasnt a joke
17:19:59 <shachaf> Easier than monoids.
17:20:41 <jle`> koz_: maybe one way to see the (Natural -> a) thing better is to implement the isomorphism
17:20:46 <mniip> shachaf, can you explain the duality of the two?
17:21:00 <jle`> fromStream :: Stream a -> (Natural -> a); tostream :: (Natural -> a) -> Stream a
17:21:26 <shachaf> Sure, there are lots of ways.
17:21:46 <mniip> jle`, Data.Functor.Representable.{index,tabulate} :D
17:21:54 <shachaf> A prism does for sums what a lens does for products.
17:22:03 <mniip> 'does'
17:22:15 <gfixler2> that's almost what I said
17:22:22 <gfixler2> but flipped
17:22:30 <mniip> I'm missing the meaning of 'does' here I guess
17:23:01 <koz_> jle`: OK, Monad is implemented. Now, since we have a Monad which is also a Monoid, isn't that a MonadPlus?
17:23:15 <shachaf> Lens s t a b = (s -> a, (s,b) -> t); Prism t s a b = (s <- a, Either s b <- t)
17:23:28 <mniip> :O
17:23:35 <shachaf> That's not a very good analogy, though it's kind of accurate.
17:23:38 <mniip> wait, tsab?
17:23:45 <shachaf> Yes, the variance is reversed.
17:24:15 <shachaf> mniip: Take a type like data Prod a = Prod { one :: a, two :: Int }
17:24:25 <safrol> koz_: what are you guys doing? i thought monads and monoids already existed
17:24:33 <mniip> nonono, I know how Lens works
17:24:41 <shachaf> Yes, but I need it for my analogy.
17:25:10 <mniip> ok, continue
17:25:11 <Eduard_Munteanu> koz_, not really
17:25:14 <shachaf> A lens for "one" lets you do the same thing that "one" lets you: get a value (i.e. "one x"), and set a value (i.e. "x{one=v}").
17:25:27 <shachaf> Now take a sum: data Sum a = One a | Two Int
17:25:53 <koz_> safrol: I'm implementing Stream for educational purposes.
17:25:59 <koz_> Eduard_Munteanu: Did I misunderstand it?
17:26:23 <shachaf> A prism for One lets you do the same things that One lets you do: Construct a value (i.e. "One v") and match on a value (i.e. "case x of { One v -> ...; _ -> ...}")
17:26:40 <shachaf> (The match you get in the failure case is slightly better than "_ -> ...")
17:27:00 <mniip> yes, you get to typechange
17:27:04 <Eduard_Munteanu> koz_, Monoid and MonadPlus may be different monoids. Similarly, consider Applicative, Monoid and Alternative.
17:27:34 <shachaf> So in particular _One :: Prism (One a) (One b) a b = (a -> One a, One b -> Either (One a) b) lets you do those two things.
17:27:42 <koz_> Eduard_Munteanu: OK, my bad.
17:27:53 <Eduard_Munteanu> > Just 3 `mappend` Just 5
17:27:56 <lambdabot>      No instance for (Show a0)
17:27:56 <lambdabot>        arising from a use of ‚Äòshow_M921253117671857382015211‚Äô
17:27:56 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
17:28:18 <Eduard_Munteanu> > Just 3 <|> Just 5
17:28:22 <lambdabot>  Just 3
17:28:46 <Eduard_Munteanu> > Just 3 `mplus` Just 5
17:28:47 <lambdabot>  Just 3
17:29:00 <shachaf> There are all sorts of other dualities, like Lens s t a b = forall f g. (Copointed g, Strong f) => (g a -> f b) -> g s -> f t; Prism s t a b = forall f g. (Costrong g, Pointed f) => (g a -> f b) -> g s -> f t
17:29:14 <shachaf> And of course it's nicest with profunctors.
17:29:27 <mniip> I have no idea what those are :D
17:29:42 <mniip> well I know Pointed and I can assume Copointed
17:29:52 <mniip> what about Strong?
17:30:17 <shachaf> class Functor f => Strong f where { strength :: (a,f b) -> f (a,b) }
17:30:23 <shachaf> (Every Functor is strong in Haskell.)
17:30:32 <mniip> and Costrong?
17:30:42 <Eduard_Munteanu> costrength :)
17:30:47 <shachaf> class Functor f => Costrong f where { costrength :: f (Either e a) -> Either e (f a) }
17:31:45 <koz_> Would it make sense for Stream to be a Semigroup?
17:31:56 <shachaf> With which instance?
17:32:05 <mniip> shachaf, doensn't that imply f ~ Identity
17:32:45 <shachaf> You can have the boring instance where a <> b = a, or you can have pointwise (<>), or something else, I guess.
17:33:30 <EvanR> instance Semigroup a => Semigroup (Stream a)
17:33:34 * mniip . o O ( when does it stop being componentwise and starts being pointwise )
17:33:44 <koz_> shachaf: The definition of Monoid for Stream a looks like this: http://paste.rel4tion.org/247
17:33:46 <shachaf> mniip: No, it's more like Traversable.
17:34:07 <koz_> I basically defined it as 'instance Monoid a => Semigroup (Stream a)' and it seemed happy enough.
17:34:13 <Eduard_Munteanu> mniip, you can make Maybe costrong.
17:34:14 <shachaf> koz_: Oh, if it has a Monoid instance then it should have a semigroup instance, sure.
17:34:18 <EvanR> koz_: use the Semigroup a constraint...
17:34:27 <mniip> oh hm
17:34:31 <EvanR> all Monoids are Semigroups if you forget the identity
17:34:48 <koz_> EvanR: Surely you'd wanna use a weaker constraint if possible?
17:34:57 <EvanR> which is Semigroup
17:35:04 <koz_> EvanR: Oh, derp, point taken.
17:35:16 <mniip> so it's a functor that doesnt "contain" its argument more than once
17:35:44 <koz_> EvanR: It actually complains if I use Semigroup a and not Monoid a.
17:35:51 <nshepperd_> costrength . fmap Left :: f e -> Either e (f a)
17:35:59 <nshepperd_> looks vaguely prismy
17:36:01 <shachaf> sequenceA :: Traversable t => t (Either e a) -> Either e (t a)
17:36:06 <EvanR> koz_: well, make sure you dont use any monoid methods
17:36:21 <mniip> > sequenceA [Left 1, Left 2]
17:36:22 <lambdabot>  Left 1
17:36:25 <mniip> oh
17:36:35 <mniip> well that makes some sense I guess
17:37:46 <koz_> EvanR: The entire definition is: instance Monoid a => Semigroup (Stream a)
17:37:57 <koz_> I assume it has a default based on Monoid methods.
17:38:25 <EvanR> koz_: im not sure what youre saying, can you paste your code
17:39:25 <koz_> EvanR: http://paste.rel4tion.org/248 <-- relevant stuff at line 45
17:39:59 <EvanR> koz_: well, i would not be surprised if it complains when you have no implementation
17:40:46 <koz_> EvanR: So basically, I just need to define <> without using Monoid methods?
17:40:55 <Enigmagic> koz_: yes you'll get a Semigroup instance there because of the Monoid instance
17:40:56 <EvanR> yes, or whatever its called
17:41:07 <koz_> EvanR: OK!
17:41:18 <EvanR> and youll only need the Semigroup constraint
17:41:22 <dmwit> I bet you can `instance Semigroup a => Semigroup (Stream a)`.
17:41:26 <Enigmagic> koz_: assuming you're using a recent-ish version of ghc, i think 7.8
17:41:52 <koz_> EvanR: OK, done.
17:41:56 <koz_> Thanks for the suggestion!
17:42:19 <Enigmagic> http://hackage.haskell.org/package/semigroups-0.18.1/docs/src/Data.Semigroup.html#%3C%3E
17:42:28 <Enigmagic> dmwit: doesn't look like it ^^^
17:43:09 <dmwit> Oh, I didn't understand that he was interested in using the default implementation.
17:43:10 <EvanR> mniip: this time machine library, does it work?
17:43:35 <dmwit> I think I would do it the other way myself. Define the `Semigroup` instance by hand and give `(<>)` in terms of that.
17:43:51 <dmwit> whatever, give `mappend` in terms of that
17:44:00 <dmwit> who can even keep track of these names
17:44:20 <EvanR> let smush = mappend
17:44:26 <dmwit> instance Monoid a => Monoid (Semigroup a) where mempty = return mempty; mappend = (<>)
17:44:50 <Enigmagic> dmwit: at least this is fixed in ghc 8.0 :-)
17:44:58 <EvanR> return o_O
17:45:11 <dmwit> s/Semigroup/Stream/
17:45:50 <mniip> EvanR, it maintains a list of State# RealWorlds
17:45:55 <dmwit> EvanR: if you prefer, `mempty = mempty:mempty`
17:45:57 <dmwit> EvanR: =)
17:46:09 <mniip> upon exiting the do-block it looks at the topmost one
17:46:29 <EvanR> so this has the possibility of being actually useful for something
17:46:33 <EvanR> unlike other acme
17:46:37 <dmwit> EvanR: (Though I would bet `return mempty` will be more efficient.)
17:46:41 <mniip> questionable
17:46:49 <mniip> it's not a totally lawful monad
17:46:56 <shachaf> Anyway profunctors are the future.
17:47:03 <mniip> it introduces checkpoints automatically
17:47:05 <EvanR> who cares you are breaking the laws of causality anyway
17:47:51 <mniip> EvanR, see the Undoable monad
17:48:06 <mniip> then see 'data Universe' and try to imagine that it does what it says
17:48:20 <mniip> it actually doesn't but that's even harder to explain
17:49:10 * EvanR files a bug report
17:50:55 <mniip> anyway
17:50:57 <mniip> I'm off
17:51:10 <ddwantstocode> Hello
17:51:32 <ddwantstocode> Is anyone online
17:51:35 <safrol> hiya
17:51:37 <safrol> yea me
17:51:39 <safrol> sup ddwantstocode 
17:51:42 <ddwantstocode> HEllo
17:51:48 <safrol> Hi.
17:51:52 <ddwantstocode> Safrol, Im creating a game
17:51:56 <ddwantstocode> Want to donate?
17:51:59 <safrol> Sure
17:52:02 <safrol> link me
17:52:03 <ddwantstocode> Thx
17:52:25 <safrol> Woops.
17:52:27 <ddwantstocode> safrol here paypal.me/TWilbur485
17:52:30 <safrol> An error in dimension.
17:52:37 <ddwantstocode> Wait how much will you donate?
17:52:48 <safrol> Nooo, plz link me the game, I wanna know what game I'm contributing to.
17:52:51 <dmwit> Do you have a Haskell question?
17:52:56 <ddwantstocode> Ya
17:52:56 <safrol> PJ
17:52:57 <safrol> OH
17:52:59 <ddwantstocode> Let me get it
17:53:04 <safrol> i thought i was in the soldat channel sry
17:53:06 <ddwantstocode> I suck at art
17:53:27 <safrol> Mee too.
17:53:52 <safrol> So many bugs out there. :>
17:53:54 <ddwantstocode> safrol https://onedrive.live.com/redir?resid=1E9AEE95987E0324!637&authkey=!AA3FE7FcZqnS-iE&ithint=file%2cexe
17:54:37 <dmwit> ?where ops
17:54:38 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
17:54:43 --- mode: ChanServ set +o dcoutts
17:54:52 <MarcelineVQ> Well, he was asked dmwit.
17:54:58 <MarcelineVQ> ddwantstocode: This isn't really the place for sharing game .exe's, share them in private plzzz
17:55:07 <ddwantstocode> KK sorry
17:55:15 <ddwantstocode> Im new
17:55:38 <hiptobecubic> who in their right mind would run that
17:55:49 <safrol> oh im on linux anyways
17:55:58 <ddwantstocode> I need donations
17:56:00 <safrol> pc still opening the link... cutie
17:56:04 <EvanR> my client is set to autorun exe links so
17:56:10 <MarcelineVQ> ddwantstocode: This is a channel for discussing topics related to the haskell programming language
17:56:16 <ddwantstocode> It is
17:56:24 <ddwantstocode> LEts create a custom channel
17:56:27 <hiptobecubic> EvanR, clever!
17:56:44 <ddwantstocode> #betterthanwolved
17:56:46 <safrol> ddwantstocode: Go.
17:56:47 <ddwantstocode> Join it
17:56:56 <ddwantstocode> Join #betterthanwolved
17:57:15 <ddwantstocode> So I can talk about my game and leave this alone
17:57:26 <safrol> ok
17:57:33 <dolio> You can leave this conversation alone regardless.
17:57:57 * dcoutts was summoned to decide if someone needed to be kicked and is making up his mind
17:58:12 <dedgrant> a cophishing opportunity appears?
17:58:21 <safrol> Sooo... Any bugs left on the table? Still eating all those bugs yea
17:58:32 <ddwantstocode> safrol You left>
17:58:35 <dmwit> dcoutts: I agree it is not obvious. I attempted to ascertain genuine interest with my "Do you have a Haskell question?" line.
17:58:37 <ddwantstocode> Join again
17:58:45 <Enigmagic> yes, not a particularly clever one either.
17:59:00 --- mode: ChanServ set +o dolio
17:59:03 <hiptobecubic> awww
17:59:20 <dmwit> dcoutts: I think as a community, it would be nice to have a policy that protects this channel from people begging for money.
17:59:47 <dcoutts> ddwantstocode: come on, this isn't the place to randomly seek interest for games and funding etc, if there's no connection to Haskell at all
17:59:52 <dmwit> Or, I don't know if "policy" is necessarily the right word. "Culture", maybe.
18:01:34 <Eduard_Munteanu> Can you spare a few coins for my monaditis, while you're at it? My monads are swollen. Help a poor Haskeller.
18:01:44 <koz_> OK,another question about section 2, question 3 here: https://github.com/quchen/articles/blob/master/write_yourself_a_brainfuck.md
18:01:47 <ddwantstocode> I need money $10
18:01:48 <Shockk> Eduard_Munteanu: sorry, only free monads here
18:01:50 --- mode: dolio set +b *!*@173.57.31.183
18:01:55 --- kick: ddwantstocode was kicked by dolio (ddwantstocode)
18:02:02 <koz_> I assume it'd be something like data Tape c a = Tape (c a) a (c a)
18:02:05 <Shockk> please someone laugh I thought that was a great joke
18:02:16 <koz_> But I'm not sure how to them define moveLeft and moveRight appropriately.
18:02:18 <Eduard_Munteanu> It sort of is. :)
18:02:19 <safrol> xDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDd
18:02:19 --- mode: ChanServ set -o dcoutts
18:02:26 <safrol> Like that?
18:02:30 --- mode: dolio set -o dolio
18:02:37 <EvanR> dang i thought that would get rid of safrol too ;)
18:02:41 <safrol> lol
18:02:44 <safrol> sry EvanR 
18:02:57 <safrol> ill keep my mouth shut from now on <3
18:04:20 <gfixler2> koz_: might be easier to do [a] instead of c a
18:04:44 <gfixler2> unless there's some reason you want a generalized tape
18:05:23 <safrol> ( if it's not about haskell.... There's just no poetry in life. )
18:06:10 <gfixler2> counterpoint: https://wiki.haskell.org/Humor/Poetry
18:06:27 <koz_> gfixler2: Did you see the link I sent?
18:06:37 <gfixler2> koz_: glanced at it
18:06:50 <koz_> I actually need to do a more general form (as I'm supposed to be able to make both a list-based and a Stream-based tape).
18:07:03 <koz_> However, I'm not sure how I would implement moveLeft and moveRight using the definition I just gave.
18:07:23 <gfixler2> koz_: 3.ii, I'm guessing
18:07:47 <koz_> gfixler2: Yup. 3.i is what I've been doing with Stream.
18:07:48 <gfixler2> koz_: you'd need a type constraint, or to pass in the function for moving
18:08:12 <gfixler2> type constraint meaning something that limits c to the set of types that can be moved left and right through
18:08:26 <gfixler2> or that work like a stack, more like
18:08:28 <koz_> Well, c only really makes sense as [] or Stream.
18:10:27 <gfixler2> koz_: is c supposed to be Stream?
18:11:34 <safrol> gfixler2: thank you.
18:12:01 <koz_> gfixler2: Either Stream or [].
18:12:13 <koz_> It can be either of those things - Stream for an infinite tape, [] for a finite one.
18:12:22 <gfixler2> koz_: just reread
18:12:31 <gfixler2> so you need two constructors
18:12:37 <EvanR> koz_: course, [] also supports infinity 
18:12:41 <gfixler2> and then you need to write moveLeft and moveRight cases
18:13:09 <koz_> gfixler2: OK, thank you, that makes sense. EvanR: I know that - I'm just following the exercise right now.
18:13:46 <Wizek> Can I specify a preferred cabal-install version in my stack.yaml file just like `compiler: ghc-7.10.3`?
18:16:03 <mgsloan> Wizek: For use with "stack solver"?  It will use whatever is on the PATH.  However, if you have "extra-deps: ['cabal-install-1.24.0.0']", it'll use that version when you do "stack build cabal-install"
18:16:35 <koz_> gfixler2: This the right start? http://paste.rel4tion.org/249
18:16:36 <mgsloan> When you do "stack build cabal-install", it'll install the binary to your project's bin directory, which will be included on the PATH when running stack solver.
18:17:08 <mgsloan> (or at least, it ought to be, not 100% sure that it'll use the project's locally installed cabal-install)
18:17:36 <gfixler2> koz_: looks right to me
18:17:40 <mgsloan> (the stackage snapshot also specifies a cabal-install version, so you probably don't need to list it in extra-deps)
18:17:53 <koz_> gfixler2: Awesome! I don't suppose there's a way to make that Functor instance declaration there less repetitive?
18:18:25 <gfixler2> not that I know of
18:18:27 <Wizek> mgsloan, thanks, giving that a try
18:18:32 <gfixler2> which doesn't mean there isn't
18:18:57 <Enigmagic> koz_: DeriveFunctor will make one for you
18:19:19 <gfixler2> besides that :)
18:19:30 <koz_> Enigmagic: OK, that's neat. I'll have to use that more often.
18:20:03 <shanemikel> seeing as how Alternative, Monoid, and MonadPlus are so similar, is it recommended to use TH to generate or derive the rest of instances from a given one?
18:20:17 <shanemikel> is there a lib for this?
18:21:28 <shanemikel> or is there even a way to derive applicative and functor instances from a monad or functor from applicative using TH or other lib?
18:21:32 <gfixler2> can GeneralizedNewtypeDeriving generate any of those?
18:21:43 <gfixler2> (I've heard GND is very unsafe)
18:21:43 <shanemikel> idk, never tried it
18:21:52 <Enigmagic> it can if you're using newtypes
18:22:12 <gfixler2> don't you have to use newtypes?
18:22:47 <Enigmagic> for GND yes
18:23:21 <Enigmagic> if you're not using newtypes ... well then you need to implement Monad yourself
18:24:00 <shanemikel> right, but you can go Monad --> Applicative --> Functor or Applicative --> Functor.. that's what I'm asking
18:24:58 <Enigmagic> shanemikel: there isn't any builtin support of doing it, but it used to be common to define Applicative instances in terms of Monad
18:25:18 <dedgrant> gfixler2: I think (but maybe others can confirm?) GND is safe again since the introduction of type roles (in 7.8.1?): https://ghc.haskell.org/trac/ghc/wiki/Roles
18:25:34 <gfixler2> dedgrant: ah, good
18:25:59 <safrol> ey seit 10 stunden steht hier der openwrt faehige router am start und ich hab immer noch kein freifunk installiert. fauler sack
18:26:05 <safrol> oops
18:26:07 <safrol> sorry
18:26:21 <safrol> It's not surprising that I'm confused.
18:26:38 <dolio> safrol: You're not doing a good job of being on-topic in this channel.
18:26:49 <dolio> I suggest that change.
18:26:54 <Cale> Yeah, I'm strongly considering a mute here
18:26:57 <shanemikel> learning Monad, Applicative, Functor isn't so bad, but juggling the interfaces of Monoid, Alternative, and MonadPlus on top of it (despite that they accomplish the same things).. is pretty scary.. also, the lack of Applicative constraint on Monad class doesn't help
18:27:44 <roboguy`> shanemikel: one nice thing is that all three of those are really the same concept (Monoid, Alternative and MonadPlus are all monoids)
18:27:58 <EvanR> shanemikel: Monad does have the Applicative constraint now
18:28:14 <Cale> Alternative is for applicative functors that create monoids. MonadPlus is for monads which create monoids.
18:28:14 <safrol> dolio: I'm sorry, that last one was an accident. I will only talk about haskell in here from now on, or jokes if that's ok
18:28:46 <safrol> I just want to stop lurking and start writing code again is all :s
18:29:06 <safrol> but i know i should just do that instead so... stfu kk np
18:29:14 <gfixler2> safrol: have you done CIS 194 yet?
18:29:20 <Welkin> safrol: then take action and do it
18:29:27 <safrol> parts, yea
18:29:45 <safrol> Welkin: i dont have a good idea where to start is all
18:30:00 <safrol> state monad really gives me headache
18:30:00 <Welkin> just showing up gets you 90% of the way there
18:30:10 <Welkin> don't get caught up in the details
18:30:19 <safrol> Oh, ok.
18:30:26 <Welkin> you will probably never understand everything; there is too much to cover
18:30:34 <Welkin> but just learn what is useful at the moment and use that
18:30:54 <gfixler2> SPJ himself doesn't understand everything
18:30:58 <Welkin> I didn't understand the state monad for a long time, but still wrote plenty of useful programs
18:31:00 <shanemikel> are there 3rd degree monad transformers lol?
18:31:04 <safrol> Of course yea
18:31:12 <safrol> No need to scream ^^
18:31:37 <ReinH> No one is screaming?
18:31:54 <safrol> Talked to myself again.
18:32:07 <Welkin> safrol: I suggest starting a project
18:32:11 <Welkin> and having fun with it
18:32:27 <Welkin> write an IRC bot, or a scheme interpreter, or a web app
18:32:29 <safrol> ohhhhhh been there done that thanks for the reminder
18:32:31 <Welkin> or a game
18:32:32 <KaneTW> i used a RWS stack when writing a implementation of a unification algorithm
18:32:45 <shanemikel> RWS?
18:32:55 <KaneTW> reader/writer/state
18:33:06 <KaneTW> actually i lied
18:33:14 <KaneTW> ExceptT, WriterT, StateT
18:33:38 <shanemikel> do people use any MonadTTs ?
18:33:50 <Welkin> shanemikel: that doesn't make sense
18:33:53 <shanemikel> or is that not even necessary
18:33:57 <KaneTW> it's just nested
18:34:02 <Welkin> you can stack monad transformers arbitrarily deep already
18:34:10 <shanemikel> yeah, just realized that
18:34:22 <shanemikel> scary
18:34:26 <KaneTW> ExceptT (UnifyError var func) (WriterT [String] (State (UnifyState var func)))
18:36:28 <shanemikel> is there a next obvious step after MonadT? should I skip on arrows until I get into some category stuff?
18:37:18 <Welkin> arrows are not important
18:37:39 <Welkin> just Functor, Applicative, Monad, Transformers, and that's about it
18:38:05 <shachaf> Yes, and then keep skipping.
18:39:11 <dolio> You probably won't run into arrows (as in Arrow) in category theory.
18:42:03 <Cale> shanemikel: Monad transformers are cool sometimes for getting at the monad that you want expediently, but even those I'd say you can put off until you need to read some code which uses them, or you're trying to implement some particular combinator library which you think ought to be a monad.
18:42:28 <Cale> shanemikel: It's usually quite doable to get by without them.
18:43:10 <shanemikel> I guess I'll start playing around with Monad instances, state next... also look into data structures, and write some programs with zippers.. what's this backtracking stuff about?
18:43:24 <shanemikel> looking it up I just get an example for Monad []
18:44:38 <shanemikel> also, is there a good library for stateful data structures.. maps, graphs, and so-on
18:44:57 <Cale> Yeah, the list monad can be used for backtracking searches, because if some part works out to an empty list, that branch of the computation gets cut off
18:45:29 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; if x^2 + y^2 == z^2 then return (x,y,z) else []
18:45:31 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
18:45:46 <Cale> which is pretty much the same thing as a list comprehension
18:46:00 <Cale> Note that due to laziness, this is a depth-first search
18:46:31 <shanemikel> I still have to gain a good intuition for laziness
18:46:35 <Cale> Usually, just using an IORef around a Data.Map is good enough
18:47:09 <shanemikel> oh, yeah.. that's right, I meant to look at IORef
18:47:39 <Cale> and for graphs, well, there are a million representations for graphs depending on what exactly you want, but Map Vertex (Set Vertex) is usually not far off.
18:48:08 <Cale> Or you can have things like Map Vertex (Set (Edge, Vertex))
18:48:56 <Cale> Or the Set might be just a list if you have some ordering on the edges out of a given vertex.
18:49:44 <shanemikel> is there a Matrix or is Array the Canonical choice?
18:49:58 <shanemikel> or [Vector]
18:50:17 <Cale> There are similarly many libraries for linear algebra
18:50:30 <shanemikel> no, I mean for a graph
18:50:52 <Cale> Ah, you could use a 2D array for adjacency.
18:51:17 <Cale> (But then, you may also prefer to use a linear algebra library, because there are relevant operations on graphs which can be performed by matrix operations)
18:51:34 <shanemikel> oh, haven't taken a linear algebra course yet
18:51:57 <shanemikel> recommended reading on laziness?
18:52:04 <shanemikel> outside of the report
18:52:07 <Cale> hmm
18:52:57 <Cale> Well, if you haven't seen it, the paper "Why Functional Programming Matters" is really more about the benefits of lazy evaluation than functional programming generally, I think.
18:53:29 <Cale> http://worrydream.com/refs/Hughes-WhyFunctionalProgrammingMatters.pdf
18:53:55 <Cale> Are you aware of what lazy evaluation *is* though? I can give you an intro in just a minute.
18:53:58 <shanemikel> yeah
18:53:59 <Cale> brb
18:56:53 <shanemikel> > foldr (\x y -> if x > 100 then x else x + y) undefined [1..]
18:56:55 <lambdabot>  5151
18:57:49 <shanemikel> I've read some stuff on laziness, and what it means for lists.. specifically spines, but I could be more comfortable with it
18:58:18 <EvanR> > fst (3, undefined)
18:58:19 <lambdabot>  3
18:58:24 <EvanR> > snd (3, undefined)
18:58:26 <lambdabot>  *Exception: Prelude.undefined
18:58:37 <ggVGc> I always think laziness sounds like such a negative aspect of a language, since we're conditioned to think lazy is a bad trait
18:58:57 <shanemikel> I guess the most important thing to understand about laziness is which functions don't necessarily evaluate all their args, and which args
18:58:58 <EvanR> and many people do deride lazy evaluation
18:59:07 <shanemikel> so it'smore about knowing base than anything
18:59:32 <shanemikel> I don't mind the idea of laziness :)
19:00:41 <EvanR> also related to what you said is that data structures dont necessarily contain fully evaluated components
19:00:41 <ggVGc> EvanR: I have started really seeing the point of laziness in the context of pure functional programming after using haskell a bit more, but in the context of IO I think it's pretty much not so great. But I think everyone agrees on that
19:00:53 <Welkin> laziness is a good character trait to have
19:01:00 <Welkin> it leads to real innovation
19:01:12 <ggVGc> sure, the correct type of laziness
19:01:23 <ggVGc> but most kinds of laziness leads to smoking weed and watching tv shows
19:01:23 <Welkin> "this is too much work... there must be an easier way"
19:01:37 * EvanR imagining Welkin wearing a steve jobs costume and talking with his hands on stage
19:01:45 <monochrom> except we are precisely conditioned to think all traits that lead to innovation to be bad traits. laziness is just one example.
19:01:48 <Welkin> costume?
19:01:52 <ggVGc> man, I just watched the steve jobs movie on the plane the other day..
19:01:57 <ggVGc> not sure what to say
19:02:05 <EvanR> oh god
19:02:05 <monochrom> another example is disobedience, deviation, non-compliance
19:02:06 <Welkin> ggVGc: the one where he puts his feet in a toilet?
19:02:18 <monochrom> another example is asking for evidence or proof
19:02:18 <Welkin> monochrom: I do all of those things
19:02:24 <ggVGc> Welkin: well, that's not really a major part of it, but yeah
19:02:25 <Welkin> and I was punished for it for years
19:02:32 <Eduard_Munteanu> Innovation is bad, mkay?
19:03:10 <Eduard_Munteanu> It tends to make people's past choices invalid.
19:03:45 <shanemikel> tinfoil hat time?
19:03:56 <Welkin> haskell is for lazy people
19:03:59 <Welkin> let the compiler do the work
19:04:11 <jmcarthur> If only.
19:04:14 <EvanR> if only the compiler werent so slow!
19:04:20 <EvanR> hurry up, work harder
19:04:39 <shanemikel> why don't you just build in the cloud?
19:04:49 <shanemikel> if it's that much a problem for your project
19:04:55 <shanemikel> hello docker
19:04:55 <jmcarthur> I end up babysitting even GHC more than I feel like I should have to.
19:05:06 <Eduard_Munteanu> 'Cause back in the day there was no cloud. See?
19:05:24 <jmcarthur> To end up with efficient programs. Compilation times... actually I'm not so sad about, considering what GHC does.
19:05:26 <EvanR> ghc is faster in the cloud?
19:05:28 <Eduard_Munteanu> Clouds are bad, mkay?
19:05:42 <shanemikel> I'm thinking about writing a little script that will descent recursively into deps and rip the pkgconfig deps out of the cabal configs, and use your linux distros tool to search for the packages providing the libs
19:05:59 <shanemikel> to help people BEFORE they start the compilation instead of the babysitting stuff
19:06:32 <ggVGc> EvanR: ghc is plenty fast enough for me
19:06:47 <ggVGc> I run "stack build" one every save
19:06:48 <shanemikel> probably wouldn't be too hard if I can figure out how to script cabal to get the recursive deps and figure a way to only download the cabal configs from them
19:06:58 <Eduard_Munteanu> And and... write a script to generate autoconf files, so we can run ./configure && make instead of cabal build :)
19:07:04 <Cale> shanemikel: So you're okay with the idea that lazy evaluation is outermost-first evaluation with sharing then. Everything else just amounts to carrying out some evaluations by hand and getting a feel for how it goes.
19:07:40 <ggVGc> jmcarthur: how are you babysitting ghc?
19:07:41 <monochrom> I am too lazy to do it by hand
19:07:52 <monochrom> so I do it in my head instead :)
19:07:56 <shanemikel> is it possible (supported) to only download specified files from a package? or should I just have the script get everything first since you need it to build anyway
19:08:01 <ggVGc> I think I write very simplistic haskell, but so far it's fulfilling every need I have. I haven't even written any custom type class yet
19:08:03 <monochrom> but head is not safe, they say
19:08:05 <ggVGc> and never felt the need to
19:08:10 <shanemikel> I'd rather it didn't, but I will if necessary
19:08:21 <ggVGc> and so far I can't even see a need personally for monad transformers
19:08:24 <ggVGc> I barely understand them
19:08:38 <Cale> ggVGc: It's rare to need them.
19:08:51 <EvanR> ggVGc: sounds about right... new type classes cant be invented by mortals 
19:08:53 <shanemikel> ggVGc: probably mostly with IO
19:09:02 <ggVGc> I feel a lot of haskells advanced features are over-used "just because"
19:09:11 <shanemikel> ggVGc: if you want to use [] or Maybe WHILE doing IO
19:09:19 <shanemikel> I can see that desire
19:09:44 <monochrom> I know a use of ContT r (ParsecT ... IO ...)
19:09:46 <Cale> ggVGc: I don't know... certainly monad transformers are slightly overused. The situation has been improving in that regard though.
19:10:06 <Cale> But sometimes they indeed are very convenient.
19:10:07 <ggVGc> EvanR: really? Isn't type classes just ad-hoc polymorphism?  I mean, they could be used in many cases
19:10:18 <Cale> ggVGc: They are not ad-hoc
19:10:55 <EvanR> ggVGc: they could be, but its usually more convenient to use a regular value, function, or record
19:11:09 <EvanR> for "ad hoc" implementations
19:11:11 <Cale> In particular, the main difference between type classes and ad-hoc polymorphism is that you can use type class polymorphic things (such as 'compare') in order to construct new type class polymorphic things (such as 'sort')
19:11:17 <ggVGc> EvanR: yeah, that's what I've foubnd
19:12:02 <ggVGc> Cale: I guess I don't know anough about the definition of ad-hoc polymorphism. but I was basing it on statements like this "In Haskell, type classes provide a structured way to control ad hoc polymorphism"
19:12:08 <ggVGc> from https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjBi6aunOzKAhUBxJQKHY-pDp4QFggdMAA&url=https%3A%2F%2Fwww.haskell.org%2Ftutorial%2Fclasses.html&usg=AFQjCNHdUb4XBsRNSifZA8BIjyIaydpzfw&sig2=TFtM7IKHKCnxcIGw_4jI4A
19:12:13 <ggVGc> oh, sorry
19:12:17 <ggVGc> here, https://www.haskell.org/tutorial/classes.html
19:12:19 <Cale> The usage site of an ad-hoc polymorphic definition needs to determine which thing is in use, because there's no type-level information which can defer that choice.
19:13:03 <shanemikel> if somebody wants to write the part that recursively traverses dependencies in cabal, getting only the configs for each of them, I'll write the pkgconfig and distro specific convenience part (for telling the user which system libs to install by exact distro package name)
19:13:14 <Cale> ggVGc: Yeah, this is a misconception which is strewn about because of the cutesy title of the paper which introduced type classes "How to make ad-hoc polymorphism less ad-hoc"
19:13:26 <ggVGc> oh
19:13:29 <ggVGc> yeah, I get it then
19:13:33 <ggVGc> thanks
19:13:44 <monochrom> it is less ad-hoc than real ad-hoc
19:13:46 <EvanR> ggVGc: based on this experience with type classes i started being suspicious about "obvious features to obviously use for stuff" in other languages, like clojure protocols
19:14:01 <shanemikel> ad-hoc then would be like generics or templates then? with unwrapping
19:14:14 <shanemikel> err java generics NOT templates
19:14:26 <Cale> It does the job that ad-hoc polymorphism does -- deciding on implementations based on the types of things involved.
19:14:32 <Eduard_Munteanu> There's no ad-hoc polymorphism in Haskell.
19:14:32 <EvanR> generics is more like parametric polymorphism
19:14:54 <Cale> But it does it in a more principled and uniform way.
19:14:55 <EvanR> data List a = Nil | Cons a (List a)
19:15:03 <EvanR> that could be a generic class in java
19:15:05 <shanemikel> not when you specify subclass or interface constraints on the generics
19:15:20 <shanemikel> then you need to do a bunch of coersion.. if i'm understanding ad-hoc correctly
19:15:25 <EvanR> oh gross
19:15:33 <EvanR> not very generic
19:15:35 <Cale> Yeah, type class polymorphism is a way of restricting the types over which type variables vary. So it's more like a kind of constrained parametric polymorphism.
19:15:36 <monochrom> yeah, by the time you say in Java "<T extends Comparable<T>>" you're looking at type class pretty much.
19:15:38 <shanemikel> IIRC
19:15:42 <Eduard_Munteanu> Like List<? extends Foo> ?
19:15:43 <jmcarthur> ggVGc: Most of my babysitting of GHC is when I want the generated code to be close to optimal. If it's just about the claim that GHC does a great job, I'd agree.
19:15:56 <monochrom> do not be surprised because Phil Wadler invented both
19:17:50 <jmcarthur> When I first heard that type classes are a way to implement ad hoc polymorphism, I just set my mental definition of ad hoc to match, because I had no preconceptions of what it should mean before that.
19:18:05 <Cale> But yeah, the really cool thing about, e.g. Monad being a type class is that you can write a bunch of code which will work with any instance of Monad, and the types in your code will end up with type variables m constrained by the Monad type class, and you can go on to use those things you defined with anything that implements return and (>>=)
19:18:41 <Cale> If it were ad-hoc polymorphism, you might be able to name those things the same thing, but you'd still have to write them over and over.
19:19:27 <KaneTW> :t mapM
19:19:28 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
19:19:30 <KaneTW> stuff like that
19:19:35 <Cale> :t liftM2
19:19:36 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:19:39 <Cale> :t sequence
19:19:41 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:20:50 <sathish_haskell> @Cale , can you please provide like a example of say a sequence , from your experience of using it ?
19:20:50 <lambdabot> Unknown command, try @list
19:20:52 <EvanR> what is the difference exactly? is it that liftM2 can take two "m class objects" (of the same type) whereas with C++ you would not be able to ensure they were the same class?
19:21:06 <EvanR> it could be two different classes that implemented the monad methods?
19:21:21 <Eduard_Munteanu> I pretty much associate ad-hoc polymorphism with C++-style overloading.
19:22:12 <shanemikel> emptyOr p x = guard (p x) >> return x
19:22:16 <thimoteus> lambdabot: is your @src working at all?
19:22:30 <shanemikel> @let emptyOr p x = guard (p x) >> return x
19:22:33 <lambdabot>  Defined.
19:22:33 <Eduard_Munteanu> :t catMaybes
19:22:35 <lambdabot> [Maybe a] -> [a]
19:22:37 <shanemikel> :t emptyOr
19:22:38 <lambdabot> (Monad m, Alternative m) => (b -> Bool) -> b -> m b
19:22:42 <KaneTW> i think in c++ you'd have to do something like m<r> liftM2(std::function<r, a1, a2>, m<a1>, m<a2>)
19:22:51 <Eduard_Munteanu> Nvm.
19:23:01 <KaneTW> except that won't work since m is unconstrained
19:23:26 <Cale> sathish_haskell: Well, you use sequence in a lot of different cases. What it does depends on the monad of course...
19:23:53 <Cale> sathish_haskell: With the list monad, you get a Cartesian product, which is nice when you want to get a list of all combinations:
19:23:59 <sathish_haskell> Choose any one from your experience , I want a concrete example.
19:24:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
19:24:03 <shanemikel> the canonical example is IO
19:24:05 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
19:24:24 <shanemikel> > sequence [print "Hello", print ", world"]
19:24:25 <lambdabot>  <IO [()]>
19:24:56 <Cale> With a list of parsers, you'll get a parser which will run each of the parsers in turn, collecting a list of the results, effectively the concatenation of the languages.
19:25:14 <KaneTW> with a bit of headache you can constrain m to be a subclass of some other class (like a class with pure virtual methods that implement a monad)
19:25:15 <Eduard_Munteanu> > sequence [Just 3, Just 5]
19:25:17 <lambdabot>  Just [3,5]
19:25:22 <Eduard_Munteanu> > sequence [Just 3, Nothing, Just 5]
19:25:24 <lambdabot>  Nothing
19:25:47 <KaneTW> so with templates you can actually do a bit of typeclass-esque things
19:25:48 <Cale> Yeah, with Maybe, it'll effectively check that all the elements are Just x, and collect up the list of x's
19:25:53 <KaneTW> but templates are cheating
19:25:56 <Cale> and give Nothing if any was Nothing
19:26:24 <sathish_haskell> So , there is a particular case that I was discussing with a friend of mine
19:26:55 <Eduard_Munteanu> (Do tell your frineds about Haskell, good! :D)
19:27:09 <koz_> :t ord
19:27:10 <sathish_haskell> We have a query to the DB , where we search for a User in a table , if not found we have to find him in another one , if not found in that one too , go to the last table.
19:27:10 <lambdabot> Char -> Int
19:27:28 <koz_> :t chr
19:27:30 <lambdabot> Int -> Char
19:27:57 <sathish_haskell> This was something atleast for my eyes , looks like an inverse of the application of <$> and <*> 
19:27:58 <Cale> sathish_haskell: Yeah, you could use something like MaybeT IO for that if you wanted.
19:28:00 <EvanR> Eduard_Munteanu: i can't, they would probably stop talking to me
19:28:20 <sathish_haskell> With the exception that <$> over Nothing will return Nothing
19:28:38 <Eduard_Munteanu> sathish_haskell, that's more suitable for things like Alternative / MonadPlus
19:28:45 <Cale> sathish_haskell: The fact that you probably don't want to keep looking once you've found the user means it's slightly more complicated than just using the Monad instance for Maybe alone.
19:29:00 <Cale> oh, right
19:29:01 <Eduard_Munteanu> > Nothing <|> Nothing <|> Just 3
19:29:03 <lambdabot>  Just 3
19:29:10 <Eduard_Munteanu> > Nothing <|> Nothing <|> Just 3 <|> Just 5
19:29:12 <Cale> Yeah, you actually want the *Alternative* instance for that :)
19:29:12 <lambdabot>  Just 3
19:29:12 <sathish_haskell> See, that is where , I bang my head :(
19:29:23 <sathish_haskell> Thanks Eduard_Munteanu
19:29:27 <Cale> Because you want the first thing, not to ensure that they're all Just
19:29:53 <Eduard_Munteanu> :t mconcat
19:29:54 <lambdabot> Monoid a => [a] -> a
19:29:58 <Eduard_Munteanu> Er.
19:30:01 <EvanR> > First Nothing <> First Nothing <> First (Just 1)
19:30:03 <lambdabot>  First {getFirst = Just 1}
19:30:05 <sathish_haskell> The worst part is , I did the CS194 exercise on Alternatives and wasnot able to figure out the right Typeclass
19:30:07 <shanemikel> just think about it like ||
19:30:16 <shanemikel> short circut evaluation
19:30:28 <shanemikel> *circuit*
19:31:08 <shanemikel> where empty is False
19:31:28 <sathish_haskell> I am trying to understand the Typeclasses atleast with a focus on the application aspect , so that they stick to my head.
19:31:29 <Eduard_Munteanu> :t msum
19:31:30 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
19:31:36 <Eduard_Munteanu> :t asum
19:31:38 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
19:33:34 <EvanR> for Monads is MonadPlus now redundant because they are also Alternative
19:34:00 <sathish_haskell> If I may ask , what is MonadPlus ?
19:34:03 <Cale> EvanR: Well, not quite, but kind of.
19:34:22 <EvanR> :t mzero
19:34:22 <Eduard_Munteanu> sathish_haskell, the equivalent of Alternative for Applicative is MonadPlus for Monad.
19:34:23 <lambdabot> MonadPlus m => m a
19:34:34 <EvanR> :t (<+>)
19:34:35 <lambdabot>     Ambiguous occurrence ‚Äò<+>‚Äô
19:34:35 <lambdabot>     It could refer to either ‚ÄòControl.Arrow.<+>‚Äô,
19:34:35 <lambdabot>                              imported from ‚ÄòControl.Arrow‚Äô at /home/lambda/.lambdabot/State/L.hs:43:1-20
19:34:40 <EvanR> fruit
19:35:02 <Cale> EvanR: MonadPlus implies a Monad instance, and if we were putting in laws, it could have some additional laws
19:35:12 <koz_> OK, done with the Brainfuck interpreter exercise. Now to write it how it *should* be written, lol.
19:35:56 <Cale> (There probably ought to exist two classes: MonadPlus and MonadElse because there are two main sorts of instances)
19:36:14 <sathish_haskell> Ok , Eduard , I think I will have to go back to reading Haskell.
19:36:32 <sathish_haskell> I will let my friend know about Alternative , seems like what we need :)
19:43:59 <bramantio> umh.. hello all
19:44:15 <koz_> HI bramantio!
19:49:01 <bramantio> i want to configure my xmonad can you help me? i've downloads config in other web but i've error code.
19:51:12 <koz_> Is there a Haskell library for Streams?
19:51:20 <koz_> Or is it a case of 'roll your own plz'?
19:51:30 <koz_> (Stream = list which must be infinite in my case)
19:54:14 <EvanR> https://hackage.haskell.org/package/Stream
19:55:05 <EvanR> "Note: I get quite a lot of requests regarding a missing Traversable instance for Streams. This has been left out by design."
19:55:22 <Cale> bramantio: If you post your code and the errors at lpaste.net, perhaps :)
19:55:33 <koz_> EvanR: It's doable though - it just doesn't often make sense.
19:55:55 <bramantio> is not my script, i'm just a end-user sir
19:56:09 <koz_> Also, how the hell do you implement a terminating Eq for Streams?
19:56:19 <EvanR> you cant, as noted in the docs there
19:56:39 <koz_> Ah, I see.
19:56:46 <Cale> bramantio: Well, regardless :)
19:56:56 <CoLdFeeLiNgS> hi
19:57:59 <koz_> Well, I guess that Eq *can* terminate if they're not equal.
19:58:02 <koz_> It just won't if they are.
19:58:20 <EvanR> yes, similar to equality on computable reals
19:58:28 <koz_> Ord likewise, I think.
19:58:30 <koz_> OK.
19:59:41 <EvanR> equality on a Stream is basically the halting problem
20:00:30 <EvanR> er, undeciability of program equality
20:03:09 <koz_> EvanR: Yeah.
20:04:06 <Cale> CoLdFeeLiNgS: Welcome
20:04:36 <Cale> bramantio: If anyone's going to be able to help you, you'll need to post the error message you're getting somewhere, probably along with the code you're trying to run
20:04:56 <Cale> bramantio: I recommend lpaste.net for anything more than a couple lines.
20:05:19 <bramantio> umh.. i'm sorry sir it's my false, i've missed some package to install. :) thank you for all
20:06:55 <Cale> bramantio: Okay, no worries!
20:12:29 * hackagebot multiaddr 0.1.0 - A network address format  https://hackage.haskell.org/package/multiaddr-0.1.0 (MicxjoFunkcio)
20:29:37 <danilo2> Hello guys! Could anybody tell me what such contexxt reduction stack overflow - compilation error basically means? I have defined all the necessary TypeFamilies and basically what the error mentions is always true : http://lpaste.net/151990
20:30:30 <pumita> Hello, I'm trying to define the following monad instance but I'm failing inthe attemp: http://lpaste.net/151991
20:32:29 * hackagebot lit 0.1.1.0 - A simple tool for literate programming  https://hackage.haskell.org/package/lit-0.1.1.0 (cdosborn)
20:38:13 <glguy> pumita: The type of v is a -> M m b
20:38:26 <glguy> so you'll need to unwrap that 'M' type to use it in that context
20:38:34 <glguy> just like you did with the argument 'Mk mk'
20:42:55 <pumita> glguy: like this? http://lpaste.net/151991
20:42:59 <pumita> still not working :/
20:43:15 <pumita> it says: `Could not deduce (b ~ Maybe b)`
20:44:39 <glguy> Yeah, now you're on the second problem with your code
20:45:38 <glguy> Think about what type should go in this location and then about what the type of 'b' is
20:46:57 <pumita> the type of what's at the left of ">>=" is "Maybe a -> m (Maybe b)" which I guess it's correct
20:46:59 <glguy> "this location" being   Just a -> _
20:47:36 <pumita> oh, ok
20:48:29 <pumita> oh, got it
20:48:47 <pumita> glguy: thanks!! b :: Maybe b
20:49:15 <pumita> just got confused with the two monads, I thought b was of type b
20:49:53 <shachaf> i,i a variant of ScopedTypeVariables that requires that value-level names unify with type-level names
20:50:09 <shanemikel> I'm trying to get my head around tooling.. one of my concerns is moving as much as possible into the type checker, however I can't see myself abandoning partial functions.. is there any good tooling for looking for partial functions, as an example, whitelisting certain guard functions and HOF's as being safe with certain types of partial functions
20:53:02 <shanemikel> for instance
20:53:46 <shanemikel> @let tern p f g x = if p x then f x else g x
20:53:48 <lambdabot>  Defined.
20:54:32 <shanemikel> @let guardNull default = tern null (const default)
20:54:32 <lambdabot>  Parse failed: TemplateHaskell is not enabled
20:54:49 <shanemikel> @let guardNull def = tern null (const def)
20:54:51 <lambdabot>  Defined.
20:56:19 <shanemikel> and get warnings for use of head, tail, init, last except where I've explicitely stated it's safe to use those functions as the third parameter to guardNull
20:56:39 <EvanR> shanemikel: theres hlint
20:57:04 <shanemikel> yeah, but in hlint can you whitelist the use of partial functions in  a fine-grained way?
20:58:07 <drbean> No #stack channel?
20:58:14 <shanemikel> :t guardNull
20:58:15 <lambdabot> Foldable t1 => t -> (t1 a -> t) -> t1 a -> t
20:58:19 <kadoban> drbean: #haskell-stack
20:58:25 <drbean> Stack is trying to extract ghc to /tmp and failing.
20:58:37 <EvanR> shanemikel: hlint has a lot of customizability
20:58:59 <geekosaur> try setting TMPDIR somewhere?
20:59:06 <shanemikel> has anybody here done anything like that, though?
20:59:33 <kadoban> drbean: I remember there being an issue for that in the github tracker, if you can find it it should have advice for a workaround.
21:00:13 <shanemikel> drbean: are you sure you have enough free space on /tmp?
21:00:20 <EvanR> shanemikel: whats the point of guardNull ?
21:00:37 <shanemikel> @let betterExample = guardNull []
21:00:40 <lambdabot>  Defined.
21:00:41 <shanemikel> :t betterExample
21:00:43 <lambdabot> Foldable t => (t a -> [t1]) -> t a -> [t1]
21:01:26 <shanemikel> > betterExample (toUpper . head) "hello"
21:01:27 <lambdabot>      Couldn't match type ‚ÄòChar‚Äô with ‚Äò[t1]‚Äô
21:01:28 <lambdabot>      Expected type: Char -> [t1]
21:01:28 <lambdabot>        Actual type: Char -> Char
21:01:30 <shanemikel> oops
21:02:05 <shanemikel> > betterExample (\(x:xs) -> toUpper x : xs) "hello"
21:02:08 <lambdabot>  "Hello"
21:02:10 <shanemikel> > betterExample (\(x:xs) -> toUpper x : xs) ""
21:02:11 <EvanR> if youre going to use a function to analyze a list then you dont need head
21:02:12 <lambdabot>  ""
21:02:28 <EvanR> the function can pattern match
21:03:36 <EvanR> shanemikel: and to show it in the type, make the function passed in take two args
21:03:36 <shanemikel> right, but the better tool would do some kind of analysis based on pattern matches in partial functions.. and for specific data types I guess I would like to list partial functions and partial pattern matches that are safe when used with certain functions
21:04:15 <EvanR> a poor mans non-empty list would be (a, [a])
21:04:24 <nitrix> Isn't the goal to improve GHC instead of having multiple "better tools" ?
21:04:31 <Tendies> Hi I'm trying to modify this code https://p.teknik.io/GAkgc to replace duplicates with underscores. It currently just removes the duplicates, however I don't understand how it's removing them. How would I make it insert underscores?
21:05:09 <shanemikel> I don't know, I'm just asking.. if such a tool were to become sufficiently good, I think that would be helpful to the ghc people
21:05:18 <shanemikel> and until it is, it would be nice for practitioners
21:05:40 <EvanR> shanemikel: when youre dealing with arbitrary lists, then you want pattern matching or functions that do it for you. you only would use partial functions in convenient cases where you know the offending cases are impossible
21:06:15 <EvanR> shanemikel: i checked hlint and it looks like you cant create new hints
21:06:28 <EvanR> UHG... you CAN create new hints
21:06:55 <kadoban> shanemikel: It seems to me that you're getting a bit too ‚Ä¶ systematic about it. In practice I just treat every 'head' and 'fromJust' and etc. as suspicious until investigated.
21:07:15 <shanemikel> yeah, i'm just suspecting that the convenient cases are gonna be relatively common, and I'm inclined to future-minded thinking, like "what if I were to be working on a project with a group, and I/(my business) was really interested in squeezing the most out of static safety"
21:07:43 <nitrix> > concat $ map (\s -> if length s > 1 then "_" else s) $ group "Mississippi"
21:07:44 <lambdabot>  "Mi_i_i_i"
21:07:45 <nitrix> Tendies: ^
21:07:49 <Reshi> Tendies: when it finds the duplicate (elem x seen) it just makes a recursive call to continue finding duplicates with (dup seen xs)
21:08:24 <Tendies> oh sorry nitrix i meant replace dups with underscores
21:08:39 <nitrix> That's what it is doing.
21:08:54 <Tendies> like, hello world -> hel_o w_r_d
21:09:01 <nitrix> Oh.
21:09:25 <kadoban> Tendies: Are you looking for efficient or concise?
21:09:40 <EvanR> shanemikel: for more generic static safety, you will need more sophisticated type technology, which might take some getting used to by a whole team, or make everyone hate haskell ;)
21:09:42 <nitrix> I could easily write a O(n^2) approach.
21:09:43 <shanemikel> the other avenue would be to just check for partial functions (I guess somehow weed them out of Prelude) and maybe craft an apply if not a monoidal falsey value
21:09:58 <Tendies> kadoban: i guess concise
21:10:22 <Tendies> yeah the approach is expected to be n^2 but i dont know how to go about it
21:10:30 <Reshi> Tendies: just change your 'dup seen xs' to 'dup (seen + ['_']) xs
21:10:39 <EvanR> shanemikel: you can ban partial functions, but you will need human touch to know when it makes sense to use them
21:11:38 <Tendies> Reshi: that makes it do markDup2 "abcabc" = "______"
21:11:50 <EvanR> and to know when Maybe and Either dont make sense
21:11:58 <shanemikel> right, that's why the idea of a whitelist to me seems like good common ground.. at least beats the sifting, and allows you to hack away and fix later
21:12:11 <Reshi> Tendies: uh for me it is returning abc___
21:12:12 <EvanR> whitelist?
21:12:21 <shanemikel> also, it'd be nice for working on teams, because you can't always read every bit of code
21:12:36 <Reshi> Tendies: I was talking about the line: elem x seen = dup (seen ++ ['_']) xs
21:12:42 <Tendies> oh
21:13:03 <Reshi> Tendies: the 5th line
21:13:42 <shanemikel> right, that's what I asked about initially, if there was a way to whitelist specific types of partial functions used with specific HOFs or guard functions..
21:13:59 <EvanR> i still dont get that
21:14:06 <nitrix> @let foo s = go s [] where go [] seen = []; go (x:xs) seen = (if x `elem` seen then '_' else x) : go xs (x : seen)
21:14:11 <lambdabot>  Defined.
21:14:17 <nitrix> > foo "Hello world"
21:14:18 <EvanR> partial functions dont get safer when passed as arguments
21:14:22 <lambdabot>  mueval-core: Time limit exceeded
21:14:32 * nitrix scratches head
21:14:54 <Reshi> Tendies: you got that?
21:15:12 <nitrix> > foo "Hello world"
21:15:13 <Tendies> ok i got that Reshi, thanks. as for the first thing you said about how it works, is it only adding to the result list if its not a duplicate?
21:15:15 <EvanR> shanemikel: but you can match certain patterns and warn / ignore things in hlint
21:15:16 <lambdabot>  "Hel_o w_r_d"
21:15:20 <nitrix> There we go :)
21:15:34 <nitrix> Tendies: ^ Not sure why it didn't print the first time.
21:15:52 <MarcelineVQ> Bot gets busy
21:16:20 <Reshi> Tendies: yeah, if it finds the character x is already in the `seen` list it just skips it (goes with the first guard)
21:16:44 <Tendies> so its not that it removes it, but rather doesnt add it. ok
21:17:05 <Tendies> oh man nitrix that is scary looking to me, this is my 2nd week of haskell
21:17:18 <shanemikel> I guess it would make more sense to build a type class out of it.. a class which has instances for the most commonly excluded pattern match or usual base case of recursive functions for data types that I use
21:17:22 <nitrix> Tendies: On a single line, I bet it does!
21:18:00 <Reshi> Tendies: That is correct. Remember that lists are immutable, you can't change anything, just read it and create a new one with new rules.
21:18:27 <Reshi> One character at a time
21:19:21 <kadoban> > flip evalState S.empty $ mapM (\x -> do {seen <- get; put $ S.insert x seen; return $ if x `S.member` seen then '_' else x}) "mississippi"
21:19:26 <lambdabot>  "mis_____p__"
21:19:35 <Tendies> lol
21:19:45 <EvanR> shanemikel: eh? probably not ;)
21:19:58 <nitrix> Tendies: I have a function `go` hidden inside `foo` that's doing the work of iterating one character at a time on the string. It matches the pattern (x:xs). For the x, it checks if it's an `elem` of seen, when it is, it yields '_', otherwise x (the character). Then for the reminder of the character, it calls this go function again, but with (x : seen), which is the previous seen list, including the character
21:20:00 <nitrix> we've just dealt with.
21:20:21 <nitrix> Tendies: It looks intimidating, but it's actually the most "naive" way to implement it, I think.
21:20:49 <shanemikel> instance BaseCase [] where _ <^> [] = []; (<^>) = $
21:20:51 <Tendies> actually it looks really similar to the function i modified, just condensed i guess
21:21:21 <tbskm> Hi, I'm new to Haskell and could use some guidance. I'm currently trying to implement a program that computes the area of a polygon (http://mathworld.wolfram.com/PolygonArea.html). I have a function to calculate the determinant which works correctly (det :: (Double, Double) -> (Double, Double) -> Double), but I'm having trouble with the actual computation (computePolygonArea :: [(Double, Double)] -> Double).
21:21:50 <EvanR> shanemikel: are you expecting much code to need to completely ignore empty lists and return empty lists?
21:21:58 <shanemikel> no
21:22:00 <tbskm> Tried list comprehensions, recursion with guards, and zipWith. I think I'm honestly just not thinking about it correctly
21:22:12 <Tendies> if it's a type error at least, what i learned is to comment out the type declaration and check what type GHCi thinks it is in the environment
21:22:20 <EvanR> (in a way they normally dont already do)
21:22:45 <Tendies> its likely something to do with type conversions based on form of operators you're using
21:23:26 <nitrix> Tendies: Mhhh, that's one way to do it. Another one is to replace an expression with _ (a type hole). The compiler will tell you what it's expected to be there.
21:23:31 <shanemikel> I'm just worrying about the heads, and tails I'm littering everywhere, and that I might use lambda syntax too often
21:23:47 <EvanR> heh, yeah you probably shouldnt be using head that much
21:23:54 <Tendies> i.e. 5/2 makes a float and 5 `div` 2 will do integer division (if 5,2 are ints)
21:23:59 <tbskm> The thing that I'm having trouble with is adding up sequential elements in a list, then adding the first list to the final element.
21:24:00 <EvanR> use pattern matching
21:24:07 <shanemikel> EvanR: by that logic neither lambda syntax
21:24:31 <EvanR> you can make a local new function without a lambda
21:24:33 <Reshi> tbskm: What have you got till now? Can you do a paste? 
21:24:46 <EvanR> in the where block
21:25:16 <shanemikel> I know, but I don't want to give it up.. that's my point, I'm trying to reconcile my love of terse code with bottom
21:25:16 <nitrix> Tendies: http://lpaste.net/151995
21:25:16 <EvanR> hence "equational reasoning"
21:25:25 <nitrix> Tendies: For convenience before I close that vim tab.
21:25:35 <Tendies> thanks
21:25:42 <EvanR> you may find code getting terser without lambdas bloating things up
21:25:55 <EvanR> youll get more opportunities for point free compositional style
21:26:34 <tbskm> sure, here's my attempt at recursion: https://gist.github.com/anonymous/608eacb048db470855f3
21:26:41 <EvanR> @unpl sum . reverse . sort . take 5 . replicate 3 4
21:26:41 <lambdabot> (\ c -> sum (reverse (sort (take 5 (replicate 3 4 c)))))
21:27:08 <shanemikel> I'm aware of point-free
21:27:14 <shanemikel> and .
21:27:14 <tbskm> Reshi: my last list comprehension was a bit ago, let me try to write another one 
21:27:16 <EvanR> probably not the best example
21:27:30 <EvanR> but extra lambda variables take up space
21:28:20 <tbskm> Reshi: you can see the issue is that I can't access the first element in the list once i hit the end of it, which you need to compute the polygon area. not sure if that's possible to do with recursion in this way
21:28:40 <shanemikel> sure, but I was just curious if you guys have more sophisticated ways of dealing with this than I was aware of
21:29:08 <shanemikel> I guess I could probably use TH to generate matching patterns
21:29:38 <EvanR> normally i just write code ;)
21:30:08 <tbskm> Reshi: oh, hold on, I just remembered i could do something like vertices@(v1:v2:xs)
21:30:21 <Reshi> tbskm: you could just add the first element to the end of the list also before calling 
21:30:45 <shanemikel> guardNull 'const []' (\(x:xs) -> toUpper x : xs)
21:30:50 <shanemikel> generates
21:30:54 <shanemikel> f [] = []
21:31:03 <shanemikel> f (x:xs) = toUpper x : xs
21:31:09 <shanemikel> err
21:31:13 <shanemikel> f [] = const []
21:31:23 <EvanR> see, you dont need all that to do that
21:31:27 <Reshi> tbskm: computePolygonArea (nodes ++ [(head nodes)])
21:31:41 <shanemikel> EvanR: what do you mean?
21:32:23 <tbskm> Reshi: wow, I can't believe I didn't think of that. Let me try that out. Thanks for your help!
21:33:23 <EvanR> hrm, well your capitalize function with two lines is certainly more readable and takes less total code
21:33:36 <shanemikel> right, but it needs to be in a block
21:33:57 <EvanR> yeah that is more common style, rather than a long dense line
21:34:00 <shanemikel> idk.. maybe I've been drinking too much DRY coolade
21:34:06 <shanemikel> err koolade
21:34:19 <EvanR> DRY has to be reconsidered after a 90 degree rotation in haskell
21:34:39 <shanemikel> what do you mean
21:34:47 <shanemikel> ^ to >
21:35:17 <monochrom> DRYTM
21:35:39 <nshepperd_> repeat yourself twice but not thrice
21:35:56 <monochrom> Kolmogorov complexity theory implies that you will repeat yourself.
21:38:25 <EvanR> certain kinds of repetition can make code more clear
21:38:47 <EvanR> and tricks to golf can reduce your code to line noise
21:42:17 <shanemikel> well, to be fair, one of the reasons I'm fighting against where blocks is I've removed the auto-indent from my haskell plugin in vim... it was buggy and more annoying than it was worth
21:42:26 <shanemikel> but I noticed tonight that this is much cleaner:
21:42:36 <shanemikel> someline = something
21:42:40 <shanemikel>   where
21:42:47 <shanemikel>     something = "Hello"
21:42:54 <shanemikel> than...
21:42:57 <shanemikel> someline = something
21:43:12 <shanemikel>   where a = "Hello"
21:43:30 <shanemikel>         b = "!"
21:43:32 <shanemikel> oops
21:43:34 <shanemikel> that didn't line up
21:43:36 <shanemikel> :)
21:44:29 <shanemikel> up till tonight I was writing where blocks with the first name on the same line, and lining everything up under it, but It's a lot easier to do the next line
21:45:14 <monochrom> yes, I also separate "where" from what follows
21:46:12 <EvanR> shanemikel: i would put where on the previous line, then only use two spaces on the next line for the block
21:46:39 <EvanR> i try to do very little crazy distant indenting, maybe because i have 80 char columns
21:48:06 <prati> Hi All, 
21:48:55 <prati> There are 10's of books on Object oriented Analysis and Design, but when I searched for design books on  functional programming 
21:48:57 <tnks> is there any merit to something like a BiApplicative, but for sum types instead of product types?
21:49:07 <prati> I came across this http://programmers.stackexchange.com/questions/89273/where-are-all-the-functional-programming-design-patterns
21:49:52 <prati> The accepted answer says in FP,  there is no itch which Design Pattern is cure for.
21:50:23 <prati> The accepted answer says, In FP there is no itch which Design Pattern is cure for 
21:50:36 <Axman6> design patterns exist to make up for deficiencies in the language. many design patterns are simply called "functions" in Haskell
21:51:04 <tnks> what exactly a design pattern is not well stated.
21:51:13 <prati> Okay, I want to know how Haskell address lot of design patterns 
21:51:14 <EvanR> haskell does have its share of design patterns, which indeed could be considered missing language features
21:51:40 <tnks> prati: "addressing a lot of design patterns" is the wrong way of stating it.
21:51:54 <prati> Yes, True
21:52:09 <tnks> the design patterns were supposed to each solve problems -- largely relating to extensibility.
21:52:20 <tnks> Haskell has plenty of solutions for extensibility.
21:52:27 <roboguy`> tnks: how would it work?
21:52:37 <tnks> roboguy`: the BiApplicative thing?
21:52:42 <roboguy`> yeah
21:53:08 <tnks> so I'm not sure. . . I think I'm trespassing on a bad idea -- like the lawless Point, but a BiPoint.
21:53:31 <tnks> that's why I stepped out to BiApplicative, to get a point with maybe some laws.
21:53:53 <tnks> but bipure takes both an left and right value.
21:54:06 <roboguy`> tnks: for a sum type?
21:54:09 <tnks> I'd just have a leftPure and rightPure.
21:54:12 <roboguy`> ah
21:54:21 <prati> tnks EvanR  Axman6  It would be nice to have haskell implementations of the use-cases where a particular design pattern is meant to be used 
21:54:30 <tnks> roboguy`: any ideas?
21:54:40 <tnks> I'd like to be more parametric if I can.
21:55:11 <EvanR> prati: youd hope that reusable solutions could be made into a library or a function in the language, haskell lets you do that with a lot of traditional patterns, so they arent patterns anymore. but you still have the combinator pattern, the DSL pattern, etc
21:55:48 <tnks> prati: just name a pattern -- most of the ones in the original book are really uninteresting once you have first class functions.
21:55:51 <prati> EvanR I merely mean having coming from OOP, I can improve my haskell skils
21:56:24 <EvanR> ah yeah, theres the OOP pattern ;)
21:56:42 <roboguy`> tnks: I guess it would be something like the opposite of Data.Biapplicative?
21:56:49 <EvanR> which means hide variety of implementations behind a record type of functions
21:56:54 <tnks> roboguy`: yeah, I think so.
21:57:01 <prati> tnks How about Factory ?
21:57:18 <tnks> prati: Factories in Haskell are just functions.
21:57:29 <EvanR> i never understood the factory pattern
21:57:32 * hackagebot binary-tagged 0.1.3.1 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.3.1 (phadej)
21:58:09 <tnks> prati: you just partially apply a curried function.
21:58:12 <tnks> simple as that.
21:58:12 <EvanR> creating new data structures and values is ingrained in everything you do in haskell
21:58:35 <EvanR> because you cant mutate any data structures
21:58:45 <prati> Okay
21:58:47 <roboguy`> A factory might also be sorta like using a record type that (might) have functions in it
21:59:06 <EvanR> yeah the object pattern
21:59:17 <tnks> prati: yeah, every time you think "I need an interface" just think "I need a data structure"
21:59:36 <tnks> because your data structure can have functions in it (just like an interface has methods)
21:59:52 <tnks> and you can make them "anonymously" to your heart's content.
22:00:08 <tnks> roboguy`: do you think the dual of Biapplicative exists?
22:00:10 <EvanR> anonymous data structure? ;)
22:00:14 <EvanR> cool
22:00:25 <prati> But how can I have different types to have common interface ?
22:00:42 <shanemikel> EvanR: actually, I didn't go with that because I wouldn't know what to do with guards
22:00:43 <prati> tnks instantiate type class ?
22:00:43 <EvanR> record of functions (or lazy values)
22:00:53 <shanemikel> EvanR: as for where, that is
22:00:59 <roboguy`> prati: it would be easier to describe this stuff with regard to a specific problem though. An abstract comparison of functional programming in Haskell and OO can be tricky
22:01:10 <EvanR> shanemikel: you can use guards in where defs
22:01:20 <tnks> prati: a type class is a statically dispatched interface -- and generally we only want one instance of any type for a type class.
22:01:23 <prati> Let's take this one https://en.wikipedia.org/wiki/Factory_method_pattern#Java
22:01:27 <roboguy`> prati: don't worry about type classes for the moment. Just make a record type and you can have functions inside of it
22:01:38 <shanemikel> EvanR: no, I'm saying if you put it on the same line, the where block spans across guards.. so it doesn't look right
22:01:42 <tnks> prati: OO uses of interfaces are often much more dynamic -- in which case, just use data structures.
22:02:04 <prati> " in which case, just use data structures." Can you explain this
22:02:32 <EvanR> prati: hes talking about record types
22:02:44 <prati> Okay
22:03:25 <tnks> prati: if you have this: interface Foo<A, B> { B someMethod(A a); }
22:04:07 <tnks> then you can just have this:  data Foo a b = Foo { someMethod :: a -> b }
22:04:21 <shanemikel> EvanR: yeah, I just was reading about factory tonight.. It seems like object currying
22:04:43 <tnks> prati: you don't need something as heavy as a record type even, but I though I'd make the parallel more straight-forward.
22:05:00 <EvanR> prati: something like http://lpaste.net/151996
22:05:30 <prati> tnks Ahh, The Foo example made it clear to me !
22:05:30 <shanemikel> so you don't have to pass the class name at instantiation (like in java).. because types are lost at runtime, but introspection requires the type names to be stored with the object for certain purposes
22:06:02 <shanemikel> specifically avoiding coersion after unwrapping
22:06:15 <shanemikel> (or something along those lines)
22:06:22 <roboguy`> shanemikel: well, that depends on what you mean. In GHC, type class dictionaries are passed at runtime
22:06:43 <shanemikel> because of the simple way Java and other encumbant OOP langs deal with object pointers
22:06:44 <EvanR> yes so static dispatch isnt the right way to explain it
22:07:32 <tnks> prati: you can actually program in Java without interfaces at all, and still get all the benefits of interfaces with the exception of subtyping (which one can argue isn't a benefit at all)
22:07:36 <roboguy`> and you can have runtime polymorphism, where the exact instance isn't known until the program is run
22:08:15 <shanemikel> so instead of doing new List<Int>(Int.__class__)
22:08:15 <tnks> prati: you'd also probably see a performance hit, but I'm ignoring that.
22:08:16 <prati> tnks Yes true, 
22:09:22 <django_> this problem has been on my mind
22:09:27 <django_> and i only have the brute force soln
22:09:29 <django_> Radioactive decay is a stochastic (i.e. random) process at the level of single atoms, in that, according to quantum theory, it is impossible to predict when a particular atom will decay.[
22:09:30 <django_> errr
22:09:33 <tnks> prati: the only thing interesting about an interface is that we can make arbitrary types of it (which is in some constrast to ADTs, which ahve a closed algebra)
22:09:38 <django_> "Design and implement an algorithm for finding the longest repeated sequence in a long string of characters. For example, abra is the longest repeated sequence in the string abracadabra."
22:10:08 <prati> tnks Yes, as long as the contract is obeyed !
22:10:09 <tnks> prati: but we can embed interfaces into ADTs anyway, so it's actually a false dichotomy
22:10:33 <EvanR> tnks prati we can implement the interface in many ways, the record type is only talking about the interface, the values of that type can be anything that satisfies it
22:10:39 <tnks> prati: in Haskell we often enforce contracts more with type classes than silent contracts on data structures.
22:10:46 <prati> tnks But How Can you impose a contract ?
22:11:04 <tnks> prati: do you know about QuickCheck?
22:11:16 <prati> No, But I heard about it 
22:11:32 <tnks> two techniques that come together for asserting contracts are parametricity and quickcheck.
22:11:38 <prati> @let data Foo a b = Foo { someMethod :: a -> b }
22:11:41 <lambdabot>  Defined.
22:11:55 <tnks> parametricity gives us theorems for free, and helps us have less possible implementations to have built.
22:11:56 <prati> In above, I don't understand how we are enforcing ?
22:12:08 <EvanR> theres not much in that data type
22:12:26 <EvanR> prati: did you see my example?
22:12:41 <prati> Yes, Circle and Ellips
22:12:41 <tnks> quickcheck helps us automate tests for the implementations we have left after programming parametrically.
22:12:45 <prati> ** Ellipse
22:13:15 <EvanR> so you are enforcing that you have two doubles for an ellipse, and two modifier operations
22:13:22 <tnks> prati: also, we can use the type system for a lot of contraints too, but it gets hard sometimes.
22:13:27 <EvanR> you can enforce more with more stuff in the type
22:14:35 <prati> EvanR Yes, But it is just what it contains, right ?
22:15:24 <EvanR> by itself that can prove a lot, but sometimes you need more type system features, and sometimes you cant express the constraint you want easily
22:15:31 <shanemikel> django_: you can probably break the string in half first.. and remove a single character for each iteration.. shifting the rightmost splice one character left until overlap, shift the leftmose splice once and repeat
22:16:55 <EvanR> prati: another strategy is the smart constructor pattern, instead of exposing the data constructors directly, you hide the constructor in a module which verifies all the properties you want, and only exposes a limited API to the user to manipulate the values
22:17:36 <EvanR> another name for this is the "trusted kernel". nothing proves you implemented the hidden mechanisms correctly, but at least the other code isnt responsible for it
22:17:58 <tnks> EvanR: prati: and smart constructors are done plenty with other languages too.
22:18:00 <kadoban> django_: I believe a suffix tree reduces that to a pretty trivial problem.
22:18:09 <prati> EvanR I am not aware of smart constructors
22:18:27 <tnks> most people don't check contracts on interfaces anyway in Java -- they say they do, but it's just a giant runtime failure.
22:18:28 <EvanR> prati: and for an example of a compiler-checked non trivial property, see the ascii package which statically ensures that your data is ascii-only
22:18:39 <EvanR> this is done with type classes
22:18:44 <tnks> prati: have you ever made a constructor private?
22:18:59 <tnks> prati: and made "public" constructors that delegate to private ones?
22:20:20 <django_> kadoban, i dont get it one sec
22:20:44 <prati> tnks Yes in Java
22:20:56 <EvanR> https://hackage.haskell.org/package/text-latin1-0.3/docs/Text-Ascii.html
22:21:08 <tnks> prati: same idea in Haskell. . . but with simple functions.
22:21:18 <EvanR> IsAscii serves as a proposition that you have ascii data
22:21:19 <tnks> prati: you can hide things in a Haskell module.
22:21:37 <EvanR> your program can only do ascii operations on it if you can satisfy this property with the code
22:23:59 <kadoban> django_: I gotta go to sleep, but my understanding is that if you trace the path to the deepest *internal* node of a suffix tree, that's the longest repeated substring.
22:24:23 <prati> tnks EvanR I am checking more on that !!
22:24:53 <EvanR> ways that you can satisfy include... doing a runtime check that the data is ascii only, constructing a string out of ascii-only strings, etc
22:25:49 <tnks> prati: you'll find some Haskellers discourage too much hiding. . . but that's kind of a social decision.
22:26:11 <prati> Is there a simple example for that ?
22:26:27 <prati> ascii example seems to be too much for me at this time
22:26:51 <EvanR> yeah that is using more advanced stuff
22:27:08 <EvanR> the smart constructor is more understandable for beginners
22:28:00 <EvanR> which would look like
22:28:23 <EvanR> fromByteString :: ByteString -> Maybe Ascii
22:28:40 <EvanR> and this would be hidden
22:28:47 <EvanR> newtype Ascii = Ascii ByteString
22:29:08 <prati> Okay, fromByteString
22:29:18 <prati> will validate and only construct if it validated ?
22:29:22 <EvanR> yes
22:29:40 <EvanR> so any value of Ascii will be "guaranteed" to have ascii only data
22:29:52 <prati> okay, nice
22:30:17 <EvanR> that means utf8 encode is a no-op, for example
22:30:28 <EvanR> so that can be an operation you expose
22:30:28 <prati> How it is guaranteed that the other module has to go through fromByteString for creating Ascii ?
22:30:35 <prati> through hiding ?
22:30:52 <EvanR> you dont export the Ascii newtype constructor
22:31:04 <prati> okay, 
22:31:19 <prati> EvanR  The similar idea is there in OOP also, 
22:31:39 <prati> you make the constructor private, and expose some public one which validates
22:32:01 <prati> Is it similar to that ?
22:32:12 <EvanR> yes
22:35:57 <grawity> so I was asked to compile git-annex "with debug symbols" to debug a segfault, how does one do that here?
22:36:20 <EvanR> prati: another way to enforce things is with phantom types, which includes extra facts in your data types *type* which proves that certain things happened
22:37:57 <EvanR> the types are called phantom because they dont correspond to any runtime data, they are only used for doing the compile time verification
22:38:42 <prati> Yes, it is explained here https://wiki.haskell.org/Phantom_type
22:39:19 <prati> But how does the parametric type is useful, it it is not used ?
22:39:30 <EvanR> it is used during type checking
22:40:31 <prati> okay
22:40:32 <EvanR> prati: heres an example from an imperative API. 
22:41:42 <EvanR> lets say you have a monad for doing opengl commands OpenGl s a
22:42:00 <prati> okay
22:42:20 <EvanR> and there is an important global state in the gl context which is fairly invisible, but you have to remember it before doing certain commands
22:43:30 <EvanR> so you put that state in the s position when writing the types for the commands
22:43:57 <EvanR> in this command, it doesnt matter what state youre in, you can always do the command
22:44:12 <EvanR> flush :: OpenGl s ()
22:44:37 <EvanR> in this command, you have to have the global state = Safe
22:45:14 <prati> yes, for flush you don't need
22:45:18 <EvanR> uploadGeometry :: Geometry -> OpenGl Safe ()
22:47:53 <EvanR> to get to the Safe state, you have to use some command which takes you from the Unsafe state to the Safe state
22:48:06 <EvanR> (or alreadt be in the safe state)
22:49:49 <prati> okay
22:49:49 <EvanR> becomeSafe :: OpenGl Unsafe a -> OpenGl Safe a
22:51:10 <EvanR> im not showing the implementation of OpenGl type, or how you would put them together, or how youd finally run a full program (finally in IO), because i dont think this fully adds up exactly as is. but something like this using phantom types can let you be more flexible with imperative APIs
22:51:55 <EvanR> normally if you want to temporarily do something during an unsafe region, youd use a bracket-like wrapper, but with opengl that wouldnt work since you may want to remain unsafe for an indefinite amount of time
22:52:30 <EvanR> its just not set up to agree with bracketing
22:53:25 <prati> Okay
22:53:54 <EvanR> done right, it would stop you from doing opengl commands that are strictly inappropriate given the previous history of your commands
22:54:27 <EvanR> (and if implemented in full generality, actually spell out how that works, since its hard to derive from gl docs alone)
22:56:00 <prati> I am sorry, I am lost, where phantom fit in exactly ?
22:56:12 <EvanR> sorry
22:57:08 <prati> I will read more about phantom types, 
22:57:17 <prati> and go through your explanation one more time 
22:57:31 <EvanR> well, i need to fix that explanation
23:07:30 <Tendies> What does "The IO action `main' is not defined in module `Main'" mean?
23:07:44 <Tendies> i have import Data.Char at the very top of my file
23:08:10 <gfixler> you don't have a main function in Main.hs
23:08:25 <Tendies> gfixler: i don't even have a Main.hs
23:08:37 <EvanR> put a module declaration at the top of your file
23:08:38 <gfixler> do you have module Main where at the top of something?
23:08:55 <Tendies> no
23:09:06 <EvanR> if you dont it takes your file to be the Main file
23:09:09 <Tendies> how about this, what is the correct way to designate to import Data.Char
23:09:31 <Tendies> the assignment instructions just say to import it
23:10:10 <EvanR> module NotTheMain where -- at the top of your file
23:10:27 <Tendies> NotTheMain can be whatever?
23:10:38 <EvanR> youll find out it needs to be the same name as the file
23:11:02 <gfixler> isn't there an idea to eventually allow any name, and indeed, several per file?
23:11:13 <EvanR> that would be cool
23:11:14 <Cale> Tendies: If you don't have a module declaration, the default module name is Main
23:11:32 <gfixler> EvanR: if a little hard to find things in larger projects
23:11:35 <Cale> Tendies: and if you're compiling an executable, it will expect to find an IO action called main in that module.
23:11:57 <gfixler> Cale: is *that* the difference between Library and Executable in the cabal setup?
23:12:02 <Tendies> so my file is a01.hs, the compiler isnt liking "module a01 where import Data.Char"
23:12:02 <Cale> Tendies: If you're loading the code in ghci, I wouldn't expect to see it complain about that.
23:12:24 <gfixler> I think it has to be a capitalized name
23:12:25 <gfixler> A01
23:13:17 <Cale> gfixler: I guess it's part of it... the primary difference is that if you're compiling a library, stuff gets added to the package database. If you're just compiling an executable, GHC doesn't need to know about it once it's built.
23:13:53 <gfixler> Cale: which package database? Local, or hackage, or...?
23:14:21 <Cale> One of your local package databases -- whichever the package is being installed to.
23:14:53 <gfixler> I don't know about this yet
23:15:18 <gfixler> Where do I read up on my local databases? Cabal docs?
23:15:38 <Tendies> uh okay its okay with the import now, but is saying parse error on a correct type declaration
23:16:09 <gfixler> Tendies: code?
23:16:33 <Tendies> increaseTen :: Num a => a -> a
23:16:41 <Tendies> its been correct for like 200 compiles
23:16:59 <EvanR> prati: still there?
23:17:50 <liste> @paste -- Tendies: can you lpaste the whole file?
23:17:50 <lambdabot> Haskell pastebin: http://lpaste.net/
23:17:54 <prati> EvanR Yes 
23:18:38 <EvanR> k i have an example
23:18:44 <prati> Cool :)
23:19:45 <Cale> gfixler: there's some information here about the fields that occur in library and executable sections https://www.haskell.org/cabal/users-guide/developing-packages.html#library
23:19:52 <EvanR> its going to look pretty weird, but at least there are phantom types ;)
23:21:02 <prati> Yes, I will try to understand that 
23:21:05 <Tendies> http://lpaste.net/151997 this is all thats relevant
23:21:26 <Cale> Tendies: move the import to the next line
23:21:54 <gfixler> Cale: thanks
23:21:57 <Cale> Tendies: The first non-whitespace character following 'let', 'of', 'do', or 'where' (in this case, it's 'where') sets the indentation level for the block
23:22:16 <Cale> Tendies: In order to be part of the block, subsequent lines have to align with that character
23:22:50 <Cale> So if you put the import there, you'd have to indent the rest of your file by 17 spaces
23:23:07 <Cale> (so you probably don't want to do that :)
23:23:23 <EvanR> prati: http://lpaste.net/151998 so i set up a weird monad indexed by dependent types which wraps IO
23:23:55 <EvanR> prati: the x is the required initial state, and the y is the final state after doing the command
23:24:20 <EvanR> boring works with any state, and doesnt change it (a to a)
23:25:20 <EvanR> you combine programs with bind, which takes a command and a continuation. you see that the ending and beginning states must agree for the two fragments to connect
23:26:08 <EvanR> also the type of runGL establishes that you start Safe and you must end Safe
23:27:13 <EvanR> you can use execute unless youre in the unsafe state
23:27:15 <EvanR> cant*
23:27:27 <EvanR> and you cant get there without using engage
23:27:42 <EvanR> and before the program is over you have to disengage
23:27:57 <EvanR> which is one reason the badProgram wont check
23:28:54 <Reshi> Tendies: uppercase module name right?
23:29:12 <Tendies> my filename isnt uppercase tho but i changed to A01.hs and A01
23:29:46 <prati> I can see how phantom types are being used for type check 
23:29:47 <Reshi> Tendies: the filename doesn't matter, your module name can be different from the file. Like a randomfile.hs can have module Main... 
23:30:05 <Tendies> what were you saying about it being the same name as the file
23:30:06 <prati> EvanR  But, I will take more time to grasp and understand your example
23:30:14 <prati> It's great example !!
23:30:27 <EvanR> prati: no guarantees it actually compiles of course ;) in fact i forgot to pass an Int to execute
23:32:14 <prati> But I get the point, how you are enforcing that Unsafe and Safe, even though they are not being used 
23:32:31 <prati> For execute
23:33:40 <EvanR> yes you can also use type classes and constraints to use more complex conditions on the phantom type variables
23:34:29 <prati> Okay,
23:34:40 <EvanR> here there is only 2 states
23:34:57 <EvanR> but if there was a more elaborate state, may you only care that the state has some computable-at-compile-time property
23:35:38 <prati> Yes
23:37:40 <EvanR> prati: and actually.. it should be pure :: a -> GL x x a, else you can cheat
23:38:13 <EvanR> and be damned
23:40:09 <prati> You mean it can be passed two different ones, as it needs to be of only of one type
23:40:18 <nineonine> hi there !
23:40:25 <nineonine> how to sort Data.Map on keys ?
23:40:28 <nineonine> 8)
23:40:45 <prati> Either Safe or Unsafe, not both
23:42:35 <EvanR> prati: the way it was, you could build an action to switch from any state to any state at any point
23:42:43 <pavonia> nineonine: There's toAscList, IIRC
23:43:11 <nineonine> oh yeah that will suffice
23:43:13 <nineonine> thanks !
23:43:22 <EvanR> prati: with x x, it properly states that pure wont modify the state, which makes sense since pure isnt supposed to have any effect anyway
23:43:35 <prati> Okay
23:43:36 <EvanR> it just wraps some value
23:44:48 <EvanR> the problem would have been that the final program didnt to the proper background action to engage or disengage
23:45:11 <EvanR> it was acting like a cast, letting the programmer bust out of the jail he was supposed to be in
23:45:24 <prati> Okay :)
23:45:41 <EvanR> which you can do anyway, with unsafeCoerce ;)
23:46:13 <prati> Okay
23:48:19 <prati> EvanR One more thing I wanted to discuss, 
23:49:09 <prati> Is there  any design exercises that I can practice or it is irrelevant question ?
23:49:57 <EvanR> theres cis194 which is a course on haskell, im not sure if thats what you mean by design exercises
23:50:14 <EvanR> @where cis194
23:50:14 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
23:50:19 <prati> No not CIS194, 
23:50:53 <prati> In OOP,  People give so much importance to Low level design  ( LLD, HLD) 
23:51:26 <prati> if you take interview scenarios,  for ex: Design a valet parking system 
23:52:16 <prati> you need to create bunch of classes, and relate them  ( sometime they can be best designed with state machines) 
23:52:29 <EvanR> like UML?
23:52:39 <prati> and you are evaluated on the design skills of LLD, Yes like UML
23:52:56 <EvanR> all that counts as "low level" ?
23:53:14 <prati> from a interview perspective, yes
23:53:25 <EvanR> yurg ;)
23:53:52 <prati> LLD, HLD are more of recruiters terms :)
23:54:33 <prati> So, for "Design a valet parking system" 
23:55:05 <EvanR> seems like you want to start with a database
23:55:24 <prati> you would start doing by classes like Vehicle, Spot, Ticket, Valet 
23:55:39 <prati> and try to relate to them in OOP design problem !
23:56:08 <prati> Try to draw a UML for that !
23:56:18 <EvanR> those are 4 sets in a relational database ;)
23:56:35 <EvanR> we just have to specify the relationships
23:56:56 <EvanR> screw the code ;)
23:57:15 <prati> Yes, I wanted to know how to approach these kind of problems from Haskell
23:57:37 <prati> For practice if there some exercises, 
23:58:18 <EvanR> i would be interested to know of any resources like that myself
23:58:37 <EvanR> most haskell stuff i see is research, math, or ... web apps
23:59:29 <prati> Yes, 
