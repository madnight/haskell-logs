00:00:00 <Tendies> i don't have access to nub ;_;
00:00:32 <liste> Tendies: an assignment with a restricted Prelude?
00:01:00 <Tendies> filter (\(x:xs) -> not . setEqual x xs) partitionSet xs
00:01:05 <Tendies> is what i tried
00:01:24 <Tendies> or subset instead of setEqual
00:01:26 <liste> you seem to miss a $
00:01:36 <liste> or actually
00:01:44 <liste> yeah, $
00:02:22 <Tendies> you see what im trying to do right?
00:02:28 <liste> (or parenthesis)
00:02:52 <Tendies> or eta reduce?
00:03:22 <liste> not in this case, at least directly
00:03:59 <liste> and x and xs are different types so setEqual won't work
00:04:04 <Tendies> > subset "abc" "bca"
00:04:05 <lambdabot>  True
00:04:24 <liste> you can implement your own nubBy and use that
00:04:40 <Tendies> [x] xs
00:06:34 <Tendies> > subset "abc" ["acb","bca"]
00:06:35 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
00:06:35 <lambdabot>      In the expression: "acb"
00:06:35 <lambdabot>      In the second argument of ‘subset’, namely ‘["acb", "bca"]’
00:06:48 <Tendies> > subset ["abc"] ["acb","bca"]
00:06:49 <lambdabot>  False
00:07:38 * hackagebot graphmod 1.2.9 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.2.9 (IavorDiatchki)
00:07:38 * hackagebot riemann 0.1.1.0 - A Riemann client for Haskell  https://hackage.haskell.org/package/riemann-0.1.1.0 (JosephAbrahamson)
00:27:33 * hackagebot gridfs 0.1.0.1 - GridFS (MongoDB file storage) implementation  https://hackage.haskell.org/package/gridfs-0.1.0.1 (btubbs)
00:34:01 <anohigisavay> is main function a special case to lazy evaluation?
00:34:28 <liste> anohigisavay: no, execution is different than evaluation
00:34:30 <EvanR> main isn't even a function
00:34:46 <EvanR> :t main
00:34:47 <lambdabot>     Not in scope: ‘main’
00:34:47 <lambdabot>     Perhaps you meant ‘min’ (imported from Data.Ord)
00:34:52 <EvanR> IO ()
00:34:59 <liste> "main" just describes an IO action which is given to RTS to be executed
00:36:49 <EvanR> is it just me or is describing the second forall in forall a. a -> (forall b. b -> a) as being "to the right of the ->" incredibly confusing
00:37:25 <EvanR> and the the first forall in (forall a. a -> a) -> (forall b. b -> b) is to the left therefore rank 2
00:38:05 <EvanR> there are several ->'s ... the first result on google for this topic is ambiguous
00:38:19 <anohigisavay> EvanR: it is confusing. just read it yesterday xD
00:38:46 <EvanR> also from it i get the impression that foralls can only be introduced surrounding a function type, but i know thats not true
00:38:54 <EvanR> :t undefined
00:38:55 <lambdabot> t
00:39:32 <anohigisavay> EvanR: other usages are not about RankNTypes but other extensions and have different meanings
00:39:37 <EvanR> the first forall is just as much to the left of a -> and the other one which is ok to move out
00:40:04 <EvanR> as the other one*
00:40:08 <EvanR> the syntax is identical
00:42:16 <anohigisavay> EvanR: i've given up on this topic xD
00:43:42 <EvanR> i wrote a polymorphic type checker with the exact same syntax and still dont get it ;)
00:44:00 <EvanR> haskellwiki gripes
00:47:07 <EvanR> wait a minute... 
00:47:22 <EvanR> can anyone sign up and fix things on haskellwiki ?!
00:47:34 * hackagebot gridfs 0.1.0.2 - GridFS (MongoDB file storage) implementation  https://hackage.haskell.org/package/gridfs-0.1.0.2 (btubbs)
00:47:44 <EvanR> NOTE: Automatic wiki account creation has been disabled....
00:48:11 <quchen> EvanR: Account creation via email is fairly quick
00:48:17 <quchen> Or used to be when I did it some time ago
00:48:22 <EvanR> ok
00:50:53 <xuex> sooo
00:51:04 <xuex> can you hear me?
00:51:14 <liste> xuex: yes
00:51:23 <xuex> nice
00:55:36 <anohigisavay> http://lpaste.net/152810
00:58:21 <EvanR> anohigisavay: what are you trying to do
01:03:23 <anohigisavay> EvanR: just don't like (Foldable t) => R.SPipeline -> V.Valve p (t a) (t a) and seeing if i can make type synonym to the `t a` part
01:03:40 <dominik> why does it suffice for (/) :: (Fractional a) => a -> a -> a to typecheck, if I just say (fromIntegral n) / (fromIntegral m) (where n,m :: Int).
01:04:02 <dominik> That is, how is the conversion Num a --> Fractional a happening under the coers?
01:04:44 <dominik> because fromIntegral only achieves Int -> Num t, right? 
01:04:53 <dominik> but (/) expects a Fractional b
01:05:19 <dominik> so does the conversion from Num a --> Fractional b happen implicitly? Or what is happening here?
01:08:34 <EvanR> dominik: theres no conversion from Num to Fractional because they arent types
01:08:47 <EvanR> it starts as Int and ends up as Double
01:08:56 <EvanR> (fromIntegral converts from Int ot Double)
01:09:30 <EvanR> Double was chosen due to special default rules
01:11:01 <dominik> EvanR: oh, ok. So the typechecker is able to see from the fromIntegral :: Num a => Int -> a that (Num a) and, moreover, from the (/) context that also (Fractional a)
01:11:24 <EvanR> :t (fromIntgral n) / (fromIntegral m)
01:11:25 <lambdabot>     Not in scope: ‘fromIntgral’
01:11:26 <lambdabot>     Perhaps you meant ‘fromIntegral’ (imported from Prelude)
01:11:29 <dominik> and then it uses a = Double because it satisfies both (Num a) and (Fractional a)
01:11:32 <EvanR> :t (fromIntegral n) / (fromIntegral m)
01:11:33 <lambdabot> Fractional a => a
01:11:52 <dominik> EvanR: ok, I think I get it. Thanks :)
01:12:05 <EvanR> it uses a = Double since its the default Fractional
01:12:24 <anohigisavay> dominik: i think it's simply because class Num a => Fractional a
01:12:44 <anohigisavay> sorry forget what i said
01:12:49 <anohigisavay> xD
01:13:05 <EvanR> and yeah all Fractionals are Num talking about Num here is redundant
01:15:42 <EvanR> anohigisavay: another confusing thing when you realize it exists is class Num a => Fractional a means "Fractional implies Num" (syntax is backwards)
01:16:03 <EvanR> and its reversed wrt to that in instance declarations
01:17:20 <anohigisavay> yea i thought was the other way around xD
01:18:56 <AliAgca> Hi guys, anyone has experience with XSS (cross site scripting) prevention?
01:18:59 <Tendies> sigh i still can't get this after like 2 hours
01:19:30 <AliAgca> I am interested in best practices for preventing XSS...
01:20:43 <AliAgca> Also, if you think this is not the appropriate channel for such questions, please point me to the right one, new to IRC...
01:22:13 <EvanR> AliAgca: #webdev
01:23:03 <AliAgca> @EvanR thank you
01:23:03 <lambdabot> Unknown command, try @list
01:24:06 <AliAgca> @list
01:24:06 <lambdabot> What module?  Try @listmodules for some ideas.
01:24:25 <AliAgca> EvanR: thank you
01:34:59 <joco42> > "s" ++ show $ (+1) 1
01:35:01 <lambdabot>      Couldn't match expected type ‘Integer -> t’
01:35:01 <lambdabot>                  with actual type ‘[Char]’
01:35:01 <lambdabot>      The first argument of ($) takes one argument,
01:35:24 <joco42> > "s" ++ show ( (+1) 1)
01:35:26 <lambdabot>  "s2"
01:35:29 <joco42> hmm
01:38:16 <EvanR> :t ("s" ++) . show . (+1)
01:38:18 <lambdabot> (Num a, Show a) => a -> [Char]
01:38:32 <EvanR> ("s" ++) . show . (+1) $ 1
01:38:44 <EvanR> > ("s" ++) . show . (+1) $ 1
01:38:46 <lambdabot>  "s2"
01:42:35 <edofic> >  "s" ++ (show $ (+1) 1)
01:42:36 <lambdabot>  "s2"
01:50:42 <echo-area> Which branch of mathematics are xxxmorphisms studied?
01:50:54 <merijn> Category Theory
01:51:01 <echo-area> merijn: Thanks
01:55:35 <phaazon> I wonder whether I should go on using MonadTrans or switch to the more general MonadBase typeclass
01:56:09 <phaazon> with MonadBase, MonadIO shouldn’t be used anymore
02:52:39 <Sabbaot> hi
02:55:16 <liste> hi Sabbaot 
03:14:41 <Sabbaot> just started to reading "Learn You a Haskell for Great Good!"
03:16:14 <odgrim> hello! on gentoo systems the ebuild relies on a bzipball at code.haskell.org/~slyfox/ghc-amd64/ghc-bin-7.10.3-amd64.tbz2
03:16:27 <odgrim> that link currently times out, making all haskell installs fail from the overlay
03:21:19 <phaazon> odgrim: that’s a pity
03:21:44 <odgrim> it is, was hoping to tag someone from haskell's ops team to kick it
03:38:09 <macalimlim> hello :)
03:38:47 <liste> hello macalimlim !
03:40:02 <macalimlim> can anyone recommend a good websocket library for haskell?
03:41:53 <liste> macalimlim: https://www.stackage.org/package/websockets ?
03:45:54 <macalimlim> looks great liste, thanks :)
04:00:33 <ij> If I've x :: a -> m a, I can make more of the same type with (\a -> return a >>= x >>= x).
04:00:44 <ij> Does this op. have a name/is defined somewhere?
04:04:14 <liste> would something like wxHaskell + netwire be a good idea to build a native GUI where blocks are dragged around, combined etc?
04:12:47 <merijn> liste: I would say reactive-banana is probably more suited?
04:13:04 <merijn> liste: reactive-banana was explicitly designed to work well with callback systems like GUI frameworks
04:13:22 <liste> merijn: thanks (: I'll look into that
04:14:51 <ij> Maybe I'm just talking about msum, hmm.
04:16:18 <liste> :t msum -- has a MonadPlus constraint, so I don't think it applies
04:16:19 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
04:17:04 <liste> ij: do you mean something like "foldr (>>=) (return a)" ?
04:17:29 <merijn> I think ij is looking for Kleisli?
04:17:46 <merijn> And/or fish operator?
04:18:00 <merijn> :t (>=>)
04:18:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:18:35 <merijn> "return a >>= x >>= x" is just "x >=> x" afaict?
04:18:41 <ij> Yes, fish operator!
04:18:45 <ij> Haha.
04:19:49 <ij> It's so nice that you can think of an idiom and find out it has a name.
04:20:09 <merijn> ij: If you wanna be all fancy, the "proper" name for that is "kleisli composition"
04:23:01 <ij> Thanks!
04:37:19 <mtesseract> Hi
04:39:34 <quchen> Is there a reason there's no combination of <%~ and <<%~ in Lens, i.e. an operator that modifies and returns both the old and new entries?
04:39:56 <liste> hi mtesseract!
04:40:37 <merijn> quchen: They ran out of unique operator names? ;)
04:40:55 <Taneb> quchen: because I don't want to add twenty more operators
04:41:33 <quchen> <<<%~~
04:41:39 <quchen> The squid operator.
04:42:40 <merijn> > generalCategory '🐙'
04:42:41 <lambdabot>  OtherSymbol
04:42:45 <merijn> w00t
04:42:51 <merijn> We can have an actual squid operator :)
04:44:01 <Nuxular> That squid looks to me like he's saying "Look! I'm here."
05:17:46 <lwm> hey, anyone got any experience with -ddump-to-file ?
05:18:12 <lwm> I just realised Stack does this automatically when I run the test command
06:16:55 <bennofs> lwm: hmm, what experience is there to have with -ddump-to-file? I use it
06:17:45 <lwm> oh, just the person to answer the question!
06:18:15 <lwm> the recent PR you submitted for tasty-th is working great
06:18:25 <lwm> but in my new generated code, the tasty stdout for the test report
06:18:45 <lwm> dissapears into a test log ... because, (I think!) that stack passes this -ddump-to-file option
06:19:01 <bennofs> lwm: -ddump-to-file is a GHC option as far as I'm aware
06:20:21 <lwm> yes, they pass it via `ghc-options` or so ...
06:20:31 <lwm> think I will just raise an issue on github
06:20:34 <bennofs> lwm: ah, no, that is not related to test output at all
06:21:16 <bennofs> lwm: what this option does is it tells ghc to write any output produced by any of the various -ddump-<something> flags while compiling to a file instead of to stdout 
06:21:32 <bennofs> it only affects output produced during compile-time
06:21:44 <bennofs> by GHC, not by the compiled program during run-time
06:22:11 <lwm> well, TH is doing that then, right?
06:22:13 <lwm> remember this?
06:22:13 <lwm> https://github.com/lwm/tasty-discover/blob/a3235c75f32fee3c5464ee4c7f90265f3f007806/src/Test/Tasty/Run.hs#L94-L103
06:22:35 <bennofs> OOOH... I'm not sure how it interacts with TH, yes, you could be right then
06:22:39 <lwm> the output from this TH generated code is getting written to file, right?
06:24:10 <lwm> darn .. I can't think of any other way to get around this ... so far, I just `cat` the test log and get the test output
06:24:42 <lwm> oh! https://github.com/commercialhaskell/stack/issues/426#issuecomment-152780832
06:28:34 <Ankhers> '
06:33:37 <SX> Hi! Could anyone help me, please? I get GHC error "Simplifier ticks exhausted" with Serializable instances inlines (here: https://github.com/SimpleX91/snmp/tree/binary)
06:35:00 <SX> Lib is compiling (but takes a long time and >500mb RAM)
06:35:21 <SX> But if you'd try to compile benchmark
06:35:40 <SX> This error occurs
06:36:23 <Mateon1_> Hello, I'm trying to debug a haskell application, successfully compiled with RTS support and -prof, but no exception is printed with +RTS -xc. The program after a while displays a Windows "stopped responding" dialog.
06:37:46 * hackagebot luminance 0.10 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.10 (DimitriSabadie)
06:52:19 <black0range> Does anyone know about a decent guide to MVectors / ST ?
07:02:47 * hackagebot luminance-samples 0.10 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.10 (DimitriSabadie)
07:05:12 <bennofs> lwm: hmm wait, do you run the tests at compile time?
07:05:31 <bennofs> lwm: i thought you only generated the tests, and the tests are still run normally
07:06:43 <bennofs> lwm: I think this has nothing to do with -ddump-to-file, but it's rather a normal stack feature(?)(i don't use stack, so idk) that the test output is suppressed by default (cabal does it the same way)
07:16:31 <dredozubov> is it possible to default associated type family return value without overlapping instances?
07:17:47 * hackagebot megaparsec 4.4.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.4.0 (mrkkrp)
07:18:58 <lwm> bennofs: you know, I am still unsure. Kind of hacking my way through this ... I am generating template haskell code from haskell code
07:19:20 <lwm> I am waiting for a moment of clarity to understand my own code ;)
07:19:38 <bennofs> lwm: yeah, but the template haskell will only generate code to run the test. The actual running of the tests happens when the test executable is run 
07:20:19 <lwm> right, I get you. So perhaps it isn't what I though
07:20:37 <lwm> thought*. In any case, put it to the stack folks in that thread to see what they think
07:37:48 * hackagebot blatex 0.1.0.5 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.5 (2016rshah)
07:41:19 <quchen> Ugh, stylish-haskell deletes SOURCE annotations for mutually recursive imports?
07:42:48 * hackagebot generic-deriving 1.10.2 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.2 (ryanglscott)
08:17:50 * hackagebot text-show 3.0.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.0.1 (ryanglscott)
08:40:19 <mniip> shachaf, so what's that Representable stuff you've been talking about?
08:40:39 <mniip> i.e what's wrong with Lens s t a b = (p ~ Star f, Functor f) => p a b -> p s t
08:44:08 <bennofs> mniip: traverse is no longer a Traversal with that representation :/
08:44:13 <mniip> sure
08:44:39 <bennofs> mniip: and you need profunctors to even define lenses, right now base is enough
08:44:58 <mniip> but you can't do prisms without profunctors
08:45:00 <mniip> nor isos
08:45:44 <bennofs> mniip: yes. that's also why many of the "simple" lens libraries don't  support prisms or isos
08:46:36 <mniip> :t dimap (maybe (Right Nothing) Left) (either (fmap Just) pure) . left'
08:46:38 <lambdabot> (Applicative f, Choice p) => p a (f a1) -> p (Maybe a) (f (Maybe a1))
08:47:44 <getynge> I'm new to haskell, is it possible to check for a hole in a tuple? eg follow one codepath if a tuple = (_, 0) and another if it = (0, _)?
08:48:29 <bennofs> getynge: how can you have holes in tuple? do you mean the typed holes that GHC supports?
08:48:35 <getynge> yeah
08:49:33 <bennofs> getynge: those holes are not really supposed to be there in a finished program, they are only an aid for development
08:49:38 <getynge> oh
08:51:36 <djbeau> getynge: your description sounds like standard pattern matching, not really type holes as the term is defined in ghc
08:53:04 <getynge> does haskell have something like hash maps?
08:53:29 <hexagoxel> is there a quick way to list _all_ instances defined by some package (by module)?
08:53:59 <dmj> getynge: Data.Map / Data.HashMap (containers / unordered-containers) 
08:54:04 <getynge> ah alright
08:54:15 <getynge> I'm gonna keep reading learn you a haskell for great good, I clearly have a lot to learn
08:54:20 <getynge> thanks for the help
08:54:30 <dmj> hexagoxel: instances of a specific type, or all instances of anything in a module?
08:54:44 <hexagoxel> all instances of anything.
08:55:54 <dmj> hexagoxel: maybe, but I don't think so, :browse shows all classes, :i on a type shows all classes it is an instance of, :i on a class shows all types that are instances of that class
08:59:52 <dbeacham> what are considered to be acceptable uses of existential types?
08:59:54 <GoorMoon> q
08:59:59 <GoorMoon> /?
09:00:01 <GoorMoon> ?
09:00:08 <dbeacham> are there many examples in the wild? packages that use them etc.
09:00:27 <puregreen> hm, I think Aeson used to escape non-ASCII characters, but 0.11 doesn't do it; does anybody remember whether Aeson used to do it or not?
09:03:30 <GoorMoon> @help
09:03:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:03:38 <GoorMoon> @list
09:03:38 <lambdabot> What module?  Try @listmodules for some ideas.
09:03:45 <GoorMoon> @help list
09:03:46 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
09:03:52 <glguy> GoorMoon: You can play with lambdabot in /msg
09:05:48 <bennofs> dbeacham: I don't think there are many. I've personally used them in http://hackage.haskell.org/package/dynamic-cabal-0.3.5/docs/src/Distribution-Client-Dynamic-Query.html#Query, although of course I can't say if that usage is "generally accepted". The Query data type requires an "intermediate" type i which has a Typeable instance (Selector represents a chunk of Haskell code that is passed to an interpreter
09:05:50 <bennofs> and returns a value of type i. The function in the Query is used to postprocess that result)
09:09:06 <jasonkuhrt> The associtative law for Monads seems a bit contrived. Whereas 1 + (1 + 1) has the real effect of causing the second (+) to evaluate _first_ I don't think that's the case with the Monad test: m >>= (\x -> f x >>= g). In the Monad case all that is being done is `x` is manually threaded one extra step. Am I missing something because I dont' really see how `1 + (1 + 1)` can be considered the same as `m >>= (\x -> f x >>= g)` E.g. The M
09:10:37 <mnoonan> it's clearer with the (>=>) operator instead of (>>=)
09:10:51 <hpc> jasonkuhrt: you're putting far too operational a perspective on it
09:11:12 <jasonkuhrt> hpc: What do you mean?
09:11:16 <hpc> the relevant part of associativity isn't that there's more lambdas or anything like that, it's that both formulations of 1 + 1 + 1 equal 3
09:11:28 <jasonkuhrt> mnoonan: Thanks, I'm not aware of >=>
09:11:38 <mnoonan> :t (>=>)
09:11:39 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:11:43 <hpc> both evaluate to the same final value
09:12:16 <jasonkuhrt> hpc: Associativity is about grouping, that seems relatively operational to me (I'm probably mistaken)
09:12:40 <hpc> jasonkuhrt: consider associativity of (/)
09:12:44 <jasonkuhrt> hpc: You're suggesting that the definition of grouping is unimportant, what is important is that two forms are equivilant
09:12:49 <hpc> > 2 / (2 / 2)
09:12:51 <lambdabot>  2.0
09:12:53 <hpc> > (2 / 2) / 2
09:12:53 <mnoonan> f >=> g is just your \x -> f x >>= g
09:12:54 <lambdabot>  0.5
09:13:19 <mnoonan> and the monad associativity law in terms of >=> is just (f >=> g) >=> h == f >=> (g >=> h)
09:14:27 <hpc> oh no wait, i see what you were asking now
09:14:36 <jasonkuhrt> hpc: I missed your point with (/)
09:14:42 <jasonkuhrt> (/) is not associative
09:14:45 <jasonkuhrt> right...
09:14:48 <jasonkuhrt> ^ ah ok
09:15:45 <hpc> i assume you were asking purely syntactically, because the (>>=) formulation of associativity has extra crap in it?
09:16:32 <hpc> but yeah, associativity is all about having the ability to logically transform freely between the two associations
09:16:33 <jasonkuhrt> hpc: Basically, yes
09:16:49 <hpc> ah k, then mnoonan had your answer a full page up :P
09:16:51 <jasonkuhrt> hpc: But its more than that I think
09:17:13 <ij> With ByteString.Char8, putStrLn . unpack . pack doesn't do the same thing as putStrLn. (Why) is that expected?
09:17:15 <hpc> ill wait for follow-up questions before clogging the channel up again ;)
09:17:37 <jasonkuhrt> In `1 + (1 + 1)` the grouping has the effect of changing evaluation order
09:17:51 <jasonkuhrt> But with the Monad test for `>>=`
09:18:12 <jasonkuhrt> `g` is still executed last
09:18:20 <mnoonan> do you really evaluate the last * first when you read 0 * (1 * (2 * (3 * (4 * 5))))?  :)
09:18:43 <jasonkuhrt> I think I do? Haha
09:18:48 <jasonkuhrt> Certainly the machine does
09:18:49 <jasonkuhrt> no?
09:19:03 <Zekka|Sigfig> Well, it could. It doesn’t necessarily have to
09:19:07 <glguy> jasonkuhrt: It doesn't matter if the value g is evaluated first or not, it matters if the final expression is equal
09:19:12 <jasonkuhrt> Its inner-brackets-first evaluation order?
09:19:15 <hpc> jasonkuhrt: so, your thinking is that (x + y) evaluates x first, then y, then adds them?
09:19:15 <glguy> it's not about order of expression evaluation
09:20:45 <jasonkuhrt> hpc: I suppose so
09:21:04 <jasonkuhrt> glguy: Ok, as mnoonan was saying
09:21:34 <jasonkuhrt> So what is the definition of "grouping" in the associative law then?
09:21:36 <jasonkuhrt> Can someone tell me?
09:22:01 <Zekka|Sigfig> Well, in (x + y) + z, you can evaluate (x + y) first or you can evaluate z first.
09:22:02 <mnoonan> think of f,g,h as if they were snippets of C source code
09:22:11 <Zekka|Sigfig> But you never get to evaluate (y + z). That’s not allowed
09:22:12 <mnoonan> and >=> like appending the source
09:22:39 <mnoonan> so the programs (f >=> g) >=> h and f >=> (g >=> h) are the same, yeah?
09:22:45 <Zekka|Sigfig> in x + (y + z) you can evaluate x first or (y + z) first, I don’t care, but you’re not allowed to evaluate (x + y)
09:23:12 <hpc> yeah, Zekka|Sigfig has the right explanation
09:23:32 <jasonkuhrt> Zekka|Sigfig: Thanks, yep that edit makes sense
09:23:50 <Zekka|Sigfig> Yeah. For (+) it doesn’t matter since (+) is usually associative but there are lots of operations where it totally does
09:24:09 <Zekka|Sigfig> (“being associative” = “it doesn’t matter where I put those parens”)
09:24:51 <lpaste> glguy pasted “for jasonkuhrt” at http://lpaste.net/152830
09:24:57 <Zekka|Sigfig> If you had x + (y * z) vs (x + y) * z it would totally matter! Or maybe (x ** y) ** z vs x ** (y ** z)
09:25:01 <glguy> jasonkuhrt: Here's an example of a Monad instance that doesn't satisfy the law
09:25:10 <jasonkuhrt> Zekka|Sigfig: But the question I have is that in the case of Monad there are no parens, its associative by another means, so the definition of "grouping" must be more generic than talking about parens
09:25:39 <jasonkuhrt> mnoonan has a good example I will look at more closely with `>=>`
09:25:44 <Zekka|Sigfig> jasonkuhrt: The associativity law for monads is a little awkward to express because the standard formulation really only works for (>=>) and (<=<)
09:25:51 <Zekka|Sigfig> it’s a little bit more awkward to write for (>>=)
09:26:26 <jasonkuhrt> When writing it for >>= we don't use parens
09:26:30 <jasonkuhrt> We use function nesting
09:26:34 <Zekka|Sigfig> (f <=< g) <=< h is f <=< (g <=< h)
09:26:43 <mnoonan> the identity laws are nicer for >=> too, assuming you're going to look at those too
09:27:01 <jasonkuhrt> Therefore the definition of "grouping" in associativity must not map to parens
09:27:02 <Zekka|Sigfig> f <=< g = (\x -> f x >>= g)
09:27:04 <jasonkuhrt> but something else
09:27:10 <Zekka|Sigfig> er, g x >>= f
09:27:16 <djbeau> hexagoxel: I realize this is late, but check out :info! in ghci as well
09:27:21 <Zekka|Sigfig> @src <=<
09:27:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:27:28 <Zekka|Sigfig> (I’m worried I’ve accidentally botched it!)
09:27:57 <jasonkuhrt> Unless you count the parens from lambas but that seems trite
09:28:06 <jasonkuhrt> that's just a syntax artifact
09:28:21 <Zekka|Sigfig> jasonkuhrt: Try expanding all the occurrences of <=< in the expression using >>= and you might see why we talk about the >>= version as an associativity rule
09:28:37 <Zekka|Sigfig> (It may be easier to go through =<< first, then flip things around to get the >>= version)
09:28:39 <jasonkuhrt> ^ Yeah!
09:28:40 <ij> Which bytestring can I fit non-ascii values into with OverloadedStrings?
09:29:01 <mnoonan> jasonkuhrt: the "real" formulation of the associative law is for (>=>) though. When you talk about monads in Haskell, a lot of it gets translated to (>>=) because of the "do" syntax sugar.
09:29:09 <jasonkuhrt> Thanks everyone! I can work backwards from these to understand >>= better
09:29:13 <Zekka|Sigfig> the rule for >>= is equivalent to the one with <=< or >=>, we just write it with different syntax to use >>=
09:29:33 <Zekka|Sigfig> jasonkuhrt: Another thing you could try to do is prove that (.) is associative
09:30:00 <Zekka|Sigfig> (<=<) and (.) are kind of similar for reasons you will totally discover if you stare at the Category type class
09:30:02 <mnoonan> jasonkuhrt: so you're looking at a translation to (>>=) of the associative law for (>=>), not exactly an associative law (in the way you'd expect) for (>>=) itself.
09:30:08 <hexagoxel> djbeau: thanks, i was not aware normal info had any filtering going on.
09:30:43 <Zekka|Sigfig> (https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Category.html <- this class explains how (<=<) and (.) are similar, but it might be a little abstract for you right now)
09:31:09 <geekosaur> ij, none of them. if you need to represent anything outside the range 0-255, you need to encode to utf8 or etc.
09:31:26 <geekosaur> it's a *byte* string, after all
09:31:30 <jasonkuhrt> mnoonan: That's an approach to take yes
09:31:37 <ij> geekosaur, I mean I know they just do bytes, but isn't there a function that makes 0xaaaa into two bytes?
09:31:49 <jasonkuhrt> Zekka|Sigfig: Thanks, noting it!
09:31:58 <Zekka|Sigfig> summary: (<=<) is to (.) as return is to id.
09:32:23 <Zekka|Sigfig> return is just id with more ms in it, and if you put ms in the arguments to (.) in the same places you put ms in return, you get (<=<)
09:35:41 <mnoonan> a kind of dump example: say you defined an operator @ by x @ y = x + 2*y.  It's pretty much equivalent to +, but a little tweaked.
09:35:53 <geekosaur> ij, if it's textual, use http://hackage.haskell.org/package/text/docs/Data-Text-Encoding.html#v:encodeUtf8 (takes a Text, produces a ByteString). if it's binary, use the binary or cereal package
09:35:59 <mnoonan> and it satisfies the law ((x @ y) @ z) @ z = x @ (y @ z)
09:36:20 <mnoonan> which doesn't look much like a normal associative law, but is really just the associative law for + in disguise.
09:39:04 <jasonkuhrt> mnoonan: Actually that looks exactly like the normal law (unless the extra `@z` is intentional, see right beore `=`)
09:39:16 <mnoonan> the extra @z is intentional :)
09:39:22 <ij> geekosaur, Thanks1
09:39:23 <jasonkuhrt> Oh, ok, then I need to think more!
09:39:24 <jasonkuhrt> haha
09:39:25 <ij> Looks likt it works.
09:39:46 <Zekka|Sigfig> jasonkuhrt: Try expanding the @s!
09:40:13 <xnull> I can't run `stack setup` on my new Linux Mint VM. https://gist.github.com/xnil/169ce1f820407c057bb7
09:40:20 <xnull> Anybody got any clue how to fix this?
09:40:35 <exio4> mnoonan: are you sure?
09:41:18 <mnoonan> > let (@) x y = x + 2*y
09:41:19 <lambdabot>  <hint>:1:6: parse error on input ‘@’
09:41:25 <mnoonan> :(
09:41:31 <mnoonan> oh, right
09:41:38 <mnoonan> > let (#) x y = x + 2*y
09:41:39 <lambdabot>  <hint>:1:7: parse error on input ‘)’
09:41:43 <Zekka|Sigfig> ha ha ha
09:41:52 <Zekka|Sigfig> > let (+~+) x y = x + 2*y
09:41:54 <lambdabot>  <no location info>: not an expression: ‘let (+~+) x y = x + 2*y’
09:42:03 <Zekka|Sigfig> @let (+~+) x y = x + 2*y
09:42:05 <lambdabot>  Defined.
09:42:05 <geekosaur> xnull, maybe: sudo apt-get install build-essential
09:42:33 <mnoonan> > ((1 +~+ 2) +~+ 3) +~+ 3
09:42:34 <lambdabot>  17
09:42:42 <mnoonan> > 1 +~+ (2 +~+ 3)
09:42:44 <lambdabot>  17
09:45:28 <xnull> geekosaur: oi, couldn't remember what it was named. thanks.
09:48:19 <djbeau> hexagoxel: no problem.  it doesn't completely answer your question because the world of instances is open, so it is impossible for the system to know of every instance in the world (on on hackage)
09:49:32 <djbeau> though it is a database I think would be handy for discovering new useful libraries
09:50:23 <jasonkuhrt> mnoonan: Your last example is _not_ assocative though, since the number of functions on either side of the `=` are not equal
09:51:07 <shachaf> mniip: "Representable p" means there exists some f (Rep p) such that "p x y" is isomorphic to "x -> f y"
09:51:20 <mnoonan> jasonkuhrt: the point is that the weird law for @ is equivalent to the normal associative law for +, just like the weird law for (>>=) is equivalent to the normal associative law for (>=>).
09:51:29 <mniip> f ~ (Rep p) you mean?
09:51:32 <Zekka|Sigfig> The funky law mnoonan wrote only works because (+) is associative
09:51:52 <jasonkuhrt> What exactly is the weird law for @?
09:52:12 <Zekka|Sigfig> ((x @ y) @ z) @ z = x @ (y @ z)
09:52:44 <Zekka|Sigfig> Write the @s in terms of addition and multiplication to have the secret of why revealed to you
09:52:52 <jasonkuhrt> In word it is that Left-associative grouping is equal to right-associative grouping less one operation?
09:53:11 <jasonkuhrt> Oh I did, I'm just trying to understand what such a law might be called
09:54:19 <hexagoxel> djbeau: yeah i know; that's why i was asking for something per-package. i guess some grepping magic will have to do.
09:54:46 <jasonkuhrt> The trick is how *2 always doubles the final result of the right version
09:55:33 <jasonkuhrt> So Associativity is essentially implemented in different ways in different categories
09:55:43 <jasonkuhrt> I think I get it now
09:56:20 <Cale> Er, what?
09:56:27 <mnoonan> no.. associativity is associativity (modulo some details that aren't relevant here)
09:56:43 <TheMoonMaster> Could you write something like `let func = fst.($)`?
09:56:56 <jasonkuhrt> Yeah scratch that, said it poorly
09:57:15 <mauke> TheMoonMaster: no, you can't use fst on a function
09:57:42 <Cale> Part of the definition of a category is that composition is associative, i.e. that for any objects X, Y, Z, W and arrows f: Z -> W and g: Y -> Z and h: X -> Y, we have (f . g) . h = f . (g . h)
09:58:48 <Cale> The proof of this equality will indeed generally be different depending on how the composition is defined, but the property itself will be the same.
10:00:33 <Cale> There are related notions in higher category theory though, where since you have 2-arrows between your 1-arrows, instead of an equation, associativity can instead be an isomorphism consisting of a pair of 2-arrows between f . (g . h) and (f . g) . h in either direction.
10:01:03 <mnoonan> "modulo details that aren't relevant here" :)
10:03:19 <Cale> Yeah, you end up wanting additional laws for those isomorphisms to satisfy, and things begin getting quite complicated.
10:04:39 <jasonkuhrt> Hm, wait a minute, how could >>= be associative in the way that (+) if one the purposes of >>= is to support computational dependencies
10:04:52 <jasonkuhrt> way that (+) is*
10:05:22 <Zekka|Sigfig> jasonkuhrt: Well, the associativity comes from its composition rule
10:05:31 <Zekka|Sigfig> <=< is like (.)
10:05:54 <Zekka|Sigfig> It’s true that f (g (h x)) can’t be written as e.g. (f g) (h x), but f . g . h $ x can be written as (f . g) . h $ x or f . (g . h) $ x
10:06:36 <Zekka|Sigfig> Likewise, f <=< g <=< h $ x is f <=< (g <=< h) $ x is (f <=< g) <=< h $ x
10:07:43 <jasonkuhrt> Makes sense, composition is assocaitive!
10:07:59 <jasonkuhrt> hence >=> if is (.) for monads
10:08:24 <Zekka|Sigfig> (<=< is (.) for monads fwiw but it’s just this: f <=< g = f >=> g)
10:08:30 <Zekka|Sigfig> er, f <=< g = g >=> f
10:09:16 <Zekka|Sigfig> f <=< g <=< h   ~   f . g . h
10:09:58 <jasonkuhrt> Why >>= is described as associative and not some other word still seems odd, but your collective feedback has been helpful thankyou!
10:10:29 <dmsnell> jasonkuhrt did you try expanding >>= into the lambdas it equates to?
10:10:38 <Zekka|Sigfig> I don’t know why that is! But as a consolation prize, >> is associative the normal way
10:10:57 <Zekka|Sigfig> f >> g >> h = (f >> g) >> h = f >> (g >> h)
10:11:02 <Zekka|Sigfig> of course, >> is weaker than >>=
10:12:01 <jasonkuhrt> A function whose purpose is to support the build up of dependencies (of values) defies the logic of what associativity means to me haha
10:12:25 <Zekka|Sigfig> I think it would be a little silly to say “function application is associative” when it turns out it’s function composition that’s associative
10:12:26 <jasonkuhrt> dmsnell: Hm, probably but I will do it again
10:13:01 <Zekka|Sigfig> I think it’s important that people understand that monads have an associativity fixation! But it’s a little strange to say that >>= is associative.
10:14:38 <Cale> Zekka|Sigfig: Yeah, the sense in which a monad is associative is more abstract.
10:14:48 <Cale> Zekka|Sigfig: (and usually not stated in terms of >>=)
10:14:54 <jasonkuhrt> bitemyapp: FYI my questions here stem from describing >>= as associative in your book on page 865. Maybe its something to revise or add a bit more explainationa about?
10:15:02 <jasonkuhrt> ^
10:15:26 <dmsnell> the >>= is just a "bind" operation on a Monad. it's pretty easy to see with Maybe
10:15:52 <Zekka|Sigfig> I’m used to hearing monad associativity nerds talk about >>, <=<, or join as a monoid op. (afaik these all basically come down to how join and fmap join must be equivalent)
10:16:08 <Zekka|Sigfig> as it turns out this is math and in math there are lots of ways to say the same thing
10:16:21 <Cale> It's return and join that correspond with monoid unit and multiplication in an abstract sense.
10:16:37 <Cale> If you write down what a monoid is in a peculiar way
10:16:44 <Zekka|Sigfig> Cale: Yeah, monoidally joining and creating ms
10:17:21 <shachaf> (>=>) is associative but being a monoid isn't enough.
10:17:34 <Cale> It's a set M which has a unit, which if you're being a category theorist, you want to think about arrows and not elements, so you can think of it as a function u: 1 -> M
10:17:36 <shachaf> It needs to be associative across types (i.e. a category).
10:17:55 <Cale> and it also has a multiplication *: M x M -> M
10:18:03 <Cale> and those have to satisfy some laws
10:18:59 <Cale> A monad on some category C, is a functor M: C -> C, which comes with a natural transformation eta: 1 -> M, where now instead of a one-element set, 1 refers to the identity functor
10:19:29 <Cale> and a natural transformation mu: M . M -> M where here we're using the composition of functors instead of Cartesian product of sets
10:19:49 <Cale> Here, eta is return
10:19:52 <Cale> and mu is join
10:20:02 <Cale> :t return
10:20:04 <lambdabot> Monad m => a -> m a
10:20:25 <Cale> this is thought of as a natural transformation from the identity functor to our monad m
10:20:27 <Cale> :t join
10:20:29 <lambdabot> Monad m => m (m a) -> m a
10:20:38 <Cale> and this is a natural transformation from m . m to m
10:20:49 <Cale> (implementing natural transformations by way of polymorphic functions)
10:21:58 <Cale> But yeah, anyway, if you write out what the laws for a monoid are in terms of the unit 1 -> M and multiplication M x M -> M, and what the monad laws are in terms of the unit 1 -> M and "multiplication" M . M -> M, they are perfectly analogous
10:26:07 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
10:26:07 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
10:29:01 <b|ackwolf> when I write a function should I write a interface for it?
10:29:08 <johnw> you mean ,a type signature?
10:29:18 <johnw> yes, always
10:30:38 <b|ackwolf> johnw, sorry, I'm watching Erik Meijer lectures to learn Haskell.
10:31:18 <bergmark> b|ackwolf: it's often helpful to first write the signature, then implement it
10:31:32 <b|ackwolf> johnw, so the type signature of this function would be: double x = x + x
10:31:54 <johnw> that would likely be: double :: Num a => a -> a
10:32:05 <b|ackwolf> double :: Numb a => a -> a
10:32:21 <Zekka|Sigfig> I think you mean Num, since Numb isn’t in the stdlib
10:32:27 <bergmark> :-)
10:32:39 <Zekka|Sigfig> (I have a strong suspicion autocorrect has jumped on you)
10:32:42 <b|ackwolf> Zekka|Sigfig, yes, indeed :D
10:33:33 <b|ackwolf> does the argument names matter?
10:33:45 <johnw> you mean, "x"?  or "a"?
10:33:50 <b|ackwolf> johnw, yeah
10:34:06 <johnw> both are up to you
10:34:35 <johnw> they can even match, if that helps: double :: Num a => a -> a; double a = a + a
10:36:14 <b|ackwolf> thanks for sharing. should I read a book or just hanging with documentation?
10:36:47 <johnw> read as much as you can get your hands on
10:36:52 <johnw> I'm still reading, almost every day
10:37:06 <b|ackwolf> I meant the first time.
10:37:09 <oherrala> Reading is good, writing code is also good
10:37:19 <oherrala> and reading code is good also :)
10:37:54 <b|ackwolf> I'm actually write, read and review code every day
10:37:56 * hackagebot luminance 0.10.0.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.10.0.1 (DimitriSabadie)
10:37:58 * hackagebot diagrams-core 1.3.0.6 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.6 (bergey)
10:38:00 * hackagebot diagrams-lib 1.3.1.1 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.1.1 (bergey)
10:38:17 <b|ackwolf> and now I'm solving Google Code Jam in Haskell
10:38:23 <b|ackwolf> *problems
10:47:56 * hackagebot luminance 0.10.0.2 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.10.0.2 (DimitriSabadie)
10:57:56 * hackagebot freesound 0.3.0 - Access the Freesound Project database  https://hackage.haskell.org/package/freesound-0.3.0 (StefanKersten)
11:03:03 * hackagebot minilens 1.0.0.0 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-1.0.0.0 (RaminHonary)
11:03:05 * hackagebot rose-trie 1.0.0.0 - Provides "Data.Tree.RoseTrie": trees with polymorphic paths to nodes, combining  properties of Rose Tree data structures and Trie data structures.  https://hackage.haskell.org/package/rose-trie-1.0.0.0 (RaminHonary)
11:08:04 * hackagebot inf-interval 0.1.0.1 - Non-contiguous interval data types with potentially infinite ranges.  https://hackage.haskell.org/package/inf-interval-0.1.0.1 (RaminHonary)
11:16:10 <coventry> Can someone point me at an example which excludes a particular set of tests when an option is passed on the commandline to "cabal test"?
11:18:04 * hackagebot diagrams-reflex 0.1 - reflex backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-reflex-0.1 (bergey)
11:18:49 <lwm> coventry: well, you could search https://github.com/search?o=desc&q=cabal+--&ref=searchresults&s=&type=Code&utf8=%E2%9C%93
11:19:21 <lwm> also, sure to find something here: https://searchcode.com/?q=cabal+--
11:19:33 <lwm> sorry, no examples, I normally do things with stack
11:22:26 <hexagoxel> coventry: lens has test-suites with `buildable` depending on flags. if that is what you mean.
11:24:28 <hexagoxel> and hakyll seems to go deeper by using CPP.
11:25:26 <coventry> hexagoxel, lwm: Thanks
11:28:27 <jophish> gosh, I'm amazed that there isn't a package for working with lexicographic structures
11:28:35 <jophish> all I want to do is myString++;
11:28:55 <jophish> and I've ended up with another weekend's work planned!
11:30:25 <enthropy> > succ "mystring"
11:30:27 <lambdabot>      No instance for (Enum [Char]) arising from a use of ‘succ’
11:30:27 <lambdabot>      In the expression: succ "mystring"
11:38:02 <xnil> not sure i get what this means
11:38:27 <xnil> collect2: error: ld returned 1 exit status
11:38:27 <xnil> Exit code ExitFailure 1 while running ["ghc","-clear-package-db","-global-package-db","-hide-all-packages","-package","base","-package","Cabal-1.22.5.0","/tmp/stack2367/Setup.hs","-o","/home/xnil/.stack/setup-exe-cache/i386-linux/tmp-setup-Simple-Cabal-1.22.5.0-ghc-7.10.3"] in /tmp/stack2367/
11:38:43 <xnil> /usr/bin/ld: cannot find -lgmp
11:41:40 <oherrala> xnil: you are missing or ghc can't find libgmp
11:42:36 <xnil> i'm missing? :O
11:42:54 <xnil> alright. i'll scour the webernets for it.
11:45:00 <xnil> oherrala: i used stack
11:45:06 <xnil> not sure why stack didn't handle this properly
11:45:27 <oherrala> try installing libgmp (or libgmp-devel or such) to your linux?
11:46:55 <xnil> grazi
11:53:05 * hackagebot uhc-util 0.1.6.5 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.6.5 (AtzeDijkstra)
11:53:07 * hackagebot uhc-light 1.1.9.3 - Part of UHC packaged as cabal/hackage installable library  https://hackage.haskell.org/package/uhc-light-1.1.9.3 (AtzeDijkstra)
11:56:03 <jophish> hmm, What are people's preferences for: Ptr a, Ptr () and Ptr Void
11:56:26 <jophish> I suppose it depends on the context
11:57:06 <monochrom> none of the above
11:57:13 <shachaf> Ptr is invariant, so all the options are kind of scow.
11:57:23 <shapr> scow?
11:57:27 <shachaf> Yep.
11:57:36 <shachaf> If you have Ptr (), you can write to it, and if you have Ptr Void, you can read from it.
11:57:44 <monochrom> I use Ptr XXX, and define my own "data XXX = XXX" and make sure it is not a Storable instance.
11:58:01 <shapr> shachaf: what does scow mean?
11:58:33 <coventry> lwm: out of curiosity, how would you do it under "stack test"?
11:58:59 <jophish> monochrom: but none of () ,a (on it's own) and Void are instances of Storable
12:00:10 <monochrom> but XXX can be renamed to remind me that it has XXX meaning on the C side
12:00:21 <jophish> ah, I see
12:00:41 <monochrom> in fact it becomes important when I also have YYY
12:01:27 <Tendies> hey guys I've done almost everything for my function to generate all partitions of a set, however i don't know what's going wrong when i filter them down at the end http://lpaste.net/152833
12:01:28 <monochrom> Ptr XXX and Ptr YYY are not interchangeable, but if you call them both Ptr Void you make them interchangeable
12:02:04 <jophish> I think that's the crux of it, one needs to create extra data structures in order to say that they're not interchangeable
12:03:08 <monochrom> you can say "newtype ZZZ = MkZ Void" if you want to not "create extra data structure"...
12:03:30 <jophish> oh sure, I didn't mean to type structure :)
12:03:39 <jophish> I usually just do "data ZZZ"
12:03:59 <Tendies> for example, partitionSet' [1,2] gives [[[1,2]],[[1],[2]],[[2,1]]], and when i filter that is only leaves [[1,2]]. then with a three element input it starts leaving empty elements
12:04:20 <monochrom> I just forgot that EmptyDataDecl exists.
12:05:17 <merijn> monochrom: That's ok, since it's Haskell2010 anyway!
12:07:54 <monochrom> oh yikes, it is
12:08:11 <merijn> monochrom: Just like PatternGuards! And everyone always forgets!
12:08:19 <monochrom> s/I just forgot that EmptyDataDecl exists/I just forgot to read all of Haskell 2010
12:08:24 <hodapp> :P
12:08:43 <dedgrant> Tendies: What happens if you reduce some simple expressions by hand? Can you discover where the problem crops up?  Is there a minimal case that produces null partitions?
12:08:43 <monochrom> pattern guards and do-if-then-else are the ones I know
12:09:17 <jophish> I don't think I've ever had cause to use pattern guards
12:09:45 <johnw> jophish: they can be a handy alternative to using isJust in a guard, for example
12:09:50 <merijn> jophish: I do, not a lot, but they can be very helpful
12:09:52 <johnw> especially since you get to bind a name to the inner value
12:10:25 <Tendies> i think it could be going down one too many lists deep or one too few, however i can't tell 
12:10:38 <jophish> johnw: I'll keep that in mind, thanks
12:11:21 <Minoru> Hi. Got a question regarding testing best practices. I've got a module that defines a ton of parsers, but only the top one should be exposed to users. Yet still, I want to test all of the little ones separately (because that makes for smaller and simpler test cases). So there's a conflict. From what I gather, I can just create "Internal" namespace for modules (e.g. "Data.Smth.Internal.Parsers") and use tha
12:11:27 <Minoru> t in tests, and hope users are smart enough not to depend on that part of API even though it's exposed. Is that right, or is there a better approach?
12:11:45 <johnw> you can prevent it being exposed in the cabal file
12:11:52 <merijn> jophish: The ability to do "foo env (SomePat n) | Just x <- lookup env n = blah; | otherwise = somethingelse" is nice
12:11:53 <kadoban> Minoru: Sounds right.
12:12:36 <Minoru> johnw: if I do, my testing suite won't be able to find them. My library is the dependency of my test suite, which is an executable defined in that same Cabal file
12:12:39 <jophish> merijn: yeah, I usually let/where and case expression that shit
12:12:41 <Minoru> johnw: but maybe I'm missing something?
12:12:54 <johnw> Minoru: have your test suite directly include the modules, rather than importing your library
12:13:04 <johnw> nothing says the test suite can't be built from the same sources
12:13:09 <jophish> Minoru: ^ That's what I do
12:13:11 <merijn> jophish: That works sometimes, but with complex patterns it can be a hassle
12:13:20 <jophish> yeah, I've noticed
12:13:24 <kadoban> jophish: Hmm, that's an interesting approach. I haven't though of doing that.
12:13:27 <merijn> jophish: i.e. if you want to scope a where clause over both cases
12:13:28 <kadoban> johnw: ^
12:13:41 <merijn> jophish: Where clauses scope over guards (and thus pattern guards), but not over multiple patterns
12:13:42 <jophish> Minoru: People like Internal modules 
12:14:27 <Minoru> jophish: yeah, that's why I thought of them before thiking of simply adding "src" to hs-source-dirs :)
12:15:08 <Tendies> dedgrant: i did decompose it, and based on my understanding of the functions it should work, but i am very new to haskell
12:15:40 <Tendies> well maybe not decompose, but i tried to break up the process and walk though a couple iterations
12:15:57 <dzeban> Hello, everyone. Can you, please, explain what am I doing wrong? ghc fails to compile my code with "parse error on input ‘where’". Can you look at it? http://pastebin.com/qkH1bpEH
12:16:16 <Minoru> okay, so that approach works, but now my program takes twice as long to compile (which is logical :) Any other approaches?
12:16:33 <Minoru> I mean, my library plus my test suite take twice as long
12:16:40 <Minoru> because library is recompiled twice
12:16:41 <johnw> Minoru: put -O0 in your compile flags for the test suite
12:16:44 <Minoru> I wonder why, actually
12:17:07 <monochrom> dzeban: "where" belongs to an equation, not an expression
12:17:10 <kadoban> dzeban: I don't think you can have a where in the middle of an expression like that. Move it down to the end?
12:18:01 <dzeban> monochrom, kadoban: then why it's okay in "else" part?
12:18:24 <monochrom> it is at the end so the computer thinks it belongs to the =
12:18:32 <Minoru> johnw: that sure sped things up, but Stack still compiles all the modules from my library when it builds my test suite
12:18:48 <johnw> yes, that will happen
12:18:50 <kadoban> dzeban: Because it's not on the else, it's on the whole equation there.
12:19:02 <johnw> Minoru: it's either that, or expose your Internal module and hope no one imports it
12:19:17 <monochrom> to test this hypothesis, try to use newRight in the "then" branch. it will work.
12:19:49 <monochrom> showing that "where newRight" is not owned by the "else" branch, but rather something bigger
12:19:59 <Minoru> I see. Thanks, johnw & jophish!
12:20:09 <dzeban> kadoban: ok, got it, thanks a lot!
12:21:06 <dzeban> monochrom: it must be whole function scope
12:22:09 <dzeban> monochrom: like this http://pastebin.com/iz7bz1Fw
12:27:21 <Tendies> alright ill come back later then
12:28:00 <jophish> What's the Soup-du-jour for fixed length vectors?
12:29:23 <dedgrant> Tendies: If you share (pastebin.com) the code for folks to review you may have more success
12:29:24 <hexagoxel> dzeban: you can have "where" on items of let/case as well.
12:30:06 <monochrom> but I don't like to read pastebin.com
12:30:34 <hexagoxel> but it is indeed much more restricted than the "let" construct.
12:30:34 <monochrom> it double-spaces and redacts.
12:30:58 <dzeban> monochrom: what is good then? Maybe gist?
12:31:10 <monochrom> almost everything else is better
12:31:11 <kadoban> gist is okay. lpaste is good, especially for haskell code
12:31:47 <monochrom> if you google for "paste bins" and you ignore pastebin.net, all other hits are good
12:32:11 <kadoban> Well, the ones that require javascript for no reason also annoy me, but yeah there's few worse than pastebin.net
12:32:12 <dedgrant> jophish: I've been doing OK with GHC.TypeLits.Nat and DataKinds. Not super convenient, but type indexing does solve the problem for me.
12:32:35 <monochrom> because almost no one double-spaces or redacts your code
12:32:56 <jophish> dedgrant: that's not really a complete vector package though
12:33:12 <jophish> The vectors in CLaSH are really nice, it's a shame they're not in their own package
12:33:44 <dzeban> Wow, lpaste is really nice. Thanks, I'll use it from now on.
12:34:23 <kadoban> It includes hlint, which is a nice bonus.
12:34:44 <dedgrant> jopshish: Ah I see. Yea I've just been rolling my own as I go. The vectors I deal with are dense, low dimensionality for typical computer graphics work.. linear has been useful for me there.
12:36:22 <dedgrant> jophish: .. rather
12:37:05 <jophish> I'll go with Vector (and a comment) for now
12:37:16 <jophish> Perhaps this'll change when 8.0 hits
12:37:31 <dedgrant> Yea sorry.. I think we have different requirements.
12:37:38 <jophish> no worries :)
12:39:33 <tangled_z> hi! so i have a fresh OS and I thought it had no ghci on it, so i installed stack and then had it install ghci(7.10.3). after which I realized that my earlier install of xmonad through apt-get also installed haskell (7.8.4).
12:39:43 <tangled_z> So now I have two ghcis? What should I do?
12:40:28 <mpickering> what do you want to do?
12:40:46 <mpickering> It's not uncommon to have multiple versions of ghc installed at the same time
12:41:18 <tangled_z> mpickering: if I do have multiple ghcis, wouldnt it be cleaner if both are maintained by stack?
12:41:33 <tangled_z> ie I was thinking of doing apt-get remove ghci and then installing xmonad through stack
12:41:37 <tangled_z> would that make sense?
12:41:45 <geekosaur> you could remove the xmonad package and then... that¸ yes
12:41:46 <geekosaur> but
12:41:54 <mpickering> I don't have any idea of how stack deals with different versions of ghc sorry
12:42:26 <geekosaur> you won;t be able to use mod-q probably, since stack will have installed the xmonad and xmonad-contrib libraries in its sandbox
12:43:04 * geekosaur is still trying to figure out how to properly integrate sandbox support
12:43:15 <tangled_z> mpickering: erm, well it doesnt need to be different versions. those are just the versions that were automatically installed by stack and apt-get respectively
12:43:23 <tangled_z> geekosaur: ah, I see. so you recommend leaving things as-is?
12:43:52 <mpickering> have you had any problems? if not then keeping it as it is should be fine
12:44:06 <tangled_z> no problems so far. it just seemed a bit... messy
12:44:07 <geekosaur> no, just means you need to bind mod-q to something like "stack exec -- xmonad --recompile && xmonad --restart"
12:44:08 <mpickering> just know that if you type ghci you will get the 7.8 version rather than the version stack has
12:44:23 <srhb> geekosaur: I wonder how Nix does it...
12:45:22 <geekosaur> whereas I'm trying to figure out something that doesn't require rebinding, and doesn;t require you to run xmonad *from* the sandbox (which means your whole X11 session is running inside that sandbox, which is a Bad Idea --- it pretty much defeats the point of sandboxes)
12:46:10 <tangled_z> geekosaur: ah right, I see. yeah, running it from the sandbox does not sound good
12:46:36 <tangled_z> Ok, thanks for the advice, guys :)
12:47:18 <geekosaur> the rebinding above just runs the recompile step in the sandbox. some other things won't work right, like xmonad normally checks to see if a config recompile is needed uring startup and there's currently no way to make that run in a sandbox, so it'll probably fail
12:47:43 <darkroom> !testing
12:47:45 <tangled_z> Yeah I think I will keep the apt-get version of haskell for xmonad, then
12:48:06 <srhb> darkroom: pong?
12:48:07 * hackagebot concurrent-machines 0.2.1 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.2.1 (AnthonyCowley)
12:48:52 <darkroom> srhb: ping sorry about that I just installed the emacs package erc for irc comm, i forgot how to do a private message
12:49:00 <srhb> darkroom: :)
12:53:14 <fr3tz0r> http://lpaste.net/5662603677546840064
12:53:24 <fr3tz0r> parse error on if, why?
12:53:48 <dolio> You indented it too far.
12:53:52 <monochrom> you see the misalignment on lpaste?
12:54:58 <monochrom> and possibly other kinds of strange spacing exposed by lpaste, showing that your editor lies.
12:55:14 <Zekka|Sigfig> lpaste knows the TRUTH!!!
12:58:13 <fr3tz0r> so what editor should i use then to get correct indentation. I'm only getting frustrated with indentation it does not help me to read code just the opposite when i do wrong indentation:( thx in advande for sugestions
12:58:34 <fr3tz0r> use emacs currently
12:58:48 <monochrom> I use emacs, but it doesn't lie to me
12:59:10 <monochrom> it displays exactly what lpaste displayes
13:00:03 <monochrom> then again, emacs is Turing-completely-configurable so no two emacs are ever comparable
13:00:13 <fr3tz0r> my emacs don't like haskell...
13:00:33 <monochrom> so I guess my conclusion is "use my emacs"
13:01:03 <fr3tz0r> what do you have and use for emacs then?
13:01:30 <glguy> fr3tz0r: Is the problem that things don't look right or just that you don't know how Haskell code should be indented?
13:01:54 <fr3tz0r> both
13:02:16 <fr3tz0r> it doesn't correct wrong indenations
13:02:34 <monochrom> I think (setq-default indent-tabs-mode nil) goes a long way
13:03:25 <monochrom> and I obtain haskell-mode from melpa, and choose 'haskell-indentation-mode (instead of the other)
13:04:10 <fr3tz0r> i don't know what i got haskell-mode from
13:04:29 <fr3tz0r> i use haskell-indentation-mode
13:04:33 <fr3tz0r> i will try
13:04:35 <fr3tz0r> (setq-default indent-tabs-mode nil)
13:04:50 <monochrom> it still will not correct wrong indentations. not its job to be restrictive. its job is only to let me know the good ones.
13:04:59 <glguy> fr3tz0r: A Haskell mode isn't going to be able to tell you that the indentation is wrong because that wasn't an indentation problem on its own
13:05:11 <glguy> there is valid code where the if could be indented one space in like that
13:05:31 <glguy> You'll have to learn what identation does in Haskell
13:06:02 <fr3tz0r> "like" some sort of ;
13:06:05 <fr3tz0r> ?
13:06:57 <fr3tz0r> will read on haskell indentation then
13:07:10 <fr3tz0r> link suggestions?
13:09:23 <dedgrant> fr3tz0r: I liked this when I was learning: https://en.wikibooks.org/wiki/Haskell/Indentation
13:09:30 <monochrom> I learned Haskell (including layout) from A Gentle Introduction to Haskell. then I happened to read other people's code and picked up some unusual, clever layouts. eventually I read the Haskell Report itself.
13:10:05 <glguy> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7 and https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3 are where they talk about it in the Haskell Report
13:10:22 <glguy> The wikibook is probably a good place to start though
13:10:32 <dedgrant> Yea it also references the Haskell Report
13:10:51 <dedgrant> I just found the examples bang on for the sorts of mistakes I made
13:11:45 <tangled_z> this might be a bit off-topic question so tell me if it is, but it's a maths thing that I encountered this while learning haskell
13:11:57 <tangled_z> what is the connection between functions and relations? 
13:12:29 <monochrom> in math, functions are a special case of relations. in Haskell, there is no relation.
13:13:05 <tangled_z> monochrom: ah, I thought they might be. but you could express a relation as a function as well, couldn't you? 
13:13:10 <mnoonan> ..and relations are a special case of functions, too :)
13:13:18 <tangled_z> ahhhh! that's what I was thinking
13:13:33 <monochrom> yes
13:14:56 <tangled_z> Ok, one more follow up: is there some third thing that subsumes both functions and relations? 
13:15:42 <monochrom> I don't think I've heard of one
13:15:44 <mnoonan> they are both instances of arrows in different categories, I guess
13:16:37 <monochrom> it has always been either "ZF is the foundation, therefore functions are special relations" or "lambda calculus is the foundation, therefore relations are special functions"
13:16:37 <tangled_z> hmm yeah that makes sense! 
13:17:23 <tangled_z> monochrome: ahh thanks for that insight, that makes sense. what about using HoTT as the foundation? 
13:17:39 <monochrom> I haven't learned that yet.
13:17:59 <tangled_z> Im just starting on it myself. very fascinating stuff!
13:18:13 <tangled_z> haskell is like the gateway drug to all sorts of crazy mathematics for me
13:18:19 <monochrom> but if you start with type theory, you probably also start with "the type X->Y exists", i.e., functions are primitive
13:19:11 <tangled_z> that makes sense
13:19:54 <tangled_z> what about a language like Curry? I want to learn that at some point, but I am not sure what it would offer that Haskell doesn't have
13:22:40 <fr3tz0r> monochrom: "I think (setq-default indent-tabs-mode nil) goes a long way" -thx helped 
13:23:24 <kadoban> tangled_z: Curry is pretty obscure. It sounds kind of like haskell - typeclass + some prolog stuff.
13:24:03 <fr3tz0r> dedgrant: "I liked this when I was learning: https://en.wikibooks.org/wiki/Haskell/Indentation" -thx gonna check it out
13:24:20 <shahn> tangled_z: If you know prolog, then Curry might be an interesting experience, as it mixes Haskell and prolog, in a way..
13:24:24 <tangled_z> kadoban: Yeah, maybe Curry was not the best example. I was thinking about "functional logical programming" in general. Maybe Mercury or Haskell with miniKanren
13:25:18 <tangled_z> shahn: I know bits of prolog but haven't used it for anything specific yet! 
13:26:29 <nomeata_> Hi. Is #haskell still the channel where even slightly strange questions are answered friendly and constructively?
13:26:54 <shahn> tangled_z: Me neither, besides for exam questions :-)
13:27:10 <tangled_z> shahn: aha! CS major? :)
13:27:19 <GLM> nomeata_:Depends on the question
13:28:05 <fr3tz0r> http://lpaste.net/5662603677546840064
13:28:12 <fr3tz0r> what does return (c:l)
13:28:14 <fr3tz0r> do
13:28:41 <glguy> fr3tz0r: In this case it's a trivial action that does nothing but return (c:l) when executed
13:28:56 <fr3tz0r> i see what it does but why not return (l)
13:29:00 <geekosaur> (c:l) prepends an item c to a list l; return wraps a value in a monad
13:29:05 <shahn> nomeata_: Is that a slightly weird question? :)
13:29:45 <glguy> fr3tz0r: With only return l, you'd lose the character c that was just read from stdin in the final result
13:29:47 <nomeata_> shahn: Could be. A bit meta at least.
13:30:19 <fr3tz0r> glguy: no i get only "" and dont know why
13:30:21 <mnoonan> fr3tz0r: it looks like they are trying to read a single line by reading the first character, checking if it is a newline, then reading the rest. But if you read the rest, you had better put that first character back on the front.
13:31:30 <geekosaur> that seems like a long-winded way to write inline = getLine
13:31:36 <mnoonan> agreed :|
13:31:41 <glguy> > let c = 'h'; l = "ello" in c:l
13:31:42 <lambdabot>  "hello"
13:31:54 <fr3tz0r> dont't get why return(l) "returns" "" not the inputed line
13:32:12 <glguy> fr3tz0r: because your base case is 'return ""'
13:32:27 <glguy> and with only return l, you're never modifying the return value, so you only get the base case back
13:32:52 <glguy> You get a character c with c <- getChar, and then ignore it
13:35:42 <fr3tz0r> i get a character c but dont get an character l then?
13:35:59 <fr3tz0r> or line for l of course
13:36:17 <glguy> No, while c is a character (Char), l is a list of characters (a String)
13:37:13 <fr3tz0r> i know
13:37:34 <haskell032> fr3tz0r what is the line you're inputting?
13:38:18 <fr3tz0r> put a
13:38:22 <fr3tz0r> get ""
13:38:33 <fr3tz0r> dont know why
13:39:13 <fr3tz0r> for me else can only be something else and not be related to if... That i need to figure out
13:39:29 <geekosaur> do you have another getChar somewhere else in your program?
13:39:42 <fr3tz0r> yes
13:39:42 <geekosaur> and are you running his in ghci, or compiled?
13:40:05 <fr3tz0r> ahh
13:40:07 <geekosaur> (because if it's compild and you getChar elsewhere, it will have needed a newline to complete and then the one in here reads that
13:40:08 <fr3tz0r> ghci
13:40:34 <geekosaur> unless you disable input buffering, which has the side effect of disabling line mode
13:40:47 <geekosaur> ...but ghci normally disables line mode anyway
13:42:09 <jophish> It's a little worrying how many packages aren't building with 8.0.1 at the moment
13:42:25 <fr3tz0r> i compile it with ghc and test
13:43:14 <fr3tz0r> i will always need main when compiling i guess?
13:43:20 <monochrom> yes
13:44:09 <mniip> shachaf, what's the point of Representable
13:44:17 <mniip> if it's isomoprhisms to Star all the way down
13:45:59 <tangled_z> does anyone use the graphviz package? 
13:45:59 <shachaf> mniip: What's the point of Lens when you could just use ALens?
13:47:10 <mniip> :t forceType $ undefined :: ALens s t a b
13:47:11 <lambdabot>     Couldn't match type ‘Force r0’
13:47:11 <lambdabot>                    with ‘(a1 -> Control.Lens.Internal.Context.Pretext (->) a1 b1 b1)
13:47:11 <lambdabot>                          -> s1 -> Control.Lens.Internal.Context.Pretext (->) a1 b1 t1’
13:47:22 <mniip> oh well
13:47:41 <mniip> oh
13:47:45 <mniip> :t forceType (undefined :: ALens s t a b)
13:47:46 <lambdabot> (a -> Control.Lens.Internal.Context.Pretext (->) a b b) -> s -> Control.Lens.Internal.Context.Pretext (->) a b t
13:48:45 <shachaf> Well, never mind that.
13:49:05 <shachaf> ALens s t a b = (a -> Context a b b) -> s -> Context a b t
13:49:10 <shachaf> Where Context a b t = (a, b -> t)
13:50:47 <mniip> Pretext is a cps (a, b -> t) right?
13:51:06 <levi> Isn't that the old data-lens representation of lenses? I rember seeing that recently in an old post.
13:51:09 <mniip> or no
13:51:10 <mniip> t
13:51:21 <shachaf> Pretext a b t = forall f. Functor f => (a -> f b) -> f t
13:51:29 <shachaf> It's the thing you get from a Lens after you apply it to an s.
13:51:44 <mniip> righto
14:02:26 <levi> Ah, (a, a -> b) is the Store Comonad. That's why it looks familiar to me. And data-lens is indeed written in terms of Store.
14:03:18 <shachaf> (a, b -> t) is indexed Store.
14:08:10 * hackagebot erlang 0.2.1 - FFI interface to Erlang.  https://hackage.haskell.org/package/erlang-0.2.1 (gombocarti)
14:12:29 <ril> hi, I'm having some trouble with cabal
14:13:00 <ril> > cabal install split
14:13:01 <ril> < ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
14:13:02 <lambdabot>  Not in scope: ‘cabal’Not in scope: ‘install’
14:15:52 <mauke> so what happened when you ran ghc-pkg init?
14:17:31 <ril> "command-line syntax error"
14:26:26 <bergmark> ril: delete the .inplace file and try again
14:28:17 <ril> I don't see a .inplace file
14:29:11 <ril> I have ~/.cabal/ and ~/split/
14:32:30 <byorgey> ril: what is in ~/split/ ?
14:41:35 <fr3tz0r> "a statement is either an action..." What is considered as an action? I nearly understand do blocks but this i don't know
14:43:15 <glguy> fr3tz0r: An action is a value with the type IO a for any a
14:44:20 <glguy> getLine :: IO String, an action that returns a string.
14:44:24 <fr3tz0r> thx (y)
14:44:31 <fr3tz0r> i get it
14:44:32 <glguy> putStrLn "Hello" :: IO (), an action returning a ()
14:45:09 <KaneTW> come to think of it
14:45:19 <KaneTW> is there a special name for values of type Monad m => m a
14:45:55 <johnw> I'm reading "Functor is to Lens as Applicative is to Biplate", but the parametricity law they give for lenses corresponds to Lens s s a a.  What would be the theorem for Lens s t a b?
14:46:35 <fr3tz0r> glguy is IO () an IO unit
14:46:59 <glguy> Yeah, "unit" is the name for the type ()
14:47:03 <fr3tz0r> what can a ()/(unit) be?
14:47:17 <kadoban> The only value of type () is also (). It has one value.
14:47:19 <kadoban> :t ()
14:47:20 <lambdabot> ()
14:47:28 <glguy> There is a value () and a type (), these are two different things
14:48:30 <dmj> Data.Array should have fromList
14:48:33 <fr3tz0r> how do i se that putStrLn is an IO ()?
14:48:50 <fr3tz0r> because it returns someting?
14:48:50 <kadoban> :t putStrLn
14:48:51 <lambdabot> String -> IO ()
14:48:52 <glguy> fr3tz0r: It's not, it's a function that makes values of type IO ()
14:49:00 <dmj> > listArray (1,3) [1..5]
14:49:01 <lambdabot>  array (1,3) [(1,1),(2,2),(3,3)]
14:49:26 <KaneTW> fr3tz0r: think of () as the same as C's void return type
14:49:31 <glguy> putStrLn is a function, specifically a function from String to IO ()
14:49:36 <KaneTW> it returns, but it always returns the same, irrelevant thing
14:49:52 <fr3tz0r> KaneTW: nice
14:49:54 <glguy> 'putStrLn "Hello"' is an action, the action you got when you applied putStrLn to "Hello"
14:50:42 <KaneTW> in some impure functional languages IO actions have type getLine :: () -> String for example
14:51:02 <glguy> putStrLn doesn't print to the screen on its own, it just makes an action that can print to the screen when executed
14:51:42 <fr3tz0r> glguy: thx that makes more sense
14:51:55 <glguy> which is why you can do stuff like: do let x = putStrLn "Hello"; x; x; x
14:52:00 <glguy> and it prints Hello 3 times
14:55:15 <fr3tz0r> glguy: "An action is a value with the type IO a for any a" value == functions? What else can values be?
14:55:40 <glguy> functions are a subset of values
14:55:41 <kadoban> functions are a subset of values, if that's what you're asking
14:55:45 <glguy> True and () are also values
14:56:43 <fr3tz0r> {types, functions} -> values?
14:57:12 <kadoban> I don't understand the syntax.
14:57:16 <glguy> no, types are not values
14:57:44 <jle`> fr3tz0r: other values are things like numbers, lists, arrays, betc.
14:58:02 <jle`> like True, 10, [7,8,9], "hello"
14:58:18 <jle`> people also call them "data" in other contexts sometimes
14:58:49 <glguy> Examples of types: Bool, (), [Int], Char -> String
15:01:00 <fr3tz0r> what distinguishes the strings "four" from "sure" if I only seen as values 
15:01:18 <fr3tz0r> *if only seen as values
15:02:23 <kadoban> fr3tz0r: Their types are the same. They are different values though.
15:02:39 <kadoban> What distinguishes them is … how they act when you use them, I guess?
15:02:53 <kadoban> > "four" == "sure"
15:02:55 <lambdabot>  False
15:05:11 <jle`> functions map values to values, so if values are different, they might get mapped to differet results
15:05:17 <fr3tz0r> i totally get it :)... sry for stupid question...
15:05:29 <montanonic> Since functions are also values==data, is there a way to talk about "values" in the colloquial sense without including functions in that?
15:05:44 <jle`> > let x = "hello"; y = "hello"; z = "abacus" in (length x, length y)
15:05:46 <lambdabot>  (5,5)
15:06:10 <jle`> montanonic: some people use the word 'non-functions'
15:06:32 <montanonic> hah, well that definitely gets the point across
15:07:09 <Aleksejs> if (a,b) as a tuple, (a,b,c) is a triple, then how to call (a,b,c,d,e)?
15:07:17 <jle`> 5-tuple
15:07:53 <jle`> but i guess if you follow that pattern it'd be a pentaple
15:08:04 <jle`> maybe i should call them pentaples from now on
15:08:07 <montanonic> Aleksejs: some people will actually refer to (a, b) as a 2-tuple
15:08:20 <jle`> or quintples, i suppose
15:08:30 <jle`> but yeah, in real life most people would call them 5-tuples
15:08:45 <Aleksejs> thanks
15:08:55 <kadoban> The fun one is (a, b, c, d, e, f)
15:09:11 <jle`> 6-tuples ? ?
15:09:23 <kadoban> sextuple ;)
15:09:39 <jle`> btw it still trips me up so much that tuple types and their values look so lexically similar
15:10:15 <jle`> er, s/trips me up/freaks me out
15:10:43 <jle`> case x of (a, b) -> (b, a)  :: (a, b) -> (b, a)
15:11:09 <jle`> :t \case (a, b) -> (b, a)
15:11:10 <lambdabot> parse error: naked lambda expression ''
15:11:21 <jle`> i guess there's no lambdacase in lambdabot
15:11:31 <jle`> :t \x -> case x of (a, b) -> (b, a)
15:11:32 <lambdabot> (t1, t) -> (t, t1)
15:11:37 <jle`> :(
15:37:12 <nineonine> Q: how to define a function with 3 args in infix form ?
15:37:44 <mauke> (x `foo` y) z
15:38:21 <nineonine> excellent
15:38:22 <nineonine> thanks
15:38:51 <dmj> :t (1 `foo''` 2) 3
15:38:52 <lambdabot> Num a => a
15:39:00 <jle`> (f . g) x = f (g x)
15:40:24 <mniip> that doesn't work in some compiler I heard
15:42:42 <jle`> :O
15:43:14 * hackagebot hjsonpointer 0.3.0.0 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-0.3.0.0 (seagreen)
15:48:50 <mniip> I remember seeing it in some random file
15:48:51 <mniip> ugh
15:49:00 * mniip dies of vague
15:49:08 <michaelt293> Hello, I am a little stuck on using Stack for testing. I am getting the following "Test suite Element-isotopes-test executable not found for Element-isotopes" which I assume means I am giving the test executable the wrong name in the Cabal file. Any ideas on what it should be called or where I can find this information out?
15:49:19 <silph> This is my first time using this channel and it's been a long time since I used IRC. I was told that this channel welcomes super newbie questions. Is this true?
15:49:29 <mniip> silph, sure thing!
15:49:57 <fr3tz0r> get error main:Main is defined in multiple files sometimes, annoying... 
15:49:57 <silph> mniip, thanks. I have just started reading Real World Haskell and I have my first confusion:
15:50:12 <silph> (also, how can I enter a newline into IRC without it actually sending the line?)
15:50:23 <silph> Real World Haskell says that "" is a synonym for []
15:50:27 <silph> typing
15:50:32 <silph> "" == []
15:50:37 <silph> into gchi returns
15:50:38 <silph> True
15:50:50 <silph> however, this seems not consistent with the following two experiments
15:50:55 <silph> Experiment One:
15:51:02 <silph> 3 : []
15:51:07 <silph> this returns [3]
15:51:09 <mniip> "" is a synonym for ([] :: String)
15:51:12 <silph> Experiment Two:
15:51:13 <kadoban> michaelt293: Is there another error before that? Can you lpaste the output of 'stack test' and the .cabal file?
15:51:16 <silph> 3 : "" is an error
15:51:40 <silph> mniip, i trust that this will make more sense as I continue to read the book :)
15:51:46 <silph> so, [] is not just an empty list
15:52:00 <silph> but one empty list can have a different type than a different empty list?
15:52:01 <Aleksejs> silph: check this
15:52:06 <Aleksejs> > 'a' : ""
15:52:07 <lambdabot>  "a"
15:52:08 <mniip> silph, "" *is* a synonym for [], but has a less liberal type
15:52:40 <mniip> [] is an empty list, thus, an empty list of anything
15:52:46 <mniip> "" is an empty list of characters
15:53:09 <jle`> silph: [] is "polymorphic" so it can be type-inferred/used as an empty list of any type
15:53:14 <michaelt293> Test suite Element-isotopes-test executable not found for Element-isotopes
15:53:15 <michaelt293> Test suite failure for package Element-isotopes-0.1.0.0
15:53:15 <michaelt293>     Element-isotopes-test:  executable not found
15:53:15 <michaelt293> Logs printed to console
15:53:25 <jle`> "" is monomorphic, it can only be used as a [Char]
15:53:29 <mniip> yeah I don't think that's going to be of any use to them :p
15:53:32 <silph> okay! i don't completely understand but i have some intuitions of material i might run into later on in the book. thanks!
15:53:34 <jle`> > 'a' : ""
15:53:35 <lambdabot>  "a"
15:53:58 <jle`> you can think of [] as a polymorphic literal/constructor ... it has type [a], for any possible a you can think of
15:54:02 <mauke> > ['a', 'b', 'c']
15:54:04 <lambdabot>  "abc"
15:54:09 <jle`> it can be [Char], or [Bool], or [Int], etc.
15:54:10 <silph> i also have code from Real World Haskell that is not working, but I'm going to fight with it. I think maybe it's because I'm using a bad text editor.
15:54:19 <jle`> it is usable as an [a] for any a
15:54:24 <jle`> but "" is only usable as a [Char]
15:54:27 <mniip> are you using hard tabs?
15:54:34 <silph> i'm using spaces for now.
15:54:40 <aerialB> silph: what's a bad text editor?
15:54:42 <jle`> some RWH is out of date too, i think
15:54:49 <mniip> silph, mind pastebinning the code
15:54:57 <silph> what does pastebinning mean?
15:55:09 <aerialB> see the topic
15:55:10 <Axman6> > let x :: [a] in (1:x :: [Int],'a':x :: String)
15:55:11 <lambdabot>      The type signature for ‘x’ lacks an accompanying binding
15:55:17 <Axman6> > let x :: [a]; x = [] in (1:x :: [Int],'a':x :: String)
15:55:18 <lambdabot>  ([1],"a")
15:55:26 <aerialB> silph: lpaste.net/new/haskell
15:55:36 <jle`> @where lpaste
15:55:36 <lambdabot> http://lpaste.net/
15:56:10 <silph> it tells me to "enter you code here". but what is the purpose of that website, http://lpaste.net/ ?
15:56:10 <jle`> > 'a' : []
15:56:12 <lambdabot>  "a"
15:56:22 <jle`> silph: paste your code there, and we can read it :D
15:56:36 <silph> ohhh, so that's how i enter in newlines?
15:56:37 <aerialB> silph: It enables you to paste your code, and creates a link to share with us
15:56:41 <mniip> silph, irc is a line-based medium, if you want to paste a large chunk of code you should use one of the plenty pastebin websites available out there
15:56:46 <silph> oh, neat :)
15:57:06 <mniip> then instead of the code you just paste a link
15:57:25 <silph> http://lpaste.net/152845
15:59:20 <mauke> you misspelled Count
15:59:25 <kadoban> michaelt293: Is that all of the output you're planning on giving, or are you working on create an lpaste or something?
15:59:39 <mauke> also that's a line count
16:00:41 <silph> thanks, I did mispell Count. i am literally blindly following the instructions RWH tells me to do.
16:00:46 <michaelt293> kadoban - I wasn't able to paste from my Cabal file for some reason
16:00:53 <silph> i fixed the mispelling of Count, but I get the same error.
16:01:08 <silph> RWH asks me to create a text file called quux.txt
16:01:26 <silph> and then in my Windows command prompt, type in runghc WC < quux.txt
16:01:32 <mauke> hint: if you want help with an error, it helps to tell us what the error actually is
16:01:39 <silph> (the code I pastebined was saved as WC.hs)
16:01:54 <glguy> Does the Windows command prompt use < for redirection from a file?
16:01:59 <mauke> yes
16:02:18 <silph> the error I get from the windows command prompt is WC.hs:1:7: parse error on input '\'
16:02:25 <michaelt293> test-suite Element-isotopes-test
16:02:25 <michaelt293>   type:                exitcode-stdio-1.0
16:02:25 <michaelt293>   hs-source-dirs:      test
16:02:25 <michaelt293>   main-is:             Spec.hs
16:02:25 <michaelt293>   build-depends:       base
16:02:26 <michaelt293>                      , containers
16:02:27 <michaelt293>                      , Element-isotopes
16:02:29 <michaelt293>                      , hspec
16:02:31 --- mode: ChanServ set +o glguy
16:02:31 <michaelt293>   ghc-options:         -threaded -rtsopts -with-rtsopts=-N
16:02:31 --- kick: michaelt293 was kicked by glguy (michaelt293)
16:02:42 <mauke> silph: ok, so what's line 1 of WC.hs?
16:02:56 <silph> it seems to be
16:02:57 <silph> -- WC.hs
16:03:03 <mauke> apparently not
16:03:11 <mauke> because runghc says it contains a \
16:03:12 <mniip> what editor are you usin
16:03:14 <mniip> g
16:03:55 <silph> yeah, that might be the problem. i don't have a proper text editor on my system. i'm using a program called PolyEdit Lite, which was written to write RTF files, although it allows saving as a TXT file
16:04:03 <glguy> michaelt293: You possibly accidentally started pasting your .cabal file to channel. For multiline content please use a pastebin, though
16:04:11 <mniip> oh god
16:04:13 <mauke> silph: ... notepad?
16:04:17 <kadoban> michaelt293: http://lpaste.net/new/haskell
16:04:22 <silph> not .. notepad.
16:04:30 <mauke> yes, notepad
16:04:37 <silph> but a different program i found on the internet called PolyEdit Lite
16:04:40 <mauke> at least that won't save your code as rtf
16:04:43 <mniip> brb writing haskell in microsoft word
16:05:03 <kadoban> michaelt293: The .cabal file and the full output of 'stack test' would be a good place to start. Make sure you paste it to lpaste.net, not directly to the channel.
16:05:21 <silph> um.. so i guess i hvae to find a better editor? but i know i wrote haskell code that worked properly in PolyEdit Lite when going through the first few chapters of Learn You a Haskell, so i'm not sure..
16:05:29 <mniip> silph, mauke is saying you should use notepad instead
16:05:37 <silph> (LYAH got discouraging and boring, so i am switching to RWH)
16:05:45 <silph> oh! okay, maybe i'll try notepad then.
16:06:15 <mauke> not necessarily "should use", but "i don't have a proper text editor on my system" is wrong
16:06:17 <kadoban> silph: https://github.com/bitemyapp/learnhaskell or http://haskellbook.com/ would be my recommendations.
16:06:20 <mniip> well
16:06:34 <mniip> I think mauke would agree that notepad is better than whatever you are using
16:06:39 <mniip> (!)
16:06:47 <kadoban> notepad is … not good. It's hard to imagine it being better than anything.
16:06:52 <Cale> mniip: Run Windows 3.1 in a DOSBox and use Microsoft Write
16:07:01 <mniip> kadoban, exactly why I put a !
16:07:05 <silph> WOW, thanks. copy and pasting it from notepad, then saving the file again solved all the problems
16:07:08 <kadoban> Ah
16:07:15 <silph> thanks! notepad is what i'm going to use now.
16:07:19 <mniip> Cale, edit.com
16:07:21 <mniip> pls
16:08:08 <silph> kadoban, i just saw your recommendations. thanks. i'll check them out.
16:08:08 --- mode: glguy set -o glguy
16:08:28 <silph> my friend just got here. [i was killing time by reading RWh]. thanks for being so friendly and helpful!
16:11:17 <nitrix> :k HasTime
16:11:18 <lambdabot>     Not in scope: type constructor or class ‘HasTime’
16:12:03 <nitrix> :t Control.Wire.Time.time
16:12:04 <lambdabot> Not in scope: ‘Control.Wire.Time.time’
16:12:33 <nitrix> Mhhh, I'll check no my side but I might have a question about wires.
16:21:57 <dedgrant> kadoban: Ironically, notepad does a better job of normalization than Visual Studio (which does no translation on either copy or paste, for instance).
16:22:37 <kadoban> dedgrant: What kind of normalization?
16:22:48 <dedgrant> line ending
16:23:18 <kadoban> Seems like a pretty minor need for an editor to have.
16:24:39 <dedgrant> yes you'd think, until some tool (not naming names, but it might be perforce) interprets 'workspace with unix line endings' as 'I don't need to do any normalization on commit!'. heh
16:27:25 <KaneTW> notepad does a terrible job at it
16:27:26 <KaneTW> it doesn't handle LR period
16:30:23 <dedgrant> LR?
16:33:40 <Aleksejs> is it possible to call a function n times, every time using previous result as argument? Like foo 5 f x = f $ f $ f $ f $ f x
16:34:08 <kadoban> :t iterate -- this should help
16:34:09 <lambdabot> (a -> a) -> a -> [a]
16:35:00 <kadoban> > iterate (+1) 7 !! 5
16:35:01 <lambdabot>  12
16:36:23 <Aleksejs> I gues sit will flood a memory, if n is big enough
16:36:57 <kadoban> I don't see why it would, though it make depend on what 'f' does exactly.
16:37:04 <kadoban> s/make/may/
16:38:25 <glguy> This won't optimize away, you'll build up and index the list: demo n f z = iterate f z !! n
16:38:44 <glguy> Due to list fusion RULES, this won't, though: demo1 n f z = foldr id z (replicate n f)
16:39:02 <kadoban> Ah, hmm right … that's rather annoying.
16:41:05 <glguy> or if you wanted to be strict in the result: demo2 n f z = foldl' (flip id) z (replicate n f)
16:41:23 <glguy> Probably better to just write out the thing directly, though
16:45:55 <Tertain_> Anyone know if in Lucid these is a way to create single value attributes, like async, without typing raw html?
16:50:30 <fr3tz0r> how can i write a function in haskell that returns two different types and i don't want NOTHING to be one of them. 
16:50:46 <shachaf> What is NOTHING?
16:50:58 <shachaf> What does it mean to return two different types?
16:51:16 <KaneTW> > (\x -> (x, True)) 1
16:51:17 <lambdabot>  (1,True)
16:51:25 <KaneTW> :t (\x -> (x, True))
16:51:26 <lambdabot> t -> (t, Bool)
16:51:45 <Tertain_> figured out my previous question. You can use a TermRaw as an attribute
16:52:09 <glguy> shachaf: I'm listening to a song at the moment, and it turns out that NOTHING really matters
16:55:31 <fr3tz0r> say i want either a 1 or True not (1,True)
16:55:51 <glguy> Then the return type will be: Either Int True, or similar
16:56:45 <fr3tz0r> so there exist a type Either?
16:57:18 <fr3tz0r> some nice links on Either?
16:58:09 <pavonia> Either isn't really a type but somthing the constructs a type if two type parameters are given to it
16:58:42 <glguy> Technically Either is itself a type
16:58:44 <glguy> http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Either
16:59:16 <hpc> the terminology is all over the place
16:59:17 <KaneTW> strictly speaking, types are in *
16:59:24 <hpc> suffice it to say Either is not of kind *
17:00:14 <EvanR> types have type *
17:00:19 <EvanR> but wait, DataKinds
17:00:42 <glguy> No, types have kinds
17:00:50 <EvanR> same thing ;)
17:00:50 <glguy> Either has a kind, Int has one, both Either and Int are types
17:00:52 <hpc> things have other things
17:01:08 <hpc> glguy: one can argue types have values
17:01:14 <EvanR> if were gonna have inconsistent jargon might as well make it all be the same!
17:01:24 <glguy> hpc: yeah, types with kind * can have values
17:01:36 <michaelt293> I want to write tests for a small library I wrote. I am using stack, however, when I use "stack test", I get "Test suite Element-isotopes-test executable not found for Element-isotopes." I will use lpaste to show my .cabal and Spec files as well as the error message from "stack test" now. (PS. sorry, I had something I had to attend to earlier).
17:01:38 <hpc> Either can't have a value so it's not a type ;)
17:01:45 <hpc> see also, 19:58 < hpc> the terminology is all over the place
17:01:47 <glguy> yeah, that's not how it works :-p
17:01:49 <lpaste> michaelt293 pasted “.cabal file” at http://lpaste.net/152846
17:02:03 <lpaste> michaelt293 pasted “Spec file” at http://lpaste.net/152847
17:02:21 <EvanR> Either is not a type, or a value, or anything. It's a functor from Hask x Hask to Hask
17:02:31 <lpaste> michaelt293 pasted “stack build and stack test” at http://lpaste.net/152848
17:02:38 <harrisi> I'm interested in learning more about the current type/kind/Either discussion
17:03:27 <glguy> EvanR: It's useful that Maybe it a type on its own. We can make typeclass instances for it, for example
17:03:58 <EvanR> constraint constructors take more than just *'s
17:04:06 <glguy> "type variables" don't have to be things that ahve kind *
17:04:13 <EvanR> so constraint constructors arent in Hask
17:04:59 <EvanR> all ->'s are arrows in some sufficiently ridiculous category
17:05:28 <fr3tz0r> i want to do if something then function1 else function2, how can i do this is haskell? 
17:05:38 <KaneTW> literally that
17:05:50 <KaneTW> > if True then "foo" else "bar"
17:05:52 <lambdabot>  "foo"
17:06:00 <dmj> :t \something function1 function2 -> if something then function2 else function2
17:06:01 <lambdabot> Bool -> r -> r1 -> r1
17:06:10 <dmj> :t \something function1 function2 -> if something then function1 else function2
17:06:12 <lambdabot> Bool -> r -> r -> r
17:06:46 <KaneTW> :t \b (f1 :: a -> b) f2 -> if b then f1 else f2
17:06:47 <lambdabot> Bool -> (a -> b) -> (a -> b) -> a -> b
17:07:14 <Tendies> anyone like combinatorics
17:07:58 <glguy> EvanR: That's probably angle to look at things, but it won't help someone looking through the Haskell Report understanding Haskell code
17:08:06 <glguy> probably a fun angle^
17:10:00 <fr3tz0r> I can take function1 and function2 as arguments for function3 and then function3 can return function1 or function2 even if function1 and function2 returns different types?
17:11:25 <johnw> fr3tz0r: best thing to do is to try what you're thinking
17:12:16 <mniip> 1455930226 [04:03:46] <fr3tz0r> i want to do if something then function1 else function2, how can i do this is haskell? 
17:12:18 <mniip> :t bool
17:12:19 <lambdabot> a -> a -> Bool -> a
17:13:33 <pavonia> "if something then function1 else function2" would actually even be correct syntax
17:14:08 <glguy> If the types of function1 and function2 don't match you can do:
17:14:18 <glguy> if something then Left function1 else Right function2
17:15:02 <Tendies> can someone more literate at list comprehensions than me help me figure out whats going on in http://lpaste.net/152849 ? it generates the partitions of a set, however the third list comp adds more than just the [[a,c],[b]] partition, and filtering out those extras has proved futile
17:15:26 <Tendies> well, not what's going on, but how to narrow down what the third list comp generates
17:16:03 <Tendies> uh oops
17:16:44 <Tendies> ok fixed paste
17:18:49 <mniip> Tendies, you probably have to review your algorithms
17:20:06 <mniip> I'm not sure what your algorithm is, and it's not very apparent what your code does,
17:20:18 <mniip> but to me the "obvious" solution is,
17:21:00 <mniip> @let part [] = []; part (x:xs) = [x] : map (x:) (part xs)
17:21:01 <lambdabot>  Defined.
17:21:08 <mniip> > part "asdf"
17:21:09 <lambdabot>  ["a","as","asd","asdf"]
17:21:12 <mniip> er
17:21:26 <mniip> oops
17:21:47 <mniip> forget that
17:23:08 <mniip> ok this isn't as obvious as it seems,
17:23:46 <mniip> but basically, if you get a possible partition P, you want to try to prepend your element into each in P,
17:23:51 <mniip> and then try adding a singleton into P
17:24:10 <mniip> the first part of that is pretty tricky yes
17:25:51 <dedgrant> Tendies: Is the exercise to generate all possible partitions of the input?
17:30:36 <montanonic> Tendies: The input is a Set, I presume. What's the output of the function supposed to be?
17:32:53 <Tendies> dedgrant: sorry, yes that's the goal
17:34:51 <dedgrant> Tendies: OK, what montanonic suggested is one good place to start. What is the type of partitionSet going to be?
17:35:15 <Tendies> [[[t]]]
17:35:50 <montanonic> So, a list of lists of lists? That leaves a lot up in the air
17:35:51 <dedgrant> Yea that's the return type (the critical part).. so partitionSet :: [a] -> [[[a]]]
17:36:21 <Tendies> well i'm using type Set a = [a]
17:36:48 <Tendies> and type definition is Eq t => Set t -> Set( Set( Set t))
17:37:19 <Tendies> the function generates all of the unique partitions, its just it generates a couple more that are duplicates
17:37:37 <montanonic> Tendies: so like a sliding window on a list, kind of
17:37:41 <Tendies> and filtering a triple nested list is a pain
17:37:58 <Tendies> yeah montanonic 
17:38:08 <montanonic> partition [1,2,3] = [[1,2,3], [1,2], [2,3], [1], [2], [3]]
17:38:11 <montanonic> ^ ?
17:38:24 <dedgrant> Tendies: Well I already see a problem with the base case. Concrete math + inductive reasoning should help build up the definition.  What is the result of 'partitionSet []'?
17:38:30 <Tendies> yes but one more list deep
17:38:38 <montanonic> Tendies: what would that look like?
17:38:45 <Tendies> i dont know that the base case even gets hit
17:38:57 <dedgrant> montanonic: partition [1..3] = [ [[1,2,3]], [[1],[2,3]], ... ]
17:39:27 <dedgrant> Tendies: Regardless, it's wrong, and the recursion will require it to be correct
17:39:37 <Tendies> [1,2,3] becomes [[[1,2,3]],[[1,2],[3]]...]
17:39:38 <montanonic> [[1,2],[3]] <-- would that be the next logical one, dedgrant?
17:39:49 <montanonic> okay, cool
17:39:57 <montanonic> interesting, I haven't seen that before
17:40:03 <kadoban> p [1,2,3] = [[[1,2,3]], [[1,2], [3]], [[1], [2, 3]], [[1], [2], [3]]]   Is that correct?  There's no [[1,3], [2]], right?
17:40:23 <montanonic> yeah I'd assume [[1,3],[2]] isn't allowed
17:40:24 <dedgrant> montanonic: Yea, though the order of generation may vary depending on how th recursion is defined.
17:40:28 <Tendies> how do i load from an lpaste
17:40:30 <montanonic> indeed
17:40:51 <Tendies> @letlpaste 152849
17:40:53 <lambdabot>  Defined.
17:40:59 <kadoban> Note that these aren't sets, by the way. Sets don't have order.
17:41:09 <montanonic> oh woah, I didn't know you could do that with lpaste
17:41:12 <montanonic> that's really cool
17:41:12 <Tendies> kadoban, there is no order here
17:41:16 <montanonic> (and lambdabot)
17:41:17 <fiddlerwoaroof> Using stack, how do I build a program against a locally modified version of a file?
17:41:29 <kadoban> Tendies: See my question above. Am I correct there?
17:41:55 <fiddlerwoaroof> s/file/library/
17:41:58 <Tendies> kadoban: yes, that last one was the problem
17:42:07 <kadoban> Tendies: Then you have order.
17:42:25 <kadoban> [[1,3], [2]] being excluded means that order is important.
17:42:44 <Tendies> [1,3],[2] wasnt supposed to be excluded i mean, it was the one i didnt know how to generate
17:42:54 <Tendies> without adding a bunch of duplicates of other partitions
17:43:10 <Tendies> partitionSet [1,2]
17:43:14 <Tendies> > partitionSet [1,2]
17:43:15 <kadoban> Okay, so they are sets then I guess.
17:43:15 <lambdabot>  [[[1],[2]],[[1,2]],[[2],[1]]]
17:43:54 <Tendies> i cant get lambda to put the whole output on a 3 set
17:44:03 <mgsloan> fiddlerwoaroof: Put your modified version in a subdirectory, and add that dir to the "packages" list in your stack.yaml
17:44:10 <Tendies> but you see it has one more than the 2nd bell number of partitions
17:44:58 <fiddlerwoaroof> mgsloan: thanks, let's see if I can get this to work.
17:45:44 <mniip> @let part [] = [[]]; part (x:xs) = concatMap (\rs -> ([x]:rs):(map (\i -> take i rs ++ (x:rs !! i):drop (i + 1) rs) $ zipWith const [0..] rs)) $ part xs
17:45:45 <lambdabot>  Defined.
17:45:48 <mniip> yuck
17:45:57 <mniip> > part "asdf"
17:45:58 <lambdabot>  [["a","s","d","f"],["as","d","f"],["s","ad","f"],["s","d","af"],["a","sd","f...
17:46:10 <Aleksejs> if i define functions in tuple, like (foo, bar) = (f a, f b) where f x y = something x y, how do I declare types of these functions?
17:46:19 <Tendies> thats gonna be 15 partitions, may want to use smaller test case mniip 
17:46:23 <fiddlerwoaroof> @mgsloan: thanks, it worked.
17:46:23 <lambdabot> Unknown command, try @list
17:46:28 <jle`> Aleksejs: you can put the type signature of f in the where block
17:46:29 <mniip> > part "asd"
17:46:31 <lambdabot>  [["a","s","d"],["as","d"],["s","ad"],["a","sd"],["asd"]]
17:46:31 <jle`>   where
17:46:35 <jle`>     f :: blah -> blah
17:46:39 <jle`>     f x y = ..
17:46:40 <Tendies> wow you got it
17:46:44 <mgsloan> fiddlerwoaroof: Welcome!
17:46:47 <mniip> yeah but
17:46:49 <jle`> but i wouldn't call it a "function in a tuple"
17:46:53 <mniip> this list diagonalization
17:46:56 <Aleksejs> jle`: but how about foo and bar?
17:47:03 <jle`> ah, those aren't functions
17:47:22 <jle`> you can put foo and bar type annotations anywhere where you would normally put type annotations for things you declar
17:47:27 <jle`> foo :: blah, bar :: blah
17:47:33 <jle`> (on separate lines)
17:47:39 <Tendies> as for the logic of how i wrote mine, i did one list comprehension for each distinct form of partition 
17:47:40 <Aleksejs> yeah, I tried, it fails
17:47:49 <jle`> can you paste what you tried?
17:48:00 <jle`> you'd put the type annotation for foo the same place you'd put it if you did foo = ...
17:48:09 <jle`> foo :: Int; foo = ...
17:48:17 <jle`> foo :: Int; (foo, _) = ...
17:52:39 <Tendies> montanonic: as for the recursion, the reasoning is that there is only one way to partition an empty list
17:52:42 <mniip> Tendies, here's a less ugly-foo solution
17:52:46 <mniip> @undefine
17:52:46 <lambdabot> Undefined.
17:52:48 <mniip> @let part [] = [[]]; part (x:xs) = part xs >>= go x where go x [] = [[[x]]]; go x (rs:rss) = ((x:rs):rss):(map (rs:) $ go x rss)
17:52:49 <lambdabot>  Defined.
17:52:57 <mniip> > part "abc"
17:52:58 <lambdabot>  [["abc"],["bc","a"],["ac","b"],["c","ab"],["c","b","a"]]
17:53:20 <Tendies> so my base case was good at least
17:54:14 <Tendies> mniip: what is >>=?
17:54:19 <mniip> monadic bind
17:54:28 <Tendies> i
17:54:49 <Tendies> i really appreciate the help but i havent learned what monads are yet
17:55:03 <mniip> well,
17:55:10 <mauke> in that case, concatMap
17:55:10 <mniip> you can think of it as of 'flip concatMap'
17:55:14 <mniip> in this particular case
17:55:52 <montanonic> Tendies: a list comprehension is using (>>=) everytime you write (<-). But yeah, don't worry about it.
17:56:05 <mniip> yeah, just write
17:56:32 <mniip> [a | rss <- part xs; a <- go x rss]
17:56:39 <mniip> (?)
17:56:57 <mniip> it's been ages since I've written a list comprehension >.>
17:57:45 <kadoban> Thankfully they're pretty easy to mechanically transform from/into do notation.
17:59:05 <Tendies> there appear to be some similarities between yours and mine as far as ((x:rs):rss
17:59:06 <dedgrant> Tendies: So you really mean 'part [] = [[]]', ie. you want empty sets in the partition?
17:59:29 <Tendies> that case shouldnt actually get met afaik
18:01:05 <dedgrant> Tendies: Sure, but there seems to be some dissonance. What does it mean to permit empty sets in the partition?  Why not 'part [] = []' instead?  The result needs to come back to the base case somehow.
18:01:19 <mniip> dedgrant, part [] is a single partition of no sets
18:01:25 <mniip> i.e [[]]
18:01:47 <mniip> [] is no partitions
18:01:53 <mniip> [[]] is one partition with no sets
18:01:58 <Tendies> dedgrant: i think that is due to the obfuscated way in which i have to represent the sets
18:01:58 <mniip> [[[]]] is one partition with one empty set
18:02:20 <mniip> get your functors sorted :)
18:02:33 <dedgrant> mniip: heheh I see.. 
18:04:08 <Tendies> so for my attempted implementation, was it just not feasable (sp?) ?
18:06:22 <Tendies> mniip: the list comp replaced line 5 after the equals, correct?
18:06:38 <Tendies> it gave me a stack overflow lol
18:08:18 <Tendies> oh i put it in wrong place
18:12:30 <Tendies> do you know how long i worked on that function mniip
18:12:54 <dedgrant> mniip: Tx for the clarification. I see where I went wrong.
18:15:32 <montanonic> Tendies: hey, I have a potential answer
18:15:42 <Tendies> it was 3 hours for the list generation and another 7 trying to filter the too many partitions down to only the unique ones
18:15:57 <montanonic> what's the output for [1,2,3,4] supposed to be?
18:16:09 <Tendies> uh
18:16:12 <Tendies> its 15 partitions
18:16:24 <montanonic> Tendies: http://lpaste.net/152853 ?
18:16:45 <montanonic> I think I have too much redundancy
18:16:53 <montanonic> But I wonder if it resembles the answer
18:17:20 <montanonic> oh, sorry
18:17:23 <montanonic> that's one level too deep
18:17:44 <Tendies> it would be more like [[[1,2,3,4]],[[1,2],[3,4]],[[1,2,3],[4]] ... ]
18:18:25 <Tendies> where each partition's union is the whole partition, i.e. [1,2,3,4]
18:18:58 <montanonic> Tendies: http://lpaste.net/152853
18:19:07 <montanonic> Tendies: try that code, tell me where it's off
18:19:21 <Tendies> is that for the output you pasted?
18:19:40 <montanonic> Tendies: no it's different
18:19:44 <montanonic> I added a join
18:19:54 <Tendies> @unload
18:19:54 <lambdabot> Unknown command, try @list
18:20:13 <Tendies> @undefine
18:20:13 <lambdabot> Undefined.
18:20:23 <montanonic> oh wait
18:20:26 <montanonic> sorry hold on
18:20:29 <montanonic> I need to fix 1 thing
18:24:18 <montanonic> err... more than one thing. darn
18:33:11 <YellowOnion> could anyone tell me what I'm doing wrong with typeclasses https://gist.github.com/6732e40eb68efdcc8ce5
18:35:16 <jle`> YellowOnion: you need to say what Action instance you want on line 114
18:35:31 <jle`> and `doit :: Action a` is probably not what you want
18:35:57 <dedgrant> Generating only binary partitions is interesting on its own.. heh
18:36:11 <jle`> it looks like getAmmo returns an Orientation, so doit :: Orientation ?
18:36:38 <YellowOnion> its meant to return an Orientation or an Action, which is the entire point of that type class.
18:37:13 <YellowOnion> sorry I mean an Actions
18:38:01 <pavonia> Maybe you should post more code
18:38:22 <YellowOnion> jle`, note my type signature (which is commented out) for getAction is what I want.
18:39:19 <pavonia> Oh, I didn't see the Main.hs, sorry
18:43:41 <YellowOnion> maybe there's a better way to abstract/serialize this?
18:47:19 <pavonia> YellowOnion: Why not just return Either Actions Orientation?
18:48:04 <pavonia> Or JSString directly, as this is the only useful result you can get for that class
18:48:42 <Pamelloes> Anyone know any good tutorials on using Data.Graph?
18:50:07 <YellowOnion> pavonia, I guess I could do the second option, but I would like to know what I'm doing wrong with type classes, as its kind of a useful thing to know.
18:52:24 <pavonia> "doit :: Action a" is wrong, for instance
18:53:13 <pavonia> "Action a => a" would be a legal type signature, but then the defintion is wrong because it returns an Orientation, not any Action
18:53:41 <YellowOnion> Orientation is an Action?
18:54:08 <pavonia> Yes, but note that the caller of getAction decides what Action a is choosen, not your function
18:54:31 <pavonia> You can't return this type in one case and that in another
18:54:54 <pavonia>  You have to prepared for all possible Actions the caller might chosse, so to say
18:55:27 <dedgrant> Tendies: Any luck finding a suitable recursion to reduce the number of duplicates?
18:57:58 <Tendies> dedgrant: i basically gave up on filtering it
18:58:26 <dedgrant> Tendies: Yea that's a really neat problem
18:59:01 <Tendies> the filter was either not going deep enough or going too deep and was removing parts of partitions instead of whole partitions
18:59:17 <Tendies> after 7 hours of trying to set up the filter lol
18:59:24 <Tendies> yeah very challenging
18:59:44 <montanonic> Tendies: GOT IT
18:59:47 <dedgrant> Haha.. well you can certainly generate more than you need with permutations
18:59:53 <dedgrant> !
19:00:15 <montanonic> http://lpaste.net/152853
19:00:46 <Tendies> wow that changed a lot
19:00:50 <montanonic> ^ just edited, refresh
19:00:51 <kadoban> I think the problem gets much easier if you write a helper: "give me every way to partition set S into two subsets". It seems pretty simple to write in terms of that.
19:01:02 <Tendies> @letlpaste 152853
19:01:03 <lambdabot>  Defined.
19:01:14 <Tendies> partition [1,2,3]
19:01:28 <Tendies> oh
19:01:29 <Tendies> lol
19:01:30 <montanonic> > partition [1,2,3,4]
19:01:31 <lambdabot>      Ambiguous occurrence ‘partition’
19:01:31 <lambdabot>      It could refer to either ‘L.partition’,
19:01:31 <lambdabot>                               defined at /tmp/mueval1244316437971899228.hs:148:1
19:01:40 <montanonic> i'll rename it
19:01:41 <Tendies> @undefine
19:01:42 <lambdabot> Undefined.
19:01:51 <montanonic> okay
19:01:52 <Tendies> oh right name conflict
19:01:53 <montanonic> ready
19:02:02 <Tendies> @letlpaste 152853
19:02:03 <lambdabot>  Defined.
19:02:10 <montanonic> > partition [1,2,3,4]
19:02:11 <lambdabot>      Couldn't match expected type ‘a -> Bool’
19:02:11 <lambdabot>                  with actual type ‘[Integer]’
19:02:11 <lambdabot>      In the first argument of ‘partition’, namely ‘[1, 2, 3, 4]’
19:02:16 <Tendies> > partition' [1,2,3]
19:02:17 <montanonic> > partition' [1,2,3,4]
19:02:18 <lambdabot>  [[[1,2,3]],[[1,2],[2,3]],[[1],[2],[3]]]
19:02:18 <lambdabot>  [[[1,2,3,4]],[[1,2,3],[2,3,4]],[[1,2],[2,3],[3,4]],[[1],[2],[3],[4]]]
19:02:32 <YellowOnion> pavonia, ahh right, its strange that its an instance error I'm getting and not a "function can only return one type" kind of error.
19:02:41 <Tendies> hm whats going on there
19:02:46 <dedgrant> montanonic, n is a pivot?
19:02:55 <montanonic> Tendies: sorry I collided with yours
19:02:58 <montanonic> > partition [1,2,3,4]
19:02:59 <lambdabot>      Couldn't match expected type ‘a -> Bool’
19:03:00 <lambdabot>                  with actual type ‘[Integer]’
19:03:00 <lambdabot>      In the first argument of ‘partition’, namely ‘[1, 2, 3, 4]’
19:03:03 <montanonic> > partition' [1,2,3,4]
19:03:04 <lambdabot>  [[[1,2,3,4]],[[1,2,3],[2,3,4]],[[1,2],[2,3],[3,4]],[[1],[2],[3],[4]]]
19:03:31 <montanonic> dedgrant: I'll elaborate once I know this is what Tendies is looking for
19:03:38 <montanonic> I want to make sure it's correct
19:03:53 <dedgrant> no problem :)
19:04:26 <Tendies> well you see, the union of the second partition is more than just the original set
19:04:34 <montanonic> Tendies: oooooh, darn
19:04:36 <montanonic> I see what you mean
19:04:55 <montanonic> so my earlier implementation is closer
19:04:58 <montanonic> my mistake
19:04:58 <Tendies> "the partition of a set s is defined as a set of nonempty, pairwise disjoin subsets of S whose union is S
19:05:02 <montanonic> indeed
19:05:13 <Tendies> if that means more to you, certainly didnt to me :P
19:05:29 <montanonic> I can see what it means in this context
19:05:42 <montanonic> alright, well all that means is I don't iterate the way I did
19:05:48 <montanonic> okay, back to try again
19:05:57 <dedgrant> it's also missing some partitions, such as [[1,3,4],[2]] for example, no?
19:06:25 <montanonic> dedgrant: yes you're right, I made the mistake of thinking that I had to divide up all possible partitions of size
19:06:33 <montanonic> instead of all possible partitions of values
19:06:39 <dedgrant> got it
19:07:35 <dedgrant> I don't think there's much getting away from having an efficient unordered set to perform fast rejection.
19:07:50 <Cale> You shouldn't need equality testing for this
19:08:02 <dedgrant> oh?
19:10:20 <Tendies> and the equality that is important here is one that counts, say [[1,2,3]] as equal to [[2,3,1]]
19:10:38 <Tendies> although unless you want to try to generate too many and filter down, its not exactly needed
19:10:46 <Cale> Well, you should probably strive to keep the elements of each part in the same order as they occurred in the original list
19:11:32 <Tendies>  for me it was the [[a,c],[b]] that prevents order remaining
19:16:07 <mjrosenb> /home/media/use/MediaGui/.cabal-sandbox/x86_64-linux-ghc-7.8.4-packages.conf.d/package.cache:
19:16:10 <mjrosenb> GHC.PackageDb.readPackageDb: inappropriate type (not a ghc-pkg db file, wrong
19:16:26 <mjrosenb> anyone know how to fix that?
19:16:27 <Cale> Think about the ways that you can form a partition of (x:xs) -- either x occurs in a part by itself, and the remainder of the partition is a partition of xs
19:16:47 <Cale> or the partition can be obtained by adding x to one of the parts of a partition of xs
19:17:04 <Cale> This leads to an easy way to write the thing recursively
19:17:13 <dedgrant> Nice
19:17:31 <Tendies> minus the x:y:ys where x is on something ys
19:17:41 <Cale> hm?
19:18:04 <Tendies> like the [[1,3],[2]]
19:18:27 <Tendies> or at least, i started with the same reasoning you laid out and it ended up being one short
19:19:10 <Cale> That partition is obtained by taking the partition of [2,3] which is [[2],[3]], and adding 1 to its second part to obtain [[2],[1,3]]
19:19:40 <Cale> in turn, [[2],[3]] comes from adding 2 in a part by itself to the partition [[3]] of the list [3]
19:19:59 <Cale> which comes from adding 3 in a part by itself to the partition [] of the empty list
19:21:40 <lpaste> Cale pasted “a solution” at http://lpaste.net/152858
19:22:33 <Tendies> does it stalk you Cale 
19:22:40 <Cale> ?
19:22:46 <Tendies> how did it know
19:23:05 <Cale> It's the same program which is running lpaste.net's web server
19:23:42 <Cale> It also connects to this IRC channel, and posts about it when people make new pastes and set the channel to #haskell
19:24:13 <Tendies> oh thats what that dropdown does
19:24:56 <Smoke_Max> What's the recommended copy paste site to share code?
19:25:23 <hppavilion[2]> Smoke_Max: Your own.
19:25:23 <Cale> lpaste.net
19:25:39 <dedgrant> That's a tricky recursion
19:25:42 <hppavilion[2]> Yes, yes, Cale's works too, but your own looks cooler.
19:26:40 <Cale> dedgrant: The way to think about it is to imagine that someone already did partitions xs for you, and to figure out what you'd have to do to it in order to obtain the solution for partitions (x:xs)
19:27:33 <Smoke_Max_> Ok, so I have a QuickCheck question. How would I go about creating Arbitrary / CoArbitrary instances for this code? http://lpaste.net/3877081954650161152
19:28:36 <sbrg> is there a way to specify which instances should be chosen in case of overlapping instances?
19:29:22 <dedgrant> Cale: Ahh ok got it
19:30:01 <dedgrant> I still let many similar looking functor applications confuse me.
19:30:12 <Cale> Smoke_Max_: arbitrary = oneof [return Start, return Retransmit, return Stop, return Fail, fmap Other arbitrary]
19:31:23 <montanonic> that's a nice solution Cale 
19:31:41 <Cale> Smoke_Max_: coarbitrary Start = variant 0; coarbitrary Retransmit = variant 1; coarbitrary Stop = variant 2; coarbitrary Fail = variant 3; coarbitrary (Other x) = variant 4 . coarbitrary x
19:32:21 <DogCat> Are there any frameworks for describing API endpoints for Scotty?
19:33:03 <DogCat> I'm building a DSL for data visualization, and as we expland the number returned types, we are about to accept a shit ton of technical debt if we continue as we are
19:33:34 <Smoke_Max_> Cale: Nice, that worked perfectly. Thanks. :)
19:33:54 <DogCat> we have about 5 or 6 output types that result in plots, each defined with via an interface object, and a Aeson.toJson methods
19:34:21 <dmj> DogCat: what's an interface object
19:34:30 <Cale> Smoke_Max_: Note that for the arbitrary instance, if you want to weight the probability of obtaining each constructor, you can do so using the frequency function.
19:34:40 <DogCat> financial time series
19:34:52 <DogCat> with one or multiple stocks
19:34:53 <Cale> Smoke_Max_: it's like oneof, except each generator is paired with an Int
19:35:04 <dmj> DogCat: how would adding types lead to technical debt
19:35:45 <DogCat> The front end will manage them in an ad-hoc way, and not understand out backend organization
19:36:11 <DogCat> and we need the front end to build the data visualization
19:36:38 <DogCat> and make it look consistent 
19:37:51 <DogCat> The best value added to our company spend the time know setting up constaints, and work later exploring new visualizations/data formats that best serve our customers
19:39:14 <DogCat> dmj: does that make sense?
19:41:22 <dmj> DogCat: kind of
19:41:48 <DogCat> yea, basically we take our DSL into on end point, and give back like 15 different JSON objects
19:42:06 <DogCat> it works now, but we need a better system to get where we are going
19:42:24 <dmj> DogCat: what's wrong with the current system
19:42:56 <DogCat> communication: we at least need a centrailzed location for JSON return types 
19:43:38 <dmj> DogCat: what does 'centralized location' mean? Same module? Same package? Same type?
19:44:27 <DogCat> Right now, we have an interface type where each constructor yeilds an object with a unique json tag and representation
19:45:16 <dmj> DogCat: what is an interface type
19:45:46 <Smoke_Max_> Cale: Thanks. This is just a small project that I'm using as a chance to learn QuickCheck, so I'm just trying to understand the basics. Getting that instance to work was good enough for me, but thanks for the heads up. :)
19:46:06 <DogCat> post dsl to an API endpoint, we take that, grad the data, do the transformation, then give back one of many different plot types
19:46:59 <DogCat> but that universe of return types has been shifting, and the front end code guys haven't really been able to leverage abstraction
19:47:09 <DogCat> btw, they are using Angular and HighCharts
19:48:06 <DogCat> I'm looking into solutions like this: https://github.com/mstksg/auto
19:50:45 <prooftechnique> I'm really looking forward to seeing what comes out of auto in the next year
19:51:07 <dmj> DogCat: that package looks excellent, good choice
19:51:18 <DogCat> thanks!
19:51:52 <orion> What functions/modules/packages should I look at if I want to perform atomic increments on Int64s?
19:52:10 <DogCat> such an amazing production langugae, sometimes I feel like we are a 20 years ahead of the rest of the software engineering community
19:52:30 <DogCat> now all we have to do is bring it to the masses
19:52:55 <Tendies> has to be translated to feminist javascript for them to touch it unfortunately
19:54:20 <DogCat> I don't know
19:54:41 <DogCat> it may require a simpler language that the Haskell we all know and love
19:55:59 <DogCat> This idea of making haskell a platform for exploratory data analysis that can easily go into production would save companies millions
20:05:23 <EvanR> DogCat: haskells type system doesnt really let you go ahead without knowing what youre trying to do, i think
20:05:52 <DogCat> yea, it's a really good start though
20:05:55 <EvanR> a huge jumble of basically CSV files is just that in haskell until you decide otherwise
20:06:36 <DogCat> the least viable solution to this is just make a csv file of output type, description, JSON format
20:08:22 <DogCat> it's a startup, so you can always get the gohead to make something great. You just need initiative and trust
20:11:13 <DogCat> EvanR: thanks for your help, It's really encouraging to have someone on here as much as you answering questions
20:12:45 <nineonine> Parsec question here : how to parse all integers from the stream ?
20:13:17 <nineonine> lets say we already have parser for numbers
20:14:01 <DogCat> so number =/= integer
20:14:02 <dmj> anyone work with unboxed mutable vectors in ST ?
20:14:18 <nineonine> numbers are interspersed with random char noise 
20:14:29 <nineonine> yeah, numbers
20:15:00 <sm> are there non-integer numbers you have to ignore ?
20:15:23 <nineonine> no
20:16:30 <nineonine> parse (many1 integer) "Test" ("-12  fas 1 fas 4 a 4 6" :: String)
20:16:32 <sm> many (many (satisfy (not . isDigit)) >> read <$> many (satisfy isDigit)) ?
20:16:34 <nineonine> gives me only -12
20:16:49 <nineonine> i want to get a list of all of them
20:18:26 <kadoban> nineonine: Are there any '-' that aren't right before a number that you want to parse?
20:18:56 <nineonine> no
20:19:03 <nineonine> only before digits
20:22:10 <kadoban> sepEndBy (do {pre <- (char '-') <|> pure ""; num <- many1 digit; return $ pre ++ num}) (many1 (satisfy $ (\x -> not (isDigit x || x == '-'))) come to mind. Haven't tested it
20:22:59 <nineonine> we can assume that we already have a combinator that successfully parses positive and negative values
20:23:07 <nineonine> integer = rd <$> (minus <|> number)
20:23:07 <nineonine>     where rd     = read :: String -> Integer
20:23:08 <nineonine>           minus  = (:) <$> char '-' <*> number
20:23:09 <nineonine>           number = many1 digit
20:23:19 <kadoban> nineonine: Ah, then throw that in instead of the first 'do' block there.
20:25:35 <sm> > parse (many (many (satisfy (not . isDigit)) >> read <$> many1 (satisfy isDigit))) "" "-12  fas 1 fas 4 a 4 6" :: Either ParseError [Int]
20:25:37 <lambdabot>  Not in scope: ‘parse’Not in scope: ‘satisfy’    Not in scope: ‘many1’
20:25:37 <lambdabot>      Perhaps you meant ‘many’ (imported from Control.Applicative)Not in scope...
20:27:58 <nineonine> worked !
20:27:59 <nineonine> thanks
20:28:01 <nineonine> parse (sepEndBy integer (many1 (satisfy $ (\x -> not (isDigit x || x == '-'))))) "Test" ("-12 1 4 6" :: String)
20:28:16 <kadoban> Cool :)
20:28:34 <nineonine> actually worked only for spaces
20:28:38 <nineonine> :))
20:28:47 <kadoban> Haha, you mean it breaks for other stuff?
20:28:55 <nineonine> fails when i feed it smth like that
20:28:56 <nineonine> "as-12as 1asf 4 6"
20:29:01 <nineonine> yeah
20:29:11 <nineonine> it did not fail
20:29:16 <nineonine> just empty list
20:29:45 <nineonine> oh ! actually 
20:29:46 <kadoban> Oh, it needs to consume the nonsense at the start
20:30:06 <nineonine> yeah !
20:30:09 <nineonine> :)
20:30:20 <nineonine> possible nonsense
20:30:52 <kadoban> Right, many instead of many1 … which actually works for the separator too, it doesn't actually have to be many1 I don't think.
20:32:03 <kadoban> I thought lambdabot had Parsec or one of those imported somewhere. I wonder if it's qualified … hmm.
20:40:53 <nineonine> im trying to abstract away that second argument to sepEndBy 
20:41:21 <nineonine> so i can do smth like 
20:41:22 <nineonine> noise *> sepEndBy integer noise
20:41:28 <nineonine> but im getting the error
20:43:17 <nineonine> nvm now its ok :D
20:43:24 <kadoban> Hehe
21:03:24 * hackagebot pinboard 0.9.3 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.3 (jonschoning)
21:46:35 <Tordek> https://gist.github.com/Tordek/cdc1800795aeaf3d9d05 how can I write this in a way that isn't as ugly?
21:47:57 <Ralith> Tordek: you could use 'maybe', and another layer of fmap instead of bind + return
21:48:43 <Ralith> and move the fromIntegral inside somewhere you've already unwrapped the Maybe
21:49:17 <jle`> there's no reason to ever >>= and return, heh
21:49:49 <jle`> Tordek: what's the type of getInfo?
21:49:54 <jle`> *getNetInfo
21:49:59 <Tordek> IO [Int]
21:50:27 <Tordek> sorry, IO (Maybe [Int])
21:51:07 <jle`> any reason you're using a list of two items instead of a tuple?
21:51:29 <Tordek> I didn't write the library ;[
21:52:03 <jle`> hm, but then how do you know that the thing is two items long for sure?
21:52:18 <Tordek> because it always returns bytes sent, bytes received
21:52:29 <jle`> hm, yeah, not the best design heh
21:52:32 <jle`> oh well ;_;
21:52:36 <Tordek> yeah :/
21:52:47 <Tordek> taffybar has a lot of... interesting... choices
21:55:01 <jle`> what's the type of ref?
21:55:04 <jle`> is it not [Int] ?
21:55:07 <jle`> er, IORef [Int] ?
21:55:12 <Tordek> IORef [Double[
21:55:28 <Tordek> becuse I store into it after I `fromInteger` it
21:55:45 <jle`> does it need to be a Double ?
21:55:46 <Tordek> but, I guess it might make sense to cast just the return...
21:56:03 <jle`> this is how i'd do it -- https://gist.github.com/mstksg/42d817ae485a07639f4f
21:57:32 <Ralith> also, if your function always returns a list of two elements, maybe use a tuple?
21:58:06 <Tordek> Ralith: I didn't write getNetInfo nor the thing calling eth0Callback :(
21:58:15 <Ralith> submit a patch!
21:59:46 <nitrix> Hi
22:00:23 <nitrix> I'm looking for a way to combine boxUpdate and boxMsg into a function equivalent in type to :: Box -> Message -> (Box, [Message])
22:00:25 <nitrix> http://lpaste.net/152862
22:00:30 <Tordek> https://gist.github.com/Tordek/ef183b66fc48f93274c6 jle` 
22:00:53 <Tordek> Ralith: yeah but i'm lazy....
22:00:58 <jle`> Tordek: that wouldn't work
22:01:00 <Tordek> also, school
22:01:12 <nitrix> I was thinking :: Message -> State Box [Message] but that's bad.
22:01:18 <jle`> Tordek: you can't write a [Int] to an IORef [Double]
22:01:40 <nitrix> The idea is to be able to accumulate output messages AND mutate the Box.
22:01:44 <Tordek> jle`: I can change the type of IORef; I wasn't clear
22:02:04 <nitrix> With this state monad, it'd only be able to return once :/
22:02:13 <nitrix> Rather than accumulating messages.
22:02:19 <jle`> Tordek: ah, okay
22:03:08 <jle`> really don't like the $ there though v.v but that's a stylistic thing
22:03:54 <Tordek> jle`: haha, I'm open to design critiques :P
22:06:08 <jle`> i can't think of any other way that's much beter, though, honestly ><
22:06:28 <jle`> return . map fromIntegral $ zipWith (-) r_next r_prev ?
22:08:11 <Tordek> well, I did end up with something a little less eyes-tear-out-y
22:08:29 <Tordek> but doing imperative in haskell feels icky
22:08:53 <jle`> well, at least it's less icky than imperative in not-haskell :)
22:08:58 <Tordek> :P
22:09:10 <Tordek> thanks!
22:09:21 <jle`> some people like to lambdacase things like this
22:09:25 <jle`> if you don't like naming 'res'
22:09:33 <Tordek> lambdacase?
22:09:42 <jle`> getNetInfo "eth0" >>= \case
22:09:48 <jle`>     Just r_next -> do ...
22:09:55 <Tordek> oooh
22:10:08 <jle`> not super common, but i can see the benefit in readability and stuf
22:22:35 <johnw> lambdacase can be quite handy
22:23:22 <Tordek> nitrix: writer monad?
22:23:27 * hackagebot cryptonite 0.12 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.12 (VincentHanquez)
22:32:53 <prooftechnique> Doesn't Writer always lead to memory leaks? I thought I read something to that effect, recently
22:34:44 <johnw> prooftechnique: where did you hear that?
22:35:10 <prooftechnique> Let me see if I can find a reference
22:37:10 <prooftechnique> Oh, that might be WriterT
22:38:14 <prooftechnique> Looks like I'm probably referring to Peaker in this thread: https://www.reddit.com/r/haskell/comments/3faa02/what_are_some_real_world_uses_of_writer/
22:39:49 <prooftechnique> Oh, and maybe this on SO: http://stackoverflow.com/questions/7720929/space-leaks-and-writers-and-sums-oh-my
22:43:28 * hackagebot minilens 1.0.0.1 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-1.0.0.1 (RaminHonary)
22:43:30 * hackagebot rose-trie 1.0.0.1 - Provides "Data.Tree.RoseTrie": trees with polymorphic paths to nodes, combining  properties of Rose Tree data structures and Trie data structures.  https://hackage.haskell.org/package/rose-trie-1.0.0.1 (RaminHonary)
22:58:28 * hackagebot text-postgresql 0.0.2.0 - Parser and Printer of PostgreSQL extended types  https://hackage.haskell.org/package/text-postgresql-0.0.2.0 (KeiHibino)
23:13:29 * hackagebot hspec-megaparsec 0.1.1 - Utility functions for testing Megaparsec parsers with Hspec  https://hackage.haskell.org/package/hspec-megaparsec-0.1.1 (mrkkrp)
23:35:26 <rtpg> What's everyone's go-to tool for storing persistent data for small scripts?
23:36:36 <montanonic> rtpg: there's acid-state; I haven't used it, but for the use-case you're describing it seems like it might be a solid fit
23:36:49 <rtpg> I'm trying to avoid having to set up a db, I thought maybe acid-state seems good but I really don't get what's going on when reading through the docs
23:36:56 <orion> What's the proper way of ignoring all exceptions that happen within a block?
23:37:32 <rtpg> yeah, reading the description acid-state seems like a good fit... I'll try again
23:37:47 <rtpg> Feel like I have to try 3 times before I get any of the major Haskell libs 
23:38:24 <montanonic> rtpg: I've been there, and when it comes to 25% of libraries, still am there
23:39:06 <montanonic> rtpg: the Haskell Programming book helps a lot with teaching the skills needed to understand many libraries; I'd recommend looking into it 
23:40:24 <montanonic> rtpg: just play around with it for a while, I'm confident you'll start piecing it all together :) have fun 
23:40:51 <montanonic> orion: inside of a `do` block, or any code block?
23:41:14 <montanonic> orion: if you want to short circuit evaluation, the Continuation Monad is boss
23:41:45 <montanonic> oh, but you're talking about just avoiding exceptions
23:41:47 <montanonic> hmm, not sure
23:43:21 <orion> I think I've solved it with handle (\(_ :: SomeException) -> foo) $ do mightThrow; foo
23:43:30 * hackagebot hpdft 0.1.0.0 - tools to poke pdf using haskell  https://hackage.haskell.org/package/hpdft-0.1.0.0 (keiichiroShikano)
23:46:15 <nut_> i have installed haskell platform  on windows. if my cabal packages messed up, how do i clean up and reinstall everything ?
23:47:21 <nut_> can i just delete these two:  C:\Users\user\AppData\Roaming\cabal       C:\Users\user\AppData\Roaming\ghc
23:48:30 * hackagebot hpdft 0.1.0.1 - tools to poke pdf using haskell  https://hackage.haskell.org/package/hpdft-0.1.0.1 (keiichiroShikano)
23:48:46 <jle`> i always wanted to poke pdf?
