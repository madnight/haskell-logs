00:01:32 <montanonic> Don Stewart writes that "almost all designs fall into the 'compiler' or 'interpreter' pattern" in this SO post: http://stackoverflow.com/questions/27852709/enterprise-patterns-with-functional-programming/27860072#27860072
00:02:14 <montanonic> What would be a concrete example of this? (Small Toy code, or references to libraries/structures that capture these techniques (free Monad?) preferred)
00:04:10 <HoloIRCUser3> Hello, anybody?
00:06:03 <phadej_> montanonic: e.g. http://hackage.haskell.org/package/github-0.14.1/docs/GitHub-Request.html
00:07:36 * hackagebot not-gloss 0.7.6.4 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.4 (GregHorn)
00:07:36 * hackagebot hoauth2 0.5.3 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.3 (HaishengWu)
00:08:51 <phadej> montanonic: there is an example how you could reuse the request in the operational monad, I also reuse it in Haxl
00:09:02 <montanonic> phadej: what would be a way of using that library that did not involve operational/Free? I'm learning about Free Monad's right now, and it's really interesting, but I was curious if there was another method.
00:10:00 <jle`> most of the things you can do in Free, you can do using normal types without Free
00:10:09 <jle`> by just "inlining" the recursion
00:10:23 <montanonic> jle`: what's "inlining" recursion?
00:10:37 <jle`> inlining the definition of Free
00:11:00 <montanonic> jle`: and I know that you don't need the additional structure, I was just curious in the context of Stewart's post what other "industrial-strength" patterns there were
00:11:02 <jle`> data Free f a = Return a | Free (f (Free f a))
00:12:27 <jle`> so, instead of `Free Maybe`, you would inline 'Maybe' into where 'f' is and make a new data type like that
00:13:51 <jle`> so people say data StateF s a = Get (s -> a) | Put s a, and using 'Free (StateF s)'
00:14:05 <jle`> you coudl just do data State s a = Get (s -> State s a) | Put s (State s a) | Return a
00:14:20 <montanonic> jle`: ah, okay, I see
00:14:21 <phadej> montanonic: there is e.g. executeRequest which executes requests directly in IO
00:15:01 <jle`> so Free doesn't have a monopoloy on the interpreter pattern :O
00:15:47 <montanonic> jle`: it seems like it's more useful than breaking down the State structure though, no?
00:15:59 <montanonic> Given that you can sequentially compose
00:16:12 <jle`> not sure what you mean; both types behave the same way
00:17:01 <montanonic> jle`: I might be mistaken, but wouldn't you end up redefining the Free Monad if you made it so that the second State type could build up ASTs the way free can?
00:17:31 <montanonic> So from my presumptive perspective, they are the same thing, but Free comes with interop and instances baked in
00:17:32 <jle`> in what way is the second State redefining the free monad?
00:17:37 <montanonic> it isn't
00:18:13 <jle`> yeah, what Free gives you us a pre-written (potentially inefficient) Monad, Applicative instances that you can use
00:18:18 <jle`> *is
00:19:14 <montanonic> jle`: I think I'll have to play around with both types and using them to get a feel for how to use them
00:19:32 <montanonic> I don't think I can ask any useful questions until I do. Thanks jle` .
00:19:45 <jle`> it's also a good habit to avoid explicit recursion when you can, and use "higher order functions" and combinators instead
00:19:51 <jle`> so Free lets you factor out the explicit recursion
00:20:03 <jle`> but my point is that Free is not what gives the interpreter its power
00:20:13 <jle`> free is not what makes the interpreter an interpreter
00:20:28 <jle`> it's the type itself; free is just a way to get the free monad instance you would have written anyway
00:20:48 <montanonic> jle`: right, okay, so your "functor" in this case would be the power of the interpreter
00:21:01 <montanonic> jle`: Free is the pattern you *may* build it with
00:21:13 <jle`> yeah, it's a convenient combinator you might use to build an interpreter
00:21:16 <jle`> or you could build it directly
00:21:42 <montanonic> jle`: can you refer me to any examples that do the latter?
00:21:51 <montanonic> I'd like to see what that could look like.
00:21:52 <jle`> the State example I gave above is an example
00:22:08 <montanonic> jle`: I mean in terms of the actual interpretation, not the type
00:22:12 <phadej> montanonic: in github example there was first directly "repos :: IO [Repo]", now in the intepreter pattern, that IO action is split into "reposR :: Request [Repos]" and "executeRequest :: Request a -> IO a"
00:22:13 <jle`> `Free (StateF s)` and `State s` are essentially the same type
00:22:14 <montanonic> not *just* the type, rather
00:22:27 <phadej> montanonic: which makes possible to write different interpreters
00:22:42 <phadej> montanonic: dunno if that help understand the motivation
00:23:00 <jle`> yeah.  but the being-able-to-write-different-backends property doesn't come from Free, it comes from the type itself
00:23:10 <phadej> yes.
00:23:12 <jle`> i can write out the monad instance, one sec
00:26:42 <montanonic> phadej: okay, I *think* I can understand what you meant there. Right, so the power of interpreters is building different "backends".
00:27:09 <montanonic> or something like that...
00:27:45 <montanonic> your example showed a separation of concerns as well, which seems like a good idea
00:29:55 <montanonic> I'm watching this: https://www.youtube.com/watch?v=hmX2s3pe_qk right now to further my understanding.
00:30:13 <montanonic> (of the "interpreter" pattern)
00:31:53 <lonokhov> o/ is there channel for using haskell with nix? Should I just ask here?
00:32:47 <lonokhov> Also I do not agree that explicit recursion is that bad. Quite often it is easier to write and read.
00:39:48 <quchen> What's unsafe about reallyUnsafePtrEquality#? I can imagine a couple of things, but none are *really* unsafe.
00:40:47 <quchen> The result 0# means very little, but 1# should tell me that two things have the same memory location, no?
00:41:37 <lpaste> jle` pasted ‚ÄúOperational State‚Äù at http://lpaste.net/152637
00:41:42 <quchen> Or could it be that when I compare (a) and (b), while doing so, the GC moves one of them around and I end up with an incorrect result?
00:41:43 <jle`> ^ montanonic 
00:41:55 <quchen> Unfortunately, there is nothing in the docs about this :-(
00:42:02 <jle`> that's the argument i have usually heard
00:42:05 <montanonic> jle`: looking now; thanks a bunch
00:42:34 <jle`> but yeah, you can imagine swapping out 'interpret' with, say, reading from an IO socket
00:42:37 <jle`> or a database connection
00:45:56 <montanonic> jle`: I'm going to play around with interpreting this a bit. I really appreciate the example.
00:46:06 <jle`> hold on one sec, adding an extra interpreter
00:46:18 <montanonic> jle`: will do :)
00:48:59 <Lokathor> oh no, haddock processes my file after the Template Haskell has run
00:49:07 <Lokathor> my poor doc coverage suffers
00:49:34 <lpaste> jle` revised ‚ÄúOperational State‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/152637
00:49:46 <jle`> montanonic: ^
00:49:54 <montanonic> ty!
00:50:19 <jle`> np.  i guess the main point is that the magic isn't from Free, it's just from the algebraic type itself :)
00:51:16 <jle`> and you'll find that writing interpreters for `Free StateF` feels very similar
00:51:29 <Lokathor> is there a way to prevent haddock from including definitions by regex, perhaps?
00:52:17 <Lokathor> or, i guess i can just have a huge export list
00:52:19 <montanonic> jle`: yeah, I'm going to turn this example into one with Free and compare. get a feel for them both
00:52:31 <jle`> sounds like a good plan!
01:04:32 <quicksilver> quchen: yes, what you said. false positives and false negatives both possible
01:05:16 <quchen> quicksilver: Ah, then I overlooked the false positives, I thought "true" was an indicative answer.
01:05:33 <quchen> quicksilver: So what would valid uses of this function be then, when it makes almost no guarantees?
01:05:38 <quchen> Can I apply it only to stable things?
01:05:45 <quchen> Pointer-stable, that is
01:07:04 <quchen> quicksilver: And also, this means it's "unsafe", i.e. yields wrong results, should probably be in IO, and so on. But what's "really" unsafe about it? Can it randomly segfault, for example?
01:07:19 <quicksilver> quchen: no
01:07:26 <quicksilver> it's not unsafe in that sense
01:07:30 <quicksilver> just very unreliable
01:08:04 <quchen> I see. And since it's a primop, it probably bypasses everything and goes straight to CMM?
01:08:10 <quicksilver> as to when you can use it - hard to say. There might be cases where having a "reliable and very fast guess" about an answer speeds up an algorithm
01:08:18 <quicksilver> well it compiles to a pointer comparison in the end
01:08:20 <quicksilver> as you might expect
01:09:20 <quchen> Hmm, I guess when the correctness of your algorithm doesn't depend on the result of the comparison it might be a good optimization, yes.
01:10:05 <tdammers> something like a binary search could benefit
01:10:36 <quchen> tdammers: How so?
01:10:52 <quchen> Binary search doesn't really have probabilistic elements, does it?
01:11:27 <tdammers> it does, in that it assumes a uniform distribution when splitting the list in half
01:11:48 <tdammers> but if you can use a guess to make a better call than "split in the middle", the search might be faster
01:12:06 <tdammers> not sure if that's the kind of guess we're talking about here though
01:12:24 <quchen> Ah right, binary search doesn't have to divide in the middle to get logarithmic performance
01:12:51 <quchen> I always forget about that, or better: I always get used so much to splitting in the middle that I don't remember this part
01:13:16 <ggVGc> what's a better way to write this?           case a of
01:13:16 <ggVGc>             []-> (newState, Nothing)
01:13:16 <ggVGc>             [e] -> (newState, Just e)
01:13:41 <quchen> ggVGc: The "list longer than 1 element" case is missing.
01:13:51 <quicksilver> ggVGc: (newState, listToMaybe a)
01:13:54 <ggVGc> quchen: yeah, but it's preceeded by a "take 1" so it doesn't exist
01:14:13 <ggVGc> quchen: thanks
01:14:15 <quicksilver> with listToMaybe you can skip the take 1 also
01:14:33 <quchen> ggVGc: I recommend avoiding this kind of implicit knowledge, even locally, in favour of things like listToMaybe, like Quicksilver said.
01:14:38 <quicksilver> I'm not quchen, I'm much icksilver than quchen.
01:14:44 <mauke[w]> case a of [] -> (newState, Nothing); e : _ -> (newState, Just e)  -- wouldn't've needed take 1 anyway
01:15:29 <zd234> what is state of the art for haskell dsl -> javascript
01:15:35 <zd234> I'm not referring to Fay / GHCJS
01:15:42 <zd234> I want a DSL within Haskell for outputting javascript
01:15:56 <jle`> ggVGc: (newState, listToMaybe a)
01:16:01 <jle`> oh, already written
01:16:15 <ggVGc> :) thanks
01:16:19 <levi> zd234: There's JMacro
01:16:58 <jle`> but yeah, unnecessarily incomplete pattern matches are probably not the best idea :P
01:17:35 <levi> zd234: Also Julius, from the Yesod family of Shakespeare-themed template languages.
01:18:56 <EvanR> jle`: "i know what im doin" ;)
01:19:01 <EvanR> "stand back"
01:19:20 <zd234> levi: yesod scares me; JMacro may be comprehendable
01:19:23 <EvanR> high level programming -> high voltage programming
01:20:02 <EvanR> lets cut the crap and just do programming high
01:21:29 <levi> zd234: I don't know, they're both highly dependent on template haskell. There might be other options, too; those are just the ones I'm currently aware of.
01:24:45 <zd234> hmm
01:25:07 <zd234> is there a way to get a *.hs file, and then to get the file parse, type-checked, as an AST with all the type checking info ?
01:26:06 <levi> I'm not sure if you can get it in exactly that form, but you can get that sort of information from the GHC API.
01:26:17 <levi> It's what tools like ghc-mod are built on.
01:26:28 <kritzcreek> you can get the parsed AST from here https://hackage.haskell.org/package/haskell-src-exts but it won't typecheck for you
01:27:10 <levi> The GHC API is not exactly an external-user-friendly API, though.
01:28:32 <Algebr> if I use haykll, how much haskell coding do I need to expect or is it a generally just generate crap kind of thing
01:30:30 <tdammers> Algebr: haven't used it myself, but considering how the compilation rules are written in a Haskell EDSL, I'd estimate you'll do at least as much Haskell coding as with XMonad
01:30:59 <tdammers> Algebr: and you definitely will have to deal with Haskell's build toolchain
01:32:18 <Algebr> I don't think the cabal stuff will be entirely too painful since I don't expect this will use anything other than haykll itself and would be the only reason I have haskell installed at all
01:32:26 <Algebr> at least I'm being hopeful
01:32:52 <tdammers> hmhm
01:33:17 <tdammers> I have this "static site generator for non-programmers" thing in the back of my mind, but it doesn't look like I'm going to get to it anytime soon
01:34:07 <tdammers> the idea being to have standalone DSLs for everything, and just one binary that acts as a compiler
01:34:21 <tdammers> would probably also expose a web-based GUI or sth
01:34:52 <quchen> Algebr: This is Jasper's homepage's entire source code. https://github.com/jaspervdj/jaspervdj/blob/master/src/Main.hs
01:35:04 <quchen> He's the author of Hackyll, you can see the site live here: https://jaspervdj.be/
01:35:11 <Algebr> I had a business idea to make a web ui that took markdown and then create a mirage unikernel out of it and instantly deploy, then charge $5 for the domain name if they wanted one, otherwise do a foo.parent.com like wordpress did
01:35:39 <Algebr> 1 machine could host thousands of accounts, overhead would be trivial
01:35:47 <Algebr> quchen: ah thank you
01:35:53 <tdammers> Algebr: people don't care about unikernels, and the markdown-to-website thing is basically covered by github / github pages already
01:35:54 <levi> Algebr: You don't have to mess around with the haskell code much after you get it set up the way you like; you just run the resulting executable program on new data files when your site changes.
01:36:39 <Algebr> presumably haykll understand org mode since it uses pandoc, right
01:37:10 <levi> I'm not sure how well Pandoc understands org-mode *input* right now, although it might.
01:37:35 <Algebr> Jasper's site is great, I'm trying to transfer a blog
01:37:54 <levi> Pandoc has a lot more output formats than input formats.
01:37:56 <Algebr> and somethign that can make filtered rss feeds, i think haykll can do it all
01:38:01 <quchen> Algebr: Jasper's site is one of the more complicated ones, I think.
01:39:11 <quchen> Algebr: Ollie Charles' blog is just 100 lines: https://github.com/ocharles/blog/blob/master/hakyll.hs
01:39:14 <Algebr> wow compliation time is pretty bad
01:39:31 <quchen> You can really get a lot of mileage out of Hackyll if you want to do something simple
01:40:05 <Algebr> quchen: yes, mostly simple, just transfering my blog because current generator one couldn't make rss filtered feeds
01:40:18 <Algebr> and I'd rather code such logic, if need be, in haskell than elisp
01:40:24 <MasseR> out of curiosity, how come you aren't writing hakyll as hakyll? I've seen haykll multiple times and at least one hackyll
01:41:30 <quchen> MasseR: Oh. Well that's because it's wrong.
01:41:37 <quchen> I thought there was a "c" in there.
01:41:57 <Algebr> Ollie's site looks great too!
01:42:37 <quchen> ‚ô• solarized
01:47:08 <Algebr> what the hell is this https://github.com/ocharles/blog/blob/077f53696519f2ed4e8ec79a0e99f98d02e70605/code/2013-12-23-fay.js
01:47:18 <Algebr> is this generated
01:47:38 * hackagebot ginger 0.1.2.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.2.0 (TobiasDammers)
01:48:18 <quchen> Algebr: "Fay$$" suggests it's generated by Fay.
01:48:25 <Algebr> yes, I found: https://github.com/ocharles/blog/blob/master/code/2013-12-23-fay.hs
01:52:27 <magthe> Algebr: you'll do a fair bit of Haskell I'd say... look for posts on people moving from foo to Hakyll for a taste... (everyone who makes the move seems to write about it, me included :)
01:53:10 <Algebr> I'm using it because I need to move from my current blog and there are no good blogging solutions in OCaml.
01:53:19 <Algebr> and I'd like to stay with functional programming
01:54:59 <magthe> Algebr: using mirage for that markdown->unikernel bit would be close to trivial, I think
01:55:35 <Algebr> possibly, someone might be doing such a presentation in SF next month.
01:55:51 <tdammers> hmm, I wonder why stack doesn't find the package I just uploaded
01:56:10 <tdammers> hackage has it, and stack re-fetches package index automatically
01:56:57 <mgsloan> tdammers: What specifically does not finding the package mean?
01:57:19 <tdammers> stack says "The following package identifiers were not found in your indices: ..."
01:57:26 <tdammers> it does list older versions though
02:07:51 <mgsloan> Oh hrmm strange
02:09:28 <tdammers> hurr durr, I just realized this machine wasn't running ntpd
02:09:34 <tdammers> clock was 2 minutes off
02:09:37 <tdammers> so maybe that played a role
02:11:04 <jophish> I wonder why Bytestring doesn't have nice mutable utilities like Vector
02:11:18 <jophish> I so want to fill one up in C and then freeze it
02:12:55 <jophish> I guess it's not too hard to construct one from a foreign pointer
02:18:50 <erebe_> jophish: look around for ByteString builder or lens
02:18:58 <cocreature> jophish: there is packCString but I agree that some lower level thing (or simply exposing the constructors in some internal module) would be nice
02:19:57 <erebe_> jophish: with lens you can use over "http://www.haskellforall.com/2015/10/explicit-is-better-than-implicit.html"
02:22:28 <mgsloan> tdammers: Hahah, that sounds like a plausible explanation :)
02:23:05 <jophish> tdammers: One of our build slaves here started failing recently, the clock was about 18 minutes off I think
02:24:23 <pikajude> is there a good way to write a doubly-linked list in haskell so that an element can be easily moved from an arbitrary point in the middle to the front?
02:24:23 <jophish> erebe_: I'm not sure what you mean. Sadly I can't replicate this external library in Haskell
02:24:44 <pikajude> if I have just a reference to a single Node, I'd have to traverse all the way in one direction to move the item to the "front" or "back" of the list
02:26:36 <tdammers> I don't think there's a truly elegant way to write a doubly-linked list in Haskell
02:26:51 <caumeslasal> Noob question on pipes and JSON : using Pipes.Aeson, I only see a @encodeArray :: Monad m => Array -> Producer' ByteString m ()@ method. I have a pipe that produces (toJSON a) values downstream, is there a way to serialize/pipe that serialize these values into a ByteString that represents a JSON Array, without breaking the pipe (that is, having the full Array into memory) ? 
02:27:22 <tdammers> discussed this earlier; you have two choices: a) emulate pointer semantics on top of some sort of container (e.g. a HashMap), or exploit laziness
02:27:32 <tdammers> b) exploit laziness, that is
02:27:49 <tdammers> a) works but isn't elegant at all; b) will make your head explode
02:27:59 <tdammers> [citation needed]
02:28:37 <tdammers> or, well, there's c), implement it in C and wrap it in a sane-ish FFI API
02:30:05 <caumeslasal> I mean, if I have a pipe that produces Int's , is there a way to pipe-produce a JSON ByteString such as "[1,2,3‚Ä¶]" (Pipe.map encode produces "123‚Ä¶", which is invalid JSON)
02:32:13 <cocreature> caumeslasal: I don‚Äôt think you can do that. Aeson insists on putting arrays into a vector which will mostly likely break streaming (assuming stream fusion doesn‚Äôt kick in). there is @hackage json-stream but I‚Äôve never used that myself
02:33:05 <jophish> hmm, I'm passing the pointer inside a bytestring to a c function (this time it's a const pointer) and I get back a structure I must run a finalizer on. What's the neatest way of specifying that the bytestring must be kept alive until after that finalizer returns?
02:33:46 <jophish> Foreign.ForeignPtr warns against using touchForeignPtr (with good reason) but doesn't seem to suggest a nice alternative for this case
02:34:10 <jophish> It seems like a case which must come up quite often
02:36:56 <jophish> I'm sure that there's a very good reason as to why this is a pain point
02:38:28 <jophish> The easiest way of doing this would be to copy the bytestring data into a mallocd buffer and free that in the finalizer. I'm a little hesitant to do this as the bytestring could be several gigabytes in size...
02:44:30 <caumeslasal> cocreature: thank you, that's what I thought.
02:45:18 <cocreature> caumeslasal: if you only care about a very specific structure of json that you want to encode, it might be the easiest to just write a small decoder yourself
02:50:09 * hackagebot hoauth2 0.5.3 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.3 (HaishengWu)
02:50:09 * hackagebot ginger 0.1.2.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.2.0 (TobiasDammers)
02:53:56 <anohigisavay> hi
02:54:18 <anohigisavay> how to parse a JSON value that can appear in multiple types?
02:54:23 <anohigisavay> with aeson?
02:54:43 <anohigisavay> e.g. {"val": 123} / {"val": "abc"}
02:55:24 <anohigisavay> and say I have data Val = I Int | S String
02:58:59 <jophish> I think my question boils down to: What's the best way to express a dependency from the code running in a finalizer and the lifetime of an object in Haskell
02:59:59 <jophish> touchForeignPtr looks so tantalizing!
03:01:06 <jophish> The haskell object in question is a Bytestring, which is another ForeignPtr under the hood.
03:04:53 * hackagebot hoauth2 0.5.3 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.3 (HaishengWu)
03:04:53 * hackagebot ginger 0.1.2.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.2.0 (TobiasDammers)
03:05:45 <pikajude> tdammers: how could I exploit laziness to do it?
03:05:46 <the_2nd> Can I mage executeable settings in my .cabal?
03:05:58 <the_2nd> e.g. One.hs => One Two.hs => Two
03:06:04 <the_2nd> all with same build settings
03:08:46 <tdammers> pikajude: you could use infinite recursive data structures, something like let head = Node nil next; next = Node head Nil in head
03:09:42 <tdammers> this is circular: you can follow the next -> prev chain indefinitely, but if Node is a lazy data type, then your list never get evaluated fully
03:10:51 <pikajude> well wouldn't I be doing that already
03:11:12 <pikajude> how does that give me O(1) on moving the node to the front of the list?
03:13:07 <nyuszika7h> how can I stop this script from using all my memory while still being relatively fast? (I'm compiling with -O3) http://termbin.com/food
03:13:15 <nyuszika7h> s/script/program/
03:16:03 <MasseR> nyuszika7h: have you tried memory profiling it?
03:16:20 <nyuszika7h> valgrind? or something else?
03:16:25 <MasseR> something else
03:16:26 <MasseR> just a sec
03:16:56 <MasseR> https://blog.pusher.com/memory-profiling-in-haskell/ for easier read
03:17:04 <MasseR> http://book.realworldhaskell.org/read/profiling-and-optimization.html
03:22:35 <nyuszika7h>     Could not find module ‚ÄòCrypto.Hash.MD5‚Äô
03:22:37 <nyuszika7h>     Perhaps you haven't installed the profiling libraries for package ‚Äòcryptohash-0.11.6@crypt_3im3fXRRCnR5Z0g4gmWKQO‚Äô?
03:22:49 <nyuszika7h> how do I instal that?
03:22:51 <nyuszika7h> *install
03:28:19 <omder> what is haskell?
03:29:04 <rom1504> a language
03:29:15 <omder> hello my friends what is haskell?
03:29:49 <rom1504> today you are going to discover a very convenient website omder, it's called https://www.google.com/ , you can ask it anything
03:30:29 <MasseR> also there is a channel topic which gives some useful urls
03:30:51 <omder> hi all
03:30:54 <omder> what is haskell?
03:30:55 <MasseR> nyuszika7h: are you using stack?
03:31:12 <omder> yes
03:31:12 <MasseR> if you are you can add '--enable-executable-profiling' in your build command
03:31:17 <nyuszika7h> not sure what that is, so probably not
03:31:18 <rom1504> omder: what is omder ?
03:31:51 <omder> omder my city
03:31:51 <MasseR> nyuszika7h: using stack is highly recommended. Otherwise we will end up in a rabbithole of instructions :)
03:38:54 <omder> hello all
03:40:07 <omder> What the similarities between hack app & haskell
03:43:46 <vkt> why can some functions be written in point free style?
03:44:13 <jeme> what is point free style????
03:44:29 <pikajude> #haskell-beginners
03:44:34 <bergmark_> @pl \x y -> x + y * x / 3
03:44:34 <lambdabot> liftM2 (.) (+) (flip flip 3 . ((/) .) . (*))
03:44:35 <MasseR> @pl \f g x -> f (g x)
03:44:35 <lambdabot> (.)
03:47:39 <vkt> bergmark_: its clearly more readable
03:48:59 <vkt> MasseR: did lambdabot tell you to use function composition?
03:49:31 <MasseR> It showed me that function composition is function composition :)
03:49:54 <vkt> ok so it wasn't a cocky remark but simply syntactically the right answer :P
03:50:14 <MasseR> It was a pointless answer ;)
03:50:32 <vkt> @pl \f g -> f . g
03:50:32 <lambdabot> (.)
03:51:29 <mauke[w]> @pl \x y z -> foo x y z
03:51:29 <lambdabot> foo
03:56:48 <matthi___> l
03:56:54 <matthi___> test
03:57:16 <vkt> geht
03:57:33 <matthi___> hi
04:00:01 * hackagebot conduit-extra 1.1.10.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.10.1 (MichaelSnoyman)
04:24:21 <tangled_z> hey guys, do you have any good resources on alleviating the impendence mismatch between FP and databases? 
04:24:43 <tangled_z> databases have always been my least favorite part of development and i want to learn more about how haskellers approach the problem
04:24:56 <Jinxit> tangled_z: look into datomic, it's clojure rather than haskell, but a pretty cool approach
04:25:00 * hackagebot transformers 0.5.2.0 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.2.0 (RossPaterson)
04:26:04 <tangled_z> Jinxit: thanks for the recommendation! have you used it? what is it like in practice? 
04:26:28 <ahihi> tangled_z: for haskell, check out persistent. the yesod book has a chapter on it: http://www.yesodweb.com/book/persistent
04:29:51 <tangled_z> ahihi: thanks! wow, it looks amazing, definitely going to try it out. 
04:30:59 <tangled_z> ahihi: do you think it solves the impendence mismatch completely or are there still caveats to be aware of? 
04:37:12 <ahihi> tangled_z: I've only used it for simple stuff, but so far I've found it very pleasant. it does give you somewhat limited control over the generated SQL, but esqueleto helps there
04:42:08 <tangled_z> ahihi: thanks for the info! I will try them out :) 
04:53:56 <Jinxit> tangled_z: I'm afraid I haven't actually used datomic (I don't tend to build stuff that requires databases) but I've heard it's somewhat of a paradigm shift
04:54:08 <Jinxit> basically bringing functional programming to databases
04:59:22 <tangled_z> Jinxit: I definitely need to experiment with that
05:00:30 <ironChicken> does anyone know of a package for reading IEEE 754 strings?
05:00:37 <ironChicken> the Prelude Read instance for Double is mainly ok, but doesn't seem to handle things like "inf"
05:04:00 <ironChicken> hmm, although i guess i actually want to continue using Double. and if Double doesn't represent inf/-inf then maybe a reader is not what i need
05:04:36 <boj_> ironChicken: i'm probably just massively ignorant, but strings?
05:05:22 <liste> > (1/0) :: Double
05:05:24 <lambdabot>  Infinity
05:05:27 <liste> > -(1/0) :: Double
05:05:29 <lambdabot>  -Infinity
05:06:27 <boj_> ah
05:06:44 <liste> ironChicken: do you mean external character sequence formats specified in the standard?
05:13:45 <bernalex> anyone have some succinct and immediately obvious examples of how the IO type protects you from making mistakes with side-effects?
05:14:11 <opqdonut> bernalex: if there is no IO in a type, it can't have side effects
05:14:24 <opqdonut> which simplifies e.g. testing
05:14:37 <opqdonut> and means you can parallelise safely
05:14:39 <bernalex> opqdonut: yes that's the one I am already using -- "you can know that this function won't produce any effects at runtime"
05:14:59 <bernalex> opqdonut: I'm making a case for IO stickyness :)
05:16:54 <zomg> I like how the haskell wiki in the topic says "we've had up to 1046 concurrent users" and there's more than that by a few hundred atm :P
05:20:02 * hackagebot second-transfer 0.10.0.1 - Second Transfer HTTP/2 web server  https://hackage.haskell.org/package/second-transfer-0.10.0.1 (dsign)
05:30:03 * hackagebot network-transport-tcp 0.5.0 - TCP instantiation of Network.Transport  https://hackage.haskell.org/package/network-transport-tcp-0.5.0 (FacundoDominguez)
05:54:14 <acarrico> I'm not a Haskell programmer (yet, anyway), but if you aren't tired of Qs about IO...
05:54:59 * Clint squints.
05:55:32 <acarrico> Can the programmer store IO values in a variable (with bind, for example), and what happens if the programmer uses one twice?
05:56:51 <obadz> acarrico: then the IO action will be run twice
05:56:51 <acarrico> I get that they are used to order a computation by threading through that computation, but I don't see what prevents an old one from being reused.
05:57:08 <acarrico> obadz: with a cached result or a new result?
05:57:20 <m0rphism> acarrico: `IO a` is a first class value, representing a computation, which produces an `a`. Using the action twice, performs the computation twice (including side effects, like writing to files).
05:57:21 <obadz> acarrico: new result
05:57:49 <obadz> like printBlah = putStrLn "Blah" :: IO ()
05:57:56 <obadz> if main = printBlah >> printBlah
05:58:06 <obadz> then Blah is printed twice.
05:58:55 <acarrico> obadz: My understanding is that the two putStringLns would each get different IO values in that example.
05:59:10 <obadz> what's an IO value?
06:00:04 * hackagebot fclabels 2.0.3 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.3 (ErikHesselink)
06:01:00 <acarrico> obadz: My understanding is that IO operations take in an IO value, and produce another IO value, and that these values represent subsequent states of the universe.
06:02:17 <m0rphism> acarrico: `IO` is not a type and can not have values, `IO String` is a type and can for example have the value `getLine`.
06:02:19 <obadz> you're wondering if there's a way to "fork" the universe?
06:02:33 <obadz> which would lead to a contradiction?
06:02:54 <acarrico> obadz: I'm wondering what *prevents* you from forking the universe.
06:03:07 <obadz> acarrico: there is no way to run an IO action other than calling it from another IO action
06:03:15 <acarrico> m0rphism: IO isn't a type? I better read a bit more.
06:03:29 <obadz> acarrico: and down the line, main is the only IO action that gets invoked
06:04:04 <obadz> acarrico: forking the universe would require a function that can escape the monad with type signature IO a -> a
06:04:15 <m0rphism> m0rphism: `IO` is a type-level function (like `Maybe`), taking a type as input, e.g. `String` and producing an output type `IO String`.
06:04:18 <obadz> acarrico: unsafePerformIO can do that, but you should basically assume it's not there
06:04:29 <m0rphism> acarrico: oops self reference ;)
06:04:45 <acarrico> obadz: I think I understand, in 
06:05:26 <acarrico> IO a, you can bind an a, but you can never hold the "token" (I was calling it the IO value) which represents the state of the universe.
06:05:41 <aweinstock> :t Control.Concurrent.forkIO
06:05:42 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
06:06:24 <aweinstock> (or did you mean "forking the universe" in some other sense?
06:06:26 <aweinstock> )
06:08:49 <acarrico> m0rphism: In https://wiki.haskell.org/IO_inside, they show:  type IO a  =  RealWorld -> (a, RealWorld) basically, I was wondering what prevents an old RealWorld from being used twice.
06:09:18 <m0rphism> acarrico: ah I see. It's prevented by not exposing RealWorld to the programmer.
06:09:50 <acarrico> m0rphism: got it, so you must use it "sugared"?
06:09:50 <m0rphism> acarrico: At least I think it's not exposed ^^
06:11:07 <m0rphism> acarrico: yes, IIRC there actually never is a value of type `RealWorld`, it's just a trick, to let the compiler ensure order without introducing a special case for non-pure functions.
06:11:46 <acarrico> obadz: m0rphism: thanks
06:12:02 <m0rphism> acarrico: you're welcome, hope I could help ^^
06:12:53 <acarrico> m0rphism: I guess I should install ghc so I can try examples.
06:13:06 <ironChicken> > (read "-inf") :: Double
06:13:08 <lambdabot>  *Exception: Prelude.read: no parse
06:13:13 <ironChicken> liste: ^^
06:13:31 <geekosaur> acarrico, tryhaskell.org
06:13:32 <obadz> acarrico: also there are deeper issues with thinking of IO as a State RealWorld
06:13:51 <ironChicken> maybe i don't mean IEEE 754. but there's a string representation of doubles that uses "-inf", "inf", "nan"
06:13:58 <geekosaur> hm, not sure that provides even liited IO though
06:14:02 <geekosaur> limited
06:14:16 <acarrico> geekosaur: Ah, thumbs up, that sounds easy.
06:14:43 <liste> ironChicken: you could define a parseDouble :: String -> Double that handles the special cases and uses `read' otherwise
06:15:07 <ironChicken> liste: yes, sounds pretty easy. i was just wondering if it already existed
06:15:22 <liste> I don't think that's any standard representation
06:15:23 <aweinstock> > -1/0 :: Double
06:15:26 <lambdabot>  -Infinity
06:15:31 <mceier> > (read "-Infinity") :: Double
06:15:33 <lambdabot>  -Infinity
06:15:40 <jophish> ironChicken: It sounds like the kind of thing which should be on hackage. You should add it if it's not there already
06:16:00 <aweinstock> > 0/0 :: Double
06:16:02 <lambdabot>  NaN
06:16:07 <liste> > (read "NaN") :: Double
06:16:09 <lambdabot>  NaN
06:16:30 <ironChicken> hmm, i'll look into the source of this data and see whether its producer thinks he/she is using a standard representation
06:16:31 <aweinstock> > (0/0 :: Double) == (read "NaN")
06:16:33 <lambdabot>  False
06:21:07 <liste> naughty NaNs
06:21:16 <liste> why is there so many of them even?
06:27:11 <hexagoxel> :t isNaN
06:27:12 <lambdabot> RealFloat a => a -> Bool
06:28:44 <quchen> liste: NaN /= NaN
06:29:34 <liste> I mean technically
06:29:45 <liste> so many bit patterns correspond to a NaN
06:30:10 <opqdonut> there are different NaNs for debugging of course!
06:32:27 * liste can imagine NaNs being used to transfer OOB information
06:32:32 <liste> oh, the horrors
06:32:37 <ggole> liste: NaN boxing is a thing
06:33:04 <ggole> Implementations of dynamic languages like lua and JS that have doubles for numbers sometimes use it
06:34:36 <geekosaur> they need tooling to warn then when they're trying to k-line irccloud >.>
06:34:39 <opqdonut> ggole: oh my, I just learned about that
06:35:05 * hackagebot hpack 0.9.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.9.0 (SimonHengel)
06:48:08 <juanpabl_> anybody knows off the top of their heads if MonadWriter is commutative?
06:50:05 * hackagebot rebase 0.4.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.4.3 (NikitaVolkov)
06:51:53 <quchen> juanpabl_: a <- tell "foo"; b <- tell "bar" -- should not commute
06:52:27 <quchen> Unless your monoid is an abelian group
06:52:59 <quchen> Or just a commutative monoid ;-)
06:57:04 <juanpabl_> quchen: my monoid is (Sum Int) so it should be commutative. Thanks for your insight!
06:58:19 <catau> is there a way to use a setter and not (^?) with lens-aeson and `key`? I'm starting from this example http://hao.codes/lenses-heart-json.html
07:01:51 <quchen> ^? is preview, it's the opposite of setting things
07:02:01 <dramforever> :t key
07:02:02 <lambdabot>     Not in scope: ‚Äòkey‚Äô
07:02:03 <lambdabot>     Perhaps you meant one of these:
07:02:03 <lambdabot>       ‚ÄòIM.keys‚Äô (imported from Data.IntMap),
07:02:42 <pippijn> hi
07:02:47 <catau> quchen: I was curious if there's a way to take a json bytestring, and produce a modified bytestring with an additional field set
07:02:59 <catau> whether that field was originally present or not
07:03:00 <dramforever> catau: key returns a Traversal; it's automatically a Setter
07:03:03 <pippijn> has anyone seen this one before (when using cabal with --enable-coverage)? hpc: can not find hspec_5zUttaSVxhh4nTCplcUX7p/Test.Hspec.Expectations.Matcher
07:06:42 <Jinxit> catau: lenses can't point at something that doesn't yet exist
07:06:54 <Jinxit> (like adding an element to a list)
07:07:06 <quchen> bytestring & _JSON . key "foo" .~ Null -- catau, something like this?
07:07:15 <pippijn> ah, it's because of hspec-discover
07:07:53 <quchen> That will only modify already existing things, as Jinxit mentioned. But you can just append something to the root JSON object/list.
07:08:11 <Jinxit> (he got disconnected)
07:08:15 <quchen> Oh
07:29:25 <boj_> you made me look up "abelian group" #haskell, and that is awesome.  good night
07:37:06 <ackthet> or you could have just taking group theory in college 
07:44:53 <haskell036> how do i make this infinity list work: some_primes = 2 ++ (product some_primes) + 1
07:47:04 <pavonia> haskell036: Could you explain what you are thying to do?
07:48:44 <Gurkenglas> @let some_primes = map ((+1) . product) $ inits some_primes
07:48:45 <lambdabot>  Defined.
07:48:46 <Gurkenglas> > some_primes
07:48:48 <lambdabot>  [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,1286493868...
07:50:34 <haskell036> Gurkenglas: thanks mate
08:25:08 * hackagebot filtrable 0.1.0.3 - Class of filtrable containers  https://hackage.haskell.org/package/filtrable-0.1.0.3 (MatthewFarkasDyck)
08:44:29 <obadz> these numbers are always prime?
08:44:44 <obadz> i.e. this whole list is prime?
08:48:29 <monochrom> no
08:48:36 <Gurkenglas> These numbers are pairwise coprime.
08:50:43 <Gurkenglas> Take any nonprime, subtract one, take the prime factorization. If that is a prefix of the list of length >=2, its next entry is not prime. That's why the naive way of proving these numbers are prime doesn't work.
08:54:00 <obadz> prefix of what list?
08:54:25 <Gurkenglas> some_primes
08:54:49 <obadz> Take any nonprime >> 43
08:55:00 <obadz> Subtract one, take prime factorisation >> 2 * 3 * 7
08:55:18 <obadz> If that is a prefix of the some_primes >> check
08:55:27 <Gurkenglas> 43 is a prime...
08:55:32 <obadz> its next entry is not prime >> wrong
08:55:37 <obadz> oh
08:55:46 <obadz> thought you meant take any number ;-)
08:56:39 <obadz> I'm not clear on how you prove that you could find such a nonprime..
08:56:47 <Gurkenglas> The way you construct the list makes sure the next number is not divisible by any of the previous ones. That says nothing about the divisiblity by primes not in the list
08:57:17 <Gurkenglas> I haven't proven it, I've only thwarted the naive proof that you couldn't
09:05:31 <dexterph> are there any guides to releasing packages on hackage? best practices, etc.?
09:08:23 <dmj> dexterph: follow the PVP, include a README.md in your project and reference it in your cabal file (extra-source-dirs: README.md), then cabal sdist && cabal upload dist/*.tgz
09:08:39 <dmj> the rest is just having good documentation I guess
09:09:03 <dexterph> cool, thanks dmj
09:11:10 <dmj> s/cabal/stack
09:25:25 <maho> Hello.
09:25:36 <maho> Can someone point to good sources for haskell?
09:26:58 <Cale> maho: What kind of sources do you mean? Resources for learning? Just interesting code to read?
09:27:14 <maho> Learning
09:27:15 <kadoban> maho: http://haskellbook.com/ or if you can't spend money: https://github.com/bitemyapp/learnhaskell
09:27:41 <Cale> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:27:53 <stepcut> Is there a way in my .cabal file to depend on aeson 0.9.* or 0.11.* but not 0.10.*?
09:28:03 <Cale> maho: Also ask lots of questions here :)
09:28:29 <kadoban> stepcut: I don't think so.
09:28:42 <maho> Cale: Ok, actually I got to learn Java as well, I don't know what to do, so confused
09:29:56 <geekosaur> `aeson == 0.9.* || 0.11.*`?
09:30:10 <geekosaur> hm
09:30:41 <mmachenry> maho: Has anyone mentioned http://learnyouahaskell.com/ yet?
09:30:45 <mmachenry> It's a great place to start.
09:31:04 <geekosaur> probably not, at that. and cabal manual says nothing about parens
09:32:36 <kadoban> mmachenry: LYAH isn't very good on its own.
09:33:06 <mmachenry> kadoban: I disagree. I think it's a pretty good starting point.
09:33:15 <maho> kadoban: Why? Actually I have started that only
09:33:20 <mmachenry> kadoban: What do you think is missing from it on its own? 
09:33:41 <mmachenry> maho: What have you programmed in before if anything?
09:33:54 <kadoban> mmachenry: maho: The most obvious problem is that it doesn't have any exercises. It doesn't ask you to actually *do* anything substantial. It just ‚Ä¶ shows you some cool looking stuff and that's about it.
09:35:28 <kadoban> There is no learning without doing, hence LYAH isn't very good. Some people try to say something like "you can use project euler", but that's fundamentally doomed. The beginner doesn't have any idea what problems could even *be* good exercises using the knowledge they already have, or they wouldn't be a beginner.
09:44:46 <Jinxit> I read through LYAH to get an overview of the language
09:45:07 <Jinxit> but then learning has mostly come from trying to do things I enjoy
09:45:13 <Jinxit> (and osmosis)
09:50:31 * hackagebot userid 0.1.2.4 - The UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.4 (JeremyShaw)
09:55:01 <hexagoxel> is there a function `String -> IO String` that does "normal" variable replacement using the (current) environment variables?
09:55:48 <koala_man> hexagoxel: that's a feature of the shell, and you can call the shell to do it
09:56:10 <hexagoxel> koala_man: platform-independently?
09:56:32 <t7> haskell should allow multiple modules in one file
09:56:44 <koala_man> well no, different os does variable substitution in different ways, e.g. %FOO% on windows and $FOO on posix
09:58:39 <hexagoxel> hmm, maybe System.Process.shell works.
09:59:16 <geekosaur> I'd acually be somewha hesitant about handing that off to the shell, because the shell also does a bunch of other expansions (notably $(cmd)
10:00:32 <hexagoxel> in this case it is the (local) user providing the input, so.. not my problem.
10:01:20 <geekosaur> t7, someday
10:01:33 <mightybyte> Is there an easy way to find out how many threads cabal will use with -j?
10:01:47 <dcoutts> mightybyte: it's the number of cores
10:01:50 <geekosaur> I think there is current work in that direction, although there's no ETA as yet
10:02:12 <mightybyte> dcoutts: Is that the same as the number of entries in /proc/cpuinfo?
10:02:19 <dcoutts> mightybyte: I believe so
10:02:37 <geekosaur> modulo hyperthreading
10:02:40 <dcoutts> mightybyte: of course you can use -j20 or whatever
10:02:50 <dcoutts> right, it's the number from the pov of the kernel
10:02:55 <mightybyte> dcoutts: Do you know off-hand where in tho cabal code it gets that number?
10:03:00 <dcoutts> which included hyperthreaded cores
10:03:09 <mightybyte> Yeah, that's kind of why I'm asking. 
10:05:18 <dcoutts> mightybyte: lets see...
10:05:31 * hackagebot lol 0.2.0.0 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.2.0.0 (crockeea)
10:05:33 * hackagebot lol-apps 0.0.0.1 - Cryptographic applications using <https://hackage.haskell.org/package/lol õ À ª>.  https://hackage.haskell.org/package/lol-apps-0.0.0.1 (crockeea)
10:06:04 <dcoutts> Distribution/Client/Utils.hs:numberOfProcessors = fromEnum $ unsafePerformIO c_getNumberOfProcessors
10:06:07 <dcoutts> mightybyte: ^^
10:06:12 <mightybyte> Awesome, thank you.
10:06:53 <dcoutts> mightybyte: and then specifically
10:06:55 <dcoutts> Distribution/Client/Install.hs:    numJobs         = determineNumJobs (installNumJobs installFlags)
10:10:04 <David5> hey guys i have problems while building a project with dependences that not found a file ghc_1.lpp 
10:14:21 <prati> There are many Object oriented Analysis books ( Not the design pattern books) for OOP 
10:14:56 <prati> Similarly, Are there any resources for design analysis on  functional programming ?
10:15:32 * hackagebot Plot-ho-matic 0.9.0.4 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.4 (GregHorn)
10:24:53 <t7> i have a type alias in a module but its not exporting the default instances for it, in another module: No instance for (Num Id)
10:25:00 <t7> where type Id = Int
10:25:26 <geekosaur> aliases do not have instances
10:26:15 <t7> can i export them somehow?
10:26:26 <glguy> t7: It seems like you might be leaving something out. If "type Id = Int", then there's an instance for Num Id
10:26:27 <geekosaur> although that seems like an unfortunate error message (unless it says more than that, specifically commenting on disallowing instances on type aliases)
10:27:00 <t7> oh my bad
10:27:04 <geekosaur> yeh, what you are saying does not make a lot of sense. Id *is* Int; Int has a Num instance
10:27:05 <t7> it wasnt even int :|
10:44:15 <prati> There are many Object oriented Analysis books ( Not the design pattern books) for OOP
10:44:25 <prati> Similarly, Are there any resources for design analysis on  functional programming ?
10:45:22 <prati> for example, how to design a valet parking ? How to approach above from FP ?
10:45:33 * hackagebot happstack-authenticate 2.3.4 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4 (JeremyShaw)
10:47:36 <tsahyt> What kind of functional data structure is used for priority queues? Any references or papers would be a good starting point.
10:50:47 <kadoban> tsahyt: There's a couple nice ones in Purely Functional Data Structures by Okasaki.
10:51:41 <kadoban> tsahyt: If you're lazy you can just use a BST, possibly augmented with caching the current minimum.
10:52:12 <davean> kadoban: Okasaki predates fingertrees though, so its missing that
10:52:21 <davean> tsahyt: You can find a few implimentations on Hackage.
10:52:24 <tsahyt> what are fingertrees actually?
10:53:12 <davean> Thats easy to find papers on, or impllimentations like https://hackage.haskell.org/package/fingertree
10:53:14 <davean> which cites a paper
10:53:52 <tsahyt> okay, thanks
10:54:20 <davean> tsahyt: I guess we could possibly give you better comments if we knew why you were asking
10:55:33 * hackagebot gitit 0.12.1 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.12.1 (JohnMacFarlane)
10:56:09 <tsahyt> I'm trying to come up with a way to store blocks of time (or any 1D interval really) such that I can quickly find the longest interval, insert new ones (automatically merging with potential overlaps) and delete intervals. I thought that a priority queue would be a decent starting point to look at since it at least satisfies the first requirement
10:58:25 <davean> tsahyt: what about an interval tree?
10:59:37 <tsahyt> As far as I know, interval trees don't lend themselves very well to finding the maximum quickly
11:00:18 <davean> tsahyt: that can be easily patched up by using both a priority queue and an interval tree together, and wrapping that
11:00:35 <davean> tsahyt: https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-IntervalMap-FingerTree.html
11:00:50 <davean> tsahyt: you might just want to compose two already implimented solutions that are on Hackage.
11:01:49 <tsahyt> I think I'd have to manually do the merging of newly inserted intervals with existing ones though
11:02:03 <davean> Yes?
11:02:10 <davean> Inside your wrapper
11:02:21 <davean> Which any implimentation would have to
11:02:39 <davean> This should pose no challenge
11:03:10 <davean> Just require 'a' to be a semigroup.
11:03:20 <tsahyt> That's true. I'll do some quick estimates of how this would work in terms of complexity. Maybe it'll work well enough
11:03:28 <tsahyt> Why the semigroup constraint?
11:03:54 <davean> So you can merge the 'a's associated with the interval.
11:04:08 <davean> I mean, you mgiht restrict it to ()
11:04:13 <davean> in which case the semigroup is pretty trivial
11:04:38 <tsahyt> The values are Doubles in my case, but a more general implementation is always nice
11:05:11 <davean> well, in the case of doubles, the question becomes with semigroup do you want to use for the merge? So you'll probably wrap it 
11:05:27 <davean> calculating the complexity, at least the big-O complexity, is of course easy
11:06:05 <tsahyt> Unfortunately, the fingertree package doesn't use the interval types from intervals
11:06:06 <davean> for insert the fingertree is O(log n), but you need to do the search also to check for overlap so O(k log(n/k))
11:06:17 <davean> tsahyt: hum?
11:06:27 <davean> tsahyt: I uses Interval?
11:06:31 <tsahyt> it's not really a problem, just something I'm not particularly happy with
11:06:37 <davean> intersections :: Ord v => Interval v -> IntervalMap v a -> [(Interval v, a)]
11:06:39 <tsahyt> yeah, but it comes with its own interval type
11:07:43 <davean> tsahyt: there is also https://hackage.haskell.org/package/IntervalMap, which has the more complicated definition
11:08:21 <davean> depending on what you're trying to do
11:08:52 <davean> tsahyt: do you mean the interval type from data-interval?
11:09:00 <davean> tsahyt: there are a number of interval definitions on Hackage
11:09:09 <tsahyt> davean: http://hackage.haskell.org/package/intervals
11:09:33 <davean> ah, harmless'
11:10:01 <davean> as popular as he is, its hardly the only one :)
11:10:25 <tsahyt> Yep, it just has a bunch of very useful functions that I could make good use of
11:10:53 <davean> well, it wouldn't be hard to reuse the generic finger tree implimentation to use that
11:11:07 <davean> You'd want to learn about how finger trees do annotations and such
11:11:18 <davean> But its not a particular challenge
11:12:03 <davean> tsahyt: Once you understand the Measures thing, I think you'll see its fairly straight forward to impliment things on finger trees
11:14:41 <tsahyt> davean: Thanks, I'll look into it.
11:30:38 * hackagebot microlens 0.4.2.0 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.2.0 (Artyom)
11:30:40 * hackagebot microlens-ghc 0.4.2.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.2.0 (Artyom)
11:35:38 * hackagebot microlens-platform 0.2.3.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.2.3.0 (Artyom)
11:46:40 <David5> hey guys i have problems while building a project with dependences that not found a file ghc_1.lpp
11:47:12 <David5> any have idea about that issue_
11:47:13 <David5> ?
11:49:02 <geekosaur> I think there isn;t enough information to know what is going on
11:50:19 <David5> well i have these error
11:51:52 <David5> /tmp/ghc21314/ghc_1.lpp: openBinaryFile: does not exist
11:58:39 <geekosaur> from that error I can tell that it is haskell code somewhere looking for a ghc-generated file
11:58:46 <geekosaur> what I can;t tell (not an exhaustive list):
11:59:20 <geekosaur> what package are you building? how are you building it? (manually, cabal, stack? what options?) on what kind of system? what ghc version?
12:00:58 <jophish> HXT seems tricky to report errors in
12:01:22 <jophish> for example, I might want to throw an error if an element with a particular name didn't exist
12:01:29 <jophish> I'm not sure how to do this
12:01:34 <David5> ghc 7.10
12:01:38 <David5> stack build 
12:01:55 <jophish> Although very lovely, hxt does seem to sacrifice some level of safety
12:01:59 <David5> th package is zip-archive
12:04:41 <David5> and the system is Debia Jessie
12:06:09 <Cale> jophish: Probably the two main usual ways are viable, no? Either or exceptions?
12:06:45 <Cale> jophish: HXT seems to also have its own exceptions for whatever reason
12:09:45 <Cale> Oh, nevermind, those are just arrow-y operations for catching exceptions, but they still work with ordinary IO exceptions.
12:14:41 <dustmote> i feel like i've already asked this question, but..
12:14:59 <dustmote> if i have a binary operation that i want to compose with another operation.. how?
12:15:29 <dustmote> eg. `Int -> Int -> Maybe Int` and then `Maybe Int -> Int`
12:15:50 <Hijiri> you want it to  give Int -> Int -> Int?
12:16:23 <dustmote> yes
12:16:36 <dustmote> but i'm thinking about composition, not just calling and passing
12:17:12 <Hijiri> I'm not sure
12:17:14 <dustmote> `composed a b = dealWithMaybe $ someBinOp a b` -- this is explicit
12:17:27 <Hijiri> @pl \g f a b -> g (f a b)
12:17:27 <lambdabot> (.) . (.)
12:17:50 <lambda-11235> dustmote: curry $ f . uncurry op
12:18:06 <kadoban> dustmote: You can define your own composition operator for that, there isn't one in Prelude somewhat unfortunately.
12:18:06 <lambda-11235> :t curry $ sqrt . uncurry (+)
12:18:07 <lambdabot> Floating c => c -> c -> c
12:18:08 <jedai_> This is "on"
12:18:20 <jedai_> dustmote: From Data.Function
12:18:27 <jedai_> :t Data.Function.on
12:18:28 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:18:53 <dustmote> jedai_: `on` transforms the inputs
12:18:55 <jedai_> Ah wait... This is wrong
12:19:14 <dustmote> kadoban: yeah, i'm trying to learn if there's an idiomatic way
12:19:35 <jedai_> This is just the b**bs operator, there is no idiomatic way (though you can find it in some packages)
12:19:54 <dustmote> Hijiri: the point free thing you produced seems good, but it's confusing
12:21:00 * dustmote not sure about that name.
12:21:09 <mnoonan> iirc that operator gets named (.:) sometimes
12:21:42 <dustmote> mnoonan: do you happen to remember any such packages?
12:22:02 <mnoonan> no, hoogle didn't know it. so I might be mis-remembering.
12:22:20 <dustmote> mnoonan: thank you anyhow
12:23:00 <mnoonan> dustmote: ah, here it is: http://hackage.haskell.org/package/pointless-fun-1.1.0.5/docs/Data-Function-Pointless.html
12:23:39 <mnoonan> and this one has many generalizations: http://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
12:25:03 <tromp> > 386356909593 `mod` 8
12:25:04 <lambdabot>  1
12:25:16 <dustmote> mnoonan: ah! "This is the same as the common idiom (f .) . g but more easily extended to multiple uses, due to the fixity declaration.
12:31:20 <dustmote> @pl \f g -> curry (f . uncurry g)
12:31:20 <lambdabot> (curry .) . (. uncurry) . (.)
12:31:31 <dustmote> no prettier, ah well. just wondering :)
12:35:40 * hackagebot network-transport-tests 0.2.3.0 - Unit tests for Network.Transport implementations  https://hackage.haskell.org/package/network-transport-tests-0.2.3.0 (FacundoDominguez)
12:45:40 * hackagebot network-transport 0.4.3.0 - Network abstraction layer  https://hackage.haskell.org/package/network-transport-0.4.3.0 (FacundoDominguez)
12:49:17 <dustmote> the answer to this question might be "No" .. Is it possible to lift the 'adjustment' function passed into `adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a` into an error monad?
12:49:49 <dustmote> eg. if adjusting a value can result in a failure
12:50:07 <dustmote> such as overflow
12:50:17 <johnw> I think you can
12:50:29 <johnw> (a -> Maybe a) -> k -> Map k a -> Map k (Maybe a)
12:50:36 <johnw> and then use "sequenceA" to get Maybe (Map k a)
12:50:39 <johnw> if that's what you meant
12:51:13 <johnw> you'd use traverse to do this in practice
12:51:34 <johnw> oh, maybe not, since you only want to do it at one key
12:52:13 <dustmote> yeah the signature of 'adjust' requires `Map k a` as both input and output
12:52:28 <shachaf> dustmote: There's a proposed function alterF :: (Ord k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)
12:52:49 <dustmote> i'm trying to approach something like `adjust2 :: Ord k => (a -> Maybe a) -> k -> Map k a -> Maybe (Map k a)`
12:53:39 <dustmote> shachaf: proposed or not, it seems to exist in my version of `containers` .. thanks shachaf!
12:54:12 <shachaf> dustmote: Wait, it does? Which version?
12:54:26 <dustmote> containers-0.5.6.2
12:54:37 <shachaf> I don't see it.
12:54:49 <Xnuk> If I have `data Cat = Cat A B C` and I will use big `[[Maybe (Cat A B C)]]` or `Array (Int, Int) (Maybe (Cat A B C))` or etc., which is better: keep using `Maybe (Cat A B C)` or change to `data Cat = NotCat | Cat A B C`?
12:55:14 <dustmote> shachaf:  http://hackage.haskell.org/package/containers-0.5.6.2/docs/src/Data-IntMap-Strict.html#alter
12:55:28 <shachaf> Oh, there's alter, sure.
12:55:31 <shachaf> But that doesn't do what you want.
12:55:39 <shachaf> (And that's IntMap, not Map.)
12:56:02 <dustmote> whoops whoops
12:56:36 <dustmote> shachaf: ah, i reread the signature for `alterF` .. yes, that's definitely closer to what i wanted.
12:56:46 <dustmote> and not the same as `alter`
12:56:47 <dustmote> ah well.
12:56:56 <shachaf> It's available in lens under the name "at".
12:59:17 <dustmote> y
12:59:19 <dustmote> ty *
13:00:23 <Ralith> How do I make ghc-mod able to see my stack-installed dependencies?
13:00:55 * hackagebot network-transport-tcp 0.5.1 - TCP instantiation of Network.Transport  https://hackage.haskell.org/package/network-transport-tcp-0.5.1 (FacundoDominguez)
13:01:38 <dustmote> Xnuk: What do you mean by "better"
13:01:43 <Ralith> running ghc-mod commands produces "cabal: At least the following dependencies are missing:" and a list of my project's dependencies
13:02:15 <dustmote> Xnuk: speed? code conciseness? .. for code, I think Maybe is better -- i dunno about speed
13:06:13 <hexagoxel> Ralith: wild guess: use stack exec ghc-mod ?
13:06:38 <Ralith> that is inconsistent with the documentation and generates additional errors about GHC_PACKAGE_PATH
13:06:50 <kadoban> Xnuk: The NotCat one looks kind of funky, there doesn't seem to be a good reason to do that. That's what Maybe is for.
13:07:00 <Ralith> is anyone here actually using ghc-mod?
13:07:25 <Ralith> users seem to exist in theory but I've never actually encountered any, and it never seems to work right...
13:07:53 <dustmote> Ralith: i use ghcid with stack (on fish shell) like `ghcid --command=stack exec ghci {src,app}/**.hs`
13:08:07 <dustmote> couldn't get ghc-mod to work
13:08:22 <Ralith> it claims to support stack these days
13:08:29 <mnoonan> how are types like X | Y a b implemented anyway? A pointer to a tag followed by data?
13:10:55 * hackagebot network-transport 0.4.3.1 - Network abstraction layer  https://hackage.haskell.org/package/network-transport-0.4.3.1 (FacundoDominguez)
13:11:06 <Xnuk> dustmote: thanks. I wanted to know better choice considering both side.
13:11:11 <Xnuk> kadoban: thanks.
13:11:30 <montanonic> Ralith: I've used it before but it had been really slow in larger projects. You can `stack install` it, so it does work with stack. I find though that having a GHCi console opened next to my text editor is good enough for me though.
13:11:36 <montanonic> GHCi is *really* good.
13:12:47 <Ralith> montanonic: 'stack install' works fine, using it in a stack project does not.
13:13:03 <Ralith> montanonic: every command produces cabal errors about missing dependencies.
13:13:15 <montanonic> Ralith: oh, okay; yes I remember having that be an issue
13:13:43 <Ralith> what am I missing? ghc-mod advertises support for stack projects as of 5.3
13:13:46 <montanonic> There was a way to get it to work though, but I've since decided the troubleshooting wasn't worth it when GHCi gives me everything I need.
13:13:55 <Ralith> do you remember what the way was?
13:14:03 <kadoban> Ralith: ghc-mod is a pain in the ass to keep working ‚Ä¶ I kind of gave up. I have a new solution just based on getting the errors from 'stack build' and using ghci for checking types and whatever. Also typed holes help.
13:14:22 <kadoban> I'd probably just wait until haskell-ide-engine becomes a thing.
13:14:38 <Ralith> I'm *this* close to having the nice emacs integration working :/
13:14:41 <montanonic> Ralith: I can try to find the resource, but I agree with kadoban.
13:14:55 <montanonic> Ralith: Ah, I used Atom. I'd have no idea for emacs.
13:14:56 <Ralith> I'd appreciate it
13:15:05 <Ralith> the specifics of emacs are not relevant
13:15:09 <Ralith> the problem is with ghc-mod
13:15:22 <dustmote> do check out ghcid - it sits in your console with it's own ghci session and does `:r` to get errors when files change.. it also reformats errors nicely
13:15:25 <montanonic> Ralith: the method was specific to atom, I `stack installed` ghc-mod and fiddled with Atom settings
13:15:35 <Ralith> I am sure I can work out how to do something equivalent
13:15:43 <Ralith> if you can find the documentation I'd appreciate it
13:15:44 <montanonic> I'll send it to you in any case.
13:16:03 <Ralith> dustmote: my console workflow is fine, I'm trying to get editor integration working
13:16:40 <montanonic> Ralith: https://git.gnu.io/snowdrift/snowdrift/blob/master/TEXTEDITORS.md
13:16:42 <dustmote> ah ok. just thought you wanted something responses
13:16:45 <dustmote> responsive*
13:16:53 <montanonic> Ralith: ghc-mod info is under the Atom heading
13:17:50 <Ralith> ah, I just had to nuke dist/
13:17:51 <Ralith> thanks!
13:18:00 <montanonic> Ralith: oh, badass; np
13:18:05 <dustmote> lol. excellent
13:18:39 <montanonic> Ralith: sorry for not sending it immediately; glad it helped
13:19:00 <dustmote> > fail "foo" :: Maybe Int
13:19:01 <lambdabot>  Nothing
13:19:11 <dustmote> > fail "foo" :: Either String Int
13:19:13 <lambdabot>  *Exception: foo
13:19:16 <dustmote> :'(
13:24:28 <dustmote> is there a monadic way to represent failure that works in all cases? it seems like this behavior of `Either` says "no" and "we don't like `fail`"
13:26:34 <dustmote> or maybe, a different class -- not monad but MonadZero or smth..
13:26:52 <davean> dustmote: note that you end up with a problem if you try to use fail to generate Left here
13:27:07 <davean> dustmote: consider trying to impliment that for a moment
13:30:12 <Cale> dustmote: For any e, Either e is a monad. Does that count as monadic?
13:30:48 <Cale> dustmote: Indeed, don't use fail
13:31:04 <Cale> Not all monads have some natural notion of failure.
13:31:18 <Cale> (consider the Identity monad, or State s)
13:31:46 <Cale> fail really ought not to be part of the Monad class, it's a historical mistake that it is
13:32:07 <Cale> But it's getting separated out into its own class soon.
13:32:26 <Cale> (at which point it will be more recommendable)
13:34:34 <dustmote> I see.. `fail :: String -> m a` doesn't work with `instance (Either e) where ...` because the e would have to match String or somesuch..
13:35:56 * hackagebot judy 0.3.0 - Fast, scalable, mutable dynamic arrays, maps and hashes  https://hackage.haskell.org/package/judy-0.3.0 (MarkWotton)
13:40:56 * hackagebot hakyll-filestore 0.1.0 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.0 (aergus)
13:49:56 <Nublet> yo
13:55:29 <geekosaur> David5, for what it's worth, I didn't see anything obvious and all I can think of is that it wanted to use cpp and couldn't find it. (is build-essential installed?) you might ask on stackoverflow but include a full build log (stack clean; stack build -v)
13:56:17 <Nublet> Hey guys I was wondering, is there a tool that allows you to see the thunk evaluation process when pattern matching?
13:56:52 <dmj`> Nublet: http://felsin9.de/nnis/ghc-vis/#basic-usage
13:58:04 <Nublet> Thanks dmj
14:03:42 <cstrahan> Hey, any Cabal devs here? We have a question over in #ghcjs trying to figure out if cabal-install or ghcjs is at fault for a recent build problem.
14:05:00 <geekosaur> #ghc might work better
14:05:16 <hexagoxel> or #hackage
14:05:33 <cstrahan> geekosaur: Thanks - figured there had to be a better channel.
14:37:57 <stasiana> Any recommendations on a simple package that I can read the source code of that uses GHC.Generics to populate a record type?
14:38:48 <Cale> stasiana: bgamari answered you in #ghc, but you'd left already
14:38:57 <Cale> <bgamari> stasiana, perhaps distributive?
14:39:21 <glguy> stasiana: If you don't find one, let us know what it is you want to be able to do
14:39:37 <stasiana> Cale: Thanks. My client crashed and I realized that #haskell might be a better place to ask.
14:40:54 <stasiana> glguy: I'm trying to learn how to populate a record if I've got a list of field names and values. For example, if I have [("a", 111), ("b", "a string")] and I want to populate a record that has an Int and a String parameter.
14:42:41 <stasiana> Cale: Would distributive have relevant code for what I want to do, do you think?
14:42:43 <Cale> stasiana: That list is ill-typed
14:42:54 <Cale> I don't think so, given that description.
14:43:38 <lpaste> glguy pasted ‚Äúfor stasiana‚Äù at http://lpaste.net/152706
14:43:39 <stasiana> Cale: Yeah sorry, [("a", "123"), ("b", "string")]. I'd like the code to try to convert types if possible, e.g. from String to Int.
14:43:53 <Cale> hmm
14:43:54 <stasiana> Cale: I know aeson does all of this and I tried reading that, but it was beyond me.
14:43:55 <glguy> stasiana: You'll have something like that
14:44:23 <glguy> stasiana: but instead of putting the field name into the record directly you'd use it to look up from your value map
14:44:33 <glguy> you'll need a sum type of all the kinds of field syou support
14:44:45 <glguy> [("a", Int 10), ("b", String "twenty")]
14:45:06 <stasiana> Yes, I can see that.
14:45:22 <glguy> You'll need a little extra machinery to check that the value you have for that field has the right type, but that'll just be an extra typeclass
14:45:58 * hackagebot HStringTemplate 0.8.5 - StringTemplate implementation in Haskell.  https://hackage.haskell.org/package/HStringTemplate-0.8.5 (SterlingClover)
14:46:32 <stasiana> glguy: That's great. Thanks. I'm going to spend some time to digest that.
14:47:30 <Cale> You might be able to write something like:  parseFoo :: [(String, Value)] -> Maybe Foo; parseFoo xs = do Int n <- lookup "a" xs; String s <- lookup "b" xs; return Foo { a = n, b = s }
14:47:53 <Cale> If the type Value is defined something like   data Value = Int Int | String String | ...
14:48:32 <Cale> Pattern match failure in a do-block for the Maybe monad results in Nothing, so it might be a compact way for you to handle all the possible failures.
14:48:43 <Cale> Of course, if you want better messages, you'll have to do something more detailed.
14:49:52 <Cale> If the lists are at all long, you might want to switch from using lists to Data.Map as well.
14:51:04 <lpaste> glguy annotated ‚Äúfor stasiana‚Äù with ‚Äúusing a map for initial values‚Äù at http://lpaste.net/152706#a152708
14:51:08 <Gurkenglas> Requesting "Prism' s a -> s -> Either s a". Like, snd . (uncurry prism)^-1
14:52:28 <Cale> glguy: haha
14:52:39 <Cale> Possibly a bit overkill :)
14:53:01 <Cale> (but nice)
14:53:25 <glguy> If the question is how to do it with Generics I don't know that there's a much simpler solution
14:53:36 <Cale> Oh, sure
14:54:07 <shachaf> Gurkenglas: You should request Prism s t a b -> s -> Either t a instead.
14:54:38 <glguy> ?type matching
14:54:39 <lambdabot> APrism s t a b -> s -> Either t a
14:54:51 <anks> Hi, ive got a problem with Pipes, I have a [(SomeTag, [Record])] list and i want to pipe elements out to different files depending on the value of SomeTag for each group of records. How should i approach this?
14:55:00 <ReinH> TIL that there is a language called Curry. Neat.
14:56:11 <Gurkenglas> That's not the fully generalized type signature either, so what does it matter? Hoogle can't generalize by a single level.
14:56:11 <anks> (to stay at maximum efficiency)
14:56:35 <ReinH> In which you can write things like: last xs | ys ++ [x] =:= xs = x where x, ys free
14:57:55 <Cale> anks: Is that really a question about Pipes?
14:59:00 <Cale> anks: I would tend to just do that as a  forM_ xs $ \(tag,record) -> do ... whatever file I/O is appropriate ...
14:59:28 <dmj`> anks: to be clear, you want to append the information in [Record] to the end of a file?
15:00:32 <Gurkenglas> Note that "foo xs = forM_ xs $ asd dsa" can be replaced by "foo = mapM_ $ asd dsa"
15:00:33 <anks> No, it will overwrite
15:01:20 <anks> If I'm not gaining anything in terms of efficiency, I'd go without Pipes
15:01:29 <anks> ill*
15:08:38 <stasiana> glguy:Thanks for the sample code. Making more sense now. In the code, the types of the record fields are inferred from the data being passed in (via Value). If I wanted to introspect the value of the fields from the Rep of the record itself, is that straightforward?
15:09:05 <stasiana> glguy: Oops I meant types of the fields from the Rep of the record.
15:19:41 <glguy> stasiana: In that code the types of the record fields are not inferred from the Value being passed in
15:20:05 <glguy> they are inferred from the type of the record field. If you passed the wrong Value in it wouldn't match and the whole thing would return Nothing
15:20:41 <glguy> The FromValue instance used is determined by the type of the field being populated
15:21:01 <glguy> if the chosen instance doesn't match the Value provided fromValue returns Nothing
15:43:17 <dedgrant> If I am in a situation with GHC where "Variable `a` occurs more often than in the instance head" what sort of transformations are there to consider to prove to GHC that instances converge? (More specific motivation here: http://codepad.org/KYA6mwLv)
15:45:40 <glguy> dedgrant: You could use FlexibleContexts which would enable
15:45:42 <glguy> 03instance (T (G l), T as) 07=> T (C l as)
15:45:56 <dedgrant> Oh that's a good one
15:47:40 <dedgrant> glguy: Wonderful that's precisely what I'm looking for ta :)
15:49:28 <dedgrant> I think I may run into a further error when elaborating other features, but will see what happens..
15:56:27 <dedgrant> Heh yea, as soon as I stack on another type function I get into "Constraint is no smaller than the instance head" ofc :d ... it seems like some sort of internal constraints inferred for type families is needed to close the loop here. (I wonder if injectivity changes ghc-8 manage some of this?)
16:01:03 * hackagebot neat-interpolation 0.3.1.1 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.3.1.1 (NikitaVolkov)
16:01:05 * hackagebot distributed-process-lifted 0.2.0.0 - monad-control style typeclass and transformer instances for Process monad.  https://hackage.haskell.org/package/distributed-process-lifted-0.2.0.0 (jeremyjh)
16:06:03 * hackagebot filtrable 0.1.0.4 - Class of filtrable containers  https://hackage.haskell.org/package/filtrable-0.1.0.4 (MatthewFarkasDyck)
16:11:04 * hackagebot mappy 0.1.3.1 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.3.1 (mjgpy3)
16:12:28 <dedgrant> glguy: Take two: http://codepad.org/8Q5Cx0mn  ... need to mull this over a bit
16:14:39 <dedgrant> The magic ingredient here (why I'm pursuing this whackiness) is to try and get record notation of the form (["foo", 3] :: ['Name, 'Age])
16:16:27 <dedgrant> Sorry, correction: The magic ingredient here is type family F, and I'm pursuing this whakiness to... etc.
16:18:12 <lwm> anyone got any TemplateHaskell chops? I don't ... I have a function that is String -> [String] -> Expq
16:18:31 <lwm> and I have a function that is String -> IO [String]
16:18:56 <lwm> and I'd like to chain the latter into the former
16:19:08 <lwm> String -> (my IO function) -> ExpQ
16:26:24 <pavonia> lwm: You want to pass the result of the second function as parameter to the first one?
16:27:52 <lwm> pavonia: yes, that sounds right
16:28:07 <lwm> but in magic compile time TH mode
16:29:00 <hexagoxel> Q is MonadIO, and ExpQ is Q Exp (iirc)
16:29:02 <pavonia> You can use runIO
16:29:02 <lambda-11235> Can GHC output the compiled Core code of a haskell program? Does core have a external representation?
16:31:07 <hexagoxel> ah indeed, runIO not liftIO
16:31:16 <hexagoxel> TH is not that transparent :D
16:32:28 <lwm> haha, tell me about it ... I just want to hack something together here
16:32:31 <lwm> runIO then ....
16:33:24 <lwm> oh wait, I think it works!
16:33:40 <Lokathor> so are (a -> a) functions a semigroup?
16:34:16 <Lokathor> rather, i don't see an instance for them, but could they be?
16:34:30 <lwm> something like - $((outerfunc x)) =<< (runIO $ myIOf y)
16:34:48 <lwm> pavonia: thanks
16:35:29 <hexagoxel> lambda-11235: there are ghc options to dump the core during compilation, if that is what you are asking.
16:42:33 <hexagoxel> (e.g. -ddump-prep)
16:50:52 <anks> is there a function, similar in goal to groupBy, but merging found groups ?
16:51:18 <anks> (and preserving the order of samples)
16:53:25 <mauke> map ... . groupBy ...?
16:56:09 <KaneTW> yeah
16:56:27 <KaneTW> :t \f xs -> map f . groupBy xs
16:56:28 <lambdabot> ([a] -> b) -> (a -> a -> Bool) -> [a] -> [b]
16:56:36 <KaneTW> eh
16:56:42 <KaneTW> :t \f -> map f . groupBy 
16:56:43 <lambdabot>     Couldn't match type ‚Äò[a1] -> [[a1]]‚Äô with ‚Äò[a]‚Äô
16:56:43 <lambdabot>     Expected type: (a1 -> a1 -> Bool) -> [a]
16:56:43 <lambdabot>       Actual type: (a1 -> a1 -> Bool) -> [a1] -> [[a1]]
16:56:49 <KaneTW> well something like that
16:56:58 <KaneTW> :t \f eq -> map f . groupBy eq
16:56:59 <lambdabot> ([a] -> b) -> (a -> a -> Bool) -> [a] -> [b]
16:57:08 <KaneTW> yeah that looks good
16:57:43 <anks> Ive just come up with  groupBy .. . sortBy ..
16:58:24 <anks> Thanks, anyway :)
17:00:19 <shapr> @admins
17:00:19 <lambdabot> Plugin `system' failed with: user error (invalid usage)
17:00:21 <shapr> aw
17:03:30 <montanonic> https://hackage.haskell.org/package/free-4.12.4 <--- what do the "Final" modules mean. They say they are the "Final encoding" of Applicative/Alternative frees, but I really don't understand what they are for.
17:07:21 <peddie> montanonic: "final encoding" usually means you're representing a structure with functions or type class methods rather than data constructors(the "initial encoding").  it's usually an engineering tradeoff betweeen the two; for example appending to a finally-encoded tree structure can be O(1), whereas appending to the initially-encoded equivalent is usually linear in the depth of the tree
17:08:24 <montanonic> peddie: I see, so it does come down to efficiency. Is the assumption that the initial encoding is more tractable to write? As in, it's a more obvious/straightforward engineering effort, and the final encoding is informed by that?
17:08:46 <peddie> montanonic: there are other tradeoffs as well
17:08:58 <montanonic> peddie: is there a resource I can look into to understand more about this?
17:09:43 <peddie> montanonic: http://okmij.org/ftp/tagless-final/index.html http://comonad.com/reader/2011/free-monads-for-less/
17:10:03 <peddie> montanonic: those two and the papers they link to are where I learned about this stuff
17:10:12 <montanonic> peddie: oh cool, I was going to get to that second article sometime today anyways; didn't understand it was related. Thanks again peddie!
17:10:50 <peddie> montanonic: good luck!  I thought it was pretty hard stuff and it took me a while to get my head around it :)
17:11:22 <montanonic> peddie: thankfully I have another article explaining codensity, and have spent 2.5 days studying the free monad, so here's for hoping :)
17:11:24 <peddie> so don't feel bad if it takes a bit of study and coding
17:11:43 <montanonic> Not at all! That's the only way to really learn anything anyways :)
17:12:21 <peddie> montanonic: I gave an introductory talk about this stuff at the FP users' group where I live, but the video is not yet online
17:12:51 <montanonic> peddie: oh badass; well if you remember, feel free to ping me when it goes online
17:14:00 <bitemyapp> montanonic: I've got a talk I can link you in the meantime
17:14:09 <montanonic> bitemyapp: go for it! :)
17:14:17 <bitemyapp> montanonic: but a lot of the original motivation was the ability to express what GADTs allow without resorting to the GADTs extension
17:14:33 <bitemyapp> montanonic: compare/contrast typeclass syntax, GADT syntax, and ordinary datatypes.
17:14:47 <montanonic> I literally have a haskellforall article on building GADTs without GADTs right now
17:14:50 <montanonic> so sounds good to me
17:16:03 <bitemyapp> montanonic: http://kievfprog.net/talks/oleksandr-manzyuk.pdf
17:16:36 <zxtx> Hi, is there a programmatic way to get at the haddock documentation associated with a function
17:16:39 <bitemyapp> montanonic: the important thing to realize is that finally tagless started focused on the GADTs thing, but the extensibility fell out of it.
17:16:58 <montanonic> bitemyapp: that's helpful; than you for the context + resource
17:17:00 <bitemyapp> montanonic: the weird thing is that you don't really need typeclasses to do what finally tagless does. It just happens to be a convenient encoding.
17:17:06 <montanonic> thank*
17:17:14 <bitemyapp> where convenient - it supplies the dictionaries for you.
17:17:31 <montanonic> right, as opposed to having to pass them around manually
17:19:01 <bitemyapp> montanonic: because the key thing to realize is that you can already extend datatypes - with nesting.
17:19:22 <bitemyapp> montanonic: it's a bit trivial, but I demonstrate this here: http://bitemyapp.com/posts/2014-12-03-why-are-types-useful.html
17:19:52 <montanonic> bitemyapp: added to the queue; thank you again
17:19:59 <peddie> bitemyapp: this talk is very clear, thanks for sharing it
17:20:11 <bitemyapp> yar, I'll write it up into a brief tutorial post on my blog at some point
17:20:15 <bitemyapp> probably after we do the next release.
17:20:37 <montanonic> peddie: https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/ he also did a write-up
17:20:39 <bitemyapp> but yeah, most presentations of tagless final elide the original context/intent which I think is unfortunate and makes it seem harder or more magical than is necessary.
17:21:21 <peddie> bitemyapp: I agree!
17:21:26 <montanonic> as always bitemyapp, thanks for helping to present things in the more cogent order
17:21:44 <bitemyapp> montanonic: :)
17:21:53 * bitemyapp returns to mucking about with ansible
17:32:14 <zxtx> Hi, is there a programmatic way to get at the haddock documentation associated with a function, I'm trying to make some tooling around that
17:43:54 <KaneTW> zxtx: i don't think so, not unless you invoke the haddock api
17:44:27 <KaneTW> docstrings might be in the interface file but i'm very unsure of that
17:44:28 <zxtx> KaneTW, I'm ok invoking the haddock api
17:44:42 <zxtx> I just can't figure out how to get the strings out of the Interface datatype
17:44:46 <zxtx> its really imposing
17:44:50 <KaneTW> sec
17:45:02 <zxtx> I'm referring to this: https://hackage.haskell.org/package/haddock-api-2.16.1/docs/Documentation-Haddock.html
17:47:32 <KaneTW> which docstrings do you want
17:47:39 <KaneTW> for each exported item?
17:48:37 <KaneTW> just get ifaceExportItems and then pattern-match on ExportDecl
17:54:52 <zxtx> KaneTW, yep exported items
17:55:20 <zxtx> can you go into slightly more detail about what I would pattern match in ExportDecl?
17:56:18 <zxtx> I'm having trouble getting out stuff I can print to the screen
17:59:36 <KaneTW> um sec
18:00:35 <KaneTW> you'll have to pull in the GHC API it seems
18:01:07 <KaneTW> https://github.com/haskell/haddock/blob/master/haddock-api/src/Haddock/Backends/Xhtml/Decl.hs for an example of how to treat those
18:03:07 <xnil> is there a comprehensive tutorial for parsec meant for absolute beginners who just know basic haskell?
18:04:14 <dmj`> xnil: there is the write yourself a scheme in 48 hours
18:04:26 <xnil> that should do the trick!
18:04:30 <dmj`> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
18:04:41 <dmj`> I don't know if I'd call it "comprehensive"
18:05:34 <xnil> comprehensive in the sense that it covers the bases in getting one started
18:05:43 <xnil> not the other sense, that it covers advanced topics
18:05:50 <zxtx> KaneTW, eek this looks rough!
18:05:55 <dmj`> xnil: real world haskell also has a section on parsing
18:05:57 <dmj`> xnil: http://book.realworldhaskell.org/read/using-parsec.html
18:45:23 <Ralith> Is there a good compliant HTML5 parser that constructs a tree (vs. tagsoup just putting out a token stream)?
18:53:53 <xnil> dmj`: I'm not sure I understand the point of Parsec.SourceName from reading any of those examples.
18:54:09 <xnil> Is it supposed to be the name of the source file you're reading from or something?
18:54:43 <pavonia> Ralith: tagsoup can also build a tree structure from that tag list
18:55:23 <Ralith> pavonia: ...how?
18:56:03 <pavonia> Ralith: There's then Text.HTML.TagSoup.Tree module
18:56:07 <pavonia> *the
18:56:11 <Ralith> oh god dammit
18:56:16 <Ralith> thanks!
18:57:13 <dfeuer> xnil, I think that's right.
18:58:56 <xnil> excellent! thanks, dfeuer 
19:15:39 <xnil> how do i run an executable produced from stack-build?
19:16:08 <xnil> or rather, how do i make stack-build produce the binary in the ./bin/ directory?
19:16:25 <dmj`> stack exec <executable-name> might work
19:16:36 <kurt11> If I have a function that uses recursion, how do I know if it's optimized recursion or not?
19:17:12 <xnil> that does, dmj`. thanks again.
19:23:05 <pavolzetor> Hi, after some thought it seems I have to rewrite my ray tracer in ISPC, but I would still like to keep the scene parsing in haskell
19:23:28 <pavolzetor> do I serialize the data and then pass pointer to it?
19:23:43 <pavolzetor> is there some automatic annotation which eases this step
19:24:09 <pavolzetor> for example I have data Vec = Vec Double Double Double which would automatically get serialized to 3 raw doubles
19:28:02 <pavolzetor> something similar to this https://www.reddit.com/r/haskell/comments/468r93/rust_haskell_software_rasterization_nbody/
19:28:07 <pavolzetor> but with much more complex data types
19:29:04 <pavolzetor> so it would nicely map into C structs
19:29:20 <dustmote_> kurt11: most tail-recursion optimization situations can be easily detected manually https://wiki.haskell.org/Tail_recursion
19:30:12 <dustmote_> kurt11: but basically, don't have stuff outside of the recursive call- your function should "end" with the recusive call `foo = 1 + foo` won't optimize because it'll still need to add 1 to the result of the recursive call
19:32:18 <dustmote_> pavolzetor: i'm not sure your question is clear.. it seems you're trying to use the haskell FFI?
19:33:35 <pavolzetor> dustmote_:
19:33:56 <pavolzetor> yes, I want to call some kernel for heavy computation and do all the management in haskell
19:34:34 <pavolzetor> and avoid doing too much work when converting the parsed data so there is some benefit to this
19:35:06 <pavolzetor> too much work means labor, not computation
19:35:57 <pavolzetor> so preferably some annotations for auto serialization
19:39:09 <dustmote_> pavolzetor: so in your ideal world, you'd get the data all set up in haskell and then just hand a pointer through the ffi to C/C++?
19:40:44 <dustmote_> Foreign.C.Types lets you deal with C/C++ primitives.. https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html
19:40:52 <dustmote_> not sure about structs
19:43:24 <dustmote_> pavolzetor: can you paste your struct somewhere? .. i think you'd use https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html to marshall into haskell
19:44:47 <pavolzetor> dustmote_: in ideal world it would be all in Haskell :), but yes, haskell would parse, linearize the scene graph, and then pass it to C
19:45:16 <pavolzetor> thanks, let me paste it
19:49:31 <pavolzetor> http://lpaste.net/152713
19:49:39 <pavolzetor> this is only one I want to support for start
19:49:49 <pavolzetor> camera is at origin and raster is fixed for now
19:51:14 <anohigisavay> hi. any hint on runtime metaprogramming?
19:51:32 <anohigisavay> how to implement this? readProp :: String -> String -> Value
19:52:17 <pavonia> What is Value?
19:53:32 <anohigisavay> pavonia: say a JSON value that can be one of String, Number, etc
19:53:43 <dmj`> anohigisavay: are the questions you asked related?
19:53:51 <Tendies> If i was to make a function  foo [a] = map makeSet (findN [a],fst a,snd a), in the process of mapping the function would all of the a's passed to map be resolved to the values of the current element being mapped to
19:54:33 <Tendies> where [a] is a set of pairs
19:54:41 <Tendies> list of pairs*
19:54:43 <anohigisavay> are they not? the arguments i pass to readProp is from a ByteString stream
19:55:10 <pavonia> anohigisavay: I'mnot sure what exactly you are asking for. If you want to parse strings into JSON values, have a look at the Aeson package
19:55:18 <pavolzetor> dustmote_:  I have to run, I will experiment with something simple and see, preferably I would even like to use HEC for task parallelism. Thanks again
19:56:11 <dmj`> anohigisavay: what you're doing sounds like parsing data, meta programming is treating the code you're working with as data
19:56:42 <glguy_> Tendies: You might have to try rephrasing your question, it isn't clear to me what you're asking
19:57:31 <dmj`> Tendies: can you make a paste of an example, [a] in your current example is a partial pattern match, it sounds like you want to rename it (as :: [(a,b)]) 
19:57:50 <anohigisavay> http://lpaste.net/152715
19:58:37 <dmj`> @typ toDyn
19:58:38 <lambdabot> Typeable a => a -> Dynamic
19:58:44 <dmj`> @def data X = X { a :: Int, b :: String }
19:58:45 <lambdabot>  Defined.
19:58:58 <dmj`> @typ toDyn (X 1 mempty)
19:58:59 <lambdabot> Dynamic
19:59:07 <Tendies> i dont quite know how to formulate another example, and the code my question comes from doesnt quite work right now
19:59:08 <dmj`> > toDyn (X 1 mempty)
19:59:10 <lambdabot>  <<X>>
19:59:23 <dmj`> Tendies: that's fine, you should still paste it
19:59:28 <dmj`> @where paste
19:59:28 <lambdabot> Haskell pastebin: http://lpaste.net/
19:59:53 <Tendies> ok ill ask for help on my error and maybe that will end up answering it.. hopefully
20:01:24 <Tendies> http://lpaste.net/152716 if it might help, im trying to do the list building part of the chinese remainder theorem
20:01:38 <dmj`> anohigisavay: it's not clear what you want to do really
20:03:01 <glguy_> Tendies: Like dmj` mentioned earlier, "test [a] = ..." This means that it only matches single element lists and that the first (and only) element of that single element list shall be named 'a'
20:03:37 <glguy_> If you want that function to work on lists that have zero elements or more than 1 element you just want "test a = ..." or "test as = ..." etc
20:03:39 <Tendies> so how would i designate a list of pairs of indefinite length
20:04:07 <glguy> Just with a variable
20:04:40 <anohigisavay> dmj`: k nvm. i think i'll just refer to the source code of Aeson
20:04:40 <Tendies> okay, and now i need to get into each pair and take the fst and snd of those pairs to pass in with map
20:06:20 <glguy> Tendies: this type signature doesn't mention any type variable a to the right of the=>
20:06:22 <dmj`> anohigisavay: import Data.Aeson; data X = X String Int deriving (Generic, Show); instance ToJSON X; instance ToJSON X; main = print ((decode (encode (X "a" 0)) == Just (X "a" 0)))
20:06:23 <glguy> makeSet :: Integral a => (Integer,Integer,Integer) -> [Integer]
20:06:38 <glguy> So you can remove the Integral a part
20:06:48 <dmj`> anohigisavay: instance FromJSON X*
20:07:13 <dmj`> anohigisavay: you'll need to add the {-# LANGUAGE DeriveGeneric #-} pragma
20:07:19 <glguy> Tendies: that a is not the same one as the value a in the arguments from the line below
20:07:28 <Tendies> oh man it gave me two more errors
20:07:36 <Tendies> i know that
20:07:55 <Tendies> i just happened to pick a below, possibly confusingly :O
20:08:25 <dmj`> anohigisavay: manually it would look like instance ToJSON X where toJSON (X a b) = object [ "a" .= a, "b" .= c]; instance FromJSON X where parseJSON = withObject "X" $ \o -> X <$> o .: "a" <*> x .: "b";
20:08:34 <dmj`> s/x/o
20:08:57 <dmj`> anohigisavay: this assumes your type has two fields named "a" and "b"
20:09:12 <dmj`> "b" .= b**
20:09:48 <glguy_> Tendies: I just figured out what your code was trying to do, I think: test xs = [ makeSet (findN xs, a, b) | (a,b) <- xs ]
20:10:10 <glguy_> or, = map (\(a,b) -> makeSet (findN xs, a, b)) xs
20:10:31 <glguy_> (and you'd probably want to name the value   findN xs
20:11:17 * hackagebot proxied 0.1 - Make functions consume Proxy instead of undefined  https://hackage.haskell.org/package/proxied-0.1 (ryanglscott)
20:12:10 <hackrilege> hi, i have a nasty error while trying to derive a show instane for a reursive datatype
20:12:17 <hackrilege> reursive*
20:12:23 <hackrilege> here is the paste; http://lpaste.net/152717
20:12:32 <Tendies> welp glguy_ that is exactly what i wanted to do
20:12:51 <hackrilege> recursive* instance*
20:13:04 <dmj`> hackrilege: can you paste the error too :]
20:13:12 <Tendies> could you try to explain either where i went wrong or how you thought through the list comp you wrote?
20:13:19 <hackrilege> its in a comment at the top?
20:13:37 <hackrilege> oh, check the annotation...
20:14:52 <glguy> Tendies, you were applying 'map makeSet' to a 3-tuple, but it expects to be applied to a list
20:14:57 <Cale> hackrilege: Looks like a totally sensible error
20:15:06 <hackrilege> i dont understand it
20:15:17 <Tendies> glguy: doesnt the type signiture of makeSet expect a 3-tuple?
20:15:22 <Tendies> signature
20:15:34 <hackrilege> the monadic container and the contents have show instaces
20:15:51 <glguy> Tendies, it does, but you aren't applying makeSet to anything
20:15:51 <Cale> hackrilege: You have an instance of Show for a, and an instance of Show for m a, but not an instance of Show for m (Molecule m a), and yet on line 17, a :: m (Molecule m a), and you're applying show a
20:16:07 <hackrilege> but how could i write shich a constraint as it requires before i write the show instance?
20:16:23 <dmj`> hackrilege: oh, see it now, was expecting a longer message
20:16:25 <glguy> Tendies, it's the type of map that you need to focus on
20:16:28 <Cale> hackrilege: Try it
20:16:59 <hackrilege> it should use the monadic show to direct the show to the molecule until it hits the base case, the prescribed show Atom
20:17:01 <Tendies> oh someone said wrap the list comp in a function then use fmap, forgot the fmap part
20:17:08 <Tendies> would that have changed it?
20:17:09 <Cale> instance (Show a, Show (m (Molecule m a))) => Show (Molecule m a) where ...
20:17:23 <hackrilege> ok ill try, should that work?
20:17:44 <glguy> Show1 is worth thinking about, too
20:18:47 <hackrilege> could i fix it with a forall statement?
20:19:03 <Cale> nope
20:19:09 <hackrilege> thanks
20:19:30 <Cale> There is a universal quantifier for type classes in the constraints package iirc.
20:19:43 <jasonkuhrt> Is the Applicative instance for Function esoteric, or is it just me?
20:20:03 <Cale> jasonkuhrt: I wouldn't call it esoteric, but it is a little uncommon that it sees use.
20:20:17 <Cale> It can be quite handy sometimes though
20:20:18 <hackrilege> Cale; variable m occurs more than once within the instance head
20:20:36 <Cale> hackrilege: Does it tell you to turn on an extension?
20:20:48 <hackrilege> UndecidableInstances
20:21:03 <hackrilege> ominous...
20:21:43 <hackrilege> this indicates to me something is wrong
20:22:09 <jasonkuhrt> Cale: I would be curious to see use-cases... I'll need to get more experience writing apps in Haskell
20:22:26 <jasonkuhrt> The definition is `g f = \x -> g x (f x)`. It will take a creative leap to see this pattern in the wild
20:22:32 <Cale> hackrilege: Yeah, I guess you really do need UndecidableInstances for that then.
20:23:18 <Cale> jasonkuhrt: Well, that function has quite a back-story
20:23:28 <jasonkuhrt> Oh?
20:23:31 <Cale> jasonkuhrt: It's the S combinator from the SKI calculus
20:23:44 <hackrilege> now it kicks up a fuss trying > show (Atom (0::Double))
20:23:55 <hackrilege> it says it cant infer the Monad
20:24:09 <Cale> hackrilege: Right, because it can't
20:24:23 <hackrilege> yeah but this totally sucks
20:24:30 <Cale> show (Atom 3 :: Molecule [] Double)
20:24:35 <Cale> try that instead
20:24:37 <hackrilege> thanks!
20:24:40 <jasonkuhrt> Cale: Interesting! Good to know... I can follow up on that information to learn more
20:24:55 <Cale> jasonkuhrt: That won't necessarily lead you to practical consequences though
20:25:24 <jasonkuhrt> Cale: More information/context can't hurt I guess
20:25:44 <jasonkuhrt> bitemyapp: Maybe note this in your book? I didn't see it mentioned in the Applicative chapter
20:26:29 <Cale> jasonkuhrt: The practical consequences are more just what you'd expect -- when you want to distribute some "environment" parameter to a bunch of parts of a computation
20:26:50 <Cale> jasonkuhrt: i.e. this thing is just the Reader instance, with less boilerplate
20:27:42 <jasonkuhrt> Hm, ok! About to hit the Monad chapter soon so I can start to sink my teeth into this points more soon I hope
20:27:51 <Cale> > liftA2 (+) (*10) (*100) 5
20:27:53 <lambdabot>  550
20:28:03 <hackrilege> Cale, i dont like how when writing the Monoid instance i can specify the Monoid constrain required to write Atom mempty, but that for the MonadPlus instance the Kind *->* requirement prevents the Monoid a constraint. since my datastructure is recursive like free, shouldnt it be possible?
20:28:14 <Cale> ^^ bad example, but you can probably guess some cases where that kind of thing is useful
20:28:47 <Cale> hackrilege: I don't understand the question.
20:28:58 <hackrilege> i am forced to write Polymer mzero
20:29:13 <hackrilege> as the Monoid Type is left unprescribed
20:29:36 <hackrilege> check the difference between my mempty and mzero implementations
20:29:44 <hackrilege> i would expect them to be the same
20:29:54 <Cale> I wouldn't expect them to be the same...
20:30:12 <hackrilege> ok, because of the reason i jest described right?
20:30:16 <Cale> Pretty much
20:30:32 <jasonkuhrt> Cale: I don't even feel that comfortable reading that example and tracing the data flow yet.
20:30:44 <Cale> jasonkuhrt: Well, stare at the result :)
20:30:51 <Cale> jasonkuhrt: It's 5 * 100 + 5 * 10
20:31:03 <Cale> Or, well, I should have written that the other way around
20:31:16 <jasonkuhrt> Cale: Most other Applicative instances I found rather straight forward, but I have to think considerably harder for the function one, I just need to build up some muscle memory for it I think
20:31:23 <Cale> liftA2 (+) will add the results of two functions
20:31:51 <Cale> > liftA2 (++) id reverse "palindrome"
20:31:53 <lambdabot>  "palindromeemordnilap"
20:31:57 <hackrilege> so this is messing up my plan, im not sure how to rectify the confusion. im not sure how this situation will arise to cause the two distinct behaviours
20:32:37 <Cale> hackrilege: You seem to have a lot of MonadPlus constraints on things which aren't needed...
20:32:46 <hackrilege> you said that last time
20:32:58 <hackrilege> sorry i should do that, but its ok for now
20:33:02 <Cale> It might be confusing things a bit in your head :)
20:33:30 <Cale> I don't really know for sure, but maybe it'll be clearer what's going on if the constraints are tight.
20:33:34 <hackrilege> its cool, its just an over constraint, its sufficiant which is most important
20:34:19 <hackrilege> and its always satisfied since i write a MonadPlus constraint which eventually requires it
20:34:42 <Cale> hackrilege: Well, okay, so we *really* have  instance (Monad m, Monoid a) => Monoid (Molecule m a), right?
20:34:50 <Cale> We're not using the MonadPlus structure there.
20:34:59 <hackrilege> it uses mplus
20:35:14 <Cale> oh, you're right, that's interesting
20:35:26 <Cale> Wait, why?
20:35:30 <Cale> :)
20:35:46 <hackrilege> because the internal structure is a monadPlus
20:35:57 <hackrilege> here ill put the compiling code and you can try it its fun
20:36:00 <Cale> Yeah, but you're using mempty
20:36:09 <Cale> which has nothing to do with mplus
20:36:32 <Cale> You have two monoid structures, and you're using the unit from one, and the multiplication from the other
20:36:36 <Cale> which is weird
20:36:41 <hackrilege> http://lpaste.net/152721
20:36:44 <Cale> (and probably wrong a lot of the time)
20:36:50 <hackrilege> no
20:37:06 <hackrilege> seriously i have been talking about this for ages!
20:37:17 <hackrilege> anyway yes, one direction for join is sufficient
20:37:21 <Cale> what?
20:37:25 <Cale> join?
20:37:26 <hackrilege> no bimonads that was a misnomer sorry
20:37:36 <hackrilege> (reference to earlier discussions)
20:37:41 <Cale> I'm talking about the mempty vs. mplus thing
20:37:46 <Cale> mempty and mplus don't go together
20:37:56 <Cale> It's mempty and mappend
20:38:01 <hackrilege> via fold plus makes join for Free
20:38:01 <Cale> vs. mzero and mplus
20:38:08 <hackrilege> mplus*
20:38:29 <hackrilege> its free and it contains itself and its a Monoid and an Mplus
20:38:35 <hackrilege> and its killing my mind
20:38:54 <Cale> Your Monoid instance would make a lot more sense if it was just  mempty = return mempty; mappend = liftA2 mappend
20:39:00 <hackrilege> a foldable container of Monoids is a Monad
20:39:15 <Cale> hackrilege: That seems false.
20:39:16 * Tendies 's brain explodes
20:39:40 <hackrilege> join = fold mappend mempty
20:39:47 <hackrilege> :t fold
20:39:48 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:39:53 <hackrilege> sorry
20:40:01 <hackrilege> join = fmap fold
20:40:13 <Cale> :t fmap fold
20:40:15 <lambdabot> (Functor f, Foldable t, Monoid b) => f (t b) -> f b
20:40:22 <hackrilege> :t join
20:40:23 <lambdabot> Monad m => m (m a) -> m a
20:40:30 <Cale> You have a Monoid b constraint that you can't discharge though
20:40:55 <hackrilege> whatever that means, probably the crux...
20:41:03 <Cale> A Monad has to be a type constructor which can be applied to *all* types, not just the ones which happen to have a Monoid instance.
20:42:05 <hackrilege> but this type constructor does produce a Monoid
20:42:14 <Cale> If you knew that all types had monoid instances, then the notion of what a monad was would be quite different.
20:42:34 <hackrilege> and it contains its self so it does certainly contain Monoids
20:42:39 <Cale> (It would be a lot more like the notion of a monad on the category of monoids, rather than a monad on the category of sets)
20:43:10 <Cale> But Monad in Haskell refers to monads on the category of Haskell types and functions only.
20:43:43 <Cale> Not the subcategory of types with monoid instances and the Haskell-definable monoid homomorphisms between them or something.
20:44:28 <hackrilege> a Datatype which is a Monad of Monoids is a Monoid, as it is Free it cointains only itself, so containing Monoids
20:44:38 <Cale> But that's a lot of high-brow talk for something which is really quite simple: when you apply (>>=), you're allowed to apply it even if you don't know that there are any monoid instances around
20:44:47 <Cale> So we can write things like...
20:45:00 <hackrilege> hey are you listening to me?
20:45:08 <hackrilege> i know what you mean...
20:45:25 <hackrilege> im confused about the circular argument arising from use of Free
20:45:32 <Cale> hm
20:46:14 <Cale> I don't really understand things the way that you've phrased them
20:46:18 <hackrilege> it "Should" be able to take a non Monoid, but it will struggle to since it provides this Monoid instance its self
20:46:33 <Cale> Hm?
20:47:00 <hackrilege> it contains its self (like Free) and it has a Monoid instance, so it will only ever contain Monoids
20:47:11 <Cale> fmap fold :: (Functor f, Foldable t, Monoid b) => f (t b) -> f b
20:47:16 <hackrilege> (perhaps Atom should not take a type parameter)
20:47:54 <Cale> So what happens when we try something like  join (x :: f (f NonMonoid))
20:48:02 <Cale> where NonMonoid is a type without a Monoid instance
20:48:25 <Cale> and f is our functor
20:49:33 <Cale> :t join
20:49:35 <lambdabot> Monad m => m (m a) -> m a
20:49:37 <hackrilege> the Monoid instance constraint will not be satisfied
20:49:43 <Cale> ^^ join is supposed to be able to work in this case
20:49:49 <Cale> But fmap fold doesn't.
20:50:07 <hackrilege> so i have a new structure?
20:50:20 <hackrilege> how do i correctly describe what i mean?
20:50:29 <hackrilege> do you understand what im trying to do?
20:50:34 <Cale> I haven't fully pieced through what you mean yet
20:50:56 <hackrilege> the source complies now...
20:51:00 <Cale> Maybe it would help to know what typical examples of m you're thinking about.
20:51:07 <hackrilege> ok
20:51:12 <hackrilege> consider a list of lists
20:51:15 <Cale> and where this will actually get used
20:51:23 <hackrilege> join map concat
20:51:32 <hackrilege> join = fold (++) []
20:51:41 <hackrilege> sorry
20:51:56 <hackrilege> join = map concat
20:52:11 <Tendies> is !! base 1 or base 0?
20:52:20 <Cale> hackrilege: join = concat
20:52:23 <FreeFull> Tendies: 0
20:52:24 <hackrilege> ok
20:52:39 <hackrilege> anyway join is in terms of fold
20:52:47 <Maxdamantus> 0 is the only sensible number to start counting from.
20:52:48 <FreeFull> Cale is right
20:53:19 <Cale> Maxdamantus: Except in cases when -2 makes more sense ;)
20:53:19 <Maxdamantus> Otherwise you end up with crazy systems like where 2016 is the 16th year of the 21st century.
20:53:34 <hackrilege> so because the internal lists are Monoids, they can be folded
20:53:38 <Maxdamantus> The 21st century being the one beginning in 2001.
20:53:39 <hackrilege> join = fold
20:53:47 <hackrilege> right?
20:54:03 <hackrilege> @src fold
20:54:03 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:54:06 <hackrilege> sry
20:54:32 <hackrilege> :t foldMap
20:54:33 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:54:51 <hackrilege> im floundering here help
20:55:31 <Cale> :t fold
20:55:32 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:55:39 <Cale> join = fold
20:55:53 <Cale> Would work here.
20:55:54 <hackrilege> ok perfect
20:56:03 <hackrilege> thats what im getting at with all this
20:56:09 <Maxdamantus> :t [join, concat, fold]
20:56:10 <lambdabot> [[[a]] -> [a]]
20:56:15 <hackrilege> so consider Free []
20:56:16 <Cale> heh
20:56:51 <hackrilege> and using foldFree
20:56:58 <Ralith> pavonia: is it known to be any good at it? I'm seeing some strange behavior...
20:58:02 <Cale> I'm not sure we need foldFree...
20:58:05 <Cale> hmm
20:58:09 <hackrilege> do you think i should lose the Type parameter on Atom?
20:58:32 <hackrilege> since the Monad can have one element...
20:58:45 <hackrilege> i guess it stops it being empty which is conceptually better
20:58:55 <Ralith> tagsoup seems to miss major parts of real-world html tree structures
20:59:00 <pavonia> Ralith: I haven't had any problems with it
20:59:00 <hackrilege> sorry nvm
20:59:28 <Ralith> pavonia: I'm getting a bunch of open/close tag pairs showing up as leaves instead and it's breaking my app
20:59:31 <Ralith> :/
20:59:39 <hackrilege> :t iterate join
20:59:40 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ m a
20:59:40 <lambdabot>     Expected type: m a -> m a
20:59:40 <lambdabot>       Actual type: m (m a) -> m a
21:00:14 <Cale> Ralith: oh? Doesn't it just spit the tags back at you exactly as they occur in the file?
21:00:20 <Maxdamantus> :t iterate Promise.prototype.then
21:00:21 <lambdabot> parse error on input ‚Äòthen‚Äô
21:00:21 <pavonia> Ralith: For a well-formed document?
21:00:37 <Ralith> pavonia: no, but that's the whole point of using a HTML5-compliant parser; my browser renders it fine
21:00:38 <FreeFull> :t iterate (join . return)
21:00:39 <lambdabot> Monad m => m a -> [m a]
21:00:46 <Ralith> Cale: I'm using the Tree submodule
21:00:54 <Cale> Ralith: ah
21:00:57 <geekosaur> browsers prove nothing re well-formed-ness
21:01:12 <Ralith> geekosaur: I did not claim otherwise.
21:01:19 <Cale> Ralith: Yeah, usually the point of using tagsoup is you have shitty HTML which is badly malformed and want to scrape things out of it anyway.
21:01:34 <Ralith> yes, and it's not doing as good a job as my browser does :P
21:01:45 <Cale> I've never really tried the tree stuff
21:01:50 <Ralith> I had hoped they'd be using fundementally equivalent algorithms
21:01:56 <hackrilege> supose i had a length of string and split it into a list of string segments, and did this repeatedly until i had lists of lists of infintesimal string sections, this would be considered a fixed point and no further division would take place, i then can fold up the bits to get the total length for example. for a treelike Monadic container, a more di
21:01:56 <hackrilege> verse behaviour is captured
21:01:56 <Ralith> but it seems not
21:02:17 <hackrilege> lists of lists of lists of .....
21:02:31 <Tendies> can i have some help thinking about how to write this function
21:03:00 <Tendies> have a list with n sublists, and i want to find the least element that is in all three
21:03:07 <Tendies> all n*
21:03:15 <Cale> Ralith: Usually I just use partitions to break the thing up into segments starting with tags that I'm looking for, and in a list comprehension or do-block for the list monad, keep chopping those up into smaller pieces until I've found what I'm after.
21:03:35 <Ralith> yeah, thta was my original plan but I got hopeful
21:03:36 <hackrilege> 3 sublists*
21:03:37 <Ralith> back to that I guess
21:03:40 <geekosaur> I was actually surprised to hear tagsoup had a tree module, because the point of tagsoup is that it ignores any tree structure on the grounds that it's probably completely wrong
21:03:55 * Clint chuckles.
21:04:03 <Ralith> geekosaur: well, HTML5 specifies tree construction
21:04:08 <geekosaur> yes
21:04:17 <Ralith> fairly robustly afaik
21:04:28 <Ralith> but not as good as browsers' quirks modes it would seem
21:04:41 <geekosaur> last I checked,random spot-checks of supposedly compliant html5 on actual web sites was not even remotely compliant
21:05:12 <geekosaur> their html generators just slap a lying html5 compatibility thing on the top
21:05:28 <Ralith> geekosaur: an "HTML5-compliant parser" is not a parser that rejects malformed HTML5 documents.
21:05:43 <Ralith> the HTML5 spec is very specific about how to make the best of malformed documents
21:07:00 <hackrilege> :t sequence (repeat (//))
21:07:02 <lambdabot> Ix i => Array i e -> [[(i, e)] -> Array i e]
21:07:41 <hackrilege> > [1,2,3] // [1,2]
21:07:42 <lambdabot>      Couldn't match expected type ‚ÄòArray i e‚Äô
21:07:43 <lambdabot>                  with actual type ‚Äò[Integer]‚Äô
21:07:43 <lambdabot>      In the first argument of ‚Äò(//)‚Äô, namely ‚Äò[1, 2, 3]‚Äô
21:07:46 <hackrilege> sorry
21:07:49 <hackrilege> k im gone
21:07:50 <hackrilege> chow
21:07:57 <hackrilege> thanks for the help
21:15:35 <Tendies> okay im trying to find the lowest number thats in all sublists of [[a]], i've got leastElem xs = [x | x <- xs!!0, x `elem` xs!!1, x `elem` xs!!2] but i want it to handle all n lists following xs!!0- not only two
21:16:31 <Tendies> can i map a function that takes two arguments and provide one of those arguments?
21:17:12 <dmj`> > map minimum $ [[1,2],[3,4]]
21:17:13 <lambdabot>  [1,3]
21:17:45 <dmj`> ($) is redundant
21:17:55 <Tendies> there is no number that appears in both of those so there isnt a least thats in all sublists
21:18:39 <Cale> Tendies: so you want to take the intersection of all the lists first?
21:18:44 <Cale> and then the minimum of that?
21:19:09 <Tendies> i suppose that gets the same end result
21:20:22 <Cale> > foldr1 intersect [[1,2,3,4],[2,3,4],[3,4,5]]
21:20:24 <lambdabot>  [3,4]
21:21:27 <Tendies> where is intersect from, standard haskell ?
21:21:29 <Cale> Note that foldr1 falls over if you give it an empty list
21:21:32 <Cale> Data.List
21:22:10 <Tendies> okay i have only the standard and prelude available to me
21:22:34 <vkx999> what happened to iteratee, is it pretty much abandoned?
21:22:57 <Cale> vkx999: It still exists.
21:23:34 <Tendies> so given that i can't use the intersect function
21:23:46 <Cale> Tendies: fair enough -- maybe write one :)
21:23:54 <Tendies> i assume another way is best than implementing intersect
21:25:37 <Cale> Actually, if this were for real, I would probably turn all the lists into Sets (i.e. Data.Set), and then intersect those which is much cheaper than intersecting lists -- and it's even cheap to take the minimum then.
21:25:44 <Cale> But given that we don't have that
21:26:08 <Cale> Probably a good way to begin would be sorting all the lists, and writing an intersection function which worked on sorted lists
21:26:43 <Cale> (because that is inexpensive and fairly easy to write recursively -- you walk down one or the other list depending on which one starts out with a smaller element)
21:26:57 <Tendies> uhm im looking at Data.list and it shows elem, which ive been using. what all is default in ghci?
21:27:00 <hackrilege> ok, i think i have formulated my query better. i would like to write join = fold, but because;
21:27:04 <hackrilege> :t fold
21:27:08 <lambdabot> (Foldable t, Monoid m) => t m -> m
21:27:25 <hackrilege> i would require a Monoid constraint for my Monad instance which is not allowed
21:27:49 <Tendies> it lets me use elem but cant find intersect
21:28:17 <Cale> Tendies: import Data.List
21:28:48 <hackrilege> :t subsequence
21:28:49 <lambdabot>     Not in scope: ‚Äòsubsequence‚Äô
21:28:50 <lambdabot>     Perhaps you meant one of these:
21:28:50 <lambdabot>       ‚Äòsubsequences‚Äô (imported from Data.List),
21:28:54 <hackrilege> :t nub
21:28:56 <lambdabot> Eq a => [a] -> [a]
21:29:13 <hackrilege> > nub "hello world"
21:29:15 <lambdabot>  "helo wrd"
21:29:27 <hackrilege> > subsequences $ nub "hello world"
21:29:29 <lambdabot>  ["","h","e","he","l","hl","el","hel","o","ho","eo","heo","lo","hlo","elo","h...
21:29:52 <lpaste> Cale pasted ‚ÄúStupid tricks with constraints‚Äù at http://lpaste.net/152723
21:29:56 <Cale> hackrilege: ^^
21:30:55 <hackrilege> wow, wtf is that!?
21:31:01 <Cale> (Note that the constraints on j don't mention a)
21:31:14 <Cale> It's Ed Kmett's constraints library
21:31:17 <Tendies> ok i confirmed i cant include anything
21:31:43 <hackrilege> god damnit
21:32:01 <Cale> hackrilege: However, you know that you can write a Monad instance for Free f without needing anything more than a Functor instance for f, right?
21:32:16 <Cale> and it's even the one that you actually want, I believe
21:32:33 <hackrilege> no i want the Monad to be Tree or Graph
21:32:41 <Cale> So, this is all just an exercise in hurting yourself using the type system
21:33:02 <Cale> Yeah, those are perfectly cromulent functors
21:33:03 <hackrilege> the Free Monad is like the Free Monoid, List, its not Tree like
21:33:16 <Cale> hm?
21:33:39 <hackrilege> non branching simple linked list
21:33:44 <Cale> Well, once you get it written, compare the results with the ones with the standard Monad instance, I think you'll be surprised.
21:33:50 <vx9999> is there an updated alternative to iteratee?
21:34:00 <Cale> vx9999: There's pipes, there's conduit
21:34:03 <jle`> hm, does pipes fit your usecase?
21:34:06 <hackrilege> if i dont present well in 2 days i lose my jjob im 2 months overdue
21:34:13 <hackrilege> i cant get my head round this
21:34:22 <Cale> vx9999: People seem to like those, at least, when they really have to use this kind of machinery.
21:34:39 <Cale> vx9999: Which, by the way, hints at another such thing, machines
21:34:48 <jle`> cute
21:35:00 <vx9999> Cale machines is related to transducers?
21:35:06 <Cale> http://hackage.haskell.org/package/machines
21:35:29 <vx9999> Cale damn i am trying to get a few biology packages working (which are few and far between)
21:35:42 <hackrilege> nothing like that is relevant at this stage
21:36:06 <Tendies> could i use filter to get only the elements that are in all of the lists?
21:36:07 <hackrilege> its obfuscating rather than illucidating
21:36:24 <vx9999> Cale they have iteratee dependencies. unfortunately nothing duplicates their functionality so it looks like the only option is to dust off the package myself
21:36:53 <jle`> sure, if they use iteratees.  but you might be able to wrap pipes around them if you want to use them with other pipey libraries
21:37:04 <hackrilege> > [1,2] \\ [2,3]
21:37:06 <lambdabot>  [1]
21:37:13 <hackrilege> hmm...
21:37:19 <Cale> vx9999: Is iteratee somehow not in a working state?
21:37:19 <vx9999> jle` i can't even get  it to build with stack :/
21:37:34 <Cale> vx9999: It's not the sort of package which should really require very much maintenance.
21:37:36 <jle`> hm, they might not be working with any snapshot
21:37:46 <jle`> the biology package, that is
21:38:14 <vx9999> Cale not with stack at least
21:38:45 <vx9999> jle` it's a bit old.. https://github.com/ingolia/SeqLoc
21:38:56 <jle`> oh hey, iteratee doesn't build for me on the latest lts, how sad
21:39:32 <vx9999> https://hackage.haskell.org/package/seqloc-datafiles-0.4.2
21:39:36 <vx9999> https://hackage.haskell.org/package/seqloc
21:39:44 <vx9999> jle` :'(
21:41:20 <hackrilege> > let f = (\ a b -> [c|c<-b, elem c a]) in foldl1 f ["hello","world","happy","haskelling"]
21:41:22 <lambdabot>  ""
21:41:36 <hackrilege> > let f = (\ a b -> [c|c<-b, elem c a]) in foldl1 f ["hello","happy","haskelling"]
21:41:38 <lambdabot>  "h"
21:42:24 <vx9999> seqloc actually builds
21:42:53 <vx9999> seqloc-datafiles does not. stack solver can't figure out a solution
21:43:05 <vx9999> er build plan
21:43:21 <hackrilege> > foldl1 instersect ["try","this"]
21:43:23 <lambdabot>      Not in scope: ‚Äòinstersect‚Äô
21:43:23 <lambdabot>      Perhaps you meant one of these:
21:43:23 <lambdabot>        ‚Äòintersect‚Äô (imported from Data.List),
21:43:34 <mgsloan> vx9999: do "stack init --solver" followed by "stack build", then iteratee builds
21:43:39 <hackrilege> > foldl1 intersect ["try","this"]
21:43:39 <Tendies> Cale: how about i take the n lists, merge them, and find only elements that appear n times
21:43:41 <lambdabot>  "t"
21:44:03 <hackrilege> Tendies: ^^
21:44:15 <Tendies> i can not import any functions
21:44:37 <vx9999> mgsloan I thought I  tried this
21:44:59 <mgsloan> vx9999: What's your stack version?  "stack init" got a lot better in the most recent version.  If you already have the latest, then you might need "stack upgrade --git"
21:45:01 <vx9999> will try one more time
21:45:13 <hackrilege> just look up how the ones used there are implemented Tendies
21:45:18 <mgsloan> (to upgrade to the git version I'm using, which just successfully built iteratee)
21:45:43 <hackrilege> foldl1 is defiend recursivly
21:45:48 <vx9999> mgsloan ok upgrading (fingers crossed)
21:46:21 <vx9999> why is it downloading a bunch fo lts 5.0 packages...?
21:46:25 <Tendies> i have access to foldl but not intersect
21:46:46 <mgsloan> vx9999: Because that's what stack is built with.  "stack upgrade --git" downloads the code and builds it
21:46:57 <hackrilege> i wrote intersect using list comprehension above
21:47:22 <hackrilege> i called it "f"
21:48:35 <hackrilege> Cale, as discussed long ago, the Free Monoid discards the join implementation of the Monad?
21:49:04 <Cale> hackrilege: I don't understand that statement...
21:50:00 <hackrilege> you say there is only one Monad instance for Free, but there are many Monads that could be nested..
21:50:25 <hackrilege> Trees of Trees of Trees e.t.c. should not fold up the same as Lists of Lists of List e.t.c
21:50:40 <vx9999> what's the difference between pipes and iteratee?
21:51:07 <hackrilege> to retain the shape of the inner Monad i should preserve its particular definition of join?
21:51:20 * hackagebot werewolf 0.4.6.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.6.0 (hjwylde)
21:51:28 <jle`> there's only one instance for Free that is a Monad for all f
21:51:35 <Cale> vx9999: Depends on how closely you look at it. Everything, structurally, but the packages are targetted at the same space of problems.
21:51:47 <jle`> polymorphic for all Functor f
21:51:55 <hackrilege> jle' its ok to not be polymorphic
21:52:10 <jle`> sure, then you can write a bunch of different instances for any specific 'f' then
21:52:11 <hackrilege> infact certainly the implementation will vary for each Monad instance
21:52:13 <hackrilege> this is desired
21:52:40 <jle`> doesn't that sort of defeat the whole purpose of Free in the first place?
21:52:43 <hackrilege> the problem is that i want to write join = fold
21:52:44 <Tendies> thanks hackrilege, didnt notice it was what i needed when i first saw it
21:52:50 <hackrilege> its ok
21:53:04 <hackrilege> nice problem, short solution
21:53:20 <hackrilege> :t fold
21:53:21 <lambdabot> (Foldable t, Monoid m) => t m -> m
21:53:21 <jle`> for what instance?
21:53:25 <hackrilege> there is a Monoid constraint
21:53:48 <vx9999> Cale I'm slightly more familiar with pipes (although not that familiar with either). are there iteratee equivalents to producers,  consumers,...
21:54:02 <jle`> is there any reason you're particularly attached to 'join = fold'
21:54:11 <jle`> if you're writing it for a specific instance you can just write join = your monomorphic instance
21:54:12 <hackrilege> i cant write instance (Monoid (m a),Monad a) => Monad (Molecule m)
21:54:27 <hackrilege> to provide the Monoid constraint required by fold
21:54:57 <jle`> sure, so just don't use fold ... use the monomorphic method that works on Molecule
21:55:17 <hackrilege> the reason im using fold, is because it embodies concatination of internal Monoids in the way that i am doing
21:56:10 <hackrilege> because my Molecule is a Foldable Monoid, i should be able to write the Monad instance using Fold
21:56:16 <hackrilege> fold*
21:56:47 <jle`> if you want ti illustrate that, you can just write foldMolecule
21:56:54 <jle`> that doesn't require the Monoid constraint
21:56:58 <jle`> and say join = foldMoleclue
21:57:09 <hackrilege> i can add elements to the collection using mappend.
21:57:28 <hackrilege> its the natural way to concatinate monoids
21:57:47 <vx9999> Cale are you sure stack init --solver works for seqloc-datafiles?
21:57:52 <hackrilege> Molecule is a Monoid, it is a Monadic collection of Monoids, namely Molecules
21:57:59 <Cale> vx9999: I've never used stack before.
21:58:00 <vx9999> Cale seems to be getting stuck so far http://lpaste.net/152724
21:58:07 <vx9999> oh sorry
21:58:09 <vx9999> mgsloan
21:58:26 <mgsloan> Oh, I only tried it on iteratee
21:58:52 <vx9999> mgsloan oh ok
21:59:02 <hackrilege> i can write Foldable and Monoid instances for Molecule, i should be able to write join = fold to give me a Monad instance
21:59:16 <Cale> hackrilege: If all this abstraction is giving you headaches in a real-world setting, I would recommend just dropping the abstraction on the floor for the time being. You don't really need to use type classes at all. Just start by writing the operations that you want on the types that you actually need them, and then worry about what type classes your thing may or may not be instances of later.
21:59:23 <vx9999> gotta get some sleep
21:59:33 <Cale> hackrilege: At least, if it were my job which were in jeopardy, that's what I'd do.
21:59:52 <hackrilege> ffs, its my whole project to identify the correct use of haskell classes in representing this datastructure
22:00:15 <cansis> dmj`: sure am :]
22:00:23 <Cale> hackrilege: Ah, I'd assumed there was something more real-world-like about the job :P
22:00:26 <hackrilege> its not like there is any roundabout way other than hitting this head on in the way im trying to, thats why i keep pushing with this line
22:00:56 <jle`> you might have a problem with that, because haskell typeclasses are the the incorrect choice for 99% of problems
22:00:57 <hackrilege> basically the chemists have this class which is a small extension to MonadPlus
22:01:02 <hackrilege> it contains a method Close
22:01:11 <dmj`> cansis: hm?
22:01:28 <hackrilege> which joins the growing end of a list to some part in the middle, tying the knott
22:02:06 <Cale> Most of the things which I'm actually paid to do involve making programs behave the way that a customer wants them to behave, and all the abstraction is nice to have when you can get it, but usually not of primary importance (until it gets to the point that the things we're writing are sufficiently complicated that understanding them in terms of abstractions is essential to actually making the program work)
22:02:14 <Tendies> why does merge [xs,ys] = foldr (:) xs ys not work on lists with more than 2 sublists
22:02:32 <jle`> Tendies: [xs, ys] is a pattern that matches the two-item list
22:02:35 <hackrilege> ok
22:02:41 <Tendies> i tried merge [xs:ys] but it said i cant generate an infinite list
22:02:42 <jle`> > let foo [x,y] = [1,2] in (x, y)
22:02:43 <lambdabot>  (x,y)
22:02:59 <Cale> Tendies: It probably was a complaint about an infinite type, not an infinite list
22:03:02 <jle`> Tendies:  [xs:ys] is a one-item list
22:03:08 <jle`> but merge is onyl defined to work on two-item lists
22:03:08 <Cale> Tendies: Infinite lists are okay, infinite types are not.
22:03:17 <hackrilege> MonadPlus is great, i can grow my datastructure, and concatinate it up again
22:03:18 <Tendies> yeah infinite type
22:03:22 <hackrilege> im making a hylomorphism
22:03:56 <jle`> Tendies: maybe you meant to write merge xs ys = foldr (:) xs ys ?
22:04:24 <jle`> i'm not sure what sort of behavior you wer expecting
22:04:26 <Tendies> the type passed in is [[a],[b],...,[n]]
22:04:29 <hackrilege> i can say e.g. z u = (join.z) >>= (repeat u)
22:04:34 <jle`> Tendies: that's not a type
22:04:37 <Tendies> i want to merge all of them 
22:04:42 <Tendies> the form of the input
22:04:47 <jle`> do you mean [[a]] ?
22:04:53 <Tendies> yes
22:04:54 <hackrilege> can you see how that forms a hylomorphism?
22:05:00 <kadoban> Tendies: "merge" meaning what?
22:05:01 <hackrilege> maybe its a type error...
22:05:21 <jle`> Tendies: so, you want a [[a]] -> [a] ?
22:05:27 <Tendies> mhm
22:05:37 <jle`> you can use 'concat', which should do the job
22:05:42 <jle`> unless you wanted to implement it from scratch
22:05:53 <hackrilege> its fold
22:06:09 <hackrilege> > fold [[0],[1]]
22:06:11 <lambdabot>  [0,1]
22:06:20 <jle`> > concat [[0],[1]]
22:06:20 <Tendies> ._.
22:06:21 <lambdabot>  [0,1]
22:06:45 <hackrilege> foldl (++) [] [[1],[2,3]]
22:06:51 <hackrilege> > foldl (++) [] [[1],[2,3]]
22:06:53 <lambdabot>  [1,2,3]
22:07:13 <hackrilege> concat = foldl (++) [] = fold
22:07:13 <jle`> foldl (++) [] is probably always a bad idea
22:07:23 <jle`> foldr (++) [] is probably prefered
22:07:28 <hackrilege> oh
22:07:42 <hackrilege> should be identical by associativity?
22:07:53 <Tendies> is 'fold' foldl or foldr?
22:08:02 <jle`> > take 10 $ foldr (++) (repeat [1,2,3])
22:08:04 <lambdabot>      Couldn't match expected type ‚Äò[a]‚Äô
22:08:04 <lambdabot>                  with actual type ‚Äòt0 [[Integer]] -> [[Integer]]‚Äô
22:08:04 <lambdabot>      Probable cause: ‚Äòfoldr‚Äô is applied to too few arguments
22:08:05 <jle`> > take 10 $ foldr (++) [] (repeat [1,2,3])
22:08:07 <lambdabot>  [1,2,3,1,2,3,1,2,3,1]
22:08:11 <jle`> > take 10 $ foldl (++) [] (repeat [1,2,3])
22:08:17 <lambdabot>  mueval-core: Time limit exceeded
22:08:17 <lambdabot>  mueval: ExitFailure 1
22:08:27 <hackrilege> ok
22:08:35 <hackrilege> thanks
22:08:39 <jle`> also, the trick is that xs ++ ys is O(length of xs)
22:08:59 <jle`> so, (xs ++ ys) ++ zs is O(length of xs + lenghth of (xs ++ ys))
22:09:02 <hackrilege> :t let z u = (join.z) >>= (repeat u) in z
22:09:03 <lambdabot>     Couldn't match expected type ‚Äò(a3 -> a2) -> a3 -> a3 -> a2‚Äô
22:09:04 <lambdabot>                 with actual type ‚Äò[a3]‚Äô
22:09:04 <lambdabot>     Relevant bindings include
22:09:07 <jle`> but xs ++ (ys ++ zs) is O(length of xs + length of ys)
22:09:25 <jle`> meaning that the foldl is O(n^2) performance, but foldr is O(n) performance :O
22:10:30 <jle`> hackrilege: if you try to force typeclasses to work for your problem, 99% of the time you're just going to end up in a worse place than where you started, and it'll just be a bad idea in general
22:10:35 <hackrilege> :t \ u -> (join.z) >>= (repeat u)
22:10:36 <lambdabot>     Couldn't match expected type ‚Äòa -> m0 (m0 a0)‚Äô
22:10:36 <lambdabot>                 with actual type ‚ÄòExpr‚Äô
22:10:36 <lambdabot>     In the second argument of ‚Äò(.)‚Äô, namely ‚Äòz‚Äô
22:10:59 <hackrilege> jle' its not a solution
22:11:01 <jle`> if you want to cut your losses, you can look at a non-typeclass-based result, and you'll probaly be able to start from scratch and find your nicer result in a quarter of the time it'd take for you to somehow force typeclasses to do the job
22:11:04 <cansis> hey bitemyapp, loving the book!
22:11:05 <hackrilege> no
22:11:07 <hackrilege> sorry
22:11:15 <hackrilege> such discussion is detracting
22:11:30 <hackrilege> as previously discussed
22:11:34 <cansis> just started last night, on Ch 3 currently
22:12:05 <hackrilege> identifying the type structure within the haskell type system is the entierity of the task
22:12:14 <jle`> sure; but if nobody replies to your questions, it isn't because they're ignoring you, it's becuase they also don't have the time and energy to go down an overly complicated rabit hole that no mortal soul would even think of entering
22:12:22 <jle`> or they don't have an answer
22:12:33 <hackrilege> or its being phrased badly by me
22:12:51 <hackrilege> but could be more easily reiterated by someone more experienced
22:13:19 <jle`> even experienced people have problems using typeclasses in weird ways
22:13:31 <hackrilege> evidently!
22:13:36 <Tendies> uh hackrilege on your foldl1 (\a b -> [ c | c <- c `elem` a]) it keeps saying c out of scope?
22:13:51 <hackrilege> but the key at the heart of this is a real understanding of why haskell has MonadPlus and Monoid instances for List
22:14:00 <hackrilege> and the natuaral extension to Trees
22:14:15 <hackrilege> and other less trivial infinitly nested Monoids than Free
22:14:53 <hackrilege> Tendies you cant draw c from c, which is what you are saying with c <- c
22:15:08 <hackrilege> also, the conditional statement should be preceded by a comma
22:15:42 <Tendies> yours worked though
22:15:55 <hackrilege> > [a|a<-b,b<-[[1..]],a<10]
22:15:55 <Tendies> or i cant type
22:15:56 <lambdabot>      Ambiguous occurrence ‚Äòb‚Äô
22:15:56 <lambdabot>      It could refer to either ‚ÄòL.b‚Äô,
22:15:56 <lambdabot>                               defined at /tmp/mueval7711514321186452551.hs:14...
22:16:24 <hackrilege> @undefine
22:16:24 <lambdabot> Undefined.
22:16:27 <hackrilege> > [a|a<-b,b<-[[1..]],a<10]
22:16:28 <lambdabot>      Couldn't match expected type ‚Äò[t]‚Äô with actual type ‚ÄòExpr‚Äô
22:16:29 <lambdabot>      In the expression: b
22:16:29 <lambdabot>      In a stmt of a list comprehension: a <- b
22:16:41 <hackrilege> oops, mess
22:16:44 <hackrilege> sorry
22:16:54 <Tendies> ye i cant type
22:17:32 <hackrilege> you got it? cool
22:18:58 <Tendies> er
22:19:04 <Tendies> i got it [to compile]
22:20:16 <hackrilege> from http://stackoverflow.com/questions/13352205/what-are-free-monads
22:20:47 <hackrilege> bind uses concatFree
22:21:02 <hackrilege> which just deconstructs the nested Roll constructors
22:21:22 <hackrilege> it does not use the Monad structure as it is provided with a functor
22:21:35 <hackrilege> when given a MonadPlus, the contents can be folded up instead
22:22:44 <hackrilege> basically the task is to write this as a class
22:22:51 <Tendies> what i have is leastElem xs = foldl1 (\ a b -> [ c | c <- b, elem c a])
22:23:04 <hackrilege> without using the ek constraints package
22:23:16 <Tendies> its saying non type-variable argument in constraint. but i havent set any constraints
22:24:11 <hackrilege> basically, it seems like the mplus of MonadPlus is a misnomer, as it does not opperate on the basecase, folding up its contents to yield a single value
22:24:31 <hackrilege> List being  monoid makes more sense than it being  a MonadPlus
22:24:34 <hppavilion[1]> Is there any online compilation of good projects to experiment with to learn Haskell?
22:24:50 <hppavilion[1]> Tutorial-independent
22:24:52 <hackrilege> > fold [1,2,3]
22:24:53 <lambdabot>      No instance for (Show a0)
22:24:53 <lambdabot>        arising from a use of ‚Äòshow_M29757648961756284417358‚Äô
22:24:53 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
22:24:54 <hppavilion[1]> (I'm using LYAH)
22:25:09 <hackrilege> > fold ([1,2,3]::[Double])
22:25:10 <lambdabot>      No instance for (Monoid Double) arising from a use of ‚Äòfold‚Äô
22:25:10 <lambdabot>      In the expression: fold ([1, 2, 3] :: [Double])
22:25:39 <Tendies> > let f = (\a b -> [c | c <- b, elem c a]) in foldl1 f ["hello","happy","haskelling"]
22:25:41 <hackrilege> i dont know why Double doesnt have a Monoid instance... do any Nums?
22:25:41 <lambdabot>  "h"
22:26:23 <hackrilege> is anyone engaged in this discussion with me?
22:26:54 <jle`> Double doesn't have a Monoid instance because it's not clear which one is preferred
22:27:05 <jle`> since there are at least a few 'obvious' ones
22:27:19 <jle`> hackrilege: you're right, mplus doesn't refer to adding any elements together
22:27:19 <shachaf> I can't think of any obvious Monoid instances for Double.
22:27:33 <hackrilege> it has 2
22:27:41 <hppavilion[1]> Oh hi shachaf
22:27:48 <hackrilege> 0,+ and 1,*
22:28:06 <jle`> hackrilege: we have Sum and Product as newtype wrappers to choose which instance you want
22:28:08 <hackrilege> i guess there is the Sum type
22:28:11 <jle`> > Sum 1 <> Sum 10
22:28:13 <lambdabot>  Sum {getSum = 11}
22:28:35 <nshepperd> "Monoid" if you pretend that Doubles are real numbers
22:28:41 <jle`> hackrilege: mplus is "plus" in the sense that it's the "addition" w.r.t. the ring-like structure when taken with "multiplication", >>=
22:28:54 <jle`> it doesn't have anything to do with addition in the traditional sense
22:29:01 <hackrilege> > fold ([1,2,3]::Sum Double)
22:29:02 <lambdabot>      Couldn't match expected type ‚ÄòSum Double‚Äô
22:29:03 <lambdabot>                  with actual type ‚Äò[Integer]‚Äô
22:29:03 <lambdabot>      In the first argument of ‚Äòfold‚Äô, namely ‚Äò([1, 2, 3] :: Sum Double)‚Äô
22:29:05 <Tendies> "let f = (\a b -> [c | c <- b, elem c a]) in foldl1 f ["hello","happy","haskelling"]" this only works in interactive, when i make it a function it just breaks
22:29:10 <hackrilege> > fold ([1,2,3]::[Sum Double])
22:29:11 <lambdabot>  Sum {getSum = 6.0}
22:29:16 <hackrilege> cool
22:29:58 <hackrilege> its just filter
22:30:00 <jle`> mplus, mzero, and (>>=) are meant to correspond roughly with +, 0, and *
22:30:31 <Tendies> any idea hackrilege ?
22:31:02 <jle`> (it's not meant to "add" elements in a type together)
22:31:13 <hppavilion[1]> Found some projects on the obvious wiki I should be checking before asking questions.
22:31:24 <hppavilion[1]> What would be a good ID- wait, wiki
22:32:12 <hackrilege> > let filter' x xs= foldr (flip elem x) xs in filter' 3 [1..10]
22:32:13 <lambdabot>      Couldn't match type ‚ÄòBool‚Äô with ‚Äòb -> b‚Äô
22:32:13 <lambdabot>      Expected type: a1 -> t3 a1 -> b -> b
22:32:13 <lambdabot>        Actual type: a1 -> t3 a1 -> Bool
22:32:18 <hackrilege> no sorry...
22:32:34 <hackrilege> > let filter' x xs= foldr (elem x) xs in filter' 3 [1..10]
22:32:36 <lambdabot>      Couldn't match type ‚ÄòBool‚Äô with ‚Äòb -> b‚Äô
22:32:36 <lambdabot>      Expected type: t4 a1 -> b -> b
22:32:36 <lambdabot>        Actual type: t4 a1 -> Bool
22:32:59 <hackrilege> > let filter' x xs= foldr1 (elem x) xs in filter' 3 [1..10]
22:33:00 <lambdabot>      Couldn't match type ‚ÄòBool‚Äô with ‚Äòt2 a1 -> t2 a1‚Äô
22:33:00 <lambdabot>      Expected type: t2 a1 -> t2 a1 -> t2 a1
22:33:00 <lambdabot>        Actual type: t2 a1 -> Bool
22:33:14 <hackrilege> omg! i have to stop its spamming up the board
22:33:16 <hackrilege> any help?
22:34:02 <hackrilege> ok, jle', can you consider the hylomorphism formed from;
22:34:23 <shachaf> Please don't do that in the channel with lambdabot.
22:34:27 <hackrilege> \ u -> (join.z) >>= (repeat u)
22:34:43 <hackrilege> sorry shachaf
22:34:45 <shachaf> If you need to use lambdabot you can /msg. Only use it in the channel for demonstrating things to others.
22:35:08 <hackrilege> sorry i forgot the /msg command...
22:39:37 <hackrilege> as Free uses a forgetful functor, no concatination is achieved with foldFree
22:40:38 <hackrilege> so i imagine while many nested list of lists can be concatinated to a single list, it would not be done so using foldFree
22:40:42 <hackrilege> is that correct firstly?
22:42:21 <hackrilege> then my intension for my dataStructure Molecule is to allow nested Monoids to be constructed using concatinate.repeat
22:43:50 <hackrilege> where concatinate would use mappend which would allow dynamic construction
22:43:54 <hackrilege> does this make sense?
22:44:56 <ansel> hi all, i'm trying to get a ghc 8 snapshot running, something is screwy with my cabal versions i think: ghc-pkg shows cabal 1.23.1 is 'installed' but i can't find a binary besides `~/.cabal/bin/cabal` which is version 1.22.7, installed by ghc-7.10.3 which i used to bootstrap ghc 8
22:45:33 <hackrilege> a great problem i feel on this channel is that i spend a lot of time explaining something people claim is not clear and recieving little response indicating how my commentary achieves clarification...
22:46:09 <hackrilege> im not sure if you understand me and im doing something wrong, or if i have failed to communicate the problem...
22:48:17 <hackrilege> again, to facilitate a meaningful analogy of foldFree which uses internal Monoidal structure (or more achivably internal MonadPlus structure) to give means to concatinate the internals without disgarding shape more complex than the free Monoid
22:48:47 <hackrilege> is my intention
22:50:00 <hackrilege> Cale has suggested using a library i cannot understand to implement the required constraint
22:50:34 <hackrilege> it was not clear then if this would do what i wanted it to do
22:50:39 <Tendies> > let f = (\a b -> [c | c <- b, elem c a]) in foldl1 f ["hello","happy","haskelling","herk"]
22:50:41 <lambdabot>  "h"
22:50:53 <kadoban> ansel: The name Cabal is the library. The executable is from the cabal-install package, despite the actual executable being named cabal. If any of that helps.
22:52:33 <hackrilege> i cant understand why i cant get feedback on if my problem makes sense or if it indicates a conceptual hole which could be identified and rectified
22:53:08 <hackrilege> other than that i am not clear, but attempts to clarify seem to be failing
22:53:17 <Walther> hackrilege: sometimes there's no people around, and sometimes the people around are only noobds, or any other reasons
22:53:23 <Walther> noobs*
22:53:57 <hackrilege> im seeng Kadoban, Cale and others who have been observing my discussion on this topic for months
22:54:00 <Walther> I have nowhere near enough haskell skills to understand your problem, no matter how well you explain it
22:54:33 <Walther> this channel is not commercial user support either, it's based on volunteers goving their time
22:54:39 <hackrilege> the thing is the problem is key to understanding the Monadic function of List and other more complex dataTypes in Haskell and the ecnteral type system
22:55:17 <kadoban> hackrilege: I understand very little of what you describe. I don't know if that's a failing on my part or yours.
22:55:30 <hackrilege> its mostly concerning to me that i dont understand it, im sure it is not the case that no one here understands it.
22:57:18 <hackrilege> its about the strange link between the possibility to recursivly nest Monads (cf [[[[]]]) and the datastructure similar to Free which does not disgard the internal Monadic structure through use of forgetfu fonctors...
22:57:38 <hackrilege> forgetful functors*
22:58:58 <hackrilege> i wish to populate lists with such lists (ones being populated with such lists) and fold them up like in a hylomorphism, while retaining the complex Monoidal shape such as Graph or Tree
22:59:30 <hackrilege> fractal datastructures...
23:00:44 <hackrilege> i had hoped that over the many attempts i had taken to describe this process, that the conceptual barrier i have to rationalising the process would be found by someone else who could visualise it better...
23:01:39 <Tendies> i got the chinese remainder theorem don in ... 13 LOC
23:01:41 <Tendies> is that ok
23:02:58 <hackrilege> Tendies, im not sure
23:03:28 <kadoban> hackrilege: I would probably suggest that if what you're trying to do isn't even clear to you, it probably make sense to instead of all these abstractions, code something that works. Then if you want to, try to find the right abstractions to make it prettier as you like. As a bonus that'd give you a huge leg up in terms of trying to explain it to people, since there's something concrete to point to and discuss.
23:04:03 <nineonine> hi there
23:04:13 <hackrilege> the paste i have so far is this;
23:04:14 <hackrilege> http://lpaste.net/152721
23:04:18 <nineonine> is there any way to detect escape chars ?
23:04:18 <hackrilege> kadoban
23:04:39 <nineonine> i mean can we see \ in string literals ?
23:04:39 <hackrilege> :t getLines
23:04:40 <lambdabot>     Not in scope: ‚ÄògetLines‚Äô
23:04:40 <lambdabot>     Perhaps you meant one of these:
23:04:40 <lambdabot>       ‚ÄògetLine‚Äô (imported from Prelude),
23:05:15 <kadoban> nineonine: What do you mean detect them?
23:05:25 <nineonine> i want to count them as well
23:05:27 <nineonine> eg
23:05:41 <nineonine> we have ‚Äú\‚Äù\‚Äù
23:05:48 <hackrilege> nineonline; haskell strings detect \ to indicate the next charicter is a special charicter. if you wish to include a \ as a charicter you must prefix it with \
23:05:51 <hackrilege> > "\\"
23:05:53 <lambdabot>  "\\"
23:05:54 <nineonine> i mean ‚Äú\‚Äù\‚Äù‚Äù
23:06:07 <nineonine> and i want to have length to be 4
23:06:15 <nineonine> not 2
23:06:23 <hackrilege> impossible
23:06:25 <liste> > text "\\\"\\\""
23:06:26 <lambdabot>  \"\"
23:06:39 <hackrilege> you must prefix the \ with \
23:06:42 <liste> length "\\\"\\\""
23:06:45 <liste> > length "\\\"\\\""
23:06:45 <kadoban> nineonine: Based on what? What *must* be escaped to express the string in code?
23:06:46 <lambdabot>  4
23:06:54 <nineonine> show ‚Äú\‚Äù\‚Äù"
23:07:35 <zd234> besides purescript, is there any compiler for "something haskell-ish, with pure functions, but strict" to javascript ?
23:07:37 <nineonine> what do you mean ‚Äòmust be escaped‚Äô ?
23:07:57 <kadoban> nineonine: Well, you understand why the length of that String is 2, right?
23:08:04 <nineonine> yes
23:08:11 <hackrilege> fso whats the problem?
23:08:57 <hackrilege> did you see the paste kadoban?
23:09:09 <bitemyapp> cansis: glad to hear it :)
23:09:13 <kadoban> > "\32" -- nineonine, so what do you want your weirdLength of this to be?
23:09:14 <lambdabot>  " "
23:10:01 <hackrilege> > '\'
23:10:02 <lambdabot>  <hint>:1:4:
23:10:02 <lambdabot>      unexpected end-of-file in string/character literal at end of input
23:10:04 <liste> zd234 does Roy count as haskellish?
23:10:18 <zd234> liste; purescript is 20K loc, is Roy smaller?
23:10:31 <kadoban> hackrilege: Yes, but I didn't really read it much. I'm not really sure what the question is in terms of that code either.
23:10:58 <kadoban> > "\32" == " " -- note this:
23:11:00 <lambdabot>  True
23:11:00 <hackrilege> ok so in the paste i have a Monoid instance and a MonadPlus instance
23:11:10 <hackrilege> i wish to write join = fold
23:11:20 <nineonine> actually function show worked
23:11:21 <zd234> ick, is roy written in js?
23:11:26 <hackrilege> but i cannot write (Monoid (m a),Moinad m) =>
23:11:35 <nineonine> > length ‚Äú!!!"
23:11:37 <lambdabot>  <hint>:1:8: lexical error at character '\8220'
23:11:42 <hackrilege> for my Monad instance
23:12:01 <nineonine> > show ‚Äú!‚Äù
23:12:03 <lambdabot>  <hint>:1:6: lexical error at character '\8220'
23:12:09 <hackrilege> this is the only problem i have
23:12:52 <liste> zd234: yes, 4059 lines of javascript
23:12:53 <hackrilege> my datastructure only contains monads of itself, and such objects have a natural Monoid instance
23:12:54 <nineonine> length ‚Äú\‚Äù\""
23:13:00 <kadoban> nineonine: Your quote characters are wonky. Is your client doing that? You hopefully can tell it not to. They're not the same as "
23:13:01 <hackrilege> does that make sense so far?
23:13:12 <nineonine> yeah i see that
23:13:14 <zd234> liste; I am having problem finding sample code for roy
23:13:21 <nineonine> i dont know
23:13:25 <nineonine> will check now
23:13:27 <kadoban> hackrilege: Yes, that makes sense, but I doubt I'll be able to help you solve it. Why can't you do what you want?
23:13:46 <Tendies> length "!!!"
23:13:50 <Tendies> >length "!!!"
23:13:56 <Tendies> > length "!!!"
23:13:58 <lambdabot>  3
23:14:16 <hackrilege> i cannot write (Monoid (m a),Moinad m) =>
23:14:25 <liste> zd234: http://roy.brianmckenna.org/ -> the combobox under "try"
23:14:28 <nineonine> > show "!"
23:14:30 <lambdabot>  "\"!\""
23:14:30 <hackrilege> so i cannot provide the context for
23:14:33 <hackrilege> join = fold
23:14:35 <hackrilege> :t fold
23:14:37 <lambdabot> (Foldable t, Monoid m) => t m -> m
23:15:38 <zd234> liste: roy looks interesting
23:15:43 <nineonine> show "\"\""
23:15:53 <nineonine> > show "\"\""
23:15:55 <lambdabot>  "\"\\\"\\\"\""
23:16:04 <nineonine> length "\"\""
23:16:17 <nineonine> > length "\"\""
23:16:18 <lambdabot>  2
23:16:27 <nineonine> length $ show "\"\""
23:16:28 <liste> zd234: not sure if it's referentially transparent though
23:16:34 <nineonine> > length $ show "\"\""
23:16:36 <lambdabot>  6
23:17:55 <hppavilion[1]> nineonine: I see you've discovered the wonders of backslash escape exponential growth
23:17:55 <liste> > length $ show "√§"
23:17:56 <lambdabot>  6
23:18:07 <liste> nineonine: that works if you're ok with that
23:18:09 <nineonine> :))
23:18:10 <hppavilion[1]> nineonine: I once crashed my computer thrice in one day testing that out
23:18:13 <hackrilege> nope?
23:18:20 <MarcelineVQ> > length $ show "‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã"
23:18:21 <lambdabot>  <hint>:1:16:
23:18:21 <lambdabot>      lexical error in string/character literal at character '\8203'
23:18:21 <nineonine> yeah that works
23:18:24 <MarcelineVQ> hehe
23:19:10 <MarcelineVQ> > text $ show "escapes?"
23:19:11 <lambdabot>  "escapes?"
23:21:24 <hppavilion[1]> I have discovered a use for Esolangs
23:22:51 <hackrilege> yeah ok
23:23:08 <hackrilege> this is clearly not helping me
23:23:13 <hackrilege> sorry everyone
23:23:57 <hackrilege> such an unforgiving environment
23:24:55 <hackrilege> as far as i can tell a bug in the language is causing me to fail my phd
23:25:15 <hackrilege> but there is clearly no point talking about it here
23:26:22 <MarcelineVQ> It's not exactly prime hours for prompt question responses.
23:42:27 <Tendies> "could not match type `t' with type `Integer'
23:42:38 <Tendies> what gives?
23:42:55 <liste> @paste -- Tendies: please lpaste your code
23:42:55 <lambdabot> Haskell pastebin: http://lpaste.net/
23:43:38 <Tendies> http://lpaste.net/152726
23:46:43 <liste> Tendies: I think you've bumped into the dreaded monomorphism restriction
23:46:58 <liste> try adding type signatures to your functions
23:47:13 <liste> or putting them into a let/where block
23:47:26 <ansel> is there a special cabal hell irc channel? :[
23:47:31 <liste> https://wiki.haskell.org/Monomorphism_restriction
23:47:36 <Tendies> the only function thats not internal is kcomposite
23:47:44 <Tendies> <_>
23:47:47 <Tendies> which has one
23:47:55 <cocreature> ansel: #haskell-stack? :P
23:47:55 <liste> Tendies: they're still all top-level
23:48:45 <ansel> cabal install can't resolve any dependencies, trying to install globally on a clean build
23:48:46 <Tendies> i mean they're never going to be used though
23:48:57 <Tendies> except as a result of calling kcomposite
23:49:12 <liste> Tendies: then it's safe to put them in a where or let block
23:50:49 <Tendies> so it would be like foo a = blah where factorize a = <function body> ?
23:51:24 <liste> Tendies yup, preferably factorize etc. would be in their own lines, indented
23:51:50 <lpaste> liste annotated ‚Äúa‚Äù with ‚Äúa (annotation) -- Tendies like this‚Äù at http://lpaste.net/152726#a152728
23:52:22 <Tendies> thanks
23:52:29 <liste> you're welcome (:
23:53:11 <Tendies> so if im trying to combine like 5 and 7 into a nested comprehension, what variables does the outside one have access to, can it see x?
23:53:19 <Tendies> line* 5 and 7
23:54:05 <liste> Tendies: all the functions have access to `a', kcFactorials and factorize shadow it with their own `a'
23:54:13 <liste> that'll produce a compiler warning
23:54:23 <liste> consider renaming the inner `a' to something else
23:56:26 <zd234> http://code.haskell.org/HList/Data/HList/ <-- can anyone explain to me why hlist is seemingly so complicated ?
23:57:36 <peddie> zd234: it probably seems complicated because it's using the type system to do a bunch of stuff you're used to seeing done with terms; is there anything in particular?
23:59:04 <zd234> peddie: no, it's just I was reading the ctrex paper (one impl of records), and it had a heteregenous list impl in like half page
23:59:06 <Tendies> liste: im really not seeing how these combine
23:59:12 <zd234> so HList clearly must be providing much more, but I just don't know what
23:59:14 <zd234> peddie: ^
