00:00:38 * gfixler wants to say anything and hear "yeah, that's close enough" as a reply, just once
00:02:03 <jle`> how useful a description is depends on the context that it is meant to be taken/used in
00:02:27 <jle`> so i'm sure that exists. context s.t. your description is close enough in that context :)
00:02:42 <gfixler> jle`: thanks! I'll take it
00:03:25 <jle`> works unless you're a constructivist :D
00:22:34 <gfixler> Autobots wage their battle to destroy the evil forces of the Constructivists.
00:22:36 <gfixler> it works
00:25:01 <ReinH> jle`: o/
00:25:32 <jle`>  \o
00:29:04 * hackagebot cli 0.1.2 - Command Line Interface  https://hackage.haskell.org/package/cli-0.1.2 (VincentHanquez)
00:34:04 * hackagebot hsdev 0.1.6.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.2 (AlexandrRuchkin)
00:35:06 <xacktm> Hi, I'm having trouble with Parsec and try; where can I tell where the parser is failing at?  It looks like it's failing at `try storep` but I'm not sure how to fix.  http://lpaste.net/152577  
00:36:30 <xacktm> the parser reads the first token, then tries to read the second token, and branches depending on the try
00:36:38 <zd234> anyone else have performance problems with running reflex-frp code (compiled to js) on a chromebook ?
00:41:03 <xacktm> (I'm assuming the behavior of try is that if it fails, it doesn't consume input and the empty string is returned)
00:43:31 <jle`> xacktm: that's not quite 'try', you might be thinking of 'optional'
00:43:51 <jle`> try changes behavior when dealing with Alternative combinators, like <|>/choice
00:44:17 <jle`> for `x <|> y`, if x fails, it'll try to parse y where x left off, and the result will be the result of y
00:44:27 <jle`> (if x succeeds then it'll just go on, ignoring y)
00:44:44 <xacktm> ok give me a min to look
00:44:55 <xacktm> I just want to look ahead and branch on that
00:44:57 <jle`> for `try x <|> y`, if x fails, then it'll "backtrack" to before x began parsing
00:45:04 <jle`> and then try y, from the same starting point
00:45:56 <jle`> so `string "hello" <|> string "world"` will work for "helworld", but `try (string "hello") <|> string "world"` won't
00:47:29 <jle`> xacktm: you might be looking for something like 'optional', which might be Parser a -> Parser (Maybe a), or a -> Parser a -> Parser a
00:47:46 <jle`> which takes a parser and returns a parser that tries to parse it, but if it fails, returns the default option or Nothing
00:48:27 <jle`> ah, in parsec, they're called option and optionMaybe
00:49:10 <xacktm> ok yea I was about to ask about option{Maybe}
00:52:09 <xacktm> a different error, progress :)
00:56:48 <gamegoblin> Not Haskell (but for a program I am working on…so tangentially related. Can anyone solve for t and theta in this system:
00:57:11 <gamegoblin> a * cos(theta) * t^2 + v_0 * t + x_0 = x_1
00:57:26 <gamegoblin> a * sin(theta) * t^2 + v_1 * t + y_0 = y_1
00:57:45 <gamegoblin> Gets into some nasty trig identities once you apply quadratic formula to it to isolate theta...
00:57:58 <gamegoblin> If anyone has mathematica and wants to let it give it a shot, I’d appreciate it :)
01:05:00 <xacktm> gamegoblin: tried ##math?
01:05:16 <gamegoblin> xacktm: nope, this is the only channel I hang out on. I’ll give it a shot.
01:05:39 <ReinH> gamegoblin: http://www.wolframalpha.com/input/?i=a+*+cos(theta)+*+t%5E2+%2B+v_0+*+t+%2B+x_0+%3D+x_1
01:06:04 <gamegoblin> ReinH: Solve for the system for t and theta
01:06:14 <gamegoblin> two variables, two equations
01:13:19 <gamegoblin> Cleaner math http://mathb.in/52142
01:18:55 <xacktm> is a newline considered a space in Parsec?
01:19:14 <xacktm> that's the only explanation I can think of for this parsing error
01:19:57 <gamegoblin> xacktm: from Data.Char
01:19:58 <gamegoblin> isSpace :: Char -> Bool Source
01:19:58 <gamegoblin> Returns True for any Unicode space character, and the control characters \t, \n, \r, \f, \v.
01:19:59 <xacktm> oh yes, \n is True for isSpace :|
01:20:07 <xacktm> yup just saw that thx
01:23:33 <xacktm> modifying my storep now looks to parse without error, but the evaluation gives unexpected results; more progress :)
02:07:14 <apsod> Hi! Does anyone know why the adjunctions package limits right adjoints to representable functors?
02:19:03 <absence> so traverse f = sequenceA . fmap f. does the "oposite", i.e. fmap f . sequenceA, have a name?
02:19:31 <mniip> :t fmap f . sequenceA
02:19:33 <lambdabot> (Show (t a), Applicative f, Traversable t, FromExpr b) => t (f a) -> f b
02:19:41 <mniip> :t fmap ?f . sequenceA
02:19:43 <lambdabot> (Applicative f, Traversable t, ?f::t a -> b) => t (f a) -> f b
02:20:05 <mniip> interesting
02:20:23 <mniip> smells comonadic
02:21:14 <absence> mniip: i've only used it with f = join when the sequencing results in nested monads, but it made me curious
02:21:32 <mniip> :t traverse
02:21:34 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:21:37 <mniip> it does seem dual to that
02:21:53 <gfixler> what does the ? do?
02:22:11 <mniip> implicit arguments
02:25:04 <gfixler> oh, wow
02:25:27 <quicksilver> they're a terrible feature but helpful for clever type-checking tricks :P
02:25:28 <gfixler> dynamic scoping
02:26:08 <gfixler> quicksilver: yeah, I was already feeling the "bad but sometimes useful" vibe
02:26:28 <gfixler> the name made me think of Python's default args
02:26:37 <gfixler> this is even worse
02:27:06 <mniip> alright,
02:27:19 <mniip> :t (. sequenceA) . fmap
02:27:20 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
02:29:15 <mniip> > fmap read . sequenceA $ ["123","45","6"]
02:29:16 <lambdabot>  [*Exception: Prelude.read: no parse
02:29:30 <mniip> > fmap (read :: String -> Int) . sequenceA $ ["123","45","6"]
02:29:31 <lambdabot>  [146,156,246,256,346,356]
02:31:03 * hackagebot freesound 0.2.0 - Access the Freesound Project database  https://hackage.haskell.org/package/freesound-0.2.0 (StefanKersten)
02:34:48 <dramforever> Question: What's the criteria for floating a binding outwards?
02:35:15 <mniip> what do you mean
02:35:27 <mniip> you mean the GHC optimizer?
02:36:25 <dramforever> Oh yeah
02:36:42 <dramforever> Somehow that part got lost when phrasing the question :/
02:36:58 <dramforever> mniip: For example, If I have a function like:
02:37:09 <dramforever> @let numberThem = zip [1..]
02:37:11 <lambdabot>  Defined.
02:37:22 <dramforever> > numberThem "This gets numbered"
02:37:23 <lambdabot>  [(1,'T'),(2,'h'),(3,'i'),(4,'s'),(5,' '),(6,'g'),(7,'e'),(8,'t'),(9,'s'),(10...
02:38:01 <dramforever> Is the [1..] being saved or recalculated? Is there a "rule" or something?
02:38:12 <dramforever> *recalculated each time
02:38:30 <mniip> uhh
02:38:33 <mniip> good question
02:38:50 <dramforever> now that "floating a binding outwards" thing no longer make sense, just ignore it
02:39:49 <quicksilver> actually it was a good quesiton, dramforever 
02:40:16 <quicksilver> moving bindings up and down changes sharing behaviour and the amount of work done
02:40:32 <quicksilver> it's not documented or specified anywhere
02:40:40 <dramforever> quicksilver: Yeah, It's being brought up in the Chinese QQ Haskell group and nobody seems to have anything to say about it
02:40:44 <mniip> [1..] is a thunk, but when it is collected and/or revaluated?
02:40:48 <dramforever> thought I could ask here
02:40:59 <quicksilver> but in general I believe GHC will float bindings up if they have no local variables
02:41:06 <quicksilver> which will tend to increase sharing (but can lead to space leaks)
02:41:25 <quicksilver> maybe only when the optimiser is on(?)
02:41:31 <dramforever> That's a somewhat huge space leak I think
02:42:02 <dramforever> quicksilver: -ffull-laziness Turn on full laziness (floating bindings outwards). Implied by -O, so yes
02:42:14 <dramforever> oh, that's one way yes
02:45:39 <dramforever> quicksilver: It's kinda amazing in Haskell to be able to easily transform code so that the semantics are preserved, but performance greatly changed
02:46:00 <tdammers> dramforever: I love how you said "changed", not "improved" :D
02:46:03 * hackagebot ginger 0.1.1.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.1.0 (TobiasDammers)
02:47:44 <dramforever> tdammers: Yeah, once -fstate-hack changed my O(n log n) algorithm into a (I think) O(n^2 log n) one or even worse
02:47:59 <dramforever> What's more, -fno-state-hack has no effect, because the Prelude is already hacked :P
02:49:03 <dramforever> oh not Prelude, I forgot which
02:51:04 * hackagebot ginger 0.1.1.1 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.1.1 (TobiasDammers)
03:43:44 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
03:43:44 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
03:43:44 --- names: list (clog t0ggah seangrove hackebeilchen isocliff tommyliu ziocroc pgiarrusso Jedai Frankablu manfoo7 proteusguy dadaro Tertain badon cchalmers ongteckwu zeroed simukis__ jaffachief Arguggi lspitzner Reshi kamog marcon wei2912 clauswitt hackebeilchen1 Lowl3v3l hamid clynamen shangxiao rodlogic nicow lep-delete bamboo pacak1 aarvar kattak kmelva hamishmack hexagoxel zcourts araujo ortmage josephle tekkkz rcat egis vharish dougia cyborg-one oish a3Dman lwm gracefu)
03:43:44 --- names: list (apsod oisdk_ jle` nomeata eyck swistak35 mrArkwright dramforever kagcc marr csabahruska dmag kam270 silky-nvds bennofs afcondon wwwbukolaycom kp666 i-amd3 sigma914 gniourf castlelore migimunz syntagma bot486cd02e tesuji chaosmasttter pamiz dpower srajendra LnL CurryWurst jophish PatrickRobotham Zekka heurist neoncontrails edwinvdgraaf benma Yuras micmus sepp2k caumeslasal infinity0 dominik free_beard kritzcreek t0by MasseR thc202 BartAdv CoconutCrab doomlord)
03:43:44 --- names: list (raichoo unclechu danvet tv1 IlanGodik gfixler AntiSpamMeta radens Vorpal Fylwind async_prince dju jix silver andyo mjrosenb topi opios Geekingfrog asjo d6e indiffernet Guest27566 justin_smith darthdeus jimki OverCoder musha68k toredl tumdedum plazmonii lstrano jnes alarmmm stoopkid anoe zenzike m0rphism Johny_ CindyLinz benl23 dm3 wvdhaute sinkensabe eatman quchen edsko N0viceLive-amd64 gem xelxebar srenatus humanbsd brh eazar001 thunderrd boj v_g mzf)
03:43:44 --- names: list (ThomasLocke slomo cpup Stratege Warlock[29A] ramky takuan acertain axm helozjisky wookiehangover xinming Tene wuxun Adios johnzorn lyuha benonsoftware noname__ mtncoder dexter_ sgfltx Sgeo_ vlatkoB nilg omega8cc coddinkn kurt111 schoppenhauer1 yrdz` Guest9703 ifesdjee_ mauke Atrumx howdoi treaki_ vili_ gauthier verement elementalest juhp Mr0rris0 nisstyre hucksy agjacome_ yfeldblum schlicht_ jaredloomis exferenceBot lritter python476 mach phileas FreeBirdLjj)
03:43:44 --- names: list (Coldblackice conal Sam_ nogic jbalint minsky markus1189 predator117 oldmanmike MelodyKH3 dlundy mochi coeus dicioccio kalail Church- clinton_ justanotheruser supatha nolraiU Regex_ alunduil Sorella ollef dgpratt bananagram Lord_of_Life eddsteel Cetusx narendraj9 Pamelloes Guest1087 Majiir Enigmagic lahwran goldfire1 mudfog_ Ashy leino Adie rrbm kakos prooftechnique hiroakip svp_ jedai42 quaestor pavonia davl proteusguy__ rgr mendez bsmt adlan freekevin)
03:43:44 --- names: list (cognominal krgn dmwit_ ryantrinkle sword_smith xplat drkonga dedgrant NeverDie Philonous Wamanuz niko jokleinn nuttycom robertk shergill moop mietek aloiscochard Natch tomaw Tesseraction Sornaensis Soft nchambers Watcher7_ erebe_ apo_ Tinchos M-Quora M-david M-Illandan alexa_ FreeFull fr33domlover anders0 keteim sys9mm Voldenet fnordbert urdh dolio brassel wrengr_a1ay Moyst a_ prkc_ simony Ezku_ juch_top_ itsmonkt1stic dud` lamilami obadz dextertzu chlong)
03:43:44 --- names: list (ethercrow lonokhov Urchin vkt jellytux agustrong troydm Internet13 whiteline delYsid nrw_ caasih codedmart drewdavis lancetw Vbitz thoughtpolice timrs2991 sbrg frelux paf31 nolrai2 _kfpratt M-ou-se codeflavour moredhel @ChanServ noexcept Clint tekacs kqr carter zph RazorX wjm Taneb GGMethos thorkilnaur kaol ajp mikeizbicki hpc flux Bane^ taruti stux|RC-only folsen ibid Kavec heath Bigcheese Fubar^ xou sgronblo_ KitC_ shteou wto ahf yeltzooo9 sujeet exio4)
03:43:44 --- names: list (Laney jameseb Twey marcel SegFaultAX alem0lars SolarAquarion KorriX no-n wtw sregister Nahra mniip LordDeath grol whoops unsymbol nyuszika7h dsop max-m vikraman marienz huonw arkarth atomi comboy numberten absence Deewiant hrnz stephe vikram______ nek0 fyolnish tjbp spaceships wyvern chu tg TommyC luzie Profpatsch EvanR xaimus statusbot sku1d icedev froztbyte FUZxxl c-rog dan64 Saizan z-nexx dtulig ephess_ leftylink ddima nitrix brisbin swhalen_ julienXX)
03:43:44 --- names: list (mmaruseacph2 mrshoe_ tedkorni1h pontus horatiohb SolitaryCypher wamaral `0660 jayne amharc pdxleif saiam yusukesuzuki marens cods lokydor martinbjeldbak Chobbes itscaleb dilinger zhulikas zomg statusfailed qz codebje kaictl Desoxy mathu arw tippenein gpampara- Guest52006 stelleg FireFly RouxTheDay TimWolla __rlp bind Guest3764 japesinator lyddonb fold3 vin-ivar deni amontez_ bolmar Drezil isomorphismes wayne kennyp Intensity juri_ tdammers xxpor thebnq)
03:43:44 --- names: list (bogdanteleaga Ptival KaneTW nille sellout mgaare sivs avocado tero- uwap int-e henrytill tippeneinn keko-2 etrepum sbjorn aristid jaaket borkdude_ MorTal1ty spacebug rkk cosban Blkt raid jasaarim minad fall_ codehero hc ByronJohnson serutsubi ClaudiusMaximus valdyn joeytwiddle bazzle kini tswett ixian DenSchub _6a68 warc killtheliterate alanz cbaines RageD pfeyz_ ppnkk klugez unknownloner zimp1 majjoha lenstr luis carter_cloud qguv dario` PotatoGim eagleflo)
03:43:44 --- names: list (mimi_vx SuperTux88 themagician case39 osfameron jstolarek spindas puzza007 rstone fabianvf shans_ flower_snark harmchop kyagrd jfokkan__ johtso TabAtkins rslima_ shelling__ milessabin runeks phuu naudiz avdi amatecha jnoah koomi sea-gull lambdabot DrFerdirand cjh` sohum reactormonk greymalkin ephemeron Shockk sekrit abk7 brt1 davean gabiruh chrzyki impure_hate ggherdov_ APic agjohnst_ pfoetchen mnoonan mak` woffy mjo acomminos yamadapc kriztw Ralith)
03:43:44 --- names: list (irclogger_com s4msung gcollins luite fingerzam1 DigitalKiwi lpsmith XMunkki_ c_wraith monty joshc___ Shandy posco zopsi niklasb mrlase cynick callumacrae ckw John[Lisbeth] t0m0 saurik OutlawStar ManiacTwister Cathy Guest54293 zudov placer14 sewilton ajmccluskey fuziontech Kneiva solidsnack pikajude pleiosaur tjpeden irishsultan fmapE monokqr gsingh93 brixen fractalcat dzack ReinH lexi-lambda banjiewen nkpart NemesisD mbrcknl wizonesolutions skrio Willis inr)
03:43:44 --- names: list (jonrh mt brolin_empey staffehn esssing zrl Forkk jaj barrucadu kloeri Chousuke_ elgot_ mokus neobrain1 davidthomas gws hegge_ noplamodo_ jcreekmore zerowidth cnr vigs bartavelle DDR Ke canta solatis lieven chelfi tim_s007 hodapp sparr RayNbow`TU jcp noteventime ricardo82 ElderFain funrep reynir andromeda-galaxy Niamkik Bez_ orcus brennie ft ahungry Elsi Ulrar hanDerPeder timloh LoganG jrp6 ljhms friden Ov3rload robtaylor nwf averell thomie mj12` WzC spill4)
03:43:44 --- names: list (sdboyer ido frontendloader Zemyla_ jackhill tomus lispy Jaak vodkaInferno da-x_ arkeet chaptast- davesilva_ aaronweiss74 TallerGhostWalt tolt karls ndeine- surtn- eyenx chirpsalot spion mshenrick [swift] Reyu dasmith91 geal Rodya k3d3 Tril jlouis cin_ TseiTsei mankyKitty AppleJacks24 ironChicken glguy ziman slick giraffe brotknust RaceCondition Jonno_FTW shutdown_-h_now pyrtsa Simson-san jorj monochrom tromp vqrs PHO liste cfloare tsani joehillen kwantam)
03:43:44 --- names: list (Ewout geekosaur capybara hatds shennyg Spaceghost DANtheBEASTman rom1504 jinblack integral SLi Walther agrif aweinstock BrianHV taksuyu cschneid YP-Cloud_ lohkey carc zmanian_ pchiusano leather sephiap edofic Klumben supki richi235 mads- fionnan xintron Shapeshifter cYmen vifon xaotuk tobiasBora hongminhee siddhu Factionwars bydo JRHaigh lf94 __name__ nexsja xacktm timothyh peddie ps-auxw _klm ec\ andjjj23 danieli Atlanis chokboy Myrl-saki hiredman)
03:43:44 --- names: list (petercommand psftw Yaiyan joedevivo Matajon pootler_ arcanine felixsch ggVGc Amnez777 lattenwald newsham andreas303 idupree meretrix johnw Ankhers rje_li fergusnoble tarcwynne_ psacrifi- aaronm04 lpaste haasn s_e happy0 shwouchk_ marmalodak Sigyn kier metaf5 Ongy kmicu d3lxa Tristan-Speccy tristero MarcelineVQ low-profile mountaingoat cdidd alang tomku Excedrin andreass sleezd gargawel cross agm_ gothos sanitypassing hausdorff Purlox spwhitt lachenmayer)
03:43:44 --- names: list (defanor vishesh epta Ring0` greeny gratimax nesqi finninde dxld jamiis Brando753 wanderer Paks pharaun capicue abh_ zerokarmaleft igniting sleepynate pranz notdan ThreeOfEight bergmark tych0 keix cjay zq mxf mero stass megaTherion dpn` suppi vic_ MK_FG cic xanadu_ Hijiri woodne hydraz magicman amiri nikola Eliel_ karshan1 Ravana Belzsch wagle geppettodivacin Baughn levi pixiebot dqd t0mb0 Erebe edwtjo arianvp condy otulp Tiktalik liszt yaknyasn kungp sdx23)
03:43:44 --- names: list (telmich stvc_ maxmo_ Shoggoth joko usr klarrt StoneToad raek Khisanth cmn vpetro magthe hyPiRion myme abra0 dfranke dakrone DrCode orbital_ mceier krakrjak ThePhoeron nurupo Speed Fuuzetsu icicled chrisdotcode eamelink Uakh knyppeldynan jrslepak sz0 quicksilver Freundlich l3france scshunt linduxed nomicflux tumdum Eiam shapr chris2 Jaxan opqdonut Draggor mephx phadej dsantiago maerwald segmond ahihi fengshaun FledRebel nemesit|znc luigy RevJohnnyHealey)
03:43:45 --- names: list (hansili cogrendel arrdem mrowe takeey _flow_ quuxman banjo k4 jotrk myfreeweb Schrostfutz caw Nickeeh pieter__ drdo jibi hvr obcode_ abbe_ crough otterdam darxun horlicks1 ski____ Tehnix`_ kshannon_ vincenz_ tomjagua1paw hbar_ corne Liskni_si stomp_ sjl___ koala_man m1stermag1c ion bjobjo Eagle_Er1in bsermons_ Sagi dwn optocoup1er themaste- obihann_ grandy zemm_ DustyDin1o Athas Jello_Raptor_ luxbock eL_Bart0 fryguybob cheater cocreature yorick rbocquet)
03:43:45 --- names: list (adimit jrib kalloc sokoll Jinxit BigEndian scrazen Plastefuchs SethTisue jyc zymurgy AlainODea kjnilsson mvr_ CARAM__ Tritlo edwardk andreypopp_ katymoe bgyss fedorafan Guest23972 si14 mrd Hafydd pikhq_ Dykam rikkus dhrosa ircbrows- Raynos sbauman Xnuk divVerent Edoxile srhb Nimatek abrar cyberlard Rembane rossberg yarou mechairoi stoned marko____ sLite_ Igloo_ AustinIncognito earthy pdgwien- ]OLI[ parsnip wedify bbee koz_ mattp__ jakutis 20WAACLZ3 Mandus)
03:43:45 --- names: list (kostja martintrojer nshepper1 magbo Jellydog Kaini_ code_crimes squisher theorbtwo epitron padre_angolano nopf dibblego enolan_ ploopkazoo Bashmetim duairc honza melter dbeacham burp_ toon Neseth hsyl20 lyxia deavid cartwright tzaeru shadowdao Adeon ernst aparent lb5tr asm89 ario flan Elision CosmicRay rofer Belgarion0 tnks dstockwell trevorriles jroesch_ alexlord hansihe tharper pkogan_ cstrahan jorendorff louispan Xorlev bigs yminsky alphonse23_ Scorchin)
03:43:45 --- names: list (sisir dkua arnihermann georgew tazjin fboyer bkolera mindos_cloud____ ocharles_ mpickering {AS} xplat|work movedx OliPicard S11001001 carlw2 ikke magically jessicah` joco42 sclv kristjansson Nadrieril TheAuGingembre Tourist SaidinWoT reem trig-ger zpconn__________ chriswk codebam kipd cow-orker stasku__ dixie jud Kruppe solirc tommd kosorith Diabolik biscarch wting anachrome pm5 xeno plog99 gseitz seanparsons LeaChim jlyndon incomprehensibly dustinm Lutin`)
03:43:45 --- names: list (byorgey amingoia etcinit danza-cloud bitonic tlevine crank1988 niteria GGuy robogoat jzl SoupEvil jgertm keemyb hiratara Cr8 zxtx gdsx skarn cjwelborn wolf_mozart dredozubov acfoltzer zxq9 jgornick o`connor xnyhps YellowOnion dschoepe Orion3k wedens qnikst moei KeelOfSteel orion amiller jmct nthxw kaste dcoutts al-damiri tr_ ackthet oberstein pompolic SavinaRoja MoALTz Nik05 zyla przembot Phlogistique jokester phaskell dexterph alkabetz Moto-chan seagreen)
03:43:45 --- names: list (sevas alpounet niluje hive-mind bshelden saep Swizec sa11 dicej Nivim ali_bush Meow-J desc nbouscal mno2 spicydonuts danclien askarpo dmoon1221 elben Oejet tortal sunfun zeroskillor martingale bernalex wolfcore acro _ashbreeze_ rieper rcsgns O7 altphi Cale PlasmaStar tomboy64 kjanosz shesek athan TDJACR hemite_ jb55 augur kipras`away gienah Boney Oxyd Polarina zaquest joeyh AlphaOmicron jack_rabbit bgamari kyren julm hackerfoo korayal Tehnix tokik nathanic)
03:43:45 --- names: list (Xeironis gnusosa tessier dmiles_afk BillyIII l3dx jholtom mpereira kurnevsky maartenpi a0a95251 negatratoron Timberwo|f Sonderblade drmoob Jesin donwilliam demize dreamdust cbm80 akfp Xack z16 Ornedan m4lvin Saimeidae tpsinnem honkfestival jre2 Xandaros cdk libscott evanvarvell nakal_ Lokathor Destol Axman6 MitchW siloxid obiwahn jcurbo dented42 xa0 Benzi-Junior selckin xpxpxpxc sajith mitchty Xe lodin_ mudfog Excureo zv nekomune isenmann m1dnight_ erikd)
03:43:45 --- names: list (besenwesen JPohlmann bitemyapp phaazon M2tias Boreeas jlewis rvncerr lnx shachaf sw1nn Kahva zyoung ChongLi relrod Starfire iross bergey hpd bcoppens glckr _zxq9_ albel727 dh Pucilowski lurker6 saruta subleq gbarboza bjs orzo pkmx djellemah bd_ seliopou dunj3 Maxdamantus larsen mikeplus64 __main__ magnificrab pi__ andrewsw kosmikus sm theDon bencryption gciubot_ SHODAN Dtgr ches noctux guios Black-Wolf lassulus_ dogui julmac pmade octo_ lukky513 whaletechno)
03:43:45 --- names: list (brainproxy betawaffle Rovanion owa chishiki benzrf Cerise sarlalian Akii srcerer psyq Vq MindlessDrone ttuegel catern Madars nont_ Flonk ninedotnine so eikke tgeeky hackagebot)
03:46:06 * hackagebot xdot 0.3 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  https://hackage.haskell.org/package/xdot-0.3 (DennisFelsing)
03:46:08 * hackagebot ghc-vis 0.8 - Live visualization of data structures in GHCi  https://hackage.haskell.org/package/ghc-vis-0.8 (DennisFelsing)
03:48:32 <HoloIRCUser3> Hello. Anybody?
03:48:41 <HoloIRCUser3> Need some help.
03:48:44 <HoloIRCUser3> :(
03:49:23 <pavonia> What is your question?
03:49:48 <HoloIRCUser3> My cabal update keeps failing.
03:50:04 <lwm> HoloIRCUser3 - think about using Stack ;)
03:50:34 <HoloIRCUser3> Well i am seriously pissed right now. >:(
03:50:52 <lwm> lpaste the error ? 
03:50:57 <HoloIRCUser3> tried setting up the damn thing on IntellijIdea
03:51:10 <HoloIRCUser3> but Couldn't.
03:51:28 <HoloIRCUser3> Btw i am a beginner so i don't know what to do.
03:51:41 <HoloIRCUser3> the message was something like
03:52:01 <HoloIRCUser3> "size should be greater thatn >=0"
03:55:34 <pavonia> HoloIRCUser3: Paste the full build log
03:56:36 <HoloIRCUser3> pavonia: how do  i do that? 
03:57:00 <dramforever> HoloIRCUser3: You might have a strange internet connection, Can you download http://hackage.haskell.org/00-index.tar.gz through a browser or something?
03:57:00 <pavonia> By using a pastebin
03:57:07 <dramforever> @lpaste
03:57:07 <lambdabot> Haskell pastebin: http://lpaste.net/
03:58:02 <grayling_> Can someone explan the difference between these two MaybeT transformer packages?
03:58:05 <grayling_> https://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html#g:1
03:58:14 <grayling_> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Maybe.html#t:MaybeT
03:58:32 <Hunter__> would haskell be usefull for a networkand sysadmin?
03:58:33 <HoloIRCUser3> dramforever: yes i can.
03:58:35 <grayling_> Is there a 'canonical'?
03:59:09 <HoloIRCUser3> what is a canonical?
03:59:10 <tdammers> Hunter__: not very, at least not directly
03:59:15 <Hunter__> ok :)
03:59:39 <grayling_> Which one is the one to use for starters. :-)
04:00:07 <tdammers> there are some frameworks for using Haskell as a scripting language, and a few systems programs written in Haskell do exist, but generally speaking, the languages to learn for system administration would be shell script, perl, and python
04:00:40 <HoloIRCUser3> how do i obtain this build log?
04:00:48 <HoloIRCUser3> sorry am a n00b.
04:00:53 <dramforever> HoloIRCUser3: can you try cabal update in a terminal?
04:00:54 <Hunter__> yesthats what i learn actualy but i saw so many people saying that haskell is actualy the language of the futur ;)
04:01:07 <dramforever> What operating system are you using?
04:01:19 <HoloIRCUser3> windows 7 64-bit.
04:01:19 <tdammers> Hunter__: it's a *programming* language; if you're looking for languages that make you a better *programmer*, then Haskell is high on the list
04:01:34 <tdammers> Hunter__: but its uses for system adminstration are limited
04:01:44 <HoloIRCUser3> which terminal? cygwin.
04:01:56 <Hunter__> i guess it would be more usefull on my personal hobby time hehe
04:02:21 <pavonia> grayling_: I don't know the differences between those, but transformers (with mtl) is widely used, so I would probably choose that one
04:02:26 <dramforever> HoloIRCUser3: how did you install haskell? did you get the haskell platform?
04:02:30 <Hunter__> so if i ad to chose from a fonctional language to learn in my spare time haskell is the one to chose right?
04:02:33 <HoloIRCUser3> Yes.
04:02:53 <HoloIRCUser3> i downloaded the platform from the website.
04:03:05 <dramforever> Then just fire up cmd and try cabal update there
04:03:34 <Hunter__> i guess its much of a self learning venture ? no online school teach it ?
04:04:10 <HoloIRCUser3> i did that and it is giving me premature end of stream.
04:04:26 <dramforever> Hmm... do you use a proxy?
04:04:32 <HoloIRCUser3> nope.
04:05:02 <HoloIRCUser3> It is a laptop. Does that affect the process?
04:05:18 <dramforever> Weird, I don't think I know what caused it
04:05:32 <dramforever> HoloIRCUser3: It shouldn't affect the process
04:05:32 <grayling_> pavonia: Yes, I just reached the same conclusion. I just noticed the other package yesterday and it made me wonder about which one to choose.
04:05:34 <HoloIRCUser3> I used mobile hotspot to connect.
04:05:57 <HoloIRCUser3> Well, what can i do about this?
04:07:37 <dramforever> HoloIRCUser3: Wait, still remember the file I told you to download earlier? What's the size of it
04:08:42 <dramforever> It's about 11MB when I just checked at my place. If it's much shorter, then things have gone wrong in the networking bit, which I don't know anything about :/
04:10:17 <HoloIRCUser3> It is 11mb. i downloaded it in chrome and put it on AppData/Roaming/cabal/packages/hackage.haskell.org
04:11:22 <dramforever> Strange situation. I don't have more suggestions :/
04:11:30 <dramforever> Perhaps retry later?
04:11:37 <HoloIRCUser3> cabal is throwing the same error.
04:12:00 <HoloIRCUser3> It is this error. "mallocPlainForeignPtrBytes: size must be >=0"
04:12:16 <HoloIRCUser3> know what this means?
04:13:28 <HoloIRCUser3> any explaination would be fine at this point. :/
04:16:41 <nicow> mallocPlainForeignPtrBytes is an equivalent to C's malloc, so allocating some room in memory
04:17:04 <nicow> you pass it the size you're trying to allocate, but in this case it complains the size can't be negative
04:17:19 <nicow> (it does some checks before allocating)
04:17:40 <nicow> but I'm surprised you get that at compile time
04:18:04 <dramforever> I think the downloaded file might be corrupt
04:18:08 <zants> hi
04:18:27 <nicow> HololRCUser3 have a look at this https://github.com/haskell/cabal/issues/2035
04:19:18 <nicow> looks like it's a problem specific to windows, when using the HTTP library
04:19:44 <nicow> ahhh sorry dramforever, you're way ahead
04:19:52 <nicow> https://github.com/haskell/HTTP/issues/72
04:22:37 <HoloIRCUser3> That wasn't helpful at all. 
04:22:56 <HoloIRCUser3> What should i do right now in plain english?
04:31:47 <grayling_> crough: You online?
04:33:11 <HoloIRCUser3> how can i bypass this cabal update mess
04:34:13 <dcoutts> HoloIRCUser3: if you're using a sufficiently recent version of cabal you can tell it to use an external http program (in powershell iirc)
04:34:56 <dcoutts> or curl would also work on windows, but the powershell one is builtin to windows these days I think
04:36:06 <dcoutts> HoloIRCUser3: cabal --http-transport=powershell update,  if you've got a sufficiently recent version
04:36:16 <dcoutts> and you can set that default in the cabal config file
04:36:57 <jophish> Is it possible to share a scarce resource between two conduits?
04:37:22 <jophish> This seems like something which should be possible, but I can't seem to think of a way to do it
04:38:28 <HoloIRCUser3> can you please simplify it a little bit?
04:38:28 <quchen> What's an "enumeration type" in GHC? Simply an unparametrized type?
04:38:31 <jophish> So I generate a resource and finalizer in IO (or wherever) and I'd like to pass it to two conduits (a source and a sink) which use this resource, and when both of them are done with it it's discarded
04:38:40 <HoloIRCUser3> like what to do after running poweshell
04:39:02 <quchen> Running `tagToEnum# 0# :: Maybe a` complains that it only works with enumeration types.
04:42:34 <HoloIRCUser3> Hello?
04:42:37 <dcoutts> HoloIRCUser3: no no, this isn't about you using powershell, it's about cabal using the http client built into powershell, you run cabal as you did before (either in cmd window or indeed in powershell)
04:42:50 <dcoutts> but use the extra flag like I said
04:43:07 <dcoutts> if it does not recognise the flag, you'll need the later release
04:43:37 <quchen> Hm, looks like an enumeration type is one where all constructors have the same type.
04:49:24 <HoloIRCUser3> now it is throwing unrecognized command "--http-transport"
04:50:59 <HoloIRCUser3> It is using version 1.22.5.0 of the cabal library
05:14:20 <jophish> For what I'm dealing with, an equivalent question is: Is it possible to split a Conduit into a Source and Sink
05:16:04 <HoloIRCUser3> Now it is showing Codec
05:16:10 <HoloIRCUser3> .Compression.Zlib: premature end of compressed stream
05:46:11 * hackagebot ginger 0.1.1.2 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.1.2 (TobiasDammers)
05:47:30 <nchambers> ^ oh hey that looks nice
05:49:08 <tdammers> :D
05:49:10 <tdammers> thanks
05:49:29 <tdammers> comes with some caveats though
05:51:30 <hodapp> huh...
05:54:19 <nchambers> tdammers, oh you wrote it? nice. jinja2 is my favorite html template thingy
05:54:30 <nchambers> cool to see it in haskell
05:56:00 <hodapp> blaaaah HTML
05:56:02 <hodapp> stab it
05:56:50 <tdammers> normally I prefer something typed and more DOM-aware
05:57:13 <tdammers> but when you need to interface with frontend peeps, a template language that is mostly a superset of plain HTML source is very useful
06:05:26 <prati> How to define map as CPS Style ?
06:05:47 <prati> @let { mapNormal f [] = [] ;  mapNormal f ( x : xs) =  f x : map f xs } 
06:05:48 <lambdabot>  .L.hs:156:1: Warning:
06:05:48 <lambdabot>      Pattern match(es) are overlapped
06:05:48 <lambdabot>      In an equation for ‘mapNormal’:
06:05:57 <dkibi> ohheyhi, I have a not supper haskell spezific question: I have a list of sets and want to check if this list is closed under the subset relation
06:05:58 <prati> @undefine
06:05:58 <lambdabot> Undefined.
06:06:00 <prati>  mapNormal f ( x : xs) =  f x : map f xs
06:06:09 <prati> @let { mapNormal f [] = [] ;  mapNormal f ( x : xs) =  f x : map f xs }
06:06:10 <lambdabot>  Defined.
06:06:26 <prati> How to define above map as CPS Style ?
06:07:33 <pavonia> Where were there overlapped paterns? O.o
06:07:47 <muzzle> hi, is there a way in HSpec to expect that no exception is thrown?
06:08:30 <prati> lambdabot is shared between different IRC channels
06:09:02 <muzzle> ?
06:11:47 <dkibi> is there a good/efficient way to do this?
06:14:23 <Jinxit> muzzle: expect the correct result?
06:15:07 <tdammers> all the testing frameworks I am aware of treat exceptions as failures or errors
06:15:14 <Jinxit> ^
06:15:47 <tdammers> so "doesn't throw an exception" is kind of an implicit default assertion
06:16:50 <pavonia> dkibi: Could you explain a bit more? What does closed under the subset relation mean exactly?
06:17:12 <bergmark> i think treating exceptions as failures is a good default...
06:17:59 <bergmark> but at worst, you write a function that exepects an exception?
06:18:03 <lonokhov> o/ any idea why c2hs generates function import with struct pointer as Ptr () ?
06:19:10 <Jinxit> bergmark: that exists
06:19:49 <Jinxit> `shouldThrow`
06:20:04 <lonokhov> hm, c2hs wanted typedef
06:20:28 <prati> Any help on how to define map in continuation style ?
06:20:42 <jatani> What is a good way of avoiding repetition in data definitions? E.g. if I have a 9-tuple that is 9 times the same thing - is there a good idiomatic way of writing this?
06:21:25 <dkibi> pavonia: if A appears in the list and B is a subset of A then B appears in the list too
06:21:53 <Shockk> jatani: you could write a data family that does it, I'm going off the top of my head here but something along the lines of:
06:22:18 <prati> @let mapcps f [] k = k []  -- k is continuation 
06:22:20 <lambdabot>  Defined.
06:22:38 <dkibi> one way to do it would be to generate the union of all powersets of the sets in the list and than compare this to the original list
06:22:54 <dkibi> but this sounds overly complex
06:23:37 <Shockk> jatani: actually, I misread your question, tuple I'm not sure, sorry
06:23:56 <prati> @let mapcps f ( x : xs) k  =  mapcps f xs ( \kxs ->  k (f x : kxs) )  
06:23:57 <lambdabot>  Defined.
06:24:23 <prati> Is that correct ?
06:24:36 <prati> :t mapcps
06:24:37 <lambdabot> (t1 -> t2) -> [t1] -> ([t2] -> t) -> t
06:25:50 <jatani> Shockk, no problem, still -- thank you!
06:29:20 <jatani> Maybe I'm doing something entirely wrong: But a thing with 9 elements where each is either a Char or an Int is best (most easily?) represented as a tuple with Either Int Char, I hope?
06:30:04 <lyxia> that sounds reasonable
06:30:30 <jatani> Okay, thanks! The somewhat ugly redundant definition it is, then. :)
06:31:32 <Profpatsch> How would I access a Microsoft SQL database from Haskell?
06:32:11 <Profpatsch> There is ODBC, but do I need a driver package for MSSQL?
06:33:24 <quchen> jatani: You should probably use your own data type with 9 fields and not a 9-tuple for that.
06:34:20 <quchen> data MyStuff a = MyStuff a a a a a a a a; and then use MyStuff (Either Int Char).
06:34:27 <jatani> quchen, so something like {firstField :: Either Int Char, secondField :: Either Int Char, ...} -- sorry if this isn't what you meant, still learning the ropes. :)
06:34:39 <quchen> Yes, that's what I basically meant.
06:34:44 <jatani> Alright, thanks!
06:35:02 <quchen> Another representation would be as a Vector, but then you wouldn't have the guarantee of exactly 9 elements by the compiler.
06:35:24 <tdammers> alternatively, if the "9 elements" part is a less rigid requirement than "all elements are of the same type", you could use a list
06:35:44 <tdammers> maybe hide it in a newtype and only expose accessors that make sure it remains at 9 elements
06:36:47 <jatani> tdammers, this might be stupid: If it is a list, how could I incorporate the fact that some elements might be Char, others might be Int?
06:37:01 <tdammers> jatani: [Either Int Char] -- no problem
06:37:26 <jatani> tdammers, Oh, just tested that ... yeah. Never thought that this would work. :)
06:37:51 <tdammers> why not?
06:37:59 <Profpatsch> Ah, I probably haven’t understood ODBC enough.
06:38:01 <tdammers> any type can go in a list
06:38:33 <jatani> tdammers, hm, I was probably thinking that since these are two things in one type it counts as two distinct types. This is of course nonsense.
06:38:56 <tdammers> it's not two things in one type; it's one type that is constructed using three other types
06:39:29 <quchen> :t undefined :: [Either (Either [a] (Maybe a)) (a -> b, Either b [b])] -- jatani  :-)
06:39:30 <lambdabot> [Either (Either [a] (Maybe a)) (a -> b, Either b [b])]
06:39:31 <jatani> tdammers, gotcha, thanks!
06:39:49 <tdammers> jatani: you may or may not want to look into "kinds" at this point
06:40:04 <tdammers> it'll either add to the confusion, or clear things up
06:41:28 <jatani> tdammers, I'll give it a try, thanks!
06:41:37 <mniip> :t dimap (maybe (Right Nothing) Left) (either (fmap Just) pure) . left'
06:41:38 <lambdabot> (Applicative f, Choice p) => p a (f a1) -> p (Maybe a) (f (Maybe a1))
06:41:51 <mniip> does that look like a valid _Just :o
06:42:20 <mniip> the prism, that is
06:44:59 <quchen> mniip: Does it do what _Just does?
06:45:07 <mniip> :t \get put -> dimap get (either (fmap put) pure) . left'
06:45:08 <lambdabot> (Applicative f, Choice p) => (a -> Either a2 b) -> (a1 -> b) -> p a2 (f a1) -> p a (f b)
06:45:13 <jatani> quchen, tdammers Man, every time I think I can 'predict' whether something is going to work or isn't (i.e. me VS the type checker, round 2315) I'm still surprised what I don't know. :) 
06:45:39 <mniip> quchen, I have no idea I just derived prisms on a piece of paper
06:46:13 * hackagebot diagrams-svg 1.4 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4 (jeffreyrosenbluth)
06:46:29 <quchen> mniip: So try it out!
06:46:36 <mniip> mobile :(
06:46:45 <Gurkenglas> Is a failing prism allowed to modify what it tried to inspect?
06:46:55 <quchen> ?let mniip = dimap (maybe (Right Nothing) Left) (either (fmap Just) pure) . left'
06:46:57 <lambdabot>  Defined.
06:47:23 <quchen> > Just 5 & mniip .~ 3
06:47:25 <lambdabot>  Just 3
06:47:28 <quchen> > Nothing & mniip .~ 3
06:47:29 <lambdabot>  Nothing
06:47:36 <mniip> \o/
06:47:53 <mniip> it's a traversal though
06:48:16 <tdammers> jatani: it'll get easier
06:48:53 <mniip> > preview mniip (Just 123)
06:48:55 <lambdabot>  Just 123
06:48:57 <dorus_> Hello, I had some questions regarding the google summer of code and after reading the documentation on the wiki I had some additional questions. Is this the right place to ask those (#haskell-gsoc seems abandoned for now)?
06:49:05 <mniip> > preview mniip Nothing
06:49:07 <lambdabot>  Nothing
06:49:15 <mniip> now that's more like it
06:49:52 <quchen> mniip: Every Prism is a Traversal
06:49:59 <mniip> exactly
06:50:08 <mniip> you were checking traversal properties though
06:50:13 <mniip> not prismatic
06:50:31 <mniip> anyway, now to write review/preview
06:51:22 <Denommus> anything similar to opaleye, but dbms-agnostic?
06:52:17 <bergmark> Denommus: not really, persistent and groundhog have multiple backends but don't have much in common with opaleye
06:52:34 <quchen> mniip: The prism laws are in terms of preview/review, so you can't check them without those
06:52:55 <quchen> ATM you have a prism, but not necessarily a valid prism.
06:56:06 <mniip> hmm
06:56:18 <mniip> data P a b = P b
06:56:30 <mniip> does this have a name
06:57:51 <quchen> Tagged
06:57:53 <mniip> :t \p -> runIdentity . unTagged . p . Tagged . Identity
06:57:54 <lambdabot> Not in scope: ‘unTagged’
06:57:55 <lambdabot> Not in scope: data constructor ‘Tagged’
06:58:00 <mniip> :(
06:58:24 <Shockk> http://hackage.haskell.org/package/tagged-0.8.3/docs/Data-Tagged.html
06:58:37 <Shockk> it looks like Const except using the second type rather than the first
06:58:39 <quchen> (Proxy a, b) ~ Tagged a b
06:58:41 <quchen> :t Proxy
06:58:43 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
06:58:55 <mniip> :t \p -> runIdentity . Data.Tagged.unTagged . p . Data.Tagged.Tagged . Identity
06:58:57 <lambdabot> forall (k :: BOX) (k1 :: BOX) c (s :: k) (s1 :: k1) a. (Data.Tagged.Tagged s1 (Identity a) -> Data.Tagged.Tagged s (Identity c)) -> a -> c
06:59:07 <mniip> !
06:59:33 <mniip> review!
07:01:40 <quchen> :-D
07:02:26 <Athas> Which functional languages have compilers/libraries targeting GPU?  I know of Accelerate for Haskell.
07:05:53 <charizard42> hi! can any body tell what are the projects huskell applying this gsoc
07:06:40 <mniip> :t ($ Left)
07:06:41 <lambdabot> ((a -> Either a b1) -> b) -> b
07:06:55 <Wizek> Anyone has any idea why Data.Text.IO's (https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-IO.html) readFile takes String as an argument instead of type Text?
07:07:42 <mniip> :O
07:07:48 <mniip> that's the other one
07:07:54 <mniip> does it have a name
07:08:25 <mniip> Prism s t a b -> s -> Either a t
07:14:55 <geekosaur> Wizek, Text is wrong for filenames
07:15:32 <geekosaur> actually so is String, but nobody wants to believe filenames are not always UTF8 and nobody wants to use ByteString for them
07:16:13 <tdammers> filename semantics are hilariously inconsistent between operating systems, file systems, and other factors
07:16:28 <geekosaur> ...plus that wouldn't be portable, as they should be UTF8 on OS X, UTF16 on Windows, ByteSring on Linuxx/general Unix
07:17:19 <tdammers> well no, you could use Text for anything that uses Unicode in some way, and encode to the appropriate bytestring representation on a per-platform basis
07:17:55 <geekosaur> and what do you do when the filename is *not* Unicode?
07:18:00 <tdammers> well
07:18:12 <tdammers> on utf-8 / utf-16 platforms, that "can never happen"
07:18:14 <geekosaur> "that shouln't happen" is the wrong answer
07:18:16 <arw> tdammers: does Text do any normalization?
07:18:32 <arw> tdammers: and how does Text behave on broken unicode sequences?
07:18:49 <tdammers> vOv
07:19:06 <geekosaur> POSIX file/pah names are yteStrings. there is no encoding information.
07:19:12 <tdammers> correct
07:19:18 <geekosaur> ...wtf keyboard :/
07:19:28 <tdammers> and that is a problem, not just in Haskell, but across the board
07:19:34 <dorus_> Hi I have a question and was referred here from #haskell-beginners. Could someone give me some intuition in what happens internally in GHC when you insert items into a binary tree. From a computer programming point it is considered that a new tree is created every time, but is that also true for the memory layout? I am curious to this in relation to the cache performance
07:19:55 <arw> hmmm. and extremely weird things will happen if one renormalizes things (like macos) or throws away broken unicode sequences (like windows and macos)
07:20:14 <nicow> but FilePath is implemented as a String in haskell, right?
07:20:28 <nitrix> Keep calm and curry on.
07:20:30 <nicow> (I have no context, sorry bout that)
07:20:43 <justin_smith> dorus_: persistent data structures allow append without full copy or mutation of the original, there's a great book on it http://www.amazon.com/dp/0521631246/?tag=stackoverfl08-20
07:20:50 <quchen> dorus_: You can share the common structure of the tree, similar how "1 : [2,3,4]" keeps only one copy of "[2,3,4]" in memory.
07:20:50 <Shockk> implemented is kind of the wrong word, FilePath is just a type alias for String iirc
07:21:11 <nicow> yes my bad
07:21:20 <nicow> represented is what I meant to say
07:21:26 <Denommus> bergmark: I'll give them a look, but something with an ArrowPlus or Alternative interface would be ideal
07:21:37 <Denommus> bergmark: MonadPlus, actually, I guess
07:22:02 <geekosaur> nicow, the portable interface uses String; the unix package provides ByteString native interfaces, and I presume the win32 package similarly provides Text interfaces (although that is less necessary since String does the right thing there)
07:22:34 <tero-> isn't it so that you'd need O(log n) new nodes when inserting something in a (balanced) tree-like data structure?
07:22:41 <davean> amusingly, a String representation isn't all that portable
07:22:47 <geekosaur> yep
07:23:06 <dorus_> justin_smith: Oh okay, and given the trivial implementation of a binary tree with a Sum type to represent nodes and leaves these are "spread" throughout the memory I  similarly to the list being a linked list? So you change the references as it were
07:23:17 <davean> That FilePath thing has caused me no end of annoyances
07:23:22 <dorus_> quchen: Thanks!
07:24:21 <justin_smith> dorus_: the implementation is interesting, there's a cool series of blog posts about the clojure version of vectors that is really good http://hypirion.com/musings/understanding-persistent-vector-pt-1
07:24:59 <justin_smith> maybe someone else here has a similar link for some of the haskell implementations
07:25:36 <justin_smith> dorus_: relevant, I think, because internally the vector is actually a tree
07:25:44 <tero-> hm. it's a bit confusing to use "persistent" instead of "immutable"
07:25:58 <justin_smith> tero-: persistent is an implementation detail of immutable
07:26:06 <justin_smith> it's one way to do immutable data structures
07:26:15 * hackagebot conduit-extra 1.1.10 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.10 (MichaelSnoyman)
07:26:22 <justin_smith> tero-: term comes from the okasaki book I linked above
07:26:50 <dorus_> justin_smith: Thanks for the link, bookmarked it for a session with a nice cup of coffee this weekend!
07:27:51 <quchen> justin_smith: Do you have an example of an alternative to persistence?
07:28:01 <justin_smith> quchen: full copy on write
07:28:04 <tero-> justin_smith: okay. when I hear persistent, I'm thinking of storing data in a persistent storage
07:28:23 <quchen> justin_smith: Oh, and persistence is "copy as much as necessesary on write"?
07:28:24 <justin_smith> tero-: yes, that's unfortunate, but okasaki picked the name, and his book earned him that right :)
07:28:42 <justin_smith> quchen: it means lay out the data such that a minimal amount of copying is done on write :)
07:29:18 <quchen> Oh! I always thought persistence was pretty much the same as … scratch that, I never thought about what persistence means exactly.
07:29:57 <justin_smith> yeah, it's not the word choice I would have used for various reasons, but the cs behind it is awesome, and the book is great
07:30:14 <erbse> any ideas of how to memorize string key without use ref? example I want to call `total_spending :: String -> Integer ` and memorize it's result
07:30:40 <quchen> justin_smith: Okasaki has more papers that didn't make it into that book, what a fine researcher
07:30:53 <quchen> Aren't skew-binary heaps also by him?
07:31:14 <justin_smith> I would need to google to answer that
07:31:38 <quchen> Don't bother, I have to leave :-s
07:31:47 <quchen> Thanks for the "check your definition" though :-D
07:32:15 <justin_smith> heh, well it takes two to turn a misunderstanding into a chance to learn, so yeah, thank you too
07:33:55 <jophish> hmm, I wonder if a NullPtr pattern synonym would be useful
07:37:08 <dorus_> By the way, what kind of level is expected for people to participate in haskell gsoc? I am interested in the hblas project (did some numerical work for my graduate coursework), but am can't really gauge the level people had from previous years
07:49:00 <mniip> :t _Just Left (Just 123)
07:49:01 <lambdabot> Num a => Either a (Maybe b)
07:49:05 <mniip> > _Just Left (Just 123)
07:49:06 <lambdabot>  Left 123
07:49:08 <mniip> > _Just Left Nothing
07:49:10 <lambdabot>  Right Nothing
07:49:12 <mniip> :o
07:50:16 <mniip> :t _Just Left Nothing
07:50:17 <lambdabot> Either a (Maybe b)
07:50:21 <mniip> polymorphic nothing too!
07:54:57 <vektor> http://lambdacube3d.com/getting-started - trying to build the lambdacube sample, I get a "Hello.hs:20:26:     No instance for (FromJSON LambdaCube.IR.Pipeline)" error - possibly my mistake?
07:55:44 <vektor> the relevant code being here: https://github.com/lambdacube3d/lambdacube-gl/blob/master/examples/Hello.hs
07:56:16 * hackagebot judy 0.2.5 - Fast, scalable, mutable dynamic arrays, maps and hashes  https://hackage.haskell.org/package/judy-0.2.5 (MarkWotton)
07:56:22 <vektor> Oh and I should probably point out that the error occured during ghc --make Hello
07:56:53 <dexterph> when using the {-# UNPACK #-} pragma, compiling without -O I get no warnings, however with -O I get several warnings about ignoring unusable unpack pragmas, I understand that they _are_ unusable because you can only unpack fixed precision fields, however why no warning without -O?
07:57:51 <geekosaur> because they're completely ignored when compiling without optimization
07:58:36 <dexterph> makes sense, thanks
07:58:37 <geekosaur> probably doesn't even note enough information to warn about them
08:06:17 * hackagebot vector-th-unbox 0.2.1.4 - Deriver for Data.Vector.Unboxed using Template Haskell  https://hackage.haskell.org/package/vector-th-unbox-0.2.1.4 (HerbertValerioRiedel)
08:11:09 <deni> how do people feel about UndecidableInstances  ? If I'm not mistaken they aren't considered evil as for instance OverlappingInstances is?  right?
08:11:48 <bergmark> i don't think overlapping are necessarily evil either... inccoherent ototh ;-)
08:11:59 <Taneb> deni: the're not evil, but often a sign you're doing something wrong
08:12:22 <mniip> or AllowAmbiguousTypes for instance :)
08:12:40 <deni> Taneb: bergmark I'm just reading some code that's out there and was wondering about it
08:12:54 <deni> people did tell me about the "bad" extensions before but I forget
08:13:01 <deni> so just wanted to check. tnx
08:13:17 <bergmark> deni: if your undecidable instances don't loop and you know why i think you are good :)
08:13:31 <KaneTW> i don't think undecidable instances are bad
08:13:47 <KaneTW> even overlapping/incoherent aren't neccesarily bad, but they require caution
08:13:52 <mniip> yeah undecidables are cool if you don't mind your compiler OOMing or aborting due to a type too complex
08:14:11 <KaneTW> you can thankfully allow overlaps/incoherency at a per-instance level now
08:14:14 <bergmark> the thing that makes undecidable better than overlapping/incoherent is that there's no room for misinterpretation if compilation succeeds
08:14:26 <KaneTW> yeah
08:14:39 <Philonous> I'm trying to return a polymorphic function from an IO action, so I'm enabling Impredicative types and have foo :: IO (forall a. API a -> IO a). However, I can't seem to use the function in a monomorphic context, i.e. passing an API () to it leads to a type error
08:14:43 <Philonous> What am I doing wrong?
08:15:16 <KaneTW> impredicative types are a very unsupported feature
08:15:29 <KaneTW> but anyway
08:16:16 * hackagebot pipes-binary 0.4.1 - Encode and decode binary streams using the pipes and binary libraries.  https://hackage.haskell.org/package/pipes-binary-0.4.1 (RenzoCarbonara)
08:19:09 <mniip> shameless cross-posting: does lens even have a function Prism s t a b -> s -> Either a t
08:20:17 <KaneTW> Philonous: lots of type annotations
08:20:18 <bennofs> mniip: yourPrism Left I think
08:20:25 <mniip> well yes
08:20:31 <bennofs> mniip: but there is no name for that afaik
08:20:36 <mniip> well
08:20:39 <mniip> :t prism
08:20:40 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
08:20:43 <mniip> ^ takes an argument of that ype
08:22:03 <KaneTW> ?let data API a = API a
08:22:04 <lambdabot>  Defined.
08:22:35 <KaneTW> ?let foo :: IO (forall a. API a -> IO a) -> IO (); foo act = do { x :: forall a. API a -> IO a <- act; x $ API () }
08:22:36 <lambdabot>  .L.hs:151:8:
08:22:37 <lambdabot>      Illegal polymorphic or qualified type: forall a. API a -> IO a
08:22:37 <lambdabot>      Perhaps you intended to use ImpredicativeTypes
08:22:44 <KaneTW> well thanks lambdabot
08:22:59 <KaneTW> anyway, the "x :: forall a. API a -> IO a" is required
08:23:12 <KaneTW> including the forall
08:23:51 <KaneTW> if your remove the forall it assumes its types are instantiated somewhere else during type inference but that's not what you want
08:24:05 <mniip> hmm
08:24:08 * mniip has an idea
08:25:13 <Philonous> OK, I'll try that
08:26:20 <sm> good morning all
08:27:19 <sm> FYI hledger will be on FLOSS Weekly today at 1730 UTC (1 hour from now). Watch: http://live.twit.tv, chat: http://irc.twit.tv
08:28:09 <sm> I think it's their first haskell project
08:28:59 <Philonous> Ah, I forgot that -XGADTs implies -XMonoLocalBinds. Now I get tons of type errors. How annoying. 
08:29:15 <Clint> sm: https://twit.tv/shows/floss-weekly/episodes/236
08:30:07 <sm> Clint: ah! phew. Pressure relieved :)
08:30:27 <sm> I'd really like to see a lot more haskell projects on this show, and it's easy: just email randal schwartz
08:36:02 <Philonous> KaneTW, Thanks, that did the trick
08:37:25 <mniip> hmm
08:37:34 <mniip> I wonder if lens has a tutorial fallacy too
08:42:40 <snyp> help me with this: http://paste.debian.net/391960/ ?
08:43:45 <snyp> uh..
08:43:47 <snyp> no wait
08:44:23 <snyp> this: http://paste.debian.net/391961/ 
08:45:17 <nitrix> snyp: You have yet to explain your problem.
08:45:57 <snyp> Given a list of N lists of items, return all the possible list of N items where each the i-th item is chosen from the i-th list (i in [0..N-1])
08:46:30 <snyp> choose [[1,2], [3,4]] will return 2 * 2 =- 4 lists
08:46:59 <snyp> [[1,3],[1,4],[2,3][2,4]]
08:47:38 <mniip> sequenceA
08:47:46 <mniip> > sequenceA [[1,2], [3,4]]
08:47:48 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
08:48:05 <nitrix> Simple applicative sequencing (:
08:48:09 <snyp> oh
08:49:32 <snyp> ah i've got it too
08:49:38 <nitrix> If the solution is too easy, you can try rewriting it in C with nested loops :P
08:49:41 <mniip> if you want, you can write it out
08:50:15 <mniip> :t foldr (liftA2 (:)) (pure [])
08:50:16 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
08:50:24 <snyp> erm.. not quite. http://paste.debian.net/391964/
08:50:28 <mniip> > foldr (liftA2 (:)) (pure []) [[1,2], [3,4]]
08:50:30 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
08:50:52 <mniip> snyp, you're missing the case of cp []
08:51:06 <slaterr> > sequence [[1,2], [3,4]]
08:51:08 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
08:51:28 <snyp> mniip, i see. yeah.
09:09:29 <snyp> so i tried something else, and that too doesn't work. book says there 'doesn't seem to be any clever way of computing cp in terms of other functions'
09:09:50 <snyp> my current one fails when you meet an empty list midway.
09:10:02 <snyp> just saying
09:12:03 <quchen> Is there a way to split a Data.Map in half to perform an arbitrary binary search on it?
09:12:22 <quchen> There are the split* operations, but they don't make any guarantees
09:12:47 <quchen> My use case would be finding the smallest positive unused key
09:13:24 <KaneTW> findMin?
09:13:36 <quchen> That will give me the smallest used key.
09:14:01 <quchen> I can iterate findMin of course, but then I'm doing a linear search.
09:14:38 <bergmark> quchen: split / splitRoot?
09:15:16 <quchen> bergmark: split requires me to provide a key, so I might not hit the middle at all. splitRoot says nothing about the size of the subtrees other than they're ordered.
09:15:44 <KaneTW> https://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#splitRoot
09:15:55 <kadoban> quchen: Isn't a linear search through a sorted list asymptotically optimal for finding the first missing key? I think you'd need a specific tree that's augmented with something extra to do "what's missing" more quickly
09:16:58 <quchen> kadoban: Shouldn't it be doable in log(n) operations? I can detect whether there is a gap in my map by looking at the (min,max) keys and comparing the range to the size of the map. I can then recurse down into one half of the map to narrow the locaion of the gap down.
09:17:57 <kadoban> quchen: If you have the size of every subtree, yeah. But I don't know if the tree Data.Map uses actually has that (for free)
09:18:17 <quchen> It does, nodes are aware of their sizes
09:19:08 <quchen> Data.Map is essentially `data Map k v = Tip | Bin Size k v Map Map`
09:19:23 <quchen> Plus strictness/unpacking
09:20:22 <cocreature> is there a nice way to go from [root,child,child,…,root,child,child,…] to some [a] given a function (root -> [child] -> a)? ofc I can write a fold but I feel like there is some combinator that I’m missing :)
09:20:54 <kadoban> quchen: Well, I guess splitRoot is probably what you want then … though I'm not sure how to reconcile its documentation with that implementation ^  It says it can give you up to 3
09:22:15 <cocreature> hm I guess it’s hard to write something general for that since root and child are the same type
09:22:29 <quchen> kadoban: splitRoot currently gives you [leftHalf, singleton middle, rightHalf]
09:22:34 <kadoban> But yeah it's going to be hard to prove bounds on the resulting thing without relying on … more than the documentation says. Maybe.
09:22:43 <quchen> So it does do what I want, but only coincidentially :-)
09:22:46 <kadoban> quchen: Oh does it? Well that makes sense I guess.
09:23:29 <andrybak> Hello, have anybody had any experience with llvm-general-pure ? If I generated a LLVM.General.AST.Module, how do I print LLVM IR code?
09:24:23 <HoloIRCUser> Okay guys this is the full error log.
09:24:25 <quchen> cocreature: You could split on roots and toList the chunks
09:24:28 <HoloIRCUser> Searching for ghc in path. Found ghc at C:\Program Files\Haskell Platform\7.10.3\bin\ghc.exe ("C:\\Program Files\\Haskell Platform\\7.10.3\\bin\\ghc.exe",["--numeric-version"]) C:\Program Files\Haskell Platform\7.10.3\bin\ghc.exe is version 7.10.3 looking for tool ghc-pkg near compiler in C:\Program Files\Haskell Platform\7.10.3\bin found ghc-pkg in C:\Program Files\Haskell Platform\7.10.3\bin\ghc-pkg.exe ("C:\\Program Files\\Haskell Platform\\7.10.3\\
09:24:41 <HoloIRCUser> Anybody got a clue?
09:25:08 <kadoban> But yeah, as to your actual question … I think that's all that's provided that's close to what you want. So in practice it should work … :-/
09:25:35 <quchen> kadoban: "In practice" I might as well do a linear search :>
09:26:32 <HoloIRCUser> Anybody remember me?
09:26:46 <HoloIRCUser> Cabal Problem dude here... ;)
09:27:01 <quchen> kadoban: Ha, I have a really really stupid and obvious idea. Instead of focussing on searching the map, I can just binary search [1..n] with a predicate that looks at the map.
09:27:02 <cocreature> quchen: the problem is that I then loose the roots or at least their position, ofc I can then zip it again but that’s not very pretty :)
09:27:04 <quchen> ..............silly me
09:27:12 <Stoertebeker> hi
09:27:41 <quchen> cocreature: Then I don't understand the problem. What do you want your function to do?
09:28:03 <cocreature> quchen: I basically want to build a tree from a list representation of a tree
09:28:11 <geekosaur> HoloIRCUser, I lack context but note that your paste got chopped off; IRC has short message length limits. please use lpaste.net for pastes
09:28:29 <HoloIRCUser> Did you guys looked at the error log?
09:28:37 <cocreature> I think I found the right thing in split
09:29:14 <HoloIRCUser> I got this message in cabal while installing foo in verbose mode
09:30:43 <byorgey> HoloIRCUser: did you see geekosaur's message?  Please paste your error log on lpaste.net and give us a link instead of pasting it directly in the channel
09:31:13 <Stoertebeker> I'm trying to foldl on a Data.Matrix row. I neither can't use the Data.Vector.foldl nor the Data.Vector.toList to use Data.List.foldl. The expected type for both is Data.Vector, as Matrix.getRow should return if I understood the docs correctly. What I get now is: vector-0.10.12.3:Data.Vector.Vector which does not match with Data.Vector.Vector. Any ideas on this?
09:31:51 <geekosaur> Stoertebeker, that usually means you have multiple versions of the vector package installed
09:32:45 <Stoertebeker> geekosaur: hm, I just have the ghc package in /Applications (on osx), nothing more. 
09:33:04 <Stoertebeker> Can I access the Data.Vector Data.Matrix brings somehow? 
09:33:11 <andrybak> andrybak : slightly reworking codegen function from this haskell/LLVM tutorial http://www.stephendiehl.com/llvm/ works
09:33:18 <andrybak> andrybak : thanks
09:39:51 <Stoertebeker> geekosaur: well, thank you anyways. I'll have to figure it out by myself then. Cheers.
09:40:05 * geekosaur go pulled into a call, sorry
09:40:10 <geekosaur> (still on it)
09:40:28 <Stoertebeker> nah, np, I'll look around
09:41:23 <kadoban> quchen: Oh, haha using like lookupIndex or something?
09:41:42 <quchen> kadoban: Maybe. This is more complicated than I thought!
09:41:43 <kadoban> I didn't know it had that … should have assumed.
09:43:04 <quchen> kadoban: The main problem for me is that it's a non-local property so the corner cases always kill me
09:43:52 <quchen> And I'm doing this for fun (and because I can't believe I'm finding this so difficult), but nevertheless the result should be easier to read than the simple linear search or I'll file it under "heavily optimized unmaintainable stuff"
09:44:57 <kadoban> quchen: Ah, yeah getting those right can be tough. It should work though it seems to me. It'll be what, like … T(n) = T(n/2) + Θ(lg n) which is … is that Θ((lg n)^2) ?   Well linear search is *really* easy to read, I wouldn't expect this would be easier to read. It could be significantly faster though.
09:45:53 <quchen> I'd like it to be actually faster, not necessarily just asymptotically faster, as well.
09:46:03 <quchen> But that can be remedied by a conditional switch to the linear version I guess.
09:46:50 <kadoban> Well it should be actually faster too I'd think. One thing I'm not totally sure about: how you avoid really bad behavior in the case of a Map with just 1 and 100000000 in it :-/
09:47:58 <kadoban> Honestly I'd probably just use splitRoot, haha. It'd be basically impossible for them to implement splitRoot/the tree in a way that'd make that perform badly for your usage it seems.
09:48:56 <kadoban> Oh wait, you don't need to search through every element 1 to 100000000, just  min-value to min-value + size of map - 1, nevermind.
09:49:36 <dmj> quchen: can you store the keys in a separate Map
09:50:07 <quchen> dmj: Sure, that's what M.keysSet does.
09:51:59 <dmj> quchen: yea, but creating it would be O(n)
09:52:37 <quchen> Hmpf. Okay, debatably yes, because I could initialize it lazily.
09:52:55 <kadoban> How would the separate Set of keys help?
09:52:58 <quchen> But it's redundant anyway, since I can just lookup the keys in my original map and have fast lookup without converting ot a set.
09:53:30 <quchen> I already have a set of keys, where each key carries some redundant information, namely the actual value ;-)
09:53:49 <dmj> kadoban: log(n) lookup for smallest key not found (IIUC)
09:54:00 <dmj> quchen: yes, doesn't seem desireable
09:54:58 <dmj> "smallest positive unused key"
09:55:21 <kadoban> dmj: I don't seem to be seeing it in the docs :-/
09:58:13 <HoloIRCUser1> I got it copied in pastebin instead.
09:58:22 <HoloIRCUser1> heres the link http://pastebin.com/icLi2pxN
09:58:51 <HoloIRCUser1> i got this error from installing foo in verbose mode
09:58:58 <HoloIRCUser1> any guesses?
10:00:18 <geekosaur> HoloIRCUser1, what are you trying to install here?
10:00:52 <HoloIRCUser1> foo
10:00:57 <geekosaur> because I see it wanting very old versions of "base" (which is the ghc runtime and the core modules), but you are using ghc 7.10.3 which includes a very recent base
10:01:26 <HoloIRCUser1> i am trying to install foo-1.0
10:01:32 <geekosaur> which is?
10:01:48 <quchen> Paste the foo.cabal file to lpaste please.
10:01:50 <quchen> ?paste
10:01:51 <lambdabot> Haskell pastebin: http://lpaste.net/
10:02:04 <HoloIRCUser1> lpaste.net is down
10:02:30 <HoloIRCUser1> how do i paste the .cabal file?
10:02:33 <quchen> Not for me. Hmm, alright, then use something else for the time being.
10:02:44 <quchen> You open the file, select everything, copy it, then paste it. :-þ
10:02:49 <geekosaur> not into irc
10:02:53 <geekosaur> use a pastebin
10:03:10 <geekosaur> lpaste is not "down", it is sometimes a bit slow and reports that as "oh, I must be down" --- usually just try again
10:03:33 <geekosaur> (I suspect it needs to be moved to a slighly larger VM instance)
10:04:08 <HoloIRCUser1> open it in what? notepad?
10:05:01 <quchen> For example. (Can notepad handle line endings yet?)
10:07:00 <quchen> .cabal files are ordinary text files.
10:07:11 <quchen> You can view and edit them like Haskell source, for example.
10:07:26 <geekosaur> notepad++ is usually better as a programmer editor anyway https://notepad-plus-plus.org
10:07:49 <HoloIRCUser1> yeah i have notepad++
10:08:01 <HoloIRCUser1> okay i have to go to sleep.
10:08:11 <HoloIRCUser1> will post tomorrow. :)
10:09:54 <quchen> Uhm, okay.
10:11:29 <HoloIRCUser1> bye.
10:16:26 <quchen> ?tell tel You're the maintainer of saltine, no? The docs won't appear on Hackage because of the missing sodium library, maybe upload them manually?
10:16:26 <lambdabot> Consider it noted.
10:21:14 <Xnuk> ;q
10:59:13 <kadoban> Can someone remind me how you trick lambdabot into doing quickcheck tests?
10:59:38 <jophish> svp_: are you behind Graphics.Vulkan?
10:59:41 <FireFly> @check \x -> x == x  -- maybe
10:59:42 <lambdabot>  <hint>:1:45:
10:59:42 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
10:59:49 <FireFly> or maybe not
10:59:55 <FireFly> @check \x -> x == x
10:59:57 <lambdabot>  +++ OK, passed 100 tests.
11:00:02 <FireFly> oh, okay, it just doesn't do comments
11:00:14 <kadoban> Thanks :) Heh yeah that's kinda funny
11:06:45 * hackagebot unordered-containers 0.2.7.0 - Efficient hashing-based container types  https://hackage.haskell.org/package/unordered-containers-0.2.7.0 (JohanTibell)
11:17:27 <lambda-11235> Are dependent types impossible in pure 2010 Haskell (no GHC extensions)?
11:21:54 <geekosaur> true dependent types aren't even possible in ghc with extensions :)
11:23:04 <geekosaur> type level programming is a ghc extension; standard Haskell is limited to type level Peano numbers
11:25:15 <monochrom> 50 years from now, people will say, "every large Haskell program contains a home-made Agda interpreter"
11:26:44 <kadoban> Only hopefully something better than agda has come along by then (not to knock agda, it's cool)
11:27:06 <vektor> with cabal/stack, how do I make it so that a custom command (the lambdacube compiler) is run and the result distributed along with the binary?
11:27:08 <johnw> lambda-11235: in dependently typed languages, the type of dependent functions (pi-types) is a feature of the core meta-theory; if it were implementable in terms of more basic constructs, then maybe Haskell could do it
11:27:47 <kadoban> vektor: I think that's what Setup.hs is for, though I haven't had to play with it and it always seemed pretty funky.
11:28:23 <Cale> geekosaur: Standard Haskell can do type level Peano arithmetic? Since when? :)
11:28:45 <lambda-11235> monochrom: I prefer Idris.
11:28:50 <geekosaur> I did not say "arithmetic", I said "numbers".
11:28:50 <monochrom> kadoban: fortunately, the parallel is not "every large C program contains a Scheme interpreter", but rather, "every large C program contains a Lisp interpreter" :)
11:29:07 <kadoban> Heh
11:29:12 <Cale> geekosaur: Yeah, I suppose you can define Z and S types, but you can't really do a whole lot with them.
11:29:41 <geekosaur> yep
11:30:13 <geekosaur> although iirc people got rather creaive with them before ghc started adding all kinds (so to speak) of type level things
11:31:40 <demize> monochrom: The 10th rule is technically about CL in particular.
11:32:08 <johnw> what were the other 9 laws?
11:32:19 <Cale> They didn't exist
11:32:38 <monochrom> they replace "C" by "COBOL", "Fortran", "PL/1", etc :)
11:32:53 <monochrom> oh, I have a better idea
11:32:55 <demize> johnw: 10 is just easier to remember. :)
11:33:01 <demize> ;)*
11:33:08 <demize> (That is the actual reason.)
11:33:17 <johnw> The 10th law of binary club is the 2nd law of binary club
11:33:40 <monochrom> heh. "there are 10 kinds of people..."
11:34:40 <Cale> actually it seems to cover Fortran already: "Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp."
11:35:10 <scshunt> it's true, too
11:36:37 <hpc> i thought that law was language agnostic
11:36:45 <hpc> (also typing "law was" is a finger-twister)
11:37:20 <monochrom> heh
11:37:29 <mnoonan> "half of Common Lisp" is a disturbingly large quantity
11:37:38 <hpc> also which half?
11:37:53 <hpc> because it could be anything from scheme to CPP
11:37:55 <scshunt> it's never the same half
11:38:14 <monochrom> the "half of what you learned is wrong, and you don't know which half" kind of half.
11:39:43 <monochrom> 98% of people do not know which 98% they are in :)
11:39:55 <Urchin> "informally specified", so you can't know
11:47:07 <jophish> haddock can't find source in dist/build/autogen :/
11:47:24 <jophish> I'm sure this is something really dumb, but I'm not sure what's going on
11:48:00 <monochrom> is it haddock? or is it "cabal haddock"?
11:48:36 <jophish> oops! I am actually missing the source
11:59:07 <mpi_failing> I tried to build my project with mpi, the mpi library is getting installed. Though when I build my project, ghc complains about missing so.12 shared object.
11:59:55 <mpi_failing> any ideas as to how to fix it?
12:00:47 <monochrom> if this is linux or similar, if the mpi library is from the linux distro, there is high probability you also need the "mpi dev" package from your linux distro
12:03:03 <jophish> Is it just me, or has Hackage been pretty bad at generating documentation recently?
12:03:15 <monochrom> I think yes
12:03:35 <monochrom> haha, I mean I think hackage has been bad at docs
12:03:57 <monochrom> there have been a lot of problem reports in haskell-cafe etc
12:04:40 <monochrom> too many to be explained away by the old "you're using a C lib, and hackage doesn't have it" (which used to be the sole cause)
12:05:11 <monochrom> I don't think anyone knows why any more
12:05:34 <mpi_failing> i built the mpi library using openmpi's latest version. haskell-mpi seems to build the .so (i can see it in the sandbox) but not .so.12?
12:06:24 <mpi_failing> openmpi 1.10.2
12:07:01 <mniip> :t \from to -> dimap from (fmap to)
12:07:03 <lambdabot> (Functor f, Profunctor p) => (a -> b) -> (a1 -> b1) -> p b (f a1) -> p a (f b1)
12:07:08 <mniip> @.@
12:07:08 <lambdabot> Maybe you meant: @ .
12:07:13 <mpi_failing> this brings to me the real issue that was kind of bothering me: whats the status of mpi haskell? Should  try to use it?
12:46:54 * hackagebot spir-v 0.0.1.0 - Some utilities for reading and writing SPIR-V files  https://hackage.haskell.org/package/spir-v-0.0.1.0 (jophish)
13:05:10 <Jinxit> is there a reason to upload things to hackage at 0.0.1?
13:06:31 <kadoban> Jinxit: Probably not really except to make sure things are working early. I'm not sure there's a reason *not* to though.
13:07:03 <prooftechnique> It's publish or perish in the package naming world
13:07:22 <prooftechnique> It's very important to upload at 0.0.1 if you have a really good pun you want to lock down
13:07:30 <kadoban> Haha, yeah there's that.
13:07:36 <Jinxit> so basically domain squatters
13:10:21 <prooftechnique> I guess so. I don't remember if anything was ever put in place to actually assign ownership to names.
13:10:46 <prooftechnique> I seem to remember name clash issues a few years ago, but I might be misremembering
13:15:34 <lpaste> jakeehrlich pasted “type variable 't' is quantified over 3 times” at http://lpaste.net/2704410691472719872
13:15:54 <jakeehrlich> so I do not understand the error I get when type checking that
13:16:08 <puregreen> Jinxit: I upload 0.0.1 versions when I have written a library for a project and I want to use it immediately and I want my Travis CI builds to work and I don't want to bother with trying to build the library from Github on the Travis box
13:16:49 <jakeehrlich> namely: I get this “:!$: :: forall t (t :: (* -> *) -> * -> *) t…” which seems to give two diffrent types to ’t’ and quantifys over it 3 times in total
13:17:57 <shachaf> jakeehrlich: It would be useful to include the complete error in your paste.
13:18:17 <jakeehrlich> in comments? or how do you want the error?
13:18:54 <puregreen> jakeehrlich: you can annotate pastes on lpaste
13:19:22 <puregreen> comments are often used as well, tho
13:20:12 <lpaste> jakeehrlich annotated “type variable 't' is quantified over 3 times” with “type variable 't' is quantified over 3 times (annotation)” at http://lpaste.net/2704410691472719872#a152600
13:20:55 <lpaste> jakeehrlich revised “type variable 't' is quantified over 3 times (annotation)”: “No title” at http://lpaste.net/152600
13:21:23 <jakeehrlich> ok well I didn’t know what I was doing but it’s all there now, just not in an ideal form
13:27:28 <exio4> is there anything like replicateM for ByteString(s)?
13:30:40 <jakeehrlich> exio4: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Char8.html#v:replicate
13:31:26 <jakeehrlich> I found it by typing in “Int -> Char -> ByteString” into hoogle btw
13:33:29 <exio4> jakeehrlich: that's replicate, I need something closer to replicateM 
13:33:31 <kadoban> replicate != replicateM
13:33:36 <exio4> > replicateM 3 [1,2,3]
13:33:37 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
13:36:19 <Lokathor> Say i have an action for (RandomGen g, MonadState g m), and my game state contains a randomgen and also player data. Is there a way to adapt my data type somehow so that my existing action can use it?
13:37:06 * hackagebot foldl-transduce 0.5.2.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.5.2.0 (DanielDiazCarrete)
13:37:26 <Lokathor> Or would i just pull some strange newtype magic with a get/set that have built in accessors?
13:38:08 <Cale> Lokathor: I'm not sure I understand what the problem is...
13:39:39 <Lokathor> The action is for RandomGen g, Monadstate g m, but the actual state in the larger program is, say, (Int,StdGen) or whatever, not a bare StdGen
13:40:03 <jakeehrlich> exio4: my bad. I guess “liftM . replicate” works
13:40:56 <Lokathor> I suppose i could make the worldstate an instance of RandomGen.. But i wonder if there is another wau
13:41:17 <Cale> Lokathor: Just extract the component you need?
13:41:18 <exio4> jakeehrlich: er, that's not doing what I want.
13:41:33 <Cale> oh, I see what you mean
13:41:54 <Cale> Yeah, maybe don't use the MonadState class.
13:42:18 <Lokathor> Yeah, might have to go that route
13:42:57 <Lokathor> Or i could do a sub-computation inside the larger state computation :P
13:43:01 <Cale> Lokathor: If you want to continue with the class-based approach to abstracting things, you could use MonadRandom, and write an instance of that for whatever monad it is you're actually using.
13:43:31 <Lokathor> Interesting. I was not aware of that typeclass
13:43:37 <Lokathor> I will go look it up
13:45:02 <exio4> jakeehrlich: I tried using BS.pack <$> replicateM n xs but it's using all my memory as I traverse it, I don't know why
13:45:19 <jle`> Lokathor: you can do (MonadRandom m, MonadState s m)
13:45:25 <jle`> to abstract away the state and the randomness
13:45:47 <jle`> your game state shouldn't contain the randomgen
13:46:42 <Lokathor> Shouldn't?
13:46:53 <jle`> the only time that would make sense is if it were something you could take out and inspect within the game ... but ... for the most part, you'd just want to treat it like an ambient entropy source/stream
13:46:55 <Cale> It's fine if the actual record you're passing around ultimately contains a StdGen or whatever. It's just a matter of how you abstract over the operations which are available.
13:47:26 <jle`> in the end you might want to bundle around the StdGen with your game state, for purposes of serialization maybe, idk
13:47:37 <jle`> but i don't think it'd be too bad to just leave them as two separate things
13:47:52 <Lokathor> Ah, well i see what you mean
13:47:55 <jle`> when i think of game state i think of the state of the game logic
13:48:04 <Cale> Personally I think the mtl's MonadFoo classes are usually the wrong idea for applications and something more specific about what operations are available on the particular state you have in mind would result in better-looking code.
13:48:09 <jakeehrlich> exio4: so liftM . replicate *seems* to work for me. 
13:48:31 <exio4> jakeehrlich: that is doing something else.
13:48:39 <jakeehrlich> what is it doing?
13:48:47 <Cale> Of course, you should also consider whether there is really more than one monad you're abstracting over
13:48:59 <Cale> An abstraction over exactly one thing isn't terribly helpful.
13:49:25 <jle`> if you had (MonadRandom m, MonadState s m), you can get a 'free' instance with `StateT s (Rand StdGen)`, if you ever decide to run it
13:49:27 <Lokathor> I'd like to write the various dice rolling funcrions in as much of a reusable way as possible is all
13:49:32 <jle`> or you can make your own GameType
13:50:04 <Lokathor> I think MonadRandom might be the simplest way to do that
13:50:16 <jle`> newtype GameType a = GameType (State SuperStateWithGen a) or something, and then write a MonadRandom instance that involves updating the stdgen inside the game state
13:50:31 <jle`> but writing things to work with MonadRandom now should be just fine
13:50:39 <jle`> you can think of the actual type you're going to be using later
13:51:20 <jakeehrlich> > (liftM . BS.replicate) 5 (return 72) >>= print
13:51:22 <lambdabot>  <IO ()>
13:51:51 <Lokathor> Yeah, i just wasnt sure how well a "wrapped" state could work in the presence of actions written before a particular wrapping
13:51:53 <exio4> > liftM (BS.replicate 2) [42,47,50]
13:51:55 <lambdabot>  ["**","//","22"]
13:52:11 <exio4> > replicateM 2 (map chr [42,47,50])
13:52:13 <lambdabot>  ["**","*/","*2","/*","//","/2","2*","2/","22"]
13:52:25 <jakeehrlich> that isn’t quite the same thing is it?
13:52:26 <exio4> jakeehrlich: ^ different functions.
13:52:52 <jle`> fwiw, you can write actions on a small 'part' of your global state, and then lift them to work/compose with functions in your big state using 'zoom' from lens
13:53:02 <jakeehrlich> > runIdentity $ (liftM . BS.replicate) 5 (return 72)
13:53:04 <lambdabot>  "HHHHH"
13:53:09 <jakeehrlich> that is what I have been doing
13:53:14 <jle`> for example, if your state as (Int, Bool), you could write a State Int a, and zoom _1 :: State Int a -> State (Int, Bool) a
13:53:30 <jle`> i have heard of this approach being used for situations like this
13:53:52 <jakeehrlich> which is what I expect
13:53:52 <Lokathor> "Zoom". I will keep that one in mind
13:54:12 <Shockk> I'll keep that in mind as well, always find out interesting stuff when lurking #haskell
13:54:13 <jle`> so a hacky bandaidy way of doing what you originally wanted was zoom _1 :: State StdGen a -> State (StdGen, GameState) a
13:54:14 <Jinxit> zoom is amazing
13:54:27 <jakeehrlich> exio4: also I expect the same output for your case as well. what output do you expect?
13:54:29 <jle`> but i'd definitely use something other than State to manage random generators
13:54:47 <Lokathor> Its like lift, but probably less stable! :3
13:54:49 <jle`> zoom-with-giant-state-monad is nice but i really feel like it doesn't scale
13:55:00 <exio4> jakeehrlich: what? 
13:55:04 <jle`> Lokathor: yeah, it's a monad morphism like lift, just a different kind of lift :)
13:55:18 <Shockk> jle`: I also wondered that 
13:55:21 <jle`> `zoom l` should follow all the typical monad morphism laws that lift does
13:55:24 <jakeehrlich> exio4: I expect the output you get to be the one you want but you do not. what output do you want?
13:55:27 <jakeehrlich> > runIdentity $ (liftM . BS.replicate) 5 (return 72)
13:55:27 <Shockk> (if it scales well with large data structures in State)
13:55:28 <lambdabot>  "HHHHH"
13:55:49 <jle`> yeah.  not performance-wise, but maintainance wise
13:55:51 <jakeehrlich> runIdentity $ (liftM . BS.replicate) 5 [72, 73, 74]
13:55:57 <jakeehrlich> > runIdentity $ (liftM . BS.replicate) 5 (return 72)
13:55:58 <lambdabot>  "HHHHH"
13:56:03 <jle`> the problem of scaling up this approach was one of the things my 'auto' libray was written to potentially address
13:56:10 <jakeehrlich> > runIdentity $ (liftM . BS.replicate) 5 [72, 73, 74]
13:56:12 <lambdabot>      Couldn't match type ‘[]’ with ‘Identity’
13:56:12 <lambdabot>      Expected type: Identity Word8
13:56:12 <lambdabot>        Actual type: [Word8]
13:56:18 <jle`> but i'm not quite sure i'd recommend it for a full scale game myself becuase i've had trouble applying it to games in real life
13:56:27 <jakeehrlich> > (liftM . BS.replicate) 5 (return 72)
13:56:28 <lambdabot>      No instance for (Show (m0 BSC.ByteString))
13:56:28 <lambdabot>        arising from a use of ‘show_M75699269804509843742725’
13:56:28 <lambdabot>      The type variable ‘m0’ is ambiguous
13:56:38 <exio4> jakeehrlich: do you know what replicateM/replicateA does?
13:57:26 <Lokathor> Theres a lot of tricky edges to abstracting games because games are often as diverse internally as they are to the player
13:58:30 <Shockk> I wonder if there are already any haskell bindings for amazon's game engine thing (lumberyard)
13:58:44 <Shockk> I thought about doing that but I don't have a lifetime of free time
13:58:52 <Jinxit> it's just a wrapper around cryengine
13:58:53 <jakeehrlich> exio4: no. no I did not. It does something 100% diffrent from what I thought
13:58:56 <jle`> it'd be nice to have a lifetime of free time
13:58:58 <anks> what is the efficient way of converting a number into a ByteString?
13:59:02 <jakeehrlich> I apologize
13:59:51 <Lokathor> I dabbled in some curses bindings the other day. Working well so far
14:00:09 <anks> will it be Data.Binary?
14:00:46 <jle`> anks: it depends on what sort of encoding you want
14:01:57 <jle`> the encodings in Data.Binary and Data.Serialize are somewhat specialized for specific applications
14:02:05 <jle`> they aren't meant to be general-purpose encoders
14:02:39 <anks> so what is the general solution? 
14:03:22 <jle`> it depends on what you want to do with the bytestring
14:03:26 <jle`> do you want to just throw it away?
14:03:38 <jle`> in which case, `const mempty` works :P
14:04:05 <jle`> do you want a bytestring that is the utf8-encoded string representation?
14:04:12 <jle`> of 'showing' the number?
14:04:32 <jle`> do you want something you can store opaquely for the purpose of later reading/loading?
14:04:50 <jle`> you can see that there are a bunch of reasons why you'd want to convert a number to a bytestring
14:05:06 <jle`> and lots of completly different things you might want to do with that bytestring
14:05:24 <jle`> are you planning on hashing the bytestring in a deterministic way?
14:05:29 <jle`> etc.
14:05:46 <osfameron> it feels like there's a missing function between group and groupBy
14:06:05 <jle`> one specific example: if you want to put the utf8-encoded "shown" number, you can do T.encodeUtf8 (T.pack (show n))
14:06:25 <jle`> that'll give you a bytestring that is the utf8 encoding of the number shown, that you can send over a terminal protocol or something
14:07:09 <osfameron> e.g. I want:  groupX fst   (instead of having to construct something like groupBy (\a b -> fst a == fst b)
14:07:20 <jle`> if you want to store the number as an opaque binary blob that can later be re-decoded, you can use binary/cereal
14:07:27 <anks> Ok, thanks for the extensive response :), i think ill need the last solution
14:07:33 <jle`> osfameron: groupBy ((==) `on` fst)
14:07:50 <osfameron> jle`: ah yes, that rings a bell!  thanks
14:07:59 <jle`> anks: yeah, if you want to encode it to a binary blob that you can later decode, you can use Data.Binary or Data.Serialize
14:09:24 <anks> ok, thanks, jle`  :)
14:09:39 <jle`> np!
14:09:44 <anks> this made it brighter 
14:10:01 <jle`> the important thing to remember in this is that the binary format that binary/cereal produces isn't meant to be read or used by any other application
14:10:18 <jle`> so you wouldn't use this to say, communicate with a network protocol that expects a specific binary format
14:10:28 <Shockk> only loosely related to haskell, but I learned about basic constraint programming today in a game AI class, it was pretty interesting because I've never heard of that kind of programming before
14:10:45 <davean> jle`: you can do that. Iv'e doen a decent bit of that with bytes
14:10:57 <davean> jle`: you just have to understand the library a very little bit
14:11:10 <jle`> i'd consider it outside of the purpose of the library
14:11:19 <jle`> it's like saying you can do integer addition by working with Strings
14:11:22 <jle`> but that's not the point of strings
14:12:38 <jle`> it's better to use the appropriate tool for the appropriate situation, I think
14:12:49 <davean> Its closer to trying to do signed arithmetic with unsigned values
14:12:59 <davean> It has all the right operations, you just have to make sure you configure it correctly
14:13:23 <jle`> yeah, but you're sort of abusing a tool for something it wasn't meant for, when there are perfectly good tools that do the job correctly
14:13:30 <jle`> and are designed for that job, with that job in mind
14:14:13 <vlad___> has anyone gotten "cannot satisfy -package" errors with stack?
14:14:15 <jle`> it's possible, but you're basically working against the system at that point
14:14:15 <davean> jle`: what do you think would be better?
14:14:36 <jle`> for reading binary protocols, attoparsec
14:14:47 <davean> uh, ok
14:14:56 <davean> I strongly disagree
14:15:00 <davean> I'll take bytes any day
14:16:17 <jle`> i'd consider using bytes for communicating with external protocols an abuse of the library
14:16:25 <jle`> even if it works
14:16:26 <mpickering> Are there any good guides to debugging happy parsers? The only advice I have seen is to look at the info file but it isn't obvious as all to me where the shift/reduce conflict actually comes from
14:16:52 <davean> jle`: Ok, I'll just go take my code back out it, I guess I was wrong about what its for.
14:18:13 <tommd> I'm all for using binary/cereal/bytes for external protocols.
14:18:52 <davean> They're perfect for it
14:19:59 <tommd> Indeed.  PacketBB? Sure.  TLVs? No problem.  Basically any IETF protocol is really obviously / directly implementable.
14:20:37 <tommd> And the fact that cereal's first "selling point" was keeping up with a 1Gbps NIC is rather telling of the intent.
14:20:42 <davean> as for not the purpose, I specificly remember that being discussed in bytes' design
14:21:29 <jle`> hm, i guess it's fine to use Builder and Get/Put, just not the typeclass Binary/Serialize/Serial mechanisms, which are the opaque serializers/deserializers
14:21:32 <davean> If you count my direct reports, I think I had 3 of those
14:21:38 <davean> er, misschan
14:22:12 <tommd> jle`: Ah, yeah.  Using the typeclass is rather not the highlight of those libraries imo.
14:22:18 <davean> jle`: they instances can't change except at major versions
14:22:30 <jle`> yeah, but the instances are intended for opaque serialization
14:22:36 <jle`> not external protocols
14:23:15 <tommd> The 'Serialize' or 'Binary' instances are in that mode, but the wide array of build/parse operations and the Get/Put monads are great.
14:23:19 <davean> they're the logical ones for those types as they're usually found in the wild
14:23:23 <davean> check if they're the ones you arleady need
14:23:30 <davean> if so, use them, otherwise make a custom wrapper
14:23:48 <davean> The Haskell specific ones are whatever is convinient
14:24:27 <davean> If you learn the instances, and build up your own instances, you'll get cleaner code
14:24:36 <jophish> no idea what you're talking about, but don't forget cbor
14:25:50 <davean> jle`: Can I point you to http://hackage.haskell.org/package/bytes-0.15.2/docs/Data-Bytes-Serial.html#g:2 ?
14:26:11 <davean> jle`: you'll notice thats SPECIFICLY for specifying endianness, an issue ONLY pressent when dealing with external formats
14:26:18 <davean> and specificly for the purpose of using the instances
14:27:08 * hackagebot pipes-transduce 0.3.4.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.3.4.0 (DanielDiazCarrete)
14:27:55 <jle`> hm, this has opened my eyes wrt bytes
14:29:43 <jle`> thanks
14:31:47 <davean> jle`: There might very well be a better representation for binary protocols, which would be interesting to know. I really doubt we're any where near as good as handling them can be in haskell
14:32:07 <davean> jle`: if you think on it and come up with any ideas for better options I'd be interested
14:33:07 <jophish> davean: do you mean, protocols for using in external programs?
14:33:16 <jophish> or protocols for (de)serialization only
14:33:31 <davean> the later? I don't know what you mean by the first
14:33:44 <davean> in?
14:33:46 <jophish> what you were talking about with the endian encoding
14:34:06 <davean> jophish: ending encoding is a core component of serialization format specification
14:34:15 <davean> different systems have different byte orders
14:34:17 <jophish> davean: you may be interested in this http://code.haskell.org/~duncan/binary-experiment/binary.pdf
14:34:43 <davean> jophish: what about it?
14:34:51 <jophish> davean: yes, but it doesn't matter as long as you're consistent
14:35:00 <jophish> davean: it's an improvement on binary/cereal
14:35:06 <davean> jophish: yes it does
14:35:10 <davean> it does matter, a lot
14:36:02 <jophish> I think there's been a misunderstanding. you said yourself "an issue ONLY pressent when dealing with external formats"
14:36:17 <davean> First you don't inherantly get a choice. Second, it matters for performance.
14:36:30 <davean> when your order matches you can just DMA
14:36:35 <davean> in theory
14:36:50 <jophish> hah, not too easily into most Haskell data structures
14:37:17 <davean> Depends on what you want, Storable for instance ...
14:37:52 <davean> though I'd hardly recomend that
14:38:53 <jophish> anyway, I thought you'd be interested in CBOR as a 'better option' for binary protocols in haskell
14:39:07 <davean> I ahve no idea how its "better"
14:39:20 <jophish> that's explained in the slides quite well
14:39:26 <davean> I read them just now
14:39:28 <davean> and I've read the RFC
14:39:33 <davean> meh?
14:40:23 <jophish> the speeds they get are certainly an improvement
14:40:26 <davean> I mean, when something uses CBOR, its great!
14:41:02 <benzrf> does forever run into issues with Cont
14:41:09 <benzrf> what with strictness
14:42:33 <davean> jophish: I mean, the implimentation is better
14:45:05 <mgsloan> @tell vlad___ Are you using an old version of stack?  There's a bug that was fixed which could cause that error: https://github.com/commercialhaskell/stack/issues/1498
14:45:05 <lambdabot> Consider it noted.
14:46:26 <davean> jophish: let me put it this way, CBOR requires added data
14:46:47 <davean> jophish: thus is must be, on a theoretical level, slower - trivially.
14:47:05 <davean> jophish: any time CBOR is faster, it is a deficite in the custom format, as the custom format could always BE CBOR.
14:47:25 <davean> jophish: this is not a result about how good CBOR is, but how bad those libraries were
14:48:09 <davean> jophish: which I'll agree, Haskell does not have amazing (de)serialization options
14:48:42 <jophish> well, you've also got to take into account programmer time, I think that each one of Binary/Cereal/CBOR do very well at optimizing for
14:49:30 <jophish> I think haskell's got the best serialization options of any language I've used by miles
14:50:30 <jophish> of course, that's a subjective statement in a field with many dimensions of quality
14:50:46 <davean> Yes
14:52:21 <davean> I'd say Haskell still has more boilerplate then some other things I've seen
14:54:14 <davean> Linking up the format wiht the type, and the slots in the type ...
14:54:25 <jophish> Something I was searching for recently was a way to describe an isomorphism between ByteStrings and a Type in one go
14:54:27 <lexi-lambda> Hey: I was looking at Spock’s routing and it uses a type called Append that appends two type-level lists. Where does this Append type come from?
14:54:32 <davean> Definately better when one can just annotate the datastructure directly
14:54:32 <lexi-lambda> The relevant line is here: https://github.com/agrafix/Spock/blob/2e46e6ec699a9f25b98622b86a62cd1d2fec3d79/src/Web/Spock.hs#L285
14:54:39 <jophish> rather than describe both directions separately 
14:54:45 <jophish> (partial isomorphism*)
14:54:50 <davean> jophish: there are options there
14:55:07 <jophish> davean: yeah, I found a few, none really did it for me though
14:55:22 <davean> jophish: boomerange and such?
14:55:30 <davean> For defining both
14:55:46 <jophish> yeah, I looked at boomerang, it didn't want to work very well for Bytestrings
14:55:49 <davean> but nothing in Haskell lets me avoid the boilerplate between type and encoding 
14:56:14 <davean> jophish: yes, but even when there are solutions like that, tehy don't adress what I was refering to
14:56:52 <davean> now, enough Generics, and such and one might get there, at great cost
14:57:04 <davean> I'd hate to work with the haskell code that resulted
14:57:51 <jophish> that's a bit like saying: I'd hate to work with the assembly my C compiler spits out
14:57:59 <davean> No?
14:58:04 <davean> I think you missed what I'm talking about
14:58:18 <davean> again, I'm talking *annotating*
14:58:28 <davean> which I can't do in haskell
14:58:31 <davean> but other languages allow
14:58:44 <jophish> oops, I've got to go now. I'll chat later!
15:12:17 <Nuxular> Hi, how come, after using "import qualified Data.List", the interpreter is complaining that 'lookup' is ambiguous giving the lookup from Data.List as one of the possible meanings?
15:14:16 <Nuxular> also, if I type ':t lookup' in the interpreter itself, I get no such ambiguity complaint
15:15:26 <Welkin> because lookup is in Prelude
15:15:54 <Nuxular> ah
15:15:56 <Welkin> ghci also acts differently than ghc itself
15:16:05 <Nuxular> ok
15:16:05 <Welkin> some behavior is not the same
15:16:08 <davean> Welkin: The Prelude and the Data.List lookup functions are the same function, from GHC.List
15:16:11 <Welkin> to really check your programs, compile them
15:16:13 <Nuxular> import Prelude hiding (lookup) fixed it
15:16:38 <davean> Nuxular: after that, where does it say lookup is from?
15:17:08 <Nuxular> from my Main, as expected
15:17:24 <davean> oh, then thats the conflict!
15:17:27 <davean> you defined lookup
15:17:33 <davean> it doesn't have to do with Data.List
15:19:45 <Nuxular> davean, yes, I misread the error message
15:20:45 <Nuxular> C:\XXX.hs:49:8:
15:20:47 <Nuxular>     Ambiguous occurrence `lookup'
15:20:48 <Nuxular>     It could refer to either `Main.lookup',
15:20:50 <Nuxular>                              defined at C:\XXX.hs:12:3
15:20:51 <Nuxular>                           or `Data.List.lookup',
15:20:53 <Nuxular>                              imported from `Prelude' at C:\XXX.hs:1:1
15:20:54 <Nuxular>                              (and originally defined in `GHC.List')
15:20:56 <Nuxular> Failed, modules loaded: none.
15:21:23 <Nuxular> I just read the part where it says 'Data.List.lookup' and presumed it was because I was importing Data.List
15:21:48 <Nuxular> cheers
15:22:30 <shachaf> Please don't paste so much code in the channel. You can use hpaste.org.
15:22:39 <Nuxular> sorry
15:24:20 <synergistics> What's going on with this type signature? :
15:24:32 <synergistics> :t (>>= (+1))
15:24:33 <lambdabot> (Monad m, Num (m b)) => m (m b) -> m b
15:25:01 <Zekka|Sigfig> synergistics: It’s possible that there’s some *particular* parameterization for your monad that gets you a Num
15:25:26 <geekosaur> synergistics, it's telling you that if you can somewhere find a type that has both Monad and Num instances, that function will be well typed
15:25:41 <Zekka|Sigfig> Like, if you made [Int] Num, then you could specialize that to [[Int]] -> [Int], but you couldn’t specialize it necessarily to [[Char]] -> [Char]
15:25:41 <geekosaur> it makes no promises that such a type exists
15:26:47 <synergistics> Zekka|Sigfig: So I could only apply (>>= (+1)) to functions that take what (+1) can result in?
15:27:13 <synergistics> > (>>= (+1) (\x -> return (x * 3))) 1
15:27:15 <lambdabot>      No instance for (Show (m0 b0))
15:27:15 <lambdabot>        arising from a use of ‘show_M75492804651904377684738’
15:27:15 <lambdabot>      The type variables ‘m0’, ‘b0’ are ambiguous
15:28:28 <synergistics> > ((+ 1) >>= (\x -> return (x*3))) 3
15:28:29 <lambdabot>  12
15:28:31 <emmanuel_erc> Hello there everyone?
15:28:35 <emmanuel_erc> sorry nvm
15:28:39 <synergistics> Hi
15:29:50 <synergistics> geekosaur: Is that the Num (m b) part?
15:30:01 <Zekka|Sigfig> synergistics: You can only apply that to values of a monad type where, if you `join`, you get a Num
15:31:02 <Zekka|Sigfig> Your type was: (Monad m, Num (m b)) => m (m b) -> m b
15:31:22 <Zekka|Sigfig> “m” is a type constructor that takes one type to get you a new type
15:31:36 <Zekka|Sigfig> so m could be [] or Maybe or Either String or a bunch of other things
15:31:49 <synergistics> Right
15:31:53 <Zekka|Sigfig> b is the particular type that’s two levels deep in your monad
15:32:13 <Zekka|Sigfig> you could have [[b]] -> [b] or Maybe (Maybe b) -> Maybe b or Either String (Either String b) -> Either String b
15:32:36 <Zekka|Sigfig> The Num constraint is just a stipulation that Maybe b, Either String b, or [b] be a Num
15:33:00 <Zekka|Sigfig> Probably that will not make sense for your program: you more likely meant to make b a num, in which case you want something like fmap (+4) or liftM (+4)
15:33:16 <synergistics> Zekka|Sigfig: Maybe b will be a num or the "b" in Maybe b is one?
15:33:26 <geekosaur> synergistics, "Maybe b"
15:33:30 <Zekka|Sigfig> synergistics: (Maybe b) will be required to be a num
15:33:31 <geekosaur> Num (m b)
15:33:35 <geekosaur> does not mean Num b
15:33:51 <synergistics> Ok, I get how that wouldn't make sense
15:33:54 <Zekka|Sigfig> If you want to require b to be a num, you can get a mapping (Monad m, Num b) => m b -> m b using liftM
15:34:11 <geekosaur> synergistics, but it *can* make sense. there have been Num instances for lists, for example
15:34:13 <Zekka|Sigfig> But you’re saying Monad m, Num (m b) => m (m b) -> m b
15:34:34 <Zekka|Sigfig> You could make [()] a Num, which gets you a particularly strange way to count. But I wouldn’t advise it
15:34:38 <geekosaur> and in that situation, the function you presented would be well typed and might even do something useful
15:35:17 <synergistics> Zekka|Sigfig: So a function that works on Nums can act as an instance of Num?
15:35:28 <synergistics> Zekka|Sigfig: Because the function is the monad here, isn't it?
15:35:31 <Zekka|Sigfig> synergistics: That is not really accurate, because a function cannot be an instance of a typeclass
15:35:35 <Zekka|Sigfig> A function also can’t be a monad
15:35:39 <synergistics> Oh?
15:35:54 <Zekka|Sigfig> Monad is the group of type constructors that take a type and give you a new type, where the new type supports all the monad operations
15:36:04 <Zekka|Sigfig> So Monad is a question you ask about a type — it’s not a type and it’s not a function
15:36:22 <Zekka|Sigfig> (you could also say Monad-ness is a property of a type constructor)
15:36:45 <Zekka|Sigfig> A typeclass instance is a typeclass instance, you can’t refer to it as a value and there’s usually only one for a particular typeclass/type pair.
15:36:50 <Zekka|Sigfig> Neither of those things are functions
15:37:46 <zd234> is ghc 8.0.1 currently scheduled for early march or late feburary ?
15:37:56 <geekosaur> march
15:38:10 <geekosaur> a third rc is considered pretty much necessary a this point
15:38:12 <Zekka|Sigfig> synergistics: Sounds like it might help you to make sure you understand typeclasses
15:38:30 <Zekka|Sigfig> it kind of sounds like you have the broad idea but I’d try to make sure
15:39:16 <synergistics> Zekka|Sigfig: I'll go over what I know. But I get that a function can't be a monad, I was thinking too fast
15:39:35 <Zekka|Sigfig> Typeclasses are different from types — a typeclass named Foo with methods x y z is a statement that “if you support x y z, you’re a foo”
15:39:45 <zd234> geekosaur: noted; thanks
15:39:51 <Zekka|Sigfig> A typeclass constraint is a question like “Is this thing a foo?”
15:40:16 <Zekka|Sigfig> Foo a => a -> a “If an `a` is a Foo, this maps `a`s to `a`s”
15:40:58 <Zekka|Sigfig> So (Monad m, Num (m b)) => m (m b) -> m b says “If m is a Monad and (m b) is a Num, this maps (m (m b))s to (m b)s”
15:43:49 <fortress_> I have a function that returns a Maybe type, which is list of tuples of length 1 or 2. What is the proper way to determine which length of list is returned by the function, in another function? For example, I'm currently just looking an the length of the list (1 or 2), but I think there must be a better way
15:43:55 <synergistics> Zekka|Sigfig: Before I continue, is it correct to call the children of both types and typeclasses "instances", or only typeclasses?
15:44:09 <fortress_> to clarify: the list of length 1 or 2, and contains tuples
15:44:26 <scshunt> fortress_: you can pattern match on it
15:44:29 <synergistics> Zekka|Sigfig: Like is "Just 1" an "instance" of Maybe, or something else?
15:44:32 <scshunt> or create a new sum type and pattern match on that
15:44:33 <Zekka|Sigfig> synergistics: I don’t think it’s wrong to call a member of a type an instance, but I think in Haskell it’s confusing
15:44:50 <scshunt> synergistics: Just 1 is a value of type Maybe Int
15:44:54 <Zekka|Sigfig> I usually call it a value, like “a value of type Maybe Int”
15:44:56 <monochrom> you can say "value"
15:44:57 <scshunt> it has nothing to do with instances
15:45:03 <synergistics> Ok
15:45:06 <Zekka|Sigfig> Well, it could totally be a Maybe Float, but that’s not really important
15:45:12 <fortress_> scshunt: thank you :) I will learn pattern matching now
15:45:23 <kadoban> fortress_: "Maybe [a]" is kind of a funny type. You might consider using "fromMaybe []" to convert it to just a [a]
15:46:04 <geekosaur> synergistics, values are not typeclass members. types are typeclass members.
15:46:16 <kadoban> It's funny because there's two ways to represent "got nada". Nothing and Just [], which both usually mean the same thing (unless they don't in your case)
15:46:44 <fortress_> kadoban: I'm unfortunately not allowed to change the portion of the code that implements the Maybe function
15:46:51 <fortress_> (class assignment)
15:47:17 <Welkin> fortress_: will you be struck across the knuckles with a yardstick?
15:47:46 <kadoban> fortress_: Well, you can do it in the place you use it. The alternative would be doing something like just pattern matching, and it's up to you if you consider Nothing and Just [] different.
15:49:25 <fortress_> Welkin: LOL. Much worse, I'm afraid. I would fail the assignment instantly
15:50:51 <geekosaur> some TA assigned to check it and does so "mechanically"
15:51:22 <fortress_> geekosaur: pretty much.
15:51:35 <geekosaur> (or, there is an actual point to that type that will be used in a future assignment. I can certainly think of cases where Nothing and Just [] would be necessarily distinct)
15:53:24 <fortress_> actually, I might have miscommunicated what is actually going on. Here is the code that is "written in stone": http://pastebin.com/QuneWWGY
15:53:33 <zd234> are type funcitons turing complete?
15:53:36 <zd234> if not, what are their limitations
15:54:00 <monochrom> an example is parsing a string that you expect to contain a list of numbers, and the empty list is legal. then you can't use [] for both "parse error" and "no parse error, it's the empty list". you have to use Nothing for parse error.
15:54:02 <fortress_> Basically, I'm writing a function to determine the type of move that was played, and I either need to grab the first tuple, when it's PawnPlacement, or the last tuple, when it's Normal
15:54:39 <fortress_> Currently I'm just checking the length of the list. But I know that this is stupid
15:55:31 <geekosaur> monochrom, indeed. or "data not provided" vs. "data was empty". ("Absence of evidence is not evidence of absence.")
16:02:41 * hackagebot NumberTheory 0.1.0.0 - A library for number theoretic computations, written in Haskell.  https://hackage.haskell.org/package/NumberTheory-0.1.0.0 (cfredric)
16:04:10 <crossroads1112> How would I implement Serialization for a data structure that has a Monad in the declaration e.g. data RoseTreeT m a = Node a [m (RoseTreeT m a)]
16:04:42 <geekosaur> I would think you wouldn't, unless you did it free-monad style
16:04:48 <geekosaur> erialization is for concrete types
16:05:02 <mniip> unquantified that is
16:27:32 <megaTherion> how do I explicitly cast the output of a function to 16bit (eg. Word16)?
16:28:30 <kadoban> :t fromIntegral :: (Int -> Word16)
16:28:31 <lambdabot> Int -> Word16
16:28:56 <kadoban> No idea what it does when you overflow … probably just truncates maybe?
16:29:02 <megaTherion> thats what I want
16:30:08 <pavonia> > (fromIntegral :: Int -> Word16) $ 2^16
16:30:09 <lambdabot>  0
16:32:42 * hackagebot haskell-neo4j-client 0.3.2.1 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.2.1 (asilvestre)
16:37:08 <megaTherion> kadoban: can I somehow bind this to my function instead of using fromIntegral?
16:37:18 <megaTherion> in essence I want to add this to the existing type signature of my function
16:38:40 <kadoban> megaTherion: I mean, you can use fromIntegral internally in your function, and change the type of the function.
16:38:54 <kadoban> megaTherion: What is the function, is it concise and easy to share?
16:39:46 <megaTherion> kadoban: Im trying to create an crc16 table gen, obviously everything past 16bit is useless to me... but I fail at change the existing function type
16:39:58 <megaTherion> my type is "poly :: (Num a, Bits a) => a -> a
16:40:02 <megaTherion> so not really complicated
16:40:56 <kadoban> megaTherion: Well, I mean you can just treat that as if it were Word16 -> Word16, or you could change the type of it to that. I'm not sure if either of those apply.
16:42:26 <megaTherion> I tried things like :: (Num a, Bits a) => Word16 a -> Word16 a -- however thats not going to work
16:42:44 <megaTherion> casting doesnt seem to be that easy in Haskell :|
16:43:01 <shachaf> Casting is for wizards.
16:43:12 <kadoban> megaTherion: Well that type signature doesn't make a lot of sense :-/   Word16 is a type. You'd have to remove the constraints and just change it to Word16 -> Word16
16:43:13 <megaTherion> (maybe because you shouldnt cast usually, but well in practice things are different)
16:43:14 <pavonia> You don't cast in Haskell, you explicitly convert between different types
16:44:27 <megaTherion> pavonia: I see
16:47:43 * hackagebot coverage 0.1.0.4 - Exhaustivity Checking Library  https://hackage.haskell.org/package/coverage-0.1.0.4 (NicolasDelPiano)
16:55:04 <Lokathor> I have a lot of functions that all have "(Integral i, Random i, MonadRandom m) =>"
16:55:22 <Lokathor> what I want to say is, "type RandIntegralMonad m = (Integral i, Random i, MonadRandom m) => m", but I seem to have forgotten some extension or be doing it wrong
16:55:36 <johnw> drop the "=> m"
16:55:50 <johnw> and you'll need a forall i. in there, which may not work
16:55:51 <Gurkenglas> Doesn't he need the i in the type?
16:56:46 <Lokathor> i do
16:57:04 <Lokathor> type RandIntegralMonad i m = (Integral i, Random i, MonadRandom m)
16:57:10 <Lokathor> I also needed ConstraintKinds
16:58:38 <Lokathor> and now we get nicer signatures like, rollxdy :: (RandIntegralMonad i m) => (i,i) -> m i
17:01:27 <benzrf> is there some function like: amounts "abaabbc" = [('a', 3), ('b', 3), ('c', 1)]
17:01:29 <Gurkenglas> Doesnt need the first set of brackets
17:02:06 <Lokathor> but they're such curvy brackets that it's appealing to the eye
17:02:07 <Gurkenglas> :t M.toList . M.fromListWith (+) . map (,1) -- benzrf
17:02:08 <lambdabot> (Num a, Ord k) => [k] -> [(k, a)]
17:02:46 <benzrf> haha, nice
17:06:06 <pavolzetor> why does ghc 7 not work with LLVM 3.7?
17:06:09 <khumba> map (length &&& head) . group . sort, arrows for the win :).
17:06:15 <pavolzetor> I am getting some metadata error
17:06:59 <benzrf> :t M.values
17:07:00 <lambdabot> Not in scope: ‘M.values’
17:07:01 <benzrf> :t M.vals
17:07:02 <lambdabot>     Not in scope: ‘M.vals’
17:07:02 <lambdabot>     Perhaps you meant ‘M.valid’ (imported from Data.Map)
17:07:06 <benzrf> what's the function?
17:07:28 <shachaf> Maybe you can discover it in /msg.
17:07:38 <benzrf> Thank you very much, shachaf.
17:08:51 <shachaf> /msg lambdabot @hoogle Map k a -> [(k,a)] and /msg lambdabot @hoogle Map k a -> [a] are some thing you could try depending on what function you're looking for.
17:14:00 <verement> > M.toList $ foldr (\c a -> M.insertWith (const (+1)) c 1 a) M.empty "abaabbc"
17:14:02 <lambdabot>  [('a',3),('b',3),('c',1)]
17:14:42 <ijmustafa> Hey guys, what's the fastest way to generate a scatter plot of a list of points in the following format [(x1,y1),(x2,y2)...(xn,yn)]
17:16:02 <pavolzetor> if I try ghc 8 with 7.10.2 packages I get failed to load interface error for vector and binary-ieee754
17:19:15 <evincar> ijmustafa: "chart" looks pretty good. https://github.com/timbod7/haskell-chart/wiki
17:20:50 <bitemyapp> ijmustafa: Another option: https://github.com/tepf/QuickPlot
17:20:53 <evincar> ijmustafa: QuickPlot (https://hackage.haskell.org/package/QuickPlot) was recently announced, though it's not very mature.
17:21:23 <evincar> I daresay no Haskell plotting library is "very mature", though.
17:21:31 <evincar> Apart from diagrams, which is lower level.
17:21:34 <ijmustafa> evincar: I was looking at chart but I couldn't find any tutorials on it. 
17:21:58 <ijmustafa> bitemyapp: I tried that but I was having trouble getting it to actually display on my browser. It kept timing out
17:22:05 <Eduard_Munteanu> ijmustafa, you could generate input for gnuplot rather easily
17:22:08 <evincar> ijmustafa: I would try playing around with the examples on that wiki.
17:22:15 <Eduard_Munteanu> Or use one of the gnuplot libs.
17:22:37 <bitemyapp> ijmustafa: sorry, I don't know much. Probably be more reliable to use something more established.
17:23:17 <ijmustafa> evincar: Ah yes, I see the examples. Thanks!
17:23:53 <ijmustafa> bitemyapp: Yeah I figured. It looks like it has a lot of potential though 
17:34:57 <tech-enthu__> Hello everyone, Currently I am working on week7 of cis194 haskell course
17:35:04 <tech-enthu__> I am facing an issue while coding indexJ, here is the link to code: http://lpaste.net/152620
17:35:10 <tech-enthu__> has anyone worked on this earlier and would like to help?
17:37:23 <shanemikel> for the successor function given in http://www.brics.dk/RS/01/10/BRICS-RS-01-10.pdf, does anybody know how to write a numeral function to that effect that will take Num as first arg and still typecheck?
17:38:14 <shanemikel> I don't want to spend the $45 on the full version in the cambridge journal just yet
17:40:01 <bitemyapp> ijmustafa: it does seem to have a lot of potential. Could you file an issue about your bug with the author please?
17:40:46 <ijmustafa> bitemyapp: yup will do!
17:41:15 <shanemikel> what's up bitemyapp .. I'm still working on your book
17:42:58 <shanemikel> (Maybe you already do) but I think it would be good to include some of the exercises from https://wiki.haskell.org/Typeclassopedia , and recommend https://wiki.haskell.org/Research_papers/Functional_pearls to your readers
17:43:31 <shanemikel> I'm getting a lot out of those articles, myself
17:43:33 <bitemyapp> shanemikel: we do recommend some papers and pearls in the book; not a ton.
17:43:41 <bitemyapp> shanemikel: I can't just lift other peoples' exercises.
17:43:45 <bitemyapp> We link the Typeclassopedia
17:43:50 <bitemyapp> but I can't just take their shit
17:43:55 <shanemikel> oh, didn't notice
17:44:02 <Eduard_Munteanu> bitemyapp, what book are you writing?
17:44:08 <shanemikel> haskellbook
17:44:10 <shanemikel> .com
17:45:18 <Eduard_Munteanu> Oh, I do remember seeing this some time ago... quite a bit of progress.
17:47:34 <dogcat> does anyone know of any DSLs in haskell that use final interpreters?
17:47:40 <dogcat> or tagless?
17:48:03 <Xnuk> Can I make any better version of `reverse . dropWhile f . reverse . dropWhile f`?
17:49:08 <Eduard_Munteanu> Xnuk, for Text, there's dropWhileEnd
17:50:04 <Eduard_Munteanu> Similarly if you can work with Seq.
17:53:40 <nitrix> @let data Test = A { xA :: Int } | B { xB :: Int }
17:53:40 <xacktm> when using readMaybe to convert a String to a Maybe Word16, does it treat hexadecimal digits as valid?
17:53:41 <lambdabot>  Defined.
17:53:55 <nitrix> > xB $ B 5
17:53:57 <lambdabot>  5
17:53:59 <nitrix> > xA $ B 5
17:54:01 <lambdabot>  *Exception: No match in record selector xA
17:54:14 <nitrix> Why is that even allowed... that's nasty.
17:54:26 <xacktm> actually, I could just test that in ghci
17:54:45 <Eduard_Munteanu> nitrix, because it can't tell the difference at compile-time
17:54:57 <Eduard_Munteanu> Except for trivial cases like that.
17:55:17 <Eduard_Munteanu> :t (A 5, B 5)
17:55:18 <nitrix> Eduard_Munteanu: I understand the why, I'm more curious as why it's allowed in the first place.
17:55:18 <lambdabot> (Test, Test)
17:55:25 <HoloIRCUser> Okay geekosaur here is the foo.cabal file that you asked for yesterday. 
17:55:28 <HoloIRCUser> http://pastebin.com/tzKVeMuc
17:55:38 <nitrix> Sum types of records should be a big no, no?
17:55:58 <HoloIRCUser> Is geekosaur here right now?
17:56:27 <Eduard_Munteanu> Admittedly you could wrap a projection in Maybe.
17:56:44 <Eduard_Munteanu> Or you can catch the exception.
17:56:56 <HoloIRCUser> hello,  anyone?
17:57:01 <geekosaur> your cabal file looks fine. do you have any constraints in ... hm where does windows put the per-user cabal config
17:57:24 * geekosaur is here ... and in 20ish other channels
17:57:35 <geekosaur> (and upgrading and rebooting linux boxes...)
17:57:59 <HoloIRCUser> I just saw a config file in useres/user/AppData/Roaming/cabal/
17:58:05 <nitrix> Eduard_Munteanu: Can GHC catch that those are partial?
17:58:40 <HoloIRCUser> Is this the per user config file.
17:58:56 <HoloIRCUser> looks like i'm in the ninth circle of cabal hell 
17:58:59 <HoloIRCUser> ;)
17:59:04 <geekosaur> sounds approximately like the right place
17:59:13 <Eduard_Munteanu> nitrix, partial how? It should be able to catch using a projection on the wrong constructor.
17:59:17 <geekosaur> but it would not by default av constraints, so if that is your hell then it is self-inflicted
17:59:24 <shanemikel> nitrix: will the lens library do that for us?
17:59:29 <geekosaur> *have constraints
17:59:46 <shanemikel> or Eduard_Munteanu 
17:59:47 <Eduard_Munteanu> lens already provides that.
18:00:57 <geekosaur> HoloIRCUser, also, remove the haskell98 dependency. base and haskell98 have been incompatible for some time (and maybe that is your problem here)
18:00:59 <Eduard_Munteanu> https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references#Prisms (via quick google)
18:02:03 <Eduard_Munteanu> :t preview
18:02:04 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
18:03:51 <geekosaur> and ghc 7.10 doesn't even support haskell98 iirc; the Foldable/Traversable changes were incompatible with it
18:05:04 <shanemikel> anybody know how to complete the definition of `numeral`? http://lpaste.net/3305594684281192448
18:08:54 <Eduard_Munteanu> shanemikel, numeral 0 = zero; numeral n = succ (numeral (n - 1))    ?
18:09:10 <shanemikel> Eduard_Munteanu: doesn't type-check
18:09:20 <nitrix> How would I implement that the player in my game can switch between entities? It sounds strange, but it's a crucial game mechanic. You can actually 1st person any NPC and "become them". Normally in C, I'd have a data structures of entities, fine, then a pointer to which one is "you".
18:09:35 <shanemikel> so that's the real question, how to complete it, and what sig to give it
18:10:23 <Eduard_Munteanu> Oh, I see.
18:13:07 <Eduard_Munteanu> @let s = undefined :: ([b] -> c) -> [a -> b] -> [a] -> c
18:13:09 <lambdabot>  Defined.
18:13:17 <Eduard_Munteanu> :t s id
18:13:19 <lambdabot>     Ambiguous occurrence ‘s’
18:13:19 <lambdabot>     It could refer to either ‘L.s’,
18:13:19 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:155:1
18:13:24 <Eduard_Munteanu> :t L.s id
18:13:25 <lambdabot> [a -> b] -> [a] -> [b]
18:13:34 <Eduard_Munteanu> :t (L. s (L.s id))
18:13:35 <lambdabot> Not in scope: data constructor ‘L’
18:13:36 <lambdabot>     Ambiguous occurrence ‘s’
18:13:36 <lambdabot>     It could refer to either ‘L.s’,
18:13:40 <Eduard_Munteanu> :t (L.s (L.s id))
18:13:41 <lambdabot> [a -> a1 -> b] -> [a] -> [a1] -> [b]
18:13:56 <HoloIRCUser> How do i remove the dependencies? 
18:14:15 <HoloIRCUser> why were they created in the first place?
18:14:30 <Eduard_Munteanu> :t L.s (L.s (L.s id))
18:14:31 <lambdabot> [a -> a1 -> a2 -> b] -> [a] -> [a1] -> [a2] -> [b]
18:15:18 <HoloIRCUser> I unregistered base by using..
18:15:24 <geekosaur> AAAAA
18:15:32 <HoloIRCUser> ..ghc-pkg unregister base.
18:15:36 <geekosaur> nice
18:15:39 <geekosaur> reinstall the compiler now
18:15:43 <Eduard_Munteanu> :)
18:15:57 <HoloIRCUser> why did you scream?
18:16:05 <geekosaur> because you just broke the compiler
18:16:20 <HoloIRCUser> you mean the haskell platform?
18:16:24 <geekosaur> ghc
18:16:33 <geekosaur> "base" is wired in and includes ghc's runtime
18:16:47 <HoloIRCUser> well i got ghc from the platform.
18:17:08 <HoloIRCUser> do i have to download standalone version now..
18:18:12 <HoloIRCUser> Also how do i remove haskell 98 dependency?
18:19:20 <jmcarthur> nitrix: The way you'd do it in C sounds similar to how I'd do it in Haskell. I'm not really sure what you are asking for.
18:20:06 <shanemikel> Sorry computer died
18:20:15 <geekosaur> by editing the cabal file to not list "haskell98" in build-depends
18:20:41 <geekosaur> also, you can either reinstall the Plaform, or deinstall it completely and install a standalone ghc
18:21:04 <geekosaur> then you have to install modules yourself, though, and that can be a nightmare on Windows
18:21:36 <HoloIRCUser> Shit
18:21:50 <HoloIRCUser> I am on WINDOWS :""""(
18:22:35 <HoloIRCUser> foo.cabal file right?
18:23:56 <geekosaur> yes, foo.cabal
18:34:14 <synergistics> What exactly does (a -> b) construct?
18:34:53 <synergistics> Like in the type declaration of a function, what is the result of "Int -> String" or "(->) Int String"
18:35:33 <geekosaur> i being a type declaration, what it is constructing is a type (or part of one)
18:36:27 <synergistics> Yea, but what's the significance of a type to a function?
18:37:02 <synergistics> So  "Int -> String"  is a type, but how is that useful?
18:37:31 <HoloIRCUser> Will this problem be fixed by then?
18:37:40 <synergistics> s/significance of a type/significance of that type
18:38:06 <geekosaur> HoloIRCUser, did you reinstall the haskell platform? if not, you're shortly going to get even stranger errors
18:38:24 <HoloIRCUser> i will reinstall it ..
18:38:32 <HoloIRCUser> and get back to you.
18:39:59 <pavonia> synergistics: It tells you what input values your function accepts and what possible outputs values it has
18:41:54 <HoloIRCUser> Okay i reinstalled it. now what?
18:42:18 <geekosaur> HoloIRCUser, also I don't know if this will fix it. it wanted base 4.3 which seems a bit old even for haskell98, unless it's looking for a haskell98 compatible with base (I didn't think there was enough dependency info for that)
18:43:37 <geekosaur> but if you've removed the haskell98 dependency then you ca ry it again. hat said, if you used "cabal init" then it may have put the dependency in there because of haskell98 flat modules used in your Haskell code (for example "import List" instead of "import Data.List") in which case you would need to update the code
18:43:39 <Ralith> Is it possible to use a newtype in unboxed arrays and vectors without writing a bunch of boilerplate?
18:47:04 <schoppenhauer1> http://ufal.mff.cuni.cz/~straka/papers/2009-perarray.pdf ← is there an implementation of these for haskell?
18:47:07 <HoloIRCUser> i did not use "cabal init"
18:48:01 <schoppenhauer1> (I know about diffarrays, but these are more than diff arrays)
18:55:59 <jmcarthur> synergistics: If you already understand why it is useful for values to have types, then I'd say the reason functions have types is because they are values.
18:57:52 <Enigmagic> Ralith: https://hackage.haskell.org/package/vector-th-unbox-0.2.1.4
18:58:44 <dfeuer> schoppenhauer1, I'm struggling to find in Straka's paper any clear description of what he achieves *compared to his predecessors*. Am I missing something, or does he just expect others to read the full reference list and compare themselves?
18:59:11 <schoppenhauer1> dunno.
18:59:37 <nshepper1> synergistics: the significance is that if `f :: a -> b` and `x :: a` then `f x` is valid (well typed) and has type `b`
19:00:31 <nshepper1> and so on, with such rules for the type inferencer
19:00:47 <schoppenhauer1> i was just amazed by the runtime classes he gave
19:02:38 <caw> Is there a canonical way to generate lists (finite or not) of random numbers?
19:05:33 <glguy> randoms 07<$> newStdGen 07:: Random a 07=> IO [a]
19:06:11 <EvanR> fancy
19:06:45 <Gentilhomme> what's the <$> for? (haskell beginner here)
19:11:07 <glguy> <$> is the infix name for fmap. In the case of IO like this f <$> m is an action that when executed executes m and then returns f applied to the result of executing m
19:11:34 <glguy> newStdGen is an action for constructing a new random number generator state
19:11:52 <glguy> randoms is a function from random number generator states to "infinite" lists of random numbers
19:12:27 <HoloIRCUser> geekosaur?
19:12:43 <bitemyapp> Eduard_Munteanu: http://haskellbook.com/
19:12:49 * hackagebot kanji 1.0.0 - Perform "W (National Kanji Exam) level analysis on Japanese Kanji.  https://hackage.haskell.org/package/kanji-1.0.0 (fosskers)
19:12:58 <bitemyapp> Eduard_Munteanu: not just me though, have a coauthor named Julie - a linguist. Haskell is her first programming language.
19:16:21 <geekosaur> HoloIRCUser, have you tried rebuilding the package again to see what happens?
19:18:16 <xacktm> Hi, I have a list of operations (do operation with x and y then store into y) which represents a recursive dependency tree.  The problem I'm having is a simple recursive lookup for a value is duplicating work and making execution time blow up.  How can I store these intermediate values (without a global variable that is) so that they are availble to all sub and super recursive lookups?
19:18:32 <xacktm> er do opertion with x and y and store into z*
19:19:25 <xacktm> the list also has definitions for x and y, etc
19:21:10 <Gentilhomme> ok thanks glguy 
19:22:49 * hackagebot nanq 3.0.0 - Performs "W (National Kanji Exam) level analysis on given Kanji.  https://hackage.haskell.org/package/nanq-3.0.0 (fosskers)
19:23:43 <chenduo> hello, I am a haskell newbie
19:24:16 <Welkin> hello 陈多
19:24:21 <xacktm> right now my recursive funciton is type eval :: String -> HashMap String Operation -> Word16, where the hashmap maps from the resulting z to the operation x y z
19:24:41 <caw> Thanks glguy :)
19:25:00 <Welkin> xacktm: paste your code and someone may help you
19:25:02 <Welkin> @lpaste
19:25:02 <lambdabot> Haskell pastebin: http://lpaste.net/
19:26:25 <xacktm> right, I'm ssh-ed in so this may be tricky - I'll ask again later when I'm home
19:38:32 <Wizek_> Anyone might know of a lib that enables specifying a template just like https://hackage.haskell.org/package/here-1.2.7/docs/Data-String-Here-Interpolated.html 's `template` function, but instead of resulting in String, return Text?
19:39:54 <Wizek_> Meaning loading and type-checking the template file at compile time
19:41:24 <KaneTW> Wizek_: you could clone it and adjust so that it returns text
19:42:34 <KaneTW> you likely won't get around a Text.pack call though
19:42:41 <KaneTW> so you might as well just use that
19:43:37 <KaneTW> there should be a rewrite rule that makes String literal -> Text fast
19:44:00 <KaneTW> Wizek_: https://hackage.haskell.org/package/text-1.2.2.0/docs/src/Data-Text-Show.html there is
19:44:06 <KaneTW> "TEXT literal"
19:50:01 <HoloIRCUser> how do i rebuild the packagegeekosaur: how do i rebuild the package?
19:52:11 <Wizek_> KaneTW, okay, I might actually do that if there is no package available that returns Text.
19:52:50 * hackagebot NumberTheory 0.1.0.1 - A library for number theoretic computations, written in Haskell.  https://hackage.haskell.org/package/NumberTheory-0.1.0.1 (cfredric)
19:53:04 <Haskell> are you still online? geekosaur
19:54:05 <Wizek_> Haskell, Interesting name of choice. What would you like to build? Is it perhaps `cabal build` that you want to do?
19:58:16 <Wizek_> Hmm, what could cause an empty .prof file output when trying to profile?
19:58:33 <Welkin> did you compile with profiling enabled?
19:58:40 <Wizek_> stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto -rtsopts -fforce-recomp" --exec "`basename "$PWD"` ./documents/1200-nodes.brainxml  +RTS -p -RTS"
19:58:56 <Wizek_> As far as I can tell I did
20:02:09 <Wizek_> Welkin, it looks like I did, didn't it? The .prof file is indeed updated (has a current time-stamp) but its length is 0.
20:02:31 <Welkin> dunno, I don't have much experience profiling
20:02:38 <Welkin> I only did it a few times, so I don't remember how it works
20:16:00 <Gentilhomme> any good reference to learn category theory?
20:16:16 <Welkin> Lawvere's Conceptual Mathematics
20:16:56 <silky-nvds> Gentilhomme: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
20:26:56 <Gentilhomme> how about Awodey's category theory?
20:34:06 <tempay> Hey guys - can someone walk me through adding dependencies to a Stack project?
20:34:54 <tempay> Like, how I go from seeing a package on Hackage to adding it to a 'stack new' project 
20:35:15 <tempay> I guess I have to add it to the .yaml and the .cabal and import it in the code?
20:35:50 <kadoban> tempay: Sure, it's really pretty easy: just add it to the build-depends: section in the .cabal file, for whichever part of the code you want
20:36:22 <kadoban> tempay: Like usually the library, or if you want to use it in the executable section directly, you can add it there instead (or in addition, whichever applies).
20:37:13 <tempay> kadoban: So if I'm building an application that needs to use hmatrix, for example, I just add hmatrix in my cabal file and it should build?
20:37:52 <kadoban> tempay: Yep. That's usually it. If the package isn't in the stack resolver you're using, then you have to specify an exact version in the stack.yaml (in extra-deps), but it'll complain if that's the case.
20:38:34 <tempay> kadoban: So I only mess with stack.yaml if it's not in the resolver, which it usually is if I use an LTS or nightly
20:39:06 <kadoban> tempay: Exactly. Most stuff I use is. On bigger projects there's like 1 or 2 that aren't and thus need to be specified.
20:39:20 <tempay> kadoban: Awesome. Thanks for you help :)
20:39:39 <kadoban> You can also use stuff that's not even on hackage, that just requires a bit more intricate stuff in stack.yaml. It's not particularly hard either though, just have to look up the syntax really.
20:39:41 <kadoban> 'welcome
20:45:22 <ggVGc> how do I write this better? maybe (return ()) (send outConn . MidiMessage 0) outEvent
20:45:59 <jle`> mapM_ (send outCon . MidiMessage 0) outEvent
20:46:35 <ggVGc> thanks
20:46:44 <ggVGc> maybe one day I'll learn to actually use monads
20:46:44 <jle`> np!
20:46:55 <jle`> this is more about Foldable/Traversable than Monad
20:46:58 <ggVGc> I tried using fmap and failed, but figured I was just doing something wrong
20:47:01 <jle`> Maybe is a Foldable, so you can mapM it
20:47:03 <ggVGc> yeah, true
20:47:04 <jle`> er, mapM_ it
20:47:20 <Hafydd> If you're writing code involving this, but you're not "actually using monads," I'm concerned for your health.
20:47:51 <Welkin> ggVGc: monads are simple
20:47:58 <Welkin> you should know better
20:48:04 <Welkin> I have seen you around here for a good year or so
20:49:05 <jle`> be friendly ;_;
20:50:26 <ggVGc> Welkin: yeah, I know monads are simple. what I meant is that I often forget how to utilise that things are foldable/traversable, but I accidentally wrote monad instead
20:51:49 <ggVGc> is it heresy that I've defined a forward pipe operator like this? outEvent \> mapM_ (send outConn . MidiMessage 0)
20:52:30 <kadoban> Doesn't that already exist, (&) or something?
20:53:02 <kadoban> :t (&)
20:53:15 <jle`> it's in Data.Function, yeah
20:53:27 <lambdabot> a -> (a -> b) -> b
20:53:42 <kadoban> Heh, lambdabot seems a bit slow at the moment.
20:55:08 <jle`> not sure what you gain from writing it that way, though
20:57:54 * hackagebot not-gloss 0.7.6.4 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.4 (GregHorn)
20:57:58 <ggVGc> jack_rabbit: just reads a lot better to me. Also, I first started FP in OCaml, so I like the forward piping style
20:58:08 <ggVGc> jle`: ^
20:58:10 <ggVGc> sorry, wrong highlight
20:58:13 <jack_rabbit> np
20:58:21 <jle`> hm
20:58:40 <kadoban> I consider (.) kind of terribly backwards, but I've grown used to it I guess at this point.
20:58:44 <jle`> well, be aware that it'll make your code a but more unreadable for other people
20:58:50 <jle`> s/but/bit
20:59:07 <ggVGc> I didn't know about &, guess I'll start using that more now
20:59:19 <ggVGc> although & doesn't convey "piping" to me
20:59:47 <jle`> you're free to write your code however you want, but writing code that differs vastly from established idioms sort of leads you on a certain path
21:00:06 <ggVGc> yep
21:00:35 <ggVGc> jle`: so, this is essentially the reason I started doing it. This is how I usually think about FP, so it matches my mental model when I'm writing, https://gist.github.com/42ce1319a1f47b24a944
21:00:39 <ggVGc> but it's not idiomatic..
21:00:59 <jle`> yeah, writing code that is readable for other people makes it easier for people to collaborate with you and offer help
21:01:27 <jle`> and if you ever contribute to a codebase or work with a group, it'll be expected that you write code consistent with the rest of the group
21:01:29 <ggVGc> at the cost of being more difficult for me to write though[5~
21:01:44 <jle`> well, more difficult for a few days
21:01:54 <jle`> but 'normal'/easy to read after that :)
21:01:54 <ggVGc> sure, I've been working professionally for about 10 years now, I'm well aware
21:02:23 <jle`> it's a slight amount of upfront investment
21:02:31 <jle`> but the payoff is long-lasting
21:03:13 <ggVGc> but I'm not convinced function composition is better than "piping" in the general case
21:03:20 <ggVGc> many people seem to have a hard time with it
21:04:36 <jle`> what is 'better' is something that we can argue for years :)
21:04:46 <kadoban> What do you mean by piping exactly? (flip (.)) essentially?
21:05:07 <jle`> it its well with the rest of haskell idioms and it encourages haskelly ways of thinking
21:05:17 <lethjakman> Is there anything like factorygirl for haskell?
21:06:20 <ggVGc> kadoban: writing like this, https://gist.github.com/anonymous/42ce1319a1f47b24a944
21:06:23 <ggVGc> i.e OCaml style
21:07:22 <kadoban> Yeah, I used to do that. I used a renamed version of (>>>) essentially. I stopped though because … yeah nobody wants to read that.
21:08:48 <kadoban> lethjakman: Can't tell what it is exactly. Sounds from the vague descriptions I bothered to read kind of like something I'd used quickcheck for.
21:09:50 <ggVGc> kadoban: why does no one want to read that? In my experience most people find it much clearer at a quick glance what a function is doing in that style
21:10:21 <kadoban> ggVGc: Because (.) is too ingrained.
21:11:10 <ggVGc> hrm
21:11:17 <ggVGc> maybe in a year or so I'll have a different view
21:11:45 <ggVGc> I've tried using composition more, but I constantly get annoyed that lines get too long, or too many parentheses, or difficult to edit
21:11:54 <ggVGc> compared to having each transformation on a new line
21:12:05 <lethjakman> kadoban: Randomly generates data and relationships for your database. 
21:12:13 <lethjakman> I use it for integration tests. 
21:12:29 <kadoban> lethjakman: Sounds even more like quickcheck from that.
21:12:46 <lethjakman> kadoban: How so? 
21:13:18 <kadoban> How not?
21:13:36 <lethjakman> Hmmm, I guess you could build some sort of generator for the base types that your database data is hydrated into...
21:14:01 <lethjakman> I'm just picturing issues if I want to run an order or something...
21:40:20 <wrathywrath> sup
21:43:14 <wrathywrath> sup darkf
21:44:17 <shanemikel> anybody know how to get the `numeral` function to typecheck?
21:44:20 <shanemikel> http://lpaste.net/8006597347947577344
21:47:33 <johnw> try writing a type signature for it
21:47:38 <johnw> that's always step #1
21:48:51 <shanemikel> I can't
21:49:05 <johnw> do you mean, you don't know what type you want it to have?
21:49:14 <shanemikel> but I figured there was something magical I could do with unsafeCoerce
21:49:20 <shanemikel> take a look, you'll see what I mean
21:49:29 <johnw> never do magical things with unsafeCoerce
21:49:41 <johnw> that's like saying hitting yourself in the face with a pan is magical
21:49:56 <shanemikel> it's one of those cases where hindley-milner sees infinity
21:50:36 <Cale> I don't understand in what sense 'succ' has anything whatsoever to do with the successor function.
21:50:37 <johnw> in those cases -- if that's really what is happening here -- you can side-step type level infinity using a recursive type.  But I don't know if that's what is going on in your case.  I have to go cook dinner now, maybe someone else can help.
21:52:01 <shanemikel> Cale: it's just the name the author used http://www.brics.dk/RS/01/10/BRICS-RS-01-10.pdf
21:52:33 <shanemikel> Cale: also << is the applicative instance for zipList
21:53:11 <shanemikel> err ZipList
21:53:39 <Cale> Oh, okay, so it's what would be used in the successor case of the dependent elimination.
21:55:43 <Cale> ah, that's cute
21:56:21 <Cale> But yeah, you can't write something which takes an Integer and produces the relevant "numeral" here, because the type level information matters.
21:57:43 <shanemikel> yeah, like johnw said, I think this is a job for Mu?
21:59:30 <shanemikel> i'll right, I'll work on it, and come back
22:00:48 <Cale> Well, you can probably do something, but it won't be too convenient to use.
22:02:56 * hackagebot hoauth2 0.5.3 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.3 (HaishengWu)
22:13:50 <ggVGc> so, what's the deal when I export a function taking an instance of A, while A is not exposed? It works, but I can't add any type signatures
22:13:53 <ggVGc> seems a bit weird
22:14:07 <ggVGc> is this normally how people do data hiding in haskell?
22:15:04 <kadoban> ggVGc: That doesn't sound normal. Usually you export the type, but not the type constructors possibly.
22:16:46 <ggVGc> kadoban: ah yeah, that makes sense
22:16:49 <ggVGc> I was being dumb
22:17:06 <ggVGc> A vs A(..)
22:43:28 <nyuszika7h> how do you get just n-length permutations from a list?
22:50:08 <montanonic> nyuszika7h: what do you mean by "n-length permutations"?
22:50:13 <montanonic> oh
22:50:21 <montanonic> use `replicateM`
22:50:30 <montanonic> > replicateM 3 [1,2,3]
22:50:37 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
22:50:43 <nyuszika7h> ah, thanks
22:50:47 <montanonic> np :)
22:53:49 <xacktm> Hi, this is my take 2.  I have a list of operations (do operation with x and y then store into z) which represents a recursive dependency tree, since x and y also have similar operations.  The problem I'm having is that a simple recursive lookup for a value is duplicating work and making execution time blow up.  How can I store these intermediate values (without a global variable that is) so that they are 
22:53:58 <xacktm> availble to all sub and super recursive lookups?  Relevant snippet of code: http://lpaste.net/152628
22:55:07 <xacktm> in the example output for example, you can see 1674 is stored into b multiple times, when ideally, this should happen only once
22:55:38 <montanonic> nyuszika7h: also, this is another way to write that, though it's less generalized: [[a,b,c] | a <- [1..3], b <- [1..3], c <- [1..3]]
22:55:40 <montanonic> > [[a,b,c] | a <- [1..3], b <- [1..3], c <- [1..3]]
22:55:45 <lambdabot>  mueval-core: Time limit exceeded
22:55:49 <montanonic> bag
22:55:51 <montanonic> bah*
23:18:06 <xacktm> my first idea was to change evaluateLogic :: String -> HashMap String Operation -> Word16 to evaluateLogic :: String -> HashMap String Operation -> HashMap String Word16 -> (Word16, HashMap String Word16) but I'm not sure if this will make values available to super-calls
23:18:30 <xacktm> (where the HM String Word16 has the intermediate values)
23:18:48 <xacktm> plus it looks unweildy
23:21:27 <xacktm> in C/C++ I would make the intermediate value hashmap pass-by-reference so updates are for sure available across all calls
23:23:28 <xacktm> hmm lots of sites are saying to use a State Monad instead of a global variable - is that appropriate for my use case?
23:25:35 * xacktm knows very little about State Monads
23:27:07 <johnw> xacktm: the State Monad abstracts the idea of passing in a variable, and returning a possibly altered version of that variable in addition to the normal return value; it abstracts this so that composition of such functions is natural, and the "variable passing" can be made invisible
23:27:21 <johnw> s/variable/value
23:29:33 <xacktm> hrm, interesting.  I guess the State Monad suits the purpose of my (Word16, HM String Word16) return tuple
23:30:12 <xacktm> the Word16 is the normal return value, and the HM will definitely vary
23:33:24 <HoloIRCUser3> Okay reinstalled haskell platform and removed dependencies from the foo.cabal file..
23:33:34 <HoloIRCUser3> this is what happened...
23:33:36 <HoloIRCUser3> http://pastebin.com/hCF0xDgn
23:33:44 <HoloIRCUser3> geekosaur?
23:33:45 <kadoban> Huh, I never noticed that Parsec's optional is different from the Applicative one. That's unfortunate.
23:34:25 <HoloIRCUser3> you online..
23:35:15 <HoloIRCUser3> geekosaur: i tried your method and this happened
23:40:39 <nackjicholson> Hello, if anyone can help me. I installed ghc, stack, and cabal via the minimal installers OSX link on this page https://www.haskell.org/downloads and now I'm running into some strange resolver problems while trying to use stack. I run `stack ghci` it tells me that it wants 7.10.3 and to run `stack setup`. Setup then says it installed ghc@7.10.2. Here is a paste of my terminal output http://lpaste.net/152629. Any help would
23:40:40 <nackjicholson>  be appreciated. Thank you!
23:42:50 <jle`> ReinH: accidentally stumbled upon a situation where you can do something in an IO do block that you can't do in ghci
23:42:59 <jle`> ReinH: http://lpaste.net/152634
23:43:14 <jle`> prints '10' when run normally, but in ghci, it complains that the type variable 'n' is not in scope
23:45:38 <MarcelineVQ> jle`: that works in ghci
23:46:23 <MarcelineVQ> How are you writing it in ghci? And is :set -XScopedTypeVariables ?
23:46:55 <jle`> ScopedTypeVariables is on
23:46:58 <jle`> and i'm just typing it line-by-line
23:47:07 <jle`> Just (SomeNat (Proxy :: Proxy n)) <- return $ someNatVal 10
23:47:18 <jle`> print $ natVal (Proxy :: Proxy n)
23:48:15 <MarcelineVQ> ah
23:49:08 <jle`> just tried it again; still doesn't work, but the error is that there it can't pick a KnownNat n for the second line
23:53:15 <HoloIRCUser3> Can anybody else help?
23:59:42 * mgsloan answering nackjicholson's question in #haskell-stack
