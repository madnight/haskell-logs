00:09:44 * hackagebot Gifcurry 0.1.0.2 - Create animated GIFs, overlaid with optional text, from movies.  https://hackage.haskell.org/package/Gifcurry-0.1.0.2 (lettier)
00:09:44 * hackagebot psc-ide 0.6.0 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.6.0 (kritzcreek)
00:25:40 <guest7878> @type map
00:25:41 <lambdabot> (a -> b) -> [a] -> [b]
00:30:40 <liste> that's the pre-GHC-7.10 map
00:30:52 <liste> actually it's the current one, nvm
00:32:52 <coconut> i have a text file which contains only of key:value pairs, each line one such pair. how can i convert it into a json file
00:36:09 <johnw> coconut: that isn't really a very specific question; are you asking someone to just write the code for you?
00:36:40 <frerich> coconut: My first shot would be to parse the file into a Map (as in Data.Map) and then use the 'encode' function in the 'aeson' package to get a JSON representation for that map.
00:36:53 <coconut> johnw, hi i would like to have some general idea how to implement it
00:37:01 <coconut> such as using which library
00:37:24 <coconut> or is there already existing code on this
00:38:12 <coconut> so aeson can 'serilize' the data to text file ?
00:38:31 <Axman6> anyone know if there's a good reason why Data.Sequence doesn't define a taker function? it defines take to take from the left, but nothing from the right
00:43:15 <frerich> coconut: aeson is a useful package to consider whenever you want to do something with JSON. Among other things, it can convert standard as well as custom data types into JSON.
00:45:30 <coconut> frerich, i will take a closer look
00:46:14 <guest7878> I recently learned about stack. I have already installed quite a few libraries using cabal. Will anything break if I experiment with stack to install more libraries?
00:46:34 <Axman6> coconut: writing a simple parser for your language and then an instance of ToJSON for the type which you parse should be quite easy
00:46:43 <Axman6> guest7878: nope
00:46:57 <Axman6> stack insyalled libraries and cabal isntalled libraries are completely separate
00:47:03 <coconut> guest7878, stack creats its own sandbox so it wont break anything
00:47:42 <Axman6> it's a bit smarter than creating a sandbox
00:47:48 <guest7878> coconut, thanks a lot! So I can safely install it and use it to start installing packages from now on?
00:48:08 <guest7878> Axman6, I see, thanks!
00:48:13 <Axman6> it shares as much as possible between projects, but snapshots mean that will never break (anything not in the snapshot is installed in the sandbox)
00:48:53 <Axman6> guest7878: don't think of it as a cabal replacement, because it qorks very differently. you should be using it within projects (which you can create easily with stack new <project-name>)
00:50:05 <Axman6> so the only things you should be installing with stack outside a project is things which give you executables you might ant to use elsewgere
00:50:09 <Axman6> elsewhere*
00:50:53 <guest7878> Axman6, I see...I will read the "New in-depth guide to stack", but is there any other reference that you would recommend?
00:51:09 <Axman6> the stack docs are the best place to learn about it
00:51:14 <guest7878> Axman6, especially as in introduction.
00:51:42 <guest7878> Axman6, I see...thanks a lot...will check them.
00:51:53 <Axman6> none that I can think of off the top of my head, but there's probably some FP Complete blog posts on it
00:52:59 <guest7878> Axman6, yeah there are a couple. Thanks for all the help.
01:23:07 <gfixler> does Writer always have leakage issues, or is it just WriterT?
01:29:24 <EvanR> i thought Writers leakage was fixed?
01:30:12 * hackagebot convert 1.0.2 - Safe and unsafe data conversion utilities with strong type-level operation. checking.  https://hackage.haskell.org/package/convert-1.0.2 (danilo2)
01:30:43 <jle`> WriterT's leakage is unredeemable for sure with the m (w, a) construction, but i'm not sure if the same arguments apply to Writer
01:37:22 <gfixler> I was just reading the Purescript 0.8 release notes: http://www.purescript.org/learn/generic/
01:37:37 <gfixler> wrong link; right one: http://blog.functorial.com/posts/2016-01-31-PureScript-0.8.html
01:38:12 <gfixler> "First, after a large amount of testing, we identified a large space leak due to the use of the WriterT monad transformer. It turns out that even the Control.Monad.Trans.Writer.Strict variant is not strict enough to avoid a tower of thunks (per the documentation, "although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer"), and in fact it is generally
01:38:14 <gfixler> recommended that WriterT not be used at all in production code."
01:41:49 * tdammers wonders if there is a realistic use case for WriterT over anything that isn't MonadIO anyway
01:45:27 <EvanR> is that purescript specific
01:45:53 <Majiir> What's driving projects like Purescript and Elm to... well, exist, as opposed to being Haskell libraries and compilers?
01:46:08 <gfixler> EvanR: wasn't sure - that's why I was asking in here
01:46:14 <EvanR> because i remember this brought up before and somebody supposedly "fixed" something about it
01:46:46 <gfixler> Majiir: elm specifically wants to make front-end work functional, but very simple, and leaves out a lot of Haskell to keep to the second point
01:47:08 <gfixler> Majiir: Purescript wants to be like Haskell while retaining javascript semantics as much as possible
01:47:14 <EvanR> Majiir: relative ease of starting over from scratch to avoid historical cruft maybe
01:47:46 <gfixler> Majiir: Purescript is written in Haskell
01:48:32 <Majiir> Javascript semantics... for types and whatnot? I'm wondering what JS semantics you'd *want* to keep...
01:48:40 <Majiir> Primitive types, that is
01:49:56 <gfixler> Majiir: https://leanpub.com/purescript/read#leanpub-auto-functional-javascript
01:50:03 <gfixler> "I hope to convince you that PureScript strikes a very practical balance between the theoretical power of purely functional programming, and the fast-and-loose programming style of JavaScript."
01:50:05 <EvanR> arrays, bool-like values
01:50:13 <EvanR> eager
01:50:32 <Majiir> Thanks, I'll take a look
01:50:33 <gfixler> Majiir: true and false instead of True and False, records are just js objects
01:50:46 <gfixler> record lookup works with js' dot operator
01:50:51 <gfixler> it's a mix
01:50:54 <tdammers> I think the main reason for staying close to JS semantics is so you can leverage existing JS libraries more easily
01:52:58 <gfixler> tdammers: yeah - from the book: "However, one of PureScript’s strengths is its interoperability with other languages which target JavaScript. Another approach would be to use PureScript for a subset of your application’s development, and to use one or more other languages to write the rest of the JavaScript."
01:53:44 <tdammers> exactly
01:54:02 <tdammers> much harder in ghcjs or Elm alike
01:54:27 <gfixler> I've heard interop is a real pain in Elm
01:55:00 <tdammers> haven't gone very deeply with this, but my impression is that in order to do useful interop in Elm, you're going to be writing wrappers in JS that talk to Elm ports a lot
01:55:16 <tdammers> which gets rather painful once you're dealing with stateful things like, say, leaflet.js
01:55:59 <gfixler> Richard Feldman said that, IIRC, in one of his Elm talks, during the Q&A when someone asked about pain points
01:59:14 <tsahyt> I'm trying to parse a list of things with megaparsec, like [a,b,c,d]. What's the easiest way to handle newlines and whitespace so that I can format it like I can format lists in Haskell?
01:59:41 <tsahyt> This is what I'm currently doing: listOf1 p = between (char '[') (char ']') $ sepBy1 p (char ',')
02:02:01 <tsahyt> Nevermind, I've just inserted some skipMany spaceChar into the separator and it seems to work
02:05:28 <kqr> yeah, unless you're doing a separate tokenisation pass, you'll have to insert skipMany whitespace errywhere
02:06:15 <tdammers> separate tokenisation can get equally hairy though, if not worse
02:07:05 <tsahyt> it's a very simple language, tokenisation would be overkill I think
02:07:33 <SX> Hi! How is it called when I have type var in constructor, but not in data? "data MyType m = MyType m a"
02:07:48 <Freundlich> tsahyt: I don't think so. Tokenization solves this kind of problem very well.
02:08:11 <tdammers> tsahyt: if it's very simple, then tokenisation might actually work better
02:08:17 <SX> Should I add "forall" or there's some other extention?
02:08:45 <tsahyt> just out of curiosity, how would I go about doing a tokenisation step anyhow?
02:09:25 <SX> Alex?
02:09:29 <bartavelle> SX, you have to add forall, because you can't do anything about the "a" parameter
02:09:52 <SX> bartavelle: Okay, thanks!
02:10:05 <bartavelle> more specifically, you can't write a function "foo :: MyType m"
02:10:13 <bartavelle> without using "undefined" or "error"
02:11:15 <tdammers> tsahyt: depends on your tokens - if it's just "whitespace separated things", the `words` function might even be enough, but otherwise, you could use something like alex, or use a first (mega-)parsec pass for tokenisation and then another for the actual parsing
02:11:52 <EvanR> do you have to write parser combinators for every token?
02:12:10 <EvanR> like, boilerplate that accepts or rejects in the most boring way
02:12:20 <tsahyt> tdammers: In this case words would probably be enough. Since the parser already works now, I'll keep it that way though. But I'll keep it in mind for the next time I'll have to deal with that
02:19:38 <coconut> why i can't decode the json file ?
02:19:39 <coconut> http://lpaste.net/151432
02:20:14 * hackagebot stylish-haskell 0.5.15.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.15.0 (JasperVanDerJeugt)
02:21:16 <lpaste> snhmib pasted “weird type error?” at http://lpaste.net/151433
02:21:42 <Axman6> Maybe values in Aeson are a bit weird coconut. you might need to implement FromJSON and ToJSON by hand
02:21:50 <bartavelle> coconut, this is a [Claim], not a Claim
02:22:02 <Axman6> oh, also that
02:22:11 <coconut> let me correct tht
02:22:29 <snhmib> hello! i have some piece of code that does "forM_ [insns] $ \i -> ... "  where insns is a list of [CsInsn]
02:22:39 <bartavelle> coconut, also you might want to use "eitherDecode", as it gives you an error message
02:22:42 <snhmib> but then i get errors saying that i is also a list!
02:22:49 <snhmib> (see also the paste)
02:22:56 <coconut> thx bartavelle 
02:22:57 <snhmib> i don't understand what i am doing wrong :(
02:23:07 <bartavelle> snhmib, well it is, you should write "forM_ insns $ \i -> ..."
02:23:18 <snhmib> arg!
02:23:21 <snhmib> hah thanks
02:23:22 <bartavelle> ;)
02:23:33 <snhmib> it's too early i need another coffee :)
02:23:50 <snhmib> thanks man
02:24:27 <phadej> snhmib: what error you get from aeson example?
02:24:51 <phadej> if you use eitherDecode jf :: Either String Claim
02:26:20 <snhmib> ?
02:26:49 <phadej> ah, sorry, it was coconut
02:27:27 <coconut> phadej, i got it working now. so most times people use eitherdecode ?
02:27:37 <bartavelle> coconut, I certainly do
02:28:29 <coconut> eitherDecode jf :: Either [Claim]
02:28:31 <coconut> ?
02:28:52 <phadej> Either String YourType
02:29:09 <coconut> what's the string for
02:29:14 <coconut> error messages ?
02:29:16 <phadej> yes
02:30:23 <coconut> usually after this either, we use case .. of ?
02:30:28 <coconut> to get the values out ?
02:32:08 <phadej> yes, Either is not that different from Maybe
02:32:19 <EvanR> also this
02:32:22 <EvanR> :t either
02:32:23 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:33:43 <coconut> i see
02:33:56 <coconut> not yet familiar with either
02:34:01 <coconut> now better
02:35:16 * hackagebot call-haskell-from-anything 1.0.1.0 - Call Haskell functions from other languages via serialization and dynamic libraries  https://hackage.haskell.org/package/call-haskell-from-anything-1.0.1.0 (NiklasHambuechen)
02:58:46 <jle`> coconut: there's also the option of leaving teh result as Either, depending on what you want to do with it eventually
03:07:17 <SX> How could I use Vector instead of List in pattern matching (with x:xs)?
03:09:29 <fr33domlover> SX, see if vector has an IsList instance
03:09:42 <fr33domlover> SX, if yes, enable OverloadedLists extension
03:10:12 <jle`> i'm not sure if IsList lets you pattern match on vectors like that
03:10:43 <phadej> I'd re-evaluate what are you doing with that vector (never needed myself to pattern match on Vector)
03:11:06 <pavonia> There are head and tail functions
03:11:40 <jle`> SX: what do you want to do in the end?
03:12:17 <SX> I have a recursive function, which calls class functions
03:12:22 <SX> one sec
03:12:53 <jle`> pattern matching on head and tail is probably not a normal thing to do with vectors, though it's sort of possible to emulate with pattern synonyms
03:12:58 <lpaste> SimpleX pasted “No title” at http://lpaste.net/7661764057363382272
03:13:04 <SX> http://lpaste.net/7661764057363382272
03:13:31 <jle`> yeah, remember that pattern matching is structural
03:13:38 <liste> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists enables pattern matching too
03:13:39 <jle`> there is no "cons" constructor for a vector
03:14:29 <jle`> oh that's...interesting
03:15:01 <SX> The part with (x:xs) doesn't work with vector.
03:15:12 <SX> And I don't really want to use lists here
03:15:17 <jle`> yes, because : is a constructor for lists
03:15:25 <jle`> that's like using `Just x` to pattern match on Bool :)
03:15:43 <mniip> hey jle`
03:15:56 <jle`> SX: what you can do here is just check if the vector is null, and use head/tail
03:16:17 <jle`> using OverLoadedLists's pattern matching might work but i'm not sure if the intermediate list of tails is ufsed away
03:16:20 <jle`> *fused
03:16:32 <jle`> mniip: hi
03:16:48 <pavonia> SX: Maybe you want foldM or one of its variants
03:16:50 <mniip> jle`, I made an interesting thing http://lpaste.net/151381
03:18:30 <SX> pavonia: don't think it's possible
03:18:55 <jle`> mniip: oh hey that's neat
03:19:15 <mniip> yeah like ultra neat
03:19:31 <SX> The thing here is to recursively apply toBody to function and end on RpcMethod instance
03:20:15 <SX> Don't know how to use folds in such case
03:20:31 <jle`> SX: the recursion pattern you're doing is basically a foldl
03:20:35 <jle`> @src foldl
03:20:35 <lambdabot> foldl f z []     = z
03:20:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:20:56 <jle`> :t foldl
03:20:57 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:20:58 <jle`> :t foldlM
03:21:00 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
03:21:27 <jle`> mniip: congrats
03:21:38 <jle`> i'll be thinking through the implications for a bit haha
03:21:47 <jle`> but for now, i must head to bed ><
03:21:58 <mniip> congrats? :o
03:22:30 <jle`> on finding it
03:22:33 <jle`> it's neat
03:22:45 <jle`> s/find/mak
03:23:15 <mniip> I have a slight feeling that this was done before
03:23:40 <SX> well, if I take 'f' as a acc, then acc type will change on each fold step
03:23:44 <mniip> and I still don't like the ugly gobble that is the state monad part of 'parse'
03:24:11 <lpaste> snhmib pasted “how to double indirection Ptr with FFI?” at http://lpaste.net/151434
03:24:36 <snhmib> guys how would i call this c function from haskell code?
03:25:06 <dramforever> snhmib: ??? = Ptr (Ptr Int) I guess, does it work?
03:25:21 * mniip . o O ( ParserT t b i a = FreeT (ReaderT t i) b a )
03:25:22 <snhmib> i tried a bunch of things from using Addr# (can't get it to typecheck), to a bunch of mallocs (fails because they are (i guess) boxed types)
03:25:27 <mniip> does that make a conformant transformer?
03:26:00 <snhmib> dramforever: it didn't when i tried it, maybe i did it wrong though
03:26:29 <mniip> oh dramforever hey
03:26:43 <mniip> I improved the parser a bit
03:26:56 <mniip> snhmib, I think you will need to allocate a space for an int *
03:27:06 <mniip> then pass the pointer to that space, and then read the result from there
03:27:10 <lpaste> SimpleX revised “No title”: “No title” at http://lpaste.net/7661764057363382272
03:27:25 <mniip> dramforever, apparently FreeT has a thing called iterTM
03:27:30 <SX> Anyone could help me rewrite it to Vector instead of List?
03:27:38 <mniip> which lets us tear a FreeT apart using an intermediate monad
03:27:50 <mniip> for which I chose State containing the token stream
03:28:04 <snhmib> yes, but the thing is how to do this in haskell?
03:28:07 <dramforever> snhmib: I think wrapping a Ptr inside a Ptr works
03:28:17 <dramforever> It works, just use CInt instead of Int
03:28:39 <dramforever> mniip: hi :)
03:29:00 <mniip> now to write a "blog" "post" about it
03:29:23 <snhmib> dramforever: it doesn't i tried that
03:29:29 <snhmib> wait i'll show what i did
03:29:42 <dramforever> huh? I just tried too... yeah show me
03:31:03 <lpaste> snhmib pasted “one of the things i tried” at http://lpaste.net/151435
03:31:39 <snhmib> oo wait i have an idea
03:32:09 <dramforever> Error please? I don't think I know what those Cs stuffs come from the standard FFI stuffs
03:33:39 <snhmib> there is no error, but runnig it gives "before insn: 0x0000000802873100" and "after insn: 0x0000000802873100"
03:33:59 <snhmib> but count is what i expect
03:34:15 <snhmib> so the pointer to the array that was allocated is somewhere unexpected
03:34:25 <snhmib> i'll make a simpler testcase to figure this out :S
03:34:43 <dramforever> snhmib: I don't know what you are doing, but you are just basically casting insn :: Ptr CsInsn to insnptr :: Ptr (Ptr CsInsn) on line 12
03:37:32 <dramforever> It's pure guessing from now on, but say we have equivalent C code cs_insn *ptr; cs_disasm(&ptr);
03:41:00 <dramforever> I suspect you should do this: allocate space for one pointer, call that ptrptr (now ptrptr -> ???), call that function (now ptrptr -> ptr to instructions), peek from ptrptr (now we have the ptr to instructions), then finally peek from the ptr to instructions
03:41:59 <dramforever> Although your function could expect ptr to already point to something... I don't know
03:50:20 <snhmib> dram, i'm not sure how to allocate space for one pointer even!
03:51:13 <snhmib> i tried using Addr# but it wouldn't work in a monad
03:51:35 <snhmib> :( he left
03:52:37 <EvanR> to allocate space for something and get a pointer to that space use alloca
03:55:55 <snhmib> EvanR: "with" uses alloca
03:56:34 <EvanR> im just responding to dram, i'm not sure how to allocate space for one pointer even!"dram, i'm not sure how to allocate space for one pointer even!"
03:56:40 <EvanR> oops
03:59:23 <snhmib> EvanR: i think the problem is "Ptr a" is a garbage collected haskell object
03:59:25 <snhmib> and not a pointer
03:59:58 <snhmib> so to pass a Ptr (Ptr x) to a c function expecting it to deref the pointer and change it to what it malloc'd
03:59:59 <EvanR> i dont
04:00:04 <snhmib> is asking for trouble
04:00:51 <EvanR> Ptrs you get from alloca are themselves pinned somewhere precisely so you can pass them to C
04:01:04 <EvanR> er
04:01:31 <EvanR> Ptrs you get and pass to C are just values, not objects
04:02:10 <EvanR> and the memory you get from alloc is pinned
04:02:43 <snhmib> oh
04:05:17 <snhmib> EvanR: then why doesn't this simple testcase work? (http://lpaste.net/151436)
04:06:49 <EvanR> what a whacky C func ;)
04:07:03 <snhmib> also it's wrong 
04:07:09 <snhmib> sorry 1 sec :)
04:07:42 <snhmib> oh no it's not
04:07:59 <snhmib> all these pointers are starting to make my head spin :P
04:08:22 <EvanR> i didnt see a problem but its whacky, ok so the haskell code
04:08:30 <EvanR> p <- malloc :: IO (Ptr Addr#)
04:09:04 <EvanR> you want a Ptr (Ptr CInt) not Ptr Addr#
04:09:10 <EvanR> and you should use malloc
04:09:12 <EvanR> er
04:09:14 <EvanR> alloca
04:09:17 <snhmib> look at this: http://lpaste.net/151436
04:09:23 <snhmib> this is compiling but it doesn't work
04:09:57 <snhmib> using a Ptr Addr# is my next attempt and i hope it will work but i cannot get it to compile ;)
04:10:14 <EvanR> i dont see how it compiles
04:10:18 <EvanR> where is pptr defined
04:10:58 <EvanR> make sure youre pasting the actual code youre having problems with
04:13:25 <EvanR> snhmib: you will actually need 2 allocas in a row for this
04:14:08 <snhmib> here this is my testcode which compiles
04:14:10 <snhmib> http://lpaste.net/151439
04:14:16 <snhmib> there is 1 malloc
04:14:20 <snhmib> and 1 alloca
04:14:27 <snhmib> the alloca is in the "with" function
04:14:38 <EvanR> one to hold the CInt argument to the function, and a second to hold the pointer to that CInt, which will be overwritten by the function
04:14:50 <snhmib> the CInt will not be overwritten
04:14:55 <EvanR> i didnt say it would be
04:15:15 <snhmib> there will be a pointer to a CInt overwritten
04:15:17 <EvanR> the pointer to that CInt, in the second alloca space will be
04:15:21 * hackagebot jukebox 0.2.2 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.2 (NickSmallbone)
04:16:14 <EvanR> so in the second alloca, write the first pointer to the second space (using the second pointer)
04:16:27 <EvanR> then pass the second pointer to the c function
04:16:43 <snhmib> with p $ \pptr 
04:16:51 <snhmib> with allocates space for a ptr to p
04:16:53 <snhmib> then puts p in it
04:17:08 <snhmib> i am doing exactly what you are saying
04:17:14 <snhmib> and it doesn't work
04:18:13 <EvanR> that much makes sense, now ill look at the latest code
04:18:53 <snhmib> it's the same as the first code :)
04:19:15 <snhmib> the testcase in the middle is where i try to use a Ptr Addr#, but i can't get it to compile
04:19:19 <EvanR> http://lpaste.net/151436 is not the same
04:19:31 <EvanR> snhmib: so... you didnt initialize the CInt to anything?
04:19:41 <EvanR> when you used malloc
04:19:50 <snhmib> no it's the C function that allocates space for 10 ints
04:19:51 <EvanR> (dont use malloc)
04:20:03 <EvanR> *x = malloc(sizeof **x * 10);
04:20:16 <EvanR> its literally using **x and **x was not initialized
04:20:31 <snhmib> no it does sizeof **x
04:21:03 <snhmib> you can write sizeof(int) if you want
04:21:12 <EvanR> what is the point of all this...
04:21:31 <EvanR> the original malloced space is not used?
04:21:34 <snhmib> i want to call a call a c function that allocates space for an array
04:21:54 <EvanR> i see that
04:22:14 <snhmib> EvanR: i know the original malloc space is not used
04:22:15 <EvanR> but theres a lot of extraneous stuff, a problem with any of it could be triggering undefined behavior
04:22:43 <snhmib> this is a minimal testcase ...
04:22:56 <EvanR> its not that minimal
04:23:02 <EvanR> i will write a minimal one for you ;)
04:24:40 <snhmib> EvanR: http://lpaste.net/151439 this works as intended
04:25:03 <EvanR> makes sense
04:25:09 <snhmib> yea :S
04:25:34 <maerwald> EvanR: since when does **x need to be initialized when you do sizeof(**x)?
04:25:37 <snhmib> i pretty sure i tried it before in the real code and it didn't work, i wonder what i did wrong then
04:25:42 <EvanR> you should use Addr#
04:25:44 <EvanR> shouldnt
04:25:56 <EvanR> maerwald: i didnt see the sizeof
04:25:59 <maerwald> oh
04:26:06 <EvanR> sizeof **x * 10
04:26:20 <EvanR> i though it was used as an argument
04:26:26 <maerwald> parenthesis 4tw
04:29:35 <EvanR> which negates most of what i was saying
04:30:36 <EvanR> alloca or malloc to get a single Ptr (Ptr CInt) (space left uninitialized), pass that pointer to C. then it will be initialized 
05:01:33 <SX> How to forkIO in ReaderT m a?
05:02:11 <SX> lifted-base?
05:03:39 <liste> SX yeah Control.Concurrent.Lifted.fork
05:04:32 <SX> liste: Thanks!
05:04:51 <liste> yw (:
05:05:07 <liste> MonadControl and MonadBaseControl twist my brain :(
05:05:16 <liste> it's hard to write instances for them
05:05:35 * hackagebot threads-supervisor 1.0.4.1 - Simple, IO-based library for Erlang-style thread supervision  https://hackage.haskell.org/package/threads-supervisor-1.0.4.1 (AlfredoDiNapoli)
05:12:09 <Zyxoas> Hey, peeps. Is there an Esqueleto channel somewhere? Or should I just ask my question here?
05:14:52 <Zyxoas> I'm trying to do a query like the following in Esqueleto's syntax:
05:15:31 <Zyxoas> select sum(a), sum(b), count(*) from foo where id = 12345;
05:16:24 <Zyxoas> I need to know how to convert this to the Esqueleto syntax. Note that I'm not selecting a primitive value, or a whole record, but rather arbitrary aggregates...
05:21:08 <int-index> How can I make `stack haddock` generate nice hyperlinked source like this? https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Control.Applicative.html
05:22:01 <mchall> I am completing the monad challenge and I need to have a function allPairs :: [a] -> [b] -> [(a,b)] that takes two lists and give all the combinations of them. The challenge uses a custom prelude so all monad niceties are not available how is it achieved ?
05:22:22 <phadej> int-index: stack install haddock and move it into ~/.stack/programs/...
05:22:41 <phadej> int-index: fancy source is in 2.16.z
05:23:09 <lyxia> mchall: liftA2 (,)
05:23:32 <liste> Zyxoas maybe something like "select $ from $ \(x `InnerJoin` y) -> (,) <$> sum_ (x^.a) <*> sum_ (y^.b) <*> countRows" ?
05:23:54 <liste> s/(,)/(,,)/
05:24:40 <Zyxoas> And if x and y are the same table? Will "select $ from $ \(x `InnerJoin` x) -> (,) <$> sum_ (x^.a) <*> sum_ (x^.b) <*> countRows" still be good, liste ?
05:24:57 <Zyxoas> "select $ from $ \(x `InnerJoin` y) -> (,,) <$> sum_ (x^.a) <*> sum_ (y^.b) <*> countRows"
05:25:56 <liste> Zyxoas if you want an inner join with itself
05:26:32 <Zyxoas> Thanks a lot, liste . Shall try that. ;-)
05:26:35 <liste> if not, then "select $ from $ \x -> (,,) <$> sum_ (x^.a) <*> (x^.b) <*> countRows"
05:26:49 <liste> warning: I didn't test that code
05:26:59 <liste> just guessed, basically
05:27:33 <Zyxoas> Your guess is better that ours. :-D
05:28:52 <liste> "select $ from $ \x -> (,,) <$> sum_ (x^.a) <*> sum_ (x^.b) <*> countRows" I meant
05:28:58 <liste> missed one sum_
05:32:53 <int-index> phadej, I'm still getting non-hyperlinked sources :c
05:34:18 <int-index> `~/.stack/programs/x86_64-linux/ghc-7.10.3/bin/haddock --version` gives me 2.16.1
05:40:31 <phadej> hmm, he left
05:42:11 <cmotoche> Hello everyone. I'm having the following error when trying to build a project with stack. Could you please help me to interpret it?
05:42:17 <cmotoche> --  Failure when adding dependencies:    
05:42:17 <cmotoche>       aeson: needed (>=0.6 && <0.9), 0.9.0.1 found (latest applicable is 0.8.1.1)
05:42:17 <cmotoche>     needed for package: snap-extras-0.11.0.1
05:42:59 <mchall> lyxia mchall: liftA2 (,)  those sort of things are not available, is there a way to do it just using recursion ?
05:43:00 <phadej> snap-extras bounds are too tight
05:43:07 <Zyxoas> Tat works, liste. Thanks.
05:43:53 <frerich> mchall: You could also do this using 'concatMap', which is available in the limited prelude.
05:44:36 <lyxia> mchall: sure there is, pattern match on one of the lists.
05:47:03 <liste> Zyxoas: yw (:
05:47:49 <lyxia> mchall: think about what you're going to get if you call your function on the tail
06:06:51 <SX> How to correctly forkIO in ReaderT?
06:07:22 <SX> I get "thread killed" exception
06:08:21 <SX> I tried "ask >>= void . fork . runReaderT f"
06:11:22 <SX>     ask >>= void . fork . void . lift . runReaderT f
06:26:37 <aweinstock> :t \f -> ask >>= \env -> liftIO (Control.Concurrent.forkIO $ f env)
06:26:38 <lambdabot> (MonadIO m, MonadReader a m) => (a -> IO ()) -> m GHC.Conc.Sync.ThreadId
06:26:57 <aweinstock> SX: ^ that should do most of it
06:27:31 <SX> I'm inside ReaderT
06:27:38 <SX> and need to stay inside of it
06:30:53 <phadej> int-index: maybe i compiled haddock from v2.16 branch
06:31:06 <phadej> I don't remember anymore
06:32:19 <int-index> phadej, ok, thanks anyway
06:32:50 <int-index> at least now I know that the feature is not enabled by an undocumented command-line flag (it was my previous assumption)
06:40:38 * hackagebot octane 0.3.0 - A Rocket League replay parser.  https://hackage.haskell.org/package/octane-0.3.0 (fozworth)
06:40:39 <mchall> lyxia frerich thanks for the help   allPairs (x:xs) lst =  concatMap (\y -> [(x, y)]) lst ++ allPairs xs lst
06:41:25 <lyxia> mchall: map (\y -> (x,y))   is more concise
06:41:56 <lyxia> use concatMap when the lists do not have the same length
06:43:56 <mchall> lyxia many thanks       allPairs (x:xs) lst = map (\y -> (x,y)) lst ++ allPairs xs ls
06:44:34 <lyxia> err, actually, when they have lengths /= 1
06:44:46 <lyxia> but yeah that's it
06:45:33 <ahihi> \y -> (x,y) can be shortened to (x,) with TupleSections ;)
06:48:00 <mchall> ahihi thanks we can't use it here because of the custom prelude but I'll try to remember for future use ;)
06:48:41 <gganley> I'm taking notes in my Math class in LaTeX and I need to "draw" some graphs, I've known about the diagrams library but I've never used it personally im just curious if, for fun, I could use diagrams or should i just use tikz
06:48:52 <gganley> btw this is on linux using emacs/auctex
06:51:21 <SX> is it possible to handle several exception types in a single catch?
06:51:59 <Ankhers> gganley: I think it probably depends on preference. I've played a little with diagrams, and if I recall, it was fairly simple to use.
06:53:09 <Ankhers> gganley: I'm a little to unfamiliar with LaTeX to know how easy it would be to place a diagrams image into your output. But something like ipython with that haskell kernel, it is quite easy.
06:55:37 <mnoonan> gganley: diagrams has a PGF backend, iirc (PGF is the layer beneath tikz)
07:00:46 <JazzyEagle> Hello, everyone...  I'm working on a server & related client, both using network-conduit-tls and a self signed certificate.  When attempting to connect, I'm getting "HandshakeFailed (Error_Protocol ("certificate rejected: [SelfSigned]",True,CertificateUnknown))" on the client.
07:01:02 <JazzyEagle> Is there any way through network-conduit-tls to tell it to trust self-signed certificates, especially for development purposes?
07:01:14 <JazzyEagle> I'm not seeing one, but I figured I'd check.
07:01:32 <JazzyEagle> If not, I'm guessing I need to look in the tls package directly?
07:27:09 <lyxia> gganley: I just use tikz for handwritten stuff.
07:29:05 <lyxia> gganley: and switch to diagrams when tikz becomes a pain, or I want to generate drawings from external data.
07:45:27 <kqr> JazzyEagle, looks like you'll have to look into the tls package
07:46:01 <JazzyEagle> kqr: That's what I was thinking, but I tend to second guess myself with Haskell, so I wanted a second opinion.  Thanks a lot, kqr!!  :)
07:47:50 <kqr> JazzyEagle, if/when you figure out how to do it with the tls package, I suggest you think of a way to integrate it with the network-conduit-tls package, write a summary of your idea and post it to the issue tracker[1]. snoyman is usually pretty good with responding to issues. if he doesn't see a problem with it, implement it and file a pull request!
07:47:56 <kqr> JazzyEagle, [1]: https://github.com/snoyberg/conduit/issues
07:48:39 <kqr> JazzyEagle, of course, you could just implement it directly and create a PR, but I tend to ask first if I've missed some obvious problem
07:48:44 <JazzyEagle> Snoyman's coding usually confuses me, so I'm not confident I can figure out myself how to do it, but I will see if I can't figure it out.
07:49:35 <Clint> network-conduit{,-tls} is deprecated in favor of conduit-extra
07:49:59 <JazzyEagle> That is a good idea, though, to recommend to him to add such a capability, especially since a lot of development work is done with self signed certificates.
07:50:30 <kqr> Clint, which part of conduit-extra replaces network-conduit-tls?
07:50:43 * hackagebot IntervalMap 0.5.0.1 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.5.0.1 (ChristophBreitkopf)
07:51:02 <Clint> kqr: you're right, i'm confused
07:51:30 <kqr> JazzyEagle, confuses you how?
07:52:45 <JazzyEagle> kqr: My first experience with Haskell and Snoyman's work was Yesod, so trying to learn Applicatives, Functors, Monads, Transformative Monads, and disguising all of that under TemplateHaskell really confused me for a long time.
07:53:02 <JazzyEagle> conduit seems to be less complex, so I'm feeling a little more comfortable with it.
07:53:16 <kqr> ah
07:53:17 <JazzyEagle> But I think the learning cover of Yesod kind of made me skiddish.
07:53:24 <JazzyEagle> s/cover/curve
07:53:52 <kqr> yeah yesod is probably not a good place to start. especially since there's afaik no clear model of how it works described... anywhere
07:54:41 <JazzyEagle> There's a lot of good documentation on how to use it in its most basic of forms.  As soon as you want to do something outside the box, though, you are forced to resort through wading through the code and hoping you can figure out what it's doing.  As a novice Haskeller, that's not exactly easy.
07:55:12 <JazzyEagle> But I learned it to help another project.  I wasn't initially thinking of continuing with Haskell beyond that, as I felt very comfortable w/ C++ & Qt, but Functional Programming eventually got me jonesin' for more.
07:55:37 <kqr> i have the same experience with yesod
07:55:44 <kqr> it is awesome but hard to learn currently
07:55:58 * geekosaur reminded of happs ~ 7 years ago >.>
07:56:05 <kqr> i did some hacking with another library of snoyman's though. a much smaller and simpler one
07:56:06 <geekosaur> (now happstack)
07:56:12 <sm> maybe someone needs to write an awesome guide to yesod ?
07:56:21 <kqr> at that point it became pretty obvious that snoyman writes the simplest code first and then changes it only when it's needed
07:56:34 <sm> that and a little polish might be all it needs
07:56:47 <kqr> sm, i think it's more of a "get a large amount of people to use it" issue
07:56:59 <sm> that would come next 
07:57:10 <kqr> any guide a single person writes is inevitably going to either only cover the basics or cover a very specific task
07:57:34 <kqr> what is needed is a big pool of community-collected wisdom
07:57:46 <shapr> like a wiki?
07:57:53 <kqr> kinda... or just a bunch of stackoverflow questions
07:58:03 <kqr> like when I work with django at work, I just google "how to do X django"
07:58:05 <sm> that requires a good curator
07:58:06 <kqr> and there it is
07:59:01 <kqr> and I don't believe yesod is inherently any harder than django
07:59:18 <kqr> though that might just be because I suck at web frameworks in general so I think both are pretty hard
07:59:46 <bergmark> "framework" usually includes "lots of stuff i don't know how it works"
08:01:22 <JazzyEagle> kqr: sm:  Like a wikibook.  There's a wikibook for Haskell (https://en.wikibooks.org/wiki/Haskell), the community make another one just for Yesod and expand what's already in yesodweb.com/book
08:01:30 <JazzyEagle> His book is a very good start.
08:01:57 <kqr> that book was not very helpful last I checked lol
08:02:49 <JazzyEagle> kqr: It's helped me immensely.  Again, so long as you stick to the basic website framework and don't go overboard with site features and design, it explains a lot.
08:03:17 <JazzyEagle> All you really end up with is something fairly static (with the exception of pulling in some data from the Haskell backend)
08:03:28 <JazzyEagle> If you want something more than that, then the book starts to fail you.
08:03:40 <sm> JazzyEagle: I think updating/polishing/rebranding the existing book would do a lot. it just requires one good author/web-presence curator to take it on. (not "the community")
08:05:20 <JazzyEagle> sm: Maybe, but I know my Haskell skills aren't enough to be the author.  :)
08:11:10 <magbo> Hey, people. I have the following set-up — haskell program F talking to other haskell program B over http. I want to re-use types of B.
08:11:24 <jgt> I think *not* being amazing at Haskell is actually critical to writing a good Yesod book
08:12:11 <magbo> So I want to convert this — ``Array (fromList [String "28499.7775",Object (fromList [("Volume",String "29924.77"),("Type",String "RUB")])])`` into (ERRate, InstrumentVolume) tuple.
08:12:18 <jgt> Yesod is really cool, and I've been digging into it for a while, but when it comes to real-world stuff, like, how to deploy an application, there's no real instruction
08:12:23 <jgt> just a bit of hand-waving at Keter
08:12:32 <jgt> and then there's barely any documentation for that project eiher
08:12:37 <jgt> s/eiher/either/
08:12:43 <magbo> jgt: just use scotty tbh.
08:13:11 <jgt> I at least think I've figured the deployment stuff out with Nix
08:13:18 <magbo> What I'm doing is I'm using awesome parts of Yesod as libraries, but scotty when it comes to "framework" over WAI/WARP.
08:13:22 <jgt> in fact, I spent all of yesterday writing a detailed article on the process
08:13:33 <magbo> Nix is good :3
08:13:55 <jgt> I'm just about to release the article, but it'd help to have another pair of eyes scan it first
08:14:00 <jgt> would you care to review?
08:14:06 <magbo> jgt: jm >>= (memorici >>> de)
08:14:09 <JazzyEagle> magbo: I know chreekat, the lead dev of Snowdrift.coop, uses Keter to deploy Snowdrift, which was built on Yesod.  He may have some pointers for ya'.  He's not on ATM, though.
08:14:29 <magbo> jgt: ^ that's for you, I think.
08:14:49 <jgt> magbo: I'm totally green in Haskell; I don't know what that means
08:14:56 <JazzyEagle> Yeah, sorry.
08:14:56 <jgt> I *think* >>= is bind
08:14:58 <magbo> jgt: that's my E-mail address
08:15:00 <magbo> :D
08:15:04 <JazzyEagle> That shoulda been for jgt
08:15:09 <jgt> ahaaaaaa
08:15:13 <magbo> bind is at and tripple arrow is dot.
08:15:17 <jgt> gotcha
08:15:21 <JazzyEagle> lol
08:15:28 <JazzyEagle> I never saw an e-mail that way before.
08:15:46 <jgt> I'll send it right away; thanks so much!
08:16:21 <magbo> JazzyEagle: I wrote one too many scrapers to know that fuzzy scrapers these days are too familiar with any sort of name <at> domain <dot> tld formats :)
08:16:37 <JazzyEagle> hehe
08:17:04 <magbo> Any pointers to my "problem"?
08:17:08 <magbo> Let me share a snippet
08:18:43 <jgt> magbo: Mail sent.
08:21:04 <jgt> I'm not sure where I stand on the whole Yesod vs Scotty thing; there are a couple of features of Yesod that I really appreciate like `yesod devel` and also the migrations
08:21:56 <magbo> jgt: ok, I'll have a look.
08:22:10 <magbo> Hurr durr I think I found a bug in my code :)
08:22:16 <tpsinnem> hey, is there a way to take a 'foo :: IO ()' and write an executable file that runs this 'foo' when executed?
08:22:18 <magbo> Let's see if it does it.
08:23:21 <magbo> tpsinnem: aside from something stupid like code generator that imports your file and then says main = foo
08:23:28 <magbo> I don't know of other ways.
08:23:47 <magbo> Word order also important is failed at it I had.
08:27:36 <kqr> tpsinnem, what are you trying to do? the easiest way to do that is probably to run ghc which is literally the thing that converts an IO () into a runnable program
08:27:53 <kqr> like that's what compilation is
08:29:02 <bergmark> :-)
08:29:22 <sm> actually it converts source code, no ?
08:29:59 <tpsinnem> kqr: i presume i'll be doing that (via the GHC api) but i'm curious if there's a way that takes an IO () value rather than a source code text representation of an IO () value
08:30:12 <tpsinnem> not that it hugely matters i suppose
08:30:41 <mnoonan> how would you handle IORefs and such in your IO () action?
08:31:07 <OverCoder> data MessageType = Info | Warning | Error Int
08:31:14 <OverCoder> How do I pattern match against Error Int? I want to use filter on a list, however, the MessageType might either have an Int or may not
08:31:21 <OverCoder> How can I solve this?
08:32:22 <tpsinnem> mnoonan: is there something special i'd have to do?
08:32:37 <mnoonan> tpsinnem: I don't think there is anything sane you can do, really
08:33:20 <tpsinnem> mnoonan: i would assume that my scenario would in most respects work identically to what goes in in compilation in any case
08:33:50 <tpsinnem> s/goes in/goes on/
08:34:08 <JazzyEagle> OverCoder: Probably the easiest way to do something like that is to write a quick function, something along the lines of isError, where it checks to see if it's an Info, a Warning, or an Error Int.  If it's an Error, it returns true.  Use that for your filter.
08:34:36 <mnoonan> only if your IO () could have been main. if it depends on the current machine state in any way, you're out of luck.
08:35:35 <kqr> OverCoder, case msgtype of { Error i -> show i; _ -> "something else" }
08:36:07 <OverCoder> Ooh, sorry guys I was away for a while, anyways, thank you very much guys :)
08:36:42 <kqr> OverCoder, or if you want it to be a function, \case { Error i -> show i; _ -> "something else" }
08:36:50 <kqr> OverCoder, (requires the LambdaCase language extension)
08:37:09 <OverCoder> Nah, case/of is many times easier
08:37:41 <kqr> lambdacase is basically the same thing, except it's a function that takes an argument to match on instead of grabbing one from the current scope
08:38:06 <mnoonan> tpsinnem: maybe the Process type from cloud haskell might be interesting to you, though.
08:38:35 <mnoonan> that lets you execute an action "somewhere else", which is sort of what you are asking for
08:40:08 <sm> mnoonan: how does that work, anyway ?
08:40:29 <mnoonan> sm: I have no idea :)
08:40:53 <tpsinnem> mnoonan: i may have a poor understanding of things, but how does an IO () value depend on machine state?
08:40:53 <mnoonan> I imagine you could make a DSL with a monadic interface, then provide interpreters to run it and serializers to move it over the wire..
08:41:22 <tpsinnem> are they not values like any other?
08:42:09 <Cale> Yeah, IO actions are just values like any other
08:42:28 <mnoonan> tpsinnem: an IO () value is like a program that can be run (and never changes), but what it *does* still depends on *when* it is run.
08:50:27 <deni> what would be a good (simplest?) way to implement a global mutable hashmap (like an in-memory store for the lifetime of the program) ?
08:52:06 <sm> io-storage IIRC
08:52:58 <phadej> deni: or stm-containers
08:53:58 <deni> phadej: sm the key part I'm struggling with is the "global" part....so that needs to be available to most functions
08:55:12 <sm> oh, including non-IO functions ? You could add unsafePerformIO, there
08:55:19 <sm> but that
08:55:57 <sm> would be considered bad taste :)
08:57:06 <deni> sm: I don't think I'll need unsafePerformIO... all of the adding and removing from the global in-memory store will happen in the IO monad. (it's a http api)
08:57:25 <deni> i can still construct most of the rest of the program to be pure
08:57:27 <deni> I think
08:57:36 <deni> sm: phadej tnx for your help
08:57:38 <sm> yep
08:57:55 <deni> I think io-storage is what I'll try
08:58:07 <sm> note when you're using web frameworks, they'll usually provide a better way to hold your state
08:58:21 <sm> look for docs about "app state"
08:59:13 <sm> it'll be thread safe etc.
09:02:01 <deni> sm: good point
09:05:21 <phadej> well, stm-containers are thread-safe 
09:05:53 * sm meant better than io-storage
09:18:04 <hopl> hello, would you know if it is safe to use an imported c function fn0 as a callback inside another imported C function fn1. Basically, I have a Haskell function fn that calls fn1. fn1 will then call fn0 but fn0 is set from Haskell code.
09:18:40 <hopl> Should I use the safe import for fn1 basically?
09:20:07 <ironChicken> in my cabal test-suite, i'm getting "cabal: Prelude.read: no parse"
09:20:18 <geekosaur> @paste
09:20:18 <lambdabot> Haskell pastebin: http://lpaste.net/
09:20:22 <ironChicken> but i wasn't getting this 30 minutes ago
09:21:20 <Ankhers> ironChicken: I believe that means the parse failed for some reason.
09:21:27 <ironChicken> i found an old (2013) bug about relative paths to log files
09:21:28 <Ankhers> > read "4" :: Int
09:21:29 <lambdabot>  4
09:21:32 <Ankhers> > read "4t" :: Int
09:21:33 <lambdabot>  *Exception: Prelude.read: no parse
09:21:58 <ironChicken> Ankhers: yes, makes sense. but i can't see that i've done anything that's causing that.
09:22:19 <ironChicken> and i'm fairly sure i've *undo* all the things i did since it last worked, and it still doesn't work
09:22:36 <ironChicken> s/*undo*/*undone*/
09:22:36 <glguy> hopl: You're going to import fn1 as a FunPtr, not as a Haskell function
09:22:47 <glguy> err, you'll import fn0 as a FunPtr
09:22:58 <glguy> If fn1 is going to re-enter Haskell it would need to be "safe"
09:23:55 <ironChicken> i was trying to define show Show instances to help with debugging; but after getting this error i removed them (and replaced them with the automatically derived ones i had before)
09:24:55 <andromeda-galaxy> ironChicken: are you using git/darcs/other vcs with lots of small modular commits?
09:26:28 <hopl> glguy: Maybe, I can just write the C code though? Basically, I set the C callback using C code and call from Haskell the function that set the callbacks instead of setting the callback from Haskell? (not sure this is clear...)
09:26:34 <Ankhers> ironChicken: If your Show and Read instances are for debugging only, I wouldn't bother testing them.
09:26:58 <glguy> hopl: Sure, if the program doesn't need to be able to control which callback is install you could do it that way, too
09:27:17 <ironChicken> andromeda-galaxy: hmm, sort of. but i've been carring around quite a bit of uncommitted trace calls
09:27:23 <ironChicken> so it's a bit messy
09:28:02 <ironChicken> Ankhers: well, i'm not testing the Show instance, i just want to get more readable versions of things to help with the testing
09:28:16 <hopl> glguy: but, you said that getting the callback into Haskell will require some kind of marshalling anyway that I cannot get rid of? Actually, can I get a raw function pointer instead of using import?
09:28:26 <andromeda-galaxy> ironChicken: ah okay. I wasn't sure how experienced you are, so I thought that if you weren't it might not be a bad idea to mention best practices.  I'm guessing that the problem is that the "more readable" show instances aren't directly parseable by read
09:28:37 <glguy> hopl: import gives you a raw function pointer
09:28:53 <andromeda-galaxy> ironChicken: (do you want to use pretty-show or some such package for defining special pretty instances?)
09:28:57 <lpaste> glguy pasted “for hope” at http://lpaste.net/151451
09:29:01 <glguy> hopl*
09:29:03 <ironChicken> andromeda-galaxy: they're not. but i've now removed them and i still get the error
09:29:27 <andromeda-galaxy> hmm, that's a bit odd. are you sure that cabal rebuilt everything? what does the failing test case look like?
09:29:43 <ironChicken> (andromeda-galaxy: i hadn't thought of using a package for assisting with Show instances, but i'll look into it)
09:30:00 <ironChicken> i did a clean to make sure
09:31:02 <andromeda-galaxy> ironChicken: that is a bit odd. Did you have to update a test case earlier and haven't un-updated it or something?
09:32:25 <ironChicken> andromeda-galaxy: i'm not quite sure what you mean. but while we're talking i've just tried setting my list of test cases to [] and now my test-suite runs without error
09:32:35 <hopl> glguy: interesting. So, I guess this is however dangerous if somebody does some marshalling with FunPtr of actual Haskell code and call the function. But it will work out of the box for a plain C function. Also, what is "&" for?
09:32:41 <ironChicken> so i'm methodically trying each one to see where it breaks...
09:33:26 <glguy> hopl: I don't know what danger you're referring to. You can learn more about foreign function interface and it's syntax here, though https://www.haskell.org/onlinereport/haskell2010/haskellch8.html
09:34:46 <andromeda-galaxy> ironChicken: I don't know what your testing infrastructure looks like, sorry if I made some nonsensical suggestions.  Bisecting the test cases is a good idea, though (I originally assumed that the test framework would tell you what was wrong).  Maybe you'll be able to figure it out just from the test?  The problem is that a no parse error is rather generic, so I'd need to see the test case to have any idea what mi
09:36:58 <Clint> is there some way to profile compilation?
09:37:57 <geekosaur> ghc is written in Haskell and accepts +RTS
09:38:18 <hopl> glguy: Thanks a lot for the link! I was talking about using unsafe import for fn0 and registering actual Haskell code that has been wrapped into a C function for fn0 (so it will be a FunPtr). Types will match but fn1 will call fn0 and actually reenter actual Haskell code and crash.
09:38:57 <Clint> geekosaur: but how do i use that information to figure out what part of the .hs is making ghc allocate all the memory?
09:39:14 <glguy> hopl: If you want to export Haskell code as a callback you'll need to do that differently than importing C code to be a callback
09:39:26 <geekosaur> that's probably a better question for #ghc or the glasgow-haskell-users list
09:39:45 <glguy> hopl: For exporting Haskell code to be the callback you should read about "Dynamic wrapper"
09:40:21 <Clint> geekosaur: fair
09:40:36 <geekosaur> also if this is the ghc8 rc, it's probably a known bug
09:40:55 <Clint> it's 7.10
09:41:18 <hopl> glguy: This is what I am saying. There is no way to prevent the user from making a mistake if he uses a dynamic wrapper for some Haskell code. An imported C function as you wrote and a wrapped Haskell code will have the same signature (FunPtr...)
09:41:41 <ironChicken> so it looks like this might have been related to a trace that used Text.Printf.printf to show a Double as "%.04d", where, of course, i meant "%0.4f"!
09:42:34 <shapr> Anyone able to compare Haskell and Rust?
09:43:03 <glguy> > "Haskell" `compare` "Rust"
09:43:04 <lambdabot>  LT
09:43:08 * shapr grins
09:43:14 <shapr> glguy: thanks :-P
09:43:15 <Ankhers> That was unexpected.
09:43:27 <geekosaur> printf considered evil, film at 11>.>
09:43:36 <oggy> how do I pass arguments with cabal sandboxes and runhaskell? e.g. `cabal exec runhaskell Test.hs --blah` passes blah as an argument to cabal, and not to my program
09:44:08 <glguy> Usage: cabal exec [FLAGS] [--] COMMAND [--] [ARGS]
09:44:08 <geekosaur> cabal exec -- runhaskell -- Test.hs --blah
09:44:27 <geekosaur> the first -- stops cabal from parsing options, the second stops runhaskell from parsing options
09:44:52 <oggy> awesome, thanks!
09:45:00 <ironChicken> geekosaur: yeah, has anyone done type-safe format strings?
09:45:08 <cocreature> @hackage formatting
09:45:08 <lambdabot> http://hackage.haskell.org/package/formatting
09:45:20 <cocreature> ^ ironChicken
09:45:27 <geekosaur> ironChicken, since they're runtime values, that's not really doable. There may be some TH though
09:45:32 <ironChicken> cocreature: lovely. thanks :-)
09:45:39 <geekosaur> I personally prefer the functions in the Numeric module
09:46:04 <andromeda-galaxy> geekosaur: if you know the format string at compile time, it works with a bunch of FunctionalDependencies
09:47:28 <cocreature> do people actually pass strings they don’t know at compile time to printf?
09:47:33 <cocreature> I don’t think I’ve ever seen that
09:47:45 <hopl> glguy: actually, the doc is a bit unclear. Sorry :-(. Can a function imported as "unsafe" call back a FunPtr?
09:48:31 <glguy> hopl: A function marked unsafe can't call back into Haskell, but it can call a C function via function pointer
09:48:45 <geekosaur> cocreature, dunno how often it's done in Haskell. it's done in C often enough that compilers have warnings in -Wall about it
09:49:12 <cocreature> geekosaur: I obviously don’t read/write enough c code for that, not sure if that’s a good or a bad thing :)
09:49:15 <geekosaur> (and it's led to a bunch of stack smashing attacks)
09:49:32 <sbrg> cocreature: that's a good thing
09:49:35 <sbrg> for your sanity.
09:49:44 <Mirry> Hey, I'd like to put two Word8 together into a Word16, here's what I have: w8to16 :: Word8 -> Word8 -> Word16; w8to16 x x2 = ((x `shiftL` 8) .|. x2); I'd like to know how I can fix this
09:50:09 <geekosaur> Mirry, apply fromIntegral to x and x2
09:50:19 <glguy> Mirry: You need to convert your Word8s (x and x2) to Word16 before doing math on them
09:50:40 <hopl> glguy: OK. So, I need to refactor the C code or make everything safe since this callback can be called from a lot of places. Thanks!
09:50:40 <andromeda-galaxy> cocreature: in c, this often happens as a mistake: char *str = <some calculation on user input>; printf(str) /* instead of printf("%s",str) */
09:50:57 <Mirry> Oh ok, so fromIntegral will know I want Word16 from the function signature?
09:51:02 <geekosaur> yes
09:51:18 <Mirry> Neat! Thank you very much
09:51:56 <glguy> hopl: Most of your imports should be safe. Unsafe imports are best for tiny C code that does very little. An unsafe call leaves the capability that was executing tied up
09:52:14 <glguy> You should have a good reason to make an unsafe import, it isn't a default
09:53:39 <cocreature> sbrg: I do formal verification of c code so my sanity is already lost
09:54:26 <hopl> glguy: is safe import killing multithreading? Is it a blocking call? This is my main concern to be honest. The thing though is that this callback is barely nothing (Clipboard function which is basically never called). Other than that, the C code will not interact with Haskell code. 
09:54:58 <geekosaur> hopl, safe calls get shipped off to a dedicated thread. unsafe calls block the thread they're made on
09:55:20 <andromeda-galaxy> cocreature: which system? I've been mildly interested in those for a while, but several of the ones that I saw seem to be defunct now
09:55:20 <glguy> unsafe calls will potentially kill your Haskell multithreading
09:55:39 <hopl> geekosaur: spawning an OS thread?
09:56:07 * hackagebot elision 0.1.2.0 - Arrows with holes.  https://hackage.haskell.org/package/elision-0.1.2.0 (jacrough)
09:56:10 <cocreature> andromeda-galaxy: a not yet released research project :)
09:56:14 <geekosaur> the runtime keeps an OS thread around to use to make safe calls, yes
09:56:27 <glguy> hopl: Possibly spawning a new OS thread, not necessarily spawning a new one
09:56:27 <andromeda-galaxy> cocreature: oh okay.  that sounds interesting, good luck :)
09:56:37 <geekosaur> also, "Clipboard function" sounds like exactly the kind of thing you must not call unsafe
09:56:49 <andromeda-galaxy> hopl: https://wiki.haskell.org/Foreign_Function_Interface#Enhancing_performance_and_advanced_topics
09:56:59 <geekosaur> clipboards are not boxes, clipboards are invitations to IPC
09:57:06 <lispy> The February Hask anything thread is up: https://www.reddit.com/r/haskell/comments/43pnb8/hask_anything_the_thread_where_you_ask_and_we_try/?sort=new
09:57:26 <sbrg> cocreature: oh god
09:58:15 <andromeda-galaxy> cocreature: by the way, what's the rationale behind formally verifying c over formally verifying something slightly more functional but still low-level like rust?
09:58:36 <geekosaur> if nothing else, it has to exchange messages with the window server (yes this is true on all of Win/Linux/OS X). on Linux and OS X it will additionally have to exchange messages with the owner of the data "in the clipboard", because what's actually int he clipboard is the address of the client that has the data
09:58:47 <geekosaur> I *think* this is also true of Windows
09:59:13 <geekosaur> since it is possible to request a specific data format ("Paste Special") for anything that is not simple text
09:59:49 <lispy> andromeda-galaxy: I suppose it depends on what you need. There is more C code that we depend on in the world than Rust, for one thing. (Not that I disagree with your point)
09:59:57 <geekosaur> this WILL block and it almost certainly will do memory allocation; doing either in an unsafe function will break things badly
10:00:26 <geekosaur> even before considering callbacks
10:00:49 <hopl> geekosaur: This API can trigger a lot of function calls. Like OpenGL for example. It cannot be migrated from threads to threads. So, I need to a cleaner containment strategy for the only IO the library does with clipboard.
10:01:14 <geekosaur> take a look at forkOS then
10:01:41 <geekosaur> it sounds like you are convinced that unsafe somehow gives you more control
10:01:42 <andromeda-galaxy> lispy: that's true, it makes sense for systems to relatively easily verify existing code.  I was just thinking about anything targeted at writing new code that Rust would make a little bit more sense...
10:01:50 <geekosaur> it gives you *no* control
10:02:00 <geekosaur> safe is what gives you control
10:02:02 <glguy> unsafe runs the foreign call on whatever thread is running that code at the moment
10:02:10 <cocreature> andromeda-galaxy: I need to make dinner now, if you want I can talk about it a bit in #haskell-blah later
10:02:56 <lispy> andromeda-galaxy: I was talking to someone recently that wants to use Rust on an embedded project and as it turns out the processor they are targetting has non-standard floating point support which gcc handles but rustc uses llvm and cannot generate the right code. So there's also odd ball considerations like that.
10:03:18 <lispy> andromeda-galaxy: and this is a flight controller so they want/need float
10:03:20 <andromeda-galaxy> cocreature: thanks, that sounds like it would be really interesting!  I'll join #haskell-blah
10:03:37 <andromeda-galaxy> lispy: ah, that makes sense.  my attitude to that sort of thing is: compiler doesn't work => improve compiler
10:03:54 <andromeda-galaxy> (but I can see why that wouldn't be practical in a number of situations)
10:04:28 <geekosaur> ghc devs are still waiting on a couple llvm patches needed to improve ghc's codegen, I think...
10:07:43 <hopl> geekosaur: I am not sure to understand. Saying I have OpenGL binding that need to run on the main thread. It *cannot* work with safe right? 
10:08:48 <hopl> geekosaur: because I am in a similar situation here. This is a non-reentrant library that goes to main thread because anyway, it depends on OGL.
10:09:07 <glguy> The main thread is already a bound thread
10:09:38 <glguy> safe calls made from it will be fine
10:10:00 <trubert1> I'd like to count the number of True elements in a vector. Is it possible to improve the following attempt, for shorter runtimes?
10:10:05 <hopl> glguy: OK. So, calling from main thread does not cause any migration?
10:10:15 <trubert1> cardinality :: Vector Bool -> Int
10:10:16 <trubert1> cardinality !vec = (length . filter (== True)) vec
10:11:27 <quchen> trubert1: The "!" is unnecessary there.
10:11:43 <trubert1> quchen: ok thanks. Any suggestion on improving the implementation?
10:11:45 <quchen> In order to get anything out of that function you have to force 'vec' anyway.
10:12:24 <quchen> Using an unboxed vector would be faster, but you lose laziness of the entries in the process.
10:12:41 <t0by> um
10:12:44 <glguy> hopl: It will migrate the other haskell threads off of executing on that OS thread so they don't get blocked by your foreign call
10:12:44 <t0by> what *is* ! anyway?
10:12:51 <quchen> t0by: BangPattern
10:13:08 <t0by> thanks quchen, something googlable :)
10:13:22 <quchen> trubert1: And (== True) is id, but that probably doesn't matter for runtime behaviour
10:13:30 <glguy> hopl: read more here http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#g:8
10:13:57 <trubert1> quchen: thanks. Good suggestion about unboxed vectors, will give a try....
10:14:28 <quchen> trubert1: I think length and filter might fuse away to a tight loop, but if you really want to be sure write the loop yourself
10:14:41 <quchen> Scratch that. If you really want to be sure, look at the Core.
10:14:47 <trubert1> quchen: :-)
10:14:52 <quchen> And if that's insatisfactory write the loop. :-)
10:16:53 <ski> t0by : strictness annotation
10:17:25 <glguy> length of filter allocates a new vector and then checks its length (a field on the vector type)
10:18:02 <hopl> glguy: I was just starting to read it. Thanks! It makes sense now. There is no relation with safe/unsafe though? I just need this code to run on the main thread.
10:18:58 <glguy> cardinality 07= V.foldl' (07\acc x 07-> 07if x 07then acc07+041 07else acc) 040
10:19:01 <glguy> won't, though
10:19:07 <quchen> Woah.
10:20:02 <ReinH> glguy: what about length . filter p  . V.toList ?
10:20:43 <glguy> ReinH: ghc-core reports that works :)
10:20:49 <quchen> Heh.
10:20:56 <quchen> toList making code more efficient. That's a first.
10:21:24 <ski> t0by : in `f !x = ..x..', `f _|_' will be `_|_'. iow it means that if `f' is applied to bottom (meaning a non-normally-returning-computation), then the result will also be bottom. but in your case, that would be the case even without the strictness annotation
10:21:40 <ReinH> The list should fuse away completely
10:22:07 <the_2nd> how does my folder structure have to look like, that I can have modules of type GROUP.NAME ? When all files currently are in src/ . Do I need folder GROUP/ and move all the files there? Currently I get "could not be found" on import of nested named modules
10:22:21 <t0by> thanks sk
10:22:23 <t0by> sk
10:22:24 <t0by> arf
10:22:27 <t0by> thanks ski 
10:22:34 <ski> t0by : in a typical demand-driven implementation, the strictness annotation could mean that if the result of the application of `f' is demanded, then the argument corresponding to the annotated parameter will also be demanded
10:22:38 <ReinH> the_2nd: replace '.' with '/' and that's your dir structure.
10:22:59 <osa1> wow this is awesome http://hackage.haskell.org/package/ChasingBottoms-1.3.0.13/docs/Test-ChasingBottoms-IsBottom.html#v:isBottom I can finally use undefined as null pointers in other languages
10:23:01 <ReinH> Foo.Bar.Baz -> Foo/Bar/Baz.hs
10:23:02 <kadoban> the_2nd: Module Group.Name  should be in the folder Group, named Name.hs or Name.lhs, yes. Where that folder structure lives depends on your .cabal file, it should probably be in src/ in your case though.
10:23:03 <the_2nd> ReinH, are modules then defined with
10:23:13 <the_2nd> module NAME where or module GROUP.NAME where
10:23:24 <ReinH> It's like above.
10:23:31 <the_2nd> alright, thanks
10:23:41 <ski> t0by : .. note that you, in general, can't depend on *when* it will be demanded, only that it will be. a high-level optimization might notice that some things will necessarily be demanded, and then decide to change the order in which they are demanded, in an attempt to improve efficiency
10:24:37 <ski> t0by : you may think of the strictness annotation as being implemented by the primitive operation `seq :: forall a b. a -> b -> b' .. or, the other way around, `seq' being implemented as `seq !_ x = x'
10:28:07 <hopl> glguy: Thanks a lot for your help! It makes me aware of lot of issues. I'll think about all that.
10:30:00 <osa1> how do I build benchmarks using Cabal? I think cabal build just ignores --enable-benchmarks
10:30:28 <osa1> cabal configure --enable-benchmarks && cabal build <-- only builds the lib
10:38:32 <kadoban> osa1: Isn't there a 'cabal bench' or something?
10:41:11 * hackagebot fasta 0.10.2.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.10.2.0 (GregorySchwartz)
10:46:46 <tugen> Hi all
10:48:38 <hexagoxel> cabal bench (presumably) runs the benchmarks; just building should be possible as well (and i would have assumed with exactly the above steps)
11:12:40 <the_2nd> somewhere I saw a syntax which defined multiple class functions of same type at once
11:12:53 <the_2nd> something like f1, f2, f3 :: a -> a -> a
11:13:08 <the_2nd> what's the correct syntax there?
11:13:11 <benzrf> the_2nd: i'm pretty sure that's valid
11:13:28 <enthropy> > let x,y :: Int; x = 1; y = 2 in (x,y)
11:13:29 <lambdabot>  (1,2)
11:13:51 <glguy> data MyRecord = MyRecord { a, b, c :: Int } -- too
11:13:54 <enthropy> I think it works everywhere you can put a type signature
11:13:57 <benzrf> glguy: oooooh nice
11:14:06 <benzrf> i never knew /that/ one
11:14:48 <the_2nd> class MouseInteract a where        
11:14:49 <the_2nd>     hover, cick, drag :: Double -> Double -> a -> a
11:14:49 <Levex> > 1 + 1
11:14:50 <lambdabot>  2
11:14:56 <the_2nd> click not a visible member of
11:15:00 <Levex> wow, I didn't know lambdabot could do that
11:15:34 <glguy> the_2nd: because you misspelled click?
11:15:45 <the_2nd> glguy, yay
11:15:56 <the_2nd> last time this happened it took 30minutes
11:16:06 <the_2nd> so 2 min for you to find it for me aint bad :D
11:16:14 <Gurkenglas> How do I include libraries in a project such that a system without those libraries can compile my project? (Ideally hoping for a one-line command x))
11:16:46 <geekosaur> glwt...
11:17:08 <geekosaur> one line command. for every linux distro and os x and windows? uh huh
11:18:34 <geekosaur> (iphone/android. illumos. etc. etc...0
11:19:41 <Gurkenglas> Would be feasible if it's a cabal option right? Either Ubuntu or Windows is enough for me.
11:19:44 <koala_man> why does e.g. lens not do that instead of dragging in so many dependencies? has it been determined not to be a good idea because then you won't know what any package will contain?
11:22:16 <glguy> Lens doesn't actually drag in that much. It's mostly small packages that define a few types and classes (e.g. profunctors, semigroupoids) that are there own little thigns so that other packages can provide their own instances
11:22:33 <glguy> as well as some larger, but common packages, like text or primitive
11:22:41 <seesaw9> how do I specify that I always want my executable to be compiled with -O3, inside a stack.yaml file?
11:22:46 <hiptobecubic> Why does everyone hate dependencies so much? It's better than writing your own everything all the time.
11:22:56 <mauke> seesaw9: -O3 doesn't exit
11:22:58 <mauke> er
11:23:00 <mauke> doesn't exist
11:23:05 <lpaste> glguy pasted “lens transitive dips” at http://lpaste.net/151465
11:23:18 <seesaw9> mauke: sorry I meant -O2 
11:24:58 <geekosaur> Gurkenglas, all I can say is you;re a remarkable optimist.
11:25:20 <demize> hiptobecubic: It's not that people hate dependencies, it's more that haskell projects have a tendency to end up having a bunch of dependecies that they don't really /need/, each of which has a tonne of them themselves, leading into a packaging nightmare for most packagers. ;p
11:25:31 <demize> Also annoying if you're low on space.
11:25:40 <Gurkenglas> geekosaur, what would that need beyond downloading the sources for each library and putting them into the project?
11:26:17 * hackagebot haskell-mpfr 0.1 - Correctly-rounded arbitrary-precision floating-point arithmetic  https://hackage.haskell.org/package/haskell-mpfr-0.1 (ilist)
11:26:41 <geekosaur> Gurkenglas, the answer to that is either bitter laughter or a pointer to every open source bug tracker in existence
11:27:01 <geekosaur> it does not work that way. *especially* on Windows it does not even begin to work that way
11:27:51 <bitemyapp> https://mail.haskell.org/pipermail/ghc-devs/2016-January/011211.html If anyone happens to know anything about how State# or other things act to make IO and ST well behaved, if you could give me some pointers I'd appreciate it.
11:28:35 <Gurkenglas> Okay, what would fail if I copied a library's files into my project folder and removed the cabal dependency, except that depending on both my project and that library wouldn't work?
11:29:30 <Gurkenglas> I mean, cabal already downloads the source files when asked to install something, right? Just skip the compile part.
11:29:56 <glguy> Gurkenglas: If you're just trying to include all the Haskell libraries into your executable you should create a statically linked executable
11:30:08 <glguy> the challenge of packaging libraries comes from non-Haskell libraries
11:30:10 <geekosaur> oh, I understood you to be talking about C libraries for some reason
11:30:22 <geekosaur> that said, you will run into those soon enoughwith your dependencies
11:30:48 <geekosaur> like, as soon as you try to include network
11:31:21 <sm> I use network on windows, without c libraries. I thought
11:31:34 <geekosaur> network has to bind to win32 APIs
11:31:38 <Gurkenglas> glguy, this competition tells me to send them a Haskell project to be compiled by them. They're also including Haskell as an afterthought and don't have the time to install more than Haskell Platform
11:31:43 <geekosaur> this turns out to be easier said than done
11:32:03 <Gurkenglas> Does Lens - Haskellplatform need anything special like that?
11:32:29 <sm> maybe network and its c libs ship with ghc on windows ?
11:32:36 <geekosaur> *much* easier said than done. it's been an ongoing nightmare for everyone who has to deal with Haskell on Windows, and in fact network is the #1 reason to install the PLatform on Windows because someone already dealt with the nightmare of making it build
11:33:08 <geekosaur> fpcomplete dealt with it by coming up with their own curated version of mingw to ensure that it would build network
11:34:42 <geekosaur> (which they then have to keep up to date while still ensuring it will build network)
11:34:57 <deni> how does one handle database migrations with haskell....I see that the persistent family of packages does have some support for migrations but lacks some features.....I'm not sure about the simple family of libraries...and packages like esqueleto and opaleye don't do migrations at all (from what I can tell).
11:35:13 <orion> What exactly is it about Windows that makes it so difficult to build the platform?
11:35:54 <Ankhers> deni: Which features are you looking for in persistent that are not there?
11:35:56 <geekosaur> pretty much the entire haskell ecosystem is designed around POSIX
11:36:00 <geekosaur> WIndows is not POSIX
11:36:45 <geekosaur> it is entirely possible to write stuff that will build on Windows, you just have to maintain a completely separate Windows code base
11:37:01 <deni> Ankhers: I haven't looked into it enough but I did notice that there's not support for colum rename and column removal for instance
11:37:12 <deni> *no support
11:37:54 <sm> geekosaur: that's overstating it
11:38:13 <Ankhers> deni: Yeah, persistent isn't so much "migrations" as it is "here is my schema, build it".
11:41:03 <sm> hledger-* works on windows with 2/3 small ifdefs and one conditional dependency
11:41:05 <geekosaur> sm, at this point I do not believe that is overstating it. I've seen too many projects say "that should be easy" and then get ripped to shreds by corner cases or someone who has some unexpected thing installed
11:41:17 <sm> maybe there's more duplication in the libs I'm relying on
11:41:27 <geekosaur> hledger gets to depend on the lower level libraries hiding the details
11:41:28 <lynn> Heyo! Does anyone here have experience with the "friday" image manipulation package?
11:43:27 <glguy> lynn: You'll get better help just asking your question
11:43:29 <sm> so practically speaking, I do write stuff that builds on windows and don't have to maintain a separate code base. Haskell gives a pretty good cross platform experience actually
11:43:44 <geekosaur> sure, as long as youre not the one who has to deal with network
11:44:16 <geekosaur> this is just shifting the pain point onto someone else, and usually intensifying it in the process
11:44:33 <sm> geekosaur: network's maintainer is doing a fine job, that's the whole point
11:44:44 <lynn> Well, I wrote a program using it, and it's about a hundred times slower than I feel like it should be. :<
11:45:36 <lynn> But I profiled it, and it turns out most of the time is spent in a "compose" function I wrote myself, which layers two RGBA images
11:45:53 <lynn> So I was wondering if there is some built-in way to do that, which I'm not seeing
11:46:02 <sm> so the rest of us can and should reap the benefits! cross-platform code++
11:46:26 <geekosaur> ...
11:46:44 <geekosaur> ok, yes, sweep minghc under the rug as 0 maintenance cost visible to you therefore 0 maintenance cost period
11:46:55 <deni> Ankhers: I'm trying to make sense of what lib to use for what....What lib to use for creating the database (the initial migration). What lib to use for querying. What to use for future migrations. Any advice on that?
11:47:18 <deni> cause there's just too many libs out there and it's kinda confusing .... (mind you I'm using postgres)
11:47:18 <sm> geekosaur: I don't get your point. It's painful, so we abstract it and get work done (as best we can). Same as always
11:49:26 <deni> for instance esqueleto  and opalaye do the same thing right? Minus the fact that opaleye can't do any migrations and esqueleto can since it's persistent backed. right?
11:50:27 <Ankhers> deni: I'm really enjoying esqueleto for SQL queries. You are basically writing a slightly modified SQL syntax. So it is already familiar.
11:50:30 <Welkin> deni: not quite
11:50:38 <Welkin> opaleye is postgres only
11:50:41 <lynn> https://gist.github.com/lynn/504e0712b5dd8c13f953#file-knyttstoriesmapper-hs-L232
11:50:45 <Welkin> and doesn't do migrations, of course
11:50:51 <Welkin> and has a lot moreboilerplate to write
11:50:51 <lynn> I really dislike this bit of code...
11:51:16 <Welkin> but can give you better safety guarantees if you need to write very complex queries
11:51:28 <lynn> Maybe `fromFunction` isn't the way to go. Apparently I waste a lot of time in `w2f` and `f2w` too, converting bytes to floats and back again
11:51:42 <deni> Welkin: I see.... being postgres only is okay for me though. Thanks for the info though I wasn't aware of those points.
11:51:58 <deni> Ankhers: Welkin but both of those should be type safe (more or less?)
11:52:03 <deni> I mean comared to string interpolation 
11:52:05 <ThatTreeOverTher> I'm trying to map
11:52:08 <lynn> But still, rendering a map for a little game world shouldn't take half an hour. Maybe I'm using the wrong package entirely?
11:52:36 <Welkin> I tend to use persistent, very rarely use esquelto, and sometimes if I need to do something very custom use the rawSql function from persistent, which still gives you some safety and you will know if it is wrong when you first ty to run it
11:52:37 <ThatTreeOverTher> I figured it out. Never mind
11:53:30 <Welkin> migrations are very helpful, as are the config files that are used with template haskell to write the boilerplate for you
11:53:49 <Welkin> I need that when I am building because I could make 20 changes to the scheme in a day
11:53:53 <Welkin> schema*
11:54:23 <Ankhers> Welkin: How do you go about renaming columns using persistent?
11:54:58 <Gurkenglas> geekosaur, does the difference between Lens and Haskellplatform need anything special like that?
11:55:00 <Welkin> Ankhers: I often just drop the table (or the column) and let persistent fix it
11:55:21 <deni> does persistent support adding columns? data migrations?
11:55:46 <Clint> deni: yes
11:55:56 <Clint> but not very complex ones
11:56:19 <Ankhers> Welkin: For development, sure. But you can't just drop production data. Is there a solution for that?
11:56:53 <Welkin> Ankhers: yes, just change it in the sql console manually
11:56:55 <Welkin> it's not hard
11:57:24 <Welkin> or you can give the column a different name in your program, and specify an explicit name for the database
11:57:30 <Ankhers> I don't disagree, I was just hoping that there was something in persistent to help with it.
11:57:35 <Welkin> if you already have an existing database
11:57:39 <Welkin> there is
11:57:39 <ThatTreeOverTher> persistent doesn't seem to have much in the way of migration support, but if you're "persistent" enough, you might write your own :)
12:00:04 <Ankhers> I
12:00:28 <geekosaur> Gurkenglas, lens itself does not. but lens creates lenses for a bunch of common libraries (which is why it has such a large dependency list), some of which do incur external dependencies
12:00:46 <Ankhers> I'm just wondering if there is a way to create a rails style migration tool for persistent. But I believe there wouls be some issues.
12:00:54 <geekosaur> and it does iirc go beyond the platform
12:04:03 <deni> are there exeternal tools for migrations?
12:04:12 <deni> Ankhers: Welkin ^?
12:04:23 <deni> I mean I would love something django/rails likes
12:05:11 <deni> also manually doesn't really work for production...it needs to be automated... and maintaining bash scripts with raw sql piped to psql isn't really that nice :(
12:11:26 <Ankhers> deni: I mean, it would be possible to create something rails like for migrations. The only downside, at least in the way I am seeing it in my head, is there would be no guarantee that the type you are creating a table for, will have a corresponding proper object. Maybe using Template Haskell you could create something, but I have not used TH before, so I do not know its limits.
12:13:48 <Welkin> yes, persistent uses template haskell for this
12:13:57 <Welkin> but there are restrictions placed on it to guarantee safety
12:14:25 <Welkin> so it will never delete data or make changes that could result on data loss, or take an action that it is not 100% sure will work
12:21:58 <crough> deni, Ankhers: yeah, persistent probaby would do pretty good here, seeing as it's a part of Yesod, which is a giant framework not unlike Rails
12:27:57 <Ankhers> Maybe when I'm a little better at Haskell, I will try and create something to deal with migrations. If nothing else, I will find out why it doesn't work.
12:28:35 <MasseR> How come persistent migrations weren't ok?
12:29:22 <jasonkuhrt> QuickCheck has a function called frequency but I don't fully understand how the bias works
12:29:51 <Ankhers> It really only deals with schema migrations, which work for the majority of cases, but sometimes you want to remove / rename a column, change data formats etc.
12:29:53 <xa0> T0BI: ha, found you. I knew you were from freenode
12:30:00 <Ankhers> MasseR:^^
12:30:41 <xa0> OverCoder: so how is Haskell going
12:30:58 <ReinH> I guess they just wanted to let us know?
12:31:07 <MasseR> point taken. for column renames you could always do a post on after verifying the data. albeit not optimal
12:31:12 <OverCoder> xa0, good, but kinda stopped learning cis after I've done the second homework
12:31:37 <xa0> So you've given up?
12:31:48 <OverCoder> I just feel now quite comfortable with Haskell to make an IRC bot (That's all because I've learned through LYAH, cis homework's did great job introducting me to functional thinking)
12:32:04 <xa0> Right
12:32:09 <ReinH> OverCoder: sounds like a great idea
12:32:16 <ReinH> Best way to learn is by doing.
12:32:17 <OverCoder> :)
12:32:27 <jasonkuhr> `frequency [(2, pure Foo), (4, pure Bar)]` would mean 2 `Foo`s for every 4 `Bar`s? AKA twice as many `Bar`s
12:32:31 <ReinH> OverCoder: and ofc there's lambdabot for inspiration
12:32:46 <jasonkuhr> Is that the correct interpretation
12:32:59 <ReinH> jasonkuhr: it would mean 2/6 chance of a foo, 4/6 chance of a bar
12:33:03 <OverCoder> Yeah I see, ReinH
12:33:34 <trobo2> I'd like an efficient implementation of a function that takes a vector of Bool's, and returns False if there exists a `True` element, or True otherwise. Here's my attempt:  https://gist.github.com/anonymous/483fb605410635ea3e29
12:33:36 <jasonkuhr> ReinH: I see. It is not about the max frequency. Its about their total.
12:33:51 <trobo2> Is there a more efficient way to implement isEmpty?
12:34:31 <jasonkuhr> So then `frequency [(2, pure Foo), (4, pure Bar), (2, pure Qux)]` would result in 1/4 Foo, 1/2 Bar, 1/4 Qux
12:34:37 <jasonkuhr> ReinH: Thanks!
12:35:10 <ReinH> jasonkuhr: yep, yw
12:35:49 <ReinH> :t any -- trobo2
12:35:53 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:35:58 <ReinH> er
12:36:01 <ReinH> :t or
12:36:02 <lambdabot> Foldable t => t Bool -> Bool
12:36:25 <trobo2> ReinH: thanks.
12:36:50 <ReinH> looks like you want not . or, specifically
12:37:54 <dfeuer> Is there a well-known synonym for  forall x y . c x y -> d x y  ?
12:37:59 <Ankhers> not $ any id [False, True]
12:38:08 <ReinH> Ankhers: or = any id
12:38:16 <Ankhers> oh
12:38:24 <Ankhers> that makes sense.
12:38:48 <Ankhers> I was trying to get lambdabot to interpret it. But I forgot the >
12:38:55 <ReinH> it's a fold using the (Bool, (||), False) monoid :)
12:40:52 <ReinH> Which is also available as the Any newtype:
12:41:09 <ReinH> > ala Any foldMap (repeat True)
12:41:11 <lambdabot>  True
12:41:32 <ReinH> It's weird that `Any` corresponds to `or` rather than `any`, but w/e.
12:41:53 <crough> :t ala 
12:41:54 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
12:41:58 <crough> The is beautiful haha
12:42:02 <crough> *that
12:42:04 <ReinH> ala is a weird way of wrapping and unwrapping the newtype
12:42:23 <crough> reminds me of Idris' `the`
12:42:30 <Ankhers> it is over my head :P
12:42:42 <geekosaur> doesn't seem that hard
12:43:15 <ReinH> ala Any foldMap = getAny . foldMap Any
12:44:42 <geekosaur> typeclasses Unwrapped and Rewrapped let the type system map between newtype constructors and the "run function" (so it can figure out getAny from Any or getSum from Sum)
12:44:51 <OverCoder> How come Data.ByteString.Internal.ByteString is different than ByteString?
12:44:52 <ReinH> ala uses the instance for the type to determine what the wrapper and unwrapper are.
12:45:00 <OverCoder> ghci complains about type mismatching because of it
12:45:13 <ReinH> OverCoder: There are two types called ByteString: the lazy one and the strict one.
12:45:20 <geekosaur> OverCoder, ecause "ByteString" is Data.ByeString.Lay/Internal.ByteString
12:45:22 <ReinH> OverCoder: if you are using one and it wants the other, you'll get an error like that.
12:45:25 <geekosaur> bah
12:45:33 <OverCoder> Ah
12:45:36 <geekosaur> because "ByteString" is Data.ByteString.Lazy.Internal.ByteString
12:45:38 <ReinH> The actual types are defined in the internal modules
12:45:47 <OverCoder> Gotcha, thanks
12:46:27 <ReinH> OverCoder: import qualified Data.ByteString.Lazy as LazyBS; import qualified Data.ByteString.Strict as StrictBS <-- should help clear up the errors.
12:46:30 <Ankhers> That makes sense.
12:46:39 <ReinH> such bs wow
12:46:40 * geekosaur has a replacement keyboard on order, this one appears to have a hairline crack causing dropped keys (with a distinct focus on a particular physical area of the keyboard)
12:46:51 <OverCoder> ReinH, yeah I have just did
12:47:00 <ReinH> geekosaur: You only have one keyboard at a time? :D
12:47:02 <geekosaur> on top of which I;m typoing like mad today
12:47:13 <ReinH> geekosaur: do you want me to send you one of my like 5 extras I have lying around?
12:47:21 <geekosaur> I dont have room for a proper keyboard on this desk
12:47:36 <mauke> > let spork a b = iterate (drop 1 . scanl (+) 0) (repeat 1) !! a !! (b - 1) in spork 3 5
12:47:37 <ReinH> geekosaur: do you use a 60% keyboard? tenkeyless?
12:47:38 <lambdabot>  35
12:47:43 <mauke> but what does this mean?
12:48:25 <ReinH> > iterate (drop 1 . scanl (+) 0) (repeat 1)
12:48:26 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:48:31 <geekosaur> I am using multdevice keyboard intended for phones/tablets, so I can switch between phone and desktop. had a good one except that the device switch keys were too easy to whack by accident
12:48:38 <ReinH> map (take 5) (iterate (drop 1 . scanl (+) 0) (repeat 1))
12:48:45 <ReinH> > map (take 5) (iterate (drop 1 . scanl (+) 0) (repeat 1))
12:48:47 <lambdabot>  [[1,1,1,1,1],[1,2,3,4,5],[1,3,6,10,15],[1,4,10,20,35],[1,5,15,35,70],[1,6,21...
12:49:07 <ReinH> each sublist counts by its index in the outer list.
12:49:13 <geekosaur> so got this one with a mechanical device switch, but it has this hairline crack in the circuit board. so another one on order
12:49:24 <oystein> I might not be asking this question correctly, but here I go: I have io.c and elevator.c, where elevator.c calls functions from io.c which in turn calls functions from a library. Is it possible to call elev.c functions from Haskell?
12:49:42 <mauke> oystein: I don't see why not
12:50:13 <mauke> ReinH: I think spork a b is the number of ways you can choose a items from a set of b (with repetition, order doesn't matter)
12:50:25 <oystein> make, thanks, I'll just have to try harder then I guess. :)
12:50:30 * geekosaur notes that e is now typing more lightly to avoid triggering the char drop. still dropped a space and a 'h' typing this... (those and 'v' seem to be the keys most often dropped, giving a hint as to where the problem is)
12:50:31 <oystein> mauke *
12:51:36 <ReinH> mauke: binomial coefficient, or pascal's triangle
12:51:38 <ReinH> mauke: yes.
12:52:22 <geekosaur> oystein, as long as elevator.c does not take structs (as distinct from struct pointers) as parameters or returns
12:52:23 <ReinH> that is a nice way to draw pascal's triangle
12:53:02 <oystein> geekosaur, it doesn't, thanks!
13:01:02 <dmj> luigy: ping
13:05:38 <yarinskell> hi
13:05:54 <dmj> yarinskell: hello
13:11:03 <xpilot> hello! I'm looking for some advice on uploading to hackage
13:11:22 <xpilot> namely, I have a package that depends on a bunch of miscellaneous code
13:11:38 <xpilot> stuff like type-level nats, dealing with variable argument functions, and the like
13:12:09 <xpilot> would it be reasonable to make a "Misc" package on hackage and have my other packages depend on it?
13:14:31 <dmj> xpilot: if you're the only person who's going to use it, probably not. 
13:14:38 <ThatTreeOverTher> consider splitting your package into well-defined groups so that other people can use them, if that's possible
13:20:21 <haskell374> hi, i have a rose tree: data Tree a = Node a [Tree a] and i have foldTree :: Monoid m => (a -> m) -> Tree a -> m, i dont understand how i should fold the tree with monoid
13:20:53 <xpilot> dmj, ThatTreeOverTher: yeah that make sense. I'll see if I can organize things better
13:21:45 <xpilot> haskell374: I'd recommend using Node [Tree a] | Leaf a
13:22:34 <xpilot> haskell374: then the fold semantics are clearer - the way you have it, it isn't clear where the root value will get mappended
13:23:11 <Ankhers> does it matter? I thought (a <> b) <> c == a <> (b <> c)?
13:23:33 <kadoban> Ankhers: But (a <> b) /= (b <> a) necessarily
13:23:43 <Ankhers> right.
13:24:11 <ski> haskell374 : depends on what kind of folding you want. what do you want to compute from the tree elements ?
13:24:41 <xpilot> haskell374: you want to map foldTree over the [Tree a] list, then fold over the resulting [a] list
13:24:42 <haskell374> sumTree and a function that collects the labels of the tree in a list
13:25:39 <xpilot> foldTree (Leaf a) = a; foldTree (Node l) = foldMap foldTree
13:26:24 * hackagebot hlint 1.9.27 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.27 (NeilMitchell)
13:27:08 <xpilot> haskell374: in fact you probably want to just have instance Foldable Tree
13:27:17 <haskell374> xpilot: where is that Leaf come from? 
13:27:28 <xpilot> haskell374: GHC can actually derive this for you quite easily
13:27:49 <xpilot> haskell374: oh I was using my suggested Tree a = Node [Tree a] | Leaf a
13:29:42 <xpilot> haskell374: in your case I would do foldTree (Node a l) = foldr mappend a (map foldTree l)
13:29:53 <ski> haskell374 : hm, so you're trying to *implement* `foldTree' (rather than *use* it) ?
13:30:50 <ski> (xpilot : it's probably better to try to give hints instead of complete solutions, in case this is an exercise)
13:30:52 <haskell374> yes i'm learning monoids, and revisiting tree's where i've implemented some functions on it before and now i do an abstraction over it
13:31:00 <ski> ok
13:32:56 <ski> monoid means that you can "smash" any sequence of elements together (based on the operations `mappend'/`(<>)' for smashing two of them into one, and `mempty' for smashing zero of them into one)
13:33:48 <bitemyapp> @karma+ bgamari
13:33:49 <lambdabot> bgamari's karma raised to 5.
13:33:51 <bitemyapp> @karma+ rwbarton
13:33:52 <lambdabot> rwbarton's karma raised to 34.
13:34:48 <ski> haskell374 : is that useful / does that make any sense ?
13:35:20 <davidfetter_fbn> hi
13:35:32 <dfeuer> Good point, ReinH.
13:36:16 <haskell374> ski: yes
13:36:32 <haskell374> ski: like Sum 1 <> Sum 2 
13:36:39 <dfeuer> Is there any package out there offering more than a few little drips and dribbles for type-indexed functors (Atkey and/or McBride)? I see the indexed package, but that's very limited and not even polykinded.
13:37:16 <dfeuer> ala looks utterly mysterious to me, but hey, whatever.
13:37:25 <crough> haskell374: it's also important to know that anything smashed with mempty is still itself.
13:38:06 <ski> (order of the elements in the sequence may matter, so `a <> b' may be different from `b <> a'. "grouping" doesn't matter, meaning that `(a <> b) <> c = a <> (b <> c)' as Ankhers said)
13:38:41 <dfeuer> I guess Unwrapped is a type family?
13:39:23 <ski> haskell374 : so the `Monoid m' part of the type signature means that there will be `mempty' and `mappend'/`(<>)' operations (and also derived ones like `mconcat') available on the type `m', that does some notion of "smashing"
13:40:06 <ski> haskell374 : your job is presumably to decide on some sensible *order* in which to take the elements of the tree, and combine them all together using such monoid operations
13:41:15 <ski> haskell374 : do you think you have an idea of what to do now ? do you want to ask about any term or concept, e.g. ones being mentioned ?
13:41:59 <haskell374> so i'm guessing (a->m) means i map a node label to a monoidal (is that the right word?) and then foldTree combines the monoidal result with the tree?
13:44:11 <ski> haskell374 : `a -> m' is the type of a function being passed to you (to `foldTree') as an argument, that you can use to convert elements in the tree of type `a' to elements of the type `m' which has the "smashing" operations associated with them, yes. and then `foldTree' will (presumably) apply this function to every element, and combine ("smash") the results together, in the chosen/selected order
13:46:05 <ski> haskell374 : e.g., in `foldTree Sum (Node 2 [Node 3 [],Node 5 [Node 7 [],Node 11 []],Node 13 []])', `Sum' will presumably be applied to all the `Integer' (say) elements, converting them to the type `Sum Integer'. then `foldTree' will use its selected ordering of the elements to combine these `Sum ..number..' things together using the `Sum Integer' monoid -- which just sums the numbers "within"
13:47:06 <haskell374> ok, ill try
13:47:11 <ski> haskell374 : so, hopefully, the result of this should be `Sum 41' (still of type `Sum Integer', you have to apply the "extraction" function `getSum' to the result to get back a "plain" `Integer')
13:48:51 <davidfetter_fbn> so i forked this project, and as a complete haskell n00b, i probably got something badly wrong. https://github.com/davidfetter/plhaskell
13:49:28 <davidfetter_fbn> what's the Right Way™ to set what the -L in the Makefile should point to? or do the cool kids these days use a non-make build system?
13:50:44 <davidfetter_fbn> (there's no /usr/lib/ghc on my system)
13:53:26 <Welkin> davidfetter_fbn: we use cabal to build
13:53:35 <Welkin> or stack
13:54:05 <davidfetter_fbn> so what would the cabal version look like?
13:54:51 <Gurkenglas> davidfetter_fbn, what's the "case <something> of Dict" for? If there's only the one case match, couldn't you remove that part?
13:55:19 <davidfetter_fbn> oh, so you think i actually read the .hs source first ;)
13:55:44 <davidfetter_fbn> i just forked the project because i was hoping to hack my way into embedding haskell in postgresql
13:55:56 <Welkin> davidfetter_fbn: install cabal, then use cabal init
13:56:06 <Welkin> that will create the cabal config files for you
13:56:22 <Welkin> or just use stack 
13:56:56 <ReinH> dfeuer: which point? :)
13:57:12 * davidfetter_fbn sees he's got some studying to do
13:57:40 <glguy> Gurkenglas: In the case of "case x of Dict -> _here", the dictionary carried by the Dict is in scope inside "_here"
13:58:57 <Gurkenglas> glguy, how would one implement Dict to work like that? ghc magic?
14:00:08 <glguy> Gurkenglas: using the ExistentialQuantification or GADTs extension
14:00:10 <glguy> http://hackage.haskell.org/package/constraints-0.6/docs/Data-Constraint.html
14:03:16 <lpaste> glguy pasted “using constraints” at http://lpaste.net/151468
14:09:46 <haskell374> ski: i think i got it: foldTree :: Monoid m => (a -> m) -> Tree a -> m foldTree f (Node x ts) = f x <> (foldr (<>) mempty $ map (foldTree f) ts) 
14:10:18 <haskell374> does it matter if it's a leftr / leftl ?
14:11:21 <ski> haskell374 : no, the grouping doesn't matter. only the order may matter
14:12:02 <ski> (well, it may matter in case some of your subtrees in the tree has an infinite amount of child trees)
14:12:13 <ski> haskell374 : note that `mconcat = foldr (<>) mempty'
14:12:34 <ski> haskell374 : in any case, good work ! :)
14:12:54 * ski would personally use brackets instead of `$'
14:13:14 <haskell374> thanks for your help!
14:14:26 <ski> haskell374 : .. if you wanted to, you could replace the `mconcat' and `map' with `foldMap'
14:14:39 <ski> (if you want to, you can ponder that)
14:15:04 <ski> @src concatMap
14:15:04 <lambdabot> concatMap f = foldr ((++) . f) []
14:15:20 <ski>   concatMap f xs = concat (map f xs)
14:15:31 <ski> ^ that's something a bit similar to what i was thinking about
14:22:34 <ReinH> haskell374, ski: Fun fact: For the monoid of ordered lists with merge, a left- or right- fold is insertion sort while a tree fold is mergesort.
14:25:40 <topin212_> Hello, just another newbie here, having trouble with Happstack. I have a IO String and i want to display it on the page somehow. Which means I have to turn it to Response, wrapped in ServerPart monad, and I have no idea how could I do this. if anyone could give a piece of advise of where to start digging, i would be very thankfull
14:26:31 <benzrf> topin212_: is writing a ServerPart a PerverseArt?
14:27:30 <monochrom> probably some liftIO is useful
14:28:48 <dmj> liftIO ioString >>= resp 200
14:31:27 <dfeuer> ReinH, Any/or
14:31:37 <topin212_> thanks, I'll try to figure it out
14:31:53 <dmj> topin212_: can you paste your code for us to see?
14:31:55 <dmj> @where paste
14:31:55 <lambdabot> Haskell pastebin: http://lpaste.net/
14:36:26 * hackagebot base-orphans 0.5.1 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.5.1 (ryanglscott)
14:39:49 <jellytux> Hi, I am starting to learn Haskell, right now. I am wondering where my ghci.conf (local file) should be stored
14:40:00 <jellytux> ~/.ghc/ghci.conf?
14:40:08 <monochrom> yes, try that initially
14:40:25 <jellytux> should I copy it from somewhere? Or can I start blank?
14:41:01 <monochrom> start blank. add stuff you like. but probably you will add nothing. I certainly add nothing.
14:41:27 * hackagebot primitive-simd 0.1.0.0 - SIMD data types and functions  https://hackage.haskell.org/package/primitive-simd-0.1.0.0 (JonasScholl)
14:41:28 <jellytux> monochrom: I added syntax-highlighting
14:41:30 <glguy> jellytux: You don't need one and likely won't have one in the future
14:41:33 <jellytux> monochrom: it works fine, thanks!
14:42:53 <jellytux> didn't highlight as much as I'd hoped though :(
14:43:45 <jellytux> oh nvm
14:44:24 <topin212_> put some code together in a smaller example here: http://lpaste.net/151472
14:46:27 * hackagebot rev-state 0.1.2 - Reverse State monad transformer  https://hackage.haskell.org/package/rev-state-0.1.2 (DanBurton)
14:46:29 * hackagebot fltkhs 0.4.0.2 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.2 (deech)
14:49:14 <Gurkenglas> topin212_, tuplesToString is concatMap (\(a, b) -> [show a, b]). You can remove line 29 and "result <-" from line 28
14:52:38 <Gurkenglas> topin212_, replacing "ok $ toResponse" with liftIO should work
14:57:00 <jroesch_> is there a way to turn off type holes? 
14:57:51 <crough> Do they cause a problem?
14:58:34 <jroesch_> I'm getting an error where a name is being treated as a hole, this is from Coq extraction so its possible the error is over there, but I believe the name to be in scope. 
14:59:20 <topin212_> Gurkenglas, I tried not reinventing a wheel, but didn't manage, thank you
14:59:47 <glguy> topin212_: The version you had was just fine
15:00:27 <fizruk> jroesch_: -fno-warn-typed-holes
15:01:13 <Gurkenglas> glguy, but he's feeding an IO String into toResponse
15:02:08 <glguy> Gurkenglas: I don't think reinventing the wheel was in response o the ok $ toResponse part
15:02:26 <glguy> or at least I didn't when I wrote my message
15:03:10 <glguy> I'd only seen the concatMap bit
15:03:23 <Gurkenglas> Oh but just doing liftIO won't make it into a response... topin212_, you'll need to do either "liftM toResponse $ liftIO $ do" or "liftIO $ liftM toResponse $ do" or either one with fmap instead of liftM, or "liftIO $ toResponse <$> do" for some infixing
15:04:43 <Gurkenglas> or of course you could replace unwords by "toResponse $ unwords" instead
15:05:47 <Gurkenglas> or you could put "toResponse . unwords . tuplesToString" to the left of that <$> so you won't even need to give dbResp a name because you can just return sqlAsker directly, and then you don't even need the do
15:06:07 <Gurkenglas> Like this: "liftIO $ toResponse . unwords . tuplesToString <$> sqlAsker"
15:09:32 <ReinH> Or toResponse . unwords . tuplesToStirng <$> liftIO sqlAsker
15:10:03 <ReinH> May be more effective if you spell string correctly.
15:12:44 <cheater> hello
15:13:03 <cheater> there's a lot of builds missing in https://downloads.haskell.org/~platform/7.10.3/ compared to https://downloads.haskell.org/~platform/7.10.2/ - who would i report this to?
15:16:14 <glguy> cheater: Which build are you looking for?
15:16:24 <glguy> most of the extra files in the 7.10.2 case are rebuilds
15:16:59 <topin212_> Gurkenglas: well, wow, that worked, now I'll try to understand why, thanks!
15:17:06 <glguy> and the stray GHC files are available in a separate directory
15:17:55 <Lokathor> why is an FRP Event called Event and not EventStream
15:18:02 <Lokathor> seems strange to me
15:18:31 <conal> Lokathor: yup.
15:19:09 <conal> Lokathor: you could think of "an event" vs "occurrences of an event".
15:19:18 <Lokathor> considering trying out reflex and/or reflex-dom to make an idle game
15:19:28 <Lokathor> because what the world REALLY needs is more idle games :3c
15:19:30 <EvanR> its the same in javascript
15:19:39 <EvanR> they called event classes "events"
15:19:49 <EvanR> subscribe to an event
15:19:55 <conal> Lokathor: but this name choice has confused people ever since i moved from single-occurrence to multi-occurrence "events" in 1997 or so.
15:19:58 <EvanR> meaning all occurrenes of that class of events
15:20:14 <phaazon> dammit, what’s the syntax to declare a closed type data family with an operator?
15:20:19 <phaazon> like the region’s constraint one:
15:20:27 <phaazon> data family (<=) a b :: Constraint where…
15:21:28 <conal> phaazon: TypeOperators in a LANGUAGE pragma, if i get what you mean.
15:21:35 <phaazon> ok, thanks
15:21:38 <phaazon> I forgot about that
15:22:00 <phaazon> hm, nope
15:22:03 <phaazon> I still have an error
15:22:15 <Lokathor> alternately another subject
15:22:19 <phaazon> wtf is going on
15:22:29 <Lokathor> question, does using ST have speed advantages over using a State ?
15:22:46 <Lokathor> or, when would you use a ST computation over a State computation
15:22:55 <ReinH> ST and State are not really similar
15:22:59 <phaazon> ah, the issue was linked to the fact closed data families don’t exist
15:23:01 <ReinH> ST allows local mutation.
15:23:04 <phaazon> I was looking for closed type families
15:23:14 <ReinH> i.e., an ST operation over an array can actually mutate the array in place.
15:23:43 <ReinH> So ST can be more efficient when you need mutation.
15:23:53 <Lokathor> well i think i'll try ST
15:23:56 <phaazon> ST is efficient èfor mutation
15:24:00 <phaazon> -è
15:24:16 <Lokathor> because i want to write a thing that will be heavily mutation based
15:24:32 <ReinH> Well, State can't do mutation, so ST seems like the obvious choice.
15:24:44 <ReinH> Then again, many things that require mutation in other languages do not require mutation in Haskell.
15:25:20 <Lokathor> with State you can update the state, which is basically the same thing as mutating it most of the time, since you don't go back in time
15:25:32 <ReinH> No, it is not.
15:25:44 <ReinH> It is very much not the same thing as mutation.
15:25:46 <koz_> Could someone tell me what the deal with FlexibleContexts is? I think I've written something sane, but GHC won't accept it without that pragma.
15:26:02 <Lokathor> ReinH, can you give an example perhaps?
15:26:09 <dmj> koz_: can you paste your code
15:26:13 <koz_> Code in question: http://paste.rel4tion.org/235
15:26:15 <phaazon> koz_: it lets you flexible contexts
15:26:18 <ReinH> Every use of State is an example.
15:26:24 <captainobvious> tata
15:26:36 <koz_> phaazon: Wow, I never would have guessed. :P
15:26:41 <phaazon> :D
15:26:43 <phaazon> yeah well
15:26:59 <phaazon> a context should have a head in the form C a0 a1 .. a_n
15:27:12 <phaazon> so if you have several C for instance, or ~ equalities
15:27:15 <phaazon> I guess you need FlexibleContexts
15:27:32 <cheater> glguy: linux x86
15:27:58 <koz_> phaazon: Well, that's fine and dandy, but I'm not sure why *my code* needs this specifically, hence my question.
15:27:58 <fr33domlover> koz_, which line of that file triggers the error?
15:28:13 <koz_> fr33domlover: The start of the definition of 'go'.
15:29:06 <phaazon> koz_: show some code then, so that we can tell you why :)
15:29:25 <cheater> glguy: i didn't understand the rest of your comment about rebuilds and "stray files".
15:29:59 <phaazon> @index Constraint
15:29:59 <lambdabot> GHC.Exts
15:30:50 <phaazon> that’s funny how () is the single inhabitant of Constraint :)
15:30:57 <koz_> Thank my uni for this wirelesss instability I'm experiencing...
15:32:01 <koz_> phaazon: Why is that funny?
15:32:19 <phaazon> koz_: because I thought it have a value Constraint
15:32:28 <phaazon> like 
15:32:32 <phaazon> data Constraint = Constraint
15:32:35 <glguy> cheater: There isn't a 32-bit linux platform build for 7.10.2, either
15:32:38 <phaazon> or something along this line
15:32:50 <glguy> cheater: The point was that while it looks like files are missing in 7.10.3 relative to 7.10.2, there aren't
15:33:00 <Lokathor> ReinH, that statement doesn't improve my understanding of the distinction you're trying to draw
15:34:40 <fr33domlover> koz_, i'd go to the GHC manual to see exactly what FlexibleContexts is, and then try to add a type signature for 'column' and/or 'go' and see what happens
15:34:57 <koz_> fr33domlover: How would I add a type sig for 'go'?
15:35:23 <fr33domlover> koz_, just like you always do. go :: x -> y -> z
15:35:24 <fr33domlover> etc.
15:35:32 <fr33domlover> you can use these in where clauses too
15:35:47 <koz_> fr33domlover: So I can just put that in the where?
15:35:49 <koz_> Neat.
15:35:51 * koz_ tries that.
15:36:38 <fr33domlover> koz_, also a little extra hint: your 'go' function can become a fold instead of directly using recursion
15:36:48 <fr33domlover> that would be the Haskell way to do it :P
15:37:04 <koz_> fr33domlover: Yeah, I figured as much - I'm currently drafting it, and will revise to fold-form.
15:37:06 <fr33domlover> (of course sometimes recursion is needed, but here i think a fold fits perfectly)
15:37:21 <koz_> I'm too used to Scheme, where recursion is used more frequently in my experience.
15:46:39 <Lokathor> fold is still recursive of course :D
15:47:06 <Lokathor> it's just a particular well-structured recursion that others can recognize more easily
15:48:12 <koz_> Lokathor: Yeah, I understand - just a habit change.
15:48:50 <jellytux> what does init stand for when getting the last element of a list?
15:49:12 <fizruk> everything but last?
15:49:13 <jellytux> whenever I see `init` I think of initialize
15:49:21 <jellytux> fizruk: yes, sorry
15:49:21 <crough> jellytux: initial
15:49:24 <fizruk> initial part of a list, I think
15:49:48 <jellytux> I see
15:51:57 <koz_> Wow, using fold makes it so much more concise.
15:52:11 <ThatTreeOverTher> and thus, koz_ was enlightened
15:52:37 <koz_> ThatTreeOverTher: Lol, it's all good. As I said, gotta change my writing habits.
15:53:04 <dmj> "and from that day forward, koz_ was never the same"
15:53:14 <jellytux> what is ? reserved for?
15:53:24 <crough> its not
15:53:51 <fizruk> > let x ? y = x + y in 2 ? 3
15:53:53 <lambdabot>  5
15:54:08 <cheater> glguy: oh. why is there no 32 bit linux build of hp at all?
15:54:37 <crough> jellytux: I usually define ? as flip fromMaybe
15:55:03 <koz_> I got the function down to two lines.
15:55:06 <crough> > let opt ? other = flip fromMaybe in Nothing ? "Hello world"
15:55:07 <lambdabot>      No instance for (Typeable c0)
15:55:07 <lambdabot>        arising from a use of ‘show_M21114107875264783429712’
15:55:07 <lambdabot>      In the expression:
15:55:11 <crough> oh well oops
15:55:16 <crough> > let (?) = flip fromMaybe in Nothing ? "Hello world"
15:55:18 <lambdabot>  "Hello world"
15:55:36 <crough> > let (?) = flip fromMaybe in Just "Not hello world" ? "Hello world"
15:55:38 <lambdabot>  "Not hello world"
15:57:38 <glguy> cheater: A generic build isn't provided, I don't know why, but lots of distros package the haskell platform in their package managers. If you're using a 32-bit linux you might find it htere
15:57:43 <jellytux> crough: hold on wait, (?) is not defined?
15:57:54 <cheater> glguy: it's very old.
15:58:04 <cheater> glguy: the distros don't keep up at all.
15:58:19 <glguy> cheater: Then you'll have to build it from source if you need modern HP on 32-bit linux
15:58:26 <jellytux> crough: I am complete noob, started around an hour ago
15:58:36 <cheater> that really sounds like hell
15:59:52 <crough> jellytux: Nope.
16:06:00 <glguy> cheater: You don't have to build a new GHC, just the HP libraries using the library source tarball
16:11:24 <koz_> How do I tell GHCi what type something is? Can I just do the usual Foo :: Bar -> Int type of deal?
16:12:14 <dmj> > "a" :: String
16:12:15 <lambdabot>  "a"
16:12:34 <dmj> koz_: like that ^
16:12:45 <cheater> glguy: ok, so if i just install ghc, how do i get cabal & co?
16:12:47 <koz_> Ah, OK, thanks.
16:13:02 <koz_> What if I want a let-bound variable?
16:13:15 <koz_> Like 'let x = ....' and I wanna tell GHC what x's type is?
16:13:18 <dmj> let a :: String = "a"
16:13:22 <koz_> Ah, right.
16:13:24 <dmj> let a = "a" :: String
16:13:24 <koz_> Thanks.
16:13:36 <dmj> either one, the first requires scoped typed variables
16:13:53 <glguy> cheater: There's a README inside the tarball you can follow
16:13:55 <dmj> let a :: String; a = "a"
16:14:14 <cheater> glguy: what tarball exactly?..
16:14:20 <glguy> source tarball
16:14:24 <glguy> for the haskell platform
16:15:03 <koz_> dmj: It seems not to like me going 'let x :: IntMap Int = ...'.
16:15:21 <koz_> Where ... is something that makes an IntMap Int.
16:15:34 <glguy> cheater: I don't use the HP, beyond that you're going to need someone else to help you
16:16:19 <koz_> I get this error: Illegal type signature: ‘IntMap Int’
16:16:43 <Clint> koz_: see above comment about scoped type variables
16:17:19 <cheater> glguy: OK, thanks though
16:17:28 <koz_> Ah, whoops. Thanks Clint.
16:17:37 <cheater> glguy: but anyways. going back to the original question...
16:17:44 <glguy> If you don't have a cabal-install executable, you can build one of those from source, too. It comes with a bootstrap script in its release source tarball
16:17:48 <cheater> there's no HP build for 32 bit linux, so who do i report this to?
16:18:04 <glguy> There's no one to report it to, it's known that there isn't one
16:18:29 <cheater> why is it accepted?
16:19:00 <danilo2> Hello guys! Is there in Haskell an abstraction that would allow me to do something like `class MayHaveName a where tryName :: Maybe (Lens' a (NameOf a)` ? I know it looks strange, but I want something that I can pattern match on and I can access the lens only if the name was found, so I can replace it. I do not want to gie user the possibility of setting a new name on structure that doesnt provide one
16:19:04 <kadoban> cheater: I'd imagine you already know this or someone has mentioned it, but: you know HP isn't a required thing, you can use haskell without it. (in fact I recommend against using HP unless you have some requirement you must)
16:19:42 <ReinH> danilo2: that sounds like a prism
16:19:43 <dmj> danilo2: I think makeClassy does this
16:19:48 <cheater> yeah, i was just looking for a simple way to get haskell + cabal, that's what HP was for me
16:19:57 <cheater> well ghc + cabal
16:20:04 <Clint> apt-get install ghc cabal-install
16:20:07 <kadoban> cheater: Install 'stack' instead, it's better.
16:20:39 <cheater> Clint: i'm trying to get recent ghc. well i guess i'll just get the ghc binary and go from there with whatever cabal i have.
16:21:12 <danilo2> dmj: no, makeClassy does something completely different as far as I know. It allows you to get the "name" only from objects that provide it, it doesnt return it in Maybe
16:21:33 <danilo2> ReinH: would you be so nice and elaborate a little more on it? How can I use it like in my use case?
16:24:15 <ReinH> danilo2: I'm not sure how you can use it in your use case, but a prism is an optic for a target which may or may not exist.
16:24:50 <hpc> just like a real prism!
16:25:50 <danilo2> ReinH: exactly, but as far as I see, prisms allow you to "update" a value that may not exist. In this case they jsut do nothing and left the value untouched. I dont want this behavior because its very fragile to user errors
16:27:23 <Gurkenglas> Maybe (Lens' a (NameOf a)) would either work for all a or work for none, you can't have that justice depend on which a you're actually lensing into
16:27:40 <ReinH> Gurkenglas: no, it's a typeclass
16:27:47 <ReinH> so a is a specific type
16:28:04 <ReinH> when that typeclass is instantiated, that is
16:28:18 <Gurkenglas> Misunderstanding: If a is Int, your lens still has to work for all Int values or for none
16:28:45 <Gurkenglas> (if it's Just, its simply a lens on all ints, if its Nothing, its not a lens for any subset of ints.)
16:28:53 <danilo2> Gurkenglas: of course. I want to be able to access names of structures that we know (on type level) that provide such name
16:29:12 <danilo2> Gurkenglas: yep, thats correct. I want exactly this behavior
16:32:00 <Gurkenglas> Oh, so each instance implementation of MayHaveName has either a Just or a Nothing directly to the right of its "tryName ="?
16:32:15 <ReinH> danilo2: Is the name a fixed type?
16:34:24 <Gurkenglas> Why not simply leave out the instances where the implementation would be Nothing, so you can remove the Maybe from the class definition?
16:35:21 <jellytux> Your list comprehensions are super-awesome
16:35:42 <ReinH> Mine specifically? Thanks.
16:35:57 <jellytux> ^^
16:37:45 <danilo2> ReinH: the name is just an associated type to a particular type `a` and indeed it is consistent across all the types I use here
16:40:47 * mniip wonders where edwardk is
16:41:30 <hpc> off inventing the next uber-package i bet
16:41:31 <jellytux> do you have predefined notations for infinite series in haskell?
16:41:55 <jellytux> [x | x <-N, x `mod` 2 == 0] !! 3
16:42:05 <mniip> hpc, aww, I wanted to get my uber-package checked :(
16:42:09 <ReinH> jellytux: No.
16:42:27 <ReinH> > [x | x <- [0..], x `mod` 2 == 0] !! 3
16:42:28 <lambdabot>  6
16:42:30 <jellytux> ReinH: should I just write `let N = [1..]` ?
16:42:37 <ReinH> No, N is not a valid variable name.
16:42:49 <jellytux> ah that's right you can capitalize
16:42:55 <jellytux> you can't!
16:42:57 <jellytux> :)
16:43:03 <mniip> 1454373662 [03:41:02] <jellytux> do you have predefined notations for infinite series in haskell?
16:43:08 <mniip> you just said it
16:43:10 <mniip> [1..]
16:43:33 <jellytux> what I meant was syntactic sugar
16:43:47 <mniip> it is syntactic sugar though :)
16:43:52 <monochrom> even ℕ cannot be a variable name
16:43:56 <mniip> for 'enumFrom 1'
16:44:00 <jellytux> syntactic sugar for the syntactic sugar :D
16:44:26 <jellytux> monochrom: how would I even type that and still be sane?
16:44:43 <monochrom> however, data ℕ = N | S ℕ is legal
16:44:53 <mniip> U+2115
16:45:31 <monochrom> I put on emacs and turned on its input method "tex" and entered \Bbb{N}. but I am insane.
16:46:01 <jellytux> oh, I usually go \mathbb{N}, thanks for the abbr
16:46:02 <monochrom> but I had to put on emacs anyway because I wanted to test my code before reporting it.
16:46:22 <mniip> data ℕ = Θ | Σ ℕ
16:46:38 <jellytux> mniip: what does data do?
16:46:46 <mniip> define a datatype
16:47:03 <jellytux> ah its in the guide, haven't gotten there yet
16:47:49 <mniip> worry not. People here always talk about things the rest of the channel doesn't understand
16:47:58 <jellytux> mniip: will it help me use \Bbb{n} as a variable name?
16:48:16 <mniip> ummm no
16:49:05 <jellytux> well then I ought to remain silent
16:49:19 <mniip> the useful piece of information here is that variable names cannot begin with a capital letter
16:49:25 <mniip> the rest is just us being silly
16:49:46 <jellytux> they haven't covered that yet
16:49:50 <jellytux> how come?
16:50:26 <jellytux> are they for something reserved?
16:50:43 <monochrom> they are for type names and constructor names
16:51:14 <jellytux> monochrom: ah, I see
16:51:24 <mniip> hmm
16:51:41 <mniip> does 'StateT a []' traverse
16:51:50 <mniip> probably not
16:53:12 <mniip> that's bad :D
16:54:37 * ski . o O ( <http://blog.sigfpe.com/2006/10/monads-field-guide.html> )
16:55:50 <monochrom> consider ListT (ListT (ListT []))
16:56:14 <mniip> is 'ListT []' a monad?
16:56:40 * ski backtracked backtracking (&c.) long ago
16:57:29 <mniip> oh hey ski
16:57:30 <ski> mniip : i don't remember details, but i suspect dpiponi's `ListT' there is continuation-based
16:57:38 <mniip> have you seen the free parser :o
16:58:01 <ski> not that i can recall
16:58:05 <mniip> http://lpaste.net/151381
17:04:10 <mniip> ski, I didn't realise it is something interesting but apparently it is?
17:04:11 <ski> mniip : hm, so you must ask for the next token before being allowed to nondeterminate ?
17:04:20 <mniip> ski, huh
17:04:44 <dedgrant> Hmm.. does GHC have a convenient syntax extension for value-level construction of HList types?
17:04:46 <mniip> "nondeterminate"?
17:05:53 <ski> er, i see i was reading it wrong
17:06:05 <dedgrant> (ie. translating some binary associative x & y & z & nil to some '[x,y,z])
17:06:23 <ski> "nondeterminate" being using effects in the chosen nondeterminism monad `b'
17:06:30 <mniip> ski, 'b' comes before Pure/Free
17:07:14 <mniip> might as well be 'pure 1 <|> pure 2'
17:07:15 <ski> iow, i was thinking `t -> b (...)' rather than `b (..(t -> ...)..)'
17:07:32 <mniip> which is FreeT (Pure 1 <|> Pure 2)
17:07:47 <mniip> err
17:07:58 <mniip> which is FreeT (pure (Pure 1) <|> pure (Pure 2))
17:10:44 <mniip> :t foldr (<|>) empty
17:10:45 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
17:10:50 <mniip> :o
17:10:58 <jle`> :O
17:11:44 <mniip> no wait
17:11:52 <danilo2> Ouch! Is anybody able to explain to me why (and how we can fix it) I'm unable to declare such typeclass? `class MayHaveAttr a t where checkAttr :: a -> Maybe (Lens' t (Attr a t))` GHC complains: Illegal polymorphic or qualified type: Lens' t (Attr a t)
17:12:00 <mniip> :t foldr ((<|>) . pure) empty
17:12:02 <lambdabot> (Foldable t, Alternative f) => t a -> f a
17:12:31 <ski> danilo2 : it's a type synonym for a universal type
17:13:27 <mniip> you'll have to factor the forall out of Maybe
17:13:27 <danilo2> ski: yep, can we do something with it ? :/
17:13:45 <danilo2> mniip: ah, I'll try!
17:14:45 <ski> danilo2 : enabling `ImpredicativeTypes' may allow it. alternatives would be to define a new data type for it (with `PolymorphicComponents' or `Rank2Types' or `RankNTypes'), or to CPS the type signature (with `Rank2Types' or `RankNTypes')
17:15:06 <mniip> Lens' t (Attr a t) ===> forall f. Functor f => (t -> f (Attr a t)) -> t -> f (Attr a t)
17:15:51 <danilo2> mniip: thank you!
17:15:52 <ski> (hm, actually `Rank2Types' wouldn't be enough in the CPS case, i suppose)
17:16:14 <danilo2> ski, mniip : that was a good idea! I dont want to enable ImpredictiveTypes here, but using class MayHaveAttr a t where checkAttr :: a -> Maybe ((a -> f a) -> s -> f s) solves the problem
17:16:19 <SrPx> Could someone link me to the definition of Prelude.$! ? I can't find that on google. I could find on hoogle but not the source. 
17:16:20 <danilo2> of course with some nice wrappers around
17:16:24 <danilo2> thank you guys! :)
17:16:58 <ski>   checkAttrMaybe :: forall o. a -> o -> (Lens' t (Attr a t) -> o) -> o  -- CPS
17:17:02 <ski> @type maybe
17:17:04 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:17:10 <mniip> SrPx, http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#%24
17:17:18 <SrPx> ty
17:17:19 <Solarlux> Hello all
17:17:29 <Solarlux> I 'm new in Haskell club
17:17:33 <Solarlux> Hello to all
17:17:36 <johnw> hello!
17:17:37 <jle`> hi :D
17:17:39 <ski> hello Solarlux
17:17:45 <Solarlux> What haskell language can do?
17:17:52 <Solarlux> I started learn it and i like
17:17:57 <SrPx> f $! x                  = let !vx = x in f vx  -- see #2273...
17:17:59 <SrPx> #2273?
17:18:05 <mniip> trac ticket I assume
17:18:10 <Solarlux> Is possible to make user interfaces in haskell?
17:18:11 <jle`> Solarlux: it's a general purpose language
17:18:16 <jle`> so it can do pretty much anything
17:18:17 <Solarlux> Liker C++?
17:18:18 <jle`> but better :D
17:18:20 <jle`> yes
17:18:25 <mniip> ski, so is this FreeT parser anything new/interesting?
17:18:27 <Solarlux> I cna build softwares?
17:18:29 <mniip> SrPx, https://ghc.haskell.org/trac/ghc/ticket/2273
17:18:31 <Solarlux> Niice\
17:18:38 <SrPx> oh okay
17:19:45 <Solarlux> Haskell new language?:D
17:19:54 <Solarlux> Rapidly developing i guess?
17:20:35 <mniip> Solarlux, it's been around for decades
17:21:03 <mniip> >First appeared 	1990; 26 years ago
17:21:08 <Solarlux> Nice
17:21:22 <Solarlux> I heard first abvout this language month ago and i started to learn it now
17:21:45 <Solarlux> It can do things like JAVA ?
17:22:34 <mniip> "things like java"?
17:22:41 <Solarlux> Yes
17:22:52 <Solarlux> It can do all what JAVA can?
17:22:58 <ski> mniip : well, i didn't see it before. i suppose it's more or less a deep embedding. perhaps one can do something fun with the expression in terms of `FreeT', i dunno
17:23:04 <mniip> Solarlux, you gotta be more specific
17:23:26 <Solarlux> For example i make application fully functional with user injterface
17:23:32 <Lokathor> Solarlux, Haskell can do all the things Java can do, and even some thing java can't easily do
17:23:34 <Solarlux> In haskell is it possible?
17:23:41 <mniip> there are gui libraries yes
17:23:43 <Solarlux> Nice
17:23:49 <Solarlux> Thanks about motivation (=
17:23:52 <synergistics> I want to learn category theory, typed lambda calculi, and generally just a lot of academic topics related to FP. Should I do that alongside learning haskell, or wait until I'm a proficient haskeller to start with a lot of theory? I already know a bit about untyped and simply typed lambda calc, but not much type theory.
17:24:30 <Solarlux> Haskell better than Python ?
17:24:36 <Solarlux> true?
17:24:40 * ski . o O ( "Can Haskell make giant balls of mud as easily as Java?" )
17:24:51 <Solarlux> :D
17:24:59 <johnw> synergistics: alongside is fun, don't wait
17:25:33 <mniip> synergistics, tbf learning haskell first has a slight downside when learning CT
17:25:39 <synergistics> johnu: Ok. It's been hard to keep track of them both, so I'll have to change my approach
17:26:24 <mniip> you tend of think in terms of the Hask category, which limits your fields of view quite a bit
17:26:31 <synergistics> mniip: I have a very very basic understanding of CT. Nothing intensive at all, but conceptually, I understand up to functors
17:26:32 <ski> synergistics : perhaps you could take a look at "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>
17:27:03 <ski> synergistics : and also "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
17:27:22 <synergistics> mniip: Not to say that I'm at all proficient at any of it
17:27:42 <synergistics> ski: Thanks, I'll look at both now
17:28:19 <ski> synergistics : there's also TaPL. and many of Wadler's papers <http://homepages.inf.ed.ac.uk/wadler/topics/> are also quite readable
17:28:23 <ski> @where TaP
17:28:23 <lambdabot> I know nothing about tap.
17:28:25 <ski> @where TaPL
17:28:25 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
17:28:42 <Solarlux> I need IDE with HASKELL compiler
17:28:52 <Solarlux> Can anyone help me please?
17:28:59 <fr33domlover> Solarlux: Vim, Emacs, Atom...
17:29:07 <fr33domlover> great text editors for developers
17:29:20 <fr33domlover> all have haskell support (using plugins etc.)
17:29:22 <Solarlux> I need IDE with haskell compilet already installed inside
17:29:31 <Solarlux> Codeblocks?
17:29:36 <synergistics> Why can't you install a plugin?
17:29:44 <ski> synergistics : "Conceptual Mathematics" by Steve Schanuel,William Lawvere is a book on CT concepts that is quite slow and easy going
17:29:45 <fr33domlover> Solarlux: Vim, Emacs, Atom...
17:29:47 <Solarlux> I don't know how to install
17:29:48 <Lokathor> Solarlux, there's no IDE with haskell pre-included
17:29:55 <Solarlux> )=
17:30:19 <synergistics> ski: Which would you reccomend the most to start?
17:30:21 <ski> (synergistics : a uni library near you may carry it)
17:30:54 <Lokathor> Solarlux, http://www.seas.upenn.edu/~cis194/spring13/lectures.html is a good way to learn for free
17:30:56 <mniip> ski, there's this one thing though
17:31:01 <SrPx> using haste-boot gives me this error: http://lpaste.net/151477 is this anything familiar and/or of easy fix for you?
17:31:10 <mniip> 'Parser b' is a Profunctor and a Category
17:31:14 <ski> synergistics : hard to say. i suppose it depends on what you're most curious to learn about
17:31:20 <mniip> but we can't make use of that without a newtype
17:31:22 <SrPx> I just tried installing haste on osx el capitan
17:32:01 <synergistics> ski: Category theory, but it seems that has the most prerequisites. But you say "Conceptual Mathematics" reads more easily?
17:32:24 <ski> synergistics : i think it reads more easily than some books on CT, yes
17:32:52 <ski> synergistics : there's also some book called "Category Theory for Computer Scientists" or something like that, which you could take a glance at
17:33:11 <ski> and "Computational Category Theory", and another one i can't recall the name of
17:34:02 <synergistics> Yea, I've heard that one mentioned
17:34:49 <synergistics> ski: Is this how you approached it, reading some of these books?
17:37:29 <Bruuuuno> Hi, I have the function foldp f z e = accumE z (fmap f e), which have the signature : foldp :: MonadMoment m => (a -> b -> b) -> b -> Event a -> m (Event b)
17:38:01 <Bruuuuno> however, accumE is accumE :: MonadMoment m => a -> Event (a -> a) -> m (Event a)
17:38:10 <Bruuuuno> I don't get why foldp have that signature
17:39:56 <ski> synergistics : i also remember looking at CS papers talking to some extent about CT, and about some CT-papers (ADJ group)
17:40:48 <ski> synergistics : also attempting to read others of the "math" books on CT
17:42:39 <ski> ("Categories for the Working Mathematician","Toposes, Triples and Theories","Abstract and Concrete Categories: The Joy of Cats",Awodey's book,&c.)
17:43:05 <ski> synergistics : and, of course, CS papers using CT terminology
17:43:33 <synergistics> ski: Why'd you do it? For fun; for a class?
17:44:02 <ski> for fun/curiosity
17:45:00 <synergistics> Haha, nice
17:45:10 <synergistics> That's awesome
17:45:10 <ski> Bruuuuno : are you wondering how to justify that signature, or are you wondering why it was inferred ?
17:45:25 <jellytux> how often do you use ghci?
17:45:38 <jellytux> or do you use some sort of testing utility?
17:46:05 <ski> the interactor (GHCi) can act as a basic testing utility
17:46:23 <jellytux> I mean automated testing
17:46:46 <ski> QuickCheck (randomized property-based testing) is quite popular
17:46:59 <ski> there are also unit-test things,&c.
17:47:10 * ski misses Buddha (a declarative debugger)
17:47:26 <Bruuuuno> ski : how it was infered and what is going on with Event (a -> a)
17:48:17 <ski> Bruuuuno : justifying the type is simpler than to explain why it didn't infer a perhaps more general type
17:49:42 <ski> we assume the following facts
17:49:59 <ski>   MonadMoment m
17:50:05 <ski>   f :: a -> b -> b
17:50:08 <ski>   z :: b
17:50:13 <ski>   e :: Event a
17:50:21 <ski> also, we assume
17:50:24 <ski>   Functor Event
17:50:41 <ski> (which must be the case for the code in question to be allowed, with that type)
17:50:56 <Bruuuuno> yes it is
17:50:59 <ski> we also happen to know
17:51:12 <ski>   accumE :: forall m a. MonadMoment m => a -> Event (a -> a) -> m (Event a)
17:51:27 <ski>   fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
17:52:26 <ski> so, instantiating the `forall'-bound `f',`a',`b' in the universal type of `fmap' to (respectively) `Event',`a',`b -> b', we get
17:52:47 <ski>   fmap :: Functor Event => (a -> b -> b) -> Event a -> Event (b -> b)
17:53:03 <ski> applying the further fact that `Functor Event', we get
17:53:08 <ski>   fmap :: (a -> b -> b) -> Event a -> Event (b -> b)
17:53:18 <ski> then, by the typing rule for application
17:53:24 <ski>   fmap f :: Event a -> Event (b -> b)
17:53:28 <ski> and again by application
17:53:35 <ski>   fmap f e :: Event (b -> b)
17:54:00 <Bruuuuno> I'm not sure on how you got fmap :: Functor Event => (a -> b -> b) -> Event a -> Event (b -> b)
17:54:46 <ski> the `f' in `fmap' becomes `Event'. the `a' in `fmap' becomes our `a'. the `b' in `fmap' becomes our `b -> b'
17:55:04 <ski> so `a -> b' in `fmap' becomes `a -> (b -> b)', which is the same as `a -> b -> b'
17:55:27 <ski> instantiating `m',`a' in `accumeE' to `m',`a', we get
17:55:33 <ski>   accumE :: MonadMoment m => a -> Event (a -> a) -> m (Event a)
17:55:50 <ski> applying the constraint `MonadMoment m'
17:55:54 <ski>   accumE :: a -> Event (a -> a) -> m (Event a)
17:55:58 <ski> application
17:56:02 <ski>   accumE z :: Event (a -> a) -> m (Event a)
17:56:03 <ski> application
17:56:16 <ski>   accumE z (fmap f e) :: m (Event a)
17:57:10 <ski> the type of the definiendum (the defined thing, to the left of `=') is the type of the definiens (the body, to the right of `=')
17:57:17 <ski>   foldp f z e :: m (Event a)
17:57:31 <ski> abstracting away `e', using its type
17:57:40 <ski>   foldp f z :: Event a -> m (Event a)
17:58:46 <ski> sorry, one correction. we're replacing `m',`a' in `accumE' by `m' and *`b'* !
17:59:09 <ski> so the `m (Event a)' we have here should really be `m (Event b)'. sorry about that
17:59:16 <ski> (continuing from)
17:59:24 <ski>   foldp f z :: Event a -> m (Event b)
17:59:27 <ski> abstracting away `z', using its type
17:59:37 <ski>   foldp f :: b -> Event a -> m (Event b)
17:59:41 <ski> abstracting away `f', using its type
18:00:00 <ski>   foldp f :: (a -> b -> b) -> b -> Event a -> m (Event b)
18:00:08 <ski> abstracting away the fact `MonadMoment m'
18:00:17 <ski>   foldp :: MonadMoment m => (a -> b -> b) -> b -> Event a -> m (Event b)
18:00:45 <ski> we're no longer depending on any assumptions which mention the type variables `m',`a',`b', so we may now generalize on those
18:00:51 <ski>   foldp :: forall m a b. MonadMoment m => (a -> b -> b) -> b -> Event a -> m (Event b)
18:01:04 <ski> Bruuuuno : that's the basic deduction
18:01:34 <Bruuuuno> [20:54] <ski> the `f' in `fmap' becomes `Event'. the `a' in `fmap' becomes our `a'. the `b' in `fmap' becomes our `b -> b'
18:01:35 <Bruuuuno> how does b become b->b?
18:02:09 <ski> look again at the ((most) general) type signature of `fmap'
18:02:13 <ski>   fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
18:02:45 <ski> the `forall f a b' part here can be omitted, and is then implicit. but conceptually it's always there. it's the `forall' which signifies that `fmap' is a polymorphic operation
18:03:37 <ski> the `forall' *binds* the type variables `f',`a',`b'. so those variables are distinct from any other `f',`a',`b' which may occur anywhere else in the program (or in our case, in reasoning about the program)
18:04:07 <ski> in particular, those variables `f',`a',`b' have, at least from an initial standpoint, nothing to do with *our*
18:04:23 <ski> type variables `m',`a',`b', related to the signature of `foldp'
18:04:29 <mniip> hmm
18:04:38 <mniip> what's the idea of ParsecT
18:04:40 <ski> when i started by saying
18:04:43 <mniip> what does the 'm' part let us do
18:04:47 <ski>   f :: a -> b -> b
18:04:47 <ski>   z :: b
18:04:50 <ski>   e :: Event a
18:04:59 <ski> i did *not* mean to say
18:05:07 <ski>   f :: forall a b. a -> b -> b
18:05:12 <ski>   z :: forall b. b
18:05:19 <ski>   e :: forall a. Event a
18:05:39 <ski> (which would be something completely different, and not what we need to talk about for the code in question)
18:06:29 <ski> i was talking about some *particular* (but unknown) types `a',`b' (and `m'). specifically the *same* type `a' in the type of `f' as in the type of `e'. and the *same* typr `b' in the type of `z' as in the type of `f'
18:07:26 <ski> so, when `foldp' will be *called*, then the caller will determine some *actual* types to use in place of these `m',`a',`b' (or possibly defer to choice to *its* caller, &c.)
18:08:18 <ski> in the argument, i should probably have started the deduction by explicitly saying something like "Assume given any types `m',`a',`b'."
18:08:28 <ski> anyway
18:08:30 <ski>   fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
18:08:34 <ski> means the same thing as
18:08:47 <ski>   fmap :: forall g c d. Functor g => (c -> d) -> g c -> g d
18:09:00 <ski> we're allowed to rename bound variables (as long as we do it consistently)
18:09:16 <ski> but, in an argument such as above
18:09:22 <ski>   f :: a -> d -> d
18:09:29 <ski> would mean something different from
18:09:32 <ski>   f :: a -> b -> b
18:10:07 <ski> (the first is talking about some particular types `a' and `d', the second instead about some particular types `a' and `b'. `b' and `d' may possibly refer to different types in the current argument)
18:10:24 <Bruuuuno> I get that, but the thing I don't get is what's the magic with Event (a -> a)
18:10:46 <ski> ok, i'll repeat that part (since i goofed up)
18:10:57 <ski> we have
18:11:13 <ski>   accumE :: forall m a. MonadMoment m => a -> Event (a -> a) -> m (Event a)
18:11:15 <ski> and
18:11:23 <ski>   fmap f e :: Event (b -> b)
18:11:39 <ski> (and `z :: b')
18:12:33 <ski> we can fit these together by choosing `m' and `a' in `accumE' (the `a' there being unrelated to *our* `a' in `f :: a -> b -> b' and `e :: Event a') to be `m' and `b'
18:12:51 <ski>   accumE :: MonadMoment m => b -> Event (b -> b) -> m (Event b)
18:12:56 <ski>   accumE :: b -> Event (b -> b) -> m (Event b)
18:13:00 <ski>   accumE z :: Event (b -> b) -> m (Event b)
18:13:09 <ski>   accumE z (fmap f e) :: m (Event b)
18:13:15 <ski> Bruuuuno : better ?
18:15:11 <Bruuuuno> I understood that step, it's the next step I don't get, how do you get the type of f
18:15:32 <ski> i assumed the type of `f' to be `a -> b -> b', early on
18:15:59 <ski> by "magic", or an "oracle", "looking in the crystal ball", if you like
18:16:32 <ski> (asking how that works amounts to asking how the type inference works. which is not what i was attempting to explain. i only tried to justify its end result)
18:18:02 <Bruuuuno> oh well, that was by original question, sorry if I wasn't clear, but thanks for the explanation 
18:18:39 <ski> *if* `f' has type `a -> b -> b', `z' has type `b', and `e' has type `Event a', and furthermore `MonadMoment m' holds, *then* `accumE z (fmap f e)', and therefore also `foldp f z e', has type `m (Event b)'
18:19:16 <ski> abstracting away the types of the arguments in `foldp f z e', one by one, gives us the type `(a -> b -> b) -> b -> Event a -> m (Event b)' for `foldp'
18:20:18 <ski> further abstracting away the fact `MonadMoment m', we can now generalize on `m',`a',`b', getting a type signature `foldp :: forall m a b. MonadMoment m => (a -> b -> b) -> b -> Event a -> m (Event b)'
18:21:03 <ski> Bruuuuno : is this more or less clear ? did you also want to know how the type inference actually found the types for `f',`z',`e' ?
18:21:56 <Bruuuuno> it's perfectly clear :) , but I want to know how the type inference actually found the types for f and e
18:22:14 <ski> for type inference, you need to introduce placeholders/metavariables (aka logic variables or dataflow variables, in some contexts)
18:22:26 <domgetter> >>= has type M a -> (a -> M b) - > M b, but what has type M a -> (a -> b) -> M b ?
18:23:11 <Bruuuuno> flip fmap?
18:23:44 <ski> note that, during a particular call to `foldp', `m',`a',`b' will stand for particular (unknown to `foldp') types. `foldp' doesn't get a say in what these types will actually end up as. it's as if they were abstract data types `M',`A',`B' that we can't look into the implementation of
18:24:12 <domgetter> got it, thank you Bruuuuno
18:24:38 <ski> metavariables/placeholders will be used to stand in for types (type expressions), that we haven't yet decided/determined what they'll actually be yet. that's different
18:25:10 <ski> i'll write metavariables (metas) with a leading `_' here, like `_a',`_b',&c.
18:25:17 <Bruuuuno> play
18:25:20 <Bruuuuno> okay
18:25:43 <ski> we start by assigning fresh metas to the parameters
18:25:47 <ski>   f :: _a
18:25:58 <ski>   z :: _b
18:26:02 <ski>   e :: _c
18:27:40 <ski> then we will compute the type of the definiens, `accumE z (fmap f e)'. for the moment say that will be `_d'. this means that the type of `foldp f z e' will also be `_d', and the type of `foldp' will be `_a -> _b -> _c -> _d', similarly to before
18:28:23 <ski> after that, we will need to abstract away remaining constraints (like `MonadMoment m' above), and generalize
18:29:40 <ski> anyway, each node in the syntax tree of the definiens `accumE z (fmap f e)' will need to be analyzed. we will collect a set of equational *constraints* for the metas
18:30:09 <dedgrant> Ooh here's a puzzler: How does one define typeclass instances for some { data T (t :: k) = T (F t) ; type family F a :: * }? heh
18:30:33 <dedgrant> or otherwise rejigger this so that an equivalent evaluation is possible.
18:30:37 <ski> considering the application `fmap f', we must have `fmap :: _e -> _f' and `f :: _e', and then by application `fmap f :: _f'
18:32:08 <ski> looking at the actual `fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b', we see that the main forms (`forall' vs. `->') doesn't exactly match. however, this is solved by replacing every *use* of a polymorphic operation (like `fmap') with a specific (but undecided) instance of it
18:33:52 <ski> in this case, `fmap' in `fmap f' is specialized to have type `(_h -> _i) -> _g _h -> _g _i' (fresh metas `_g',`_h',`_i' replacing the `f',`a',`b' in the general type signature for `fmap'). also in this case we at this point assume the constraint `Functor _g'
18:34:38 <ski> note that if we had called `fmap' also somewhere else in the expression, then that call would have been specialized using *another* set of fresh metas (and yielding another assumed constraint)
18:34:52 <alan__> ?src foldr
18:34:52 <lambdabot> foldr f z []     = z
18:34:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:35:14 <alan__> ?src foldl
18:35:14 <lambdabot> foldl f z []     = z
18:35:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:35:36 <ski> anyway, in the basic polymorphic type inference system, we can actually start by making such instances of all polymorphic variables (like `fmap' and `accumE' here), only then starting to traverse the main syntax tree
18:36:02 <ski> returning to the application `fmap f'. what do we know ?
18:36:07 <ski> we know
18:36:17 <ski>   Functor _g
18:36:24 <ski>   fmap :: (_h -> _i) -> _g _h -> _g _i
18:36:28 <ski>   f :: _a
18:37:20 <alan__> ?src foldl1
18:37:20 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:37:20 <lambdabot> foldl1 _ []     = undefined
18:37:24 <ski> but because we have an application of `fmap' to `f', we must also have `fmap :: _e -> _f',`f :: _e', .. and then `fmap f :: _f'
18:38:02 <ski> so we have two distinct type expressions being ascribed to both `fmap' and `f' .. so the two types in each of those pairs must then be equal :
18:38:33 <ski>   _e -> _f  =  (_h -> _i) -> _g _h -> _g _i
18:38:41 <ski>   _e  =  _a
18:39:00 <ski> we can simplify the first equation to the two equations
18:39:06 <ski>   _e  =  _h -> _i
18:39:12 <ski>   _f  =  _g _h -> _g _i
18:39:26 <mjrosenb> Does anyone happen to know if any of the standard diff algorithms are linear in the size of the two lists if we know the edit distance between them is bounded by a constant?
18:40:01 <ski> eliminating `_e' (which doesn't appear elsewhere) we can replace the first of these, together with `_e = _a', by
18:40:08 <ski>   _a  =  _h -> _i
18:41:10 <ski> (in fact, we could have not bothered with choosing a fresh meta for the argument type here, instead directly asserting that the argument type in `(_h -> _i) -> _g _h -> _g _i' must be equal to the type of the argument, which is `_a')
18:41:58 <ski> Bruuuuno : as you can imagine, this gets a bit tedious to write out in detail (i can do it if you really want to, but preferable then in another channel, like #haskell-overflow)
18:42:13 <tgeeky> or #haskell-in-depth
18:42:20 <tgeeky> which never gets used :(
18:42:38 <ski> Bruuuuno : the idea is that you generate a set of equational constraints, from considering each node in the syntax tree of the body. and you simplify it as much as possible
18:43:02 <ski> Bruuuuno : if there's a mismatch in trying to simplify, then that's a type error
18:43:25 <Bruuuuno> so in my example
18:44:08 <Bruuuuno> Event (a -> a) == (c -> b) -> f c -> fb
18:44:44 <django_> is this a good place to ask about data?
18:44:51 <django_> I wanna make a project that maps wikipedia
18:44:53 <Bruuuuno> or like _a _b == _c -> _d -> _e
18:46:16 <ski> Bruuuuno : otherwise (in our case), we will (after simplification, and replacing equals by equals) end up with something like `accumE z (fmap f e) :: _t (Event _b)', depending on assumptions `f :: _k -> _b -> _b',`z :: _b',`e :: Event _k',`Functor Event',`MonadMoment _t'
18:46:52 * hackagebot mappy 0.1.1.0 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.1.0 (mjgpy3)
18:46:54 <ski> Bruuuuno : and so `foldp f z e :: _t (Event _b)' under the same assumptions
18:47:44 <ski> Bruuuuno : so, after argument abstraction (discharging the argument assumptions, leaving the constraint ones), `foldp :: (_k -> _b -> _b) -> _b -> Event _k -> _t (Event _b)'
18:49:46 <ski> Bruuuuno : because `_t' in the assumption `MonadMoment _t' has no further information that may allow us to discharge it (as opposed to the constraint `Functor Event', which is a known fact), we abstract on it : `foldp :: MonadMoment m => (_k -> _b -> _b) -> _b -> Event _k -> _t (Event _b)'
18:49:56 <ski> (there was no other constraints to abstract on)
18:51:22 <ski> Bruuuuno : *now*, because there's no equations (or constraints) imposing further information on what `_t',`_k',`_b' must be/satisfy, we "pick" some ordinary type variables (like `m',`a',`b') to *instantiate* `_t',`_k',`_b' (the *remaining* metas) to, and generalize on these (introducing a `forall') :
18:51:51 <ski>   foldp :: forall m a b. MonadMoment m => (a -> b -> b) -> b -> Event a -> m (Event b)
18:52:17 <ski> (sorry, `MonadMoment m' should have been `MonadMoment _t' in the signature before this last one)
18:53:22 <ski> Bruuuuno : so the idea is that we accumulate information on what constraints (class constraints, and equational constraints) these metas must satisfy, and then we try to "solve the equation system", simplifying it as much as possible, and detect whether there is any inconsistency
18:53:51 <Bruuuuno> oh so that's how it work!
18:53:58 <ski> Bruuuuno : "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> might perhaps help more
18:55:03 <ski> <Bruuuuno> Event (a -> a) == (c -> b) -> f c -> fb
18:55:21 <synergistics> ski: Thanks for the book tips, I'm really enjoying "Conceptual Mathematics"
18:55:23 <ski> that would be an inconsistent equation (system). since `Event' doesn't match `(->)'
18:55:30 <ski> synergistics : cheers :)
18:56:09 <ski> Bruuuuno : however, `Event (a -> a)' could be equated to `f b' ..
18:56:21 <ski> (well, if we replace `f' and `b' by metas)
18:56:35 <ski> <Bruuuuno> or like _a _b == _c -> _d -> _e
18:56:42 <ski> i didn't follow this one
18:59:48 <kevinkjt2000> Hi, I'm new here.  Is this the right place to ask for help during building ghc?
19:00:54 <mjrosenb> it is not a bad place, but #ghc may be better?
19:01:12 <mjrosenb> it also depends on what exactly the problem is.
19:01:40 * mjrosenb would suggest asking, and if it is better suited for another channel, someone will say so.
19:01:44 <dfeuer> kevinkjt2000, it's a good one.
19:01:59 <kevinkjt2000> Sadly, it involves ncurses/terminfo not playing nicely with gcc-5.3.0
19:02:27 <caconym> is there any particular regex package that's generally accepted as the one to use?
19:03:12 <kevinkjt2000> I should also begin by mentioning that I am building and installing to user directories, since I am limited on my school's cluster
19:03:57 <caconym> regex-posix is the first google hit generally but wiki says it is "very slow"
19:04:07 <Bruuuuno> oh so if Event (a -> a) == f b
19:04:16 <Bruuuuno> that means that Event = f
19:04:20 <Bruuuuno> b = (a -> a)
19:04:27 <ski> yes
19:04:31 <Bruuuuno> since we have (a' -> b)
19:04:41 <Bruuuuno> we now have (a' -> a -> a)
19:04:48 <Bruuuuno> -> f a
19:04:56 <ski> (assuming `b' and `f' are really metas, rather than ordinary type variables ("skolems"))
19:05:10 <Bruuuuno> which is -> Event a'
19:05:23 <Bruuuuno> everything make sense now haha thanks a lot!
19:05:34 <ski> note that `f' couldn't be matched to `Event' if `Event' was a type synonym. type synonyms are (at least conceptually) expanded first
19:06:03 <kevinkjt2000> When terminfo is configuring during make, I see "* Missing (or bad) header file: ncurses.h"
19:06:35 <kevinkjt2000> but it is most certainly there and included in C_INCLUDE_PATH
19:06:56 <ski> also note that an equation `F _a = F _b' implying `_a = _b' means mathematically that `F' is an injective type function. all `data' and `newtype's are assumed / considered to be injective by the type system
19:07:18 <ski> (well, in the presence of "roles" (language extension), this may be complicated somewhat. but that's the basic idea)
19:07:34 <kevinkjt2000> I'm going to also ask #ghc as mjrosenb suggested
19:08:41 <ski> consider `newtype F a = MkF Integer'. conceptually `F Int' and `F Char' is represented the same way. if `F' is injective, `F Int' and `F Char' are still considered to be distinct (so if `F _a = F _b', then that must be because `_a = _b', enabling this very useful simplification in type inference)
19:08:51 <ski> Bruuuuno ^
19:08:52 <geekosaur> you might make sure it's not a symlink to a nonexistent file or something
19:09:40 <Bruuuuno> okay nice
19:09:50 <Bruuuuno> thanks again!
19:10:05 <kevinkjt2000> it is indeed not a symlink as I just compiled ncurses from source and installed to a spot in my user directory
19:10:22 <kevinkjt2000> I checked with ls -l just in case
19:10:28 <kevinkjt2000> not a symlink
19:11:11 <kevinkjt2000> well not a symlink to a non-existent is what I meant
19:15:52 <caconym> kevinkjt2000: if the thing that's failing to build is terminfo, have you verified that C_INCLUDE_PATH is the correct environment variable to use for includes?
19:16:18 <caconym> seems that's what it is for GHC, but I've seen other variable names used for most other builds from source I've done
19:16:47 <synergistics> For an endomorphism to be the identity morphism, does it need to map each element of it's domain to itself?
19:16:58 <caconym> e.g I think CFLAGS is the usual one
19:27:16 <koz_> If I wanna map over a list of lists then concat the results, is there a function that I can call rather than manually concatenating the results of map?
19:27:41 <coconut> why is this wrong?
19:27:41 <coconut> dateToday :: IO Day
19:27:41 <coconut> dateToday = getCurrentTime >>= return utctDay
19:28:46 <michp> :t concatMap
19:28:48 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
19:29:08 <michp> > concatMap head [[1,2],[3,4]]
19:29:11 <lambdabot>      No instance for (Show b0)
19:29:11 <lambdabot>        arising from a use of ‘show_M1602294349616450369992’
19:29:11 <lambdabot>      The type variable ‘b0’ is ambiguous
19:29:26 <koz_> michp: Thanks!
19:29:32 <michp> > concatMap head [[1,2],[3,4]] :: [Int]
19:29:33 <lambdabot>      No instance for (Num [Int]) arising from the literal ‘1’
19:29:34 <lambdabot>      In the expression: 1
19:29:34 <lambdabot>      In the expression: [1, 2]
19:29:44 <koz_> I think you meant [[Int]]
19:29:46 <koz_> But I get the idea.
19:30:18 <caconym> coconut: you need to compose the `return utctDay` I think
19:30:24 <michp> well, the result should have been [Int]? it is late, and I'll let you figure it out :)
19:30:36 <caconym> getCurrentTime >>= return . utctDay
19:31:17 <michp> ah right
19:31:26 <michp> > concatMap init [[1,2],[3,4]]
19:31:28 <lambdabot>  [1,3]
19:31:58 <michp> > [[1,2],[3,4]] >>= init
19:31:59 <lambdabot>  [1,3]
19:33:51 <pikajude> is there a fixtures library for haskell?
19:36:32 <kevinkjt2000> caconym: someone in #ghc suggested --with-curses-{includes,libraries} during toplevel configure
19:36:47 <coconut> caconym, thx
19:37:17 <kevinkjt2000> which allowed terminfo to successfully configure, but now I'm trying to identify why multiple definition linking errors are surfacing
19:39:32 <caconym> kevinkjt2000: uh oh, there's even less chance I'll be able to help you with that :(
19:39:41 <caconym> that's how these things go for me, one issue after another
19:40:20 <caconym> i wish you luck
19:40:27 <kevinkjt2000> well what you suggested usually works for most open source builds :)
19:40:35 <kevinkjt2000> thanks for trying to help :)
19:40:49 <ski> coconut : `liftM utctDay getCurrentTime' (or `fmap' instead of `liftM') ?
19:40:58 <kevinkjt2000> and thanks for the good luck; I'm going to need it
19:44:42 <koz_> Could someone suggest ways I can make this code less ugly? http://paste.rel4tion.org/237
19:46:05 <caconym> coconut: yet another way to do it is `utctDay <$> getCurrentTime` which I think is the way I would go if I hadn't been prompted by this question FWIW
19:46:55 * hackagebot frown 0.6 - LALR(k) parser generator  https://hackage.haskell.org/package/frown-0.6 (MatthewFarkasDyck)
19:57:33 <pavonia> koz_: Why do you use an IntMap and not a (Map Category)?
20:05:56 <mniip> >A Stream instance is responsible for maintaining the "position within the stream" in the stream state s. This is trivial unless you are using the monad in a non-trivial way.
20:06:03 <koz_> pavonia: Because the category is used for filtering the table and not generating the map.
20:06:10 <koz_> The map is values -> occurences.
20:11:16 <obadz> Is there a way to create a typesafe hashmap (kind of like Vectors with typesafe bounds checking using type families) ?
20:12:37 <Cale> obadz: perhaps you're looking for something like http://hackage.haskell.org/package/vinyl
20:12:47 <Cale> It doesn't do hashing though
20:13:15 <ThatTreeOverTher> is there a way to turn (a, IO a) into IO (a,a) ?
20:13:28 <Cale> (nor does it even use a binary balanced tree -- it's basically glorified association lists)
20:13:39 <Cale> ThatTreeOverTher: Yes
20:13:46 <Cale> :)
20:14:02 <ThatTreeOverTher> Okay, thanks!
20:14:07 <Cale> f (u,x) = do v <- x; return (u,v)
20:14:09 <obadz> Cale: you know I think that's what I'm looking for
20:14:55 <Cale> ThatTreeOverTher: This is sometimes called 'strength', but I don't know whether it's in a particularly convenient library you can import
20:15:19 <ThatTreeOverTher> is there a reason it has that name?
20:15:40 <obadz> ThatTreeOverTher: we ran out of other names :-)
20:15:46 <mniip> :t sequenceA
20:15:47 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
20:15:57 <mniip> sequenceA can do that
20:16:34 <ThatTreeOverTher> I'm not sure I follow
20:16:54 <mniip> :t sequenceA :: (a, IO a) -> IO (a, a)
20:16:55 <lambdabot> (a, IO a) -> IO (a, a)
20:17:00 <ThatTreeOverTher> oh neat
20:17:03 <Cale> ThatTreeOverTher: I don't know the original etymology, but the definition of a "strong monad" predates the use of monads in programming.
20:17:10 <mniip> t ~ ((,) a), f ~ IO
20:17:14 <Cale> Oh yeah, cute!
20:17:31 <Cale> :t sequenceA :: (a, IO b) -> IO (a, b)
20:17:32 <lambdabot> (a, IO b) -> IO (a, b)
20:17:52 <Cale> ^^ nothing says the types have to be the same either -- this is the actual type of strength
20:17:56 <nitrix> I was going to suggest the same but didn't know the notation for it.
20:18:01 <nitrix> mniip: ~ is specialized?
20:18:08 <mniip> ~ is type equality
20:18:17 <nitrix> Like an isomorphism?
20:18:39 <mniip> no, like actual equality
20:18:39 <lispy> has anyone here used meldable-heap (https://hackage.haskell.org/package/meldable-heap) or a different formally verified priority queue? Thoughts on using it?
20:19:01 <nitrix> mniip: I'll try to remember that. Thanks.
20:19:15 <mniip> :t undefined :: (a ~ Char) => a
20:19:16 <lambdabot> Char
20:19:19 <ThatTreeOverTher> mniip, is there a way I could have found that myself? I hoogled "(a,IO a) -> IO (a,a)"
20:19:24 <mniip> :t undefined :: ([a] ~ m Char) => m a
20:19:25 <ThatTreeOverTher> nothing came up
20:19:25 <lambdabot> [Char]
20:20:00 <mniip> ThatTreeOverTher, probably not if you don't know what traversables are
20:20:06 <Cale> http://home.math.au.dk/kock/SFMM.pdf -- an early reference on tensorial strengths
20:20:22 <saulzar> Ah, so that's what 'strong' means - I see now why the StaticPointers thing could be used for functors which aren't 'strong'
20:20:42 <nitrix> mniip: So, I'd assume that has a kind then?
20:20:45 <nitrix> :k (~)
20:20:47 <lambdabot> k -> k -> Constraint
20:20:50 <nitrix> Oh !
20:21:01 <nitrix> And it gives a constraint. Fancy.
20:21:37 <ThatTreeOverTher> so a Traversable is a Foldable but preserving the shape so you can put edits back in the structure
20:21:42 <ThatTreeOverTher> is that correct?
20:21:56 * hackagebot octane 0.4.0 - A Rocket League replay parser.  https://hackage.haskell.org/package/octane-0.4.0 (fozworth)
20:22:27 <Cale> saulzar: I don't know what StaticPointers is, but typically all our functors are strong in Haskell, because pattern matching lets us write  strength (u,x) = fmap ((,) u) x
20:22:34 <benzrf> ThatTreeOverTher: ehhh, i guess
20:22:35 <jle`> ThatTreeOverTher: that's a nice way to think about it, i think
20:23:03 <jle`> it's more like, the 'traversing' process is aware of the structure so it knows how to traverse it smartly
20:23:07 <nitrix> ThatTreeOverTher: The idea of Traversable is that you can commute functors. Example, list of trees into trees of lists.
20:23:16 <nitrix> afaik.
20:23:19 <mniip> I don't have a better intuitive understanding of traversables other than something you can applicatively map
20:23:23 <saulzar> Cale, Yeah I see that.. is there an example of something which is not 'strong'?
20:23:24 <jle`> for example, sequence :: Map k (IO a) -> IO (Map k a)
20:23:39 <Cale> saulzar: You'd have to pick another monoidal category...
20:23:41 <jle`> ThatTreeOverTher: sequence executes every action contained in a Map, and returns a map of the results
20:23:47 <koz_> OK, I'm trying to use my code to construct a table using this: https://hackage.haskell.org/package/tabular-0.2.2.7/docs/Text-Tabular.html#t:Table . This is what I have, along with associated errors: http://paste.rel4tion.org/238 . I have no clue what I'm missing here.
20:23:50 <nitrix> mniip: What about my definition?
20:24:23 <mniip> they're all the same
20:24:46 <nitrix> Just validating. I don't have better.
20:24:48 <mniip> I could as well say that a monad is a pointed functor that lets us squash 2 layers into one
20:24:56 <mniip> which is valid, but is it helpful?
20:25:05 <ThatTreeOverTher> that's the weirdest part of Haskell, to me; there are a bunch of mathematical devices that serve a wide range of uses
20:25:14 <ThatTreeOverTher> in other langs, every lang feature has one use
20:25:31 <mniip> ThatTreeOverTher, that's the idae
20:25:37 <mniip> make your tools as composable as possible
20:25:42 <koz_> Generality gives immense power that way.
20:25:47 <ThatTreeOverTher> here, features are so generalized, you can't point at it and say "Monads do this" "Traversables do that"
20:25:59 <nitrix> ThatTreeOverTher: There's a small set of devices, and the devices all combines together to make greather things.
20:26:02 <ThatTreeOverTher> it's such a new idea to me
20:26:08 <jle`> it's cool, ain't it :)
20:26:10 <koz_> ThatTreeOverTher: It grows on you fast.
20:26:17 <mniip> "you can't point at it and say "Monads do this" "Traversables do that""
20:26:20 <mniip> you can
20:26:21 <mniip> but
20:26:24 <nitrix> ThatTreeOverTher: Some of these devices can also be implemented with other ones. That's just hwo generic and powerful they inherently are.
20:26:30 <koz_> I love Haskell because very often, I don't have to fight my logical/mathematical training and just write what I came up with.
20:26:33 <ThatTreeOverTher> it wouldn't be a very helpful definition, mniip :)
20:26:38 <mniip> "this" in this case would be too abstract, yes
20:26:41 <mniip> exactly
20:26:46 <Cale> saulzar: Tom Leinster gives a nice example here http://mathoverflow.net/questions/85391/any-example-of-a-non-strong-monad
20:26:55 <saulzar> Cale, StaticPointers is the cloud haskell extension which lets you refer to a global value (a pointer of sorts). Because it's not curried you can know that it doesn't refer to values in the running program
20:27:23 <nitrix> ThatTreeOverTher: It takes a bit to get used to, but once you do, you start hating how the other languages build their library.
20:27:36 <Cale> saulzar: Ah, messing around with things like that seems like it might result in cases where you have something fmap-like, but still can't break apart pairs so easily :)
20:27:55 <mniip> "So one example would be the monad on Cat (considered as a Set-category) whose algebras are cartesian closed categories -- it is known that this is not a Cat-monad (although it does extend to Cat as a groupoid-enriched category)."
20:27:57 <mniip> haha
20:28:00 <mniip> I know some of thosse words
20:28:34 <nitrix> ThatTreeOverTher: Hating might be too harsh, but it's certainly frustrating at times. "If this was a functor or monoid, it'd just magically work with all these other things and I wouldn't have to write this boilerplate.".
20:28:40 <Cale> mniip: Yeah, Finn is talking about monads in a way that we normally don't talk about them in Haskell - in terms of their algebras
20:28:55 <mniip> I still haven't figured out what algebras are :I
20:29:21 <ThatTreeOverTher> in Java, HashMaps have .size() but Strings have .length() while arrays have .length (the field, not the function)
20:29:22 <Cale> mniip: The list monad is "the monad whose algebras are monoids", for example.
20:29:28 <nitrix> I was introduced to monads from a lambda calculus point of view.
20:29:30 <nitrix> I loved it.
20:29:38 <ThatTreeOverTher> nitrix: i'm already perfectly capable of hating other languages haha
20:30:06 <saulzar> Cale, Yeah - it was mentioned in the discussion of FRP and strong Functors but I had no idea why :)
20:30:09 <mniip> Cale, wouldn't a free magma have the same property?
20:30:42 <ThatTreeOverTher> I wanted to write a programming language but I'm slowly realizing that Haskell has everything I wanted in a prog lang
20:30:44 <Cale> mniip: The monad for magmas is more tree-like
20:30:44 <nitrix> ThatTreeOverTher: In Haskell, all of those would just be an instance of Bounded.
20:30:55 <jle`> ThatTreeOverTher: when you use haskell you'll also see where it's lacking, too :)
20:30:55 <nitrix> ThatTreeOverTher: Or Enum, or similar.
20:31:09 <mniip> pretty sure the algebras for the list monad are a bit more specific than just monoids?
20:31:12 <Cale> mniip: (it's exactly the monad of leaf-labelled binary trees)
20:31:19 <Cale> Nope
20:31:27 <Cale> Every monoid is a list monad algebra
20:31:29 <ThatTreeOverTher> jle`, there's always FFI, I guess? Where do you think Haskell could use some improvement?
20:31:30 <Cale> and vice-versa
20:31:33 <koz_> OK, I'm trying to use my code to construct a table using this: https://hackage.haskell.org/package/tabular-0.2.2.7/docs/Text-Tabular.html#t:Table . This is what I have, along with associated errors: http://paste.rel4tion.org/238 . I have no clue what I'm missing here. Halp plz? :)
20:31:43 <jle`> ThatTreeOverTher: Haskell FFI is kind of nice actually, i think
20:32:01 <Cale> Well, let's spell it out and see :)
20:32:07 <jle`> i don't have a list of things on hand, but i do know after a few years of usage that it's not perfect
20:32:12 <jle`> it's just the best we've got for now :)
20:32:16 <nitrix> ThatTreeOverTher: The tooling is the biggest problem for Haskell currently.
20:32:22 <Cale> So a list monad algebra consists of some type A together with an "evaluation map" a: [A] -> A
20:32:31 <nitrix> ThatTreeOverTher: The language is years ahead of its time. I'm not worried about it.
20:32:32 <jle`> oh, are we talking about the language, or the ecosystem?
20:32:34 <Cale> and this has to satisfy some conditions
20:32:40 <jle`> i was talking about the language; the language isn't perfect
20:32:40 <mniip> Cale, hmm, what laws require the algebra to be sane enough to decompose into mempty and mappend?
20:32:57 <ThatTreeOverTher> jle`, I think LuaJIT's FFI is prettier, but yeah Haskell's FFI looks fairly usable
20:33:02 <Cale> basically, our evaluation map is going to be the mconcat of the monoid
20:33:15 <Cale> So we'll have mempty = a []
20:33:21 <Cale> and  mappend x y = a [x,y]
20:33:28 <mniip> ThatTreeOverTher, luajit's ffi is prettier because it is dynamically typed
20:34:23 <mniip> Cale, what lets us say that a [x, y, z] = a [a [x, y], z]
20:34:26 <ThatTreeOverTher> mniip, nah, you paste in C header files to get their functions in your code. Calling something with the wrong types will fail
20:34:32 <Cale> right, so let's look at the laws
20:34:38 <mniip> ThatTreeOverTher, it will fail at runtime
20:34:44 <Cale> https://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
20:34:45 <mniip> there is no compile-time typechecker
20:34:59 <ThatTreeOverTher> mniip, that is true
20:35:02 <Cale> I've been writing a for h and A for x
20:35:28 <mniip> Cale, I think I'm missing the required knowledge to understand that :(
20:35:37 <Cale> I'll translate it :)
20:35:52 <Cale> So the square on the left is saying that we should have a . fmap a = a . join
20:36:09 <Cale> i.e. if we start with some list of lists of monoid elements [[A]]
20:36:19 <Cale> I should say, of type [[A]]
20:36:28 <mniip> ah I see
20:36:39 <Cale> then multiplying together each of the lists, and then multiplying the results
20:36:51 <mniip> a $ fmap a [[x, y], [z]] = a [x, y, z]
20:36:51 <Cale> is the same as concatenating the lists, and then multiplying everything
20:37:02 <Cale> right
20:37:09 <ThatTreeOverTher> oh, so you can flip the monads but the result is the same
20:37:11 <ThatTreeOverTher> whoa
20:37:12 <mniip> and a [z] = z is required by the fact that return . a = id
20:37:19 <Cale> The triangle says that  a . return = id
20:37:32 <Cale> yeah
20:37:39 <mniip> oh right, a . return
20:37:52 <Cale> (you flipped the composition around, but got the right idea there)
20:38:10 <mniip> Cale, I'm still stuck at natural transformations though
20:38:48 <Cale> I might be able to help...
20:38:55 <ThatTreeOverTher> it's times like these where I wish I weren't "allergic" to math
20:39:55 <Cale> ThatTreeOverTher: I'm pretty firmly of the opinion that most people just aren't given an opportunity to learn mathematics properly
20:40:52 <ThatTreeOverTher> Cale, could you elaborate?
20:42:04 <Cale> It's pretty unfortunate, but the way that we teach mathematics in highschools and even to many non-mathematicians at the university level is akin to trying to teach people "music" who have never heard music by making them draw dots with stems.
20:42:46 <rwiggins> In all of my upper-division mathematics courses, everyone (who hadn't already studied the material) seemed to allergic to everything. It's just a field that requires a _lot_ of thinking _and_ practice to absorb. But eventually it all does settle.
20:42:47 <Cale> We strip out all the real content of mathematics -- the proofs -- and reduce everything to uninteresting rote calculations.
20:43:18 <koz_> I agree with Cale.
20:43:22 <Cale> and of course it's hard to appreciate then, because the interesting part which is the whole reason that people do it is missing
20:43:27 <koz_> Like, 100%. This is exactly my sentiment.
20:44:08 <ThatTreeOverTher> Yeah, I think I can agree with that. I'm not good at "crunching numbers" but I do fairly well with induction and logical reasoning
20:44:49 <koz_> ThatTreeOverTher: Crunching numbers no longer needs humans.
20:44:56 <koz_> Our computers can out-crunch us any day of the week.
20:44:58 <ThatTreeOverTher> so when tests are based on how precise your numbers are and how good you are at rote application of select theories, you fail
20:45:18 <koz_> Heck, our *cellphones* can out-crunch us. It just so happens that our education system is chained to the late 19th century when it was established.
20:45:36 <koz_> (in its present form anyway)
20:46:10 <ThatTreeOverTher> so what way do y'all suggest I should try re-learning math
20:46:15 <Cale> Yeah, it's really ridiculous when the one thing which people can take from learning mathematics, no matter where else they decide to go in life, is learning how to apply logic and reason in a precise way.
20:46:36 <Cale> ThatTreeOverTher: One book that I could recommend is "Calculus" by Michael Spivak
20:46:40 <koz_> ThatTreeOverTher: Read 'Proofs and Fundamentals'.
20:46:44 <Cale> It is *not* an average calculus textbook
20:46:45 <koz_> That'd be *my* recommendation.
20:46:52 <Cale> It's simply disguised as one :)
20:47:01 <kadoban> Out of curiosity: does GHC try to figure things out at compile time if it can? Like if I do f :: Integer\nf = sum [1..50] at the top level, does it figure out that that calculation can be done totally statically?
20:47:03 <koz_> Although Cale's suggestion is also good.
20:47:37 <Cale> It's really an introduction to proper mathematics, and the branch of that known as analysis more specifically.
20:47:48 <ThatTreeOverTher> Cale, and after obtaining this textbook, how does one go about applying it? Are there exercises or..?
20:48:29 <Cale> There are exercises -- they range from pretty easy to quite difficult.
20:48:43 <Cale> You probably shouldn't expect to be able to solve all the exercises on your first time through
20:49:00 <Cale> But they're all things which are worth thinking about on their own
20:49:12 <Cale> Rather than things which result in a number that nobody cares about.
20:49:29 <ThatTreeOverTher> That makes a lot of sense.
20:49:50 <ThatTreeOverTher> Will this bolster my Haskell writing ability? (This is just a point of curiousity, I don't expect any magic)
20:49:54 <mniip> 1454387899 [07:38:19] <Cale> I might be able to help...
20:50:57 <mniip> my body is ready
20:51:06 <Cale> ThatTreeOverTher: If so, then probably only in a very indirect way -- unfortunately this is an area which only gets used in special sorts of applications (you might be able to use some of it for certain graphics work for example)
20:51:34 <koz_> It's the *thinking* that it helps foster that will help.
20:51:37 <Cale> yeah
20:51:56 <Cale> It's just a good intro to proper mathematics generally, and then you can maybe go read some stuff whose content is more in-line with what would be useful to programming.
20:52:02 <ThatTreeOverTher> So this will improve my foundations, but it'd just be the first step in my journey- yeah, that exactly
20:52:05 <Cale> yeah
20:52:37 <Cale> mniip: So, have you read the definition of a natural transformation? What part is confusing? :)
20:53:35 <Cale> mniip: Let's just repeat it I guess :)
20:53:41 <Cale> So we have two categories, C and D
20:53:58 <Cale> and we have two parallel functors, F and G both functors C -> D
20:54:31 <Cale> and we're going to define a natural transformation eta: F -> G
20:55:23 <Cale> In this, it may help to think of the functors F and G in terms of their images in D -- it's kind of like F and G each pick out some part of D which looks like a (possibly very squished) copy of C
20:55:48 <mniip> they don't have to be endofunctors though do they
20:55:57 <Cale> nope, in this description they are not
20:56:04 <Cale> C and D needn't be the same category
20:56:20 <glguy> kadoban: It doesn't generally compute recursive functions at compile time
20:57:12 <Cale> mniip: It may even help to think the definition through while picking C to be some category with a small finite number of objects
20:57:22 <ThatTreeOverTher> is using backticks over flip advisable?
20:57:29 <ThatTreeOverTher> hlint seems to think so
20:57:42 <Cale> ThatTreeOverTher: I think usually... that or just using a lambda
20:57:49 <Cale> flip is okay sometimes...
20:57:57 <kadoban> glguy: Should that be taken to mean it'll compute non-recursive functions at compile time?
20:57:58 <ThatTreeOverTher> hlint disliked my use of a lambda
20:58:13 <Cale> Take the stuff that hlint says with a grain of salt
20:58:33 <Cale> It's just offering suggestions, you're free not to like them :)
20:58:52 <mniip> Cale, ok so what happens next
20:59:39 <Cale> mniip: Okay, so our natural transformation eta: F -> G will consist of a family of arrows in D, connecting up the corresponding objects in the images of objects in C
20:59:45 <kadoban> glguy: Also, are you referring to 'sum' as the recursive function?
21:00:05 <Cale> That is, for each X in C, we have some arrow eta_X: FX -> GX in D
21:00:09 <mniip> mhm
21:00:43 <glguy> kadoban: Yeah, sum was the recursive function (either directly or indirectly)
21:01:03 <Cale> So geometrically, we're sort of connecting up the corresponding points in these two "sketch drawings" of C which are sitting in D.
21:01:08 <glguy> kadoban: It doesn't precompute *all* non-recursive function applications, but it can do a lot
21:01:21 <Cale> mniip: But now what about the arrows of C?
21:01:32 <kadoban> Ah okay, so there's at least an attempt made? That's good.
21:02:13 <Cale> mniip: So for each arrow a: X -> Y in C, we have these arrows Fa: FX -> FY and Ga: GX -> GY sitting in D, and we want to say somehow that our natural transformation is relating one to the other.
21:02:49 <Cale> mniip: So we insist that the square formed by those arrows and  eta_X: FX -> GX and  eta_Y: FY -> GY is a commuting square
21:02:50 <mniip> so we say that eta_Y . Fa = Ga . eta_X
21:02:51 <mniip> ?
21:02:54 <Cale> right
21:03:05 <codebje> @pl \a b -> fst a == fst b
21:03:05 <lambdabot> (. fst) . (==) . fst
21:03:16 <mniip> codebje, (==) `on` fst
21:03:48 <codebje> ahha, thanks, I knew there was something like that
21:03:55 <codebje> but, obviously, not _what_
21:04:07 <mniip> :t Data.Function.on
21:04:08 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:04:27 <mniip> Cale, ok, how does this relate to haskell
21:04:31 <Cale> mniip: If you imagine that commuting squares are a bit like 2D "sheets" through which you can deform the arrows on one side to the arrows on the other, the natural transformation is sweeping out those arrows in the images of C into 2D sheets connecting the two drawings
21:04:45 <mniip> huh
21:05:15 <Cale> mniip: Okay, so in Haskell, we might have (endo)functors f and g
21:05:22 <mniip> hold on hold on
21:05:25 <Cale> oh, okay
21:05:29 <mniip> I don't understand the sheet thing at all
21:05:50 <Cale> ah, it's not terribly important if you get the equation way of looking at it
21:06:12 <Cale> It's sort of a vague intuition anyway
21:06:41 <Cale> But if we're thinking of objects in our categories as 0-dimensional "points"
21:06:52 <Cale> and arrows as 1-dimensional "lines" or "curves"
21:07:17 <mniip> righto
21:08:18 <Cale> Then each object (point) X in C, corresponds to two points FX and GX in D and our natural transformation is sort of "sweeping out" a connection between those
21:08:31 <Cale> we have eta_X: FX -> GX sitting between those two points
21:09:12 * gfixler eavesdrops in on natural transformation discussion, already in progress...
21:09:21 <Cale> You can imagine that our goal is to be able to smoothly deform F's picture of C into G's picture of C
21:09:47 <Cale> and so the components eta_X are providing the paths that the objects travel along
21:10:01 <Cale> and then we need to do something about the arrows
21:10:24 <Cale> If we sweep out a line, we get a 2D surface
21:10:45 <mniip> that's a weird analogy
21:10:46 <Cale> and if we think of commuting squares as being like 2D surfaces, then we have the right idea for the definition
21:11:09 <Cale> There's a way to make it even more like the definition of a homotopy in topology
21:11:20 <Cale> I don't know if you'd be familiar with that
21:11:40 <mniip> also TIL what commutative diagrams actually are
21:12:04 <codebje> having also now eavesdropped on this, the second dimension in D works better for me if I think of it as a time-like dimension
21:12:14 <Cale> yeah, that may help
21:12:21 <codebje> making the 2D surface a line morphing over time
21:12:24 <Cale> yep
21:12:44 <Cale> So we're sort of "animating" the image of C under F into the image of C under G
21:13:10 <Cale> (of course, it's not for realsies, because there are not actually intermediate points to go to)
21:13:16 <mniip> ah so like if we had a family of functors, that slowly morph into one another
21:13:16 * gfixler likes both descriptions - very wibbly wobbly
21:13:27 <mniip> and F and G were specific functors from that family?
21:13:44 <Cale> But okay, let's look at the definition of a homotopy between continuous functions in topology :)
21:13:46 <mniip> hmm I think I'm getting away from the analogy
21:13:54 <mniip> what
21:13:55 <mniip> no
21:13:57 <Cale> (don't worry *too* much if you don't know what topological spaces are)
21:14:09 <mniip> I don't know any of those words D:
21:14:23 <Cale> Do you know what a continuous function is?
21:14:41 <Cale> (even from the real numbers to the real numbers)
21:14:59 <mniip> yeah that's the only one I know
21:15:03 <ski> (i think you can probably describe a natural transformation `eta : F >---> G' instead by how it transforms any arrow `a : X >---> Y' into an arrow `eta_a : F X >---> G Y'. you'd recover the `eta_X : F X >---> G X' in the original formulation as `eta_{id_X}'. but you'd need some kind of conditions re `eta_a' of some sort, possibly)
21:15:57 <mniip> ski, that seems interesting
21:15:59 <ski> (if this works, the nice thing would be that it takes arrows to arrows, rather than objects to arrows)
21:16:50 <ski> (in terms of the original formulation, `eta_a' is just the diagonal in the square, `eta_Y . F a', which is also `G a . eta_X')
21:17:02 <mniip> yeah I can see that yes
21:17:33 <mniip> ok now wrt haskell,
21:17:47 <mniip> I've seen natural transformations being defined as forall a. f a -> g a
21:18:07 <mniip> is there anything that requires the definition to be uniform across all objects?
21:18:12 * ski . o O ( `readIORef_NT :: (a -> b) -> IORef a -> IO b' )
21:18:31 <Cale> mniip: Right, well, that gives all the components of the natural transformation, clearly, right?
21:18:41 <ski> mniip : parametricity. aka "theorems for free" (search for wadler paper)
21:18:50 <Cale> mniip: So if we have  eta :: forall a. F a -> G a
21:19:12 <mniip> ski, more specifically?
21:19:18 <Cale> mniip: Then we don't even have to write  eta_X
21:19:31 <Cale> Haskell will automatically supply the type parameter when we go to use it
21:19:40 <Cale> mniip: But now for the commuting squares
21:19:49 <Cale> we need to know that  fmap f . eta = eta . fmap f
21:19:58 <Cale> (nicely implicit, huh?)
21:20:05 <mniip> haha
21:20:10 <mniip> uh
21:20:14 <ski> mniip : <https://en.wikipedia.org/wiki/Parametricity>
21:20:15 <mniip> can we pause for a second
21:20:18 <Cale> sure
21:20:25 <mniip> I still don't see what requires eta to be uniform
21:20:43 <Cale> mniip: Well, what do we mean by uniform?
21:21:19 <mniip> well, it is universally quantified
21:21:22 <mniip> it is required to have the same definition for any object a
21:21:22 <Cale> mniip: In order to be a natural transformation, the only sort of uniformness we require is that for every function f :: X -> Y, we need that fmap f . eta = eta . fmap f
21:22:36 <Cale> Polymorphism sort of ensures this -- intuitively, fmap f will only apply f to the values of type X throughout the structure
21:22:54 <ski> for a natural transformation `eta', it doesn't matter if we apply `eta_X : F X >---> G X' first, and then "map over the elements" by `G a : G X >---> G Y' (using the "element"-mapping `a : X >---> Y'), or start by mapping via `F a : F X >---> F Y', and only then apply the natural transformation `eta_Y : F Y >---> G Y' (this time at "element" type `Y')
21:22:59 <Cale> while eta can't touch those parts because it's polymorphic and doesn't even know what type they have
21:23:17 <codebje> all haskell polymorphic functions are universally quantified, it's implicit
21:23:19 <mniip> Cale, my exact question
21:23:23 <mniip> why can't it touch those parts
21:23:26 <codebje> something like: class Natural a where { eta :: (Functor f, Functor g) => f a -> g a }
21:23:29 <codebje> ?
21:23:44 <Cale> mniip: Well, there's not much you can do with a value whose type you don't know
21:23:56 <mniip> ok, let's go back a bit
21:24:10 <mniip> I asked why can't it know the types of the values
21:24:17 <mniip> this reasoning seems a bit circular
21:24:21 <ski> to the extent that `F a' means "convert elements via `a', preserving other structure", then this ensures that you can't tell any difference between applying the NT `eta' at one "element" type `X', and at another one, at least as long as there's any morphism from `X' to `Y'
21:24:23 <Cale> codebje: It would be  class Natural f g where ...
21:24:47 <Cale> codebje: class (Functor f, Functor g) => Natural f g where eta :: forall a. f a -> g a
21:24:51 <codebje> cale, right, because you need knowledge of both functors to convert them
21:24:55 <codebje> to map between them
21:25:13 <Cale> codebje: But in general, there will be many natural transformations between any pair of functors, so it turns out not to be so useful to single one out with a type class
21:25:31 <Cale> It would be more useful to make a data type for this
21:26:10 <Cale> newtype Natural f g = NT (forall a. f a -> g a)
21:26:39 <ski> (e.g. both `X' and `Y' could be some (single) finite type, or perhaps the type of naturals or integers, and `a' could be a permutation over that type. then it seems `eta_X' can't depend on the actual values of the "element" type, since we can "rename" them via `a', and we still get the same answer, regardless of the order in which we do these things)
21:26:54 <Cale> mniip: Because it's polymorphic
21:26:57 <ski> mniip : i realize this is still a bit handwavy
21:27:01 <mniip> Cale, hmm, consider eta (Identity x) = Just x :: Identity a -> Maybe a
21:27:07 <mniip> that makes an NT, right?
21:27:10 <ski> yes
21:27:14 <Cale> yep
21:27:20 <mniip> my question is, what would break if I said
21:27:37 <mniip> eta (Identity x) = if typeOf x == typeOf () then Nothing else Just x
21:27:43 <Cale> typeOf doesn't exist
21:27:52 <mniip> circular reasoning
21:27:56 <Cale> huh?
21:28:01 <Cale> What's typeOf?
21:28:16 <mniip> well
21:28:20 <Cale> I'm saying, there is no such function in Haskell
21:28:23 <mniip> eta :: Typeable a => Identity a -> Maybe a
21:28:25 <ski> Cale : the "polymorphic operations" are exactly those that have a "universal type", yes
21:28:55 <Cale> mniip: Yeah, if you restrict the variable by a type class, that's not the same
21:28:58 <ski> mniip : languages with something like `typecase' typically do not enjoy parametricity. e.g. Java,Mercury
21:29:15 <mniip> so like I said
21:29:16 <Cale> mniip: and so you would need to actually check the laws by hand
21:29:43 <Cale> mniip: You'd need to provide additionally some proof that for every function f, you had fmap f . eta = eta . fmap f if you want to use typecase
21:29:48 <ski> mniip : therefore, operations with (the equivalent of) the type `forall a. F a -> G a' needn't be natural transformations in the intended sense, there
21:30:11 <codebje> > newtype Natural f g = NT (forall a. f a -> g a)
21:30:12 <mniip> do you understand what I'm asking though
21:30:13 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
21:30:17 <codebje> nuts.
21:30:19 <Cale> But polymorphic functions *in Haskell* are automatically natural transformations, because typecase doesn't exist.
21:30:22 <ski> @let newtype Natural f g = NT (forall a. f a -> g a)
21:30:24 <Cale> So we get theorems for free
21:30:24 <lambdabot>  Defined.
21:30:32 <codebje> :t NT $ Just . runIdentity
21:30:33 <lambdabot> L.Natural Identity Maybe
21:30:43 <mniip> Cale, but there definitely are natural transformations that aren't univerally quantified
21:30:49 <mniip> are there
21:31:07 <mniip> my question goes in the opposite direction
21:31:09 <Cale> mniip: Maybe, but none that we particularly care about
21:31:32 <mniip> not whether all universally quantified functions are NTs, but instead whether are all NTs universally quantified
21:31:38 * ski str "Categories for the Working Mathematician" expressing natural transformations as ends ..
21:31:39 <Cale> We tend to be able to arrange that natural transformations are honest polymorphic functions
21:33:02 <Cale> mniip: Actually, there might not even be any others... I seem to recall Ed Kmett saying that he'd proved that there aren't, but I don't know the proof myself.
21:33:16 <ski> mniip : at least to an initial approximation, category theory is first-order, not higher order. there is no `forall' (or maybe ends is it ?), and thus no `forall a. F a >---> G a' in CT
21:33:44 <Cale> mniip: It's certainly a tall order producing something which satisfies all of those equations simultaneously and yet isn't honestly polymorphic.
21:34:00 <Cale> mniip: It has to interact nicely with *every* function.
21:34:01 <codebje> intuitively, there can't be natural transformations which don't transform the entire functor
21:34:14 <codebje> else they wouldn't be an arrow in the category of functors
21:34:29 <Cale> codebje: Well, no, it's not that which we're talking about
21:35:03 <Cale> codebje: mniip I think is getting at the fact that when we specify a natural transformation according to the mathematical definition, we're allowed to define each eta_X component separately
21:35:12 <ski> Cale : well, perhaps something similar can be done to stuff like a monoid homomorphism being epi but not surjective (or mono but not injective ?)
21:35:16 <Cale> (even though that never really happens in practice)
21:35:31 <mniip> well, you know, after realising that functors are something bigger than Data.Functor.Functor
21:35:32 <Cale> (even in other categories)
21:35:41 <mniip> I take haskell aproximations of CT with a grain of salt
21:35:45 <ski> ("similar" is probably stretching it. "something along that vein" ?)
21:35:47 <Cale> mniip: For sure
21:35:52 <Cale> mniip: and you should!
21:35:54 <codebje> in the same way that we can define functors as separate mappings of each object and arrow, right?
21:35:57 <mniip> hence my question about the relation between NTs and their haskell representations
21:36:14 <Cale> codebje: yes
21:36:43 <exio4> Cale: isn't this "all nice" until we throw GADTs, Type Families, etc to the language?
21:37:13 <codebje> aiui, a functor must nevertheless be total on its domain, right?
21:37:17 <mniip> exio4, some CT things start breaking down even without any of those
21:37:26 <Cale> exio4: Yeah, GADTs give you perhaps some additional functors...
21:37:51 <exio4> mniip: which things?
21:38:11 <mniip> exio4, recursive datatypes
21:38:13 <Cale> seq screws up a bunch of stuff, but that's on seq
21:38:36 <mniip> and I mean recursion that is more complex than Data x = ... (Data x) ...
21:38:36 <exio4> mniip: what about recursive datatypes?
21:38:37 <codebje> it's all fun and games until something evaluates to bottom
21:39:56 <mniip> exio4, how do you cps-transform data Data a = Pure a | Double (Data (a, a))
21:40:45 <mniip> Cale, anyway, hm
21:40:51 <mniip> is there more to natural transformations?
21:41:54 <Cale> mniip: Yes and no? You have the whole definition... there are consequences of that definition and many examples, and structures which can be built from them
21:42:08 <mniip> what about the applicative thing
21:42:47 <shachaf> I like the version of natural transformations where components are for arrows, not objects.
21:42:55 <shachaf> (The component gives you the diagonal.)
21:43:03 <Cale> Let's leave Applicative for some other time... if you want me to explain monoidal categories and monoidal functors, it'll keep me up too late and I won't be able to wake up to catch the train to my flight the morning after next :)
21:43:15 <shachaf> (Maybe diagonal is a bad name here.)
21:43:26 <mniip> oh yeah that
21:43:29 <exio4> mniip: you mean the (typeful version of) church encoding of that datatype?
21:43:31 <Cale> mniip: But yeah, if you look at the mathematical definition of a monad
21:43:43 <Cale> mniip: You'll see that it consists of an endofunctor T: C -> C
21:43:57 <Cale> and two natural transformations:  eta: 1 -> T, and  mu: T^2 -> T
21:44:04 <Cale> (satisfying some laws)
21:44:10 <mniip> shachaf, with that definition, we have
21:44:11 <Cale> eta we usually call "return"
21:44:19 <Cale> :t return
21:44:20 <lambdabot> Monad m => a -> m a
21:44:33 <mniip> forall a b. (a -> b) -> f a -> g b
21:44:34 <Cale> while mu, we usually call "join"
21:44:34 <mniip> right?
21:44:38 <Cale> :t join
21:44:39 <lambdabot> Monad m => m (m a) -> m a
21:45:23 <mniip> oh yes, that thing
21:45:34 <mniip> where return is actually Identity a -> m a
21:46:29 <mniip> Cale, hold on, just to check my understanding,
21:46:37 <mniip> reverse is an endo-NT on lists?
21:46:45 <Cale> yeah
21:47:05 <Cale> and, say,  inorder :: Tree a -> [a]  is a natural transformation Tree -> []
21:47:16 <mniip> :t toList
21:47:18 <lambdabot>     Ambiguous occurrence ‘toList’
21:47:18 <lambdabot>     It could refer to either ‘Data.Foldable.toList’,
21:47:18 <lambdabot>                              imported from ‘Data.Foldable’ at /home/lambda/.lambdabot/State/L.hs:87:1-20
21:47:23 <mniip> :t Data.Foldable.toList
21:47:24 <Cale> fun
21:47:24 <lambdabot> Foldable t => t a -> [a]
21:47:25 <mniip> :p
21:47:33 <Cale> You can also define a natural transformation in another way
21:48:04 <Cale> as a functor  H: C x I -> Y, where I is the category with two objects 0 and 1, and a single non-identity arrow 0 -> 1
21:48:18 <Cale> oops
21:48:23 <Cale> as a functor  H: C x I -> D
21:48:29 <mniip> what's x
21:48:36 <Cale> product of categories
21:48:40 <mniip> how's that work
21:49:19 <Cale> If C and D are categories, then the objects of C x D are pairs (X,Y) with X an object of C and Y an object of D
21:49:43 <Cale> and the arrows (X,Y) -> (X',Y') are pairs of arrows (f,g) with f: X -> X' and g: Y -> Y'
21:49:43 <mniip> so a cartesian product
21:49:46 <Cale> yep
21:49:48 <Cale> pretty much
21:50:34 <mniip> hmm and (f1 . f2, g1 . g2) = (f1, g1) . (f2, g2)
21:51:03 <adas> is there a way to let stack pass ghci options to ghci when I do "stack ghci"?
21:51:24 <codebje>   --ghc-options OPTION     Additional options passed to GHCi
21:51:31 <Cale> mniip: that's right
21:51:36 <Cale> mniip: everything componentwise :)
21:51:44 <codebje> (or, probably, stack gchi -- <options here>)
21:53:17 <Cale> mniip: So now, we can look at FX = H(X,0) and for arrows a: X -> Y, we'll take Fa = H(a,id_0), and we get a functor F in this way
21:53:31 <adas> thanks will look into it
21:53:36 <Cale> similarly we can take GX = H(X,1) and Ga = H(a,id_1)
21:53:46 <Cale> F and G both C -> D
21:54:28 <Cale> but now what happens to that additional unique arrow 0 -> 1 in I? Let's give that arrow a name, say !
21:56:08 <codebje> I'm gonna go with 'eta'
21:56:11 <Cale> So, because this H is a functor, for each object X in C, we can look at where H(id_X, !) gets sent in D.
21:56:25 <mniip> Fa = H(a,id_0)
21:56:27 <mniip> you mean
21:56:32 <mniip> H((a, id_0))
21:56:33 <Cale> It'll be some arrow H(X,0) -> H(X,1)
21:56:38 <Cale> i.e. some arrow FX -> GX
21:57:22 <Cale> This, we can take to be our eta_X
21:58:42 <Cale> and then we'll also have for any arrow a: X -> Y in C, some arrow H(a,!): H(X,0) -> H(Y,1), i.e. FX -> GY
21:58:53 <Cale> this will be the diagonal of the square which is supposed to commute
21:59:59 <Cale> So, let's actually check the square...
22:00:24 <Cale> We want that  eta_Y . Fa = Ga . eta_X
22:01:20 <Cale> i.e.  H(id_Y, !) . H(a, id_0) = H(a, id_1) . H(id_X, !)
22:01:22 <mniip> that makes sense
22:01:34 <mniip> but I guess I've spent too much time trying to figure out a haskell analogy
22:01:39 <Cale> but by functoriality, this is
22:02:01 <Cale> well, let's just look at the left hand side to start
22:02:10 <Cale> H(id_Y, !) . H(a, id_0) = H((id_Y, !) . (a, id_0))
22:02:32 <Cale> = H((id_Y . a), (! . id_0))
22:02:43 <Cale> = H(a, !) -- there's our diagonal
22:03:04 <Cale> and we can do the same on the other side, and the identities cancel to give us the same thing
22:03:21 <Cale> So the naturality square indeed will commute
22:03:41 <oldmanmike> well what do you know, cereal will actually work after all. 
22:04:03 <Cale> mniip: cool?
22:04:12 <mniip> sure is
22:04:15 <mniip> but wait
22:04:32 <mniip> we can compose natural transformations right?
22:04:38 <Cale> oh, indeed
22:04:43 <Cale> and not just in one way, but two!
22:05:37 <mniip> and every functor has an identity transformation
22:05:46 <Cale> If we have functors F, G, H and natural transformations alpha: F -> G, and beta: G -> H, then there's a composite beta . alpha : F -> H
22:05:46 <mniip> which means
22:06:15 <mniip> every pair of categories gives rise to a category of NTs on those categories' functors
22:06:16 <mniip> :o
22:06:24 <Cale> yes
22:06:33 <Cale> This is typically written [C,D]
22:07:55 <Cale> [C,C] is the category of endofunctors you might have heard about from the "a monad is just a monoid object in the monoidal category of endofunctors on C" bit.
22:08:26 <Cale> (but we need to equip it with some additional structure before we can say what we mean that it's a *monoidal* category)
22:11:06 <mniip> Cale, hmm, I see that in CT monads are more fundamental entities than applicative functors
22:11:25 <mniip> even though that is not the case with haskell's endo-algebraic-datatype-functors?
22:11:28 <Cale> mniip: Yeah, they show up a little more easily...
22:12:33 <Cale> I dunno, I still think of Applicative as a more fancy class than Functor and Monad
22:12:42 <Cale> But maybe that's just because I was around before Applicative
22:12:48 <mniip> >_>
22:13:22 <mniip> I like how applicative has 2 absolutely unrelated definitions
22:13:27 <mniip> or at least they seem unrelated
22:13:48 <Cale> You mean the one which uses liftA2 (,) instead of (<*>) ?
22:13:58 <mniip> liftA2 (,) and pure ()
22:14:01 <Cale> yeah
22:14:22 <Cale> It's not hard to spell out what the relationship is
22:14:49 <Cale> but yeah, they might seem unrelated until you try to get one from the other
22:15:44 <mniip> pure x = fmap (const x) unit; a <*> b = fmap (uncurry id) $ a ** b
22:15:45 <ski> mniip,exio4 : `data Data a = Pure a | Double (Data (a, a))', `Data T' can be coded as `forall o. (forall a. a -> o a) -> (forall a. o (a,a) -> o a) -> o T'
22:15:48 <ski> mniip : "forall a b. (a -> b) -> f a -> g b" -- yes
22:16:05 <Cale> mniip: yeah
22:16:18 * ski . o O ( `pure = liftA0' )
22:16:29 <mniip> fmap = liftA1 yeah
22:16:40 <mniip> I think we had this discussion before :p
22:16:55 <Cale> mniip: So, yeah, this H approach to describing natural transformations is sometimes referred to as "homotopy of functors", and is very much analogous to the definition of a homotopy between continuous functions in topology
22:17:11 * ski . o O ( modal logic, `[] (A -> B) -> [] A -> [] B' )
22:17:30 <Cale> mniip: Where you define a homotopy as being a continuous function X x I -> Y, but where I is now the unit interval [0,1] in the real numbers. :)
22:18:02 <ski> (the category `I' is an "abstract interval")
22:18:16 <codebje> cale, in far less abstract terms, we might call that lerp() ?
22:18:22 <Cale> mniip: and you typically think of such a function as being like an animation, i.e. that second parameter is "time" and you're continuously deforming from one picture of X sitting in Y (at time 0) to another (at time 1).
22:18:32 <mniip> oh also
22:18:42 <Cale> codebje: Well, it needn't be *linear* interpolation, but it is a sort of interpolation, sure.
22:18:43 <ski> mniip : that CPS-encoding making sense ?
22:18:48 <mniip> ski, not really no
22:19:19 <exio4> w
22:20:11 <mniip> also, recently I started noticing a common pattern among things that are called 'free', but it doesn't seem to be a formal term or definition, or something?
22:20:13 <exio4> ski: what's the name of that encoding? I am not familiar with it
22:20:15 <ski> mniip : consider
22:20:22 <ski>   foldData :: forall o. (forall a. a -> o a) -> (forall a. o (a,a) -> o a) -> (forall a. Data a -> o a)
22:20:25 <ski>   foldData pure double (Pure a)  = pure a
22:20:26 <ski>   foldData pure double (Double t) = double (foldData pure double t)
22:20:36 <codebje> it's a church encoding, yes?
22:20:55 <codebje> mniip, 'free' is formally defined
22:20:59 <codebje> but I don't understand the definition
22:21:00 <Cale> mniip: free = left adjoint to something
22:21:02 <ski> then partially apply this. setting the last `forall'ed `a' to `T', and passing the `Data T' input, and you get the CPS type above
22:21:14 <mniip> oh god, adjunctions
22:21:31 <Cale> mniip: For that, you'll need to understand the definition of an adjunction, which you're in a position to understand now that you sort of understand natural transformations :)
22:21:38 <ski> exio4,codebje : it's "basically" a church encoding, yes. not sure if it has a specific name. iirc, i saw the idea in some paper
22:22:05 <Cale> mniip: btw, TheCatsters on youtube have wonderful coverage of this stuff
22:22:29 <Cale> http://www.simonwillerton.staff.shef.ac.uk/TheCatsters/
22:23:03 <ski> the idea with `data Tree a = Leaf a | Branch (Tree a) (Tree a)' is that you can think of `Tree' as either being `\a. mu t. a + t * t', or as `mu t. \a. a + t a * t a' (in the former case, `t' has kind `*'; in the latter case, `t' has kind `* -> *')
22:23:29 <mniip> ohh
22:23:35 <mniip> that kinda makes sense yes
22:23:54 <ski> with `data Data a = Pure a | Double (Data (a,a))', `\a. mu d. ..a..d..' doesn't work, but `mu d. \a. a + d (a * a)' still works
22:25:06 <exio4> ski: I see, thanks
22:26:35 <ski> the situation is similar to polymorphic recursion
22:26:49 <Cale> Speaking of the Catsters, Eugenia Cheng is apparently giving the keynote at Compose Conference! :)
22:27:54 <ski> with ordinary (monomorphic) recursion for a polymorphic operation `poly :: forall a. ..a..', you can think of the definition as either `poly = /\a. mu p. ..p..' (`p' being monomorphic, of type `..a..'), or as `poly = mu p. /\ a. ..(p a)..' (`p' being polymorphic in this case)
22:28:40 <mniip> Cale, sorry if I'm being a help vampire, but what about adjunctions :o
22:28:56 * ski . o O ( "adjunctions are everywhere" )
22:29:09 <mniip> I remember edwardk claiming quite the opposite
22:29:26 <mniip> something along the lines of Hask only having one boring adjunction
22:29:52 <Cale> mniip: Well, start by watching the Catsters videos on adjunctions... http://www.simonwillerton.staff.shef.ac.uk/TheCatsters/ --> https://www.youtube.com/watch?v=loOJxIOmShE
22:30:20 <mniip> mhm
22:30:24 * mniip bookmarks
22:32:42 <acertain> so, I want a data structure that is `type SparseList = [Maybe a]` that has efficient index, cons, and `length . filter isJust . take n`, and had decent sharing after cons, ideas?
22:34:38 <acertain> I suppose a fingertree where measure is (length, #justs) would work?
22:34:45 <kadoban> acertain: Sounds like an order statistic tree?
22:35:27 <ReinH> Cale: oh really
22:35:38 <Cale> ReinH: hm?
22:35:53 <ReinH> Cale: Eugenia Cheng at compose conf
22:36:01 <Cale> ReinH: Yes!
22:36:05 <ReinH> unfortinately that's literally this week and I hadn't planned on going :/
22:36:27 <ReinH> I hope they'll record video
22:36:31 <ReinH> Cale: are you going?
22:36:36 <Cale> yes
22:36:43 <codebje> it's half a world away for me, I hope there'll be video
22:36:57 <ReinH> Cale: double drat
22:37:14 <ReinH> Cale: going to anything else? Lambdajam? Etc?
22:37:18 <kadoban> acertain: If you have an order statistic tree, I think you'd augment it by storing a "next item to insert is keyed by:" number and decrement it each time you insert, that seems to work?
22:37:28 <Cale> ReinH: It was a lot of fun trying to get my passport when I didn't have any valid photo ID
22:37:33 <ReinH> o_O
22:37:39 <ReinH> I imagine it would be
22:37:49 <ReinH> but now that you have it you may as well use it
22:38:29 <Cale> also, my birth certificate disappeared, and I had to apply for *that*, and it turned up the day after I'd used my new one to apply for the passport 
22:38:35 <ReinH> huh
22:38:38 <ReinH> that's annoying
22:39:24 <acertain> kadoban, huh?
22:39:30 <mrguser> he6
22:39:34 <kadoban> acertain: huh on which part?
22:39:57 <mrguser> Hey sup
22:40:17 <acertain> kadoban, how does it give you efficient cons? (which needs to adjust indexes (+1))
22:40:44 <acertain> oh nope, that's easy, nvm
22:40:54 <kadoban> acertain: cons is just insertion into a BST (and a decrement of the "next index" thing
22:41:00 <kadoban> It's possible I missed something else though.
22:41:02 <mrguser> Whats tht channel about
22:41:10 <acertain> but uh, how does it help with counting Justs?
22:41:32 <ski> mrguser : the Haskell programming language
22:41:35 <Cale> ReinH: Especially annoying when the web form for applying for one is probably the worst web form I've ever used. It was split onto many pages, broke the browser navigation controls, and if you stopped making progress for 30 minutes, everything would be deleted and you'd have to start over (which is fun when you have to call someone up halfway through to ask if it's okay to put them in as your guarantor). Then you get t
22:41:35 <Cale> o the end and the debit payment option only works with the old non-Visa-style debit cards, and the visa option is broken in Chrome and only works with non-debit Visa credit cards.
22:42:10 <Cale> Additionally, the "Help", "Contact Us" and "FAQ" links were all broken in different ways
22:42:19 <Cale> One of them was a redirect loop
22:42:24 <Cale> one of them was a 404
22:42:58 <kadoban> acertain: The number of "Just"s in the first 'n' elements of the "list" is the rank of "next-index-to-insert" + n … that's probably off by one, but something like that.
22:43:00 <Cale> and I think the last was just a different 404
22:43:15 <Cale> or it took you to the front page of something, right...
22:43:41 <ReinH> Cale: fun
22:44:17 <Cale> https://www.youtube.com/watch?v=gEyFH-a-XoQ -- perfect summary of what applying for government ID in Canada is like
22:44:18 <acertain> kadoban, how do you do index?
22:45:30 <kadoban> acertain: Index is just lookup in the BST (again relative to "next-key-to-use" or whatever I'm calling it this sentence)
22:45:50 <mniip> on an absolutely unrelated note
22:45:58 <mniip> what does ParsecT do as a transformer?
22:46:08 <kadoban> I could probably code up a really basic example if it helps, it sounds kind of interesting.
22:46:54 <Cale> mniip: I don't think I've ever used it as one, but I would imagine that it's perfectly analogous to StateT String
22:47:08 <acertain> yeah, that makes sense
22:47:10 <Cale> er StateT String []
22:47:22 <mniip> that's a monad
22:47:41 <Cale> You're right
22:47:46 <mniip> I mean,
22:47:57 <ReinH> hah
22:48:10 <mniip> if we look at 'ParsecT _ IO'
22:48:14 <mniip> no wait
22:48:15 <Cale> StateT String . ListT  I guess
22:48:18 <mniip> 'ParsecT _ _ IO'
22:48:35 <mniip> how do the IO actions relate to the combinators that we use, etc
22:48:51 <Cale> mniip: Well, you'll be able to execute IO actions in the midst of parsing
22:48:59 <mniip> Cale, yeah there's the problem. ListT is not a lawful transformer
22:49:02 <kadoban> mniip: That would presumably mean you can use IO actions to decide parsing results (or have arbitrary side-effects while doing so)
22:49:25 <Cale> mniip: The ListT in mtl is not a lawful transformer
22:49:36 <Cale> But there are implementations of ListT which are
22:49:42 <mniip> is there a different one that is?
22:50:15 <Cale> pipes provides one
22:50:21 <liste> https://hackage.haskell.org/package/pipes-4.1.8/docs/Pipes.html#t:ListT
22:50:26 <Cale> There's also LogicT in the logict package
22:50:58 <Cale> To be fair, I don't know if ParsecT is actually law-abiding or not, and it's quite possible that it's not./
22:51:16 <Cale> I don't know if anyone's checked, and that sort of thing is easy to screw up.
22:51:28 <codebje> ParsecT _ _ Reader might be interesting
22:51:54 <kadoban> What's it mean to be lawful or not? That the result of transforming any Monad is also a lawful Monad essentially, or is there more to it?
22:52:38 <Cale> kadoban: Yeah, that and that lift is a monad homomorphism.
22:52:38 <mniip> Cale, well, I'm trying to add the transformer-ness into my parser monad and it doesn't really seem to stick
22:52:56 <Cale> mniip: ah I see
22:53:24 <kadoban> Ahh, right.
22:54:06 <mniip> I either end up having to use a Traversable backtracking monad, or ListT (the broken one)
22:58:35 <mniip> although if ParsecT isn't actually lawful, and the monad part is only used for fancy Stream operations, I can live with that
22:59:35 <mniip> after all, you can always tear down the Free monad by hands
22:59:45 <mniip> hand(
22:59:47 <mniip> *
23:00:15 <mniip> Cale, have you seen the free parser though :o
23:00:31 <mniip> er, s/though/btw/
23:00:50 <Cale> mniip: hm, no, but I can sort of imagine what one might look like
23:00:55 <mniip> oh?
23:05:12 <mniip> Cale, you think? :p
23:05:20 <Cale> mniip: hm?
23:06:00 <mniip> Cale, well, uh, I made this http://lpaste.net/151381
23:06:40 <Cale> mniip: ah, okay, that's not the functor I was thinking of
23:06:58 <Cale> (I was just thinking of a big functor with constructors for all the usual parser combinators)
23:07:01 * hackagebot postgresql-binary 0.7.9 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.9 (NikitaVolkov)
23:07:07 <mniip> ah no
23:07:27 <mniip> (is this what a 'free something' usually means?()
23:07:33 <Cale> hm?
23:08:13 <Cale> Freeness is actually always a relationship between two sorts of structures
23:09:10 <Cale> (and actually, sometimes it's not unique... things can have more than one left adjoint)
23:09:59 <akfp> I want a zipper for a 2d structure.  I have a [[a]], what 2d structure has good support for zippers.  Lens-zippers would be fine.
23:10:19 <akfp> I want to go up, down, left, right.
23:10:47 <mniip> [[a]]? you have rows of different size?
23:11:06 <akfp> I do, so I'd have to do some intelligent alignment when I create the 2d thing.
23:11:40 <akfp> it's basically tokenized text, but I need to move vertically for inferring table-like structures.
23:16:24 <jellytux> Hi, how can I produce a simple sum function which input may take either Float or Int?
23:16:41 <jellytux> if it takes Int it should return Int, if it takes Float it should return Float
23:17:18 <mniip> so like
23:17:18 <liste> jellytux the Num type class
23:17:20 <mniip> :t (+)
23:17:22 <lambdabot> Num a => a -> a -> a
23:17:51 <liste> > let sum :: Num a => [a] -> a; sum = foldr (+) 0 in sum [1,2,3,4,5]
23:17:53 <lambdabot>  15
23:18:05 <mniip> :t sum
23:18:07 <lambdabot> (Num a, Foldable t) => t a -> a
23:18:08 <mniip> ^exists in prelude
23:18:48 <jellytux> Cool thanks
23:22:02 * hackagebot http-media 0.6.3 - Processing HTTP Content-Type and Accept headers  https://hackage.haskell.org/package/http-media-0.6.3 (TimothyJones)
23:27:37 <tpsinnem> hey, can i somehow conditionally halt compilation with an error in template haskell?
23:27:52 <phadej> jes, just "fail" in Q monad
23:28:04 <tpsinnem> phadej: ok, thanks!
23:42:27 <domen> which tools are used in haskell for gui programming?
23:43:54 <jellytux> mniip: will the => be reused in other areas?
23:44:02 <mniip> ?
23:44:26 <jellytux> mniip: (Num a, Foldable t) => t a -> a
23:44:41 <liste> domen gtk2hs and hsqml for "traditional" desktop apps and threepenny-gui for browser-based GUI
23:44:45 <liste> (for example)
23:45:19 <jellytux> mniip: or only when defining a type with arguments or aliases?
23:45:25 <tpsinnem> might there be tools to execute a program like with 'executeFile' in System.Posix.Process, except using an in-memory binary rather than something on the filesystem?
23:46:15 <tpsinnem> i would like to bake an existing executable binary into my haskell program
23:46:26 <liste> jellytux: the stuff left of "=>" is called "context"
23:46:35 <mniip> tpsinnem, operating systems rarely provide such facilities
23:47:01 <mniip> on linux there's no way to spawn a process if you don't have a full elf file somewhere in the filesystem
23:47:05 <jellytux> liste: ah, thanks now it will be easier to look up
23:47:15 <tpsinnem> mniip: ok
23:47:52 <liste> jellytux http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
23:48:33 <tpsinnem> i suppose i could dump the file into /tmp and run it from there
23:48:49 <jellytux> liste: I am currently reading that one
23:48:56 <mniip> tpsinnem, what are you trying to do
23:49:21 <jellytux> liste: soon on typeclasses-101
23:49:53 <tpsinnem> mniip: i'm looking to create setuid wrappers for programs, with fixed arguments
23:50:05 <liste> jellytux "=>" will be explained later then (:
23:50:13 <mniip> tpsinnem, that's... an interesting approach
23:52:34 <jellytux> liste: after reading through the entire guide, is there any books I should buy, or does this guide cover most?
23:52:44 <mniip> Cale, hmm, if I said data Foo a = Return a | Join (Foo (Foo a))
23:52:50 <mniip> could I call that a free monad?
23:53:48 <tpsinnem> i suppose i'll just use the original binary, but i was curious to see if i could avoid keeping it around
23:55:09 <johnw> mniip: I'm not sure what would make that "free" in any sense
23:55:35 <mniip> tpsinnem, well, you could exec without using the actual system call, but that's a task for a very low level library written in half C half assembly, about the size of glibc
23:56:49 <mniip> johnw, well then I have no idea what 'free' means
23:58:11 <tpsinnem> mniip: yeah, i think i'm not going to get too fancy just to be silly
23:58:27 <mniip> I tried making something of that nature once
23:58:29 <mniip> didn't go well
