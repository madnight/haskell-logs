00:14:27 <lonokhov> o/
00:15:17 <lonokhov> is hDuplicateTo atomic, or should I guard second handle with lock, say if I want to reopen log file?
00:25:48 * hackagebot hsqml 0.3.4.0 - Haskell binding for Qt Quick  https://hackage.haskell.org/package/hsqml-0.3.4.0 (RobinKay)
00:26:01 <mniip> so I wrote a thing
00:26:09 <lpaste> mniip pasted “quickSort” at http://lpaste.net/153261
00:26:14 <mniip> looks good?
00:40:55 * hackagebot hsqml-demo-samples 0.3.4.0 - HsQML sample programs  https://hackage.haskell.org/package/hsqml-demo-samples-0.3.4.0 (RobinKay)
00:45:55 * hackagebot cndict 0.7.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.1 (DavidHimmelstrup)
01:38:57 <hectortrope> Hi how can we parse json in haskel ?
01:39:02 <lyxia> mniip: you can use findM to shorten divideAbove and divideBelow!
01:39:09 <hectortrope> its very very complicated right?
01:39:37 <lyxia> hectortrope: have you looked at aeson
01:40:16 <kadoban> hectortrope: JSON isn't that complicated, as far as formats go. aeson seems to be the standard answer, it works pretty well as far as I've seen (which isn't very far, but whatever)
01:41:04 <mniip> lyxia, oh?
01:42:27 <cocreature> hectortrope: it’s not complicated at all. aeson is pretty easy to use
01:42:54 <lyxia> mniip: divideAbove looks for the last value smaller than the pivot, divideBelow looks at the first greater, this is a job for findM!
01:46:12 <hectortrope> lyxia:  kadoban  cocreature  I don't even know basics of haskell but I just want't write some parsing toolmis haskell so what is aeson ?
01:48:40 <cocreature> hectortrope: https://hackage.haskell.org/package/aeson-0.11.0.0/docs/Data-Aeson.html but it’s pretty hard to dive into haskell by just starting to write something because it’s quite different from a lot of other languages
01:48:41 <tdammers> hmm, my code leaves zombie processes around even though I call terminateProcess on them
01:49:04 <merijn> tdammers: Do you wait(2) on them?
01:49:17 <hectortrope> ok Thanks cocreature 
01:49:30 <merijn> tdammers: Calling terminateProcess is, in all likelihood WHY they are zombies
01:49:37 <merijn> If you didn't kill them they wouldn't be zombies
01:49:47 <tdammers> well, yeah
01:50:49 <EvanR> so i tried this in ghci let foo = $( bar [| \[a, a, a] -> [a] |] ) trying to be clever using lambda for configuration of some template
01:50:51 <merijn> You always need to wait on child process to reap zombies
01:50:57 <merijn> *processes
01:50:58 <EvanR> but i cant have duplicate names in the lambda pattern
01:51:02 <EvanR> what do i do
01:51:13 <tdammers> right, yeah, that does the trick
01:52:34 <EvanR> is there a way to pass dummy vars to TH, just for their string values, other than using strings
01:53:12 <EvanR> the lambda actually would be perfect
01:54:53 <nomeata> What is an example for a function of type [a] -> b (where b is something other than a list type) that is implemented via "foldr f n" for some simple f and n.
01:55:05 <nomeata> like sum = foldl' (+) 0, but for foldr
01:56:35 <Athas> nomeata: short-circuiting 'all'.
01:56:48 <Athas> scall = foldr (&&) True
01:56:59 <nomeata> Athas: ah, perfect example. Thanks!
01:57:35 <lyxia> funny thing, foldrM uses foldl while foldlM uses foldr
02:12:18 <EvanR> omg quasi quotes
02:36:59 <hackriledge> Lists are implicitly indexed as are one dimensional with a natural implementation of elem. Is there a class requiring an implementation of elem is provided?
02:37:22 <hackriledge> They*
02:37:32 <EvanR> :t elem
02:37:39 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
02:38:04 <hackriledge> Sorry, I mean (!!)
02:38:14 <hackriledge> :t (!!)
02:38:20 <lambdabot> [a] -> Int -> a
02:38:46 <EvanR> yuck
02:38:48 <hackriledge> :t toList
02:38:56 <lambdabot>     Ambiguous occurrence ‘toList’
02:39:00 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
02:39:03 <kqr> is there a good function in the vein of "UrlEncodable a => Map String a -> URLParams"?
02:39:46 <hackriledge> :t Data.Foldable.toList
02:39:55 <lambdabot> Foldable t => t a -> [a]
02:40:35 <hackriledge> So foldable containers have a natural implementation of (!!)
02:40:59 <EvanR> foldables are just basically lists
02:41:35 <hackriledge> However toList removes information about referencing e.g. Which branch of a tree an element lies in and it's local connectivity in this sense
02:42:04 <EvanR> how would you have that info with !! anyway
02:42:41 <hackriledge> A more natural index could be a list of left or right Boolean indicators for a binary tree
02:43:07 <EvanR> youre looking for zippers
02:43:17 <hackriledge> Interesting
02:44:35 <hackriledge> What is the class with this index function and what is the function called?
02:45:31 <EvanR> you might also be looking for containers type class
02:45:32 <hackriledge> :: Zipperlike a -> Index a -> a
02:45:39 <EvanR> which isnt that interesting
02:45:49 <EvanR> :t (!)
02:45:52 <lambdabot> Ix i => Array i e -> i -> e
02:47:04 <hackriledge> :t Data.Map.(!!)
02:47:19 <lambdabot> Not in scope: data constructor ‘Data.Map’
02:47:28 <hackriledge> Nvm
02:47:54 <hackriledge> Ok so Ix is available
02:48:18 <hackriledge> But it's not close to Monoid
02:49:23 <hackriledge> A Tree is a Foldable so I can use toList and (!!)
02:50:12 <hackriledge> I think Foldable is like Monoid because List is the Free Monoid and foldable has toList
02:51:07 * hackagebot ginger 0.1.3.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.3.0 (TobiasDammers)
02:53:04 <hackriledge> How is Traversable related in this sense?
02:56:46 <hackriledge> data Zipper a = Zipper [a] [a]
02:56:59 <hackriledge> I'm not sure that's what I'm looking for
02:57:09 <EvanR> the zipper is your index
02:57:14 <hackriledge> From; http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html?m=1
02:58:05 <hackriledge> Hmm, strange type for an index
02:58:15 <EvanR> welp
02:59:21 <hackriledge> left and right seem to be like some heap descending thing
03:00:34 <EvanR> or ascending
03:01:14 <hackriledge> You should be able to see that in some sense comonads describe lazy computations and monads represent strict ones. !!!!!
03:01:25 <hackriledge> Oh zippers
03:01:31 <EvanR> eh...
03:01:45 <hackriledge> From the article linked above
03:02:22 <EvanR> comonads are like functors, but with an extra feature which is pretty much useless by itself
03:02:58 <EvanR> you have to specifically use the types support to utilize duplicate
03:03:12 <EvanR> in a way thats not just a functor way
03:04:32 <hackriledge> :t cojoin
03:04:53 <EvanR> :: w a -> w (w a)
03:05:07 <EvanR> Comonad w =>
03:05:15 <hackriledge> Yeah
03:05:22 <hackriledge> Crazy!
03:05:48 <hackriledge> So a hylomorphism can be made of a monad and a comonad
03:06:18 <hackriledge> I wonder how to handle the fixed point
03:07:02 <zipper> Damnit people in this channel always mention my nick when referring to zippers :(
03:07:18 <hackriledge> I guess it's when id = join.cojoin
03:07:35 <hackriledge> Hi zipper, sorry!
03:08:00 <zipper> hackriledge: It's for a good cause :) it's cool.
03:08:07 <bernalex> zipper: at least you're not called monad or burrito.
03:09:36 <zipper> haha 
03:10:23 <hackriledge> hylo =? foldr1 (.) ((repeat join) ++(repeat cojoin))
03:10:37 <hackriledge> Helpf^
03:11:47 <hackriledge> Lazy lazy evaluation...
03:12:08 <mniip> cojoin?
03:12:17 <mniip> as in comonadic duplicate?
03:12:41 <mniip> :t duplicate
03:12:44 <lambdabot>     Not in scope: ‘duplicate’
03:12:44 <lambdabot>     Perhaps you meant one of these:
03:12:44 <lambdabot>       ‘replicate’ (imported from Data.List),
03:12:47 <mniip> :t Control.Comonad.duplicate
03:12:51 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
03:12:59 <hackriledge> Yeah that's it
03:13:38 <hackriledge> > Control.Comonad.duplicate []
03:13:57 <lambdabot>  mueval-core: Time limit exceeded
03:14:04 <hackriledge> Ok
03:14:24 <EvanR> empty lists arent valid comonads
03:14:48 <hackriledge> @define duplicate = Control.Comonad.duplicate
03:14:55 <lambdabot>  .L.hs:145:13:
03:14:55 <lambdabot>      Not in scope: ‘Control.Comonad.duplicate’
03:14:55 <lambdabot>      Perhaps you meant ‘Control.Monad.replicateM’ (imported from Control.Monad)
03:15:04 <bernalex> I am doing something wrong. what am I doing wrong?
03:15:06 <bernalex> w { activeRoom = (activeRoom w) { roomItems = sort (xs <> ys) } }
03:15:15 <bernalex> that should update the roomItems of activeRoom in w
03:15:25 <bernalex> well, I should say, that's what *I want to do*
03:15:45 <bernalex> instead I make a *new activeRoom*, with those roomItems
03:15:53 <bernalex> i.e. the rest of activeRoom's properties are merely discarded
03:15:54 <bernalex> halp!
03:16:18 <mniip> EvanR, is it valid to say that "intuitively", duplicate replaces every item in a structure, with a part of the structure that "hangs" on that item?
03:16:45 <EvanR> each point is replaced with a copy of the world pointing at that point
03:17:15 <EvanR> this world is not accessible via comonad methods so you necessarily have to specialize
03:17:41 <hackriledge> !!!
03:17:43 <mniip> huh?
03:18:02 <EvanR> im saying youll have a hard time making a generic comonad utility function
03:18:09 <EvanR> unlike the monad lib
03:18:27 <hackriledge> Who is this monad lib?
03:18:43 <hackriledge> Ok i understand
03:18:47 <EvanR> Control.Monad
03:18:53 <hackriledge> Yes
03:19:27 <hackriledge> I think that's the library I'm trying to produce
03:19:38 <hackriledge> Doh!
03:20:08 <hackriledge> The generic hylomorphism resulting from a monad and a comonad
03:20:30 <hackriledge> I think i will have to impose some extra structure on the comonad
03:20:30 <EvanR> the beast with two backs
03:20:34 <bernalex> oh. I might have fixed it. but I have also broken my haskell packages because they are all updating.
03:20:41 <bernalex> but removing the parens might have fixed it maybe
03:20:52 <hackriledge> Nice
03:21:07 <hackriledge> So I was wondering about indexing...
03:21:36 <hackriledge> To indicate naked ends which can be extended
03:21:55 <hackriledge> Does that make sense in this context?
03:22:26 <hackriledge> Toward this generic comonad
03:23:07 <hackriledge> And does anyone know of a class for such indexing?
03:23:15 <hackriledge> Is it zipper?
03:24:05 <EvanR> well theres the Store comonad
03:24:36 <hackriledge> What is it's significant?
03:25:24 <mniip> data Store s a = Store s (s -> a)
03:25:43 <mniip> the implementation of 'extract' is probably obvious
03:26:17 <hackriledge> It takes the a and supplies it to the function?
03:26:55 <hackriledge> s*
03:28:05 <zipper> hackriledge: Are you talking to me?
03:28:18 <hackriledge> So s is the index I'm searching for?
03:28:25 <hackriledge> Hi zipper sorry!
03:29:37 <hackriledge> I'm talking to anyone on the channel who can answer, the Covent was not directed at you...
03:29:42 <mniip> hackriledge, yes
03:29:51 <hackriledge> Comment*
03:29:58 <hackriledge> Awesome!!
03:30:25 <hackriledge> Ok store comonad here I come!
03:31:06 <hackriledge> Any info on hylomorphism using Store?
03:31:07 <mniip> now try to come up with a 'Store s a -> Store s (Store s a)'
03:31:44 <hackriledge> I'm calling the package zebedde
03:34:38 <hackriledge> It requires definition of fixed point conditions
03:35:44 <mniip> huh
03:35:51 <mniip> duplicate for Store doesn't require anything
03:36:03 <EvanR> dont forget the zygohistowhatsits
03:36:29 <hackriledge> I have seen Either used well in hylomorphisms so require a Boolean value to indicate escape
03:37:29 <hackriledge> Oh I thought it would be infinite
03:38:19 <hackriledge> Is there only one possible definition?
03:38:43 <combinator> @pl \i -> (i, i+1, ())
03:38:43 <lambdabot> flip (ap (,,) (1 +)) ()
03:38:45 <mniip> well the one I have in mind doesn't involve nontermination or anything funky like that
03:39:05 <hackriledge> If so what I'm doing is slightly different, I'm creating another comonad
03:39:53 <hackriledge> It's like unfold right?
03:40:13 <hackriledge> duplicate
03:40:47 <hackriledge> Like how fold is like join
03:40:57 <mniip> fold is like join?
03:40:57 <EvanR> duplicate is like the old star trek games where before you go anywhere you activate sensors to see whats around
03:41:03 <mniip> I don't see the similarity
03:41:30 <EvanR> you can look at all the results, then choose where to warp to (with fmap or special support from the type)
03:41:32 <hackriledge> Activate burrito
03:42:28 <hackriledge> I think of monads like foldable containers not sequential computations so I don't get your analogy
03:42:58 <mniip> hackriledge, I'll hint a bit:
03:43:01 <EvanR> in the Life comonad, the choice would be dependent on the 8 neighbors bits
03:43:15 <mniip> duplicate (Store s f) = Store _ $ \s' -> Store _ _
03:43:51 <kqr> problem: i want to "stack install" a library from stackage which has an incorrect dependency specified. idea for solution: specify a new dependency on the "stack install" command line. is this possible?
03:43:54 <mniip> this follows pretty obviously from the type
03:44:34 <hackriledge> (mniip) duplicate (Store s f) = Store s $ \s' -> Store s' f?
03:45:17 <hackriledge> Is that right? What's with all your underscores?
03:45:23 <liste> kqr: you can add the dependencies to $HOME/.stack/global-project/stack.yaml
03:45:47 <liste> kqr: or do you mean it has dependency that makes it unbuildable?
03:46:09 <hackriledge> :t duplicate
03:46:13 <lambdabot>     Not in scope: ‘duplicate’
03:46:13 <lambdabot>     Perhaps you meant one of these:
03:46:13 <lambdabot>       ‘replicate’ (imported from Data.List),
03:46:24 <mniip> hackriledge, exactly
03:46:32 <hackriledge> Ok cool
03:46:51 <kqr> liste, yes. specifically the flickr package. it depends on "network" which used to include Network.URI, which has since been split off into a separate network-uri package
03:46:56 <mniip> although it seems that the definition of Store is backwards: data Store s a = Store (s -> a) s
03:47:08 <mniip> so the function eta-reduces to
03:47:21 <mniip> duplicate (Store f s) = Store (Store f) s
03:48:14 <hackriledge> I think I'm trying to use store to index a container and then make a comonad instance for this container
03:48:54 <kqr> liste, and the flickr package does not depend on network-uri, so I'd like to give stack a hint that network-uri is really a dependency even though it doesn't seem that way
03:48:57 <hackriledge> Rather than using Store as the comonad
03:49:59 <EvanR> containers are so exciting
03:50:46 <mniip> hackriledge, did you know, just like Reader is a Monad, Coreader (Writer) is a comonad
03:51:06 <mniip> and just like Writer is a monad with a monoidal constraint, Reader is a comonad with a monoidal constraint!
03:51:16 <hackriledge> I don't know about those
03:51:55 <mniip> type Reader r a = r -> a
03:52:01 <hackriledge> My initial question is how Store is like Monoid
03:52:03 <mniip> type Writer t a = (t, a)
03:52:37 <shachaf> Writer is a comonad with a comonoidal constraint, and Reader is a monad with a comonoidal constraint.
03:52:39 <hackriledge> Hellish
03:54:48 <hackriledge> If join = fold, then duplicate = unfold, and toList and fromList should be available
03:54:53 <hackriledge> Is makes sense?
03:55:21 <hackriledge> There is a natural interpretation of indexing via (!)
03:55:44 <hackriledge> So it should tie in with store concerning indexing
03:56:52 <hackriledge> Foldable structures are Monoids?
03:56:57 <hackriledge> That's ok?
03:58:14 <hackriledge> mconcat = fold.fromList
03:58:34 <hackriledge> Ok so foldables containing Monoids are Monoids?
03:59:21 <hackriledge> Sorry...
03:59:29 <bernalex> if there's an instance Monoid [a]
03:59:37 <hackriledge> Neither of those are true..
03:59:38 <bernalex> i.e. f a
03:59:56 <liste> kqr: you may need to clone the source locally and modify the .cabal file
04:00:28 <liste> that's bad for distributing your package, but so is overriding dependencies in the command line...
04:01:54 <liste> kqr: see http://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
04:04:57 <kqr> liste, is it okay to clone a source from hackage?
04:05:35 <liste> kqr: sure
04:06:16 <bernalex> I'm pretty sure I'm supposed to be able to update a nested record
04:06:17 <merijn> "It Depends"
04:06:17 <bernalex> but w { activeRoom = (activeRoom w) { roomItems = sort (xs <> ys) } }
04:06:20 <bernalex> doesn't do that
04:06:22 <doudou> finally, i found a debian on another computer, and i have been able to install ghci , is there threads with haskell? is there socket databases http server and things like that?
04:06:28 <bernalex> so wtf am I doing wrong this time around?
04:06:42 <kqr> doudou, yes
04:06:48 <doudou> thanks
04:06:49 <liste> doudou: there's packages in hackage that do those, and a lot more
04:06:56 <liste> there's very little built in
04:07:06 <merijn> bernalex: What's the error/context/whatever?
04:08:29 <bernalex> merijn: I don't even know wtf is going on. it seems that code gives me a Room with the correct roomItems, but with all other fields broken. I don't even know how that's possible. it should give an error about not giving the other fields, iirc.
04:08:36 <doudou> I continue reading my book, chapter 2 only. then i will search thank you
04:08:36 <bernalex> maybe something else is broken somewhere else.
04:09:12 <bernalex> I need to try this in the repl and see wtf is up
04:09:40 <mniip> wait,
04:09:44 <mniip> is Store just Costate?
04:10:14 <EvanR> Store is Co tuple
04:10:14 <shachaf> Depends on what you mean by Co.
04:10:29 <mniip> EvanR, no that'd be Reader?
04:10:39 <mniip> shachaf, fsvo Co :D
04:11:03 <EvanR> coconauts
04:11:05 <shachaf> If Co w a = forall r. w (a -> r) -> r, then State = Co Store
04:11:25 <shachaf> And the adjunction (e,) -| (e ->) gives you the monad State and the comonad Store.
04:13:42 <mniip> wait what
04:13:55 <mniip> that Co is pretty fancy
04:15:12 <EvanR> what is the opposite of that Co, if any
04:15:17 <EvanR> empty string?
04:15:33 <mniip> it's the opposite of itself
04:15:53 <EvanR> pure co
04:16:02 <shachaf> Co (e,) = (e ->), Co (e ->) = (e,)
04:16:10 <mniip> shachaf, yeah exactly
04:16:11 <EvanR> oh
04:16:29 <mniip> how very fancy
04:16:38 <EvanR> co is a mapping between adjoint functors
04:16:39 <bernalex> merijn: ok I solved it. i.e. I figured out what was broken, and broke it a bit further, and vòila I have another "exercise" for tonight. :]
04:22:16 <mniip> it seems that Co NonEmpty = []
04:23:09 <mniip> shachaf, can one write free monads/comonads using Co?
04:24:01 <shachaf> Why is Co NonEmpty = []?
04:24:21 <mniip> well, NonEmpty a = (a, [a])
04:24:31 <mniip> so (a -> r, [a -> r]) -> r
04:25:24 <shachaf> I don't follow.
04:25:32 <shachaf> What value :: forall r. NonEmpty (a -> r) -> r corresponds to []?
04:25:35 <mniip> me neither :s
04:29:37 <platzhirsch> I remember there was a really good comic about FP, couple of pages long, PDF.. any idea?
04:34:28 <kqr> does anyone know what this stack error means? http://lpaste.net/1115113508795580416
04:47:07 <pavonia> kqr: Is that module compiling correctly?
04:47:13 <liste> kqr: is there anything before that error?
04:51:13 * hackagebot http2 1.5.1 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.5.1 (KazuYamamoto)
04:51:25 <kqr> a lot, let me copy&paste
04:53:40 <kqr> http://lpaste.net/705846732289736704
04:54:28 <kqr> whoops, that is "stack install flickr"
04:54:40 <kqr> i'll try removing the executables from the cabal file
04:54:45 <kqr> because I don't need 'em anyway
04:55:17 <kqr> well that actually did it
05:08:01 <hackriledge> cocodamonad
05:09:00 <hackriledge> Can anyone give me an example of using zippers?
05:10:58 <mniip> cobiendosemiditranscontramonadoid
05:11:29 <mniip> hail cokmett
05:11:36 <hackriledge> ...
05:13:09 <EvanR> aruba, jamaica
05:13:36 <hackriledge> Devo, monganoid
05:13:48 <bernalex> hackriledge: a speed reading program
05:14:10 <bernalex> hackriledge: it zips down the text you are reading one word at the time, so that you rewind/fast-forward/whatever at any time.
05:14:15 <kqr> ah dagnabbit. the flickr package uses the HTTP package which doesn't support HTTPS which flickr requires these days. should be pretty simple to swap out (only three functions dealing with HTTP in the flickr package) but... meh. some day maybe
05:14:18 <hackriledge> Can we use zippers in lambdabot?
05:14:29 <bernalex> hackriledge: you can define any data type with lamdabot
05:14:50 <hackriledge> I'd like to see it in use...
05:15:20 <mniip> @let data Data = Data
05:15:33 <hackriledge> Specifically in constructing a hylomorphism
05:15:39 <EvanR> @let data Data = Data Data Data Data
05:15:48 <mniip> ded?
05:15:59 <hackriledge> It was slow before
05:16:13 <mniip> @ping
05:16:27 <hackriledge> > "I'm ok"
05:16:41 <hackriledge> rip
05:17:32 <hackriledge> I think I broke it with duplicate []
05:17:46 <mniip> nah
05:17:52 <mniip> unlikely
05:17:56 <lynn> Hiya. I'm using monad transformers in a "real" project for the first time
05:17:58 <lambdabot> Plugin `eval' failed with: <<timeout>>
05:18:09 <hackriledge> It's alive!
05:18:36 <mniip> I wonder
05:18:39 <lynn> I had a bunch of `lift`s in my code, which felt awkward, so I looked on StackOverflow and found this trick: http://stackoverflow.com/a/9054826/257418
05:18:58 <mniip> @undefine
05:18:58 <lambdabot> Undefined.
05:19:05 <mniip> > ""
05:19:10 <lambdabot>  ""
05:19:22 <mniip> was that it?
05:20:32 <merijn> lynn: What's the question? :)
05:20:44 <lynn_> Oops, bad internet
05:20:53 <lynn_> <lynn> I had a bunch of `lift`s in my code, which felt awkward, so I looked on StackOverflow and found this trick: http://stackoverflow.com/a/9054826/257418
05:20:54 <lynn_> <lynn> (Which is really cool!! :D)
05:21:03 <lynn_> But now all my functions have silly type signatures like this:
05:21:11 <lynn_> (MonadState BotState m, MonadReader UserID m, MonadIO m) => Message -> m ()
05:21:19 <EvanR> welcome to transformers
05:21:24 <hackriledge> Lol
05:21:39 <hackriledge> They look friendly
05:21:52 <lynn_> Before, I had written a cool type alias, and it was simply `Message -> Action ()`.
05:21:54 <EvanR> complexity in disguise
05:21:56 <merijn> lynn: You can use the mtl function to get the "magically lifted" versions of get/put/ask/etc.
05:22:22 <hackriledge> I wonder if I will ever need these
05:22:39 <lynn_> Oh, yeah, I got rid of the lifts, but now I have that big list of FlexibleContexts in each signature I write
05:22:40 <merijn> lynn: i.e. "Message -> Action ()" should still work, if you just make sure that 1) you import the mtl versions and 2) make Action an instance of MonadState/MonadReader/MonadIO
05:23:01 <lynn_> I see
05:23:14 <merijn> lynn: There's no reason you have to keep the 'm' polymorphic (which is what causes all those contexts)
05:23:48 <liste> there's also https://twitter.com/haskelltips/status/528305089866256384, but using the concrete type in signatures is better imo
05:23:52 <lynn_> Actually, I think I do have a reason, but I'm not sure...
05:24:17 <merijn> Or, if you just have "type Action a = StateT BotState (ReaderT UserID IO) a" it "should just work"
05:24:43 <bernalex> is this where we should be asking people "have you heard of our lord and saviour idris?"
05:25:15 <merijn> lynn_: If you were happy with "Message -> Action ()" before and just wanted to get rid of the lifts, you don't need a polymorphic m
05:25:30 <lynn_> I have two different transformer stacks using the same functions. `Action`s are `StateT BotState IO`. `ReplyAction`s are `ReaderT UserID (StateT BotState IO)`.
05:25:44 <hackriledge> So earlier I was introduced to the Store comonad, I don't like it however as I would like to use zippers as my index
05:25:53 <bernalex> that's the problem most people have with transformers. it happens in a lot of other contexts too, like databases. i.e. the quest for generality above everything else.
05:26:27 <hackriledge> Does that make sense? I can define a store using (!!)....
05:26:29 <lynn_> Some of the functions I'm writing are replies to some user command, in which case I want to be able to `ask` their UserID. So I add a ReaderT layer for those
05:27:36 <lynn_> Actions that are user-independent, only updating the BotState, don't need such a layer
05:27:38 <hackriledge> Is there a class requiring cons is defined?
05:27:57 <mniip> 1456320116 [16:21:56] <liste> there's also https://twitter.com/haskelltips/status/528305089866256384, but using the concrete type in signatures is better imo
05:28:24 * mniip . o O ( (,,,) <$> Show <*> Read <*> Eq <*> Ord )
05:28:40 <lynn_> mniip: Oh, wow. I suppose what I'm doing is a valid usecase for that...
05:29:06 <mniip> I er, that's not actually a thing
05:29:11 <hackriledge> :t (:)
05:29:11 <merijn> mniip, liste: Except that ConstraintKinds is infectious, last time I used that
05:29:16 <lambdabot> a -> [a] -> [a]
05:29:25 <lynn_> I mean the tweet you linked
05:29:30 <merijn> i.e. you need to enable ConstraintKinds in every module using that alias, at least last I used it
05:29:41 <lynn_> (Or, the tweet liste linked)
05:30:01 <EvanR> hackriledge: these kinds of "classes" for "lookupable" and "consable" are really not that great
05:30:34 <hackriledge> cons :: Constructable => a -> m a -> m a
05:30:49 <hackriledge> Why is it bad?
05:30:55 <merijn> hackriledge: Why is it good?
05:31:05 <merijn> hackriledge: Not everything that CAN exist SHOULD exist
05:31:13 <merijn> See Fairbairn threshold
05:31:14 <hackriledge> It gives my Monads more structure
05:31:15 * hackagebot fswatcher 0.2.1 - Watch a file/directory and run a command when it's modified  https://hackage.haskell.org/package/fswatcher-0.2.1 (ErlendHamberg)
05:31:18 <EvanR> youre not really saying much when you say you support a function of type a -> Floob -> b
05:31:27 <merijn> At some point remembering that something exists becomes harder than just writing it again
05:31:50 <hackriledge> ...
05:31:55 <EvanR> hackriledge: you might want to look at record interfaces instead
05:31:59 <lynn_> Anyway, as I wrote, this is my first time using monad transformers. To be honest, what I have right actually works very elegantly; it's just a bit ugly and hard to read
05:32:03 <hackriledge> It seems a necessary superclass
05:32:31 <hackriledge> You mean the curly braces evanr?
05:32:50 <lynn_> I was really amazed at how, like...
05:33:11 <lynn_> In other languages using this kind of feature is complex, and there are ways to "do it wrong"
05:33:31 <EvanR> transformers is not an exception to that ;)
05:34:25 <tdammers> merijn: the hardest part is not knowing that it exists, but being able to find it
05:34:28 <lynn_> Haskell did a good job forcing my code to make sense, I suppose
05:34:58 <hackriledge> I would like something like mappend which is certainly behaving like (++) and certainly not like (+)
05:35:10 <EvanR> <>
05:35:20 <hackriledge> No...
05:35:27 <hackriledge> That's simply a synonym
05:35:39 <tdammers> then explain what it needs to do *differently*
05:36:27 <hackriledge> > mappend [1] [2]
05:36:45 <hackriledge> Not;
05:37:15 <hackriledge> > fold [1,2::Sum Int]
05:37:24 <lambdabot>  Sum {getSum = 3}
05:37:28 <lynn_> Imagining the natural numbers as [()] shows you there isn't much structural difference between (++) and (+)
05:37:48 <EvanR> + carries some implications though
05:37:53 <EvanR> connotations
05:37:54 <hackriledge> It's one nesting out
05:38:08 <merijn> mappend already just appends lists...
05:38:15 <hackriledge> Internal Monoids or Monoids as containers
05:38:24 <EvanR> lynn_: ++ isnt commutative ex
05:39:19 <phadej> EvanR: it is for [()]
05:39:24 <EvanR> natural numbers as natural numbers object ftw
05:39:33 <hackriledge> Associative identity
05:39:42 <lynn_> Well, what I mean is, I think I know what hackriledge means by "behaving like (++)"
05:39:54 <hackriledge> Thanks
05:40:29 <lynn_> (+) feels like it reduces values and "loses" information; (++) feels like it's putting things together without reducing anything.
05:40:34 <merijn> I'm still not sure what the value of making it a class is?
05:40:54 <lynn_> But it doesn't make sense to distinguish between those things on a typeclass level, which is what my example tried to demonstrate
05:41:33 <lynn_> i.e., you can look at what (+) does on naturals in a very (++)-like perspective.
05:41:45 <hackriledge> I guess n = sum $ take n $ repeat (length [[]])
05:41:59 <EvanR> in that particular representation
05:42:55 <EvanR> lynn_: heres another interesting one http://graphicallinearalgebra.net/2015/05/16/natural-numbers-diagrammatically/
05:43:09 <lynn_> Anyway, Monoids are nice! Why divide them into subclasses that are less nice
05:43:38 <hackriledge> Because there are some things I can do to containers I can't do to elements
05:43:50 <hackriledge> Like, extract elements
05:44:06 <cocreature> so what you really want is a typeclass that allows you to extract elements?
05:44:34 <hackriledge> I thought having cons would imply this
05:44:42 <merijn> hackriledge: How so?
05:44:56 <merijn> "a -> m a -> m a" does not imply the existence of "m a -> a"
05:45:07 <EvanR> so far youve wanted to add every odd features of every data type to your type class
05:45:10 <hackriledge> If you can add things then at least they exist if your trying to extract them
05:45:30 <cocreature> hackriledge: only if there is no other way to create that thing
05:45:57 <EvanR> its nice to be able to separate stuff rather than crammed together inflexible monolithic
05:46:11 <hackriledge> Cons usually references the record constructor of the datatype
05:46:21 <merijn> "Const k a" sounds like it could easily implement "constructable :: a -> Const k a -> Const k a", but it's not very useful
05:46:24 <lynn_> Maybe you can think of some kind of "law" for cons?
05:46:37 <lynn_> Typeclasses aren't too useful without laws
05:46:41 <hackriledge> And is the natural way to add data to a datatype operating as a collection
05:46:57 <EvanR> youre sounding a lot like clojure
05:47:11 <EvanR> conjable, seqable, lookuppable
05:47:18 <hackriledge> Does that help me?
05:47:28 <EvanR> maybe you want clojure ;)
05:47:38 <bernalex> haskell has foldable and other not too great things too.
05:47:51 <hackriledge> I would prefer to understand your criticism of it's utility
05:47:59 <EvanR> yeah Foldable is the 1 think clojure guys seemed to have heard about ;)
05:48:07 <hackriledge> Foldable is awesome times
05:48:17 <hodapp> EvanR: a lot of Clojure actually was modeled after bits of Haskell :P
05:48:36 <bernalex> foldable is pretty silly imo. traverseable feels more sane.
05:48:37 <hackriledge> I want pure Haskell certainly
05:49:10 <hackriledge> There feels like there is a large redundancy between Monoid foldable and traversable
05:50:16 <hackriledge> As Monoid is a group... Perhaps the difference is that fold is not strictly associative
05:50:29 <merijn> Foldable isn't all that silly, imo. My biggest objection is a bunch of the new functions added to it later
05:50:33 <cocreature> a monoid is not a group
05:50:38 <bernalex> a monoid isn't a group wtf
05:50:42 <cocreature> a group is a monoid but not the other way around
05:50:59 <bernalex> monoids are "semigroups with identity".
05:51:02 <hackriledge> It's a collection who's elements are closed under mappend with identity
05:51:13 <EvanR> monoids are monoids in the category of monoids whats the problem
05:51:15 <cocreature> a group gives you an inverse
05:51:17 <merijn> hackriledge: groups require invertibility, etc.
05:51:31 <hackriledge> Like fractional?
05:51:38 <hackriledge> Hmm
05:51:48 <hackriledge> Ok, more like a ring I guess
05:51:59 <bernalex> EvanR: they are?
05:52:16 <EvanR> haha
05:52:35 <bernalex> EvanR: I guess they are. but it's a bit redundant to say so.
05:52:38 <EvanR> something like that... specifically commutative monoids
05:52:52 <merijn> bernalex: I think that was the joke... :p
05:52:53 <bernalex> I mean a monoid object in the monoidal category are obviously monoids
05:53:25 <EvanR> it doesnt seem so obvious, wtf is a monoid object in the category of monoids anyway
05:53:43 <hackriledge> Yeah, semigroup..
05:53:49 <bernalex> an object M with two morphisms, mu and eta.
05:54:12 <bernalex> EvanR: (M, μ, η) where μ: M ⊗ M → M; η: I → M.
05:54:23 <hackriledge> Anyway, Constructable...
05:54:55 <EvanR> yeah there is a theorem that a commutative regular monoid is such a monoid object in Monoid
05:55:07 <bernalex> for any category, the category of its endofunctors has a monoidal structure.
05:55:10 <EvanR> im still trying to type check that one
05:55:30 <bernalex> (namely the objecw thi compositions & identity)
05:55:38 <hackriledge> I can get nats using iterate ( :[[]])
05:55:52 <cocreature> what is the tensor product in Monoid?
05:55:59 <hackriledge> I want the analogous person for eg trees
05:56:06 <hackriledge> Operation*
05:56:11 <bernalex> and a monoid object in the category of endofunctors of a category is a monad on said category -- thereof the monad-joke/saying/meme/thing.
05:56:36 <EvanR> yadda yadda
05:57:24 <hackriledge> Further comment regarding constructable class
05:57:26 <lynn__> Are (&) and (>>>) and (<&>) heresy?
05:57:36 <lynn__> I like reading from left to right. ;-;
05:58:03 <bernalex> lynn__: not really. I put & in base because I like it.
05:58:18 <bernalex> lynn__: I also prefer >>= to =<<
05:58:21 <lynn__> (>>>) is so much louder than (.) though
05:58:31 <bernalex> yes I prefer . in that case
05:58:38 <bernalex> although >>> has its merits
05:58:41 <EvanR> lynn__: im using >>> in my current project
05:58:47 <bernalex> we should do what J does for function composition LOL
05:58:47 <EvanR> for backwards composition
05:58:57 <EvanR> of diagrams though not functions
05:59:24 <lynn__> J uses @ but it's the same direction as (.)
05:59:48 <bernalex> lynn__: J is muuuch more complicated than that. it has a bunch of different compositions.
05:59:49 <lynn__> (>>=) is cool! This project I've been writing has lots of:
06:00:08 <lynn__> doSomeThing >>= \case { pat -> ... }
06:00:23 <byorgey> EvanR: for understanding this stuff about monoid objects I can recommend the Catsters videos on the subject
06:00:31 <FireFly> bernalex: you mean trains and such?
06:00:32 <lynn__> None of them are (>>>)-y. It has &. though, which is amazing.
06:00:35 <hackriledge> Kk I'm away ciao
06:00:38 <byorgey> EvanR: see https://byorgey.wordpress.com/catsters-guide-2/#monoid-objects
06:00:42 <bernalex> FireFly: IDR what they're called. they have "hooks" and stuff.
06:00:45 <FireFly> Right
06:00:50 <FireFly> hooks and forks are trains
06:01:03 <FireFly> J terminology is a bit weird..
06:01:08 <bernalex> yeah and the way to use them, like a lot of J stuff, is to just remember some magic symbol and number
06:01:27 <FireFly> hooks and forks don't even have any syntax per se :P
06:01:32 <FireFly> or at least no magic symbols to remember
06:01:51 <lynn__> The classic example: +/ is sum, % is divide, # is count elements
06:01:53 <bernalex> oh? I thought you used a function composition uh monad uh something and a number to get the composition uh dyad you want
06:02:02 <bernalex> it's been a while since I looked at J, thankfully
06:02:05 <FireFly> (it's signified by juxtaposing functions, so it has "no syntax" the way function calls in Haskell have "no syntax")
06:02:07 <lynn__> and  (+/%#) y  is the mean of y
06:02:21 <lynn__> because it expands to (+/ y) % (# y), by some wacky rules.
06:02:25 <lynn__> It's really cute.
06:02:38 <bernalex> J is nice to have as a calculator on a phone or whatever, if you can be bothered remembering things
06:02:42 <EvanR> byorgey: thanks yeahi have these links
06:02:43 <mniip> +/ is a thing in APL too
06:02:44 <lynn__> You can read (+/ % #) as "sum over count".
06:02:46 <EvanR> i watched it once already
06:02:55 <EvanR> its going to take a few times
06:03:04 <FireFly> bernalex: that's basically how I use it, yeah :P
06:03:05 <byorgey> EvanR: fair enough =)
06:03:24 <EvanR> byorgey: sorry for waking you up by saying diagrams ;)
06:03:38 <lynn__> bernalex: Do you know about &. (Under)?
06:03:53 <mniip> I should learn J sometime
06:03:54 <lynn__> It is the coolest
06:04:17 <bernalex> lynn__: oh, in J? I remember pretty much nothing from J. if it is in the tutorial, I likely knew it at some point. :p
06:04:26 <mniip> FireFly, you probably know the J irc channel? ALIS is not willing to cooperate
06:04:50 <FireFly> #jsoftware
06:05:00 <lynn__> bernalex: I don't think tutorials mention it! But, (f &. g) is (g⁻¹ ∘ f ∘ g)
06:05:23 <FireFly> There's a really cute set of slides that explains J's various compositions and related things using Lego
06:05:23 <bernalex> ah. I think it's in the tutorial. I've seen it at some point at least. :]
06:05:27 <lynn__> And J tries to compute the inverse of g for you, which it often succeeds in, because of tacit functions just being trees.
06:05:48 <byorgey> EvanR: =D  no worries
06:06:19 <bfcf1169b30cad5f> sometimes i think even J programmers dont understand J
06:06:22 <FireFly> http://www.jsoftware.com/papers/FP/comb2.htm  here (and forward, using >>)
06:06:30 <bfcf1169b30cad5f> it all looks like befunge, but more difficult to understand
06:06:56 <FireFly> Tehe, it's not wrong
06:07:19 <FireFly> I admit, it definitely looks like line noise until you get used to it
06:07:27 <FireFly> and even rather noisy once you do get used to it
06:08:14 <lynn__> A J programmer I talked to once told me he just copy-pastes code into the J interpreter and dissects it interactively, and that's how you "read" programs.
06:08:18 <lynn__> Bit of a cop-out, IMO.
06:08:54 <bfcf1169b30cad5f> im more of a ¨lets write a novel in java or something to do somrthing you can do with 2 lines of J¨ person :^)
06:08:54 <mniip> lynn__, well sooner or later you learn to dissect code using just a text editor
06:08:57 <lynn__> Then again, he had that interesting APL/J/K way of thinking about "code". Where a line-noise one-line Sudoku solver is automatically better than 100 readable lines.
06:09:00 <mniip> without needing interactivity
06:10:14 <mniip> FireFly, fancy, I have no memory of this place: 1456322653 [17:04:13] * Loaded log from Mon Feb 17 11:08:15 2014
06:10:15 <FireFly> I mean, I could kinda see where he's coming from.. if I look at someone else's code I /could/ mentally run it, and probably do, but it's nice to look at how the program or part-of-program behaves on some input interactively
06:10:31 <FireFly> mniip: hehe, I think I dragged you there once :p
06:10:39 <FireFly> I don't really remember the context
06:10:51 <mniip> might have been APL
06:11:00 <FireFly> Oh yeah, possibly
06:11:27 <lynn__> I enjoy APL-likes, but I don't think I'd want to maintain a big project at all
06:11:42 <lynn__> I imagine a "big APL project" is one that doesn't fit on an A4 piece of paper
06:11:58 <merijn> lynn__: I have a good story about this...
06:12:04 <FireFly> That sounds massive :P
06:12:27 <merijn> lynn__: I was at PLDI 2 years ago and someone wrote a Dylan compiler (APL dialect) in Dylan, representing the AST as...arrays
06:12:33 <FireFly> I'm similar--I like them but wouldn't want to use them for anything big
06:13:08 <merijn> Amongst the marvels of his presentation was the "look how simple a compiler pass is", followed by a single slide having (seemingly) a 40x40 blobs of random unicode characters (and I mean dense 40x40 block)
06:13:18 <merijn> Which had everyone in the audience go "wut?"
06:13:25 <lynn__> Hahaha~
06:13:30 <FireFly> Haha
06:13:58 <merijn> I'm pretty sure Dylan causes addled mental states...
06:14:15 <lynn__> That is the best part about APL. People who get sucked in and start to think APL's normal to other people, too
06:14:54 <lynn__> Are there array-based and/or tacit programming languages that don't cram every builtin into a symbol or two?
06:15:38 <EvanR> matlab? ;)
06:15:42 <lynn__> Honestly, writing  "mean := sum / count"  makes forks and stuff look a lot less scary already.
06:16:43 * hackagebot mida 1.0.1 - Language for algorithmic generation of MIDI files  https://hackage.haskell.org/package/mida-1.0.1 (mrkkrp)
06:16:45 * hackagebot alga 0.2.1 - Algorithmic automation for various DAWs  https://hackage.haskell.org/package/alga-0.2.1 (mrkkrp)
06:17:15 <FireFly> lynn__: there's nial
06:17:32 <FireFly> There's also... what was it called
06:18:01 <lynn__> Wow, Nial looks cool
06:19:04 <FireFly> meh, I can't find the slides for the presentation, but there's http://lang5.sourceforge.net/tiki-index.php which is a mix of stack-based and array-based
06:20:08 <FireFly> > let avg = liftM2 (/) sum genericLength in avg [1,2,3,4,5]  -- speaking of forks
06:20:27 <FireFly> c'mon, lambdabot
06:21:44 <FireFly> :<
06:22:15 <merijn> FireFly: That's a bad implementation anyway :p
06:22:23 <FireFly> It is
06:22:53 <FireFly> I just wanted to show how liftM2 could act as a monadic fork in the J sense
06:22:56 <dinnu93> where can I start learning haskell ?
06:23:35 <dinnu93> there are quite a few resources but I'm unable to decide where to start
06:29:48 <phaazon> ey
06:29:59 <phaazon> what is the syntax to create typeclass synonym again?
06:30:15 <phaazon> like to gather several typeclass via a synonym?
06:30:27 <phaazon> (I don’t want to introduce a new typeclass for that)
06:30:34 <phaazon> something like
06:30:43 <phaazon> type Typeclass m = (A m,B m) => m
06:30:45 <phaazon> but I’m not sure
06:31:08 <phaazon> hm found it
06:31:12 <phaazon> it’s via ConstraintKind
06:39:40 <infinity0> has anyone been following the HKT discussion in rust
06:40:08 <infinity0> found this yesterday, very clear discussion of the hurdles remaining https://m4rw3r.github.io/rust-and-monad-trait/
06:41:11 <infinity0> thought people in here might be interested, rust is interesting in that some of its functions (that would otherwise be "pure" in a standard FP language) are impure and they explicitly model this
06:43:58 <liste> phaazon: https://twitter.com/haskelltips/status/528305089866256384
06:45:52 <isweet> anyone have experience with z3 lib? https://hackage.haskell.org/package/z3
06:47:57 <phaazon> liste: yeah, that’s what I used :)
06:55:27 <phaazon> do not we have a color output for ghc / ghci yet?
06:57:45 <merijn> phaazon: I saw someone working on that, but haven't seen it yet
06:57:52 <merijn> I guess the tricky bit is making that portable
06:57:59 <bitemyapp> merijn: ended up adding dlist
06:58:05 <bitemyapp> merijn: as an exercise, though.
06:58:41 <bitemyapp> merijn: so thank you for that :)
06:58:43 <phaazon> merijn: neat, I’ll be looking forward to that then
06:59:33 <isweet> So in general if I'm dealing with an FFI library, do I just have to deal with all code interacting with that library being in the IO monad?
06:59:48 <Sornaensis> guys what is the best up-to-date book on haskell for beginners who have no experience with functional programming
06:59:56 <phaazon> isweet: you can wrap it (MonadIO m) => m, or add a pure layer over it
07:00:09 <phaazon> Sornaensis: bitemyapp’s one
07:00:16 <phaazon> or LYAH
07:00:24 <phaazon> (Learn You A Haskell)
07:00:31 <bitemyapp> @where book
07:00:31 <lambdabot> http://haskellbook.com/
07:00:34 <bitemyapp> Sornaensis: ^^
07:00:38 <Sornaensis> thanks
07:00:41 <bitemyapp> Sornaensis: that's the book my coauthor and I are working on.
07:00:57 <bitemyapp> Sornaensis: can answer questions about it if you have any, but there's a FAQ and a detailed description of what each chapter covers on the website.
07:00:58 <phaazon> bitemyapp: do you plan a paper release at some day? :)
07:01:14 <bitemyapp> phaazon: that's covered in the FAQ.
07:01:48 <isweet> phaazon: not quite sure what you mean, but I'll read up on MonadIO
07:02:22 <phaazon> isweet: it’s just a general IO
07:03:56 <Sornaensis> early access books huh
07:04:09 <bitemyapp> Sornaensis: don't let early access mislead you
07:04:21 <bitemyapp> Sornaensis: it's quite a lot and quite a bit more edited and refined than you'd think
07:04:36 <bitemyapp> Sornaensis: but the book has taken so long to write, we started offering it for sale before it was 100%
07:04:52 <bitemyapp> Sornaensis: it's about 80-85% done at the moment. 26 chapters.
07:05:02 <phaazon> bitemyapp: you should update the progress on the website then
07:05:06 <phaazon> you say 50% ;)
07:05:15 <bitemyapp> phaazon: sigh, dammit
07:05:17 * bitemyapp greps
07:05:20 <phaazon> :P
07:05:29 <bitemyapp> phaazon: where?
07:05:40 <bitemyapp> phaazon: wait you mean the on deck thing?
07:05:44 <phaazon> yeah
07:05:46 <bitemyapp> phaazon: that's not what that is saying dude
07:05:54 <bitemyapp> phaazon: it's talking about the percentage complete of the upcoming material
07:06:02 <bitemyapp> phaazon: 26 chapters in the current release is not 50% done
07:06:16 <bitemyapp> I'll add wording to make this more clear
07:06:38 <bitemyapp> ie, material that is about to go out for release
07:06:44 <Sornaensis> it says 80% on frontpage
07:06:47 <Sornaensis> 1156 pages
07:06:51 <bitemyapp> right and that's what it is at the moment
07:07:24 <bitemyapp> we're not going to write a 52 chapter book :P
07:08:05 <phaazon> should you succeed to release it as a paper version, I’d buy it for sure
07:09:21 <Sornaensis> I would pay $59 for a print version
07:09:28 <phaazon> yeah, for sure
07:10:07 <phaazon> even though I’m more into advanced Haskell now; I’d love to learn more about writing Core plugins
07:10:10 <phaazon> I should learn how to do that
07:10:24 <Sornaensis> what are Core plugins
07:10:46 <phaazon> Sornaensis: GHC’s System F internal language
07:10:56 <phaazon> it’s a super simple lambda calculus language
07:11:06 <phaazon> and you can write Core routines to transform the generated Core
07:11:10 <phaazon> to suit your needs
07:11:25 <Sornaensis> F internal language
07:11:27 <Sornaensis> wuuuut
07:11:35 <phaazon> System F
07:11:39 <phaazon> it’s not really System F
07:11:42 <phaazon> but it’s alike
07:11:49 <Sornaensis> are there any resources about it
07:11:55 <phaazon> yeah
07:12:02 <phaazon> the talk of SPJ at Haskell eXchange
07:12:03 <phaazon> wait
07:12:47 <phaazon> https://skillsmatter.com/skillscasts/6495-keynote-from-simon-peyton-jones
07:13:28 <Sornaensis> I gotta LOG IN?
07:13:31 <phaazon> yeah…
07:13:32 <Sornaensis> what is this 2006
07:13:34 <phaazon> :(
07:13:42 <Sornaensis> is it free
07:13:45 <phaazon> it might be on vimeo or somewhere else
07:13:47 <phaazon> yes it is
07:13:52 <phaazon> but you still have to log in
07:13:53 <bitemyapp> Sornaensis: you're not going to use the book because it's not in print?
07:13:53 <phaazon> that’s a pity
07:15:03 <bitemyapp> Sornaensis: are you a student?
07:15:07 <Sornaensis> I'd wary of spending that much money on a non print book tbqh
07:15:09 <Sornaensis> yea I am
07:15:15 <bitemyapp> Sornaensis: we offer discounts for students
07:15:31 <phaazon> Sornaensis: then have a shoot at LYAH
07:15:35 <phaazon> I learned from that
07:15:36 <bitemyapp> phaazon: no no no
07:15:45 <bitemyapp> phaazon: I will do whatever it takes to get them to use our book
07:15:46 <phaazon> it’s a uber cool online free book
07:15:46 <Sornaensis> yea I've read all the free online stuff hah
07:15:53 <Sornaensis> I'm a haskell intermediate
07:15:56 <phaazon> bitemyapp: huh
07:16:07 <boj> or ignore books and try to absorb it the hard way.  i'm hard headed though, brute force for life
07:16:08 <bitemyapp> Sornaensis: what if I sent you a discount code?
07:16:27 <phaazon> boj: well, for advanced haskell, we don’t have the choice
07:16:31 <phaazon> we learn from here
07:16:37 <phaazon> and online paper / blog entries
07:16:40 <phaazon> papers*
07:16:45 <phaazon> but for getting one’s feet wet…
07:16:53 <boj> that is what i meant
07:16:57 <phaazon> :)
07:17:06 <boj> i don7t recommend it though :)
07:17:27 <phaazon> lyah ?
07:17:44 <phaazon> why? it’s a great source of knowledge and is fun :)
07:17:56 <bitemyapp> it doesn't work well.
07:17:59 <bitemyapp> it has no exercises.
07:18:07 <bitemyapp> it leaves people pretty unprepared to understand or write Haskell.
07:18:12 <Sornaensis> yea
07:18:13 <boj> blindly learning from blogs/resources as a beginner.  i'm scarred for life
07:18:20 <Sornaensis> it's a good intro to the language
07:18:22 <bitemyapp> I understand why it's popular but it's really not enough by far.
07:18:22 <phaazon> bitemyapp: it has exercices
07:18:25 <Sornaensis> RWH has a lot of out of date stuff
07:18:26 <phaazon> and yeah
07:18:28 <bitemyapp> phaazon: mate
07:18:29 <Sornaensis> and confusing annotations...
07:18:39 <phaazon> it doesn’t have the pretention to be more than an introduction to Haskell
07:18:40 <bitemyapp> phaazon: I've run a lot of people through all of the free online material
07:18:45 <phaazon> it’s even a disclaimer on the website
07:18:49 <bitemyapp> phaazon: it's not an introduction...
07:18:57 <phaazon> for sure it is!
07:19:06 <phaazon> it doesn’t even cover lambda calculus
07:19:16 <bitemyapp> that makes it less useful as an introduction, not more.
07:19:24 <phaazon> it’s for people coming from the imperative world
07:19:32 <bitemyapp> it doesn't work well for them either.
07:19:35 <bitemyapp> phaazon: dude, please.
07:19:38 <phaazon> bitemyapp: it worked well on me
07:19:42 <bitemyapp> phaazon: that's n=1
07:19:53 <bitemyapp> phaazon: what you don't seem to understand is that I would've never written a book if I didn't have to.
07:19:59 <phaazon> I guess I’m not as skilled nor badass as you are, but I think I’m a pretty good haskell programmer now
07:20:03 <bitemyapp> phaazon: I would've happily written material for intermediate and advanced instead
07:20:09 <bitemyapp> phaazon: it's not about me being better than you, dammit
07:20:17 <bitemyapp> phaazon: it's about how much time I've spent helping beginners struggle with this
07:20:22 <Sornaensis> right now I'm in a haskell course at my university and I am pretty far and away ahead of the other people in my class and the lecturer, so I'm just looking for a really good book to recommend to people who are into haskell so they aren't trying to piece things together from the flippin' wiki and LYAH and junk
07:20:39 <bitemyapp> Sornaensis: I can give you a coupon code you can share with classmates.
07:20:46 <Sornaensis> bitemyapp: that would be amazing
07:20:49 <phaazon> well go for bitemyapp’s book Sornaensis 
07:20:53 <bitemyapp> Sornaensis: please. It will kill me if they use LYAH/blog diaspora instead of our book.
07:21:02 <phaazon> but I keep thinking LYAH is a good introduction to the Haskell and FPL world
07:21:12 <phaazon> it has nice drawings and the images work well
07:21:22 <phaazon> it’s pleasant to read, I mean
07:21:31 <bitemyapp> Sornaensis: may I query you?
07:21:40 <phaazon> I think writing a new book is good because of how Haskell has changed lately
07:21:51 <phaazon> RWH is far deprecated
07:21:56 * hackagebot ratel 0.1.0 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.1.0 (fozworth)
07:22:00 <phaazon> while it was a good book a few years ago
07:22:12 <bitemyapp> Being old or out of date isn't the biggest problem with RWH, but it is a problem.
07:22:41 <phaazon> bitemyapp: I don’t really understand what you think is wrong about LYAH
07:22:51 <phaazon> even though I can imagine why you’d rather like people reading your book instead
07:22:59 <bitemyapp> jesus man
07:23:06 <bitemyapp> we steered people away from LYAH long before our book was available
07:23:12 <phaazon> why?
07:23:16 <bitemyapp> I'd maintained that guide of free resources for ages
07:23:20 <geekosaur> LYAH is great as a grand our of Haskell. it does not teach you to write Haskell
07:23:24 <geekosaur> *grand tour
07:23:28 <bitemyapp> because it does _not_ work well for any audience for actually learning Haskell
07:23:34 <bitemyapp> it's precisely as geekosaur says. it's a tour.
07:23:36 <bjobjo> I've only gotten through 5 chapters of bitemyapp's book so far, but I can vouch for the assertion that LYAH does not make you capable to write a real program - at least not in my case. And I *like* LYAH
07:23:52 <phaazon> bitemyapp: well, that has a definition then
07:23:55 <phaazon> introduction.
07:24:00 <bitemyapp> that's not what an introduction is
07:24:02 <phaazon> an introduction doesn’t teach you how to use something
07:24:12 <bitemyapp> an introduction _does_ teach and LYAH doesn't do that.
07:24:13 <phaazon> bitemyapp: that’s what an introduction should be. a tour of topic
07:24:15 <Sornaensis> bitemyapp: yes go ahead
07:24:50 <bitemyapp> phaazon: http://bitemyapp.com/posts/2014-12-31-functional-education.html
07:24:55 <chelfi> all of my beginner friends interested in haskell are going through LYAH right now ^^
07:25:06 <bitemyapp> phaazon: https://www.youtube.com/watch?v=Bg9ccYzMbxc
07:25:09 <chelfi> no idea what they are thinking of it so far though
07:25:15 <phaazon> chelfi: that’s good, especially for people coming from C/C++/C#/Java
07:25:22 <phaazon> even from python or Javascript or whatever
07:25:22 <bitemyapp> It's not.
07:25:28 <bjobjo> I'm from C/C++ :(
07:25:30 <bitemyapp> phaazon: why do you ignore expertise?
07:25:39 <phaazon> ignore?
07:25:47 <bitemyapp> phaazon: I've spent years figuring out how to teach people Haskell effectively and I tried for ages to make the free materials like LYAH work.
07:25:53 <phaazon> I am not ignoring it, I said that I know you are more skilled and so than me
07:26:09 <bitemyapp> but you're not taking anything I say seriously
07:26:30 <bitemyapp> chelfi: if they won't buy a book, there are better free resources than LYAH.
07:27:12 <phaazon> bitemyapp: I am, but you are very hm
07:27:17 <ggVGc> I feel LYAH approaches the topic in a very strange way
07:27:20 <phaazon> I don’t know how to say that in English as I’m French
07:27:26 <phaazon> I’d say, hm
07:27:29 <ggVGc> you have to be pretty interested in haskell already to stick with it
07:27:34 <infinity0> it's a useful introduction, but it doesn't teach you to really get to know it, and really deeply why it's useful
07:27:48 <infinity0> in my experince, to do that you need to play around, in your own unsupervised time, with a lot of programming examples
07:27:50 <phaazon> you seem to be very upset and almost arrogant
07:27:51 <merijn> I think it's just nostalgia
07:27:59 <infinity0> and see why the higher-level stuff makes your code shorter and easier to understand eventually
07:28:07 <merijn> For some reason I really like LYAH, but that's probably because that's how I learned
07:28:14 <merijn> But, objectively, it's pretty bad
07:28:18 <infinity0> it is understandable for beginners to be frustrated at overly-abstract stuff and i was like that in first-year uni
07:28:25 <merijn> At least, nowhere near how I would teach people Haskell
07:28:26 <bitemyapp> phaazon: here, listen to merijn 
07:28:41 <phaazon> merijn: “people” is vague
07:28:41 <merijn> Which leads to some cognitive dissonance, because I don't understand why I like it :p
07:28:48 <phaazon> I think LYAH is great at catching attention
07:28:55 <merijn> phaazon: Undergrad CS students
07:28:59 <phaazon> CS?
07:29:03 <phaazon> C#?
07:29:05 <jackhill> It doesn't look as if y'all are going to be able to come to a consensus here (unfortunately). Maybe it's time to move on to another topic?
07:29:07 <infinity0> cs = computer science
07:29:10 <merijn> phaazon: Computer Science
07:29:18 <phaazon> ah ok, I thought you’d say IT (what’s the difference?)
07:29:29 <boj> jackhill: agreed
07:30:02 <merijn> phaazon: You said "people" is vague, so I clarified that it's not how I would teach students, although if not students, who WOULD you teach like LYAH?
07:30:07 <infinity0> phaazon: what's your background and/or context for this topic? seems strange you're not familiac with the "CS" acronym
07:30:21 <phaazon> merijn: people who have no idea what functional means
07:30:32 <phaazon> people used to write C code for ages
07:30:34 <merijn> phaazon: CS undergrads don't have a clue what functional means
07:30:37 <Ferdirand> the difference is that you can study CS without ever using a computer :D
07:31:06 <phaazon> infinity0: simple
07:31:08 <phaazon> I’m French 
07:31:11 <phaazon> :)
07:31:27 <merijn> People who wrote C for ages are probably considerably more advanced than most CS students >.>
07:31:31 <bitemyapp> phaazon: I care about this because I've been trying to make Haskell easier for people to get into.
07:31:34 <phaazon> merijn: yeah
07:31:38 <chelfi> bitemyapp: I suspect they have actually bought LYAH
07:31:41 <phaazon> I’m not talking about experience 
07:31:48 <phaazon> I’m talking about distance to the FPL world
07:31:49 <bitemyapp> chelfi: I'd give up a kidney to get them away from that.
07:31:51 <Ferdirand> french is treacherous because we have a single word for computer science and computer technology
07:31:53 <bitemyapp> phaazon: LYAH harms this cause because it distracts people from better resources.
07:32:03 <phaazon> I think new students are nearer to FPL than old C programmers
07:32:05 <bitemyapp> phaazon: I have lost too many damn hours to people set adrift by bad resources.
07:32:09 <merijn> I think LYAH deserves respect for being the first attempt to make haskell accessible, and being miles ahead of the competition at the time
07:32:17 <bitemyapp> It does deserve credit for that.
07:32:26 <bitemyapp> Gentle Intro to Haskell wasn't.
07:32:41 <merijn> But that doesn't mean it should keep being touted as the best book :)
07:32:45 * geekosaur would like to note that he has not looked at bitemyapp's book; just had to try to help an endless procession of newcomers left confused by LYAH
07:32:46 <merijn> @quote gentle.intro
07:32:46 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
07:32:50 <merijn> hmmm
07:32:53 <merijn> Wrong quote
07:33:02 <boj> maybe more effort should be put forth into showing where the good resources are?
07:33:14 <bitemyapp> boj: I made a guide
07:33:15 <merijn> @quote brend gentle
07:33:15 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
07:33:17 <bitemyapp> boj: people ignored it
07:33:21 <merijn> @quote Brend gentle
07:33:21 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
07:33:23 <geekosaur> (also Gentle Intor worked for me --- but I'd been exposed to both FP in general and SML in particular beforehand)
07:33:23 <phaazon> seems to
07:33:38 <bitemyapp> boj: this recommends free resources - https://github.com/bitemyapp/learnhaskell
07:33:42 <boj> bitemyapp: sure, which means it hasn't be adopted by the community as a good resource
07:33:51 <boj> i've definitely gone through it
07:33:51 <bitemyapp> boj: I maintained this and tested different curricula with learners.
07:34:03 <bitemyapp> boj: none of it really worked nearly as well as our book.
07:34:13 <bitemyapp> especially for the earliest parts.
07:34:20 <bitemyapp> or...some of the later bits too. hrm.
07:34:27 <phaazon> so should I deduce I learn Haskell the wrong way?
07:34:32 <phaazon> learned*
07:34:41 <boj> bitemyapp: yet people (unfortunately from your point of view) keep referring to LYAH.  curious why that is
07:34:55 <dramforever> It
07:35:01 <merijn> bitemyapp: Maybe you should include Apfelmus' lazy evaluation tutorial? Not sure if the things it covers are covered elsewhere in your resources. But my quick scan over it made me think it was fairly solid
07:35:18 <boj> it was first, for sure.  clearly not the best.  free, with a buy the paper option?  has character?  accessible?
07:35:21 <dramforever> ouch, wrong place to put that :P
07:35:23 <merijn> phaazon: Not necessarily the "wrong" way as much as the "harder than necessary" way
07:35:27 <lokien_> bitemyapp: hey, shh, what are "good free learning resources"? I'd buy your book, but I'm poor
07:35:44 <phaazon> I think it’s biased anyway
07:35:52 <infinity0> i think people defending LYAH are getting the wrong point of the argument. you won't quite "get" why LYAH is not a good resource until you've gone through the other resources, just read the blog post bitemyapp linked to earlier above
07:36:11 <merijn> bitemyapp: https://hackhands.com/guide-lazy-evaluation-haskell/ it was the simplest stuff I could find for people wanting to learn operational/performance intuition for Haskell without going straight for the STG paper
07:36:14 <infinity0> i have a copy of LYAH and it's not the greatest. i wouldn't call it "bad" but yeah there are quicker ways to learn "deeply"
07:36:31 <phaazon> infinity0: you just introduced deeply
07:36:37 <phaazon> none of us used that word before
07:36:50 <phaazon> anyway
07:36:52 <infinity0> and i think bad/good is not a great way to discuss this topic, but rather how quickly you learn how much
07:36:57 <bitemyapp> lokien_: no
07:36:57 * hackagebot hedis 0.7.0 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.0 (k_bx)
07:37:01 <phaazon> I trust bitemyapp and that’s why I recommend his book in the first place
07:37:04 <phaazon> then talked about LYAH
07:37:04 <bitemyapp> lokien_: if you're poor I'll just give you a free copy
07:37:20 <bitemyapp> lokien_: email us http://haskellbook.com/support.html
07:37:23 <lokien_> bitemyapp: wha- really? 
07:37:23 <infinity0> by "learn deeply" i mean roughly "grok" https://en.wikipedia.org/wiki/Grok http://www.catb.org/jargon/html/G/grok.html
07:37:27 <bitemyapp> lokien_: yes. email us.
07:37:33 <infinity0> LYAH can teach haskell syntax but not haskell ways of thinking
07:37:47 <phaazon> infinity0: yeah, as it’s an introduction!
07:38:07 <infinity0> yeah but it's also like 600 pages long :p i'd rather spend my time with more efficient resources
07:38:13 <phaazon> from that perspective, for sure it’s not as good as bitemyapp’s book!
07:38:21 <infinity0> it's good to skim over though, and to refresh your memory if you haven't done haskell in a few years
07:38:25 <phaazon> I don’t recommend LYAH as a “Haskell book”
07:38:33 <Clint> you recommend it as a comic book?
07:38:34 <phaazon> I advise people to read it to “get an idea of what Haskell is”
07:38:43 <phaazon> Clint: a porn manga
07:38:46 <Clint> oh my
07:39:09 <infinity0> bind and inject baby
07:39:35 <doudou> bitemyapp: i followed the link http://bitemyapp.com/posts/2014-12-31-functional-education.html as i dont know anything about haskell, and as it has a very good reputation, i wonder the article is pretty heavy, did haskell wrote it himself?
07:39:43 <phaazon> anyway, I don’t want to upset bitemyapp as I think he and argumatronic do a really good job with their book
07:39:54 <lokien_> bitemyapp: how to entitle it? I can't think of a title that's not forcing/stupid
07:39:58 <phaazon> and I’d love to buy a print copy of it
07:40:12 <bitemyapp> doudou: what?
07:40:13 <phaazon> lokien_: “gimme da book”
07:40:29 <bitemyapp> lokien_: just say you're lokien from IRC and that you'd like to use the book but can't afford it.
07:40:33 <bitemyapp> lokien_: don't gotta be fancy
07:40:34 <doudou> the article was automatically wrote by haskell?
07:40:45 <phaazon> doudou: I guess bitemyapp wrote it
07:40:45 * Clint squints.
07:40:46 <lokien_> phaazon: :)
07:40:53 <lokien_> bitemyapp: okay, I love you
07:41:00 <phaazon> I marry you
07:41:27 <phaazon> bitemyapp: so what do you recommend as a first approach to Haskell?
07:41:36 <phaazon> beside from your book, of course
07:41:38 <phaazon> which is not free
07:41:46 <phaazon> a free online material resource
07:41:51 <bitemyapp> lokien_: you can show me how much you love me by using the book :)
07:41:58 <doudou> phaazon: there are too many words, for a human have wrote it
07:42:03 <bitemyapp> lokien_: I'll let Julie know she has a not-so-secret admirer too
07:42:15 <phaazon> doudou: well bitemyapp is not human ;)
07:42:15 <bitemyapp> doudou: I wrote it manually, myself.
07:42:18 <lokien_> bitemyapp: is she single?
07:42:22 <bitemyapp> phaazon: correct, I am FP bear
07:42:26 <phaazon> haha :D
07:42:28 <bitemyapp> lokien_: no, she's a home-schooling mother of two. Sorry :(
07:42:38 <doudou> bitemyapp: you have super powers
07:42:45 <lokien_> bitemyapp: well, can't have it all at once :(
07:43:01 <lokien_> bitemyapp: does she have a daughter? 
07:43:01 <doudou> i will read it slowly so
07:43:03 <lokien_> :D
07:43:04 <bitemyapp> I'm just diligent
07:43:07 <bitemyapp> lokien_: no, two sons.
07:43:17 <sm> lokien_: inappropriate
07:43:22 <lokien_> bitemyapp: oh, well.
07:43:43 <phaazon> lokien_: why such a question? :D
07:44:01 <lokien_> sm: sorry, I am just.. happy and surprised. I'll calm myself down.
07:44:31 * dramforever is interested in the discussion. the Haskell book one, NOT the "marrying" one
07:44:37 <phaazon> :D
07:44:43 <lokien_> phaazon: I'm still in high-school, we ask questions like that
07:45:25 <phaazon> oh gosh
07:45:33 <phaazon> I won’t enter the cliché debate, please :D
07:46:07 <dramforever> After some time going through all the random materials, I feel that I've been spoiled with a knowledge base that is too deep to be put into usr
07:46:09 <dramforever> use
07:46:10 <phaazon> how old are you lokien_?
07:46:19 <lokien_> phaazon: 17
07:46:23 <phaazon> neat :)
07:46:30 <phaazon> happy to see young people around
07:46:35 <lokien_> still braindead, sadly
07:47:13 <sm> lokien_: I understand :) we have to be a little more careful here
07:47:50 <lokien_> sm: I feel like I spent way too much time in #lua
07:48:14 <phaazon> who is @mmirman on twitter?
07:48:22 <lokien_> Why did you stop talking about books? Now I'm sad.
07:49:00 <phaazon> because it’ll eventually get on bitemyapp’s nerves I guess, and I apologize for that; you have all my love bitemyapp <3
07:49:39 <bitemyapp> phaazon: <3
07:49:41 <bitemyapp> @karma+ phaazon
07:49:41 <lambdabot> phaazon's karma raised to 2.
07:49:45 <dramforever> Let me talk about books. Well, sort of. When I saw the planned contents of the haskellbook, I find myself having read a post or two on almost each of the concepts, yet I feel I do not know enough to put any of the knowledge to use
07:49:48 <phaazon> wouhou
07:49:51 <phaazon> such karma!
07:49:55 <phaazon> I should talk more here :D
07:49:59 <phaazon> thanks bitemyapp :)
07:50:01 <lokien_> bitemyapp: sent, not too fancy. would you mind some fan arts in the future though?
07:50:11 <bitemyapp> lokien_: Julie says hi btw
07:50:22 <bitemyapp> lokien_: we are all about art, so fan art would be awesome :)
07:50:25 <lokien_> bitemyapp: hey Julie :)
07:50:39 <lokien_> bitemyapp: neat!
07:51:14 <phaazon> dramforever: like which concepts?
07:51:27 <phaazon> a chapter that would interest me in Haskell Book is the one about IO
07:51:33 <phaazon> I’ve read some GHC internal code about it
07:51:34 <phaazon> but hm
07:51:41 <phaazon> I’m not sure at all of what I read :D
07:51:57 <mitchty> IO is black magique
07:51:58 <merijn> dramforever: I just spent a lot of time hacking together neat (albeit somewhat useless) things just to see how far I could push various extensions and that's help solidify things a lot for me
07:52:06 <phaazon> it’s like a hugh algebraic data, but it’s not
07:52:49 <merijn> phaazon: What do you want to understand about it?
07:53:21 <merijn> There's the abstract meaning of IO and there's the concrete way GHC implements things, these two are orthogonal and you shouldn't have to know the latter
07:53:22 <phaazon> merijn: basically, how it translates to bare machine code
07:53:44 <phaazon> for instance, I often wonder whether readIORef translates to dereferencing a pointer
07:53:49 <kqr> you really shouldn't have to know the former either, but it helps when trying to generalise your knowledge
07:53:51 <phaazon> or an adress, whatever you’d like to call it
07:54:01 <dramforever> roughly from least familiar to more familiar: IO, non strictness, the common structures (no intuition for me at all)
07:54:02 <monochrom> reading internal code does not help you distinguish desired external behaviour from accidental clever implementation tricks.
07:54:03 <merijn> phaazon: IO just enforces a certain sequencing (see the Lazy Functional State Threads paper) for how it does this
07:54:31 <phaazon> dramforever: hm
07:54:50 <phaazon> I thought you were a Haskell guru!
07:54:54 <kqr> phaazon, things like that may depend on optimisations triggered and such. if you really want to know how something is executed in a particular build, read the core/stg/c--
07:54:56 <merijn> phaazon: In the actual code generation IO doesn't really exist so much. Some primitives are build into GHC and those generate code, the rest is "just" haskell evaluation
07:54:58 <phaazon> I’ve seen you around for a while
07:55:13 <merijn> dramforever: What do you mean by "common structures"?
07:55:22 <phaazon> I guess State, Reader, Writer
07:55:22 <bitemyapp> lokien_: check your inbox :)
07:55:42 <doudou> bitemyapp: i went slowly in the beginning of the article because there where too much about humans, feelings, learning, failling, many things that does not have mean except that haskell is different. But after you give links to courses and that seem very helpful.You could put an example of a feature you like in haskell, but this may be impossible because before play we need to master some step. thanks for your help
07:56:40 <dramforever> of course, since I do not program professionally, I have problems making "real projects" like using "stack new" or something
07:56:48 <tekkkz> hi
07:56:49 <tekkkz> at the first example of tagsoup using HTTP (https://github.com/ndmitchell/tagsoup) why can't I save the page of the url url = "http://bulbapedia.bulbagarden.net/wiki/" ++ pkm ++ "_%28Pok%C3%A9mon%29" but from something like google it works?
07:57:23 <dramforever> merijn: those typeclasses like Traversable, Applicative, etc
07:58:01 <nitrix> tekkkz: I'm not exactly sure what the question is about, but have you tried with a url that has no % signs due to urlencoding?
07:58:06 <kqr> tekkkz, what does it mean to be unable to "save the page"
07:58:13 <merijn> dramforever: The way to learn is to invent "weird" datatypes and see if you can make lawful instances and, if not, why not
07:58:13 <phaazon> dramforever: I think I never use stack new
07:58:17 <phaazon> I sometimes use stack init
07:58:24 <phaazon> or I write the stack.yaml manually
07:58:32 <tekkkz> nitrix, sure, this works, like i said, google.de worked
07:58:41 <dramforever> phazoon: i never knew
07:58:46 <tekkkz> kqr, the saved file is 0bytes large
07:58:51 <nitrix> Then presumably the library doesn't support urlencoding.
07:59:03 <phaazon> dramforever: stack is a very nice tool and playing with resolvers is pretty easy :)
07:59:35 <lokien_> bitemyapp: thank you very much :)
07:59:45 <dramforever> yep, guess I just need more work to get used to it
07:59:57 <geoffreyiy> @pl (\(xp,yp) -> (f xp, f yp))
07:59:58 <lambdabot> f *** f
08:00:00 <dramforever> i was happy about the resolver feature so far
08:00:06 <ggVGc> stack basically makes haskell useable for real projects
08:00:50 <hodapp> citation: I used stack on a real project with Haskell.
08:01:09 <dramforever> Hmm... As I talk about this, I think my worries boils down to the gap between those concepts and "real-world" problems
08:01:46 <merijn> dramforever: Have you seen digestive functors? They're a nice example of applying "those concepts (i.e. applicative) to a real-world problem
08:02:18 <kqr> tekkkz, there's something about bulbagarden.net
08:02:21 <kqr> tekkkz, same thing happens with curl
08:02:28 <dramforever> that's like exactly what's worrying me!
08:02:29 <tekkkz> kqr, yeah okay... but what?
08:02:40 <merijn> dramforever: See http://groups.inf.ed.ac.uk/links/papers/formlets-essence.pdf
08:02:50 <merijn> dramforever: OCaml instead of haskell, but should be readable
08:03:11 <merijn> dramforever: Basically "how to make web form validation not suck using applicative"
08:03:30 <dramforever> all sorts of "abstract nonsense". Yes, I can write a huge amount of mathematically beautiful code with haskell
08:03:54 <tekkkz> kqr, any idea what it could be/ what i could do now?
08:04:29 <dramforever> but no, I find myself unable to find the "aha" moments when I realize that Haskell's watomorphisms could be used for this blah blah blah
08:04:30 <ggVGc> none of my haskell is mathematically beautiful
08:04:36 <ggVGc> it's just functions and data, as any other language
08:04:43 <ggVGc> just with a better type system for the data
08:04:48 <ggVGc> it's all what you make of it
08:04:55 <merijn> dramforever: You mean like recursion schemes?
08:05:09 <dramforever> merijn: yep, one of them
08:05:14 <merijn> IMO recursion schemes complexity to usability ratio is way off
08:05:26 <dramforever> and perhaps lens
08:05:30 <merijn> I would not recommend studying them to anyone until they've exhausted a billion more interesting topics
08:05:35 <mmachenry> dramforever: The idea that functional languages are mathematically beautiful but not practical is largely a myth. Beauty in programming and practicality are often see to be opposites when I have no idea how people back that up.
08:05:39 <merijn> Lens is far more accessible than recursion schemes
08:06:11 <dramforever> mmachenry: I did not say they are opposites
08:06:15 <ggVGc> you can write most projects in haskell just using simple ADTs and functions, without anything fancy, and it'll be great, and you'll solve real world problems
08:06:18 <ggVGc> anything else is just extra
08:06:30 <tzaeru> mmachenry, I guess people associate beauty in programming with such things as comprehensibility, elegancy and simplicity, all things which you throw out the window in real world scenarios, where it's "hey, client asked this and they are going live in 5 hours, so lets do it."
08:06:34 <mmachenry> dramforever: You may not have but it's a common implication. 
08:06:51 <dramforever> I just said what *I* *seem* to be feeling
08:07:05 <dramforever> which, as you said, is likely wrong
08:07:17 <tzaeru> I guess some super-humans can actually make beautiful code under such time restrictions and stress, but I for sure can not, so most of the time I do mediocore code that spaghettifies quickly.
08:07:18 <mmachenry> tzaeru: Yeah, could be why. However, that's conflating language design with programmer practice. I think I can hack out crappy code in a functional language fast. I have in fact. 
08:07:21 <ggVGc> tzaeru: but the point is that you can write haskel that way just as you can write any other language that way. and I have
08:07:24 <ggVGc> and you have
08:07:29 <ggVGc> and everyone who's done anythig in haskell has
08:08:02 <tzaeru> ggVGc, yeah, it's definitely not a case about languages as much as it's a case about deadlines and so .)
08:08:03 <phaazon> ggVGc: I think I’m having a seizure trying to speak your nick out loud :D
08:08:05 <tzaeru> *:)
08:08:09 <tzaeru> everything looks fugly when done under stress.
08:08:19 <dramforever> ggVGc: I guess so, but it does not seem to be the case for me
08:08:32 <dramforever> I'm looking to fix this
08:08:38 <merijn> phaazon: "Scrap the entire document" :p
08:08:40 <ggVGc> tzaeru: the thing for me is that spaghetti haskell at least has a very strong type system under it, so it's much easier to unspaghetti at some later arbitrary time
08:08:44 <ggVGc> if needed
08:08:49 <phaazon> merijn: :D
08:09:23 <tzaeru> but mostly I meant that as my take on practicality and beautifulness often seen as opposites in programming..
08:09:28 <dramforever> like I said I feel spoiled
08:09:30 <ggVGc> dramforever: why don't you just use ADTs and functions and lists, and ignore every other feature? You'll get practically anything you want to do done, and when you want to make something in a better way you can maybe find a feature filling that gap.
08:09:39 <ggVGc> at worst haskell is just a typed javascript, which is good enough
08:09:42 <ggVGc> for anything
08:10:09 <merijn> I write loads of ugly shell scripts in haskell :p
08:10:11 <dramforever> I used to be able to just work with an idea and go "wheeeee" and output a bunch of code
08:10:35 <ggVGc> saying haskell can't be used for practical things is a bit like saying you can't write any C++ without metaprogramming all your program in templates
08:10:57 <dramforever> with Haskell I seem stuck at every step, thinking: "I saw this foobafunctors in the category of lolmorphisms, can it be used?"
08:11:00 <tzaeru> ggVGc, mh yea, about that... ^^
08:11:01 <merijn> ggVGc: That last bit is true :p
08:11:22 <mniip> which reminds me
08:11:42 <ggVGc> dramforever: why don't you just ignore that and finish your task instead
08:11:43 <mniip> there was some fancy snipped of code that nondeterministically applied a function to each element of a list
08:11:51 <mniip> snippet, even
08:12:01 <ggVGc> snipped snippet
08:12:02 <dramforever> IIUC If I work with maths that's exactly what I should do
08:12:29 <mniip> think f, [a, b, c] -> [[f a, b, c], [a, f b, c], [a, b, f c]]
08:12:51 <mniip> it used some lens feature that is no longer there in recent versions I think
08:13:01 <ggVGc> dramforever: you should attempt using hasjell for a project that you are more interested in getting done than writing. And push yourself to finish it. THen you'll see how you just ignore all the fanciness that you have yet to learn, and just solve your program with the tools you have
08:13:05 <nitrix> Seems trivial to implement, afaik.
08:13:06 <ggVGc> and it'll still be great
08:13:27 <dramforever> ggVGc: I guess I see
08:13:52 <bitemyapp> lokien: :)
08:13:58 <ggVGc> having too much time to do something is a great way to never actually do it
08:14:08 <merijn> ggVGc: Having too little is too :p
08:14:13 <ggVGc> merijn: not sure
08:14:15 <bitemyapp> doudou: I don't think Haskell features are relevant in that particular post
08:14:38 <ggVGc> merijn: if you've started and have too little time to finish it, but you have to, chances are you'll find a way
08:14:47 <ggVGc> that's how work works
08:14:50 <dramforever> and the balance is when you just keep typing typing typing and you finish in time?
08:15:19 <nitrix> dramforever: The "problem" with haskell is that you have many levels of understanding; and you can go pretty deep (if not near infinitly deep) learning all the small things if you don't restrain yourself.
08:15:32 <dramforever> yeah
08:16:10 <ggVGc> dramforever: my current example is that I really want a specific type of midi sequencer that I've had in my head for years, and I started writing it in haskell. I really have no interest in actually writing the program, but I really want the sequncer for some music I'm going to make. I don't know much advanced haskell, but I've been programming for 10 years and I'm soon done with my sequencer, without much 
08:16:16 <ggVGc> fanciness at all
08:16:17 <nitrix> A high-level understanding will get you just as far. The difference is between accepting things for what they are (like monadic laws) or understanding the why behind them.
08:16:31 <ggVGc> there are tons of ways I could improve tis code and make it more concise and beautiful
08:16:35 <ggVGc> but that's irrelevant
08:16:40 <ggVGc> since the product is actually what matters
08:16:43 <lokien> bitemyapp: what is this "irc channel you've made for beginners"? by the way, I was primarily writing python and clojure too!
08:17:00 <bitemyapp> lokien: #haskell-beginners
08:17:10 <dramforever> so I guess
08:17:14 <bitemyapp> lokien: it's not really exclusively for beginners though. It's just more exclusively focused on teaching/learning.
08:17:19 <tzaeru> one thing that stops my learning of haskell almost every single time, is looking into code of the modules I want to use.
08:17:19 <bitemyapp> lokien: advanced topics come up too.
08:17:22 <tzaeru> it gets cryptic every time :S
08:17:27 <dramforever> as the problem is described, so is a solution
08:17:35 <lokien> bitemyapp: thanks, I'll join :)
08:17:39 <dmj`> tzaeru: which modules?
08:17:59 <tzaeru> dmj`, last time it was.. hm. need to rumble my memory box a second
08:18:00 <nitrix> lokien: #haskell-beginners, but I must advise you on behalf of other people here that asking beginner questions here is just as fine, if you explicitly mention you're a beginner. The difference is the assumption people might make about your skills, that's all.
08:18:09 <ggVGc> dramforever: I didn't mean I've been working on this for 10 years. what I meant is with that knowledge and some basic haskell knowledge, I can just hack up a working program, benefiting from the basic features of haskell
08:18:20 <ggVGc> there's no need to make everything amazingly perfect to get a product
08:18:21 <dramforever> 1. see what others are doing, 2. get things done rather than done right in the wrong way
08:18:27 <ggVGc> that's how you end up in non-real-world use lad
08:18:29 <ggVGc> land*
08:18:36 <tzaeru> maybe 'JuicyPixels'!
08:19:09 <nitrix> lokien: Equally, there's advanced discussions in #haskell-beginners as well when they explicitly mention that they are comfortable about given subjects.
08:19:22 <dramforever> ggVGc: :) I'd like to give you big thanks for your long responses
08:19:24 <lokien> nitrix: yeah, I won't abandon regular channel
08:19:40 <ggVGc> I think the issue is that haskell is very much a research platform, where normal users also exist. SO it's easy to get dragged into the research-ness of haskell and miss out on actually using the language for work
08:19:54 <dramforever> And thanks to the whole channel too, you've been really friendly :)
08:20:03 <ggVGc> tyis is a pretty friendly channel
08:20:06 <ggVGc> mostly
08:20:09 <doudou> bitemyapp: i understood this article as promoting haskell use. In ideal world haskell will be a game like a puzzle with many levels to acheive, and then we will be able to program with it. I thought that presenting a feature that please you much help people understand why you find haskell to your taste. It is nice to warn that it is different and we cant come from another langage and transpose way of thinking easily, explain that th
08:20:43 <frontendloader> What's the latest blog post/guide that can try to teach me what a monad is :(
08:20:53 <frontendloader> I am a beginner
08:20:55 <bitemyapp> doudou: I don't really do Haskell advocacy per se. I prefer to work with people already convinced they want to learn and instead focus on how to make that smooth.
08:21:04 <bitemyapp> doudou: there are tons of advocates already. Not enough helpers.
08:21:24 <frontendloader> a monad is just a monoid in the category of endofunctors has no meaning to me
08:21:29 <bitemyapp> frontendloader: it doesn't need to.
08:21:30 <nitrix> frontendloader: This isn't a good tutorial about monads, but it's "good enough" to start and break the ice: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
08:21:39 <dramforever> :) IMHO (trying to) "easily transpose way of thinking" is like THE problem of haskell newcomers
08:21:44 <bitemyapp> frontendloader: it's not a helpful explanation by itself and it requires a lot of context not directly apropos to Haskell.
08:22:01 <ggVGc> dramforever: you should maybe take a look at Elm. It's a langauge very much based on haskell, but with just the basics of what's needed for a pure functional language. I wrote a small game in it, and it gave me a very good perspective on what features of haskell are actually the foundations that you can build an entire piece of software on, and what things are advanced research topics that are cool but not 
08:22:06 <frontendloader> thank you!
08:22:07 <ggVGc> necessary
08:22:20 <nitrix> frontendloader: It'll at least remove the fear and give you a (admitedly weak) mental model so that you can dig more into the subject.
08:22:24 <dramforever> but I somehow threw that thinking away, without picking much else up :/
08:22:25 <doudou> bitemyapp: but you help mucjh having collected all this links, much more than any promoter with words ideas and nothing solid
08:22:53 <dramforever> ggVGc: Thanks for that, noted
08:23:35 <doudou> bitemyapp: you help me, all i wanting to say is only feedback about what i felt, i can be stupid or useless. thanks
08:24:50 <dramforever> ggVGc: Ah, so the idea is: Stay hungry (for more knowledge), Stay foolish (when working) :)
08:25:04 <dramforever> how relevant...
08:25:22 <bitemyapp> doudou: well, thank you, but I don't know precisely what you want. And even if I did, I'm not sure I'm the person to provide it.
08:25:23 <ggVGc> dramforever: that's a very good summary of what I'm saying yes
08:25:35 <bitemyapp> doudou: I have a full time job in addition to the book, training, and other things we do. I just don't have much time.
08:25:48 <dramforever> thanks again for all your help, gotta go :)
08:26:33 <ggVGc> dramforever: what I often do is when I'm working on a task, and feel "man there has to be a better way", instead of delving into finding that better way, I write it in a text file, and then I finish my task in the way I know how to. Then at some later point when I'm in research mode I look up the thing I thought about
08:26:39 <ggVGc> it's all about focus and context
08:31:12 <doudou> bitemyapp: i do not ask something, only tell what i felt reading, mainly thanks. what i know is we can recognize items 50 times more than we can recall in memory item, that pleasure make ten time things done than hard work. but i may be plenty of mistake. And i love the idea that when question is stupid, or when nobodies knows answer there is no answer at all. So we can work on our question.
08:32:04 <bitemyapp> doudou: :)
08:33:25 <orion> < bitemyapp> doudou: there are tons of advocates already. Not enough helpers. <-- Teaching others requires a level of mastery above any beyond what most people can achieve.
08:33:43 <merijn> I don't think so
08:33:49 <merijn> You can learn a lot teaching people
08:34:05 <bitemyapp> including how much you don't know
08:34:43 <orion> For example, I refrain from helping people on this channel because I don't feel competent enough.
08:34:59 <orion> For me, the worst thing you could possibly do is tell someone wrong information.
08:35:26 <tekkkz> what is ~/= in dropwhile doing?
08:35:35 <mniip> that's why there's always plenty of people here who will happily nitpick on anything you say :D
08:35:57 <merijn> orion: Oh, when I just started I would just answer anything I felt I had an inkling of an idea and relied on others to correct my mistakes
08:36:04 <merijn> That's the entire value of having a channel like this
08:36:08 <orion> mniip: At the cost of my reputation.
08:36:09 <bitemyapp> Sornaensis: <3
08:36:44 <bitemyapp> mniip: which is true enough, but the noisiness and confusion that erupts when it happens is partly why we splintered away.
08:37:03 <ggVGc> merijn: agreed
08:37:03 <bitemyapp> mniip: it's not that we don't want people to learn to teach (we welcome new helpers) but most don't know how to intervene constructively
08:37:13 <Sornaensis> aye, thanks
08:37:21 <mniip> bitemyapp, oh no I don't mean nitpicking is a bad thing
08:37:23 <bitemyapp> okay that's two people setup with the book today.
08:37:33 <bitemyapp> mniip: well, I'm not saying it's good or bad. It depends on how it's done.
08:37:53 <tekkkz> bitemyapp, what is ~/= in dropwhile doing? in refenrence to tagsoup
08:37:57 <bitemyapp> but the issue is that the channel is so large and informal that it usually leads to level 50 tetris and a confused beginner
08:38:14 <bitemyapp> tekkkz: is the unicode intentional?
08:38:23 <tekkkz> what?
08:38:50 <mniip> level 50 tetris >.>
08:38:54 <orion> Moreover, you could be a Haskell expert and a lousy teacher.
08:39:03 <ggVGc> level 50 is nothing
08:39:09 <ggVGc> not even invisible
08:39:16 <bitemyapp> tekkkz: I don't have any context for your question
08:40:00 <ggVGc> tbh, "ghc-mod lint" has actually helped me improve my haskell a lot
08:40:09 <ggVGc> by teaching me some rewrites of things I didn't see at first
08:40:21 <ggVGc> like using mapM_ in places I didn't realise at first
08:41:21 <bitemyapp> hlint is handy too
08:41:27 <bitemyapp> don't know what ghc-mod's lint uses though.
08:41:45 <geekosaur> there isn
08:42:04 <geekosaur> isn't a dropWhile in tagsoup. which dropWhile do you actually mean?
08:42:28 <ggVGc> bitemyapp: I think it's actually using hlint
08:46:42 <bitemyapp> ggVGc: suspected not.
08:46:51 <bitemyapp> geekosaur: that's why I'm confused
08:47:01 <bitemyapp> geekosaur: I think they're talking about example code in the README that happens to use a list operation.
08:47:16 <bitemyapp> geekosaur: I don't think they understand what the tag query operators are doing.
08:47:45 <ggVGc> is this terrible? https://gist.github.com/7681486e02c35dad0727
08:48:08 <ggVGc> I feel I overuse  &
08:48:17 <ggVGc> but I like that way of reading
08:48:21 <ggVGc> I feel like I'm missing a trick
08:49:05 <geekosaur> oh, I see it. so if ~== is explained as tag equality ignoring attributes, presumably ~/= is tag *inequality*
08:49:13 <bitemyapp> @pl outEvents & (sequence_ . mapInd (\e ind -> e & mapM_ (send outConn . MidiMessage (ind+1)) ))
08:49:13 <lambdabot> outEvents & (sequence_ . mapInd ((. (mapM_ . (send outConn .) . MidiMessage . (1 +))) . (&)))
08:49:24 <bitemyapp> ggVGc: go for the full monty ^^ lol
08:49:41 <bitemyapp>  . (. (. ) . .  . . ( . . . )) lol
08:50:04 <ggVGc> that's not great..
08:50:08 <ggVGc> and still uses &
08:50:41 <bitemyapp> sorry, was kidding
08:50:57 <bitemyapp> isn't & just the other thing flipped?
08:50:59 <bitemyapp> @ty (&)
08:51:01 <lambdabot> a -> (a -> b) -> b
08:51:06 <bitemyapp> yeah it's $ flipped
08:51:14 <bitemyapp> maybe implicitly less polymorphic
08:51:22 <ggVGc> yes, I was just asking in regards to wat's idiomatic
08:51:48 <ggVGc> I really dislike reading a lambda and then the argument it's being applied to after the parenthese
08:52:51 <phaazon> what the heck
08:53:04 <phaazon> I have a typeclass with an associated type family in there
08:53:12 <phaazon> when writing an instance
08:53:25 <phaazon> I get an error stating that the typeclass doesn’t have such an associated type family
08:53:35 <phaazon> is there something specific to do to import that?
08:53:57 <phaazon> ah nevermind!
08:54:02 <merijn> phaazon: Did you export it/import it?
08:54:11 <phaazon> just the typeclass
08:54:13 <phaazon> forgot the (..)
08:54:16 <phaazon> :P
08:54:17 <phaazon> my ybad
08:54:19 <phaazon> -y
08:54:34 <phaazon> compiles now
08:55:15 <phaazon> hm
08:55:42 <phaazon> is there a way to make compilation fail when an instance doesn’t implement all of a typeclass methods/types?
08:55:54 <phaazon> I thought it was the aim of the MINIMAL pragmna
08:55:55 <phaazon> -n
08:56:42 <merijn> phaazon: No, although -Wall should warn
08:56:51 <merijn> So you could use -Wall -Werror
08:57:09 <phaazon> merijn: I do (-Wall) but I don’t like -Werror
08:57:16 <phaazon> merijn: why isn’t that an error already?
09:00:20 <ggVGc> wnder if I'll ever write a type class
09:00:29 <ggVGc> phaazon: what is your type class?
09:01:05 <phaazon> ggVGc: I use typeclasses to implement loose-coupling
09:01:16 <phaazon> I hesitated for a long time with free monads
09:01:19 <ggVGc> inventing a type class seems like something only research institutions do
09:01:27 <ggVGc> to me
09:01:50 <phaazon> and came to the realization that typeclasses are more flexible, composable and it’s very likely they’re faster at runtime than free monads
09:02:10 <ggVGc> I see
09:02:14 <phaazon> so I define my “syntax” with methods and relations and shit with associated type families
09:02:21 <ggVGc> well, would be intersting to see how that works out down the line
09:02:21 <phaazon> and I implement instances for each intepreters
09:02:29 <phaazon> well
09:02:36 <phaazon> I already have an interpreter
09:02:38 <mniip> come up with a fancy useless monad
09:02:39 <phaazon> I’m migrating the code
09:02:48 <mniip> go the mtl way of typeclassing everything
09:02:50 <phaazon> so I should have an idea very soon
09:02:56 <phaazon> mniip: I like that
09:02:58 <mniip> class MonadFancy m f
09:03:02 <ggVGc> from all I've seen/read using tupe classes ends up being less versatile in usge
09:03:02 <phaazon> MonadWriter, MonadError and so on
09:03:05 <phaazon> it’s very powerful
09:03:13 <ggVGc> but I 'm fairly inexperienced
09:03:27 <mniip> ggVGc, every time you use '==' or 'return' you use a typeclass
09:03:41 <ggVGc> mniip: yes, but not ones I made myswelf
09:03:46 <phaazon> I think I haven’t use “return” for a year or more :D
09:03:57 <mniip> pure?
09:03:59 <phaazon> yes
09:03:59 <ggVGc> how?
09:04:03 <ggVGc> I use return quite a lot
09:04:04 <phaazon> return is just a flaw
09:04:10 <mniip> phaazon has gone pure
09:04:12 <ggVGc> hm
09:04:22 <phaazon> and I use the Monad constraint way less than before
09:04:30 <phaazon> Applicative is often enough
09:04:40 <mniip> yeah
09:04:48 <phaazon> instead of using >>
09:04:49 <mniip> why is StateT not applicative
09:04:51 <phaazon> you can use *>
09:05:03 <ggVGc> I feel I need to use return a lot when doing IO
09:05:04 <phaazon> instead of using liftM, use liftA
09:05:04 <phaazon> etc.
09:05:09 <phaazon> or fmap, simply :D
09:05:12 <mniip> oh wait right
09:05:15 <Cale> I don't think I agree about return being a flaw. I can see how you might think that though, if you really love Applicative.
09:05:20 <phaazon> mniip: it is
09:05:31 <phaazon> Cale: well
09:05:36 <mniip> phaazon, Applicative m => Applicative (StateT s m)
09:05:45 <phaazon> Applicative was discovered after Monad
09:05:54 <phaazon> that’s the single reason I see 
09:06:22 <phaazon> flaw might be a big word, yeah
09:06:32 <phaazon> I’d say that, we shouldn’t use it anymore because of AMP
09:06:51 <phaazon> :t return
09:06:52 <lambdabot> Monad m => a -> m a
09:06:52 <phaazon> :t pure
09:06:53 <lambdabot> Applicative f => a -> f a
09:06:56 <Cale> It certainly has a better name :P
09:07:08 <phaazon> Cale: well, yeah
09:07:11 <phaazon> pure should be named wrap
09:07:23 <Cale> wrap is a terrible name in most instances
09:07:23 <phaazon> or the other one I never remember
09:07:24 <ggVGc> let's just rename Monad to ApplicativePlus
09:07:24 <phaazon> pointed?
09:07:32 <phaazon> :t pointed
09:07:33 <lambdabot> Not in scope: ‘pointed’
09:07:35 <phaazon> :t point
09:07:36 <lambdabot>     Not in scope: ‘point’
09:07:36 <lambdabot>     Perhaps you meant ‘print’ (imported from Prelude)
09:07:40 <phaazon> I don’t remember
09:07:43 <Cale> Most things which are instances of Applicative are also instances of Monad
09:07:59 <phaazon> return is a bad name as well
09:08:04 <phaazon> I think it should be called burrito
09:08:09 <mniip> something something Const
09:08:28 <Cale> return is a great name given what it does in most of the instances of Monad that we actually use
09:08:48 <phaazon> Cale: I think return only makes sense with the do syntactic sugar
09:08:50 <ggVGc> I don't think pure and return are such terrible names actually..
09:08:55 <Cale> i.e. return v produces an action which does nothing except to... well... return v
09:09:12 <phaazon> an “action”?
09:09:13 <kadoban> return is pretty bad given its meaning in … every other language.
09:09:19 <phaazon> Identity has no action
09:09:25 <Cale> phaazon: Yes -- what an action is depends on the monad
09:09:33 <osfameron> pure seems like a worse name to me, if anything
09:09:36 <mniip> identity does have an action
09:09:42 <mniip> it's pretty boring, yes,
09:09:46 <phaazon> mniip: define action please
09:09:51 <Cale> phaazon: But most of the monads we actually *use* are monads consisting of computations or actions of a particular sort.
09:09:53 <mniip> just like id is a function
09:09:54 <Cale> e.g. parsers
09:09:59 <Cale> or IO actions
09:10:07 <phaazon> well
09:10:09 <phaazon> to me
09:10:13 <phaazon> Just 3 is not action
09:10:13 <phaazon> though
09:10:15 <phaazon> :t Just 3
09:10:16 <osfameron> kadoban: XQuery also defines `return` differently (it's the end of an expression, not the whole function)
09:10:16 <lambdabot> Num a => Maybe a
09:10:29 <phaazon> so « return 3 » doesn’t make a sense to me
09:10:33 <mniip> it is a 3 wrapped in a context that says that there could be no value instead
09:10:41 <phaazon> > return 3 :: Maybe Int
09:10:43 <lambdabot>  Just 3
09:10:51 <Cale> Well, you can think of it as an action in the Maybe monad. An action of the Maybe monad either fails (i.e. is the value Nothing), or succeeds, producing some value.
09:11:03 <geekosaur> just rename it eta and have done >.>
09:11:05 <ggVGc> I agree with Cale
09:11:06 <Cale> and Just 3 is the action which succeeds, producing the result 3
09:11:24 <phaazon> Cale: I kinda disagree with that
09:11:29 <ggVGc> geekosaur: I tink all haskell functions should be max 4 letters, as in the good old days of C
09:11:33 <Cale> phaazon: Why?
09:11:37 <phaazon> “result” implies computation, or at least an arrow-ish structure
09:11:45 <phaazon> which is not the case of Maybe
09:11:47 <phaazon> or any monad
09:11:57 <Cale> phaazon: There is a trivial amount of computation involved.
09:12:02 <phaazon> (as it’s * -> *, not * -> * -> *)
09:12:17 <mniip> how is that related
09:12:17 <Cale> Similarly, lists model nondeterministic computation
09:12:46 <Cale> A list is a computation which may have zero or more results, and "running" a list means picking an element from it (in all possible ways)
09:13:04 <Cale> > do x <- [1,2]; y <- [3,4]; z <- [5,6]; return (x,y,z)
09:13:05 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
09:13:25 <phaazon> fair enough :)
09:14:13 <phaazon> I just don’t like the “action” word
09:14:18 <phaazon> because it misleads people
09:14:26 <Cale> For all the monads which we actually use on a regular basis, thinking about monads via this computational analogy will work well.
09:14:30 <mniip> it's better than "container" I believe
09:14:40 <Cale> For monads outside Haskell, it's perhaps misleading
09:14:51 <phaazon> one tends to think that a monad’s action is impure, side-effects-related and so on
09:15:05 <mniip> they are side effects to the returned value
09:15:10 <Cale> For example, it's hard to imagine how to think of what the completion functor on metric spaces is doing in terms of computations
09:15:12 <phaazon> mniip: I kinda like the container stuff
09:15:16 <phaazon> like, the burrito 
09:15:38 <mniip> phaazon, so how would you describe the list monad?
09:15:57 <Cale> The container approach, while it can be made to work, has to come with lots of caveats because most people are going to have ideas in their heads about what containers are.
09:16:10 <phaazon> mniip: good question
09:16:37 <mniip> oh that wasn't the main question I was going to ask
09:16:40 <phaazon> I don’t use lists as monads
09:16:48 <mniip> you're missing out
09:16:49 <Cale> and many monads that we use are difficult to think of as containers
09:16:58 <phaazon> Cale: yeah, like Maybe
09:17:01 <phaazon> or worse
09:17:02 <phaazon> State
09:17:06 <mniip> I was going to continue to Reader and State
09:17:06 <phaazon> it doesn’t even store the value
09:17:08 <phaazon> at no time
09:17:12 <Cale> Maybe is easy to think of as a container type
09:17:18 <mniip> as well as IO and Proxy
09:17:32 <Cale> But yeah, State is a better example, and yeah, IO, and various free monads...
09:17:39 <phaazon> or Cont
09:17:53 <mniip> wait
09:18:01 * mniip . o O ( Cont ~ Co Identity
09:18:03 <mniip> )
09:19:14 <phaazon> mniip: I think the list is a very interesting type btw
09:19:31 <phaazon> at first I thought it was just a sequence of values
09:19:42 <phaazon> but we can have circular lists in constant memory
09:19:58 <ahihi> phaazon: why is Maybe hard to think of as a container? it holds either zero values, or one
09:20:01 <mniip> that's execution semantics of your compiler
09:20:15 <mniip>  @ phaazon
09:20:41 <mniip> we don't usually talk about those in type-theoretic contezt
09:20:52 <phaazon> ahihi: yeah that’s true
09:21:15 <phaazon> I was more thinking about “having something in there” and thinking about Maybe as Functor
09:22:09 <phaazon> anyway, an action is interesting but I kinda feel uncomfortable with that word
09:22:35 <mniip> I do think of functors as containers, but that's because my intuitive definition of a container is flexible enough to fit Reader, State, and Const
09:23:05 <phaazon> mniip: I like to see Functor as an abstract way of mapping things
09:23:36 <phaazon> going too concrete never works I think
09:23:41 <ahihi> I view the "container-ness" of a type as a property that is orthogonal to its being a Functor/Applicative/Monad
09:23:54 <phaazon> like, for a list, the functor instance “iterates over the list and applies the function”
09:24:28 <phaazon> but for (->) r, it just performs composition
09:24:42 <mniip> well
09:25:00 <mniip> 'Reader r a' can be said to contain an a once r is applied
09:25:14 <mniip> and you apply a function to that a
09:25:26 <phaazon> :)
09:25:41 <phaazon> yeah Reader is just a function in disguise
09:25:57 <mniip> likewise, 'Const r a' contains no as, and you apply a function to all of zero as there are
09:26:04 <phaazon> and State is just a function in disguise that can do a bit more than Reader
09:26:25 <phaazon> mniip: yep :)
09:26:28 <levi> You can think of function composition as a sort of containment if you squint at it and you've got a broad view of what 'containment' means.
09:26:47 <phaazon> levi: so what is a contravariant functor now? ;) ;)
09:26:50 <mniip> phaazon, I do like the bit where we represent State as a composition of a Reader and an Endo Writer
09:27:04 <phaazon> mniip: hm
09:27:12 <phaazon> that reminds me edwardk’s MonadUpdate :)
09:27:24 <mniip> quite possibly that's exactly the thing
09:27:31 <phaazon> I think it is yeah
09:27:36 <phaazon> it uses a monoidal interface
09:27:40 <phaazon> to make them compatible
09:28:01 <phaazon> anyway, I just figured that everyone left the openspace :D so I’ll go home as well!
09:28:06 <phaazon> see you!
09:28:17 <levi> I don't think about contravariant functors often enough to even say whether I could convince myself you could screw your brain into considering them as containers somehow. :)
09:28:33 <phaazon> levi: I see them as adapters :)
09:29:41 <levi> I try to think of functors in terms of mapping rather than containers anyway.
09:36:24 <centrica>  /SET autolog ON
09:37:22 <Jinxit>  /SET password hunter2
09:38:07 <osfameron> last night, lyxia suggested using fmap to avoid an explicit accumulator variable in a recursive function: https://gist.github.com/osfameron/4b5d9954e742110bd4ac#gistcomment-1705821
09:38:13 <osfameron> but I don't understand why this isn't buggy
09:38:33 <osfameron> e.g. in the case of:  longestMatch "watchable" ss
09:38:54 <osfameron> where "watch" will match, but "able" doesn't.  e.g. why doesn't that just become fmap ("watch":) [] ?
09:39:21 <osfameron> (which would be a bug.  So that's good.  But I don't understand *why* it's doing what I wanted it to ;-)
09:39:50 <lyxia> how would that be a bug
09:39:59 <lyxia> > fmap (42 :) []
09:40:00 <lambdabot>  []
09:40:21 <osfameron> ah I see.  I was misparsing what it's doing
09:40:55 <aweinstock> matches [] ss = return [] = [[]]
09:40:58 <osfameron> we're in the list monad, so we're prepending to *all* the successful combinations (of which there are none)
09:41:13 <aweinstock> > fmap ("watch":) [[]]
09:41:15 <lambdabot>  [["watch"]]
09:42:11 * osfameron is (slightly) enlightened :-)
09:42:12 <osfameron> thanks
09:46:31 <roelof> Does anyone know a good web "framework" which can work with 1G memory ? 
09:47:32 <orion> scotty
09:47:40 <fr33domlover> roelof, Yesod can't?
09:47:59 <bitemyapp> I run a Yesod app + postgresql on a 512mb VPS
09:48:06 <VassilisVHF> http://channel44.vask1lux.de/ my messageboard
09:48:26 <kadoban> Building yesod might take more than that possibly, is that where you're having trouble roelof?
09:48:49 <bitemyapp> yeah that might be the issue - building.
09:48:51 <roelof> wierd, I tried to install yesod on a 1G cloud box but saw a error message that could be related to memory problem 
09:49:18 <bitemyapp> well yeah
09:49:20 <fr33domlover> roelof, you can build locally and then upload just the binary to the server
09:49:24 <kadoban> roelof: Can you pump up the available memory somehow while you're installing it? You should be able to lower it after.
09:49:25 <fr33domlover> also more secure
09:49:26 <bitemyapp> roelof: are you using the sa---what fr33domlover said.
09:49:27 <geekosaur> I'd almost bet on building yesod needing more than that, between the TH and that just linking hello world seems to take 1G (thanks binutils)
09:49:43 <bitemyapp> geekosaur: yeah, building definitely does. I could make the build work, but he's better off rsyncing the binary.
09:50:16 <roelof> I saw this error message : http://lpaste.net/153273
09:50:49 <roelof> Can I build Yesod on Windows and then use it on a linux box ? 
09:51:16 <roelof> I cannot change the memory. It's a fixed box that I can use for free 
09:51:19 <kadoban> roelof: You'd probably want to make a linux VM with as close to the exact setup as your server as you can.
09:51:21 <M-Quora> not easily
09:52:18 <roelof> bitemyapp:  what do you mean with using the sa  
09:53:35 <geekosaur> that was an interrupted comment
09:55:03 <roelof> I tried also servant but then a lot of problems with aeson. it need aeson-0.10 for the tutorial and there are "errors" in the tutorial 
09:56:14 <nitrix> roelof: Try making a vm that's as close as possible to the target machine, compile there and move the binary.
09:56:17 <roelof> or I must find a good setup, so I can work on Windows but then I have to find a "ide" which can work with stack. Then I could use 4G 
09:57:27 <luigy> roelof errors? you sure? you mean a written tutorial somewhere or the code from servant-examples/tutorial? I tried the latter recently and have no probs
09:58:00 <roelof> luigy:  I tried the latter and the written tutorial.  
09:58:31 <roelof> LIke I said I had problems because the tutorial needs aeson-0.10 and stack does not shipped it 
09:58:57 <luigy> I'm also a big stack user :P
09:58:59 <roelof> and on the other page I see a error message that a key was not found 
09:59:03 <luigy> had no probs either
09:59:17 <roelof> I did type everything myself 
09:59:43 <luigy> where you doing it from master or a separate branch? did notice a few new tutorial branches
10:00:30 <hexagoxel> what does the channel think of this idea: https://github.com/lspitzner/qualified-prelude ?
10:00:55 <hexagoxel> are there disadvantages that i am missing?
10:01:11 <hexagoxel> (it is not ready for hackage release yet)
10:01:40 <roelof> luigy:  I see here a error message that the key clientName was not found : http://pastebin.com/8iFgTvwd
10:02:15 <roelof> I did the tutorial from this page : https://haskell-servant.github.io/tutorial/server.html
10:04:30 <roelof> luigy:  did you read my last remarks ?
10:07:44 * hackagebot turtle-options 0.1.0.0 - Collection of command line options and parsers for these options  https://hackage.haskell.org/package/turtle-options-0.1.0.0 (elaye)
10:13:08 <prooftechnique> \quit
10:13:12 <prooftechnique> Whoops
10:22:34 <luigy> roelof oh I see.  Yeah the tutorial needs to be updated, but it probably already is on master.  The thing is that the generic parser doesn't strip the "clientæ prefix
10:22:45 * hackagebot turtle-options 0.1.0.1 - Collection of command line options and parsers for these options  https://hackage.haskell.org/package/turtle-options-0.1.0.1 (elaye)
10:22:47 * hackagebot renderable 0.2.0.0 - An API for managing renderable resources.  https://hackage.haskell.org/package/renderable-0.2.0.0 (SchellScivally)
10:23:26 <luigy> roelof https://github.com/haskell-servant/servant/blob/master/servant-examples/tutorial/T3.hs
10:25:30 <roelof>  Oke, can I install this tutorial also with stack.  I could only find cabal instructions 
10:26:06 <alpounet_> luigy: the tutorial is being reworked for the upcoming release, sorry for the inconvenience =)
10:26:52 <roelof> alpounet_:  so I can better wait for the next relaese to test if Servant suits me ? 
10:27:09 <alpounet_> nah you can probably start right now
10:27:13 <alpounet_> just restrict the aeson version
10:29:20 <srpx> Is there any library for immutable data structures in JavaScript that is more haskellish than Immutable.js? Curried functions, functional-style types, etc.
10:29:25 <srpx> Not sure if it is ok to ask this here
10:34:17 <johnw> not really the place, no
10:34:29 <johnw> I appreciate the use of the word 'haskell' in the attempt, though :)
10:35:05 <bitemyapp> srpx: "Haskell'ish" isn't too meaningful a criteria here anyway.
10:35:30 <osfameron> presumably you've looked at ghcjs and purescript?
10:35:37 <kadoban> srpx: There's GHCJS. I hear that's pretty haskellish ;)
10:35:39 <Cale> srpx: Compile stuff from ghcjs :D
10:35:42 <Cale> yeah
10:35:43 <Cale> haha
10:35:43 <nitrix> One could argue you're in good terms with Haskell when you feel procedural languages are restrictive.
10:35:51 <johnw> haha
10:36:16 <srpx> Cale I need to use angular :/
10:36:33 <srpx> I need at least some breath of fresh air to make it through 
10:36:56 <Cale> srpx: I don't really know what angular is, but GHCJS lets you do Javascript FFI really easily. You can FFI import arbitrary javascript expressions.
10:37:41 <Cale> So it's usually not so hard to use things that you really want. e.g. we use FFI to access the Google Maps API and stuff in our applications.
10:38:18 <Cale> (but I suppose if you're not the only one working on the project, perhaps the others don't know Haskell so well :)
10:38:37 <clahey_> Is there a logging library that lives in pure functions but can be turned on to log whatever string it's passed when debugging mode is turned on?
10:39:26 <mauke> "they told me Haskell doesn't have null but it's right there in the Prelude"
10:39:33 <Cale> mauke: haha
10:39:44 <kadoban> clahey_: Sounds like something you could do with Debug.Trace if the purpose is debugging.
10:39:46 <kadoban> mauke: Nice
10:41:52 <clahey_> kadoban, That's pretty much what I'm looking for. Is there not a way to turn the debugging off for production so I don't have to delete all my debug statements?
10:42:16 <johnw> clahey_: you can always use CPP macros
10:42:18 <kadoban> clahey_: I guess you could do something with CPP
10:42:28 <Cale> clahey_: Generally you can define something like  tq s x = trace (s ++ ": " ++ show x) x  or something, and then conditionally compile that to id
10:42:40 <Cale> er, or const I suppose :)
10:42:41 <johnw> not that monad-logger was designed to allow you to "compile out" logging statement, using instance selection
10:42:44 <johnw> note that
10:42:52 <johnw> however, it's not convenient to use at all if you just want "pure functions"
10:43:02 <Cale> All the logging libraries I've seen have been really silly
10:43:12 <srpx> Cale it means I have to rewrite the entire website of my company in a MVC framework which mixes HTML with inline control flow in a JS-like DSL
10:43:21 <johnw> oh, yeah, you can use CPP to either import Debug.Trace, or define trace _ = id, like Cale says
10:43:34 <Cale> srpx: That sounds "fun"
10:43:37 <srpx> and controllers to activelly mutate the DOM when you want anything dynamic like a list that grows/shrinks
10:44:27 <srpx> Cale you mispeled death
10:44:36 <clahey_> CPP = C preprocessor?
10:44:39 <johnw> yes
10:44:49 <clahey_> Uhhh.
10:44:49 <johnw> not the real C preprocessor, a subset of it
10:44:59 <clahey_> I didn't know we did that sort of thing in haskell land.
10:45:09 <johnw> sure, people do it to support different library versions all the time
10:45:26 <Cale> It's still more suitable for certain things than Template Haskell or anything else.
10:45:41 <clahey_> I can also just have "myDebug = Debug.Trace.whatever" and then when I want to productionize, change it to id.
10:45:50 <Cale> clahey_: absolutely
10:45:50 <clahey_> Or const id, rather.
10:46:11 <clahey_> I'm not to the point of needing compile time options like that.
10:46:31 <clahey_> I'm thinking about how I would implement what I'm looking for.
10:46:44 <clahey_> But I think it would end up messing up optimization real hard.
10:46:57 <clahey_> Because you'd have run time checking of debugging mode.
10:47:06 <Cale> generally the compiler is good at inlining things like id or const and simplifying them away
10:47:07 <clahey_> Which would have to be in IO no matter what.
10:47:15 <clahey_> Oh, what we just described would work, yeah.
10:47:42 <clahey_> I meant having an IO action like, "setDebugging Disabled"
10:47:47 <Cale> ah
10:48:09 <clahey_> Which would have to store data in an IORef or something and then look it up every time you did debugging which would cripple optimization.
10:48:14 <Cale> yep
10:48:18 <Cale> But then you can *still* do conditional compilation trickery to completely eliminate it.
10:49:08 <Cale> If you want to be able to turn things on and off while in debugging mode, but still compile it right out in production.
10:49:17 <clahey_> Oh, sure.
10:49:26 <clahey_> Absolutely.
10:49:52 <mauke> when debugging $ log "stuff"
10:50:10 <osfameron> srpx: I found Angular quite fun tbh
10:50:26 <clahey_> So, one thing that came up while I was thinking about implementing this myself was this question...
10:50:34 <Cale> Yeah, and you can of course throw in a logging level enumeration type which you check against or something, if you want.
10:50:36 <osfameron> though I'm still firmly of the "front-end is nice for a vist, but I wouldn't like to live there" opinion
10:50:52 <Cale> osfameron: I actually don't mind frontend stuff now using reflex-dom :D
10:51:03 <clahey_> Can I memoize the results of IO actions?
10:51:38 <Cale> osfameron: There are still a few headaches here and there whenever I really have to get CSS properties right, but for the most part, I get to just write Haskell code
10:52:02 <clahey_> getGlobalState :: IORef MyType
10:52:10 <clahey_> getGlobalState :: IO IORef MyType
10:52:19 <clahey_> getGlobalState :: IO (IORef MyType)
10:52:25 <clahey_> And have it return the same IORef each time?
10:52:46 <Cale> Er...
10:53:19 <roelof>  alpounet_  how can I then restrict the aeson version. Or can I do that with the if !min version part in the tutorial ? 
10:53:38 <Cale> clahey_: What's the usage case? Maybe I'll understand better what you want.
10:53:51 <nitrix> clahey_: That's nasty.
10:54:21 <nitrix> You're tyring to translate a procedural paragdim (actually it looks like what you'd do in C) directly to Haskell. It doesn't work this way :/
10:54:27 <clahey_> The usage case it came up in is I want to have a library that uses unsafePerformIO and runs some initialization the first time it is executed.
10:54:40 <osfameron> Cale: I have some worries about, e.g. getting frontend devs/designers to support that kind of thing... but yeah, will play with reflex-dom sometime soonish...
10:56:08 <clahey_> Basically, any time you would want global state.
10:56:25 <clahey_> But except for this debugging idea, I generally dislike global state, so there's that.
10:57:56 <Cale> clahey_: http://paste.lisp.org/display/308146 -- perhaps something like this?
10:58:40 <Cale> clahey_: e.g. you can write something like
10:58:55 <Cale> theLine <- memoIO getLine
10:59:13 <Cale> and then executing theLine the first time will run getLine and get a line of text
10:59:36 <Cale> But on every subsequent time, will produce the same line of text as the first.
10:59:45 <clahey_> There's no reason to do that.
11:00:05 <clahey_> I.e., that doesn't help because you still get a new line every time you run memoIO getLine.
11:00:07 <Cale> i.e. it's "memoised" the result of the action
11:00:16 <clahey_> Yeah, I understand.
11:00:19 <Cale> You only call memoIO getLine once.
11:00:29 <Cale> and pass the resulting action to where it's needed
11:00:31 <clahey_> But then you have to store "theLine" somewhere.
11:00:33 <Cale> yep
11:00:42 <clahey_> The goal is to not have to store theLine somewhere.
11:00:52 <Cale> Then nope :)
11:01:00 <clahey_> I realize it may be impossible, yeah.
11:01:09 <clahey_> I mean, you can do it with the ffi.
11:01:14 <clahey_> But that's ugly.
11:01:26 <Cale> You can actually make global state cells using unsafePerformIO, but don't do it.
11:01:42 <nitrix> Cale: You did the mistake of mentioning it.
11:01:51 <Cale> hah, perhaps
11:02:04 <nitrix> Looking at how he seem to choose the sketchiest approach everytime, this is a fatal error.
11:02:16 <Cale> ah, haha, I had no sense of history here
11:02:17 * nitrix hits Cale with a stick.
11:02:24 <kadoban> Oi. One test-case failing, and it's the most tediously annoyingly long test-case I have in the whole set :-/
11:02:38 <clahey_> Is there some history that suggests I choose sketchy other than this conversation?
11:02:57 <Cale> But yeah, it's just far and away much nicer to pass in some record of operations that access the various bits of state of your program, rather than having global state.
11:02:59 <clahey_> Cause I know that what I'm describing is sketchy.
11:03:08 <clahey_> Oh yeah, that's how I write things normally, yes.
11:03:13 <Cale> clahey_: I don't know, nitrix seems to think so :)
11:03:29 <clahey_> But in order to implement a logging solution that gets out of the way as much as possible, I was considering using sketch.
11:03:41 <nitrix> :: IO (IORef MyType) is nuts ._.
11:03:45 <Cale> But yeah, if you're already passing around a record of ops, it's not hard to add in something which does logging
11:03:59 <clahey_> Yes, that is true.
11:04:14 <clahey_> Sorry, not logging. Debugging.
11:04:16 <Cale> Actually sometimes you can implement logging entirely by modifying the operations you're *already* passing around.
11:04:27 <Cale> (or debug logs)
11:04:31 <clahey_> With ReaderT or something?
11:04:39 <clahey_> Sorry, WriterT?
11:04:46 <Cale> No monad transformers
11:05:47 <Cale> If you're creating some operations which manipulate the state of your program, e.g. perhaps creating an IORef and then applying readIORef and writeIORef to it, and passing the record of those to the rest of your program from main
11:06:23 <Cale> Then you can instead of just using writeIORef r, you can make some more elaborate action which logs the state change.
11:06:28 <Cale> and pass that along
11:06:31 <clahey_> Honestly, I wouldn't tend to use readIORef and writeIORef. I would tend to use a State monad, possibly with monad transformers.
11:07:07 <Cale> I tend to avoid monad transformers as much as possible until there's definitely a good reason for them, and I have a well-thought-out coherent plan for what operations will be in my monad.
11:07:27 <clahey_> I tend to avoid them to and stick to simple Monads until they seem like would be useful.
11:07:43 <Cale> StateT over IO is almost always silly
11:07:47 <clahey_> Why?
11:07:58 <Cale> Because IO already has a ton of facilities for statefulness.
11:08:17 <burke_> are there any programming languages with session types as a core feature/language construct?
11:08:24 <adarqui> hey.. i've tried looking but can't find info on this: how do I set default configuration variables for cabal & stack? email, git, full name, license etc?
11:08:28 <Cale> So at best, you're saving yourself from passing a parameter
11:08:39 <Cale> But you immediately cost yourself the need to put liftIO everywhere
11:08:47 <Cale> and the balance usually isn't pretty
11:10:26 <Cale> If you like the idea that you can write things like  MonadState s m => ... m () and then use it with m = IO, well, you can pull the same trick with polymorphic record types rather than MonadState
11:10:28 <srpx> osfameron: you found angular fun? Please teach me how?
11:10:34 <clahey_> I had some success mixing ParserT and Either. Or maybe it was EitherT and Parser. It was a while ago.
11:10:50 <srpx> osfameron: it looks exactly like the type of thing I hate most. Tries to do everything well, does everything mediocrely 
11:11:02 <Cale> e.g. you can have:
11:11:30 <srpx> osfameron: has specific rather than generic ways to do things, so if you need anything out of what the devs predicted, good luck
11:11:38 <Cale> data MyStateOps m = MSO { readFoo :: m Foo, writeFoo :: Foo -> m (), ... other stuff ... }
11:11:42 <glguy> JavaScript libraries in general are off topic in #haskell
11:11:48 <Cale> and then maybe you only ever use this with m = IO
11:11:56 <Cale> but you can write functions whose type looks like:
11:12:08 <Cale> MyStateOps m -> ... -> m Bar
11:12:15 <srpx> like the fact routes work well for the notion of top-level tavving, but you need something different for apps inside your main app, and if you have apps inside apps inside apps boom
11:12:21 <Cale> and then only the operations you pass in can be used
11:12:21 <srpx> tabbing*
11:12:36 <srpx> osfameron: I'm on haskell-blah
11:18:05 <tekkkz> how to do map (\x -> x : []) pkmType when pkmType is of type IO String
11:18:41 <johnw> map (\x -> x : []) <$> pkmType
11:19:18 <johnw> also, (\x -> x : []) = (:[])
11:19:27 <adarqui> found it, i need this: https://github.com/commercialhaskell/stack-templates#readme
11:21:49 <tekkkz> johnw, what is <$> doing?
11:22:22 <johnw> it's lifting your map from type a -> [a] to type IO a -> IO [a]
11:22:26 <glguy> tekkkz: Remember that a value with type IO String is an action that returns a String when executed
11:22:36 <johnw> it's lifting your map from type [a] -> [[a]] to type IO [a] -> IO [[a]]
11:22:41 <glguy> it's not a String
11:22:50 <tekkkz> ok
11:23:10 <glguy> the <$> operation in this case is creating an new action that returns a [[Char]] if it's executed
11:25:35 <burke_> <$> = fmap
11:26:41 <jackhill> when would I want to use <$> instead of liftM ?
11:27:09 <johnw> liftM imposes a stricter constraint, of Monad instead of Functor
11:27:15 <kadoban> jackhill: Essentially always.
11:27:28 <johnw> if all you need is <$>, always use it
11:27:46 <johnw> the only reason to use liftM is that previously, Monad did not imply Functor, and so if all you had was a Monad constraint, liftM is all that you _could_ use
11:27:48 <kadoban> The only time I use liftM is in code that needs to work with GHC 7.8 and I don't feel like adding a Functor constraint in addition to the Monad one.
11:28:07 <jackhill> ah, cool, thanks
11:28:14 <johnw> for users of 7.10+, always use <$>
11:28:19 <johnw> (or "fmap")
11:29:26 <jackhill> is fmap v. <$> just convienence of naming for prefix/infix ?
11:29:38 <lynn> Yep
11:29:44 <jackhill> sweet
11:30:07 <glguy> You also use liftM if you're deriving your Functor instance in terms of your Monad instance
11:30:23 <Gurkenglas_> What about liftA? Was Applicative ever not Functor?
11:31:21 <glguy> liftA is defined in terms of <*>, so you could use that to define fmap, too
11:31:26 <kadoban> liftA probably exists in case you've written the Applicative instance and want to reuse it for the Functor one?
11:40:18 <yyyyy> is there anything like a Either that also allows for a “both” case? something like `data Or a b = Left a | Right b | Both a b
11:40:28 <johnw> see Data.Align
11:40:30 <johnw> @package these
11:40:31 <lambdabot> http://hackage.haskell.org/package/these
11:41:17 <yyyyy> johnw: this is perfect, thanks!
11:41:51 <johnw> it's quite handy for comparing two hierarchical structures
11:43:41 <nitrix> jackhill: <$> is defined by the Control.Applicative module to have the convenient "applicative-style" syntax:   (+) <$> Just 5 <*> Just 3
11:44:28 <nitrix> jackhill: It's exactly the same as fmap (except it's infixl 4).
11:44:37 <orion> What is the most advanced Haskell topic you can think of at the moment?
11:44:44 <orion> (you, anyone)
11:44:59 <nitrix> orion: I guess you can scare people with zygohistomorphic prepromorphisms.
11:45:15 <mauke> GONE SEXUAL
11:45:17 <nitrix> It's not very advanced though.
11:46:14 <mauke> kind-level lenses
11:46:24 <johnw> orion: I'm still trying to figure out how to express propositional predicates over another data types (so called "judgments")
11:47:31 <johnw> actually, edwardk's latest researches into categories is probably the most advanced thing I know about at the moment
11:47:43 <johnw> considering he needed a feature from SPJ just to write it last month
11:48:33 <shapr> mauke: what?
11:50:25 <mauke> shapr: which one?
11:50:43 <shapr> er, sexual?
11:50:51 <shapr> or heck, kind level lenses
11:51:25 <mauke> shapr: excessive silliness
11:51:34 <jelle> is building ghc without static libs generally supported in the haskell community or not?
11:52:04 <nitrix> I don't think the community has a stage about it, but think of the user.
11:52:04 <johnw> with TypeInType, kind-level lenses will just be lenses again? :)
11:52:28 <nitrix> jelle: It wouldn't make sense for the user to install GHC just to get the runtime necessary to run your applications.
11:52:34 <shapr> mauke: oh, that happens to me often
11:52:44 <jelle> nitrix: I'm talking about a linux distro
11:52:56 <nitrix> jelle: I'm talking about every operating systems.
11:53:24 <shapr> raichoo:  you really have that hat in your twitter pic?
11:54:30 <raichoo> shapr: Not anymore. It's a pretty old pic and that baseball cap was since replaced by another one.
11:55:30 <shapr> raichoo: if I had a pic I'd submit a PR
11:56:21 * raichoo is not quite sure where this is heading…
11:57:53 * hackagebot ratel-wai 0.1.0 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-0.1.0 (fozworth)
11:58:32 <shapr> raichoo: nowhere :-)
11:58:55 <raichoo> ^^
11:59:13 <shapr> it's still a cool twitter pic
12:00:20 <raichoo> shapr: It was a quick snapshot taken by a co-worker of mine. I liked it so I kept it ^^.
12:01:06 <shapr> I need to update my twitter pic, I have four times the hair
12:08:06 <jle`> shapr: kind level lenses
12:08:09 <jle`> that's
12:08:11 <jle`> something
12:09:06 <jle`> although i guess in 8.0+, kind level lenses are just type level lenses
12:12:04 <quchen> jle`: We need universes, I feel constrained lensing in my sorts
12:18:28 <jle`> Type :: Type feels so haskell to me
12:18:38 <jle`> like 'haha what is consistency'
12:18:58 <pantsman-> something is really bugging me about how haskell-mode is working in spacemacs (don't know if it is the same in vanilla emacs): when I cut and then yank some lines, they are put back with an indent on them.
12:19:16 <pantsman-> I'd like it to not touch the indentation when I yank a bunch of lines.
12:19:35 <pantsman-> every time I move some code around I end up having to fix the indentation :(
12:20:43 <pantsman-> this doesn't happen in other language modes.
12:31:57 <crough> pantsman-: It's your indentation mode. I'd read up on the setting to maybe be able to use a simpler one
12:32:31 <pantsman-> _my_ indentation mode? It's the default one.
12:33:18 <crough> pantsman-: Yes, I know. Haskell mode requires an indentation mode. Normally it's not set by default but Spacemacs doesn't want you to configure anything so it just... picks one.
12:33:56 <crough> pantsman-: I'm not trying to blame you, Spacemacs does a *wonderful* job of obscuring this from people
12:35:12 <pantsman-> yeah, thanks, setting haskell-indent-mode fixed it
12:35:25 <orion> < johnw> actually, edwardk's latest researches into categories is probably the most advanced thing I know about at the moment -- link?
12:35:27 <pantsman-> I was under the impression that haskell-mode had recently fixed the indentation modes and there was now only one mode
12:35:34 <pantsman-> but spacemacs has obviously complicated this
12:36:05 <crough> pantsman-: No, there's only one in Haskell Mode (the one that is on by default) but it still supports others...
12:36:34 <crough> pantsman-: Either way, it's very opinioned. I had a macro to insert 80 hyphens as a divider and it tried to indent that all of the time...
12:38:00 <sinelaw> yo. I want to spawn a set of processes in parallel, but with differing current working dir
12:38:16 <jle`> zipWithM ?
12:38:20 <johnw> edwardk: ping
12:38:22 <scshunt> sinelaw: fork your own process, then change working dir, then exec the new process
12:38:27 <scshunt> johnw: good luck
12:39:21 <dmj`> as <- forConcurrently ["dir1", "dir2"] $ \dir -> doThing dir 
12:39:21 <sinelaw> scshunt: ok
12:39:41 <geekosaur> createProcess lets you specify cwd of the new process
12:44:40 <sinelaw> geekosaur: great, sounds better
12:45:41 <hectortrope> Hi same old question I am a very complete noob know 0 language and directly want to start with haskell where should I start? Note i grasp very fast 
12:46:05 <dfurman> hectortrope: github/bitemyapp/learnhaskell
12:46:34 <Quintasan> hectortrope: Most recommended course is CIS194 http://www.seas.upenn.edu/~cis194/
12:47:06 <Quintasan> That said I'm going through cis194 and for life of me I can't figure out how to consistently import provided tests. I'm doing :load HW02.hs HW02Tests.hs ../Testing.hs in ghci but ex*Tests are not available
12:49:02 <hectortrope> git confusing and another url 13 week course and my douby haskel will be useful in 2016 because its old language?
12:50:12 <Quintasan> hectortrope: Haskell's relevancy on the job market is really low so if you are learning it with that in mind then you'll be disappointed.
12:50:18 <Quintasan> But it does make you a better programmer.
12:51:00 <hectortrope> yes I want to be very good at programming'
12:51:33 <hectortrope> Quintasan:  but suppuse if I learn node.js and practising it daily hours 
12:51:37 <dfurman> hectortrope: then haskell is good choice. btw have you read SICP?
12:51:51 <hectortrope> SICP ??
12:52:04 <dfurman> hectortrope: 6.001 at mit ocw
12:52:05 <hectortrope> means
12:52:37 <hodapp> Structure & Interpretation of Computer Programs
12:52:39 <hectortrope> dfurman:  sorry I am not understanding
12:52:43 <hodapp> a.k.a. The Wizard Book
12:53:19 <Quintasan> hectortrope: JavaScript, while functional, is not Haskell and I'm tempted to say that nodejs is usually frowned upon.
12:53:56 <hectortrope> Quintasan:  ??
12:54:08 <hodapp> JavaScript is sort of functional, and sort of awful.
12:54:13 <Quintasan> ^
12:54:14 <hectortrope> Ok
12:54:37 <hodapp> but yes, plenty of places are looking for JavaScript and Node.js experience.
12:54:39 <hectortrope> My aim I should develop any webapp I am thonking like this from last one year'
12:54:45 <hectortrope> but I didnt move further
12:59:44 <hectortrope> ??
12:59:50 <hectortrope> So haskel right for me?
12:59:58 <hectortrope> hodapp: 
13:00:38 <hodapp> you'd likely learn a lot from it, but I don't know what your goals are
13:02:45 <hectortrope> my goal simple become good programmer like most of the irc guys here
13:02:47 <hectortrope> thats it
13:03:50 <hodapp> learning a variety of languages, and working with them a lot, is one thing bto do there.
13:04:15 <hodapp> and SICP is a good book for a lot of general things that can apply in any language
13:15:39 <orion> < Quintasan> hectortrope: JavaScript, while functional <-- how is JS functional?
13:16:08 <jpll> functional in a more general sense
13:16:20 <tekkkz> Can someone please explain me my mistake here please? https://bpaste.net/show/3949d39175e4
13:17:40 <geekosaur> dropWhile (== '/')
13:17:53 <tekkkz> whats there wrong?
13:17:58 <geekosaur> this drops initial /, you want the one in the middle
13:18:19 <tekkkz> sorry i don't understand what you mean
13:18:36 <geekosaur> dropWhile (== '/') "////a" ---> "a"
13:18:43 <tekkkz> yes
13:19:00 <tekkkz> thats correct
13:19:04 <geekosaur> dropWhile (== '/') "steel/fighting" ---> "steel/fighting"
13:19:09 <tekkkz> nono
13:19:10 <geekosaur> because it drops WHILE
13:19:11 <tekkkz> look at my code
13:19:16 <tekkkz> steel is taken from it already
13:19:17 <geekosaur> not "WHEN IT FINDS"
13:19:21 <geekosaur> no it is not
13:19:45 <geekosaur> takeWhile does not modify pkmType
13:19:52 <tekkkz> >dropWhile (== '/') . dropWhile (/= '/') $ "steel/fighting"
13:19:53 <geekosaur> it's still the full string
13:20:00 <tekkkz> > dropWhile (== '/') . dropWhile (/= '/') $ "steel/fighting"
13:20:01 <lambdabot>  "fighting"
13:20:04 <tekkkz> you see?
13:20:14 <geekosaur> yes, because you fed the output of the first into the second
13:20:17 <geekosaur> you are not doing that here
13:20:18 <tekkkz> yes
13:20:21 <tekkkz> i am
13:20:34 <geekosaur> oh,. you are. poorly. but.
13:20:38 <tekkkz> hehe :D
13:20:41 <tekkkz> no problem
13:20:52 <geekosaur> I think you wanted break instead, rather than have to repeat yourself
13:21:11 <geekosaur> break (=='/') "steel/fighting" ---> ("steel","/fighting")
13:21:35 <tekkkz> > break (=='/') "steel/fighting"
13:21:37 <lambdabot>  ("steel","/fighting")
13:21:46 <geekosaur> oh, I see the type error
13:21:52 <geekosaur> you are prepending a [Char]
13:21:59 <geekosaur> you can't do that with (:)
13:22:02 <geekosaur> use (++)
13:22:14 <tekkkz> but i wanna rreceive a [String]
13:22:26 <nkaretnikov> is there something like a transaction for io?  no i don't want to mess with locks, etc.  i just want to write something like: do startTransaction; action; endTransaction
13:23:17 <koala_man> nkaretnikov: like STM?
13:23:37 <geekosaur> > let splitIt s = let (pr,su) = break (== '/') s in [pr, drop 1 su] in splitIt "steel/fighting"
13:23:38 <lambdabot>  ["steel","fighting"]
13:24:44 <tekkkz> geekosaur, from wehre to import splitIt?
13:24:50 <geekosaur> ???
13:24:53 <geekosaur> I defined it
13:25:02 <tekkkz> oh 
13:25:03 <tekkkz> sorry
13:25:04 <niez> hi, anyone here is using servant and validates incoming json data?
13:25:04 <tekkkz> xD
13:25:06 <geekosaur> "let splitIt s "
13:25:11 <nkaretnikov> koala_man: stm feels just like locks
13:25:21 <hexagoxel> there is a package "geekosaur" :p
13:25:41 <nkaretnikov> koala_man: i want something like an sql transaction but for io
13:25:52 <mauke> nkaretnikov: how would rollback work?
13:25:54 <nkaretnikov> koala_man: stm could do, but that must be implemented on top of the raw primitives
13:25:59 <nkaretnikov> mauke: no idea
13:26:02 <koala_man> nkaretnikov: how does stm feel like locks?
13:26:03 <mauke> ...
13:26:05 <nkaretnikov> mauke: i'm just listing my demands :)
13:26:20 <mauke> nkaretnikov: then what do you mean by "transaction"?
13:27:27 <nkaretnikov> mauke: a block that's executed in a batch.  if interrupted, it's not executed at all.  maybe i'm looking for mask?
13:27:41 <nkaretnikov> i see what you're hinting at, but still...
13:28:12 <mauke> nkaretnikov: define "interrupt"
13:28:26 <gargawel> Hi, in which package is the (-<) operator used in Opaleye defined ?
13:28:34 <gargawel> I thought it would be in Control.Arrow
13:28:44 <nkaretnikov> koala_man: you put stuff into a mutable variable, sort of.  i skimmed the paper that introduced stm or something and know that it's meant to replace locks actually
13:28:53 <osa1_> gargawel: it's an arrow syntax I think
13:28:57 <glguy> gargawel: It's not an operator, it's syntax
13:29:04 <nkaretnikov> mauke: an exception is raised
13:29:20 <mauke> nkaretnikov: ok, that's impossible
13:29:33 <mauke> e.g. you can't unsend a network packet
13:29:38 <gargawel> Oh, OK I feel stupid :)
13:29:57 <nkaretnikov> mauke: i don't have anything like that
13:30:06 <gargawel> I should have guessed that some extension was required
13:30:18 <mauke> nkaretnikov: you said IO block, and IO has that
13:30:20 <nkaretnikov> mauke: i have two dbs: an on-disk one and in-memory one
13:30:41 <nkaretnikov> i want to make sure that they are kept in consistent state
13:30:41 <osa1> I think it's a valid operator syntax, it's just hijacked by -XArrows
13:30:55 <nkaretnikov> mauke: comeeee on :)
13:31:06 <nkaretnikov> mauke: you're trolling, right?
13:31:27 <mauke> bye
13:31:31 <nkaretnikov> ugh
13:32:35 <nkaretnikov> mauke: i didn't mean to offend you.  it's just that i find it difficult talking to you. :\
13:33:32 <geekosaur> nkaretnikov, you can't unwrite something to a database either
13:33:54 <nkaretnikov> geekosaur: i don't want to unwrite it
13:34:02 <nkaretnikov> i'm okay with holding it for a bit
13:34:07 <nkaretnikov> i don't know
13:34:29 <geekosaur> you really are not explaining yourself well
13:34:32 <Zekka|Sigfig> nkaretnikov: So if you already sent the packet, and you want to go back, what do you expect to happen?
13:34:43 <Zekka|Sigfig> Do you want to hold onto the packet until you get to a part of the code that says “commit”?
13:34:50 <nkaretnikov> i guess i should read more on how database transactions are implemented
13:35:11 <nkaretnikov> Zekka|Sigfig: please stop mentioning packets
13:35:21 <nkaretnikov> i have a very specific usecase, which i mentioned above
13:36:42 <Zekka|Sigfig> nkaretnikov: Oh, my mistake — it sounds like you want to hold onto your in-memory database and you’d like to have two modes — one where everything gets committed to disk automatically and one where you must manually commit to write the in-memory one to the on-disk one?
13:37:31 <nkaretnikov> i want a bunch of operations on my dbs happen atomically
13:37:47 <nkaretnikov> like a symlink switch
13:38:00 * hackagebot Rasenschach 0.1.3.2 - Soccer simulation  https://hackage.haskell.org/package/Rasenschach-0.1.3.2 (MartinWoehrle)
13:38:01 <nkaretnikov> either do it all or do nothing
13:38:26 <geekosaur> database transactions are implemented by a transaction manager in the database server.
13:38:52 <geekosaur> it sounds to me like you want to do a database transaction and only update the in-memory db if the commit succeeds
13:38:56 <Zekka|Sigfig> You can hack out transactions yourself by just refusing to replace your real copy with your scratch copy until the scratch copy is done
13:39:00 <niez> geekosaur, in database managament system, to be specific ;)
13:39:12 <Zekka|Sigfig> (replace “replace” with “write all the operations from the journal of” as needed afaik)
13:39:18 <Zekka|Sigfig> That doesn’t work in a concurrent situation, mind
13:39:21 <nkaretnikov> geekosaur: yes!
13:40:38 <nkaretnikov> sorry, i thought it's an easy thing with plenty available solutions.  didn't expect that it would take so much time to explain myself :\
13:40:54 <Zekka|Sigfig> It’s kind of common, I just assumed that you wanted something other than your database’s transaction support
13:41:07 <Zekka|Sigfig> And I don’t know what that would have been
13:41:07 <geekosaur> it's common only when the db engine can do all the work for you
13:41:37 <geekosaur> if you are doing your own db management, you are going to have to do a fair amount of work. if you are talking to a db engine, it cannot help you with a separate in-memory copy of the data
13:41:47 <nkaretnikov> geekosaur: no db engine
13:42:06 <geekosaur> ...and transaction management is precisely why people use actual db engines; it's *hard*
13:42:16 <nkaretnikov> geekosaur: the question is: can i cook up something like this on top of stm?
13:42:20 <geekosaur> so you reuse someoine else's time and effort to get it right
13:42:37 <nkaretnikov> geekosaur: the thing is that i don't need a huge db
13:42:49 <nkaretnikov> geekosaur: but this property is crucial for my sanity :)
13:42:51 <Zekka|Sigfig> If you were dealing exclusively with persistent data structures in one thread this wouldn’t be too hard, but it sounds like you’re using the disk and you might care about concurrency, which makes this stuff a little hard
13:43:02 <geekosaur> yes, exactly
13:43:03 <nkaretnikov> Zekka|Sigfig: i have a few threads
13:43:42 <nkaretnikov> okay, i'll have to think about that more
13:43:44 <nkaretnikov> thanks all
13:43:56 <geekosaur> implementing this yourself for threads in a single process could be done with STM although I am not especially familiar with doing so. multiple processes, get a real database manager
13:44:40 <geekosaur> because concurrent transactions are amazingly hard to get right
13:44:46 <nkaretnikov> we'll see, i guess you're right
13:45:06 <nkaretnikov> appreciate the heads up =)
13:45:49 <verement> nkaretnikov: can you use something like vcache?
13:46:22 <nkaretnikov> verement: haven't heard about it, will take a look
13:46:24 <nkaretnikov> later
13:53:31 * hackagebot fltkhs 0.4.0.5 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.5 (deech)
13:53:34 * hackagebot fltkhs-demos 0.0.0.7 - FLTKHS demos. Please scroll to the bottom for more information.  https://hackage.haskell.org/package/fltkhs-demos-0.0.0.7 (deech)
13:58:32 * hackagebot fltkhs-fluid-demos 0.0.0.6 - Fltkhs Fluid Demos  https://hackage.haskell.org/package/fltkhs-fluid-demos-0.0.0.6 (deech)
14:01:17 <lpaste> emmanuel_erc pasted “2D QuickHull in Haskell!” at http://lpaste.net/153291
14:01:33 <emmanuel_erc> oops sorry that was meant for #haskell-beginners
14:01:42 <emmanuel_erc> Please ignore.
14:04:59 <t7> are parsers usually  (a -> m b)  or (a -> m (a, b)) ?
14:05:27 <t7> Parsing or syntactic analysis is the process of analysing a string of symbols
14:05:45 <t7> (a -> m (a, b)) then ?
14:05:53 <Hafydd> Great definition.
14:06:13 <Zekka|Sigfig> Internally there’s often (a -> m (a, b)) somewhere but from the outside it’s typically (a -> m b) where m is a parser monad, b is the result type and a is the stream type
14:06:59 <Zekka|Sigfig> (a -> m (a, b)) is your monad m plus State
14:20:03 <augur> is it possible to compile a file inside a library cabal project to execute the file?
14:21:35 <johnw> augur: sure
14:21:43 <johnw> augur: once you use a custom builder, you can do whatever you want
14:21:57 <augur> johnw: ?
14:22:06 <johnw> what does the ? mean?
14:22:14 <augur> i dont understand what you said :P
14:22:29 <augur> im giving a demo file that people can run, along side a library
14:22:45 <johnw> Cabal projects default to using the "simple builder"
14:22:49 <augur> and im not sure how you'd actually *run* the demo file, or if you'd have to do that separate from the library in your own project or whatever
14:23:07 <johnw> that you are free to tell it to use a custom builder, where you can specify in Haskell code exactly how the project is to be built
14:23:18 <johnw>  okay, maybe we're talking about different things then
14:25:12 <augur> maybe :)
14:25:40 <augur> i mean, i guess people interested in using this file can make a new project w/ the file and load that up in GHCi?
14:25:45 <augur> sure, i guess that'll work
14:25:56 <augur> right? hmm.
14:31:54 <CLion> a
14:36:54 <Peaker> Hey, is there any nice way or alternative to wl-pprint that does constraint solving for good layouts?
14:37:41 <Peaker> wl-pprint seems to be super naive: "if reached end of width, line-break" and that inserts a line break at awful positions sometimes
14:37:59 <Peaker> (I'm trying to improve the pretty printing of language-ecmascript)
14:38:07 <Peaker> to generate sane looking JS
14:38:42 <Peaker> But if you get unlucky, and you have foo(function() { ... }) where 'foo' ends at just the right column, the entire function will be indented off the screen :(
14:48:52 <Peaker> http://www.cse.chalmers.se/~bernardy/prettiest.html <-- seems to talk about my issue exactly, pretty-compat might be what I want, yay :)
14:50:07 <orion> bitemyapp: I found a typo on your site.
14:59:46 <Peaker> how would I express a "newline and UNINDENT if no space available"?
14:59:57 <Peaker> Or "unindent" in general when using wl-pretty or pretty-compact?
15:01:42 <Peaker> I guess that's not exactly what I need, hmm
15:19:33 <Peaker> ok, pretty-compat is great :)
15:19:39 <Peaker> getting some nice looking JS now
15:19:57 <Peaker> also helps to finally understand "nest", "line", and friends :)
15:25:24 <mniip> hmm is it possible to have a GADT newtype?
15:27:43 <Peaker> mniip: what does that mean?
15:27:48 <Peaker> mniip: "data .. where" syntax?
15:27:51 <mniip> yes
15:27:58 <Peaker> (I think that's not considered a GADT but I'm not sure)
15:28:15 <Peaker> But anyway newtype has its own "newtype" syntax, I don't think "where" is supported there
15:30:07 <EvanR> i cant help by say GADT like a word but it doesnt sound like anything intellegible
15:30:20 <EvanR> so its probably bad
15:30:22 <enthropy> newtype X a where X :: a -> X a -- is supported, but if you try to do anything special that GADT allows it complains
15:37:19 <Peaker> EvanR: Gaddet
15:38:05 <Hijiri> mniip: I think the problem is a GADT might need extra runtime representation beyond just the value
15:38:21 <mniip> isn't it typechecker-only?
15:38:25 <Hijiri> for example data Bob where Bob :: Show a => a -> Bob would need the Show instance
15:38:47 <Hijiri> so it can provide show later
15:39:48 <mniip>     A newtype constructor cannot have existential type variables
15:39:51 <mniip> ah there we go
15:46:15 <Peaker> I could use ML modules now!  wl-pprint/pretty-compact have same interface, but different concrete types!
15:46:26 <Peaker> If I modify a library to use another, all of its users break!
15:46:52 <Peaker> A type-class for the entire library interface is cumbersome
15:56:09 <levi> Yeah; ML modules are really nice to have sometimes.
15:57:58 <Peaker> does stack support having the same package installed multiple times with different flags?
16:00:23 <mgsloan> Peaker: No, it unregisters the old one on flag change.  It'd be an interesting thing to consider having, though.  I believe one reason we don't support it is that "stack exec ghci" and "stack ghc" would get really confused by the ambiguous packages
16:00:40 <S11001001> mniip: yeah, I was confused about why that was at first. Now I am slightly less :)
16:01:15 <Peaker> mgsloan: changing language-ecmascript to use pretty-compat rather than wl-pprint makes the output sooo much nicer. But it changes the concrete "Doc" type breaking users! :-(
16:01:41 <mgsloan> Ah :/
16:01:48 <Peaker> pretty-compact*
16:02:01 <Peaker> Program to an interface, not an implementation!
16:03:56 <mgsloan> Stack will allow multiple versions of it to exist, though.  If there's a language-ecmascript version in your snapshot, and you set the flag, you'll get the version with the flag enabled, built in your project DB
16:04:54 <schell> is anyone using vim with in-editor errors, warnings, hlint hints, etc?
16:05:43 <ARM9> yes
16:06:43 <schell> ARM9: can i ask you which plugins you’re using, stack vs cabal sandbox, ghc version etc? i had a nice setup at one time but it seems to have degraded after “upgrading” things...
16:07:13 <Peaker> mgsloan: Maybe someone should make a pretty-doc-class package which lets you plug in whichever pretty package you want after-the-fact
16:09:04 <ARM9> neco-ghc with neocomplete, cabal (always sandbox), ghc 7.10 whatever
16:09:27 <ARM9> syntastic does the error checking with ghcmod
16:10:06 <schell> ARM9: i think the syntastic doesn’t support the newest ghcmod (and won’t going forward)
16:10:22 <schell> s/the syntastic/syntastic/g
16:10:26 <ARM9> well try something else then
16:10:46 <schell> indeed, that’s what i’m getting at here
16:10:48 <ARM9> either swap out ghcmod or syntastic, there are alternatives for both
16:11:20 <schell> hdevtools is the alternative to ghcmod - i seem to be having trouble there as well
16:12:06 <schell> the vim plugin is unmaintained and has been for at least a year - i’m trying to find out what configurations work for other people
16:14:34 <schell> i’ll try switching out syntastic 
16:24:11 <mgsloan> Peaker: That'd be cool, but not all prettyprint libraries have the same combinators
16:24:58 <Peaker> mgsloan: what different ones are there?  It could use GCD
16:25:27 <mgsloan> Yeah, that's reasonable
16:30:08 <Peaker> at least compact/leijen seem to be 100% compatible (modulo '<$>' and 'empty' that were renamed in the more modern compact one)
16:37:28 <centrica> just starting with haskell, have a question
16:37:40 <centrica> is there a qay to recompile and reload modules
16:37:51 <centrica> programatically
16:38:27 <centrica> e.g. i have modules that depend on other ones
16:38:41 <centrica> A -> B -> C, E -> F, G -> H -> I -> J
16:39:09 <centrica> is there a way to say "reload and recompile A"
16:39:17 <erikd> centrica: in GHCi?
16:39:23 <centrica> which would reload and recompile B and C on which A dependencies
16:39:25 <gargawel> centrica: you mean, dynamically ?
16:39:32 <centrica> erikd: no, within another haskell app
16:39:36 <gargawel> in a compiled program ?
16:39:59 <schell> you’re loosly talking about building a plugin architecture 
16:40:07 <centrica> gargawel: in a compiled program, however modules (A, B, ... above) can be interpreted
16:40:36 <centrica> schell: probably - new to haskell, any pointers that i can read specifically about this?
16:40:43 <gargawel> centrica: I don't think there is something like that, but don't take my word for it
16:40:47 <centrica> i.e. dynamic recompiling and reloading
16:40:53 <gargawel> some people might have done experiments
16:40:54 <centrica> gargawel: ok, thanks!
16:41:17 <schell> centrica: i’ve looked into it very very briefly 
16:41:21 <schell> you may want to check out http://hackage.haskell.org/package/hint
16:41:28 <gargawel> I truly wonder why you would want to do such a thing, though
16:41:36 <centrica> schell: thanks, will check it out
16:41:37 <gargawel> May I ask what is your use-case ?
16:41:45 <centrica> gargawel: sure, let me try to summarize
16:42:28 <centrica> basically i want to have quick prototyping turnaround time
16:42:42 <centrica> let's say i want to make a web page
16:42:47 <centrica> so pure html, nothing fancy
16:43:05 <centrica> from what i understood, i can use things like yesod, snap, etc
16:43:14 <schell> centrica: http://hackage.haskell.org/package/plugins
16:43:33 <centrica> but, i also want to have the ability to use the code outside the web server
16:43:35 <gargawel> centrica: OK, so it's more of a programming workflow issue
16:43:41 <gargawel> am I right ?
16:44:05 <centrica> i would agree - if i understand the other workflows correctly, they are all modify, compile, see the results
16:44:10 <centrica> trying to avoid the wasted time there
16:44:20 <gargawel> You can use the GHCi - the REPL
16:44:43 <gargawel> use the -fobject-code to enjoy very fast reload
16:44:50 <gargawel> type:
16:44:52 <gargawel> :r
16:44:54 <gargawel> main
16:45:19 <gargawel> it's normally very fast and you don't have to suffer long compilation times
16:45:26 <centrica> so you are saying within ghci i can edit the file and it will reload the module behind the scenes?
16:45:31 <EvanR> thats still a lot relative to auto-reloading webdev stuff
16:45:44 <centrica> trying to understand how it will behave with the other parts of the app
16:45:58 <gargawel> It will not do it on itself, you will have to ask for it
16:46:27 <gargawel> for Yesod specifically, I think there is some utility to automatically recompile / relaunch your server when you modify something
16:46:32 <EvanR> you can make the app into components and recompile / reboot pieces that change in response to a file system event
16:46:45 <EvanR> but relinking takes time
16:47:12 <centrica> gargawel: ok, but when it reloads, how will the "old" parts react to that?
16:47:24 <schell> centrica: you can also use https://github.com/schell/steeloverseer to build your project for you after filesystem events
16:47:27 <centrica> EvanR: thanks, just exploring here - not sure hwat the best way is
16:47:40 <centrica> schell: thanks, but that's the whole rebuild, correct?
16:47:47 <schell> it’s really whatever you like
16:47:48 <centrica> i guess i'm trying to find a way to recompile just parts
16:47:56 <gargawel> centrica: it will reload everything that needs to be reloaded
16:48:01 <centrica> say i have 100 modules and i change 1, will it recompile 1 or 100?
16:48:03 <schell> you specify file name patterns to match on and then commands to run
16:48:11 <gargawel> (ie. that depends, either directly or transitively, on something that changed)
16:48:15 <Peaker> The "Haskell is not for Production" talk seems to use an ApplicativeDo example that is not actually Applicative?
16:48:37 <centrica> schell: ok, so that's more a file notify only and it will issue a full build
16:48:56 <Cale> Peaker: haha, what's this?
16:49:03 <gargawel> centrica: a "full build" is only as "full" as needed
16:49:06 <schell> centrica: cabal and stack are both pretty good about only building things that change or things that depend on things that change
16:49:25 <Peaker> Cale: https://www.youtube.com/watch?v=mlTO510zO78 <-- I left out "and other myths" suffix :)
16:49:26 <schell> of course you still need to link but that’s pretty minimal
16:49:32 <Peaker> (oops: other tales)
16:49:48 <centrica> ok, so it might be quick enough to just use steeloverseer
16:49:53 <centrica> or something along those lines
16:50:13 <schell> yeah - you should also check out https://github.com/lukexi/halive
16:50:37 <schell> i’ve had less luck with halive, but i wrote the original version of steeloverseer - so i’m biased
16:50:47 <centrica> ok, thanks guys - this is plenty for a newbie :)
16:50:54 <Cale> Peaker: oh, the Haxl thing? I thought it was supposed to actually be Applicative...
16:51:03 <gargawel> centrica: I would highly suggest the GHCi approach though, as you will evade long linking times that can slow down your workflow
16:51:10 <gargawel> s/evade/avoid/
16:51:22 <centrica> gargawel: i think that makes sense, as this is mostly for development only
16:51:31 <Peaker> Cale: Yeah, it is more efficient when Applicative is used rather than Monad. ApplicativeDo is useful there. She brings up a specific example that looks like do notation for: getFriends >>= filterM likesPython
16:51:38 <centrica> i.e. i don't need the code running in "production"
16:51:44 <Peaker> Cale: so I don't think the extension would do anything useful in that example
16:51:49 <schell> gargawel: do you know of a way to issue a running GHCi process commands from the command line?
16:51:49 <Cale> ah
16:51:50 <Cale> yeah
16:51:51 <centrica> just the product of the code
16:52:08 <gargawel> schell: no, that would be amazing though
16:52:49 <EvanR> yeah with that you could auto reload
16:52:58 <EvanR> a hack for that should exist
16:53:06 <centrica> maybe wrap using things such as http://code.haskell.org/haskellmode-emacs/haskell-ghci.el
16:53:40 <centrica> i.e. that line of thinking, instead of pure command line approach
16:54:04 <EvanR> yeah through the text editor seems like the most plausible route
16:54:17 <EvanR> since the editor can listen on a port
16:54:22 <EvanR> and control ghci
16:55:07 <dmj`> anyone know how to pretty-print html text?
16:55:28 <gargawel> that seems relevant: https://github.com/chrisdone/ghci-reload-demo
16:56:04 <centrica> gargawel: thanks, i'll look into this
16:56:16 <schell> EvanR, gargawel: i was just looking for that
16:56:20 <schell> thanks
16:56:31 <gargawel> :)
16:57:52 <schell> i’m actually starting to think this is what halive is based on
17:14:17 <lifter> Anyone know what "maximum slop" is? (It's a heap-related statistic in Threadscope, but I don't know what it means.)
17:14:41 <shachaf> @google ghc slop
17:14:42 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Slop
17:16:00 <lifter> thanks
17:41:51 <Peaker> did 7.10.3 fix the fundep inference bugs 7.10 introduced?
17:47:42 <Peaker> why does cabal recompile EVERYTHING if I change a single .cabal dependency? :(
17:48:40 <enthropy> Peaker: I don't think so. My understanding is that ghc 7.8 allowing more instances for a given fundep was a bug that got fixed
17:48:54 <adu> where do I go for literate programming?
17:48:55 <Peaker> ah
17:49:13 <enthropy> but maybe we're talking about different "bugs"
17:50:34 <Peaker> enthropy: IIRC lens tuple stuff (_1, _2, etc) stopped type checking in some cases
18:15:52 <haskell634> Does anyone know if the GHCi, version 7.10.3 has Data.Fraction module with it? I am new to Haskell and i'm not sure if these kinds of modules are automatically imported once you install Haskell. Thank you.
18:22:50 <pavonia> haskell634: I don't think this module comes with GHC but you can easily install it e.g. with cabal-install
18:23:47 <fr33domlover> How do I debug this: I'm writing a web app with Yesod. One of my form fields uses 'checkM' to validate the input against the DB. However when it calls 'checkUnique' it seems to never return and I never get a response back. I tried 'checkUnique' in GHCi. Then it does work. Only with the actual scaffolded site ("runDB $ checkUnique ...) it never returns
18:24:13 <fr33domlover> I wrapped it with 'catch' but it doesn't seem to throw either,simply doesn't return
18:27:29 <fr33domlover> I also checked postgresql logs which clearly show a connection was made
18:28:53 * hackagebot ty 0.1.7 - Typed type representations and equality proofs  https://hackage.haskell.org/package/ty-0.1.7 (ConalElliott)
18:50:53 <fr33domlover> ah, found the bug. so silly: I wrote "project = project {...}" instead of "project = Project {...}"
18:51:06 <fr33domlover> one-letter typo caused infinite loop
18:51:58 <kadoban> fr33domlover: Heh, woops :-/
18:52:49 <fr33domlover> kadoban, yeah, I wish GHC could warn about these cases. It's one of the recurring runtime bugs i generally have in my projects
18:53:20 <fr33domlover> most other things just cause a type error... but not this one unfortunately
18:53:23 <ggVGc> fr33domlover: maybe you should adopt not naming instances with the same name but lowercased
18:53:32 <ggVGc> I know itäs convenient, but for cases like this itäs worth avoiding
18:54:13 <fr33domlover> ggVGc, good point. I could call it 'proj' or 'theProject' or something
18:55:37 <EvanR> fr33domlover: data Project = MkProject {...
18:56:09 <EvanR> though x = ... x ... can't really be protected against since that is "A-OK" in haskell
18:56:27 <EvanR> just like + on anything is OK in js
18:56:44 <fr33domlover> EvanR, I'm using Persistent
18:56:59 <fr33domlover> it auto generates the type definitions with TH
18:57:29 <EvanR> another remark is another horray for single-letter variable names ;)
18:57:36 <EvanR> p = Project ...
18:57:55 <danharaj> jfischoff: hey there handsome
18:58:22 * jmcarthur had to check what channel he was in
18:58:51 <jfischoff> ahhhh I feel all warm and fuzzy inside
18:59:03 <danharaj> jfischoff: why don't you call anymore baby?
18:59:08 <danharaj> i didn't see you at compose or nothing
18:59:21 <jfischoff> Fam time
18:59:25 <danharaj> d'aw
18:59:54 <danharaj> we should get lunch sometime and reminisce about the shit pile you inherited from me
19:00:06 <jfischoff> we inherited together
19:00:19 <jfischoff> funny I was just thinking I should open source ddl
19:00:23 <danharaj> my sins run deeper than you know in that code base
19:00:32 <danharaj> oh you like it?
19:00:34 <danharaj> i'm flattered
19:00:51 <jfischoff> seems like something that could exist on it’s own
19:01:13 <Ralith> is there a package to place the stdout of a command at compiletime into a file as a bytestring
19:01:20 <Ralith> kind of like file-embed
19:01:42 <Ralith> I want to get my git tag/revisions into my program without manually editing them in all the time
19:01:48 <EvanR> theres TH
19:02:02 <EvanR> ah premade package...
19:02:07 <jfischoff> danharaj: we might hire someone who worked on nicki minaj song
19:02:17 <jfischoff> err not song website
19:02:47 <danharaj> i would hire them
19:02:47 <kadoban> Ralith: gitrev ? https://github.com/acfoltzer/gitrev
19:03:01 <Ralith> ooh, that works too
19:03:02 <Ralith> thanks!
19:03:07 <jfischoff> danharaj: yes yes you would
19:03:17 <danharaj> that's a good package, thanks for mentioning it kadoban
19:03:32 <Ralith> from the readme it sounds like it doesn't do tag names, just hashes?
19:03:34 <Ralith> still nice
19:03:37 <danharaj> jfischoff: well there's a reason why no one puts me in charge of anything :)
19:04:39 <kadoban> Ralith: I think 'gitBranch' will do what you want, despite its name
19:04:53 <akbiggs> does anyone have any recommendations for a good testing workflow? I've been googling around for something that runs "stack test" automatically when any haskell files change, but haven't had any luck so far
19:05:00 <kadoban> Ralith: At least if you have a tag checked out. I don't think it's as smart as like 'git describe'
19:05:31 <kadoban> akbiggs: stack has --file-watch on all of the build commands
19:05:46 * Ralith would really like git describe --tags >_>
19:05:48 <akbiggs> kadoban: oh sweet!
19:05:55 <Ralith> oh well at least I can crib the code here
19:06:27 <Cale> Oh, you could also just grab a script like https://gist.github.com/senko/1154509 or something from somewhere that uses inotify to watch files and do some command
19:13:56 * hackagebot libxls 0.2 - Bindings to libxls  https://hackage.haskell.org/package/libxls-0.2 (uuhan)
19:13:58 * hackagebot hadoop-rpc 1.1.0.0 - Use the Hadoop RPC interface from Haskell.  https://hackage.haskell.org/package/hadoop-rpc-1.1.0.0 (JacobStanley)
19:28:57 * hackagebot hadoop-tools 1.0.0 - Fast command line tools for working with Hadoop.  https://hackage.haskell.org/package/hadoop-tools-1.0.0 (JacobStanley)
19:29:53 <ReinH> @google facebook watchman
19:29:56 <lambdabot> https://facebook.github.io/watchman/
19:30:05 <ReinH> Relatively good file watcher thing
19:33:30 <Cale> ReinH: cool, thanks. I knew there would be something better :)
19:43:40 <akbiggs> hey, also, has anyone had any troubles getting neomake to show the left-side gutter in stack projects? it seems that if I have it running in a file that's in the folder created by "stack new", I don't get the left-side gutter with error/warning hints, but if I take the same file and copy it outside of the stack-created directory, I get the left-side gutter.
19:43:58 * hackagebot hadoop-tools 1.0.1 - Fast command line tools for working with Hadoop.  https://hackage.haskell.org/package/hadoop-tools-1.0.1 (JacobStanley)
19:46:30 <akbiggs> I grabbed a log from neovim but didn't see anything suspect in it
19:46:49 <EvanR> fr33domlover: another one that seems hazardous is the frequency use of code where you have a variable foo, and then another foo'. dont mix them up or the typechecker will laugh at you (silently)
19:46:57 <EvanR> frequent*
19:48:28 <mattn> I’m having a problem with accelerate’s array type that I think indicates I’m missing some conceptual piece about how it operates.
19:49:47 <mattn> If I have a singleton list [1.0 :+ 2.0] :: [Complex Double] and apply “fromList (Z :. 1)” to it, I end up with Array (Z :. 1) [2.0 :+ 2.0]
19:50:01 <mattn> why is the imaginary part duplicating itself into the real part?!
19:51:31 <jmcarthur> mattn: I'm not familiar with accelerate, but (fromList (Z :. 1)) looks like something I would expect to behave like a natural transformation, so your result looks really surprising. It could be a bug.
19:54:38 <mattn> jmcarthur: glad it seems unexpected to others, too :)  The relevant instance (I think) for Elt a => Elt (Complex a) looks totally normal, so I’m a bit at a loss.
19:56:20 <jmcarthur> mattn: Which backend are you using?
19:57:11 <mattn> same behavior on both llmv and the interpreter, though I think the Array type is backend-independent
19:57:16 <mattn> *llvm
19:58:07 <mattn> (and accelerate-2.0.0.0)
20:02:30 <shachaf> λ> fromList (Z :. 1) [1.0 :+ 2.0] :: Vector (Complex Double)
20:02:30 <shachaf> Array (Z :. 1) [1.0 :+ 2.0]
20:02:36 <shachaf> How are you getting that behavior?
20:02:37 <mattn> :(
20:03:14 <mattn> compiled, and showing the list and the vector
20:04:25 <mattn> and I can’t run ghci on this project because of some dynamic linking C++ thing on os x :|
20:05:55 <shachaf> Which version are you running?
20:06:10 <shachaf> And what's the full actual code you're running?
20:08:00 <mattn> hang on, I’ll paste.  Also, I just ran stack ghci from outside the project and got the same behavior as you did.  So I’m almost certainly doing something silly.
20:12:45 <mattn> shachaf: http://lpaste.net/153303
20:14:24 <mattn> a bunch of these are run concurrently, though I wouldn’t expect that to effect on anything..
20:17:51 <shachaf> It happens even when you only run one?
20:19:06 <mattn> I’ll check.
20:22:18 <mattn> yeah, same behavior even with “main = f [1.0 :+ 2.0]"
20:24:01 <mattn> same wrong behavior, that is. prints “[1.0 :+ 2.0]  =>  Array (Z :. 1) [2.0 :+ 2.0]"
20:37:25 <mattn> shachaf: aha, narrowed it down slightly. I’m seeing the problem when using accelerate >= 2 but not accelerate-0.15
20:58:41 <adas> is the usage of TemplateHaskell a code smell? I mean I know it has its uses but is there anything that can only be done in TemplateHaskell that cannot be done any other way?
21:01:00 <Hijiri> generation of mechanical typeclass instances? (Without using Data, at least)
21:01:15 <Hijiri> lens uses TH for lens generation
21:01:55 <Hijiri> I don't know if Data provides the names of record fields
21:03:12 <shachaf> There's always upon.
21:03:18 <adas> upon?
21:03:31 <shachaf> > over (upon snd) (+1) (5,6)
21:03:34 <lambdabot>  (5,7)
21:03:44 <shachaf> > set (upon head) 0 [1,2,3,4]
21:03:47 <lambdabot>  [0,2,3,4]
21:04:04 <shachaf> > set (upon tail) "cd" "ab"
21:04:08 <lambdabot>  "acd"
21:05:13 <adas> so there are some things that cannot be done without TH?
21:05:20 <adas> or atleast thats what it looks like
21:08:52 <zenguine> hey is anyone here doing haskell dev on nixos? got a question about stack vs nix.
21:09:38 <zenguine> it seems like if you are writing nix expression to set up a nix-shell environment anyways, there isn't much of a reason to use stack at all.  Is this accurate, or is there something else that stack provides that nix doesn't that still warrants its use?
21:09:44 <adas> stack is alwasy better
21:09:52 <adas> just kidding.
21:09:59 <adas> i know nothing of nix. could be better
21:10:18 <zenguine> ha okay
21:15:54 <Ralith> zenguine: I think stack is nice because it's more amenable to collaboration with non-nixos users
21:16:11 <Ralith> also, you can gnerate your nix-shell environment *from* your stack file, so there's not too much duplication of effort
21:16:27 <mightybyte> What might be some of the causes of "multiple definition" linker errors when building cabal projects?
21:19:34 <EvanR> adas: re cannot be done without TH... you cant have the type checker verify your database schema at compile time without it!
21:19:46 <EvanR> you can verify it at runtime but, thats a little late
21:23:01 <zenguine> Ralith: that makes sense. though I'm not quite clear on how nix expressions can be generated from stack.yaml files.  I know about cabal2nix, but is there a tool that is also able to take both the project cabal file and stack file and figure out the correct versions from the stack resolver?'
21:23:19 <adas> EvanR: but in general, is usage of TH frowned upon? cos I read a bunch of stackoverflow questions about why TH is a bad idea which is absolutely necessary but should have been implemented differently?
21:23:54 <glguy> mightybyte: Foreign exports conflicting with existing names? Conflicting external symbols from c-sources? Or are you getting conflicts with GHC-generated names?
21:24:12 <adas> SO question -> https://stackoverflow.com/questions/10857030/whats-so-bad-about-template-haskell
21:24:16 <EvanR> i dont know what the attitude is in general, but ive never seen anyone in here recommend against it, and its used in many popular libraries
21:24:23 <Ralith> zenguine: yes, that tool is stack :P
21:24:38 <Ralith> http://docs.haskellstack.org/en/stable/nix_integration/
21:25:20 <EvanR> its not nearly as bad as macro programming since you have the type system to help during and after the template process
21:25:33 <Ralith> adas: stackoverflow is not a reliable source
21:25:44 <Ralith> TH has its place
21:25:51 <adas> but isn't it easy to create badly typed code using TH?
21:26:02 <adas> or rather wrongly typed code in TH?
21:26:08 <EvanR> its not going to compile
21:26:19 <glguy> 1) the type checker types is after you generate it 2) there is "typed" template haskell that is less powerful but typed
21:27:12 <EvanR> at least the AST has types
21:27:34 <adas> oh so you mean to say that after TH does its thing, all the code including TH generated code is type checked? So even if TH produces wrongly typed expression its caught at compile time?
21:28:06 <EvanR> yeah, and you cant produce misspelled code like in lisp because youre building an AST
21:28:20 <EvanR> well, like javascript eval
21:29:03 <adas> EvanR: misspelled code?
21:29:09 <EvanR> if _ then _ else is a structure rather than a string, so you cant screw up with if _ tehn _ else
21:29:36 <adas> ah okay
21:29:38 <EvanR> if _ then _ else _
21:30:22 <adas> i wish lambdabot did some TH so I coudl see a very trivial exampel of TH right here, right now
21:30:30 <EvanR> ghci
21:31:17 <zenguine> Ralith: ahh that looks cool. Wasn't using a new enough version of stack it seems.'
21:31:22 <zenguine> Ralith: thanks
21:41:32 <mightybyte> glguy: It's this issue.  https://github.com/phonohawk/HsOpenSSL/issues/50
21:42:21 <mightybyte> glguy: I started seeing this issue on our CircleCI build.  It doesn't happen on my local mac build though.
21:45:04 <glguy> mightybyte: possibly relevant could be that the duplicated symbols come from an HSC module
21:45:32 <glguy> It could be something like hsc2hs was used in the source tree and is creating a .hs file that's getting compiled
21:45:48 <glguy> and there's a stray .o or .hs in the build diretcory
21:46:11 <mightybyte> glguy: Hmmm
21:46:32 <glguy> This is on a clean build though?
21:46:47 <mightybyte> Yeah
21:47:12 <mightybyte> And I even ssh'd into the machine and tried just HsOpenSSL standalone and it didn't work.
21:47:53 <luigy> mightybyte oh I remember seeing that
21:48:05 <mightybyte> luigy: Oh?
21:48:27 <luigy> one sec let me fetch solution
21:48:38 <mightybyte> luigy: Thanks!
21:49:08 <mightybyte> I even tried doing "cabal get HsOpenSSL" and then cabal installing directly from the directory and that didn't work either.
21:49:26 <luigy> mightybyte https://github.com/commercialhaskell/stack/issues/1658#issuecomment-171961580
21:49:30 <luigy> looks similar
21:54:03 <mightybyte> luigy: That looks really promising.  Thank you so much!
21:57:23 <mightybyte> luigy: Yes, it worked!
22:05:24 <luigy> nice! :)
22:22:25 <roelof> Hello, anyone who knows how to get Prelude.Compat into stack. Im trying out the new servant tutorial and stack build cannot find it 
22:24:07 <Axman6> roelof: what errors are you getting?
22:24:15 <kadoban> roelof: It's from the base-compat package apparently, which you can specify as a dependency if you have a .cabal file associated with the code you're talking about.
22:24:35 <kadoban> In other contexts, you can use the --package argument, like 'stack ghci --package base-compat'
22:25:42 <roelof> kadoban:  thanks, package builds now 
22:38:00 <mattn> wow, I added a bug report for the accelerate issue and it is already fixed, in only an hour or so!
22:39:07 <mattn> good thing too, because despite finding myself in the right part of the codebase, I’m not sure I would have figured out the problem (needed an unsafeInterleaveIO instead of unsafePerformIO)
22:40:46 <Surendra> hello
22:41:46 <Surendra> I am planning to learn Haskell. Does Haskell has built in libraries for distributed computing?
22:42:46 <lieven> Surendra: yeah. it's good for that. Check out Marlow's book Parallel and Concurrent Programming
22:44:37 <Surendra> thanks. basically i am going thru Learn you haskell for great good. Any idea how is Haskell in  terms of performance compared to Java/C++( I am not looking for milli seconds comparison but is Haskell comaparble to c++/java?)
22:45:05 <mauke> (oh yes, you can definitely compare it)
22:45:17 <lieven> lol I was thinking of a reply along these lines
22:45:35 <Surendra> I heard functional languages are great choice for specific types of apps. For network/io heavy apps ?
22:45:36 <EvanR> ghc green threads are very fast
22:45:56 <Surendra> ok. great.
22:46:23 <liste> Surendra: also parallel processing is MUCH easier using FP
22:46:27 <Cale> Haskell *is* pretty general purpose though.
22:46:46 <Surendra> ok.
22:47:15 <mauke> haskell is the only language where threads are kind of fun
22:47:34 <Surendra> cool.
22:47:43 <mauke> (writing async exception safe code is still a PITA)
22:47:55 <EvanR> unless you use async!
22:48:20 <Cale> At the place where I work, we're using Haskell to write web applications for a variety of clients. Both our frontends and backends are written in Haskell -- the frontends using reflex-dom compiled via ghcjs to Javascript, and the backends typically using Snap along with a database framework to store things in a postgres database.
22:48:22 <mauke> how does async help with that?
22:48:29 <EvanR> it does it for you
22:48:35 <mauke> does what?
22:48:52 <kadoban> Surendra: By the way, LYAH is not good on its own. Have a look at https://github.com/bitemyapp/learnhaskell or ever better: http://haskellbook.com/
22:48:53 <johnw> async at least sets up propagation nicely
22:48:55 <EvanR> run async code in a way that is async exception safe
22:49:05 <EvanR> at least for the setup and take down part
22:49:29 <mauke> as in the part where nothing happens? :-)
22:49:42 <EvanR> that part is a PITA
22:49:43 <Surendra> ok thanks all. I will sure go thru these books. 
22:49:53 <EvanR> but yeah
22:50:05 <montanonic> Cale: how's reflex-dom's performance for y'all?
22:50:15 <montanonic> Cale: do you end up diving much into naked JS code?
22:50:17 <Cale> montanonic: Perfectly fine.
22:50:38 <Cale> Haven't had a problem with performance, at least since I started using it.
22:50:46 <johnw> Cale: how about memory?
22:50:49 <johnw> are leaks common?
22:51:05 <montanonic> good to know; I'm a PureScript user and I've been a bit reserved with using Haskell libraries for JS stuff
22:51:22 <Cale> Not really, at least for the sort of applications we've been writing.
22:52:43 <Cale> The main, really serious, performance issue is the amount of time that it takes GHCJS to compile anything involving Template Haskell
22:52:48 <Cale> It's sort of ridiculous.
22:52:58 <Cale> But the applications themselves run quite well.
22:53:33 <montanonic> thanks for the info Cale 
22:56:06 <nineonine> greeetings !
22:56:23 <nineonine> im experiencing troubles with making epub file 
22:56:29 <nineonine> https://github.com/nineonine/wiwinwlh
22:56:34 <nineonine> im following instructions
22:56:38 <nineonine> when i do make
22:56:39 <nineonine> i get
22:56:52 <nineonine> ghc: can't find a package database at .cabal-sandbox/*-packages.conf.d
22:56:56 <nineonine> when i use stack
22:56:57 <nineonine> i get
22:57:19 <nineonine> Could not find module ‘Text.Pandoc’
22:57:28 <nineonine> Could not find module ‘Text.Pandoc.Error’
23:00:08 <kadoban> nineonine: You'll probably have to edit the makefile. It looks like it's hardcoded to use cabal's sandbox (in a way that looks broken?) or just plain ghc with nothing.
23:01:19 <nineonine> http://lpaste.net/153306
23:01:38 <nineonine> yeah i see some condition there
23:03:11 <nineonine> thanks for pointing !
23:25:07 <juri_> so, all code that uses base has to print out.. what exactly?
23:25:22 * juri_ starts to dig into licensing.
23:25:48 <srhb> juri_: _print_ out?
23:26:03 <juri_> Redistributions in binary form must reproduce the above copyright notice,
23:26:03 <juri_> this list of conditions and the following disclaimer in the documentation
23:26:04 <juri_> and/or other materials provided with the distribution.
23:27:00 <srhb> juri_: reproduce as in that file must follow along. Not necessarily be printed out by the program.
23:27:04 <juri_> standard bsd3 clause.
23:27:08 <Shockk> "in the documentation and/or other materials provided with the distribution"
23:34:10 <EvanR> join :: IO (IO a) -> IO a
23:34:15 * hackagebot vulkan 1.0.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.0.0.0 (jophish)
23:34:32 <EvanR> how is that supposed to be interpreted in english
23:34:40 <EvanR> in context of IO
23:35:18 <johnw> an action resulting in an action resulting in a value can be transformed into an action resulting in a value
23:35:44 <EvanR> yes thats what it says, now what is the meaning of the resulting action?
23:36:25 <johnw> it aggregates any effects by sequencing them
23:36:33 <EvanR> which effects?
23:36:42 <johnw> from IO[1] (IO[2] a)
23:36:48 <johnw> it becomes IO[1, 2] a
23:36:50 <johnw> effectively
23:37:06 <johnw> that is, whatever IO[1] did, and IO[2] did, IO[1,2] will do both of those things
23:37:13 <lyxia> a program which produces a program and runs it
23:37:44 <EvanR> hold on... the IO that resulted from the arguments execution is also executed?
23:37:50 <EvanR> doesnt seem right
23:38:06 <johnw> no execution is happening in 'join'
23:38:11 <verement> @src join
23:38:12 <lambdabot> join x = x >>= id
23:38:15 <EvanR> i use join the get the action and not use it yet
23:38:19 <johnw> right
23:38:30 <johnw> it does not "run" anything
23:38:42 <EvanR> so i dont see how IO[2] effects come into play
23:38:49 <johnw> that's what join is
23:39:00 <johnw> I mean, that's exactly what it is defined to do in this case
23:39:02 <EvanR> in a normal monad yeah
23:39:04 <xnool> does String lie within Ord?
23:39:09 <johnw> in IO
23:39:17 <johnw> oh, you mean for Haskell's implementation of IO specifically?
23:39:19 <xnool> implement*
23:39:30 <liste> > "a" > "b"
23:39:32 <lambdabot>  False
23:39:32 <EvanR> no im trying ot understand platonic IO
23:39:48 <EvanR> specifically join
23:39:49 <xnool> > "a" < "b"
23:39:50 <xnool> thx
23:39:52 <lambdabot>  True
23:40:06 <xnool> dunno why i didn't just try that.
23:40:24 <Shockk> xnool: there's an instance of Ord Char and also of Ord a => Ord [a]
23:40:38 <EvanR> johnw: could you say that, the result is an action that does the effects of the arugment, and simply returns the result action as is?
23:40:58 <xnool> oic
23:41:07 <xnool> didn't know the latter
23:41:33 <EvanR> (in IO)
23:41:48 <johnw> EvanR: imagine IO[1] is a program; the result of that program is another program, IO[2].  The job of IO[2] was to produce an value.  IO[1,2] is the concatenation of those two programs, in order to produce the same value.
23:42:14 <johnw> I guess I need to understand better where the confusion lies
23:42:22 <EvanR> ok heres a program
23:42:41 <EvanR> do{ io <- join foo; return io }
23:42:50 <EvanR> this is equivalent to join foo right
23:43:05 <johnw> right
23:43:14 <EvanR> i get the result io, and it wasnt executed
23:43:18 <EvanR> so no IO[2]
23:43:30 <EvanR> maybe they arent equivalent
23:43:31 <johnw> why do you say that?
23:43:35 <johnw> you called "join"
23:43:46 <EvanR> i mean no IO[1,2]
23:43:52 <EvanR> just IO[1], and i have IO[2]
23:43:57 <johnw> hmm?
23:43:59 <johnw> i don't follow
23:44:10 <johnw> the type of foo here is IO[1] (IO[2] a)
23:44:17 <EvanR> if i execute the above program, ill end up with only the effects IO[1]
23:44:25 <johnw> no
23:44:30 <johnw> you'd have the effects from both
23:44:39 <johnw> join will turn foo here into IO[1,2] a
23:44:56 <EvanR> oh
23:45:00 <EvanR> my variable i named wrong
23:45:04 <EvanR> its not an io
23:45:12 <johnw> no, it's not
23:45:23 <EvanR> ok, so join doesnt both 
23:45:29 <EvanR> join DOES both
23:45:35 <EvanR> far out
23:45:51 <johnw> join gives you back an action that does both
23:46:20 <EvanR> and the more familiar program io1 >> io2 can be represented as a IO (IO _) as...
23:46:37 <johnw> >> has a join deep inside
23:46:59 <johnw> a >> b is a >>= \_ -> b which is join (fmap (\_ -> b) a)
23:47:07 <EvanR> ok
23:47:28 <EvanR> fmap (\_ -> b) a :: IO (IO _)
23:48:04 <johnw> correct
23:48:37 <EvanR> it is funny how in actual use it seems like it only does 1
23:48:43 <EvanR> when inside of do notation
23:48:53 <johnw> what does it seem like that?
23:49:23 <EvanR> no it doesnt... since youre getting the `a' 
23:49:25 <EvanR> nevermind
23:50:05 <johnw> there's another way to think of this
23:50:06 <EvanR> concatting two actions, like a monoid
23:50:18 <johnw> think of IO as an abstract syntax tree that will be evaluated at runtime
23:50:25 <johnw> this AST describes what you want done by that runtime
23:50:34 <johnw> so, AST (AST a) is an AST whose leaves contain ASTs
23:50:58 <johnw> it's usually pretty straightforward to "flatten" such an AST by grafting those leaves into the structure
23:52:57 <EvanR> so F (F a) seems to be an odd way to describe a binary input type
23:53:11 <EvanR> for an operation like join
23:53:27 <EvanR> why is it like that in haskell
23:53:28 <johnw> "binary input type"?
23:53:38 <EvanR> yes the join is the mappend of some monoid somewhere right
23:53:49 <EvanR> usually oyu see A x A ->
23:53:54 <johnw> the monoid object in question is ([Hask,Hask],Compose,Identity)
23:54:01 <johnw> so it's (F ∘ F) a
23:54:07 <johnw> with composition being the mappend
23:54:08 <EvanR> ah compose
23:55:05 <EvanR> :k Compose
23:55:07 <lambdabot>     Not in scope: type constructor or class ‘Compose’
23:55:36 <shanemikel> is it supported, compiling to core, or whatever the intermediate lang is called in one place, and finishing compilation on target archs?
23:56:02 <johnw> shanemikel: interesting question
23:56:29 <phadej> AFAIK Core doesn't have "over the wire" serialisation
23:56:59 <EvanR> this project was experimenting with messing with core somehow https://github.com/conal/lambda-ccc
23:57:28 <shanemikel> phadej: that's not inhibiting, though
23:57:35 <EvanR> but i dont think it was going to compile it the last mile with ghc
23:58:12 <shanemikel> it has a text repr, right? that's a serialization
23:58:13 <EvanR> you can try C output
23:59:02 <phadej> shanemikel: but it doesn't have a parser
23:59:56 <shanemikel> then there's a big gap in my understanding of what core is
