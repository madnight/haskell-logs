00:00:06 <jle`> MonadReader is an interface over many things that you can 'ask'
00:00:10 <jle`> it's a typeclass
00:00:20 <jle`> just like how Eq is a typeclass over things that support (==)
00:00:25 <saurabhnanda> EvanR: ask is my attack vector. My overall conquest is to understand Reader properly.
00:00:34 <EvanR> well then concentrate on just Reader
00:00:38 <saurabhnanda> jle`: got that
00:00:52 <jle`> so yeah, if you want to understand Reader, don't worry about MonadReader
00:00:57 <EvanR> Reader r can be implemented as (r ->)
00:00:59 <saurabhnanda> jle`: so, Reader "implements" MonadReader, which means that it supports 'ask'
00:01:02 <jle`> yes
00:01:06 <EvanR> though its apparently not in real life
00:01:35 <jle`> saurabhnanda: a 'Reader r a' is an *action* that, when executed, returns a value of type 'a'
00:01:41 <saurabhnanda> EvanR: i can't concentrate on Reader, because just inspecting types throws up ReaderT and MonadReader
00:01:51 <jle`> the "execution" of a `Reader r a` is done with runReader :: Reader r a -> r -> a
00:01:52 <EvanR> saurabhnanda: thats why were giving you the simplified types
00:01:59 <EvanR> ask :: Reader r r
00:02:08 <EvanR> runReader :: Reader r a -> r -> a
00:02:16 <EvanR> return :: a -> Reader r a
00:02:27 <roelof> Hello, I have to make a Vigenère cipher. I think I can make the lists even length with cycle.  But how can I take care that when I have to decode the first character I also have the first character of the code-word 
00:02:47 <EvanR> (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b
00:02:59 <EvanR> and thats all there is to it
00:03:04 <liste> :t zip -- roelof, will this help?
00:03:05 <lambdabot> [a] -> [b] -> [(a, b)]
00:03:05 <cocreature> roelof: zip them?
00:03:48 <roelof> > zip [1,2,3] [ 4,5,6] 
00:03:50 <lambdabot>  [(1,4),(2,5),(3,6)]
00:03:52 <jle`> saurabhnanda: so, 'ask' is a 'Reader r r', a Reader action whose result is simply to return the environment
00:04:02 <liste> > zip (cycle [1,2,3]) [1..]
00:04:03 <lambdabot>  [(1,1),(2,2),(3,3),(1,4),(2,5),(3,6),(1,7),(2,8),(3,9),(1,10),(2,11),(3,12),...
00:05:23 <roelof> oke, so the first character of the to decode word and the first character of the code-word are then in a tuple 
00:05:27 <roelof> nice 
00:05:42 <saurabhnanda> hmm
00:05:59 <roelof> then I can use map or foldr to decode things  :) 
00:06:16 <liste> :t zipWith -- roelof: if you want to skip the tuple altogether, you can use this, though IMO having the tuple is more readable
00:06:17 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
00:06:29 <liste> zip == zipWith (,)
00:06:37 <EvanR> funny i never use zip ;)
00:06:52 <saurabhnanda> :t runReader
00:06:53 <lambdabot> Reader r a -> r -> a
00:06:54 <EvanR> which classical i remember being one of the awesome pillars of FP
00:07:11 <jle`> > runReader (do ask; ask; ask) 10
00:07:13 <lambdabot>  10
00:07:18 <jle`> each of those actions just returns '10' as teh result
00:07:38 * hackagebot zerobin 1.5.1 - Post to 0bin services  https://hackage.haskell.org/package/zerobin-1.5.1 (ip1981)
00:07:38 * hackagebot purescript 0.8.1.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.1.0 (PhilFreeman)
00:07:40 <saurabhnanda> > 1 + 1
00:07:42 <lambdabot>  2
00:07:47 <jle`> as far as actions go, Reader only offers a few "primitive" actions that you can use to build more complex actions with
00:07:49 <roelof> > zipWith [1,2,3] [ 4,5,6] 
00:07:50 <lambdabot>      Couldn't match expected type ‘Integer -> b -> c’
00:07:50 <lambdabot>                  with actual type ‘[Integer]’
00:07:50 <lambdabot>      In the first argument of ‘zipWith’, namely ‘[1, 2, 3]’
00:08:02 <liste> roelof: you need a function too
00:08:09 <liste> > zipWith (+) [1,2,3] [4,5,6]
00:08:09 <roelof> > zipWith (+)  [1,2,3] [ 4,5,6] 
00:08:09 <jle`> IO, on contrast, offers several "primitives", like putStrLn, etc.
00:08:11 <lambdabot>  [5,7,9]
00:08:11 <lambdabot>  [5,7,9]
00:08:37 <jle`> saurabhnanda: the "primitive" 'Reader r' actions are 'ask' and 'return :: a -> Reader r a'
00:08:51 <verement> :t local
00:08:53 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
00:08:53 <roelof> Everyone a good day, I have now a good idea how to solve this one 
00:09:00 <jle`> and i gues you can count asks
00:09:13 <saurabhnanda> in Reader r a, what is 'r' supposed to *mean* and what is 'a' supposed to *mean*?
00:09:27 <jle`> the 'a' is the result
00:09:28 <EvanR> r is what you passed into runReader
00:09:34 <jle`> the 'r' is the type of the underlying environment
00:09:42 <liste> roelof: great (:
00:09:46 <jle`> so a "Reader Int String" is a Reader action that produces a String when run
00:09:53 <jle`> and it does so using an 'Int' as an underlying environment
00:09:56 <verement> jle`: would local also be considered a Reader primitive?
00:10:00 <jle`> that you can access with 'ask'
00:10:23 <jle`> verement: hm, i gues you would consider it
00:10:29 <jle`> local is kinda weird because it's not algebraic, they say
00:11:18 <saurabhnanda> jle`: practically doesn't it mean that it's an Int => String mapping?
00:11:37 <jle`> i'm not sure what you mean by 'practically'
00:11:51 <EvanR> Reader Int String is isomorphic to Int -> String
00:11:55 <jle`> but i'm telling you want they are supposed to mean, semantically
00:12:10 <jle`> but yes, they are isomorphic, if that's what you're asking
00:12:47 <EvanR> dependency injection is isomorphic to passing an argument in ;)
00:17:32 * hackagebot wai-extra 3.0.14.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.14.1 (MichaelSnoyman)
00:20:20 <saurabhnanda> so, is this intuition correct: ask basically proclaims that *this* function needs to be run inside a Reader monad/environment. You cannot run this function otherwise.
00:20:50 <pavonia> What function?
00:20:55 <EvanR> ask isn't a function
00:20:56 <opqdonut> saurabhnanda: yes
00:21:07 <opqdonut> :t ask
00:21:08 <lambdabot> MonadReader r m => m r
00:21:20 <EvanR> so no its not correct
00:21:23 <opqdonut> the type of ask has a MonadReader constraint, and that constraint gets propagated to anything that used ask
00:21:53 <opqdonut> (sure, you can do something stupid like (const 1 ask), but in general it gets propagated)
00:22:00 <EvanR> and ask doesnt have to be used in a function
00:22:08 <opqdonut> EvanR: you're not being helpful at all
00:23:32 <saurabhnanda> pavonia: *this* function -- the function in which ask is used.
00:23:34 <EvanR> saurabhnanda: when you write do notation, youre build some monad action. if you use ask, then this means itll be a reader monad
00:24:01 <EvanR> saurabhnanda: ask is not necessarily used in a function, it can be used in a do block though
00:24:13 <EvanR> which are not functions
00:24:17 <saurabhnanda> EvanR: so I've stopped using the do notation. Especially when I'm trying to understand some concept. 
00:24:29 <saurabhnanda> so, wrt to this definition -- computation = ask >>= (\greeting -> return $ "hello " ++ greeting)
00:24:30 <EvanR> thats fine, but its still not necessarily in a function
00:24:36 <EvanR> computation isnt a function
00:24:56 <EvanR> so im just trying to help your intuition not be type-incorrect
00:24:58 <saurabhnanda> EvanR: in the definition I pasted above, 'computation' is NOT A function?
00:25:02 <EvanR> no its not
00:25:18 <EvanR> like main = getLine >>= putStrLn isnt a function
00:25:19 <pavonia> saurabhnanda: It requires the whole action to be a Reader, if this is what you are asking
00:25:19 <saurabhnanda> EvanR: okay, this is new
00:25:43 <saurabhnanda> EvanR: what? isn't 'main' a function?
00:25:47 <EvanR> nope
00:25:54 <EvanR> main :: IO ()
00:26:06 <saurabhnanda> EvanR: so, what are computation and 'main' in that case?
00:26:25 <EvanR> "monad actions" is one way people describe it
00:26:33 <EvanR> they just non-function values
00:26:49 <EvanR> like Just 'x'
00:27:28 <saurabhnanda> EvanR: is this a function? processOutgoingMessages :: TelegramOutgoingChannel -> IO ()
00:27:33 * hackagebot ginger 0.1.4.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.4.0 (TobiasDammers)
00:27:37 <EvanR> yeah, theres an arrow
00:27:57 <saurabhnanda> EvanR: hmm, okay. So it's like in Pascal? Function vs Procedure?
00:28:30 <EvanR> interesting way to look at it, except that any do-procedure you write that takes arguments, is a function so that might confuse you
00:28:56 <EvanR> processOutgoingMessages is a function that returns an action
00:29:22 <EvanR> actions are first-class values
00:29:54 <Maxdamantus> > let a = putStr "foo" in do{ a; a; a }
00:29:56 <lambdabot>  <IO ()>
00:30:00 <Maxdamantus> Damn it.
00:30:14 <EvanR> well that doesnt demonstrate it
00:30:19 <EvanR> er, that DOES demonstrate it
00:31:24 <EvanR> putStr is a function, `a' is a command which you just list in the do notation or in >>-chains as-is, you dont call it
00:31:50 <liste> saurabhnanda: processOutgoingMessages is a function that results in an action
00:32:15 <saurabhnanda> so haskell *does* support "actions" which are different from "functions". I thought it was supposed to be completely pure with no concept of imperative "step-wise" progrmaming
00:32:28 <liste> saurabhnanda: actions are values
00:32:40 <EvanR> do notation is pretty much literally imperative programming
00:33:08 <jle`> saurabhnanda: 'actions' is just a human descriptivey thing we assign to certain values
00:33:12 <EvanR> youll see that some distinctions between imperative and functional dont really make sense
00:33:18 <kadoban> saurabhnanda: Not at all. I'd say more the whole point is to be able to express and reason about the difference between pure and impure computation.
00:33:20 <jle`> saurabhnanda: it's not really an in inherent part of the language
00:33:29 <jle`> saurabhnanda: that's like saying that haskell supports trees
00:33:32 <saurabhnanda> EvanR: only if you write it as a do-notation. If you write it using >>= and >> it's pretty much function composition.
00:33:34 <liste> > [putStrLn "x", putStrLn "y", putStrLn "z"]
00:33:34 <jle`> i mean, yeah, you can make your own Tree data type
00:33:35 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
00:33:38 <Maxdamantus> It is still pure though. All you're doing is composing actions into larger actions.
00:33:51 <Maxdamantus> You can't perform some action inside a function.
00:33:54 <EvanR> saurabhnanda: well, >> isnt function composition
00:34:09 <EvanR> >=> is though
00:34:14 <EvanR> :t (>=>)
00:34:15 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:34:16 <jle`> saurabhnanda: actions are just semantics we give to specific values...they're semantic constructs/ideas, not inherent things built into the language
00:34:31 <liste> saurabhnanda: (+) is a function that results in a value, 4 is a value
00:34:47 <liste> (though functions are values too)
00:34:51 <jle`> saurabhnanda: there are a lot of things in Haskell that aren't functions --- booleans, like True, False, etc., aren't functions
00:34:54 <Maxdamantus> (disregarding `unsafePerformIO`)
00:35:19 <EvanR> saurabhnanda: >> is more like combining values with a + sign
00:35:20 <jle`> saurabhnanda: "actions" in haskell are no more pure or impure than normal values, becuase they *are* normal values
00:35:26 <EvanR> 3 + 4 + 5
00:35:49 <saurabhnanda> jle`: got that, functions, vs values. but what does an "action-value" mean? All other values can't get executed. But "action values" can get executed. That doesn't make them very different from function, then. Does it?
00:35:58 <jle`> not according to the language
00:36:07 <jle`> just in whatever API we chooose to make for our actions
00:36:18 <jle`> that's like saying that "number values" can get addition'd
00:36:19 <liste> saurabhnanda: mind the difference between execution and evaluation
00:36:27 <liste> saurabhnanda: functions can't be executed either
00:36:30 <jle`> that's not an inherernt part of the language, that's just becuase we made a number type and added the ability to add them
00:36:57 <jle`> "executed" in the sense that a 'Reader r a' is executed -- execution is just a normal function on normal data
00:37:03 <saurabhnanda> liste: functions cant be executed, say what?
00:37:22 <saurabhnanda> liste: execution vs evaluation -- is there a difference in the context of our current conversation?
00:37:30 <liste> saurabhnanda: there indeed is
00:37:30 <EvanR> saurabhnanda: IO actions get executed (if you run the program), other monads are merely evaluated
00:37:31 <jle`> but i'll admit that the usage of 'execution' there is different than the typical way the word 'execution' is used in haskell, so i should probably stop using it
00:37:58 <jle`> well, IO actions can get executed by computers by doing IO
00:38:06 <jle`> that's different than evaluating IO actions
00:38:11 <EvanR> executing the addition in 3+3 to get 6 ;)
00:38:17 <jle`> 'IO actions' are just normal data, describing io actions
00:38:18 <EvanR> -- jle` 
00:38:35 <jle`> we can evaluate IO actions all we like, but they won't perform any IO
00:38:50 <jle`> evalationg IO action would be like reading the contents of a python source file
00:39:06 <saurabhnanda> okay, so execution vs evaluation -- any real difference in this current context? Also, what's the differnce between functions vs values. Isn't it execution (or evaluation) essentially?
00:39:11 <liste> saurabhnanda: nothing is really executed in Haskell, you just evaluate a big ol' IO action and pass it to RTS to be executed
00:39:29 <jle`> functionrs are values whose types have (->)
00:39:34 <jle`> so things of type Int -> Bool are functions
00:39:38 <jle`> things of type String are not
00:39:44 <jle`> but all functions are values, yes
00:39:53 <EvanR> saurabhnanda: you are really asking about evaluating, runReader, >>= etc these all evaluate to some value without doing any IO
00:40:01 <EvanR> so thats why haskell is pure
00:40:15 <saurabhnanda> okay, this seems to be another philosophical discussion. Back to original question. Why is computation :: Reader String String not a function?
00:40:23 <EvanR> no ->
00:40:24 <jle`> because it doesn't have (->) in the type
00:40:25 <liste> saurabhnanda: it has no (->) in its type
00:40:29 <EvanR> it doenst take any argument
00:40:31 <jle`> high five everyone
00:40:35 <saurabhnanda> EvanR: so evaluation vs execution is all about IO? Side-effects outside the RTS?
00:40:37 * liste high fives jle`
00:40:44 <liste> and EvanR
00:40:55 * EvanR cannon balls into the deep end
00:41:18 <EvanR> saurabhnanda: yep
00:41:19 <jle`> note that things get a little fuzzy here because when we talk about a "Reader String String" as if it were a computation/action, then we also attach a definition of what it means to "execute" it
00:41:49 <jle`> and 'executing' a Reader action means nothing more than using it with runReader :: Reader r a -> r -> a
00:42:09 <saurabhnanda> okay, now I'm unable to understand the difference between a 'computation' as defined by Reader x y vs a first-class function
00:42:12 <EvanR> "running" a runReader is just evaluation
00:42:12 <jle`> but these concepts are sort of just a part of the api/semantics of reader
00:42:12 <saurabhnanda> both get evaluated, right?
00:42:37 <liste> saurabhnanda: yes, the computation evaluates to a Reader r a value
00:42:37 <EvanR> its not useful to mix up evaluation and execution and say they are the same and different
00:42:44 <EvanR> no point in having two words then
00:42:57 <verement> a function is something that you apply to an argument
00:43:00 <jle`> saurabhnanda: a lot of things can *represent* functions
00:43:00 <liste> saurabhnanda: and runReader turns the Reader r a value into "a" value
00:43:02 <saurabhnanda> so rolling another level up. What is 'ask' doing in // computation = ask >>= (\greeting -> return $ "hello " ++ greeting)
00:43:23 <EvanR> its not doing anything, its just there
00:43:24 <jle`> saurabhnanda: it is a Reader action whose result is the environment it's being run in
00:43:35 <EvanR> what does 3 do in 3 + 3
00:43:58 <jle`> saurabhnanda: you might also be conflating things that can represent functions with functions themselves
00:44:01 <jle`> let's say i make a data type:
00:44:06 <liste> > (do {x <- id; y <- id; return (x + y)}) 5
00:44:07 <lambdabot>  10
00:44:11 <jle`> data Foo = Add3 | Add4 | Negate
00:44:19 <jle`> and write a function runFoo :: Foo -> Int -> Int
00:44:31 <jle`> runFoo Add3 i = i + 3; runFoo Add4 i = i + 4; runFoo Negate i = -i
00:44:37 <jle`> does that mean that Foo is the same as a function?
00:44:41 <liste> saurabhnanda: Reader does what I just did "under the hood"
00:44:46 <jle`> Foo just represents functions
00:45:00 <liste> saurabhnanda: though technically nowadays it's a bit more complex
00:45:12 <jle`> there's a difference between data types that can represent functions vs. actual functions
00:45:36 <saurabhnanda> :t id
00:45:37 <lambdabot> a -> a
00:46:02 <EvanR> liste: what monad is that?
00:46:09 <saurabhnanda> :t id >>= (\x -> id >>= (\y -> return (x + y)))
00:46:10 <lambdabot> Num b => b -> b
00:46:11 <liste> EvanR: (->) a (:
00:46:17 <EvanR> insane!
00:46:24 <jle`> saurabhnanda: asking why a 'Reader r a' is not a function is like asking why Foo is not a function
00:46:34 <jle`> they just...aren't functions
00:46:36 <EvanR> why is Maybe a not a function
00:46:44 <saurabhnanda> jle`: actually my question is why 'ask' is not a function
00:46:50 <jle`> ah
00:47:03 <jle`> that'd be like asking why my Add4 up there is not a function
00:47:11 <EvanR> again, since it doesnt take any arguments
00:47:16 <Axman6> Reader String String is a data type which contains a function from String -> String, but is not a function
00:47:20 <EvanR> you cant apply it
00:47:23 <jle`> it's just normal data, ask :: Reader String String
00:47:31 <jle`>  Add4 :: Foo
00:47:41 <saurabhnanda> jle`: okay got that
00:48:15 <jle`> now, we can turn any Foo into the function that it represents by writing such a transformation --- it was runFoo up there
00:48:22 <jle`> runReader is the analogous transformation for Reader r a
00:48:27 <Axman6> just like how an object in an OOP language which contains a string isn't a string
00:48:44 <jle`> 'runReader' transforms a `Reader r a` into a function it represents, an (r -> a)
00:48:56 <saurabhnanda> so, ask >>= (something) take a monadic values of Reader r a and puts it through the 'something' function and returns another monadic value of type Reader r b
00:49:07 <EvanR> Reader r r
00:49:23 <saurabhnanda> EvanR: why Reader r r
00:49:23 <EvanR> yes
00:49:24 <merijn> saurabhnanda: Yes, although the "monadicness" is only tangentially related
00:49:32 <saurabhnanda> EvanR: how is Reader r r even useful in real life?
00:49:36 <jle`> `something` is (r -> Reader r a) -- it makes a new `Reader r b` action from the 'r' that 'ask' gave it
00:49:37 <EvanR> saurabhnanda: thats simply what the type of ask is:: Reader r r
00:49:42 <jle`> honestly nobody uses Reader r in real life
00:49:49 <jle`> the only time Reader really comes up is for learning
00:50:02 <merijn> saurabhnanda: I mean, we could define a special "composeReader :: Reader r a -> (a -> Reader r b) -> Reader r b" and everything would still work
00:50:07 <merijn> jle`: I disagree
00:50:19 <merijn> I use Reader often enough
00:50:27 <EvanR> saurabhnanda: its useful since that is what ask is ;)
00:50:37 <jle`> any reason to prefer it over just normal parameter passing?
00:50:39 <EvanR> the only thing Reader can even do
00:50:48 <jle`> i mean, besides using it in a monad transformer chain
00:50:52 <merijn> jle`: Less of a mess with lots of parameters
00:51:03 <jle`> boo
00:51:05 <jle`> ok i redact
00:51:14 <jle`> *retract
00:56:43 <saurabhnanda> okay here's a parallel question, like the main use for Applicative is to be able to compose multi-value functions inside a Functor, is it correct to say that the main reason for Reader is to compose functions that deal with a common set of arguments (the environment)?
00:57:34 * hackagebot hdevtools 0.1.3.0 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.3.0 (ch1bo)
00:57:54 <merijn> saurabhnanda: Yes
00:58:18 <merijn> In fact, that's pretty much it's only purpose :p
00:58:45 <EvanR> saurabhnanda: right, and you can pack as much into the environment as you want using a record and asks myField
00:59:16 <EvanR> better than globals!
01:03:39 <gaffey> part
01:07:21 <hc> Hi, a friend of mine asks whether he should learn C++ or haskell... he read LYAH over the weekend... Can you recommend a good comparision between the two languages?
01:11:50 <tdammers> hc: why not both?
01:12:32 <tdammers> also, the two languages are so different that it probably makes more sense to list what they have in common, rather than what the differences are
01:16:51 <EvanR> start with haskell for fun, then move to C++ when you feel masochistic
01:16:58 <kadoban> hc: Haskell is a high level language with excellent abstractions and a badass type system. C++ is a language strives tries to both have nice high-level abstractions and the ability to poke at low-level bits as well, which (along with its history) tends to make it quite complicated and a bit dangerous to work with in practice.
01:17:59 <hc> thanks :)
01:18:28 <kadoban> hc: Yeah, nothing wrong with learning both, though there's other languages I'd probably suggest before C++ for most uses.
01:19:07 <kadoban> hc: If they do decide to learn haskell, have them swing by and ask for some resource suggestions.
01:19:19 <hc> he already knows C++ and is a bit intimidated by the thought of having to start from zero again ;)
01:19:48 <hc> i also wanted to show him how friendly this channel is, that worked well :)
01:20:19 <kadoban> hc: Ah, heh. Well it's not quite starting from zero, though it may feel like that initially for a bit :)
01:20:26 * Liskni_si thinks the compile times of Haskell are a very big win compared to e.g. C++/Scala, which makes it much less pain to work with.
01:20:35 <Freundlich> I have been using C++ for a very long time before I started with Haskell. I cannot stress enough how much a bit of Haskell helped me improve my C++ code.
01:20:51 <kadoban> It's worth it though. If nothing else, the ideas Haskell presents are really cool and useful even in other languages.
01:21:00 <Freundlich> Exactly.
01:27:36 * hackagebot hpack 0.10.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.10.0 (SimonHengel)
01:32:37 * hackagebot ginger 0.1.5.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.5.0 (TobiasDammers)
01:37:30 <Vektorweg1> whats a good way or package to get generic polymorphism? i mean something like `Int :+ Double :+ String` which is more or less similar to `data T = Foo Int | Bar Double | Baz String` or `Either Int (Either Double String)` 
01:40:12 <saurabhnanda> test
01:40:47 <mniip> Vektorweg1, type (:+) = Either
01:40:48 <mniip> ?
01:41:16 * saurabhnanda has shifted to Limechat on Mac OSX
01:41:26 <mniip> {# LANGUAGE TypeOperators KitchenSink #-}
01:42:23 <Vektorweg1> maybe. but i hoped for some accompanying functions to simplify some things. 
01:43:39 <saurabhnanda> EvanR: jle` pavonia liste what's a good tutorial for monad transformers?
01:44:59 <EvanR> Vektorweg1: you want a dynamic type?
01:44:59 <Vektorweg1> saurabhnanda: the wikibook page isnt so bad for the beginning.
01:45:14 <pavonia> saurabhnanda: Don't know, maybe the RWH chapter?
01:45:23 <saurabhnanda> Vektorweg1: wikibook?
01:45:40 <Vektorweg1> saurabhnanda: https://en.wikibooks.org/wiki/Haskell/Monad_transformers
01:45:53 <saurabhnanda> http://book.realworldhaskell.org/read/monad-transformers.html and https://en.wikibooks.org/wiki/Haskell/Monad_transformers
01:46:08 <Vektorweg1> yep.
01:46:16 <jle`> i liked that monad transformers step by step one
01:55:08 <Vektorweg1> EvanR: i really want to avoid Dynamic. i want a parametric list of types if possible.
01:55:26 <EvanR> yeah i didnt mean Dynamic, since you dont get any operations
01:55:38 <EvanR> you want a type that emulates the javasacript-style type that can do anything?
01:56:00 <Vektorweg1> no
01:58:51 <quicksilver> Vektorweg1: there is lots of stuff for that
01:58:59 <quicksilver> but I can't recommend any specific example
01:59:15 <quicksilver> I think hlist has some, vinyl has some
02:00:49 <Vektorweg1> the list of types has to be flexible but i dont actually do anything with that values. i only want to get them, keep them in ram, maybe sort them and put them out as requested. and if possible keeping it all typesafe. 
02:01:37 <EvanR> ah
02:01:44 <EvanR> then you might want to look at generic
02:01:47 <EvanR> generics
02:04:13 <Vektorweg1> yes that could work. but generics are hard. :|
02:06:36 <quicksilver> I don't think it is very hard
02:06:46 <quicksilver> I think the kind of thing you describe is quite easy
02:07:00 <quicksilver> but you need to ask more specific questions to get actual examples of solutions
02:07:20 <Vektorweg1> i'll try.
02:07:50 * hackagebot profiteur 0.3.0.2 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.3.0.2 (JasperVanDerJeugt)
02:07:52 * hackagebot stylish-haskell 0.5.15.2 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.15.2 (JasperVanDerJeugt)
02:08:56 <jophish> What happens when I pass a callback to a foreign library and this callback is called asynchronously at a later time?
02:12:38 <EvanR> jophish: it works as long as you put the right ffi annotation... i believe "safe"
02:12:46 <EvanR> and you use -threaded
02:12:57 <ggVGc> I am not sure I like monad transformers. I don't fully know how to use them yet, but I also feel that the simplifications they give come at too high complexity cost
02:13:41 <jophish> EvanR: ah ok. I could only find information about synchronous callbacks.
02:13:43 <sbrg> ggVGc: how so?
02:14:38 <EvanR> jophish: there are cases where not using -threaded can cause certain things to freeze things up... generally -threaded solves most ffi issues
02:14:45 <EvanR> and makes threadDelay more accurate
02:15:07 <ggVGc> sbrg: I don't find monadic code without monad transformers very difficult to read, and if you start using transformers, you put a higher demands on the reader
02:15:58 <EvanR> jophish: ghc never ceases to amaze
02:16:16 <Vektorweg1> ggVGc: you may have to write lots of boilerplate but its reducing complexity on the user side ...
02:16:34 <sbrg> ggVGc: much of that complexity can be abstracted away by making functions that kind of make up a DSL.
02:16:37 <ggVGc> Vektorweg1: not if the user is not comfortable with monad transformers
02:16:42 <ggVGc> then the code becomes unreadable instead
02:16:52 <sbrg> ggVGc: not really. 
02:17:25 <sbrg> my irc bot is essentially one big transformer stack of multiple levels. writing plugins for it could be done by a haskeller that doesn't have any idea what monad transformers do or how they work. 
02:23:14 <jophish> bgamari: thanks for the PR, do you want write access to the repo?
02:23:37 <jophish> oh, please disregard the travis build at the moment, I've not finished tinkering.
02:35:21 <purelazy> @pl \guess -> merge (f guess) (Finished string)
02:35:21 <lambdabot> flip merge (Finished string) . f
02:36:42 <purelazy> @pl \guess -> merge (f1 guess) (f2 guess)
02:36:42 <lambdabot> liftM2 merge f1 f2
02:45:28 <bgamari> jophish, I'm afraid that's all of the time I have for the moment
02:46:11 <bgamari> jophish, thanks for cleaning up this package, though
02:46:21 <bgamari> There's been need for something like this for quite a while
02:46:47 <jophish> bgamari: happy to do it :) I'll see about merging your changes this evening after work
02:50:00 <ingdas> @pl (\i l -> i . ( \s -> s . l))
02:50:00 <lambdabot> (. flip (.)) . (.)
02:50:19 <ingdas> @pl ( i . ( \s -> s . l))
02:50:19 <lambdabot> i . (. l)
05:09:06 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
05:09:06 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
05:09:06 --- names: list (clog parsecChar PennyNeko danthemyth KeelOfSteel huckleberry78 mettekou reem Tertain albertid_ free_beard cereal_killer_ nottc zipper srajendra prognoob1 ggole marrrk amyers doofin IlanGodik cchalmers daandd__ eskimo nuuit sdothum afcondon Iskarlar shafox hellertime ner0x652 magine-pc ifesdjeen M-davidar M-Quora M-david M-Illandan mizu_no_oto domyos binaryplease JagaJaga lordf rodlogic jix fsvehla yakutori xelxebar mochi ikke verde pkkm proteusguy proteusguy_)
05:09:06 --- names: list (Xe garphy PatrickRobotham Maerten_ aznashwan bobry mountaingoat primeval2 _kfpratt narwhal01 ziocroc Plastefuchs danza clynamen CurryWurst montanonic oisdk_ m0rphism Nivim pydave6367 i-amd3 alpounet bkolera biglama ype pplorins_ simukis_ Philpax latk teeteewhy SAnnaBot castlelore absence fizruk nkhodyunya Caelum Uakh erikd suls cgfbee plutoniix oish dadaro bertschneider Internet13 sz0 Reshi Cerise ninedotnine t0by csabahruska magthe ozgura keevil_ bencryption)
05:09:06 --- names: list (Vektorweg1 jophish vlatkoB_ SCHAAP137 sigma914 unclechu elementalest LordBrain Aruro kurnevsky araujo earthy pantsman- adulteratedjedi xplat adlan_ meretrix dm3 alexa_ AcuZZio bsermons tesuji frontendloader oberstein Yuras ipalade bsmt Wizek Guest26166 raichoo DenSchub smwangi dud LoganG tippenein tippeneinn Wizek_ osfabibisi bollullera caumeslasal mattyw kungp hackagebot jaaronamo kam270 synthmeat perspectival thc202 Freundlich Icewing edon takuan Miroboru)
05:09:06 --- names: list (jtobin srenatus danvet gauthier nyazdani slomo quchen MrWoohoo tusj undoall bjz greeny dario` dextertzu lyuha Guest50611 recycle cceckman jmct juhp ThomasLocke BartAdv jibi gem jle` fr33domlover boj_ fujimura tristanp Tehnix rogorido isenmann hk238 rejuvyesh moei majoh joneshf-laptop heurist AntiSpamMeta otto_s_ a3Dman vili_ TommyC cpup emmanuel_erc clintm badon pavonia brotknust mauke thunderrd kp666 xnil Cetusx pyon-kan hucksy_ pacak ThreeOfEight humanbsd)
05:09:06 --- names: list (shesek Brando753 pranz wookiehangover andyo henrytill Adeon leat ario tennix Athas shadowdao seangrove brixen Amnez777 mxf nidr0x kritzcreek_ koz_ phileas qnikst sku1d FreeBirdLjj c0ld- gws mjo kadoban goldfire1 liyang dmiles_afk liszt nakal1 DANtheBEASTman vishesh Maerten markus1199 predator217 darkf carlf_ Destol tek0 bithijacker prkc SIGILL Elision fiddlerwoaroof conal mr_yogurt2 bounb owa dicioccio Jinxit geal aerialB gipp amiri osfameron LnL Twey)
05:09:06 --- names: list (Guest59455 Yaiyan tjbp Factionwars bb010g unsymbol wto statusfailed Tehnix` pieter tekacs sword_smith Desoxy swhalen liste M-ou-se jakutis Bashmetim ldg dustinm vic_ aaron7 shelling__ tswett zymurgy Belgarion0 moop hamishmack Gurkenglas_ {AS} k3d3 igniting dibblego Lokathor djellemah lodin- xxpor bogdanteleaga robertk mudfog_ Shockk icedev armyriad warc Liskni_si zq SHODAN XMunkki Jesin tomboy65 martintrojer jgornick eazar001 Hijiri kwantam seagreen cosban)
05:09:06 --- names: list (CosmicRay Cathy koala_man agjohnst grol justin_smith _6a68 spicydonuts MelodyKH3 eacameron flower_snark_ solidsnack Cale alang mt kaste Ulrar pchiusano Polarina oldmanmike prooftechnique Sigyn themagician Moto-chan verement Church- bitemyapp ljhms Oxyd d6e fkurkowski OutlawStar ches negatratoron lispy leftylink tomh- mrd fmapE jre2 bitonic edwardk anohigisavay karshan1 Proteus1 chris2 bengt__ Reyu newsham chaptastic joehillen arkeet mendez Fylwind dreamdust)
05:09:06 --- names: list (zhulikas eL_Bart0 Eliel sLite dunj3 bcrom_ cnr _janne jbalint keemyb rtur leather arnihermann linduxed pootler_ przembot Sorella CoconutCrab askarpo Majiir fuziontech wizonesolutions monokqr edwtjo saiam johtso Baughn urdh squisher fergusnoble uwap japesinator ggVGc Sgeo ahihi zyla Matajon FUZxxl neobrain` JPohlmann ziman Guest4877 cfloare cow-orker quaestor1 spacebug Lord_of_Life lohkey nwf tjpeden Taneb Erebe Xorlev xinming razi1 average fengshaun ndeine)
05:09:06 --- names: list (dpower Guest12896_ chishiki Guest46433 vin-ivar PlasmaStar dh lokien gfixler katymoe stasku___ bjobjo mmaruseacph2 Voldenet chelfi timrs2991 stephe xacktm jholtom SolarAquarion Guest44471 Vbitz anachrome _flow_ sisir OliPicard kjnilsson movedx carlw2 Guest33283 Enigmagic cjwelborn codebam clion ocharles_ codedmart micxjo paf31 mietek dfranke sclv bgyss dstockwell pkogan_ marcel aloiscochard TDJACR shans_ wyvern Guest34040 mankyKitty mlhmwglt kyagrd louispan)
05:09:06 --- names: list (Scorchin t0mb0_ alem0lars chriswk etcinit takeey vikraman avdi ttuegel lpaste puzza007 KorriX TimWolla fabianvf georgew fnordbert radens Cr8 amingoia minsky Tiktalik mirsal SegFaultAX timloh thetallguy felixsch_ lingbot SLi jcreekmore sohum Raynos fortress_ clahey_ mimi_vx incomprehensibly ortmage Levex rikkus jessicah` benonsoftware SoupEvil zopsi spinda radge_ Walther sgronblo capicue esssing itscaleb si14 marko____ friden gratimax hbar_ pmade noctux)
05:09:06 --- names: list (zmanian__ martingale sarlalian zaquest asm89 obiwahn ReinH numberten vpetro coddinkn bernalex kqr myme dcoutts sjl_ lyxia yamadapc Sonderblade gsingh93 exio4 karls barrucadu Guest95751 Ptival gienah jrslepak dsantiago GaveUp spwhitt sternenseemann __name__ kennyp jonrh giraffe nathyong juri_ pdgwien jliikka lahwran lyddonb sm darthdeus thorkilnaur_ simony vigs pdxleif jellytux cmn jrp6 aweinstock anoe Moyst Bez_ __main__ amontez shteou joshc omilu Shapeshifter)
05:09:06 --- names: list (nore quicksilver larsen hyPiRion phaazon Jonno_FTW Zekka fryguybob lnx chattered apo_ sdx32 horatioh1 plog99 koomi svp solirc PHO keix dixie_ joachifm kier niko nopf kmicu Black-Wolf catsup Forkk helozjisky ggherdov luxbock Ankhers Pamelloes Elsi jstolarek davidthomas sqram wrengr_away t0m0 sephiap Intensity alevy Guest3764 capisce spaceships whiteline jamiis TallerGhostWalt sleepynate davesilva tokik jedws zyoung sanitypassing mikeplus64 Oejet acfoltzer)
05:09:06 --- names: list (Tinchos RaceCondition mpark1 Guest47317 e darxun dogui gpampara cocreature MindlessDrone pm51 fractalcat nisstyre_ lonokhov sys9mm NeverDie ollef folsen mitchty sivs ahungry bartavelle S11001001 gnusosa cjay_ mbrcknl antoniy staffehn jzl kipras seliopou hydraz avocado jfokkan__ etrepum abbe magbo cjh` guampa watersoul hive-mind fold4 sokoll zxq9 Tritlo noteventime Adios wagle myfreeweb cynick crank1988_ KaneTW wolfcore dedgrant andjjj23 rofer ironChicken)
05:09:06 --- names: list (low-profile Lutin` jackhill isomorphismes obadz pfeyz otterdam Ewout taruti opqdonut alkabetz jimki Zemyla richi235 gdsx quuxman serutsubi donwilli1m Bane^ funrep ElderFain zxtx spill4 kosorith dschoepe ibid bergmark nathanic tim_s007 MasseR tumdum kvieta Johannes13 tinco nchambers dmwit _zxq9_ lieven DrCode zemm knyppeldynan corne_ Kahva Nimatek iliastsi horlicks_ maerwald felixschl Benzi-Junior Marqin zerokarmaleft Pucilowski magically Vorpal s_e descender)
05:09:06 --- names: list (lamilami dan64 FireFly fionnan aristid phuu kipd rvncerr Fubar^ scshunt lf94 marens_ nbouscal xanadu_ AppleJacks24 narendraj9 fboyer marienz yminsky Rembane dtulig LeaChim_ kishar orion infinity0 klarrt pelegreno tg sajith tuple_cat dwn Ralith Tene zv yarou ahf surtn kshannon tessier reynir froztbyte rossberg Irrationality heath hongminhee cstrahan runeks freekevin levi tych0 magicman msloma siddhu tedkornish bshelden honkfestival ckw dolio Boreeas neshmi)
05:09:06 --- names: list (brainpro1 cansis gniourf Guest85605 trevorriles vifon imalsogreg sbjorn Dtgr jlyndon Rodya tlevine stux|RC-only lokydor Xandaros jinblack Kneiva_ davl theorbtwo lukky513 nicola1 benzrf peddie jb55 arianvp chirpsalot abh nitrix petercommand rkk eyck robogoat [swift] jnes supki pompolic mjrosenb Clint asjo huonw Drezil MarcelineVQ cyberlard Hammy_Work hausdorff mrlase dju codebje nurupo wting julienXX pleiosaur caserg bbee2 lancetw nikola opios kjanosz wedify)
05:09:06 --- names: list (rwiggins Ongy johnw zerowidth Watcher7 StoneToad tolt indiffernet code_crimes aatxe geppettodivacin cic majjoha otulp lassulus DustyDingo happy0 callumacrae tumdedum leino coeus irishsultan marmalodak yeltzooo kakos albel727 stelleg catern slick dilinger tomjaguarpaw ManiacTwister Gothmog_ Starfire Hafydd martinbjeldbak subleq ppnkk dkibi ion hanDerPeder aparent Ornedan bd_ AustinMatherne arkarth vodkaInferno lenstr mephx ChongLi FreeFull siloxid` ido dzack)
05:09:06 --- names: list (drmoob_ fingerzam ski_ Wamanuz2 spion Chousuke condy brolin_empey_ pnutus pharaun lstrano_ Sornaensis xou bergey bob_vh mrshoe hiratara nshepperd tromp_ __rlp shennyg avn Ariadeno pi___ julmac zenzike spock kini psftw niklasb yusukesuzuki mceier gbarboza luzie eddsteel c_wraith sevas oherrala Excureo pikajude swistak35 octo dredozubov irclogger_com joeytwiddle psyq d3lxa shwouchk maartenpi PanicSkittle deni CindyLinz mpereira_ chu pyrtsa andrewsw unknownln)
05:09:06 --- names: list (honza_ padre_angolano pkmx besenwesen ebird tomku|two telmich inr_ z-nexx_ eagleflo cods M2tias stvc maxmo mads- stomp archaic joeyh_ RazorX| obcode_ syntacticNaCl mw jud nekomune int-e alunduil_ Madars acro Edoxile Paks Ov3rload saurik sleblanc notdan shachaf Khisanth Deewiant andreas303 skrio Maxdamantus elgot duairc mechairo` kalloc_ mj12`_ Kavec orbital davean biscarch Eric1 bind Schrostfutz woffy raek sekrit bananagram srhb Guest62564 Xnuk lpvb jokester)
05:09:06 --- names: list (ali_bush jlouis ernst topi kaol Profpatsch sunnid APic hsyl20 dxld tismith mnoonan tomaw tdammers ephess_ _ashbreeze_ dasmith91 julm qz wedens lattenwald Philonous RouxTheDay edofic platz RageD ps-auxw Axman6 Shandy posco nexsja bgamari kloeri rootzlevel atomi rieper|net valdyn Saizan mokus bydo mtesseract2 Mandus_ Soft brisbin cross noexcept_ abrar _guios Igloo_ taksuyu luis` metaf5_ ploopkazoo acommino- sujeet DigitalKiwi whaletechno mshenrick DDR vincenz)
05:09:06 --- names: list (thebnq da-x_ hodapp bcoppens lhynes lurker6_ naudiz burp rjeli cdk ec\ adarqui jameseb s4msung_ bjs korayal jaaket pfoetche1 tzaeru `0660 hemite sellout pgiarrusso niteria eyenx xintron andromeda-galaxy d-q-d wayne hvr gseitz_ sleezd dhrosa_ ThePhoeron Ke kosmikus Laney hpc _klm tsani_ jcurbo BigEndia1 ClaudiusMaximus luigy WhoA3 jotrk toredl Speed Natch hiredman brennie_ ddude dlundy vqrs jlewis_ mrowe xaimus_ zomg luite amharc_ justanotheruser optocoup1er)
05:09:06 --- names: list (tnks Excedrin_ srcerer_ dakrone cheater z16 sdboyer Boney glckr kyren_ lachenmayer tero- gridaphobe suppi EvanR mach zeroskil1or mattp__ WzC MoALTz Mr0rris0 sideDigit rkazak Meow-J tv Ravana Tourist progato rcsgns hackerfoo ft benl23 Ring0` lambdabot jgertm comboy lpsmith cognominal acertain ]OLI[ wamaral niluje k1 ephemeron Akii mgaare_ selckin gargawel_ l3france xeno BillyIII Vq noplamodo aulambda jnoah fyolnish averagehat beckyconning_ jokleinn phaskell jaj)
05:09:06 --- names: list (hrnz RayNbow`TU H3ku hc agrif ackthet cantstanya buoto Quintasan SaidinWoT Chobbes Nik05 abra0 amatecha so caasih alphonse23_ sparr mpickering caw PotatoGim jorendorff hansihe jcp seanparsons betawaffle tgeeky eikke nrw_ kaictl grandy skarn orcus @ChanServ carc kristjansson nyuszika7h borkdude_ arrdem saruta epitron monty cbm80 mniip mero troydm shapr wtw mak` LordDeath moredhel thomas relrod zudov Reiser cursork GGMethos usr defanor nek0 keteim Dykam cbaines)
05:09:06 --- names: list (anders0 codehero minad sea-gull impure_hate alexlord chrzyki tortal raid SuperTux88 bigs milessabin YP-Cloud_ SethTisue stass rbocquet divVerent m4lvin qguv rstone zpconn__________ haasn jroesch_ carter_cloud sewilton fall_ gothos ixian bazzle Blkt icicled whoops psacrifice harmchop yaknyasn mindos_cloud____ banjiewen dkua vikram_______ nolrai2 killtheliterate alanz andreypopp_ lexi-lambda frelux joedevivo rom1504 BrianHV Diabolik adimit brezel Ferdirand)
05:09:06 --- names: list (integral Geekingfrog Kaini_ theolaurent geekosaur cin tazjin dxtr teqwve andirc8000 jjardon demize robtaylor zimp2 Atlanis iross xa0 Nadrieril klugez Eagle_Erwin toon Jello_Raptor dbeacham danieli ricardo82 Sagi kriztw gcollins m1stermag1c nille Guest98597 andreass phadej MK_FG mudfog Simson-san hegge Klumben Jaxan josephle iphy idupree solatis xplat|work danza-cloud ajp flux case39 m1dnight_ Jaak Niamkik_ sbrg canta wolf_mozart carter ircbrowse danclien drdo)
05:09:06 --- names: list (nemesit|znc dpn` cschneid zph Frankablu stqism mikeizbicki greymalkin wjm CARAM__ mno2 TabAtkins trig-ger dmoon1221 nkpart brt1 dsop thoughtpolice drewdavis placer14 thalleralexander yorick thomie Xack poga Bigcheese pikhq tarcwynne_ isocliff sbauman xnyhps Saimeidae ddima Ashy xaotuk stoned gabiruh ajmccluskey AlainODea NemesisD sunfun max-m)
05:09:12 <cocreature> parsecChar: looks like https://hackage.haskell.org/package/errors-2.1.2/docs/Control-Error-Util.html#v:note
05:09:48 <parsecChar> cocreature: can you tell me the list of steps how you sent from the link I pasted to the link you found?
05:10:42 <cocreature> parsecChar: look at the source, see noteT and hope that’s less common, type it into hoogle http://hoogle.haskell.org/?hoogle=noteT and check if there is also a note function in the same package
05:12:09 <parsecChar> cocreature: got it; thanks!
05:23:34 * hackagebot order-statistic-tree 0.1.0.0 - Order statistic trees based on weight-balanced trees  https://hackage.haskell.org/package/order-statistic-tree-0.1.0.0 (MZiatdinov)
05:24:14 <cheater> cool
05:39:59 <asthasr> is there a good name for the 'type of functions' that is kinded * -> * -> *?
05:46:28 <pavonia> asthasr: Binary type constructor?
05:47:15 <asthasr> pavonia: I mean, more -- the "type of functions"
05:48:29 <jmc__> hey all
05:48:35 * hackagebot pipes-bzip 0.2.0.2 - Streaming compression/decompression via pipes.  https://hackage.haskell.org/package/pipes-bzip-0.2.0.2 (chemist)
06:13:37 * hackagebot pipes-bzip 0.2.0.3 - Streaming compression/decompression via pipes.  https://hackage.haskell.org/package/pipes-bzip-0.2.0.3 (chemist)
06:21:32 <m0rphism> asthasr: maybe binary type operators?
06:23:37 * hackagebot pipes-bzip 0.2.0.4 - Streaming compression/decompression via pipes.  https://hackage.haskell.org/package/pipes-bzip-0.2.0.4 (chemist)
06:37:22 <jophish> Does anyone else get connectivity problems with hackage after uploading a package?
06:38:38 * hackagebot vector-sized 0.2.0.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.2.0.0 (jophish)
06:46:57 <iphy> I'm getting "Unknown encoding for constructor" when I try Binary encoding for a large enum (a type with 256 nullary constructors)
06:47:15 <iphy> I'm using Generic and the Data.Binary.Binary typeclass
06:47:50 <iphy> is there a limit of nullary constructors for a type?
06:48:23 <iphy> it seems to happen only with the last few constructors
06:48:38 * hackagebot tslib 0.1.4 - Time series library  https://hackage.haskell.org/package/tslib-0.1.4 (alex_bates)
06:52:01 <saurabhnanda> an IRC question
06:52:07 <saurabhnanda> how do I reserve my nick on freenode?
06:52:45 <iphy> saurabhnanda: /msg nickserv help
06:54:54 <saurabhnanda> iphy: thanks, worked.
07:04:08 * hackagebot atom-conduit 0.3.0.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.3.0.0 (koral)
07:04:10 * hackagebot generic-deriving 1.10.4 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.4 (ryanglscott)
07:07:12 <iphy> is there a better way to write this? https://www.irccloud.com/pastebin/WOrefpEK/
07:11:19 <bergmark> @pl \x -> (f x, id x)
07:11:19 <lambdabot> (,) =<< f
07:12:03 <bergmark> ... i was thinking `f &&& id`
07:13:46 <iphy> cool, that's better, thanks
07:14:08 * hackagebot heap 1.0.3 - Heaps in Haskell  https://hackage.haskell.org/package/heap-1.0.3 (eberlm)
07:15:19 <byorgey> iphy: how many different PacketKinds are there?
07:15:58 <iphy> byorgey: currently 20, so I've resolved to writing the number mapping myself
07:16:56 <byorgey> iphy: OK, makes sense.  I was going to say if PacketKind has an Ord instance you could make it a bit faster (binary instead of linear search) but it probably doesn't matter very much with only 20, and might even be slower
07:17:05 <iphy> https://github.com/TokTok/hstox/blob/master/src/Network/Tox/Network/PacketKind.hs
07:17:25 <iphy> byorgey: right, and it won't ever be more than 256
07:17:59 <iphy> and likely not much more than 20 actually
07:18:22 <byorgey> right.  If it was actually 256 it might be faster to use binary search, but still probably only worth doing if you actually discovered it to be a bottleneck.
07:18:30 <iphy> anyway, efficiency is very low on the list of priorities for this project
07:18:36 <byorgey> fair enough =)
07:18:58 <iphy> it's supposed to be a model implementation of a spec against which other (more efficient) implementations can be validated, so clarity is top priority
07:20:13 <byorgey> ah, makes sense.  yes, then in that case I think your current implementation (using &&&) is probably the best possible.
07:20:29 <iphy> I like it :)
07:24:01 <iphy> does Prelude export Monoid? and since when does it do that? because I use it and it works locally, but it doesn't work on Travis CI (which uses an older ghc and base)
07:24:30 <{AS}>  iphy I believe it is a part of the Monoid Semigroup proposal
07:24:52 <{AS}> https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
07:25:12 <iphy> I see
07:25:46 <{AS}> iphy: Or, I mean I believe it was proposed in conjunction
07:25:58 <byorgey> iphy: yes, that's fairly recent, since GHC 7.10 IIRC
07:26:47 <{AS}> iphy: here it is https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10
07:27:11 <byorgey> iphy: if you want to support both without resorting to CPP, you can depend on the base-compat package, and import Data.Monoid.Compat
07:27:31 <byorgey> which will be either a re-export of Data.Monoid, or empty, depending on the version of the compiler used
07:27:50 <{AS}> byorgey: iphy You should really fix the version of GHC in Travis to match your dev env
07:28:05 <{AS}> byorgey: Sorry, only meant to highlight iphy 
07:32:29 <byorgey> {AS}: I disagree.  The great thing about Travis is that it lets you test on multiple GHC versions, including ones different than your dev environment.
07:33:02 <byorgey> {AS}, iphy: for an easy solution setting up Travis to test on multiple versions of GHC, see https://github.com/hvr/multi-ghc-travis
07:33:26 <tdammers> depends what you're writing I guess
07:34:00 <iphy> {AS}: no, my travis env matches my customer's env
07:34:08 <{AS}> iphy: Ah
07:34:13 * hackagebot base-orphans 0.5.3 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.5.3 (ryanglscott)
07:34:58 <tdammers> if the code is for a single customer, then it makes more sense to just test against that, yeah
07:35:11 <tdammers> but if it's a general-audience library, testing against multiple versions is nice
07:35:32 <mogunus> Hi. I’m trying to figure out if there is a way to take a list of Ord a and get an a that definitely isn’t in the list.
07:36:00 <iphy> yeah, I can think about that later, when/if I get more customers
07:36:25 <mogunus> Obviously this works for anything that is like an integer, because you can take max and then shift. But is there anything similar that would do that for just Ord? Alternately, what’s the mimum typeclass that I’d need to do something like that…?
07:36:37 <sbrg> mogunus: You can't go from some type of Ord to all the values that inhabit that type. maybe Enum?
07:37:09 <jophish> Better throw Bounded in there too
07:38:20 <sbrg> true
07:38:52 <mogunus> I see… Ok, I see the need for Enum. But not quite bounded. The methods are just minBound and maxBound right?
07:39:18 <mogunus> Is the concern that I might be exceeding the maxBound of the enum with my “definitely outside” element and need to check?
07:40:08 <sbrg> mogunus: Well, if you enumerate all values of a type that is an instance of Enum, you can be enumerating forever. Integer, for example
07:40:19 <iphy> (just a side note being captain obvious: your function is partial)
07:41:24 <sbrg> mogunus: Why do you want to do this? It probably won't be optimal to do for many types that are instances of both Bounded and Enum. Like all Ints.. that's a lot of ints to check
07:41:28 <mogunus> sbrg: Ah, I see. I only ever need a finite number of not-in-the-list elements, though? Maybe that changes this.
07:42:05 <jophish> mogunus: It's probably best to generate a (lazy) list of every element and filter out the ones you don't want
07:42:14 <sbrg> mogunus: yeah, that would probably change it. but depending on the sizes of your input, it may not be very efficient. 
07:42:17 <jophish> if the list of rejects is small this works pretty well
07:42:56 <jophish> If it's not important to eventually get 100% coverage you could use a bloom filter to be really quick
07:43:04 <sbrg> mogunus: Actually, if you sort it and find the first pair of elements (x, y) so that there exists a z = succ x that is x < z < y you could probably do it somewhat efficiently
07:43:13 <sbrg> since it's an instance of Ord
07:43:34 <mogunus> sbrg: efficiency isn’t super important at this point, I’m just trying to figure out some properties of the type system
07:43:49 <sbrg> s:that is:such that:
07:43:52 <sbrg> mogunus: I see
07:44:05 <jophish> ah yes, if they're in Orf, sbrg's sorting solution sounds best
07:44:08 <jophish> Ord*
07:45:04 <sbrg> Well, Ord is for types that are Ordered, but it doesn't say anything about them being enumerable or bounded. So you want Enum and Bounded.
07:46:05 <sbrg> but with sorting, I think the worst case is O(n). n log n for the sorting, n for the search for the pairs. 
07:46:19 <mogunus> Okay, I understand now. Because I need to be able to get a finite list of new, all-unique elements that don’t occur in the incoming list.
07:47:23 <sbrg> yes
07:48:05 <mogunus> Now here’s my primary question, I guess: say I do this, and re-shuffle my data structure using the “fresh” elements. Then I replace all “fresh” elements with the elements that were in my input, so there will never be any artificially generated elements in the output of this function, only the input elements satisfying Ord. How do I convience the typechecker of this?
07:49:04 <mogunus> I will certainly accept answers like, “you should never do that”.
07:50:06 <mogunus> But it’s a property that is fairly easy to prove about this type of code. So I was wondering if I could get it into the type system somehow.
07:52:25 <Lokathor> if i just need a beginner's web server where i can respond to appropriate requests with files already on disk, will warp serve me well?
07:54:37 <sbrg> Lokathor: i haven't used warp, but scotty and spock would make that really easy
07:54:56 <Lokathor> what's the difference between the two of those?
07:55:05 <Lokathor> also, why so many star trek names with the web servers?
07:55:17 <c_wraith> spock is a "simplified" remake of scotty
07:55:23 <c_wraith> Which is why the name similarity.
07:55:33 <sbrg> haha, no idea on the latter. I think Spock does some more type-safe routing stuff
07:55:33 <c_wraith> (I don't know if it's actually simpler, I just know that's what the author was going for)
07:55:45 <Lokathor> well one could consider "warp" to also be a star trek name, though perhaps not intentionally
07:56:11 <Lokathor> alright i'll try spock later today i guess
07:56:12 <c_wraith> iirc, both scotty and spock are based on warp
07:56:13 <Lokathor> gotta go to work for now
07:56:49 <Lokathor> I'll make my own series of webserver programs.. sisko, paris, seven, and so on
07:59:25 <cheater> please not "paris"
07:59:30 <cheater> worst character ever
07:59:41 <Lokathor> :(
07:59:49 <Lokathor> more like best gary stu ever
07:59:52 <cheater> might as well go with archer then
08:01:52 <jophish> Nobody's mentioning Wesley?
08:10:01 <muzzle> can you guys help me with frp?
08:10:26 <muzzle> i'm developming a simulation of an agent system
08:10:35 <muzzle> that i am visualizing using sdl2
08:10:56 <muzzle> and for various visualization related stuff i wanted to set the whole thing up using FRP
08:12:06 <muzzle> basically i want to run my simulation in an infinite loop, that has a typesignature like
08:12:27 <muzzle> WorldState -> Behavior Bool -> MomentIO (Behavior WorldState)
08:12:36 <muzzle> and run that loop in a separate thread
08:12:43 <muzzle> is that a valid approach ?
08:13:02 <muzzle> the behavior bool i would use if i wanted to stop the simulation for some reason
08:13:07 <muzzle> (temporarily)
08:53:13 <ClaudiusMaximus> Ix has  index :: Ix a => (a, a) -> a -> Int  but is there something to go the other way, like  unIndex :: Ix a => (a, a) -> Int -> a  or how would i write it?
08:55:20 <lyxia> ClaudiusMaximus: you could access the range list
08:55:20 <ClaudiusMaximus> i mean i could use range and !! but it'd be horribly slow
08:55:24 <lyxia> heh
08:56:31 <ClaudiusMaximus> i guess it'd need to be a class method so that it could be implemented efficiently at all types, perhaps with a default implementation for types with Enum
08:57:05 <opqdonut> mmh
08:57:08 <opqdonut> sounds reasonable
08:58:26 <ClaudiusMaximus> where should i file this feature request?  ghc trac?
08:59:07 <bennofs> ClaudiusMaximus: probably as a proposal to the libraries@ mailing list:https://mail.haskell.org/mailman/listinfo/libraries
08:59:22 <ClaudiusMaximus> bennofs: ah, ok
09:00:40 <ClaudiusMaximus> I'll maybe do it after i've done the more fun stuff, will hard-code to Int instead of general Ix for the time being
09:04:04 <ski> @type \ix -> listArray (0,rangeSize ix - 1) (range ix)
09:04:05 <lambdabot> Ix e => (e, e) -> Array Int e
09:04:12 <ski> @type \ix i -> listArray (0,rangeSize ix - 1) (range ix) ! i
09:04:13 <lambdabot> Ix e => (e, e) -> Int -> e
09:04:17 * hackagebot git-annex 6.20160229 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160229 (JoeyHess)
09:04:40 <ski> ClaudiusMaximus : .. obviously wasteful in space instead of time
09:05:53 <ClaudiusMaximus> ski: probably wasteful in time too, depending on how range is implemented (not to mention listArray)
09:07:27 <ClaudiusMaximus> ski: but i guess the array can be memoized for multiple calls
09:08:00 <ski> yes
09:12:29 <wagle> whats the funtion for inhaling a file (by name) into a String?
09:14:30 <wagle> ooh,,  readfile..  thought it had an odder name
09:14:52 <toogley> hello. what does this mean? cabal: At least the following dependencies are missing:
09:14:54 <toogley> QuickCheck -any
09:15:07 <dcoutts> toogley: when running configure?
09:15:19 <toogley> dcoutts: when running cabal build
09:15:40 <dcoutts> toogley: ok, try: cabal install --only-dependencies  [--enable-testsuites] [--dry-run]
09:16:29 * dcoutts notes the next-gen cabal code will do this automagically
09:16:56 <toogley> dcoutts: thanks
09:24:17 * hackagebot postgresql-typed 0.4.3 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/postgresql-typed-0.4.3 (DylanSimon)
10:01:43 <slack1256test> Does anybody have shipped a fltk app on windows? was it painful?
10:03:51 <sm> slack1256test: I suspect nobody has yet, except maybe the fltkhs author
10:06:15 <sm> from his docs, it sounds painful to build, but non-painful to ship 
10:06:53 <slack1256test> yeah, that is the major selling point of this. I want to believe!
10:07:48 <sm> please try it and report back!
10:08:14 <slack1256test> searching already for a winPC, I'll come back tomorrow
10:08:33 <sm> great. Might work on wine too
10:16:35 <hunteriam> Is there still an opportunity to apply to be a student in Haskell GSOC?
10:16:43 <hunteriam> Also, is it a good idea career wise to participate?
10:17:03 <hunteriam> Because I love Haskell deeply, but If the experience won't count for anything, I cant justify it
10:17:17 <hiptobecubic> Pretty much anything that involves making real things with smart people is good, career wise.
10:17:18 <hunteriam> Career-wise, of course it counts for quite a lot personally
10:17:27 <hunteriam> Ok, thats good to hear
10:18:01 <hunteriam> If anyone can direct me w.r.t Haskell GSOC id greatly appreciate it
10:28:18 <Nahiyan> Hi I have a question
10:28:29 <dmj`> Nahiyan: yes
10:28:35 <Nahiyan> This line spits out an error: let prefs n = [10.0^(i/n) | i <- [1..n]]
10:28:45 <Nahiyan> "Could not deduce (Fractional b0) arising from a use of ‘prefs’"
10:28:53 <Nahiyan> how can I fix it?
10:29:00 <bash0r> :: Double 
10:29:05 <Nahiyan> I mean that line doesn't but it does when I try to call the function
10:29:10 <Nahiyan> ok
10:29:13 <bash0r> Or other concrete number type 
10:29:17 <hpc> :t let prefs n = [10.0^(i/n) | i <- [1..n]] in prefs
10:29:18 <lambdabot> (Fractional t, Fractional b, Integral b) => b -> [t]
10:29:27 <geekosaur> jej
10:29:29 <geekosaur> heh
10:29:30 <hpc> :t (^)
10:29:31 <lambdabot> (Integral b, Num a) => a -> b -> a
10:29:38 <hpc> use (**) instead of (^)
10:29:39 <Nahiyan> um
10:29:43 <Nahiyan> ohh
10:29:49 <Nahiyan> :t (**)
10:29:50 <lambdabot> Floating a => a -> a -> a
10:30:07 <hpc> i am not entirely sure why those others are defined differently
10:30:19 <hpc> except perhaps just so integers can do it too
10:30:55 <Nahiyan> bash0r, how can I use `let` with a type definition
10:31:11 <Ankhers> let x = 5 :: Integer
10:31:36 <bash0r> You can say let foo = 10; foo :: Int in foo
10:31:38 <Nahiyan> ahh
10:31:46 <Nahiyan> thanks!!
10:31:59 <bash0r> If you want more complex signature 
10:32:14 <bash0r> Then you can split it on 2 lines 
10:32:32 <bash0r> Or just add Ankhers said ^^
10:32:40 <bash0r> As *
10:33:00 <Nahiyan> what about in my example prefs? I am trying: let prefs n = [10.0**(i/n) | i <- [1..n]]; prefs :: Int -> [Double] in prefs
10:33:04 <Nahiyan> but it isn't working
10:33:26 <hpc> :t let prefs n = [10.0**(i/n) | i <- [1..n]] in prefs
10:33:27 <lambdabot> (Enum t, Floating t) => t -> [t]
10:33:44 <monochrm> i/n is a type error when n :: Int
10:33:47 <hpc> the first parameter is the same type as your result list
10:34:04 <Nahiyan> ok...
10:34:07 <hpc> if you're dead set on Int, use (fromIntegral i / fromIntegral n)
10:34:18 <Nahiyan> Thanks!!
10:34:24 <hpc> :t fromIntegral
10:34:25 <lambdabot> (Integral a, Num b) => a -> b
10:34:40 <Nahiyan> I thought the function name for converting types would be toDouble or something !
10:34:49 * hackagebot wacom-daemon 0.1.0.0 - Manage Wacom tablet settings profiles, including Intuos Pro ring modes  https://hackage.haskell.org/package/wacom-daemon-0.1.0.0 (IlyaPortnov)
10:36:07 <hpc> and just to rub in how silly it can get, fromIntegral = fromInteger . toInteger
10:36:09 <Nahiyan> I still haven't understood the type definition statements. So (...) defines the types of a and b, and a -> b states the domain & range of the function?
10:36:24 <bash0r> let prefs :: Double -> Double; prefs n = [10 ** (i / n) | i <- [1..  n]  in prefs 
10:36:59 <hpc> Nahiyan: (...) => type -- this means type, but with some constraints
10:37:07 <bash0r> a says just that there is some type you know barely nothing about. 
10:37:21 <hpc> Nahiyan: there's many different numeric types, and the class constraints to the left of the fat arrow narrow it down
10:37:22 <bash0r> b is same 
10:37:39 <bash0r> The arrow states a transformation from some type to another 
10:38:00 <hpc> Nahiyan: (a -> b) means a function that takes an 'a' and produces a 'b'
10:38:04 <bash0r> In a -> b it states a transformation from some type a to some type b
10:38:20 <Nahiyan> ok let me read this
10:38:39 <Nahiyan> ok ok.
10:38:55 <hpc> similarly, f :: (a -> b -> c) means you can do let c = f a b
10:38:55 <Nahiyan> just "a -> b" is the most general function right?
10:39:06 <bash0r> When stating concrete types you know the concrete structure and you are able to perform pattern matching and such things 
10:39:29 <bash0r> Yes. You can't know less about the types of a function 
10:39:39 <Nahiyan> ok I'm not sure I understand but I guess I understand what you said about concrete types
10:39:50 <nitrix> Nahiyan: It's so general, it's actually almost impossible to implement in a useful manner.
10:40:16 <hpc> one could argue s/almost// :P
10:40:35 <Nahiyan> ok thanks
10:40:38 <Nahiyan> !
10:40:45 <bash0r> When adding a context such as (Num a) => a -> a -> a you say that you know that it's at least a Num 
10:41:20 <bash0r> By that you can use functions implemented for some type a that guarantees to be implemented 
10:41:22 <nitrix> Nahiyan: Typically, type variables have constraints to them. (a -> b) is just way too general.
10:42:05 <Nahiyan> ok thanks... I have one last question.. when hpc used :t on prefs, it returned "(Enum t, Floating t) => t -> [t]". What does that mean?
10:42:19 <bash0r> Eg: foo :: (Num a) => a -> a
10:42:28 <bash0r> foo n = n * n
10:42:43 <Nahiyan> ok
10:42:50 <hpc> Nahiyan: it means the type 't' must be a floating point number type
10:42:54 <Nahiyan> sorry I meant what does the Enum part mean?
10:42:54 <hpc> Nahiyan: and it also must be enumerable
10:42:59 <bash0r> :t (*) 
10:43:00 <lambdabot> Num a => a -> a -> a
10:43:00 <Nahiyan> what is the Enum constraint?
10:43:05 <hpc> so like, you can list the values between 'a' and 'b'
10:43:19 <nitrix> Nahiyan: That's be that it takes any type `t` and returns a list of `t`, but the type in question must be an instance of both the Enum and Floating type classes, which guarantees some operations are possible on it.
10:43:27 <bash0r> It enables access to functions provided by that type class 
10:43:28 <hpc> [1 .. n] translates to enumFromTo 1 n
10:43:30 <hpc> :t enumFromTo
10:43:32 <lambdabot> Enum a => a -> a -> [a]
10:43:41 <hpc> enumFromTo lists the values between its two parameters
10:43:48 <hpc> > [False .. True]
10:43:50 <lambdabot>  [False,True]
10:43:52 <Nahiyan> ok so the type being enumerable means that it can be put into a list?
10:44:03 <nitrix> @let data Demo = DemoOne | DemoTwo | DemoThree deriving (Show, Enum, Bounded)
10:44:05 <lambdabot>  Defined.
10:44:14 <nitrix> > [minBound..maxBound] :: [Demo]
10:44:16 <lambdabot>  [DemoOne,DemoTwo,DemoThree]
10:44:18 <hpc> you can make lists of anything
10:44:20 <bash0r> It means that you can use the .. Operator on it 
10:44:23 <nitrix> > fromEnum DemoTwo
10:44:24 <lambdabot>  1
10:44:26 <Nahiyan> ahhh
10:44:28 <hpc> but Enum says you can make lists in this particular way
10:44:42 <Nahiyan> > fromEnum 5
10:44:44 <lambdabot>  5
10:44:54 <hpc> > fromEnum False
10:44:56 <lambdabot>  0
10:44:57 <nitrix> Nahiyan: Int's Enum instance is very boring.
10:45:03 <bash0r> It is used in list comprehension expressions though 
10:45:03 <Nahiyan> ok that returned the index of the list which has the number 5 from [1..] right?
10:45:19 <hpc> > fromEnum LineBuffering -- wonder if that's in scope...
10:45:21 <lambdabot>  Not in scope: data constructor ‘LineBuffering’
10:45:23 <nitrix> Nahiyan: There's no list involved there.
10:45:35 <bash0r> Nitrix is right 
10:45:49 <Nahiyan> umm
10:45:51 <nitrix> Nahiyan: It's the type itself that's enumerable.
10:45:55 <Nahiyan> ok
10:46:29 <Nahiyan> ok thanks I think I understand most of this. Thank you very much!!
10:46:48 <bash0r> Pleased to help 
10:47:12 <nitrix> Nahiyan: Repetition will eventually break the mental block. Don't worry too much :)
10:47:26 <Nahiyan> thanks
10:47:36 <hpc> and once you're comfortable with this, the rabbit hole goes even further
10:47:37 <nitrix> Fortunatly, type classes makes (for the most part) a lot of sense in Haskell.
10:47:46 <dedgrant> Nahiyan: Not sure if anyone mentioned, but if you have questions about specific things like the Enum constraint, hoogle can be useful: http://haddock.stackage.org/lts-5.5/base-4.8.2.0/Prelude.html#t:Enum  -- that should help reinforce
10:47:56 <Nahiyan> thanks I'll read that
10:48:18 <hpc> https://www.haskell.org/hoogle/
10:48:23 <dedgrant> (y)
11:00:57 <burbly> Could someone point me at the last v. of the Haskell Platform for Windows WITHOUT the burning bridges changes? (So I can compile some old code)
11:01:46 <ReinH> burbly: why not use stack instead?
11:01:55 <ReinH> It makes it much easier to switch haskell versions
11:03:22 <burbly> What's stack?
11:03:33 <bitemyapp> burbly: sort of an alternative to cabal-install.
11:03:49 <ReinH> www.haskellstack.org
11:03:55 <bitemyapp> burbly: it's sorta like rvm/nvm/virtualenv/multirust+cargo
11:04:05 <bitemyapp> or leiningen
11:04:09 <bitemyapp> burbly: or, imagine a maven/ivy that also manages your Java install.
11:04:33 <bitemyapp> #PackageManagerAnalogies > #MonadAnalogies
11:04:39 <ReinH> heh
11:04:44 <burbly> I already have cabal files forthe software + don't want to tinker -- so 
11:04:51 * hackagebot pretty 1.1.3.3 - Pretty-printing library  https://hackage.haskell.org/package/pretty-1.1.3.3 (DavidTerei)
11:04:52 <burbly> will stick with cabal for now
11:04:52 <jle`> stack uses cabal files
11:04:56 <jle`> stack uses cabal
11:04:58 <average> how much money can I make with a Monad ?
11:05:09 <burbly> https://www.haskell.org/platform/prior.html doesn't tell you which v. corresponds to which GHC v.
11:05:21 <burbly> If I pick up 2014.2.0.0, August 2014 ⟹ Linux, 64bit - Mac OS X, 64bit - Windows, 32bit - Windows, 64bit - Source
11:05:24 <jle`> burbly: what stack would do for you is managing the GHC versions on your computer and your dependences
11:05:31 <luigy> he did mention some old code... snapshots/compiler don't go bellow 7.8, so that mileage may vary xD
11:05:32 <burbly> is that before the change?
11:05:35 <dcoutts> burbly: old versions of the HP are available from the HP download site
11:05:54 <ReinH> burbly: You just need GHC and cabal, you don't need the platform.
11:06:08 <burbly> @ReinH: platform makes life easier
11:06:08 <lambdabot> Unknown command, try @list
11:06:12 <ReinH> In fact, the platform can often make it *harder* to install packages.
11:06:16 <jle`> if you just want to try out some old code then the platform might just make your life a mess
11:06:18 <ReinH> It often makes life harder.
11:06:24 <dcoutts> burbly: https://www.haskell.org/platform/prior.html
11:06:28 <kadoban> burbly: I strongly disagree in general, though I don't know what you're trying to get building.
11:06:41 <burbly> I built the old code under the haskell platform, so I know it will compile
11:06:43 <ReinH> If you want to install a package, the only downside to not using the package is a slightly longer dependency install time
11:06:47 <burbly> not trying to make a general statement
11:06:59 <burbly> @dcoutts: see above -- 
11:06:59 <lambdabot> Unknown command, try @list
11:07:06 <ReinH> er, not using the platform
11:07:17 <ReinH> And you can pick the version of ghc you want, rather than guessing.
11:07:25 <burbly> have seen that page, but can't tell which v.s were before burning bridges
11:07:39 <average> is Haskell primarily a choice made to prove someone has tech decision power within a company ?
11:07:40 <dcoutts> burbly: you want the last release that has ghc-7.8
11:07:58 <burbly> dcoutts: thank you!
11:08:13 <ReinH> average: So far your questions are indistinguishable from trolling. Please try to make more effort.
11:09:12 <James123> A maybe stupid question: Assume I do `find . -type f` | head -10 | ...`. Is there a way to make find lazy i.e. stop after 10 results?
11:09:26 <ReinH> James123: is that a Haskell question?
11:09:51 <James123> ReinH: No, but maybe Haskell could help with its lazy evaluation, a haskell implementation of find ??
11:10:04 <johnw> James123: that we can certainly do
11:10:09 <ReinH> Generally speaking, if a downstream consumer closes a pipe, the upstream producer will receive a SIGPIPE and have the option to terminate.
11:10:12 <johnw> James123: I wrote pipes-files for constructions like that
11:10:33 <ReinH> What find will do in that particular case, i don't know.
11:10:41 <koala_man> James123: it's already lazy, but on a buffer level
11:11:33 <burbly> thanks all
11:11:55 <koala_man> James123: you can reduce the buffer size with stdbuf, unbuffer or script (making it line buffered), in which case it would stop after 11 files (10 plus one to detect that head exited)
11:12:41 <James123> koala_man: Thank you very much!
11:13:24 <geekosaur> and that's the best you can do, since any laziness or lack of same in find gets hidden by the pipe
11:13:43 <ReinH> (Note that your pipeline will give bad results when filenames contain newlines, which is not at all impossible)
11:14:48 <James123> ReinH: Hmm, good point
11:14:58 <Nahiyan> Hello I am back with another problem...
11:15:06 <Nahiyan> let roundTo a b = (fst pair) + (round (snd pair) * (10.0^b)) / (10.0^b) where pair = properFraction a
11:15:27 <Nahiyan> this definition works but I get another error when trying to use it
11:15:29 <geekosaur> (in fact you're not considering that in your analysis: the OS inserts its own buffering, whose size depends on the kernel; you can check for PIPE_BUF in your system include files
11:15:56 <Nahiyan>  No instance for (Fractional a0) arising from a use of ‘it`
11:15:57 <geekosaur> on most modern Linuxes this is 4096 bytes and any smaller buffer size in find will be irrelevant
11:16:16 <ReinH> Nahiyan: what did you do to get that error?
11:16:31 <ReinH> it is a placeholder for the result of a previous expression, so we need to know what the previous expression was.
11:16:35 <Nahiyan> I did: roundTo 1.333 2
11:16:55 <James123> geekosaur: Very interesting that about the OS buffer, thanks for the advice
11:16:59 <Nahiyan> this is the type: roundTo :: (Fractional a, Integral a, Integral b, RealFrac a1) => a1 -> b -> a
11:17:11 <ReinH> You won't find a type that is both Fractional and Integral.
11:17:23 <ReinH> So while your function typechecks, it is not usable.
11:17:29 <Nahiyan> ohh..
11:17:47 <ReinH> You probably want to use fromIntegral in strategic place(s).
11:18:00 <ReinH> :t (^)
11:18:01 <lambdabot> (Integral b, Num a) => a -> b -> a
11:18:17 <Nahiyan> this is really weird. I only used a in: pair = properFraction a
11:18:21 <ReinH> :t (/)
11:18:22 <Nahiyan> :t properFraction
11:18:23 <lambdabot> Fractional a => a -> a -> a
11:18:24 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
11:20:07 <Nahiyan> ok got it I think
11:20:40 <Nahiyan> nope..
11:21:47 <jle`> who needs MaybeT/StateT when you have Free (Sum Maybe IO)
11:22:57 <scshunt> lol
11:25:02 * hackagebot syntactic 3.5 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.5 (EmilAxelsson)
11:26:17 <mniip> jle`, sum being what?
11:26:33 <jle`> from transformers
11:27:04 <jle`> data Sum f g a = InL (f a) | InR (g a)
11:35:02 * hackagebot purescript 0.8.2.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.2.0 (PhilFreeman)
11:40:29 <sphinxo> I was creating some kind of typeof typeclass for my interpreted lang like so:
11:40:33 <sphinxo> class TypeOf a where typeOf :: a -> Type a
11:41:03 <sphinxo> Where Type is some datatype with like TInt, TBool and stuff
11:41:32 <sphinxo> Could I use Typeable for this?
11:41:58 <sphinxo> (instead of defining my own typeclass)
11:46:32 <jle`> sphinxo: typeable would have typeOf :: a -> Type
11:46:37 <jle`> sphinxo: and you could tuple it up if you want
11:47:06 <jle`> myTypeOf x = (typeOf x, x)
11:47:18 <jle`> unless you mean that yout Type is a GADT
11:48:08 <sphinxo> jle`: I have like http://lpaste.net/7073501761427734528
11:48:53 <sphinxo> So I shouldn't need to tuple it up right?
11:50:45 <lyxia> That's odd, a pinned bytearray is not moved but twice the space is still allocated
11:51:28 <ClaudiusMaximus> base 4.5 corresponds to which ghc release?
11:55:12 <demize> 7.4.1 it seems like.
11:55:35 <ClaudiusMaximus> yep, thanks
12:12:34 <mattn> so I think I’m bumping up on a bug in accelerate-llvm or the way I’m using it (parallel workers operating on a common Ptr Word8 buffer), but I
12:12:46 <mattn> ‘m not sure how to further debug it; can anybody advise?
12:13:59 <johnw> mattn: the problem with "asking to ask" is that you're asking people to commit to helping you without knowing the scope of the problem or if they want to get involved.  So, most of the time no one will respond to such a query.
12:14:53 <johnw> however, we're mostly suckers for an actual question...
12:14:58 <mattn> heh
12:15:27 <mattn> ok, how about this: I have a wxHaskell app where the image to be displayed is rendered in chunks by a bunch of worker threads
12:15:28 <monochrom> my slogan is not "don't ask to ask, just ask". my slogan is "don't answer to answer. just don't answer."
12:16:06 <monochrom> (studies show that I can't answer 94% of the questions anyway.)
12:16:10 <mattn> I’ve got it set up so that a redraw prevents new workers from spawning and waits until existing workers are finished, so the redraw won’t see any partial results
12:16:27 <mattn> based on putStrLns scattered around, that part appears to be working properly.
12:17:13 <mattn> I have a couple different ways the workers can operate: using a native Haskell function, or using Accelerate with either the interpreter or the LLVM backend.
12:17:57 <mattn> when using the LLVM backend, I’m seeing blocks of the image that look as if they are drawings of random hunks of memory (mostly black, with some chunks of contiguous color)
12:18:13 <mattn> it gets worse if I bump the number of worker threads past the number of capabilities
12:18:37 <mattn> I’m not sure how to debug the problem much past this point.
12:19:11 <mattn> Any ideas?
12:19:19 <johnw> mattn: how could you even obtain such raw bytes?
12:20:37 <mattn> johnw: from a mallocForeignPtrBytes (called once at the start of the program; each worker writes to a different part of that big array)
12:21:09 <mattn> and the foreign pointer is passed on to wxHaskell to build an Image
12:21:19 <johnw> so it sounds like it's being read before being written to?
12:22:00 <mattn> no, it seems to be stranger. It’s initialized to grey before any work begins, but the “wrong” blocks are mostly black.
12:23:05 <mattn> and again, only one of the three worker strategies shows this behavior.
12:25:35 * hackagebot vulkan 1.2.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.2.0.0 (jophish)
12:25:37 * hackagebot bitwise 0.1.1 - fast multi-dimensional unboxed bit packed Bool arrays  https://hackage.haskell.org/package/bitwise-0.1.1 (ClaudeHeilandAllen)
12:28:43 <mattn> also, the buffer is written to multiple times with progressively higher resolution, yet I’m seeing low-res normal tiles overwritten by higher-res “uninitialized memory”-looking tiles
12:29:04 <mattn> which to me suggests that I’m uninitialized data back from my accelerate computation somehwo
12:29:06 <mattn> *somehow
12:29:17 <platz> I find it odd that a package has 1353 downloads, but there are no repos or gists on github showing evidence of using said package
12:30:35 * hackagebot generic-aeson 0.2.0.8 - Derivation of Aeson instances using GHC generics.  https://hackage.haskell.org/package/generic-aeson-0.2.0.8 (ErikHesselink)
12:31:07 <liste> platz maybe it has only proprietary use, and/or is downloaded for caching
12:32:39 <platz> liste: MIT liscence, but my theory for a while is that something like stackage is inflating counts
12:34:45 <sphinxo> I'm getting  renameFile: unsupported operation (Invalid cross-device link)
12:34:51 <sphinxo> when I try and hindent
12:35:02 <sphinxo> ( I installed hindent with stack )
12:35:17 <sphinxo> Any ideas?
12:35:17 <mattn> aha, the plot thickens
12:35:18 <platz> might be interesting to pull the download counts for a month and see what is correlated
12:35:52 <platz> since there is no history, though i'm sure it's sitting on the server somewhere out of reach
12:36:38 <mattn> I previously ran into an accelerate-2.0.0.0 bug having to do with converting between complex numbers and tuples; something was using unsafePerformIO that should have been using unsafeInterleaveIO.
12:37:17 <mattn> whoops, no, that doesn’t explain this either..
12:38:08 <jle`> i've been using ImplicitParams as a 'more flexible' MonadReader that doesn't force me to write everything using do notation
12:38:11 <jle`> i wonder if i'm evil or not
12:38:56 <jle`> MonadReader Foo m => m Bar  ===   (?ask :: Foo) => Bar
12:39:31 <jle`> one of the advantages of Reader/MonadReader is that you can compose them and "call" them seamlessly from within other actions, so you don't have to pass in parameters manually if you have a long chain of calls
12:39:34 <jle`> this does the same thing
12:44:05 <c_wraith> jle`, I don't think Reader is worth it by itself, but ReaderT sure can be 
12:44:43 <jle`> yeah, but i'm talking about this to replace general MonadReader r m usage
12:44:45 <jle`> not just Reader
12:45:17 <jle`> and one nice thing about this is that you can have different 'asks' for different environment parameters, without layering raders or using lens tricks
12:45:30 <jle`> (?ask1 :: Foo, ?ask2 :: Bar) => ...
12:46:06 <sphinxo> Could I have some code review on http://lpaste.net/8554810448237559808
12:46:16 <sphinxo> I'm looking for anything
12:46:35 <jophish> sphinxo: no module name on line 6
12:46:50 <jophish> :D
12:46:56 <muesli4> Hi, what is the best way to parse nested files with Parsec? (By that I mean a filename which I found in another file, which is kind of *included* into it.) Should I used the MonadIO instance, or is there some better way?
12:47:06 <sphinxo> Right :) jophish 
12:47:19 <tdammers> ParsecT over IO, I'd say
12:47:42 <tdammers> alternatively, defer the nesting to a pass on the parsed AST
12:47:44 <sphinxo> jophish: Fixed :)
12:48:15 <sphinxo> jophish: Apart from that, what else can you tell me?
12:48:53 <muesli4> tdammers: That's basically my thought process and I don't want the latter.
12:49:13 <tdammers> well, then having IO in your parser is kind of unavoidable
12:49:52 <jophish> muesli4: another alternative would be to extract the file dependency graph first and then do a detailed parse
12:50:14 <tdammers> yeah, that could work too, depending on the grammar
12:50:19 <jophish> (depending on how easy it is to extract these include statements)
12:51:03 <tdammers> yeah
12:51:20 <jophish> sphinxo: looks pretty neat, although you might want to make your functions total
12:51:30 <sphinxo> jophish: Like how?
12:51:38 <jophish> get rid of 'error' and return Nothing for example
12:51:58 <sphinxo> oh nice
12:53:26 <sphinxo> Any way i could merge TypeOfExpr and TypeOf?
12:54:13 <koala_man> muesli4: I ended up basically generalizing to Monad m => ParsecT String state m v  and passing in a function  FilePath -> m String. it's not awesome to read the files into memory, but it made it easy to just run pure functions for unit testing and sandboxing
12:55:13 <jophish> sphinxo: write typeOfExpr in terms of typeOf perhaps
12:55:29 <muesli4> koala_man: My files are small, so I see no problem with that. Thanks, that's really a good idea.
12:56:23 <monochrom> koala_man: w00t, that's a smart move, to keep the m as a variable, so you know it is not arbitrary IO
12:56:44 <sphinxo> jophish: How?
12:57:35 <muesli4> monochrom: Functions always surprise me ;)
12:58:54 <jophish> sphinxo: typeOfExpr :: forall a. Expr a -> Type a; typeOfExpr _ = typeOf (undefined :: a)
12:59:14 <jophish> you'll need ScopedTypeVariables
13:00:50 <sphinxo> oh wow
13:00:54 <sphinxo> Nice, thanks
13:01:01 <jophish> yw
13:01:22 <monochrom> I like ScopedTypeVariables too
13:02:14 <jophish> sometimes I explicitly scope my variables just for fun
13:03:22 <sphinxo> jophish: That's hardcore
13:03:51 <enthropy> typeOfExpr = typeRep
13:04:21 <sphinxo> hmm, No instance for (TypeOf a) arising from a use of ‘typeOf’?
13:04:51 <sphinxo> tried: typeRep :: (TypeOf a) => forall a. Expr a -> Type a
13:05:32 <jophish> sphinxo: you need the forall first
13:05:56 <enthropy> typeOf and typeRep give you a TypeRep not "Type a", too
13:06:11 <monochrom> forall a. TypeOf a => Expr a -> Type a
13:06:38 * enthropy assumed it was from Data.Typeable, not a different definition in the paste above
13:07:07 <enthropy> so disregard what I said above
13:07:17 <sphinxo> this scopedtypevariables stuff is nifty
13:20:29 <sphinxo> How should I handle errors in my interpreter? I only have a couple of predefined ones.
13:20:34 <sphinxo> MonadError?
13:20:36 * hackagebot lambdacube-ir 0.3.0.0 - LambdaCube 3D intermediate representation of 3D graphics pipelines  https://hackage.haskell.org/package/lambdacube-ir-0.3.0.0 (CsabaHruska)
13:20:38 * hackagebot lambdacube-gl 0.5.0.1 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.5.0.1 (CsabaHruska)
13:20:40 * hackagebot lambdacube-compiler 0.5.0.0 - LambdaCube 3D is a DSL to program GPUs  https://hackage.haskell.org/package/lambdacube-compiler-0.5.0.0 (CsabaHruska)
13:25:37 * hackagebot vulkan 1.3.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.3.0.0 (jophish)
13:27:50 <Cale> sphinxo: Do you already have some special monad?
13:28:11 <sphinxo> No
13:28:35 <Cale> sphinxo: In that case, I'd probably just use Either SomeErrorType Result
13:28:53 <sphinxo> Ahh ok
13:29:38 <Cale> (and if it's an IO action, you can have it produce something of that type)
13:30:46 <Cale> There are also exceptions in IO. You can make your error type into an instance of Exception just by writing   instance Exception SomeErrorType where   -- and just leaving the instance blank, the default methods will do.
13:31:12 <Cale> That'll let you throwIO exceptions of that type and catch them later, if that would be more convenient.
13:31:45 <sphinxo> Cale: I think i'll just stick with Either, thanks
13:37:56 <dmj`> can typeclass constraints be aliased?
13:40:16 <thoughtpolice> dmj`: Yes, using ConstraintKinds (or UndecidableInstances, but ConstraintKinds are nicer)
13:41:38 <dmj`> thoughtpolice: aah, very cool, thanks ! 
13:45:37 * hackagebot generic-xmlpickler 0.1.0.5 - Generic generation of HXT XmlPickler instances using GHC Generics.  https://hackage.haskell.org/package/generic-xmlpickler-0.1.0.5 (ErikHesselink)
13:49:31 <purelazy> hi
13:50:26 <sphinxo> Welcome purelazy 
13:51:10 <purelazy> I have a problem with Arrows sphinxo
13:51:32 <sphinxo> I may be able to help, what is your problem?
13:51:56 <lpaste> purelazy pasted “Arrows” at http://lpaste.net/153685
13:52:17 <purelazy> http://lpaste.net/153685
13:52:40 <kadoban> purelazy: (>>>) is from Category I believe, you might have to import that separately.
13:52:44 <sphinxo> hmm, that is odd
13:52:54 <sphinxo> I can't replicate it locally
13:53:08 <sphinxo> ( import the same and then :t (>>>) )
13:53:08 <kadoban> purelazy: Oh yeah you just need to give an instance for Category as well as Arrow.
13:53:41 <byorgey> purelazy: yes, (>>>) is a method of the Category class, not of the Arrow class
13:54:35 <purelazy> I am trying to follow http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
13:54:36 <seishun> so there's Data.Map.Strict and Data.Map.Lazy, but what happens when you import Data.Map?
13:54:40 <byorgey> actually, it's not a method of any class.
13:54:56 <kadoban> byorgey: Yeah I just noticed that, kind of funny.
13:55:13 <byorgey> purelazy: that is rather old, there are some things that have changed a bit since it was written
13:55:21 <kadoban> purelazy: Yeah, Arrow got split into Category and Arrow since then.
13:55:34 <byorgey> purelazy: I still think it is a great document and well worth working through
13:55:40 <byorgey> you just have to do a bit of translation.
13:55:47 <purelazy> well I'm stuck at the moment
13:56:23 <purelazy> on kadoban's "
13:56:34 <purelazy> ... you just need to give an instance for Category
13:56:45 <purelazy> un "
13:56:50 <byorgey> purelazy: that was not an accurate statement, actually
13:57:37 <byorgey> purelazy: here's what you need to do: (1) import Control.Category  (2) define an instance of Category which defines  id  and  (.)  (see the documentation: http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Category.html)
13:58:31 <byorgey> (3) for your Arrow instance, you can start with just implementing arr, but eventually you'll want to implement 'first' as well
14:00:38 * hackagebot witherable 0.1.3.3 - Generalization of filter and catMaybes  https://hackage.haskell.org/package/witherable-0.1.3.3 (FumiakiKinoshita)
14:01:46 <purelazy> byorgey: so instance Category SF
14:02:48 <purelazy> byorgey: or instance Category Arrow
14:03:06 <byorgey> purelazy: instance Category SF
14:03:09 <kadoban> purelazy: The former
14:03:35 <byorgey> purelazy: basically, Arrow got split into two classes: Category + Arrow
14:03:44 <byorgey> so now instead of just giving an Arrow instance you have to give both
14:05:58 <purelazy> byorgey: kadoban: Thanks. I'll see how far I can get.
14:06:57 <kadoban> purelazy: If you get confused, the docs are pretty helpful on these. It'll tell you what relationship these typeclasses have and what methods each one requires/allows: http://haddock.stackage.org/lts-5.5/base-4.8.2.0/Control-Arrow.html#t:Arrow and the one byorgey linked above for Category.
14:09:01 <lpaste> tippenein pasted “capture remaining args from getArgs” at http://lpaste.net/153688
14:09:25 <tippeneinn> how would you pattern match out the remaining args from that example?
14:09:52 <johnw> byorgey: today I was in a meeting about something else, and I said, "What we know about X is only given by the set of operations to be performed on it, without knowing the internals of X", and a part of my brain screamed: CATEGORY!!!!
14:10:38 * hackagebot objective 1.1 - Composable objects  https://hackage.haskell.org/package/objective-1.1 (FumiakiKinoshita)
14:10:47 <kadoban> tippeneinn: args <- […]  doesn't really make sense, that's the wrong type for the do block you're in (which is :: IO a)
14:11:24 <kadoban> tippeneinn: But you'd do something like ("search" : rest) -> stuff with rest
14:11:37 <geekosaur> tippenein, remember that [...] is syntactic sugar, a list is actually (x:xs)
14:12:08 <geekosaur> (where xs may be [] or (y:ys), etc.)
14:14:14 <tippeneinn> kadoban: sure, that was a poorly put together example.
14:14:32 <tippeneinn> thanks tho, ("search" : rest) does it. 
14:15:10 <kadoban> tippeneinn: For serious usage you'll probably be better off using a library, by the way. Command line options quickly get really complicated to handle explicitly. optparse-applicative is nice, IMO.
14:16:39 <tippeneinn> I've already reached that point I think. It's a needed mistake for me apparently, since I was abusing list syntactic sugar
14:31:54 <purelazy> kadoban: byorgey: I found the solution here -> https://mail.haskell.org/pipermail/haskell-cafe/2011-October/096389.html
14:32:11 <purelazy> kadoban: byorgey: Thanks again
14:35:26 <jle`> id = join seq
14:35:49 <duue> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
14:35:49 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
14:36:28 <duue> @undo do generator <- get;let (value, newGenerator) = randomR (1,6) generator; put newGenerator;return value
14:36:28 <lambdabot> <unknown>.hs: 1: 90:Parse error: ;
14:36:44 <byorgey> johnw: =D
14:37:09 <jle`> duue: did you know that you can also use lambdabot via pm? :)
14:37:10 <byorgey> johnw: also, final coalgebras =)
14:37:17 <mauke> @undo do generator <- get;let { (value, newGenerator) = randomR (1,6) generator }; put newGenerator;return value
14:37:18 <lambdabot> get >>= \ generator -> let { (value, newGenerator) = randomR (1, 6) generator} in put newGenerator >> return value
14:41:16 <seishun> so there's Data.Map.Strict and Data.Map.Lazy, but what happens when you import Data.Map?
14:41:22 <augur> hmm
14:41:30 <augur> sooo whats going on with this?
14:41:32 <augur> > ‘bisequenceA’ is not a (visible) method of class ‘Bitraversable’
14:41:33 <lambdabot>  <hint>:1:1: lexical error at character '\8216'
14:42:04 <augur> bisequenceA is one of the two parts possible for a minimal definition of an instance of Bitraversable, so like.. what
14:43:33 <Cale> augur: do you have an explicit import list for that module?
14:43:44 <augur> no
14:43:59 <Cale> hmm
14:44:11 <Cale> (I was thinking perhaps the class was imported, but not its methods)
14:44:21 <kadoban> augur: It looks like bitraverse is the only actual method of the class
14:45:00 <geekosaur> huh?
14:45:09 <geekosaur> I see it back through several versions
14:45:21 <davean> seishun: first, read the docs at http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map.html but also, just look at http://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Map.html
14:45:27 <augur> ugh this has changed since the version i had been using before, i guess
14:45:34 <geekosaur> (I decided to see if maybe an old version of bifunctors for some reason, but bisequenceA seens to go back a way)
14:46:05 <kadoban> http://haddock.stackage.org/lts-5.5/bifunctors-5.2/Data-Bitraversable.html it only shows that, and the source code appears to agree. bisequenceA exists, it's just not a method of the class.
14:46:09 <geekosaur> oh, went away
14:46:10 <augur> this is apparently new to 5.1
14:46:16 <geekosaur> no docs for the latest one on hackage :/
14:46:39 <geekosaur> but 5.2 shows indeed it's the only method now
14:46:46 <seishun> davean: so is this just Lazy with some extra deprecated functions?
14:46:51 <davean> seishun: Do you see the "module Data.Map.Lazy" in the documentation?
14:46:58 <augur> also there's no requirement for the class???
14:46:59 <davean> seishun: Well, basicly.
14:47:07 <augur> edwardk: whats going on with bitraversable
14:47:18 <seishun> I saw it, but I wasn't sure what it meant in this context
14:47:44 <seishun> apparently it means this module is imported?
14:47:48 <davean> seishun: it means that module is re-exported
14:48:00 <seishun> I see, thanks
14:48:02 <davean> haddock doesn't show whats imported, jsut whats exported
14:48:43 <seishun> but Data.Map itself isn't deprecated?
14:48:50 <davean> No
14:50:48 <kadoban> augur: It appears to have a default implementation for bitraverse, though I don't really understand under what circumstances it's supposed to work (if any or all or something in between)
14:51:13 <augur> kadoban: it does indeed, tho it also seems circular and guaranteed to loop o.O
14:51:36 <kadoban> augur: That was my initial reading as well, but I suspected I was missing something.
14:53:52 <kadoban> augur: I figure either we are missing something, or someone just forgot the remove the default implementation for that.
15:09:08 <fnord__> hi, I have 2D RGB image data stored in a ByteString. Is there a convenient and fast way to manipulate data at a position (x,y) as a color of type `V3 Char`?
15:10:50 <fnord__> Ideally, I'd like the image manipulation to take place on the same memory region as the ByteString I have, so that there is no reallocation before or during image manipulation.
15:14:48 <Zemyla> Can GHC derive KnownNat (n + 1) from KnownNat n?
15:24:33 <fresheyeball> so recently spoke to some Scala folks who use Scala streams for a high scale realtime data application 
15:24:47 <fresheyeball> is there a Haskell alternative?
15:24:59 <Axman6> what are they?
15:25:02 <fresheyeball> something that does streams in a fashion appropriate for high scale?
15:25:08 <fresheyeball> Lifetime fitness if you can believe it
15:25:23 <fresheyeball> the engineers over there come from realtime finance world
15:25:41 <M-radix> there is a lot of realtime finance being done in Haskell
15:25:47 <Axman6> there's plenty of haskell libraries for streaming data, but you haven't really specified what makes scala streams interesting
15:25:51 <duue> @undo do let x = 1; putStrLn x
15:25:52 <lambdabot> <unknown>.hs: 1: 25:Parse error: EOF
15:25:52 <fresheyeball> I am scared to pick a Haskell streams lib without some advice 
15:26:03 <dmj`> M-radix: like trading?
15:26:05 <duue> @undo do let x = 1; putStrLn x; return
15:26:05 <lambdabot> <unknown>.hs: 1: 25:Parse error: ;
15:26:10 <M-radix> pipes and conduit both have strong ecosystems, but those are super general and I'm not sure what you're looking for
15:26:11 <M-radix> dmj` yes
15:26:18 <geekosaur> duue, let needs braces when done on one line
15:26:22 <fresheyeball> I worry that lazy will bite me in the streams, they need to be efficient from a memory perpective
15:26:34 <geekosaur> @undo do let {x = 1}; putStrLn x
15:26:35 <lambdabot> let { x = 1} in putStrLn x
15:26:37 <fresheyeball> yes like trading 
15:26:48 <Axman6> The point of streaming data is that they are not laxy...
15:26:48 <dmj`> M-radix: ghc haskell, or just haskell
15:26:49 <duue> yikes. thanks
15:26:56 <geekosaur> because when it sees the ; it applies it to the let, not to the do
15:26:57 <M-radix> fresheyeball: both pipes and conduit are all about efficient, strict stream processing
15:26:59 <Axman6> they specifically exist to avoid using lazy IO
15:27:04 <M-radix> dmj`: GHC haskell, but maybe other implementations too
15:27:10 <geekosaur> then it sees putStrLn x instead of another let binding
15:27:15 <dmj`> M-radix: other implementations yes, like Mu
15:27:24 <fresheyeball> I use GHC so GHC is preferred over hugs or whatever 
15:27:30 <dmj`> M-radix: Maybe GHC, unsure
15:27:40 <fresheyeball> or so any reason to use pipes or conduits?
15:27:50 <M-radix> dmj`: are you asking me honest questions or quizzing me?
15:28:06 <fresheyeball> I am asking honestly
15:28:22 <fresheyeball> I need to do an evaluation, and I thought IRC would be a good place to narrow the search
15:28:28 <Axman6> fresheyeball: what do you need, we can';t give you advice without knowing what you need to do
15:28:35 <fresheyeball> ok
15:28:45 <duue> @undo do generator <- get; let {(value, newGenerator) = randomR (1,6) generator}; put newGenerator;return value
15:28:45 <lambdabot> get >>= \ generator -> let { (value, newGenerator) = randomR (1, 6) generator} in put newGenerator >> return value
15:29:08 <fresheyeball> so basically I am looking to introduce Haskell to their existing system
15:29:36 <fresheyeball> which is Scala streams as micro-services built with Docker
15:29:39 <dmj`> M-radix: I am giving you answers, not questions
15:30:01 <M-radix> dmj`: I think I misinterpreted what you meant when you said "GHC haskell, or haskell" then
15:30:12 <fresheyeball> Actually, so long as both pipes and conduits are non-strict, and its only 2 options
15:30:15 <M-radix> sorry :)
15:30:17 <fresheyeball> I think that answers my question 
15:30:22 <fresheyeball> I can evaluate 2 things
15:30:28 <Axman6> there's more than two streaming libraries
15:30:31 <Axman6> :P
15:30:31 <fresheyeball> I just saw so many out there
15:30:37 <fresheyeball> yes very very many
15:30:40 <dmj`> M-radix: Mu Haskell is used at a bank, for trading 
15:30:50 <Axman6> but you haven't given a single quality you need from your library yet, so we can't help you at all...
15:31:26 <Axman6> Streaming looks quite interesting, good benchmarks too: https://hackage.haskell.org/package/streaming-0.1.4.0
15:31:35 <fresheyeball> The only quality I'm looking for right now is strictness and efficiency so I have a place to start 
15:31:38 <fresheyeball> I'm shopping
15:32:45 <fresheyeball> holy cow those benchmarks are amazing
15:33:23 <fresheyeball> what is Mu Haskell?
15:34:19 <dmj`> fresheyeball: it's a strict dialect of haskell
15:34:26 <fresheyeball> I wish there was a handy comparison chart of features and characteristics for streaming libraries 
15:34:29 <fresheyeball> Interesting 
15:34:30 <fresheyeball> ok
15:34:35 <fresheyeball> I need to learn about that too
15:34:47 <dmj`> http://www.haskellcast.com/episode/002-don-stewart-on-real-world-haskell/
15:34:55 <dmj`> don stewart talks about it a bit here
15:48:58 <lethjakman> So I think I almost have this type signature right...but the MonadIO constraint seems to expect a * -> *, but looking at the docs it looks like it should simply be a *, what am I missing?
15:49:09 <lethjakman> https://gist.github.com/lethjakman/7496ca33d2be7d03bb85
15:49:14 <lethjakman> http://haddock.stackage.org/lts-5.5/yesod-core-1.4.19/Yesod-Core.html#t:MonadIO
15:52:19 <geekosaur> * would be the type of a value, so a type with a MonadIO instance would be like a value (e.g. Int). * -> * is what I would expect (e.g. IO a)
15:53:26 <geekosaur> and what you are missing is that Monad is * -> * and the parameter type is not used by the class
15:53:58 <lethjakman> Hmmm. 
15:54:27 <enthropy> it might work if you just comment out that type signature
15:54:29 <lethjakman> geekosaur: By the class you mean the MonadIO in the docs I sent, right?
15:54:37 <lethjakman> enthropy: it can't deduce MonadIO
15:54:38 <geekosaur> oh, and it's not necessary for the class to be defined on something that is fully saturated
15:54:48 <lethjakman> geekosaur: Sorry, what do you mean?
15:54:55 <lethjakman> "fully saturated"?
15:54:59 <geekosaur> you can say instance Foo IO where
15:55:09 <geekosaur> but you cant use IO by itself normally
15:55:11 <geekosaur> it's IO a
15:55:41 <geekosaur> but for the purposes of a class or instance definition, the instance can be on just IO as long as actual uses end up being IO a
15:55:45 <geekosaur> (as an example)
15:56:15 <lethjakman> Oh, ok. 
15:56:17 <lethjakman> Makes sense.
15:56:19 <lethjakman> Hmmm...
15:56:32 <lethjakman> So, I'm using MonadIO m wrong. 
15:56:36 <lethjakman> m should be wrapping around something. 
15:57:08 <lethjakman> Right?
15:58:19 <geekosaur> `MonadIO master` is fine as is, provided master has kind * -> *
15:58:38 <lethjakman> geekosaur: So...I added that constraint because of the error I just added to that gist
15:58:52 <lethjakman> "Could not deduce (MonadIO m0) arising from a use of ‘loginForm’"
15:58:58 <geekosaur> but you have a value of type Route master, and unless Route supplies the additional parameter then that is a kind mismatch
15:59:23 <lethjakman> Hrm. That makes sense. 
15:59:34 <geekosaur> actually like 6 of that addition makes me suspicious
15:59:39 <geekosaur> MonadIO m1, ...
15:59:46 <lethjakman> I don't understand why it needs to deduce it fully. 
15:59:49 <lethjakman> Or...more why it can't. 
15:59:59 <geekosaur> something that you think should be matching up is not matching up, so ghc thinks it's a different instance
16:00:12 <geekosaur> er, line 6 of that addition
16:00:53 <lethjakman> geekosaur: What do you mean by suspicious?
16:01:08 <geekosaur> because it's rolling a new type variable m1 out of nowhere
16:01:13 <lethjakman> I appreciate the help btw. Thank you. 
16:01:31 <lethjakman> Yeah...I'm confused by that. 
16:02:02 <geekosaur> which makes me think that it "should" be using m there, but it instead thinks that that is a separate thing instead of unifying it. but I don't know yesod so nothing pops out as obvious to me
16:02:30 <bash0r> What about type holes? 
16:02:48 <bash0r> They might help finding the issue causing your problem 
16:03:17 <lethjakman> bash0r: I'll look into them
16:03:20 <lethjakman> geekosaur: Hmmm. Ok. 
16:04:28 <bash0r> lethjakman: I hope this helps a bit 
16:06:14 * hackagebot vulkan 1.3.1.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.3.1.0 (jophish)
16:06:33 <lethjakman> bash0r: It looks cool so far :)
16:07:21 <lethjakman> bash0r: Is that useful if I'm not actually defining the instance?
16:08:18 <bash0r> lethjakman: what exactly do you mean with this? I'm currently on my phone and just reading your code 
16:09:59 <lethjakman> bash0r: I'm not defining an instance of MonadIO, most of the code is already added for me, I'm just trying to use a runFormPost in a funtion. 
16:11:16 <bash0r> Does your code work without the MonadIO actions? 
16:12:22 <bash0r> lethjakman: Do you use liftIO provided by MonadIO? This would be the next I'd try out. 
16:14:51 <bash0r> When using Monad Transformers, like these provided by Yesod, you need to use the provided functions. liftIO from MonadIO brings you explicit lifting of IO actions. I don't actually see the IO in the code but no liftIO either which looks suspicious. 
16:16:14 * hackagebot vulkan 1.3.2.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.3.2.0 (jophish)
16:23:12 <lethjakman> bash0r: Ok. 
16:23:17 <lethjakman> Yeah, I tried a few different lifts. 
16:23:33 <lethjakman> They all complained about the MonadIO issue and sometimes a RenderForm one as well. 
16:24:11 <bash0r> lethjakman: okay, sorry that I can't help any further 
16:24:20 <lethjakman> That's ok. Thank you!
16:24:34 <lethjakman> Lol, I'm just trying to figure this out. I haven't been able to get it for a while. 
16:24:55 <lethjakman> So, thank you for all the help. 
17:34:26 <jakeehrlich> Is there a way to to use GHC as a libary, get llvm code out, and then JIT compile it right then and there?
17:40:07 <dmj`> jakeehrli: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/LlvmCodeGen.html
18:00:25 <rui> It's still hard to use haskell for numeric programming and scripting, data science, and those things, right?
18:01:37 <dmj`> rui: http://www.amazon.com/Haskell-Analysis-Cookbook-Nishant-Shukla/dp/1783286334
18:03:24 <kakos> Does anyone know how to use the C2HS get hook on an array inside of a struct?
18:04:06 <rui> dmj`: Thanks. I wonder...
18:10:35 <dmj`> rui: do it
18:12:14 <duue> Can  anybody  tell me why this does not work? (\ x y -> x + y ) <$> (Just 1) `ap` ( Just 2)
18:12:55 <duue> @undo (\ x y -> x + y ) <$> (Just 1) `ap` ( Just 2)
18:12:55 <lambdabot> (\ x y -> x + y) <$> (Just 1) `ap` (Just 2)
18:13:36 <dmj`> : liftA2 (\x y -> x + y) (Just 1) (Just 2)
18:13:41 <dmj`> > liftA2 (\x y -> x + y) (Just 1) (Just 2)
18:13:43 <lambdabot>  Just 3
18:14:45 <geekosaur> should probably be <*> instead of `ap`
18:14:50 <duue> I know (\ x y -> x + y ) `fmap` (Just 1) `ap` ( Just 2) and  fmap (\ x y -> x + y )  (Just 1) `ap` ( Just 2) and  (<$>) (\ x y -> x + y )  (Just 1) `ap` ( Just 2)
18:15:16 <geekosaur> oh. I think precedence issues
18:15:18 <duue> I thought fmap and <$> are the same thing
18:16:24 <dmj`> :t (+) <$> Just 1 <*> Just 2
18:16:25 <geekosaur> right, `ap` has no defined precedence, so is not 100% identical to <*> which is infixl 4
18:16:25 <lambdabot> Num b => Maybe b
18:16:30 <dmj`> :t (+) <$> Just 1 `ap` Just 2
18:16:31 <lambdabot> (Num a, Num a1, Num (a1 -> a)) => Maybe (a -> a)
18:16:33 <geekosaur> you need parentheses
18:16:42 <dmj`> :t (+) <$> do Just 1 `ap` Just 2
18:16:43 <lambdabot> (Num a, Num a1, Num (a1 -> a)) => Maybe (a -> a)
18:16:56 <duue> ah ha. thanks much appreciated
18:20:22 <geekosaur> \rigfht, so `ap` is infixl 9 and ends up grouping oddly compared to <*>
18:21:43 <duue> ap needs level up  :)
18:21:50 <geekosaur> you wanted ((+) <$> (Just 1)) `ap` (Just 2) but you got (+) <$> ((Just 1) `ap` (Just 2))
18:23:22 <geekosaur> unfortunately I bet changing the fixity of `ap` would break a lot of existing programs...
18:23:30 <duue> so the problem is ap has higher precedence. ok
18:23:40 <geekosaur> and adjusting other fixities to match could well just create an avalanche
18:24:04 <rcyr> I'm a super noob.. but since 7.10, why would anyone use `ap`?
18:24:25 <duue> for monad 
18:24:30 <duue> no?
18:24:44 <rcyr> Because of AMP, aren't all monads, applicative?
18:24:45 <geekosaur> well, if you have a monad where <*> and `ap` do different things, you have arguably found a bug
18:24:52 <duue> yeb
18:24:57 <geekosaur> so <*> should be valid for the monad case as well
18:26:09 <geekosaur> modulo the fixity thing, which I think we're stuck with (aside from something of a push to get people to use the Applicative stuff instead and retire ap)
18:26:28 * hackagebot STL 0.3.0.4 - STL 3D geometry format parsing and pretty-printing  https://hackage.haskell.org/package/STL-0.3.0.4 (bergey)
19:21:29 * hackagebot phoityne 0.0.4.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.4.0 (phoityne_hs)
19:25:44 <John[Lisbeth]> does cygwin have GHCI?
19:36:30 * hackagebot GPipe-GLFW 1.2.2 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.2.2 (plredmond)
20:00:22 <dogcat> hey, any one play with the Ethereum API in haskell?
20:00:36 <dogcat> could be a great project using Servant to show off microservice design in Haskell
20:03:34 <dogcat> anyone hack around with: https://hackage.haskell.org/package/ethereum-client-haskell
20:08:30 <dmj`> dogcat: sounds like an opportunity :) 
20:18:41 <adas> is it possible to add typeclass constraints during data definitions?
20:19:26 <adas> and is it idiomatic to add such typeclass constraints during data definitions
20:20:45 <c_wraith> 1) Sort of-not really-sort of-but it doesn't do what you think 2) definitely not
20:21:14 <adas> c_wraith: thanks. removed
20:42:04 <geppettodivacin> c_wraith: I didn't know you could even do it. What does it do, if not what would be expected?
20:47:13 <c_wraith> geppettodivacin: Well, It used to be part of the standard that you could put constraints on constructors.  But it ended up being basically useless, since the constraint wasn't stored in the data structure.
20:47:32 <c_wraith> geppettodivacin: That is the missing feature people often assumed it offered, and it.. didn't. :)
20:56:17 <geppettodivacin> Interesting. It seems like something that would be easy to add to type constructors.
20:57:05 <nshepperd> the new GADTs can do it
20:58:26 <Axman6> I thought the problem was that the constraint basically infected all code that used the type, whether they needed to use the functions from the class or not
20:59:50 <Axman6> so if you had data Complex a = Floating a => a :+ a, then things like Show would need a Fractional superclass even though the implementation of the show functions never used any of the Fractional functions
21:00:46 <shachaf> Are you thinking of "data Floating a => Complex a = a :+ a"?
21:01:08 <shachaf> The thing you wrote is a feature that's still in GHC and used often.
21:01:12 <Axman6> yes, probably
21:12:50 <adas> is writing libraries generally more harder than writing a binary?
21:12:54 <adas> in haskell that is
21:13:07 <adas> seems like I simply can't satisfy the type system
21:13:26 <kadoban> adas: Not really, though you probably have to spend a bit more time with .cabal files to do it right I guess.
21:22:54 <lpaste> adas pasted “How to write the library” at http://lpaste.net/153781
21:23:14 <roboguy`> adas: type errors should be the same either way
21:23:33 <lpaste> adas revised “How to write the library”: “How to write the library” at http://lpaste.net/153781
21:24:06 <adas> ^^^^^
21:24:15 <adas> I understand what the error is..but Im not sure how to fix it
21:24:32 <adas> basically if I add an annotation on that line, problem solved
21:25:30 <adas> but I can't add the annotation because I don't know the name of the type that the user of the library will use
21:27:31 <maybefbi> how do i convert String -> Data.Bson.ObjectId
21:28:03 <maybefbi> its ok got it
21:28:08 <maybefbi> it implements Read
21:29:58 <roboguy`> adas: you can add a phantom type to Row
21:30:20 <roboguy`> adas: so, data Row a = <your original definition of Row>
21:30:42 <roboguy`> and then add a constraint to the instance: instance AgentSpec a => FromNamedRecord (Row a) where ...
21:31:02 <adas> roboguy`: ill try that and report back
21:31:24 <roboguy`> You'll probably also need to add an explicit type signature inside the instance (and turn on scoped type variables in order to do that)
21:31:55 <Ralith> jophish: why DuplicateRecordFields rather than typeclasses?
21:38:50 <kadoban> View patterns are really badass … never had occasion to use them before.
21:39:44 <c_wraith> Best when hidden by pattern synonyms.
21:41:36 <adas> roboguy`: scoped type vars or instance sigs?
21:41:43 <kadoban> c_wraith: I'll have to look up how those work.
21:42:13 <shachaf> c_wraith: I can handle the regular view pattern syntax. Stop being so patternalistic.
21:42:28 <roboguy`> adas: scoped type vars
21:43:18 <roboguy`> That way you can use the `a` type variable in the body of parseNamedRecord
21:45:23 <adas> so the type woudl be "parseNamedRecord :: NamedRecord -> Parser (Row a)" and then I add the "a" in the body?
21:46:11 <roboguy`> adas: you shouldn't need an explicit type signature for parseNamedRecord itself
21:46:25 <roboguy`> You can just add an explicit signature to an expression the body
21:46:28 <roboguy`> *in the body
21:48:11 <adas>   parseNamedRecord r = Row <$> (r .: "Date") <*> foldM helper HM.empty (concatMap agentEvents (allAgents :: [a]))
21:48:16 <adas> thats what I did
21:48:18 <roboguy`> yep
21:48:25 <roboguy`> that should work without the instance sig
21:48:39 <adas> and ofcourse I added {-# scoped type vars #-} in the header
21:48:41 <roboguy`> (probably with it too, but it shouldn't be necessary)
21:48:55 <adas> but how come that works?
21:48:59 <adas> cos it type checked
21:49:08 <kadoban> c_wraith: Yeah, I don't really understand them, I'll look at pattern synonyms some other time.
21:49:32 <roboguy`> adas: Because now for any "Row a", for any type a, it will know which instance to choose
21:49:54 <roboguy`> For example, if you have a value of type Row Agent, it will know to choose the "Agent" instance of AgentSpec
21:50:06 <adas> is using phantom types idiomatic in normal haskell code?
21:50:10 <adas> ah that makes sense
21:50:44 <roboguy`> Yeah, I would say it's generally idiomatic. This is maybe a bit of an unusual application of phantom types, but yeah
21:51:14 <roboguy`> You need to be careful that you don't accidentally change a "Row a" into a "Row b" where a is not the same as b
21:51:31 <roboguy`> But with a little bit of information hiding, that should be ok
21:51:34 <Cale> adas: A nice example from the code I was working on today: we use a GADT with a phantom type parameter to represent the requests that our web application frontend makes to the backend, where the type parameter gives the type of the eventual response to the request.
21:51:52 <Cale> (so we know what type to JSON decode)
21:53:55 <adas> roboguy`: Cale so basically, giving more information to the compiler via the type system so there is no ambiguity
21:54:20 <adas> that sounds weird but awesome and interesting
21:54:26 <roboguy`> pretty much, yeah
21:54:36 <Cale> Yeah, in this case, the request doesn't contain a value of that type, but the response that comes back from the server, we're going to want to parse it as a value of that type.
21:55:23 <adas> if using a phantom type parameter is not idiomatic that what other method could I employ in this situation?
21:56:12 <Cale> (as it happens, both the client and the server are written in Haskell, and use the same type definition, so the server, upon determining what the request is, also finds out which sort of response it needs to produce)
21:56:36 <roboguy`> Well, I would say it is pretty idiomatic. I can't think of another solution off the top of my head that doesn't involve a phantom type
21:57:01 <Cale> What was the problem again?
21:57:27 <roboguy`> Cale: http://lpaste.net/153781
21:57:45 <Cale> If we're using a phantom type in order to pick an instance of a type class, it's almost always another viable approach to instead pass a record of what would just be the implementation of that instance.
21:59:06 <Cale> Like, in my example with the type determining which JSON decoding to use, we could always just physically put the function to decode the JSON which comes back from the server into the data structure used to represent the request.
22:00:15 <Cale> But that just makes the type not phantom :)
22:00:40 <Cale> (I'd still need the type parameter)
22:01:06 <roboguy`> that's a good point. I'm not sure if incorporating the AgentSpec methods into Row would look nice in this case though
22:01:55 <Cale> In this case, it might be weird
22:02:21 <Cale> Yeah, the other option in your case is just to pick Agent.
22:02:45 <Cale> Is there a good reason for the AgentSpec type class?
22:02:53 <Cale> What do the other instances look like?
22:03:01 <bollu> I don't see haskell on the gsoc 2016 list
22:03:02 <bollu> did I miss it?
22:03:28 <johnw> bollu: we aren't participating this year
22:03:35 <bollu> johnw: :( aww
22:03:40 <johnw> Google has decided to choose other organizations; an announcement is forthcoming
22:04:03 <bollu> ouch, that's.. disappointing
22:04:43 <johnw> but it gives other organizations a chance
22:04:45 <Cale> roboguy`: I guess in your case, it's part of the interface of how you're using the library
22:04:47 <johnw> it's a limited pool after all
22:05:26 <roboguy`> Cale: oh, this is adas's code/question. But yeah, it is constrained by that
22:05:42 <bollu> johnw: yes, I suppose so
22:05:56 <Cale> Ah, right, sorry
22:07:23 <Cale> adas: Yeah, so you could turn AgentSpec from a class into a data type, and then include such a record in your Row type, from which you could unpack the agentEvents/allAgents to use in the parseNamedRecord implementation.
22:07:37 <Cale> adas: But that might be a bit weird here, I don't know.
22:07:58 <Cale> It's always something to consider though.
22:17:54 <adas> using AgentSpec as a type and making it a record for row is a bit weird and perhaps non-idiomatic...is it not? perhaps even more so than just using a phantom type parameter?
22:18:22 <adas> my stupid obsession with idiomatism 
22:18:40 <adas> i don't think such a word exists. "idiomatism" i mean
22:19:44 <adas> Cale: the reason for the AgentSpec type class was because I was trying to write it as a library..
22:20:35 <adas> Cale: so users of the library could make their own type but as long as they provided an instance for AgentSpec I want to be able use the mthods in AgentSpec to do the bulk of the work
22:21:31 <adas> I mean, apart from a few other type theatrics used in other libraries I learned from, it seems like using typeclasses is perhaps the right way
22:30:55 <kadoban> GHC's ability to figure out if patterns are exhaustive is really quite amazing … was dreading it not being able to figure this mess out between ViewPatterns and pattern guards. Just works of course, yay.
22:39:25 <shanemikel> good evening y'all
22:39:58 <apostolis> how can I assert on a specific condition and report back the local variables? Is there an easy way?
22:40:52 <kadoban> apostolis: Sounds like you want something from Debug.Trace, though I'm not sure.
22:40:59 <apostolis> In c, i used to put printfs, but how to do it in haskell.
22:41:20 <kadoban> apostolis: Sounding more like Debug.Trace from that.
22:42:18 <apostolis> let me check some examples on debug.trace
22:42:57 <apostolis> Oh, nice?
22:43:02 <apostolis> !
22:43:33 <kadoban> Yeah, it's pretty badass
22:43:51 <apostolis> thanks, that is what I need.
22:44:19 <apostolis> Bye
22:46:09 <jakeehrlich> Does anyone know of a way to JIT compile haskell in an application?
22:46:37 <johnw> jakeehrlich: why does it need to be full Haskell?
22:47:22 <maybefbi> if imperative programs were written inside a monad transformer stack what would the type signature be? imperative programs allow for IO, State on every line methinks
22:48:31 <jakeehrlich> johnw: Well I was more curious. I was specifically intrested it making a play version of distributed haskell
22:50:08 <dmj`> maybefbi: foo :: ( MonadState MyState m, MonadIO m ) => m a
22:51:51 <maybefbi> dmj`, ok
22:53:21 <dmj`> maybefbi: not entirely sure what is meant by 'imperative', do syntax does give you that 'imperative' feel, but that's true of any monad, not just transformers
22:54:06 <maybefbi> yes i was talking about that imperative feel
22:58:46 <dmj`> > flip execState [1] $ do _head += 1; _head += 1
22:58:48 <lambdabot>  [3]
22:58:50 <dmj`> maybefbi: ^
23:00:18 <maybefbi> how?
23:00:28 <maybefbi> _head ?
23:00:30 <dmj`> maybefbi: lens magic
23:00:45 <dmj`> looks super imperative
23:01:04 <maybefbi> i used to use them for a while. then i realized i dint need it
23:01:20 <maybefbi> i bet that _head is some template haskell spell
23:03:41 <lyxia> nope
23:05:26 <lyxia> well, we typically use TH to define lenses with makeLenses but you can also do it by hand. And once defined no TH is necessary.
23:11:25 <jle`> nope, no TH at all, it's just a normal function
23:11:31 <jle`> we can define it from scratch here if you want, too
23:11:52 <jle`> it's also likely that _head was defined from scratch and not using TH
23:13:26 <jle`> @let _head' = prism (\x -> [x]) (\xs -> case xs of [] -> Left xs; y:_ -> Right y)
23:13:27 <lambdabot>  Defined.
23:13:30 <jle`> ^ maybefbi 
23:13:56 <jle`> basically you tell prism how to "construct" a list if you're given just a Head, and also how to "get" the head of a list, failing with Left if the list is empty
23:14:17 <jle`> > flip execState [1] $ do _head' += 1; _head' += 1
23:14:18 <lambdabot>  [3]
23:14:20 <jle`> ta dah
23:15:24 * dmj` applauds loudly
23:17:50 <prognoob> I have a free ebook on amazon, which haskell book should I go for ?
23:18:07 <prognoob> I was thinking of "Haskell: The Craft of Functional Programming "
23:18:22 <maybefbi> jle`, mind blown
23:18:35 <prognoob> Thinking Functionally with Haskell by Richard Bird
23:18:50 <maybefbi> made a mess on the office floor
23:19:41 <wolfcore> prognoob: is purely functional data structures available?
23:20:08 <dmj`> maybefbi: yea, you don't have to use TH
23:20:55 <dmj`> @def newtype QSF = QSF { _qsf :: Int } deriving Show
23:20:57 <lambdabot>  Defined.
23:21:06 <maybefbi> the last time i used lenses i ran into a memory leak i couldnt fix
23:21:24 <dmj`> @def qsf = lens _qsf (\(QSF x) b -> QSF y)
23:21:26 <lambdabot>  .L.hs:160:37:
23:21:27 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
23:21:27 <lambdabot>      In the first argument of ‘QSF’, namely ‘y’
23:21:27 <maybefbi> because i had used up all my smarts to d lens
23:21:37 <dmj`> @def qsf = lens _qsf (\(QSF x) b -> (QSF y))
23:21:38 <lambdabot>  .L.hs:160:38:
23:21:38 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
23:21:38 <lambdabot>      In the first argument of ‘QSF’, namely ‘y’
23:23:15 <prognoob> wolfcore yes it is
23:23:40 <dmj`> > flip execState (QSF 1) $ do qsf += 1; qsf += 1
23:23:42 <wolfcore> prognoob: that's a great book, albeit it's in SML, but the ideas are the same (and there's (haskell translations in the back)
23:23:42 <lambdabot>  QSF {_qsf = 3}
23:24:21 <wolfcore> prognoob: Pearls of Functional Algoriths Design by Richard Bird
23:24:32 <wolfcore> prognoob: (there's a PDF of it floating around online too)
23:24:40 <prognoob> but that costs £20 where the craft of functional programming is £44 so it would be cheaper to get that later
23:25:08 <wolfcore> prognoob: oh I see
23:27:53 <shanemikel> does OCaml break anything SML?
23:27:58 <maybefbi> dmj`, what does qsf stand for
23:28:00 <shanemikel> or just add features?
23:28:29 <maybefbi> dmj`, quantum superposition function
23:29:02 <dmj`> maybefbi: that is correct
23:29:26 <dmj`> :)
23:29:53 <shanemikel> wolfcore: this? https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
23:30:05 <maybefbi> ok i will try to pick up lenses for a second time. i did use it after watching SPJ explain it
23:30:27 <wolfcore> shanemikel: OCaml is different from SML but if you understand one you can understand the other
23:30:49 <wolfcore> shanemikel: that's the thesis, but later Okasaki published a book
23:31:00 <wolfcore> shanemikel: which is like an extended, improved version of that thesis
23:31:51 <wolfcore> shanemikel: http://amzn.com/0521663504
23:47:38 <parsecChar> I'm looking at the Haskell LevelDB bindings. Is there a function "Range a b" which returns a list of Keys of all k where a <= k <= b ?
23:48:34 <parsecChar> imalsogreg: thanks for the info on the "note" function; yeah, that's what I eventaully figured, promoting a Maybe to an Either
