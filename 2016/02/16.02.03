00:00:07 <phadej> except time, AFAICS
00:01:24 <pavonia> Also scientific I guess
00:01:50 <phadej> scientific is used in `Value` type
00:02:20 <pavonia> Hhm, okay
00:04:18 <phadej> OTOH, you are correct. perfectly all instances would be written which could be, and for that dependency graph have to be linearised. Which could mean that stuff at the end would depend on almost everything before it
00:04:49 <phadej> but that's not true even for very beginning of depedency graph. For example hashable and vector
00:05:14 * hackagebot Plot-ho-matic 0.9.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.0 (GregHorn)
00:07:36 * hackagebot Plot-ho-matic 0.9.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.0 (GregHorn)
00:07:38 * hackagebot alsa-seq 0.6.0.6 - Binding to the ALSA Library API (MIDI sequencer).  https://hackage.haskell.org/package/alsa-seq-0.6.0.6 (HenningThielemann)
00:10:11 <tsahyt> Is there anything really bad about packages providing orphan instances? For example there's vector-instances.
00:13:51 <mniip> is there a 'fold' that uses Alternative instead of Monoid
00:15:23 <quchen> mniip: asum?
00:15:30 <mniip> :t asum
00:15:31 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
00:15:40 <mniip> hmmm no
00:15:42 <phadej> tsahyt: discoverablity
00:16:15 <phadej> mniip: foldMap Alt ?
00:16:25 <quchen> asum is literally a fold that uses Alternative instead of Monoid. fold = foldr mappend mempty, asum = foldr (<|>) empty.
00:16:44 <mniip> I meant something more like
00:16:51 <mniip> :t foldr ((<|>) . pure) empty
00:16:52 <lambdabot> (Foldable t, Alternative f) => t a -> f a
00:17:15 <jle`> is there a nice way to get kind synonyms?
00:17:34 <jle`> `type Foo = Bar ()` doesn't seem to work when i want to use Foo as a kind
00:17:37 * hackagebot alsa-pcm 0.6.0.4 - Binding to the ALSA Library API (PCM audio).  https://hackage.haskell.org/package/alsa-pcm-0.6.0.4 (HenningThielemann)
00:18:11 <phadej> mniip: getAlt . foldMap (Alt . pure) ?
00:18:29 <mniip> well it's starting to get a little bit too long
00:18:52 <mniip> I was merely looking for a more conscise way to say
00:18:55 <mniip> :t maybe empty pure . uncons
00:18:56 <lambdabot> Alternative f => [a] -> f (a, [a])
00:20:42 <phadej> well, there is 'choice' in parsing libraries, but not in `base`
00:20:56 <mniip> I see
00:21:26 <mniip> :t StateT $ maybe empty pure . uncons
00:21:27 <lambdabot> Alternative m => StateT [a] m a
00:21:28 <mniip> oh well
00:31:39 <jellytux> Now that I've read a bit about Curried functions and Higher-order functions
00:32:00 <jellytux> functions only take one parameter
00:32:16 <rom1504> yes
00:32:17 <jellytux> but how would I describe max a b
00:32:28 <jellytux> what are a and b?
00:32:43 <tsahyt> :t max
00:32:45 <lambdabot> Ord a => a -> a -> a
00:32:46 <tsahyt> :t max 0
00:32:48 <lambdabot> (Num a, Ord a) => a -> a
00:32:50 <tsahyt> :t max 0 1
00:32:51 <lambdabot> (Num a, Ord a) => a
00:33:15 <jellytux> but how would I describe them to you a fellow programmer in human language?
00:33:18 <tsahyt> a and b are values
00:33:35 <jellytux> I can't say that a and b are the first and second parameter of the function now can I?
00:33:41 <rom1504> max is a function that takes an argument and return a function
00:33:56 <tsahyt> You can still think of it that way, sure. Technically a is the argument to max, and b is the argument to max a
00:34:26 <rom1504> well in lot of situation thinking max has 2 arguments makes sense, even though it's not exactly that
00:34:56 <jellytux> but how would one describe that in an API/Library documentation
00:35:14 <jellytux> (I haven't read any since I am just a baby as of now)
00:35:26 <tsahyt> curried functions and functions of tuples are isomorphic. I think it's absolutely fine to think of max as a function of two parameters *and* as a function of one parameter returning a function
00:35:35 <montanonic> Is the Strict extension a thing yet?
00:35:47 <montanonic> I just tried {-# LANGUAGE Strict #-} but it wasn't a recognized pragma
00:35:49 <tsahyt> In the same sense that you can think of a linear map as a matrix and as a function
00:35:52 <montanonic> using LTS 3.19 with Stack
00:36:07 <montanonic> GHC = 7.10.2
00:36:41 <tsahyt> montanonic: I think it will be as of GHC 8
00:37:07 <montanonic> tsahyt: okay, awesome. Thank you.
00:47:38 * hackagebot event-list 0.1.1.3 - Event lists with relative or absolute time stamps  https://hackage.haskell.org/package/event-list-0.1.1.3 (HenningThielemann)
00:52:38 * hackagebot monad-logger 0.3.18 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.18 (MichaelSnoyman)
00:59:00 <Guest7358> Hi. I want to learn hasekll, and I play in ghci for the time beeing 
00:59:19 <Guest7358> can somone please explain me the general take-away from error messages like
00:59:26 <lpaste> Guest7358 pasted “No title” at http://lpaste.net/151551
01:00:16 <liste> Guest7358: you put a number in a place where a function is expected
01:01:36 <lpaste> Guest7358 pasted “No title” at http://lpaste.net/151552
01:01:55 <Guest7358> this is the code on which ghci chockes
01:02:53 <Guest7358> and please tell me what is the (Num(...)) part in the error message
01:03:32 <liste> :t 5
01:03:34 <lambdabot> Num a => a
01:04:07 <mgsloan> montanonic: If you want to try out the GHC 8 release candidate with stack, you can add this to your stack.yaml https://www.reddit.com/r/haskell/comments/40skug/ghc_80_release_candidate_1_is_out/cyxjsep
01:04:19 <EvanR> Guest7358: that code compilers for me
01:04:24 <EvanR> compiles*
01:04:33 <pavonia> Guest7358: Are the 2 1 0 digits actually part of your code?
01:04:35 <EvanR> (after removing the three random numerals
01:04:54 <EvanR> so the problem must be somewhere else in your code
01:04:59 <Guest7358> no, they aint pavonia
01:05:10 <liste> Guest7358: that Num part means that the literal 5 can't be interpreted as (Int -> Int -> Int)
01:05:12 <jellytux> http://sprunge.us/EEXH
01:05:13 <Guest7358> so Num is a typecalss ?
01:05:19 <Guest7358> typeclass
01:05:22 <liste> yes
01:05:24 <Guest7358> thanks
01:05:28 <jellytux> why can't I do zipWith' (++) ['A'..'Z'] ['a'..'z']
01:05:30 <jellytux> ?
01:05:44 <EvanR> :t (++)
01:05:45 <lambdabot> [a] -> [a] -> [a]
01:05:50 <EvanR> :t 'A'
01:05:51 <jellytux> ah wait I think I know why
01:05:52 <lambdabot> Char
01:05:58 <jellytux> can't do 'A' ++ 'a'
01:06:10 <jellytux> 'A':'a':[]
01:06:55 <EvanR> @pl (\x y -> [x,y])
01:06:55 <lambdabot> (. return) . (:)
01:07:25 <jellytux> I haven't learnt about that yet, but I guess that's something like a lambda function?
01:07:51 * mniip . o O ( are Maybe and Comaybe adjoint? )
01:07:52 <EvanR> (\x y -> [x,y]) is a lambda abstraction... or anonymous function "literal"
01:08:32 <Guest7358> hmm, how does ghci interprets a hs file ? after I removed the last lines I added to the file, the code compiles again. It is possible to get an error messages tenths of lines before the actual error ?
01:08:51 <jellytux> EvanR: wow, Haskell is so damn flexible - it makes me question what I've been doing my whole life
01:08:54 <jellytux> lol
01:09:17 <EvanR> flexible is not how a lot of people would call it ;)
01:09:32 <jellytux> EvanR: how come?
01:10:27 <EvanR> sometimes you hear, from people with peripheral knowledge of the language, haskell described as "bondage and discipline"
01:10:40 <jellytux> kinky
01:10:44 <jellytux> ^^
01:10:53 <EvanR> it wont auto convert Ints to Floats, it wont left you "add" a string to a string with the same operator as array concat
01:11:10 <EvanR> it wont let you merge two records
01:11:46 <EvanR> it wont let you randomly use nil to indicate a random thing
01:12:09 <EvanR> it wont let you "just return now" from a do block
01:12:32 <EvanR> (only specially prepared do blocks)
01:12:32 <Guest7358> So my mistake was passing indeed a number bound to a varibale to foldr where a function was expected, but why the interpretor output as error line not the line where I did the mistake, but rather tenths of lines before where the expresion for that varibale was define
01:12:33 <Guest7358> ?
01:12:45 <Guest7358> should i expect this behaviour all the time ?
01:12:49 <EvanR> Guest7358: can you paste the entire file then
01:13:03 <EvanR> for verification of that phenomnon
01:13:43 <jellytux> EvanR: I haven't gotten that far, but loving it so far
01:14:18 <jellytux> Lets me transform data like a boss
01:14:26 <EvanR> a big one is haskell wont let you "easily" execute IO or impure effects from just anywhere
01:15:07 <EvanR> theres no global variables
01:15:17 <EvanR> etc
01:15:22 <frerich> Guest7358: When you do something like 'foldr 5 ...', the compiler knows that a) the type of '5' is 'Num a => a', and b) the first argument to foldr has to be of type 'a -> b -> b'. So the compiler tries to unify those two requires, which means looking for an instance 'Num (a -> b -> b)'.
01:15:26 <jellytux> that's a big list :)
01:16:18 <EvanR> jellytux: but from all these things that cant happen, you may come to find that it is in a way liberating rather than restricting
01:16:31 <EvanR> because you dont have to think about it anymore
01:16:37 <Guest7358> yeah, I got that , but I would expect the error message from the compiler to spit the line where foldr was used
01:16:41 <EvanR> (most of the time)
01:16:42 <Guest7358> with the worng param
01:16:54 <Guest7358> not the line where the worng expresion was defined
01:16:55 <EvanR> Guest7358: it normally would be
01:17:07 <Guest7358> thanks
01:17:33 <EvanR> it would help if you put top level type annotations for each top level name
01:17:44 <bartavelle> do I have to wait for GHC 8 to have debug information for function names, or is there some flag I didn't find in 7.10.3 ?
01:17:58 <knupfer> What's the recommended way to perform a cleanup action in yesod when yesod terminates? A use of bracket in appMain?
01:17:59 <EvanR> the compiler uses that to determine which types are more likely to be what the user intended
01:21:25 <lpaste> Guest7358 pasted “No title” at http://lpaste.net/151553
01:21:27 <Guest7358> EvanR the whole file is a dumping ground where I test what I learned for last 2 days , here it is the paste  ... error was passing x which evaluated to Num instead of a function to foldr, surpise come from where the error was shown by the compiler  
01:22:29 <lpaste> Guest7358 pasted “No title” at http://lpaste.net/151554
01:22:38 <Guest7358> the error ghci split
01:22:58 <EvanR> Guest7358: yeah, so `x' has no type annotation, so inference may guess wrongly what you were trying to do
01:23:16 <EvanR> put x :: Int
01:23:19 <frerich> I think it's rather because at the very end of the file, it says
01:23:20 <frerich> product1 = foldr (x) 1 
01:23:26 <Guest7358> I see
01:23:28 <frerich> I.e. you unintentionally reused 'x'.
01:23:36 <EvanR> i think he was trying to do that
01:23:44 <Guest7358> I got that
01:23:50 <Guest7358> thanks
01:24:11 <EvanR> with x :: Int it will not think you are trying to use 5 as a function
01:24:22 <Guest7358> nI understand now
01:24:40 <EvanR> or x rather
01:24:49 <Guest7358> I will pay more and more attention to those 
01:24:49 <EvanR> and by extension 100 as a function
01:24:56 <frerich> Guest7358: Yeah, with 'x :: Int', you will still get a type error -- but something which is closer to what you expected.
01:25:16 <Guest7358> its cool I can leanr thos things fast thanks for your assistance
01:25:20 <Guest7358> its appreciated
01:26:00 <EvanR> a heuristic where in the absense of more info, it would rather not assume you are trying to use function Num instances, would be nice
01:26:28 <EvanR> i.e. consider function Num instances as less likely the intended results
01:30:59 <mniip> hmm
01:31:08 <mniip> if NT f g = forall a. f a -> g a
01:31:25 <mniip> does that mean that Adjunction f g = forall a b. (f a -> b, a -> g b)
01:38:49 <phadej> mniip: kind of. https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Adjunction.html
01:51:41 <EvanR> looks like i was on the right track the other day, in instance A a => B a, it operationally means you turn a given A a constraint into a B a at will. but in class A a => B a, it is the opposite direction
01:52:38 <EvanR> in the exploring the design space paper they mention this "perhaps the syntax was designed wrong!"
01:52:42 <EvanR> in a footnote
01:53:07 <phadej> EvanR: purescript reversed the other arrow :)
01:53:18 <EvanR> haha really
01:55:34 <Freundlich> EvanR: Yes, a class implication is reversed: A a => B a reads: B a implies A a.
01:55:44 <Freundlich> I noticed that as well some time ago.
01:57:24 <EvanR> in ruby class A < B, its also reversed
01:57:41 <EvanR> if you think of < as inclusion
01:58:27 <EvanR> A implies B, but B contains A
01:59:20 <EvanR> i guess thats the right direction, opposite of haskell
01:59:25 <EvanR> just the arrow is weird
02:09:26 <dramforever> I always thought A => B meant A implies B, so that syntax seems quite consistent to me. What do you think?
02:09:55 <EvanR> in the case of class declarations, its backwards
02:10:13 <dramforever> hmm yeah I take it back
02:10:14 <EvanR> which was confusing to me once i thought baout it
02:10:22 <thimoteus> it does mean that, but for example: Applicative m => Monad m says "if m is applicative it's a monad"
02:10:23 <EvanR> i thought i made a mistake ;)
02:10:24 <thimoteus> which is wrong
02:10:57 <dbushenko> hi all!
02:11:02 <EvanR> class Applicative m => Monad m means if m is a monad, its applicative, but if you changed it to instance, it would be forwards again
02:11:03 <dbushenko> what do you use for regex matching?
02:11:19 <Freundlich> douglascorrea: I suggest alex.
02:11:34 <Freundlich> Sorry.
02:11:41 <Freundlich> dbushenko: I suggest alex.
02:11:49 <dramforever> Text.Regex perhaps?
02:11:59 <tdammers> is there a way to make Aeson's Generics-based FromJSON instance accept "null" as a valid JSON serialization of a data type that has just one parameterless constructor?
02:12:21 <dbushenko> Freundlich, isn't alex for other purpose?
02:12:29 <tdammers> data Foo = Foo deriving (Generic); instance FromJSON Foo where -- like this
02:12:51 <tdammers> or do I need to write an instance manually?
02:12:54 <dbushenko> tdammers, did you try Maybe on the nullable fields?
02:12:56 <Freundlich> dbushenko: It takes a regular language and turn that into a parsing mechanism (a DFA). Maybe that's a bit overkill...
02:13:18 <tdammers> dbushenko: there are no fields
02:13:55 <m1dnight_> Is there an easy way to disable custom Show implementations and just use the `deriving` keyword?
02:14:01 <tdammers> dbushenko: the use case is consuming responses from a JSON API, where some response types do not carry any information at all, so I receive JSON Null
02:14:36 <tdammers> I could change the API to return an empty list instead, but that seems wrong
02:18:05 <tdammers> is there an existing type that has only one inhabitant and serializes to JSON Null?
02:18:27 <phadej> tdammers: () ?
02:18:31 <tdammers> nope
02:18:39 <phadej> does it serailises to empty array?
02:18:40 <tdammers> () serializes to an empty list, apparently
02:18:54 <tdammers> and deserializing "null" to () fails
02:18:58 <EvanR> thats annoying
02:19:07 <tdammers> yes
02:19:13 <phadej> makes sesne, () is empty tuple after all.
02:19:20 <tdammers> I'm very tempted to just write a Null type specifically for this
02:20:21 <tdammers> only other thing I've found that serializes from null are Maybes, but I'd want a type that has only the Nothing branch
02:20:23 <phadej> not the first time one need a newtype for different instance behaviour :)
02:21:04 <tdammers> well, I could hack the TH that generates instances to cater for this case, but I believe the Null type approach is easier in this case
02:21:11 <EvanR> perhaps unrelated: rails json request body support has a bug that i call "deep munge" where it considers all empty arrays as nil
02:21:27 <EvanR> i guess if it was related, it would be the opposite in aeson
02:22:18 <tdammers> oh, dynamic languages and their many different and incompatible notions of falsiness / emptiness / zeroness
02:22:30 <phadej> tdammers: but why you need `null`, just to check that field exists?
02:22:44 <tdammers> phadej: I need something that deserializes correctly
02:23:03 <tdammers> my API always returns responses of the form {"status":"ok","data":...}
02:23:20 <phadej> and sometimes data is just "null" ?
02:23:25 <tdammers> and for each call, I define a pair of Request and Response types, such that the Response type serializes from whatever is in data
02:23:27 <tdammers> yeah
02:23:36 <tdammers> for some calls, all that matters is that I get a response at all
02:23:37 <phadej> ok, now it make sense
02:23:45 <EvanR> "dude whats the point of having data there if its null"
02:23:53 <tdammers> I could leave it out
02:24:00 <tdammers> but that wouldn't solve my problem would it
02:24:05 <tdammers> I'd still need to special-case those calls
02:24:20 <EvanR> yes thats why it should be there ;)
02:24:26 <EvanR> (and working)
02:24:32 <tdammers> exactly
02:24:33 <phadej> tdammers: i'd write an EmptyResponse for your api specifically
02:24:41 <dramforever> Now I wonder what () deserializes to
02:24:50 <phadej> would communicate semantics better as well
02:24:53 <phadej> dramforever: empty list
02:25:15 <tdammers> phadej: well, yes, that's the idea - for each request that returns an empty response, I write a type of the shape data Response = Response;
02:25:19 <tdammers> that's not the issue
02:25:32 <dramforever> :(
02:25:33 <tdammers> the issue is that I want to use the same TH to generate all the instance boilerplate
02:26:00 <phadej> well, that's not much of extra boilerplate to check if your type is "Boring"
02:26:21 <tdammers> hmm, well, you're right
02:29:23 <dramforever> tdammers: I wonder if it's okay to have a type data Boring = Boring and use that for all boring responses
02:30:11 <tdammers> dramforever: normally, yes, but the way it works currently is that I have one module per call, designed to be imported qualified, and it defines two types named CallName.Request and CallName.Response
02:30:37 <tdammers> this way I can just write $(deriveAPICall "methodName")
02:30:41 <phadej> type Response = Boring ?
02:30:49 * tdammers facepalms
02:30:51 <tdammers> ofc
02:31:12 <tdammers> OTOH, that's not much less boilerplate than data Response = Response
02:31:19 <ironChicken> does anyone know of any examples of using the Progress String (IO Progress) constructor of the Progress type in Distribution.Testsuite?
02:31:32 <phadej> tdammers: no need to write TH :)
02:31:43 <tdammers> I need TH to generate the instances
02:32:18 <tdammers> ToJSON/FromJSON for the request and response, IsRequest for the Request, and IsCall for the Request/Response pair
02:32:40 * hackagebot psqueues 0.2.1.0 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.1.0 (JasperVanDerJeugt)
02:35:09 <dramforever> Check if Response is an alias of Boring in the TH call?
02:35:28 <tdammers> even easier: check if Response has exactly one constructor, and that constructor is parameterless
02:35:36 <tdammers> writing the pattern-matching as we speak
02:44:39 <EvanR> what is a "constructor class"
02:49:50 <tdammers> hmm, I can't create entire modules out of thin air using TH, can I
02:52:41 * hackagebot not-gloss 0.7.6.3 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.3 (GregHorn)
02:58:42 <mauke`> EvanR: one of kind (* -> x) -> Constraint, not * -> Constraint
02:59:04 <EvanR> ah
03:35:40 <Yuras> hey, was anyone able to enable -split-objs with stack?
03:38:15 <mgsloan> Yuras: I'll probably implement https://github.com/commercialhaskell/stack/issues/1438 at some point
03:38:50 <mgsloan> There's an anecdotal report that "--ghc-options -split-objs" doesn't work, but I have no idea why it wouldn't
03:39:01 <mgsloan> potentially `--enable-split-objs` does more than pass that flag to ghc
03:39:13 <Yuras> mgsloan: so it is simply not possible yet?
03:39:23 <Yuras> ghc-options doesn't work for me too
03:39:42 <Yuras> I'll probably switch back to cabal sandbox
03:39:46 <mgsloan> Yeah, but it isn't anything fundamental.  We just never needed configure-options
03:40:16 <mgsloan> Should be a really easy thing to add to stack
03:40:24 <mgsloan> I'm just swamped with other stuf
03:52:35 <marrrk> Please explain to me how to use the "Strawberry" flavour described in this: https://hackage.haskell.org/package/ansi-terminal-0.6.2.3/docs/System-Console-ANSI.html#g:1
03:52:44 <SrPx> Hello guys, so after those 2~3 years struggling I think I'm confident enough with Haskell. Now I see dozens of problems my company faces could be easily solved by what Haskell already does. But do you think it is a good idea to try introducing it to my company? Or should I avoid it in fear some practical factors such as ability to hire, etc., will hurt it more?
03:53:43 <frerich> SrPx: In my experience,  it's easier to rather apply lessons learned from working with Haskell (e.g. pure functions) to the currently used programming language.
03:54:22 <mgsloan> Of course easier /= better :)
03:56:16 <quchen> marrrk: putStr (setSGRCode [SetColor Foreground Vivid Green] ++ "Hello World" ++ setSGRCode [Reset])
03:56:18 <maerwald> SrPx: so how many of your employees know haskell already? If the answer is 0, then introducing haskell will take probably as long as it took you to get confident with it.
03:56:53 <marrrk> quchen: Is there no way around IO? I was trying to use "interact"
03:57:42 * hackagebot werewolf 0.4.1.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.1.0 (hjwylde)
03:57:44 * hackagebot werewolf 0.4.2.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.2.0 (hjwylde)
03:58:01 <SrPx> maerwald: 1 is a better answer ?  :P
03:58:18 <SrPx> But yea, you area right.
03:58:31 <quchen> marrrk: The part in parentheses does not use IO.
03:58:42 <marrrk> oh okay
03:58:42 <quchen> That's how the third flavour in that lib is used, I guess.
03:58:52 <SrPx> (Any quick way to convert a binary string such as "00010011" to hex, such as "13", without having to code it myself?)
03:58:52 <maerwald> I think it's easier to form a startup based on haskell/FP than introducing haskell to en existing company.
03:58:55 <marrrk> Thanks I will try it out
03:58:55 <SrPx> Something from Hackage
03:59:18 <SrPx> I find it a little awkward that coding some things like that in Haskell is often faster than finding it 
04:01:22 <jophish> We're going to be hiring some haskell people soon. What haskelly questions would you ask at an interview?
04:02:17 <SrPx> Write an algorithm to detect if a potentially infinite list has a cycle
04:02:26 <SrPx> is cyclic*
04:02:28 <quchen> SrPx: I'd hire someone who can do that.
04:02:35 <SrPx> That's the point :)
04:02:44 <jophish> The ones I've got are along the lines of: Explain what a category is. What is a Functor. What are the differences between Applicative and Monad
04:02:59 <jophish> SrPx: :D nice one
04:03:05 <SrPx> jophish: well I'd be discarded already
04:03:10 <SrPx> jophish: so consider that a good question
04:03:14 <quchen> What a category is is probably not very useful to ask. It's not something you need in everyday Haskell at all.
04:03:15 <maerwald> a category? I think that's not really relevant for practical haskell
04:03:37 <quchen> Ask them to implement a tree type, and a lookup on it.
04:03:39 <jophish> hmm, that's what you get from an office full of mathematicians :/
04:03:39 <maerwald> applicative vs monad however is an excellent question
04:03:47 <quchen> Make them sum up the values of the tree. Talk about strictness.
04:03:48 <quchen> End.
04:03:57 <jophish> oh, strictness questions are good
04:04:12 <quchen> The rest is filler material to keep talking if you like each other ;-)
04:04:36 <SrPx> actually you here taught me a category is just like a graph with a property that if there is an edge A->B and an edge B->C then there is an edge A->C
04:04:44 <SrPx> so I might be able to BS through that question? 
04:05:15 <quchen> Applicative vs Monad is good for proficient candidates, but you can get pretty far with a good gut feeling on that topic, I don't think it's a requirement. Strictness on the other hand is crucial.
04:05:21 <jophish> I guess that good questions would tell the interviewer more about the candidate than just reading their public code
04:05:23 <tdammers> I got some questions on the Haskell library ecosystem in one interview, I thought that was a rather good question
04:05:52 <SrPx> But seriously, though. I'd ask them to implement the list datatype and some list functions. I'd say there is a very clear line where if you are not able to do that you almost certainly isn't good in Haskell, and if you can, then you probably are.
04:06:14 <jophish> tdammers: what kind of questions?
04:06:33 <SrPx> foldr, foldl, map, sum
04:06:40 <maerwald> you could also come up with broad things like "what ways do you know to express or simulate state in haskell?"
04:06:55 <maerwald> and that's a lot more than ST monad
04:07:02 <SrPx> maerwald: and if they say monads run away
04:07:15 <jophish> "That's easy, I always use unsafeperformIO"
04:07:15 <maerwald> they should say "recursion" first
04:07:19 <tdammers> jophish: stuff like, which type would you use for general-purpose string processing, which libraries do you prefer to generate HTML, which library for avoiding lazy I/O, etc.
04:07:47 <quchen> I've asked a candidate to sketch a webserver in Haskell. Nothing big, just the loop and a handler, then you can go into detail of where one could apply concurrency, where exceptions might leak, and what not. It's open-ended and you can end up in a nice technical discussion, which tells you much more than a question with a definite answer.
04:08:11 <tdammers> quchen: it's also something that's biased towards people who have done it before
04:08:26 <jophish> tdammers: ah, that kind. I was wondering if they were quizzing you on how Cabal and Hackage are implemented
04:08:33 <tdammers> jophish: yeah, no.
04:08:43 <jophish> quchen: I might do that for a basic compiler
04:08:49 <SrPx> yep I wouldn't know that one :( mostly for the web-related part, I've always used high level libs to do that kind of thing
04:08:49 <jophish> (We're writing a compiler)
04:09:16 <quchen> tdammers: But if you realize someone has done it before you can still find many niches you can go on. How would you handle routing, how things scale, and what not.
04:09:27 <jophish> I'm tempted to ask about some knowledge on system-f, but that's something specific to what we're doing
04:09:28 <tdammers> I would first look at the candidate's portfolio and then either pick something they've never done before, or something they should know how to do fairly well
04:09:41 <SrPx> tdammers: +1
04:09:45 <jophish> or at least test to see how quickly they can understand it (assuming no knowledge)
04:09:52 <tdammers> depending where you want the conversation to go, obv
04:10:06 <SrPx> give them a random piece of ekmett's code and ask them to explain it to you
04:10:12 <tdammers> but I'm actually more tempted to say "pick something the candidate is comfortable with and see if you can get that spark in their eyes"
04:11:09 <tdammers> but there's certainly value in seeing how a candidate responds to a challenge that is typical for your business, but outside their current experience
04:11:37 <tdammers> and then hiring the candidate that comes up with ideas that are different from what you've done so far, but in a good way
04:11:51 <jophish> tdammers: perhaps that could be to get them to explain some of their code to you as though the interviewer was a beginner
04:12:22 <jophish> oh! I've got a good question: "If you were interviewing a candidate for a Haskell position, what questions would you ask them"
04:12:47 <maerwald> the only thing I'd care about when looking at a candidates code is the documentation
04:12:56 <maerwald> if there is none... get out
04:13:04 <maerwald> (no matter if it's his foss project or not)
04:13:14 <tdammers> "If you were asked "If you were interviewing a candidate for a Haskell position, what questions would you ask them", what answers would you expect?"
04:14:09 <tdammers> maerwald: BUT DOCUMENTATION IS AN ANTIPATTERN, DOCUMENTATION CAN GO STALE AND THEN ALL HELL BURSTS LOOSE, ITS BETTER TO NOT WRITE DOCUMENTATION!!!111
04:14:31 <quchen> tdammers: Not funny. :'(
04:14:37 <tdammers> sorry
04:14:43 <tdammers> too close to reality?
04:14:51 <flux> just write machine-readable documentation and infer the implementation from that!
04:14:59 <quchen> "Close" makes it sound like there's a gap.
04:15:35 <flux> actually someone(TM) should research if it would be possible to use some pattern detection that would prompt the user about "non obvious places" that "why are you writing this piece of code here"
04:15:50 <tdammers> flux: awesome idea. all we have to do is come up with a formal language that describes in minute detail what our code is supposed to do; we can then use that language to write our documentation, and use an automated tool to derive the code from it!
04:16:10 <flux> tdammers, exactly!
04:16:16 <Freundlich> "What code is supposed to do"... wait, that's a programming language! :p
04:16:22 <flux> tdammers, and to make it amazing, it would also have a LaTeX-backend
04:16:23 <tdammers> flux: we shall call that tool a "compiler"
04:16:59 <flux> but as you wrote, your documentation only describes the 'what', not the 'why'
04:17:00 <Freundlich> Coming up with good documentation is pretty hard, and a lot of Haskell libraries are lacking in that regard IMO.
04:17:15 <maerwald> terribly lacking even
04:17:16 <riaqn> Hello, when I 'm trying to update a record, I 'm told "‘field’ is not a (visible) constructor field name", what does it mean?
04:17:20 <flux> and at times, not the "why not" :)
04:17:20 <Freundlich> But on the other hand it's good if you don't need to say much besides from the formal specification.
04:17:23 <tdammers> Freundlich: a lot of libraries in general are lacking in that regard
04:17:27 <jophish> documentis qui in documenters
04:17:30 <tdammers> Haskell just gives you a tempting excuse to slack more
04:17:36 <tdammers> ("The types are the documentation")
04:17:38 <maerwald> yeah and it's just that... an excuse
04:17:46 <tdammers> in part, yes
04:18:07 <flux> well, they really are a lot of that, I would expect them to be an amazing level of documentation if you come from untyped language ;-)
04:18:16 <quchen> tdammers: We have one-letter definitions to make up for that
04:18:22 <tdammers> but to be fair, I've successfully figured out and used productively some libraries that had virtually no documentation beyond a rough outline of what they're for, and I could figure out how to use them based on the types alone
04:18:46 <flux> just nice type aliases can do a lot, plus good naming of types
04:19:05 <tdammers> flux: these days I tend to step up to newtypes sooner rather than later
04:19:30 <tdammers> flux: the extra effort is minimal, especially with GeneralizedNewtypeDeriving, and you get more meaningful type checks in return
04:19:48 <tdammers> velocity :: Distance -> Time -> Velocity
04:20:00 <jophish> Do you think it's worth asking about how (basically) Haskell is translated to machine code. On the one hand it's not always relevant, on the other hand it is something one tends to pick up with some experience.
04:20:06 <tdammers> ^ if you use type aliases, you can still swap the arguments, but newtypes will prevent that
04:20:17 <maerwald> jophish: no
04:20:46 <tdammers> jophish: I'd say the whole point of using a high-level language like Haskell is so you don't have to worry about the machine code translation
04:20:50 <maerwald> don't ask about compiler details at all
04:21:47 <maerwald> a nice question would also be "how do you represent a graph (or just doubly linked list) in haskell?"
04:21:50 <jophish> For what we're doing some knowledge about compilers is important though
04:22:29 <tzaeru> maerwald, myea, just too bad that actual computers don't run mathematical representations of complex graphs but machine code that coincidentally happens to produce effects consistent with what you'd expect from a doubly linked list
04:22:33 <maerwald> as in: moving to things that are awkward in haskell and figuring out how the candidate deals with them
04:22:43 * hackagebot json-pointer 0.1 - JSON Pointer parsing and interpretation utilities  https://hackage.haskell.org/package/json-pointer-0.1 (NikitaVolkov)
04:23:18 <tzaeru> not saying that it was generally useful to have a clue about how the compiler works, but flat-out ignoring the questions about that is a bit.. odd.
04:23:41 <tdammers> maerwald: AFAIK you end up implementing pointer/reference semantics on top of Haskell's type system one way or antoher
04:23:46 <maerwald> that's not a haskell question then, it's a GHC question
04:23:57 <maerwald> tdammers: there are multiple ways to do that
04:24:02 <jophish> "do you use Hugs?"
04:24:17 <tzaeru> well, you could then direct people to a forum for GHC questions instead of just saying that it's a bad question, ask something else? :P
04:24:55 <tdammers> maerwald: but they all involve some kind of explicit referencing right?
04:25:06 <maerwald> Well, I use haskell, because I don't want to care about compiler details. Otherwise I can go back to C :/
04:25:13 <maerwald> tdammers: no
04:25:25 <tdammers> how so?
04:25:41 <marrrk> What should I use for regexes?
04:25:48 <maerwald> you can abuse laziness with recursive let so the compiler implicitly creates those references
04:25:55 <tdammers> oooh, rigt
04:25:55 <maerwald> it's called tying the knot and is highly awkward
04:26:08 <liste> @hackage regex-applicative -- marrrk this could be interesting
04:26:08 <lambdabot> http://hackage.haskell.org/package/regex-applicative -- marrrk this could be interesting
04:26:16 <maerwald> and for anything more complex than a doubly linked list, it will hurt your brains
04:26:28 <liste> marrrk although maybe it's better to just go to "full" parser conbinators
04:26:40 <tdammers> yeah, I think I tried that once and didn't like it at all
04:26:53 <maerwald> it's pretty unexpressive haskell code
04:26:54 <marrrk> liste: What if I'm a beginner?
04:28:11 <marrrk> This doesn't work: http://hackage.haskell.org/packages/archive/regex-applicative/latest/doc/html/Text-Regex-Applicative.html
04:28:32 <liste> marrrk this does: https://hackage.haskell.org/package/regex-applicative-0.3.2.1/docs/Text-Regex-Applicative.html
04:28:38 <maerwald> also, maybe it's worth asking about the IO type explicitly... it's one of those things many people get wrong or only partly right
04:28:45 <marrrk> Thanks
04:28:50 <maerwald> (and is also awkward in haskell)
04:30:02 <liste> marrrk https://github.com/feuerbach/regex-applicative/wiki/Examples here's examples
04:30:09 <jophish> maerwald: what about IO?
04:30:21 <maerwald> jophish: ask what it is
04:30:40 <maerwald> and you don't want to hear "it's a monad" :P
04:31:48 <jophish> well, that could lead to some follow up questions
04:32:42 <jophish> I think it's important to know if they think that Monad is just to enable syntactic sugar and ordering of effects or if they understand more
04:33:03 <jophish> but that's probably covered by the Applicative vs Monad question
04:34:29 <icbm> `\o -> o ?? m` is the same as `((??) m)` right?  The former typechecks but the latter doesn't.  (?? is some operator)
04:34:35 <marrrk> liste: Does that work with Text or [Char]?
04:34:46 <liste> marrrk [Char] unfortunately
04:35:12 <notdan> icbm: hm, might be (?? m)
04:35:20 <marrrk> I'm starting to wonder if I am gaining any performance if all I'm doing is T.pack and T.unpack all the time.
04:35:29 <notdan> I am not sure, but my suspicion is ((??) m) is \o -> m ?? o
04:35:48 <notdan> > ((++) [3]) [2]
04:35:49 <lambdabot>  [3,2]
04:35:52 <icbm> notdan: That was it.  I get it now.
04:36:43 <barrucadu> () lets you use an infix operator as a regular prefix function
04:36:50 <icbm> notdan: x ?? y = (??) x y = (?? y) x
04:36:54 <barrucadu> Just like how `` lets you use a funciton like an infix operator
04:37:12 <liste> marrrk found this, it has only one release though https://hackage.haskell.org/package/regex-applicative-text
04:37:15 <icbm> Yep, coffee underflow error.  I remember now.
04:40:44 <EvanR> so uh. generalized newtype deriving breaks type safety when used with GADTs ?
04:43:07 <EvanR> kind of old reddit, https://www.reddit.com/r/haskell/comments/19mwxr/how_the_syntactic_type_equality_of_gadts_inhibit/ but the problem appeared to have caused a debate about HoTT instead possible fixes
04:49:41 <EvanR> latest ghc manual does not mention the issue in the section on generalized newtype deriving
04:52:30 <notdan> I think it got fixed at some point?
04:52:38 <notdan> EvanR: goldfire worked on that IIRC
04:53:09 <burbly> I'm getting a bunch of error messages which I am pretty sure are related to the "burning bridges" change
04:53:21 <burbly> e.g. 
04:53:22 <burbly>  No instance for (Monoid (t0 Bool))
04:53:22 <burbly>       arising from a use of `accumulateVariableInTerm'
04:53:25 <notdan> EvanR: https://ghc.haskell.org/trac/ghc/wiki/Roles
04:53:29 <burbly> I can't remember whether there is a quick fix for this? 
04:53:48 <EvanR> ah this is related to roles
04:53:52 <burbly> [Short of downgrading my version of the Haskell platform]
04:57:19 <mniip> 1454502358 [15:25:58] <liste> marrrk although maybe it's better to just go to "full" parser conbinators
04:57:29 <mniip> just use the 2 loc monadic parser library!
04:58:13 <EvanR> haha
04:58:40 <burbly> http://lpaste.net/151560   
04:58:44 <burbly> has more errors
04:59:29 <burbly> All arising from
04:59:30 <burbly> occursIn :: Variable -> Term -> Bool
04:59:30 <burbly> occursIn v = or . accumulateVariableInTerm (return . (== v))
04:59:38 <ahihi> burbly: I think you need to add explicit type signatures somewhere
04:59:42 <barrucadu> What's the type of accumulateVariableInTerm?
05:00:26 <EvanR> indeed i cannot pull the shenanigans with GND and GADTs to cause type unsafety
05:00:38 <EvanR> the error message is kind of esoteric though
05:00:44 <EvanR> i will read about roles
05:01:19 <burbly> I'm just trying to figure out the type signature -- this is code I haven't looked at in years, and unfortunately it's not explicit
05:01:56 <mniip> hey EvanR have you seen the updated library :D
05:02:01 <mniip> 5 lines of code -> 2
05:02:22 <hodapp> what is this, Perl?!
05:02:23 <barrucadu> mniip: How did you manage that?
05:02:48 <liste> mniip where?
05:02:52 <burbly> I have mapVariableInTermM :: Monad m => (Variable -> m Variable) -> Term -> m Term
05:03:12 <burbly> nonmonadic :: ((a -> Identity a) -> b-> Identity b) -> (a -> a) -> b -> b
05:03:16 <burbly> mapVariableInTerm = nonmonadic mapVariableInTermM
05:03:22 <burbly> accumulate :: forall w. forall a. forall b. (Monoid w) => ((a -> Writer w a) -> b-> Writer w b) -> (a -> w) -> b -> w
05:03:27 <mniip> http://lpaste.net/151381
05:03:28 <burbly> accumulateVariableInTerm = accumulate mapVariableInTermM
05:03:29 <barrucadu> I had a similar amount of fun when I was playing around with writing a parsing/serialisation library using State/Divisible. I changed some newtypes to types, abstracted over some type variables, and suddenly everything I needed dropped out for free :)
05:03:58 <burbly> Sorry, ignore that part about nonmonadic
05:04:05 <EvanR> mniip: i see 5 lines
05:04:13 <mniip> EvanR, types don't count :p
05:04:19 <mniip> they are kinda optional
05:04:20 <EvanR> THERE ARE 5 LINES
05:04:28 <EvanR> jk
05:05:14 <mniip> barrucadu, I don't know, it sort of hit me all of a sudden
05:05:36 <burbly> Is there a way to use e.g. lambdabot to deduce the type of accumulateVariableInTerm  From the types of mapVariableInTermM and accumulate?
05:06:45 <barrucadu> :t let accumulate = undefined :: (Monoid w) => ((a -> Writer w a) -> b-> Writer w b) -> (a -> w) -> b -> w; mapVariableInTermM = undefined :: Monad m => (Variable -> m Variable) -> Term -> m Term; in accumulate mapVariableInTermM
05:06:47 <lambdabot>     Not in scope: type constructor or class ‘Variable’
05:06:47 <lambdabot>     Not in scope: type constructor or class ‘Variable’
05:06:47 <lambdabot> Not in scope: type constructor or class ‘Term’
05:06:50 <barrucadu> Oops
05:07:09 <EvanR> :t uncons
05:07:10 <lambdabot> [a] -> Maybe (a, [a])
05:07:52 <EvanR> the secret sauce
05:08:33 <burbly> Variable and Term aren't really important for present purposes -- you could replace them with whatever.
05:09:26 <burbly> It looks like one should be unifying 'm = Writer w', 'a = Variable', 'b = Term'
05:10:02 <burbly> so accumulate mapVariableInTermM :: (Monoid w) => (Variable -> w) -> Term -> w
05:10:29 <burbly> That's the type of  accumulateVariableInTerm 
05:10:53 <burbly> So why am I getting an error message in 
05:10:53 <burbly> occursIn v = or . accumulateVariableInTerm (return . (== v))
05:10:58 <burbly> After the burning Bridges change?
05:11:24 <burbly> because there's now more than one monoid it could mean?
05:11:59 <ahihi> yeah
05:12:36 <mchall> is  [a -> b] a list of functions and how do I use it ?
05:12:38 <burbly> What's easiest way of fixing it? 
05:13:06 <liste> mchall: it's a list of functions from a to b. what do you want to do with it?
05:13:12 <burbly> I can't even remember what monoid I meant to use -- list? 
05:13:37 <notdan> mchall: you can get a function from the list and apply it to something?
05:13:37 <ahihi> perhaps: occursIn v = (or :: [Bool] -> Bool) . accumulateVariableInTerm (return . (== v))
05:13:46 <mchall> the function definition is combStep :: [a -> b] -> [a] -> [b]
05:14:11 <liste> :t zipWith
05:14:13 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:14:20 <mchall> so take an a give it to the function and get a b how do I do that ?
05:14:31 <notdan> :t zipWith ($)
05:14:33 <lambdabot> [a -> c] -> [a] -> [c]
05:14:34 <ahihi> burbly: before the change, or (in the Prelude) was defined only on lists
05:14:46 <notdan> mchall: see zipWith ^^
05:15:14 <EvanR> you *may* be able to get a function from the list and apply it to something
05:15:21 <EvanR> by no means guaranteed possible
05:15:49 <burbly> ahihi: that would definitely explain it – thanks for the explanation.
05:15:49 <EvanR> but it is possible to zip the list against a list of arguments
05:15:57 <notdan> yeah yeah
05:16:01 <EvanR> taking the shorter of the two as the list of results
05:16:09 <burbly> Sadly that change doesn't make the error messages go away -- I on the other hand have to go to a driving lesson.  Thanks for the help so far.
05:16:47 <EvanR> dont drive and derive
05:20:30 <mchall> zipWith takes a function and two lists how do I use it here ?
05:20:39 <burbly> no, wait, it works. Thanks!! must go...
05:20:56 <mniip> mchall, you just explained how to use it
05:21:53 <prsteele> mchall: :t ($) :: (a -> b) -> a -> b
05:22:14 <ahihi> burbly: good to hear :)
05:23:26 <mchall> something like ? combStep flst lst  = zipWith  (\f l -> f l) flst lst   
05:23:48 <prsteele> > :t (\f l -> f l)
05:23:50 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:23:55 <prsteele> :t (\f l -> f l)
05:23:56 <lambdabot> (r1 -> r) -> r1 -> r
05:24:01 <prsteele> :t ($)
05:24:02 <lambdabot> (a -> b) -> a -> b
05:25:48 <liste> mchall yes, for example
05:26:07 <mchall> prsteele these are from the monad challenges and use a custom prelude so that is not available
05:26:34 <prsteele> :t id :: (a -> b) -> a -> b
05:26:36 <lambdabot> (a -> b) -> a -> b
05:26:47 <prsteele> mchall: ($) is just id with different fixity
05:28:59 <mniip> ($) is type-constrained id
05:29:11 <mniip> they aren't exactly interchangeable
05:29:35 <prsteele> true, I suppose I should have said you can define ($) in terms of id
05:43:32 <ggole> $ actually has slightly different typing rules to id
05:57:18 <Geraldus_____> hi friends!  
05:58:42 <Geraldus> it there some cases when following record syntax won't work: `data A = A { b :: () } deriving Show;  let x = A undefined;  let y = x { b =  () }` ? 
05:59:22 <Geraldus> this works well in GHCi, but in my real app I see "*** Exception: Prelude.undefined"
05:59:46 <Geraldus> I have re-checked and everything looks fine.  Can't figure out what's wrong 
06:00:26 <EvanR> Geraldus: lpaste the minimal test case?
06:00:30 <prsteele> Geraldus: shot in the dark, do you have strict record fields on in your cabal file?
06:00:36 <prsteele> i.e. https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
06:02:53 <Geraldus> prsteele: no, this is not my case, by the way thank you, I wasn't aware of this pragma.
06:03:26 <Geraldus> EvanR: hmm… I'll try to strip out useless parts and paste example now
06:03:44 <dcoutts> Geraldus: I believe that should work just fine, and for me it does.
06:03:57 <Geraldus> prsteele: I see error only when I'm attempting to store modified data to DB
06:04:55 <EvanR> Geraldus: for example... let x = A undefined; won't fit in a normal source file so not sure how to reproduce the effect
06:05:24 <dcoutts> main = do
06:05:24 <dcoutts>   let x = A undefined
06:05:24 <dcoutts>   let y = x { b =  () }
06:05:24 <dcoutts>   print y
06:05:27 <dcoutts> this works just fine
06:05:30 <EvanR> and putting both lets... yeah you need a print
06:06:14 <Geraldus> dcoutts: I belive it should, because it works in GHCi :D
06:06:26 <dcoutts> Geraldus: and it works compiled
06:06:48 <dcoutts> I also believe it should based on the semantics :-)
06:14:12 <domen> is Data.Array implementet by using Data.Map?
06:14:43 <domen> i mean, are arrays just association lists?
06:16:12 <lpaste> Geraldus pasted “example” at http://lpaste.net/9125169074215583744
06:16:29 <geekosaur> domen, no
06:16:37 <Geraldus> EvanR: I http://lpaste.net/9125169074215583744
06:17:12 <Guest7358> What means a "rigid type variable" ?
06:19:57 <geekosaur> Guest7358, it means the type variable cannot match just any type but instead must be compatible with the way it is used; that information should be the next thing in the error message
06:19:58 <Geraldus> dcoutts: you also could have a look (:
06:20:51 <Geraldus> I use record wildcards in that module, but I believe it should not matter
06:21:24 <vkt> If I wanted to create 'data Pair a b = Pair a b' with type a = type b how would I syntactically incorporate that constraint?
06:21:40 <mauke`> Geraldus: that doesn't look like a valid file
06:21:52 <mauke`> vkt: data Pair a = Pair a a
06:22:41 <vkt> mauke`: what does that mean semantically?
06:23:21 <dcoutts> Geraldus: and the definition of MediaMetaData?
06:24:37 <vkt> mauke`: because if i extend that to lets say 'data Quad a b = Quad a a b b' that doesnt work
06:25:09 <EvanR> Geraldus: so mmd crashes... does mmd'
06:25:28 <EvanR> if not, that kind of proves realMid is bottom
06:25:39 <geekosaur> vkt, maybe you need to explain what you're trying to accomplish; because it doesn't make a lot of sense that you use different type variables but want them to always be the same type
06:25:46 <EvanR> which seems like it would be a big in `upsert'
06:27:25 <tromp> uter-go] Knowledge Details - The current fashion favours general AI approaches forgoing knowledge details. Given enough
06:27:27 <tromp> 	 	4:50 am
06:27:28 <tromp> 	
06:27:30 <tromp> 	Not starred	
06:27:31 <tromp> 	
06:27:33 <tromp> cryptography-request
06:27:34 <tromp> 	
06:27:36 <tromp> cryptography Digest, Vol 34, Issue 1 - Send cryptography mailing list submissions to cryptography@metzdowd.com To subscribe or unsubscribe
06:27:38 <tromp> 	 	9:36 pm
06:27:39 <tromp> 	
06:27:40 <tromp> 	Not starred	
06:27:46 <lpaste> Geraldus revised “example”: “No title” at http://lpaste.net/9125169074215583744
06:27:46 <mauke`> vkt: yes, it does
06:28:22 <Geraldus> dcoutts: I've updated pasted code, MediaMetaData is Persist model
06:28:25 <mauke`> @let data Quad a b = Quad a a b b   deriving (Eq, Ord, Read, Show)
06:28:28 <lambdabot>  Defined.
06:28:56 <Geraldus> EvanR: yeah, it looks like realMid is undefined, by the way, let me check what is it for sure
06:28:57 <dcoutts> Geraldus: ahh, do you know how it's actually defined? It may well be defined with strict fields.
06:29:47 <dcoutts> Geraldus: you can use ghc's  :info to find out how it's defined
06:31:24 <Geraldus> dcoutts: hmmm… I know all fields of Aeson's Value are strict and I use it to parse answer from API
06:32:08 <dcoutts> Geraldus: it's not clear to me why that's relevant
06:32:30 <Geraldus> dcoutts: likely it is not, let me check realMid value
06:32:34 <dcoutts> Geraldus: the important question is whether the fields of MediaMetaData are defined to be strict or not. This depends on what Persist does.
06:32:40 <EvanR> realMid is coming back from upsert
06:32:52 <Geraldus> EvanR: yep
06:33:16 <dcoutts> it would not surprise me at all if Persist defaults to all fields strict
06:33:30 <{AS}> Geraldus: Have you tried using Maybe instead of undefined?
06:33:33 <EvanR> would that mean it would have crashed much sooner
06:33:36 <EvanR> wouldnt*
06:33:46 <EvanR> instead of waiting until the record is printed
06:34:03 <{AS}> I am wondering whether it may give you a more clear indication where it failed
06:35:54 <JJJollyjim> Hey, dumb question: how do I use a package that provides an alternate prelude? Is it as simple as importing it unqualified? 
06:36:36 <dcoutts> JJJollyjim: and import Prelude () or use the language extension NoImplicitPrelude
06:36:44 <Geraldus> realMid is a real value, it is printed successfully, let me check :info 
06:37:12 <bergmark> JJJollyjim: does the package have a module named Prelude?
06:37:13 <Geraldus> dcoutts: you're right, it have strict fileds
06:37:18 <Geraldus> *fields
06:37:30 <Geraldus> thanks, I should update my code in this case
06:37:38 <dcoutts> Geraldus: so this means the update is not the problem, it's putting an undefined in there in the first place
06:37:50 <dcoutts> or alternatively in using strict fields when you want at least this one to be lazy
06:38:17 <dcoutts> mind you, it's not great design to stuff _|_ values in
06:38:19 <JJJollyjim> No bergmark, module is ClassyPrelude
06:38:27 <JJJollyjim> Thanks dcoutts 
06:38:52 <Geraldus> dcoutts: mediaMetaDataMedia :: !Key MediaId
06:40:17 <Geraldus> dcoutts: I know, I can substitute this with `toSqlKey 0` or even -1, but it looks for me more hacky than undefined.  This is just a raw quick approach, I definitely write better code late
06:40:35 <EvanR> Key MediaId, so the MediaId could be _|_
06:40:45 <EvanR> in which case the strict field isnt immediately crashing
06:40:50 <Geraldus> I just wanted to have some quick near real world test run 
06:42:28 <Geraldus> thank you pals, learned few new things (:
06:42:34 <Geraldus> have a nice day!
07:00:37 <prsteele> is there a well-understood relationship between the max heap size and how much RAM my program can take?
07:01:15 <prsteele> i.e. if I'm worried about running out of memory will +RTS M1024m -RTS limit me to about a gig of ram?
07:02:25 <sm> more or less (with a hyphen in fron of the M)
07:02:43 <prsteele> sm: thanks
07:03:12 <prsteele> I want to run a (long) computation that (until recently) was eating up all available RAM, and I want to walk away from my computer and not come back to it deadlocked
07:04:50 <sm> experiment to be sure
07:09:44 <prsteele> well it's a bit of a moot point for me now, since I'm now running on O(1) memory
07:12:30 <EvanR> my too, where O(1) = 4G
07:13:01 <prsteele> heh
07:13:40 <prsteele> turns out WriterT was leaking -- I was defining mappend to just choose the better of each alternative, but apparently that was building up thunks. Switched to StateT and just put the better of two answers
07:14:43 <prsteele> hm, can you use things like pmap inside of the State monad (or more generally in any monad) in a reasonable fashion?
07:15:36 <prsteele> I know I could spin up new state monads for each thread and re-assemble them, but that seems tedious and maybe a large bit of overhead
07:27:53 * hackagebot errors 2.1.2 - Simplified error-handling  https://hackage.haskell.org/package/errors-2.1.2 (GabrielGonzalez)
07:35:39 <andromeda-galaxy> geekosaur: http://pastebin.com/M3vK9XSS (lpaste was down)
07:40:48 <troydm> is there a way to see on hackage which other hackage packages use the package I'm interest in ?
07:41:35 <andromeda-galaxy> troydm: http://packdeps.haskellers.com/reverse is the best that I know of
07:43:16 <troydm> andromeda-galaxy: thx
07:43:23 <andromeda-galaxy> troydm: np
07:43:27 <Guest47863> can guards be used in a where ? like where z |guard a = 1 | guard b =2
07:49:14 <Martiini> sorry for trolling.. but .. what's programming language and why are there so many and why haskell 
07:50:40 <frerich> Martiini: For much the same reason as why there are many different spoken languages. Different languages have different vocabularies and are often differently well-suited to express certain things. For instance, the language of the Inuit is great for talking about winter (I think they have like 20 different words for snow or so).
07:51:00 <frerich> Martiini: Maybe you'd rather use French for a love letter and German for a declaration of war. Instead of doing it the other way round. ;-)
07:51:36 <frerich> Martiini: In the same vein, expressing the same text is often easier or more difficult and awkward depending on the programming language you use.
07:52:19 <Martiini> true, but computer programming is different than human language
07:52:43 <Martiini> yes, efficiency is the key, so, is haskell more efficient than C
07:52:59 <frerich> Martiini: Efficiency is not always (or not even often) the key.
07:53:38 <frerich> Martiini: If that was true, then there would probably be a single best language. However, the programs you express using a programming language are not only consumed by a computer, but *also* by other humans -- including your future self, when you revise code you wrote in the past.
07:53:41 <Martiini> true
07:54:06 <EvanR> there are so many because its not that hard to create one, and there is no existing one which is obviously perfect
07:54:12 <EvanR> progress in language research continues
07:54:45 <EvanR> in fact for any programming language you name there will be a ton of problems
07:55:29 <Martiini> .. so it's impossible to create a "perfect" programming language
07:55:46 <EvanR> everyone bitches about langauges, so the obvious resulting behavior is to make a new one
07:55:58 <Martiini> what about low level machine code .. like assembly .. etc
07:55:59 <EvanR> hopefully one that doesnt just rename existing ideas (looking at ruby)
07:56:09 <Martiini> I see
07:56:51 <frerich> Martiini: It's actually fairly hard to tell whether some language (think of spoken languages!) is 'better' than another. What's certainly true is that a language shapes the way you think about a problem since it gives you a somewhat fixed set of words to use for expressing your thoughts.
07:56:54 <S11001001> Martiini: it might be possible to create a perfect programming language.  But if it is, no one has figured out how to do it yet.
07:57:04 <EvanR> perfect general purpose language?
07:57:07 <frerich> Martiini: And depending on those words, you may end up expressing the same thing in different ways.
07:57:33 <EvanR> DSLs can be perfect in their specific domain ;)
07:57:55 * hackagebot relational-query 0.8.0.3 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.0.3 (KeiHibino)
07:58:16 <frerich> Martiini: For this reason it's often enriching to know multiple languages (both in terms of programming but also in human languages). It makes you think "Oh, there's a really nice and concise and catchy way to express this in language X"
07:58:56 <frerich> Martiini: Think "raison d'etre" or "Zeitgeist" or "sh*t hits the fan" or "bonmot". :-)
07:59:21 <frerich> I think they are nice examples of how to say a lot without actually talking much.
07:59:44 <EvanR> natural languages are bad inspiration for computer languages though
07:59:46 <Jinxit> butterly, mariposa, papillon, fjäril... schmetterlinge
08:00:31 <Martiini> lolz maybe some type of Artificial Intelligence can create new computers and programming languages .. so it can spread further .. and then .. build immortal robots that will colonize other galaxies and use the stars as energy source  
08:06:24 <int-index> Martiini, we all praise Haskell for Haskell is the perfect language without a single con, amen
08:06:37 <int-index> Now let's write some lambdas.
08:07:21 <Martiini> nice
08:09:09 <EvanR> > let con = con in con
08:09:13 <lambdabot>  mueval-core: Time limit exceeded
08:09:53 <t0by> the bit about artificial intelligence and immortal robots kind of made me cringe.
08:10:40 <Martiini> some hollywood films are good
08:10:55 <Martiini> sci-fi films
08:13:44 <Martiini> I once read some paragraph from Linus Torvald's text about how he descovered intel x86 and it was like computing on drugs for him etc (or something like that) 
08:17:52 <EvanR> if you have nothing haskell to talk about, try #haskell-blah and let this channel return to silence
08:20:18 <prsteele> what are the right options to set in a cabal file to enable optimization?
08:20:33 <dcoutts> prsteele: you don't need to, -O is the default
08:21:12 <prsteele> dcoutts: okay. But if I wanted -O2?
08:21:34 <prsteele> I tried ghc-options: -O2, but that doesn't seem to increase compile time (which the guide suggests it would)
08:22:09 <Ankhers> prsteele: I don't think it increases compile time. I believe it only increases run time.
08:22:28 <dcoutts> prsteele: ok, if you checked that it's making a useful improvement then use it. You've got the right syntax.
08:22:38 <prsteele> thanks
08:22:59 <dcoutts> prsteele: alternatively, you can set it when building the package
08:24:50 <Ankhers> prsteele: Sorry, I misunderstood what you said. It may increase compile time. But it should also make your application faster.
08:25:53 <dcoutts> Ankhers: it *might*
08:26:08 <dcoutts> that is, might make your application faster
08:26:48 <Ankhers> dcoutts: Yes. I'm apparently bad at explaining things today.
08:45:46 <ohad> Running on Mint (in VBOX) cabal install fails - complains about glib with some haskell syntax error. Is this a good place to look for help?
08:48:08 <Ankhers> ohad: I don't see why not. Can you paste the error you are getting?
08:51:01 <ohad> http://lpaste.net/151586
08:52:34 <Kaidelong> are you on win64
08:53:05 <Kaidelong> no, okay
08:53:39 <Kaidelong> (all I would have told you anyway is "just give up, it's completely broken and won't build"
08:56:19 <ohad> But on Linux it's working?
08:56:59 <ohad> I started up trying to install plot
08:57:16 <Kaidelong> oh you are on win64?
08:57:28 <ohad> No, Linux Mint
08:57:29 <Kaidelong> your IRC client says you are on linux
08:57:31 <Kaidelong> okay
08:58:26 <Welkin> or as RMS says, "luhnucks"
08:58:49 <CaptainLex> I think RMS says GNU/Luhnucks ;)
08:59:00 <Welkin> Gnu+Linux
08:59:15 <ohad> RMS?
08:59:21 <Welkin> Root Mean Square
08:59:25 <Kaidelong> I am guessing the type errors are almost certainly because of the fact that gtk2hs sets up its C interfaces with a bunch of template metaprogramming and it has gotten some stuff wrong
08:59:32 <Welkin> did you even take circuits in college?
08:59:32 <ksj> ohad, read my sign
08:59:42 <Kaidelong> what you can do about this, I have no idea
08:59:49 <Kaidelong> did you install gtk2hs-buildtools?
09:00:03 <CaptainLex> ohad: Richard Stallman of the Free Software Foundation
09:00:17 <Kaidelong> you might have forgotten that given that your goal was to install plot, not gtk2hs
09:00:40 <Kaidelong> but IIRC you have to install pango and cairo, so you need to install gtk2hs-buildtools
09:01:05 <ohad> yes I installed gtk2hs-buildtools
09:01:16 <ohad> ksj: what?
09:01:52 <ksj> ohad, I'm just joking :) CaptainLex already answered what rms meant
09:02:39 <ohad> sorry guys, I'm really slow
09:08:33 <bryanvick> Anyone know of a mathematical model in the area of: "tracking changes", or diffs, or append-only editing etc.  I want to "snapshot" some records in a DB and allow mutations to be "overlaid" on this snapshot.  before I worry about implementation in the DB, I want a clear model.
09:14:30 <bitonic> bryanvick: well, there's patch theory...
09:25:27 <silver> bryanvick, http://arxiv.org/abs/1311.3903 , https://www.cs.cmu.edu/~rwh/papers/htpt/paper.pdf https://en.wikibooks.org/wiki/Understanding_Darcs/Patch_theory http://darcs.net/Theory
09:25:30 <silver> etc. etc. 
09:25:59 <bryanvick> thanks silver and bitonic, I'll look into it
09:26:56 <silver> sorry for unfriendly links, I don't know the topic, so basically conducting buzz words for it
09:27:42 <silver> darcs is actual dcvs though
09:37:58 * hackagebot success 0.2.5.1 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.5.1 (NikitaVolkov)
09:41:41 <Guest47863> can you define a range tipe like Ada's "type T is range 1..10" 
09:41:42 <Guest47863> ?
09:42:58 <geekosaur> no
09:45:49 <Guest47863> geekosaur: so you should guard in every function where you want to enfirce a range on a parameter ? Is it idiomatic ?
09:48:22 <Ankhers> does anyone have an example using csv-conduit to read the input and place each of the records into a database using either persistent or esqueleto?
09:49:23 <geekosaur> Haskell doesn't support subtypes. Various people have been using type level programming to get around this, but the usual way is to check with guards or etc. when needed
09:49:41 * geekosaur juggling calls...
09:50:16 <crough> geekosaur, Guest47863: That said, there is `Data.Nat` which employs some of the type level stuff to do that for you.
09:51:23 <Guest47863> thx
09:51:56 <crough> Guest47863 -- I wouldn't use it until you're more familiar with haskell, though. It's *not* beginner level :)
09:52:36 <Guest47863> Im only wirrting toys as for now
09:52:48 <Guest47863> so at worst, ill catch my ears :P
10:07:28 <supernullset> Is anyone available to help with a build error that I am having? I am using stack; the details to the issue I am having is here: https://gist.github.com/supernullset/8e5b29b1c34c28c6c28d
10:11:35 <kadoban> supernullset: What's the type of 'main' in all of those modules? Is it really just some number type or whatever?
10:11:42 <supernullset> yep!
10:12:05 <supernullset> Its mostly just ints
10:12:48 <kadoban> supernullset: Shouldn't be causing the problem, but next time maybe don't do that, it's kind of confusing to people beacuse 'main' is *really* ingrained as the … main IO action of an executable, which is always type :: IO () .  Probably not worth changing, just thought I should point that out.
10:12:59 <kadoban> supernullset: What's in the .cabal file for this package?
10:13:15 <supernullset> Oh for sure, there are a few things in here that need some <3. Thanks for the thought
10:13:21 <supernullset> Ill add the cabal to the gist, please hold
10:14:49 <supernullset> updated, ANNNNND I just relised my problem
10:14:56 <supernullset> Im not exposing the module
10:15:03 <supernullset> I am not a clever man -_-
10:16:11 <kadoban> supernullset: Ah hehe, yeah that was my guess. Hopefully that fixes it. It's unfortunate that there's not a better error for that though.
10:16:15 <supernullset> kadoban: thank you for asking the right questions! Much obliged for the extra brain
10:16:24 <supernullset> it sure does fix it
10:16:25 <nitrix> Is there a command to just typecheck the program without compiling it?
10:16:26 <monochrom> the most popular and undesirable one-off names: test, main
10:16:28 <nitrix> (I'm using stack)
10:16:30 <kadoban> supernullset: Yeah glad to help
10:16:33 <nitrix> Some sort of `stack check` ?
10:18:31 <kadoban> nitrix: I don't think so, unless maybe you can pass some GHC option you can pass that'll do that via --ghc-options ?
10:19:06 <nitrix> I'm on windows where there's a GHCI bug with TemplateHaskell
10:19:11 <nitrix> And I can't use the repl.
10:19:30 <nitrix> So I have to compile the application everytime, just to see if there's a type error, it's annoying.
10:19:48 <geekosaur> -fno-code
10:19:53 <geekosaur> (ghc)
10:19:58 <nitrix> Of course, that's only when I'm at work, I mean, I'm normally on linux, but it's sadens me :(
10:20:04 <nitrix> geekosaur: Awesome :P
10:22:15 <adas> i know this question is very general but I don't know how else to phrase it. What kind of mindset do you have to go in with when writing a library? because I've noticed that writing a stand alone binary and a library are slightly different
10:27:01 <sm> as a library author, you're concerned about your API for one thing
10:27:51 <adas> yup. and also using the right abstractions
10:27:55 <adas> I think
10:28:00 * hackagebot rebase 0.2.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.2.3 (NikitaVolkov)
10:28:02 <sm> you're also concerned about GHC and dependency compatibility; some applications are too, but others maybe less so
10:29:12 <geekosaur> nitrix, one warning, if you were thinking that would save time over compiling, it won't. typechecking's the expensive part
10:29:48 <nitrix> geekosaur: noted
10:31:29 <kadoban> nitrix: One stack feature that … might make it more pleasant: 'stack build --file-watch', which will automatically start rebuilding as soon as you change any files in the project. I usually have that going in another terminal pane so I can switch to it when I care and get the errors right away.
10:32:11 <Welkin> kadoban: haha really?
10:32:14 <nitrix> kadoban: o: !
10:32:18 <Welkin> that is good
10:32:23 <Welkin> I am usually running yesod though
10:32:28 <Welkin> so I already have yesod devel
10:32:37 <Welkin> or in hakyll I have `watch`
10:32:51 <Welkin> I bet snoyman just ported over that feature from yesod devel
10:33:19 <Sornaensis> does anyone here use yi
10:33:34 <nitrix> kadoban: Works like a charm :3 Micro optimisations!
10:33:40 <kadoban> nitrix: Yay :)
10:34:21 <kadoban> Welkin: Heh, yeah I used to use hakyll's watch a long time ago, and missed it when I wasn't doing hakyll stuff.
10:34:58 <sm> that hakyll feature is awesome, I wish it was reliable
10:35:17 <ggVGc> Welkin, nitrix, here's a general purpose solution for what you were talking about, http://entrproject.org/
10:36:23 <mchall> Can someone give me some clues as to how I implement allCombs :: (a -> b -> c) -> [a] -> [b] -> [c] in terms of combStep :: [a -> b] -> [a] -> [b]
10:36:26 <kadoban> ggVGc: The bonus of using a domain-specific one like these would be that 'stack' already knows what files it actually needs to care about, entr would need to be told that somehow, if you even can.
10:36:48 <ggVGc> kadoban: uhm, I do ls **/*.hs | entr
10:37:09 <ggVGc> kadoban: or you could use your vcs to spit out all files under version control
10:37:12 <ggVGc> lots of ways
10:37:16 <kadoban> ggVGc: There's more than that though, .stack .cabal, probably others. Though yeah it's probably not *too* complicated in most projects
10:37:36 <kadoban> stack.yaml I meant instead of .stack
10:38:35 <ggVGc> kadoban: is your stack and cabal files not under version control?
10:38:43 <ggVGc> are*
10:39:01 <ggVGc> kadoban: oterwise ls **/* | entr
10:39:32 <nitrix> Question, would it defeat the purpose to have a StateT on the IO monad?
10:39:46 <nitrix> (Never tried, maybe it isn't possible)
10:39:59 <joehillen> nitrix: No, very common
10:40:30 <nitrix> It's a game. I want to maintain the state, but I still have plenty of IO rendering to do.
10:40:51 <nitrix> I'm trying my best to separate the two but it's hard to go in the right direction before having something "work" first.
10:40:59 <joehillen> I see no problem with that
10:41:09 <ggVGc> seems like an abuse of the state monad
10:41:21 <ggVGc> do you just want to get at do notation?
10:41:26 <ggVGc> pretty sure that's an anit pattern
10:41:28 <nitrix> I think I'll try to accumulate a list of things to be rendered.
10:41:28 <ggVGc> anti*
10:41:38 <nitrix> And let the mainLoop (which is in IO) do the rendering.
10:41:49 <rod_> i have a problem with http io in StateT IO monad
10:42:23 <ggVGc> nitrix: the common way is to have your update functions take models and return new copies with modifications, and have your rendering just rander the current state
10:42:43 <ggVGc> why do you need a state monad during the rendering?
10:42:47 <nitrix> ggVGc: Right. Except I'm going with lazy rendering (only the things that have changed).
10:43:06 <ggVGc> nitrix: why does that matter? you diff two models during rendering
10:43:10 <ggVGc> still no state
10:43:15 <joehillen> ggVGc: It's not an anti-pattern. It's a very common use case https://github.com/search?type=Code&q=statet%20io%20language%3Ahaskell
10:43:20 <ggVGc> ah, okay
10:43:40 <glguy> If Cale was awake he'd argue against doing it (again) :)
10:44:02 <joehillen> glguy: what is his argument?
10:44:05 <ggVGc> joehillen: sorry, what does this have to do with using state monad for rendering?
10:44:20 <rod_> why is Network.HTTP doing requests only when program terminates ?
10:44:28 <ggVGc> joehillen: I meant that using the state monad to get access to do notation is an anti pattern
10:44:44 <glguy> joehillen: I don't remember his exact position, but it's the case that it makes code more awkward to write and less efficient to run
10:44:56 <glguy> things need to be lifted and IORefs exist already
10:45:38 <nitrix> glguy: I could use IORefs... but really?
10:46:07 <nitrix> You're making me doubt about State now :/
10:46:38 <joehillen> nitrix: try both, and see which you prefer
10:46:55 <nitrix> gameHandleEvent :: Event -> State GameState Bool
10:47:08 <rod_> might liftIO in liftIO $ simpleHTTP (request uri)  distract from actually doing the request immediatly
10:47:19 <nitrix> Which takes an event, changes the game state accordingly and yields a bool if the game should keep running or exit.
10:47:32 <dedgrant> mchall: How would you implement allCombs and combStep individually?
10:47:42 <dedgrant> mchall: May help?
10:47:45 <nitrix> I kinda like that the type is expressive there. Otherwise, that's IO Bool, not so great.
10:48:00 <joehillen> nitrix: ++
10:48:14 <glguy> nitrix: The point is against STateT on IO, not pure values in general
10:48:20 <glguy> so State GameState Bool isn't relevent
10:48:25 <nitrix> gameHandleNetwork :: IO () ...
10:48:33 <nitrix> Everything will just turn into IOs lol :P
10:48:41 <nitrix> glguy: Oh I see.
10:48:43 <Sornaensis> IO contaminates all
10:49:20 <mchall> dedgrant sorry I implemented combStep flst lst  = zipWith  (\f l -> f l) flst lst    like so I'm not sure how to use it to implement my new version of allCombs
10:49:59 <mchall> my old version of allCombs is allCombs3 f (x:xs) lst2@(y:ys) lst3  = map (\z -> f x y z ) lst3  ++  allCombs3 f [x] ys lst3  ++ allCombs3 f xs lst2  lst3
10:50:50 <mchall> these functions are part of the monad challenge using a custom prelude
10:50:56 <Gurkenglas> StateT IO ++
10:51:17 <Gurkenglas> Why should it be less efficient?
10:55:44 <lisbeth> can I point stack exec to a specific filepath?
10:56:15 <Gurkenglas> :t \f as -> (undefined :: [a -> b] -> [a] -> [b]) $ map f as -- mchall
10:56:17 <lambdabot> (a1 -> a -> b) -> [a1] -> [a] -> [b]
10:56:38 <Ankhers> lisbeth: Yes. stack exec will execute the program within context of the stack environment.
10:56:46 <nitrix> Is there a traceM equivalent that uses stdout?
10:56:52 <EvanR> ReaderT IO ++
10:57:19 <lisbeth> Ankhlers: how can I stack build sucht aht the result is within the context of the stack environment?
10:57:51 <Gurkenglas> :t liftIO . Debug.Trace.traceIO -- nitrix?
10:57:52 <lambdabot> MonadIO m => String -> m ()
10:58:16 <Gurkenglas> Oh this'd still be stderr right
10:58:22 <joehillen> lisbeth: stack build does it automatically
10:58:34 <joehillen> lisbeth: stack build && stack exec foo-exe
10:58:34 <Ankhers> lisbeth: What is your use case?
10:58:39 <nitrix> Gurkenglas: Unfortunatly, it isn't a MonadIO.
10:58:39 <Gurkenglas> Wait wait wait. Why would you ever want to do standard output using trace?
10:59:00 <lisbeth> stack exec turtle-exe
10:59:12 <Ankhers> lisbeth: Does that not work already?
10:59:12 <nitrix> Gurkenglas: Because Haskell support on windows is terrible and stderr is also broken for GUI applications.
10:59:24 <lisbeth> no
10:59:33 <lisbeth> I think there is something wrong with my stack path
10:59:47 <Gurkenglas> nitrix, hmm redirect stderr to stdout?
10:59:57 <joehillen> lisbeth: past your turtle.cabal
11:00:01 <nitrix> Gurkenglas: How o: ?
11:00:02 <Ankhers> lisbeth: Is this an application you created, or something you found and want to use?
11:00:12 <lisbeth> joehillen: where is the location of my turtle.cabal?
11:00:26 <joehillen> ls
11:00:42 <lisbeth> This is a package from hackage. I installed it in /foo/turtle.<version>
11:01:08 <lisbeth> I ran:
11:01:23 <Ankhers> lisbeth: You should just be able to do `stack build turtle` from anywhere. You didn't need to download the package.
11:01:29 <lisbeth> stack unpack turtle; cd turtle.<version>; stack init; stack setup; stack build
11:01:37 <lisbeth> interesting
11:02:33 <Ankhers> Or, you can `stack install turtle` if you want it to copy the binaries to ~/.local/bin
11:02:42 <joehillen> lisbeth: turtle isn't an application. it's a library https://github.com/Gabriel439/Haskell-Turtle-Library/blob/master/turtle.cabal#L46
11:03:33 <kadoban> lisbeth: Are you attempting to use the turtle library in something else?
11:03:34 <Gurkenglas> :t void $ System.Process.runProcess ?cmd ?args Nothing Nothing Nothing Nothing (Just System.IO.stdout) -- nitrix. I have no idea about any of this but this sounds like it makes sense right
11:03:35 <lambdabot> (?args::[String], ?cmd::FilePath) => IO ()
11:03:57 <lisbeth> okay the correc tcommand was "stack ghci turtle" from the github page's readme
11:04:00 <jasonkuhrt> Addition and Multiplication are monoids correct?
11:04:20 <liste> jasonkuhrt: Sum and Product in Haskell
11:04:41 <Ankhers> lisbeth: Yes. That is because, as others have said, turtle is a library, not an executable.
11:04:42 <liste> > getSum (Sum 4 <> Sum 7 <> Sum 12)
11:04:44 <lambdabot>  23
11:04:46 <lisbeth> :set -XOverloadedStrings
11:04:46 <jasonkuhrt> liste: Hm, I haven't encountered that yet, so something other than (+) and (*)
11:04:55 <Gurkenglas> > ala Sum foldMap [4,7,12]
11:04:58 <lambdabot>  23
11:05:19 <joehillen> lisbeth: read this more carefully https://hackage.haskell.org/package/turtle-1.2.5/docs/Turtle-Tutorial.html
11:06:32 <liste> jasonkuhrt: Sum and Product are newtype wrappers over numbers that have Monoid instances
11:06:35 <lisbeth> it's okay< i have it working now
11:07:06 <liste> so they realize the (0, (+)) and (1, (*)) monoids
11:07:07 <jasonkuhrt> liste: I see `sum` and `product` functions but not types, do I have to import them?
11:07:39 <geekosaur> Data.Monoid
11:07:45 <jasonkuhrt> Ah thanks
11:08:23 <Gurkenglas> Would be nice if lambdabot had a command that lets you read the current L.hs
11:09:03 <Gurkenglas> Although how would it work? It couldn't be IO String because lambdabot doesnt allow you to run those, it couldn't be the string returned by a @ command because those are capped in size
11:09:41 <jasonkuhrt> liste, geekosaur: Thanks
11:09:57 <kadoban> Gurkenglas: It could probably throw it on a pastebin site somewhere, or a dedicated webpage or something.
11:09:59 <Gurkenglas> Maybe something like @fillWithLhs asd10 that would assign a string of the current L.hs to asd10 in the namespace
11:10:04 <geekosaur> Gurkenglas, in another channel I'm in something like that the bot would send to pastie
11:10:51 <jasonkuhrt> liste, geekosaur: I would be curious to see the use-cases and benefits of wrapping up the domain of additiona and the domain of multiplication into their own types
11:11:09 <geekosaur> there's no benefit, it's a hackaround
11:11:24 <jasonkuhrt> Clearly `mappend 5 5` would not make sense because its ambiguous if 5 is supposed to be the world of summation or productization
11:11:27 <geekosaur> you can have only one instance of a given Haskel typeclass per type
11:11:55 <Gurkenglas> Oh, of course, you can make it CPS
11:12:05 <geekosaur> so at least one of them *must* be wrapped in a newtype. since there is no sensible way to say that either of them deserves to be the non-wrapped one, both are wrapped
11:12:43 <Gurkenglas>  @runOnSource find (isInfixOf "Sum") . lines -- gives you the module that lambdabot imports Sum from
11:13:04 <geekosaur> @index Sum
11:13:05 <lambdabot> Data.Monoid, Data.Functor.Sum
11:13:11 <geekosaur> you're overthinking it :p
11:13:35 <geekosaur> (granted, @index doesn't query L.hs)
11:16:55 <econometrician> @help
11:16:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:18:00 <Gurkenglas> Who wrote @run?
11:19:25 <econometrician> preflex: list
11:20:27 <geekosaur> -- Copyright (c) 2004-6 Donald Bruce Stewart - http://www.cse.unsw.edu.au/~dons
11:35:50 <radens> I have something like: let a x = case x of { (isDigit x) -> 1 }
11:36:13 <radens> and when I call it with a 'a' I expect it to say no pattern was matched, but I just get 1
11:36:23 <radens> What am I doing wrong in my guard?
11:36:47 <geekosaur> that guard shouldn't even compile as you wrote it
11:36:56 <radens> oh whoops
11:37:02 <radens> this: let a x = case x of { isDigit -> 1 }
11:37:13 <geekosaur> you created a new local binding named isDigit
11:37:27 <geekosaur> nothing is tested since the binding matches any value
11:37:44 <radens> that's unfortunate. How do I switch on a value of x which is a digit?
11:37:51 <geekosaur> let a x | isDigit x = ...
11:38:44 <radens> brilliant, thank you.
11:48:15 <Guest63708> Hello ladies and gentlemen! Does anyone know how to make haskell understand that userpwdSeparator is Element s and not Element (URL s)? see error message at the bottom of the apge  
11:48:19 <Guest63708> page *
11:49:29 <mauke> ???
11:49:55 <geekosaur> ...bottom of what page?
11:50:01 <csd_> how do i prove for f :: t -> s -> s and a :: s that foldr f a xs == foldr (o) id (fmap f xs) a ?
11:50:30 <csd_> that o should have been a period
11:51:35 <Guest63708> mallocthis: whooops! Here! http://lpaste.net/151610
11:52:01 <phadej> csd_: by induction on xs
11:53:00 <phadej> if xs = [], foldr f a xs = a, foldr . id (fmap f xs) a = foldr id [] a = a
11:53:40 <phadej> if the equation holds for xs, then proof it for (x:xs) , foldr f a (x : xs) = f x (foldr a xs) = ...
11:53:54 <EvanR> "every type constructor is a functor in some category"
11:54:06 <geekosaur> Guest63708, what did you intend the `:: Element s` to apply to?
11:54:12 <EvanR> does that make sense?
11:54:31 <geekosaur> :: is not an operator, it is syntax and it extends as far as it can.. .so you have explicitly told it that userpwdSeparator :: Element s
11:55:04 <Guest63708> geekosaur: (Simple.authentication simpleURL) is of type s 
11:55:41 <csd_> phadej: is there an easy algebraic way to prove it?
11:56:00 <phadej> csd_: algebraic?
11:56:05 <hefesto> hi, haskell gurus :) I have a question about deriving Generic. It seems to be needed to serialize my data to json, but I can't seem to do that when i make my data with Persist (from Yessod, i think). Here is an example that works (without Perist) and what I am trying to do (with Persist): https://gist.github.com/hhefesto/27742166607d02168b27
11:56:49 <Guest63708> geekosaur: Seq.indexEx is of type (s -> Element s)
11:56:54 <phadej> csd_: maybe there are some equations for foldr and map, which would make the proof more direct, but they are proven using induction themselves
11:57:07 <phadej> i.e. it's not that difficult to use induction here
11:58:01 <geekosaur> ok, so that error is telling you that what you gave it is indeed (Element s)
11:58:15 <geekosaur> but it expected to see something of type (Element (URL s))
11:58:39 <geekosaur> udrpwdSeparator is not the problem,  it's where the compiler realized that something else isn't matching up
11:59:18 <geekosaur> at least that's what I think I am seeing
11:59:23 <csd_> phadej: i just mean in terms of rearranging the terms to get from equation a to equation b; are you saying that can only be shown inductively?
11:59:46 <geekosaur> if I had to guess, Simple.authentication is not producing the type you think it is
12:00:53 <Guest63708> geekosaur: i wrote that myself its of type s -> Simple.URL s 
12:01:08 <geekosaur> right. so there's where the extra URL comes in
12:01:57 <geekosaur> you are using an Element s to search the Element (URL s) from Simple.authentication
12:02:21 <geekosaur> rather the URL s, which is then trying to do that match
12:03:13 <geekosaur> and the compiler is telling you that your Element s cannot be matched against the Element-s of a URL s
12:03:29 <Guest63708> geekosaur: wait sorry i'm sorry authentication is of type Simple.URL s -> s
12:04:10 <Guest63708> would paste the code but lpastes upload service is down
12:04:24 <geekosaur> in that case you need to doublecheck that it's not getting wrapped in URL twice
12:04:46 <Guest63708> geekosaur: http://lpaste.net/151615 here it is
12:04:46 <geekosaur> because the compiler knows that you have an Element s, but thinks the Seq it's been told to look for is a URL s, not an s
12:05:04 <geekosaur> s/look for/look for it in/
12:05:36 <Guest63708> geekosaur: if you're looking at it, it's some really messy code sorry :/ 
12:08:03 <geekosaur> actually, line 79 and 80 in your original paste are telling you that you have something wrongt hat is not userpwdSeparator
12:08:28 <geekosaur> not to mention that line 85 alredy confirms that the compiler knows it is Element s, not Element (URL s)
12:09:02 <geekosaur> ah. in fact I bet line 92 is telling you the *real* problem
12:09:17 <geekosaur> take a look at the type of fromString. is that actually what you intended?
12:10:28 <Guest63708> geekosaur: from s -> Maybe (URL s) yuuup
12:10:59 <geekosaur>   fromString :: URL s -> Maybe (URL (URL s)) (bound at Smutt/Util/URL/Refined.hs:56:3)
12:11:02 <geekosaur> from your error message
12:12:31 <Guest63708> geekosaur: first of. Thanks for caring! And yes 
12:13:02 <Guest63708> the s gets convertet do a Maybe Simple.URL s at line 58 
12:13:33 <Guest63708> to*
12:16:20 <geekosaur> you mean line 59?
12:16:32 <geekosaur> that removes the Maybe. it doesn't remove either level of URL
12:16:43 <geekosaur> you have a URL (URL s)
12:16:58 <Guest63708>  maybeSimpleUrl = Simple.fromString strIn
12:17:14 <geekosaur> yes, whose type is Maybe (URL (URL s))
12:18:13 <Guest63708> geekosaur: I'm a god damn retard
12:18:30 <Clint> eureka
12:18:57 <Guest63708> Clint: thank you :
12:19:02 <Guest63708> :)*
12:19:31 <Guest63708> geekosaur: Thanks a lot! 
12:21:45 <Guest63708> geekosaur: Now to another question. Where did you get that godlike patience?
12:22:12 <phadej> csd_: maybe there is some equation for foldr f x (map g xs) = ..., but I don't remember it by hard
12:22:15 <phadej> heart
12:23:03 <exio4> @type \f z g -> [foldr f z . map g , foldr (f . g) z]
12:23:04 <lambdabot> (b -> c -> c) -> c -> (a -> b) -> [[a] -> c]
12:28:04 * hackagebot graph-generators 0.1.3.0 - Functions for generating structured or random FGL graphs  https://hackage.haskell.org/package/graph-generators-0.1.3.0 (ulikoehler)
13:02:07 <pikajude> > foldr f z [a,b,c]
13:02:09 <lambdabot>      Ambiguous occurrence ‘f’
13:02:09 <lambdabot>      It could refer to either ‘L.f’,
13:02:09 <lambdabot>                               defined at /tmp/mueval1600515282040332871.hs:194:1
13:02:12 <pikajude> doh
13:02:20 <pikajude> @unlet
13:02:20 <lambdabot>  Define what?
13:02:32 <pikajude> i don't remember how to use lambdabot anymore...
13:02:41 <kadoban> @undef
13:02:41 <lambdabot> Undefined.
13:03:04 <pikajude> oh, that's the one
13:07:05 <danilo2> Hello guys! A small, not so important question here- but why we're using so cluncly naming convension in Haskell? Why do we have MonadState and nod StateMonad ? and so on - the names do not "sound" good in english and sometimes they could be missunderstand. Lets consider "MonadBuilder" it is some Builder's monad or it is a Builder for Monads? 
13:07:42 <zipper>  /j nairobilug
13:08:01 <danilo2> <Writing in hurry without proper interpunction - sorry about tha>
13:08:38 <geekosaur> I would only expect someone to be confused about the latter if they're expecting Java
13:09:08 <geekosaur> and, well, if they're expecting Java, that's the *least* of the problems they're going to have
13:09:26 <monochrom> I think you made a wrong assumption. there is no universal naming convention. every author does their best to name each thing, given their context and background.
13:10:38 <monochrom> an author chose MonadState instead of StateMonad because of a historical context exemplified by "MonadPlus". (indeed, "PlusMonad" would make no sense, if you found out what MonadPlus is.)
13:11:26 <monochrom> however, this is still not a universal convention, because there are other names and libraries for which this context isn't relevant.
13:12:37 <dfeuer> Anyone seen Tekmo around lately?
13:12:46 <monochrom> for example, another author chose "Alternative" rather than "ApplicativeAlt"
13:13:37 <geekosaur> dfeuer, 2016 Jan 24 03:12:18 *	Tekmo has quit (Ping timeout: 252 seconds)
13:14:51 <dfeuer> Thanks,  geekosaur. I think he's the one I want to talk to... his index-core package looks like it might be the right one to try to graft a type-aligned Traversable onto. Not sure.
13:15:05 <monochrom> also consider the sentence "the State monad is an instance of StateMonad". pronounce it in voice, make a voice recording, replay it to yourself. it sounds wrong.
13:15:44 <monochrom> it shows that while MonadState may not be the best choice, StateMonad has to be the worst choice.
13:16:15 <Welkin> wtf is StateMonad?
13:16:16 <monochrom> (clearly, a Java person would think that StateMonadInterface would be the best choice)
13:16:44 <mauke> Stateable
13:16:47 <zd234> suppose I'm writing an editor; one way is to define a "proceeKeystroke :: Key -> EditorState -> EditorState" this basically means that "EditorState" stores the buffer + some internal state machine; ... an alternative approach is some function "runEditor" ... which takes as an input some [KeyStroke] .... and after each KeyStroke, it outputs some EditorState. Now, my qeustion is: ... is ther esome monad which allows me to transform the
13:16:50 <monochrom> Welkin, StateMonad is a suggested name in competition with MonadState
13:17:00 <danilo2> monochrom: maybe something is broken with my english, but I don't think anything is worng with this sentence : ""the State monad is an instance of StateMonad""
13:17:23 <monochrom> have you pronounce it in voice, make a voice recording, replay it to yourself?
13:17:44 <danilo2> in fact using plain english I would tell "the state is an instance of state monad" 
13:17:53 <monochrom> while we're at it, close your eyes when replaying the voice recording
13:18:39 <monochrom> no. in "State Int", "the state" is Int. the whole thing "State Int" is not the state, it's the state monad.
13:18:44 <danilo2> monochrom: but the sentence is incorrect, it should be "the State <ie. the datatype> is an instance of state monad"
13:18:58 <danilo2> I cannot do recordign right now, seriosly, but I was saying it to myself
13:20:00 <monochrom> I get to say "the State monad" because State is a monad. other examples include "the Cont monad", "the IO monad".
13:20:20 <monochrom> you can't tell me to not say "the IO monad".
13:20:49 <danilo2> hmm, ok, I see what youre saying, but I'm not convinved (and I will not be), but thank you for the clarification. Still I'm feeling pretty bad there is no perfect universal solution
13:21:00 <danilo2> monochrom: I can!
13:21:16 <danilo2> monochrom: don't say "the IO monad!"
13:21:18 <danilo2> D
13:21:18 <geekosaur> come up with a language that isn't linear
13:21:19 <danilo2> :D
13:21:42 <danilo2> just joking of course :) 
13:22:19 <monochrom> the problem is that the substrings "State monad" and "StateMonad" have exactly equal pronounciation. nothing in voice preserves the difference in spacing and tokenization.
13:22:59 <monochrom> and yet they are semantically different. one is an implementation, another is an interface
13:23:38 <danilo2> I completely get it. Still looking at the code (we read the code in most cases though) if I see BuilderMonad m =? it is just clear, while MonadBuilder m => ... is confusing
13:23:59 <monochrom> that's just you. I think the opposite.
13:24:23 <monochrom> no, not the exact opposite. I find both equally clear or equally unclear.
13:24:58 <monochrom> and I am not just deciding this right now for the sake of disagreeing. I truly think that even before this began.
13:25:16 <lisbeth> test
13:25:44 <montanonic> SrPx: oh, oops, wow; sorry that was from last night. 
13:25:59 <danilo2> monochrom: I have to rethink it once again
13:26:06 <danilo2> anyway thank you for the conversation! :)
13:26:06 <SrPx> montanonic: hm? hi?
13:26:09 <Gurkenglas> It's MonadState s m and not MonadState m s so MonadState s can have an instance of the hypothetical "MonadConstraint :: ((* -> *) -> Constraint) -> Constraint" right?
13:26:46 <SrPx> what was last night?
13:26:49 <montanonic> SrPx: you were asking about Haskell in your company. I just opened IRC and your comment was the last one, but I didn't realize it was from ~10 hours ago
13:26:59 <danilo2> Gurkenglas: no, its so becaue it can be monad transformer this way :)
13:27:22 <montanonic> SrPx: (last night in my timezone, at least)
13:27:27 <SrPx> but you didn't say anything about it
13:28:19 <montanonic> SrPx: oh, maybe my message didn't send. I got disconnected seconds after.
13:28:26 <Gurkenglas> danilo2, MonadState, not StateT. Although it probably makes sense too to keep the parameters in the same order.
13:28:28 <SrPx> probably
13:28:29 <SrPx> let me know
13:28:34 <montanonic> SrPx: Anyways, did you get the feedback you were looking for?
13:29:22 <SrPx> yep ~ I still really, really wish we had a programming language that compiled to readable javascript. my javascript code is basically haskell anyway, with type annotations on comments and json simulating adts
13:30:01 <SrPx> people think it is an awful idea for reasons I do not agree/understand, but I really like we had something like a subset of haskell with just functions and adts that compiled to readable js
13:30:31 <SrPx> I'm sure my coworkers would be completely fine with that, as they are fine with my js
13:30:39 <SrPx> but they would not be not ok with haskell itself
13:30:44 <montanonic> SrPx: Ah, interesting. Are you familiar with https://github.com/fantasyland/fantasy-land ?
13:30:54 <montanonic> SrPx: https://github.com/fantasyland/fantasy-combinators/
13:32:18 <SrPx> never heard of it
13:32:19 <SrPx> cool
13:32:27 <montanonic> People might have already talked about this, but getting your javascript coders to become more comfortable with functional styles seems like a step towards using better languages.
13:33:03 <SrPx> but ehh js
13:33:35 <Welkin> it is just a psychological barrier
13:33:57 <Welkin> they could easily switch to using haskell instead of [language]
13:34:15 <Welkin> but they have been told that OOP is the One True Way for too long
13:34:24 <Welkin> and that Haskell is some esoteric academic language for neckbeards
13:34:44 <montanonic> SrPx: I concur, I'm learning it right now using https://leanpub.com/javascriptallongesix/read which teaches it in a very functional style, and while it's not as horrible of a language as I'd have thought, Haskell is so, so much more productive.
13:35:45 <montanonic> SrPx: I personally am using PureScript to write JavaScript code. It's an excellent language with a great (though small) community and a core, dedicated development team that use it in production at their company, Slamdata.
13:36:07 <BlackCap> How do I ping a ip?
13:36:12 <SrPx> Yep I really like it, I think I could use it but 
13:36:35 <Welkin> montanonic: your company sounds like it has something to do with porn, hookups, or baskeball
13:36:43 <Welkin> basketball*
13:36:50 <montanonic> Welkin: not my company
13:36:54 <Welkin> BlackCap: ping ip.here.
13:39:33 <Gurkenglas> BlackCap, on Windows, press Windows-R, enter cmd, press Enter, enter ping google.de, press enter. You can put an IP adress instead of google.de
13:40:38 <Gurkenglas> For doing it from haskell, I find https://hackage.haskell.org/package/websockets-0.9.3.0/docs/Network-WebSockets.html#sendPing
13:40:40 <montanonic> SrPx: If you have the ability to manage your workers, I think having them start reading through the Haskell Programming book (http://haskellbook.com/) would be one of the simplest ways to get them to not vomit at Haskell. It takes time to gain comfort with the language, but it isn't hard.
13:41:20 <montanonic> Anyways, I hope things work out well for you SrPx.
13:41:21 <SrPx> The Haskell book is turning out to be awesoem :)
13:41:31 <montanonic> Oh yes it is :0
13:41:33 <BlackCap> sendPing from Network.WebSockets requires a Connection, which it seems like I can only get by opening a server and having a client connect
13:41:34 <montanonic> :)
13:41:36 <SrPx> The author gave me access and I love it so far
13:41:40 <SrPx> oh, thanks montanonic 
13:43:05 <isd> Hey all. I'm looking at System.IO, and all of the functions there seem to report errors via exceptions. What I'd really like is something that has a return type like `IO (Either SomeErrorType Handle)`. This has to exist; is there another module somewhere I should be looking at instead?
13:43:06 * hackagebot swagger2 2.0 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.0 (NickolayKudasov)
13:43:39 <monochrom> Gurkenglas: I think the main concern is to be able to write "instance MonadTrans (State s)".
13:44:00 <geekosaur> @hackage spoon
13:44:00 <lambdabot> http://hackage.haskell.org/package/spoon
13:44:09 <geekosaur> isd, ^^
13:44:10 <monochrom> err, "instance MonadTrans (StateT s)"
13:44:20 <Gurkenglas> :t try
13:44:21 <lambdabot> Exception e => IO a -> IO (Either e a)
13:44:26 <lisbeth> Had to go on a little trip to get some clothing
13:44:30 <lisbeth> oops wrong channel
13:44:57 <mutantmell> Hey all, I'm looking at using Criterion for doing a benchmark on some web-service calls, but I don't want to use defaultMain.  Every example I've seen uses defaultMain(With), is there an example that does not use this convenience function?
13:45:21 <Gurkenglas> monochrom, that assumes that the parameters must be in the same order for StateT and MonadState, which is obvious in retrospect.
13:45:51 <Gurkenglas> As in, the correct argument would have been "StateT and MonadState should have it in the same order" :P
13:46:58 <isd> geekosaur: thanks
13:47:19 <monochrom> well, you decide what type classes you want, then they determine how you write your types.
13:47:44 <monochrom> the thing is MonadTrans is a very simple type class that you would want, pretty early on.
13:52:07 <MarcelineVQ> Why does Traversable require Functor and Foldable when its methods require Applicative?
13:52:59 <Gurkenglas> MarcelineVQ, the Applicative is not required of the Traversable but of something else
13:53:04 <monochrom> I think you're conflating two types into one.
13:53:11 <fizruk> MarcelineVQ: every Traversable is Functor and Foldable (see fmapDefault and foldMapDefault)
13:53:51 <monochrom> a typical method of Traversable has type "f1 (f2 a) -> f2 (f1 a)". requirements on f1 are different from requirements on f2.
13:54:06 <fizruk> MarcelineVQ: in the signature of traverse, Applicative is applied to a different type constructor, not the one which is Traversable
13:54:14 <monochrom> two types are involved, therefore two different sets of requirements are involved
13:54:39 <Gurkenglas> Okay folks I think he gets it ^^
13:58:54 <MarcelineVQ> That's helpful but I'm not sure why Foldable is a constraint of Traversable.  Is constraint the wrong way to think of => ?
13:59:17 <monochrom> it is right
13:59:41 <monochrom> there are ways to argue both sides.
13:59:42 <MarcelineVQ> Most of the Traversable instance I've written don't involve using the methods of Foldable at all
13:59:44 <danilo2>  /join haskell-lens
13:59:54 <danilo2> ugh
13:59:55 <danilo2> sorry
14:00:34 <vektor> Hey guys! I'm kinda working on a multiplayer game in haskell right now. Simple prototype stuff mostly. I'm trying to sync up two instances of the application, one as server, one as client. My current Problem is that the server will hang indefinitely as long as there's no client around, and it probably can only handle one client at a time.
14:00:45 <vektor> Here's the code: http://lpaste.net/151623
14:00:49 <monochrom> one side says "I am defining my type and I will only use traverse on it. why must I implement Foldable too?"
14:00:53 <Gurkenglas> MarcelineVQ, any traversable can implement foldMap: https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:foldMapDefault
14:01:10 <vektor> I know the issue is with the server side handleNetworkConnection: It only asks once, and that request is blocking too. Any ways around that?
14:01:31 <monochrom> the other side says "I am writing general code for Foldable and Traversable. why must I say both "Foldable x, Traversable x" all the time?"
14:02:44 <Gurkenglas> Hmm. Why not make any class automatically implement its superclasses with the default implementations if none has been defined?
14:03:11 <monochrom> Haskell was not designed for that.
14:03:46 <Gurkenglas> Why wouldn't you design it for that? Surely there's a better reason than "the proposal hasnt gone through yet"
14:03:54 <MarcelineVQ> I think I've made a mistake in how I think of => that I'm not able to express well. I can see how silly my last statement was now that I've written it out but I'm still not clear about why Foldable and Traversable are so connected
14:04:21 <vlad___> hey does anyone know why cabal would produce a .so with undefined symbols?
14:04:30 <Gurkenglas> MarcelineVQ, do you see why Applicative and Monad are so connected? (Have you been around before they were =>'d?)
14:04:31 <geekosaur> it's the relationship between map and fold[lr]
14:04:40 <MarcelineVQ> yes and no
14:04:40 <monochrom> but see the extension DefaultSignatures
14:04:51 <vlad___> it's causing errors when trying to install a downstream dependency
14:04:54 <MarcelineVQ> sorry that's two answers
14:04:55 <geekosaur> vlad___, most commonly because you forgot to put something in extra-modules
14:05:07 <MarcelineVQ> yes I can see, no I wasn't
14:05:14 <joehillen> https://twitter.com/deech/status/694994441719963649
14:05:29 <joehillen> http://www.halloweentshop.com/products/15965894.png
14:06:10 <MarcelineVQ> monochrom, fizruk, Gurkenglas: I see now thank you
14:06:21 <geekosaur> vlad___, so you have some internal module that you don't export anything from, but your exported modules use it. since it's not exported, you need to list it in extra-modules or downstream consumers will explode at link time
14:06:31 <vlad___> geekosaur: is there some way to get cabal install to fail in that case?
14:06:54 <geekosaur> not easily. it belongs in the linker, but linkers are kinda dumb
14:07:02 <MarcelineVQ> Traversable can encompass Foldable and Functor so they're reasonable implications.
14:07:06 <vlad___> geekosaur: this seems like something cabal/ghc should check for me
14:07:10 <geekosaur> (basically they know how to deal with C, anything else theyr'e a bit fuzzy about)
14:07:32 <glguy> s/extra-modules/other-modules?
14:07:44 <vlad___> geekosaur: shouldn't this be doable just from knowing the dependencies?
14:07:48 * glguy goes off to check
14:07:52 <geekosaur> vlad___, not really, no
14:08:08 <vlad___> geekosaur: I mean, ghc needs to be fed all the dependencies
14:08:22 <geekosaur> but it only needs to be fed them one at a time
14:08:48 <vlad___> geekosaur: well someone should be able to generate the list of dependencies (either cabal or ghc)
14:09:05 <geekosaur> yes, sufficiently intelligent tooling "could" do the linker's job for it. except this causes other problems
14:09:05 <vlad___> geekosaur: and then check that against the exposed/other modules
14:09:15 <geekosaur> (most notably on windows)
14:09:25 <vlad___> geekosaur: this is all before any linking happens though
14:09:29 <geekosaur> no?
14:09:42 <jophish_> What's the reasoning behind template haskell not being executed in some machine independent environment?
14:09:46 <geekosaur> this is the link step to create the .so, not the link step that consumes the .so
14:09:57 <jophish_> Was it just ease of implementation?
14:09:59 <vlad___> geekosaur: so you're saying ghc relies on the linker to figure out what order to compile modules in?
14:10:34 <vlad___> geekosaur: that sounds wrong to me
14:10:41 <geekosaur> no, it does not use the linker for that
14:11:03 <vlad___> geekosaur: well someone is figuring out what stuff to pass to ghc
14:11:09 <geekosaur> I am trying to figure out how to explain this in a way that will make sense to you
14:11:14 <vlad___> geekosaur: someone knows about the module I forgot to expose
14:11:40 <geekosaur> ghc's compile step knows it used the module at some point
14:11:44 <vlad___> geekosaur: I say this because the compilation works
14:12:11 <geekosaur> if ghc *itself* did the linking then there would be no problem
14:12:21 <geekosaur> except that it would fail on windows
14:12:26 <geekosaur> and other odd platforms
14:12:33 <geekosaur> (like ARM)
14:12:37 <vlad___> geekosaur: I don't think linking is relevant here
14:12:46 <geekosaur> generation of a .so is linking
14:12:55 <vlad___> geekosaur: all I want is a tool that tells me that my package depends on modules that I don't expose
14:13:03 <geekosaur> you may not want to think of it as linking, but the linker knows how to create a .so and nothing else does
14:13:25 <geekosaur> and nothing else is going to unless you want it to work on only the platform you are using and never even try to support any other platform
14:13:58 <vlad___> geekosaur: are you saying that the set of modules that my package depends on is platform specific?
14:14:03 <geekosaur> ...
14:14:22 <vlad___> geekosaur: I'm not using any cabal flags that explicitly detect the OS or CPP or anything like that
14:14:24 <geekosaur> here, let me eat a bunch of modules and barf up a platform specific .so/.dll/whatever
14:15:02 <geekosaur> this is not portable
14:15:16 <geekosaur> creating a .so is not something ghc can do on all platforms by magic
14:15:26 <geekosaur> platforms come with linkers that know how to create .so files
14:15:43 <geekosaur> ghc *used* to be in the business of "oh I know how to link". except it didn't on windows or ARM
14:16:17 <geekosaur> jophish_, ease of implementation and that TH has to know something about what it's generating an AST for
14:16:38 <geekosaur> there's some work in progress in making TH more independent (primarily targeting ghcjs)
14:17:44 <geekosaur> vlad___, creating the .so is a separate step and pretty much has to be, the way the platform-supplied toolchains work
14:18:11 <vlad___> geekosaur: I stil don't see why linking details are relevant here. my point is that ghc/cabal can figure out my package's dependency graph, and warn me that I am depending on unexposed modules
14:18:30 <geekosaur> if you do not see then you will not understand
14:18:37 <vlad___> geekosaur: the fact that this averts linking-related problems later is just a bonus
14:19:30 <vlad___> geekosaur: to illustrate my point, I assume that haskell can also run in interpreted mode in which no linker is used
14:19:37 <geekosaur> I am apparetly incapable of explaining this
14:19:43 <geekosaur> it is uisng a linker
14:19:54 <monochrom> I don't think it is productive to argue generally.
14:20:06 <geekosaur> it infamously didn't work reliably on windows and didn't work at all on ARM
14:20:27 <vlad___> geekosaur: really? so when I :load in ghci and it tells me loading module... [interpreted] or whatever it is actually calling the linker?
14:20:29 <geekosaur> because ghci used, until recently, its own built-in linker because it's linking for a bytecode environment
14:20:59 <geekosaur> these days it uses the system linker and dlopen --- which solved one set of problems and introduced others
14:21:02 <monochrom> instead, what is the specific case you are suffering from? how to reproduce it? so that this case can have its tailor-made explanation and solution.
14:21:30 <monochrom> because I really doubt that "an exposed module imports an unexposed module" explains it
14:21:54 <vlad___> monochrom: if I understand it correctly that exactly is the problem
14:21:58 <monochrom> because there are tons of packages on hackage that do that and still work in great harmony
14:22:26 <monochrom> for example bytestring does it. no problem.
14:22:35 <monochrom> for example text does it. no problem. etc etc.
14:22:43 <vlad___> monochrom: I have two local cabal packages, one depending on the other, and I get a failed to load .so missing symbol errors when trying to install
14:23:18 <vlad___> the internet and geekosaur both claim that this is due to failing to export some modules
14:23:24 <monochrom> you have my sympathy but how does a third person reproduce it?
14:23:31 <vlad___> by export I mean listing the module in exposed-modules or other-modules
14:24:31 <geekosaur> so, the real problem here is you can use parts of modules without requiring downstream to know about them, so naively linking in everything that gets referenced in some way will load a lot of unwanted and unneeded junk into downstream users' programs
14:24:36 <geekosaur> (and complicate linking those)
14:24:41 <vlad___> nm -D confirms that the symbol cabal install complains about is indeed missing
14:25:47 <vlad___> geekosaur: so it is acceptable to generate .so's with undefined symbols?
14:25:50 <geekosaur> something (ghc cabal stack whatever) can pretend to be the linker, but this is nonportable enough that it's better to leave to an actual linker --- otherwise you get even weirder errors, and you don't get them in your package, but when someone else tries to use your package. and it's not as simple as missing symbol
14:26:11 <geekosaur> the way .so-s work? yes
14:26:44 <geekosaur> and has to be, because OSes like to do that. Solaris tried to force their .so-s to always have defined symbols, and it meant they needed to maintain special patches to e.g. apache
14:27:07 <geekosaur> (this is something of a long story and I don't think you need to know the ugly details of how symbols get resolved at runtime)
14:27:16 <monochrom> every *.o and *.so are meant to refer to "undefined" symbols. this is the bane of separate compilation.
14:27:29 <vlad___> geekosaur: that sounds like a bad design choice...?
14:27:53 <monochrom> it means that by execution time you should have enough *.o and *.so files to define everything mentioned ever
14:27:55 <geekosaur> it's the least bad of a bunch of terrible possible designs
14:28:04 <vlad___> geekosaur: I see
14:28:06 <geekosaur> the one thing that hasn't been found is a non-bad one
14:28:08 <monochrom> but compile time is not execution time
14:29:33 <vlad___> so how do I make my library usable?
14:29:38 <geekosaur> the design used by ELF shared objects is one such choice. the one used by older AIX / SVR3 / Mach(OS X) is another --- and Apple reworked the latter to be more like ELF over time, as they realized they couldn't fix its flaws.
14:30:39 <vlad___> it sounds like the the state of affairs with shared objects and linking is so bad that cabal/ghc can't protect me from it
14:30:48 <geekosaur> they can try
14:31:05 <vlad___> well they have done a mostly decent job
14:31:14 <geekosaur> the problem is the failure modes when the attempt fails make this situation look pretty
14:32:03 <vlad___> I guess what I was complaining about originally was that my first library cabal installs just fine, it's just that when I try to depend on it things break
14:32:13 <vlad___> which is the same type of error as dynamic typing
14:32:21 <vlad___> or whatever javascript does
14:32:34 <geekosaur> if yu ink everything static you can avoid it. but then your program only works on systems that are just like yours --- in particular you can't use the name service switch, which must be linked shared
14:33:27 <vlad___> geekosaur: is there some cabal switch to do that?
14:34:45 <geekosaur> --disable-shared andor --disable-executable-dynamic
14:35:03 <geekosaur> make sure to ignore the link warning where glibc tells you the result won't work on any other computer
14:36:04 <vlad___> hm I think a possible cause of my problem might be that my first library has a bunch of extra .hs files in the root dir that aren't meant to be part of the library
14:36:28 <vlad___> iirc .hs files in the root of a cabal package have caused me problems before
14:41:12 <vlad___> ah ok cabal repl compiles a bunch of unintended files
14:41:17 <zipper> Hey I noticed that in arch haskell libs are getting stored globally.
14:41:21 <zipper> Like the core libs
14:41:28 <zipper> In an update, why is this happening?
14:41:36 <zipper> It comes with the update of GHC
14:41:51 <zipper> Oh wait
14:42:00 <zipper> I think I should uninstall GHC and use just slack
14:42:13 <zipper> Anyone that knows what's going on?
14:43:43 <Welkin> you mean stack?
14:44:13 <Welkin> zipper: never use ghc or any haskell things from your distro pakcage manager
14:44:23 <Welkin> always install it yourself, or have stack do it
14:44:41 <zipper> Welkin: Yeah this is weird behavious
14:44:45 <zipper> *bahaviour
14:44:52 <Clint> Welkin: pfft
14:45:32 <glguy> touché
14:46:38 <monochrom> use stack. don't use slack. big difference :)
14:47:00 <monochrom> @stack monochrom
14:47:00 <lambdabot> go slap monochrom yourself
14:49:04 <geekosaur> [03 22:43] <Welkin> zipper: never use ghc or any haskell things from your distro pakcage manager
14:49:11 <vlad___> geekosaur: I figured out how to get what I wanted! I just moved the cabal library to its own directory free of extra .hs files, and now cabal install gives me errors about importing missing files
14:49:12 <geekosaur> increasingly a truism for almost any language
14:49:35 <geekosaur> there's a reason perl folks will point you to perlbrew, python to virtualenv, etc.
14:50:05 <geekosaur> (you haven't had "fun" until you've had to help a debian user who upgraded the wrong perl module and broke dpkg/apt)
14:50:07 <mauke> not necessarily perlbrew. local::lib works fine if your distro doesn't fuck up core perl
14:50:21 <mauke> (hi, redhat)
14:52:44 <Welkin> Clint: care to elaborate?
14:53:08 * hackagebot hjsmin 0.1.5.2 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.5.2 (ErikDeCastroLopo)
14:57:19 <Clint> Welkin: i use only haskell things from my distro package manager
14:57:36 <ReinH> Cale: ping
14:57:49 <ReinH> Oh is he not here? o_O
14:58:50 <adas> :q
14:58:56 <adas> oops
15:05:51 <kadoban> Clint: That sounds very limited.
15:06:21 <hefesto> Hi! I am sort of new at Haskell. If I have a function that returns a IO(Maybe User), how can I extract the User (or Maybe User)?
15:07:00 <wedify> hey i'm trying to make Data.StateVar bindings for agda but i get an error i don't understand -> http://lpaste.net/151628
15:07:47 <kadoban> hefesto: In a do block of type :: IO a, you can have something like:    do {theMaybeUser <- theOriginalThing; other stuff}   In "other stuff", theMaybeUser is of type Maybe User
15:07:54 <Clint> kadoban: it works great for me
15:08:16 <Welkin> Clint: I hardly trust my package manager for anything, sadly
15:09:15 <geekosaur> wedify, might ask in #agda? but it looks like you are using typeclasses as if they were types, and agda likes that about as much as haskell does
15:09:26 <hefesto> kadoban: thanks!!!
15:09:45 <geekosaur> there is nothing with type MonadIO a. there are types a that have instances of MonadIO
15:10:05 <danilo2> Hello guys! I would like to store a list of Lenses, but ... how can we do it? I've heard that there is something like ALens, which is Rank-1 and can be storied inside containers but I've also heard it has some runtime overhead - does it? Either way - I need also something like foo :: Functor f => [LensLike' f a b] -> LensLike' f a [b]  but I cannot do it using normal lens combinators, because GHC infers different types for f when im
15:10:12 <wedify> geekosaur: i have asked in #agda. it seemed like it would be good to ask here too
15:10:51 <Clint> Welkin: maybe you need a better operating system
15:10:53 <wedify> geekosaur: do you have a suggestion on how to convert a class constraint into a type?
15:11:00 <vlad___> is there a way to get cabal repl not to recompile everything if I've already cabal installed?
15:11:16 <kadoban> Clint: Until you want to use something in haskell that isn't in your package manager yet?
15:11:17 <wedify> similar to what's done for get, set
15:11:28 <geekosaur> wedify, I could answer that in Haskell, but not Agda
15:11:29 <Clint> kadoban: then i package it and upload it to debian
15:11:41 <Welkin> Clint: I use apt-get and brew (osx)
15:12:03 <Lokathor> so it looks like, if i wanted a FRP Behavior that was based on a real time clock, I'd use (pull :: m a -> Behavior a) where the m a is something like (getCurrentTime :: IO UTCTime)
15:12:19 <kadoban> Clint: Sounds like a lot of work. Isn't debian on like GHC like 7.6 or something in the official package managers too?
15:12:19 <Lokathor> does this seem sensible enough to the FRP gurus out there?
15:12:26 <Clint> kadoban: 7.10
15:12:42 <wedify> geekosaur: a haskell answer would help me a lot
15:12:43 <conal> Lokathor: eep. that looks way off to me.
15:12:50 <geekosaur> in Haskell it means your type is not MonadIO a, but MonadIO a => a
15:13:04 <geekosaur> :t MonadIO
15:13:06 <lambdabot> Not in scope: data constructor ‘MonadIO’
15:13:09 <geekosaur> ah right
15:13:39 <geekosaur> :t Control.Monad.Trans.MonadIO -- not sure it will allow this
15:13:40 <lambdabot>     Not in scope: data constructor ‘Control.Monad.Trans.MonadIO’
15:13:43 <geekosaur> nope
15:13:54 <Lokathor> conal, hmm. let me start over then: what i want is a counter that starts at 0 and then an event will give it a positive delta and it goes up by that delta at all times (possibly with a maximum value)
15:14:06 <geekosaur> wait
15:14:10 <geekosaur> :k Control.Monad.Trans.MonadIO -- not sure it will allow this
15:14:11 <lambdabot> (* -> *) -> Constraint
15:14:12 <Lokathor> and from time to time, the user can also click a button that will deplete the counter by some value
15:14:22 <geekosaur> that's the Constraint that agda is complaining about
15:14:34 <John[Lisbeth]> ["echo
15:14:38 <conal> Lokathor: ... in that (a) it thwarts the simple & precise specification/denotation of FRP, and (b) in FRP you can just say "time", whose denotation is simply the identity function.
15:14:43 <geekosaur> I just made the same mistake you did... things get confused when you mix type and value level >.>
15:15:03 <conal> Lokathor: "all times" in the continuum?
15:15:23 <John[Lisbeth]> ["echo" <> " " <> a <> ";" <> " " | a <- ["Hello," "Goodbye", "Bonjour", "Konnichiwa"]]
15:15:39 <wedify> writing 'data HasMonadIO m = MonadIO m => HasMonadIO m' results in an error about m expecting one more argument
15:15:41 <hunteriam> How can I improve this datatype? Setterls of Catan board
15:15:41 <hunteriam> http://lpaste.net/151629
15:15:57 <Lokathor> well, goes up continually such that it gains, say, +1 per second, but updating the view fractionally more than once per second (perhaps 30fps).
15:16:02 <conal> Lokathor: maybe you're talking not about FRP, which is based on continuous time. http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525
15:16:04 <wedify> if i give it an argument it says it expects two more, and if i give it two more it asks for four more
15:16:58 <conal> Lokathor: in FRP, the meaning has nothing to do with sampling. you'd just say "time", which means \ t -> t. and then it gets sampled whenever it gets sampled.
15:17:01 <ReinH> conal: o/
15:17:10 <conal> ReinH: \o
15:17:22 <geekosaur> data HasMonadIO m a = MonadIO m => HasMonadIO (m a)
15:17:25 <enthropy> wedify: data HasMonadIO m a = MonadIO m => HasMonadIO (m a) -- but having that context is kind of stupid
15:17:35 <geekosaur> and yeh, that does not make a lot of sense
15:17:44 <geekosaur> m is a type constructor, it must be applied to a type
15:18:15 <geekosaur> liewise you can't just say Maybe, it's always Maybe a or Maybe Int or etc.
15:18:39 <conal> Lokathor: when you're thinking in FRP's model, sampling/updating doesn't arise. It's below the level of abstraction. like laziness but more so.
15:19:05 <Lokathor> conal, okay... so if a counter starts at 0 and doesn't start increasing until some event has happened (a "start" button clicked), and then it starts to go up at +1/second, and sometimes another button causes the total to go down by some amount.. would using FRP be approrpaite to this at all? or am i too far off?
15:19:23 <conal> Lokathor: i.e., like destructive thunk updating in the implementation of non-strict languages like haskell.
15:19:46 <hunteriam> Tips on a data type anyone?
15:20:12 <conal> Lokathor: sure FRP is a good fit. I'd first define a behavior for the rate and then integrate it.
15:20:34 <wedify> enthropy: doing that just gets me the error i posted about
15:20:39 <ReinH> hunteriam: I prefer to represent the board as a map from a coordinate to a hex. This sort of representation is difficult to work with in practice.
15:20:46 <conal> Lokathor: the rate is defined over continuous time (like all behaviors) but in this case is a step function .
15:20:55 <Lokathor> conal, eg, what would be a basic outline for a simple "Candy Box" type thing (http://candies.aniwey.net/ if you're not familiar). A candy counter goes up, and you can press a button to eat the candies.
15:20:56 <ReinH> hunteriam: Let me publish this thing I've been working on. One sec.
15:21:03 <hunteriam> ReinH: I also need to access edges and vertices
15:21:22 <conal> Lokathor: try the integral approach. it reduces your question to a simpler one.
15:21:23 <Lokathor> i'm still a little unsure of that's a Event that produces +1s or a Behavior or what
15:21:40 <conal> "If you can't solve a problem, then there's an easier problem you can solve: find it." - George Polya
15:21:58 <ReinH> hunteriam: actually it's similar enough to https://hackage.haskell.org/package/grid that you can just use that.
15:22:07 <Lokathor> well, I suppose that's true
15:22:14 <ReinH> Store edges separately, e.g. Map Coordinate [Edge]
15:22:36 <Lokathor> conal, when you say "integral" do you mean like calculus integrals? or integral like "core"?
15:22:44 <conal> Lokathor: calculus.
15:22:46 <ReinH> or Map Coordinate [Coordinate], depending on how you want to represent things.
15:22:55 <Lokathor> oh boy i never pass that, and i took it 3 times
15:22:59 <Lokathor> passed*
15:23:16 <ReinH> or even Map Coordinate (Map Edge Coordinate)
15:23:54 <conal> Lokathor: being able to use calculus one of the reasons it's so important to use continuous time rather than discrete.
15:24:03 <enthropy> wedify: http://lpaste.net/8645816463027863552 compiles for me
15:24:05 <ReinH> Representing a graph by tying the knot is possible but not very nice to work with in practice
15:24:38 <Lokathor> then perhaps FRP will be beyond me
15:24:38 <ReinH> It's generally easier to use an adjacency list or similar
15:25:37 <conal> Lokathor: see http://conal.net/fran/tutorial.htm, where I use the name "atRate" instead of "integral". it just means the behavior whose (time-varying) rate is a given one.
15:26:29 <conal> Lokathor: you don't have to know any calculus. just roughly what "rate of change" means.
15:27:00 <Lokathor> I'm familiar with the ideas, just never good at executing on the actual formula translations required to pass a test
15:27:21 <hefesto> I wasn't able to take to take the Maybe Users out of IO(Maybe Users). Here is a part of my code: https://gist.github.com/hhefesto/aaf2c1826f395ab32459
15:27:50 <hefesto> that doesn't compile
15:27:55 <Lokathor> conal, are these Fran demos roughly able to be converted into being used with the Reflex and Reflex-Dom haskell libs?
15:27:59 <hefesto> but it gives an idea of what i am ptrying to do
15:28:45 <ReinH> hefesto: you can't take the Maybe Users out of IO (Maybe Users) as there isn't one there to take out.
15:29:08 <kadoban> hefesto: It's a little hard to figure out what's going on there, probably largely because I don't know scotty. What's the error you're getting at least?
15:29:20 <wedify> enthropy: it does for me as well but when agda calls ghc to compile it it gives the error
15:29:42 <glguy> First error is going to be the do-notation ending with a <- binding on line 6
15:29:51 <conal> Lokathor: i don't know. last time i looked, reflex had neither of the two fundamental properties of FRP. (see that stackoverflow answer above and follow its links.)
15:30:14 <hunteriam> anyone know why `grid` is not on stackage?
15:30:19 <Lokathor> oh i thought reflex was a FRP lib :/
15:30:41 <Welkin> lol
15:30:45 <Welkin> here we go again
15:30:52 <Welkin> FRP is a sensitive issue around here
15:31:06 <Welkin> reflex is "FRP-like" let's say
15:31:13 <kadoban> hunteriam: The usual answer is: "because nobody added it yet"
15:31:14 <Welkin> that's all I know
15:31:20 <hunteriam> kadoban: how do you add it?
15:31:26 <conal> Welkin: more accurately, "inspired by FRP".
15:31:32 <luigy> hunteriam you can use extra deps
15:31:41 <Lokathor> all i want is to start with a candy box style demo :/ and then i think i can probably take it from there.
15:32:00 <Lokathor> but conal, i will read your website tutorial, though i don't think i have time to try all of it today
15:32:05 <kadoban> hunteriam: Usually the package author has to do it I believe. If you just want to use the thing, yeah just put it as an extra-dep in your stack.yaml file
15:32:50 <conal> Lokathor: "FRP" has a precise meaning, but over the last few years the term started being used of systems that lack the fundamental properties. mostly by misunderstanding/confusion that spread by imitation.
15:33:35 <Dr4ke63> Hello
15:34:09 <wedify> what does it mean that 'MonadIO xm' has kind GHC.Prim.Constraint
15:34:22 <conal> Lokathor: see also a recent talk I gave on the "Essence and origins of FRP": https://github.com/conal/essence-and-origins-of-frp
15:34:36 <Welkin> lol conal 
15:34:48 <ReinH> Welkin: ?
15:34:52 <Welkin> just like how everything is "Functional Programming" these days if it has map, reduce, and filter
15:35:07 <Lokathor> this is quite the sudden mountain being set before me
15:35:16 <Lokathor> but i will attempt the trek
15:35:23 <maerwald> I wonder, are there any advocates of introducing an effect system to haskell similar to what Idris has? I don't want to believe that we cannot do that. But afais it will certainly require more than just a library.
15:35:24 <hefesto> kadoban: the error is https://gist.github.com/hhefesto/da526ffae00792d06098
15:35:26 <conal> Lokathor: i hope you enjoy the journey!
15:35:36 <conal> Lokathor: feel free to ask questions along the way.
15:35:36 <geekosaur> you survived the dreaded Monad, you can handle this :p
15:35:43 <Welkin> maerwald: Extensible Effects?
15:36:09 <maerwald> I don't even know what they call it, but I am referring to https://eb.host.cs.st-andrews.ac.uk/drafts/eff-tutorial.pdf
15:36:51 <conal> Welkin: exactly. that's why Peter Landin (a founding father of our whole field) deprecated the term "functional programming" way back in 1966. it didn't mean anything clear even then. so he suggested "denotative" as a substantive replacement. See http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-626 .
15:36:52 <Gurkenglas> Would be nice if the ircbrowse search respected type isomorphisms as hoogle does
15:37:26 <kadoban> hefesto: So … you're pretty new to haskell, right? Have you learned the basics or are you kind of starting with a project?
15:37:58 <hefesto> ReinH: If I can't get a Maybe User out of IO(Maybe User), then how can I access database things (IO) from a non IO monad (e.g. ScottyM) 
15:38:41 <wedify> a further clue is that 'liftIO :: HasMonadIO m -> IO a -> m a' works fine
15:38:42 <hefesto> kadoban:  I read Learn you a Haskell a while ago, and now I am trying with a project
15:40:07 <kadoban> hefesto: Ah. LYAH is … not good, IMO. It's more of a "here's some cool stuff about haskell" than something that teaches you haskell. Which is to say: if you get frustrated, I'd recommend reading/going through a more substantative book/course, which people can recommend.
15:40:13 <geekosaur> wedofy, it means that can only be used on the left of =>
15:40:21 <geekosaur> wedify, it means that can only be used on the left of =>
15:40:26 <geekosaur> :k MonadIO
15:40:28 <lambdabot> (* -> *) -> Constraint
15:40:42 <kadoban> hefesto: If you just want the answer, I can try to help you work through what's going wrong here, but I'm not optimistic that I'll actually be teaching you anything useful is the thing.
15:40:44 <Lokathor> hefesto, http://www.seas.upenn.edu/~cis194/spring13/lectures.html if you want problems to work on as a beginner, try here
15:40:51 <geekosaur> it is not a type, it is a constraint that can be applied to a type
15:41:14 <geekosaur> you can think of => as a type level operator that applies constraints
15:41:55 <ReinH> hefesto: because ScottyM is secretly an IO monad.
15:43:53 <Lokathor> the intro of the reactive package on hackage warns of serious bugs :(
15:44:40 <ReinH> hefesto: http://haddock.stackage.org/lts-5.1/scotty-0.10.2/Web-Scotty-Trans.html#v:scottyT
15:45:34 <hefesto> kadoban: sigh. Thanks! will follow the course.
15:46:17 <hefesto> ReinH: Ty. I'll look it up :)
15:46:19 <kadoban> hefesto: Good luck! It's pretty good. http://haskellbook.com/ would be the other option I'd recommend, though it's not free.
15:46:20 <ReinH> Or perhaps more accurately, running a ScottyM action at the top level of your program results in an IO action, which is then executed.
15:47:03 <meditans> so, guys, I remember of an utility that let print a nested value in ghci, by clicking the parts to expand, one at a time
15:47:12 <meditans> anyone recalls something similar?
15:47:20 <CaptainLex> Lokathor: Thanks for that link, I've been looking for something approachable and also hands-on
15:48:49 * hackagebot greplicate 0.0.1 - Generalised replicate functions  https://hackage.haskell.org/package/greplicate-0.0.1 (TonyMorris)
15:48:51 * hackagebot greplicate 0.0.2 - Generalised replicate functions  https://hackage.haskell.org/package/greplicate-0.0.2 (TonyMorris)
15:49:41 <meditans> maybe it was `present` or something, I can find only a library with that name now
15:51:28 <sm> meditans: I'm not finding it either, but wow there are a lot of presentation tools on hackage
15:52:16 <meditans> sm yeah but they mostly are for presentations in the slide sense xD
15:52:34 <jle`> meditans: sprint ?
15:52:38 <sm> pretty-show or data-pprint might be interest
15:52:42 <sm> of interest
15:52:46 <jle`> oh, i see what you mean
15:52:49 <jle`> i remember seeing it online
15:53:09 <meditans> jle`: yeah, there were some videos online, right?
15:53:25 <geekosaur> http://hackage.haskell.org/package/ghc-vis
15:53:27 <meditans> I recall this video in which a list was presenteed
15:53:40 <wedify> geekosaur: if you're curious the problem is i'm binding the classes instead of the proxy types i made
16:01:19 <meditans> sm, thanks, pretty-show is a very good one
16:01:27 <danilo2> hello :) I would be very thankfull if somebody would tell me if ALenses have any performance overhead over simple Lenses - and if yes, where it comes from and how can I not suffer form it when I need to store  list of lenses :)
16:01:37 <meditans> I expecially like to be able to generate the html version
16:04:39 <geekosaur> danilo2, ALenses wrap Lenses in existentials to preserve information. That necessarily entails overhead, and overhead that you cannot avoid without breaking the Lenses
16:04:46 <geekosaur> as I understand it
16:05:00 <sm> meditans: np. Just be aware it requires "happy" in the path if you add it as a dependency
16:05:18 <geekosaur> meditans, did you see the hackage link I posted earlier?
16:05:26 <meditans> sm, I'm mainly using the executable ppsh, for now, but I'll remember
16:05:31 <geekosaur> ghc-vis is probably what you are remembering
16:05:36 <meditans> geekosaur: ghc-vis?
16:05:42 <geekosaur> yes
16:05:49 <meditans> yeah, I was looking at the page now
16:06:45 <meditans> it's surely an impressive tool, I didn't remember the memory layout, but it's nice to know!
16:07:41 <geekosaur> the only other thing that occurs to me is GHood
16:08:01 <geekosaur> but I think it may require instrumenting code
16:08:13 <KaiJia> 东八区的各位菊苣早上好。
16:08:52 <meditans> geekosaur: this package isn't what I saw, but it even better :O
16:09:13 <meditans> exploration of the memory layout of common datastructures will ensue!
16:41:16 <topin212> hello everyone, just yesterday I asked how could you transform(I believe this is the right term) one monad to another, and Gurkenglas suggested this: http://lpaste.net/151634. I just wonder, how your thoughts go while writing this kind of code?
16:42:36 <Gurkenglas> topin212, then someone suggested "toResponse . encode . tuplesToBanks <$> liftIO sqlBanksAsker" which seems better to me
16:43:36 <Gurkenglas> Do you mean us to explain the algorithm we use to refactor code? Good question.
16:43:58 <Gurkenglas> If we could answer it precisely, we wouldn't be doing it manually.
16:44:08 <monochrom> I check and obey types when I write this kind of code.
16:45:59 <topin212> First, I checked the types of that expression, and tried to figure out the "type flow" of it, and why it works, then I tried to replicate it with some simpler things.
16:46:18 <topin212> So, the types are the main rule you use?
16:46:29 <Gurkenglas> Although it is relatively possible to pretty bruteforcefully search the space of well-typed programs for short inhabitants of a type. See the exference project.
16:47:31 <monochrom> types are why I would find that I need liftIO and <$> somewhere
16:47:34 <isd> So a few hours ago I asked about modules that let me use the stuff from System.IO (e.g. openFile) and get Maybe/Either on errors instead of exceptions. I was pointed at the spoon library, but upon investigation found it only does "pureish" exceptions; `fmap teaspoon (openFile "/does/not/exist" ReadMode)` still throws an exception.
16:47:52 <Gurkenglas> :t try -- isd, I suggested this
16:47:54 <lambdabot> Exception e => IO a -> IO (Either e a)
16:59:51 <glguy> isd: You should rarely if ever find yourself using the spoon package
17:00:37 <glguy> fmap teaspoon (openFile "/does/not/exist" ReadMode) -- this would find errors buried within the actual resulting Handle value, not in the process of opening a file and creating that handle
17:01:12 <glguy> 'try' from Control.Exception as mentioned by Gurkenglas is the right answer
17:01:20 <hpc> as a great philosopher once said
17:01:23 <hpc> there is no spoon
17:01:31 <monochrom> haha
17:01:53 <monochrom> and they have a scarcity of forks, too
17:08:16 <KaneTW> i'm currently using a type class with an associated type family to enforce some constraints, but it generates a lot of bloat:  https://github.com/KaneTW/knxd-native-client/blob/master/src/KNXd/Client/Internal/PacketArgs.hs#L80
17:08:27 <KaneTW> does anyone have an idea how to reduce that, apart from writing a bit of TH?
17:11:25 <django_> Lisp is also a functional language right?
17:12:27 <koala_man> django_: yes, but not as purely functional as Haskell
17:12:37 <django_> ok im a newb programmer
17:12:39 <dmj> django_: there's no real concrete defintion of what "functional programming" is
17:12:46 <montanonic> django_: it supports first-class functions, among other things, so kind of
17:12:50 <montanonic> ^^what dmj said
17:13:01 <django_> im thinking about picking up a functional language
17:13:11 <montanonic> django_: have you programmed much before?
17:13:17 <django_> kinda
17:13:22 <dmj> django_: you've come to the right place
17:13:35 <montanonic> django_: wanna tell us about you're experiences and what you're looking for?
17:13:53 <montanonic> I've only been coding myself for around ~7 months or so.
17:13:53 <django_> ive done some python/js and recently some java..i wanna pick up more skills
17:15:26 <montanonic> django_: I think Clojure and Haskell would be two great options. I lean heavily towards the Haskell side though.
17:16:01 <montanonic> But Clojure has industry adoption that Haskell doesn't yet have, so it might be more appealing if you're trying to get right into programming work or stuff like that.
17:16:16 <montanonic> I'll let others comment upon that though, this is just my impression.
17:16:49 <KaneTW> define what your goal is in learning a language
17:16:53 <KaneTW> then decide appropriately
17:17:57 <dmj> django_: by and large industry hasn't caught onto the fact that what it really wants is haskell, and haskell is perceived as being inaccessible, despite constant demonstrations of its practicality / power in industry
17:18:26 <django_> oh well
17:20:04 <montanonic> django_: if you want to learn "functional programming" though, you will definitely learn it by coming to this IRC often and also joining #haskell-beginners
17:20:50 <KaneTW> not learning a language because it's not widely adopted is a mistake, imo
17:21:46 <dmj> popularity + adoption != correct
17:22:20 <montanonic> django_: you should feel free to ask technical questions if you want to understand a particular concept
17:22:44 <monochrom> even if you care about popularity, global popularity is not always relevant to you. only local (to you) popularity is relevant to you.
17:23:14 <monochrom> for example, suppose Facebook's Simon Marlow group hires you. then local popularity says Haskell.
17:24:23 <monochrom> the exciting point is that you and your locality influence each other. there are differential equations to solve.
17:24:37 <hpc> btw, that's the group that programs the simon marlow android
17:25:23 <barrucadu> Once you get to a certain level of Haskell expertise, the community replaces you with an android
17:25:57 <hpc> it's the only defense against the bowtie menace
17:26:09 <KaneTW> beep boop
17:26:23 <hpc> more seriously, especially with the internet being... the internet
17:26:44 <hpc> it's very easy to find a group for any niche
17:27:56 <nineonine> hello there !
17:27:59 <hpc> also, create your own bubble of popularity, if you can
17:28:14 <nineonine> can anyone suggest the key-value data structure
17:28:24 <monochrom> Data.Map has one
17:28:26 <nineonine> that allows O(1) querying ?
17:28:26 <mrlase> I'm trying to add a field to a list of [Entity Category] (entity being from persistent) in a JSON response. This is my attempt: http://lpaste.net/2117966296279678976, how might I fix this?
17:28:31 <hpc> find a pick-your-language opportunity where haskell works best and use that
17:28:37 <monochrom> there is none, strictly speaking.
17:28:38 <dmj> nineonine: Data.Array is O(1)
17:29:03 <KaneTW> nineonine: O(1) for what keys
17:29:10 <nineonine> String
17:29:35 <hpc> O(1) with respect to what, as well?
17:29:58 <KaneTW> well, i assume amount of keys stored
17:29:58 <hpc> with String you've automatically resigned yourself to non-constant lookup time wrt the size of the key (if your keys are somehow very large)
17:30:02 <monochrom> string length of the string key
17:30:13 <nineonine> its no bigger than 2 chars actually
17:30:20 <nineonine> it can be 1 or 2 chars
17:31:01 <nineonine> @hpc sorry I did not really understand the question :\
17:31:01 <lambdabot> Maybe you meant: src rc pl ghc
17:31:33 <hpc> nineonine: just getting a sense of what direction your problem scales in
17:31:41 <hpc> but it sounds like you just have a large number of keys
17:31:55 <monochrom> no, only a small number
17:31:56 <hpc> (but not that large given your strings are small)
17:32:17 <hpc> > 2 ** 16
17:32:19 <lambdabot>  65536.0
17:32:34 <monochrom> create an array of size 1114112^2
17:33:02 <hpc> but yeah, Data.Map is probably what you're looking for then, for just a basic k-v association type
17:33:24 <nineonine> yeah, probably Data.Map is the best option
17:33:32 <nineonine> thanks for help
17:33:33 <KaneTW> it's O(log n) but log n is effectively constant anyway
17:33:38 <hpc> in general, questions of data structure go "what data structure do i need?" followed by "what implements that structure in haskell?"
17:35:09 <Gurkenglas> mrlase, you'll need to say what doesn't work. Is there an error?
17:35:31 <mrlase> Gurkenglas: No instance for (Foldable IO) arising from a use of ‘.=’, where .= is from Aeson
17:36:32 <KaneTW> post your code
17:36:40 <Gurkenglas> mrlase, please paste the complete error. KaneTW, he has.
17:36:58 <KaneTW> oh there
17:37:02 <Gurkenglas> Oh wait you mean including the parts of the code he didn't post, hah.
17:37:09 <KaneTW> well
17:37:10 <KaneTW> that too
17:37:25 <mrlase> http://lpaste.net/151642
17:37:28 <mrlase> is the error
17:38:04 <KaneTW> what's the type of calculateCategoryBalanceForMonth
17:38:05 <mrlase> although I realized after sending this that I'm not even adding the field, just mapping each entity and returning one field, not concatenating to the fields
17:38:22 <mrlase> KaneTW: CategoryId -> Int -> IO Double
17:39:21 <Gurkenglas> mrlase, it's trying to use the ToJSON instance "(Foldable t, ToJSON a) => ToJSON (t a)" from http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Types.html#t:ToJSON
17:40:05 <KaneTW> .= is probably the wrong operator here, then
17:40:53 <KaneTW> get the double with liftIO and set the key to it
17:41:04 <Gurkenglas> But "calculateCategoryBalanceForMonth (toSqlKey 12) 1" is in IO so it doesn't work. You'll need to execute "calculateCategoryBalanceForMonth (toSqlKey 12) 1" separately
17:42:00 <mrlase> hmm ok
17:42:18 <lpaste> Gurkenglas annotated “map is hard” with “mrlase, here's a quick fix” at http://lpaste.net/2117966296279678976#a151643
17:43:03 <mrlase> this was a bad example with my hard coded value 
17:43:05 <mrlase> was using that to test
17:43:28 <mrlase> calculateCategoryBalanceForMonth has type CategoryId as an argument
17:43:49 <mrlase> so the first argument should have been the category id from x in the lambda function for map
17:44:12 <mrlase> (which, as an aside, am confused about how to get the ID out of a record with persistent)
17:53:54 * hackagebot MoeDict 0.0.4 - Utilities working with MoeDict.tw JSON dataset  https://hackage.haskell.org/package/MoeDict-0.0.4 (AudreyTang)
18:07:04 <Gurkenglas> http://lpaste.net/1266431305487220736 <- what do? I'm on Windows.
18:07:29 <Gurkenglas> (Did stack setup and stack install for that minesweeper thing from the subreddit.)
18:08:08 <andromeda-galaxy> Gurkenglas: not sure, maybe MinGW/MSYS/Cygwin?
18:08:30 <andromeda-galaxy> Gurkenglas: see http://stackoverflow.com/questions/18592674/install-haskell-terminfo-in-windows
18:10:10 <Gurkenglas> andromeda-galaxy, the answerer to that question doesn't seem to have managed it to work. I thought stack is supposed to tame this madness :s
18:10:48 <andromeda-galaxy> Gurkenglas: I'm not sure how things are on windows.  I don't think you'll find "native" ncurses without cygwin/mingw/msys2 thoughtpolice 
18:11:34 <geekosaur> Gurkenglas, stack can't do anything about native libraries, only Haskell libraries
18:12:17 <geekosaur> native libs are *always* a pain on Windows
18:12:28 <kadoban> Gurkenglas: Having stack have to deal with any kind of library, haskell or not, would be … even bigger madness. It'd have to integrate with every package manager in existence, or replace them all.
18:12:58 <geekosaur> as if windows has package managers. (well, chocolate, if it matures)
18:13:34 <andromeda-galaxy> hmm, if I have a GADT 'data Ty (l :: TTree *) a' (with type constructors like 'Plus :: Ty l1 a -> Ty l2 a -> Ty ('TTree a '[l1, l2]) a'; the basic idea is to ensure that I never accidentally end up with a GADT-ized existential) is there any decent way to make it an instance of Num?  I see why it doesn't work directly, but feel like there should be some way to do somtehing like it...
18:15:02 <montanonic> Finally got to the STM chapter in the ParConc book. Holy shit STM is nice.
18:15:05 <sm> stack ensures some kind of basic msys environment - I think "stack exec bash" will take you there, and maybe pacman is available, so you could pacman -S terminfo or similar.. ?
18:15:50 <sm> or pacman -S ncurses or whatever
18:16:11 <geekosaur> minghc, but I don't know how integrated with msys it is --- since it needs to ensure a known good set, it can't just install an ncurses that might not be compatible with it (but is with current msys)
18:16:25 <montanonic> And while on the topic of side-effecting operations, I want to work through an algorithms book by implementing the imperative-style algorithms functionally, but I'd *also* like to implement them in the same way they are done in the book too in Haskell
18:16:39 <montanonic> What tools might I use to write things like in-place algorithms in Haskell?
18:16:52 <andromeda-galaxy> montanonic: ST?
18:17:08 <geekosaur> and, well, chouce of "pacman" makes me think it expects a rolling release world and won't play well with stuff deliberately held back
18:17:21 <andromeda-galaxy> (about my earlier question) the only alternative that I can think of is to use Typeable constraints on the GADT, which is kind of annoying...
18:17:27 <montanonic> andromeda-galaxy: ST is a more isolated IORef, right?
18:17:35 <andromeda-galaxy> montanonic: sort of...
18:18:05 <montanonic> Right, it doesn't force your code to exist within IO. That's one thing, if I'm not mistaken.
18:18:37 <montanonic> It doesn't kill purity because state is encapsulated, I think that's what I meant to say.
18:18:47 <montanonic> Any other tools you or others can think of, for in-place stuff?
18:19:32 <montanonic> And to slam another question down, if I wanted to parallelize code using the ST monad, would MVars or STM still work?
18:21:12 <geekosaur> I don't think you can do that
18:22:11 <andromeda-galaxy> montanonic: I'm not really sure, I haven't done too much with that kind of thing.  geekosaur: is that an answer to montanonic's question, or mine?
18:22:17 <geekosaur> individual state threads are isolated from each other by design; multiple threads would each have its own state independent of any other
18:22:35 <geekosaur> andromeda-galaxy, I have no idea about your question
18:22:56 <Axman6> montanonic: ST is IO -I -O but keeping mutation
18:23:07 <montanonic> thanks geekosaur and Axman6 
18:23:25 <geekosaur> (state threads are not the same as CPU threads, but being separate CPU threads means they cannot share common ST state)
18:23:52 <Axman6> ST and parallel aren't really ideas which work well together since you cannot guarantee determinism at that point
18:23:52 <montanonic> geekosaur: is there a resource where I can read up on this more?
18:24:22 <montanonic> Axman6: I would have guessed as much, I was mainly interested in seeing how painful it would be to do that way, but without using constructs I'm unfamiliar with.
18:24:27 <geekosaur> there's a paper on the idea behind ST. I don't know how readable it is though
18:24:30 <andromeda-galaxy> geekosaur: okay, I just wanted to check
18:24:39 <geekosaur> that said, many Haskell-related papers are quite readable
18:24:39 <Axman6> but, it is possible to share mutable arrays between parallel ST computations in an "unsafe" but actually safe way, using the unsafe* functions
18:25:03 <montanonic> geekosaur: Yeah I think I'm better off sticking to blog posts; they are readable, but it takes too much effort for me, usually, for now
18:25:12 * geekosaur does not really have a feel for how unsafe unsafe{IO,ST}to{ST,IO} are
18:25:13 <Axman6> montanonic: you might want to have a look at how Repa does pure parallelism in an efficient manner (you might be able to hook into some of what it offers)
18:25:50 <montanonic> Axman6: Is there a resource on repa aside from Marlow's book?
18:25:58 <montanonic> any good blog posts?
18:26:06 <Axman6> there's Ben's paper on it, which IIRC is quite readable
18:27:41 <montanonic> Axman6: thank you; I'm taking a look at the libraries
18:27:42 <Axman6> montanonic: http://benl.ouroborus.net/papers/guiding/guiding-Haskell2012.pdf http://benl.ouroborus.net/papers/repa/repa-icfp2010.pdf (SPJ is a co-author on both so you know they're going to be a good read)
18:27:55 <montanonic> ^thanks for that too
18:28:29 <montanonic> those look good
18:38:14 <andromeda-galaxy> no one
18:38:14 <andromeda-galaxy> !
18:38:16 <andromeda-galaxy> ?
18:39:03 <Axman6> ?
18:40:18 <andromeda-galaxy> Axman6: (about my above question; the ! was a typo..)
18:42:03 <Axman6> yeah that type looks like it's the wrong shape to be an instance of Num, Num cannot have differing types for arguments and results
18:42:16 <Axman6> maybe subhask provides a way
18:44:39 <andromeda-galaxy> yeah, I know it's not exactly right (that's why I said I understand why it doesn't work now), I'm just trying to make sure there isn't some other way, since my type otherwise ends up with a bunch of things that are kind of accidentally existentially qualified
18:46:22 <Cale> Hello!
18:46:28 <andromeda-galaxy> Subhask sounds really nice (whether or not it's applicable here), thinks for the suggestion
18:46:32 <andromeda-galaxy> Cale: hello!
18:47:18 <cads> Hey is there any way to automatically test the functor laws for instances of type class functor?
18:47:41 <Cale> I'm in NYC, going to Compose Conference tomorrow :)
18:48:38 <Cale> cads: The composition law follows from the identity law in Haskell, so it reduces to testing that
18:48:53 <Cale> cads: just because of parametricity
18:49:36 <andromeda-galaxy> cads: hmmm, I'm not sure (something that I've been meaning to look into for a while), but I'd guess that at the very least you could use Template Haskell to generate Quickcheck properties for all in-scope instances of a class
18:49:46 <andromeda-galaxy> (the SubHask test suite seems to do somethig like that)
18:50:59 <andromeda-galaxy> Cale: any idea if it's possible to come up with an instance of Num with a GADT that looks like 'Ty (l :: TTree *) (a :: *)' with constructors like 'Plus :: Ty l1 a -> Ty l2 a -> Ty ('TTree a '[l1 l2]) a'?  I understand why it doesn't work the naive way, but I feel like there should be some way to do something like that
18:52:10 <Cale> btw, if you use DeriveFunctor, then you don't have to test your instance :)
18:53:12 <Cale> andromeda-galaxy:  hmm, I'm not sure what's going on there
18:53:29 <Cale> What's TTree?
18:53:49 <andromeda-galaxy> Cale: a promoted tree-ish type: 'data TTree a = TTree a [TTree a]'
18:54:29 <andromeda-galaxy> I've got a GADT where constructors that take values of the GADT and produce new value lose the types occasionally (often?) causing it them get existentially quantified
18:55:10 <mrlase> Gurkenglas: from earlier, why does assigning the result of liftIO to spent work, but not calling liftIO directly?
18:55:16 <andromeda-galaxy> which obvoiusly restricts what can be done with them, so I wanted to use these type-level "tree" structures to represent the type parameters of the other GADT values that are part of a GADt with a givenconstructor
18:55:33 <andromeda-galaxy> but it doesn't make sense to only say that two GADT values that were built up from the same types in the same fashioin an be addedd..
18:57:14 <Gurkenglas> mrlase, the "<-" desugars into using >>= to bind the value returned by liftIO's argument. Without the "<-", liftIO's argument is just an IO action that you can't directly use
18:58:38 <mrlase> Gurkenglas: is there a desugared way to directly assign with .= using >>= and liftIO then?
18:58:56 * hackagebot json-pointer-hasql 0.1 - JSON Pointer extensions for Hasql  https://hackage.haskell.org/package/json-pointer-hasql-0.1 (NikitaVolkov)
19:03:23 <mrlase> @undo spent <- liftIO $ calculateCategoryBalanceForMonth (toSqlKey 12) 1
19:03:23 <lambdabot> <unknown>.hs: 1: 7:Parse error: <-
19:03:31 <mrlase> @undo do spent <- liftIO $ calculateCategoryBalanceForMonth (toSqlKey 12) 1
19:03:31 <lambdabot> <unknown>.hs: 1: 70:Parse error: Last statement in a do-block must be an expression
19:03:56 <andromeda-galaxy> Cale: the only alternative that I can think of would be to require Typeable constraints on everything, and that's kind of nasty as well
19:06:40 <andromeda-galaxy> (or to use a newtype wrapper for all of the typeclasses like Num/etc., which is equally nasty)
19:06:48 <andromeda-galaxy> (though I could always redefine num...)
19:13:56 * hackagebot unicode-show 0.1.0.0 - print and show in unicode  https://hackage.haskell.org/package/unicode-show-0.1.0.0 (TakayukiMuranushi)
19:20:43 <Cale> andromeda-galaxy: It's not very clear to me that this type even really makes a sensible instance of Num... What would addition do for example? Or fromInteger?
19:22:13 <Cale> andromeda-galaxy: Oh, you have constructors for them...
19:22:20 <Cale> hm, I dunno
19:24:38 <Cale> Yeah, you might be able to build an existential around it which discards the type index that would be an instance of Num, but that would probably defeat the purpose
19:25:25 <Cale> (+) needs arguments of the *same* type and needs to produce a result of that type, so if you want something else, you've just got to use something different
19:35:36 <andromeda-galaxy> Cale: yeah, that's what I was worried about.  I wish I could just do 'instance Num (Ty (forall l. l) a)', but see why that doesn't work
19:35:48 <andromeda-galaxy> maybe I'll just end up rewriting more of the Prelude
20:02:34 <hunteriam> Tips on how to store [a] in HDBC?
20:03:25 <pavonia> Lists are usually stored as a separate table, AFAIK
20:06:39 <andromeda-galaxy> Cale: more generally, do you know of any decent way to preserve the type information on the operands in that kind of GADT?
20:08:31 <cdepillabout> Can someone help me out with a lens question?  I have a `Traversal' a b`, a `Traversal' b c`, and a `Traversal' b d`.  I want to combine them to get a `Traversal' a (c, d)`.  Is there an easy way to do this?
20:19:34 <mniip> hmm, how do I formulate this
20:19:34 <Gurkenglas> cdepillabout, lets say the three traversals are id, the one that traverses over the first two elements of a list, and the one that traverses over the second two elements of a list. How should they be combined? (Do you mean the one that traverses all of the 4 resulting pairs?)
20:19:35 <Gurkenglas> (and if it were the first and second three elements, that would be 9 pairs)
20:22:16 <cdepillabout> Gurkenglas: Sorry, I should have been more specific.  I'm using xml-lens to parse an XML document.  I have a traversal from an XML document to a specific element, let's say <foo>: `foo :: Traversal' Document Element`.
20:23:04 <Axman6> cdepillabout: I don't think that's possible for Traversals. Perhaps with Lenses, but Traversals inherently point to multiple data, and it is not quaranteed that for every c there is a d
20:23:34 <Gurkenglas> Right, what if your latter two argument traversals both traverse more than one tag?
20:24:46 <cdepillabout> Axman6: Gurkenglas: Ah, I see the problem!
20:24:50 <cdepillabout> That makes sense.
20:26:58 <cdepillabout> Hmm, is there some way to say that I only want the FIRST tag <bar> and <baz> under <foo>?
20:30:19 <cdepillabout> So if my document looked like <foo><bar>lala</bar><baz>jaja</baz></foo>, and I had a traversal `foo :: Traversal' Document FooElement`, and `bar :: Traversal' FooElement BarElement`, and `baz :: Traversal' FooElement BazElement`, is there some way to combine them to get `xxx :: Traversal' Document (BarElement, BazElement)`?
20:30:59 <cdepillabout> It would only return a tuple of the first BarElement and BazElement, and fail if either a BarElement or BazElement doesn't exist.
20:31:17 <cdepillabout> Does this even make sense?
20:33:35 <qmm> is there anything like this for haskell? https://www.inverse.com/article/10674-here-s-how-inverse-tests-external-apis-in-elixir-with-bypass
20:37:47 <Gurkenglas> :exf "Applicative f => ((a -> f a) -> s -> f s) -> ((b -> f b) -> s -> f s) -> ((a, b) -> f (a, b)) -> s -> f s" -- Let's see, we want this
20:38:11 <exferenceBot> could not find expression
20:39:54 <cdepillabout> That is what I want.  Hmm, maybe I'll just try to write it myself.
20:46:30 <exio4> how is such function even implemented?
20:56:00 <mniip> sounds rather impossible
20:59:14 <fizruk> is there a function to print using ToJSON? like (ByteString.putStrLn . encode) ?
20:59:15 * hackagebot unicode-show 0.1.0.1 - print and show in unicode  https://hackage.haskell.org/package/unicode-show-0.1.0.1 (TakayukiMuranushi)
21:03:06 <jle`> is there a nice way to get time synonyms?
21:03:13 <jle`> *kind synonyms
21:03:36 <Clint> odd freudian slip
21:04:08 <ReinH> Huh. I wonder where Cale is.
21:04:15 * hackagebot unicode-show 0.1.0.2 - print and show in unicode  https://hackage.haskell.org/package/unicode-show-0.1.0.2 (TakayukiMuranushi)
21:04:50 <Clint> ReinH: <Cale> I'm in NYC, going to Compose Conference tomorrow :)
21:04:53 <hunteriam> Im trying to store a game state and theres a lot of lists involved, is it better to serialize the lists or give each potential list its own table?
21:05:04 <ReinH> Ah. Of course. I knew that.
21:05:31 <ReinH> hunteriam: I think the answer has to be "it depends". On, e.g., access patterns.
21:05:34 <dmj`> fizruk: not in aeson, maybe elsewhere
21:05:42 <hunteriam> ReinH: frequent access
21:05:48 <ReinH> Does it fit in memory?
21:06:00 <hunteriam> ReinH: yes 
21:06:12 <jle`> hunteriam: wait, are these actual things that should be lists, or is it like random-access vectors?
21:06:13 <ReinH> Then you could optimize for load time.
21:06:22 <hunteriam> ReinH: meaning?
21:06:31 <hunteriam> jle`: ?
21:06:33 <ReinH> Serialize the data in a way that is easy to load into memory.
21:06:45 <hunteriam> ReinH: beyond just "show"?
21:06:47 <jle`> like, what are these lists containing?
21:07:07 <hunteriam> jle`: numbers, and also a special data type
21:07:11 <ReinH> @hackage binary
21:07:11 <lambdabot> http://hackage.haskell.org/package/binary
21:07:17 <exio4> jle`: kind synonyms? GHC 8.0 :P 
21:07:53 <jle`> hunteriam: are you usually processing them one-by-one, or are you doing a lot of random-access stuff?
21:08:01 <ReinH> hunteriam: if you are just loading data into memory you can just serialize it. If you need random access to data from disk that's a different problem.
21:08:28 <hunteriam> I want to drop this into a database, its not necessarily a long list 
21:08:48 <ReinH> Why do you want to use a database?
21:09:29 <hunteriam> project contraints
21:09:38 <jle`> oh i see, you meant "table" as in a database table
21:09:44 <jle`> like an sql table
21:10:16 <ReinH> hunteriam: I mean, you could put the whole serialized binary in a blob. The answer depends on how you want to use it.
21:10:33 <hunteriam> how?
21:10:35 <hunteriam> does it depend
21:11:18 <ReinH> On access patterns and frequency, etc.
21:11:28 <ReinH> How you store data depends on how you use it.
21:11:51 <django_> hey
21:11:52 <hunteriam> can you say more?
21:11:55 <django_> i was chatting here earlier and had to afk
21:12:49 <ReinH> hunteriam: I mean, I'm trying to get you to say more... It all depends on what sort of data it is, how you want to access it, what operations you want to optimize for, etc
21:13:04 <hunteriam> looking for examples
21:13:30 <ReinH> Well, if you are going to load it into memory and work with it there, it doesn't matter much how you store it.
21:13:50 <ReinH> If you need to query the data on disk, you need to store it in a way that makes those queries efficient enough.
21:14:02 <hunteriam> ah
21:14:10 <hunteriam> just gonna load it 
21:14:34 <ReinH> Then put it in a blob, I guess. Database is the wrong tool, but constraints are constraints.
21:15:09 <hunteriam> ReinH: what else?
21:15:16 <ReinH> What do you mean?
21:15:19 <hunteriam> besides dbs?
21:15:23 <ReinH> Files.
21:15:28 <ReinH> Files are pretty good at storing bytes.
21:15:47 <ReinH> I mean, databases use them.
21:16:28 <hunteriam> thanks
21:17:00 <kadoban> hunteriam: Usually you use a database because you need efficient queries of certain forms to a bunch of data. You just want a blob somewhere, so that's why it sounds a bit off.
21:19:07 <hunteriam> are files still good if it will be small?
21:19:10 <hunteriam> *better
21:19:28 * hackagebot json-ast-quickcheck 0.2 - Compatibility layer for "json-ast" and "QuickCheck"  https://hackage.haskell.org/package/json-ast-quickcheck-0.2 (NikitaVolkov)
21:27:34 <ktonga> Hi. Quick question regarding do notation. Is there a way to include a conditional so that if it is false it stops the further bindings. With Maybe, for instance, if condition is False it injects a Nothing. I dont know if you are aware of Scala's IFs within a for comprehension 
21:28:13 <Zekka> ktonga: Are you looking for guard from monadplus?
21:28:50 <Zekka> it looks like it may have been renamed, but I don't know about that
21:29:12 <mniip> ktonga, you're looking for MonadPlus
21:29:21 <Zekka> > do x <- [1, 2, 3]; guard (x > 1); return x
21:29:22 <lambdabot>  [2,3]
21:29:32 <Zekka> > do x <- Just 4; guard (x > 5); return x
21:29:32 <mniip> alternatively,
21:29:33 <lambdabot>  Nothing
21:29:52 <mniip> > do x <- [1, 2, 3]; if x > 2 then mzero else return x
21:29:54 <lambdabot>  [1,2]
21:30:56 <ktonga> can I use it in the middle? kind of a precondition for the next lines. or just before de return?
21:34:05 <pavonia> > do x <- [1, 2, 3]; guard (x > 1); y <- "abc"; return (x, y)
21:34:07 <lambdabot>  [(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
21:36:12 <ktonga> I was trying just that. Thank you, it is exactly was I was looking for. 
21:36:16 <exio4> @type guard
21:36:18 <lambdabot> Alternative f => Bool -> f ()
21:36:32 <exio4> oh, it's in Alternative? 
21:45:45 <ktonga> Zekka++ pavonia++ mniip++
21:45:59 <mniip> it's @karma+ :>
21:56:21 <saurabhnanda> hello there, good people
21:56:43 <saurabhnanda> i'm dealing with another philosophical question. How do i separate out pure/impure (or non-IO vs IO) code in my haskell program
21:56:57 <saurabhnanda> Right now it seems every function in my code is dealing with IO ()
21:57:41 <ktonga> @karma+ Zekka 
21:57:41 <lambdabot> Zekka's karma raised to 2.
21:57:45 <kadoban> saurabhnanda: You separate it out by making some functions not deal with IO ()
21:57:53 <ktonga> @karma+ pavonia
21:57:53 <lambdabot> pavonia's karma raised to 3.
21:58:04 <ktonga> @karma+ mniip
21:58:04 <lambdabot> mniip's karma raised to 6.
21:58:21 <saurabhnanda> kadoban: how do I do that, practically
21:58:25 <saurabhnanda> i'll give an example
21:59:11 <saurabhnanda> handleResponse :: [OutstandingRequest] -> OutgoingChannel -> [OutstandingRequest]
21:59:52 <saurabhnanda> sorry, missed an argument
22:00:05 <saurabhnanda> handleResponse :: String -> [OutstandingRequest] -> OutgoingChannel -> [OutstandingRequest]
22:00:23 <saurabhnanda> handleResponse response [outstandingRequest] chan = blah
22:00:45 <saurabhnanda> I want the function to take in a response, remove it from the [OutstandingRequest] queue
22:00:53 <saurabhnanda> write something to the OutgoingChannel
22:01:11 <saurabhnanda> and send me back the new [OutstandingRequest] list
22:01:26 <saurabhnanda> compiler is complaining about the missing IO() in the type sign
22:01:39 <saurabhnanda> how do I separate out the IO from the non-IO in this function
22:01:46 <saurabhnanda> the non-IO logic is parsing the response
22:02:09 <saurabhnanda> and popping it from the outstandingRpc and returning the new outstandingRpc
22:02:19 <saurabhnanda> ...
22:03:07 <saurabhnanda> any help?
22:03:38 <liste> saurabhnanda: what type is OutgoingChannel?
22:03:48 <saurabhnanda> Chan a
22:03:53 <saurabhnanda> where 'a' is a custom data type
22:03:59 <kadoban> saurabhnanda: The general advice would be just to move the stuff that's pure into a separate function and call it from the IO whatever if you want to I guess. I didn't really quite understand some parts of that, so I'm not really sure :-/
22:04:07 <liste> saurabhnanda: then you need IO in your type to write anything to it
22:05:05 <liste> maybe do something like "process :: String -> OutstandingRequest -> Response" where Response is the thing you write into a Chan
22:05:11 <saurabhnanda> I realize that because I'm writing to a channel, I need IO() in my type sig
22:05:20 <saurabhnanda> but, that's what's happening throughout my program
22:05:34 <saurabhnanda> almost every function has IO in it, and it doesn't seem right
22:05:53 <liste> separate the computation of the response and writing it into the channel
22:06:04 <saurabhnanda> liste: hmm
22:06:27 <saurabhnanda> in that case it will be process :: String -> [OutstandingRequest] -> (Response, [OustandingRequest])
22:06:46 <saurabhnanda> because I need to pop from the [OustandingRequest] list
22:07:26 <saurabhnanda> actually, it will be: process :: String -> [OutstandingRequest] -> (Maybe Response, [OustandingRequest])
22:08:19 <saurabhnanda> so, is the general pattern like this: A few functions which have IO () in their type sig, and these functions call multiple smaller/pure functions which deal with specific data transformations?
22:09:02 <liste> saurabhnanda: mostly yes. depends on the situation though, but usually that's the goal
22:09:36 <saurabhnanda> okay, let me try to rewrite my code
22:09:39 <johnw> saurabhnanda: if you really want the philosophical answer, deny yourself IO completely and see what you can accomplish
22:09:59 <saurabhnanda> johnw: I'm writing a telegram bot. Is that even possible?
22:10:04 <johnw> you'd be surprised
22:10:31 <johnw> in fact, you can remove all IO from your program, and move it to an interpreter that runs on a program representation you build from pure code
22:10:51 <johnw> for example, http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
22:11:20 <johnw> I'm not saying you should go that far for all code
22:12:53 <johnw> I gave a talk on this recently also: http://begriffs.com/posts/2015-12-26-what-code-means.html
22:17:08 <saurabhnanda> johnw: thanks for the links. let me go through them
22:24:03 <codebje> saurabhnada, a type signature like that might work better as process :: Monad m => String -> StateT [OutstandingRequest] m Response
23:06:20 <zipper> Hey arch users how come stack is giving a 404 page on arch https://aur.archlinux.org/packages/haskell-stack/
23:06:38 <zipper> Oh it's in the main repos
23:07:40 <zipper> Wait, why does installing stack require me to install so many depends? This is weird.
23:10:16 <liste> zipper there's a different package named `stack'
23:10:23 <liste> it only requires one lib from AUR
23:10:28 <zipper> liste: Okay
23:11:06 <zipper> liste: stack is what was called haskell-stack in the AUR previously
23:11:28 <liste> during installation it gives two choices for deps
23:17:27 <liste> iirc
23:35:20 <Ainieco> hello what kind of congruence is this? http://stackoverflow.com/questions/27091668/refl-in-agda-explaining-congruence-property
23:36:04 <Ainieco> i mean which one from this list https://en.wikipedia.org/wiki/Congruence
23:38:43 <johnw> Ainieco: I don't see a connection with what's on that wiki page
23:41:23 <nineonine> Parsec question here: how to parse string literal ( example: “ a + b = c” ) into (“a + b”, “c”) :: (String, String) 
23:41:43 <nineonine> basically i need that “ = “ as a separator
23:42:13 <johnw> all you want to do is split on "="?
23:42:29 <nineonine> yeah
23:42:45 <nineonine> “ = “ actually
23:43:01 <nineonine> i dont need those spaces in parsed substrings
23:43:17 <johnw> (,) <$> manyTill anyChar (try (string " = ")) <*> text
23:43:31 <johnw> not sure if you need to parse the separator with <* string " = " after the first
23:43:38 <johnw> or if "text" is in parsec, or trifecta :)
23:43:54 <nineonine> will give it a try now. thanks !
23:43:55 <johnw> but along those lines: parse everything up to the separate, then parse everything else
23:46:56 <nineonine> nope it didnt work :\
23:47:22 <johnw> try just the manyTill on its own, and make sure you allow partial parse results
23:47:31 <nineonine> kk
23:50:51 <nineonine> what does text here mean ?
23:51:06 <nineonine> there is no such a combinator
23:51:15 <johnw> "read everything else up to EOF as a string"
23:51:52 <nineonine> i cant find it
23:52:02 <johnw> just write it another way then
23:52:11 <johnw> I can't remember offhand the syntax
23:52:22 <johnw> it may just be "many anyChar"
23:55:00 <frerich> I think that would be 'manyTill anyChar eof'.
23:56:04 <nineonine> yeah i tried that as well
23:56:13 <nineonine> it is still complaining about unexpected end of input
23:56:36 <nineonine> actually
23:56:37 <nineonine> that worked
23:56:43 <nineonine> yay
23:56:45 <nineonine> thanks
23:57:08 <johnw> frerich: I guess sometimes it's obvious :)
23:59:01 <nineonine> parsers are so confusing for newcomers :\
23:59:12 <johnw> certainly applicative parsers
23:59:15 <johnw> they aren't too common elsewhere
23:59:25 <johnw> but so natural once you get used to them
23:59:45 <johnw> it allows you to very naturally merge AST building with parsing
23:59:51 <nineonine> yeah that applicative point free parsing is killing my brain
