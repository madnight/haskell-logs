00:01:28 <shanemikel> but I haven't read the report, so don't feel compelled to learn me
00:01:37 <shanemikel> (yet)
00:03:14 <shanemikel> that's kinda crazy, ghc can translate it's state into "Core", but it can't read it?
00:03:37 <johnw> a part of GHC can read it, surely
00:03:43 <johnw> but whether it trusts you to give it valid Core is something else
00:05:56 <shanemikel> i was under the impression that ghc was the product of a haskell to core transpiler, and a core to machine compiler
00:06:12 <johnw> you should read up on it :)
00:06:19 <shanemikel> definitely will
00:07:13 <shachaf> shanemikel: Core is an internal language mostly represented as an internal data structure in GHC.
00:07:30 <shachaf> There's a thing called "external Core" but it doesn't really work anymore, if it ever did.
00:07:39 * hackagebot hadoop-tools 1.0.1 - Fast command line tools for working with Hadoop.  https://hackage.haskell.org/package/hadoop-tools-1.0.1 (JacobStanley)
00:07:39 * hackagebot vulkan 1.0.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.0.0.0 (jophish)
00:08:17 <ner0x652> Hi!
00:09:29 <ner0x652> I wrote a clone function for reverse(for educational purpose)
00:09:41 <ner0x652> The function signature is this
00:09:50 <ner0x652> rev :: (a -> a) -> [a] -> [a]
00:10:02 <ner0x652> I want to use foldr for this
00:10:12 <ner0x652> this is the definition
00:10:20 <shanemikel> thanks shachaf, exactly what I was looking for
00:10:37 <ner0x652> rev f xs = foldr (\x acc -> acc ++ [f x]) [] xs
00:10:49 <shanemikel> even though the answer is rather unfortunate
00:10:57 <ner0x652> What I did works, that's ok.
00:11:15 <ner0x652> I want to know, is there another way to implement reverse using foldr?
00:11:28 <shachaf> ner0x652: There's external Cmm, if that makes you feel any better. :-)
00:11:45 <ner0x652> what's Cmm?
00:11:46 <shachaf> ner0x652: Yes, there are lots of ways to implement reverse using foldr.
00:11:54 <shachaf> ner0x652: Er, that was meant to go to shanemikel.
00:12:10 <shachaf> But what you wrote isn't reverse, it's some sort of odd reverse + map.
00:12:38 <ner0x652> shachaf: give me an example, please
00:13:08 <shachaf> "reverse xs = foldr (\x acc -> acc ++ [x]) [] xs" is what people normally call "reverse". No need for f.
00:13:20 <shachaf> But it's pretty inefficient.
00:13:24 <shanemikel> yes, it does make me feel a bit better :)
00:13:52 <ner0x652> shachaf: I guess it is inefficient because of concatenation function ++, right?
00:13:58 <Saizan> > foldr (\x acc -> acc . (x :)) id xs [] [1..5]
00:14:02 <lambdabot>      Not in scope: ‚Äòxs‚Äô
00:14:04 <lambdabot>      Perhaps you meant one of these:
00:14:06 <lambdabot>        ‚Äòx‚Äô (imported from Debug.SimpleReflect),
00:14:13 <shachaf> I was just typing out the thing Saizan said.
00:14:16 <Saizan> > foldr (\x acc -> acc . (x :)) id [1..5] []
00:14:20 <lambdabot>  [5,4,3,2,1]
00:14:30 <ner0x652> shachaf: then how does an efficient implementation looks like?
00:15:23 <Saizan> ner0x652: the one here ^^^ is more efficient because it doesn't go over the accumulator multiple times
00:17:01 <ner0x652> ok, thanks
00:17:58 <shanemikel> there's a trick in readline + vi line-editing mode to get an indicator of whether you're in edit or insert mode, is there a way to do it with haskeline and ghci
00:19:59 <shanemikel> it's 'set show-mode-in-prompt on'
00:20:00 <magthe> shanemikel: something in the prompt?
00:20:04 <shanemikel> yeah
00:20:19 <magthe> ah, thanks... that's something I didn't even realise I was missing :)
00:22:41 * hackagebot oden-go-packages 0.1.0.1 - Provides Go package metadata.  https://hackage.haskell.org/package/oden-go-packages-0.1.0.1 (owickstrom)
00:23:31 <shanemikel> magthe: you really used vi editing in your shell without missing a mode indicator lol, you must have superb short-term memory
00:24:21 <shanemikel> in other words, you're welcome
00:24:34 <EvanR> its like knowing what gear youre in ;)
00:27:11 <shanemikel> in an electric car, how do you know what gear you're in?
00:27:33 <doudou> Hi, i read http://sequence.svcs.cs.pdx.edu/node/367 and i dont understand why haskell should be slow, is it still the case, is it programming error, is haskel fast reading bytes from sockets?
00:27:56 <EvanR> now give me the text editor equivalent of an electric car
00:28:23 <magthe> shanemikel: I'm just not very often in ghci :)
00:30:23 <xnool> So Stack is giving me this wonderfully helpful message: "Perhaps you need to add ‚Äòcontainers‚Äô to the build-depends in your .cabal file."
00:30:40 <xnool> More info can be given if needed, but how specifically would I add this?
00:30:44 <Cale> doudou: That's from almost a decade ago... I don't know what the results would be like today for those particular tests, but the compiler is a hell of a lot better now than it was then.
00:31:36 <xnool> oof, nevermind.
00:32:41 * hackagebot oden-go-packages 0.1.0.2 - Provides Go package metadata.  https://hackage.haskell.org/package/oden-go-packages-0.1.0.2 (owickstrom)
00:33:25 <doudou> Cale so he must be as fast as python for example reading data and doing and or xor and manipulate bytes? As fast as C?
00:33:49 <Cale> doudou: Languages don't have speeds -- programs on given input do.
00:34:23 <Cale> doudou: http://hackage.haskell.org/package/pureMD5 appears to be the modern version of that code if you want to try it
00:35:55 <Cale> er, perhaps you'd rather use https://github.com/TomMD/pureMD5 as the source, it looks like there was a change on github about a month ago
00:38:40 <shanemikel> EvanR: idk, it wasn't a pre-meditated analogy
00:38:59 <EvanR> not guilty
00:39:44 <shanemikel> but modal editing without indication is an incentive to absorb emacs bindings
00:46:11 <magthe> can't find any setting for it at http://trac.haskell.org/haskeline/wiki/UserPrefs :(
00:47:12 <shanemikel> did you try adding that line to your .inputrc?
00:47:23 <shanemikel> are you pleased with the effect?
00:47:42 * hackagebot oden-go-packages 0.1.0.3 - Provides Go package metadata.  https://hackage.haskell.org/package/oden-go-packages-0.1.0.3 (owickstrom)
00:48:50 <magthe> yes, but on this machine I'm using zsh, where I have indication... the setting is for the few machines I can't install zsh on :)
00:49:28 <shanemikel> oh, yeah. zsh doesn't use readline
00:49:55 <magthe> indeed, and my indication there is rather more flashy :)
00:52:17 <shanemikel> I want to use zsh, but I haven't come around to curating a config.. is it completely compatible with bash syntax?
00:52:25 <johnw> no
00:53:09 <magthe> I'm not sure actually... largely, I think... but I have a setup I've grown over the last 5 years or so
00:53:21 <magthe> my bash config is considerably simpler
00:54:04 <shanemikel> I mean are all bash scripts runnable on zsh, not the other way around
00:54:25 <johnw> shanemikel: this channel is really for Haskell discussion
00:54:38 <shanemikel> I agree
00:58:14 <johnw> ugh, my Haskell code SEGV's until I put in tracing statements, which causes it to work
00:59:19 <EvanR> then make sure you have tracing statements in --doctor
01:02:30 <jle`> johnw: good ol' heisenbugs
01:19:12 <mniip> hmm
01:19:57 <mniip> how do I prove  a ~ forall r. f ((forall q. f (a -> q) -> q) -> r) -> r
01:42:41 <phaazon> hi
02:02:47 * hackagebot directory-listing-webpage-parser 0.1.0.0 - directory listing webpage parser  https://hackage.haskell.org/package/directory-listing-webpage-parser-0.1.0.0 (sifmelcara)
02:09:29 <lonokhov> o/
02:10:31 <lonokhov> linux or unix package or ghc question: why it does not catch USR2 if USR1 handler is also installed?
02:14:01 <lonokhov> hm, or it does.
02:14:41 <mniip> lonokhov, USR1 and USR2 are very separate signals
02:19:24 <lonokhov> yeah, but still. I've changed usr2 to hup and it works. maybe GHC uses it for something?
02:20:09 <lonokhov> strange, now it works. probably problem was elsewhere
02:22:48 * hackagebot turtle-options 0.1.0.2 - Collection of command line options and parsers for these options  https://hackage.haskell.org/package/turtle-options-0.1.0.2 (elaye)
03:39:26 <fractalsea> I‚Äôm using `orElse` to read from one of two STM transactions. At the moment I wrap the return types in Left or Right, and then pattern match on these to decide what IO to do afterwords. Is there a cleaner way of doing this?
03:40:29 <liste> fractalsea: do you mean (Left <$> action1) `orElse` (Right <$> action2) ?
03:40:38 <fractalsea> yes
03:42:05 <fractalsea> It would be nice if there was a version of orElse, like orElse‚Äô :: STM a -> STM b -> (a -> m c ->) (b -> IO c) -> m c
03:54:57 <bernalex> edwardk: thanks for the elucidating all-encompassing reply to the foldable thread.
04:08:05 <ggVGc> hn, why would ghc-mod say my code is fine, while it doesn't compile in ghc?
04:12:08 <ironChicken> how do i execute the [my-test-suite]Stub by hand? that is, the executable created from a cabal testsuite. does it need some arguments?
04:16:24 <bernalex> ironChicken: cabal test
04:16:51 <ironChicken> bernalex: actually, i meant, can i run the executable directly?
04:17:11 <ironChicken> when i try, it just waits; i don't see any output
04:17:31 <ironChicken> i was wondering if cabal actually calls it with some necesssary arguments or something
04:19:44 <ironChicken> looking at the definition of Distribution.Simple.Test.LibV09.stubMain, it calls getConents
04:19:56 <ironChicken> so it's obviously waiting for something
04:20:51 <lyxia> ironChicken: Are you using the detailed interface?
04:21:34 <lyxia> the test executable is built with this module http://hackage.haskell.org/package/Cabal-1.22.7.0/docs/src/Distribution.Simple.Test.LibV09.html#stubMain
04:21:47 <lyxia> stubMain starts with getContents
04:22:28 <lyxia> and it expects a pair (logFile, suiteName)
04:22:46 <ironChicken> lyxia: thanks. yes, i'd just found that :-)
04:23:13 <ironChicken> so i tried typing them in at the terminal and it seems to work
04:25:27 <lyxia> nice
04:32:34 <edwardk> bernalex: here's hoping it does some good =)
04:32:52 <bernalex> edwardk: oh I don't think you can convince anyone. but it's a nice summary post that I can refer back to.
04:33:35 <edwardk> i figured i should say something since almost all the folks participating so far are the same folks who complained when the FTP was first proposed, and they are using all the same arguments that were shot down at the time
04:33:48 <edwardk> if _anything_ new was being said in the thread i'd be much more engaged
04:33:49 <bernalex> edwardk: while I don't like most of Foldable very much, I always keep a keen eye on your emails pertaining the issue, as you have a gift for elucidating the practical concerns perfectly.
04:34:02 <bernalex> edwardk: I agree. same old men saying the same old things. yawn.
04:35:01 <ironChicken> w00t
04:35:05 <ironChicken> problem solved :-)
04:39:25 <inerkick> Hi. I'm new to Programming and keen to learn Haskell and eventually into web development. Is it good way to learn Haskell alongside Website development. Could someone help me out how to visualize the concept of website development with Haskell
04:41:46 <gracefu> step 1) Install Go
04:42:02 <EvanR> what no
04:42:17 <EvanR> step 0) disregard step 1
04:42:25 <gracefu> XD
04:42:32 <inerkick> :D
04:42:53 <inerkick> Are you telling me to try Go, gracefu 
04:43:13 <gracefu> yes, but maybe evanR has something to say
04:43:48 <inerkick> Funny, I mean I am going through the tutorial of Haskell, brought the usual famous two which everyone knows. Slowly learning it
04:43:52 <gracefu> also, if you aren't working on a huge webservice, python is probably a better choice than Go. Probably.
04:43:55 <{AS}> inerkick: You try looking at a framework like Yesod
04:44:13 <{AS}> can try*
04:44:21 <{AS}> http://www.yesodweb.com/
04:44:25 <inerkick> Yeah, I checked Yesod and Snap. I couldn't find Snap tutorial though.
04:44:42 <inerkick> What I mean to say is that, there is way the tutorials explain Haskell concepts
04:45:14 <inerkick> but these frameworks Yesod, Happstack, snap(I'm not sure) they probably evolve from already understood concepts of Haskell
04:45:48 <inerkick> What I am trying to understand is, per say you got HTML, CSS and scripts, over to HAskell how do you use it or apply simple steps
04:46:06 <inerkick> using Haskell
04:46:07 <obadz> kmicu: hey my ~/.XCompose seems to get any ignored. Any ideas?
04:46:35 <{AS}> inerkick: I am not experienced enough with that part, sorry
04:46:54 <gracefu> inerkick: Those things usually depend heavily on the framework. It's true for all the languages I do know, but haskell isn't one of them
04:47:15 <gracefu> you'll probably have to look directly at the framework
04:47:39 <inerkick> yeah..  What I'm trying to say here is, Say we got to develop something right from scratch as REST frameworks does
04:47:57 <inerkick> so since we know like functions -> so and so 
04:48:23 <inerkick> how that apply to HTML, CSS and other domain elements is what I'm trying to understand this logic
04:48:27 <fsestini> Hi guys. I have a problem with multiple parameter typeclasses. Suppose we have a typeclass Relation:
04:48:27 <fsestini> class Relation ta tb where
04:48:27 <fsestini>   foo :: ta -> tb
04:48:27 <fsestini> If I try to instantiate it like, for example, this:
04:48:27 <fsestini> instance (Relation Int t) => Relation String t where
04:48:28 <fsestini>   foo _ = (foo :: Int -> t) 10
04:48:30 <fsestini> I get: ìCould not deduce (Relation Int t1) arising from a use of ëfooí from the context (Relation Int t).î Why is that? Why canít I refer to that specific t in the use of ìfooî, instead of getting the typechecker to create a new type variable t1?
04:53:16 <inerkick> I hope someone who is into web site development share ideas over Haskell's way
04:53:58 <quchen> fsestini: Do you know about scoped type variables?
04:54:23 <quchen> fsestini: If not, have a look at -XScopedTypeVariables: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#scoped-type-variables
04:55:12 <fsestini> quchen, I don't, I'll have a look. Thanks
05:15:50 <roelof> I have this exercise : http://lpaste.net/153314 . I think the int could be the same as the example the number of things. What could be the String then ? Or do I not have to use it 
05:16:10 <roelof> This is a exercise of the Haskell book 
05:17:59 * hackagebot hedis 0.7.1 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.1 (k_bx)
05:23:09 * hackagebot turtle-options 0.1.0.2 - Collection of command line options and parsers for these options  https://hackage.haskell.org/package/turtle-options-0.1.0.2 (elaye)
05:23:09 * hackagebot hedis 0.7.1 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.1 (k_bx)
05:48:05 * hackagebot haskell-kubernetes 0.3.2 - Haskell bindings to the Kubernetes API (via swagger-codegen)  https://hackage.haskell.org/package/haskell-kubernetes-0.3.2 (aaronlevin)
05:51:23 <roelof> no one who can help me ? 
05:52:09 <kadoban> roelof: It's hard without the context of what the TooMany typeclass does.
05:54:21 <roelof> kadoban:  this is the source of the code I have to adapt : http://lpaste.net/153316
06:00:34 <sbrg> roelof: one plausible implemention is tooMany (string, int) = length string > int
06:01:59 <roelof> oke, so you compare if the string is longer then a certain length . sbrg 
06:02:25 <sbrg> yes. 
06:02:39 <roelof> sbrg:  thanks 
06:02:53 <roelof> I think I can implement that 
06:03:20 <sbrg> that's one possible implementation. I don't know what it's supposed to do
06:03:22 <sbrg> but it makes some sense
06:04:00 <roelof> Another question : Can I somehow check a version of a library I installed with stack install.  So I can check for example which version of servant is installed 
06:04:28 <roelof> sbrg:  thanks again. IM thinking a while how to solve it 
06:11:48 <roelof> Another question : Can I somehow check a version of a library I installed with stack install.  So I can check for example which version of servant is installed 
06:13:00 <cocreature> roelof: "stack exec ghc-pkg -- describe servant" should do the trick
06:13:57 <cocreature> or stack exec ghc-pkg -- field servant version if you only care about the version
06:15:38 <roelof> cocreature:  thanks, The project uses a old version :(  it needed to use the version I had installed locally , bummer 
06:15:52 <roelof> now trying to find out how to solve this 
06:16:28 <sm> I type stack exec -- ghc-pkg ... a lot, I think I'll make a "stack pkg" alias 
06:17:29 <kadoban> I've never once found a reason to do that ‚Ä¶ what do you use it for?
06:17:59 <cocreature> I just used it for the first time to check if my tip was actually correct :)
06:18:21 <sm> troubleshooting.. checking if a package is really in the local stack db, and what version it is
06:18:55 <sm> mainly the latter
06:19:12 <roelof> kadoban:  im doing the servant tutorial and try to find out if Im using the right version so I can solve a problem 
06:19:22 <sm> I like that field command, thanks
06:21:09 <kadoban> With stack it's usually obvious if it's using the correct version ‚Ä¶ it is. Heh.
06:21:47 <roelof> I wanted to use the upcoming version and that one is not in stack 
06:21:52 <sm> function stack-ver()
06:21:52 <sm> {
06:21:52 <sm>     stack exec -- ghc-pkg field $1 version
06:21:52 <sm> }
06:21:55 <sm>  
06:26:16 <sm> or better: alias stack-list="stack exec ghc-pkg list"
06:28:14 <roelof> Is this good code : http://lpaste.net/153317 ?  it's a solution for this challenge : http://lpaste.net/153314
06:28:54 <kadoban> roelof: Seems nice to me
06:31:05 <roelof> kadoban:  thanks, This is a very challenging chapter about Algebraic datatypes . The book keep on getting harder and harder 
06:32:33 <kadoban> :)
06:33:04 <roelof> kadoban:  why a smile ? 
06:33:15 <luigy> :(
06:42:46 <Stratege> out of curiosity, can someone explain to me what an Algebra is or what a Coalgebra is? (or has some decent resource for finding out, http://hackage.haskell.org/package/algebra-4.2/docs/Numeric-Algebra.html has left me rather confused)
06:43:33 <kadoban> roelof: Just a friendly smile since I had no other response.
06:43:41 <jorr> There's a really good stackoverflow answer here: https://stackoverflow.com/questions/16015020/what-does-coalgebra-mean-in-the-context-of-programming
06:43:49 <jorr> At least, I always liked it.
06:44:24 <jorr> Actually I'm rereading it and it's kind of terrifying.
06:45:11 <Stratege> jorr thanks a lot, it's a lot less terrifying that direct exposure to ekmett.
06:45:18 <jorr> Stratege: how are you with understanding Functors?
06:45:20 <Stratege> (or ekmett's code, rather)
06:45:36 <jorr> Yes, just looking at ekmett packages is too much for me, too.
06:45:57 <Stratege> eh, I can use them, I'm decently good at figuring out if something's a functor, but the second I hear a mathematician start talking about them I'm lost.
06:46:38 <jorr> That's probably good enough.  Have you been exposed to mathy stuff like group theory?  Or are you kinda familiar with monoids?
06:47:11 <roelof> Does every instance needs a own class  ? 
06:47:44 <Stratege> well minor exposure to math directly, I prefer approaching it via Haskell. Since having types and a compiler (and a fixed notation that can't be arbitrarily deviated from...) is helpful.
06:47:55 <jorr> I think you can think about algebras in the Haskell context as collections of elements with rules to combine some elements to get a new one.  Like monoids form an algebra, and have one way to combine two elements to make a new one, and also have a way to get an element out of nowhere (mempty).
06:47:59 <Stratege> And yes I'd say I'm pretty familiar with Monoids (and as a result the Category typeclass)
06:48:19 <jorr> But there are other things like groups, etc, with some more structure.  Or you could have algebras with operations that take three elements and produce another one.
06:49:11 <jorr> You can think about monoid as something like having an () -> m method and a m -> m -> m method... which you could encode in an ADT in some way.
06:49:23 <Stratege> jorr thanks a lot for the stackoverflow post, it's great and just what I was looking for.
06:49:43 <jorr> But either of the two methods takes some shape of `m`s and produces and `m`.
06:50:16 <jorr> So generally an algebra in Haskell works with some functor over a type `a` and can produce a type a through the algebra reduction method things.
06:50:40 <jorr> So that's why you get something where an algebra is just a function from f a -> a.
06:50:47 <jorr> That's... maybe a terrible explanation?
06:52:10 <Stratege> jorr the post you linked already explained it awesomely well :)
06:52:24 <jophish>  
06:53:06 <jorr> Ha, thank goodness.
07:00:21 <barrucadu> roelof: What do you mean?
07:03:38 <barrucadu> jorr: That answer is a good explanation. Finally I know *why* an f-algebra is what it is :)
07:15:00 <jophish> I wish haddock supported latex in the comments
07:16:31 <cmotoche> Hey guys I'm getting an TlsExceptionHostPort when building a project in travis against lts-3.2 with stack. Do you know why this could happen?
07:19:01 <kadoban> cmotoche: Is it transient? It's probably just a connection error.
07:19:23 <kadoban> cmotoche: Do you know what operation stack in doing when that happens?
07:21:28 <cmotoche> Yeah, I guess it was just a connection error, because I restarted the job again and it works.
07:22:48 <Maplicant_> Does anyone recommend vim2hs?
07:26:46 <phaazon> hm, I‚Äôm looking for a way to force ‚Äúinterpreters‚Äù of my abstraction to implement some instances (through a type Foo a :: Constraint in the typeclass)
07:28:18 <phaazon> I guess the best solution is to implement the typeclass with a lot of several functions, per type, and put those in the typeclass
07:43:01 <phaazon> oh, I actually found a way!
07:43:12 <phaazon> with a Constraint! not a typeclass!
07:43:18 <phaazon> closed type family like
07:43:34 <phaazon> type family Foo a :: Constraint where { Foo Int = (); Foo Float = ()‚Ä¶ }
07:43:35 <phaazon> :)
07:44:11 <Hersh> Ola??
07:44:17 <phaazon> salut Hersh 
07:45:13 <Hersh> Can anyone here please tell me if the NixOS packages have the latest build of Haskell platform?
07:45:36 <bartavelle> phaazon, are you trying to prove that with strange extensions even death may die?
07:46:55 <phaazon> bartavelle: I‚Äôm trying to force people to implement some instances to be considered to correct interpreters
07:49:30 <bartavelle> but the set of instances to implement is dependent on some type variable ?
07:49:54 <phaazon> what do you mean?
07:50:24 <bartavelle> it seems like I never understand your questions, or I never understand what kind of convoluted dark magic you might be doing :)
07:50:57 <phaazon> bartavelle: I have several typeclass which represent my API
07:51:08 <phaazon> the implementations live in packages
07:51:19 <phaazon> the idea is that I need to enforce implementations to implement some instances
07:51:30 <phaazon> for associated type families constraints
07:51:51 <bartavelle> I don't understand that last sentence
07:52:01 <phaazon> ok
07:52:02 <phaazon> imagine this:
07:52:14 <bartavelle> " type families constraints"
07:52:19 <phaazon> class API m where { type Foo m :: Constraint }
07:52:35 <phaazon> an instance of API is an implementation, an interpreter
07:52:46 <phaazon> now, I want those instances to actually define Foo with several instances
07:52:48 <tdammers> this is peculiar
07:53:06 <phaazon> and the set of instances is fixed
07:53:11 <tdammers> stack install fails with ExitFailure (-7), but doesn't tell me what actually goes wrong
07:53:13 <bartavelle> ohhh
07:53:22 <phaazon> so I go with
07:53:32 <phaazon> outside of the API¬†typeclass:
07:53:39 <luigy> stack install -v ? maybe hints a bit more
07:53:54 <phaazon> type family EnforcedFoo a :: Constraint where { EnforcedFoo Int = (); EnforcedFoo Float = () }
07:54:08 <phaazon> and then, I can tag methods in API which need the Foo constraint with EnforcedFoo
07:54:20 <phaazon> forcing the instances of API to define those instances
07:54:47 <tdammers> hmm, I can run that step manually
07:54:53 <phaazon> I guess I could use a more general type, like Enforce :: Constraint -> * -> Constraint
07:55:03 <phaazon> and use Enforce Foo instead
07:55:10 <phaazon> hm wrong kind
07:55:14 <tdammers> zsh: bus error (core dumped)   --builddir=.stack-work/dist/x86_64-linux/Cabal-1.22.4.0 build exe:blah
07:55:23 <phaazon> Enforce :: (* -> Constraint) -> Constraint
07:55:57 <phaazon> but I‚Äôm hitting issue with that way of doing
07:56:01 <bartavelle> phaazon, why can't you   "class (constraints here) => API m where" ? I believe I might not actually understand what you are saying
07:56:11 <phaazon> I can‚Äôt see how to inject constraint
07:56:12 <phaazon> like
07:56:28 <phaazon> (Eq a) => EnforcedFoo (Maybe a) = ()
07:56:49 <phaazon> ^ that doesn‚Äôt work
07:56:57 <phaazon> bartavelle: I don‚Äôt get what you just said
07:57:06 <bartavelle> I don't get anything you said :)
07:57:15 <phaazon> hm
07:57:17 <bartavelle> do you have actual code somewhere?
07:57:19 <phaazon> you said ¬´ oooh ¬ª :D
07:57:21 <phaazon> yeah, wait
07:57:29 <bartavelle> yeah I thought I understood at some point!
07:57:44 <phaazon> https://github.com/phaazon/luminance/blob/master/src/Graphics/Luminance/ShaderDriver.hs
07:57:46 <bartavelle> clearly I didn't
07:57:58 <phaazon> the createProgram will soon be corrected
07:58:09 * hackagebot hlint 1.9.29 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.29 (NeilMitchell)
07:58:17 <phaazon> line 62 will have an extra (Uniform a) => in the 2-ranked function
07:58:41 <acarrico> Hi all, another beginner Q. Incoming paste of replicate' from learn-you-a-haskell (do you use the acronym LYAH?):
07:58:57 <phaazon> I guess the simple way to go is to provide a method for each type
07:59:04 <phaazon> but it‚Äôll make the typeclass explode :D
07:59:04 <phaazon> like
07:59:16 <phaazon> uniformF, uniform2F, uniform3F‚Ä¶
07:59:24 <bartavelle> phaazon, oic!
07:59:28 <phaazon> oic?
07:59:33 <bartavelle> oh I see
07:59:39 <phaazon> ok :)
08:00:07 <bartavelle> this is tricky though
08:00:16 <acarrico> hmm, that didn't show up. Anyway here it is: http://lpaste.net/153318
08:00:18 <phaazon> yeah it‚Äôs a nice used of closed type families 
08:00:22 <phaazon> but anyway, I‚Äôm stuck
08:00:27 <phaazon> I cannot inject constraints in them :(
08:01:09 <bartavelle> but what's wrong with having the missing constraint produce error messages somewhere else? because of the package boundary ?
08:01:19 <acarrico> I tried using (pred n), instead of using (n - 1) as the book does.
08:01:39 <phaazon> bartavelle: well I need to state that those types should have an instance in the implementation
08:01:46 <phaazon> I haven‚Äôt found any way to do that correctly yet
08:01:54 <acarrico> I figured out that I needed to add (Enum i) to the type (a type constraint?)
08:02:41 <acarrico> But now replicate, replicate', and replicate'' all have different types. I suspect there is a lesson for me here, but I'm not sure what it is. Style?
08:02:43 <tdammers> what *is* a bus error anyway
08:02:47 <phaazon> bartavelle: I could also do this:
08:02:55 <phaazon> type Uniform m :: Constraint
08:02:59 <phaazon> in the typeclass
08:03:02 <phaazon> and then use that constraint 
08:03:14 <phaazon> but if I do this, I drive my types with the implementation, which is wrong
08:03:19 <phaazon> I wont the other way around
08:03:28 <phaazon> want*
08:08:10 * hackagebot idris 0.10.1 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.10.1 (EdwinBrady)
08:08:32 <tekkkz> Could anybody have a look here please: https://bpaste.net/show/4b762bd6ca9c question is included there?
08:08:34 <cocreature> phaazon: why do you want to enforce the constraints in the first place? if you use them they should be enforced at the use site and if you don‚Äôt use them don‚Äôt enforce them
08:08:55 <phaazon> cocreature: to provide them in the interface
08:09:07 <phaazon> because the API will be the only part of the interface
08:09:49 <phaazon> maybe I‚Äôm going too overkill and that I should use a free monad, but I¬†think free monads are just a way not to use typeclasses in disguise
08:10:07 <phaazon> (even though I‚Äôd use free monads for EDSL or languages, but this is not what I‚Äôm doing)
08:10:17 <phaazon> I‚Äôm trying to implement a loosely-coupled framework
08:11:42 <phaazon> the single solution I see is to create as many methods as types
08:11:51 <phaazon> and implement the typeclass myself with the methods
08:11:59 <phaazon> that sucks but I really don‚Äôt see any other way :/
08:13:49 <lyxia> tekkkz: Why "" ? words does not produce empty words anyway
08:19:18 <mnoonan> phaazon: what about a single method with type "(TC1, TC2, ..., TCn) => ()" ?
08:24:34 <combinator> @pl \a b g -> (b & (a & g))
08:24:36 <lambdabot> flip ((.) . (&)) . (&)
08:34:17 <phaazon> mnoonan: ?
08:34:32 <phaazon> I think this is all filthy
08:34:38 <phaazon> I need to find a better way to do that
08:34:45 <mnoonan> at least it localizes the filth :)
08:34:48 <phaazon> because my type are not injective :/
08:34:53 <phaazon> types*
08:35:09 <phaazon> for instance, Texture2D is an associated type in the TextureDriver
08:35:10 <tekkkz> lyxia, nono you missunderstood, read for single tpye description again
08:35:28 <phaazon> so, (TextureDriver m) => Texture2D m could be anything
08:35:36 <phaazon> if a driver defines Texture2D m = Int
08:35:46 <phaazon> it‚Äôll be completely fucked up
08:35:57 <phaazon> because the Int instance also has to be defined
08:37:39 <phaazon> or, I could define a <|> Constraint :D
08:37:52 <phaazon> yeah, stupid idea
08:39:33 <lyxia> tekkkz: I really don't understand the problem.
08:41:00 <phaazon> I think the idea of mnoonan is actually quite good :D
08:41:18 <phaazon> it‚Äôs heavy, but it‚Äôll work
08:41:34 <phaazon> and I guess I can make a default value
08:41:35 <phaazon> like
08:41:53 <phaazon> foo :: (A m,B m,C m,D m‚Ä¶) => m (); foo = pure ()
08:53:40 * hackagebot generic-deriving 1.10.3 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.3 (ryanglscott)
08:58:40 * hackagebot base-orphans 0.5.2 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.5.2 (ryanglscott)
09:10:53 <Marqin> Is there maybe some difference in memoization in those two functions http://lpaste.net/153320 ?
09:11:35 <Marqin> I just want to be sure "words cont" will be run only once 
09:12:06 <glguy> Marqin: Those two are identical
09:12:27 <vkt> How can I infer the Kind of a Type which can be instantiated as the following class: class Arrow where liftArrow :: (a->b->c)-> arrow a b c?
09:12:54 <glguy> Marqin: and in both cases words cont will be evaluated twice
09:13:13 <glguy> Marqin: If you want to share the values between the two uses you can name it with a let
09:13:40 * hackagebot irc-core 1.1.4 - An IRC client library and text client  https://hackage.haskell.org/package/irc-core-1.1.4 (EricMertens)
09:15:21 <lpaste> glguy annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/153320#a153321
09:15:48 <Aleksejs> Hello, I have a list of triples in state. I need a function that gets a triple (a,b,c) as an argument, and looks for triple in list where first and second elements are equal to a and b respectively. If it finds that then it replaces third element with c. If not, then it just appends (a,b,c) to the end of list
09:16:29 <glguy> Marqin: There's a cleaner version that avoids extra computation and deals with the possible failure
09:17:01 <glguy> Aleksejs: You'll have to write that function, you're not likely to find it in a library
09:17:36 <glguy> Aleksejs: You might consider using    Map (a,b) c, instead of [(a,b,c)]
09:18:27 <Marqin> glguy: why words will be run twice? why it wont memorize?
09:18:49 <glguy> Marqin: because GHC doesn't generally do common subexpression elimination (CSE)
09:19:11 <glguy> It's not an obvious win and can have negative repercusions on memory behavior
09:19:41 <glguy> Marqin: check out the annotation added to your paste
09:20:23 <glguy> You should strongly prefer pattern matching on lists to using head/tail when its possible (as it is here)
09:20:49 <Marqin> glguy: I'm just reading two numbers that are divided by a space
09:20:58 <glguy> I saw that
09:21:15 <Marqin> but next there will be possibility of very long line of numbers divided by spaces
09:21:26 <Marqin> so I don't want to run words too many times
09:21:43 <glguy> Yeah, so you'll just name that value
09:23:17 <Marqin> is that <$> some new addition to haskell? I've learned it some years ago
09:23:19 <kadoban> Is there any advanced material on structuring complicated parses in Parsec's style? It seems quite tricky to get right such that the code isn't a shitheap and such that the errors on incorrect parses are actually helpful.
09:23:40 <kadoban> I've got it so I think I'm pretty close to it parsing everything correctly, but the code isn't nice and the errors are basically complete shit.
09:23:53 <glguy> If you're dealing with lots of lines of numbers separated by spaces you should name that, make a getLineInts :: IO [Int]
09:24:43 <glguy> getLineInts 07= map read 07. words 07<$> getLine
09:25:26 <glguy> If you're dealing with more than a few numbers and performance is the concern you can do better going via ByteStrings instead of Strings there
09:26:00 <glguy> (guessing this is the format specified by some programming challenge where lines of space delimited numbers are common)
09:26:14 <glguy> <$> is the operator name of fmap
09:26:19 <kadoban> Marqin: <$> is just an alias for fmap, but it comes from Applicative style so it's newer than some things, like Monad.
09:30:41 <Marqin> glguy: yeah, I'm just challenging myself and doing algorithm classes not in C++ like most but in Haskell
09:31:03 <Marqin> glguy: and it will be checked by something like spoj, so input/out had to be strict
09:32:32 <Marqin> "Not in scope: `<$>'" :/ so it's too new for that system there
09:32:51 <glguy> Marqin: On some systems it's in Data.Functor. Otherwise you can use fmap
09:32:56 <geekosaur> import Control.Applicative
09:32:58 <kadoban> Marqin: It's from Control.Applicative usually.
09:33:33 <eacameron> Or Data.Functor more directly
09:34:30 <sbrg> kadoban: I hear megaparsec's error messages are much better than parsec's, and it's almost a drop-in replacement, I believe. That might get you somewhere.
09:35:18 <Marqin> geekosaur: thx
09:37:45 <kadoban> sbrg: I suspect it's more the way I had to formulate my parser to get it right, though I could try I suppose.
09:43:58 <Marqin> Is there some "import if not imported" so I don't get "The import of ‚ÄòControl.Applicative‚Äô is redundant" warning/error on mine GHC? ( when I produce code for GHC that does not auto imports Control.Applicative )
09:44:34 <levi> Marqin: You can turn off that particular warning, but other than the warning that's exactly what import statements do.
09:44:55 <scshunt> Control.Applicative isn't automatically imported
09:45:02 <kadoban> Marqin: Unfortunately not. You can use CPP to choose to or not, or there's some weird trick involving explicitly importing Prelude that for some reason shuts up that warning.
09:45:08 <scshunt> whatever symbols you're using from it will be
09:45:38 <Marqin> scshunt: it's on machine from which i'm now writing
09:45:53 <scshunt> Marqin: that sounds wrong.
09:45:58 <scshunt> what symbols are you using from it?
09:46:28 <kadoban> scshunt: Not sure what you're finding hard to believe. In older GHC, <$> isn't in Prelude. In newer, it is. So if you want to support both of them without warnings, you run into this.
09:46:29 <Marqin> scshunt: <$>
09:47:57 <adelbertc> has anybody worked with the Bitraversable laws before? i'm looking at https://github.com/ekmett/bifunctors/blob/master/tests/BifunctorSpec.hs#L283 and translating it to Scala, but it's not working on that first naturality law
09:48:23 <adelbertc> just looking at it it seems it wouldn't hold given the functions passed to bitraverse are different - one composed with `t :: c a -> c a` and one that's not
09:49:28 <adelbertc> Hackage docs say `bitraverse (t . f) (t . g) ‚â° t . bitraverse f g for every applicative transformation t` - does that mean `t` is `forall a. c a -> c a` ? and also the code doesn't show that `t . bitraverse f g` part on the other side
09:50:19 <scshunt> kadoban: that's different from saying that Control.Applicative is imported by default though
09:50:50 <scshunt> Marqin: use a conditional compilation based on GHC version
09:50:53 <shachaf> adelbertc: It looks like that law is missing one use of t, yes.
09:51:15 <kadoban> scshunt: The difference is so pedantic in context that I'm not even really sure what you're objecting to.
09:52:28 <Marqin> scshunt: I cannot modify compilation there. I can only submit single .hs file 
09:52:44 <Marqin> scshunt: so i'll just look for flag to supress this warning here
09:52:57 <adelbertc> shachaf: and is t expected to be a natural transformation from c to c? since the result of bitraverse on the right side is `f (p c c)` and the usage on the right side is on `f c` ?
09:53:53 <shachaf> It sounds like it's expected to be more than a natural transformation.
09:53:57 <kadoban> Marqin: Try just: after all of your real imports, import Prelude   . I believe that removes the warning and is probably the easiest way that doesn't have other consequences.
09:54:28 <shachaf> See https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html
09:54:42 <shachaf> t (pure x) = pure x; t (x <*> y) = t x <*> t y
09:55:19 <adelbertc> ah got it
09:55:31 <adelbertc> cool, thanks shachaf 
09:55:43 <adelbertc> ill file a ticket on bifunctors for the test
09:59:21 <saurabhnanda> hey there, is there a way to check what typeclasses are implemented by a certain type?
09:59:37 <Marqin> I found better solution
09:59:41 <Marqin> #if __GLASGOW_HASKELL__ < 710
09:59:44 <Marqin> then import
09:59:53 <saurabhnanda> for example, how do I check if a certain type is a Functor or a Monoid?
10:01:21 <Hexapoder> Hi there ! There is noob haskell learner here. I need an advice guiding me to my path in my hobby in robotics ( with some ai in the future) with haskell. Could someone help me ? I am  in irc for more tahn 10 years sorry if did not follow the rules.    
10:01:27 <srhb> saurabhnanda: In ghci the best you can do is :i Type
10:01:43 <srhb> saurabhnanda: This only works if the instances are actually loaded, so it's not as useful as you might think.
10:02:04 <srhb> saurabhnanda: But basically, if you think something should have one of the more common instances, it's probably there, somewhere, with the right import. :-)
10:02:06 <Cale> Hexapoder: I'm sure if you ask questions, people will generally try to help...
10:02:25 <Cale> I don't know much about using Haskell for robotics specifically
10:02:37 <Hexapoder> ok
10:05:06 <saurabhnanda> srhb: got it thanks
10:05:18 <saurabhnanda> srhb: it works for Monoid, Monad, Applicative, Functor, etc. because they are almost always there
10:05:59 <saurabhnanda> srhb: was trying to make sense of the weird <*> and <$> notations in Aeson JSON parsing
10:06:03 <Hexapoder> I want to communicate hasskell with microcontroller ( intel edison 1Gb memmory)  i cannot imagine how that would be . Haskino can controll the board but does it require full haskell to be installed inside edison and there will be large room for my code? Option 2 is netwire : How will i be communicaitng with the microcontroller  
10:06:12 <srhb> saurabhnanda: Also known as Applicative notation. :)
10:07:03 <Marqin> Hexapoder: can't you just crosscompile for Atom processor?
10:08:47 <Hexapoder> That is the option for newtwire i guess . Ok good to know . Is this the best choice ?
10:09:41 <Marqin> Hexapoder: what is best?
10:10:47 <Hexapoder> flexible to add ai with less efford. only to focus as much haskell stuff 
10:11:23 <saurabhnanda> is <*> left associative or right associative?
10:11:24 <liste> Hexapoder: you don't need to install GHC inside the edison
10:11:33 <liste> s/the edison/edison
10:11:34 <glguy> saurabhnanda: Type :i <*> in GHCi
10:11:50 <liste> Hexapoder: you can compile the binary on another computer and transfer it
10:12:37 <saurabhnanda> glguy: done that. how do I make sense of the output?  infixl <4> means? infixL means left associative?
10:12:41 <glguy> yeah
10:12:52 <liste> @hackage netwire -- Hexapoder do you mean this?
10:12:54 <lambdabot> http://hackage.haskell.org/package/netwire -- Hexapoder do you mean this?
10:13:08 <Hexapoder> how would that be suitable with netwire ?  
10:13:11 <srhb> saurabhnanda: And the number is the precedence.
10:13:17 <Cale> saurabhnanda: and the number indicates precedence, with higher numbers binding more tightly to their arguments
10:13:32 <saurabhnanda> got it, thanks srhb Cale & glguy
10:13:42 * hackagebot pretty-compact 2.0 - Pretty-printing library  https://hackage.haskell.org/package/pretty-compact-2.0 (JeanPhilippeBernardy)
10:13:49 <srhb> I always get that mixed up. Clearly it should be infixl VeryVeryVeryVeryHigh etc.
10:13:50 <Hexapoder> thats the package
10:13:54 <srhb> Numbers suck.
10:13:58 <liste> Hexapoder: you can use netwire, but it doesn't do any IO
10:14:05 <liste> it's just for structuring your program
10:14:06 <saurabhnanda> so, now I need to REALLY understand what's happening here: parseJSON (Object v) = VersionResponse <$> v .: "version" <*> v .: "enabledFeatures"
10:15:14 <srhb> > (+) <$> Just 2 <*> Just 3
10:15:16 <lambdabot>  Just 5
10:15:19 <srhb> To take a simpler example.
10:15:26 <Hexapoder> liste that is my question ? i am noob on programming too . I need a path
10:15:36 <felixschl> hi!
10:15:56 <srhb> saurabhnanda: Do you understand fmap? (<$>)
10:16:10 <saurabhnanda> srhb: yup, I get that
10:16:21 <srhb> saurabhnanda: Ok, so fmap gives you (a -> b) -> f a -> f b
10:16:25 <saurabhnanda> so (.:) returns Parser a which is an applicative
10:16:35 <srhb> saurabhnanda: <*> gives you f (a -> b) -> f a -> f b
10:17:19 <liste> Hexapoder so you want make a program with components both for Edison and a desktop computer, so that the components would communicate with each other?
10:17:22 <felixschl> i'd like to ask a couple of newbie questions, if you don't mind: a) can stack be used to build distributables that run on windows also w/o further dependencies? b) what is the size of overhead of creating a dependency-free redistributable program written in haskell (and compiled using the stack tool)? - I am evaluating writing a command line utility in haskell and I took shellcheck as reference which my
10:17:23 <felixschl> system reports as 18MB (!).
10:17:28 <Cale> Hexapoder: If you weren't a beginner, I might recommend building something around reflex, which is the functional reactive programming library we've been using in production at the company I work for. It's rather nice, but since nobody has built a robotics application with it, it will likely need a new chunk of code written to interface with IO, and I wouldn't entirely be comfortable asking a beginner to write that bit.
10:17:52 <saurabhnanda> ah got it, got it, got it
10:18:10 <saurabhnanda> so VersionResponse is a data-contructor, which needs multiple arguments
10:18:30 <lifter> Why isn't there a strict version of "atomicWriteIORef" in "Data.IORef"?
10:18:44 <saurabhnanda> however, if I were to not bother with applicatives and simply fmap VersionResponse into (Parser a), then it would end up with a partially applied function inside a functor.
10:18:49 <srhb> saurabhnanda: That's right.
10:18:53 <srhb> saurabhnanda: To both. :)
10:19:01 <glguy> lifter: There is, atomicModifyIORef'
10:19:17 <lifter> glguy: I see, thanks.
10:19:25 <saurabhnanda> srhb: which also means, that this is using positional arguments? aargh!
10:19:34 <srhb> saurabhnanda: Sure, we always are!
10:19:37 <srhb> saurabhnanda: :-)
10:19:56 <saurabhnanda> srhb: what if my actual object is a record with a LOT of fields?
10:20:06 <saurabhnanda> just changing around the order is going to break code.
10:20:11 <srhb> saurabhnanda: You can always mix them around with a custom function
10:20:18 <srhb> saurabhnanda: foo a b c = bar b c a -- etc
10:20:25 <saurabhnanda> srhb: I'm actually saddened by how underwhelming records in Haskell are
10:20:26 <Cale> lifter: If you're only doing the write, then you can force the evaluation yourself with $! or seq
10:20:32 <srhb> saurabhnanda: It is sad, indeed.
10:20:39 <jle`> srhb: if the record has a lot of fields, it's often worth a look to rewrite it in record syntax
10:20:48 <jle`> er, * saurabhnanda 
10:21:00 <jle`> but yeah, it's awkward for Applicative syntax
10:21:02 <Hexapoder> So , is it the easiest way is to use C and call FFI haskell ?
10:21:07 <saurabhnanda> is there a way to rewrite this code using the record-oriented constructor?
10:21:11 <srhb> jle`: ApplicativeDo!
10:21:15 <jle`> that's the reason why 'applicative do' is so neat
10:21:17 <jle`> yeah, heh
10:21:18 <srhb> :-)
10:21:19 <Stratege> saurabhnanda do you know of a language that implements it in a nice way and still allows us to do pattern matching?
10:21:20 <Cale> lifter: It's that atomicModifyIORef takes a function which is going to be applied, and *that function application* is what the strict version forces the evaluation of.
10:21:23 <jle`> yay applicative do
10:21:33 <jle`> saurabhnanda: can i see the code?
10:22:09 <saurabhnanda> jle`: hang on
10:22:16 <Cale> Hexapoder: I'm not sure. What exactly do you need the program to do?
10:22:26 <srhb> saurabhnanda: Try rewriting it with do notation. ie do { firstArg <- v .: "version"; .... return $ Version firstArg ... }
10:22:36 <srhb> Then you can write the final line with a record instead.
10:22:49 <srhb> Then you get a monad constraint, but we can make that go away soon.
10:22:53 <jle`> you can even use RecordWildCards to make syntax nicer
10:22:55 <saurabhnanda> jle`: http://lpaste.net/153325 (this doesn't have the really huge JSON objects, but that shouldn't matter)
10:23:49 <saurabhnanda> srhb: there's another question. How does Haskell figure out which type to pick for (Parser a)?
10:23:54 <Hexapoder> Make lots of decision based on events (from sensors) and command back to microcontroller ( that is a robot)   
10:23:59 <srhb> saurabhnanda: By picking the only one that type checks.
10:24:04 <lpaste> jle` annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/153325#a153326
10:24:11 <srhb> saurabhnanda: Longer answer something something Hindley-Milner type inference.
10:24:14 <jle`> ^ saurabhnanda 
10:24:45 <jle`> the VersionResponse{..} captures all of the locally defined record field labels and packages them up
10:24:53 <jle`> fun times for all
10:25:07 <saurabhnanda> every application of (.:) returns a (Parser a). When I was playing around with it in ghci, you had to give it something like (:: Text) or something to let it figure out the actual type. How is it working with this data constructor?
10:25:21 <jle`> the type of each thing can be inferred
10:25:22 <lifter> Cale, would it make any sense to roll my own function: atomicWriteIORef' ior x = atomicModifyIORef' ior (const (x, ()))
10:25:26 <jle`> > [read "True", False]
10:25:31 <lambdabot>  [True,False]
10:25:34 <jle`> it knows that 'read "True" has to be a Bool
10:25:36 <srhb> saurabhnanda: Right, so the type of your program is more constrained. The type checker has more information from your surrounding program to pick the type.
10:25:37 <jle`> so it reads it as a Bool
10:25:44 <Hexapoder> :Cale  I need a way for my learning targets. It is a hobby at the end  but i take seriously
10:25:53 <jle`> in GHCi, there isn't enough information to figure out what you want, a lot of the time
10:25:59 <jle`> because you usually use it later in the future
10:26:05 <Cale> lifter: You could just have  atomicWriteIORef' r x = atomicWriteIORef r $! x
10:26:13 <jle`> and :set -XTimeTravel isn't implemented yet
10:26:18 <jle`> there are still some bugs in the implementation
10:26:41 <saurabhnanda> jle`: WHAT?! for {..} I can't imagine the code for how that's written!
10:27:06 <jle`> {..} just captures all of the variables in scope with names matching record fields
10:27:24 <jle`> @let data Foo = F { getFoo :: Int, getBar :: Bool } deriving Show
10:27:25 <lifter> Cale, I see, thanks!
10:27:27 <lambdabot>  Defined.
10:27:34 <jle`> > let getFoo = 10; getBar = True in F{..}
10:27:37 <Stratege> jle` ... that's pretty cool, didn't know that was a thing. Thanks.
10:27:38 <lambdabot>      Illegal `..' in record construction
10:27:40 <lambdabot>      Use RecordWildCards to permit this
10:27:43 <jle`> well, it would work if RecordWildCards was enabled
10:27:55 <jle`> the result of that would be F { getFoo = 10, getBar = True }
10:28:30 <Cale> Hexapoder: I guess I don't know what the API looks like for accessing the sensors and sending the commands. If it's reading and writing unix character devices and network sockets, that's pretty easy to do without FFI. If there's some C library which implements some trickier I/O that's required, then you might want to FFI to it.
10:28:32 <saurabhnanda> jle`: that's pretty cool, but I'm not sure how the lexer,parser,compiler,voodoo work together to get this done
10:28:32 <jle`> @let {-# LANGUAGE RecordWildCards #-}
10:28:33 <Stratege> (welcome to GHC, where everything requires an extension)
10:28:34 <lambdabot>  Parse failed: Parse error: EOF
10:28:37 <jle`> hm, was worth a shot
10:28:43 * ski . o O ( `[$ado | version <- v .: "version"; enabledFeatures <- v .: "enabledFeatures" ; VersionResponse { .. } |]' , using `Control.Applicative.QQ.ADo' <https://hackage.haskell.org/package/applicative-quoters> )
10:29:05 <jle`> nice :O
10:29:17 <saurabhnanda> what was that earlier about applicative do?
10:29:24 <saurabhnanda> is that another technique to achieve this?
10:29:28 <jle`> well, it's not really an issue here
10:29:39 <jle`> so it's no big deal
10:29:45 <saurabhnanda> is there any way to de-sugar a 'do' block?
10:29:49 <Stratege> applicative do is making do notation work with just an applicative constraint instead of a monad constraint, as jle said, not important here.
10:30:11 <Stratege> yes, do blocks, currently, desugar into usages of (>>=) (and I suppose (>>))
10:30:16 <jle`> @undo do { x <- m; return x }
10:30:18 <lambdabot> m >>= \ x -> return x
10:30:51 <mniip> @pl m >>= \ x -> return x
10:30:54 <lambdabot> m
10:30:55 <ski> @undo do ver <- v .: "version"; enFs <- v .: "enabledFeatures" ; return (VersionResponse { version = ver,enabledFeatures = enFs })
10:30:56 <lambdabot> v .: "version" >>= \ ver -> v .: "enabledFeatures" >>= \ enFs -> return (VersionResponse{version = ver, enabledFeatures = enFs})
10:31:17 <Hexapoder> Cale : thanks i need a deeper search for io , continious data flow  and triggers with haskell . 
10:31:31 <jle`> saurabhnanda: yeah, on the point about {..}, people do often complain about GHC haskell's syntax being so bloated and crazy
10:31:41 <jle`> but
10:31:50 <jle`> it's useful >_______>
10:32:02 <jle`> for some reason people come into haskell looking for a scheme-like syntax efficiency/elegance
10:32:12 <jle`> maybe because people try to sell haskell its syntax so often
10:32:23 <jle`> s/haskell its/haskell with its
10:32:31 <saurabhnanda> jle`: is this de-sugaring right? http://lpaste.net/153325#a153328
10:32:45 <saurabhnanda> jle`: I did that de-sugaring by hand, to understand what's going on here.
10:32:47 <jle`> saurabhnanda: yes that is correct
10:33:11 <jle`> well, a more proper desugaring would be to use version for x and enabledFeatures for y
10:33:18 <jle`> actually, {..} isn't too complicated, now that i think about it
10:33:39 <srhb> It's very not-complicated and slightly scary. :-)
10:33:42 <jle`> VersionReponse{..} is just desugared to VersionResepose{ version = version, enabledFeatures = enabledFeatures }
10:33:47 <jle`> that's all :O
10:34:16 <srhb> So one had better get the names right or make sure they are all unique types.
10:34:17 <jle`> you just have to remember that the 'version' on the left hand side of the = is the record name, and the 'version' on the right hand side of the = is the variable/name of the thing to set it to
10:34:23 <Peaker> is writeIORef not atomic on any platform GHC works on?
10:34:34 <jle`> so it's no different than just writing VersionResponse{version = version, enabledFeatures=enabledFeatures} manually
10:34:40 <saurabhnanda> the undo command doesn't work in ghci?
10:34:46 <jle`> yeah, it's a lambdabot module
10:34:51 <jle`> beep boop
10:35:06 <jle`> you can install it locally and hook it up to ghci if you want, but it might be easier to just /q lambdabot
10:37:08 <saurabhnanda> why exactly does Aeson's (.:) return a Monad, i.e. (Parser a)? What's the real advantage of doing that?
10:37:29 <jle`> it doesn't return an 'a', it returns a Parser
10:37:34 <jle`> it returns a parser for an 'a'
10:37:44 <jle`> and using do notation, <$>, <*>, etc., you can combine parsers
10:37:49 <jle`> to create more complex parsers
10:38:20 <saurabhnanda> :k Parser
10:38:23 <lambdabot> Not in scope: type constructor or class ‚ÄòParser‚Äô
10:38:24 <jle`> the whole point of parseJSON is really not to parse anything, but to return a parser
10:38:27 <jle`> it's to describe a parser
10:38:32 <jle`> so maybe the name is a slight misnomer
10:38:38 <jle`> maybe it should be jsonParser
10:39:04 <ski> (also, a parser is not a monad. `Parser' itself is a monad. something of type `Parser T' (for any type `T') is not a monad, it's a parser)
10:39:38 <jle`> what you're doing with <$>/.:/do notation is describing a parser for your type, and you describe it by combining little mini-parsers (like v .: "blah")
10:40:09 <jle`> sort of like how you can describe complex IO actions in haskell by using do notation/<$>/<*> on little mini-IO actions, like putStrLn "hello"
10:40:39 <saurabhnanda> so how does one "run" this parser?
10:40:47 <jle`> main :: IO () doesn't actually do any IO, it's just a desciption of an IO action; parseJSON x doesn't actually parse anything, it just a description of a parser
10:40:56 <jle`> saurabhnanda: the Parser type usually offers an API
10:41:08 <jle`> if you dig around in the library you should be able too find it
10:41:09 <saurabhnanda> some monads have this weird record-oriented data constructor which can run/unwrap the inner value
10:41:26 <jle`> s/too/to
10:41:28 <saurabhnanda> I think I saw something called runExcepT or runEitherT
10:41:29 <ski> usually something like `parse :: Parser a -> IO (Maybe a)', possibly slightly more complex
10:41:41 <jle`> saurabhnanda: yeah, it varies from type to type/monad to monad
10:41:56 <jle`> and monads don't even necessarily have to have a "runner"
10:42:10 <jle`> it just depends on the specific type you're talking about and what API it decides to offer
10:42:42 <jle`> for the record (ha ha) i would consider runExceptT, runEitherT, etc. to be abstract API methods
10:42:55 <jle`> the fact that it's a record name is an implementation detail, it could have been implemented abstractly
10:43:12 <jle`> the recordness of it isn't the important part
10:43:28 <jle`> some people even consider it an abuse of record syntax
10:43:58 <jle`> (i use 'some people' to mean 'me' but in a way that absolves me of the responsibility to justify myself :) )
10:44:08 <srhb> saurabhnanda: In Aeson you often leave the choice of the parser implicit (by using the FromJSON instances)
10:44:19 <saurabhnanda> http://hackage.haskell.org/package/aeson-0.11.0.0/docs/Data-Aeson-Types.html#v:parse
10:45:07 * ski would like to be able to construct records using "message-dispatching" syntax ..
10:45:29 <ski> s/construct/define/
10:45:37 <saurabhnanda> why is the type signature of 'parse' so weird? Why is not parse :: Parser a -> a
10:45:51 <jle`> saurabhnanda: well, Parser a -> a doesn't quite work...where is the thing to parse?
10:46:02 <saurabhnanda> (.:) :: FromJSON a => Object -> Data.Text.Internal.Text -> Parser a
10:46:30 <jle`> saurabhnanda: right, a Parser is just a description of a way to parse something
10:46:31 <saurabhnanda> (parse) :: (a -> Parser b) -> a -> Result b
10:46:40 <jle`> so, you have your description of a way to parse something
10:46:46 <jle`> so ... now you need the thing you want to parse
10:47:17 <saurabhnanda> so, parse :: a -> Parser a -> a
10:47:37 <srhb> saurabhnanda: The x in Parser x is the resulting type, not the thing it parses.
10:47:38 <jle`> well
10:47:48 <jle`> if you already have an 'a', you wouldn't need to parse it, would you?
10:47:49 <saurabhnanda> parse (thing to parse) (parser) (result=thing)
10:47:59 <jle`> that's like parsing an Int into an Int
10:48:11 <jle`> you want to parse a something ('a' here) into the thing you want ('b' here)
10:48:47 <jle`> if you already have an 'a', and you want an 'a', there's no reason to parse anything :P
10:48:56 <srhb> You COULD have a completely monomorphic parser like parse :: String -> Parser Foo -> Maybe Foo -- which is what I think you're getting at.
10:49:03 <saurabhnanda> in a type signature, don't all variables represent a type?
10:49:10 <jle`> yes
10:49:22 <saurabhnanda> ah, got it
10:49:22 <ski> @type Text.Parsec.parse
10:49:24 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
10:49:41 <jle`> but `a -> Parser a -> a` means "i want an a, and i have an 'a' and a 'Parser a'" -- a sensible implementation would be to just return the 'a' you have :P
10:49:44 <jle`> and ignore the parser
10:49:47 <saurabhnanda> money quote: if you already have an 'a', and you want an 'a', there's no reason to parse anything :P
10:50:15 <saurabhnanda> so, parse :: b -> Parser a -> a
10:50:20 <srhb> saurabhnanda: Impossible.
10:50:27 <srhb> saurabhnanda: You need to pick a concrete b for that to work out.
10:50:31 <ski> s/b/String/
10:50:37 <srhb> Sorry, not concrete
10:50:39 <ski> (or some other token stream type)
10:50:41 <srhb> Eeek I might have summoned merijn now
10:50:47 <srhb> A _specific_ b :-)
10:50:48 <KaneTW> hide
10:50:59 <KaneTW> hide your children, hide your wifes
10:51:00 <KaneTW> :v
10:51:04 <jle`> yeah, except the way Aeson works, you have (a -> Parser b)'s everywhere
10:51:12 <ski> and, the parsing might fail, so you'd normally have `Maybe a' or `Either ParserError a' or something like that
10:51:19 <srhb> Which is fine, because you have a function from an a to a Parser b
10:51:26 <jle`> a bit of it is tied to how Aeson is structured
10:51:32 <saurabhnanda> ski: there's parseEither and parseMaybe for that
10:51:46 * ski nods
10:52:06 <saurabhnanda> so, I'm not clear why parse :: b -> Parser a -> a is not right?
10:52:21 <srhb> saurabhnanda: Because it's impossible for the Parser to create an `a` for any `b`
10:52:24 <saurabhnanda> b could be restricted to things which implement a certain typeclass
10:52:35 <srhb> saurabhnanda: It could, but that's a different type signature.
10:52:49 <srhb> Just as String -> Parser a -> a -- is a different type signature
10:52:59 <saurabhnanda> right, what about that?
10:53:00 <srhb> You're making very specific promises with the one you wrote (which you can't keep.)
10:53:09 <saurabhnanda> why isn't it just String -> Parser a -> a
10:53:21 <srhb> saurabhnanda: Oh, that answer is easy. People would like to vary the input type.
10:53:28 <jle`> it could be, there might be another utility function that offers that
10:53:30 <saurabhnanda> or to also include exception handling, String -> Parser a -> Maybe a
10:53:40 <srhb> Yes, both are fine and possible.
10:53:46 <srhb> but also locked to a specific input stream type.
10:53:53 <jle`> lots of options :D
10:54:26 <exio4> how the fun do you write a 'paper' on the implementation details of a small game
10:54:29 <exio4> fuck *
10:54:37 <saurabhnanda> I can't wrap my head around what parse :: (a -> Parser b) -> a -> Result b even means
10:54:55 <exio4> err, wrong chan, <_<
10:55:05 <srhb> saurabhnanda: It means, given a function from an `a` to a `Parser into type b` as well as an `a` to parse, you can get a `Result of b`
10:55:14 <exio4> ignore whatever I said, I am saying, and will say for a bit.
10:55:24 <saurabhnanda> what would you call the first argument to that function? (a -> Parser b)? What name can you give that thing?
10:55:30 <jle`> saurabhnanda: well, you have a bunch of those
10:55:37 <jle`> note that parseJSON has that exact signature
10:55:39 <srhb> saurabhnanda: Parser generator? That's a bit overloaded though...
10:55:56 <srhb> saurabhnanda: But that's what it _is_. It's the function that creates a Parser b, given an a.
10:56:08 <saurabhnanda> If I were writing documentation and had to explain what that argument MEANS, what would I call it?
10:56:17 <srhb> saurabhnanda: Here's a trivial one: yourParser . id
10:56:17 <jle`> "function to create a parser from an 'a'"
10:56:59 <srhb> actually, const yourParser is more fun.
10:57:47 <saurabhnanda> but, given a value of type 'a' why would I create a parser. I would just.... parse it
10:58:06 <saurabhnanda> however, if give a type 'a' (as opposed to value of type 'a'), I could create a parser for all values of type 'a'
10:58:15 <saurabhnanda> I'm lost in the dungeons of abstraction here, I think
10:58:20 <jle`> look at the type of parseJSON
10:58:34 <jle`> you don't have Parsers directly in aeson
10:58:38 <jle`> you have functions to create parsers
10:58:44 * hackagebot th-typegraph 0.33 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.33 (DavidFox)
10:58:46 <jle`> which is admittedly a bit weird, i always thought it was
10:58:59 <saurabhnanda> parseJSON :: FromJSON a => Value -> Parser a
10:59:04 <jle`> yes
10:59:25 <jle`> so to use that, you'd use parse parseJSON myVal
10:59:25 <saurabhnanda> wow, this is even weirder
10:59:38 <saurabhnanda> a function called parseJSON is not actually parsing my JSON, it's return a parser
10:59:57 <saurabhnanda> shouldn't it be parseJSON :: Value -> MyType
11:00:06 <jle`> that's what i said earlier
11:00:13 <srhb> It should totally be called jsonParser
11:00:16 <srhb> That would be clearer.
11:00:19 <jle`> parseJSON doesn't parse earlier, it just returns a parser
11:00:42 <jle`> so if you want, you could define parse' :: Value -> Parser a -> Result a
11:01:30 <saurabhnanda> I'm more confused
11:01:31 <jle`> and do parse f v = parse' v (f v)
11:01:58 <saurabhnanda> "return a parser" would mean that it returns a function, which then needs to be passed something, which will then return the final value
11:02:06 <jle`> it doesn't quite returna  function
11:02:10 <jle`> it returns a description of a parser
11:02:44 <saurabhnanda> HOWEVER // parseJSON (Object v) = VersionResponse <$> v .: "version" <*> v .: "enabledFeatures" // is returning a VersionResponse object. Not a function that, when passed an argument, will return a VersionResponse object.
11:02:56 <jle`> it's not returning a VersionResponse object
11:02:58 <srhb> No it isn't.
11:03:03 <jle`> it's describing how to parse a VersionResponse
11:03:25 <jle`> it returns a description of how you would parse a VersionResponse
11:03:26 <ski> a parser itself may or may not be implemented as a function. assuming it is abstract, you need a function (`parse') above to apply the parser to some given input, giving you a parsed result (or possibly an indication of parse error)
11:03:58 <jle`> the description is: "first, parse the "version" field, then parse the "enabledFeatures" field, and return the result of VersionResponse applied to those fields"
11:04:03 <jle`> it's a bit clreaer with do notation
11:04:41 <jle`> parseJSON doesn't actually parse anything, it just returns a description of "how to parse"
11:04:57 <jle`> and you build descriptions by combining simple descriptions/parsers with <$>/<*>/do notation etc.
11:05:16 <jle`> the 'parse' function is responsible for taking that description and actually using that description to parse something
11:05:27 <saurabhnanda> I give up
11:05:36 <srhb> saurabhnanda: If you didn't catch it the first time around, notice how parseJSON has a type that fits exactly into the first argument of parse
11:05:43 <saurabhnanda> I understood <*> and <$> that's enough haskell-fu for tonight, I guess :-)
11:05:54 <saurabhnanda> and the {..} magic
11:06:33 <saurabhnanda> srhb: I actually know how to make this work. But I'm not being able to appreciate WHY there are so many moving parts to the Aeson API. What' the higher order truth waiting to be revealed?
11:06:45 <srhb> saurabhnanda: More general = more better, clearly! :-)
11:06:48 <jle`> i don't quite agree with the API myself, i think I would have approached it differently
11:07:02 <jle`> so i might not be the best person to answer 'why'
11:07:06 <saurabhnanda> srhb: I'm comparing it to Ruby where you just call JSON.parse(obj) and get back a series of nested arrays/hashes and call it a day.
11:07:08 <jle`> but i am but a naive simpleton
11:07:17 <srhb> saurabhnanda: Which is great if you have one type.
11:07:33 <jle`> saurabhnanda: you can do that with aeson too
11:07:42 <jle`> and get a series of nested lists/hashmaps
11:07:47 <saurabhnanda> jle`: i tried doing that. It's not easy. Not easy at all.
11:08:01 <jle`> hm, really?
11:08:08 <jle`> i thought it was just one function
11:08:17 <saurabhnanda> jle`: it's possible. But you can clearly get a sense that the author didn't intend it to be used that way.
11:08:27 <jle`> yeah, it's possible.  and it's simple to do, but it's not the "haskell way"
11:08:34 <jle`> the "haskell way" is to parse things directly into a semantic data type
11:08:44 <jle`> that describes the structure of what you want
11:09:35 <jle`> it's possible to just parse it into nested lists/hashmaps and do "exploratory" stuff with it, but for real work, the 'haskell way' is to parse it directly into a data type you know the structure of :)
11:10:06 <saurabhnanda> jle`, srhb: I get that. In fact I'm dealing with a 150k LOC ruby project which doesn't define too many data types. Everything is a bunch of nested arrays/hashes and I know the pain. Which is why I started learning Haskell in the first place. To see if there is a better way to do these things. Get more type-safety into the picture. But a lot of times I just look at a package and wonder why the API had to be so complicated in the f
11:10:46 <jle`> well, if you alraedy know how to get things done, that's a good first step :)
11:10:50 <srhb> saurabhnanda: I can only say that you're answering the right questions, and have been all night, and you will eventually appreciate why this was done, even if you don't agree with the specific api of Aeson :)
11:10:52 <jle`> maybe after using it a while you'll learn how to appreciate it
11:10:56 <srhb> er, asking all the right questions*
11:11:11 <jle`> i definitely would have implemented it differntly if it were me
11:11:27 <saurabhnanda> I've not touched monad transformers, which I know will be another world of pain. How do I do IO, DB interaction, and logging in one function. God knows. Haven't gotten there yet.
11:11:54 <jle`> the key to avoiding monad transformer pain is to not work with monad transformers :P
11:12:05 <srhb> saurabhnanda: I like them! Especially for mocking things together.
11:12:06 <jle`> it's 2016
11:12:17 <srhb> What, 2016 is the year of extensible effects?
11:12:33 <srhb> ( :-P )
11:12:43 <jle`> heh, we've just have had better ways of describing effects than using concrete monad transformers for a while
11:12:59 <jle`> but it really doesn't have to be that bad, either
11:14:33 <saurabhnanda> I had a bad experience with JSONRpc or XmlRpc library, I think
11:14:39 <saurabhnanda> their examples just had very basic stuff
11:14:46 <saurabhnanda> how to add two numbers, etc.
11:15:45 <saurabhnanda> and I had to deal with talking to an RPC server which was returning extremely complex data types. How do I write a method signature for that? Dug deep and found how to do it, but just couldn't get it to work, because the API was way too generalized. It had to something to do with Conduits. That's when I gave up.
11:17:00 <srhb> saurabhnanda: It can be disheartening when your usual methods fail you. Again, I think most people think a lot of these abstractions are worth it, and once you know them you find things easier than they were. But until then, it's hard.
11:17:02 <jle`> there will be a day when conduits becomes natural to use :) but there are a lot of interconnected parts of the haskell ecosystem, it does get discouraging
11:17:05 <saurabhnanda> Probably over-generalization is also not good, sometimes. Make the 90% use-case dead simple, and make the 10% possible.
11:17:23 <jle`> also haskell's documentation story as a whole isn't always too great unfortunately
11:17:27 <srhb> saurabhnanda: Once you have the generalization, writing the simple case is usually dead simple (once you know how)
11:17:40 <srhb> saurabhnanda: But you probably know all this. Not sure if you're looking for encouragement :P
11:18:19 <Cale> Well, to be fair, conduit is *frequently* overkill.
11:18:38 <saurabhnanda> srhb: my little experience with haskell libs is that the APIs for the 90% simplified cases are generally not there. So one has to understand the underlying general abstractions and types that the author thought of and then work one's way up from there.
11:18:48 <srhb> saurabhnanda: Agreed. :)
11:18:54 <srhb> saurabhnanda: That's often the case.
11:20:04 <saurabhnanda> anyways, I've got JSON parsing covered, concurrency using threads & channels, and now I'm trying DB interaction
11:20:17 <saurabhnanda> hopefully will come back with a feature-complete version of my Telegram bot
11:20:53 <saurabhnanda> thanks for all the help everyone. srhb jle` ski Cale 
11:21:01 <saurabhnanda> good night
11:21:05 <jle`> np, happy haskelling!
11:21:39 <srhb> saurabhnanda: o/
11:21:40 <jle`> it's also good that you appreciate the pace of learning haskell, that you can't just pick it up and do things you are doing in your other languages right away
11:22:05 <jle`> i always tell people to remember how long it took them to learn programming from scratch to be able to get to the point they are at now, and compare it to learning haskell from scratch
11:22:19 <jle`> more often than not, they learn haskell faster ... but it's easy to lose sight of this
11:24:00 <Tritlo> With servant, how do I server index.html at the empty path?
11:24:11 <exio4> saurabhnanda: sqlite-simple is.. simple =)
11:24:34 <Tritlo> https://www.irccloud.com/pastebin/apSfLpMo/
11:25:08 <Tritlo> i.e. when I do `type WebApi = "" :> Raw`, I keep getting "not found"
11:25:12 <ARM9> is there a way to install ghc, happy, alex and cabal with stack in a non isolated location? the package manager for my so is way too outdated
11:25:57 <srhb> ARM9: Nix?
11:25:59 <ARM9> aye
11:26:04 <dcoutts> ARM9: I just grab the ghc binary from haskell.org and bung them all in /usr/local
11:26:09 <kadoban> ARM9: Any tools except ghc you just 'stack install whatever' and it gets put in ~/.local/bin/, which you should have in your PATH. GHC you can add the specific directory inside ~/.stack/ to your PATH if you like.
11:26:12 <srhb> ARM9: No, I mean. nix. As in Nix the package manager :P
11:26:24 <srhb> Oh, with stack, sorry.
11:26:46 <ARM9> srhb, ah fair enough, but yeah I'll see what nix has to offer
11:27:13 <srhb> ARM9: A giant binary cache of new haskell packages, for one. :-)
11:28:02 <ARM9> I'm open to suggestions as I've barely migrated from cabal to stack
11:28:58 <kadoban> ARM9: The times when you have to manually run GHC are pretty rare in my experience. If nothing else, there's 'stack ghc' The rest is already trivial with stack, as I mentioned above.
11:29:36 <ARM9> yeah, I just need a stable location to point my path for emacs integration
11:29:57 <srhb> ARM9: Your Emacs should probably use the sandbox too.
11:30:02 <srhb> Otherwise things get funky.
11:30:10 <dcoutts> ARM9: the traditional method is just /usr/local/{bin,lib}, which is what the ghc binary tarballs install to by default
11:30:25 <kadoban> Yeah, unless your editor integration understands stack, or you manually do something about it, things are probably not going to play too well anyway.
11:31:20 <dcoutts> ARM9: then obviously that overrides your /usr/ one from your package manager, and its already on the $PATH, everything will pick it up by default. Simple.
11:32:37 <kadoban> They already specified using stack though, in which case installing GHC manually isn't really useful.
11:34:09 <dcoutts> kadoban: surely stack will use the one on the $PATH?
11:34:40 <srhb> If it matches the resolver version, I think it will, yes.
11:34:42 <luigy> --system-ghc? or something like that
11:34:43 <kadoban> dcoutts: It will, but why bother? Extra work for dubious to no gain.
11:36:09 <srhb> Come to think of it, isn't the answer to the original question just stack install alex happy ?
11:36:17 <ddrscott> @help
11:36:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:36:30 <srhb> If "user" is non-isolated enough
11:36:40 <dcoutts> or equivalently cabal install alex happy :-)
11:36:41 <kadoban> srhb: That's part of the answer, and was given above. You can't 'stack install ghc' though, so that's the other part.
11:36:47 <srhb> Sorry. :)
11:36:48 <ARM9> I see, is there a recommended way to install ghc-mod and other such tools that don't generally rely on a particular ghc version? with stack
11:37:17 <Peaker> is Andrey Chudnov in #haskell?
11:37:33 <kadoban> ARM9: 'stack install ghc-mod' ?
11:38:47 <sleepynate> i had to struggle with that when moving to 7.10 as well
11:39:07 <luigy> I guess someone should make nice short intro videos about haskell tooling(stack, cabal friends) that go to the point like in https://egghead.io/lessons/javascript-intro-to-webpack
11:39:16 <sleepynate> stack install ghc-mod, put .local/bin in path before .cabal/bin, then run cabal configure again
11:39:21 <srhb> luigy: Tag, you're it!
11:39:23 <srhb> :-)
11:39:41 <sleepynate> then emacs was back to "just working"
11:40:10 <dcoutts> ARM9: ghc-mod unfortunately does depend on a particular ghc version, I think
11:41:19 <ARM9> ah alright, much appreciated ya'll
11:43:00 <luigy> srhb hehe, thought about it :)  
11:43:08 <luigy> oh ghc-mod can be a whole series on its own
11:43:19 <srhb> luigy: I'm sure it would be very much appreciated :)
11:43:23 <luigy> with multiple parts that have different endings
11:46:23 <mmaruseacph2> @query lambdabot 
11:46:24 <lambdabot> Unknown command, try @list
11:49:11 * hackagebot th-typegraph 0.33.1 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.33.1 (DavidFox)
11:54:12 * hackagebot xlsx 0.2.1 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.1 (KirillZaborsky)
11:58:09 <tdammers> update on the stack coredumping / Bus error issue: apparently it's related to hsass
11:58:50 <tdammers> when I go back to the last version of my code to not include hsass, it compiles cleanly, and after that it keeps working fine until I nuke .stack-work
11:58:59 <Peaker> "Warning: module not listed in Lamdu.cabal for 'lamdu' component (add to other-modules): Paths_Lamdu" <-- Paths_Lamdu is auto-generated by cabal. Does it still need to be mentioned to .cabal which generates it? weird!
11:59:19 <dcoutts> Peaker: yes.
11:59:21 <dcoutts> you're using it
11:59:32 <dcoutts> you don't have to use it
11:59:57 <Tertain> If there a way to make stack test print the results of the tests?
12:00:09 <Peaker> What does "Other-Modules" do? It's put into the sdist?
12:00:18 <johnw> it include it in the library
12:00:23 <johnw> but doesn't export it to clients
12:00:29 <johnw> so you can use it, but others cannot directly
12:00:32 <Peaker> What does it do for Executables?
12:00:49 <johnw> good question, I never tried that
12:01:11 <Peaker> The auto-gen Paths_* module is used by the executable, so I find it a bit weird..
12:01:50 <luigy> Tertain does it contain multiple local packages?
12:02:23 <Tertain> hm, yes.
12:02:33 <urbna> does anyone here know how to set msys gcc to the gcc that comes with ghc? I need it to install ghcjs on windows
12:02:35 <luigy> I guess in the meantime stack should at least start showing a warning when there are multiple local packages building the tests output will not be shown until a better solution is integrated
12:02:35 <urbna> https://github.com/ghcjs/ghcjs/blob/master/INSTALL.windows
12:02:55 <luigy> build output too
12:02:58 <Tertain> I see, is there a way to only run tests for a single package?
12:03:16 <hexagoxel> Peaker: i found the same, see https://github.com/commercialhaskell/stack/issues/1830
12:03:31 <luigy> stack test package1
12:03:43 <luigy> stack test package2
12:03:50 <luigy> that should work around it
12:03:58 <luigy> in the meantime xD
12:04:02 <Tertain> oh awesome, thanks :)
12:06:47 <hexagoxel> Peaker: i still am not sure if the warning is nitpicking or if there are real cases where not having it might cause problems at some point.
12:07:15 <Peaker> hexagoxel: I think it could just always be considered part of Other-Modules by cabal, what's the downside?
12:07:37 <hexagoxel> Peaker: my version is SECRET!
12:07:41 <hexagoxel> oh, wait :)
12:08:03 <hexagoxel> yeah, i don't know :p
12:19:13 * hackagebot path-io 1.0.1 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-1.0.1 (mrkkrp)
12:21:40 <cocreature> ^ that‚Äôs a weird translation of symbols hackagebot doesn‚Äôt understand
12:21:59 <cocreature> the first simply gets converted into a space and the second into ?
12:23:48 <ClaudiusMaximus> cocreature: i get reverse video X and Y wrapping the terms (i guess they should be quote symbols?)
12:25:18 <mniip> ClaudiusMaximus, that's irssi rendering nonprintable characters
12:25:31 <mniip> U+18 = ^X, U+19 = ^Y
12:27:19 <cocreature> ClaudiusMaximus: yeah on the hackage page it shows single quotes
12:29:52 <ClaudiusMaximus> mniip: well, byte values 24 and 25 i guess, which implies hacakgebot doesn't utf-8 properly :(
12:30:20 <ClaudiusMaximus> > map (\x -> ord x `mod` 256) "‚Äò‚Äô"
12:30:22 <lambdabot>  [24,25]
12:32:57 <cocreature> it looks like it uses rss2irc and the rss seems to html encode them
12:38:22 <sm> that looks bad
12:39:20 <sm> if anybody wants to take a look, I can give pointers
12:39:23 <ClaudiusMaximus> http://hub.darcs.net/simon/rss2irc/browse/Feed.hs#188 Data.ByteString.Lazy.Char8 usage when reading from web network :(  http://hub.darcs.net/simon/rss2irc/browse/Irc.hs#178 Data.ByteString.Char8 usage when writing to irc network :(
12:39:41 <sm> ha, ClaudiusMaximus already on it
12:39:57 <ClaudiusMaximus> http://hub.darcs.net/simon/rss2irc/issue/2 known issue
12:40:11 <sm> so on it!
12:40:13 <ClaudiusMaximus> is that you?
12:40:29 <sm> no I'm simon, rss2irc "maintainer"
12:41:29 <sm> uh.. and yes, that *was* me that reported it :)
12:41:53 <sm> from nanq, last month
12:43:47 <ClaudiusMaximus> sm: hehe - so i guess it should use decodeUtf8With (const (fmap (const '?'))) or similar
12:44:13 <mniip> what
12:44:19 <mniip> why not just send utf8 to irc
12:44:42 <ClaudiusMaximus> mniip: it gets a bytestring from the network containing (hopefully) RSS XML
12:44:54 <mniip> right
12:44:59 <ClaudiusMaximus> mniip: then parses it to text to get the various fields
12:45:24 <ClaudiusMaximus> mniip: you don't want the bot to crash if someone uploads invalid unicode to hackage
12:45:42 <sm> it doesn't crash, hopefully
12:45:50 <sm> is the feed content misencoded then ?
12:46:24 <ClaudiusMaximus> sm: no, it seems to be html unicode entities, which i imagine get converted to code points (Char) in the feed parser
12:47:01 <ClaudiusMaximus> sm: but it could be equally valid to have an RSS feed containing UTF-8 characters directly (without the &#...; stuff)
12:48:12 <ClaudiusMaximus> sm: but then i guess you have to check the document encoding in the xml declaration, more complications
12:49:22 <sm> I see it does not validate, but not because of those quotes: http://feedvalidator.org/check.cgi?url=http%3A%2F%2Fhackage.haskell.org%2Fpackages%2Frecent.rss
12:49:45 <sm> presumably the feed package should be handling this
12:50:21 <sm> https://github.com/bergmark/feed/issues/9 relevant perhaps
12:59:14 * hackagebot atp-haskell 1.13 - Translation from Ocaml to Haskell of John Harrison's ATP code  https://hackage.haskell.org/package/atp-haskell-1.13 (DavidFox)
13:08:59 <ClaudiusMaximus> sm: will you work on a fix?  no worries if not, but it might be worth mentioning my comments about the Char8 stuff on the issue tracker?  don't feel like signing up there myself right now
13:25:25 <Tertain> Does anyone know if ghc perform special optimizations on non-IO functions? Like, if it's not IO, then it will memoize expressions, and if it's IO, then it won't?
13:28:04 <phaazon> is there a way to introduced universally quantified type variables in heads of signature?
13:28:07 <phaazon> like
13:28:25 <benzrf> forall a. a -> a?
13:28:43 <phaazon> foo :: (Bar a,Bar b,Zoo m (a :. b)) => m ()
13:29:02 <phaazon> benzrf: it‚Äôs only in the head
13:29:13 <benzrf> ah, i don't think i know what a head is, then
13:29:16 <benzrf> >.>
13:29:24 <phaazon> benzrf: the left part of the =>
13:29:40 <benzrf> does the signature you just posted not work?
13:29:42 <phaazon> I should have said the head instance
13:29:50 <phaazon> benzrf: well no, of course
13:30:00 <benzrf> hmm, kinda woulda thought it would
13:30:04 <phaazon> because I¬†introduce a and b and they‚Äôre not used in m ()
13:30:18 <phaazon>     In the ambiguity check for the type signature for ‚ÄòvertexInstances‚Äô:
13:30:21 <phaazon> I get that
13:30:38 <phaazon> I think there‚Äôs an extension for that
13:31:43 <phaazon> hm maybe with Rank2Types
13:31:59 <phaazon> nope
13:32:01 <phaazon> dammit
13:32:24 <mniip> that's not typechekable in general
13:32:31 <mniip> AllowAmbiguousTypes
13:32:32 <mniip> but like
13:32:40 <mniip> you're probably doing something very wrong
13:32:45 <phaazon> yeah if it‚Äôs error-prone I¬†don‚Äôt want that
13:32:59 <phaazon> mniip: well, I‚Äôm migrating an instance into a ‚Äúmust-declare‚Äù instance
13:33:25 <phaazon> I¬†think all that experimental shit I‚Äôve been doing for the past few days is hitting a wall :D
13:33:44 <phaazon> I‚Äôm defining no-op instance to force instances haha
13:33:47 <phaazon> that‚Äôs so messy
13:34:35 <phaazon> seriously
13:34:44 <phaazon> I must be doing something wrong
13:35:27 <phaazon> https://github.com/phaazon/luminance/blob/master/src/Graphics/Luminance/ShaderDriver.hs#L74 mniip 
13:35:38 <phaazon> I¬†have no idea how to do that without that nasty function
13:37:30 <jle`> Tertain: there is no implicit memoization of functions
13:37:39 <jle`> Tertain: but GHC will do stream fusion and other optimizations
13:37:56 <jle`> Tertain: also, for the record, all functions on IO are pure, and return the same thing every time
13:38:45 <jle`> phaazon: it should work with ScopedTypeVariables if you use it later, i think
13:38:59 <phaazon> jle`: yeah but I don‚Äôt need to use it
13:39:01 <phaazon> all this mess‚Ä¶
13:39:11 <phaazon> I think I‚Äôm seriously hitting a wall
13:39:17 <phaazon> all of this is way too complex
13:39:20 <jle`> oh, i see
13:39:25 <jle`> you're using 'a' and 'b' to describe m
13:39:39 <phaazon> I thought writing an API + loosely-coupled implementation would be an easy things
13:39:43 <phaazon> but it‚Äôs not :/
13:39:44 <jle`> i feel like that should work, the universal quantification isn't the part that is tripping you up
13:39:46 <phaazon> jle`: yeah
13:39:48 <jle`> yeah, typeclasses are weird
13:40:01 <jle`> they kind of might be one of the worst best ideas ever
13:40:14 <phaazon> jle`: well
13:40:19 <phaazon> I love them
13:40:23 <phaazon> but I¬†can see the limit now
13:40:25 <jle`> but, do they love you?
13:40:28 <phaazon> :D
13:40:33 <phaazon> I started with free monads
13:40:47 <phaazon> and decided to switch to typeclasses, because free monads were annoying to use in my case
13:41:07 <phaazon> like, I had to parameterize the *F types with all the types I¬†associate with in the typeclass now
13:41:25 <phaazon> I think I‚Äôm just doing it wrong
13:41:43 <phaazon> I¬†know how to solve the messy function 
13:41:58 <phaazon> by creating the typeclass in the API, implementing the instance in the API with methods in the typeclass
13:42:05 <phaazon> which would make the number of methods explode
13:42:10 <phaazon> but at least it would be correct
13:42:11 <phaazon> like
13:42:18 <phaazon> vertex1F
13:42:20 <phaazon> vertex2F
13:42:23 <phaazon> vertex3F
13:42:24 <phaazon> etc.
13:42:33 <phaazon> I guess I‚Äôm going to do that
13:43:11 <phaazon> then, the user would have to implement the methods
13:43:18 <phaazon> instead of defining a new typeclass
13:43:21 <phaazon> implement all the instances
13:43:23 <phaazon> and so on
13:43:26 <phaazon> I¬†think it‚Äôs saner
13:43:32 <phaazon> even though it‚Äôs kind of messy
13:43:37 <phaazon> I¬†have no better solution up to mind yet
13:43:49 <SuperBan> what have haskell that not have c++?
13:44:10 <phaazon> SuperBan: laziness, kinds, purity
13:44:19 <phaazon> well, you can have stupid laziness in C++ though
13:44:29 <phaazon> modules
13:44:32 <phaazon> what else
13:44:39 <phaazon> currying
13:44:43 <phaazon> I guess almost everything :D
13:45:21 <Stratege> easy ways to define ones own control structures ^^
13:45:39 <jle`> yes, almost everything, haha.  it might be easier to ask what haskell has that c++ *does* have
13:45:39 <rmbeer> in c++ also have a modules, libraries, class, etc. :/
13:46:22 <phaazon> rmbeer: modules in C++?!
13:46:31 <phaazon> I don‚Äôt think so
13:46:35 <phaazon> not yet, I¬†guess
13:46:49 <Stratege> jle` both are giantic languages that everyone uses their own preferred subset of (assuming Haskell == GHC)
13:47:06 <phaazon> I think we cannot state that Haskell == GHC
13:47:12 <phaazon> even though I kinda use it that way :D
13:47:18 <phaazon> (I need to have a look at ghcjs)
13:47:31 <rmbeer> phaazon, ok, c++ not have the modules, but can have, like the string variable
13:47:47 <phaazon> string variable?
13:47:59 <phaazon> I guess something that C++ has Haskell doesn‚Äôt is‚Ä¶
13:48:05 <phaazon> literals operators
13:48:15 <phaazon> but I¬†guess we can have those with -XPostfixOperators
13:48:17 <rmbeer> phaazon, yes, string variable that have in c++, (class string)
13:48:18 <phaazon> so nevermind
13:48:23 <rmbeer> not in C
13:48:33 <phaazon> rmbeer: well, C has strings
13:48:47 <rmbeer> in C have a vector of char
13:48:49 <rmbeer> :)
13:48:59 <phaazon> the C string library <string.h> is gigantic
13:49:04 <phaazon> and I guess it covers more that std::string
13:49:12 <phaazon> than*
13:49:20 <phaazon> and has very funny function names
13:49:27 <phaazon> like wsctombs
13:49:30 <phaazon> or wcstombs
13:49:33 <phaazon> I¬†never remember
13:49:35 <rmbeer> also in C can create a simulate class string with struct
13:51:00 <rmbeer> humm, ok, i go to silent...
13:52:37 <orion> Are there any examples of ghcjs in production/the wild?
13:54:51 <SuperBan> and now?
14:00:15 <suppi> orion, you might want to ask at #reflex-frp
14:09:00 <phaazon> seriously, I¬†think I‚Äôll just stop doing that huge mess
14:09:08 <phaazon> in language like C# or C++
14:09:19 <phaazon> I‚Äôd just have an ‚Äúinterface‚Äù and implement it in backends
14:09:21 <dedgrant> phaazon: A truly novel feature of C++ is the TMP accident. (I can't think of anything else honestly)
14:09:24 <phaazon> but there, with all those typeclasses
14:09:33 <phaazon> geez it‚Äôs so messy
14:09:35 <phaazon> TMP?
14:09:40 <phaazon> temporary?
14:09:43 <dedgrant> template metaprogramming
14:09:47 <phaazon> ah
14:09:50 <phaazon> it sucks so hard :(
14:10:04 <pdxleif__> it's the same as haskell
14:10:04 <phaazon> D has better metaprogramming features
14:10:08 <dedgrant> Well.. it's ugly.. but the pure functional language it permits is not appreciated by committee
14:10:11 <phaazon> but Haskell has way better ones
14:10:30 <phaazon> dedgrant: I hate all the verbose shitstorm in C++
14:10:31 <phaazon> like
14:10:35 <phaazon> template <class T> ‚Ä¶
14:10:36 <pdxleif__> http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/
14:10:38 <phaazon> everywhere
14:10:41 <glguy> C++ is off-topic in #haskell
14:11:05 <Zekka|Sigfig> (Could always go to #haskell-blah though)
14:11:27 <phaazon> yeah, so
14:11:30 <mjhoy> i'm wondering, why isn't main's type something like [String] -> [(String, String)] -> IO ()? (argv, envvars as parameters)
14:11:38 <dedgrant> 'salright. There is a connection to indexed types and type functions
14:11:57 <phaazon> mjhoy: well, good question :)
14:12:10 <phaazon> I actually never thought about that
14:12:13 <phaazon> so is actually bash
14:12:16 <jle`> mjhoy: it might tie haskell to a specific type of machine
14:12:19 <jle`> or architecture
14:12:19 <mjhoy> just seems natural...
14:12:32 <jle`> when it's meant to be a platform-agnostic language specification
14:12:33 <mjhoy> hm, but it's in C, right?
14:12:38 <jle`> what's in C?
14:12:46 <mjhoy> argv, envvars
14:12:51 <mjhoy> i guess not the latter.
14:12:59 <jle`> yeah, but just because C has it doesn't mean haskell should ahve it :P
14:13:06 <mjhoy> point well taken :)
14:13:10 <phaazon> so
14:13:12 <jle`> there are a lot of things that C has that haskell doesn't have, for good reasons :)
14:13:17 <phaazon> how do you implement loosely-coupled APIs?
14:13:26 <Zekka|Sigfig> Might be because Haskell didn‚Äôt want to make it necessary to propagate that stuff all over your program with your own state management machinery
14:13:27 <phaazon> that is, APIs capable of switching the implementation based on whatever
14:13:35 <phaazon> like package
14:13:42 <phaazon> or instance, or pattern-matching or whatever
14:13:58 <jle`> phaazon: have you looked at examples?
14:13:58 <Zekka|Sigfig> The choice it made is effectively ‚Äúargv and argc are globals‚Äú
14:13:58 <phaazon> jle`: well I‚Äôve tested around a lot
14:13:58 <phaazon> as I said
14:13:58 <Zekka|Sigfig> (well, you don‚Äôt need an argc)
14:14:01 <phaazon> typeclasses and free monads
14:14:06 <phaazon> and for now
14:14:06 <jle`> i mean, examples in the wild
14:14:11 <phaazon> luminance has three backends
14:14:20 <jle`> like gitlib, Chart, diagrams
14:14:22 <phaazon> that are baked directly into the code with #ifdef
14:14:24 <phaazon> it‚Äôs terrible :(
14:14:28 <jle`> persistent
14:14:31 <jle`> etc.
14:14:39 <phaazon> jle`: hm, I should have a look then yeah
14:14:44 <phaazon> or accelerate
14:14:53 <jle`> there are actually several examples, those are just the ones i can think of off of the top of my head :)
14:15:11 <phaazon> that‚Äôs a lot of of
14:15:11 <phaazon> :D
14:15:12 <jle`> i wouldn't consider it a "solved problem", but there are definitely several that have implemented it in a nice way
14:15:29 <phaazon> jle`: is it solved in any languages?
14:15:37 <phaazon> -s
14:15:55 <Zekka|Sigfig> phaazon: Well, the problem is basically ‚ÄúI have a lot of code with holes in it, and I want to substitute something in to fill those holes,‚Äù right?
14:16:14 <pdxleif__> mjhoy: You could argue main should return IO Int instead of IO (), even
14:16:18 <phaazon> Zekka|Sigfig: that‚Äôs a bit more complex than that
14:16:20 <phaazon> but that‚Äôs the idea
14:16:41 <Zekka|Sigfig> Well, most languages have *some* construct for that ‚Äî Java has abstractclasses, Haskell has typeclasses and free monads, C has nothing except maybe for structs because that‚Äôs how C is
14:16:47 <pdxleif__> mjhoy: I reason I heard for not taking args in main as [String] is that some programs might want to rewrite the arguments they were called with.
14:17:09 <pdxleif__> Seems like a pathological case to me, but I guess some programs do that (to influence how they look in top / ps ?)
14:17:10 <dolio> pdxleif__: No, main should be IO Void.
14:17:11 <phaazon> I guess C would do it the same way as Haskell does with records
14:17:11 <Zekka|Sigfig> So I think the simplest version of the problem has been solved. But maybe you want more things to be done for you
14:17:11 <jle`> to me, having main :: IO Int ties haskell too much to a specific machine/arcitecture
14:17:19 <dolio> And you should call exitWith.
14:17:33 <mjhoy> I assume it was something different before monadic IO? i suppose that was a long time ago...
14:17:35 <jle`> haskell isn't inherently tied to unix
14:17:37 <jle`> or exit codes
14:18:11 <phaazon> Zekka|Sigfig: well, I guess I‚Äôm trying too hard to solve a problem too hard 
14:18:21 <jle`> a lot of people use haskell to compile to javascript, too
14:18:23 <phaazon> the interface of my package is already impacted by the technologies I use
14:18:32 <jle`> in that sense it wouldn't make sense for main to be IO Int ...
14:18:33 <phaazon> so I guess trying to abstract over that is a dead end
14:18:36 <jle`> or even take a [String] ...
14:18:38 <Zekka|Sigfig> phaazon: I think most languages have a way to say ‚Äúmy code has holes in it, fill them‚Äù ‚Äî but it sounds like you have a more specific problem
14:19:29 <phaazon> Zekka|Sigfig: I think I¬†have a problem of design
14:19:37 <phaazon> I¬†cannot fit all the implementation in that design
14:19:45 <mjhoy> jle`: what is main in those programs? dom ready event?
14:19:52 <phaazon> I have a lot of already abstract code that makes sense only for the technology I use
14:19:54 <jle`> it represents an IO action
14:20:00 <phaazon> so I¬†need to clean that up before trying to abstract, I¬†guess
14:20:11 <jle`> same thing as in haskell-compiled-to-machine-code
14:20:43 <mjhoy> guess i mean, when does it get executed
14:20:44 <jle`> it's a representation of a program
14:20:54 <jle`> ah. i'm not exactly sure exactly when
14:25:17 <orion> < phaazon> that is, APIs capable of switching the implementation based on whatever <-- Consider a cryptographic library implementing HMAC. If the user does let x = hmac foo bar :: HMAC SHA256 and the underlying hash function is determined by the type you specify, is that close to what you want?
14:25:53 <phaazon> orion: no
14:25:56 <phaazon> I already have that
14:26:11 <phaazon> here it‚Äôs just basic implementation that you already know
14:26:12 <phaazon> like
14:26:30 <phaazon> I‚Äôm looking for ‚Äúfuture‚Äù implementations coverage
14:26:57 <orion> Couldn't you consider new hash functions to be future implementations?
14:27:18 <phaazon> well
14:27:19 <phaazon> in my case
14:27:27 <phaazon> I have objects that represent resources  on the GPU
14:27:38 <phaazon> the implementation of those objects depend on the technologies used
14:27:47 <orion> Objects?
14:27:49 <phaazon> with OpenGL it‚Äôs basically a GLuint
14:27:50 <phaazon> yeah
14:27:53 <phaazon> handles, if you prefer
14:27:57 <orion> OH, ok
14:28:01 <phaazon> newtype Buffer = Buffer { bufferID :: GLuint }
14:28:09 <phaazon> but that doesn‚Äôt make any sense for a Vulkan backend
14:28:14 <phaazon> maybe it‚Äôs a string
14:28:16 <phaazon> or a Int64
14:28:18 <phaazon> etc.
14:29:08 <phaazon> so hm
14:29:22 <phaazon> how to represent a type which implementation is driver-dependent?
14:29:28 <phaazon> I¬†use type families for that
14:29:31 <orion> Why can't these handles be parameterizsed over the kind of implementation?
14:29:33 <phaazon> but it introduces new problems
14:29:46 <phaazon> orion: that‚Äôs basically what type families are for in my case
14:29:50 <phaazon> but yeah
14:29:52 <phaazon> you could have
14:29:58 <phaazon> data API buffer texture = ‚Ä¶
14:30:01 <phaazon> and have a free monad
14:30:09 <phaazon> but I¬†have a LOT of those objects
14:30:17 <phaazon> that would make the number of type variables very high
14:33:02 <dedgrant> phaazon: Are you the author of luminance? :D
14:33:57 <phaazon> yes I¬†am
14:34:00 <phaazon> why? :)
14:34:31 <orion> phaazon: I'm not sure if this helps, but I get the sense that I ran in to a similar challenge: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Cipher.hs
14:34:55 <sm> fltkhs is looking quite useful
14:35:15 <dedgrant> phaazon: Thank you for that. I've been enjoying the blog posts and I'm using luminance for light OGL work at home.
14:35:32 <phaazon> dedgrant: or really?! awesome! which version are you using right now?
14:35:38 <dedgrant> Also made my foray into ekmett's linear package, which has been incredibly useful
14:35:47 <phaazon> orion: indeed, looks like what I‚Äôm working on
14:35:50 <phaazon> dedgrant: yeah
14:35:53 <phaazon> linear‚Äôs great!
14:37:36 <orion> phaazon: You're only parameterizing over the implementation though, right?
14:37:42 <phaazon> well
14:37:43 <dedgrant> phaazon: I want to say v0.9.something, but I'm not entirely positive
14:37:55 <phaazon> dedgrant: ok, that‚Äôs one of the latest anyway :)
14:37:57 <phaazon> orion: wait
14:38:06 <phaazon> you can have a look at the current mess here:
14:38:26 <phaazon> https://github.com/phaazon/luminance/blob/master/src/Graphics/Luminance/ShaderDriver.hs#L28
14:38:31 <phaazon> I need to remove that from master anyway
14:38:50 <phaazon> the uniformInstances function is a fucking joke :D
14:39:18 * hackagebot nist-beacon 0.1.0.0 - Haskell interface to the nist random beacon.  https://hackage.haskell.org/package/nist-beacon-0.1.0.0 (bstamour)
14:41:23 <orion> phaazon: What specifically are you unhappy about in the code to which you linked?
14:41:52 <phaazon> the uniformInstances function
14:44:34 <orion> If I read correctly, the purpose of that function is to force driver authors to implement certain instances.
14:45:14 <orion> Correct?
14:45:16 <phaazon> yep
14:45:38 <phaazon> I need that instance in the API interface
14:45:43 <phaazon> typeclass*
14:45:52 <orion> What are the consequences of not implementing an instance?
14:45:57 <phaazon> but the implementation and its content is driver-dependent
14:46:06 <phaazon> orion: it doesn‚Äôt compile
14:46:17 <orion> Why is that undesirable?
14:46:35 <phaazon> well, to be considered a ‚Äúdriver‚Äù you need to provide all the instances
14:46:41 <phaazon> like
14:46:47 <phaazon> if you don‚Äôt provide the instance for floats
14:46:52 <phaazon> and that I use floats
14:47:02 <phaazon> it will fail on your driver
14:47:11 <orion> That's a good thing though.
14:47:18 <phaazon> and furthermore, I¬†need a way to restrict them
14:47:32 <phaazon> I don‚Äôt want an instance for String in the API‚Äôs interface as it doesn‚Äôt make sense
14:47:43 <phaazon> but hm
14:47:53 <phaazon> I‚Äôm just coming to the realization that such abstraction is not trivial
14:47:57 <phaazon> I should focus on something else
14:48:00 <phaazon> like cleaning the api
14:48:12 <phaazon> I‚Äôll see later on for abstracting and loose-coupling
14:50:47 <orion> It seems to me that you want to prevent incomplete drivers from ever compiling, rather than preventing the end-user's (the person utilizing the driver) library from compiling (which is what would happen by default).
14:53:08 <ClaudiusMaximus> phaazon: what orion said.  you might take a look at 'diagrams' which has various backends, with different feature sets afaik
14:57:32 <phaazon> hm
14:57:44 <phaazon> I didn‚Äôt get the thing about having the user‚Äôs code failing
15:01:20 <dedgrant> phaazon: I'm really enjoying the divisibility of uniform interfaces.. the application of Contravariant.Functor alone was quite profound for me. (Hadn't used it before.)
15:01:37 <phaazon> :)
15:01:38 <phaazon> yeah
15:01:55 <phaazon> dedgrant: Contravariant is a good use there
15:02:03 <dedgrant> err Functor.Contravariant rather
15:02:06 <phaazon> however I think I‚Äôm going to remove Divisible
15:02:15 <phaazon> because it‚Äôs not what uniforms are for
15:02:16 <dedgrant> Too restrictive?
15:02:19 <dedgrant> right\
15:02:28 <phaazon> dedgrant: well it can lead into misuses I guess
15:02:44 <dedgrant> What is one such example?
15:02:58 <zygentoma> w
15:03:29 <phaazon> dedgrant: well, the Divisible instance basically sequence two glUniform*
15:03:38 <zygentoma> sry, why can't i write (a,b) <- functionThatReturnsAPair in do notation?
15:03:45 <phaazon> which can then quickly lead to GPU bandwidth saturation if you have a lot of big objects to update
15:04:07 <phaazon> it‚Äôs better to use the UniformBlock class for that (with Buffer)
15:04:41 <ClaudiusMaximus> phaazon: user might want to use a feature of one backend that not all backends support - otherwise you're limited to the intersection of all backends which might be too small
15:05:20 <dedgrant> phaazon: Right I see.
15:05:36 <phaazon> however I‚Äôm not sure about that Divisible stuff
15:05:42 <phaazon> I¬†need to be sure about what to do about that
15:05:55 <phaazon> I need to find a way to use divided the same way we use (<*>)
15:06:06 <phaazon> I¬†haven‚Äôt found yet but I¬†saw someone using a weird operator for that
15:06:07 <phaazon> like
15:06:21 <phaazon> f >$< g >*< h ‚Ä¶
15:06:29 <phaazon> with (>$<) being contramap
15:06:34 <phaazon> and (>*<) I¬†have no idea :D
15:07:28 <dedgrant> zygentoma: In Haskell, '<-' desugars  {x <- m ; ...} into {m >>= \x -> ...}  ... if you do this by hand, does the program compile?
15:09:04 <zygentoma> dedgrant: i fixed it, the problem was, that functionThatReturnsAPair really returned a pair
15:09:20 <dedgrant> zygentoma: :)
15:09:24 <zygentoma> not a pair in the monad, so return was to the rescue :)
15:09:34 <dedgrant> cool!
15:20:14 <Peaker> Lamdu's generated JS is no longer very readable: https://gist.github.com/Peaker/85d4c3c5d68bd938a317
15:20:50 <Peaker> adding logging for all intermediate results makes it terrible.. (bloats the code to N^2 its original size!)
15:26:34 <malloiki> where can i find the deduction rules for a typed lambda calculus?
15:29:18 <malloiki> i guess there are 5 of them here in wadler "propositions as types": x-I, x-E1, x-E2, ->-I, ->-E
15:30:00 <Aleksejs> Hello, a question about adic-state: I open a state via state <- openLocalStateFrom in main function. How can I access to opened state from another function? Should I always pass refenrece to state to it or can I access it some other way?
15:31:44 <rpfun> when doing "exploratory" numerics by playing around in GHCi, it is very annoying that the code loaded from files and typed at the interpreter is not optimized
15:31:48 <rpfun> is there a way around this?
15:32:17 <Aleksejs> I meant acid-state
15:32:24 <shachaf> You can compile the code in files and ghci will use the compiled code.
15:32:57 <rpfun> shachaf: apparently not on windows :()
15:33:08 <shachaf> Oh.
15:33:18 <shachaf> Then you might not like the way around it.
15:36:19 <rpfun> also, I thought something like "sum . map f $ [0..N]" or even the equivalent foldl' code "foldl' (\s x -> s + f x) 0 [0..N]" should use fusion and laziness and be "fast", but in my experience it's much faster to use explicit recursion. this is fine, but then why is there not a "loop i f" function in the prelude?
15:37:55 <rpfun> where "loop i f = loop' 0 0" where "loop' j s | j < i = loop' (j + 1) (s + f j); | otherwise = s"
15:38:13 <shachaf> It should compile to pretty good code.
15:38:18 <rpfun> the point is the latter seems like 'non-idiomatic' haskell but runs much faster
15:38:23 <rpfun> again, in my experience
15:40:06 <shachaf> http://slbkbs.org/summap.txt
15:42:56 <shachaf> The philosophy used to be that it's better to write code that indicates what you mean and then figure out ways to optimize it than to have special-purpose functions that are only there because you can't optimize the code you'd want to write.
15:50:02 <malloiki> going from "propositions as types" to "propositions as session" i see terms without types in the deduction rules. are they just 'untyped terms'? what are untyped terms?
15:53:34 <malloiki> i guess it's a well-formed program with 'undefined behavior'
15:58:55 <orion> < phaazon> I didn‚Äôt get the thing about having the user‚Äôs code failing <-- The person using luminance needs to select a driver. Assuming you removed that function from ShaderDriver.hs, both luminance and the driver will successfully compile on their own, despite some instances not being defined.
15:59:18 <orion> (not being defined in the driver)
16:01:23 <orion> It seems to me that your goal is to prevent the driver from compiling if some instances are not defined. From my perspective, it seems fine that an incomplete driver might compile successfully, because when the person using luminance+incomplete driver in their code tries to compile, it will fail.
16:36:31 <rpfun> shachaf: do you have a second to look at a particular (short) example where the explicit loop is much faster than the obvious code, maybe suggest some type annotations/rearrangements to make the simple example fast?
16:37:10 <shachaf> Maybe, but I won't commit to it sight unseen.
16:37:17 <shachaf> And maybe someone else here can help you.
16:37:21 <shachaf> So you should just post your example.
16:37:40 <rpfun> http://lpaste.net/723816355765157888 I would LIKE to write polarDim', but it is about 4 times slower (criterion) than polarDim
16:40:23 <o`connor> is "fn :: IVar a -> b" a pure function, or equivalent to "fn :: (a -> b) -> IO a -> IO b"?
16:41:30 <o`connor> er... "IO a -> IO b"
16:49:01 <rpfun> it seems that at least part of the issue is that [a..b] is slow. I rewrote "polarDim'" to be the exact same code but with unboxed vectors, UV.enumFromN js (ceiling m) replacing [js..m] and it runs much faster than the explicit loop
16:59:15 <rpfun> a more specific question: why is "sum . map f $ [a..b]", a, b doubles much slower (4x) than "UV.sum . UV.map f $ UV.enumFromN a (b - a)"?
17:00:06 <rpfun> where i have "import qualified Data.Vector.Unboxed as UV"
17:00:33 <Zekka|Sigfig> rpfun: I am not a Haskell optimization expert but my guess is that it‚Äôs because the list version involves lots of branching and dereferencing, but the unboxed vector version only involves branching
17:00:55 <Lokathor> so if you have to pass a pointer to a FFI function and then it's going to mutate the data pointed to by your pointer, would IOVector be a sensible type to model that?
17:00:58 <Zekka|Sigfig> IIRC the representation of an unboxed vector is a length-tagged array, although you shouldn‚Äôt trust me
17:01:29 <rpfun> Zekka|Sigfig: i think the idea is that in either example no allocation is supposed to happen
17:01:56 <rpfun> in fact i'd be very surprised if any was happening in the unboxed vector case, since it runs faster than a corresponding explicit loop with no allocation
17:02:23 <Zekka|Sigfig> I‚Äôm curious what‚Äôs happening if not allocation. Have you examined the native code?
17:02:56 <rpfun> I also think unboxing is a very minor factor, since if I change to Data.Vector instead of Data.Vector.Unboxed the running time increases by a small constant factor, still (4x) faster than the non-vector code
17:03:00 <Zekka|Sigfig> It could be there‚Äôs a rewrite rule that‚Äôs helping you avoid it, or some crazy optimization in ghc that realizes what you‚Äôre trying to do
17:03:29 <Zekka|Sigfig> rpfun: Sounds like my guess is unlikely to be accurate. I‚Äôd recommend checking out the generated code if possible, although that‚Äôs gnarly
17:03:59 <Zekka|Sigfig> there‚Äôs some flags you can pass to GHC to get it to print your code at various representation levels but I don‚Äôt know most of them
17:10:32 <rpfun> here is a minimal example, again i'd like to understand what I can do to polarDim' to make it (much) closer to polarDim: http://lpaste.net/2790520911697018880 . again, unboxing plays a minor (constant) role, polarDim' is 4x slower on my machine
17:11:20 <malloiki> i can't seem to find ghc.arr on hayoo...
17:11:29 <malloiki> GHC.Arr
17:11:54 <shachaf> rpfun: See, I wasn't even around when you posted your code.
17:11:58 <shachaf> Is it resolved?
17:12:57 <hefesto> hi :) I am trying to build my proyect (https://github.com/hhefesto/communis-api) with 'stack build' on a remote server, but I get this weird error: (http://lpaste.net/153369). I really dont know what is wrong because it works fine on my local setup...
17:13:30 <shachaf> rpfun: Oh, you're using a Double range. I'd expect that to behave oddly.
17:13:58 <mpickering> Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
17:14:21 <mpickering> So you are running out of memory? 
17:15:28 <rpfun> shachaf: not resolved. i posted this minimal example: http://lpaste.net/2790520911697018880 , now with a vector version that's much faster
17:15:41 <rpfun> i'd still like to know how to make the "native" code faster
17:16:15 <rpfun> at least within some small constant factors to be competitive with the Data.Vector code, which is only a small (additive) constant factor slower than the unboxed code
17:17:21 <shachaf> rpfun: [a..b] for Double is so complicated that I wouldn't expect it to be fast.
17:18:18 <rpfun> shachaf: so the best course of action in this case is the explicit loop after all?
17:18:28 <shachaf> Maybe.
17:18:45 <shachaf> Or maybe use [a..b] with Ints instead of Doubles and then convert to Doubles.
17:20:16 <shachaf> enumFromN is doing a pretty different thing from [a..b]
17:22:19 <rpfun> i figured it was [a..b] that was killing me. changing to map (f . (+) a . fromIntegral) where a converts to the appropriate double brings me within 1.2 of the boxed vector vesion
17:22:22 <dedgrant> o`connor: In Haskell parlance, functions are pure. (Specifically, evaluation is said to be pure.) The presence of IO in types doesn't change this.
17:22:34 <rpfun> is there an 'enumFromN' equivalent in the prelude for this sort of situation?
17:24:24 <hefesto> mpickering: Yes it is :S Which is wierd because locally it doesn't eat up a whole gb of mem
17:27:28 <augur> i can make a library cabal project into an executable later with a thing in the config file, right?
17:27:44 <dcoutts> augur: in the .cabal file, yes
17:28:09 <augur> ok
17:28:32 <shachaf> rpfun: Maybe you can use take n [x..]?
17:28:36 <augur> thank you, dcoutts:)
17:30:08 <rpfun> shachaf: 2.5 times slower :)
17:30:46 <Zekka|Sigfig> This sort of thing is why I avoid claiming I know much about optimizing Haskell code!
17:31:11 <rpfun> it gets closer (~1.7x) to use "enumFromN' s l | l > 0 = s : enumFromN' (s + 1) (l - 1); | otherwise = []"
17:31:32 <rpfun> and enumFromN' js (ceiling m :: Int) instead of [js..m]
17:36:08 <shachaf> rpfun: Well, you're not going to get any fusion that way.
17:40:43 <rpfun> shachaf: so am i stuck with explicit loops or vector then?
17:40:54 <rpfun> thanks for your advice betw
17:40:55 <rpfun> btw*
17:43:42 <shachaf> I don't know.
17:44:01 <shachaf> That example is too minimal to be able to run it and reproduce your results.
17:44:34 <Zekka|Sigfig> rpfun: In the worst case, switch to a language with a simpler cost model! But there may still be better options than that
17:45:55 <mgsloan> hefesto: Yeah, you're probably running out of memory, "stack build -j1" can help, because then it just builds one package at a time
17:49:19 <dedgrant> mgsloan: Is there a common method for building an entire stackage repository locally? :d  Is this a thing?
17:50:13 <mgsloan> dedgrant: I think "stackage-curator" can do that, but I haven't done so myself
17:50:35 <dedgrant> Cool ty for the lead!
17:50:38 <mgsloan> Stack doesn't currently have a way to build an entire snapshot, but such a feature may make sense in the future
17:52:54 <dedgrant> Do you think that the Haskell/Stack ecosystem may be close to benefitting from hosted prebuilts?
17:53:15 <dedgrant> (sort of a loaded question I suspect)
17:57:10 <mgsloan> dedgrant: Sure, but I'm not sure of the extent of the technical challenges.  One issue is that Paths_ modules have absolute paths to the build directory, which could contain data files and stuff
17:57:36 <dedgrant> There be dragons
17:57:47 <mgsloan> Feel free to look into it, but it isn't a priority, since, yeah, probably dragons
17:57:52 <dedgrant> :)
18:01:37 <luigy> the nix folks probably familiar with those dragons :)
18:02:03 <mgsloan> Yes, one answer to that is "use nix" :)
18:03:03 <mgsloan> I think the current nix + stack integration is mostly intended for using nix for non-haskell dependencies.  I think there's some nix stuff based on stackage snapshots, though, so it might be possible to get a good nix + stack setup that uses nix for the binary caching and stack for building the rest
18:06:50 <centrica> post-setup, are any benefits to stack over nix for haskell?
18:08:02 <mgsloan> Yes, nix isn't a build tool
18:08:12 <mgsloan> (not directly anyway)
18:08:48 <mgsloan> Nix doesn't have very much haskell-specific knowledge, whereas stack does
18:09:41 <centrica> mgsloan: ok, makes sense. for package dependencies though, it's a wash or nix advantage due to prebuilt binaries?
18:09:48 <mgsloan> Also, nix doesn't work well on windows
18:10:12 <mgsloan> Nix does have the advantage of prebuilt binaries
18:10:36 <centrica> mgsloan: any advantages that stack has over nix in package dependency area?
18:10:50 <mgsloan> But what if you want to change the flags of the libraries you depend on? Now you're hosed, I think. I'm not sure, I haven't used nix much
18:10:59 <mgsloan> I don't know.
18:11:23 <centrica> yeah, when you want to change flags, you have to write nix expressions
18:12:08 <mgsloan> It seems like operations like "rebuild everything with profiling" could be tricky with nix as well
18:12:14 <mgsloan> Whereas with stack it's just "stack build --profile"
18:13:14 <centrica> i think that's true - with nix you are either a) use defaults or b) write expressions yourself, for everything you need
18:13:36 <centrica> so yeah, it leans strongly towards defaults afaik
18:13:49 <centrica> for the benefit of not having to build things locally
18:13:49 <dcoutts> though of course the nix language makes using parameters easy, like turning on profiling
18:13:54 <mgsloan> Right, so by being a more generic tool, nix isn't as convenient for specific development operations
18:14:14 <centrica> dcoutts: but wouldn't you have to specify everything for every package?
18:14:19 <rubystallion> How is the type of fmap fmap id derived? I understand how to derive the type of fmap fmap, but then I'm stuck.
18:14:22 <lpaste> rubystallion pasted ‚ÄúDerivation of fmap fmap id‚Äù at http://lpaste.net/153374
18:14:26 <centrica> or is it just that haskell packages anticipated this and have this as a flag?
18:14:48 <centrica> that = profiling, in this case
18:14:51 <mgsloan> It'd be great if stack could rely on nix in general, but we can't due to windows support and not everyone being nix wizards
18:14:58 <dcoutts> centrica: in principle no, since each one can say it depends on its deps with the appropriate params passed down. I don't use nix myself so I don't know how they actually do it in practice
18:15:00 <mitchty> ok inline-c is awesome, so much nicer than ffi for a quick hack
18:15:40 <centrica> dcoutts: yeah, might be that they just have this parameter (profiling) somewhere, as a frequently used operation
18:15:44 <dcoutts> mgsloan: which is why we're putting nix concepts into cabal
18:16:08 <mgsloan> Yeah, well, we've had package sharing in stack for many months now
18:16:16 <dcoutts> centrica: that's what I'd assume, but I don't use it in practice
18:16:42 <dcoutts> mgsloan: but only within pre-defined collections right?
18:16:51 <mgsloan> Yes, but that restriction will be lifted soon
18:16:57 <luigy> Yeah I would say that is another feature... user friendliness
18:17:00 <luigy> :)
18:17:33 <mgsloan> Soon == next couple months hopefully
18:17:43 <dcoutts> mgsloan: so what's that going to look like?
18:18:08 <mgsloan> Your "extra-deps" will become implicit snapshots
18:19:23 <dcoutts> mgsloan: I'm not quite sure what the implication of that is
18:19:34 <mgsloan> So whenever you choose a new set of extra-deps, you will get a new package DB.  It will then find all of the packages that have the correct transitive deps / flags / etc, in the existing snapshots, and add them to this DB
18:20:04 <mgsloan> We will need to have some way of GCing these implicitly created DBs, but otherwise this is quite straightforward
18:20:28 <mgsloan> main reason implementation has been delayed is that we want this change to go in with a fair number of related improvements
18:20:41 <centrica> unrelated q for stack - i understand you always have to do "stack ghc" etc. any way to avoid the startup time of these?
18:20:57 <centrica> i assume just putting stack's ghc in PATH won't work
18:21:08 <mgsloan> centrica: "stack exec bash"
18:21:40 <centrica> ok, that helps :)
18:22:14 <ClaudiusMaximus> sm: just had a thought re the rss2irc memory leak - maybe some code needs to ByteString.copy or Text.copy somewhere (if it keeps a small slice of the full feed data which prevents it from being gc'd, for example)
18:22:56 <ClaudiusMaximus> sm: just building it from darcs now, after wibbling the dependency bounds, will see if it works with the newer versions first
18:24:54 <mgsloan> dcoutts: See this issue for more info https://github.com/commercialhaskell/stack/issues/1265
18:26:03 <dcoutts> mgsloan: cheers
18:28:36 <sm> ClaudiusMaximus: great! IIRC the xml package was leaking
18:30:36 <ClaudiusMaximus> sm: first i'll try to tackle the unicode issue, as that is likely easier to nail down
18:30:38 <sm> ClaudiusMaximus: you can log in to darcs hub with a github or google account too
18:31:56 <ClaudiusMaximus> sm: good to know, do i have to set anything up at the other end?  (like "allowed apps" or some such?)
18:32:03 <sm> no
18:34:02 <ClaudiusMaximus> sm: the authorisation page says "This application will be able to read and write all user data" so i'm a bit reluctant
18:34:34 <sm> oh boy.. I would be too. Sorry about that :)
18:34:58 <ClaudiusMaximus> so for now i'll respectfully decline
18:36:09 <sm> saving a username and password on darcs hub itself takes a second and does not get you spammed, but if you prefer not no worries
18:36:22 <sm> afk a little (cooking), thanks for looking at it
18:36:35 <ClaudiusMaximus> yeah i think i'll do that instead.  bon'app
18:44:37 <hefesto> mgsloan: 'stack build -j' did not work :( The same error (http://lpaste.net/153369). Does building 'package text-1.2.1.3' take more than 600 MB of memory? It also takes reaaaaaaly long
18:46:16 <mgsloan> It needs to be -j1 not -j
18:46:49 <mgsloan> If you don't need optimizations, you can pass the "--fast" flag to stack
18:46:52 <ClaudiusMaximus> sm: woe, build failure with ghc-7.10, guess i revert my dependency wibbles and try 7.8 for now - another 25mins to rebuild all the deps, joy
18:48:23 <hefesto> mgsloan: it was -j1, sorry, bad copy.
18:50:17 <mgsloan> Then I'm not sure we can do anything about that, you're going to need more memory, possibly by using swap?
18:52:15 <ongteckwu> hi can anyone tell me what's wrong w my code?
18:52:16 <ongteckwu> https://bpaste.net/show/e0bc85992133
18:52:44 <ongteckwu> I just started learning haskell and the trace stack has been really frustrating for me
18:52:53 <ongteckwu> would appreciate your nice help!
18:54:23 <mgsloan> ongteckwu: "null" tells you if a list is empty.  You probably want []
18:54:29 <ongteckwu> ohhh
18:54:42 <ongteckwu> wait, I apologize for not explaining what's going on
18:55:02 <ongteckwu> basically I wanna take the second element of every list on a list of lists and append them onto an output list
18:55:21 <ongteckwu> mgsloan: oh i see
18:55:29 <ongteckwu> mgsloan: but what if I want a null object
18:55:34 <ongteckwu> mgsloan: is there such a thing?
18:55:43 <mgsloan> No, this is one of the great things about haskell
18:56:11 <mgsloan> No more null pointer exceptions!  They are nearly impossible (and represent a bug in the RTS or other external code if it does happen)
18:56:25 <ongteckwu> mgsloan: oh i see
18:56:33 <ongteckwu> mgsloan: so how should i represent nothing? haha
18:56:42 <luigy> Nothing :)
18:56:59 <mgsloan> Yes, it's literally the "Nothing" constructor of the Maybe datatype
18:58:24 <ongteckwu> so do I just use Nothing?
19:00:01 <ongteckwu> okay I think I need to brush up on my Haskell
19:00:02 <ongteckwu> haha
19:02:39 <andromeda-galaxy> I'm playing around with making various things pointfree, and was wondering if there's a more idiomatic way of doign this: runKleisli $ returnA &&& (Kleisli monadicFunction)
19:04:01 <shachaf> That is a very not idiomatic.
19:04:54 <andromeda-galaxy> shachaf: that's why I was wondering about a more idiomatic way.  This partially came up as a way of playing with Kleisli arrows, which I haven't run into much before, and then I realized that I actually needed to use this pattern for something
19:05:06 <shachaf> Is this meant to be the same as (\x -> fmap (x,) (monadicFunction x))?
19:05:54 <andromeda-galaxy> shachaf: indeed it is
19:06:05 <shachaf> Then that's much more idiomatic.
19:06:10 <shachaf> @pl (\x -> fmap ((,) x) (monadicFunction x))
19:06:11 <lambdabot> liftM2 fmap (,) monadicFunction
19:06:29 <shachaf> Or something like that.
19:06:38 <shachaf> If you really want to be point-free for some reason.
19:07:28 <andromeda-galaxy> shachaf: why did I miss liftM2?  of courses that's better for pointfree.  thanks!  Kleisli arrows can be fun anyway, though.
19:20:18 <maybefbi> why does lint suggest mappend instead of (++)
19:20:36 <maybefbi> and fmap instead of map
19:20:56 <ClaudiusMaximus> sm: is there anything i need to configure with rss2irc to get it to connect?  currently i'm just getting "Connection timed out" after a few lines from the server http://lpaste.net/4019208504148492288  (tried a different non-freenode server with similar outcome)
19:21:00 <maybefbi> why is generic version of something better than more specific version
19:29:29 * hackagebot nist-beacon 0.1.0.1 - Haskell interface to the nist random beacon.  https://hackage.haskell.org/package/nist-beacon-0.1.0.1 (bstamour)
19:39:05 <Cale> maybefbi: It's not. You don't have to take every suggestion.
19:39:29 <Cale> maybefbi: Sometimes if you generalise enough, you can end up with something that's more reusable, so it's perhaps worth considering.
19:39:47 <Cale> maybefbi: But a lot of the time, suggestions of that sort don't really do much.
19:41:35 <nitrix> maybefbi: I suspect you're missing type definitions.
19:42:25 <nitrix> Normally hlint doesn't suggest the most generic variants if your implementation is sufficiant.
19:42:33 <maybefbi> nitrix, yeah they were mostly let expressions for which i did not annotate the types
19:42:44 <nitrix> That makes sense.
19:43:06 <maybefbi> thanks anyways
20:04:30 * hackagebot multiaddr 0.3.0 - A network address format  https://hackage.haskell.org/package/multiaddr-0.3.0 (MicxjoFunkcio)
20:19:56 <pavonia> Is there a command line arguments parser that supports different sub-modules (or what they are called) like cabal-install uses them? Such that you can have different arguments depending on what module you choose
20:20:54 <chreekat> pavonia: yup, optparse-applicative among possibly others
20:21:42 <chreekat> https://github.com/pcapriotti/optparse-applicative#commands
20:21:57 <pavonia> Nice, thanks
20:22:24 <chreekat> I find that documentation a bit dense w.r.t the datatypes, but it'll probably get you towards your goal
20:23:40 <v937xjd> Hi 
20:23:50 <chreekat> hi
20:39:53 <mgsloan> Does anyone know if having a flag to automatically add (?_unique_ident :: CallStack) to every function was considered?
20:40:01 * hackagebot http-kinder 0.2.0.0 - Generic kinds and types for working with HTTP  https://hackage.haskell.org/package/http-kinder-0.2.0.0 (JosephAbrahamson)
20:40:03 * hackagebot serv 0.2.0.0 - Dependently typed API framework  https://hackage.haskell.org/package/serv-0.2.0.0 (JosephAbrahamson)
20:40:05 * hackagebot serv-wai 0.2.0.0 - Dependently typed API servers with Serv  https://hackage.haskell.org/package/serv-wai-0.2.0.0 (JosephAbrahamson)
20:40:30 <mgsloan> I am currently fed up with "-xc", dwarf symbols, etc. Implicit locations is my only hope, but now i need to sprinkle these constraints everywhere....
20:40:57 <mgsloan> Worse yet, I can't get them into libraries, and I can't make exceptions include this info
21:01:11 <minn> I have a quick question: is fmap unique for a given type? It seems intuitive that map is unique, but not the general case.
21:08:12 <chreekat> minn: fep, fmap is unique for a given type, since typeclass instances are defined globally. 
21:09:03 <chreekat> some people find this bizarre, but that is a deep rabbit hole, and newtypes often handle the situation where you want a different implementation
21:12:08 <andromeda-galaxy> also: I feel that 'runKleisli $ (Kleisli monadFunc1 >>^ pureFunc1 . pureFunc2) &&& (Kleisli monadFunc2)' is much clearer than the alternative defined with lots of binds and lambdas, and *much* more clear than the alternative defined pointfree with the liftM* functions.  Would the kleisli version still be considered less idiomatic?  if so, why?
21:21:01 <fr33domlover> Does the Yesod scaffolding provide any util for quick access to app settings? Or do I need to write my own wrapper or directly do e.g. "asks $ appCopyright . appSettings" ?
21:21:54 <chreekat> fr33domlover: that line strikes me as pretty quick... :)
21:24:59 <andromeda-galaxy> Also: are there any good stdlib functions for working with three-tuples?  things like uncurry/fst/snd/etc.  This is specifically in the context of defining a pointfree function that takes a tuple of three argumetns and needs to split it into a pair and the remaining singile argument, @pl won't work here because lambdabot throws parse errors on the third argument
21:28:37 <MarcelineVQ> you're wanting to make (a,b,c) into ((a,b), c) ?
21:29:17 <glguy_> andromeda-galaxy: You work with 3-tuples using pattern matching
21:30:03 * hackagebot hsdev 0.1.6.4 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.4 (AlexandrRuchkin)
21:30:11 <andromeda-galaxy> MarcelineVQ: basically, \(a,b,c) -> (f (a,b)) c
21:30:24 <andromeda-galaxy> glguy_: of course, but I was wondering if there were any good ways to do it pointfree
21:31:01 <MarcelineVQ> Does (f (a,b)) result in another function?
21:31:06 <glguy_> andromeda-galaxy: Not really, no.
21:33:07 <andromeda-galaxy> MarcelineVQ: it does.  glguy_: okay, thanks for the information, I suspected as much
21:44:51 <corefocus> hello everyone!
21:44:58 <corefocus> hi jonmorehouse
21:45:15 <jonmorehouse> corefocus: hi
21:45:22 <corefocus> how are you today
21:45:34 <jonmorehouse> good; your handle sounds familiar
21:46:11 <jonmorehouse> how're you?
21:47:11 <corefocus> We most likely don't know eachother
21:47:16 <corefocus> but I haven't been on irc in a long time
21:47:28 <corefocus> so im just trying to see what sort of activity i can find here
21:51:39 <stasiana> Hi all. PyRulez (here?) recently posted some code for a purely applicative parser that I cannot understand. Would someone help me out?  https://gist.github.com/ChristopherKing42/cb30809332ccb9d7a6bd
21:52:53 <jonmorehouse> fair enough, I'm not in the haskell room too awfully much myself
21:52:58 <jonmorehouse> it's a good one to hang out in
21:53:32 <corefocus> I found it by asking google
21:53:36 <corefocus> what the best hang out place on freenode was
21:53:42 <corefocus> haskell was among one of them
21:53:46 <ski> corefocus : there's often lots of conversations here
21:53:54 <corefocus> any chicks? :)
21:54:15 <chreekat> https://www.stackage.org/lts-5.4/hoogle?q=chick
21:54:29 <corefocus> Your search produced no results.
21:54:34 <chreekat> pun not intended
21:54:51 <corefocus> Oh well.  Let's just make the best of it then.
21:55:03 <corefocus> Drag queens can be fun too.
21:56:53 <chreekat> stasiana: any particular question?
21:57:49 <stasiana> chreekat: Just how to use it. I don't understand what (Char -> f ()) is. For example, how do I parse a single character with it?
22:00:07 <ski> stasiana : instead of `head $ show c', i might say `intToDigit c'. alternatively just `c', but enumerating digits instead of numbers from `0' to `9'
22:00:09 <EvanR> stasiana: Char -> f () gives you a parser if you give it a char. the parser you get depends on the char you give it. if you give it 'x' then youll get a parser than returns () if it sees 'x' next otherwise it fails and gives nothing
22:02:05 <ski> stasiana : it seems the comments at the end ("Our type can be converted to your type like so:","It can also be converted to Parsec efficiently") refer to the alternative definition `newtype Parser a = Parser {run :: forall f. Alternative f => f Char -> f a}'
22:02:48 <stasiana> EvanR: Okay, but it is an argument to `run`. So, if I wanted to parse a single digit, how to I use `run`, `Parser` and `digit` to accomplish this with an input string s?
22:03:53 <ski> stasiana : `newtype Parser a = Parser {run :: forall f. Alternative f => (Char -> f ()) -> f a}' represents a parser by abstracting/parameterizing over a `char :: Char -> f ()' operation to attempt to parse a given `Char', for any appropriate `f' the user decides to use ..
22:03:54 <EvanR> so you need a f Char which only succeeds if it sees a digit
22:05:20 <ski> stasiana : the user is required to use an `f' that is an instance of `Applicative' (because that is a superclass of `Alternative', which is explicitly required in the signature for the `run' field) -- therefore the `f' the user uses must support (static) sequencing
22:06:53 <ski> stasiana : furthermore, the user is required to use an `f' that is an instance of `Alternative' itself -- therefore the `f' the user uses must support (static) alternatives/branching
22:07:06 <stasiana> ski: So for example I can use `[]` since that is an instance of Alternative. But now what?
22:08:44 <mfellows_> exit
22:09:03 <ski> stasiana : furthermore, as mentioned, the user must provide an operation of type `Char -> f ()', which will be used as a primitive operation by `Parser' and its operations, to attempt to parse a given `Char'. presumably, it yields an `()' when executed (parse success), or otherwise fails (using `empty' from `Alternative') (parse failure)
22:09:54 <ski> (by "the user" here, i mean whoever calls `run' on a `Parser T', for some type `T')
22:11:13 <ski> stasiana : so `[]' is `Applicative' and also `Alternative'. however, i don't think you can construct a sensible operation of type `Char -> [()]' to feed `run', given a `Parser T'
22:11:50 <chreekat> yeah, kinda looks like you have to give it an "engine" like the given example (anyChar from Parsec) to kick things off, so you'd have to use it like `Parsec.parse (run digit Parsec.anyChar) "the input text"`
22:12:06 <saurabhnanda> hi fellows, I back. I see that ski is still online?  what what timezone s/he is in
22:12:20 <saurabhnanda> so, what's the correct way to use ADTs?
22:12:31 <ski> @time ski
22:12:35 <lambdabot> Local time for ski is Fri Feb 26 07:12:11 2016
22:12:57 <corefocus> Wow, the particular IRC server that I'm on is hosted in Vilnius Lithuania.
22:12:58 <corefocus> I think that's remarkable
22:13:01 <chreekat> that seems like a broad question. :)
22:13:02 <ski> /ctcp ski time
22:13:15 <ski> is an alternative way
22:13:27 <saurabhnanda> Apparently // data NightwatchCommand = InvalidCommand | DownloadCommand { url :: String } | PauseCommand { gid :: String } | UnpauseCommand { gid :: String } | StatusCommand { gid :: String } deriving (Show, Eq) // is not a good idea because it results in some partial functions or something. Basically some value-types in that definition don't have record-accessors, while some do. Haskell can't deal with that very elegantly.
22:13:55 <stasiana> chreekat: That seems odd. Originally this code was a response to a StackOverflow question on how to build applicative parsers and presumably it wouldn't actually need to use Parsec or any other parser. Should be independent.
22:13:55 <corefocus> you made drbean ping out.
22:13:56 <corefocus> with your command.
22:14:10 <EvanR> saurabhnanda: records are product types, youre defining a sum type, so thats what you get
22:14:14 * ski idly wonders whether the last sentence of that long message of saurabhnanda really was "Haskell can't deal with that very elegantly.", or whether there was something more, that got cut off
22:14:24 <saurabhnanda> my question is, given the current state of whatever is happening with record types in Haskell, what's the best way to use ADTs? Is it recommended to define ADTs where different value-types have different record-fields?
22:14:59 <EvanR> i would be ok with not being able to even do that
22:15:00 <chreekat> oh, I see, you are correctly noting that having multiple 'gids' doesn't work
22:15:16 <EvanR> records are one thing, sum types are another
22:15:35 <ski> saurabhnanda : by "value-types", do you mean different alternatives, different (data) constructors ?
22:15:55 * ski concurs with EvanR
22:16:28 <EvanR> data Maybe a = Nothing | Just { fromJust :: a } ;)
22:16:38 <chreekat> stasiana: well, I suppose the fun part is you can build up all manner of a parser within that applicative framework, without using anything else from Parsec other than a function "Char -> f ()"
22:16:40 <EvanR> fromJust = no good very bad
22:16:45 <saurabhnanda> ski: yes, I'm probably using the wrong name here. In my type definition, I'm referring to all the alternative types, eg. InvalidCommand, DownloadCommand, PauseCommand, etc.
22:17:51 <chreekat> saurabhnanda: a possibility is to just get rid of the record names and always rely on pattern matching
22:17:57 <saurabhnanda> I'm not sure if it's a good idea to have different constructors for each alternative type. For example one type has no-arg constructor. Some other type has a 3 arg constructor. Something else has a record-oriented constructor.
22:18:18 <stasiana> chreekat: Really was just looking for a concrete example. In parsec I do `parse digit "" "123"` and that's it.
22:18:49 <saurabhnanda> chreekat: what about ADT-ing types with constructors having different number of arguments. Is that going to blow-up in my face anywhere?
22:19:22 <EvanR> different numbers of arguments is the whole point of ADTs
22:19:36 <chreekat> "case cmd of { InvalidCommand -> dosmth; DownloadCommand url -> doSmthElse; ...}"
22:19:44 <EvanR> ^
22:19:56 <chreekat> yeah it's like one of the nicest things about them :P
22:21:07 <ski> stasiana : you can compare this notion of parameterizing over an arbitrary `Alternative' `f', together with an `Char -> f ()' with the definition `newtype GenericNum = MkGN {unGN :: forall a. Num a => a}', for which you can declare `instance Num GenericNum where MkGN x + MkGN y = MkGN; ...'
22:22:16 <saurabhnanda> EvanR chreekat I thought one could ADT anything that conceptually belonged together, until I got hit with this: http://stackoverflow.com/questions/35266143/ghc-compiler-not-complaining-about-incorrect-code-paths/35268192
22:22:32 <saurabhnanda> EvanR chreekat which is why I'm being careful now
22:22:47 <ski> stasiana : in this case, we're delaying the choice of an actual type `a' (in `Num') to the user. when the user selects one, it will be propagated through all the arithmetic operations of `Num' for `GenericNum'
22:23:06 <EvanR> saurabhnanda: typically pattern matching is the go-to way to deconstruct and analyze the data you have
22:23:13 <saurabhnanda> btw, is there any compiler support for refactoring code when an underlying type changes? for example, If I change the definition of my ADT to NOT use record-syntax, is there something which can help in automatic refactoring of code?
22:23:39 <saurabhnanda> s/compiled/IDe
22:23:44 <saurabhnanda> s/compiler/IDE
22:23:44 <EvanR> you will get type errors, fix them
22:24:03 <saurabhnanda> EvanR: the good ol' way of the shouting-compiler
22:24:04 <EvanR> this aspect of haskell is awesome, refactoring after changing the types
22:24:16 <EvanR> fix all the errors, it probably still works
22:24:33 <EvanR> its hard to get this in C
22:25:04 <stasiana> ski: I know what the forall does and what Alternative is. Can you offer a sample line of code that will use the minimal parser in that gist to parse a digit out of a string?
22:25:06 <ski> stasiana : in your case, the choice of the actual "parsing `Alternative' functor" to use in place of `f' is delayed, and also the choice of the actual operation of type `Char -> f ()' (for this previous choice of `f') is delayed. i.e., until `run' is applied, at which point the `f' to use (together with `Functor',`Applicative',`Alternative' methods for it) and also the "`char'" operation to use, will be propagated
22:25:35 <saurabhnanda> EvanR: okay, let me try
22:28:30 <saurabhnanda> is there any way to annotate what each of the arguments represents? // data NightwatchCommand = InvalidCommand | DownloadCommand String | PauseCommand String | UnpauseCommand String | StatusCommand String deriving (Show, Eq)
22:28:48 <EvanR> you could not use String
22:28:55 <EvanR> or use a type synonyms for String
22:29:23 <saurabhnanda> EvanR: is it okay to have so many custom types in a program?
22:29:28 <saurabhnanda> EvanR: or is this over-engineering?
22:29:50 <ski> stasiana : using the specified version, you can't parse an arbitrary character (without resorting to enumerating all of them, iow trying them one at a time, which may be inefficient). the version that has `f Char' instead of `Char -> f ()' would allow to define `anyChar :: Parsec Char; anyChar = Parser (\char -> char)'
22:30:01 <EvanR> if its a custom type, then you have to make it because its custom, theres no standard solution for it already
22:30:33 <EvanR> but dont recreate lists if its exactly the same function as a list
22:30:38 <saurabhnanda> is there some standard type available to represent a URL?
22:30:54 <EvanR> there is probably a package with a URL type with lots of url operations
22:31:33 <saurabhnanda> EvanR: wreq should have it, right?
22:31:40 <EvanR> i dont know
22:31:54 <EvanR> to the docs
22:32:19 <ski> (stasiana : trying them all, using the current version, would be :  anyChar :: Parser Char; anyChar = Parser (\char -> asum [c <$ char c | c <- ['\0' ..]])
22:32:53 <saurabhnanda> looking at http://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq-Types.html
22:33:28 <saurabhnanda> reqURL :: Req -> ByteString // Return the URL associated with the given Req.
22:33:38 <saurabhnanda> seems to be using a standard ByteString to represent a URL
22:34:03 <saurabhnanda> I guess I'll run with // newtype URL = URL String deriving (Show, Eq)
22:34:28 <EvanR> ByteString has the same issues as String
22:35:03 <EvanR> i see two packages with a URL type, url and the standard network package
22:35:27 <EvanR> and network-uri 
22:35:33 <saurabhnanda> cabal build && cross fingers
22:36:10 <EvanR> working with urls as Strings is kind of like working with JSON data as strings
22:36:33 <saurabhnanda> 4 errors only. Not that bad...
22:36:37 <EvanR> its usually something that looks like a string, but its not really
22:36:51 <EvanR> theres structural assumptions built in
22:37:22 <saurabhnanda> EvanR: yes, using a URL type is a better idea. Let me look for the simplest one
22:38:33 <ski> stasiana : hm, sorry, i missed you mentioning "digit" there
22:40:08 <ski> statusfailed : i think you could use `Text.Parsec.parse (run digit ((() <$) . Text.Parsec.char)) ""' to grab a digit. with the alternative version, try `Text.Parsec.parse (run digit Text.Parsec.Char.anyChar) ""'
22:40:12 <ski> er
22:52:28 <lpaste> adas pasted ‚ÄúHow may I do my types‚Äù at http://lpaste.net/153380
22:52:47 <adas> can someone please take a look ^^^^
22:55:14 <saurabhnanda> adas: why not use lists?
22:55:38 <EvanR> adas: when the format of the config changes, change the type
22:56:04 <adas> EvanR: yes, but I will have to edit the haskell source again..
22:56:06 <saurabhnanda> data Event = Event String; data EventList = [Event]; data Java = Java EventList?
22:56:06 <EvanR> you can also use a more dynamic data type, like json
22:56:14 <adas> EvanR: which would be nice If I can avaoid
22:56:27 <EvanR> if the config changes, wont you have to edit some code somewhere to deal with it?
22:56:48 <EvanR> you need to decide on the format of the config at some point
22:57:00 <adas> saurabhnanda: I know what you mean. But I want to model the fact that .. say .. Java only has 2 events. Php only 4 events. Dotnet only 1 event.. at the type level
22:57:14 <adas> EvanR: the format of the config will never change
22:57:15 <EvanR> then you have this
22:57:22 <adas> EvanR: it will always be the same..
22:57:26 <adas> EvanR: only the contents change
22:57:28 <EvanR> Config Java Java Php Php Php Php Dotnet
22:58:13 <EvanR> any more or less and you wont be able to build it
22:58:43 <adas> saurabhnanda: If I use a list, then illegal states are representable. ANd I want illegal states to be non-representable
22:59:05 <saurabhnanda> adas: data Java = Java Event Event Event
22:59:08 <adas> EvanR: can you elaborate?
22:59:34 <EvanR> your config type has 7 fields
22:59:43 <EvanR> make a type with 7 fields
22:59:49 <EvanR> not 3 types
23:00:25 <adas> saurabhnanda: yes that is hardcoded in the .hs file. but what if one day the config changes and we have "Java - Event1, Event2, Event3, Event4, Event5". Then I have to edit the hs source again
23:00:41 <adas> EvanR: why 7?
23:00:56 <pavonia> adas: You just said the format will never change!?
23:00:57 <EvanR> you cant say there ar exactly 4 in the types and then change it to 5 without modifying the code
23:01:00 <saurabhnanda> adas: isn't that a direct effect of your earlier statement -- "If I use a list, then illegal states are representable. ANd I want illegal states to be non-representable"
23:01:22 <adas> pavonia: the format is <language> - <Event>..
23:01:24 <EvanR> the types serve as a specification, so if your spec changes, you need to change the types
23:01:52 <adas> EvanR: TH?
23:02:09 <EvanR> so you are ok with recompiling but not modifying code?
23:02:19 <EvanR> what WOULD you be ok with changing
23:02:20 <pavonia> adas: So what exactly may change in the future and what not?
23:03:21 <adas> pavonia: config can change, but only within the rules of the format. you can delete entries or add entries. But if you add an entry it must always be off the form <language> - <Event>...
23:03:30 <adas> pavonia: .hs source file should not change
23:03:36 <EvanR> then youll have to use lists
23:03:37 <adas> pavonia: recompilation is okay
23:03:48 <EvanR> the spec is "any number of foo"
23:05:10 <pavonia> Why would you want to recompile if the source doesn't change?
23:05:28 <EvanR> because whatever the TH reads might change 
23:05:42 <EvanR> which brings up the next question
23:05:46 <adas> because whatever the TH reads from config file
23:05:53 <adas> may change
23:06:19 <Lokathor> it's weird that Num doesn't have Eq as a superclass
23:06:23 <EvanR> so TH is reading the config file to determine the format? then reading its own self in then checking its self consistent?
23:06:48 <EvanR> Lokathor: well... some Nums dont have a working Eq
23:07:06 <pavonia> Oh, I thought this config file should be read at runtime
23:07:10 <Lokathor> i assume you mean floating point numbers
23:07:19 <EvanR> that works
23:07:21 <Shockk> hoogle thinks it does
23:07:26 <Shockk> class (Eq a, Show a) => Num a
23:07:39 <adas> pavonia: nope. read once and run many times. unless the config changes
23:07:43 <EvanR> :i in ghci says it doesnt
23:07:50 <EvanR> Eq and Show was removed a while back
23:07:57 <Shockk> ahhh
23:08:06 <EvanR> Lokathor: computable reals
23:08:06 <Shockk> hoogle out of date?
23:08:12 <adas> I think I might have dug myself in by using the word "config"
23:08:15 <Lokathor> https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Num
23:08:22 <adas> it's more of a "Spec" than a "config"
23:08:27 <cocreature> Shockk: use the new hoogle http://hoogle.haskell.org/?hoogle=Num
23:08:36 <adas> infact its not a "config" at all. It's a "Spec"
23:08:40 <EvanR> adas: ah, so this config is really a proxy for your type defs
23:08:45 <Lokathor> EvanR, are there... computable reals that aren't floating point numbers?
23:08:53 <EvanR> yeah, like pi
23:09:03 <EvanR> or sqrt 2
23:09:03 <adas> EvanR: proxy for type defs?
23:09:31 <EvanR> the point would have to be floating infinitely far to the left
23:11:15 <ahihi> or 0.1
23:11:21 <EvanR> heh
23:11:41 <EvanR> that could be a base 10 floating point number
23:14:13 <Lokathor> EvanR, let me rephase: are there computable reals that are digitally encoded in a computer system such that the computer can use them in a computation that aren't floating point numbers?
23:14:49 <EvanR> right like pi or sqrt 2
23:14:55 <EvanR> pi :: CReal
23:14:57 <EvanR> > pi :: CReal
23:15:04 <lambdabot>  3.1415926535897932384626433832795028841972
23:15:10 <cocreature> lambdabot: you might want to watch https://www.youtube.com/watch?v=LJQgYBQFtSE
23:15:24 <EvanR> > pi + 1 :: CReal
23:15:32 <lambdabot>  4.1415926535897932384626433832795028841972
23:15:45 <EvanR> ignore its default truncation ;)
23:16:01 <ahihi> that's just the Show instance, right?
23:16:03 <Lokathor> now, i'm an idiot maybe, but how is it doing that if not by floating point?
23:16:08 <Lokathor> or, do i have to watch the whole video?
23:16:37 <EvanR> conceptually its not hard to see how it is possible
23:16:54 <EvanR> you can calculate pi yourself on paper with the long division and squaring, cubing etc
23:17:07 <EvanR> you stop when you get tired or run out of paper
23:17:23 <ahihi> https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/src/Data-Number-CReal.html
23:17:49 <Lokathor> isn't that... a floating point computation? like, okay, as i understand numbers at the bit level, they're basically integral or floating point or fixed point and that's like.. all three ways to encode numbers into bits
23:17:53 <johnw> Lokathor: if by "floating point" you mean IEEE 754, then it is an encoding of a binary fraction plus a significand as a regular binary encoded integer
23:17:53 <cocreature> Lokathor: the short story is that you store a number as a way to calculate it to an arbitrary number of digits instead of storing a fixed number of precalculated digits
23:18:04 <EvanR> Lokathor: youd use rationals for all intermediate state, on paper at least
23:18:15 <EvanR> or the integer parts of rationals
23:18:18 <johnw> some real numbers, however, could be represented in other forms than that, even as decimal strings
23:18:35 <Lokathor> ah, hmm
23:19:09 <EvanR> your intermediate state grows and grows the deeper you go
23:19:21 <EvanR> so you need infinite memory
23:19:22 <Lokathor> and only gets realized once at the end
23:19:22 <johnw> I'm working on a program right now where floating point reals are impractical, so I'm just using rationals to approximate
23:20:02 <EvanR> did you consider scientific?
23:20:18 <EvanR> i guess sqrt would throw a wrench in 
23:20:31 <EvanR> (or dividing by 3)
23:21:22 <cocreature> dividing by 3 is heresy
23:21:33 <Lokathor> x >> 1.5
23:21:56 <johnw> unless you're counting in trinary I guess
23:22:12 <EvanR> > 1/3
23:22:20 <lambdabot>  0.3333333333333333
23:22:25 <EvanR> > 1 >> 1.5
23:22:30 <lambdabot>      Could not deduce (Num (m a0))
23:22:34 <lambdabot>      from the context (Fractional (m b), Monad m, Num (m a))
23:22:36 <lambdabot>        bound by the inferred type for ‚Äòe_1115‚Äô:
23:23:25 <EvanR> > sqrt (2 * 4)
23:23:32 <lambdabot>  2.8284271247461903
23:24:22 <levi> Lokathor: Even if you only consider the sets N, Z, Q, R, and C to be "numbers", there are still more ways to represent them than you can shake a stick at.
23:24:54 <Lokathor> levi, i don't know what types of numbers most of those letters even mean
23:25:16 <daniel-s> 4+3
23:25:25 <levi> N = Naturals, Z = Integers, Q = Rationals, R = Reals, C = Complex
23:25:50 <Lokathor> i confess that i don't know much math, i'm more interested with the engineering elements than the rest of the theory
23:26:06 <levi> Those are all used in engineering maths, though.
23:26:18 <ahihi> and it doesn't end there!
23:26:22 <ahihi> quaternions are useful as well
23:26:31 <johnw> every one of those letters are types in some languages :)
23:26:36 <johnw> with the same meanings
23:26:48 <EvanR> sometimes broken 
23:26:52 <EvanR> like Reals
23:27:02 <johnw> in Coq Reals are just axiomatized.  "Not my problem" :)
23:27:31 <levi> johnw: Not very useful for engineering purposes! :)
23:27:39 <Lokathor> levi, not the math for engineering :P the engineering of math. Like, how the number gets encoded into bits, and then moved around between registers and stuff.
23:27:54 <johnw> well, it just means I have to manually transport the axioms into Haskell functions
23:28:07 <johnw> but I get to choose whichever mapping works best for the problem at all
23:28:25 <johnw> at hand*
23:29:02 <levi> Lokathor: The amount of math that you can do with the native bit encodings without any extensions is paltry compared to the math you can do in general with a computer, though.
23:29:11 <EvanR> ok. im about the try speeding up a pure function by using unsafePerformIO
23:29:22 <EvanR> if im not back in 10 minutes call the cops
23:29:25 <johnw> EvanR: don't do it! there's so much to live for!
23:30:28 <Lokathor> levi, the ability to do things with it and the ability for it to be interesting are totally distinct dimensions far more often than not
23:30:49 <EvanR> Lokathor: how faithful the implementations are to the "real thing" is pretty interesting AND practical
23:30:49 <levi> Lokathor: I am not sure what you're getting at with that statement.
23:31:19 <EvanR> ex. floats lack of associative ops
23:32:05 <Lokathor> levi, I mean that I'm interested in the very basic engineering of bits not because it's the most useful element of computing, but because it's just plain interesting. Meanwhile, there are plenty of more "useful" fields of math and computing that i just don't care about at all
23:32:08 <levi> I have a big fat textbook on using computers to solve numeric problems without going totally off into the weeds due to the potential failures of computer number representations.
23:32:39 <ahihi> levi: what's it called?
23:32:58 <levi> I don't remember the exact name, but it's got "Numerical Methods" in it.
23:32:58 <Lokathor> levi, perhaps the word i should be using is "orthogonal"
23:33:39 <levi> Lokathor: That's fine; no one can force you to be interested in stuff. I'm not sure what this has to do with Num and Eq though.
23:34:13 <Lokathor> well we meandered from there to here. Long conversations are rarely faithful to their inception
23:34:29 <ahihi> "Numerical Methods for Scientists and Engineers", maybe?
23:34:31 <haskell968> What is the best place to ask a lens related questions?
23:34:34 <ahihi> seems to have good reviews at least
23:34:36 <levi> ahihi: Could be?
23:34:39 <johnw> either here or #haskell-lens
23:36:32 <levi> I had forgotten enough calculus by the time I took the course that I was perpetually trying to catch up, and it's been ages since then again, so mostly I remember that doing numeric calculations is fraught with peril for the unwary.
23:36:38 <{AS}> Is there any reason why MonadFail requires fail to take a String, or is it just for historic reasons?
23:36:52 <Lokathor> historic
23:36:57 <Lokathor> breaks the least amount of code that way
23:37:23 <{AS}> Lokathor OK, thanks
23:39:24 <levi> Anyway, I was curious if what you were saying still had any relevance to Eq, or if your question about it had been resolved, or if we were just totally on a tangent.
23:39:39 <ski> Lokathor : i would've thought "the engineering of math" would be stuff like how to manage lemmas, theorems, definitions, theories, &c.
23:40:11 <Lokathor> i always feel so outgunned on #haskell
23:40:58 <levi> I am not gunning for you, I am just feeling unmoored in the conversation.
23:41:37 <levi> Like, "are the points I'm making even relevant to you, or are we just rambling past one another?"
23:42:11 <Lokathor> oh i was responding to ski
23:42:19 <ski> {AS} : `fail' is basically for reporting error strings automatically generated by the implementation in case of failable patterns in `do' (and in monad comprehensions, i think ?)
23:43:05 <{AS}> ski: Ah thanks. But I thought it didn't make sense if you e.g. had Either Boolean
23:43:10 <Lokathor> levi, yes i suppose it makes sense that "numbers" that aren't literal bit strings wouldn't be testable for equality in a meaningful sense
23:43:52 <EvanR> some are some arent
23:43:58 <{AS}> I mean the string is probably being dropped unless you explicit have somewhere to put it :)
23:44:02 <EvanR> you can test rationals for equality
23:44:09 <levi> It's not so much that you can't test the bit strings for equality, it's just that bit string equality doesn't always represent numeric equality.
23:44:41 <EvanR> if they are made of two integers which can be compared for equality
23:45:11 <ahihi> the fact that equality on CReals may not terminate stems from the fact that you may have to compare an infinite amount of digits
23:45:32 <EvanR> or show the programs are equivalent
23:45:38 <ski> {AS} : yes
23:46:34 <ski> Lokathor : (arbitrary) real numbers aren't "testable for equality in a meaningful sense", as you may or may not know
23:47:35 * ski is slow
23:47:59 <ahihi> EvanR: well, yes, but surely the implementation doesn't even try that? :P
23:48:11 <levi> Part of the reason there's no Eq for Num is that, when we're dealing with approximations for Reals, there's more than one reasonable way to do approximations of equality; putting an Eq constraint would require us to commit to *one* approximation of equality.
23:48:50 <johnw> it would also give the false sense that compares Floats for equality means something
23:49:26 <levi> johnw: It *can* mean something if you mean equality up to some approximation.
23:49:49 <johnw> so, not equal, just equivalent?
23:49:50 <Lokathor> well if two floats have the same bits I expect them to count as equal at least then
23:50:03 <{AS}> One wants to have a family of equalities :)
23:50:08 <Lokathor> though other situations are fuzzier perhaps
23:50:23 <johnw> Lokathor: you could represent 0.5 with a larger mantissa that is full of zeroes
23:50:28 <levi> johnw: We're already playing a bit fast and loose using floats as Reals in the first place. :)
23:50:35 <{AS}> but even comparing floats to some approximation is actually faulty
23:50:44 <EvanR> johnw: im back. i got Bus error: 10 ;)
23:51:12 <Ashy> ok so with stack in a new project what's the process of adding postgresql-simple as a dependency?
23:51:15 <Lokathor> {AS}, in the sense that you're get false negatives? or false positives? or both?
23:51:23 <{AS}> When you write programs depending on Float you would usually like to have a sound overapproximation to show that your code is correct
23:51:45 <ahihi> > 0/0 == 0/0
23:51:54 <lambdabot>  False
23:52:00 <Ashy> ive tried adding it to my stack.yaml:
23:52:01 <Ashy> extra-deps:  - postgresql-simple
23:52:12 <Ashy> (there's a newline in there in the file)
23:52:24 <{AS}> Lokathor: It depends on the size of your numbers
23:52:24 <Ashy> but stack is unable to parse that field
23:52:38 <{AS}> and how you do the calculations
23:52:53 <Lokathor> hmm, this is perhaps getting too deep for 1am
23:52:59 <Lokathor> but i will keep this in mind for later
23:53:00 <Ashy> so im guessing i need to specify a version on the end, but what that's a bit crap if i have to go look it up isnt it?
23:53:10 <{AS}> Lokathor:  http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
23:53:13 <ski> @check \x y z -> ((x :: Float) + y) + z == x + (y + z)
23:53:13 <Ashy> how do i get stack to just grab the latest version from the current resolver?
23:53:20 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 108 shrinks):
23:53:22 <lambdabot>  -1.3112736 -0.96229655 -0.92311585
23:53:31 <{AS}> wait: http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm is the latest version
23:54:05 <Lokathor> tricked by a frame!
23:54:08 <Lokathor> it didn't update your URL
23:54:16 <{AS}> argh
23:54:16 <Lokathor> https://randomascii.wordpress.com/category/floating-point/ appears to be the correct link
23:54:30 <liste> Ashy: you don't need to include lts/stackage packages in stack.yaml extra-deps
23:54:55 <Hijiri> > ((-1.3112736 + -0.96229655) + -0.92311585, -1.3112736 + (-0.96229655 + -0.92311585))
23:54:58 <{AS}> http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
23:54:59 <lambdabot>      Precedence parsing error
23:55:01 <lambdabot>          cannot mix ‚Äò+‚Äô [infixl 6] and prefix `-' [infixl 6] in the same infi...
23:55:03 <lambdabot>          cannot mix ‚Äò+‚Äô [infixl 6] and prefix `-' [infixl 6] in the same infi...
23:55:11 <Hijiri> > ((-1.3112736 + -0.96229655) + -0.92311585, (-1.3112736) + (-0.96229655 + -0.92311585))
23:55:17 <lambdabot>      Precedence parsing error
23:55:19 <Hijiri> ok, sorry
23:55:20 <lambdabot>          cannot mix ‚Äò+‚Äô [infixl 6] and prefix `-' [infixl 6] in the same infi...
23:55:21 <lambdabot>          cannot mix ‚Äò+‚Äô [infixl 6] and prefix `-' [infixl 6] in the same infi...
23:55:28 <Ashy> liste: so where do i put them?
23:55:42 <liste> Ashy: in your .cabal file
23:56:14 <{AS}> @check \x y z -> (((x :: Float) + y) + z) -  (x + (y + z)) <= 0.5
23:56:20 <lambdabot>  +++ OK, passed 100 tests.
23:56:21 <EvanR> > (((-1.3112736) + (-0.96229655)) + (-0.92311585), (-1.3112736) + ((-0.96229655) + (-0.92311585)))
23:56:22 <Ashy> OH
23:56:26 <Ashy> liste: cheers
23:56:30 <lambdabot>  (-3.196686,-3.1966859999999997)
23:56:40 <{AS}> @check \x y z -> abs ((((x :: Float) + y) + z) -  (x + (y + z))) <= 0.5
23:56:46 <lambdabot>  mueval-core: Time limit exceeded
23:58:29 <{AS}> @check \x y z -> abs ((((x :: Float) + y) + z) -  (x + (y + z))) <= 0.5
23:58:36 <lambdabot>  +++ OK, passed 100 tests.
23:59:55 <EvanR> nice i made a factorial that is fast around 40000 when the naive version takes a few seconds
