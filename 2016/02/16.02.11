00:01:13 <ReinH> Or maybe his opinion was that the former thing should exist but not be called Maybe. I can't recall.
00:01:46 <jle`> your initial statement reflects his views afaik
00:01:59 <jle`> source: i heard him say it here last week
00:02:18 <ReinH> nice
00:03:38 <ReinH> Either way, instance Monoid a => Monoid (Maybe a) is just annoying.
00:07:39 * hackagebot xcffib 0.4.1 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.4.1 (TychoAndersen)
00:07:39 * hackagebot dbmigrations 1.1 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-1.1 (JonathanDaugherty)
00:08:55 <lpaste> echo-area annotated “corollary of universal property” with “corollary of universal property (annotation)” at http://lpaste.net/152088#a5971670215656734720
00:32:51 <montanonic> Broad question here. I'm trying to understand how to use the `operational` package, and what benefits that approach has (I'm still not entirely clear on how it's useful as the toy examples don't seem much-improved compared to simple function composition). I was hoping that people could comment upon its value, and also perhaps recommend some alternatives to it.
00:33:29 <montanonic> I started looking into it because https://hbtvl.wordpress.com/2015/06/28/servant-persistent-and-dsls/ uses it in making a Servant CRUD API with Auth
00:36:09 <shanemikel> so, for all you legacy barbarians still using cabal, If I'm managing various sandboxes, careful never to install anything globally, and I accidentally do a cabal install command outside of a sandbox dir, how can I clean everything out of cabal global namespace without needing to rebuild everything in my sandboxes? Am I wrong, or do the sandboxes keep some information in ~/.cabal ?
00:36:28 <geekosaur> montanonic, operational is a free monad implementation. the point of it is that you can substitute different "backends"; for example you can replace a network connection with mocking in something using http, or you can provide text and graphical user interfaces
00:36:29 <shanemikel> so I can't just rm -r ~/.cabal ~/.ghc, or can I?
00:37:22 <montanonic> geekosaur: right, okay; so like it shows in the `Random` example, with Sampling vs Distributions
00:37:38 <geekosaur> shanemikel, you can rm -r ~/.ghc. there will be stuff in ~/.cabal, but (a) one of those things is ~/.cabal/config which you do not want to remove (b) if ~/.ghc is removed then nothing under ~/.cabal/lib will be referenced or found
00:38:08 <geekosaur> (c) you also don't want to remove cabal's cache of known packages
00:38:10 <montanonic> geekosaur: Does it open up many areas for bad performance hits? I'm a tad scared of making Monads after seeing that Writer can and will lead to space leaks
00:39:02 <shanemikel> geekosaur: just for the sake of ocd and wasted space, is there a particular directory I can remove in ~/.cabal that will get rid of the stuff for which there is no longer any reference from ~/.ghc ?
00:39:34 <shanemikel> or just ~/.cabal/lib, I guess you said that
00:39:42 <geekosaur> just that, really
00:39:56 <shanemikel> and this world file?
00:40:00 <shanemikel> safe to delete?
00:40:05 <koz_> How do you put a package on Hackage?
00:40:27 <geekosaur> shanemikel, yes
00:41:19 <liste> koz_: create an account and upload using "cabal upload" or manually
00:41:21 <geekosaur> montanonic, any time you do something indirectly like this you could potentially introduce extra laziness, although that's generally a different kind of leak
00:41:54 <koz_> liste: Do I need anything in my .cabal file for this to work properly besides the usual stuff?
00:42:06 <montanonic> geekosaur: alright. Thank you for clarifying the purpose of `operational` for me. 
00:42:57 <geekosaur> you will be creating data structures that store the monad operations (return and bind) instead of calling them; the "interpreter" then feeds those to the actual monad. done properly (don't add extra stuff and don't do anything silly in the interpreter) this should not take up any more space
00:43:42 <liste> koz_: cabal upload will check your package quality. there's also a -c switch for just running the checks, not uploading
00:43:44 <geekosaur> but with this it's easier to get right than wrong, whereas Writer it's too easy to get wrong and produce space leaks
00:46:16 <montanonic> That makes me feel less nervous. Thanks again geekosaur!
00:46:31 <liste> koz_: cabal check also does that, it seems easier
00:47:06 <koz_> liste: Thanks - I'll keep that in mind.
00:57:15 <koz_> 'cabal upload' doesn't seem to wanna upload. Do I need to first run some packaging command?
01:01:55 <liste> koz_ cabal sdist
01:02:02 <koz_> liste: *Just* figured that out. Thanks!
01:03:01 * hackagebot awesome-prelude 0.1.0.0 - A prelude which I can be happy with. Based on base-prelude.  https://hackage.haskell.org/package/awesome-prelude-0.1.0.0 (kozross)
01:33:01 * hackagebot distributed-closure 0.2.1.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.2.1.0 (MathieuBoespflug)
02:14:19 <graeme_> test
02:32:26 <liste> koz_: awesome-prelude yours?
02:33:04 * hackagebot reflection 2.1.2 - Reifies arbitrary terms into types that can be reflected back into terms  https://hackage.haskell.org/package/reflection-2.1.2 (EdwardKmett)
02:38:11 <gfixler2> what prevents us from having * :: * currently?
02:39:02 <jle`> you can have it if you get ghc 8.0 :)
02:39:15 <jle`> or what do you mean by your question, other than that it's not implemented?
02:39:22 <mauke> :k (*)
02:39:24 <lambdabot> *
02:39:36 <gfixler2> is it a kind vs type thing?
02:39:43 <gfixler2> * has kind *, but not type *?
02:40:05 <mauke> what's * ?
02:40:16 <gfixler2> lifted types?
02:40:22 <gfixler2> boxed types?
02:40:24 <gfixler2> concrete values?
02:40:26 <gfixler2> strict values?
02:40:28 <gfixler2> I don't know?
02:40:43 <jle`> are you asking why * :: * isn't true in current ghc?
02:40:53 <merijn> gfixler2: * can't have "type *" because types don't have types
02:40:59 <jle`> or why current ghc can't be changed to have * :: *
02:41:05 <gfixler2> :t ()
02:41:07 <lambdabot> ()
02:41:16 <jle`> (the second thing probably isn't true, because * :: * is possible)
02:41:18 <merijn> gfixler2: VALUES have types, types have kinds and then you have a choice
02:41:18 <gfixler2> merijn: true
02:41:31 <gfixler2> so what's the deal with * :: *?
02:41:35 <merijn> gfixler2: Old GHC went "kinds have sorts" and it stopped there
02:41:52 <jle`> do you understand why * :: * isn't true/doesn't make sense in current ghc?
02:42:04 <gfixler2> jle`: no - that's what I'm after
02:42:14 <jle`> ah, ok
02:42:18 <merijn> gfixler2: Agda/Idris/etc. go the Calculus of Constructions way where we say "we have an infinite hierarchy of kinds" where types have kind *0, *0 has kind *1, etc. up to infinity
02:42:21 <gfixler2> I've been watching Eisenberg's talk
02:42:23 <gfixler2> a few times now
02:42:32 <gfixler2> he sort of jumps to * :: * without any transition
02:42:35 <merijn> The third way is that you say "kind * has kind *"
02:42:38 <gfixler2> the stuff before it doesn't relate in my mind
02:42:51 <fooba> Hey guys. I was reading about monads. One thing which I can't get is how to decide what value do I get when I use '<-'. When I use it with say IO (a,b), it gives me a tuple but when I use it with Writer (a, b) it doesn't give a tuple back. How do I decide its behavior?
02:42:52 <ahihi> there's a talk? link? :)
02:42:55 <dominik> is there any way to parse a string into a Template Haskell AST? 
02:43:00 <jle`> in current ghc, * is the kind of types that can have values of them.  so, Int :: *, Bool :: *
02:43:06 <jle`> some common examples of things that aren't * are Maybe :: * -> *
02:43:10 <jle`> Either :: * -> * -> *
02:43:12 <jle`> etc.
02:43:18 <gfixler2> fooba: the monad decides it by its implementation
02:43:28 <mauke> fooba: it does give you a tuple with Writer
02:43:35 <lyxia> :k Writer
02:43:37 <lambdabot> * -> * -> *
02:43:40 <merijn> fooba: My advice is generally to avoid do notation UNTIL you are comfortable writing the same code without do notation. See, https://en.wikibooks.org/wiki/Haskell/do_notation
02:43:41 <gfixler2> jle`: right
02:43:50 <jle`> fooba: if you use <- with Writer w (a, b), you should get the tuple
02:44:10 <fractalsea> Hi can anyone help me write `mapPropertyM :: (m a -> n a) -> PropertyM m a -> PropertyM n a` for http://haddock.stackage.org/lts-5.2/QuickCheck-2.8.1/Test-QuickCheck-Monadic.html#t:PropertyM ? I’m getting completely lost in the types. Thank you
02:44:16 <dominik> similar to how one can parse [| some real haskell code |] into a Q Exp, I'm wondering if there is something like [| "some real haskell code" |] as well.
02:44:22 <gfixler2> jle`: are you saying functions aren't values?
02:44:32 <jle`> functions are values
02:44:35 <jle`> but functions have kind *
02:44:39 <gfixler2> oh?
02:44:41 <jle`> `Int -> Bool` is a function
02:44:43 <jle`> it has kind *
02:44:47 <jle`> :k Int -> Bool
02:44:48 <lambdabot> *
02:44:51 <jle`> or, Int -> Bool is the type of a function
02:44:53 <gfixler2> ah, right
02:44:55 <jle`> and the type has kind *
02:45:05 * merijn was about to be pedantic about that ;)
02:45:09 <jle`> yeah, heh
02:45:12 <gfixler2> I'm mixing functions with ADT constructors
02:45:15 <jle`> being pedantic is probably important here
02:45:20 <gfixler2> indeed
02:45:30 <gfixler2> this is built of pedantry
02:45:33 <jle`> so, how would * :: * even make sense, under this interpretation?
02:45:36 <merijn> gfixler2: The type of constructors is also of kind *
02:45:43 <puregreen> dominik: what do you mean? 
02:46:01 <gfixler2> merijn: then I'm more wrong than I thought I was a minute ago
02:46:23 <gfixler2> so it's type constructors that can have * -> * -> etc kinds
02:46:24 <jle`> the type of constructors like Just and Left have kind *
02:46:25 <bennofs1> merijn: ehm? isn't it kind * -> *?
02:46:28 <merijn> gfixler2: "Just" has type "a -> Maybe a" and the kind of "a -> Maybe a :: *"
02:46:30 <mauke> for any value x, the type of x has kind *
02:46:38 <merijn> bennofs1: That's the kind of TYPE constructors
02:46:45 <merijn> mauke++
02:46:46 <bennofs1> right
02:46:49 <gfixler2> now it's sinking in
02:46:58 <dominik> puregreen: I mean, using template haskell for instance, I can write [| True == False |] and it gives me the TH AST of this expr inside the Q monad.
02:47:04 <gfixler2> * -> * means a type is needed to create a type
02:47:13 <merijn> "Maybe :: * -> *", "Maybe a :: *" (given "a :: *", else it's a kind error)
02:47:17 <jle`> gfixler2: * :: * doesn't even really make sense in current ghc, right?
02:47:28 <jle`> it's kind of silly
02:47:28 <merijn> Therefore "a -> Maybe a :: *"
02:47:31 <puregreen> dominik: yep, I didn't understand the 2nd part
02:47:36 <gfixler2> jle`: are they intended to be the same thing?
02:47:54 <puregreen> dominik: what do you want [| "True == False" |] to give?
02:47:58 <gfixler2> is the one on the left supposed to be a value, and on the right a type?
02:47:59 <dominik> puregreen: however, what if my code is represented as a string? Is there a way to execute [| "some haskell in a string" |] and to get the TH AST that is represented by the concrete haskell code inside the string?
02:48:04 <gfixler2> because () gets away with that
02:48:08 <jle`> gfixler2: exactly, it doesn't make sense
02:48:17 <gfixler2> jle`: but it makes sense for (), no?
02:48:19 <bennofs> jle`: it just means that in GHC 8.0, types and kinds will be the same
02:48:26 <jle`> not sure what you mean there
02:48:28 <gfixler2> bennofs: like idris?
02:48:29 <bennofs> so * is just another type
02:48:34 <gfixler2> :t ()
02:48:36 <lambdabot> ()
02:48:37 <jle`> yes, i was leading into that
02:48:44 <gfixler2> () :: ()
02:48:50 <gfixler2> so why can't * :: *?
02:48:57 <merijn> gfixler2: Because those () are DIFFERENT
02:48:58 <dominik> puregreen: basically I would like some way of getting rid of the string, so that it could convert the real code again into a TH ast
02:49:11 <jle`> () :: () is only because the value constructor and the type happen to have the same name
02:49:17 <Jinxit> will GHC 8.0 allow us to encode matrix dimensions in types? or is that already possible?
02:49:18 <jle`> @let data Unit = U
02:49:20 <lambdabot>  Defined.
02:49:20 <merijn> gfixler2: In GHC we have "data () = ()", but let's rephrase that as "data Unit = Unit" which gives "Unit :: Unit"
02:49:22 <jle`> :t U
02:49:23 <lambdabot> Unit
02:49:36 <merijn> gfixler2: But secretly we have "data UnitType = UnitValue" with "UnitValue :: UnitType"
02:49:48 <jle`> the () and () are different, they just happen to have been named the same thing for the purpose of confusing people :)
02:49:49 <merijn> gfixler2: Whereas "* :: *" is talking about "UnitType :: UnitType"
02:49:52 <dominik> puregreen: did that make sense?
02:50:07 <lyxia> fractalsea: that doesn't seem possible
02:50:08 <jle`> named the same as in, given the same lexical text identifier
02:50:09 <gfixler2> jle`: that's what I'm getting at - are the * and * intended to be the same, unlike the () case?
02:50:10 <jle`> but they aren't the same thing
02:50:13 <merijn> gfixler2: Yes
02:50:15 <gfixler2> merijn: that answers it
02:50:15 <jle`> they are intended to be the same
02:50:20 <gfixler2> ok
02:50:24 <gfixler2> I'm back on board
02:50:26 <gfixler2> it doesn't make sense
02:50:29 <fractalsea> lyxia, really? Why not?
02:50:44 <merijn> gfixler2: It produces an inconsistent logic when considering Curry-Howard, yes
02:50:44 <jle`> you can say Type :: Type too, if you like using words
02:51:00 <jle`> types and kinds are now the same thing, so the "type of types" is itself a type
02:51:09 <jle`> Bool :: Type, Maybe :: Type -> Type
02:51:15 <jle`> Either :: Type -> Type -> Type
02:51:19 <jle`> and now, Type :: Type
02:51:21 <gfixler2> this is sounding like my brief interlude with idris
02:51:39 <gfixler2> though I think that was values == types
02:51:45 <jle`> Bool is a Type, Maybe is a Type -> Type, and Type is also a Type
02:51:45 <merijn> gfixler2: Yes, but Idris has a nicer (theoretical) approach
02:52:12 <merijn> gfixler2: Idris avoids the inconsistency using CoC (i.e. an infinite hierarchy of kinds)
02:52:17 <fr33domlover> it reminds me of RDF, where you have the class of classes
02:52:29 <bennofs> merijn: oh, and Haskell does have that inconistency?
02:52:32 <fr33domlover> and rdf:Class is itself an rdf:Class etc.
02:52:34 <jle`> to be consistent, you'd have something like Bool :: Type0, Int :: Type0
02:52:35 <gfixler2> it reminds me [worryingly] of the bowels of Python, where it ends in a loop at the bottom
02:52:38 <jle`> Type0 :: Type1
02:52:50 <jle`> Maybe :: Type0 -> Type0, etc.
02:52:52 <gfixler2> jle`: that's idrisy
02:53:03 <gfixler2> the type ladder
02:53:04 <jle`> yeah, haskell doesn't care about being consistent
02:53:09 <jle`> we're too real world rawr
02:53:11 <merijn> gfixler2: For future research, I recommend: the TaPL book, Henk Barendregt's "Introduction to Generalised Type Systems" (also known as the "lambda cube") and then the basics of CoC
02:53:20 <gfixler2> real world? I stick that in IO where it belongs
02:53:30 <sbrg> the TaPL book is awesome. 
02:53:44 <gfixler2> merijn: was going to ask about TaPL - are we talking the same sorts?
02:53:45 <merijn> gfixler2: The lambda cube paper is very readable if you know the basics of lambda calculus
02:53:49 <merijn> gfixler2: Yes
02:54:05 <gfixler2> merijn: then I have a shallow inkling of what that's about
02:54:28 <gfixler2> overarching question:
02:54:40 <lyxia> fractalsea: PropertyM is both variant and contravariant on Gen (m Property)
02:54:44 <gfixler2> is this levity business a fallout of our machine architectures?
02:54:52 <gfixler2> or is it fundamental to FP lazy/strict semantics
02:55:07 <fractalsea> lyxia, hmm ok. I think I need to look more into that…
02:55:08 <fractalsea> thanks
02:55:31 <puregreen> dominik: okay, I see, but I can't think of a way to do it yet
02:55:56 <lyxia> fractalsea: you can do it if you provide an inverse (n a -> m a) as well
02:56:19 * gfixler2 just realized he was thinking of something else, not tAPL
02:56:28 * gfixler2 owns tAPL, though, since Christmas
02:56:37 <fractalsea> lyxia, hmm ok. I need to have more of a think about it I think
02:59:51 <puregreen> dominik: see http://stackoverflow.com/questions/31412444/template-haskell-is-there-a-function-or-special-syntax-that-parses-a-string-a
03:00:13 <puregreen> (in particular, the comments)
03:04:15 <dominik> puregreen: thanks! It seems like haskell-src-meta is able to do this
03:04:55 <puregreen> dominik: well, but keep in mind that haskell-src-meta (and haskell-src-exts) are standalone Haskell parsers
03:05:01 <puregreen> they don't use GHC
03:05:49 <puregreen> and I think there are some differences between how GHC parses things and how haskell-src-exts parses things, but perhaps it's irrelevant for your usecase
03:13:56 <evenex> I am trying to better understand FRP. Suppose I have a service which listens to a socket, receives some bytes, interprets those bytes as some datatype, then does something with that datatype. I want to decompose it into "recvBytes | convert | doSomething" in a pipeline of callbacks. I think this is close to what FRP is supposed to be used for, but I was hoping someone with more experience with the paradigm could help me frame it in
03:14:23 <bennofs> evenex: that sounds more like streaming in my opinion
03:14:41 <gfixler2> I don't know what FRP means now
03:14:55 <evenex> bennofs: Yes, I agree. Are they orthogonal?
03:15:31 <bennofs> evenex: they share some similarities, but if you can get by with streaming, I don't think the added complexities of FRP are worth it
03:15:58 <merijn> evenex: I would say FRP is completely unrelated to streaming
03:16:10 <bennofs> FRP is more useful if you have complex state between the various "input" events 
03:16:30 <merijn> But I'm an FRP fundamentalist and think most of the existing "FRP" frameworks aren't FRP
03:16:48 <bennofs> merijn: :) is there a name for existing "FRP" frameworks?
03:16:48 <merijn> bennofs: I would say FRP is more useful if you DON'T have input events
03:16:54 <gfixler2> merijn: I'm curious about the efficacy of pure FRP
03:17:00 <merijn> bennofs: "event handling" :)
03:17:09 <bennofs> merijn: hmm, alright
03:17:09 <evenex> merijn: What's the difference?
03:17:21 <gfixler2> is streaming done with recursion schemes ever?
03:17:29 <gfixler2> they seem like they might fit the idea
03:17:52 <fr33domlover> Can I use multiple where_ in esqueleto? does the order matter?
03:17:56 <merijn> evenex: I would strongly recommend the "FRAN" and Push-Pull FRP papers on the ideas behind/design of FRP
03:18:06 <fr33domlover> I'm making an implicit join
03:18:23 <merijn> evenex: See http://conal.net/papers/push-pull-frp/ and http://conal.net/fran/
03:18:33 <evenex> merijn: Thanks
03:18:38 <gfixler2> http://conal.net/blog/posts/why-classic-frp-does-not-fit-interactive-behavior
03:18:39 <bennofs> merijn: why would you not have input events in real FRP? Would you see real FRP more as pull-driven rather than the push-driven applications its used in it existing libraries?
03:18:51 <merijn> bennofs: You have input events in real FRP
03:18:57 <merijn> bennofs: But not JUST events
03:18:57 <gfixler2> bennofs: check out that link
03:19:16 <merijn> bennofs: The crucial point is that FRP must have a notion of "continuous time"
03:19:30 <bennofs> merijn: ok. that basically means that you have to have at least a little bit of pull-driven functionality, which you don't have with most existing libraries
03:19:33 <merijn> i.e. values that have a continuous varying value
03:19:43 <merijn> bennofs: Right
03:20:16 <evenex> at first glance, FRP seems a bit like programming with a typed breadboard
03:20:48 <merijn> evenex: That's not a bad analogy
03:21:45 <merijn> evenex: The idea behind FRP is to find a vocabulary to talk about "continuous" behaviour, FRP is about "what do programs with continuous time mean?"
03:22:09 <merijn> Now there is a separate question "How could we efficiently implement the semantics of FRP?" which is still a tricky challenge
03:22:28 <mniip>  Closed (Tagged (TYPE Lifted))
03:22:28 <mniip> Source
03:22:28 <mniip> 	 
03:22:30 <mniip> oh boy
03:22:31 <akfp> if I have [2,4,3,2], and I want to pick out elements where the previous element is 2, so the result would be [4]. is there a lens expression for this?
03:22:38 <mniip> hackage using 8.0?
03:22:39 <merijn> So everyone just goes "well, we'll just implement the simple bits and ignore the continuous time", which kinda defeats the entire point of FRP, i.e. being able to talk about continuous time
03:22:48 <bennofs> merijn: what package is that?
03:23:09 <merijn> bennofs: I assume you mean mniip? :)
03:23:13 <mniip> hi
03:23:14 <bennofs> right
03:23:15 <bennofs> :)
03:23:17 <mniip> profunctors
03:23:28 <mniip> oh
03:23:30 <bennofs> mniip: statusbot Docs uploaded by user
03:23:45 <mniip> it looks like edwardk uploaded his own?
03:23:58 <mniip> <a href="file:///usr/local/share/doc/ghc/html/libraries/base-4.9.0.0/GHC-Exts.html#t:TYPE">TYPE</a>
03:23:59 <mniip> oops
03:24:23 <gfixler2> I've played with conal's idea of continuous images (x,y) -> color, and ran into some trickiness
03:25:09 <bennofs> merijn: do you think FRP is useful for use in traditional GUI applications? because I've found that actually, the continuous behaviours are not really need there (they're only used as "data stores")
03:25:12 <gfixler2> to render a bezier the usual way, you compute the points and draw them
03:25:20 <mniip> what's the difference between Star/Costar and Kleisli/Cokleisli?
03:25:26 <gfixler2> in the continuous-image way, you have to search around, rendering, looking for the points
03:25:39 <evenex> merijn: I implemented something like a streaming continuous time framework for series of physics experiments once. The data streams wrote asynchronously to ring buffers while the main thread ran on its own timing loop and sliced all of the data streams by time. So the diagnostic display would render from something like "voltageChannel[end - 50.ms .. end].convert.log.whatever"
03:25:47 <bennofs> mniip: Kleisli is for monads, Cokleisli for comonads :)
03:25:49 <gfixler2> because you're not talking about the points; you're talking about the space they're in
03:25:52 <evenex> I don't know if that is similar
03:26:01 <bennofs> mniip: so Kleisli is a -> m b,  Cokleisli is w a -> b
03:26:10 <evenex> But it was a lot more comfortable than using the existing tools offered by labview and matlab and whatnot
03:26:19 <mniip> bennofs, I know that yes
03:26:32 <mniip> how are they different from Star/Costar?
03:26:34 <bennofs> I don't have any deeper understanding of them either, sry :)
03:27:35 <mniip> newtype Star f d c = Star { runStar :: d -> f c }
03:27:36 <mniip> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
03:28:14 <bennofs> mniip: ah I see. Perhaps Kleisli is missing instances that the author of Star wanted?
03:28:18 <bennofs> (to avoid orphans)
03:28:27 <mniip> it's in base though
03:28:41 <mniip> (Kleisli)
03:28:48 <bennofs> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#t:Kleisli doesn't seem to have a Functor instance for example
03:29:45 <mniip> Star doesn't either
03:29:53 <mniip> oh
03:29:54 <mniip> it does
03:31:01 <mniip> on a slightly related note,
03:31:12 <mniip> did anyone rewrite the lens laws in terms of Lens s t a b
03:32:28 <mniip> e.g, l Identity = Identity -- I think that's the "you get back what you put in" law
03:32:36 <merijn> bennofs: Continuous behaviours not needed for GUIs? Oh? How about animations and clocks?
03:32:52 <merijn> bennofs: Hell, the very first FRP paper is on animation :)
03:33:11 <bennofs> merijn: ok, for animations perhaps.
03:33:46 <bennofs> mniip: you might like http://hackage.haskell.org/package/lens-4.13.2/docs/Control-Lens-Type.html#t:Optic
03:34:04 <merijn> evenex: For streaming operations there's a bunch of good libraries too, like pipes and conduits
03:34:11 <mniip> what about it
03:35:37 <bennofs> mniip: l pure ≡ pure
03:35:40 <bennofs> l (Procompose f g) = Procompose (l f) (l g)
03:35:49 <bennofs> This gives rise to the laws for Equality, Iso, Prism, Lens, Traversal, Traversal1, Setter, Fold, Fold1, and Getter as well along with their index-preserving variants.
03:35:52 <mniip> oh
03:36:04 <mniip> I thought you hyperlinked Optical
03:36:10 <mniip> because it scrolled down only so much
03:36:23 <bennofs> hackage ui is not the best :=)
03:38:06 * hackagebot rainbox 0.18.0.6 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.18.0.6 (OmariNorman)
03:38:23 <mniip> ooh
03:38:32 <mniip> I could use some rainboxes for my vector space category thing
03:39:49 <fr33domlover> Since base 4.8 is there a non-edgecase use case for mapM? considering traverse_ always works too
03:39:54 <fr33domlover> oops i mean mapM_
03:39:58 <fr33domlover> not maM
03:40:00 <fr33domlover> *mapM
03:40:33 <mniip> :t mapM_
03:40:35 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
03:40:38 <mniip> :t traverse_
03:40:41 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
03:40:44 <fr33domlover> in all the cases i'd use mapM_, i can now use traverse_
03:40:50 <fr33domlover> because every Monad is also Applicative
03:40:59 <mniip> some things have faster Monad instances than Applicative
03:41:01 <mniip> or so I hear
03:41:13 <mniip> faster -> more effictive
03:41:39 <fr33domlover> mniip, i was adviced to use fmap over liftM (i.e. the other direction) for the same reason :P
03:41:41 <fr33domlover> weird
03:41:46 <mniip> yes
03:41:53 <mniip> well
03:42:02 <mniip> fmap is usually much simpler than liftM
03:42:06 <fr33domlover> does a more specific type (Monad in place of Functor and Applicative) generally help optimize, or is it the other way around?
03:42:08 <mniip> but that is not the case for <*>/ap
03:42:57 <fr33domlover> mniip, you have any info about mapM_ being more efficient in specific cases?
03:43:05 <fr33domlover> i'm curious why and how and when :)
03:43:09 <mniip> not really no, sorry
03:43:09 <cocreature> mniip: do you have an example where ap is faster? I don’t see why you couldn’t just use that implementation for applicative in that case
03:45:28 <mchall_> I need to implement a function  repRandom :: [Gen a] -> Gen [a] in terms of generalA ::  (a -> a) -> Gen a -> Gen a genTwo :: Gen a -> (a -> Gen b) -> Gen b   mkGen ::  a -> Gen a  my code so far is  http://lpaste.net/152018 the code so far gets the right seed value but it is not collecting the a values. How do I use generalA to achieve this ?
03:47:19 <fr33domlover> simple intuition maybe: with Monad you have more assumptions, therefore more opportunities to optimize?
03:48:11 <lyxia> mchall_: in repRandom you are ignoring the parameter n
03:48:21 <fr33domlover> hmmm if anyone else has insights on mapM_ vs traverse_, plz share :)
03:48:38 <lyxia> mchall_: use generalA to add it back to the result of the recursive call.
03:49:08 <mchall_> lyxia would you mind showing me how this is done please
03:49:42 <mniip> hmm
03:49:52 <mniip> if we have view :: Lens s t a b -> s -> a
03:50:06 <mniip> it should also make sense to have view' :: Lens s t a b -> t -> b
03:50:27 <mniip> however the variance of types involved doesn't make sense
03:50:45 <lpaste> lyxia annotated “No title” with “mchall_ (annotation)” at http://lpaste.net/152018#a152218
03:50:58 <mniip> i.e in Lens, s is specifically contra while t is co
03:53:41 <mchall_> lyxia many thanks for the help
03:55:08 <cocreature> mniip: I don’t think we have view :: Lens s t a b -> s -> a, we only have view :: Lens s s a a -> s -> a
03:55:34 <mniip> but I just wrote one
03:55:54 <cocreature> mniip: hm ok, then it’s only the implementation in Control.Lens which doesn’t allow this
03:56:02 <cocreature> yeah that makes sense
03:56:06 <mniip> view :: Lens s t a b -> s -> a
03:56:06 <mniip> view l = getConst . l Const
03:59:01 <bennofs> mniip: actually, in order for laws to make sense, you need to have some relation between s <-> t and a <-> b   (they must be polymorphic enough so that they can unify). So lens only supports Lens s t a b if you can have s ~ t and a ~ b
03:59:09 <mniip> right
03:59:27 <mniip> hmm
04:00:49 <bennofs> mniip: see "Why is it Lens Family" in http://comonad.com/reader/2012/mirrored-lenses/
04:02:03 <MasseR> I wish I had time to really grok lenses
04:02:22 <MasseR> As it is, they are just a weird type that can give marginally better syntax for queries / modifications
04:02:33 <MasseR> Where I spend 2 hours figuring out the types every time I try to use them
04:02:43 <bennofs> MasseR: do you know Traversable?
04:03:27 <bennofs> if not, getting an intuition for Traversable will probably help with understanding lenses
04:04:17 <mniip> can you even "grok" lenses
04:04:30 <mniip> is there a limit to what you can understand about them
04:04:33 <bennofs> good question :D
04:04:43 <mniip> like
04:04:53 <mniip> I thought I understood 'Lens'
04:05:11 <ReinH> no lens is eternal
04:05:33 <mniip> I thought it's a way to unify 2 processes by abstracting Identity and Const r
04:05:55 <mniip> but then I realized that it makes sense for an arbitrary functor
04:06:10 <MasseR> bennofs: more or less
04:06:10 <mniip> aaand now I don't understand 'Lens' :D
04:07:07 <bennofs> lenses are really a way to "traverse" parts of a data structure, specially cases of that are collecting the value you reach with the traversal (using the Const r functor) or modifying the value (with the Identity functor)
04:07:29 <bennofs> at least that's how I think of them
04:07:41 <bennofs> but that analogy might be as helpful as monad analogies :p
04:07:48 <mniip> I see them as something that splits a data structure into a value and a one-hole context
04:08:27 <mniip> and after passing the value through the given function, adds the one-hole context inside the functor
04:08:52 <jophish_> What do people tend to put in extra-source-files?
04:08:59 <jophish_> Everything to be distributed in the tarball?
04:09:14 <mniip> this intuition also applies to Traversal
04:09:22 <bennofs> jophish_: i don't remember, does cabal have a data-files section?
04:09:32 <mniip> we split a data structure into some values and a /multi/-hole context
04:09:42 <mniip> and the power of Applicative lets us plug multiple holes at once
04:09:51 <jophish_> bennofs: yeah
04:10:25 <bennofs> jophish_: ok, then everything that is not a data-file (data files are installed) but that you still want in the tarball I guess (I'd think things like READMEs, etc)
04:10:55 <jophish_> that makes sense, although I almost never bother to fill that up
04:11:07 <jophish_> perhaps I should write a linter for it
04:11:16 <jophish_> Does anyone still use tarballs!
04:11:40 <mniip> so like
04:11:56 <mniip> we could say (s -> a, s -> b -> t)
04:12:06 <mniip> but it starts making more sense if we say s -> (a, b -> t)
04:12:12 <mniip> and for a traversal we uhh
04:12:21 <mniip> s -> ([a], [b] -> t)...kinda
04:13:25 <bennofs> MasseR: a good way to get a better understanding of lenses is to implement a little bit of lenses yourself. start with type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t and then figure out how to a) write lenses like _fst :: Lens' (a,x) (b,x) a b and b) write the operations for thoses lenses, view and over/set
04:13:32 <mniip> hmm
04:13:39 <mniip> :t \view set f = fmap . set <*> f . view
04:13:40 <lambdabot> parse error on input ‘=’
04:13:44 <mniip> :t \view set f -> fmap . set <*> f . view
04:13:45 <MasseR> bennofs: that's actually what I probably need
04:13:45 <lambdabot> Functor f => (a -> b1) -> (a -> a1 -> b) -> (b1 -> f a1) -> a -> f b
04:14:04 <jophish_> MasseR: there's a really good talk by SPJ on lenses. I'll try and find it
04:14:26 <MasseR> jophish_: thanks
04:14:26 <jophish_> MasseR: https://www.youtube.com/watch?v=2IZQx7WNOMs This one I think
04:14:35 <mniip> oh oh oh
04:15:04 <mniip> data D t a b = R t | P a (b -> D t a b)
04:15:17 * mniip . o O ( is this a free? )
04:15:28 <mniip> so then, a traversal is s -> D t a b
04:15:33 <bennofs> mniip: the thing you're looking there for Traversal is a weird type. I think it data X a b t = End b | Cont a b (b -> t)
04:15:49 <bennofs> correction: Cont a (b -> t)
04:15:57 <mniip> b -> t?
04:16:02 <mniip> not b -> X a b t?
04:16:20 <bennofs> mniip: ugh, I meant Cont a (X a b (b -> t)) :)
04:16:26 <MasseR> Where's the Const declared?
04:16:34 <mniip> huh
04:16:35 <bennofs> MasseR: Control.Applicative
04:16:45 <bennofs> mniip: it's a fun type
04:16:48 <mniip> bennofs, how about
04:17:13 <mniip> data X t a b = End t | Hole a (b -> X t a b)
04:17:33 <bennofs> mniip: how do you write toList for that to get all the a's ?
04:17:34 <mniip> oh yes, we could totally distribute the (b ->)
04:17:44 <mniip> data X t a b = End t | Hole a (X (b -> t) a b)
04:17:53 <bennofs> that's what I wanted to say :)
04:17:59 <mniip> :O
04:18:02 <bennofs> mniip: the type is in lens as a Bazaar
04:18:10 <bennofs> mniip: with a different representation
04:18:30 <mniip> lemme guess
04:18:31 <mniip> cps?
04:18:38 <bennofs> mniip: partially applied traversal :)
04:18:43 <bennofs> :t Bazaar
04:18:44 <lambdabot> (forall (f :: * -> *). Applicative f => p a (f b) -> f t) -> Bazaar p a b t
04:19:05 <mniip> generalized profunctor?
04:19:49 <bennofs> mniip: yes also generalized. simplified, it would be something like forall f. Applicative f => (a -> f b) -> f t, so it's just the result of applying a traversal to the "s" (which is of course expected)
04:20:27 <bennofs> mniip: btw, that thing has an Applicative instance. Trying to write that though is quite a challenge :p
04:20:32 <mniip> :t Bazaar (`traverse` Just "whatever")
04:20:34 <lambdabot> Bazaar (->) [Char] b (Maybe b)
04:20:57 <mniip> bennofs, how so
04:21:25 <mniip> Compose (Reader (p a (f b))) f
04:22:08 <bennofs> mniip: oh right, the Applicative instance in t is not the complicated one
04:22:22 <mniip> is it applicative in a? >_>
04:22:28 <bennofs> mniip: iirc yes
04:22:32 <mniip> oh dear
04:22:40 <bennofs> mniip: though don't ask me for the instance, look in lens if you wish or try yourself
04:26:47 <mniip> hmm
04:27:07 <mniip> there are no kindclasses are there
04:27:27 <mniip> such that you can write polykinded types that aren't uniformly defined
04:28:12 <bennofs> mniip: kindclasses? you mean like class Kind (k :: BOX) in pre-GHC-8?
04:28:49 <mniip> I have an interesting idea in mind
04:29:13 <mniip> a kind-polymorphic Show
04:29:41 <bennofs> How would that work? Why? What should it do?
04:30:15 <mniip> have you seen Show1
04:30:54 <mniip> class Show1 f where Show a => show1 :: f a -> String
04:31:19 <bennofs> ah yes, the hack because you can't have (forall a. Show (f a)) =>
04:31:23 <MasseR> Eh, 
04:31:31 <MasseR> @type getConst . traverse Const
04:31:32 <lambdabot> (Traversable t, Monoid c) => t c -> c
04:31:39 <MasseR> Where does the Monoid constraint come from?
04:31:44 <MasseR> None of the primitives have it
04:31:46 <bennofs> MasseR: Const's Applicative instance
04:32:06 <bennofs> MasseR: data Const r a = Const r. What do you do with the r's in Const r1 <*> Const r2 ?
04:32:16 <bennofs> MasseR: and where do you get the r from for pure? :)
04:32:38 <bennofs> that's where the Monoid comes in. It's instance Monoid r => Applicative (Const r)
04:33:07 <MasseR> Makes sense, I guess :)
04:33:52 <bennofs> MasseR: and because 'traverse' requires 'f' to be 'Applicative', and 'f' is 'Const r' in this case, 'r' has to be Monoid since 'Const r' is not 'Applicative' otherwise
04:34:18 <MasseR> I would probably need to have some paper to draw this chain :)
04:35:25 <mniip> Const is essentially...
04:35:30 <mniip> WriterT r Proxy
04:35:39 <mniip> :o
04:35:55 <mniip> no
04:36:03 <mniip> ProxyT (Writer r)
04:36:06 <opqdonut> Writer r ()
04:36:08 <mniip> hmm that's meaningless
04:36:08 <opqdonut> right?
04:36:26 <mniip> opqdonut, that's the wrong kind
04:36:34 <opqdonut> yeah you're right
04:36:52 <mniip> @unmtl WriterT r Proxy
04:36:52 <lambdabot> Plugin `unmtl' failed with: `WriterT r Proxy' is not applied to enough arguments, giving `/\A. Proxy (A, r)'
04:36:58 <mniip> @unmtl WriterT r Proxy a
04:36:58 <lambdabot> Proxy (a, r)
04:37:01 <mniip> yeah no
04:37:11 <mniip> not that
04:37:13 <MasseR> Ah nevermind, :info Applicative just told me the const instance :)
04:37:18 <opqdonut> @unmtl WriterT r Identity ()
04:37:18 <lambdabot> ((), r)
04:37:21 <opqdonut> that's it
04:37:27 <mniip> still wrong kind
04:37:46 <opqdonut> yeah it doesn't ignore the a parameter
04:37:59 <opqdonut> but Const r a = WriterT r Identity () definitely
04:39:14 <mniip> hmm
04:39:18 <mniip> there is not a ProxyT
04:39:27 <mniip> there should be one
04:40:14 <bennofs> mniip: ugh why would you need that. kind of useless IMO
04:40:28 <mniip> newtype ProxyT m a = m ()
04:40:52 <bennofs> mniip: not a monad
04:41:14 <bennofs> mniip: and if it's not a monad, you might as well just use Compose Const :)
04:41:19 <mniip> hmm you're right
04:41:33 <mniip> it's kind-a useful :)
05:05:43 <mniip> wait
05:05:50 <mniip> Traversals are a monoid
05:06:25 <codedmart> What can I use to find out why my haskell web server I wrote slowly grows in memory?
05:18:23 <danza> codedmart, profiling? there is a well known library called Criterion, i think
05:19:56 <phadej> danza codedmart: criterion is for benchmarking, not profiling
05:20:09 <danza> oh, sorry! :)
05:20:34 <silver> https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html
05:21:04 <phadej> real world haskell chapter on profiling is still quite up to date
05:21:52 <codedmart> phadej: Thanks
05:25:21 <mniip> hmm
05:25:27 <mniip> that pulls in a monad constraint
05:25:34 <mniip> which defeats Const
05:45:11 <quicksilver> mniip: traversals aren't a monoid because a traversal which goes to the same place twice will break the rules
06:07:46 <jophish_> I have a function which returns a conduit source and conduit sink which both depend on the same ForeignPtr and can't use it both at the same time. Locking the resource for using it isn't a problem. The question is: Does Conduit have any machinery for resources shared between conduits?
06:08:28 * hackagebot wai-routes 0.9.7 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.7 (AnupamJain)
06:17:05 <Stan_> Has someone experience with the sdl2 package? I have installed it according to this guide without problems
06:17:07 <Stan_> https://www.reddit.com/r/haskellgamedev/comments/2i1784/how_to_install_sdl2_and_the_haskell_sdl2_bindings/
06:17:36 <Stan_> But when I try the example it tells me that it can't find the module `Graphics.UI.SDL`
06:19:57 <lieven> jophish_: ResourceT perhaps?
06:22:42 <geekosaur> Stan_, sdl2 2.x uses a top level moule hierarchy (SDL.* instead of Graphics.UI.SDL.*)
06:22:56 <geekosaur> http://hackage.haskell.org/package/sdl2
06:23:09 <geekosaur> compare http://hackage.haskell.org/package/sdl2-1.3.1
06:24:25 <jophish_> lieven: I wonder if Conduit distributes over ResourceT, because the generator function type would be something like:: MonadIO m => MonadResource m => Config -> m (Source m ByteString, Sink m ByteString)
06:24:54 <Schrostfutz> Hi, I'm currently following a haskell tutorial and I want to transform the expression "liftM (Number . read) $ many1 digit" into a version without liftM but with >>=. My idea was "many digit >>= (Number . read)" which does not compile. Do you have a hint to what I am doing wrong?
06:25:25 <lieven> jophish_: pretty sure it does because it was written for conduit
06:25:51 <lieven> jophish_: https://www.schoolofhaskell.com/user/snoyberg/library-documentation/resourcet#interleaving-with-conduit
06:26:22 <jophish_> Ah, that looks ideal, thanks lieven!
06:29:43 <ClaudiusMaximus> Schrostfutz: what does the error say?
06:30:21 <Schrostfutz> ClaudiusMaximus: http://sprunge.us/ALVR
06:31:09 <Stan_> geekosaur: Ahh, now it works. Thank you very much =)
06:31:30 <ClaudiusMaximus> Schrostfutz: so it can't match  LispVal  with a context expecting  m LispVal  for some m
06:32:59 <Schrostfutz> ClaudiusMaximus: if I understand correctly that means that the function does not work with monads which is what originaly the liftM function was used for, does it?
06:33:28 <ClaudiusMaximus> Schrostfutz: yeah, but luckily there is a  Monad m => a -> m a
06:34:52 <ClaudiusMaximus> Schrostfutz: so you can add that to your  Number . read  pipeline
06:36:19 <Schrostfutz> ClaudiusMaximus: alright, I'll try that
06:36:23 <Schrostfutz> Thanks
06:36:35 <merijn> Obligatory: Avoid read and use readMaybe
06:37:12 <Schrostfutz> merijn: the parser will only match digits so I think it's safe
06:47:19 <Schrostfutz> ClaudiusMaximus: I still cannot work it out. I tried many1 digit >>= (Number . read . {Monad,Parser}). Monad is not found and Parser is not a constructor. Sorry if I am being stupid here....
06:47:41 <ClaudiusMaximus> :t return
06:47:42 <lambdabot> Monad m => a -> m a
06:49:15 * hackagebot microlens-th 0.3.0.1 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.3.0.1 (Artyom)
06:50:00 <Schrostfutz> ClaudiusMaximus: Thanks!, I think I understand what happens.
07:08:26 <kqr> i feel like I've asked before but is there a neat way of writing [x | p] without MonadComprehensions?
07:08:28 <kqr> ah yes
07:08:31 <kqr> guard p <$ x?
07:09:31 <puregreen> I think it's guard p $> x
07:09:56 <opqdonut> the arrow points towards the value you keep
07:10:46 <kqr> oh
07:10:58 <kqr> i remembered it as "the arrow points where the value is going"
07:11:00 <kqr> haha
07:11:06 <puregreen> guard p $> x == guard p >> return x
07:11:14 <puregreen> >>, *>, $>
07:11:19 <kqr> oohhh
07:11:21 <kqr> neat
07:11:24 <kqr> is there an <$?
07:11:26 <puregreen> yep
07:11:27 <kqr> so x <$ guard p?
07:11:30 <puregreen> yep
07:11:53 <kqr> i know I've read and understood how that works, but I still don't have intuition for it
07:12:11 <kqr> I just think it's awesome that what in other languages pretty much always gets syntactic tricks is so easy to create in haskell without 'em
07:13:09 <puregreen> a different name for “guard” could be “failIf”
07:13:19 <puregreen> no, failIfNot
07:13:45 <kqr> or "when" if it were not used for other things
07:13:51 <kqr> I think ruby does something like that
07:19:59 <quicksilver> it's true that $> is the same as >> return
07:20:11 <quicksilver> but it's more fundamently than that because it only needs Functor
07:24:05 <quicksilver> guard p $> x = fmap (const x) (guard p)
07:28:30 <nitrix> > 3 <$ Just 5
07:28:32 <lambdabot>  Just 3
07:30:24 <nitrix> :t ($>)
07:30:26 <lambdabot>     Not in scope: ‘$>’
07:30:27 <lambdabot>     Perhaps you meant one of these:
07:30:27 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
07:30:34 <nitrix> Why is $> not in scope?
07:32:29 <geekosaur> because (<$) is re-exported by Prelude but ($>) isn't
07:32:31 <nitrix> It's in base and not prelude as a flipped version of $> gotcha.
07:33:29 <deni> quick question....if I use TH to derive my JSON instance classes i have an option for modifying the fieldName to let's say field_name so that I can have camel case in haskell but snail case in json...
07:33:38 <deni> does Generic also offer something like that?
07:34:00 <deni> from what I've seen it's only "instnace ToJSON MyType" but without any options for modifiers
07:34:58 <deni> I mean for the complext types I'm going to write the instances by hand but for the simpler ones it would be great to be able to use generics and not pull in TH for this.
07:35:44 <deni> (also it's not actually camelCase snail_case conversions it's camelCase CamelCase conversion because the api has the first letter capitalized for it's fields)
07:36:04 <icicled> deni: Generic offers that too I'm pretty sure
07:36:28 <deni> icicled: I seem to recall reading about this (or hearing about) at one point.... but I'm not sure any more
07:38:09 <icicled> the docs on hackage aren't there >_>
07:41:08 <icicled> deni: its a new package it seems
07:41:13 <icicled> generic-aeson
07:41:34 <deni> icicled: yeah I'm looking at that right now....but can't make much sense out of it yet
07:42:00 <puregreen> deni: see https://artyom.me/aeson#generics-customising-field-names for an example of using modifiers with generics
07:42:28 <deni> puregreen: bingo! that's exactly what I need....thanks o much!
07:42:50 <deni> and strange I couldn't come up with the word "modifier" would have made this easier to google for
07:42:52 <deni> :D
07:44:06 <icicled> what's going on with the hackage docs for aeson?
07:44:23 <puregreen> icicled: a new version was released recently
07:44:31 <icicled> even in the older versions the links to the generics module is broken
07:44:38 <glguy_> Using TH is nice for avoiding the overhead from the generics generated code, particularly on larger types
07:44:38 <puregreen> and Hackage has been having problems with building docs quickly— ah, so it's not that
07:45:33 <puregreen> icicled: I'm looking at 0.9.0.1 and the link to Data.Aeson.Generic (which is not what anyone wants, by the way) is not broken: http://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson-Generic.html
07:48:14 <deni> glguy_: I was always under the impression that TH has much more overhead than Generics. And there's definitely more people hating TH than Generics from what I can tell.
07:48:27 <quicksilver> TH has zero overhead in the generated code.
07:48:33 <quicksilver> I mean it generates the code you tell it to.
07:48:40 <quicksilver> if you generate code with overhead that was your fault :P
07:49:02 <deni> quicksilver: glguy_ why is TH criticized so much then?
07:49:09 <deni> perhaps overhead in some different sense
07:49:18 <quicksilver> it's ugly and hard to debug?
07:49:20 <puregreen> TH is less convenient for the programmer
07:49:27 <quicksilver> and you have to work with poorly documented types
07:49:31 <quicksilver> and weird GHC quirks?
07:49:39 <crough> TH is used in places it doesn't need to be a lot, too.
07:50:31 <puregreen> simplest example of a quirk (that actually isn't a quirk per se but anyway): if you try to define your own defaultOptions for instances (“myDefaultOptions”), GHC won't let you and you'll have to move it into a separate module
07:51:37 <deni> puregreen: yeah I have that one :D
07:51:55 <deni> forgot why it's the only thing in that module though  :D
07:52:05 <puregreen> TH-generating code is also really annoying to maintain, to the point where Bryan refuses to do anything with TH-related issues
07:52:27 <puregreen> (at least ne accepts pull requests, tho)
07:53:12 <deni> good to know....so I was when I said that Generics is a more accepted solution? (At least for small things where bringing in TH is really not necessary)
07:53:15 <deni> right?
07:53:26 <jackhill> heh TASK1382950 "In the future, please send tickets to the general Identity Management-OIT so the person on call for the week will process them. There's always a danger that if you directly assign them to one us, that we would be out of the office or not watching the ticket queue. "
07:53:29 <deni> *so I was right when I said...
07:53:34 <jackhill> oops
07:53:45 <puregreen> yeah, use Generics until you badly need speed
07:54:01 <deni> puregreen: okay I can work with that rule of thumb.
07:54:02 <deni> tnx
07:54:13 <puregreen> I think TH is about 1.5–2 times faster, but not sure
07:54:27 <deni> oops seems deriveJSON isn't the only thing I'm using from TH I have makeClassy as well....which I really don't need as well
07:54:56 <deni> puregreen: faster at code generation during compile time or the code that it generates is 2x times faster in runtime?
07:55:01 <puregreen> the latter
07:55:07 <puregreen> Generics doesn't do any code generation
07:55:56 <deni> (yeah I don't really understand the difference between the 2 tbh....but Generics seemed less magic to use than TH)
07:57:22 <quicksilver> well using Generics involves asking GHC to generates one generic set of combinators
07:57:25 <quicksilver> no pun intended
07:57:31 <quicksilver> and then you use those to achieve your ends.
07:57:46 <quicksilver> they may or may not be the most efficient way to do what you're doing
07:57:56 <quicksilver> TH lets you generate precisely the code you want, if you have the patience.
07:58:06 <puregreen> okay, right, I forgot about deriving Generic technically generating code
08:03:02 <glguy> deni: The overhead of TH is that it has to load libraries at compile time. The overhead of Generics is that GHC's optimizer often gives up before finishing the elimination of generics
08:03:22 <glguy> and then in other situations people write code that won't allow the generics to optimize away and creates runtime overhead
08:06:59 <c_wraith> puregreen: all automatic deriving (except GND, I guess) technically generates code.  (GND actually just says to use the other type's instance dictionary directly, instead of creating a new one)
08:10:30 <cmotoche> Hello everybody. I need some help with a project. I'm using stack and when I try to build the application it gets stuck building the dependency "haskell-src-exts-1.16.0.1". It seems it gets out of memory or something like that. What could I do?
08:10:55 <glguy> Add memory? How much do you have?
08:11:02 <bergmark> cmotoche: haskell-src-exts takes a long time to compile, how long did you wait?
08:11:36 * hackagebot git-annex 6.20160211 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160211 (JoeyHess)
08:12:12 <cmotoche> Around 2 hours.
08:13:05 <bergmark> that's too long :-)
08:14:12 <cmotoche> Yeah. So, should I still waiting or what else should I do?
08:14:34 <glguy> cmotoche: It's possible that you actually don't have enough memory to do it, how much do you have?
08:14:47 <sm> always worth a try: 1. kill it and try again, 2. enable verbose logging
08:16:19 <glguy> and which version of GHC?
08:16:27 <bergmark> hse could do with some .hs-boots, would help
08:17:05 <bezirg> am I correct to believe that haskell-src-exts, template-haskell and ghc-api all provide their own Haskell-AST? Why we cannot unify all these?
08:18:19 <badmash> hoogle by default only searches haskell platform.  how can i get hoogle to search all installed packages in my machine?
08:19:35 <badmash> appreciate any help
08:20:08 <geekosaur> bezirg, long story, suggest trawling ghc-devs mailing list archives for gory details
08:20:50 <bezirg> geekosaur: ok, thanks for confirming this. I thought this was my misconception
08:21:10 <geekosaur> short version is ghc *really* needs an abstraction layer, but then that becomes one more thing to keep in sync. (ghc changes its internals regularly and sometimes wildly)
08:21:43 <cmotoche> Well, I'm using GHC-7.10.3 and I have 512 RAM.
08:21:55 <bezirg> geekosaur: by abstraction layer u mean something different than ghc-api?
08:22:03 <glguy> cmotoche: 512 won't do, you'll need just over 1.2GB to dedicate to GHC
08:22:20 <geekosaur> which is one of the reasons pople avoid TH --- it tends to mean TH-using packages need to be rejiggered with new GHC releases because the internals changed enough to break them
08:22:27 <glguy> I'm rebuilding it now and watching my memory usage
08:22:34 <glguy> I've seen it hitting 1.2 GB so far
08:22:49 <geekosaur> ghc-api *ought* to be an abstraction  layer. it's not; it's the direct guts of ghc
08:23:33 <badmash> geekosaur: so there is not much abstraction over ghc then exposed to the users?
08:23:37 <geekosaur> exactly
08:23:52 <glguy> cmotoche: Perhaps you're using Linux and your distribution provides precompiled Haskell library binaries?
08:23:53 <geekosaur> and various attempts at abstraction layers keep getting broken by ghc internals changes
08:24:01 <cmotoche> 1.2 GB? I think that's a lot.
08:24:13 <cmotoche> Well, I don't know.
08:24:22 <glguy> geekosaur: On the flip side, the Generics interface changes too :)
08:24:35 <cmotoche> I'll research information about that.
08:24:37 <cmotoche> Thanks.
08:24:49 <geekosaur> cmotoche, ghc stresses linkers considerably. gold handles it a bit better, binutils just explodes memory-wise
08:24:51 <glguy> cmotoche: Yeah, it's definitely a lot
08:24:55 <badmash> geekosaur: but the argument in favor of haskell i often hear is that change is not bad -- haskell is so easy to refactor, so even if you get hit by changes, it is not that hard.
08:25:07 <geekosaur> and recent ghc also uses a fair amount of RAM for typechecking
08:25:23 <bezirg> geekosaur: it is a good argument you make.  I hope there is gonna be such abstraction layer; afterall we haskell ppl are all about abstractions!
08:25:27 <glguy> badmash: The changing interfaces are hard on people who want to support multiple versions
08:25:52 <geekosaur> badmash, that's true up to a point. the key difference is whether you're changing your project, or reacting to sometimes poorly documented changes in a dependency
08:25:59 <geekosaur> *nothing* can save you from the latter
08:26:06 <bollu> is there a natural way to memoise comonads
08:26:06 <bollu> ?
08:26:15 <badmash> i see
08:26:46 <badmash> geekosaur: as far as GHC people are concerned, GHC is just an experiment 
08:26:57 <geekosaur> it's a research project, yes
08:27:20 <deni> quicksilver: puregreen glguy tnx for the explanation. I just use for FromJSON ToJSON so nothing to complex
08:27:35 <badmash> so i suppose you can expect a lot of churn, but i suppose an abstraction layer that insulates would be good
08:27:37 <jasonkuhrt> Hi, can any experienced Haskellers here tell me what level of excitement there is for GHC 8 and roughly what the impact on day-to-day coding Haskell will be?
08:27:46 <geekosaur> they are aware that this conflicts with production usage. they also don't have anything like the resouces (mainly time and people who understand ghc internals) to maintain both stable and research branches
08:28:23 <jasonkuhrt> I'm curious because presumably a boatful of new features will be available to the Haskeller engineer soon but not many books cover it if at all (even Haskell First Principals etc.)
08:28:42 <geekosaur> it is a *regular* topic of discussion on ghc-devs, especially shortly before they start cutting a new release that they know will annoy a lot of people with the API breakages....
08:29:20 <lingxiao> hey doees anyone here know coq and care to answr a question at #coq?
08:29:22 <badmash> geekosaur: but the surprising thing is that many of the warts still live on despite the churn
08:29:24 <lingxiao> please?
08:29:40 <badmash> like partial functions
08:32:26 <badmash> does anyone here use hoogle much locally?  how do you get hoogle to search through all your locally installed packages?
08:36:07 <fresheyeball> so, I struggling with the concept of traversable 
08:36:19 <fresheyeball> can anyone help me understand what makes a type traversable?
08:36:51 <athan> fresheyeball: yo
08:36:56 <fresheyeball> I get applicative and foldable, but combining them to traversable 
08:36:59 <fresheyeball> I don't quite get it
08:37:04 <fresheyeball> athan: sup!
08:37:43 <athan> okey so applicative is like enriching values with immediate context, at least from what I understand
08:37:49 <athan> and I think you get this too
08:37:50 <Cale> hm
08:38:13 <athan> fresheyeball: traverse is just mapM, basically
08:38:24 <geekosaur> badmash, re churnvs. warts, there is still a massive amount of argument over whether the Prelude should be changed or not
08:38:25 <athan> we adjacently accumulate the effects
08:38:50 <athan> and kinda unfold the pure data together inside the effects
08:39:04 <athan> but it's not an unfold at all
08:39:06 <athan> it's weird
08:39:08 <athan> it's like relief
08:39:19 <fresheyeball> Applicative f => (a -> f b) -> t a -> f (t b)
08:39:22 <dramforever> :t mapM -- that's basically what traverse is
08:39:23 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
08:39:25 <fresheyeball> but why must it be applicative?
08:39:26 * athan gets his artists' hat and color pallate
08:39:31 <Cale> Well, you can probably say that a bit more clearly as just: "run all the computations contained in the structure and build a structure having their results in corresponding positions"
08:39:48 <dramforever> fresheyeball: you can try to write/read a few instances
08:39:52 <Cale> I like looking at Traversable via sequence/sequenceA
08:39:55 <Cale> :t sequence
08:39:56 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:39:59 <Cale> :t sequenceA
08:40:01 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
08:40:02 <athan> Cale: But does it _need_ to build it back up?
08:40:07 <athan> in that unfolding is essential?
08:40:08 <Cale> yes?
08:40:16 <fresheyeball> dramforever:  thats what I would like to do for learning
08:40:18 <athan> okay :D
08:40:20 <Cale> Uh, I don't know what the unfolding is about
08:40:33 <Cale> You can build the result however you want
08:40:58 <fresheyeball> does anyone have an example of a type that is foldable but not traversable?
08:41:03 <Cale> Set
08:41:07 <fresheyeball> or and instance where the applicative restriction comes into play?
08:41:11 <dramforever> http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html
08:41:12 <athan> fresheyeball: I think Set
08:41:18 <fresheyeball> why not Set?
08:41:23 <Cale> Set isn't Traversable because it's not even a Functor
08:41:24 <athan> fresheyeball: Ordering :)
08:41:33 <dramforever> click on the "Source" link for the code
08:41:40 <badmash`> question once again on hoogle -- how do you get hoogle to search all your locally installed packages?
08:41:45 <Cale> All the nontrivial operations on Set require Ord, but the type of fmap doesn't demand an Ord instance
08:41:46 <dramforever> and you'll get the pattern, perhaps
08:42:05 <EvanR> is it possible to write a function splitTypes :: (us ++ vs) -> (us, vs), seems not as such because it would not know at runtime how far to go
08:42:11 <athan> traverseMonotone :v
08:42:29 <fresheyeball> :t traverseMonotone
08:42:30 <lambdabot> Not in scope: ‘traverseMonotone’
08:42:35 <fresheyeball> :t traverse
08:42:37 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:42:57 <athan> :t sequenceA
08:42:58 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
08:43:03 <athan> fresheyeball: It's like foldMap vs. fold
08:43:12 <fresheyeball> oh! 
08:43:14 <fresheyeball> that helped
08:43:19 <dramforever> @let data X a = Two a a | Three a a a
08:43:22 <lambdabot>  Defined.
08:44:40 <dramforever> @let deriving instance Functor X -- (it's a GHC extension)
08:44:43 <lambdabot>  Defined.
08:44:48 <fresheyeball> athan: you have any success last night?
08:45:50 <dramforever> @let instance Foldable X where foldMap f (Two a b) = f a <> f b; foldMap f (Three a b c) = f a <> f b <> f c
08:45:52 <lambdabot>  Defined.
08:47:33 <dramforever> @let instance Traversable X where traverse f (Two a b) = Two <$> f a <*> f b; traverse f (Three a b c) = Three <$> f a <*> f b <*> f c
08:47:35 <lambdabot>  Defined.
08:47:37 <EvanR> k i found a cafe thread about it ... https://mail.haskell.org/pipermail/haskell-cafe/2014-June/114584.html
08:48:36 <dramforever> fresheyeball: The pattern is, you apply the supplied function to each of the "elements" of your data type (possibly through recursion, which is not shown here)
08:48:53 <dramforever> Then, you use Applicative to combine the results
08:49:19 <dramforever> Back into... Your data type! Only wrapped in an applicative
08:50:21 <Cale> "Wrapped in" is a funny way to put it though
08:51:41 <dramforever> Cale: Yeah I find the "container" analogy very helpful
08:51:44 <Cale> It's more that traverse/sequence/etc. construct computations, and those computations will build up a data structure (of your type) as they run, producing it as their result
08:53:01 <Cale> For example,  sequence (Two getLine getLine)  will be the IO action which gets two lines of text from the user, and if, for example, they are "hello" and "world", will produce Two "hello" "world" as its result.
08:53:07 <dominik> hey there, I'm just getting my feet wet with parsec again, trying to build a regexp parser: http://lpaste.net/152226
08:53:18 <dramforever> The supplied function will only build elements, it's traverse's responsibility to build up the structure so that it has the same shape as the original one, only with elements replaced
08:53:39 <dominik> anyone knows, why it's not even parsing regexp's like "a|b|c" ?
08:53:54 <dramforever> like... a powered-up fmap,
08:53:55 <dominik> somewhere, I must have made a mistake in the grammar, but I can't seem to find it.
08:56:02 <dramforever> Cale: I was enlightened when it came to me that ((->) r) (the reader thing) is a container of "r" elements, where the "r" roughly means the "cardinality" of r
08:56:38 * hackagebot propellor 2.15.4 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.15.4 (JoeyHess)
08:56:50 <Cale> dramforever: Yeah, the container analogy works somewhat, but it's usually less natural in terms of how we actually use monads and applicatives in Haskell than thinking about computations.
08:57:22 <Cale> (I *did* write "Monads as Containers" after all ;)
08:57:27 <ironChicken> anyone know of any rasterisation libraries on hackage? i can see there are plenty of drawing libraries, but what i actually want to do is something like [((a,a),(a,a))] -> [[b]], i.e. convert a list of pairs of points which describe the lines of a polygon into a list of lists of binary "piexls"
08:58:20 <Cale> There's http://hackage.haskell.org/package/Rasterific
08:58:36 <EvanR> the "an value of IO is a box such that if you press the button, it stays pressed until possibly at some point a value pops out and the button resets, while having had arbitrary unseen effects" seems to be taking the "container" analogy a little far ;)
08:59:11 <EvanR> you could explain any phenomenon in the universe as such a container
08:59:16 <EvanR> but its not really containing much
08:59:23 <ironChicken> Cale: yes, i had a quick look but  i couldn't see that i could get the raw bitmap data
08:59:38 <dramforever> for precise work I prefer the category theoretical definitions (which are admittedly not well-understood by me)
09:00:26 <Cale> ironChicken: renderDrawing gives you a JuicyPixels Image, and you can apply imageData from that to get a Vector of the pixels
09:00:35 <Cale> s/from/to/
09:00:51 <dramforever> the "lax monoidal functor" and "category of endofunctors" things make *some* sense if you squint a little harder :)
09:01:19 <ironChicken> Cale: ok, thanks. i have a closer look
09:01:44 <dominik> nevermind, I forgot some try's... on the left hand sides of <|>
09:01:51 * hackagebot pooled-io 0.0.2.1 - Run jobs on a limited number of threads and support data dependencies  https://hackage.haskell.org/package/pooled-io-0.0.2.1 (HenningThielemann)
09:01:53 <dramforever> EvanR: that sounds like a perfectly reasonable analogy :)
09:02:34 <EvanR> dramforever: its not really a container though
09:02:59 <EvanR> whatever happens, doesnt stay inside
09:03:24 <dramforever> Sounds like a side-effectful container
09:03:35 <EvanR> unless all the other monads
09:03:37 <EvanR> unlike*
09:05:53 <dramforever> What about this: IO is an abstract and primitive Monad, where the value contained cannot be retrieved (read: there's no unsafePerformIO in 2010), but several library functions and the FFI permits creation of such containers
09:06:06 <dramforever> *Haskell2010
09:06:27 <dramforever> oops that was a serious typo :P
09:06:36 <dolio> What about not trying to shoehorn everything into some "containers" analogy?
09:06:57 <EvanR> you cant necessarily get a value back from any monad
09:07:03 <glguy> Analogies are like a container for ...
09:07:45 <EvanR> dramforever: instead of contains it makes more sense to think of them as programs
09:07:49 <EvanR> containers* 
09:08:14 <EvanR> you can combine two IO program with >>= in a certain way
09:08:23 <EvanR> it ostensibly follows the monad laws
09:08:28 <dramforever> dolio: otherwise it would be like this: I had a problem, and I used Haskell. Now I have a problomorphism in the category of endowatnesses
09:09:51 <dramforever> hmm, problomorphism, I like that
09:16:51 * hackagebot gnuplot 0.5.4.1 - 2D and 3D plots using gnuplot  https://hackage.haskell.org/package/gnuplot-0.5.4.1 (HenningThielemann)
09:26:51 * hackagebot ViennaRNAParser 1.2.8 - Libary for parsing ViennaRNA package output  https://hackage.haskell.org/package/ViennaRNAParser-1.2.8 (FlorianEggenhofer)
09:31:52 * hackagebot docker 0.2.0.4 - Haskell wrapper for Docker Remote API  https://hackage.haskell.org/package/docker-0.2.0.4 (denibertovic)
10:08:00 <shapr> I've started a functional programming meetup in Atlanta. If anyone wants to start showing up, it's on meetup.com 
10:10:33 <EvanR> nice
10:34:30 <deni> hmmm how to I get stack build to print generated TH code? stack build --ghc-options -ddump-splices doesn't seem to work
10:49:30 <mniip> I made a seemingly cool thing I think http://lpaste.net/5165756749734477824
10:49:59 <sphinxo> Hi, i'm wondering how to best represent assembly instructions
10:50:01 <mniip> kinda like a lens decomposes into view+set, a traversal decomposes into a multitext
10:50:41 <sphinxo> It seems simple at first but then you end up with like lots of Eithers and it seems like there should be a better way to do it?
10:51:45 <puregreen> mniip: isn't this something similar to Bazaar? 
10:51:47 <ppineda> hello... I got this finalLoadHook called while running when i was trying to run snap with stack
10:51:50 <mniip> kinda
10:51:50 <puregreen> “Where a Context a b t holds an a and a function from b to t, a Bazaar a b t holds N as and a function from N bs to t, (where N might be infinite).”
10:52:12 <ppineda> what should I do?
10:52:22 <mniip> yeah, it is a bazaar but with less type-foo I think
10:56:48 <shachaf> mniip: I'd say more, not less.
10:56:55 <shachaf> It's a non-regular type!
10:57:07 <shachaf> Anyway this type exists somewhere.
10:57:25 <shachaf> It's a variant of Twan's FunList.
10:57:28 <shachaf> http://twanvl.nl/blog/haskell/non-regular1
11:00:35 <mniip> shachaf, but
11:01:14 <mniip> traversal (\(x, y, z) -> Hole x $ Hole y $ End \x' y' -> (x', y', z))
11:01:20 <mniip> simple as that!
11:01:55 <shachaf> The trouble with the FunList representation is that it flattens a tree into a list.
11:02:45 <shachaf> Anyway, that doesn't look simpler than (\f (x,y,z) -> (\x' y' -> (x',y',z)) <$> f x <*> f y).
11:04:07 <osa1> does anyone know if distfix and mixfix are the same thing?
11:06:12 <gfixler2> does non-regular just mean that atype changes in the recursion?
11:06:43 <osa1> gfixler2: what is the context?
11:06:58 <gfixler2> osa1: what shachaf just said
11:07:04 <gfixler2> about what mniip just said
11:07:18 <osa1> ops OK, I haven't followed that
11:07:25 <gfixler2> http://twanvl.nl/blog/haskell/non-regular1
11:07:43 <gfixler2> osa1: "but remember that the data type is non-regular"
11:08:05 <mniip> 1455216483 [21:48:03] <mniip> I made a seemingly cool thing I think http://lpaste.net/5165756749734477824
11:08:40 <conal> gfixler2: yes. and using a non-regular data type generally requires polymorphic recursion.
11:08:54 <conal> gfixler2: non-regular (in this context) is also called "nested"
11:09:05 <gfixler2> conal: right, thanks
11:09:12 <gfixler2> ah, nested I've heard
11:09:49 <gfixler2> although, I believe it's often allowed for the types *not* changing in the recursion
11:12:40 <mniip> shachaf, hmm you're right
11:13:05 <mniip> wait
11:13:07 <mniip> waaaaaaaaait
11:13:21 <mniip> traverse :: Traversal (f a) (f b) a b
11:13:23 <mniip> amirite?
11:13:39 <mniip> fsvo Traversable f
11:14:35 <mniip> :t traverse :: Traversable f => Traversal (f a) (f b) a b
11:14:37 <lambdabot> (Applicative f1, Traversable f) => (a -> f1 b) -> f a -> f1 (f b)
11:14:56 <mniip> woah
11:14:57 <mniip> magic
11:15:01 <mniip> everything makes sense now
11:15:17 <shachaf> Yes.
11:15:22 <mniip> Traversals are like Traverstables
11:15:28 <shachaf> I don't know how people are expected to understand lens without knowing that.
11:15:29 <mniip> Traversables even
11:15:49 --- mode: ChanServ set +o mauke
11:15:50 --- mode: mauke set -b $a:Mitzelflick
11:17:50 --- mode: mauke set -o mauke
11:18:04 <mniip> shachaf, believe it or not but most people don't have a clue what you mean when you say
11:18:13 <mniip> look lens is
11:19:02 <mniip> :t traverse . traverse . traverse . traverse
11:19:04 <mniip> I'm lagging...
11:19:04 <lambdabot> (Applicative f, Traversable t, Traversable t1, Traversable t2, Traversable t3) => (a -> f b) -> t (t1 (t2 (t3 a))) -> f (t (t1 (t2 (t3 b))))
11:20:20 <shachaf> Well, that's not how I introduce lens.
11:41:11 <OverCoder> Why isn't there a startswith function for strings?
11:41:12 <OverCoder> How silly
11:41:30 <ahihi> > "foo" `isPrefixOf` "foobar"
11:41:30 <puregreen> :t isPrefixOf
11:41:33 <lambdabot> Eq a => [a] -> [a] -> Bool
11:41:33 <lambdabot>  True
11:41:52 <OverCoder> yikes
11:41:56 * OverCoder shrinks
11:42:14 <OverCoder> I was making my own function lol
11:42:51 <kadoban> Hehe. Data.List is a great module, lots of stuff in there. Anything that's not in there is probably in the 'split' package.
11:43:18 <OverCoder> hmm
11:44:04 <Welkin> make a pizza by starting with a goat, some wheat plants and some tomato plants
11:44:32 <Welkin> I suppose you need a chicken too, for the eggs
11:44:36 <kadoban> A male goat
11:44:50 <Welkin> and collect some seawater for the salt
11:45:09 <Cale> OverCoder: Of course, implementing a lot of the list library is a great exercise toward getting comfortable with Haskell.
11:45:36 <OverCoder> Yeah I see
11:45:39 <OverCoder> xnil, hi :P
11:46:22 <johnw> Cale: hello! :)
11:46:32 <Cale> johnw: hello!
11:46:43 <xnil> hi, OverCoder 
11:47:09 <johnw> Cale: so nice to have a face to associate with the name now :)
11:47:28 <Cale> haha
11:47:55 <Cale> I'm just used to not having faces for anyone by this point, it's unusual :D
11:48:20 <Welkin> Cale: you have never shared your face until now?
11:48:25 <dolio> johnw: Were you in New York?
11:48:29 <johnw> yes
11:48:32 <johnw> I'm in Boston today still
11:48:34 <dolio> Huh.
11:48:40 <Cale> dolio: Yeah, we both stayed at Ryan's place
11:48:41 <Welkin> bahstun?
11:49:30 <Cale> Welkin: Kinda sorta -- there were a few Haskellers who had seen me, but those guys are sort of a reclusive part of the community to begin with.
11:49:38 <EvanR> er, there is '[] and ': but what about '++
11:49:56 <Cale> Welkin: (some folks at McMaster University)
11:49:57 <johnw> EvanR: that might be in 'singletons'
11:50:02 <johnw> '++ is not a constructor, the other two are
11:50:20 <Welkin> lol
11:50:25 <Welkin> my photo is all over the internet
11:50:30 <Welkin> on all my profiles
11:51:12 <Cale> I usually use a little magnetic sculpture as my profile pic. I don't intentionally hide my face, I just think the magnets are nicer :P
11:52:02 <ReinH> You could imagine a list-like data type where :++:  is a constructor. It's actually even useful for some things.
11:52:05 <Cale> http://i.imgur.com/oFnpdtd.jpg Here's a picture of me in my new hat :D
11:52:20 <ReinH> Cale: epic
11:53:37 <eacameron> Double epic
11:53:47 <eacameron> Epic = Electronic Picture
11:54:06 <EvanR> johnw: i see... 
11:54:39 <EvanR> ReinH: is :++: defined somewhere?
11:54:49 <EvanR> i see :++ as a type family in singletons
11:54:57 <ReinH> No. But it could be.
11:55:57 <MustaphaAbiola> Hi. I want to study the complete grammar of GHC Haskell - including some of extensions; I want this to be in BNF syntax. I know and have found some circa its 2010 records, in BNF-like syntax, but not BNF.
11:56:07 <EvanR> with data kinds and type operators, all you get are promoted versions of the built in list? no support?
11:56:18 <MustaphaAbiola> I found this - https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y.pp - but it's just a code segment, not actual BNF grammar.
11:56:31 <MustaphaAbiola> Looking for something like this - http://askra.de/software/ocaml-doc/3.12/full-grammar.html#anchor01
11:58:01 <ReinH> EvanR: No, I just mean a value-level list-like type could have a :++: constructor.
11:58:09 <EvanR> oh
11:58:37 <dolio> Except most people would call it a tree. :)
11:58:39 <ReinH> Well, a type with list-like values, not something promoted.
11:59:08 <ReinH> dolio: I've seen something like Data CList a = Nil | Cons a (CList a) | CList a :++: CList a before.
11:59:30 <EvanR> yeah delaying the interpretation of ++
12:07:33 <OverCoder> data A = a :: String, b :: string, c :: String
12:07:46 <OverCoder> Say I have an A, how do I access a, or b, or c without pattern matching?
12:07:47 <EvanR> uhg. this error makes no sense. http://lpaste.net/152237 in what sense is :++: execting kind * and not [*]
12:09:00 <EvanR> OverCoder: in data A = A { a :: String, b :: String, c :: String} you can use fields a b and c to access the fields
12:09:44 <EvanR> a (A "x" "y" "z") == "x"
12:11:29 <hansili> > pl f xs = zip xs [1..]
12:11:31 <lambdabot>  <hint>:1:9: parse error on input ‘=’
12:12:55 <hansili> > pl \x -> zip x [1..]
12:12:57 <lambdabot>  <hint>:1:4: parse error on input ‘\’
12:13:36 <verement> @pl \x -> zip x [1..]
12:13:36 <lambdabot> flip zip [1..]
12:14:00 <hansili> thx verement :-)
12:14:01 <Mishac> Can someone explain to me this: Folds in general
12:14:02 <Mishac> The take-away message is that we can implement a fold for many (though not all) data types. The fold for T will take one (higher-order) argument for each of T’s constructors, encoding how to turn the values stored by that constructor into a value of the result type—assuming that any recursive occurrences of T have already been folded into a result.
12:14:02 <Mishac>  Many functions we might want to write on T will end up being expressible as simple folds.
12:14:11 <Mishac> ok nwm
12:14:14 <Mishac> this is too much text
12:14:22 <Mishac> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures/07-folds-monoids.html
12:14:26 <Mishac> the last paragraph before the monoids
12:14:33 <Mishac> can someoneclarify some of the terms
12:14:35 <Mishac> ?
12:14:39 <OverCoder> EvanR, How do I?
12:14:47 <OverCoder> I mean how do I access those fields
12:15:05 <OverCoder> ah wait
12:15:13 <OverCoder> Nothing never mind, I just didn't see your example at first
12:18:10 <EvanR> i guess type families dont work with data kinds
12:19:27 <Welkin> EvanR: they don't like yer kind 'round 'ere
12:20:51 <geekosaur> ...unkind families...
12:22:13 <ReinH> Oh they left :(
12:22:17 <ReinH> It was a good question.
12:42:39 * hackagebot hsqml-demo-morris 0.3.1.1 - HsQML-based implementation of Nine Men's Morris  https://hackage.haskell.org/package/hsqml-demo-morris-0.3.1.1 (RobinKay)
12:44:10 <lambda-freeze> i'm doing a qualified import of Data.Vector as V. How do I use the (++) function defined in Data.Vector? V.(++) does not work. I feel incredibly stupid but I can't seem to figure it out
12:44:46 <Welkin> you must put the parens around the entire function
12:44:49 <Welkin> (V.++)
12:45:06 <lambda-freeze> ah, thanks!
12:45:49 <zipper> Hey haddock seems to take files to generate docs.
12:46:10 <zipper> What if I want to generate docs for the entire project?
12:46:36 <zipper> I can't find a way to generate haddocks for the entire project in the man pages
12:47:11 <kadoban> lambda-freeze: By the way, you can just use (<>) from Data.Monoid instead. Vector a  is an instance of Monoid
12:49:38 <EvanR> got it to work type family (a :: [*]) :++: (b :: [*]) :: [*]
12:49:41 <OverCoder> Everything is there http://lpaste.net/152239 :)
13:00:04 <lpaste> SavinaRoja pasted “hamm.hs” at http://lpaste.net/152240
13:00:58 <SavinaRoja> in the main of that script, there are a couple equivalent expressions, I would be curious as to which people here would choose and why
13:01:35 <SavinaRoja> or if you would choose something else
13:15:57 <the_2nd> little game engine im working on. Thoughts / suggestions? : https://github.com/I3ck/HGE2D
13:17:28 <kadoban> SavinaRoja: I'd probably do the applicative one I guess *shrug*
13:21:00 <SavinaRoja> kadoban: thanks, not something that evokes strong opinions
13:28:17 <danilo2> Hello guys! :) In the current GHC version is using CPS Maybe faster than just Maybe monads? I'm asking about it because compiler can optimize CPS and non-cps code in the same way by inlining and unification, and CPS style is much less readable than "normal" monadic one
13:30:25 <Cale> danilo2: You'd have to profile, but I wouldn't expect the performance difference to be very significant in most cases.
13:31:09 <Cale> There will likely be many other things to attack before that becomes a reasonable thing to be doing to your code.
13:31:46 <danilo2> Cale: I know, just rewriting some core components in two versions and making measurments is time consuming so I just asked if there were maybe some important performance and opt improvements introduced that i dint know about :)
13:32:23 <danilo2> Cale: sure! but I prefer to think abut it whe writing the code, not after its done :)
13:41:23 <gfixler2> I feel like I asked this recently... is there more than one free monad?
13:41:57 <gfixler2> is "free monad" more a description of a set of qualities, or is there really just one of them?
13:43:08 <dolio> You'd have to be more precise what you mean by "free monad" to really get an answer. But generally speaking there is one, up to isomorphism.
13:43:23 <dolio> Or, one per functor.
13:43:44 <gfixler2> hmmm
13:43:55 <gfixler2> so one list free monad, one maybe free monad...?
13:47:32 <dolio> Free things are defined by an adjunction.
13:47:42 <dolio> Free ⊣ Forget
13:48:02 <dolio> And adjoint functors are unique up to isomorphism.
13:54:55 <Hijiri> free and forget
13:58:00 <SavinaRoja> is there a simple way to write a function that operates on sequence-like types?
13:58:00 <gfixler2> I need to learn what an adjunction is, it seems
13:58:16 <gfixler2> SavinaRoja: use fmap?
13:58:31 <gfixler2> Functor, or maybe Traversable?
13:58:39 <SavinaRoja> to say, operate just as well on ByteString, list, DList, etc.
13:58:58 <koz_> SavinaRoja: That depends on what functionality you want.
13:59:09 <koz_> Do you just want to be able to map over such things? Functor does what you want.
13:59:17 <koz_> If you want something more involved, you'd need something else.
13:59:35 <gfixler2> SavinaRoja: "just as well" - do you mean with the same complexity?
13:59:39 <SavinaRoja> I was thinking in the context of my hamming distance function
14:00:02 <SavinaRoja> zip is separately implemented for the sequence types
14:00:20 <koz_> You probably want a typeclass IsHammingDistanceable.
14:00:26 <gfixler2> fmap is implemented for each type, too
14:00:26 <koz_> And then put whatever functionality in there.
14:00:33 <koz_> And then implement it for the types you want.
14:00:43 <koz_> Disclaimer: Naming things is hard.
14:01:01 <gfixler2> does Traversable allow for traversal in both directions?
14:01:07 * gfixler2 doesn't know Traversable yet
14:02:02 <gfixler2> SavinaRoja: does hamming distance require walking back and forth over the sequence?
14:02:34 <SavinaRoja> gfixler2: it basically assumes that the type can be aligned, then compares at each position
14:02:51 <gfixler2> SavinaRoja: aligned across values?
14:03:01 <__monty__> gfixler2: Hamming distance is just the number of differences in items.
14:03:48 <SavinaRoja> I suppose one could propose a hamming-like function for trees as well
14:04:12 <gfixler2> SavinaRoja: this is the tricky bit - what does hamming even mean? :)
14:04:53 <__monty__> gfixler2: If you're serious: https://en.wikipedia.org/wiki/Richard_Hamming
14:05:09 <SavinaRoja> it has meaning between two objects, where it is the discrete count of deviations between the two
14:05:14 <gfixler2> __monty__: serious about finding the appropriate types based on the semantics
14:05:56 <gfixler2> SavinaRoja: can you simply zipWith?
14:06:08 <gfixler2> but with a generalized zipWith that works on any zipWithable type?
14:06:41 <__monty__> gfixler2: And then fold over the result?
14:06:46 <gfixler2> > sum $ zipWith (+) [1,2,3] [5,3,-1]
14:06:49 <lambdabot>  13
14:06:53 <gfixler2> __monty__: yeah
14:07:00 <gfixler2> find the deviations and sum them
14:07:02 <gfixler2> or similar
14:07:07 <SavinaRoja> I suppose I could say that for hamming, the objects need to be lengthable, and have the same length
14:07:48 <gfixler2> if they're the same length, zipWith sounds very useful to me
14:08:10 <__monty__> gfixler2: Hamming would actually be more like zipWith (==) xs ys and then count the false's.
14:08:40 <__monty__> SavinaRoja: You'd also need equable on the contained type of course.
14:08:52 <SavinaRoja> __monty__: yep
14:09:10 <gfixler2> zipWith (==) [1,2,4,5,5] [1,2,3,4,5]
14:09:13 <gfixler2> > zipWith (==) [1,2,4,5,5] [1,2,3,4,5]
14:09:14 <lambdabot>  [True,True,False,False,True]
14:09:26 <gfixler2> > length $ filter (== True) $ zipWith (==) [1,2,4,5,5] [1,2,3,4,5]
14:09:28 <lambdabot>  3
14:09:44 <gfixler2> fold would probably be more efficient
14:09:44 <__monty__> gfixler2: filter id
14:09:51 <gfixler2> __monty__: nice
14:10:07 <SavinaRoja> > length $ filter (== True) $ zipWith (==) "hello" "holla"
14:10:09 <lambdabot>  3
14:10:32 <__monty__> gfixler2: But yes, fold would probably be better.
14:10:55 <SavinaRoja> should filter on ==False
14:12:45 <__monty__> SavinaRoja: You're right, or use /=
14:12:54 <gfixler2> > foldr (\(x,y) zs -> zs + if x == y then 0 else 1) $ zip "hello" "holla"
14:12:56 <lambdabot>      Could not deduce (Num [(Char, Char)]) arising from a use of ‘+’
14:12:56 <lambdabot>      from the context (Eq a, Foldable t)
14:12:56 <lambdabot>        bound by the inferred type of
14:13:04 <gfixler2> :(
14:13:14 <gfixler2> > foldr (\(x,y) zs -> zs + if x == y then 0 else 1) 0 $ zip "hello" "holla"
14:13:16 <lambdabot>  2
14:13:52 <gfixler2> can probably shrink that with `on` or somesuch
14:13:55 <gfixler2> :t on
14:13:56 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:14:31 * hackagebot ed25519-donna 0.1.1 - Haskell bindings to ed25519-donna (Elliptical Curve Signature Scheme)  https://hackage.haskell.org/package/ed25519-donna-0.1.1 (ThomasDuBuisson)
14:16:40 <SavinaRoja> gfixler2: that seems pretty concise to me :)
14:27:15 <koz_> Is there some type out there like Seq, but which covers both finite *and* infinite sequences?
14:27:29 <koz_> s/type/typeclass
14:28:05 <hexagoxel> can i append to the end of an infinite container in O(1) then?
14:28:38 <koz_> hexagoxel: I didn't necessarily ask for a type with the same performance characteristics.
14:28:56 <koz_> I'd like a typeclass that collects all sequence-like operations under its wing which work for both finite and infinite sequences.
14:35:45 <Hijiri> koz_: infinite on possibly both the left and right?
14:36:43 * hexagoxel does not know an answer, and remembers that there is a clear answer in Scala (not even scalaz).
14:37:12 <mniip> data Fancy a = Pure a | Cons a (Fancy a) | Snoc (Fancy a) a
14:37:43 <hexagoxel> well, `AbstractSeq` or `LinearSeq`.
14:37:49 <mniip> oh wait this is only infinite in one direction
14:38:39 <mniip> hmm
14:38:53 <mniip> data Fancy a = Fancy (Maybe (Fancy a)) a (Maybe (Fancy a))
14:39:50 <koz_> Hijiri: Infinite in one direction.
14:41:44 <hexagoxel> koz_: what about http://hackage.haskell.org/package/collections-api-1.0.0.0/docs/Data-Collections.html
14:41:52 <koz_> hexagoxel: Finite-only.
14:41:59 <koz_> I think.
14:42:30 <koz_> Oh wait, never mind, was thinking the wrong thing. Thanks, will investigate.
14:43:34 <hexagoxel> koz_: it does not seem to provide any instances though, does it? :/
14:44:18 <koz_> hexagoxel: I just noticed that.
14:44:34 <koz_> Also, how do you check the precedence of an infix operator?
14:45:27 <hexagoxel> http://hackage.haskell.org/package/sequence-0.9.8/docs/Data-SequenceClass.html has at least [] and Seq instances.
14:45:58 <hexagoxel> :i
14:46:42 <koz_> :i (:)
14:48:48 <koz_> hexagoxel: Unfortunately, Sequence there is finite-only.
14:48:54 <koz_> Oh well, time to experiment a bit.
14:49:32 * hackagebot foldl-transduce 0.5.0.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.5.0.0 (DanielDiazCarrete)
14:49:44 <hexagoxel> meh, sorry for my wild guessing.
14:52:12 <koz_> hexagoxel: It's fine - I appreciate the help. :)
14:56:37 <sphinxo> How do I implement show for GADTS?
14:57:28 <sphinxo> ke@unaffiliated/cfricke) has quit (Quit: leaving)
14:57:31 <sphinxo>           >> :: baweaver (~baweaver@173.230.196.25) has joined #haskell
14:57:33 <sphinxo>           << :: kurt11 (~Adium@207.191.34.198) has quit (Quit: Leaving.)
14:57:35 <sphinxo>           << :: csd___ (~chris@cpe-24-90-169-55.nyc.res.rr.com) has quit (Ping timeout: 264 seconds)
14:57:37 <sphinxo>      sphinxo :: How do I implement show for GADTS?
14:57:39 <sphinxo>           << :: xnil (~xnil@69.43.66.12) has quit (Ping timeout: 276 seconds)
14:57:41 <sphinxo> oh god
14:57:46 <Hijiri> what
14:57:58 <baweaver> ?
14:58:11 <sphinxo> Wonderful middleclick pasting
14:58:31 <sphinxo> when your mousepad is clickable on a thinkpad
14:58:33 <hexagoxel> there are clients out there that ask you before doing multiline pastes, i heard.
14:58:38 <dmj> would it be possible to promote fields of a record to types (or no since types can't be lowercase). The field name could become uppercase with the kind being its unpromoted type?
14:59:15 <sphinxo> hexagoxel: Mine should have ( weechat )
14:59:48 <sphinxo> I think it may have seen y in what I pasted
15:02:03 <sphinxo> so i want to implement Show for Expr when expr is a GADT like so (data Expr a where Lit    :: a -> Expr a)
15:02:49 <sphinxo> oh wait
15:02:53 <sphinxo> I'm an idiot
15:03:41 <Enigmagic> dmj: if you like writing template haskell
15:03:50 <dmj> Enigmagic: boo :(
15:04:08 <dmj> Enigmagic: There is an alternative GADT syntax which would work
15:04:44 <Enigmagic> dmj: use that instead? :-)
15:05:27 <dmj> sorry, which *could* work :]
15:21:03 <hexagoxel> i want to create a package "c" that exposes the union of the interfaces of packages "a" and "b", using reexports. Is this possible without creating a module for each module in `a union b`, each containing a trivial reexport?
15:21:40 * hexagoxel is experimenting with some advanced custom Prelude technicalities.
15:23:03 <hexagoxel> alternatively, the user of this Prelude would have to add a direct dependency for each dependency of the Prelude..
15:27:12 <jamesfordummies> can anyone tell me why line 8 prints out, but line 16 does not? (it occurs in a forked thread through line 10) http://lpaste.net/3532083471033827328
15:27:45 <hexagoxel> hmm, as i am deep in CPP at this point anyway, i could only provide reexports for exactly those dependencies that are actual direct dependencies.. i would only need some macro that allows to query if x is a dependency of the current package.
15:27:48 <bergmark> hexagoxel: with cabal 1.22 you can re-export modules without needing extra files
15:29:20 * hexagoxel checks cabal --version; 1.23.
15:29:44 <Cale> jamesfordummies: I don't know, but  forever $ return ()  is a very expensive way to block.
15:30:14 <geekosaur> threaded runtime?
15:30:23 <Cale> jamesfordummies: Try  forever (threadDelay (10^8))  or something at least.
15:30:23 <jamesfordummies> Cale: not what it will be eventually, this is reduced-debugging-code :P
15:30:31 <jamesfordummies> kk
15:31:00 <jamesfordummies> welp that was it
15:31:02 <Cale> Yeah, but that code might not even be suitable for testing, because it'll go into a non-allocating loop and in a non-threaded runtime might not yield to other threads.
15:31:15 <hexagoxel> bergmark: is this documented somewhere?
15:31:29 <jamesfordummies> Cale: expensive because it occurs so quickly it will never pause?
15:32:06 <geekosaur> in general, the non-threaded runtime does things on blocking operations or memory allocation
15:32:13 <geekosaur> forever $ return () does neither
15:32:37 <jamesfordummies> ah
15:32:51 <jamesfordummies> duh. makes sense - thanks geekosaur and Cale 
15:33:26 <geekosaur> ("things" including thread context switching, garbage collection, various other housekeeping tasks)
15:34:02 <Zekka|Sigfig> geekosaur:  jamesfordummies: Would inserting a very brief sleep operation fix his problem?
15:34:11 <jamesfordummies> the problem is fixed
15:34:27 <Zekka|Sigfig> Asking because I’m guilty of doing that once or twice, and haven’t had a case for anything like it for months
15:34:27 <geekosaur> Zekka|Sigfig, yes. or a long one, which was Cale's suggestion
15:34:34 * hackagebot vault 0.3.0.6 - a persistent store for values of arbitrary types  https://hackage.haskell.org/package/vault-0.3.0.6 (HeinrichApfelmus)
15:34:39 <Zekka|Sigfig> Oh, it looks like I missed Cale’s comment. I see it now, thanks
15:34:55 <geekosaur> also if you use the threaded runtime then you'll just have one thread spinning and other threads may be on other CPUs and still run
15:34:58 <Zekka|Sigfig> I started reading from “Yeah, but that code might not be suitable for testing” and assumed the problem had not been solved
15:35:05 <hexagoxel> bergmark: nevermind, i think i found it
15:35:27 <jamesfordummies> geekosaur: which would use OS threads, right
15:35:31 <geekosaur> yes
15:36:22 <jamesfordummies> cool
15:36:26 <geekosaur> non-threaded runtime uses one OS thread for FFI calls but all Haskell code is essentially cooperatively multitasked, with the possible yield points being blocking operations or memory allocations
15:38:05 <dmj> Is it possible to have type level let bindings
15:38:08 <o`connor> geekosaur: so threaded RT has preemption, but non-threaded doesn't? 
15:39:13 <hexagoxel> bergmark: neat, it actually works, once you figure out the syntax of the field :p
15:39:15 <geekosaur> theaded RT does N:M multithreading (that is N Haskell threads over M CPU threads) and CPU threads will be preempte according to system scheduler policy, yes
15:40:14 <geekosaur> I think the block-or-allocation thing still matters for switching which Haskell threads are on CPU threads though; less familiar with that part of the runtime
15:40:22 <o`connor> geekosaur: and there is no scenario in which M = 4, and I have 4 threads blocking everyone else?
15:40:33 <o`connor> ah
15:41:06 * geekosaur has had to dig into the guts of the non-threaded runtime. less cause to do so for the threaded one.
15:41:17 <o`connor> :) ok
15:41:22 <o`connor> thanks
15:42:23 <OverCoder> What's the equivalent of exec for Haskell?
15:42:29 <OverCoder> I want to execute code based on input
15:42:36 <OverCoder> I want my application to act just like an interpreter
15:43:12 <Zekka|Sigfig> OverCoder: Oh, you mean like in ghci?
15:43:19 <OverCoder> yeah
15:43:24 <geekosaur> I don't think you mean exec there? maybe you mean some kind of eval?
15:43:28 <Zekka|Sigfig> You’ve got to use a library for that but you can use hint
15:43:36 <Zekka|Sigfig> (there might be a newer alternative)
15:43:41 <OverCoder> geekosaur, maybe, but I want to do everything possible, not just evaluate expressions
15:43:43 <geekosaur> (exec would be, replace this program completely with another one)
15:44:12 <Zekka|Sigfig> ghc is not that easy to host in your program by itself, but a lot of people have written wrappers to make the interface much nicer
15:44:16 <mauke> OverCoder: python?
15:44:35 <geekosaur> also note that, as Haskell is compiled, "eval" means you would be using ghc-api (likely wrapped by hint or mueval) which is a completely different Haskell environment from that of your program
15:44:43 <OverCoder> mauke, actually coming from mainly Java, but I know some python, and I want python's exec equiavelnt in haskell
15:44:47 <Zekka|Sigfig> hint is one, there’s also one designed for config files, but I don’t remember what it’s called
15:44:54 <OverCoder> geekosaur, hmm
15:44:55 <geekosaur> that is, you cannot introspect *your* program this way
15:44:56 <mauke> OverCoder: yeah, everyone else calls that "eval"
15:45:01 <mauke> python is weird
15:45:07 <Zekka|Sigfig> You can’t create top-level definitions or new type definitions for your program, but that probably wouldn’t be desirable anyway
15:45:11 <OverCoder> mauke, hm, okay
15:45:17 <Zekka|Sigfig> types don’t exist at runtime most of the time and you can just hold onto values instead of top-level definitions
15:45:25 <OverCoder> Hm, so it's almost impossible for a tiny beginner? D:
15:45:36 <Zekka|Sigfig> And you can inject stuff into the environment you’re hosting, of course
15:45:39 <geekosaur> it is not the best place to start, no
15:45:55 <OverCoder> Okay :P
15:46:04 <OverCoder> Thank you all :)
15:46:05 <Zekka|Sigfig> It’s not that hard to do but you might be missing some concepts: https://hackage.haskell.org/package/hint read these docs and if you understand them you might play around
15:46:22 <OverCoder> Gonna read that
15:46:55 <OverCoder> Zekka|Sigfig, seems like exactly what I need
15:47:11 <koz_> How would I turn (Maybe x, Maybe y) into Maybe (x, y)?
15:47:47 <koz_> (meaning 'Nothing if either x, y or both are Nothing')
15:47:57 <OverCoder> koz_, I am a beginner, but lemme throw a guess
15:48:50 <OverCoder> Ah wait, I did the reverse thing
15:49:37 <Zekka|Sigfig> koz_: Want a golfy way? I think uncurry (liftA2 (,)) does what you want
15:49:46 <Zekka|Sigfig> > uncurry (liftA2 (,)) (Just 1, Just ‘a’)
15:49:48 <lambdabot>  <hint>:1:36: lexical error at character '\8216'
15:49:52 <Zekka|Sigfig> oh, smartquotes!
15:50:00 <Zekka|Sigfig> > uncurry (liftA2 (,)) (Just 1, Just 2)
15:50:02 <lambdabot>  Just (1,2)
15:50:23 <Zekka|Sigfig> > uncurry (liftA2 (,)) (Just 1, Nothing)
15:50:25 <lambdabot>  Nothing
15:50:32 <echo-area> koz_: If either Maybe x or Maybe y is Nothing, what's the corresponding entry in Maybe (x, y)?
15:50:40 <koz_> echo-area: Nothing.
15:51:02 <koz_> Zekka|Sigfig: Thanks, that seems about right.
15:51:45 <Zekka|Sigfig> koz_: The intuition is that Maybe’s applicative behavior is to stop producing values if a Nothing appears anywhere up the chain
15:52:00 <Zekka|Sigfig> So using `uncurry` is just a shorter way to get inside both sides of your tuple, and (,) just puts your tuple back together
15:52:23 <koz_> Zekka|Sigfig: Yeah, that makes sense - thank you!
15:52:24 <Zekka|Sigfig> this is less golfy: flipTup (x, y) = liftA2 (,) x y
16:05:17 <OverCoder> How do I compare a ByteString and a String ?
16:05:39 <OverCoder> equation operator doesn't work because types mistmatch
16:05:43 <OverCoder> mismatch*
16:06:55 <tommd> Compare how?
16:06:55 <Zekka|Sigfig> OverCoder: You’ll probably want to convert one to the other
16:07:05 <tommd> As in, equality assuming the string is ASCii?
16:07:07 <Zekka|Sigfig> That’s a slightly sticky process because there are multiple ways to represent a String as a bytestring
16:07:21 <OverCoder> Ah, so I want to pack the other string? okay
16:07:27 <Zekka|Sigfig> You could drop all nonascii characters from the String, for instance. Or you could encode them in UTF-8
16:07:30 <tommd> compare bs str 07= bs 07`compare` Data.ByteString.Char8.pack str
16:07:36 <tommd> err, name the top level function something not compare.
16:07:48 <Zekka|Sigfig> If you know what the ByteString is (like, what encoding) I would turn it into a String
16:07:58 <OverCoder> No I they are guranteed to be alpha characters, so I don't care about dropping chars
16:08:02 <tommd> Yes, certainly but if that's the case you should be using text.
16:08:22 <Zekka|Sigfig> Sounds like no harm in dropping everything nonascii from the string then. (I don’t remember offhand how to do this though)
16:08:36 <koala_man> pack will truncate
16:08:44 <Zekka|Sigfig> Will it? Cool then!
16:08:52 <OverCoder> hmmm
16:08:57 <tommd> > Data.ByteString.Char8.pack "ƃuıʇsǝʇTesting"
16:09:00 <lambdabot>  Not in scope: ‘Data.ByteString.Char8.pack’
16:10:23 <Axman6> > Char8.pack "ƃuıʇsǝʇTesting"
16:10:25 <lambdabot>  Not in scope: ‘Char8.pack’
16:10:28 <Axman6> :(
16:11:12 <dogcat> hey, trying to find some great ideas to work on in haskell? Anyone learn something cool lately?
16:12:31 <dogcat> I guess I'll go, a haskell for industry would be amazingly productive
16:12:48 <EvanR> Enterprise Haskell Integration Platform
16:13:38 <davean> What is a "a haskell for industry"?
16:14:25 <dogcat> Haskell for industry would dial down some things like language pragma to reduce training time while still benefiting from equational reasoning and expressiveness
16:14:54 <dogcat> you want to train a haskell dev, its gonna be at least 3 months before they start contributing, 6 months and they might be on their won
16:14:56 <dogcat> *own
16:15:00 <EvanR> making glasgow-exts the default? ah yes that would definitely reduce boilerplate ;)
16:15:13 <shadowdao> And Oracle would own it.
16:15:25 <dogcat> nah, this is open source
16:15:26 <EvanR> dogcat: i dont know
16:15:38 <dogcat> i work on a closed source language at work, and it's not really cool
16:15:55 <EvanR> i think somebody could be up to speed in haskell pretty fast if they are already into write-compile-fix loops
16:16:12 <EvanR> and learn basic types
16:16:39 <dogcat> idk, I've been learning it for three months and am just feeling like I can understand most code I see
16:16:58 <EvanR> "train a 'dev'" could mean a lot of people
16:17:09 <dogcat> haskell has some great ideas, but it's hard to learn
16:17:39 <EvanR> nowadays devs include former customer relations managers
16:17:48 <Nublet> hi everyone
16:17:58 <dmj`> hi Nublet
16:18:08 <EvanR> dev could also mean 37 years experience in C
16:18:37 <EvanR> theres going to be some distinction in haskell grokking
16:18:41 <peddie> dogcat: "learn something cool" guaranteed: http://okmij.org/ftp/
16:22:21 <Nublet> Haskell seems to be missing learning material compared to more widespread languages. I don't find the available books satisfactory but that may be me.
16:22:36 <dogcat> what about the white papers? it's academic culture is huge
16:22:50 <dogcat> you just gotta fake it to you make it
16:23:06 <montanonic> Nublet: http://haskellbook.com/ is really comprehensive for beginner -> intermediate stuff
16:23:12 <EvanR> well, learning material on javascript is pretty much ... you learn it by experiencing it
16:23:15 <kadoban> Nublet: http://haskellbook.com/ has a really good reputation, and seems to be a great way to start.
16:23:19 <EvanR> same with ruby really
16:23:26 <dogcat> ruby is perl with objects
16:23:31 <kadoban> dogcat: That's … not useful information for learning the language.
16:23:35 <EvanR> neither of these gets the same criticism
16:23:48 <Welkin> Nublet: we have our chosen material
16:23:50 <montanonic> Nublet: there's definitely less stuff out there targeted towards beginners/intermediates though, that's for sure; but there's also enough to learn the language from, with simultaneous practice and use
16:23:51 <Welkin> @where learnhaskell
16:23:51 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:23:54 <Welkin> go there
16:24:03 <dogcat> sorry man, I know both and I would argue that they choose expressiveness over convention, which makes for code that is harder to read
16:24:04 <EvanR> ruby is smalltalk with a couple of perlisms
16:24:09 <Axman6> kadoban: sure it is, I just have to learn perl now
16:24:25 <Welkin> yes, also, the papers are great
16:24:26 <dogcat> for me, the hard thing about haskell was realizing I needed to think about it mathematically
16:24:33 <Welkin> the early Monad papers by SPJ in particular
16:24:40 <dogcat> what's a monad? return and bind functions
16:24:47 <Welkin> short and filled with great information to demystify haskell
16:24:51 <EvanR> in fact you should probably think about more things than haskell mathematically
16:25:00 <dogcat> haha
16:25:44 <dogcat> mathematics is a powerful tool, it's amazing we have design patterns that can't be expressed in the syntax of a programming language
16:25:48 <kadoban> Axman6: I mean the thing about whitepapers, heh.
16:25:57 <Axman6> oh =)
16:26:17 <dogcat> like we already figured out how to reason over structures, why don't we define abstraction that way?
16:26:25 <Welkin> dogcat: design patterns?
16:26:35 <dogcat> i'm not sure I follow?
16:26:36 <Welkin> design patterns are a sign of something being broken
16:26:45 <dogcat> yea, I agree
16:26:46 <Welkin> haskell doesn't have design patterns
16:26:59 <dogcat> that the language can't express all the ideas you need to build with it
16:27:16 <montanonic> Welkin: speaking of this, I wanted to ask: do people think that Free or operational are design patterns?
16:27:40 <dogcat> yea, i see what you mean
16:27:46 <dogcat> they aren't in gang of four though
16:28:03 <dogcat> like first and final form evaluators 
16:28:24 <Welkin> montanonic: I'm not the one to ask about that
16:29:05 <EvanR> gang of four... is this still relevant?
16:29:17 <montanonic> it was an open question; I've never used Java so I don't really know what in particular defines a Pattern 
16:29:17 <EvanR> visitor objects?
16:29:21 <dogcat> yea, it turned me on to smalltalk
16:29:25 <dogcat> that was fun!
16:30:42 <dogcat> so we could say haskell is more expressive, defining all structures semantically, and the type inference is demonstrably useful. What can we do know that we couldn't do before? 
16:30:49 <Welkin> there are plenty of PL enthusiasts and researchers in here who could answer all your questions though 
16:31:05 <EvanR> a lot
16:31:06 <montanonic> dogcat: you could always do everything in assembly
16:31:27 <dogcat> not really
16:31:32 <dogcat> lol
16:31:54 <dogcat> montanonic: we'll run out of funding right when we get to the compiler
16:32:36 <montanonic> There's parse ambiguity in that sentence, sorry, I meant: "everything that we do has already been possible in assembly". I wasn't sure if you were asking from the perspective of someone who doesn't use Haskell, either.
16:33:13 <dogcat> i love seeing how people leverage these ideas haskell does so well to make the software development a better process, or build something very easily
16:33:14 <montanonic> I was just going to say that Haskell, at least for me, makes it much nicer to write code, compared to the other languages I've tried. Strong types are a huge winner.
16:34:00 <dogcat> yea, if you don't want strong types, you may need tests to hold together your commercial system
16:34:54 <dogcat> I like the idea of using haskell to solve algorithmic problems elegantly
16:35:00 <dogcat> like Birds book was an eye opener
16:35:29 <Welkin> yeah
16:35:31 <montanonic> dogcat: yeah I've only barely touched that (prioritizing web devel right now), but I loved the tiny bit I read and worked through
16:35:33 <Welkin> but I don't even use it for things like that
16:35:44 <Welkin> I just use it to make web dev suck less
16:35:56 <dogcat> using DSLs ?
16:36:16 <Welkin> sure, some
16:36:36 <dogcat> i like the idea of being able to write a DSL as a tool to write faster code
16:37:07 <dogcat> like a DSL to make iphone apps really fast enough that you can try all sorts of solutions
16:37:12 <dogcat> or android
16:38:32 <dogcat> Haskell's superiority in data science/ analysis/ data visualization/ machine learning is hard to see
16:39:12 <dogcat> maybe it's dependent types, or the fact that you don't get much out of the type checker when you go doubles to doubles, but there must be some advantage
16:39:47 <dogcat> has anyone used HLearn?
16:40:07 <montanonic> I can't imagine how the types of abstractions raised in those areas would be better expressed in basically any other language.
16:40:30 <montanonic> dogcat: I've been curious to try it as my next step after web devel stuff
16:40:46 <dogcat> well, the reality is that you are writing mostly one off small scripts, and sometimes types just get in the way
16:41:25 <montanonic> yeah, I guess I wouldn't really know; if you're trying to build a library to do something though, I would imagine that Haskel is where it's at
16:41:32 <montanonic> Haskell*
16:41:33 <dogcat> you are trying to explore quickly, using different packages
16:41:36 <dogcat> yea, i agree
16:41:45 <dogcat> I'm trying to figure out what to work on
16:42:05 <montanonic> dogcat: do you know a fair bit about ML?
16:42:15 <montanonic> (Machine Learning, not the PL)
16:42:16 <dogcat> i did it everyday in grad school till i dropped out
16:42:24 <Cale> dogcat: I can't imagine that types really get in your way any more than they would in a dynamically typed setting -- you're free to just make everything a Double if you want to.
16:42:39 <Cale> dogcat: Of course, that doesn't get much use out of the type system if you do.
16:42:40 <montanonic> dogcat: gotcha; good stuff; I'm a drop-out too, but I didn't get to grad-school :)
16:42:41 <dogcat> i can get predictions done for classifiers better than most, im not that good with unsupervised or reinforcement
16:43:23 <Cale> dogcat: The closest thing to machine learning I've done with Haskell is building a linear regression model with the stuff in http://hackage.haskell.org/package/statistics though
16:43:51 <dogcat> it's good practice is hard problems, but grad school graduates are so hyper focused and get things done on a very slow scale
16:43:56 <dogcat> not good for startups
16:44:22 <montanonic> dogcat: hey, can you recommend a few ML resources for a noob? I'd like to know a kind of path through learning it
16:44:22 <shadowdao> I've used the simple-neural-network package.  Seems like a good place to start.
16:44:40 <dogcat> yea, my go to is boosting
16:44:41 <montanonic> dogcat: also, if you like startups, have you seen the recent Haskell one in Boston for ML? Sentenai?
16:44:51 <dogcat> is that Brandon's?
16:44:54 <montanonic> dogcat: yes
16:45:21 <dogcat> yea, I'm aware, but have a job that may make switching tricky
16:45:25 <johnw> Cale: do you know if this would be a valid parametricity theorem arising from Codensity: forall (k : Codensity m a) (f : a -> m b), runCodensity k pure >>= f = runCodensity k f
16:45:45 <johnw> (Monad m, of course)
16:45:45 <montanonic> dogcat: yeah, it just seemed like I should mention it to you
16:46:00 <dogcat> thanks, Brandon is great at reinforcement learning
16:46:25 <dogcat> it's awesome he's doing his company in Haskell!
16:46:50 <dogcat> hopefully some good opensource packages will emerge for exploring and plotting data in Haskell
16:47:07 <dogcat> an implementation of Wilkonson's Grammer of Graphics would be cool
16:47:16 <montanonic> dogcat: sorry to ask this question again, but are you able to name a few resources in ML (books, for example) that a noob like me could read to go from knowing next-to-nothing to having moderate knowledge in the field?
16:47:33 <montanonic> dogcat: also yeah, it's super-great to see companies forming with Haskell as the primary language. Yay.
16:47:53 <dogcat> :montanonic do you feel comfortable with statistics?
16:48:15 <dogcat> if not, read Jaynes Probability the science of logic or something
16:48:31 <montanonic> I've had a horrible time finding anything that was good; I think Machine Learning: The Art and Science of Algorithms that Make Sense of Data was the best looking intro I found
16:48:36 <dogcat> you need to grok probabilities to understand machine learning
16:48:44 <dogcat> so there are two really good books:
16:48:51 <dogcat> Bishop, which I don't read
16:49:00 <montanonic> dogcat: I studied math and physics in college, and did stats in high school; I don't know it but I'm sure I'd get comfort quickly
16:49:00 <Cale> johnw: That seems like it ought to involve the monad laws somehow...
16:49:11 <dogcat> and The elements of statistical learning, which i do read all the time
16:49:14 <montanonic> dogcat: those sound good to me, I'll look them up
16:49:23 <johnw> Cale: I meant to include Monad m =>, is that what you mean?
16:49:25 <dogcat> yea, try the coursera course on ml
16:49:41 <Cale> johnw: I mean, can it really arise from just parametricity? I'm not sure.
16:49:49 <montanonic> dogcat: is it high quality?
16:49:50 <johnw> Cale: I'm not sure either...
16:49:51 <dogcat> but don't be afraid to learn stats/some calc/and linear algebra first, they are the tools of the trade
16:50:03 <montanonic> I'm just wary of hype approaches, since it's kind of a pop field right now
16:50:19 <montanonic> dogcat: Yeah, I'm def not afraid of that
16:50:27 <bitemyapp> I don't think learning calculus, stats, and the foundations would hurt anybody
16:50:33 <johnw> Cale: I'm trying to identify the exact precondition under which Codensity m A ≅ m A, given that Codensity is larger, but owing to the type I must refer to parametricity somehow
16:50:43 <dogcat> well, if you find you can solve problems with economic value, then you'll keep learning
16:51:16 <dogcat> and we just have so much data coming at us right now, that you have to get creative if you want to understand its trends
16:51:42 <EvanR> the trend of more trends
16:52:02 <montanonic> dogcat: The Elements of Statistical Learning looks great
16:52:05 <Welkin> an app to help you organize your apps that organize your apps
16:52:07 <dogcat> montanonic: but try to keep your focus on the question you are asking, not the methods you are using, it's easy to lose sight of the bigger picture
16:52:19 <dogcat> the Free App library?
16:53:06 <dogcat> most data questions don't need machine learning, so don't force it
16:53:17 <Welkin> machine learning is a massive fad right now
16:53:23 <Welkin> it is definitely overhyped
16:53:25 <montanonic> dogcat: would Probability Theory: The Logic of Science -> Elems of Stat Learning be a good sequence for developing a foundation?
16:53:26 <dogcat> is PAC Learning wrong?
16:53:27 <Enigmagic> even if they do, you usually can get away with either logistic regression or random forests
16:53:49 <dogcat> montaonic: those are the books that inspired me
16:53:54 <Welkin> mostly it will be a waste of time and resources, especially if you don't know what you are doing and have no idea what kinds of questions to ask about the data
16:54:10 <dogcat> yea, you need domain experts
16:54:23 <montanonic> dogcat: awesome, thank you for the recommendations
16:54:36 * hackagebot feed-collect 0.2.0.1 - Watch RSS/Atom feeds (and do with them whatever you like).  https://hackage.haskell.org/package/feed-collect-0.2.0.1 (akrasner)
16:55:02 <dogcat> maybe what we call machine learning now, will just be called statistics, in a few years
16:56:14 <dogcat> the fact that it's popular will hopefully give the field enough space to define what it can and can't do
16:56:38 <Welkin> you don't want to be in the situation where you have a solution in search of a problem
16:56:45 <Welkin> which is so common with these hyped technologies
16:57:04 <dogcat> haha, i knew a post doc like that, really interesting idea: correlation can mean causation, if the distrubtions are right
16:57:12 <Welkin> dogcat: it is just statistics :P
16:57:18 <dogcat> I'm not sure he's published yet
16:57:23 <Welkin> this is a heated debate among AI researchers
16:57:27 <Nublet> does filterM make sense when used with Maybe?
16:57:29 <Welkin> they hate "machine learning"
16:57:40 <dogcat> yea, it's semantics
16:57:52 <dogcat> you need to talk about the underlying framework you are using
16:58:05 <dogcat> Probably Approximately Correct, proved useful for me
16:58:12 <Cale> Nublet: I suppose if your conditional might fail, and you want this to just fail to produce a list altogether.
16:58:29 <Cale> :t filterM
16:58:30 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
16:58:44 <Cale> So that'll be  (a -> Maybe Bool) -> [a] -> Maybe [a]
16:58:55 <montanonic> Seems like there's redundancy 
16:59:05 <Cale> Where if any of the results is Nothing, the overall result is Nothing
16:59:08 <Nublet> right, got it.
16:59:19 <dogcat> Welkin: that's funny, they really have so much they could share
16:59:21 <Nublet> Thanks everyone!
16:59:35 <montanonic> Nublet: alternatively you could use `all`, and map a `(a -> Bool)` function
16:59:44 <montanonic> > all [True, True, True]
16:59:46 <lambdabot>      Couldn't match expected type ‘a -> Bool’ with actual type ‘[Bool]’
16:59:46 <lambdabot>      In the first argument of ‘all’, namely ‘[True, True, True]’
16:59:46 <lambdabot>      In the expression: all [True, True, True]
16:59:50 <montanonic> oh darn
17:00:04 <dogcat> I like reading about the MIT AI lab in the 60s, it was a cool time when we explored what was actually possible to do with computers
17:00:12 <montanonic> Nublet: http://haddock.stackage.org/lts-5.2/base-4.8.2.0/Prelude.html#v:all
17:00:12 <int-e> montanonic: there's `and`
17:00:51 <montanonic> int-e: right, I think that's what I meant; thank you
17:01:38 <montanonic> > and [True, True, True]
17:01:40 <lambdabot>  True
17:01:45 <montanonic> > and [True, False, True, True]
17:01:47 <lambdabot>  False
17:01:48 <montanonic> Nublet
17:02:03 <dogcat> > foldrl1 and [True, True]
17:02:05 <lambdabot>      Not in scope: ‘foldrl1’
17:02:06 <lambdabot>      Perhaps you meant one of these:
17:02:06 <lambdabot>        ‘foldl1’ (imported from Data.List),
17:02:11 <dogcat> > foldr1 and [True, True]
17:02:13 <lambdabot>      Couldn't match type ‘Bool’ with ‘t Bool -> t Bool’
17:02:13 <lambdabot>      Expected type: t Bool -> t Bool -> t Bool
17:02:13 <lambdabot>        Actual type: t Bool -> Bool
17:02:22 <montanonic> dogcat: (&&) 
17:02:27 <Nublet> Basically, if the predicate fails to give a boolean value, the whole filtering process fails.
17:02:28 <dogcat> > foldr1 (&&( [True, True]
17:02:30 <lambdabot>  <hint>:1:25:
17:02:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:02:33 <dogcat> > foldr1 (&&) [True, True]
17:02:35 <lambdabot>  True
17:02:38 <dogcat> thanks!
17:02:41 <montanonic> :)
17:03:00 <dogcat> folds are great, but sometimes hard for me to read
17:03:12 <dmj`> are there kind functions?
17:03:17 <dmj`> like type families but for kinds
17:04:07 <EvanR> type families work for datakinds (i just figured out after head bashing)
17:04:08 <dogcat> are dependent types really coming to haskell?
17:07:00 <geekosaur> someday, if they can figure out how to do it without killing type inference etc.
17:07:13 <dogcat> haha, it's okay, the user won't do that anyway
17:07:33 <dogcat> Is there a place with references of all the type theory you would need to understand haskell?
17:07:49 <Cale> dogcat: kind of... The stuff that's already there allows for some dependently typed programs to be translated (albeit kind of awkwardly) into Haskell. The general approach to how things are going is to try to maintain a basic language where most types can be inferred easily, and only require annotations on definitions of things which are fancily typed.
17:07:55 <dogcat> I guess my problem is I read Ideas in Peirce's TAPL, but am not sure how exactly they apply
17:08:26 <Cale> But we don't even really know what our ideal lazy dependently typed language would look like.
17:08:34 <dogcat> awesome, I'll be watching what that will let us do
17:09:04 <Cale> dogcat: Well, definitely check out Idris, Coq, and Agda at some point.
17:09:29 <dogcat> i met Adam Chilpala, finally a academic who cares about implementation
17:09:36 <Cale> (If you learn one, I recommend going after all three to some extent, because the resources for learning are still a bit limited, and the three languages have fundamental similarities)
17:10:06 <dogcat> yea, I want to get everything in Haskell down first, including all the pragmas
17:10:07 <EvanR> it seems to me that ghc people cared more about implementation than most industrial languages
17:10:22 <mgsloan> Yeah, Chlipala is crush'n it
17:10:22 <johnw> Cale: dolio has something similar, but more general, in http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/
17:10:25 <mgsloan> *badum-tish*
17:10:30 <dogcat> could there be a compiler project where the inverse is true?
17:10:34 <johnw> I sat in on Adam's semantics class yesterday
17:10:43 <montanonic> dogcat: you know of http://dev.stephendiehl.com/hask/ right?
17:11:14 <dogcat> he's the one that got me into this!
17:11:23 <montanonic> oh haha, goo stuff
17:11:29 <montanonic> good*
17:12:25 <dogcat> it seems like Adam is closer than anyone to getting provable properties into commercial products
17:12:35 <mgsloan> Yeah, actually Chlipala recommending Haskell was one of the things that got me into it ~9 years ago
17:13:17 <mgsloan> Back when he was just some dude named smerdyakov on freenode ^_^
17:13:22 <dogcat> theres a great little type theory circle around Kendall
17:14:04 <Welkin> sounds like a LoTR character
17:14:15 <dogcat> lol, redline stop for MIT
17:14:46 <johnw> dolio: ping
17:24:47 <louispan> HI Haskell oracle. I'm trying to learn how to use the free monads from the free package (http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free.html).
17:24:47 <louispan> If I use cutoff to get the first n levels of computation (so that I can evaluate the first n levels of computation), how do I get to the leftover tree after cutoff?
17:34:38 * hackagebot Gifcurry 0.1.0.5 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-0.1.0.5 (lettier)
17:34:58 <dolio> johnw: Yes?
17:46:06 <dmj`> does type level (>>=) exist
17:50:40 <geekosaur> dmj`, I don't think there are (or planned to be) kindclasses, so no kindclass Monad where ...
17:51:11 <johnw> dolio: had questions about http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/
17:51:32 <johnw> I'll ask in PM
17:52:33 <dogcat> any using Haskell for microservers?
17:52:53 <dogcat> wanted to give it a shot via Servant/Aeson/Algorithm/ and out
17:53:05 <dogcat> i guess microservices
17:54:49 <dmj`> dogcat: yea, servant is good, do it
17:54:51 <montanonic> dogcat: if you haven't used Servant much, https://www.youtube.com/watch?v=gMDiKOuwLXw is a great watch
17:54:55 <dmj`> geekosaur: thanks
17:55:08 <dogcat> i gotta convince my co-founder let me code in haskell, and segmenting the code away would be perfect
17:55:40 * geekosaur does wonder how many brains exploded when he said "kindclasses" :p
17:55:53 <dogcat> like typeclasses for kinds?
17:56:03 <geekosaur> yeh. (not a planned feature)
17:57:09 <SavinaRoja> geekosaur: typeclasses for children?
17:57:20 <dogcat> homotopy type theory for the win!!!!!
17:57:44 <dogcat> making the pullback fun again...
17:59:06 <dogcat> has anyone used Data.Map for data analysis? was the performance acceptable to alternatives?
17:59:48 <dogcat>  > let x = x in x
18:05:12 <dogcat> anyone working on an interesting Haskell project?
18:05:30 <dogcat> learning the language and trying to find the good ideas
18:10:05 <dogcat> welcome!
18:14:10 <dogcat> are there any decently featured scripting languages in haskell? most of the stuff I see uses type inference, not dynamic dispatch
18:14:36 <dogcat> we are building one at work, and am curious about strategies to implement closures
18:16:34 <zv> shahaf: I don't think so, I just took a look and the x86 fencing instruction only orients the boundary, never after EL/IL 
18:17:59 <zv> so the instructions that GHC generates are in general sound, however a standalone derived may routinely bubble in the pipeline 
18:19:34 <montanonic> dogcat: if you haven't already seen this, this might help: http://stackoverflow.com/questions/13106683/dynamic-dispatch-in-haskell#13110560
18:24:27 <zv> the so does a great job but I can't help but feel that the question of vtables or dynamic dispatch in the context of haskell. implementation details can switch you between vtables & monomorphization
18:24:58 <zv> s/context of haskell/\1 is silly/g
18:34:56 <dmj`> anyone have examples of type level forM
18:36:46 <KaneTW> that sounds complicated
18:37:00 <Axman6> dmj`: what would the... type of that be?
18:37:20 <KaneTW> it's possible with -XTypeInType
18:37:21 <dmj`> type family ForM (as :: [a]) (f :: a -> b) :: [b] where
18:37:35 <dmj`> ForM '[] f = '[]
18:37:37 <Axman6> pretty sure that's map
18:37:54 <dmj`> aw, you're right, that's flip map
18:38:10 <dmj`> that's fine, For is fine for now
18:38:15 <dmj`> I just want to see it's usage
18:39:48 <KaneTW> i've done something similar for mapping a HList '[Stuff...] to a HList '[network representation of Stuff]
18:39:56 <KaneTW> not directly with ForM but I cna see the use case
18:40:41 <KaneTW> converting a list of finite naturals to fixed-width types or so
18:44:30 <dmj`> it would be cool if we could do this
18:44:31 <dmj`> type XS = Map (\a -> a + 1) '[1,2,3]
18:46:19 <KaneTW> wouldn't type-level lambda just be anonymous type aliases
18:48:40 <dmj`> unsure if haskell has type level lambdas :/
18:48:46 <dmj`> don't think so though
18:49:07 <KaneTW> it doesn't
18:50:46 <dogcat> the only Type to Type operaters are :: [], ->, and ()
18:55:35 <KaneTW> lambda is not an operator
18:55:48 <KaneTW> neither is [] or ()
18:56:10 <KaneTW> there's a type operators extension that allows you to define e.g. :+:
19:03:31 <montanonic> How the what does this even work? http://dev.stephendiehl.com/hask/#polyvariadic-functions
19:04:20 <montanonic> collect [1..9] 20 "lo.///lll" 40 :: [String] works and I'm so confused why
19:04:33 <montanonic> returns: ["[1,2,3,4,5,6,7,8,9]","20","\"lo.///lll\"","40"]
19:04:59 <montanonic> From the definition of the Arg class and instance Arg [String] it really doesn't seem like there's at all enough information to do that.
19:05:17 <Axman6> that's just how printf works
19:05:47 <montanonic> But, why does: collect' acc = acc ; lead to that behavior?
19:06:01 <montanonic> that's clearly a 1-param function
19:06:03 <Axman6> it's the (Show a, Arg r) => Arg (a -> r) instaqnce that does it
19:06:16 <Axman6> which is immediately below the [String] one
19:06:47 <montanonic> wait, but that's a separate instance, for IO, right?
19:06:58 <montanonic> ooh
19:07:00 <montanonic> no
19:07:52 <montanonic> Okay, well that's helpful because at least now I know which part of the code is responsible.
19:08:59 <montanonic> Fascinating. That's really cool.
19:09:00 <montanonic> Wow
19:10:28 <montanonic> Axman6: I see how it works now. Thanks for pointing that instance out.
19:10:51 <montanonic> That's cool to see a recursive function work across class instances
19:11:27 <Axman6> yeah, it's a little trippy and it confuses me every time I say it again
19:13:45 <vamega> I'm trying to parse some json with Aeson. But I'm having some trouble with nested structures.
19:14:07 <vamega> Here's a gist of my current attempt.
19:14:41 <vamega> Wait, sorry that's an older revision.
19:14:44 <vamega> Let me update that..
19:15:01 <Axman6> there is no gist...
19:15:09 <Welkin> hahaha
19:15:12 <vamega> Oh good, didn't hit send on that. :)
19:15:24 <Welkin> Axman6: we could have pranked you hard
19:15:30 <Welkin> we should have gone along with it
19:15:42 <Welkin> make you think you are losing your mind
19:15:53 <Axman6> heh
19:16:42 <koz_> @src foldr
19:16:42 <lambdabot> foldr f z []     = z
19:16:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:16:49 <vamega> https://gist.github.com/vamega/560cd49434f81ca5fb7e
19:17:33 <vamega> There you go.
19:18:44 <vamega> It say's it expected an array, but got an Object when I try to load the file.
19:21:10 <EvanR> erisco:  there are interesting laws here... like (a+b)•(c+d) = (a•c)+(b•d) , 
19:21:45 <EvanR> uhg lag... wrong
19:25:28 <monochrom> vamega: you have weather: [ ... ]  that's patently an array.
19:25:41 <monochrom> oh nevermind, misread.
19:31:36 <EvanR> I was under the impression that when the main thread died, the entire program ended. is that not a thing anymore?
19:31:59 <monochrom> the entire program should die. last I checked it did.
19:32:19 <EvanR> oh its misleading me... the spawned thread says Main: ExitSuccess
19:32:35 <EvanR> but its not the main thread
19:34:16 <AbelianGrape> Why isn't there a Foldable instance for Data.Vector.Unboxed?
19:34:35 <Axman6> AbelianGrape: I was aksing myself the same question just last week
19:34:38 <EvanR> or Vector right
19:35:22 <vamega>  monochrom: yeah weather is the key which has a value as an array.
19:35:35 <AbelianGrape> Axman6: Ever find an answer?
19:35:45 <Axman6> nope, I just used U.toList
19:36:04 <Axman6> which proved to be very fast, at least for what I'm working on (hopefully open sourced soon)
19:36:07 <vamega> Unsure if that means I should treat that key as an array or an object.
19:36:19 <AbelianGrape> Axman6: Huh. I'm surprised that doesn't hurt performance quite a bit
19:37:19 <Axman6> the compiler should be able to optimise it into exactly what you'd expect for a hand written Foldable instance
19:37:32 <Vaelatern> Hey folks. I'm trying to install a piece of software  (ganeti @ http://ganeti.org), and it uses haskell. It also seems to depend on various libs being older, like json<0.9. The problem is then it would require an older version of base, and getting that to work has been extremely difficult. Any advice?
19:38:10 <Axman6> that URL doesn't work
19:38:16 <montanonic> Axman6, AbelianGrape: not sure if this is helpful, but hackage.haskell.org/package/mono-traversable-0.4.0.3/docs/Data-MonoTraversable.html
19:38:23 <montanonic> MonoFoldable has Vector instances
19:38:25 <Vaelatern> By older version I mean base<4.8
19:38:37 <Vaelatern> Axman6: http://www.ganeti.org/ now with extra spaces to improve copying
19:38:40 <Axman6> Vaelatern: you'll need an older GHC to make that work
19:39:24 <AbelianGrape> montanonic: I am curious why this is necessary. Vector is polymorphic
19:40:09 <peddie> AbelianGrape: is it because you can't put an Unbox constraint on a Foldable instance?
19:40:14 <Vaelatern> Axman6: How old is current ghc?
19:40:39 <AbelianGrape> peddie: Ah, that looks like it
19:40:57 <Cale> Vaelatern: I think if you need base<4.8 that means you need GHC 7.8.x
19:40:58 <montanonic> interesting, how does the `mono` part help with that peddie ?
19:41:23 <AbelianGrape> montanonic: Using type families, you can put constraints on the element types
19:41:26 <peddie> montanonic, AbelianGrape: you'll find more about this problem if you look at "restricted monads"
19:41:29 <montanonic> I'm kind of noob with the whole monomorphism stuff
19:41:42 <montanonic> peddie: on it; thx
19:42:06 <peddie> montanonic: the `mono` part has the element type `a` in the instance declaration; the Foldable class definition involves only the container `f`
19:42:10 <montanonic> AbelianGrape: I'll have to do more research. I'm still not comfortable with type families, but thanks.
19:42:15 <Vaelatern> Cale: Shame. My OS doesn't allow older versions of packages in packaging dependencies.
19:42:25 <montanonic> peddie: what would the alternative be?
19:42:36 <montanonic> I interpret `a` as polymorphic
19:42:43 <montanonic> ooooh
19:42:44 <montanonic> wait
19:42:45 <montanonic> I get it
19:42:48 <Vaelatern> Is 4.8 a huge milestone or something?
19:42:50 <dmj`> see this in a reactive banana example: roll :: () -> StdGen -> (Reels, StdGen), why would it be necessary to pass in unit as a parameter, just curious
19:43:02 <peddie> montanonic: TypeFamilies or MultiParamTypeClasses + FunctionalDependencies, but you won't see those used just to define important classes in base like `Monad` or `Foldable`
19:43:11 <Cale> Vaelatern: base versions are tied to GHC versions, in an unfortunately not-100%-obvious way
19:43:34 <EvanR> dmj`: maybe to make it consistent with other functions of the form a -> b -> (c,b) ?
19:43:40 <montanonic> peddie: yeah, I'm currently studying those things because I'm still weak on the fancier type stuff in Haskell
19:43:47 <montanonic> feel free to throw resources my way
19:44:06 <peddie> montanonic: just go to oleg's website and browse around, you'll hit plenty of tricky stuff in no time
19:44:09 <peddie> @where oleg
19:44:09 <lambdabot> http://okmij.org/ftp/
19:44:29 <Cale> Vaelatern: I just happen to know that base-4.8.0.0 is what comes with ghc 7.10.1
19:44:31 <dmj`> EvanR: maybe, hm
19:44:38 <dmj`> https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/doc/examples/SlotMachine.hs
19:44:48 <dmj`> line 138
19:45:11 <montanonic> peddie: I think the problem is I need very basic explanations, not trickyness; I'm too intimidated by the overly mathy stuff when I'm coming into something new
19:45:19 <Cale> Vaelatern: It shouldn't be impossible to update the project to work with a new base
19:45:21 <montanonic> peddie: I need simple when starting
19:45:46 <Cale> (It might be as simple as relaxing the upper bound on the version)
19:45:48 <peddie> montanonic: I guess it depends on what you're trying to study, but probably more people can chime in with more specific resources if you ask a more specific question
19:45:59 <peddie> montanonic: otherwise I will just point you at the GHC user's guide
19:46:02 <peddie> heh
19:46:05 <montanonic> peddie: fair enough :)
19:46:15 <dmj`> montanonic: the typeclassopedia is a good resource, rewriting most typeclasses and instances from scratch will help
19:46:23 <dmj`> @where typeclassopedia
19:46:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:46:28 <montanonic> Yeah, any blog posts that demistify some of the type level stuff, like GADTS and type families, with nice examples, are solid
19:46:31 <AbelianGrape> montanonic: Type families and such aren't actually mathy themselves. They just let you do some useful things. You know how type classes let you define functions that are different depending on what class they are defined by? Type families let you define types that are different depending on which class they are defined on.
19:46:32 <Vaelatern> Cale: Any resources you may suggest? There are three libs it depends on that care, json, utd8-string, and lens
19:46:50 <peddie> dmj`: I wouldn't consider the typeclassopedia to be "fancy type stuff" like montanonic mentioned
19:46:53 <Vaelatern> Take note that I have not yet learned me a haskell for the greater good
19:46:53 <montanonic> dmj`: I've gone through that and loved it, but it doesn't cover stuff like type families and such
19:46:54 <EvanR> dmj`: i kind of dont see where *that* roll is being used
19:47:11 <EvanR> unless it has to do with recursive do
19:47:18 <EvanR> in which case look at the line with mapAccum
19:47:23 <montanonic> AbelianGrape: I meant to say that examples of them tend to be very formal and hard for me to penetrate. 
19:47:48 <montanonic> AbelianGrape: that explanation is nice
19:47:50 <dmj`> peddie, montanonic: ah I see
19:47:54 <dmj`> @where promotion
19:47:54 <lambdabot> I know nothing about promotion.
19:48:01 <dmj`> @google promotion
19:48:01 <lambdabot> https://en.wikipedia.org/wiki/Promotion_(marketing)
19:48:02 <peddie> montanonic: ok, here is an exercise: start reimplementing the HList library using type families instead of MPTCs+fundeps
19:48:07 <dmj`> heh :] 
19:48:19 <montanonic> I don't even know what HList does :D
19:48:23 <dmj`> montanonic: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
19:48:26 <peddie> guess you know what step 1 is :)
19:48:31 <montanonic> haha :)
19:48:45 <dmj`> EvanR: only one spot it seems, mapAccum initialStdGen $ roll <$> edoesplay
19:48:51 <montanonic> alright, thanks peddie :) ; also, don't know how fundeps work either... hehe
19:49:04 <montanonic> peddie: is that actually a reasonable goal, by the way? 
19:49:12 <EvanR> dmj`: right... so check the type of mapAccum
19:49:16 <dmj`> montanonic: ocharles has a 24 days of GHC Extensions
19:49:18 <peddie> montanonic: but seriously, I think if you can ask specific questions, you'll get good answers here or on stackoverflow
19:49:27 <dmj`> montanonic: https://ocharles.org.uk/blog/posts/2014-12-14-functional-dependencies.html
19:49:56 <montanonic> peddie: I agree with you, I just needed some guides to start with; dmj` has given me two things though, so I'll be looking through those
19:49:58 <montanonic> thanks all
19:49:59 <vamega> In Aeson, what's the difference between V.Vector Object and Array?
19:50:11 <peddie> montanonic: you could do it, although I suspect reimplementing the first 20% will teach you 80% of what there is to learn there
19:50:30 <montanonic> peddie: awesome, that sounds helpful then; I appreciate your advise
19:50:30 <Axman6> vamega: IIRC nothing
19:50:34 <montanonic> advice* 
19:50:53 <Axman6> vamega: actually, are you sure you don't mean V.Vector Value?
19:50:55 <EvanR> should be Vector Value right
19:51:23 <dmj`> EvanR: ah, edoesplay = () <$ filterE id emayplay ... roll <$> edoesplay
19:52:06 <Cale> Vaelatern: Where does the build get stuck? What kind of message are you seeing? I'd not have to ask, except it seems to be using autoconf/automake to build the Haskell stuff, which is quite unorthodox :)
19:52:07 <EvanR> dmj`: uh...
19:52:08 <koz_> OK, I'm having a bit of trouble here. I have two typeclasses - A (anything sequential, finite or not) and B (specifically finite sequential thing, which are all obviously As). I'm trying to define zip in terms of them, but I'm having trouble, because if I define it in terms of only As, it's hard for me to describe what happens when you zip together an A and a B.
19:52:15 <Axman6> montanonic: MonoTraversable feels like a code smell to me
19:52:28 <vamega> Axman6 yeah I'm sure.
19:52:31 <Axman6> the fact that MonoFoldable is so massive is a sign it's poorly designed
19:52:35 <koz_> So I have zip :: (A t) => A a -> A b -> A (a, b) at the moment.
19:52:56 <Axman6> koz_: that doesn't look like it makes any sense
19:52:58 <Cale> oh, there is a .cabal here at least
19:53:12 <EvanR> dmj`: if () -> anything is actually being used somehow, doesnt seem like haskell ;)
19:53:13 <Axman6> unless you have both a type called A and a class also called A
19:53:33 <koz_> Axman6: Sorry, my bad.
19:53:46 <koz_> It should be zip :: (A t) => t a -> t b -> t (a, b)
19:53:48 <vamega> Axman, the exact error output is here: https://gist.github.com/vamega/560cd49434f81ca5fb7e
19:53:54 <vamega> Along with the code.
19:54:19 <Cale> Vaelatern: So I guess what you do is start increasing/removing the upper bounds on the package dependencies around line 302 of ganeti.cabal
19:54:22 <vamega> GHC seems to see a difference between V.Vector Object and Array
19:54:35 <koz_> The problem is that Bs are As (finite sequential things are obviously sequential things), and if one of the arguments is a finite thing, the result should be a finite thing as well.
19:54:39 <Axman6> vamega: why does weatherP take () as an argument? o.O
19:54:49 <Axman6> vamega: they are different
19:54:53 <Cale> Vaelatern: and see if you can get it to find a solution to the dependencies which uses your installed base package
19:54:59 <dmj`> EvanR: hm :/ 
19:55:17 <GGuy> Lucid has the following definition: m >>= f = HtmlT (do { ~(g,a) <- runHtmlT m; ~(h,b) <- runHtmlT (f a); return (g <> h,b) })
19:55:19 <EvanR> vamega: type Array = Vector Value
19:55:19 <GGuy> so this would mean (<>) in 'g <> h' is: <> :: (HashMap Text Text -> Builder) -> (HashMap Text Text -> Builder) -> (HashMap Text Text -> Builder)
19:55:33 <GGuy> If that's right how do I find out where this is defined?
19:55:41 <vamega> It's not supposed to take that as an argument. Must have accidentally typed that in before copying.
19:55:51 <Cale> Vaelatern: and then if you get type errors and stuff, you'll have to figure out how the libraries have changed, which might require knowing some Haskell to really sort out.
20:02:51 <Vaelatern> Cale: It gets stuck, oh, somewhere... Configuring ganeti-2.16...
20:02:54 <Vaelatern> cabal: At least the following dependencies are missing:
20:02:56 <Vaelatern> json >=0.5 && <0.9,
20:02:58 <Vaelatern> lens >=3.10 && <4.8,
20:03:00 <Vaelatern> utf8-string >=0.3.7 && <0.4
20:03:02 <Vaelatern> Makefile:4120: recipe for target 'cabal_macros.h' failed
20:03:04 <Vaelatern> Sorry for paste
20:03:20 <dmj`> is reactive-banana the simplest FRP implementation? Looking for pedagogical examples
20:04:43 <GGuy> dmj`: elm?
20:05:49 <GGuy> dmj`: http://elm-lang.org/examples/mouse-position
20:06:48 <dmj`> GGuy: would like to stick with haskell
20:06:52 <Axman6> GGuy: that's the Monoid instance for Monoid r => Monoid (a -> r)
20:08:02 <GGuy> Axman6: Thanks!
20:11:08 <KaneTW> dmj`: FRP is a huge blanket term
20:11:29 <KaneTW> e.g. netwire and reactive-banana are both FRP, but completely different
20:11:36 <Cale> Vaelatern: Try relaxing the upper bounds on those packages in the .cabal file
20:11:54 <Cale> Vaelatern: (maybe just try removing them at first and see if it builds)
20:17:08 <koz_> @pl \f x -> x : iterate f (f x)
20:17:08 <lambdabot> ap (:) . ((.) =<< iterate)
20:19:20 <dmj`> KaneTW: sure, one being arrow-based. Just looking for a pedagogical implementation
20:20:33 <EvanR> dmj`: better start with the Fran paper then
20:20:59 <EvanR> functional reactive animation
20:21:23 <dmj`> EvanR: ah cool, 1997 :] 
20:21:29 <koz_> @pl \x -> x : repeat x
20:21:29 <lambdabot> ap (:) repeat
20:24:51 <koz_> \f x -> x : iterate f (f x)
20:24:55 <koz_> Whoops.
20:25:00 <koz_> @pl \f x -> x : iterate f (f x)
20:25:00 <lambdabot> ap (:) . ((.) =<< iterate)
20:25:54 <crough> That is some gross point free haha
20:26:27 <EvanR> dmj`: pay attention to the predicate events, both as a theoretical curiosity (think time is real-valued) and for the cool implementation
20:26:35 <Adeon> the points want to be free!
20:26:46 <koz_> crough: Yeah, that's pretty gross.
20:26:48 <EvanR> i dont think that really survived fran
20:28:03 <GGuy> dmj`: FYI if I remember correctly Conal Elliott is also a pretty good speaker if you like video (watched a few of his videos on youtube in the past)
20:28:19 <EvanR> yes conal videos are great
20:28:24 <conal> thx! :)
20:32:11 <koz_> @pl \i x -> x : replicate (i-1) x
20:32:11 <lambdabot> ap (:) . replicate . subtract 1
20:32:55 <koz_> How would that thing there be written using applicatives, if it can be done?
20:36:16 <Gurkenglas> What do you want from @pl? That is where those combinators are defined, if there were an elegant way to write that we wouldn't need the combinators. Unless you count arcane libraries... iterate f = unfoldr (Just . (id &&& id) . f) = evalState . repeatM . state ((id &&& id) . f) = \x -> scanl (const . ?f) x (repeat ())
20:37:08 <Gurkenglas> ap (:) is ((:) <*>)
20:39:58 <koz_> Gurkenglas: So thus, ap (:) . whatever is (((:) . whatever) <*>)?
20:40:53 <Gurkenglas> No, it's \x -> ((:) <*> whatever x)
20:42:37 <koz_> Gurkenglas: Ah, OK, that makes more sense. Thanks!
20:42:52 <nikki__> What is this channel?
20:44:43 <nikki__> I nee to rewrite a program, break the main function down into a bunch of other functions, the code is a mess. 
20:46:24 <dmj`> nikki__: haskell can do that
20:46:48 <nikki__> What is haskell?
20:47:04 <nikki__> What is haskell? @dmj'
20:47:36 <dmj`> nikki__: haskell is a purely functional programming language
20:47:51 <dmj`> https://www.haskell.org/
20:48:00 <nikki__> Oh, I'm on the wrong IRC channel, then. 
20:48:11 <nikki__> Sorry about that. 
20:48:39 <nikki__> Any idea where I should go for a general C++ channel?
20:48:58 <dmj`> #c++
20:49:29 <nikki__> Hah, I should've thought of that. Bye, thanks. 
20:49:29 <hodapp> I have found this and #haskell-blah much friendlier though.
21:49:46 * hackagebot mwc-probability 1.1.3 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.1.3 (JaredTobin)
21:50:09 <timothyh> hey - anyone around who's familiar with Cabal-the-library internals?
21:52:03 <dogcat> sorry, I've only every dug around to get alex/happy to work
22:19:51 <pdxleif> TIL: {}'s are called "suspenders" in American.
22:19:57 <pdxleif> https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/TFM.pdf
22:23:22 <Renard_Chase> So, I'm learning Haskell and am trying to put togather what would normally be a simple number game, which normally requires tracking a list of numbers, and a few other variables which doesn't seem doable in Haskell in the way that I would be used to doing it, so I'm wondering what the proper way to maintain the state of the application is in Haskell.
22:23:50 <dogcat> State Monad
22:24:33 <dogcat> if lets you get and put a state, if you make that state a hash map, you can map keys to some values you want to store
22:25:02 <EvanR> rather than hash map, try IntMap
22:25:12 <EvanR> or just regular Map
22:25:25 <Renard_Chase> Well I'm not looking for a solution to my specific problem, just a good general starting point
22:25:40 <dogcat> I would say learn the RWS monad
22:25:43 <dogcat> and the mtl library
22:25:48 <EvanR> eh...
22:25:56 <EvanR> Renard_Chase: what way would you like to be doing it
22:25:58 <dogcat> those are powerful enough to have you evaluate a stack based programming language
22:26:56 <dogcat> my advice is to write out the state monad and try to memorize it
22:27:00 <exio4> Renard_Chase: a recursion function might do it.
22:27:06 <dogcat> the bind is a little tricky, but will make sense, I promise
22:27:13 <Renard_Chase> I want it in a way that fits in with the Function Programming aspect of Haskell (which is what I am learning it for). Also my appologies if I'm getting any terminology wrong
22:27:30 <EvanR> ok there are a lot of ways to track this game state
22:27:34 <dogcat> yea, the state monad is just function calls
22:28:04 <dogcat> it implements something what acts like state by using do notation, and a bind operator that can extract and put values into a state
22:28:23 <EvanR> exio4 mentioned passing the state into the next recursive call (your game loop), another way is with IORefs, and there is the state monad but that one takes some work to set up
22:28:45 <exio4> I would just use functions, he's a novice, and functions are perfectly fine.
22:30:03 <dogcat> yea, good time to learn some foldr tricks
22:30:21 <Renard_Chase> I was considering recursive functions, but was worried it was... well I can't think of the right word, basically what you do when you solve a problem using methods in a way that you really should be using
22:30:29 <EvanR> dogcat: the fact that State is called that doesnt meant it should always be used for that... in fact StateT over something can be a pain in the ass
22:30:38 <dogcat> recursive functions are find in haskell
22:30:48 <dogcat> if you look up the Data.Map implementation, it uses them all over the place
22:31:12 <dogcat> EvanR: good point
22:32:23 <exio4> Renard_Chase: if you want to learn Haskell, a good idea might be to follow something like CIS194, or similar.
22:32:28 <exio4> @where learnhaskell
22:32:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:33:15 <Dividesbyzer0> Can anyone here tell me if CCIE is worth the money and the trouble. Or is there something better these days? 
22:33:18 <exio4> Renard_Chase: there's also #haskell-beginners (not that this channel is also beginner-friendly, but that channel is strongly related to the previous link)
22:33:41 <Renard_Chase> Fair enough, I'm just trying to find the right words for what I want to say next
22:36:37 <Renard_Chase> I guess what I want to ask is if that kind of recursion would go against the best practices for Haskell? Basically "Yes the problem can be solved like that, but you're not supposed to solve it like that" is what I am trying to avoid
22:36:57 <peddie> Renard_Chase: "idiomatic haskell"?
22:37:53 <EvanR> for a test or toy program that is probably the easiest way
22:38:21 <EvanR> do you want to research developing a large application?
22:39:04 <Renard_Chase> peddie: That seems to be the right coice of words
22:40:51 <EvanR> for a web app you dont have any local persistent state, but you would use a database. for a desktop app you may want to combine a local database and an FRP framework, like reactive-banana, instead of the OOP way
22:41:42 <Renard_Chase> EvanR: (If that was directed at me) Probably later, the situation at hand is that I'm taking a self-directed course and chose Haskell, and my first goal appears to have been more ambitious than I originally planned since a language where all of the variables are read-only by default was not a thought that ever crossed my head
22:41:43 <EvanR> managing or mitigating the need for state in a large application is a big deal and requires for thought
22:42:10 <dogcat> if you want to write a programming language, managing state will be a major concern
22:42:34 <EvanR> Renard_Chase: indeed for writing the basic code to process data, it takes some practice to re-think how you would do it
22:42:47 <EvanR> and it carries over well to other languages, what you learn 
22:42:56 <EvanR> it simplifies writing local code
22:43:25 <EvanR> but you still might want mutable vars for very efficient isolated algorithms
22:43:52 <EvanR> dogcat: were not talking about that though
22:45:53 <Renard_Chase> I think I'll give the recursion approach a try
22:46:31 <Renard_Chase> Then when I have something working, I'll see if I can get someone to look over it in #haskell-beginners
22:46:41 <dogcat> its true, but working towards understand the RWS monad is a great way to learn how monads work
22:46:48 <EvanR> a lot of cool techniques can be accomplished with recursion
22:46:52 <EvanR> its very easy in haskell
22:46:59 <Renard_Chase> Any tips/
22:47:01 <Renard_Chase> ?*
22:47:01 <lambdabot> Maybe you meant: v @ ? .
22:47:06 <EvanR> though if you get carried away it might be hard to find bugs
22:47:10 <EvanR> like freeze ups
22:47:39 <EvanR> nonetheless its very idiomatic
22:47:56 <Renard_Chase> Well at least it would only be my computer and I don't have to worry about taking out the collage's test server by accident... again
22:48:05 <EvanR> lol
22:49:00 <EvanR> dogcat: monads are interesting... but only a side-show to the full array of FP in haskell
22:49:05 <Renard_Chase> I accidentally used up the application pool (or something like that) trying to debug a certain program... they then increased the limit on it
22:49:14 <Renard_Chase> Anyway, thank you for all of them
22:49:19 <peddie> Renard_Chase: my experience with this channel is that you'll get better answers if you say "I've solved problem X with this code I pasted; is there a more idiomatic/efficient/clean way to solve this problem?"
22:49:20 <Renard_Chase> all of the help*
22:49:36 <Renard_Chase> peddie: Thank you
22:49:36 <dogcat> yea, it's just one structure, and a particularly notorious one
22:49:49 <dogcat> it's first hard thing any weekender will get to
22:50:12 <dogcat> however, the FP style doesn't need monads, and Clojure is a great example of this
22:52:28 <EvanR> clojure makes FP style into torture
22:52:46 <dogcat> I don't get why they don't want SystemF or something like it
22:52:48 <EvanR> recursion limit... thread macros
22:53:05 <EvanR> effects dont fire
22:53:08 <dogcat> Rich Hickey has some great things to say about persistent state and how programs express ideas
22:53:20 <EvanR> he is famous for that
22:53:30 <EvanR> he loves decomplection
22:53:38 <dogcat> but not type systems?
22:54:12 <EvanR> lisp and dynamic people think of types in a totally different way
22:54:27 <EvanR> im only starting to understand it
22:55:34 <dogcat> It's one of the coolest times in the history of computing, the first dedicated attempt to discover what are the practical limits of computation
22:55:41 <dogcat> Lisp and the AI Lab
23:00:36 <uanl> i have no math background and i can't do logic well
23:00:38 <uanl> what would you recommend to do for me to improve?
23:00:54 <dogcat> practice practice practice!
23:01:04 <uanl> besides taht
23:01:22 <cocreature> uanl: improve your haskell or your general math/logic knowledge?
23:01:25 <uanl> you can practice the thing and practice it wrong and then you have to unlearn the wrong things and relearn it the proper way
23:01:56 <uanl> well i'd like a general math logic knowledge because i can not solve logical puzzles to save my life
23:02:50 <cocreature> for haskell I’ve heard very good things about http://haskellbook.com/
23:02:58 <cocreature> not sure about general math knowledge
23:03:35 <zipper> uanl: I am a lot like you.
23:03:44 <zipper> I plan on reading math for comp sci
23:04:19 <dogcat> this notion that some people think they are not math people is unneeded, would you ever tell someone you aren't a reading person?
23:04:29 <dogcat> the reality is, you learn through practice
23:04:35 <cocreature> ^ that
23:04:59 <zipper> dogcat: WOW awesome :)
23:05:08 <zipper> Encouraging
23:05:08 <cocreature> but accompanying that practise by some reading is definitely helpful :)
23:05:30 <Vaelatern> dogcat: One requires a certain rigor of the mind
23:05:43 <dogcat> yea, you have to be able to verify you are right
23:06:07 <dogcat> the idea not practice, but perfect practice makes perfect
23:06:11 <Vaelatern> A 3 year old can tell you he is a reading person. It means a different thing to different people. Math has a baseline.
23:09:49 * hackagebot foldl-transduce 0.5.1.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.5.1.0 (DanielDiazCarrete)
23:10:55 <Peaker> Why does optparse-applicative have such bad errors? :( Is there a better alternative?
23:17:02 <cocreature> Peaker: can’t you specify your own errors using eitherReader or one of the other functions that allows you to specify an error?
23:17:32 <cocreature> or what error messages are you referring to?
23:24:54 * hackagebot base-prelude 0.2 - The most complete prelude formed from only the "base" package  https://hackage.haskell.org/package/base-prelude-0.2 (NikitaVolkov)
23:25:11 <ggVGc> does anyone know of a haskell tool to find use sites of a function, or which files in a project imports a certain module?
23:25:21 <ggVGc> I am using ghc-mod, but don't think it supports this?
23:25:55 <dogcat> grep -nr "function ::" src/
23:26:19 <ggVGc> dogcat: that's not type specific though
23:26:49 <ggVGc> dogcat: also, that find the definition, not the call sites
23:28:44 <liste> ggVGc: for the second question, grep for "import (qualified)? Module.Name" ?
23:29:01 <liste> plus maybe some \s'es
23:29:14 <kadoban> ggVGc: Change the type, see what yells at you.
23:29:48 <ggVGc> yeah, right, I know many workarounds. I was just wondering if there is a tool like ghc-mod that actually does things like this
23:29:54 * hackagebot foldl-transduce-attoparsec 0.2.0.0 - Attoparsec and foldl-transduce integration.  https://hackage.haskell.org/package/foldl-transduce-attoparsec-0.2.0.0 (DanielDiazCarrete)
23:29:55 <Renard_Chase> Ok, quick question. When I try to compile a simple Haskell program it keeps telling me that main@main:Main is defined in multiple files
23:29:55 <ggVGc> specifically to not have to work around it
23:30:01 <ggVGc> thanks anyway
23:32:50 <dogcat> has anyone had problems exporting data in excess of 100BM via Scotty Server as JSON?
23:33:37 <jle`> Renard_Chase: how are you compiling it?
23:33:54 <Renard_Chase> ...Wrong the wrong flags... sorry
23:33:58 <Renard_Chase> With the wrong*
23:34:10 <jle`> what tool are you using to compile?
23:34:21 <Renard_Chase> ghc... I forgot an option
23:34:27 <jle`> ah ok
23:34:45 <Renard_Chase> Though I am now curious why a 33 byte source file results in a 3,455,105 byte exe
23:34:55 <jle`> most of it is the run time system
23:35:03 <jle`> i'm willing to bet that a 66 byte source file produces something similar :)
23:35:11 <Renard_Chase> Fair enough
23:36:18 <`Guest00000> 66 byte source -> 6,910,210 byte exe haha
23:54:55 * hackagebot hasql-optparse-applicative 0.1 - "optparse-applicative" parsers for "hasql"  https://hackage.haskell.org/package/hasql-optparse-applicative-0.1 (NikitaVolkov)
23:59:55 * hackagebot base-prelude 1 - The most complete prelude formed from only the "base" package  https://hackage.haskell.org/package/base-prelude-1 (NikitaVolkov)
