00:01:36 <prati> What do you think about, take those OOP problems and try to solve them in Haskell 
00:01:46 <prati> but the problem is the feedback so that you can learn and improve
00:01:48 <EvanR> sure
00:05:51 <prati> If you are interested, http://stackoverflow.com/questions/1364237/is-there-a-visual-modeling-language-or-style-for-the-functional-programming-para 
00:06:39 <prati> But, It isn't answered properly !
00:07:36 * hackagebot data-inttrie 0.1.2 - A lazy, infinite trie of integers.  https://hackage.haskell.org/package/data-inttrie-0.1.2 (LukePalmer)
00:08:59 <Axman6> hmm, there is definitely someone working on a visual, Haskell like language
00:09:31 <Axman6> there's Viskell: https://github.com/viskell/viskell
00:13:32 <prati> It looks like, a visual programming which is more like Blockly, Scrath
00:13:41 <prati> not a Visual Modeling
00:13:58 <prati> **Scratch
00:17:38 * hackagebot ekg-json 0.1.0.1 - JSON encoding of ekg metrics  https://hackage.haskell.org/package/ekg-json-0.1.0.1 (JohanTibell)
00:17:40 * hackagebot ekg 0.4.0.9 - Remote monitoring of processes  https://hackage.haskell.org/package/ekg-0.4.0.9 (JohanTibell)
00:36:13 <locrian9> Can someone check why this patch isn't working? Original file https://ptpb.pw/4Gdn with this patch https://ptpb.pw/Wey8, and then I'm getting this output https://ptpb.pw/S9xA.
00:42:35 <cocreature> locrian9: you’ll probably get a better answer in #archlinux since this isn’t haskell related
00:42:36 <MarcelineVQ> locrian9: that looks like a PKGBUILD file so try asking in #archlinux, this channel is for the haskell programming language
00:42:45 <MarcelineVQ> dat timing
00:42:55 <cocreature> :)
00:52:39 * hackagebot argon 0.4.1.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.4.1.0 (rubik)
01:04:34 <quuxman> I ran into build errors with `cabal install bindings-glfw` on osx with GHC 7.10.2 and cabal 1.22.7
01:07:08 <quuxman> (hundreds of syntax errors in many header files)
01:07:33 <quuxman> OSX 10.10.4
01:13:24 <mazur> does "static" just mean "guaranteed to terminate"?
01:14:16 <merijn> mazur: In what context?
01:14:19 <phadej> mazur: in which context? probably not
01:14:20 <phadej> :D
01:14:27 <mazur> just an idle question :)
01:15:01 <mazur> i was reading a little bit about erlang, which doesn't necessarily have strong type checking
01:15:17 <phadej> erlang is strong, but not static
01:15:35 <merijn> Strong is an ill-defined word when talking about typing, avoid.
01:16:06 <merijn> Static analysis in general (including static typing) refers to program analysis of facts/properties that ALWAYS hold (they're static)
01:18:01 <merijn> As opposed dynamic analysis which deals with control flow during specific execution traces. For example, "foo b = if b then 1 else 'c'" can't be typed statically, as there isn't one single type that's always valid. Whereas a more complex analysis might prove that "foo is only ever called with True as argument, so "foo :: Bool -> Int" is a valid type"
01:19:45 <mazur> merijn: it's equivalent to a sum type though? Int | Char
01:20:13 <merijn> mazur: If your type system supports such a thing than you could typecheck it statically as a sumtype, yes
01:21:38 <merijn> I'm not really aware of any "mainstream" languages with sum types, though?
01:22:00 <mazur> haskell's not mainstream? :]
01:22:12 <merijn> It is, but haskell doesn't have sumtypes like that
01:22:33 <jle`> swift has them i think, and it's growing :O
01:22:38 <jle`> oh
01:22:44 <jle`> you mean statically inferred sum types?
01:22:48 <jle`> instead of explicit tagged unions?
01:22:51 <merijn> mazur: Additionally, what did you mean by "guaranteed to terminate"?
01:22:52 <merijn> jle`: Yes
01:23:00 <jle`> mhm
01:23:11 <merijn> jle`: Any language with ADTs can do tagged unions
01:23:30 <jle`> at one level i thought you were talking about anonymous sums
01:23:54 <mazur> merijn: decidability
01:23:58 <jle`> but i see now what you mean
01:24:01 <merijn> mazur: Of what?
01:24:14 <merijn> mazur: The type checking of the type checked code?
01:24:32 <jle`> on an unrelated note, i'm sad that the anonymous sum tracs aren't going to be completed in time for ghc 8.0
01:24:41 <mazur> merijn: i was thinking of 'static analysis' in general, but maybe type inference/ type checking as specific instance
01:24:47 <merijn> It is perfectly possible to have a system where type checking is not strongly terminating
01:25:46 <merijn> And type inference isn't guaranteed to terminate either, for example, RankN inference is undecidable and thus not guaranteed to terminate (hence why GHC requires type signatures)
01:26:25 <merijn> This is one of the main limiting factors with the typing developments in GHC, people don't want to break type inference
01:38:11 * hackagebot digestive-functors-aeson 1.1.19 - Run digestive-functors forms against JSON  https://hackage.haskell.org/package/digestive-functors-aeson-1.1.19 (OliverCharles)
01:38:52 <quuxman> yay, installing the latest Haskell Platform fixed my build issue
01:48:24 * hackagebot engine-io 1.2.13 - A Haskell implementation of Engine.IO  https://hackage.haskell.org/package/engine-io-1.2.13 (OliverCharles)
01:48:26 * hackagebot socket-io 1.3.5 -   https://hackage.haskell.org/package/socket-io-1.3.5 (OliverCharles)
02:21:30 <merijn> Is there a zip(With(M)) that fails for differently sized lists?
02:23:54 <Gurkenglas> :t Safe.Exact.zipWithExact
02:23:55 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
02:24:27 <merijn> That type looks wrongs
02:24:36 <Gurkenglas> :t Safe.Exact.zipWithExactMay
02:24:38 <lambdabot> (a -> b -> c) -> [a] -> [b] -> Maybe [c]
02:25:44 <merijn> Ugh, hackage is slow again
02:28:25 * hackagebot pagerduty 0.0.6 - Client library for PagerDuty Integration and REST APIs.  https://hackage.haskell.org/package/pagerduty-0.0.6 (BrendanHay)
02:49:12 <merijn> hmmm
02:50:10 <merijn> So I'm trying to implement System F_omega as described in the Henk paper by SPJ and Erik Meijer, but they seem to rather gloss over how the hell type checking for ADTs is supposed to work?
02:51:10 <merijn> And I keep getting stuck...
02:52:32 <merijn> Suppose I have the code http://lpaste.net/152006
02:53:07 <merijn> Actually, lemme change that a bit
02:53:45 <merijn> http://lpaste.net/152006
02:54:24 <merijn> Computing the type of 'p' is easy (just substitute variables with their types), but I'm having a hard time with correctly constraining type variables in patterns...
02:55:34 <merijn> Because, given that I know the pattern "Proxy x" should match the type "ProxyT UnitT" I can't seem to manage a way to find out how I should constrain x's type in my checker...
02:56:30 <merijn> Basically, I don't know how to "unfold" the result type of an ADT to it's corresponding arguments
02:57:23 <mazur> i'm trying to install idris with cabal, and it wants an older version of comonad (says it will break lens,linear)? do i need to build and install from the idris github repo instead?
03:00:41 <liste> mazur: are you installing it globally or in a sandbox?
03:00:51 <mazur> liste: globally
03:01:03 <liste> you could try a sandbox
03:18:27 * hackagebot free-vl 0.1.4 - van Laarhoven encoded Free Monad with Extensible Effects  https://hackage.haskell.org/package/free-vl-0.1.4 (aaronlevin)
03:28:30 * hackagebot clash-prelude 0.10.6 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.6 (ChristiaanBaaij)
03:33:30 * hackagebot clash-lib 0.6.10 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.10 (ChristiaanBaaij)
03:33:32 * hackagebot clash-vhdl 0.6.7 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.7 (ChristiaanBaaij)
03:33:35 * hackagebot clash-ghc 0.6.10 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.10 (ChristiaanBaaij)
04:11:09 <Gurkenglas> @letlpaste 151726
04:11:10 <lambdabot>  Parse failed: Parse error: ;
04:11:21 <Gurkenglas> What's this? I didnt even use a semicolon! http://lpaste.net/151726
04:12:20 <lpaste> Gurkenglas revised “A class that generalizes mtl's classes and an improper monad transformer that generalizes MaybeT and ListT”: “No title” at http://lpaste.net/151726
04:12:54 <Gurkenglas> Whoops, it's still set to post to channel. Just fixed a comment.
04:12:55 <frerich> Gurkenglas: I think there's a ")" missing in the "pure x = ..." line
04:13:02 <frerich> Gurkenglas: line 6
04:13:15 <Gurkenglas> Thanks.
04:13:27 <frerich> Gurkenglas: Maybe your compiler borrowed automatic semicolon insertion from JavaScript.
04:13:39 <Gurkenglas> Only @letlpaste used
04:14:25 <lpaste> Gurkenglas revised “A class that generalizes mtl's classes and an improper monad transformer that generalizes MaybeT and ListT”: “No title” at http://lpaste.net/151726
04:14:33 <frerich> Hm, then maybe there's an injection attack somewhere in here if it's just @letlpaste falling over that  ;->
04:14:50 <Gurkenglas> Oh, it reactivates itself on each edit according to whether I originally made it post to a channel? I'll move to another paste.
04:15:25 <Gurkenglas> I didn't say local compilers wouldn't fail, I meant I only gave this code to letlpaste
04:15:35 <Gurkenglas> Because setting up Haskell locally is hard.
04:25:18 <Gurkenglas> Can we make lambdabot funnel its output to a paste site?
04:25:36 <merijn> Gurkenglas: For what reason?
04:25:54 <Gurkenglas> So I can read type errors without waiting for the @more cooldown
04:36:06 <anakreonm> ghc 7.10.3 crashes frequently when I use it from within emacs in Windows. Is this a known problem or should I file a bug report? I have the crash dump file.
04:41:56 <safrol> ewww anakreonm You could just use linux. Orrrrr..... file a bug report.... Idk really. Sorry for the response. BUT we'd be happy to know more about that crash dump file
04:47:17 <anakreonm> Thank you safrol. Unfortunately I can't choose the OS. I'll file a bug report
04:53:28 <safrol> Sure thing anakreonm :)
04:53:33 * hackagebot gore-and-ash-network 1.2.1.0 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.2.1.0 (NCrashed)
04:59:12 <anakreonm> It's quite hard actually to file a bug report. Username guest doesn't work and I had to register to discover that I lack credentials for filing a bug report. have
04:59:17 <anakreonm> "TICKET_CREATE privileges are required to perform this operation on Ticket #None. You don't have the required permissions."
05:01:56 <Gurkenglas> What's the intersection of Traversable and Applicative called?
05:03:13 <Gurkenglas> @letlpaste 5640768261382471680
05:03:14 <lambdabot>  .L.hs:211:10:
05:03:14 <lambdabot>      Could not deduce (Monoid w)
05:03:14 <lambdabot>        arising from the superclasses of an instance declaration
05:03:32 <Gurkenglas> Wait what it just said "Parse failed: Parse error: <!" :(
05:03:48 * hackagebot gore-and-ash-logging 1.1.1.0 - Core module for gore-and-ash with logging utilities  https://hackage.haskell.org/package/gore-and-ash-logging-1.1.1.0 (NCrashed)
05:04:11 <balor> If a package is on hackage then is it in cabal?  Am having problems resolving `neks` dependency https://hackage.haskell.org/package/Neks even without using stack.
05:05:20 <ChristianS> balor: case matters, so you want Neks
05:05:34 <balor> ChristianS, Thanks...wasn't aware of that.
05:08:48 * hackagebot gore-and-ash-actor 1.1.1.0 - Gore&Ash engine extension that implements actor style of programming  https://hackage.haskell.org/package/gore-and-ash-actor-1.1.1.0 (NCrashed)
05:12:40 <balor> hmmm...looks like I'll be better off using acid-state at any rate.  Great example at http://www.stephendiehl.com/posts/haskell_web.html
05:13:56 * hackagebot gore-and-ash-async 1.0.1.0 - Core module for Gore&Ash engine that embeds async IO actions into game loop.  https://hackage.haskell.org/package/gore-and-ash-async-1.0.1.0 (NCrashed)
05:18:44 <Wizek> Anyone know if/how I could have multiple versions of a local library available to be installed via `cabal`/`stack` without having it uploaded to Hackage? Some more background on my question: https://gist.github.com/Wizek/4858f5a9460256baf696
05:20:01 <martinvlk> Wizek, would "cabal sandbox add-source" do for you? That will make a local source project available to your sandbox.
05:21:01 <Wizek> martinvlk, You mean to add a local folder? Wouldn't that only one version of that lib is available at all times?
05:21:20 <dcoutts> Wizek: you can have the tarballs of your various versions and "cabal sandbox add-source" the tarball into your sandbox
05:21:57 <dcoutts> Wizek: ie you have the local folder of the latest version of that lib, but you also keep a dir of tarballs of the older versions
05:22:21 <Wizek> hmmm, that is an interesting proposition
05:22:45 * dcoutts notes that with the next-gen version of cabal, that'd also share the built versions when possible
05:23:21 <Wizek> okay, let me try this. Do you think this also works with stack.yaml's `other-deps` field?
05:23:44 <dcoutts> Wizek: not sure if it supports tarballs
05:23:48 <dcoutts> probably
05:24:15 <dcoutts> Wizek: stack also supports git snapshots
05:24:52 <Wizek> What do you refer to as git snapshots?
05:25:20 <dcoutts> Wizek: git hashes identifying a particular state of a repo
05:25:34 <dcoutts> Wizek: of course you can achieve the same by using git submodules or subtrees
05:26:24 <dcoutts> ie the project that uses the lib can either have the head of the lib as a git submodule/subtree, or it can require an older state of the lib's repo
05:26:58 <dcoutts> Wizek: and then you just use that local dir in the sandbox/project
05:30:51 <Wizek> Hmm, do you mean I could specify the hash somewhing like this? `packages: ['/path/to/local-dep#abcdef123']`
05:38:57 * hackagebot gore-and-ash-sync 1.1.1.0 - Gore&Ash module for high level network synchronization  https://hackage.haskell.org/package/gore-and-ash-sync-1.1.1.0 (NCrashed)
05:41:27 <Stan_> Hello, has someone experience with the zeromq4 module?
05:41:28 <e-user> Why can't I make a function `foo n = sum [x + 0.5 | x <- [n, n - 2 .. 0], x > 0] * n * 2` that complies with a type signature of `Integer -> Integer`? I'm always getting "No instance for (Fractional Integer) arising from the literal ‘0.5’"
05:42:02 <pavonia> e-user: 0.5 can't be an Integer
05:42:11 <Stan_> 0.5 is floating point
05:42:25 <e-user> pavonia: OK, I get that. I was trying all kind of stuff to convert x to a fractional, but no luck
05:43:04 <mchall_> I've got to  http://mightybyte.github.io/monad-challenges/pages/ex4-2.html where it asks you to "Also try reimplementing repRandom in terms of generalA, genTwo, and mkGen." My code so far http://lpaste.net/152018
05:43:07 <frerich> pavonia: You could use 'round' on the result of 'sum'.
05:43:08 <mchall_> I get the correct seed value but it doesn't collect the [a] 's and I end up with an empty list. How do I use generalA in repRandom ?
05:43:38 <frerich> pavonia: Sorry, wrong recipient :-)
05:43:46 <frerich> e-user: You could use 'round' on the whole product.
05:44:01 <pavonia> Yup, but still doesn't work if x is an Integer
05:44:08 <e-user> frerich: Tried before, it gives me an additional error instead: "No instance for (RealFrac Integer) arising from a use of ‘round’"
05:44:28 <pavonia> :t fromInteger 123 :: Double
05:44:29 <lambdabot> Double
05:45:09 <pavonia> > fromInteger 123 + 0.5
05:45:11 <lambdabot>  123.5
05:45:25 <frerich> e-user: Oh yeah, you'll need to use 'fromInteger' on your 'x' and then something like 'round' on the resulting product.
05:46:07 <e-user> `round $ sum [fromInteger x + 0.5 | x <- [n, n - 2 .. 0], x > 0] * n * 2` keeps both errors, no change
05:48:14 <saurabhnanda> hello good people. I've moved away from my philosophical questions to more practical stuff. That of completing my side project.
05:48:43 <saurabhnanda> Wrt that, here's a questions -- it is possible to export a record constructor BUT hide the accessors?
05:48:56 <saurabhnanda> data NightwatchCommand = InvalidCommand | DownloadCommand { url :: String } | PauseCommand { gid :: String } | UnpauseCommand { gid :: String } | StatusCommand { gid :: String } deriving (Show, Eq)
05:49:28 <saurabhnanda> I want other modules to be able to use DownloadCommand {url="something"} BUT not call (url cmd) because of partial function problem
05:49:33 <Stan_> #zmq
05:50:03 <e-user> OK, `round (sum [fromInteger x + 0.5 | x <- [n, n - 2 .. 0], x > 0]) * n * 2` works with just a warning. Thank you guys
05:51:05 <shanemikel> what is the most idiomatic reactive or functional reactive gui library?
05:51:46 <Wizek> dcoutts, do you mean I could specify the hash something like this? `packages: ['/path/to/local-dep#abcdef123']`
05:52:39 <dcoutts> Wizek: if you mean stack files, no, there's some special syntax. Or use git subtrees
05:55:42 <srhb> shanemikel: I _think_ that none of the very used FRP libraries are very idiomatic, according to the authorative source. :-)
05:55:53 <srhb> (But I'm no expert on FRP)
05:56:49 <shanemikel> have you been able to install ghcjs?
05:56:55 <shanemikel> I keep failing on ghcjs-boot
05:57:22 <martinvlk> shanemikel: I did it successfully, what's the issue?
05:58:35 <shanemikel> hold on, it'll take me a few minutes to get to the error again :(
06:00:40 <shanemikel> did you build it in a sandbox?
06:00:51 <shanemikel> and did you do the git repo, or a tarball?
06:00:55 <ddburnsuidown> Hello
06:01:20 <ddburnsuidown> Anyone ONLINE?
06:01:32 <ddburnsuidown> Say "YES" if you are con
06:01:42 <ddburnsuidown> Waiting...
06:01:50 <shanemikel> hi
06:01:57 <ddburnsuidown> hello
06:02:18 <martinvlk> shanemikel, I did it in a sandbox allright
06:02:29 <ddburnsuidown> shanemike1 can you donate to  me?
06:02:33 <ddburnsuidown> Need donations
06:02:45 <shanemikel> op?
06:03:31 <martinvlk> shanemikel: there was one gotcha there that after installing and before running ghcjs-boot, you have to set the PATH to the sandbox bin directory
06:03:39 <saurabhnanda> can I define a chanell using a typeclass? eg. type MyChannel = Chan MyTypeClass ?
06:03:45 <ddburnsuidown> http://gogetfunding.com/evolve/ Please donate
06:03:58 <martinvlk> shanemikel: and it has to be an absolute path, not relative
06:04:15 <shanemikel> did you do `ghcjs-boot --dev --ghcjs-boot-dev-branch somebranch --shims-dev-branch`, `ghcjs-boot --dev` or just plain-ol `ghcjs-boot` ?
06:04:16 <ddburnsuidown> martin1k: will you?
06:04:38 <martinvlk> shanemikel: plain ghcjs-boot
06:05:03 <shanemikel> somebody ping an op for thid ddburnsuidown guy
06:05:39 <ddburnsuidown> k what is "ping an op"
06:07:30 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:31 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:32 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:33 <ddburnsuidown> http://goget.fund/20Ld2Dwhttp://goget.fund/20Ld2Dw
06:07:34 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:36 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:39 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:41 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:44 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:07:45 <cocreature> @where op
06:07:45 <lambdabot> I know nothing about op.
06:07:46 <ddburnsuidown> http://goget.fund/20Ld2Dw
06:08:44 <shanemikel> @where ops
06:08:45 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
06:08:49 --- mode: ChanServ set +o dcoutts
06:08:56 --- mode: ChanServ set -o dcoutts
06:08:57 <shanemikel> ping conal
06:09:16 <dcoutts> shanemikel: freenode's auto stuff is pretty quick :-)
06:22:53 <shanemikel> is it safe to do multiple cabal installs at once (in two different sandboxes)
06:29:23 <bollu> when I'm writing a library, how do I expose a newtype constructor and pattern match?
06:29:29 <bergmark> shanemikel: afaik yes, i've done it lots of times but it never caused any issues
06:29:52 <bollu> for some reason, I'm not able to destructure my newtype on the API user end
06:30:09 <bergmark> bollu: module Foo (MyNewType (MyNewTypeConstructor)) where
06:30:18 <bollu> bergey: oh thanks :)
06:30:41 <martinvlk> shanemikel: I think it's module MyModule ( MyNewtype(..) )
06:31:17 <martinvlk> shanemikel: sorry, that was meant for bollu
06:32:53 <bollu> how do I profile haskell programs?
06:33:23 <adamCS> bollu: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
06:33:31 <bollu> ooh, thanks
06:33:52 <adamCS> bollu: np
06:34:47 <bergmark> bollu: the profiling chapter in real world haskell is good
06:36:56 <Stan_> when I'm on a windows system and try to install a module like "cabal install zeromq4-haskell --extra-include-dir=..."  what is the format to write the path ? Is it "C:\\include", "C:\include" or C:\include ?
06:37:49 <dcoutts> Stan_: if it includes spaces you need the "", but you don't need \\
06:37:58 <dcoutts> or in other words, option b
06:38:42 <Stan_> dcoutts: Thanks!
06:44:00 * hackagebot gore-and-ash-network 1.2.2.0 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.2.2.0 (NCrashed)
06:59:00 * hackagebot yesod-auth-oauth2 0.1.7 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.7 (PatrickBrisbin)
07:00:13 <badmash> hey
07:02:19 <badmash> i set up haskell-mode + ghc-mod in emacs running on OS X Yosemite, but the ghc-mod cmmand M-t doesn't for function body completions.  it simply says "Nothing to be done".  any ideas what could be wrong?
07:06:26 <badmash> appreciate any help
07:08:49 <Schrostfutz> hi, I currently do this tutorial: https://wiki.haskell.org/Learn_Haskell_in_10_minutes in section 6 the line where factorial is defined does not work when entering it directly into ghci, when saved as a haskell file it works however, why is that? (the error is a parse error on '=') 
07:09:29 <bollu> Schrostfutz: try let factorial n = ...
07:09:30 <monochrom> ghci wants you to prepend "let " for definitions
07:09:44 <Schrostfutz> bollu, monochrom: ah, thank you!
07:09:54 <bollu> np :)
07:17:54 <nitrix> Schrostfutz: I don't want to be rude considering we don't know each others and maybe that's the ideal perfect way to go and learn about things, but in my book, you should stay away from teaching material that says "Learn X in Y units of time". There's no need to rush learning Haskell and you'll just hit a wall harder at some point.
07:18:53 <MarcelineVQ> How's the content though?
07:19:46 <Schrostfutz> nitrix: I totally understand your concern. However I do have programming experience in other languages and even looked into haskell a while ago. I just had a bit of time and wanted to get a impression of what the syntax is like so I figured I'll just go through it to get an idea about it.
07:20:04 <nitrix> Schrostfutz: :)
07:21:27 <liste> Schrostfutz: that `factorial' is a top-level function definition; the stuff you input into GHCi is more akin to a do block
07:21:38 <liste> try "let factorial n = ..."
07:23:22 <nitrix> I find the do block explanation mediocre. GHCI is a REPL, so it needs to be a valid expression to be read-evaluated-printed.
07:25:34 <shanemikel> do you need let with :{ ?
07:25:50 <Phlogistique> nitrix: well, you can type "foo <- return 3" in GHCI
07:26:08 <Phlogistique> shanemikel: usually you don't, but in GHC it can be useful
07:26:32 <Phlogistique> in most real code indentation is used instead of {;}
07:26:43 <Phlogistique> s/GHC/GHCi/
07:28:52 <nitrix> Phlogistique: foo <- return 3 is the expression return 3 >>= (\foo -> ...)
07:29:22 <Phlogistique> well, you can't really have "..." in an expression
07:29:24 <mnoonan> nitrix: ..but then why is foo in scope for the next repl input?
07:29:26 <Phlogistique> if you see what I mean
07:31:08 <nitrix> mnoonan: Because the repl preserves the scope between commands, but it wouldn't have to to be a correct repl.
07:33:35 <mjhoy> is there any difference in terms of debugging between throwing `trace` calls in a State monad, with having io puts statements in StateT over IO?
07:33:42 <nitrix> To proove my point, start GHCI and write return (), then return 5, then return Just 3.
07:34:02 <nitrix> Suddently you see that it cannot be thought as a do block as the three returns would have incompatible types.
07:35:16 <merijn> mjhoy: Yes, trace is lazy and repeated evaluation might result in only one print
07:35:34 <merijn> mjhoy: putStr would be more reliable if you're already in IO
07:35:55 <mjhoy> merijn: is there a way to force trace to be strict?
07:36:36 <merijn> mjhoy: The problem is that even a strict trace would only print once, since you're lying about purity
07:36:49 <mjhoy> ah.
07:37:05 <mjhoy> i'm not already in IO, wondering if i should add it just for that
07:37:55 <mjhoy> but if i associate (one) trace call with a state get or puts and that should be ok mostly in terms of laziness?
07:44:37 <merijn> mjhoy: In general trace is ok, if you're aware that funky optimisations might move them around
07:45:52 <csd_> what's a good introductory paper introducing the ideas behind the lens library
07:46:42 <merijn> csd_: If you're somewhat comfortable with, e.g. the Identity and Const newtypes you can watch edward's youtube talk
07:46:45 <merijn> @where lens
07:46:45 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
07:46:48 <merijn> That last one
07:47:36 <csd_> merijn: anything written? it tends to stick with me better
07:47:52 <csd_> also, i'm not familiar with those types :)
07:49:02 * hackagebot remote-json-server 0.2.0.1 - Web server wrapper for remote-json  https://hackage.haskell.org/package/remote-json-server-0.2.0.1 (AndyGill)
07:49:24 <merijn> csd_: "newtype Identity a = Identity { runIdentity :: a }" and "newtype Const k a = Const k"
07:50:16 <csd_> seems sensible
07:52:20 <mjhoy> i'm playing with my first monad transformer stack... and it feels like object oriented programming, suddenly! should i be worried?
07:52:30 <merijn> mjhoy: Why?
07:53:01 <mjhoy> merijn: complex state interactions, etc
07:53:11 <mnoonan> nitrix: I'm almost convinced by that argument, except then I would expect to be able to write "x <- Just 3" in ghci
07:53:29 <srhb> mnoonan: You are.
07:53:33 <srhb> (almost)
07:53:41 <srhb> :-)
07:53:53 <mnoonan> "couldn't match expected type 'IO t0' with actual type 'Maybe Integer'"
07:54:10 <nitrix> IO t0, fancy.
07:54:11 <merijn> mjhoy: How are there any complex state interactions? Everything is still immutable
07:54:15 <nitrix> So I was wrong then.
07:54:17 <srhb> Right righht, it's always IO.
07:54:47 <mjhoy> merijn: i guess it's just that i have a lot of M () functions (where M is my monad with state)
07:55:33 <nitrix> > x <- _
07:55:34 <lambdabot>  <no location info>: not an expression: ‘x <- _’
07:55:55 <merijn> mjhoy: Sure, if you need the state for your computation, there's no avoiding that. But it's actually surprisingly limited in scope. Suppose you have multiple threads running in your program, you know for a fact none of them can influence each other's state :)
07:56:26 <nitrix> lambdabot seems to act more like the type of repl I'd expect.
07:56:30 <nitrix> (Expression based)
07:56:48 <mjhoy> merijn: so perhaps it feels like OO programing but only because i'm not trying to do crazy things at the moment.
07:57:16 <nitrix> mnoonan: thanks
07:58:10 <MrTrump> anyone using happstack?
08:01:01 <merijn> hmmm, is lpaste down?
08:01:30 <geekosaur> it seems to return a lot of "backend too slow, I must be down" a lot of late
08:02:16 <mjhoy> merijn: it is interesting moving from (s1, s2, ...) -> (s1', s2', ...) functions (explicitly passing state) to M () functions, though.
08:03:25 <Cale> mjhoy: You pay a lot in terms of convenience for the first monad transformer you apply to IO, because you give up all the higher order things related to IO such as forkIO and catch, and it's awkward to get them back. It takes a lot of work to make the use of monad transformers really count for something most of the time.
08:04:00 <crough> Cale: MonadBaseControl alleviates a lot of that in the long run
08:04:21 <Cale> crough: Yeah... but it's not exactly possible to describe that as not awkward :D
08:04:34 <crough> Haha it's the most awkward typeclass I can think of
08:04:35 <merijn> MonadBaseControl is super awkward
08:04:37 <mjhoy> Cale: for me now it seems to make refactoring nice. I use Monad.Control.Random and State
08:04:53 <mjhoy> err Control.Monad.Random
08:05:00 <merijn> I think mjhoy is just using State, not even transformers
08:05:10 <Cale> oh
08:05:24 <mjhoy> merijn: just random over state (Which is stateT over identity? i don't know too much about this)
08:05:27 <merijn> mjhoy: In which case, State is literally just syntactic sugar for explicitly passing state arguments, but without all the chance to mess up
08:05:41 <Cale> mjhoy: ahhh, okay
08:05:50 <merijn> mjhoy: The best way to learn is to reimplement them yourself! https://gist.github.com/merijn/098106abd45c940dab09
08:05:52 <Cale> mjhoy: Yeah, that's fine
08:07:23 <mjhoy> i'm VERY new to monads and transformers. i wanted to reimplement an algorithm which passed state explicity to one using the state monad.
08:07:35 <mjhoy> i might try to get my algorithm working first, and then implement that merijn
08:07:38 <merijn> mjhoy: Especially if you used "(s1, s2, ...) -> (s1', s2', ...)" it should be fairly easy
08:08:30 <merijn> (Fairly easy being: "Upto 2 days of frustration and staring at it confusedly, followed by infinity time spend wondering why you ever thought it was hard before you implemented it"
08:09:12 <mjhoy> merijn: for me and haskell, yep :)
08:09:22 <mniip> so uh
08:09:31 <mniip> how does Control.Lens.Prism work
08:09:42 <merijn> mniip: Pixie dust and magic
08:09:49 <mniip> I mean shachaf (?) showed that it is dual of Lens
08:10:02 <mniip> but how does the type line up with that of Traversal
08:11:36 <Elision> okay, can someone explain to me exactly what's going on here? (content warning: kinds) http://pastebin.com/raw/KU0xnuXS
08:11:43 <glguy> mniip: type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
08:11:47 <glguy> replace the p with (->)
08:11:59 <glguy> (There is an instance Choice (->))
08:12:03 <mniip> ok now what's Choice
08:12:09 <Elision> everything except the application "g undefined" makes sense to me
08:12:23 <glguy> https://hackage.haskell.org/package/lens-4.13.2/docs/Control-Lens-Prism.html#t:Choice
08:12:33 <Elision> why can I use undefined there as an unlifted type :?
08:12:37 <mniip> Elision, because undefined is levity-polymorphic and m is not
08:12:56 <mniip> it was hidden from the user and it's been made visible in GHC 8.0
08:12:58 <Elision> mniip: but how does it make any sense to have 'unlifted undefined'?
08:13:09 <Elision> isn't the point of unlifted to not contain bottom
08:13:10 <mniip> Elision, unlifted errors are a thing
08:14:06 <merijn> Elision: What is unlifted division by 0 if not bottom?
08:15:13 <Elision> merijn: that just sounds like the type of division shouldn't result in something unlifted...
08:15:50 <merijn> Elision: So you're proposing we ban "div# :: Int# -> Int# -> Int#"?
08:15:56 <Cale> I'm rather curious what use case spurred on the development of levity polymorphism
08:16:10 <Elision> merijn: I admit it sounds like a huge pain to work with
08:16:21 <merijn> Cale: Cleaning up the closet (eh, kind system?) :p
08:16:29 <Elision> (fwiw Int# -> Int# -> Maybe Int# would also work :p)
08:16:49 <mpickering> Cale: from the HIW video is just seemed motivated by getting rid of internal compiler magic (ie OpenKind)
08:16:51 <Elision> so there's just, what, lifted and sorta-lifted types?
08:17:06 <Cale> mpickering: hm, I suppose I have to see that talk :)
08:17:42 <MrTrump> is darcs better than git?
08:18:08 <Cale> MrTrump: I like its UI a lot better, but only few people use it, sadly.
08:18:19 <Elision> mniip: also, if it's levity-polymorphic, why does the last line /not/ type check?
08:18:25 <Cale> MrTrump: Git has the definite advantage that everyone else is using it.
08:18:29 <mniip> Elision, because m is not
08:18:34 <MrTrump> whch is easier
08:18:37 <MrTrump> I ginf git a pain
08:18:40 <mniip> you cannot create levity-polymorphic functions outside GHC 8.0
08:18:43 <MrTrump> I find git a pain
08:18:52 <MrTrump> everyone trying to keep ansible files updated
08:18:56 <MrTrump> and its chaos
08:18:59 <Elision> mniip: the last line is "undefined :: GHC.Prim.Int#"
08:19:01 <merijn> Cale: I use mercurial so I get the nicer UI with git interoperability ;)
08:19:02 <MrTrump> I say use bash forget ansible
08:19:05 <mniip> oh that
08:19:15 <mniip> Elision, you tried to print it?
08:19:24 <Elision> oh.
08:19:25 <mpickering> mniip: You can create levity polymorphic functions in user-land?
08:19:27 <merijn> Elision: Monomorphism restriction? :)
08:19:28 <Elision> that's not undefined failing, it's Show
08:19:30 <mniip> mpickering, in 8.0
08:19:32 <Elision> whup
08:19:35 <sm> MrTrump: darcs is easier for basic/moderate tasks
08:19:37 <mpickering> mniip: how :) ?
08:19:46 <shanemikel> so, can somebody explain the ghcjs-pkg.. I have stuff installed in a cabal sandbox.. and ghcjs is compiling now, but I can't figure out how to compile the dependent libs
08:20:12 <merijn> shanemikel: I think there's a #ghcjs might be more knowledgeable people that
08:20:26 <mniip> fancyCompose :: forall (w :: Levity) (c :: TYPE w). (b -> c) -> (a -> b) -> a -> c
08:20:32 <mniip> fancyCompose f g x = f (g x)
08:20:34 <mniip> simple as that
08:20:52 <merijn> :t (Control.Category..) --what, haskell scary?
08:20:53 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
08:20:55 <Cale> shanemikel: Well, ghcjs-pkg is just like ghc-pkg, but it manipulates your ghcjs package database rather than ghc's.
08:21:11 <greg`> ologs?
08:21:19 <Elision> haaayeeek that's sure a signature
08:21:58 <MrTrump> all i need is basic
08:22:01 <lifter> I'm new to Haskell web programming and I've been playing around w/ Servant. Does anyone know about threading in servant? I'm wondering if the handler functions I've defined for my endpoints are all running on the same thread or what
08:22:10 <Elision> thanks mniip, merijn, makes a little more sense now
08:22:18 <MrTrump> servant? what about happstack.com ?
08:24:11 <lifter> MrTrump: I don't know.
08:24:31 <shanemikel> do you know how to tell ghcjs to look in the cabal-sandbox for deps?
08:25:41 <o`connor> In nix, should I use "haskell.packages" "haskellngPackages" or "haskellPackages"?
08:26:29 <dedgrant> Hmm.. what primitive kinds exist as of ghc-8?  *, #, Levity, TYPE, BOX, Symbol, Nat?
08:26:54 <dedgrant> (->)?
08:27:12 <dedgrant> (Is that even the right question now?)
08:27:57 <merijn> dedgrant: With DataKinds you can create your own kinds :)
08:28:21 <merijn> TYPE is a replacement/new name for *, I think
08:28:36 <merijn> BOX is not a kind, but a sort
08:28:37 <mniip> dedgrant, * and # are not primitive
08:28:43 <mniip> BOX is gone, no?
08:28:48 <dedgrant> Oh that's interesting
08:28:50 <mniip>  Levity is just promoted
08:28:51 <merijn> mniip: I think so?
08:29:05 <dedgrant> (Did not know BOX was a sort)
08:29:07 <mniip> Levity is no different from Bool
08:29:11 <merijn> dedgrant: types are to values, as kinds are to types, as sorts are to kinds
08:29:30 <merijn> Except "Type in Type" just short circuits the hierarchy
08:29:31 <MrTrump> is haskell really better?
08:29:37 <MrTrump> less code more work done?
08:29:41 <mniip> also TYPE is questionably primitive
08:30:12 <mniip> it is wired-in I guess, because all datas get a TYPE Lifted kind
08:30:17 <sm> lifter: #servant will know
08:30:23 <mniip> but it has a definition
08:30:33 <lifter> sm: oh thanks!
08:32:09 <sm> MrTrump: code is not always shorter than eg ruby or python
08:32:25 <sm> but it tends to be more correct and much easier to maintain as it grows larger
08:33:19 <liste> so, in the long run, less time more work done
08:34:46 <sm> yep
08:35:48 <dedgrant> mniip: What is the definition?  I'm sort of curious following the mailing list but not really comprehending. Really curious about how the specific choices skirt russel's paradox.
08:35:56 <dedgrant> (assuming I can spell)
08:36:12 <mniip> data TYPE (a :: Levity)
08:36:17 <mniip> definition ^
08:36:22 <dedgrant> Neat
08:37:34 <MrTrump> :)
08:37:41 <MrTrump> lless work more output!!
08:37:45 <MrTrump> I like that!
08:38:02 <sm> also, encourages more rigorous thought, allowing tougher problems to be tackled
08:38:37 <mniip> none of my friends believe in haskell :(
08:38:45 <sm> but mainly we like it because it's fast :)
08:38:58 * sm semi-joking
08:44:35 <Deithrian> Can't believe there are 1.5k people here and on every video I watch about haskell they say no one uses it :)
08:44:41 <Cale> Deithrian: heh
08:44:41 <dedgrant> "We should never have a levity-polymorphic type to the left of an arrow." -- https://ghc.haskell.org/trac/ghc/ticket/11473  .. trying to understand why.
08:45:42 <mniip> dedgrant, because the runtime wouldn't know how to pass a polymorphic unboxed type
08:45:46 <Cale> Deithrian: Well, it's not as big in terms of commercial use as some languages. But there are people and companies using Haskell in production now.
08:45:49 <mniip> as it has varying width and all that
08:46:05 <dedgrant> mniip: Ah that makes sense!
08:46:55 <Cale> Deithrian: For example, the company I work for, Obsidian Systems, is developing web applications end-to-end in Haskell for clients. (Using Reflex.DOM and GHCJS on the frontend, and typically Snap on the backend)
08:47:35 <Deithrian> Cale, I just expected there will be at most 50 people on IRC... at least that's the expression I got from the youtube clips I saw.
08:48:45 <Cale> Deithrian: 50 people was closer to where it was when I joined the channel back in 2003 or something.
08:49:21 <Cale> It's been quite some time since Haskell was *that* small :)
08:49:42 <crough> IRC usage is declining as a whole but this channel has been growing crazy quickly. It helps that we have a good appearance :)
08:50:06 <Deithrian> Cale, well it's great that the community is so large, maybe people should stop saying those diminishing things about the language on presentations :)
08:50:40 <Cale> Actually, maybe it was even earlier that I joined... it seems these logs I'm looking at are cut off. I was already quite a confident Haskell user by that point.
08:50:45 <Cale> 2002?
08:50:47 <Cale> :)
08:51:37 <Deithrian> Cale, lucky you, I'm just starting, both with programming and Haskell, so it's going to be fun :)
08:51:43 <Cale> Deithrian: Well, sure... "avoid success at all costs" is still part of the culture of Haskell, even if we're failing miserably at it though.
08:51:58 <Deithrian> :D
08:53:04 <Deithrian> Can I ask as general information, is there a strategy for Haskell that's as good as OTP for Erlang, or something similar? I saw the Cloud Haskel, but as a newb I'm not able to tell if it's a good solution or not?
08:53:22 <MrTrump> happstack.com
08:54:15 <Cale> Cloud Haskell directly steals a lot of Erlang's approach to distributed concurrency (well, it steals the semantics that Erlang people think Erlang ought to have had really)
08:54:41 <Deithrian> Thanks a lot MrTrump, congrats on your victory ;)
08:55:11 <Cale> But it doesn't yet have all the same things built on top of it... I think because it's just there aren't so many users which really need that sort of thing, and probably a few of those who do are proprietary.
08:55:26 <MrTrump> We are guna make American great again.
08:55:30 <MrTrump> We are guna win so much.
08:55:34 <merijn> ugh...was there a way to get a stacktrace from partial Prelude functions?
08:55:50 <MrTrump> :)
08:55:53 <Deithrian> Indeed MrTrump :D
08:56:09 <merijn> Deithrian: Simon Marlow has pointed out that people bracket the "avoid success at all cost" wrong
08:56:09 <Cale> merijn: You can try compiling with profiling on, and run with +RTS -xc
08:56:36 <merijn> Deithrian: i.e. it's "avoid (success at all cost)", not "(avoid success) at all cost"
08:56:46 <Cale> merijn: I think it's a bit of both
08:57:05 <merijn> Cale: I'll try that
08:57:16 <Deithrian> Thanks for the information, I thought that something like OTP can provide great help for a beginner like me. It's good to know there's similar things for Haskell.
08:57:17 <Cale> There's an extent to which success makes it difficult for a language to continue improving.
08:57:29 <merijn> I should probably cleanup and refactor my code first
08:57:35 <merijn> It's a huge mess of traceM atm
08:58:23 <Deithrian> merijn, I very much liked it when people talked about how the community is constantly trying to find the best solution for a problem, that sounds great :)
08:59:05 * hackagebot gore-and-ash-sdl 2.0.0.0 - Gore&Ash core module for integration with SDL library  https://hackage.haskell.org/package/gore-and-ash-sdl-2.0.0.0 (NCrashed)
08:59:37 <dedgrant> Deithrian: Never before have I seen so many computer scientists and engineers come together so productively. It's really unique.
09:01:35 <MrTrump> We are guna build a wall, so strong.
09:01:49 <MrTrump> so darcs is easier than git?
09:01:50 <glguy> MrTrump: Please stay on topic
09:01:51 <MrTrump> NICE
09:01:56 <glguy> Do you have a question about Haskell?
09:01:58 <Deithrian> dedgrant, gear to hear!
09:02:09 <MrTrump> what happens when you have different files than me and we both upload in darcs?
09:02:13 <MrTrump> or do i pll from you?
09:02:22 <MrTrump> like what happens?
09:02:23 <sm> MrTrump: #darcs is a good place for that
09:03:11 <sm> another the darcs questions, I mean. Not the trumping :)
09:03:24 <MrTrump> ok back to web aps
09:03:29 <Deithrian> dedgrant, great* to hear! No idea how I ended up typing gear lol
09:03:32 <MrTrump> happstack.com  whos usign it
09:03:41 <alpounet> hackage
09:03:57 * sm thinks it's about time haskell had a really good FAQ
09:04:12 <Clint> FAQage
09:04:24 <sm> #haskell should make it
09:05:36 <Deithrian> dedgrant, some months ago I thought that the language itself should be designed in a way to encourage good code, but as I found out that's not always the case, and it's great to hear that in the Haskell community there's a conscious effort in the community.
09:06:21 <sm> does lambdabot have a db of questions and answers already ?
09:06:26 <Cale> Deithrian: Yeah, and it's really actually possible in Haskell to reuse code, as opposed to almost being able to reuse it, but not quite.
09:06:34 <sm> that would be a good starting point
09:07:04 <Cale> Deithrian: Which is another motivation to get things right, because you won't need to reimplement them. :D
09:08:47 <Deithrian> Cale, it sounds like things I will discover for myself, hopefully soon. :)
09:09:25 <Deithrian> Cale, is "Real World Haskell" the best place to start, say if you already have an idea of what a function is?
09:11:12 <kadoban> Deithrian: https://github.com/bitemyapp/learnhaskell (spring '13 cis194 and etc) or http://haskellbook.com/ are good ways to go. The latter is probably better, but it's not free.
09:12:18 <Deithrian> Thank you kadoban.
09:13:41 <Deithrian> Oh there's a beginner channel, how awesome :)
09:13:47 <Cale> Deithrian: Real World Haskell filled a niche at the time it was written, but the libraries it discusses have changed a good bunch since that time. If you can put up with that, it might eventually be worth looking at.
09:14:01 <Cale> Beginner questions are also always welcome in this channel.
09:14:28 <Cale> I'm opposed to the naming of that channel just because it suggests that beginners shouldn't bring their questions here.
09:15:28 <dedgrant> Deithrian: Perhaps the single greatest influence of Haskell over the past couple decades has been motivating a new generation of CS in public education? The slow but steady democratization has been quite remarkable.. I really enjoy hearing more teachers and students talk about how tools work rather than simply how to use the tools.
09:15:44 <Deithrian> Cale, good to know! :)
09:21:16 <Deithrian> dedgrant, I lost a year learning the basics of all the "popular" languages, jumping from one to the other, after discovering that language X can't do Y, but language Z has that problem solved 10 years ago. It would have been helpful to stumble across information about Functional Programming in the beginning, but it was simply not mentioned as an alternative.
09:24:56 <EvanR> Deithrian: CS at LSU amounts to essentially enterprise microsoft training
09:25:19 <EvanR> a year after they started they dropped C and switched to java
09:25:25 <EvanR> a year after I started
09:25:43 <bitemyapp> >enterprise microsoft training
09:25:44 <bitemyapp> >java
09:25:59 <EvanR> OOP was considered an advanced topic you need before you graduate
09:25:59 <bitemyapp> Has Microsoft dropped .NET as a platform?
09:26:10 <EvanR> .net wasnt as big back then
09:26:51 <EvanR> they might have switcehd to C#
09:27:30 <EvanR> corporate sponsorship you know
09:27:35 <shlomocomputer> Which Vim plugin is regarded as the most complete/supported/popular that integrates ghci to implement "smart" IDE functionality?
09:28:02 <shlomocomputer> I found a blog raving about haskellmode but it was from 2011
09:28:25 <nitrix> The blog or haskellmode?
09:28:30 <shlomocomputer> blog
09:28:37 <nitrix> Then what's stopping you from trying it?
09:28:42 <dedgrant> Deithrian: Cargo-culting is a problem, even in Haskell, but much more tempered by informed discourse that is mindful of cs (and much more recently, industry practitioners of all sorts). Much respect for the people who made this happen, and the governments and industry that kicked in funds to support growth.
09:29:10 <shlomocomputer> Nothing, besides the desire to do a little research so as not to go on any wild goose chases
09:29:42 <nitrix> Schrostfutz: There's like 3 or 4 plugins. Just try them all and see.
09:29:49 <nitrix> shlomocomputer: ^ *
09:30:08 <shlomocomputer> nitrix: do you use any?
09:30:21 <nitrix> shlomocomputer: My text editor is a text editor.
09:31:38 <Deithrian> EvanR, some of the languages I came across felt like their design is not necessarily such as to help the developer, but rather to be able to easily replace Bob with Peter.
09:31:48 <shlomocomputer> nitrix: mine too, precisely because I've always been turned off from any kind of IDEs by what looks like a lot of time invested and not a huge payoff
09:32:18 <shlomocomputer> but I'm sort of itching to enter the 21st entury
09:32:31 <EvanR> Deithrian: thats the liskov's programmer substitution principle
09:32:43 <fr33domlover> in 'persistent', is it possible to declare for a specific table, that when a row isn't referred to in other places it should be deleted?
09:33:13 <EvanR> shlomocomputer: then you need to get off IRC and start using slack ;)
09:33:21 <Deithrian> EvanR, oh great, there's a name for it :)
09:34:12 <Deithrian> I think I will learn a lot in this channel :D
09:34:19 <shlomocomputer> EvanR:  my first distro was Slackware, does that count?
09:34:26 <EvanR> heh
09:37:22 <dedgrant> bitemyapp: .net isn't going to be dropped any time soon, as this is the 'standard library' solution for CLR, as such there are over a billion clients using it. I do think that F# is getting a bit more say in the direction of .net though, so that's a good thing. (And of course Haskell still influences a number of decisions here.)
09:38:09 <EvanR> i would like to see haskell influence the design of CPU archs
09:38:52 <EvanR> programming languages factor into that somehow, and i have a feeling haskell is not on the top of the list
09:39:03 <EvanR> GHC is like a miracle
09:40:43 <shlomocomputer> For any interested, it seems haskellmode-vim is little maintained (since 2011) and people tend to pick and choose smaller plugins.  I think I'll go that route.
09:40:44 <shlomocomputer> Thanks
09:40:46 <humanoyd> Can anyone tell me what a type declaration inside a type-class declaration does? E.g. https://hackage.haskell.org/package/react-flux-1.0.3/docs/src/React-Flux-Store.html#StoreData
09:41:31 <dedgrant> EvanR: Heh.. I would be satisfied with retiring the tired and convoluted x86. Mid-sized FPGA kits are relatively cheap now. Surely Haskell (being closely aligned with lambda calculus) should be a good fit for HDLs?  
09:41:41 <crough> humanoid: It’s called a type family. 
09:41:54 <EvanR> humanoyd: that there is an associated type synonym (filed under type families)
09:42:19 <crough> humanoyd: It works a lot like a type level function: it takes a type and returns a new type dependent on the original.
09:43:12 <EvanR> theres a bunch of combinations of that feature and calling it all type families is confusing
09:44:14 <humanoyd> EvanR: crough Thanks, I'll google it from here :)
09:45:30 <bitemyapp> dedgrant: it was not a serious question, but okay.
09:46:24 <`Guest00000> is it possible to reinstall Haskell Platform without reinstalling packages?
09:46:45 * dedgrant tunes his filters.
09:46:48 <dedgrant> heh
09:47:48 <kadoban> `Guest00000: Why? What's happening that would prompt you to do that? (also: why are you using haskell platform?)
09:48:11 <legendre6891> Hi everyone! Is the function count = (length . filter) because (count pred X) has to keep the result of (filter pred X) in memory when passing it to length?
09:48:49 <legendre6891> I'm more familiar with Java, and there you can just loop through X and increment a counter when (pred element) evaluates to true --- no need to build the list (filter pred X)
09:49:22 <kadoban> legendre6891: There seem to be some words missing in your question possibly? I don't seem to be able to parse it.
09:49:24 <`Guest00000> i installed it on one drive and now i want it to be on another drive
09:51:02 <kadoban> legendre6891: Also I kind of suspect that length . filter isn't what you mean on its own? The type of that seems pretty goofy.
09:51:05 <crough> legendre6891: Sort of, although you don’t build the lists in Haskell (functions like this work similarly to streams)
09:51:29 <crough> kadoban: I think he’s asking why not just increment a counter, and it has to do with immutability
09:51:36 <legendre6891> kadoban: Hmm ... I'm not quite sure since I'm not comfortable using IRC. http://i.imgur.com/xJeGyMw.png <-- I pasted the screenshot there
09:52:05 <EvanR> if all youre doing is counting while traversing a temporary list, nothing will be in memory for long
09:52:22 <EvanR> big if though
09:52:56 <legendre6891> EvanR: but wouldn't the call (filter pred X) have to finish before count is called on the result?
09:53:04 <S11001001> legendre6891: Aye, the result of filter isn't so much a list as it is a promise to build a list as you ask for it.
09:53:43 <S11001001> legendre6891: so "count" consumes and throws away the list as it is constructed. As crough mentioned, it's more like a stream than a fully realized list.
09:54:11 <legendre6891> S11001001: Ah, so it is like an iterator in Python? 
09:54:17 <S11001001> legendre6891: sort of, yeah.
09:54:54 <S11001001> legendre6891: except you can always run it multiple times if you like; the API of python iterators is imperative
09:55:03 <EvanR> legendre6891: youre building the list as needed during the traversal, and if you dont need the nodes after each step, they will be collected
09:55:28 <S11001001> legendre6891: but in that way you can consider filter to be like itertools.ifilter
09:55:46 <EvanR> so lists have the ability to basically not exist in a substantial way
09:56:03 <EvanR> its easy to hold on to a reference though and defeat that feature
09:56:43 <jedai> legendre6891: This function will always be in constant memory (in addition to the memory taken by the initial list though)
09:57:27 <legendre6891> Got it. Thanks everyone! -- looks like I need to do more reading to have the right "mental model" of Haskell
09:57:43 <jedai> legendre6891: As other have said, with lazyness each element of the list created by filter will be consumed and garbage collected as soon as possible
09:57:58 <S11001001> legendre6891: Another way that haskell goes beyond python here is that it can inline or "fuse" operations, thus avoiding even the little bit of overhead that remains in the streaming data structure.
09:58:10 <jedai> legendre6891: beside, with stream-fusion it is likely that this function would be optimized to a tight loop anyway
09:58:14 <S11001001> legendre6891: but this is a compiler thing, try not to to worry about it too much.
09:58:17 <badmash> is there an alternative package to ghc-mod?  half the things in ghc-mod doesn't work!
09:58:33 <jedai> badmash: they don't ?
09:59:09 <legendre6891> Thanks!
09:59:10 <badmash> yep.  ghc-mod maintainer says refine command no longer works
09:59:24 <badmash> plus, function body completion doesn't work
09:59:47 <badmash> you know, i am starting to feel ghc-mod is a maze
10:00:42 <badmash> is there an alternative to ghc-mod?
10:01:04 <kadoban> badmash: hdevtools, for some definition of alternative
10:01:38 <jedai> badmash: Well the project is to put everything in ide-haskell-engine (and make it possible to add plugin)
10:01:47 <badmash> kadoban: thank you.  if this turns out ok, i will be never again looking at ghc-mod
10:01:55 <jedai> badmash: but for now this is a time of transition
10:02:07 <badmash> what transition?
10:02:24 <jedai> kadoban: does hdevtools work better than ghc-mod presently ?
10:03:00 <badmash> actually, i love emacs
10:03:18 <badmash> and i want something to work in emacs
10:03:22 <kadoban> jedai: I dunno, I haven't used ghc-mod in a long time, and I only use hdevtools very sparingly
10:04:07 <jedai> badmash: There is a project to get all actual ide-like capabilities for Haskell in one place (ide-haskell-engine), so there's lot of work around that but it's nowhere near ready yet. The hope is that it will simplify thing like stack did in the project management space
10:04:45 <jedai> haskell-ide-engine
10:05:14 <jedai> https://github.com/haskell/haskell-ide-engine
10:05:29 <badmash> well, is this something like the eclipse project?  i basically don't like IDEs like eclipse, which tries create a whole universe within themselves
10:06:20 <kadoban> Doesn't seem like it, it's more of a backend thing that'll then be used by plugins in whatever editors/IDEs
10:06:30 <badmash> i will stay with vim & emacs, with some basic code completion ... all lightweigh is what i need
10:06:44 <jedai> badmash: No, as the "engine" part of the name indicate, this is a backend module, that's intended to get everyone together and give the capacity to current IDE (emacs will of course be a part of that)
10:07:56 <DR4G0NFLY> What do you guys talk about?
10:08:12 <kadoban> DR4G0NFLY: Mostly haskell.
10:08:18 <DR4G0NFLY> What's that?
10:08:36 <jedai> DR4G0NFLY: A programming language unlike most others
10:08:47 <DR4G0NFLY> What is its purpose?
10:08:53 <DR4G0NFLY> Where can it be learned?
10:09:20 <Ankhers> @where learnhaskell -- DR4G0NFLY 
10:09:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:09:32 <DR4G0NFLY> Thank you.
10:09:39 <DR4G0NFLY> For what is it used?
10:09:46 <jedai> it's general purpose
10:10:03 <DR4G0NFLY> I see. Why is it "unlike most others"?
10:10:12 <jedai> You can use it for anything : script, Web backend, frontend, GUI, server, etc...
10:10:13 <badmash`> one of the problems with IDEs like eclipse is that they grow and grow, and become mammoths ... and then just to start up and thing takes time and a lot of memory.
10:10:28 <jedai> DR4G0NFLY: it's purely functional
10:10:43 <DR4G0NFLY> What does that mean?
10:10:57 <DR4G0NFLY> What would happen if it was only partially functional?
10:11:07 <badmash`> jedai: what does purely functional has to do with an IDE?
10:11:29 <jedai> DR4G0NFLY: You program with functions (no objects), it's "pure" because normal functions don't have side-effects
10:11:29 <Ankhers> badmash`: jedai wasn't responding to you...
10:11:50 <DR4G0NFLY> Ah, I see.
10:11:56 <jedai> DR4G0NFLY: That means they behave like mathematical functions, they always returns the same result for the same input
10:12:21 <DR4G0NFLY> Cool. How can it be general-purpose if it's not object-oriented?
10:12:25 <badmash`> Ankhers: i see ... sorry for the confusion
10:12:31 <tippeneinn> Is there a way around listing dependencies twice for 'executable' and 'library' sections in cabal file?
10:12:39 <jedai> DR4G0NFLY: Of course you can still have side-effects (without IO your program would be useless) but the way Haskell handle that is much more principled than normal language
10:12:48 <EvanR> i program with objects in haskell
10:12:51 <dcoutts> tippenein: you can make your exe depend on your lib
10:12:54 <jedai> DR4G0NFLY: C is general purpose, it's not object-oriented
10:12:59 <EvanR> much easier with functions ;)
10:13:27 <dcoutts> tippenein: but then it has to use the public api of the lib, not the hidden internal modules, and has to compile the same way (ie doesn't get to pick its own flags for how the lib modules are built)
10:13:30 <DR4G0NFLY> Oh, okay. I appreciate your help. I've only learned languages with objects, aside from HTML/CSS and AIML.
10:13:35 <jedai> DR4G0NFLY: The functional paradigm allows for better abstraction in general than object-oriented
10:13:50 <dcoutts> tippenein: e.g. a test that uses lib module may want to build with -fno-disable-assert for example
10:13:52 <DR4G0NFLY> It's good for dealing with unknown values?
10:14:02 <dcoutts> tippenein: but for exes it's often fine
10:14:18 <jedai> DR4G0NFLY: Don't know what you mean by "unknown values"
10:14:28 <DR4G0NFLY> Unknown numbers.
10:14:32 <tippeneinn> dcoutts: ok, I assumed you could name dependencies that way and have compiler flags for each
10:14:37 <dcoutts> tippenein: only "gotcha" is you need to use a separate src dir for the exe, otherwise it'll pick up the lib modules directly.
10:15:02 <tippeneinn> dcoutts: haha, that _is_ a 'gotcha'
10:15:03 <jedai> DR4G0NFLY: if they're really unknown you can't do anything about them (whatever the language) but if they follow a schema (like numbers) then you can manipulate them easily, no need for objects
10:15:08 <dcoutts> tippenein: the exe/text can have its own flags of course, but that applies to the module in the exe/test, not the ones in the lib
10:15:13 <DR4G0NFLY> Okay.
10:15:24 <DR4G0NFLY> I appreciate your help, thank you. :)
10:15:59 <jedai> DR4G0NFLY: Note that Haskell has an advanced type system (it's statically typed but inferred which allow you to write code that look like dynamic languages but checked by the compiler for type errors)
10:16:12 <EvanR> dealing with unknown numbers can be done in any language
10:16:30 <SavinaRoja> http://savinaroja.github.io/2016/02/06/haskell-revisits-the-central-dogma/ is up if anyone cares to critique
10:17:06 <jedai> You have "typeclass" which allows to deal with types that allow certain operations, this is extendable like objects (not exactly like of course....)
10:17:17 <EvanR> heh, i wanted to see what this central dogma was referring to, but its literally central dogma from biology
10:17:44 <SavinaRoja> EvanR: someone thought I was making a reference to evangelion :)
10:17:46 <notabigthreat> interfaces kinda correspond to typeclasses, right?
10:17:47 <EvanR> jedai: not the base use case though for that
10:18:25 <jedai> EvanR: True, but I thought maybe that was what he meant with "unknown values", doesn't seems like it though
10:18:28 <EvanR> SavinaRoja: i want that to refer to anything central and dogmatic in some field, but ive only heard it in those two instances :(
10:19:22 <SavinaRoja> EvanR: sounds like it could be something from the Magisterium, or RCC
10:19:33 <Gurkenglas> When one superclass of a class can be inductively proven from another using a law of the class, should I use put both in the class definition or only the second?
10:20:52 <jedai> Gurkenglas: That seems like an esthetic choice. Do you think the second class is relevant to the instance of the class you're defining ?
10:22:25 <Gurkenglas> The second one is relevant, the first is only a theorem that happens to always be true if the laws are followed... oh hey, that means I should include it so people can use the theorem.
10:26:31 <kmelva> is there a "standard" pretty printing library for GHCI? there's a bunch of stuff out there...
10:27:17 <jedai> kmelva: I think "ofrmatting" is pretty good
10:27:23 <jedai> formatting
10:28:23 <jedai> kmelva: it's type safe but there's no TH and it's not too verbose (in fact you have the choice of being very terse or more verbose depending on your needs and/or preferences)
10:28:25 <kmelva> jedai: that looks more like a text formatting library, not for (automatic) pretty printing... it's more like printf on steroids :)
10:28:37 <jedai> Ah, pretty printing
10:28:40 <jedai> sorry
10:28:50 <kmelva> I'm looking for something to make my SHow instances readable in terminal...
10:28:56 <kmelva> when Showing large nested records...
10:29:30 <ReinH> @hackage pretty-show
10:29:31 <lambdabot> http://hackage.haskell.org/package/pretty-show
10:30:35 <jedai> maybe GenericPretty would be good
10:30:55 <jedai> though it seems a bit abandoned...
10:31:04 <SavinaRoja> kmelva: what would prettier than the default, more concise?
10:31:40 <kmelva> SavinaRoja: indenting nested records, maybe skipping Nothing values, etc...
10:31:47 <jedai> Hmm pretty-show seems to do what you asked for
10:32:04 <ReinH> kmelva: ^
10:32:40 <ReinH> kmelva: Well, it doesn't skip Nothing values, because they contain information. But it does prettify shown values.
10:32:41 <jedai> It's based on pretty which is AFAIK state of the art in pretty printing
10:34:14 <kmelva> jedai: thnx, pretty does look like a stanard and it seems maintained... will go with that and pretty-show
10:34:33 <jedai> kmelva: ReinH is the one who pointed pretty-show
10:34:53 <jedai> but you're welcome ! Good luck with your project :)
10:35:35 <kmelva> thnx both of you :) Haskell has not been easy so far, but it's damn rewarding when you get something going :)
10:36:50 <Gurkenglas> Is there an OR combinator for constraints?
10:37:06 <phadej> not implicit
10:37:47 <subttle> hi, I have a working function that I'm trying to reimplement with `fix` but I keep getting ***Exception: <<Loop>>
10:38:08 <subttle> trans :: Set Node -> Set Node
10:38:16 <subttle> trans = \nodes -> ("\nDEBUG: " ++ show nodes) `trace` ((nodes `bind'` move) `Data.Set.union` nodes)
10:38:53 <subttle> it gives me the correct answer when I use `iterate` it eventually repeats the same answer, yet when I try `fix trans` it crashes
10:39:15 <phadej> subttle: it doesn't know when to stop. `fix` makes it going forever
10:39:30 <phadej> ie. the same as with `last . iterate trans`
10:39:39 <subttle> phadej: shouldn't it stop when it sees two values in a row that are the same?
10:39:45 <phadej> subttle: nope.
10:39:56 <phadej> how it would know when to stop?
10:40:01 <geekosaur> <<Loop>> generally means that in trying to evaluate to a constructor, it re-entered the thing being evaluated. which can mean it's not lazy enough
10:40:03 <phadej> (there is no Eq constraint e.g.)
10:40:03 <subttle> phadej: ah, I see
10:40:03 <jedai> subttle: fix doesn't do any comparisons
10:40:09 <Gurkenglas> subttle, iterate takes an initial argument. phadej, fix (1:) /= last . iterate (1:) undefined
10:40:28 <Gurkenglas> (umm, $ to the left of undefined)
10:40:32 <kadoban> Gurkenglas: How would OR work in constraints? Like what would it be useful for?
10:40:53 <notabigthreat> Gurkenglas: could you make a "weaker" constraint and depend on that one?
10:41:02 <phadej> kadoban: I guess the motivation is something "use this if there is ord constraint, otherwise Eq is enough"
10:41:19 <jedai> phadej: That seems a case for GADT ?
10:41:35 <subttle> jedai phadej Gurkenglas: thanks for the help! 
10:41:39 <Gurkenglas> kadoban, not done yet, but this: http://lpaste.net/5640768261382471680 <- It would be pretty useful if I could define MonadMonadTrans in the general case without needing quadratically many instances with the amount of monad transformers
10:41:58 <Gurkenglas> Because I want one behavior when the transformers are equal, and another if they are not
10:42:45 <jedai> Gurkenglas: Right, but the problem is that basically you have no way to detect which constraint was verified in the function (even if you had a OR)
10:43:01 <tippeneinn> anyone know what highlighter github uses? it consistently messes up haskell highlighting
10:43:09 <Gurkenglas> Oh, right. Dang.
10:43:51 <jedai> Gurkenglas: I was thinking of GADT since different constructor can transport different contraints (and differ only in that) and pattern matching makes it available
10:44:01 <phadej> tippeneinn: IIRC pygments?
10:44:23 <jedai> Gurkenglas: but I don't know if that's an option in your case
10:44:38 <phadej> tippeneinn: oh, no: https://github.com/github/linguist#syntax-highlighting
10:45:27 <phadej> wait, that just detects language
10:46:01 <Gurkenglas> Nah, I want different implementations depending on whether the transformers are equal
10:46:55 <Gurkenglas> Has anyone ever needed to use the same transformer multiple times and couldn't have solved it by fusing them into one, perhaps using a record?
10:47:30 <phadej> Gurkenglas: hmm, so you want A single constraint on two types "DecideEquality a b =>"
10:47:58 <Gurkenglas> phadej, I want... overlapping instances x.x
10:48:14 <phadej> with case decEq (:: a) (:: b) of { Refl -> {- same -} ; _ -> {- maybe different -} }
10:48:24 <Gurkenglas> (They would differ only in the constraints, but the constraints would make them disjunct by law)
10:48:35 <Gurkenglas> sure sounds good
10:49:08 <Gurkenglas> (Actually there'd be some further constraints on both cases.)
10:50:56 <phadej> Gurkenglas: but still, your "I want different implementations depending on whether the transformers are equal" means you want decidable type equality
10:51:03 <phadej> and that's usually fishy :/
10:51:16 <Gurkenglas> Well actually I just want data constructor equality
10:51:32 <Gurkenglas> Which I'm currently solving by putting in 4 instances for each pair of equal constructors, and 12 for the other pairs
10:51:45 <Gurkenglas> -each+the
10:52:09 <Gurkenglas> http://lpaste.net/5640768261382471680 <- Why can't it deduce Monoid w from MonadTrans (WriterT w)?
10:52:52 <phadej> Gurkenglas: it doesn't work that way
10:53:13 <phadej> MonadTrans (WriterT w) could be satisfied without w having `Monoid`
10:53:34 <Gurkenglas> No it couldn't. "Monoid w => MonadTrans (WriterT w)" on CMWL
10:53:43 <tippeneinn> phadej: right?! it's so hard to find out what they're using. I've tried rouge and pygments and they work on haskell code
10:53:59 <phadej> tippeneinn: apparatently :/
10:54:00 <ReinH> Gurkenglas: there can't be an or combinator for constraints. You wouldn't know which methods you can call on your constrained values.
10:54:22 <Gurkenglas> It even itself knows that w must be a Monoid because MonadMonadTrans requires "(WriterT      w m)" to be a monad
10:54:26 <ReinH> Unless you consider (Foo a, Bar b) => Either a b to be an or combinator.
10:55:02 <ReinH> (Which it certainly is)
10:55:03 <phadej> Gurkenglas: that constraint is on instance, not class. It cannot be known
10:55:59 <Gurkenglas> phadej, if overlapping instances are off, why not?
10:56:38 <phadej> Gurkenglas: because when compiling that code, compiler is not interested in which instances exists
10:56:47 <phadej> i.e. whether constraints are satisfiable ever
10:57:13 <Gurkenglas> Then what makes the compiler error I pasted there
10:58:11 <phadej> Gurkenglas: to satisfy `Monad` constraint on your MonadMonadTrans class
10:58:44 <phadej> e.g. Monad n, if i interpret ok
10:58:55 <Gurkenglas> Misunderstandings piling up. roll back to "It's pretty much an equivalence in that case, not a" and rephrase?
10:59:11 <Gurkenglas> Waaait
10:59:28 <Gurkenglas> That was the wrong clipboard. I meant roll back to "<phadej> Gurkenglas: because when compiling that code, compiler is not interested in which instances exists"
11:00:38 <phadej> Gurkenglas: the context MonadTrans (WriterT w) doesn't provide `Monoid w` because MonadTrans class doesn't have superclass
11:00:52 <phadej> i.e. you don't know that w is monoid from knowing that MonadTrans (WriteT w) is monoid
11:00:59 <phadej> well, you know, but compiler doesn't
11:01:19 <phadej> because the instance might be defined later, or not defined at all
11:01:21 <Gurkenglas> Why not? There is an instance Monoid w => MonadTrans (WriterT w) and we know there can't be any other instance so anything with MonadTrans (WriterT w) must have Monoid w
11:01:44 <Gurkenglas> The instance was already defined, there won't be a second one
11:02:13 <Gurkenglas> It knows that instance because it came up with Monoid w in the first place
11:02:35 <phadej> Gurkenglas: no, the Monoid w is required by the fact that `Monad n` should be satisfied
11:02:50 <phadej> i.e. (Monoid w, Monad m) => Monad (WriterT w m)
11:03:11 <Gurkenglas> Oh, hey, didn't know that. Makes sense that the MonadTrans can't say that it produces monads
11:04:36 <Gurkenglas> The point stands, though - why doesn't it look whether there's an instance of MonadTrans (WriterT w) and takes all the emerging constraints as a given?
11:04:48 <phadej> Because there could be another instance
11:05:15 <Gurkenglas> There couldn't be another instance! Overlapping forbidden
11:05:25 <phadej> I'm not sure if it would be sound to do, if overlapping instance is forbidden entirely
11:05:37 <phadej> but they aren't, so you cannot make that assumption anyway
11:06:09 <phadej> instance resolution is done in the caller code, not at the definition site
11:06:35 <phadej> So one could have `MonadTrans (WriterT ImNotAMonoid)`
11:07:08 <Gurkenglas> Okay, you're right.
11:15:49 --- mode: ChanServ set +o mauke
11:15:49 --- mode: mauke set +b $a:Mitzelflick
11:16:03 --- kick: MrTrump was kicked by mauke (MrTrump)
11:16:53 <yyyyy> \quit
11:16:55 <yyyyy> ops
11:18:02 --- mode: mauke set -o mauke
11:20:19 <Gurkenglas> :t modifyT :: (s -> IO s) -> WriterT String (StateT s IO) () -- It werks! http://lpaste.net/5640768261382471680
11:20:21 <lambdabot> (s -> IO s) -> WriterT String (StateT s IO) ()
11:20:32 <nut> i'm using stack on windows, how do i make sublime text work with stack?
11:20:50 <nut> i havnt installed any system wide ghc
11:21:53 <nut> i have added the ghc(installed through stack) path in the Path varible
11:21:57 <nut> and sublime can find it
11:22:04 <{AS}> Is there any place I can monitor the status of DepHaskell?
11:22:06 <nut> but sublime couldnt find any haskell library
11:23:51 <crough> nut: I don’t know Sublime at all. It may be easier to ask the maintainer of whatever plugin your using
11:33:28 <Gurkenglas> "makeWrapped ''TraversableT" in a line of an lpaste given to lambdabot won't work, right?
11:42:09 <dolio> {AS}: Hire Richard.
11:47:18 <EvanR> will two weak references to something stop it from being collected
11:49:20 <geekosaur> weak references should not stop things from being collected
11:49:26 <geekosaur> egardless of how many
11:49:50 <EvanR> thx
11:58:21 <dmwit> Gurkenglas: There's one easy way to find out...
11:58:39 <dmwit> Even easier than asking non-bots what will happen. =)
11:59:47 <gfixler2> Lifted implies boxed, but does it *mean* boxed?
12:00:30 <Gurkenglas> dmwit, I had already tried and it said parse error ' and I wanted to make sure it's not just some sort of typo
12:00:36 <EvanR> lifted means add _|_?
12:01:06 <geekosaur> yes, as I unerstand it. in fact I gather it's already changing such that it's either Lifted or an enum indicating the size of the unboxed value
12:01:43 <geekosaur> if I understood the discussion correctly
12:02:12 <gfixler2> EvanR: that's an intriguing thought
12:02:45 <gfixler2> okay, so then why doesn't Unlifted imply unboxed?
12:03:00 <dmwit> Gurkenglas: In that case, you should ask the question you actually meant!
12:03:56 <dmwit> Okay, okay, enough pedantry.
12:03:58 <EvanR> unboxing is a possible implementation of unliftedness? ;)
12:04:05 <Gurkenglas> But the question I actually wanted could be reduced to the one I asked! Not my fault your model suggested another reason for my question :P
12:04:07 <dmwit> Gurkenglas: I would be shocked if TemplateHaskell was enabled in lambdabot.
12:04:40 <dmwit> Gurkenglas: Ah, but it couldn't. Since the answer "no it won't work" doesn't tell you whether you made a typo.
12:05:10 <gfixler2> EvanR: it's too early for this, I think
12:05:16 <gfixler2> the terms are swimming around in my head
12:05:17 <dmwit> gfixler2: I suppose a strict boxed implementation could be considered unlifted.
12:05:39 <gfixler2> dmwit: I think I get that
12:05:52 <geekosaur> gfixler2, I don's actually know at this point. I think there was confusion about it that got resolved in favor of it actually meaning unboxed, but am not certain
12:06:02 <lynn> Hey, can lambdabot do regexes?
12:06:09 <Gurkenglas> Yes it would - it would be evidence I made no typo since that's the statement that makes Wrapped and if that should work then I must have done something else wrong
12:07:58 <dmwit> lynn: I'm not sure, but `(=~)` appears not to be in scope, so my guess would be no.
12:09:06 <shachaf> Can you golf a regular expression implementation into one line of IRC?
12:09:37 <dmwit> yikes
12:09:42 <gfixler2> just use Parsec/Applicatives
12:10:48 <dmwit> More importantly: can you golf it into something short enough that you're willing to put it all in every time somebody ?undefines everything?
12:11:18 <lynn> gfixler2: well, I wanted to quickly use its built-in quickcheck to determine whether two conditions on strings -- one of which uses a regex match -- are equivalent.
12:11:38 <lynn> Thankfully, it's a dead-simple regex, so yeah, I can sort of confidently convert it
12:11:49 <dmwit> lynn: ...ghci *also* has quickcheck...
12:11:58 <geekosaur> seems like you coul have done it with a local ghci on the time it's taken to discuss it in lambdabot
12:12:03 <gfixler2> [] = oneOf; [^] = noneOf; \a = alphaNum; . = anyChar; etc...
12:13:04 <lynn> Jeez, sorry, I'm on a ghci-less machine right now...
12:13:11 <lynn> I was just wondering :/
12:15:40 <dmwit> Parsing HTML with regexen is for the weak. This morning I built a regex LaTeX parser before breakfast
12:16:23 <Rembane> dmwit: I first thought you built a HTML-parser with regexen in TeX.
12:16:40 <dmwit> Come on, even *I* don't want to summon the elder gods.
12:16:49 <Rembane> dmwit: Pah! Wuss!
12:18:18 <mmachenry> Is LaTex even a regluar language? 
12:19:13 * hackagebot FontyFruity 0.5.3 - A true type file format loader  https://hackage.haskell.org/package/FontyFruity-0.5.3 (VincentBerthoux)
12:19:15 * hackagebot rethinkdb 2.2.0.3 - A driver for RethinkDB 2.2  https://hackage.haskell.org/package/rethinkdb-2.2.0.3 (codedmart)
12:19:18 <Rembane> mmachenry: LaTeX is not a language, but I think TeX is Turing complete.
12:19:36 <mmachenry> Parsing HTML with a regexp (just a regexp and not building your own full rec decent parser using some regexps) is impossible. 
12:19:48 <ahihi> that doesn't stop people from trying ;)
12:20:10 <mmachenry> Rembane: Ah. Tex is the langauge? What's LaTex, then the interpreter? 
12:20:23 <geekosaur> it's a macro package for and in TeX
12:20:30 <dmwit> Most regex libraries don't even pretend to recognize only regular languages.
12:20:53 <EvanR> can you even parse with regex, or is it merely recognizing
12:21:10 <dmwit> Grouping can be abused to get something like parsing.
12:21:26 <codedmar_> ocharles_ is engineio/socketio tied to a specific version of the js one?
12:21:34 <mmachenry> EvanR: A bit… you can remember what matched which parts. 
12:21:56 <ocharles_> codedmar_: not necessarily by design, but it's very possible
12:22:04 <mmachenry> So you can parse regular languages with a regexp as much as you can parse grammars with a parser. 
12:22:04 <ocharles_> codedmar_: may be worth noting I don't use it anymore as I quit that job :(
12:22:28 <codedmar_> ocharles_ :) aren't you with CircuitHub now?
12:22:31 <EvanR> so the common notion of using regex to parse anything is somewhat ridiculous
12:22:32 <ocharles_> that's right
12:22:39 <Rembane> But still hilarious
12:22:44 <codedmar_> Cool, thanks!
12:23:03 <mmachenry> EvanR: this, of course, assumes your implementation of the regexp allows it. But that is true of BNF. You can't parse with BNF only recognize. But any implementation of it will be used as a parser.
12:23:33 <EvanR> when you parse a sentence with a BNF grammar, you get a tree
12:23:42 <EvanR> when you use a regex you get a bool
12:23:51 <EvanR> (and some captures)
12:24:03 <mmachenry> EvanR: I slightly disagree.
12:24:13 * hackagebot json-rpc-server 0.2.3.0 - JSON-RPC 2.0 on the server side.  https://hackage.haskell.org/package/json-rpc-server-0.2.3.0 (KristenKozak)
12:24:15 * hackagebot FontyFruity 0.5.3.1 - A true type file format loader  https://hackage.haskell.org/package/FontyFruity-0.5.3.1 (VincentBerthoux)
12:24:43 <dmwit> EvanR: Nah, you get a tree.
12:24:46 <mmachenry> When you parse with a BNF you get (Maybe Tree) when you parse with regexp you get (Maybe some captures) 
12:24:51 <EvanR> oh?
12:25:05 <mmachenry> They are the same relative to their difference on the Cholmsky Heirarchy. 
12:25:11 <dmwit> EvanR: With a *ahem* well-designed library, you could get a tree, anyway.
12:25:22 <EvanR> interesting
12:25:29 <dmwit> EvanR: I don't think any popluar implementation tries to do it, though.
12:25:31 <EvanR> that would make regex not suck a little less ;)
12:25:40 <mmachenry> dmwit: Even with a standard regexp library you can get captures. IT's not powerful… but regexp is not power.
12:25:59 <EvanR> if you got a tree, the captures might not be necessary
12:26:13 <dmwit> e.g. the regex `ab*c` could reasonably give you a tree whose first level children are 'a', '*', and 'c', where '*' has one child for each 'b'.
12:26:16 <mmachenry> EvanR: If you got a tree you'd no longer have regexp. 
12:26:37 <EvanR> eh?
12:27:04 <dmwit> EvanR: e.g. see regex-applicative, which presents itself as a parser combinator library
12:27:11 <EvanR> oh wow
12:27:18 <dmwit> ?hackage regex-applicative
12:27:18 <lambdabot> http://hackage.haskell.org/package/regex-applicative
12:27:31 <EvanR> the answer to anyone coming in here looking for regex ;)
12:27:43 <adis> imal neko iz Bosne?
12:27:49 <kadoban> EvanR: mockery? ;)
12:28:08 <dmwit> I wouldn't call it mockery. I've found that library quite useful on a number of occasions.
12:28:18 <EvanR> im serious
12:28:30 <kadoban> Just making a bad joke … badly.
12:28:49 <EvanR> making a bad joke badder
12:28:53 <EvanR> since 2016
12:35:18 <liste> too bad regex-applicative doesn't work with Text :<
12:35:27 <liste> or ByteString
12:36:06 <dmwit> Yes, it is. I suspect patches would be welcomed.
12:37:16 <EvanR> you can lazily stream a given text or bytestring into it via a string, but yeah
12:42:11 <dmwit> I wonder how hard it would be to make it work with any MonoTraversable.
12:42:18 <dmwit> Or, like... any Traversal.
12:43:11 <EvanR> not foldable?
12:43:47 <dmwit> As long as we're asking questions instead of answering them, I'm happy to ask that question too. =)
12:44:59 <EvanR> are there really only ever questions anyawy?
12:45:50 <liste> at least string is `traverse sym'
12:46:52 <liste> https://github.com/feuerbach/regex-applicative/blob/master/Text/Regex/Applicative/Interface.hs and some others look generalizable too
12:47:38 <dmwit> That's not the part we want to generalize.
12:47:43 <dmwit> We want to generalize the consumers, not the producers.
12:49:36 <dmwit> Well, I mean, I guess generalizing the producers too couldn't hurt. As long as it's somebody else doing the work, right? ;-)
13:00:02 <dedgrant> Wow lovely in-situ summary of the ghc-8 levity polymorphism debate here: http://stackoverflow.com/questions/35318562/what-is-levity-polymorphism  .. clears up a lot for me
13:04:24 * hackagebot json-rpc-client 0.2.3.0 - JSON-RPC 2.0 on the client side.  https://hackage.haskell.org/package/json-rpc-client-0.2.3.0 (KristenKozak)
13:07:06 <EvanR> will we be able to actually use levity polymorphism or is it only going to be magically assigned to certain primitivish combinators like id
13:07:38 <kadoban> It sounded like it was going to be exposed I thought.
13:08:27 <EvanR> i know polymorphic arguments typically make no sense for kind # since its unboxed, the code cant handle both runtime objects without c++ style code variants
13:08:39 <EvanR> both boxed and unboxed
13:09:08 <dolio> That's a solvable problem.
13:09:25 * hackagebot ChasingBottoms 1.3.0.14 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.0.14 (NilsAndersDanielsson)
13:09:55 <kadoban> Nice name.
13:10:00 <EvanR> ah well thats interesting 
13:13:21 <EvanR> the levity thing gets deeper and deeper ;)
13:23:38 <chpatrick> is there a quick way to derive generic instances for a whole module?
13:24:09 <jedai> Personally I'm for a "beginner" Prelude. If we do it correctly I think it won't be an impediment because basically everything that worked with the Beginner Prelude would work with the "real" Prelude, you'l just be able to do more with the real one
13:24:16 <pie_> there was an environment variable for telling stack where its installed, does anyone know what it is? i cant find it
13:24:18 <chpatrick> or at least a type structure recursively
13:25:05 <pie_> or where it installs ghc or whatever
13:25:50 <adamCS> pie_: "stack path"? 
13:25:52 <dgpratt> TIL "levity polymorphism" is a thing and apparently it does not relate to accepting humor in all its forms
13:26:09 <kadoban> pie_: STACK_ROOT ?
13:26:12 <adamCS> pie_:  Never mind.  Not what you wanted.
13:26:16 <pie_> kadoban: yeah thats it thanks
13:26:21 <pie_> adamCS: ;P
13:34:28 * hackagebot number-length 0.1.0.1 - Number of digits in a number in decimal and hexadecimal representation.  https://hackage.haskell.org/package/number-length-0.1.0.1 (PeterTrsko)
13:50:17 <tibbe> the syntax of pattern synonyms is bevildering
13:51:04 <tibbe> especially for scoping of bindings
14:09:21 <magnificrab> is there a list comp operator that complements <-? eg "x such that x is not an element of xs"?
14:10:57 <Gurkenglas> magnificrab, there are infinitely many x that are not element of xs, right?
14:11:10 <Gurkenglas> Like, way up the cardinal ladder
14:12:24 <EvanR> Gurkenglas: oh ... please use types ;)
14:12:31 <Cale> You could use \\ along with an appropriate enumeration
14:12:54 <Cale> Depending on which type of lists you were working with
14:13:17 <EvanR> Woodin cardinals ;(
14:13:36 <magnificrab> Cale: \\ is more or less what i'm trying to implement
14:14:32 * hackagebot distributed-closure 0.2.0.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.2.0.0 (MathieuBoespflug)
14:17:57 <nucdak> haskell is a programming language for faggots
14:18:01 <nucdak> type /join lynchniggers
14:18:03 <nitrix> !ops
14:18:09 --- mode: ChanServ set +o shachaf
14:18:15 --- mode: shachaf set +b *!*462330be@*.70.35.48.190
14:18:15 --- kick: nucdak was kicked by shachaf (nucdak)
14:18:17 --- mode: shachaf set -o shachaf
14:18:21 <luite> :)
14:18:38 <maerwald_> sounds like he got frustrated learning monads
14:18:51 <EvanR> aint nobody got time for that
14:18:52 <nitrix> Not everyone can handle burritos.
14:19:29 <hexagoxel> being banned, he/she won't be able to return anyways.
14:19:44 <Gurkenglas> neither to join
14:19:52 <hexagoxel> :p
14:40:40 <alpha123> nitrix: not everyone has the gonads for monads
15:05:47 <EvanR> so if i have a data structure which constains serializable data and function values and nothing else, can i feasibly display this data along with something like a function name or other sane pretty print of the function values
15:07:47 <EvanR> wondering what sort of tricks are avilable for displaying function values
15:09:25 <geekosaur> there's a dummy Show instance in Text.Show.Functions that just outputs "<function>" (literally). names are not available, and may not even exist
15:10:01 <EvanR> right
15:10:12 <geekosaur> lambdabot has something that can display a function by its type, provided that it is monomorphic (it uses Typeable, which currently does not support polymorphism)
15:10:17 <EvanR> for example fmap (+1)
15:11:19 <dfeuer> :t fmap (+1)
15:11:20 <lambdabot> (Functor f, Num b) => f b -> f b
15:11:20 <geekosaur> ghc8 has support for DWARF symbol, which in theory *might* enable some ability to find the name of exported named functions
15:12:31 <EvanR> would be nice if the value produced by fmap (+1) was shown as "fmap (+1)" ;)
15:22:20 <demize> EvanR: https://wiki.haskell.org/Show_instance_for_functions
15:25:48 <hackrilege> Could not deduce (Applicative (X m)) arising from the context (MonadPlus m), what does this mean? Why is applicative being involved, it's not a superclass of MonadPlus...
15:25:58 <csd_> I'm getting stuck trying to expand ((>>>) (f &&& g))... i am getting stuck at (\ b' -> (arr (\b -> (b, b))) b') >>= ( (\x -> x) *** (\y -> y)) which doesnt type check; could anyone help?
15:26:09 <adas> a case statement always receives a single expression. am I correct?
15:26:19 <geekosaur> adas, it could be a tuple
15:26:44 <geekosaur> hackagebot, MonadPlus has Monad as superclass, in ghc 7.10 and later Monad has Applicative as superclass
15:26:45 <adas> geekosaur: yup.. but I can't do `case x, y of -> ...` or `case x y of ->` or something like that?
15:27:07 <adas> geekosaur: but `case (x,y) of ` is valid
15:27:08 <geekosaur> if you are using older code, it may neeed to be updated with an Applicative instance for any monad instances it defines
15:27:09 <hackrilege> Oh dear, thanks, I didn't know that
15:27:18 <geekosaur> adas, yes
15:27:25 <adas> geekosaur: thanks for the clarification
15:27:28 <EvanR> demize: interesting about universe reverse
15:27:46 <geekosaur> "case x y of" would in any case be treated as application of x to y
15:28:07 <EvanR> however this is not about serializing the true extensional value of a function, just pretty printing for shits and giggles
15:28:39 <geekosaur> you do realize that what you want simply is not available? this is not python
15:29:04 <geekosaur> at runtime, you have a pointer. that pointer does not have source code attached to it, nor a name, nor anything else
15:29:16 <EvanR> yes
15:29:39 <EvanR> but ghc never ceases to amaze
15:30:13 <Zekka|Sigfig> You could store pairs of function name and function value, instead of storing the function pointer
15:30:31 <EvanR> well theres no "name" really
15:31:03 <EvanR> but actually youre right i could attach a manually formatted string for this purpose
15:32:41 <hackrilege> I don't understand why join isn't in the class header
15:33:25 <hackrilege> https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#join
15:33:31 <crough> hackrilege: I heard somewhere that >>= was easier to optimize but that could be the most false thing
15:34:31 <hackrilege> I want to provide join, not (>>=)
15:34:58 <crough> You can define `myMonadJoin` and just define >>= in terms of it… I know it’s not ideal, but :/ 
15:35:01 <Zekka|Sigfig> Why not provide join’, then define (>>=) in terms of that? Other than maybe the optimizer finding that confusing?
15:36:16 <crough> Zekaa|Sigfig is reading my mind :)
15:36:24 <crough> Oh well I spelled it wrong anyway
15:36:48 <EvanR> would be nice if it was in the Monad class like Comonad 
15:37:09 <hackrilege> Sorry I dropped connection, was there a response?
15:37:34 <crough> Yes, just define join’ somewhere and then define >>= in terms of that
15:37:36 <Zekka|Sigfig> hackrilege: Probably just the one you were expecting: write join’ and implement (>>=) in terms of that
15:37:53 <Zekka|Sigfig> It won’t make the optimizer less confused unless there are already good rewrite rules to handle that
15:37:55 <EvanR> complete with smart quote ;)
15:37:57 <crough> where `x >>= f = join (map f x)`
15:38:14 <hackrilege> It would be nice if it would default
15:38:50 <crough> hackrilege: I agree but it’s honestly not a huge deal…
15:39:11 <hackrilege> The Functor superclass constraint required is present
15:39:23 <hackrilege> It's a huge deal
15:39:25 <geekosaur> it may happen at some point. it's not considered particularly important by most people though, so nobody's pushing ghc devs for it
15:39:43 <hackrilege> I am
15:39:49 <crough> Yeah we get that.
15:39:58 <geekosaur> no you are pushing #haskell
15:40:04 <hackrilege> So how do I change it?
15:40:08 <geekosaur> very few ghc devs hang out here
15:40:18 <Zekka|Sigfig> Wait, you’re concerned about the functor superclass constraint? If that doesn’t make sense for what you’re doing, your type might not be a monad
15:40:46 <crough> No, functor is required for monads to be implemented in terms of join
15:40:53 <Zekka|Sigfig> Yeah, that’s what I thought he was saying.
15:41:10 <hackrilege> Many of the posters here should have these abilities
15:41:27 <geekosaur> make a proposal on glasgow-haskell-users@haskell.org, probably including a page on the ghc wiki with arguments and supporting information
15:41:47 <hackrilege> No
15:41:54 <hackrilege> I'm fighting for my life
15:41:56 <geekosaur> actually this one might be better for libraries@
15:41:56 <hackrilege> Brb
15:42:04 <hackrilege> Thanks for your help
15:42:09 <EvanR> hey, he doesnt get that if i dont get reflexive source code reconstruction!
15:42:24 <EvanR> jk
15:42:25 <lpaste> echo-area pasted “corollary of universal property” at http://lpaste.net/152088
15:42:27 <hackrilege> Well not right back...
15:43:07 <hackrilege> Any one had any thoughts about bimonads since I was here last in December?
15:43:17 <Zekka|Sigfig> What’s a bimonad?
15:43:53 <Zekka|Sigfig> bireturn :: a -> b -> bm a b; bibind :: ?????
15:43:54 <hackrilege> Two distinct directions to join
15:44:25 <Zekka|Sigfig> ljoin :: bm (bm a b) b -> bm a b; rjoin bm a (bm a b) -> bm a b?
15:44:28 <hackrilege> Trivial case was a tree with trees as elements
15:44:35 <Zekka|Sigfig> rjoin :: bm*
15:44:44 <hackrilege> Had an extra base case in the constructor
15:44:51 <Zekka|Sigfig> (and I’m going to guess a similar formulation for lbind and rbind?)
15:45:04 <echo-area> Hi, I want to prove the corollary of the universal property by going from bottom to top in the link.  But in the path unfold g = f' is a weird assumption.  Are there better ways?
15:45:19 <hackrilege> Rich class of bass cases, all shaped trees with empty nodes
15:45:41 <dfeuer> crough, >>= is definitely easier to optimize than join in some important cases. However, =<< would be even better sometimes!
15:46:17 <crough> dfeuer: Awesome, thanks. I hate it when someone tells me something and I can never remember if I just made it up.
15:47:31 <hackrilege> I'll come back and figure it out in another batch of freedom
15:48:00 <dfeuer> Any time fmap is expensive, >>= is better than bind. Rewrite rules can only save you sometimes. =<< would've been slightly better, I think, because of the way it works with Identity.
15:48:13 <dfeuer> er ...
15:48:17 <dfeuer> I mean >>= is better than join.
15:48:24 <John[Lisbeth]> Why can't I (let astring = "/")
15:48:32 <crough> Also, dfeuer, =<< keeps flow in the same direction :)
15:48:45 <crough> from a purely language design standpoint
15:49:05 <dfeuer> crough, that's sometimes true, yes. But then <*> goes and makes that wonky....
15:49:29 <Zekka|Sigfig> John[Lisbeth]: If you’re not in do notation, let needs to be an expression, so you need an `in` block
15:49:56 <Zekka|Sigfig> Having a thing in parentheses that’s not a value is really weird!
15:50:13 <Zekka|Sigfig> (well, a value or a pattern or a type…)
15:50:20 <dfeuer> crough, =<< makes *values* flow the right way, but its *effect* order is opposite that of <*>.
15:50:29 <John[Lisbeth]> Zekka|Sigfig: I'm in GHCI
15:50:35 <dfeuer> Which might mean that <*> should've worked the other way.
15:50:48 <crough> dfeuer: that’s actually a very good point… although <*> still mostly reads as normal application
15:50:54 <Zekka|Sigfig> John[Lisbeth]: GHCi usually behaves pretty close to a do block, but if you put parens around it the parser decides you mean for it to be an expression
15:51:08 <Zekka|Sigfig> you might want to not use parens here
15:51:16 <Zekka|Sigfig> (expression => thing that has a value)
15:51:48 <John[Lisbeth]> I can't do it without parens either
15:52:19 <dfeuer> It's all far too late to change now. You can always use >>> and & and Backwards and such, I suppose.
15:52:22 <jmcarthur> I've never knowingly had a problem with the effect ordering of applicatives, and although I really like (=<<), I'm a bit sad that its effect order is right to left. One reason I never use it with IO.
15:52:50 <Zekka|Sigfig> John[Lisbeth]: Oh, yeah, you’re into parens IIRC. I don’t think you will be able to convince GHCi to make a persisting binding while also using the parens, since the parens mean what you’re writing is an expression
15:52:54 <dfeuer> jmcarthur, the only problem with the effect ordering of applicatives is that it disagrees with =<<.
15:53:09 <Zekka|Sigfig> You can introduce a temporary binding though using `in`
15:53:13 <jmcarthur> dfeuer: I think it's more of a problem with (=<<) though.
15:53:22 <John[Lisbeth]> I took out the parens. It still doesn't work
15:53:34 <jmcarthur> dfeuer: Bind just has some unpleasant assymmetry here.
15:53:42 <Zekka|Sigfig> Really? Weird, what exactly are you feeding it?
15:53:47 <jmcarthur> *asymmetry
15:54:04 <c_wraith> (=<<) does the only thing it can do, at least without introducing something like MonadFix
15:54:19 <John[Lisbeth]> let astring = "\"
15:54:25 <jmcarthur> Exactly. Whereas Applicative gets to choose.
15:54:27 <Zekka|Sigfig> Oh, that’s a backslash!
15:54:36 * hackagebot oanda-rest-api 0.1.0.0 - Client to the OANDA REST API  https://hackage.haskell.org/package/oanda-rest-api-0.1.0.0 (jdreaver)
15:54:37 <John[Lisbeth]> yes
15:54:42 <lethjakman> So...I read this sentence "Category is a relatively recent addition to the Haskell standard libraries."
15:54:43 <Zekka|Sigfig> GHCi is interpreting the backslash to mean “the next character exactly, no matter what it is
15:54:49 <geekosaur> you said / the first time, they are different
15:54:50 <lethjakman> What exactly is the haskell standard library?
15:54:50 <dfeuer> jmcarthur, I don't see a problem with that. =<< performs the effects on the right first and feeds their results to the left. Just like you'd get in a language like ML with side-effects.
15:54:51 <lethjakman> Prelude?
15:54:58 <John[Lisbeth]> but \\ seems not to work
15:55:17 <Zekka|Sigfig> This has a nonneglible chance of working afaik: let astring = “\\”
15:55:22 <geekosaur> Show is confusing you. use putStrLn
15:55:23 <jmcarthur> dfeuer: By that argument, Applicative does the right thing too.
15:55:40 <dfeuer> Since Applicative gets to choose, I think it would be more sensible if it matched =<<.
15:55:40 <Zekka|Sigfig> lethjakman: I don’t know exactly which modules are in the haskell standard library, but afaik the standard library is the package called `base`
15:56:02 <John[Lisbeth]> but when I print astring it equals "//"
15:56:08 <geekosaur> putStrLn
15:56:09 <geekosaur> not print
15:56:14 <jmcarthur> Actually I guess the language gets to choose when it comes to applicative style.
15:56:14 <geekosaur> print is putStrLn . show
15:56:17 <geekosaur> show is expanding the \
15:56:29 <geekosaur> (in the same way it turns a newline character into \n)
15:56:34 <geekosaur> > "\\"
15:56:36 <lambdabot>  "\\"
15:56:38 <Zekka|Sigfig> `show` tries to generate approximate Haskell source code for most of the types it’s defined for
15:56:42 <geekosaur> > text "\\"
15:56:44 <lambdabot>  \
15:57:03 <dfeuer> So we'd have  ., <=<, =<<, <*> and <* (with the effects backwards from currently), and everything would work in a very consistent way.
15:57:03 <geekosaur> ("text"is somewhat specific to lambdabot, since we can't use putStrLn)
15:57:07 <jmcarthur> dfeuer: I'm coming around, although I still think right-to-left effects are confusing.
15:57:22 <jmcarthur> *are sometimes confusing
15:57:58 <dfeuer> jmcarthur, I can see that for sure. I think we should have *all the things*, but that the "basic set" should all match each other as well as possible.
15:58:29 <Zekka|Sigfig> Apologies by the way — no one should copypaste code snippets I write because my client obsessively inserts smart quotes
15:58:51 <Zekka|Sigfig> it is not a good client
15:58:59 <dfeuer> jmcarthur, I suspect Applicative ended up the way it did because it's particularly natural that way for parsing.
15:59:16 <jmcarthur> I see this as an argument against (=<<) rather than an argument for changing the behavior of Applicative.
16:00:42 <jmcarthur> I would be sad to lose (<=<) though...
16:01:16 <dfeuer> jmcarthur, the composition order of ., <=<, and =<< makes a lot of sense for Haskell's function application notation. A postfix language would be happier with >>>, >=>, >>=, etc.
16:01:51 <jmcarthur> I see what you're saying. I'm just unhappy. :)
16:01:55 <dfeuer> Yes.
16:02:36 <dfeuer> Anyway, it is the way it is. Convenient but not very consistent.
16:04:49 <jmcarthur> dfeuer: I think this argument also implies that parsing should happen in reverse. Then writing a parser with the reversed effects doesn't suck as much.
16:06:44 <dfeuer> jmcarthur, we like writing char 'a' <*> char 'b' to parse "ab" rather than char 'b' <*> char 'a'. I think that's a reasonable preference. How it relates to actual parsing is a question I can't personally answer.
16:06:59 <John[Lisbeth]> I can't do let astring = "cat a\ file"
16:07:16 <dfeuer> Except that I imagine parsing right to left would make streaming stuff much harder.
16:07:26 <jmcarthur> dfeuer: I just mean that if the implementation started at the *end* of the stream instead of the beginning, then we still get to write it the natural way with effects going right-to-left.
16:07:38 <hpc> it breaks my personal rule anyway, "make it look like what it does"
16:07:44 <Zekka|Sigfig> John[Lisbeth]: I think you are not distinguishing backslash and slash, but they don’t mean the same thing
16:07:53 <EvanR> haha... right to left is natural?
16:08:01 <EvanR> dunno
16:08:11 <dfeuer> jmcarthur, sure, but when do you get a stream that starts at the end? Not in typical applications.
16:08:11 <jmcarthur> EvanR: char 'a' <*> char 'b'  is the "natural" way to parse  ab
16:08:18 <jmcarthur> dfeuer: Agreed.
16:08:29 <John[Lisbeth]> Zekka|Sigfig: I am trying to use the escape character
16:08:29 <EvanR> looks left to right
16:08:44 <Zekka|Sigfig> What character are you trying to escape? You don’t ordinarily need to escape spaces
16:08:57 <jmcarthur> EvanR: If effects are right-to-left *and* the stream you're parsing is going in reverse, you would write it the same way, but it's not left-to-right.
16:09:01 <Zekka|Sigfig> Are you trying to escape the backslash? Because in that case you would need a second backslash
16:09:10 <John[Lisbeth]> I am evaluating strings from a lang that uses backslash for escaping
16:09:51 <EvanR> jmcarthur: at the expense of being even more confused, what does "effects going" a direction mean
16:10:06 <EvanR> and why does it matter if the syntax is the same
16:10:40 <jmcarthur> EvanR: Consider the difference between   (<*)   and   flip (*>)
16:10:45 <EvanR> (and how would it even work with parsing in reverse)
16:11:30 <EvanR> what is the difference?
16:12:13 <EvanR> ok... so it lets you write the app chain backwards
16:12:46 <jmcarthur> > (<*) ("foo", False) ("bar", True)
16:12:47 <lambdabot>  ("foobar",False)
16:12:52 <jmcarthur> > flip (*>) ("foo", False) ("bar", True)
16:12:54 <lambdabot>  ("barfoo",False)
16:13:05 <jmcarthur> Same value, different effect.
16:13:14 <crough> Is there a nice way to right-partial subtraction?
16:13:25 <EvanR> > flip (*>) ("bar", True) ("foo", False)
16:13:27 <lambdabot>  ("foobar",True)
16:13:28 <jmcarthur> :t subtract  -- crough 
16:13:29 <lambdabot> Num a => a -> a -> a
16:13:34 <crough> Thanks!
16:13:59 <jmcarthur> > subtract 3 {- from -} 5
16:14:00 <lambdabot>  2
16:14:50 <EvanR> honestly neither direct seems right anymore for anything, with the number of conflicting and sensible ways available in haskell. if anything the classic syntax f(x) no longer makes absolute sense
16:14:57 <EvanR> directions
16:15:07 <crough> I’m guessing this function is here explicitly for this reason. Why did Haskell choose to use (-) instead of (~), anyway? Just an arbitrary choice?
16:15:15 <crough> The ambiguity is… annoying.
16:15:30 <jmcarthur> crough: (-) is a pretty standard operator for substraction...
16:15:50 <crough> jmcarthur: negation, though.
16:15:53 <jmcarthur> crough: Oh, you mean for the prefix for negation.
16:16:11 <crough> haha yeah. I know a few older MLs use the tilde
16:16:38 <jmcarthur> crough: I think the way to go would have been to make whitespace around operators mandatory.
16:16:49 <jmcarthur> crough: Then removing the whitespace could be interpreted specially.
16:16:50 <EvanR> ~4 looks funny
16:17:02 <jmcarthur> crough: (.) for record notation. (-) for negation. etc.
16:17:17 <crough> jmcarthur yeah, that’s a good point
16:18:41 <jmcarthur> And it would have cleared up the inconsistency of (.) with uppercase vs. lowercase identifiers
16:19:01 <jmcarthur> > (Just.succ) 5
16:19:03 <lambdabot>  Not in scope: ‘Just.succ’
16:19:04 <jle`> and [False..True] vs. [False .. True]
16:19:09 <jmcarthur> right
16:19:18 <Lokathor> anyone used the inline-c package? Is it a solid thing or still kinda in development?
16:19:21 <jmcarthur> That one's even weirder.
16:19:31 <lpaste> geekosaur pasted “string escapes and show vs. putStrLn (John[Lisbeth])” at http://lpaste.net/152124
16:20:06 * hackagebot werewolf 0.4.4.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.4.0 (hjwylde)
16:20:08 * hackagebot llvm-general-pure 3.5.1.0 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-general-pure-3.5.1.0 (BenjaminScarlet)
16:20:10 * hackagebot llvm-general 3.5.1.2 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.5.1.2 (BenjaminScarlet)
16:20:14 <jmcarthur> The mandatory whitespace might also reduce some of the operator overload we are prone to.
16:20:34 <jmcarthur> ... Nah, it wouldn't.
16:20:48 <jle`> it might also make things like sin x^2 clearer
16:21:20 <EvanR> sum^2 x obv
16:21:23 <EvanR> sin^2 x
16:21:55 <jle`> it's not obvious until you think about it :O
16:21:56 <jmcarthur> > sin^2 7   -- I don't remember if lambdabot has NumInstances. I know it did, and then I think it was removed, and maybe it's back?
16:21:58 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
16:21:58 <lambdabot>      from the context (Floating a, Num (a -> a))
16:21:58 <lambdabot>        bound by the inferred type of
16:22:02 <jmcarthur> ah
16:22:03 <jmcarthur> hey
16:22:10 <jle`> also what's up with
16:22:16 <jmcarthur> > (sin^2) 7
16:22:18 <jle`> > let x = "hello" in const 1x
16:22:18 <lambdabot>      No instance for (Show a0)
16:22:18 <lambdabot>        arising from a use of ‘show_M22838199974428165369914’
16:22:18 <lambdabot>      The type variable ‘a0’ is ambiguous
16:22:20 <lambdabot>  1
16:22:35 <geekosaur> every so often someone loads it in and it disappears at the next @undefine
16:23:48 <jmcarthur> jle`: That's quite gross.
16:23:50 <jle`> > let x = 5 in (+) 10x
16:23:52 <lambdabot>  15
16:23:58 <ddssA> someone telling me go messure it out inch by inch drip by drip keeps saying "you ar.ed already you already a.r.ed" whats that mean?
16:26:06 <Axman6> ddssA: what on earth are you talking about? o.O
16:42:11 <lpaste> geekosaur revised “string escapes and show vs. putStrLn (John[Lisbeth])”: “string escapes and show vs. putStrLn (John[Lisbeth])” at http://lpaste.net/152124
16:49:36 <dmj> data PortID = .. | PortNumber PortNumber .. how confusing
16:49:52 <EvanR> yep
16:49:55 <dmj> newtype PortNumber = PortNum Word16
16:50:14 <dmj> then I get, "Don't use the PortNum constructor, just the Num instance"
16:50:32 <geekosaur> ys. PirtNum is historical baggage and the whole thing will hopefully go away soon
16:50:37 <geekosaur> *Portnum
16:50:39 <geekosaur> ...
16:50:52 <geekosaur> *PortNum -- not so much with the typing this evening, I guess
16:56:10 <megaTherion> Im trying to read from an socket via Network.Socket.ByteString (recvFrom) - and I want to pass the ByteString to a Data.Binary.Get (runGet) function - however runGet wants an lazy ByteString which I dont have?
16:56:32 <lukky513> uhm. why does :t (+) (+) give me (a -> a -> a) -> a -> a -> a? and not, say, (a -> a -> a) -> a -> a?
16:57:39 <Axman6> because it (+) :: (a -> a -> a) is the first argument to the first (+), and both (+)'s arguments have the same type, and that type is also the return type
16:58:08 <Axman6> the first (+) has type: (a -> a -> a) -> (a -> a -> a) -> (a -> a -> a)
16:58:32 <Axman6> (which probably doesn't make a whole lot of sense but that's what you asked it for)
16:59:18 <lukky513> Axman6: thanks
16:59:35 <lukky513> well, it doesn't have to, I was just wondering what I get, stacking functions like this
16:59:53 <lukky513> it might not make sense, but I should be able to understand it all the same :)
17:00:21 <geekosaur> you get that prefixed with a bizarre-looking Num instance
17:00:44 <lukky513> geekosaur: that too
17:01:09 <geekosaur> haskell is perfectly happy to do such things, and only notice that no such thing exists when you try to use it
17:01:36 <puregreen> what are the benefits of typeclass laws?
17:01:59 <puregreen> (if there are any articles stating them, I'd appreciate the link)
17:02:09 <puregreen> * links
17:02:27 <lukky513> geekosaur: oh, so that combo is not effectively applicable?
17:03:11 <geekosaur> only if you can come up with some type where both it and a function combining two of it to produce a third are *both* instances of Num 
17:03:32 <geekosaur> (this turns out to be possible, but it's not very intuitive)
17:03:49 <lukky513> I think I'll come back to that some other day.
17:06:03 <orion> Is there a cleaner way to write this?: case ... of; (..., ...) -> (\(a,b) -> (Just a, b)) <$> foo
17:06:47 <EvanR> > Just <$> (1, 2)
17:06:50 <lambdabot>  (1,Just 2)
17:06:59 <EvanR> :t (Just <$>)
17:07:01 <lambdabot> Functor f => f a -> f (Maybe a)
17:07:04 <EvanR> dang
17:07:30 <Axman6> > first Just <$> (1,2)
17:07:31 <lambdabot>      No instance for (Show b0)
17:07:32 <lambdabot>        arising from a use of ‘show_M608977910780753779510859’
17:07:32 <lambdabot>      The type variable ‘b0’ is ambiguous
17:07:34 <Axman6> no
17:07:37 <Axman6> > first Just  (1,2)
17:07:39 <lambdabot>  (Just 1,2)
17:07:50 <puregreen> @src (,) fmap 
17:07:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:08:00 --- mode: ChanServ set +o glguy
17:08:00 --- mode: glguy set +b-bo *!~ddss*@2600:1003:b0* *!*@2600:1003:b00f:6e85:* glguy
17:08:04 <Gurkenglas> What's in the ...?
17:08:26 <orion> Unrelated.
17:08:36 <puregreen> (hm, how come the @-thing worked when I PM'd lambdabot but not here)
17:08:45 <Gurkenglas> :t (fmap . first) Just
17:08:46 <lambdabot> Functor f => f (b, d) -> f (Maybe b, d)
17:08:49 <Axman6> anyway, (\(a,b) -> (Just a, b)) <$> === first Just <$>
17:09:03 <shachaf> puregreen: Maye you put a space at the end of the line?
17:09:08 <shachaf> puregreen: What are the benefits of any laws?
17:09:37 <orion> Where is first defined?
17:09:47 <Axman6> Control.Arrow iirc
17:10:17 <Axman6> I think bifunctors might be the more common way to do that these days?
17:16:42 <puregreen> shachaf: yeah, it probably was the space, thanks. As for laws: e.g. one benefit of typeclass laws is that you can occasionally use them to prove properties of your code that you care about. What I was wondering about is what other people would say (which could give me an idea of what people perceive to be the biggest benefit).
17:17:04 <shachaf> Ah.
17:18:10 <geekosaur> puregreen, in general there is a strong preference for typeclasses to have associated laws, not just to prove properties of your own code but also so that there is consistency between instances
17:18:14 <Lokathor> typeclass laws inform you about what code replacements / optimizations are supposed to be valid
17:18:39 <geekosaur> (there being historical typeclasses with little consistency about them)
17:18:58 <puregreen> geekosaur: well, but consistency isn't a goal in itself
17:19:26 <geekosaur> it is if you want to be certain that being polymorphic in a typeclass is a sensible thing to do
17:20:17 <Lokathor> puregreen, whatever consistency you have is part of the whole contract of what it means for a type to have an instance of a typeclass.
17:20:41 <Schrostfutz> Hi, I have a probably stupid quetsion: what am I doing wrong?: Prelude>  read "5" -> *** Exception: Prelude.read: no parse
17:20:56 <geekosaur> Schrostfutz, ghci is weird
17:21:05 <Lokathor> > read "5" :: Int
17:21:07 <kadoban> Schrostfutz: If you don't specify a type for the result, it just defaults to one … which is not what you want.
17:21:07 <lambdabot>  5
17:21:13 <Lokathor> Schrostfutz, try sticking a type signature on it
17:21:21 <geekosaur> read is polymorphic; since you didn't tell it the type to produce, it inferred the most general one it can whih is ()
17:21:23 <kadoban> (It's defaulting to the () type I believe … which is less than useful here, haha.)
17:21:46 <kadoban> > read "()"
17:21:48 <lambdabot>  ()
17:22:12 <geekosaur> (you can make it default to numeric types with ":seti -XNoExtendedDefaultRules" so it follows the rules a program would)
17:22:27 <kadoban> > read "5" + 2 -- note that if context requires it to be a more useful type, that works too
17:22:29 <lambdabot>  7
17:23:27 <Schrostfutz> Lokathor, kadoban, geekosaur: ah, thanks!
17:25:21 <orion> Is there a good way to shorten this?: f x = do { foo x; bar x } I was able to do (\x -> foo x >> bar) but I don't quite understand why it works or if there's a better way.
17:26:44 <Gurkenglas> liftA2 (>>) foo bar, or perhaps runReaderT $ ReaderT foo >> ReaderT bar
17:26:46 <geekosaur> that looks wrong in the genral case
17:27:04 <geekosaur> (foo x >> bar, that is)
17:28:19 <orion> geekosaur: It type checks.
17:28:32 <Reshi> orion: Just match types. Think of do blocks as just a nicer way of wrapping >> and >>= . So do { foo x; bar x} is just foo x >> bar x 
17:28:55 <geekosaur> ^ and that last is why yours seems wrong
17:29:03 <orion> Reshi: foo x >> bar x won't typecheck
17:29:17 <geekosaur> then neither would do { foo x; bar x }
17:29:26 <geekosaur> @undo do { foo x; bar x }
17:29:26 <lambdabot> foo x >> bar x
17:29:51 <Reshi> orion: with (>>) :: Monad m => m a -> m b -> m b . So foo and bar should be giving m a
17:30:10 <ReinH> foo x >> bar =/= foo x >> bar x
17:30:10 <Reshi> orion: what are the types sigs for foo and bar?
17:30:17 <ahihi> @pl f x = foo x >> bar x
17:30:17 <lambdabot> f = liftM2 (>>) foo bar
17:30:43 <ReinH> I am guessing that foo x >> bar is a typo
17:30:54 <geekosaur> or something else is
17:31:10 <ReinH> There's no way both f x = do { foo x; bar x } and f x = foo x >> bar both typecheck, so one must be incorrect.
17:32:02 <Reshi> oh I didn't notice it was just ..>> bar.. and not >> bar x
17:32:24 <ReinH> The literal desugaring of the former is f x = foo x >> bar x
17:32:32 <ReinH> so what exactly is it?
17:33:36 <mazur> so I ran `stack build` to build Idrid-dev, the readme says it should be in `~/.local/bin`, but i have nothing there and `idris` is not on my path
17:33:53 <geekosaur> shouldn't that be stack install?
17:34:01 <geekosaur> otherwise it just built it but it'ss till in he dist tree
17:34:07 <geekosaur> *still in the
17:34:13 <orion> ah, I was misinformed.
17:34:31 <orion> I was missing an argument in the anonymous function.
17:35:00 <orion> It's supposed to be \x y -> foo x y >> bar y
17:35:15 <orion> The reason it "worked" is because of currying.
17:35:20 <orion> On y
17:35:35 <mazur> geekosaur: ah, thanks, the readme left out that part :)
17:35:43 <ReinH> Well, that is certainly different.
17:35:46 <geekosaur> @pl \x y -> foo x y >> bar y
17:35:46 <lambdabot> (`ap` bar) . ((>>) .) . foo
17:35:50 <geekosaur> ...ew
17:36:15 <ReinH> Although I don't see how you can curry the y.
17:36:24 <ReinH> At least, not without invoking some extra machinery.
17:36:31 <orion> erm hmm
17:36:50 <ReinH> or eta reduce the y, I guess
17:37:11 <ReinH> That is not an expression in a form that can be eta reduced.
17:37:35 <orion> Well, both (\x y -> foo x y >> bar y) and (\x -> foo x >> bar) work.
17:37:44 <ReinH> I don't believe you.
17:37:51 <ReinH> They are not equivalent.
17:38:12 <orion> Would you believe me if I said one of the type signatures has SomeException in it?
17:38:33 <ReinH> I'd believe you if you showed me something GHC will compile.
17:42:39 <orion> http://lpaste.net/1209293113575604224
17:43:37 <orion> setOnException is from Warp and has type (Maybe Request -> SomeException -> IO ()) -> Settings -> Settings
17:44:02 <ahihi> I think the first one typechecks because of the Monad instance for (->) r
17:44:08 <ahihi> but it won't do what you want
17:44:21 <orion> That's scary.
17:48:50 <ahihi> (\req -> logException exceptionLog req >> statsException) === (\req ex -> (logException exceptionLog req >> statsException) ex) === (\req ex -> statsException ex)
17:48:53 <ahihi> something like that
17:50:09 * hackagebot reflex-gloss 0.2 - An reflex interface for gloss.  https://hackage.haskell.org/package/reflex-gloss-0.2 (jeffreyrosenbluth)
17:51:10 <hanz> Is the Real World Haskell book not available online anymore?
17:51:26 <hanz> http://book.realworldhaskell.org/ doesn't connect for me anymore.
17:51:43 <puregreen> hanz: works for me
17:51:50 <ahihi> works here too
17:52:10 <puregreen> if it still doesn't work for you, perhaps try waybackmachine
17:52:14 <hanz> Bah, must be the train wifi
17:52:27 <Romefeller> Hi all
17:52:39 <Romefeller> anyone can help me with taggy-lens package?
17:54:45 <lambda-11235> Is it normal for my computer to crash when running sum [1..1e100]?
17:55:47 <geekosaur> it's not supposed to crash, but it's not surprising that it would take a fair amount of memory (and leave you to the tender mercies of your OS's out of memory handler)
17:56:30 <geekosaur> I think compiling with optimization loses most of the memory allocation, compared to using ghci
17:59:54 <lambda-11235> geekosaur: It does seem like ghci often causes crashes when doing expensive computations, while compiled haskell or other language repls wouldn't.
18:00:20 <geekosaur> ghci lacks a lot of smarts
18:00:28 <geekosaur> mostly due to lack of developer time
18:00:33 <Lokathor> lambda-11235, ghci doesn't do a JIT step or anything, it just interprets the computation, so it ends up being suuuuper slow sometimes
18:00:58 <geekosaur> not just super slow but often does a lot more allocation than the same thing compiled to optimized native code
18:02:29 <geekosaur> that said, hm, sum. is that foldl?
18:02:41 <dustmote> it's foldMap in prelude
18:02:49 <geekosaur> in 7.10, yeh
18:02:54 <geekosaur> is it morally foldl?
18:03:21 <geekosaur> (that is, does it build up unevaluated thunks like foldl, or does it operate strictly like foldl' ?
18:03:25 <dustmote> "    foldMap f = foldr (mappend . f) mempty
18:03:45 <dustmote> tbh, i don't know.
18:04:30 <ahihi> based on the memory explosion it causes, I'm guessing thunks
18:04:49 <geekosaur> IIRC in 7.10 there's a few cases of stuff converted to foldMap that ended up being foldl-like
18:05:00 <geekosaur> which means it runs out of memory anyway because it's too lazy
18:05:15 <dustmote> I love that we're so careful about documenting types, and so careless with documenting this kind of behavior. (But i guess the optimizer makes it hard to document this behavior..)
18:05:28 <geekosaur> (note, if it's 7.8.x or earlier, this won't apply)
18:10:10 * hackagebot xcffib 0.4.1 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.4.1 (TychoAndersen)
18:11:36 <geekosaur> dustmote, there's also that, with those things moved into a typeclass, the strictness likely depends on the instance
18:11:46 <geekosaur> to some extent
18:12:06 <dustmote> yes, good point. some of them didn't used to exist in a typeclass
18:12:25 <geekosaur> s/some/most/ actually
18:12:38 <geekosaur> Foldable is a monster these days
18:12:51 <dmj> the Show instance for PortNumber calls ntohs...
18:13:14 <geekosaur> dmj, have you met its Num instance yet?
18:14:56 <dmj> geekosaur: yes, but the problem is that hedis uses PortID for the ConnInfo, since I read it as an environment variable I need to parse it from its String representation
18:15:23 <dmj> the PortNum constructor is deprecated, and none of the conversion functions are exported
18:15:44 <EvanR> how about Read
18:15:47 * geekosaur would not have designed Network that way
18:16:48 <dmj> Read ruins it too
18:17:17 <dmj> λ> fromVar "6379" :: Maybe PortNumber  
18:17:25 <dmj> Just 60184 
18:17:53 <dmj> the app was trying to connect to redis on port 60184 :]
18:18:01 <dmj> fromVar = readMaybe (from Text.Read)
18:18:58 <geekosaur> yes. the ntoh stuff should have been completely hidden, instead we got this :(
18:19:20 <dmj> > read "6379" :: Word16
18:19:23 <lambdabot>  6379
18:19:26 <dmj> sigh
18:19:44 <dmj> yea, non-standard show instances are tricky
18:19:59 <EvanR> fromInteger (read "6379" :: Word16) ?
18:20:13 <EvanR> er
18:20:20 <EvanR> :: Integer
18:20:41 <dustmote> i think the HTTP module uses its show instances for putting stuff on the wire, and read instances for getting them off... as a result you can't roundtrip losslessly through read/show
18:20:53 <dustmote> so now we have wreq :D
18:21:14 <Lokathor> lossless read/show
18:21:16 <Lokathor> for shame
18:21:27 <Lokathor> wait i mean the opposite!
18:21:33 * Lokathor sighs
18:21:44 <lethjakman-l> So if (.) comes from category, why can I use it with every function? Shouldn't I have to make that function an instance of Category?
18:21:57 <dustmote> :t (.)
18:21:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:22:08 <geekosaur> because Category has its own, the normal one is in Prelude
18:22:16 <dustmote> :info Category
18:22:21 <geekosaur> no :info
18:22:23 <lethjakman-l> Ohhh. 
18:22:25 <dustmote> damn
18:22:38 <lethjakman-l> Why redefine something in prelude then?
18:22:41 <lethjakman-l> OH I see what you're saying. 
18:22:46 <lethjakman-l> (.) = (GHC.Base..)
18:22:50 <geekosaur> yes
18:23:09 <geekosaur> and then Category define a more "categorically correct" one
18:23:30 <lethjakman-l> Gotcha. 
18:23:32 <lethjakman-l> Thank you!
18:24:45 <geekosaur> (I *think* you can understand this as: Prelude (.) applies to Hask; Control.Category (.) applies to any category)
18:28:31 <dmj> <3 fromIntegral
18:29:21 <dmj> PortNumber $ fromIntegral (port :: Word16) got around it
18:29:32 * dmj wipes brow
18:52:19 <benzrf> lethjakman-l: because (->) has a Category instance
18:54:56 <EvanR> :: Integer
18:55:03 <EvanR> oops, though i was disconnected
18:57:02 <dustmote> what's the best way to hammer on a bunch of quickcheck properties?
18:57:31 <dustmote> I'm pretty sure a few of mine will fail if i can get them to run on more than 100 tests..
19:00:14 <kadoban> dustmote: You can specify how many times to run. You could also look at something like smallcheck in addition.
19:00:25 <kadoban> dustmote: How are you running the quickcheck tests? Any test runner framework thing?
19:01:14 <dustmote> kadoban: defaultMain from Test.Framework runs a testGroup::Test
19:01:40 <dustmote> my properties are constructed with testProperty from Test.Framework.Providers.QuickCheck2
19:02:08 <dustmote> i'm not using the TH stuff in quickcheck, though i could easily switch to that.
19:02:37 <kadoban> dustmote: I forget what the syntax is for specifying. Try running: whatever-the-test-binary-is --help or something?
19:03:12 <dustmote> kadoban: gah.. i'm in stack. let me see
19:03:48 <kadoban> dustmote: stack test --test-arguments "--help" maybe
19:04:15 <dustmote> nice! i didn't see --test-arguments
19:04:25 <kadoban> Yeah it's really useful :)
19:04:44 <dustmote> beautiful! this seems to be what i'm looking for
19:04:57 <kadoban> Cool
19:10:14 <dustmote> hm.. so `stack test --test-arguments -a1000` seems to be how you control the number of tests, but if that's too high you get "Arguments exhausted after 0 tests"
19:10:26 <dustmote> there's another option that has to do with the arguments, but i don't grok it yet
19:10:32 <dustmote> in any case, thanks kadoban 
19:13:15 <dustmote> ah, it's a bug with a workaround: https://github.com/batterseapower/test-framework/issues/34
19:13:47 <adamCS_> KaneTW: you around?
19:15:13 <KaneTW> adamCS_: yeah
19:16:34 <adamCS_> KaneTW:  just wanted to thank you again for the template haskell code.  Turns out the best tutorial is one written to do a thing you are interested in!  Now I understand a lot more TH (well, a little more) and I am starting to get it to do what I want.  I appreciate your time!
19:17:16 <KaneTW> haha, you're welcome
19:22:51 <dmwit_> dmj: I'm puzzled. What was the type of `port` before the ascription?
19:24:59 <Guest00000> > ()
19:25:01 <lambdabot>  ()
19:27:16 <dmj> dmwit_: so 'port' was of type PortNumber, where PortNumber = PortNum Word16. Silly thing is the Read / Show instances for PortNumber called htons and ntohs when dealing with the Word16
19:28:03 <dmwit_> I don't believe `port` was of type `PortNumber`; as then `port :: Word16` would be a type error.
19:31:16 <dmj> dmwit_: well I changed it to PortNumber $ fromIntegral (port :: Word16) since I neeeded to use the Num instance for PortNum (which is a hidden constructor)
19:34:03 <dmwit_> dmj: Okay. So what is the type of `port` before you ascribe it type `Word16`?
19:34:23 <glguy> My interpretation of dmwit_'s question was "Why not write   Portnumber (fromIntegral port)" or possibly just "Why not   PortNumber port"
19:34:44 <dmwit_> dmj: I'm not talking like, chronologically before in your development history. I'm talking logically before in the type inference algorithm.
19:34:51 <dmwit_> And yes, glguy has basically nailed by question on the head.
19:37:52 <geekosaur> I think the point is that network tosses in a free ntohs() unless you swizzle the types, and that breaks other consumers
19:38:10 <geekosaur> (network kinda sucks)
19:38:47 <glguy> You're not supposed to touch the constructor for the PortNumber type
19:42:11 <dmj> let me try and recreate, one second
19:43:02 <dmwit_> geekosaur: Ah. The ad-hoc part of ad-hoc polymorphism.
19:45:50 <fortruce> how can I tell quickcheck to not generate tests with empty lists?
19:48:21 <peddie> @check \xs -> not (null xs) ==> reverse (reverse xs) == xs
19:48:22 <lambdabot>  Couldn't match expected type ‘Test.QuickCheck.Safe.SProperty’
19:48:23 <lambdabot>  with actual type ‘[a0]’ Relevant bindings include xs :: [a0] (bound at <inte...
19:48:33 <peddie> hm, OK, that works with quickcheck locally . . .
19:48:42 <peddie> fortruce: ^^
19:48:53 <fortruce> oh that makes sense, thanks
19:53:02 <dmj> dmwit_: w/o fromIntegral it's "cannot match expected type PortNumber with Word16"
19:53:52 <dmwit_> dmj: Okay. So `port` already is known to have type `Word16`; and the type ascription probably isn't needed.
19:54:24 <dmj> dmwit_: yea, that was just for clarity
19:54:42 <mnoonan_> This is a bit of a shot in the dark, but does anybody have experience building accelerate-llvm on a newish os x version?
19:54:45 <dmj> it's still confusing though, since PortNum has no instances associated with it
19:54:59 <dmj> yet PortNumber does, but PortNumber needs a PortNum
19:55:14 * hackagebot dbmigrations 1.1 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-1.1 (JonathanDaugherty)
19:55:32 <dmwit_> Yeah, I've been confused by that in the past, too.
19:55:33 <dmj> oh I'm sorry, it's PortNumber = PortNum Word16, not PortNumber = PortNumber PortNum
19:55:46 <dmj> yea, glad that that's over
19:56:06 <tippeneinn> apparently 1Gb memory is not enough for ghc. has anyone else run up against this limit with builds?
19:56:15 <dmj> as you can tell, I'm still confused even after fixing it
19:56:40 <dolio> tippeneinn: I have a build that requires 10 GB.
19:56:54 <glguy> vector related?
19:56:58 <dolio> Yeah.
20:03:36 <mnoonan_> Specifically, I'm getting this error when stack tries to build llvm-general: http://lpaste.net/152205
20:04:16 <mnoonan_> and here is the relevant file: https://github.com/bscarlet/llvm-general/blob/master/llvm-general/src/LLVM/General/Internal/LibraryFunction.hsc  (no Main to be seen?)
20:07:25 <mgsloan> mnoonan_: Maybe take a look at the generated code?  (the filepaths to the .hs file are in the error)
20:09:05 <mnoonan_> mgsloan: weirdly, the .hs file is empty
20:09:13 <mgsloan> Note the error message is from GHC.  It happens when GHC's module header parser thinks it's encountered something that must come before "module Name where"
20:09:18 <mgsloan> *must come after
20:09:22 <mgsloan> Yeah, that'd do it
20:09:29 <mnoonan_> oh, implicit Main module?
20:09:32 <mgsloan> Maybe your hsc is broken
20:09:32 <mnoonan_> that makes sense.
20:09:51 <mgsloan> Err I mean hsc2hs
20:14:50 <radens> Is there a way to get rid of progHelper? https://pastebin.osuosl.org/37716/
20:17:52 <Stratege> radens - progHelper is just: \l -> fmap (l :)
20:19:45 <jle`> for second (l :)
20:19:48 <jle`> *or
20:22:20 <radens> Thanks
20:43:21 <dmwit_> You could also write `prog ls = catMaybes <$> mapM cmd ls` if you upgraded `cmd` appropriately. But that may be a bit ahead of your comfort zone if you're still learning Haskell.
20:45:22 <ReinH> It is also fmap . (:), but I don't think this is an improvement over \l -> fmap (l :).
20:45:49 <ReinH> Pointfree style should improve readability, not hinder it.
21:22:13 <Demon_Fox> Anyone know of some good free books to learn Haskell?
21:22:46 <kadoban> Demon_Fox: The best free way is probably the advice in https://github.com/bitemyapp/learnhaskell
21:25:17 <Demon_Fox> Thanks
21:56:31 <radens> dmwit_: thanks. If it weren't a homework assignment I probably would have used the state monad.
22:13:04 <jle`> oh i figured out a way to avoid all of those nested case statements when extracting existentials in gadt's
22:13:20 <jle`> use do notation with Identity :O
22:13:52 <MarcelineVQ> You madman
22:14:00 <jle`> instead of:
22:14:02 <jle`> case x of
22:14:06 <jle`>   Foo y ->
22:14:13 <jle`>     case y of -> .. etc.
22:14:33 <jle`> Foo y <- x; Bar z <- k; Baz a <- y; ... etc.
22:14:48 <jle`> um i guess that should be Foo y <- return x
22:14:55 <jle`> Bar z <- return k, etc.
22:15:22 <jle`> now i don't have to have all that indentation creep
22:16:18 <jle`> 'do notation considered useful'
22:16:44 <exio4> jle`: I normally solved it with the CPS-equivalent/(forall r. r -> a) -> a version
22:16:58 <jle`> exio4: yes, but not every type offers that
22:17:07 <jle`> and i keep on submitting PR's to libraries that don't >_>
22:17:11 <exio4> jle`: you just need to write such function ;)
22:17:23 <jle`> but i'd have to do it for every one :O
22:17:33 <exio4> it's for a greater good!
22:17:33 <jle`> well my favorite thing is actually withFoo x $ \y -> ...
22:17:48 <jle`> but that still has to be written on a per-existential basis
22:18:28 <jle`> (that is, giving a way to change the existential type into the continuation version)
22:19:12 <exio4> withFoo looks nicer infix
22:19:28 <jle`> to avoid the $ ?
22:19:35 <exio4> x `withFoo` \y -> 
22:19:52 <exio4> we just need a polymorphic with now..
22:41:27 <zd234> is reflex-frp supposed to be fast or laggy on a $150.00 chromebook? (intel celeron + 2gb ram)
22:41:34 <zd234> i'm not talking compilation, I'm talking running the generate *.js file
22:41:45 <zd234> I appear to get noticable lag just from an input field (admittedtely it's done all in svg)
22:41:59 <zd234> it's rather smooth on my surface pro 3; but appears laggy on my $150.00 chromebook
22:56:31 <tippeneinn> is it unreasonable to think a compiler should use less than 1 gig of memory for a build?
22:57:17 <erikd> tippenein: for a C compiler yes. others maybe not :)
23:19:17 <koz_> Could someone please ELI5 what the Reader monad is all about?
23:21:55 <keko-2> passing some data that doesn't need to be modified, like configuration parameters
23:22:36 <liste> or IORefs for data that needs to be modified (:
23:24:27 <liste> @src Reader
23:24:27 <lambdabot> Source not found. My pet ferret can type better than you!
23:25:51 <liste> > runReader 5 $ do { x <- ask; y <- ask; return (x + y) }
23:25:53 <lambdabot>      Could not deduce (Num b0)
23:25:53 <lambdabot>      from the context (Num b, Num (Reader (m b) a), MonadReader b m)
23:25:53 <lambdabot>        bound by the inferred type for ‘e_15’:
23:26:19 <maybefbi> how to not print () in the end of my program
23:27:13 <liste> maybefbi: can you show us the code?
23:27:14 <liste> @paste
23:27:14 <lambdabot> Haskell pastebin: http://lpaste.net/
23:27:20 <maybefbi> ok wait
23:29:03 <lpaste> maybefbi pasted “This one prints () after running” at http://lpaste.net/7174800944515776512
23:29:19 <maybefbi> liste, done
23:30:54 <liste> maybefbi: what does your main look like?
23:31:55 <maybefbi> like this: main = generateReport
23:33:20 <liste> maybefbi: what's the value of `e' in generateReport
23:33:44 <liste> (or, alternatively, the type)
23:35:17 <maybefbi> liste, access :: MonadIO m => Pipe -> AccessMode -> Database -> Action m a -> m a
23:35:45 <maybefbi> here is the documentation for access "Run action against database on server at other end of pipe. Use access mode for any reads and writes. Return Left on connection failure or read/write failure."
23:35:47 <liste> what's the `a' in that
23:35:47 <koz_> I'm also having some trouble understanding wtf an Alternative is supposed to be.
23:36:08 <liste> maybefbi: what's `a' in your specific case
23:36:18 <maybefbi> liste, i just ghc-mod the type of e and it is ()
23:36:27 <liste> ... and you print e
23:36:30 <maybefbi> yeah
23:36:32 <maybefbi> thanks
23:36:46 <liste> yw (:
23:36:52 <maybefbi> shit i should have guessed that myself
23:37:59 <liste> koz_: Alternative gives extra monoidal structure to Applicative
23:38:19 <liste> it's used e.g. in parsers and computations that may fail
23:38:48 <liste> > (Nothing) <|> (Just 5) <|> (Nothing) <|> (Just 7)
23:38:50 <lambdabot>  Just 5
23:39:27 <phadej> Maybe is not so good example, as it's Monoid and Applicative instances don't agree
23:39:34 <phadej> > [1, 2, 3] <|> [4, 5, 6]
23:39:36 <lambdabot>  [1,2,3,4,5,6]
23:40:48 <zd234> how do I get better and better at declarative programming?
23:40:57 <zd234> I want the focus on "what" rather than "how"
23:42:20 <jle`> just apply it to the things you do every day :)
23:42:29 <jle`> find opportunities in your life for you to apply it
23:42:32 <jle`> and take advantage of them
23:42:43 <jle`> s/find/recognize
23:43:45 <jle`> and read/try out examples of people applying it :)
23:46:08 <lpaste> maybefbi revised “This one prints () after running”: “No title” at http://lpaste.net/7174800944515776512
23:57:43 <ReinH> phadej: Yes, this is an annoying problem with Maybe. There are two good options for the Monoid instance and the one we have is neither of them.
23:58:32 <ReinH> imo (and I think McBride's) the Maybe monoid should match the applicative, e.g., work like First. Then something else should be the semigroup + identity.
23:58:48 <ReinH> s/e.g./i.e.
