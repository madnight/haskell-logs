00:00:58 <nachoman> thanks! and do you have a guide or something for internals?
00:01:20 <Welkin> @where learnhaskell
00:01:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
00:01:36 <Cale> nachoman: Internals as in GHC's implementation?
00:02:14 <nachoman> hmm yes
00:02:44 <EvanR> whats another operator for (.)
00:03:02 <ahihi> (○)
00:03:04 <Welkin> (.).(.)
00:03:39 <liste> :t (>>>)
00:03:41 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
00:03:44 <nachoman> Cale: that would be great
00:04:05 <Cale> GHC is big, and there are a lot of aspects to it, from the type checker, to the simplifier, Core to STG and then STG to Cmm and then Cmm to various other things...
00:04:08 <liste> > ((/2) >>> (+1)) $ 4
00:04:09 <lambdabot>  3.0
00:04:12 <EvanR> clobbering >>> will have to do
00:04:22 <nachoman> good :)
00:04:45 <nachoman> do you have some resources to learn that?
00:04:54 <Cale> nachoman: But if you're interested in how Haskell gets run, a good place to begin is the STG machine paper -- it's old and not really up to date with respect to how modern GHC does things, but it has a good discussion of approaches
00:05:11 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
00:05:37 <liste> :t (<<<) -- EvanR this is the same way around as .
00:05:38 <Cale> especially the "Exploring the design space" part
00:05:38 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
00:05:51 <MarcelineVQ> Cale: have you seen his "a tutorial" one?
00:05:57 <nachoman> thanks!!! :D exciting
00:06:01 <Cale> MarcelineVQ: hm, I'm not sure
00:06:36 <Cale> nachoman: But note that at least personally, I almost never think at that low a level of abstraction while writing Haskell code, even when thinking about performance.
00:06:37 <MarcelineVQ> It might just be an alternate title even, lemme compare
00:07:37 <nachoman> I know, It is just curiosity, I want to know about language internals to build my own compiler ;)
00:07:47 <MarcelineVQ> hmm, nah it's different, idk why the year says 92 on the page, http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
00:07:58 <Cale> nachoman: Typically, I picture evaluation as rewriting expression graphs (which are like expression trees, except they're directed graphs which can contain cycles. Actually, even that's more than you usually need, and can usually just imagine expressions being rewritten.
00:08:43 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html -- this language is really nice for showing you the graphs... I wish he'd release an implementation of it
00:09:29 <nachoman> omg, this it how it parses those expressions
00:09:42 <nachoman> thank you very much
00:10:04 <Cale> Well, it's a pictorial representation of something kind of similar to what's going on in memory
00:10:05 <EvanR> :t apply
00:10:06 <lambdabot> Not in scope: ‘apply’
00:10:38 <Cale> (this HOPS language also isn't quite the same as Haskell)
00:11:09 <nachoman> i like this kind of things, i'm in comp science :P
00:11:10 <Cale> (but the idea that you're rewriting graphs in memory is a useful thing to hold on to)
00:12:07 <nachoman> ok I see
00:12:11 <Cale> If you read the STG machine paper I linked, you'll find out how close it comes to being the literal truth of what's going on :)
00:13:20 <nachoman> I'm looking the paper
00:13:46 <Cale> Of course, there are *lots* of optimisations and stuff obscuring the picture, and by the time GHC has done all that, it's hard to really recover the expressions -- but if your program would perform well doing graph rewriting, it'll probably perform well compiled by GHC.
00:17:11 <nachoman> this is fantastic :p
00:18:46 <nachoman> it is crazy to learn a language by studying the compiler :p
00:19:52 <Cale> nachoman: A bit. Especially in the case of Haskell, where we tend to have pretty good ways of completely disregarding implementation details.
00:21:34 <Cale> nachoman: Like, if all you care about are the results of your functions and not the performance, then interpreting the language into mathematics is probably a quicker route to understanding than interpreting it into x86 assembly :)
00:22:19 <Cale> (or just treating the language directly like mathematics and substituting things for their definitions)
00:22:38 <nachoman> oh for sure, I did some scheme in the college, and I felt like a blind
00:31:45 <EvanR> is there a list of top level namespaces
00:31:54 <EvanR> or break down of conventional namespace hierarchies
00:34:42 <orion> < liste> orion: did you link C libraries (glibc etc) statically too? <-- you mean recursively?
00:37:14 <liste> orion: recursively?
00:38:08 <liste> orion: no, I just meant statically linking glibc (and maybe other non-Haskell libraries)
00:38:41 <liste> Haskell libraries are always linked statically AFAIK
00:38:48 <liste> (not always, but by default)
00:39:51 * hackagebot alga 0.2.0 - Algorithmic automation for various DAWs  https://hackage.haskell.org/package/alga-0.2.0 (mrkkrp)
00:41:47 <orion> liste: I added -static -pthread to ls-options in the cabal file and got a completely static binary, as reported by the `file` program. Is that what you mean?
00:41:58 <liste> orion: yes
00:42:09 <liste> glibc doesn't like static linking
00:42:22 <liste> you'd need to use some other libc, like musl
00:43:45 <liste> and you'd need a musl-based OS for that, like Alpine Linux for example
00:44:38 <orion> Ah, sad. :(
00:47:16 <liste> although it technically should work if you're running it on your machine
00:47:25 <liste> with the same glibc version
00:47:36 <orion> Same OS, different machine.
00:47:43 <orion> Same architecture
00:47:48 <liste> different glibc version?
00:49:38 <liste> orion: why are you linking statically? is there some C library as a dependency for your program you don't want to install on other computers?
00:49:52 * hackagebot cacophony 0.5.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.5.0 (jgalt)
00:50:18 <orion> liste: Yes, confirmed with md5sum
01:09:52 <superlinux> hi. I want a book very much like Deitle's "How to program " series . after reading "Learn you a haskell for great good" i felt it's also not suitable for beginners too. please , if there is such a book, tell me about it.
01:17:11 <liste> superlinux: maybe http://haskellbook.com/ ?
01:17:27 <superlinux> liste, looks like that
01:17:41 <superlinux> but it's still not finished yet.
01:17:50 <liste> well, it's 80% done
01:18:06 <liste> so I guess you can already start reading it
01:18:29 <superlinux> I would pay. I never mind early access. Haskell is NOT taught in the Arab world.
01:19:33 <Ralith> it's not taught most places
01:20:27 <liste> KL–>
01:24:15 <nymacro> Hi #haskell. Is anyone familiar with cryptonite package? I am having trouble figuring out how to load a P256 point via pointFromBinary and somehow caress it into a PublicPoint
01:25:15 <nymacro> I might be doing the completely wrong thing. But I have no idea (I am trying to get web push working from a Haskell server)
01:25:57 <ner0x652> superlinux: Do you think that "Learn You a Haskell" is not good for computer programming beginners or for Haskell beginners?
01:26:18 <superlinux> yes .. it's not good at all.
01:26:31 <superlinux> I am now in section 8.6
01:26:57 <dramforever> IMHO LYAH is like a highly elaborate introduction for non-Haskellers to get a taste of Haskell
01:27:25 <ner0x652> I am at section 6
01:27:41 <ner0x652> I consider it to be a good (free) resource to learn Haskell
01:27:44 <superlinux> till now, all I can do is define factorial function in the recursive way.
01:28:10 <superlinux> Deitle books are seriously awesome. 
01:28:11 <geekosaur> it's a decent grand tour of haskell. it's lousy for learning how to write haskell.
01:28:57 <ner0x652> hmmm, I don't know.  For example I know more about high-order functions, about partial functions, about currying. I understood better guards and pattern matching.
01:29:03 <orion> nymacro: Can you show me your code thus far?
01:29:12 <superlinux> In beirut like all uni's teach using its C++ book and Java books. and also his VB books students used to fight to get it.
01:29:41 <ner0x652> Maybe you should try Real World Haskell, I heard it is for those who already know Haskell, let's say at intermediate level.
01:30:26 <nymacro> orion: actually, I think I might have figured it out. There is a pointToIntegers to get the x,y from P256's Point. From that I can create a "generic" ECC.Types' Point
01:30:49 <liste> I learned Haskell from Real World Haskell
01:31:04 <nymacro> I was trying to get from Crypto.PubKey.ECC.P256.Point + pointFromBinary, to Crypto.PubKey.ECC.Types.Point
01:31:06 <liste> I liked that approach and the exercises
01:31:10 <superlinux> ner0x652, what I want is Haskell book for someone who has never EVERR had anything to do with programming.
01:31:24 <ner0x652> I guess there are many good resources that you can pick up and learn from them, some concepts from a book, others from anothers.
01:31:25 <nymacro> I was actually looking around a while for this last night. :(
01:31:46 <nymacro> orion: Thanks though. I will give this a try. If I can't piece it together from this, I will post something up
01:31:52 <orion> ok
01:32:09 <ner0x652> Somebody told me that they learned Haskell from Write a Scheme Interpreter in 48 hours( or something like that), but I found it hard.
01:32:17 <superlinux> ner0x652, for me, I am a 10 year graduate programmer. I worry about the novice students
01:32:28 <dramforever> I think by the time I can afford the haskellbook, it will be complete :P that's my long-term plan so far
01:32:31 <superlinux> my plan is to be a haskell teacher.
01:32:55 <ner0x652> superlinux: Understood
01:33:05 <dramforever> wow that was *some* plan
01:33:29 <ner0x652> Try some online tutorials like that one from Google, that uses Haskell
01:35:43 <ner0x652> superlinux: Start a project on what you want to have... if you think there is a problem with this, why not try to solve it? :)
01:37:00 <superlinux> ner0x652, my project as always will be a database forms app.
01:37:35 <superlinux> this is the best way in my opinion to learn a language and benefit commercially from it.
01:38:46 <liste> superlinux: a web-based one?
01:38:55 <superlinux> no
01:39:01 <superlinux> desktop app
01:39:22 <superlinux> web based implies using yesod
01:39:27 <dramforever> no
01:39:37 <liste> there's a ton of web frameworks for Haskell
01:39:43 <earthy> https://github.com/bitemyapp/learnhaskell ?
01:39:51 <liste> desktop, on the other hand, is a bit underdeveloped
01:40:12 <superlinux> yeah I understand. but yesod is all i know about haskell for web 
01:40:14 <liste> most desktop GUI toolkits are thin wrappers and encourage imperative code
01:40:32 <merijn> That's because designing GUI toolkits is a pain
01:40:46 <merijn> Hell, most desktop toolkits suck even in imperative language, in my experience
01:41:14 <liste> the request->response cycle of the Web suits very well for a functional approach, otoh
01:48:55 <jakub_> Hi, haskell.org/news does not seem to update the list of new posts on reddit
01:49:25 <jakub_> where should one report this?
02:09:50 <anakreonm> Hello. I wrote a hoopl transformation with the following signature: rewrite :: (UniqueMonad m, CheckpointMonad m, FuelMonad m) => Stm -> m (Graph Insn O O) where Stm is the AST of the original language. How do I execute the method? I know the runSimpleUniqueMonad function which executes a computation under a unique and checkpoint context but don't 
02:09:50 <anakreonm> know how to provide a FuelMonad context
02:11:12 <anakreonm> I would like to have a function f :: Stm -> Graph Insn O O which would call rewrite
02:15:24 * hackagebot pipes-cacophony 0.2.0 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.2.0 (jgalt)
02:18:09 <superlinux> early access to the haskell book is disallowed to Beirut
02:33:14 <liste> superlinux: maybe bitemyapp (one of the authors) can help you with that?
02:41:37 <lyxia> anakreonm: runWithFuel seems to fit
03:00:39 <anakreonm> lyxia: The caller should provide several context at once. runWithFuel provides a Fuel context and runSimpleUniqueMonad the Checkpoint and Unique monad. I'm having trouble combining the two. For example runWithFuel 12  . runSimpleUniqueMonad . rewrite does not typecheck
03:03:41 <lyxia> anakreonm: runWithFuel still returns a monadic value, whereas runSimpleUniqueMonad doesn't, so I'd put them in the reverse order
03:35:15 <vkt> how does the return in a do block know which monad to encapsulate the result with?
03:36:43 <liste> vkt: type inference
03:36:45 <merijn> vkt: Type checker infers it
03:37:00 <liste> probably from your top-level type annotation
03:37:41 <vkt> so it has nothing to do with the sequence of bindings I make ? IO, x <- Just 4, y <- [1,2,3] etc?
03:37:44 <dramforever> :t return "x" -- It's probably kept polymorphic in the monad
03:37:45 <lambdabot> Monad m => m [Char]
03:38:09 <dramforever> vkt: yes, it might help if you understand the desugaring of do-notation
03:38:36 <merijn> vkt: All bindings in the block must be the same monad (due to the way do notation desugars)
03:38:38 <dramforever> do { x <- m; return (f x) } = m >>= \x -> return f x, and:
03:38:41 <vkt> dram you mean bind?
03:38:43 <dramforever> :t (>>=)
03:38:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:38:52 <merijn> vkt: Do notation desugars into >> and >>= which uses the same monad on both sides
03:38:54 <dramforever> vkt: do you know how do is a syntax sugar?
03:39:00 <EvanR> > Nothing >> return 4
03:39:01 <lambdabot>  Nothing
03:39:11 <vkt> dramforever: yes vaguely
03:39:14 <liste> > do { x <- [1,2,3]; y <- Just 5; return (x + y)} -- does not type check
03:39:15 <lambdabot>      Couldn't match expected type ‘[b]’ with actual type ‘Maybe Integer’
03:39:16 <lambdabot>      Relevant bindings include x :: b (bound at <interactive>:1:6)
03:39:16 <lambdabot>      In a stmt of a 'do' block: y <- Just 5
03:39:37 <vkt> but your info already has been great help
03:39:43 <EvanR> ouch bad lag
03:39:54 <EvanR> > Nothing >> return 4
03:39:56 <lambdabot>  Nothing
03:40:04 <merijn> vkt: I recommend reading this: https://en.wikibooks.org/wiki/Haskell/do_notation
03:40:12 <dramforever> vkt: See the "Translation" box in: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
03:40:29 <vkt> thx
03:40:36 <merijn> I generally recommend beginners to avoid do-notation until they know how to write the same code WITHOUT do notation, because that means you have a better understanding of what's going on
03:41:00 <dramforever> hmm... the "p" part has to do its work with patterns, I hope you can understand it
03:41:25 <merijn> dramforever: I think the wikibook is more accessible than the report for beginners
03:41:42 <EvanR> freenode is collapsing
03:42:08 <dramforever> merijn: Yeah, TIL there's a great wikibook over there
03:42:19 <dramforever> I haven't really read it before
03:42:20 <merijn> The wikibook quality varies
03:42:33 <kqr> wikibook wasn't great 7 years ago. glad if it has been improved
03:42:36 <merijn> but the do notation, GADT chapter, and iirc arrow chapters are ok
03:42:57 <merijn> kqr: I dunno, I just cherry-picked the chapters I found well written and link those when relevan
03:43:08 <kqr> yeah
03:43:09 <merijn> Oh, the chapter on layout rules is good too
03:43:19 <kqr> i haven't looked at the book for a long time
03:43:25 <kqr> i looked at it when I tried learning haskell
03:43:31 <kqr> which was probably more years ago than I care to admit
03:44:40 <oherrala> kqr: I have been trying to learn since probably 2005
03:44:47 <kqr> haha
03:45:13 <kqr> I'd like to say I've learned haskell now
03:45:27 <kqr> but of course there are all those ghc extensions and libraries and whatnots
03:45:47 <dramforever> Other languages: There's always something I can learn
03:45:55 <dramforever> Haskell: There's always something I CAN'T learn
03:46:40 <dramforever> All sorts of extensions or categories of watmorphisms I hope to learn, but they make my head hurt
03:47:41 <python476> dramforever: I feel the opposite somehow
03:48:06 <python476> most other languages are full of stuff that makes me cringe because too ad-hoc, haskell hurts but in a fair way
03:48:39 <dramforever> python476: yeah I guess we mean the same thing
03:48:42 <merijn> IMO most of the extensions aren't that complicated
03:49:10 <EvanR> they just dont have the same level of accessibility
03:49:14 <EvanR> and tutorial support
03:49:19 <EvanR> just random blog posts
03:49:19 <merijn> dramforever: Which extension(s) makes you feel it's too hard to learn?
03:49:46 <dramforever> The more complicated ones like syb, Generics, TH
03:49:59 <python476> the formal logic lingo is still weird to me, forall, exists .. I never ever got them even in college logic classes
03:50:00 <merijn> Generics and syb aren't extensions
03:50:11 <dramforever> Those LambdaCase, MPTC, etc. are easier
03:50:14 <merijn> dramforever: What's the issue with TH?
03:50:36 <dramforever> Just can't wrap my head around it. Don't worry, it's okay
03:50:46 <dramforever> You need not try to make me feel it's easy
03:51:00 <EvanR> its not easy
03:51:12 <EvanR> the type errors i was getting earlier were insane
03:51:16 <EvanR> and made no sense
03:51:21 <dramforever> Guess if I put in enough effort it will make sense
03:51:28 <merijn> I always though TH was one of the easiest things to explain (not too understand how it all works)
03:51:34 <EvanR> my problem ended up being i didnt actually enable the extension...
03:52:19 <dramforever> merijn: Fine, added to TODO list: learn TH
03:53:00 <python476> TH as in Template Haskell ?
03:53:07 <dramforever> yep
03:53:11 <merijn> python476: I don't know another TH :)
03:54:21 <merijn> dramforever: In essence it boils down to a preprocessor like CPP, with the fairly important distinctions 1) the language of your macros is Haskell, instead of some braindead macro language and 2) instead of generating plain text you generate an AST directly, reducing silly typos
03:56:10 <dramforever> merijn: thanks, noted
03:56:48 <dramforever> Ah, so like metaprogramming with all the magic, but without the silly syntax errors?
03:56:55 <dramforever> s/like/it's
03:57:46 <merijn> dramforever: It's not "like" metaprogramming, it IS metaprogramming
03:58:22 <dramforever> hmm... I thought I said "s/like/it's", but yes, I agree
03:58:31 <merijn> It's just "using haskell at compile time to generate haskell that you actually wanna compile", i.e. generating boilerplate lens code or whatever
03:59:05 <dramforever> Sounds useful
03:59:08 <EvanR> ah... so thats why it cant just be a function
03:59:11 <merijn> The hardest part is basically that haskell's AST is kinda verbose and the API for reifying/inspecting things isn't very readable
03:59:20 <EvanR> unlike lisp where there is nothing going on at compile time
03:59:38 <EvanR> so im still confused why metaprogramming is so necessary there
04:00:03 <dramforever> Runtime metaprogramming sounds plausible
04:00:18 <dramforever> like you can give an object different methods depending on the JSON you used to construct it
04:00:24 <merijn> Quoting helps with the AST verbosity, i.e. "[| expr here |]" just asks GHC to parse some normal haskell and return the AST for it
04:00:28 <dramforever> but basically a big no-no in Haskell
04:00:34 <EvanR> dramforever: see that is just a function
04:00:48 <EvanR> that creates objects
04:00:53 <merijn> The reifying/inspection bit stays a bit of a hassle, but with some effort you can grok most of it from the haddocks
04:01:04 <merijn> And you can do lots of neat things without reifying stuff
04:01:46 <merijn> The biggest issue with TH is that while it produces valid haskell ASTs, it doesn't guarantee the generated ASTs type check, so you might generate code that doesn't type check and then get confusing compilation errors referring to non-existent code
04:02:02 <merijn> Although we've had Typed TH for a while now, which should eliminate that issue
04:03:11 <python476> I just saw strong rebuttals about TH, so I'm surprised people talk about it here
04:03:35 <merijn> python476: "Rebuttals about TH" <- what do you mean?
04:04:02 <dramforever> merijn: One of the things that made me feel weird is that generated ASTs can also fail to parse. I sometimes run into it when using TH with packages like persistent.
04:04:10 <python476> merijn: my memory fails but on a thread someone describing how to use Haskell in production said TH was an antipattern somehow
04:04:16 <dramforever> It's because extensions required are not enabled :P
04:04:26 <dramforever> python476: TH is slow, do you mean that?
04:04:35 <dramforever> http://www.stephendiehl.com/posts/production.html
04:04:48 <ggole_> dramforever: metaocaml is a reasonable runtime metaprogramming design
04:04:52 <merijn> python476: I think that's nonsense
04:05:03 <python476> exactly this article, but below
04:05:07 <ggole_> Although the focus there seems to be specialisation rather than abstraction.
04:05:12 <merijn> python476: Lots of problems DON'T require TH, but there's tons of problems that are best tackled with TH
04:05:18 <python476> ok
04:05:29 <KaneTW> considering TH an antipattern is a pretty bold claim
04:05:45 <python476> as a newb it felt like cancelling the generic mechanism of nonTemplate haskell
04:05:49 <merijn> python476: That post's biggest concern is "build time" which is fair
04:05:56 <dramforever> "Avoid TemplateHaskell as it can cause ridiculously inflated build times and enormous memory footprints in GHCi."
04:05:57 <python476> or a bad solution
04:06:12 <merijn> python476: I mean, you're running a bunch of code at compile time, which will obviously slow your build time
04:06:48 <merijn> python476: He's also saying "a lot of uses of TH can be avoided with high level design", which is true. But somethings are fundamentally impossible/really ugly without TH
04:06:53 <dramforever> If only we had this implemented https://ghc.haskell.org/trac/ghc/ticket/5016 (Make Template Haskell: -ddump-splices generate executable code)
04:07:07 <python476> merijn: the paragraph below "Avoid TemplateHaskell."
04:07:08 <dramforever> then we can get this into ghc-mod or something
04:07:13 <python476> it's not about speed or build time
04:07:19 <merijn> python476: TH lets you do things like embed entire files into your binary, see for example: https://hackage.haskell.org/package/file-embed
04:08:16 <merijn> python476: He's talking from the perspective of someone doing commercial business code in haskell, not everything that applies there applies everywhere
04:09:01 <python476> ok ok
04:09:16 <merijn> python476: I think I've used TH like 3 or so times in a few years of haskell. It's one of those things that is rarely useful, but when it is, it's irreplaceable
04:10:41 <python476> I hope it wasn't to embed files into your binary ~_~
04:10:50 <KaneTW> i used TH to generate proof terms for some existential stuff i was doing
04:11:04 <KaneTW> kind of like a replacement for Coq tactics
04:11:22 <python476> is there such a thing like Template Coq ?
04:11:24 <merijn> python476: I've done that before (not in haskell)
04:11:43 <merijn> python476: Embedding files in binaries is very useful if you wanna be easily portable
04:11:48 <KaneTW> no, and it's not really needed
04:11:57 <merijn> i.e. embedding OpenCL kernels into binaries
04:12:14 <dramforever> python476: why not use Ltac?
04:12:21 <tdammers> fwiw, TH is a life saver for my current project
04:12:38 <dramforever> with 8.5 you can already use ltac:(intuition) or so as a galinna term
04:12:47 <dramforever> but it's getting a bit off-topic I think
04:13:01 <KaneTW> i'm tempted to rewrite that project in idris anyway
04:13:02 <KaneTW> at leas
04:13:14 <KaneTW> at least the parts i want verification for
04:13:28 <python476> Id love to see the things you do
04:13:39 <python476> are you all PhD students ? 
04:13:43 <tdammers> nope
04:13:53 <KaneTW> nop
04:13:58 <python476> it seems so far from the mainstream (to me at least)
04:14:12 <tdammers> programmer in the trenches, but using haskell for a real-world project right now
04:14:18 <python476> ((and my nickname is an unfortunate collision))
04:14:30 <tdammers> granted, our team is supposed to produce "innovation", whatever that's supposed to mean
04:14:52 <python476> you saw the talk about 'why greatness cannot be planned'?
04:14:57 <tdammers> so we have more freedom than our colleagues in the larger assembly line programming department
04:14:57 <merijn> I'm a PhD student, but sadly not remotely haskell or programming languages related :p
04:15:15 <merijn> (Because no one was willing to pay me for that >.>)
04:15:24 <tdammers> my colleagues love clojure, but they're much younger and their brains still work flawlessly
04:15:57 <python476> the few IT shops I visited froze at the mention of clojure
04:15:59 <KaneTW> i'm 23 and i don't really like clojure and similar
04:16:23 <python476> I thought I insulted them
04:16:54 <python476> KaneTW: I don't "love" clojure anymore, but is a damn nice porcelain layer for the JVM though
04:17:40 <python476> I should go back to my clojure book, IRC is too distracting
04:17:41 <tdammers> clojure is in a weird spot, being both dynamically typed and unsuitable for the situation where dynamic typing is at its best
04:18:07 <python476> meaning ?
04:18:25 <python476> the JVM is still too static friendly to leverage the lisp roots ?
04:18:39 <tdammers> what I mean is that dynamic typing is particularly useful for things like shell scripts, one-off hack jobs, quick prototyping, and scripting more complex host systems
04:19:04 <tdammers> but you don't write shell scripts in clojure, because startup times
04:19:28 <python476> but I believe it's used in this way, just not for single user shell scripts
04:19:31 <tdammers> you don't use it for quick hack jobs either, because the project startup cost is a fair bit higher than, say, perl or python
04:19:49 <python476> most people wrap Java subsystems and juggle with them in clojure
04:20:28 <tdammers> well, yes, but that only makes sense if you're either scripting things in an existing Java ecosystem, or you are committed to producing a fairly large system already
04:20:48 <tdammers> and if you're going to write a large system anyway, I'd much rather use something typed
04:21:57 <tdammers> the benefits that clojure has over, say, Python, are benefits that you'd typically want for developing large applications, and the price you pay mostly hurts small applications, so clojure is clearly somewhat biased towards larger, long-lived systems with certain quality standards
04:22:13 <python476> I was wondering what would have happened if Rich Hickey was inspired by Haskell rather than Lisp when he started clojure
04:22:23 <tdammers> Hickey is very familiar with Haskell, it seems
04:22:39 <tdammers> and he did actually take a lot of Haskell ideas into clojure
04:22:51 <python476> but he was clearly aiming at a lisp more than a ML 
04:22:54 <tdammers> but his stance seems to be that a type system isn't worth the effort
04:23:16 <python476> I remember few comments about that 
04:23:41 <python476> 'bugs passed (tests and) type checker'
04:24:28 <tdammers> yeah, but the fallacy there is to argue that since type checkers do not prevent *all* bugs, they are therefor completely useless
04:24:40 <python476> :)
04:25:28 <tdammers> also, the people who argue this completely miss the point - type checkers aren't just reactive safeguards, they can be leveraged proactively
04:25:32 <python476> after a few ml classes, composing functions in lisp quickly makes you miss a typechecker
04:25:34 <tdammers> what is sometimes called "type driven development"
04:25:48 <python476> it allows for a little more acrobatics in abstractions
04:26:05 <python476> tdammers: understood
04:26:05 <tdammers> you can do the same acrobatics in lisp, but you need to do the type checking yourself
04:26:13 <python476> in a way I experienced this long ago in .. Java
04:26:33 <python476> I abused the typechecker to keep in flow while designing interfaces
04:26:39 <python476> it was a tiny logical assistant
04:26:55 <tdammers> the development cycle changes from "what do I want the program to do" to "what are the properties of the things I have, and what are the properties of the things I want, and how can I turn one into the other"
04:26:57 <python476> tdammers: my code is littered in ;; a -> b 
04:27:02 <tdammers> haha yeah
04:27:06 <tdammers> I write JavaScript like that
04:27:18 <python476> people are almost about to make it into a convention
04:27:19 <ggole_> I miss some things from Lisp, like variadicity
04:27:27 <python476> //+ <fun> :: <type>
04:27:41 <ggole_> (Typed racket can express it.)
04:27:48 <tdammers> the general concept is called "Hindley-Milner type hints"
04:27:51 <hectortrope> hi this is haskel channel ? I see python and js stuff 
04:27:53 <hectortrope> ?
04:27:54 <python476> that's an ad-hoc js one, others are reusing... typescript I believe
04:27:57 <tdammers> Haskell didn't invent them even
04:28:09 <Taneb> hectortrope, yes, this is the Haskell channel
04:28:15 <tdammers> hectortrope: we're comparing Haskell to various other languages
04:28:25 <python476> hectortrope: if you want me to shut it I can, if that's just a comment about the openness of #haskell then you're right
04:28:44 <tdammers> might be #-blah material
04:29:00 <python476>  #emacs too
04:29:06 <merijn> tdammers: Any sufficiently large lisp program contains an ad-hoc, ill-specified and bugridden implementation of half of Hindley-Milner in the comments :)
04:29:38 <python476> what's the next step after HM ? is it a global maxima ?
04:29:50 <tdammers> merijn: sounds suspiciously like something I said a while ago: "Any sufficiently complex program will at some point contain an ad-hoc, ill-specified, bug-ridden implementation of a type system"
04:30:07 <python476> I look at DT but people say it has drawbacks
04:30:10 <merijn> python476: Hindley-Milner is just a specific type-checking and inference algorithm, there are other algorithms and certainly more complex typesystems
04:30:15 <KaneTW> you can definitely go more complex than HM
04:30:44 <merijn> python476: The defacto standard paper on this is the lambdacube paper "Introduction to Generalised Type Systems" by Henk Barendregt
04:31:03 <merijn> python476: But that assumes familiarity with basic type systems
04:31:06 <python476> I wonder what concepts they use. I'm so used to think that functions are universal
04:31:28 <merijn> python476: Insert obligatory recommendation of TaPL here
04:31:30 <merijn> @where tapl
04:31:30 <python476> merijn: I have this one 1032 times in my bookmarks I believe
04:31:30 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:31:47 <tdammers> anyway, some type system praise: I have a library that wraps around PhantomJS and exposes a Haskell EDSL, and I rewrote it to use HTTP rather than pipes (because, in a nutshell, pipes proved too brittle, stray prints would break the protocol, and concurrent requests were a nightmare)
04:32:14 <tdammers> so I changed the relevant stuff, then fixed all compiler errors, and everything just worked
04:32:20 <python476> future software will be n-dimensional curved topologies. Simple really
04:32:38 <tdammers> hooked the new library version into the main project, and everything works, first attempt. No bugs.
04:32:46 <tdammers> no new ones, anyway.
04:32:51 <hectortrope> all haskelers are mostly professors top developers and pure programmers and no way a common programmer knows haskel Right? am I correct ? 
04:33:22 <tdammers> hectortrope: not at all
04:33:33 <python476> hectortrope: I wonder how long can a haskeller survive on Visual Basic 6
04:33:49 <ner0x652> hectortrope:I consider that your hypothesis is wrong :)
04:33:50 <Jinxit> python476: please
04:33:55 <Jinxit> don't
04:33:59 <python476> I believe it's considered as torture by UN
04:34:09 <python476> Jinxit: did I cross the line already 
04:34:25 <python476> on #haskell, one does not mention ...
04:34:25 <Jinxit> i'm reporting you
04:34:27 <tdammers> hectortrope: you don't have to be a genius to learn haskell; it just seems that it takes a certain mindset to value what Haskell brings to the table enough to stick with it through the first phases of the learning curve
04:34:40 <python476> very true ^
04:34:50 <python476> it's very hard to convey though
04:34:57 <python476> it's like a foreign culture
04:35:17 <hectortrope> tdammers:  I am dying to learn java and so much depended on others so Haskel may be after years for me I already heard its very very tough
04:36:52 <python476> hectortrope: you may die learning java /s
04:37:16 <python476> note that Java, since Java 8, is aiming at functional programming a bit
04:38:25 <hectortrope> python476:  but I can't even lean python when I jeard  print 'hello world" thats's it I thought I can do much but when we do real world app with python its also impossible for a noob
04:59:50 <tdammers> haskell isn't harder to learn than Java, it's just different enough that having learned Java already will not help you as much with Haskell as it would with, say, C++ or Python
05:03:05 * araujo actually believes the Haskell learning curve is much lower if you are not used to other language
05:05:17 * dramforever believes that it's an illusion
05:05:42 <dramforever> "I know C++, I learn Java, easy; I learn Haskell, wtf"
05:05:50 <tdammers> :D
05:05:52 <tdammers> yeah
05:06:16 <tdammers> that's like, "I know Swedish, I learn Norwegian, easy; I learn Japanese, wtf"
05:08:00 <dramforever> tdammers: Chinese here, I think that's exactly why the world thinks Mandarin Chinese is hard to learn (got no idea about other dialects)
05:08:28 <qq03> I'd say knowing other languages helps you appreciate the utility in learning haskell
05:08:35 <tdammers> IIRC I read somewhere than Mandarin was classified among the world's 10 easiest languages at some point
05:08:52 <Ferdirand> I've been casually writing Haskell for a couple of years and I still haven't wrapped my head around optimizing for performance
05:09:01 <qq03> as in "wow, this is so much more concise and elegant than I would be in XYZ"
05:09:36 <Taneb> araujo, I always found Haskell quite easy, and it was the first language I really got into
05:09:50 <dramforever> 你觉得这个你能学会吗？ :) (I hope it displays correctly)
05:10:01 <dramforever> (Translated: Do you think you can learn this?)
05:10:33 <dramforever> The reactions of the people seeing that is almost exactly like:
05:10:41 <free_beard> It really helped me to accept that the computational model haskell relies upon is different from other languages. After 7 years of reading haskell books, reading about the lambda calculus vs turing machine models really helped me get over the anxiety of working on a haskell project
05:10:55 <dramforever> (zip [1..]) <$> (wtf *** id)
05:10:58 <dramforever> or whatever
05:11:06 <dramforever> can't think of a good example atm
05:12:20 <merijn> dramforever: The reason Mandarin is hard to learn is: 1) tonality 2) script
05:12:23 <araujo> 中文很难，但是有意思！
05:12:27 <araujo> :)
05:12:46 <tdammers> tonality is only hard if your native language isn't tonal
05:12:48 <qq03> free_beard that's how I feel at times. I know that the problem can be nicely solved in haskell, but I'm a bit afraid I won't be able to find the cool solution
05:12:49 <merijn> dramforever: afaik the grammar is pretty easy
05:13:19 <dramforever> merijn: probably, I can't tell :P
05:13:39 <merijn> Ferdirand: I think the STG paper is good starting point for getting an intuition on haskell execution cost
05:13:48 <dramforever> so for haskell it's 1) purely functional 2) syntax
05:14:00 <merijn> Ferdirand: Although you'd need some basic C/asm knowledge to get through that paper
05:14:29 <merijn> tdammers: You mean like basically every western language? ;)
05:14:51 <tdammers> merijn: yep
05:14:58 <merijn> Ferdirand: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
05:14:59 <tdammers> merijn: with a few notable exceptions
05:15:18 <tdammers> arguable, Swedish, Limburgs and some adjacent languages, ...
05:15:59 <dramforever> tdammers: You must mean those with certain functional parts like Python, Java 8, Perl 6 :P
05:16:38 <araujo> Taneb, yeah, I believe the main problem for programmers when approaching Haskell for the first time is the way they already think in terms of other languages
05:16:59 <puregreen> is there any way to use RULES to do something different is a string passed to some function is ASCII-only?
05:17:18 <tdammers> dramforever: I'd say for Haskell it's 1) type system, and 2) uncompromised purity
05:17:32 <Athas> puregreen: since you don't know until runtime, isn't that just a branch?
05:17:44 <Athas> tdammers: Haskell isn't *totally* uncompromised purity-wise.
05:17:52 <Athas> I say you'd need a total language for that.
05:18:08 <Athas> It's certainly the most pure practically useful language I've seen, though.
05:18:08 <puregreen> Athas: well, assuming that the string is a constant (as it will be in 99% of cases)
05:18:28 <puregreen> I understand that nothing can be done if the string only appears at runtime, yeah
05:18:31 <Taneb> puregreen, I think you'd need template Haskell :(
05:18:55 <dramforever> tdammers: Perhaps
05:19:09 <dramforever> whatever, it's just the reaction of people that is similar
05:19:26 <Ferdirand> merijn: actually I remember I stopped dead in the middle of this paper, I will give it another try
05:29:58 <puregreen> okay, for anybody interested, it turns out that it's actually possible: http://www.serpentine.com/blog/2012/09/12/the-case-of-the-mysterious-explosion-in-space/
05:31:04 <puregreen> ASCII string literals get compiled with unpackCString#, apparently, and Unicode ones use unpackCStringUtf8#, so it's possible to target the former ones at compile-time
05:39:19 <lyxia> I have an array that fits just in about 4GB, but it seems that the GC has a 2x overhead, which prevents me from using even Vector.Unboxed (I have 8GB RAM). It seems I can work around it with by allocating manually with Foreign. Is there something more appropriate for that?
05:41:12 <merijn> lyxia: You could allocate a pinned array, but I'm not sure you could feed that to Vector
05:41:42 <dramforever> Looks relevant: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html
05:41:43 <merijn> pinned allocations are more expensive (i.e. take more cycles to do), but are never moved so you aren't limited to half your physical memory
05:43:10 <phaazon> hey, I need your opinion!
05:43:14 <phaazon> http://lpaste.net/7074906675295027200
05:43:20 <phaazon> which one sounds the best to you?
05:43:28 <phaazon> the BufferDriver or BufferCommand?
05:43:36 <phaazon> the BufferDriver is pretty simple and straightforward
05:43:43 <phaazon> the BufferCommand is maybe more elegant
05:44:00 <aweinstock> lyxia: Data.Vector.Storable.unsafeFromForeignPtr, possibly
05:44:03 <phaazon> but I’m not sure how to mix it with other Command
05:44:08 <phaazon> like TextureCommand
05:44:12 <phaazon> FramebufferCommand
05:44:14 <phaazon> and so on
05:44:56 <lyxia> dramforever: aweinstock: Right that's what I'm using right now with mallocForeignPtrArray.
05:45:04 <{AS}> phaazon: The BufferCommand still needs an interpreter right?
05:45:11 <phaazon> yes
05:45:16 <phaazon> in both case
05:45:18 <phaazon> I have the interface
05:45:20 <phaazon> for instance
05:45:31 <phaazon> I could write a createBuffer function using drvBufferCreate 
05:45:35 <phaazon> and a Reader, for instance
05:45:38 <phaazon> to have access to the driver
05:45:41 <phaazon> in the second case
05:45:46 <phaazon> I just have to use the free monad
05:45:50 <phaazon> and interpret it later on
05:46:14 <phaazon> I just don’t know how I might end up using the BufferCommand
05:46:22 <phaazon> especially if I want interleaved IO and so on
05:46:25 <phaazon> maybe with FreeT
05:46:46 <phaazon> or I guess…
05:46:57 <phaazon> I could just state that the graphics code shouldn’t be mixed with IO code
05:47:04 <phaazon> and should be ran in a separate thread
05:47:20 <{AS}> phaazon: I mean you need some function : interpretBufferCommand : BufferCommand -> m ()
05:47:24 <{AS}> or something like that
05:47:25 <phaazon> yes
05:47:34 <phaazon> (MonadIO m) => BufferCommand -> m ()
05:47:56 <phaazon> the interpreters would be the driver
05:48:10 <phaazon> but my question is: can we decoralate IO code from graphics code?
05:48:11 <{AS}> phaazon: It depends on whether you want to have multiple ways of interpreting BufferCommand
05:48:11 <phaazon> like
05:48:22 <phaazon> I do, but not at the same time
05:48:25 <{AS}> or just have a bunch of records
05:48:31 <phaazon> like the first solution?
05:48:36 <phaazon> (CommandDriver)
05:48:37 <{AS}> Also, you can probably use type classes for the first
05:48:48 <phaazon> hm, I don’t need typeclasses for that
05:49:12 <lyxia> merijn: that sounds good, I'll look into it. Thanks!
05:49:20 <{AS}> phaazon: I would think the second solution is better, but I am not an expert
05:49:34 <phaazon> it sounds better yes
05:49:36 <phaazon> but hm
05:49:50 <phaazon> imagine I have a TextureCommand
05:49:52 <dramforever> Sounds like you could change BufferCommand a bit and put it into a Cofree Comonad, then you could use it as an interpreter http://dlaing.org/cofun/posts/free_and_cofree.html
05:49:57 <phaazon> which is a Free TextureCommandF
05:50:11 <phaazon> how should I put both TextureCommand and BufferCommand together to make a type?
05:50:18 <dramforever> (Yet another "Sounds relevant")
05:50:28 <phaazon> and I’m worried about how I should “drive” the type with common IO code
05:51:43 <dramforever> I think a sum type could be used to combine the functors data Sum f g a = Inl (f a) | Inr (g a)
05:51:54 <dramforever> *sum functor
06:02:47 <jgertm> is there a haskell library for talking to http2 servers?
06:10:04 <aweinstock> jgertm: https://hackage.haskell.org/package/http2
06:10:48 <aweinstock> I havn't used it, but apparently the author works on yesod (http://www.yesodweb.com/blog/2015/07/http2), so it's probably production-quality
06:12:12 <jgertm> aweinstock: ive looked at that but its just a bunch of datatypes and ways to construct them as far as i can tell. no idea how to create a connection and send the data
06:20:21 <cocreature> jgertm: it provides encode and decode functions so you could just use a tls connection and encode and decode there but that is quite painful
06:20:38 <cocreature> it doesn’t look like we have some higher level package for http2 right now
06:26:25 <lpaste> Veidit pasted “base install error” at http://lpaste.net/1377977318470844416
06:27:11 <geekosaur> um? base is not installable, except by installing a new ghc
06:27:43 <cocreature> bump the upper bound of base in the rede package (no idea what that is)
06:28:40 * geekosaur has not yet been able to load the paste; local notwork is made of fail today'
06:53:48 <avn> Hello! Folks, any ideas how to befriend Network.Wreq and Codec.Tar? (Trying to implement get-and-untar and  tar-and-put -- part of docker's API). 
06:54:36 <xophmeister> Is there a quick-and-easy way to read a list of strings into a sum type? e.g., output from getArgs into Arguments Foo Bar Baz
06:54:48 <c_wraith> Tar files tend to be large.  Do you intend on streaming the data?
06:55:13 <avn> c_wraith: yep
06:55:34 <cocreature> I don’t think wreq does streaming, you might want to look into http-conduit
06:55:48 <avn> or pipes?
06:56:29 <cocreature> ah I didn’t know pipes-http existed
06:57:00 <cocreature> so yes pipes should be fine too
06:58:16 <lyxia> xophmeister: I don't think there's anything shorter than explicit pattern matching.
07:02:55 <dmj> > mapM (\case "foo" -> pure (Just 1)) =<< return ["foo"]
07:02:56 <lambdabot>  <hint>:1:7: parse error: naked lambda expression ''
07:03:43 <tdammers> huh, turns out that building the same library twice in parallel with stack, from two different projects, is not a good idea
07:04:17 <Eduard_Munteanu> How do you call external tools from Cabal? I need to call a typescript compiler to generate a file for julius.
07:07:09 <kadoban> tdammers: Oh yeah? How badly does it go?
07:07:57 <c_wraith> Eduard_Munteanu: that needs to go in Setup.hs, which is part of Cabal, rather than cabal-install
07:08:18 <c_wraith> Eduard_Munteanu: then you tell cabal-install that the setup type is custom.
07:08:56 <Eduard_Munteanu> Hm, I see.
07:09:13 <Eduard_Munteanu> I wonder if I'm better off writing a TH splice.
07:10:46 <puregreen> Eduard_Munteanu: just in case: maybe this could be useful? http://hackage.haskell.org/package/shakespeare-2.0.7/docs/Text-TypeScript.html
07:10:49 <tdammers> kadoban: not very, the two build jobs just step on each other's toes and partially overwrite the .hi files, and then they barf because the .hi are invalid
07:11:11 <tdammers> kadoban: kind of annoying with two parallel --file-watch jobs though
07:11:36 <Eduard_Munteanu> puregreen, cool, thanks, I had no idea it was already supported.
07:11:49 <kadoban> tdammers: Huh. You might want to mention that in the issue tracker, sounds pretty bad. Quite possible nobody noticed yet and there's a way to avoid that happening.
07:16:08 <cocreature> I think stack did lock at some point but it was a global lock or at least one lock per snapshot and they decided locks with finer granularity are not worth the trouble
07:19:46 <mgsloan> Yeah, the locks were too global and got in the way of a lot of common usecases
07:19:57 <mgsloan> And we hadn't encountered much actual breakage
07:21:01 <mgsloan> I'd be in favor of bringing back locks as needed to prevent errors 
07:21:28 <mgsloan> Could be as fine-grained as one per dist directory
07:21:49 <cocreature> mgsloan: do you have a highlight on stack? you magically appear everytime someone mentions it :)
07:21:50 <mgsloan> (whereas the old lock was over the entire run of stack, which was too much)
07:21:53 <mgsloan> Yes
07:21:59 <cocreature> :)
07:33:19 <AshSlave> Sorry for probably noobish question, but how to get web page's title? Is there any ready solution or do I need to parse page's source?
07:34:11 <kadoban> AshSlave: From the HTML? Yeah you'd have to parse the HTML quite a bit.
07:34:40 <kadoban> I would imagine some haskell library can do that, but I haven't done HTML parsing in haskell yet.
07:35:24 <dmj> AshSlave: check out tagsoup, I assume there should only be one title per page, so that might not even be necessary
07:36:41 <kadoban> Even if there's only one, you still probably don't want to get into parsing it yourself unless you don't care if the answers are wrong pretty easily. HTML is pretty complicated.
08:11:39 <zygentoma^phy> hi :)
08:14:30 <zygentoma^phy> why are the fields in some monads named "run…"? Like "runReader", "runWriter", "runState" …
08:16:07 <geekosaur> because they act like that.
08:16:53 <geekosaur> so runState, given an initial state value and a (State s a) (that is, an action using state), will run the action with the initial state
08:17:41 <zygentoma^phy> ah, ok
08:18:51 <tdammers> well, when used as a function they act like that
08:19:07 <tdammers> when used in pattern matching or assignment, they wouldn't, but with these types, they are rarely used that way
08:19:15 <geekosaur> yep
08:20:48 <Aleksejs> Hello, is there anyone responsible for tryhaskell.org? It looks like the page is down
08:25:10 <puregreen> Aleksejs: http://chrisdone.com/
08:30:05 <fizbin> Any experts at how to get specialization {-# RULES #-} to work feel like taking a whack at http://stackoverflow.com/questions/35557964/library-ghc-rules-dont-activate/35558365#35558365 ?
08:31:00 <bergmark> zygentoma^phy: it's also pretty common to name them unX, makes more sense if you don't have a transformers imo
08:32:18 <tdammers> I like to use unX for newtype wrappers
08:34:01 <bergmark> then you get e.g `runWorker e = flip runReaderT e . unWorker'
08:40:34 * hackagebot socketson 0.1.0.0 - A small websocket backend provider.  https://hackage.haskell.org/package/socketson-0.1.0.0 (apho)
08:53:05 <esssing> does somebody recognize this monad: http://pastebin.com/rf3vsfGZ
08:53:48 <esssing> i need something like that and i assume it's already part of some existing library
08:54:54 <johnw> esssing: it's called Writer
08:55:19 <johnw> note that have a tuple in a data declaration is redundant and wastes space
08:55:33 <johnw> "UM m a" would be isomorphic and use one less constructor tag
08:57:16 <esssing> johnw: thanks
09:00:21 <pavonia> Any ideas on this Monad instance? http://dpaste.com/02RDTE0  The instance probably doesn't exist for this Builder definition, but is there a way to rewrite it such that you get the functionality shown in the paste?
09:00:37 <fizbin> What does the INLINABLE pragma mean? How is that pragma different from saying nothing about the function at all?
09:01:12 <glguy> fizbin: The pragma is described in the GHC user's guide
09:01:13 <johnw> fizbin: I believe it includes the function body in the .hi file so that it can be inlined by users of your package
09:01:26 <johnw> without it, it will only be inlined within your package
09:02:17 <oherrala> and you can SPECIALIZE INLINABLEd functions
09:02:29 <fizbin> glguy: Yes, and the description says "In other words the choice is left to GHC, which uses the same rules as for pragma-free functions."
09:02:36 <fizbin> Which makes me think, why bother?
09:03:15 <glguy> "Unlike INLINE, it is OK to use an INLINABLE pragma on a recursive function. The principal reason do to so to allow later use of SPECIALISE
09:03:48 <glguy> "One way to use INLINABLE is in conjunction with the special function inline
09:04:55 <fizbin> Thing is, I've got a working example right now where doing nothing but adding a INLINABLE pragma to a (non-recursive) function in a package makes some code that uses that package _much_ faster. The code using that package isn't using and SPECIALIZE pragmas or the special function inline.
09:05:22 <glguy> Probably because "Like INLINE, the INLINABLE pragma retains a copy of the original RHS for inlining purposes, and persists it in the interface file, regardless of the size of the RHS.
09:05:35 <fizbin> So clearly it does *something*, but ...
09:05:41 <geekosaur> ^ compare the .hi files
09:05:49 * hackagebot hstats 0.3.0.1 - Statistical Computing in Haskell  https://hackage.haskell.org/package/hstats-0.3.0.1 (BasDeHaas)
09:06:35 <fizbin> geekosaur: No hablo .hi
09:06:42 <geekosaur> (ghc -ddump-hi filename.hi)
09:06:47 <fizbin> Ah.
09:06:58 * geekosaur was doublechecking the option to use
09:07:22 <geekosaur> when switching  between them -ddump-hi-diffs may be helpful to see just the changes caused by e.g. INLINABLE
09:08:17 <geekosaur> oh, actually I think I wanted --show-iface
09:08:26 <geekosaur> whih runs sandalon instead of during a compile
09:08:29 <geekosaur> ...
09:08:38 <geekosaur> which runs standalone instead of during a compile
09:08:40 <fizbin> Ah.
09:09:03 <fizbin> I was wondering why --dump-hi gave me "ld: warning: ignoring file dist/build/Data/Graph/Inductive/Graph.hi, file was built for unsupported file format"
09:09:20 <puregreen> with -ddump-simpl-phases gone, is there any way to see the output after each simplifier phase?
09:10:36 <puregreen> okay, nevermind, found something close (-ddump-simpl-iterations)
09:12:35 <pavonia> Or alternatively, are there any rules on to figure out when a type can be a monad and when not?
09:12:53 <fizbin> geekosaur: Huh. I'm not sure what I'm looking at here.
09:12:56 <johnw> pavonia: yes: if you can write a lawful instance or not :)
09:13:16 <kadoban> pavonia: Being kind * -> * is a good first step.
09:13:30 <johnw> when I think about types, I think "what would join mean for this type", and that usually guides my thinking pretty quickly
09:13:33 <pavonia> Yeah, I mean without thinking hard about it, just deriving from it's structure
09:13:55 <johnw> SomeType (SomeType a) -> SomeType a.  What does this mean for SomeType, in a way that respects the laws
09:14:14 <pavonia> My problem is just because I can't come up with an instance, that doesn't mean that there isn't one
09:14:28 <johnw> you could ask here too
09:14:29 <geekosaur> you are probably better off compiling without and with the INLINABLE pragma, retaining the .hi/o files between compiles, and using -ddump-hi-diffs so it shows the difference. that said, I expect the difference is that it puts (the core for? I think) the function marked INLINABLE in the .hi file
09:14:42 <johnw> geekosaur: that's what I understood it to do also
09:14:56 <johnw> it exports the information needed to make inline decisions elsewhere
09:14:59 <pavonia> johnw: I did several times, no one answered :(
09:15:00 <kadoban> pavonia: Any type in particular you have in mind?
09:15:03 <geekosaur> so it is available for a compile using that library later to get the code from it and inline it
09:15:09 <johnw> pavonia: go ahead and ask again
09:15:10 <pavonia> This is the code http://dpaste.com/02RDTE0
09:15:13 <mnoonan> so maybe a good question is "are there any properties of a type constructor * -> * that prove it *cannot* have a monad instance?"
09:15:16 <mnoonan> (but I have no idea :)
09:15:40 <dolio> Inlining isn't the only thing it allows, either.
09:16:03 <dolio> But, you can learn what all it does by reading about it in the manual.
09:16:17 <geekosaur> (this, btw, is why ghc has such strict dependencies and you can't just swap out libraries even if they are the same version; if the code in the .hi file is different between different modules using it that are subsequently linked together into an application, you can well get crashes)
09:17:24 <fizbin> johnw, geekosaur: No, I don't think that's it, quite. Here's a diff of what --show-iface says for each .hi file. Will try -ddump-hi-diffs next
09:17:58 <kadoban> pavonia: Is there a description somewhere of what this is for? Or examples of how you'd use it?
09:19:38 <geekosaur> also there will be differences between runs anyway because of manufactured symbols (see above remark about ghc dependencies)
09:20:37 <pavonia> kadoban: I'm using it for parsing a set of parameters of the form key = value, where both are strings. builderParams is a definition how the values should look like, builderApply is the function that parses the actual parameter list and builds a final result from it
09:20:40 <johnw> pavonia: you don't actually use params in your >>=, you just carry it through; that part of this is Writer-esque
09:21:17 <fizbin> What I see in the hi diffs seems to suggest that the main difference is that the non-INLINABLE version uses a variant of the "insEdge" function that has the first tuple ripped apart. The signature of that $winsEdge function is DynGraph gr => Node -> Node -> b -> gr a b -> gr a b , whereas the signature of insEdge (used by the INLINABLE version) is DynGraph gr => (Node, Node, b) -> gr a b -> gr a b
09:22:21 <pavonia> kadoban: Here is a sample on how it's used http://dpaste.com/0H0BRED
09:22:50 <fizbin> geekosaur: -ddump-hi-diffs was completely uninformative.
09:23:08 <geekosaur> then I think you need to ask in #ghc
09:23:10 <kadoban> pavonia: Thanks. I'll think about it on and off if nobody else answers first. Bit slow today so it might take a while.
09:23:43 <fizbin> geekosaur: All I got was "  Out of date: insEdge 68c03599988075389c962bc26cc87389 -> 4c65de7119fb2fc0ae23991e15b2aec4"
09:23:52 <geekosaur> ugh
09:23:53 <fizbin> Which... gee, thanks.
09:24:00 <pavonia> johnw: So could a writer be put in there somewhere?
09:24:07 <johnw> one sec
09:24:15 <geekosaur> ok, you need to ask in #ghc, maybe -ddump-hi-diffs is broken
09:29:13 <johnw> pavonia: I don't think this can be a monad
09:34:18 <johnw> pavonia: there is a data dependency on Parameter that cannot be satisfied in order to determine the next builderParams to merge with the previosu one
09:34:31 <johnw> another way to think of this is trying to rewrite it as a Reader/Writer/Either transformer stack
09:34:39 <johnw> but there is no combination that composes like this
09:38:33 <magnus__> https://paste.debian.net/402615 I'm trying to write a function for multiplying numbers, but GHCi keeps giving stack overflow exceptions with this.
09:38:35 <pavonia> johnw: Okay, thank you. I'll have to live with the Applicative instance then
09:39:39 <sbrg> pavonia: ghc8 will give you applicative do so there's that
09:40:32 <orion> johnw: Can >>= be written in terms of join for all Monads, by law?
09:41:23 <pavonia> sbrg: How would that work for types that don't have a Monad instance?
09:41:32 <sbrg> pavonia: see https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
09:42:02 <johnw> pavonia: btw, this is related to ocharles_' Query applicative
09:42:03 <mnoonan> orion: sure, just fmap your (a -> m b) to get an m a -> m (m b), then join the result to get the m b
09:42:27 <johnw> pavonia: https://ocharles.org.uk/blog/posts/2014-05-28-pure-batched-queries.html
09:42:37 <johnw> in particular, check out the applicative instance for Querying, and tell me it doesn't look familiar :)
09:42:51 <bgy> Hi
09:43:10 <johnw> the reason this works well as an applicative is that <*> takes two Querying arguments, so you can "inspect" both environments.  But, for the same reason, Querying doesn't work as a monad
09:43:13 <orion> mnoonan: I see. johnw: Why is it helpful to think of the monad in terms of join instead of >>= ?
09:43:24 <johnw> orion: it's not, necessarily; it's just my habit
09:43:38 <johnw> some people do prefer >>=
09:44:01 <mnoonan> join and return are both kind of simpler operations though, and the laws are also simpler
09:44:13 <johnw> yes
09:44:46 <pavonia> johnw: Nice, thanks for the link
09:45:08 <johnw> pavonia: I link it to let you know that it's not always bad that something is "only Applicative"
09:45:23 <bgy> I've two lists of tuples, both are [(a,b,c,d)]  and I'd like to get a new list [(a,b,c,d, [(a,b,c,d)]] where I need to insert the second when d matches a in the first, I guess I could use zipWith for the work, or is there any clever way?
09:47:26 <sbrg> bgy: you might consider rolling your own type instead of working with 4-tuples. probably more convenient. 
09:49:59 <bgy> sbrg, well, I guess you are right, but I'm learning haskell and I'd like to be able to solve simple problems with basic data types : )
09:51:02 <sbrg> bgy: sure, but doing data Foo a b c d = Foo { first :: a, second :: b, third :: c, fourth :: d } is isomomorphic to a 4-tuple but much more pleasant to work with :)
09:59:01 <Sonarpulse> Does the cabal solver take "buildable: false" into account?
10:00:06 <dolio> I don't think so.
10:00:57 <Gurkenglas_> bgy, if you make the new list [((a,b,c,d), [(a,b,c,d)]], then your problem can be generalized to [a, [b]] with some extra arguments. Are you sure you mean zipWith (instead of comparing every element in one list to each in the other)?
10:01:00 <Sonarpulse> that's annoying
10:01:13 <Sonarpulse> I wonder if there is an issue for that
10:01:33 <Gurkenglas_> I mean [((a,b,c,d), [(a,b,c,d)])] and [(a, [b])]
10:06:01 <Sonarpulse> dolio: there is an ancient issue
10:06:11 <Sonarpulse> but another one recently got closed
10:12:43 <puregreen> I've got a class method (with INLINE in all instances) and a RULE that is supposed to replace this method with something else. I'm getting a “Rule may never fire because <method name> might inline first” warning, which seems reasonable, but no matter what INLINE pragmas I add ([2], [1], bland) to the methods, the warning persists. Can anything be done about it?
10:13:15 <puregreen> relevant piece of code: http://lpaste.net/153062
10:18:42 <dolio> If you inline [0] and put [~1] on the rule, does it still complain?
10:19:07 <hexagoxel> why don't containers provide Generic or Out instances? is there any pretty-printing for.. Data.Map.Maps?
10:19:37 <glguy> Generic instances would leak the implementation details of the types
10:19:49 <dolio> Actually, [0] and [~0].
10:20:44 <william-s> in #elm
10:20:48 <william-s> oops
10:21:01 <barrucadu> Is it possible with any of the fancy new GHC 8 stuff to associate a kind with a type class? I'm trying to do something with indexed monads, but don't want to restrict the kind of the index type to *
10:23:19 <puregreen> dolio: yes
10:23:41 <puregreen> (both with ~0 and ~1)
10:26:14 <dolio> puregreen: What if you put noinline[0] on the class method?
10:26:18 <barrucadu> Oh, it turned out to just work. Not sure why I just assumed I'd need to stick kind signatures on everything
10:26:21 <dolio> Not the instance.
10:28:21 <puregreen> dolio: “The NOINLINE pragma for default method ‘.=’ lacks an accompanying binding”
10:28:56 <dolio> Okay.
10:29:41 <dolio> What about this... Instead of writing a rule on the class method, write a rule on a function that calls the class method. Does it complain?
10:29:50 <dolio> Just an alias.
10:33:11 <digitalmentat> what do I need to cache in order to *not* rebuild my dependencies every single time a build hits my CI instance?
10:33:27 <digitalmentat> oh wait
10:33:30 <puregreen> digitalmentat: hvr's script does that automatically
10:33:31 <digitalmentat> I just answered my question
10:33:41 <digitalmentat> puregreen, I had a severe derp moment
10:33:55 <digitalmentat> derp derp
10:35:38 <puregreen> dolio: okay, it doesn't. So, it's just a minor bug/something in GHC, then?
10:35:57 <dolio> puregreen: I don't know if it's a bug.
10:36:08 <dolio> It might just not be safe to write rules on class methods.
10:36:37 <dolio> Because they might turn into the instance functions which no longer match the rule, and you can't control it.
10:37:12 <dolio> The bug would be that the warning message is bad, I guess.
10:39:18 <puregreen> okay, thanks
10:39:40 <puregreen> I'll use the alias solution
10:39:58 <puregreen> (...now to see whether it actually improves performance)
10:43:46 <cheater> hi
10:43:57 <jle`> hi cheater 
10:44:09 <cheater> what is a relatively pretty gui toolkit that works on linux and isn't toooo difficult to use?
10:44:25 <cheater> i just want to make something that displays an interactive image from diagrams, and a few sliders
10:47:04 <rom1504> try some cheats
10:48:22 <cansis> dmj: pong
10:48:32 <cocreature> cheater: gtk is supposed to be pretty good for that but I haven’t used it myself
10:58:37 <alanz> stupid question: in "foo :: a -> a", is a a free variable?
10:59:17 <jle`> a is a type variable
10:59:51 <alanz> and I guess it is free, as it must be provided from elsewhere
11:00:00 <geekosaur> ghc will sometimes report that as foo :: forall a. a -> a
11:00:02 <liste> and in "foo x = x", x is bound
11:00:06 <cocreature> alanz: it’s bound in a forall
11:01:29 <cocreature> so in a -> a the a is free, but the type of foo will be forall a. a -> a even if ghc doesn’t always show you that so in that type it is bound
11:01:30 <alanz> ok. I am trying to sort out a HaRe function to get free and declared vars, and hit this. I think I am going to err on the side of calling it free.
11:02:17 <alanz> but then implicit forall...
11:02:53 <alanz> And in "data Foo a = F a | B Int", is a free?
11:03:09 <alanz> it is also a type var
11:03:39 <cheater> thanks cocreature. i wonder what other toolkits are useful.
11:45:12 <Poiuy> Test 
11:45:53 * hackagebot gnss-converters 0.1.5 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.5 (markfine)
11:47:00 <jophish> I'm hitting 'undefined' in alloca https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Foreign.Marshal.Alloc.html#alloca
11:47:25 <jophish> The record I'm passing in is strict in it's fields
11:47:40 <jophish> but I wouldn't have thought it would have made any difference...
11:48:06 <mauke> broken Storable implementation?
11:48:29 <mauke> what does your record type and its Storable instance look like?
11:48:44 <jophish> mauke: sizeof and alignment both match with _
11:48:45 <jophish> ah!
11:48:54 <jophish> I'm using -XStrict in that module
11:49:06 <jophish> perhaps that's forcing them, even when they're matched as wildcards
11:49:28 <jophish> I hope that's it, as this module has a 13 minute compile time :/
12:12:34 <jophish> Woo! creating a vulkan instance in Haskell
12:14:22 <d-snp> jophish: how close are you to rendering a triangle? :P
12:14:54 <jophish> d-snp: thousands of lines away :D
12:15:11 <jophish> This is creating and destroying an instance https://github.com/expipiplus1/vulkan-examples/blob/master/src/Main.hs
12:16:18 <jophish> I'm starting to get some ideas for a good 'medium level' wrapper for vulkan
12:16:30 <jophish> to avoid having to tag structs with their type and all that rubbish
12:17:50 <big_dick_jim> hey guyss
12:17:52 <big_dick_jim> im new here
12:18:18 <big_dick_jim> im new to functional programming and am looking fro some nice dick
12:18:30 <prooftechnique> !ops
12:18:44 <big_dick_jim> !ops
12:18:54 <big_dick_jim> DONT KICK ME
12:18:55 <big_dick_jim> pls
12:19:05 <big_dick_jim> my goldfish swam over and typed that
12:19:17 --- mode: ChanServ set +o mauke
12:19:18 --- kick: big_dick_jim was kicked by mauke (big_dick_jim)
12:19:18 <prooftechnique> @where ops
12:19:18 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
12:19:26 <d-snp> lol
12:19:37 <prooftechnique> I always forget the command :|
12:21:30 --- mode: mauke set -o mauke
12:22:38 <paul_112233> I'm looking for some big dicks to plug all me holes       Don't respond unless ur dick is longer than 9 inches    Preferably Whites between 8-88
12:23:04 --- mode: ChanServ set +o johnw
12:23:04 --- mode: johnw set -o johnw
12:23:04 --- mode: ChanServ set +o mauke
12:23:05 --- mode: mauke set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.107.107.57.128
12:23:12 --- kick: paul_112233 was kicked by mauke (paul_112233)
12:23:44 --- mode: ChanServ set +o johnw
12:23:51 --- mode: johnw set -o johnw
12:24:34 <prooftechnique> Busy day
12:25:12 --- mode: mauke set -o mauke
12:25:55 <dedgrant> jophish: Oh wow that didn't take long.. wasn't Vulkan just released on Friday?
12:26:13 <jophish> dedgrant: some time last week, yearh
12:26:15 <jophish> yeah*
12:26:34 <dedgrant> Bookmarking the repos :)
12:26:49 <jophish> dedgrant: :D
12:28:04 <jophish> The packages are very likely to change quite a bit in the near future, I'm not settled on a final design yet :)
12:28:22 <dedgrant> jophish: Ouch.. that compile time
12:28:32 <jophish> dedgrant: oh, yeah. Use O0 for now
12:28:39 <jophish> otherwise it takes about 15 minutes
12:29:23 <jophish> I'm not sure exactly what to do about that. I'm thinking of splitting the library up into some smaller modules, and perhaps generating the instance definitions myself
12:32:04 <lifter> Does anyone know if it's possible to stack with-rtsopts as in -with-rtsopts="-N -T" (this doesn't seem to work)? I can't seem to figure out how to put -N and -T together like this.
12:32:32 <dedgrant> jophish: Do you know what is causing the explosion in time?
12:33:09 <dedgrant> jophish: If it can be worked into some pre-ghc-8 form, it might be good for comparison.
12:33:55 <mauke> lifter: my first attempt would be -NT
12:34:15 <chokboy> Is anyone familiar with Xlib programming in Haskell? I'm trying to send a click event, but the only solution I can find is creating a click event from scratch (as a c struct). Does anyone have a nicer, more elegant idea?
12:34:16 <lifter> mauke: That didn't seem to work either.
12:34:37 <geekosaur> chokboy, without the XTest extension, that's it
12:34:49 <geekosaur> (and XTest has security implications)
12:34:57 * mauke tries to remember
12:35:10 <geekosaur> "For example, to set -H128m -K64m, link with -with-rtsopts="-H128m -K64m"."
12:35:22 <geekosaur> so I'd expect that to work
12:35:40 <jophish> dedgrant: I've got no idea at the moment
12:35:48 <geekosaur> hm, you may also need to turn on -rtsopts
12:36:18 <jophish> dedgrant: It could be backported to ghc7.10, but it's not at the top of my todo list :)
12:37:02 <lifter> geekosaur: Yep, I do enable -rtsopts
12:37:19 <mauke> chokboy: this might be related: http://hackage.haskell.org/package/xmonad-0.12/docs/src/XMonad-Main.html#line-338
12:37:34 <mauke> specifically the clickJustFocuses part
12:38:12 <dedgrant> jophish: Yea that's fair. There's been a lot about compile time regressions with significant changes to GHC-8, but I'm not up on the specifics. Just a possible hook for exploration.
12:38:45 <jophish> dedgrant: I'll let you know if I figure out a way to improve things
12:39:57 <dedgrant> jophish: no worries, but would certainly be curious, more for learning than anything else
12:40:09 <hexagoxel> jophish: apart from 15min, it also seems to require 8+GB of mem during compilation.
12:40:38 <jophish> hexagoxel: is that with -O or -O0?
12:40:48 <hexagoxel> -O1
12:41:04 <hexagoxel> (i.e. -O)
12:41:59 <jophish> ok. Once I'm parsing the interface definitions I'll split things up into multiple modules https://github.com/KhronosGroup/Vulkan-Docs/blob/1.0/src/spec/vk.xml#L4707
12:43:44 <jophish> Annoyingly that doesn't segment the structs, which I strongly suspect are what's causing the explosion in compile time
12:51:31 <dedgrant> Some sort of exponential complexity in pattern matching?
12:55:59 <dedgrant> jophish: Are you interested in doing something similar to gl?  https://github.com/ekmett/gl/blob/master/Setup.hs
12:56:36 <jophish> dedgrant: generating the source at build time, right?
12:56:45 <sf> hi, am from java background, how good is haskell when u compare with java e.g. for web, for desktop
12:56:48 <dedgrant> yea, from the xml spec
12:56:51 <jophish> I hadn't planned on it as an immediate feature, but it probably makes sense
12:56:58 <jophish> dedgrant: it's already generated from the spec
12:57:02 <jophish> but manually by me :)
12:57:21 <dedgrant> Yea. Just thinking of pros/cons for getting the automation in early :)
12:57:56 <jophish> dedgrant: pull requests welcome :) Or if you raise an issue I'll get around to it eventually
12:58:05 <dedgrant> Sounds good
12:58:19 <jophish> but I'd rather spend the immediate future finishing of parsing the corners for the spec
12:58:33 <jophish> oh, and I'm going to parse the man pages and generate groovy haddocks :)
12:59:41 <dedgrant> A nice bonus. It was nice to get that from gl as well.
13:00:56 * hackagebot vulkan 0.2.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-0.2.0.0 (jophish)
13:02:57 <suppi> sf, it's different :^)
13:03:25 <chokboy> geekosaur: Xtest seems like the best solution because I'm really not interested in doing all that gorey stuff. Would you be able to shed some light on the security implications and how I might be able to avoid them? I haven't been able to find any reference to them.
13:05:13 <geekosaur> chokboy, when you synthesize an event in X11 (which is the only way to programmatically click on something), the server sets a flag in he event to inidcate that it is synthetic. Some programs specifically ignore all events with that flag set so that malicious programs cannot use that to inject events or possibly intercept passwords etc.
13:06:06 <geekosaur> The XTest extension lets you manufacture real events, and it is server-wide, so there is no longer any way to prevent such malicious event injection.
13:06:49 <roelof> Is it possible to have eason-11 with stack. I need it to run a servant tutorial ? 
13:07:40 <Welkin> chokboy: bokchoy
13:08:05 <suppi> roelof, sure
13:08:15 <suppi> roelof, check out third bullet: http://docs.haskellstack.org/en/stable/faq/
13:08:17 <kadoban> roelof: You shouldn't have problems with versions, 'servant' is in stackage. What directions are you following?
13:10:20 <roelof> I add servant to my cabal file and put this into my main.hs : http://lpaste.net/153074
13:11:31 <kadoban> roelof: Hmm, yeah I guess you can try overriding what aeson it uses then.
13:12:18 <roelof> kadoban:  how do I do that . when I do aeson >= .10 I get a error message on servant server 
13:12:48 <kadoban> roelof: suppi Pointed it out, in the FAQ ^
13:14:22 <kadoban> roelof: Oh if you did that and it complains, it's going to be more work :-/ You can try uhm … setting up the correct requirements in blah.cabal and then 'stack init --solver' or something
13:14:55 <roelof> I did add it to the extra-deps not to the packages 
13:15:19 <roelof> I have to find out then how I can tel where the source of aeson-0.11 is then 
13:15:35 <kadoban> roelof: You shouldn't have to, it's in hackage and it knows about hackage.
13:17:10 <kadoban> roelof: extra-deps is where it should go. But it's possible that that conflicts with the version of servant that it wants to use, and it'll be a cascade of problems. But if you just set it in your .cabal file and remove the stack.yaml, you can try 'stack init --solver' and see if it figures it all out for you.
13:21:39 <chokboy> geekosaur: Ah, I see. Thanks for the help! I hope that won't make me run into too many issues.
13:21:51 <chokboy> Welkin: yes, that is what I was going for. ;)
13:23:04 --- mode: ChanServ set +o mauke
13:23:05 --- mode: mauke set -b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.107.107.57.128
13:23:14 <roelof> kadoban:  It still searching. Last message till now rying with packages from lts-4.2 as hard constraints...
13:23:32 <baweaver> mauke: bad time of it with kiwi?
13:24:29 <kadoban> roelof: Can take a while probably.
13:24:31 <Tehnix> roelof: Can take a while probably.
13:25:05 --- mode: mauke set -o mauke
13:37:54 <roelof> Stack resolver did finisch. Now trying a stack build
13:38:51 <aidecoe> hello
13:40:22 <aidecoe> https://hackage.haskell.org/package/wx-0.92.2.0/docs/doc-index.html - 404. Where can I find docs for wx?
13:42:05 <glguy> aidecoe: You can use the ones on hackage for versino 0.92.1.0 or build them locally
13:42:11 <puregreen> aidecoe: https://hackage.haskell.org/package/wx-0.92.1.0/docs/Graphics-UI-WX.html
13:43:19 <M-davidar>  
13:45:15 <roelof> kadoban:  new build is working. Some 90 - 100 packages to go :( 
13:45:45 <kadoban> roelof: Hehe. Yeah it takes a while the first time. Once dependencies get built it'll take way less time.
13:49:14 <roelof> kadoban:  I know. I hope now that everything gets sorted and  I can test servant 
13:50:08 <jle`> a/b 19
13:51:04 <Polarina> Is it valid that an ICD may exist on the system, but supports no devices?
13:51:08 <Polarina> Wrong channel.
13:51:09 <Polarina> Sorry.
14:13:14 <hiptobecubic> Can cabal specify that a particular package version *shouldn't* be used? Say for example I want to depend on Foo > 1.1.0.0, but not 1.1.2.3 because I know it's buggy. I don't see '!=' mentioned in the user guide.
14:13:44 <aidecoe> puregreen: thanks
14:13:44 <phaazon> hm
14:13:54 <jle`> hiptobecubic: everywhere i've seen, they've used things like (> 1.0.0.0 and <1.1.2.3) or (> 1.1.2.3)
14:14:01 <jle`> (with proper syntax for connectives)
14:14:02 <phaazon> I need to build a type through a free monad, but I need to inject some constraints in there, like MonadError
14:14:07 <phaazon> do I have to use FreeT then?
14:14:26 <hiptobecubic> jle`, that was my assumption as well, just checking
14:14:30 <phaazon> I don’t want to hang around with Either everywhere
14:14:30 <jle`> phaazon: can you give a more specific example?
14:14:35 <hiptobecubic> Thanks.
14:14:41 <phaazon> jle`: I have a constructor like :
14:14:42 <jle`> np
14:15:02 <phaazon> Foo :: Word -> (Zoo -> n) -> ASTF n
14:15:12 <phaazon> if Word is higher than something, the interpreter must fail
14:15:23 <phaazon> so I’d like something with
14:15:52 <phaazon> Foo :: (MonadError whatever m) => Word -> (Zoo -> n) -> ASTF m n
14:16:35 <jle`> sounds a lot like those ill-fated attempts to restrict constructors to only take specific constrained types
14:16:40 <jle`> and besides, any interpreter is free to ignore the `m`
14:16:47 <phaazon> hm
14:16:48 <phaazon> so:
14:16:58 <phaazon> Foo :: Word -> (Either Error Zoo -> n) -> ASTF n
14:16:58 <phaazon> ?
14:17:15 <phaazon> I guess it’s the right solution
14:17:15 <jle`> my advice would just be to let the interpreters handle the Foo however they like
14:17:42 <jle`> or else, use a more specific type than Word
14:17:55 <jle`> interpreters might choose to themselves fail when they see a bad Word
14:18:01 <jle`> let the interpreter decide what to do
14:18:58 <phaazon> jle`: ok
14:19:03 <phaazon> but I actually need the Either
14:19:16 <phaazon> so that I can react to errors in the AST itself
14:19:23 <phaazon> and take proper decisions
14:19:40 <jle`> how do you mean?
14:19:59 <phaazon> jle`: if the command fails, I’d like to be able to do something else
14:20:19 <jle`> i feel like the interpreter can handle that
14:20:29 <jle`> just provide an "or" type combinator
14:20:32 <jle`> in your AST
14:20:34 <jle`> <|>-like
14:20:54 <phaazon> why not the (Either ZooError Zoo -> n)?
14:22:11 <jle`> i think it's tricky to tell from just an isolated case like this
14:22:13 <jle`> but you can try that too
14:22:41 <phaazon> yeah, well, I’ll see
14:22:45 <phaazon> thanks :)
14:22:54 <phaazon> the idea is that I’ll write the interpreters
14:23:04 <phaazon> as backends
14:41:14 <icicled> what other libraries are there besides "strings" and "listlike" that abstract over bytestring, text, and string to provide some level of common functionality?
14:41:31 <icicled> via a single API that is
14:41:47 <kadoban> The stuff in mono-traversable maybe?
14:42:10 <puregreen> lens, too
14:47:17 <timbod7> http://haskelliseasy.readthedocs.org recommands fast-logger. This is pretty low level. Any recommendations for a higher level library atop it?
14:47:43 <johnw> timbod7: there is "logging", if your needs are simple
14:47:49 <johnw> it uses fast-logger
14:48:40 <timbod7> johnw: I saw that - thanks. I would have prefered to pass around loggers explicitly, rather than reference global IORefs. But I might use it in any case.
14:49:14 <hexagoxel> what is the magic behind getting code-blocks in a package's description to display correctly? or rather: any of the markdown features?
14:49:42 <hexagoxel> or is there some custom processor running on hackage, that is not active on my local hackage-server?
14:50:09 <Axman6> have you read the docs for haddock? I think it's all haddock syntax (sadly)
14:51:57 <hexagoxel> Axman6: how does lens get away with its description formatting?
14:52:37 <hexagoxel> ah, maybe the custom Setup.lhs
14:52:41 <puregreen> hexagoxel: the README is rendered as Markdown
14:52:46 <puregreen> but the description is rendered as Haddock
14:52:49 <jophish> I've got a super odd haddock bug, it seems to be reading the synopsis as the package name
14:54:03 <puregreen> hexagoxel: here's the relevant part of the .cabal file: https://github.com/ekmett/lens/blob/master/lens.cabal#L70
14:55:17 <hexagoxel> puregreen: that is exactly what does not work for me :)
14:55:34 <puregreen> okay, interesting, can you show your .cabal file?
15:00:08 <hexagoxel> nevermind, there is a syntax error somewhere in my description, and apparently that kills all formatting.
15:00:48 <hexagoxel> i'll just put "read the friggin readme"
15:00:51 <hexagoxel> :p
15:11:00 * hackagebot vinyl 0.5.2 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.5.2 (AnthonyCowley)
15:20:32 <phaazon> hm, I just came to the realization that using Free is a bit like using typeclass and functional dependencies…
15:20:38 <phaazon> so I guess I should go with typeclasses
15:20:55 <phaazon> it’ll be probably much faster
15:25:03 <johnw> phaazon: you might be interested in https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html
15:30:30 <phaazon> johnw: thanks, I’ll read it
15:30:31 <phaazon> anyway
15:30:36 <phaazon> I found a little difference anyway
15:30:44 <phaazon> so I’ll stick to the free monads ;)
15:35:16 <johnw> what about them do you not like?
15:35:41 <phaazon> johnw: the look like dictionnary passing a lot
15:35:45 <phaazon> and in my mind
15:35:51 <phaazon> they seem to force the compiler not to optimize them 
15:36:00 <phaazon> like, pattern-matching dynamically every now and then
15:36:12 <phaazon> I might be wrong though
15:36:25 <phaazon> I don’t really know what GHC does with Free, FreeT nor F
15:36:30 <johnw> there are several known performance issues, and several known approaches to handling each one, depending on what happens to you at runtime
15:36:30 <phaazon> (or even FT)
15:36:48 <phaazon> what do you mean?
15:37:12 <johnw> meaning that there are well-documented drawbacks; and various proposed solutions for them
15:37:26 <phaazon> hm, I need to inquire about that then
15:38:13 <johnw> I'm quite curious about the performance of the van Laarhoven free monad, which you can find in the free-vl package
15:56:01 * hackagebot hahp 0.1.3 - Analytic Hierarchy Process  https://hackage.haskell.org/package/hahp-0.1.3 (taeradan)
16:03:42 <phaazon> johnw: I read the article
16:03:44 <phaazon> and yet
16:04:02 <phaazon> I don’t quite understand what a free monad offers more than a typeclass
16:04:36 <phaazon> a typeclass can be used to solve the language–interpreter problem
16:05:30 <EvanR> phaazon: what benefit does this way have over the GADT way
16:05:45 <phaazon> hm?
16:05:59 <phaazon> EvanR: my question is:
16:06:32 <phaazon> instead of having a ProgramF + type Program = Free ProgramF types, why not directly have a typeclass like class ProgramInterpreter?
16:06:50 <phaazon> I can see a point
16:06:50 <phaazon> like
16:06:54 <phaazon> with a typeclass
16:06:58 <phaazon> you’d need to use something like
16:07:14 <phaazon> class (Monad m) => ProgramInterpreter pi m | pi -> m where…
16:07:26 <EvanR> ok im not too familiar with the free way
16:07:32 <phaazon> then if you want to interpret that to String
16:07:37 <EvanR> but the GADT way seems pretty straight forward
16:07:39 <phaazon> you’ll need to define a stupid monad
16:07:41 <EvanR> which is why im asking
16:07:53 <phaazon> EvanR: what do you mean with GADT?
16:07:55 <phaazon> how do you use it?
16:08:01 <EvanR> the language is the GADT
16:08:09 <phaazon> like for a EDSL?
16:08:26 <EvanR> i assume thats what we were talking about "language interpreter" 
16:09:01 <phaazon> EvanR: try to define the GADT for a simple language like, having two “commands”: print et getLine
16:09:07 <phaazon> what would the GADT would be like?
16:09:14 <phaazon> I can see how to do that with free monads and a typeclass
16:10:03 <EvanR> data Program = Print String Program | GetLine (String -> Program)
16:10:24 <EvanR> whats the typeclass for
16:10:34 <phaazon> how do you define the monad instance of that?!
16:10:48 <EvanR> ah well i guess the assumption is you want a monad instance
16:10:55 <phaazon> yep
16:11:00 <phaazon> that’s what free monads are for :D
16:11:04 <phaazon> and typeclass for this:
16:11:06 <EvanR> thats not a monad at all, not that it has to be given your challenge ;)
16:11:15 <EvanR> you just have two commands
16:11:18 <phaazon> class ProgramInterpreter pi | pi -> m where
16:11:26 <phaazon>   print :: String -> m ()
16:11:33 <phaazon>   getLine :: m String
16:11:46 <EvanR> if you want a monad it would be
16:12:00 <glguy> phaazon: You'll need the type variable 'pi' to feature in those type signatures
16:12:05 <phaazon> the problem with that is the fact there’s no law
16:12:08 <EvanR> data Program :: * -> * where
16:12:10 <phaazon> glguy: are you sure?
16:12:18 <phaazon> I put a functional dependency
16:12:27 <EvanR>   Pure :: a -> Program a
16:12:41 <EvanR>   Print :: String -> Program a -> Program a
16:12:50 <phaazon> you can’t make that a monad
16:12:55 <EvanR>   GetLine :: (String -> Program b) -> Program b
16:12:59 <EvanR> why not?
16:13:05 <glguy> phaazon: Yeah, because your fundep is pi -> m, the pi has to feature, the m does not
16:13:23 <phaazon> ah, so…
16:13:24 <phaazon> m -> pi
16:13:27 <phaazon> :––––––––––’)))
16:13:43 <glguy> phaazon: in that case you can drop the pi, it's not used
16:13:59 <phaazon> yeah, so the monad is the interpreter
16:14:02 <phaazon> which is not that good
16:14:06 <glguy> No, that's fine
16:14:11 <glguy> That's how this style works
16:14:29 <phaazon> glguy: so we’d need to wrap everything in newtypes I guess?
16:14:37 <phaazon> EvanR: define the monad then ;)
16:15:10 <phaazon> what is Print :: String -> Program a -> Program a btw?
16:15:27 <phaazon> EvanR: with the free monad, you’d have:
16:15:40 <EvanR> what is it?
16:15:45 <phaazon> data ProgramF n = Print String n | GetLine (String -> n)
16:15:51 <phaazon> type Program = Fix ProgramF
16:15:53 <EvanR> its a program that always produces a
16:16:04 <phaazon> print str = liftF (Print str ())
16:16:15 <phaazon> getLine = liftF (GetLine id)
16:16:56 <Enigmagic> there is also operational
16:16:59 <Enigmagic> @hackage operational
16:16:59 <lambdabot> http://hackage.haskell.org/package/operational
16:17:16 <phaazon> glguy: so what do you think the differenc is between typeclasses and free monads for the interpreters problem?
16:17:29 <EvanR> http://lpaste.net/153079
16:17:35 <phaazon> Enigmagic: thanks for the link
16:18:11 <phaazon> EvanR: what is that :D
16:18:16 <lpaste> glguy pasted “program monad for phaeton” at http://lpaste.net/153080
16:18:24 <EvanR> dunno, the last line is messed up i see
16:18:29 <glguy> phaazon: sorry, spellcheck ate your name
16:18:35 <phaazon> no problem
16:18:37 <phaazon> it’s nice that way :D
16:18:46 <Enigmagic> phaazon: i find operational handy for stuff that can't be implemented in free
16:19:19 <phaazon> glguy: hm ok
16:19:21 <phaazon> in your case
16:19:22 <phaazon> you have Pure
16:19:25 <phaazon> so you can have a monad
16:19:48 <phaazon> without Pure
16:19:50 <phaazon> you need a free monad
16:20:01 <glguy> Yeah, which adds the Pure, so you get to the same place
16:20:01 <phaazon> which is exactly what Free gives you
16:20:05 <phaazon> yeah
16:20:15 <glguy> Sure, use Free
16:20:32 <EvanR> ok
16:20:36 <phaazon> data Free f a = Pure a | Roll (f (Free f a))
16:20:49 <phaazon> glguy: I was more wondering about the difference with typeclass
16:20:51 <glguy> I haven't been following chat closely, so maybe that paste isn't relevant then
16:21:39 <phaazon> especially:
16:21:57 <phaazon> what are the advantages of using a free monad instead of typeclasses?
16:22:30 <EvanR> im try not to use typeclasses for computation if i dont have to
16:22:33 <EvanR> trying*
16:22:44 <EvanR> because it seems like a hack
16:22:52 <phaazon> EvanR: a hack?
16:23:06 <phaazon> typeclasses are just dictionnaries
16:23:08 <phaazon> no magic there
16:23:22 <EvanR> right, so i have some type lists here and if i want to create a permutation then i think there might be a way using undecidable and overlapping instances
16:23:47 <EvanR> and it would whiz bang, but the type errors are insane if you dont have things right
16:24:08 <EvanR> it just seems like a different universe from normal haskell code
16:24:27 <lpaste> glguy annotated “program monad for phaeton” with “program monad for phaazon (annotation)” at http://lpaste.net/153080#a153083
16:24:27 <EvanR> so if theres another way ill use it
16:24:34 <glguy> phaazon: You can do stuff like this
16:24:49 <glguy> phaazon: and then write your code generically in terms of a Program constraint and run it multiple ways
16:25:02 <phaazon> glguy: yeah
16:25:04 <phaazon> I see that
16:25:06 <phaazon> so now
16:25:10 <glguy> and then extending functionality amounts to adding more typeclasses
16:25:11 <phaazon> why would I use a free monad
16:25:15 <phaazon> when you can write such a typeclass?
16:25:51 <phaazon> in the end, typeclasses and free monads are very alike
16:26:03 <phaazon> free monads are a bit like dictionnary passing as well
16:28:05 <glguy> Maybe it's easier to vary how you're interpreting the Free monad version at runtime? It'd be easier to switch to another interpreter than to get things to change types? Easier to pass interpreters around as values?
16:28:24 <glguy> I'd have to think more about it, I don't use the Free monad style for much of anything
16:28:32 <phaazon> yeah
16:28:33 <johnw> phaazon: typeclasses don't allow reflection
16:28:43 <phaazon> I’ve never used the Free type either
16:28:49 <johnw> which if you want to build custom optimizers, or interpret the same structure in multiple ways, can matter
16:28:58 <glguy> johnw: You can make a typeclass that reflects to a datatype, still
16:29:11 <phaazon> johnw: in multiple ways?
16:29:13 <johnw> but I can't pick which of 5 typeclasses to use
16:29:15 <glguy> and also optimizations are still possible via the typeclass implementations
16:30:04 <johnw> glguy: how is that?
16:30:07 <glguy> You can also have a: newtype ReifiedProgram a = Program (forall p. Program p => p a)
16:30:14 <johnw> ah
16:30:17 <glguy> for one
16:30:45 <glguy> and you can have typeclass isntances implemented in terms of other typeclass instances, passing down to the parent instance after doing optimization
16:31:24 <glguy> It's just not as easy to look down multiple levels like you can do with nested pattern matching on a concrete type
16:31:41 <glguy> but it's still possible
16:32:02 <EvanR> you can write the whole program as instances! ;)
16:32:24 <glguy> My Traversal optimizer runs as a stack of instances
16:33:15 <EvanR> traversal optimizer? link?
16:33:21 <glguy> http://www.galois.com/~emertens/generic-traverse-0.1-docs/Boggle.html
16:33:57 <glguy> it reassociates applicative computations to be left-associated with either zero or 1 uses of fmap
16:34:14 <glguy> my particular use case was getting efficient code generation from traversals constructed using GHC.Generics
16:36:42 <glguy> so maybe GHC.Generics would give you code like this:
16:36:43 <glguy> pure (07\x' (y',z') 07-> (x',y',z')) 07<*> f x 07<*> ((,) 07<$> f y 07<*> f z)
16:37:05 <glguy> but after GHC's optimizer ran your generated code would be what you'd have gotten from:
16:37:06 <glguy> 07\f (x,y,z) 07-> (,,) 07<$> f x 07<*> f y 07<*> f z
16:37:38 <shachaf> But the first one is right-associated and the second one is left-associated. :-(
16:37:50 <shachaf> Which is what you just said, I guess.
16:38:11 <shachaf> Why do you prefer left-association?
16:42:03 <glguy> Because it allows the GHC.Generics representation to optimize away
16:42:23 <glguy> Maybe right associated would have been fine
16:43:02 <glguy> but the mixed association you get from a naïvely generated traversal via GHC.Generics doesn't work out
16:43:43 <glguy> since it uses that balanced binary tree representation
16:46:43 <glguy> If you end up with code like: fmap M1 ..., where that M1 is stranded by itself behind an unknown Functor instance, then there's no hope of getting the generics representation to optimize away
17:18:06 <Lokathor> if you don't depend on the text package, but you make your own module that's named Data.Text, will ghc get mad at you? since text is a bundled package? or will it not care?
17:19:27 <geekosaur> shouldn't care, I hink
17:21:03 <Lokathor> seems to not care, yeah
17:21:40 <kadoban> Lokathor: But you probably shouldn't do that, by the way.
17:21:53 <Lokathor> yes I know
17:29:57 <Eduard_Munteanu> Does shakespeare play tricks on the environment? I can't get it to obey PATH when calling the typescript compiler.
17:31:16 * hackagebot hermit 1.0.1 - Haskell Equational Reasoning Model-to-Implementation Tunnel  https://hackage.haskell.org/package/hermit-1.0.1 (ryanglscott)
17:32:13 <sm> joeyh ? what was that thing you used to run terminal apps (Scroll) in the web browser ?
17:36:17 <timrs2991> I know I can overload an operator like `(<*>) :: (Double,Double,Double) -> (Double,Double,Double) -> (Double,Double,Double)`, but can I also overload it for `(<*>) :: Double -> (Double,Double,Double) -> (Double,Double,Double)`? I keep getting a `Duplicate type signatures for '<*>'` error
17:36:52 <shachaf> You can't overload operators in Haskell.
17:37:00 <geekosaur> you are not overloading, you are declaring a new one in your scope instead of the Prelude's
17:37:37 <geekosaur> there is no operator overloaded. there are typeclass operators instead
17:37:52 <dwn> why are these patterns non-exhaustive? http://lpaste.net/153084
17:37:59 <geekosaur> and I don't think you can do that one that way
17:38:11 <dwn> spews errors about the Ord binding if i do: merge ([], []) = []
17:38:51 <geekosaur> dwn, [xs] doesn't do what you think
17:39:00 <timrs2991> So if I wanted operators for vector math (ie: (5,6,7)*(8,9,10) and both 2*(1,2,3) ), should I avoid clashing with the Prelude's operators and define `mult` for these cases?
17:39:10 <geekosaur> you just wanted xs there (and similarly for the others)
17:39:20 <geekosaur> [xs] is a list containing a single item
17:40:07 <geekosaur> timrs2991, functions follow the same rules, you can't have two different ones in the same scope with different types
17:41:18 <pavonia> dwn: What is the exact error message? That code should at least compile fine
17:41:25 <EvanR> is there such a thing as a bi-contrafunctor
17:42:06 <timrs2991> That makes sense, thanks. I've been trying to port a c++ raytracer from college to Haskell to learn the language
17:42:16 <EvanR> if its not in kmettskell then it must be useless ;)
17:42:32 <dwn> pavonia: standard non-exhuastive pattern message in function merge on the last line of the merge declarations
17:43:19 <dwn> geekosaur: if I don't do that I get Could not deduce (a ~ [a]) from the context (Ord a)
17:44:09 <sm> joeyh: shell in a box! that's it. Also your telnet servers are still up but segfaulting :)
17:44:18 <pavonia> dwn: You don't handle the cases for lists with more than one element
17:44:53 <dwn> pavonia: what's the correct way to state "the entire list" if it's not [xs]?
17:45:03 <pavonia> Just xs
17:45:58 <geekosaur> dwn, you need to (a) move the first case to the bottom since it matches before the other two, and (b) change its result to xs ++ ys
17:46:14 <geekosaur> [xs, ys] is a 2-item list of lists
17:46:48 <dwn> oh. the main issue seems to be not using ++, yeah
17:46:50 <geekosaur> which is what's leading to the (somewhat obscurely mentioning Ord) type error
17:47:02 <dwn> thank you
17:51:55 <pumita> Hello, I need to explain why we can't perform equational reasoning in the IO Monad, that is: why doesn't exist a function `runIO` such as: f = x - y where x = runIO $ do {n <- getLine; return $ read n :: Int}; y = runIO $ do {n <- getLine; return $ read n :: Int}
17:53:11 <geekosaur> for one, how do you know what order they happen in?
17:53:29 <geekosaur> actions sequenced in IO have a well defined order. pure code does not
17:53:41 <pumita> geekosaur: I don't understand that part
17:54:22 <hpc> consider the following:
17:54:25 <hpc> f x y = x - y
17:54:30 <hpc> g y x = x - y
17:54:51 <hpc> for all x and y, it is obvious that f x y = g y x, right?
17:55:08 <pumita> yes
17:55:09 <EvanR> hehe
17:55:12 <geekosaur> pumita, Haskell is lazy. it does not execute things in the order you write them, and pure code guarantees that reordering is always correct.
17:55:27 <hpc> so, take your x and y, which read lines of input
17:55:31 <hpc> what does f x y do?
17:56:15 <geekosaur> which is why we need IO: the IO monad enforces, via a data dependency on a phantom parameter, that IO actions happen exactly in the order they are written. pure code cannot make such guarantees.
17:56:37 <EvanR> explaining IO via data dependencies on phantom parameters ;_;
17:56:47 <geekosaur> (there are ways to make it do so, but they are equivalent to writing the IO monad out long-wise
17:56:59 <pumita> hpc: it waits until I put the first number, and then the second one? :P I don't know
17:57:07 <geekosaur> no
17:57:13 <geekosaur> it does not know which is first
17:57:47 <geekosaur> you are used to languages where it does them in the order you write them. Haskell does not do that ... unless you write them in IO. the *same* IO, so it can order them relative to each other
17:57:53 <hpc> pumita: in what i expect you are imagining, it would read two lines and subtract #2 from #1
17:58:02 <hpc> pumita: but then g y x would do it the other way around!
17:58:08 <geekosaur> therefore having more than one IO context via some runIO gives you no ordering guarantees
17:58:38 <hpc> pumita: and this obvious equality no longer holds
17:59:39 <hpc> in many other languages, you would just say that f(getline(), getline()) is obviously different from g(getline(), getline()), but that's thinking in terms of procedures
17:59:41 <pumita> hpc geekosaur: oh I see it now, so it's about the order on how things are executed
17:59:45 <geekosaur> yes
17:59:57 <hpc> a function isn't a set of steps to follow, it's an equality that takes some parameters
18:00:03 <pumita> I thought it was because of side effects
18:00:13 <geekosaur> there are no ordering guarantees about pure code, except that some value will be available when it is  needed. when exactly that happens is not defined.
18:00:18 <pumita> because IO changes the state of the world or somtehing like that
18:00:31 <geekosaur> so it could look at x first, or y first, or even both at the same time
18:00:42 <hpc> pumita: (later you will learn a function is an equality that takes exactly one parameter, but currying isn't needed to understand this bit)
18:00:53 <geekosaur> no, because IO carries around a token that it passes around to enforce orderin
18:00:55 <geekosaur> g
18:01:17 <hpc> it doesn't necessarily carry a token around, per se
18:01:30 <hpc> but in a grand conceptual sense, IO is the entire world
18:01:42 <hpc> my noodly fingers are IO typing to you right now
18:01:47 <pumita> where I can read about the one parameter thing?
18:01:58 <geekosaur> you could do this yourself by passing something into every function and returning it, and passing the returned value into the next thing; this introduces a data dependency so the first thing must happen before the second
18:02:26 <geekosaur> IO is a monad for one reason only: so it can pass that around for you instead of making you do it to enforce ordering
18:02:39 <geekosaur> Everything else weird abou IO is not because of Monad but because IO is IO
18:02:40 <hpc> pumita: the key word to search for is "currying", which you can look up after this
18:03:08 <hpc> it's not needed to understand IO and doesn't really help directly in any way for this conversation
18:03:20 * exio4 hands geekosaur forkIO :p
18:03:56 <pumita> so, for example, if the f and g you defined before, take one parameter, it would be deterministic then?
18:04:14 <ggVGc> "it all started with a named Curry...."
18:04:23 <ggVGc> a man named*
18:04:57 <hpc> pumita: believe me, you'll only confuse yourself trying to understand both at once
18:05:06 <pumita> I mean, f x = x and g x = x, where x = runIO $ do {n <- getLine; return n}
18:05:14 <hpc> pumita: suffice it to say everything we've been saying is correct in both the presence and absence of currying
18:06:13 <getynge> Hello World!
18:06:16 <pumita> hpc thanks, I liked your example :)
18:06:31 <pumita> and another thing, why I can't type the Y combinator in haskell?
18:07:11 <getynge> Is it possible to perform pattern matching (I think that's what it's called) on Maybes?  As in f (x:s) = ... but have one function for Just and another for Nothing?
18:07:32 <hpc> pumita: the classic definition which i assume you are trying to use is going to rely on something like (\x -> x x)
18:07:44 <dmj`> :t fix
18:07:47 <lambdabot> (a -> a) -> a
18:07:56 <hpc> the type equations for that value turn out to be
18:08:06 <hpc> a -> b
18:08:25 <hpc> er, f = a -> b
18:08:30 <hpc> a = f
18:08:54 <pumita> hpc: yes, I've shown that I can't type that in some kind of church-style semantics from the Pierce book, I guess that Haskell follows the same type inference rules
18:08:55 <hpc> which is just a big long stack of (-> b) with no end
18:08:57 <hpc> or an infinite type
18:09:09 <verement> @src maybe
18:09:11 <lambdabot> maybe n _ Nothing  = n
18:09:13 <ggVGc> I often do things like this to have separate passes of updates to a value. How would I write it more idiomatic? https://gist.github.com/cbc9a41df962d81badfa
18:09:13 <lambdabot> maybe _ f (Just x) = f x
18:09:55 <hpc> @src fix
18:09:59 <lambdabot> fix f = let x = f x in x
18:10:23 <hpc> that's the common haskell definition, and there's some irrelevant implementation details for it being written that way
18:10:28 <hpc> a nicer formulation for learning is
18:10:33 <hpc> fix f = f (fix f)
18:10:57 <hpc> which it turns out, when going through the type unifier, is a solvable system of equations
18:11:03 <pumita> I used that definition to define the length of a list
18:11:24 <getynge> thanks for the help! I'd stay on longer but I g2g
18:11:26 <getynge> cya
18:12:11 <hpc> lemme try writing out the equations from memory
18:12:20 <hpc> fix = a -> b
18:12:33 <hpc> f = c -> b
18:12:42 <hpc> a = f
18:13:03 <anks> Can I, for a record type, have function that will list all it's field values? I've found that i'm writing a lot of boilerplate code that can be simplified to: getRecordFieldsAsList (RName {..}) = [field1, field2, ... ]
18:13:21 <hpc> via function call of f (fix f)
18:13:32 <hpc> and c = b, by going the other way
18:13:41 <hpc> (b -> b) -> b
18:13:47 <anks> Or rather more generally [f field1, f field2 ..], etc..
18:15:10 <hpc> there's a whole field of math behind the algorithms that make the types line up right, but you can often work your way through them intuitively once you've had some practice
18:16:41 <pumita> yes, thanks :) this was very helpful
18:17:39 <geekosaur> anks, nothing requires a record to contain fields of all the same type, so it's not possible to predefine something like that (the first one at least). the second is potentially doable but assigning a type to f and the list-making function gets "interesting"
18:18:22 <Cale> anks: https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html has some useful stuff in that direction
18:19:41 <anks> Cale: I think that's what Im looking for. Does generic programming introduce some performance costs?
18:21:02 <Cale> anks: some, for sure
18:21:26 <hodapp> it depends on how it's used, doesn't it?
18:22:21 <Cale> You're doing stuff with runtime type information and dictionaries of generic operations, rather than static programs which can be optimised at compile time, so it'll pretty much always be harder to compile efficiently.
18:24:03 <anks> that's what i was thinking about, thanks :)
18:24:35 <anks> Im gonna learn it anyway, cause i think this is  a piece i've been missing in haskell.
18:25:48 <anks> And I find it disappointing that for some task the equivalent code in C/C++ would be shorter but more perfomant than in Haskell.
18:26:48 <Cale> Well, there are also Template Haskell approaches to the problem.
18:26:54 <Cale> Which would result in static code
18:27:13 <exio4> you can SPECIALIZE things too
18:29:12 <anks> Ok, ill look into these. Thanks :)
18:30:17 <Lokathor> http://lpaste.net/153087 module needs a cleanup :/
18:31:32 <preyalone> is it possible to index lists with !! Integer, or do i have to use a trick like head . drop Integer ?
18:32:01 <Cale> preyalone: You should consider indexing lists at all as being a sort of last resort thing to do.
18:32:11 <Cale> preyalone: If you have to index a list, it probably shouldn't be a list
18:32:28 <Cale> But (!!) is there if you need it.
18:32:30 <EvanR> :t genericIndex
18:32:32 <lambdabot> Integral i => [a] -> i -> a
18:32:35 <EvanR> heh
18:32:55 <EvanR> in case you have ackermann style list indices
18:33:04 <Cale> (!!) does take an Int rather than an Integer
18:33:12 <Cale> (but then so do head and drop)
18:34:16 <EvanR> > genericIndex (repeat 1) (2^1000000)
18:34:22 <lambdabot>  mueval-core: Time limit exceeded
18:34:30 <EvanR> lambdabot: you meant to say 1
18:34:55 <preyalone> is there a convenience function for partitioning like (take n xs, drop n xs)?
18:35:02 <exio4> splitAt
18:35:07 <exio4> > splitAt 3 [1..10]
18:35:10 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
18:35:19 <exio4> it's in Data.List
18:37:11 <EvanR> is there a newtype or something to let me use >> as the mappend for a writer
18:37:37 <exio4> that sounds awful
18:37:42 <EvanR> ikr
18:38:02 <EvanR> Writer (IO ()) a
18:38:05 <preyalone> is there a version of splitAt that returns a tuple form of the partitioning?
18:38:21 <exio4> preyalone: what do you mean?
18:38:32 <dmj`> :t splitAt
18:38:36 <lambdabot> Int -> [a] -> ([a], [a])
18:39:19 <pumita> :t unsafePerformIO
18:39:23 <lambdabot> Not in scope: ‘unsafePerformIO’
18:39:31 <pumita> :( haha
18:39:33 <dmj`> preyalone: is ([a], [a]) not what you're looking for
18:40:25 <geekosaur> pumita, it exists, it's hidden, don't use it, (or do and learn the hard way why it's not an escape hatch to get something you are used to)
18:41:25 <pumita> geekosaur: yes, I know, I just want to find an example where the IO breaks
18:41:36 <geekosaur> Haskell doesn't evaluate things the way you are used to, and unsafePerformIO is an open invitation to weid behavior unless you understand fully what it is doing
18:42:01 <int-e> "breaks"?
18:42:03 <EvanR> :t readFile
18:42:07 <lambdabot> FilePath -> IO String
18:42:10 <EvanR> ^ IO breaks
18:42:11 <EvanR> ;)
18:42:21 <Cale> ?
18:42:38 <int-e> I guess EvanR doesn't like lazy IO.
18:42:46 <EvanR> confirmed
18:42:49 <Cale> It's really not all that bad, 99% of the time
18:43:33 <EvanR> if you like IO errors crashing an unexpected thread
18:44:10 <Cale> Well, it's often really unlikely that you'll have any kind of I/O error during a readFile
18:45:07 <EvanR> the 1% when its not ok, and suddenly you have to do maintenance on a server
18:45:31 <EvanR> becoming a larger than expected percent of perceived effort
18:45:35 <EvanR> (more than zero)
18:46:06 <EvanR> assuming IO never fails is ok too
18:46:26 * hackagebot warp 3.2.3 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.3 (KazuYamamoto)
18:46:30 <Cale> Well, typically you're reading some bit of configuration which the worst thing that can happen is that the file is missing, and it's not worth worrying about what if the file disappears or is rewritten halfway through reading it.
18:46:55 <EvanR> that is some fast and loose design
18:47:03 <Cale> Sure
18:47:14 <exio4> lazy IO is fine for certain things, I mean, I can't really hate you if you have a lazy list of values which are being computed concurrently
18:47:25 <exio4> and where those values, maybe, talk with some server or things
18:47:30 <Cale> But if it's not going to go wrong, then it's not worth spending lots of time overengineering a solution for.
18:47:54 <EvanR> id like to know and fail in the right thread before anything else happens
18:48:03 <Cale> I guarantee that if you reach for pipes or conduit every damn time, you'll drive yourself crazy (or at least get a whole lot less done)
18:48:49 <Cale> Most of the time that lazy IO isn't okay, then just using strict IO, like Data.Text.IO.readFile or Data.ByteString.readFile instead will be fine.
18:48:56 <preyalone> ah was just a typo
18:49:06 <preyalone> is there a version of splitAt that takes Integer indices?
18:49:26 <EvanR> yes strict IO, perfect ;)
18:49:43 <xpilot> is there any way to declare kind synonyms?
18:49:48 <dmj`> preyalone: you can zip [1..] xs
18:49:58 <dmj`> xpilot: doubt it
18:49:59 <Cale> preyalone: No, but you can usually get by just applying fromIntegral to convert (unless you expect to use very very large indices)
18:50:25 <xpilot> ghc doesn't seem to like type (~>) a b = TyFun a b -> *
18:50:26 <exio4> xpilot: in GHC8.0, it should be the same as a type synonym (as far as I know, haven't tried, just read the paper)
18:50:56 <exio4> xpilot: so, not for now :) 
18:51:16 <xpilot> exio4: darn. can't wait for ghc 8 though!
18:51:29 <xpilot> is ghc 8 usable yet?
18:51:31 <Cale> preyalone: What are you using splitAt to do?
18:52:32 <exio4> maybe for GHC9 we can stop using Haskell, and write our programs in the type checker 
18:52:58 <xpilot> I tried using goldfire's fork a while ago but couldn't use TH anymore :(
18:53:16 <xpilot> exio4: well, we already have agda, idris, coq...
18:54:21 <exio4> xpilot: which are quite nice!
18:54:38 <xpilot> exio4: yeah I was really happy with idris
19:00:51 <preyalone> i'm forming an open form solution to a proj euler prob. first demo f(1 .. 10), then rewrite for efficiency
19:01:17 <preyalone> what's a good way to make my Enum type's succ wrap around?
19:02:21 <EvanR> :t min
19:02:23 <lambdabot> Ord a => a -> a -> a
19:02:31 <exio4> preyalone: implement Enum on your own
19:02:50 <EvanR> hmm i wonder if you can get a faster min by using bounded, stop if you see the absolute min
19:04:17 <pavonia> > cycle [minBound .. maxBound] :: [Bool]
19:04:19 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
19:05:05 <EvanR> > minimum (cycle [minBound .. maxBound] :: [Bool])
19:05:18 <lambdabot>  mueval: ExitFailure 1
19:05:25 * EvanR knocks minimum on the head hello!
19:11:20 <int-e> > and (cycle [minBound .. maxBound] :: [Bool])
19:11:24 <lambdabot>  False
19:26:39 <EvanR> game programming is full of gotchas... if a bunch of events occur simultaneously, you dont want to have to care about what order the effects are done in. or you might think this is just too unlikely to matter. but for example when you transition from one scene to the next, you want to make sure the music is correctly canceled
19:27:09 <EvanR> if the music being cancelled is dependent on the scene state, then transitioning first might mean music is stuck on
19:27:42 <preyalone> is there an STM-like way to append to a list?
19:27:59 <EvanR> :t modifyTVar
19:28:00 <lambdabot> Not in scope: ‘modifyTVar’
19:29:58 <EvanR> i guess easier is to make background music be an ambience thing, it exists in so far as whats going on implies it, rather than needing to be explicitly activated and deactivated
19:30:10 <EvanR> which i guess means an annoying polling technique
19:30:26 <Ralith> any wxhaskell users around?
19:33:18 <exio4> EvanR: is that much of an issue?
19:33:56 <EvanR> i dont like polling
19:34:08 <exio4> EvanR: I mean, I am assuming you are rendering at 60FPS, having some "inconsistent" state within frames doesn't sound that bad, which would mean the next frame would see the new scene with the new background music
19:34:15 <EvanR> at least when it doesnt make sense, and besides that doenst address the other order-dependent stuff
19:35:06 <Lokathor> yeah i don't think a human will notice when the music isn't frame perfect unless it's literally a music game
19:35:18 <EvanR> exio4: for the polling case, it just means you have this task always running doing "is it still running? is it still running? is it still running?" to keep the music from stopping
19:35:26 <exio4> EvanR: er, what
19:35:37 <EvanR> which is annoying to me
19:36:21 <EvanR> yes i was originally bringing up what order simultaneous events are handled in
19:36:42 <exio4> EvanR: how are you playing music?
19:37:14 <exio4> a concurrent thread which keeps sending data to a device? (which be a pulse stream, jack port, alsa device, whatever)?
19:37:22 <EvanR> for the sake of this example you have a media player object with methods "play" "stop" "change song"
19:37:39 <EvanR> one or more of those
19:40:01 <exio4> EvanR: adding an if there doesn't sound bad, some concurrent state, read-only by the sound thread? 
19:40:42 <EvanR> whatever sound driver thread exists should not be checking game states
19:40:58 <exio4> it's not checking the game state, it's checking its own state
19:41:03 <EvanR> for what?
19:41:10 <exio4> so it knows what to do :) 
19:41:46 <EvanR> pretty far from my original context now ;)
19:42:10 <Lokathor> sounds like you want a TChan for music data, and a TVar for music state, and the music player reads from the chan, and the music sender reads the state and puts data into the chan. perhaps?
19:42:31 <EvanR> how to play music wasnt the point
19:42:54 <exio4> it'd be pooling its own state, you would modify that state with a play_sound() function which "tells" that thread what to do
19:43:03 <exio4> polling
19:43:40 <EvanR> but how simultaneous events to control stuff can either work or fail if they depend on state which each other are about to affect
19:44:02 <EvanR> in imperative programming you by default are already thinking about this and carefully sequence them
19:44:45 <Lokathor> well clearly your game flow shouldn't depend on your music, have your music only depend on game flow, and then you don't have any dependency loops
19:44:47 <EvanR> but if the events arent directly related then an FP way might not care about the ordering, and then youre damned
19:46:37 <Cale> Lokathor: wait, or *should* it? :)
19:47:02 <EvanR> new super mario bros is pretty awesome in that the music is synchronized with the animation
19:47:13 <EvanR> for really no reason
19:47:17 <EvanR> its just cool
19:47:30 <Lokathor> Cale, nope :3
19:49:52 <EvanR> lets say three interactions happen at the same time (for whatever reason), and each one produces a w -> w to update the world. you can do the three in any order, and the order may or may not matter
19:50:03 <EvanR> would be nice if it didnt matter, what can you do
19:50:35 <Lokathor> well, i think we can trivially propose a situation where order does matter
19:50:52 <EvanR> yeah, if the update are messing with the same parts of the world
19:50:52 <Lokathor> so since order might ever matter, there has to be an ordering imposed
19:51:32 <EvanR> and if one sequence means that some event shouldnt have even happened, then what
19:51:38 <EvanR> something is messed up
19:51:43 <Lokathor> now that ordering might be defined partly by the desired game mechanics, perhaps, but it must be there, and hopefully also in a consistant way that the player can understand
19:52:23 <Lokathor> yes, for example, killing blow and heal spell; if they're killed they can't be hit with the heal, if they're healed then hit the blow won't kill any more; so the player needs to be able to make sense of what's going on there
19:52:38 <EvanR> good example
19:52:49 <EvanR> its a race to see what the hell should have happened
19:53:05 <Lokathor> keep every value in the entire system within TVars exclusively, clearly
19:53:12 <EvanR> haha
19:53:53 <EvanR> well it shouldnt really be necessary since all data is pure anyway
19:54:18 <EvanR> its your job to compute the final result however you can
19:54:43 <Lokathor> doGame :: Input -> GameState -> (GameView,GameState)
19:55:21 <EvanR> i have that split up into different ways
19:55:37 <koz_> Is there a clever way to take x :: [[Text]] and make y :: [[Text]] consisting of column 4, columns 10-12, and columns 20-40 of x?
19:56:22 <EvanR> sounds like you want a matrix type
19:58:23 <EvanR> koz_: you can also transpose, select, construct new list, and transpose 
19:58:36 <EvanR> but... matrix
20:07:59 <mightybyte> Has anyone encountered this issue with HsOpenSSL?  https://github.com/phonohawk/HsOpenSSL/issues/50
20:10:57 <preyalone> can i append to an MArray by writing to a larger index, or would i need to first create a larger space?
20:13:01 <Cale> preyalone: You'd need to make a larger array
20:13:21 <preyalone> is there an array-backed linked list implementation for haskell?
20:14:26 <Cale> preyalone: What do you mean by array backed?
20:14:39 <EvanR> rope of arrays
20:14:51 <preyalone> a data type that allows me to cheaply append and cheaply access randomly
20:15:12 <EvanR> it wouldnt be a linked list if it was an array
20:15:18 <Cale> Data.Sequence qualifies, I suppose.
20:15:46 <Cale> Also, if you're not aware of it, see Data.Map
20:16:04 <slaterr> preyalone isn't that just an array?
20:16:05 <EvanR> sequence is really cool, but how is its performance?
20:16:10 <Cale> How big are the data structures you're manipulating?
20:16:25 <EvanR> slaterr: you cant "just append" to an array
20:16:35 <Lokathor> preyalone, if you really want the constant time access, and are willing to throw memory away, you could come up with an array-backed container that grows and shrinks by more than it needs to when forced to grow
20:16:37 <Cale> EvanR: The constant factors are a bit heavy, but asymptotically it's good.
20:16:42 <Lokathor> that's basicaly what an an ArrayList does in java
20:17:07 <slaterr> EvanR yes you can if it is a mutable array
20:17:13 <Cale> MVectors have a grow operation
20:17:25 <EvanR> slaterr: well its a fixed size
20:17:30 <Lokathor> preyalone, if it's acceptable, a standard list has cheap *prepend* of course
20:17:47 <Cale> Lokathor: But not cheap random access
20:18:09 <Lokathor> oh, right, well you might have to roll your own Arraylist then
20:18:11 <slaterr> EvanR so just double its element count when you hit limit.
20:18:20 <EvanR> "just" ;)
20:18:38 <slaterr> it will still waste less memory than a linked list
20:18:41 <Cale> preyalone: What is your application? What kind of data are you manipulating?
20:18:52 <slaterr> (probably)
20:19:02 <EvanR> dunno
20:19:10 <preyalone> a proj euler problem lol
20:19:35 <Cale> Okay, so what does the array/list contain?
20:19:38 <preyalone> Int's
20:19:52 <Cale> Do the Ints mean anything? :)
20:20:17 <preyalone> i don't want to give too much away--i'm solving the problem on my own, just trying to make various portions of my code more efficient
20:20:20 <Cale> Are the ones that you care about dense in the array?
20:20:48 <preyalone> i access the indices in linear order, but append in unpredictable order
20:21:09 <preyalone> what gets appended depends on the values near the beginning
20:21:16 <Cale> I would use Data.Map for a *lot* of things until I had a really good reason to use something else.
20:21:51 <Cale> Though it does have the downside that if you really want the filled indices to be contiguous, it doesn't guarantee that
20:22:07 <preyalone> ultimately, a cyclic array that grows a little and discards a little at a time would be fantastic--after a while, i don't need the first n elements anymore
20:22:38 <EvanR> sounds like a queue
20:23:10 <EvanR> (in reverse)
20:23:11 <Cale> Maybe try Data.Sequence, actually.
20:23:21 <Cale> It tends to make a pretty good queue
20:24:15 <Cale> You can insert reasonably efficiently (log of the distance to the nearer end) anywhere in the middle, and access to the front and back is constant time
20:24:22 <preyalone> thanks all! i think i'll go with Data.Sequence soon
20:24:22 <EvanR> i wonder what the performance comparison is for all these sequence structures vs an "obvious auto growing java array" implementation
20:26:04 <nshepperd> IntMap is there too, for efficientish random access
20:26:06 <EvanR> fixed size ring buffers are one thing but reallocating a large array sounds like a hit
20:26:50 <preyalone> if i do manage to get a reasonably efficient implementation, i'll reveal which problem i'm attacking, and which implementation i used
20:28:20 <Lokathor> most euler problems i did, the answer was some weird math transformation, so i gave up
20:30:32 <nshepperd> EvanR: amortised cost is something like 3 integer copies per element
20:30:46 <EvanR> of what
20:30:48 <nshepperd> with the standard doubling size strategy
20:31:13 <nshepperd> of appending n elements to a growing array, starting with it empty
20:31:38 <EvanR> how does that compare, if at all to a list
20:32:09 <Lokathor> that's why you always want to also have an "ensure capacity" operation
20:33:57 <nshepperd> probably much faster. a cons list has to go to the memory allocator to make a new cell every time you put something on the front, not just every n times
20:35:47 <nshepperd> dunno how much that costs since cache misses get involved there
20:37:41 <koz_> EvanR: Would Vector (Vector a) be suitable for this, or is there a full-blown Matrix out there?
20:38:24 <EvanR> hmatrix is probably overkill
20:38:38 <EvanR> i thought iknew of a simpler matrix library
20:39:25 <koz_> So I guess Vector (Vector a) will have to do.
20:39:39 <EvanR> yurg, youre probably better off with lists then ;)
20:40:01 <koz_> EvanR: Alrighty then. Transpose-select-transpose it is then.
20:40:24 <koz_> Time to write some fun munging code.
20:40:34 <Eduard_Munteanu> Or simply Vector a.
20:40:56 <Eduard_Munteanu> You just need to compute indices.
20:41:05 <koz_> Eduard_Munteanu: Yeah, that'd work too I guess.
20:41:10 <koz_> Although the indices would be quite large.
20:41:17 <EvanR> ... but... 
20:41:20 <koz_> (20,000 rows, 40 columns)
20:41:39 <Eduard_Munteanu> You have better memory locality.
20:41:50 <EvanR> this is why there should be a matrix type
20:41:53 <nshepperd> there's always /linear
20:42:10 <koz_> nshepperd: /linear?
20:42:21 <nshepperd> er, just linear
20:42:32 <nshepperd> https://hackage.haskell.org/package/linear linear algebra package
20:43:12 <koz_> nshepperd: I'm looking at it right now.
20:43:35 <koz_> It does seem a bit overkill for what I'm trying to do.
20:44:44 <nshepperd> oh, you were talking about manipulating [[Text]] things, not linear algebra matrices
20:44:47 <Cale> I don't think the types in linear are designed for high dimensional linear algebra
20:44:53 <Cale> and yeah...
20:45:00 <koz_> nshepperd: Yeah.
20:45:20 <koz_> I need a way of constructing a new [[Text]] from an old [[Text]] by grabbing rows and gluing them together.
20:45:28 <EvanR> you can try Arrays
20:45:35 <EvanR> which do support slices
20:45:46 <EvanR> but ive had trouble with it
20:45:50 <koz_> EvanR: https://hackage.haskell.org/package/array <-- this?
20:45:54 <EvanR> yeah
20:45:59 <nshepperd> transpose-select-transpose does seem like the most sensible approch here
20:46:06 <montanonic> Wouldn't Vectors be better for that though?
20:46:16 <EvanR> Arrays can be 2D
20:46:33 * EvanR looks for the simple matrix lib
20:46:36 <koz_> Once I get my hands on the full data set for this, it's going straight into XML.
20:46:43 <koz_> Because fucking CSV is fucking annoying.
20:46:49 <Eduard_Munteanu> Ew, XML.
20:46:57 <nshepperd> s/XML/json/
20:46:58 <koz_> Eduard_Munteanu: It's a lot easier to do transformations on.
20:47:15 <Eduard_Munteanu> Well, you could use like, an efficient binary format...
20:47:28 <koz_> Eduard_Munteanu: I wanna keep it in a textual form.
20:47:48 <koz_> There's no reason to binarise that data, and if I wanted *that*, I'd stuff it into an SQLite DB or something.
20:48:02 <nshepperd> Cale: there's a whole bunch of V2, V3, V4 types, but there's also the general V n a for doing any dimension
20:48:14 <Eduard_Munteanu> Or that.
20:48:44 <Cale> nshepperd: yeah, but I don't know how well that works for large numbers
20:48:45 <Eduard_Munteanu> Beats me why people insist on textual representations.
20:49:22 <nshepperd> it's just a Data.Vector underneath
20:49:27 <Cale> Oh, it actually is, okay
20:50:06 <EvanR> V n is still "1 D"
20:50:56 <Cale> Well, it's n dimensional, but rank 1.
20:51:29 * koz_ is reminded *again* that classy-prelude has no transpose for some raisin.
20:55:15 <Lokathor> import ClassierPrelude
20:55:31 <koz_> Lokathor: I just need to send a PR to it.
20:56:23 <dmj`> koz_: do you use NoImplicitPrelude on every file? 
20:56:23 <dmj`>  
20:56:45 <koz_> dmj`: Yeah, I thought that's what you did with alternative preludes.
20:57:01 <kadoban> import ClassiestMostLuxuriousPrelude
20:58:02 <geekosaur> as distinct from ClassistPrelude >.>
20:58:08 <dmj`> koz_: Prelude is pretty good imo, sure it'd be nice to have foldl' but meh
20:58:41 <kadoban> There's a couple of things I don't really like about Prelude, but not enough to make me want to actually try an alternative really.
21:00:20 <montanonic> BasicPrelude has been flawless for me so far
21:01:02 <montanonic> Actually, hold that, it's given me a bit of grief with implementing Show instances because `show` defaults to working with Text
21:01:22 <montanonic> but I can't live without `map` == `fmap`
21:01:47 <koz_> montatonic: Isn't classy-prelude just CorePrelude from basic-prelude with some extras?
21:02:11 <montanonic> Yes
21:02:23 <montanonic> But the typeclass stuff it does leads to weaker type inference
21:02:30 <montanonic> Not by much, but in some cases
21:04:33 <scshunt> If a type has Show and Read defined, you should have read (show x) = x
21:04:39 <scshunt> (for some value of =)
21:04:55 <scshunt> but is it ok to make a Show instance that doesn't convey full information, such as when a record contains a function?
21:06:21 <EvanR> Show is either for adhoc debugging or for 2-way serialization
21:06:32 <EvanR> these are pretty incompatible so pick one
21:06:47 <EvanR> (not for pretty printing)
21:06:57 <dmj`> scshunt: can you move the function out of the record?
21:07:34 <scshunt> the former
21:07:38 <scshunt> definitely the former
21:07:53 <scshunt> actually, hmm
21:08:01 <scshunt> dmj`: sort of
21:08:06 <lambda-11235> I like setting instance Show (a -> b) where show _ = "<function>", in my .ghci so don
21:08:28 <scshunt> I have a monadic action type, and a number of records that contain both the action type and a textual representation of it
21:08:32 <lambda-11235> 't have to cotinually do :t f.
21:09:53 <montanonic> lambda-11235: that's a good tip; I'm going to do that myself now
21:09:57 <montanonic> I like that a lot
21:10:01 <scshunt> that's *awesome*
21:10:04 <scshunt> hmm I wonder
21:11:44 <scshunt> does anyone have a solid style guide somewhere?
21:11:52 <scshunt> with pedantic things like how to format & indent line continuations
21:13:48 <scshunt> hrmmmmm
21:13:58 <scshunt> I will revisit this later
21:14:08 <scshunt> since I will want serialization of some parts of this program
21:14:15 <scshunt> maybe I'll make it a separate module with show instances
21:14:23 <scshunt> (orphans)
21:16:18 <scshunt> hmm, nah
21:17:10 <Lokathor> if only the show instance of a function could be the function's type
21:17:15 <scshunt> yeah
21:17:19 <scshunt> > id
21:17:22 <lambdabot>      No instance for (Typeable a0)
21:17:24 <lambdabot>        arising from a use of ‘show_M199118160365402075431174’
21:17:26 <lambdabot>      In the expression:
21:17:29 <scshunt> O_o
21:18:59 <jle`> there are a bunch of id's
21:19:21 <jle`>  id :: Int -> Int, id :: Bool -> Bool, id :: String -> String, etc.
21:19:32 <Lokathor> i tried to put that instance line in my ghci
21:19:38 <Lokathor> didn't seem to do it >_>
21:26:26 <Lokathor> lambda-11235, what does your ghci file look like specifically?
21:26:32 * hackagebot hasql-transaction 0.4.3 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.4.3 (NikitaVolkov)
21:28:00 <koz_> OK, I need some advice. My problem description is here: http://paste.rel4tion.org/264
21:28:51 <koz_> My current thoughts involve Map use, but I was wondering if there was another way using some kind of black Haskell magic.
21:36:28 <xpilot> koz_: (Int)Map sounds like the right way to do it
21:37:11 <koz_> xpilot: Yeah, I thought folding into a Map was the way, but I was wondering if there was something else I could use.
21:38:27 <kadoban> koz_: Is it always is sorted order like that already?
21:39:09 <kadoban> You could do it based on grouping up adjacent "equal" lists (sort first if you have to). But it's not really any better, and a Map would be easier usually.
21:39:27 <glguy_> :t \xs -> fromListWith (++) [ (k,[v]) | k:v <- xs ]
21:39:29 <lambdabot>     Not in scope: ‘fromListWith’
21:39:31 <lambdabot>     Perhaps you meant one of these:
21:39:33 <lambdabot>       ‘IM.fromListWith’ (imported from Data.IntMap),
21:39:39 <lpaste> lambda-11235 pasted “~/.ghci file” at http://lpaste.net/153093
21:39:40 <glguy_> The Map version will go fast if the list is already sorted on its own
21:39:57 <lambda-11235> Lokathor: http://lpaste.net/153093
21:40:01 <kadoban> Err wait, I misread the desired version, hmm.
21:40:52 <Lokathor> lambda-11235, weird, http://lpaste.net/153094 that's mine and it doesn't work for me
21:41:01 <glguy_> you could use an array, possibly
21:41:10 <kadoban> You could do it with (sorting), grouping and traverse, but it's probably going to look not amazing.
21:42:01 <montanonic> koz_: http://lpaste.net/153095
21:42:15 <montanonic> koz_: use that on foo, see if you can make it work from there
21:42:48 <pavonia> lambda-11235: Is that your actual prompt? :D
21:42:56 <koz_> montanonic: What the ... woah.
21:43:31 <montanonic> koz_: I can't tell if that's helpful for you? 
21:43:39 <montanonic> koz_: or is it not in the right direction?
21:44:21 <lambda-11235> pavonia: Yeah, I like a lot of spacing in my prompts. :)
21:45:04 <montanonic> koz_: oh, it doesn't actually look helpful now that I see your Baz
21:45:13 <montanonic> bar*
21:45:16 <montanonic> koz_: my bad
21:45:17 <lambda-11235> Lokathor: Does it work if you type it into the REPL?
21:46:26 <koz_> montanonic: No problem - I appreciate the help!
21:46:28 <montanonic> koz_: http://lpaste.net/153095; update it; all this does is it gives you a list of all the first elements without duplicates
21:46:37 <montanonic> updated* it
21:46:49 <koz_> montanonic: Ah, OK.
21:46:51 <koz_> :t group
21:46:52 <montanonic> in a tuple with the original list
21:46:54 <lambdabot> Eq a => [a] -> [[a]]
21:47:51 <montanonic> koz_: you'll actually want to add a sort before the group
21:47:59 <montanonic> group . sort 
21:48:07 <montanonic> unless your input list is sorted
21:48:08 <montanonic> already
21:48:35 <Lokathor> lambda-11235, oddly it does
21:48:41 <Lokathor> not sure why it won't work out of the ghci
21:49:02 <koz_> montanonic: I'm not certain of this, so I'll sort it just in case.
21:49:19 <montanonic> koz_: I updated the code to reflect that
21:50:16 <montanonic> koz_: it's very simple: transpose gets all the first elements of each sublist in one list at the beginning (as if you have a matrix); I just sort and group those together to put all the equal elements in individual lists, then take the head of each of those lists to remove duplicates
21:50:43 <montanonic> koz_: that could be a helpful first step towards getting your foo into bar
21:50:52 <mitochon> anyone familiar with checkers library (extension of quickcheck) ? ... having this problem -> http://lpaste.net/153096
21:52:46 <koz_> montanonic: Thanks - that led me to groupBy, which is exactly what I was looking for!
21:52:55 <montanonic> koz_: excellent
22:01:33 * hackagebot set-extra 1.4 - Functions that could be added to Data.Set.  https://hackage.haskell.org/package/set-extra-1.4 (DavidFox)
22:05:50 <EvanR> can i has type holes at the type level
22:15:08 <chasm> trying to get started with hoc: http://lpaste.net/5142730369203699712
22:15:17 <chasm> hpc sorry autocorrect
22:16:12 <chasm> I get the same thing when I try to get a report from my more meaningful program
22:16:32 <chasm> any hints?
22:17:38 <montanonic> koz_: so yeah, I don't know if there's a magic Haskell way to solve that problem, but there totally might be. Anyways, I was curious to properly solve it (I like algorithm problems), so I came up with this naive solution: http://lpaste.net/153095 .
22:18:35 <kadoban> chasm: stack build has --coverage, does that do the same thing?
22:21:57 <MarcelineVQ> montanonic: What's the exercise?
22:23:03 <montanonic> MarcelineVQ: http://paste.rel4tion.org/264
22:23:24 <kadoban> My pretty lazily done version:
22:23:26 <kadoban> > let f = map (fmap transpose) . map ((head . head) &&& fmap (drop 1)) . groupBy ((==) `on` head) . sort in f [[1, 2, 3], [1, 3, 5], [2, 2, 5], [2, 3, 7]]
22:23:29 <lambdabot>  [(1,[[2,3],[3,5]]),(2,[[2,3],[5,7]])]
22:23:44 <kadoban> Could probably be improved to be an actual solution, mostly would have to deal with the couple of partial functions (head)
22:23:54 <kadoban> And ya know … make it readable at all.
22:23:58 <montanonic> kadoban: haha, nice!
22:24:23 <montanonic> I updated mine. Realized that my three lines of `removeFirstMatch` function was actually just `drop 1` in the context of this problem.
22:24:23 <kadoban> I tried to use headMay, but … bleh lambdabot doesn't seem to have it in scope or something, so that ruined it.
22:24:55 <montanonic> :( legacy Haskell code :(
22:26:10 <chasm> kadoban: interesting - there is a .stack-work/.../7.10.3/hpc directory but it has an html error report in it to the same effect... seems odd that there would be "build --coverage" and "hpc report" as separate commands... kinda lost I admit
22:26:10 <osfameron> oh! NotJustMaybe is out of favour :-( https://wiki.haskell.org/Not_just_Maybe
22:29:30 <liste> osfameron: let's see if MonadFail brings it back
22:30:29 <kadoban> chasm: Never really messed with coverage :-/ Not too sure how it's supposed to work, unfortunately.
22:34:17 <osfameron> liste: is that this proposal: https://github.com/quchen/articles/blob/master/monad_fail.md ?
22:35:00 <liste> osfameron: yes
22:36:06 <osfameron> ah, great.
22:36:45 <osfameron> but while we wait for that to get released, the old NotJustMaybe pattern will still work (but cause Haskellers to wince)?
22:40:48 <kadoban> osfameron: MonadThrow sounds applicable if you want to do that.
22:42:11 <montanonic> Any blog posts on Extensible Effects ever since it got reimplemented using the Freer Monad?
22:42:30 <montanonic> The only stuff I can find is from ~2 years ago, which isn't really an accurate representation of EE in its current iteration.
22:43:50 <osfameron> kadoban: ta
22:46:03 <osfameron> ah, I see that's documented in e.g. https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices
22:58:44 <EvanR> the best thing about exception best practices is there are so many best practices
22:59:39 <Cale> heh
23:01:27 <Cale> Personally, I tend to avoid the monad transformers and type classes for the most part. I can see using them in some obscure cases, like maybe where my base monad is StateT s [] or something.
23:04:38 <Cale> I use Either when I expect the thing to be dealt with immediately, or synchronous IO exceptions in the case where I expect the error probably won't be handled by default. I reserve async exceptions thrown from evaluation for things that I really want the program to die over if they're ever triggered.
23:16:52 * hackagebot bitx-bitcoin 0.7.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.7.0.0 (tebello_thejane)
23:40:46 <MarcelineVQ> > map (head . head &&& transpose . map tail) . groupBy ((==)`on`head) . sort $ [[1, 2, 3], [1, 3, 5], [2, 2, 5], [2, 3, 7]] -- kadoban, barely shorter, the map head head makes me think this should operate a level deeper though.
23:40:49 <lambdabot>  [(1,[[2,3],[3,5]]),(2,[[2,3],[5,7]])]
23:51:54 <kadoban> MarcelineVQ: Yeah, true, that extra map isn't really useful.
