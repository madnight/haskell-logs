00:08:04 <shanemikel> wow
00:08:09 <shanemikel> mind blown
00:08:40 <shanemikel> I think I'm gonna have to study some cat theory
00:09:56 <julianleviston> shanemikel: this is a cat. 
00:10:02 * julianleviston proffers a cat
00:19:30 <Lokathor> so how much does haskell optimize polymorphic code during it being compiled? "well enough"?
00:19:45 <Lokathor> compared to writing the non-polymorphic version that is
00:21:27 <peddie> Lokathor: there exists a SPECIALISE pragma, so it seems like there's something to be gained in some cases
00:21:38 <Lokathor> hmm
00:21:57 <Lokathor> well i've got some stuff using tuples of Int as locations
00:22:10 <Lokathor> for now i'll leave it at that, and perhaps move to Num a later on if i really need to
00:22:16 * hackagebot stackage-curator 0.13.1 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.13.1 (MichaelSnoyman)
00:34:41 <liste> how can I install leksah with stack? do I just add the proposed packages to global stack.yaml, rinse, repeat?
00:45:16 <int-index> I have TemplateHaskell code that generates a definition. I want to generate lenses for that definition, but makeLenses uses reify that fails, since the generated definition is not yet available
00:45:50 <liste> int-index: would placing them in different packages and re-exporting work?
00:45:53 <liste> modules*
00:47:38 <int-index> liste, how that would help? Let me elaborate. I have a function `genDef :: String -> DecsQ`. String here is the name of the data type that will be generated.
00:47:39 <pikajude> how do I generate haddock documentation that has hyperlinks between identifiers in the source code like on hackage?
00:48:10 <int-index> I surely can do this: `genDef "SomeName"; makeLenses ''SomeName`
00:48:20 <int-index> but I want to call makeLenses within genDef
00:48:21 <Axman6> pikajude: stack build --haddock works for me
00:48:47 <liste> int-index: oh, now I get it
00:48:57 <pikajude> ugh, guess i'll have to go install stack and figure out how it calls haddock
00:49:11 <pikajude> Axman6: what haddock version
00:54:30 <shanemikel> "[construct] a building out of bananas" -- Simon Peyton Jones https://www.youtube.com/watch?v=pHtk437yD1s
01:02:56 <julianleviston> shanemikel: I wonder which language he had in mind when he was saying that :)
01:02:58 <julianleviston> (if any)
01:19:32 <coconut> how to skip exception and continue running ?
01:19:44 <coconut> im using zipWithM_
01:20:04 <coconut> one of the IO actions could generate exceptions 
01:20:12 <coconut> i dont want to stop the program
01:20:17 <wpad> if this is a noob question, i apologize. how's haskell for networking? like setting up simple servers, making email client etc.
01:21:46 <int-index> coconut, catch the exceptions
01:22:04 <int-index> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html
01:22:17 <coconut> im using try..
01:22:20 <coconut> case of
01:22:57 <int-index> In this case there should be no problems.
01:23:10 <coconut> the action is to use pandoc to convert files. one of the files couldnt be converted and i would like to skip it
01:23:28 <coconut> with with try it still stops
01:24:20 <coconut> http://lpaste.net/151857
01:26:16 <int-index> I don't see why it would stop
01:29:46 <saurabhnanda> just broadcasting this here: http://stackoverflow.com/questions/35266143/ghc-compiler-not-complaining-about-incorrect-code-paths
01:32:51 <int-index> wpad, to see how good Haskell is a particular task, I recommend https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
01:33:38 <int-index> See "Server-side programming"
01:39:01 <wpad> [3,10..100] is doing something else then what i expected. i thought i would get [13, 16, etc.] but i got [3,10,17,24, etc.] what is happening?
01:39:17 <wpad> thanks int-index
01:39:31 <frerich> wpad: The first two numbers give the 'stepping width'
01:40:02 <frerich> wpad: I.e. you asked for the list which starts with 3, then 10, then go on like that (which means: keep adding 7) until 100
01:40:20 <jle`> wait, how would [3,10..100] imply [13,16, etc. ] ?
01:40:44 <wpad> i see. i was thinking 3 was the step, i'm used to python
01:41:13 <frerich> wpad: In Python's range() function, isn't the stepping width the last argument?
01:41:48 <jle`> > [5, 4 .. ]
01:41:50 <lambdabot>  [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,...
01:41:55 <wpad> yes, but i thought this was the same only stepping width was first argument
01:41:59 <Geraldus__> hi friends!
01:42:11 <jle`> ah yeah, the comma isn't there to separate 'arguments'
01:42:28 <jle`> [2, 4, 6, 8, 10] is [2, 4 ... 10]
01:42:34 <jle`> [2, 4 ... and so forth ... 10]
01:42:38 <wpad> it's going to take some getting used to :)
01:43:12 <Geraldus> I need to get items from list in random order,  can anyone suggest me some *good* random package? 
01:43:43 <jle`> do you want to shuffle the list and pull the first few items?
01:43:49 <jle`> or draw items from a set multiple times, with replacement
01:43:52 <Geraldus> I'm not expert in this, but it looks like there is some issues with most of them
01:44:12 <Geraldus> jle`: I'm writing solitaire game, I just need to shuffle list
01:44:19 <frerich> Geraldus: I think I'd shuffle the list and then take as many items as you need. There is a 'random-shuffle' package which has a convenient 'shuffle' function to do this (I used that in the past for a little game).
01:44:41 <jle`> easiest way to shuffle is just to zip with a list of random doubles and sort it on the doubles
01:44:53 <jle`> the 'random' package should be fine
01:44:58 <Geraldus> frerich: thanks
01:45:08 <Geraldus> jle`: oh, nice
01:45:10 <jle`> > zip "hello" (randoms (mkStdGen 10) :: [Double])
01:45:11 <lambdabot>  [('h',0.9411121095656491),('e',0.38022658385886665),('l',0.6880194990342998)...
01:45:18 <jle`> > sortBy (comparing snd) $ zip "hello" (randoms (mkStdGen 10) :: [Double])
01:45:20 <lambdabot>  [('o',0.3112947328521384),('e',0.38022658385886665),('l',0.45347134400258726...
01:45:24 <jle`> > map fst . sortBy (comparing snd) $ zip "hello" (randoms (mkStdGen 10) :: [Double])
01:45:26 <lambdabot>  "oellh"
01:45:26 <Geraldus> :t nubSort
01:45:28 <lambdabot> Not in scope: ‘nubSort’
01:45:40 <wpad> ok, new problem: i did [5,4..] and now i want to do something else. how do i abort (i have stopped it).
01:46:03 <frerich> Geraldus: I have this piece in my little game: http://lpaste.net/151858 -- I ask the user for a 'game number' and then use that to shuffle the cards.
01:46:19 <jle`> @let shuffle gen = map snd . sortBy (comparing fst) . zip (randoms gen :: [Double])
01:46:20 <lambdabot>  Defined.
01:46:28 <jle`> > shuffle (mkStdgen 10) "hello world"
01:46:30 <lambdabot>      Ambiguous occurrence ‘shuffle’
01:46:30 <lambdabot>      It could refer to either ‘L.shuffle’,
01:46:30 <lambdabot>                               defined at /tmp/mueval1600515282040332871.hs:169:1
01:46:37 <jle`> aw
01:46:40 <jle`> wpad: ctrl+c ?
01:46:50 <jle`> @let shuffle' gen = map snd . sortBy (comparing fst) . zip (randoms gen :: [Double])
01:46:51 <lambdabot>  Defined.
01:46:58 <jle`> > shuffle' (mkStdGen 10) "hello world"
01:47:00 <lambdabot>  " loeldolwhr"
01:47:01 <jle`> > shuffle' (mkStdGen 20) "hello world"
01:47:03 <lambdabot>  "w dlllreooh"
01:47:04 <jle`> > shuffle' (mkStdGen 30) "hello world"
01:47:06 <lambdabot>  "edrlw olohl"
01:47:08 <jle`> etc.
01:47:41 <jle`> i'd consider it overkill to import a whole package for that, heh
01:48:24 <wpad> jle`: thank you
01:48:50 <jle`> np!
01:55:11 <Geraldus> jle`: thanks! (:
01:55:18 <jle`> np :D
01:55:27 <Geraldus> :t mkStdGen
01:55:28 <lambdabot> Int -> StdGen
01:55:29 <zyxoas> Hi, peeps. How do I get GHC (>= 8) to produce a detailed stack trace on error? The type of undefined is now "forall (v :: GHC.Types.Levity) (a :: TYPE v). GHC.Stack.Types.HasCallStack => a" which causes undefined to print a stack trace, but it seems to only tell us where undefined was called, and says nothing about the functions which called it.
01:56:21 <zyxoas> I need to know how to (implicitely, hopefully) thread this information throughout the entire code path, so that the stack trace gives more useful information than "undefined was called on line x, and that is all".
01:56:33 <zyxoas> Anyone know how to do this? :-)
01:56:47 <zyxoas> :t undefined
01:56:49 <lambdabot> t
01:56:56 <Geraldus> :t random
01:56:58 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
01:57:24 * hackagebot boombox 0.0 - Chronokinetic stream sources and incremental consumers  https://hackage.haskell.org/package/boombox-0.0 (FumiakiKinoshita)
01:57:32 <jle`> Geraldus: if you're in IO, you can use newStdGen :: IO StdGen
01:57:41 <zyxoas> I tried adding "GHC.Stack.Types.HasCallStack =>" to my function types, but I can't seem to import that symbol...
01:57:49 <Geraldus> jle`: yeah, I know (:
01:58:36 <wpad> take 23 [2,4..] is genius
01:59:21 <bergmark> zyxoas: did you try `import GHC.Stack'?
01:59:35 <Geraldus> I just was confused a bit about security concerns (I read about weakness of random generators from `nonce` package announcement by Felipe Lessa), but I guess this is not so important fot shuffling list for a game 
02:01:08 <merijn> Geraldus: Weakness of random generators generally means "not secure for cryptographic use"
02:01:18 <zyxoas> bergmark Yeah, GHC.Stack does not have that symbol. Am I going about this the wrong way?
02:01:24 <merijn> Geraldus: Most standard pseudo-random algorithms are more than good enough for, e.g. games
02:02:27 <Geraldus> merijn: yeah, I re-read announcement message and came to same thoughts
02:03:14 <Geraldus> oh, pals, by the way, how should I pronounce `instance Show Int`?
02:03:52 <Geraldus> :i StdGen
02:04:37 <jle`> lambdabot has no :i   :O
02:04:42 <merijn> Geraldus: I would usually say "Int is an instance of Show"
02:04:45 <jophish__> Geraldus: Instance of Show for Int
02:04:54 <bergmark> zyxoas: i'm guessing you want `?loc :: CallStack'?
02:05:07 <jophish__> merijn's is a little better actually
02:05:49 <Geraldus> merijn: jophish__: thanks!
02:06:57 <martinvlk> Geraldus: Int has an instance of Show
02:07:03 <Geraldus> merijn: and how should I spell that I'm defining instance (e.g. instance Show Int)?
02:07:44 <martinvlk> Geraldus: just like you said IMO
02:08:02 <martinvlk> you are defining an instance of Show for Integer
02:08:17 <Geraldus> martinvlk: thanks!
02:08:19 <martinvlk> /s/Integer/Int
02:08:46 <Geraldus> I mixed sometime with "instance of Int for Show"
02:08:55 <Geraldus> *I mix
02:09:00 <Geraldus> sometimes
02:13:59 <zyxoas> bergmark: bizarely, even though Vim w/ GHC-Mod/Hdevtools seems to not like me using the HasCallStacksymbol, the file compiles just fine and does give a stack trace.
02:14:48 <bergmark> zyxoas: :-t
02:15:26 <zyxoas> bergmark: it would appear that HasCallStack is in Base-4.9.0.0, which comes with GHC 8, but the base version on Hackage is still only 4.8.*. That is, the docs for the latest Base do not exist on Hackage.
02:16:19 <zyxoas> So my Vim tools must be using my Stack GHC, or something, and they can't recognise that symbol. I don't know, but I'm not happy that Hackage does not have the docs for the latest version of BAse...
02:16:32 <bergmark> zyxoas: base won't be uploaded until ghc 8 is released
02:16:56 <bergmark> there's a candidate: https://hackage.haskell.org/package/base/candidates/
02:16:56 <zyxoas> bergmark: Alright. So I'm flying blind here. Hehe.
02:17:15 <bergmark> oh candidates can have docs too, didn't know that
02:17:19 <zyxoas> Ah. Excellent! I was not aware of this. :-D
02:19:08 <zyxoas> bergmark: do you know if there's a way to add this annotation to every function automatically? The "HasCallStack" context?
02:19:39 <bergmark> zyxoas: not that I know, we've just added them in strategic places
02:19:50 <merijn> zyxoas: hdevtools/ghc-mod use the GHC api and were presumably built against GHC 7.10, not GHC 8.0, therefore they don't know about HasCallStackSymbol
02:20:33 <merijn> zyxoas: i.e. they don't use GHC (the executable) at all, they are linked with GHC (the library)
02:20:59 <merijn> zyxoas: FYI, ghc should install a local copy of the base docs on your machine
02:21:12 <zyxoas> merjin: Thanks. I thought as much. I'd rather not risk screwing up my VIM by trying to update GHC-Mod, &c. hehe
02:22:09 <zyxoas> Thanks a lot merjin and bergmark. :-D
02:22:19 <zyxoas> merijn
02:24:00 <merijn> zyxoas: Try looking in ~/.cabal/share/doc to find the relevant docs
02:32:25 * hackagebot generics-sop 0.2.1.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.2.1.0 (AndresLoeh)
02:33:25 <bollu> hey guys
02:33:30 <bollu> I was wondering about GSoC
02:33:34 <bollu> and if haskell projects are applying for it
02:33:49 <bollu> I for one would *love* to work on anything haskell this summer :)
02:39:13 <bezirg> hi, I want to access the two TVars of the STM's TQueue abstract datatype. What is the canonical way to do that? Is it better to 1) modify the stm library and distribute it with my code, or do sth like unsafeCoerce?
02:41:17 <merijn> bollu: AFAIK GHC has been part of GSoC almost every year
02:41:56 <merijn> bezirg: I wouldn't modify stm, but merely copy the TQueue implementation and expose what you need
02:42:43 <merijn> bezirg: That's what I did when I needed "broadcast" Chan, just base my own implementation on the code in Chan, the TQueue module is fairly small, afaik
02:43:02 <bezirg> merijn: aha, so I only provide my own TQueue module?
02:43:10 <bezirg> merijn: that is what you are suggesting?
02:44:02 <bezirg> merijn: I think this is a good idea! thank you very much!
02:44:22 <merijn> bezirg: Yeah
02:44:47 <merijn> bezirg: I'd change the name to avoid collissions with stm
02:46:09 <bezirg> merijn: y I call it MyTQueue, ugly name I know
02:46:12 <bezirg> :D
02:51:20 <JJJollyjim> Hey, is there a type for a List of a certain length which is not known until runtime, or is that outside of the possibilities of Haskell?
02:53:52 <frerich> JJJollyjim: I guess [a] does not count? :-}
02:54:39 <JJJollyjim> Well, no :-)
02:54:50 <JJJollyjim> Is that the realm of languages like Idris?
02:55:32 <frerich> JJJollyjim: I suspect you may be looking for dependent types, in which case I'd indeed look at Idris. However, maybe it's not worth it to move to an entirely different language.
02:56:47 <JJJollyjim> Sure, makes sense
02:59:50 <bollu> merijn: whoa that's cool
03:00:01 <bollu> merijn: I don't know anything about GHC, but I'm totally willing to learn
03:00:17 <bollu> merijn: if I'd apply for it, are there mentors willing to help me out? (I'll put in the effort ofc)
03:19:44 <obadz> Looking to parse an HTML block into a record with multiple field. Is there an easy way to write a lens to do that?
03:19:48 <obadz> Or are lenses more appropriate for single field type of datatypes?
03:20:30 <Geraldus> Hey pals, can I make `stack` use another haddock executable, e.g. that one I have built with `stack install`?
03:20:48 <jle`> obadz: lens works for multi-field types, but you probably are looking for a parser, not a lens
03:21:29 <jle`> that being said the wreq library has some lenses to interface with parsers of html data
03:21:53 <obadz> I've been using wreq with lenses
03:22:39 <obadz> I'm zoomed in to the point where I have <tr><td>x</td><td>y</td></tr> and just need to turn that into MyRecord x y
03:22:56 <obadz> was hoping not to context switch from a lens to a parser
03:23:23 <obadz> am using taggy-lens
03:24:23 <obadz> actually the example in taggy-lens haddock is useful
03:28:06 <obadz> :t to
03:28:07 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
03:28:13 <obadz> I don't understand this guy
03:31:13 <jle`> obadz: you can zoom in just a little more to get x and y, right?
03:31:22 <jle`> obadz: 'to' makes a Getter from a function
03:31:29 <jle`> > view (to fst) (1,2)
03:31:31 <lambdabot>  1
03:31:35 <jle`> > view (to show) (1,2)
03:31:37 <lambdabot>  "(1,2)"
03:31:53 <jle`> > view (_1 . to (+1)) (1,2)
03:31:55 <lambdabot>  2
03:32:03 <obadz> > set (to fst) 3 (1,2)
03:32:05 <lambdabot>      Could not deduce (Contravariant Identity)
03:32:05 <lambdabot>        arising from a use of ‘to’
03:32:05 <lambdabot>      from the context (Num t, Num t1)
03:32:17 <cocreature> you can’t use a getter to set things :)
03:32:18 <jle`> it doesn't give you something you can 'set' with, heh
03:32:27 <jle`> because it'd be difficult to infer it from just 'fst'
03:32:45 <obadz> that's what I thought, so this thing isn't really a Lens
03:32:53 <jle`> yup, it's a 'Getter'
03:33:06 <obadz> ok, makes sense
03:33:08 <jle`> all Lenses can be used as Getters, so that's neat
03:33:11 <jle`> but not all Getters are lenses
03:33:30 <jle`> the hierarchy is on this page -- http://hackage.haskell.org/package/lens
03:33:44 <obadz> I only need 1-way in this case so will use to
03:33:59 <obadz> thx I need to refresh myself with this hierarchy
03:34:57 <cocreature> if you have a getter and a setter you can use lens (https://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Lens.html#v:lens) to construct a Lens instead of only a getter
03:35:43 <jle`> mhm.  from the picture you can see that lenses can be getters, folds, setters, and traverses, so they can view, toListOf, set/over, traverseOf, etc.
03:35:53 <jle`> but getters can only get and fold.
03:36:11 <obadz> it would have been great if the graph in http://hackage.haskell.org/package/lens included expanded type signatures
03:36:54 <jle`> i guess the intended workflow is that you look in the diagram for the type signature instead of asking ghc/ghci
03:38:48 <jle`> but, it would be nice to see the definition of Prism, Iso, Getter, etc.
03:39:06 <jle`> feels a bit incomplete because the definition of Lens and Traversal are there
03:39:53 <cocreature> those two don’t use all the profunctor machinery so maybe that’s why only they are there
04:30:40 <puregreen> am I right that using lens-aeson is a tradeoff between convenience and error reporting? namely, with lenses you can deconstruct JSON values really easily but when e.g. a field wasn't found you'll get Nothing instead of “field X wasn't present”?
04:31:29 <Liskni_si> as if that was any better :-)
04:42:28 <obadz> So when composing a bunch of lenses, if there's a single Fold in the chain, the whole thing is a fold, right?
04:43:07 <obadz> (since Fold is a leaf of the "subtyping" tree in http://hackage.haskell.org/package/lens)
04:44:32 <jle`> yes
04:52:58 <kqr> puregreen, yeah, I think so. I had a discussion with someone here before on just creating prisms for all kinds of coding/decoding and where you lose is in error messages
05:00:33 <csd_> where does ghc define what list comprehensions mean?
05:02:18 <liste> csd_: https://www.haskell.org/onlinereport/exps.html at least the standard defines list comprehensions there
05:03:51 <rod_> Hi, i am on project euler problem 15 (https://projecteuler.net/problem=15) and cause my first solution took to long to compute i introduced State to speed up. A grid of 20x20 should have 400 Positions but my program (http://lpaste.net/151860) runs out of memory ... does someone hve a clue ?
05:04:39 <csd_> liste: so its something that's not going to be in a library like GHC.base? but rather actually defined within the compiler?
05:06:15 <liste> csd_: the "translation" part in that page defines list comprehensions in terms of [], if, let and concatMap
05:06:47 <liste> and True
05:07:30 <liste> I don't know about the implementation, but it'd make sense that GHC did something similar
05:09:45 <csd_> liste: ok thanks this is helpful too
05:10:12 <csd_> maybe translating that identify is part of the parser ?
05:18:18 <liste> csd_ probably it's part of desugaring
05:18:27 <liste> like e.g. do notation
05:32:50 <dgpratt> I was looking at the rules for HM inference and there's (at least) one aspect I don't fully understand
05:33:15 <merijn> dgpratt: Shoot
05:33:44 <dgpratt> in a couple premises (e.g. T-Lam), it looks like the context is being...augmented
05:33:51 <dgpratt> Γ, x:τ1 ⊢ e:τ2
05:33:54 <dgpratt> hmm
05:34:15 <dgpratt> can you see that ok, merijn ?
05:34:24 <dgpratt> doesn't quite come through right from here
05:34:34 <frerich> It looks ok here.
05:34:35 <opqdonut> (I see it fine)
05:34:37 <dgpratt> ok
05:34:47 <merijn> dgpratt: 1 sec
05:35:23 <dgpratt> so that's the premise for T-Lam and a conclusion of Γ⊢λ x . e:τ1→τ2
05:36:11 <opqdonut> in practice when HM hits a lambda abstraction \x->e, it adds x::a (for a fresh variable "a") to the context, and type infers e
05:36:46 <dgpratt> opqdonut, I see...sorta
05:36:47 <merijn> dgpratt: It's basically saying that the variable 'x' is removed from the context
05:36:51 <opqdonut> the type inference of "e" might result in "a" getting unified with something
05:37:03 <opqdonut> narrowing the argument type
05:37:09 <dgpratt> ohh
05:37:15 <dgpratt> ok, that kinda makes sense
05:37:28 <merijn> dgpratt: So "If we can see that 'e : t2' given some free variable 'x : t1' then we can say the same if 'x' is NOT a free variable, but bound by a lambda
05:37:55 <merijn> dgpratt: The gamma is there to signify that 'e' might have OTHER free variables in addition to 'x'
05:38:00 <dgpratt> that makes even more sense :)
05:38:56 <merijn> Incidentally, insert obligatory recommendation of TaPL
05:39:23 <dgpratt> merijn, I have TaPL on a shelf collecting dust atm :)
05:39:32 <bergmark> i brought my TaPL book to work, one of my colleagues is now using it as a laptop stand :-(
05:39:55 <dgpratt> I keep pulling it down every 3-4 months and seeing how far I can get with it this time :)
05:43:48 <dgpratt> regarding my experiences with TaPL, I find that I can understand the proofs as they are presented to me, but I have little to no intuition for deriving proofs de novo
05:43:52 * mjrosenb cannot remember which one TaPL is... is it the first or the second book?
05:44:45 <merijn> The first
05:44:49 <{AS}> Hi, has anyone used SparseCheck?
05:45:01 <merijn> dgpratt: Learning how to write proofs is hard and requires practice :)
05:45:10 <merijn> dgpratt: Incidentally, there's a (free) book for that too ;)
05:45:12 <merijn> @where sf
05:45:12 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
05:45:12 <lambdabot> assistant."
05:45:17 <mjrosenb> ahh, I read that one through, thought it would be good for reference, and haven't actually purchased the second.
05:45:32 <dgpratt> oh nice, I'll check it out, thanks merijn
05:45:33 <merijn> dgpratt: The covers formal proofs of programs using Coq :)
05:45:41 * dgpratt runs away
05:46:10 <mjrosenb> it is always weird seeing the name of someone you know from undergrad on the author list of a book.
05:46:49 <{AS}> I was wondering if there were any limitations that made it not as used as QuickCheck
05:48:44 <joko> Hello, what's the most elegant way of handling Maybe datatypes?
05:49:05 <{AS}> joko: Depends on what you want to do
05:49:29 <joko> I have some IO (Maybe datatypes) and I have filled my code with helper functions with cases and do nothing
05:49:49 <bergmark> joko: have you looked at MaybeT?
05:50:27 <joko> bergmark: no, checking now
05:53:25 <{AS}> joko: You may also want to take a look at MonadIO
05:53:37 <{AS}> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-IO-Class.html
06:07:18 <telmich> good day
06:07:40 <telmich> anyone usings emacs w/ haskell mode in here? I'm trying to find out how indent with guards is supposed to work
06:08:31 <bergmark> telmich: you can also try #haskell-emacs
06:16:22 <mjrosenb> ooh, sounds neat
06:16:23 <Ankhers> telmich: What exactly are you having issues with?
06:19:48 <telmich> Ankhers: when I define a function, press enter and type '|' the guard stays un-indented
06:19:56 <telmich> bergmark: thanks for the hint
06:21:19 <Ankhers> telmich: If you press tab anytime after typing '|', does it indent correctly?
06:22:20 <telmich> Ankhers: ahh, now after I enabled haskell-indent, it indeed does
06:23:06 <int-index> How do I call makeLenses for a type that I've just generated in my TH code?
06:23:17 <int-index> makeLenses relies on reify, and there isn't anything to reify yet.
06:24:08 <int-index> Basically, I have `genDef :: String -> DecsQ` where String is the name of the data type to be generated
06:24:20 <int-index> Currently I call `genDef "SomeName"; makeLenses ''SomeName`
06:24:27 <int-index> I want to call makeLenses within genDef somehow.
06:24:49 <quchen> int-index: Maybe makeFieldOpticsForDec :: LensRules -> Dec -> DecsQ
06:24:56 <quchen> http://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Internal-FieldTH.html#v:makeFieldOpticsForDec
06:25:07 <int-index> quchen, I should try this, thanks.
06:25:15 <quchen> int-index: It's what makeLenses uses
06:25:32 <quchen> makeFieldOptics is a reify call chained with that function, and makeLenses is a makeFieldOptics call
06:29:03 <quchen> Is there an easy way to open a file with `stack ghci`? It seems it only allows directories
06:29:17 <quchen> I'd like to do "ghci test.hs" in a (global) stack env
06:35:14 <tekkkz> Hello! In the HaskellBook, chapter 9 (LISTS), at the chapter exercises, Number 7, squishAgain ... I don't understand what this function should be able todo because I should reuse squishMap ... why? What? Can someone explain me please what squishAgain should do. The task is on page 386 at version 0.9.2
06:36:46 <frerich> tekkkz: Can you paste some code (e.g. type signatures and code you wrote so far) up at lpaste.net? It's kinda hard to tell.
06:37:03 <obadz> is there a Prism from Text to Int ?
06:45:22 <tekkkz> i have no. only whats on this page of the book ...
06:46:14 <Ankhers> tekkkz: Not everyone has the book, so people can't help you if they don't have the description of the exercise.
06:47:58 <Ankhers> tekkkz: Do you have a definition for squishMap from exercise 6?
06:49:00 <Ankhers> For anyone interested, squishAgain :: [[a]] -> [a], needs to be defined in terms of squishMap :: (a -> [b]) -> [a] -> [b]
06:49:08 <puregreen> obadz: I don't think there is (you can write unpacked._Show, tho)
06:49:30 <obadz> puregreen: thx
06:50:14 <tekkkz> yes
06:50:31 <tekkkz> sorry that i waws too slow :/
06:50:49 <tekkkz> Ankhers, so what does this means?
06:51:06 <tekkkz> i have squishMap already, but what should squishAgain do?
06:51:37 <Ankhers> tekkkz: It should do the same thing as sqitsh from exercise 5.
06:51:45 <Ankhers> squish
06:51:56 <tekkkz> and why should i use shquishMap inside it?
06:52:26 <int-index> quchen, makeFieldOpticsForDec worked nicely, thank you
06:52:45 <Ankhers> tekkkz: I haven't gone through the book yet. Maybe it is leading up to something else.
06:52:47 <frerich> tekkkz: Do you know the 'id' function?
06:53:06 <tekkkz> yes
06:53:24 <frerich> tekkkz: That might be useful. :-)
06:53:30 <tekkkz> what?
06:53:55 <pavonia> If I have a type "data Handler = Handler { parseRequest :: String -> Maybe foo, requestToURI :: foo -> Maybe URI }", is there a way to state "I don't care which foo is used, as long as both foos match" without making foo a type parameter?
06:54:02 <tekkkz> i mean how should i use squishMap in squishAgain without giving a function - you think id as function - but what sense is this making?
06:54:07 <frerich> tekkkz: Well try to get a piece of paper and thing of what happens when you pass 'id' as the first argument to 'squishMap'
06:54:38 <tekkkz> frerich, ik, but what a sense is the use of squishMap then when i jsut apply id ?
06:55:23 <puregreen> pavonia: data Handler = forall foo. Handler {...}
06:55:24 <frerich> tekkkz: I meant 'squishMap id', not 'id squishMap' :-)
06:55:37 <frerich> tekkkz: Compare the types of those.
06:55:37 <tekkkz> yes
06:55:46 <tekkkz> i know what you mean
06:55:47 <pavonia> puregreen: Ah, thanks
06:56:27 <tekkkz> frerich, squishMap id ... is not compiling (error)
06:57:06 <tekkkz> oh it does
06:57:09 <tekkkz> sorry, my mistake
06:57:11 <tekkkz> yes
06:57:25 <tekkkz> i know what you mean, but like i said 5 mins ago, what a sense does it have>
06:57:33 <tekkkz> *?
06:57:52 <frerich> tekkkz: What is the behaviour of 'squishMap'?
06:58:21 <tekkkz> with id it is concatting the list
06:58:52 <frerich> tekkkz: It flattens the list, right - is that not what 'squishAgain :: [[a]] -> [a]' is supposed to do?
06:59:02 <frerich> I.e. the function you're trying to define in terms of squishMap?
06:59:14 <tekkkz> yes. but isnt it the same like squish then?
06:59:22 <tekkkz> from behavior?
06:59:29 <Ankhers> tekkkz: It is supposed to be the same.
06:59:45 <tekkkz> oh, just with the euse of map ... yaya now i understand the task
06:59:56 <frerich> tekkkz: Exactly, 'squishAgain' is the same as 'squishMap id'. The former is defined in terms of the latter
07:00:03 <tekkkz> maan, sorry ... im german, so sometimes i don't understand everything right :D
07:00:23 <frerich> tekkkz: I'm not buying that excuse, I'm german, too. ;->
07:00:25 <hodapp> I'm American, which means I always understand everything perfectly, except for things that no one needs to understand.
07:00:39 <Ankhers> I almost never understand German correctly.
07:00:58 <tekkkz> Ankhers, from where are you?
07:01:32 <frerich> Ankhers: It's simple, german thinking is almost, but not quite, entirely unlike british thinking. Simple, innit?
07:02:14 <tekkkz> >> germans are thinking? *g*
07:02:17 <merijn> ok, so System F_omega question (or perhaps Core?)
07:02:33 <merijn> So I'm trying to implement typechecking for recursive ADTs and things get messy...
07:03:16 <merijn> Suppose I have the following code: http://lpaste.net/151866
07:03:52 <merijn> To typecheck I need to instantiate 'a' at typecheck time, no?
07:04:00 <merijn> Maybe my implementation is just dumb...
07:05:21 <EvanR> trying to check the type of head?
07:06:29 <merijn> EvanR: My typechecker goes wonky because it's not sensibly dealing with the "Nil a" (or Cons a, for that matter), but I'm a bit confused how to deal with that, as the Henk paper kinda glosses over ADTs
07:07:56 <chelfi> quchen: would 'stack ghci' then ':l test.hs' work for you ?
07:08:12 <pavonia> This is probaly the wrong approach http://lpaste.net/151867 but is there a way to have handlers with different intermediate types and still be able to use the fields as usual?
07:08:41 <quchen> chelfi: Unfortunately no, I'd like to use zsh glob patterns to load certain files into GHCi, like `ghci *.hs`
07:09:55 <Ankhers> frerich: From what I know of the language, I like it a lot more than English. I just haven't put in enough time to properly learn it.
07:10:02 <EvanR> merijn: yeah instantiate an a, then check the type of head a is List a -> Maybe a
07:10:31 <merijn> EvanR: But it makes no sense to instantiate 'a' in a polymorphic context like head
07:10:42 <EvanR> it does
07:11:08 <EvanR> its not any particular type, its a particular a
07:11:20 <EvanR> er its not any type, its a particular type, just unnamed
07:11:36 <EvanR> the a's in the List a -> Maybe a have to end up being equal to it
07:11:58 <EvanR> and if you instantiated another variable later, and they ended up in those positions, it shouldnt check
07:12:23 <EvanR> this is the reverse process of inferring the type of head
07:12:39 <EvanR> where youll generalize the a instead of specializing
07:13:24 <puregreen> pavonia: I don't think so (how would you write the type of parseRequest, for instance?)
07:14:40 <puregreen> pavonia: actually, what exactly do you want all this for?
07:14:42 <EvanR> merijn: i guess you could call such an a a "rigid type variable"
07:15:01 <merijn> EvanR: I need to meditate on how to implement this
07:15:50 <EvanR> a should also not match any particular type constant either, like Int, since you didnt specifically choose Int, and you have no evidence it is Int like a equality constraint
07:16:10 <pavonia> puregreen: I want to be able to pass data to all handlers, ignoring the intermediate result, but still be able to use a very specific handler with a certain request
07:16:39 <pavonia> I tried to avoid typeclasses but is seems this is the only way
07:17:30 <puregreen> pavonia: then perhaps you should write “data Handler foo = ...” but make your passing-data function polymorphic: “passData :: Handler foo -> String” (or whatever should it be instead of String)
07:18:08 <EvanR> merijn: since you have explicit foralls, really every type variable in the language acts like this
07:18:26 <merijn> EvanR: I think the bug is the fact that I'm typechecking by basically instantiating expressions, but I'm not instantiating inside patterns, which is what I would need to do for this
07:18:28 <puregreen> pavonia: and if e.g. you also want to be able to store all handlers in a list, make a SomeHandler wrapper
07:19:01 <puregreen> * passData :: Handler foo -> String -> String
07:19:04 <EvanR> merijn: well.. when you apply head to some a, it gets substituted into the pattern
07:19:10 <merijn> EvanR: (i.e. I'm typechecking lambda's by basically replacing occurences of a variable with it's type and seeing if the expression makes sense), but it didn't occur to me that I should do the same with patterns
07:19:19 <merijn> Actually
07:19:43 <EvanR> actually thats not even right
07:19:45 <pavonia> puregreen: I'll try that, thanks
07:19:49 <EvanR> pattern variables act differently
07:19:50 <merijn> I think the main problem is that my case syntax is wrong
07:19:55 <EvanR> wouldnt Nil a be a new a ?
07:20:02 <merijn> EvanR: Yeah, I just realised this
07:20:16 <EvanR> zonk
07:20:40 <merijn> EvanR: The Henk paper actually has an explicit "case ... of { ... } at { ... }" to annotate the type
07:20:51 <merijn> Although that syntax doesn't make a lot of sense either, imo
07:20:57 <EvanR> yeah you need to write the case differently
07:21:11 <merijn> I don't quite understand the syntax proposed in the paper
07:22:20 <merijn> They propose "case (reverse xs) of { Cons -> \y ys . <rhs1>; Nil -> <rhs2> } at { Int }", which seems to have the compiler "magically" infer the fact that Cons/Nil have additional type arguments filled in with Int
07:22:25 <merijn> Which makes no sense to me
07:23:00 <EvanR> since all patterns are at the same type, you can list top level types to fill in the foralls
07:23:11 <EvanR> in the order they are in in the data type
07:23:36 <merijn> EvanR: That only works if type arguments precede other arguments
07:24:06 <merijn> Which isn't mandatory at all for System F_omega
07:24:08 <EvanR> List : * -> * -> * ?
07:24:12 <EvanR> what other arguments
07:24:21 <merijn> EvanR: Not in this example
07:24:34 <merijn> But obviously the typechecker needs to be able to deal with every possible version
07:24:40 <EvanR> like what
07:24:41 <merijn> But, I think I understand my flaw
07:25:34 <EvanR> yeah i think that syntax is a list of arguments to the type constructor
07:25:48 <merijn> Anyway, that's clearly not necessary
07:26:17 <merijn> I should just *not* typecheck the type argument there, but rely on the checking of the RHS
07:26:24 <EvanR> you can also have a special case behavior in the patterns, type variable positions dont indicate new vars, they are substitutable vars, but thats weird
07:27:09 <EvanR> yes where check it means that the RHS produces a List a, how you get that a to that part of the code is with that extra syntax
07:27:30 <EvanR> because otherwise filling in the original forall loses the a somewhere
07:27:34 <merijn> I don't need extra syntax, I think
07:28:46 <EvanR> you just have to pass in the expected type of the case to the check for the case somehow
07:30:41 <joko> Is it possible to have extra pattern matching inside a lambda function? E.g. in (\_ (results, oldSeed) -> ( (fst $ rand oldSeed) : results, snd $ rand oldSeed )) to get rand oldSeed
07:31:01 <phadej> joko: yes
07:32:29 <joko> phadej: where is not working :S
07:32:37 <phadej> > (\(a,b) -> (b, a)) ("foo", "bar")
07:32:38 <lambdabot>  ("bar","foo")
07:33:29 <schorsch80> hi everyone?
07:33:35 <phadej> joko: where?
07:33:59 <joko> phadej: I was thinking sth like (\_ (results, oldSeed) -> ( (fst a : results, snd a) where a = rand oldSeed)
07:34:10 <schorsch80> I have a question about a function as parameter
07:34:23 <schorsch80> evalAExpNd :: (String -> [Int]) -> AExp -> [Int]
07:34:33 <phadej> joko: where doesn't work in lambda, use let ... in ..
07:34:46 <phadej> i.e. where isn't expression syntax
07:35:11 <schorsch80> how do I get the Singel String from  (String -> [Int]) and how do I get the single [Int] from (String -> [Int]) ?
07:35:28 <phadej> > (\(a,b) -> let z = "quux" in (b ++ z, a ++ z)) ("foo", "bar")
07:35:30 <lambdabot>  ("barquux","fooquux")
07:35:46 <EvanR> schorsch80: you cant get a String from a (String -> Foo)
07:35:50 <phadej> yet I'd rather give that function a name already
07:36:08 <EvanR> you can only get a Foo if you have a String
07:36:32 <schorsch80> hm
07:36:53 <EvanR> so find a String somewhere and you can apply that function
07:37:27 <joko> phadej: many thanks!
07:38:15 <schorsch80> thanks EvanR
07:38:27 <schorsch80> I think about that
07:44:21 <schorsch80> @EvanR
07:44:21 <lambdabot> Unknown command, try @list
07:50:50 <EvanR> schorsch80: probably use User: instead of @User on IRC
07:51:12 <schorsch80> thanks for the hint
07:51:32 <schorsch80> I will play a little more with my example before quering again
07:55:40 <Wizek> Anyone knows with stack how could I check what version of a package is installed for test-suite? stack list-dependencies seems to exclude test deps.
07:55:56 <schorsch80> user:EvanR
07:56:01 <schorsch80> User:EvanR
07:56:22 <schorsch80> User:
07:56:28 <exio4> schorsch80: you should do it like this, <nick>: 
07:56:44 <exio4> schorsch80: you should be able to tab-complete his nick, too.
07:57:03 <schorsch80> I am using webchat
07:57:15 <schorsch80> EvanR: test
07:57:44 <EvanR> test passed
07:58:12 <derpling> I just implemented a PID controller in Yampa frp... I like it! :)
07:58:16 <lpaste> derpling pasted “PID Controller in Yampa FRP” at http://lpaste.net/151870
07:58:16 <mpickering> How can I make stack use a haddock executable which isn't on my path?
08:06:42 <bergmark> mpickering: is it in your local stack folder? stack exec -- haddock
08:06:56 <mpickering> I am asking for Geraldus 
08:07:37 <mpickering> but I think he wants a way to run the stack equivalent of "cabal haddock --with-haddock=... --haddock-options=..."
08:09:13 <Geraldus> bergmark: yep, I have installed it by `stack install`
08:10:16 <Geraldus> which haddock shows me .local/bin path, while stack exec which -- haddock shows me a version packed in GHC 7.10.3.app (I'm on OS X)
08:10:42 <Geraldus> oh, let me try
08:11:21 <can0n7d> :D
08:11:30 <can0n7d> Hiya folks
08:11:47 <Geraldus> bergmark: hmm… hyperlinked-source is still not available
08:11:51 <Geraldus> can0n7d: o/
08:12:25 <can0n7d> had to google that Geraldus.
08:12:54 <can0n7d> Is it fine to ask general programming questiosn here?
08:12:58 <can0n7d> questions*
08:13:25 <can0n7d> Not even programming, just stuck at a preliminary phase...
08:13:29 <geekosaur> hyperlink-source is actually a cabal(-the-library so also Setup.hs) option not haddock
08:13:41 <geekosaur> can0n7d, this isn't the best channel for it
08:14:22 <can0n7d> Any recommendations geekosaur? Two channels I've been on were super toxic.
08:14:32 <geekosaur> (the last one triggered an extended discussion of subtyping, iirc, which probably confused the heck out of the asker)
08:16:55 <Geraldus> geekosaur: hmm… I have several(!) haddocks now: one from GHC 7.10.2.app (which I will remove soon), another from GHC 7.10.3.app, and finally haddock built from source (git v2.16 branch).  The last one have --hyperlinked-source support (it prints this option in help), two others - does not.  The question is how to make stack to use .local/bin/haddock?
08:17:20 * mjrosenb is usually interested in answering general programming questions, even if it is off topic.
08:17:46 <luigy> Geraldus ah you want hyperlinked source
08:17:56 <Geraldus> luigy: yes (:
08:18:00 <geekosaur> Geraldus, that I can't help with. possibly just: PATH=$HOME/.local/bin:$PATH stack ...
08:18:17 <geekosaur> (that is, temporarily augment PATH for stack)
08:18:53 <Geraldus> geekosaur: which haddock shows me manual built haddock, however stack still picks up old version so I guess PATH is OK
08:19:01 <geekosaur> (if you're using a nonstanard shell you may need toprefix that with "env")
08:19:19 <geekosaur> hm. is stack providing your ghc?
08:19:37 <geekosaur> because there's probably a haddock in there with it, in that case
08:20:11 <schorsch80> Hi agian
08:20:28 <Geraldus> I believe I can build my project with cabal and invoke needed version of haddock directly, but ideally I want to make stack use new haddock, because all my Haskell workflow is based ob stack now
08:20:45 <luigy> Geraldus if you stack install from the cloned repo of haddock that I assume you have it should place it on ~/.local/bin
08:21:04 <geekosaur> luigy, it's already installed there
08:21:13 <schorsch80> I have a possible infinie list of [Bool] and I want to get all unique (true, false) entries, so nub could  stop after one true and one false found, but it won't 
08:21:16 <geekosaur> asking again: are you using a ghc that stack installed?
08:22:00 <geekosaur> haddock is part of ghc these days, although it can be installed separately. so if stack is managing your ghc installations, it may have an (older) haddock as part of the ghc installation
08:22:48 <luigy> geekosaur this all just seems to be a path problem.... stack does a very simple check to see if the haddock in the env has hyperliked-source support and uses it
08:23:33 <EvanR> schorsch80: it also wont stop if its just trues
08:23:41 <EvanR> so its about as useful
08:23:43 <schorsch80> jea
08:23:48 <luigy> you also have to update Cabal to 1.22.7.0 which has bug fixes for the unreleased haddock, but you're not even that far yet I suppose
08:23:49 <schorsch80> that would be fine
08:23:53 <EvanR> it all your lists are fininte and you only expect to consume answers lazily, its ok
08:24:00 <EvanR> are infinite
08:24:19 <EvanR> termination is overrated
08:24:29 <schorsch80> okay
08:24:54 <EvanR> (otoh this infinite nub isn't guaranteed to be productive)
08:25:11 <schorsch80> my lists are finate but i thought it woult be more lazy to abort earlier instead of parsing the maybe hughe amoutn of other bools
08:25:18 <luigy> by update I mean -> `stack setup --upgrade-cabal`
08:26:20 <EvanR> > take 2 . nub $ cycle [True,False]
08:26:22 <lambdabot>  [True,False]
08:26:36 <EvanR> > take 2 . nub $ cycle [True]
08:26:38 <luigy> I hope stackage goes back to it soon. I haven't had any problems which any packages so far https://cloudup.com/cAxlRpLkHd0
08:26:41 <lambdabot>  mueval: ExitFailure 1
08:26:51 <Geraldus> geekosaur: I have several GHC version, two of them are from "dot-apps" (OS X bundles of GHC), but since I use stack everywhere it have separate GHC installations (also 7.10.2 and 7.10.3)
08:27:09 <EvanR> schorsch80: take 2 will abort if it finds 2
08:27:20 <EvanR> and will terminate for finite lists
08:27:23 <schorsch80> oh 
08:27:46 <schorsch80> so take 2 nub xs ?
08:27:56 <EvanR> :t take 2 . nub
08:27:57 <lambdabot> Eq a => [a] -> [a]
08:28:03 <Geraldus> luigy: stack exec cabal -- --version prints me 1.22.6 for cabal-install and 1.22.4 for Cabal library
08:28:34 <EvanR> > take 2 [True]
08:28:35 <lambdabot>  [True]
08:28:57 <luigy> Geraldus once you resolve the PATH issue you will have to update since there where some issues when parsing packages with multiline synopsis
08:29:05 <Geraldus> luigy: haddock in the env is points to ~/.local/bin/haddock, which have hyperlinked-source option, however it does not allow me to use it
08:30:07 <Geraldus> luigy: mmm… how can I update stack's Cabal?
08:30:15 <luigy> Geraldus ~/.local/bin/haddock --help | grep hyperlinked-source
08:30:21 <luigy> what do you get from that ^ ?
08:30:46 <Geraldus> luigy:  --hyperlinked-source             generate highlighted and hyperlinked source code (for use with --html)
08:30:53 <luigy> actually omit the ~/.local/bin
08:31:03 <Geraldus> luigy: same output from `haddock --help …`
08:31:04 <luigy> because some other haddock probably has prescendence
08:31:23 <Geraldus> which haddock -> /Users/arthurfayzrakhmanov/.local/bin/haddock
08:31:28 <luigy> so far so good then
08:31:41 <Geraldus> that what I tried to say already :D
08:31:47 <luigy> what stack version are you on?
08:32:33 <Geraldus> I just can't understand why stack picks other haddock, I tried to search for `haddock` across stack's sources but didn't find any hardcoded path
08:32:36 <Geraldus> 1.0.2
08:33:02 <luigy> it is not... is uses the same as what is in your env
08:33:23 <Geraldus> luigy: I end up with same thoughts (:
08:33:35 <Geraldus> let me try some shell magic
08:37:34 <Geraldus> luigy: if I understand correctly `stack haddock` automatically use heperlinked-source in case it is available, and running `stack haddock` gives me unlinked sources in old style :(
08:38:02 <Geraldus> also hscolour is installed and available in PATH
08:38:16 <luigy> yes, it automatically does and I don't think there is even a way to tell it not to xD
08:38:41 <luigy> yet ^
08:39:39 <luigy> Geraldus are you checking with a local package first?
08:40:06 <Geraldus> luigy: didn't catch 
08:40:55 <Geraldus> do you mean am I running `stack haddock` for local package?
08:42:25 <luigy> I mean you should -> stack new should-work; cd should-work; stack haddock
08:46:11 <Geraldus> luigy: I've run stack new test; cd test; stack haddock.  Everything work :D but I still have unlinked docs  
09:09:35 <csd_> how can i prove to myself that (join .) . (flip fmap) is equivalent to >>= ? mostly i'm confused by the leftmost (.) next to join
09:11:02 <scshunt> To start with, what definitions are you using for join and (>>=)?
09:11:02 <mniip> csd_, it's just a fancy way of writing \x y -> join (fmap y x)
09:11:04 <fizruk> csd_: eta-expand
09:11:04 <csd_> (flip fmap) returns (f b) but (join .) needs a function
09:11:25 <scshunt> :t join
09:11:26 <scshunt> :t (.)
09:11:26 <lambdabot> Monad m => m (m a) -> m a
09:11:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:11:54 <csd_> scshunt: i dont have a specific monad in mind
09:12:06 <int-e> @unpl (join_ .) . (flip fmap)
09:12:07 <lambdabot> (\ g j -> join_ (fmap j g))
09:12:14 <fizruk> csd_: (join .) . (flip fmap) = \x -> join . flip fmap x = \x f -> join (flip fmap x f) = \x f -> join (fmap f x)
09:12:16 <scshunt> csd_: sure, but if you're trying to prove that they're equivalent, you have to define them
09:12:33 <mniip> scshunt, no?
09:12:40 <scshunt> mniip: sure you do
09:12:47 <byorgey> scshunt: no, it should be possible to prove it using the monad laws
09:12:49 <scshunt> because it's not true for general functions named "join" and "(>>=)"
09:13:00 <mniip> join and >>= are very specific functions
09:13:14 <scshunt> @src join
09:13:15 <lambdabot> join x = x >>= id
09:13:27 <scshunt> is that the join we're talking about?
09:13:36 <scshunt> or are we definining (>>=) in terms of join...
09:13:37 <mniip> both come from the categorical definition of a monad
09:13:43 <gspr> Is there an extension (or a proposed extension) that allows importing *everything* from a module, not just the things the module exports? (I once again trapped myself in a mess of "internal" modules and re-exports, and find it would be so nice to just be able to import my own modules fully, and leave the export list for external users)
09:13:58 <geekosaur> for historical reasons join is defined in terms of (>>=) instead of the reverse
09:13:59 <byorgey> gspr: no
09:14:18 <scshunt> mniip: Ok, sure. But taking the definitions out of the category-theoretical ones is very different from the one I quoted from \bot
09:14:30 <scshunt> the method of proof would be different
09:14:45 <gspr> byorgey: :/   Are there any commonly accepted nice ways to counter the pattern I am describing?
09:14:56 <mniip> scshunt, I think that proof is exactly what they are looking for
09:15:01 <int-e> gspr: there's a convention of using Foo.Internal modules for that purpose (Foo.Internal exports everything, Foo imports Foo.Internal and exports public things.)
09:15:07 <mniip> csd_, is it?
09:15:13 <csd_> so (flip fmap) and >>= both return m a; and (join .) needs a function. that's where i get confused
09:15:36 <scshunt> csd_: what's the type of (join .)?
09:15:43 <gspr> int-e: Yeah, that's what I'm doing, but I'm kinda fed up with it, especially when I decide to refactor things. But maybe I should be annoyed at my tools instead ;)
09:16:00 <csd_> (a -> m (m a1)) -> a -> m a1
09:16:10 <mniip> cheater
09:16:12 <csd_> :) 
09:17:01 <cheater> mniip
09:17:17 <scshunt> csd_: what's the type of flip fmap?
09:17:37 * hackagebot natural-transformation 0.3.1 - A natural transformation package.  https://hackage.haskell.org/package/natural-transformation-0.3.1 (AndyGill)
09:17:43 <csd_> (f a) -> (a -> b) -> (f b)
09:17:50 <GLM> Does anyone know why stack might not be able to find the lens library?
09:18:22 <scshunt> csd_: Now what happens when you compose them?
09:18:40 <kadoban> GLM: What are you trying to do that's not working?
09:19:02 <GLM> kadoban:When I run stack build, it says "    Could not find module ‘Control.Lens’"
09:19:27 <csd_> scshunt: then f b gets passed to (join .) ... ?
09:19:48 <kadoban> GLM: There should be more to the message that kind of explains why, but: add lens to the build-deps in the .cabal file
09:19:53 <scshunt> csd_: not quite
09:20:08 <csd_> scshunt: that's where i'm getting stuck
09:20:15 <scshunt> csd_: remember that a function f : a -> b -> c is really a -> (b -> c)
09:20:28 <scshunt> when you compose it, you only compose the first argument
09:20:38 <scshunt> so you have (f a) -> ((a -> b) -> (f b)) and (c -> m (m d)) -> (c -> m d) (I rewrote the second type to simplify)
09:20:47 <kadoban> build-depends I should have said, that should be what it's called.
09:21:34 <csd_> ohh
09:22:16 <csd_> so where was i erring in thinking this through? 
09:22:30 <csd_> in fully evaluating fmap?
09:22:34 <GLM> kadoban: I did but got a cryptic error
09:22:49 <scshunt> fmap can't be evaluated here at all, at least not without two more arguments
09:23:04 <csd_> well yeah i'm assuming those exist
09:23:15 <gganley> hello, I'm thinking of starting a project to help me randomly pick the most powerful champion in league of legends using something like nerfplz.com. I have zero experience with anything web and even less with scraping (a term i've only learned in the past month). Just looking for some advice for a library to use and maybe a tutorial to look over.
09:23:55 <kadoban> GLM: What error, and what's in the stack.yaml and blah.cabal files? (and is it just an error in your code, or is it some sort of unexpected build error?)
09:24:12 <GLM> Looks like a build error
09:24:44 <scshunt> csd_: my *guess* is that you evaluated it on both arguments
09:25:10 <scshunt> (join .) . (flip fmap) $ x y is not the same as (join .) $ (flip fmap) x y
09:25:13 <GLM> kadoban: http://lpaste.net/151876
09:25:22 <scshunt> it's ((join .) $ (flip fmap) x) y
09:27:42 <kadoban> GLM: Not sure what that is. Is this an old version of stack? You could try a newer one possibly.
09:27:55 <csd_> scshunt: i definitely was doing the latter
09:27:57 <GLM> 1.0.2
09:28:04 <csd_> err
09:28:17 <csd_> i was doing (join .) . (flip fmap) x y
09:28:26 <scshunt> right :)
09:28:38 <scshunt> :t \x -> (join .) $ (flip fmap) x
09:28:39 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
09:28:39 <csd_> tricky
09:28:56 <scshunt> and then you apply this to y and recover bind
09:29:04 <scshunt> indeed
09:29:51 <kadoban> GLM: Not sure then, sorry. I guess if you're really stuck you could try wiping out your whole ~/.stack and try again, see if the same thing happens. It's possible there's some common cause of this I don't know though, doesn't look familiar.
09:31:06 <{AS}> How do you write f x y z = f y z x point-free?
09:31:30 <{AS}> sorry f x y z = f z x y
09:32:13 <kadoban> {AS}: You probably don't all that sanely.
09:32:27 <{AS}> OK :(. Thanks for the answer
09:32:33 <csd_> scshunt: thank you :)
09:32:42 <Gurkenglas> {AS}, try to change the type signature of your function or the one you're calling instead
09:32:55 <kadoban> {AS}: If it's a pattern you're doing a bunch of times, you could write it yourself, flip3 or something.
09:33:20 <{AS}> I was just doing a map where the argument I needed was the first to be passed
09:33:51 <{AS}> I guess it is not an issue to just write a lambda
09:34:38 <Gurkenglas> Paste your code? There may be a way. Although it does be weird that the rectangle traverse, for, map is incomplete
09:35:28 <{AS}> Gurkenglas: What do you mean by map being incomplete?
09:37:24 <Gurkenglas> http://sketchtoy.com/66584450
09:38:10 <{AS}> Ah, thanks :)
09:38:20 <Gurkenglas> ((You don't need to understand this:) Of course alaf Identity doesn't actually work on the flipped one, since the hook must be at the front)
09:38:48 <{AS}> I am assuming that <$> should be at the question mark
09:38:59 <Gurkenglas> Nope, that's just map
09:39:13 <Gurkenglas> flip map is at the question mark :P
09:39:18 <{AS}> Ah yes :)
09:39:24 <{AS}> Of course, the other one is just infix syntax
09:40:32 <{AS}> Thanks
09:41:45 <{AS}> I guess one could use some type class hackary to do a rotate
09:52:05 <miscyb> does anyone know how to get cabal working on fedora? I tried installing it from the repos but if I try to install packages it says that I don't have Cabal installed
09:52:28 <miscyb> so if i do "cabal install cabal-install"
09:52:50 <miscyb> it complains that i don't have Cabal >= 1.8, which I definitely do
09:53:17 <miscyb> and if i do "cabal info Cabal", it says that it's not installed, which it has to be if I'm running cabal right?
09:53:38 <kadoban> miscyb: Cabal is the library that cabal-install uses.
09:54:18 <kadoban> miscyb: By the way, the usual advice is to not use whatever stuff from your OS's package manager for haskell. You should install 'stack' and let it install everything else you need, like GHC and build-dependencies.
09:54:19 <miscyb> kadoban: yes I'm aware of that, "cabal --version" says that I'm using Cabal 1.18.1.0
09:54:30 <trubert9> I'm struggling to understand the construction of arrays. I'd like to create 2x2 array holding values 1 2 3 and 4.
09:54:36 <trubert9> Here's my attempt: Data.Array.array (2,2) [(1,1),(2,2),(3,3),(4,4)] :: Data.Array.Array Int Int
09:54:43 <trubert9> I get: array *** Exception: Ix{Int}.index: Index (1) out of range ((2,2))
09:55:12 <miscyb> kadoban: I have to have some haskell stuff installed from my os because I use xmonad
09:55:31 <miscyb> unless you think it's a good idea to uninstall that completely and run xmonad out of hackage
09:55:57 <kadoban> miscyb: I don't know about xmonad. If it's installed and working, I'd' probably just try to ignore as much of it as possible and just use 'stack' for actual haskell stuff.
09:56:20 <miscyb> kadoban: but doesn't stack also use the Cabal library, won't I run into the same issues
09:56:22 <GLM> kadoban:Thanks. Wiping my stack did the trick
09:56:26 <andromeda-galaxy> miscyb: my xmonad/Haskell setup is:
09:56:46 <kadoban> trubert9: A 2x2 array should more be something like:  array ((1,1), (2,2)) [((1,1), 1), …]
09:56:49 <andromeda-galaxy> (miscyb: stack might work in your case since it installs all of its own tooling)
09:57:13 <andromeda-galaxy> miscyb: I set this up before stack, so it should work if you want to be able to use bare cabal as well:
09:57:31 <andromeda-galaxy> I installed ghc and cabal (1.22) from the Gentoo package repositories
09:58:03 <kadoban> miscyb: 'stack' is just an executable, install it via one of the recommended ways and it won't care at all what you have installed.
09:58:17 <trubert9> kadoban: great that worked, thanks.
09:58:18 <andromeda-galaxy> Then, I made a project '~/xmonadrc' with a cabal file requiring xmonad, set up so that 'cabal build' builds a copy of xmonad + my customizations in dist/
09:58:28 <andromeda-galaxy> (that project had a sandbox)
09:58:34 <andromeda-galaxy> then everything else can be installed at the user level
09:59:06 <andromeda-galaxy> miscyb: stack is probably the best way to deal with it, though, if you don't need to use plain cabal-install for anything else
09:59:56 <schorsch80> Hi again
10:00:04 <miscyb> andromeda-galaxy: ok I'll give stack a shot i've been meaning to look into it anyway
10:00:19 <schorsch80> I have got a custom statemonade:
10:00:21 <schorsch80> newtype Trans state a = T { runT :: state -> (a,state)}  instance Functor (Trans state) where   fmap g (T h) = T $ (\(a,st) -> (g a,st)) . h  instance Applicative (Trans state) where   pure = return   m <*> g = m >>= flip fmap g  instance Monad (Trans state) where   return a = T $ \st -> (a,st)   T g >>= f = T $ (\(a,st) -> runT (f a) st) . g  modify :: (state -> state) -> Trans state () modify f = T $ \st -> ((),f st)  get :: T
10:00:24 <andromeda-galaxy> miscyb: sounds good, I hope those explanatin shelp
10:00:30 <dcoutts> miscyb: if Cabal the lib is not installed (check ghc-pkg list Cabal) then your OS ghc install is borked
10:01:07 <andromeda-galaxy> miscyb: your distro might package ghc and cabal separately,
10:01:25 <dcoutts> andromeda-galaxy: but it's a dep of ghc, so can it cannot
10:01:31 <dcoutts> erm, it cannot
10:01:42 <dcoutts> miscyb: note that if you cabal install cabal-install then it'll likely be masked by the /usr/bin/cabal on your system, so you'd need to adjust your $PATH to put your ~/bin or ~/.cabal/bin first
10:01:43 <andromeda-galaxy> that's true, I don't remember how it works exactly,
10:01:51 <andromeda-galaxy> but gentoo's got separate ghc and cabal-the-library packages, somehow
10:02:11 <dcoutts> andromeda-galaxy: that's for installing an extra version that's not the one shipped with ghc
10:02:15 <dcoutts> iirc
10:02:40 <miscyb> fedora keeps them separate for whatever reason
10:02:48 <Gurkenglas> schorsch80, what's the problem? (That got cut off after "get ::". Try lpaste.net)
10:03:07 <miscyb> it also keeps Cabal in ghc-Cabal and ghc-Cabal-devel so it's even more split up
10:03:12 <dcoutts> miscyb: oh, then you need the -dev version then, if it's splits the .so from the .a
10:03:19 <andromeda-galaxy> dcoutts: hmm, maybe.  I ran into trouble importing anything from cabal without the package, though
10:03:29 <schorsch80> nice
10:03:34 <schorsch80> see http://lpaste.net/151879
10:03:41 <miscyb> dcoutts: i actually have them both installed and it still says that Cabal is not installed
10:03:51 <miscyb> *through cabal-install
10:03:51 <schorsch80> this is given monade 
10:03:53 <dcoutts> miscyb: what does ghc-pkg list Cabal say?
10:04:14 <miscyb> /usr/lib64/ghc-7.8.4/package.conf.d
10:04:18 <miscyb> is all that it spits out
10:04:20 <dcoutts> wow
10:04:32 <miscyb> yeah that doesn't seem correct
10:04:34 <Gurkenglas> "this is the given monad"
10:04:36 <dcoutts> miscyb: are you sure the fedora Cabal lib package is installed?
10:04:44 <schorsch80> I now try to implement a method bigStepTransMax :: Statement -> Trans (String -> Int,Int) Statement
10:04:45 <dcoutts> miscyb: not the cabal exe package
10:05:02 <miscyb> Package ghc-Cabal-1.18.1.5-46.fc23.x86_64 is already installed, skipping
10:05:17 <dcoutts> miscyb: and -dev version of that
10:05:18 <miscyb> oh wait i didn't actually install the devel package
10:05:22 <miscyb> i thought that i did
10:05:25 <schorsch80> which breaks the monade if the Second Int is 0
10:05:47 <Gurkenglas> schorsch80, did you mean (Int, Int) instead of Int,Int? Trans takes two type arguments, not one
10:05:49 <{AS}> > :t alaf Identity
10:05:50 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:05:57 <schorsch80> no
10:06:10 <miscyb> oh man it's actually working
10:06:15 <dcoutts> miscyb: :-)
10:06:15 <schorsch80> it is Pair String->Int, Int
10:06:33 <dcoutts> miscyb: note that if you do upgrade cabal-install, remember the thing about the $PATH
10:06:39 <Gurkenglas> So that should say "Trans (String -> Int) Int"?
10:06:39 <miscyb> dcoutts: thanks it looks like it's compiling things now
10:06:50 <miscyb> dcoutts: yeah I have ~/.cabal/bin in my path alreadhy
10:06:54 <Gurkenglas> :t alaf Identity -- {AS}, without the >
10:06:55 <lambdabot> Profunctor p => (p r (Identity b) -> e -> Identity b1) -> p r b -> e -> b1
10:06:56 <miscyb> so it'll override once it installs
10:07:03 <Gurkenglas> :t alaf Identity traverse
10:07:04 <{AS}> Thanks
10:07:05 <lambdabot> Traversable t => (a -> b) -> t a -> t b
10:07:15 <dcoutts> miscyb: ok, and it'll have to be before /usr/bin or you'll still get the system one
10:07:26 <miscyb> dcoutts: yeah it is
10:07:29 <dcoutts> ok
10:07:39 <miscyb> oh wait it failed to install
10:07:40 * hackagebot streaming-commons 0.1.15.1 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.15.1 (MichaelSnoyman)
10:07:56 <miscyb> and now it's hanging at "Failed to install Cabal-1.22.7.0
10:07:58 <miscyb> Last 10 lines of the build log ( /home/mattro/.cabal/logs/Cabal-1.22.7.0.log ):Failed to install Cabal-1.22.7.0
10:08:00 <miscyb> Last 10 lines of the build log ( /home/mattro/.cabal/logs/Cabal-1.22.7.0.log ):
10:08:43 <schorsch80> @gutkenglas see http://lpaste.net/151879
10:08:43 <lambdabot> Unknown command, try @list
10:08:50 <Gurkenglas> Oh I didn't notice the "Statement" of the end of schorsch80's line is part of the type <.<
10:08:53 <schorsch80>  gutkenglas see http://lpaste.net/151879
10:09:00 <dcoutts> miscyb: you likely have half a dozen other core libs that are not installed, ie fedore -devel packages., see ghc-pkg list and see the log output
10:09:10 <schorsch80> look at the bottom 
10:09:20 <miscyb> dcoutts: yeah I'm going to look through what it has
10:09:25 <schorsch80> I want to break aut of the monad 
10:09:40 <{AS}> Gurkenglas: Why the profunctor here?
10:10:15 <schorsch80> what do you mean by profunktor?
10:10:50 <Gurkenglas> {AS}, because the second argument to ala/alaf is supposed to accept more than just Traversals ( la the lens package) like traverse
10:11:03 <{AS}> schorsch80: It was a question about something I asked before (profunctor = https://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor.html )
10:11:09 <{AS}> Ah thanks
10:12:46 <schorsch80> gurkenglas I have no clue this was given by the lector
10:13:06 <schorsch80> I am just to implement bigStepTransMax :: Statement -> Trans (String -> Int,Int) Statement
10:13:49 <schorsch80> I am already done with the main work if int > 0 but do not know how to "abort" the monad if second int =0
10:17:40 * hackagebot hoppy-generator 0.1.0 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.1.0 (khumba)
10:19:32 <bennofs> Does anyone know of a graph library in haskell which is simple and uses efficient datastructures (I'm trying to find an alternative to my own implementation, which would just represent the graph as a Vector Node where each Node has a Vector Edge as well as some additional information) 
10:20:29 <Taneb> bennofs, there's fgl
10:20:32 <bennofs> I've only found things which either use IntMap (why not vector????), or lists, both which I predict will not be quite as efficient as I'd like. Additionally, using ST for the "build up" part would be nice as well
10:21:54 <Gurkenglas> schorsch80, are you told anything about what properties bigStepTransMax must have? (How is it used?)
10:22:12 <bennofs> Taneb: do you know anything about the performance of fgl?
10:22:24 <schorsch80> did u see the las updates of http://lpaste.net/151879
10:22:26 <Taneb> bennofs, I do not
10:22:33 <schorsch80> i have included the relevant data types
10:22:40 * hackagebot hoppy-std 0.1.0 - C++ FFI generator - Standard library bindings  https://hackage.haskell.org/package/hoppy-std-0.1.0 (khumba)
10:22:42 * hackagebot hoppy-runtime 0.1.0 - C++ FFI generator - Runtime support  https://hackage.haskell.org/package/hoppy-runtime-0.1.0 (khumba)
10:23:12 <schorsch80> bigsteptransmax should behave like bigStepTrans stmt = T $ \env -> ((),bigStep env stmt)
10:23:14 <Gurkenglas> schorsch80, I want to know how bigStepTransMax is used
10:23:47 <schorsch80> but should stop if counter int is 0
10:24:14 <Gurkenglas> That sounds like "Statement -> Trans (String -> Int,Int) ()", not "Statement -> Trans (String -> Int,Int) Statement"
10:24:41 <schorsch80> jeha but it should also return the last statement
10:25:43 <Gurkenglas> Man, this is all way too mess. May I have a link to the original task description?
10:25:47 <Gurkenglas> *messy
10:25:58 <schorsch80> shure but its german
10:26:05 <Gurkenglas> <-------- read my nick :P
10:26:19 <{AS}> Cucumber jar?
10:26:36 <Gurkenglas> More like Picklejar, cucumbers are larger I think
10:26:56 <alpha123> edwardk: are there examples for your zippers package (the lens/traversal based one)? how does that thing work?
10:27:40 * hackagebot lens 4.13.2 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.13.2 (EricMertens)
10:27:49 <Gurkenglas> dun dun dun
10:27:52 <schorsch80>  http://www.file-upload.net/download-11290160/Aufgabenblatt31.tar.gz.html
10:27:53 <schorsch80> :)
10:28:22 <Gurkenglas> No changelog?
10:28:31 <Gurkenglas> (For the lens thing hackagebot just said)
10:29:25 <schorsch80> it is part 3.4
10:29:26 <adamCS> From github: Restore default signature for Control.Lens.At.at
10:29:28 <adamCS> Improve operations for Data.Sequence.Seq
10:29:28 <adamCS> Fix declarePrisms behavior on GHC 8 using GADT record syntax
10:29:41 <adamCS> (for lens)
10:30:55 <glguy> Gurkenglas: You'll have to click the link to see the changelog. hackagebot doesn't write them to channel
10:31:02 <pikajude> hi, how do I get the same highlighted haddock source that is on hackage? (with links between identifiers)
10:31:36 <Gurkenglas> Yea I was looking at https://hackage.haskell.org/package/lens-4.13.2/changelog but apparently that's updated by now
10:31:39 <khumba> pikajude: cabal haddock --hyperlink-source (or cabal install --haddock-hyperlink-source)
10:31:40 <glguy> pikajude: YOu need a new-enough version of haddock to do it, then the right flags https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
10:31:50 <glguy> you can see the difference in my script for generating haddocks
10:32:01 <pikajude> oh, hyperlinked-source, ok
10:32:03 <pikajude> cool
10:33:23 <Yuken> Hallo. Unless I'm thinking of another language, isn't there a Haskell compiler... made with Haskell?
10:33:24 <pantsman-> any tips on getting HaRe to work (with a project I'm building with stack)?
10:33:45 <edwardk> alpha123: there are some in the project itself
10:34:07 <glguy> Yuken: GHC is written in Haskell and is the primary Haskell compiler
10:34:16 <edwardk> alpha123: see the examples/Brainfuck.hs etc.
10:34:22 <edwardk> alpha123:  also the shorter one-liners
10:34:36 <Yuken> glguy, thanks.
10:35:50 <pantsman-> invoking HaRe from emacs gives me "cannot satisfy -package id ....", so I guessed it doesn't know about the stuff I installed via stack. So I invoked it via stack exec, and it craps out with a load of spurious "Module Foo does not export bar" errors
10:35:52 <pikajude> glguy: how new does it have to be? I'm using git master
10:36:02 <Gurkenglas> schorsch80, try first to implement bigStepTrans in terms of smallStepTrans
10:36:13 <glguy> pikajude: git master is pretty new
10:36:21 <pikajude> yeah
10:36:28 <pikajude> it doesn't recognize the hyperlinked-source flag though
10:36:29 <schorsch80> bigStepTrans :: Statement -> Trans (String -> Int) () bigStepTrans stmt = T $ \env -> ((),bigStep env stmt)
10:36:40 <Gurkenglas> I said in terms of smallStepTrans
10:36:43 <glguy> pikajude: then you probably didn't rebuild the executable against the git master library
10:36:48 <schorsch80> it is already implemented in While.hs
10:36:54 <glguy> and you're just using a new executable against the old library
10:37:01 <pikajude> doh.
10:37:06 <glguy> or somethin glike that
10:37:09 <Gurkenglas> Yes, and I am asking you to implement it differently, because I expect it will help you solve that other problem
10:37:12 <glguy> the project is in 3 pieces
10:37:41 * hackagebot reactive-banana-sdl2 0.1.1.0 - Reactive Banana integration with SDL2  https://hackage.haskell.org/package/reactive-banana-sdl2-0.1.1.0 (cies)
10:38:02 <Gurkenglas> And tell your lecturer they should have recommended you to first try to implement bigStepTrans in terms of smallStepTrans in the task description
10:39:03 <schorsch80> my SmallStepTrans implementation is : smallStepTrans stmt = T $ \env -> (fst (smallStep env stmt),snd (smallStep env stmt))
10:39:51 <adamCS> Suppose I had a sum type and I knew that all of the fields of all of its constructors were instances of Default.  Could I construct a list of default values, one per constructor?
10:39:56 <Gurkenglas> By the way, you should use "T $ \env -> smallStep env stmt" because otherwise you'll compute smallStep twice
10:41:00 <Gurkenglas> Pretend bigStep and smallStep didn't exist, only smallStepTrans, and now implement bigStepTrans
10:41:19 <ski> a middle form would be `T $ \env -> let (x,y) = smallStep env stmt in (x,y)', which perhaps helps you to realize they are equivalent
10:42:11 <Gurkenglas> I was going to write that until I realized I was being silly and wrote what I did instead :P
10:42:13 <alanz> pantsman-, getting HaRe to work with stack is next on my list
10:42:55 <pantsman-> alanz, good to know, thanks!
10:43:29 <alanz> HaRe, hie, and stack for emacs
10:46:53 <pantsman-> stack is awesome but when something like stack comes along it throws a massive spanner in the works of all the dev tooling I took months to get working
10:47:12 <pantsman-> so I have to weigh up its benefits vs having a working editor :-/
10:48:08 <alanz> pantsman-, not long now
10:50:56 <Ankhers> alanz: Doesn't stack already work with emacs?
10:51:18 <alanz> Ankhers, I am talking about getting HaRe to play nice too
10:51:31 <alanz> at the moment it does not resolve libraries properly
10:51:43 <Ankhers> gotcha. Sorry about the confusion.
10:51:47 <alanz> np
10:52:24 <schorsch80> Gurkenglas i don't have a clue :(
10:53:03 <csd_> does anyone know whether The Fun of Programming was released for free electronically ever? i see that it's out of print
10:53:12 <Wizek> @pl mkX a = Edge <$> getEidX a <*> getSourceX a <*> getTargetX a <*> pure a
10:53:13 <lambdabot> mkX = (Edge <$>) . ap ((<*>) . ap ((<*>) . liftM2 (<*>) getEidX getSourceX) getTargetX) pure
10:53:16 <Gurkenglas> schorsch80, has your course covered do notation yet?
10:53:35 <Wizek> Can this be written nicer?
10:53:50 <schorsch80> no but I read about in slides of a previouse cours
10:55:59 <kadoban> Wizek: The original seems fine to me really.
10:56:57 <Gurkenglas> Wizek, mkX = runReaderT $ Edge <$> ReaderT getEidX <*> ReaderT getSourceX <*> ReaderT getTargetX <*> ReaderT pure
10:59:06 <Wizek> Gurkenglas, Interesting, thanks!
10:59:38 <Wizek> kadoban, yeah, not too bad, was just wandering if there is an even more consice form I'm not thinking about
11:01:01 <Wizek> at least it is quite a bit more consice than https://gist.github.com/Wizek/e2ebc318c03b5b0717ff already
11:02:21 <Phlogistique> I want to use optparse-applicative to parse a value from a list of value
11:02:24 <glguy> Wizek: the version using do-notation that you pasted is probably the way to go
11:02:31 <Phlogistique> what is the most idiomatic way to do that?
11:02:52 <Phlogistique> (i.e. I want an option which value can be foo, bar, baz, or qux)
11:03:58 <{AS}> Doing the generalized flip/rotate function is hard for n-ary functions, even with dependent types :|
11:07:34 <Wizek> glguy, do you even prefer the do notation to `mkX a = Edge <$> getEidX a <*> getSourceX a <*> getTargetX a <*> pure a`? And if so, why?
11:08:48 <glguy> Yeah, I prefer using record notation for constructing records, generally. I don't consider getting the whole thing to fit on one long line an automatic improvement
11:09:03 <Gurkenglas> Can we get lambdabot to have Data.Coercible?
11:11:02 <Wizek> glguy, Well, yes, record notation for records I'd prefer as well. But there is no way to use Control.Applicative with record notation, is there?
11:11:13 * meoblast001 pokes raichoo 
11:11:39 <raichoo> ho, meoblast001
11:11:42 <meoblast001> :D
11:11:46 <meoblast001> long time no see
11:11:56 <meoblast001> you are not in #haskell-blah
11:11:57 <glguy> Wizek: The closest would be using record notation to make a lambda  (\x y -> R { a=x, b=y}) <$> this <*> that, 
11:12:11 <glguy> Wizek: But if you already have a Monad instance, sticking to Applicative operators isn't a win
11:12:22 <raichoo> meoblast001: Nope, I'm not chatting on IRC that often.
11:13:15 <kadoban> glguy: I'm not really sure what benefit using the record syntax has to justify the extra verbosity.
11:14:12 <glguy> kadoban: It means when you rearrange fields in your record definition your code doesn't break, and your reader doesn't have to memorize the order of the record fields when reading code using them
11:14:41 <meoblast001> raichoo: ooh :o
11:25:18 <schorsch80> Gurkenglas I have no clue on what to do with the do notation
11:25:49 <schorsch80> how do i get the second int within a do guard?
11:36:12 <mjhoy> hello! i'm working on a project that has a hideous function that mostly works: https://github.com/mjhoy/chorebot_hs/blob/master/src/Chorebot/Distributor.hs#L101 It maintains a lot of state. Should my first step to clean this up be to investigate the state monad?
11:37:11 <Rembane> mjhoy: Or pick it apart into smaller pieces. 
11:39:29 <bergmark> mjhoy: the downside with StateT is that it's so easy to just clump everything together, which can make it even harder to reason about the state
11:41:37 <mjhoy> bergmark: is there an alternative? i'm definitely running into problems having e.g. chores2, chores3, chores4... and mixing them up
11:41:55 <mjhoy> my impression is stateT would solve that?
11:42:16 <bergmark> yes it'd help with that, so it may be a good fit for you
11:45:44 <mjhoy> ok, stupid question... is StateT what I should look at, or is that a monad transformer and not necessary?
11:46:30 <bollu> hey everyone
11:47:46 <sm> mjhoy: +1 for breaking this up into smaller functions, and for at least experimenting with passing the args needed to each one
11:48:01 <sm> if it's too verbose, you can group them into another type
11:48:09 <sm> you're likely to get more insights this way
11:48:15 <hexagoxel> mjhoy: there is Rand Monad; you can use that instead of a State gen.
11:48:25 <hexagoxel> http://hackage.haskell.org/package/MonadRandom-0.4.2.2/docs/Control-Monad-Random.html
11:50:54 <mjhoy> hexagoxel: does that help ensure i'm not reusing a previously used generator?
11:51:21 <hexagoxel> (in case you use State and Rand, one of them will need to be a transformer, i.e. either m==`StateT Assignments Rand` or `RandT (State Assignments)`.)
11:51:43 <hexagoxel> yes.
11:51:48 <mjhoy> sm: i guess i'm not sure how to break it up more... yes a lot of things are in the `where` clause and could be reordered, is that what you mean?
11:53:14 <mjhoy> hexagoxel: thanks. will look into that.
11:55:20 <the_2nd> is there a method to merge two lists? [1, 2, 3] [4, 5, 6] => [1, 2, 3, 4, 5, 6]
11:55:37 <Rembane> the_2nd: ++ should do taht for you
11:55:48 <Rembane> > [1,2,3] ++ [4,5,6]
11:55:50 <lambdabot>  [1,2,3,4,5,6]
11:55:56 <bollu> 	stupid question - how do I write literate haskell?
11:56:01 <sm> mjhoy: the functions are not top-level because they rely on state from the parent, I assume ? Faced with a function of that size I will usually break the sub functions out to the top level
11:56:06 <bollu> the_2nd: are you familiar with monoids?
11:56:15 <hexagoxel> :t (++) -- commonly "concat(enation)"
11:56:17 <lambdabot> [a] -> [a] -> [a]
11:56:24 <bollu> :t (<>)
11:56:26 <lambdabot> Monoid m => m -> m -> m
11:56:27 <the_2nd> lol sure :D
11:56:46 <bollu> so yeah, (<>) is the operator used to smash together any two monoids together :)
11:56:53 <mjhoy> sm: that's true, yes
11:57:03 <bollu> and since List is an (almost) free monoid, you can use (<>) to concatenate
11:57:10 <bollu> > [1, 2, 3] <> [4, 5, 6]
11:57:12 <lambdabot>  [1,2,3,4,5,6]
11:57:58 <bollu> as in, if I have a .lhs file, how do I build it?
11:57:58 <sm> mjhoy: for one thing it makes them easier to test in ghci, and for another it may highlight a group of args that you're always passing that belong together, maybe grouped as an ADT or newtype
11:58:11 <hexagoxel> i disagree that lifting functions to the top level (thereby polluting the global/module namespace) is a good style.
11:58:15 <bollu> and which style do I use? bird style or the other style?
11:58:52 <sm> (which might then become the state in your State/Reader monad. But adding a monad should be the last resort I think)
12:00:29 <hexagoxel> if all parameters that are "state" are properly wrapped in Monads, local functions won't be able to access the state accidentally, either.
12:01:06 <hexagoxel> unless they are monadic and called appropriately, in which case their effect is explicit as well.
12:02:24 <mjhoy> sm: i just made a change where instead of tracking just [Chore] through these functions, i wanted [(Chore, Int)] and it seemed a bit painful in this set up. i guess state monad wouldn't necessarily help
12:03:59 <mjhoy> ok i have to run to lunch, thanks all! i will try a few things suggested.
12:05:27 <Gurkenglas> Can you define a number of top-level names with access to the same where block?
12:07:55 * hackagebot regex-applicative-text 0.1.0.1 - regex-applicative on text  https://hackage.haskell.org/package/regex-applicative-text-0.1.0.1 (phadej)
12:15:33 <puregreen> Gurkenglas: nope
12:15:40 <puregreen> no
12:15:42 <puregreen> yep
12:15:51 <puregreen> as a tuple
12:16:03 <puregreen> (x, y, z) = ... where ...
12:20:22 <Gurkenglas> https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#some why aren't these two defined directly in terms of each other? Shouldn't the compiler be able to do whatever optimization was done here?
12:22:55 * hackagebot uu-cco 0.1.0.5 - Utilities for compiler construction: core functionality  https://hackage.haskell.org/package/uu-cco-0.1.0.5 (AtzeDijkstra)
13:04:34 <cads> hey, ihaskell+jupyter is pretty cool
13:05:27 <cads> it was strange to build it here in ubuntu - had to manually install pango and cairo dev libs
13:06:16 <cads> also blas, lapack, and libmagic
13:07:29 <cads> the stack build crashes in human readable way and installing those packages was not hard, but I am wondering if it could be automatic
13:07:57 * hackagebot data-default-extra 0.0.1 - A class for types with a default value.  https://hackage.haskell.org/package/data-default-extra-0.0.1 (PeterTrsko)
13:10:03 <kadoban> cads: Not really in general. stack would have to know a *lot* about every package manager out there, and it'd have to know stuff that's not specified in the .cabal file as well I think.
13:11:31 <cads> It would be neat if it could precompile a list of external libraries
13:12:28 <cads> then you could get an idea of the kind of environment you need to build in
13:12:32 <kadoban> cads: Not entirely sure what you mean.
13:13:06 * hackagebot mwc-probability 1.0.3 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.0.3 (JaredTobin)
13:13:33 <kadoban> cads: Oh like it could output: "you need library x and y and z and blah blah blah" ?
13:13:59 <cads> yeah, though I think that might not be practical
13:14:16 <cads> hmm
13:14:34 <cads> maybe stack /could/ be integrated with a package manager
13:14:45 <cads> say something like nix if not debian
13:15:28 <kadoban> cads: I don't think stack knows enough to say what C library you need. Not sure though. And without that … kind of hard to even envision it doing a lot more than it does.
13:17:38 <cads> one other question can't answer - I've built and installed ihaskell with stack, but since ihaskell depends on ghc, I have to use 'stack exec' to run jupyter with ihaskell
13:18:07 * hackagebot binary 0.8.2.1 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.2.1 (LennartKolmodin)
13:18:49 <cads> is there any way to make the appropriate version of ghc available to ihaskell without having to say 'stack exec jupyter-notebook'?
13:20:00 <kadoban> cads: If all you need is a particular GHC on your path, I mean you can just add whatever directory inside ~/.stack/ where GHC lives to your PATH and it'll work fine. But I don't think there's a way to do it based on context, withouth like, writing a script to do it or something.
13:20:05 <cads> what I've done in the past was to manually put ~/.stack/programs/x86_64-linux/ghc-7.10.3/bin on my path
13:21:11 <kadoban> Right, that's what I do if I need a ghc binary sitting around.
13:22:21 <cads> kadoban, I was thinking of writing a 'ihaskell' wrapper script to automatically put the right version of ghc into the path. I'd call ihaskell like normal, but the little utility script would execute first
13:22:56 <cads> seems troublematic in general ;)
13:23:07 * hackagebot aeson 0.11.0.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.0.0 (AdamBergmark)
13:23:55 <cads> kadoban, I don't like the idea of manually wrangling the path variable in every environment I want to build something in, but I guess that's one way
13:25:42 <kadoban> Yeah I'm not sure there's a good answer to that.
13:27:15 <OverCoder> t0by, hey yo
13:27:28 <t0by> hey OverCoder 
13:33:07 * hackagebot operational-extra 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/operational-extra-0.1.0.0 (andrewthad)
13:38:07 * hackagebot cassava-streams 0.2.0.0 - io-streams interface for the cassava CSV library.  https://hackage.haskell.org/package/cassava-streams-0.2.0.0 (PeterJones)
13:50:56 <navyer> Hi
13:52:53 <zmanian_> Reccomendations for abstracting over a TCP server that handles protobuf messages? Pipes-network? bitemyapp 
13:56:56 <adas> I have a long list of import statements in my file. Is it possible to replace all those "import" keywords with just a single "import" keyword?
13:57:33 <glguy> You need one import per module imported
13:57:51 <puregreen> adas: you can make a module called “Imports”, put your imports there, export them, and then you'd be able to do “import Imports”
13:57:52 <glguy> the only way to replace them would be to make a new module that reexported a bunch of modules
13:58:23 <adas> cool thanks. that works
13:58:54 <adas> ill try that out
14:11:06 <csd_> were any of you at the Compose conference this past weekend?
14:13:08 * hackagebot remote-monad 0.2 - An parametrizable Remote Monad, and parametrizable Applicative Functor  https://hackage.haskell.org/package/remote-monad-0.2 (AndyGill)
14:13:25 <ThatTreeOverTher> https://hackage.haskell.org/package/cheapskate-0.1.0.4 makes reference to a "walk" function, but hoogling for it turns up no results. Can someone explain what's going on?
14:13:55 <ThatTreeOverTher> Nevermind. The package provides it
14:14:42 <kadoban> ThatTreeOverTher: https://www.stackage.org/lts-5.2/hoogle?q=walk  hackage's hoogle is kind of terrible, it only searches some weird subset of packages that I'm not really sure how it picks. Otherwise you have to specify exactly what package it's from, making it kind of useless.
14:15:27 <ThatTreeOverTher> Okay, that's useful. Thanks kadoban 
14:15:53 <sm> http://hoogle.haskell.org is pretty good
14:17:07 <kadoban> sm: Except the type search thing :(
14:18:36 <Welkin> if you want to search all of hackage use hayoo
14:18:59 <Welkin> hoogle is only for base + a few other packages that come with the platform afaik
14:20:44 <lpaste> echo-area pasted “mapS” at http://lpaste.net/151914
14:21:10 <echo-area> Hi, is it possible to annotate the h' function?
14:21:35 <glguy> echo-area: You can use the ScopedTypeVariables extension
14:21:49 <jle`>   where
14:21:53 <jle`>     h :: Blah
14:21:54 <glguy> or you can pass f as a parameter to h'
14:21:55 <jle`>     h = ...
14:23:00 <echo-area> jle`: A simple annotation doesn't work, due to the type level argument `s' must be the same for h and h'
14:23:20 <jle`> mhm. i was addressing the syntax
14:23:39 <jle`> but yeah, you need scoped type variables to refer to the 'a' or 'b' in the signature of mapS
14:24:04 <jle`> mapS :: forall a b. (a -> b) -> Stream a -> Stream b
14:24:25 <jle`>  and now if you use 'a' or 'b' in your type signature for h', it'll refer to those
14:30:20 <lpaste> echo-area annotated “mapS” with “mapS (annotation)” at http://lpaste.net/151914#a151915
14:30:33 <echo-area> Oh, I still have problems with it
14:30:52 <echo-area> I want to refer the missing s there
14:50:34 <glguy> echo-area: You didn't change the code like jle` and I said to yet, so it won't work
14:52:02 <echo-area> glguy: But it's not a or b that caused the problem, it's s, which does not appear in the type signature of mapS
14:54:40 <glguy> well, it's both the s, and the b
14:55:18 <Wizek> can I run `stack eval`in a way to load the Main module so I can have access to the local bindings?
14:55:54 <lpaste> glguy annotated “mapS” with “mapS (annotation) (annotation)” at http://lpaste.net/151914#a151916
14:57:34 <dakrone> can someone describe how I would implement this typeclass (Frobdicate) for a class with a constructor that has multiple things in it: https://gist.github.com/dakrone/2d0fbbfd4307a13b82f9 (this has errors, but hopefully describes what I'd like to do)
14:57:38 <Gurkenglas> Surely one can just derive Functor for Stream
14:58:19 <glguy> Gurkenglas: That'll only work for simple types. This isn't one of those
14:59:52 <glguy> echo-area: That paste was for you ^
15:04:15 <echo-area> glguy: I see, I see, thanks.  I did not know that a type signature could be used on a single argument
15:05:35 <glguy> echo-area: There are a number of places that can introduce a lexically scoped type variable https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#scoped-type-variables
15:05:40 <glguy> Might be worth reading through
15:08:46 <mgsloan> Wizek: Hmm, maybe you want "stack ghci"?
15:23:24 <lokien_> hey guys. can you recommend me any good articles/books about type theory/functors, applicatives and monads?
15:23:54 <tnks> lokien_: from a practicing programmer's perspective?
15:24:00 <Wizek> mgsloan, I was able to `echo $stuff | stack ghci` and it worked, thanks!
15:24:11 <tnks> or are you really interested in digging into theory beyond the practice?
15:24:20 <lokien_> tnks: yeah, I'm not a mathematician 
15:24:32 <tnks> lokien_: still, different people have different motivations.
15:24:42 <lokien_> tnks: but I don't mind digging into it, I like things like that 
15:25:04 <tnks> haskellbook.com (the book) is the best I've seen for getting cleanly through functors, applicatives, and monads.
15:25:05 <Axman6> the NICTA course isn't a bad introduction to the practical use of Functor, Applicative and Monad
15:25:12 <Ankhers> What does ': mean?
15:25:30 <Axman6> Ankhers: a type level list cons
15:25:49 <tnks> lokien_: learning what functors are in a CT sense is fun, but may not really help you Haskell better.
15:25:56 <Ankhers> Axman6: Thanks.
15:25:59 <lokien_> hrmm, something more language agnostic? 
15:26:14 <Axman6> Ankhers: it's : lifted to the type level
15:26:24 <lokien_> tnks: I know. I'd like type theory better 
15:26:30 <tnks> lokien_: the better implementations of these things are with type classes.
15:26:40 <tnks> and Haskell implements type classes pretty well.
15:26:52 <tnks> lokien_: I really don't think functors are so much about type classes.
15:27:02 <tnks> or type theory, rather.
15:27:05 <danilo2> Hello guys! Is there somewhere defined equivalent of (mapM . mapM) ? I was looking for MapM2 but without a luck. Of course existence of such function can be arguable, but still, I would love to know if it exists somewhere
15:27:30 <lokien_> tnks: that's why I put a slash in there, not an "and" :D
15:27:34 <tnks> the type theory part is really more about dictionaries, statically or dynamically dispatched.
15:28:40 <tnks> lokien_: if you want to learn about type theory, then a great place to start is with Pierce's Types and Programming Languages (TaPL)
15:28:44 <hatds> wouldn't it have to be fmap mapM . mapM ?
15:28:51 <lokien_> 1300 pages, sweet jesus on a stick
15:29:25 <tnks> lokien_: the authors are trying to go slow to deal with common misunderstandings.
15:29:35 <tnks> it probably reads faster than it looks.
15:29:50 <lokien_> tnks: thanks, I'll look at it. 
15:30:15 <tnks> lokien_: TaPL won't go much into functors, applicatives, or monads at all.
15:30:27 <tnks> but it will give a good foundation for what type theory is.
15:30:43 <tnks> and you can pivot from there.
15:31:15 <lokien_> tnks: I can't into types, nor into functors. so I have to learn the theory somewhere 
15:31:42 <lokien_> I kind-of-can apply it, but I don't understand it 
15:31:55 <tnks> lokien_: most people learn functors as a useful instance of a type class.
15:32:16 <tnks> so it /much/ less about learning about CT and why it's called a "Functor"
15:32:34 <tnks> and more about thinking about the type signature of fmap and how broadly applicable it is.
15:33:20 <lokien_> tnks: there are some deep people on #haskell 
15:34:02 <tnks> lokien_: deep as in they think alot?
15:34:19 <ski> danilo2 : perhaps `Compose' ?
15:34:33 <danilo2> hatds: no, because mapM2 :: (Monad m, Traversables '[t1, t2]) => (a -> m b) -> t1 (t2 a) -> m (t1 (t2 b))
15:34:41 <danilo2> ski: I'm checking it, brb
15:34:51 <ski> @let data Compose f g a = MkC {unC :: f (g a)}
15:34:52 <lambdabot>  Defined.
15:35:00 <mmachenry> tnks: No deep as in they live near the dead sea ;)
15:35:15 <ski> @let instance (Functor f,Functor g) => Functor (Compose f g) where fmap f (MkC fga) = MkC (fmap (fmap f) fga)
15:35:16 <lambdabot>  Defined.
15:35:17 <lokien_> tnks: yeah. it was a compliment 
15:35:43 <ski> @let instance (Foldable f,Foldable g) => Foldable (Compose f g) where foldMap f (MkC fga) = foldMap (foldMap f) fga
15:35:44 <lambdabot>  Defined.
15:35:45 <tnks> lokien_: I think you'll find Haskellers extremely thoughtful about APIs.
15:36:18 <ski> @let instance (Traversable f,Traversable g) => Traversable (Compose f g) where traverse f (MkC fga) = fmap MkC (traverse (traverse f) fga)
15:36:20 <lambdabot>  Defined.
15:36:22 <danilo2> ski - is such compose somwehre defined ? I think that's beautiful solution
15:37:22 <sm> what standard function(s) let you repeatedly apply a sequence of functions and accumulate the result ? I always flounder with this. Is it just a fold, or do I need ap ?
15:38:00 <lokien_> tnks: what can I read though so my head will stop aching? really, I get physical headaches from reading type signatures
15:38:03 <danilo2> sm: foldr ($) ?
15:38:21 <danilo2> lokien_: read python manual :P
15:38:46 <lokien_> danilo2: headaches > vomiting
15:39:26 <danilo2> lokien_: I'm afraid to ask what will happen to you while reading javascript / java things :P
15:40:09 <danilo2> ski: is this Compose something you;ve done or is this something standard? I cannot find in on hackage
15:40:33 <tnks> lokien_: my feeling is it is just new for you, and it will pass with time.
15:40:38 <lokien_> danilo2: in reality I'm not *that* sensitive, I just don't like them.
15:41:01 <tnks> lokien_: there's a /lot/ of inference in Haskell, so you don't need to be explicit in a lot of places.
15:41:05 <danilo2> ski: ah, are you talking about Data.Functor.Compose? 
15:41:07 <lokien_> tnks: I'll take your word for it 
15:41:44 <tnks> lokien_: the type signature is really just a great statement a the top level of a function to state clearly what the function does.
15:41:51 <ski> danilo2 : <http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html> ?
15:41:54 <danilo2> lokien_: of course, I was just joking. But hearing about your reactions to Python was entertaining in some way 
15:41:55 <lokien_> tnks: I know I don't have to type them, I just wanted to know how they work :(
15:41:57 <tnks> within a function, you'll rarely see type annotations as much.
15:42:04 <danilo2> ski, ok thank you very much!: )
15:42:27 <lokien_> danilo2: python was my first language!
15:42:43 <tnks> lokien_: start simple and it's not really that crazy:  "a -> b -> a" is pretty straight-forward.
15:42:57 <danilo2> lokien_: everybody starts with something. There are worse choices though ;)
15:43:08 <danilo2> lokien_: glad you've landed here :)
15:43:31 <tnks> lokien_: after that, you'll want to learn about type classes to understand constraints and the "=>" notation.
15:43:39 <lokien_> tnks: but it's messy with traversals and such, iirc
15:43:44 <tnks> at which point, you'll be very close to "vanilla Haskell"
15:43:50 <echo-area> glguy: I should have read that link before solving the problem.  I read instead the haskell wiki, which is a little bit lacking.  I'm sorry it took more of your time on this.
15:44:23 <lokien_> danilo2: I'd landed on ocaml and lua too. is it bad?
15:44:25 * ski started with BASIC, so must be "mentally mutilated beyond hope of regeneration" (Dijkstra)
15:44:26 <tnks> lokien_: you'll get to Traversable with contraints and type classes.
15:44:36 <lokien_> danilo2: I can still go back from lua tho
15:44:53 <danilo2> lokien_: not at all. ocaml is pure fun, but I'm not a fan of lua
15:44:59 <lokien_> ski: have you had a blue tie?
15:45:08 <lokien_> tnks: hm, okay
15:45:10 * ski checks
15:45:14 <ski> nope, no tie
15:45:16 <danilo2> lokien_: stay with haskell, you'll not look back
15:45:24 <lokien_> ski: syntax error
15:45:42 <lokien_> danilo2: I was with haskell, and I looked :(
15:45:52 <lokien_> danilo2: now I'm looking back at haskell
15:45:55 <danilo2> lokien_: everybody makes mistakes ;)
15:46:01 <lokien_> :D
15:46:44 <lokien_> danilo2: you can use lua functionally, but it isn't statically typed, which is.. blah 
15:48:23 <danilo2> lokien_: I think I understand what oyu're looking for. In couple of (probbly) weeks we are finally releasing our programming langguage, which is pure fun. You should definitively check it out. It's called Luna (no connections to Lua though). You'll not find much about it right now, but you can grab me in a month or so
15:49:53 <Lokathor> hey
15:50:00 <lokien_> danilo2: can you link the best page available right now?
15:50:00 <Lokathor> was anyone looking to install sdl2 on their windows boxes today?
15:50:04 <Lokathor> https://lokathor.gitbooks.io/haskell-stuff/content/graphics/installing_sdl2.html
15:50:16 <Lokathor> please see if this works for you and tell me if you hit any walls i missed
15:50:21 <Lokathor> have fun folks
15:51:30 <sm> yes bitemyapp was
15:51:52 <lokien_> danilo2: I was expecting something different :D
15:53:31 <danilo2> lokien_: you havent seen it yet I think, so how do you know? ;)
15:53:31 <Lokathor> sm, yeah i know, he's the one who told me to write out that guide there :3
15:53:38 <sm> ok, cool
15:53:49 <Lokathor> now i just need test subjects
15:54:01 <Lokathor> it's a stack based guide, so it *probably* is sturdy, but maybe not
15:54:19 <lokien_> danilo2: googled it. lua, io, rust, ruby and c? :D
15:54:34 <ski> lokien_ : .. note that the "functor" concept is more general than what is captured by the `Functor' type class in Haskell. the latter are functors from the category `Hask' to the category `Hask' (aka endofunctors on `Hask')
15:54:37 <Lokathor> whoops, i already noticed that i missed a step >_<
15:54:46 <danilo2> lokien_: I told you you'll not find it. I'm not talking about it
15:54:59 <danilo2> lokien_: what you've found is just pure crap
15:55:03 <danilo2> lokien_: http://www.newbyteorder.com
15:55:32 <ski> lokien_ : do you know about kinds ?
15:55:33 <lokien_> danilo2: it was the crap of craps :D
15:55:43 <lokien_> ski: what are they? 
15:56:34 <lokien_> danilo2: wow, powerful team 
15:56:41 <lokien_> danilo2: can I join you? 
15:57:10 <ski> lokien_ : you might call kinds the "types of types". just like `False :: Bool' and `Just True :: Maybe Bool' is relating values to types; `Bool :: *' and `Maybe :: * -> *' is relating types to kinds
15:57:35 <lokien_> ski: I know them then 
15:57:37 <danilo2> lokien_: We've got a lot of collaboration requests and everybody is welcome as fast as we open source it. You have to wait couple of weeks for now, but sure, why not! :)
15:58:00 <lokien_> danilo2: so I won't be significant :(
15:58:24 <ski> lokien_ : a type of kind `*', a concrete type, is basically one that is capable of having values. you can't have a value of type `Maybe', it's "incomplete", you need to supply that type function with a (type) argument (of kind `*'), like `Maybe Bool' or `Maybe (Maybe Bool)', to get a type that is capable of having values
15:59:03 <lokien_> ski: yeah, I remember that 
15:59:09 <ski> lokien_ : then you can also get more complicated stuff like `StateT :: * -> (* -> *) -> *', a "higher-order type function"
15:59:11 <danilo2> lokien_: dont judge yourself to early, never :)
15:59:40 <lokien_> danilo2: I mean for now. I'd just break your code 
15:59:59 <ski> lokien_ : anyway, you can consider functors not only from `*' to `*' (that'd be the types classified by the type class `Functor'), but also from `*' to `* -> *', from `* -> *' to `*', from `* -> *' to `* -> *', and so on
16:01:18 <lokien_> ski: or from `*' to `* -> * -> *'? 
16:01:42 <ski> yep
16:01:44 <ski> lokien_ : e.g., let's say you have defined `newtype List ref a = MkL (ref (ListCell ref a))' together with `data ListCell ref a = Nil | Cons a (List f a)', then `ListCell IORef a' would be a type of lists, where the tail-linkage is indirected through mutable I/O reference cells
16:02:18 <ski> lokien_ : or you can use something else in place of `ref', like `Identity' to get basically ordinary lists back
16:03:02 <lokien_> ski: I'd love to understand that, but it's 1 am here. will you be there tomorrow?
16:03:38 <ski> lokien_ : now, the type of an "`fmap'-like thing", for `List' here would be `(forall x. f x -> g x) -> List f a -> List g a', allowing you to transform the `ref' part of `List ref a' into another type
16:04:31 <ski> for the usual kind of functor classified by `Functor', you can use it to change the `a' part in `Tree a' to any `b' you like (provided you give a function from `a' to `b')
16:05:01 <ski> in that case, the `a' type that you can "change" by the functor has kind `*' (so is a concrete type)
16:05:30 <ski> in the `List ref a' example, `List' being a functor (from `* -> *' to `* -> *') means that you can "change" the `ref' part, of kind `* -> *'
16:06:31 <lokien_> but I can't change the other parts? 
16:07:37 <ski> well, if `f' is a functor, then `List f' is also a functor. meaning that you can then change the `a' part of `List f a' into any `b' you like (provided a function from `a' to `b')
16:08:11 <ski> so you can (easily) write an `instance Functor f => Functor (List f) where ...'
16:08:54 <ski> one could introduce type classes for the other kinds of functors mentioned above .. but it gets a little hairy to invent a sensible naming convention
16:09:32 <lokien_> okay, thanks a lot :)
16:09:46 <ski> the best solution there would possibly be to use polymorphic type classes (enabled by an extension) (and possibly some other extension(s) as well) to have a single type class that would capture all ..
16:10:24 <lokien_> danilo2: what that language will be for? web, graphics standalone stuff?
16:10:42 <lokien_> ski: let's not go that hairy today 
16:10:43 <ski> in terms of types, a functor allow you to "change" a type that is being passed as argument to the functor
16:11:16 <lokien_> neat 
16:11:21 <danilo2> lokien_: everything. We've got Haskell and JS bindings. In fact everything we do (compiler, webgl GUI etc) is written in Luna & Haskell now only
16:11:23 <sm> danilo2: thanks, by the way (foldr ($))
16:11:40 <danilo2> sm: :)
16:11:46 <lokien_> danilo2: can I do 2d games in it? 
16:12:14 <danilo2> lokien_: it would be possible but we will not ship any usefull libraries for game development on the beginning
16:12:37 <lokien_> danilo2: hrm, so no "goodbye lua" this month 
16:12:56 <ski> (in the type suggested for the mapping operation for `List' above, you have an argument that's required to be polymorphic. this is known as a rank-2 type (an extension). the argument function has to be able to convert `f x' to `g x', for any type `x', not just `a' or `List f a' or something .. this is because the definition of `List f a' is free to apply `f' to any type in the body of the definition)
16:13:23 <lokien_> that's too much, man :D
16:13:37 <lokien_> for me at least 
16:14:52 <lokien_> I'm going to sleep, thank you all, see ya :)
16:15:03 <ski> good night, pleasant dreaming
16:25:35 <Lokathor> if there were a UI library for curses that didn't otherwise depend on anything beyond base, would it be a "good thing" to bring in mtl as a dependency and then make everything MonadIO instead of just IO?
16:25:51 <Lokathor> or, avoid the dependency and let users sort it themselves? or kinda just equal either way?
16:27:02 <MarcelineVQ> That's kinda vague, what does doing that provide you?
16:27:26 <Lokathor> well all the actions would be MonadIO m => m () instead of IO (), for example.
16:27:34 <Lokathor> they'd have liftIO pre-applied, in other words
16:27:58 <Ferdirand> how about making a separate module which exports the same names liftIOified ?
16:28:28 <Lokathor> Ferdirand, wouldn't affect the fact that at the library level you'd need the extra dependency even if they're in two different modules
16:28:52 <Ferdirand> well the extra module could be in a separate and very thin wrapper library
16:28:59 <ski> (.. and functions taking actions as arguments ?)
16:29:26 <Ferdirand> i'm just asking, i have no clue about packaging in general
16:30:05 <Stratege> danilo2 are you planning to release some document on the language's capabilities / reasons to use it over say Haskell?
16:30:12 <Lokathor> Ferdirand, you do make a good point. However, you can only have one "library" entry per .cabal file, so it would get a little clunky perhaps
16:30:23 <Lokathor> ski, I'm not clear on what you mean by the question
16:33:17 <ski> Lokathor : something like `frob :: IO Foo -> IO Bar'
16:33:38 <ski> should it become `frob :: MonadIO m => m Foo -> m Bar' ?
16:33:57 <ski> or `frob :: MonadIO m => IO Foo -> m Bar' ?
16:34:05 <ski> (also see "monad tunneling problem")
16:34:15 <Lokathor> well i see your point
16:34:33 <Lokathor> but also, Curses doesn't quite.. have that sort of function, generally
16:34:42 <ski> @google monad tunneling problem
16:34:42 <lambdabot> https://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
16:34:50 <ski> ok
16:34:51 <Lokathor> even a withCurses type wrapper and such wouldn't be very complex
16:35:02 <jle`> Lokathor: i don't think i'd worry about requiring transformers, because transformers is packaged with GHC, isn't it?
16:35:16 <Lokathor> but i'll read about this monad tunnling problem
16:35:40 <Lokathor> jle`, yeah i think so, actually
16:35:43 <jle`> there are libraries that approach things both ways, so as long as you are consistent, feel free to do what you want
16:35:52 <jle`> you might run into trouble with the MonadIO m => approach in a few situations
16:36:01 <jle`> also, a lot of people like controlling how their liftIO's associate
16:36:21 <jle`> `liftIO x >> liftIO y` might be different, perfornace-wise, than `liftIO (x >> y)`
16:36:24 <jle`> s/associate/distribute
16:36:33 <Lokathor> true
16:36:44 <Lokathor> i guess i'll probably do the simple and obvious non-mtl thing
16:36:50 <Lokathor> and let people lift as they like
16:36:51 <jle`> so if all you ever do is provide liftIO x, people can't control this
16:36:54 <jle`> yeah
16:37:01 <jle`> in any case, i wouldn't worry about relying on transformers, in general
16:37:07 <jle`> (MonadIO is in transformers, not mtl)
16:37:30 <Lokathor> well there's fun to be had in a package that relies only on base
16:37:32 <jle`> any person that uses your library will already have transformers installed, anyways
16:37:53 <jle`> (it comes with ghc)
16:38:25 <jle`> heh, yeah, it can feel nice :P
16:38:50 <jle`> for an example of a commonly used library that does everyhting polymorphic over MonadIO when it can, see pipes
16:39:04 <jle`> although i think things might have changed since i last saw it
16:40:02 <jle`> and for dealing with the awkward situations that inevitably that arise from MonadIO m => everywhere, see monad-control
16:40:32 <Lokathor> i read about a Tardis monad, which sounds interesting, but I had a hard time wrapping my head around when I'd actually need it
16:42:55 <jle`> there are some cute examples of reverse state floating around
16:43:03 <jle`> but i don't know if people actually use Tardis in real life
16:43:05 <jle`> heh
16:43:17 <Lokathor> there's really just the one guy
16:43:24 <Lokathor> he shows up again and again though
16:44:42 <jle`> has a different look every time too, sorta creeps me out
16:46:22 <Hijiri> it probably wasn't worth it, but I used tardis to make a "modify the smallest value" function over traversables
16:46:53 <jle`> i remember last year i was sort of searching for an example of a type that had multiple monad instances, and i had totally forgotten about state/reverse state
16:46:56 <jle`> Hijiri: oh that's interesting
16:47:10 <jle`> that makes sense
16:47:24 <Lokathor> Hijiri, if by "wan't worth it" you mean "totally cool" then yes
17:06:02 <Lokathor> you know your function is probably general enough in just the right way when the typeclass constraints are over 6 times as long as the rest of the signature
17:08:19 <deech> I'm in an MSYS2 shell and my Setup.hs is not finding executables in the shell's path. Is there a way to tell it to search in the MSYS2 shell search path?
17:08:48 <Axman6> Lokathor: if some of those type classes are often used together, you can use constraint kinds to make a new name for them: type AllTheClasses a b = (Read a, Show b, Ord a, Profunctor b)
17:09:43 <adas> a cool one liner in haskell?
17:09:51 <adas> other than let fib= ....
17:10:03 <Lokathor> Axman6, that's a good idea i think
17:10:09 <Lokathor> rollOne :: (Integral i, Random i, RandomGen g, MonadState g m) => i -> m i
17:10:19 <Lokathor> and then like 20 variations of how to roll dice
17:11:37 <Axman6> adas: main = putStrLn "Hello, world!"
17:19:34 <schell> has anyone had any luck converting Html from blaze-html to Html () with Lucid?
17:20:16 <schell> i’m trying to use Lucid for templating with pandoc, but pandoc uses blaze-html - hence having to map from one to another
17:39:25 <blogle> how can I encode binary operator type dependencies like: Int -> Int -> Int and Float -> Int -> Float and Int -> Float -> Float
17:40:18 <Lokathor> blogle, you just did? I'm confused, could you ask the quesiton another way?
17:40:23 <scshunt> blogle: what do you mean?
17:42:17 <jle`> foo :: Float -> Int -> Int; foo = ..
17:43:15 * hackagebot http2 1.4.5 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.5 (KazuYamamoto)
17:49:14 <blogle> I have data Column a where .... that can take on Column Vector or Column Scalars. If I add Column Scalars I want to enforce at the type level that the result is a Column Scalar, but If I add a Column Scalar to a Column Vector I get a Column Vector. But I also get a Column Vector when adding a Column Vector to a Column Scalar.
17:49:24 <blogle> hopefully that makes some sense
17:50:51 <Lokathor> make each add operation a different function?
17:50:59 <Lokathor> or use a conversion function explicitly
17:51:21 <Lokathor> oh wait
17:51:45 <Lokathor> you want a function like, addCol :: Column a -> Column a -> Column a
17:51:55 * goctintuc is busy
17:51:56 <Lokathor> and then to enforce things about the a
17:52:17 <Lokathor> tricky
17:52:22 <blogle> exactly!
17:52:56 <Lokathor> i'm not sure, but i think you need to have different functions for each matchup
17:53:13 <Lokathor> if you want to ensure at the type level how things will work out
17:54:04 <Lokathor> you can't really look at the type inside a polymorphic variable, at least not at my skill level you can't
17:55:08 * ski objects to the phrase "polymorphic variable" here ..
17:55:09 <scshunt> or use a type family
17:55:21 <scshunt> type family ColumnSum a b
17:55:34 <scshunt> addCol :: Column a -> Column b -> ColumnSum a b
17:55:49 <blogle> oooh that looks nice 
17:56:21 <Lokathor> ski, "polymorphically typed variable binding"?
17:57:55 <ski> i would describe `a' in `Column a -> Column a -> Column a' as a "type variable"
17:58:23 <Lokathor> but i don't mean the 'a', i mean the thing it's describing
17:58:32 <ski> and `a' in `addCol :: forall a. Column a -> Column a -> Column a' (which is what your signature really means, barring `a' being bound elsewhere) as a universally bound type variable, i suppose
17:58:56 <Lokathor> but i mean the x in "addCols x y = ..."
17:59:01 <ski> well, in a specific instance use, `a' will be replaced by whatever type the caller decides to use
18:02:06 <ski> so i suppose instead of "you can't really look at the type inside a polymorphic variable", i'd possibly say something like "you can't really detect, (at run-time) inside a polymorphic operation, what actual type is used for the universally quantified type variable"
18:03:31 <ski> e.g., if you have (part of) an input, having that type variable as type, then you can't detect the actual type used by "looking at the input value"
18:04:05 <Lokathor> okay, that's pretty much what i said
18:04:39 <ski> except you used the (imho nonsense) term "polymorphic variable", which was all i was objecting to :)
18:05:39 <ski> the ways to workaround the above inability are to use a constraint on the type variable, or to use a GADT
18:06:03 <Lokathor> it's a variable, and it's type is a polymorphic one, eh
18:06:18 <ski> (neither of which changes the actual limitation (which is also a strength). they just enable you to work around it)
18:07:14 <ski> well, in `addCol :: forall a. Column a -> Column a -> Column a', `a' is not a polymorphic type (its kind is `*', which doesn't involve any `forall')
18:07:42 <ski> if some part of an input of type `Column a' has type `a', then that input part is still not polymorphic
18:07:57 <ski> a polymorphic value is one whose type is of the shape `forall a. ..a..'
18:08:32 <ski> examples being `Nothing',`reverse',`readLn'
18:08:57 <hodapp> :t 0
18:08:58 <lambdabot> Num a => a
18:08:59 <ski> (of types `forall a. Maybe a',`forall a. [a] -> [a]',`forall a. Read a => IO a', respectively)
18:09:05 <Lokathor> ski, I don't see the distinction, but i'll trust you if you say that the compiler is able to see one where i cannot
18:09:06 * ski nods
18:09:51 <ski> Lokathor : `reverse' is polymorphic because its general type `forall a. [a] -> [a]' specializes to `[Int] -> [Int]',`[String -> IO Bool] -> [String -> IO Bool]',&c.
18:10:12 <Lokathor> alright, sure, so how is [a] different from Column a
18:10:29 <ski> no real difference here
18:11:04 <ski> `reverse' is polymorphic. `forall a. [a] -> [a]' is not polymorphic. and `[a] -> [a]',`[a]',`a' are not polymorphic either
18:11:27 <Lokathor> define polymorphic
18:11:42 <ski> i tend to call a type like `forall a. [a] -> [a]' universal (because `forall' is known as a "universal quantifier")
18:12:27 <ski> `reverse' has "many shapes", in the sense that you can get (infinitely) many specializations for it. one operating on lists of `Int's, another on lists of `String's, another on lists of functions from `String' to `IO'-actions returning `Bool',&c.
18:12:38 <Lokathor> but you said that reverse was a "forall a. [a] -> [a]", and then you said that it's polymorphic, but that its type is not
18:12:46 <ski> yes
18:13:09 <Lokathor> are you trying to say that a polymorphic function isn't the same as a polymorphic type?
18:13:16 <ski> yes
18:13:16 <Lokathor> because sure
18:13:29 <ski> the kind of `forall a. [a] -> [a]' is simply `*'. no `forall' in the kind, so the type `forall a. [a] -> [a]' isn't polymorphic
18:13:32 <ski> if you define a type
18:13:41 <ski>   newtype Flip f a b = MkFlip (f b a)
18:14:04 <ski> then `Flip' gets kind `forall k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *'
18:14:12 <ski> `Flip' is polymorphic, has universal kind
18:14:29 <Lokathor> when did kind come into it
18:14:55 <ski> (`k0' and `k1' here are *kind* variables, not type variables. in particular uses of `Flip', `k0' (resp. `k1') can be replaced by `*' or `* -> *' or ...)
18:15:36 <ski> Lokathor : the point being that there *are* polymorphic types (like `Flip'). but the type of a polymorphic operation (like `Nothing' or `reverse') is not itself polymorphic
18:16:33 <ski> i'm using basically the same idea of "polymorphism" on the type level, for types, as on the value level, for values
18:17:22 <Lokathor> if you're trying to tell me that "reverse :: [a] -> [a]" doesn't describe an operation that you'd call polymorphic then I don't think I care for your definition of polymorphic because it sounds silly and excessively restrictive
18:17:41 <ski> since this seems like a useful thing to be able to do (at times), it would be a shame if by "polymorphic type" we really intended to mean "the type of a polymorphic operation" (which is something completely different from "polymorphic type" above)
18:17:57 <ski> Lokathor : `reverse' is for sure polymorphic
18:18:15 <ski> but its type, `forall a. [a] -> [a]', for sure, *isn't* polymorphic
18:18:55 <ski> compare : `"foo"' is a string, but its type, `String', isn't a string
18:19:34 <Lokathor> well of course a type doesn't have a type itself
18:20:08 <ski> well, a type has a kind, which is what we intend by the vague phrase "the type of a type"
18:20:52 <Lokathor> i would always endevor to avoid using the phrase "type of a type" and always try to say kind whenever i can remember to do so
18:21:12 <ski> if we read `::' aloud as "has type", then we could read `Bool :: *' as : `Bool' has type `*' -- only we prefer to use the term "kind" here, instead of "type", for better precision
18:21:29 <ski> (another reading of `::' would possibly be "inhabits")
18:21:46 <ski> Lokathor, *nod*
18:22:03 <Lokathor> when reading the phrase "Bool :: *" I'd say "Bool has kind Star" and just accept that :: is, like many other symbols and words, overloaded
18:22:18 <ski> Lokathor : anyway, i suspect that one of the problems here is that in many cases in Haskell, the `forall's in the types are implicit
18:23:05 <Lokathor> would you say "a function is polymorphic when it has a polymorphic type"?
18:23:09 <ski> so when people see `reverse :: [a] -> [a]' they (seem to) think "oh, the presence of the type variable `a' in the type of this operation `reverse' means that it is a polymorphic operation"
18:23:17 <ski> .. which isn't quite right
18:23:52 <ski> it's the presence of `forall' in ("the front of") `reverse :: forall a. [a] -> [a]' which indicates that `reverse' is a polymorphic operation
18:24:17 <ski> only that `forall a. ' part is often kept implicit, and Haskell will silently fill it in for you
18:24:50 <Lokathor> yes, an unbound type variable sure is a sign of polymorphism
18:24:51 <ski> Lokathor : no. the type of `reverse' (which is polymorphic) is `forall a. [a] -> [a]' (which is not polymorphic)
18:25:10 <ski> Lokathor : not quite
18:25:38 <Lokathor> i think this sounds like an unncessary splitting of hairs
18:26:23 <ski> the main reason i'm making the distinction is that it's useful to use the term "polymorphic" for types. but types like `forall a. [a] -> [a]' are not the types which are polymorphic
18:26:55 <ski> iow an operation being polymorphic doesn't mean the same as the type of the operation being polymorphic
18:28:12 <osa1> :t (-)
18:28:13 <lambdabot> Num a => a -> a -> a
18:28:37 <osa1> funny, it could be `Num a => a -> a` as well
18:28:59 <Lokathor> an unfortunate overloading of the concepts of subtract and negate
18:29:29 <Lokathor> the TI-89 actually uses different keys for each
18:30:36 <ski> Lokathor : consider `class Eq a where (==),(/=) :: a -> a -> Bool'. as a method of this class, `(==)' isn't polymorphic. the dictionary implementation would generate `data EqDict a = MkEqD {eq,neq :: a -> a -> Bool}' where the fields are *not* polymorphic
18:30:37 <Enigmagic> :t negate
18:30:38 <lambdabot> Num a => a -> a
18:30:50 <Lokathor> :t subtract
18:30:51 <lambdabot> Num a => a -> a -> a
18:31:05 <ski> compare this with `class Functor f where fmap :: forall a b. (a -> b) -> f a -> f b'. here the method *is* polymorphic
18:31:59 <osa1> ha, cool. I didn't know we have negate
18:32:11 <ski> then it's another fact that a use of the method `(==)' will be (constrained) polymorphic, of type `forall a. Eq a => a -> a -> Bool'
18:32:52 <Lokathor> ski i don't want to be rude but you'll never convince me on this subject
18:33:51 <ski> (the dictionary for `Functor' would look like `data FunctorDict f = MkFunctorD {fmap :: forall a b. (a -> b) -> f a -> f b}'. this would require the extension `PolymorphicComponents', though)
18:34:36 <ski> with `Rank2Types', we can have `runST :: forall a. (forall s. ST s a) -> a'. note that `runST' is *not* polymorphic in `s', despite `s' being a type variable in its type
18:35:42 <ski> LHC (another, experimental, Haskell compiler) had an `exists' quantifier in types. an operation like `foo :: Int -> exists a. Bar a' wouldn't be polymorphic in `a', despite it being a type variable
18:35:46 <ski> and so on ..
18:36:12 <ski> Lokathor : to be clear, i'm not quite sure on which point you disagree
18:36:59 <ski> (but i'll stop now)
18:43:18 <blogle> sleuthing through search results on type families lead me to this slide http://cdepillabout.github.io/haskell-type-families-presentation/#/4
18:43:26 <blogle> this is pretty much my use case
18:43:31 <blogle> thanks
18:54:11 <kaizoku> from hacker news: http://www.willamette.edu/~fruehr/haskell/evolution.html
18:56:51 <phoe_krk> I have (!!) [1,2,3] 0 => 1. How can I switch the places of the number and the list though?
18:57:16 <phoe_krk> I need the list on the last place so I can apply the whole function to it.
18:58:01 <kaizoku> phoe_krk: you're looking for flip
18:58:13 <saulzar> > flip (!!) 0 [1,2,3]
18:58:15 <lambdabot>  1
18:58:29 <phoe_krk> Thanks!
18:59:19 <ski> > map (flip (!!) 1) [[0,1,2,3],[4,5,6],[7,8]]
18:59:21 <lambdabot>  [1,5,8]
18:59:27 <ski> > map (!! 1) [[0,1,2,3],[4,5,6],[7,8]]
18:59:29 <lambdabot>  [1,5,8]
19:13:29 * hackagebot Gifcurry 0.1.0.4 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-0.1.0.4 (lettier)
19:33:45 <koz_> I'm having a bit of trouble understanding how I would implement this typeclass: https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:MonoTraversable for a type of the form 'data Foo = Foo [Bar]'. The idea is that the inner [Bar] is part of that typeclass, so I'm not sure how to 'lift' it properly.
19:34:58 <koz_> s/so/but
19:49:19 <nitrix> Does haskell has an equivalent of $ at the type level?
19:50:47 <shanemikel> :t (>>=)
19:50:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:52:03 <shanemikel> https://en.wikibooks.org/wiki/Haskell/Monad_transformers is confusing me
19:52:13 <shanemikel> so what's with 
19:52:16 <shanemikel> :t guard
19:52:17 <lambdabot> Alternative f => Bool -> f ()
19:52:32 <shanemikel> why is it alternative and not MonoidPlus?
19:52:37 <shanemikel> like in https://en.wikibooks.org/wiki/Haskell/MonadPlus
19:52:50 <shanemikel> err MonadPlus
19:53:12 <kadoban> shanemikel: Are you familiar with how every Monad is an Applicative, so Applicative f => f   is just plain more general than Monad f => f ?
19:53:58 <shanemikel> don't you mean Applicative --> Monad
19:54:33 <Lokathor> Monads are Applicatives, not all Applicatives are Monads
19:54:35 <kadoban> shanemikel: I mean that if you know something is a Monad, it's also an Applicative, guaranteed.
19:54:39 <shanemikel> right? Monad -/> Applicative ^ Monad </> Applicative
19:54:53 <kadoban> I don't know what that notation means.
19:54:54 <shanemikel> oh yea
19:54:56 <shanemikel> I see
19:55:05 <shanemikel> okay, so what's this Alternative
19:55:21 <kadoban> shanemikel: Alternative is to Applicative as MonadPlus is to Monad
19:55:21 <ski> @src Alternative
19:55:21 <lambdabot> class Applicative f => Alternative f where
19:55:22 <lambdabot>     empty :: f a
19:55:22 <lambdabot>     (<|>) :: f a -> f a -> f a
19:56:02 <kadoban> shanemikel: MonadPlus and Alternative have a similar relationship to that of Monad and Applicative
19:56:20 <shanemikel> okay so the sigs have been changed?
19:56:32 <shanemikel> or are they just doing that in wikibooks to be tricky?
19:57:13 <kadoban> shanemikel: I think it was changed, to be more general. The types in the wikibook are basically just more restrictive, but not really problematically incorrect.
19:57:40 <kadoban> shanemikel: In other words, you can pretend the type is still as restrictive as it says it is in the wikibook and nothing bad should happen.
20:00:24 <zq> @pl \a -> a
20:00:24 <lambdabot> id
20:01:27 <nshepperd_> nitrix: looks like it's actually as easy as defining 'type ($) (a :: k) = a' with PolyKinds and TypeOperators
20:02:20 <nitrix> I think so too.
20:13:35 <v444> is there a clean way to clear off old lts snapshots in stack?
20:13:50 <v444> i'm switching from lts-5.0 -> lts-5.2
20:13:58 <v444> and lts5.0 is a good ~2 gigs
20:16:40 <crough> Delete them in .stack?
20:17:09 <Lokathor> what is the effect, if any, of declaring "other-extensions:   CPP" in my cabal file, compared to just putting it at the top of the file that uses it?
20:17:27 <Lokathor> if it's in other-extensions: does every file in the build count as having it?
20:17:56 <crough> Other extensions just declares it
20:18:03 <crough> default-extensions adds it to every file implicitly
20:18:12 <crough> other-extensions is just for documentation, iirc
20:18:25 <Lokathor> okay
20:19:44 <Lokathor> and do -threaded or -rtsopts -with-rtsopts=-N have any effect on a library entry? or binary and test-suite only?
20:20:13 <crough> Only binary. Libraries can't control how they are used in the future.
20:20:50 <v999> ack lost my irc window
20:21:04 <v999> anyone see that question about stack?
20:21:14 <shanemikel> wow, this monad transformer stuff is pretty messy
20:21:16 <v999> is there a clean way to remove previous snapshots?
20:21:27 <Lokathor> v999, i think you can just delete that directory
20:21:32 <MarcelineVQ> v999: crough said you can delete the specific snapshot you don't want anymore from the snapshopts folder in your .stack folder
20:21:50 <v999> lokathor that's not goint to mess up assumed dependencies or something in haskell?
20:21:53 <v999> er in stack
20:22:00 <MarcelineVQ> if it needs them it'll get them again
20:22:27 <Lokathor> v999, nope, each lts keeps things seperate. If it shared a lib between versions it'll get it again if it needs, like MarcelineVQ says
20:22:36 <Lokathor> MarcelineVQ, are you on windows?
20:22:46 <MarcelineVQ> No why
20:23:09 <Lokathor> i want windows guinea pigs to try out my "install sdl2 with stack on windows" article i wrote
20:23:49 <crough> MarcelineVQ: you can just delete the whole folder if you want. Haskell statically compiles everything by default; you aren't going to break anything.
20:23:51 <v999> ok here goes
20:23:58 <crough> Well, that was meant for v999 but :)
20:24:08 <MarcelineVQ> :>
20:25:20 <shanemikel> in practice, do y'all see yourselves using Monad Transformers with inner monad other than IO very often?
20:26:11 <v999> whoops lts 5.2 is choking
20:27:10 <MarcelineVQ> I just switched to 4.1 and y'all moved on to 5.2
20:27:43 <v999> so far 5.2 is not working so well
20:27:57 <v999> isn't there some kind of check to see that lts packages build? why isn't this working ...
20:28:47 <v999> compilation errors
20:29:29 <kadoban> shanemikel: Sure. I rarely transform with IO at the base.
20:29:36 <crough> v999: It should just print it out?
20:30:20 <MarcelineVQ> v999: http://lpaste.net your errors
20:30:37 <johnzorn> Is Yorgey's cis194 course the best way to get started with learning haskell? There are so many resources it can be difficult to weigh them.
20:31:32 <MarcelineVQ> johnzorn: for free resources it's one of the best, it won't hold your hand though so you gotta read the reccomended stuff closely and expect some work
20:31:36 <kadoban> johnzorn: The ones I recommend are that one, specifically the spring '13 version (the others don't teach the same things exactly), or http://haskellbook.com/ , which I suspect is much better, but not free.
20:31:47 <v999> marcelineVQ http://lpaste.net/151927
20:32:09 <v999> johnzorn agree with kadoban haskellbook.com is great. stay away from learn you a haskell.
20:32:50 <MarcelineVQ> v999: is there a particular reason you're using install on that?
20:32:57 <johnzorn> v999: I was about to check that one out :)
20:33:04 <johnzorn> ok thanks
20:33:32 <v999> marcelineVQ it's the dependency that happened to fail
20:33:51 <v999> i have a shell script that installs a whole lot of my usual packages for when i upgrade lts
20:34:01 <MarcelineVQ> hmm well, install isn't for installing libraries, it's for building and installing tools to .local/bin Can you paste the error from the project where that dependency failed?
20:34:40 <v999> marcelineVQ didn't know that it seems to work for installing libraries most of the time
20:34:47 <v999> marcelineVQ it's the global project
20:34:59 <v999> i'm just doing stack install [ ~ 50 packages ]
20:34:59 <kadoban> MarcelineVQ: v999, etc: deleting random snapshots from .stack/ isn't actually a good idea, per some discussions earlier. You happen to be able to do it if the GHC version differs between them, but otherwise it can break things.
20:35:17 <phoe_krk> Oh hell.
20:35:19 <phoe_krk> It's over.
20:35:20 <phoe_krk> http://lpaste.net/151924
20:35:30 <phoe_krk> I'll work on it some more tomorrow.
20:35:54 <v999> kadoban this was what i was worried about...
20:36:06 <v999> kadoban must have missed the discussion when i got logged out
20:36:26 <v999> that's why i was asking if there's a cleaner way to wipe previous snapshots
20:36:27 <kadoban> v999: It may have been in #haskell-stack , can't recall. It was earlier in the day.
20:36:56 <v999> dunno why snoyman has such an aversion to a formal uninstall command
20:36:56 <kadoban> v999: There isn't currently that I know. You can delete *all* the snapshots, but that'll entail a lot of building when you want to use some stuff again.
20:37:02 <kaizoku> phoe_krk: for what it's worth, `flip (!!) 0` can be rewritten as `head`
20:37:13 <kaizoku> > flip  (!!) 0 [1.23]
20:37:14 <lambdabot>  1.23
20:37:19 <kadoban> v999: I don't think he does? It's just not implemented yet.
20:37:20 <phoe_krk> oh
20:37:25 <phoe_krk> thanks
20:37:28 <kaizoku> > flip  (!!) 0 [1..23]
20:37:28 <v999> "why would you ever want to uninstall" ... because each of these things is taking up 2 gigs of space on my laptop hd that's why
20:37:29 <lambdabot>  1
20:37:33 <kaizoku> > head [1..23]
20:37:34 <lambdabot>  1
20:37:52 <kaizoku> > (!! 0) [1..23]
20:37:53 <lambdabot>  1
20:37:57 <v999> snoyberg i mean. see - https://github.com/commercialhaskell/stack/issues/361
20:38:00 <kaizoku> or merely (!! 0) will give you the first element
20:38:19 <v999> "Can someone explain what the motivation would be for using uninstall? ..."
20:38:38 <kadoban> v999: That's different. 'stack install' just copies some executables into ~/.local/bin/. It has nothing at all to do with snapshots or whatever.
20:38:55 <kadoban> v999: The issue more in tune with what you're talking about would be: https://github.com/commercialhaskell/stack/issues/133
20:38:56 <v999> kadoban well maybe i'm using stack all wrong
20:39:03 <Axman6> things installed via stack are only installed becauser they are dependencies of some project on the machine, so uninstalling things would mean reinstalling the packages to make that project again
20:39:27 <v999> but "stack install" seems to work to install packages to the global projec
20:39:28 <v999> t
20:39:39 <v999> my understanding is that those get reused if a particular project needs them, right?
20:39:58 <Axman6> there's no such thing, but executables can be isntalled globally
20:40:01 <v999> there's a set of like 50  packages i know i'll be needing in multiple projects
20:40:06 <Axman6> yes
20:40:06 <kadoban> v999: It's basically by accident, and only in the sense that they'll be usable in 'stack ghci'. 'stack build' should do the same thing for that.
20:40:30 <kadoban> And yes, built packages are reused where possible.
20:40:38 <v999> right, but if i'm upgrading LTS and i know i'll need these packages, why not install these all overnight
20:40:45 <v999> and save the time for the individual projects
20:40:55 <Axman6> as long as you use the same LTS (or a compatible one*) then packages will be shared, without the breakages you used to get through cabal when you needed conflicting versions
20:41:18 <v999> yeah, so that's my motivation for doing one big global package install
20:41:21 <v999> when i upgrade LTS
20:41:30 <kadoban> v999: You can, but the 'install' part only works because it also builds them as a side effect. 'stack install' is 'stack build' + copying some files.
20:41:45 <Axman6> packages will also be reused between LTS versions if possible (they are installed exactly the same with identical dependencies)
20:41:46 <v999> might as well install them so i don't have to wait 5 minutes here 10 minutes there for each individual project later
20:42:08 <MarcelineVQ> your script could just build the projects instead :>
20:42:24 <v999> axman6 well i guess maybe that's why wiping the previous lts snapshot dirs is breaking things
20:42:32 <MarcelineVQ> They'll have the old LTS though unless you change that first
20:42:39 <kadoban> v999: This conversation doesn't seem to be leading anywhere. Anyway, the important point I was trying to make is that you're misreading what that issue you linked to is talking about.
20:42:41 <v999> marcelineVQ that would be more complicated since i'd have to change the stack.yaml files per project
20:43:02 <Axman6> v999: yes, they are symlinked into the new LTS dir
20:43:36 <glguy> Sometimes you see stack mention something about using precompiled version
20:43:48 <glguy> instead of building it, that means it's using the version from a previous snapshot
20:43:50 <jellytux> Hi, if we derive Eq to ur data type does every field have to also derive Eq?
20:44:21 <Axman6> jellytux: yes
20:44:28 <glguy> jellytux: It doesn't have to derive Eq necessarily, but it does need Eq instances for all of the types of the fields
20:44:29 <jellytux> If so, how do we ignore the fields that don't derive it?
20:44:36 <glguy> no, you don't get to do that
20:44:54 <jellytux> glguy: Ok, just wanted to know. Thanks
20:45:31 <v999> kadoban i've wiped my .stack dir entirely and am trying to start from scratch. maybe it will work now
20:54:39 <materia> Hello folks?
20:54:51 <materia> Just came here to recommend this book
20:54:57 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
20:55:00 <jellytux> is there a typeclass that enables us to enumerate our data type circularly? e.g data Day = Monday | Tuesday | ... | Sunday deriving (Enum, Circular); succ Sunday == Monday
20:55:01 <materia> Its an hacking book
20:55:05 <materia> I enjoyed it
20:55:14 <materia> Never had a hacker book before
20:55:30 <materia> It really help me understand how to hack
20:55:33 <Axman6> this channel has nothing to do with hacking
20:55:44 <kadoban> materia: I wouldn't think anyone else appreciates spam.
20:55:50 <Axman6> (except in the programming sense)
20:55:54 <materia> The book is not known by many.. and i wanna share it
20:55:54 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
20:55:57 <o`connor> materia: i see you want to make money from your affiliate link, gtfo
20:55:59 <materia> Oh i see
20:56:02 <materia> but programming
20:56:04 <materia> i like hacking
20:56:06 <materia> in a way
20:56:12 <materia> if you cant program you cant hack
20:56:24 <materia> atleast
20:56:25 <jellytux> materia: thanks, I will probably read it
20:56:29 <jellytux> materia: only 110pages
20:56:31 <materia> sure
20:56:47 <materia> yeah thats why i read it like 7 times hahah
20:56:49 <shanemikel> is there any pratcical difference between (Alternative m, Monad m) and (MonadPlus m)
20:56:50 <materia> kinda crazy
20:57:30 <shanemikel> that is (Alternative m, Monad m) => m and (MonadPlus m) => m
20:59:48 <Axman6> materia: yeah this is really off topic in this channel, particularly since you're trying to make money of the channel members. Please do not spam our channel
21:00:16 <materia> WTF?
21:00:31 <materia> its not off topic
21:00:35 <Axman6> yes it is
21:00:36 <materia> everyone wants to hack
21:00:40 <Axman6> it has nothing to do with Haskell
21:00:41 <kadoban> shanemikel: In current GHC I think the only difference would be that you can't use the name 'mzero' or 'mplus' with the former. (you'd have to use the names 'empty' and (<|>) instead, which most people use anyway)
21:00:45 <glguy> materia: Did you have a Haskell question?
21:00:53 <materia> what is haskell?
21:00:56 <koz_> I'm having a bit of trouble understanding how I would implement this typeclass: https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:MonoTraversable for a type of the form 'data Foo = Foo [Bar]'. The idea is that the inner [Bar] is part of that typeclass, but I'm not sure how to 'lift' it properly.
21:01:04 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:04 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:05 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:06 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:06 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:07 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:08 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023Xhttp://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023Xhttp://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:08 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:09 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:10 <materia> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:01:10 <Axman6> @where ops
21:01:10 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:01:19 <Axman6> heh
21:01:25 --- mode: ChanServ set +o shapr
21:01:25 <kaizoku> :|
21:01:37 <shapr> dang, too slow
21:01:39 --- mode: shapr set -o shapr
21:01:41 <glguy> k-line is better than I can do :)
21:01:52 <Axman6> indeed =)
21:02:43 <ski> shanemikel : i think the laws on `MonadPlus m' doesn't follow from the laws on `(Alternative m,Monad m)'
21:04:39 <shanemikel> I'm getting a wierd type inference error
21:04:40 <Axman6> koz_: what problems are you having?
21:05:15 <saulzar> koz_, Have a look at how some of the built-in instances are witten, first you need to define the element type... e.g.  instance Element Foo = Bar
21:05:17 <shanemikel> `returnIf p x = guard (p x) >> return x` alone, ghc can infer the type
21:05:33 <shanemikel> but if I add an alias like so: `emptyOr = returnIf`
21:05:53 <shanemikel> No instance for (MonadPlus m0) arising from a use of ‘returnIf’ (until I explicitely set the types)
21:06:01 <saulzar> koz_, Sorry - type instance Foo = Bar  
21:06:19 <Axman6> Element Foo*
21:06:20 <ski> shanemikel : that's DMR
21:07:46 <koz_> saulzar: OK, I'll try. Axman6: I'm having trouble understanding what otraverse is meant to do.
21:08:06 <kadoban> koz_: Are you familiar with Traversable itself?
21:08:13 <saulzar> koz_, First you need MonoFunctor - that should be simpler
21:08:58 <koz_> saulzar: I've done all of those already. kadoban: Not really, no.
21:09:14 <saulzar> koz_, Ah.. good good
21:10:00 <Axman6> otraverse f (Bar xs) = Bar <$> otraverse f xs -- I think
21:10:14 <Axman6> that feels mightly lensy
21:10:14 <koz_> Axman6: What's <$> again?
21:10:18 <Axman6> fmap
21:10:32 <kadoban> koz_: Well, I'd probably recommend you get familiar with the original versions of these typeclasses before starting in on the mono-traversable versions.
21:10:46 <koz_> kadoban: OK, I'll do that.
21:10:52 <Axman6> fmap Bar (otraverse f xs) if you prefer
21:11:19 <koz_> Oh, right, <$> is just infix fmap for Applicatives.
21:11:30 <Axman6> well, for Functors =)
21:12:31 <koz_> Alrighty, I'll try and make sense of Traversable first, then. 
21:12:49 <Axman6> (actually, if Bar is a newtype, otraverse = coerce otraverse)
21:13:25 <archlinux> http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:13:47 <koz_> Axman6: It's not a newtype.
21:13:58 <koz_> I guess I'm trying to understand wtf traverse is meant to do.
21:14:08 <Axman6> :t traverse
21:14:09 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:14:24 <Axman6> :t sequenceA -- a bit easier to understand
21:14:25 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:15:00 <Axman6> If you have a [IO a] you can use sequenceA to turn that into IO [a]
21:15:13 <Guest9042> hey haskell newbie here does everyone know whether there is a hackage for shrinkable and growable vectors
21:15:14 <koz_> Is sequenceA a sub-process of traverse?
21:15:27 <Axman6> yes, it can be implemented using traverse
21:15:36 <caconym> are the "downloads in last 30 days" numbers on hackage mostly accurate? they always seem surprisingly low to me
21:15:47 <Axman6> I think they're equivalent because of Functor being required for Traversable
21:16:06 <Axman6> traverse f x = sequenceA (fmap f x)
21:16:17 <koz_> Yeah, that's what I thought.
21:16:23 <Axman6> anyway, you probably know traverse better as mapM
21:16:26 <Axman6> :t mapM
21:16:27 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
21:17:12 <Axman6> hmmm, ok that type is less useful for explaining this than it used to be =)
21:18:31 <koz_> OK, that actually makes a bit more sense now. At least, I get how I would do the lift now, even if the whole Traversable thing still doesn't fit into my mental model like, at all.
21:19:37 <Axman6> :t map
21:19:38 <lambdabot> (a -> b) -> [a] -> [b]
21:19:44 <Axman6> :t mapM print -- oops
21:19:45 <lambdabot> (Show a, Traversable t) => t a -> IO (t ())
21:20:25 <koz_> Axman6: It's ok - I'll think and read about it, and maybe it'll make more sense.
21:20:55 <koz_> Also, with the 'list wrapper' types, is it correct that I can't implement Functor (for instance)? By that I mean types of the form 'data Foo = Foo [Bar]', and I wanna have Foo be a Functor.
21:21:11 <Axman6> yes, Bar has the wrong kind
21:21:11 <saulzar> mapM :: (a -> m b) -> [a] -> m [b]
21:21:29 <koz_> You mean *Foo* has the wrong kind, no?
21:22:01 <saulzar> Yes, it has no parameter
21:22:05 <kadoban> koz_: Correct.
21:22:34 <kadoban> koz_: If you haven't, you should do NICTA. It'll teach you a lot about this. It's essentially a guided tour through implementing a bunch of these typeclasses.
21:22:42 <koz_> NICTA?
21:22:53 <ski> @where NICTA
21:22:54 <lambdabot> https://github.com/nicta/course
21:23:04 <koz_> Oh, cool, thank you ski and kadoban!
21:24:22 <koz_> I dunno ... something about that seems odd to me; I can have it implement MonoFunctor, but not Functor, because Functor requires a * -> * kind, even though its operations work *fine* on the wrapped [Bar].
21:30:00 <mick__>  http://www.amazon.com/Hackers-Life-Starter-Security-Penetration/dp/149932023X
21:31:42 <kaizoku> again?
21:31:58 <MarcelineVQ> the price of fame
21:32:27 <ski> koz_ : "its operations" ?
21:33:36 <shanemikel> thanks btw.. how could you tell that msg was DMR
21:33:42 <kadoban> koz_: I think you'd actually have a lot of difficulty implementing fmap on Foo, even if the kind system didn't disallow it.
21:33:53 <kadoban> :t fmap
21:33:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:34:28 <kadoban> koz_: It's going to be a little hard actually using any function like that, because you only have Bar, which isn't 'a' and isn't 'b'
21:34:42 <ski> shanemikel : "until I explicitely set the types" and `emptyOr = returnIf' (no explicit parameters to the left of `=')
21:36:13 <shanemikel> that's a funky bug
21:36:25 <ski> what is ?
21:36:28 <kadoban> shanemikel: It's not really a bug
21:36:53 <ski> DMR was by design
21:38:33 * hackagebot publicsuffix 0.20160209 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160209 (wereHamster)
21:39:48 <shanemikel> Idk, it seems like a bug to me.. the tradeoff between repetative computation and breaking type inference as result of a subtle propogation of typeclass design is exactly the type of thing I would describe as a bug
21:40:10 <shanemikel> not that I'm complaining... nice to know that it exists at least
21:41:15 <shanemikel> rather, the implementation of the typeclass design
21:43:54 <shanemikel> so, how much do y'all know about the machinery of haskell? 
21:44:11 <shanemikel> what are the most important things to start with?
21:46:37 <kadoban> shanemikel: http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz is probably a good starting point I think
21:50:43 <levi> Probably start with the Haskell 2010 Report if you haven't read it; then you can dig into GHC-specific stuff like the STG-machine.
21:51:04 <kadoban> Hmm, good point.
21:59:01 <shanemikel> how long did you spend learning/(programming in) haskell before you read through the report? (how long did it take you, how much head-banging?)
22:00:50 <kadoban> The report is relatively easy to read, especially compared to some other language specifications. I probably programmed in haskell for a few months before I actually read the whole thing, but it's not very head-bangy anyway.
22:02:23 * Axman6 hasn't ever read it, at least not in full
22:07:26 <dmj> shanemikel: rewriting Data.List, Control.Monad and the rest of the Prelude helped, learn you a haskell by writing you a haskell. Then going through the typeclassopedia. Comes down to writing it a lot I think
22:13:56 <levi> The Haskell Report is a lot easier to read than the specifiation of C or, heaven forbid, Javascript.
22:15:07 <levi> Maybe not quite as easy as the Scheme spec.
22:20:24 <shanemikel> done a lot of that. not as much with monads, but I've read about them a few times now.. I've finally read about monad transformers today.. my checklist now looks a little like this '[]parsing; []some sort of gui stuff, maybe rp, frp, or specifically keera hails.. or maybe I'll try a basic elm app first; []lisp interpreter or something else involving parsing, maybe learning about BNF first and finding/writing a lib to generate 
22:20:26 <shanemikel> parsers from that; []conduit, or other stream/signal processing combinator lib; []build system stuff (maybe implement some js transform for source maps or something)' not in any particular order
22:21:29 <levi> Reading through a language specification is something you do mainly so you know what's in it and roughly where to find it, so when you are scratching your head over something you know where to look for a definitive answer.
22:22:53 <cads> hi all
22:22:56 <liste> hi cads 
22:24:17 <dmj> hi
22:24:46 * cads wishes there was a better way for a compiler to tell the OS or build environment when it needs a certain external library to proceed
22:25:58 <dmj> cads: use nixpkgs and that won't happen :] 
22:26:05 <cads> ubuntu is pretty good about it - if a compiler says it needs pango, you just search for libpango, and find libpango1.0-dev.
22:26:35 <cads> That works with pango, cairo blas, lapack, gtk...
22:27:53 <shanemikel> cads: I think you should be able to use apt-file on debian/ubuntu to search for the package that provides the right pkgconfig file
22:28:12 <shanemikel> basically the name cabal says you need + the .pc extension
22:28:19 <shanemikel> err not basically, but exactly
22:29:13 <cads> huh, I haven't learned about package config files
22:29:23 <shanemikel> on rhel 'yum provides', and on archlinux 'pkgfile'
22:30:20 <cads> so could I aggregate these files on a dry run of the build, and then certify that I have all of them?
22:31:04 <shanemikel> well, I'm assuming that the same distro package that provides the appropriate pkgconfig file will provide the library
22:31:16 <shanemikel> I think that's true.. in fact, I think that's the point
22:31:23 <cads> also, I wanted to ask what you guys think, as far as ease of dependency management for haskell stuff like ghcjs, what distribution is favored?
22:31:42 <cads> dmj, I've been seriously considering nix
22:32:57 <cads> I built ryan trinkle's try-reflex code using his nix deploy method and it was super fast - I think it used a binary cache of the code, which is amazing.
22:33:43 * hackagebot lit 0.1.10.0 - A simple tool for literate programming  https://hackage.haskell.org/package/lit-0.1.10.0 (cdosborn)
22:33:56 <dmj> cads: I use stack w/ ghcjs now
22:34:05 <dmj> not that using it with nix doesn't work
22:34:17 <dmj> cads: do you use emacs?
22:35:00 <koz_> kadoban: What I mean is that 'fmap g [Bar]
22:35:27 <koz_> ' works fine. However, the Foo wrapper around it makes this impossible to implement, even though it's just 'unwrap, map, rewrap'.
22:35:35 <cads> dmj, I was able to build ghcjs with stack but the ghcjs-boot stage is a monster
22:36:03 <koz_> (for an appropriate g, obv)
22:36:06 <dmj> cads: yea, but that should be true of nix too, even more so (on the first run)
22:37:06 <cads> dmj, seems like try-nix 'cheats' and uses a remote cache of precompiled binaries
22:37:22 <cads> err, I meant try-reflex
22:41:08 <levi> nix uses remote-cached binaries in general when they're available and match up with what you require.
22:45:01 <koz_> Could someone check if my Functor implementation is law-abiding? http://paste.rel4tion.org/243
22:45:10 <koz_> I believe it is, but I may have missed something.
22:47:59 <kadoban> koz_: Looks good to me.
22:48:14 <liste> is anyone here using haskell-vim-now? how do I turn off Unicode symbols?
22:49:13 <koz_> kadoban: OK, good to know. Also, would it make sense for Tape to be an Applicative as well?
22:49:53 <Axman6> it's less clear what an applicative for a list zipper (which is what you have) actually looks like
22:51:04 <cads> dmj, talking to someone in #nixos who explains that you can use a remote binary cache to serve builds of a particular nix expression
22:51:29 <Axman6> koz_: there's at least two ways to implement Applicative for that type, the cartesian product one and the zip based one
22:51:34 <Gurkenglas> koz_, consider "data Tape a = Tape [a] a [a] deriving Functor"
22:52:00 <kadoban> koz_: It seems like it, sure.
22:52:20 <Gurkenglas> I would say the zip based one makes more sense since it (mostly) commutes with jerking
22:52:29 <Axman6> actually, maybe the cartesian product version doesn't make a whole lot of sense
22:52:32 <koz_> Gurkenglas: Can it auto-derive?
22:52:51 <Gurkenglas> @let data Tape a = Tape [a] a [a] deriving Functor
22:52:52 <lambdabot>  .L.hs:170:1:
22:52:52 <lambdabot>      Multiple declarations of ‘Tape’
22:52:52 <lambdabot>      Declared at: .L.hs:165:1
22:53:04 <Gurkenglas> @let data TapeGurk a = TapeGurk [a] a [a] deriving Functor
22:53:06 <lambdabot>  Defined.
22:53:06 <koz_> Axman6: Could you explain a bit more about both of these, or link me to an explanation?
22:53:21 <Gurkenglas> > fmap (+3) $ TapeGurk [5,2] 4 []
22:53:23 <lambdabot>      No instance for (Show (TapeGurk b0))
22:53:23 <lambdabot>        arising from a use of ‘show_M682653581248509202827288’
22:53:23 <lambdabot>      In the expression:
22:53:24 <koz_> Gurkenglas: Do I need to enable any language features for this?
22:53:56 <Gurkenglas> Gah okay I went too long without in-channel errors and stopped testing in query ._.
22:54:24 <MarcelineVQ> hubrisbot
22:54:35 <kadoban> koz_: It's essentially the difference between the Applicative instance for [] and for ZipList, which is a newtype wrapper around []
22:55:02 <Gurkenglas> :t fmap (+3) $ TapeGurk [5,2] 4 [] -- o.o
22:55:03 <lambdabot> Num b => TapeGurk b
22:55:26 <Gurkenglas> koz_, yup, DeriveFunctor
22:55:32 <koz_> Gurkenglas: I see, thanks!
22:56:08 <Gurkenglas> Oh, hey, I didn't derive show.
22:56:54 <Gurkenglas> This no instance for show error turns up so often that you stop thinking it's because the show instance is missing :I
22:57:49 <ski> @let deriving instance Show a => Show (TapeGurk a)
22:57:51 <lambdabot>  Defined.
22:58:10 <ski> > (+3) `fmap` TapeGurk [5,2] 4 []
22:58:11 <lambdabot>  TapeGurk [8,5] 7 []
22:59:40 <koz_> Part 2, Q3 confuses me: https://github.com/quchen/articles/blob/master/write_yourself_a_brainfuck.md - does it mean 'implement Stream'?
23:01:54 <ski> koz_ : define it as a data type
23:02:07 <koz_> ski: Oh, so that's what it's asking me to do.
23:02:45 <dmj> cads: it does, but if you build your pkgs from HEAD odds are it won't be available in the cache
23:04:04 <koz_> ski: Does it want me just to implement a Stream of constant values or something? The question's wording confuses me...
23:04:43 <cads> lol I wish you could distribute compilations in a kind of hybrid distributed compiler/torrent swarm
23:04:48 <ski> yes, "Implement that tape a repeat function for it analogous to Data.List.repeat." doesn't sound like a proper sentence
23:04:56 <ski> koz_ : but i think yes
23:05:27 <koz_> ski: I should put up an issue.
23:06:30 <MarcelineVQ> It wants a type because you use that type in the next part, I totally agree that's not readable
23:07:03 <dmj> cads: heh, sounds interesting
23:07:14 <MarcelineVQ> "Implement that type and a repeat function for it analogous to Data.List.repeat." perhaps
23:07:44 <koz_> MarcelineVQ: I think that's what they meant too, but I wanted to check.
23:07:49 <koz_> Well, I'll just do that then. :)
23:08:45 <cads> dmj, you get into the problem of trusting some random person's compiler to build a section of your final system.
23:10:17 <cads> but if you doubt any node's output you can build it and check on them
23:11:05 <dmj> cads: maybe distribute the evaluation of the dependency graph to other "seeders" in the network known to have your same arch. 
23:11:31 <dmj> cads: you could check based on the hash, like nix does
23:11:55 <cads> does the hash specify the target arch?
23:12:02 <dmj> there is a way to share your machines /nix/store with a network, which is what reflex-dom does
23:12:32 <dmj> er: try-reflex
23:13:48 <dmj> cads: re:hash I don't think so
23:16:48 <Ralith> dmj: nix uses hashes to identify inputs, not validate outputs...
23:17:16 <Ralith> indeed, if you knew the hash of the outputs ahead of time, you probably have a faster way of getting the outputs than computing them from scratch :P
23:17:25 <Ralith> wouldn't be much of a hash otherwise
23:17:37 <koz_> Functions aren't instances of Show and/or Read, right?
23:19:11 <mniip> they can be
23:19:25 <ski> koz_ : function types doesn't have any standard instance for `Show' and `Read', right
23:19:30 <mniip> ^
23:19:49 <koz_> ski: Eq either, it seems.
23:19:57 <ski> one could imagine something like `instance (Bounded a,Enum a,Show a,Show b) => Show (a -> b)'
23:20:04 <ski> koz_ : *nod*
23:20:19 <koz_> ski: I see, thanks.
23:20:20 <dmj> Ralith: right, so maybe nix binary caches should be distributed p2p 
23:20:35 <Ralith> dmj: I just explained why that wouldn't work.
23:21:04 <ski> (or `instance (Compact a,Overt a,Eq b) => Eq (a -> b)', iirc)
23:21:41 <ski> koz_ : the problem is that function equality is undecidable, in general
23:21:49 <Ralith> of course, there's nothing stopping you from creating a torrent tracker for binary packages, but doing it for nix would not be substantially different than doing it for, say, debian
23:22:02 <mniip> it's undecidable if the domain is infinite
23:22:49 <ski> mniip : .. depends
23:25:00 <mniip> oh?
23:25:18 <koz_> ski: Yeah, I figured as much.
23:26:14 <koz_> Also, something's not right with my attempt to make my Stream a Functor: http://paste.rel4tion.org/244
23:26:41 <Gurkenglas> If it's undecidable, the domain is infinite. It's pretty easy to generate an infinite sequence of where it's decidable.
23:27:23 <ski> @where impossible
23:27:23 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
23:27:26 <ski> mniip ^
23:27:40 <Gurkenglas> koz_, your Stream isn't a functor.
23:27:49 <koz_> Gurkenglas: I just realized why.
23:27:57 * koz_ feels a little retarded.
23:28:16 * ski isn't sure what "known area" would refer to
23:28:44 <ski> are you attempting to store a course-of-values recursion (computing the next value from the list of the previous ones) ?
23:28:51 <koz_> ski: Yeah.
23:28:59 <koz_> Like, you could have a stream of Fibonacci numbers or something.
23:29:07 <koz_> Or a stream of factorials.
23:29:08 <Gurkenglas> Why not just store the infinite list then?
23:29:27 <dmj> Ralith: So a torrent tracker would be p2p... not seeing how this wouldn't be possible I guess, also not seeing how this would be the same as debian.
23:29:30 <ski> in that case, you'd need existentials/GADTs to be able to make it a functor
23:29:46 <ski> .. however, there's a much simpler way
23:30:01 <ski> (not involving cov)
23:30:04 <koz_> ski: OK, please enlighten me. I've never written a stream by hand.
23:30:09 <Gurkenglas> ski, how could that possibly be made a functor? It has a in negative position
23:30:26 <Ralith> dmj: you should refer to the nix manual on what it actually does
23:30:38 <ski> Gurkenglas : obviously the type has to be changed a little bit (coyoneda)
23:31:08 <ski> koz_ : can you define your own clone of the list data type ?
23:31:15 <dmj> Ralith: wow thanks :]
23:31:25 <koz_> Gurkenglas: So would that mean that basically I only expose a smart constructor for Stream a la repeat, but the data declaration would be something like 'Stream a = Stream [a]'?
23:31:42 <koz_> ski: Yeah, I basically have an idea of what it'd look like.
23:32:01 <koz_> Gurkenglas: Sorry, *data* Stream a etc.
23:32:04 <ski> .. can you spell it out ?
23:32:39 <ski> (i suppose the abstract data type (implementing a subtype) would also work, yes)
23:32:43 <koz_> data ListClone a = Nil | Cons a (ListClone a) or something? 
23:32:54 <dmj> Ralith: for what it's worth, we're talking about possibilites here, and it is possible to serve your nix-store, http://nixos.org/nix/manual/#ssec-ssh-substituter
23:32:58 <jle`> data List a = Nil | Cons a (List a)
23:33:05 <jle`> can you think of one modification to that you can make
23:33:08 <dmj> Ralith: I'm saying why not serve this over a different protocol, does that make sense?
23:33:09 <jle`> to turn it into a Stream?
23:33:22 <jle`> what's the difference between List and Stream, fundamentally?
23:33:37 <liste> https://hackage.haskell.org/package/Stream-0.4.7.2/docs/Data-Stream.html -- found this
23:33:38 <koz_> Well, no Nil. So it'd be 'data Stream a = Cons a (Stream a)', right?
23:33:42 <ski> yep
23:33:42 <jle`> yup
23:33:46 <ski> that's it :)
23:33:48 <koz_> liste: The whole goal of the exercise is to implement it myself.
23:33:56 <koz_> Also, thanks - I feel fucking retarded now. :P
23:33:56 <jle`> that's the common recursive way of implementing it
23:33:58 <koz_> But enlightened.
23:34:08 <jle`> nah, it's a difficult concept to think of immediately
23:34:15 <liste> koz_ yeah, you just implemented it yourself! (:
23:34:22 <Ralith> dmj: for the same reason your other idea wouldn't: it depends on trusting arbitrary third parties
23:34:36 <koz_> jle`: Well, yeah, that's true. OK, that makes life much easier for me.
23:34:36 <ski> now for `repeat' for streams
23:34:59 <koz_> Well, the type would be something like repeat :: a -> Stream a
23:35:05 * ski nods
23:35:34 <jle`> there's actually another non-recursive way of implementing streams, but we can save that for another day :)
23:35:39 <koz_> repeat x = Cons x (repeat x)
23:35:46 <liste> I've seen Cons referred to as :| too sometimes
23:35:51 <jle`> the recursive one is the one i learned first because it forms such a nice analogy with list
23:36:04 <koz_> I keep forgetting Haskell's lazy.
23:36:11 <ski> koz_ : you can also do it with a `where' (or `let', if you prefer)
23:36:11 <MarcelineVQ> jle`: I am interested in the non-recursive version
23:36:13 <jle`> data Stream a = a :~ Stream a
23:36:21 <jle`> and make sure to infixr 5 :~
23:36:45 <jle`> MarcelineVQ: there's another analogy to list you can follow --- the anamorphism for lists
23:37:10 <jle`> any `[a]` can be represented as a (b, b -> Maybe (a, b))
23:37:11 <koz_> OK ski, I am now interested in how to make a stream type that permits a stream of Fibonacci numbers or factorials.
23:37:28 <dmj> Ralith: sure, doesn't mean it isn't possible though
23:37:45 <Ralith> ...that's exactly what it means
23:37:56 <jle`> MarcelineVQ: so, a (b, b -> Maybe (a, b)) can be thought of as isomorphic to an [a]
23:37:57 <ski> koz_ : define `zipWith' for streams, and you get fibonacci
23:38:34 <jle`> MarcelineVQ: 'b' is the starting generator, and applying the b -> Maybe (a, b) creates an "item" in the list, and the updated/next generator.  if it's Nothing, then that means that the list is done being generated
23:38:57 <jle`> MarcelineVQ: so ... the natural question is, if exists b. (b, b -> Maybe (a, b)) is [a]...what modification can be made to make it Stream a ?
23:38:58 <ski> jle` is reinventing objects
23:39:07 <koz_> ski: I don't follow.
23:40:05 <koz_> jle`: It doesn't ever return Nothing.
23:40:10 <ski> koz_ : have you seen the trick to get an infinite list of fibonacci numbers, using `zip' or `zipWith', efficiently ?
23:40:15 <koz_> ski: Nope.
23:40:28 <ski> koz_ : do you want me to show it ?
23:40:33 <koz_> ski: Or link if you could.
23:40:44 <koz_> quchen: Are you the author of the Brainfuck in Haskell tutorial on GitHub?
23:40:45 * ski doesn't recall one offhand
23:40:48 <koz_> If so, please check your issues.
23:40:58 <MarcelineVQ> jle`: I follow so far I'm just reexamining unfoldr atm so I can determine the last step
23:41:13 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
23:41:14 <quchen> koz_: Maybe, and okay
23:41:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:41:19 <dmj> Ralith: people download stuff all the time on p2p networks where the seeders are from identities unknown
23:41:29 <koz_> ski: That is really cool.
23:41:41 <ski> koz_ : this is "chasing its own tail"
23:41:48 <koz_> These bottomless recursive definitions are a bit hard for me to get used to.
23:42:00 <koz_> I'm coming from eager languages, and that kind of thing is *very* strongly advised against in them.
23:43:13 <ski> koz_ : my "`fibs' reduction trace" in 2014-12-1[56] at <http://lpaste.net/116547> is supposed to show roughly how that would reduce under a sharing regime
23:43:46 <jle`> @let data AnaList a = forall b. AL b (b -> Maybe (a, b))
23:43:48 <lambdabot>  Defined.
23:44:04 <koz_> ski: OK, thanks, will read that.
23:44:18 <koz_> But yeah, now to typeclass instantiate the hell out of my Stream, for practice.
23:44:25 <jle`> @let oneToTen = AL 1 (\i -> if i <= 10 then Just (i, i+1) else Nothing)
23:44:27 <lambdabot>  Defined.
23:44:38 <ski> koz_ : it attempt to be pedantic in showing each step
23:45:02 <jle`> @let alToList al = case al of (AL z f) -> unfoldr f z
23:45:04 <lambdabot>  Defined.
23:45:08 <jle`> > alToList oneToTen
23:45:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:45:20 <koz_> But yeah, that is really, really cool.
23:45:21 <jle`> ^ MarcelineVQ 
23:45:36 <koz_> jle`'s thing too. I guess the way you make it a Stream is make it never give out Nothing?
23:45:48 <koz_> Or rather, giving it a function on construction that never returns a Nothing
23:46:00 <jle`> yes ... and there's a slightly less awkward way to say that
23:46:14 <jle`> what can you call an (a -> Maybe b) that always returns Just?
23:46:15 <koz_> jle`: Which is?
23:46:19 <jle`> how can you encode the always-returns-Just in the type?
23:46:20 <koz_> a -> b ?
23:46:22 <jle`> yes
23:46:43 <koz_> Damn that is clever.
23:47:01 <jle`> i find that the recursive data type way is a bit easier to think about when first talking about this stuff
23:47:10 <jle`> so definitely write typeclass instances for your recursive version
23:47:19 <koz_> jle`: Oh, I plan on it!
23:47:20 <jle`> but in practice, the continuation-based version tends to perform better
23:47:35 <ski> (jle` : fwiw, i think something like `forall o s. (s -> (s -> o) -> (s -> a -> s)) -> o' may be more fusable ..)
23:47:35 <jle`> because GHC can inline things and do better analysis on non-recursive definitions
23:47:40 <koz_> I guess that (other than Eq, Show, Read) anything a list is an instance of, a Stream can be too?
23:48:36 <jle`> keep in mind that the Monad instance for Stream is very unlike the Monad instance for List
23:49:29 <koz_> jle`: Alrighty, I will keep that in mind, but I'll likely need help defining it. At least the simpler ones I can do.
23:50:01 <koz_> I'll give it a try.
23:50:08 <jle`> good luck!
23:50:09 <koz_> This is a helluva learning experience.
23:50:21 <koz_> If I ever have to teach Haskell, I'll put my students through it. :P
23:51:02 <ski> koz_ : "This" being #haskell, or a tutorial ? ;)
23:51:28 <koz_> ski: Both.
23:51:31 <Squarism> Is there a nice "functional" approach on tranforming a list of items {id,parentId,data} into a tree that obays the parent child relations
23:52:30 <pavonia> Squarism: For what type?
23:52:49 <Squarism> data could be anything... say String
23:52:56 <Squarism> id and parentId are integers
23:53:16 <ski> Squarism : i suppose you could try building a map from ID to the (sub)tree rooted at that ID
23:53:17 <koz_> Squarism: Are they necessarily in parent-child order?
23:53:39 <Squarism> no, not in parent child order
23:53:47 <ski> (using this same map to build the trees which you populate the map with, i.e.)
23:54:14 <Squarism> just random order of mentioned tuples
23:54:34 <ski> the first ID in the list is the ID of the root ?
23:54:45 <frerich> Squarism: I think I'd start with defining a function 'insert :: (Id, Id, a) -> Tree a -> Tree a' and then using that to fold the list.
23:54:56 <koz_> ski: Not necessarily - I assume that the root has id = 0 or id = 1 or something.
23:54:59 <koz_> But it won't be first.
23:55:04 <koz_> (if parent-child order isn't assumable)
23:55:07 <echo-area> How is (.) pronounced?
23:55:08 <ski> koz_ : ok, so separately specified, then
23:55:11 <koz_> echo-area: Compose.
23:55:29 <koz_> Or 'composed with', I guess.
23:55:30 <Squarism> i hoped there was a function avaialable just to paste
23:55:31 <echo-area> koz_: So `f . g` is read "f compose g"?
23:55:43 <koz_> echo-area: 'f composed with g' is a bit more natural.
23:55:48 <thimoteus> i say "of"
23:55:53 <ski> echo-area : iirc, i've heard "follows" mentioned
23:56:11 <koz_> thimoteus: When I head 'f of g' I assume f(g), not f . g.
23:56:12 <echo-area> I though it could be read "dot"
23:56:27 <koz_> s/head/hear
23:56:39 <thimoteus> koz_: in my head, i use that for both
23:56:44 <ski> `∘' is the real math symbol
23:57:08 <ski> @let infixr 9 ∘; (∘) = (.)
23:57:11 <lambdabot>  Defined.
23:58:05 <echo-area> ski: I see that Frege code uses math symbols more frequently
23:58:14 <ski> Squarism : if an ID isn't a parent ID, then it's to become a leaf in the tree ?
23:58:33 <Squarism> ski yep
