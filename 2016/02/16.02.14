00:00:49 <Cale> Another cool thing about this approach is that later on, you might replace your DBOps IO record which uses the database with one which e.g. makes requests over the network, or perhaps logs things which are taking place.
00:01:27 <Cale> nocturne777: I don't know if that's clear enough... hopefully you get the idea.
00:02:09 <Cale> Generalising over the choice of monad isn't particularly essential, but it can be cool to get that little bit of bonus type safety when you can sometimes.
00:04:38 <nocturne777> Cale: I get the idea, but this does not compile foo :: Monad m => DBOps m -> m ()
00:05:03 <nocturne777> "Expecting one more argument to ëmí"
00:07:52 <nocturne777> Cale: is it not supposed to be foo :: Monad m => DBOps IO  -> m ()
00:40:09 <bollu> silly question - how do I profile with stack?
00:42:53 <bollu> oh, I got it - http://stackoverflow.com/questions/32123475/profiling-builds-with-stack
00:45:37 <nocturne777> Cale: sorry, it type checks, I was using my previous type by mistake. 
00:48:16 <EvanR> urh
00:48:53 <EvanR> what is the syntax to scope typed variable create a proxy of a type whose variable is in scope
00:49:51 <EvanR> Id -> [eOrV (undefined :: f)], and the error is from the context (i ~ '[f a], j ~ '[f a], EOrV f) could not deduce EOrV f0
00:50:06 <EvanR> i have that code, and its refusing to take my `f' seriously
00:53:00 <EvanR> maybe i have to spell out the type sig in the case pattern
00:57:06 <EvanR> i have the context just let me use the dang instance ;_;
01:10:54 <xkami> does haskell have foldl and foldr functions?
01:14:38 <Xeironis> :t foldl
01:14:39 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
01:14:40 <Xeironis> :t foldr
01:14:41 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:14:46 <Xeironis> ^ xkami
01:14:53 * hackagebot svg-tree 0.4 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.4 (VincentBerthoux)
01:17:47 <xkami> Xeironis: yes, getting help from syncope
01:19:24 <bollu> xkami: you may want foldl' and foldr' (the strict versions)
01:19:35 <bollu> they're better behaved with respect to laziness
01:22:06 <bollu> ReinH, Cale: ping
01:22:14 <xkami> bollu: okay :-)
01:22:46 <bollu> if I have a comonad w, does that automatically guarantee memoization because I can write a Store instance for it?
01:24:22 <bollu> (as in, if I can get a Store, I can in some sense "index" values, correct?)
01:24:33 <bollu> so that automatically gives me "memo for free"?
01:24:43 <bollu> I've been writing cellular automata and I'm getting a 3x slowdown
01:24:52 <Xeironis> hm, stack init seems to be stuck at "Trying with packages from lts-2.22 as hard constraints...". Is that a common problem?
01:44:06 <dmwit> Oh man, the type checker is good. Saved me again from a ridiculous piece of code that probably would have given rise to very weird behavior.
01:44:33 <koz_> dmwit: That's why we love it.
01:44:52 <dmwit> Wrote `type Knowledge = SFunArray SIngredient SWord4` and `mkSFunArray (\singredient -> {- complicated expression here -})`.
01:45:15 <dmwit> Coludn't for the life of me figure out why it was complaining... even when I replaced the complicated expression with the *obviously* correct `0`.
01:45:32 <koz_> dmwit: That type is... what?
01:45:41 <dmwit> That's SBV's type for symbolic arrays.
01:45:49 <koz_> SBV?
01:46:00 <dmwit> And `SIngredient`/`SWord4` are symbolic variants of other types I had in my program.
01:46:16 <dmwit> SBV is an awesome library for interacting with SMT solvers.
01:46:20 <dmwit> ?hackage sbv
01:46:21 <lambdabot> http://hackage.haskell.org/package/sbv
01:46:21 <koz_> Ah, I see.
01:46:54 <dmwit> Anyway, turns out that... I should have written `SFunArray Ingredient Word4` instead.
01:47:06 <dmwit> Because `SFunArray` internally adds the symbolic-ness. 
01:47:15 <koz_> A typographical off-by-one error? :P
01:47:20 <dmwit> Sort of, yeah! =D
01:47:36 <koz_> I've had that happen before, though not with Haskell.
01:48:26 <dmwit> bollu: Not sure about that, so much. Memoization is rarely "free" in Haskell.
01:48:44 <bollu> dmwit: damn, I was hoping a store instance would naturally work out
01:48:51 <dmwit> You generally have to explicitly ask for it (e.g. by writing your function as indexing into a data structure).
01:48:55 <bollu> I need to memoize a finite grid that admits a comonad structure
01:49:01 <bollu> argh
01:49:10 <bollu> I was hoping there would be a library that memoizes stores automagically
01:49:21 <EvanR> theres memo-combinators
01:49:22 <dmwit> There are several memoization libraries on Hackage.
01:50:13 <bollu> I was using memoize (the library
01:50:25 <bollu> wait, let me link to my completely non modular codebase :)
01:51:26 <bollu> here is the part where I'm actually creating the memo instance : https://github.com/bollu/cellularAutomata/blob/master/src/Lib.hs#L152
01:52:12 <bollu> here is where I use it: https://github.com/bollu/cellularAutomata/blob/master/src/GameOfLife.hs#L19
01:52:27 <bollu> getNeighboursMemo uses the memoised versions of the "universe shifting" functions
01:52:35 <bollu> I'm still getting kinda bad performance
01:55:27 <bollu> any ideas on what I'm doing wrong?
02:10:17 <lyxia> bollu: perhaps memoize is simply too inefficient
02:10:27 <bollu> lyxia: hmm, that's a possibility?
02:10:31 <bollu> lyxia: I wish it was easy to profile
02:10:40 <bollu> lyxia: so, well, how do I get more performance?
02:10:48 <bollu> would switching to Data.Vector give me some gains?
02:14:23 <lyxia> fmapping shiftright looks pretty expensive as well
02:15:10 <lyxia> I mean, if you're going to go left and right a lot of times, it builds up huge thunks in places you go rarely
02:16:30 <lyxia> and these shift functions are not something worth memoizing. You spend more time looking it up than doing the shift
02:18:47 <bollu> lyxia: hm yes, you're right
02:18:55 <bollu> lyxia: so what's the right approach?
02:19:29 <bollu> also, if I have a stack environment where I'm building "my" library, and want to run examples (i.e, the examples use my library in the environment), how do I ask stack to execute the haskell file?
02:19:37 <lyxia> Comonad might still be the right tool
02:19:48 <lyxia> every cell needs to carry its context
02:20:11 <bollu> lyxia: right. that I'm sure of
02:20:31 <bollu> lyxia: but I can't take advantage of "super laziness" because I'm simulating a finite grid, so I need to take care of the warping conditions at the boundaries
02:23:00 <bollu> lyxia: do you know of any way to improve performance?
02:23:03 <lyxia> I don't think that's an issue but we'll see...
02:23:27 <lyxia> Univ still has a type variable, what do you instantiate it with at the end of the day?
02:23:48 <lyxia> What's the current type you have for a grid?
02:25:18 <bollu> lyxia: Univ Cell (where Cell = On | Off)
02:25:30 <bollu> lyxia: but it can be more complicated for other cellular automata
02:28:12 <lyxia> Does duplicate replace every cell with its context?
02:29:21 <bollu> lyxia: yes
02:29:24 <bollu> lyxia: has to, right?
02:29:28 <lyxia> I think that's it, your functions should work with Univ (Univ Cell)
02:30:36 <bollu> ooh, so I can exploit the inner structure?
02:31:38 <grayling_> I've got a chain of (Either SomeException a). Is there any way I can lift Either so that I can avoid the case-Left-Right stairs?
02:32:03 <bollu> grayling_: use do-notation?
02:32:18 <lyxia> bollu: I'm not sure what you mean but Univ (Univ Cell) is what I meant by "each cell should carry its context"
02:32:55 <lyxia> or is it...
02:32:59 <grayling_> Hmm. The stairs are already enclosed in do to lift an IO.
02:33:00 <EvanR> grayling_: you probably shouldnt be passing around SomeExceptions
02:33:19 <EvanR> you should be letting them get caught somewhere as normal
02:33:47 <bollu> lyxia: I think I understand what you're saying - I'll try a rewrite and get back to you
02:33:52 <EvanR> instead of try, look at bracket finally and catch
02:33:54 <grayling_> EvanR: Yeah. I am. The problem is that I want to catch them at the top.
02:37:31 <Jedai___> grayling_: That doesn't seem like a problem to me. Rather like the normal use of exceptions.
02:38:34 <grayling_> Yes. Except if you want to pass the exception along for some time.
02:38:45 <EvanR> eh? 
02:38:58 <lyxia> bollu: Oh, with Univ (Univ a), the neighboring Univ a are easy to get, but you still have the issue that you will be recomputing the outermost Univ... I'm not sure how to say that clearly.
02:39:48 <lyxia> bollu: Cofree Univ seems to fit better
02:40:19 <bollu> lyxia: how will Cofree help?
02:40:33 <bollu> lyxia: right, I have a superposition of universes
02:42:02 <grayling_> Say you have a http req and that can produce a number of exceptions. The resp get passed to a number of functions, who all passses the exception along. All the functions handle the exceptions alike. That is Left is very similar. So the question is: Could I avoid all these case-Left-Right stairs where Left doesn't do anything but passing along.
02:42:30 <EvanR> dont catch it there
02:42:59 <EvanR> catch it where you actually want to handle it, instead of passing it around forever
02:44:22 <grayling_> But I have to unwrap it so to speak in all my subfunctions to manipulate and change a.
02:44:55 <EvanR> you wouldnt have to if you werent using Either SomeException for IO exceptions
02:58:32 <lysgaard> I am writing a toy compiler. I would like it to generate portable C-code. Right now I am using the language-c package to generate the C-code, but it is quite unergonomic for my use. I guess this is mostly because C is a complex language, but would anyone by chance know of a lighter alternative to the language-c package?
03:04:24 <bennofs> lysgaard: if you're willing to go much more lower-level, perhaps generating llvm IR would be a better alternative? (llvm IR is kind of portable assembly, afaik)
03:06:53 <lysgaard> bennofs: It has crossed my mind, but my language is a DSL supposed to be used with existing C-projects, so I would like to generate C-code.
03:07:21 <zipper> Hey, how long does it take for haddocks to build on hackage?
03:09:57 * hackagebot resourcet 1.1.7.2 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.7.2 (MichaelSnoyman)
03:26:40 <grayling_> EvanR: Excellent suggestion. I removed my try at the bottom of the stair. And am no longer using Either SomeExceptions for IO exceptions.
03:27:21 <grayling_> EvanR: Sometimes a problem can make you blind of the obvious.
03:32:25 <fr33domlover> Is there a way to syntax-highlight config/models and config/routes in yesod apps (at least when editing with vim)?
03:53:51 <hexagoxel> grayling_: if you ever encounter this with a non-IO monad, EitherT should be able to remove the stairs.
04:14:51 <Xeironis> just installed lens and saw "compiling Main". Why does lens have a Main module?
04:16:00 <deepfire> Xeironis: is it a test?
04:16:20 <bollu> how do I install a package into stack's sandbox?
04:16:24 <bollu> not globally
04:16:51 <Xeironis> deepfire: that's possible
04:18:14 <Xeironis> ugh, actually, cabal is stuck at Linking this Main module for some reason :/
04:20:00 * hackagebot conduit 1.2.6.2 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6.2 (MichaelSnoyman)
04:25:05 * hackagebot conduit-extra 1.1.9.3 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.9.3 (MichaelSnoyman)
04:28:05 <bollu> if I have a library and examples in stack
04:28:11 <bollu> how do I compile the library in my sandbox
04:28:17 <bollu> so that the examples have access to the library?
04:28:32 <bollu> (I want this to happen inside the sandbox)
04:35:08 * hackagebot svg-tree 0.4.1 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.4.1 (VincentBerthoux)
04:45:09 * hackagebot rasterific-svg 0.3 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.3 (VincentBerthoux)
04:49:01 <Fuco> how can I destructure nested data, e.g. data A = A { b :: B }, data B = B { c :: String, d :: Int }, I want to do something like function (A { b { c = c } = b }) = ...  Does it make sense?
04:49:50 <bennofs> Fuco: I think it's 'function (A { b = B { c = c, d = d } }) 
04:51:31 <Fuco> I think the thing before the = is what I bind to, and the thing after = is the accessor
04:51:34 <Fuco> so I can't use the class there
04:54:17 <pavonia> It's { fieldname = pattern }
04:55:16 <Fuco> hmm... yes of course
04:55:24 <Fuco> funny I used this for years and never really thought about it :D
05:14:33 <haskell658> hi every one
05:20:10 * hackagebot wai-devel 0.0.0.3 - A web server for the development of WAI compliant web applications.  https://hackage.haskell.org/package/wai-devel-0.0.0.3 (urbanslug)
05:29:37 <Guest48981> hi there. Can one use an empty type with existetial constraint?
05:32:35 <Guest48981> http://lpaste.net/152441
05:37:48 <mniip> Guest48981, as a GADT
05:38:14 <mniip> but to me it sounds like you just want instance PeanoClass n => PeanoClass (Succ n)
05:38:43 <mniip> oh wait no, not even GADTs can help with that
05:39:01 <Guest48981> mniip, yes, it is that, but wanted to avoid DataContext as it seems a misfeature...
05:39:26 <mniip> you don't need to impose any context on the data
05:40:03 <Guest48981> with datacontext I might write: data (PeanoClass n) => Succ n
05:40:10 * hackagebot secp256k1 0.4.4 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-0.4.4 (xenog)
05:40:20 <mniip> why do you think you need that?
05:41:48 <Guest48981> normally I wouldn't expose those low level things, but I liked the idea of conveying more information to the compiler, because in effect, in order to construct Succ n, n must be in PeanoClass, otherwise Succ Int would be just as fine
05:42:38 <obadz> so I have MyMonadT that's a newtype around some stack of StateT/ReaderT/whatever..
05:42:51 <obadz> and MyMonad that MyMonadT Identity
05:43:49 <obadz> all the functions that I expose (that don't require any specific monad in the stack) should have signature Monad m => MyMonadT m a, right?
05:43:51 <Guest48981> mniip I understood your point, just wondering if could could get better and say: Succ n is to be contructed only if n is in PeanoClass
05:43:59 <mniip> "Constructed"
05:44:04 <mniip> you have no constructors
05:44:18 <Guest48981> Succ
05:44:25 <obadz> Is there anyway to write them to have signature MyMonad a and use them in MyMonadT where m != Identity (without using MFunctor)
05:44:29 <mniip> that's a type constructors
05:44:30 <Guest48981> as a type constructor
05:44:44 <mniip> you can't impose constraints on that
05:45:09 <obadz> the type signature Monad m => MyMonadT m a on every function is a bit ugly..
05:45:14 <Guest48981> i thought forall n . PeanoClass n
05:45:29 <mniip> that only applies to data constructors
05:45:46 <Guest48981> but I would be forced to use a full definition with '=', loosing emptyness in the type
05:45:55 <mniip> @let data Num a => Foo a = Foo a
05:45:55 <lambdabot>  .L.hs:146:6:
05:45:56 <lambdabot>      Illegal datatype context (use DatatypeContexts): Num a =>
05:45:59 <mniip> aw
05:46:41 <mniip> anyway, if you were to do that,
05:46:44 <mniip> nothing prevents you from:
05:46:49 <mniip> > :t undefined :: Foo String
05:46:49 <mniip> Foo String
05:46:50 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
05:47:24 <mniip> you really want an instance constraint instead
05:47:40 <Guest48981> well, I'm glad you got the point so well!! :)
05:48:11 <Guest48981> but it's just a question i wondered one could anwer outside datacontexts
05:49:48 <Guest48981> thanks! really!!
05:53:18 <Wizek> Is it possible for two different datatypes to reference each other in different modules without GHC saying 'Module imports form a cycle'? Or is the solution to this to put them in the same module?
05:54:27 <davean> Wizek: there is a way, but its rather annoying and complicated
05:54:43 <mauke> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#mutual-recursion
05:54:46 <davean> Wizek: is there a strong reason you can't put them together, or avoid it by paramaterizing one by the other?
05:55:20 <davean> Wizek: I've never encountered a pair, that on further examination, actually required it in the end
05:59:04 <obadz> anyway to have this be autogenerated? instance MonadIO m => MonadIO (GraphT m) where liftIO = lift . liftIO
06:09:13 <pavonia> obadz: Have you tried with a standalone deriving clause?
06:11:17 <obadz> pavonia: that works!
06:11:38 <obadz> shouldn't something like this be legal? => instance (MonadIO m, MonadTrans t) => MonadIO (t m) where liftIO = lift . liftIO
06:53:55 <lwm> can anyone please tell me how to get `stack test` to rebuild everything from scratch ... I keep makeing changes and have to run `stack ghci` then `stack test` to get them picked up
06:54:18 <lwm> I tried --reconfigure flag, but not luck ... also --file-watch
06:59:42 <sbrg> lwm: `test` is synonymous to `build --test` and build takes a `--force-dirty` which may do what you want.
07:00:13 * hackagebot judy 0.2.4 - Fast, scalable, mutable dynamic arrays, maps and hashes  https://hackage.haskell.org/package/judy-0.2.4 (MarkWotton)
07:00:32 <lwm> ah, I found that `force-dirty` flag, but it still isn't doing what I want
07:00:48 <lwm> oh, I needed to list my files in the `other-modules` in the cabal file ... doh
07:00:58 <lwm> thanks though sbrg
07:07:48 <Jinxit> is it possible to have a list of a certain typeclass? like [Num]
07:08:03 <Jinxit> (which could then contain Int, Real, etc)
07:09:11 <sbrg> Jinxit: foo :: Num a => [a]
07:09:15 <mauke> not directly, no
07:09:29 <sbrg> but you can only instantiate `a` to a single type. so it can't be a heterogenous list, if that's what you're looking for
07:09:59 <Jinxit> yeah I am
07:10:15 <mauke> Jinxit: if you had such a list, what would you do with it?
07:10:28 <sbrg> Jinxit: then you can do something like data Foo = IntThing Int | FloatThing Float | DoubleThing Double
07:10:34 <sbrg> and then have a list [Foo]
07:10:35 <Jinxit> only do operations that are available for the typeclass on it
07:10:42 <mauke> Jinxit: such as?
07:10:59 <mauke> I mean, there's negate
07:11:05 <mauke> how is that useful?
07:11:18 <Jinxit> Num was only an example
07:36:35 <Ainieco> hello
07:36:48 <Ranjit> Hi
07:37:07 <Ranjit> nice to meet u.
07:37:39 <Ranjit> Recently i started learning about Functional Programming
07:38:51 <mniip> cool
07:39:06 <Sornaensis> Ranjit: can u drive me to McClaren's
07:40:21 <Ranjit> @Sornaensis. Sorry what u r saying.? Who is that McClaren's
07:40:22 <lambdabot> Unknown command, try @list
07:41:53 <Sornaensis> it was a pop culture reference/joke about the long running television sitcom series ''How I Met Your Mother'' (2 more messages)
07:44:33 <Gurkenglas> The "(2 more messages)" part presumably was a reference to similar things irc bots say at the end of some lines, because you asked using a line starting with @, which often stands for commands given to irc bots, and because the rest of his line looked like a database lookup of the sort that some irc bots do.
07:49:25 <qubitnerd> @Sornaensis more
07:49:25 <lambdabot> Unknown command, try @list
07:51:58 <xv2> giving QuickPlot a spin
07:53:14 <xv2> anyone use inline-c much?
07:59:52 <zygentoma> Hi, is there a function, that does ((a -> b), (c -> d)) -> (a, c) -> (b, d) ?
08:01:54 <Maplicant> f f1 f2 (a, c) = (f1 a, f2 c)
08:02:07 <liste> zygentoma: there's *** and uncurry
08:02:14 <liste> :t (***)
08:02:15 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:02:25 <Gurkenglas> :t [bimap, (***)] :: [(a -> b) -> (c -> d) -> (a, c) -> (b, d)]
08:02:26 <lambdabot> [(a -> b) -> (c -> d) -> (a, c) -> (b, d)]
08:03:02 <Gurkenglas> :t [bimap, (***)] -- In fact, that's the intersection of their types :D
08:03:03 <lambdabot> [(a -> b) -> (c -> d) -> (a, c) -> (b, d)]
08:03:56 <zygentoma> ah, nice, thanks!
08:05:08 <aspidites> has anyone gotten ghcjs + stack to play nicely together recently
08:05:23 <aspidites> I stuck with an error like this: https://github.com/commercialhaskell/stack/issues/1252 which isn't resolved by the solution proposed
08:05:28 <aspidites> or i don't understand the solution...
08:07:33 <bergey> I had it working a month ago, but not in the last few weeks.
08:07:43 <bergey> I haven't yet tried using an older nodejs, per https://github.com/ghcjs/ghcjs/issues/453
08:08:10 <bergey> I also don't understand the resolution of the issue you linked.
08:09:31 <aspidites> thanks bergey I've installed the exact version of node suggested in #453 which got me past another error, and now i'm stuck :-\
08:09:43 <Ainieco> could you please give me a hint on bind impl of Monad [] instance? can't quite a make a sense out of m a -> (a -> m b) -> m b for [] specifically, it's like map but not really
08:09:56 <zygentoma> ok, follow up question, i'm doing the above in the IO monad, do I have to care for not both functions being called if I do 'fst $ (a,b)' where a and b :: IO ()
08:10:30 <aspidites> I was originally setting out to try reflex, but reflex-platform fails to install because of a bug in nix that seems to only manifest on certain distros
08:10:38 <liste> Ainieco: hint: it has `map' in its name
08:11:02 <mniip> Ainieco, you mean you can't figure out [a] -> (a -> [b]) -> [b]
08:11:03 <mniip> ?
08:11:20 <aspidites> anachrome: you can think of it as replacing the cryptic [] with List - that is, it's just a type constructor, as mniip shows
08:11:25 <bergey> aspidites: Fair enough.  Let us know in #ghcjs if you sort it out, please?
08:11:51 <mniip> aspidites, do you mean Ainieco :P
08:12:20 <aspidites> yes, sorry
08:12:50 <aspidites> bergey: i'm not sure i'll spend too much more time on it - i switched from cabal to stack so that this kind of thing *wasn't* a pain
08:13:20 <bergey> aspidites: Yes, I've been using try-reflex.  Which issue # are you hitting?
08:13:35 <Ainieco> mniip: yeah, it's not a map
08:13:50 <mniip> what on earth could it be then? :p
08:14:41 <Ainieco> mniip: i don't know, that's why i'm asking :) "bind xs f = map f xs" won't compile because f is (a -> m b) and not (a -> b)
08:14:47 <liste> Ainieco: it's a map combined with something else
08:14:55 <mniip> Ainieco, maybe try thinking in terms of join?
08:15:02 <mniip> join :: Monad m => m (m a) -> m a
08:15:27 <mniip> f >>= k = join (fmap f k)
08:15:42 <aspidites> bergey: something to do with locales -- like anything but C would fail
08:15:53 <aspidites> and it looks like they fixed it within the last week, which is when I last tried
08:16:13 <aspidites> go figure
08:16:36 <Ainieco> mniip: liste hm i think i understand now - bind for lists should map and then flatten list, right?
08:16:43 <mniip> bingo
08:17:17 <aspidites> bergey: it was this upstream issue: https://github.com/NixOS/nix/issues/599
08:17:52 <aspidites> I'm assuming that for now reflex-platform is just copying over the archive
08:21:20 <Ainieco> mniip: seems weird to me, why would you do that unnecessary action(flattening) if you can avoid that and you map/fmap right away, looks like Monad [] instance isn't good for actual use 
08:21:35 <mniip> sure is
08:21:49 <mniip> what if your actions produces multiple results
08:21:56 <liste> or no results at all
08:22:32 <mniip> > [1..5] >>= enumFromTo 1
08:22:32 <liste> > [1,2,3,4,5]¬†>>= \x -> if x > 3 then [x] else []
08:22:33 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
08:22:34 <lambdabot>  [4,5]
08:23:01 <Ainieco> oh, i think i understand, thank you!
08:23:13 <liste> Ainieco: you're welcome (:
08:25:41 <bergey> aspidites: but the workaround at https://github.com/reflex-frp/reflex-platform/issues/51 doesn't work?
08:25:53 <bergey> It may take a while for the nixpkgs change to get into reflex-platform.
08:26:23 <Xeironis> Not in scope: Exts.coerce'
08:26:25 <Xeironis> Perhaps you meant `Exts.coerce' (imported from GHC.Exts)
08:26:27 <Xeironis> how can this happen?
08:27:02 <Xeironis> oohh
08:27:04 <Xeironis> I didn't see the prime
08:30:27 <aspidites> bergey: not sure, I don't thing I ever ended up at that page
08:30:49 <aspidites> that said, it's working now, so I assume someone integrated the work around into reflex-platform, which is fine by me
08:35:28 <zygentoma> Hm, in the Maybe-Monad, I go on until i get Nothing somewhere. Can I somehow get the opposite behaviour? Calling functions until I receive a Just?
08:36:29 <puregreen> zygentoma: you can use Either for that (calling functions until you receive a Left)
08:36:57 <puregreen> zygentoma: if you just want to combine several Maybes and take the 1st Just, use ‚Äúasum‚Äù or <|>
08:37:21 <aspidites> except Left is usually your error case
08:37:26 <zygentoma> :t <|>
08:37:27 <lambdabot> parse error on input ‚Äò<|>‚Äô
08:37:34 <zygentoma> :t (<|>)
08:37:35 <lambdabot> Alternative f => f a -> f a -> f a
08:38:00 <mniip> :t asum
08:38:01 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
08:38:05 <mniip> oh that's new
08:38:15 * puregreen wishes it was called ‚Äúchoice‚Äù
08:38:35 <mniip> well it's only choice in nondeterminism monads
08:38:40 <zygentoma> :t asum
08:38:41 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
08:38:43 <mniip> although on a second thought are there any other
08:39:09 <zygentoma> oh, hehe :)
08:39:41 <aspidites> :i Alternative
08:39:45 <mniip> I like this function in particular
08:39:49 <mniip> :t foldr (<|>) empty
08:39:50 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
08:39:54 <mniip> errr
08:39:58 <mniip> :t foldr ((<|>) . pure) empty
08:39:59 <lambdabot> (Foldable t, Alternative f) => t a -> f a
08:41:04 <aspidites> oh well. Just wanted to confirm that t (f a) -> f a was due to the Monoid instance provided for the f, which does seem to be the case
08:42:09 <mniip> that's no monoid
08:42:13 <mniip> it's an alternative
08:42:53 <scshunt> an alternative is a monoid
08:45:00 <aspidites> specificially, Alternative -> Applicative -> Monoid
08:45:11 <aspidites> (:info Alternative, etc)
08:45:30 <scshunt> eh? Applicatives are not monoids
08:45:44 <scshunt> An alternative is a monoid and an applicative
08:50:31 <aspidites> I wasn't meaning to say (by way of ->) that the left is an instance of the right, but rather that the left in some way relies on the existence of the right
08:51:11 <aspidites> class Applicative f => Alternative f where... 
08:51:37 <aspidites> oh I see what you mean now. I read the info for Applicative wrong
08:52:01 <aspidites> it just relies on functor, my bad
08:55:18 * hackagebot kicad-data 0.3.0.0 - Parser and writer for KiCad files.  https://hackage.haskell.org/package/kicad-data-0.3.0.0 (kasbah)
09:00:19 <lynn> When should I use an operator as a data type constructor, as opposed to a word?
09:01:27 <lynn> I'm writing an UnorderedPair data type, but I dunno whether I should go for "data UnorderedPair a = UnorderedPair a a" vs. "data UnorderedPair a = a :*: a" or something like that
09:03:16 <ggole> Words by default
09:04:56 <c_wraith> lynn: Really, you should only use operators when you expect to be chaining them inline a lot.
09:06:20 <lynn> I see. Also: I'm surprised this type doesn't exist anywhere yet
09:06:47 <lynn> I bet either it does, or there's some obvious problem with its definition that I'm not seeing... These instance definitions I'm writing do feel a bit odd
09:06:49 <monochrom> it exists in the haskell wikibook
09:07:13 <lynn> https://bpaste.net/show/22c42d69f608
09:08:27 <EvanR> what is unordered about x :*: x ;)
09:08:33 * geekosaur would guess the main thing the instances are telling you is that Haskell's type system isn't quite up to helping you with it
09:09:06 <lynn> geekosaur: Yeah, that's the thing. :< Everything seems to work, though!
09:12:12 <lynn> Should I call this module "Data.UnorderedPair"?
09:13:03 <lynn> That seems so official. ^^;
09:14:24 <c_wraith> That's not even a type constructor you can chain inline.  I wouldn't use an operator for it. :)
09:19:46 <xv2> what's canonical way of making an infinite list of a constant?
09:20:27 <lynn> > repeat 3
09:20:28 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
09:20:39 <Jinxit> > [3..]
09:20:41 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
09:20:43 <Jinxit> :(
09:21:04 <lynn> > [3,3..] -- this might work? But repeat is way more canonical. It's in Prelude.
09:21:06 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
09:21:23 <xv2> ... klunking around with more hmatrix numerical computin' today
09:23:15 <zygentoma> what does it mean, when my program just outputs <<loop>>
09:23:36 <puregreen> c_wraith: I wonder whether any language has an ‚Äúinfixbinary‚Äù fixity that would group something like a <> b <> c <> d <> e <> f into ((a <> b) <> c) <> ((d <> e) <> f)
09:24:21 <c_wraith> zygentoma: it means somewhere in the program, it determined that evaluating a particular expression depends on the result of evaluating that expression.
09:24:22 <puregreen> and then :*: would be ‚Äúinfixbalanced‚Äù fixity that fails with a compilation error until the value repeats 2^n times
09:24:30 <puregreen> ...this is probably useless for any purpose, isn't it
09:24:31 <c_wraith> zygentoma: something like "let xs = tail xs"
09:24:37 <geekosaur> zygentoma, it means that your program tried to evaluate something and the first thing it did was try to re-evaluate that something again
09:25:03 <c_wraith> zygentoma: the most likely cause is a typo creating accidental value recursion.
09:26:37 <zygentoma> thank you all!
09:26:40 <geekosaur> or forgetting that let is recursive -- `let x = 5 in ... let x = x + 2 in ...` but in the second 'let', both 'x's are the same x and different from the one in the first 'let'
09:27:05 <zygentoma> was using the same name for a parameter and result in a function call
09:27:29 <c_wraith> zygentoma: compiling with -Wall will make ghc warn you when you shadow a value like that.
09:34:39 <adas> how come `data Bleh = Bleh { count :: Int }` is valid but not `data Bleh = Bleh somefield { count :: Int }`?
09:34:59 <adas> For the second version I get `illegal record syntax` error
09:35:31 <hpc> somefield is not a record field
09:35:35 <hpc> data syntax goes either
09:35:57 <hpc> data TypeName [optional type vars] = Constructor TypeOfParameter TypeOfParameter ...
09:36:03 <lynn> Sadly, it's all-or-nothing with naming record fields. :(
09:36:10 <hpc> or the record syntax is Constructor {fieldName :: FieldType}
09:37:04 <adas> ah okay. 
09:37:21 <lynn> (And then if you define a throwaway fieldName, but don't use it, `ghc -Wall` will complain. Grrr.)
09:42:04 <monochrom> that is probably a non-problem in large projects. you're going to either export the field name or use it internally.
09:44:16 <Ainieco> could you please give me a hint on how to create bind(Monad instance) function for "newtype Gen a = Gen { getState :: Seed -> (a, Seed) }" ? i don't understand how to deconstruct it
09:44:23 <Ainieco> context - https://mightybyte.github.io/monad-challenges/pages/ex4-4.html
09:45:14 <lynn> What have you tried so far?
09:46:08 <Ainieco> lynn: im not sure where to start, i've made a return as "return a = Gen { getState = \seed -> (a, seed) }" but completely stuck on bind
09:46:19 <Ainieco> lynn: if you were talking to me
09:46:30 <lynn> Yep. That one looks correct!
09:46:59 <lynn> (In my experience, if it typechecks, there's a good chance it's correct. ^^)
09:47:25 <mniip> fun = undefined
09:48:03 <lynn> Ainieco: What should the type signature for your `bind` implementation look like?
09:50:30 <Jinxit> is it possible to represent matrix dimensions in haskell's type system, or do you need dependent types for that?
09:50:42 <EvanR> it is possible!
09:51:04 <EvanR> matrix dimensions are type level natural numbers, so good
09:51:09 <EvanR> haskell can do that
09:51:30 <Jinxit> know of any libraries that make use of this?
09:51:42 <EvanR> ive only heard of hmatrix
09:51:55 <Ainieco> lynn: m a -> (a -> m b) -> m b
09:51:59 <Jinxit> I'll take a look
09:52:01 <Jinxit> thanks
09:52:06 <mniip> Ainieco, where m is
09:53:47 <Ainieco> mniip: Monad m
09:53:54 <mniip> no?
09:54:03 <mniip> m is your 'Gen' type
09:54:08 <mniip> for which you're defining the instance
09:54:32 <Ainieco> mniip: ah, yeah, i thought you were asking about context, sorry
09:57:04 <Ainieco> mniip: but i don't understand how to take out "a" from Gen and apply function to it since its only field is a function
09:57:37 <mniip> so, uh, what does the type signature look like
09:57:46 <mniip> Gen a -> (a -> Gen b) -> Gen b
09:57:47 <mniip> right
09:58:06 <Ainieco> yup
09:58:18 <rmrfroot> can someone recommend a suitable beginners book on discrete math for a programmer? learning haskell has made me interested in learning more about the math behind it. is something like "concrete mathematics" by knuth a good choice?
09:58:30 <lynn> You can write: bind (Gen {getState = f}) g = ...
09:58:41 <lynn> To extract the getState from the first argument.
10:00:20 * hackagebot monoid-extras 0.4.0.4 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.0.4 (bergey)
10:02:27 <pkmx> Is there a good way to bind additional variables in pattern synonyms?
10:03:47 <pkmx> Something like: pattern P x y <- x where y = x + 1
10:04:05 <pkmx> View patterns work but it gets ugly fast :(
10:05:20 * hackagebot dual-tree 0.2.0.9 - Rose trees with cached and accumulating monoidal annotations  https://hackage.haskell.org/package/dual-tree-0.2.0.9 (bergey)
10:05:34 <Guest00000> where can i find source code for ContT? (hackage page doesn't have "Source" link for it, module reexports it from other module which i can't see)
10:06:57 <hpc> newtype ContT r m a = ContT {runContT :: (a -> m r) -> m r}
10:07:21 <hpc> you can derive it from the documentation, newtypes are very simple
10:07:39 <Guest00000> i want to look at the Monad instance
10:07:41 <hpc> it's reexported from transformers
10:07:42 <hpc> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Cont.html#v:ContT
10:07:58 <Guest00000> thanks
10:08:03 <hexagoxel> does a function of type `Tagged a b -> (Proxy a -> r) -> r` make sense, and is it already present somewhere in Data.Tagged's interface?
10:08:12 <Ainieco> lynn: well, that's cool but how can i get "a" from it? i don't understand
10:08:59 <lynn> Ainieco: You will pass it a Seed, at some point in your implementation. Do you know about "typed holes"?
10:10:11 <Ainieco> lynn: yeah, but where can i get that seed if "bind" doesn't accept it as argument?
10:10:21 * hackagebot diagrams-solve 0.1.0.1 - Pure Haskell solver routines used by diagrams  https://hackage.haskell.org/package/diagrams-solve-0.1.0.1 (bergey)
10:12:06 <hpc> Ainieco: the mere act of having a (Gen a) is enough
10:14:49 <hpc> Ainieco: when you run the Gen action, you provide an initial seed, and it gets carried through
10:14:59 <Guest3049> How can I create SDL.Surfaces from JuicyPixels.Image? I don't understand how to build a 'IOVector Word8' required for 'createRGBSurfaceFrom' in SDL.Video.Renderer.
10:15:36 <hpc> the definition of Gen is roughly "given i already have a seed, how do i get a thing of type 'a' plus a new seed"
10:18:22 <Ainieco> hpc: hm, but i have to return (Gen b) from bind and i think that means that i have to apply function to "a" within Gen, is it correct?
10:19:03 <hpc> no
10:19:12 <hpc> a Gen value stores a function
10:19:22 <Ainieco> hpc: yup
10:19:23 <hpc> when you apply a value to a function, you don't have a function anymore
10:19:40 <hpc> so you need to compose the functions
10:19:50 <KaneTW> anyone here who did some larger projects with yesod? i have some questions regarding keeping splitting the project into subsites
10:20:45 <hpc> which is to say, \seed -> f (snd (g seed))
10:25:37 <Ainieco> hpc: sorry, i still don't understnd where is \seed will come from? i don't see a place for seed in "m a -> (a -> m b) -> m b" as i understand bind takes "Gen a", "f" and applies f to a within Gen
10:26:01 <Ainieco> bind can't return lambda because it should return Gen
10:26:06 <Ainieco> and Gen is newtype
10:34:20 <John[Lisbeth]> why doesn't this compile:
10:34:59 <KaneTW> (preemptivel: don't paste code here, use a pastebin please)
10:35:08 <monochrom> Ainieco: have you considered "Gen (lambda expression here)"?
10:35:16 <John[Lisbeth]> let defecho "let echo options args ending = \"echo\" ++ \" \" ++ options ++ args ++ \" \" ++ ending ++ \" \""
10:35:51 <geekosaur> are you missing a =?
10:36:08 <monochrom> why are there so many quotes?
10:36:12 <geekosaur> either that or an implementation (and a rather long pattern)
10:36:22 <John[Lisbeth]> let defecho = "let echo options args ending = \"echo\" ++ \" \" ++ options ++ args ++ \" \" ++ ending ++ \" \""
10:36:48 <nocturne777> Cale: I am seriously thinking about using that monad-transformerless approach you suggested. But on the other hand everything has a lifted version out there, I don't know how much this approach is going to buy me
10:36:49 <KaneTW> works for me
10:37:34 <Cale> nocturne777: Sorry, what do you mean about lifted versions?
10:38:15 <nocturne777> Cale: Control-Exception-Lifted, Control.Concurrent.Async.Lifted, etc
10:38:19 <geekosaur> John[Lisbeth], I think we need more contxt, plus an actual error message
10:38:22 <farnoy> anyone knows what could cause such a jump in GC time from -N3 to -N4? https://gist.github.com/farnoy/a40f7cd64c9ccb8630ae
10:38:35 <John[Lisbeth]> geekosaur: it's solved
10:39:02 <nocturne777> I guess one could argue that by simply looking at the type signature of a function one could tell that the function won't do anything beyond DB specific IO
10:39:10 <nocturne777> as it affords finer granularity
10:39:19 <Cale> nocturne777: Oh, MonadBaseControl shenanigans
10:39:19 <`Guest00000> Guest3049: to createRGBSurfaceFrom pixel data, you also need to specify the pixel format for it. it must correspond to pixel format of your Image (if you don't try to convert)
10:39:59 <EvanR> all your MonadBase are belong to us
10:40:16 <Cale> nocturne777: I tend to think of MonadBaseControl as a last ditch effort rather than something you'd choose to design into things.
10:40:22 * hackagebot diagrams-lib 1.3.1.0 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.1.0 (bergey)
10:40:24 * hackagebot palette 0.1.0.3 - Utilities for choosing and creating color schemes.  https://hackage.haskell.org/package/palette-0.1.0.3 (bergey)
10:44:35 <`Guest00000> Guest3049: note that some pixel formats may be not supported by both SDL2 and JuicyPixels
10:44:36 <Xeironis> Apparently ghci is giving me a type error because the version of containers in a compiled package is older than the version of containers ghci has loaded. Is there something I can do about that?
10:45:17 <Ainieco> mniip, hpc, lynn, monochrom: oh, figured it out, thank you! (need to get some sleep, getting dumber every minute)
10:45:49 <mniip> sleep is important
10:46:03 <Cale> Xeironis: This is presumably not in a sandbox of any sort?
10:46:12 <Xeironis> no, it's not
10:47:37 <Cale> Let's see, I suppose you want to start off with "ghc-pkg check" to see if you have any broken packages.
10:47:56 <Cale> ghc-pkg list containers  will show you which versions of containers you have installed.
10:48:23 <Cale> I think you usually want to stick with the version of containers that comes with GHC, but there are various reasons why it might've needed to install a newer one.
10:48:37 <Xeironis> alright, I do have two versions of containers installed
10:50:14 <Xeironis> can I just hide the new one? Or should I expect that to cause a lot of problems?
10:50:54 <Xeironis> ah, I suppose I could just hide it for the ghci session
10:51:10 <Cale> You could... With something like containers, I would tend to want to uninstall it, and figure out why the other packages which caused it to be installed did that, but this is a hassle.
10:51:26 <Cale> Just hiding it might help for now anyway.
10:51:26 <Xeironis> alright
10:51:47 <Xeironis> I'll probably end up doing that, it's a pretty new installation, so it shouldn't take too much effort
10:51:49 <Xeironis> thanks for your help
10:52:07 <`Guest00000> Guest3049: you can turn (Image a) to an IOVector with ( thaw . imageData :: Image a -> IO (IOVector (PixelBaseComponent a)) )
10:53:08 <`Guest00000> Guest3049: but, if (PixelBaseComponent a) isn't Word8, you won't get (IOVector Word8)
10:57:35 <Guest3049> ok thanks, that compiles. I just use JuicyPixels convertRGBA8 to ensure it being Word8. Let's hope this works :)
10:58:05 <`Guest00000> Guest3049: compiles, but do you get the right picture? colors may be off
11:02:09 <Guest3049> Actually the picture looks nothing like what I excpected :(
11:03:16 <`Guest00000> how does it look?
11:04:22 <`Guest00000> what PixelFormat did you pass to createRGBSurfaceFrom?
11:04:45 <`Guest00000> try ABGR8888
11:05:03 <`Guest00000> or other, RGBA8888
11:05:36 <Guest3049> does it have a pixel format argument?
11:06:00 <`Guest00000> ah wait it doesn't
11:06:34 <Guest3049> it seems like every third line gets decoded, the rest is invisible
11:07:13 <`Guest00000> show me how you call createRGBSurfaceFrom please
11:09:13 <Guest3049> http://pastebin.com/nRCGmnLc
11:09:55 <NemesisD> hi guys. i wrote some bindings to a c library for LZF decoding https://github.com/MichaelXavier/lzf-bytestring/blob/master/src/Codec/Compression/LZF.hs  i use ByteString.useAsCStringLen and allocaBytes but these are all in IO and I'd prefer them not to be. Could someone help me determine why these are in IO and if it would be ok to use unsafeperformio?
11:10:00 <Guest3049> sry, and missing: mask = Lin.V4 0xff000000 0x00ff0000 0x0000ff00 0x000000ff
11:10:01 <Guest3049>  
11:11:00 <NemesisD> essentially, the C library in both compress/decompress requires you to preallocate a CString buffer and pass it in to get filled. the function itself seems like it should be referentially transparent though as all the input comes from the input bytestring
11:11:31 <geekosaur> NemesisD, allocaBytes would be expected to be in IO sine it's allocating "pinned" memory. and both of those are intended for use with the FFI which is in IO.
11:11:46 <Guest3049> sry, I fucked up. This is not the compiling version. New paste: http://pastebin.com/yZZHDvy7
11:11:56 <NemesisD> the only other possibly dicy thing is i have to use getErrno in one place. that appears to be thread-local so i would imagine this would be safe as long as my function is called without context switching on the same thread
11:11:58 <geekosaur> and unsafeLocalState is there for FFI operations that are known to actually be pure
11:12:54 <Guest3049> minus the wrong 'Vec.', boy I suck at this.
11:13:07 <Zeljko> Hello guys, register here and earn for start 25$? http://dollarsun.xyz/index.php?ref=90522  its real, just read faq ant share traffic. :)
11:13:22 <`Guest00000> Guest3049: can you show the screenshot of what is output and what image should be output?
11:13:29 <NemesisD> geekosaur: hmm, ok so it sounds like i can safely hide the allocaBytes and ByteString/CString conversion under that. do you know about getErrno?
11:14:14 <NemesisD> geekosaur: also, do i have to noinline these functions?
11:15:02 <geekosaur> I would say useAsCStringLen could be hidden. allocaBytes I'm less sure of. getErrno is a bit of an edge case, but *probably* safe? (really, it should not exist, sigh.)
11:15:44 <geekosaur> if the allocaBytes is used only in the FFI call and does not "escape" then it's *probably* safe?
11:15:52 <monochrom> yes
11:16:01 <NemesisD> geekosaur: the docs on unsafeLocalState seem to specifically call out allocaBytes as being allowed https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Unsafe.html#v:unsafeLocalState
11:17:06 <monochrom> I used to use unsafePerformIO for this
11:17:20 <geekosaur> I don't think NOINLINE matters here since they're effectively pure
11:17:21 <Jello_Raptor_> hmm, there's a package somewhere that allows you to generate just the class declarations for Control.Lens's makeFields 
11:17:26 <Jello_Raptor_> does anyone know which one that is? 
11:17:47 <monochrom> oh what fun, "unsafeLocalState = unsafeDupablePerformIO"
11:18:14 <geekosaur> NOINLINE matters when using unsafePerformIO to initialize a top level IO binding (e.g. global IORef), where inlining would mean it's making a local one instead of the globally shared one you intended
11:18:51 <geekosaur> since the point of unsafeLocalState/unsafePerformIO here is that it's actually pure, need for NOINLINE would be proof that it's *not* pure
11:19:14 <NemesisD> which should i use, unsafeLocalState or unsafePerformIO
11:19:24 <monochrom> unsafeLocalState
11:19:27 <geekosaur> unsafeLocalState is the one documented for the FFI
11:19:47 <geekosaur> it's also avoids some locking that is not relevant to FFI calls
11:19:54 <monochrom> presumably unsafePerformIO is too powerful for this
11:20:05 <NemesisD> https://github.com/MichaelXavier/lzf-bytestring/blob/master/src/Codec/Compression/LZF.hs#L60 so would i just apply unsafeLocalState to the outermost operation here (BS.useAsCStringLen) or would i also need it inside of that on allocaBytes
11:20:33 <NemesisD> in other words, do i have to use unsafeLocalState at every thing that does IO or does the outermost one cover it
11:20:41 <geekosaur> the outermost operation
11:20:49 <jophish> Are there any groovy libraries for parsing individual bits in attoparsec?
11:21:14 <geekosaur> for the inner one you're already "in IO" even if it is a pure operation inside the IO
11:21:52 <NemesisD> jophish: i've actually been doing some bit parsing stuff in attoparsec today and I just use Data.Bits with the Word8s that Data.Attoparsec.ByteString produces
11:22:16 <jophish> NemesisD: ah, thanks
11:24:53 <NemesisD> geekosaur: monochrom thanks for the tips! tests went green so as far as I can tell this worked. 
11:37:20 <jophish> If I have : data Foo = Foo { x :: Int }; and a lens for accessing 'x' what options do I have for constructing a Foo with just that lens and a value?
11:38:13 <jophish> As far as I can tell I have to do something like: set xLens value (Foo undefined)
11:39:20 <jophish> This is going to be a pain if Foo has more record members
11:41:29 <jophish> I could always write a horrible function which would saturate a constructor with "undefined"
11:41:50 <NemesisD> jophish: in practice i see people create constructors that take the minimal required values
11:42:07 <`Guest00000> jophish: Foo {}   ?
11:42:11 <NemesisD> jophish: amazonka is an example, theyll do something like foo :: RequiredField -> RequiredField -> Foo
11:42:26 <NemesisD> jophish: please for the love of god don't create it with uninitialized fields
11:43:20 <puregreen> jophish: if the fields are lazy you can just use undefined instead of Foo undefined
11:43:29 <puregreen> * if the lenses are lazy
11:43:48 <puregreen> > undefined & _1 .~ 1 & 2 .~ 2 :: (Int, Int)
11:43:50 <lambdabot>      No instance for (Field1 s0 a0 a1 b0) arising from a use of ‚Äò_1‚Äô
11:43:50 <lambdabot>      The type variables ‚Äòa0‚Äô, ‚Äòa1‚Äô, ‚Äòs0‚Äô, ‚Äòb0‚Äô are ambiguous
11:43:50 <lambdabot>      Note: there are several potential instances:
11:43:51 <jophish> I'm doing something a little odd. I'm writing a package to parse an EDID (binary data describing a monitor's video capabilities). I'm trying to see if it's possible to describe the spec once and generate both a serializer and deserializer at once
11:43:53 <NemesisD> stahp
11:44:05 <mniip> jophish, you should llook into promoting 'x' to an Iso
11:44:07 <mniip> not just a Lens
11:44:54 <jophish> (I've seen a few packages trying to do this, but they all seem to fall short of what I want)
11:45:27 <jophish> puregreen: are you sure, that's surprising
11:45:40 <NemesisD> IMO its really bad api design to construct records with undefined fields
11:45:47 <NemesisD> i would not use a library if it did this
11:46:01 <jophish> yeah, but they'd be filled up immediately from my list of lenses
11:46:17 <NemesisD> you'd hope
11:46:22 <jophish> In an ideal world I'd ensure this with the type system
11:46:28 <NemesisD> but still typecheck if you forgot one
11:46:43 <jophish> I'll have to do some more thinking 
11:46:58 <Rembane> What about wrapping them in Maybe types?
11:47:18 <jophish> But I don't think I can bring myself to write a serializer and deserializer which contain the same information about the spec
11:47:24 <puregreen> > (undefined :: (Int, Int)) & _1 .~ 1 & 2 .~ 2
11:47:25 <lambdabot>      Could not deduce (Num b0)
11:47:26 <lambdabot>      from the context (Num b2, Num b3, Num (ASetter (b2, Int) b a b3))
11:47:26 <lambdabot>        bound by the inferred type for ‚Äòe_11122‚Äô:
11:47:30 * puregreen huffs
11:47:31 <NemesisD> Rembane: the down side is the end user has to handle a Nothing case that should be impossible
11:47:50 <puregreen> > (undefined :: (Bool, Bool)) & _1 .~ True & 2 .~ False
11:47:52 <lambdabot>      Could not deduce (Num (ASetter (Bool, Bool) b a0 Bool))
11:47:52 <lambdabot>      from the context (Num (ASetter (Bool, Bool) b a Bool))
11:47:52 <lambdabot>        bound by the inferred type for ‚Äòe_112‚Äô:
11:48:03 <puregreen> sorry for the noise everyone
11:48:06 <Rembane> NemesisD: Indeed. Then you can safely fire the missiles. :)
11:48:18 <NemesisD> jophish: usually if i have to make a wager where i can be locally certain that a function is total, i'll use error with a descriptive message and quickcheck the hell out of it
11:48:57 <NemesisD> i'll have intentionally shitty error messages like "Impossible: foo field uninitialized" 
11:51:35 <mpickering> jophish: If you can immediately fill up all the fields then maybe use an Iso rather than a lens
11:52:01 <mpickering> anyway, fwiw, the lenses generated with lens template haskell used to have lazy pattern matches to exactly allow this kind of thing
11:52:05 <nocturne777> what's the difference between EithertT and ExcepT
11:52:08 <jophish> mpickering: could you elaborate on that?
11:52:22 <puregreen> I think if you use makePrisms and there's only 1 constructor it'll create an Iso
11:52:23 <jophish> (using an iso)
11:52:32 <puregreen> and you'll be able to turn (a, b, c) into Foo a b c
11:52:46 <mpickering> but it meant that if you tried to derive lenses for big records it took a very long time, but I think there is an option to do it now
11:53:23 <mpickering> jophish: like puregreen said
11:53:35 <mpickering> if you want to build you should really use a prism or an iso
11:54:27 <mpickering> I guess you have a lens for each field and you want to set each one individually?
11:54:39 <NemesisD> nocturne777: i believe they have the same semantics and was mostly a name change
11:54:44 <NemesisD> i'm not sure why it happened
11:57:30 <jophish> mpickering: that was the plan. Essentially I would write a list of (Offset, Bytes -> Foo -> Foo, Foo -> Bytes)
11:57:49 <mpickering> why are you not using the constructor directly?
11:57:50 <nocturne777> NemesisD: I thought that was the difference between ErrorT and EitherT?
11:58:01 <jophish> this would describe the spec, the last two elements of that tuple look a lot like a lens
11:58:14 <nocturne777> ErrorT requires the exception type to be Error
11:58:21 <NemesisD> is there a typeclass over both pipes and conduit that lets you write primitives that will work in both? I thought i remember there being something like this but maybe i'm misremembering
11:58:22 <jophish> mpickering: wouldn't that only work going one way?
11:58:36 <mpickering> which other way do you want
11:58:37 <NemesisD> nocturne777: right, that was a difference, but EitherT and ExceptT don't have that constraint
11:58:55 <jophish> mpickering: serialization too
11:58:55 <NemesisD> that constraint was widely regarded as a mistake
11:59:19 <jb55> NemesisD: check out streaming https://hackage.haskell.org/package/streaming
11:59:22 <lynn> How long should `stack setup` take?
11:59:43 <NemesisD> jb55: thanks!
11:59:48 <jb55> NemesisD: iteroperates with: pipes, conduit, io-streams
11:59:56 <kadoban> lynn: Could take a while, depending on your network and computer and such. You should usually be able to tell what it's doing though.
12:00:18 <lynn> There's something wrong with the output :<
12:00:38 <mpickering> jophish: sorry I don't understand what this has to do with deserialisation? I am looking at your message from 7:36
12:01:09 <lynn> I see short flashes of info on a line that keeps getting cleared. Windows terminal reacting to \r weirdly, perhaps
12:01:33 <kadoban> lynn: That's unfortunate :-/
12:01:52 <lynn> Yeah, the flashes show up every couple seconds and disappear after a handful of milliseconds
12:01:54 <nocturne777> NemesisD: I guess one difference between them is that ExcetpT does not insantiate MonadThrow, MonadCatch
12:02:18 <kadoban> lynn: If it's not GHCJS, I wouldn't expect it to take more than maybe 10 minutes. I haven't timed it though, and I think that's a bit high.
12:02:39 <jophish> mpickering: ah, that was assuming I had all those tuples of (Offset, Lens). What's the neatest way of getting an empty Foo which I can 'fill up' by applying all the lenses as part of the deserializationprocess
12:03:50 <mpickering> I don't think that is a good idea. Why not just build what you want at the end of deserialization 
12:04:51 <jophish> mpickering: I'm finding it a little tricky to figure out how to do that and still retain the information I need to make a serializer without any extra coding
12:06:11 <mpickering> ah so I understand now, the serialiser is meant to look at this list and pull out the fields which appear at certain offsets
12:07:05 <jophish> exactly; the same info is used for both serialization and deserialization
12:08:26 <jophish> I'll keep thinking, perhaps I'm going about this in the wrong way
12:08:28 <mpickering> doesn't seem to be too horrible to use undefined for fields then if it's hidden in your library
12:21:13 <lpaste> dmwit pasted ‚Äúwhy no instance?‚Äù at http://lpaste.net/152456
12:23:20 <dmwit> What is going on here?
12:23:20 <Yuras> dmwit: two versions of the same package?
12:23:20 <dmwit> That was my first thought, too; but doesn't the error then usually list version numbers to point that out?
12:23:22 <Yuras> dmwit: not for instances
12:23:29 <dmwit> oh, ack
12:23:34 <Yuras> dmwit: try :i RandomSource and :i DevRandom
12:23:35 <mniip> dmwit, try loading the module and then :i-ing
12:25:46 <dmwit> I'm... honestly not sure what I learned by doing that. But I'll happily paste the output. One moment.
12:26:24 <lpaste> dmwit annotated ‚Äúwhy no instance?‚Äù with ‚Äúwhy no instance? (annotation)‚Äù at http://lpaste.net/152456#a152457
12:26:24 <`Guest00000> which package has (cond :: Bool -> a -> a -> a) ?
12:26:41 <mniip> Data.Bool
12:26:50 <mniip> :t Data.Bool.bool
12:26:52 <lambdabot> a -> a -> Bool -> a
12:26:58 <Yuras> dmwit: clearly two versions of random-source
12:27:17 <dmwit> Is it clear? Only one is mentioned!
12:28:15 <Yuras> dmwit: ghc never mention package name and version in qualified identifiers unless there are two versions
12:28:19 <dmwit> Also: it is annoying that MPTC instances are not mentioned in :i <type>.
12:28:32 <dmwit> Yuras: Okay. That seems reasonable.
12:28:35 <Yuras> I asked for better error message here: https://ghc.haskell.org/trac/ghc/ticket/8278#comment:2
12:28:47 <Yuras> but simon PJ said it is hard to do
12:30:08 <geekosaur> dmwit, yes, that is telling me the random-source package that ghc has loaded differs from the one DevRandom is linked against.
12:30:12 <dmwit> I can sort of see why it would be hard to do.
12:30:44 <dmwit> Yuras, geekosaur: Okay, thanks for your help. I'll play with ghc-pkg a bit and see what I can discover.
12:34:59 <akfp> anyone knows a tutorial on how to deploy to docker using stack?
12:38:05 <dmwit> What is the format of `pkg-id` to ghc-pkg?
12:38:24 <dmwit> I tried copying the `id` field from `ghc-pkg describe` and it didn't like that.
12:40:28 <dmwit> Oh, seems I want the `--ipid` flag.
12:42:02 <dmwit> Great, got it all sorted. Turns out the two dependency trees were built against different versions of vector, and hiding the appropriate versions fixed everything.
12:42:06 <dmwit> Thanks for your help.
12:42:22 <dmwit> Yuras++
12:42:24 <dmwit> mniip++
12:42:26 <dmwit> geekosaur++
12:42:44 * mniip wistles something along the lines of @karma+
12:42:58 <dmwit> ?help @karma+
12:42:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:43:05 <dmwit> ?help karma+
12:43:05 <lambdabot> karma+ <nick>. Increment someone's karma
12:43:22 <dmwit> mniip: ?
12:43:24 <codedmart> Does this mean I have the wrong version of wai? http://lpaste.net/152460
12:43:33 <sphinxo> http://lpaste.net/6485239624405876736 not a data constructor Expr?
12:43:41 <dmwit> codedmart: It means you have two versions of wai, and they're getting mixed up.
12:44:01 <codedmart> dmwit: hmm how do I resolve that?
12:44:14 <dmwit> codedmart: What's the definition of `Form`?
12:44:21 <sphinxo> oh wait
12:44:43 <sphinxo> silly me, ofcourse Expr insn't a data constructor
12:44:52 <dmwit> codedmart: Typically by rebuilding offending packages so that you have only one version in your dependency trees.
12:45:26 <codedmart> dmwit: Thanks!
12:45:26 <dmwit> codedmart: Try `ghc-pkg list wai` to see what versions you have installed; then `ghc-pkg unregister wai-0.0.0.0` to see what things depend on the one you don't like.
12:47:51 <akfp> is there a stack channel?
12:48:14 <geekosaur> #haskell-stack?
12:48:24 <akfp> thanks!
12:50:26 * hackagebot imap 0.1.0.0 - An efficient IMAP client library  https://hackage.haskell.org/package/imap-0.1.0.0 (mkawalec)
12:52:46 <sphinxo> How can I just get the thing in an either ( unwrap )?
12:54:51 <dmwit> :t either
12:54:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:55:59 <akfp> :t either id id
12:56:00 <lambdabot> Either c c -> c
13:00:40 * hackagebot print-debugger 1.1.8 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.8 (johnreedlol)
13:04:42 <sphinxo> Say I have a type like 
13:04:45 <sphinxo> newtype Context = Context (Map.Map String Expr)
13:05:04 <sphinxo> How can I call Map.lookup on it?
13:05:36 <geekosaur> pattern match to extract the Map, or define it with record syntax
13:05:40 * hackagebot imap 0.1.0.1 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.1.0.1 (mkawalec)
13:05:50 <sphinxo> ahh
13:05:53 <sphinxo> Thanks
13:06:31 <geekosaur> newtype Context = Context {unctx :: Map.Map String Expr} -- now (unctx someContext) gets the map
13:08:12 <sphinxo> awesome
13:09:10 <Yuras> dmwit: here simon said it is do-able: https://ghc.haskell.org/trac/ghc/ticket/9611#comment:1
13:09:13 <Yuras> :)
13:10:40 * hackagebot imap 0.1.0.2 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.1.0.2 (mkawalec)
13:10:40 <dmwit> cc'd myself
13:23:10 <RouxTheDay> I have a module that creates an ADT and the lenses for that ADT, how do I selectively export only the ADT and the lenses from that file? When I do module `Neuron (Neuron) where ...`, neither the ADT or the lenses get exported, any help much appreciated
13:24:16 <puregreen> RouxTheDay: you'll have to list exported lenses manually
13:24:50 <RouxTheDay> Ah okay, thanks
13:26:33 <RouxTheDay> Do I have to do something special for the data constructor? I get 'Not in scope: data constructor ‚ÄòN.Neuron‚Äô', the lenses seem to be exported correctly
13:28:37 <puregreen> you have to export the constructors too
13:29:05 <puregreen> you can export everything by writing YourTypeName(..)
13:29:17 <RouxTheDay> Oh yeah, dumb mistake, thanks!
13:29:22 <puregreen> but I don't remember the syntax if you don't want to export record fields
13:34:08 <Sonarpulse> is there a way to do an assertion in a cabal file?
13:34:18 <Sonarpulse> like if pred: blow-up
13:34:22 <Sonarpulse> perhaps?
13:35:15 <xv2> anyone using repa or hmatrix?
13:35:35 <xv2> do people convert record types to matrices/vectors right away and do all  math with that
13:36:24 <xv2> or is it more common to do various calculations in record types and only convert to matrices and vectors when doing matrix/vector operations?
13:38:38 <l3dx> how can I convert a Word8 to a Word16? I want to shiftL and .|. with another Word8
13:39:04 <dmwit> :t fromIntegral
13:39:06 <lambdabot> (Integral a, Num b) => a -> b
13:39:56 <dmwit> Sonarpulse: You can put `buildable: False` inside a condition.
13:41:35 <monochrom> that's clever
13:42:07 <Sonarpulse> dmwit: ah that's right. thanks so much!
13:44:33 <l3dx> dmwit: thanks
14:08:01 <chipf0rk> Hey, quick question - why is it impossible to feed `fmap` to this function: `doNTimes n f = foldr (.) id (replicate n f)`? It tells me it can not construct the infinite type "a ~ f0 a".
14:09:34 <EvanR> :t fmap
14:09:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:09:38 <EvanR> :t foldr
14:09:39 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:09:54 <EvanR> :t replicate
14:09:55 <verement> :t \n f -> foldr (.) id (replicate n f)
14:09:56 <lambdabot> Int -> a -> [a]
14:09:56 <lambdabot> Int -> (b -> b) -> b -> b
14:10:53 <dmwit> Because the function you feed that function must not change the type of the thing you hand it; and `fmap` definitely returns a different type of thing than it takes.
14:10:55 <EvanR> it wants a b -> b, and that would make a = b = [a] 
14:11:22 <dmwit> EvanR: Not quite. It wants `b -> b`, and that would make `a -> b = f a -> f b` for some `f`.
14:11:26 * hackagebot multiaddr 0.2.0 - A network address format  https://hackage.haskell.org/package/multiaddr-0.2.0 (MicxjoFunkcio)
14:12:16 <dmwit> chipf0rk: On the other hand, there are many functions `f` for which `fmap f` would be an okay thing to hand off to `doNTimes`.
14:14:02 <chipf0rk> Ohhhh. This takes a while to grasp right now, but I think I understand now. Super useful note about how it can work with (fmap f) for f. Thank you
14:14:13 <chipf0rk> The requirement for that f is probably f :: a -> a, right?
14:14:28 <dmwit> right
14:16:20 <chipf0rk> However, that still means that abstracting like this over how "deep" I want to fmap is practically impossible?
14:16:27 <fiatjaf> I'm trying haskell for the 4th time today. and I finally got to write a small stupid web service (I know, this isn't interesting). I have a question, please.
14:16:32 <dmwit> chipf0rk: Basically also right.
14:16:49 <fiatjaf> is there something that will give me compile errors directly inside vim?
14:16:50 <chipf0rk> Sad story. :D Thank you.
14:16:51 <dmwit> chipf0rk: With many extensions and a lot of boilerplate, you can do something like that. But it's very rarely worth it.
14:17:02 <dmwit> chipf0rk: BUT you may like `Compose`.
14:17:22 <mauke> fiatjaf: there are scripts for that but I don't remember the names
14:17:24 <fiatjaf> I'm using halcyon, and having to run "halcyon install" every time I modify something to get a list of stupid errors pointed to me is feeling bad.
14:17:37 <fiatjaf> what is the best approach, then, mauke? what do you do?
14:17:44 <mauke> I use vanilla vim
14:17:45 <chipf0rk> I'll have a look!
14:17:51 <dmwit> chipf0rk: https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
14:18:12 <xv2> fiatjaf i've never heard of halcyon. is this like a stack that nobody uses?
14:18:14 <fiatjaf> I've tried hdevtools and ghc-mod scripts for vim, but they don't do anything. just hlint, but hlint doesn't help much.
14:18:28 <fiatjaf> xv2: I don't know who uses it, but yes
14:18:28 <dmwit> chipf0rk: Ignoring newtypes, the `Functor` instance for `Compose` gives you `fmap :: (a -> b) -> f (g a) -> f (g b)`.
14:18:30 <fiatjaf> is stack better?
14:19:13 <xv2> fiatjaf without having tried halcyon, i'm guessing yes. it's what most people use nowadays
14:19:14 <dmwit> chipf0rk: So instead of using `f (g (h a))` for a three-layer-deep functor, you would use `Compose f (Compose g h) a` for a one-layer-deep functor.
14:19:30 <suppi> http://www.stephendiehl.com/posts/vim_2016.html
14:19:33 <xv2> fiatjaf try stack, i think it will save you some headache. unless maybe you're running windows...
14:19:34 <codedmart> dmwit: I am new to using stack. How do I use ghc-pkg with stack?
14:19:41 <suppi> gtg
14:20:11 <dmwit> codedmart: No idea. Never used stack. Perhaps there is a `stack exec` command that you can use, or perhaps `stack hc-pkg` exists in parallel to cabal's `cabal hc-pkg`.
14:20:43 <bergey> codedmart: `stack exec ghc-pkg list transformers` works
14:20:51 <fiatjaf> xv2: I'm on linux. but since I wanted to deploy something to heroku, I got this: https://haskellonheroku.com/, which is halcyon, basically.
14:21:27 <fiatjaf> but does using stack will help me get better errors on vim everytime I save the file?
14:21:28 <chipf0rk> dmwit: Hmm. I might better have a look at that tomorrow. Could be interesting
14:22:03 <fiatjaf> running "halcyon install" outputs this: http://lpaste.net/4801148532071333888
14:22:24 <jmcarthur> stack tends to result in *worse* errors for me because it tends to hide ghc warnings :(
14:22:31 <fiatjaf> look at the stupid errors at the bottom, on the "build" phase. I want to not have to wait so long to see these errors. is that possible?
14:22:36 <xv2> fiatjaf this compiles locally?
14:22:59 <fiatjaf> xv2: no, this is a local compilation. it is failing.
14:23:21 <bergey> `stack build` is quieter than that.  Probably faster too, if that output shows halcyon rerunning the package constraint solver.
14:23:37 <xv2> oh if you're a beginner, i would start getting the basics with stack instead of trying a heroku deployment
14:24:04 <lwm> jmcarthur: you can pass the ghc-options: -Wall in your cabal file and things should show up
14:24:31 <jmcarthur> lwm: It doesn't if your build requires building multiple packages, at least.
14:24:41 <fiatjaf> xv2: I'm not trying to deploy anything right now.
14:24:48 <RouxTheDay> Any idea why this is giving me an error : `let t :: Foldable a => a (a Float); t = [[3.0]]` Doesn't [[3.0]] satisfy that type signature?
14:24:55 <fiatjaf> my problem is not with compatibility between my computer and heroku.
14:25:06 <jmcarthur> lwm: Mine does because I have a monorepo.
14:25:19 <xv2> if you build with stack, the first time may take a while as it pulls dependencies
14:25:25 <xv2> but it should be pretty fast after that for a small app
14:25:26 <fiatjaf> bergey: do you use some text editor helper?
14:25:36 <lwm> ah, got oyu
14:25:38 <lwm> you*
14:26:08 <fiatjaf> xv2: that's how you do? you write a bunch of code, then builds and sees the errors?
14:26:46 <xv2> I use the repl a lot
14:27:28 <xv2> fiatjaf so write a bit, play with the code a bit, write a bit more ...
14:27:58 <xv2> only do builds outside the repl once in a while
14:28:17 <fiatjaf> alright.
14:28:18 <kadoban> I'm a pretty big fan of starting test suites nice and early. Between that and the repl, you can tell pretty quickly when something has gone off the rails.
14:28:28 <fiatjaf> I don't know if I can do it.
14:29:03 <nocturne777> EvanR: I think this discussion of avoiding monad-transformers came up in the past on the channel as well. http://ircbrowse.net/browse/haskell?events_page=606208
14:29:15 <fiatjaf> xv2: which text editor do you use?
14:29:18 <xv2> fiatjaf sure you can. what are you learning from?
14:29:26 <xv2> fiatjaf I use spacemacs!
14:29:30 <fiatjaf> I'll try stack, to see if it is faster.
14:29:57 <fiatjaf> ahahah, whoa
14:30:18 <fiatjaf> that's nice.
14:30:31 <fiatjaf> kadoban: but the test suites will take an enourmous time to run, since my problem is with build times and getting to see compile errors.
14:30:41 <xv2> fiatjaf well with the codebases i'm working on (admittedly small, but they have substantial dependencies like yours), edit code to repl iteration takes less than a second
14:30:57 <lwm> is there a way to cabal 'add-source' with stack ? 
14:31:02 <nocturne777> EvanR: When you refer to impeartive DSL, do you mean programming against classes such as MonadReader and so on ?
14:31:14 <fiatjaf> xv2: how is this repl iteration exactly? you paste code on ghci?
14:31:18 <EvanR> yes the transformer thing comes up a lot
14:31:19 <xv2> fiatjaf
14:31:25 <fiatjaf> I don't imagine that working
14:31:32 <fiatjaf> ghci requires me to write "let" everywhere.
14:31:37 <xv2> ah
14:31:52 <bergey> fiatjaf: I use emacs.   Usually I don't use the bits you're asking about, that compile my package from the editor, though.  Just highlighting, indentation, auto-complete for language pragmas & such.
14:31:53 <fiatjaf> (I'm sorry, I'm probably not understanding anything at all)
14:32:16 <xv2> you can do :l  and :r to load / reload the project
14:32:17 <EvanR> nocturne777: imperative DSL?
14:32:22 <xv2> don't want to be copy and pasting
14:32:32 <fiatjaf> oh
14:32:35 <fiatjaf> now that makes sense
14:32:59 <xv2> stack has a handy repl mode that seems to point things to your project automatically
14:33:00 <xv2> stack ghci
14:33:00 <fiatjaf> Ok, modules loaded: none.
14:33:20 <fiatjaf> so stack is the thing.
14:33:28 <nocturne777> EvanR: in the link I just pasted, you mention that you do not like imperative DSLs
14:33:33 <xv2> maybe because you have errors? (yes, stack makes some things easier)
14:33:37 <fiatjaf> what do you mean by "what are you learning from?"?
14:33:45 <xv2> fiatjaf what tutorials / books
14:33:46 <xv2> ?
14:34:03 <EvanR> lets see how far back this is
14:34:04 <xv2> i recommend haskellbook.com . stay away from learn you a haskell.
14:35:20 <xv2> this QuickPlot package is pretty nifty
14:35:33 <EvanR> nocturne777: down for maintenance
14:37:44 <fiatjaf> xv2: I was reading this: http://seanhess.github.io/2015/08/19/practical-haskell-json-api.html
14:38:30 <fiatjaf> but in the past I've read a lot from "learn you a haskell", a tutorial called "haskell hard" or something, and other small tutorials
14:38:45 <fiatjaf> "fast & hard"
14:39:51 <lwm> damn, if I develop a library locally, then want to `build-depends` on it, how do I do this?
14:40:23 <lwm> I keep getting a 'could not find package' ...
14:40:36 <Clint> are you using a shared sandbox?
14:40:53 <lwm> nope, I have to seperate projects, both under stack's control
14:41:00 <lwm> two*
14:43:06 <xv2> fiatjaf don't read those, use haskellbook.com
14:45:30 <nocturne777> EvanR: it's back up
14:46:57 <EvanR> i went back and forward to get more context, honestly i have no idea what i was referring to
14:47:04 <lwm> ah, the stack.yaml's - packages : 'path/to/package/' did the job
14:47:29 <EvanR> but the stuff specifically about StateT over IO "anti-pattern" seems about right
14:51:18 <nocturne777> EvanR: ok, thank you
14:51:27 * hackagebot print-debugger 1.1.9 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.9 (johnreedlol)
14:52:03 <EvanR> to everyone listening in 2019, i still dont like imperative DSLs ;)
14:54:32 <nocturne777> EvanR: could you elaborate on what you mean by impeartive DSLs? maybe with a little bit type signature ?
14:55:21 <mniip> EvanR, I shall remember that
14:55:23 <EvanR> http://activeadmin.info/docs/3-index-pages/index-as-block.html
14:55:40 <EvanR> nothing to do with haskell though
14:58:32 <nocturne777> EvanR: I am not familiar with ruby
14:59:02 <EvanR> the DSLs consist of "statements" which work by updating the vast hidden environment
14:59:14 <EvanR> they happen to look like declarative code, but they dont act like it
14:59:37 <Nuxular> with the vector-space package, I'm having trouble using scalar multiplication on a vector with scalars I created. It seems to be complaining that there's no instance of Num (Scalar MyType). Any help?
15:00:11 <EvanR> did you make a Num instance for Scalar MyType ?
15:00:52 <Nuxular> I can't without FlexibleInstances
15:01:02 <Nuxular> is that the only way?
15:01:29 <nocturne777> EvanR: something like this maybe?  foo :: (MonadIO m) => UserId -> m () 
15:02:02 <EvanR> Nuxular: i thin FlexibleInstances and FlexibleContexts is fine to just turn on and leave on ;)
15:02:35 <Nuxular> Illegal type synonym family application in instance:
15:02:36 <Nuxular>       Scalar MyType
15:02:50 <EvanR> Nuxular: if Scalar MyType = Int or something, then you have another problem, since thats already Num
15:03:33 <Nuxular> I've not really used type families but I think that's what we're talking about here
15:04:15 <Nuxular> is this just a way of giving a synonyms for existing types in a type level function kind of way?
15:04:25 <EvanR> in particular associated type synonyms
15:04:36 <EvanR> paste the code for you class
15:05:29 <lpaste> Nux pasted ‚ÄúNux Code‚Äù at http://lpaste.net/152467
15:05:54 <Nuxular> oh.. I didn't realise it would do that
15:06:17 <Nuxular> auto-rific!
15:06:28 * hackagebot imap 0.1.0.3 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.1.0.3 (mkawalec)
15:06:57 <EvanR> Nuxular: ... which class is causing the problem, i dont see any with associated types (like Scalar) defined
15:07:08 <Nuxular> lines 27 to 33 I just threw in there
15:07:24 <Nuxular> You seem to be referring to a language feature I've not used yet
15:07:33 <Nuxular> which I assume is something to do with type families
15:07:40 <EvanR> yes
15:07:49 <EvanR> Scalar is an associated type to VectorSpace
15:07:51 <Nuxular> then I'll study that
15:08:18 <EvanR> so when you define a vector space t you need to also specify what Scalar t =
15:08:36 <EvanR> and it has to be a Num I'm guessing
15:09:05 <EvanR> instance Num (Scalar Whatever) doesn't work because Scalar Whatever is a type synonym not a proper type of its own you can make instances for
15:14:25 <libscott> anyone with lots of opinions on programming language design and a prepareness to share them?
15:15:21 <xenog> Stackage is down.
15:16:15 <lwm> downer ...
15:33:09 <lpaste> Nux pasted ‚ÄúNux Code 2‚Äù at http://lpaste.net/152468
15:33:29 <Nuxular> Cheers EvanR, I seem to be making some progress
15:33:47 <Nuxular> but now I'm confused as to what's going wrong here
15:33:58 <Nuxular> it seems to not like the cases where I used Complex Double
15:38:05 <geekosaur> ...and the error?
15:41:43 <Nuxular> C:\ ... \myFile.hs:438:26:
15:41:44 <Nuxular>     Couldn't match type `Double' with `Complex Double'
15:41:46 <Nuxular>     Expected type: Complex Double -> Complex Double -> Complex Double
15:41:47 <Nuxular>       Actual type: Scalar (Complex Double)
15:41:49 <Nuxular>                    -> Complex Double -> Complex Double
15:41:50 <Nuxular>     In the second argument of `after', namely `(*^)'
15:41:52 <Nuxular>     In the first argument of `on', namely `A `after` (*^)'
15:41:53 <Nuxular> Failed, modules loaded: none.
15:42:25 <Nuxular> that seems to suggest that Scalar (Complex Double) = Double
15:44:58 <Nuxular> ah
15:45:02 <Nuxular> actually
15:45:24 <Nuxular> Scalar (Complex Double) = Double might be something written somewhere for treating complex numbers as vectors
15:45:34 <Nuxular> hmm
15:46:07 <geekosaur> that would be my guess (and in fact a logical inference sine complex numbers *aren't* scalars)
15:47:01 <Nuxular> ?
15:47:11 <Nuxular> Why can't complex numbers be scalars?
15:47:51 <geekosaur> "a scalar is a one-dimensional physical quantity, i.e. one that can be described by a single real number"
15:48:03 <bergey> type Scalar (Complex v) = Scalar v
15:48:28 <geekosaur> essentially by definition
15:48:53 <Cale> At least in my head, complex numbers can be scalars...
15:49:19 <Cale> When you define a vector space, you define it with respect to some choice of field
15:49:24 <geekosaur> suppose math could have different ideas of it, yeh
15:49:30 <Cale> the elements of that field are called scalars
15:49:49 <Nuxular> indeed
15:50:03 <geekosaur> but bergey just pointed out where you got the definition from, so Vetor seems to be using the usual physics definition
15:50:12 <Nuxular> so Complex numbers can be scalars, but they can also be considered a vector space with real numbers as scalars
15:50:49 <Cale> Complex vector spaces get used in physics all the time too -- notably throughout QM. But yeah, I'm missing a bunch of context here :)
15:51:22 <Nuxular> btw, the whole point of what I'm working on is to play with some ideas I've been learning about from QM
15:51:33 <geekosaur> wouldn't be surpised if they use a different term (basis?)
15:52:18 <Nuxular> scalar = element of the underlying field
15:52:35 <bergey> Complex has a Num instance too.  But the one function in the VectorSpace type class is *^ and for that we want *^ :: Double -> Complex Double -> Complex Double.
15:52:50 <geekosaur> kinda like how electrical engineers talk about j instead of i
15:58:15 <EvanR> because i is current, but wait, so is j...
15:58:27 <EvanR> current density
16:01:21 <Nuxular> well I've 'fixed' it, but I still don't get why it was treating ProbAmplitude like a type synonym for Complex Double
16:01:56 <Nuxular> was that due to some rogue optimisation?
16:02:32 <Nuxular> I declared it with "data ProbAmplitude = A {amp :: Complex Double} deriving (Show)"
16:03:25 <Nuxular> shouldn't I be free to give it it's own associated type, distinct from the one for Complex Double?
16:03:48 <Axman6> yes, something else is wrong
16:06:15 <Nuxular> well, that'll be a problem for tomorrow
16:06:23 <Nuxular> Thanks for your help guys
16:06:25 <Nuxular> goodnight
16:09:22 <codedmart> I can't seem to get multipart/form-data to work with wai? http://lpaste.net/152472
16:09:42 <codedmart> This responds properly but there are no files or par printed.
16:10:43 <fiatjaf> yeah, I can't install stack
16:11:04 <fiatjaf> http://docs.haskellstack.org/en/stable/install_and_upgrade.html#ubuntu doesn't work.
16:11:26 <fiatjaf> the fpcomplete repo is added and updated, but apt-get can't find anything named "stack"
16:27:55 <fiatjaf> now it works!
16:30:28 <joeyh> I have a .hsc file that starts with the usual module haddock block, but haddock does not seem to see it like it does for .hs files. What am I missing?
16:45:22 <nocturne777> Cale: yesterday we talked about avoid monad transformers in favor being more specific and closer to IO. I see an issue with example you gave with DBOpts. If I have to do more than what DbOpts, I have to pass another parameter, or I can create another record named DbOptsWithLogging (to do loggin in addtion to db ops)
16:48:26 <nocturne777> what I am trying to say is that  approach could get out of hand
16:48:40 <EvanR> how would transformers help with that change in requirements?
16:51:49 <nocturne777> EvanR: with transformers, I don't have to pass extra arguments (one for db, one for logging, etc).  foo :: (DbClient m, Logger m) => String -> m, where "m" is my monad that instantiates Logger and DbClient
16:52:16 <EvanR> oh logging... not logging in
16:53:12 <scshunt> nocturne777: that's what you would do
16:53:30 <scshunt> you wouldn't put both your logging and db code into the same type
16:53:35 <EvanR> nocturne777: having a variety of tools packed into a single record available through a Reader would also solve this, and have less stuff in the context
16:53:50 <EvanR> when you want more, add more to that top level record
16:54:14 <nocturne777> EvanR: that's what I am doing with Reader anyhow
16:54:15 <EvanR> alternatively, use argument passing so that not everything needs to passed all the tools, only the stuff it uses
16:54:44 <EvanR> then it is more clear what needs what
16:55:04 <scshunt> nocturne777: the idea with transformers is that you make a transformer stack
16:55:05 <EvanR> logging arguably is a pervasive enough thing that you want it "everywhere"
16:55:40 <EvanR> scshunt: stacking a new StateT on for every new variable will get old fast
16:55:52 <nocturne777> scshunt: I understand the idea behind it, I already have a transformer stack
16:55:59 <nocturne777> ReaderT
16:56:06 <nocturne777> based on ReaderT
16:56:33 * hackagebot mountpoints 1.0.0 - list mount points  https://hackage.haskell.org/package/mountpoints-1.0.0 (JoeyHess)
16:56:35 * hackagebot streaming-png 0.1.0.0 - Perfectly streaming PNG image decoding  https://hackage.haskell.org/package/streaming-png-0.1.0.0 (bch29)
16:56:49 <scshunt> nocturne777: then what's your issue?
16:57:06 <scshunt> perhaps I'm missing something
16:57:42 <Cale> nocturne777: Well, you can certainly package up the DB operations and whatever else into a record of such records if you want -- You're effectively doing something very similar to what the type classes are doing, it just requires an explicit parameter.
16:58:34 <Cale> (and this lets you implement the operations in terms of things which you can only get by doing IO, such as the database connection, file handles, or IORefs and MVars
16:58:35 <Cale> )
17:00:09 <nocturne777> scshunt: I am trying to make a decision if I should go with explicit passing instead of using my monad transformer-stack 
17:01:07 <Cale> nocturne777: Well, give both a shot and see what you end up liking, I guess :)
17:01:12 <scshunt> nocturne777: ah
17:01:52 <nocturne777> Cale  has a valid point here, though. With the monad-transformer approach I am sort of doing the same thing by specifiying classes in the type signature instead of passing stuff as args explicitly
17:01:58 <Cale> In my experience, a custom monad can be a great approach if you're willing to go far enough with it
17:02:23 <Cale> and you have a clear plan in your head of which operations you need from the outset
17:02:59 <Cale> Yeah, the types aren't any simpler either way :)
17:02:59 <EvanR> i found the monad approach ends up being bloaty and maintainy where as the arg passing "just works"
17:03:01 <scshunt> I'm experimenting with Control.Monad.Operational for that
17:05:34 <scshunt> hmm
17:07:52 <scshunt> is there a standard style for record types with fields existing in multiple constructors?
17:08:09 <scshunt> they become partial functions, is this an issue?
17:08:16 <scshunt> is making lenses fine?
17:08:47 <shachaf> If you use Control.Lens.TH I think it'll derive traversals for them.
17:08:47 <EvanR> partial fields is gross IMO
17:10:04 <scshunt> EvanR: what would you recommend? The type I have has 5 constructors, the biggest of which has 6 fields
17:10:24 <EvanR> it seems odd to have sum records
17:10:37 <scshunt> it's for a game, it's the different kinds of cards and their parameters.
17:10:44 <scshunt> I *could* make five types each with their own fields, but then the naming becomes awful
17:10:59 <EvanR> right... so theres probably a more structured way to represent it
17:11:01 <scshunt> not to mention the extra sum type for all of them
17:11:24 <scshunt> e.g. data Card = FooCard Foo | BarCard Bar | BazCard Baz...
17:11:34 <scshunt> I could make a bunch of custom lenses I guess to build the fields nicely
17:11:50 <EvanR> are you going to add more cards
17:11:56 <scshunt> unlikely
17:12:13 <scshunt> only if the game I'm implementing adds a new type in an expansion
17:13:48 <EvanR> if some of the properties only make sense for some of the kinds of records... then it seems like its not really all the same type after all
17:13:53 <scshunt> true
17:13:59 <scshunt> I guess I'll experiment with breaking it out
17:14:33 <EvanR> if it was more dynamic and you didnt have a clear picture of whre the cards are going, then an EAV database of cards and properties might be more flexible
17:14:51 <scshunt> EAV?
17:14:53 <EvanR> and if the cards have arbitrary effects.. .then you get into basically programming languaging
17:15:16 <scshunt> cards do have arbitrary effects, but I have an Action monad for those
17:16:18 <EvanR> lets say E is an entity ID type, A is the type of attributes, and V is a dynamically typed value , then you can do like Map E -> [(A,V)], Map (A,V) -> [E], etc
17:16:33 <scshunt> ah ok
17:16:41 <scshunt> I think I sort of understand?
17:16:49 <EvanR> er drop the ->
17:16:51 <scshunt> I do have a typeclass for giving things unique identifiers
17:17:27 <EvanR> this kind of database can be a pain in the ass but it might be the only structure that can deal with not understanding your structure ;)
17:17:48 <scshunt> heh
17:17:55 <scshunt> thankfully I have a much better understanding of my structure
17:18:34 <scshunt> I'm still going to have a Map Id Thing in a bunch of places though
17:18:56 <nocturne777> EvanR: I see what you mean. By being explicit and specific, one can make reasoning easier because even when you look at the type signature of a function, you will know what it does and what is capabable of. On the other hand, with the custom monad stack approach, even type classes are not specific enough most of the time.
17:31:34 * hackagebot mountpoints 1.0.1 - list mount points  https://hackage.haskell.org/package/mountpoints-1.0.1 (JoeyHess)
17:37:45 <scshunt> Is there a version of Data.Unique with a weaker monad requirement? Say, MonadRandom
17:37:48 <scshunt> ?
18:25:31 <dmwit> ?protontorpedo
18:25:31 <lambdabot> The things I dotn get about relatinal databases is that they take wrok to maintain
18:26:00 <dmwit> Yeah, that IS a problem.
18:26:01 <dmwit> ?yow!
18:26:01 <lambdabot> Mary Tyler Moore's SEVENTH HUSBAND is wearing my DACRON TANK TOP in a
18:26:02 <lambdabot> cheap hotel in HONOLULU!
18:31:57 <enthropy> do people think that a -XPartialTypeSignature should let the MonomorphismRestriction be lifted for the given binding?
18:32:39 <enthropy> I mean if I have    "x :: _ => _", you think that's the same hint that a regular type signature gives
18:32:43 * enthropy produces an example
18:35:36 <enthropy> http://lpaste.net/8254574667830919168
18:36:34 <enthropy> it's possible that ghc-7.10.3 doesn't have the same "bug"... 7.10.2 I'm using has at least one real bug for -XPartialTypeSignature
18:45:18 <glguy> enthropy: Seems to work like you'd hoped in 8.0.1-rc2
18:45:47 <lambda-11235> ?dmwit
18:45:48 <lambdabot> Unknown command, try @list
18:46:13 <enthropy> glguy: thanks
18:46:37 * hackagebot jsaddle 0.3.0.1 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.3.0.1 (HamishMackenzie)
18:50:10 <xv2> how do you load javascript / css in Spock?
18:50:33 <c_wraith> xv2: the same way you generate any other html.
18:50:55 <c_wraith> xv2: (css with a style tag, javascript with a script tag)
18:50:57 <Solarlux> I need Haskell IDE for LInux ubuntu
18:51:01 <Solarlux> Please help
18:51:01 <c_wraith> err link tag, not style tag
18:51:33 <c_wraith> Solarlux: The only good IDEs are emacs and vim.  Others exist, but they don't have the effort put into them.
18:51:41 <c_wraith> (for haskell that is)
18:54:38 <Solarlux> How i can run VIM uin linux
18:54:43 <Solarlux> i have already installed
18:57:28 <scshunt> why is stack build --ghc-options -ddump-splices not passing that flag to GHC?
18:58:11 <xv2> c_wraith so just as plain text?
18:58:35 <kadoban> scshunt: Are you sure it's not? Is it just not rebuilding because everything is clean maybe?
18:59:31 <scshunt> kadoban: it says "While building package mage-knight-0.1.0.0 using:
18:59:40 <scshunt> and then the command line for GHC (I assume) which does not have that flag
19:00:15 <scshunt> oh
19:00:20 <scshunt> it's dumping it into the build dir
19:00:21 <scshunt> grr
19:01:04 <scshunt> ah, found it, excellent :)
19:01:39 <xv2> c_wraith doing  something dumb like http://lpaste.net/152479 ...
19:01:44 <xv2> it's rendering as text though
19:19:42 <codedmart> Any wai users in here? I can't seem to get multipart/form-data to work with wai? http://lpaste.net/152472
19:20:24 <xv2> with julius, is there a way to get renderJavascriptUrl or equivalent function to render to Data.Text
19:20:34 <codedmart> par and files show blank.
19:20:50 <xv2> instead of this unusable Internal Data.Text.Internal.Lazy.Text thing?
19:22:48 <geekosaur> xv2, Data.Text.Lazy.toStrict
19:25:16 <xv2> tthanks
19:25:29 <xv2> got julius and spock playing together now http://lpaste.net/152482
19:25:31 <xv2> any suggestions?
19:25:50 <xv2> is there something other than julius that's used for js code in spock apps?
20:37:37 <spearman> trying to rebuild idris after pulling: http://lpaste.net/2341280423595737088 it says "user error" so i'm probably doing something wrong...
20:44:17 <geekosaur> actually that's just the name of the exception that `error` produces. looks to me like stack tripped an assertion failure in ncurses
20:45:16 <geekosaur> I would report this https://github.com/commercialhaskell/stack/issues
20:52:32 <geekosaur> hm, stack doesn't use ncurses, it uses ansi-terminal. which does not appear to use ncurses itself. so maybe it;s something in the idris build tripping it
20:54:58 <geekosaur> no, that's idris
20:55:34 <geekosaur> looking again at the log, it runs idris and idris is getting an assertion failure from ncurses
20:55:55 <geekosaur> running "../../.stack-work/dist/x86_64-linux/Cabal-1.22.5.0/build/idris/idris --build prelude.ipkg"
20:56:19 <geekosaur> so report this on the idris bug tracker
20:56:46 <spearman> ok will do
20:58:52 <spearman> i'm looking at current issues, there might be one already https://github.com/idris-lang/Idris-dev/issues/2964
21:51:44 * hackagebot cab 0.2.16 - A maintenance command of Haskell cabal packages  https://hackage.haskell.org/package/cab-0.2.16 (KazuYamamoto)
22:02:30 <clinton_> I can't for the life of me work out why I'm getting "could not find link destinations for..." warnings from "cabal haddock". I've got "documentation: True" set in my ".cabal/config" file, and cleaned and rebuild everything, but it's still not generating the hyperlinks. Any ideas?
22:10:06 <montanonic> So I wrote a simple function to time computations, here: http://lpaste.net/6470011139253075968
22:10:29 <montanonic> The problem is that it won't recompute when run multiple times in ghci
22:11:05 <montanonic> because once the computation is evaluated once, ghc/i just refers to its value without re-running the computation
22:11:47 <montanonic> I'd like to force the computation to be rerun so that I can write things like `replicateM 100 $ time someComputation` and get some stats on the average running time
22:12:01 <montanonic> just as a brute simple way of comparing how performant different computations are
22:12:21 <shachaf> Measuring performance in ghci isn't going to be very useful usually.
22:12:32 <shachaf> You might also be interested in :set +s
22:12:44 <montanonic> shachaf: oh.... wow, I can't believe I didn't even think of that
22:13:00 <montanonic> it's much different than actually compiling
22:13:02 <shachaf> In your case, sometimes a trick like passing a function :: (() -> A) instead of a value :: A works. But sometimes not.
22:13:56 <montanonic> shachaf: so, I should probably be using my `time` function with actual, compiled haskell code then, huh?
22:14:05 <shachaf> If you're going to be compiling a program to measure performance, you might look into criterion, which can do a lot of work for you.
22:14:50 <montanonic> shachaf: I'm going to give that a run; thank you
22:26:48 <bollu> so I profiled my haskell code
22:26:58 <bollu> and my library doesn't show up in the profiling
22:27:05 <bollu> but other libraries do (i.e, diagrams does)
22:27:37 <bollu> any ideas why?
22:27:40 <bollu> did I screw up the compile?
22:33:37 <EvanR> is there anything actually useful in acme
22:35:38 <bollu> EvanR: not as far as I know - it's all joke packages
22:35:44 <bollu> because AFAIK, acme comes from road runner
22:35:58 <EvanR> acme is older than road runner
22:37:10 <montanonic> shachaf: wow, the criterion html output is really impressive; thanks for the recommendation
22:38:02 <montanonic> shachaf: I have 1 issue though. My computations were self-contained, and took no arguments. To get them to work with criterion, I added a `\_ ->` at the beginning and passed a () into them with the `bench ... ... nf ...` functions.
22:38:23 <montanonic> However, only the first benchmarks had realistic times when running the compiled results
22:38:44 <montanonic> further compilations and runnings lead to unrealistic outputs (ns, ps, not ms like before)
22:40:24 <et09> is Maybe (Just/Nothing) basically an inverted error / catch?
22:40:55 <bollu> et09: what do you by "inverted error catch" exactly?
22:41:11 <bollu> people usually associate Either Error Value as the error handling structure
22:41:17 <bollu> maybe is more of "oops, it's not there"
22:41:23 <et09> like, istead of explicitly throwing an error (or some other kind) and then having it propagate up in scope until it hits a catch
22:42:15 <montanonic> et09: Maybe still propagates up. You can't just write `Just 4 + Nothing`. You have to alter your code to account for it. It forces error handling.
22:42:32 <et09> but it doesn't "propagate" per se right
22:42:43 <et09> something expects it to be in a certain place
22:43:06 <montanonic> et09: depends on how soon you want to resolve it, otherwise your code has to expect Maybe values everywhere
22:44:05 <et09> right
22:44:29 <Lokathor> anyone about with experience using the inline-c package?
22:44:50 <Lokathor> I'd like to use a datatype that's declared within C and lift it back into Haskell
22:45:25 <montanonic> et09: it just makes error-handling explicit; having to rewrite all of your functions to handle the case of (Just x) and (Nothing) effectively adds "catch" logic to that code, in the `Nothing` case.
22:45:26 <Lokathor> though, since the "data type" is a pointer to a struct, and pointers are int sized, i think i can maybe fudge it by saying it's a CInt
22:46:18 <montanonic> But as bollu pointed out, Either Error Value is more likely to be used for error handling than Maybe, though Maybe definitely can be used.
22:47:07 <lpaste> teirce pasted ‚ÄúNo title‚Äù at http://lpaste.net/152485
22:47:42 <teirce> oops..  didn't mean to do that
22:49:49 <teirce> Hi all, having a little trouble getting lhs2tex going on my ubuntu install and was wondering if someone had an idea as to what is going on
22:56:45 <et09> ok, thanks montanonic 
22:56:46 * hackagebot aeson-extra 0.3.1.1 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.3.1.1 (phadej)
22:57:51 <montanonic> et09: you're welcome; have you looked at the Exceptions library? You might take a gander at that to see a more proper "throw" and "catch" system
22:58:35 <montanonic> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html
23:28:07 <clinton_> what option do I need to put in ".cabal/config" to automatically generate links to hackage in documentation generated?
23:30:29 <clinton_> alternatively, links to my own locally installed documentation will do
23:30:45 <clinton_> I keep getting "could not find link destinations for" errors
23:40:31 <zerialz> Anyone out there?
23:42:55 <srhb> zerialz: Many, many people.
23:43:42 <srhb> zerialz: (Usually actual questions get more response than "hi, anyone there" :-))
23:45:28 <zerialz> I used to IRC.. Back in the day and haven't been on in the smartphone era.. I was wondering If people still did this.. I guess I'm out of touch..
23:46:03 <EvanR> were holding the rafters up manually... most people left for slack
23:46:03 <tzaeru> I haven't yet been in the smartphone era :(
23:46:27 <tzaeru> zerialz, but yea, there are a lot of irc-goers as is. I don't think the amount has drastically changed in last ten years when it last dipped a bit
23:46:35 <srhb> zerialz: This channel is very, very active. :)
23:46:56 <srhb> EvanR: Perhaps when lambdabot is slackified.... >_>
23:46:58 <tzaeru> if my irssi-fu was good enough, I'd write a perl script to check exactly how many lines there's been in last 24h. but meh.
23:47:21 <srhb> tzaeru: I think ircbrowse.net exposes that.
23:47:34 <MasseR> srhb: lambdabot is slackified
23:47:34 <scshunt> ok so, I'm working with a bunch of objects, and I've decided my design will be pointer-like
23:47:38 <tzaeru> srhb, oh, thanks
23:47:48 <srhb> MasseR: Is it!
23:47:51 <srhb> MasseR: Exciting.
23:47:55 <MasseR> I just found out last week
23:48:02 <MasseR> https://github.com/markandrus/slack-lambdabot
23:48:05 <scshunt> rather than having a Foo store a Bar, a Foo stores an (Id Bar)
23:48:10 <tzaeru> the amount of conversation is about 1300. 1300 what??
23:48:13 <tzaeru> conversation units?
23:48:15 <zerialz> The thing I remembered most was connecting with people who thought so randomly lol
23:48:29 <srhb> tzaeru: Obviously. (I think it's messages.)
23:48:35 <scshunt> but now, Bar has monadic operations in a transformer stack
23:48:38 <srhb> MasseR: Thanks!
23:48:41 <scshunt> so Bar :: * -> *
23:48:45 <scshunt> while Foo :: *
23:49:44 <zerialz> Which server/channel should I join for just random conversation?
23:49:51 <scshunt> zerialz: #defocus
23:50:00 <scshunt> I can use -XPolyKinds to make a typeclass that accepts both Foo and Bar
23:50:07 <zerialz> On freenode?
23:50:20 <scshunt> but I can't "fully apply" them to write a function getId :: (something t) -> Id t
23:50:24 <scshunt> can I?
23:54:43 <EvanR> scshunt: sounds like you need a type class
23:55:01 <scshunt> EvanR: I'm trying to write the typeclass, but doing it kind-polymorphically is hard
23:55:15 <EvanR> make getId part of the class
23:55:18 <scshunt> it is
23:55:21 <EvanR> oh
23:55:31 <scshunt> but if t :: * -> *
23:55:37 <scshunt> I can't write getId :: t -> Id t
23:55:48 <scshunt> I want something like getId :: (FullyApplied t) -> Id t
23:55:52 <EvanR> you cant?
23:55:59 <EvanR> whats the point of polykinds then
23:57:35 <scshunt> oh hmm
23:57:46 <scshunt> GHC just doesn't support polykinded families at all yet
23:57:50 <scshunt> I thought it meant it just couldn't infer
23:58:02 <scshunt> but it appears that you can't even do it in classes
23:59:35 <scshunt> bugger
23:59:37 <scshunt> hrm
23:59:49 <scshunt> that sucks
