00:01:09 <quuxman> is there an IDE out there that has type filtered completion?
00:01:33 <quuxman> I was just checking out Haskell for Mac out of curiosity, and the completion is either non-existant or much worse than ghci, can't tell
00:04:56 * hackagebot binary-parser 0.5.2 - A highly-efficient but limited parser API specialised for bytestrings  https://hackage.haskell.org/package/binary-parser-0.5.2 (NikitaVolkov)
00:17:30 <quuxman> @hoogle Module
00:17:32 <lambdabot> Language.Haskell.TH.Syntax Module :: PkgName -> ModName -> Module
00:17:32 <lambdabot> Language.Haskell.Syntax Module :: String -> Module
00:17:32 <lambdabot> System.Posix.DynamicLinker.Module data Module
00:34:57 * hackagebot hfmt 0.0.2.2 - Haskell source code formatter  https://hackage.haskell.org/package/hfmt-0.0.2.2 (danielstiner)
01:09:58 * hackagebot tagchup 0.4.0.5 - alternative package for processing of tag soups  https://hackage.haskell.org/package/tagchup-0.4.0.5 (HenningThielemann)
01:10:00 * hackagebot sox 0.2.2.6 - Play, write, read, convert audio signals using Sox  https://hackage.haskell.org/package/sox-0.2.2.6 (HenningThielemann)
01:13:32 <quuxman> cabal installs can be painfully slow. Heh, It'd be great if the build process could be lazy, and it just interpreted it and somehow backgrounded the compilation :-P
01:13:52 <dave23_> how can I ensure one monadic action is evaluated before another?
01:14:24 <clintm> I swear stack is faster than cabal, but that might be bias because I like stack so much.
01:14:25 <bolmar> quuxman: that's basically JIT isn't it
01:14:54 <quuxman> you write it first. though I assume you mean enforce an ordering for later monadic composition
01:15:53 <dave23_> quuxman: Forgive my sloppy vocabulary. What I mean is one of the effects has to occur before the other in order for the program to work.
01:16:58 <quuxman> dave23_: so simply verify that effect A always appears before effect B in any given monadic sequence. If the monadic composition is non-deterministic, I have no idea off the top of my head
01:19:02 <dave23_> quuxman: how can I verify this? The effect is a change in a database, nothing in the program changes.
01:19:14 <`Guest00000> an addition to haskell
01:19:21 <`Guest00000> [..]  as shorthand for [minBound..maxBound]
01:19:58 * hackagebot fft 0.1.8.3 - Bindings to the FFTW library.  https://hackage.haskell.org/package/fft-0.1.8.3 (HenningThielemann)
01:20:28 <quuxman> bolmar: except JIT would take a lot of work to implement. GHC already supports interpreting
01:21:10 <`Guest00000> hm, i can just write a function...
01:21:24 <quuxman> it would be the most ghetto of JITC, but I think it'd be great :-)
01:21:28 <shanemikel> how can I import prelude hiding functor instances for certain types (how about either e as an example).. I'm trying to do the exercizes for https://wiki.haskell.org/Typeclassopedia
01:24:34 <quuxman> hey Typeclassopedia is a great article I haven't seen yet
01:28:13 <shanemikel> recommended by stephen deihl in his http://dev.stephendiehl.com/hask
01:32:52 <shanemikel> also, is there something I'm missing in my sandbox setup.. for instance, I'd like to run ghci without cabal exec.. and get access to the sandboxed libs
01:33:47 <shanemikel> and using atom editor's ide-haskell package.. can't resolve the sandboxed libs which breaks the type-checking
01:35:39 <bernalex> I've never used stack, but I decided to check out the newest haskell-vim-now. what does "The following package identifiers were not found in your indices: bin-package-db-0.0.0.2" mean?
01:37:23 <quuxman> maybe I should've just installed haskell-vim-now. I decided to switch to atom from Sublime Text just about an hour ago to check out the haskell packages. Atom has a much better vim package than ST
01:38:10 <shanemikel> atom is much better on most counts
01:38:30 <quuxman> yeah it seems pretty nifty
01:39:02 <quuxman> the one haskell atom package I didn't see immediately is live-reload on type, like some of the Haskell IDEs
01:40:54 <shanemikel> it's a beautiful markdown reader/editor too
01:41:33 <shanemikel> did you play around with the github integration? I've never tried that stuff.. I have a hard time moving away from the cmd line
01:41:58 <shanemikel> quuxman: what live-reload on type? an atom plugin for haskell?
01:44:20 <quuxman> it hasn't been done at all. In fact I don't think I've ever seen an editor plugin attempt this. For some reason it's always tacked on as a feature in some ghetto IDE, like Haskell for Mac
01:45:21 <shanemikel> or leksah
01:45:57 <quuxman> obviously the general case isn't reasonably solveable, the reload method depends on initialization
01:46:54 <quuxman> I mean solveable automatically, but an editor plugin should be able to support this with some kind of annotation
01:47:28 <shanemikel> in my very limited experience, it's rather annoying
01:47:51 <quuxman> I think it's fantastic for graphics and audio code
01:48:06 <quuxman> pretty much everything else it sucks for
01:49:20 <shanemikel> wait, what do you mean by live reload? nvm.. I thought you were talking about live type checking.. you're talking about reloading a client application.. like refreshing the browser if you're building a JS app?
01:49:59 * hackagebot cryptonite 0.11 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.11 (VincentHanquez)
01:51:26 <quuxman> shanemikel: well, browser refresh takes long enough I'd only want this to be on save. I think it's only useful in the context of graphics and audio code that uses a library that supports this
01:52:08 <shanemikel> oh, well that's the only niche in which I've tried it
01:53:01 <deepfire> Good day folks!
01:53:23 <deepfire> We have a job opening in Moscow, Russia: https://www.reddit.com/r/haskell/comments/45e14x/onsite_haskellpython_opportunity_at_positive/
01:54:51 <kriztw> deepfire: no remote I guess?
01:55:12 <shanemikel> quuxman: what audio processing lib do you use in HS?
01:55:24 <shanemikel> and graphics?
01:56:21 <quuxman> shanemikel: so far all the Haskell stuff I've done has only used Cairo, OpenGL, and Super Collider for audio. I've never had a satisfactory live update environment with Haskell
01:57:10 <quuxman> speaking of cairo, is there any better way to draw things with cairo in a window than gtk?
01:57:38 <quuxman> I mean I want something like GLUT, so even if gtk is a library dependency, I don't have to think about it
01:59:52 <shanemikel> quuxman: well, if you think about all the scariness that goes into something like a live reload, it's no wonder that there's some context requirements of a hack like that
02:00:29 <quuxman> shanemikel: definitely. But it's interesting to think about a more general approach
02:01:14 <shanemikel> I shiver even thinking about the specific approach
02:02:09 <quuxman> the specific approach is mighty simple. Either the process restarts, or it dynamically loads a module defining the new code
02:02:49 <quuxman> for anything involving a window, dynamically loading a module is obviously the best approach
02:03:06 <quuxman> Haskell supports this quite nicely
02:07:45 <shanemikel> well I haven't done that.. I was thinking something along the lines of IPC and coupling with the audio subsystem
02:11:16 <shanemikel> but in any case.. there are many layers you're conveniently ignoring.. you're talking about watching the editors buffer (specific to most editors), and doing some type checking.. assuming some sane time interval..
02:12:15 <quuxman> with audio, it's typically done with a client/server system, at least that's how Super Collider works
02:12:23 <shanemikel> yeah, IPC
02:12:48 <shanemikel> but I'd think that relies on specific support for each OS and audio subsystem
02:13:33 <quuxman> hey, speaking of environments, has anyone here managed to experiment with UnisonWeb?
02:14:12 <quuxman> I was quite interested in checking it out, but it failed to build after quite a few attempts and I gave up
02:15:08 * hackagebot xournal-types 0.5.1.0 - Data types for programs for xournal file format  https://hackage.haskell.org/package/xournal-types-0.5.1.0 (IanWooKim)
02:24:23 <liste> does anybody have experience with beam? how does it compare to opaleye/persistent?
02:29:01 <bernalex> is there a function/operator Maybe a -> Maybe a -> Maybe a that returns the leftmost if it is Just, else the rightmost?
02:29:27 <puregreen> > Just 1 <|> Nothing
02:29:29 <lambdabot>  Just 1
02:29:35 <puregreen> > Nothing <|> Just 1
02:29:37 <lambdabot>  Just 1
02:29:44 <bernalex> ta!
02:29:50 <jle`> there's also 'asum' for multiple Maybe's
02:29:58 <bernalex> should have thought about that
02:29:59 <jle`> > [Just 1, Nothing, Just 10]
02:30:01 <lambdabot>  [Just 1,Nothing,Just 10]
02:30:09 <jle`> > [Nothing, Just 1, Nothing, Just 10]
02:30:11 <lambdabot>  [Nothing,Just 1,Nothing,Just 10]
02:30:18 <jle`> oops, should have been putting asum
02:30:19 * hackagebot bytestring-tree-builder 0.2.5 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.5 (NikitaVolkov)
02:30:27 <jle`> but i don't want to rob you of the fun of trying it yourself :)
02:32:42 <bernalex> how would you guys encode an "opposite"? I was just thinking I'd like to overengineer this... I have data Direction = North | East | West | South -- how would you encode opposite direction so that you could just od North and get South? right now I'm using a plain case-statement, but that's boring! :p
02:34:30 <bennofs> bernalex: plain case statement is how I'd do it as well.
02:35:14 <bennofs> bernalex: btw, in my code, i have data Axis = X | Y, and data Dir = Dir Axis Bool, where the Bool specifies if we go in positive or negative direction on the axis
02:35:29 <bennofs> bernalex: so I can just flip the bool to get the opposite direction
02:35:43 <bernalex> bennofs: that sounds like something I would do with a clear conscience in c++ or python
02:36:20 <jle`> writing a 'turnAround :: Direction -> Direction' using a case statement probably makes the most sense to me
02:37:39 <bennofs> bernalex: for me it has the advantage that I need to write most code only once for each axis, and then I can just put a "negate" in somewhere if that Bool was False
02:38:47 <jle`> you could write 'rotated' isos maybe to make functions on one access work on another
02:39:07 <jle`> over rotated90 myFuncOnAxis
02:39:19 <jle`> s/Axis/Direction
02:40:12 <bernalex> I haven't programmed any real haskell for so long now
02:40:45 <bernalex> http://lpaste.net/2930972247856250880 what should I be doing here? :p something tells me I should implement some instance for this stuff...
02:43:35 <bennofs> bernalex: fromMaybe w $ do  r <- activeRoom w; MkNeighbours ns <- M.lookup r (rooms w); n <- M.lookup d ns; return w { activeRoom = Just n }
02:44:10 <bernalex> bennofs: yeah I was considering doing it the monad-y way too. although I'm not always convinced it is the more readable solution.
02:44:42 <bennofs> to me the monadic one is way more readable than the nested case stuff.
02:45:08 <bennofs> bernalex: I suppose you could also use PatternGuards, like    move w d | Just ... <- ..., Just ... <- .... = .... | otherwise = w
02:45:19 <jle`> i would say that using Maybe's Monad instance is definitely more readable than nested case statements
02:45:20 <bernalex> wwoh yeah in this case I quite agree
02:45:26 <jle`> that's the entire point of the monad instance
02:45:27 <bernalex> s/ww//
02:45:39 <bernalex> it's a lot nicer for future changes
02:45:43 <jle`> at least, in this case, yeah
02:47:57 <bernalex> hm. my code doesn't work though. heh. probably an error someplace else.
02:48:26 <bernalex> oh. yeah.
02:48:37 <hexagoxel> have any of you automated the process of publishing packages to hackage, including testing and other sanity checks?
02:49:34 <bennofs> hexagoxel: not really. I've only automated all the sanity checks to travis, so basically I tag a release, check travis for that tag, then upload
03:00:02 <sphinxo> Say i'm writing a simple vm ( stack or register based ) how best should I represent the internal state of the machine? contents of registers etc
03:00:47 <jophish> sphinxo: it depends on what your objective is
03:01:45 <sphinxo> Well i'd like to teach some other people I know about haskell, and I thought making a simple vm would be a good project
03:02:04 <sphinxo> I'd like to foldl over a list of instructions
03:02:59 <hexagoxel> bennofs: i think i want more automation; e.g. to include the haddock upload, and checks like "was an entry added to the changelog?".
03:03:26 <jophish> hexagoxel: let me know when you come to a solution please!
03:03:36 <sphinxo> jophish: Any ideas?
03:04:12 <jophish> sphinxo: If it's just for a pretty example I'd have a big data type MachineSTate
03:04:19 <jophish> MachineState*
03:04:30 <dogcat> so you can foldr over a list of instructions, but you may need to use a tuple to keep an environment
03:04:43 <jophish> which contains other types such as RegisterSet and MemoryContents for example
03:04:59 <sphinxo> ahh
03:05:18 <dogcat> working on a virtual machine for teaching haskell is a great project
03:05:20 <jophish> that's dead easy to explain, and doesn't involve anything complicated such as mutable vectors or ST which you might get involved with if you're going for performance
03:05:43 <dogcat> like Deihl's write you a haskell
03:09:56 <bernalex> I'm having some cabal problems, it semes like
03:10:00 <bernalex>     Could not find module ‘Data.Monoid’
03:10:02 <bernalex>     It is a member of the hidden package ‘base-4.8.2.0’.
03:10:04 <bernalex>     Perhaps you need to add ‘base’ to the build-depends in your .cabal file.
03:10:18 <bernalex> I have base >=4.8 && <4.9 in the library req
03:10:51 <bernalex> the executable (I am trying to do cabal run) reqs the library. the error msg is ina library file.
03:11:14 <pavonia> You have to have it in the library section as well
03:11:36 <hexagoxel> bernalex: is the hs-source-dirs the same for executable and library?
03:13:08 <hexagoxel> because if yes, the "library file" will be read directly (instead of importing from the lib) when compiling the executable, making it an "executable file".
03:13:58 <hexagoxel> (and how do you manage to write exe without using base.. well it is possible i guess.)
03:18:08 <bergmark> bernalex: if lib and exe share source dirs you need to duplicate the dependencies since the modules will be built twice
03:19:41 <bernalex> hexagoxel: yes
03:20:15 <bernalex> hexagoxel: the exe should probably depend on base too anyway, yeah
03:21:04 <bernalex> bergmark: that's completely and utterly retarded. but yeah I seem to remember that.
03:21:16 <bernalex> I guess I'll just make separate dirs.
03:22:53 <sphinxo> How are these types to represent a simple vm? http://lpaste.net/5664344676900012032
03:23:25 <sphinxo> Is something I can derive from that can give me the functionality that the fn reg is giving me?
03:25:16 <yuval> Hey
03:26:25 <dogcat> I would say use the RWS monad
03:26:34 <dogcat> or some combination of state and reader
03:28:13 <deepfire> kriztw, yes, unfortunately..
03:29:30 <deepfire> kriztw: "no, unfortunately, no" would be a properly-worded English answer to your question
03:37:16 <quuxman> arhg, with the latest version of gtk, it seems I must write: button `on` buttonPressEvent $ liftIO mainQuit >> return False
03:37:26 <quuxman> whereas before I could simply write: onClicked button mainQuit
03:37:50 <quuxman> onClicked is now nowhere to be found :-[
03:40:59 <sphinxo> How could I simply implement Pop in this? http://lpaste.net/1931699324203302912
03:41:53 <bernalex> @hoogle readMay
03:41:54 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
03:41:54 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
03:42:44 <quuxman> I'm very unhappy with this API update
03:42:53 <bernalex> @hoogle Read a => String -> Maybe a
03:42:54 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
03:42:54 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
03:42:54 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
03:43:03 <bernalex> @hoogle Read a => String -> [(Maybe a, String)]
03:43:03 <lambdabot> No results found
03:43:07 <bernalex> @hoogle Read a => String -> (Maybe a, String)
03:43:07 <lambdabot> No results found
03:43:12 <bernalex> ok does anyone remember wtf the safe read is called
03:43:42 <sphinxo> And how should I implement my "main loop" ( fetch execute etc )
03:45:08 <lep-delete> :t Text.Read.readMaybe
03:45:10 <lambdabot> Read a => String -> Maybe a
03:45:10 <bernalex> oh. there is indeed a readMay in safe. hoogle just doesn't do safe.
03:46:03 <ClaudiusMaximus> bernalex: it's in recent base as lep-delete points out
03:47:22 <bernalex> ClaudiusMaximus: lep-delete: so it is. ta.
03:49:09 <bernalex> I guess I shouldn't use read anyway. I just remember the read . show isomorphism. I should just use a function parseDirection.
03:55:22 * hackagebot threepenny-gui 0.6.0.6 - GUI framework that uses the web browser as a display.  https://hackage.haskell.org/package/threepenny-gui-0.6.0.6 (HeinrichApfelmus)
03:56:53 <sphinxo> Could someone please review this code? http://lpaste.net/5845979213215039488
03:57:16 <Rembane> sphinxo: It's code all right. Should we look for something in particular?
03:57:24 <sphinxo> ooh just noticed I'm not incrementing the ip
03:57:50 <sphinxo> Rembane: How would I easily implement Pop?
03:57:54 <gracefu> @pl head (filter (\x -> ident x == sub_id) subs)
03:57:55 <lambdabot> head (filter ((sub_id ==) . ident) subs)
03:58:11 <gracefu> huh, (sub_id ==) neat
03:58:26 <Rembane> sphinxo: What should pop do?
03:58:45 <sphinxo> Place the value on the top of the stack into a register
03:59:31 <sphinxo> Oh
03:59:35 <Rembane> sphinxo: So the function signature is like: pop :: Stack -> Register -> VM ?
03:59:50 <sphinxo> ahh yes
03:59:51 <liste> sphinxo: it looks nice. one alternative would be to flip eval, so that "eval Add :: VM -> VM", but that's not necessarily better
04:00:03 <sphinxo> so registers would be on VM like (Int, Int, Int)
04:00:46 <Rembane> sphinxo: Or you could keep the register typ for as long as possible.
04:00:53 <sphinxo> How so?
04:01:29 <Rembane> sphinxo: For making it easier to reason about and give the typechecker a better chance to help you.
04:01:40 <sphinxo> How would I do that?
04:03:00 <Peaker> cocreature: you still here?
04:03:01 <Eduard_Munteanu> Is there a preferred way to serialize [String] into char ** for FFI purposes? I'm using c2hs, by the way.
04:03:51 <Peaker> Eduard_Munteanu: https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCString on all the list elements
04:04:15 <Rembane> sphinxo: There are a couple of different ways, how low level do you intend this to be in the end? :)
04:04:21 <Peaker> Eduard_Munteanu: and storing all the ptrs in a ptr array, don't know if there's any better way
04:04:32 <sphinxo> Rembane: not too much
04:04:58 <Rembane> sphinxo: Then you can for instance use a Data.Map where the keys are registers and values are what the registers contain.
04:05:22 * hackagebot cases 0.1.3 - A converter for spinal, snake and camel cases  https://hackage.haskell.org/package/cases-0.1.3 (NikitaVolkov)
04:05:24 * hackagebot contravariant-extras 0.3.1 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.1 (NikitaVolkov)
04:05:39 <ClaudiusMaximus> or you could derive Ix and use Data.Array with register as index
04:05:53 <Eduard_Munteanu> Peaker, looks like newCString+free is easier then.
04:05:58 <sphinxo> That's a good idea
04:06:06 <Rembane> That's neat.
04:06:09 <Peaker> Eduard_Munteanu: cause nesting "with" is hard?
04:06:18 <Peaker> Eduard_Munteanu: you could use mapM with ContT wrapping
04:06:31 <sphinxo> how could I change the step function it inc the ip?
04:06:56 <sphinxo> s/it/to/
04:08:44 <Rembane> sphinxo: vm { ip = ip vm + 1, } $ eval bla...
04:09:33 <sphinxo> like this? step vm =   vm { ip = ip vm + 1} $ eval vm (fetch vm)
04:10:14 <Rembane> sphinxo: Yeah. But you might want to double check that it actually does things in a way and order you expect it to. 'cause I just winged it. :)
04:10:47 <sphinxo> yeah, Couldn't match expected type ‘VM -> VM’ with actual type ‘VM’
04:11:59 <sphinxo> ah it's cause I've also got a function called vm
04:13:24 <safrol> Good morning everyone.
04:13:25 <ClaudiusMaximus> sphinxo: i'd write a new function to increment the counter - raw record syntax gets a bit hairy
04:13:46 <sphinxo> Good idea
04:15:41 <Eduard_Munteanu> Peaker, uh, my head hurts
04:17:21 <Peaker> :t (runContT . mapM (ContT . Foreign.C.withCString))
04:17:23 <lambdabot> Traversable t => t String -> (t Foreign.C.String.CString -> IO r) -> IO r
04:17:54 <Peaker> Eduard_Munteanu: you'd still need to convert the [CString] to a c array of CString, and then take a ptr to that
04:18:16 <safrol> Eduard_Munteanu: Ouch.
04:20:23 * hackagebot list-t 0.4.6 - ListT done right  https://hackage.haskell.org/package/list-t-0.4.6 (NikitaVolkov)
04:21:37 <Eduard_Munteanu> I guess I can add withArray to that.
04:25:23 * hackagebot postgresql-binary 0.8.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.8.1 (NikitaVolkov)
04:32:09 <sphinxo> Rembane: How would I repeatedly call step step until the vm ip is greater then the length of the intrs?
04:32:21 <sphinxo> s/step step/step/
04:35:23 * hackagebot neat-interpolation 0.3.1 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.3.1 (NikitaVolkov)
04:36:15 <bernalex> I want to write
04:36:23 <bernalex> foo | x == y = blah
04:36:29 <bernalex>     | x == z = bluh
04:36:36 <bernalex> in do-notation
04:36:41 <bernalex> I can't, afaik, but what can I do instead?
04:37:20 <bernalex> iow, what's a non-clutter way of doing "if x == y then ... else if x == z then ... else if true then...
04:38:14 <Rembane> sphinxo: You could build a looping function that removes one instruction per cycle and feets it to eval, and then calls itself with the result from eval.
04:39:18 <sphinxo> One instruction from the list in VM?
04:39:35 <sphinxo> The problem with that is that i've implemented jumping
04:39:45 <sphinxo> so it doesn't really work like that
04:39:54 <ClaudiusMaximus> bernalex: you could use case with guards, might be slightly less clutter
04:40:24 * hackagebot hasql 0.19.8 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.8 (NikitaVolkov)
04:40:26 * hackagebot stm-containers 0.2.10 - Containers for STM  https://hackage.haskell.org/package/stm-containers-0.2.10 (NikitaVolkov)
04:40:26 <safrol> :t I
04:40:28 <lambdabot> Not in scope: data constructor ‘I’
04:40:35 <bernalex> ClaudiusMaximus: how so?
04:40:40 <safrol> It's all fun and games until someone loses an I.
04:41:07 <hpc> :t I#
04:41:09 <lambdabot>     Not in scope: data constructor ‘I#’
04:41:09 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
04:41:22 <ClaudiusMaximus> case () of _ | x == y -> blah   | x == z -> bluh   | otherwise -> ...
04:41:30 <safrol> :t In
04:41:32 <lambdabot> f (Mu f) -> Mu f
04:41:39 <safrol> Aha.
04:41:42 <safrol> Interesno.
04:41:55 <bernalex> ClaudiusMaximus: oh using (). that's an ugly way to make up for a syntax shortcoming... but I guess it works.
04:42:06 <safrol> Unit ? 
04:45:24 <safrol> :k Unit
04:45:27 <lambdabot> *
04:45:35 <safrol> :t ?
04:45:38 <lambdabot> parse error on input ‘?’
04:45:44 <safrol> :t ()
04:45:46 <lambdabot> ()
04:45:53 * safrol yawns
04:46:07 <safrol> Weird...
04:50:24 * hackagebot slave-thread 1.0.1 - A principal solution to ghost threads and silent exceptions  https://hackage.haskell.org/package/slave-thread-1.0.1 (NikitaVolkov)
04:50:26 * hackagebot rebase 0.4.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.4.2 (NikitaVolkov)
04:50:30 <haskellcoredump> I am getting a segmentation violation when doing some socket disconnects how do I get a better stack trace 
04:51:28 <haskellcoredump> also, can i assume that it could be a compiler bug and go to ghc 7.10 from 7.8? any pointers will help. I know its a bit less in detail, I was looking for some way to try out today.
04:53:24 <haskellcoredump> i guess -O0 is a start. Let me see what I find.
04:53:26 <haskellcoredump> thanks.
05:00:24 * hackagebot aivika-branches 0.1.2 - Branching discrete event simulation library  https://hackage.haskell.org/package/aivika-branches-0.1.2 (DavidSorokin)
05:08:35 <unit73e> hello
05:09:13 <unit73e> what is the best gui framework for haskell? By best I mean easiest and less buggy.
05:09:25 <unit73e> I want to do an editor
05:09:46 <MasseR> unit73e: haskell doesn't have a good track record with guis
05:09:55 <MasseR> But you can try wxhaskell or gtk
05:10:05 <Rembane> unit73e: haste.
05:10:05 <unit73e> both suck?
05:10:15 <MasseR> For a 'pretend-html-and-javascript-is-native' you can use something like threepenny
05:11:29 <unit73e> Rembane: No web please, god no. But thanks :)
05:11:48 <MasseR> Then you have either wx or gtk 
05:11:53 <MasseR> wx is a bit more haskelly
05:12:07 <Rembane> unit73e: ^^
05:13:18 <unit73e> I'll try wx, seems easier. That or I'll use scala instead and eventually switch to haskell.
05:13:23 <MasseR> :D
05:13:57 <unit73e> thanks
05:22:07 <bernalex> wx and gtk are the best indeed for native programs. for Web stuff things are quite a bit better.
05:29:14 <m0rphism> unit73e: if a terminal UI is sufficient, there is also the brick library
05:29:14 <roelof> Hello, I have this : chk :: Eq b => (a -> b) -> a -> b -> Bool and I have this so far : chk  f  = f   
05:29:31 <roelof> but I do not see how I can turn this to a Bool 
05:30:35 <m0rphism> unit73e: it's a widget based terminal UI. I like programming with it, but there aren't many buit-in widgets yet, so I have to write a lot of them on my own.
05:31:14 <m0rphism> unit73e: btw, I'm also working on an editor right now :>
05:32:36 <MasseR> m0rphism: unit73e and vty-ui
05:32:54 <m0rphism> MasseR: brick is the successor to vty-ui
05:33:19 <MasseR> m0rphism: oh, I thought they were just different libraries
05:33:48 <unit73e> m0rphism: that was the next step thanks. I fact I might start with brick, seems easier.
05:34:31 <KaneTW> roelof: you can turn the a into a b using f, and then use (==) or (/=) on them
05:36:18 <roelof> I know , but where do I have to compare it to Eq . I can do check f = f == ??? 
05:37:07 <KaneTW> well you can't compare the f itself
05:37:16 <KaneTW> check f a b = ...
05:38:11 <roelof> and compare it against f x does also not work 
05:40:26 * hackagebot RNAlien 1.1.0 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.1.0 (FlorianEggenhofer)
05:40:56 <roelof> KaneTW: can you give one more tip 
05:42:51 <OverCoder> I get "*** Exception: <stdout>: hPutChar: invalid argument (invalid character)" when I print non-ascii character, how do I fix this?
05:43:04 <OverCoder> I tried hSetEncoding stdout utf8 but it still crashes
05:45:15 <pavonia> OverCoder: What character are you trying to prnt?
05:45:37 <Jedai__> Overcoder: That's strange, on what OS are you ?
05:45:43 <OverCoder> I want to be able to print any character, the one made the app crash was ¢
05:45:52 <OverCoder> Jedai__, PowerShell on Windows 10
05:45:57 <KaneTW> roelof: check f a b = f a == b
05:46:35 <Jedai__> Overcoder: Well that's definitely possible. I did it recently.
05:47:25 <OverCoder> I've just tried with cmd and it still doesn't work
05:47:41 <sphinxo> How can I fold a function with type sig a -> a ?
05:47:55 <sphinxo> tried doing foldl with (.)
05:48:49 <sphinxo> trying to implement run in http://lpaste.net/2574581621185314816
05:49:05 <Jedai__> weird I'll look at how I did it
05:50:55 <sphinxo> Any ideas?
05:51:00 <ClaudiusMaximus> :t iterate
05:51:02 <lambdabot> (a -> a) -> a -> [a]
05:51:32 <Jedai__> Overcoder: the problem is probably with your inputs. I just checked and my code doesn't even do anything before using putStr
05:51:35 <ClaudiusMaximus> although you don't need all the intermediate results
05:51:40 <roelof> KaneTW:  thanks, and stuck on the next one : arith :: Num b => (a -> b) -> Integer -> a -> b . I have so far this :  arith f x =  f x + x
05:52:12 <sphinxo> hmm, can I get that to continue to run whilst the ip is less then the total number of instructions?
05:53:12 <Jedai__> Overcoder: On the other hand I had to change the encoding of my input handle since Haskell tried to read it with the console encoding...
05:53:16 <pavonia> :t foldl
05:53:18 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
05:53:45 <pavonia> sphinxo: ^ the a looks like your Instrauction type and b like your VM type
05:55:42 <OverCoder> Jedai_, hmm, well I get my input from an IRC server actually
05:55:48 <OverCoder> and I have set it's encoding to utf8 too
05:55:50 <sphinxo> Yeah, if you see my step function pavonia it is just VM -> VM
05:55:57 <OverCoder> I can show you the full source if you like
05:56:05 <Jedai__> Overcoder: Another possibility is that you're trying to output characters that are not supported by your codepage. Then you'll have to change it.
05:56:18 <OverCoder> Codepage? what's that?
05:56:20 <sphinxo> and I can't really do jumping very easily using foldl
05:57:12 <Jedai__> That's specific to Windows consoles, it's basically the set of characters they know
05:57:49 <OverCoder> hm, well I used to run the same things but with other langauges (Java, specifically) and it used to work
05:57:57 <Jedai__> see chcp, it can be changed from a Haskell program if necessary
05:58:05 <OverCoder> hmm
05:58:22 <pavonia> sphinxo: Does your VM terminate eventually with a final result?
05:58:41 <sphinxo> it terminates when it runs out of instructions to execute
05:59:10 <pavonia> So you could probably use iterate as ClaudiusMaximus suggested
05:59:30 <pavonia> and take the last element of that list as the result
05:59:33 <sphinxo> or when the instruction pointer is greater then the length of the code part (a list of instrs)
05:59:34 <Jedai__> Overcoder: I can tell you that I'm able to print accented characters that I read from a file in utf8_bom without any special handling.
05:59:58 <OverCoder> What OS are you using?
06:00:02 <sphinxo> The final thing I want to be returned is a version of the VM
06:00:11 <Jedai__> Overcoder: the same as you
06:00:27 <roelof> No one who can help me with this problem : http://lpaste.net/152268
06:00:28 <OverCoder> ooh, how weird
06:00:57 <Jedai__> Overcoder: it wouldn't be very significant otherwise
06:01:19 <OverCoder> hm
06:01:45 <ClaudiusMaximus> roelof: you need more arguments for your function definition
06:02:54 <roelof> ClaudiusMaximus:  more ?? f :: ( a -> b) -> Integer and x :: a . What do I need more ? 
06:03:16 <pavonia> x :: Integer here
06:03:35 <ClaudiusMaximus> f :: a -> b
06:03:45 <lpaste> Jedai pasted “Output accented” at http://lpaste.net/152269
06:04:37 <Jedai__> Overcoder: you can see my code (as ugly as it is) in this paste
06:05:06 <roelof> oke, I changed it to this : arith f i x =  f x + fromIntegral x + i  but now It seems ghci thinks b is a Integer :( 
06:06:01 <OverCoder> Jedai__, hm, okay hold on
06:06:38 <pavonia> roelof: b is the result type of f, and you add i :: Integer to it, so it tries to unify b with Integer
06:07:22 <pavonia> roelof: Maybe you want fromInteger i?
06:08:21 <OverCoder> Jedai__, hmm, well here's mine too http://lpaste.net/7482476282588954624
06:08:34 <roelof> yes, I need that one : this is working: arith f i x =  f x + fromIntegral i .  you remark about tries to unify b with i did it 
06:10:14 <pavonia> OverCoder: Note that BS.unpack doesn't convert Unicode characters from UTF-8 to String
06:10:26 <hexagoxel> (funny to have dependencies on both the `safe` and the `unsafe` packages.. :D)
06:10:58 <Jedai__> Overcoder: I suppose you tried it without the set encoding on stdout
06:11:18 <OverCoder> Jedai__, yeah
06:11:22 <OverCoder> pavonia, ow
06:11:37 <OverCoder> pavonia, Then there the problem could be?
06:11:51 <pavonia> I think that's the problem, yes
06:12:05 <OverCoder> Hm, okay I'll search for that, many thanks :^)
06:13:58 <pavonia> OverCoder: I usually use Data.Text.Encoding to convert from ByteString to Text and then unpack the Text to String. Not sure if this is the recommended way, though
06:14:20 <OverCoder> Hm, I'll just try it now
06:14:34 <sphinxo> I'm wondering whether I could implement run in a cleaner way: http://lpaste.net/3699637854717083648
06:15:27 * hackagebot adblock2privoxy 1.4.2 - Convert adblock config files to privoxy format  https://hackage.haskell.org/package/adblock2privoxy-1.4.2 (zubr)
06:16:59 <ClaudiusMaximus> sphinxo: you can have both guards on the same function line, so you don't need to repeat "run instrs vm@VM {ip=ip}" (just replace the second occurence with spaces)
06:17:36 <Jedai__> pavonia: Once you have a Text you may as well stay with that rather than getting back to String though (apart from some libraries that don't grok Text)
06:17:38 <ClaudiusMaximus> sphinxo: also it should probably be 0 <= ip && ip < length instrs , and more idiomatic would be  otherwise  in the second guard
06:19:18 <sphinxo> Like this? http://lpaste.net/4213661258689282048 ClaudiusMaximus 
06:19:24 <pavonia> Jedai__: Yes, but sometimes you need to convert it back
06:20:01 <exio4> OverCoder: why do you need a String, though?
06:20:32 <OverCoder> to um
06:20:47 <sphinxo> ClaudiusMaximus: Maybe instead of passing a list of instructions I could instead pass the total number?
06:20:49 <OverCoder> oh wait my problem isn't in unpacking the ByteString, I've just realized now
06:20:58 <lpaste> ClaudiusMaximus annotated “No title” with “No title (annotation)” at http://lpaste.net/4213661258689282048#a152270
06:21:13 <OverCoder> I receive a String from the handle and print it using printStrLn
06:21:25 <ClaudiusMaximus> sphinxo: i meant like that
06:21:28 <sphinxo> ahh nice
06:21:34 <Jedai__> pavonia: I know, but more and more packages work with Text :)
06:22:01 <exio4> OverCoder: putStrLn, you mean? 
06:22:15 <OverCoder> Yeah I meant that :P
06:22:27 <exio4> OverCoder: you can use getLine/putStrLn from bytestring
06:23:06 <OverCoder> Um, did you lookup the source I pasted? because when I receive from a handle I don't get a ByteString anyways, I get a plain String
06:23:29 <pavonia> exio4: Does that handle UTF-8 corectly?
06:23:40 <OverCoder> But later in the code I get ByteString from the Network.IRC.Parser.decode, but the problem is in printing the String itself, and not the output from the Parser
06:23:55 <exio4> pavonia: it won't
06:24:08 <exio4> pavonia: it doesn't handle anything on its own
06:24:17 <exio4> pavonia: it'll give you a byte array, mostly.
06:24:31 <pavonia> So it will probably result in the same error then
06:24:33 <exio4> OverCoder: where's that code?
06:24:48 <OverCoder> http://lpaste.net/7482476282588954624
06:26:11 <exio4> OverCoder: you're using ByteString wrong
06:26:43 <OverCoder> Not surprising actually
06:26:58 <exio4> OverCoder: you shouldn't be reading String(s) from the network, you should be reading ByteString(s)
06:27:28 <exio4> OverCoder: you can do this using Data.ByteString.[Char8.]hGetLine
06:27:45 <OverCoder> Ow, um, somebody actually pointed that out to me earlier.. I couldn't figure out how to use them anyways, oh and thanks for that ^, I'll just do the switch now
06:29:43 <exio4> OverCoder: it might be nicer to use OverloadedStrings, I am sure the IRC parser is only using ByteString(s), so if you want to print UTF8 strings, you'd need to use Data.Text.Encoding and decode them on your own
06:30:31 <OverCoder> Oh alright, so it needs some more work than I thought, I'll just do those now
06:30:32 <ClaudiusMaximus> sphinxo: you could extract the instructions from the VM instead of passing them to run, but caching the repeated length is probably not worthwhile - better switch to an Array of instructions with O(1) access instead of O(n) for list (!!)
06:31:39 <sphinxo> ClaudiusMaximus: in my VM record type?
06:31:45 <ClaudiusMaximus> yep
06:32:12 <exio4> OverCoder: fwiw, "forever" is available in Control.Monad
06:32:32 <OverCoder> exio4, and it works the exact same way?
06:32:39 <exio4> OverCoder: yes
06:32:42 <exio4> @type forever
06:32:44 <lambdabot> Monad m => m a -> m b
06:32:54 <OverCoder> Ooh
06:32:58 <OverCoder> Okay, thanks
06:35:35 <OverCoder> exio4, how can I use head or words on a ByteString?
06:36:45 <OverCoder> Ah wait, I figured out
06:36:48 <sphinxo> ClaudiusMaximus: In record VM, what is the type signiture of the array as I don't know the length at that stage?
06:36:52 <exio4> OverCoder: there are multiple functions which do that, they are named "head" and "words" respectively
06:37:44 <maerwald> I hope he knows what head means in the context of ByteString
06:38:20 <exio4> OverCoder: anyway, if you are working with Char(s), then you shouldn't be using head naively
06:38:27 <maerwald> it's not really a char you get, unless you use Char8, which you shouldn't
06:38:45 <exio4> OverCoder: a ByteString is closer to a ByteArray than a String
06:39:01 <maerwald> Char8 is used for some network protocols where you have a guarantee about 8bit/7bit chars
06:39:14 <exio4> which you don't have on IRC 
06:39:32 <maerwald> yeah, the name "ByteString" is a bit misleading, unfortunately
06:39:42 * OverCoder confuses a bit
06:39:53 <OverCoder> How Char8 is different than a ByteString
06:40:13 <exio4> OverCoder: you will probably want to switch as soon as you can to Text, Data.Text.Encoding.decodeUtf8
06:40:22 <maerwald> OverCoder: http://a-dimit.blogspot.de/2012/04/strings-in-haskell.html
06:40:34 <OverCoder> exio4, hmmm
06:41:01 <OverCoder> maerwald, seems exciting article, /me reads it now
06:41:09 <ClaudiusMaximus> sphinxo: Array Int Instruction  (the size isn't part of the type, only the type of indices)
06:41:46 <sphinxo> ahh
06:42:48 <maerwald> OverCoder: although "There is no legitimate use case for ByteString.Char8.pack in production code." from that article is wrong... there are legitimate use cases where the domain guarantees that only max 8bit chars are sent
06:43:15 <sphinxo> ClaudiusMaximus: and then construct like  listArray (0, length instrs) instrs
06:43:16 <OverCoder> hmm
06:43:20 * OverCoder continues reading
06:43:34 <sphinxo> and use ! to index
06:43:42 <ClaudiusMaximus> sphinxo: lenght instrs - 1  (array ranges are inclusive)
06:44:03 <sphinxo> Great
06:44:33 <nshepper1> imo Char8 would be (more) legitimate if it was called Ascii
06:44:40 <marchelzo> hi, I have an a, and in my state i have [[a]]. I want to cons my a to the first [a] in the State monad using lens. Is this the right way? listOfListOfALens.(ix 0) %= (myA:)
06:45:09 <ClaudiusMaximus> sphinxo: then you can use functions from Ix like  inRange  instead of manual comparison
06:45:34 <sphinxo> How? ClaudiusMaximus 
06:46:10 <ClaudiusMaximus> instead of 0 <= ip && ip < length instrs , something like  inRange (bounds instrarray) ip
06:46:43 <sphinxo> awesmoe
06:47:00 <ClaudiusMaximus> probably not shorter to type, but clearer to read imo
06:47:11 <sphinxo> Thanks
06:48:59 <OverCoder> maerwald, this article is complicated to me, I am young to learn those in school D:, I am talking about things like f ⋅ f − 1 = 1 * Bf and f − 1 ⋅ f = 1C
06:49:11 <OverCoder> (Those weren't pasted correctly for some reason)
06:50:49 <OverCoder> I mean, things could be simplified some how :P
06:51:08 <maerwald> OverCoder: it's not so important to understand that part
06:51:20 <OverCoder> hm, okay
06:52:34 <maerwald> if you are dealing with ByteString which is meant to represent some sort of textual data, you need to handle it via the appropriate encoding/decoding functions
06:53:29 <maerwald> at which point, it might make more sense to use Data.Text
06:54:02 <OverCoder> hmm
06:54:45 <maerwald> ByteString is not just a faster version of String... the information it holds is different
06:57:18 <exio4> Text is the faster version :P
06:57:31 <hvr> ByteString is a faster version of [Word8]
06:57:49 <hvr> (with different semantics)
06:58:02 <hvr> s/semantics/complexities/
06:59:01 <maerwald> maybe the documentation of Data.ByteString.Char8 should say that it's generally not the module you want, unless you know what you are doing
06:59:31 <maerwald> in bold, so ppl actually read it :P
06:59:35 <StoneToad> lol
06:59:39 <StoneToad> does that really help?
07:00:17 <maerwald> can't hurt at least
07:06:46 <rydgel> Hey guys, I started to make a NES emulator (toy project). I was wondering if you guys have any examples of good implementation of similar project.
07:07:18 <rydgel> I'm currently struggling finding a good way to represent the CPU. I wonder if the ST monad fits.
07:22:13 <mitchty> why does text require integer-gmp now? this makes porting cross compilers way harder than it need be
07:23:45 <mitchty> https://gist.githubusercontent.com/mitchty/ea592033ac87870aeffd/raw/97a1483874b6c50eb9156ec9ad3aa5de9e687018/gistfile1.txt is what i'm noticing on a cross compiled ghc with integer-simple
07:24:55 <geekosaur> mitchty, changelog says there's a flag (but for integer-pure not integer-simple)
07:24:55 <mitchty> this is via bootstrap.sh for cabal 1.22.8.0 as a note
07:25:41 <rydgel> there is a flag "integer-pure" yes.
07:27:12 <mitchty> i'll file an issue for it in github then, but would be nice to be able to build cabal via a bootstrapped stage2 with integer-simple
07:27:25 <mitchty> just reverting to 1.22.7.0 for now
07:27:57 <geekosaur> "1.2.2.0 The integer-simple package, upon which this package optionally depended, has been replaced with integer-pure. The build flag has been renamed accordingly." (changelog)
07:28:37 <mitchty> well the bootstrap script needs to be able to detect that if the ghc compiling text doesn't have gmp support either way :)
07:29:01 <mitchty> that or text needs to detect it
07:30:32 <geekosaur> in theory flags should e autodetected such that if it can't build a build plan with integer-gmp then it should set the integer-pure flag itself and retry
07:31:33 <geekosaur> although if bootstrap is avoiing cabal-install / stack then I guess that wouldn't work and the bootstrap would have to retry Setup itself
07:31:53 <mitchty> well bootstrapping implicitly doesn't have anything but the cross compiled cabal package
07:33:00 <mitchty> this is basically me trying to build cabal for the target platform for the first time, stack at this point is not even on the radar
07:33:38 <dcoutts> mitchty: you might get more answers/help in #ghc
07:33:40 <mitchty> either way no worries, 1.22.7.0 worked, i'll keep using that for now
07:37:01 <mitchty> dcoutts: geekosaur will do thanks for the info!
07:43:12 <lingxiao> hey is anyone here good with coq that might help me with a proof over at #coq
07:45:35 * hackagebot process-streaming 0.9.1.0 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.1.0 (DanielDiazCarrete)
08:05:36 * hackagebot jukebox 0.2.3 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.3 (NickSmallbone)
08:22:43 <OverCoder> How come do I get this weird input/output? https://gist.github.com/MicroDroid/d8718dd55f58d82737fe
08:23:14 <OverCoder> I used to use Char8 without problems, but since I needed to transfer Unicode characters, I used Text
08:24:05 <OverCoder> What confuses me is how do I get weird characters before the first '->' in the program output
08:24:41 <OverCoder> Ah wait, fixed it!
08:24:50 <Zekka|Sigfig> What was it?
08:24:52 <OverCoder> I had to remove hSetEncoding stdout/conn utf8
08:25:14 <geekosaur> I was suspecting that was related to the byte order mark
08:25:40 <OverCoder> hmm
08:25:41 <OverCoder> Maybe
08:25:57 <geekosaur> don't use that unless you need to deal with certain older versions of windows that use an initial byte order mark (which is useless with utf8) to indicate a text file is utf8 instead of legacy code page
08:26:33 <geekosaur> byte order marks only make sense with utf16/utf32
08:27:21 <OverCoder> ah, hm
08:29:01 <OverCoder> Um, actually the problem was only in hSetEncoding conn utf8_bom, because I had to put set the encoding for stdout again, even thought the output of the program was the same, the output to the server was right, without setting the encoding for stdout I am not able to print Unicode
08:29:06 <geekosaur> (and in case that wasn't clear, that's the _bom part)
08:29:33 <OverCoder> Well, I don't even know the different between with BOM and without BOM :P
08:29:40 <geekosaur> I just told you
08:29:51 <OverCoder> Yeah I mean I did not
08:50:03 <emc2> so, I implemented static dictionaries based on FKS hashing.  They start to beat IntMap for lookups at 256 entries.
08:50:21 <emc2> switching to an unboxed buckets vector might improve things more
08:51:11 <emc2> next on my list is to experiment with an implementation based on linear probing + tabulation hashing
09:02:05 <EvanR> recursive do... its like time travel
09:02:44 <EvanR> but if you analyze the wrong thing at the wrong to try a paradox it conveniently freezes up instead
09:03:53 <EvanR> maybe in the next ghc it will have more support for paradoxes
09:05:44 <nitrix> EvanR: We must go deeper.
09:06:08 <lifter> Does anyone know what the GHC flag "-optc-03 does?
09:06:34 <SavinaRoja> I'd like to learn a little parsec, what is the hello world of parsing?
09:07:09 <maerwald> writing a parser yourself
09:07:14 <glguy> lifter: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html
09:07:16 <SavinaRoja> skip a comment, snag the rest?
09:07:39 <SavinaRoja> maerwald: indeed, but I was thinking along the lines of a good first parsing goal
09:07:53 <EvanR> parse lisp
09:07:53 <maerwald> SavinaRoja: imo, to understand it properly, you should really write your own parser type and basic combinators
09:08:11 <maerwald> it's not that difficult if it's just basic
09:08:13 <lifter> glguy, thanks
09:09:20 <SavinaRoja> maerwald: do you mean make my own parsing module?
09:09:28 <maerwald> yes, https://www.seas.upenn.edu/~cis194/spring13/lectures.html week 10 here starts with parsers/applicatives 
09:09:34 <maerwald> week 11 lets you use the parser
09:09:45 <EvanR> SavinaRoja: convert text into this data structure: data S a = Atom a | S [S a]
09:11:27 <SavinaRoja> err, will I be able to access that?
09:11:41 <NemesisD> looking for some advice on a problem I have. I've got a big chunk of monadic code that takes a long time to run. i'd like to be able to signal to it (perhaps with a TVar) to cleanly cancel and to define a point in the computation where it has reached a point of no return
09:12:38 <NemesisD> the simplest solution I can think of is to pepper lots of checks on the tvar into the code. i'd have to thread that all the way down to any sufficiently time consuming calls this monadic block may do. i know there's ContT but I'm apprehensive because I often hear about it being unsafe w/ other transformers
09:12:46 <SavinaRoja> I've seen "combinators" come up a few times now, I should read about them
09:13:26 <kurt11> I have a benchmark that is doing calculation and then outputting millions of characters, one by one through putChar. It's very slow. What would be a Haskell approved fast buffering alternative? Data.ByteString? Are there examples?
09:14:10 <NemesisD> kurt11: you may also want to look at bytestring's Builder module which is about providing efficient bytestring construction with O(1) appends
09:20:28 <axm> Hi, suppose I have a data type deriving Typeable and containing a field "_transportable :: ByteString" and I am considering to abstract _transportable with a type class - I am wondering how to retain the Typeable instance?
09:37:49 <kurt11> NemesisD: thanks! Builder looks perfect
09:44:02 <Vaelatern> When I compile a haskell program, and it pulls in libraries I cabal installed, do I need to cabal install the libraries on any machines that will run the compiled haskell?
09:45:32 <NemesisD> Vaelatern: i believe those are statically linked in but if those libraries had any system dependencies, the target machines will have to have those installed
09:46:02 <geekosaur> it depends on whether the libraries were built statically or dynamically, actually
09:46:20 <Jedai___> Vaelatern: no, Haskell libraries are statically linked by default 
09:47:03 <axm> isn't it both for libraries nowadays, but programs are statically linked by default?
09:47:26 <Jedai___> Vaelatern: on the other hand you may have shared C libraries to copy 
09:48:40 <Jedai___> axm: no, by default libraries are still statically linked though you can change that
09:58:41 <gromak> Can someone please tell me (in few words) what this signature means and where can I read about it (in more detail): `(~) * e SomeException => MonadThrow (Either e)`?
09:58:58 <Zekka|Sigfig> Wow! That’s a lot of punctuation
10:01:35 <KaneTW> gromak: it's equivalent to (SomeException ~ e, MonadThrow (Either e))
10:01:40 <axm> this is from http://hackage.haskell.org/package/exceptions-0.8.2.1/docs/Control-Monad-Catch.html ?
10:02:03 <KaneTW> (~) is the type equality constraint, (~) * says that the types it compares are both in *
10:03:37 <gromak> Yes, it's from there. Ok, thanks, looks like here is more detailed description https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/equality-constraints.html
10:08:38 <gromak> Hmm, one more question: is it different from `MonadThrow (Either SomeException)`?
10:10:01 <gromak> I don't understand what's the profit of that more complex signature
10:11:24 <kurt11> NemesisD: fyi, using ByteString.Builder and mappend seems to run slower that multiple putChar commands
10:13:07 <jedai> kurt11: That seems a bit strange (on the other hand as far as I know our IO is buffered anyway), could we see the code ?
10:15:41 * hackagebot neet 0.4.0.1 - A NEAT library for Haskell  https://hackage.haskell.org/package/neet-0.4.0.1 (hijiri)
10:18:45 <kurt11> Here is my code: http://lpaste.net/1919072829022666752. This is simply a port of a simple benchmark game program (I ported from the Java source): http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=fastaredux
10:18:59 <kurt11> jedai: thank you for looking :)
10:22:55 <kurt11> jedai: I'm going to lunch. Please use my name in any response and I'll read when I get back
10:24:30 <hiptobecubic> kurt11, jedai lambdabot can also relay messages for you.
10:27:36 <migimunz> Hi! I have functions f and g, both of which are of type State CState [NClause] (using Control.Monad.Trans.State). f does something with the state, and I'd like to call g with that state, and use its result and state to return from f. I'm not quite sure how to do this.
10:28:24 <migimunz> the best I can come up with is to do runState g get, and then construct my result and set the new state, is there a better way?
10:28:25 <NemesisD> migimunz: if they both run in State CState then both f and g already have access to the state
10:28:45 <NemesisD> migimunz: and if you run one first and it modifies the state, the latter will get the updated state
10:29:15 <NemesisD> i'm probably misunderstanding the question
10:30:06 <migimunz> NemesisD, No, I'm just misunderstanding how the state monad works. So far so good - but how do I access g's result? I've done val <- g, but that returns the complete state monad. I'd like to combine its result with the result I computed in f and return.
10:30:52 <migimunz> looks like evalState should do something of the sort
10:30:53 <NemesisD> migimunz: fresult <- f \n gresult <- g \n return (combine f g)
10:31:15 <NemesisD> newlines because i'm too lazy to paste a gist
10:31:38 <migimunz> NemesisD, well, g is parametrized by a value calculated in f, that's why f calls g. 
10:32:14 <axm> ok, my actual problem (apart from a weird type alias problem) seemed to be a too loose coupling of instances, I introduced an unused "witness" parameter  to couple some methods which need to work on the same type (or rather: need one instance they can work with) - are there best practices for that documented somewhere?
10:32:16 <migimunz> I'll paste this, but it's quite messy, I hoped to explain it better
10:32:37 <NemesisD> migimunz: you could do: fresult <- f \n g fresult, or if you want to get fancy: g =<< f
10:33:42 <NemesisD> migimunz: so fresult's type will be [NClause], not State CState [NClause]
10:33:48 <migimunz> NemesisD, here's what I'm trying to do https://gist.github.com/migimunz/7edd79e7d34288afa60d
10:33:51 <NemesisD> because you are using monadic binding
10:35:11 <migimunz> Does that demonstrate my problem better? 
10:35:13 <NemesisD> migimunz: your type annotation :: [NClause] i think is causing you problems
10:35:33 <migimunz> NemesisD, it is, it fails, I wrote it because that's what I expect to get somehow
10:35:55 <NemesisD> migimunz: if i'm parsing that correctly, its saying that expandLong xs's type is [NClause], it isn't. its type is State CState [NClause], *however* rest's type *is* [NClause]
10:36:08 <NemesisD> have you tried removing that type annotation?
10:36:29 <migimunz> ooh, I see, so the type annotation refers to the function, not to rest
10:36:32 <migimunz> I'll try that right away
10:36:56 <NemesisD> yes, when you use <- you're doing a monadic bind, so the left side of <- does not carry the type of the monad you're operating in
10:37:44 <migimunz> ah, ok that makes sense. I expected the bound value to be the result. Thank you!
10:37:47 <NemesisD> its why you can do stuff in IO like str <- getLine, str is :: String, but you're operating in a do block of IO, so at the end of the block everything will be wrapped in IO
10:37:52 <NemesisD> no problem :)
10:42:26 <shanemikel> is there a way to get ghc to look in my sandbox for libraries without using cabal exec? I am trying to figure out how to get atom editor's haskell ide pluins to resolve imports
10:42:56 <axm> you can give the package-db as param
10:45:33 <axm> -package-db `find .cabal-sandbox package.cache | dirname` or so
10:59:30 <shanemikel> is it possible to do this with an environment var?
10:59:40 <axm> arg, I need Generic, too: Can't make a derived instance of Generic - must not have unlifted or polymorphic arguments - is there a workaround for having a Generic data type containing type classes?
11:00:00 <axm> hm, I do not know how cabal-sandbox sets up its environment
11:00:14 <axm> ah, you mean for ghc
11:03:05 <axm> GHC_PACKAGE_PATH, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html
11:04:27 <axm> have not tried that thoug
11:05:48 <SavinaRoja> interesting, that upenn course site is public
11:10:42 * hackagebot varying 0.4.0.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.4.0.0 (SchellScivally)
11:10:48 <OverCoder> Okay I have a functional thinking problem (coming for Java, C/C++, and others), I have my IRC bot up and running, for example, users might query .chanusers, I want the bot to print users names in the current channel, but, IRC sends users list upon joining the channel, in imperative languages, I'd store a HashMap with Channels as keys and User lists as values, but in Haskell, we have immutable variables, what should I do 
11:10:49 <OverCoder> in this case?
11:12:12 <kadoban> I'd store a HashMap with Channels as keys and User lists as values. (actually I'd probably use a Set of Users, but whatever)
11:12:15 <opqdonut> you can still have state, you just need to be explicit about it
11:12:35 <opqdonut> you can either use the State monad, which is just a nicer way of passing pure values around
11:12:45 <OverCoder> o
11:12:52 <opqdonut> or you can use IORefs which are mutable "boxes" in the IO monad
11:13:01 <OverCoder> So we can yet still have some mutability
11:13:17 * OverCoder googles those
11:13:19 <OverCoder> Thanks guys
11:13:30 <opqdonut> you might want to look up "real world haskell"
11:13:33 <kadoban> Sure. Haskell just requires you actually encode in the type system that you're doing it.
11:13:38 <Cale> OverCoder: There's also just the possibility of having the main loop consist of a function with parameters that change over time
11:13:53 <opqdonut> right, no need for special machinery as such
11:13:54 <OverCoder> hmmm
11:14:20 <Cale> OverCoder: The parameters to a function can of course be different every time it is invoked, and it can invoke itself with new arguments for those parameters.
11:14:55 <Cale> OverCoder: But in a multi-threaded setting, you probably really want some IORefs and/or MVars
11:14:58 <OverCoder> Ooh, gotcha
11:15:01 <Cale> and/or STM things
11:15:18 <OverCoder> Ayy, multi-threading is a lot for a beginner in a new language haha :P
11:15:36 <OverCoder> But yeah I got it
11:15:53 <jle`> good thing multi-threading in haskell is easy and natural compared to how it is in other languages :)
11:16:07 <jle`> but yeah i might save it for a second or third project instead of a first one
11:16:22 <OverCoder> Yeah I've seen that in LYAH
11:16:52 <OverCoder> Anyways, thank you all for your help :)
11:17:56 <SavinaRoja> in a triple bar glyph, what does it mean when the distance from mid bar to top bar is twice the distance from mid bar to bottom bar
11:18:23 <SavinaRoja> as in 5.1.1.1 of https://wiki.haskell.org/Combinatory_logic
11:19:39 <shanemikel> anybody else using atom with cabal sandboxes?
11:22:21 <ReinH> SavinaRoja: nothing.
11:22:48 <Cale> OverCoder: If you're writing a network server, you're definitely going to want to forkIO a thread for each client.
11:23:07 <ReinH> OverCoder: Simon Marlow's free book covers this
11:23:13 <ReinH> you should definitely read it
11:25:25 <OverCoder> Cale, hmm, yeah that's the same way how we run a server in imperative languages, we run an instance of a Thread upon a client connection
11:25:42 <OverCoder> ReinH, hm, I'll look it up
11:26:27 <ReinH> @google Parallel and Concurrent Programming with Haskell
11:26:29 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
11:26:29 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
11:27:45 <OverCoder> hmm
11:29:09 <EvanR> so Arrow
11:29:16 <EvanR> what is up with the tuples?
11:29:44 <EvanR> is there another class with a more general type combiner
11:31:20 <rcosta> hi
11:32:08 <rcosta> Out of curiosity, are there any Portuguese speaking Haskellers around here?
11:34:33 <OverCoder> Why are you asking that
11:35:47 <rcosta> just curious ;)
11:38:08 <SavinaRoja> rcosta: spanish, so portuguese makes some approximate sense
11:46:52 <jle`> EvanR: they're sort of the natural choice for cartesian products
11:46:57 <jle`> in haskell at least
11:50:29 <SavinaRoja> do most people using haskell come to it from a strong background in the relevant maths?
11:50:56 <jle`> definitely not
11:51:23 <SavinaRoja> because while I am enjoying all the things I am learning, I am astounded by how very much I have never encountered
11:51:26 <jle`> although, it depends on what you mean by 'relevant maths'
11:51:36 <jle`> there isn't much relevant math needed when using haskell
11:51:43 <jle`> it's helpful to know how addition and multiplication works
11:51:52 <jle`> but ... what other math were you thinking of?
11:52:16 <SavinaRoja> category theory, lambda calculus, combinatory logic... these things are new to me
11:52:20 <jle`> ah
11:52:28 <jle`> they're definitely not things people normally are exposed to
11:52:35 <jle`> and they're also not really relevany to learning haskell
11:52:43 <jle`> *relevant
11:52:56 <jle`> they're sort of just fun things haskellers as a community like to talk about
11:53:07 <hpc> bits of each are needed to get beyond the basics, but you'll generally pick them up quickly
11:53:22 <jle`> every community has their fun topics they like to talk about :)
11:53:49 <jle`> but you definitely can start haskell without any category theory and use it proficiently without ever learning category theory
11:54:00 <mmachenry> SavinaRoja: I second that. It's more of a community mutual interest that is related to Haskell than it is Haskell or necessary to learn Haskell. In short, Haskellers have a shared interest in the deeper aspects of our language more so than most languages.
11:54:17 <jle`> i wouldn't even call category theory a 'deep aspect of haskell language'
11:54:22 <dogcat> I am supporting domain specific language in haskell, dynamically dispatched, using the RWS monad for the evaluator...is there a faster strategy?
11:56:47 <dogcat> we could go down to LLVM, but I'm looking to make a smaller speed gain using something like lenses
11:57:23 <dogcat> has anyone built a haskell interpreter with a faster eval monad than RWS?
11:59:15 <EvanR> what is the speed of a monad?
11:59:22 <EvanR> unladen
11:59:47 <dogcat> how long it takes to transform internal state
11:59:49 <dogcat> ?
11:59:58 <mmachenry> EvanR: Do you mean African or European monad? 
12:00:08 <mniip> RWS goes to about 11 hash-bytes per square gigahertz
12:00:39 <dogcat> :mniip what if the state as 100's of MB of data?
12:00:57 <dogcat> :mniip, thanks
12:01:03 <mniip> (I was being sarcastic)
12:01:06 <hpc> have you tried turning it off and on again?
12:01:11 <mniip> you should care about the way you store and transform your data
12:01:27 <dogcat> :mniip, this is start up engineer, we are lucky we can use haskell
12:01:31 <mniip> there isn't a "monad that will magically make code faster"
12:02:10 <dogcat> but is there some streaming, or alternative processing style?
12:02:46 <dogcat> even an example of an interpreter that does something alternative to RWS monadic binding
12:03:04 <EvanR> is mzero and zeroArrow supposed to be a monoid identity with MonadPlus?
12:03:08 <EvanR> and ArrowPlus
12:03:38 <Welkin> EvanR: I believe so
12:03:50 <Welkin> don't know about ArrowPlus though
12:03:56 <Welkin> but it sounds right
12:03:58 <jle`> dogcat: write it with RWS first, benchmark it to see if it is good enough, and if not, try optimizing it
12:04:16 <dogcat> :jle` that's exactly what we are doing
12:04:54 <dogcat> i thought I might be missing some better way, but it looks like we should clean up the algorithmic complexity on everything first
12:05:45 <hpc> that's generally the way to go
12:06:20 <hpc> you've given us very little to go on, so the best answers we can give are the most generic, like "use concurrency", "use strictness", or whatever
12:06:30 <hpc> nothing that would give more than a constant factor's improvement anyway
12:06:34 <dogcat> :hpc, yea, sorry
12:06:46 <hpc> see what parts of your performance are unacceptable and focus on those
12:06:58 <dogcat> specifically, would using a library like lenses or conduit be able to help?
12:07:09 <hpc> maybe!
12:07:54 <hpc> lens is a fairly specialized abstraction (by which i mean you won't "write a program in lens" the way you would "write a program in happstack")
12:07:55 <Welkin> I think erisco wrote a DSL a little while back and used pipes to great effect
12:08:24 <hpc> conduit is a streaming IO library
12:08:33 <hpc> if your DSL involves streaming IO, it might be a natural fit
12:08:55 <Zekka|Sigfig> It sounds kind of like you’re trying to find fast technologies instead of a fast solution to your problem
12:09:12 <hpc> er, not specifically IO
12:09:35 <hpc> it'll help for many types of data streams, but you still need to have that be an element of your problem
12:12:28 <Zekka|Sigfig> dogcat: FWIW, if constant factor performance is a huge deal to you I’m not sure if I would recommend Haskell — there is very fast Haskell around but afaict a lot of the optimizations the compiler does are based on adhoc rewriting rules and a lot of the fast code was written by people who first had to learn how Haskell was implemented
12:13:29 <Zekka|Sigfig> Most common Haskell features won’t make your program more than a constant factor slower, but I would not want to be the guy who has to optimize around that constant factor. 
12:13:53 <hpc> haskell's a constant factor slower than C in many ways, but faster than a lot of other languages
12:14:10 <hpc> i would put haskell's weakness more at timing-sensitive code, due to being garbage collected
12:15:47 <Zekka|Sigfig> What C has going for it is that afaik it’s not that hard to make micro-level optimizations to C code, and there’s a limited repository of control structures — a lot of Haskell optimization is based on actual mathematical insight
12:16:18 <Zekka|Sigfig> Like consolidating maps and folds — that doesn’t follow obviously if you’re a computer. Humans have to tell Haskell how to do that
12:16:24 <EvanR> im sure there are people who balk at C when the time comes to do micro optimizations
12:16:30 <Zekka|Sigfig> C has cases like that too but there’s a finite pre-specified number of them
12:17:00 <Cale> There are things which take place when you use ByteString which are obnoxious as hell to do by hand in C.
12:17:29 <EvanR> like what
12:17:41 <mniip> LIKE THE ENTIRE THING
12:17:44 <hpc> lol
12:17:45 <Cale> Mostly stuff related to breaking things into chunks
12:18:23 <Cale> There are some microbenchmarks on which naive-looking ByteString code will beat naive-looking C code
12:18:28 <Zekka|Sigfig> FWIW, I think it’s way easier to write slow code in C by accident than it is in Haskell.
12:19:29 <Zekka|Sigfig> someone still has to have the math insight to write fast code — it’s just that in C you can’t blame the compiler for not having it
12:20:13 <Cale> (or the library developer, in the case of RULES stuff)
12:21:49 * dgpratt wonders if cabal really needs ghc for "cabal init" or is just being pessimistic
12:22:09 <hpc> it does, it can auto-populate build depends
12:22:23 <dcoutts> dgpratt: iirc it looks at imported modules to work out deps
12:22:46 <dgpratt> hpc, dcoutts ok, thanks
12:22:47 <dcoutts> in principle cabal can do that with any compiler, but not sure if cabal init does
12:22:59 <hpc> it actually bugs me that there's not a special command for "infer depends"
12:23:32 <dgpratt> I want "infer whatimean"
12:24:35 <Geraldus> hi friends!  What is stack's alternative to `ghc-pkg list` command?  I want to unregister some old versions of my local packages.
12:25:32 <jle`> shouldn't your snapshot figure that out for you?
12:25:39 <luigy> should be the same... just that it should be run under `stack exec -- ghc-pkg list`
12:27:01 <jle`> oh i see, local packages
12:27:48 <Geraldus> jle`: hi!  I know I can remove them manually, but I guess there is a better way to do this
12:35:57 <siriusbtx> (noob here) I want to count the number of occurenses in a list. E.g [1,1,1,4,4] -> [0, 3, 0, 0, 2]. So there are zero 0's. Three 1's. etc ...
12:36:02 <siriusbtx> how would I do this?
12:36:58 <jle`> i'd use a Map
12:37:41 <EvanR> you would?
12:38:01 <EvanR> for representing the answer
12:39:00 <exio4> this is basically a histogram
12:39:00 <mmachenry> EvanR: No I imagine that would be jle`'s intermediate data structure. Probably a solid idea.
12:39:11 <Cale> map (\x -> (head x, length x)) . group . sort
12:39:11 <jle`> i think it'd make sense to represent the ansswer as a map too
12:39:28 <jle`> that's nice too :)
12:39:30 <EvanR> the simplest way to calculate it is with a group . sort
12:39:32 <exio4> Cale: M.fromList . [...]
12:39:47 <siriusbtx> are you guys answering my question? :p
12:39:48 <mmachenry> Well siriusbtx did phrase the question in terms of wanting a list back but perhaps he doesn't specifically care.
12:39:53 <Cale> Yeah, you can zip the list with  repeat 1
12:39:55 <mmachenry> siriusbtx: Yes
12:40:01 <siriusbtx> idc
12:40:02 <Cale> and then fromListWith (+)
12:40:24 <Cale> siriusbtx: Well, we're doing the tricky part :)
12:40:24 <jle`> > M.fromListWith (+) [(x, 1) <- [1,1,1,4,4]]
12:40:27 <lambdabot>  <hint>:1:28:
12:40:27 <lambdabot>      parse error on input ‘<-’
12:40:27 <lambdabot>      Perhaps this statement should be within a 'do' block?
12:40:28 <siriusbtx> its just important that if a value does not appear in the list, it's index will be 0
12:40:32 <jle`> > M.fromListWith (+) [(x, 1) | x <- [1,1,1,4,4]]
12:40:34 <lambdabot>  fromList [(1,3),(4,2)]
12:40:41 <jle`> so there's 3 ones, and 2 4's
12:40:58 <jle`> > M.fromListWith (+) [(x, 1) | x <- [4,7,4,5,6,2,2,2,6,4,5,5,3,4,1,6,8,3,9,2,4,1,1]]
12:41:01 <lambdabot>  fromList [(1,3),(2,4),(3,2),(4,5),(5,3),(6,3),(7,1),(8,1),(9,1)]
12:41:05 <daakr> it's nice how you can drop an arbitrary list-processing question in here, and 5 minutes later you have a point-free oneliner, that might or might not use lens
12:41:18 <Cale> heh
12:41:42 <jle`> siriusbtx: you can get occurences from a map with M.lookupDefault 0
12:41:51 <siriusbtx> mhm k
12:42:00 <jle`> > let occurencesMap = M.fromListWith (+) [(x, 1) | x <- [4,7,4,5,6,2,2,2,6,4,5,5,3,4,1,6,8,3,9,2,4,1,1]] in M.lookupDefault 0 9
12:42:02 <lambdabot>  Not in scope: ‘M.lookupDefault’
12:42:02 <NemesisD> could anyone take a look at http://lpaste.net/7782755558129401856 I'm trying to use ContT for early termination. the paste works but i'm wondering if "checkpoint" can be written in terms of MonadCont and callCC
12:42:04 <jle`> aw
12:42:48 <jle`> > let occurencesMap = M.fromListWith (+) [(x, 1) | x <- "akeonutrfaisopefdjsadfkdjddfksa;fjiasdf"] in M.findWithDefault 'a' 9
12:42:50 <lambdabot>  <Map Integer Char -> Char>
12:43:03 <jle`> > let occurencesMap = M.fromListWith (+) [(x, 1) | x <- "akeonutrfaisopefdjsadfkdjddfksa;fjiasdf"] in M.findWithDefault 0 'a' occurencesMap
12:43:05 <lambdabot>  5
12:43:11 <jle`> > let occurencesMap = M.fromListWith (+) [(x, 1) | x <- "akeonutrfaisopefdjsadfkdjddfksa;fjiasdf"] in M.findWithDefault 0 'f' occurencesMap
12:43:13 <lambdabot>  6
12:43:20 <jle`> > let occurencesMap = M.fromListWith (+) [(x, 1) | x <- "akeonutrfaisopefdjsadfkdjddfksa;fjiasdf"] in M.findWithDefault 0 'z' occurencesMap
12:43:23 <lambdabot>  0
12:50:47 * hackagebot esqueleto 2.4.3 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.4.3 (FelipeLessa)
13:10:47 * hackagebot cli 0.1.0 - Command Line Interface  https://hackage.haskell.org/package/cli-0.1.0 (VincentHanquez)
13:34:46 <andromeda-galaxy> Are there any safe ways to use reallyUnsafePtrEquality# ?   If there aren't why is it exposed as a primop at all?
13:35:19 <csd_> how do i get a value out of an arrow, e.g. addA (arr $ \x -> 1) (arr $ \x -> 2) ?
13:46:38 <EvanR> csd_: in general i dont think you can
13:49:09 <EvanR> > (arr (\x -> 3)) :: (a -> Int)) 99
13:49:12 <lambdabot>  <hint>:1:30: parse error on input ‘)’
13:49:26 <EvanR> > (arr (\x -> 3) :: (a -> Int)) 99
13:49:28 <lambdabot>  3
13:49:43 <EvanR> only works with function arrows
13:51:37 <shanemikel> what do I need to hide in order to implement the functor instance of either e?
13:51:52 <shanemikel> I'm trying to follow https://wiki.haskell.org/Typeclassopedia
13:52:18 <shanemikel> I would just rewrite the data type with a different name, but there are tons of exercises like that in there
13:53:05 <ReinH> shanemikel: I suggest defining class MyFunctor f where myFmap :: (a -> b) -> f a -> f b and then defining MyFunctor instances.
13:53:38 <shanemikel> oh, lol.. yeah, that's easier
13:53:45 <ReinH> :)
13:54:29 <ReinH> I really appreciate that the typeclassopedia has exercises.
13:54:33 <ReinH> Exercises are great.
13:55:40 <ReinH> Exercise a is particularly nice. For comparison, you could also try writing an instance for data InvITree a = Leaf (a -> Int) | Node [InvItree a]
13:55:43 <csd_> EvanR: what do you mean? why not?
13:56:10 <csd_> are arrows only good for effects ?
13:56:14 <bitemyapp> ReinH: use Emacs lately?
13:56:14 <EvanR> csd_: what the type of value "inside" of an a b c where a is an arrow?
13:56:19 <ReinH> EvanR: Well, obviously you can't apply an arrow. Arrows are not functions.
13:56:55 <csd_> EvanR: well if addA returns an arrow, i'm thinking pattern match and return the third value
13:56:59 <EvanR> ReinH: yes, i was suggesting a possible way to get the value out of csd_'s arrow... and why it doesnt work in general
13:57:04 <ReinH> At least, not generally.
13:57:05 <csd_> where a b c is some arrow
13:57:15 <ReinH> Well, that only works because you specialized to (->)
13:57:32 <ReinH> csd_: pattern match on what?
13:57:37 <EvanR> csd_: so that would only make sense if your arrow type held a value of type c for any arrow value
13:57:46 <EvanR> which it might not
13:58:26 <csd_> i specifically have in mind the function addA f g = f &&& g >>> arr (\ (y, z) -> y + z)
13:58:44 <EvanR> are you specifically thinking of functions/
13:59:00 <csd_> yeah
13:59:05 <EvanR> oh ;)
13:59:30 <EvanR> the only thing you can do with a function is apply it to something
14:00:50 <csd_> i understand the composability of arrows but how to actually use them is eluding me
14:01:11 <EvanR> it depends on the particular arrow type
14:01:30 <scshunt> are we talking Arrows or categorical arrows?
14:01:45 <EvanR> same story as monads, and applicatives
14:02:05 <csd_> scshunt: good question; i dont know :)
14:03:53 <csd_> oh i see what my problem is
14:04:46 <csd_> it's confusing because the type i get back is `cat a c` but it's actually a function
14:05:05 <EvanR> cat = (->) in your case
14:05:50 <csd_> fun stuff
14:07:30 <csd_> what should i read after i'm done reading the typeclassopedia; i've read history of haskell; wadler's initial monad paper; and generalizing monads to arrows. looking to broaden and solidify my understanding of types
14:07:59 <csd_> i'm thinking of reading that paper on applicatives that i dont know the name of offhand
14:08:22 <EvanR> wait arrows arent a generalization of monads
14:08:24 <hodapp> csd_: read hasochism!
14:08:58 <hodapp> EvanR: http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf ?
14:09:31 <EvanR> i thought you could do more with monads
14:09:43 <geekosaur> depends on the definition of "more"
14:09:53 <EvanR> and you had to add ArrowApply to get back to monads from arrows
14:10:46 <EvanR> without ArrowLoop... is an arrow turing complete? 
14:11:15 <EvanR> if the question makes no sense, just shoot me ;)
14:11:38 <csd_> hodapp: i think thats a little too esoteric for me right now
14:12:00 <csd_> althoug im sure its very interesting. just not practical seeing as im not installing liquid haskell any time soon
14:13:18 <EvanR> csd_: checked out TAPL?
14:13:25 <csd_> what's TAPL
14:13:57 <geekosaur> @where tapl
14:13:57 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:14:00 <geekosaur> _Types and Programming Languages_
14:14:26 <csd_> i have not read that no
14:19:19 <dogcat> :EvanR, I'm going through TAPL right now, so good!
14:20:13 <dogcat> By the end of my time with it, my version will be highlighted with all the part relevant to Haskell's implemention of System-Fomega
14:20:19 <nitrix> Question, Just is a value constructor, Maybe is a type constructor, Functor Maybe is a type class, then what is Functor?
14:20:26 <nitrix> A type class constructor?
14:20:43 <dogcat> a Functor is a structure that implements fmap
14:20:49 <notdan> Functor is a type class
14:20:52 <nitrix> dogcat: You haven't read the question.
14:20:54 <notdan> Functor Maybe is an instance 
14:20:59 <notdan> of a type class
14:21:01 <nitrix> notdan: Gotcha, thanks.
14:21:20 <EvanR> :k Functor
14:21:21 <lambdabot> (* -> *) -> Constraint
14:21:59 <EvanR> Constraint constructor ;)
14:22:03 <dogcat> :nitrix, ambiguous no right answer :)
14:22:27 <nitrix> EvanR: I like that c:
14:22:44 <geekosaur> dogcat, given the list, there was a fairly obvious intent
14:22:56 <nitrix> EvanR: Does (=>) has a type?
14:23:07 <nitrix> (=>) :: Contraint -> ... ? 
14:23:25 <EvanR> it maps to Dictionary ->
14:23:26 <alkabetz> nitrix: It has a kind; it should be Constraint -> * -> *
14:23:29 <dogcat> haha, i just explained functors to a coworker, and did jump the gun!
14:23:32 <nitrix> :k (=>)
14:23:34 <lambdabot> parse error on input ‘=>’
14:24:30 <bitemyapp> :k Num
14:24:33 <lambdabot> * -> Constraint
14:24:38 <bitemyapp> :k Num Int
14:24:39 <lambdabot> Constraint
14:24:40 <EvanR> Foo a => a -> a will make sure the Foo dictionary and anything derivable from it are available at runtime
14:25:02 <EvanR> so its like an argument
14:25:46 <csd_> why is there no true haskell implementation for the jvm. is it just not possible? (i'm aware of frege)
14:25:46 <EvanR> someone was telling me its implemented totally different in idris though...
14:26:08 <dogcat> in terms of type theory, => is more like a declaration of subtyping constraints
14:26:20 <EvanR> no, its not subtyping
14:26:46 <dogcat> oh, what would be the type theoretical definition?
14:26:55 <geekosaur> csd_, there used to be (yhc could target the JVM). mostly it's performance and lack of interest among implementors
14:26:55 <EvanR> im not sure
14:28:06 <csd_> interop would be a PITA i guess
14:28:18 <EvanR> check out java-bridge ;)
14:28:50 <notdan> it would be a constraint 
14:28:58 <notdan> typeclass constraint
14:29:09 <dogcat> yea, it's a declaration that what came before is a typeclass constraint
14:29:14 <dogcat> lol what :notdan said
14:29:19 <geekosaur> interop would be via the FFI, the same way ghcjs can use Javascript
14:29:37 <geekosaur> dogcat, not always a typeclass constraint; consider a ~ b
14:31:17 <wtmr> its kind of like a context
14:31:28 <EvanR> i guess the argument interpretation doesnt help with the a ~ b case
14:31:36 <geekosaur> context is actually what the Haskell Report calls it
14:31:45 <dogcat> what does "tilde" do?
14:31:45 <wtmr> oh yeah?
14:31:48 <wtmr> makes sense
14:31:54 <wtmr> ~ means two types are "equal"
14:31:57 <dogcat> okay
14:32:42 <EvanR> when a ~ b, a and b are the same type
14:33:16 <EvanR> like Int and Int
14:33:55 <m0rphism> hi, does anyone know how to use the `lens` package to derive `fooL` from `data Foo = Foo { foo :: Int }`?
14:33:56 <dogcat> I've never seen that before, is it used for ad-hoc polymorphism, or part of some pragma?
14:34:08 <EvanR> probably = was used by something else when ~ was invented ;)
14:34:38 <m0rphism> `makeLenses ''Foo` requires the field to be named `_foo` and derives the lens `foo`.
14:34:57 <shachaf> There's some makeLenses variant in the TH module that takes a configuration.
14:35:11 <dogcat> haha, is equality relationship different between terms and types?
14:35:28 <shachaf> You can also write the lens by hand -- fooL f (Foo x) = Foo <$> f x
14:38:11 <m0rphism> shachaf: cool thanks, I think I'll go with the by-hand variant for now :)
14:38:28 <dogcat> has anyone used lenses to implement mutability in a DSL?
14:38:56 <NemesisD> is there any way to define checkpoint in terms of MonadCont/callCC with the same semantics? http://lpaste.net/7782755558129401856 I tried to replace it but it doesn't terminate the action
14:51:35 <daakr> is there something like lenses for IO? in particular, is there something like a lens for StablePtrs?
14:51:53 <daakr> (no I am not sure what I mean by that)
14:54:44 <mniip> is 'ConstT r m a = m r' a thing?
14:57:38 <Shockk> hmm I have a quick question; if I'm defining a data type, can I define its constructor like so? :
14:57:49 <Shockk> data ChessPiece = ChessPieceType `Of` ChessPlayer
14:58:31 <wtmr> No
14:58:46 <Shockk> ah, thanks
14:59:34 <wtmr> infix data constructors need to start with :
14:59:37 <Shockk> or, well hm it built
14:59:41 <Shockk> weird
14:59:46 <wtmr> and maybe they can only contain symbols
15:00:10 <EvanR> that is funny
15:00:44 <wtmr> does that actually work
15:00:47 <wtmr> weird
15:00:49 <Shockk> it does apparently
15:00:59 <Shockk> I didn't think it would but wanted to check
15:01:32 <Shockk> maybe it treats `` around a constructor name the same way it treats `` around a function name for infix notation
15:02:39 <Shockk> I think it's probably a bad idea for me to have a data constructor with the name "Of" anyway, but was just curious
15:02:53 <wtmr> well data constructors are just functions on data 
15:02:55 <wtmr> so it makes sense
15:03:02 <Shockk> oh, that's true
15:06:22 <EvanR> Shockk: heh... thats the ocaml syntax
15:06:54 <Shockk> EvanR: interesting
15:07:02 <EvanR> type foo = Nothing | Int of int | Pair of int * int | String of string
15:07:14 <EvanR> not the same interpretation though ;)
15:07:21 <daakr> wtmr: well, constructors aren't just functions... close though...
15:07:30 <EvanR> :t Just
15:07:32 <lambdabot> a -> Maybe a
15:07:34 <EvanR> ho ho!
15:07:47 <Welkin> santa!?
15:07:48 <Shockk> hah
15:07:58 <wtmr> "just" functions
15:08:27 <EvanR> i got yer just function right there
15:08:49 <wtmr> i guess you would say for each data constructor there is a corresponding injection 
15:09:18 <geekosaur> next up, fromJust -> unJust
15:09:33 <wtmr> is that what you mean daakr?
15:09:37 <daakr> can everyone stop being in such a good mood?
15:09:52 <daakr> wtmr: i suppose that would be more accurate, yes
15:10:46 <EvanR> wtmr: well, (,) 
15:10:52 <Spaceghost> Clint.
15:11:02 <EvanR> an injection to somewhere but not perhaps where you thought
15:11:07 * hackagebot print-debugger 0.0 - Print debugging with stack trace for Haskell (formatted for the IDE).  https://hackage.haskell.org/package/print-debugger-0.0 (johnreedlol)
15:11:29 <Shockk> hmm, with the linear package, is there an advantage to using Linear.V4 as opposed to Linear.V (n-D Vectors)?
15:13:06 <sm> print-debugger, nice!
15:13:35 <Shockk> @ edwardk if you're here
15:29:30 <bergey> Shockk: The low-dim vectors have a bunch of conveniences - lenses, swizzling, the camera functions for M44.  I don't think V has those.
15:30:48 <Shockk> bergey: ahh I see
15:30:49 <Shockk> thanks
15:46:08 * hackagebot elm-init 1.0.3 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.3 (justus)
15:49:30 <jbalint> is there any function to get text source code of the current module?
15:50:10 <EvanR> readFile "path/to/source/of/current/module"
15:51:01 <EvanR> i think there is TH to insert the module name at least into source
15:51:09 <jbalint> TH?
15:51:13 <geekosaur> jbalint, compiled code doesn't necessarily have source available
15:51:25 <jbalint> ah shucks, i thought i was on the #emacs channel. haha sorry!
15:51:44 <jbalint> geekosaur: yes, it makes much less sense here...
15:51:52 <Welkin> jbalint: I read your name as "jailbait"
15:52:01 <jbalint> Welkin: you're not the first!
15:52:08 <Welkin> haha
15:52:15 <Welkin> causes me to do a double-take
15:57:43 <monochrom> @hoogle f a -> Proxy a
15:57:46 <lambdabot> Did you mean: f a -> Proxy
15:57:46 <lambdabot> Test.QuickCheck.Modifiers getBlind :: Blind a -> a
15:57:46 <lambdabot> Test.QuickCheck getBlind :: Blind a -> a
16:02:53 <`Guest00000> is there a library which turns tuples into lists and back?
16:03:17 <EvanR> it canna be done
16:03:38 <EvanR> tuples can have different types and lists cant
16:06:12 <maerwald> EvanR: well, depends how you look at it
16:06:33 <ReinH> bitemyapp: yeah, emacs is my daily driver now. Spacemacs, specifically.
16:07:14 <EvanR> tuplesIntoLists3 :: (a,b,c) -> [?]
16:07:25 <hexagoxel> does Turtle have no method for capturing stdout, stderr and exitCode?
16:08:17 <ReinH> hexagoxel: I've found the shell scripting libraries to often be too restrictive, so I usually end up using
16:08:19 <ReinH> @hackage process
16:08:19 <lambdabot> http://hackage.haskell.org/package/process
16:08:32 <ReinH> or @hackage process-conduit in exceptional cases
16:08:35 <maerwald> EvanR: https://wiki.haskell.org/Heterogenous_collections#Existential_types it's not really what a tuple can do, but 
16:08:38 <ReinH> @hackage process-conduit
16:08:39 <lambdabot> http://hackage.haskell.org/package/process-conduit
16:08:40 <enthropy> > [(1,2) ^.. each, (1,2,3,4) ^.. each ]
16:08:43 <lambdabot>  [[1,2],[1,2,3,4]]
16:09:07 <hexagoxel> ReinH: indeed, that would be the fallback.. but disappoint.
16:09:35 <ReinH> hexagoxel: Maybe it can, but there is eventually *something* that the DSL you are provided with won't do ime.
16:09:35 <EvanR> maerwald: yes, thats neither tuples or lists
16:09:47 <maerwald> EvanR: ?
16:09:50 <maerwald> it ios list
16:09:52 <ReinH> `Guest00000: you shouldn't think of tuples and lists as being similar enough things that conversion even makes sense.
16:10:15 <ReinH> iow the answer is really: instead of wanting to do that, do not want to do that.
16:10:47 <ReinH> They are notationally vaguely similar, but otherwise not at all.
16:11:15 <ReinH> (a,b,c) is the same as data Triple a b c = Triple a b c, which is nothing at all like a list.
16:11:24 <hexagoxel> ReinH: well, if it allows me to call bash and capture the raw output, it cant be less powerful than some cumbersome bash wrapper.
16:11:27 <`Guest00000> (a, a, a)
16:11:30 <enthropy> that "each" is from lens lets you do conversions if the tuple has all elements of the same type
16:11:35 <`Guest00000> a fixed length list
16:11:41 <hexagoxel> but really, that should be the lower limit.
16:12:08 <mauke> (a, (a, (a, ()))) is closer to that
16:12:09 <EvanR> its really a vector
16:12:17 <enthropy> > (undefined :: (Int,Int)) & partsOf each .~ [1,2]
16:12:19 <lambdabot>  (1,2)
16:12:33 <ReinH> each :/
16:12:33 <`Guest00000> originally i wanted to map (a, a, a) -> (b, b, b) 
16:12:50 <ReinH> each is cheating :p
16:13:04 <maerwald> EvanR: I don't really know what you are talking about, the example in my link however is a list
16:13:14 <ReinH> `Guest00000: you'd be better off writing your own data type instead of using a tuple
16:13:24 <`Guest00000> omg
16:13:24 <ReinH> writing your own data types is a good thing
16:13:37 <EvanR> `Guest00000: if you had data Three a = Three a a a, then you can auto derive Functor and just use fmap
16:13:45 <`Guest00000> hm...
16:14:16 <`Guest00000> okay
16:14:21 <ReinH> Haskell's ADTs specifically exist so that you can write custom structures to fit your needs easily rather than having to shoehorn your data into something that slightly fits. That's the point.
16:14:23 <EvanR> maerwald: its not data [] a = [] | a : [a]
16:15:09 <`Guest00000> yes, i agree, but for simple cases it seems to me that writing new types is bloating code
16:15:20 <maerwald> EvanR: hlist :: [Showable] -- is not a list?`
16:15:26 <EvanR> then write (\(x,y,z) -> (f x, f y, fz)) ;)
16:15:49 <geekosaur> maerwald, it's a list but the only thing you can do with its elements is show
16:15:56 <maerwald> I am aware
16:16:09 <EvanR> i thought you were talking about the HList library
16:16:15 <maerwald> no
16:16:24 <EvanR> not the existential anti pattern
16:16:29 <ReinH> `Guest00000: it's a good thing. It adds more information to your system while also making it less error-prone.
16:16:54 <ReinH> You should really disabuse yourself of the notion that adding more type information to your system is a bad thing
16:17:22 <`Guest00000> i agree with you...
16:17:27 <EvanR> haskell would be interesting with -XDisableTypeSystem ... then you can do anything ;)
16:17:46 <Welkin> lol
16:18:07 <hexagoxel> (ah, there _is_ Turtle.Prelude.inprocWithErr. it has bad copy-pasted haddock, which made me believe it would not capture stderr, but i think it does.)
16:18:09 <`Guest00000> but cost is extra code, which *in simple cases* seems bad to me
16:18:23 <Welkin> to people who have only ever known dynamically typed (or unityped) languages, they view the "type system" as something bad
16:18:26 <EvanR> why do you have a tuple 3 things anyway?
16:18:29 <Welkin> when it is the opposite
16:18:36 <EvanR> wouldnt it be "simpler" (less code) to have [x,x,x]
16:18:51 <maerwald> Welkin: that always depends on how good the type system is
16:18:51 <ReinH> One line of extra code.
16:18:52 <Welkin> no type information mwans you are flying a plane with a blindfold and earmuffs on
16:18:57 <Zekka> I like a lot of untyped languages, but Haskell's error handling discipline isn't designed to help you with that
16:19:16 <enthropy> EvanR: there's -fdefer-type-errors
16:19:25 <EvanR> right
16:19:26 <Zekka> confusing things happen if you let your types be inhabited by values you can't use
16:19:34 <akfp> When using cryptonite, the SystemDRG module is hidden, but it contains an instance of DRG for the SystemDRG type.  Not sure what to do to get the instance..?
16:19:43 <EvanR> enthropy: but that has the disadvantage of crashing when you disobey the type system
16:19:44 <ReinH> And it's even better if you can give it a more specific name than Triple.
16:19:48 <`Guest00000> also, i don't want to say that less code is always simpler
16:19:56 <ReinH> Because then it constraints the type *and* provides the programmer with more info.
16:20:47 <`Guest00000> i want local data type declarations then
16:20:57 <ReinH> They are already module local unless you export them.
16:21:08 <`Guest00000> i want more local
16:21:09 <EvanR> i just put some "local" data types right next to the one function that uses it
16:21:10 <ReinH> And if your module is so big that this isn't local enough, your module is too big.
16:21:20 <`Guest00000> ah..
16:21:23 <`Guest00000> haha
16:21:24 <ReinH> because by definition it is doing too many things
16:21:37 <EvanR> arent we getting local data types ?
16:21:51 <hexagoxel> (nevermind, i cannot get the exitcode that way. grr.)
16:22:32 <Welkin> EvanR: I think you mean the record field accessors
16:22:38 <ReinH> `Guest00000: what are you actually doing with this (a,a,a) value?
16:23:16 <Welkin> data V3 a = V3 a a a
16:23:16 <Welkin> ?
16:23:22 <ReinH> If a data declaration isn't local enough, how about \f (x,y,z) = (f x, f y, f z)? It's hard to get more local than that.
16:23:46 <ReinH> if you want an ad hoc solution, use an ad hoc solution
16:24:24 <Spaceghost> Mp, Clint.
16:24:32 <Spaceghost> MPp.
16:24:37 <ReinH> If you want some systematic solution (i.e., one that might be found in a library), then why do you care if it's "not local enough"?
16:25:05 <ReinH> If it's worth putting in a library, it's worth putting in its own module.
16:26:00 <`Guest00000> ReinH: never mind
16:26:15 <ReinH> Ok
16:27:04 <ReinH> (The reason that a library for converting between tuples and lists doesn't exist is presumably that everyone who had the idea to make one also had the good sense to not do so.)
16:27:30 <EvanR> except for oleg's stuff ;)
16:27:51 <ReinH> Well, Oleg is Oleg.
16:35:18 <`Guest00000> maybe i am scope fanatic, i really don't like to add to scope names which i want to use JUST once
16:38:14 <`Guest00000> hm
16:38:21 <`Guest00000> is threadDelay super precise?
16:38:48 <EvanR> nope
16:38:59 <EvanR> it will wait at least as long as you tell it
16:39:05 <EvanR> probably more
16:39:12 <`Guest00000> ok thx
16:39:42 <EvanR> compiling with the threaded runtime seems to greatly improve the precision btw
16:44:35 <`Guest00000> is there a reason threadDelay takes microseconds?
16:44:53 <EvanR> to allow for implementations that are so precise
16:45:38 <EvanR> linux for instance has a nanosleep primitive which actually works in a real time environment
16:51:11 * hackagebot persistable-record 0.4.0.0 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.4.0.0 (KeiHibino)
17:11:12 * hackagebot relational-query-HDBC 0.6.0.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.0.0 (KeiHibino)
17:27:51 <zd234>  https://github.com/atzeus/CTRex/blob/master/Data/OpenRecords.hs#L87 -- how do I learn more about the "~" there?
17:28:05 <zd234> I heard it's called "type equivalence operator" but I am not finding much info on google
17:30:04 <ReinH> zd234: They are properly called "equality constraints": https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/equality-constraints.html
17:30:46 <zd234> ReinH: thanks!
17:31:13 * hackagebot relational-query 0.8.0.5 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.0.5 (KeiHibino)
17:31:14 <ReinH> At the least, you should get better search results.
17:36:13 * hackagebot persistable-types-HDBC-pg 0.0.1.3 - HDBC and Relational-Record instances of PostgreSQL extended types  https://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.1.3 (KeiHibino)
18:01:51 * hackagebot RFC1751 0.3.1.0 - RFC-1751 library for Haskell  https://hackage.haskell.org/package/RFC1751-0.3.1.0 (xenog)
18:53:07 <`Guest00000> cool
18:53:09 <Majiir> Hi, folks. I'm looking for a library, and I'm not sure that it exists--wondering if anybody knows. I'd like to write procedures in Haskell which "compile" to Lua scripts for Redis. I can imagine writing the high-level details myself, but I was hoping there was some kind of Lua-writing or -transpiling library already out there. I checked out HsLua, but it seems to be something else... unless I've misunderstood?
18:53:34 <`Guest00000> it's so nice that mod behaves 'right' with negative argument
19:01:42 <pavonia> > True
19:01:46 <lambdabot>  mueval-core: Time limit exceeded
19:02:54 <`Guest00000> > True
19:02:56 <lambdabot>  True
19:03:45 <pavonia> Hhm, seems to work again
19:04:52 <geekosaur> Majiir, HsLua goes the other direction. afaik there isn't anything going that direction
19:06:38 <Majiir> geekosaur, are you aware of any projects which go that direction for other languages? Something lighter than, say, ghcjs? Or would 'ghclua' really be my only hope?
19:07:28 <ggVGc> Majiir: I am currently writing a backend for Elm, which compiles to JS. It would be fairly easy to change the javascript backend into a Lua one I think
19:07:38 <ggVGc> the code base for Elm is very easy to naviate
19:07:50 <ggVGc> Elm isn't haskell, but very close
19:07:54 <geekosaur> elm, fay, haste
19:07:57 <ggVGc> might not be enough for your purposes
19:08:12 <ggVGc> I think fay and haste are probably a lot harder to write a new backend for
19:08:13 <geekosaur> all ae subsets. ghcjs is all of ghc, so a superset of haskell instead of a subset of it
19:08:15 <ggVGc> especially haste
19:08:46 <geekosaur> also frege (targets jvm)
19:10:25 <Majiir> I'm not Elm's biggest fan, but I'll take a look at the rest for inspiration
19:10:35 <Majiir> Also found a Lua backend for Purescript somehow, so that's promising
19:10:37 <geekosaur> there used to be haskell compilers which could be more easily retargeted for that (there used to be translators from yhc's core language to both java and javascript, iirc)
19:11:24 <ggVGc> Majiir: why are you not a fan of Elm? Either way, the reason I suggested it is that I think it's a feasible project to change the JS output into Lua(since I've been working with it for the past day and already have a working alternative backend for another language)
19:11:30 <ggVGc> Haste and Fay are much bigger afaik
19:14:15 <Majiir> In this case, it's because losing typeclasses and do-notation feels like a big blow. In general, I found Elm to be disappointing on the UI design front. Have to do eeeeeeeverything myself, and while I could imagine a world where Elm is great, the libraries don't seem to be there (or they're just too hard to find)
19:21:27 <petercommand> what does the -dynamic-too flag do?
19:22:29 <petercommand> ah, I found it
19:22:39 <petercommand> nvm
19:26:54 * hackagebot mappy 0.1.3.0 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.3.0 (mjgpy3)
19:52:23 <dogcat> Any cool Algol family scripting languages implemented in Haskell out there?
19:53:03 <dogcat> I am curious how they implement the evaluater 
20:11:00 <Moosef> Learning this language is hard. How can I stay motivated?
20:11:16 <Xe> Moosef: determination
20:13:14 <Moosef> Xe: Haha. I guess my question deserves that. My main issue it that the benefits that I am experiencing seems kind of intangible so far. A vague sense that my coding style is improving and my mind expanding. How has Haskell helped you and what can I expect from it?
20:13:16 <broma0> I'd like some help modeling a few Types (User, Task, Tag) that also have a less-strongly typed JSON version, like UserJSON etc. Anyone up for a discussion?
20:15:35 <pavonia> Anyone sees a way to write that function in a nicer way? http://lpaste.net/152291
20:16:26 <broma0> pavonia: can you briefly describe the intended functionality?
20:17:35 <pavonia> It gets two regexes and a lins of lines (strings), and merges each pair of consecutive lines into one if regex 1 matches the former and regex 2 the latter line
20:17:46 <pavonia> *a list
20:17:59 <Xe> Moosef: but really it's all about understanding how to think in that way
20:18:06 <Xe> also have a project to work on
20:18:12 <Xe> the stupider the idea the better
20:18:30 <broma0> pavonia: I'm thinking about how i'd write that - then ill compare and see if its "nicer". it might not be!
20:18:49 <dogcat> :Moosef, i was doing data science, got hired, and realized Haskell has way more great things to work on
20:18:59 <dogcat> now I'm just working on Haskell
20:18:59 <Moosef> Xe: goofy 'stupid' or ambitious 'stupid'
20:19:25 <Moosef> dogcat: You use haskell at work?
20:19:51 <Xe> Moosef: I'm at a PHP and Haskell shop personally
20:19:53 <dogcat> Yea, we have a domain specific language and API to support a financial analysis platform
20:20:20 <dogcat> it's pretty straight forward to get an API up and running in haskell
20:20:40 <Moosef> Do either of you ever work with Yesod?
20:20:56 <dogcat> no, My killer app for haskell is language design
20:21:43 <dogcat> but the type theory gives you the ability to think of functions more mathematically
20:21:58 <dogcat> since you know they will work at runtime if they compile, it offloads a huge mental burden
20:22:35 <broma0> pavonia: might have something for you
20:22:54 <Moosef> dogcat: the type theory is a huge draw for me. I am hoping that consistent exposure help me think more abstractly about my projects
20:22:56 <dogcat> combine that with immutable data structures, and you get really powerful abstraction
20:23:11 <Moosef> How do you plan a project?
20:23:48 <dogcat> good question, right now I'm looking for a great idea
20:24:16 <dogcat> making haskell into a language better suited for something in industry, or say, data science might be one of them
20:24:37 <dogcat> or using Haskell to solve a difficult problem via simple abstraction
20:24:55 <Moosef> What would an example of that be?
20:25:43 <pavonia> broma0: Please share your thoughts :)
20:26:12 <dogcat> sure, there is are no design patterns in haskell code
20:26:35 <dogcat> any idea regarding composition can be fully expressed in the languague
20:26:48 <dogcat> well, at least not gang of four design pattern
20:26:56 * hackagebot Plot-ho-matic 0.9.0.2 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.2 (GregHorn)
20:27:01 <broma0> pavonia: got something..
20:27:06 <broma0> ill lpaste it
20:27:19 <dogcat> https://news.ycombinator.com/item?id=2619080
20:27:45 <broma0> pavonia: ehhh its not that pretty :/ http://lpaste.net/152291
20:28:51 <broma0> pavonia: might want to break it up into two real simple fn's
20:29:17 <Moosef> dogcat: what do you mean by gang of four?
20:30:58 <pavonia> broma0: Thanks, using <*> is quite nice, I think you don't even need the <$> part
20:32:06 <kadoban_> Moosef: https://en.wikipedia.org/wiki/Design_Patterns
20:32:13 <broma0> i think i got the cases backwards..
20:32:19 <dogcat> gang of four was this book that established design patterns for object oriented programming languages
20:32:49 <broma0> pavonia: you should swap the first and second arguments of "maybe" or else itll append the lines if the regexes don't match
20:33:01 <pavonia> Right :)
20:33:22 <broma0> someone else must have a better implementation though, mine kinda sucks
20:34:40 <dogcat> :Moosef, the language has been an academic research platform for almost 30 years, there are a ton of great ideas not found in any other languages you can use
20:36:07 <dogcat> Haskell is so abstract that the data structures are valid constructs in category theory (mostly true)
20:38:12 <dogcat> the only problem is that it takes a lot of practice to understand things like monads, and you need to learn a bit of type theory to understand how language extensions work
20:39:44 <Moosef> I have heard that really grasping this stuff it pretty eye-opening. Would you say that has been your experience?
20:39:54 <dogcat> absolutely
20:40:02 <dogcat> it's changed the direction of my career
20:40:28 <Moosef> What was your previous trajectory?
20:40:38 <dogcat> grad school drop out doing data science
20:41:32 <Moosef> And haskell got you into financial analysis?
20:41:48 <dogcat> no, financial analysis got me into haskell
20:42:29 <dogcat> i was hired for this job because I had experience in numerical computing, and the people that hired me thought I would learn haskell if given the chance
20:42:40 <dogcat> ;) they were right!
20:42:57 <Moosef> What particular aspect was the most eye opening for you?
20:43:29 <dogcat> The benefit of type theory 
20:43:38 <petercommand> dogcat: what an interesting experience :p
20:44:00 <dogcat> yea, i was always a programming language nerd
20:44:07 <dogcat> and had learned clojure before this
20:44:32 <dogcat> Industry will adopt these ideas, and we can help make that happen
20:44:39 <Moosef> How does type theory differ from set theory in Algebra?
20:45:04 <dogcat> well, I think type theory arised out of a problem in set theory
20:45:28 <Moosef> What particular problem?
20:45:31 <dogcat> and describes the arguments of a function
20:46:10 <dogcat>  I think it was Russell's paradox
20:46:18 <dogcat> but I'm not positive
20:46:42 <KaneTW> the most important distinction between type and set theory is that propositions are types
20:46:57 * hackagebot zlib-lens 0.1.2.1 - Lenses for zlib  https://hackage.haskell.org/package/zlib-lens-0.1.2.1 (EricMertens)
20:46:57 <Moosef> Okay I would enjoy looking into that. I am always more of a sucker for theory
20:46:59 <KaneTW> but propositions in set theory are first-order formulas over ZFC
20:47:21 <Moosef> ZFC?
20:47:36 <KaneTW> zermelo-fraenkel axioms + axiom of choice
20:47:44 <KaneTW> the usual set-theoretic axioms
20:48:16 <Moosef> Okay, still getting started with set theory. Look forward to that though. 
20:48:40 <dogcat> you don't actually need that knowledge to program in haskell, its just a nice side effect of Haskell's academic nature
20:49:00 <Moosef> I am actually trying to work my way through haskell and set theory or at least the Algebra surrounding it at the same time.
20:49:38 <Moosef> Yeah I have been noticing that. For some reason I feel more secure when I can understand the rational behind things though
20:49:53 <Moosef> It helps me make sense of why things are they way they are.
20:50:10 <dogcat> I'm the same way, but it will take years
20:50:18 <Moosef> Also I am a glutton for punishment with something to prove.
20:50:31 <Moosef> That's what I have been hearing.
20:50:51 <Moosef> How many years are you into things.
20:50:54 <Moosef> ?
20:50:58 <dogcat> yea, it was about three months before I could take autonomy in our code base
20:51:09 <dogcat> i did analysis work for 4 before this
20:51:17 <dogcat> but not really building industry software
20:51:42 <dogcat> we are teaching a DB guy haskell, and he's doing fine
20:52:21 <dogcat> you could teach high schooler's this stuff, the actual type theory to understand the code isn't that difficult
20:52:46 <Moosef> How do you know when to create your own types?
20:53:10 <dogcat> when its easier than not!
20:53:21 <Moosef> Haha
20:53:23 <dogcat> if I want to compute on two objects, i would make a pair
20:53:35 <dogcat> data PairT a = Pair a a
20:53:57 <dogcat> PairT is the type and "Pair 2 2" create a pair of type "Pair Int"
20:54:19 <Moosef> That makes sense
20:54:46 <Moosef> I do a lot of work with map coordinates I could see that kind of thing being handy
20:56:40 <Moosef> dogcat: What was something that really boosted your learning?
20:57:04 <dogcat> working on it everyday certainly helped
20:57:28 <dogcat> but what made me want to learn more was probably this book: Types and Programming Languages by Pierce
20:58:06 <dogcat> the book is in OCaml, but it gave me a structured way to understand what type theory is as field
20:59:49 <dogcat> plus you can write programming languages so easily in haskell
21:00:28 <Moosef> How so? Is it similar to lisp in that way?
21:00:46 <levi> It's a great book, but it's very much focused on type theory as it relates to types in programming languages; type theory has other applications, though.
21:01:51 <kadoban_> levi: Does it? What applications, out of curiosity?
21:03:09 <levi> It was originally developed to investigate mathematical foundations, IIRC.
21:04:47 <levi> And it continues to be used as the foundation of formal mathematical proofs as managed by proof assistants and similar software.
21:05:33 <dogcat> ^^ that's actually one of it's most promising features...IMO software engineering would become more like the rest of engineering if we could show work in provable units
21:05:46 <levi> The origins of type theory predate programming languages, though.
21:06:58 * hackagebot refined 0.1.2 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.1.2 (NikitaVolkov)
21:07:04 <Moosef> levi: Where would you say its origins lie?
21:08:39 <levi> In attempting to resolve the paradox Bertrand Russell found in Frege's set theory.
21:09:43 <broma0> If you were building some hierarchy of types, would you have the references point upward or downward? for example, should an item have "parents" or "children". On the same note, if you were making a sequence, should an item have "preceeds" or "follows"?
21:10:16 <Moosef> levi: This is a tangent but do you have any interest in modal logic?
21:11:42 <levi> More generally, they started in the formalist and logicist approaches to mathematical foundations. Attempts to formalize mathematics kept running into paradox and inconsistency. The Lambda Calculus was invented in basically the same context, but a bit later.
21:12:21 <levi> Moosef: I am vaguely interested in modal logic; it's on my list of things to learn more about but not at the top.
21:13:25 <Spaceghost> Clint.
21:13:26 <Spaceghost> PMm.
21:13:42 <Moosef> levi: I remember enjoying it in college. Konyndyk has a good book on it.
21:16:12 <dogcat> :Moosef, Haskell is pretty cool in that you can take all these really profound ideas and apply them helping you build a software system
21:16:49 <levi> Russell came up with a "ramified theory of types" to resolve the paradox he found; it was rather cumbersome. Church came up with his own logical notation in which he attempted to make it impossible to construct the sort of self-referential sentences that led to Russell's paradox without resorting to types. This was the untyped lambda calculus, which turned out to be a failure as a consistent logic but rather
21:16:51 <levi> useful for other things.
21:17:52 <Moosef> That seems to be the general theme from a lot of things during that period. Do you read much Wittgenstein levi ?
21:18:18 <Moosef> dogcat: That's really what I am hoping for.
21:18:43 <dogcat> :levi, so are church booleans a failure as a consistent logic
21:19:27 <levi> Some other logicians figured out how to make a much simpler concept of types, and Church applied these ideas in a reformulation of lambda calculus *with* these simpler types.
21:20:34 <levi> I haven't read much Wittgenstein, or any philosophers really, although I have read a few summaries of the work of various philosophers.
21:21:05 <levi> (the exception being Russell; I've read a couple of his books)
21:22:42 <levi> Anyway; to relate this to Haskell--the simply-typed lambda calculus turned out to be a sound and consistent logic system, but various extensions to it re-introduced inconsistency but provided a useful model for the semantics of typed functional programming languages.
21:24:20 <vikingofrock> So I'm having some issues with stack and I was wondering if people here could help: whenever I try to run stack test (or stack build), I get an error message about a GHC version mismatch, and it tells me to run stack setup. I did run stack setup, and it runs cleanly, but the issue did not go away
21:25:05 <Moosef> Well time to go. Good night
21:25:14 <levi> One variant of typed lambda calculus, called System F-omega, is basically what Haskell is beneath its syntactic sugar.
21:25:54 <hodapp> can one desugar into System F-omega and write that directly?
21:26:15 <dogcat> yea, haskell goes to untyped lambda calc
21:26:33 <dogcat> both typed and untyped lambda calc are turing complete, so they can express eachother
21:27:00 <levi> Haskell goes to System F-omega (aka Core), which is a typed lambda calculus.
21:27:06 <geekosaur> hodapp, no. there was an "external core" facility, but it bitrotted (and wasn't actually the same as ghc's core language to begin with)
21:27:09 <levi> dogcat: Not all typed lambda calculi are turing complete
21:27:27 <levi> The simply typed lambda calculus is not, for example.
21:28:44 <levi> The typed lambda calculi used in theorem provers are generally not turing complete, either, as that introduces inconsistency to their use as a system of logic.
21:31:58 * hackagebot print-debugger 1.0.0 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.0.0 (johnreedlol)
21:32:02 <dogcat> :levi, I think there a mention in TAPL that compilation to either typed or untyped lambda calculus is possible, and equivelent
21:33:18 <levi> There's not just one typed lambda calculus.
21:33:53 <dogcat> you are right, it's been a long day
21:52:18 <t0mb0> Hey can anyone explain to me how toInteger can be called here without an argument?
21:52:18 <t0mb0> http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function#
21:53:20 <scshunt> t0mb0: it's function composition
21:53:22 <scshunt> :t (.)
21:53:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:53:33 <scshunt> read this as (b -> c) -> (a -> b) -> (a -> c)
21:54:42 <t0mb0> but doesn't composition require a list as an argument?
21:54:51 <t0mb0> so toInteger would have to be called against something
21:55:01 <dogcat> functions can wait!
21:55:04 <t0mb0> so normally I see composition have a dollar sign
21:55:20 <Hijiri> dollar sign is function application
21:55:25 <Hijiri> @src ($)
21:55:25 <lambdabot> f $ x = f x
21:55:42 <Hijiri> If you see f . g $ x it means (f . g) x
21:55:49 <Hijiri> i.e. compose f and g, then apply that result to x
21:55:53 <t0mb0> yep!
21:55:55 <t0mb0> that makes sense to me
21:56:00 <t0mb0> so what is toInteger being applied to here
21:56:07 <t0mb0> the final result?
21:56:10 <t0mb0> of sumOf x?
21:56:12 <dogcat> i use it for things like fmap ( f . g) list
21:56:14 <dogcat> all the time
21:57:03 <Hijiri> t0mb0: there's no final result yet, it's not applied yet
21:57:39 <Hijiri> you can say sumOf . (x +) . toInteger gives a function as a result
21:57:50 <Hijiri> toInteger is not being applied to anything though
21:58:02 <Hijiri> It is like if you did f . g, without the $x
21:58:09 <t0mb0> yeah
21:59:22 <Hijiri> the instance for (a -> r) is supposed to take the next integer and make another thing of instance SumRes
21:59:45 <t0mb0> but shouldn't ghci give a compiler error that toInteger has no args/
21:59:49 <Hijiri> nope
21:59:56 <Hijiri> functions don't have to be applied
22:00:16 <t0mb0> hm ok I'm going to adapt this to a normal function as a test hang on
22:25:17 <t0mb0> Hijiri: ok so I've had a play around
22:25:25 <t0mb0> correct me if I am wrong
22:26:02 <t0mb0> but, you don't need to supply toInteger an arugment because when sumOf gets called, it returns a function that you would bind to a var
22:26:02 <t0mb0> say
22:26:06 <t0mb0> testSumOf
22:26:23 <t0mb0> then what you supply as an arg to testSumOf would effectively be toIntegers argument
22:32:15 <lettier> Hello
22:35:16 <t0mb0> Hijiri: https://dpaste.de/CAro
22:35:18 <t0mb0> my example
22:37:00 * hackagebot print-debugger 1.0.1 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.0.1 (johnreedlol)
23:02:01 * hackagebot print-debugger 1.1.1 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.1 (johnreedlol)
23:12:01 * hackagebot print-debugger 1.1.2 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.2 (johnreedlol)
23:26:42 <mniip> interesting
23:27:02 * hackagebot print-debugger 1.1.3 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.3 (johnreedlol)
23:27:09 <mniip> 'Sieve (Forget r) (Const (TYPE Lifted) r'
23:27:11 <mniip> yet 'type Rep (Forget r) = Const * r'
23:27:26 <mniip> (haddock with 8.0)
23:57:55 <jaen> Hello fine Haskell people and/or sufficiently advanced artificial intelligences - I'm thinking about finally learning Haskell properly (took me long enough since that was first FP language I learned of almost 5 years ago) and I'm thinking about using it for parsing; the language I have in mind would ideally have a dual textual-graphical representation, so I'm wondering if anyone has any idea how hard would
23:57:58 <jaen> it be to write a parser that keeps exact source locations and can retain the correspondence to source locations even under transforms of the AST (eg. by coalescing source locations). Any pointers on what to look at?
