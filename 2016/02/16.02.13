00:02:03 * hackagebot print-debugger 1.1.4 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.4 (johnreedlol)
00:07:03 * hackagebot print-debugger 1.1.5 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.5 (johnreedlol)
00:07:05 * hackagebot print-debugger 1.1.6 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.6 (johnreedlol)
00:07:39 * hackagebot print-debugger 1.1.5 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.5 (johnreedlol)
00:07:39 * hackagebot print-debugger 1.1.6 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.6 (johnreedlol)
00:17:33 * hackagebot print-debugger 1.1.7 - Debug print formatting library.  https://hackage.haskell.org/package/print-debugger-1.1.7 (johnreedlol)
00:22:53 <xkami> how does this work? https://gist.github.com/anonymous/1d10244f51a2d0dbe029
00:23:28 <mniip> xkami, that doesn't work
00:23:50 <xkami> mniip: I know, I mean just the ´z <- 1 .. n   y <- 1 .. z   x <- 1 .. y´ part
00:24:02 <mniip> that's not valid either
00:24:24 <xkami> I mean
00:24:30 <xkami> how do i understand this: ´z <- 1 .. n´
00:24:52 <xkami> the full code is this: http://try.purescript.org/?gist=47c2d9913c5dbda1e963
00:26:08 <mniip> xkami, that's not valid syntax
00:26:28 <mniip> you're trying to 'understand' a program that is not valid?
00:26:39 <xkami> ;(
00:27:01 <xkami> what about just
00:27:05 <xkami> ´z <- 1 .. n´
00:27:13 <xkami> that should be valid in haskell some how
00:27:20 <mniip> that still is not valid
00:27:21 <xkami> or maybe not
00:27:24 <xkami> :(
00:27:26 <mniip> I said that at least 3 times now
00:27:30 <xkami> sorry
00:27:31 <xkami> haha
00:28:31 <mniip> are you sure you want it to be an array comprehension?
00:28:41 <mniip> a more appropriate type would be [(Int, Int, Int)]
00:30:20 <xkami> mniip: it's purescript, so I don't want you to try understand it. It's another language but reminds a lot of haskell
00:30:29 <mniip> oh
00:30:34 <mniip> it isn't haskell?
00:30:50 <mniip> you should've... said that
00:31:05 <xkami> sorry again..
01:32:43 * hackagebot cli 0.1.1 - Command Line Interface  https://hackage.haskell.org/package/cli-0.1.1 (VincentHanquez)
02:22:45 * hackagebot secp256k1 0.4.3 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-0.4.3 (xenog)
03:02:46 * hackagebot doctest-discover 0.1.0.7 - Easy way to run doctests via cabal  https://hackage.haskell.org/package/doctest-discover-0.1.0.7 (karun012)
03:09:39 <castlelore> What can be done about Undo.hs "Couldn't match expected type ‘Maybe Binds’ with actual type ‘Binds’"
03:11:47 <bergmark> castlelore: what is Undo.hs?
03:12:11 <castlelore> module Lambdabot.Plugin.Haskell.Undo (undoPlugin) 
03:15:07 <bergmark> castlelore: you can probably make it compile with --constraint='haskell-src-exts<1.17'
03:16:01 <bergmark> i can revise the constraints in a bit
03:16:50 <castlelore> thanks I'm in way over my head but hoping to learn something by trying anyway :-)
03:18:36 <bergmark> the reason this happened is because the lambdabot-haskell-plugins package doesn't have an upper bound on haskell-src-exts and it doesn't support the latest version
03:19:28 <castlelore> that makes sense-- it does seem to be building now
03:20:32 <castlelore> fantastic it built thanks
03:21:59 <bergmark> there's a filed issue about it already https://github.com/lambdabot/lambdabot/issues/139
03:52:54 * hackagebot QuickPlot 0.1.0.0 - Quick and easy data visualization with Haskell  https://hackage.haskell.org/package/QuickPlot-0.1.0.0 (tepf)
04:48:11 * hackagebot wai-predicates 0.8.6 - WAI request predicates  https://hackage.haskell.org/package/wai-predicates-0.8.6 (ToralfWittner)
04:59:26 <jophish> I'm planning to write a parser/generator for the EDID spec (binary data your monitor sends to the gpu to advertise its capabilities)
04:59:41 <jophish> It seems redundant to encode this spec into Haskell twice, once for parsing and again for generating
04:59:59 <jophish> What are people's favourite packages for reducing this redundancy?
05:11:23 <Gurkenglas> That sounds like the thing that ToJSON/FromJSON does, you might figure out how they do it. It also sounds like the kind of thing lens could help with
05:12:12 <jophish> Gurkenglas: yeah, I just stumbled across the Json package's usage of this
05:12:13 <jophish> thanks
05:13:35 <Gurkenglas> @let readprism = prism show (\x -> maybe (Left x) Right $ readMay x)
05:13:37 <lambdabot>  Defined.
05:13:41 <Gurkenglas> > "123" & readprism +~ 3
05:13:43 <lambdabot>  "126"
05:15:04 <Gurkenglas> https://www.schoolofhaskell.com/user/tel/lens-aeson-traversals-prisms
05:16:16 <jophish> Gurkenglas: this package looks a lot like what I want
05:25:16 <bennofs> jophish: I haven't used it, but http://hackage.haskell.org/package/boomerang looks like it fits your description
05:27:41 <jophish> bennofs: I looked at that but it seemed to be geared more towards textual formats. I'll investigate it a little mre
05:28:16 * hackagebot svg-tree 0.3.2.2 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.3.2.2 (VincentBerthoux)
05:44:45 <jophish> hmm, codec seems to be along the rights lines, but doesn't seem to support alternative parsers
06:03:07 <quchen> Has there been any news about ZuriHac this year?
06:03:13 <cocreature> quchen: afaik no
06:14:50 <Hrk> I'd like to understand this 'efficient definition' of findIndices. Where can I read more about what all these '#'s mean? http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.OldList.html#findIndices
06:16:26 <pavonia> Hrk: They are called unboxed types
06:16:35 <ClaudiusMaximus> Hrk: unboxed ints (data Int = I# Int#) to avoid pointer indirection overhead
06:17:41 <ClaudiusMaximus> Hrk: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html#glasgow-unboxed
06:18:22 <Hrk> pavonia, ClaudiusMaxiums: you're right, the time has come for me to read ghc manual. I've been postponing this for too long :-)
06:21:46 <cocreature> Hrk: there is also https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/primitive-haskell.md
06:22:47 <Hrk> cocreature: Looks nice. Thanks!
06:38:35 <OverCoder> [Int] -> String ?
06:42:01 <xkami> ??
06:44:05 <OverCoder> How do I convert Int list to a String?
06:46:15 <osfameron> depends what you want the result to be, presumably?
06:47:12 <kadoban> > show [1..5]
06:47:13 <lambdabot>  "[1,2,3,4,5]"
06:48:48 <domgetter> OverCoder: are the Ints character codepoints of some sort? e.g. ascii?
06:51:45 <osfameron> > join . intersperse "," . map show $ [1..5]
06:51:47 <lambdabot>  "1,2,3,4,5"
06:53:25 <osfameron> > intercalate "," . map show $ [1..5]
06:53:27 <lambdabot>  "1,2,3,4,5"
06:55:35 <ClaudiusMaximus> > map chr [1..5]
06:55:37 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ"
07:03:47 <tuxayo> Hi :)
07:04:43 <AleXoundOS> hi
07:10:44 <tuxayo> I'm beginning with Haskell and I'm searching how to write clean code (most readable/maintainable possible).
07:10:45 <tuxayo> Given a function that the name and type can't describe properly. (to avoid needing to read the implementation to know how to use it)
07:10:45 <tuxayo> If I need to choose between using a parameter that is “eta reducible” or adding a comment, what should I do?
07:10:45 <tuxayo> The comment can become obsolete. But a parameter is much less likely do so.
07:10:46 <tuxayo> If the function can be understood simply by adding a parameter. Then adding a comment would be too much (longer to read).
07:10:49 <tuxayo> For now I'm would think that a parameter is better in this case. Does someone with experience can review this reasoning?
07:11:43 <synergistics> Point versus point free?
07:12:41 <synergistics> addOneXs = map (+ 1)
07:12:44 <synergistics> versus
07:12:57 <synergistics> addOneXs xs = map (+ 1) xs
07:13:00 <synergistics> Is that what you mean?
07:13:29 * hackagebot HueAPI 0.2.7 - API for controlling Philips Hue lights  https://hackage.haskell.org/package/HueAPI-0.2.7 (SjoerdVisscher)
07:13:57 <tuxayo> I don't know what point free means :-( - Yes your example is what I mean (given that the name of the parameter really help to understand the function)
07:14:19 <mpickering> it seems like you answered your own question
07:15:08 <synergistics> The style that's most eta reduced is called point free style. 
07:16:12 <synergistics> Sometimes point-free style can be less understandable as you've seen
07:16:58 <tuxayo> mpickering: thanks, I wanted to be sure that I hadn't made a mistake or forgot something to put in balance.
07:17:25 <tuxayo> synergistics: Does this have something to do with the "." operator?
07:18:11 <synergistics> tuxayo: Ironically, I'm pretty sure it doesn't. Because using (.) for composition would lead to a more point-free function.
07:18:21 <synergistics> like this
07:18:29 * hackagebot discrete-space-map 0.0.5 - A discrete space map.  https://hackage.haskell.org/package/discrete-space-map-0.0.5 (SjoerdVisscher)
07:18:40 <synergistics> foo = show . map (+ 1) . reverse
07:19:14 <synergistics> foo xs = show $ map (+ 1) (reverse xs)
07:19:46 <synergistics> A lot of times, there's various combinations of ($) and (.) that can make a function more or less point free
07:20:46 <synergistics> Even this though: foo xs = (show . map (+1) . reverse) xs
07:20:49 <synergistics> Is not point free
07:22:52 <synergistics> But do you see how the first definition of foo sort of documents itself?
07:24:35 <tuxayo> synergistics: I see
07:25:08 <synergistics> If functors map a category to a category, for the Functor typeclass, are types objects or categories?
07:27:25 <liste> synergistics: types are objects of category Hask
07:43:34 <synergistics> liste: Then what's the connection between Hask functors and category theory ones? Is it that types (not haskell specific) are generally categories themselves?
07:46:54 <tuxayo> synergistics: I understand that point free means https://wiki.haskell.org/Pointfree#But_pointfree_has_more_points.21
07:47:05 <tuxayo> Thanks all for your help! :-)
07:47:52 <synergistics> tuxayo: Haha, nice link integration there
07:48:28 <tuxayo> synergistics: Link integration?
07:49:11 <synergistics> If you read your sentence followed by the has at the end of the link, it's almost its sentence
07:49:41 <synergistics> "I understand that point free means: point free has more points" So close
07:50:27 <mniip> synergistics, haskell functors are endofunctors on Hask
07:50:47 <synergistics> mniip: OOH
07:50:55 <mniip> FX is literally spelled 'F X' in haskell
07:50:58 <mniip> and Ff is 'fmap f'
07:51:08 <mniip> where fmap :: (a -> b) -> F a -> F b
07:51:16 <tuxayo> synergistics: Oh I didn't see that hehe
07:51:30 <synergistics> Ah, that makes much more sense, thank you
07:52:16 <ackthet> anybody using HueAPI?
07:52:18 <synergistics> mniip: What's F by itself? I'm a bit confused
07:52:26 <synergistics> mniip: Just fmap?
07:52:27 <mniip> some functor
07:52:31 <synergistics> Oh
07:52:38 <mniip> for example
07:53:00 <mniip> Maybe is a functor that for every type (set) X produces a set Maybe X with one extra element
07:53:43 <synergistics> Is that element Nothing?
07:53:45 <mniip> yes
07:53:52 <synergistics> Ok, I see
07:54:21 <synergistics> But that definition only works if Maybe is an endofunctor specifically, right?
07:54:30 <mniip> well
07:54:36 <mniip> if X is in Hask, then Maybe X is in Hask too
07:54:39 <mniip> hence endofunctor
07:56:19 <mniip> I think with visible type application in GHC 8.0 you can actually say that category theory notation 'Ff' corresponds to 'fmap@F f'
07:56:52 <mniip> but I don't know the details of that nor have tested it
07:57:36 <synergistics> Time to go learn about functors! Thanks
08:33:30 <mniip> hmm
08:34:46 <mniip> if we generalized Endo to data Join c a = Join (c a a), then we could have Category c => Monoid (Join c)
08:35:08 <mniip> i.e Kleisli, and Cokleisli monoids for free :o
08:36:05 <Taneb> mniip, this exists in monoid-extras
08:36:17 <Taneb> http://hackage.haskell.org/package/monoid-extras-0.4.0.2/docs/Data-Monoid-Endomorphism.html
08:36:40 <mniip> noice
08:36:58 <Taneb> Hmm, that could be more kind-polymorphic I think
08:58:46 * hackagebot json-rpc 0.7.1.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.7.1.0 (xenog)
09:08:10 <SpencerT> anyone use emacs as IDE? Flycheck doesn't recognize any packages I cabal-install even though my sources compile fine, looking for help
09:13:46 * hackagebot json-rpc 0.7.1.1 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.7.1.1 (xenog)
09:34:59 <ggVGc> I want to define an interface for a certain kind of hardware devices, and supply two implementations of it for two different devices. Is a type class te correct answer here?>
09:42:10 <liste> ggVGc depends. probably a good ol' record is better
09:42:43 <liste> e.g. data DeviceInteface = DeviceInterface { initialize :: IO (); readByte :: IO Word8 }
09:47:36 <Shockk> I completely forgot, what's the cabal command again to source an outside directory's package?
09:48:07 <hexagoxel> cabal sandbox add-source
09:48:13 <Shockk> great thanks hexagoxel 
09:48:41 <Ainieco> hello
09:49:05 <Ainieco> i'm a little bit stuck with type inferrence - http://lpaste.net/5067496844418875392 how can i make it work
09:49:45 <lifter> I used to do "cabal install hlint" inside a cabal sandbox to get a sandbox-local hlint executable, but now I've migrated to stack. How do I do the same thing in stack?
09:52:03 <lyxia> Ainieco: the order of arguments of foldl isn't right
09:54:16 <bergmark> lifter: `stack install hlint`, you don't need a sandbox
09:55:11 <lifter> bergmark, cool, thank you!
09:55:12 <ggVGc> liste: yeah, I just realised that. thanks :)
09:55:36 <Ainieco> lyxia: this is the type of foldl in my prelude Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b 
09:55:52 <Ainieco> lyxia: could you please be more specific, what and where isn't right?
09:58:34 <Ainieco> lyxia: geez, i see it now, thanks
09:59:18 <Ainieco> it seems i'm never going to remember the order of foldl its just different in different languages and i'm not that often using it
09:59:33 <lpaste> lyxia annotated “No title” with “Ainieco (annotation)” at http://lpaste.net/5067496844418875392#a152332
09:59:35 <Ainieco> strugling with this issue for 5 years now and still can't remember
09:59:54 <Ainieco> lyxia: yeah, thank you!
10:00:14 <lyxia> foldl (+) a [b, c, d] = ((a + b) + c) + d
10:00:39 <lyxia> foldr (+) [a, b, c] d = a + (b + (c + d)) 
10:01:03 <Ainieco> lyxia: huh? + is assoiciative
10:01:08 <Ainieco> > foldl (+) a [b, c, d]
10:01:10 <lambdabot>  a + b + c + d
10:01:28 <lyxia> sure it's associative
10:01:44 <mniip> consider a noncommutative operation
10:01:50 <lyxia> I just meant that to be more general in case you use a non-associative operator instead
10:01:52 <mniip> > foldl (/) a [b,c,d]
10:01:54 <lambdabot>  a / b / c / d
10:02:03 <mniip> > foldr (/) a [b,c,d]
10:02:05 <lambdabot>  b / (c / (d / a))
10:02:33 <lyxia> Ainieco: foldl, the accumulator is on the left: foldl (\ acc x -> ...) acc0 xs ; foldr the accumulator is on the right: foldr (\x acc -> ...) xs acc0
10:02:50 <lyxia> oops
10:02:51 <mniip> lyxia, umm
10:02:56 <mniip> in both the list is the last paramter
10:03:00 <lyxia> right
10:03:07 <lyxia> nvm :D
10:25:00 <gganley> so I've been reading "Category Theory" by Steve Awodey and I have been having issues understanding certain topics due to my lack of mathematical maturity. If i have questions where should I ask them? I know there is the #math channel but I was curious if there is a friendly channel that I can ask those questions.
10:26:05 <Cale> gganley: You can ask here, but there's also ##categorytheory
10:27:56 <gganley> Cale: I'm just always cautious about asking that are off-topic questions
10:28:27 <Cale> People are typically lenient toward category theory questions here :)
10:29:02 <Gurkenglas> More lenient than towards questions about asking questions, in fact!
10:32:26 <gganley> Cale: If I remember correctly kmett refrenced you as someone who is very knowlagable about the subject
10:32:45 <Cale> I know a bit :)
10:34:27 <Cale> gganley: So what's your question?
10:36:59 <gganley> Cale: I dont have a question right now but I'm a freshman in uni and I dont have too much exposure to advanced math. Like I know a bit about Set theory and thing connected to haskell (monoids and semigroupds) but beyond that I have no clue.
10:37:19 <gganley> *things
10:38:47 <Cale> gganley: Ah, okay! Well, feel free to ask if you get stuck on anything.
10:39:08 <Welkin> this channel is not for math or category theory
10:39:15 <Welkin> there are channels for that though
10:39:30 <Welkin> ##math and ##categorytheory
10:39:57 <Cale> Welkin: Well, it's not specifically for category theory, but if it's stuff at the level of what's being discussed in Awodey, there's probably enough general interest here to support the discussion :)
10:40:12 <gganley> Cale: thank you very much. Is there any online resource that I can look at for simple questions? I remember hearing n-lab but I was curious about other sources of information.
10:40:40 <gganley> Welkin: point taken. trust me if there is discussion going on in the channel i will delay/move my questions to more appropriate channels.
10:40:50 <Cale> gganley: Well, it's not a way to get questions answered, but check out http://www.simonwillerton.staff.shef.ac.uk/TheCatsters/
10:41:17 <gganley> Welkin: but all my questions will relate back to haskell or clojure or something of the like
10:42:26 <Cale> Eugenia Cheng and Simon Willerton have a YouTube channel (TheCatsters) which has a fair number of quick lectures on various topics.
10:42:53 <Cale> The level of sophistication moves around a lot though
10:43:34 <Cale> So you can't always tell from the video title what the prerequisites will look like.
10:44:28 <haskey> Anyone using Euterpea?
10:44:30 <Cale> https://www.youtube.com/user/TheCatsters/videos?flow=grid&view=0&sort=da -- the order in which they actually put the videos up actually isn't terrible, but starts off assuming that you know what natural transformations are.
10:44:49 <haskey> The music/sound library?
10:45:31 <haskey> I can't hear anything
10:45:50 <haskey> Yet the function is evaluated
10:46:02 <owenpar> oh hai
10:56:10 <gganley> Cale: do you think I should learn abstract algabra first or should i look it up while learning cat-theory
10:56:47 <Cale> gganley: It shouldn't be required, but understanding how category theory applies to abstract algebra will give you a better appreciation for things.
10:56:49 <gganley> Cale: like I understand a group has permutations of a set that has inverses and rotations or something but not much beyond that
10:57:25 <gganley> Cale: ok, I should be taking abstract in about... two semesters but not exeactly sure
10:57:46 <scshunt> Basically, the more you know about abstract math, the easier it will be to understand category theory
10:58:01 <scshunt> Abstract algebra especially, but there are numerous examples of categories in other areas of math too
10:58:58 <Cale> Basically, in mathematics we're pretty much never content with studying structures in isolation -- instead we always want to be looking at all structures of some sort and the relationships between them. Usually that results in at least one category.
11:04:06 <gganley> Cale: things in haskell can help a bit, like on page 15 arrows are addressed and the type of g is the same as (***) in haskell.
11:05:31 <Cale> gganley: That arrow category doesn't really correspond directly with the Arrow abstraction in Haskell though.
11:07:28 <Cale> gganley: Maybe we could define a corresponding instance of Arrow if Haskell were dependently typed so that we could give the functions (which are the objects of the category) at the type level.
11:15:15 <gganley> Cale: give the functions what at the type level. i didnt exactly follow. from what i understand the objects in the Arrow category are arrows of a category C. where the arrows of the Arrow category are functions from the domain of two functinons or a function of the codomain of two functions
11:16:36 <scshunt> Cale: yes, or weird categories like order categories or Boolean algebras
11:16:48 <scshunt> gganley: do you mean Arrow as in Control.Arrow, or arrow as in the categorial abstract notion
11:17:05 <Cale> gganley: Well, the objects of the arrow category are arrows of C, and if we have f: a -> b, and g: c -> d in the category C, then an arrow f -> g consists of arrows a -> c and b -> d which make the resulting square commute
11:17:48 <Cale> gganley: It's hard to represent this situation accurately in Haskell because we can't have a type which depends on the functions f and g -- types may only depend on other types.
11:18:27 <dogcat> yea, the lambda cube really helped me understand type, terms, and what each language can do 
11:21:15 <gganley> Cale: but how would dependent typing help with the issue? I have heard of dependent typing but have no idea what it is 
11:21:31 <Cale> gganley: Well, it lets you have types which depend on terms
11:21:46 <gganley> Cale: terms in what sense
11:22:01 <Cale> In the sense of value-level expressions
11:22:18 <Cale> gganley: So you could have a type which was parameterised on the functions f and g
11:22:25 <gganley> Cale: like 2+2? or something
11:22:29 <Cale> (as well as their domains and codomains)
11:22:52 <Cale> Or indeed, a type which depends on a natural number
11:23:01 <Cale> (like length-indexed lists)
11:23:24 <gganley> so with dependent typing we could have a type level function like dom(f) or cod(f) or something like that  
11:24:48 <Cale> Yeah, and not only that, you can have a type like  ArrowArrow f g  which would have fields like  h : dom f -> dom g  and  k : cod f -> cod g
11:26:01 <Cale> (and even, if you like, a term of type g . h = k . f -- since you can formulate a type for equalities between values in these languages)
11:26:42 <Ainieco> could you please give a hint on https://mightybyte.github.io/monad-challenges/pages/ex3-5.html ? i know the type signature but it doesn't make sense to me
11:29:18 <Cale> Ainieco: You want a hint about how to write the function or a hint on how it would be used?
11:29:52 <Cale> Ainieco: Basically, this is aiming at an Applicative instance for lists -- I can't say I'd have introduced things in this order...
11:30:04 <Cale> Ainieco: Do you already happen to know about (<*>) or ap?
11:32:48 <dalastboss> can anyone explain why this is a parse error
11:32:49 <dalastboss> http://pastebin.com/8bp9ewNC
11:32:51 <Cale> Ainieco: (It's okay if you don't, I just want to tune the explanation)
11:32:56 <dalastboss> it complains about the last line
11:33:29 <ClaudiusMaximus> dalastboss: mismatched () if i count right
11:33:44 <synergistics> How could you have a partially applied Either data?
11:33:47 <Cale> dalastboss: Your function is supposed to produce an Int, but I don't think it's going to do so.
11:33:54 <dalastboss> ahh
11:34:03 <dalastboss> and yes you are right Cale, I'll need one last call
11:34:20 <ClaudiusMaximus> dalastboss: delete the ( before fromIntegral, because function application binds tighter than anything else
11:34:31 <ClaudiusMaximus> (including operator sections)
11:35:08 <dalastboss> "map (* 3600) . (/ (fromIntegral s)) deltas" has the same behaviour?
11:35:24 <ClaudiusMaximus> map ((* 3600.0) . (/ fromIntegral s)) deltas
11:35:25 <Ainieco> Cale: i'd like to understand how this function will be used and i don't know about <*> or ap, sorry
11:35:51 <dalastboss> ah that makes more sense
11:36:01 <Cale> Ainieco: That's okay, so I think the best thing is just to see a usage of <$> and <*> working together...
11:36:08 <Cale> Ainieco: and then piece through it
11:36:32 <Cale> So, suppose we have some function of three arguments f :: A -> B -> C -> D
11:36:51 <Cale> (<$>) is just another name for fmap, we have
11:37:06 <synergistics> If the type of "Left 1" is Num a => Either a b, what's the type for "b"?
11:37:14 <Cale> :t (<$>)
11:37:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:37:43 <Cale> So now, if we take some list  xs :: [A]
11:37:49 <Cale> Then we'll have:
11:38:01 <Cale> f <$> xs :: [B -> C -> D]
11:38:03 <Cale> right?
11:38:24 <Cale> Ainieco: good so far?
11:38:50 <Ainieco> Cale: yup
11:38:52 <Cale> okay
11:38:53 <ClaudiusMaximus> synergistics: its unconstrained, type inference will pick something that fits the context in which it is used
11:38:59 <Cale> So, now we get to use (<*>)
11:39:03 <Cale> :t (<*>)
11:39:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:39:16 <Cale> Suppose we have ys :: [B}
11:39:18 <Cale> oops
11:39:19 <Cale> Suppose we have ys :: [B]
11:39:37 <ClaudiusMaximus> synergistics: just like the Num a constrains the a, so type inference has fewer types to choose from, the calling context might make it a Double or an Int or something else
11:39:53 <Cale> then picking f = [], a = B and b = C -> D in the type of (<*>) gets us:
11:40:06 <Cale> (<*>) :: [B -> C -> D] -> [B] -> [C -> D]
11:40:19 <Cale> So we'll have
11:40:27 <Cale> f <$> xs <*> ys :: [C -> D]
11:40:38 <synergistics> ClaudiusMaximus: What type of function would depend on the type of b so that it would be inferred?
11:41:36 <Cale> Ainieco: cool? We can now go another step... if zs :: [C], then we'll have
11:41:47 <Cale> f <$> xs <*> ys <*> zs :: [D]
11:41:54 <ClaudiusMaximus> synergistics: example :: Either Int String -> Maybe Int ; example (Left x) = Just x ; example (Right s) = Nothing  -- this will force the b of  example (Left 1)  to be String
11:42:22 <Ainieco> Cale: oh, i think i understnad now, thank you!
11:42:40 <Cale> Ainieco: Yeah, play around with it a bit.
11:42:53 <Cale> > (+) <$> [1,2,3,4] <*> [50,60,70,80]
11:42:55 <lambdabot>  [51,61,71,81,52,62,72,82,53,63,73,83,54,64,74,84]
11:43:01 <ClaudiusMaximus> synergistics: this is a bit of a silly example, real programs tend to be subtle with deeper contexts ultimately determined by main
11:43:50 <synergistics> Ah I see
11:43:50 <Cale> > (\x y z -> 100*x + 10*y + z) <$> [1,2,3] <*> [4,5,6] <*> [7,8,9]
11:43:52 <lambdabot>  [147,148,149,157,158,159,167,168,169,247,248,249,257,258,259,267,268,269,347...
11:44:14 <Ainieco> Cale: nice!
11:45:43 <synergistics> ClaudiusMaximus: So how can Either be partially applied. For instance, the Functor instance for Either is pattern matched on (Either a) instead of just Either
11:47:45 <ClaudiusMaximus> synergistics: Functor expects a type with kind * -> * , ie a type constructor with one argument - it's Functor (Either a) because Functor Either would be a kind error (Either :: * -> * -> * which doesn't match)
11:48:46 <ClaudiusMaximus> synergistics: the kind * is the kind of types which have values - you can't have values of type Either or Either a, it needs to be fully applied to Either a b
11:50:49 <synergistics> Then how could it ever be partially applied if using Left and Right to construct an Either value will have the type of Either a b automatically?
11:52:03 <ClaudiusMaximus> synergistics: Functor (Either c) has fmap :: (a -> b) -> Either c a -> Either c b - so by the time it gets to talking about values it's fully applied
11:52:20 <synergistics> Just got that
11:52:27 <synergistics> Makes sense
11:52:42 <synergistics> Then why does the Functor instance for Either even pattern match on Left?
11:53:51 <ClaudiusMaximus> you mean why not have a catch-all definition at the bottom like  fmap f x = x ?  the types don't match!   in fmap f (Left x) = Left x  the Left has a different type on each side of the definition
11:53:58 <monochrom> you are probably conflating "Functor (Either c)" at the type level with "fmap takes how many parameters?" at the value level
11:58:05 <synergistics> I mean, wouldn't "Either a" only be matchable on Rights and not Lefts since "Either a" is already pattern matching on the left side?
11:58:26 <mauke> wat
11:59:04 <synergistics> Nevermind, I confused myself too
11:59:43 <monochrom> "Either a" is not the type of Left values
12:00:14 <synergistics> Left values are of type "Either a b"
12:00:57 <monochrom> and fmap still wants an "Either a b" parameter not an "Either a" parameter
12:01:10 <monochrom> despite what Functor says about "Functor (Either a)"
12:01:24 <synergistics> Makes sense
12:01:58 <synergistics> I think I get it
12:02:45 <synergistics> fmap on Left has to be constant because you can only make a Functor out of "Either a". By the definition of fmap, the "a" is constant
12:03:57 <synergistics> fmap :: (b -> c) -> Either a b -> Either a c. fmapping on the Left would have to be of type a and return something of type a
12:04:01 <synergistics> I think
12:05:48 <gganley>  Cale: they make a lot of refrences to Cayley representation. What do they mean by a Cayley representation?
12:06:24 <ClaudiusMaximus> synergistics: and because you don't know anything about 'a', you have to return the 'a' you are given from the Left (or undefined) - keyword "parametricity" iirc - and because fmap id = id (Functor law) you can't return undefined so  fmap f (Left x) = Left x  is the only legal definition
12:06:49 <monochrom> I personally do not think up any essay-type explanation. Instead, I just check types and laws.
12:07:21 <Cale> gganley: See page 13 (at least in the edition I have) -- it's introduced early in the book.
12:07:48 <Cale> gganley: They first define the Cayley representation of a group, and then the Cayley representation of a category.
12:08:00 <Cale> gganley: It's Theorems 1.5 and 1.6
12:08:05 <synergistics> ClaudiusMaximus: Yea, exactly
12:08:19 <gganley> Cale: its in my edition also. I'll try and understand it better thank you
12:08:52 <Cale> gganley: If that's what you're reading right now, then I suppose the answer to your question is "that is the phrase which is presently being defined" :)
12:10:51 <Guest00000> how to install support for compiling via LLVM under Windows? GHC manual had a link to an installer, but it didn't seem to install any "opt.exe" or "llc.exe"
12:13:00 <synergistics> So is there any semantic meaning to pattern matching on "Either a" for the Functor instance, or is it just to get the kind proper? I haven't been able to think of "Either a" in any intuitive sense
12:13:29 <mauke> you can't pattern match on types
12:13:51 <kadoban> synergistics: You mean is there semantic meaning to the Functor instance for Either a? (not really clear to me from your wording)
12:14:36 <synergistics> kadoban: Sorry, that's what I meant. 
12:15:05 <kadoban> synergistics: "Either a" Functor/Applicative/Monad I think of as computation that can fail, with an error
12:15:48 <kadoban> So fmap (+1) is something like, if we haven't failed yet, add one.
12:16:16 <synergistics> kadoban: Oh, that makes sense
12:17:54 <deepfire> is liftM obsolete?
12:18:44 <kadoban> deepfire: Pretty much, yeah. It's fmap with a more restrictive type. There's times I use it for code that needs to target GHC 7.8 or whatever though.
12:18:46 <Cale> Sort of, except that it still serves a purpose when it comes to writing the Functor instance for something which you've made a Monad
12:18:59 <kadoban> Oh yeah, that too.
12:19:03 <Cale> (as an easy way to implement fmap)
12:19:32 <Cale> You're required to write the Functor instance now if you have a Monad instance, but nothing says you can't do it by using the Monad operations :)
12:20:22 <kadoban> Cale: Is there anything that says that liftM isn't just defined as liftM = fmap though, just out of curiosity?
12:20:55 <Cale> Well... the source code :P
12:21:03 <kadoban> Haha, I guess.
12:21:05 <Cale> Apart from that, I suppose not.
12:22:05 <geekosaur> kadoban, you can only do that if you have a Functor instance around, whereas if you want to say fmap - liftM it's because you don't have such an instance
12:22:14 <geekosaur> s/-/=/
12:22:47 <geekosaur> hm,although I guess i can;t verify that at compile time (open world)...
12:23:49 <deepfire> hmm..
12:25:04 <Rembane> On the other hand, doesn't a typeclass need to implement Functor to implement Monad?
12:25:13 <geekosaur> now, yes
12:25:19 <kadoban> geekosaur: I was just curious if there was something preventing the GHC maintainers from changing liftM's definition to liftM = fmap, and thus breaking some user code. Not that they would, but just was curious.
12:25:24 <deepfire> I guess the discussion is dangerously close to opening the obsoleteness-of-return can'o'worms..
12:25:28 <geekosaur> that;s the problem; this comes up when porting software written for pre-ghc 7.10
12:25:43 <Rembane> Aha.
12:25:46 <Rembane> Thanks.
12:25:52 <monochrom> "liftM f a = a >>= return . f" came from a time when the Functor instance was optional.
12:26:49 <monochrom> I don't think change it breaks any code out there, since you're doing it in sync with the same base that promises Functorness.
12:27:21 <monochrom> I mean certainly you are not changing it in base-3.0.0.0
12:29:16 <mniip> 1455395059 [23:24:19] <monochrom> "liftM f a = a >>= return . f" came from a time when the Functor instance was optional.
12:29:24 <mniip> everybody and their mom has a functor instance now though
12:29:30 <geekosaur> sadly not
12:29:44 <geekosaur> this porting issue comes up often enough to be annoying
12:29:52 <monochrom> mniip, what is your point?
12:29:55 <andromeda-galaxy> hmm, is there a lens for getting all of the indices of an indexed collection? I can't find anything when looking at all the functions around IndexedTraversal...
12:29:56 <mniip> well, besides structures that aren't covariant functors
12:30:15 <mniip> monochrom, I don't know, is it mandatory to have one?
12:30:56 <monochrom> ok, you admit you don't know what your point is. I figured that much.
12:31:28 <mniip> random comment on the AMP I guess?
12:36:13 <puregreen> andromeda-galaxy: itoListOf gives you indexes and values, you can just strip the values afterwards
12:37:02 <Ste1891> Hi.  May seem obvious but...If the return value of a pure function appears more than once in the construction of another value (e.g. [(foo x y) !! 0, 0, (foo x y) !! 1, 1]), would GHC "realise" the same computation doesn't need to be done twice and optimise this out of the binary?
12:37:25 <mniip> sometimes
12:37:41 <monochrom> low chance yes, high chance no, see the generated core to find out
12:37:54 <mniip> might want to do that explicitly with let v = foo x y in [v !! 0, 0, v !! 1, 1]
12:38:03 <kadoban> Ste1891: You should probably just use a 'let' or whatever if it's important
12:38:56 <mniip> CSE sometimes gives performance improvement, but also sometimes gives memory footprint increase. So GHC is not very eager to do CSE
12:39:36 <Ste1891> Oh, I thought let was just for avoiding writing the same thing several times.  I didn't realise it affected the compilation.
12:40:36 <mniip> of course it does
12:40:57 <mniip> you're excplicitly requesting that v and v are the same closure
12:41:26 <Gurkenglas> <mniip>	is 'ConstT r m a = m r' a thing? <- What's lift?
12:41:29 <andromeda-galaxy> pureGreen: okay, I'll just use that, thanks.  I was just wondering if there was any other way
12:42:28 <mniip> Gurkenglas, hmm yeah, just like Const it's not a monad
12:42:32 <mniip> it can be applicative though
12:42:48 <Gurkenglas> mniip, Compose (Const r)
12:42:58 <mniip> ah right
12:42:59 <mniip> that
12:43:25 <mniip> "applicative transformers" are as easy as that?
12:43:56 <jellie> A short and easy way to drop everything before and including the first slash in a path in haskell?
12:43:59 <jellie> e.g
12:44:10 <andromeda-galaxy> puregreen: hmm, actually, maybe I phrased that badly.  is there any lense for, given an Ix'd collection, like a Map/IntMap/List (specifically IntMap) to get the keys out? itoListOf looks like it would require .itraversed and then a few extra modifiers , which seems awfully complicated...
12:44:13 <jellie> ./wewe/ere.hs to wewe.ere.hs
12:44:48 <Gurkenglas> > tail . dropWhile (/= '/') $ "./wewe/ere.hs"
12:44:51 <mniip> drop 1 . dropWhile (/= '/')
12:44:53 <lambdabot>  "wewe/ere.hs"
12:45:01 <mniip> (tail is evil)
12:45:11 <Ste1891> Great.  I would usually use let in those kind of situations anyway.  I was just interested in how much time optimisation is done automatically.
12:45:17 <andromeda-galaxy> (also, I'm actually doing all of this stuff using the state monad operators...)
12:46:10 <puregreen> andromeda-galaxy: okay, I've just noticed that there's also itoList, it makes it easier
12:46:17 <Gurkenglas> andromeda-galaxy, to M.keys
12:46:33 <puregreen> map fst . itoList :: Map k v -> [k]
12:47:35 <Ste1891> Thanks then.  Bye...
12:47:47 <ClaudiusMaximus> jellie: case span (/= '/') s of (_, '/':x) -> x ; (x, "") -> ?  -- explicitly handles the case of no slashes, what do you want the ? to be
12:47:58 <puregreen> Gurkenglas: congrats on solving the X of the XY problem, I should've thought of it
12:48:07 <andromeda-galaxy> Gurkenglas: oh, that's a nice idea, thanks.  puregreen: oh I see, I missed that somehow, thanks!
12:50:28 <jellie> ClaudiusMaximus: What?
12:51:08 <ClaudiusMaximus> jellie: what do you want to happen if your path doesn't contain any '/' at all?
12:52:55 <ClaudiusMaximus> > drop 1 . dropWhile (/= '/') $ "no.slashes.here"
12:52:59 <lambdabot>  ""
12:53:51 <jellie> ClaudiusMaximus: Just leave it.
12:54:25 <jellie> I specifically want to get rid of a leading "./" in any path.
12:55:17 <yaxu> hi all does anyone know an easy way of getting ghci running on a raspberry pi?
12:58:39 <Wobble> !id hi
12:58:39 <botWobble> hi
12:58:44 <Wobble> !quit
12:59:04 <fnurglewitz> hi, may I ask a question here or there is a more specific channel for beginners?
12:59:16 <monochrom> this channel is good
12:59:20 <mauke> this is the right channel
13:00:54 <andromeda-galaxy> hmm, i sthere a state-monadic version of 'at' in lens?
13:00:59 <fnurglewitz> on the book I'm reading an exercise asks to implement my own version of enumFromTo, which has type signature Enum a => a -> a -> [a]
13:01:19 <fnurglewitz> I did that recursively and used a guard to check the base case
13:01:26 <andromeda-galaxy> oh wait, never mind
13:01:31 <puregreen> andromeda-galaxy: what do you mean by “state-monadic”? you can use all lenses with state monads with .= and %=
13:01:36 <fnurglewitz> on that guard I used fromEnum 
13:01:48 <fnurglewitz> which has signature: a -> Int
13:02:01 <fnurglewitz> my question is, if a is an Integer bigger than an Int
13:02:15 <fnurglewitz> how does fromEnum represent it inside an Int?
13:02:23 <fnurglewitz> is it "modular"?
13:02:28 <Cale> fnurglewitz: Poorly.
13:02:41 <monochrom> > fromEnum (100000000000000 :: Integer) :: Int
13:02:43 <lambdabot>  100000000000000
13:02:49 <Cale> fnurglewitz: You probably want to implement enumFromTo without using toEnum/fromEnum
13:02:51 <monochrom> ok, I need a bigger number
13:02:55 <mauke> > fromEnum (toInteger (maxBound :: Int) + 1)
13:02:57 <lambdabot>  -9223372036854775808
13:03:02 <monochrom> > fromEnum (10^10 :: Integer) :: Int
13:03:04 <lambdabot>  10000000000
13:03:10 <monochrom> nevermind
13:03:12 <OverCoder> How to remove duplicates from a list?
13:03:25 <Cale> OverCoder: nub, if you don't want to rearrange the list
13:03:28 <mauke> Cale: is that even possible?
13:03:34 <OverCoder> hm
13:03:47 <Cale> OverCoder: map head . group . sort  is a decent way if you don't mind sorting
13:04:00 <Cale> I believe there's a nubOrd somewhere...
13:04:20 <Wobble> OverCoder: Or maybe try any(==) statement?
13:04:22 <mauke> the perl way would be to fold a set through the list
13:04:39 <OverCoder> hmmm
13:09:26 <Cale> > foldr (\x xs s -> if x `S.member` s then xs s else x : (xs (S.insert x s))) (const []) [2,1,4,2,1,2,6,3,5,1,5,3,5]  S.empt
13:09:27 <lambdabot>      Not in scope: ‘S.empt’
13:09:28 <lambdabot>      Perhaps you meant one of these:
13:09:28 <lambdabot>        ‘S.empty’ (imported from Data.Set),
13:09:28 <Cale> oops
13:09:30 <Cale> > foldr (\x xs s -> if x `S.member` s then xs s else x : (xs (S.insert x s))) (const []) [2,1,4,2,1,2,6,3,5,1,5,3,5]  S.empty
13:09:32 <lambdabot>  [2,1,4,6,3,5]
13:11:08 <Cale> This algorithm probably ought to be in Data.List but I don't think it is. (yet?)
13:11:23 <mniip> is Data.Map in base?
13:11:26 <mauke> > foldr (\x xs s -> if x `S.member` s then xs s else x : (xs (S.insert x s))) (const []) [0 ..]  S.empty
13:11:28 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:11:39 <mniip> (I think it might be containers)
13:11:46 <mniip> errrr
13:11:48 <mniip> Data.Set I mean
13:12:17 <Cale> It's in containers
13:12:40 <mniip> so there's your answer
13:13:03 <Cale> That wouldn't prevent someone from grabbing a quick implementation of sets in order to implement that function though.
13:13:17 <mniip> "quick implementation of sets"
13:13:26 <mniip> haha, have you seen the containers implementation?
13:13:42 <Cale> You can do the relevant part of red-black trees in like 20 lines or something.
13:14:21 <mniip> easier to include it in containers somehow imo
13:14:29 <Cale> Yeah, maybe
13:14:58 <maerwald> Cale: hah, 20 lines in haskell doesn't mean it's quick :P
13:15:51 <kadoban> It is though. red-black trees are a dream to write in haskell. Basically anything tree-ish I've tried. So nice.
13:15:54 <Cale> Ah, just found an implementation in Neil Mitchell's extra package, and that's *exactly* what he does.
13:16:09 <exio4> maerwald: O(logn) vs O(n^2)
13:16:11 <Cale> https://hackage.haskell.org/package/extra-1.4.3/docs/src/Data-List-Extra.html#nubOrd
13:16:45 <kadoban> exio4: I think they meant quick to write. (and it'd be O(n lg n) vs O(n^2))
13:17:07 <exio4> oh, right, sorry.
13:17:22 <mauke> kadoban: try splay trees :-)
13:18:15 <kadoban> mauke: Well, those are awkward because you need reads to be able to modify the tree, which is a bit troublesome, but actually implenting it shouldn't be particularly hard, right?
13:18:51 <mauke> I don't know, I was only thinking about the first part
13:19:12 <kadoban> Yeah. It'd be pretty annoying to use if nothing else.
13:19:24 <mniip> > foldr (\x cont p -> if p x then cont p else x : cont (\x' -> x' /= x && p x')) (const []) [2,1,4,2,1,2,6,3,5,1,5,3,5] (const True)
13:19:26 <lambdabot>  []
13:19:41 <mniip> > foldr (\x cont p -> if p x then cont p else x : cont (\x' -> x' == x || p x')) (const []) [2,1,4,2,1,2,6,3,5,1,5,3,5] (const False)
13:19:43 <lambdabot>  [2,1,4,6,3,5]
13:20:00 <bradley_hardy> I tried to register for a Hackage account yesterday, and it told me I would receive an email to complete the registration process, but I never got it. Anyone know what's going on with that?
13:22:56 <geekosaur> bradley_hardy, try #hackage or #haskell-infrastructure?
13:23:07 <bradley_hardy> thanks, will do
13:23:08 <geekosaur> but first check your spam trap
13:23:46 <bradley_hardy> I already looked there
13:23:55 * hackagebot wai-routing 0.12.3 - Declarative routing for WAI.  https://hackage.haskell.org/package/wai-routing-0.12.3 (ToralfWittner)
13:44:24 <gganley> Cale: on page 12, def 1.4 item 2. how can function composition be useed on the elements of G. I thought G was a subgroup of Aut(X).
13:44:33 <Gurkenglas> Why doesn't MonadTrans have "Monad m => t Identity a -> t m a" as part of the class definition, to generalize "MaybeT . return" and "ListT . return" and "state"?
13:44:58 <Wobble> !quit
13:45:21 <Cale> gganley: What are the elements of Aut(X)?
13:45:23 <bradley_hardy> Gurkenglas, look for MFunctor on Hackage
13:45:30 <akfp> is there a STM map data structure?
13:45:46 <bradley_hardy> With that you can do hoist (return . runIdentity) to achieve what you're after
13:45:47 <Gurkenglas> (Oh wait Maybe is only isomorphic to MaybeT Identity ._.)
13:47:02 <gganley> Cale: the set of automorphisms of X? so the elements of G are themselves functions. ok thats why it works.
13:47:40 <jaen> Wondering about the Validation applicative - I understand it's there to `or` validations as in, say, checking the age and presence of username (which are orthogonal validations), but what about validations that depend on each other so you would have to `and` them to short circuit, for example validating that a string is a number and then performing range check on the coerced value.
13:47:41 <Cale> right :)
13:48:25 <jaen> It seems (disclaimer: don't have much in the way of intuition here) that one behaviour is what makes the applicative validation desireable, the other - a validation monad. But there's only a validation applicative in common usage
13:48:28 <jaen> What am I missing?
13:49:04 <EvanR> "A commutative monoid is the same as a monoid in the category of monoids." eh?
13:49:37 <EvanR> is this a weird definition of a commutative monoid, or is it talking about any commutative monoid from algebra
13:50:07 <EvanR> or just wrong
13:50:23 <Cale> EvanR: It's true, but there are two different definitions of "monoid" in use there.
13:51:31 <Cale> There's the old fashioned monoid consisting of a set together with a binary operation that is associative and has an identity element -- in this case, a commutative such thing.
13:51:44 <Cale> and then we have the definition of a monoid object in a monoidal category
13:52:22 <EvanR> where does the commutativity come from
13:53:00 <EvanR> the category laws?
13:53:03 <Cale> It's an Eckmann-Hilton sort of argument, if that means anything to you... the Catsters videos cover exactly this thing in detail, so I should probably just link you
13:54:15 <EvanR> ok
13:54:34 <nocturne777> It is really strange that the author of Control.Concurrent.Async chose IO over MonadIO
13:54:49 <nocturne777> what could be the rationalte behind that?
13:55:22 <Cale> EvanR: https://www.youtube.com/watch?v=PH-OhkrXXvA Monoid objects 1 (intro definition of a monoid object in a monoidal category)
13:55:54 <Cale> https://www.youtube.com/watch?v=7Sf3Y4sesZE Monoid objects 2 (shows that the category of monoids is a monoidal category and goes after the statement you were puzzling about)
13:56:29 <Cale> https://www.youtube.com/watch?v=Rjdo-RWQVIY -- Eckmann-Hilton 1 -- this gets used by the previous video
13:57:13 <Cale> nocturne777: hm?
13:57:30 <Cale> nocturne777: If you mean IO, use IO.
13:57:59 <Cale> nocturne777: A lot of the operations in that module don't generalise.
13:59:05 <nocturne777> Cale: I am in my custom monad stack and I want to do some operations async, but the fact that the functions in that library take (IO a) make it difficult
13:59:10 <Cale> MonadIO is a type class which says "we have a way to turn IO actions into actions in this monad" -- it doesn't give you a way to go the other way around.
13:59:20 <Cale> That's right, because it's hard.
13:59:27 <nocturne777> I am getting compilation errors like this: Could not deduce (m ~ IO)
13:59:33 <Cale> The precise structure of your monad matters.
13:59:53 <Cale> and there are multiple ways that you might have that extra structure interact with the higher order operations
14:00:06 <Cale> (or perhaps none, in some cases)
14:00:07 <EvanR> if you are a MonadIO monad, then use liftIO to do IO
14:00:08 <Wobble> !uptime
14:00:08 <botWobble> 31s
14:00:17 <Wobble> !id hi
14:00:17 <botWobble> hi
14:00:19 <Wobble> !quit
14:00:23 <nocturne777> Cale: I can create an (IO a) function
14:00:33 <nocturne777> in the where clause
14:01:09 <pantsman-> there is lifted-async, but that uses MonadBaseControl IO, not MonadIO
14:01:10 <Cale> Right, you can use liftIO to go in one direction, but applying higher order things like async, you'll still be required to provide a plain IO action as the argument.
14:01:15 <nocturne777> and liftIO that function in the body of the function that works with custom monad
14:01:17 <Cale> and there's not really a way around that
14:01:23 <nshepper1> nocturne777: most ThingT actions are difficult if not impossible to make sense of running asynchronously
14:01:51 <Cale> nocturne777: Exactly how is the monad you're using defined?
14:02:52 <lpaste> nocturne777 pasted “appmonad” at http://lpaste.net/152368
14:03:05 <nocturne777> Cale: I pasted the example
14:03:17 <nocturne777> that is my current monad
14:03:31 <OverCoder> What happens if I return Just Nothing in a function?
14:03:41 <EvanR> > Just Nothing
14:03:43 <lambdabot>  Just Nothing
14:03:52 <EvanR> ^
14:03:52 <OverCoder> hm
14:03:57 <OverCoder> > Just Nothing == Nothing
14:03:59 <lambdabot>  False
14:04:03 <OverCoder> aw
14:04:06 <EvanR> indeed
14:04:20 <EvanR> > join (Just Nothing)
14:04:22 <lambdabot>  Nothing
14:04:33 <Sornaensis> >> fmap (== Nothing) (Just Nothing)
14:04:34 <Sornaensis> > fmap (== Nothing) (Just Nothing)
14:04:36 <lambdabot>  Just True
14:04:54 <OverCoder> hmm
14:05:31 <Cale> nocturne777: How much code is there which uses this App type?
14:05:32 <Adeon> :t Just Nothing
14:05:33 <lambdabot> Maybe (Maybe a)
14:05:46 <Adeon> :t Just (Just 5)
14:05:48 <lambdabot> Num a => Maybe (Maybe a)
14:05:55 <Adeon> :t Nothing :: Maybe (Maybe Int)
14:05:55 <nshepper1> nocturne777: so what do you want to happen if your subroutine running in a separate thread fails with a ServantErr (in ExceptT)?
14:05:56 <Cale> nocturne777: Perhaps consider using  AppConfig -> IO (Either ServantErr a)  instead.
14:05:56 <lambdabot> Maybe (Maybe Int)
14:06:40 <nocturne777> Cale: that is the plan
14:07:08 <Gurkenglas> > (`evalState` S.empty) . runListT . ((runReaderT $ do guard . not =<< ReaderT (gets . S.member); ReaderT $ modify . S.insert; ReaderT return) <=< ListT . return) $ [2,4,2] ++ [0..] -- Argh the library goodness is introducing so much plumbing
14:07:10 <lambdabot>  [2,4,0,1,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:07:36 <nshepper1> O_O
14:07:41 <nocturne777> nshepper1: I would except the user to get Internal Error (500) response in this case
14:07:51 <Cale> nocturne777: I mean, you can go forward with this monad transformer shenanigans, but I would tend to shy away from it unless I had a very clear idea of the operations that I would need up front, and knew that the monad transformers would actually get me there.
14:08:07 <Cale> nocturne777: As soon as you apply a transformer to IO, you give up a lot of stuff.
14:10:58 <nocturne777> Cale: you suggest that I keep the entire thing IO ?
14:11:06 <nocturne777> that will introduce a lot of boilterplate code
14:11:15 <Cale> oh?
14:11:18 <nshepper1> nocturne777: note that you can convert App a -> AppConfig -> IO (Either ServantErr a) by just unpacking the monad transformer constructors
14:11:29 <EvanR> Cale: that is wild (the commutative monoid thing)
14:12:04 <Cale> nocturne777: What does the boilerplate look like?
14:12:13 <nshepper1> :t (\m r -> runExceptT (runReaderT m r))
14:12:14 <lambdabot> ReaderT r (ExceptT e m) a -> r -> m (Either e a)
14:12:27 <Cale> nocturne777: Perhaps we can find another way to abstract it instead.
14:14:06 <lpaste> nocturne777 pasted “db call” at http://lpaste.net/152372
14:14:07 <lpaste> nocturne777 pasted “db call” at http://lpaste.net/152373
14:14:14 <grayling_> I have an [Either SomeException a] that I want to turn into (Either SomeException [a]). Any good suggestions?
14:14:15 <nocturne777> sorry for double paste
14:14:31 <nocturne777> Cale: I have db calls like show in my last paste
14:14:35 <pavonia> :t sequence
14:14:37 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:14:51 <pavonia> grayling_: ^
14:15:05 <nocturne777> since my App monad is an instance of MonadClient, I don't have to mention the state of the db in the call
14:15:05 <grayling_> Thanks. :-)
14:15:31 <nocturne777> otherwise, I have to do stuff like this  "runClient dbClientState $ CS.write q p
14:15:36 <Cale> nocturne777: Yeah, but that's a single function parameter, which is usually not much of a pain compared to having to use liftIO everywhere.
14:16:17 <grayling_> Weird. I couldn't find that on Hoogle. Thanks again.
14:16:42 <Cale> (and making things like async and forkIO and catch awkward to use)
14:16:58 <nocturne777> Cale, if I do what you suggest,  I would access the state of the db through a TVar or smth, correct?
14:17:22 <Cale> Possibly... you could do a number of different things...
14:17:41 <Gurkenglas> grayling_, that's because hoogle doesn't look for more general type signatures than you provided. (Hint hint to everyone looking for something to implement)
14:17:51 <Cale> You could pass around a record of various operations on your DB.
14:18:36 <Cale> Or you could pass around some kind of handle to the DB connection directly.
14:19:30 <Cale> You may or may not want to put it in an IORef
14:19:47 <Cale> I'm not sure whether I can imagine a use case for putting it in a TVar vs. IORef
14:19:52 <monochrom> although, ReaderT IO is not the most complicated when it comes to extending forkIO and catching exceptions.
14:19:54 <Cale> Since such things are usually not really inspectable.
14:20:32 <nocturne777> if I put it an IORef, I have global state
14:20:39 <Cale> Sure, it's doable in the case of ReaderT, just awkward.
14:20:49 <EvanR> nocturne777: you mean a top level IORef?
14:20:55 <nocturne777> EvanR: yeah
14:21:04 <EvanR> globalssss
14:21:10 <Cale> nocturne777: This would be an IORef you'd pass around explicitly as part of your application state.
14:21:19 <nocturne777> so that I can refer to the dbstate, instead of passing as an argument all over the place
14:21:22 <Cale> That's assuming it even needs to be an IORef
14:21:30 <Cale> (which is questionable)
14:21:46 <Cale> Making it an IORef would let you swap out your database connection for another.
14:21:49 <EvanR> it needs to be an IORef so it can start uninitialized and later written to like a C program ;)
14:21:59 <Cale> IORef doesn't make that easy
14:22:03 <Cale> MVar kind of does
14:22:04 <EvanR> nocturne777: really this a bad idea
14:22:13 <Gurkenglas> @let f = 2 * ?x
14:22:15 <nocturne777> EvanR: that's what I was thinking
14:22:15 <lambdabot>  Defined.
14:22:31 <EvanR> Cale: newIORef undefined ;)
14:22:32 <Gurkenglas> > let ?x = 2 in L.f -- Implicit parameters!
14:22:35 <lambdabot>  4
14:22:38 <nocturne777> EvanR: with monad transformers I can avoid stuff like that
14:22:59 <nocturne777> for now I might even use "lifted-async" package
14:23:01 <EvanR> nocturne777: ReaderT IO will work... theres also odd ball features like implicit parameters
14:23:11 <monochrom> @undefine
14:23:11 <lambdabot> Undefined.
14:23:12 <Cale> nocturne777: As a start, I would just put the DB connection into your AppState type, and pass it around by hand.
14:23:37 <Cale> nocturne777: But you might do better than that by instead putting a bunch of operations on your DB into your AppState.
14:24:14 <Cale> and then you can swap out the database with something entirely different later.
14:25:32 <Cale> and just don't worry about the function parameter, it won't really get that bad -- most of the time it's significantly nicer than working in some monad built using transformers over IO
14:26:22 <nocturne777> hmm, I will mull over these suggestions for sure
14:27:13 <nocturne777> I will need to go now, thank you for taking the time to discuss the issue with me
14:28:23 <Cale> nocturne777: Okay, if it comes down to needing to prevent some parts of the program from doing arbitrary IO, and only having the ability to interact with the database, there's a way to make that happen to
14:28:25 <Cale> too*
14:28:50 <Cale> nocturne777: You can parameterise the record of database operations on a choice of monad (which you know is going to be IO)
14:29:55 <Cale> data DBOps m = ...;  foo :: Monad m => DBOps m -> m ()
14:30:41 <Cale> and even if you only ever apply foo with m = IO, the implementation of foo can't assume that, and so can only use the operations you give it
14:34:58 <EvanR> oh nice
14:36:00 <pavonia> Is there a currently recommended pattern/package for handlung pure errors/exceptions?
14:36:11 <pavonia> *handling
14:38:51 <Gurkenglas> pavonia, Either e. (Equivalently, https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Except.html )
14:39:31 <deepfire> why is DoAndIfThenElse sabotaged by Cabal?
14:40:45 <bradley_hardy> pavonia: you could also use https://hackage.haskell.org/package/exceptions-0.8.2.1/docs/Control-Monad-Catch-Pure.html if you want more composability, but without having the type of the errors exposed in the type signature of your funcions.
14:40:46 <pavonia> Gurkenglas: Hhm, I've read somewhere that this is considered an anti-pattern now. There was something with typeclasses, but I don't recall exactly which
14:41:09 <Gurkenglas> Tell me when you find that.
14:41:35 <bradley_hardy> You'd write your pure code in 'MonadThrow m => ...'
14:42:14 <Gurkenglas> (I like EitherT more than ExceptT, but you did say exceptions)
14:42:16 <pavonia> Yeah, could be that's what I meant
14:44:09 <bradley_hardy> 'MonadThrow m' is great for writing pure code that can go wrong and composes effortlessly into IO code.
14:45:25 <pavonia> Gurkenglas: It actually was MonadThrow recommended in this blog post: https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices
14:46:48 <pavonia> They are only referring to wrapping that around IO, though
14:48:38 <Gurkenglas> What makes MonadThrow purer than throwing and catching using Control.Exception?
14:49:06 <bradley_hardy> If you use 'Control.Exception' directly you're stuck in IO.
14:49:39 <bradley_hardy> You can run your code in a pure environment with the CatchT monad I linked to above with this one, which is useful for testing.
14:51:02 <pavonia> My problem is, I have several pure functions that return Either FooError a, Either BarError b etc. I'd like to compose somehow, ideally without defining a lot of sum types
14:51:34 <pavonia> bradley_hardy: Would you use the Identity monad with MonadThrow if you are dealing with pure functions then?
14:52:12 <bradley_hardy> It would be easy enough to write a function with type '(MonadThrow m, Exception e) => Either e a -> m a'
14:52:28 <bradley_hardy> And yeah.
14:54:11 <pavonia> Okay, thanks
15:08:10 <csd_> why are applicatives often referred to as `effects` -- not to be confused with IO side effects
15:09:06 * hackagebot servant-elm 0.1.0.0 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.1.0.0 (mattjbray)
15:16:03 <AbelianGrape> Hello, all. I am using the Dimensional library, which provides statically checked physical unit types. I am running into a problem. I have two concrete physical units A and B. I have a term of type (A*B)*c, but the typechecker is failing to see that this is equal to A*(B*c) (the syntactically derived type of the term). Is there some trick to convince the compiler these are equal? 
15:16:39 <AbelianGrape> That is to say, the type that I want in the type signature is (A*B)*c, but the type Haskell thinks the term is is A*(B*c)
15:16:56 <scshunt> that's because it is
15:17:01 <AbelianGrape> Well, yes, it is
15:17:10 <mauke> I've never seen Dimensional but doesn't it provide conversion functions for this?
15:17:20 <AbelianGrape> but what I'm asking is how to work with the checking engine to get it to see the associative truth
15:17:26 <scshunt> you will need to introduce a proof (conversion function) that the types are identical
15:17:40 <scshunt> and AFAIK you must manually introduce it; it won't do it automatically
15:18:58 <geekosaur> one of the problems with using the type system to check this is that the type system doesn't know about associativity, so you have to deal with that somehow yourself
15:19:01 <AbelianGrape> scshunt: Would this proof be a term of type A*(B*c) -> (A*B)*c?
15:19:36 <AbelianGrape> geekosaur: I didn't have this problem with CLaSH IIRC, because it used a sum-of-products reduction system for numeric equality checking
15:20:15 <AbelianGrape> Also, is there some sort of "safe cast" function of type e.g. (a :=: b) => a -> b?
15:20:26 <AbelianGrape> That might work
15:21:35 <bradley_hardy> You can't do inductive proofs over Haskell's built-in type level naturals though, at least not last time I checked.
15:21:50 <AbelianGrape> :/ well shoot
15:22:00 <bradley_hardy> I suppose an 'unsafeCoerce :: (A*B)*C -> A*(B*C)' would solve it.
15:22:08 <mauke> http://hackage.haskell.org/package/dimensional-1.0.1.1/docs/Numeric-Units-Dimensional-Coercion.html
15:22:23 <mauke> "Note that use of these constructs requires the user to verify the dimensional safety of the conversion, because the coercion doesn't explicitly mention the unit of the representation."
15:22:32 <AbelianGrape> Thanks mauke!
15:23:32 <AbelianGrape> Thanks mauke!
15:23:36 <AbelianGrape> Oops, double tap
15:36:52 <hackrilege> hi!
15:37:05 <hackrilege> i have a nasty contraint error...
15:37:07 <hackrilege> http://lpaste.net/152376
15:38:36 <hackrilege> basically to make the mzero of a MonadPlus, i would like to use that the type it contains is a Monoid
15:39:28 <hackrilege> however a MonadPlus instance must have kind * -> *
15:39:49 <hackrilege> so i cannot supply the additional constraint
15:39:53 <nitrix> Is let actually sugar for a lambda?
15:40:59 <hackrilege> nitrix: seems so
15:42:12 <quchen> nitrix: How so?
15:42:13 <hackrilege> but maybe something funny about it forcing evaluation
15:42:59 <quchen> nitrix: Anyway, no, let is not sugar for lambdas.
15:43:07 <mauke> nitrix: almost, except for recursion and polymorphism
15:43:14 <hackrilege> oops sorry"
15:43:35 <hackrilege> i can see where you are coming from though
15:44:03 <nitrix> I'm using let inside do notation (no alternative there, the function is recursive and the value has to change based on the context).
15:44:12 <nitrix> And I was wondering how come let type-checked.
15:44:31 <nitrix> I have a hard time with "that's just how it is" explanations.
15:45:10 <mauke> I don't understand the problem
15:45:49 <nitrix> So be it then.
15:46:11 <mauke> can you show an example?
15:46:15 <hackrilege> if data Tree a = Leaf a | Branches [a], i struggle to write mzero
15:46:27 <hackrilege> :t mzero
15:46:28 <lambdabot> MonadPlus m => m a
15:46:35 <mauke> Branches []
15:46:37 <exio4> Branches [] ? :P
15:46:46 <daakr> hackrilege: put the type constraint on the Molecule declaration?
15:47:06 <hackrilege> DatatypeContexts is depriciated
15:47:25 <daakr> hackrilege: maybe you can simulate it with type families or something fancy like that?
15:47:27 <mauke> ITYM deprecated
15:49:01 <hackrilege> thanks, exio4,mauke, that works
15:49:22 <hackrilege> mzero = Polymer mzero
15:49:47 <`Guest00000> what is Polymer?
15:50:10 <hackrilege> data Molecule m a = Atom a | Polymer (m (Molecule m a))
15:50:44 <hackrilege> m is a MonadPlus, a is a Monoid
15:51:02 <hackrilege> but DatatypeContexts is depriciated
15:51:38 <mauke> that's still not a word
15:52:03 <hackrilege> !?
15:52:22 <hackrilege> ok thanks
15:52:23 <mauke> there's no i in deprecated
15:53:23 <hackrilege> depeciated
15:53:29 <hackrilege> r*
15:53:40 <kadoban> There's an i in depreciated, but it's a different word.
15:53:41 <nshepper1> it looks like you're trying to write depreciated, which is an unrelated thing to deprecated
15:53:51 <hackrilege> you guys are dicks
15:54:27 <nshepper1> :/
15:54:28 <mauke> patches welcome
15:54:38 <mauke> that is, suggestions on how to handle this differently
15:54:53 <hackrilege> i clearly meant depreciated
15:55:04 <mauke> but that makes no sense in this context
15:55:19 <hackrilege> you are not as dumb as the compiler...
15:55:23 <mauke> depreciate is a financial term
15:55:25 <nshepper1> depreciation is when something has less monetary value over time
15:55:34 <quchen> Let's just assume all words with "depr" mean "deprecated" and turn back to the Haskell-related part of the question.
15:55:43 <mauke> how depressing
15:56:17 <hackrilege> what quchen surggests should be implicit
15:56:53 <hackrilege> symantic discussion detracts
15:57:08 <mauke> "symantic" isn't a word either
15:57:10 <hackrilege> sorry i am having bad english
15:57:26 <quchen> mauke: Could you stop please
15:57:44 <`Guest00000> so. how do i use a binding library and compiling via LLVM backend together?
15:57:55 <mauke> quchen: just as soon as people stop being wrong on the internet
15:58:19 <hackrilege> your censoring my creed
15:58:30 <Gurkenglas> Your depravity is depreciated here
15:58:47 <hodapp> That someone said something wrong on the Internet really isn't an excuse for being a dick.
15:58:53 <hackrilege> i just wanted to know about the Monoid
15:59:27 <hackrilege> i will be more careful with spelling in the future
15:59:45 * nshepper1 generally prefers to be told when using a word wrong so I can be less wrong next time...
16:00:23 <hackrilege> at least we arnt in public
16:02:03 <hackrilege> basically, if a Monad of Monoids is a Monoid, but i must instead write a MonadPlus instance, i cant use that (m (m a)) is a monad of monoids for using foldMap
16:03:24 <hackrilege> i see that join is like an internal fold. i need that my datatype is Foldable, how do i correctly relate this to the Monadic opperation join?
16:04:05 <hackrilege> here is my paste;
16:04:06 <hackrilege> http://lpaste.net/152376
16:04:12 <Gurkenglas> One of the reasons for Set not being a functor is that Functor requires that you need no constraints (where Set needs Ord). https://hackage.haskell.org/package/constraints could help, if you really want.
16:04:55 <hackrilege> i cant see any documentation...
16:05:09 <kadoban> Gurkenglas: That's one of the better package descriptions I've seen XD
16:05:30 <hackrilege> i would prefer to keep in the stype of the paste rather than ivolving anything to do with lens
16:05:38 <Gurkenglas> That means the latest version is new and hasn't gotten its docs built by the volunteering machines yet. Switch to the second oldest version, it hasn't been obsolete for long
16:05:40 <hackrilege> style*
16:05:41 <mauke> hackrilege: https://hackage.haskell.org/package/constraints-0.6 has documentation but probably outdated compared to 0.8
16:06:04 <nshepper1> MonadPlus is different to Monads of Monoids
16:06:27 <hackrilege> unforturnately that documentation has destroyed my mind
16:06:46 <nshepper1> the point of MonadPlus is that it doesn't care what is 'contained'
16:07:12 <hackrilege> im trying to make nestings of Monads, which i can fold and unfold to use like hylo
16:07:28 <hackrilege> fold uses Monoids
16:07:31 <Gurkenglas> There should be a button that allows you to build and upload the hackage docs so you (and others) can read them
16:07:31 <hackrilege> :t foldMap
16:07:32 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:07:42 <hackrilege> i write instead mplus
16:07:46 <hackrilege> :t mplus
16:07:47 <lambdabot> MonadPlus m => m a -> m a -> m a
16:07:57 <hackrilege> than mappend
16:08:00 <hackrilege> :t mappend
16:08:00 <nshepper1> why do you want to use mplus
16:08:01 <lambdabot> Monoid a => a -> a -> a
16:08:22 <hackrilege> because foldMap uses mappend
16:08:38 <monochrom> what does "Monad of Monoid" mean, to begin with?
16:08:44 <hackrilege> its about how i want to write join to be like fold
16:09:08 * hackagebot servant-elm 0.1.0.1 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.1.0.1 (mattjbray)
16:09:32 <nshepper1> monochrom: a moderately inaccurate shorthand for (Monad m, Monoid a) => m a
16:09:37 <nshepper1> I assume
16:09:38 <hackrilege> (Monad m,Monoid a) => m a
16:09:48 <hackrilege> yep
16:10:03 <nshepper1> hackrilege: what's wrong with mappend
16:10:16 <hackrilege> i have a Monad of Monoids, not a Monoid
16:10:36 <hackrilege> i cant write; instance (Monad m,Monoid a) => Monoid (m a)
16:11:10 <nshepper1> you can certainly write 'instance (Monad m, Monoid a) => Monoid (Molecule m a)'
16:11:46 <hackrilege> so if join takes m (m a), and i want to use fold, then (m a) should be a monoid. but its a MonadPlus so i just want to use mplus, but thats not what foldMap required
16:12:19 <hackrilege> hmm, ill try that, thanks
16:13:17 <nshepper1> (without condoning your quixotic quest to write join in terms of fold...)
16:13:29 <hackrilege> explain
16:13:35 <hackrilege> since that is the end
16:13:54 <hackrilege> folding and joining are not synonymous?
16:14:10 <syncope> by the way, is it idiomatic haskell to always use <>, even for lists (when the Data.Monoid module is already imported)?
16:14:30 <hackrilege> monads nested like as in Free, who are foldable, can be joined up using foldMap
16:15:18 <hackrilege> and better than join, fold allows to concatinate the outer monad, not just the inner one
16:15:21 <hackrilege> :t fold
16:15:23 <lambdabot> (Foldable t, Monoid m) => t m -> m
16:15:35 <hackrilege> :t join
16:15:36 <lambdabot> Monad m => m (m a) -> m a
16:16:08 <hackrilege> how is this not a good idea?
16:16:50 <hackrilege> it feels like im missing something important...
16:16:58 <hackrilege> can you see where im coming from?
16:19:36 <hackrilege> what is quixotic about it!?
16:20:01 <`Guest00000> i recompile my program with -fllvm and it segfaults, what do i do?
16:20:12 <`Guest00000> default backend - runs fine
16:20:57 <hackrilege> nshepper1 ^^^
16:22:30 <nshepper1> hackrilege: we explained this, fold has no laws
16:23:23 <hackrilege> so i just do away with the Foldable instance, and just put the implementation of fold manually into join?
16:23:49 <hackrilege> it can still satisfy monad laws even if it does not need too...
16:24:13 <hackrilege> some folds lead to lawful joins
16:24:30 <hackrilege> its my job to ensure so.
16:24:42 <hackrilege> how is it a problem?
16:25:15 <nshepper1> never mind
16:25:24 <hackrilege> what am i missing?
16:25:59 <hackrilege> i do mind because if i have some flaw which is going to trip me up id like to understand it now
16:26:25 <nshepper1> sure, you can write a monad instance in a foldy way
16:26:55 <hackrilege> id rather write a foldable instance and use it to write bind
16:27:05 <exio4> `Guest00000: do you have a small test case?
16:27:33 <hackrilege> is that ok?
16:27:58 <hackrilege> with this Monoid instance hack you gave me...
16:28:15 <hackrilege> it all seems so convoluted i dont know what im not understanding
16:28:44 <hackrilege> :t foldMap
16:28:46 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:29:29 <hackrilege> its not  clear?
16:29:53 <Cale> hackrilege: For which type?
16:30:16 <Cale> hackrilege: What type are you trying to write a Monad instance for?
16:30:19 <hackrilege> http://lpaste.net/152376
16:31:27 <hackrilege> something like Free
16:31:41 <Cale> Yeah, it's pretty much Free
16:32:00 <Cale> Your instances are demanding much more than they need to though
16:32:04 <`Guest00000> exio4: a case which uses sdl2. it is a binding package which has a function which returns a pointer which i use to access raw memory
16:32:10 <Cale> MonadPlus where Functor would do, for instance.
16:32:19 <hackrilege> yeah, i can lower those constraints later
16:32:34 <hackrilege> sorry i was in a rush
16:32:36 <dmj> anyone know why data X = X is promotable, but not data X = X Int
16:32:43 <`Guest00000> is just any raw memory access not allowed under llvm? or is it
16:34:10 <monochrom> dmj: does the GHC user's guide say something about this?
16:34:35 <hackrilege> Cale, is the discussion about fold and join make sense enough for you to understand what im trying to do?
16:35:04 <Cale> hackrilege: I didn't read the whole thing... but I'm not sure fold is going to be of any help at all in defining join
16:35:21 <Cale> Whereas join is pretty easy to define recursively in terms of fmap
16:36:07 <hackrilege> how is join and fold not the same action but one level of nesting further in
16:36:09 <hackrilege> ?
16:36:14 <Cale> hm?
16:36:34 <hackrilege> if i fold the iner foldable monadplus, it is join
16:37:06 <hackrilege> fmap foldMap, that kind of thing
16:37:13 <Cale> Your Foldable instance uses some additional Foldable structure on m which you ought not to need in defining your Monad instance.
16:37:17 <monochrom> @type fmap foldMap
16:37:18 <lambdabot> (Functor f, Foldable t, Monoid m) => f (a -> m) -> f (t a -> m)
16:37:25 <Cale> At least, the obvious Monad instance.
16:37:38 <Cale> If there's another one, it's not clear to me what it is.
16:38:15 <hackrilege> fold is natural enough, hmm maybe i mean concat written in terms of fold
16:38:23 <hackrilege> using mappend
16:40:31 <hackrilege> how is bind like foldMap?
16:41:36 <hackrilege> i think thats basically the point
16:42:07 <hackrilege> any ideas?
16:43:48 <hackrilege> ok thanks anyhow
16:43:54 <hackrilege> see you next time
16:44:37 <geekosaur> still working on their visualization of the Cosmic All, I see...
16:47:40 <`Guest00000> so. raw memory access itself works when using llvm
16:48:02 <exio4> `Guest00000: code should work with any backend
16:48:12 <dmj> monochrom: "We do not promote data constructors that are kind polymorphic, involve constraints, mention type or data families, or involve types that are not promotable."
16:48:25 <`Guest00000> i guess so...
16:48:43 <`Guest00000> was trying to isolate the problem.
16:53:32 <dmj> monochrom: guess the domain of values is infinte so it wouldn't make sense when promoting... probably Symbol is for
16:53:41 <dmj> probably what*
16:56:13 <`Guest00000> so. my program segfaults only when i try to poke larger strings into memory
16:57:36 <`Guest00000> 6400 bytes is fine; 32000 bytes crashes if llvm.
16:59:06 <exio4> `Guest00000: if you have a minimal/small test case, you should report a bug!
17:00:15 <kadoban> What is "poking strings into memory"?
17:04:30 <c_wraith> kadoban: it usually means writing directly to a pointer.  (Not a very haskelly thing to do)
17:04:54 <geekosaur> ...except when working with the FFI...
17:05:11 <c_wraith> one might argue the FFI isn't very haskelly, either.  But for good reasons!
17:11:30 <hodapp> one of these days I'll have to tackle the Haskell FFI probably...
17:12:09 <Adeon> I use the FFI all the time in my work
17:12:49 <hodapp> at my old work all my Haskell was by way of Ivory and so "FFI" meant nothing because I wasn't using GHC's runtime at... errr... runtime
17:16:35 <lpaste> “`Guest00000” pasted “llvm-test.hs” at http://lpaste.net/152377
17:17:15 <hppavilion[1]> hp
17:17:18 <hppavilion[1]> Whoops
17:17:21 <hppavilion[1]> Meant to ctrl+f that
17:17:32 <`Guest00000> so.
17:17:59 <hppavilion[1]> Huh, that's weird, this channel's logs meshed with #python in the logs
17:18:17 <`Guest00000> exio4: ^ i have pasted a test case. is it all right?
17:19:22 <romanandreg> quick question, is there a way to use the deep lens on an itraversalOf?
17:19:25 <exio4> `Guest00000: I don't really know, maybe asking in #ghc and/or reporting a bug might help
17:19:44 <shachaf> romanandreg: What would that mean?
17:20:38 <romanandreg> I'm manipulating JSON via aeson-lens, and I have a traversal that goes through all leafs that are Aeson String values
17:20:52 <romanandreg> however, in the traversal function, I would like to get the Text of the property
17:20:57 <romanandreg> the original code does something like this
17:21:04 <romanandreg> is something like this:
17:22:06 <romanandreg> traverseOf (deep Aeson.String)
17:22:07 <romanandreg>                (\stringVal ->
17:22:08 <romanandreg>                   error "something here")
17:22:09 <romanandreg>                 jsonObj
17:22:12 <romanandreg> that seems to work as expected
17:22:34 <romanandreg> however, when I try to use itraverseOf instead of traverseOf, I get a compilation error that of course, I can't grok
17:23:38 <shachaf> Oh, this is a Plated thing.
17:23:44 <shachaf> I was thinking of uponTheDeep.
17:24:10 * hackagebot jsaddle 0.3.0.0 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.3.0.0 (HamishMackenzie)
17:24:24 <shachaf> romanandreg: You should consider using lens-aeson instead of aeson-lens.
17:24:51 <shachaf> What's (deep Aeson.String)?
17:25:10 <romanandreg> shachaf: my mistake, I'm actually using lens-aeson
17:25:42 <romanandreg> (deep Aeson.String) uses the String Prism and gets to the leafs of the JSON Tree, it is simply dark magic
17:25:54 <romanandreg> I'm guessing that doesn't work with indexed traversals
17:25:57 <romanandreg> :-(
17:26:03 <shachaf> Oh, _String?
17:29:10 * hackagebot uniform-pair 0.1.10 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.10 (ConalElliott)
17:29:45 <romanandreg> shachaf: right
17:30:04 <shachaf> OK. What are you expecting the index to be?
17:32:54 <romanandreg> I think I got 
17:32:55 <romanandreg> it
17:33:02 <romanandreg> I need to compose members with _String
17:33:04 <romanandreg> and that does it
17:33:06 <romanandreg> like magic
17:50:13 <nitrix> Is there an easy way to do multiple inserts on a map?
17:51:06 <shachaf> union?
17:51:07 <nitrix> Some sort of :: Map k v -> [(k,v)] -> Map k v
17:51:43 <byorgey> @type M.union . M.fromList
17:51:45 <lambdabot> Ord k => [(k, a)] -> M.Map k a -> M.Map k a
17:51:53 <shachaf> > M.fromList [('a', 1), ('b', 2)] `M.union` M.fromList [('b', 3), ('c', 4)]
17:51:55 <nitrix> Does union overrites?
17:51:55 <lambdabot>  fromList [('a',1),('b',2),('c',4)]
17:52:14 <byorgey> yes, union is left-biased
17:52:34 <byorgey> there is also 'unionWith' if you want more control over how the merging happens
17:52:51 <nitrix> A `union` B, the A has priority?
17:52:56 <byorgey> right
17:53:15 <nitrix> I see, so I can just flip the ordering of the operands to get the desired behaviors then.
17:53:26 <shachaf> Or flip your desire.
17:53:32 <nitrix> o:
17:53:42 <nitrix> byorgey: shachaf Thanks.
17:55:20 <luvenfu> hello, there's a good book to learn haskell or site?
17:55:38 <shachaf> luvenfu: I like Hutton's _Programming in Haskell_.
17:56:22 <pavonia> Could someone please explain this error to me? http://lpaste.net/revision/152380  I understood it in another context, but in this particular example I'm not sure why it happens
17:56:54 <kadoban> luvenfu: http://haskellbook.com/ is popular and seems good, https://github.com/bitemyapp/learnhaskell#how-should-i-learn-haskell is acceptable if it must be free
17:57:48 <luvenfu> shachaf: ok, i will check it out, thanks
17:58:05 <luvenfu> kadoban: amazing
18:25:11 <lingxiao> hey all
18:25:17 <lingxiao> anyone wnat to help me over at #coq?
18:32:24 <pavonia> Is there a way to fix http://lpaste.net/revision/152380 without adding another type that wraps ParameterDefinition?
18:33:50 <shachaf> What type do you expect the whole thing to have?
18:34:06 <pavonia> Maybe Int
18:34:40 <shachaf> No, impossible. The whole point of ParameterDefinition is that it's hiding the type.
18:36:09 <shachaf> It's possible that an existential isn't the right way to accomplish whatever you're trying to accomplish.
18:37:23 <pavonia> I'm trying to just store the type of the parameter definition such that it can be used later to parse a value to this type
18:37:45 <pavonia> the type of the parameter value, that is
18:38:55 <shachaf> That's not how existentials work.
18:39:40 <shachaf> Types are opaque. An existeitnal "stores" the type, but not in a way that lets you do anything with it other than what the existential explicitly lets you do.
18:41:01 <geekosaur> I wouln't even say it stores the type; it hides the type even more completely than usual (even from the typechecker) except for whatever context it exposes --- which becomes the statement of the only thing you can do with values
18:42:41 <pavonia> Hhm, I've never really understood existentials. What would be a use-case where such a "hidden" value or type would make sense?
18:43:06 <shachaf> This is dual to forall.
18:43:25 <shachaf> foo :: forall a. (a -> a) -> a -> a; foo f z = f (f (f z))
18:43:51 <shachaf> Here the type a is opaque to foo. The only thing it can do with a value of type a is pass it to f.
18:44:13 <shachaf> Well, maybe that's a bad example, let's take a simpler one.
18:44:26 <shachaf> foo :: a -> (a -> String) -> String; foo x f = f x
18:44:41 <shachaf> The type a is opaque to foo. The only thing it can do with a value of type a is pass it to f.
18:44:58 <shachaf> foo :: (exists a. (a, a -> String)) -> String; foo (x, f) = f x
18:45:21 <shachaf> The same thing is going on here.
18:46:52 <pavonia> Except for the type is hidden to foo
18:47:37 <shachaf> It's hidden to foo in both cases.
18:48:56 <pavonia> What would be a case where it's not hidden?
18:49:53 <shachaf> There's no such case.
18:52:49 <pavonia> I'm not quite sure I understand the diference, to me it's just a different position the forall occurs
18:53:41 <pavonia> And as it's used in a value constructor that makes it even more confusing
18:56:06 <EvanR> pavonia: you mean data Foo = forall a . Foo a ?
18:57:25 <EvanR> the different between this and normal data is Foo's type ctor has no a
18:57:34 <EvanR> so its not just the forall
18:58:04 <pavonia> Yeah
18:58:11 <EvanR> and that notation is confusing to me, its better with GADT syntax
18:58:24 <EvanR> data Foo where
18:58:44 <EvanR>   MkFoo :: forall a . a -> Foo
18:59:30 <EvanR> [MkFoo 3, MkFoo 'z', MkFoo True]
19:00:49 <pavonia> So if I wanted to use this value in any way, I'd have to wrap the functions in this constructor too, right?
19:01:05 <EvanR> youd need to include the operations yes
19:01:34 <pavonia> Okay, this makes sense
19:02:00 <EvanR> you can still use the value, but only with functions that work on any type
19:03:08 <EvanR> like f x y b = if b then x else y
19:03:08 <pavonia> I guess this is why it complains that the type is "less polymorphic than expected"
19:04:26 <EvanR> i would expect the error to be "can't match type a0 with a1" or a0 with Int, etc
19:05:57 <pavonia> That's the error when you add an explicit type annotation for the result value
19:29:36 <lpaste> “`Guest00000” revised “llvm-test.hs”: “No title” at http://lpaste.net/152377
19:50:22 <synergistics> Is there a way to run a case statement matching on specific functions
19:50:27 <synergistics> To avoid behavior like
19:50:27 <benzrf> synergistics: no
19:50:30 <synergistics> Oh
19:50:40 <benzrf> wait, maybe i misunderstood what you meant
19:50:44 <benzrf> explain what you're looking for?
19:50:56 <synergistics> > case (+) of (-) -> 1
19:50:57 <lambdabot>  1
19:50:59 <benzrf> no
19:51:05 <synergistics> Ok, thanks
19:51:07 <benzrf> what would it even mean?
19:51:26 <synergistics> Well let's say I want to match on (+), but it's stored as a variable
19:51:32 <EvanR> there are view patterns, though that might not be what youre looking for
19:51:34 <benzrf> what does it mean to match on (+)
19:51:35 <scshunt> you can't match on functions because equality is ill-defined
19:51:51 <synergistics> scshunt: Ok, yea
19:52:11 <benzrf> synergistics: how should i test whether (\x -> x + 1) matches (\x -> if foo then x + 1 else x)
19:52:13 <scshunt> e.g. are \x -> f x and f the same functions?
19:52:28 <EvanR> equality computation is not defined, but you can well define an equivalence of functions (such as extensional equality)
19:52:48 <benzrf> EvanR: yeah, but we care about computing here
19:53:03 <EvanR> just saying theres no ill-definedness going on
19:53:37 <EvanR> you cant match on functions because they dont have constructors
19:54:35 <synergistics> Why is that?
19:54:50 <geekosaur> they're just pointers to code
19:54:55 <benzrf> there's no reason why they /should/
19:55:03 <benzrf> "why is that" is the wrong question
19:55:23 <EvanR> you werent there to design haskell to have functions made of constructors ;)
19:55:53 <scshunt> EvanR: true, your answer is more exacting, but it's less explicitly helpful ;)
19:56:23 <nocturne777> EvanR: in the case of ReaderT and async, is exception handling also more difficult? I did not understand that part from the previous discussion 
19:56:47 <EvanR> i dont think readerT will interfere with IO exceptions much
20:12:35 <scshunt> what I don't understand is the proliferation of error-handling monads
20:12:43 <scshunt> MonadThrow, MonadError, etc.
20:12:43 <EvanR> me neither
20:18:16 <Cale> scshunt: Yeah, it's like "yes, this is a possible thing which can be done", but given how rarely you'd actually want one of those things, there ought not to be so many of them.
20:25:50 <SirSkidmore> I'm trying to rewrite this "decompress" function https://gist.github.com/SirSkidmore/7cee8a2a1c1d5df5aac0#file-hw5-hs-L94-L102 using the State monad, keeping the [Bit] in state, but I'm having trouble transitioning the naturally recursive parts of the function into the monadic block
20:25:57 <SirSkidmore> any suggestions?
20:26:45 <EvanR> you may be able to simply use recursive do notation
20:28:18 <EvanR> or you might not have to
20:30:03 <EvanR> honestly the way you have it makes sense
20:30:43 <SirSkidmore> the way I have it here? https://gist.github.com/SirSkidmore/7cee8a2a1c1d5df5aac0#file-hw5-1-hs
20:30:56 <SirSkidmore> Or the way I have it without the State monad in the first place?
20:31:01 <EvanR> without state
20:31:54 <SirSkidmore> it's not a matter of what makes sense, but rather, what I've been asked to do, heh
20:32:03 <EvanR> oh
20:35:40 <nitrix> Is it a known bug that GHC looses precision in the inference as `let` bindings are added?
20:36:15 <c_wraith> nitrix: it's not a bug, it's called "let generalization"
20:36:20 <nitrix> I had a typed hole, the type is well known. Then I added a let statement with _, then substitued my original hole with the name of that let statement
20:36:24 <c_wraith> nitrix: it's a key part of hindley-milner
20:36:25 <nitrix> Then it became generic.
20:36:29 <nitrix> c_wraith: oh?
20:36:44 <nitrix> c_wraith: Please reassure me, it's only let statements, right?
20:36:59 <c_wraith> nitrix: yes.  You can also enable MonoLocalBinds if you want to turn it off.
20:37:18 <nitrix> I see. I might do that. I had a very annoying bug hard to locate.
20:37:40 <nitrix> So... well, what's the rationale behind it? I'm curious now that it's fixed.
20:38:07 <c_wraith> I'm not sure.  I'm just going by what I've heard.  I should actually learn Hindley-Milner sometime.
20:38:30 <nitrix> c_wraith: It's still incredibly useful. I appreciate and will lookup on my own as well then.
20:38:33 <nitrix> Thanks (:
20:42:14 <nitrix> Oh! I see how it works.
20:42:55 <nitrix> That is actually really neat -- but obscure when you've never worked with ML languages.
20:46:55 <kadoban> I don't think I've come across that or noticed it or whatever. Did you find something concise that explains it well?
20:48:48 <EvanR> its so that you can do this
20:49:14 <nitrix> More or less, I'm reading exchanges about GHC 7.0 (when they reworked the type inference system).
20:49:20 <EvanR> f :: Char -> Bool -> (Char, Bool)
20:49:35 <EvanR> f x y = let id z = z in (id x, id y)
20:49:58 <EvanR> id is used at two types, but wouldnt be possible if id's type was fixed by type inference
20:50:14 <nitrix> Yep, exactly :)
20:50:26 <kadoban> Oh. That seems to be something that I must have just assumed it was the only way it could work or something.
20:50:51 <kadoban> Isn't that just a ... I mean that's how other definitions work too, right? Is there something special about it applying to let?
20:50:57 <nitrix> kadoban: Same here, I'm using it to render tiles in my game for convenience (it made the code simpler0
20:51:26 <nitrix> But then I'm pulling the thing away inside its own module and got confused with the lenses and stuff, so I added typed holes and all I got was `t0`'s....
20:51:33 <nitrix> I was like.. what the heck is a t0 :P
20:51:57 <EvanR> kadoban: well, it could determine that id : Char -> Char and then say "FU"... its a possible strategy ;)
20:52:15 <kadoban> Heh, yeah I guess.
20:52:31 <nitrix> Not gonna lie, I think it's cool.
20:52:41 <nitrix> I'm just abusing let statements too much.
20:53:01 <nitrix> (hence the refactor)
20:53:03 <Gentilhomme> do people actually use haskell for software projects? and doesnt haskell syntax have a lot of redundant features?
20:53:27 <nitrix> Gentilhomme: Redundant is complicated to explain with Haskell.
20:53:58 <c_wraith> Yes.  I wish haskell didn't have if/then/else. :)
20:54:00 <kadoban> Gentilhomme: Sure. Redundant features like what?
20:54:04 <c_wraith> Unnecessary feature!
20:54:07 <nitrix> Gentilhomme: There's many ways to achieve the same results, just because the concepts are broken into their most granular form to let you compose them the way that's the most intuitive for you.
20:56:24 <Gentilhomme> yes, that's what I'm talking about. Writing some operation on a list could be expressed with a dozen ways (map, fold, pattern matching, a custom recursive function, etc)
20:56:37 <Gentilhomme> I feel a bit overwhelmed with all the possibilities
20:57:22 <kadoban> Gentilhomme: It's true in most languages that there's several ways to do things, it hasn't seemed particularly true in haskell to me.
20:57:48 <EvanR> error handling ;)
20:58:04 <kadoban> Gentilhomme: If that's all that's bugging you ... just pick one. If it sucks, you'll figure out why probably. You get intuition for what's the way that works best for you, or in what circumstances.
20:58:43 <Gentilhomme> maybe I don't have enough experience (im still learning the syntax and have a bit of an Fsharp background) but each time I want to write something I constantly try to think about the most elegant/shortest way to write it instead of actually writing code
20:59:05 <Gentilhomme> where as the most choice I get in C is "while vs for"
20:59:27 <EvanR> whats interesting about haskell is that when you have that feeling... there usually is a nicer more elegant way to say it
20:59:34 <nitrix> Gentilhomme: My best advice is that; as you learn Haskell and grow, you'll develop a sense for what works and what doesn't, and you'll be able to refactor the pieces that you aren't happy with very easily.
20:59:39 <kadoban> Well, haskell is quite a bit more expressive than C. Eventually that'll be an asset to you thankfully.
20:59:56 <Myrl-saki> Guys.
21:00:03 <nitrix> Myrl-saki: Hi
21:00:04 <Myrl-saki> type T a = (a,a)
21:00:10 <Myrl-saki> I forgot what T was called.
21:00:40 <nitrix> Myrl-saki: A type alias?
21:00:45 <Myrl-saki> Naw.
21:00:49 <Myrl-saki> There's a certain type that does that.
21:01:01 <EvanR> Pair ?
21:01:16 <Myrl-saki> I don't see any "Pair" in Hoogle.
21:01:26 <nitrix> Oh you want the name of the type.
21:01:27 <kadoban> tuple?
21:01:32 <Myrl-saki> Yes. The name of the type.
21:01:37 <nitrix> It's a Pair afaik
21:01:46 <Myrl-saki> How about a generalyzed version of that?
21:01:48 <Myrl-saki> generalized*
21:02:13 <Myrl-saki> @i Pair
21:02:13 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
21:02:23 <Myrl-saki> @src Pair
21:02:23 <lambdabot> Source not found. Maybe you made a typo?
21:02:45 <nitrix> ype PairTy f = forall a b. f a -> f b -> f (a, b)
21:02:52 <nitrix> https://hackage.haskell.org/package/TypeCompose-0.9.11/docs/Data-Pair.html#t:Pair
21:03:00 <nitrix> I think that'd be a generic version?
21:03:27 <kadoban> I think they just want the name, which if it's not tuple, I'm not sure what they're looking for.
21:03:47 <Myrl-saki> There's a certain type synonym that does that.
21:03:54 <Myrl-saki> I was thinking Vec2.
21:04:00 <Myrl-saki> But it doesn't seem to be it.
21:04:10 <nitrix> Oh, there's linear affine types.
21:04:25 <nitrix> Myrl-saki: https://hackage.haskell.org/package/linear-1.20.4/docs/Linear-V2.html
21:04:41 <Myrl-saki> It was discussed in ##programming a few months ago.
21:04:46 <nitrix> V2 0 0 :: V2 Int
21:04:59 <nitrix> data V2 a = V2 !a !a
21:05:04 <Myrl-saki> s/discussed/mentioned
21:06:43 <nitrix> Myrl-saki: Am I getting warmer, colder?
21:07:25 <kadoban> There's hlist, which is pretty much generalized tuples I thought, maybe.
21:07:34 <kadoban> But it's far more than a type alias IIUC.
21:07:49 <nitrix> The operators for linear vectors are also very nice (^+^) (^-^)
21:08:41 <Myrl-saki> nitrix: I think that's it.
21:09:02 <nitrix> Myrl-saki: It's what I'm personally using in my game for coordinates.
21:09:22 <nitrix> The only problem that I had with it is that I wished it also had a Bifunctor instance.
21:10:46 <nitrix> To like, multiply both values by 32, but I just did a V2 32 32 and you can multiply the vectors because they are Num instances.
21:10:52 <nitrix> Worked great (:
21:16:09 <EvanR> is there such a thing as a coproduct category
21:16:23 <EvanR> analogous to the cartesian product of two categories
21:21:42 <bros>  Couldn't match expected type ‘Data.Text.Internal.Text’  with actual type ‘[Char]’
21:21:52 <bros> putStrLn (r ^? responseBody . key "total_count")
21:22:52 <c_wraith> bros: key takes Text, not a String.  You've seen examples pass it String values because they're using the OverloadedStrings extension
21:23:04 <bros> I'm using it too up top
21:23:06 <bros> Is it not working?
21:23:24 <c_wraith> With that error message, something isn't working right.
21:23:36 <bros> ah, it needs to be before any imports
21:24:02 <bros> Couldn't match type ‘Maybe Value’ with ‘[Char]’ Expected type: String
21:24:14 <ahihi> Gentilhomme: if the function you want to write matches a common "shape" of recursion, like a map or a fold, it makes sense to express it in terms of that. but in order to develop an intuition for this, it may be helpful to prefer explicit recursion at first
21:25:11 <EvanR> hehe develop intuition... 
21:26:33 <EvanR> that proper form of intuitive "easy to understand" rather than "easy to understand without any training or practice"
21:26:40 <nitrix> Is there such thing as eta reduced pattern matching?
21:27:05 <nitrix> KeyboardEvent ked -> handleKeyboardEvent ked
21:27:10 <nitrix> KeyboardEvent -> handleKeyboardEvent
21:28:25 <nitrix> Granted you probably loose a lot on readability.
21:29:25 * hackagebot directory 1.2.5.1 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.5.1 (Rufflewind)
21:29:30 <EvanR> this syntax means... if you match an incomplete constructor... apply the function to the argument
21:29:45 <EvanR> sort of not what eta reduce usually means
21:30:13 <bros> c_wraith: Is it asking for Maybe Value -> [Char] ?
21:37:23 <nitrix> Do you guys align your arrows, comments and patterns?
21:38:06 <nitrix> Having written a few thousands lines this week, I cannot resist the urge anyore and want to make it all pretty. 
21:38:35 <kadoban> I try not to align anything in such a way that changing code later will require changing a bunch of alignments. It makes a mess of version control/diff views.
21:38:41 <kadoban> Plus it's just annoying to do.
21:41:09 <ahihi> if my cases get long enough to make arrow alignment actually useful, I tend to put the RHS on new, indented lines instead
21:57:06 <nitrix> http://lpaste.net/152432
21:57:12 <nitrix> Thoughts on readability?
22:04:23 <Ralith> what do people like for haskell webapps these days?
22:07:46 <kadoban> nitrix: Looks pretty good to me. The whole True/False thing in the keyboard events I ... don't really like for a couple of reasons, and I'm not really sure why underscores for the record accessors?
22:08:40 <kadoban> The True/False things: I'm not a fan of True/False for things that it's hard to tell which one is which, or what they do. I'd probably call them something else (make my own sum type). Also it seems annoying that everything has to specify when really only one of them actually has anything to do with quitting.
22:14:26 * hackagebot pipes-parse 3.0.4 - Parsing infrastructure for the pipes ecosystem  https://hackage.haskell.org/package/pipes-parse-3.0.4 (GabrielGonzalez)
22:15:03 <nitrix> kadoban: Nice catch..
22:15:26 <nitrix> kadoban: let (halt, newGameState) = runState (gameHandleEvent event) gameState
22:15:43 <nitrix> kadoban: That's what happens. Maybe I should document it, you're right.
22:16:55 <nitrix> It's to break out of the main loop and terminate the game (which I suspect will be triggered by a mouse event / keyboard event)
22:17:40 <nitrix> Although, recently, I was thinking to move it to the GameState record, and modify that when necessary, then have the main loop check the `halt` flag in the gamestate instead.
22:18:09 <kadoban> Yeah, it'd just be nice if it had to be explicitly done when you get an action that has to quit, and the other ones don't have to do something specifically about it. Adding a flag "timeToQuit" to the game state comes to mind I guess, not sure if that's ideal or not.
22:18:18 <kadoban> Haha, yeah.
22:18:21 <nitrix> Would be a lot more readable, but then I end up with a   :: State GameState () and it feels like a waste.
22:18:24 <EvanR> classic
22:18:37 <EvanR> while(!gameEnded){
22:19:00 <nitrix> EvanR: I'm comming from a precedural background, so yeah, it's hard to break the mold.
22:19:05 <nitrix> I'm really am trying though.
22:19:08 <EvanR> bool windowShouldClose();
22:19:38 <EvanR> well, i still havent found a better way. I mean for a concurrent program your main thread can take an mvar which something will put when ready to end
22:19:46 <EvanR> however, opengl has to be done from the main thread 
22:20:21 <EvanR> but if data needed for opengl is coming from another thread, through an MVar or something, you can use a sum type there to indicate "close program"
22:20:27 <nitrix> I'm using sdl2 without opengl at the moment. It's probable it'll change.
22:50:27 <Shockk> okay I have a weird <<loop>> problem when running my code, and I've tracked it down with ghci but I can't figure out *why* it's happening,
22:50:35 <Shockk> https://github.com/shockkolate/hs-uci/blob/master/src/Data/UCI.hs#L43
22:50:56 <Shockk> I'm loading this with `cabal repl` and then I'm evaluating the following expression:
22:51:12 <Shockk> show (Info "test") :: [String]
22:51:31 <Shockk> I get the output [" and then it presumably enters an infinite loop
22:52:24 <Shockk> the same happens if I try and show ID or OK or ReadyOK, etc
23:15:26 <shachaf> Is there a nice way to group a list into increasing runs?
23:20:13 <shachaf> > let f [] = []; f (x:xs) = add x (f xs) where add y ((a:as):yss) | y <= a = (y:a:as):yss; add y yss = [y] : yss in f "abcbcdcdeefa"
23:20:15 <lambdabot>  ["abc","bcd","cdeef","a"]
23:24:31 * hackagebot dynamic-state 0.2.1.0 - Optionally serializable dynamic state keyed by type  https://hackage.haskell.org/package/dynamic-state-0.2.1.0 (DmitryIvanov)
23:37:28 <EvanR> hmm. is AllowAmbiguousTypes bad
23:45:36 <nocturne777> Cale: could you elaborate on the example you gave earlier => "data DBOps m = ...; foo :: Monad m => DBOps m -> m ()"
23:49:48 <Cale> nocturne777: Sure...
23:50:38 <nocturne777> I wonder if you meant something like this: data DBOps a = forall m. (Monad m) => DBOps {dbOp :: DbClient a -> m a }
23:51:05 <Cale> nocturne777: No, when I wrote the m there it was very intentionally an m
23:52:53 <Cale> I mean that you'd have something like  data DBOps m = DBOps { insertBar :: Bar -> m (Id Bar); ... other basic operations relevant to the application ... } -- note that it needn't be the case that you have this Id Bar thing, just whatever makes sense for the DB library you're using
23:53:15 <Cale> But the idea is that you're going to choose m = IO
23:53:54 <Cale> But this gives you the option of writing some operations that use the database primitives you provide, but don't know that they're really in IO
23:54:19 <Cale> (and so can't, for example, do unrestricted filesystem access)
23:55:12 <Cale> Does that make some sense?
23:56:41 <Cale> So in the end, you'll construct a record of type  DBOps IO  and pass that around
23:57:06 <Cale> But some things might have been written polymorphically to take a  DBOps m  and produce an m-action.
23:57:24 <Cale> In which case, they'll only be able to use the operations inside that record they're given.
23:57:44 <Cale> This may or may not be useful to you, but it's an option.
