00:00:16 <clinton_> is there an option I need to provide other than "documentation: true" in ".caba/config" so that "cabal haddock" makes hyperlinks between packages instead of giving the error: "could not find link destinations for"?
00:07:38 <scshunt> I think I will just make explicit the types
00:07:40 * hackagebot cab 0.2.16 - A maintenance command of Haskell cabal packages  https://hackage.haskell.org/package/cab-0.2.16 (KazuYamamoto)
00:07:40 * hackagebot aeson-extra 0.3.1.1 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.3.1.1 (phadej)
00:08:58 <EvanR> parental advisory
00:13:31 <scshunt> what on earth
00:14:24 <scshunt> why am I getting a warning that a name I never use isn't exported?
00:15:05 <shachaf> Presumably because you're never using it and not exporting it.
00:22:48 <sphinxo> Given a data A = B Int
00:23:03 <sphinxo> And I have a list of Bs, how can I convert that into a list of ints?
00:23:18 <EvanR> map?
00:23:25 <sphinxo> the ways I can think of are pattern matcing and case, any other ways I could use?
00:23:36 <sphinxo> Oh wait
00:23:40 <sphinxo> would that work?
00:23:56 <EvanR> map converts lists to lists
00:24:06 <shachaf> map (\(B x) -> x)
00:24:17 <shachaf> Pattern matching is the only way to do that.
00:25:06 <ahihi> alternatively, if you define A using record syntax, you get an extractor function for free
00:25:21 <sphinxo> hmm
00:30:39 <scshunt> > Traversal' a b
00:30:41 <lambdabot>      Not in scope: data constructor ‘Traversal'’
00:30:42 <lambdabot>      Perhaps you meant ‘Traversal’ (imported from Control.Lens)
00:53:40 <schoppenhauer1> hi. is it possible, with haskell, to check for absolute equality? that is, check whether two variables refer to the exact same object?
00:54:06 <schoppenhauer1> (I would have expected this to be an optimization of ==)
00:54:54 <ahihi> haskell has no concept of object identity
00:55:03 <merijn> It does, it's just horrifically unsafe :p
00:55:33 <merijn> Or rather, you're right that haskell (the abstract language) doesn't specify identity in the standard
00:55:59 <merijn> But GHC does have it, but like "unsafeCoerce" it is "blow your hands off"-dangerous\
00:56:07 <schoppenhauer1> merijn: what's unsafe about it?
00:56:17 <schoppenhauer1> merijn: at least as an optimization for list comparison
00:57:05 <merijn> schoppenhauer1: GHC is free to duplicate and move objects in memory
00:57:06 <schoppenhauer1> as haskell is side-effect-free, it is enough that two list variables point to the same direction
00:57:24 <schoppenhauer1> merijn: ok.
00:57:28 <merijn> schoppenhauer1: Which means that, i.e. storing the identity is unsafe because it's subject to change
00:57:37 <quchen> I'm not sure GHC even knows about equality of things, it's implemented in ordinary modules after all
00:58:11 <quchen> merijn: Sure, but if a=b then *a=*b, and GHC could make use of that regardless of GC and so on.
00:58:16 <merijn> schoppenhauer1: And sometimes the inliner might, e.g. duplicate an expression so that was looks like one list in code might end up being compiled and running asif it was two lists
00:58:28 <schoppenhauer1> ok. 
00:58:35 <schoppenhauer1> then I'll have  to find another  solution
00:58:53 <merijn> quchen: Sure, a=b implies *a=*b, but not all code that looks like a=b actually HAS a=b
00:58:58 <merijn> schoppenhauer1: What's the actual problem? :)
00:59:22 <schoppenhauer1> merijn: very hard to explain.
00:59:43 <scshunt> EvanR: as I look at my lenses, I think partial fields were the way to go
01:00:03 <schoppenhauer1> especially as it's not a haskell problem.
01:00:10 <quchen> merijn: Hence it's only an optimization. GHC might, when seeing "a == b", check whether they both point to the same memory location, and skip the actual "==" implementation based on that.
01:00:32 <quchen> There are good reasons not to do this, of course, such as "Eq doesn't even have laws"
01:00:51 <merijn> quchen: An even better one would be "that's a conditional jump in your asm and those suck"
01:00:57 <scshunt> EvanR: not doing partial fields is just making me write all these Traversals that I'm going to want anyway myself
01:01:44 <Ainieco> hello
01:01:45 <merijn> schoppenhauer1: It's hard to give a good recommendation without more info. Anyway, ghc has "reallyUnsafePtrEquality#" but the name should really be rather indicative of how wise it is to use :p
01:02:06 <scshunt> but I've gone far enough that I am just going to keep using it, and if it turns out that I was right, I'll switch it back later
01:02:16 <schoppenhauer1> merijn: yes. that's not a satisfactory solution. well, the problem has to do with coq program extraction...
01:02:25 <schoppenhauer1> and memoized induction
01:02:33 <schoppenhauer1> do I have to say more? :3
01:03:12 <schoppenhauer1> it is very intricate. but if that pointer equality does not work, then ... it doesn't work.
01:03:16 <scshunt> if I use the lenses I can change their definitions later and I don't expect to be using the fields directly
01:03:21 <scshunt> at least, not too much
01:04:02 <merijn> schoppenhauer1: Well, as quchen points out, it's fine in the sense that "a == b" will clearly imply "a == b"
01:04:15 <merijn> schoppenhauer1: eh "*a == *b"
01:04:31 <schoppenhauer1> ok, so maybe it's worth a shot
01:04:37 <merijn> schoppenhauer1: So afaik it doesn't produce false positives, just false negatives
01:04:52 <schoppenhauer1> merijn: I think the problem boils down to having a hashtable that is indexed by *many* lists
01:04:53 <merijn> schoppenhauer1: But I'd consult the mailing list/#ghc for details on GHC.Prim
01:05:16 <Liskni_si> schoppenhauer1: This may be a good read, too: http://stackoverflow.com/questions/9649500/what-advantages-do-stablenames-have-over-reallyunsafeptrequality-and-vice-vers
01:05:55 <merijn> Oh, yeah
01:05:57 <merijn> I forgot
01:06:09 <merijn> If you're ok with using IO StablePtr might be valuable
01:06:32 <Liskni_si> note that StablePtr ≠ StableName :-)
01:06:47 <ggole> But a == b doesn't imply *a == *b in general because of floating point
01:07:46 <schoppenhauer1> omg... it can give false positives.
01:07:51 <schoppenhauer1> => not useful for me.
01:08:21 <schoppenhauer1> thank you!
01:10:32 <quchen> ggole: ..?
01:11:12 <quchen> Oh, if *a and *b are both NaN
01:13:22 <quchen> merijn: What's the "if" equivalent for primops?
01:17:19 <merijn> quchen: I think just case on Int#?
01:18:02 <merijn> case myComparison of 0# -> {- if branch -}; _ -> {- else branch -}
01:18:13 <quchen> Oh, right, that makes sense.
01:19:34 <merijn> Might wanna scroll through ghc-prim, it's filled with interesting tidbits
01:20:04 <quchen> At least in the beginning
01:20:16 <quchen> The end is mostly homogeneous array mangling
01:20:42 <merijn> For example, I found dataToTag# and tagToEnum# recently which I needed a long time ago and people told me it didn't exist...
01:22:38 * hackagebot yaml 0.8.16 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.16 (MichaelSnoyman)
01:24:15 <quchen> merijn: dataToTag# (x:xs) = 1#; dataToTag# [] = 0#`
01:24:16 <quchen> ?
01:29:13 <Algebr`> HAKYLL seriously looks amazing
01:29:14 <merijn> quchen: Basically
01:45:52 <sphinxo> Any ways I can clean up the evalExpr function? http://lpaste.net/7239618701161398272
01:46:03 <mjrosenb> Is there a function like Data.Map.Update, but it can also insert a new key/value pair into the map?
01:46:18 <sphinxo> Data.Map.Insert?
01:47:12 <sphinxo> Specifically the builtin case 
01:47:38 * hackagebot hills 0.1.2.1 - Generate STL models from SRTM elevation data.  https://hackage.haskell.org/package/hills-0.1.2.1 (djf)
01:48:00 <mjrosenb> sphinxo: is there a reason that you used a separate case, rather than just matching the buildin at the top level?
01:48:33 <sphinxo> Good point
01:48:55 <sphinxo> I guess I thought to seperate it from the other things in the pattern match
01:50:01 <mjrosenb> ok, so I can probably bend insertWith to do what I want, but it will be uglt
01:50:05 <mjrosenb> *ugly
01:50:22 <mjrosenb> less ugly than not using it, so, I guess that is a win.
01:50:50 <MasseR> @type Data.Map.insertWith
01:50:51 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
01:54:37 <mjrosenb> I could also use...
01:54:44 <mjrosenb> @type Data.Map.alter
01:54:45 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
01:55:05 <mjrosenb> but I think the semantics of update more accurately reflect my use case.
01:55:17 <mjrosenb> err, semantics of insertWith
01:57:28 <mjrosenb> namely, the fact that a (k,v) can never be removed from the map by this operations.
01:57:39 * hackagebot QuickPlot 0.1.0.1 - Quick and easy data visualization with Haskell  https://hackage.haskell.org/package/QuickPlot-0.1.0.1 (tepf)
01:59:27 <merijn> mjrosenb: You could wrap alter with a custom convenience function
02:00:03 <merijn> mjrosenb: The problem with the Map API is that there's a gazillion possible operations, so instead of implementing everything they try to just provide the tools to write what you want efficiently
02:01:00 <mjrosenb> merijn: yeah, I guess alter doesn't actually incur any overhead for being able to remove things from the map.
02:01:35 <mjrosenb> I have a convience function written around insertWith for now.
02:01:57 <mjrosenb> insertUpdate f v k m = insertWith (\ o n -> f o) k (f v) m
02:03:50 <quchen> merijn: There are still gazillions of "provided tools" in the Map API :-þ
02:04:29 <merijn> quchen: Sure
02:04:37 <merijn> quchen: But people still suggest more
02:04:57 <quchen> mergeWithKey is the most powerful, all-encapsulating one, no?
02:05:33 <mjrosenb> quchen: likely.  I've used that one in this project already.
02:05:58 <mjrosenb> likely not good for deleting keys?
02:06:22 <mjrosenb> oh, I guess if you can define differenceWith, you can define delete.
02:09:52 <schoppenhauer1> is there a haskell function to copy an array into another one (Mutable IO arrays)
02:09:55 <schoppenhauer1> ?
02:26:22 <mniip> schoppenhauer1, you can make one yourself
02:26:40 <mniip> should be too hard - sequence a list of assignments
02:27:00 <schoppenhauer1> mniip: yes but if there was one I wouldnt have to
02:27:13 <mniip> I doubt there is one
02:27:19 <schoppenhauer1> k
02:40:50 <georgex> is there a function like this? Monad m => [m a] -> m [a]
02:40:57 <merijn> :t sequence
02:40:59 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:41:09 <merijn> :t sequence `asAppliedTo` []
02:41:10 <lambdabot> Monad m => [m a] -> m [a]
02:41:20 <georgex> nice
02:41:24 <merijn> See also:
02:41:26 <merijn> :t mapM
02:41:27 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:41:31 <merijn> and
02:41:43 <merijn> :t mapM_ -- or sequence_ in case you don't care about results
02:41:44 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
02:42:14 <georgex> :t concat <$> sequence undefined
02:42:15 <lambdabot>     Could not deduce (Foldable t0) arising from a use of ‘concat’
02:42:15 <lambdabot>     from the context (Monad f)
02:42:15 <lambdabot>       bound by the inferred type of it :: Monad f => f [a]
02:42:29 <georgex> :t concat <$> sequence (undefined :: [IO String])
02:42:30 <lambdabot> IO [Char]
02:43:23 <agustrong> Rite
02:43:28 * mniip . o O ( Monoid instance for IO? )
02:43:39 <merijn> mniip: There isn't one, but it has been proposed
02:43:55 <merijn> The problem is that all Monads have multiple legal monoid instances
02:43:58 <georgex> if I do this am I guaranteed to get entire parsed string back? I think so but I am not sure.. concat <$> sequence [ <a bunch of Parser String> ]
02:44:30 <georgex> there's probably an easier way to do this too
02:45:02 <merijn> georgex: Sure, that's basically the same as "do { x1 <- parsers1; x2 <- parser2;... ; return (concat [x1,x2,...]) }"
02:47:41 <merijn> mniip: Incidentally, I have defined my own orphan instance of Monoid for IO before
02:49:26 <quicksilver> the (>>) instance?
02:49:35 <merijn> quicksilver: Yeah
02:49:44 <quicksilver> there is anewtype for that somewhere
02:50:16 <merijn> mempty = return mempty; mappend = liftM2 mappend
02:50:40 <quicksilver> oh that's not the one I meant :)
02:51:08 <merijn> What other monoid based around >> could you have?
02:51:22 <quicksilver> the where where mappend = (>>)
02:51:35 <quicksilver> which is what I meant by the (>>) instance :)
02:51:41 <quicksilver> https://hackage.haskell.org/package/reducers-3.11/docs/Data-Semigroup-Apply.html
02:51:43 <merijn> quicksilver: What would mempty be?
02:51:48 <quicksilver> return ()
02:52:19 <merijn> quicksilver: Mine is more general
02:52:31 <merijn> quicksilver: That monoid is equivalent to mine with 'a' limited to ()
02:53:11 <quicksilver> yes
02:53:21 <merijn> Why would you needlessly restrict it to ()?
02:53:26 <quicksilver> you don't really
02:53:34 <quicksilver> you view it as ignoring return types
02:53:49 <quicksilver> (ignoring return values, rather)
02:54:19 <quicksilver> I take your point tho
03:04:49 <georgex> how come Text.Parsec has many function when many from Control.Applicative seems to work just as well?
03:05:26 <merijn> georgex: Text.Parsec predates Control.Applicative
03:05:41 <merijn> georgex: In other words: Backwards compatability
03:05:54 <merijn> georgex: Applicative is a surprisingly new invention, it wasn't conceived until 2004
03:06:07 <georgex> ah I see
03:08:08 <Ala> hoi
03:15:48 <dominik> Hey, could anyone tell me why in this snippet, the types fail to unify?
03:15:55 <dominik> http://lpaste.net/152494
03:16:48 <quicksilver> dominik: e has type Error String a
03:16:53 <quicksilver> not Error String b
03:17:02 <mniip> ^
03:17:11 <quicksilver> fmap f (Err err) = Err err
03:17:13 <quicksilver> would work
03:17:21 <quicksilver> I appreicate that seems mildly paradoxical
03:17:32 <dominik> whooo :D
03:17:36 <dominik> I just figured
03:17:38 <dominik> why is this?
03:17:41 <quicksilver> e "is" (Err err), but the second Err err is at a different type
03:17:46 <quicksilver> even though they look the same
03:17:54 <shachaf> It's a shame that GHC turns that into an allocation, though.
03:18:02 <quicksilver> it is.
03:18:55 <dominik> quicksilver: ok, thanks!
03:19:17 <georgex> @hoogle Eq a => a -> a -> [a] -> [a]
03:19:18 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
03:19:18 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
03:19:18 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
03:19:33 <georgex> is there such a function in Prelude?
03:19:52 <georgex> replace 'o' 'x' "foo" -> "fxx"
03:20:27 <quicksilver> no, I don't think there is, georgex 
03:21:07 <quicksilver> there is something in MissingH
03:21:47 <MasseR> @type \x y -> map (\z -> if z == x then x else z)
03:21:49 <lambdabot> Eq b => b -> r -> [b] -> [b]
03:22:22 <quicksilver> it's a bit daft that it's not available in Data.List or somewhere similar
03:22:36 <quicksilver> I think there is a lack of consensus on the right, elegant, general replace function
03:23:07 <georgex> I could swear I have used it before. maybe it is part of some utility lib
03:23:14 <martinvlk> @p \s -> (\a -> (a, s))
03:23:14 <lambdabot> Maybe you meant: palomer part paste ping pinky pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pop-topic pretty print-notices protontorpedo purge-notices push-topic v @ ? .
03:23:16 <quicksilver> Data.String.Utils most likely
03:23:43 <martinvlk> > ?
03:23:44 <lambdabot>  <hint>:1:1: parse error on input ‘?’
03:24:21 <martinvlk> @pl \s -> (\a -> (a, s))
03:24:22 <lambdabot> flip (,)
03:25:23 <martinvlk> @pl \s -> (\a -> (a, s)) <$> m
03:25:24 <lambdabot> (<$> m) . flip (,)
03:29:57 <martinvlk> @pl (\a -> (a, s))
03:29:57 <lambdabot> flip (,) s
03:30:16 <martinvlk> @pl \s -> (\a -> (a, s))
03:30:16 <lambdabot> flip (,)
03:32:46 * hackagebot mida 1.0.0 - Language for algorithmic generation of MIDI files  https://hackage.haskell.org/package/mida-1.0.0 (mrkkrp)
03:37:51 * hackagebot imap 0.2.0.0 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.2.0.0 (mkawalec)
03:37:53 * hackagebot mono-traversable 0.10.1.1 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.10.1.1 (MichaelSnoyman)
04:17:10 <codedmart> I can't seem to get multipart/form-data to work with wai? http://lpaste.net/152472
04:17:32 <codedmart> I am not sure what I am doing wrong, but par and files always end up blank.
04:20:14 <georgex> how do I cancel parser in Parsing? if something (return this) (else cancel parsing)
04:27:13 <merijn> georgex: Sounds like you want guard/empty
04:27:18 <merijn> :t empty
04:27:19 <lambdabot> Alternative f => f a
04:27:27 <merijn> > empty :: Maybe Int
04:27:28 <lambdabot>  Nothing
04:27:44 <merijn> georgex: "empty" is basically the "failing parser", it always fails
04:27:44 <georgex> merijn is fail ok too? it seems to work
04:27:54 * hackagebot imap 0.2.0.1 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.2.0.1 (mkawalec)
04:28:04 <merijn> georgex: Only in some monads, fail is a bit of an abomination
04:28:22 <merijn> :t guard
04:28:23 <lambdabot> Alternative f => Bool -> f ()
04:28:38 <merijn> > guard True :: Maybe ()
04:28:39 <lambdabot>  Just ()
04:28:43 <merijn> > guard False :: Maybe ()
04:28:45 <lambdabot>  Nothing
04:29:05 <absence> is there a library function or some other concept to achieve this?
04:29:07 <absence> :t fmap join . sequence
04:29:07 <merijn> georgex: Guard is basically "\b -> if b then return () else empty",
04:29:08 <lambdabot> (Monad f, Monad m, Traversable m) => m (f (m a)) -> f (m a)
04:36:21 <bernalex> hm. what's a good way to fallthrough? I have some semi-lengthy case thingy, where I now want to add two things that should result in the same
04:36:49 <bernalex> ("look":[a]) and ("look":"at"[a]) should both do the exact same thing
04:36:59 <bernalex> what's a not too annoying way of doing that?
04:37:48 <merijn> bernalex: Split the body off into a function in where clause and pass the match result in as argument?
04:38:05 <bernalex> merijn: that's more noisy than just duplicating the code
04:38:12 <bernalex> merijn: the rhs of -> is just two lines in a do
04:38:35 <merijn> But at least you're DRY :p
04:39:06 <bernalex> o_o
04:39:17 <bernalex> the things I've seen in the name of DRY
04:39:36 * bernalex shudders
04:41:04 <cheater> does anyone know what the | character means in the sequent calculus formulas used here? http://www.csd.uwo.ca/~mburrel/presentation/LCC.pdf
04:56:52 <t0by> cheater, I *suspect* that is a grammar and a -> b | c means "a can be b or c"
04:57:14 <cheater> doesn't work
04:57:19 <t0by> no, it's not
04:57:20 <t0by> nevermind
04:57:35 <t0by> nice background by the way
04:58:07 <ner0x652> Hi!
04:58:37 <ner0x652> I read a in Haskell book that pattern matching is syntactic sugar for case expression
04:59:14 <quchen> Not really. Case expressions are the primitive that allows pattern matching.
04:59:24 <quchen> All pattern matching is converted to (possibly nested) case expressions.
04:59:33 <ner0x652> If the expression evaluated in a case expression does not match any of the defined cases, it will throw a runtime expression. Is it possible to define an otherwise pattern for case expression?
04:59:51 <cheater> ner0x652: what book was that?
05:00:15 <ner0x652> I add a _ -> "Undefined case", but the compiler says pattern match(es) are overlapped
05:00:17 <merijn> ner0x652: Sure, a variable
05:00:18 <MasseR> ner0x652: it probably meant that for example `f Foo = "foo"` is converted to case
05:00:19 <cheater> quchen: you just defined syntactic sugar.
05:00:26 <ner0x652> cheater: Learn You a haskell
05:00:28 <merijn> ner0x652: Overlapped means that you have too many
05:00:41 <merijn> ner0x652: i.e. some patterns will never match because others are first on the list
05:01:40 <ner0x652> I think I understood, I am trying to pattern match a list
05:01:57 <ner0x652> added the cases then the list is: [], [x] and xs
05:02:08 <ner0x652> and the case _ -> "undefined list"
05:02:18 <MasseR> xs and _ are the overlapping ones
05:02:33 <ner0x652> so the last case is redundant, it does not make sense, as the compiler suggests
05:02:52 <merijn> ner0x652: Right
05:02:53 <MasseR> exactly
05:03:17 <MasseR> Btw, great that you are having -Wall on
05:03:33 <ner0x652> does it mean that those 3 cases will match all lists? is there is possibility for runtime error?
05:03:59 <bernalex> what was that trick again...
05:04:02 <bernalex> in the Maybe monad
05:04:03 <bernalex> n               <- M.lookup e ns
05:04:15 <ner0x652> yes, I do, I like to use the compiler as much as I can in writing good code :p
05:04:16 <MasseR> ner0x652: The code after = or -> might cause runtime errors
05:04:21 <bernalex> but e is Maybe a and you just want a
05:04:28 <MasseR> But you have handled al possible cases
05:04:30 <merijn> ner0x652: If you compile with -Wall the compiler will warn you if you're missing a possible case
05:04:34 <bernalex> I thought you could "Just e' <- e", but evidently not
05:04:45 <merijn> bernalex: That works in guards
05:04:51 <ner0x652> understood, Thanks :)
05:05:03 <bernalex> merijn: right so it works in monad comprehensions and stuff
05:05:15 <bernalex> what appropriate shortcut should I use here then? :p
05:05:27 <bernalex> I'm in fromMaybe "..." $ do ...
05:05:33 <merijn> bernalex: Maybe I misunderstand the question?
05:05:42 <bernalex> merijn: let me just paste the whole thing
05:06:01 <bernalex> merijn: http://lpaste.net/2712386454331326464
05:06:17 <bernalex> merijn: d :: Maybe a, but lookup wants just 'a'.
05:06:27 <bernalex> I could just use fromJust or something but eh
05:07:02 <MasseR> Hmm... I can't immediately see problems on that
05:09:49 <bergmark> bernalex: why not make the function handle `a' instead of `Maybe a'?
05:10:03 <bernalex> bergmark: that makes it less nice to call
05:10:06 <lpaste> merijn annotated “No title” with “No title (annotation)” at http://lpaste.net/2712386454331326464#a152500
05:10:14 <bernalex> bergmark: although I have considered it
05:10:15 <merijn> bernalex: See annotation?
05:10:35 <bernalex> merijn: oh yes of course I could just rewrite the entire thing for guards
05:10:36 <bernalex> merijn++
05:11:10 <merijn> I'm sure there's other compromises you could use, but it's a start
05:11:54 <MasseR> bernalex: what does the ghc complain about your version?
05:12:40 <pavonia> merijn: What syntax extensions do you use there?
05:12:48 <bernalex> MasseR: I already explained that. d is Maybe a but needs to be a. so I can do what merijn suggested.
05:12:54 <bernalex> pavonia: you don't need any extensions for that code.
05:13:05 <pavonia> Huh
05:13:11 <exio4> Pattern Guards are in Haskell2010
05:13:49 <MasseR> bernalex: ah I see
05:16:16 <merijn> pavonia: None
05:16:48 <merijn> No one ever appreciates PatternGuards
05:18:31 <pavonia> That even works in my (very old) GHC without enabling an extension
05:18:40 <hpc> mostly because it's a very minor thing to need an extension for
05:18:46 <bernalex> pavonia: haskell 2010 is 6 years old.
05:18:58 <merijn> And patternguards where in GHC before then
05:19:00 <hpc> if i had noticed it was standard i would have been using it more
05:19:12 <bernalex> merijn: without extensions?
05:19:33 <bernalex> I haven't programmed haskell for over 6 years. :)
05:19:35 <merijn> bernalex: No, but when H2010 came out the only thing they had to do is toggle the default value
05:19:43 <merijn> (of the extension flag)
05:19:57 <bernalex> merijn: yes that's what I assumed. it would be very odd if it weren't an extension prior to 2010.
05:20:04 <merijn> hpc: It's like the one useful addition that 2010 actually made :)
05:20:14 <hpc> didn't it make GADTs default too?
05:20:17 <merijn> No
05:20:20 <bernalex> 2010 did loads of useful things
05:20:25 <hpc> damn
05:20:26 <bernalex> hpc: unfortunately not
05:20:32 <bernalex> GADTs are super cool
05:20:38 <bernalex> but records are super not cool
05:20:48 <merijn> Because GADTs in the report means ExistentialQualification in the report too
05:20:48 <bernalex> i.e. records in haskell now
05:20:52 <hpc> i guess i know why, there were some issues with it interacting with stuff
05:20:57 <hpc> oh yeah, like that
05:21:09 <merijn> hpc: Not so much issues, as much as ideological differences
05:22:04 <bernalex> 2010 introduced EDDcls
05:22:13 <merijn> EDDcls?
05:22:32 <bernalex> > data D
05:22:34 <lambdabot>  <hint>:1:1: parse error on input ‘data’
05:22:41 <merijn> oh, EmptyDataDecls
05:22:59 <hpc> merijn: i think there was an interaction with deriving that was a problem at one point?
05:25:09 <bennofs> @let data D -- :)
05:25:11 <lambdabot>  Defined.
05:26:19 <gracefu> oi XD
05:27:56 * hackagebot imap 0.2.0.2 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.2.0.2 (mkawalec)
05:28:11 <hpc> ooh
05:28:25 <hpc> ^ i like those kinds of libraries
05:28:38 <nomeata> Hi. Can someone enlighten me on the relation between the cairo and svgcairo packages?
05:28:49 <nomeata> cairo comes with a flag to enable an SVG backend.
05:34:12 <mjrosenb> nomeata: my guess would bethat svgcairo has fewe dependencies than cairo?...
05:35:47 <nomeata> mjrosenb: could be, yes.
06:23:00 <lwm> bennofs: question about tasty-th - does the $(defaultMainGenerator) pick up all imported prop_* and case_* ?
06:23:13 <lwm> or they need to be written in the current file
06:48:09 <Xeironis> I can make an instance declaration for lists by writing something like "instance Functor []". Is there a way to write an instance declaration for lists of lists?
06:49:12 <mauke[w]> not in H98 but probably with FlexibleInstances
06:49:22 <Xeironis> alright, I'll look into that, thanks
06:49:35 <mauke[w]> ... but not for constructor classes like Functor
06:49:51 <mauke[w]> you can say something like instance MyClass [[a]] where ...
06:49:53 <mauke[w]> I think
06:50:08 <Xeironis> okay
06:50:48 <Xeironis> I feel like that should be possible
06:51:07 <mauke[w]> for functor it'd have to be instance Functor ([] . []) with . representing type-level composition
06:51:11 <mauke[w]> which doesn't exist
06:51:15 <Xeironis> right
06:51:19 <bradley_hardy> You can, but you shouldn't, because it will overlap with instances of the same class for [a] (you need an OVERLAPPING pragma in order to make GHC let you do it). If you need an instance of something for [[a]], you should newtype it.
06:51:59 <Xeironis> Well, Functor was just an example for [], but I can imagine that there might be classes that don't have a possible instance for [], but do have one for [] . []
06:52:31 <bradley_hardy> In that case you can make an instance for `newtype ListList a = [[a]]` instead.
06:52:40 <Xeironis> Ah, that makes sense
06:52:44 <Xeironis> thanks
06:52:49 <bradley_hardy> Oops, that should be `newtype ListList a = ListList [[a]]`
06:52:54 <Xeironis> right
06:52:54 <bradley_hardy> (It needs a constructor)
06:52:59 * hackagebot imap 0.2.0.3 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.2.0.3 (mkawalec)
06:53:01 * hackagebot svg-builder 0.1 - DSL for building SVG.  https://hackage.haskell.org/package/svg-builder-0.1 (jeffreyrosenbluth)
06:53:50 <obadz> Question: is there a way to write a function with this type signature: Monad m ⇒ m [a] → (a → m b) → [m b] ?
06:54:10 <obadz> I don't think there is with Monad constraint alone
06:54:15 <obadz> (could escape IO ?)
06:54:44 <obadz> I'm pretty convinced you can't at this point
06:54:45 <bradley_hardy> Technically you could, but it'd have to be the constant empty list function I think.
06:55:04 <bradley_hardy> Because yeah, you can't pull the list out of the monad in the first place to operate on it.
06:55:44 <obadz> right
06:57:02 <codedmart> Any wai users here right now? I could really use some help understanding what I am doing wrong: http://lpaste.net/152472. par and files are both blank.
06:57:10 <mauke[w]> :t \ma f -> map (\i -> ma >>= \xs -> f (xs !! i)) [0 ..]
06:57:12 <lambdabot> Monad m => m [a] -> (a -> m b) -> [m b]
06:58:51 <bradley_hardy> Oh, of course, that makes sense. You're running the monadic action once per item in the list though!
06:58:53 <mauke[w]> :t \ma f -> map (\i -> do xs <- ma; x : _ <- return (drop i xs); f x) [0 ..]
06:58:54 <lambdabot> Monad m => m [a] -> (a -> m b) -> [m b]
06:59:00 <ggVGc> so I have an API that has me supply a callback, but I need to keep state between callbacks. How do I do this>
06:59:05 <ggVGc> do I have to use an IORef?
06:59:07 <mauke[w]> bradley_hardy: yes :-)
06:59:23 <mauke[w]> ggVGc: what's the type of the callback?
07:00:13 <ggVGc> mauke[w]: a -> IO ()
07:00:36 <obadz> mauke[w]: interesting
07:00:40 <mauke[w]> yeah, an IORef would work
07:00:53 <mauke[w]> or you could have the callback shove the value into a queue to be processed elsewhere
07:01:18 <ggVGc> just wish I could do it with recursion
07:01:21 <ggVGc> IORef seems wrong
07:01:37 <ggVGc> mauke[w]: it needs to call another stepper function which keeps state
07:01:48 <ggVGc> but I need to pass that state again at the next callback
07:02:07 <ggVGc> I guess IORef is what I'll need to use
07:02:11 <bradley_hardy> ggVGc: Once you're in the realm of IO callbacks, you're fairly inextricably bound to mutation.
07:02:20 <ggVGc> sucks
07:02:26 <ggVGc> this feels like bad API design
07:02:38 <bradley_hardy> What library is it?
07:02:53 <obadz> mauke[w]: this implementation will return a list that eventually bottoms unless the input list is infinite though..
07:03:18 <mauke[w]> obadz: not exactly bottom. the second version uses fail
07:03:18 <ggVGc> bradley_hardy: HMidi
07:03:27 <exio4> you need to add some mzero
07:03:33 <ggVGc> it's the callback for listening to a midi source
07:03:50 <obadz> mauke[w]: oops hadn't seen the 2nd one
07:04:53 <obadz> a failed pattern match inside do notation uses fail?!
07:05:18 <bradley_hardy> ggVGc: Yeah, the library consists of fairly low-level bindings to a C library, so you're bound to get that. It would certainly be possible to implement a more idiomatic API on top of it, which uses IORefs under the hood but hides it from users.
07:05:31 <ggVGc> ah yeah
07:05:33 <ggVGc> alright
07:05:33 <ggVGc> cool
07:05:38 <ggVGc> so IORef is the right answer then anyway
07:05:40 <mauke[w]> :t let mkstepper :: (a -> b -> b) -> a -> IO (a -> IO ()); mkstepper f z = do r <- newIORef b; return (\x -> b <- readIORef r; writeIORef r (f x b)) in mkstepper
07:05:41 <ggVGc> just wanted to double check
07:05:42 <ggVGc> thanks
07:05:42 <lambdabot>     parse error on input ‘<-’
07:05:42 <lambdabot>     Perhaps this statement should be within a 'do' block?
07:08:45 <obadz> > do { (x : _) <- Just []; return x }
07:08:46 <lambdabot>  Nothing
07:08:49 <obadz> whoaaaaa
07:08:53 <obadz> you live and you learn
07:09:58 <mauke[w]> > [ x | Just x <- [Just 1, Nothing, Just 3, Nothing] ]
07:09:59 <lambdabot>  [1,3]
07:10:13 <mauke[w]> > do Just x <- [Just 1, Nothing, Just 3, Nothing]; return x
07:10:15 <lambdabot>  [1,3]
07:10:46 <obadz> list comprehensions always map to do-notation in that way?
07:11:05 <mniip> well there's one problem
07:11:19 <mniip> list comprehensions skip unmatched items, whereas do-notation invokes 'fail
07:11:22 <mniip> '
07:12:50 <obadz> > fail undefined :: [Int] -- mniip
07:12:51 <lambdabot>  []
07:13:01 <obadz> looks like fail in the list monad is []
07:13:33 <statusfailed> What's the recommended monad-transformer for errors? MonadThrow or something?
07:13:47 <obadz> statusfailed: ExceptT ?
07:14:01 <obadz> statusfailed: MonadError is the typeclass
07:14:24 <statusfailed> obadz: noice, thanks
07:15:09 <mniip> obadz, 'fail' is a very very bad thing though
07:15:57 <obadz> mniip: so they say..
07:16:00 <mauke[w]> mniip: I would be very surprised if list comprehenions didn't use fail
07:17:03 <geekosaur> list comprehnsions don't. monad comprehensions do
07:17:27 <obadz> geekosaur: monad comprehension? means do notation?
07:17:34 <geekosaur> obadz, no
07:18:02 <obadz> {-# LANGUAGE MonadComprehensions #-} -- whoaaaaa
07:18:39 <mniip> let's see
07:18:44 <geekosaur> list comprehension syntax was originally monad comprehension syntax, Haskell98 restricted i to liss and made it desugar to non-monadic operations, ghc re-aded monad comprehnsions as an extension and list comprehensions with MonadComprehensions enaled again desugar to monadic operations
07:19:42 <obadz> bottomless pit of haskell knowledge shows its deep darkness again
07:19:57 <Johnny_> Hey, I am currently taking a lecture on Haskell programming and the Professor said, that it is possible to define zipWith by using map and uncurry... I sadly cant figure out how.. Does someone of you have an idea?
07:20:19 <obadz> :t zipWith
07:20:20 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:21:33 <bernalex> my brain is tired
07:21:34 <prati> I am trying out http://lpaste.net/152496 , 
07:21:51 <prati> I want to understand why fooCPSWrong is wrong way to define CPS Style
07:22:15 <prati> @let { fooCPSWrong [] k = k 5 ; fooCPSWrong ( 0 : xs) k = fooCPSWrong xs k ; fooCPSWrong ( x : xs) k = k (x + fooCPSWrong xs k) }
07:22:16 <lambdabot>  .L.hs:153:1: Warning:
07:22:17 <lambdabot>      Pattern match(es) are overlapped
07:22:17 <lambdabot>      In an equation for ‘fooCPSWrong’:
07:22:20 <bernalex> when you have f :: a -> b -> b, and as :: [a], and b :: b, how do you f every a to b, remembering the result each time?
07:22:48 <prati> bernalex: For me ?
07:22:54 <bernalex> i.e. let b' = f (head a) b; let b'' = f (head (tail a)) b'; etc.
07:22:59 <bernalex> prati: no.
07:23:20 <mauke[w]> bernalex: foldl?
07:23:28 <obadz> Johnny_: hint, you'll need to use zip as well
07:23:44 <bernalex> mauke[w]: my brain thanks you.
07:24:12 <bradley_hardy> :t map . uncurry -- Johnny_
07:24:14 <lambdabot> (a -> b1 -> b) -> [(a, b1)] -> [b]
07:24:35 <bernalex> mauke[w]: although I'll just use foldr f b as.
07:24:47 <mauke[w]> prati: when you convert a normal function to CPS, you generally never call k twice
07:25:41 <prati> mauke[w] Okay, 
07:25:56 <prati> But, Can you look at the following, 
07:26:04 <prati> @undefine
07:26:04 <lambdabot> Undefined.
07:26:10 <prati> @let { fooCPSWrong [] k = k 5 ; fooCPSWrong ( 0 : xs) k = fooCPSWrong xs k ; fooCPSWrong ( x : xs) k = k (x + fooCPSWrong xs k) }
07:26:11 <lambdabot>  Defined.
07:26:17 <prati> @let { fooCPS [] k = k 5 ; fooCPS ( 0 : xs) k = fooCPS xs k ; fooCPS ( x : xs) k = fooCPS xs ( \r -> k ( x + r )) }
07:26:18 <lambdabot>  Defined.
07:26:38 <mauke[w]> > fooCPS [1,2,3] id
07:26:41 <lambdabot>  11
07:26:43 <prati> @let report x  = x 
07:26:43 <lambdabot>  Parse failed: Illegal character ''\FS''
07:26:47 <mauke[w]> > fooCPS [1,2,3] (* 2)
07:26:51 <lambdabot>  22
07:26:54 <mauke[w]> > fooCPSWrong [1,2,3] (* 2)
07:26:57 <lambdabot>  114
07:27:13 <mauke[w]> there, different results
07:27:29 <prati> Yes :)
07:27:59 <prati> How these evaluated differently ?
07:28:08 <Johnny_> jea i got a solution using zip, but i thought maybe there is a clever solution with only map and uncurry.. Thanks :)
07:28:20 <prati> How fooCPS and fooCPSWrong evaluates differently 
07:28:46 <mauke[w]> step through them
07:29:20 <prati> Also, Is there proper def on what's not CPS form and what's CPS
07:30:13 <obadz> Johnny_: can't think of one
07:30:35 <obadz> Johnny_: I think you need all 3
07:31:13 <sphinxo> Any ideas on how I clean up the evalExpr Builtin stuff? http://lpaste.net/7239618701161398272
07:31:39 <Johnny_> obadz: ok thank you!
07:33:09 <obadz> sphinxo: lots of partial functions in there..
07:34:30 <sphinxo> obadz: is that a particually bad thing? if so how could I refactor it?
07:34:37 <obadz> sphinxo: seems to me that your Expr allows for lots of illegal expressions
07:34:45 <sphinxo> yeah
07:34:51 <sphinxo> Gadts? 
07:35:02 <obadz> sphinxo: for instance, List [Expr] where you really want the first element of the list to always be a Function or Builtin, right?
07:35:16 <obadz> I think if you're working only on Int you don't need GADT
07:35:22 <sphinxo> oh ok
07:36:03 <sphinxo> Should I have two different list types?
07:36:24 <obadz> sphinxo: maybe have FnApp Function Expr Expr ?
07:36:42 <sphinxo> why two exprs?
07:36:42 <obadz> sphinxo: where data Function = Builtin | Fn …
07:36:52 <obadz> sphinxo: or list of exprs depending on function arity..
07:37:36 <obadz> I admit I've never gone through this excercise so I might be pointing you in wrong direction
07:37:53 <sphinxo> hmm
07:38:45 <sphinxo> Anybody else got any experience doing this kinda thing?
07:39:15 <obadz> sphinxo: goal is to build a lambda calculus over int interpreter, right?
07:39:29 <sphinxo> yeah/lisp interpreter
07:39:48 <obadz> lisp but your only datatype is Int ?
07:40:00 <obadz> and you can define top level functions and you have lambda functions, right?
07:40:07 <sphinxo> for the moment yes
07:40:13 <prati> mauke[w]: Thanks, it made sense with ur counter use case !!
07:43:38 <obadz> sphinxo: basically I would remove Builtin / Fn / List from Expr
07:43:51 <sphinxo> and replace with?
07:44:09 <obadz> sphinxo: and replace by FnApp Function [Expr]
07:44:48 <obadz> sphinxo: and data Function = Builtin | Fn …
07:44:58 <sphinxo> Great
07:45:09 <sphinxo> How should I represent nil?
07:45:18 <obadz> sphinxo: so that every Expr can always be evaluated down to an Int
07:45:26 <obadz> sphinxo: means you can't store lists in symbols though..
07:45:48 <obadz> sphinxo: yeah maybe throw Nil in Expr
07:45:58 <obadz> sphinxo: for when functions don't have enough args or something
07:46:13 <sphinxo> hmm
07:47:33 <mjrosenb> I store a bunch of stuff on disk, and I want to make it infinitely backwards compatible, I have a plan for doing this, but it is super-complex.  Anyone feel like giving me an idea for how to do it?
07:47:46 <csd_> why does ghc complain about a parse error with this statement: (readLn :: IO [Char]) >>= print
07:47:52 <csd_> complains regardless of how i cast readLn
07:48:18 <obadz> mjrosenb: Json?
07:49:12 <arw> mjrosenb: find some standard to implement, implement it, stick to it and document everything in detail.
07:49:14 <mjrosenb> @type (readLn :: IO [Char]) >>= print
07:49:16 <lambdabot> IO ()
07:49:40 <csd_> mjrosenb: that's valid, right?
07:49:41 <bradley_hardy> mjrosenb: you could try http://hackage.haskell.org/package/safecopy
07:49:52 <arw> mjrosenb: and don't bother with "somebody will figure out how to parse my custom xml/json/textfile format", that doesn't really work.
07:50:14 <obadz> csd_: you're using the Read instance for Strings, which requires your input to be properly quoted like a String
07:50:40 <mjrosenb> arw: "custom format" is currently "output of show"
07:50:50 <csd_> obadz: ah... what function would i use to not have to quote
07:51:08 <csd_> getLine i guess
07:51:10 <obadz> :t getLine
07:51:11 <lambdabot> IO String
07:51:17 <csd_> thx obadz 
07:51:18 <arw> mjrosenb: do you want it compatible with any software besides your own? so should your data survive your software?
07:51:38 <obadz> csd_: and print btw will add the quotes (using Show instance). use putStrLn if you don't want them.
07:53:11 <csd_> my question was sparked by trying to follow along with https://wiki.haskell.org/IO_inside#.27.3E.3E.3D.27_and_.27do.27_notation .. could have been more clear in this regard IMO
08:00:23 <csd_> haskell is so freaking cool
08:00:30 <mjrosenb> arw: nope, don't care a lick about compatability with anything other than previous versions of this software.
08:00:45 <sphinxo> csd_: indeed it is
08:00:48 <mjrosenb> bradley_hardy: that weems really neat.  I'll look insto it.
08:01:01 <sphinxo> csd_: map ($4) [even,odd]
08:01:16 <sphinxo> csd_: also  iterate (*2) 1
08:01:48 <csd_> have there ever been studies evaluating whether programming in haskell is more secure than in other languages? intuitively i would think it would be
08:01:50 <obadz> bradley_hardy: safecopy seems pretty cool. Wondering if we should be using something like this for Json :)
08:03:51 <fractalsea> I’m trying to track down the source of a fromJust exception. I used -xc, but all I get in the stack trace is `Data.Maybe.CAF`. Is there any way I can get more info?
08:04:53 <obadz> fractalsea: sadly I think you must use profiling to get stack traces
08:05:11 <bennofs> fractalsea: yeah, enable profiling and compiling your whole project with -fprof-auto
08:05:19 <fractalsea> obadz, ah I see. Yeah I don’t think I had library profiling on...
08:05:22 <fractalsea> Thanks
08:05:42 <bennofs> fractalsea: -fprof-auto will make it so that you see which function in your project called the fromJust function
08:06:24 <fractalsea> bennofs, great, thanks. I’ll try that
08:07:33 <lingxiao_> hey could somene come over to #coq and help me with a proof please?
08:07:39 <bernalex> it seems I will never in my entire life remember this
08:07:50 <bernalex> { activeRoom = activeRoom w { roomMonsters = ms' } } -- where do the freaking parens go?
08:08:07 <bernalex> forgot a w -- w { activeRoom = activeRoom w { roomMonsters = ms' } }
08:09:38 <bernalex> ah
08:09:40 <bernalex> found it
08:09:47 <bennofs> bernalex: that parses as w { activeRoom = activeRoom (w { roomMonsters = ms' }) \
08:09:53 <bernalex> show-type-plugins++
08:10:17 <mjrosenb> I find the syntax for {} to be super confusing.
08:10:30 <bernalex> it is
08:10:54 <erebe_> i cannot agree more on that
08:10:59 <mjrosenb> otoh, what I want it to be would almost certainly break the most common use case
08:11:29 <mjrosenb> namely, that {foo=bar} is a suffix function that is the equivalent of (\x -> x{foo=bar})
08:11:46 <mjrosenb> but that will /totally/ break Ctor {f1 = a, f2 = b}
08:12:17 <bennofs> mjrosenb: just make it be a normal function. (&) is available in Data.Function, so you can write x & { foo = bar } if you really want
08:13:10 * hackagebot judy 0.2.4.1 - Fast, scalable, mutable dynamic arrays, maps and hashes  https://hackage.haskell.org/package/judy-0.2.4.1 (MarkWotton)
08:13:34 <mjrosenb> right, but then Ctor becomes a value with both fields being whatever magical undefined state they'd be in with Ctor {}, which would break using it as a function.
08:16:36 <arw> mjrosenb: then something like safecopy should work.
08:20:45 <mjrosenb> I'll certainly be checking it out this evening.
09:37:44 <NemesisD> hi folks. ContT/MonadCont question. the docs for MonadCont say it has an escape mechanism w/ callCC, but the best I've been able to manage is an escape with ContT. is it possible to write checkpoint in terms of callCC? http://lpaste.net/7782755558129401856
09:48:17 <Cale> NemesisD: uhhh, that's weird. You should be able to break out of a forever by executing the continuation that callCC gives you
09:48:22 <Cale> NemesisD: What happens?
09:49:11 <monochrom> is it "forever (callCC"? is it "callCC (forever"? they are different.
09:51:25 <NemesisD> i've clarified it by adding the typeclass version http://lpaste.net/7782755558129401856
09:52:12 <Cale> Prelude Control.Monad.Cont Data.IORef> (`runContT` return) . callCC $ \ret -> do r <- liftIO (newIORef 0); forever $ do v <- liftIO (readIORef r); when (v >= 100) (ret v); liftIO (writeIORef r (v+3))
09:52:12 <Cale> 102
09:52:26 <NemesisD> monochrom: its forever (callCC
09:52:27 <Cale> I'll try the threaded one
09:52:34 <Cale> oh, what?
09:52:44 <Cale> You can't break out of the forever if the callCC is inside
09:52:54 <Cale> the current continuation includes the rest of the forever
09:52:59 <monochrom> then it means you can skip to the next iteration
09:53:05 <NemesisD> but you can with the ContT version
09:58:20 <Cale> NemesisD: callCC and the ContT data constructor have very different semantics. They also have rather different types.
09:59:33 <NemesisD> Cale: yeah, so it sounds like its impossible to do what i'm trying to do with just MonadCont
10:00:31 <Cale> NemesisD: Well, you're aborting the entire runContT
10:01:12 <Cale> So yeah, sort of, though you could just put the whole thing in a callCC, and use *that* continuation.
10:02:10 <monochrom> "callCC (forever" is a thing
10:02:50 <NemesisD> unfortunately this causes the end user to have to be very careful/conscious of what monadic functions they're using
10:03:02 <monochrom> on the other hand, the value of MonadCont is fairly little
10:03:20 <NemesisD> i'm trying to define a transformer where the user can define checkpoints where it would be safe to cancel the whole computation
10:03:41 <NemesisD> i've got it working with ContT, its not much different than the paste
10:06:22 <qwerkljhsdfhj> t
10:06:25 <qwerkljhsdfhj> :t
10:08:01 <mniip> mauke, so I've recompiled base with fail=error
10:08:03 <mniip>  > [() | True <- [False]]
10:08:03 <mniip> []
10:08:37 <monochrom> have you missed some rewrite rules?
10:10:41 <lpaste> Cale pasted “Using callCC to finish early” at http://lpaste.net/152528
10:10:49 <Cale> NemesisD: ^^
10:11:04 <mniip> oh
10:11:07 <mniip> desugarer
10:13:05 <Cale> NemesisD: of course, probably what you really want is to pre-apply checkpoint to that continuation and pass checkpoint in
10:16:06 <lpaste> Cale pasted “A little bit closer to the original idea.” at http://lpaste.net/152529
10:17:36 <lpaste> mniip pasted “core” at http://lpaste.net/152530
10:18:14 <NemesisD> Cale: ooh, that's nice!
10:24:58 <oish> I know that people are going to say IEEE but it seems to me like addition on Floats ought to be associative. It seems to break down around 8 decimal places eg.
10:25:20 <oish> (0.4880033 + 2.5480988e-6) + 1.4901168e-6 == 0.4880033 + (2.5480988e-6+1.4901168e-6)
10:25:25 <oish> False
10:25:30 <EvanR> it ought to be assoc?
10:25:46 <EvanR> morally speaking ? :)
10:25:47 <oish> IS there a good way to get associativity back for small floats?
10:26:04 <oish> EvanR: Ethically. yes :-)
10:26:13 <EvanR> is it even assoc for normal sized floats?
10:26:33 <EvanR> actually the exponent shouldnt even matter until you get to the denormalized ones
10:26:49 <EvanR> if the operands are around the same magnitude
10:27:08 <lambda-11235> > (0.4880033 + 2.5480988e-6) + 1.4901168e-6 == 0.4880033 + (2.5480988e-6+1.4901168e-6)
10:27:10 <lambdabot>  True
10:27:19 <Cale> oish: No, floating point operations are not associative.
10:27:53 <EvanR> > (0.4880033 + 2.5480988) + 1.4901168 == 0.4880033 + (2.5480988+1.4901168)
10:27:55 <lambdabot>  True
10:28:01 <EvanR> its a miracle
10:28:12 <EvanR> quickcheck however will show many cases where it doesnt work
10:28:28 <oish> EvanR: yep, that's what I have 
10:29:19 <oish> oh well, ((x+y) + z) - (x + (y+z)) < 0.000001 will have to do 
10:29:30 <EvanR> for what
10:29:52 <Cale> Basically all the nice properties you'd expect numbers to have apart from commutativity of the operations, the fact that 0 is an identity for addition, and the fact that 1 is an identity for multiplication, all fail.
10:30:13 <EvanR> commutativity might be out the window too
10:30:19 <Cale> Nah, they are commutative
10:30:29 <Cale> But the distributive law fails
10:30:40 <EvanR> is it guaranteed by the haskell standards?
10:31:00 <EvanR> i know its supposed to hold in ieee
10:31:02 <Cale> I mean, it's guaranteed by how floating point operations work
10:31:25 <EvanR> how they work on x86? 
10:31:36 <Cale> and in general
10:32:14 <monochrom> IEEE 754 specifies: floating_add x y = round (math_add x y). from this you can prove commutativity
10:33:16 <EvanR> in a=c, b=d, a+b == d+c, what if a and c happened to use two different precisions at the machine level
10:33:21 * hackagebot hsdev 0.1.6.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.1 (AlexandrRuchkin)
10:33:38 <monochrom> in fact, from this you can prove a lot of error bounds too. so that floating-point arithmetic is not as random as a cynic would say.
10:33:57 <EvanR> i need a real test case for that..
10:34:53 <EvanR> so you might only be able to reproduce commutative correctly by carefully deciding when and where to use extra precision
10:35:02 <EvanR> in the compiler
10:35:47 <EvanR> the rounding law is interesting though
10:39:07 <nitrix> MonadIO m => MonadIO (ReaderT * r m)
10:39:26 <nitrix> That means `ReaderT * r m` is a MonadIO when `m` itself is a MonadIO ?
10:40:08 <monochrom> what is * doing there?
10:40:45 <exio4> monochrom: kind application 
10:41:02 <nitrix> exio4: Hai c:
10:41:10 <nitrix> What does kind application means?
10:41:29 <mniip> wot
10:41:32 <monochrom> is that a joke?
10:41:37 <mniip> readerT is not kind-polymorphic
10:41:38 <Jinxit> a program that asks your permission before doing anything
10:41:44 <exio4> mniip: I was checking that
10:42:06 <EvanR> mayI keyword
10:43:08 <nitrix> So what does the asterisk mean?
10:43:58 <nitrix> newtype ReaderT r m a = runReaderT { r -> m a }
10:44:03 <nitrix> instance MonadIO m => MonadIO (ReaderT * r m)
10:44:20 <monochrom> where did you see this?
10:44:39 <nitrix> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Reader.html
10:44:55 <monochrom> ok, read an older version
10:44:57 <EvanR> i think haddock is broken wrt polykind sigs
10:45:25 <monochrom> in fact, read the version that matches your version
10:45:27 <EvanR> try reading the source code
10:45:37 <monochrom> which is very like merely 0.4.something
10:45:44 <geekosaur> yes, that's haddock reporting kinds weirdly
10:45:50 <nitrix> When I look at the source, it says:
10:45:53 <nitrix> instance (MonadIO m) => MonadIO (ReaderT r m) where
10:45:58 <ClaudiusMaximus> http://trac.haskell.org/haddock/ticket/189
10:46:05 <monochrom> in fact, never read docs from hackage. build local docs and read that only.
10:46:07 <geekosaur> I keep being told that's not a bug...
10:46:32 <monochrom> because hackager "latest" version never matches your installed version. (how could it?)
10:47:06 <EvanR> nitrix: the code makes sense, r is any type
10:47:35 <Cale> If you're referring to the extra *'s I think that's just Haddock not knowing to hide kind parameters.
10:48:03 <nitrix> Okay, so it's not intuitive that it's shown, but what is it?
10:48:09 <EvanR> ok, so r must be *, not k
10:48:13 <monochrom> it says what you said.
10:48:16 <nitrix> What does it means for ReaderT to have the asterisk?
10:48:26 <EvanR> :k Int
10:48:27 <lambdabot> *
10:48:29 <EvanR> :k k
10:48:31 <lambdabot> Not in scope: type variable ‘k’
10:48:34 <EvanR> :k Maybe
10:48:36 <lambdabot> * -> *
10:48:43 <exio4> :k forall k. k
10:48:44 <lambdabot> k
10:48:55 <Cale> :k ReaderT
10:48:56 <lambdabot> * -> (* -> *) -> * -> *
10:49:03 <Cale> oh, it's not kind-polymorphic
10:49:14 <nshepper1> ReaderT doesn't have a kind parameter
10:49:23 <nshepper1> so in this context, the * means nothing
10:49:26 <Cale> It *could* given its definition.
10:49:32 <nshepper1> I guess
10:49:48 <EvanR> an extra * makes no sense
10:50:44 <Cale> If the module got built with kind polymorphism turned on, then it would have a kind parameter. I think that's what's happening.
10:51:00 <nitrix> So what is it, * -> (* -> *) -> * -> *  ~  ReaderT r m a ?
10:51:07 <nitrix> m :: * -> *  ?
10:51:12 <monochrom> yes
10:51:31 <monochrom> r has kind *, for example r can be Int, but r cannot be Maybe
10:51:33 <nshepper1> Cale: forall (r :: *) (m :: k -> *) (a :: k). r -> m a?
10:51:42 <Cale> nshepper1: yeah
10:51:49 <monochrom> similarly, m can be Maybe, but m cannot be Int
10:51:53 <nshepper1> so the * haddock sees is referring to a
10:52:04 <Cale> right
10:52:19 <nitrix> So the issue with haddock is that it's displaying an extra `*`, right?
10:52:41 <nitrix> Not that it didn't match it with the proper type variable?
10:52:45 <Cale> nitrix: Yeah, it's displaying the argument to the implicit kind parameter.
10:52:47 <nitrix> If I understand correct?
10:53:03 <Cale> See nshepper1's type signature :)
10:53:27 <Cale> (for the ReaderT data constructor in that case)
10:54:01 <Cale> ReaderT's kind would be forall k. * -> (k -> *) -> k -> *
10:54:12 <Cale> But it can only be an instance of Monad etc. when k = *
10:54:35 <Cale> and in Haskell 98, k would be defaulted to * anyway
10:57:45 <nitrix> nshepper1: forall (r :: *) (m :: k -> *) (a :: k). r -> m a?
10:58:07 <nitrix> nshepper1: Aren't you supposed to have a (k :: *) as well or something?
10:58:19 <nitrix> I'm trying to learn forall too.
10:58:23 * hackagebot gore-and-ash-logging 1.2.1.0 - Core module for gore-and-ash with logging utilities  https://hackage.haskell.org/package/gore-and-ash-logging-1.2.1.0 (NCrashed)
10:58:54 <nshepper1> k is a kind variable there
10:59:04 <nitrix> Oh I see.
10:59:16 <nshepper1> if I added the k, it would be (k :: BOX)
10:59:17 <nitrix> r m a are type variables and :: is to indicate kinds.
10:59:24 <nshepper1> yeah
10:59:28 <nitrix> I see, and that'd be the sort.
10:59:34 <mniip> k :: TYPE Lifted
10:59:35 <mniip> :D
10:59:50 <nitrix> Strange how haskell reuses :: for types, kinds and sort.
10:59:58 <Cale> nitrix: Well, it's not that strange
11:00:30 <nshepper1> there's some voodoo going into ghc 8.0 that'll change the BOX thing, I've heard
11:00:38 <Cale> It's common to use : for all of them in pretty much all type theories which make the distinction.
11:00:44 <nitrix> Yes, to Lifted, I've read that too.
11:00:55 <nitrix> It's making `($)` very complicated now.
11:01:03 <nitrix> There's a whole debate on the mailinglist.
11:01:15 <Cale> Well, ($) is very complicated already, and they're making the complication visible
11:01:18 <johnw> a pretty senseless debate, if you ask me
11:01:26 <geekosaur> only some of the complication
11:01:29 <Cale> I would rather just uncomplicate ($), it's silly
11:01:39 <johnw> the answer being either "Constraint ($) to lifted types only", or "just don't show me again"
11:01:55 <mniip> Cale, the levity polymorphism has nothing to do with the typechecking shortcut
11:02:17 <johnw> there should be a flag where, if I don't care about levity polymorphism, I just don't see it, the same way that I don't see forall (x :: *) today, but just forall x
11:02:35 <mniip> johnw, -fshow-levity-polymorphism
11:02:39 <johnw> exactly
11:02:41 <geekosaur> and hat is what they are doing
11:02:48 <johnw> cool
11:03:01 <nshepper1> so how close are we to being able to write the type of (::)
11:03:08 <geekosaur> this is complicated by the fact that apparenly it's already suppressed in many cases but leaked out in a few
11:03:40 <EvanR> nitrix: well, what :: means anyway has always been undefined ;)
11:04:00 <EvanR> so might as well reuse it in similar context
11:04:45 <mniip> (::) :: forall (k :: *) (a :: k). a -> k -> Constraint
11:04:49 <mniip> :D
11:04:56 <EvanR> oh god
11:05:23 <EvanR> what :: is the second :: in that one ;)
11:05:33 <mniip> the same
11:05:40 <EvanR> impastable
11:06:10 <geekosaur> Ωmega lives!
11:06:28 <mniip> the second :: here has kind (forall (k :: *) (a :: k). a -> k -> Constraint) -> * -> Constraint
11:06:37 <EvanR> better
11:07:00 <mniip> so coherent
11:07:04 <mniip> now
11:07:08 <mniip> let's express the kind of (,)
11:07:26 <mniip> *evil laughter*
11:07:43 <EvanR> (,) is primitive
11:08:07 <EvanR> drops the mic
11:08:25 <exio4> mniip: what about (,)'s kind?
11:08:30 <exio4> @kind (,)
11:08:31 <lambdabot> * -> * -> *
11:08:40 <mniip> hahahaha
11:08:44 <mniip> hahahahahhaha
11:08:49 <mniip> *->*->* you're so funny
11:09:34 <Hrk_> Ist there a query for google that would search for package with given name? like package:split
11:09:47 <Hrk_> I mean for Hoogle
11:09:51 <exio4> mniip: ?
11:10:33 <exio4> mniip: (,) is "sane" AFAIK, maybe you were talking about unboxed tuples?
11:10:44 <cocreature> Hrk_: yes, package:split :) at least in the new hoogle http://hoogle.haskell.org/
11:11:00 <mniip> ooh
11:11:02 <mniip> new hoogle
11:11:17 <mniip> finally useful outside wired-in packages
11:11:23 <cocreature> it’s not that new anymore, but I think it’s still unreleased
11:11:30 <cocreature> but I’ve been using it exclusively for a few months
11:11:39 <cocreature> yeah it searches all of stackage afaik
11:11:47 <obadz> why do people say OCaml has a first class record system when it does not have row level polymorphism?
11:11:59 <Hrk_> cocreature: oh. I was trying on stackage and there it doesn't work yet: https://www.stackage.org/lts-5.3/hoogle?q=package%3Asplit
11:12:01 <EvanR> it doesnt?
11:12:17 <obadz> i.e. I'm not sure how OCaml's record system is better than Haskell, except for the namespace issue..
11:12:23 <obadz> EvanR: it does?
11:12:46 <EvanR> "Elisions Are Polymorphic
11:12:51 <EvanR> https://realworldocaml.org/v1/en/html/objects.html
11:13:01 <Hrk_> cocreature: cool. Thanks!
11:13:06 <the_2nd> thoughts on my little game engine (work in progress)? https://github.com/I3ck/HGE2D
11:13:06 <cocreature> Hrk_: yw
11:13:07 <obadz> EvanR: is the type signature of f x = x.a + x.b something like Has r "a" "b" => r -> Int ?
11:13:41 <EvanR> in what language?
11:13:52 <obadz> EvanR: so people are really refering to Objects when talking to OCaml's first class record system?
11:14:00 <obadz> EvanR: OCaml
11:14:48 <EvanR> thats the only kind of row polymorphism ive heard about in ocaml
11:14:58 <fiatjaf> how can I use `ghci -i` (so I can load packages with :load) pointing to a directory of precompiled packages (specifically the one generated by halcyon)?
11:15:01 <EvanR> the objects
11:17:11 <obadz> http://dev.stephendiehl.com/hask/#ocaml ⇒ "[…] a record system supporting first-class records"
11:17:44 <obadz> guess I'll ask him
11:17:59 <fiatjaf> I have this directory structure: http://lpaste.net/4253483388003942400
11:18:58 <EvanR> obadz: check out fieldslib
11:19:03 <geekosaur> fiatjaf, if they're precompiled then you need to find the package.conf.d corresponding to those packages
11:20:32 <Gentilhomme> how important are monads to write Haskell code?
11:21:02 <Gentilhomme> or in haskell in general
11:21:02 <gfixler> Gentilhomme: only a little
11:21:04 <obadz> Gentilhomme: kinda lika wheels to a car
11:21:12 <fiatjaf> geekosaur: I think I found it: http://lpaste.net/4253483388003942400
11:21:23 <nshepper1> Gentilhomme: Important enough to learn, not important enough to be afraid
11:21:25 <fiatjaf> now what should I do?
11:21:26 <hsk3> Can you show me an example of an infix type constructor?
11:21:39 <hsk3> How do I make one with "data"?
11:21:42 <obadz> nshepper1: would edit: not difficult enough to be afraid
11:21:52 <hsk3> I tried data (:--) a b = Hello a b but it doesn't work.
11:22:06 <obadz> hsk3: data a :+: b = a :+: b
11:22:11 <kadoban> Gentilhomme: More fuss is made about Monads than really needs to be. Don't try to spend forever learning them in the abstract, just read a haskell book that introduces them when it's time.
11:22:40 <hsk3> obadz: oh
11:22:44 <hsk3> that doesn't work unless I use TypeOperators
11:22:50 <hsk3> is that expected?
11:22:56 <obadz> hsk3: sure
11:23:23 <obadz> hsk3: if all you care about is the type constructor: data Hello a b = a :+: b
11:23:24 * hackagebot gore-and-ash-actor 1.2.1.0 - Gore&Ash engine extension that implements actor style of programming  https://hackage.haskell.org/package/gore-and-ash-actor-1.2.1.0 (NCrashed)
11:23:57 <Gentilhomme> not really afraid, just started reading about them as im learning haskell and i have trouble figuring out why you'd want to introduce such a concept in day to day programming
11:24:01 <obadz> hsk3: that doesn't require TypeOperators
11:24:18 <hsk3> obadz: you mean data constructor?
11:25:01 <kadoban> Gentilhomme: Many resources teach them badly and/or too soon. They're really not that important, it's just a common pattern that comes up in haskell code, so it was abstracted out. They're one of several ways to combine IO actions together, for instance.
11:25:07 <obadz> hsk3: yes you are correcet ;-)
11:25:13 <hsk3> ok thanks!
11:25:37 <kadoban> Gentilhomme: Out of curiosity, what are you reading/using to learn haskell?
11:25:58 <Gentilhomme> I installed leksah and im reading the wikibook on haskell
11:26:17 <geekosaur> fiatjaf, (sorry for delay, stuff taking forever to load here) ghci -package-db /app/ghc/lib/ghc-7.8.4/package.conf.d
11:26:19 <obadz> Gentilhomme: it's a useful absraction.. but before one realizes that it generalizes behaviors from a bunch of different types of things, it's better to see each type used in specific cases. One of which is IO.
11:26:53 <geekosaur> the packages themselves are not sufficient; you have the .hi and .o files but not, for example, what native libraries they require or the details of how to link them in
11:26:55 <obadz> Gentilhomme: you liking leksah?
11:26:56 <kadoban> I haven't read the wikibook, not sure if that's a good way to learn or not.
11:27:03 <nshepper1> Gentilhomme: have you heard of promises (from javascript)? that's a nice example of a useful thing with a monad interface
11:27:43 <nshepper1> the difference is in javscript it's not abstracted, you just learn the interface from scratch without noticing you've seen the interface before
11:28:31 <Gentilhomme> obadz: it's not bad. Had a little trouble setting it up and getting started but now I think I got it
11:28:50 <Gentilhomme> interface is pretty
11:29:17 <Gentilhomme> nshepper1: I've never used javascript before, sry
11:29:18 <gfixler> Gentilhomme: monads are not a complex thing, but very abstract, and thus give rise to many interpretations, which have spawned countless tutorials, the correctness and efficacy of which are argued over relenetlessly
11:29:51 <kadoban> Seems more like "the correctness of efficacy of which are mocked relentlessly" to me.
11:30:41 <gfixler> Gentilhomme: interpretations I've seen: A monad is like tainted data; monads are lifted types; monads are really DSLs; a monad is like a programmable semicolon; monads are just fancy function application; monads are category theoretic objects; monads are burritos
11:31:13 <Gentilhomme> I like the last one, lol
11:31:17 <gfixler> kadoban: yeah, that's closer to right
11:31:23 <gfixler> Gentilhomme: that's the one most despised :)
11:31:47 <gfixler> Gentilhomme: that one gave rise to many "no they're not burritos" posts/arguments
11:31:53 <fiatjaf> thank you, geekosaur, but it didn't work: http://lpaste.net/210577844181401600
11:32:05 <nshepper1> a monad is a common api
11:32:36 <fiatjaf> ghci just tried to search on the current directory
11:32:36 <gfixler> monads are wrapped values
11:32:36 <gfixler> the ideas are endless
11:33:25 * hackagebot vector-space-map 0.2.0 - vector-space operations for finite maps using Data.Map  https://hackage.haskell.org/package/vector-space-map-0.2.0 (ChristianConkle)
11:33:27 * hackagebot gore-and-ash-network 1.3.2.0 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.3.2.0 (NCrashed)
11:33:31 <gfixler> re: fancy function application, I noticed this one day: http://lpaste.net/136379
11:33:43 <gfixler> but so far, no one in here or elsewhere has found it of any interest
11:33:58 <monochrom> monads are not wrapped values. getChar does not wrap the character I will enter tomorrow. (how could it?)
11:34:01 <nshepper1> the burrito one is an advanced application that should probably wait until familiarity has been gained :)
11:34:06 <geekosaur> oh, that is not the package.db with those, then
11:34:18 <gfixler> Gentilhomme: note the arguing has already begun
11:34:24 <geekosaur> in fact it looks like that's your global package db
11:34:57 <nshepper1> the problem is just that all these 'interpretations' are the wrong way around. they're examples
11:35:10 <geekosaur> I would expect that the one you need is under /app/sandbox somewhere
11:35:15 <nshepper1> monads aren't wrapped values, wrapped values are a monad
11:35:17 <nshepper1> etc
11:35:30 <gfixler> nshepper1: true - they're so abstract, the only way to learn them is through examples, but everyone hates every example
11:35:32 <Gentilhomme> I feel like I unleashed a beast
11:35:38 <gfixler> because it doesn't get to the truth underlying it
11:35:54 <gfixler> Gentilhomme: don't worry - he's unleashed most days
11:35:57 <nshepper1> similarly burritos are a delicious monad
11:35:58 <geekosaur> fiatjaf, find /app -name aeson-\*.conf
11:36:01 <obadz> gfixler: surprised that "Monad is an interface" wasn't in your list ;-) Just saying…
11:36:08 <Cale> The best example instance for Monad is Parser.
11:36:13 <gfixler> obadz: couldn't remember them all - so many now
11:36:22 <geekosaur> Monad is.
11:36:24 <Cale> Obviously you should look at a bunch of others
11:36:27 <gfixler> we should keep a list, and rank them by closeness to right
11:36:47 <obadz> gfixler: yeah the rankings would definitely get argued over..
11:36:58 <Cale> But I think Parser is usually the thing which gets people to really understand the usefulness of the abstraction.
11:36:59 <gfixler> obadz: we can rank the rankings
11:37:03 <gfixler> we'll call them rank types
11:37:07 <Cale> (certainly this was the case for me)
11:37:08 <geekosaur> also if you built but did not install them somewhere then you cannot use them
11:37:24 <nshepper1> tainted data could also be a monad I guess
11:37:34 <gfixler> Cale: I'd have to see - can't Parser also be applicative?
11:37:53 <fiatjaf> geekosaur: you're a genius. thank you very much.
11:37:59 <obadz> gfixler: everything that's a monad is applicative+functor too..
11:38:02 <geekosaur> gfixler, only for some purposes
11:38:11 <gfixler> nshepper1: tained data is in a writeup by sigfpe: http://blog.sigfpe.com/2007/04/trivial-monad.html
11:38:17 <kadoban> gfixler: Parser is also what got me to actually start using Applicative XD
11:38:19 <fiatjaf> I run your "find" command and it was on /app/sandbox/i386-linux-ghc-7.8.4-packages.conf.d
11:38:34 <nshepper1> it's just an application of the identity monad right?
11:38:37 <gfixler> obadz: of course - just want Parser to definitely be monadic in the example
11:38:49 <gfixler> kadoban: me too
11:38:51 <fiatjaf> ghci is working now.
11:39:42 <geekosaur> fiatjaf, if you're going to be doing that often, you probably want $GHC_PACKAGE_PATH
11:40:04 <nshepper1> could be a nice way to store web application input that hasn't been sanity checked
11:40:12 <geekosaur> or install them in a (cabal or stack) sandbox and use cabal repl or stack ghci respectively
11:40:20 <Rotaerk> hmm is there some simpler function that unfolds but only returns the final value, rather than a list of every intermediate value
11:40:32 <Rotaerk> or would you generally unfold, and then get the last value from the list
11:41:06 <gfixler> monochrom: getChar doesn't wrap the character you'll type tomorrw; it wraps the character in a context of it needing to be retrieved at a later time
11:41:33 <monochrom> how do you know?
11:41:36 <EvanR> Rotaerk: you could use a fold for that
11:41:38 <gfixler> the wrapping is a context, and the context with IO is the work needed to retrieve the value
11:41:45 <gfixler> context is a better word
11:41:55 <monochrom> and is your sentence even falsifiable?
11:42:36 <gfixler> :t (>>=)
11:42:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:42:41 <Rotaerk> EvanR: hmm, good point
11:42:43 <monochrom> (remark: unfalsifiable = unscientific)
11:42:50 <gfixler> there's the value - a, in the context of m
11:43:03 <EvanR> abstract types are unscientific!
11:43:09 <gfixler> for Maybe, the M represents a possibility the value won't be there
11:43:28 <gfixler> for List, it represents values of many (possibly no) states
11:43:49 <gfixler> for IO, it represents an action that will have to be performed to possibly obtain the value
11:43:58 <fiatjaf> geekosaur: these things don't work here. they need me to compile everything and I have too little memory for that. I'm using halcyon which seems to be downloading the packages precompiled for me or something like that.
11:44:01 <monochrom> but I have no disagreement on Maybe and []
11:44:15 <gfixler> monochrom: I'd like to hear a better idea for IO
11:44:23 <gfixler> it's a murky one
11:44:33 <gfixler> to me, the value is always in all of these monads - that a exists
11:44:37 <monochrom> the free-monad story is the best story for IO so far
11:44:39 <fiatjaf> geekosaur: setting GHC_PACKAGE_PATH didn't work. ghci could not find "Prelude".
11:44:52 <monochrom> and it wraps no character
11:45:00 <obadz> Gentilhomme: well done opening the box of worms. You know how long it's going to take to put them all back in there?
11:45:04 <EvanR> gfixler: huh... it exists in Nothing?
11:45:06 <geekosaur> fiatjaf, yes, you'll need to include the global package path (the /app/ghc one you found earlier)
11:45:15 <geekosaur> it works like $PATH, colon-separated
11:45:29 <EvanR> or the Const Void monad?
11:45:30 <gfixler> EvanR: yes, you just can't have it
11:45:39 <gfixler> EvanR: things didn't work out for you, sorry
11:45:41 <EvanR> ... that doesnt make too much sense
11:45:44 <monochrom> for a refreshing example, "data No a = None" is a functor, applicative, and monad too. it wraps nothing.
11:45:59 <Gentilhomme> obadz: omg I'm so sorry 
11:46:02 <gfixler> EvanR: the a is right there in the type - Nothing doesn't make the a not be there
11:46:04 <Rotaerk> I made a relatively-simpler port of parsec, for C#, where I work... this function's signature, expressed in haskell, would be:  value -> (value -> Parser input value) -> Parser input value
11:46:20 <EvanR> gfixler: ok, so you have the type. you were saying the value of that type exists
11:46:42 <EvanR> monochrom: i was trying to come up with that one
11:46:49 <gfixler> EvanR: I misspoke - that type is always there
11:46:54 <gfixler> misstyped*
11:46:59 <EvanR> oh
11:47:06 <kadoban> Gentilhomme: The short version is just: don't worry about it and just learn it practically in context.
11:47:12 <obadz> monochrom: isn't that Proxy? :)
11:47:17 <Rotaerk> its purpose is to get a parser from the seed value, use that to get the next value, from which the next parser is obtained, and so on until the generated parser fails
11:47:32 <Rotaerk> and the result parser is one that returns the final result
11:47:39 <Rotaerk> so it's sort of a fold across ... the input
11:47:43 <monochrom> yes, but I like my names more
11:47:56 <gfixler> the endless bickering over every detail of the world of monads is one of the reasons I don't much care for them
11:47:58 <monochrom> data Nothing_to_see_here a = Move_along
11:48:25 * hackagebot gore-and-ash-sync 1.2.0.0 - Gore&Ash module for high level network synchronization  https://hackage.haskell.org/package/gore-and-ash-sync-1.2.0.0 (NCrashed)
11:48:45 <monochrom> no, there is no endless bickering over every detail of the world of monads. I am only doing endless bickering over your wrong model.
11:48:48 <kadoban> omg snake_case. You heretic.
11:49:00 <gfixler> monochrom: this moment is not what I'm talking about
11:49:30 <gfixler> monochrom: what wrong model? I've thrown out half a dozen models from as many other people
11:49:43 <obadz> the bickering is itself a Monad, because you look at the contents of the bickering, and produce some more bickering
11:49:45 <gfixler> and claimed up front that everyone has different ideas about what they are
11:49:50 <gfixler> obadz: :)
11:49:59 <EvanR> obadz: what, thats comonad
11:49:59 <obadz> bickering >>= noYoureWrong
11:50:13 <EvanR> :t duplicate
11:50:15 <lambdabot>     Not in scope: ‘duplicate’
11:50:15 <lambdabot>     Perhaps you meant one of these:
11:50:15 <lambdabot>       ‘replicate’ (imported from Data.List),
11:50:37 <obadz> Bickering a -> (a -> Bickering b) -> Bickering b
11:50:47 <gfixler> Gentilhomme: monads are a honey pot for people who love to be extremely right about difficult things
11:50:50 <EvanR> Bickering a -> Bickering (Bickering a)
11:51:14 <obadz> EvanR: can join that stuff ;-)
11:51:15 <monochrom> but you know which ones you wrote yourself (as opposed to just quoting other people's)
11:52:04 <NemesisD> why does monad-control explicitly not implement MonadTransControl for ContT. is it unsafe?
11:52:15 <monochrom> I don't think it can be done.
11:52:24 <NemesisD> fml
11:52:29 <monochrom> I think there is even a paper on why it can't be done
11:52:56 <obadz> speaking of Comonad.duplicate, how is it different from
11:52:59 <obadz> :t fmap return
11:53:00 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
11:53:10 <fiatjaf> thanks again, geekosaur!
11:53:28 <gfixler> monochrom: I think if you go back and read every line of mine, I only said one thing that isn't a direct repeat of the consenus I've gleaned in here, and it was a typo
11:53:41 <EvanR> obadz: well fmap return cant have any effect
11:54:11 <EvanR> and duplicate can, and the effect is very specific
11:54:21 <monochrom> ok, the sentence "getChar doesn't wrap the character you'll type tomorrw; it wraps the character in a context of it needing to be retrieved at a later time. the wrapping is a context, and the context with IO is the work needed to retrieve the value. context is a better word"
11:54:24 <EvanR> so specific to be basically useless ;)
11:54:44 <monochrom> for what it's worth, I am not even convinced that it is a falsifiable sentence.
11:54:47 <EvanR> (you cant make a library based on just comonad ops)
11:55:11 <obadz> yeah I guess Functor is less general than Comonad
11:55:22 <obadz> but I would assume there's some kind of law forcing duplicate = fmap return ?
11:55:23 <EvanR> functor is more general
11:55:24 <gfixler> monochrom: the idea of IO being a context of actions to be performed at runtime is not my idea; it's literally the thing I've heard most, by far, in here
11:55:37 <obadz> oh right
11:55:42 <mettekou> Has anyone here ever experienced the broken package error for `base` when running `stack build`?
11:55:44 <obadz> it is
11:55:54 <obadz> so I guess my question stands again?
11:55:55 <monochrom> it is one of those beautify prose that will get you an A+ from an essay teacher, but completely doesn't help me make predictions.
11:56:03 <EvanR> obadz: no... theres no law
11:56:07 <gfixler> monochrom: it helps me
11:56:07 <monochrom> s/beautify/beautiful/
11:56:10 <mettekou> As in some package is broken because `base` is missing.
11:56:20 <gfixler> :t getChar
11:56:22 <lambdabot> IO Char
11:56:44 <EvanR> obadz: that would really make comonad useless
11:56:48 <gfixler> to me, that Char dangling off the end means I can work with this like it's a Char, and push the problems of IO off to runtime
11:57:36 <gfixler> if I need to get 3 characters and join them, I don't have to think about the mess of the real world; I can get 3 chars in IO, and do what I need with them, knowing, because of the type, that things might not work out, because IO means work needs to be done later to actually have those Chars
11:57:37 <EvanR> gfixler: in the applicative sense, i guess
11:57:42 <EvanR> you can work with it like its a char
11:57:44 <johnw> obadz: "fmap return" wouldn't hold up to the duplicate laws, such as fmap extract . duplicate = id
11:58:26 * hackagebot gore-and-ash-async 1.1.0.0 - Core module for Gore&Ash engine that embeds async IO actions into game loop.  https://hackage.haskell.org/package/gore-and-ash-async-1.1.0.0 (NCrashed)
11:58:27 <EvanR> but with IO Char monad i work with it like i have no idea whats going to happen
11:58:40 <obadz> johnw: isn't extract the opposite of return?
11:58:47 <gfixler> EvanR: I don't think that's completely true
11:58:50 <johnw> obadz: yes
11:58:55 <obadz> johnw: fmap extract . fmap return = fmap (extract . return) = fmap id = id ?
11:58:57 <gfixler> EvanR: you need a Char, so you get a Char with getChar
11:59:07 <EvanR> maybe, maybe not
11:59:09 <gfixler> EvanR: true, you know it might not work out, but it doesn't mean you have no idea what will happen
11:59:28 <gfixler> you don't say "Screw it, I'm not even going to bother using this Char, because knowing my luck, it all will have failed anyway"
11:59:48 <EvanR> IO Char isnt a char in any way ;)
11:59:49 <zd234> with 8.0.1, do we get full row types? will we still need things like vinyl ? or does 8.0.1 only provide 'overloaded labels' without row types
11:59:50 <gfixler> you use the Char, as though you had it
11:59:59 <gfixler> EvanR: didn't say it was
12:00:06 <EvanR> like a function of type Int -> Int isnt an Int
12:00:14 <obadz> gfixler, EvanR ⇒ #haskell-monads-shmonads
12:00:15 <gfixler> EvanR: I've said a few times now that it's an action that might get you one
12:00:19 <gfixler> represents one
12:00:28 <johnw> obadz: well done, your proof trumps my internal reasoning
12:00:33 <EvanR> it doesnt represent one really
12:00:43 <gfixler> EvanR: okay, I'm done
12:00:48 <jmcarthur> gfixler: EvanR is just saying that IO doesn't have any defined semantics
12:00:49 <gfixler> EvanR: THIS is why I'm so done with monads :)
12:00:57 <obadz> johnw: can't tell if this is sarcastic? I know nothing about comonads..
12:01:01 <EvanR> dont let IO ruin monads for you!
12:01:03 <johnw> obadz: what bugs me is that that basically means your comonad has no information in it
12:01:15 <jmcarthur> gfixler: All we know is some axioms. And it's only that we *think* we know them, really.
12:01:29 <jmcarthur> meh
12:01:43 <jmcarthur> IO really is the worst.
12:02:00 <EvanR> how about game semantics for IO
12:02:06 <johnw> ah, I see, I was thinking of extract, not fmap extract
12:02:13 <johnw> extract . duplicate = id
12:02:18 <jmcarthur> EvanR: What would that be?
12:02:19 <johnw> that's the law that wouldn't work out for fmap return
12:02:22 <johnw> because it would throw away information
12:03:05 <monochrom> but you can look at a free monad that talks about a GetChar instruction and a PutChar instruction. it is well-defined and it still doesn't wrap a Char
12:03:06 <jmcarthur> I've never understood how understanding something in terms of game theory is supposed to be useful. If anything, it seems more useful to game theory than to me.
12:03:24 <obadz> what's the canonical comonad example people use to think about it? (Like Maybe for monads) ?
12:03:28 <jmcarthur> *to somebody studying game theory
12:04:45 <monochrom> game semantics is useful but you have to just use the definition of "two-person game" and its perspective, and not dive into game theory
12:04:51 <nshepper1> obadz: zipper is the one I have heard
12:05:10 <EvanR> for an IO Char to have meaning... there is someone with a Char -> IO ()... so the combined meaning is any combination of "ask for char" and "tell a char"
12:05:26 <johnw> obadz: Store usually
12:05:30 <EvanR> where there is no more asks than tells
12:05:40 <monochrom> for example, "forall a. a -> a" vs "(forall a. a -> a) -> Int -> Int" are best understood from the two-person-game perspective, i.e., caller-chooses vs callee-chooses
12:05:41 <grayling_> Anyone know any good tutorials on monad transformers. Specifically on maybeT.
12:05:44 <EvanR> youre not allowed to ask if they didnt tell yet enough times
12:05:47 <johnw> obadz: where Store s a = (s, s -> a)
12:05:52 <nshepper1> (launchMissiles >> return 'a') :: IO Char
12:06:21 <jmcarthur> monochrom: So is there a distinction between game semantics and a session type?
12:06:33 <monochrom> and it is worst understood by repeatedly waving the word "any! it can be any!"
12:06:46 <monochrom> I don't know session type
12:07:31 <EvanR> so an IO Char can only make sense given another player
12:07:40 <jmcarthur> EvanR: So basically the "interpreter" explanation.
12:07:50 <obadz> so erm.. duplicate (Store s f) = (Store s (Store s f)) ?
12:07:56 <zd234> does ghc 8.0.1 provide full row types or just overloaded labels? i.e. will we still need the links of ctrex/vinyl?
12:08:19 <obadz> and extract (Store s f) = f s ?
12:08:24 <EvanR> jmcarthur: i dont really know, im kind of winging it here
12:08:24 <geekosaur> just overloaded labels
12:08:26 <jmcarthur> EvanR: Which is another way of saying it's just a free monad.
12:08:26 * hackagebot gore-and-ash-sdl 2.1.0.0 - Gore&Ash core module for integration with SDL library  https://hackage.haskell.org/package/gore-and-ash-sdl-2.1.0.0 (NCrashed)
12:08:52 <EvanR> jmcarthur: right which probably doesnt answer questions about timing and concurrency
12:09:22 <EvanR> but it kind of answers the question about randomness
12:09:28 <EvanR> randomIO
12:09:29 <johnw> obadz: yes
12:09:55 <johnw> obadz: there are a few Google-able articles on Store and its uses
12:10:10 <obadz> is Store also a Monad ?
12:10:22 <obadz> I guess only if s is a Monoid ?
12:10:33 <johnw> try to define the instance
12:10:50 <obadz> well not even
12:11:32 <obadz> hmmm
12:11:32 <obadz> instance Monoid m => Monad (Store s) where return x = (mzero, const x) ?
12:11:36 <grayling_> The best Iøve found for what I'm trying to do is this gist:
12:11:39 <grayling_> https://gist.github.com/patrickt/7db6dd1a8a07ce7144db
12:11:47 <johnw> i mean, try it in Haskell and write some tests to verify your implementation based on the comonad laws
12:11:56 <johnw> that will build some intuition
12:12:02 <monochrom> jmcarthur: Ralph Back and Joakim von Wright's "Refinement Calculus" uses two-person games to explain that there are two opposite kinds of non-determinism, namely, one kind helps the programmer, the other kind fights the programmer.
12:12:03 <grayling_> And it seems to have an error in fancyEnvInfo.
12:13:26 <obadz> johnw: actually I don't see how duplicate (Store s f) = (Store s (Store s f))
12:13:33 <obadz> second argument has to be s -> a
12:13:40 <obadz> I have to think about this some more
12:20:24 <johnw> obadz: I think you were close: duplicate (Store s f) = Store s (`Store` f)
12:20:39 <obadz> johnw: don't tell me more I'm trying to work out the puzzle now :)
12:20:48 <johnw> k
12:20:51 <mniip> ooo
12:20:55 <mniip> comonadic stores
12:20:56 <obadz> I've got functor
12:24:27 <EvanR> jmcarthur: honest yes thats how i think of it... the free whatever over IO primitives
12:26:38 <monochrom> data Small_IO a = Answer a | GetChar (Char -> Small_IO a) | PutChar Char (Small_IO a)
12:27:15 <monochrom> notice how GetChar wraps a callback, not a Char. and how PutChar is the one wrapping a Char.
12:33:27 * hackagebot asciidiagram 1.2 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.2 (VincentBerthoux)
12:38:51 <sphinxo> Any ways I can simplify the builtin stuff? http://lpaste.net/2166115233309917184
12:42:23 <EvanR> oh wow ascii diagram
12:42:52 <sm> cute
12:44:37 <obadz> johnw: so I've got this https://gist.github.com/obadz/e2d444355144aaf144cf 
12:44:58 <obadz> johnw: and I can drop monoid if I write pure x = Store undefined (const x)
12:45:47 <monochrom> wait, from ascii art to png?! that's the unusual direction
12:45:51 <mniip> uhhhh
12:45:52 <mniip> no
12:46:00 <mniip> that's not how you do it D:
12:46:10 <obadz> mniip: is that for me?
12:46:13 <mniip> yes
12:46:18 <obadz> so what's wrong?
12:46:31 <mniip> I'm not sure the applicative/monoid instances need to be there
12:46:40 <mniip> but if they are that's defninitely not what they should look like
12:47:01 <obadz> mniip: who would you write pure?\
12:47:02 <mniip> consider
12:47:47 <mniip> pure id <*> Store "foo" (const ())
12:47:51 <mniip> should be identical to
12:47:56 <mniip> fmap id $ Store "foo" (const ())
12:47:58 <mniip> but it isn't
12:48:06 <obadz> hmmm
12:48:12 <obadz> because it gets evaluated further
12:48:40 <obadz> ok let me play some more
12:49:00 <obadz> nevermind I got it
12:49:26 <obadz>     f <*> x = fmap (extract f) x
12:49:50 <mniip> still not quite there
12:50:17 <mniip> I'm not versed enough in the applicative laws to put my finger on it but
12:51:03 <mniip> I think it has to do with the flip law
12:51:21 <mniip>     u <*> pure y = pure ($ y) <*> u
12:51:24 <mniip> check if this works
12:54:55 <obadz> Store s1 f1 <*> Store s2 f2 = Store s1 (flip f1 (f2 s2)) ?
12:55:20 <Luke> is there a good example of quickchecking for exceptions?
12:56:09 <mniip> obadz, I think it's closer to
12:56:30 <obadz> Stores don't derive Show or Eq so hard to check anything
12:56:33 <mniip> Store sf f <*> Store sx x = Store (sf <> sx) (f <*> x)
12:56:56 <obadz> oooooooooooh
12:56:59 <obadz> so you do use Monoid?!
12:57:20 <mniip> indeed you do
12:57:29 <obadz> wow I'm proud that I had this insight ;-)
12:57:37 <obadz> too bad I wasn't able to do much with it other than write pure
12:57:47 <mniip> now, I
12:57:51 <mniip> 'm not sure it's a Monad
12:57:55 <mniip> for same reasons as Const
12:58:48 <obadz> and you use the (s ->) Applicative instance too
12:58:57 <obadz> it's a concerto of typeclasses!
12:59:21 <mniip> welcome to the madhouse
13:00:13 <obadz> mniip:     join (Store s (Store s' f)) = Store (s <> s') f ?
13:00:28 <mniip> hmm
13:01:07 <mniip> return (f x) = fmap f (return x) -- check
13:01:30 <mniip> join (fmap join x) = join (join x) -- check
13:02:03 <mniip> x = join (return x) -- check
13:02:08 <mniip> what else is there
13:04:09 <obadz> this doesn't typecheck
13:04:13 <obadz> we should start with that ;-)
13:07:39 <mniip> oh
13:07:41 <mniip> hahaha
13:07:50 <mniip> madhouse I'm telling you
13:08:25 <obadz> join' (Store s is) = Store (s <> s') f' where Store s' f' = is s
13:08:27 <obadz> this type checks
13:08:32 <obadz> but I don't like it
13:09:21 <obadz> s is used twice
13:10:10 <obadz> how about this:
13:10:12 <obadz> join' (Store s fs) = fs s
13:10:19 <obadz> Feels simple, must be it ;-)
13:10:42 <obadz> in other words
13:10:43 <obadz> join = extract
13:11:04 <obadz> x >>= f = extract (fmap f x)
13:13:15 <obadz> isn't that a law?
13:14:50 <Johnny_> hey i just found this gist: https://gist.github.com/patrickt/7db6dd1a8a07ce7144db, is it me or is the example fancyEnvInfo not working? (http://lpaste.net/152543)
13:20:22 <obadz> doesn't look like kmett wrote a monad instance for Store
13:20:27 <obadz> there probably isn't one.
13:21:46 <geekosaur> Johnny_, I think MaybeT was altered to make it more useful; the gist seems to be using it the old way, whereas the new one makes it possible to directly wrap a Maybe into a MaybeT but means you get those extra Maybe-s
13:22:11 <geekosaur> I recall people having to pattern match to turn a Maybe into a MaybeT
13:24:02 <grayling_> There seems to be a Control.Monad.Maybe and a Control.Monad.Trans.Maybe. Both doing the same thing.
13:24:03 <geekosaur> ...alhough if I read the gist information correctly, this was changed more than 6 months ago
14:50:05 <Vertue_> I am trying to parse a filename with trifecta,  but need to skip the path, but because there can be any number of '/' I cant figure out how to stop skipping characters after the last '/'
14:52:40 <hexagoxel> Vertue_: just parse a list of path fragments, then fmap last.
14:53:19 * hexagoxel hopes that trifecta works sufficiently similar to other parsing libraries so this makes sense.
14:55:44 <Axman6> hexagoxel: you're probably best using the parsers library and instantiating things using Trifecta, IIRC
15:01:17 <Vertue_> Thanks that will work
15:02:03 <Vertue_> Axman6: how do you do that? I have struggled to find examples
15:15:33 <alote> :q
15:15:47 <Axman6> Vertue_: the classes in there mostly come from well known parser combinators, so you should be writing something similar to what you would in say parsec
15:25:15 <Vertue_> Axman6: I get that part but I don't know how to instantiate it with trifecta or attoparsec
15:25:39 <kadoban> There's no lookupBy :-(
15:31:17 <johnw> :t find
15:31:18 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:31:52 <kadoban> Ah, thanks.
15:38:34 * hackagebot Plot-ho-matic 0.9.0.3 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.3 (GregHorn)
15:45:11 <srpx> Is it possible to assign a type to (\ x -> x x) in any reasonable type system?
15:47:39 <prooftechnique> Maybe one that supports equirecursive types?
15:47:43 <monochrom> yes
15:51:36 <Sonarpulse> I'm doing "ghc Setup.hs"
15:51:50 <Sonarpulse> and ghc is trying to read a bunch of unrelated files and getting configured
15:51:54 <Sonarpulse> *confused
15:51:57 <Sonarpulse> why is that?
15:52:11 <srpx> doesn't it make it inconsistent ?
15:52:37 <Sonarpulse> this is plain old normal Setup.hs that doesn't reference anything odd
15:52:42 <mauke> Sonarpulse: what's the output?
15:53:06 <Sonarpulse> I'm building base with nix
15:53:07 <Sonarpulse> for ghc
15:53:13 <Sonarpulse> complains about missing header in GHC.Fload
15:53:15 <Sonarpulse> *Float
15:53:24 <mauke> k bye
15:53:32 <Sonarpulse> and yes, there is a missing header, but it shouldn't care about GHC.Float
15:53:40 <Sonarpulse> oh and i turned off all autoconf stuff
15:53:42 <Sonarpulse> nuked it
15:54:24 <prooftechnique> Why not just nix-env -i ghc?
15:54:40 <Sonarpulse> I'm building base for ghcjs
15:54:45 <Sonarpulse> rewriteing ghcjs-boot in nix
15:55:15 <Sonarpulse> I've built ghc-prim and integer-gmp just fine so far
15:55:21 <Sonarpulse> no problems with Setup.hs
15:55:27 <prooftechnique> Oh, I was gonna say "nix-env -i ghcjs", but I see this is a bigger thing :D
15:56:18 <Sonarpulse> the goal of this is
15:56:28 <Sonarpulse> 1) use lts for built in libraries
15:56:34 <Sonarpulse> 2) get rid of nothing of built in libraries
15:56:43 <Sonarpulse> 3) expose absurdities of ghc build system
15:56:44 <Sonarpulse> :)
15:57:25 <prooftechnique> I think the absurdity of the GHC build system is a known element :D
15:57:36 <Sonarpulse> fair :)
15:58:05 <prooftechnique> What's the exact error?
15:58:16 <prooftechnique> And which GHC are you building for/with?
15:58:43 <prooftechnique> Does ghcjs have the normal versioning scheme? I honestly don't remember
15:58:44 <Sonarpulse> http://lpaste.net/152554
15:58:52 <Sonarpulse> ghcjs is unversioned basically :)
15:58:59 <Sonarpulse> building with 7.10
15:59:01 <Sonarpulse> lts-3
15:59:08 <Sonarpulse> if you have nix I can quickly push what i got
15:59:15 <Sonarpulse> it's half pushed already
15:59:52 <Sonarpulse> but simply doing "ghc Setup.hs" in a directory with broken modules seems to confuse ghc
16:01:34 <prooftechnique> Are you wavewave? Look like someone by that name has the same issue
16:01:43 <Sonarpulse> no Ericson2314 on github
16:02:08 <prooftechnique> https://github.com/wavewave/nix-build-ghc-android/blob/master/nixpkgs/development/haskell-modules/configuration-common.nix#L228
16:02:43 <prooftechnique> One of all of two references I find to that error. That's disheartening
16:04:08 <prooftechnique> The issue on haste seems to suggest you need a partially built GHC and a bunch of flags, though what those flags are is not stated
16:04:23 <Sonarpulse> interesting find
16:04:51 <Sonarpulse> I could see that *running setup.hs* might be weird
16:04:57 <prooftechnique> The haste issue, if it helps: https://github.com/valderman/haste-compiler/issues/11
16:05:00 <Sonarpulse> but buidling it really out to work
16:05:11 <Sonarpulse> ah yeah saw that
16:05:17 <Sonarpulse> but thanks anyways
16:05:46 <prooftechnique> It may be that it's expecting a stageN compiler to build with (for some N), and without that it can't find the header
16:07:14 <Sonarpulse> i feel like it's a bug/intensional inconsistency in ghc's make logic
16:07:20 <Sonarpulse> in which case, yuck
16:10:35 <Sonarpulse> prooftechnique: know of a way to make ghc not delete its temp dirs?
16:11:08 <prooftechnique> -keep-tmp-files?
16:11:25 <Sonarpulse> thanks
16:11:45 <Lokathor> http://lpaste.net/152555 i didn't forget any sorts of top level declarations, did i?
16:11:51 <prooftechnique> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html
16:12:24 <Sonarpulse> prooftechnique: oh one idea
16:12:26 <prooftechnique> Lokathor: Patterns? Type families?
16:12:30 <Sonarpulse> is since its base
16:12:34 <Sonarpulse> and Cabal depends on base
16:12:49 <Sonarpulse> it gets confused
16:12:55 <prooftechnique> Oh, that could be
16:12:58 <Lokathor> prooftechnique, hmm. Don't know how those work.
16:13:03 <Lokathor> Guess they'll be a "todo"
16:13:31 <prooftechnique> Also imports, arguably. Depends what you're trying to do
16:13:54 <Sonarpulse> well Setup.hs doesn't import anything their directly
16:13:58 <Sonarpulse> only transitively
16:14:03 <prooftechnique> Oh, no, sorry that was for Lokathor 
16:14:38 <Sonarpulse> err wait!
16:14:40 <Sonarpulse> prelude!
16:14:41 <Lokathor> prooftechnique, imports, yes, I thought about that, but I think i'll leave it off for now. Or at least, that would be a different data type
16:14:45 <Sonarpulse> imma try no implicit prelude
16:16:31 <Sonarpulse> prooftechnique: hahaha that did it
16:16:56 <Sonarpulse> prooftechnique: thanks!
16:18:11 <Lokathor> prooftechnique, http://lpaste.net/152555 I think something like this is what I want. I'm making a program that scrapes for basically all the function info
16:30:35 <sindriava> What does "cabal-helper: needed (<0.7 && >=0.6.3.0), 0.6.0.0 found (latest applicable is 0.6.3.1)" Mean?
16:30:48 <sindriava> I'm trying to install ghc-mod through stack, but with no luck
16:31:08 <sindriava> If latest applicable is 0.6.3.1, why doesn't stack install it?
16:31:20 <sindriava> I can't even remember the last time stack install worked normally tbh
16:51:44 <mgsloan> sindriava: That means that ghc-mod requires a different cabal-helper, than the one that's in your stack.yaml configuration 
16:52:08 <mgsloan> If stack install isn't working normally for you, then you are probably confused about what it means
16:52:16 <mgsloan> I suggest taking a look at the docs
16:52:40 <destsk> What's the best way to recurse through a list xs so that I can work on pairs (xs1,xs2) such that xs1 ++ xs2 = xs?
16:53:15 <destsk> So basically for a list of length n I'd like to work on n-1 separate cases
16:53:22 <destsk> Is there a good functional way to do that?
16:54:09 <mgsloan> Ah, I see that sindriava left.. Why ask a question if you're just going to bail, argh
16:54:36 * mgsloan guesses the demonstrated impatience is related to the issues they're encountering 
16:56:35 <mgsloan> destsk: (zip (inits xs) (tails xs))
16:57:32 <srpx> that's cool
16:57:32 <destsk> mgsloan: thanks! just what I was looking for
16:57:49 <srpx> > (\ x -> (zip (inits xs) (tails xs)) $ [1..6]
16:57:51 <lambdabot>  <hint>:1:45:
16:57:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:58:02 <srpx> > (\ x -> zip (inits xs) (tails xs)) $ [1..6]
16:58:04 <lambdabot>      Not in scope: ‘xs’
16:58:04 <lambdabot>      Perhaps you meant one of these:
16:58:04 <lambdabot>        ‘x’ (line 1), ‘x’ (imported from Debug.SimpleReflect),
16:58:10 <srpx> > (\ xs -> zip (inits xs) (tails xs)) $ [1..6]
16:58:11 <lambdabot>  [([],[1,2,3,4,5,6]),([1],[2,3,4,5,6]),([1,2],[3,4,5,6]),([1,2,3],[4,5,6]),([...
16:59:08 <srpx> I don't understand why people prefer loops
16:59:39 <srpx> just look at that, it is beautiful
17:07:15 <prooftechnique> > (\xs -> uncurry zip . (inits &&& tails)) [1..6]
17:07:17 <lambdabot>      No instance for (Typeable a0)
17:07:17 <lambdabot>        arising from a use of ‘show_M115168511695665637211938’
17:07:17 <lambdabot>      In the expression:
17:07:30 <prooftechnique> @let pairs = uncurry zip . (inits &&& tails)
17:07:31 <lambdabot>  Defined.
17:07:36 <prooftechnique> > L.pairs [1..6]
17:07:38 <lambdabot>  [([],[1,2,3,4,5,6]),([1],[2,3,4,5,6]),([1,2],[3,4,5,6]),([1,2,3],[4,5,6]),([...
17:19:34 <sm> wow, ghcid is awesome
18:00:13 <Pamelloes> If I have a custom enum, what do I need to do to be able to use the X..Y syntax?
18:01:36 <Cale> Just use it? It's the instance of Enum which is required for that.
18:02:12 <Pamelloes> Huh, I wonder why I'm getting a Not in scope error
18:02:33 <Cale> Try putting spaces between X and .. and Y
18:02:33 <geekosaur> @paste actual code?
18:02:34 <lambdabot> Haskell pastebin: http://lpaste.net/
18:02:38 <geekosaur> (also beware... tha)
18:02:41 <geekosaur> *that
18:02:46 <Cale> and make sure you have square brackets around it of course
18:02:59 <geekosaur> . means too many things in Haskell...
18:03:15 <Pamelloes> Adding the space between X and .. fixed it :)
18:04:15 <Cale> Pamelloes: So the problem was that it was parsing X as a module name, and X.. as the infix operator (.) defined in module X
18:06:00 <leksahcon_> 91
18:06:08 <c_wraith> Pamelloes: beware of nested module disambiguation rules
18:07:04 <KaneTW> anyone here planning to go to icfp16 from europe?
18:14:22 <montanonic> Any recommendations for learning about Free Monads? I've been reading a lot of stuff about them but I haven't found any in-depth piece that starts from the beginning; everything has just assumed familiarity.
18:17:04 <peddie> montanonic: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
18:17:23 <montanonic> peddie: perfect; thanks! 
18:21:55 <Gentilhomme> is monads a way to compose wrappings without having to work in the wrapping space directly?
18:29:08 <montanonic> Gentilhomme: If you want an oversimplified way to conceptualize how many Monads work, think of the Monad as some computational context, and the >>= (or Bind operation) as a way to *sequence* computations through that context. The Maybe type has a Monad instance that allows you to perform computations that may fail (resulting in Nothing) and thread those results to other computations that may fail. If at any point one of those co
18:29:08 <montanonic> mputations fail, the *whole* computation inside the Monad fails.
18:38:38 <zd234> https://wiki.haskell.org/GHC/Type_families <-- what to read after that? I need to learn mor eabout how to implement things like CTRex / Vinyl
18:44:07 <benzrf> haskellforall is all very well
18:44:12 <benzrf> but when will we have haskellexists?
18:44:41 <montanonic> zd234: https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html; he covers a lot of type extensions in that series as well
18:45:01 <montanonic> (sorry if that's too brief and simplified; I found the repetition useful though)
18:46:19 <zd234> montanoic: printing it now; thanks!
18:48:50 <synergistics> Are function types not concrete?
18:50:16 <hodapp> 'concrete' in what sense?
18:50:30 <synergistics> *
18:51:30 <geekosaur> :k map
18:51:31 <lambdabot>     Not in scope: type variable ‘map’
18:51:32 <lambdabot>     Perhaps you meant type constructor or class ‘M.Map’ (imported from Data.Map)
18:51:39 <geekosaur> whoops, right
18:51:49 <geekosaur> but th fact that I can pass map around as a value means it is kind *
18:52:03 <geekosaur> likewise (+1) etc.
18:52:46 <geekosaur> :k (->)
18:52:47 <lambdabot> * -> * -> *
18:53:16 <synergistics> So does that mean (* -> *) is of type (*) itself?
18:53:31 <synergistics> Wait no, that's for constructors
18:53:42 <geekosaur> you're confusing type level and kind level, perhaps
18:53:51 <synergistics> Yes, I think so
18:54:09 <synergistics> (*) is a kind
18:54:28 <geekosaur> (+1) has kind * but type (pretending for a moment that types work like kinds) (* -> *)
18:54:32 <xnil> :t (->)
18:54:33 <lambdabot> parse error on input ‘->’
18:54:48 <synergistics> Yea
18:54:49 <xnil> i was not aware that (->) had a kind.
18:54:51 <xnil> that's interesting.
18:55:04 <xnil> thought it was just a syntactic construct
18:55:13 <geekosaur> xnil, that's (->) as used in a type signature
18:55:19 <xnil> yes
18:55:28 <synergistics> :k (::)
18:55:29 <lambdabot> parse error on input ‘::’
18:55:33 <synergistics> Aww
18:55:40 <xnil> synergistics: that's what i expected for (->)
18:55:49 <xnil> though (->) having a kind makes perfect sense
18:56:01 <xnil> geekosaur: thanks for showing that.
18:56:50 <geekosaur> there was actually a discussion of that earlier. (::) is currently syntax, because it is a bunch of different things, few of which can be captured by types or kinds or sorts or ...
18:57:08 <geekosaur> (and more are coming; there's some stuff about :: as a section that didn't make 8.0.1)
18:57:32 <synergistics> So in words, does (->) take two types and return a new one?
18:57:44 <geekosaur> in a type signaure, yes
18:57:48 <synergistics> Ok
18:58:05 <geekosaur> this is distinct from the use in case or lambdas, where it is purely syntax
18:58:50 <synergistics> Yea, and the (->) in a kind signature is also?
18:58:57 <synergistics> Since (->) has a kind
18:59:48 <synergistics> I'm saying it's also distinct
18:59:50 <geekosaur> in a kind signature, it would have to be an sort-level operator. which means it ends up being syntax, because ghc doesn't know about sort-level operators
19:00:08 <geekosaur> values have types, types have kinds, kinds have sorts
19:00:14 <synergistics> Whoa
19:00:42 <synergistics> I'm confused by that: what's defined by ghc and what's defined by Haskell?
19:00:46 <geekosaur> Tim Sheard's Ωmega language can keep that up forever, with the same language at each level
19:01:05 <xnil> synergistics: look at haskell 2010 page
19:01:07 <xnil> paper*
19:01:19 <geekosaur> standard Haskell doesn't know about anything above the level of types
19:02:38 <synergistics> xnil: The language report?
19:03:37 <xnil> sureynot
19:08:51 <synergistics> geekosaur: Funny, just got to the part in Learn You a Haskell talking about the Functor instance for ((->) r)
19:10:44 <geekosaur> partially applied type constructor (which is completed by the type parameter for Functor). as far as standard Haskell is concerned, that's the end of it
19:21:21 <leksahcon_> Haskell beginner here, should I be using stack?
19:21:38 <leksahcon_> If so, why?
19:22:11 <silky-nvds> leksahcon_: probaboyl, yes. it's good for starting new projects and libraries
19:22:26 <silky-nvds> leksahcon_: but if it's your first time using haskell, it probs generates a bit of overhead that is confusing
19:22:49 <silky-nvds> leksahcon_: one way to have some fun for free is ihaskell+docker - https://github.com/gibiansky/IHaskell
19:23:05 <tommd> leksahcon_: If you are a beginner in the sense of writing hello world and other self-contained haskell programs/moduels then no.
19:23:45 <tommd> leksahcon_: If you are building a full project/package that spans modules and/or has non-trivial dependencies then yes using cabal and perhaps stack is sensible.
19:24:53 <leksahcon_> Considering "I'm the beginner writing hello world moduels" where to start?
19:25:29 <kadoban> leksahcon_: You should still use stack, though a pretty limited subset of it. It's still the easiest way to just get GHC installed and do stuff without it blowing up in your face later.
19:25:30 <leksahcon_> wouldn't cabal and stack put me on the correct path?
19:25:41 <silky-nvds> leksahcon_: i vote start with stack.
19:26:14 <kadoban> leksahcon_: cabal-install and stack are separate tools, stack is the one you want.
19:26:38 <leksahcon_> ok thanks
19:27:07 <leksahcon_> does stack do away with cabal hell?  A term I've read numerous times.
19:27:27 <silky-nvds> leksahcon_: no, it doesn't
19:27:37 <silky-nvds> leksahcon_: sorry, cabal hell, yeah, i'd say it does :)
19:27:43 <kadoban> leksahcon_: In the common ways it's used, yes it does.
19:33:20 <davidthomas> There's probably no cleaner way of expressing "foldl' (>=>) pure"?
19:33:24 <davidthomas> (not that that's bad)
19:35:51 <shachaf> Maybe you could invent some clever ala-style trickery for it.
19:42:58 <glguy> foldl' might not be as good as using foldr for this purpose
19:44:33 <glguy> The strict part of foldl' would be strict in the function, not the "accumulated" value
19:44:40 <glguy> foldr (>=>) pure (repeat (\x -> print x >> return (x+1))) 0
19:44:50 <glguy> while something like this would be able to perform the side-effect early
19:45:07 <glguy> while the foldl' version of that would just spin looking for the end of the list
19:47:04 <leksahcon_> so as a beginner, first things first, remove haskell-platform?
19:48:23 <davidthomas> glguy: good point
19:49:00 <davidthomas> list is small (<10 elements, for sure) so I'd postponed any consideration of which fold :p
19:53:50 * hackagebot courier 0.1.1.2 - A message-passing library for simplifying network applications  https://hackage.haskell.org/package/courier-0.1.1.2 (PhilHargett)
19:55:56 <synergistics> Is it right to say that Maybe is a functor because the constructor maps types to maybe types and it's fmap definition maps morphisms to morphisms that work on Maybe objects?
19:58:34 <shachaf> Yes, that's what people mean.
20:00:12 <synergistics> So without even being an instance of Functor, a type constructor satisfies half of the functor definition (i.e. it maps objects to (some type constructor) objects)
20:01:12 <shachaf> Yes, but it's not the important half.
20:01:23 <shachaf> You can define functors without talking about that half at all.
20:02:07 <synergistics> How so?
20:02:28 <shachaf> By just talking about the arrow-mapping bit.
20:02:53 <shachaf> Since fmap id = id, the object-mapping bit is implied.
20:03:09 <shachaf> If you like, you can also define categories without talking about objects.
20:03:15 <KaneTW> yeah i was about to say that
20:03:20 <shachaf> And natural transformations and so on.
20:03:25 <KaneTW> you don't really need explicit objects when talking about categories
20:03:28 <KaneTW> identities are fine
20:04:12 <synergistics> Does not needing objects have to do with the "an object can be defined by knowing all the arrows mapping to and from it"
20:04:39 <shachaf> No, objects are an illusion in the first place.
20:04:55 <shachaf> They're a convenience so that the arrows can have domains and codomains.
20:05:45 <synergistics> What is an arrow without domains and codomains? If you didn't have explicit objects, wouldn't you still have to define them abstractly to talk about a morphism?
20:06:05 <shachaf> Well, they're implied in some sense.
20:06:19 <shachaf> You can't multiply any arrow by any arrow.
20:06:45 <synergistics> How are they implied?
20:06:50 <synergistics> I'm confused on that bit
20:07:19 <shachaf> @google one-sorted category
20:07:20 <lambdabot> https://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
20:20:12 <synergistics> shachaf: Are s(t(x)) and t(s(x)) both the identity morphism?
20:20:43 <shachaf> s(x) and t(x) are both identities.
20:20:57 <shachaf> If x : A -> B, s(x) = 1_A, and t(x) = 1_B
20:20:58 <rpglover64> I'm having some issues with running liquidhaskell using `stack exec`.
20:21:28 <synergistics> shachaf: I got that, but I didn't see how s and t are themselves identities
20:21:32 <rpglover64> MyModule.hs:6:22-27: Error: GHC Error     Module ‘Data.List’ does not export ‘foldl'’
20:21:50 <shachaf> They aren't.
20:21:52 <rpglover64> which makes no sense to me
20:21:58 <shachaf> s and t aren't even in C.
20:21:59 <synergistics> shachaf: Oh, good
20:23:33 <synergistics> shachaf: But they operate on C or morphisms in C, or are those the same thing?
20:23:59 <shachaf> C is a collection of arrows.
20:24:07 <shachaf> Or morphisms or elements or whatever you want to call them.
20:24:31 <synergistics> yea, but what is x in s(x). It's an element in C, right?
20:24:31 <rpglover64> (I do have an "import Data.List (foldl')" line in my file)
20:27:55 <shachaf> Yes.
20:28:50 <tommd> rpglover64: You misunderstand the error.  It is telling you that Data.List does not define the function foldl', not that you aren't importing it.
20:29:05 <rpglover64> But Data.List does define foldl'
20:29:13 <tommd> rpglover64: Which isn't true for any distributed module named Data.List I know.
20:29:17 <tommd> Yes agreed.
20:29:30 <rpglover64> The error points to the import line
20:29:35 <tommd> rpglover64: So, do you have something in a Data directory called List.hs?
20:29:41 <rpglover64> no
20:29:43 <tommd> rpglover64: Yes I get that.
20:29:54 <synergistics> shachaf: Sorry, was that to me? I accidentally quit earlier
20:30:01 <shachaf> Yes.
20:30:13 <jle`> rpglover64: what happens if you just imported Data.List?
20:30:18 <synergistics> shachaf: Sorry, was that to me? Just kidding
20:30:22 <shachaf> You didn't miss anything. But there's a link to the logs in the channel topic, if you want to make sure.
20:30:46 <synergistics> shachaf: Ah, thanks
20:30:55 <tommd> rpglover64: If you use ghci and `import Data.List` then `:type foldl'` what does it say?  From the same directory as you are compiling in, mind.
20:30:57 <rpglover64> jle`: error moves to use site: "Not in scope"
20:31:12 <jle`> referring to foldl' ?
20:31:13 <tommd> How are you compiling the code anyway?
20:31:14 <rpglover64> tommd: it gives me the type of foldl'
20:31:26 <rpglover64> stack exec -- liquid MyModule.hs
20:31:36 <rpglover64> jle`: yes
20:31:39 <jle`> hm, maybe try using the foldl' from Data.Foldable ?
20:31:39 <tommd> Ahh, liquid haskell?
20:31:41 <Axman6> that doesn't look right
20:31:58 <Axman6> at the very least, it should be stack exec liquid -- MyModule.hs
20:32:09 <Axman6> afaik anyway
20:32:34 <mgsloan> Either is fine
20:33:03 <Axman6> really? that's kinda gross =)
20:33:16 <tommd> I've happily used either before too.
20:34:17 <tommd> Makes me wonder what stack + liquid does in some cases.
20:35:40 <mgsloan> I don't know very much about liquid haskell, but I do know about stack.  So the ghci started by "stack exec ghci" gives the type of Data.List.foldl' ?
20:36:04 <mgsloan> AFAIK no version of Data.List ever lacked foldl', so I have no idea what's going on there, seems quite bizarre
20:36:16 <rpglover64> mgsloan: yes
20:36:28 <tommd> Yeah, liquid is the most suspicious thing here right now.
20:36:36 <rpglover64> I'm guessing liquid is failing to actually import the module
20:36:39 <rpglover64> somehow
20:36:57 <tommd> Perhaps the stack-ghc and library paths aren't being communicated.
20:37:53 <rpglover64> `stack exec env` seems to suggest that they are
20:38:33 <rpglover64> and the whole reason I started running `stack liquid` instead of bare `liquid` was to get access to `Data.Vector` (and it doesn't complain about missing the module)
20:38:47 <jle`> maybe try asking on the mailing list?
20:38:49 <jle`> it's fairly active
20:38:52 <tommd> Indeed, I can reproduce the issue using liquid.
20:38:58 <tommd> (and stack)
20:39:01 <rpglover64> That might be relevant; the behavior is the same for `Data.Vector`
20:39:10 <tommd> Using Liquid alone works fine.
20:41:24 <synergistics> shachaf: What does the "C x C" in (.) : C x C -> C mean
20:42:00 <shachaf> Cartesian product.
20:42:31 <jle`> `C x C` can be thought of as the collection whose elements are pairs of elements in C
20:42:40 <jle`> like (C, C) -> C in haskell-speak, roughly
20:42:45 <jle`> ordered pairs
20:43:08 <rpglover64> tommd: For reference, stracing confirms that it's finding the right interface files.
20:43:17 <synergistics> jle': Or combinations in some other sense possibly?
20:43:48 <jle`> you can just think of it as saying that (.) takes two items in C and returns another item in C
20:44:04 <jle`> like + : R x R -> R
20:44:09 <tommd> rpglover64: OTOH, the "Module Imports:" output (--verbose) isn't present in the failing run with stack exec.
20:44:14 <tommd> It is there with just liquid.
20:44:58 <rpglover64> tommd: I think I'll file an issue on github and see where things go from there.
20:45:06 <synergistics> jle`: So it's specifying a morphism that takes multiple objects as input?
20:45:27 <jle`> i'd call it just a function
20:45:42 <jle`> to prevent some confusion
20:45:53 <tommd> Just (a -> b)?
20:46:01 <jle`> :P
20:46:02 <synergistics> Since a morphism takes just one object?
20:46:18 <jle`> no, since the word "morphism" is used to describe elements in C
20:46:25 <synergistics> jle`: Oh, ok
20:47:39 <jle`> it's a function in the traditional sense of the word -- it assigns inputs to outputs.  the inputs here are pairs of elements in C, and the outputs are elements in C
20:48:54 <synergistics> jle': Any reason (.) couldn't just be defined as (.) : C -> C -> C?
20:49:20 <prooftechnique> :t (.)
20:49:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:49:27 <prooftechnique> Er, (.) :: Category cat => cat b c -> cat a b -> cat a c
20:49:30 <prooftechnique> It's kinda close
20:50:43 <synergistics> I was talking specifically about two arrows instead of Cartesian product
20:50:52 <Pamelloes> I see System.Random has functions for getting one random number at a time or an infinite number, but is there a good way to just get 10 random numbers and the generator after generating them?
20:50:54 <jle`> i don't think so, but it's not really conventional
20:51:22 <synergistics> jle`: Just making sure
20:51:42 <prooftechnique> Pamelloes: take 10 randoms?
20:51:50 <jle`> Pamelloes: you can split first and then take 10, i guess
20:52:00 <jle`> or replicateM with State/Rand
20:52:27 <Pamelloes> jle`: What does splitting do?
20:52:36 <jle`> g -> (g, g)
20:52:39 <prooftechnique> :t splitAt
20:52:40 <lambdabot> Int -> [a] -> ([a], [a])
20:52:44 <prooftechnique> :t split
20:52:45 <lambdabot> Splitter a -> [a] -> [[a]]
20:52:57 <jle`> it makes two "independent" new generators from an old generator
20:53:03 <Pamelloes> huh..
20:53:08 <jle`> or you can think of it as a way of randomly generating a generator
20:53:21 <prooftechnique> :t System.Random.split
20:53:22 <lambdabot> RandomGen g => g -> (g, g)
20:53:23 <prooftechnique> There we go
20:53:28 <jle`> it's not exactly the most cryptographically sound operation, but it's suitable for most randomness applications i think
20:53:36 <exio4> @type \r n -> runState $ replicateM n (state (randomR r))
20:53:37 <lambdabot> (RandomGen s, Random a) => (a, a) -> Int -> s -> ([a], s)
20:53:58 <jle`> but, using Rand from MonadRandom is nice if you're planning on chaining more non-trivial generators like this
20:54:02 <jle`> or chaining them in non-trivial ways
20:54:29 <jle`> > runState (replicateM 10 (state random)) (mkStdGen 10) :: ([Double], StdGen)
20:54:31 <lambdabot>  ([0.9411121095656491,0.38022658385886665,0.6880194990342998,0.45347134400258...
20:54:48 <prooftechnique> > runState (replicateM 10 (state random)) (mkStdGen 2) :: ([Double], StdGen)
20:54:49 <lambdabot>  ([0.17372420460863047,0.7322089110734834,0.1812545530369175,0.79100477643703...
20:54:54 <prooftechnique> Whoops, wrong change
20:54:57 <prooftechnique> > runState (replicateM 2 (state random)) (mkStdGen 10) :: ([Double], StdGen)
20:54:58 <lambdabot>  ([0.9411121095656491,0.38022658385886665],1928412403 1780294415)
20:55:05 <prooftechnique> Just to see the generator
20:55:07 <synergistics> shachaf: Thanks for linking the nLab page, really cleared things up
20:56:00 <Pamelloes> Rand looks promising
20:56:35 <Pamelloes> I think I'll go with that since I can tell things are going to quickly spiral out of control if I don't.
20:57:41 <jle`> with rand it'd just be replicateM :: Int -> Rand g a -> Rand g [a]
20:58:07 <jle`> so replicateM 10 rand :: Rand g [a], would generate 10 a's
20:58:14 <jle`> er, replicateM 10 getRandom
20:59:54 <irmoathlete> I don't want to be "that guy", but currently I use java, python, javascript, html, css, and various libraries and frameworks associated with a range of those. The question I have and I'm sure you dislike it and get it a lot is: "Should I bother learning Haskell?"
21:00:07 <jle`> i think so :)
21:00:14 <silky-nvds> irmoathlete: if you want to
21:00:29 <prooftechnique> Haskell will at least be new
21:00:34 <irmoathlete> from what I've read, by learning it, it will help expand your functional programming skills that will carry over into your other languages.
21:00:50 <jle`> that's a common thing people say
21:00:52 <silky-nvds> irmoathlete: it's also just fun
21:01:10 <prooftechnique> I certainly write very different Python, Java, and JS since learning Haskell
21:01:11 <irmoathlete> a down side I've heard is "you'll never use it commercially or professionally", so I thought I'd jump in here and ask lol
21:01:16 <prooftechnique> Even different PHP
21:01:16 <jle`> but a big benefit for me is that learning haskell has enabled me to actually use Haskell
21:01:27 <jle`> which is an awesome language great for real-world applications in and of itself
21:01:41 <dmj> irmoathlete: facebook has "hundreds of thousands" of lines of haskell, it's used comercially
21:01:51 <dmj> commercially*
21:01:57 <irmoathlete> ok cool, so that was probably a misconception I read
21:02:28 <prooftechnique> It depends on the jobs you apply for. :)
21:02:28 <irmoathlete> I want to constantly learn new things, and I also want to write better javascript
21:02:39 <nitrix> I think it's wrong to want something to "be used comercially" before "using it comercially". It creates a catch-22.
21:02:50 <dmj> irmoathlete: the best javascript is no javascript at all :]
21:02:58 <jle`> a lot of people try to sell the haskell-will-make-you-a-better-programmer-and-expand-your-mind thing, which is probably true, but for me the biggest benefit has been learning it has let me actually use it :)
21:03:05 <nitrix> Haskell has a lot of benefits to bring on the table and if those speaks to you, then go ahead. You don't need other reasons.
21:03:15 <prooftechnique> Especially when it *is* used commercially, just not as much as $LANG
21:03:56 <irmoathlete> are there any exceptional sites/docs that you recommend outside of the site itself?
21:04:01 <prooftechnique> I'd recommend Advent of Code for some fun problems to do in Haskell
21:04:22 <prooftechnique> Very slightly more practical than the usual Project Euler
21:04:36 <jle`> what site are you talking about?
21:04:44 <irmoathlete> the haskell.org site
21:05:08 <prooftechnique> @where hoogle
21:05:08 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
21:05:12 <prooftechnique> @where hackage
21:05:12 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
21:05:16 <prooftechnique> @where hayoo
21:05:16 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
21:05:18 <cstrahan> are there any other Washington, D.C. peeps here?
21:05:36 <irmoathlete> thanks guys, very informative. Thank you for excusing my ignorance xD
21:05:40 <prooftechnique> Oh, I didn't realize Hoogle and Hayoo crosslinked :D
21:06:08 <prooftechnique> irmoathlete: Also, hundreds of blog posts. And then there's FPComplete's articles
21:06:47 <prooftechnique> http://www.haskellforall.com is usually good for a neat idea or two
21:07:12 <prooftechnique> And https://themonadreader.wordpress.com
21:07:34 <prooftechnique> And http://blog.ezyang.com
21:08:49 <cstrahan> irmoathlete: I have a background in C#/Ruby/Clojure, and picked up Haskell just about 2 years ago. I think it's been both a ton of fun and rather enlightening.
21:09:18 <irmoathlete> cstrahan, thanks for the insight, it sounds like something that will be fun and useful to learn.
21:10:47 <jle`> irmoathlete: for learning, there are some great resources
21:10:50 <jle`> @where learnhaskell
21:10:50 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:10:52 <jle`> @where haskellbook
21:10:52 <lambdabot> I know nothing about haskellbook.
21:10:54 <jle`> aw
21:11:32 <irmoathlete> excuse my ignorance again lol, what is @where
21:12:30 <geekosaur> it's lambdabot's knowledgebase
21:12:50 <prooftechnique> @remember haskellbook http://haskellbook.com
21:12:50 <lambdabot> I will never forget.
21:12:56 <prooftechnique> @where haskellbook
21:12:56 <lambdabot> I know nothing about haskellbook.
21:13:00 <prooftechnique> :|
21:13:04 <cstrahan> lol
21:13:06 <prooftechnique> Oh, wait
21:13:08 <geekosaur> that was for @quote not @where
21:13:13 <geekosaur> you wanted @where+
21:13:18 <prooftechnique> @where+ haskellbook  http://haskellbook.com
21:13:18 <lambdabot> Good to know.
21:13:23 <prooftechnique> Right, I always forget
21:13:26 <prooftechnique> @where haskellbook
21:13:27 <lambdabot> http://haskellbook.com
21:13:27 <geekosaur> @forget haskellbook http://haskellbook.com
21:13:28 <lambdabot> Done.
21:13:28 <prooftechnique> There
21:13:50 <irmoathlete> @where haskellbook
21:13:51 <lambdabot> http://haskellbook.com
21:13:51 <kadoban> "I will neven forget." "I forgot" :(
21:13:55 <irmoathlete> oooooh ok
21:14:01 <irmoathlete> thank you lmao
21:14:27 <prooftechnique> It's thoroughly worth the money
21:14:58 <prooftechnique> Even in the first few chapters I hit some good info that hadn't dawned on me despite using Haskell for quite some time
21:16:56 <geekosaur> it was worse when there was also @fact >.>
21:19:40 <Pamelloes> If I have [a -> b] and [a] can I combine them to get [b] such that each function is applied just to the value at its corresponding position? <*> applies each function to each value
21:20:20 <geekosaur> :t zipWith ($)
21:20:21 <lambdabot> [a -> c] -> [a] -> [c]
21:20:47 <felixjet> hiya!
21:20:52 <Pamelloes> Awesome!
21:22:01 <felixjet> i probably shouldn't ask this here, but if someone can help would be great. i want to use pandoc on arch linux, but there are 2 packages, "haskell-pandoc" (which depends on "pandoc") and "pandoc", anyone know why 2 packages or the differences?
21:25:56 <geekosaur> looks like pandoc is just the program; haskell-pandoc is the libraries and API documentation
21:27:18 <geekosaur> (apparently done to keep the size down; ach doesn't normally do the devel libs split that fedora/rhel and debianoids do)
21:28:17 <prooftechnique> Debianoid is an exceptionally cromulent word
21:37:55 <`Guest00000> are there any libraries which do thunk manipulation?
21:38:54 <`Guest00000> one would allow me to write (f :: Int -> IO String), where f (5 + 5) ==> "5+5" and f 10 ==> "10"
21:39:46 <geekosaur> I don't think so. but libraries wouldn't help there, I suspect
21:40:34 <kadoban> Sounds vaguely like maybe ghc-vis might be something you're interested in, but I'm not sure.
21:41:01 <geekosaur> at runtime (which is when a library would be able to do anything) you do no have names for functions or operators
21:41:25 <prooftechnique> Maybe ghc-exactprint?
21:42:45 <geekosaur> IIRC that deconstructs an AST and relies on recentish (7.8+ I think) ghc including source location information for AST nodes
21:43:03 <prooftechnique> Hmm. Maybe some HSE hackery?
21:44:33 <`Guest00000> geekosaur: so, that function could be unable to discern different functions (so f (5 * 5) ==> "5+5")
21:45:30 <geekosaur> at runtime a function is just a pointer. there isn't even type information available
21:47:50 <geekosaur> worse, if the compiler could determine which Num instance was being used, the pointer will be to the implementation of (*) for that instance, not the actual (*) that looks up the necessary instance in the passed class dictionary
21:49:34 <geekosaur> (or (+), etc.)
21:50:00 <geekosaur> and then there's the question of what (+1) gives you. or (\x -> x + 1)
21:51:51 <geekosaur> a decae ago there was a thing called hat, which did this by instrumenting code. it bitrotted long ago, and the way it did its instrumentation was incompatible with many of the standard modules
21:53:57 * hackagebot werewolf 0.4.0.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.0.1 (hjwylde)
21:53:59 * hackagebot werewolf 0.4.1.3 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.1.3 (hjwylde)
21:54:41 <geekosaur> I think if I wanted to do this with modern ghc, I'd be looking at the new plugins mechanism
21:55:35 <geekosaur> but there would probably be a runtime price to pay for carrying around the extra information so you could reconstruct function names
21:55:52 <geekosaur> on the other hand, maybe you can do something with
21:55:58 <geekosaur> @hackage simple-reflect
21:55:58 <lambdabot> http://hackage.haskell.org/package/simple-reflect
21:56:23 <geekosaur> > foldr f z [0..4]
21:56:25 <lambdabot>  f 0 (f 1 (f 2 (f 3 (f 4 z))))
21:58:59 * hackagebot werewolf 0.4.2.3 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.2.3 (hjwylde)
21:59:01 * hackagebot werewolf 0.4.5.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.5.0 (hjwylde)
21:59:03 * hackagebot werewolf 0.4.4.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.4.1 (hjwylde)
21:59:05 * hackagebot werewolf 0.4.3.2 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.3.2 (hjwylde)
23:00:30 <none> msg chanserv
23:00:41 <none> msg chanserv help
23:00:47 <mniip> /
23:04:50 <irmoathlete> do you guys mind if I ask a non haskell question, just because every other room I'm in nobody can really shed any insight on what I'm asking? 
23:05:08 <irmoathlete> any ideas on how to go about getting peer/code review for a small project I'm working on?
23:05:34 <peddie> irmoathlete: there is a code review stackexchange
23:06:21 <irmoathlete> @peddie have you ever used it or heard of any problems such as bad advice etc?
23:06:21 <lambdabot> Unknown command, try @list
23:06:44 <irmoathlete> peddie, have you ever used it or heard of any problems such as bad advice etc?
23:06:47 <silky-nvds> irmoathlete: a more outlandish way could be to try programming whilst on this site - https://www.livecoding.tv/
23:06:56 <silky-nvds> irmoathlete: then if people watch, they could give you feedback :)
23:08:02 <irmoathlete> silky-nvds see my only problem with that is great developers are usually coding or on forums etc xD, it's usually the lower echelon developers watching those things, and I could be very wrong, just my outlook.
23:09:08 <peddie> irmoathlete: I haven't used it, but it seems like if you've already written the code, it's probably worth a shot
23:09:23 <irmoathlete> peddie, with the code review stack exchange isn't it a question/answer based site?
23:11:15 <peddie> irmoathlete: https://codereview.stackexchange.com/ the first one I see seems like just a regular request for feedback
23:24:48 <irmoathlete> DC'd sorry, thank you for the help peddie.
23:26:35 <peddie> no prob
23:27:43 <irmoathlete> Also, I joined one of their chats associated with code review, thanks again. 
23:53:23 <gfixler> Alright, #haskell, you're right. You win.
23:53:50 <gfixler> Monads in Haskell aren't like anything. They're a typeclass and some laws.
23:54:23 <gfixler> things that are monads in Haskell fulfill the types, and obey the laws, the end
23:57:15 <jle`> well
23:57:17 <Jinxit> here we go again
23:57:24 <gfixler> :)
23:57:25 <jle`> monads can be like many things
23:57:29 <gfixler> I can't resist
23:57:30 <thimoteus> like burritos!
23:57:30 <jle`> but "Monad" is, yeah
23:57:35 <jle`> s, s/Monads/Monad
23:57:39 <jle`> *so
23:57:48 <gfixler> Monad because it was the first word in the sentence
23:58:06 <gfixler> but I see
23:58:18 <jle`> things that are monads in haskell can do a lot more things than just fulfill the types and obey the laws
23:58:20 <jle`> :P
23:58:49 <gfixler> some people just want to watch the world burn
23:59:55 <gfixler> is there a #haskell-nopedantry?
