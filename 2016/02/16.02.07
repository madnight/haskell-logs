00:01:48 * hackagebot hcoap 0.1.0.0 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.0.0 (lulf)
00:07:38 * hackagebot rebase 0.3.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.3.2 (NikitaVolkov)
00:07:38 * hackagebot hcoap 0.1.0.0 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.0.0 (lulf)
00:17:32 * hackagebot rebase 0.4 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.4 (NikitaVolkov)
00:52:21 <NZKindest> hail thee what news
00:59:19 <average> NZKindest: what news ?
01:01:54 <NZKindest> News from New Zealand
01:04:23 <NZKindest> squawk
01:21:10 <tsahyt> Do the semantics of the monad instance for Vector differ from those for lists?
01:21:34 <mniip> yes
01:22:03 <mniip> they're closer to that of ZipList
01:22:44 * hackagebot hcoap 0.1.0.1 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.0.1 (lulf)
01:22:54 <tsahyt> so I can't use a do block with guard for a "vector comprehension"?
01:23:19 <mniip> if the vector has a length encoded in its type
01:23:28 <bitemyapp> Lokathor: what'll really bake your noodle is `whois monadtutorial.com`
01:23:41 <mniip> then the whole do-block operates over vectors of that length
01:24:00 <tsahyt> mniip: Data.Vector can have a length encoded in its type?
01:24:09 <jle`> tsahyt: i don't think you can use guard, there really isn't a MonadPlus/Alternative instance i can think of
01:24:27 <jle`> Data.Vector can't, there's a wrapper over Data.Vector in the `linear` library that does
01:24:34 <tsahyt> jle`: According to the docs for Data.Vector it is an instance of MonadPlus though
01:24:43 <jle`> `V n Double` is a Vector Double that has n Doubles
01:24:49 <jle`> ah
01:25:00 <tsahyt> well anyhow, that might explain why this code doesn't do what I think it should be doing
01:25:00 <jle`> okay, you're talking about Data.Vector vectors
01:25:15 <bitemyapp> this is like talking to anglos in new york
01:25:16 <jle`> Data.Vector vectors should have a Monad instance that's similar to that of lists
01:25:22 <bitemyapp> "OHHHHHH you mean the Smith Smiths!"
01:25:31 <bitemyapp> "The Connecticuit Smiths riiiiight?!"
01:25:33 <jle`> haskell life v.v
01:25:36 <mniip> are "Data.Vector vectors" just lists with fancy functions?
01:26:09 <jle`> Data.Vector vectors are represented as contiguous memory chunks of stuff
01:26:13 <jle`> like vectors in other languages
01:26:25 <jle`> so they aren't like linked lists, but they have variable size...so they should have the same Monad instance
01:26:49 <jle`> (Data.Vector vectors are just wrappers over Array)
01:27:11 <tsahyt> time for some testing, this bug is getting weirder
01:27:23 <jle`> tsahyt: so yeah, just checked, x >>= f for Vector is V.concatMap f x
01:27:43 <jle`> but you'll get some different behavior for specific cases, because infinite vectors don't really work as a thing
01:27:58 <tsahyt> jle`: Everything's finite in my case
01:28:18 <tsahyt> huh yeah, so I just tested a minimal example and it should do what I want
01:28:29 <tsahyt> So the bug must be somewhere else I suppose. Thanks for the help!
01:28:55 <jle`> http://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector.html#instance%20Monad%20Vector
01:30:24 <mniip> mhm
01:30:39 <mniip> jle`, well type theory wise they are naturally isomorphic to lists
01:31:12 <jle`> hm, not haskell lists though, right?
01:31:23 <jle`> you can't write an isomorphism that works when you consider infinite lists
01:32:23 <jle`> you can think of Vector x as 1 + x + x^2 + x^3 + x^4 + ..., this enumeration doesn't include infinite lists
01:32:47 <jle`> (despite including arbitrarily long lists)
01:33:29 <mniip> jle`, but list x = 1/(1-x)
01:33:36 <mniip> which is kinda the same thing
01:34:23 <mniip> well I kinda see the difference though, lots of things start breaking when you introduce bottoms
01:34:46 <jle`> are infinite lists considered bottoms?
01:35:20 <mniip> no but its length is
01:37:15 <jle`> hm.  i'm not sure how really state the idea that lists have an extra class of "member" that vectors don't...but i don't want to invoke the full mess of reasoning with bottoms
01:37:47 <jle`> maybe you can say that List a = Vector a + Stream a
01:38:13 <jle`> but i guess there's a problem with that, in that you can't determine which branch you are on in finite time
01:38:53 <jle`> er, i mean, the check of which case you have is potentially nonterminating
01:39:01 <jle`> weird :|
01:39:46 <jle`> but i feel like there's something simpler here at play, because the Monad, Functor, and Applicative etc. laws for lists are totally true in the presence of infinite lists
01:43:40 <saulzar> They'd be isomorphic to a strict list..
01:44:24 <jle`> that works :)
01:46:06 <mniip> while playing around with a generalization of typeSeq I broke the typechecker :o
01:46:12 <mniip> or so I think
01:46:49 <saulzar> mniip, That 'Force' paste you posted earlier?
01:46:56 <mniip> yes
01:47:12 <lpaste> mniip pasted ‚ÄúForce‚Äù at http://lpaste.net/151831
01:47:44 * hackagebot hcoap 0.1.0.2 - CoAP implementation for Haskell.  https://hackage.haskell.org/package/hcoap-0.1.0.2 (lulf)
01:47:49 <nikola> How can I parse json (using Aeson) containing the following key and value -  "textRU": "\u0422\u0440\u0438\u043c\u0430\u0440\u0430\u043d" . eitherDecode just gives Left "Failed reading: satisfy". Minimal example is at http://lpaste.net/151832
01:48:11 <lpaste> mniip annotated ‚ÄúForce‚Äù with ‚ÄúForce (annotation)‚Äù at http://lpaste.net/151831#a151833
01:49:50 <Lokathor> soon enough bitemyapp will own all possible haskell related URLs
01:50:57 <mniip> ha!
01:51:02 <mniip> not haskell.mniip.com
01:53:24 <Lokathor> % filter (\url -> isHaskellUrl url && notCallenOwned url) (theURLs ^. all)
01:53:27 <pixiebot> []
01:53:48 <mniip> % theURLs
01:53:56 <mniip> :(
01:54:04 <Lokathor> pixiebot can't interpret lines for real :(
01:54:16 <Lokathor> but it helps to have a backer for your antics
01:54:22 <saulzar> mniip, What is that (trying?) to do?
01:54:23 <MarcelineVQ> @echo flimflam
01:54:23 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "MarcelineVQ!~anja@S0106602ad0983de6.no.shawcable.net", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo flimflam"]} target:#haskell rest:"flimflam"
01:54:51 <mniip> saulzar, evaluate type-functions at specific locations
01:54:57 <mniip> see for example
01:55:01 <mniip> :t typeSeq state
01:55:02 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
01:55:06 <mniip> err
01:55:08 <mniip> :t typeSeq mapState
01:55:09 <Lokathor> %transmit PRIVMSG #haskell :wow that's a lot of stuff MarcelineVQ
01:55:09 <pixiebot> wow that's a lot of stuff MarcelineVQ
01:55:10 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
01:55:26 <mniip> doesn't expand the State type synonyms
01:55:29 <saulzar> Oh, I see - the loc thing is like a pointer to some part of the type expression
01:55:30 <mniip> however I can do...
01:55:35 <mniip> :t mapState . typeSeq
01:55:36 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
01:55:42 <mniip> no wait
01:55:52 <mniip> :t \x -> typeSeq (mapState x)
01:55:54 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
01:55:57 <mniip> hrm
01:56:21 <mniip> uh-oh
01:56:29 <mniip> :t \x y -> typeSeq (mapState x y)
01:56:31 <lambdabot> ((a, s) -> (b, s)) -> State s a -> StateT s Identity b
01:56:32 <mniip> there
01:56:38 <Lokathor> bitemyapp, datapoint: after having watched edk's lens video long ago, and then reading your Traversable chapter recently, and then watching his lens video again just now... I feel like I somehow understand lens more but also traversable less.
01:57:58 <saulzar> Ah, that's neat
02:18:01 <tsahyt> How can I pass RTS options to an executable that I run via stack exec? It seems like they get intercepted by stack itself
02:19:31 <MarcelineVQ> `stack exec ./bleh -- +RTS -s` works for me
02:19:50 <tsahyt> ah I was missing the --, thanks!
02:20:16 <MarcelineVQ> np
02:33:48 <koz_> I'm trying to write a type-general mapMaybe using classy-prelude's isSequence typeclass (https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-Sequences.html#t:IsSequence). However, I'm having some trouble with the type signature: I believe it should be 'mapMaybe :: IsSequence seq => (a -> Maybe b) -> seq -> seq', but this doesn't work because seq doesn't know about a or b types. I really
02:33:50 <koz_> want to say that it takes a function, a seq of as, and spits a seq of bs. What am I missing here?
02:38:03 <dramforever> koz_: You need something like (IsSequence s1, IsSequence s2) => (Element s1 -> Maybe (Element s2)) -> s1 -> s2. Element is a type family [1], if you want to know more about them, you can read the ghc users_guide [2]
02:38:05 <dramforever> [1] https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:Element
02:38:11 <dramforever> [2] https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html
02:38:21 <koz_> dramforever: Thanks, I'll read.
02:42:21 <mniip>     ‚Ä¢ No instance for (Show *) arising from a use of ‚Äòprint‚Äô
02:42:24 <mniip> you, what, mate?
02:42:38 <mniip>     ‚Ä¢ No instance for (Show #) arising from a use of ‚Äòprint‚Äô
02:42:41 <mniip> o.O
02:43:06 * hackagebot pdf-toolbox-core 0.0.4.1 - A collection of tools for processing PDF files.  https://hackage.haskell.org/package/pdf-toolbox-core-0.0.4.1 (YurasShumovich)
02:43:08 * hackagebot pdf-toolbox-content 0.0.5.1 - A collection of tools for processing PDF files  https://hackage.haskell.org/package/pdf-toolbox-content-0.0.5.1 (YurasShumovich)
02:43:17 <jle`> mniip: welcome to the world of kind families
02:43:27 <jle`> *kindclasses
02:43:58 <mniip> well, I realize that * :: *
02:44:03 <mniip> but I didn't realize that * :: *
02:45:03 <jle`> wait until you find out that * :: *
02:45:08 <jle`> that'll throw you for a loop
02:45:39 <koz_> There's a few moments of weird type rigidity in classy-prelude, which I'd like to PR away.
02:46:16 <jle`> koz_: well, that sort of comes from the spirit of mono-traversable
02:46:26 <jle`> they're not meant to represent things that can 'change' types
02:46:36 <mniip> jle`, I mean, * :: * means that the kind of types has sort *
02:46:50 <mniip> but * :: * means that * is something of kind *, i.e a concerete type
02:47:56 <jle`> hm, i wonder if you can have values of type Type
02:48:06 <mniip> you can
02:48:06 * hackagebot pdf-toolbox-document 0.0.7.1 - A collection of tools for processing PDF files.  https://hackage.haskell.org/package/pdf-toolbox-document-0.0.7.1 (YurasShumovich)
02:48:12 <mniip> all kinds of bottoms
02:48:14 <mniip> for a start
02:48:17 <jle`> neat
02:48:47 <koz_> jle`: Well, the fact that mapMaybe only works on lists kinda bothers me.
02:48:56 <jle`> koz_: there's the Witherable typeclass
02:48:59 <koz_> Surely any sequence should be game for it.
02:49:00 <jle`> @hackage witherable
02:49:00 <lambdabot> http://hackage.haskell.org/package/witherable
02:49:15 <jle`> sort of, but not necessarily
02:49:24 <jle`> NonEmpty wouldn't be able to implement it
02:49:35 <jle`> fixed-length vectors
02:49:46 <jle`> a lot of things people would normally consider a sequence-like thing
02:50:16 <koz_> jle`: Let me rephrase. All the stuff mono-traversable puts under IsSequence should be game for it.
02:50:46 <jle`> ah well, yeah
02:50:59 <koz_> I'm just trying to understand how to write it right now.
02:51:01 <jle`> if you use IsSequence, dramforever's type is probably most in spirit with it
02:51:09 <koz_> jle`: Yeah, I figured as much.
02:51:20 <jle`> koz_: well, it's a MonoTraversable
02:51:29 <jle`> so you can just fromList . mapMaybe f . toList
02:51:49 <koz_> Hmm, that works. Much easier than my original thought, thanks!
02:51:51 <jle`> fromList from IsSequence and toList from MonoFoldable
02:52:03 <jle`> you might potentially be able to benefit from stream fusion
02:53:02 <koz_> jle`: If I hide the mapMaybe from ClassyPrelude, I can't refer to it in my code somehow can I?
02:53:11 <jle`> you can import it qualified
02:53:20 <jle`> import ClassyPrelude hiding (mapMaybe)
02:53:25 <lpaste> mniip pasted ‚Äúinstance Show *‚Äù at http://lpaste.net/151835
02:53:29 <jle`> import qualified ClassyPrelude (mapMaybe) as CP
02:53:30 <mniip> jle`, :D ^
02:53:45 <jle`> mniip: cute :P
02:54:26 <koz_> jle`: The compiler seems to hate that 'as' there.
02:55:10 <jle`> import qualified ClassyPrelude as CP (mapMaybe), perhaps
02:55:29 * mniip . o O ( is TYPE a functor )
02:56:53 <koz_> jle`: Thanks, awesome!
02:57:00 <jle`> np!
02:57:10 <koz_> Also, what did you mean by 'stream fusion'?
03:01:21 <jedai> koz_: stream fusion is a compiler optimization that translate a composition of function on a container into a tight loop that do the same thing but much more efficiently
03:02:07 <koz_> jedai: So in this particular case, instead of unwrapping to a list, doing its thing, and rewrapping, it'd just do it element-by-element from one container type into the other or something?
03:02:16 <jedai> this is a very high level optimization, mostly only generally possible in Haskell thanks to purity (no effect means you don't care about ordering)
03:02:24 <jedai> koz_: Right
03:03:03 <jedai> koz_: though as jle` said, "you might potentially be able to benefit from stream fusion"
03:03:06 * hackagebot logging-effect 1.0.1 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.0.1 (OliverCharles)
03:03:28 <koz_> jedai: Oh, I'm aware that no optimization is guaranteed.
03:03:57 <jedai> koz_: this is not a 100%, since it's an optimization that needs a lot of help from the programmer (stream fusion is not a compiler level optimization, it's library level)
03:04:57 <jedai> koz_: vector  is a good example of a library that did a lot of effort to have very good stream fusion (since their performance kinda depends on it), you have good papers on the subject
03:05:19 <koz_> jedai: So basically, if classy-prelude or whatever magic libs it uses has good stream fusion, so will this?
03:06:24 <jedai> koz_: maybe, if fromList, toList and mapMaybe all mesh well so that it works (I don't know if they do, I kind of doubt it a priori)
03:06:37 <koz_> Also, a more general question: my understanding is that custom Show implementations (ones creating Show/Read assymetry) are not a good idea. Therefore, I assume that the suggestion in exercise 2 in part 1 here: https://github.com/quchen/articles/blob/master/write_yourself_a_brainfuck.md isn't a good plan?
03:06:54 <koz_> jedai: Well, I dunno much about the guts of classy-prelude.
03:06:57 <koz_> I just love its premise.
03:06:58 <jedai> but this is definitely possible in the stream fusion framework (kinda straightforward even)
03:07:15 <koz_> s/assymetry/asymmetry
03:07:39 <koz_> Classy-prelude still has a few bits of type rigidity I'm unhappy about, but hopefully I can get them PRed away.
03:07:50 <koz_> (like that mapMaybe thing)
03:08:04 <jedai> koz_: Well as long as you can write the symetric Read instance, why not
03:08:06 <mniip> koz_, I would create a function whatever :: String -> BFSource
03:08:16 <koz_> mniip: That was my thought as well.
03:08:22 <mniip> then I could yield 'whatever "string"' in the Show instance
03:08:29 <mniip> see Show instance for Map for example
03:08:32 <jedai> koz_: though prettyPrint is probably a better idea
03:08:46 <koz_> I guess I'm just a bit confused as to why this tutorial asks you to do this.
03:08:57 <koz_> Since a complementary Read instance is *not* requested.
03:10:52 <koz_> Like, all the other stuff it asks for makes sense, but that doesn't.
03:38:07 * hackagebot hsdev 0.1.6.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.6.0 (AlexandrRuchkin)
03:46:39 <lpaste> mniip pasted ‚ÄúforceType‚Äù at http://lpaste.net/151837
03:46:46 <mniip> so I ended up having this
03:46:58 <mniip> @undefined
03:46:58 <lambdabot> Undefined.
03:47:05 <mniip> @letlpaste 151837
03:47:06 <lambdabot>  Defined.
03:47:26 <mniip> :t fmap forceType . mapState
03:47:27 <lambdabot> ((a, s) -> (b, s)) -> State s a -> StateT s Identity b
03:47:45 <mniip> it has a clearly non-id type now so it doesn't get optimized away:
03:47:47 <mniip> :t forceType
03:47:48 <lambdabot> a -> Force a
03:49:14 <koz_> Can any arbitrary composition of functions (including curried ones) *always* be rewritten point-free?
03:49:23 <mniip> yes
03:49:51 <koz_> I clearly have to up my point-free rewriting game then. :P
03:49:55 <mniip> you only need 3 transformation rules:
03:50:12 <mniip> '\x -> x' -> i
03:50:29 <dramforever> https://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
03:50:29 <mniip> '\x -> somethingFreeOfx' -> k somethingFreeOfx
03:50:49 <mniip> '\x -> f a' -> s (\x -> f) (\x -> a)
03:52:11 <koz_> dramforever: Goddamn it Turing-completeness.
03:52:36 <koz_> So you could actually write a 'point-free-er'?
03:53:06 <dramforever> Yes, in fact it's kinda easy
03:53:25 <koz_> Well, as mniip just said, you only need 3 rewrite rules.
03:54:38 <wmealing> haskell and darksouls, two things i'm playing right now and someone writes about it
03:54:39 <wmealing> http://bitemyapp.com/posts/2016-02-06-haskell-is-not-trivial-not-unfair.html
03:54:42 <mniip> I wrote a really weird point-freer once
03:54:47 <koz_> wmealing: Yeah, you saw that too, huh.
03:55:07 <koz_> mniip: Once I've written this Brainfuck interpreter, I'm gonna try writing a point-free-er.
03:55:28 <mniip> I didn't know about these rewrite rules back then
03:55:38 <mniip> so it ended up as a 200-line... blob
03:55:44 <koz_> Lol.
03:56:09 <dramforever> mniip: wow, is it complete?
03:56:40 <mniip> I think
03:56:55 <mniip> it was the stupidest thing though
03:57:09 <koz_> mniip: Stupid things can still be cool though.
03:57:16 <mniip> oh also once I tried writing a djinn analog
03:57:21 <koz_> (although I get the feeling that some point-free-er outputs aren't very legible)
03:57:35 <mniip> which tried all possible typecheckable compositions of a predefined set of functions
03:57:47 <mniip> koz_, 
03:57:56 <mniip> @pl \a b c d e f -> f e d c b a
03:57:56 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
03:58:06 <koz_> Wtf did I just read?
03:58:25 <mniip> it's quadratic iirc
03:58:36 <mniip> if not exponential
03:59:06 <koz_> That's ... terrifyingly impressive.
04:00:18 <koz_> @pl \a b c d e f g -> f e g d c a b
04:00:18 <lambdabot> flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip id)))
04:00:33 <koz_> Goddamn.
04:01:03 <koz_> It's art, I swear.
04:01:14 <dramforever> flip-art
04:01:21 <koz_> Hurr hurr.
04:02:31 <koz_> Also, I'm having trouble understanding wtf the implementation of transpose means.
04:02:38 <koz_> transpose ((x:xs) : xss) = (x : [h | (h:_) <- xss]) : transpose (xs : [ t | (_:t) <- xss])
04:02:42 <koz_> This part most notably.
04:04:28 <koz_> @pl \a b c d e f g -> g f e d c b a
04:04:28 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
04:04:32 <dramforever> > let xs = [[1], [2, 3], [], [4], [], [5, 6, 7]] in [(h, t) | (h : t) <- xs] -- An example should suffice
04:04:33 <lambdabot>  [(1,[]),(2,[3]),(4,[]),(5,[6,7])]
04:04:43 <dramforever> note how the empty lists are gone
04:05:28 <mniip> ooh that's an interesting way to do it
04:05:38 <koz_> dramforever: OK, *that* much I get.
04:05:51 <koz_> mniip: Are you referring to pl's output or that transpose thing?
04:05:55 <mniip> transpose thing
04:06:51 <koz_> The reason I was looking at it was because I wanted a type-generic transpose in classy-prelude.
04:06:56 <koz_> I'm not so sure I want one anymore.
04:07:11 <koz_> (collection-type-generic should I say)
04:07:39 <koz_> ('collection-type-generic', should I say) <-- wtf, my grammar is dying.
04:25:05 <mysqlprogrammer> Hi guys! I'm working on a application that requires haskell to respond to a trigger (like when a text file gets updated.) What is a nice way to do this?
04:26:03 <ahihi> fsnotify perhaps
04:28:05 <fr33domlover> mysqlprogrammer, ^
04:28:21 <fr33domlover> iirc there are even several packages for that :P
04:29:43 <mysqlprogrammer> Just checked out hfsnotify and the spy package! Exactly what I wanted!
04:29:49 <mysqlprogrammer> Many thanks!
04:35:43 <leytzher> Hi guys, newbie here. I am going through Learn A Haskell and found some problems with the let expressions. "parse error on input ="
04:35:54 <megaTherion> Im looking for something like pack/unpack in haskell, is there some option?
04:36:06 <mniip> leytzher, you're supposed to put them in a file iirc
04:36:07 <leytzher> is there something related to Haskell versions>?
04:37:01 <fr33domlover> megaTherion, what is pack/unpack? if you mean serialization, check out the 'binary' package
04:37:02 <dramforever> megaTherion: check out http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Builder.html
04:37:34 <dramforever> there are things like "stringUtf8" "int32LE" in it
04:46:59 <jedai> leytzher: I don't think that's the problem.
04:48:56 <jedai> leytzher: "let ... = ..." is to be used in ghci (the interpreter), in a file, you would just write ".... = ..." for top-level definition. That seems the most probably cause of this error message (not the only possibility of course, come discuss it on #haskell-beginners if it doesn't work)
04:49:08 <dramforever> leytzher: expressions in GHCi and haskell code in files are treated differently. IIRC If LYAH did not say that you should type it in ghci (by giving a prompt like "ghci>"), put the code into a file.
04:50:29 <boj> is there still no way to get around name clashes when re-exporting A.foo and B.foo from a parent module? i have to name them A.aFoo and B.bFoo if i want to re-export both?
04:56:35 <boj> added to my list of haskell warts
04:58:32 <boj> (meant in a good way - knowing limitations of your tool is a bonus)
04:59:39 <Rembane> boj: I'm curious on how a solution would look like, 'cause I can't make one up.
04:59:55 <boj> i don't think there is one
05:02:52 <EvanR> modules are an unsolved problem
05:03:31 * hackagebot data-default-instances-new-base 0.0.1 - Default instances for types in newer versions of base package.  https://hackage.haskell.org/package/data-default-instances-new-base-0.0.1 (PeterTrsko)
05:16:12 <spion> is the fpcomplete online ide broken for anyone else?
05:18:49 <alliedwaste> howdy
05:18:53 <bergmark> spion: https://www.fpcomplete.com/blog/2015/10/retiring-fphc
05:20:29 <mniip> wait, if TYPE Lifted is *
05:20:32 <mniip> then what is ->
05:20:51 <alliedwaste> I don't use haskell. I have no particular interest in haskell. but I randomly came across this hackernews thread and wanted to drop by: https://news.ycombinator.com/item?id=7161236
05:21:01 <alliedwaste> it says you are all lovely people. 
05:21:26 <mauke> all lies
05:22:28 <mniip> "what you can do is grab the logs for the past 3 years, grep for "> " (used to invoke the evaluator) and you have instant insight into how an experienced Haskeller's mind works."
05:22:30 <mniip> whut
05:23:44 <alliedwaste> I have to say I found this very charming: https://gist.github.com/quchen/5280339
05:25:00 <shachaf> Because it's an example of #haskell being trolled successfully?
05:25:16 <alliedwaste> unsuccessfully! 
05:25:25 <alliedwaste> the troll was won over. 
05:25:57 <alliedwaste> also, there is a giant spider crawling on my wall and I don't know what to do. 
05:26:10 <shachaf> Entirely too successfully. The whole thing was a disaster, if you ask me.
05:26:58 <shachaf> But this isn't the place for that. It's also not the place for spiders, unless they're written in Haskell.
05:27:44 <alliedwaste> I hoped there might be a haskell solution to the spider problem. 
05:29:39 <ggole> How about one of 1) leave it alone 2) move it outside?
05:31:30 <alliedwaste> I think #1 would simply extend my anxiety and I fear if I attempted #2, it might eat me. 
05:31:38 <Ainieco> hello
05:31:58 <alliedwaste> howdy
05:32:10 <shachaf> alliedwaste: The topic of this channel is Haskell. Please stay on-topic.
05:32:49 <Ainieco> what is the esiest way to parse file and extract its multi line section which starts with "** Bla bla" and ends with "**" ?
05:32:50 <alliedwaste> understood. 
05:34:16 <jedai> Ainieco: If there is no exception and you're a beginner, I would recommend the split package
05:34:43 <jedai> Ainieco: (but there's always exceptions....)
05:36:36 <jedai> Ainieco: then you do "splitOn "**" ('0':myFileText)" and only keep the odd elements
05:37:02 <jedai> Ainieco: the '0': is there so you don't have to worry if your file start with "**"
05:38:00 <mniip> 1454851745 [16:29:05] <ggole> How about one of 1) leave it alone 2) move it outside?
05:38:05 <mniip> just do what the GC would do
05:38:10 <mniip> evacuate
05:38:44 <jedai> Ainieco: If this is any more complicated (way to put a "**" in a section, imposed position of "**"), I would resort to a very simple parser (see parsec/attoparsec...)
05:39:20 <Ainieco> jedai: ok, got it, thanks
05:40:53 <Ainieco> jedai: thesr is splitOn is in Data.Text btw, is ther any reason to use split package?
05:41:11 <Ainieco> it doesn't have any docs
05:41:17 <Ainieco> https://hackage.haskell.org/package/split
05:44:02 <jedai> Ainieco: Ah, if you're reading your file in Text just use the facilities in Data.Text (split is for lists, so String, also it has documentation, the latest version has just not been built yet by hackage, see the before last version for documentation)
06:08:32 * hackagebot data-default-instances-bytestring 0.0.1 - Default instances for (lazy and strict) ByteString, Builder and  ShortByteString.  https://hackage.haskell.org/package/data-default-instances-bytestring-0.0.1 (PeterTrsko)
06:09:39 <Ainieco> https://hackage.haskell.org/package/split
06:09:52 <Ainieco> oops, ignore that, wrong term
06:14:26 <jedai> Ainieco: You really don't need to use split, working in text is better from all points of view (almost). Also if you're searching the doc for split, it's available for 1.22 on Hackage (the difference is minimal) or for 1.23 on stackage
06:15:12 <Ainieco> jedai: yeah, thank you
06:15:51 <jedai> Ainieco: You're welcome :)
06:38:34 * hackagebot data-default-instances-text 0.0.1 - Default instances for (lazy and strict) Text and Text Builder.  https://hackage.haskell.org/package/data-default-instances-text-0.0.1 (PeterTrsko)
06:38:36 * hackagebot reactive-banana-sdl2 0.1.0.0 - Reactive Banana integration with SDL2  https://hackage.haskell.org/package/reactive-banana-sdl2-0.1.0.0 (cies)
06:53:37 <the_2nd> I need an example .cabal for a library where I create example executeables aswell
06:53:41 <the_2nd> can this be done?
06:55:14 <Xandaros> the_2nd: https://github.com/DanielG/ghc-mod/blob/master/ghc-mod.cabal
07:04:40 <the_2nd> Xandaros, working, thanks
07:10:09 <codedmart> I am not sure how to write and instance for MonadIO (liftIO) http://lpaste.net/151839
07:11:21 <mauke> codedmart: what's Raw?
07:12:19 <codedmart> mauke It is a type in Servant. https://github.com/haskell-servant/servant/blob/178/servant/src/Servant/API/Raw.hs#L37
07:13:31 <mauke> how is that an instance of MonadIO?
07:14:17 <notabigthreat> what you think "a" is in "IO a"?
07:15:17 <codedmart> It isn't but when I try to use liftIO I get an error: `No instance for (MonadIO (Raw App)) arising from a use of ‚ÄòliftIO‚Äô`
07:15:31 <codedmart> Should I not use liftIO?
07:19:42 <mauke> for what?
07:20:28 <codedmart> mauke If I just try to use the standard some <- thisIO I get Couldn't match type ‚ÄòIO‚Äô with ‚ÄòRaw App‚Äô
07:21:45 <mauke> for what?
07:23:02 <pavonia> codedmart: I don't think you can write such an instance because that App parameter is only a phantom type for Raw, it's never used
07:23:25 <Gurkenglas> notabigthreat, I would say "IO a" is "An effectful program that produces an a". You can't "get the a out" because there's no way to know what the a will be without executing the program, and pure code can't execute effectful programs. What you can do is transform effectful programs into other effectful programs.
07:24:48 <codedmart> So in other words I need to go about this differently Gurkenglas?
07:25:49 <Gurkenglas> Oh, I thought notabigthreat was asking a question to the channel :D
07:25:58 <codedmart> Gurkenglas :)
07:28:40 <codedmart> pavonia Sorry just saw your reply. Thanks!
07:37:28 <BernhardPosselt> hi im watching https://www.youtube.com/watch?v=pzouxmWiemg and he talks about using ReaderT for abstracting away the database connection at minute 16. how is the ReaderT solution different from just using currying to create a function that already has a connection?
07:38:43 <BernhardPosselt> e.g. query :: Connection -> IO [Thing] would become queryC :: () -> IO [Thing] 
07:41:10 <pavonia> It would become :: ReaderT Connection IO [Thing], no?
07:45:53 <BernhardPosselt> right
07:46:56 <BernhardPosselt> ah, its allows to pass the Connection down via bind
07:47:01 <BernhardPosselt> implicitely
07:51:10 <BernhardPosselt> btw, what do you guys use as editor? intellij?
07:51:48 <mniip> vim
08:08:55 <zd234> what is the fastest way to convert a [Double] -> String, where [0.2, 0.4, 0.6] -> "0.2 0.4 0.6"
08:11:40 <mniip> zd234, "fastest"?
08:13:36 <maerwald> https://hackage.haskell.org/package/double-conversion-2.0.1.0/docs/Data-Double-Conversion-Text.html
08:13:42 <maerwald> "These functions are about 30 times faster than the default show  implementation for the Double type. "
08:16:03 <mniip> hahaha
08:16:20 <mniip> wow look at that
08:16:26 <mniip> it's not even using unboxed doubles
08:16:27 <mniip> boo
08:17:11 <zd234> maerwald , mniip: will look into it; thanks!
08:17:57 <monochrom> but is it using unboxed characters?
08:19:17 <mniip> Addr# strings
08:19:37 <fr3tz0r> what's worng with this typesignature? (Maybe (String,Int))
08:19:52 <mniip> fr3tz0r, "wrong"? seems good to me
08:20:33 <fr3tz0r> ghc says invalid typesignature Should be of form <variable> :: <type>
08:21:06 <mniip> you're excluding some important context
08:23:03 <fr3tz0r> i try to patternmatch func (Just(a,b)) and so on... but is it illegal to patternmatch like that? I mean a tuple is only one value but I want to patternmatch the tuple 
08:23:38 <mniip> can you pastebin your code and the full error message?
08:24:20 <monochrom> the cause is always in the code you didn't show
08:24:25 <monochrom> always
08:25:51 <zd234> monochrom++
08:25:59 <zd234> this is almost in all questions:
08:26:02 <zd234> asker: I got a contradiction
08:26:09 <zd234> debugger: *how* did you get to this contradiction ?
08:26:39 <monochrom> furthermore, http://www.vex.net/~trebla/humour/tautologies.html #4 :)
08:28:56 <fr3tz0r> do I have to derive Ord for Maybe type?
08:29:08 <monochrom> no, it's already done
08:29:12 <mniip> fr3tz0r, no you have to pastebin the rest of your code
08:29:24 <mniip> >0. ‚ÄúX is like Y‚Äù can always be argued to be true.
08:29:29 <monochrom> no, not just the rest. all of the code.
08:29:46 <mniip> I have a gist of a proof of existence of X and Y such that that is impossible
08:29:47 <mniip> :)
08:29:57 <fr3tz0r> http://lpaste.net/1452638070712041472
08:30:16 <mniip> Auxi is not a valid function namee
08:30:24 <monochrom> and I want to extend it to: "furthermore, if X /= Y, 'X is the opposite of Y' can always be argued to be true"
08:30:38 <mniip> function names begin with a lowercase character
08:31:52 <haskell969> oll
08:31:56 <haskell969> hi
08:31:59 <monochrom> you will have an uncovered case, i.e., when b >= d
08:32:26 <Lowl3v3l> is there any actual manual for the lambdabot?
08:32:41 <fr3tz0r> monochrom: yes 
08:33:35 <fr3tz0r> "stuck" on wrong syntax implementation...
08:33:35 <haskell969> hi
08:33:44 <haskell969> l
08:33:45 <haskell969> ,
08:33:45 <haskell969> l
08:36:07 <fr3tz0r> monochrom: what is more idiomatic to use otherwise or >= for the reamining cases?
08:36:24 <monochrom> otherwise
08:37:41 <fr3tz0r> thought so but I'm Haskell noob so I think I do wrong all the time even when I don't...
08:37:58 <fr3tz0r> thx
08:38:19 <mniip> I like the part where
08:38:21 <mniip> > otherwise
08:38:23 <lambdabot>  True
08:38:29 <mniip> just that
08:45:20 <ThatTreeOverTher> GHC's telling me it can't match Data.Text.Internal.Lazy.Text with Data.Text.Internal.Text when trying to save text to a file. How do I fix this?
08:47:00 <geekosaur> make sure you're not mixing up lazy and strict ByteStrings
08:47:11 <monochrom> s/ByteString/Text/
08:47:16 <geekosaur> sory, yes
08:47:22 <geekosaur> blegh
08:47:29 <monochrom> but yes, you are mixing up Lazy and non-Lazy
08:47:52 <ThatTreeOverTher> "import Prelude hiding (readFile,writeFile)" "import Data.Text.IO (readFile,writeFile)"
08:48:02 <ThatTreeOverTher> where can I get a strict writeFile?
08:48:25 <monochrom> you already got it.
08:48:34 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
08:48:53 <mniip> monochrom, >10. A piece of writing is clear to its writer.
08:48:57 <mniip> arguable, see perl
08:49:11 <monochrom> yes but I had natural language in mind
08:49:34 <geekosaur> you're reading the error backwards. Data.Text.IO is strict and you're trying to use it with a lazy Text. see Data.Text.Lazy.IO
08:50:07 <ThatTreeOverTher> that's a teensy bit more helpful, thanks haha
08:50:27 <monochrom> no, you should show complete actual code.
08:50:51 <monochrom> I hate it when people guess, and guess correctly, and promote the wrong view that programming is magic.
08:51:22 <ThatTreeOverTher> I'm trying to take data from renderHtml and put it in a file. And I don't think programming is magic?
08:51:23 <johnw> mniip: "clear to its writer at the time it was written."
08:52:34 <mniip> well one could argue that the writer then is not the same as the writer now
08:54:04 * hackagebot Lazy-Pbkdf2 1.0.2 - Lazy PBKDF2 generator.  https://hackage.haskell.org/package/Lazy-Pbkdf2-1.0.2 (Ofenhed)
08:57:03 <monochrom> ok, s/magic/telepathy and guru meditation/
09:00:53 <geekosaur> there's nothing magic about "compiler complains about mixing Text and Text.Lazy" with "when using writeFile from using strict Text IO" to get "use lazy Text IO instead"
09:01:27 <geekosaur> the main problem here is it's sometimes unclear to newcomers that there is even a difference
09:08:08 <mniip> they might also think the error is somehow related to laziness
09:08:18 <mniip> whereas it's as simple as having two different aptly named modules
09:11:17 <geekosaur> yes, that's actually what I was getting at
09:11:44 <geekosaur> it's also not helped by Data.Map.{Lazy,Strict} where it's the same structure but different functions
09:11:58 <geekosaur> we use "lazy" in often confusing ways
09:19:40 <dustmote> does anyone know how to get 'stack build' to respect and display ghc's warnings?
09:23:08 <dustmote> ah, `stack build --help` shows there's an option `--pedantic`
09:26:09 <MarcelineVQ> Oh you want -Wall? there's a few ways to do that
09:27:11 <MarcelineVQ> such as `ghc-options: -Wall` in your cabal file or {-# OPTIONS_GHC -Wall #-} in your source file
09:29:17 <bollu> how do you guys get around to writing blog posts?
09:29:38 <bollu> I've done something that (I think) is interesting - simulated CA on a finite warping grid with comonads and diagrams
09:29:45 <bollu> but I have no idea on how to.. write I guess :P
09:30:10 <bollu> also, I was wondering about GSoC and haskell - are there haskell projects in gsoc? I for one would like to work on diagrams
09:30:17 <rott922> allo
09:30:41 <MarcelineVQ> bollu: You just keep going over it, all human craft is iterative
09:30:58 <bollu> MarcelineVQ: thanks :)
09:31:10 <bollu> I guess I'll do that - write it out and then ask you guys for feedback
09:31:17 <MarcelineVQ> That's a good option too
09:43:44 <dustmote> MarcelineVQ: so, i've tried adding -Wall in the the ghc-options section of my cabal file, but stack seems to be eating the errors
09:48:29 <bartavelle> dustmote, stack build "name of package you want to see the output of", or cat the build log (somewhere in .stack-work)
09:52:55 <MarcelineVQ> dustmote: Interesting, tested it out just now and that was true but running stack clean solved it
09:53:06 <dustmote> bartavelle: explicitly naming the package i'm building `stack build this-package --pedantic -file-watch` doesn't work for me eithre
09:53:21 <dustmote> ive been running stack clean, but i'll try again
09:55:30 <dustmote> ok, found the problem- i'd renamed the file and then changed the cabal to point to the new file, but then continued to only edit the old file
09:55:38 * dustmote durp'd
09:55:51 <dustmote> ty anyhow
09:55:57 <rott922> hmm chatter is not playing with stackage lts 5.0
09:56:30 <MarcelineVQ> happens :> I should mention there's nothing wrong at all with using pedantic, and that I usually use -Wall in the source file myself if I really want -Wall on. That way it only gives me stuff from the files I'm interested in
10:00:04 <dustmote> the pragma line you mentioned? yeah, i'll try that. ty
10:07:14 <the_2nd> work in progress game engine : https://github.com/I3ck/HGE2D
10:07:30 <rott922> the_2nd whee yay
10:08:07 <rott922> the_2nd is this comparable to love?
10:08:28 <MarcelineVQ> or a rose?
10:09:02 <rott922> Love2D I mean
10:09:24 <the_2nd> don't know that one, so I guess not
10:10:17 <rott922> the_2nd how far along is it?
10:11:19 <the_2nd> rott922, version "come back later" :D
10:11:33 <the_2nd> writing a game and moved engine stuff to own project
10:11:51 <rott922> the_2nd lol too bad
10:12:04 <rott922> desperately need something beyond "start with opengl" here...
10:12:14 <the_2nd> I guess things will change greatly within the next weeks / months
10:12:21 <the_2nd> rott922, just check the examples
10:12:31 <the_2nd> maybe it's better already for your use case
10:12:40 <the_2nd> feel free to open issues if you need anything
10:12:58 <fr3tz0r> how do I accomplish to send two arguments two a function which are not part of the same recursive step, say: func(arg from first recursion step, arg after second recursive step)
10:13:11 <rott922> the_2nd looks nice and sstraightforward
10:13:23 <fr3tz0r> *to
10:13:52 <rott922> the_2nd isn't  Graphics.Rendering.OpenGL kind of deprecated these days in favor of gl or gpipe... or am i out of date on that?
10:16:47 <dustmote> "Pattern match(es) are non-exhaustive"
10:16:49 <dustmote> FINally.
10:17:01 <scshunt> you *want* that?
10:17:14 <dustmote> absolutelyesir
10:17:43 <the_2nd> I dont understand why haskell would even compile then
10:18:29 <dustmote> the_2nd: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-sanity.html
10:18:55 <dustmote> pretty sure this page explains why.. hold on, i'll quote it here in a sec
10:19:25 <dustmote> "This option isn't enabled by default because it can be a bit noisy, and it doesn't always indicate a bug in the program. However, it's generally considered good practice to cover all the cases in your functions, and it is switched on by -W.
10:19:37 <dustmote> so, there's no real reason.
10:21:25 <csd_> does anyone know of a good blog post explaining Control.Foldl's Fold and FoldM types ?
10:21:48 <Gurkenglas> fr3tz0r, does some other information pass between the runs of the function? Try to come up with the type signature you want
10:22:31 <dustmote> csd_: here ya go
10:22:32 <dustmote> http://www.haskellforall.com/2013/08/composable-streaming-folds.html
10:22:46 <dustmote> the package got renamed, and he does a few things differently in the modern version
10:22:49 <dustmote> but the essentials are there
10:23:29 <csd_> dustmote: aha! i knew i remembered seeing this at some point but couldnt find it
10:23:34 <csd_> what's the new library called?
10:23:40 <dustmote> `foldl`
10:24:44 <the_2nd> dustmote, non-exhausive patterns. A great way to make pure code crash no matter what
10:25:19 <MarcelineVQ> the_2nd: pretty sure he just wanted the error to actually show
10:25:23 <dustmote> the_2nd: that's why i'm turning on the warning 
10:25:40 <dustmote> `--pedantic` is nice though, because it promotes the warning to an error
10:25:42 <the_2nd> dustmote, not blaming you, but it not being enabled by default
10:26:25 <dustmote> gotcha :)
10:27:50 <fr3tz0r> Gurkenglas: No, I want func(arg first recursive call, arg second recursive call) then on third and fourth time func(arg third recursive step, arg fourth recursive step) and so on... All i come up with going to be like func(arg1,(func arg2...
10:30:16 <Gurkenglas> fr3tz0r, "recursive call" seems ambigious. Using the arguments twice can be done as follows, if you just want the results in a list:
10:30:32 <Gurkenglas> :t \xs -> zipWith ?f xs (tail xs)
10:30:34 <lambdabot> (?f::b -> b -> c) => [b] -> [c]
10:31:44 <Gurkenglas> If you give me a line of the form that lambdabot replied to me, I can give you a line that would have made lambdabot say one like it if possible
10:35:41 <fr3tz0r> Gurkenglas: this is my function defs, idk if you asked for something else? f1 :: Tree -> (Maybe (String, Int)) calls f2 :: (Maybe (String, Int)) -> (Maybe (String, Int)) -> (Maybe (String, Int))
10:45:05 <Gurkenglas> :t scanl ?f ?basecase (?firsttimearg : replicate 10 ?otherwisearg) -- If your function transforms an accumulator "b" into another depending on the function argument a, and you want to run it once with one argument and 10 times with another, this is like "f otherwisearg (f otherwisearg (f otherwisearg (...(f firsttimearg basecase)...)))"
10:45:06 <lambdabot> (?basecase::b, ?f::b -> a -> b, ?firsttimearg::a, ?otherwisearg::a) => [b]
10:46:17 <Gurkenglas> fr3tz0r, try pasting your code, maybe I can figure out what you want
10:49:15 <Gurkenglas> lpaste.net
10:55:36 <EvanR> what is the diff between
10:55:43 <EvanR> newtype Pair a b = Pair (forall c. (a -> b -> c) -> c) and
10:55:44 <geekosaur> 8.0.1rc2 just dropped, it seems
10:56:02 <saurabhnanda> I'm stuck with the ReaderT monad. Why does the following not compile? http://lpaste.net/151841
10:56:08 <EvanR> newtype Pair a b = forall c . Pair ((a -> b -> c) -> c)
10:56:17 <RyanGlScott> I'm hoping the compilation times improve a bit now that the pattern-matcher was overhauled (again)
10:56:24 <EvanR> er, or the data version of the second one
10:56:41 <fr3tz0r> Gurkenglas:http://lpaste.net/9121167882682630144
10:56:48 <geekosaur> saurabhnanda, you need to use liftIO, like on line 30
10:57:43 <saurabhnanda> geekosaur: yes, it works with a liftIO, but why?
10:58:02 <EvanR> reading the haskell wikibook on existential and rankN, they move the exists outside when converting to forall, but randomly put forall inside for the Pair example
10:58:38 <geekosaur> ...sigh. I understand why, but have never been good at explaining it...
10:58:52 <geekosaur> (the liftIO thing, not the forall)
10:58:54 <saurabhnanda> I'm trying to completely understand what's going on here. Another question I had was, how come the functions which are doing DB access (insert, get), don't have an IO() in their type-signatures?
10:59:02 <exio4> EvanR: it might be easier to see if you see the the types of the constructors
10:59:42 <exio4> EvanR: in one case, the function has to work -for all- c (inner forall), in the other one, you mean it has to work for some c.
11:00:03 <Gurkenglas> fr3tz0r, nope don't see the point yet, but I think you had a hacky way to code in what you want. Can you add that to the paste, and I could try to refactor it?
11:00:04 <geekosaur> saurabhnanda, the IO is not "on top", it is buried inside other monads
11:00:28 <EvanR> exio4: for all on the outside in a data definition means "for some" ?
11:00:37 <saurabhnanda> geekosaur: it shouls show up in the ReaderT type, right?
11:00:46 <geekosaur> the type error tells you that you have a ReaderT wrapping a Logger which wraps a ResourceT which wraps an IO
11:01:09 <saurabhnanda> ah, missed that
11:01:19 <geekosaur> so, you can either "lift" the IO operation 4 times, or you can use liftIO which figures out where the IO is and passes the IO action to it
11:01:40 <exio4> EvanR: it's a way to encode ‚àÉ, looking at the types might give you a hint, in the first case, you have (forall c. (a -> b -> c) -> c) -> Pair a b
11:01:56 <exio4> in the second case, it's ((a -> b -> c) -> c) -> Pair a b 
11:02:23 <exio4> well, can we name them differently? :)
11:02:50 <EvanR> ok, so forall inside translates to a rankN constructor
11:02:59 <EvanR> forall on the outside does not
11:03:09 <saurabhnanda> right, but you lift from "smaller to larger", right? you can't "lift" from a monad into a non-monad, right? Even it it's working with liftIO, the type of the do-block should be ReaderT, not IO. How is the type-check passing, even with the liftIO usage?
11:03:14 <EvanR> during a pattern matching, its reversed
11:03:29 <saurabhnanda> lift == fmap, right?
11:03:37 <geekosaur> no, lift here is not fmap
11:03:45 <geekosaur> it's Control.Monad.Trans.lift
11:04:06 <saurabhnanda> geekosaur: ok, this is new. There are TWO lifts?
11:04:20 <glguy> saurabhnanda: You might be remembering liftM = fmap
11:04:20 <geekosaur> ther's two concepts that are both confusingly called "lifting"
11:04:43 <exio4> EvanR: you can't even write an "unPair" function for the second case! that'd need existential types. ‚àÄa b. Pair a b -> (‚àÉc. (a -> b -> c) -> c) :P 
11:04:45 <BernhardPosselt> because naming in haskell was just not a priority :D
11:04:49 <BernhardPosselt> like fst and snd
11:05:00 <csd_> for writing a monoid instance of Pair (a b) where a and b are monoids also, how do i interpret this: mempty = (mempty :!: mempty) ?
11:05:26 <geekosaur> they both *o* lift, but with a monad transformer Foo SomeMonad SOmeValue, the fmap lift operates on the SomeValue slot and the monad transformer lift oprates on the SomeMonad slot
11:05:34 <geekosaur> * *do*
11:05:43 <saurabhnanda> is this the lift that is being referred to? http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Class.html#v:lift
11:05:47 <geekosaur> yes
11:06:14 <glguy> csd_: The mempty element of pairs of things is a pair of the mempties of the things contained within the pair
11:06:16 <EvanR> exio4: oy... still not clear. i get the usage of rankN, but not the haskell syntax in data defs ...
11:06:29 <geekosaur> also, to see what types are going on, look at the type of runSqlite.
11:06:47 <geekosaur> the key here is that there will be a MonadIO constraint somewhere, which is what enables liftIO to work
11:06:56 <exio4> EvanR: have you done this with GADT syntax? it's much clearer with them, fwiw
11:07:19 <geekosaur> hm or maybe not since it looks like it may use IO explicitly, so it won't need to declare MonadIO...
11:07:21 <EvanR> i have never tried moving foralls outside of the GADT completely
11:07:28 <fr3tz0r> Gurkenglas: i will edit it a bit, I try to traverse a tree with two different nodes(and compare each node and keep the smallest int, I want the smallest Int so i finally can return the (String, Int) with the smallest Int) and I'm only intersted in WOMEN nodes, 
11:08:06 <EvanR> that doesnt even make sense
11:08:16 <geekosaur> ah, it does mention it
11:08:17 <csd_> glguy: oh right, mempty doesn't take any arguments
11:08:19 <exio4> EvanR: "Pair :: ((a -> b -> c) -> c) -> Pair a b" 
11:08:25 <geekosaur> runSqlite :: (MonadBaseControl IO m, MonadIO m)=> Text-> SqlPersistT (NoLoggingT (ResourceT m)) a-> m a
11:09:00 <EvanR> Pair :: forall a b c . ((a -> b -> c) -> c) -> Pair a b
11:09:10 <geekosaur> m here is instantiated to IO because you are invoking runSqlite from run :: IO ()
11:09:38 <saurabhnanda> I have no clue what't going on with the monadic lift
11:09:57 <geekosaur> IO has a "dummy" MonadIO instance: instance MonadIO IO where liftIO = id
11:09:57 <EvanR> Pair :: forall a b . (forall c . (a -> b -> c) -> c)) -> Pair a b ?
11:10:31 <saurabhnanda> what does the type signature even mean at http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Class.html
11:10:53 <exio4> EvanR: yep
11:10:53 <saurabhnanda> Especially lift (m >>= f) = lift m >>= (lift . f)
11:11:04 <tekkkz> how to rewrite following line with functionComposition by func . func . func $ value : ªgetWords xs = takeWhile (/=' ') xs : [] ++ getWords (dropWhile (==' ') (dropWhile (/=' ') xs) )´ ?
11:11:13 <EvanR> exio4: k. i will stop trying to understand non-GADT syntax ;)
11:11:30 <tekkkz> i mean only this part ªgetWords (dropWhile (==' ') (dropWhile (/=' ') xs) )´
11:11:33 <saurabhnanda> where did monadIO come from?
11:11:38 <exio4> EvanR: that's probably the best :P 
11:11:56 <geekosaur> saurabhnanda, those lines are the mathematical laws defining the behavior of lift
11:12:26 <geekosaur> you don't really need to worry about them; they're more important if you are defining your own monad transformer
11:12:33 <saurabhnanda> geekosaur: I understand, but I don't understand. I could understand what fmap **means** or what >>= **means**
11:12:41 <saurabhnanda> but this new lift it way over my head
11:12:51 <EvanR> :t lift
11:12:52 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:13:22 <EvanR> lift :: IO () -> ReaderT Foo IO (), for example
11:13:45 <saurabhnanda> so, if I have to write a function that accepts a userId and fetches a user object from the DB, will it's type signature have a ReaderT or an IO()
11:13:46 <saurabhnanda> ?
11:13:58 <EvanR> either
11:14:14 <geekosaur> if it needs to fetch from the DB, it will be a ReaderT
11:14:18 <EvanR> depends if you want to be able to use the reader or not
11:14:19 <saurabhnanda> is there any way to NOT have either of those two?
11:14:24 <geekosaur> because runSqlite :: (MonadBaseControl IO m, MonadIO m)=> Text-> SqlPersistT (NoLoggingT (ResourceT m)) a-> m a
11:14:35 <geekosaur> and SqlPersistT is a ReaderT
11:14:41 <EvanR> ah you need the reader to use the db connection
11:14:58 <saurabhnanda> geekosaur: is it mandatory that the return type of said function will be a ReaderT?
11:14:59 * mniip mumbles something along the lines of unsafePerformIO newIORef
11:15:10 <EvanR> blasphemy!
11:15:55 <geekosaur> saurabhnanda, if you want to use the DB via persist, then yes, it is mandatory that the return type will be either the ReaderT or something wrapping that (in which case you would need some form of monadic lifting to reach the ReaderT)
11:16:26 <begriffs> How do you update the second element of a tuple using lenses?
11:16:28 <geekosaur> you could do it in IO but you would need to invoke runSqlite to create a DB context (and then probably have to worry about locking issues)
11:16:48 <geekosaur> you cannot do it from pure code, at least if you want the code to actually work reliably
11:16:55 <fr3tz0r> Gurkenglas:http://lpaste.net/9121167882682630144
11:18:06 <geekosaur> Haskell does not make you isolate IO code just to make your life difficult; it does it because there is otherwise no way to predict when that IO code will be executed, because of laziness
11:18:15 <saurabhnanda> geekosaur: every single function which touches the database will necessarily need to have ReaderT is its **return type** ?
11:18:18 <geekosaur> sequestering it in IO forces it to execute in order
11:18:20 <geekosaur> yes
11:18:44 <EvanR> saurabhnanda: in that particular library
11:18:58 <saurabhnanda> geekosaur: how was it possible for me to define run :: IO () and do SQL ops inside it, in that case?
11:19:07 <geekosaur> likewise sequestering DB operations in the ReaderT (a) makes sure the functions can find the database connection, by getting it from the ReaderT (b) ensures database operations happen *in the order you specified them* and not when something happens to need a result
11:19:29 <geekosaur> because you used runSqlite, as I said earlier
11:20:02 <geekosaur> the code inside your runSqlite invocation has a connection to the database, and produces a result in IO
11:20:38 <geekosaur> runSqlite "nightwatch.db" $ do ...
11:20:44 <saurabhnanda> why is this so hard
11:20:54 <geekosaur> the stuff inside that "do" can now access stuff from nightwatch.db
11:21:07 <EvanR> saurabhnanda: maybe youd like to use the database directly, all in IO directly
11:21:25 <EvanR> IO can do anything
11:22:27 <EvanR> your library is only trying to make it easier than that
11:23:09 <saurabhnanda> I just managed to wrap my head around IO() and fmap and >>= and do-notation; and now this ReaderT business comes along
11:23:24 <Welkin> EvanR: aren't you supposed to be marching in the parade and throwing a pigskin?
11:24:09 <EvanR> saurabhnanda: implement Reader and ReaderT yourself, and itll make more sense
11:24:37 * hackagebot mappy 0.1.2.1 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.2.1 (mjgpy3)
11:25:15 <EvanR> Reader technology is something i seriously miss when not in haskell
11:28:38 <saurabhnanda> just blindly using liftIO here, but why isn't this working -- http://lpaste.net/151842
11:28:53 <csd_> why is it necessary in defining Control.Foldl to use existential quantification on (Monoid w) as shown at the top of http://www.haskellforall.com/2013/08/composable-streaming-folds.html ?
11:28:59 <geekosaur> you are already in IO
11:29:28 <geekosaur> so the liftIO isn't doing anything. the error message tells you that you need a ReaderT; to get that you do not use liftIO, you use runSqlite
11:32:59 <saurabhnanda> geekosaur: but I can't do runSqlite in every minor "internal" function, right? It seems like runSqlite has to be done from the main function, just once
11:33:08 <geekosaur> yes
11:33:22 <geekosaur> but you seem to want everything to be in IO so you can ignore the ReaderT...
11:33:50 <saurabhnanda> geekosaur: so what should I change the type-sig of this function to?
11:34:44 <saurabhnanda> It's doing DB ops, and needs to return an object of the type AuthNightwatchCommand, suitably gift-wrapped in an monad
11:35:21 <geekosaur> SqlPersistT (NoLoggingT (ResourceT m)) a
11:35:32 <geekosaur> er
11:35:35 <geekosaur> SqlPersistT (NoLoggingT (ResourceT IO)) a
11:35:55 <geekosaur> I don;t see a convenient synonym for that, so you may want
11:36:17 <geekosaur> type Db a = SqlPersistT (NoLoggingT (ResourceT IO)) a
11:36:38 <saurabhnanda> and 'a' can be my own type?
11:36:47 <saurabhnanda> and I can fmap stuff into this value?
11:36:51 <geekosaur> and now you can declare authenticateCommand :: Message -> Db AuthNightwatchCommand
11:37:43 <geekosaur> and generally use Db in place of IO, and use liftIO to do IO operations
11:38:00 <geekosaur> and yes, fmap will still work
11:38:00 <saurabhnanda> geekosaur: okay, let me try
11:39:45 * hackagebot mdp 0.1.0.0 - Tools for solving Markov Decision Processes.  https://hackage.haskell.org/package/mdp-0.1.0.0 (prsteele)
11:39:53 <saurabhnanda> geekosaur: I'm not sure if it's supposed to work like this?
11:40:09 <saurabhnanda> none of those symbols are exported by the standard Persistent-Yesod modules
11:42:37 <geekosaur> sigh. figures
11:42:52 <geekosaur> guess it expects you to rely on type inference instead of explicitly typing things
11:44:04 <saurabhnanda> geekosaur: so what can the type sig be?
11:45:33 <geekosaur> hm
11:45:39 <saurabhnanda> additional imports -- import Control.Monad.Logger (NoLoggingT) import Control.Monad.Trans.Resource(ResourceT) & 
11:45:54 <geekosaur> was it only complaining about those?
11:46:19 <geekosaur> because, digging further, it looks like you want SqlPersistM
11:46:35 <geekosaur> (sigh, this is a mess)
11:47:07 <geekosaur> so instead of defining that type Db a, you use SqlPersistM a
11:47:08 <saurabhnanda> and import Database.Persist.Sql for SqlPersistT
11:47:19 <geekosaur> supposedly that is re-exported
11:47:42 <geekosaur> but if it's not then you import that and use SqlPersistM, and don't bother importing Logger or Resource
11:50:48 <geekosaur> authenticateCommand :: Message -> SqlPersistM AuthNightwatchCommand
11:51:36 <saurabhnanda> geekosaur: yep, that seems to work. I'm still unable to compile because of some Int <=> Integer issues
11:52:16 <saurabhnanda> geekosaur: apparently I had defined a number of Integers, but the DB layer cannot seem to handle Integer; only Int
11:52:58 <geekosaur> I'm not too surprised by that, marshaling bigints tends to be painful
11:53:10 <saurabhnanda> geekosaur: anywho, this is progress. I will investiage this Int <=> Integer issue tomorrow. It's too late for me now. Gotta catch some sleep.
11:53:13 <geekosaur> whereas in ghc Int is a light wrapper around a machine word
11:53:14 <saurabhnanda> geekosaur: thanks for your help
11:53:55 <saurabhnanda> geekosaur: I need the Integer because it's actually coming from a remote API and I don't know how large the thing may get
11:55:08 <geekosaur> looks like the sqlite binding indeed doesn't support Integer
11:55:48 <geekosaur> you'll need to discuss that with Michael Snoyman since the sqlite binding is bundled with persistent-sqlite
11:56:03 <geekosaur> (Database.Sqlite module)
12:06:31 <bitemyapp> Lokathor: that's kinda funny
12:08:09 <Big_G> What are the best resources for building out a test suite (with examples)?
12:14:37 <csd_> Why do I see code that has a function like echo txt = liftIO (putStrLn txt) with type echo :: MonadIO io => Text -> io () when if you omitted the liftIO you'd instead have the similar signature Text -> IO () ?
12:14:49 <csd_> what is using monadio buying you
12:15:17 <Lokathor> csd_, you can use a MonadIO statement within any monad stack that incorporates IO
12:15:19 <Welkin> it works with anything that is an instance of MonadIO insteado f strictly the IO monad
12:15:22 <samba1_> Big_G: dunno any learning resources specifically, but search for hspec stuff, it's easy and effective
12:15:31 <geekosaur> that you can use it in things that are not directly IO. see for example the previous discussion with saurabhnanda
12:15:58 <Lokathor> csd_, for example, if you use ReaderT or StateT on top of IO, then an operation with a type signature for MonadIO and using liftIO would still work in that context
12:15:59 <geekosaur> something using MonadIO m => m would be able to do IO directly from inside runSqlite instead of requiring liftIO
12:16:19 <Big_G> samba1_, I've seen tools like hspec and tasty but it isn't clear how I'd make a test suit with them like I'd do with maven and Junir
12:16:25 <Big_G> *Junit
12:16:49 <geekosaur> similarly, xmonad has a number of things that are MonadIO m => m a instead of IO a, so you can use them both in IO a and in X a
12:16:50 <csd_> i'm still learning about monad transformers. so you're saying that it depends on what the context calling `echo` is?
12:17:09 <Lokathor> Big_G, https://github.com/Lokathor/roguelike-hs/blob/master/tests/Roguelike/Util/RNGTests.hs here are some tests I wrote using HSpec for some RNG stuff I did
12:17:14 <Lokathor> perhaps this will guide you?
12:17:18 <geekosaur> whereas if they ha type IO a then you'd need to use liftIO 
12:18:02 <Lokathor> csd_, yes, MonadIO is more a flexible conctraint than just IO.
12:18:07 <Lokathor> constraint*
12:19:41 <csd_> and it's more flexible because it's a monad transformer?
12:19:57 <Lokathor> yes essentially
12:20:12 <exio4> MonadIO is not a monad transformer, or anything
12:20:31 <exio4> it's a typeclass for lifting things into monads which can "run" IO actions
12:20:40 <Lokathor> there's no "IOT" transfromer, so any monad transformer stack that is partly IO will have IO at the "base" of the stack. MonadIO is a typeclass that says, "this monad incorporates IO at the base"
12:20:46 <geekosaur> so here;s a more concrete example
12:20:58 <samba1_> Big_G: I haven't read it really, so take it with a grain of salt, but this blog post looks to show how to get using hspec (amongst other things): http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/
12:21:01 <geekosaur> in xmonad we have a function spawn :: MonadIO m => String -> m ()
12:21:15 <geekosaur> it could have been written as spawn :: String -> IO a
12:21:26 <Big_G> samba1_, Thanks. I'll take a look
12:21:30 <csd_> Lokathor: from what I've seen you'd wrap transformers around IO... and here i see that instead MonadIO m actually is an instance of a bunch of different transformers
12:21:45 <geekosaur> but then you would have to use liftIO to use it from within xmonad hooks, whereas in main before invoking xmonad you could use it directly
12:22:13 <geekosaur> by making it MonadIO m => String -> m a, you can use spawn in either place and not have to remember to liftIO it when using it from an xmonad hook
12:22:44 <Lokathor> csd_, ah, that is code to help automatically derive different things. Essentially, if you use all the transformers and typeclasses provided by the mtl and transformers libraries, the system can figure out a great deal "automatically" for you based on those definitions
12:22:50 <geekosaur> (It could also have been String -> X (), in which case you could use it from xmonad hooks but not from main at all
12:23:05 <Lokathor> it comes into play when you begin to stack more than one monad transformer up, such as a StateT over a ReaderT over IO
12:23:51 <csd_> geekosaur: and so how exactly does instantiating MonadIO prevent you from having to use liftIO
12:24:18 <geekosaur> by itself? it doesn't. it lets you move the liftIO inside your definition instead of requiring your callers to do it
12:24:21 <Lokathor> csd_, essentially, liftIO has already been used for you inside the function
12:24:31 <csd_> oh
12:24:41 <csd_> got it
12:25:07 <csd_> thank you
12:25:50 <Lokathor> csd_, it's somewhat more confusing at first, but once you're used to it your eyes will just see past the pattern the same way that you worry less about fmap the more you see it
12:26:16 <csd_> although actually i see that the code i'm looking at is using liftIO despite using MonadIO too
12:26:30 <csd_> https://github.com/Gabriel439/Haskell-Turtle-Library/blob/master/src/Turtle/Prelude.hs#L653-L655
12:26:48 <Lokathor> when you stack up more than one transformer, you need to use lift more than once to "dig down" past each layer, if you want to bring something up
12:27:01 <Lokathor> MonadIO is setup especially so that you just have to use liftIO once
12:27:30 <Lokathor> and then since each lower level is also a MonadIO, it will in turn use liftIO, until it's been used the correct number of times automatically
12:27:32 <Welkin> I always forget if those typeclasses are in mtl or transformers
12:27:42 <Welkin> but whichever it is, it's great
12:27:54 <geekosaur> MonadIO constraint just means "hey, something in here is using liftIO"
12:27:58 <Lokathor> Welkin, mtl has the typeclasses, transformers has the newtypes (which are imported into mtl)
12:28:06 <geekosaur> you still have to use it, but you need the constraint to be *able* to use it
12:28:33 <geekosaur> "please mr. compiler make sure that liftIO will work in my function"
12:28:36 <csd_> ok
12:28:45 <csd_> thank you
12:30:46 <geekosaur> this is much the same as having to declare an Eq constraint to use (==) in a function: it tells the compiler to pass in information about how to do (==) with the type
12:35:16 * hackagebot servant-swagger 1.0.3 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.0.3 (NickolayKudasov)
12:39:38 <codedmart> can you run io stuff in STM atomically do block?
12:41:43 <liste> codedmart: no
12:41:45 <fizruk> codedmart: you can run STM stuff atomically, you can't exactly perform IO in an STM computation
12:42:22 <codedmart> OK here is what I am trying to do.
12:42:24 <codedmart> Just getting into STM stuff I have a STM.TVar (Maybe Int). If there is no Int. I make a request to a rest api to get the last int I need and write that back to the TVar. If there is an int I make a request to a rest api for some events using that int. Then I get the last int and write that to the TVar.
12:42:27 <fizruk> codedmart: you shouldn't even, but if you *really* want to, you can
12:42:58 <codedmart> The problem is the rest api is super slow to respond. We are talking up to a couple minutes.
12:43:15 <codedmart> So right not the way I have wrote it.
12:43:27 <fizruk> mint <- atomically (readTVar var)
12:43:30 <fr3tz0r> how do i do this: http://lpaste.net/9121167882682630144
12:43:43 <fizruk> codedmart: then do case mint of ...
12:44:25 <fizruk> codedmart: ah
12:44:31 <fizruk> sorry, I got it wrong
12:44:54 <codedmart> fizruk I have that but if two different people come with in a few seconds of each other they both get Nothing and then go to get the last id.
12:45:01 <codedmart> So essentially they could overwrite each other.
12:45:13 <codedmart> Not sure how to handle this properly.
12:45:21 <liste> fr3tz0r: do what exactly?
12:45:46 <fr3tz0r> save arguments to function calls
12:46:07 <codedmart> Once this happens mint <- atomically (readTVar var) and you are in the case statement it is no longer blocking right?
12:46:11 <dehaskell> i have two sets and a function f and i need to form a new set by applying f on members of the two sets, ho to do this?
12:46:26 <fr3tz0r> liste: this: function(arg after first recursion, arg after second recursion)
12:46:38 <fizruk> codedmart: right, I see your problem, don't have a solution yet
12:47:00 <codedmart> fizruk ok I will keep thinking through it. Thanks!
12:47:58 <fr3tz0r> liste: in old i would like to call auxi with arguments that i get from recursion
12:48:02 <dehaskell> anyone can help? :)
12:48:04 <fizruk> codedmart: STM transactions actually can run in parallel
12:48:21 <fizruk> codedmart: that means that if you have an http request in your STM computation
12:48:47 <fr3tz0r> liste: don't know how to handle multiple arguments? Does what I say make sense to you or is it to vague?
12:48:59 <fizruk> codedmart: it can perform several times if several "different people come within a few seconds"
12:49:23 <snowowl> how can i get the elements in order if i write something like this [x | xs <- (take 3 (repeat arr)), x <- xs]
12:49:26 <fizruk> codedmart: what you probably want is an actual block
12:49:35 <codedmart> fizruk Yeah probably.
12:50:30 <snowowl> i've been trying to find a list comprehension based solution, but this is as far as i've gotten
12:50:34 <codedmart> I could also have a boolean on the TVar that I update whether we are blocked or not. If blocked don't do anything otherwise do? Maybe? I that a bad idea?
12:50:48 <codedmart> fizruk ^^
12:50:51 <NemesisD> i'm trying to write some FFI code for a compression algorithm. i see all the bytestring/cstring conversion stuff uses IO. is there any way i could avoid this?
12:50:55 <codedmart> Something along those lines.
12:51:04 <lep-delete> :t unsafePerformIO
12:51:05 <lambdabot> Not in scope: ‚ÄòunsafePerformIO‚Äô
12:51:12 <liste> fr3tz0r: a more minimal example would help
12:51:15 <fizruk> codedmart: I am not sure what is the right tool for that, maybe MVar Bool is better than TVar Bool
12:51:29 <NemesisD> how can i tell if its a good idea to call unsafePerformIO though?
12:51:49 <lep-delete> if you know your c function is "pure"
12:51:54 <lep-delete> same output for same input
12:51:55 <codedmart> fizruk OK I am still not up to snuff on TVar vs MVar but I will look. Thanks for you info.
12:52:05 <lep-delete> which i guess compression should be
12:52:27 <NemesisD> lep-delete: that's what i'm thinking. is there something i could be looking out for in the tests to ensure this is the case? also do i need to do a NOINLINE or something?
12:52:48 <fizruk> codedmart: also if you only write once to that Int, maybe you need IVar Int, not TVar (Maybe Int)
12:53:09 <dehaskell> i have two sets and a function f and i need to form a new set by applying f on members of the two sets, ho to do this?
12:53:14 <codedmart> fizruk Well I write to it each time I get more records from the rest api.
12:53:29 <lep-delete> nah
12:55:04 <Welkin> dehaskell: fmap
12:56:17 <liste> dehaskell: one result element for each pairing of input set elements (ie. cartesian product) ?
12:56:51 <dehaskell> yes a set
12:57:46 <fizruk> > liftA2 (,) [1, 2, 3] [4, 5]
12:57:48 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
12:57:56 <liste> dehaskell: so {1, 2}¬†and {3, 4}¬†would produce {f 1 3, f 1 4, f 2 3, f 2 4} ?
12:58:19 <fr3tz0r> liste: I added one example: http://lpaste.net/9121167882682630144 
12:58:47 <dehaskell> not cartesian product
12:59:24 <fr3tz0r> I cannot move forward because idk how to do the programming concept in example
12:59:28 <liste> fr3tz0r: you can have the old value as an extra argument
13:00:05 <deni> when doing updates with persistent do I have to enumerate all the field like so: update (toSqlKey i) $ [UserFullName =. (userFullName u), UserEmail =. (userEmail u)] ???
13:00:23 <deni> it seems redundant since I already have the User data structure in the variable u
13:00:53 <deni> (i receive it as JSON to my api endpoint....and create a User instance from it)
13:01:01 <fr3tz0r> liste:can you show with an short example/line  
13:02:52 <fr3tz0r> liste: this seems impossible to me if I access one node at a time: auxi((Just (a,b)), (Just (c,d))
13:04:59 <fr3tz0r> liste: with old argument I can only think of getting this "output": auxi((Just (a,b)), auxi(Just (c,d)))
13:05:17 * hackagebot lift-generics 0.1.1 - GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation  https://hackage.haskell.org/package/lift-generics-0.1.1 (ryanglscott)
13:05:33 <csd_> anyone know of any newbie-friendly open source projects looking for contributors?
13:05:58 <liste> dehaskell: liftA2 and fromList/toList should work
13:06:12 <RevBayes> join #sdpython
13:06:54 <liste> > liftA2 (,) (ZipList [1,2,3,4,5]) (ZipList [2,3,4,5,6]) -- dehaskell if you want zipping instead of cartesian product
13:06:56 <lambdabot>  ZipList {getZipList = [(1,2),(2,3),(3,4),(4,5),(5,6)]}
13:07:19 <liste> > zip (,) [1,2,3,4,5]¬†[2,3,4,5,6] -- or just this
13:07:21 <lambdabot>      Couldn't match expected type ‚Äò[Integer] -> t‚Äô
13:07:21 <lambdabot>                  with actual type ‚Äò[(a0, Integer)]‚Äô
13:07:21 <lambdabot>      The function ‚Äòzip‚Äô is applied to three arguments,
13:07:32 <liste> > zipWith (,) [1,2,3,4,5]¬†[2,3,4,5,6] -- or just this
13:07:33 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
13:09:07 <liste> fr3tz0r: I still can't follow. it'd help if you provided an example with no Maybes or your own types but just a single function that expresses your question
13:09:09 <fizruk> csd_: most projects have newbie-friendly issues, look for a project you like and see if it has any issues tagged "newcomer"
13:10:10 <fizruk> csd_: e.g. stack has a number of "newcomer" issues: https://github.com/commercialhaskell/stack/issues?q=is%3Aopen+is%3Aissue+label%3Anewcomer
13:10:53 <fizruk> csd_: also, servant (a type-level web DSL) has a few: https://github.com/haskell-servant/servant/issues?q=is%3Aopen+is%3Aissue+label%3Anewcomer-friendly
13:10:56 <ely-se> I have a package on stackage but I want to move away all my repositories from GitHub, is that possible?
13:11:18 <dehaskell> i use arithmetic operator
13:11:23 <fr3tz0r> liste: i will give a decent example but my question regards calling another function with two arguments from the previous function 
13:11:23 <fizruk> ely-se: I think stackage gets packages from hackage, not github
13:11:33 <ely-se> fizruk: oh, I see.
13:16:13 <deni> liste: was that intended for me?
13:20:35 <fr3tz0r> liste: function2 :: a -> b -> (some of a or b) function1 :: a -> a , function1 a = function2 a; function1 a = function1 b i want function1 to call function2 a b
13:21:11 <koz_> Is there any way to modify what 'cabal init' generates by default?
13:21:33 <fr3tz0r> liste: b is a value given after on recursion cycle
13:21:38 <fr3tz0r> one
13:21:42 <kadoban> koz_: Just use 'stack new' ? You can create your own templates, set a default template, etc.
13:22:04 <koz_> kadoban: I haven't used Stack yet, but I might have to if it has this capability.
13:23:29 <YellowOnion> Could someone critque my use of the Free Monad? https://gist.github.com/YellowOnion/a5f2921aa1e330fa3afc
13:24:39 <fizruk> YellowOnion: you can reduce boilerplate with makeFree http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-TH.html
13:25:02 <snowowl> how can i get the elements in order if i write something like this [x | xs <- (take 3 (repeat arr)), x <- xs]
13:25:18 * hackagebot data-default-instances-unordered-containers 0.0.1 - Default instances for unordered-containers.  https://hackage.haskell.org/package/data-default-instances-unordered-containers-0.0.1 (PeterTrsko)
13:25:25 <YellowOnion> snowowl, thanks!
13:25:38 <snowowl> YellowOnion: wrong person probably
13:25:46 <YellowOnion> oh whoops
13:26:00 <YellowOnion> fizruk, thanks
13:26:38 <jedai> koz_: really do yourself a favor and use stack (this doesn't dispense from using the .cabal file, but everything tend to work easier)
13:26:49 <fizruk> snowowl: concat (take 3 (repeat arr)) ?
13:27:17 <fizruk> snowowl: not sure what order you mean
13:27:30 <snowowl> fizruk: say i have a list [1,2,3]
13:27:39 <snowowl> I want [1,1,1,2,2,2,3,3,3]
13:27:50 <snowowl> but i get [1,2,3,1,2,3,1,2,3]
13:28:21 <fizruk> > concatMap (take 3 . repeat) [1, 2, 3]
13:28:22 <lambdabot>  [1,1,1,2,2,2,3,3,3]
13:28:35 <koz_> concatMap is awesome like that. :)
13:28:40 <kadoban> > concatMap (replicate 3) $ [1,2,3]
13:28:41 <lambdabot>  [1,1,1,2,2,2,3,3,3]
13:28:49 <jedai> fizruk: concatMap (replicate 3)
13:28:59 <Clint> > [1,2,3] >>= replicate 3
13:29:01 <lambdabot>  [1,1,1,2,2,2,3,3,3]
13:29:09 <snowowl> concatMap never heard of it
13:29:18 <snowowl> what is the . operator?
13:29:18 <koz_> snowowl: It's very useful.
13:29:23 <snowowl> sorry i'm very new
13:29:24 <koz_> snowowl: Functional composition.
13:29:26 <fizruk> snowowl: concatMap = concat . map = (>>=) for lists
13:29:32 <jedai> snowowl: just concat . map
13:29:48 <fizruk> snowowl: (.) is function composition
13:29:54 <snowowl> ok
13:29:57 <fizruk> snowowl: (f . g) x = f (g x)
13:29:59 <koz_> (f . g) x = f (g x)
13:30:01 <snowowl> that makes sense
13:30:03 <koz_> Goddamn ninjas.
13:30:16 <jedai> snowowl: basically useful when to each element from the initial list you associate several element in the result (and don't want a list of lists)
13:30:18 * hackagebot data-default-instances-vector 0.0.1 - Default instances for types defined in vector package  https://hackage.haskell.org/package/data-default-instances-vector-0.0.1 (PeterTrsko)
13:31:02 <fizruk> > [y | x <- [1, 2, 3], y <- replicate 3 x]
13:31:04 <lambdabot>  [1,1,1,2,2,2,3,3,3]
13:31:12 <fizruk> snowowl: with list comprehension ^
13:31:17 <koz_> Lol, how many ways can #haskell solve the same problem? :P
13:31:34 <Clint> many
13:31:37 <fizruk> koz_: depends on a problem I think
13:31:37 <jedai> koz_: a lot...
13:31:45 <koz_> jedai: I can tell!
13:31:59 <koz_> Personally, I'm a fan of the list comprehension one, because it looks like set comprehension.
13:32:09 <koz_> (if you squint, <- looks like set inclusion)
13:33:52 <snowowl> fizruk: thanks, that's actually how i was trying to solve it
13:34:22 <snowowl> i'm just so set on for loops that it's hard for me to think about it in ways like this
13:34:34 <liste> fr3tz0r: you need function1 to return a tuple
13:35:22 <liste> > let f a = (2 * a, a) in [f 1, f (f 1), f (f (f 1))]
13:35:24 <lambdabot>      No instance for (Show t0)
13:35:24 <lambdabot>        arising from a use of ‚Äòshow_M451043231504845387622709‚Äô
13:35:24 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
13:36:40 <fizruk> > take 4 $ iterate (2*) [1]
13:36:42 <lambdabot>      No instance for (Show t0)
13:36:42 <lambdabot>        arising from a use of ‚Äòshow_M334569021877390865722763‚Äô
13:36:42 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
13:36:46 <fizruk> nice
13:37:18 <liste> fr3tz0r: that way you can pass the previous argument to function2
13:37:40 <fizruk> > take 4 (iterate (2*) 1)
13:37:41 <lambdabot>  [1,2,4,8]
13:40:18 * hackagebot data-default-instances-case-insensitive 0.0.1 - Default instance for CI type from case-insensitive package.  https://hackage.haskell.org/package/data-default-instances-case-insensitive-0.0.1 (PeterTrsko)
13:40:23 <koz_> What's the command to invoke our point-free-er?
13:40:26 <koz_> @pl right?
13:40:27 <lambdabot> (line 1, column 7):
13:40:27 <lambdabot> unexpected end of input
13:40:27 <lambdabot> expecting white space or simple term
13:40:55 <koz_> @pl \i -> initEx . map (drop (fromIntegral i)) . drop 1
13:40:55 <lambdabot> (initEx .) . (. drop 1) . map . drop . fromIntegral
13:41:09 <koz_> What is this I don't even.
13:42:45 <fizruk> :t initEx
13:42:47 <lambdabot>     Not in scope: ‚ÄòinitEx‚Äô
13:42:47 <lambdabot>     Perhaps you meant one of these:
13:42:47 <lambdabot>       ‚Äòinit‚Äô (imported from Data.List),
13:43:21 <koz_> fizruk: It's from classy-prelude. Same as init basically.
13:44:12 <koz_> @pl \i -> initEx . map (drop i) . drop 1
13:44:12 <lambdabot> (initEx .) . (. drop 1) . map . drop
13:46:12 <deni> does anybody have experience with https://hackage.haskell.org/package/postgresql-orm ?
13:46:57 <Gurkenglas> koz_, it's not that whatisthisidonteven: map . drop wraps it into the middle part of your top level composition, then (. drop 1) and (initEx .) each modify the function by composing another to one of its sides
13:47:44 <koz_> Gurkenglas: I guess my expression was 'goddamn that's a lot less readable'.
13:48:00 <koz_> Or at least, that was my intent. It's not the flip-art that pl can yield, certainly, I agree.
13:48:23 <koz_> @pl \a b c d e f -> b d e c f a
13:48:23 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip . (flip .))
13:48:32 <koz_> Oh, that was a lot tamer than I expected.
13:49:04 <koz_> @pl \a b c d e f -> f e d c b a
13:49:05 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
13:49:05 <Gurkenglas> koz_, would you have been happier with something like "bracket initEx (drop 1) (map . drop)"?
13:49:15 <koz_> Gurkenglas: bracket?
13:49:17 <YellowOnion> fizruk, makeFree is giving me an error, "don't know how to make Arg" not the most descriptive of errors.
13:49:44 <Gurkenglas> koz_, "something like" - if it existed, would you be happier with it?
13:50:14 <fizruk> YellowOnion: can you paste the code?
13:50:52 <fizruk> YellowOnion: also I agree that TH code is old and not very good
13:52:05 <YellowOnion> fizruk, its literally just the old code with makeFree ''BFMonad added, I suspect its something to do with the Block ont line 30
13:52:39 <koz_> Gurkenglas: Well, yeah, why?
13:54:12 <fizruk> YellowOnion: can you paste the whole error message?
13:54:26 <Gurkenglas> I wanted to ask because I guessed that to be as readable as the . version, but also expected you to be happier with it
13:54:34 <RyanGlScott> Speaking of which, fizruk
13:54:36 <fizruk> YellowOnion: I really doubt it is caused by Block
13:54:44 <RyanGlScott> How is makeFree supposed to work when you give it a GADT?
13:54:56 <RyanGlScott> e.g., data Foo a where Foo :: Int -> Foo Int
13:55:36 <Gurkenglas> YellowOnion, why use IORefs instead of the State monad?
13:55:44 <YellowOnion> fizruk, that is the whole error message, appart from the line numbers.
13:55:47 <RyanGlScott> Actually, bad example, since that can't be a Functor
13:55:49 <fizruk> RyanGlScott: well, there is an example with GADTs: http://hackage.haskell.org/package/free-4.12.4/docs/examples/RetryTH.hs
13:56:28 <RyanGlScott> I'm asking since I'm trying to fix free for GHC 8.0, as it changed the TH rerpesentation of GADTs
13:56:30 <fizruk> RyanGlScott: can't it?
13:56:44 <RyanGlScott> And by GADT, I mean one where one of the type variables if refined to a particular type
13:56:46 <fizruk> RyanGlScott: yeah, I've seen the issue
13:56:52 <RyanGlScott> Not just a Haskell98 data constructor in disguise
13:56:57 <RyanGlScott> Like in the example
13:57:11 <fizruk> RyanGlScott: yes, I think I had an example of what you're talking about too
13:57:48 <YellowOnion> Gurkenglas, not sure, its easier to write just in the IO monad I guess.
14:00:11 <hsk3> foldr (+) 0 [1,2,3,4] = 1 + (2 + (3 + (4 + 0))).
14:00:11 <hsk3> Why doesn't foldr pile things up in memory just like foldl does? I don't get it. It seems to me foldr has to pile things up too. Nothing can be evalulated until it reaches to right-most parantheses. Those 1, 2, 3 have to pile up in memory right?
14:00:27 <mauke> yes
14:00:54 <hsk3> So then why is foldr not considered this huge memory leak issue like foldl?
14:01:02 <fr3tz0r> liste: i cannot access two values at the same time, so i tuple isn't the solution, i can access one argument each recursive step and i need two arguments to pass to the function from two different recursive steps
14:01:38 <jedai> hsk3: It depends on the function
14:02:12 <jedai> hsk3: for (+) it is definitely very bad but for (&&) for instance it works in constant memory
14:02:59 <YellowOnion> fizruk, removing the Block removes the error, so its definitely to do with that.
14:03:22 <RyanGlScott> OK, here's a better example, fizruk
14:03:27 <RyanGlScott> data Foo a b where Foo :: b -> Foo Int b deriving Functor
14:03:41 <RyanGlScott> On GHC 7.10 and earlier, $(makeFree ''Foo) would generate
14:04:08 <RyanGlScott> foo :: forall m_a9xs a_a87C. (a_a87C ~ Int, MonadFree (Foo a_a87C) m_a9xs) =>m_a9xs (); foo = liftF (Foo ())
14:04:12 <jedai> hsk3: because (a && b) either returns immediately (for a == False) which correspond to a short circuit of the foldr, or can forget the a after checking it (which means the beginning of the list don't need to stay in memory)
14:04:43 <RyanGlScott> But on GHC 8.0, Foo wouldn't reify as a ForallC, so you don't get the (a_a87C ~ Int) constraint as easily
14:04:49 <jedai> hsk3: which is why "and = foldr (&&) True" is pretty much optimal
14:05:01 <hsk3> Ok, I just noticed foldl (+) 0 [1..1e7] seems to be just as bad as foldr (+) 0 [1..1e7]
14:05:01 <hsk3> Does that sound right?
14:05:31 <jedai> hsk3: well that's because it build a thunk but if you use foldl' instead, it will be far better than foldr
14:05:34 <liste> fr3tz0r: why not? you'd use the tuple to just pass the previous argument
14:05:54 <jedai> hsk3: this is linked to lazyness
14:06:32 <fr3tz0r> liste: it isn't accessible before i patternmatch it
14:06:44 <jedai> hsk3: You almost _never_ want to use foldl. Either your function is lazy enough and foldr is better, or your function is very strict and foldl' will be the best
14:07:09 <fr3tz0r> liste:i have to make another example and thinking throughly this time 
14:07:23 <hsk3> jedai: thanks, makes sense
14:07:29 <fizruk> YellowOnion: sorry about that, looking at the code of makeFree and it looks rather suspicious to me...
14:07:46 <jedai> hsk3: you can read more details on https://wiki.haskell.org/Foldr_Foldl_Foldl'
14:07:59 <jedai> hsk3: You're welcome :)
14:08:38 <fizruk> RyanGlScott: can you point me to the template-haskell haddocks for GHC 8?
14:09:36 <fizruk> RyanGlScott: also, maybe while you're at it, you could clean my my mess there? :)
14:09:37 <RyanGlScott> fizruk: Sure, it's kind of hidden on Hackage ATM: http://hackage.haskell.org/package/template-haskell-2.11.0.0/candidate
14:09:51 <Sonarpulse> hmm attoparsec says I am not at the end of input
14:09:58 <Sonarpulse> but then i do takeText
14:10:00 <RyanGlScott> fizruk: My problem is that I barely understand what's going on in the code right now
14:10:02 <Sonarpulse> and get an empty text
14:10:23 <RyanGlScott> It seems to be inferring a type signature by doing some crazy unification algorithm
14:10:35 <fizruk> RyanGlScott: I have written that code a few years back, so I sort of feel the same way :)
14:11:02 <RyanGlScott> Well, the bad part is that with a GadtC, you don't get (a ~ Int), when you reify, all you get is the return type Foo Int b
14:11:10 <RyanGlScott> So you have to infer the constraints yourself
14:11:25 <fizruk> RyanGlScott: ok, let me look into this
14:11:40 <RyanGlScott> Thanks fizruk, I appreciate it
14:12:03 <fizruk> RyanGlScott: also is there an easy way to build free with GHC 8 on my machine?
14:12:13 <fizruk> RyanGlScott: preferrably with stack?
14:12:41 <RyanGlScott> fizruk: I don't know about stack, but free and all its dependencies support GHC 8.0 if you get the latest versions on Hackage
14:12:58 <RyanGlScott> I believe there's a stack resolver for using a GHC version
14:13:00 <fizruk> RyanGlScott: I mean I don't have GHC 8 locally
14:13:07 <RyanGlScott> fizruk: What OS do you have?
14:13:20 <fizruk> OS X
14:20:32 * hackagebot frown 0.6.2.1 - LALR(k) parser generator  https://hackage.haskell.org/package/frown-0.6.2.1 (MatthewFarkasDyck)
14:22:15 <fragamus> I was on here a while back and there was discussion about alternatives to monad transformers. What is the new thing that all the cool kids use
14:24:21 <geekosaur> extensible effects?
14:24:40 <fragamus> whats that
14:25:56 * hackagebot frown 0.6.2.2 - LALR(k) parser generator  https://hackage.haskell.org/package/frown-0.6.2.2 (MatthewFarkasDyck)
14:29:54 <Cocolates> join #haskell
14:31:03 <Cocolates> @help
14:31:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:31:27 <Cocolates> :t flip 
14:31:28 <lambdabot> (a -> b -> c) -> b -> a -> c
14:32:55 <Cocolates> @pl \x y -> filter y p
14:32:55 <lambdabot> const (flip filter p)
14:33:07 <Cocolates> @pl \x y -> filter y x
14:33:07 <lambdabot> flip filter
14:33:08 <jmcarthur> Cocolates: Maybe do that in a private session with lambdabot?
14:37:44 <obadz> is taggy the canonical html parser out there?
14:42:38 <srpx> If I'm developing something with real (not 100%, but plausible) chances of evaluating haskell programs much faster than GHC, and I can show concrete evidence to it, is there any way in the world for me to get funding so I can work on it? ...
14:43:38 <veverak> hi folks, what is proper way to use list comprehesion to define list such as 'x' is even number, and is present (x % 12) times in the list 
14:43:43 <veverak> I could create list of lists to make this
14:43:49 <veverak> but there should be way to make it one list
14:44:01 <benzrf> this sounds like a good case for comonads to me
14:44:01 <srpx> Not a lot, just enough so I could dedicate myself to this project u.u
14:45:15 <srpx> (moving this to haskell-blah)
14:45:33 <veverak> yeah!
14:45:37 * veverak maybe figured out a way
14:46:33 <veverak> if I use two sources in list comprehension, one going y=[0...11] and second x=[1....] I can create it :), one condition is that x is even and second that y <= x % 12
14:50:52 <jb55> obadz: I believe so, I've used it a lot with great success
14:53:05 <puregreen> is there any way to use a Name in a splice without having to wrap it in $(varE name) or something similar?
14:53:34 <obadz> jb55: thx
14:53:38 <stelleg> any good reason for CArray not being Foldable?
14:53:38 <puregreen> e.g. I have [|T.pack $(varE name)|], but I want something simpler, like [|T.pack $$name|]
14:53:47 <puregreen> or is it impossible even in principle?
14:54:07 <obadz> stelleg: probably has a Storable constraint of some sort on the elements
14:56:29 <stelleg> obadz: hmm
15:09:23 <jmcarthur> Sweet. I have an implementation of coroutine that gets compiled away entirely as long as you force everything to inline. I just wish it wasn't necessary to add INLINE pragmas everywhere.
15:09:47 * jmcarthur has found that liberal use of INLINE is often necessary to get ghc to generate fast executables :\
15:11:15 <shachaf> I think there's a trend of over-INLINING without checking that it helps.
15:11:27 <montanonic> What's the potential downside to INLINE?
15:11:29 <shachaf> So I'm glad you checked.
15:11:52 <ThatTreeOverTher> Larger executable size?
15:11:57 <jmcarthur> montanonic: You can actually make things slower if you aren't selective about it.
15:12:08 <jmcarthur> montanonic: It's hard to think about sometimes.
15:12:19 <montanonic> jmcarthur: oh, okay. I just see some libraries that use it in basically every single function
15:12:21 <jmcarthur> montanonic: Sometimes you have to restrict inlining to certain phases of optimization, even.
15:12:48 <shachaf> I think I've mostly seen that in combination with rewrite rules.
15:13:08 <obadz> is there a traversal from [Maybe a] to [a] where the Nothings are just dropped?
15:13:19 <jmcarthur> Yeah. I think rewrite rules are the only reason phase control matters at all.
15:13:20 <Gurkenglas> :t catMaybes
15:13:21 <lambdabot> [Maybe a] -> [a]
15:13:52 <jmcarthur> :t foldMap toList  -- but catMaybes is better
15:13:53 <lambdabot>     Ambiguous occurrence ‚ÄòtoList‚Äô
15:13:53 <lambdabot>     It could refer to either ‚ÄòLambdabot.Plugin.Haskell.Eval.Trusted.toList‚Äô,
15:13:53 <lambdabot>                              imported from ‚ÄòLambdabot.Plugin.Haskell.Eval.Trusted‚Äô at /home/lambda/.lambdabot/State/L.hs:125:1-59
15:13:59 <obadz> Gurkenglas: looking for something composable with lenses
15:14:00 <shachaf> What's your coroutine thing?
15:14:24 <Gurkenglas> obadz, that would violate the traversal laws - traversals must not delete elements
15:14:52 <obadz> Prism then
15:14:57 <obadz> whichever one is most general
15:14:59 <jmcarthur> shachaf: It's just, for now, half of an implementation of pipes, in that it only has one channel of communication instead of two.
15:15:13 <stelleg> obadz: oh yeah, I see what you were saying now, duh
15:15:14 <jmcarthur> It works with a bunch of Cont junk.
15:15:17 <Gurkenglas> Prisms are merely traversals over 0 or 1 element
15:15:26 <stelleg> obadz: thanks!
15:15:40 <jmcarthur> That's oversimplifying...
15:16:01 <django_> whats something cool i can build lol
15:16:04 * hackagebot monad-parallel 0.7.2.1 - Parallel execution of monadic computations  https://hackage.haskell.org/package/monad-parallel-0.7.2.1 (MarioBlazevic)
15:16:06 * hackagebot monad-coroutine 0.9.0.2 - Coroutine monad transformer for suspending and resuming monadic computations  https://hackage.haskell.org/package/monad-coroutine-0.9.0.2 (MarioBlazevic)
15:16:17 <jmcarthur> But it may be that my current implementation could be simplified anyway, so I don't think it's worth explaining in detail yet.
15:16:39 <shachaf> Some sort of Free variant?
15:17:13 <obadz> Gurkenglas: you're saying it's impossible to zoom from [Maybe a] to [a] ?
15:17:22 <jmcarthur> No, or at least not explicitly and not in a way that I can obviously relate to Free yet.
15:18:29 <Gurkenglas> obadz, what do you want to do with it? Do you mean zoom in the lens-specific sense?
15:19:00 <obadz> Gurkenglas: I'm looking for a tag with taggy-lens
15:19:05 <shachaf> Did you see how concurrency is implemented in Hugs, by the way?
15:19:09 <jmcarthur> Well, okay, I think I could relate it back to Free pretty easily, but I wouldn't say it's actually a Free monad.
15:19:23 <jmcarthur> How is concurrency implemented in Hugs?
15:19:27 <shachaf> It was pretty nice and simple, co√∂perative threads with no runtime support.
15:19:33 <jmcarthur> Neat.
15:19:34 <obadz> Gurkenglas: html' ^.. to (decodeUtf8With lenientDecode) . html . allNamed (only "input") . allAttributed (folded . only "authenticity_token") . attr "value" returns a [Maybe Text]
15:19:35 <shachaf> If I remember correctly.
15:19:56 <obadz> Gurkenglas: I would just like a Maybe Text instead which is the first non-Nothing Text in there
15:20:22 <jb55> obadz: just hit it with a `. traverse . _Just`
15:20:50 <shachaf> I think implementing fork takes you away from the Free model, though?
15:21:03 <shachaf> Actually I don't remember.
15:21:14 <obadz> jb55: . traverse gets me to [Text]
15:21:19 <obadz> jb55: so does . _Just
15:21:53 <jb55> obadz: that's what you wanted right?
15:22:01 <obadz> jb55: I'd like a Maybe Text
15:22:13 <obadz> jb55: I think I need a . ix 0 somewhere in there
15:22:31 <Gurkenglas> :t firstOf
15:22:32 <lambdabot> Getting (Leftmost a) s a -> s -> Maybe a
15:22:39 <obadz> jb55: that seems to look at the first character in the string..
15:23:10 <Gurkenglas> That and ". _Just". When you said "Prism", you wanted "Fold" (i think)
15:23:14 <jmcarthur> shachaf: So this is in sort of a finally tagless style, in that there is a type class and a bunch of types for implementing different operations. The one type class I have is a lot like a specialized version of MonadFree, though.
15:23:48 <jmcarthur> shachaf: Anyway, this style works out nicely for optimizations, because the compiler gets to choose the optimal representation for each operation you apply.
15:24:43 <obadz> jb55 / Gurkenglas - somehow I don't think these filters should come at the very end of the lens..
15:25:01 <Gurkenglas> > firstOf (traverse . _Just) [Nothing, Just 3] -- huh needed another traverse
15:25:03 <lambdabot>  Just 3
15:25:08 <jmcarthur> shachaf: I guess as soon as I define a newtype for   forall m. MyClass m => m a   I have a free monad, but I haven't done that and am not sure it's necessary.
15:25:34 <Gurkenglas> > firstOf (_1 . traverse . _Just) ([Nothing, Just 3], "bla") -- yes they do obadz :D
15:25:36 <lambdabot>  Just 3
15:25:53 <jb55> obadz: first = preview (traverse.f)
15:25:55 <jmcarthur> Ah, it would be necessary to avoid impredicative types in some cases, I guess.
15:26:10 <jb55> I had this lying around somewhere...
15:26:24 <jb55> obadz: first f = preview (traverse.f)
15:26:59 <jb55> might be the same as firstOf...
15:27:28 <Gurkenglas> Oh sure preview works as well as firstOf. (preview is a little more general though, it works with any MonadReader)
15:28:15 <jb55> type sig is `first :: (MonadReader (t s) m, Traversable t) => Getting (First r) s r -> m (Maybe r)`
15:28:20 <jb55> not sure if that's what you want
15:28:45 <obadz> jb55 / Gurkenglas - Get get a type error when I append . traverse . _Just at the end. Couldn't match Maybe a with Text.
15:28:52 <obadz> s/Get/I/
15:29:17 <obadz> 2ndly, where would you put the firstOf in this chain: Œª> html' ^.. to (decodeUtf8With lenientDecode) . html . allNamed (only "input") . allAttributed (folded . only "authenticity_token") . attr "value" ?
15:30:01 <Gurkenglas> preview (to (decodeUtf8With lenientDecode) . html . allNamed (only "input") . allAttributed (folded . only "authenticity_token") . attr "value" . traverse . _Just) html'
15:31:37 <obadz> Gurkenglas: wow that first
15:31:39 <obadz> works
15:31:41 <jb55> yeah preview is super useful, I find myself using it a lot
15:32:02 <obadz> so erm, how come I didn't need firstOf ?
15:32:26 <obadz> (btw that works without the . _Just at the end)
15:33:14 <jb55> also #haskell-lens ;)
15:34:54 <obadz> Haskell's ability to make me feel stupid is really depressing..
15:36:08 <obadz> hmmmm given that there's no firstOf I suspect it is concatenating the bytestrings (via Monoid) rather than actually picking the first element
15:39:24 <obadz> ah firstOf is a substitute to preview it looks like
15:43:19 <koz_> @pl \x -> if x == "foo" then "bar" else x
15:43:19 <lambdabot> flip if' "bar" =<< ("foo" ==)
15:49:07 <crossroads1112> @src concat
15:49:07 <lambdabot> concat = foldr (++) []
15:50:06 <fragamus> extensible effects looks great
15:50:19 <fragamus> is there anyone who does not like it
15:51:04 <crossroads1112> @src foldr
15:51:04 <lambdabot> foldr f z []     = z
15:51:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:51:13 <crossroads1112> @src foldl
15:51:14 <lambdabot> foldl f z []     = z
15:51:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:51:19 <crossroads1112> @src foldl'
15:51:19 <lambdabot> foldl' f a []     = a
15:51:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:54:57 <Gurkenglas> > preview traverse [Nothing, Just 3] -- obadz, yes you do need _Just.
15:54:59 <lambdabot>  Just Nothing
15:55:03 <Gurkenglas> > preview traverse [Just 3, Nothing] -- obadz, yes you do need _Just.
15:55:05 <lambdabot>  Just (Just 3)
15:55:57 <obadz> > preview _Just [Just 3, Nothing]
15:55:59 <lambdabot>      Couldn't match type ‚Äò[Maybe a0]‚Äô with ‚ÄòMaybe a‚Äô
15:55:59 <lambdabot>      arising from a functional dependency between:
15:55:59 <lambdabot>        constraint ‚ÄòMonadReader (Maybe a) ((->) [Maybe a0])‚Äô
15:56:23 <Gurkenglas> > preview (traverse . _Just) [Just 3, Nothing]
15:56:24 <jb55> > preview (traverse._Just) [Nothing, Just 3]
15:56:25 <lambdabot>  Just 3
15:56:26 <lambdabot>  Just 3
15:56:28 <obadz> in my case it works with either traverse or _Just but not both
15:56:59 <obadz> https://gist.github.com/obadz/6750ee608bf0c10c10e4
15:57:34 <jb55> yeah you probably don't need that just in that context
15:57:51 <jb55> unless for some reason attr returned a maybe which would be odd
15:57:57 <jb55> since it's probably a prism
15:58:05 <jb55> or traversal
15:58:39 <Gurkenglas> What is the type of 'to (decodeUtf8With lenientDecode) . html . allNamed (only "input") . allAttributed (folded . only "authenticity_token") . attr "value"ƒ?
16:00:37 <obadz> Gurkenglas: it's   :: (Applicative f, Contravariant f) =>
16:00:40 <obadz>      (Maybe Text -> f (Maybe Text)) -> BL.ByteString -> f BL.ByteString
16:01:21 <obadz> so a Prism (?) from BL.ByteString -> Maybe Text
16:01:25 <Gurkenglas> Ah so you didnt need to go from [Maybe Text] to [Text] or Maybe Text, but from Maybe Text to Text
16:01:39 <obadz> yeah I guess the [] came from ^..
16:01:49 <jb55> ^.. is just toListOf infix
16:02:06 <jb55> basically does the traversal and collects it into a list
16:02:23 <obadz> replacing by firstOf fixes that
16:02:31 <obadz> and _Just at the end gets rid of Maybe
16:02:35 <Gurkenglas> :t typeSeq (undefined :: Prism' s a) -- nope
16:02:36 <lambdabot> (Applicative f, Choice p) => p a (f a) -> p s (f s)
16:02:45 <obadz> I just wish it didn't make my brain explode in the process
16:02:56 <Gurkenglas> :t typeSeq (undefined :: Fold s a)
16:02:57 <lambdabot> (Applicative f, Contravariant f) => (a -> f a) -> s -> f s
16:03:07 <jb55> you guys don't have these memorized yet? lol
16:03:45 <Gurkenglas> Why doesn't ghc try to turn the latter into the former?
16:04:28 <jb55> could be ambiguous depending on context, but yeah ghc could be smarter about it
16:04:28 <obadz> I think it tries to keep the type alias but if ever expands it it can never backtrack
16:05:37 <Gurkenglas> :t prism -- doesn't look like it
16:05:38 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
16:05:54 <csd___> What is the purpose of `forall` as used in newtype Shell here https://github.com/Gabriel439/Haskell-Turtle-Library/blob/master/src/Turtle/Shell.hs#L84 ?
16:06:00 <Gurkenglas> "prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b" https://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Prism.html#v:prism
16:06:30 <django_> what do you guys for a living
16:06:56 <Welkin> django_: bounty hunter
16:07:03 <Gurkenglas> We're parking on every haskell job that exists. Assassinate any of us and you're settled
16:07:08 <django_> lol
16:07:12 <jb55> pmuch
16:08:03 <jb55> I get to code haskell at work because people can't tell me otherwise bwahaha
16:08:49 <django_> jb55, which sort of software do you work on
16:09:27 <jb55> music industry stuff
16:10:02 <Welkin> he programs vocaloids
16:10:11 <Welkin> taylor swift is just a robot
16:10:19 <Derya> hi
16:10:37 <jb55> Welkin: shh
16:12:25 <NeverDie> Hello fellow Haskellers. 
16:13:03 <Gurkenglas> (I don't actually have a job. Just a student.)
16:14:32 <jb55> you're hired
16:14:43 <puregreen> oh oh hire me too
16:14:46 <jb55> done
16:14:56 <ggVGc> I'm guessing the salary is fairly low
16:14:58 <Gurkenglas> What do we do?
16:15:07 <jb55> ggVGc: you got it
16:15:25 <Gurkenglas> Pls let it be refactoring code into style that appeals to me
16:15:28 <jb55> Gurkenglas: mostly javascript
16:15:42 <Gurkenglas> You're cofired.
16:16:15 <NeverDie> jb55: Hire me too, thanks.
16:16:18 <jb55> The old Haskell bait and switch into js, works everytime on unsuspecting interns
16:16:19 <django_> Gurkenglas, what do you use haskell for?
16:25:24 <Gurkenglas> What I apply it to that comes closest to not serving itself is umm some cs homework stuff that they expect you to find the answers for with a little coding, recently this thing http://lpaste.net/148166 to fetch some game stats out of a forum quest
16:26:05 <Welkin> Gurkenglas: O.o is that English?
16:26:23 <Welkin> it reads like something generated by a chatterbot
16:28:41 <Gurkenglas> How long have you been generated?
16:30:57 <monochrom> haha
17:07:18 <deech> Is there any way to get the stack resolver a range of versions?
17:07:48 <geekosaur> wouldn't that kinda defeat the purpose?
17:08:26 <deech> geekosaur: My package is compatible with any GHC >= 7.8.1. 
17:11:06 <deech> Wait, s/get/give
17:12:49 <geekosaur> wondering if you're confusing the resolver (which specifies a known-compatible compiler+package versions as a base) with the compatibility info in the cabal file
17:13:03 <Gurkenglas> Oh wait looks like googling for a word i remember using on lpaste.net while it's down wasnt the best idea. django_, I meant this http://lpaste.net/148381
17:13:38 <django_> ?? Gurkenglas 
17:13:38 <lambdabot>  Gurkenglas
17:13:55 <hiratara> It seems that you should provide stack-7.8.yaml and stack.yaml
17:14:33 <Gurkenglas> (A thing I made using Haskell that doesn't serve Haskell. The above 148166 link was a stub.)
17:16:07 <zedbourbaki> hey everyone :) It's been a while since I had anytime to learn/code in Haskell - last time I checked in, I was in to learn more about how to use stack. Now I decided to start a new project, and its throwing me this issue ( https://github.com/atom-haskell/haskell-ghc-mod/issues/86 ). I am not sure what is the best way out... DAE ever dealt with that?
17:21:08 * hackagebot hOpenPGP 2.4.3 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.4.3 (ClintAdams)
17:32:30 <Lokathor> using esquelto, i have a type that's a Text and Int. I want to look in the DB for a row with a matching Text, and if it's there add 1 to the Int, and if it's not add a new entry with an Int of 1
17:34:11 <davidthomas> Lokathor: sounds like you want upsert?
17:34:41 <Lokathor> I'm not seeing that in Database.Esquelto
17:34:46 <Lokathor> should i look in another module?
17:34:59 <davidthomas> it's in the index, but not linked, hmm
17:35:05 <davidthomas> ah
17:35:09 <davidthomas> belongs to PersistUnique
17:37:31 <Lokathor> i found PersistUnique, but i still can't see where upsert is
17:38:30 <Lokathor> i guess insertUnique and then a case works
17:38:55 <davidthomas> http://haddock.stackage.org/lts-5.1/persistent-2.2.4/Database-Persist-Class.html#t:PersistUnique
17:40:02 <Lokathor> oh yikes, google gave me the 0.9 version >_>
17:41:11 <Welkin> Lokathor: never trust google
17:41:18 <Lokathor> okay so this is my template, http://lpaste.net/151847
17:41:20 <Welkin> use hayoo like the rest of us
17:41:32 <Lokathor> how do i label the command as being a Unique element?
17:41:46 <vx999> if I've wrapped a list in a newtype, how do I expose list operations like !! ?
17:42:11 <KaneTW> :t (!!)
17:42:13 <lambdabot> [a] -> Int -> a
17:42:19 <KaneTW> you'll have to define your own
17:42:31 <jle`> that's sort of the "point" of newtypes, in a sense
17:42:37 <Gurkenglas> Use Data.Coercible's coerce
17:42:51 <jle`> yeah, you can do that if the constructor is exported
17:43:11 <jle`> so that makes things a little more convenient than manually wrapping and unwrapping :)
17:43:27 <KaneTW> i need a cross-platform gui package for haskell
17:43:37 <KaneTW> not sure what's current
17:43:52 <jle`> i use html5+js
17:44:10 <Welkin> KaneTW: there is GTK, Qt, wx, or you can build your own using SDL
17:44:30 <KaneTW> the current solution i have is C++/Qt
17:44:41 <KaneTW> it's really ugly though
17:45:01 <Lokathor> answer to my own question: http://www.yesodweb.com/book/persistent
17:45:33 <vx999> KaneTW best UI option in haskell is probably via web front end..
17:45:36 <KaneTW> basically i need to display a table, some related data, and jump around in the table as items are scanned (eg with a barcode scanner)
17:45:39 <KaneTW> that's what i heard
17:45:41 <Welkin> Lokathor: what was your question?
17:46:13 <sm> KaneTW: if not web, http://hackage.haskell.org/package/hsqml seems worth a try
17:46:22 <Welkin> Lokathor: and yes, you will find a lot of answers in the yesod book for persistent, as well as on the yesod github wiki
17:46:24 <Lokathor> Welkin, i want to track commands input and how many times people have tried them, so i'm pairing Text with Int, and using persist. The question was how to make a Unique key
17:46:27 <KaneTW> ty
17:46:49 <vx999> KaneTW it's true. sm maybe an option but aren't those qml bindings kind of out of date?
17:47:05 <sm> or you can go old school and give a text ui
17:47:06 <vx999> i'm not too confident in the future of Qt these days, but i guess if it's a personal project that's not a huge deal
17:47:11 <KaneTW> well
17:47:21 <KaneTW> it's certainly a project only i ever will be working on
17:47:25 <KaneTW> but it's not really personal
17:47:32 <KaneTW> i'm fine with web ui
17:47:33 <vx999> KaneTW if you really need a desktop app, you can do like wagon and wrap the web front end in Electron
17:47:37 <sm> vx999: eh maybe, I had the impression this project was being maintained
17:47:38 <KaneTW> as long i can make it responsive
17:47:52 <Welkin> KaneTW: lol what? web buzzwords?
17:47:55 <KaneTW> no
17:48:03 <KaneTW> responsive as in
17:48:06 <vx999> responsive as in fast
17:48:08 <KaneTW> yeah
17:48:08 <Welkin> oh, fast
17:48:27 <Welkin> you can use threepenny-gui I think
17:48:37 <KaneTW> i'll take a look
17:48:40 <vx999> yeah, especially coming from C++/Qt in previous projects  i have high standards for responsive...
17:48:47 <sm> the problem with haskell GUI solutions is we have so many :)
17:48:48 <Welkin> that is for using the browser as a rendering engine for your local application
17:49:14 <Welkin> the browser is probably the slowest thing you could use though
17:49:19 <Welkin> a slow, bloated beast
17:49:27 <vx999> sm and none of them are good =/ it pains me to see cutting edge haskell done with FLTK as the gui toolkit
17:49:35 <vx999> cmon that FLTK shit looks like it's from 1992
17:49:48 <sm> Welkin: that may be true for load time, but not when interacting with the gui
17:49:48 <Welkin> it's like starting up a VM to run your program
17:49:55 <vx999> i'm looking forward to the day when haskell & purescript interop smoothly with frameworks like - http://sharkdp.github.io/purescript-flare/
17:50:15 <Lokathor> Alright, does this look sane so far? http://lpaste.net/151848
17:51:01 <sm> plus, most of us have a browser running 24x7 so starting your web gui app is just a quick new tab
17:51:02 <Lokathor> whoops, forgot to return the Int
17:51:09 <vx999> time to push the numerical computing libraries in haskell
17:51:14 * vx999 braces for pain and disappointment
17:51:16 <Welkin> Lokathor: which part?
17:51:16 <KaneTW> this is going to run on computers that do nothing but run that app
17:51:25 <Welkin> Lokathor: the model definition?
17:51:29 <carter_cloud> Working on it vx999
17:51:30 <Lokathor> Welkin, well, the whole thing i guess
17:51:59 <Lokathor> i've never used persist at all before today other than to glance at a tutorial
17:52:27 <Welkin> Lokathor: looks fine to me
17:52:35 <KaneTW> threepenny looks fine i think
17:52:53 <zedbourbaki> vx999: which library ? i heard numerical computing and i'm curious now
17:53:03 <sm> is there any relationship between threepenny-gui and reactive-banana, aside from their author ?
17:53:24 <KaneTW> threepenny has a bit of frp going on it seems
17:53:50 <solirc> Big_G: You may want to look at https://github.com/hspec/hspec-example
17:54:19 <carter_cloud> Hehe it's a huge space.
17:55:53 <peddie> vx999: I encourage you to ask questions here or in #numerical-haskell if you run into any problems
17:56:15 <carter_cloud> Indeed.
17:56:30 <domgetter> In the Category Hask, the objects are types, and the arrows are structure-preserving functions.  My question is, what structure are the morphisms preserving in this category?  For example, if we let f x = True (where x is an int), is this a morphism from Num to Bool, and if so, how can we tell that it preserved structure?
17:56:43 <carter_cloud> I'm working on a few tools in that area ... But kinda got hosed with building a new language at work
17:57:04 <Welkin> vx999: that purescript library looks cool
17:57:12 <scshunt> domgetter: where did you hear that definition of Hask?
17:57:14 <Welkin> too bad I don't like purescript though
17:57:49 <zedbourbaki> carter_cloud: building a new language? tell us more!
17:57:54 <domgetter> scshunt: https://wiki.haskell.org/Hask#Is_Hask_even_a_category.3F
17:58:15 <domgetter> Sorry, here's the top of that page: https://wiki.haskell.org/Hask
17:58:25 <KaneTW> domgetter:  "the morphisms from objects A to B are Haskell functions of type A -> B"
17:58:28 <vx999> zedbourbaki i'm bouncing around between a few libs. hmatrix, repa, random-fu, ad
17:58:29 <scshunt> domgetter: where did you get the "structure-preseriving" bit from?
17:59:24 <vx999> zedbourbaki I started exploring repa and then realized i can't even pretty-print a matrix ... and hightailed back to hmatrix :(
18:00:08 <domgetter> scshunt: a morphism is a structure-preserving map between objects in a category.  Not all maps between groups preserve structure in the category of groups, but the ones that do are morphisms (specifically homomorphisms).  So I'm wondering if there are Haskell functions which are not morphisms
18:00:18 <zedbourbaki> vx999: so you're deciding on a project, if I understand correctly?
18:00:24 <jle`> domgetter: hm, that's not the definition of "morphism" in category theory
18:00:36 <jle`> you might be mixing it up with a separate and unrelated definition of morphism
18:00:47 <vx999> zedbourbaki no project is known... fitting some time series stochastic models, then forward simulating them
18:01:31 <zedbourbaki> vx999: sounds finance-y
18:01:46 <vx999> zedbourbaki no... think more squishy ;)
18:01:50 <peddie> vx999: if there is no package to convert between a Repa manifest array and an hmatrix matrix, both are Storable vectors under the hood, I think, so with a little work you could pretty-print ;)
18:01:51 <jle`> in category theory, a morphism is just a 'thing' that has an associated domain and codomain, with the appropriate binary function (composition) and associated identities
18:01:54 <domgetter> I guess all I'
18:02:03 <jle`> with respect to the idea of morphisms
18:02:14 <jle`> morphisms aren't required to "preserve" any sort of structure
18:02:20 <KaneTW> the structure-perserving part doesn't make sense in the context of haskell
18:02:36 <vx999> peddie there's workarounds to pretty print repa matrices. but it was just a wake up as to just how immature the library is. there's no built in function to show each matrix row... on a separate line.
18:02:36 <domgetter> I guess all I'm asking is, since not all functions between groups are morphisms, is the same true in Hask?  That is, are there haskell functions which are not morphisms in Hask?
18:02:52 <peddie> vx999: yeah, no, I get it :)
18:03:04 <KaneTW> technically, yes. practically, you ignore bottom values, so no
18:03:15 <peddie> vx999: there are very specific things you can do with it
18:03:27 <jle`> domgetter: perhaps you're thinking about homomorphisms?
18:03:35 <jle`> because functions between groups can be considered morphisms by definition
18:03:47 <domgetter> jle`: homomorphisms are morphisms in the category of groups
18:03:47 <jle`> depending on what category you're talking about
18:03:48 <vx999> peddie actually idontgetoutmuch had a solution here which probably should go into some sort of repa-extra lib : http://stackoverflow.com/questions/34714306/haskell-repa-is-there-a-way-to-pretty-print-matrices
18:04:10 <jle`> domgetter: you can define a category where morphisms are homomorphisms
18:04:14 <jle`> but that's not true for all categories
18:04:16 <vx999> peddie what do you mean specific things? parallelism?
18:04:20 <peddie> vx999: good idea
18:04:23 <jle`> lots of categories have morphisms that aren't structure preserving or homomorphisms
18:04:32 <vx999> zedbourbaki are you doing any numerics with haskell?
18:04:32 <lpaste> adas pasted ‚Äútoo much repetition‚Äù at http://lpaste.net/151849
18:04:42 <jle`> haskell functions are morphisms in hask by definition
18:04:43 <shachaf> "homomorphism" just means "arrow in a category"
18:05:13 <adas> ^^^ is there some way to reduce the repetitive functions in that lpaste?
18:05:20 <peddie> vx999: yeah, I mean, certain array/matrix operations are a good fit for what Repa lets you do easily and can do quickly for you
18:05:23 <jle`> Hask is *defined* as the category where the objects are types and the morphisms are functions between types
18:05:27 <domgetter> shachaf: that's what a morphism is, not a homomorphism
18:05:28 <jle`> so all haskell functions are morphisms, by definition
18:05:52 <jle`> that's like talking about the set of all natural numbers N, and asking if there are any numbers in N that aren't natural numbers
18:06:03 <KaneTW> morphism is just an abstraction of homomorphism
18:06:06 <jle`> *are morphisms in Hask
18:06:11 <shachaf> Well, it's silly to argue about words.
18:06:13 <vx999> peddie do you know much about that hmatrix<->repa bridge library? any idea if it still works?
18:06:32 <peddie> does it exist?  I haven't tried it; when I had to do this I just wrote a conversion function
18:06:42 <zedbourbaki> vx999: i try to make some time to translate quant fin class projects into haskell, but it has proven to be more difficult than I first thought
18:06:43 <peddie> vx999: better just try it
18:07:07 <dolio> shachaf: That's like 70% of what people argue about, though.
18:07:25 <KaneTW> up to a point where the set of morphisms between to objects of a (small) category x,y is called hom(x,y) :v
18:07:54 <monochrom> we can contribute to reducing that ratio. by arguing about punctuations instead. :)
18:08:19 <monochrom> -> is a poor punctuation for morphisms.
18:08:22 <vx999> zedbourbaki yeah it's kind of a bummer. thin ecosystem atm, with like 10 or so active participants
18:09:23 <vx999> peddie i remember talk of a 0-overhead converter, might be hmatrix-repa. of course, hackage being what it is there's also a repa-hmatrix =P
18:09:34 <domgetter> KaneTW: so I can make a function in Haskell that isn't a morphism?  I know that this doesn't stop Hask from being a category, since the category would only be those functions which are morphisms.  I just don't want to make a mistake when giving examples to someone
18:09:55 <peddie> vx999: yeah, the conversion is just a pointer cast -- looks like hmatrix-repa is the more mature one?
18:10:10 <jle`> Hask is defined as the category whose objects are Haskell types, and whose morphisms are all functions between types
18:10:22 <jle`> all functions in haskell are morphisms in Hask by definition of Hask
18:10:44 <shachaf> Obviously the true answer for what "homomorphism" means is a Chu space homomorphism.
18:11:12 <jle`> `f _ = True`, Int -> Bool, is indeed a morphism in Hask
18:11:45 <domgetter> jle`: even let f x = undefined ?
18:12:02 <KaneTW> yes, as long you define morphism equality properly
18:12:08 <Lokathor> Welkin, I am BEYOND shocked that it actually compiled after minimal type fiddling
18:12:36 <Lokathor> current code, http://lpaste.net/151848
18:12:39 <vx999> hrm stack is not succeeding in compiling hmatrix-repa ...
18:12:43 <KaneTW> if you don't, you don't have a category
18:12:51 <KaneTW> so you can't make a function that isn't a morphism, no
18:13:00 <domgetter> KaneTW: you said earlier that we ignore bottom values.  What's an example of a bottom value?
18:13:08 <zedbourbaki> vx999: 10 ? where are they ?
18:13:41 <KaneTW> undefined
18:13:43 <domgetter> The only reason I'm still confused is because jle` is claiming that all functions are morphisms, and KaneTW said earlier that this is not the case.
18:13:52 <vx999> zedbourbaki... well roughly. I know of more like 4 or 5, but i figure i'm missing a few people.
18:14:02 <KaneTW> no i was a bit unclear
18:14:04 <zedbourbaki> vx999: fair enough
18:14:10 <KaneTW> if you have a function that isn't a morphism
18:14:15 <KaneTW> you don't have a category
18:14:30 <monochrom> does a Scott-continuous, uncomputable function exist?
18:15:04 <monochrom> because that would be a good candidate for a perpetual argument on "should Hask include it?"
18:15:06 <domgetter> KaneTW: but that isn't true in the category of groups, is it? That is, for f(x) = x + 1, f(3 + 4) != f(3) + f(4)
18:15:17 <domgetter> It's still a category, and there are functions which are not morphisms
18:15:19 <KaneTW> we're talking about hask
18:15:46 <zedbourbaki> vx999: i still feel like there's going to be a better ROI from python/c++, which saddens me.
18:15:51 <domgetter> "if you don't, you don't have a category " Was this a general statement about categories?
18:15:54 <vx999> zedbourbaki carter doing numerical, ocramz doing petsc wrapping, idontgetoutmuch & chad...  blogs..., there's ek with AD/linear/etc, Ben with repa, alberto with hmatrix...
18:15:55 <KaneTW> about hask
18:16:03 <vx999> zedbourbaki ... and that's about the whole party
18:16:10 * hackagebot pipes-text 0.0.2.0 - Text pipes.  https://hackage.haskell.org/package/pipes-text-0.0.2.0 (MichaelThompson)
18:16:10 <EvanR> so according to haskell wiki, Hask (including bottoms) is a category. But with bottoms its so broken to not have any properties
18:16:38 <KaneTW> it's a category if you define function equality by forall x. f x = g x
18:16:45 <carter_cloud> I also have hblas.  Which I need to finish updating
18:16:53 <EvanR> do you need function equality?
18:17:03 <jle`> you need function equality for the laws to make sense
18:17:03 <KaneTW> morphism equality
18:17:15 <lpaste> Gurkenglas annotated ‚Äútoo much repetition‚Äù with ‚ÄúOf course, you don't need the first 5 definitions in the first place now.‚Äù at http://lpaste.net/151849#a151852
18:17:16 <jle`> er, morphism equality, yeah, in an abstract sense
18:17:21 <jle`> EvanR: f . id = f
18:17:24 <vx999> zedbourbaki i feel the same, must be a few shortcuts... like could we programmatically wrap large chunks of the python ecosystem? it's mostly C/C++...
18:17:28 <Gurkenglas> adas, there
18:17:30 <jle`> this doesn't make sense unless you define what it even means for `f . id = f`
18:17:30 <EvanR> alright
18:17:37 <EvanR> and syntactic equality wont work
18:17:38 <jle`> for f . id to be "equivalent" to f
18:17:46 <peddie> vx999: a lot of specialized libs just need reasonable bindings written
18:17:48 <monochrom> category theory assumes you know "are these two morphims equal?"
18:18:01 <Lokathor> oh no it crashed :(
18:18:12 <Welkin> Lokathor: oh noes!
18:18:17 <Lokathor> spacefortress: SQLite3 returned ErrorError while attempting to perform prepare "SELECT \"id\",\"command\",\"count\" FROM \"command_attempt\" WHERE \"command\"=?": no such table: command_attempt
18:18:30 <Lokathor> i guess it type checked the wrong thing somehow
18:18:32 <vx999> peddie yeah that's true. if you could wrap scikitlearn reasonably cleanly that's a big chunk of what the data science people need.
18:18:46 <zedbourbaki> vx999: the thing is, part of me is more interested into open sourcing computational finance articles than software engineering, ie i only learn languages when I ought to - or when I am particularly curious about them.
18:18:47 <Lokathor> oh i didn't run the migrate!
18:19:05 <vx999> still wouldn't be great usability though
18:19:10 <vx999> most likely
18:19:49 <vx999> zedbourbaki yeah i think a lot of applied sciences people have this attitude. i have more patience for good computing tools because i started in computation before going into applied stuff
18:20:18 <vx999> zedbourbaki for them a more-mature julia would probably be the ideal programming language. or they don't care rewriting the same script slightly differently for every project.
18:20:55 <zedbourbaki> vx999: that is most correct. which i have learned to accept... up to some point.
18:21:10 * hackagebot pandoc-csv2table 1.0.3 - Convert CSV to Pandoc Table Markdown  https://hackage.haskell.org/package/pandoc-csv2table-1.0.3 (baig)
18:21:39 <zedbourbaki> vx999: but the thing is that many applied sciences people - we don't have a strong enough CS bckground to really quantify what is a good computing tool.
18:21:48 <peddie> vx999: I think a lot of the problem may be that the people who really want to use the libs usually don't want to sit down and write a bunch of bindings, and many of the people who would consider making idiomatic haskell bindings a fun challenge have more interesting problems and don't care about the library that much
18:22:00 <vx999> zedbourbaki for me personally there's an argument to be said in terms of a good language automating development productivity in a very long-term view... but it's definitely long term.
18:22:57 <vx999> peddie well if i was a little more mature in my haskell  ability i'd probably be the right person to contribute filling-in the gap. unfortunately my downtime is really limited.
18:23:38 <Lokathor> Welkin, it appears to work now :3
18:23:47 <peddie> vx999: I'm in the same boat regarding downtime :/
18:23:48 <vx999> i actually do have an idea for a personal project to write binding for a particular tool... but i haven't started on it yet :/
18:24:00 <zedbourbaki> vx999: the thing with haskell is that the tools that you use to develop with are moving fast. like today, i wanted to catch up on haskell but i was stuck with a development setting bug and i just decided to come and chat instead :)
18:24:02 <peddie> vx999: is scikit mostly in python, or is it all wrappers around C/C++?
18:24:05 <Welkin> Lokathor: sqlite is not the best either
18:24:33 <Welkin> I don't think it even supports foreign keys
18:25:18 <Welkin> ah, looks like it does, but it needs to be enabled
18:25:52 <vx999> zedbourbaki it's moving fast in some respects slow in others. type system magic to get the flexibility of DT with guarantees seems to be moving quickly. usability stuff like printing a matrix moves slowly
18:26:01 <zedbourbaki> peddie: according to wikipedia, it's mostly in python
18:26:24 <peddie> zedbourbaki: that's what I read as well.  that makes it tougher to bind to the algorithms that already work
18:26:25 * hackagebot pipes-text 0.0.2.1 - properly streaming text  https://hackage.haskell.org/package/pipes-text-0.0.2.1 (MichaelThompson)
18:27:00 <vx999> peddie zedbourbaki aren't the core routines C/C++ though? how do they get decent speed in python? i thought it was more the pandas / data frame scaffolding that's python
18:27:17 <peddie> vx999: it sounds like you already know way more about this than I do :)
18:27:44 <zedbourbaki> peddie: so pardon me for my noob-ness, but I've always thought that a binding was something that you did whilst waiting for a rewriting in the actual language... innit ? it seems that you are implying that bindings are better... i am confused.
18:27:53 <vx999> i've dabbled in scikit-learn, i do more R though
18:27:54 <EvanR> #haskell-blah may be interested in talking about numeric python ;)
18:28:04 <Welkin> EvanR: no it is not
18:28:14 <KaneTW> haha
18:28:22 <vx999> lol
18:28:45 <vx999> zedbourbaki for python, C bindings are an end in itself
18:28:46 <peddie> zedbourbaki: I dunno, rewriting that all in Haskell and avoiding bugs sounds like a lot of hard work compared to calling a C library where it's possible
18:29:05 <vx999> zedbourbaki actually the other way around, python code is what you write while waiting for someone to do the definite C version =P
18:29:15 <Lokathor> Welkin, yeah, it's just sorta demo mode for now
18:29:15 <zedbourbaki> vx999: ahahah fair enough
18:29:17 <KaneTW> there are cases where a haskell rewrite is better, but usually not for numeric code
18:29:22 <peddie> zedbourbaki: plus it will take a lot more work to make the Haskell perform comparably with the C version
18:29:31 <EvanR> or use a numeric haskell lib
18:29:32 <hodapp> rewriting numeric code is almost never better >_>
18:29:43 <KaneTW> yup
18:30:00 <KaneTW> dump it into your favorite BLAS implementation and go on your merry way
18:30:03 <Welkin> from what I know, scipy/numpy is actually written in C and has a python interface
18:30:06 <lambda-11235> Does Data.Array.Array have O(1) access times, or is the name "Array" taken in a more mathematical context?
18:30:09 <hodapp> there's a reason that a lot of people still rely on something written in the '60s in FORTRAN
18:30:20 <EvanR> Array is O(1)
18:30:32 <KaneTW> Vector is O(1), too
18:30:33 <vx999> peddie i think there's some low hanging fruit though. i don't see why useful stuff like sundials can't be minimally wrapped up in haskell... could even get inline-c to do some of the lifting i suspect
18:30:55 <hodapp> Welkin: that's mostly correct; it makes use of a lot of C routines written for the task at hand, and it also ties into other C & FORTRAN libraries
18:31:03 <peddie> vx999: I made bindings with c2hs and got a sundials example running!  but I haven't put it up yet; still needs more testing
18:31:25 <peddie> it's a big API, and there are always quirks
18:31:46 <vx999> peddie nice, yeah not pretty. maybe start with boost ODE which is a bit more lightweight
18:31:51 <jle`> lambda-11235: they're meant to be arrays in the C/etc. sense
18:32:04 <vx999> although in my world it doesn't take much to hit stiff system use cases
18:32:13 <peddie> vx999: there's already hmatrix-gsl's integrators if you want something simple
18:32:46 <vx999> peddie yeah I think the GSL integrators are too primitive though (maybe boost is not much better, i havent tried it in depth)
18:33:05 <peddie> vx999: they do have some dedicated stiff integrators in GSL; haven't tried them though
18:33:22 <vx999> peddie from what i remember it didn't take much system complexity before GSL integrators started choking
18:33:37 <peddie> too bad
18:34:27 <peddie> vx999: the boost ODEINT performance page gives benchmarks for RK4 . . . not encouraging :P
18:34:44 <vx999> peddie may have missed some options, i didn't dive all that deep into hmatrix-gsl. are the stiff options exposed in the hmatrix-gsl inteerface?
18:35:29 <peddie> looks like you can try BDF https://hackage.haskell.org/package/hmatrix-gsl-0.17.0.0/docs/Numeric-GSL-ODE.html
18:36:15 <peddie> vx999: they also say implicit Bulirsch-Stoer is "generally suitable for stiff problems," but I will remain skeptical until I see proof
18:36:34 * hackagebot pandoc-csv2table 1.0.4 - Convert CSV to Pandoc Table Markdown  https://hackage.haskell.org/package/pandoc-csv2table-1.0.4 (baig)
18:36:56 <movedx> haskelliseasy.com -- could be note worthy for some.
18:38:22 <vx999> peddie personally i'm more an end user for these models, but i've had a couple simple examples that didn't work with anything out of the box other than CVODE
18:38:32 <peddie> vx999: you need to give both those methods a Jacobian
18:39:26 <peddie> vx999: well, if the choice is between waiting for sundials bindings to magically appear and testing GSL's admittedly simple integrators, I might test out hmatrix-gsl -- shouldn't be difficult unless you don't have Jacobians already
18:40:15 <EvanR> movedx: read it. ah, so easy
18:40:25 <vx999> peddie actually my current project is a stochastic model fit+simulation
18:40:48 <movedx> EvanR: Now you know Haskell. Go forth, and, er... spawn processes? 
18:45:20 <lpaste> adas revised ‚ÄúOf course, you don't need the first 5 definitions in the first place now.‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/151852
18:45:32 <peddie> vx999: I'm not sure what "actually" implies there :)  (of course you can also just use sundials in python or something)
18:45:56 <adas> Gurkenglas: i don't think the decoder function works in that case
18:46:36 <Gurkenglas> adas, what case, and why wouldn't it?
18:47:33 <Gurkenglas> Oh, you edited it. Damn lpaste with its not updating the annotations on the page they're targeting
18:47:37 <vx999> peddle meaning my i don't have a rush need for ODE integration in the short term (although use do that for some other projects). my immediate task i'm working on at this minute is to set up some stochastic models
18:47:58 <vx999> peddie
18:48:15 <Gurkenglas> Huh, didn't even notice that the type changes. adas, remove line 16 and it should work. :t it in ghci to see what should have been put there
18:48:45 <adas> Gurkenglas: will try that
18:49:03 <vx999> so i'll probably come back to tinkering with hmatrix-gsl integrators in a few weeks. for now i'm tinkering more with random-fu and some matrix/vector lib (still settling on which) to manage state
18:49:48 <vx999> wondering if AD can help me get map estimates, but i ran into a bit of a roadblock with AD not playing well with the other numerics libs
18:49:51 <peddie> vx999: cool, good luck!  maybe if I get my rear in gear the sundials bindings will be working :)
18:50:05 <peddie> vx999: yeah, AD does not play nicely with matrices
18:50:18 <vx999> i think it needed Traversable instances or something
18:50:20 <peddie> vx999: there are bindings to CasADi, but they will be a lot more complicated than the 'ad' library
18:50:32 <peddie> much higher performance though
18:50:41 <vx999> that hmatrix (and i think repa) couldn't provide
18:50:57 <vx999> huh I didn't know CasADi existed
18:51:36 <vx999> peddie would love to see what you're doing with sundials bindings!
18:52:02 <peddie> vx999: well, if I ever get to it, hackagebot should announce it ;)
18:52:09 <vx999> even toy examples would be better than nothing.. good luck
18:52:38 <Gurkenglas> I remember someone saying that stack traces don't work how I'd expect them to in haskell. Can someone explain why?
18:53:02 <shachaf> That depends on what you expect.
18:54:21 <Gurkenglas> I'd expect a top-level definition without function arguments to cut off traces because you can't know what triggered the thunk to evaluate (or can you?), but a top-level definition with function arguments would point to where that argument was plugged into that function
18:54:31 <jle`> Gurkenglas: typically people think about call stacks when you talk about stack traces, but haskell doesn't really have the idea of a call stack
18:54:51 <jle`> stack traces refer to an "evaluation stack", i believe
18:54:55 <jle`> (in haskell)
18:55:33 <jle`> for example, if you evaluate the result of a function or evaluate a value, where it is eventually evaluated might be far away from when the function's result is evaluated, or where the value is used is evaluated, etc.
18:55:51 <ij> Why doesn't this type-check? f :: (Integral a, Num a) => Ratio a -> Ratio a; f x = 1 % (x + (1 % 1))
18:55:58 <jle`> it's not as simple as "this was called by this which was called by this which was called by this"
18:56:15 <adas> Gurkenglas: that works. thanks.. but it still means I have to provide the a type at the call site like so `decoder csv :: Vector (Funnel Java)`. still better than typing all those functions
18:56:17 <jle`> ij: what's the error?
18:56:50 <jle`> btw, Integral implies Num
18:56:53 <Gurkenglas> adas, remove lines 1, 4, 7, 10 and 13 and it should still work >:D
18:57:13 <jle`> :t (%)
18:57:14 <lambdabot> Integral a => a -> a -> Ratio a
18:57:33 <ij> Here's the error: http://sprunge.us/JceM | jle` I was thinking about about the implication but wasn't sure, so added both.
18:57:36 <jle`> ij: note that for a Ratio a, the "top and bottom" have to be `a`, not Ratio a
18:58:09 <jle`> so if you use 'x :: Ratio a' on the right of a %, the result will be Ratio (Ratio a)
18:58:59 <Gurkenglas> :t \x -> 1 % (x + (1 % 1))
18:59:00 <lambdabot> (Integral a, Integral (Ratio a)) => Ratio a -> Ratio (Ratio a)
18:59:03 <Gurkenglas> :t \x -> 1 / (x + (1 % 1))
18:59:04 <lambdabot> Integral a => Ratio a -> Ratio a
18:59:08 <jle`> ij: if you want a `Ratio a` as a result, you need to put an `a` on the bottom
18:59:11 <jle`> but x isn't 'a', it's Ratio a
18:59:18 <jle`> (that's what the error message is saying)
19:00:31 <Gurkenglas> (adas, assuming that you are deconstructing the Java/Dotnet/etc. data at some point rather than just plugging it into some common typeclass function like show again)
19:00:32 <ij> Makes sense. What a complex error message.
19:01:24 <jle`> hm, i guess you get use to it after a while
19:01:43 <jle`> "can't match expected type 'a' with actual type 'Ratio a', in 'x'"
19:01:51 <jle`> which says x should be an 'a' but it's actually a Ratio a
19:02:00 <jle`> it does take a bit of getting used to, admittedly
19:02:38 <Gurkenglas> I'm still waiting for when you can interactively tell it with a button press "no really x is Ratio a, not a" and make it binary search you down to the mistake
19:08:00 <Gurkenglas> ghci session: http://lpaste.net/4856257394885263360 what introduces a stack trace layer?
19:08:51 <geekosaur> what ghc version? some of the stuff was in 7.10 but not functional yet
19:08:59 <geekosaur> 8.1 will have the full implementation
19:09:19 <geekosaur> (8.1rc2 landed earlier today...)
19:09:27 <Axman6> there are some flags you need to turn on, like profiling iirc
19:09:29 <Gurkenglas> Ah, 7.10.2
19:09:45 <Axman6> you'll need to read the GHC docs to find out what's necessary
19:09:59 <Gurkenglas> eww nvm then ._.
19:10:07 <Axman6> :\
19:10:22 * Axman6 makes a note to himself to never hire Gurkenglas :P
19:11:42 <Gurkenglas> Damn command line stuff why is everyone expected to have grown up with it
19:17:04 <Gurkenglas> oh hey turns out there's a readable version of all this stuff at https://downloads.haskell.org/~ghc/master/users-guide/profiling.html
19:19:21 <AbelianGrape> Is there a version of (^.) from Lens that is equivalent to "\a b -> fmap (^. b) a"?
19:19:34 <AbelianGrape> So that I can essentially apply lens getters to e.g. IO actions?
19:19:51 <AbelianGrape> foo <- bar <^. baz
19:19:54 <AbelianGrape> or something
19:20:33 <Gurkenglas> foo <- view baz <$> bar
19:20:36 <AbelianGrape> I would use Hoogle, but I have absolutely no idea what the type of this would be
19:20:49 <AbelianGrape> Yeah, that would work, but a single thing would be better
19:21:37 <Gurkenglas> :t (^.)
19:21:38 <lambdabot> s -> Getting a s a -> a
19:21:49 <Gurkenglas> Functor f => f s -> Getting a s a -> f a
19:22:08 <Gurkenglas> http://hayoo.fh-wedel.de/?query=Functor+f+%3D%3E+f+s+-%3E+Getting+a+s+a+-%3E+f+a Nothing :P
19:26:34 <AbelianGrape> Second question: Is there something like a Prism that will crash if the wrong path is taken? Like a _Just that crashes if we're not actually inspecting a Just valueD
19:26:38 <AbelianGrape> s/D/?
19:27:00 <Gurkenglas> :t unsafeSingular
19:27:02 <lambdabot> (Functor f, Conjoined p) => Traversing p f s t a b -> Over p f s t a b
19:32:20 <Gurkenglas> > (Just 3 ^?! _Just, Nothing ^?! _Just) -- Also consider this
19:32:22 <lambdabot>  (3,*Exception: (^?!): empty Fold
19:32:33 <AbelianGrape> Perfect
19:39:25 <blogle> Is there a shorter tagless final tutorial I can look at before http://okmij.org/ftp/tagless-final/course/lecture.pdf 
19:39:45 <peddie> blogle: the paper is shorter, but it's definitely not a "tutorial"
19:41:13 <blogle> I was hoping for something to provide the motivation for their use before commiting to the lecture
19:50:38 <andromeda-galaxy> I feel like Coq is the only "proof assisstant" that gets mentioned a lot in the community (discounting Agda and Idris since those are also programming langauges), does anyone know why?  What are some of the advantages/disadvantages between Coq/Isabelle/etc.?
19:51:37 * hackagebot github-backup 1.20160207 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20160207 (JoeyHess)
19:53:59 <ggVGc> andromeda-galaxy: I have to admit to only really knowing about Coq, but I'm not a mathematician
19:54:02 <andromeda-galaxy> (from the point of view of the haskell community specifically)
19:54:10 <ggVGc> and I don't fully even grasp the everyday need for a proof assistant
19:54:51 <ggVGc> I've often wondered who the people are that are the primary users of i.e Coq
19:56:22 <andromeda-galaxy> I'm not a mathematician either, but I've always enjoyed abstract mathematics, and thought that it would be fun to go over my old class notes and verify a bunch of proofs, and then to (hopefully) manage to verify other software systems (I like the precedent of using Isabelle/HOL for seL4...)
19:57:11 <andromeda-galaxy> (I'm also planning on learning category theory & type theory soon, and want to try writing a bunch of exercise proofs in an assistant)
20:15:49 <orion> Are higher order functions ("callbacks") and MVars a sign of API warts?
20:17:19 <EvanR> sometimes you have to have that for FFI bindings
20:18:24 <EvanR> like in libmikmod, which allows you to pass a set of function pointers to tell it how to read a custom stream
20:19:26 <nitrix> Another recent example of mine; FUSE, to provider handlers to each file system operations.
20:22:23 <orion> EvanR: In my case I am implementing a network protocol. The callbacks you need to provide me include "write" and "read" functions that actually put the packets I generate on the wire.
20:23:07 <EvanR> if its all in haskell, consider using threads for baby sitting sockets
20:23:21 <EvanR> theres a lib async which helps with that
20:23:47 <vx999> hmm
20:24:56 <orion> EvanR: A requirement is that the user gets to have complete control over the socket.
20:25:03 <orion> And over the data I send.
20:25:05 <EvanR> orion: otoh if this is just some record with functions for implementations, thats just the oop pattern
20:25:37 <EvanR> not exactly the same as a calback
20:26:06 <orion> So for example, my library might generate a packet (ByteString) that I need to deliver back to the user so they can transform it how they wish.
20:26:24 <orion> Some users might take the ByteString I return and wrap it in JSON.
20:26:37 <orion> Others might write it to the socket as-is.
20:27:36 <EvanR> instead of starting with bytestrings, start with the possible packets and then apply the encoder
20:28:16 <orion> Could you rephrase?
20:28:18 <EvanR> no point in having the user decode then reencode
20:28:39 <EvanR> just have one encoding point
20:29:30 <orion> Oh, the user isn't meant to inspect/parse/decode what I give them. It's opaque data. My library is saying to the user, "Take this blob of data and deliver it to the other party however you deem necessary"
20:29:37 <levi> orion: I sure wouldn't consider higher-order functions an API wart.
20:31:21 <orion> ok
20:32:32 <levi> As to MVars; they're a somewhat low-level mechanism, so there might be a better way to express the API at a higher level.
20:33:13 <orion> My library doesn't require the user to use MVars. It's just the only option if you want to do anything remotely complicated.
20:33:56 <EvanR> theres also TVars and libraries that wrap these things for you for things that are "complicated"
20:34:26 <levi> There are various libraries that let you choose among various back-end implementations of the same basic API.
20:34:26 <vx999> hm
20:34:47 <vx999> what happend to the Data.Packed.Vector / Data.Packed.Matrix modules in hmatrix?
20:35:12 <vx999> they're no longer part of the package
20:35:26 <vx999> but i don't see what functions are supposed to replace their functionality
20:36:11 <orion> levi / EvanR: This leads me to another question: Let's say I am an end-user of said library and I want to construct a pair of Pipes to be used as the "read" and "write" callbacks/HOFs. In other words, I want the "read" callback to actually be "await" and the "write" callback to be "yield".
20:37:01 <EvanR> so you want blocking
20:37:09 <orion> http://lpaste.net/3654837866896293888#line23
20:37:26 <orion> ^ That's exactly what I want.
20:38:51 <EvanR> orion: FooPipe doesnt take any arguments so
20:39:02 <EvanR> FooPipe IO () doesnt make much sense
20:39:56 <orion> EvanR: That's an oversight in my test case translation. Let's assume it does take arguments.
20:40:14 <EvanR> having a hard time understand what its supposed to be doing
20:41:18 <dustmote>  :t \a b l -> (a,b):l
20:41:39 <EvanR> you can make a producer with the send callback, and a consumer with the recv callback
20:41:57 <dustmote> is there a good way to write this using a combinator? i always want to do something like `(:) . (,)` but that's obviously wrong because of the type of (.)
20:42:51 <EvanR> @pl \a b l -> (a,b):l
20:42:51 <lambdabot> ((:) .) . (,)
20:42:55 <orion> EvanR: I hadn't considered that.
20:43:16 <EvanR> or the other way around
20:43:25 <EvanR> use recv, then yield the result, forever
20:43:30 <dustmote> EvanR: oh nice. what is @pl?
20:43:34 <EvanR> use await, then send the result, forever
20:43:52 <levi> dustmote: It's a translator to point-free style
20:44:04 <dustmote> levi: is that something that's always possible to do?
20:44:19 <EvanR> its possible but usually gross
20:44:33 <levi> Where 'point-free style' means you build your function by composing functions without binding any names via function arguments.
20:44:36 <orion> EvanR: yield and await can't be drop-in HOFs for send and recv though, I assume.
20:45:10 <EvanR> orion: im only suggesting things that typecheck at this point, no idea if its a good idea ;)
20:45:37 <orion> I want doFoo to be able to call cbSend "blah" and have it echo "blah" to stdout.
20:45:47 <augur> is there a way to get "free" partiality?
20:46:18 <orion> EvanR: In other words, I don't want doFoo to be aware that there is actually a pipe under the hood.
20:46:21 <EvanR> orion: well, then youre not really in a pipe
20:46:29 <augur> by which i mean i want to have a function that returns Maybe a in a whole bunch of catch all situations but i dont want to have to write a bunch of   foo _ = Nothing   everywhere
20:46:40 <EvanR> but its still possible to hack whatever through IO
20:48:35 <EvanR> augur: you want to throw exceptions at any point?
20:48:52 <EvanR> theres MonadExcept
20:48:58 <augur> EvanR: eh. really i just want to avoid having to write  foo _ = Nothing   in a bunch of places :)
20:49:53 <levi> So you want pattern match failures to turn into Nothing?
20:49:55 <EvanR> well theres fail
20:50:36 <augur> levi: basically
20:51:35 <EvanR> foo okArg = do x <- f okArg; return x ;)
20:51:37 <augur> i mean, it's not deeply necessary, it's just ugly to write  foo _ = Nothing  sort of catchalls a lot, given the kind of program im writing
20:51:48 <augur> EvanR: i actually considered that :p
20:52:38 <EvanR> or list comprehensions
20:52:41 <augur> it'd introduce a bunch of other ugly things. i think maybe i should just learn some TH and then i could write some little gadget that does the insertion automatically
20:52:45 <EvanR> er... monad comprehensions
20:53:20 <augur> write some junk like   @foo P = bar   and that becomes   foo P = Just bar ; foo _ = Nothing
20:53:22 <augur> or whatever
20:55:02 <levi> MonadPlus gives you the pattern match fail = Nothing semantics, doesn't it?  I guess you don't want to apply the monad instance, though?
20:55:45 <augur> i dont think that works so nicely tho. i think it only works for matches with the result of bind
20:55:49 <EvanR> foo x = do
20:56:00 <augur> do P <- x ; ...    if P fails to match
20:56:00 <EvanR>   P <- code x
20:56:09 <EvanR>   ...
20:57:25 <EvanR> for a large number of boiler plate style functions of this sort you may want TH or generic
20:57:51 <EvanR> then you dont even need to put @foo P 
20:57:57 <EvanR> just generate the whole swath
20:57:59 <augur> that actually may be feasible tho, since i probably will end up wanting to use a function like your `code` there EvanR
20:58:14 <augur> hmm
21:01:39 * hackagebot bytestring-tree-builder 0.2.3 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.3 (NikitaVolkov)
21:04:09 <JJJollyjim> Hey, anyone know how I can extraact an Element from the result of anyElement in xml-conduit?
21:05:27 <JJJollyjim> I'm slightly confused by the various types of Cursor
21:06:58 * hackagebot bytestring-tree-builder 0.2.3.1 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.3.1 (NikitaVolkov)
21:09:11 <EvanR> JJJollyjim: did you try using node :: Cursor Node -> Node
21:11:25 <JJJollyjim> Yeah, that seems to give me a Node instead of an Element. I know i can match on NodeElement to get the Element out, but it seems silly when I just filtered out non-elements
21:12:07 <EvanR> a Node is a sum type to let you dynamically determine if you are looking at an Element or something else
21:12:33 <EvanR> and yeah, if you use anyElement... the docs suggest you may end up without any elements by definition
21:12:44 <JJJollyjim> But that's not encoded in the types?
21:12:48 <EvanR> which makes no sense
21:13:03 <JJJollyjim> Yeah
21:13:28 <EvanR> im going to ignore that part of the doc and say that anyElement gives you an Axis with the meaning "any element"
21:13:28 <JJJollyjim> But it seems like there can also be a `Cursor Element'
21:14:09 <EvanR> maybe there can be, but i only see Cursor Nodes
21:14:30 <JJJollyjim> Ok thanks, that clarifies things
21:15:26 <EvanR> oh... filters out NON elements
21:16:12 <EvanR> meaning you can safely pattern match and do the equivalent of a fromJust, and crash on other cases because they are impossible
21:16:22 <EvanR> (tm)
21:21:58 * hackagebot bytestring-tree-builder 0.2.4 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.4 (NikitaVolkov)
21:31:59 * hackagebot json-encoder 0.1.5 - A direct-to-bytes single-pass JSON encoder with a declarative DSL  https://hackage.haskell.org/package/json-encoder-0.1.5 (NikitaVolkov)
21:36:18 <orion> Generally speaking, is it good practice to use the MonadIO class constraint as much as possible?
21:36:40 <jle`> people are a little split on that
21:36:49 <jle`> orion: do you mean, offer MonadIO m => m a, instead of IO a's ?
21:37:17 <orion> jle`: For example, the HOFs I was talking about earlier had types ByteString -> IO () and IO ByteString. I could use forall m. MonadIO m => ByteString -> m () and forall m. MonadIO m => m ByteString instead.
21:37:17 <davidthomas> anyone have thoughts on where to start debugging if hspec-discover isn't finding a Spec file?
21:37:27 <jle`> opinions are a bit split and i don't think you'll offend too many people as long as you pick something and stay consistent
21:37:48 <jle`> there are many libraries that make an informed decision for one or the other
21:37:54 <EvanR> what is the argument against
21:40:00 <jle`> i think there are some issues if the IO appears in the negative position
21:40:12 <jle`> and also some things like choosing to associate your liftIO's the way you want might make a difference
21:40:34 <jle`> for example, you might want to do liftIO (x >> y) instead of liftIO x >> liftIO y
21:41:15 <orion> Is it advisable to re-export MonadIO and liftIO?
21:41:45 <jle`> but for situations when IO appears in the negative position, you'd have to go through all sorts of hoops with monad-control etc. to make MonadIO work right
21:42:15 <EvanR> :t liftIO
21:42:17 <lambdabot> MonadIO m => IO a -> m a
21:42:46 <pavonia> jle`: What do you mean by "if the IO appears in the negative position"?
21:43:02 <jle`> orion: if all of your things are MonadIO m => .., you wouldn't need to have MonadIO imported to use them
21:45:09 <jle`> pavonia: trying to find a nice example
21:45:10 <orion> jle`: You would need liftIO though, right?
21:45:19 <jle`> you wouldn't need liftIO
21:45:23 <jle`> because all of the things would already be lifted
21:45:36 <EvanR> thats the point of making the actions MonadIO instead of IO
21:46:28 <orion> But, if my library requires that the user provide me with a function having type forall m. MonadIO m => ByteString -> m (), how would the user define a function for themselves?
21:47:30 <jle`> oh
21:47:52 <jle`> wait, why would you write your functions to expect (forall m. MonadIO m => ByteString -> m ()) ?
21:48:01 <jle`> don't you already know what MonadIO you're going to use?
21:48:07 <davidthomas> ah, it seems I needed to poke my Spec.hs so it'd be reprocessed
21:48:14 <davidthomas> this makes sense
21:49:05 <jle`> i thought you were talking about returning m ()'s
21:49:43 <EvanR> better make the callbacks IO
21:49:57 <Lokathor> ghcjs builds are distressingly slow
21:50:32 <EvanR> your lib cant use whatever extra feature the m will have, its just for avoiding a liftIO
21:51:12 <EvanR> otoh you might want the callbacks to be able to use those features, but they cant, because you have no idea what m it is (so it cant unify inside your lib)
21:51:22 <orion> jle`: Not necessarily. Let's say I required that the user give me a ByteString -> IO (). The user wants to give me a function of type StateT Foo IO (). With MonadIO, they'd be able to to this (I think?)
21:51:44 <jle`> what's the final type of your hof?
21:51:58 <jle`> there isn't much you can do with a MonadIO m => m a
21:52:14 <dramforever> orion: I don't think it's possible, it's totally backwards
21:52:24 <jle`> besides pick something specific to use it as
21:52:50 <orion> https://github.com/centromere/cacophony/blob/refactoring/src/Crypto/Noise/Internal/HandshakeState.hs#L56
21:54:03 <orion> And here it is in action: https://github.com/centromere/cacophony/blob/refactoring/tests/Handshakes.hs#L42
21:54:29 <jle`> wait
21:54:35 <jle`> you can't use a StateT Foo IO () as a MonadIO
21:54:42 <jle`> as a forall m. MonadIO m => m ()
21:55:43 <jle`> if you're expecting a (forall m. MonadIO m => Foo -> m Bar), you can't pass in a Foo -> StateT Foo IO ()
21:55:52 <jle`> *Foo -> StateT Foo IO Bar
21:56:07 <dmj> :t (undefined :: MonadIO m => StateT Int m ())
21:56:08 <lambdabot> MonadIO m => StateT Int m ()
21:56:53 <orion> hmm
21:57:00 * hackagebot include-file 0.1.0.3 - Inclusion of files in executables at compile-time.  https://hackage.haskell.org/package/include-file-0.1.0.3 (DanielDiaz)
21:57:05 <jle`> @let mioTest :: (forall m. MonadIO m => Int -> m Bool) -> String; mioTest _ = "hello"
21:57:06 <lambdabot>  Defined.
21:57:10 <EvanR> it cant work, if the api wants any m, and then later the callback has some m, they arent necessarily compatible
21:57:18 <jle`> > mioTest (\_ -> return True :: IO Bool)
21:57:20 <lambdabot>      Couldn't match type ‚Äòm‚Äô with ‚ÄòIO‚Äô
21:57:20 <lambdabot>        ‚Äòm‚Äô is a rigid type variable bound by
21:57:20 <lambdabot>            a type expected by the context: MonadIO m => Int -> m Bool
21:57:43 <orion> Hmm so, there's absolutely no benefit to using MonadIO in my particular case.
21:58:04 <EvanR> you can use MonadIO for the normal api calls to avoid liftIO
21:58:08 <EvanR> but the callbacks should be IO
21:58:57 <EvanR> whatever extra state the user needs can be passed using closure
21:59:21 <jle`> i don't see any benefit
21:59:35 <jle`> (in this case)
21:59:40 <EvanR> avoiding liftIO isnt that much of a benefit
22:00:13 <EvanR> if the user is using a transformer over IO they are probably importing liftIO and using it somewhere anyway
22:00:22 <orion> < EvanR> whatever extra state the user needs can be passed using closure <-- good point
22:02:00 * hackagebot reflex 0.4.0 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.4.0 (RyanTrinkle)
22:03:34 <dustmote> any idea why adding a 'shrink' method to a quickcheck arbitrary instance might cause nontermination?
22:06:02 <orion> Thank you EvanR, jle`.
22:06:07 <jle`> np
22:08:08 <kadoban> dustmote: Because quickcheck tries to 'shrink' any failing test cases that it finds before presenting them, to give you the most concise failure possible, ideally.
22:08:40 <kadoban> dustmote: So if your 'shrink' is either nonterminating or behaves in some way that quickcheck doesn't expect, bad things gonna happen.
22:10:16 <dustmote> kadoban: ok, i think my shrink terminates.. what i'm seeing is nondeterministic nontermination
22:10:24 <jle`> i wonder why i can't do:
22:10:32 <jle`> data Foo :: Foo -> * where ....
22:10:35 <dustmote> sometimes it finds a failing testcase, sometimes not ... sometimes it just eats all my ram
22:10:45 <jle`> it makes perfect sense in my head
22:12:54 <kadoban> dustmote: If I had to guess, your shrink either suggests the input itself as a possible shrink, or there's possible "cycles" of longer length where 'a' suggests 'b', and 'b' suggests 'a' or something.
22:13:10 <EvanR> jle`: infinite type?
22:13:35 <jle`> data Foo :: Foo -> * where F :: Foo F
22:13:43 <jle`> i guess GADT's can't be promoted pre-8.0
22:13:50 <jle`> but it still doesn't work in 8.0
22:14:22 <EvanR> Foo's type is effectively ... -> *) -> *
22:14:49 <jle`> but `Foo F` terminates
22:15:04 <jle`> doesn't it?
22:15:19 <EvanR> sure why not
22:15:42 <EvanR> but i was under the impression that regardless of how much sense it makes infinite types are not welcome
22:17:00 * hackagebot reflex-dom 0.3 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.3 (RyanTrinkle)
22:17:13 <dmj> ^ hmmmm
22:17:21 <dustmote> kadoban: so.. is the list returned by shrink supposed to be exhaustive?
22:17:24 <dustmote> can it have repeats?
22:17:52 <dmj> reflex-dom just added websockets :]
22:19:03 <jle`> EvanR: List is already a potentially infinite type though
22:19:14 <EvanR> how so
22:19:35 <dustmote> i'm just seeing quickcheck print out the name of my testcase with a number "  blahTestcase: [24]" forever
22:20:00 <dolio> Type-level lists can't be infinite.
22:20:11 <dolio> But also, pretty much no theoretical system lets you do what Foo does.
22:20:38 <kadoban> dustmote: It's supposed to be a list of the possible *immediate* ways you can "shrink" the value given to it. I don't think it's a huge problem if there are repeats. I don't think you want an infinite list, nor do you want there to be the possibility of cycles, where shrinking a suggests b, and shrinking b suggests a
22:22:00 <EvanR> ah type level list
22:24:00 <dolio> Even in impredicative systems, you can usually only indirectly refer to yourself as part of your own definition (by referencing the entire class of things you are a part of).
22:24:09 <dustmote> kadoban: ok, i think i'm causing a cycle by suggesting some aggressive shrinks up front, maybe.
22:25:31 <jle`> dolio: what about something like type-in-type
22:25:45 <jle`> the type of type is itself
22:25:53 <jle`> *the type of Type is itself
22:26:35 <jle`> it's an inconsistent system, but it is a system that is implemented in the real world and stuff
22:27:13 <dramforever> :t let x = x in x -- nobody really cares that much about consistency
22:27:15 <lambdabot> t
22:28:06 <EvanR> i use consistency twice a day whether i need to or not
22:28:58 <julianleviston> what on earth did lambdabot just do then?
22:29:06 <dolio> That's not an example of something you define inside a system.
22:29:12 <opqdonut> julianleviston: chose t as the type variable :)
22:29:27 <julianleviston> oh‚Ä¶ right. I would have expected it to state the expression, too.
22:29:32 <julianleviston> :t True
22:29:34 <lambdabot> Bool
22:29:38 <julianleviston> Oh ok fair enough.
22:30:46 <opqdonut> :t []
22:30:47 <lambdabot> [t]
22:30:53 <opqdonut> looks like the default has changed from a to t
22:31:08 <EvanR> :t id
22:31:10 <lambdabot> a -> a
22:31:19 <jle`> typically it depends on the type signature given at the definition site
22:31:22 <opqdonut> id probably has an explicit signature
22:31:24 <opqdonut> yeah
22:31:26 <jle`> but i think t has been the default for a while?
22:31:33 <jle`> maybe i'm mistaken :|
22:31:42 <opqdonut> not on 7.6.3 which I just tried
22:31:52 <Gurkenglas_> :t \x -> x
22:31:53 <lambdabot> r -> r
22:31:55 <opqdonut> but maybe that's ancient, I don't really keep up with ghc versions
22:31:57 <opqdonut> Gurkenglas_: nice
22:31:57 <Lokathor> dmj, websockets are cool. sadly, i seem to have had poor luck getting ghcjs going when i tried today :/
22:32:01 * hackagebot texmath 0.8.4.2 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.4.2 (JohnMacFarlane)
22:32:01 <jle`> 7.6.3 is fairly ancient
22:32:27 <Lokathor> opqdonut, you want 7.10.3 if you can get it, or something in the 7.10 family
22:32:45 <opqdonut> Lokathor: yeah this is just what my work pc happened to have, I'm not using it for anything
22:32:53 <jle`> there's a good chance any new code written in haskell these days is not going to compile in 7.6, heh
22:33:26 <dmj> heh
22:34:00 <dmj> 7.6.3 was all the rage when it came out
22:34:56 <jle`> hm, \x -> x is r -> r in 7.10 and t -> t in 8.1
22:35:16 <jle`> i guess there's a ghc committer whose job is to go in and make sure to change the variable name between every minor release
22:35:21 * geekosaur was wondering if it got r from reader
22:35:41 <julianleviston> opqdonut: t for Traversible t => t isn‚Äôt it?
22:35:45 <jle`> it's t -> t in 7.8 again
22:35:55 <julianleviston> oh no‚Ä¶ t for type?
22:35:58 <julianleviston> ah I don‚Äôt know why t.
22:36:10 <Gurkenglas> :t \a b c d e f g -> a b c d e f g
22:36:11 <lambdabot> (r1 -> r2 -> r3 -> r4 -> r5 -> r6 -> r) -> r1 -> r2 -> r3 -> r4 -> r5 -> r6 -> r
22:39:43 <Gurkenglas> :t \f -> f id id id map map -- so that's how that works
22:39:44 <lambdabot> ((a -> a) -> (a1 -> a1) -> (a2 -> a2) -> ((a3 -> b) -> [a3] -> [b]) -> ((a4 -> b1) -> [a4] -> [b1]) -> r) -> r
22:48:56 <EvanR> so... how about this optimization. you have a sum of N floating point numbers. later, you are told that one of the N floating point numbers has changed value, recalculate the sum. So you clevery say alright, subtract the original value from the already calculated sum, then add the new value
22:49:09 <EvanR> and the universe implodes
22:49:50 <EvanR> is there any way to make that work?
22:50:29 <kadoban> "make it work" as-in always give the same answer as if you did all of the work anew?
22:50:35 <Gurkenglas> The universe implodes because a + b - b isn't a?
22:50:38 <EvanR> yes
22:50:51 <geekosaur> with floating point? probably not. "welcome to floating point"
22:50:55 <EvanR> ;_;
22:51:37 <EvanR> what about a different number type
22:51:37 <Gurkenglas> Does floating point have commutativity/associativity?
22:51:55 <geekosaur> CReal, if it can represent the values. (it'll be slow)
22:52:11 <EvanR> one with decent performance?
22:52:35 <liste> fixed-point numbers have decent performance
22:52:44 <liste> if you can use them
22:53:09 <peddie> EvanR: use MPFR to get lots of extra precision and hope for the best?
22:53:31 <EvanR> lol
22:53:37 <geekosaur> but precision will bite you. meanwhile Cantor's probably rolling his eyes in his grave
22:54:03 <EvanR> at what
22:54:56 <EvanR> Gurkenglas: floats are ostensibly commutative but not associative (... which is weird) however you can find claims that its not even commutative because of arbitrary usage of extra precision 
22:56:19 <peddie> if I understand correctly, with extra precision _and_ caches in the mix, it's not even deterministic!
22:56:52 <EvanR> might as well use analog computers!
22:57:01 <geekosaur> when it comes down to it, cantor's diagonal argument is biting you. computers work ultimately in terms of integers, which can't represent all real numbers. you can mangle representations to make some things work, but you lose others in the process.
22:57:13 <Axman6> EvanR: look at Kahan summation
22:57:49 <Axman6> EvanR: specifically, check out the math-functions library by bos (Numeric.Sum I think is where the implementations are)
22:58:09 <Axman6> also ekmett's compensated package
22:58:28 <EvanR> geekosaur: not really interested in real numbers, just law abiding numbers... which i guess rationals do unless you need square roots
22:58:53 <EvanR> Axman6: nice
22:59:21 <kadoban> EvanR: do you care what order the original sum is done in? If you instead of just having the sum, you have some kind of data structure, like a binary tree that encodes the sum and every part of the sum, you can start changing parts of it more quickly than recomputing the entire sum without having the entire thing become nonsense when you change parts, I guess?
23:00:06 <kadoban> (Like you'd essentially have a BST augmented with "the sum of everything in this subtree is: x")
23:00:10 <EvanR> yes that is what im thinking for the entire calculation
23:00:16 <EvanR> not just a sum
23:00:30 <Axman6> I'm hopefully about to open source a package which makes use of a lot of bos' work in the statistics package (and math-functions) so I've become quite intimate with all this lately
23:00:35 <EvanR> but you could decompose the sum that way too, but i wonder how deep it can go before performance
23:00:46 <pikajude> what haddock options do I use to get the little "Source" link?
23:01:06 <geekosaur> --hyperlink-source?
23:01:26 <pikajude> if I were using Setup.hs, how would I pass that option correctly?
23:01:46 <pikajude> since it uses haddock --ghc-version first, --ghc-version --hyperlink-source causes exit 1
23:01:58 <kadoban> Wellll, I mean in one sense it should be pretty performant, since you only need to redo a logarithmic amount of work to change a term in the sum, but ‚Ä¶ the constants are going to be kind of huge compared to "just do a floating point add and subtract"
23:02:06 <Axman6> EvanR: Kahan summation is definitely the way to go, as long as you keep track of the residual you can always modify the sum by adding (-n) and then n'
23:02:08 <kadoban> So, I have no idea :-/
23:02:13 <pikajude> ahh so it's an option to Setup.hs haddock as well
23:02:51 <Axman6> as long as you only care about getting a much precision as a Double can possibly give, then that'll give you an "exact" answer
23:03:04 <EvanR> Axman6: excellent, so the error will be indefinitely bounded
23:03:10 <EvanR> by some constant
23:03:36 <Axman6> I believe so
23:03:52 <pikajude> ok, so is the source color theme on hackage (like here http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#Applicative) available to an average haddock user?
23:04:10 <EvanR> kadoban: for a large calculation with many terms, redoing a particular path would be a huge improvement over starting from scratch, so hopefully there is some wiggle room for speed up
23:04:12 <peddie> Axman6: nice trick
23:06:13 <Axman6> if you want a much slower alternative then the Scientific type might be useful. but it will be a lot slower (and potentially will not terminate for some operations)
23:06:26 <pikajude> come to think of it, the CSS classes in that source are a bit different from mine
23:06:52 <EvanR> i like scientific as a datatype to store these values in
23:07:09 <EvanR> well, base 10 derived values
23:07:51 <EvanR> with terminating reps
23:11:23 <EvanR> lol, in kahan's algorithm pseudo code, the comment reminds us that the compensation variable should always be zero, beware of overly agressive optimizers... i thought it was a joke but its probably serious
23:11:31 <pikajude> wow, also hackage's source has links to the definitions of other symbols
23:17:07 * hackagebot rebase 0.4.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.4.1 (NikitaVolkov)
23:26:41 <Axman6> EvanR: yes it's very serious =)
23:26:59 <subleq__> Where does the simply typed lambda calculus fall on the chompsky hierarchy?
23:28:05 <subleq__> or what class of algorithms can be implemented in simply typed lambda calculus?
23:28:20 <julianleviston> subleq__: probably Recursively Enumerable
23:28:42 <dolio> 5 bites.
23:28:51 <julianleviston> oh dear.
23:29:25 <subleq__> julianleviston: no, simply typed lambda calculus always halts
23:34:21 <julianleviston> subleq__: fair enough.
23:47:48 <Axman6> EvanR: I should add to what I earlier, when I said "Kahan summation" I really meant "Kahan-Babu≈°ka-Neumaier summation", which according to bos is 30% faster and more accurate
23:51:16 <Axman6> uh, whoops, it's 30% slower, but more accurate
