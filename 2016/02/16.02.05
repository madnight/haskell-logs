00:01:08 <amar1> ah, okay. makes sense. Thanks for help
00:02:42 <cocreature> snowowl: I wouldn’t worry about it too much at the beginning, just use do notation for IO and at some point come back to understand the more general use of do notation outside of IO
00:07:00 <snowowl> cocreature: Alright, I'm starting pretty small so far. Just wanna get my head around this paradigm
00:07:14 <snowowl> thanks for the help
00:07:17 <cocreature> yw
00:07:39 * hackagebot text-show-instances 3 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3 (ryanglscott)
00:07:39 * hackagebot text-show 3 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3 (ryanglscott)
00:12:09 <joko> Hello, is there anyone familiar with the X11 bindings here? Someone who could answer to my question at https://github.com/xmonad/X11/issues/38 ?
00:27:31 <quchen> Is there anything to combine a fast and a user-friendly parser? I imagine something like using a fast parser (e.g. Attoparsec) to create an AST or reject the input, and a slow-but-friendly parser (e.g. Megaparsec) to revisit the input just in order to generate good error messages.
00:28:55 <jle`> is trifecta not fast enough?
00:30:46 <quchen> jle`: I'm just asking out of curiosity (at this point).
00:30:58 <quchen> jle`: But you remind me that I should try Trifecta. :-)
00:32:30 <jle`> from what i hear, trifecta is supposed to be user friendly and also fast, but i might be misremembering things, heh
00:32:35 <django_> anyone wanna mentor me in haskell
00:33:18 <quchen> jle`: It's maintained by Edward, so it's probably (asymptotically) optimal. :-D
00:33:27 <jle`> heh
00:33:52 <liste> django_: I'm sure #haskell wants to (: just ask if you have any concerns!
00:34:09 <liste> you can also PM me if you want to, but usually you get help better here
00:34:19 <liste> there's also #haskell-beginners
00:36:08 <django_> liste, what kind of development do you do with haskell?
00:37:31 <liste> django_ most kinds! Haskell is a general purpose language. It's not very useful for embedded/systems programming due to GC requirement though
00:37:48 <django_> liste, you do industry work?
00:38:27 <liste> django_ not in Haskell, mostly
00:38:36 <django_> in what?
00:39:39 <liste> django_ mostly Java and Python
00:39:56 <django_> ahh
00:41:04 <quchen> liste: #haskell is a good channel for Haskell beginners. #haskell-beginners was opened for some special reason I think, not because beginner questions are off-topic here (because they are not off-topic).
00:42:14 <liste> quchen: good to know (: I always wondered why it existed
00:56:16 <absence_> is Free.Church.F f ~ Codensity (Free f)?
01:01:20 <kqr> what's the difference between `for` and `traverse`?
01:01:36 <kqr> aha for = flip traverse
01:02:47 <mniip> absence, I don't think so, not in a useful sense
01:03:23 <mniip> forall r. (a -> r) -> (f r -> r) -> r, versus forall r. (a -> Either r (f (Free f r))) -> Either r (f (Free f r))
01:15:12 <absence> mniip: so maybe not entirely isomorphic, but fromF and lowerCodensity basically does the same thing?
01:16:50 <mniip> well duh
01:17:18 <mniip> lowerCodensity and 'Codensity . (>>=)' make an isomorphism
01:18:29 <absence> mniip: hm?
01:18:47 <mniip> :t Codensity . (>>=)
01:18:48 <lambdabot> Not in scope: data constructor ‘Codensity’
01:19:07 <mniip> :t Control.Monad.Codensity.Codensity . (>>=)
01:19:08 <lambdabot>     Couldn't match type ‘(a1 -> m1 b0) -> m1 b0’
01:19:08 <lambdabot>                    with ‘forall b. (a -> m b) -> m b’
01:19:08 <lambdabot>     Expected type: ((a1 -> m1 b0) -> m1 b0)
01:19:12 <mniip> sec
01:20:46 <mniip> ah yes rankntypes is being evil
01:20:48 <mniip> :t \x -> Control.Monad.Codensity.Codensity (x >>=)
01:20:49 <lambdabot> Monad m => m a -> Control.Monad.Codensity.Codensity m a
01:21:49 <absence> mniip: i'm confused, where did the fromF in my question go?
01:22:41 <mniip> well fromF and toF make an isomorphism too
01:23:13 <mniip> as well as retract and liftF
01:23:25 <mniip> and a composition of isomorphisms, is, you know,
01:24:33 <absence> mniip: my question was if fromF and lowerCodensity doesn't to the same thing
01:25:22 <mniip> huh?
01:30:21 <absence> mniip: i'm trying to relate Free.Church.F to Codensity. even if the types are not exactly isomorphic, they're basically about the same idea, right?
01:30:39 <mniip> well
01:30:52 <mniip> F is a CPS-transformed Free
01:30:53 <mniip> so kinda
01:35:03 <absence> mniip: my gut feeling is that if i wrap a non-church Free in Codensity, i should get something that behaves a lot like Church.Free even if the types aren't exactly the same, e.g. lowerCodensity seems to do the same as Church.Free.fromF
01:43:18 * hackagebot rebase 0.2.4 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.2.4 (NikitaVolkov)
01:44:11 <absence> mniip: the types are not necessarily as different as you wrote, they can be forall r. (a -> r) -> (f r -> r) -> r vs forall b. (a -> Free f b) -> Free f b
01:45:02 <absence> mniip: seems like the Free.Church one doesn't let you escape freeness, but is otherwise similar?
01:48:53 <kqr> so i'm writing a tutorial on parser combinators, and the ReadP library from base has a `+++` operator which from what I can tell is reasonably similar to `<|>` from Control.Applicative. is there any reason to teach one over the other? as far as I'm concerned, +++ has the benefit of not needing an import, while <|> has the benefit of being more universally applicable (if you excuse the pun)
01:54:47 <absence> kqr: i'm not familiar with that operator specifically, but in general the community seems divided on whether general or specific functions/operators should be used, cf the whole foldable/traversable in prelude (FTP) drama
01:55:18 <dramforever> kqr: see the source of the instance Alternative ReadP and MonadPlus ReadP, they are *exactly* the same (modulo name differences)
01:56:07 <kqr> well then
01:57:07 <absence> kqr: people who prefer specific types will want +++, and people who prefer general types will want <|>, can't please em all :)
01:58:26 <kqr> i just realised that <|> also has the benefit of being recogniseable in other parser combinator libraries, so if the user wants to move on to parsec there is less to relearn
01:58:30 <kqr> so I think i'll go with <|>
01:58:58 <dramforever> I prefer general types because they make sense immediately if I already know what it is. For example if I see +++ in a parser, I would have to look up the docs to see "Oh that's the choice operator", but with <|> I know instantly that it's from Alternative
01:59:26 * absence agrees
01:59:27 <dramforever> But some may argue that people might not know about Alternative or so...
01:59:35 <kqr> yeah but i'm going to assume someone who reads a tutorial on parser combinators for beginners are not going to be familiar with alternative
01:59:52 <kqr> actually i barely assume familiarity with functor so alternative would be a stretch heh
01:59:55 <liste> that way they'll learn about Alternative (:
01:59:59 <dramforever> kqr: Introduce it then? Couldn't be too hard
02:00:06 <kqr> yeah I'm probably going to
02:00:12 <kqr> I was just gonna see if there was any good reason to use +++ instead
02:00:16 <dramforever> kqr: do you assume that they know typeclasses?
02:00:44 <kqr> so far I've avoided talk about typeclasses, and I think i'm going to keep doing that heh
02:01:24 <dramforever> Uh... In that case we've got a problem here, I think
02:01:43 <dramforever> kqr: perhaps those experiences of avoiding typeclasses can help, I don't know
02:02:53 <kqr> what do you mean?
02:03:18 <dramforever> Uh... no just disregard that
02:03:48 <dramforever> absence: I remember seeing something like this: To write an HTTP server, one has to know about Monad's, MonadState, MonadReader and all other thing completely unrelated to web programming
02:05:05 <dramforever> OTOH If I already know those I can avoid "wasting time" learning to read the query/change server state/etc.
02:05:11 <dramforever> What do you think?
02:06:37 <kqr> dramforever, by "avoiding talk about typeclasses" I mean that I provide a handwavy general explanation of functors alongside a lie to children where I say the reader can think of "fmap read" as ":: Parser String -> Parser Int". that kind of thing. in the case of <|> I'll describe it as a choice operator for parser and provide a more advanced aside where I quickly mention the alternative typeclass and how <|>
02:06:39 <kqr> can be used for other things than parsers :)
02:07:50 <dramforever> kqr: Great then :)
02:10:01 <absence> dramforever: in some other languages you'd have to know about other things completely unrelated to web programming, like memory management or whatever. i think it's unreasonable to avoid learning about monads and similar ideas when writing haskell in the same way i think it's unreasonable to avoid learning about memory and pointers when writing c++
02:10:43 <dramforever> absence: What makes it worse is that people *assume* monads are hard...
02:12:56 <absence> dramforever: yes, and at the same time assume manual memory management is trivial :)
02:12:59 <julianleviston> dramforever: it’s kind of amusing, but I think it’s because of the name.
02:13:31 <absence> dramforever: likely it's a matter of confusing familiarity with easiness
02:17:13 <dramforever> julianleviston: Got a better name? 'Cause I don't think there is one...
02:18:10 <julianleviston> dramforever: ‘course not. There’s no good name for them because they’re so general.
02:18:20 <julianleviston> dramforever: monad is a great name for them.
02:18:57 <julianleviston> dramforever: “computational context” is rather nothingy.
02:19:13 <liste> do CT/Haskell monads relate to philosophical context of monad in any way?
02:19:31 <liste> s/context/concept/
02:19:41 <julianleviston> liste: not from what I’ve heard… 
02:19:55 <julianleviston> liste: I read something about this recently
02:20:39 <julianleviston> liste: oh yeah…  The essence of monad is thus separation of composition timeline from the composed computation's execution timeline, as well as the ability of computation to implicitly carry extra data, as pertaining to the computation itself, in addition to its one (hence the name) output…. 
02:20:43 <julianleviston> https://wiki.haskell.org/Monad
02:24:34 <jellytux> it feels like this chapter never ends, http://learnyouahaskell.com/modules
02:24:36 <jellytux> :'(
02:40:39 <liste> jellytux: too much functions?
02:41:56 <jellytux> liste: yeah, way too many
02:42:15 <jellytux> liste: my head is spinning, kinda
02:42:44 <liste> jellytux: don't sweat too much, you don't need to memorize them
02:42:55 <liste> @hoogle Eq a => a -> [a] -> Bool
02:42:58 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
02:42:58 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
02:42:58 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
02:44:46 <jellytux> liste: True, I am just so eager to start programming in Haskell ^^
02:46:07 <liste> jellytux: just don't skip "Making our own modules"
02:47:11 <jellytux> liste: I wouldn't skip anything, this is gold :D
02:48:00 <dramforever> jellytux: Then just start :) With things you already know you can already do a lot
02:49:30 <jellytux> dramforever: I want to wield all the theory first, though.
02:51:56 <dramforever> Hmm... I guess that would also work. just do whatever you want then
02:53:16 <martinvlk> jellytux: have you seen haskellbook.com ? This is the best beginner-intermediate resource you can get.
02:53:37 <julianleviston> jellytux: it’s really good. So thorough.
02:54:19 <jellytux> Anything wrong with the one I am currently reading?
02:54:43 <jellytux> http://learnyouahaskell.com/
02:55:39 <julianleviston> jellytux: some people dislike it. If you’re enjoying it, all good.
02:56:19 <martinvlk> Er, yes apparently it's not so good from pedagogiacal point of view - you can learn much more effectively - see https://github.com/bitemyapp/learnhaskell
02:56:20 <julianleviston> jellytux: it doesn’t give you a very rigorous understanding of the language, one might say, but on the other hand, it’s an intro tutorial
02:56:59 <jellytux> oh, is that so. Thanks, I'll read the haskellbook.com as well.
02:57:44 <julianleviston> martinvlk: what concrete reasons is it bad from a pedagogical point of view?
02:57:59 <martinvlk> also see this article if you 're interested in seeing why you want to take the proper learning path: http://bitemyapp.com/posts/2014-12-31-functional-education.html
02:58:19 <jellytux> I tried this one a couple of months ago, http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
02:58:43 <jellytux> somehow it made me not want to learn.
02:58:59 <martinvlk> julianleviston: see the details in that article above
02:59:19 <julianleviston> martinvlk: yeah I have. I was talkinga bout your opinions, not Chris’s. Pretty aware of his.
02:59:22 <martinvlk> BTW, I tried a few other resources, and then the haskellbook and I recommend it absolutely
02:59:52 <julianleviston> jellytux: BTW, if you felt like reviewing ours, happylearnhaskelltutorial.com - we’d be pretty chuffed.
03:00:04 <martinvlk> okay, I gave up on a few other learning resources before succeeding with Chrisses book
03:01:01 <martinvlk> because they generally either took very scientific/academic approach which I can't handle.. or they were too basic and I couldn't do any real programming after finishing
03:03:00 <julianleviston> martinvlk: length didn’t bother you at all?
03:03:02 <martinvlk> I find the haskellbook balanced in providing rigour while staying friendly to beginners
03:03:12 <jellytux> julianleviston: sure, I can try. Seems like the page is taking to long time to load though
03:03:18 <jellytux> too*
03:03:43 <martinvlk> julianleviston: no.. I am into really learning, not doing a tutorial or two quickly..
03:04:08 <julianleviston> martinvlk: sure. I didn’t mean the depth. I meant the length.
03:04:42 <julianleviston> martinvlk: was just curious. Also I’m surprised a 10yo managed to read it given the vocabulary.
03:05:00 <julianleviston> martinvlk: but I think it’s a great book
03:05:23 <martinvlk> Feels to me like you can't do so well with short text.. there is lots of exercises which adds to length too.
03:06:09 <martinvlk> given the aim of the book, which is leave you in a place where you can be on your own learning more
03:06:32 <julianleviston> martinvlk: Yeah, I’ve read it. :)
03:06:53 <jellytux> Wow, the one I am reading is getting a really poor reception
03:07:01 <Gurkenglas> Is there a way to derive Show for everything applicable for testing purposes?
03:07:02 <martinvlk> julianleviston: ya, got that.. and it's still in the making BTW
03:07:13 <julianleviston> martinvlk: it’s about the only book to rigourously cover the whole monad track.
03:07:17 <julianleviston> martinvlk: yeah, I know :)
03:07:31 <julianleviston> jellytux: well, to be fair, that website you’re reading is written by the author of the haskellbook.com
03:08:26 <dobq> cocreature: ping
03:08:30 <martinvlk> jellytux, julianlevinston... abd to be fair I have been reviewing all chapters of the book so I'm biased too
03:08:37 <cocreature> dobq: pong?
03:08:46 <dobq> cocreature: you wrote reactand?
03:09:08 <cocreature> dobq: yep
03:09:21 <dobq> cocreature: how's using reflex working out for you?
03:09:51 <dobq> cocreature: also, how is the wlc library?
03:10:26 <cocreature> dobq: it didn’t cause any problems, but I also didn’t feel like it helped me. I ported it to pipes-mvc at some point, but it looks like I haven’t pushed that.
03:10:56 <cocreature> dobq: wlc is pretty nice. you need to do some chan stuff to not have to deal with callbacks, but that’s not too bad
03:11:00 <jellytux> the final book is 1300 pages, I doubt I can read that much
03:11:32 <jellytux> how many pages can you read from an academic book, mathematical or CS book a day?
03:12:11 <martinvlk> jellytux: IMO the point is this is not academical/math book, it's the beginners book, hence the lenght.
03:12:27 <cocreature> dobq: I kinda abandoned the project due to lack of interest and time from my side. feel free to pick it up or use it as a starting point for your own project
03:12:49 <dobq> cocreature: well i might have a look at it for API design inspiration
03:13:10 <dobq> cocreature: i'm writing some wayland stuff and want to keep it as generic as possible
03:16:53 <dobq> cocreature: how far did you get? does it work?
03:17:27 <cocreature> dobq: you can open windows, move them arround, there are multiple workspaces and 3 layouts or something like that
03:18:08 <dobq> cocreature: did wlc offer much over the raw wayland lib?
03:18:46 <cocreature> dobq: I’m not too familiar with the raw wayland lib, but afaik that doesn’t do any of the compositing, so if my understanding is correct, wlc offers a lot
03:20:32 <Gurkenglas> Is there a way to lift something as far as needed for the types to match up?
03:21:24 <dobq> cocreature: what do you mean by "compositing" here?
03:22:09 <dramforever> :t lift -- Gurkenglas: this?
03:22:11 <cocreature> dobq: in wlc I can just tell it where to put windows and what the stacking order is and it does all the actual drawing for me.
03:22:11 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
03:22:31 <dobq> cocreature: okay, that makes sense. thanks.
03:22:34 <cocreature> yw
03:23:35 <Gurkenglas> dramforever: That is only one level. I mean something like liftN :: MonadLift m n => m a -> n a, with instance MonadTrans t => MonadLift m (t m)
03:24:29 <Gurkenglas> And instance (MonadLift m n, MonadLift n o) => MonadLift m o, although hmmm overlaps.
03:26:09 <dramforever> I think mtl is there to work around this overlap
03:26:32 <dramforever> @hackage mtl
03:26:32 <lambdabot> http://hackage.haskell.org/package/mtl
03:27:15 <dramforever> it does so by carrying constraints around functions, so that for example, ask works in any monad stack that contains a ReaderT or Reader
03:27:34 <dramforever> yes, sort of
03:27:51 <Gurkenglas> I know of it, and it doesn't lift enough stuff, so I thought maybe there's a tradeoff that allows me to buy lifting everything
03:29:00 <Gurkenglas> (I want modifyT :: (MonadLift m n, MonadState s n) => (s -> m s) -> n s)
03:29:24 <Gurkenglas> *n () at the end there ofc
03:29:44 <Darwin226> Has anyone used Yesod with the repl?
03:30:02 <Gurkenglas> More generally, stateT :: (MonadLift m n, MonadState s n) => (s -> m (a, s)) -> n a
03:30:13 <dramforever> Gurkenglas: what do you mean by "it doesn't lift enough stuff"?
03:30:31 <Gurkenglas> I mean that in the specific case there's a missing feature
03:30:40 <dramforever> oh... Yeah I guess you would need to change the signatures of your functions
03:32:34 <dramforever> Hmm... sorry it's still not quite right..
03:32:53 <Gurkenglas> Oh wait that wouldn't even work m might be above the StateT.
03:36:06 <julianleviston> How would you say “putStrLn” out loud?
03:36:14 <julianleviston> “put str line”?
03:36:27 <quicksilver> put str luhn
03:36:41 <phadej> julianleviston: I have no problem pronouncing 6 consonants in line
03:36:47 <julianleviston> phadej: haha :)
03:36:49 <quicksilver> or however you want to represent a schwa
03:36:51 <julianleviston> quicksilver: thanks! :)
03:36:55 <Gurkenglas> I do "put str el en" with swallowed es
03:37:50 <cocreature> c is even worse in that regard, try pronouncing strcspn
03:38:05 <phadej> there is a sicp video where the pronunciation of car and cdr and cadr and caddr etc. is discussed
03:38:28 <phadej> I thought it was funny :)
03:39:56 <ktonga> Hi. I'm trying to connect to #haskell using Konversation but it tells me I cant connect cos I'm banned. Do you have any clue why?
03:40:33 <statusfailed> When I do `:i Control.Category`, it shows this: Control.Category.id :: forall (a :: k). cat a a
03:40:36 <statusfailed> what does that mean?
03:40:56 <pavonia> ktonga: You are in the channel right now
03:41:22 <pavonia> Oh, by web client apparently
03:41:25 <ktonga> yeah :) but using another client (webchat)
03:42:46 <Gurkenglas> class MonadTrans t => MonadMTL t m n where liftN :: (t m a) -> n a; instance MonadTrans t => MonadMTL t m (t m) where liftN = id; instance (MonadMTL (t m n), MonadTrans u) => MonadMTL t m (u n) where liftN = lift . liftN; dammit that overlaps too
03:42:58 <ReinH> statusfailed: it means that id has type cat a a for all a of kind k
03:43:10 <pavonia> Oh my, #haskell's ban list is huge
03:43:37 <ReinH> for example, if k = * and cat = (->) then you have Prelude.id
03:46:11 <Gurkenglas> Hmm could you use what I just wrote, but plug in every particular monad transformer for the first instance and every particular pair of different monad transformers for the second instance?
03:46:13 <pavonia> ktonga: Could you connect via that other client and join #haskell-blah, for instance? We could at least see which ban applies for your host then
03:47:25 <haskellquestion3> hi
03:47:35 <liste> hi haskellquestion3 
03:47:51 <haskellquestion3> quick question
03:48:08 <Jinxit> is it a haskellquestion?
03:48:15 <haskellquestion3> yup! trying to think of how to word it
03:48:21 <ReinH> not that quick, I guess.
03:48:27 <haskellquestion3> hehe
03:48:30 <Jinxit> is it your third question?
03:48:45 <haskellquestion3> oh no my name was haskellquestion33 but the extra 3 got cut off
03:48:58 <haskellquestion3> and no it's not my 33rd question either i just typed in random number in to the nickname box
03:50:05 <haskellquestion3> ok so my question: every function in haskell is a single function call/expression right? things like let bindings/do syntax/etc. is all just syntactic sugar over chaining functional composition?
03:50:12 <Gurkenglas> How should I name a class to generalize MonadState, MonadReader, etc.? How should I name an improper monad transformer to generalize IdentityT, MaybeT, ListT, etc.?
03:50:53 <liste> haskellquestion3: pretty much yes
03:51:01 <haskellquestion3> ok perfect!
03:51:12 <haskellquestion3> trying to write a monad tutorial for myself to teach monads to myself and wasn't sure if that point was correct or not
03:51:51 <quicksilver> "case" is not syntactic sugar
03:52:05 <quicksilver> it's genuinely different from function calls / application
03:52:09 <haskellquestion3> pretty funny how you can pretty much do anything with a language where functions can only take one parameter, compute one expression, and return one value
03:52:12 <Darwin226> If I have to do "cabal configure -fdev", how do I do that with stack?
03:52:21 <quicksilver> (unless you church-encode your data types, but we don't)
03:53:25 <ReinH> The basis of Haskell is basically function application and case scrutinization.
03:53:51 <haskellquestion3> yeah i kinda had an epiphany while reading some tutorials
03:54:01 <haskellquestion3> in oop languages you can just do statement1, statement2, statement3, etc.
03:54:06 <ReinH> function application causes case scrutinization, which causes function application, which causes case scrutinization...
03:54:11 <opqdonut> and you can represent case expressions as applications of a destructor function
03:54:18 <ReinH> This is called "evaluation".
03:54:30 <opqdonut> church encoding the data structures
03:54:33 <haskellquestion3> in haskell you just compose for the same effect
03:54:35 <opqdonut> of course that's not practical
03:55:01 <ReinH> @where lazy
03:55:01 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
03:55:21 <ReinH> Is something I always recommend for learning about evaluation in haskell
03:56:00 <haskellquestion3> wait so you said case statements arent functional composition?
03:56:08 <haskellquestion3> is it just for efficiency reasons or?
03:56:23 <opqdonut> case is a primitive for efficiency reasons pretty much yeah
03:56:36 <ReinH> function composition is not primitive.
03:56:42 <ReinH> @src (.)
03:56:42 <lambdabot> (f . g) x = f (g x)
03:56:55 <ReinH> it is defined in terms of application
03:57:08 <haskellquestion3> oh when i said composition i meant f (g x) yeah
03:57:13 <haskellquestion3> not the operator just the math term
03:57:27 <haskellquestion3> sorry i dont really know any haskell i was learning monads just to learn them
03:57:32 <opqdonut> let can also be expressed using functions, but it's still a builtin in haskell
03:57:48 <opqdonut> (and AIUI, it doesn't get turned into a function application even in the compiler)
03:58:11 <ReinH> when f (g x) is evaluated, g x is only evaluated if forced by case scrutinization.
03:58:15 <opqdonut> let a = b; x = y in e  ===  (\a x -> e) b y
03:58:50 <haskellquestion3> so it seems like the end-user has to do everything with functional composition and the haskell compiler/whatever could have done the same thing but implemented certain things under-the-hood more efficiently but for all intents and purposes you can think of it as pure
03:58:54 <haskellquestion3> is that right?
03:59:23 <ktonga> pavonia: #haskell-blah is working
04:00:13 <haskellquestion3> brb brushing teeth
04:01:01 <ktonga> pavonia: I connected as <tonga> with the other client
04:01:51 <quicksilver> ktonga: got it
04:02:05 * quicksilver investigates
04:02:45 <pavonia> ktonga: I can't see a ban that matches, but quicksilver seems to do
04:04:27 <quicksilver> 112 - #haskell: ban *!*Gast*@* [by tepper.freenode.net, 10120711 secs  ago
04:04:28 <pavonia> It seem sto be "*!*Gast*@*"
04:04:31 <quicksilver> that was a long time ago
04:04:43 <haskellquestion3> ok back
04:04:50 --- mode: ChanServ set +o quicksilver
04:04:54 <mchall> I am trying to implement allCombs in terms of combStep combStep :: [a -> b] -> [a] -> [b] combStep flst lst  = zipWith  (\f l -> f l) flst lst  allCombs :: (a -> b -> c) -> [a] -> [b] -> [c]
04:04:59 --- mode: quicksilver set -b *!*Gast*@*
04:05:06 <quicksilver> ktonga: you should be OK to connect now
04:05:34 <ReinH> About 4 months ago.
04:05:38 <mchall> how do I do this partial application ? I am lost on how to do this
04:05:42 --- mode: ChanServ set +b *!*Gast*@*
04:05:42 --- kick: tonga was kicked by ChanServ (User is banned from this channel)
04:05:49 <quicksilver> argh
04:05:53 <ReinH> heh
04:05:58 <quicksilver> got to remove it in chanserv
04:06:46 <haskellquestion3> ok thanks for answering my questions good night everyone
04:07:50 <ReinH> quicksilver: apparently there was a problem with spam from that hostmask about 5 years ago. http://ircbrowse.net/browse/haskell?id=10130835&timestamp=1281228769#t1281228769aa
04:09:13 <quicksilver> it wasn't a hostmask, it was a ircname pattern
04:09:22 <quicksilver> anyone with a username matching *gast*
04:09:29 <ReinH> oh right
04:09:31 <quicksilver> in ktonga's case his username is 'gaston'
04:09:42 <ReinH> that seems overly broad
04:09:46 <quicksilver> agreed
04:10:08 <ReinH> Besides, gaston is an awesome name.
04:10:18 <ktonga> :)
04:13:04 <ktonga> have to go now. will check later if you could solve the problem. Thanks!
04:13:23 --- mode: ChanServ set -b *!*Gast*@*
04:13:30 <quicksilver> ktonga: done :)
04:23:21 <lpaste> Gurkenglas revised “A class that generalizes mtl's classes and an improper monad transformer that generalizes MaybeT and ListT”: “No title” at http://lpaste.net/151726
04:23:23 * hackagebot uu-cco 0.1.0.4 - Utilities for compiler construction: core functionality  https://hackage.haskell.org/package/uu-cco-0.1.0.4 (AtzeDijkstra)
04:24:42 <Gurkenglas> Whoops that's been publicated by lpaste-bot? Anyway whence this parse error? the lpaste doesn't even have ;! http://lpaste.net/151726
04:24:46 <Gurkenglas> @letlpaste 151726
04:24:46 <lambdabot>  Parse failed: Parse error: ;
04:25:53 <lpaste> Gurkenglas revised “A class that generalizes mtl's classes and an improper monad transformer that generalizes MaybeT and ListT”: “No title” at http://lpaste.net/151726
04:26:47 <Gurkenglas> I'll look through ircbrowse later for Gurkenglas if someone finds something.
04:30:53 <statusfailed> ReinH: thanks! (forgot to check this channel earlier :-))
04:39:59 <julianleviston> Do you call (*) a 2-arity function? or a 1 - 1 arity function? lol
04:40:07 <julianleviston> an infix 2-arg function?
04:42:07 <pavonia> binary function is the most common term, I think
04:42:35 <julianleviston> pavonia: I mean what do you call a function \x y z -> ...
04:42:55 <julianleviston> or anything that is curried like that… more than a single arg?
04:43:50 <pavonia> You mean independed of the number of arguments?
04:44:05 <pavonia> *independent
04:44:42 <julianleviston> pavonia: I mean… say we have flip… 
04:44:44 <julianleviston> :t flip
04:44:45 <lambdabot> (a -> b -> c) -> b -> a -> c
04:44:49 <julianleviston> what do you call this function?
04:45:06 <julianleviston> a function of one argument? because all haskell functions are...
04:45:10 <pavonia> A ternary function
04:45:14 <julianleviston> hehe :)
04:45:26 <koz_> Or a function of arity 3.
04:45:31 <julianleviston> but arity?
04:45:35 <julianleviston> there isn’t arity, is there?
04:45:45 <ggole> Arity is not a clear concept in Haskell
04:45:50 <koz_> julianleviston: Technically-speaking no.
04:45:58 <koz_> Because all functions curry.
04:46:03 <julianleviston> exactly.
04:46:13 <pavonia> I don't know a of a term beside curried and x-ary
04:46:20 <julianleviston> but what do we call this function? \x y z a b c -> ...
04:46:23 <julianleviston> ok
04:46:28 <dramforever> :t id id id id id
04:46:29 <lambdabot> a -> a
04:46:31 <julianleviston> lol
04:46:38 <ggole> You can use it to communicate in circumstances where the vagueness doesn't matter, but expecting precise definitions is mistaken
04:46:50 <koz_> ggole: Yeah, that makes sense.
04:46:53 <fizruk> :t fmap fmap fmap fmap fmap fmap fmap fmap  -- dramforever 
04:46:55 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
04:46:58 <julianleviston> I meant how do we communicate that this particular function yields a function that (and so on, 7 times)
04:47:21 <julianleviston> a curried 5-arity function? ;-)
04:47:32 <julianleviston> We don’t really have a way to talk about this
04:48:30 <ggole> I usually just use nullary (well, in ML rather than in Haskell) unary, binary, ternary etc and people tend to understand in practice.
04:49:05 <EvanR> (a,b,c) -> d, arity 3 ;)
04:49:05 <koz_> ggole: I prefer to say 'arity 1', 'arity 2', etc, but always considering the problem of precision you just mentioned.
04:49:19 <koz_> Mostly because words above 'ternary' don't tend to be known by people.
04:49:53 <julianleviston> koz_: it’d be nice if we had a precise word that meant “this function returns a function which returns a function"
04:49:56 <EvanR> koz_: and arity doesnt tend to work either... in clojure arity refers to both number of arguments and type of arguments (for multi-dispatch purposes)
04:50:09 <EvanR> julianleviston: curried
04:50:24 <EvanR> or shoenfinkeled
04:50:28 <koz_> EvanR: See my note above regarding the precise definition of that term.
04:50:48 <julianleviston> EvanR: 3-curried?
04:50:50 <koz_> I know it's not 100% exacting, but provided that no ambiguity can arise, that's OK.
04:50:54 <julianleviston> EvanR: curriety. :)
04:50:57 <julianleviston> I think that will do
04:51:01 <koz_> Lol.
04:51:02 <julianleviston> this is a 5-curriety function
04:51:06 <julianleviston> I’m coining it :)
04:51:40 <koz_> julianleviston: Your function deals with butter chicken, chicken korma, lamb madras, lamb rogan josh and some vege curry, right? :P
04:51:53 <julianleviston> koz_: you forgot the samosas!
04:52:02 <koz_> julianleviston: Samosa /= curry.
04:52:02 <julianleviston> koz_: I know, not curry :)
04:52:22 <julianleviston> koz_: aloo matar? :)
04:52:27 <koz_> julianleviston: That'll do.
04:52:44 <koz_> It appears you have good knowledge of currying.
04:52:53 <koz_> We need us some monad korma in this place.
04:52:57 <EvanR> time for breakfast
04:53:09 <julianleviston> EvanR: 11.52 pm at night? 
04:53:14 <julianleviston> EvanR:  ;-) soz. Couldn’t resist.
04:53:16 <EvanR> 7am
04:53:26 <koz_> Nearly 2am here...
04:53:32 <koz_> (on Saturday morning)
04:53:50 <EvanR> aint nobody got time
05:07:13 <narendraj9> julianleviston: Aloo matar? :-D
05:07:23 <julianleviston> narendraj9: peas and potatoes
05:07:26 <julianleviston> I think :)
05:07:30 <narendraj9> julianleviston: I know that! :)
05:07:31 <julianleviston> maybe you can correct me.
05:07:41 <ktonga> sweet. thank you quicksilver
05:07:44 <narendraj9> potatoes and peas, respectively :)
05:07:50 <quicksilver> ktonga: you're welcome
05:07:58 <ktonga> @karma+ quicksilver
05:07:58 <lambdabot> quicksilver's karma raised to 13.
05:08:41 <narendraj9> julianleviston: You must have been to India? If you are not an Indian. Since this is off topic, I won't say more than this. 
05:09:05 <mniip> does hackage build haddocks nowadays?
05:09:35 <julianleviston> narendraj9: It’s about currying! (or curriety)… so it’s not off topic! jokes. Sydney has a lot of curry places, some of them slightly authentic, I’m told!
05:09:52 <julianleviston> narendraj9: haskellblah if you want to keep talking
05:09:59 <narendraj9> julianleviston: Okay. I see. :) 
05:10:31 <narendraj9> julianleviston: There isn't much I have to say. Never learned how to cook. :-D
05:32:04 <akfp> if I have `data X = A | B; xs :: [X]; xs = ...;  now I want to collect all As in xs.  is there a lens traverse thing for that?
05:32:57 <akfp> filter (\case A -> True; _ -> False) xs kind of thing.
05:37:19 <scshunt> akfp: elements
05:46:21 <jewels> Hi there. Is it possible in haskell to create a kind of "generator" of tuple which satisfies a specific property? For example (7,6, 113)  where 113 is obtained from 7 and 6 in this way: concat_digit(7-6, 7+6)
05:47:10 <quchen> > toListOf (folded . filtered isRight) [Left 1, Right 2, Left 3] -- akfp 
05:47:11 <lambdabot>  [Right 2]
05:47:34 <MasseR> jewels: Sure it's possible, lazy lists etc
05:49:20 <liste> > [(x,y,z) | x <- [1..100], y <- [1..100], z <- [1..100], x*y*z > 10000] -- jewels (couldn't be bothered to write concatDigit)
05:49:22 <lambdabot>  [(2,51,99),(2,51,100),(2,52,97),(2,52,98),(2,52,99),(2,52,100),(2,53,95),(2,...
05:49:39 <MasseR> @type iterate
05:49:40 <lambdabot> (a -> a) -> a -> [a]
05:50:25 <akfp> quchen: If I have a list like that, and I want to focus on the Right ones, extract lenses for those into a list, do some invariant checking, and based on whether invariants hold or not, I want to go back to the lenses and update the structure.  I feel that lenses would be the right tool, but how do I do the transformation.. seems I have to work on something like [Either OrigData (Lens OrigData MyFocus)] .. any intuition on how to work
05:50:25 <akfp> like this?
05:51:15 <chelfi> > [(x, y, (show x ++ show y)) | x <- [1..10], y <- [1..10]]
05:51:17 <lambdabot>  [(1,1,"11"),(1,2,"12"),(1,3,"13"),(1,4,"14"),(1,5,"15"),(1,6,"16"),(1,7,"17"...
05:51:39 <quchen> akfp: Folds violate the lens laws, so they're read-only in order to not break stuff.
05:52:02 <chelfi> > [(x, y, (show (x-y) ++ show (x+y))) | y <- [1..10], x <- [y..10]]
05:52:03 <lambdabot>  [(1,1,"02"),(2,1,"13"),(3,1,"24"),(4,1,"35"),(5,1,"46"),(6,1,"57"),(7,1,"68"...
05:53:15 <akfp> quchen: but wouldn't there be some generic transfomation of a data structure into Either NotTouched (Lens ...) that injects the machinery for a lens only in the places that are "traversed"?
05:55:06 <quchen> akfp: Zippers might allow you to do what you want, but I haven't used them lately
05:55:28 <quchen> akfp: You could implement "get this, go to the next one, get this, then do stuff, then put it back modified"
05:55:33 <quchen> But that sounds very imperative
05:55:35 <srhb> Is it possible to separate two argument parsers in optparse-applicative? Such that "foo bar sep baz quux" gives me foo bar in one list and baz quux in another?
05:58:30 <jewels> MasseR: liste: I've done it in this way http://lpaste.net/151733
06:05:50 <quchen> akfp: If you're interested, here are the lens laws: http://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Type.html#t:Lens
06:06:13 <quchen> Setting stuff with a Fold would violate  set l v' (set l v s) ≡ set l v' s
06:07:05 <quchen> You could for example make all Lefts to Rights, and then set all Lefts to 1. This would not be the same as setting all Lefts to 1 in the first place.
06:11:03 <badmash> hello there
06:11:58 <badmash> if two packages within a cabal sandbox have conflicting dependencies, hwo do you resolve that?
06:13:43 <badmash> appreciate any help
06:17:44 <srhb> badmash: You don't, really.
06:17:53 <srhb> Fix the packages. :-)
06:18:06 <badmash> srhb: so you are simply stuck, i suppose?
06:18:48 <srhb> I tend to try to bump the package dependencies manually if the version mismatch isn't extremely ancient.
06:18:49 <badmash> srhb: even if those packages are libraries from elsewhere
06:18:57 <srhb> Sure, just cabal unpack them and fix them :)
06:19:03 <co-dan> badmash: nuke the sandbox and reinstall it?
06:19:11 <srhb> Then you can use cabal sandbox add-source (or what it's called) to point it to your fixed source
06:19:30 <srhb> It's pretty simple.
06:20:12 <badmash> co-dan: nuking sandbox i don't think will help
06:20:31 <co-dan> badmash: yeah, otherwise what srhb said
06:20:45 <badmash> srhb: isn't this is a common problem likely, especially if you are using a lot of packages from hackage?
06:20:56 <co-dan> sometimes if you install packages in the sandbox not all at once, but one by one, you may arrive at dependency conflicts that do not arise if you install everyhing at the same time
06:21:22 <badmash> co-dan: i see
06:21:22 <srhb> badmash: Not really. It used to be, but mostly people use some curated set with fixed versions.
06:21:31 <srhb> badmash: Like Nix or Stackage provides.
06:21:43 <srhb> There are obviously still broken ones, but usually they are ancient and unmaintained.
06:21:43 <badmash> srhb: curated set from fp complete?
06:21:47 <srhb> badmash: Yes.
06:22:30 <badmash> because right now i amtrying to install a bunch of packages for haskell-mode fo emacs, and they are conflicting with stuff 
06:23:20 <srhb> badmash: Have you tried installing them all with stack?
06:23:32 <co-dan> System Information: Model: MacBook Air (13-inch, Mid-2013) • OS: OS X El Capitan (Version 10.11.3, Build 15D21)
06:23:38 <co-dan> oops, sorry
06:28:26 * hackagebot text-show-instances 3.0.1 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.0.1 (ryanglscott)
06:29:18 <badmash> srhb: sorry, i had got disconnected.  probably missed anything you said
06:30:13 <srhb> badmash: Have you tried to install them with stack instead for the curated sets?
06:31:26 <badmash> srhb: i am aware of stack, but before using that tool, i wanted to get a hands-on understanding of cabal and how it works ...
06:32:13 <srhb> badmash: OK. :) If there are no compatible versions to find, you'll have to make it yourself.
06:32:13 <badmash> srhb: so i wanted to sort of play with it and see for myself, as part of my haskell learning
06:32:19 <srhb> (Regardless of the chosen solution)
06:32:51 <badmash> srhb: i came across this command cabal sandbox init --sandbox .
06:33:07 <badmash> from this site -- http://bob.ippoli.to/archives/2013/01/11/getting-started-with-haskell/
06:33:50 <badmash> cabal sandbox init --sandbox .
06:34:01 <srhb> badmash: What about it?
06:34:33 <badmash> srhb: will that command be a possible solution to manage top-level conflicts within a sandbox?
06:36:34 <srhb> badmash: Doubtful.
06:36:42 <badmash> srhb: i see
06:36:51 <hexagoxel> without that command, you would not have a sandbox in the first place. (unless it already existed.)
06:37:15 <srhb> badmash: I've given you the only solution I know. Unpack one of the packages with the conflicting dependency, fix its versions, fix any type errors as the result, and start over. :)
06:37:41 <badmash> hexagoxel: yes, but it won't resolve conflicts within a sandbox, i suppose
06:38:23 <badmash> srhb: thanks.  one other question -- is there anyway to remove a package and all its dependencies?
06:38:28 <hexagoxel> if you have conflicting versions, it is a) irrelevant if you are using sandbox b) irrelevant if you are using stack or cabal. it wont work.
06:39:00 <badmash> hexagoxel: i see
06:39:54 <badmash> hexagoxel: basically, unless you use a curated set of packages and a tool like stack, you don't have much options
06:41:06 <hexagoxel> uh, what? a curated set, by definition, will not contain conflicting dependencies.
06:41:34 <srhb> badmash: No, cabal-install is not a package manager.
06:41:39 <hexagoxel> "the solution to conflicts is not having conflicts"
06:44:35 <badmash`> srhb: thanks for the help
06:54:24 <hexagoxel> would the no-reinstall cabal feature also allow conflicting dependencies? if the dependency is only used privately, there might be usecases for this.
07:06:17 <Jinxit> what's a good category theory book for a computer scientist?
07:11:36 <hodapp> well there's http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
07:11:51 <scshunt> I believe that's the book I've most commonly seen suggested
07:12:00 <gothos> Jinxit: I like CT for the sciences, but only just started :)
07:26:39 <dobq> Jinxit: awodey?
07:27:24 <hodapp> whodey?
07:28:47 <dobq> hodapp: steve
07:30:27 <co-dan> https://mitpress.mit.edu/books/basic-category-theory-computer-scientists this one is still really good
07:30:41 <co-dan> Barr and Wells is a bit more advanced, maybe
07:40:56 <hasnj> How do i reduce my compilation times?
07:41:43 <co-dan> hasnj: good question. One thing that might work is to disable optimizations
07:43:11 <ktonga> hey, I have to model conversations, something like Reddit threads. Is it a good idea to use Data.Tree? or I shoud create my own ADTs? I prefer simplicity over performance at this moment.
07:43:17 <hasnj> @co-dan: let me try that. I was also trying to add heap size using -H6g option.
07:43:17 <lambdabot> Unknown command, try @list
07:44:08 <hasnj> i dont believe that -H made any difference in my case. Let me disable o2
07:44:25 <co-dan> try setting O0 explicitly
07:45:57 <co-dan> ktonga: I don't know, what kind of features do you want to have? I would imagine you want to find a parent of a comment quickly. Data.Tree does not provide that
07:48:18 <ktonga> co-dan: mainly build the tree from a list of messages sorted my time and be able to write it to json and graph it to console for debugging 
07:49:25 <co-dan> ktonga: ok, then Data.Tree seems like a decent idea. I mean, there is already a function that graphs a tree for you :)
07:49:43 <ktonga> yeah I saw that
07:50:12 <hasnj> http://lpaste.net/151736 my compilation options.
07:50:22 <hasnj> -O0 did not speed up much.
07:50:46 <ktonga> but I think it is not trivial to me figure out how to build the tree from the list. or append a new node at the proper point
07:52:38 <ktonga> co-dan: is there any example you can point me out?
07:55:18 <saurabhnanda> hey good people, I've levelled-up my Haskell-foo and moved on to ORM with Yesod/Persisten
07:55:50 <saurabhnanda> and here are the first two things I got stuck with 10mins into the tutorial: http://stackoverflow.com/questions/35228263/how-to-use-record-syntax-with-yesod-persistent & http://stackoverflow.com/questions/35228162/how-to-omit-fields-that-will-be-filled-in-by-the-database
07:56:01 <saurabhnanda> *within 10mins of the tutorial
07:56:58 <saurabhnanda> thought I'd broadcast them here, cycle home, and check-in again :-)
07:57:45 <puregreen> saurabhnanda: it'd be better if you included the error message, but just for the sake of it, you forgot commas between your fields
07:58:13 <puregreen> it should be User {email="saurabhnanda@gmail.com", createdAt=Nothing, updatedAt=Nothing}
08:00:25 <saurabhnanda> puregreen: thanks. updated http://stackoverflow.com/questions/35228263/how-to-use-record-syntax-with-yesod-persistent
08:01:42 <hasnj> @saurabhnanda : do you have a cabal for the project? cabal repl > :i User will probably help?
08:01:42 <lambdabot> Unknown command, try @list
08:06:43 <puregreen> well, even if there's no cabal project, doing “:i User” in GHCi should still help
08:08:45 <hasnj> @saurab : try userEmail when updating (prefix table name in camel case).
08:08:45 <lambdabot> Unknown command, try @list
08:12:12 <geoffreyiy> @pl (\(i1,i2) -> i1+i2)
08:12:12 <lambdabot> uncurry (+)
08:16:12 <puregreen> from haskell-cafe: “I expect that every single person teaching Haskell is going to be unhappy about [new type of ($) in GHC 8.0]” – what is that type going to be?
08:16:34 <exio4> new type?
08:16:58 <puregreen> probably something involving kinds or whatever
08:17:03 <puregreen> still curious about the details, tho
08:18:46 <glguy> (07$) 07:: forall (w 07:: GHC.Types.Levity) a (b 07:: TYPE w)07.  (a 07-> b) 07-> a 07-> b
08:18:59 <puregreen> ...that's what GHCi prints?
08:19:08 <glguy> Is what I got out of ghci from :t ($)
08:19:33 <puregreen> okay, I see why that would be kinda sli-ightly annoying
08:19:59 <mniip> oh dear
08:20:01 <nitrix> Whao.
08:20:02 <mniip> what in the
08:20:09 <nitrix> Where does that color comes from?
08:20:37 <cordawyn> the color must be a part of the type definition :)
08:20:37 <nitrix> That is super nifty. I love it.
08:20:40 <puregreen> glguy's got nir own IRC client with Haskell syntax highlighting
08:20:55 <nitrix> Can't lambdabot do that too?
08:21:01 <nitrix> Makes me want to implement it.
08:21:05 <glguy> There's other fun stuff, like in the haddocks for Bool it says "data Bool :: TYPE Lifted"
08:21:31 * mniip tests
08:21:37 <mniip> 04($) 04:: forall 04(w 04:: GHC04.Types04.03Levity04) a 04(b 04:: 03TYPE w04).  04(a 04-> b04) 04-> a 04-> b
08:21:44 <mniip> that's what mine says
08:21:49 <mniip> I mean, my highlight scripts
08:23:26 <geekosaur> the Lifted stuff is being actively discussed, apparently it is a bug that it's leaking out of ghc
08:23:47 <mniip> what ghc version is that
08:23:52 <geekosaur> 8.0
08:24:19 <glguy> Levity Lifted is the new * and Levity Unlifted is the new #
08:24:50 <glguy> (w :: Levity) -> Levity w  is like the new ? or whatever we used to use for things that could be either * or #
08:25:09 <glguy> err: (w :: Levity) -> TYPE w
08:25:21 <glguy> TYPE Lifted, Type Unlifted
08:25:27 <nitrix> Would it be bad if lambdabot has color highlighting?
08:25:49 <mniip> is there a thing somewhere where I can read about all these typesystem changes?
08:26:06 <mniip> I've been kinda out of touch
08:26:10 <geekosaur> nitrix, someone would have to contribute the code
08:26:30 <geekosaur> mniip, there's https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1#LandedinHEAD
08:26:33 <nitrix> geekosaur: I'll do it, seems fun and practical :3 
08:26:49 <mniip> I have a C program that replaces ANSI codes with IRC colors, which I compose with gnu's source-highlight!
08:26:58 <puregreen> mniip: also see https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds
08:26:58 <geekosaur> there's also the ghc-devs mailing list which is actively discussing the levity polymorphism stuff leaking out into user visibility
08:27:26 <geekosaur> (someone should mention the thing about data Bool, and possibly file a bug if there isn't one already)
08:27:42 <geekosaur> (haddock probably needs to be brought up to date or something)
08:28:12 <geoffreyiy> @pl (\x -> f2 x C $ f1 x)
08:28:12 <lambdabot> ap (flip f2 C) f1
08:28:44 <geekosaur> (why (am (I (being) parenthetical) again) ?)
08:32:19 <puregreen> (probably because “someone should file a bug” and “there's a discussion on the mailing list” feel like they don't belong to the same branches of conversation? at least that's why I'd be parenthetical if I was you)
08:32:52 <StoneToad> ((I feel like I'm in a RP channel suddenly))
08:37:59 * crough conjures a level 2 monad
08:38:15 * crough hits global state for 10 hp
08:40:03 <mniip> wait
08:40:05 <mniip> you did what?
08:40:18 <mniip> 'read @Int "5"'
08:40:43 * dcoutts has achieved zen enlightenment and no longer believes in the notion of global state
08:41:58 <fryguybob> dcoutts: :D
08:42:18 <dcoutts> crough: keep fighting, you'll make it
08:43:25 <geoffreyiy> @pl (\(i1,i2) -> [(i1+1,i2), (i1 - 1, i2), (i1, i2+1), (i1,i2 - 1)])
08:43:26 <lambdabot> uncurry (ap (ap . ((:) .) . (,) . (1 +)) (ap (ap . ((:) .) . (,) . subtract 1) (ap (ap . ((:) .) . (. (1 +)) . (,)) (flip flip [] . ((:) .) . (. subtract 1) . (,)))))
08:43:32 <geoffreyiy> hmm
08:43:32 <maerwald> dcoutts: state is not the problem, only if it's mutable
08:43:38 <maerwald> and shared
08:43:43 * dcoutts gets back to writing stateful, concurrent distributed algorithms...
08:45:03 <dcoutts> maerwald: oh I embrace mutable state, I just deny the existence of global mutable state
08:51:35 <joko> Hello, could anyone help me with IO and Maybe monads?
08:52:17 <Freundlich> joko: Just ask your question.
08:54:28 <mniip> "For example, this equation would be redundant: vzip VN (VCons x xs) = ..." <- wouldn't it be ill-typed?
08:54:36 <joko> ok, let's try.. I have a function which returns IO (Maybe [a_type_with_show]) and I'm trying to show the output of this type
08:55:52 <domen> hey guys, is anyone of you using leksah?
08:56:04 <domen> or what IDE do you use?
08:56:11 <nitrix> vim mostly.
08:56:15 <mniip> joko, joko and what happens if it's Nothing, or when the list contains multiple items?
08:56:29 <mniip> er, why did I highlight twice?
08:56:43 <nitrix> domen: I'm not a big fan of IDE. A text editor and a good compiler is enough for me.
08:56:47 <domen> what else does vim provide other than sintax highlighting?
08:57:16 <nitrix> domen: Convenient text editing. Obviously text editors don't just highlight.
08:57:34 <joko> So, inside a do notation, I'm calling a function with signature Maybe [type] -> [type] , which has a case: if it is Just value, it putStrLn $ show value, else it putStrLn "nothing"
08:57:57 <martinvlk> I tried Leksah, but found it forcing me to work its way.. in the end I ended up using Emacs with haskell-mode and ghc-mod
08:58:30 <domen> ok, thanks for your answers
08:59:27 <nitrix> joko: You could leverage mapM_
08:59:27 <domen> if i am using just some text editor i am not warned about errors until compile time
08:59:34 <nitrix> :t mapM_
08:59:35 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
09:00:10 <nitrix> joko: mapM_ print $ Just "Hi!"
09:00:34 <joko> nitrix: are you on Linux by any chance?
09:00:47 <nitrix> Not currently, but it's one ssh away.
09:01:16 <joko> Nah, it requires X and haskell-x11 to show you my example
09:01:37 <nitrix> You can forward X through ssh :P
09:02:03 <joko> Fair enough, here's my code https://github.com/xmonad/X11/issues/38 (the last comment)
09:02:12 <chelfi> domen: many text editors can be customized with plugins providing error reporting for instance
09:02:28 <mniip> joko, right, and what happens next?
09:02:30 <nitrix> joko: Start by asking a question; I doubt it's necessary to show the full thing just to print a functor.
09:02:33 <joko> That thing is compiling, so I have *something* right
09:02:47 <joko> mniip: it segfaults :S
09:03:12 <mniip> looks like a library problem
09:03:52 <chelfi> going the IDE way is arguably simpler but a nice consequence of using plugins is you can tailor your editor exactly to your needs (provided your needs are all covered by plugins, that is :D)
09:03:54 <mniip> I've never had GHC segfault without using unsafe*** stuff or leaving the world of lifted types :o
09:04:10 <geekosaur> the X11 bindings have a lot of not checking for NULL returns
09:04:12 <joko> mniip: think so? I mean my code is compiling, but maybe I'm missing something
09:04:29 <geekosaur> this is probably just another example of it
09:04:54 <nitrix> I think the binding just isn't very typesafe.
09:05:11 <nitrix> Probably everything happens in IO and you're essentially working with C through Haskell.
09:05:15 <geekosaur> yes
09:05:31 * mniip . o O ( weechat plugins )
09:06:25 <naudiz> I'm trying to get stack running on my gentoo server, but I always get an error message: Compiler version mismatched, found ghc-7.10.2 (x86_64), but expected minor version match with ghc-7.10.3 (x86_64) (based on resolver setting in /root/.stack/global-project/stack.yaml).
09:06:33 <deni> is there a way to get persistent to return just a User rather a Entity User ?
09:08:10 <naudiz> ghc-7.10.2 is the newest stable version available on Gentoo. Do I REALLY need ghc-7.10.3? Because that would suck.
09:09:22 <geekosaur> stack likes to maintain its own pool of installed ghc-s
09:09:46 <geekosaur> and if the resolver you selected requires 7.10.3, it probably has a reason (probably bug fixes)
09:10:01 <KaneTW> naudiz: that's weird
09:10:04 <KaneTW> i have 7.10.3 on my install
09:10:22 <dalastboss> if i have an algebraic type "CompilerM a b c" and i want to implement a monad instance over the type var a, how would i write that?
09:10:36 <dalastboss> i.e., i'd like to be able to work for all a, b, c
09:10:37 <naudiz> geekosaur: unfortunately, stack setup doesn't work either. I've also tried lts-4.0, it's the same.
09:10:51 <naudiz> KaneTW: you're probably using ~arch?
09:10:57 <KaneTW> yes
09:11:07 <naudiz> KaneTW: that's why.
09:11:12 <KaneTW> also the haskell overlay
09:11:34 <KaneTW>  * haskell                   [Git       ] (git://github.com/gentoo-haskell/gentoo-haskell.git       )
09:11:40 <jasonkuhrt> Can someone suggest how the TypeClass First might implement an instance of Arbitrary?
09:11:54 <naudiz> I don't really want to use ~arch or overlays on my server unless it's absolutely necessary.
09:11:59 <hasnj> i plan to using open mpi for a haskell app: is there anything that I need to watch out for?
09:12:02 <jasonkuhrt> Whoops, I mean, Type First**
09:12:17 <KaneTW> you can just selectively package.keywords ghc
09:12:49 <barrucadu> jasonkuhrt: First from Data.Monoid?
09:12:54 <jasonkuhrt> Yes
09:13:07 <deni> also, with persistent, do I have to manually convert from the type that was made with mkPersist and template haskell or can I use the type it generated?
09:13:20 <naudiz> stack setup gives me: /root/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/bin/ghc-pkg: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory"
09:13:24 <KaneTW> you can use it but i've seen people separate it
09:13:27 <barrucadu> jasonkuhrt: It's just a wrapper around a Maybe, and there's an instance Arbitrary a => Arbitrary (Maybe a)
09:13:36 <barrucadu> So you could do arbitrary = First <$> arbitrary
09:13:42 <deni> KaneTW: why? I mean mkpersist generated both..the db type and the haskell type right?
09:13:47 <KaneTW> it adds a layer of abstraction
09:13:57 <jasonkuhrt> barrucadu: Ok, I'll look at that
09:13:57 <KaneTW> i haven't done it myself but i can see why it's useful
09:14:19 <naudiz> KaneTW: I know I can add keywords for specific programs, but I'd like to know if there's a way around it.
09:14:30 <glguy> naudiz: You might need to enable tinfo support in your ncurses, then
09:14:34 <deni> KaneTW: it also addas a layer ot boilerplate right?
09:14:52 <KaneTW> the boilerplate can be fairly minimal and sometimes useful
09:15:07 <naudiz> glguy: thanks, I totally forgot about that.
09:24:37 <naudiz> okay, by now I'm just desperate: https://bpaste.net/show/8c1842f66bcc
09:25:54 <naudiz> all I want is a damn darcsden server and I can't even get stack working on my server
09:27:27 <Clint> naudiz: apt-get install haskell-stack?
09:28:00 <naudiz> Clint: not funny...
09:28:53 <geoffreyiy> @pl (\xs arr -> foldl' (\foldArr i -> processPath i foldArr) arr xs)
09:28:53 <lambdabot> flip (foldl' (flip processPath))
09:34:40 <naudiz> that shit happens with lts-2.1 as well... no ideas? :/
09:35:31 <glguy> naudiz: Debugging your system is the best part of using Gentoo. Have you tried in #gentoo?
09:35:59 <naudiz> glguy: doesn't look like a gentoo bug to me. They'd probably just send me back here.
09:41:12 <lingxiao> hey all, could someone answer a few questions over at #coq please?
09:41:20 <pilne> having troubles with something stack related? although i hesitate to give any gentoo advice
09:41:49 <pilne> i have zero knowledge of #coq its purpose doesn't suit what I enjoy about programming, much respect to the design of it though.
09:42:10 <glguy> lingxiao: Asking for help in #coq is offtopic in #haskell
09:42:39 <lingxiao> yeah that's why I'm asking someone to come over at #coq to answer a few questions
09:42:41 <naudiz> pilne:  https://bpaste.net/show/8c1842f66bcc that's my problem. right now, I'm rebuilding my system installation of ghc. Maybe it helps.
09:42:42 <lingxiao> no one is over there right now
09:45:16 <pilne> that's way deeper than i've ever been down stack's rabbit hole, but #haskell-stack is a thing (as that looks like stack taking a config-based puke to me).
09:46:38 <naudiz> thanks, I'll try if rebuilding ghc doesn't work
09:48:32 * hackagebot swagger2 2.0.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.0.1 (NickolayKudasov)
10:08:16 <GLM> Is there a way to have Aeson extract fields from a larger JSON blob?
10:08:25 <GLM> It keeps on giving me Nothing when I decode it
10:08:36 <saurabhnanda> what does this mean? ---- data EntityField record :: * -> *
10:08:53 <joeyh> how can I make stack build pass extra-lib-dirs to cabal?
10:08:54 <puregreen> GLM: maybe that's defaulting? if you haven't specified the type you want it's going to assume ()
10:09:10 <joeyh> I tried setting it in ~/.cabal/config, but it seems that is not read when using stack
10:09:25 <bergmark> GLM: if you don't want to type the whole thing you can parse any json into a Value and then access the inner parts you are interested in from that
10:09:34 <GLM> I specified the type at the end of the line with :: Maybe Item
10:09:37 <bergmark> GLM: also, if you use eitherDecode you will get error messages
10:11:45 <joeyh> hmm, looks like maybe the global stack.yaml is supposed to be used for this..
10:14:06 <naudiz> I finally managed to get stack working with an old resolver
10:14:51 <naudiz> now, can anyone tell me what "stack install [--flag darcsden:cli] [--flag darcsden:ssh] [--flag darcsden:closing]" is supposed to mean?
10:15:59 <naudiz> do they mean I'm supposed to run stack install --flag darcsden:cli && stack install ...?
10:16:55 <maerwald> darcsden can be installed easily without stack
10:16:56 <Xnuk> ;q
10:16:58 <naudiz> but even that gives me a parsing error
10:17:09 <puregreen> GLM: if you still haven't solved your problem, perhaps pasting code could help us solve it
10:17:12 <puregreen> @where lpaste
10:17:12 <lambdabot> http://lpaste.net/
10:17:25 <naudiz> maerwald: sure, but I don't like cabal-install :P
10:17:37 <GLM> puregreen:I found the issue but I'm not sure how to solve it. The keys in the Json fields are uppercase
10:17:40 <maerwald> naudiz: you know what [] and <> mean in the context of options/manpages?
10:17:47 <GLM> and you can't have uppercase fields in data objects
10:18:43 <puregreen> GLM: if you are using a generic instance, see https://artyom.me/aeson#generics-handling-weird-field-names-in-data
10:18:43 <naudiz> maerwald: doesn't [] mean it's optional?
10:19:09 <maerwald> yes, so you can do 'stack install --flag darcsden:cli --flag darcsden:ssh --flag darcsden:closing' probably if you want all those
10:19:33 <naudiz> but just stack install makes no sense in a global context, does it?
10:20:28 <naudiz> oh, I guess they want me to pull the source first... I thought it was part on stackage
10:22:01 <puregreen> GLM: (but if your fields are always uppercase, you don't need jsonLower – you can just get away with writing “parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = \(x:xs) -> toLower x : xs}”)
10:23:09 <GLM> puregreen: They're camelCased including the firstChar
10:24:20 <puregreen> GLM: so, fields in your Haskell record look like “someField”, while fields in JSON look like “SomeField”?
10:26:04 <GLM> puregreen:Yeah
10:27:29 <puregreen> GLM: then what I wrote should work
10:32:06 <GLM> puregreen:I'm still getting the same errror
10:33:23 <puregreen> GLM: then write “eitherDecode ... :: Either String Item” instead of “decode ... :: Maybe Item”
10:33:28 <puregreen> the error might help you
10:36:00 <GLM> puregreen:Yeah, I saw that. It says it can't find the "style" value
10:38:31 <puregreen> ouch, sorry
10:38:36 <puregreen> it should actually be the opposite
10:38:39 <puregreen> toUpper, not toLower
10:40:18 <GLM> puregreen:How does that help? That'd make the incoming key "STYLE" when the object requires style
10:41:12 <puregreen> “\(x:xs) -> toUpper x : xs” only modifies the 1st letter
10:41:34 <puregreen> so if your Haskell field is called “style” it's going to search for “Style” in the JSON object
10:43:33 * hackagebot exact-pi 0.4.1.1 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.4.1.1 (dmcclean)
10:48:33 * hackagebot servant-swagger 1.0.1 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.0.1 (NickolayKudasov)
10:51:24 <GLM> What is the most common way to run a file with tests in it?
10:54:23 <sm> good question
10:55:14 <sm> I think all the test frameworks provide a defaultMain or similar, and you make an executable using that
10:55:47 <puregreen> GLM: if your project has a .cabal file, then “cabal test”
10:56:05 <fizruk> GLM: I use doctest and hspec, make test suites in .cabal and run "stack test"
10:57:15 <sm> yes.. where "make an executable" is usually done by defining a test suite in the cabal file
10:57:42 <dcoutts> GLM: tasty (& tasty-quickcheck/hunit/etc) are common libs to use for defining that exe
10:57:44 <jasonkuhrt> Haskell GHC 7.12 become GHC 8?
10:57:46 <jasonkuhrt> Correct?
10:57:49 <sm> running them in GHCI is another option
10:57:56 <dcoutts> jasonkuhrt: yep
10:58:09 <jasonkuhrt> dcoutts: What is the status with Semigroup as superclass of Monoid?
10:58:30 <dcoutts> jasonkuhrt: not sure ottomh
10:58:38 <dcoutts> ask in #ghc
10:58:48 <jasonkuhrt> Sure, thanks
11:01:47 <jasonkuhrt> This answers my question I think https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Phase1GHC8.010365
11:04:51 <dalastboss> is there a way to automatically derive the implementation for Applicative and Functor once I've defined a monad instance
11:04:56 <dalastboss> or must i include the boilerplate
11:06:45 <monochrom> there is a DerivingFunctor extension that derives Functor for obvious cases. it doesn't care about Monad.
11:06:52 <puregreen> dalastboss: there are no default definitions for fmap/etc, but there's not much boilerplate anyway
11:07:02 <puregreen> fmap = liftM, (<*>) = ap, pure = return
11:07:14 <monochrom> otherwise you have to write it out yourself
11:07:16 <mniip> ^
11:07:43 <mniip> it's best to write fmap by hand though
11:07:51 <dalastboss> seems like low hanging fruit
11:07:53 <dalastboss> why?
11:08:09 <mniip> often you can lower the constraints, if any
11:08:19 <monochrom> yes, combining >>= and return is not always the most efficient fmap
11:08:27 <mniip> that too
11:09:29 <monochrom> the overall Haskell language design did not leave room for this.
11:09:42 <monochrom> but see the extension DefaultSignatures
11:10:26 <mniip> hmm I should build ghc 8, these new thingies sound fun
11:10:29 <saurabhnanda> got stuck again -- http://stackoverflow.com/questions/35231697/how-to-let-default-values-comes-from-the-database
11:10:43 <monochrom> there are people who see my answer and press on to ask "why didn't the design do this or leave room for this???!!!!!"
11:11:49 <monochrom> they do not understand, or do not want to accept, the very simple reality that "you weren't around when the Haskell committee when they did it"
11:14:13 <monochrom> there were a million trade-off points to consider and a million conflicting things at stake.
11:14:55 <monochrom> everyone thinks "my stake is obvious" and yet everyone's stake opposes each other.
11:15:13 <geekosaur> people are still human. film at eleven >.>
11:15:46 <monochrom> if you weren't lucky enough to be around when the committee was in session, then very simply and very obviously, your view would not be represented at all, other people didn't even think that it existed.
11:15:59 <mniip> geekosaur, is water still wet?
11:17:41 <mniip> wait, there's no ghc 8.0, just 7.11, is there
11:18:14 <geekosaur> also, often enough that view *didn't* exist. if you can guess what kind of tricks someone will come up with 20 years down the road, you're well beyond the rest of humanity
11:18:46 <geekosaur> mniip, 8.0 is still in prerelease. there is an rc1 from last month and they're working on getting an rc2 out hopefully within the next few days
11:18:57 <mniip> I don't see a git tag
11:19:15 <mniip> I just fetched HEAD and it tells me: checking for GHC version date... inferred 7.11.20160205
11:19:32 <EvanR> master?
11:19:39 <EvanR> HEAD is a local pointer
11:20:00 <monochrom> yeah, every branch has its own HEAD
11:20:43 <mniip> HEAD -> master, origin/master, origin/HEAD
11:21:29 <mniip> oooh
11:21:44 <mniip> for some reason it was only fetching one branch
11:21:53 <mniip> origin/ghc-8.0 I see now
11:22:29 <geekosaur> you often need 'git fetch --all' to get it to look beyond whatever branch you first checked out
11:25:00 <Mirry> Hello everyone! How can I write this in a cleaner, better way? map (fmap (+2)) [Just 3, Just 4] (Just out of curiousity)
11:25:52 <shachaf> That way looks pretty clean and good to me.
11:51:39 <dalastboss> i just made minor changes to my source and i am now getting a linker error
11:51:45 <dalastboss> not really sure what do with this
11:55:13 <pikajude> is ExceptT an invalid candidate for a MonadMask instance?
12:23:36 * hackagebot haskell-bcrypt 0.3.2 - A bcrypt implementation for haskell  https://hackage.haskell.org/package/haskell-bcrypt-0.3.2 (BrettCarter)
12:23:38 * hackagebot lambdacube-ir 0.2.0.0 - LambdaCube 3D intermediate representation of 3D graphics pipelines  https://hackage.haskell.org/package/lambdacube-ir-0.2.0.0 (CsabaHruska)
12:25:05 <zq> what is this levity thing
12:26:58 <geekosaur> intended to be more principled than the old hackery where unboxed stuff showed up as kind # instead of * and there was hackery all over the place to support it
12:27:55 <f-a> foldr f z t = appEndo (foldMap (Endo #. f) t) z <-- what the hell is (#.)?
12:28:04 <zq> as in, (# Int, Int)?
12:28:22 <zq> damn, i was so used to # already
12:28:36 * hackagebot lambdacube-gl 0.4.0.0 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.4.0.0 (CsabaHruska)
12:29:06 <puregreen> f-a: it's a faster variant of (.)
12:29:29 <f-a>    puregreen f-a: it's a faster variant of (.)
12:29:31 <f-a> woops
12:29:36 <puregreen> f-a: specifically, it's used as <newtype constructor> #. <function>
12:29:41 <f-a> thanks puregreen 
12:29:53 <Axman6> where's it from?
12:30:04 <puregreen> http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Unsafe.html#v:.-35-
12:30:04 <mpickering> Can you have injective open type families?
12:30:23 <f-a> from foldr implementation
12:30:27 <f-a> or you mean where it is defined?
12:30:34 <Axman6> yes
12:30:56 <nitrix> Why does so many of the terms in Haskell / theory have barely anything to do with what it does?
12:31:06 <meditans> Mirry: you may prefer the more symmetrical (fmap . fmap) (+2) [Just 3, Just 4]
12:31:09 <Axman6> is it the coerce based version of (.) for endomorphisms?
12:31:20 <puregreen> (just in case: you're only supposed to use it with newtypes and other things that don't change the underlying representation. Otherwise bad stuff will probably happen.)
12:32:29 <mniip> sphinx-build: error: no such option: -b
12:32:30 <mniip> o-O
12:32:35 <mpickering> there's no probably about it.. it's defined using unsafeCoerce
12:33:20 <puregreen> mpickering: “probably” because it's got a Coercible constraint and so I guess you can't actually use it with anything that isn't a cast
12:33:36 * hackagebot lambdacube-compiler 0.4.0.0 - LambdaCube 3D is a DSL to program GPUs  https://hackage.haskell.org/package/lambdacube-compiler-0.4.0.0 (CsabaHruska)
12:33:47 <mpickering> Why is it in the profunctor class in the first place?
12:35:28 <puregreen> if I had to guess, “edwardk had to use it for lens and so it had to be more general than it'd be otherwise”
12:36:18 <puregreen> the #. that f-a mentioned isn't from Profunctor, tho, it's defined internally in base
12:37:16 <puregreen> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Foldable.html#%23.
12:38:36 * hackagebot lambdacube-gl 0.4.0.1 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.4.0.1 (CsabaHruska)
12:38:38 * hackagebot lambdacube-gl 0.4.0.2 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.4.0.2 (CsabaHruska)
12:39:07 <shachaf> Here is the origin of #. and .#: https://github.com/ekmett/lens/issues/75
12:46:17 <jmg`> I'm giving stack a go and Control.Monad.State is not found. I have a feeling that I've missed something obvious, but initial Googling has failed to find it. Any hints?
12:46:49 <dmj`> jmg`: stack install mtl
12:47:08 <dmj`> stack ghci
12:47:12 <dmj`> import Control.Monad.State
12:47:20 <mniip> sphinx-build: error: no such option: -b <- any idea what is that supposed to mean
12:47:26 <mniip> (trying to build ghc 8)
12:48:39 <jmg`> dmj: import Control.Monad.State
12:48:40 <jmg`>  
12:48:40 <jmg`> <no location info>:
12:48:43 <jmg`>     Could not find module ‘Control.Monad.State’
12:48:46 <jmg`>     Perhaps you meant
12:48:49 <jmg`>       Control.Monad.ST (from base-4.8.2.0)
12:48:52 <jmg`>       Control.Monad.ST.Safe (from base-4.8.2.0)
12:48:55 <jmg`>       Control.Monad.Fix (from base-4.8.2.0)
12:48:59 <jmg`>  
12:49:11 <kadoban> jmg`: In what context are you trying to do this? In a package you're writing? ghci?
12:49:49 <jmg`> dmg: Sorry, missed your first line (stack install mtl). That'll be it ...
12:52:29 <rui1> Is it worth learning that haskell intermediate compiled language to understand reasonably well haskell?
12:52:35 <jmg`> OK, some progress: import Contol.Monad.State
12:52:35 <jmg`>  
12:52:35 <jmg`> <no location info>:
12:52:35 <jmg`>     Could not find module ‘Contol.Monad.State’
12:52:38 <jmg`>     Perhaps you meant
12:52:43 <jmg`>       Control.Monad.State (needs flag -package-key mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8)
12:52:46 <jmg`>       Control.Monad.Cont (needs flag -package-key mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8)
12:52:46 <jmg`>       Control.Monad.List (needs flag -package-key mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8)
12:52:49 <jmg`>  
12:52:52 <jmg`> But it's not clear to me *where* the flag -package-key-etc is needed
12:52:58 <mniip> jmg`, you mgiht wanna use a pastebin
12:53:07 * mniip eyes Sigyn
12:53:15 <rui1> jmg` you left my question buried in a second
12:53:34 <jmg`> rui1, sorry
12:53:56 <jmg`> mniip, is there a preferred pastebin here?
12:54:09 <mniip> @where lpaste
12:54:09 <lambdabot> http://lpaste.net/
12:54:39 <mniip> it has paste announcements too \o/
12:56:06 <dmj`> jmg`: you spelled it wrong, should be 'Control.Monad.State'
12:59:34 <jmg`> dmj, how embarassing! Now I get
12:59:34 <jmg`>  Could not find module ‘Control.Monad.State’
12:59:34 <jmg`>     It is a member of the hidden package ‘mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8’.
12:59:34 <jmg`>  
13:00:02 <kadoban> jmg`: In what context are you trying to do this? In a package you're writing?
13:00:26 <MarcelineVQ> that means you need to add mtl to your .cabal file's build-depends
13:00:36 <kadoban> jmg`: In other words, in there a .cabal file associated with whatever code you're messing with?
13:01:03 <kadoban> jmg`: If so, add mtl in the build-depends in the .cabal file. Otherwise, try: 'stack ghci -package mtl'
13:01:20 <dmj`> jmg`: call `stack ghci` from a directory that doesn't have a cabal file
13:02:48 <dmj`> jmg`: you can do it
13:03:46 <jmg`> dmj, `stack ghci` in a directory without a cabal file does the trick. Many thanks.
13:05:08 <jmg`> kadoban, adding mtl to the builds-depends in the cabal file also works. Many thanks!
13:06:22 <quxbam> Whats the recommended way to:  DiffTime -> Double?
13:06:36 <quxbam> fromRational . toRational ?
13:07:04 <mniip> wut
13:07:42 <mniip> error :: forall (v :: GHC.Types.Levity) (a :: TYPE v). (?callStack::GHC.Stack.Types.CallStack) => [Char] -> a
13:07:43 <mniip> o-O
13:08:21 <mniip> that's a new one
13:10:13 <monochrom> levity?!
13:10:47 <mniip> I'm more interested in CallStack
13:10:57 <monochrom> oh god, BOX and kind are not enough, we need a new level "levity"
13:11:03 <mniip> BOX is gone
13:11:06 <badmash> hello
13:11:07 <mniip> long live box
13:11:12 <geekosaur> mniip, introduced in 7.10 actually
13:11:26 <dmj`> levity?
13:11:29 <monochrom> yeah, the callstack part would be nice
13:11:38 <mniip> what's that even
13:11:47 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack/ImplicitLocations
13:12:09 <monochrom> it looks like "levity" is some generalization of kind, or a level above kind, or even the whole notion of "level" itself
13:12:10 <mniip> monochrom, in case you haven't heard, we now have type * = TYPE Lifted, and * :: *
13:12:10 <geekosaur> the machinery was added in 7.10, the full implementation is in ghc8
13:12:25 <monochrom> oh haha, I love * :: *
13:12:35 <mniip> type # = TYPE Unlifted
13:12:37 <geekosaur> monochrom, it's the replacement for the # and * kinds, allowing levity polymorphism
13:12:51 <badmash> if i have installed a package in a sandbox, and this package is need by many projects that are sandboxed themselves, is there a way to get this done?
13:13:01 <geekosaur> the fact that it's leaking into these types visibly is considered a bug
13:13:04 <mniip> I wanna check out GADT kinds though :o
13:13:29 <monochrom> Chinese proverb: "paper can't wrap fire"
13:13:37 <glguy>  /ˈlevədē/ noun. humor or frivolity, especially the treatment of a serious matter with humor or in a manner lacking due respect.
13:15:05 <badmash> appreciate any help
13:15:16 <geekosaur> badmash, cabal can't do that. stack "stashes" packages and can link them between its sandboxes
13:15:36 <badmash> geekosaur: i see
13:15:48 <geekosaur> in general it's kinda weird though; if you built it in a sandbox, it's to keep it out of other sandboxes...
13:15:56 <mniip> huh
13:16:00 <mniip> what's TypeInType
13:16:08 <dcoutts> badmash, geekosaur: this is one of the things the next-gen cabal will do properly, full sharing (not just with pre-defined package collections)
13:16:53 <megaTherion> Hi
13:17:28 <koz_> I need a function Int -> Int -> [(Int, Int)], which generates all 2-combinations of all natural numbers in the closed interval of its first two arguments, in order. Is there something like this already around, or am I hand-rolling?
13:17:46 <megaTherion> Im trying to get more into haskell, Im tracking some lessions at http://learnyouahaskell.com/syntax-in-functions#pattern-matching - however the bmi example with the where clause is not working due syntax error at thte second assign below 'where'...
13:17:58 <dcoutts> koz_: sounds like list comprehensions will help you
13:18:19 <koz_> dcoutts: Yeah, that's a good call. I'll have to look into those.
13:19:09 <codedmart> natefaubion I set ghc-options: -Wall -02 -threaded, but when I run stack build then stack exec I get `registerDelay: requires -threaded`
13:19:14 <geekosaur> megaTherion, check your indentation
13:19:44 <codedmart> sorry didn't mean to have natefaubion in there
13:19:53 <codedmart> That question was for anyone.
13:21:02 <glguy> codedmart: The -threaded options goes on the executable and not the library, maybe you put it on the library?
13:21:07 <koz_> dcoutts: Thanks - list comprehensions make this super-easy!
13:21:16 <dcoutts> koz_: yep :-)
13:22:17 <codedmart> glguy I have it under executable.
13:22:24 <codedmart> Do I need to reconfigure or something?
13:22:29 <koz_> I *believe* this gets me all the 2-combinations in order in the interval [0, 3].
13:22:32 <koz_> [(i, j) | i <- [0..2], j <- [1..3], i /= j, i < j]
13:23:07 <koz_> With a redundant filter, admittedly.
13:23:15 <megaTherion> geekosaur: not really sure what I should do about indention, if I do it like in the example it wont work....
13:23:36 <glguy> megaTherion: A common indentation issue is if your editor doesn't know that tab stops are at 8 spaces
13:24:14 <badmash> dcoutts: so when you have a package X that is used by many others, but X has to be sandboxed because it has conflicts with other packages, how did people deal with that before stack came in?
13:24:35 <dcoutts> badmash: add X to each sandbox
13:25:03 <megaTherion> glguy: thanks, that did it - the magic '8' I didnt know... ^^
13:25:24 <quxbam> koz_: you can as well put in the j the i
13:25:40 <badmash> dcoutts: i suppose that is the only to have it working now
13:25:41 <quxbam> [(i, j) | i <- [0..2], j <- [i+1..3]]
13:25:55 <glguy> megaTherion: It is recommended to set your editor to not use actual tabs, but expand them out with spaces when writing Haskell files
13:26:15 <dcoutts> badmash: and that's more or less how the next-gen cabal will do it too, each project is isolated by default, and conceptually you use X in each project, but if projects need X built in the same way then they'll automatically share it
13:26:54 <megaTherion> glguy: then I'll just do that :)
13:26:58 <badmash> dcoutts: the future version of cabal you were talking about -- is that nix-style version of cabal?
13:27:06 <dcoutts> badmash: exactly
13:27:31 <badmash> i heard that it may be in GHC 8.0?
13:27:32 <dcoutts> badmash: so if you're beta-testing that branch then you'll get this behaviour today
13:27:56 <dcoutts> badmash: well, we're merging it at the moment but it'll only be a tech preview, not all the features are completed
13:28:03 <badmash> dcoutts: i see
13:28:18 <dcoutts> but it's enough for several people to be using it as their default
13:29:07 <badmash> dcoutts: in your blog, you had outlined another thing about curating hackage.  i am not sure where it is now, but i think that will help heck of a lot
13:30:39 <dcoutts> badmash: yes, there's a fair bit of curation going on now by the hackage trustees, see matrix.hackage.haskell.org
13:31:21 <dcoutts> badmash: I also mentioned hosting currated collections on hackage. We'll likely do that once the nix style cabal is stable
13:31:35 <dcoutts> or if we get more volunteers :-)
13:31:53 <dcoutts> there's a design spec and prototype code available for someone to pick it up
13:32:31 <mniip> is there a command-line option to ghci to import some modules?
13:32:43 <orion> dcoutts: How would maintainers tightening version constraints affect packages which use stack?
13:32:46 <badmash> dcoutts: yes, that's what i was referring to -- hosting curated collections on hackage
13:33:01 <dcoutts> orion: well we've been doing that now for some time
13:34:44 <dcoutts> orion: in principle a collection could conflict with tightened constraints, but if it actually worked with the version the collection used then that'd mean the tightened constraints were too tight
13:35:25 <badmash> dcoutts: would this be something along the lines of ruby bundle etc?
13:35:29 <dcoutts> orion: the hack/workaround until the constraints were corrected would be --allow-newer=$the-pkg-in-question
13:36:04 <dcoutts> badmash: no, that's more of a local frozen thing, rather than a publicly hosted/distributed collection
13:36:16 <dcoutts> badmash: that's more like what you get now with cabal freeze
13:36:18 <badmash> dcoutts: yes
13:36:52 <koz_> If I have five [[a]], and wanna get out *one* [[a]] made by concatenating the rows of all the five input [[a]]s in that order, what should I use?
13:37:05 <mniip> :t concat
13:37:06 <lambdabot> Foldable t => t [a] -> [a]
13:37:13 <mniip> oh, rows
13:37:14 <badmash> dcoutts: i see
13:37:43 <mniip> koz_, what if the inner (middle) []'s had different amount of elements?
13:38:01 <koz_> mniip: Across each of the five inputs, or within an input?
13:38:05 <mniip> err
13:38:12 <mniip> I am slightly confused now :D
13:38:39 <GLM> How can I decode from JSON if the value is \"45\" and I want an Int?
13:38:43 <monochrom> could you write a test case to show what you mean?
13:38:45 <koala_man> koz_: map concat?
13:38:45 <badmash> dcoutts: i think the crux of the difficulty is in the publicly hosted collection
13:38:59 <badmash> you know, all the dependencies
13:39:01 <koz_> koala_man: Thank you - that seems like exactly what I sought.
13:39:07 <mniip> what monochrom said
13:39:34 <mniip> from what I read you want zipWith5 (\a b c d e -> a ++ b ++ c ++ d ++ e)
13:39:36 <mniip> but I'm not sure
13:40:05 <a0a95251> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6]]
13:40:07 <lambdabot>  [[1,4],[2,5],[3,6]]
13:40:13 <monochrom> GLM: get a String, then add readMaybe for the Int
13:40:24 <dcoutts> badmash: hmm? I'm not sure what you're getting at
13:40:33 <GLM> monochrom: decode {\"Price\" : \"100\"} == (PriceResponse 100)
13:40:49 <GLM> monochrom:Where do I put readMaybe? The parse is failing before I can get to it
13:41:11 <monochrom> in your FromJSON instance.
13:41:24 <monochrom> and yes you have to write your own FromJSON instance. no automation.
13:41:44 <monochrom> since the automation does not allow deviating from standards
13:41:49 <GLM> monochrom: I already did but it is saying it has a parser Int, not a String
13:42:10 <mniip> paste code and the error
13:42:12 <monochrom> show actual complete code
13:42:47 <badmash> dcoutts: sorry, you can ignore what i said ... but being able to install as well as uninstall pacakes with ease with nix-like system would be cool
13:43:13 <dcoutts> badmash: we had a GSoC student work on uninstall by nix-style GC
13:43:38 <GLM> http://lpaste.net/151757
13:44:07 <badmash> dcoutts: yes, i read about it ... ezyang mentioned it on reddit
13:44:50 <badmash> dcoutts: anyway, thanks for your time
13:44:55 <dcoutts> np
13:45:00 * dcoutts gets on with merging
13:45:02 <dcoutts> :-)
13:45:12 <deni> again question about persistent and about keeping a type for the db entity (eg. User) and a Haskell data type for the rest of the program (eg. Person). What if I don't want to come up with different names? Do I keep the Models in one module and the rest of the types in a different module and then just do qualified import?
13:45:23 <deni> how many people actually do this in practice?
13:45:23 <GLM> Error is : Left "Error in $.CurrentRetail: failed to parse field CurrentRetail: expected Int, encountered String"
13:45:36 <GLM> monochrom:Any ideas?
13:46:47 <monochrom> do { s <- v .: "CurrentRetail"; case readMaybe s of Nothing -> mzero; Just n -> return n }
13:47:31 <monochrom> readMaybe is in Text.Read
13:47:54 <glguy> GLM: *Main> decode "{\"CurrentRetail\":10}" :: Maybe PriceResponse 
13:47:55 <glguy> Just (PriceResponse {price = 10})
13:47:59 <monochrom> but you should fix the JSON origin and have it obey standards, namely, numbers do not have quotes
13:48:54 <glguy> monochrom: Maybe the prices exceed 2^53 and they worry about loss of precision
13:51:23 <Welkin> monochrom: a lot of times in yaml config files I *must* quote numbers for it to work
13:51:26 <Welkin> strangely
13:51:34 <Welkin> specifically for keter
13:51:41 <monochrom> yes but is yaml JSON?
13:51:52 <Welkin> it uses the same json parsers
13:52:03 <Welkin> not sure about the standard though
13:52:23 <rui1> When running nixos-rebuild, "This version of Nixpkgs requires Nix >= 1.10, please upgrade"
13:52:38 <monochrom> I read the RFC. it explicitly says " means strings, numbers aren't quoted, there is no ambiguity or guessing.
13:52:40 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/151757#a151758
13:52:55 <rui1> Now, after running what the site suggests, it says it installed nix 1.11. Yet the message remains
13:53:58 <monochrom> fail is better than mzero. I forgot that I could use fail to add an error message
13:54:12 <monochrom> (for aeson anyway)
13:54:40 <glguy> I'd have left it alone if I noticed you'd pasted code to channel already
13:54:54 <GLM> glguy:How are you getting that? My decode requires a byteString
13:55:17 <glguy> OverloadedStrings, same as you're using in your source file
13:58:13 <codedmart> If I want to run a command every minute what would I use?
13:58:19 <codedmart> Not sure what to look for.
13:58:34 <puregreen> codedmart: maybe forever + threadDelay
13:58:47 <codedmart> puregreen Great thanks!
13:58:48 <mniip> interesting
13:58:59 <monochrom> use ghcjs and call setInteval  <duck>
13:59:23 <mniip>     • GHC internal error: ‘Ghci1.f’ is not in scope during type checking, but it passed the renamer
13:59:24 <mniip>       tcl_env of environment: []
13:59:40 <puregreen> or, or use GTK and timeoutAdd
13:59:44 <puregreen> lots of great options
13:59:45 <mniip> sounds like bug report material
14:00:32 <mniip> oh, it's not actually new
14:00:39 <GLM> glguy:That example wasn't what I needed. The input I have is "{\"CurrentRetail\":\"10\"}"
14:00:46 <GLM> Note the quotes on 10
14:01:44 <monochrom> actually GHC.Event has something similar to javascript window.setTimeout. maybe you can consider it.
14:02:24 <puregreen> GLM: if you want to parse this quoted 10 as a number, you can use readMaybe
14:02:57 <GLM> puregreen:Yeah but where do I put the readMaybe in my parseJson?
14:03:14 <puregreen> you'll have to stop using the generic instance
14:04:08 <GLM> I'm not using the generic instance.
14:05:13 <puregreen> http://lpaste.net/151759
14:06:08 <puregreen> tho it's also possible to do a bit better than that with parseJSON, a sec
14:06:43 <puregreen> http://lpaste.net/151760
14:06:46 <puregreen> I think this might work
14:07:04 <rui1> "nixos-rebuild automatically fetches and uses the latest version of Nix ", but when I use it it complains for needing a version >=1.10. But I already upgraded to 1.11
14:07:09 <puregreen> no
14:07:10 <puregreen> won't work
14:07:14 <rui1> Any ideas?
14:07:46 <rui1> Btw, I am using nixos-rebuild with the -I option 
14:09:06 * hackagebot remote-monad 0.1.0.1 - An parametrizable Remote Monad, and parametrizable Applicative Functor  https://hackage.haskell.org/package/remote-monad-0.1.0.1 (AndyGill)
14:19:54 <zalatovo> Anyone have any idea what could be causing Emacs (Spacemacs) to be indenting my data definitions weirdly?
14:20:04 <zalatovo> Specifically, it doesn't align | and = anymore
14:20:22 <zalatovo> Not entirely sure if an update in Spacemacs is the issue, or haskell-mode itself
14:21:10 <monochrom> it's probably a new decision in haskell-mode 13.18
14:21:58 <monochrom> because I think I recall in 13.16 it aligned | under =. and I am on vanilla emacs24
14:22:54 <zalatovo> monochrom: found a commit for haskell-mode titled "Align | with = in data declarations" from a day ago
14:23:00 <zalatovo> monochrom: so it's probably that
14:28:48 <lambda-11235> Anyway to force cabal install with a mismatched base dependency?
14:32:07 <glguy> lambda-11235: There's the --allow-newer[=DEPS] flag if you're trying to use a newer version of the dependency that is otherwise allowed
14:32:29 <glguy> lambda-11235: Beyond that you can use "cabal get" to download and unpack a package in order to edit it before you install it
14:32:56 <glguy> of course there are no guarantees that the new version of base will work
14:33:04 <zalatovo> monochrom: you were right, downgrading to 13.16 "fixes" it, thanks :)
14:36:00 <bluezone> Who would like to hear a nice joke?
14:36:24 <lambda-11235> bluezone: Only is it's nice.
14:36:32 <bluezone> I am currently programming in ABAP
14:37:13 * bluezone dies of laughter at his pathetic career
14:37:23 <hiptobecubic> :D
14:38:21 <bluezone> I don't think there is a single element of functional programming in ABAP lol
14:38:44 <glguy> bluezone: Unfortunately ABAP is off-topic in #haskell
14:41:52 <puregreen> anybody got an example of a simple CPS parser?
14:43:19 <puregreen> I tried looking at attoparse but it goes beyond basics and I want to get the idea first
14:43:23 <puregreen> * attoparsec
14:54:25 * hackagebot graph-rewriting-gl 0.7.6 - OpenGL interface for interactive port graph rewriting  https://hackage.haskell.org/package/graph-rewriting-gl-0.7.6 (JanRochel)
14:54:28 * hackagebot graph-rewriting-lambdascope 0.5.7 - Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system  https://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.7 (JanRochel)
14:54:30 * hackagebot graph-rewriting-layout 0.5.4 - Force-directed node placement intended for incremental graph drawing  https://hackage.haskell.org/package/graph-rewriting-layout-0.5.4 (JanRochel)
14:59:26 * hackagebot graph-rewriting-ski 0.6.5 - Two evalutors of the SKI combinator calculus as interactive graph rewrite systems  https://hackage.haskell.org/package/graph-rewriting-ski-0.6.5 (JanRochel)
14:59:28 * hackagebot graph-rewriting-strategies 0.2.4 - Evaluation strategies for port-graph rewriting systems  https://hackage.haskell.org/package/graph-rewriting-strategies-0.2.4 (JanRochel)
14:59:30 * hackagebot graph-rewriting-trs 0.1.7 - Evaluate first-order applicative term rewrite systems interactively using graph reduction  https://hackage.haskell.org/package/graph-rewriting-trs-0.1.7 (JanRochel)
14:59:32 * hackagebot graph-rewriting-ww 0.3.5 - Evaluator of the lambda-calculus in an interactive graph rewriting system with explicit sharing  https://hackage.haskell.org/package/graph-rewriting-ww-0.3.5 (JanRochel)
15:03:34 <ReinH> puregreen: well, how familiar are you with CPS in general?
15:04:51 <joehillen> do dependent typed languages prevent integer overflow? 
15:05:16 <joehillen> I googled, but I can't find any examples of whether they do or not
15:05:49 <ReinH> joehillen: they can
15:06:40 <ReinH> For example, in the ATS language integer overflow can be made a type error.
15:06:45 <ReinH> https://bluishcoder.co.nz/2013/05/07/ranged-integer-types-and-bounds-checking.html
15:07:57 <joehillen> Are Idris' or Agda's Int types bounded?
15:08:21 <rui1> How can I make nixos upgrade nix >=1.10?
15:08:46 <monochrom> bounded does not imply can overflow
15:08:49 <vikingofrock> is there a way to define a function Monad m => (a -> m b) -> m (a -> b) ? Bonus points if it can be done for Functors or Applicatives, instead of just Monads
15:09:08 <hpc> vikingofrock: it's not possible
15:09:21 <puregreen> ReinH: not really but I've already decided to just start coding and see whether I get stuck in an hour or not :)
15:09:23 <hpc> vikingofrock: as an example, putStrLn :: String -> IO ()
15:09:26 * hackagebot graph-rewriting-lambdascope 0.5.8 - Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system  https://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.8 (JanRochel)
15:09:27 <joehillen> monochrom: I would think it would mean the opposite
15:09:29 <hpc> a = String, m = IO, b = ()
15:09:47 <hpc> supposing you could transform it as you propose, we'd get
15:09:48 <rui1> I can do it with nix-env, but nixnos-rebuild still complains that it doesn't have it when I use a custom nixpkgs (which has nix 1.11)
15:09:49 <monochrom> a designer can very well decide "I am so doing mod-32 arithmetic" and so it is bounded and no overflow
15:09:52 <hpc> IO (String -> ())
15:10:03 <hpc> which somehow is still able to express the printing of the string
15:10:06 <ReinH> puregreen: well, the basic idea of CPS in attoparsec is that success and failure continuations are supplied and invoked depending on the result of a parse step.
15:10:26 <vikingofrock> hpc: okay, yeah that makes sense
15:10:31 <mniip> 1454713730 [02:08:50] <hpc> vikingofrock: as an example, putStrLn :: String -> IO ()
15:10:36 <mniip> that's not a very good example
15:10:49 <hpc> mniip: it's a great example
15:10:50 <mniip> a much better would be something like Bool -> Maybe ()
15:11:17 <mauke> mniip: wrong
15:11:28 <puregreen> here's another example: your function applied to readFile would yield something of type “FilePath -> String”, which would yield different outputs based on whether I edited the file sneakily or not, but it can't possibly do that since it's a pure function
15:11:32 <mniip> you think?
15:11:49 <mauke> yeah, hpc's example was intuitively obvious to me
15:11:51 <mniip> well with IO you have to go into referential transparency and all that
15:11:53 <hpc> @djinn (Bool -> Maybe ()) -> Maybe (Bool -> ())
15:11:53 <mauke> yours wasn't
15:11:53 <lambdabot> f a =
15:11:54 <lambdabot>     case a False of
15:11:54 <lambdabot>     Nothing -> Nothing
15:11:54 <lambdabot>     Just _ -> Just (\ _ -> ())
15:12:06 <hpc> mniip: :P
15:12:23 <ReinH> vikingofrock: no, and this demonstrates the added power that Monad has over Applicative.
15:12:36 <hpc> vikingofrock: anyway your question is a very common one
15:12:44 <monochrom> the only possible concern about the putStrLn example is that the reader has to understand IO enough first
15:12:50 <mniip> well that
15:12:52 <hpc> and often the answer is a big step in understanding the relationships between types
15:12:54 <monochrom> but that is a low requirement
15:13:00 <ReinH> vikingofrock: a -> m b is a computation that can choose its 'm' context based on the 'a' value. Downgrading it to m (a -> b) would lose exactly that property.
15:13:45 <ReinH> e.g., for the Maybe monad, a -> Maybe b can choose Nothing or Just constructors based on the 'a' value. Maybe (a -> b) can't change its context from Nothing to Just or vice versa.
15:14:06 <vikingofrock> that makes a lot of sense
15:14:25 <vikingofrock> thanks everyone
15:14:32 <ReinH> This is exactly what you can do with Monad but can't do with Applicative: choose the context based on the value.
15:25:00 <koz_> OK, I have a question, with explanation with code snippets here: http://paste.rel4tion.org/240
15:25:42 <monochrom> is that transpose?
15:25:52 <koz_> :t transpose
15:25:53 <lambdabot> [[a]] -> [[a]]
15:25:57 <monochrom> > transpose [["1", "2"], ["a", "b"], ["A", "B"]]
15:25:59 <lambdabot>  [["1","a","A"],["2","b","B"]]
15:26:02 <romanandreg> is this the right place to ask about stack build tool?
15:26:03 <koz_> That's perfect - thank you!
15:26:06 <monochrom> apart from String vs TexT
15:26:27 <monochrom> but mind what happens when lengths mismatch
15:26:38 <glguy> romanandreg: sure
15:26:59 <romanandreg> so, I’m having stack + nix, and trying to install dependencies but getting a forbidden error:
15:27:20 <monochrom> incidentally I think sequenceA happens to be transpose when the type is [] [].
15:27:24 <romanandreg> "/run/user/900/stack10881/distributive-0.4.4/.stack-work/dist/x86_64-linux-nix/Cabal-1.22.5.0/setup/setup: streamingProcess: runInteractiveProcess: exec: permission denied (Permission denied)”
15:27:25 <monochrom> @type sequenceA
15:27:26 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
15:27:43 <monochrom> if t=[] and f=[] too, what happens...
15:27:43 <romanandreg> have been trying to google it, but no luck, anyone has seen this before?
15:27:46 <glguy> monochrom: I think sequenceA is slightly differnt
15:27:52 <monochrom> > sequenceA [["1", "2"], ["a", "b"], ["A", "B"]]
15:27:54 <lambdabot>  [["1","a","A"],["1","a","B"],["1","b","A"],["1","b","B"],["2","a","A"],["2",...
15:27:59 <monochrom> ah, indeed
15:28:11 <romanandreg> the error happens with any dependency I try to install via stack
15:29:30 <hypoon> Hi all, is https://wiki.haskell.org/HsLua outdated?
15:30:05 <mniip> ehh
15:30:11 <mniip> using dostring to query globals
15:30:27 <ysz> how can i ask cabal to link Haskell code statically when creating (.so) shared library?
15:30:41 <monochrom> no, I think it cannot
15:30:50 <mgsloan> romanandreg: Is this relevant? https://github.com/commercialhaskell/stack/issues/471
15:30:51 <mniip> hypoon, considering how little the lua api changed in the past 10 years I say that is unlikely
15:31:06 <hypoon> mniip: Also, it says: that we then read using "eval", but there's no use of eval in the code.
15:31:25 <mgsloan> romanandreg: Oooh, I bet it's this https://github.com/commercialhaskell/stack/issues/1640
15:31:28 <romanandreg> mgsloan: not really, haven’t used sudo ever
15:31:29 <mniip> I think they mean dostring
15:31:33 <mniip> which is basically eval
15:31:53 <mgsloan> romanandreg: https://github.com/commercialhaskell/stack/commit/568938da27fde2d472fca0057b5ea82a9e07448b
15:32:01 <monochrom> great invention: eval is evil
15:32:15 <hypoon> mniip: I don't believe dostring is implemented in the most recent versions on hackage.
15:32:33 <mniip> hypoon, you'll want to use getglobal/gettable instead
15:32:33 <romanandreg> mgsloan: interesting 
15:32:42 <mniip> and/or loadstring+pcall/call
15:33:12 <romanandreg> mgsloan: boom, right on target!
15:33:18 * koz_ discovers classy-prelude lacks transpose in any form he can locate.
15:33:23 <romanandreg> good catch, may I inquire how did you google for that/
15:33:23 <romanandreg> ?
15:33:29 * koz_ considers that this is likely due to lack of knowledge of classy-prelude.
15:33:31 <ysz> monochrom, is that at all possible with GHC?
15:33:35 <mniip> @package hslua
15:33:36 <lambdabot> http://hackage.haskell.org/package/hslua
15:33:54 <mgsloan> romanandreg: https://github.com/commercialhaskell/stack/search?q=permission+nix&type=Issues&utf8=%E2%9C%93
15:33:58 <mniip> yeah looks like a straightforward mapping of the C API
15:34:01 <monochrom> no possible today. no one has done it. I think no one will do it in the near future
15:34:13 <ysz> oh dear...
15:34:40 <ysz> that rules out writing self-contained plugins in Haskell 
15:34:42 <mniip> damn
15:34:47 <mniip> that code is slightly horrible
15:34:47 <hypoon> mniip: Why do we have packages for such direct mappings? Is using FFI that difficult?
15:34:51 <mgsloan> romanandreg: Also, I maintain stack / the tracker, so I've pretty much seen every issue.  It sounded familiar
15:35:01 <mniip> whoever wrote that wasn't very experienced with lua :s
15:35:49 <romanandreg> mgsloan: awesome, thank you very much 
15:35:55 <monochrom> naw, FFI is so easy, everyone affords to write and upload thin wrappers :)
15:36:26 <mgsloan> welcome!
15:36:37 <hpc> i have come across my fair share of thin wrappers that technically do what i want but are entirely useless
15:36:40 <glguy> Wrapping Lua isn't that easy from Haskell
15:36:53 <hypoon> mniip: As someone who's not very experienced with Lua either, I'm starting to reconsider using Lua for scripting within my application. The existence of hslua is part of the reason why I chose Lua.
15:37:09 <mniip> what are you trying to achieve
15:37:11 <glguy> You have to carefully thread errors between layers
15:37:29 <koz_> hypoon: Do you need a scripting layer or soemthing?
15:37:31 <mniip> glguy, elaborate?
15:37:33 <hypoon> Are there any embedded scripting languages that are particularly well suited for use with a haskell application?
15:37:47 <glguy> Lua uses either setjmp/longjump or C++ exceptions for error control flow
15:37:52 <mniip> ah yes that
15:37:59 <glguy> It's not OK to longjump out of a C FFI call you made from Haskell
15:38:07 <hpc> there's also runtime system initialization you have to do, you might have to do your own GC stops, etc
15:38:08 <glguy> it leaves the runtime in a bad state
15:38:28 <hpc> see also, calling haskell from C
15:38:32 <hypoon> mniip, koz_: I'm writing a game. I want modders to be able to create new content.
15:38:44 <mniip> I suppose you could compile lua with a haskell-specific implementation of exceptions
15:39:07 <hpc> you could do what the source engine does
15:39:26 <hpc> put the game logic in a dll and provide a bare base for others to write stuff on top of
15:39:43 <koz_> Yeah, that actually seems pretty sensible.
15:39:50 <hpc> they compile their own dll and have your closed executable load it
15:40:10 <koz_> If FFI-longjumps are a problem, pretty much any C-based scripting lang with exceptions is gonna have issues.
15:40:49 <hypoon> hpc: I see, I was hoping for something that expects less technical expertise on the part of the modders.
15:40:52 <mniip> hmm well
15:40:58 <mniip> you can avoid those with lua
15:41:08 <koz_> hypoon: If you scaffold this properly, it shouldn't be *that* hard.
15:41:12 <mniip> at what cost, though...
15:41:19 <mniip> hmm
15:41:20 <hpc> hypoon: providing a decent enough framework it should be fairly easy
15:41:27 <koz_> mniip: At that point, you might as well just reimplement Lua inside of Haskell honestly.
15:41:33 <hpc> hypoon: making them write lua forces a high level of technical expertise anyway
15:41:39 <mniip> you could wrap every call in a pcall...
15:42:01 <mniip> (just so that you don't get hit by an exception in a metamethod or some such)
15:43:02 <EvanR> hypoon: dunno if anyone mentioned but haskell can do plugins
15:43:21 <EvanR> so mods can be written in haskell
15:43:39 <koz_> Yeah - it's basically a nicer form of hpc's suggestion.
15:43:49 <ReinH> hypoon: You can also include a Lua interpreter. A lot of modders use Lua...
15:44:13 <mniip> EvanR, ehhhhhhhhhh
15:44:23 <mniip> dynamically loaded haskell is uhhh
15:44:23 <koz_> ReinH: I believe there are some issues with that, according to some other folks' opinions in here.
15:44:26 <mniip> ughhhhh
15:44:31 <ReinH> koz_: A lua *interpreter*.
15:44:35 <EvanR> smart?
15:44:51 <koz_> ReinH: So you mean, not calling out to Lua, but reimplement Lua inside of Haskell?
15:44:59 <mniip> I was thinking more in direction of "disgusting"
15:45:05 <ReinH> @hackage hslua
15:45:05 <lambdabot> http://hackage.haskell.org/package/hslua
15:45:32 <ReinH> Oh, wait, that's embedded, not an interpreter
15:45:56 <hypoon> My first attempt was to define all the game logic and objects using data types and constructors, all implementing Read and Show. Then I was just going to let new content be read from a file using "read".
15:46:09 <EvanR> heh...
15:46:09 <adas> Just like Alternative is a monoid on applicatives, is it safe to say that MonadPlus is a monoid on Monads?
15:46:14 <ReinH> Read isn't a particularly good format to *write*
15:46:20 <forker> Hi folks, is there a better way to get rid off field prefixes when using Aeson TH than this: $(deriveJSON defaultOptions{fieldLabelModifier = drop 4} ''Book)
15:46:23 <EvanR> hypoon: use a parser to at least make it decent looking
15:46:23 <ReinH> You could consider JSON or YAML or even XML
15:46:26 <Shockk> hypoon: this may not be that useful to you but I wrote an interface using the GHC API to load stuff into one of my haskell projects at runtime
15:46:26 <ReinH> if you want humans to write it
15:46:32 <Shockk> hang on a moment
15:46:32 <koz_> I agree with ReinH - something structured is better by far.
15:46:42 <koz_> I'm a fan of XML personally because of the nice tooling for it, but that's a personal thing.
15:46:49 <koz_> (also, very nice validation so people don't shit in your game logic)
15:47:00 <EvanR> XML.... even less appealing to write than Read format
15:47:09 <ReinH> EvanR: not at all
15:47:15 <Shockk> hypoon: this is the actual plugin loading code I wrote, it's a little obscure to read,
15:47:18 <ReinH> XML is a standard format with extensive tooling support
15:47:28 <koz_> Including some *very* nice schema languages.
15:47:36 <EvanR> youre writing mods in XML??
15:47:36 <ReinH> You might dislike it, but you can't seriously compare it disfavorably to an ad hoc debugging format for a particular language
15:47:40 <hpc> i would rather use json
15:47:43 <Shockk> this is a simple example of something I could load
15:47:44 <Shockk> https://github.com/shockkolate/arata/blob/master/plugins/NickServ/Info.hs
15:47:56 <hypoon> I'm trying to avoid things that aren't portable. If gcc can target a platform, I intend to be able to (hypothetically) run this game on it.
15:47:58 <EvanR> ReinH: who cares about the format, talking about human typable with keyboard
15:48:03 <koz_> hpc: JSON is also workable, but JSON Schema is much less powerful than RELAX NG for example.
15:48:18 <ReinH> EvanR: Uh... humans who type things with a keyboard care about the format.
15:48:30 <EvanR> if youre using XML as a transition format, ok, but you have to write the mod in something
15:48:44 <hypoon> I was going to create an editor to ship with the game
15:48:54 <forker> Hi folks, is there a better way to get rid off field prefixes when using Aeson TH than this: $(deriveJSON defaultOptions{fieldLabelModifier = drop 4} ''Book)  ?
15:48:58 <hypoon> So it doesn't have to be entirely easy to write by hand
15:49:06 <ReinH> EvanR: we're talking about XML as opposed to something Read can parse, not XML as opposed to a fully fledged scripting language
15:49:12 <glguy> forker: That looks pretty good
15:49:18 <puregreen> forker: I don't think there is
15:49:25 <koz_> hypoon: I would basically suggest that you don't force editor usage on your modders. I would find it unpleasant to have to use a GUI editor instead of (for instance) Emacs to write mods for a game.
15:49:25 <ReinH> forker: Nope, that's the usual way
15:49:32 <forker> Thanks guys!
15:49:39 <adas> Just like Alternative is a monoid on applicatives, is it safe to say that MonadPlus is a monoid on Monads?
15:49:44 <ReinH> koz_: Well, that depends on what you're ediging. Map files are generally easier to edit with a map editor. ;)
15:49:48 <ReinH> *editing
15:49:51 <hypoon> ReinH: exactly my thoughts
15:50:16 <hypoon> I'm hoping for a user experience similar to Blizzard's editors that shipped with Starcraft and Warcraft III.
15:50:31 <koz_> ReinH: My point still stands. Binary formats aren't something I think belongs in situations where space is not at a mega-premium.
15:50:32 <EvanR> ReinH: define all the game logic in data constructors... seems like a language
15:50:48 <ReinH> koz_: No one writes maps by hand any more. It's not feasible.
15:51:02 <Welkin> yeah! They generate them using a RNG
15:51:02 <ReinH> EvanR: I'm not sure what your point is.
15:51:09 <hypoon> koz_: I agree. I definitely want to avoid binary formats.
15:51:14 <hpc> i write maps by foot
15:51:29 <koz_> ReinH: Well, that clearly shows I need to prove this point wrong now. :P
15:51:29 <EvanR> Read and XML are terrible programming languages
15:51:31 <ReinH> Haskell is a very good language to write DSLs in. It top tier parsing.
15:51:46 <koz_> ReinH: *That* I agree with. I love Parsec.
15:51:48 <ReinH> You could write a scripting language for your game.
15:51:56 <hypoon> DSL?
15:52:01 <ReinH> *It has
15:52:04 <koz_> ReinH: Do you think rolling your own is better than using one that's already established though?
15:52:06 <ReinH> domain specific language
15:52:08 <koz_> hypoon: Domain-Specific Language.
15:52:11 <koz_> Goddamn ninjas...
15:52:12 <hypoon> Ah, gotcha
15:52:14 <EvanR> that was also my point ;)
15:52:17 <ReinH> koz_: It depends.
15:53:08 <ReinH> Game developers generally don't let modders write modules that are linked into the running game for a variety of reasons, including safety.
15:53:27 <ReinH> So letting modders write Haskell that you link in isn't necessarily a good solution
15:53:45 <hypoon> Are domain-specific languages compiled and linked in?
15:53:50 <ReinH> DSLs give you control over what modders are allowed to do.
15:53:51 <koz_> Nope.
15:53:57 <koz_> They're usually parsed at runtime and loaded.
15:54:05 <ReinH> So does exposing an API that some embedded runtime uses, e.g., Lua
15:54:20 <glguy> naudiz: Did you get your stack environment working on Gentoo
15:54:24 <adas> Just like Alternative is a monoid on applicatives, is it safe to say that MonadPlus is a monoid on Monads?
15:54:25 <hypoon> ReinH: Lua's very... "sandboxed"
15:54:41 <ReinH> hypoon: Yes. That's one of the reasons it's so commonly used as a scripting language for modding.
15:54:51 <koz_> Well, and its simplicity and lightness.
15:54:59 <ReinH> That's an attractive property for the game develoeprs. It helps prevent mods from crashing their game or doing even worse things.
15:55:24 <hypoon> ReinH: These are exactly the kinds of features I'm seeking.
15:55:37 <hypoon> koz_: And those too.
15:56:05 <ReinH> If you just link in arbitrary Haskell modules, you have a much bigger attack surface to deal with for malicious mod creators. It's risky.
15:56:24 <koz_> Am I correct in understanding that GADTs, type families and dependent types seek to solve similar problems?
15:56:34 <ReinH> I can write a module that reads your private keys and sends them to my server. How do you stop me?
15:57:22 <hypoon> These modders will be doing two things. They'll be creating new areas for players to explore, and they'll be creating new game logic to accompany those areas (though it may not be confined to those areas). I don't anticipate letting them do much more than that.
15:58:00 <hypoon> (Their new game logic may legitimately "bleed over" into non-modded areas of the game.)
15:58:01 <ReinH> The first is data, and can easily be stored in some data format. The second can be *made* data to some extent with limited success.
15:58:29 <ReinH> But some sort of scripting language is generally used for the latter because, e.g., turing completeness is a nice thing to have when writing AIs.
15:58:44 <koz_> Well, also the fact that it can allow possibilities you never considered before.
15:59:00 <koz_> Generally-speaking, modders will want to do things you never anticipated.
15:59:02 <ReinH> Yep.
15:59:11 <koz_> And giving them a full-blown language is a good way of making this less of a pain.
15:59:14 <hypoon> ReinH, koz_: bingo. Turing completeness is something I'm seeking as well.
15:59:14 <koz_> (for you and them)
15:59:18 <ReinH> So giving your modders a scripting language enables emergent design.
15:59:55 <ReinH> So one approach might be to see how far you can get with embedding Lua via hslua.
15:59:57 <hypoon> Hell, forget the modders. *I* like the idea of being able to add features without recompiling everything.
16:00:17 <ReinH> Yeah, lots of games that don't have mod support still use Lua for exactly that reason.
16:00:34 <koz_> ReinH: Well, because their engine code is in C++ that requires 90001 hours to compile.
16:00:39 <hypoon> ReinH: That's what I was thinking before, but hslua isn't as refined as I was hoping.
16:00:40 <ReinH> The framework is statically compiled and offers enough functionality to the scripting layer so that they can generally update things dynamically to change behavior
16:01:13 <koz_> hypoon: What's it missing?
16:01:24 <ReinH> hypoon: You should let your users write their mods in brainfuck. It's very easy to write a brainfuck interpreter.
16:01:41 <koz_> ReinH: You have an interesting sense of humour.
16:01:43 <ReinH> And if they want, they can cross-compile from lots of languages into brainfuck so there's really no downside.
16:01:44 <hypoon> koz_: It doesn't appear to be much more than just FFI wrappers.
16:01:51 <ReinH> None whatsoever.
16:02:41 <ReinH> koz_: (brainfuck is actually a fascinating language for real though)
16:02:42 <koz_> hypoon: Is its embedded option still FFI-based? I thought it'd only be FFI-ing if it calls out to the OS's Lua?
16:02:55 <koz_> ReinH: I never saw the point, honestly. I'll take your word for it.
16:03:15 <hypoon> koz_: I don't know, but regardless... when I was reading about how useful embedding Lua can be, I wasn't imagining having to manage the stack myself.
16:03:40 <koz_> hypoon: Well, yeah, because Lua was intended to be used as a scripting layer for *C* rather than Haskell.
16:04:24 <hypoon> koz_: Perhaps, which is why I came here looking for better options :-)
16:04:36 <ReinH> koz_: It's basically a weirdly spelled minimalistic assembly langauge. It can be "compiled" without generating any sort of immediate representation, just by translating the characters into C or even machine code directly. You can do lots of interesting optimizations basically as parallel rewrite rules on the source string, so you can write an optimizing compiler as an L-System.
16:04:55 <koz_> ReinH: Oh, OK. I wonder why nobody ever mentioned *that*.
16:05:02 <ReinH> With rules like "[]" -> ""
16:05:08 <koz_> I just assumed Brainfuck was some particularly-popular esoteric lang.
16:05:24 <ReinH> It's a very simple model of with a weird spelling and an unfortunate name.
16:05:35 <ReinH> It's very interesting from a CS perspective though.
16:05:40 <ReinH> *model of computation
16:05:43 <koz_> hypoon: Well, in all honesty, I think it means you probably want some kind of hardwired interpreter in Haskell.
16:05:53 <hypoon> koz_: I was thinking of that language I read about once, where whitespace is the only stuff that mattered, and everything that's not whitespace was a comment.
16:05:55 <koz_> It doesn't have to be Lua - anything nicely-orthogonal and simple should do.
16:06:00 <koz_> hypoon: It's called Whitespace.
16:06:51 <hypoon> koz_: High probability that you're right, lol.
16:07:15 <hypoon> koz_: With a name like that, I can't imagine that what I read /wasn't/ what you're referring to.
16:07:16 <ReinH> koz_: Because "compilation" and optimization can both be written purely in terms of string transformations, you can write an optimizing compiler in sed that is actually super easy to understand. It translates brainfuck characters directly into machine code, performing a few optimization steps via string transformations along the way.
16:07:41 <koz_> ReinH: That is indeed *very* interesting.
16:07:51 <koz_> I wish more people mentioned that *upfront* about Brainfuck.
16:07:53 <ReinH> koz_: https://github.com/stedolan/bf.sed
16:08:17 <koz_> hypoon: Well, I'd think about what you want your scripting lang to look like. Do you want something Haskell-like? Lisp-like? C-like? Something else?
16:08:19 <ReinH> koz_: also look at its only issue https://github.com/stedolan/bf.sed/issues/1
16:08:40 <hypoon> One of the other features I had in mind was the ability to tap into the scripting language from in-game. I don't think brainfuck will be well suited for that.
16:08:56 <koz_> ReinH wasn't suggesting raw Brainfuck.
16:09:04 <ReinH> I mean, not seriously.
16:09:09 <koz_> He/she/it was suggesting something -> Brainfuck.
16:09:13 <hypoon> (I don't intend it to be accessed during normal gameplay, but it'd be very useful for debugging)
16:09:17 <ReinH> I wasn't seriously suggesting that either.
16:09:23 <ReinH> but it would be hilarious and pretty cool
16:09:32 <koz_> ReinH: I couldn't quite tell whether you were being serious or not, to be honest. :P
16:09:35 <ReinH> and not actually as untenable as it might immediately appear
16:09:43 <koz_> Oh, I have no doubts about its tenability.
16:09:50 <koz_> In fact, that'd actually allow you to have scripting front-ends.
16:10:03 <koz_> Basically, you'd need to write a translator plug-in which targets Brainfuck.
16:10:07 <koz_> Which would then be interpreted.
16:10:15 <koz_> (and/or optimized, depending on how you look at it)
16:10:40 <ReinH> koz_: srsly look at the issue though.
16:10:42 <koz_> So people could potentially write mods in anything which can be compiled to Brainfuck, which is kinda cool.
16:10:46 <koz_> ReinH: I did look at the issue.
16:11:16 <hypoon> Brainfuck might work for that purpose, but it sounds like biting off more than I can chew right now.
16:11:27 <ReinH> koz_: They added it to a milestone
16:11:37 <ReinH> So they are clearly taking it seriously.
16:11:45 <koz_> Afterhell freezes over apparently. :P
16:12:47 <ReinH> I know, I love it
16:12:53 <koz_> But ReinH actually gave me a very interesting idea.
16:13:17 <koz_> (since I'm likely gonna be making a Haskell game of my own soon)
16:13:21 <hypoon> How difficult is it for a DSL to be made turing complete?
16:13:25 <koz_> (once I figure out precisely what I want it to be like)
16:13:43 <koz_> hypoon: Very easy. Turing completeness isn't a hard thing to manage. Hell, a two-counter automaton is as powerful as a Turing machine!
16:14:24 <ReinH> koz_: The actual problem with that request, btw, is that you can't count in sed.
16:14:57 <koz_> ReinH: Thanks - I don't know sed, so yeah.
16:15:07 <ReinH> hypoon: Well, I can write a brainfuck interpreter in 10 lines of code and brainfuck is turing complete.
16:15:33 <koz_> ReinH: Is that 10 lines of Haskell, or 10 lines of something else?
16:15:45 <koz_> You can say a lot more in 10 lines of Haskell than 10 lines of (for example) C++.
16:15:50 <ReinH> It's pretty easy to achieve TC. You just need loops or recursion, basically. And "being turing complete" isn't actually super interesting. I was mostly using it as a short hand for "has loops or recursion".
16:16:30 <koz_> ReinH: Not just loops - loops terminated by arbitrary conditions. If your loops are limited to a compile-time known number of repetitions, then you won't have TC.
16:16:39 <ReinH> koz_: Yes. 10 lines of pretty much anything. If you're trying super hard, often less than 500 bytes.
16:16:51 <ReinH> koz_: http://codegolf.stackexchange.com/questions/84/interpret-brainfuck
16:17:26 * koz_ is impressed.
16:17:27 <ReinH> koz_: Yes, good point re conditions.
16:17:53 <koz_> I usually think of it as having the ability to unconditionally jump.
16:18:00 <koz_> If you have that, you basically have TC.
16:18:00 <ReinH> It's actually much harder to achieve non-TC while still allowing you to write interesting programs.
16:18:04 <ReinH> Yep.
16:18:06 <koz_> Yup!
16:18:09 <geekosaur> hm. sed has both b and s///t 
16:18:21 <romanandreg> is there an easy way to call HashMap.toList over lens? is there any backed in operator that I can use instead of `to HashMap.toList`
16:18:22 <romanandreg> ?
16:18:24 <koz_> geekosaur: What do those do for the unenlightened?
16:18:47 <romanandreg> assuming meh is of type Aeson.Value
16:18:48 <romanandreg> (meh ^? _Right . key "components" . _Object . to HashMap.toList)
16:18:49 <geekosaur> b is unconditional branch, t modifier branches to a label on successful match
16:19:01 <romanandreg> I want to do that without using HashMap.toList
16:19:04 <romanandreg> is that possible?
16:19:04 <koz_> So why can't you count in sed then?
16:19:18 <ReinH> romanandreg: Aeson? Generally you don't need to work with the underlying implementation (HashMaps)
16:19:18 <geekosaur> with the hold space and a unary representation I would expect to be able to count
16:19:27 <ReinH> So I wonder if you're doing something at too low of a level
16:19:31 <xcv_> romandreg: try with (meh ^.. _Right . key "components" . _Object . traverse)
16:19:36 <ReinH> and I suspect that this is an XY problem.
16:19:41 <romanandreg> ReinH: I want to transform JSON Objects in a way
16:19:49 <puregreen> xcv_: this will lose keys
16:19:52 <ReinH> What sort of way?
16:19:55 <xcv_> itraverse?
16:20:06 <hypoon> Idk. I'm not sold on BF... I don't imagine it making my life easier until quite far down the road.
16:20:15 <romanandreg> I want to traverse keys on an Object, looking for particular keys
16:20:17 <romanandreg> say an object has
16:20:35 <romanandreg> {“key1”: “{{Properties.hello-world}}”}
16:20:41 <romanandreg> and latter I have another json
16:20:46 <geekosaur> so I'm pretty sure sed is turing complete. just most people don't know all of what sed can do
16:20:47 <ReinH> geekosaur: Well, sed is turing complete. It isn't impossible to do, it's just much harder than any of the other optimization steps currently implemented.
16:20:52 <glguy> xcv_:   itoListOf (_Right . key "components" . members)
16:20:55 <romanandreg> { “Properties”: {“hello-world”: 123}}
16:21:00 <romanandreg> I want to get the two JSON
16:21:01 <hypoon> Can someone point me toward a resource for implementing a DSL?
16:21:03 <romanandreg> and get as an output
16:21:08 <glguy> oh, not your question
16:21:08 <ReinH> And the main reason that it's much harder is that sed can't count. :)
16:21:09 <romanandreg> {“key1”: 123}
16:21:14 <glguy> romanandreg: ^ my previous line
16:21:51 <geekosaur> sure it can. it's just as painful as anything else in sed
16:21:52 <ReinH> romanandreg: where does 'key1' come from?
16:21:55 <koz_> ReinH: What do you mean exactly by 'sed can't count'?
16:21:59 <geekosaur> unary representation, hold space
16:22:05 <ReinH> geekosaur: Ok, of course it can count, I mean that it doesn't have built-in functionality for it.
16:22:06 <romanandreg> it is an input parameter
16:22:23 <romanandreg> so there is two json objects, one that has some sort of template with convertable arguments
16:22:26 <ReinH> If it did, it would be much easier to match matching parens.
16:22:29 <romanandreg> and one that has the arguments as keys
16:22:29 <ReinH> or matching w/e
16:22:55 <geekosaur> you have one variable, you can regex on it. I've even abused this once or twice. it's painful, but I'm not sure it's worse than any other Turing tarpit
16:23:25 <ReinH> geekosaur: Yep. What I said was "it's possible but much more difficult than the other things they're already doing." :)
16:23:33 <romanandreg> glguy: that is exactly what I want it
16:23:34 <romanandreg> thanks
16:23:45 <ReinH> I kind of want to implement it now though
16:23:56 <ReinH> I haven't used sed in anger in what a decade? I guess I'll have to relearn it.
16:24:03 <ReinH> I mean, besides trivial stuff.
16:24:11 <xcv_> is anyone using ghc-mod successfully?
16:24:17 <koz_> ReinH: I guess I'm just a noob, because I've never used sed for anything.
16:24:19 <ReinH> xcv_: I bet a lot of people are.
16:24:27 <koz_> But then again, I work almost entirely in Haskell when I'm not in C these days.
16:24:32 <ReinH> I am using it more or less successfuly
16:24:39 <xcv_> ReinH: I'm getting "unable to load package `text-1.2.2.0`"
16:24:41 <koz_> (mostly because I find most dynalangs to be intolerable)
16:25:03 <ReinH> xcv_: can you pastebin the full error?
16:25:11 <xcv_> that's the full error, nothing else 
16:25:26 <ReinH> I think "unable to load package" might be secret code for "you are using the wrong version of ghc-mod, or one compiled with the wrong version of GHC" or something like that
16:25:29 <xcv_> ReinH: the command was ghc-mod check src/Main.hs, for any project
16:25:36 <ReinH> error reporting in ghc-mod is not great
16:25:45 <xcv_> the thing is, I just compiled it right now
16:26:06 <ReinH> Are you using cabal? Stack? How are you running it? Via editor support??
16:26:16 <ReinH> The more info you can give, the better.
16:26:23 <xcv_> I'm using stack
16:26:35 <xcv_> just upgraded to LTS-5.1 and wanted to try out ghc-mod again
16:26:38 <ReinH> mgsloan: Maybe you can help with this
16:26:51 <ReinH> xcv_: and you rebuilt ghc-mod with lts-5.1?
16:26:57 <xcv_> exactly
16:27:06 <romanandreg> glguy: if I want to traverse over all the keys of an Aeson.Value (include keys on inner objects), is there a way to do it in one go?
16:27:13 <ReinH> And you're sure it's finding the correct ghc-mod.
16:27:46 <romanandreg> something like, give me all the leafs that are String inside an Aeson.Object?
16:27:51 <xcv_> ReinH: yes, I even ran the one in the ~/.stack/(...)/lts-5.1/(...)/bin directory explicitly
16:28:01 <glguy> romanandreg: try:  deep _String
16:28:37 <glguy> That'd give you all the string values though, not the keys
16:31:19 <adas> is there a library for map datastructures that allow me to use String as keys?
16:31:55 <romanandreg> glguy: yes, that is what I want
16:31:58 <glguy> Prelude Data.Aeson.Lens Control.Lens> toListOf (_Value . cosmos . members . asIndex) " { \"one\" : { \"two\" : 10 } } "
16:31:59 <glguy> ["one","two"]
16:32:03 <glguy> for the keys
16:32:06 <romanandreg> wow
16:32:13 <romanandreg> glguy: seriously Lens is soo powerful
16:32:27 <romanandreg> just thinking all that came from an API that is not concerned at all about Aeson is like
16:32:29 <glguy> but toListOf (deep _String) would get you the string values (non-keys) 
16:32:31 <romanandreg> :mindblown:
16:32:50 <romanandreg> If I want to perform filtering on the list
16:33:25 <glguy> you'd put filtered in there somewhere depending on what you're filtering on
16:34:38 <ReinH> romanandreg: (Yeah, generally speaking if you are working with HashMaps, you aren't working with aeson at the right level of abstraction.)
16:34:58 <ReinH> That said, they do break that encapsulation by not exporting helps for creating hashmap singletons and such)
16:35:03 <ReinH> *helpers
16:35:07 <romanandreg> ReinH: yeah, that is way I’m using Aeson-lens, I’m not trying to model Javascript to actual domain logic
16:35:12 <romanandreg> but to do transformations to it
16:35:16 <romanandreg> jq style
17:01:12 <dalastboss> when I try to run stack ghci on my project it cannot find certain modules.. any advice on how to troubleshoot this?
17:03:52 <erisco> is dependent Haskell being taken seriously? I see in GHC 8 there is mention of dependent Haskell milestones
17:04:38 <mgsloan> dalastboss: Is there an error message earlier than the error about not finding certain modules?  That will happen for any error while loading the modules 
17:05:14 <mgsloan> (what happens is that it does a ":load" followed by a ":m +" to import.  So it'll error about not finding modules if they don't load
17:10:15 <mniip> erisco, there's dependent kinds
17:10:28 <mniip> I don't think there will ever be dependent types
17:11:50 <hodapp> dunno
17:12:29 <KaneTW> erisco: goldfire is working on dependent haskell
17:12:46 <KaneTW> it's probably going to be another year until full dependent types
17:12:56 <KaneTW> dunno how his schedule is, just guessing
17:12:56 <hodapp> goldfire?
17:13:01 <KaneTW> richard eisenberg
17:13:12 <hodapp> ohhh!
17:13:19 <hodapp> never realized that was his nick
17:13:24 <hodapp> I've read some of Eisenbergs papers
17:13:56 <puregreen> also known as goldfirere
17:14:22 <hodapp> Quit confusing me, dependent types in Haskell are confusing enough :P
17:15:51 <anks> Hi, I've just check my haskell program with +RTS -s option and it shows that more than 50% were spent GCing, what should be my next move to optimize this and the execution time? How can i further profile stack project with dependencies?
17:17:06 <peddie> anks: get a heap profile and/or a time+alloc profile: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
17:17:49 <peddie> anks: with a profile it should be easier to understand what part of the program is generating all the garbage
17:17:59 <monochrom> this April 1, github will implement "dependent account name"
17:18:29 <anks> peddie: ok, will i need to recompile all my dependencies for profiling
17:18:31 <anks> ?
17:19:34 <mgsloan> anks: yeah, "stack build --profile" will build everything with profiling
17:20:20 <mgsloan> (except ghc I think.  Also not 100% sure if base and other wired-in packages are installed with profiling)
17:21:28 <anks> mgsloan: ok thx, gonna try it
17:21:34 <xcv_> has anyone else met this ghc-mod error or similar? "unable to load package `text-1.2.2.0`"
17:22:41 <mgsloan> --profile implies "-auto-all -caf-all" ghc options, and "--enable-library-profiling" for cabal.  It also automatically passes "+RTS -xc" in to benchmarks / tests
17:23:54 <simony> xcv_: I ran into a similar issue when my installed ghc-mod wasn't built by whatever ghc I was running (though with aeson, not text)
17:25:28 <dramforever> xcv
17:25:32 <xcv_> simony: I believe everything is running has been compiled with the same ghc version (I just have one installed and I'm using slack)
17:25:34 <xcv_> stack*
17:25:49 <dramforever> xcv_: Did you do stack build?
17:26:15 <xcv_> dramforever: yes, the project is fully compiled, I even tried generating haddocks
17:26:25 <anks> mgsloan: (Could not find module ‘Data.Text’
17:26:25 <anks>         Perhaps you haven't installed the profiling libraries for package ‘text-1.2.1.3
17:26:39 <anks> this is the error im getting when building with this options
17:27:07 <simony> xcv_: I was using stack as well, and I think when trying out haskell-vim-now, and I believe it forced a build of ghc-mod using 7.10.3 (or something did at some point), while my projects were using 7.10.2, so things were not happy
17:28:15 <mgsloan> anks: Weird! Did you use "stack setup" to install ghc, or using a system install?
17:28:50 <simony> again, YMMV, but it's maybe worth a shot? (do check `ghc-mod --version` to see if things are as expected)
17:29:03 <anks> mgsloan: i don't remember ^^
17:29:24 <cads> hey all
17:29:28 <cads> how are you guys this evening
17:29:54 <xcv_> simony: I think everything is okay, "ghc-mod version 5.5.0.0 compiled by GHC 7.10.3", and I also did a stack clean of my project before rebuilding
17:30:04 <anks> mgsloan: 'stack will use the ghc on your PATH
17:30:10 <xcv_> simony: I have no idea about what might be wrong at this point
17:30:16 <anks> probably system install
17:30:26 * cads is starting to <3 stack
17:30:52 <cads> the LTS has this feeling that it can't just randomly break, lol
17:31:55 <Samo_svoj> advantage of haskell over java?
17:32:26 <mgsloan> anks: "stack exec -- which ghc" will tell you where the binary is.  If it's not in ~/.stack, then it's using your system level install
17:32:32 <simony> xcv_: yeah, sorry, dunno then. I just had a similar issue, and couldn't figure out what was wrong for a few weeks until I realized the ghc versions didn't line up. Could be it's sensitive to the ghc it's built with (stack vs cabal vs ???), but i'm really just stabbing in the dark now
17:32:53 <anks> it is using system's ghc
17:33:05 <mgsloan> Using your system install should be fine, but it's a bit less controlled and things can be screwed up by prior mutations of your global package DB
17:33:07 <hodapp> Samo_svoj: well, Java is horribly verbose and has comparatively very limited abilities for expressing abstraction
17:34:00 <mgsloan> anks: Might be worthwhile trying again after "stack setup --no-system-ghc"
17:34:41 <anks> you think? ok, im gonna try it then
17:35:48 <xcv_> simony: it's really weird... I guess I'll just keep using a split window with a prompt then :P
17:36:01 <mgsloan> Could be.  If you care about harddrive space, you can delete it out of ~/.stack/programs later
17:36:52 <hypoon> Hi guys, I'm having some trouble finding an introductory resource to implementing a scriptable domain specific language as discussed earlier.
17:36:53 <mgsloan> xcv_: simony: Yeah, ghc-mod could *really* use better error handling in the case that there's a ghc version mismatch...
17:37:18 <mgsloan> And I think most of the editor integrations run the ghc-mod on the path, so it's hard to use different compiler versions for different projects
17:37:46 * mgsloan is gonna try to fix this stuff at some point hopefully soon
17:38:24 <simony> mgsloan: that'd be greatly appreciated :)
17:38:36 <xcv_> indeed ^
17:39:34 <xcv_> mgsloan: well, I try to have a single ghc version installed (the system ghc) so that I can avoid these problems
17:39:40 <xcv_> except this one
17:42:30 <mgsloan> Right, but that sucks!  That leads to situations where if you want to work on a project from 2 years ago, you've gotta spend a bunch of time getting it building again
17:44:57 <xcv_> mgsloan: I haven't met that situation yet, probably because I haven't worked on any "serious" haskell project
17:47:29 <ThatTreeOverTher> is lazy IO a good thing?
17:48:23 <Hijiri> It's ok for some small programs
17:48:37 <erisco> lazy IO is fine if you don't care when IO happens
17:48:57 <erisco> and you don't care if seemingly pure computations explode with failure
17:49:05 <cads> Hey guys, short of setting control groups in the cpu scheduler, is there any way to ensure that all the child processes of a haskell stack build are exceedingly nice?
17:49:50 <erisco> (it is not a good thing, maybe try pipes)
17:49:53 <cads> I've been building in a VM and throttling the VM so my laptop doesn't catch on fine or become an unresponsive brick while building
17:49:54 <ThatTreeOverTher> cads, http://unix.stackexchange.com/questions/112235/how-to-renice-a-group-of-processes ?
17:50:37 <ThatTreeOverTher> also are you setting your job count high? that could be the issue
18:19:41 <cads> where can I learn about setting jobcount?
18:20:25 <cads> ThatTreeOverTher, thanks, that link is helping - I'm going to try running nice stack :)
18:21:08 <cads> wow, it's working, that's it an amazingly nice ghc process
18:22:38 <adas> is there a way to use a type at the value level as well?
18:22:51 <ThatTreeOverTher> I usually set my -j to 64 with cabal, dunno what stack does but it's probably similar. Setting it lower causes less concurrent threads to compile your objects
18:23:57 <cads> lol
18:24:05 <cads> 'nice stack install cabal'
18:24:21 <cads> err
18:24:27 <cads> *cabal-install
18:31:20 <codehero> is it possible to restrict a data type's Integer to a range or a String to some regex, etc?
18:31:43 <hodapp> hmm, within the type, not really
18:31:59 <ThatTreeOverTher> http://stackoverflow.com/questions/8510570/restricting-values-in-type-constructors
18:32:10 <ThatTreeOverTher> does that help?
18:32:20 <hodapp> you could make a type with constructors that only permits- yeah, that
18:34:22 <codehero> not exactly what i meant, but it's still fairly cool
18:35:01 <codehero> i guess you need dependent types to do that stuff on the type level?
18:35:33 <ThatTreeOverTher> I don't think you can do Ada-style type contraining in Haskell, but I'm not 100% sure
18:36:07 <ThatTreeOverTher> well, I guess the two look pretty similar in retrospect, never mind
18:39:24 <ReinH> codehero: Yes, the usual approach involves smart constructors
18:39:53 <codehero> okay ^^
18:40:21 <ReinH> Essentially you have an algebraic type that underspecifies your value space (i.e., allows more well-typed values than you want), so you instead treat it as an abstract type and only expose an interface for working with it that ensures that your invariants are maintained
18:41:00 <ReinH> You have to do the extra work to manage those invariants yourself.
18:41:01 <homework> Hi, I am completely lost on one requirement of my homework. it's not a matter of "how do you do this in Haskell" but more I am just lost in a more general level like what would functional programming code for this look like
18:41:06 <ReinH> This is a limitation of Haskell's type system, yes.
18:41:19 <ReinH> homework: What's the problem?
18:42:53 <codehero> well. to be honest. now that i think about it. i'm not sure how i would handle types constrained by the type system in case of false user input
18:43:12 <codehero> i'd still have to check, or i'd risk a runtime error
18:43:18 <lpaste> homework pasted “requirement” at http://lpaste.net/151768
18:43:33 <homework> http://lpaste.net/151768
18:45:08 <codehero> which specific requirement?
18:45:36 <ReinH> homework: I can't find the question in that.
18:46:48 <homework> the question is at the top
18:48:05 <homework> lines 1-5
18:48:36 <ReinH> homework: I read that. There isn't a single question there. Can you be specific about what you are asking?
18:48:36 <codehero> i see
18:48:49 <ReinH> In fact, there isn't a single question in the entire paste.
18:48:53 <codehero> ^
18:49:27 <codehero> "some applicable code:" what's that?
18:50:00 <lpaste> homework pasted “requirement part 2” at http://lpaste.net/151769
18:50:04 <ThatTreeOverTher> it looks like the harness for the assignment, providing testing code
18:50:13 <codehero> oh. lol. i'm dumb
18:50:22 <codehero> i thought it was something because the some was highlighted
18:50:23 <ReinH> Ok. What is the question?
18:50:34 <homework> does http://lpaste.net/151769 help
18:50:38 <ReinH> I read that.
18:50:47 <ReinH> I am looking for a problem statement.
18:50:56 <ReinH> Of the form "I am trying to do X" or "How do I do X?"
18:51:04 <homework> How do I accomplish this functionality
18:51:08 <ReinH> Accomplish WHAT?
18:51:22 <ThatTreeOverTher> Can you express it in the form of a question?
18:51:26 <monochrom> the whole assignment, I think
18:51:31 <codehero> lol
18:51:33 <ReinH> monochrom: Which is what?
18:51:45 <monochrom> I don't know.
18:51:47 <ReinH> There isn't a problem statement anywhere that I can find.
18:52:00 <ReinH> There's a lot of supplemental information, but no actual statement of the goal.
18:52:16 <monochrom> I don't bother to read, on the slight pretext that it has a 42-inch-long line
18:52:25 <ReinH> So I just want to know: what, specifically and explicitly, are you trying to accomplish?
18:52:47 <ReinH> monochrom: I have a 5k monitor and small fonts and it was still too long a line to read.
18:52:48 <monochrom> I don't have a 42-inch screen.
18:53:02 <ReinH> Same problem with the second paste.
18:53:15 <ReinH> Clicking "edit" helps slightly, as then it's wrapped by the text field.
18:53:28 <ReinH> But still, I don't know what the actual problem is.
18:53:32 <monochrom> I am not even paid to click "edit" or "raw"
18:53:40 <ReinH> Only that it involves a chess derivative and some code.
18:53:41 <Reshi> It's the whole assignment I guess
18:53:54 <codehero> then i think i should outsource my java assignments to irc
18:53:58 <lpaste> homework revised “requirement part 2”: “No title” at http://lpaste.net/151769
18:54:00 <ReinH> Reshi: which is what/
18:54:02 <ReinH> ?
18:54:40 <ReinH> homework: What is the thing you are trying to do?
18:54:44 <ReinH> Tell us in your own words.
18:55:09 <lpaste> homework revised “requirement”: “No title” at http://lpaste.net/151768
18:55:41 * ReinH sighs
18:55:49 <ReinH> I'm not going to keep reading through that haystack looking for a needle
18:55:52 <ReinH> Just tell us.
18:56:32 <homework> specifically and explicitly I am trying to accomplish given a set of strategies a round is computed and given the moves an output is decided for the move
18:56:45 <ReinH> ...
18:56:51 <ReinH> Those are some words. They do not form a sentence.
18:56:53 <ThatTreeOverTher> those aren't your own words, haha
18:57:08 <ReinH> If you want help, literally the least you could do is explain what you want help with.
18:57:51 <ReinH> Well, clearly you can and are doing less. But if any of us are going to help you, you need to do that.
18:57:58 <ReinH> *can do
18:58:00 <homework> I don't know where the lack of understanding is, the 2 files state when I want help with and 
18:58:13 <ReinH> Ok, it's simple.
18:58:15 <ReinH> Explain what you want.
18:58:16 <Reshi> Professor wants the gamePlay function, are you asking for the whole gamePlay function?
18:58:35 <ReinH> At this point, I've already wasted enough time trying to get you to pose a question.
18:58:47 <ReinH> So I'm not really inclined to waste any more.
18:59:07 <ThatTreeOverTher> homework, have you tried asking your professor or classmates for help?
18:59:17 <homework> I did ask a question, how do you do this
18:59:18 <ThatTreeOverTher> (or any other university resource)
18:59:33 <homework> there are no other university resources for this
18:59:38 <ReinH> homework: You have never asked a question about what you want to accomplish. Not once.
19:00:00 <ReinH> As far as I can tell, you have never asked a single question, period.
19:00:10 <codehero> well he did ask "How do I accomplish this functionality"...
19:00:14 <codehero> lol
19:00:18 <ReinH> Ok, fair point.
19:00:40 <homework> what would functional programming code for this look like
19:00:41 <Reshi> homework: have you started with writing the gamePlay function?
19:00:42 <ReinH> At this point, I am finding your inability to pose a question far more interesting than the actual question.
19:00:47 <ReinH> homework: You have yet to define "this".
19:01:08 <codehero> this == functionality == ?
19:01:16 <homework> yes
19:01:24 <ThatTreeOverTher> rofl
19:01:25 <homework> the top statements in the 2 files
19:01:34 <ReinH> The top statements in the two files do not describe a goal.
19:01:39 <ReinH> I have read them. Repeatedly.
19:01:55 <ReinH> At this point, I have to assume that you are not in good faith trying to get help.
19:01:57 <monochrom> this is why most people hated programming. programming languages banned pronouns such as "this".
19:02:10 <ReinH> I have been pretty patient so far, but I am running out of patience.
19:02:15 <monochrom> and this is why most people like OOP. because it restores "this".
19:02:21 <codehero> lol
19:02:42 <Big_G> > liftM2 (+) (Just 3) (Just 9)
19:02:43 <lambdabot>  Just 12
19:03:06 <codehero> well you can do "this = undefined" and it'll work with everything!
19:03:11 <homework> I am in good faith trying to get help, I am stuggling to understand what you don't get? I thought I was clear what I am trying to accomplish
19:03:11 <Big_G> > liftM2 (+) (Just 3) Nothing
19:03:12 <lambdabot>  Nothing
19:03:24 <ReinH> homework: If it's so easy to understand then it should be easy to explain
19:03:33 <ReinH> So please humor me and explain it again, in here, in your own words.
19:03:56 <ReinH> And by "in your own words", I am explicitly trying to prevent you from copying and pasting some words together.
19:04:02 <ReinH> Just so that's clear.
19:04:23 <mniip> anyone got a GHC 7.8 at hand?
19:04:29 <ReinH> mniip: I can, sure.
19:04:34 <ReinH> Stack is nice for that.
19:04:37 * hackagebot Plot-ho-matic 0.9.0.1 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.1 (GregHorn)
19:04:51 <mniip> I have to quicktest a couple things
19:07:02 <homework> given 2 strategies (which are functions) compute the resulting moves in one round and the move type from the move data type. and compute the subsequent half round if necessary that follows if a pawn is moved to its far side
19:07:14 <homework> and those are my own words
19:07:50 <ReinH> That's great, thanks.
19:08:01 <mniip> ReinH, so uh
19:08:12 <ReinH> homework: You gave a lot of background information but you didn't actually explain what you were trying to *do*. This is very helpful.
19:08:28 <ReinH> homework: Give me a moment to re-read the things in light of this new information.
19:09:04 <homework> I am trying to write a function or set of functions
19:10:22 <ReinH> So we have:
19:10:24 <ReinH> gamePlay :: GameState -> Chooser -> Chooser -> IO GameState
19:10:35 <ReinH> type Chooser = GameState -> PlayType -> Player -> IO (Maybe [(Int,Int)])
19:11:00 <homework> yes
19:11:28 <ReinH> The Chooser functions are essentially callbacks that decide the move to make for each player.
19:11:52 <ReinH> callbacks, continuations, w/e. Functions that dewcide the move to make for each player.
19:12:19 <homework> and then out put the move, where they moved to and from
19:12:36 <homework> one momment and I can submit a chooser I have done
19:13:01 <ReinH> So this is a simultaneous game? Black and White make their moves at the same time? Or are you expected to feed the results of one into the other?
19:13:19 <lpaste> homework pasted “a strat” at http://lpaste.net/151774
19:13:22 <ReinH> I wouldn't imagine a chess derivative would be a simultaneous game, and there doesn't seem to be any notion of reconciling two simultaneous moves, so I'm going to go with the latter.
19:14:57 <mniip> ReinH, can I ask you to test a couple things
19:14:59 <homework> in other instructions it says it is a simultaneous game, for Clashes. If two pieced both move to the same square in a round, a knight captures a pawn. Same-type pieces are both removed from the board.
19:15:30 <ReinH> mniip: Sure.
19:15:35 <homework> Black and White move at the same time
19:15:43 <ReinH> mniip: I mean, you can ask whatever you want. I will do my best...
19:15:52 <ReinH> Ah, I see.
19:16:20 <homework> in real life they would move their pieces and then use the clashes rule I have quoted
19:16:25 <mniip> ReinH, it's a thing in the interactive interpreter. if you do 'data A = A' and then 'data A = B' and then ':t A' what does it say
19:17:09 <homework> isn't ghci an interactive interpeter?
19:18:22 <monochrom> it says Ghci1.A
19:18:31 <monochrom> this is 7.8.3
19:18:38 <mniip> hmm so the 7.10+ behavior
19:18:39 <homework> Prelude> data A = A Prelude> data A = B Prelude> :t A A :: Ghci1.A
19:18:49 <mniip> now
19:18:56 <mniip> data A = A; :t Ghci1.A
19:19:08 <mniip> (in same session)
19:19:11 <monochrom> I think it means the first A-type is shadowed
19:20:28 <ReinH> homework: Ok, I see.
19:20:55 <ReinH> homework: What have you tried so far?
19:21:02 <monochrom> I think the intention is to tell you a type name you can no longer use, and rightfully so since you yourself shadowed it
19:21:24 <homework> one moment and I will lpaste it
19:21:45 <mniip> monochrom, what's :t Ghci1.A say once the con is shadowed?
19:22:03 <mniip> (I'm actually assembling a bug report)
19:22:04 <monochrom> the con is not shadowed. the type is.
19:22:08 <lpaste> homework pasted “attempt 1” at http://lpaste.net/151775
19:22:09 <mniip> 1454728703 [06:18:23] <mniip> data A = A; :t Ghci1.A
19:22:30 <monochrom> in a new session? not in a new session?
19:22:38 <mniip> same session
19:23:24 <monochrom> Ghci1.A :: Ghci1.A.  this is still 7.8.3
19:23:40 <monochrom> not sure of the value of a bug report against 7.8
19:24:12 <mniip> this is against 7.10+8.0
19:24:55 <homework> ReinH http://lpaste.net/151775
19:26:16 <mniip> monochrom, if you open a new session, and do 'data A = A', 'data A = A', ':t Ghci1.A'
19:26:43 <mniip> nothing explosive happens?
19:28:21 <monochrom> you know what, there is a difference between "data A = A \n data A = A \n :type Ghci1.A \n" and "data A = A \n data A = A \n :type Ghci1.A \n :type Ghci1.A \n"
19:28:36 <mniip> the first :t fails and the second one works?
19:28:38 <monochrom> that's right, ":type Ghci1.A" is side-effectual
19:28:40 <monochrom> yeah
19:29:37 <monochrom> but nothing exploded. just "Failed to load interface for Ghci1 \n no package matching 'interface' was found"
19:30:19 <monochrom> this is insanity
19:30:39 <monochrom> I knew it was a bad idea to support arbitrary declarations in a REPL
19:31:50 <mniip> monochrom, should I cc you to the bug report?
19:32:02 <monochrom> no, thanks
19:32:09 <mniip> ok
19:32:46 <mniip> boom there we go https://ghc.haskell.org/trac/ghc/ticket/11547
19:35:12 <mniip> monochrom, note that this covers regular declarations too
19:35:23 <ReinH> Well, that is a rather surprising behavior, to say the least.
19:36:23 <ReinH> homework: "How do I write this 100 line function" is far too large in scope of a question for me, sorry.
19:36:59 <ReinH>  100 line functions are far too large to begin with.
19:37:04 <mniip> dat nickname though
19:38:16 <ReinH> mniip: accurate, if nothing else.
19:38:18 <homework> ReinH Yeah thats when I realized I need help as if I keep going it will be like 500 and that is way too big a function
19:38:43 <mniip> ReinH, refering to what
19:38:55 <homework> ReinH do you know of a better more compact way of accomplishing what I want?
19:39:18 <mniip> split your game's logic into logical units?
19:40:12 <ReinH> homework: Try to break it down into (much) smaller problems and solve each one of those.
19:40:36 <ReinH> Defeat it in detail.
19:40:44 <ReinH> Divide and conquer.
19:40:48 <ReinH> Other military analogies.
19:41:13 <ReinH> Haskell is very good for this because it's so easy to build larger functions from lots of smaller ones via composition
19:41:35 <horny-sama> f# vs haskell go fight
19:42:05 <mniip> :set -XNoMagicHash
19:42:15 <monochrom> haha
19:42:21 <homework> in Haskell is there a way to do the simultaneous move? or is that just a bunch of if's and checks?
19:42:28 <horny-sama> mniip: what?
19:42:38 <horny-sama> homework: are you asking for hw help?
19:42:39 <geekosaur> *snrk*
19:42:53 <ReinH> homework: One way to look at it: You have two states that you need to combine into a single state.
19:42:56 <homework> I am
19:42:58 <ReinH> Generate each state, then combine them.
19:43:13 <homework> oh, ok that makes sense thank you
19:43:29 <ReinH> The combining logic is entirely separate from the generating logic.
19:44:21 <mniip> a funny haskell joke for once
19:44:24 <mniip> no one understands it :(
19:44:40 <homework> so in general I would grab the results of the strategies, generate the 2 resulting states then combine them and check for clashes
19:44:44 <ReinH> homework: e.g., move gameState p1Strategy p2Strategy = combine (p1Strategy gameState) (p2Strategy gameState)
19:45:21 <ReinH> homework: in this hypothetical example, gameState :: GameState; p1Strategy, p2Strategy :: GameState -> GameState; combine :: GameState -> GameState -> GameState
19:45:32 <ReinH> the strategies make a news gamestate from a previous gamestate, and combine then combines the two.
19:45:41 <ReinH> s/news/new
19:46:00 <monochrom> I understand the joke
19:46:07 <ReinH> monochrom: ?
19:46:23 <homework> oh ok, I think I understand now, thank you ReinH
19:46:27 <mniip> well 1 person understood it ;(
19:46:27 <monochrom> NoMagicHash in response to f#
19:46:31 <ReinH> ahhhhh
19:46:37 <geekosaur> mniip, I got it too
19:46:54 <monochrom> took me 10 seconds though
19:47:18 <ReinH> heh
19:47:25 <jellytux> Hello
19:47:30 <ReinH> > map toUpper <> map toLower $ "Hello World"
19:47:31 <lambdabot>  "HELLO WORLDhello world"
19:47:41 <ReinH> Two strategies for creating a new string state combined.
19:48:03 <jellytux> I get ‘on’ is not in scope
19:48:09 <jellytux> where may I import it from?
19:48:14 * geekosaur just not paying close attention in here atm
19:48:16 <monochrom> probably Data.Function
19:48:18 <ReinH> jellytux: Data.Function
19:48:20 <geekosaur> Jellydog, Data.Function
19:48:25 <geekosaur> whoops
19:48:27 <geekosaur> ttab :/
19:48:41 <ReinH> geekosaur: I am disappoint
19:48:44 <pavonia> mniip: You could explain the joke so that everybody can understand it
19:48:45 <jellytux> what does ((==) `on` isSpace) evaluate to?
19:49:00 <geekosaur> :t on
19:49:00 <homework> ReinH are you on here often? (in case I have a question)?
19:49:00 <mniip> :t GHC.Types.F#
19:49:01 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:49:01 <lambdabot> GHC.Prim.Float# -> Float
19:49:03 <mniip> \o/
19:49:14 <Shockk> ReinH is here all the time
19:49:20 <jellytux> (\a b -> (isSpace a) == (isSpace b)) ?
19:49:37 <geekosaur> yep
19:49:45 <mniip> pavonia, MagicHash is an extension that lets you use the # character in identifiers
19:49:52 <homework> cool, I need to go but ReinH thank you very much
19:50:48 <jellytux> geekosaur: but I don't get it “groupBy ((==) `on` isSpace) "hey guys its me"”. How does this work?
19:51:05 <jellytux> what's ‘a’ and ‘b
19:51:10 <jellytux> in this context?
19:51:14 <mniip> pavonia, by disabling it I bring F# out of the scope
19:51:19 <geekosaur> do you know how groupBy works?
19:51:27 <saulzar> Hm - is there an easy way to get ghci to evaluate a type function? (Rather than just printing out the expression you gave it)
19:51:46 <pavonia> mniip: Oh, I thought "joke" was referring to "The combining logic is entirely separate from the generating logic." :S
19:51:56 <mniip> saulzar, :t undefined :: (r ~ F x) => r
19:51:58 <mniip> works often
19:52:05 <saulzar> Ah, cool. Cheers
19:52:19 <mniip> not alwys though
19:52:49 <geekosaur> b here will be the character of the string that it is currently looking at. a will be the character defining the current group; when it sees a b that does not match a according to the current value of the groupBy expression, it ends the current group and starts another using b as the new a
19:54:38 <geekosaur> so, here it will be creating new groups when it sees a transition between space and not-space (the places where ((==) `on` isSpace) changes value)
19:54:43 <ReinH> > group [1,1,2,2,2,3]
19:54:44 <lambdabot>  [[1,1],[2,2,2],[3]]
19:55:05 <ReinH> group = groupBy (==) = groupBy ((==) `on` id)
19:56:06 <jellytux> well this is weird
19:56:14 <jellytux> because this expression will never be true
19:56:15 <jellytux> (\a b -> (isSpace a) == (isSpace b))
19:56:22 <geekosaur> huh?
19:56:58 <ReinH> > isSpace ' ' == isSpace ' '
19:57:00 <lambdabot>  True
19:57:37 <ReinH> jellytux: I think I understand what you mean.
19:57:40 <mniip> ok legit question
19:57:49 <mniip> how do I make :t expand type synonyms
19:57:55 <ReinH> Groupings will be broken when the left hand side returns True and the right hand side returns False, or vice versa.
19:58:07 <mniip> the docs don't mention anything that might be of use
19:58:20 <ReinH> This happens when a non-space abutts a space, or vice versa
19:58:23 <geekosaur> mniip, currently you don't. It's been requested, dunno offhand if it's planned at any point
19:58:38 <geekosaur> hm
19:58:46 <mniip> perhaps a flag analogous to -fprint-explicit-foralls
19:59:14 <ReinH> jellytux: the end result is that groups are divided by a change from space to non-space or a change from non-space to space
19:59:22 <mniip> hmm Typeable over quantified types isn't a thing yet is it
19:59:33 <pavonia> mniip: IIRC, there was a command with an *, :t* or :k* or something
19:59:38 <geekosaur> no, that's ongoing development
19:59:59 <geekosaur> pavonia, there's :kind! but not :type!
20:00:25 <jellytux> ReinH: I understand the end result, but I want to understand step by step how it does it. e.g for "A B C"
20:00:38 <ReinH> > isSpace 'A' == isSpace ' '
20:00:39 <lambdabot>  False
20:00:44 <ReinH> > isSpace ' ' == isSpace 'B'
20:00:45 <ReinH> and so on
20:00:45 <lambdabot>  False
20:00:48 <geekosaur> hm, :kind! also normalizes the type
20:01:16 <ReinH> Every false starts a new group
20:01:49 <jellytux> ReinH: ah, now I get it
20:01:53 <jellytux> ReinH: thank you
20:02:01 <ReinH> yw
20:02:17 <ReinH> The predicate is "Does the existing group continue?"
20:02:49 <jellytux> ah, that makes more sense when you put it like that
20:02:52 <ReinH> and it's given the last element of the existing group and the next element with which to decide.
20:03:02 <geekosaur> mniip, https://ghc.haskell.org/trac/ghc/wiki/TypeableT
20:04:03 <geekosaur> listed as "Won't make it but being actively worked on" on the ghc8 status page
20:04:53 <mniip> 1454731166 [06:59:26] <geekosaur> pavonia, there's :kind! but not :type!
20:04:57 <mniip> it's lying too :(
20:05:06 <mniip> TYPE Lifted :: *
20:05:07 <mniip> = *
20:05:42 <saulzar> minip, yeah - seems like if I do   :t undefined :: (r ~ T) => r   for  T = '[Int, Int] it just tells me   Expected a type, but r has kind [*] 
20:06:04 <saulzar> Of course that makes sense because r can't have the type of a type list...
20:06:39 <mniip> saulzar, you'll need a Proxy r
20:06:45 <saulzar> Ah yes..
20:07:33 * mniip . o O ( Seq :: k -> Constraint )
20:07:52 <jellytux> ReinH: whenever I encounted a *By function should I assume that the binary functions parameters will always be `b_index = a_index+1`?
20:07:52 * mniip . o O ( A constraint that evaluates the type to WHNF )
20:08:06 <mniip> jellytux, of course not, see sortBy
20:08:21 <geekosaur> not always. sortBy doesn't only compare adjacent elements
20:08:27 <saulzar> Now it prints the type ...   undefined :: (r ~ T) => Proxy r :: Proxy T  .. no kidding !
20:08:50 <mniip> saulzar, like I said it's not always working
20:08:56 <mniip> hmm hold on a sec
20:08:59 <saulzar> Alright, well thanks for the tips :)
20:09:44 <jellytux> mniip: sortBy :: (a -> a -> Ordering) -> [a] -> [a]
20:10:18 <jellytux> mniip: so what does the first and second parameter represent?
20:10:31 <mniip> jellytux, just some 2 elements
20:10:39 <mniip> the function should say which of them is larger
20:11:09 <jellytux> mniip: b does not express the preceeding element in the unsorted List?
20:11:21 <jellytux> sorry 
20:11:23 <jellytux> the succeeding*
20:11:25 <mniip> what?
20:11:30 <jellytux> [1,2,3,4
20:11:40 <dreaswar_h> Hi, I am a haskell noob and new to this channel. Thanks for all the help !!
20:11:45 <jellytux> a = 1, b= 2, ... next iteration a = 3, b = 4
20:12:58 <lpaste> mniip pasted “hurr durr saulzar” at http://lpaste.net/151776
20:13:03 <dreaswar_h> can anybody help me why (++ "SAY") "HELLO"  outputs "HELLOSAY"  and ("SAY" ++ ) "HELLO" outputs "SAYHELLO" ? 
20:13:32 <mniip> dreaswar_h, (# a) = (\x -> x # a)
20:14:36 <jellytux> sortBy f (a:b:xl) = ... (f a b) ... somewhere
20:14:43 <jellytux> mniip: don't you get what I mean
20:14:49 <dreaswar_h> mniip, Im sorry to say im just a few days old into haskell; could you be more elaborate ? Is it something to do with fixity ? 
20:15:01 <mniip> dreaswar_h, no it's just how operator sections mean
20:15:04 <jellytux> mniip: the values of a and b aren't arbitrary, they are adjacent elements in the list
20:15:05 <mniip> jellytux, no not at all
20:15:18 <mniip> like
20:15:20 <mniip> the opposite of that
20:15:48 <jellytux> mniip: what do you mean by the opposite?
20:17:02 <Shockk> dreaswar_h: (x `f`) is the same as \y -> f x y    from what I understand
20:17:09 <jellytux> I am wondering if I should always expect the elements to be adjacent whenever using a *By function.
20:17:15 <Shockk> dreaswar_h: ('f' y) is the same as \x -> f x y
20:17:35 <Shockk> r that should be `f` there but you get the point
20:18:03 <mniip> jellytux, how many times do I have to say no
20:18:10 <jellytux> [1,2,3,4], here 1 and 2 are adjacent, 3 and 4 are adjacent, so I would expect (\a b -> ...) that a and b are adjacent
20:18:23 <mniip> jellytux, http://lpaste.net/8667474784805715968
20:18:25 <mniip> are you satisfied now
20:19:21 <dreaswar_h> so Shockk, this is a section of an infix operator ? 
20:19:33 <jellytux> mniip: yes, thanks. I was afraid that I wasn't making myself clear, sorry
20:19:51 <Shockk> dreaswar_h: yes, they're called left/right sections
20:20:33 <dreaswar_h> Shockk ++ , mniip ++ , Thanks. I'm reading them here: https://wiki.haskell.org/Section_of_an_infix_operator
20:20:51 <mniip> it's called @karma+ :p
20:21:25 <dreaswar_h> Shockk++ mniip++ : small karmic correction :p
20:21:43 <shachaf> @karma+ is the extra-noisy way of incrementing lambdabot karma.
20:22:39 <mniip> yeah, lambdabot karma is the thing we're all after aren't we
20:33:36 <rui1> Anyone can give a hand? I am trying to nixos-rebuild -I "nixpkgs=mypath" and get a "This version of Nixpkgs requires Nix>=1.10" error
20:34:07 <rui1> Even if nixos-channel --update, or install nix 1.11 with nix-env
20:35:01 <rui1> ...running what the site says
20:35:07 <rui1> https://nixos.org/wiki/How_to_update_when_Nix_is_too_old_to_evaluate_Nixpkgs
20:36:51 <hypoon> osa1: are you around?
20:37:10 <shanemikel> man.. I'm thinking I could use pattern matching clauses as values
20:37:23 <shanemikel> or rather patterns to match against as values
20:40:38 <mniip> hmm
20:40:48 <mniip> Seq doesn't help with quantified types though
20:44:11 <mniip> very interesting
20:44:39 <mniip> id :: a -> a
20:44:39 <mniip> id reads :: Read a => ReadS a
20:44:44 <mniip> tseq :: a -> a
20:44:44 <mniip> tseq reads :: Read a => String -> [(a, String)]
20:47:05 <mniip> aww
20:47:08 <mniip> tseq (Proxy :: Proxy TypeSynonym) :: Proxy TypeSynonym
20:48:15 <mniip> haha!
20:50:57 <mniip> huh
20:51:04 <mniip> looks like an error message is broke
20:51:05 <mniip> n
20:51:08 <hypoon> What's the preferred way to contact the maintainer of something on hackage? Email? Submit an issue in Git? Wait patiently here?
20:51:19 <Clint> it depends
20:51:58 <mniip> saulzar, I might have solved your problem
20:56:02 <mniip> this is ultra weird though
20:57:03 <saulzar> minad, Using that Seq type family?
20:57:16 <saulzar> Er, mniip, Sorry!
20:57:30 <mniip> will past in a sec
21:00:11 <osa1> hypoon: yes
21:02:10 <hypoon> osa1: Does hslua support luaopen_*?
21:03:09 <osa1> hypoon: it supports luaL_openlibs
21:04:23 <hypoon> osa1: Right, but if I don't want all the standard libraries, but just (for example) base, string, math, and table?
21:04:40 * hackagebot aivika-transformers 4.3.2 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.3.2 (DavidSorokin)
21:04:46 <hypoon> osa1: specifically, I don't want scripts to be able to use io.
21:05:09 <osa1> hypoon: open an issue on Github, or even better, send a pull request :)
21:05:27 <lpaste> mniip pasted “typeSeq” at http://lpaste.net/151778
21:05:31 <mniip> saulzar, ^
21:06:00 <mniip> meanwhile I think I found another bug in 8.0
21:06:00 <enolan> hey, in trifecta, what determines which <?> takes precedence?
21:06:25 <hypoon> osa1: Ah, ok. I'm new to Lua, so I didn't know if I was missing something obvious.
21:07:38 <hypoon> osa1: I'll submit an issue for now, and if I get it working, I'll follow up with a pull request. Thanks for your time.
21:07:47 <osa1> hypoon: I haven't used that API before, but I just had a quick look and I don't see why not support those.
21:08:31 <osa1> hypoon: sure don't worry if you can't implement yourself, I can take care of it this weekend probably.
21:08:54 <mniip> hypoon, why'd you exclude os and coroutine
21:08:57 <mniip> aand io
21:09:40 * hackagebot aivika-branches 0.1.1 - Branching discrete event simulation library  https://hackage.haskell.org/package/aivika-branches-0.1.1 (DavidSorokin)
21:10:09 <hypoon> mniip: I'm not a sufficiently advanced Lua user to know what's safe and what's not. I'm already fearful of scripters dumping my game engine into an infinite loop, I don't want to have to worry about them trashing my filesystem (just an example).
21:10:26 <saulzar> mniip, Cool, seems to do nicely.
21:10:30 <mniip> sandboxing lua is...
21:10:34 <mniip> a complicated thing
21:10:53 <mniip> I have quite some experience as I run the official #lua interpreter bot
21:11:22 <mniip> long story short I just gave up and ran the process in a ptrace jail
21:11:32 <hypoon> mniip: I thought by default Lua was relativly safe, and that the standard libraries are what give it the power to be dangerous.
21:12:01 <saulzar> type T = Elem 3 '[3, 4]  >  :t proxySeq (Proxy :: Proxy T)    -->   proxySeq (Proxy :: Proxy T) :: Proxy 'True
21:15:32 <mniip> saulzar, magic
21:34:37 <orion> Within a (Pipe ByteString ByteString IO ()), is it possible to shoehorn `yield' and `await' so that they work with functions whose signatures are ByteString -> IO () and IO ByteString?
21:36:01 <mniip> \o/
21:36:04 <mniip> there goes another bug report
21:36:48 <monochrom> this is a good time to say: bugger it all
21:37:04 <JuanDaugherty> always
21:37:16 <JuanDaugherty> almost
21:38:46 <mniip> it looks like a low hanging fruit too, maybe I can trace it
21:40:49 <orion> mniip: Which one are you looking at?
21:42:18 <mniip> the one I just made, https://ghc.haskell.org/trac/ghc/ticket/11548
21:42:28 <orion> ah
21:53:42 <romanandreg> I’m trying to change some JSON values using the aeson-lens libraries
21:54:05 <romanandreg> I want to change all the leafs that are String and have a pattern “{{property.one}}”
21:54:26 <romanandreg> I’m able to get the leafs by doing
21:54:38 <romanandreg> aTemplate ^.. (deep _Value)
21:54:47 <romanandreg> aTemplate :: Aeson.Value
21:54:57 <romanandreg> nevermind, is
21:55:05 <romanandreg> aTemplate ^.. (deep _String)
21:55:12 <romanandreg> this returns me all the leafs that are string
21:55:29 <romanandreg> but I would like to get all the leafs regardless of them being _String or _Number
21:55:40 <romanandreg> because I want to be able to change properties types if necesseray
21:55:43 <romanandreg> is there a way to do that?
21:56:57 <c_wraith> :t having
21:56:59 <lambdabot>     Not in scope: ‘having’
21:56:59 <lambdabot>     Perhaps you meant one of these:
21:56:59 <lambdabot>       ‘taking’ (imported from Control.Lens),
21:59:20 <shanemikel> I'm learning haskell, and I'm at the point where I think dependent types could solve some of my issues, but I'd like to be able to work with haskell and have the type system work for me, not against me.. I'm worried I'm falling into some bad habits, does somebody care to comment on this: http://lpaste.net/8710551408409051136
22:03:48 <shanemikel> I could probably use monad in those examples actually
22:03:57 <Gurkenglas_> :t liftA3 bool
22:03:58 <lambdabot> Applicative f => f d -> f d -> f Bool -> f d
22:04:30 <Gurkenglas_> "a ->" can be used for f.
22:04:31 <jle`> shanemikel: what are you trying to enforce?
22:04:58 <jle`> if you want to show that your strings are non-empty you can always just use NonEmpty
22:05:16 <shanemikel> :t NonEmpty
22:05:18 <lambdabot> [a] -> NonEmptyList a
22:05:27 <jle`> er
22:05:32 <jle`> i wonder where that's from
22:05:40 <jle`> i'm talking about the NonEmpty type
22:05:41 <shanemikel> jle`: i'm sorry I don't know what you mean
22:05:46 <shanemikel> :k NonEmpty
22:05:47 <lambdabot> [k] -> NonEmptyList k
22:05:52 <jle`> i wonder where those are from
22:05:56 <jle`> i meant the one from semigroups
22:06:19 <jle`> http://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html
22:06:24 <jle`> i wonder where the one on lambdabot is from
22:06:32 <jle`> i've never seen it before :O
22:06:48 <jle`> but yeah, a NonEmpty Char is a String with at least one character
22:06:57 <Gurkenglas_> :t liftA2 $ \bool b -> guard bool >> Just b -- shanemikel
22:06:58 <lambdabot> Applicative f => f Bool -> f b -> f (Maybe b)
22:07:10 <jle`> hm
22:07:16 <jle`> i'd just say `guard p $> j`
22:07:22 <jle`> er, guard p $> x, or x <$ guard b
22:07:31 <jle`> > 1 <$ guard False :: Maybe Int
22:07:32 <lambdabot>  Nothing
22:07:39 <jle`> > guard True $> 2 :: Maybe Int
22:07:40 <lambdabot>      Not in scope: ‘$>’
22:07:40 <lambdabot>      Perhaps you meant one of these:
22:07:40 <lambdabot>        data constructor ‘Seq.:>’ (imported from Data.Sequence),
22:08:03 <jle`> @let import Data.Functor
22:08:04 <lambdabot>  Defined.
22:08:07 <jle`> > guard True $> 2 :: Maybe Int
22:08:08 <lambdabot>  Just 2
22:09:05 <jle`> i'm still not totally sure what part you think dependent types will help you with?
22:09:08 <Gurkenglas_> "guard p $> x" <- p? You mean b, right? Because p sounds like predicate sounds like (a -> Bool)
22:09:43 <Gurkenglas_> And sure, ">> Just" can be replaced by $>.
22:10:20 <jle`> hm, let me look at what is actually wanted
22:10:20 <MarcelineVQ> jle`: it's quickchecks NonEmptyList
22:11:00 <shanemikel> oh wow.. I guess I just need to get more comfortable with using applicative and monad instances of (r ->)
22:11:50 <jle`> nothingFor might nto be too useful, because it's a bit simple-ish
22:12:09 <jle`> nothingFor p f x = guard (p x) $> f x, i suppose
22:12:18 <jle`> but might as well use mfilter
22:12:49 <jle`> or f <$> mfilter p (Just x)
22:12:56 <shanemikel> but, in practice, do you see yourselves using guard functions as an excuse to use partial functions
22:13:04 <jle`> i'm not sure what you mean
22:13:21 <shanemikel> like the lamba in the first function in my paste
22:13:21 <jle`> guard functions are an excuse to use partial functions?
22:13:39 <kadoban> The guard stuff above isn't using ((->) r)'s instances, unless I'm tragically misunderstanding. That was just Gurkenglas_'s golfing your tern function I believe
22:14:06 <jle`> shanemikel: it looks like you just want to map toUpper on the first item on a list?
22:14:11 <jle`> there isn't anything partial about that
22:14:43 <Gurkenglas_> :t liftA2 $ \bool -> (guard bool $>) -- kadoban, this sure uses (the reader) applicative
22:14:44 <lambdabot> (Applicative f, Alternative f1) => f Bool -> f b -> f (f1 b)
22:15:00 <shanemikel> I guess I could define a `mapFor` .. I've already done `mapWhile`
22:15:28 <jle`> the lens library gives some pre-defined mappers on arbitrary indices of lists, but you could def write your own
22:15:34 <jle`> > over (ix 0) toUpper "hello"
22:15:36 <lambdabot>  "Hello"
22:15:40 <jle`> > over (ix 0) toUpper ""
22:15:41 <lambdabot>  ""
22:15:49 <kadoban> Gurkenglas_: Well, yes I guess that one does.
22:17:17 <shanemikel> what about isSymbolKey, do y'all see yourselves writing boilerplate functions to complement your data types?
22:17:22 <jle`> shanemikel: this is sort of in the same space as defining a function that maps over eithers
22:17:28 <jle`> or, over Rights, or Lefts
22:17:38 <jle`> > fmap (+2) (Left "hello")
22:17:39 <lambdabot>  Left "hello"
22:17:49 <shanemikel> yeah, but I was thinking of adding more constructors
22:18:09 <shanemikel> and I don't want nested Eithers.. but I was thinking there could be something EitherN that might help
22:18:27 <jle`> there are EitherN-like things, but you can also use the 'lens' library to generate boilerplate functions too
22:18:37 <jle`> it might be more natural for beginner/intermediate haskell
22:18:52 <jle`> lens generates the boilerplate functions you're thinking of
22:19:00 <jle`> isSymbolKey = has _SymbolKey
22:19:28 <jle`> or well, the 'lens' library has features to generate these if you wanted
22:19:34 <jle`> (that's not the point of lens, per se)
22:19:45 <shanemikel> jle`: oh wow.. that's great thanks
22:19:48 <jle`> isShiftKey = has _ShiftKey
22:20:32 <shanemikel> looks like a big library.. could you point me in the direction of that, perhaps?
22:21:18 <shanemikel> (and thanks for putting the /intermediate in there, ego +1)
22:21:19 <jle`> it's in the TH module
22:21:59 <jle`> there are EitherN/TupleN -type types but i think the approach using the boilerplate generators in the lens library is more natural for normal haskell usage
22:22:25 <jle`> shanemikel: http://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-TH.html
22:23:08 <jle`> you'd want makePrisms
22:23:28 <jle`> oh, and this pattern: (H.nothingOr isSymbolKey getSymbols)
22:24:21 <jle`> that's preview _SymbolKey
22:24:30 <jle`> > preview _Left (Left "hello")
22:24:32 <lambdabot>  Just "hello"
22:24:42 <jle`> > preview _Left (Right 10)
22:24:43 <lambdabot>  Nothing
22:25:00 <jle`> > preview (ix 0) "hello")
22:25:02 <lambdabot>  <hint>:1:23: parse error on input ‘)’
22:25:04 <jle`> > preview (ix 0) "hello"
22:25:06 <lambdabot>  Just 'h'
22:25:09 <jle`> > preview (ix 0) ""
22:25:11 <lambdabot>  Nothing
22:25:11 <jle`> etc.
22:25:38 <shanemikel> awesome
22:25:43 <shanemikel> what's this ix you keep using?
22:25:45 <shanemikel> :t ix
22:25:46 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
22:27:11 <shanemikel> :t preview
22:27:12 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
22:28:13 <shanemikel> jle`: do you recommend using an alternative prelude like I've been reading about?  classy-prelude for instance?
22:29:28 <badmash> is there an irc channel for haskell cabal?
22:31:49 <badmash> no one answered ... so i suppose not 
22:35:15 <badmash> if you're using cabal to install packages and two packages you need have conflicts, how do you resolve it? (note -- even if you use a sandbox, these two packages within the sandbox will be in conflict, so i suppose sandboxing will not solve the problem)? 
22:37:04 <shanemikel> you might be able to do some static linking? I don't really no about this I'm just shit shooting
22:37:15 <shanemikel> err.. know
22:38:23 <shanemikel> but the answer (whatever it is) is not likely to be pretty
22:38:27 <ReinH> badmash: Cabal only allows you to use one version of a given package across all dependencies.
22:38:47 <ReinH> So the only solution is to resolve the conflict to a single version.
22:38:57 <badmash> shanemikel: this should be a fairly common problem people must have faced in haskell development prior to stack, so i want to know how -- basically the workflow -- people managed it.
22:39:51 <badmash> ReinH: that would be an extremely tedious affair, wouldn't it?
22:39:54 <shanemikel> I think by updating whatever code was behind on versions, probably
22:39:59 <ReinH> This is one of the reasons that stackage exists: to provide a set of mutually compatible package versions.
22:40:22 <badmash> ReinH: yes, i know
22:40:30 <ReinH> So yes, it's tedious, but that's how it is.
22:40:54 <ReinH> In practice, using stack or stackage fixes this almost all the time.
22:41:48 <shanemikel> anybody know how to ask lambda-bot where a name comes from?
22:41:59 <shanemikel> :i preview
22:42:10 <ReinH> @hoogle preview
22:42:11 <lambdabot> package markup-preview
22:42:19 <ReinH> Is the closest you can get, I suppose
22:42:27 <shanemikel> @hoogle fmap
22:42:28 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
22:42:28 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
22:42:28 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
22:42:32 <shanemikel> okay.. awesome
22:42:55 <shanemikel> oh.. I don't think that's the same one
22:42:57 <shanemikel> :t preview
22:42:59 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
22:43:22 <ReinH> Hoogle isn't complete.
22:51:20 <badmash> ReinH:  is it possible to install a package within a
22:51:20 <badmash>                 sandbox, and then make that package available to
22:51:21 <badmash>                 GHC?  (of course, this still would not be an ideal
22:51:21 <badmash>                 solution, because things could break at runtime)
22:51:59 <badmash> sorry for the badly formatted message
22:53:22 <badmash> ReinH: i am wondering if it is possible to install a package within a sandbox, and then make that available to GHC?  this is being done to avoid conflicts between packages.
22:54:22 <kadoban> badmash: What would the point be of sandboxes that you couldn't use with GHC?
22:54:29 <kadoban> I'm not really understanding the question.
22:56:43 <orion> Does anyone know how to properly define `cb' here?: http://lpaste.net/3654837866896293888#line23
22:57:04 <shanemikel> badmash you probably want to compile the lib inside the sandbox using the -static flag to ghc, then copy the compiled result into the sandbox of your app
22:57:06 <badmash> package A exists in the global db, and i want to install package B, but it has conflicts with package, so i install package B within a sandbox.  projects (having their own sandboxes) can use package A, but can they use package B?  
22:58:55 <badmash> kadoban: do you see what my problem is?
22:59:06 <badmash> i hope it is clear
22:59:55 <shanemikel> oh, so you may be able to have the sandbox reach outside of itself for some global deps
23:00:24 <shanemikel> but you should try the static linking and copying first to see if it even works
23:01:41 <badmash> shanemikel: the problem is, even if i have the sandbox or static linking, as you mentioned, i can not have package A & package B in the same sandbox because they have conflicts. so what can be done here?
23:01:59 <shanemikel> it probably depends on how you're using the conflicting package
23:03:16 <shanemikel> it could be that a hacky use of renaming and qualified imports would do the trick
23:03:17 <badmash> shanemikel: my question is -- can i install package B in a sandbox, and then have code outside the sandbox access package B?
23:03:24 <nshepperd> find versions of A and B that do not conflict, and install them both in the same sandbox
23:04:25 <kadoban> That seems like the only solution to me ^
23:04:25 <badmash> nshepperd: yes, that is a solution, but that could be unbelievably tedious.  is that the only solution?
23:04:37 <shanemikel> badmash: what are the packages
23:04:42 <cads> wow, try-reflex builds pretty quickly
23:04:54 <shanemikel> and the conflicting dep?
23:05:19 <nshepperd> also, you should generally not have packages installed in the global db
23:06:27 <nshepperd> badmash: it should just be a case of '<enter sandbox>; cabal install A B' and then cabal should find compatible versions by itself
23:07:22 <nshepperd> and then of course build your project in that same sandbox
23:08:36 <kadoban> If there *are* no compatible versions, then I'd think usually you're kind of doomed to go down the rabbit hole trying to figure out if that's really true or if one (or both) have bounds on their dependencies that are too tight. Either way it's probably not fun, but … not sure what other choice there is really.
23:08:36 <shanemikel> yeah, the only other solution would be to manually build parts of it, or trick cabal one way or another
23:09:22 <shanemikel> but I've never done that before, so don't take my word on it
23:12:27 <badmash>  right now, i am facing conflicts between dependencies of criterion and ghc-mod, and there could be many others
23:13:24 <shanemikel> would the conflict happen to be ghc itself?
23:14:14 <badmash> shanemikel: sorry, didn't fully understand your question ... i am just learning haskell, by the way :)
23:14:41 <shanemikel> are they depending on different versions of ghc (the haskell compiler itself)
23:14:46 <kadoban> badmash: You should really just be using 'stack'. But I have a feeling you're doing something weird even in cabal-install land. Why do you care that criterion and ghc-mod have different deps?
23:14:48 <shanemikel> have you tried stack?
23:15:43 <shanemikel> usually people just build ghc-mod and put it in their PATH, right?
23:15:49 <nshepperd> aha
23:16:02 <badmash> shanemikel: actually, i am aware of stack, but i want to understand how things work, so digging into use of cabal first to see all the issues and problems for myself
23:16:26 <nshepperd> yes, if you're just using ghc-mod for your editor, that's easy
23:16:40 <shanemikel> are you actually using ghc-mod as a dependency of an application you're writing? or do you just want to use it for ide type features?
23:17:13 <badmash> kadoban: i am not sure what you mean? i had installed criterion and now i am installing ghc-mod, and cabal reports conflicts
23:18:19 <kadoban> badmash: Do them in separate sandboxes. Also you shouldn't have let anything install any packages to the "global" (your user) package DB, so if you did … time to nuke the world and start over (and welcome to cabal-install, ain't it fun?)
23:18:32 <badmash> shanemikel: ghc-mod -- i plan to use it with haskell-mode in emacs primarily.  also perhaps run it as a command from terminal.
23:19:17 <shanemikel> badmash: right, so simply as a user of ghc-mod (not developing on it or with it), you just need to build it and put it in your PATH
23:19:21 <kadoban> badmash: ghc-mod is just an executable, it's not a dependency of like … anything. So there's no reason to care what dependencies it uses really, or that they conflict with anything else. It should be built in its own personal sandbox and then you copy the executable elsewhere, or use a symbolic link
23:19:24 <nshepperd> (you can delete the user-global package db by deleting ~/.ghc)
23:19:39 <badmash> kadoban: "do them in seperate sandboxes"?  yeah, if i did that, how would other code outside those sandboxes be able to use them?
23:19:44 <ReinH> badmash: Either everything is in a sandbox or nothing is in a sandbox. There's simply no facility to use multiple concurrent versions of a package at the same time.
23:19:49 <shanemikel> badmash: so there's no reason to use the same sandbox (that's the point of sandboxes to begin with) because you're not building using them into the same executable
23:19:58 <kadoban> badmash: I know of no code that uses ghc-mod. It's an executable.
23:20:07 <ReinH> Instead of asking how you can do that, ask how you can avoid needing two versions instead.
23:20:42 <ReinH> The simplest solution to that problem has already been mentioned: use stackage.
23:20:56 <shanemikel> ReinH: we've got passed that
23:20:58 <kadoban> Well, stack, stackage too if you want.
23:21:08 <kadoban> Oh sorry, ignore that. I misread.
23:21:12 <shanemikel> ReinH: he's not even building one project, he's trying to install some haskell applications
23:21:27 <shanemikel> ReinH: which can (and should) be built separately
23:21:40 <shanemikel> err.. in separate sandboxes
23:21:53 <kadoban> badmash: If you want to use the criterion library (I think it's mostly/solely a library?), put that in whatever sandbox you're using for the project you're using it with. But it should be a separate one from the ghc-mod sandbox.
23:22:05 <ReinH> There is no criterion executable.
23:22:08 <shanemikel> badmash: okay, create a sandbox JUST for ghc-mod, and build it.. then cabal install
23:22:24 <ReinH> Or just use stack.
23:22:24 <shanemikel> badmash: and put ~/.cabal/bin in your PATH
23:22:25 * ReinH shrugs
23:22:34 <badmash> kadoban: i see.  in this case, i have done that with ghc-mod, but there will inevitably be situations where 2 packages will be conflict, and i was trying to understand how to handle that.  perhaps there are no solutions for that in cabal, as ReinH has mentioned.
23:23:03 <shanemikel> but even with stack, he'd want to do the same thing
23:23:35 <badmash> shanemikel: and if i do that, i should be able to use emacs with haskell-mode and ghc-mod, i suppose?
23:23:37 <ReinH> The whole point of stackage is to present a mutually consistent set of package versions. So no, it is not at all inevitable.
23:23:39 <shanemikel> you need to understand what sandboxes are for, and the difference between installing applications and building apps you're working on
23:24:17 <badmash> shanemikel: yes, you are right.  i am a bit confused on that front, frankly
23:24:39 <ReinH> The issue with cabal is putting everything into a shared space and then getting conflicts.
23:24:39 <shanemikel> I think you're misled because you're used to python sandboxes being used as a way to install programs in users' home dirs
23:24:41 <jle`> shanemikel: i don't use an alternative prelude myself
23:24:47 <ReinH> Sandboxes per build solve this, as does stack.
23:25:11 <shanemikel> or some other, similar language package management
23:25:25 <ReinH> Other language package managers sandbox by default.
23:25:27 <ReinH> As does stack.
23:25:43 <shanemikel> ReinH: you're not understanding the misconception either
23:26:14 <ReinH> Well, feel free to enlighten me.
23:26:18 <shanemikel> badmash: the reason you do something like that to install python applications, and not haskell, is because python is interpreted, where with a compiled language you can build things and get rid of the source
23:26:43 <shanemikel> ReinH: he's trying to use one sandbox to put all the haskell applications he wants to be a *user* of, not develop with
23:26:48 <nshepperd> shanemikel: uh wait, I don't think cabal install will put anything into ~/.cabal/bin either, if you run it in a sandbox
23:26:52 <ReinH> Yeah, so stop doing that.
23:27:34 <jle`> shanemikel: the proper terminology concerning `ix n` and _Left is that they are 'traversals' over specific things "inside" the data structure; 'ix 0' gives a traversal over the first index, ix 1 gives you a traversal over the second, etc, and _Left gives you a traversal over the "Left" field (if it exists)
23:27:37 <kadoban> nshepperd: It won't I don't think, but yeah you can just ln -sf it to wherever you want.
23:27:37 <ReinH> That doesn't conflict with anything I said.
23:27:44 <shanemikel> so with python it makes more sense, and the python package managers AFAIK don't do much in the way of versioning deps and complex dep resolution
23:28:27 <shanemikel> nshepperd: oh, well wherever the exe get's placed
23:28:37 <nshepperd> A program built in a sandbox will be put into .cabal-sandbox/bin by default
23:28:43 <badmash`> shanemikel: sorry, got briefly disconnected.  i may have missed what you said
23:28:44 <nshepperd> in the sandbox
23:28:56 <shanemikel> badmash: the reason you do something like that to install python applications, and not haskell, is because python is interpreted, where with a compiled language you can build things and get rid of the source
23:28:59 <shanemikel> so with python it makes more sense, and the python package managers AFAIK don't do much in the way of versioning deps and complex dep resolution
23:29:11 <shanemikel> I think you're misled because you're used to python sandboxes being used as a way to install programs in users' home dirs
23:29:16 <shanemikel> or some other, similar language package management
23:29:21 <shanemikel> ReinH: he's trying to use one sandbox to put all the haskell applications he wants to be a *user* of, not develop with
23:29:31 <ReinH> Yes, you already said that and I already responded.
23:29:32 <shanemikel> ReinH: .... Yeah, so stop doing that
23:29:36 <ReinH> Oh ok.
23:31:07 <ReinH> Which is weird, because you would have to do extra non-obvious work to share sandboxes
23:31:21 <ReinH> like, it requires an option to cabal that you have to specifically look up
23:31:27 <badmash`> sorry, got disconnected, so may have missed some stuff
23:31:46 <shanemikel> so, to summarize badmash` you should use sandboxes to build projects you are *working* on, independently of every other project you're *working* on, and you can also use a different sandbox for each application you want to install, and then all the binaries for said built applications get put in a directory (so you can destroy the sandboxes after building if you want)
23:32:09 <ReinH> All that, or you can just use stack, which takes care of that for you.
23:32:16 <ReinH> TL;DR: use stack
23:32:42 <shanemikel> err. . nvm actually I think cabal does strange things with linking. so maybe you can't delete the sandboxes (I can't remember)
23:32:46 <shanemikel> so yeah, use stack
23:32:51 <kadoban> The stack version: 'stack install ghc-mod' somewhere else: add criterion to a build-dep in a .cabal file and then … that's it.
23:33:17 <ReinH> ghc-mod is an executable. criterion is a library. Their use cases are entirely different.
23:33:22 <ReinH> So I don't get the confusion there.
23:33:24 <shanemikel> at some point, stack will be able to install applications that are pre-built too
23:33:41 <shanemikel> ReinH: he's a newbie, that's all
23:33:44 <ReinH> If it's that they can't mutually coexist in the same package universe, then the answer is the same: use separate universes.
23:36:21 <shanemikel> jle`: yeah, I'm reading about it now https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial looks promising
23:36:56 <badmash`> alright, thanks for the inputs
23:40:43 <badmash> one more question on this sandbox thing -- when you have sandboxed a project, and installing all its dependencies in that sandbox, you could still run into conflicts between those dependencies.  i that case, you just go in there and manually resolve those conflicts, ensureing there is only one compatable version for every dependency?
23:44:51 <badmash``> shanemikel: thanks for the inputs
23:44:57 <shanemikel> badmash``:  yes
23:45:19 <shanemikel> but the sandboxes exist specifically to reduce the probability of that happening
23:46:01 <shanemikel> also, don't confuse the word sandbox with security isolation (like a chroot sandbox or container)
23:46:26 <shanemikel> it's simply a way to keep the compilation isolated
23:48:13 <badmash``> just trying to understand some things you said -- in haskell, you need all this complex dependency resolution because haskell is a compiled language?
23:48:36 <JuanDaugherty> no
23:48:45 <shanemikel> so, here's another tip.. as for stackage vs hackage (stack vs cabal), when you are building projects, to be on the safe side you wanna try and limit yourself to libraries in stackage.. as for applications, try stack first, and if the application isn't there, just do the cabal sandbox thing
23:49:13 <JuanDaugherty> badmash, it's not compilation alone, it's the model of computation realized
23:50:17 <shanemikel> badmash``: the fact that it's a compiled language makes it easier to break
23:50:23 <badmash``> shanemikel: ok, yes, about stack and stackage, i am kind of aware, but i wanted to dig into cabal etc to understand first hand how things are, what the problems are.  it might be not a wise thing, but i wanted to learn this stuff.
23:50:39 <ReinH> There could be support for multiple concurrent package versions. Theoretically, the version is just another part of the unique identifier for a module. But this would require language/compiler support that doesn't exist.
23:51:54 <ReinH> This is complicated somewhat by the way imports work, but it is technically solvable. It just hasn't been solved.
23:52:32 <badmash``> shanemikel: in python etc, where things are interpreted, so all the source is there, so things breaking will be easier to detect, you mean?
23:53:01 <shanemikel> even so, would people expect to be able to cherry-pick functions and data constructers from both versions in the same code? that doesn't sound like a good idea
23:53:54 <badmash``> ReinH: i think you need curated versions to really solve this problem, like stackage
23:54:11 <ReinH> Currently, yes, and that's what we have.
23:54:37 <shanemikel> badmash``: in a compiled language, a change that doesn't effect the interface of your code (the functions, by name, you export) could still effect the compiled version
23:55:25 <shanemikel> in an interpreted language, the interface (and all the names/symbols used by the programmer) is all that matters
23:55:48 <badmash``> shanemikel: i see
23:56:33 <shanemikel> err.. not necessarily, but more often
23:58:24 <shanemikel> at least that's what I understand.. don't have first hand experience, I expect there are exceptions in both case, and I don't know what that means for JIT
