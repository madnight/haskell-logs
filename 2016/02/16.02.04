00:00:17 <johnw> you can do it do-block style also, with as many points as you wish
00:00:39 <vkt> can someone help me understand why (\x -> x):[] :: [t -> t] instead of t -> [t]?
00:01:29 <kadoban> vkt: What's the type of (\x -> x) ?
00:01:55 <vkt> kadoban: r -> r
00:02:00 <frerich> vkt: It's because () binds stronger than ':'. I.e. compare '(\x -> x:[])' with '(\x -> x):[]'.
00:02:06 <kadoban> vkt: And what's the type of (:) ?
00:02:49 <vkt> kadoban: r->[r]->[r]
00:03:08 <johnw> :t (:)
00:03:09 <lambdabot> a -> [a] -> [a]
00:03:26 <vkt> hurray lambdabot =D
00:04:43 <vkt> actually it's hard for me to wrap myhead around what [t -> t] actually is. the input of my function is clearly not a list... 
00:05:24 <ahihi> [t -> t] is a list of functions t -> t
00:05:26 <kadoban> vkt: It's a list of functions.
00:05:35 <vkt> oh 
00:05:47 <t0mb0> Hey all
00:05:48 <kadoban> vkt: Each of the functions in the list is of the type "give me something and I'll give you something of the same type"
00:05:49 <jle`> > head [(\x -> x)] "hello"
00:05:51 <lambdabot>  "hello"
00:06:07 <jle`> head [f] = f, so head [(\x -> x)] "hello" = (\x -> x) "hello"
00:06:10 <jle`> = "hello"
00:06:22 <jle`> t0mb0: hi!
00:06:28 <t0mb0> I'm trying to learn haskell but having troubles grasping this closure problem https://wiki.haskell.org/Closure
00:06:43 <maybefbi> where can i start learning about functions that act on types, and how can i use them
00:07:16 <jle`> t0mb0: hm, what part are you struggling with?  but, if you're trying to learn haskell, it might be best to go through some structured course/tutorial that introduces things in a good order
00:07:38 <jle`> i'm not sure if i ever consciously think of the idea of "closure" when using haskell...
00:07:48 <Ainieco> johnw: hm, do you mean you don't see connection with https://en.wikipedia.org/wiki/Congruence_relation ? what's on SO then?
00:07:53 <jle`> do you understand what the function does?
00:08:01 <jle`> forgetting the "closure" jargon
00:08:09 <Ainieco> johnw: i thought it was a cong relation
00:08:12 <johnw> x = y -> f x = f y    I usually think of that as aspect of "Leibniz equality"
00:08:19 <pavonia> maybefbi: https://wiki.haskell.org/GHC/Type_families might be a good start
00:08:22 <t0mb0> jle`, I am doing that - sort of... But I'm just playing around in GHCI to understand
00:08:23 <maybefbi> dank
00:08:25 <maybefbi> danke
00:08:26 <t0mb0> but I have this 
00:08:27 <t0mb0> https://dpaste.de/hyvp
00:08:38 <t0mb0> when I do someting like let ret = testFunc 1
00:08:54 <Ainieco> johnw: why do they call it congruence in agda/coq if it's not?
00:08:56 <jle`> t0mb0: do you notice that your function has a type signature that says it only takes one argument
00:09:02 <jle`> t0mb0: but you name two arguments in your definition?
00:09:06 <t0mb0> it seems to forget that I passed 1 to testFunc when I bound it
00:09:17 <jle`> you probably meant to say testFunc x = (\y -> x + y)
00:09:29 <t0mb0> ah ok
00:09:29 <johnw> well, in Coq it comes from: "The tactic congruence, by Pierre Corbineau, implements the standard Nelson and Oppen congruence closure algorithm, which is a decision procedure for ground equalities with uninterpreted symbols."
00:09:32 <jle`> or, if you intend to pass in an argument and ignore it, testFunc _ x -> (\y -> x + y)
00:09:42 <t0mb0> jle`, so referencing https://wiki.haskell.org/Closure
00:09:47 <t0mb0> where they say "f x"
00:10:02 <t0mb0> f in my example is my function name "testFunc"
00:10:02 <jle`> t0mb0: 'f' is the name of the function there
00:10:10 <jle`> yeah, so you shouldn't put 'f' there, also
00:10:12 <Ainieco> johnw: seem like this is yet another "Vec"(which is not in fact a vector)
00:10:18 <jle`> testFunc x = (\y -> x + y) would be the analogy
00:10:26 <jle`> but in any case, your type signature still is a bit off
00:10:32 <jle`> you take an 'a', and return a new function, a -> a
00:10:32 <johnw> isn't overloaded terminology wonderful
00:10:37 <t0mb0> jle`, sorry I didn't mean to include the sig I was playing with that as well
00:10:41 <johnw> be glad it wasn't called functor
00:10:41 <jle`> so it should be testFunc :: Num a => a -> (a -> a)
00:10:51 <jle`> "take an `a`, and return an `a -> a`"
00:10:57 <t0mb0> I was just playing around with just the implementation
00:11:12 <jle`> johnw: mhm
00:11:19 <jle`> * t0mb0 
00:11:29 <jle`> ah, did you still have a question, the?
00:11:31 <Ainieco> johnw: sigh, so confusing, seems pointless to learn this thing because nobody will understand you when you say "look it has cong property, you know, that one which is not actually cong but called that way..."
00:11:31 <jle`> *then
00:12:20 <t0mb0> jle`, I think my question, although round-about was actually just querying how I would adapt that example from the haskell wiki into ghci
00:12:25 <t0mb0> and I believe you answered it for me
00:12:33 <jle`> cool!
00:12:39 <t0mb0> for some reason I interpreted the wiki example as having f as an argument
00:12:50 <t0mb0> where F is meant to equal my "testFunc"
00:12:51 <jle`> i wouldn't bother with trying to understand what a closure means in the wiki, it's a bit opaque even for someone who has been using haskell for years
00:13:27 <t0mb0> jle`, I get really compulsive with trying to understand Haskell  haha
00:14:00 <t0mb0> I'm not a mathematician so it can take me a while to understand
00:14:30 <jle`> haha yeah.  i know the feeling.
00:14:45 <kadoban> A closure seems like a much more important concept in ‚Ä¶ pretty much any other language. When nothing is mutable, I dunno ‚Ä¶ yeah I just don't think of anything as a closure.
00:15:10 <jle`> t0mb0: but yeah, i wouldn't think understanding closures really helps you understand haskell in any meaningful way
00:15:12 <ahihi> math doesn't really deal with closures in this sense
00:15:39 <t0mb0> jle`, ok cool that's good to know. I think I stumbled onto that page from reviewing the lambda operator
00:16:08 <t0mb0> so many symbols in haskell!
00:16:12 <jle`> i guess in learning haskell it's really easy to get side tracked into a lot of unrelated things, heh, because the links are everywhere
00:16:23 <t0mb0> yeah I am following the learn me a haskell book
00:16:26 <jle`> haskell people tend to be interested in a lot of weird things that aren't directly tied to haskell
00:16:32 <t0mb0> and sometimes I need to google things that are covered as I don't fully understand
00:16:35 <jle`> so the culture is littered with references like this, heh
00:16:40 <t0mb0> then the journey down the rabbit hole begins
00:17:40 <johnw> Ainieco: maybe: "cong establishes the equality of outputs based on an equality of inputs"; they are congruent, because they are equal for all properties being considered (where the "property" is the function/proposition applied to the inputs)
00:17:42 <jle`> haha, yeah.  it's an aspect of haskell culture i've noticed.  they like to talk about interesting but not quite directly related things, but the talk is everywhere.  it can be intimidating at times, for sure
00:18:02 <johnw> from Wikipedia: "In some cases, one may consider as equal two mathematical objects that are only equivalent for the properties that are considered."
00:18:14 <jle`> just take a look at a haskell subreddit's front page most of the time, heh
00:18:26 <johnw> it calls that congruence
00:19:32 <phadej> johnw: https://en.wikipedia.org/wiki/Congruence_relation#Relation_with_homomorphisms
00:20:04 <jle`> it'd be nice if there was something in haskell like idris's dependent pairs
00:20:05 <phadej> equality is congruence relation, and agda's cong is the proof for that
00:20:19 <jle`> right now i have to make a separate data type for each one
00:20:38 <johnw> phadej: thank you
00:20:57 <jle`> data SomeVec :: * -> * where SV :: Sing n -> Vec n a -> SomeVec a
00:21:35 <jle`> instead of just something more convenient like (exists n. (Sing n, Vec n a)) that i can just use in a type
00:21:46 <jle`> (n :: Nat)
00:22:35 <Ainieco> johnw: i gave that link in very beginning "< Ainieco> johnw: hm, do you mean you don't see connection with https://en.wikipedia.org/wiki/Congruence_relation ? what's on SO then?"
00:22:45 <Ainieco> johnw: and then you started to confuse me :/
00:22:50 <phadej> jle`: you can abstract a bit on that
00:22:51 <johnw> Ainieco: I'm sorry
00:23:08 <Ainieco> johnw: no problem :)
00:23:19 <jle`> phadej: i can see how to abstract it to specific patterns/shapes
00:23:28 <jle`> but nothing too general
00:23:32 <jle`> can you give an example of what you are talking about?
00:24:01 <phadej> jle`: I agree that you have to write own versions for different permutations of indexes / types
00:24:26 <jle`> yeah. i guess you can use a combination of Flip newtype wrappers to coerce everything to fit, but
00:24:27 <phadej> jle`: but in idris there is similar boilerplate
00:24:28 <jle`> :|
00:24:32 <jle`> hm, really?
00:24:40 <phadej> or is exists. valid idris?
00:24:50 <jle`> i think it's just (n ** Vec n a), in idris
00:24:52 <phadej> haven't followed its development
00:24:59 <jle`> or well, ((n :: Nat) ** (Vec n a))
00:25:06 <johnw> jle`: in Coq it would be { n & Vec n a }
00:25:19 <jle`> yeah so neat
00:25:25 <johnw> Ainieco: clearly I don't understand it well yet
00:25:49 <johnw> Ainieco: so in future I'll keep silent
00:25:52 <phadej> jle`: but in Haskell you have to squeeze the singleton somewhere too :)
00:26:11 <jle`> well the singletons package is kind of nice
00:26:24 <jle`> it lets things like SV :: Sing n -> Vec n a -> SomeVec a make sense
00:26:33 <jle`> and (exists n. (Sing n, Vec n a))
00:26:46 <jle`> unless i misunderstand what you're trying to say
00:27:18 <phadej> jle`: in fully dependent language you don't need singletons, as the type can act as one itself
00:27:44 <jle`> yeah
00:28:01 <jle`> but something like (Sing n ** Vec n a) would "make sense", i think
00:28:15 <jle`> even though requiring the singleton makes it a bit less clean
00:28:20 <jle`> it's still useful :D
00:29:58 <phadej> (:**:) :: Sing n -> Thing1 n a -> SomeThing1 a ? :)
00:30:15 <jle`> yeah, but only for specific shapes/orderings of indexes
00:30:48 <jle`> i guess making a bunch of combinators would be doable if you stuck with a specific convention
00:31:15 <jle`> but then we might end up with something like that 'composition combinators' library that has 500 template-haskell derived operators for all sorts of function composition combinators
00:32:05 <Ainieco> johnw: no worries, it's actually better to make mistakes and learn than don't mke mistakes and don't learn, i've seen your https://github.com/jwiegley/coq-haskell which is nice, just wanted to let you know :)
00:33:59 <jle`> phadej: in my specific situation i have a bunch of arbitrary usages on the rhs
00:34:10 <jle`> Sing n ** Foo n a (2 + n) etc.
00:34:21 <jle`> so i guess i'm stuck for now
00:34:44 <phadej> jle`: yeah, those ae quite special
00:34:54 <cem__> what is concurrency as i know any point in time there is only one execution happens wont that make concurrency a drawback ?
00:35:49 <jle`> i'm not sure what you mean
00:36:00 <jle`> is "what is concurrency" your first question?
00:36:25 <jle`> and in a lot of situations, you can have multiple processes happening simultaneously on different CPU cores, or network nodes, etc.
00:36:46 <jle`> and in any case, even in a single-threaded system, structuring your program with concurrency can help you organize things in a more natural way
00:38:42 <gfixler> Simon Marlow talks about parallel vs concurrent at the start of this talk: https://www.youtube.com/watch?v=lqG3mURwUxo
00:38:50 <gfixler> clears it up quite nicely
00:40:47 <cem__> if any point in time if we could to 1 task what is point of having threading , a single thread can do the job better (assuming no multiple cores)
00:41:56 <gfixler> cem__: what if the tasks take a while, and you don't want one to wait all the way until another is done?
00:42:11 <gfixler> what if you need two things to work together across threads?
00:42:52 <JJJollyjim> Hey, why is there a function <**> that is <*> reversed, but no equivelent <$$> for <$>?
00:43:14 <phadej> <&>
00:43:15 <phadej> in lens
00:43:57 <JJJollyjim> Ahh cool
00:44:24 <JJJollyjim> Hmm, why did that not come up on Hoogle?
00:44:26 <quchen> JJJollyjim: <**> is not flipped <*>.
00:45:11 <phadej> JJJollyjim: use stackage hoogle http://haddock.stackage.org/lts-5.1/lens-4.13/Control-Lens-Lens.html#v:-60--38--62-
00:45:34 <phadej> (the hoogle search bar is on frontpage: https://www.stackage.org/)
00:45:37 <gfixler> lens is a huge dependency just for flipped fmap
00:46:06 <JJJollyjim> quchen: https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:-60--42--42--62-
00:46:11 <JJJollyjim> quchen: What is it then?
00:46:21 <phadej> gfixler: Haskell is a huge dependency just for a small utility tool ;)
00:46:58 <jle`> JJJollyjim: `fx <**> ff` exectues fx first, then ff
00:46:58 <phadej> JJJollyjim: it sequences effects in argument order still
00:46:59 <gfixler> phadej: been using it for quick maths stuff on Khan Academy :)
00:47:02 <quchen> JJJollyjim: `flip (<*>) a b` runs b's effects before running a's. `(<**>) a b` runs a's effects first.
00:47:51 <JJJollyjim> Ahh I see
00:47:53 <quchen> mf <*> mx = do { f <- mf; x <- mx; pure (f x) }        mx <**> mf = do { x <- mx; f <- mf; pure (f x) }
00:48:57 <JJJollyjim> I wanted it because I was chaining <$>'s and >>='s, and wanted it going in one direction, though I guess I could just use =<<
00:49:31 <quchen> Chaining <*> <$> and >>= isn't something you can write down nicely, unfortunately. :-|
00:50:10 <xd1le> anyone know how to open fifos in haskell? and write to them?
00:50:22 <xd1le> as in openFile does not seem to work
00:50:59 <gfixler> > (*2) <$> Just 3 >>= \x -> return [x] -- quchen 
00:51:01 <lambdabot>  Just [6]
00:51:03 <gfixler> no good?
00:51:38 <quchen> gfixler: It works in some cases, but you can't fmap on the RHS of a >>= for example
00:51:53 <quchen> There is no "right-flowing fmap" you can put into a >>= chain
00:52:00 <quchen> That's what I meant
00:59:36 * hackagebot hlint 1.9.28 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.28 (NeilMitchell)
01:12:56 <cem__> gfixler for example uploading image takes a lot of time so threads can be used there ? how will it makes faster (single core)
01:21:38 <cem__> well i dont understand multi threading
01:27:19 <ahihi> cem__: a good example of why concurrency is useful even on a single core is basically any app that has an interactive UI and may perform lengthy operations
01:27:50 <ahihi> cem__: if you do everything in the same thread, a lengthy operation will cause the UI to be unresponsive for its entire duration
01:31:40 <jle`> hi all
01:31:49 <jle`> shouldn't SomeNat have a Num instance?
01:32:09 <jle`> analogous to Natural's Num instance>
01:32:11 <jle`> ?
01:32:46 <jle`> this should happen
01:33:45 <jle`> i'm going to make this happen
01:35:15 <MarcelineVQ> you madman
01:38:51 <dramforever> Question: I'm trying to use ghc-mod in a stack-based project. stack wants Cabal 1.22.7.0, but ghc-mod wants 1.22.4.0. What can I do to fix this?
01:38:52 <dramforever> well, lts-5.1 wants Cabal 1.22.7.0
01:38:52 <dramforever> Looks like nobody else is having this problem..
01:41:49 <kadoban> dramforever: Why would it matter what version of Cabal stack uses? (AFAIK it doesn't)
01:41:50 <pavonia> Is there a function to convert a Rational to a String, representing the corresponding floating point number at full precision?
01:42:26 <kadoban> pavonia: 1 % 3 outputs what?
01:42:47 <pavonia> "0.3333..."
01:43:10 <kadoban> pavonia: Well, what is "full precision" there? Or you mean literally the ellipsis there?
01:43:37 <pavonia> No, I mean an infinte string
01:44:02 <kadoban> Ah
01:44:53 <zipper> Is anyone familiar with the error `"ghc-pkg" is required but could not be found` ?
01:45:25 * hackagebot BNFC 2.8.1 - A compiler front-end generator.  https://hackage.haskell.org/package/BNFC-2.8.1 (GregoireDetrez)
01:46:16 <zipper> Oh nvm ghc-pkg is supposed to come with ghc
01:46:45 <zipper> ghc isn't installed? What?
01:47:15 <pavonia> zipper: When do you encounter that error?
01:47:45 <zipper> pavonia: No it's just that I installed ghc via stack. So now no program can find it.
01:48:05 <zipper> Which is the preferable way to have user wide ghc and it's related binaries?
01:49:08 <dramforever> kadoban: Not really, but ghc-mod insists on 1.22.4.0 (sorry, was AFK for a while)
01:49:18 <dramforever> lemme give you a log
01:50:09 <lpaste> dramforever pasted ‚Äústack exec ghc-modi‚Äù at http://lpaste.net/151655
01:50:37 <dramforever> This just... can't be right, you know
01:57:16 <kadoban> dramforever: That doesn't seem to be ghc-mod or stack wanting something, that seems to be ‚Ä¶ some deprecated thing that's installing ghc-mod for you? I don't understand.
01:59:01 <dramforever> kadoban: Nah, same thing for ghc-mod legacy-interactive
01:59:40 <kadoban> dramforever: What are you actually running, what command?
02:00:22 <dramforever> Hmm... Just did stack exec cabal update and the problem went away completely
02:01:35 <kadoban> dramforever: If that's true, I suspect you're not actually using stack to do whatever it is you're doing, you seem to be using cabal-install for it, otherwise I have no idea why that'd have any effect.
02:02:34 <dramforever> kadoban: I tried both "ghc-modi" and "ghc-mod legacy-interactive", and also using atom with haskell-ghc-mod. They all complained about installing Cabal-1.22.4.0
02:02:34 <dramforever> but now I can't reproduce it anymore. Sort of a good thing actually
02:03:24 <MarcelineVQ> kadoban: ghc-mod has strange cabal-helper things it does sometimes :X
02:04:04 <BernhardPosselt> hi ive got a datastructure A which holds a list of things B and i need to pair it together using (A, B), whats the best approach?
02:04:19 <BernhardPosselt> thought of a flatmap but then i lose A
02:04:37 <MarcelineVQ> I think sometimes there's an issue when your project's lts differs from the lts version used to build ghc-mod, but I don't think I've run into that
02:04:56 <dramforever> kadoban: Perhaps, I had been using system-ghc: true (it's 7.10.2) for a while when I started using stack, because amazon s3 is slow to nonsense here in China
02:05:10 <kadoban> I believe there's an issue when the versions of GHC differ, but I'm not sure.
02:05:25 <frerich_> BernhardPosselt: Not sure I understand, but couldn't you run 'map (\x -> (a, x)' on your list where 'a' is of type 'A'?
02:05:56 <dramforever> BernhardPosselt: Where do you get the B from?
02:06:18 <BernhardPosselt> A holds a list of B dramforever
02:06:26 <dramforever> Just... can you give more details? 
02:06:26 <BernhardPosselt> frerich_: right, and just flatmap that 
02:06:45 <frerich_> BernhardPosselt: What does 'flatmap' mean? :-]
02:06:53 <BernhardPosselt> frerich_: concatMap
02:06:56 <BernhardPosselt> :D
02:07:08 <dramforever> To me, that's too vague to figure out anything...
02:07:21 <frerich> BernhardPosselt: So you actually have a list of lists?
02:07:26 <BernhardPosselt> yes
02:07:41 <dramforever> > let theA = [1,2,3,4,5] in map (\x -> (theA, x)) theA
02:07:43 <lambdabot>  [([1,2,3,4,5],1),([1,2,3,4,5],2),([1,2,3,4,5],3),([1,2,3,4,5],4),([1,2,3,4,5...
02:07:55 <dramforever> this?
02:08:30 <BernhardPosselt> yes
02:09:05 <dramforever> "And just flatmap that"?
02:09:09 <BernhardPosselt> and i need to reduce it to a list which consists of a pair e.g. the first list item would become [(1, 1), (1, 2) ‚Ä¶
02:09:10 <frerich> BernhardPosselt: I don't see how a "flatmap" loses 'A'. Maybe paste some code to illustrate your issue at lpaste.net -- it seems to me there's a lot of guessing going on.
02:10:29 <dramforever> > let theA = [1,2,3] in liftA2 (,) theA theA -- this? (going to be AFK for a while, sorry)
02:10:31 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
02:10:47 <BernhardPosselt> dramforever: exactly
02:20:44 <dramforever> > let theA = [1,2,3] in liftA2 (,) theA theA -- this? (going to be AFK for a while, sorry)
02:20:46 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
02:21:08 <dramforever> uh, sorry, didn't mean that...
02:22:30 <zipper> Hey could someone do me a favour and paste me their ~/.stack/global/ 's cabal file?
02:23:01 <zipper> I keep getting this error "No .cabal file found in directory ~/.stack/global/"
02:23:15 <mchall> I have to replicate the function allCombs :: (a -> b -> c) -> [a] -> [b] -> [c] allCombs _ [] _ = [] allCombs f (x:xs) lst = map (\y -> f x y) lst ++ allCombs f xs lst  in terms of the function combStep :: [a -> b] -> [a] -> [b] combStep flst lst  = zipWith  (\f l -> f l) flst lst   
02:23:37 <zipper> This is when I run stack install outside of a haskell prject dir
02:23:39 <mchall> this is part of the monad challenge with a custom prelude
02:24:23 <dramforever> ~/.stack/global/ isn't a thing, AFAIK
02:24:40 <liste> there's ~/.stack/global-project/ on my machine
02:24:47 <zipper> dramforever: What do you mean it's not a thing?
02:24:55 <liste> it just contains a README and a stack.yaml
02:25:11 <dramforever> zipper: that directory doesn't exist at all
02:25:12 <zipper> well the error I am getting is very real
02:25:19 <ahihi> mine is called ~/.stack/global, but there's no cabal file in it
02:25:21 <mchall> how do I  use combStep which only has an a -> b when I need have an a->b->c ?
02:25:23 <zipper> dramforever: It exists for me and is giving me errors.
02:25:53 <dramforever> No more suggestions :(
02:26:23 <RaceCondition> if there was a `Set a` such that it contained all elements of type `a`, sets could form a Monoid under intersection -- is this a new idea?
02:26:46 <zipper> dramforever: Okay I deleted my whole ~/.stack and then ran stack update
02:27:06 <zipper> Then `stack --resolver lts-5.1 install ...`
02:27:07 <frerich> mchall: Note that 'a -> b' can be made to match ("unified" is what people often call it) 'x -> y -> z' if you set 'a ~ x' and 'b ~ (y -> z)'.
02:27:16 <frerich> mchall: 'a -> b -> c' is the same as 'a -> (b -> c)'.
02:27:35 <zipper> Seems to be going fine and now opting for liste's global-project/ die
02:27:37 <zipper> *dir
02:36:46 <ReinH> RaceCondition: There is already a Monoid instance for Set a
02:37:10 <dramforever> RaceCondition: Easier: An s :: NonSet a is a set whose underlying representation Set a contains all elements *not* in s
02:37:12 <RaceCondition> ReinH, I was explicitly asking about Monoid under intersection; I know about the one under union
02:38:15 <RaceCondition> dramforever, and that produces a monoid over sets under intersection?
02:38:25 <phadej> under union
02:38:43 <dramforever> If you think about it that way :)
02:39:00 <dramforever> RaceCondition: For most types the "set containing all values of the set" is infeasible
02:39:02 <RaceCondition> dramforever, is phadej's comment relevant/correct?
02:39:29 <dramforever> yes, that's how you do it on the underlying representation
02:39:32 <ReinH> You can also use the usual trick of adjoining an identity element onto the set intersection semigroup.
02:39:33 <RaceCondition> dramforever, well yes but I think it's easy to abstract: MySet = Elems (Set a) | All
02:39:49 <dramforever> actually you need not do anything about it, just use Set a for a set of excluded elements
02:39:52 <ReinH> Yes, that's the trick.
02:40:35 <dramforever> RaceCondition, ReinH: ooh sweet :)
02:40:40 <phadej> ReinH: but then you have two representations for full set, e.g. Elems (fromList ()) and All
02:40:58 <phadej> it might be a problem, or might not
02:41:02 <dramforever> TIL semigroup -> monoid rocks
02:43:14 <co-dan> Right, it's the same issue with the Maybe semigroup instance
02:43:50 <co-dan> Maybe (Set a) <- there is the identity Nothing, but also for some `a' we might have things that should be identities inside Just
02:45:20 <ReinH> You mean the Maybe Monoid instance, I suppose.
02:46:39 <mniip> hmm
02:48:27 <RaceCondition> dramforever, did you mean MySet a = NotElem a | All?
02:49:00 <RaceCondition> or InverseSet or smth
02:49:06 <co-dan> ReinH yes indeed
02:49:09 <RaceCondition> ...then I'm wondering how I can go between Set and InverseSet
02:49:33 <RaceCondition> I have an algorithm that would work nicely with such InverseSet, but the real life input data is still a Set of course
02:49:33 <ReinH> RaceCondition: generally speaking, you can't
02:49:47 <RaceCondition> nothing practical but I got stuck thinking about it
02:50:38 * hackagebot yoctoparsec 0.1.0.0 - A truly tiny monadic parsing library  https://hackage.haskell.org/package/yoctoparsec-0.1.0.0 (mniip)
02:50:45 <mniip> welp there it goes
02:50:51 <mniip> a package with 3 lines of code :D
02:52:52 <co-dan> mniip: nice!
02:55:13 <tomus> > ($ 10) <$> [(+), (-)] <*> [1]
02:55:14 <lambdabot>  [11,9]
02:55:29 <tomus> let's a complicated plus/minus operation
02:58:17 <mniip> > fmap ($ 1) $ fmap ($ 10) [(+), (-)]
02:58:18 <lambdabot>  [11,9]
03:00:19 <tomus> >map ($ 1) $ map ($ 10) [(+), (-)]
03:00:28 <tomus> > map ($ 1) $ map ($ 10) [(+), (-)]
03:00:30 <lambdabot>  [11,9]
03:00:38 <tomus> ok, that's more intuitive I suppose
03:01:17 <jle`> > [(+),(1)] <*> [10] <*> [1]  -- tomus 
03:01:18 <lambdabot>      No instance for (Show b0)
03:01:19 <lambdabot>        arising from a use of ‚Äòshow_M739021225253757753328536‚Äô
03:01:19 <lambdabot>      The type variable ‚Äòb0‚Äô is ambiguous
03:01:23 <bernalex> that's a bit redundant
03:01:27 <jle`> > [(+),(-)] <*> [10] <*> [1]
03:01:28 <lambdabot>  [11,9]
03:01:54 <tomus> yes
03:01:57 <tomus> that's what I was looking for
03:01:59 <bernalex> that's nicer.
03:02:02 <mniip> hey jle`
03:02:05 <jle`> hi mniip 
03:02:05 <mniip> I made a package \o/
03:02:09 <jle`>  \o/
03:02:25 <jle`> link me before i go to bed :)
03:02:29 <mniip> http://hackage.haskell.org/package/yoctoparsec
03:02:38 <bernalex> tomus: FFR: map f . map g = map (f . g)
03:02:59 <jle`> ty!
03:04:29 <tomus> now it's all very nice but I am using interactive R where I wrote "(function(x, e){c(x-e, x+e)})(15.39, qnorm(0.975) * sqrt(0.107))" and then thought about how I would do it in Haskell :/
03:11:43 <EvanR> mniip: bold
03:11:54 <mniip> italics?
03:12:27 <EvanR> yocto is at the very bottom, no place else lower to go ;)
03:13:39 <mniip> well
03:13:52 <mniip> you try coming up with something an order of magnitude smaller :)
03:15:39 <mniip> I suppose if there already was a package embedding FreeT (ReaderT ...) in a profunctor/category
03:15:50 <mniip> then I could get rid of 'token' because that's just 'id'
03:15:55 <dramforever> EvanR: nothing in between, though
03:16:09 * hackagebot werewolf 0.4.1.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.1.1 (hjwylde)
03:16:11 * hackagebot werewolf 0.4.2.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.2.1 (hjwylde)
03:16:12 <mniip> dramforever, zepto?
03:16:13 * hackagebot werewolf 0.4.3.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.3.0 (hjwylde)
03:17:09 <dramforever> mniip: Ah exactly, I got it wrong ;)
03:18:09 <dramforever> anyway I don't think it could go much smaller than that, but I wouldn't be surprised if some zyhoistwhatever ekmett package actually gives rise to a parser
03:24:26 <barrucadu> mniip: Woah, I see three whole lines of actual code there. The bloat!
03:25:08 <EvanR> confirmed bloated
03:25:48 <Gurkenglas> mniip, you coulda used $ in parseString!
03:34:13 <Gurkenglas> :t ala StateT (Control.Monad.Trans.Free.iterTM . (>>=) . ($ ?next)) -- hmmmm
03:34:14 <lambdabot> (Monad m', ?next::s' -> m' (a', s')) => Control.Monad.Trans.Free.FreeT ((->) a') m' a'1 -> s' -> m' (a'1, s')
03:36:09 * hackagebot ghc-typelits-natnormalise 0.4.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.4.1 (ChristiaanBaaij)
03:36:53 <Gurkenglas> Because not enough lens dependency
03:41:21 * hackagebot SimpleServer 0.1.1.0 - A simple static file server, for when apache is overkill  https://hackage.haskell.org/package/SimpleServer-0.1.1.0 (AnupamJain)
03:41:59 <mniip> haha
03:43:00 <mtesseract> hi
03:43:55 <Guest97851> hi
03:44:16 <mniip> Gurkenglas, I wonder if I can implement composition without patternmatching Free/Pure by hand
03:44:36 <mniip> Parser b x y -> Parser b y z -> Parser b x z, that is
03:44:46 <mniip> fsvo b
03:45:39 <lpaste> Guest97851 pasted ‚ÄúNo title‚Äù at http://lpaste.net/151659
03:45:56 <Guest97851> can you plese tell me why this gives error : parsers.hs:27:19: parse error on input ë<-í
03:47:15 <saurabhnanda> okay, my brain is completely fried dealing with Aeson and its API. How do I "run" a Parser object?
03:47:35 <danza> Guest97851: because you have a random `item` in its own line?
03:47:42 <saurabhnanda> why does .: give me back a (Parser a) monad (?) and not the final object/value?
03:47:46 <frerich> Guest97851: Err, those increasing/decreasing line numbers are somewhat irritating. Which of those is line 27? :-}
03:48:08 <Guest97851> y<- item
03:48:09 <{AS}> Guest97851: Do you have any tabs in your code?
03:48:14 <Guest97851> yes
03:48:32 <{AS}> That might be an issue
03:48:37 <frerich> danza: That's actually ok (it just discards the extracted item, i.e. it's equivalent to '_ <- item')
03:48:39 <Guest97851> I write C so I use tabs everyhere in my tools
03:48:46 <Guest97851> should I convert all to spaces ?
03:48:52 <danza> yeah
03:48:58 <Guest97851> thx
03:49:05 <puregreen> saurabhnanda: you can run a Parser object by using http://hackage.haskell.org/package/aeson/docs/Data-Aeson-Types.html#v:parseMaybe. However, I wonder: what do you need it for?
03:49:07 <{AS}> Guest97851: My guess would be that there is some misalignment :)
03:49:18 <danza> thanks frerich 
03:49:58 <dramforever> Guest97851: Basically in C you indent stuff, so you use tabs
03:50:07 <dramforever> in Haskell you line up stuff, so you use spaces
03:50:11 <Guest97851> k
03:50:14 <Guest97851> thx
03:50:36 <dramforever> you're welcome
03:50:39 <danza> dramforever: never thought if it this way :)
03:50:45 <mniip> but you can line up stuff with tabs :(
03:50:47 <danza> *of it*
03:50:49 <Guest97851> and that random item ... I follow Meijer;s C9 videos
03:51:01 <Guest97851> he said its ok to have item that way
03:51:15 <danza> yep frerich explained above
03:51:21 * hackagebot SimpleServer 0.1.1.1 - A simple static file server, for when apache is overkill  https://hackage.haskell.org/package/SimpleServer-0.1.1.1 (AnupamJain)
03:51:23 * hackagebot sexp-grammar 1.1.1 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.1.1 (SergeyVinokurov)
03:51:40 <dramforever> mniip: you can't, not everyone uses the same tabstops
03:51:48 <mniip> yes you can
03:51:55 <mniip> you write ts-agnostic layouts
03:51:57 <dramforever> ...
03:52:11 <mniip> that's what I always do
03:52:42 <dramforever> But obviously that code is not ts-agnostic, and it really trips people up
03:53:04 <mniip> that code sure isn't
03:53:06 <dramforever> and stop stop, no use discussing stuffs that don't really matter, as long as it work
03:53:14 <dramforever> *works
03:53:31 <mniip> :(
03:55:54 <Guest97851> thanks,  renouncing tabs fxed the compilation 
03:55:58 <Guest97851> I repent :P
03:55:59 <Guest97851> haha
04:46:06 <fizruk> what does this error mean? http://lpaste.net/6917606096534241280
04:46:22 <fizruk> why is b untouchable?
04:50:11 * frerich tries hard to sing "Can't touch this"
04:50:19 <frerich> NOT to sing.
04:57:07 <fizruk> no clues? :(
04:59:36 <`Guest00000> hello. at start, ghci shows "Prelude> " prompt. has it been proposed at least once to add something like "[ghci]" to the prompt (so it looks: "[ghci] Prelude> ")? i have met at least one person who mistakenly called the interpreter Prelude
05:00:46 <zipper> Hey say I have a function say foo, where foo :: ... (Str -> IO ()) -> IO () As you can see what I am interested in is the last argument to foo. 
05:01:20 <zipper> So I want to write that function which is foo's last argument such that the string is printed to the browser.
05:02:08 <zipper> The issue is that foo runs the last argument severally so I want to be able to print all the results in the browser at any one time. What can I do?
05:02:22 <zipper> Like showing logs or progress in the browser.
05:02:56 <zipper> Currently I am using print but print isn't what I want because I want to show it on the browser. What can I do?
05:03:03 <pavonia> `Guest00000: You change it with ":set promt" if you're not satisfied with that
05:03:11 <pavonia> *prompt
05:03:49 <`Guest00000> pavonia: i know that. i am talking about changing default prompt, so that people don't conflate Prelude with the interpreter
05:07:35 <phadej> fizruk: it does work in not-ghci
05:09:05 <pavonia> not-ghci = ghc?
05:09:10 <phadej> http://lpaste.net/151666
05:09:30 <phadej> pavonia: yes
05:09:49 <Guest97851> in a do block, lazy evaluation applys ?
05:10:50 <johnsonSteward> can i use empty lines in do blocks?
05:10:59 <sbrg> johnsonSteward: sure
05:11:00 <phadej> Guest97851: do block is just a syntax sugar
05:11:22 <fizruk> phadej: hmm, interesting
05:11:35 <fizruk> phadej: why do you need ScopedTypeVariables?
05:12:40 <johnsonSteward> but.. my vim script refuses to indent things under do block if it contains do blocks
05:12:47 <johnsonSteward> sorry, empty lines
05:12:59 <fizruk> phadej: doesn't work for me, which GHC are you using?
05:13:59 <pavonia> johnsonSteward: It's legal syntax, so there's something wrong with the script apparently
05:14:05 <lpaste> Guest97851 pasted ‚ÄúNo title‚Äù at http://lpaste.net/151668
05:14:13 <Guest97851> phadej, yeah but
05:14:26 <Guest97851> Im folowing C9 lectures by Meijer
05:14:35 <Guest97851> look at the naked item
05:14:45 <johnsonSteward> pavonia: i'm using haskell-vim, anything better to suggest?
05:14:51 <Guest97851> its never used but it seems it consumes from inout
05:15:25 <pavonia> johnsonSteward: No sorry, I've never used vim
05:15:38 <hexagoxel> fizruk, phadej: it works on ghc-7.8.4, but not anything else, apparently.
05:16:11 <hexagoxel> (i.e. not 7.10 or 8.0)
05:16:28 <fizruk> probably because it shouldn't work
05:16:43 <hexagoxel> agreed
05:16:56 <pavonia> Guest97851: The result is discarded, but it's evaluated anyway. In do-blocks, all actions are evaluated in order
05:17:09 <Guest97851> i see
05:17:32 <Guest97851> thank you
05:21:23 * hackagebot graph-core 0.3.0.0 - Fast, memory efficient and persistent graph implementation  https://hackage.haskell.org/package/graph-core-0.3.0.0 (AlexanderThiemann)
05:23:05 <phadej> fizruk: will, with AllowAmbigiousTypes it works
05:23:09 <phadej> on ghc 8
05:23:45 <{AS}> johnsonSteward: Have you looked at https://github.com/neovimhaskell?
05:23:52 <phadej> fizruk: and then you can say {-# LANGUAGE RankNTypes, ConstraintKinds, ScopedTypeVariables #-}
05:23:54 <hexagoxel> fizruk: but i don't understand what you are actually trying to do. `b` only occurs in the constraint, which does not seem to make much sense.
05:23:55 <phadej> import Data.Proxy
05:23:58 <phadej> f :: (a => b) -> Proxy a
05:24:07 <fizruk> phadej: right, but it still won't work for anything like (f show) to extract the Show constraint
05:24:13 <mchall> can someone please tell me of a good resource to learn about unification please
05:24:31 <hexagoxel> fizruk: you don't need the `b` either, just `f :: forall (a :: Constraint) . Proxy a; f = Proxy`
05:24:35 <phadej> fizruk: kind of
05:24:56 <phadej> fizruk: f show :: Show Int works for example
05:25:01 <{AS}> johnsonSteward: Oh it got deprecated. Take a look at https://github.com/eagletmt/neco-ghc and https://github.com/Shougo/deoplete.nvim instead as suggested :)
05:25:39 <fizruk> hexagoxel: phadej: what I was trying to do is to remove the first argument of props here: http://haskell-servant.github.io/servant-swagger/haddock/Servant-Swagger-Internal-Test.html#v:props
05:25:49 <phadej> chicken-egg problem, you need Proxy somewhere to make stuff unabigious, but if you have one then you don't need that function :)
05:26:28 <fizruk> hexagoxel: phadej: my idea was that I have to be able to extract constraints of the property to apply them to the types in a type-level list automatically
05:26:44 <fizruk> hexagoxel: phadej: without writing them down
05:27:13 <fizruk> hexagoxel: phadej: essentially, I was trying to remove "(Proxy :: Proxy [Eq, Show, Read])" from that example
05:29:52 <{AS}> johnsonSteward: Or I guess only the completion is abandoned, but not the case splitting, refinement, etc.
05:30:35 <phadej> fizruk: if GHC cannot unify cs here and there (and probably cannot), then you have to provide proxy (i.e. explicitly state the type in call site)
05:31:11 <fizruk> phadej: seems like that's the case here, unfortunately
05:31:31 <phadej> also i'd guess that ghc won't even try too hard to unify universally quantiied stuff
05:32:08 <phadej> e.g. it would default to (Eq (), Show (), Read ()) at it's best and not to (Eq :&: Show :&: Read)
05:35:06 <phadej> fizruk: tangentually, check {-# LANGUAGE RankNTypes, ConstraintKinds, ScopedTypeVariables #-}
05:35:09 <phadej> import Data.Proxy
05:35:10 <phadej> √§h
05:35:12 <phadej> f :: (a => b) -> Proxy a
05:35:21 <phadej> fizruk: seems you are doing quite a magical stuff on typelevel
05:36:07 <phadej> fizruk: Every looks like All from generics-sop
05:36:35 <phadej> wait, it isn't
05:37:48 <fizruk> phadej: All has a list of types, Every has a list of constraint constructors
05:38:00 <fizruk> but they are very similar, yes
05:41:41 <phadej> fizruk: the need for library for type-level mangling starts to be huge
05:41:52 <fizruk> agreed
05:42:13 <phadej> (lists mangling especially)
05:42:59 <fizruk> there's https://hackage.haskell.org/package/type-list-0.3.0.2/docs/Data-Type-List.html
05:43:29 <fizruk> it's entirely on the type-level though
05:43:37 <fizruk> what I need is going from types to values
05:44:04 <phadej> fizruk: yes, I have seen that too
05:45:35 <phadej> fizruk: yet it doesn't work for all cases even on type level
05:45:41 <phadej> had to roll https://github.com/futurice/haskell-haxl-typed/blob/935f7f1998e9221cf8e2c8d12668a6befa2d6ca0/src/Haxl/Typed.hs#L88-L95
05:45:44 <phadej> in addition
05:49:05 <sbrg> anyone here happen to have worked with both scala and haskell professionally that would like to share their thoughts? How did the pros and cons of both compare and so on? I know this is a pretty vague question, but I'm basically just looking for anything.
05:50:50 <phadej> sbrg: personally, Scala after Haskell is annoying
05:52:23 <phadej> the only scala pros is the jvm and java interop, but that's also one of the cons :)
05:52:43 <fizruk> phadej: that fact that you generally need both a (k -> Bool) and (k -> Constraint) is a bit annoying
05:52:58 <sbrg> yeah. i'm starting a full-stack dev job with scala on both ends and the compile times are atrocious, as is the memory usage
05:53:09 <ahihi> I work with scala (but not haskell, yet‚Ä¶) and tend to miss haskell for its nicer APIs and more explicit effects
05:53:22 <sbrg> i've been writing Haskell for ~7 years or something but not really in a professional capacity
05:54:05 <sbrg> but thankfully the company is open to exploring haskell solutions as well. we just have to find the time and the right project.
05:54:18 <phadej> fizruk: maybe 'IsTrue con = con ~ True` would do it :)
05:54:36 <bergmark> i think the major difference with haskell vs most other languages is that it's actually principled and you can offload a lot of paranoia to the compiler. in most other languages anything can crash at any point, mostly because of nulls
05:54:55 <maerwald> bergmark: really depends on the language
05:55:06 <ahihi> scala mostly doesn't have nulls, until you touch java libraries
05:55:07 <maerwald> haskell is not the only pioneer here
05:55:35 <phadej> fizruk: there's plenty of design space to explore, still. It's good that servant and generics-sop and xyz are pusing boundaries, so we'll settle for something which works for everyone
05:55:43 <bergmark> of course it depends on the language, we are talking about languages aren't we?
05:55:45 <wmealing> take the erlang approach, who cares if its going to break, plan for failure.
05:55:47 <sbrg> ahihi: yes. That is what I understand is one of the biggest warts in Scala.. the forced java compatibility which means in some cases type-safety is just thrown out the window
05:56:24 * hackagebot haskore 0.2.0.8 - The Haskore Computer Music System  https://hackage.haskell.org/package/haskore-0.2.0.8 (HenningThielemann)
05:57:03 <fizruk> phadej: I would really love to see promoted functions and first-class types in Haskell, I think most of the type-level stuff can be eliminated if we just could promote functions from Prelude
05:57:21 <fizruk> phadej: but maybe that's another language I am dreaming about :)
05:57:29 <phadej> fizruk: well, you can do it by hand now already
05:58:27 <fizruk> phadej: yeah, for type-to-type, type-to-term, term-to-type... too much code duplication it seems
05:58:41 <EvanR> theres no term to type
05:58:42 <fizruk> phadej: better that nothing though
05:59:07 <EvanR> automatically at least
06:00:04 <fizruk> EvanR: well, sort of. that's one of the most difficult parts in dependent programming I think
06:00:06 <wmealing> is there a haskell equivalent to rebar or leiningen
06:00:07 <phadej> fizruk: well, singletons package does it (well, not for *) with TH
06:00:22 <phadej> wmealing: cabal
06:01:37 <phadej> but e.g. list manipulating stuff can be done PolyKinded, and probably should be
06:04:21 <phadej> fizruk: btw your (a => b) cannot relly work, as > :t toEnum 0 ::  () => () => Enum a => a
06:04:56 <wmealing> phadej: it looks more geared towards package management than either rebar or lein‚Ä¶ unless i'm reading the docs wrong
06:05:06 <fizruk> phadej: yes, I thought about a similar example :)
06:05:38 <fizruk> wmealing: try stack: http://docs.haskellstack.org/en/stable/README.html
06:06:29 <wmealing> fizruk: that may be closer.
06:06:30 <phadej> wmealing: cabal-install is a build tool, package management is only small part of it (similarly as lein uses maven)
06:06:59 <phadej> (and with stack you still need to know cabal package description format)
06:07:28 <phadej> shortly: cabal describes and builds packages, but doesn't really manage them
06:08:54 <wmealing> so in the haskell world, what else does cabal do to help me with the project ?
06:09:30 <phadej> what you mean?
06:09:53 <phadej> if you seek for something like "lein outdated" then there are similar tools for that too (packdeps in this case)
06:10:23 <wmealing> downloading and creating packages i think is a solved problem
06:10:29 <mchall> Any body who is near Cambridge England tomorrow there is a talk at the University "Effects as sessions, sessions as effects"  " The embedding of session types into an effect system is leveraged to give a new implementation of session types in Haskell, via an effect system encoding. "http://talks.cam.ac.uk/talk/index/62549
06:10:29 <wmealing> here is the output of lein
06:10:30 <wmealing> http://hastebin.com/berasocasa.lua
06:10:58 <wmealing> for example lein new, <template> , lein repl (starts a repl in the project namespace) lein clean..
06:11:08 <wmealing> i'm sure you can read
06:11:30 <phadej> cabal can repl
06:11:56 <phadej> cabal can download (and install) your dependencies (yet at this point you probably want to try stack)
06:12:01 <phadej> stack has templates
06:12:23 <Ankhers> cabal can only repl when using sandboxes.
06:12:25 <phadej> I'd like to be able to give short answer, but it's quite hard
06:12:27 <fizruk> wmealing: stack new, stack ghci, stack clean...
06:12:44 <phadej> the problem with stack, is that you still need to know cabal
06:12:50 <phadej> at least a bit
06:13:05 <fizruk> only Cabal format, no?
06:13:12 <wmealing> phadej: i'm not expecting 0 knowledge solutions, i'm willing to get my hands dirty.
06:13:37 <phadej> not as bad as with lein you *might* need to get dirty with maven
06:13:45 <phadej> fizruk: yeah.
06:13:45 <wmealing> oh god, the nightmares
06:13:46 <wmealing> dont remind me
06:13:59 <fizruk> wmealing: you should go through the Stack readme, I think it covers most basic workflows
06:14:02 <wmealing> fizruk: i'm going to look into that.. not sure how to get it yet‚Ä¶ but its on my list
06:14:13 <mchall> Could someone please show me how to do the following I have a function allCombs :: (a -> b -> c) -> [a] -> [b] -> [c] that I need to implement in terms of combStep :: [a -> b] -> [a] -> [b] combStep flst lst  = zipWith  (\f l -> f l) flst lst 
06:14:16 <phadej> wmealing: http://docs.haskellstack.org/en/stable/README.html
06:14:18 <wmealing> fizruk: got it open
06:14:35 <fizruk> wmealing: there are also instructions on how to get it for many platforms
06:14:43 * wmealing nods
06:15:08 <mchall> I've been told this is known as unification could someone please show me some code as to how this is achieved please
06:18:17 <srhb> mchall: I think you misunderstood something with respect to what unification is.
06:19:39 <srhb> mchall: The point was that if you have a type (a -> z), then if z ~ (b -> c), (a -> z) ~ (a -> b -> c)
06:19:49 <srhb> Read ~ as "equals" (for types)
06:26:08 <Ankhers> mchall: What have you tried for the definition of allCombs?
06:28:56 <lingxiao> anyone want to answer a few questions for me at #coq?
06:31:25 * hackagebot rest-core 0.38 - Rest API library.  https://hackage.haskell.org/package/rest-core-0.38 (AdamBergmark)
06:31:28 * hackagebot rest-gen 0.19.0.2 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.19.0.2 (AdamBergmark)
06:33:36 <zd234> is there a haskell builtin for Int -> Char? (basically just reading off ascii code)
06:34:24 <bergmark> > chr 85
06:34:25 <lambdabot>  'U'
06:35:01 <sbrg> there's also the dual ord
06:35:07 <sbrg> > ord 'U√∞
06:35:08 <lambdabot>      Syntax error on 'U√∞
06:35:08 <lambdabot>      Perhaps you intended to use TemplateHaskell
06:35:08 <lambdabot>      In the Template Haskell quotation 'U√∞
06:35:10 <sbrg> > ord 'U'
06:35:12 <lambdabot>  85
06:37:31 <zd234> Data.Char.chr
06:37:34 <zd234> cool, thanks!
06:37:46 <srhb> @hoogle Int -> Char
06:37:48 <lambdabot> Data.Char chr :: Int -> Char
06:37:49 <lambdabot> Data.Char intToDigit :: Int -> Char
06:37:49 <lambdabot> Data.Text.Internal.Builder.Functions i2d :: Int -> Char
06:37:53 <srhb> zd234: ^ useful
06:38:09 <srhb> zd234: If you know the type, but not the name. Especially the stackage hosted Hoogle is quite big. :)
06:38:41 <srhb> zd234: Mind, almost nothing is "builtin" -- but this particular module is in the base package.
06:38:44 <zd234> where is the srhb stackage hoogle ?
06:38:54 <zd234> https://www.stackage.org/lts-5.1/hoogle?q=%s ?
06:39:03 <zd234> oh shit, that searches all of stackage?
06:39:04 <zd234> I like
06:39:24 <srhb> zd234: Yes. :)
06:39:30 <srhb> zd234: And type searches are pretty nifty.
06:39:44 <srhb> zd234: Mind, it only searches the specific resolver (lts 5.1 in this case)
06:50:53 <black0range> Hey, when making some kind of simple string parser for example a String -> Maybe HTTPMethod function
06:51:26 * hackagebot servant-swagger 1.0 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.0 (NickolayKudasov)
06:51:58 <black0range> whats the most effective way? If i make a hashmap would it be constructed every time? or does for ex: f "POST" = Just Post; f "GET" = Just GET get optimized somehow? 
06:52:16 <sm> \o/ go fizruk
06:52:56 <fizruk> sm: \o/
06:53:25 <quchen> black0range: If efficiency is what you want, String is not the right type. https://github.com/quchen/articles/blob/master/fbut.md#string
06:53:42 <fizruk> so what's the latest way of uploading docs to hackage?
06:54:11 <black0range> quchen: I know :) I'm just wondering about the matching method itself 
06:54:20 <cmotoche> Hello everyone. I just installed GHC using stack. Although, I need to use cabal for testing a project that has a cabal.config file. The problem is that I can't do "cabal test", since it doesn't find GHC. This is the error message:
06:54:25 <cmotoche> cabal: The program 'ghc' version >=6.4 is required but it could not be found.
06:54:51 <cmotoche> Do you now how could I solve this?
06:54:54 <sm> fizruk: they're supposed to build automatically most of the time, a while after uploading
06:54:56 <fizruk> stack exec cabal test?
06:55:37 <fizruk> sm: swagger2 docs are pending for almost a day...
06:55:48 <sm> ah
06:57:38 <cmotoche> thanks fizruk, that almost work. Now, I get another error. He, he. cabal: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with
06:57:38 <cmotoche> Cabal. Use the flag --package-db to specify a package database (it can be used
06:57:38 <cmotoche> multiple times).
06:58:01 <cmotoche> I'll try to solve it. Thanks
06:58:47 <fizruk> cmotoche: probably stack exec was not a good idea, you might want to put GHC in PATH instead
06:59:43 <fizruk> cmotoche: maybe something like "stack setup --install-ghc" is what you want
07:00:32 <cmotoche> Ok, fizruk. I'll try it. Thank you.
07:10:23 <cmotoche> Yes, fizruk adding ghc to PATH worked perfectly. Thanks.
07:10:27 <mchall> srhb thanks for telling me that ~ is equal for types
07:17:20 <srhb> mchall: I suppose that means that I didn't explain the rest very well. :-)
07:18:00 <mchall> srhb no it means I'm a noob and I'm trying to solve this :)
07:18:42 <srhb> mchall: That's fine. I was hoping it'd lead you on the right path though. I think it would really help you if you rename one of the `b`s to something else.
07:19:40 <mchall> srhb yes its from the monad challenges and it is exposing my missing knowledge 
07:22:15 <srhb> mchall: Are you still stuck with it?
07:23:04 <mchall> srhb can i pass in an anonymous function like this [(\x -> x + 2)] ?
07:24:02 <srhb> mchall: You can, but it certainly won't have the type you requested.
07:24:36 <mchall> srhb  how do I arrange it to get the right type back ?
07:25:03 <srhb> mchall: Can you elaborate on what you mean exactly? Arrange it?
07:26:00 <mchall> srhb how do I get the right types so that I end up with a c
07:26:19 <srhb> Well you can't possibly use '2' for sure.
07:27:52 <Ankhers> srhb, mchall: I apologize for butting in, but maybe trying to use typed holes would be beneficial? Especially since you know you need to use a certain function as a base.
07:28:19 <srhb> Butt in all you like. I'm not sure what exactly the problematic bit is yet. :)
07:29:01 <mchall> srhb all of it :)
07:29:34 <mchall> srhb I was thinking like   allCombs f l1 l2 = combStep [(\x -> x  + x)] ( combStep  [(\x -> x + x)] l1) 
07:29:54 <srhb> mchall: What do you think [(\x -> x + x)] means (in english)
07:29:55 <Ankhers> mchall: Are you familiar with typed holes?
07:31:22 <mchall> srhb   it is a list of one anonymous function that takes an x and gives me an x plus an x
07:31:35 <srhb> mchall: Right, OK. :)
07:34:09 <mchall> Ankhers this is from the monad challenges and uses a limited prelude I'm pretty sure that won't be allowed :) and no I'm not familiar with typed holes :)
07:34:51 <MasseR> mchall: type holes aren't related to prelude. They are a on-by-default compiler extension
07:35:02 <Ankhers> > head _
07:35:03 <lambdabot>      Found hole ‚Äò_‚Äô with type: [a]
07:35:04 <lambdabot>      Where: ‚Äòa‚Äô is a rigid type variable bound by
07:35:04 <lambdabot>                 the inferred type of it :: a at <interactive>:1:1
07:35:06 <sshine> @pl \a b xs -> (a,b) : xs
07:35:06 <lambdabot> ((:) .) . (,)
07:35:25 <MasseR> It just helps you to see types inside expressions
07:35:28 <sshine> @pl \xs a b -> (a,b) : xs
07:35:28 <lambdabot> flip (flip . ((:) .) . (,))
07:35:39 <Ankhers> mchall: If you are unsure what you need, you can insert an underscore as a 'hole' in your code. The compiler will tell you what type is needed in that location.
07:36:28 <srhb> mchall: The first clue that this won't work should be that the type of allCombs never mentions +
07:36:33 <srhb> mchall: Er, Num
07:36:58 <srhb> mchall: So you cannot meaningfully use + with any of its arguments.
07:37:06 <srhb> mchall: Since that would constrain its type.
07:40:46 <KaneTW> does anyone know of a package that provides type-level bounded naturals?
07:41:28 * hackagebot llvm-general 3.5.1.1 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.5.1.1 (BenjaminScarlet)
07:41:41 <exio4> KaneTW: you should switch to Idris :P
07:41:53 <exio4> KaneTW: they have Fin in base
07:41:55 <KaneTW> i've already thought about it
07:42:05 <KaneTW> it's more of an exercise at this point
07:42:25 <maerwald> exio4: just that the eco system has like ~20 useful libraries only
07:47:45 <andromeda-galaxy> If I have a GADT with 'type Ty (a :: *) where C1 :: Ty a -> Ty a -> Ty Bool' (for example), the 'Ty Bool' value resulting from applying 'C1' essentially loses the type information about what 'a' was.  Does anyone know a good way to preserve it?  I tried adding a type-level tree as a parameter of to 'Ty' to hold on to the information, but that doesn't work since I need a Num representation
07:48:39 <mchall> srhb  how do I get a c back then ? allCombsv2 f l1 l2 = combStep [(\x -> x )] ( combStep  [(\x -> x )] l1)   Couldn't match type `a' with `c' ‚Ä¶ for l1
07:59:04 <lyxia> andromeda-galaxy: if all you need is a being a Num you can pass the typeclass constraint to the constructor C1 :: Num a => ...
08:04:59 <Dr4ke63> Hello
08:05:08 <Ankhers> Dr4ke63: Howdy
08:05:41 <Dr4ke63> Ankhers: Hey
08:06:23 <Dr4ke63> If you use a VPN while downloading via peer-to-peer connecting 
08:06:32 <Dr4ke63> Will you be caught?
08:06:46 <Ankhers> That isn't really a question for this channel.
08:07:04 <Dr4ke63> Ok :P
08:07:06 <Ankhers> This channel is about the Haskell programming language.
08:09:41 <andromeda-galaxy> lyxia: There are lots of constructors on the GADT and I need to be able to recover type information for the earlier terms after building up a large tree, and some terms at least shouldn't have the num constraint (or any other), and I need to recover typing information at a higher granularity than that (hence the type-level-tree of types approach); I just incidentally need the whole GADT to be an instance of Num (a
08:09:41 <andromeda-galaxy> classes)
08:11:57 <andromeda-galaxy> maybe I should just use ifcxt and set up smart constructors to use 'if (Typeable fa) then <store typeeable> else <store "cannot typeable">'
08:13:52 <KaneTW> welp
08:14:03 <KaneTW> there goes my desire to not depend on GHC8
08:14:12 <KaneTW> hello injective type families
08:14:54 <andromeda-galaxy> KaneTW: if you really want to avoid them, you can kind of sort of simulate them with extra fundeps...
08:16:46 <black0range> Are there some way to make characters overloaded?
08:17:14 <black0range> meaning that 'a' can be both a Char and a Word8?
08:20:57 <dave23> is there a nice way to browse local packages? like hackage in a browser but local so I don't always get the wrong versions.
08:27:11 <Ankhers> dave23: You should be able to build the documentation locally.
08:34:21 <dave23> Ankhers: the main thing I want to do is search the packages and ideally follow references to other modules
08:36:50 <andromeda-galaxy> hmm, why does GHCi refuse to show any instances of Data.Typeable?
08:39:07 <andromeda-galaxy> (more specifically, ifcxt seems to not work on Data.Typeable constraints)
08:43:47 <Ankhers> dave23: Well, depending on your needs, you may be interested in Dash (OS X only, not free), or Zeal (Linux and windows officially supported Open Source version of Dash).
08:44:27 <dave23> Ankhers: I'll have a look thanks
08:44:51 <Ankhers> Though, you still need to be careful about which verison of a package you are using because you can download the documentation for any version on Hackage.
08:44:58 <Ankhers> dave23: ^^
08:45:28 <dave23> Ankhers: I am using stack, so I'd like it to use the ones from my stack env
08:45:34 <Ankhers> But, it can integrate with your text editor, and works for more than just Haskell. 
08:46:05 <Ankhers> I believe there is a way to get stack to build the documentation for your packages.
08:46:44 <andromeda-galaxy> (:i Show => big list of instances; :i Typeable => no list of instances, but typeOf (5 :: Int) works!)
08:47:33 <EvanR> so Typeable
08:47:38 <Ankhers> dave23: `stack build --haddock` does that work for you?
08:47:52 <EvanR> i believe every single type in the universe is now an instance of Typeable
08:48:21 <EvanR> you dont even have to derive an instance
08:48:21 <andromeda-galaxy> EvanR: is that just in GHC8? I'm still on 7.10 right now..
08:48:24 <Ankhers> That may only build the docs for your package though.
08:48:35 <EvanR> andromeda-galaxy: not sure
08:48:47 <andromeda-galaxy> EvanR: with 7.10 at least, adding a Typeable constraint to a data constructor in a GADT resutls in a "could not satisfy constraint" kind of thing..
08:49:32 <andromeda-galaxy> EvanR: so I was thinking of making a smart constructor that uses ifcxt to use a Typeable-requried constructor when possible and another one when not (since I don't want a hard constraint)
08:49:54 <andromeda-galaxy> but that seems to result in the Typeable version never getting used, as far as I can tell because Template Haskell can't figure out what the instances of Typeable are
08:51:36 <andromeda-galaxy> (EvanR: looks like you were right, the wiki page at least claims that 7.10 includes a "medium-term" solutin under which everything is typeable.  Why does that ever cause constraint errors, then?)
08:52:32 <EvanR> andromeda-galaxy: i have 7.10.2 and it works
08:52:44 <andromeda-galaxy> EvanR: hmm, with 7.10.3: 
08:52:45 <andromeda-galaxy> No instance for (Typeable a) arising from a use of ‚ÄòConstructorOne‚Äô (which is 'ConstructorOne :: Typeable a => a -> MyTy a')
08:53:14 <EvanR> let me try with a variable in the GADT
08:53:22 <EvanR> (* -> *)
08:53:30 <andromeda-galaxy> EvanR: thanks!
08:53:34 <exio4> just because everything is Typeable, it doesn't mean you can deduce it
08:54:06 <andromeda-galaxy> exio4: oh right... so I have to put typeable constraints everywhere, but they can always be resolved by the runtime?
08:54:23 <EvanR> not resolved at runtime, but the implementation available for use at runtime
08:54:33 <EvanR> the constraint is like where the dictionary is passed in
08:54:34 <exio4> well, runtime, compile time.. ;) 
08:54:43 <andromeda-galaxy> *not by runtime, by ghc --- going to statically deriving thingy*.   I've been doing too much metaprogramming
08:55:07 <andromeda-galaxy> for me recently, compile time is the "run time" for half this code, run time is just the "actually show what happened during compiletime"
08:55:13 <EvanR> it works for me with * -> *
08:55:30 <andromeda-galaxy> EvanR: hmm, what do you mean?  Typeable constraints everywhere and they automatically get resolved?
08:55:51 <andromeda-galaxy> (when things are eventually actually applied to types)
08:55:56 <EvanR> resolution means determining which dictionary to use at runtime
08:56:03 <andromeda-galaxy> right
08:56:23 <EvanR> i dont know what the code is that is throwing that no instance error
08:57:03 <andromeda-galaxy> in this particular case, it's when using a constructor with a Typeable constraint inside the definition of a typeclass instance
08:57:04 <EvanR> like, youre apply ConstructorOne to a variable which is not constrained by Typeable, i guess
08:57:22 <andromeda-galaxy> I'm assuming that I just need to add Typeable constraints
08:57:31 <andromeda-galaxy> and then not worry about them since they'll work for every type
08:57:47 <EvanR> so formally you need to have that constraint so the dictionary is available to (implicitly) stick in the GADT
08:58:19 <andromeda-galaxy> right, that's what I thought.
08:58:59 <EvanR> usually an error like that says "possible solution add a constraint for foo"
08:59:13 <EvanR> or write an instance for Class foo
08:59:53 <andromeda-galaxy> EvanR: hmm, this one didn't.  I figured that I needed to do that, I was just sad that I couldn't get away with not doing that and then using IfCxt
09:01:00 <EvanR> well, when you have a variable for type "forall a. a" you kind of can do anything with it
09:01:03 <EvanR> cant*
09:01:18 <EvanR> this quirk of Typeable doesn't change that
09:01:58 * ski idly wonders whether EvanR meant `exists a. a'
09:02:21 <EvanR> i guess... is that type of x in the function (\x -> ... x ...)
09:02:34 <andromeda-galaxy> EvanR: ifcxt is a crazy library with a bunch of template haskell and overlapping instances that lets you dispatch versions of a polymorphic function based on whether a constraint is satisfied or not
09:02:45 <andromeda-galaxy> (on each particular concrete instance)
09:03:57 <EvanR> sounds like C++
09:04:15 <andromeda-galaxy> so I wanted to use 'lit :: a -> DelayedNum a; a = ifCxt (Proxy :: Proxy (Typeable a)) ConstrWithTypeable ConstrWithout', but that doesn't work anymore because the way that ifcxt figures out the constraints doesn't work with no explicit instances
09:08:32 <infandum> Do I need to close handles? Is it done automatically? Using pipes, if I do fromHandle, do I need to close that? What's the point of closing them anyway?
09:09:55 <EvanR> in general you want to close handles after using them because there is a finite limit of open handles allowed
09:10:27 <EvanR> if they are not already closed when GC'd theyll be closed
09:10:36 <EvanR> im not sure what pipes does
09:10:52 <infandum> EvanR: So I just always hClose both the input and output handles at the end of the program?
09:11:00 <infandum> pipes is for io streaming
09:11:08 <EvanR> at the end of the program they are closed anyway
09:11:19 <infandum> Should I use hClose on both stdin and stdout handles as well?
09:11:23 <EvanR> no
09:11:43 <infandum> Why not? Would it not matter?
09:11:54 <crough> infandum: You don't need to close unless there's an explicit reason for it, like you're holding a reference.
09:12:16 <infandum> crough: How so? What scenario would I need to close a handle?
09:12:26 <infandum> explicitly I mean, not automatically
09:12:47 <EvanR> if you opened it manually and youre done with it and the program isnt ending any time soon
09:12:53 <ski> infandum : btw, beware of `hClose'ing handles that have been passed to `hGetContents'
09:13:43 <infandum> EvanR: With lazy evaluation (and streams as well), wouldn't it take pretty much the whole program before it's finished reading?
09:14:03 <infandum> ski: Yeah, I would also have it at the end anyway
09:14:18 <EvanR> ignoring lazy IO... if youre streaming then youre not done with it
09:14:33 <crough> infandum: then no need to close it if you have it until the end. Haskell's garbage collector will.
09:14:37 <andromeda-galaxy> one other question: is there any decent way to have Data.Dynamic convert a value in a Dynamic to an existential around some class?  Essentially, "here's a value, if it can be shown give me Just an AnyShow value that I will now show, otherwise Nothing"
09:15:00 <infandum> OK cool, so I'll just exclude it since with streaming it reads a bit at a time for the whole program
09:15:25 <crough> andromeda-galaxy: I don't know? Why not just pass around an existential?
09:15:27 <ski> `hGetContent's implicitly does a `hClose' (when the end of the generate string is reached). using `hClose' on the handle prematurely, the string will be cutoff. (imho, it would perhaps be better to make this raise an exception ?)
09:15:27 <phadej> andromeda-galaxy: nope, you'd need to know which show you want
09:15:32 <infandum> Wait, would there be a case the the program is no longer running but the file is still being written to?
09:15:42 <EvanR> ski: yes
09:15:43 <infandum> Or would it ALWAYS close at the end of the program?
09:15:50 <andromeda-galaxy> crough: I don't want to require that the type that I'm getting this from has a Show instance, but if it does, I want to use it
09:16:02 <phadej> andromeda-galaxy: i.e. you cannot lookup type-class dictionaries at run time anymore
09:16:03 <EvanR> infandum: it is closed at the end of the program
09:16:17 <infandum> Great, so it's definitely all written to by the end
09:16:32 * ski isn't aware of any sensible use of prematurely `hClose'ing a handle that has been passed to `hGetContents' .. but perhaps someone has found one
09:16:34 <crough> andromeda-galaxy: yeah, not a possibility. You can run Show on it prematurely, though, and carry around its string rep with the Dynamic
09:16:40 <crough> That's gross but it does what you want
09:17:01 <andromeda-galaxy> crough phadej: ah well, that's too bad, maybe I'll just go without showing literals for now
09:17:08 <phadej> andromeda-galaxy: you can have Map TypeRep (Dynamic -> String) though
09:17:17 <phadej> andromeda-galaxy: and populate it with your types
09:17:43 <crough> you can also create a type and smart constructor that requires a show instance before hand, and another which requires you to provide one when casting to dynamic.
09:17:53 <andromeda-galaxy> phadej: and use Template Haskell to do it with all in-scope instances of Show!  Yeah, that would work, and is something that I'm considering, but I'm still working on a proof-of-concept so I'll probably leave it out for now, since it's somewhat annoying
09:17:54 <EvanR> is this a sufficiently complex haskell program that contains a buggy slow implementation of haskell? ;)
09:18:15 <infandum> EvanR: Wait, not really, I just tested it being written to a file and it does NOT write to the file unless I use hClose!
09:18:26 <phadej> andromeda-galaxy: when I did something like that, I used my own 'Dynamic' which captured needed instances
09:18:42 <crough> infandum: you have to use hFlush still
09:18:43 <EvanR> infandum: im not sure how you are testing that, but the OS has an extensive buffering system that you may be experiencing
09:18:52 <andromeda-galaxy> phadej: makes sense. I'll consider doing that once I get a list of instances
09:18:54 <EvanR> yeah hFlush
09:18:58 <crough> infandum: hClose calls hFlush, if you don't close it you're going to want to flush first
09:19:04 <phadej> andromeda-galaxy: e.g. if you have some Map Key Dynamic, you can populate showMap when you insert in the first one
09:19:15 <crough> infandum: or, turn of buffering, or change to line buffering or a more appropriate kind
09:19:51 <infandum> crough: Is the easy thing to just call hClose on ALL handles at the end of the program?
09:19:58 <andromeda-galaxy> phadej: yeah, that's a good point, thanks for the suggestion.... I'll probably do that
09:19:59 <phadej> andromeda-galaxy: one close-to-real-world example: https://github.com/futurice/haskell-servant-cache/blob/3384dca89849b066fa264695e687761d525ef0d3/src/Servant/Cache/Internal/DynMap.hs#L39
09:20:04 <mniip> Map String Dynamic? Sounds like a bugless fast implementation of PHP
09:20:11 <EvanR> infandum: they are all closed at the end of the program
09:20:23 <infandum> EvanR: But not flushed. hClose apparently flushes it
09:20:24 <EvanR> even if you dont conveniently have access to the handles 
09:20:34 <EvanR> infandum: they are flushed and closed at the end of the program
09:20:51 <andromeda-galaxy> phadej: thanks for the suggestion & example, I think I'll use that approach
09:21:32 <infandum> EvanR Then why did nothing get written without any hClose but with hClose it did?
09:21:49 <crough> infandum: Create a higher order function (Handle -> IO ()) -> IO () that creates the handle, sends it to the continuation, then closes the handle.
09:22:01 <EvanR> infandum: are you using lazyIO ?
09:22:05 <crough> But you're getting toward the point that you should probably just be using Pipes or Conduit
09:22:11 <infandum> EvanR: I'm using pipes
09:22:11 <EvanR> (not to be confused with lazy evaluation)
09:22:41 <crough> infandum: Pipes has its own handles, doesn't it? In Pipes.Prelude? It should close everything for you.
09:22:52 <EvanR> you may be misusing pipes
09:23:14 <dave23> Ankhers: Thanks, managed to get that working.
09:24:04 <infandum> EvanR: runEffect $ (PT.fromHandle hIn) etc. etc. >-> PT.toHandle hOut
09:24:33 <EvanR> crough: theres a better version of that withFile that also handles exceptions
09:25:16 <EvanR> infandum: and after you do that runEffect and exit, nothing shows up in the output file?
09:25:30 <infandum> Nothing, unless I do hClose hOut
09:25:53 <EvanR> ;_;
09:25:59 <EvanR> ill have to try that
09:27:34 <andromeda-galaxy> phadej: actually, where would you suggest putting said 'Map TypeRep (Dynamic -> String)'?
09:27:44 <mniip> I've just got a great idea for yoctoparsec
09:27:58 <mniip> supply it with an enormous testsuite spanning thousands of lines
09:28:01 <mniip> xD
09:28:05 <infandum> EvanR: I mean, toHandle uses hPutStr, (actually this is Pipes.Text.IO but I'm sure it's the same), and it looks like it never flushes
09:28:42 <phadej> andromeda-galaxy: it depends a bit on what you do
09:28:46 <EvanR> infandum: if its executing the write, then exiting will cause a flush
09:29:01 <EvanR> so it must not be executing the write for some reason
09:29:10 <phadej> andromeda-galaxy: somewhere where you do a -> Dynamic "type-erasure:, you could try to remember instances you need
09:29:52 <EvanR> infandum: library pipes-text ?
09:30:19 <infandum> EvanR: Yeah, but the code is almost identical to Pipes.Prelude
09:30:48 <infandum> I havent tested if it doesn't work for Pipes.Prelude either, but I assume the same thing would happen
09:31:36 <EvanR> toHandle :: MonadIO m => Handle -> Consumer' Text m r
09:31:43 <andromeda-galaxy> phadej: hmm, actually, come to think of it, there may not even be need for a map.  the erasure happens in a type constructor that's GADT-ish and ends up existentially qualifying types, so it might be fine to just add an extra field to the constructor that's a record of a bunch of 'Maybe ((forall a. Class a => a -> res) -> Dynamic -> res)'
09:31:51 <EvanR> infandum: well im not so sure i trust pipes-text-0.0.1.0
09:32:13 <EvanR> infandum: this type... what is r ?
09:32:24 <infandum> EvanR: I mean, it's toHandle h = for cat (liftIO . T.hPutStr h)
09:32:29 <EvanR> the doc says "converts text stream into a handle" but it *takes* a handle
09:32:43 <infandum> EvanR: In pipes prelude it says: toHandle handle = for cat (\str -> liftIO (IO.hPutStrLn handle str))
09:33:09 <phadej> andromeda-galaxy: my point was to have only single dictionary captured, i.e. once per typerep, not ocne per data value
09:33:29 <infandum> EvanR in fact, the code is identical
09:33:37 <phadej> andromeda-galaxy: but hard to say without seeing larger picture
09:33:43 <infandum> just IO.hPutStrLn instead of T.hPutStr
09:33:44 <andromeda-galaxy> phadej: that's what I was originally thinking, but I'm not sure of any way to do it other than global IORefs
09:34:02 <andromeda-galaxy> (in other words, I don't think that it works in this particular situation, since all that I have is a bunch of GADT values that get built up in a tree)
09:34:44 <EvanR> infandum: whats hIn
09:34:50 <infandum> my handle
09:35:02 <phadej> andromeda-galaxy: because if you go for capturing dictionaries per value, then it's cleaner to capture actual values
09:35:03 <infandum> input file
09:35:06 <EvanR> how should i reproduce it ;)
09:35:08 <infandum> hout is the handle
09:35:12 <infandum> uh
09:35:21 <EvanR> ill use stdin
09:35:24 <phadej> andromeda-galaxy: i.e. not Foo :: Show a => a -> myType, but Foo :: String -> a -> MyType
09:35:29 <infandum> stdin works though
09:35:40 <infandum> interestingly, the file doesn't while stdout works
09:35:41 <phadej> andromeda-galaxy: and use some smart constructors to make thunks
09:35:43 <EvanR> alright... so i wont use stdin
09:35:49 <infandum> I mean, for stdout
09:35:57 <infandum> stdin can work for a test
09:36:06 <infandum> the issue was with the output, not the input
09:36:15 <EvanR> im trying to reproduce your context
09:36:47 <andromeda-galaxy> phadej: hmm, that's an idea.... I'm not sure how many of this sort of thing I'll need or what the classes should be, so I'll probably hold off on deciding what to do for a little while and then use one of those approaches
09:37:22 <andromeda-galaxy> (why is it cleaner to capture values than dictionaries?  capturing dictionaries is more extensible, to my mind at least...)
09:37:25 <phadej> andromeda-galaxy: hopefully you are well equiped with toools now :)
09:37:40 <andromeda-galaxy> phadej: yep, thanks for the suggestions
09:38:36 <phadej> andromeda-galaxy: less magical types, though also a bit wider (as the String don't need to be result of show)
09:39:06 <EvanR> infandum: so whats etc. etc
09:41:22 <infandum> EvanR doesn't matter. I'm trying to reproduce it with a simple example of just "each ["hello", "hi"]" and outputting those strings to a file
09:43:14 <EvanR> as soon as lpaste responds ill have a working test case
09:43:23 <infandum> EvanR: Got it
09:43:44 <infandum> EvanR: runEffect $ each ["hello", "dude"] >-> .toHandle x
09:43:59 <infandum> x is a handle
09:44:00 <luckysid> Hi! I'm a newbie here. So far, I have completed "Learn You a Haskell for Great Good!" and want to do some real projects in Haskell. Any further resources that I should follow to be more competent?
09:44:24 <infandum> x <- IO.openFile "test" IO.WriteMode
09:44:33 <infandum> that outputs the test file that is empty
09:44:41 <infandum> however, using hClose x then writes to the file
09:45:00 <infandum> sorry, that's P.toHandle from Pipes.Prelude
09:45:03 <EvanR> lpaste down for maintenance :(
09:45:13 <infandum> and IO.hClose is from System.IO
09:45:20 <EvanR> http://codepad.org/OU9THnCl
09:45:53 <infandum> EvanR: Ah, so that also did not work for you, right?
09:47:43 <EvanR> right
09:48:01 <infandum> So I guess I'm hClose-ing everything haha
09:48:35 <infandum> I hope it doesn't matter if it's stdin or stdout either, hClose IO.stdout doesn't do anything anyway (I hope)
09:51:16 <EvanR> infandum: well.. i think that successfully closes stdout
09:51:29 <EvanR> still trying to understand wtf is going on here
09:51:40 <EvanR> hopefully its not something with lazy evaluation
09:51:52 <infandum> I hope not, if it's pipes
09:52:53 <infandum> I'll be back soon
09:56:32 * hackagebot modify-fasta 0.8.1.1 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.1.1 (GregorySchwartz)
09:57:14 <EvanR> infandum: well there seems to be a lot written on pipes... and conduit http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit
10:00:16 <geekosaur> [04 17:48] <infandum> I hope it doesn't matter if it's stdin or stdout either, hClose IO.stdout doesn't do anything anyway (I hope)
10:00:29 <geekosaur> don't run any subprocesses. most programs do NOT like stdin or stdout being closed
10:00:44 <geekosaur> (g++ runtime will abort() during startup, for example)
10:01:46 <pippijn> hi
10:02:11 <pippijn> what's a commonly used binary codec combinator library?
10:02:36 <koala_man> hopefully it'll just abort. scripts with idioms like  [[ -n $DRYRUN ]] && echo "would delete $file" || rm -r "$file"  would start taking both actions
10:03:14 <pippijn> I was looking into "codec" https://hackage.haskell.org/package/codec
10:03:17 <pippijn> is that commonly used?
10:04:07 <bergmark> pippijn: the download code gives you some idea if you compare it to other packages
10:08:58 <John[Lisbeth]> >head([1,2,3]) ++ head(tail([1,2,3]))
10:09:33 <EvanR> > head([1,2,3]) ++ head(tail([1,2,3]))
10:09:35 <lambdabot>      No instance for (Show a0)
10:09:35 <lambdabot>        arising from a use of ‚Äòshow_M80075899122057128273890‚Äô
10:09:35 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
10:10:07 <Welkin> ew
10:10:09 <EvanR> 1 ++ 2, not well typed
10:10:13 <Welkin> what's with the parens?
10:10:23 <John[Lisbeth]> It helps me visually.
10:10:24 <EvanR> haskell supports javascript syntax
10:10:43 <John[Lisbeth]> Parens are my frens
10:10:48 <EvanR> > fst(1,2)
10:10:50 <lambdabot>  1
10:10:52 <EvanR> lol
10:11:10 <Welkin> John[Lisbeth]: it confuses me and I think it is ugly
10:11:57 <John[Lisbeth]> To each his own.
10:12:02 <kadoban> It's rather specifically confusing because it implies that something like map((+1), [1..5]) would work, when it ‚Ä¶ really won't.
10:13:12 <EvanR> > map(1,) [1..5] -- on the other hand
10:13:13 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5)]
10:13:45 <EvanR> > map((1,,) [1..5])[] -- on the other hand
10:13:47 <lambdabot>  []
10:13:52 * Welkin slaps EvanR with a trout
10:13:56 <Welkin> use spaces
10:14:21 <int-e> that's a bit unfair, there were spaces there ;-)
10:15:06 <pippijn> bergmark: this? 207 total (20 in last 30 days)
10:15:12 <EvanR> when can get the extension that lets you use space as an operator
10:15:28 <Welkin> EvanR: you mean haskell?
10:15:38 <pippijn> is there any library that is similar to "codec"?
10:15:49 <EvanR>   :: A -> B -> C
10:16:11 <EvanR>   = \x y -> ... x ... y ...
10:16:25 <pippijn> something for bidirectional binary serialisation
10:16:29 <Ankhers> That sounds like a bad idea.
10:16:55 <EvanR>                      ^ ass
10:17:11 <glguy> dcoutts: Are you around?
10:17:18 <dcoutts> glguy: hello
10:17:35 <Ankhers> EvanR: There is an xkcd about that.
10:17:54 <glguy> dcoutts: Currently I'm doing this outside of Cabal as a post-compilation pass, wondering if there's a way to integrate it more nicely:
10:18:20 <glguy> My goal is to make a stand-alone static library suitable for linking in a C program
10:18:36 <glguy> currently I run ld -o $LIBNAME -arch x86_64 -static -r -exported_symbols_list public_api.txt $LIBRARIES
10:18:51 <glguy> where LIBRARIES are all the of .a files for all of my transitive dependencies
10:19:19 <glguy> to produces a single object file with everything needed for the symbols I need exported as listed in public_api.txt
10:19:36 <dcoutts> glguy: first thought is that this would fit nicely within the "foreign library" feature patches
10:19:39 <glguy> I didn't know if perhaps I could add flags to a library or executable section of my .cabal to get a similar result
10:20:50 <dcoutts> glguy: there's a feature (currently a PR) for doing this that currently supports making shared libs, but it's designed to be extensible to other kinds of system libs, so static would fit nicely
10:21:30 <dcoutts> glguy: and actually we also supported an export list (at least for windows .dlls)
10:21:49 <bergmark> pippijn: yep
10:22:28 <dcoutts> glguy: so there's basically two approaches: hack hack hack, or go and extend that foreign libs patch with your extra case (and rebase the PR so it's mergable)
10:22:30 <glguy> dcoutts: So perhaps my best solution is to keep doing to post-processing pass for now and track the foreign library support?
10:22:42 <glguy> oh, and also to contribute :)
10:22:45 <dcoutts> :-)
10:23:18 <dcoutts> glguy: see https://github.com/haskell/cabal/pull/2540
10:23:20 <glguy> OK, I wasn't sure if my particular use-case fit within that feature. I'll have to clone the repo and see what I'd need to do to add it
10:23:57 <dcoutts> glguy: so Mikhail says he would like this feature in if someone can fix up the merge conflicts
10:24:17 <glguy> Is it just a matter of merge conflict or is there actual functionality to implement?
10:24:42 <dcoutts> glguy: merge conflicts and then you'd have to add static lib support. We did shared libs, as that's what our client needed.
10:25:18 <dcoutts> glguy: sadly startup that went bust so we've not properly kept up with that patch, but we looked at it fairly carefully at the time so the code should be good
10:25:28 <glguy> dcoutts: Does your dynamic library support then make use of the existing shared libraries as installed on the system
10:25:37 <glguy> or isit making a standalone shared library?
10:26:04 <dcoutts> glguy: it has a mechanism for saying what you want, but it can only produce certain things on certain platforms
10:26:28 <dcoutts> glguy: so on windows you can request a single "everything linked in" .dll.
10:26:59 <dcoutts> glguy: you can request a single "everything linked in .so", but we cannot actually make one because of the way we build libs on ghc by default
10:27:35 <dcoutts> glguy: in principle it's totally possible, but iirc it would require building all the static libs with -fPIC
10:27:47 <glguy> OK
10:28:00 <dcoutts> which we don't do (and the base libs ghc ships with don't, so we can't add it later)
10:28:03 <glguy> My use-case is for producing statically linked executables in the end
10:28:09 <glguy> so I think that the existing .a files are good enough
10:28:13 <dcoutts> glguy: right
10:29:00 <dcoutts> glguy: so you'd want "type: native-static; options: standalone"
10:30:06 <dcoutts> glguy: and you'd want to add something equiv to "mod-def-file". "mod-def-file" is windows linker specific for dlls. But in principle it's the same idea, providing an export list. So add an equivalent thing for gnu linker scripts or whatever format it is.
10:31:10 <dcoutts> glguy: is "-exported_symbols_list public_api.txt" a standard format? gun ld specific?
10:32:08 <glguy> I don't think so, that's what I need on OS X. the ld on Linux needs something else
10:32:20 <glguy> The list format isn't even the same
10:32:47 <dcoutts> glguy: ok, that's fine. the mod def file is windows specific. All these things are.
10:32:56 <augur> coroutines are interesting when they're not plugged into one another x.x
10:33:03 <infandum> EvanR: Okay, I'm back
10:33:09 <augur> but full-blown coroutines are dreadful :(
10:33:12 <infandum> what was the conclusion?
10:33:15 <dcoutts> glguy: we tried to make a design that allows for platform specific things, while also allowing some degree of portability
10:36:31 <EvanR> infandum: still not sure whats going on, ive mainly been trying to decode pipes basics
10:37:43 <infandum> EvanR: Alright. In the meantime I'll use hClose on everything BUT stdin and stdout, apparently. Should I be using it on both input and output handles or just output handles at the end of the program?
10:40:19 <EvanR> use it on input handles when you are finished reading from them
10:40:31 <EvanR> if ever
10:41:16 <mutantmell> Hey all, I'm looking at using Criterion for doing a benchmark on some web-service calls, but I don't want to use defaultMain.  Every example I've seen uses defaultMain(With), is there an example that does not use this convenience function?
10:41:56 <infandum> EvanR: Which is hard to know due to lazy evaluation... If I don't close it there seems to be no issue, so I'll just let the GC close it at the end
10:42:09 <EvanR> its not hard to know if you dont use lazy IO
10:42:12 <infandum> It looks like only the output HAS to be closed
10:42:27 <EvanR> it might but the >->
10:43:39 <EvanR> p1 >-> p2 = (\() -> p1) +>> p2
10:46:34 * hackagebot simple-log 0.3.4 - Simple log for Haskell  https://hackage.haskell.org/package/simple-log-0.3.4 (AlexandrRuchkin)
10:47:28 <nitrix> Hi, I have a State GameState Bool, which is a switch case. I was wonder if I have to explicitly give all the cases a return False / return True or if there's a way to have a default?
10:47:30 <augur> edwardk: a few months back i mentioned the idea of a coupled producer-consumer gadget, and I've since discovered that such a thing does indeed exist in the literature, namely, coroutines :)
10:47:43 <nitrix> Since return doesn't affect control flow, I suppose I can just put it above the case ?
10:47:59 <augur> edwardk: turns out that chart parsing can be viewed as involving coroutines! :)
10:48:01 <glguy> nitrix: If you put the return before the case it will be a no-op
10:48:13 <nitrix> glguy: does the return short circuit?
10:48:40 <glguy> return x >> y   is just y
10:48:44 <kadoban> return is just a function. I assume you're talking about something like: return $ case ‚Ä¶ ?
10:49:09 <nitrix> kadoban: not exactly. case ? ? return ?
10:49:31 <kadoban> nitrix: Right, but you asked if you can put it above the case? What did you mean by that?
10:49:34 <nitrix> kadoban: Different cases yields different values for the Bool in :: State GameState Bool
10:49:44 <nitrix> Let me paste it
10:50:04 <lpaste> nitrix pasted ‚ÄúNo title‚Äù at http://lpaste.net/151682
10:50:56 <nitrix> kadoban: I'd like to avoid every cases to explicitly mention the return value. There's only QuitEvent that has it True.
10:51:01 <nitrix> kadoban: All the others are False.
10:51:49 <kadoban> nitrix: Hmm, well you've kind of achieved that with the _ case, right?
10:51:55 <nitrix> (Bth, that doesn't currently compile because KeycodeUp, KeycodeDown etc all would need a return, hence the madness and reason I'm here)
10:52:03 <kadoban> Oh
10:52:15 <glguy> case x of Quit -> return True; _ -> (case x of A -> B; C -> D) >> return False
10:52:19 <nitrix> kadoban: Yes but no, _ only takes care of what's not matched, and this case is going to have like 20 cases.
10:52:20 <glguy> you could do something like that
10:52:35 <nitrix> glguy: Oh I suppose.
10:53:14 <glguy> or:  case x of {A -> B; C -> D;} ; return (x == Quit)
10:53:34 <nitrix> I was thinking about that too o: !
10:53:58 <glguy> omg, me too!
10:54:15 <nitrix> I suspect ingame there'll be a way to click a button to exit so it'll eventually become the former I think.
10:54:19 <nitrix> But the latter works for now.
10:54:24 <nitrix> Thanks.
10:54:28 <glguy> np
10:56:55 <nitrix> :t (<<)
10:56:57 <lambdabot>     Not in scope: ‚Äò<<‚Äô
10:56:57 <lambdabot>     Perhaps you meant one of these:
10:56:57 <lambdabot>       data constructor ‚ÄòSeq.:<‚Äô (imported from Data.Sequence),
10:57:02 <nitrix> :t (>>)
10:57:03 <lambdabot> Monad m => m a -> m b -> m b
10:57:09 <shapr> :t (!!)
10:57:10 <lambdabot> [a] -> Int -> a
10:57:16 <nitrix> :t flip . (>>)
10:57:17 <lambdabot> (b -> a) -> b -> (b -> c) -> c
10:57:46 <nitrix> What? That seems wrong.
10:58:06 <nitrix> :t flip (>>)
10:58:07 <lambdabot> Monad m => m b -> m a -> m b
10:58:24 <nitrix> There we go :]
11:00:09 <lpaste> nitrix revised ‚ÄúNo title‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/151682
11:00:21 <nitrix> What do you think? glguy, kadoban.
11:01:48 <nitrix> I wish I could not have the disgusting record updates, but TemplateHaskell doesn't work on windows.
11:01:48 <kadoban> Well, I guess that works. Looks correct for what I think you were saying at least.
11:02:03 <mniip> eww
11:02:38 <kadoban> nitrix: You could just factor those out as a function since you're doing the same thing over and over, no?  modifyCamera cameraMoveLeft
11:02:41 <nitrix> I should just factor it into a handleKeyEvent
11:02:44 <nitrix> Exactly :P
11:02:56 <nitrix> Oh, for the camera too, yes, good idea.
11:04:04 <kadoban> Of course I don't know if that's the only thing you're doing, you might end up with like N of those, heh. can lens save you from that? I thought it could. *needs to learn lens sometime*
11:04:31 <lpaste> glguy annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/151682#a151688
11:04:35 <glguy> nitrix: I'd do it more like that
11:05:27 <nitrix> glguy: Yeah that was solution #2, but it wont work if I have triggers in game (like keys or buttons to quit)
11:05:43 <glguy> nitrix: the way you'd just pasted it doesn't help with that
11:06:04 <nitrix> Ah crap :(
11:08:17 <glguy> nitrix: You don't need TemplateHaskell to use the lens package, that's only a convenience
11:09:29 <nitrix> :t lens
11:09:30 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
11:09:39 <nitrix> Yeah I think I can use that thing.
11:09:49 <nitrix> Never done that before though.
11:09:53 <glguy> The best way to go is to just write them out
11:10:55 <glguy> cameraLens f x = fmap (\c -> x{camera = c}) (f (camera x))
11:13:37 <EvanR> infandium: looks like this has nothing to do with pipes... it seems like flushing does not occur on program exit
11:14:23 <EvanR> this is a reference, though pretty old https://mail.haskell.org/pipermail/haskell-cafe/2011-July/094051.html
11:14:34 <EvanR> and youre ping timeoutted
11:16:05 <fortress_> hello, I have a very newbie question... How can call two functions from an else branch? For example, I am trying to have an else branch first append an item to a list, as well as call another function
11:16:51 <EvanR> i cant believe that people would argue that having the output buffers simply forgotten during the exit of a program is "not a valid bug"
11:16:56 <fortress_> I realized I could just make another function to do both of those things, then call that function in the else branch, but I think there must be a way to do it without making a new function. I am at a loss with regards to the syntax
11:17:27 <EvanR> @tell infandium sort of insane but, https://mail.haskell.org/pipermail/haskell-cafe/2011-July/094051.html
11:17:27 <lambdabot> Consider it noted.
11:17:34 <maho> Can I please get help for something which is non-Haskell?
11:18:42 <glguy> maho: Generally not in #haskell
11:19:07 <maho> Please? I heard you guys are the most helpful.
11:19:12 <maho> Here is the question : http://paste.ofcode.org/f7ExXYs5jmhkn9FzJtV9J9 . I have an answer as well : http://sprunge.us/KdWB . The fourth Output is wrong. How do I store all the 'wrong' sequences and then process them to get the correct output?
11:19:39 <shapr> maho: do you have working Haskell code for that?
11:19:47 <maho> Nope
11:19:54 <maho> No channel is helping
11:19:59 <maho> So I came here
11:20:16 <fortress_> For example, if I try: "else item:list func' item list", the compiler thinks I am trying to pass func', item, and list to list, which obviously won't work!
11:20:37 <fortress_> Does my question make sense?
11:21:03 <nitrix> glguy: http://lpaste.net/151690
11:21:08 <glguy> you'd write: function2 (function1 (x : xs))
11:21:10 <nitrix> glguy: So, I've cheated, but my lunch time's over :/
11:21:27 <glguy> fortress_: Your first function can return the result of adding an eleemnt to a list, it isn't modify existing lists
11:21:40 * hackagebot modify-fasta 0.8.1.2 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.1.2 (GregorySchwartz)
11:21:42 <glguy> if you want to have more than one function application you can use the result of one as an argument to another
11:21:53 <maho> Anyone?
11:22:29 <fortress_> glguy: thank you! i think i get it. So i'd write: "else func' item (item:list)"
11:22:42 * fortress_ brain melts
11:22:47 <glguy> fortress_: Yeah, that'd work assuming it's what you wanted :)
11:22:49 <fortress_> thank you i think i get it now!
11:23:41 <maho> Anyone?
11:24:10 <kadoban> hackagebot: If you're going to ask something off topic, the least you could do would be to refrain from "Anyone?" every 2 minutes.
11:24:13 <kadoban> maho: ^
11:24:13 <glguy> maho: The topic is actually Haskell programming, this isn't a good place to get offtopic help
11:24:34 <Clint> or to yell at hackagebot
11:24:50 <EvanR> try #programming
11:25:04 <ski> or ##c, judging from the paste
11:25:24 <maho> EvanR :They can't help me
11:25:29 <EvanR> why not
11:25:46 <maho> EvanR :'cause they are not replying
11:32:10 * hackagebot hsdev 0.1.5.6 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.6 (AlexandrRuchkin)
11:45:28 <infandum> EvanR sorry, my ethernet converter broke
11:46:17 <EvanR> infandum: apparently i was wrong, ghc does not auto flush open fds on exit. and i guess it might not call any finalizers either
11:46:37 <infandum> EvanR: As in, it won't close either?
11:46:55 <infandum> So it's all manual (or closes when it finishes, not the program, but the file)
11:46:58 <EvanR> its closed by the OS (so im not sure why its not flushed...)
11:47:02 <infandum> ah
11:47:27 <EvanR> ghc's rts must be doing a bigger part of it than i thought
11:48:07 <infandum> I've been coding incorrectly for so long...
11:48:16 <EvanR> if you use openFile then you have to hFlush or hClose before exit, but if you use withFire you are good
11:48:19 <EvanR> withFile
11:48:43 <EvanR> is the take away from the mailing list post i sent you
11:50:01 <infandum> Ah. The example in Pipes.ByteString uses withfile as well
11:50:52 <infandum> Weird that it's all in a lambda function then
11:51:21 <EvanR> well you sometimes see this style
11:51:30 <EvanR> do
11:51:43 <EvanR>   forM_ [1,2,3] $ \x -> do
11:51:47 <infandum> yeah
11:51:48 <EvanR>     ... x ...
11:51:56 <EvanR> then you dont have a dangling paren
11:52:17 <infandum> Now I need to write separate cases for stdin and stdout though where before it was cleaner
11:52:27 <EvanR> this "bracket" pattern is really good for taking care of opening and closing tasks
11:53:01 <EvanR> stdout ... well you cant use withFile with those 
11:53:13 <infandum> exactly
11:53:25 <infandum> I give the option of a file or stdin with stdout
11:53:30 <EvanR> but you can still abstract over "this part of my code takes handles"
11:53:36 <infandum> mhm
11:53:46 <infandum> well the handles are from stdin and stdout as well
11:53:52 <infandum> but I guess im not supposed to close those
11:53:59 <EvanR> yes dont
11:54:20 <EvanR> but i guess you have hFlush stdout.. unless you disable buffering
11:55:29 <infandum> It looks like they just use hClose in withFile anyway, so I can keep it the same I just need to use hClose
11:55:45 <infandum> I should stop any non stdin and stdout to be perfectly honest
11:55:55 <infandum> but I feel like so many people don't use that just cause
11:57:11 <EvanR> you can use hClose anytime, but dont use it on a handle that is in use (such as by lazy IO)
11:57:56 <EvanR> ... so anytime is not right ... 
11:58:09 <infandum> uh
11:58:24 <EvanR> youre not using lazy IO in your examples so far
11:58:28 <infandum> just using hclose at the end of the program should hopefully avoid all of those problems
11:58:56 <EvanR> or hFlush
11:59:28 <infandum> mhm
12:02:25 * hackagebot modify-fasta 0.8.1.3 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.1.3 (GregorySchwartz)
12:21:47 <Ankhers> If I am inside Reader, and I call liftIO, can I still call get inside the IO portion?
12:22:58 <glguy> no
12:23:27 <Ankhers> So I would need to call get before, and pass it as an argument to the function?
12:24:02 <kadoban> Ankhers: Yes, if you need to.
12:24:12 <kadoban> :t liftIO
12:24:13 <lambdabot> MonadIO m => IO a -> m a
12:24:26 <kadoban> The thing you call liftIO on isn't a 'm' or a Reader or anything, it's just IO
12:24:53 <Ankhers> I figured. Thanks.
12:25:41 <EvanR> heh... http://lpaste.net/151692 screwing around with type families, guided mostly by compiler errors leads me here
12:26:41 <EvanR> Ankhers: you can also make the thing you are passing into a ReaderT IO and defer the liftIOing
12:27:17 <Ankhers> I'm still not really familiar with monad stacks.
12:27:24 <Ankhers> (monad transformers?)
12:43:01 <ReinH> Ankhers: well, this seems like a good time to learn
12:45:45 <fortress_> I have a function that returns Either String Bool. What is the correct method for inserting a variable into a string returned by Either?
12:46:24 <fortress_> I have tried doing: "Error string " ++ variable ++ " rest of string."
12:46:32 <fortress_> in this case, variable is a function that returns a char
12:46:42 <fortress_> and it does not work 
12:47:25 <koala_man> if it's a Char, then [variable] will make it a [Char] that you can concatenate with ++
12:48:39 <fortress_> koala_man: thanks for the reply. I tried that and, oddly enough, nothing changed.
12:49:09 <koala_man> > let variable = 'a' in "Error string " ++ [variable] ++ " rest of string."
12:49:10 <lambdabot>  "Error string a rest of string."
12:52:14 <fortress_> koala_man: I am having difficulty understanding the compiler errors. Here is a pastebin: http://pastebin.com/6iUwCikN
12:52:51 <mjrosenb> fortress_: if it is Either String Bool, you can use show to get it to be a string
12:53:04 <koala_man> fortress_: tricky indeed. use Left (your string expression)
12:53:14 <shachaf> I don't see your code, but it looks like you're writing Left "blah" ++ ...
12:53:31 <koala_man> currently it thinks you mean (Left "Some stuff") ++ "more stuff" which obviously fails
12:53:33 <shachaf> Which is (Left "blah") ++ ... -- function application is stickier than any operator.
12:54:02 <fortress_> oh I see!
12:54:07 <fortress_> one moment, thanks for the help everyone
12:57:27 <puregreen> monochrom: just wondering: have you finished lens over tea or was it too long (Lens over A Feast Spanning 5 Days is a cool title, by the way)? asking 'cause I don't have any data on whether its length is offputting to people or not and I'm curious
12:57:37 <snowowl> sorry for the dumb question, but i'm having trouble compiling a simple haskell program
12:58:10 <snowowl> it's my first time with functional programming and i'm trying to get it down
12:58:28 <puregreen> snowowl: if it doesn't compile, put it on lpaste (together with the error) and we'll figure it out
12:58:31 <puregreen> @where lpaste
12:58:31 <lambdabot> http://lpaste.net/
12:58:55 <snowowl> puregreen: https://bpaste.net/show/6ad9b196d666
12:59:27 <puregreen> snowowl: okay, I see several errors here, right
12:59:29 <snowowl> i'm following the haskell for great good book
12:59:49 <puregreen> snowowl: first of all, you forgot the ‚Äú=‚Äù between ‚Äúmain‚Äù and ‚Äúdo‚Äù (probably a typo)
13:00:22 <snowowl> ok
13:00:26 <puregreen> ‚Äúmain‚Äù is the name of the procedure, ‚Äúdo‚Äù is a keyword starting a block
13:01:15 <kadoban> snowowl: There's better resources than LYAH. You experimenting and making sure stuff works is a great sign, but LYAH won't help you much there, there's no exercises, and some of its descriptions are ‚Ä¶ not great.
13:01:37 <puregreen> the 2nd error is that ‚Äúlucky‚Äù is a function that turns an integer into a string, but it doesn't specify what should be done with it, so you can't just say ‚Äúmain = do lucky 4; lucky 7‚Äù ‚Äì it won't automatically know that you want to print the results
13:02:07 <snowowl> kadoban: i'm supplementing it with hackerrank
13:02:37 <puregreen> so, if you want the strings to be printed, you should use ‚ÄúputStrLn‚Äù: http://lpaste.net/151695
13:03:03 <snowowl> puregreen: thank you very much
13:03:27 <puregreen> if you type ‚Äúlucky 7‚Äù in GHCi, it *will* show the string, but that's because GHCi automatically prints all values it can print
13:03:38 <kadoban> snowowl: Better than nothing, but I suspect it's going to be a little difficult because hr is it's own thing, you'll have no guide of what's useful or possible to try at what stages of learning.
13:04:03 <mjrosenb> and it yells at you when you evaluate someting that it can't print.
13:04:20 <puregreen> mjrosenb: ouch, right, I forgot that GHCi yells
13:04:25 <puregreen> haskell-mode doesn't yell
13:04:49 <mjrosenb> I guess I've never tried to execute something in IO that returns something that isn't an instance of Show.
13:05:41 <snowowl> kadoban: yeah, i'll work on practicallity after i can just understand syntax. need to wrap my head around haskell first
13:06:35 <kadoban> snowowl: LYAH didn't help me with that. It's more "here's some cool stuff, okay bye!" than something that will teach you haskell by itself.
13:06:38 <ReinH> snowowl: I recommend http://dev.stephendiehl.com/hask/#monads and the rest of it
13:08:47 <_d0t> ohai
13:09:16 <kadoban> snowowl: My usual recommendations are https://www.seas.upenn.edu/~cis194/spring13/ or http://haskellbook.com/ , if you're interested. The second costs money, but is far more thorough. The first is at least something around LYAH to give you actual exercises and stuff to do.
13:09:16 <_d0t> is there any particular reason why Data.Foldable.{maximumBy,minimumBy} are using foldr instead of foldl?
13:09:20 <John[Lisbeth]> whattype is '[Char] -> r0' ?
13:10:06 <kadoban> John[Lisbeth]: It means "give me a String, and pick any other type, I'll give you a value of that type."
13:10:10 <kadoban> :t error
13:10:11 <lambdabot> [Char] -> a
13:10:24 <kadoban> > 1 + error "omg"
13:10:26 <lambdabot>  *Exception: omg
13:11:59 <ReinH> John[Lisbeth]: without any other context, it's a function which takes a string and either crashes or runs forever when evaluated.
13:12:19 <John[Lisbeth]> oh no
13:12:42 <ReinH> r0 is a stand-in for "any type", and the only way to produce a value of "any type" is to produce bottom, which is either a crash or a loop.
13:12:56 <mjrosenb> I forget...
13:13:02 <mjrosenb> > fix error
13:13:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:13:06 <John[Lisbeth]> well I have a functionbash which is :: ShellCommand r => r-> IO String
13:13:12 <mjrosenb> yup, that's what I thought.
13:13:23 <ReinH> :t let loop s = loop (s :: String) in loop
13:13:24 <lambdabot> String -> t
13:13:35 <kadoban> Note that it would be a little different if it were something like: Num a => [Char] -> a -- that gives the implementation more options, and there's other possible implementations other than ‚ä• (crashing or running forever)
13:13:39 <ReinH> John[Lisbeth]: That's different.
13:14:00 <kadoban> John[Lisbeth]: That's ‚Ä¶ not even close to the same thing?
13:14:00 <John[Lisbeth]> andI set a new function to 'bash (concat "echo" " "Hello, World!")
13:14:31 <John[Lisbeth]> it hasthe type of :: IO String
13:14:44 <geekosaur> r becoming r0 suggests something is not unifying to me
13:14:51 <ReinH> Well, that's a totally different thing...
13:14:56 <ReinH> Maybe you should show us your code using lpaste
13:15:03 <geekosaur> hm, OverloadedStrings?
13:15:21 <geekosaur> no, probably not here. yes, we need to see actual code
13:15:31 <ReinH> geekosaur: I too enjoy playing "Guess the contents of the file" games...
13:15:55 * geekosaur sometimes has success with it... but usually with a *little* more to go on
13:16:09 <geekosaur> (all I have here is the r0 suggesting ghc didn't unify something)
13:16:19 <jle`> is there any way to declare local type synonyms
13:16:28 <ReinH> jle`: Define "local".
13:16:32 <jle`> gladly
13:16:36 <ReinH> Module-local? Sure. Don't export them.
13:17:21 <jle`> f :: forall a. (KnownNat a => Proxy a -> r) -> r, and i want to call: f (\(Proxy :: Proxy n) -> ... )
13:17:37 <jle`> but in the body of the lambda, it'd be nice to have the type variable `k` refer to `n + 2`
13:17:43 <jle`> so i don't have to type (n + 2) everywhere
13:17:49 <ReinH> Ah. I don't think so, no.
13:17:50 <jle`> (if i use n + 2 a lot)
13:18:07 <geekosaur> type level let, anyone? :p
13:18:07 <mmaruseacph2> use let
13:18:08 <jle`> hm i could fake something with Refl
13:18:19 <ReinH> Maybe something involving (~) and a witness of equality?
13:18:21 <mmaruseacph2> oh, you mean in type
13:18:28 <jle`> ReinH: yeah that was what i was thinking
13:18:31 <ReinH> I prefer to do my programming at the value level, so I'm not sure.
13:18:32 <jle`> sounds like a bit of a hassle though
13:18:43 <John[Lisbeth]> stack build HSH; stack ghci HSH RET import HSH RET let bashargs = (run $ args :: IO String) RET import Data.List RET let echo = bash (concat "echo" (concat " " "Hello, World!")) RET echo
13:18:54 <jle`> this whole project has been an exercise in extreme type safety so trying to figure out if this is doable in a nice way is a part of the learning process i guess, heh
13:18:58 <ReinH> John[Lisbeth]: use lpaste please
13:19:02 <ReinH> @where lpaste
13:19:02 <lambdabot> http://lpaste.net/
13:19:12 <jle`> coming soon to espn, Extreme Type Safety
13:19:42 <ReinH> jle`: Oh yeah I was involved with one of those. It took 30 minutes and 6GB of memory to compile.
13:19:45 <jle`> ReinH: it'd be nice if i could have some sort of constraint over the whole thing
13:19:48 <jle`> OH!
13:19:50 <jle`> i could define a continuation helper
13:20:28 <jle`> withKToo :: Proxy n -> (forall k. (k ~ n) => Proxy k -> r) -> r
13:20:30 <jle`> hehe
13:20:35 <jle`> withKToo :: Proxy n -> (forall k. (k ~ (n + 2)) => Proxy k -> r) -> r
13:20:45 <jle`> i'm actually irl laughing
13:21:12 <jle`> so convolute
13:21:29 <ReinH> :D
13:21:33 <jle`> i wonder if there's a way i can abstract over this pattern
13:21:39 <ReinH> jle` what r u doing
13:21:42 <ReinH> jle` stahp
13:21:49 <jle`> can't ... stop ..
13:22:14 <jle`> it's addicting
13:22:17 <jle`> the safety
13:22:31 <jle`> it's like the rush you feel when you first started haskell
13:22:44 <jle`> but now you need more safety to feel the same rush as you did when you first started
13:23:00 <jle`> it never stops
13:24:48 <EvanR> so much type safety it hurts
13:25:43 <mjrosenb> jle`: do we need to stage an intervention?
13:26:15 <jle`> it's okay becuase i'm still the one in control ultimately
13:26:33 <jle`> ReinH: free for a PM?
13:26:35 <exio4> jle`: which pattern do you want to abstract out?
13:26:48 <jle`> exio4: the (k ~ (n + 2)) part
13:26:52 <jle`> with an arbitrary constraint
13:27:01 <exio4> Proxy n -> (forall k. (k ~ (n + C)) => Proxy k -> r) -> r ? 
13:27:25 <jle`> Proxy n -> (forall k. (k ~ F n) => Proxy k -> r) -> r
13:27:42 <Guest00000> omg
13:27:43 <jle`> where F is some type function, like (+ 2)
13:27:49 <Guest00000> "fix error" is funny
13:27:49 <exio4> that should be impossible to write
13:28:14 <exio4> what if (k ~ F n) can't be deduced? you crash?
13:28:22 <telmich> good evening
13:28:24 <jle`> well yeah, that's haskell for ya
13:28:31 <jle`> oh!
13:28:34 <jle`> it could be a lot simpler
13:29:03 <EvanR> call me when the 3D shooter is implemented at compile time
13:29:05 <jle`> withKInScope :: Proxy k -> (forall k'. Proxy k' -> r) -> r
13:29:17 <jle`> then i could do withKInSscope (Proxy :: Proxy (n + 2))
13:29:28 <telmich> I'm a haskell & emacs beginner and trying to install haskell-mode into emacs; if I have installed the emacs-haskell-mode, do I need to specify full path on load or can I use something relative?
13:29:33 <exio4> that's not very meaningful 
13:29:43 <exio4> withKInScope p f = f p 
13:29:44 <jle`> exio4: it lets me use `k` to refer to (n + 2) in the scope
13:29:49 <jle`> yeah, that's the beauty of it
13:29:54 <jle`> the implementation is simple
13:29:57 <jle`> like `asTypeOf`
13:30:01 <exio4> what, does it?
13:30:10 <ReinH> jle`: go for it
13:30:17 <exio4> (forall k'. Proxy k' -> r) isn't very useful.
13:30:21 <jle`> yeah, withKInScope (Proxy (n + 2)) (\(Proxy :: Proxy k) -> ...)
13:30:27 <jle`> i can use k in the scope, and it's equivalent to n + 2
13:30:39 <exio4> you lose information
13:30:41 <jle`> the whole point is to basically simulate a "local" type synonym
13:30:51 <ReinH> EvanR: well... http://lambdacube3d.com
13:30:53 <jle`> in the scope, you have both `n` and `k`, and `n ~ k + 2`
13:31:07 <ReinH> It is, in a sense, implemented at compile time.
13:31:09 <jle`> so it's sort of equivalent to let type k = n + 2 in ...
13:31:09 <exio4> jle`: you don't have that equality.
13:31:30 <jle`> hm
13:31:33 <jle`> do i not?
13:32:22 <exio4> jle`: you can try, "‚àÄr.(‚àÄk'. Proxy k' -> r) -> r" doesn't say much
13:32:47 <jle`> hm
13:32:49 <jle`> ah
13:33:04 <jle`> withKInScope :: Proxy k -> (forall k'. (k' ~ k) => Proxy k' -> r) -> r
13:33:08 <jle`> that should do it
13:34:06 <exio4> jle`: that doesn't add much though, it should be the same as Proxy k -> (Proxy k -> r) -> r
13:34:06 <jle`> good catch
13:34:29 <jle`> but, now k' and k unite in the scope of the function
13:34:49 * hackagebot modify-fasta 0.8.1.3 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.1.3 (GregorySchwartz)
13:34:49 * hackagebot pong-server 0.0.1.0 - A simple embedded pingable server that runs in the background.  https://hackage.haskell.org/package/pong-server-0.0.1.0 (RobertFischer)
13:35:10 <jle`> so withKInScope (Proxy (n + 2)) (\(Proxy :: Proxy k) -> ... ), in the ... body, (k ~ n + 2) is satisfied
13:35:47 <exio4> jle`: what'd be a good use of this? 
13:35:53 <jle`> the point is to have a local type synonym
13:36:03 <jle`> so it's like `type k = n + 2`
13:36:08 <jle`> but only inside the scope of the lambda
13:36:17 <exio4> well, I guess it does the trick then
13:36:39 <exio4> jle`: you might like GHC 8.0's TypeApplications :)
13:37:10 <jle`> yes, heh, i'm waiting for it to be officially released v.v i already have ghc-8.0 installed to play with heh
13:37:37 <exio4> you could rewrite this as withK :: forall k r. (forall k'. (k ~ k') => Proxy k' -> r) -> r! 
13:37:37 <jle`> i was going to write a "practical dependent types in the real world in haskell" post but i probably should wait until 8.0 comes out and the ecosystem adjusts
13:38:01 <jle`> :O
13:38:26 <exio4> jle`: also, why are you forcing proxy? :P
13:38:26 <puregreen> jle`: have you got a blog I can subscribe to
13:39:02 <jle`> puregreen: yeah, http://jle.im :)  there hasn't been some posts in a while becuase of my doctoral research taking all my time though
13:39:04 <exio4> jle`: withK :: p k1 -> (forall p' k2. p' k2 -> r) -> r should be fine 
13:39:17 <jle`> exio4: p' probably has to be Proxy
13:39:33 <jle`> or, hm, does it?
13:39:37 <exio4> it doesn't has to be, pattern matching on it doesn't give add you any extra information
13:39:52 <exio4> give/add*
13:39:56 <jle`> well, how would i define it?
13:40:05 <jle`> withK p f = f (????)
13:40:07 <John[Lisbeth]> http://sprunge.us/BjEA
13:40:14 <exio4> jle`: f p 
13:40:15 <jle`> it would have to be the same p (and not p'), or just Proxy
13:40:21 <jle`> oh yeah
13:40:26 <jle`> that works
13:41:17 <exio4> or you could use Proxy instead of p', but the first parameter doesn't need to be :) 
13:41:21 <jle`> oh, i could write an even nicer version once my PR to the 'constraints' library gets looked at
13:41:34 <exio4> which PR?
13:41:51 <jle`> https://github.com/ekmett/constraints/pull/20
13:42:18 <jle`> hm
13:42:23 <jle`> nvm it doesn't work as cleanly as i thought
13:42:41 <jle`> anyways back to being unproductive with types
13:42:48 <jle`> i mean, productive and safe :)
13:44:46 <John[Lisbeth]> It simply takes three strings, concats them, and then sends them as a parameter to a shell command that returns IO String
13:47:30 <John[Lisbeth]> the type of bash is ShellCommand r => r -> IO String
13:48:07 <dmj`> John[Lisbeth]: bash args = bash args ?
13:48:07 <dmj`>  
13:48:50 <John[Lisbeth]> becauseof the nature of run I define the bash command for syntactic berevity
13:50:43 <John[Lisbeth]> echo has type IO String I think the trouble is going IO String -> ShellCommand r
13:50:58 <dmj`> John[Lisbeth]: that function won't terminate
13:51:09 <John[Lisbeth]> why not?
13:51:16 <dmj`> bash args = bash args
13:51:22 <dmj`> @def f' x = f' x
13:51:23 <lambdabot>  .L.hs:150:8:
13:51:23 <lambdabot>      Ambiguous occurrence ‚Äòf'‚Äô
13:51:23 <lambdabot>      It could refer to either ‚ÄòL.f'‚Äô, defined at .L.hs:150:1
13:51:40 <dmj`> it's defined in terms of itself
13:54:25 <John[Lisbeth]> sprunge.us/YgCh
13:54:28 <dmj`> John[Lisbeth]: who taught you how to write haskell like that
13:54:46 <John[Lisbeth]> You mean with my spacing?
13:54:49 <dmj`> yes
13:55:03 <John[Lisbeth]> That's howI feel code should look
13:55:04 <dmj`> run is not defined here
13:55:12 <John[Lisbeth]> runis imported by HSH
13:55:53 <John[Lisbeth]> stack build hsh; stack ghci HSH
13:56:04 <dmj`> John[Lisbeth]: are you trying to print "echo" to the console?
13:56:51 <John[Lisbeth]> I am tryingto print "Hello, World\n"
13:57:28 <dmj`> main :: IO (); main = putStrLn "Hello, World"
13:57:51 <John[Lisbeth]> I am not using putStrLn
13:58:08 <John[Lisbeth]> that is not the purpose of my program
13:58:17 <kadoban> John[Lisbeth]: That's really really bad formatting :(
13:58:27 <John[Lisbeth]> probably
13:58:41 <dmj`> John[Lisbeth]: what is the purpose of your program if not to print "Hello, World\n"
14:00:03 <John[Lisbeth]> The next working goal is to create an echo command where echo j = j ++ "\n"
14:00:19 <John[Lisbeth]> And it must pass through the bash shell to do it
14:02:16 <dmj`> John[Lisbeth]: 'putStrLn' appends a new line for you automatically
14:02:56 <John[Lisbeth]> True, but what if use a different command than echo
14:03:03 <John[Lisbeth]> awk, for example
14:03:15 <John[Lisbeth]> I would have to write an awk function
14:03:23 <John[Lisbeth]> then putstrln
14:03:32 <kadoban> John[Lisbeth]: So, why isn't the definition of 'bash' just: bash = run -- like 6-7 lines less, depending on if you put in a type sig, which you probably should.
14:03:56 <kadoban> John[Lisbeth]: Most of the rest is just line noise ‚Ä¶ those () :-/  The rest has similar formatting issues.
14:04:33 <John[Lisbeth]> which issues
14:05:46 <kadoban> Issues like, taking 20 lines for a really pretty short and simple function
14:06:30 <John[Lisbeth]> Are you not able to read it?
14:06:53 <kadoban> Barely. It takes forever and it *really* shouldn't, because there's almost nothing to it.
14:06:55 <Hijiri> it was a bit hard for me to read it
14:08:07 <kadoban> I also don't understand parts of it. You seem to be calling concat with two arguments for example
14:08:11 <kadoban> :t concat
14:08:13 <lambdabot> Foldable t => t [a] -> [a]
14:10:22 <otacon89> suppose i have function "map . snd", how would i pass arguments to this and what would they look like?
14:10:47 <John[Lisbeth]> sprungeus/KCMJ
14:10:48 <kadoban> :t map . snd
14:10:50 <lambdabot> (a1, a -> b) -> [a] -> [b]
14:10:53 <John[Lisbeth]> sprunge.us/KCMJ
14:11:17 <jle`> > (map . snd) ("hello", (+2)) [1,2,3,4]
14:11:18 <lambdabot>  [3,4,5,6]
14:11:20 <kadoban> otacon89: Is that really the function you want? I mean it's a possible function but it doesn't sound commonly used?
14:11:36 <Hijiri> is that lisp?
14:11:44 <John[Lisbeth]> me?
14:11:57 <Hijiri> also you opted to use $ in one spot but not the others
14:12:22 <otacon89> kadoban: it is theoretical...i am just trying to make sense of it
14:12:26 <Welkin> I use dem dollah bill all dah time
14:12:50 <Hijiri> actually that $ is not necessary at all
14:13:04 <Welkin> f . g . h $ 1
14:13:07 <Welkin> like that :D
14:13:11 <Hijiri> it wasn't in the original either, but it's more obvious now
14:13:13 <otacon89> jle` is it possible to write that same function using $ ?
14:13:25 <jle`> like, only $'s?
14:13:32 <Hijiri> John[Lisbeth]: yes, sorry
14:13:32 <jle`> $ $$$ ($) $ $?
14:13:45 <otacon89> i mean pass the arguments to the map . snd function like that (with $)
14:13:48 <John[Lisbeth]> no, not lisp
14:14:06 <John[Lisbeth]> but I find the parentheses to be the most powerful characters
14:14:14 <jle`> otacon89: yeah, you could use $:  (map . snd) ("hello", (+2)) $ [1,2,3,4]
14:14:22 <otacon89> jle`: for instance, map . snd $ <something>
14:14:26 <Welkin> lisbeth just likes to make haskell look like an abomination
14:14:27 <jle`> ah
14:14:56 <jle`> otacon89: well, you could directly apply ("hello", (+2)) to (map . snd)
14:15:10 <jle`> otacon89: (map . snd $ ("hello", (+2)) [1,2,3,4]
14:15:21 <jle`> um
14:15:32 <jle`>  (map . snd $ ("hello", (+2))) [1,2,3,4]
14:15:49 <jle`> but i think you should be realizing that `map . snd` is slightly silly in most cases
14:16:11 <jle`> (map . snd $ ("hello", (+2))   === map (+2)
14:16:31 <jle`> because that's map (snd ("hello", (+2)))
14:16:37 <jle`> which is map (+2)
14:16:44 <emmanuel_erc> Hey there, so on a function like "join (***) fromRows" (it's signature is Element t => ([Vector t], [Vector t]) -> (Matrix t, Matrix t))why does GHC demand that both pieces in the final tuple be the exact same type?
14:16:55 <otacon89> jle`: absolutely. i'm just trying to grasp haskell and particularly the . and $ operators
14:17:10 <Welkin> otacon89: (.) is just function composition
14:17:22 <jle`> one way to look at how (.) works is to see that it's just a normal function you can 'apply out' by hand
14:17:22 <Welkin> $ is just function application
14:17:23 <John[Lisbeth]> Does it make more sense to you, now?
14:17:26 <jle`> (f . g) x = f (g x)
14:17:31 <Welkin> but with the lowest precedencde
14:17:36 <Welkin> so it can be used in place of parens
14:17:38 <jle`> emmanuel_erc: `join` forces it
14:18:11 <jle`> join :: ((a -> b) -> (a -> b) -> (a,a) -> (b,b)) -> (a -> b) -> (a,a) -> (b,b)
14:18:34 <jle`> emmanuel_erc: `join` apples `fromRows` to (***) twice
14:18:38 <jle`> but it applies the same fromRows
14:18:40 <emmanuel_erc> yeah, I see it now. Thanks
14:18:42 <jle`> join f x = f x x
14:18:48 <jle`> it applies the same x twice
14:19:03 <emmanuel_erc> Thanks jle`.
14:19:06 <jle`> np
14:19:26 <emmanuel_erc> I want it do something else though, but I suspect there isn't a clever way of doing it.
14:19:50 <otacon89> jle`: i get that "(map . snd $ ("hello", (+2))   === map (+2)", but is it possible to apply the list to the right side? i would like to do something like the following, but make it compile: map . snd $ ("hello", (+2)) [1,2,3,4]
14:20:03 <emmanuel_erc> the final output should have matrices of different types (Matrix Double and Matrix CInt).
14:20:12 <jle`> otacon89: that's not really how $ works
14:20:17 <jle`> f $ x = f x
14:20:20 <jle`> apply the function f to the value x
14:20:31 <jle`> so you'd be applying (map . snd) to some value
14:20:36 <jle`> but:
14:20:37 <jle`> :t map . snd
14:20:38 <emmanuel_erc> Would learning more about arrows be the right way to go?
14:20:39 <lambdabot> (a1, a -> b) -> [a] -> [b]
14:20:45 <kadoban> otacon89: The problem with that is that there ("hello", (+2)) must be a function, which it's not. Since you're apply an argument to it
14:21:01 <jle`> otacon89: (map . snd) is a function that needs two more values to be 'fully applied'
14:21:14 <otacon89> yup, i get that. how do i accomplish what i want?
14:21:22 <jle`> emmanuel_erc: `fromRows *** fromRows` would work
14:21:50 <jle`> otacon89: what i wrote earlier would work, but it's a bit verbose
14:21:52 <emmanuel_erc> Lol.... I sometimes overthink things. Thanks!
14:22:03 <jle`> but, a lot of people consider $ to be bad style, anyway
14:22:14 <jle`> better to be learning how to avoid using $, than learning how to force it in to awkward situations :)
14:22:34 <koz_> I have [([Foo], [Foo])], and I want ([[Foo]], [[Foo]]). How would I do that?
14:22:39 <otacon89> kadoban / jle`: is it possible to pass both arguments in the second? for example map . snd $ ("hello", <both arguments here>)?
14:22:41 <EvanR> should be using ¬¢ instead
14:22:46 <EvanR> its more humble
14:22:52 <Welkin> I tend to use $ at the end of a long composition, siuch as: f . g . h . x y . z $ 1
14:23:02 <jle`> otacon89: you can uncurry (map . snd), i guess
14:23:05 <jle`> :t uncurry (map . snd)
14:23:06 <lambdabot> ((a1, a -> b), [a]) -> [b]
14:23:12 <jle`> uncurry lets you give both values "at the same time"
14:23:16 <jle`> > uncurry (+) $ (1,2)
14:23:18 <lambdabot>  3
14:23:29 <jle`> but that's also slightly silly, becuase you could just write:
14:23:32 <jle`> > uncurry (+) (1,2)
14:23:33 <lambdabot>  3
14:23:40 <jle`> by slightly i mean very :)
14:23:58 <emmanuel_erc> So far, I have only learned how to use arrows to make functions on tuples easier to write and think about.
14:23:59 <jle`> but yeah, if you want to give a function both of its arguments at once, you could use 'uncurry' and pass in the tuple
14:24:07 <emmanuel_erc> I realize there is more to the story here.
14:24:17 <jle`> emmanuel_erc: most of the story isn't practical/relevant to the day-to-day
14:24:32 <kadoban> emmanuel_erc: Well if you're talking about Arrow, it's pretty rarely used. Though I don't really understand what you're doing, so I'm not sure if it's a good idea or not.
14:24:38 <jle`> emmanuel_erc: in fact, i think the preferred abstraction for tuple manipulation stuff these days is Bifuntor 
14:24:42 <jle`> instead of (***), use bimap
14:24:55 <otacon89> jle` what are some good resources to learn . and $. i've read the definitions, but it isn't helping. i want to grok it and need practice
14:24:58 <emmanuel_erc> is bimap lazier or stricter? Or is it just a better abstraction?
14:24:59 <jle`> > uncurry (map . snd) $ ( ("hello", (+2)),   [1,2,3,4] )
14:25:01 <lambdabot>  [3,4,5,6]
14:25:24 <jle`> but that's just
14:25:27 <jle`> > uncurry (map . snd) ( ("hello", (+2)),   [1,2,3,4] )
14:25:29 <lambdabot>  [3,4,5,6]
14:25:48 <kadoban> emmanuel_erc: Bifunctor abstracts over the "tuple" part, so you can use stuff like Either instead. Arrow abstracts over the (->) part, so you can use stuff like Kleisli instead ‚Ä¶ which is kind of rarer.
14:25:48 <jle`> otacon89: i don't think you should stress yourself out too much about learning about them in a vacuum
14:26:04 <kadoban> Arrow is far more powerful of course, but if you're just using it as a cute tuple library thing ‚Ä¶
14:26:07 <jle`> emmanuel_erc: it's a more natural generalization, i think
14:26:36 <jle`> especially if all you want to do is tuply stuff
14:26:49 <jle`> using Arrow just to do tuple manipulation is a bit extreme
14:26:58 <jle`> like kadoban mentioned :)
14:27:02 <Welkin> lol
14:27:07 <emmanuel_erc> I use the function Monad quite a bit to simplify my code (really make it more terse). Is Arrow better for that type of shenangians?
14:27:07 <jle`> otacon89: just try to understand when people use (.) in real life
14:27:11 <Welkin> I only learned Arrow for using Netwire
14:27:23 <Welkin> then I just used it for tuple manipulation
14:27:26 <jle`> emmanuel_erc: i wouldn't think so
14:27:54 <jle`> otacon89: but for the most part, you can always avoid using $, and it's often cleaner
14:28:00 <Welkin> it is a pain to remember which combinators are which though
14:28:02 <Welkin> I always forget
14:28:05 <jle`> if you see blah blah $ blah blah, know that it's just (blah blah) (blah blah)
14:28:06 <Welkin> so I don't use them anymore
14:28:36 <emmanuel_erc> Yeah... there is always pointfree.io though
14:28:40 <kadoban> Some of them are still pretty cute, like &&&, some of the ArrowChoice stuff, etc. But mostly Bifunctor is enough.
14:28:42 <jle`> most of the usages that Arrow was envisioned for when it was canonicized into `base` have now been subsumed by the more natural/intuitive Applicative interfaces
14:28:47 <koz_> I have [([Foo], [Foo])], and I want ([[Foo]], [[Foo]]). How would I do that?
14:28:58 <jle`> koz_: unzip?
14:29:07 <koz_> :t unzip
14:29:08 <lambdabot> [(a, b)] -> ([a], [b])
14:29:16 <koz_> Wow, that easy huh. Thanks jle`!
14:29:19 <jle`> np!
14:29:30 <jle`> :t uncurry zip
14:29:31 <lambdabot> ([a], [b]) -> [(a, b)]
14:29:40 <jle`> :t unzip . uncurry zip
14:29:42 <lambdabot> ([a], [b]) -> ([a], [b])
14:30:01 <jle`> interestingly enough, they don't form isomorphisms
14:30:07 <jle`> as their name might imply
14:30:11 <jle`> but, oh well
14:30:16 <jle`> :t uncurry zip . unzip
14:30:17 <lambdabot> [(a, b)] -> [(a, b)]
14:31:05 <jle`> John[Lisbeth]: main = echo
14:31:08 <koz_> That's a really neat function. I'm gonna have to remember that one.
14:31:25 <jle`> there's also unzip3 etc. and friends
14:31:54 <John[Lisbeth]> oops
14:31:55 <jle`> but those are slightly less useful because if you're using 3-tuples/4-tuples etc., you should probably be rethinking things, heh
14:33:39 <John[Lisbeth]> sprungeus/NfTL
14:33:58 <John[Lisbeth]> sprunge.us/NfTL
14:34:09 <hpc> i hear that's the new web standard
14:34:13 <hpc> NFTL plus sprungeus
14:34:16 <Welkin> John[Lisbeth]: wtf does that mean?
14:35:14 <glguy> John[Lisbeth]: Are you hoping that echo will execute when this file is loaded because it is on its own line at the end?
14:35:57 <John[Lisbeth]> glguy: it depends on what you mean by "on its own line"
14:36:34 <glguy> In any case, in Haskell you define a main. This main is what is executed when you run your Haskell program
14:37:02 <glguy> you can't have raw expressions at the top-level like that (unless you're doing Template Haskell, which you aren't)
14:38:08 <sleblanc> John[Lisbeth], the point is: Haskell is not a script language. You have to compile it and it needs a "main" function to run.
14:38:34 <EvanR> what, you can write all kinda scripts with haskell!
14:38:40 <exio4> sleblanc: use https://github.com/EXio4/nitrun ! :P 
14:39:13 <Hijiri> main action
14:39:15 <sleblanc> heh! I mean, the Haskell one writes for GHC.
14:40:03 <EvanR> exio4: cool
14:41:55 <John[Lisbeth]> stack ghci HSH RET :l script
14:42:56 <otacon89> `jle / kadoban: thanks
15:02:49 <mgsloan> BTW it's also good to know about "stack exec ghci" - it'll have the right package DBs but won't load any configuration from your cabal files or do any package hiding.  Good for messing around with your dependencies / loading little scripts that don't use your code 
15:04:15 * mgsloan has considered adding something like "stack ghci --bare" or "stack ghci --plain" or something to make it more discoverable, but i don't like those flag names 
15:06:32 <timbod7> what is current best practice for easy to use cryptography in haskell? I wan't to store some data in the file system, encrypted by a keyphrase. I guess I'm looking for something akin to python's simplecrypt: https://github.com/andrewcooke/simple-crypt. 
15:06:44 <John[Lisbeth]> sprunge.us/eFMF
15:07:35 <John[Lisbeth]> timbod7: SHA256 should be good
15:07:49 <John[Lisbeth]> make sure you know your primes
15:08:25 <John[Lisbeth]> or AES256 I mean
15:08:32 <kadoban> timbod7: Last I looked, the state of crypto stuff in haskell wasn't very good, I'd personally be pretty wary of using any of the stuff people actually use.
15:09:50 <timbod7> John[Lisbeth] : If You‚Äôre Typing the Letters A-E-S Into Your Code You‚Äôre Doing It Wrong (https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2009/july/if-youre-typing-the-letters-a-e-s-into-your-code-youre-doing-it-wrong/)
15:10:07 <koala_man> is there an interface to symmetric gpg or something?
15:10:15 <kadoban> Neither SHA256 or AES256 have much to do with primes either ‚Ä¶
15:10:33 <John[Lisbeth]> I could be wron
15:10:41 <timbod7> lots that I've read suggest that without a whole lot of experience, I probably can't write safe code making use of low level crypto algorithms.
15:11:31 <kadoban> timbod7: That's probably true. Crypto isn't something you do on a lark really, it's far easier to get wrong than it is to get right, and it tends to be *terrible* when you get it wrong. Also you'll have no idea, unless you're an expert.
15:11:45 <Hijiri> John[Lisbeth]: main is defined like a normal definition like any other definition
15:11:55 <koala_man> the more you learn about crypto, the harder it seems
15:11:55 <Hijiri> you don't put main=(everything else)
15:12:14 <Hijiri> I think what you want is main = echo (and no echo by itself on its own line(
15:12:29 <timbod7> kadoban: yes. I get that. Which was why I was hoping for a simple solution.
15:13:19 <kadoban> timbod7: Yeah, it's a good thought if you're going to do crypto, use a library ‚Ä¶ just last I knew, none of the haskell ones made me feel all safe and snuggly, they mostly seemed like "someone wrote this ‚Ä¶ nobody has really checked if it actually does anything right"
15:13:33 <timbod7> There's an interesting blog post from the author of pythons simplecrypt, describing the challenges in getting the code correct even though it is just assembling lower level crypto components.
15:14:15 <timbod7> here is it: http://www.acooke.org/cute/WhyandHowW0.html
15:15:36 <kadoban> timbod7: Anyway, if you must do it in haskell ‚Ä¶ just be careful and don't assume that because a library exists or is used, that anyone made sure it's actually like ‚Ä¶ correct or anything.
15:17:50 <timbod7> It's a bit embarassing that python appears more mature in this space that haskell
15:22:00 <shashwat> Hi guys. I am from a python background and considering learning haskell. Did learning haskell help you design better systems?
15:22:49 <hpc> yes
15:23:20 <shashwat> could you elaborate a little?
15:24:30 <hpc> you get away with a lot fewer shennanigans that other languages would happily accept
15:24:47 <hpc> like foo = foo['bar']
15:24:47 <Sornaensis> haskell made me stronger
15:24:54 <Sornaensis> like it gave me gains IRL
15:24:58 * Sornaensis flexes
15:25:36 <koala_man> shashwat: yes, my code in all languages is better now. more modular, cleaner separation of logic and io, more conscious of context and scope
15:25:43 <roberth> Haskell as a language has rather few compromises, which is pleasant to work with and for me raised the bar on what any system should feel like
15:25:49 <hpc> it gives names to a lot of major concepts that few other languages take full advantage of
15:26:18 <hpc> like applicatives
15:26:48 <Zekka|Sigfig> shashwat: I don‚Äôt think a lot of the things Haskell will require you to care about are actually that important to writing good programs ‚Äî its builtin typeclass hierarchy is pretty unique to Haskell
15:27:13 <Zekka|Sigfig> But you should probably work with some statically-typed language if not Haskell
15:27:50 <hpc> counterpoint: very few static languages take advantage of the benefits being static-typed gives you
15:28:07 <hpc> one could say C is static-typed, but it has very few instances of forcing you to make the types work
15:28:17 <hpc> it's more of a size-typed language
15:28:31 <exio4> hpc: all languages are static typed, some just have trivial type checkers!
15:28:37 <hpc> it has a 1-byte type, 2-byte type, processor-size type, ...
15:29:10 <dmj> exio4: javascript's typechecker is 'id'
15:29:18 <exio4> const True, you mean? :P 
15:29:28 <Zekka|Sigfig> shashwat: Haskell‚Äôs going to make you think about separating IO from program logic, and about exactly how thing X gets to know about thing Y, but imho the tools Haskell gives you to do this are pretty cumbersome
15:29:41 <dmj> no 'id', :] it makes more sense because it makes less sense
15:29:52 <exio4> heh
15:30:08 <Zekka|Sigfig> IORefs and STRefs are syntactically a little awkward but they‚Äôre close to what you can accomplish in other languages ‚Äî using monad transformer stacks to handle it is more common for general use but imho monad transformers are a big hack
15:31:12 <Zekka|Sigfig> The type system intervenes in this stuff in a mostly-useful but pretty complicated way ‚Äî I don‚Äôt know any other general purpose programming languages that make you deal with such complicated abstractions for bare-bones state management
15:31:33 <shashwat> thanks i‚Äôll start learning it. i‚Äôve mostly worked with oops languages so should be interesting to think from a functional programming point of view. any good resources you would recommend?
15:31:35 <Zekka|Sigfig> (disclaimer: IORefs are not very complicated)
15:32:03 <hpc> shashwat: learn you a haskell is fairly approachable, but has its flaws
15:32:03 <Hijiri> Zekka|Sigfig: does Idris count?
15:32:13 <Hijiri> or what about Haskell-likes like PureScript
15:32:44 <hpc> real world haskell is a bit better at teaching libraries, but i like LYAH's concept ordering better and i don't know how up to date it is either
15:32:44 <Zekka|Sigfig> Hijiri: Fair to raise! I don‚Äôt know if I would count Idris ‚Äîit doesn‚Äôt seem to be designed around being actually used right now. But I‚Äôd probably count Purescript
15:32:48 <hpc> haskell moves fairly fast
15:33:09 <Lokathor> hpc, LYAH is a rather poor book :/
15:33:11 <hpc> someone's working on another thing, but i am totally blanking on who and it's not out yet
15:33:12 <roberth> Elm should be nice, but its standard typeclasses are more precise => complicated
15:33:29 <Hijiri> hpc: bitemyapp's book?
15:33:36 <Lokathor> hpc, you're probably thinking of bitemyapp http://www.haskellbook.com/
15:33:38 <hpc> Hijiri: that's it
15:33:45 <Hijiri> there is also the stuff in bitemyapp's guide
15:33:47 * hpc reads
15:34:10 <hpc> whatever you pick, it helps immensely to have a fairly approachable and modular project you want to write
15:34:14 <Hijiri> (CIS194 + NICTA + some other things)
15:34:26 <hpc> an irc bot is a good start because it starts with some IO and then branches out into whatever you want
15:35:21 <cads> can I get stack by doing cabal install stack?
15:35:25 <barrucadu> My IRC bot was probably the project that taught me the most Haskell in the shortest time
15:35:54 <hpc> a website is another good choice
15:36:06 <monochrom> parameter passing is my major way of state management. "foldl f acc (x:xs) = foldl f (f acc x) xs" is my way of "mutating" an "accumulator state". IORef is when I simulate OOP or when I have a shared variable between several threads. (atomicModifyIORef is a thing and is for multiple threads.)
15:36:11 <hpc> you learn less IO to start, but you can go in more directions more quickly (especially starting from basic CGI)
15:36:33 <hpc> and you can jump into a framework and start learning a bit about how others structure their libraries
15:37:08 <kadoban> cads: You can in theory, yeah. I would probably recommend just downloading a binary though, or installing it via one of the instructions that haskell stack docs tell you to.
15:37:39 <shashwat> i have some machine learning stuff i want to implement. how much modular i‚Äôll be able to make it remains to be seen :)
15:37:39 <Hijiri> I used cabal to get stack and it took a very long time to build, even with 8 jobs
15:38:14 <cads> or should I just download it from stackage.org/stack for my architecture?
15:38:39 <kadoban> cads: http://docs.haskellstack.org/en/stable/README.html#how-to-install
15:38:45 <cads> yeah, I've cut the build job off
15:38:57 <cads> Going to try the binary
15:39:34 <hpc> shashwat: it's fine to have something specific in mind, but you won't be able to go "ooh i learned how to gloopledoop, lemme write a @gloopledoop command for my bot"
15:40:29 <monochrom> I once helped someone to replace thread-local IORef by parameter passing. the program sped up by about 5 times.
15:41:16 <monochrom> in fact, I replaced a loop over randomIO by one newStdGen and one randoms
15:56:50 <Axman6> monochrom: you're doing gods work
15:59:04 <latk> Is there an ubuntu based vagrantfile for stack anywhere ?
16:04:49 * hackagebot relational-query 0.8.0.4 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.0.4 (KeiHibino)
16:12:56 <John[Lisbeth]> sprunge.us/XBZX
16:13:46 <Axman6> why so many brackers and such weird spacing?
16:13:54 <Zekka|Sigfig> John[Lisbeth]: I‚Äôm a little confused, do you compile these before sending them to us?
16:14:01 <Zekka|Sigfig> Because I don‚Äôt see how this would compile ‚Äî are you asking why not?
16:14:07 <puregreen> and why are you posting seeminly the same thing for the 3rd time?
16:14:12 <Axman6> this is very very strange code
16:14:12 <puregreen> *
16:14:51 <John[Lisbeth]> The whole problem is I can't compile it. If I could I wouldn't be here because it would probably work
16:15:05 <puregreen> what error are you getting?
16:15:16 <Axman6> the code doesn't make any sense at all
16:15:47 <Axman6> you can't call import inside main, for one (or anywhere that isn't just after the module declaration/before any definitions
16:16:18 <Axman6> unless this is some weird syntax that isn't actually haskell?
16:16:35 <John[Lisbeth]> Where can I import?
16:16:46 <Zekka|Sigfig> John[Lisbeth]: On the top level at the beginning of a module
16:16:53 <Axman6> you haven't even closed the first bracket
16:16:57 <Zekka|Sigfig> (if you‚Äôre in the main module, just at the beginning of the file)
16:17:00 <puregreen> there are also 2 mains, and ‚Äúconcat‚Äù doesn't take a variable number of arguments like it does in Lisp (neither does it take 2 arguments, like in... a lisp where any function can only take 2 arguments, I guess)
16:17:24 <Zekka|Sigfig> It might help to consider that Haskell isn‚Äôt lisp
16:17:34 <Zekka|Sigfig> I am guessing that John[Lisbeth] came in from Lisp background
16:17:54 <Zekka|Sigfig> although if this were lisp some of his parens would still be invalid
16:18:32 <lpaste> glguy pasted ‚ÄúFor John[Lisbeth]‚Äù at http://lpaste.net/151707
16:21:58 <John[Lisbeth]> I think I'll steal that system.process
16:22:25 <John[Lisbeth]> though it doesn't entirely solve my issue of where to put import
16:25:34 <glguy> Your imports go before the rest of your code. The determine what names are in scope for the following program. 
16:26:25 <glguy> These aren't statements that execute at runtime, they're used at compile time
16:26:40 <glguy> so they don't go "inside" your program
16:27:22 <glguy> For contrast in a language like Lua you could write: if happy then require 'funtime' end
16:27:29 <glguy> Haskell isn't like that
16:28:13 <John[Lisbeth]> system.process fixes everything
16:29:17 <Zekka|Sigfig> John[Lisbeth]: That‚Äôs not really the only difference between your code and glguy‚Äôs code
16:32:31 <augur> so. haskell-style delimited coroutines are interesting. undelimited coroutines break my head :(
16:33:50 <hpc> one of my big "oooooooh!" moments with continuations was realizing that Cont and DelCont were both delimited continuations
16:34:07 <augur> hpc: dunno DelCont
16:34:22 <hpc> delimited continuation type
16:34:31 <augur> yeah but i mean i dont know what its defined as :)
16:34:49 <hpc> oh, it's some freaky thing straight out of a paper
16:35:26 <monochrom> they are delimited differently. there are consequences.
16:35:37 <augur> i understand the idea of continuations tho, dont get me wrong. like, i get it. its fine. hard to code with, but i get it. but undelimited ones are super hard to grok
16:35:38 <hpc> newtype CCT ans m a = CCT { unCCT :: Cont ans m a -> P ans m ans }
16:35:50 <augur> and the same is true of undelimited coroutines
16:36:07 <augur> primarily what makes it hard to grok is that its not really legitimate for them to "return"
16:36:25 <hpc> monochrom: i know, but my other point stands
16:36:28 <augur> they never return, they just run forever, so you can't think of them as funky ways of computing values, they're funky ways of *being*
16:36:41 <augur> well.. funky ways of doing? i dont know
16:36:49 <hpc> my only other point of reference for learning continuations was scheme which didn't help at all
16:36:52 <hpc> so i took what i could get
16:37:23 <augur> they're processes, not values, in an important sense, and that makes it hard to think about
16:39:20 <augur> i mean, you can think about like.. say, math or list operations in isolation of IO, right
16:40:08 <augur> but with undelimited coroutines, there's sort of no such thing, because there's no returning, there's just doing, so you have to think about how the behavior of the coroutines do something that escapes them
16:41:52 <augur> wow what was that o_O
16:43:06 <hpc> probably a server did a bad
16:45:14 * hackagebot bytestring-short 0.1.0.0 - Backport copy of ShortByteString  https://hackage.haskell.org/package/bytestring-short-0.1.0.0 (KeiHibino)
16:45:16 * hackagebot werewolf 0.4.3.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.3.1 (hjwylde)
16:45:18 * hackagebot werewolf 0.4.1.2 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.1.2 (hjwylde)
16:45:20 * hackagebot werewolf 0.4.2.2 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.2.2 (hjwylde)
16:46:28 <hpc> therewolf!
16:47:28 <geekosaur> there castle.
16:48:47 <monochrom> two versions are hanged before the real version emerges
16:49:06 <rui> Anything new in the "numeric computing" field these last months? Also data science/machine learning?
16:50:01 <ThatTreeOverTher> The Text.Markdown package parses markdown and turns it directly into HTML. It has a way to filter or modify blocks as they're being parsed, but I want to parse files and modify their data structures before immediately converting them. Is there a way to ask the package to just return the document as it is?
16:50:56 <ThatTreeOverTher> aka I want to parse markdown separately from turning it into HTML, don't want to write a new parser myself to do that
16:52:22 <geekosaur> you might want to use pandoc as a library instead?
16:52:45 <ThatTreeOverTher> thank you thank you thank you
16:53:25 <geekosaur> this looks like it's just a quick way to load markdown as html, not a full featured conversion utility
16:54:01 <ThatTreeOverTher> oh this is seriously complicated
16:54:35 <ThatTreeOverTher> I want to make an auto-linking wiki made of markdown. You'd think that wouldn't be so difficult
16:57:05 <ThatTreeOverTher> yeah, I don't know if I want to use Pandoc, as I really just want to record and then modify a markdown AST in two separate passes
16:57:19 <ThatTreeOverTher> I guess I'll just write my own parser, none of these things really help me that much
16:59:49 <sm> it shouldn't be too difficult, you might find gitit a good source of ideas
17:00:36 <ThatTreeOverTher> weird, I was going to build basically something exactly like this
17:01:00 <sm> great minds think alike!
17:01:18 <sm> by the way if you search hackage for markdown you'll see a lot of options, one of them may have an API you prefer
17:01:53 <sm> but pandoc's will be mature and featureful
17:03:34 <ThatTreeOverTher> maturity is alright but I don't want features. simplicity will make my and other editors' lives easier
17:04:05 <ThatTreeOverTher> but thanks for the tip about there being more than one package for markdown on hackage, that's super helpful!
17:04:30 <sm> pandoc's features are all configurable, I don't know about the other packages
17:20:35 <hefesto_> hi :) I am trying to serialize to json some data that I defined using Persistent (yesod), but I get an error that I really don't understand: https://gist.github.com/hhefesto/67bac2e96855d5fdfc29
17:21:10 <geekosaur> looks like you have multiple versions of "persistent" installed
17:21:47 <sm> isn't it a Maybe mismatch, rather ?
17:22:45 <geekosaur> both Expected and Actual are Maybe (Entity Users) but the fist one is fully qualified with a package version
17:22:47 <geekosaur> *first
17:23:10 <geekosaur> which usually means that something that was compiled aginst that version was handed a type from a different version
17:23:29 <sm> huh, right you are
17:23:35 <sm> damn hard reading some of these errors :)
17:25:54 <sm> what's the fix ? hefesto_, are you using plain cabal, a cabal sandbox, stack, or.. ?
17:26:20 <KaiJia> ‰∏úÂÖ´Âå∫ÁöÑÂêÑ‰ΩçËèäËã£Êó©‰∏äÂ•Ω
17:26:32 <hefesto_> sm: stack
17:26:47 <sm> does stack exec ghc-pkg list persistent show two of them ?
17:26:57 <sm> seems unlikely
17:27:08 <hefesto_> geekosaur: how can it have different versions if it is on the same cabal (stack) proyect?
17:28:06 <sm> sometimes it's old build files, stack clean is worth a try
17:28:06 <ThatTreeOverTher> KaiJia, hello from America!
17:30:07 <geekosaur> gtranslate mangles that greeting impressively
17:30:16 <KaiJia> ThatTreeOverTher : when do you go to bed
17:30:19 <glguy> KaiJia: Sorry, this is an English speaking channel.
17:31:36 <KaiJia> glguy : well
17:31:36 <ThatTreeOverTher> KaiJia, I'll probably be going to bed fairly late tonight, but most people in my timezone will go to sleep in an hour and a half, at 10pm EST
17:31:55 <peddie> KaiJia: there is #haskell-cn and #haskell.tw if you want to discuss Haskell in Chinese
17:33:47 <mgsloan> hefesto_: Are you using "stack ghci" ?
17:35:24 <mgsloan> If so, what's your stack version?  Old versions of stack's ghci isn't very reliable
17:35:35 <mgsloan> (depending on how old)
17:35:58 <hefesto_> mgsloan: yes
17:36:53 <hefesto_> mgsloan: Version 0.1.5.0
17:38:45 <mgsloan> Yeah, that's quite old, try "stack upgrade", or if you want to use the very latest, "stack upgrade --git"
17:39:27 <mgsloan> I really wish we had logic for checking for new versions (particularly in these old releases).  Been getting a lot of bug reports that turn out to be folks using old stuff
17:39:50 <mgsloan> It seems like people get directed down the route of using their distro version, which is often way out of date
17:41:56 <mgsloan> Issue about adding a check for new version to stack: https://github.com/commercialhaskell/stack/issues/1681
17:53:08 <artemis> what is a good package to link to postgress db, idealy with schema support? is Persist the defacto out there, or there something else I should take a look at?
17:54:26 <sm> no, there are others.. http://hackage.haskell.org/packages/search?terms=postgres 
17:56:39 <hefesto_> mgsloan: thanks! i'll try stack upgrade and see if that works
17:56:48 <ThatTreeOverTher> sm, I found the markdown library of my dreams: https://hackage.haskell.org/package/cheapskate
17:57:08 <sm> ThatTreeOverTher: good, what you you prefer about it ?
17:57:20 <hefesto_> sm geekosaur: thanks also!
17:58:45 <ThatTreeOverTher> sm, it's written by the pandoc author, but it's BSD, 7x faster, 5x less memory, and outputs an intermediate AST in markdown form!
18:03:50 <sm> "A cheapskate is always in search of the best markdown." :)
18:04:11 <ThatTreeOverTher> I resemble that remark! :)
18:05:25 <sm> omg http://hackage.haskell.org/package/cmark is his too
18:08:14 <ThatTreeOverTher> "82 times faster than cheapskate" well, he cheated, using a C lib instead of pure Haskell :/
18:08:36 <sm> ouch
18:08:44 <sm> that's too much
18:10:15 <bitemyapp> homeboy wrote his own parser combinator library in cheapskate
18:10:25 <bitemyapp> $50 says an attoparsec version wallops it.
18:11:08 <koz_> Is there something like a zipWith5, or am I hand-rolling that?
18:11:37 <ThatTreeOverTher> the description of cheapskate says it's faster than https://hackage.haskell.org/package/markdown, which is attoparsec based
18:11:38 <shachaf> Just zap it.
18:11:45 <ThatTreeOverTher> where's my $50 :)
18:11:55 <mauke> koz_: <*> and ZipList
18:12:42 <shachaf> > let infixl 4 `zap`; zap = zipWith ($) in (\a b c d e -> (a,b,c,d,e)) <$> "ab" `zap` "cd" `zap` "ef" `zap` "gh" `zap` "ij"
18:12:43 <koz_> mauke: I'm not sure I follow, sorry.
18:12:44 <lambdabot>  [('a','c','e','g','i'),('b','d','f','h','j')]
18:14:03 <sm> interesting.. john also did the underlying libcmark, and it is the reference implementation of commonmark
18:14:50 <mauke> :t \f a b c d e -> getZipList (f <$> ZipList a <*> ZipList b <*> ZipList c <*> ZipList d <*> ZipList e)
18:14:51 <lambdabot> (a5 -> a4 -> a3 -> a2 -> a1 -> a) -> [a5] -> [a4] -> [a3] -> [a2] -> [a1] -> [a]
18:15:04 <ThatTreeOverTher> he really cares about markdown, apparently
18:15:37 <shachaf> :t \f a b c d e -> zipWith ($) (zipWith4 f a b c d) e
18:15:38 <lambdabot> (a1 -> b -> c1 -> d -> a -> c) -> [a1] -> [b] -> [c1] -> [d] -> [a] -> [c]
18:16:50 <sm> s/the reference/the C reference/
18:16:57 <koz_> shachaf: So could I build it up from zipWith by just iterating that construction over and over?
18:18:51 <cads> hey I had to bail on a stack install of ghcjs, and now I can't build. Is there any way to get `stack setup` to continue building ghcjs where it left off? Also, is there a way that I can run it with a cpu usage quota?
18:19:28 <Vyrsace> Hello everyone :)
18:19:29 <ThatTreeOverTher> your OS might provide CPU limiting features
18:19:46 <cads> I'm using "compiler: ghcjs-0.2.0.20151230.3_ghc-7.10.2" in my stack.yaml
18:21:14 <cads> ThatTreeOverTher, it spawns a lot of ghc processes, I'll have to check if I can automatically throttle them
18:21:21 <Vyrsace> Just throwing this out there, but I'm wondering if anyone in the channel is experienced with handling flash files with embedded documents? I have a little troubleshooting question.
18:22:11 <sm> cads: ulimit is the tool for that, isn't it 
18:23:10 <ThatTreeOverTher> I tried not to imply a particular OS. Then again, I assume most people here are on a Unix of some sort
18:23:32 * sm sensed the wind and took a shortcut
18:24:15 <ThatTreeOverTher> ulimit works on all descendant processes too, right?
18:24:28 <bitemyapp> ThatTreeOverTher: it's not hard to write slow attoparsec parsers.
18:29:28 <dmwit_> Vyrsace: I would be shocked if that is a Haskell question.
18:30:20 <KaneTW> what's with the recent influx of people asking not-haskell questions
18:30:21 <ThatTreeOverTher> perhaps Vyrsace is generating or parsing flash files with Haskell!
18:30:24 <ThatTreeOverTher> but probably not
18:31:08 <KaneTW> if i had to parse flash files i'd do it in haskell :v
18:31:11 <peddie> KaneTW: maybe they just see a huge channel and figure someone will know the answer?
18:31:56 <dmwit_> This meta discussion is probably also off-topic here.
18:33:14 <peddie> sorry
18:38:36 <Vyrsace> Ha! I misinterpreted this channel's purpose. I didn't realize it was an IRC channel for a programming language. I just saw a reference to this channel on this server because someone posted that people were pretty generally knowledgable, but seeing as I skimmed through the post, I probably didn't realize they were talking about knowledgable about Haskell haha
18:40:18 * hackagebot coroutine-object 0.3.0 - Object-oriented programming realization using coroutine  https://hackage.haskell.org/package/coroutine-object-0.3.0 (IanWooKim)
18:47:32 <mgsloan> cads:  It won't be able to start off where it left off, but it should recover from prior broken installs
18:54:41 <kadoban> Vyrsace: Hah, nice
19:36:50 <chokboy> Hello, I have a question about using the low level create function for parsing a region in memory pointed at by a Ptr Word8 into some type. I'm working with pcap dumps, and would love an example of how the function that the `create` function accepts is used to build the ByteString.
19:37:29 <chokboy> I know that once I have the ByteString I'll be able to take it from there, but I'm really not quite sure how to build a ByteString from a Ptr Word8.
19:38:14 <dmwit_> What `create` are you referring to?
19:40:03 <chokboy> The `create` function in Data.ByteString.Internal.
19:40:36 <chokboy> Is there perhaps a different function that would help me achieve what I'm looking for?
19:40:57 <glguy> chokboy:  http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#g:24 
19:41:38 <glguy> You'll just need to castPtr your Ptr Word8 to a Ptr CChar aka CString
19:43:50 <chokboy> Ah! Fantastic. Just what I was looking for. Should've looked further into the docs. Thanks, g1guy.
19:43:51 <dmwit_> To directly answer your question, `create` appears to use the function you hand it to basically directly scribble on the `ForeignPtr` backing the `ByteString` it creates.
19:45:02 <chokboy> Hm. I see. I think packCString is definitely what I'm looking for though. Thanks for helping out, dmwit; I appreciate it.
19:45:32 <nshepperd_> https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Internal.html#accursedUnutterablePerformIO ^_^
19:45:34 <dmwit_> So I guess for your use you could also pass a partially applied memcpy-alike. But yes, glguy's suggestion is going to be better for everything except learning how `ByteString` works internally.
20:09:33 <nitrix> cameraLens :: Lens GameState GameState Camera Camera
20:09:41 <nitrix> cameraLens f gs = \gs -> gs { camera = f $ camera gs }
20:10:00 <nitrix> I was hoping this would typecheck but it doesn't.
20:10:12 <nitrix> Apprently the type that it should be is:    cameraLens :: Functor f => (Camera -> f Camera) -> GameState -> f GameState
20:10:18 <nitrix> Where does that functor come from?
20:14:08 <nitrix> Anyway... I used typed holes and implemented it as: cameraLens f gs = (\c -> gs { camera = c }) <$> (f $ camera gs)
20:14:19 <nitrix> But I just don't get it. My implementation is probably disgusting too.
20:14:38 <oldmanmike> Why couldn't simple ol functions work?
20:14:57 <oldmanmike> Aren't you just transforming the Camera in the GameState?
20:15:43 <oldmanmike> Like f :: GameState -> Camera -> GameState
20:16:58 * nitrix scratches head.
20:24:29 <Hunter_> hi guys i have a few question , im a backend programmer ..learning haskell be usefull to me? from a business point of view? can hi hope making money with this language anytime soon? im 35 years old right now
20:26:39 <monochrom> no
20:27:10 <monochrom> a good MBA school is a much more certain way to make more money
20:27:52 <Hunter_> what i mean is ..will it be used enough soon to find jobs using that language 
20:30:06 <CoconutCrab> I don't think that will happen soon
20:30:09 <nineonine> parsec question here : lets say i have a sum datatype with 5 data constructors and im parsing some strings. I want to have a function that returns a value of that type, but constructed differently depending on a parsec combinator that was successfully used 
20:30:28 <nineonine> any suggestions on that ? thanks !
20:31:37 <nineonine> another thing to keep in mind is that i would need to use parsed values from applied parser and they have different arity
20:31:50 <nineonine> sometimes it can be just char
20:32:11 <nineonine> but sometimes it can be int and string
20:32:52 <nineonine> and i need thoes values to construct a value of particular type
20:34:26 <Hunter_> ok ,thanks
21:00:29 <heartlessnobody> what are the chances of body switching/altering technology being devleped in my lifetime (i'm 10)? i don't like being a ginger and would like the body an english or italian boy
21:01:20 <Axman6> that sounds like mutation, and that's something that we frown upon in Haskell
21:03:09 <ReinH> heh
21:03:44 <Axman6> 1cloning on the other hand is fine, you can make all the modifications you want to the clone
21:05:24 <nitrix> I don't know, body switching might have side-effects.
21:16:01 <binh>   
21:25:23 * hackagebot text-show-instances 3 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3 (ryanglscott)
21:25:25 * hackagebot text-show 3 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3 (ryanglscott)
21:29:16 <Big_G> Are there any best practices for combining values from inside a monad to another monadic value?
21:30:08 <ThatTreeOverTher> how do you mean?
21:31:48 <Big_G> ThatTreeOverTher, I'm calling to external services with Wreq and want to put some information from those requests into an object
21:33:38 <Axman6> "inot an object"?
21:34:08 <Big_G> I have a data type with a few fields
21:34:54 <ThatTreeOverTher> are you asking about IO a -> a ?
21:35:48 <Big_G> ThatTreeOverTher, Something more along the lines of "IO Wreq Response -> IO Wreq Response -> IO customObject"
21:38:01 <ThatTreeOverTher> so you want to transform a value under IO from one thing into another
21:38:48 <Big_G> Yeah. Although getting inside the WreqResponse has been more difficult than I'd like
21:39:26 <stampsrule_> Hi I need some help writing some Haskell code (or a small section written for me) how do I get help on here?
21:39:42 <Big_G> stampsrule_, Depends. What do you need help with?
21:39:53 <ThatTreeOverTher> stampsrule_, ask questions, get answers
21:41:01 <Big_G> ThatTreeOverTher, Does my question make sense now?
21:41:27 <stampsrule_> I have associated files that would help with actual code but 
21:41:27 <stampsrule_> Game play. The game is played by playing each round with a play by both the black and white strategies (a function type Chooser = GameState -> PlayType -> Player -> IO (Maybe [(Int,Int)]).) by a call of the form (chooser state¬†Normal¬†player).¬†If one or both of the players moves a pawn into the far row from which they started, then a second "sorta round" is played in which the pawn(s) is (are) either upgraded to a knight or the
21:41:45 <ThatTreeOverTher> Big_G, it does, I just haven't had the opportunity to use Wreq :)
21:41:53 <stampsrule_> data Played = Played ((Int, Int), (Int, Int)) -- ^ A "normal" move.             | Passed                          -- ^ A (legal) pass.             | Goofed ((Int, Int), (Int, Int)) -- ^ An illegal move, penalty applied.             | Init                            -- ^ No one has moved yet.             | UpgradedPawn2Knight (Int,Int)   -- ^ A pawn reached the other side when <2 knights.             | PlacedPawn ((Int, Int), (Int
21:41:59 <lpaste> adas pasted ‚ÄúParser problems.‚Äù at http://lpaste.net/151711
21:42:00 <pavonia> Big_G: You could probably use the Applicative cominators or liftM functions
21:42:12 <adas> can someone please take a look at that?
21:42:15 <adas> ^^^^
21:42:20 <ThatTreeOverTher> stampsrule_, if you have a long piece of text, please paste it http://lpaste.net/new/haskell 
21:42:33 <stampsrule_> oh ok
21:43:29 <Big_G> pavonia, Have you used Wreq before?
21:43:55 <pavonia> No
21:44:14 <jle`> is there a way to write a case statement so it wouldn't take two extra levels of indentation for a do block in the result?
21:44:16 <jle`> case foo of
21:44:19 <jle`>   Bar -> do
21:44:21 <stampsrule_> http://lpaste.net/151712
21:44:23 <jle`>     ...
21:45:09 <jle`> is there a way for it to take 0 or 1 indentation levels?
21:45:25 <EvanR> use { ; }
21:45:47 <pavonia> adas: What is ‚Ü• ?
21:46:00 <adas> fmap
21:46:03 <adas> <$>
21:46:12 <adas> my editor does that
21:47:01 <ThatTreeOverTher> So what's the question you need answered?
21:47:34 <jle`> EvanR: ew ;_;
21:47:46 <adas> the question is, if I have multiple "Event" then I cannot change the instance based on the event
21:48:02 <adas> meaning I can only have one "instance FromNamedRecord Count"
21:48:21 <adas> But I want the instance to change based on the Event type
21:48:28 <stampsrule_> the first line of text
21:48:38 <pavonia> adas: You'd case-branch over the event name then, no?
21:49:05 <adas> yes, but I do not know the event before hand
21:49:23 <pavonia> Where does the event com from?
21:49:50 <adas> the user of the library creates the Event based on the column headers in his CSV file
21:49:59 <pavonia> Actually, I don'T understand what you are trying to do there
21:50:21 <adas> so in the csv file if there is a column called "Date", then Event "Date" is of type Event
21:51:16 <adas> im trying to write a library that parses a CSV file from a specific website
21:52:10 <ThatTreeOverTher> Big_G, I can't see anything in the documentation making reference to a type IO Wreq Response. I might be looking at the wrong documentation
21:53:15 <pavonia> adas: And how does the user decide which column/event to choose?
21:53:54 <adas> pavonia: the user could choose whatever column he wants
21:53:55 <Big_G> ThatTreeOverTher, I think the IO was from another library. It's also Wreq.Response, not Wreq Response
21:54:22 <pavonia> adas: But cou Count only encodes a single value
21:54:28 <pavonia> *your Count
21:54:33 <ThatTreeOverTher> Big_G, oh, I thought you typed "Wreq Response", sorry about that
21:54:54 <adas> pavonia: yes, it is only "Count Int"
21:54:54 <Big_G> I did. That was my mistake
21:55:47 <adas> pavonia: if I make every column header in the CSV file its own type then I can do it.
21:55:54 <pavonia> adas: FromNamedRecord is meant to parse a complete row into one value, so I don'T see how you could get multiple values out of a single Int then
21:56:01 <ThatTreeOverTher> Big_G, look into the >>= and return functions
21:56:17 <Big_G> ThatTreeOverTher, Thanks but I already know about those
21:56:33 <horny-sama> Game play. The game is played by playing each round with a play by both the black and white strategies (a function type Chooser = GameState -> PlayType -> Player -> IO (Maybe [(Int,Int)]).) by a call of the form (chooser stateNormalplayer).If one or both of the players moves a pawn into the far row from which they started, then a second "sorta round" is played in which the pawn(s) is (are) either upgraded to a knight or the pawn is placed by
21:56:33 <horny-sama>  a call of the form (chooser state PawnPlacementplayer) which returns a singleton list contain the coordinate (x,y) pair indicating the chosen coordinate of the pawn. http://lpaste.net/151712
21:56:49 <Big_G> Would I be able to use either of those to combine two maybe values which returns Nothing if either of them is Nothing?
21:57:10 <adas> pavonia: what if I'm only interested in a single column? and what if that column Im interested in keeps changing?
21:57:37 <horny-sama> knock knock
21:57:51 <cads> hey I was able to get ghcjs to build with stack, but ghcjs-boot won't run without ghc installed, which apparently I do not have
21:58:22 <ThatTreeOverTher> horny-sama, we're not going to do your assignment for you. If you ask us specific questions, we'll answer them
21:58:26 <cads> any way to use stack to install the right version of ghc locally?
21:58:38 <adas> so right now I might be interested in only the "days" column then I would have an 'Event "days"' and do parseNamedRecord r = eventParser (Event "days") r
21:59:06 <ThatTreeOverTher> horny-sama, hopefully I'm not coming across as harsh, I don't mean to
21:59:21 <pavonia> adas: I don't think that's possible as you can't pass the information to the parser in which column you are interested for the next record
21:59:21 <adas> but say I only want the column "nights", then I would have an 'Event "nights"' and do parseNamedRecord r = eventParser (Event "nights") r
21:59:27 <horny-sama> ThatTreeOverTher: that really since I am asking on my behalf on my friend
21:59:28 <horny-sama> so...
22:00:09 <pavonia> adas: You#d have to parse all columns into the result value and choose then which of the fields you need
22:01:23 <ThatTreeOverTher> horny-sama, it's not about who's asking, it's about how much work that is.
22:01:44 <adas> pavonia: I don't know if im doing something wrong or if the cassava CSV library I'm using is inhibiting how I write my library
22:01:57 <horny-sama> *not
22:02:04 <EvanR> Big_G: well, yes. namely, >>
22:02:22 <EvanR> @src (>>)
22:02:23 <lambdabot> m >> k = m >>= \_ -> k
22:03:02 <adas> pavonia: how about if I make the Event type a field in the Count type?
22:03:06 <adas> I think that might work
22:04:17 <adas> that wouldn't work
22:06:34 <pavonia> adas: Still, you don't know which event to choos at the time of prasing, only after parsing is finished
22:06:59 <mgsloan> cads: Are you sure it requires ghc?  It shouldn't require ghc to boot ghcjs
22:07:13 <mgsloan> (I wrote the "stack setup" stuff for ghcjs)
22:07:30 <pavonia> adas: Maybe you would like to explain which problem you are trying to solve?
22:10:55 <adas> pavonia: i think my abstractions and my types that represent those abstractions are all wrong
22:11:08 <adas> pavonia: our work uses mixpanel
22:11:24 <adas> pavonia: mixpanel has a crappy UI
22:11:28 <johnsonSteward> does anyone use vim for haskell here? trying to find some script to make life simpler
22:11:42 <ThatTreeOverTher> I do
22:11:55 <adas> so we just want to download the CSV file from their site and present it the way we want it
22:12:05 <johnsonSteward> what i need is `gg=G` for whole file's indent
22:12:16 <adas> and this CSV file can have any number of columns
22:12:38 <adas> And I want to build a library that can specifically deal with mixpanel exported CSV files
22:13:43 <ThatTreeOverTher> johnsonSteward, I use this, dunno if it does what you're asking https://github.com/itchyny/vim-haskell-indent
22:15:22 <pavonia> adas: I don't know about mixpanel, but if you don't know the column names in advance, you could parse into something like Map String Int (if alls columns are Ints)
22:16:10 <adas> yea Ill have to look into doing something like that, since Cassava itself does not seem to provide that kind of fidelity
22:18:16 <cads> mgsloan, if I run ghcjs-boot it gives me "fatal: program ghc is required but could not be found at ghc"
22:19:27 <cads> mgsloan, if I run stack exec ghcjs-boot, it uses the lts-5.1 resolver but then throws "fatal: program cabal is required but could not be found at cabal
22:19:39 <cads> which is almost comical :)
22:20:01 <cads> since avoiding cabal was the whole point I used stack :)
22:22:29 <mgsloan> Can you please post the full log somewhere?
22:23:06 <adas> pavonia: thanks anyways for looking into it
22:23:18 <pavonia> No problem
22:25:47 <mgsloan> cads: Yeah, ghcjs-boot does require cabal-install. Stack automatically temporarily installs the correct  version of it that will work with ghcjs-boot (this is probably the #1 thing that makes "stack setup" for ghcjs work a lot better than doing it manually)
22:30:02 <gamegoblin> Say I had a N-tuple, and I made a function to index into it by pattern matching. What‚Äôs the runtime of that? Can GHC optimize it to a constant time lookup?
22:30:50 <EvanR> a normal tuple of normal types is a vector of pointers, so its just like indexing an array
22:31:12 <cads> gsloan, I'm trying stack setup  7.10.3 --upgrade-cabal to soo if that will download the right version of cabal to my virtual haskell environment, lol
22:32:35 <mgsloan> I have no idea what "virtual haskell environment" means, but sounds good :D
22:32:49 <mgsloan> It will do it automatically if necessary
22:33:06 <mgsloan> Please post the log of stack setup if you want me to try to figure out what's wrong 
22:33:23 <mgsloan> I cannot diagnose these things from just one line of output, I need to know what was happening when the failure occurred
22:34:15 <gamegoblin> mgsloan: thought I recognized your name, met you at a Seattle haskell group around a year ago or something
22:35:04 <mgsloan> Hey, nice!  Do you still go?  I don't make it to all the meetings, but I certainly try
22:35:29 <gamegoblin> mgsloan: Only went to that one
22:36:20 <mgsloan> Also, this bug rings a bell.  What stack version are you using?
22:36:47 <mgsloan> "stack upgrade" or "stack upgrade --git" might fix it if you're on an older version
22:37:44 <mgsloan> Also, make sure you have a node version that works well with ghcjs
22:38:09 <mgsloan> See the discssion here about node version https://github.com/commercialhaskell/stack/issues/1496#issuecomment-170293368
22:40:54 <ohad> Hi, I'm failing to install hmatrix-gsl-stats. Maybe someone can help. http://lpaste.net/151715
22:46:48 <peddie> ohad: not sure exactly why that doesn't work, but you should file an issue at https://github.com/amcphail/hmatrix-gsl-stats and try temporarily deleting the import of System.IO.Unsafe from the file in question
22:47:28 <peddie> ohad: what version of GHC are you using?
22:48:52 <cads> mgsloan, stack exec ghcjs-boot still fails, so I'm doing stack install cabal-install, which should actually build the appropriate version of cabal from lts-5.1... in theory.
22:48:57 <peddie> ohad: I suspect it's related to the version of `base` you're on or the version of `hmatrix-gsl-stats` you're trying to install; maybe try the latest hmatrix-gsl-stats (0.4.1.3) before filing an issue
22:50:14 <ohad> peddie: GHC version 7.6.3
22:53:42 <cads> gsloan, aside from stack, what is the correct way to install ghc 7.10.3 and the correct version of cabal for ghcjs? On ubuntu it's turned out to be enough of a nightmare that I'm doing it in a VM to avoid screwing my system, lol
22:54:58 <django_> what can you make with haskell
22:55:27 <pavonia> Write programs
22:55:38 <mgsloan> cads: Honestly, I could never get that stuff setup fully properly, which is one of the reasons I'm keen on stack
22:55:44 <mgsloan> (among many :D )
22:55:54 <peddie> ohad: in ghc 7.8, unsafePerformIO was removed from Foreign, so it looks like this lib will only build as-is on 7.8+
22:56:05 <mgsloan> I guess follow the instructions for installing ghc tarballs, then install a cabal-install >= 1.24
22:56:21 <mgsloan> Then build ghcjs, and boot it
22:56:22 <peddie> ohad: you can still just remove that line and build it locally if you like, or ask the author on github whether he or she is willing to support older GHCs
22:56:26 <ohad> peddie: ok, how do I update my ghc version? on linux mint
22:57:30 <cads> mgsloan,  stack instal cabal-install gave me the right version of cabal, lol!
22:57:38 <liste> ohad https://launchpad.net/~hvr/+archive/ubuntu/ghc for example
22:57:40 <peddie> ohad: I'm not familiar with linux mint, but if it's debian-based, you might be able to add this repository https://launchpad.net/~hvr/+archive/ubuntu/ghc and install newer versions to /opt/ghc/<version>, or go to the GHC site and just download a binary
22:58:00 <liste> ohad stack is also a very good option
22:58:08 <liste> it can install correct versions of ghc automatically
22:58:14 <peddie> ohad: listen to liste; sounds like this person knows a better way
22:58:20 <ohad> not familiar with stack
22:58:36 <peddie> (me neither!)
22:58:41 <ohad> can you share a link?
22:59:04 <peddie> ohad: http://docs.haskellstack.org/en/stable/README.html  I think
22:59:45 <peddie> ohad: I'm afraid I can't help you any further when it comes to stack, but I'm sure other people here can
23:10:30 <bollu> guys, I've written an interesting (in my opinion) program using diagrams
23:10:49 <bollu> it's conway's game of life on a *finite, warping* grid using comonads
23:10:58 <bollu> figuring out the comonad rules for such a structure was fun
23:11:05 <bollu> so, well, I've never seen anyone else do this
23:11:11 <bollu> can I write about it on the internet? ;)
23:11:39 <scshunt> there's a couple of articles about it, actually
23:11:39 <scshunt> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
23:11:54 <bollu> scshunt: yes, they all use inifinite grids
23:12:04 <bollu> the comonad instances are way easier to write for that
23:12:07 <jle`> write about it :)
23:12:07 <bollu> than on a finite grid
23:12:10 <bollu> yayy
23:12:11 <bollu> thanks :D
23:12:13 <jle`> i have a library doing something similar
23:12:16 <jle`> but it hasn't been published
23:12:18 <jle`> but go for it
23:12:27 <bollu> cool :)
23:12:40 <bollu> jle`: I'm sure your haskell code will be way neater >_> mine is somewhat of a mess right now
23:13:52 <jle`> this is the closest thing i think to something that is 'written' that talkes about Store with finite grids with comonads -- http://hub.darcs.net/ertes/articles/raw-file/media-processing.lhs
23:13:54 <jle`> https://jaspervdj.be/posts/2014-11-27-comonads-image-processing.html
23:14:30 <bollu> huh, thanks
23:14:32 <bollu> I'll take a look
23:14:47 <bollu> I need to use Store with this as well to memoize - but that comes later
23:15:10 <jle`> ertes in particular always emphasizes the fact that writing these things comonadically means you can defer processing of boundary/edge conditions to outside of the actual CA logic
23:15:19 <jle`> so, you define the CA logic independent of boundary/edge conditions
23:15:22 <bollu> jle`: yes, exactly
23:15:29 <bollu> jle`: as long as your duplicate does the right thing
23:15:33 <bollu> it just "works out"
23:15:45 <bollu> I had a jaw hit the floor moment when I realized I could do that
23:15:58 <jle`> yeah, or you can even choose boundary conditions too by your choice of duplicate/extend
23:16:10 <jle`> that was one of his favorite things about this he kept on waxing about, heh
23:16:18 <jle`> miss him here on irc :'(
23:16:24 <bollu> why did he stop coming>
23:16:26 <bollu> ?
23:16:41 <jle`> i mean, it's a huge productivity killer >_____>
23:16:44 <jle`> i wouldn't blame him
23:16:57 <bollu> yes, but I like it here :)
23:17:20 <bollu> okay, comonads question:
23:17:28 <bollu> I understand how they work now "philosophically"
23:17:42 <jle`> gabriel gonzalez (Tekmo) once told me --- for every minute i spend answering a question on IRC and helping an individual person, i could be writing a blog post that would help hundreds of people
23:17:55 <bollu> i.e, duplicate creates a "universe of structures" on which running operations and then extracting is equivalent to doing the same thing on the "lower" structure
23:18:06 <jle`> not being on IRC was the strictly utilitarian moral thing to do v.v
23:18:13 <bollu> however, for us to do this, we need to have a type that is parametrized by another type
23:18:20 <bollu> jle`: :P that's one way to look at it I guess
23:18:32 <bollu> so, well, if I have a type that's *not* parametrised
23:18:37 <bollu> then I can't write a comonad instance for it
23:18:49 <jle`> well the guy pumps out five blog posts a month, he takes his own medicine
23:18:54 <bollu> so, what does it mean in this case? this object "cannot evolve" ? this object "is not an object" ?
23:19:08 <jle`> well, there's MonoComonad that I wrote for mono-traversable:
23:19:30 <jle`> http://hackage.haskell.org/package/mono-traversable-0.10.1/docs/Data-MonoTraversable.html#t:MonoComonad
23:19:44 <jle`> but, it's a bit misleading
23:20:05 <jle`> from the definition of a Comonad, it's essentially a *functor* that has certain natural transformations
23:20:25 <jle`> and one way haskell functors are realized is by using type constructors
23:20:55 <jle`> so if you take your Functor to be a Functor on Hask, then the Comonads you get from those functors are the Comonad typeclass instances
23:20:57 <bollu> jle`: (only) way right? the only functors we have a endo functors that are our type constructors?
23:21:04 <bollu> are*
23:21:05 <jle`> but, there are definitely other functors in haskell besides type constructor-based ones
23:21:15 <jle`> because there are many other categories besides Hask
23:21:30 <bollu> jle`: but those are not accessible *in* Hask, correct?
23:21:41 <jle`> not sure what you mean, we have lots of functors that we use every day
23:21:54 <jle`> but aren't Functor instances, because they aren't functors on Hask
23:22:12 <bollu> jle`: which ones?
23:22:53 <jle`> one common one is `length`, which is a functor from the one-item category whose morphisms are appends, to the one-item category whose morphisms are additions
23:23:24 <jle`> (++[1,2,3]), (++[4,5,6,7]) would be morphisms in the first category, and (+3), (+4) would be morphisms in the second one
23:23:34 <jle`> and length is a category homomorphism between the two
23:23:48 <jle`> preserving composition and identity
23:24:02 <jle`> you'll find a lot of these functors-between-one-object-categories in common haskell usage
23:24:08 <amar1> Hello good people
23:24:24 <jle`> but they aren't by any means Functors because the categories they are between have every little to do with Hask
23:24:26 <jle`> amar1: hi!
23:24:27 <bollu> jle`: oh, like, abstract algebraic morphisms are also "functors". right
23:24:27 <cocreature> amar1: hello good person :)
23:24:32 <bollu> amar1: hey :)
23:24:45 <jle`> bollu: yeah.  homomorphisms
23:24:55 <amar1> I am trying to export data constructors of a data family from a module which contains one of it's instance
23:24:59 <jle`> or well, i guess any structure-preserving morphism will do
23:25:20 <bollu> jle`: right, gotcha.
23:25:22 <jle`> and no need to put "functors" in quotes, they're actually functors :P
23:25:40 <jle`> so, it's definitely possible to have a comonad from functors like those, or whole bunches of different types of normal haskell functors
23:25:41 <amar1> import My.Module( DataFamilyName(..) )
23:25:49 <jle`> there are also "abstract" categories on Hask, too
23:26:01 <jle`> that the monotraversable package attempts to provide
23:26:06 <amar1> It doesn't compile though, it says module doesn't export DataFamilyName
23:26:20 <bollu> jle`: xD yes, but I studied category theory very late - so to me, functor = things in cat. land, morphism = things in algebra land
23:26:22 <amar1> am I missing something?
23:26:24 <bollu> jle`: have to get over that
23:26:48 <bollu> jle`: I'm not sure what you mean by abstract categories
23:27:07 <jle`> like, a generalized type function F a = blah
23:27:24 <jle`> instead of just the normal type functions Maybe $ a = "Maybe a"
23:27:35 <jle`> as in, the Functor Maybe applied to the type 'a' is the type "Maybe a"
23:27:44 <jle`> s/functions/constructors
23:27:44 <cocreature> amar1: you say that you are trying to export it but then you show us an import, what does the export in My.Module look like?
23:27:59 <amar1> ah sorry typo: it's import
23:28:33 <amar1> the module exports everything actually
23:28:42 <jle`> bollu: you could really imagine your "comonad" as 'anything' as long as you define what the functor is, what the category its domain is, etc.
23:28:46 <amar1> it only have the instance of relevent type class and associated data family
23:29:26 <bollu> jle`: and follows the laws, right?
23:29:32 <amar1> But class declaration lies in some other module
23:29:53 <cocreature> amar1: hm that‚Äôs weird, it should work that way. if you paste the complete code (or at least something compilable) somewhere I‚Äôll take a look
23:30:12 <jle`> bollu: for example, monotraversable treats Text as an abtract resut of some functor F on Char, but F's domain is literally only the subset of Hask that is Char 
23:30:17 <amar1> cocreature: Sure, let me see if I can create a minimal use case
23:30:21 <jle`> and it maps morphisms in Char to morphisms in *
23:30:31 <jle`> *in Hask
23:31:03 <jle`> it's sort of a more abstract notion of a functor than an actual Functor instance, but it lets us do neat things, and it follows the laws
23:31:14 <bollu> jle`: can you use omap for String and show me what it looks like?
23:31:15 <jle`> fmap id = id, and fmap (f . g) = fmap f . fmap g
23:31:50 <bollu> jle`: would fmap (const 1) str ~= length?
23:32:02 <bollu> because the "elements" of a string are the characters?
23:32:05 <jle`> bollu: well, omap toUpper ("hello" :: Text) will return ("HELLO" :: Text)
23:32:16 <bollu> hm, neat
23:32:24 <jle`> omap can't change the type, it operates on a restricted subset
23:32:42 <bollu> right, understood
23:32:58 <jle`> so it would treat `String` as the result of some abstract functor F Char = String
23:33:12 <bollu> MonoComonad :) neat
23:33:32 <bollu> I get what you're saying
23:33:36 <jle`> yeah, i sort of wrote that into the module so i could do fast image manipulation with it, heh
23:34:23 <bollu> the usual functors that we have in haskell require us to have a type of kind (* -> *) (because category = Hask), but your library lets us create a Functor instance on something of kind *, by teaching the type what an "element" is supposed to be, correct?
23:34:55 <bollu> this is the first time I've understood what "type family" does
23:34:58 <bollu> this is enlightening
23:34:59 <jle`> well monotraversable isn't my library, but yeah, it's not a Functor instance, it's a typeclass describing the action of some abstract functor following a specific pattern
23:36:07 <cads> mgsloan, it's almost done building now - I was able to use 'stack install' to install cabal, alex, and happy, and I was able to link stack;s version of ghc 7.10.2 to the local environment, and now ghcjs-boot is building
23:36:27 <bollu> thanks for the help :)
23:36:30 <jle`> but they're actually pretty boring from a category theoretic standpoint
23:36:39 <jle`> mono-traversable is mostly designed around practical usage, heh
23:36:46 <jle`> being able to "map" over Text, ByteString, etc.
23:36:51 <bollu> quick question on literate haskell: how do you write it, and how do you convert it to markdown?
23:36:56 <bollu> jle`: yeah, I mean, it's practical
23:36:59 <jle`> and being able to fold them generically
23:37:28 <jle`> i think most text editors have some sort of lhs plugin, and for markdown conversion, there's always pandoc
23:37:29 <cads>  mgsloan I mean I was able to add ghc to the path. I added the same version that stack used to compile ghcjs
23:37:31 <bollu> also, one more comonad question: right now, we can only "duplicate" over one parametrisation (as in, we can "view" all states of one particular button in some sense)
23:37:52 <bollu> is there some way to duplicate over multiple parameters without stacking comonads up? or will I need a ComonadT to do this?
23:37:56 <bollu> (if such a thing exists)
23:38:07 <bollu> I'm not sure if I made sense
23:38:28 <cocreature> amar1: fwiw http://lpaste.net/151716 works for me
23:39:21 <jle`> bollu: i think you can do something to a similar extent with just normal functions
23:39:28 <jle`> using duplicate and fmap together
23:40:19 <jle`> or it might be even cleaner expressed with Appliative/CoApplicative
23:40:27 <bollu> jle`: yes, but the "problem" is that duplicate can only explore over one particular "axis" of evolution
23:40:38 <bollu> as in, if you think of the members of the class as an eigenbasis
23:40:49 <bollu> duplicate can only give you the objects along one axis
23:41:00 <bollu> fmap can act as translates in this space
23:41:12 <bollu> but I would like to have a duplicate that gives me *all* linear combinations
23:41:19 <bollu> my god I'm stretching the terminology gere
23:41:20 <bollu> here*
23:41:22 <jle`> i'm not sure what you mean; for a 3d image comonad, duplicate would give you all 3d axes of shifts
23:41:31 <jle`> see the spreadsheet comonad and stuff like that
23:42:03 <jle`> duplicate for Store has to necessarily range over all possible changes in the state parameter
23:42:13 <bollu> jle`: okay, let's say I want an image comonad that lets me have 2 duplicates - one that shifts the focus, and one that shifts the hue for example
23:42:33 <bollu> jle`: so in some sense, I need two comonad instances if I want to be able to access these two properties separately
23:42:44 <bollu> jle`: however, I would also like to have the ability to combine these
23:42:45 <jle`> if your image is expressed as a 3-d thing, with position and hue, then duplicate would explore all of them
23:43:06 <bollu> jle`: I would like to "separate" the explorations
23:43:10 <bollu> one that explores only position
23:43:14 <bollu> one that only explores hue
23:43:19 <bollu> and some combinator between them
23:43:21 <bollu> is that possible?
23:43:53 <jle`> you could probably implement them using fmap and duplicate
23:44:24 <jle`> but, you might be able to do something neat to those ends using CoFree and data types ala carte-style techniques
23:44:45 <jle`> i'm not sure
23:44:46 <bollu> jle`: I don't know what you're referring to. Links, please?
23:47:48 <snowowl> sorry guys, a quick question, not really sure how I'd modify what I have to print hello n number of times
23:48:17 <cocreature> snowowl: that depends on what you have :)
23:48:22 <snowowl> https://bpaste.net/show/b5af7b5190a9
23:49:06 <snowowl> i'm just trying to solve hacker rank problems in order to learn, but i seem to get stuck on the easiest things.
23:49:36 <cocreature> snowowl: you can use do notation to sequence IO actions
23:49:42 <cocreature> so use something like this http://lpaste.net/151717 (untested)
23:50:35 <snowowl> cocreature: what exactly is do?
23:50:51 <cocreature> snowowl: do you know what >> and >>= do?
23:50:56 <amar1> cocreature: http://lpaste.net/151718
23:51:04 <snowowl> nope
23:53:34 <amar1> okay again used export instead of import :(
23:55:00 <cocreature> amar1: ah you are only talking about classes with associated data types. you can‚Äôt import specific class instances
23:55:30 <cocreature> :t >>
23:55:31 <lambdabot> parse error on input ‚Äò>>‚Äô
23:55:35 <cocreature> :t (>>)
23:55:36 <lambdabot> Monad m => m a -> m b -> m b
23:55:38 <cocreature> :t (>>=)
23:55:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:56:09 <amar1> cocreature: well, I want to import specific data constructor
23:56:37 <cocreature> snowowl: so >> takes two actions and ‚Äúsequences‚Äù them whatever that means for the specific monad (IO in this case). (>>=) sequences two actions where the second can depend on the first one
23:57:07 <cocreature> snowowl: do notation desugares into a mix of >> and >>=, in particular in your case you could also write putStrLn "Hello World" >> hello (n-1)
23:57:36 <amar1> cocreature: in fact ghc suggests to do that: http://lpaste.net/151719
23:58:12 <snowowl> cocreature: thanks for the explanation
23:58:49 <cocreature> amar1: I don‚Äôt think that makes sense. the constructor only exists inside the class instance, so you can‚Äôt have it in scope without the class instance and then you run into the problem that you can‚Äôt import specific class instances
