00:12:08 <parsecChar> is heist the most advanced haskell templating engine ?
00:16:00 <levi> Depends on what you mean by "most advanced"
00:16:56 <levi> People have varying ideas on how template engines should work. If you like the way heist works, it's probably advanced enough for you!
00:17:50 <Cale> Does reflex-dom count as a templating engine? :D
00:18:25 <kadoban> Does haskell count as a templating engine? :)
00:19:09 <EvanR_> does PHP count as haskell
00:45:40 <cocreature> EvanR_: nomeata once said that it stands for powerful haskelllike programming language so I suppose it counts
00:48:17 <EvanR_> we say that the answer to whether two programs are equal is undecidable. but we say that the identity of a real number relies on its convergence toward a limit. why isnt the answer to the question of program equality also a converging yes / no sequence
00:49:08 <EvanR_> or that real comparison is undecidable
00:49:24 <EvanR_> or real identity
00:57:57 <toph> what are algebraic effects in category theory?
01:53:12 <ner0x652> Hi!
01:53:22 <ner0x652> I wrote a binary search function
01:53:35 <ner0x652> it does not work as it should
01:53:46 <ner0x652> I need some help understanding what I did wrong
01:53:52 <ner0x652> here is a gost with the code 
01:53:53 <ner0x652> https://gist.github.com/ner0x652/056c0e43952f69162680
01:55:30 <shachaf> It's very rare that binary search on a linked list makes sense.
01:56:01 <shachaf> It's also somewhat uncommon that length on a linked list -- more than once, at any rate -- makes sense. It's not the right data structure.
01:56:51 <Freundlich> ner0x652: The first case uses the 'mid' function which cannot deal with empty lists.
01:56:53 <Freundlich> So that's one mistake.
01:56:55 <ahihi> I agree with shachaf, but the problem here is that the functions left and right are not correct
01:56:56 <shachaf> In this case the reason the code isn't doing what you want is takeWhile and dropWhile. Maybe you meant to be using just take and drop.
01:56:58 <pavonia> ner0x652: takeWhile and dropWhile take a predicate applied to the elements, not the index of the list
01:57:54 <new-to-haskell> Hey, I'm new to haskell, and I am working on reading the "Real World Haskell" textbook (in addition to completing the exercies, of course). I am having trouble with installing the software necessary for the development done in the excersices. I am working on an Ubuntu 14.04 (with no connection to the internet, but with a connection to a relatively up-to-date Ubuntu repository). The trouble I am having is finding a balance bet
01:58:18 <Cale> new-to-haskell: your message was cut off at "The trouble I am having is finding a balance be"
01:58:20 <ahihi> writing list functions on [Int] is treacherous, because the compiler won't complain when you mix up lengths and elements
01:58:49 <shachaf> Well, writing list functions and using lengths or indices in the first place is probably not a good idea.
01:58:55 <ahihi> sure
01:59:06 <ner0x652> pavonia: I think they do take a predicate, isn't it?
01:59:19 <new-to-haskell> Hey, I'm new to haskell, and I am working on reading the "Real World Haskell" textbook
01:59:28 <new-to-haskell> I am having trouble with installing the software necessary for the development done in the excersices.
01:59:33 <new-to-haskell> I am working on an Ubuntu 14.04 (with no connection to the internet, but with a connection to a relatively up-to-date Ubuntu repository).
01:59:42 <ner0x652> Freundlich: how do I fix that? :-/
01:59:43 <new-to-haskell> The trouble I am having is finding a balance between following best practices for installation and not spending too much time trying to figure out how to apply the best practices to my internet-less situation.
01:59:51 <new-to-haskell> Can anyone point me to a suitable installation tutorial?
01:59:58 <pavonia> ner0x652: Yes, but the point is it's a predicate for the elements of the list. You code looks like you use it as a predicate for the indices of these elements
02:00:45 <pavonia> > takeWhile odd [1,3,5,2,4,6]
02:00:47 <lambdabot>  [1,3,5]
02:01:20 <ner0x652> pavonia: I thought that in that way I can take elements before middle element and after it :-/
02:01:31 <Freundlich> Isn't there a version of (!!) that returns a Maybe? Can't find one using Hoogle.
02:01:55 <pavonia> ner0x652: If your list is sorted, you can
02:02:17 <Freundlich> ner0x652: You need to not call !! on empty lists.
02:02:17 <ner0x652> pavonia: of course it is sorted
02:02:42 <ahihi> Freundlich: the safe package has "atMay"
02:03:04 <pavonia> ner0x652: So you probabl want something like "takeWhile (< mid)"
02:03:12 <Freundlich> ahihi: Ah, thanks.
02:03:29 <shachaf> You probably don't want that. You know how many elements you want to take. You want to use take.
02:03:41 <Cale> new-to-haskell: hmm, well, you should be able to apt-get install haskell-platform and get a bunch of stuff which will be somewhat usable until you can get to somewhere that you have an internet connection.
02:04:01 <Cale> (though how are you talking to us without a connection to the internet? :)
02:04:09 <ner0x652> Freudlich: cannot I do:  if null . length $ xs then [] else xs !! (length xs `div` 2) ?
02:04:17 <shachaf> But really you don't want to be doing any of this in the first place, on a linked list.
02:04:22 <new-to-haskell> Cale: I am currently using a seperate machine.
02:05:31 <new-to-haskell> Cale: first of all , thanks! second: I can transfer files on a USB stick, it's just a bit of a pain and so I am looking for a solution that is tried, tested and can be executed with few file transfers.
02:06:08 <Cale> new-to-haskell: Ubuntu's Haskell-related packages are almost always horribly out of date. It shouldn't be a problem for the exercises in that book (you're going to have to adapt things a bit anyway, since the book itself is also probably differently old), but for development in general, you'd probably rather have a newer GHC than 7.6.3 at this point.
02:06:24 <Cale> But it won't kill you to use it while learning :)
02:07:26 <new-to-haskell> Cale: Thanks again. Can you suggest for me a pair of (book-edition, ghc version)?
02:08:41 <Cale> I don't actually recall exactly which version of things the book used, but the changes aren't *too* major that it'll be too hard to figure out where stuff needs to be a bit different (iirc, some module names changed a bit)
02:09:00 <new-to-haskell> Cale: aplogies, this pair is available in the "getting started" section.
02:32:42 * hackagebot erlang 0.2.2 - FFI interface to Erlang.  https://hackage.haskell.org/package/erlang-0.2.2 (gombocarti)
02:37:43 * hackagebot hip 1.0.0.0 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.0.0.0 (lehins)
02:55:13 <muzzle> hi
02:55:35 <muzzle> i'm looking for a library to do simple 2d drawing in a gui window
02:56:01 <muzzle> drawing boxes and lines in color (best with some antialiasing) would be sufficient
02:56:15 <muzzle> a high level API would be preferred
02:56:23 <parsecChar> I have a situation where one of my *.hs files uses {-# LANGUAGE CPP #-} and uses a #include "blahblah"; now when I build the project under cabal, all works fine; but when I try to build it under stack, it's appearing as if stack is NOT putting the directory taht contains my *.cabal file into the include list
02:56:30 <parsecChar> is this a known problem or am I doing something wrong?
03:07:22 <jle`> parsecChar: you might want to try #haskell-stack too if you can't find an answer here :)
03:11:59 <parsecChar> jle` : oh, I figured it out
03:12:05 <parsecChar> jle`: by editing stack.yaml
03:12:28 <parsecChar> now I'm trying to figure out why vim , on C-p, is not executing <esc>:w<cr>:GhcModCheck<cr>
03:20:08 <maybefbi> im looking at web framework benchmarks: https://www.techempower.com/benchmarks/#section=data-r12&hw=peak&test=update and haskell only does well for JSON serialization. even for single queries haskell is not good. is this true?
03:39:30 <pavonia> maybefbi: How many Haskell packages have been tested there? For example, I can't find aeson in the JSON serialization list, though it is the de facto standard package used for this n Haskell, AFAIK
03:39:58 <maybefbi> pavonia, only wai, snap and yesod are tested
03:40:27 <maybefbi> wai does JSON serialization well. snap does single queries ok.
03:40:40 <maybefbi> snap does multiple queries poorly
03:40:46 <maybefbi> none do DB updates
03:41:11 <ggVGc> I think it's fair to say web dev in haskell probably hasn't had as much effort put into it as i.e nodejs or apache/php
03:41:14 <ggVGc> etc.
03:41:48 <ggVGc> these things usually have fairly little to do with the running cost of the programming language used
03:41:51 <ggVGc> since it's all about throughput
03:41:55 <ggVGc> and IO
03:42:06 <ggVGc> everything becomes IO bound way before it becomes CPU bound
03:42:44 <ggVGc> so writing "fast code" won't really help much in doing efficient web serving
03:42:45 * hackagebot threads-supervisor 1.1.0.0 - Simple, IO-based library for Erlang-style thread supervision  https://hackage.haskell.org/package/threads-supervisor-1.1.0.0 (AlfredoDiNapoli)
03:43:15 <Azel> maybefbi: Where did you see yesod's results? I've seen snap's and some for wai but I don't manage to get to yesod's.
03:43:27 <maybefbi> Azel, yesod is available in previous rounds
03:43:36 <Azel> Ok thanks!
03:43:37 <maybefbi> ggVGc, ok
03:58:25 <Aruro> suppose we have recursive definition fib n = fib (n-1) + fib (n-2) ,, why does fib 30 takes 3 sec to calculate and uses 287 megabites of space???
03:59:56 <ggVGc> Aruro: you should probably give us a runnable example and output from `time`
04:00:22 <Aruro> i mentioned output from ghci :set +s
04:00:25 <pyrtsa> Aruro: Because that definition is exponentially complex and not tail recursive.
04:00:53 <Aruro> yes but amount of space needed for fib 30 is hardly bigger than kilobytes , wrong?
04:01:07 <Aruro> even doing it on paper will take less space and time :D
04:01:33 <Aruro> i just have to unfold it maximum 30 times
04:01:52 <pyrtsa> Aruro: Wrong, you don't have anything to memoise it like that.
04:02:31 <Aruro> lets estimate, will we come to 300 megabytes order of magnitude?
04:02:50 <Nublet> fib 30 -> (fib 29 + dib 28) -> (fib28 + fib 27 + fib 27 + dib 26) -> (fib27 + fib 26 + fib 26 + fib 25 + fib 26 + fib25 + fib 25 + fib24)
04:02:51 <Nublet> etc
04:02:55 <Aruro> fib 20 uses 20 megabytes
04:03:13 <pyrtsa> What Nublet said.
04:03:19 <Aruro> Nublet: u almost came to the end
04:03:26 <rom1504> no
04:03:28 <Aruro> its really small number, 30 ..
04:03:40 <pyrtsa> Aruro: No, it was only at fib27.
04:03:48 <pyrtsa> And already 8 terms.
04:03:48 <Aruro> in one line
04:03:57 <Aruro> so , not that bad?
04:04:09 <rom1504> exponentially complex
04:04:10 <Aruro> definitely not 300 megs monster :)
04:04:18 <Aruro> does not matter, number is just 30
04:04:19 <pyrtsa> Definitely 300 megs, easily.
04:04:23 <Aruro> i did not say 3000
04:04:48 <Aruro> pyrtsa: can we estimate it?
04:04:57 <Aruro> at least handwaving?
04:05:14 <Nublet> 1 fib down -> 2 terms to compute, 2 fibs down -> 4 terms, 3 fibs down -> 8 terms
04:05:19 <pyrtsa> Aruro: http://stackoverflow.com/a/360773
04:05:23 <Nublet> so for 30 terms it's 2^30
04:05:48 <Aruro> ok its one billon terms
04:05:59 <Aruro> true, now  300 megs does not look far
04:05:59 <pyrtsa> In reality it's a bit less than 2^30 because some of the terms find the base case `fib 0` faster.
04:06:08 <Aruro> yes
04:06:24 <Nublet> that's a high end estimate, not all terms continue to expand
04:06:28 <pyrtsa> θ(1.6^n) is the result given by that StackOverflow answer.
04:06:33 <Nublet> yes what pyrtsa said
04:07:00 <Aruro> 1.6^30 = 1329227
04:07:09 <Aruro> just one meg
04:07:20 <Aruro> so each iteration takes like 1 meg of ram?
04:07:28 <rom1504> no, you're missing the θ
04:07:38 <Aruro> how big is it?
04:07:57 <Aruro> u mean its just of order 1.6^n
04:08:37 <Aruro> ok, guys, ty now seems a lot clearer
04:11:53 <Aruro> but memory mentioned by ghci is a cumulative right?
04:12:15 <Aruro> not absolute
04:12:36 <Aruro> ghci's :set +s option
04:17:53 <rom1504> Aruro: you are aware that there are much better algo to compute fibonacci ?
04:18:10 <Aruro> i am:)
04:18:42 <Aruro> i just had bad intuition to why fib 30 is sooo bad 
04:18:53 <Aruro> 2^30 makes things clearer
04:19:49 <Aruro> ghci's :set +s option shows actuall memory used by ghc or cumulative? 
04:20:41 <parsecChar> where does ## come from?
04:20:46 <parsecChar> I tried hoogling for it, but can't find it
04:21:43 <EvanR_> i would also like to know
04:22:23 <parsecChar> https://github.com/lukerandall/snap-web-routes uses ##
04:22:26 <parsecChar> I can't get my code to compile
04:22:32 <parsecChar> ##, ## where art thee ?
04:22:39 <parsecChar> whoethe exportethe thou ?
04:24:23 <Aruro> how do i force /usr/share/doc/ghc/html/libraries/index.html to refresh? i installed new libraries but they are not visible
04:24:56 <parsecChar> why should it update?
04:25:34 <Aruro> is it just base libraries coming with platform?
04:29:57 <lyxia> parsecChar: map-syntax.
04:30:08 <parsecChar> actually, it's from Heist
04:30:10 <Oejet> Aruro: The platform comes with more packages than the core packages provided by GHC: https://www.haskell.org/platform/contents.html
04:30:16 <lyxia> parsecChar: you can use http://hoogle.haskell.org to look up combinators
04:30:17 <parsecChar> I'm an idiot, Heist exports ##, and I'm using Snap/Heist
04:30:26 <parsecChar> lyxia: I couldn't find it while searching for (##)
04:30:26 <lyxia> parsecChar: Heist uses map-syntax
04:30:49 <Aruro> lyxia: i want to use locally, i thought mistakenly thats the path where hoogle creates local hmtl base
04:31:13 <Aruro> cabal has source of all packages, how do i make documentation out of them?
04:31:23 <Aruro> haddock?
04:32:36 <Aruro> Oejet: sry above was to you
04:46:45 <Aruro> http://stackoverflow.com/questions/1587635/haddock-for-cabal-installed-modules
04:47:11 <Aruro> how to generate haddock docs. im surprised documentation:True option for cabal is not default
04:47:46 * hackagebot rebase 0.5 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.5 (NikitaVolkov)
04:58:35 <camm> Hello. Can someone explain to me how printf(http://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:printf) works? I mean, that variable argument magic from PrintfType.
05:02:43 <Aruro> i dont know how printf works, but look here http://okmij.org/ftp/Haskell/polyvariadic.html
05:02:54 <Aruro> camm: see above
05:59:21 <fr33domlover> I'd like to create a DAG and then to topological sort on its vertices, with a specific removal order (the maintained set of vertices should be a stack, i.e. LIFO). Is there a graph library anyone can recommend? There seem to be few and I'm not sure which ones are good :P
06:00:24 <fr33domlover> specificall the number of edges is very small, very close to the number of vertices
06:00:37 <fr33domlover> so perhaps an association matrix is a bit of a waste
06:02:22 <muzzle> hi
06:02:44 <muzzle> i'm looking for a simple way to draw lines and boxes on a window
06:02:48 * hackagebot cgrep 6.6.3 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.3 (NicolaBonelli)
06:02:57 <muzzle> the api should preferrably be high level
06:03:08 <Rembane> muzzle: https://hackage.haskell.org/package/HGL-3.2.3.1/docs/Graphics-HGL.html like this?
06:03:18 <muzzle> but all i can find are either fairly obscure opengl bindings or 10 year old stuff
06:04:45 <muzzle> Rembane, this looks ok
06:04:46 <muzzle> thanks
06:05:25 <bergey`> muzzle: https://hackage.haskell.org/package/gloss and http://hackage.haskell.org/package/diagrams-gtk are popular
06:07:51 <average> http://haskellryangosling.tumblr.com/
06:07:54 <average> is this known ^^
06:07:56 <average> ?
06:20:35 <danilo2> Hello! :) Does anybody knows and could fastly explain the architecture of Trifecta? I'm asking mainly about the parser implementation - what are all the functions in this chain: https://hackage.haskell.org/package/trifecta-1.5.2/docs/src/Text-Trifecta-Parser.html#Parser  
06:21:39 * hodapp pages Chobbes
06:29:52 <kakadu> I have binding x declared and I want to declare x again below with another type. I get error about multiple declarations. What is the trick to avoid that?
06:30:20 <kakadu> Can I explicitly hide previous declaration before declaring the 2nd one
06:32:46 <pavonia> kakadu: You mean as a top-level definition in your module?
06:32:56 <kakadu> yep
06:33:02 <pavonia> You can't do that
06:33:16 <kakadu> hmm
06:33:28 <kakadu> can I declare module inside another module?
06:33:34 <lyxia> no
06:33:36 <pavonia> There's no previous in a module, it's just a set of function definitions
06:35:58 <kakadu> So, if I want to implement some functions using 1st strategy, than using second, than usign 3rd and paste it to IRC to ask how should I do 4th attempt to get what I need 
06:36:09 <kakadu> how can I paste the code as a single file?
06:36:39 <kakadu> (I want it to be compilable, obviously)\
06:37:06 <lyxia> you define differently named functions
06:37:44 <kakadu> and no other solution?
06:38:28 <hodapp> I'm trying to figure out what the point is of this
06:38:56 <hodapp> you can have some global value that switches your function between different strategies, and change that, I guess
06:40:51 <lyxia> right, your requirements are just weird
06:44:27 <gipp> your description is vague, but it sounds like _maybe_ you want a typeclass?
06:44:47 <kakadu> Ah, forget it
06:45:19 <kakadu> It wasn't for something concrete, just to make haskell more OCaml :)
06:45:50 <lyxia> I'm sure deep down we all want that.
06:49:52 <hodapp> does OCaml let you have multiple functions in the same module with the same name?
06:52:29 <lyxia> the last one shadows the previous definitions
06:52:52 <kakadu> And OCaml require explicit recursive annotation
06:52:58 <kakadu> requires*
06:53:53 <scshunt> kakadu: what about for mutual recursion?
06:54:11 <kakadu> let rec f x = ... and g y = ...
06:54:43 <scshunt> kakadu: you can't otherwise do mutual recursion?
06:55:12 <kakadu> AFAIK, can't
06:55:23 <scshunt> O_o
06:55:28 <quchen> scshunt: It's a speciality of Haskell that let and letrec ("let with recursion") are both grouped under "let".
06:55:38 <scshunt> ahh, right
06:55:50 <scshunt> well, Haskell allows provisional definitions
06:56:03 <scshunt> the report even allows them cross-module ;)
06:56:34 <quchen> I'm not sure what the downsides of combining let and letrec are, but the upside is that it's very convenient.
06:57:15 <quchen> I guess accidential recursion can be avoided if let is non-recursive.
06:58:08 <quchen> scshunt: If you want a place where Haskell does distinguish between recursion and non-recursion, that's in do notation, where "<-" is non-recursive.
06:58:09 <lyxia> it's annoying when you're passing state explicitly
07:16:44 <hexagoxel> use Identity monad; "<-" ~ "let _ ="
07:17:25 <hexagoxel> (but without rec)
07:20:39 <fr33domlover> Anyone has a recommendation for a graph library? "fgl" and "graph-core" seem reasonable
07:25:23 <hsk3> How do I see the current resolver for stack?
07:25:47 <hsk3> ah never mind. "stack ghci" shows it to me.
07:39:50 <rtur> Hey guys. Is there a way to run ghci in debug mode ? I've tried the -v switch bug don't get anything helpful. I am trying to run this package https://hackage.haskell.org/package/ghc-vis and have installed it as explained here http://felsin9.de/nnis/ghc-vis/installing-archlinux/ . I can load it but when trying to use it I get "ghc: dot: runInteractiveProcess: runInteractiveProcess: exec: does not exist (No
07:39:52 <rtur> such file or directory)" .. any idea which package isn't installed / properly installed ?
07:43:57 <bennofs> rtur: you might try running strace -e trace=process -f  ghci and then trying it again
07:44:11 <bennofs> rtur: that should give you some information about what exec syscall it is executing
07:44:26 <rtur> bennofs: Oh, right. Thank you.
07:46:33 <veva_88> !list
07:46:44 * geekosaur would suspect that's ghci trying to run dot. did you install that?
07:50:21 <geekosaur> hm, that page (once my crap network condescended to load it) doesn't even mention dot as a dependency
07:51:36 <bennofs> rtur: yeah, dot seems likely (the hackage package for ghc-vis depends on graphviz)
07:52:12 <rtur> geekosaur, I've tryied to google for "dot" coupled with various haskell related stuff but can't find a package . 
07:52:19 <bennofs> rtur: graphviz
07:52:37 <geekosaur> rtur, it's not a haskell packayge, it is an external non-haskell program from the graphviz suite
07:54:35 <crossroads1112> Can anyone give me an example of where ReaderT is useful? Let's say I was writing a function with the type ReaderT a IO (). Could I not just put that function in the IO monad, replacing all of the `ask` and `asks` calls with let bindings?
07:54:55 <rtur> Yey, thank you guys. Installing graphviz did the trick. 
07:55:55 <bennofs> crossroads1112: well, that function must then also take another argument. You can replace f :: ReaderT a IO () with f :: a -> IO ()
07:55:57 <geekosaur> crossroads1112, you couldnt use let bindings. no. you could in theory use IORefs, but you lose compile-time assurance that the value is written only once
07:57:03 <bennofs> crossroads1112: the problem is, when you have many functions like f that take an 'a' as an argument, it becomes tedious to pass that a around all the time. Using ReaderT makes that easier (in some cases.)
07:57:12 <gipp> crossroads1112: Reader is roughly the same as implicitly passing arguments around
07:57:40 <gipp> having ReaderT a IO () means "somewhere up the call stack of this function an `a` needs to be passed, don't care where"
07:57:47 <gipp> roughly
07:57:58 <bennofs> also, using ReaderT a IO () instead of a -> IO () allows you to use functions like sequence_ :: Monad m => [m ()] -> m () directly rather than first having to apply each of those functions to an argument
07:59:47 <crossroads1112> Thank you all very much
07:59:58 <crossroads1112> bennofs: Could you maybe give a quick example of that?
08:11:35 <bennofs> crossroads1112: you can write h = sequence_ (map f [0..10]) for example, without having to apply 'f' to the reader environment first (if you didn't use ReaderT, you would have to write something like h a = sequence_ (map (f a) [0..10]), which is arguably note so bad in this case but it can matter a lot in more complex cases)
08:20:45 <parsecChar> https://gist.github.com/anonymous/8c179330768b915c78a3 <-- why can I hit /hello and /hello2 --- but I can't hit /hello3
08:49:37 <quchen> parsecChar: We'll need more information to answer that.
08:49:44 <quchen> Such as what is wrong.
08:50:33 <kakadu> Need some  help with church numerals. I made a few attempts to get what I want but I don't like results. Maybe you have some thoughts how to detect if what I want is possible
08:50:36 <kakadu> https://gist.github.com/Kakadu/c6243d6e5bf5f228080b
09:16:42 <nitrix> How would I get from  `(f, g) x`  to   `(f x , g x)` ?
09:17:04 <nitrix> Would that be bifunctors? Actually biapplicatives?
09:18:04 <mniip> bimap ($x) ($x)
09:19:17 <nitrix> mniip: Is there cleaner?
09:19:35 <mniip> cleaner what?
09:20:03 <mniip> join bimap ($x)
09:20:21 <mniip> join bimap . flip id
09:21:22 <nitrix> I think I'll just go with \x -> (f x, g x)  ahah.
09:21:30 <nitrix> Are bifunctors actually used?
09:26:09 <quchen> Yes.
09:26:18 <quchen> They're part of Base since 7.10.
09:26:39 <quchen> Applicative, Foldable, Traversable will probably follow in a later release. Not sure what 8.0 adds.
09:27:27 <mniip> LEVITY
09:29:41 <nitrix> I know 8.0 fixes a long standing bug of template haskell on windows :P
09:29:57 <nitrix> I'll be able to use lens's TH now :]
09:30:15 <nitrix> It's painful to write the lenses manually for you game.
09:30:53 <scshunt> nice
09:31:24 <mniip> is it
09:34:05 <nitrix> mniip: It just polutes the code when you have a lot of things tied together.
09:34:08 <nitrix> e.g. gamePlayer f s = (\x -> s { _gamePlayer = x }) <$> f (_gamePlayer s)
09:43:27 <nitrix> I actually just realised that I can do gamePlayer = lens _gamePlayer (\s x -> s { _gamePlayer = x })
09:43:34 <nitrix> That's quite easier to read
09:57:55 * hackagebot postgresql-simple-migration 0.1.5.0 - PostgreSQL Schema Migrations  https://hackage.haskell.org/package/postgresql-simple-migration-0.1.5.0 (ameingast)
10:21:10 <henrytill> .9
10:33:55 <muzzle> hi
10:34:11 <muzzle> does anyone know how i can enable antialiasing when using the sdl2 package?
10:36:52 <muzzle> anyone?
10:38:22 <ARM9> raw or no
10:41:09 <Maerten_> Does anyone know how to store a Word64 value with Persistent?
10:41:36 <Maerten_> Database.Persist.toPersistValue $ (10728965855173292345 :: Data.Word.Word64)
10:41:37 <Maerten_> PersistInt64 (-7717778218536259271)
10:42:34 <WzC> question: is there a haskell package/DS out there that has a persistent/immutable *static* Map with O(1) lookup? 
10:43:08 <bitemyapp> Maerten_: Word64 has a PersistField instance
10:43:22 <bitemyapp> Maerten_: it's doing that on purpose: https://hackage.haskell.org/package/persistent-2.2.4/docs/src/Database-Persist-Class-PersistField.html#line-166
10:43:34 <bitemyapp> Maerten_: it'll just read the bits back out into Word64 out on the other side.
10:43:38 <bitemyapp> Maerten_: try the isomorphism.
10:43:43 <WzC> (maybe s.t. like cuckoo hashing on immutable Vectors or so) 
10:44:15 <Maerten_> bitemyapp: thanks, i also see now that fromPersistValue will indeed get back my original value
10:44:25 <Maerten_> i guess my mistake is making an unsigned database column
10:44:51 <Maerten_> i thought i read somewhere that word64 is unsigned.. anyway, that'll probably fix my issue
10:45:26 <merijn> WzC: eh, you mean an array? >.>
10:45:35 <bitemyapp> Maerten_: Word64 is unsigned
10:45:59 <bitemyapp> Maerten_: unsigned and signed is about what one thinks bits mean.
10:46:06 <bitemyapp> Maerten_: it doesn't change the bits.
10:46:30 <bitemyapp> Maerten_: database only knows signed, so we pretend the bits that were intended for an unsigned value are signed, but it doesn't actually change anything.
10:46:32 <WzC> merijn: yes, except that I want to index the array with elents of an arbitrary type 
10:46:49 <bitemyapp> Maerten_: all data is bits and any structure is a matter of an interpretation projected onto them.
10:46:57 <merijn> WzC: Have a function "Foo -> Int" and wrap lookups around that?
10:47:01 <WzC> i.e. I want an O(1) lookup with type: a -> Maybe a (modulo required class constraints) 
10:47:05 <bitemyapp> > ord 'A'
10:47:07 <lambdabot>  65
10:47:10 <bitemyapp> Maerten_: why is 'A' 65?
10:47:21 <bitemyapp> Maerten_: because we decided so. It has no intrinsic meaning.
10:48:22 <Maerten_> bitemyapp: yeah i kind of knew that actually. but the thing is, with signed, the range would be lets say -512 up to 512 (just making that up), but unsigned it would be 0 to 1024.
10:48:24 <WzC> merijn: yes, however I'm wondering if there is an existing way of doing the a -> Int part 
10:48:37 <ARM9> -512 to 511
10:48:45 <Maerten_> i assumed the values would be stored incorrectly that way
10:48:49 <WzC> Hashable should be able to give me s.t. like that 
10:49:07 <bitemyapp> Maerten_: you said you know that, but then you say something that indicates you don't.
10:49:29 <bitemyapp> Maerten_: if you start with the value/literals you intend as Word64, converting to/from Int64 shouldn't change anything.
10:49:32 <merijn> WzC: Depends on 'a'
10:50:23 <EvanR> the best programs are the ones that dont do anything when they run
10:50:28 <EvanR> very efficient
10:50:32 <EvanR> and safe
10:50:41 <ARM9> it's the haskell way
10:50:50 <Maerten_> well i only "kind of" knew it bitemyapp ;)
10:50:57 <ARM9> that's how we get away with using linked lists for strings :')
10:51:01 <WzC> sure, as I said, I probably need something like Hashable. 
10:51:01 <Maerten_> thanks for your help!
10:51:14 <WzC> I'm wondering if there is something like that out there already 
10:52:05 <EvanR> WzC: theres this
10:52:08 <EvanR> :t (!)
10:52:09 <lambdabot> Ix i => Array i e -> i -> e
10:52:21 <bitemyapp> Maerten_: fair enough. Hope that helped, good luck :)
10:52:43 <bitemyapp> Maerten_: there are definitely some things about Persistent that can be confusing, I remember having a hell of a time just trying to turn an Int into a SQL PK :)
10:52:58 <Maerten_> thanks!
10:53:30 <Maerten_> yes i had that too in the beginning, but it seems to be easier now with "fromSqlKey" and "toSqlKey" 
10:53:42 <WzC> Hmm
10:55:01 <EvanR> does anybody know how to generate a lazy list of digits from an infinite list of bits
10:56:49 <EvanR> or have a proof of impossibility
10:58:18 <merijn> EvanR: You need to decide how many bits constitute one digit
10:58:42 <EvanR> you know thats not a constant
10:59:02 <EvanR> but its log_2 of 10 on average
10:59:07 <merijn> EvanR: Since 4 bits is 8 values and 5 bits is 16 values, none of which map exactly to the number of digits
10:59:16 <EvanR> right
10:59:50 <merijn> Do you care about any statistical properties of the produced digits?
11:00:01 <merijn> Uniform randomness, etc.
11:00:10 <EvanR> its not supposed to be random
11:00:20 <EvanR> its supposed to be a base change
11:00:36 <merijn> Then you need to phrase your question more clearly, I think?
11:00:53 <EvanR> 0.b0b1b2b3b4... -> 0.d0d1d2d3d4...
11:01:19 <verement> EvanR: what do you envision the type signature to be?
11:01:22 <merijn> What's that mean?
11:01:28 <EvanR> [Bit] -> [Digit]
11:01:29 <mniip> EvanR, treat the incoming stream as a random real between 0 and 1
11:01:43 <mniip> baseconvert that t o your base
11:01:45 <EvanR> that is what it is
11:01:51 <EvanR> that is what im trying to do ;)
11:02:21 <verement> EvanR: could you first write [Bit] -> Digit?
11:02:22 <mniip> it's N^2 if I'm not mistaken
11:02:37 <EvanR> its not any squared, its infinite
11:02:56 <mniip> i mean computation cost
11:03:06 <EvanR> as long as it is productive i dont care
11:03:16 <mniip> ok
11:03:21 <EvanR> or else theres a reason why it cant be done
11:03:43 <mniip> multiply your stream by your base, take integer part
11:04:21 <mniip> that's the head, the fractional part is then the tail
11:04:22 <EvanR> well you get a remainder
11:04:28 <mniip> (recursively)
11:04:32 <EvanR> how do you incorporate that into the stream
11:05:16 <EvanR> converting the remainder to another infinite bit stream is possible, but adding them together results in carries coming in from infinity
11:05:27 <EvanR> that is what im struggling to understand
11:06:00 <mniip> why do you need to add them
11:06:15 <EvanR> when you multiply by 10, that is what happens
11:06:23 <EvanR> the 10 goes into each bit, so to speak
11:06:39 <mniip> also yes, infinite remainders are a thing, but they will converge if your data is random
11:07:01 <EvanR> converge is a thing with a sequence of finite results
11:07:06 <EvanR> which this isnt
11:07:24 <mniip> converge  = nondiverge
11:07:25 <EvanR> im trying to get one digit at a time
11:07:47 <mniip> in the bottom sense
11:07:57 * hackagebot language-ecmascript 0.17.1.0 - JavaScript parser and pretty-printer library  https://hackage.haskell.org/package/language-ecmascript-0.17.1.0 (AndreyChudnov)
11:08:23 <mniip> you have an irrational number, it will "just work"
11:08:32 <EvanR> uh ... huh.
11:08:43 <EvanR> how ;)
11:09:27 <EvanR> you can easily multiply the stream by a power of 2, but how do you multiply by 10
11:09:43 <mniip> if you have an infinite sequence of carries it means you've computed a rational
11:10:09 <mniip> one with a denominator of 2^n at that
11:10:27 <EvanR> it doesnt matter whether its rational or not, how do you get the 2nd digit
11:10:41 <mniip> ok, look
11:10:44 <EvanR> (or the 1st for that matter, since it requires knowing the 1st carry)
11:10:52 <EvanR> and that requires knowing the 2nd carry
11:11:25 <mniip> imagine multiply :: [Bit] -> Natural -> (Natural, [Bit])
11:11:37 <EvanR> sure
11:12:28 <mniip> generate s base = case multiply s base of (int, frac) -> int : generate frac base
11:13:43 <EvanR> can you explain your variable names, s, frac, int
11:13:55 <mniip> s is the input stream
11:14:10 <mniip> int is the integer part of product
11:14:19 <mniip> frac is the fractional part
11:14:34 <EvanR> ok thats fine
11:14:53 <mniip> it won't diverge if s is irrational
11:14:54 <EvanR> now the question is how multiply will give the correct frac
11:15:05 <EvanR> and int
11:15:22 <mniip> just do long multiplication?
11:15:51 <EvanR> i understand that you can write the function to produce a stream of numbers that when combined with inverse powers of 2, it will converge to the correct number
11:16:18 <EvanR> however the problem requires that the carries are floated all the way to the top to make the int part maximal
11:16:44 <mniip> I don't think I can type the code for that on my phone
11:16:57 <mniip> with a broken touchscreen :I
11:18:23 <EvanR> ok i see how the multiplication might work
11:20:01 <iwmrby> How can I tell the haskell console to output number not in the scientific notation?  0.09849234012853572 and not 9.8492340128533572e-2
11:20:10 <EvanR> import Numeric
11:20:19 <EvanR> :t showFFloat
11:20:20 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
11:20:40 <EvanR> > showFFloat Nothing 0.00000314 ""
11:20:44 <lambdabot>  "0.00000314"
11:21:44 <EvanR> mniip: ok so i see the lazy multiplication, by grouping terms into 1, then 2, then 3, etc... but what about carries?
11:21:47 <trubar1> How do I modify the value of one element in an accelerate array? http://hackage.haskell.org/package/accelerate-0.15.1.0/docs/Data-Array-Accelerate.html 
11:23:06 <iwmrby> EvanR: huh? I need to use a function to modify the output?
11:23:07 <mniip> you have to evaluate until you know a carry wouldn't affect preceeding results
11:23:31 <EvanR> iwmrby: the scientific notation is the Show instance, you cant change it
11:23:55 <EvanR> its using showEFloat
11:24:02 <EvanR> you can use showFFloat
11:24:09 <iwmrby> EvanR: oh. That's disappointing
11:24:19 <EvanR> mniip: how do i know how far that is?
11:24:30 <EvanR> is there some law for that?
11:24:48 <EvanR> is that even theoretically sound
11:25:04 <EvanR> what is the "max distance" of carry effects
11:25:34 <mniip> as soon as you know you're adding 0 and 0 or 1 and 1 you know what the carry is
11:25:45 <EvanR> but thats in the next step
11:25:57 <EvanR> which requires knowing the carry of the yet next step
11:26:14 <EvanR> sometimes you add 1 and 1 and 1
11:26:27 <EvanR> or 1 and 1 and 1 and 1
11:28:54 <EvanR> and if youre right, what if you never see a 0+0 or 1+1
11:32:16 <broma0> Can someone recommend a nice SQL database library that doesn't mess with my types? I won't use persistent because I cant have nice/clean "data" declarations, I have to use mkPersistent, etc. Any ideas?
11:32:57 <broma0> HDBC is a bit too low-level, and the *-simple's require positional columns
11:37:23 <EvanR> yep... that would imply that youre adding two fractions that add up to 1
11:37:41 <EvanR> which would carry into the integer part that was supposed to be correct
11:38:10 <EvanR> so the 2nd digit cant be trusted
11:38:50 <EvanR> in any case theres no criteria to stop and a-ok the next term
11:39:14 <EvanR> but this checkpoint criter 00 and 11 is news to me... cool
11:40:48 <EvanR> i guess thats why you stipulated random input data
11:42:02 <mniip> EvanR, ok I'm on a normal keyboard now
11:42:15 <mniip> basically, decompose multiplication by an integer into repeated addition,
11:42:56 <mniip> and when you do addition, at one step, you have digit a, digit b, and carry from the next pair of digits as a thunk
11:42:57 <EvanR> well... the cross method might be better
11:43:01 <mniip> and you have to return a digit and a carry
11:43:25 <mniip> sometimes, you can return a carry without evaluating the next carry's thunk
11:43:33 <EvanR> yes, always
11:43:36 <mniip> no
11:43:37 <mniip> not always
11:43:54 <roelof> Anyone who knows where I can find a CRUD tutorial with Servant ? 
11:44:05 <EvanR> you have to force the thunk to determine if the integer part is ready for export
11:44:25 <mniip> integers come in later
11:44:28 <EvanR> or to look at the integer part
11:45:12 <EvanR> you mean bit a and bit b right
11:45:17 <mniip> yes
11:45:40 <EvanR> or 10 bit a's
11:45:48 <mjrosenb> woah, I just went to write some code, and I realized I was implementing the S combinator.
11:46:11 <mniip> mjrosenb, Control.Applicative.<*>
11:46:23 <gipp> roelof: https://github.com/tfausak/factory
11:46:34 <gipp> for an extended example
11:46:44 <xshay> I want to implement Show and Eq for Text.Regex.TDFA.Regex, I'm going down the path of making a new type `data ShowableRegex = ShowableRegex String Regex`
11:46:49 <xshay> ... is that the right alley?
11:46:56 <mjrosenb> mniip: yup, that's what I'm implementing.
11:47:22 <gipp> xshay: what is the String parameter intended to be there?
11:47:38 <xshay> gipp: ah, I'm parsing a regex from a text file, so that String is the original source text
11:47:49 <mniip> EvanR, ugh, I'll just implement it
11:47:49 <xshay> (unless I can figure a way to "extract" it from the Regex object)
11:48:04 <EvanR> mniip: are you sure this is going to work or are you just speculating
11:48:14 <mniip> I am definitely sure
11:48:15 <hsk3> ghci -XNoImplicitPrelude
11:48:16 <hsk3> works fine. But
11:48:17 <hsk3> stack ghci -- -XNoImplicitPrelude
11:48:17 <roelof> gipp : Thanks, I will study this one 
11:48:18 <hsk3> doesn't work.
11:48:19 <hsk3> How do I pass XNoImplicitPrelude into "stack ghci"?
11:48:40 <scshunt> hsk3: --ghc-options
11:48:44 <EvanR> mniip: so youre suggesting to add a to itself 9 times
11:48:46 <gipp> xshay: ah, so you want to carry around the source text the whole time just for "show"? Yeah probably not the right solution
11:48:55 <gipp> but i don't really know that regex representation too well
11:49:08 <mniip> EvanR, no
11:49:16 <mniip> add a << 1 to a << 3
11:49:28 <EvanR> alright
11:49:29 <xshay> gipp: assuming I can' get a normalized representation out of the regex, I can't see how else to do it (Regex -> String matches nothing on hoogle)
11:49:36 <hsk3> scshunt: stack ghci --ghc-options=-XNoImplicitPrelude    isn't working either. It runs, but it's not picking up that option (prelude functions are still available)
11:50:17 <xshay> for extra context: I have an AST and one of the node types is regex. I want to be able to dump the AST.
11:50:18 <scshunt> hsk3: --ghc-options -XNoImplicitPrelude
11:50:21 <EvanR> so that gives you an integer part right off the bat, but the question is if there is a carry to it
11:50:45 <hsk3> scshunt: same thing. it runs, but prelude functions like "not" are still available :S
11:50:52 <luigy> ghci-options?
11:51:01 <hsk3> i did "stack ghci --ghc-options -XNoImplicitPrelude"
11:51:02 <EvanR> first column, 00, no (i think). 11 obviously yes. 10 01 you have to continue on to see
11:51:13 <scshunt> hsk3: hmm
11:51:32 <mniip> EvanR, if you have 00 or 11 you can return a constant carry
11:51:40 <scshunt> hsk3: oh, it's --ghci-options, duh
11:51:41 <mniip> if it's 01 or 10 you have to go on
11:51:46 <EvanR> until?
11:51:54 <mniip> I'll rephrase
11:52:00 <hsk3> scshunt: I love you thanks
11:52:06 <hsk3> worked
11:52:08 <mniip> if you have 01 or 10 the carry you return is a thunk depending on the next carry
11:52:23 <EvanR> which may depend on the next carry
11:52:27 <EvanR> etc
11:52:30 <mniip> yes
11:52:36 <mniip> "until" is resolved automagically
11:52:46 <EvanR> and if you add 1/3 to 2/3 it freezes?
11:52:56 <mniip> yes
11:53:03 <EvanR> i mean, the thunk isnt helping that much since im about to force the integer part
11:53:26 <EvanR> so shucks
11:53:39 <mniip> the integer part is just a specialcase
11:53:48 <EvanR> the integer part is the freaking answer ;)
11:54:00 <EvanR> its a stream of integers between 0 and 9
11:54:01 <mniip> no
11:54:03 <mniip> you need both
11:54:13 <mjrosenb> :t <&>
11:54:15 <lambdabot> parse error on input ‘<&>’
11:54:15 <mniip> you don't throw the fractional part away
11:54:17 <EvanR> and you actually want to look at them
11:54:21 <EvanR> right
11:54:22 <mjrosenb> :t (<&>)
11:54:23 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:54:37 <EvanR> but the algorithm does not always converge
11:54:47 <mjrosenb> backwards, blast.
11:55:00 <EvanR> which also makes me suspicious of doing addition in other bases
11:55:10 <mniip> it does if the input isn't a rational with a denominator of 2^n base^k
11:55:22 <EvanR> huh
11:55:31 <EvanR> 1/3 ?
11:55:41 <mniip> if the base isn't 3, it's going to work
11:55:46 <EvanR> lol
11:55:46 <mniip> well
11:56:22 <mniip> if base is not divisible by 3 I think
11:56:23 <Aruro> how do i regenerate docs of all installed packages , documentation option was off, i turned it on. ?
11:56:40 <EvanR> who needs 3, how did it become a real anyway
11:56:52 <mniip> basically the only divergence you get, is the one between 0000... and 9999...
11:57:05 <mniip> and 1/3 in base 3 is exactly that: 0.100000 vs 0.099999
11:57:40 <EvanR> so 1/10 will work
11:57:43 <mniip> yes
11:57:49 <mniip> it's successfully yield 0.3333333333...
11:57:55 <mniip> 'll*
11:58:22 <roelof> Another question : Can I run Yesod with stack exec -- yesod devel on another url then localhost ? 
11:58:28 <EvanR> so theres no pathology in base 10 ?
11:58:37 <mniip> 0.1
11:58:42 <EvanR> thats what i just asked ;)
12:00:08 <hsk3> If I import Data.Bool, why doesn't its "not" conflict with the existing prelude "not"?
12:00:12 <mniip> if your input is a random stream it's going to be irrational
12:00:15 <EvanR> .00011001100...
12:00:27 <EvanR> i can see how random streams avoid the issue
12:00:30 <mniip> hsk3, prelude's "not" is the "not" from Data.Bool
12:00:51 <mniip> if it's rational it's a repeated fraction, which means it's not random
12:01:12 <mniip> mathemagic
12:01:21 <EvanR> sure but rationals are common choices for people to pick
12:01:22 <mjrosenb> where is & defined?
12:01:27 <mniip> Data.Function
12:01:39 <EvanR> $0.10 use to be the price a coke ;)
12:01:48 <mniip> EvanR, you talked about a bitstream
12:02:03 <mniip> a random bitstream
12:02:17 <EvanR> well you stiplated random over and over
12:02:23 <mniip> damn, I want to implement it now
12:02:23 <EvanR> i agreed with the real number
12:02:42 <EvanR> yeah it should be easy to throw together
12:02:51 <EvanR> but the divergence makes it bittersweet
12:02:59 <mniip> you can't get rid of it
12:03:14 * EvanR flips a table
12:03:14 <mjrosenb> mniip: is there a way to ask lambdabot where it came from, since lambdabot obviously knows about it.
12:03:28 <mniip> uhh no
12:03:34 <mniip> you can in GHCi though
12:03:41 <mniip> :info &
12:04:01 <EvanR> mniip: isnt there some way to make it output the integer part and be ok with the answer being 0.99999999...
12:04:05 <EvanR> some trick
12:04:06 <mjrosenb> mniip: assuming I have all of lambdabots imports imported
12:04:26 <mniip> EvanR, imagine you have a stream of 1:0:0:0:0:0...
12:04:43 <mniip> if you write 0.99999999999... as the answer
12:04:53 <EvanR> that is acceptable
12:04:57 <mniip> it's not
12:05:00 <EvanR> eh?
12:05:04 <mniip> because if after a long series of zeros
12:05:06 <mniip> there's a one,
12:05:13 <mniip> the answer should have actually been 1.000000000...
12:05:23 <EvanR> oh well i took 1:0:0.. seriously
12:05:38 <mniip> you can't patternmatch an infinite series of zeros ;)
12:06:33 <EvanR> what if you change the format to be upside down?
12:06:42 <Aruro> is it possible to generate haddock docs of a given package by hand?
12:06:48 <mniip> EvanR, doesn't help anything
12:06:56 <hsk3> mniip: how do you see that Prelude's not is Data.Bool's not?
12:07:23 <mniip>  > :info Prelude.not
12:07:23 <mniip> not :: Bool -> Bool 	-- Defined in ‘GHC.Classes’
12:07:27 <mniip>  > :info Data.Bool.not
12:07:27 <mniip> not :: Bool -> Bool 	-- Defined in ‘GHC.Classes’
12:07:39 <mjrosenb> hsk3: I'm at least somewhat sure that everything in preulde is just imported from another module.
12:07:59 * hackagebot fltkhs 0.4.0.6 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.6 (deech)
12:08:21 <hsk3> interesting. and haskell is smart about it i guess. it detects the whole "module hierarchy" and doesn't count functions as conflicting if it finds the function originate in the same module.
12:08:21 <hsk3> correct?
12:08:37 <EvanR> so you need an infinite lookahead for carries precisely when the answer would involve 9999999... somewhere
12:08:41 <hsk3> even if at the "top level" they come from two different modules
12:10:38 <EvanR> mniip: wait... 1:0:0:... thats just 0.500000
12:10:52 <mniip> or 0.499999999
12:11:17 <EvanR> the first step gives a 5
12:11:27 <hsk3> mniip: ?
12:11:29 <EvanR> and theres no going down
12:11:32 <mniip> 0:1:1:1... is 0.5 too
12:11:59 <EvanR> so does anything ending in all zeros freeze up too?
12:12:02 <mniip> hsk3, yes
12:12:07 <Cale> hsk3: Yeah, if module D imports modules B and C, and both B and C import and re-export x from A, then module D can use x unambiguously.
12:12:14 <mniip> hsk3, every function has a module it's imported from and a module it's defined in
12:13:29 <hsk3> Cale, mniip, thanks!
12:24:05 <EvanR> mniip: do you happen to know if theres an analogous trick like the 00 11 pattern in other bases
12:24:19 <EvanR> to know that carries will be blocked at that point
12:25:58 <roelof> Another question : Can I run Yesod with stack exec -- yesod devel on another url then localhost ? 
12:43:00 * hackagebot graylog 0.1.0.0 - Support for graylog output.  https://hackage.haskell.org/package/graylog-0.1.0.0 (andrewrademacher)
12:43:46 <roelof> no yesod people here ? 
12:48:00 * hackagebot graylog 0.1.0.1 - Support for graylog output.  https://hackage.haskell.org/package/graylog-0.1.0.1 (andrewrademacher)
12:53:27 * hackagebot endo 0.3.0.0 - Endomorphism utilities.  https://hackage.haskell.org/package/endo-0.3.0.0 (PeterTrsko)
13:06:53 <csd_> hi-- how would i make this typecheck http://pastebin.com/HZfjNps4? seems like i need to instruct the compiler that TmSucc will always wrap another Term
13:09:04 <gipp> csd_: the type parameter of Term should encode the value type of the term
13:09:12 <gipp> having three parameters doesn't really make sense there
13:09:27 <csd_> gipp: in the function definition?
13:11:41 <xshay> csd_: TmIf can have any 3 types? Seems weird?
13:12:00 <csd_> xshay: i'm trying to translate this ocaml http://pastebin.com/AJB7xfGa
13:12:39 <xshay> ah so I think you want...
13:12:56 <xshay> data Term = TmTrue | TmIf (Term, Term, Term) | TmSucc Term | etc...
13:13:27 <csd_> oh yeah thats right
13:13:47 <csd_> thank you
13:13:55 <xshay> no worries :)
13:14:22 <xshay> argh QC is finding an infinite loop and I can't figure out how to get a stack trace
13:14:24 <xshay> stack test --test-arguments '--pattern "Quickch" --quickcheck-verbose' --executable-profiling 
13:14:33 <xshay> ctrl+c just eats it
13:17:30 <lyxia> --test-arguments +RTS -xc ?
13:18:31 <xshay> lyxia: that appears to do something, thanks
13:19:01 <lyxia> :)
13:19:03 <xshay> lol just shows all "MAIN.MAIN". Oh well, getting closer
13:20:28 <lyxia> you might need -fprof-auto, I'm not sure
13:20:34 <lyxia> at compilation
13:48:15 <askdjaslkfdfjask> ?src ($)
13:48:15 <lambdabot> f $ x = f x
13:48:41 <askdjaslkfdfjask> ?src (((\g x -> g x + g x) (\y -> y)) 3)
13:48:41 <lambdabot> Source not found.
13:49:02 <askdjaslkfdfjask> let i :: Int; i = ((\g x -> g x + g x) (\y -> y)) 3
13:49:06 <askdjaslkfdfjask> ?src i
13:49:06 <lambdabot> Source not found.
13:49:09 <askdjaslkfdfjask> i
13:57:09 <csd_> how do i pattern match on a function throwing an exception?
13:58:20 <del_> Simple question about currying:  One of the effects of currying means that if I have an f(x,y), then calling f(x_1, <undefined>) returns another function, let's call it g(y), that is effectively identical to f(x,y) except that all terms of g have an x_1 where f would have an x. And I could do stuff with g. Yes?
14:02:44 <Axman6> csd_: you can't, exceptions need to be caught using something like catch or try, they are not values which are returned by the function
14:03:36 <MitchellSalad> del_: yes, but where you wrote "calling f(x_1, <undefined>)", you should have wrote "calling f(x_1)"
14:04:04 <MitchellSalad> i.e. it's valid to pass one argument to a "two-argument" function
14:04:19 <Axman6> del_: yes, though using that awkward syntax can make it hard to think about, which is why we don't use tuples to pass arguments to functions, but juxtapostision: f x y = ...; let g = f x_1 -- g is a new function which is the same as f with all x's substituted for the value x_1
14:05:45 <del_> MitchellSalad; Axman6: Ah the lightbulb just flickered on!
14:06:06 <MitchellSalad> goodie
14:06:32 <csd_> Axman6: so how would i write the haskell equivalent of the ocaml `eval` fn here? https://books.google.com/books?id=ti6zoAC9Ph8C&lpg=PP1&pg=PA49#v=onepage&q=eval&f=false
14:07:40 <del_> So, is that effectively what currying is?  The notion that one could partially apply given values for specific arguments/variables in a defined function?
14:07:45 <Axman6> I don't know OCaml well enough to be able to tell what that's doing
14:08:09 <Axman6> del_: yes, and without it higher order functions become a pain to use
14:09:38 <MitchellSalad> del_: "currying" the verb refers to expressing a function 'f :: (x, y) -> z' as 'g :: x -> y -> z', which you can do for any f
14:10:00 <MitchellSalad> with parens, g :: x -> (y -> z)
14:10:14 <mniip> EvanR, I did it
14:10:29 <lyxia> csd_: You wouldn't use exceptions but wrap the error in a Maybe or Either
14:10:42 <lpaste> mniip pasted “EvanR” at http://lpaste.net/153551
14:11:13 <csd_> lyxia: i was hoping to avoid that because otherwise the pattern matches get kinda yucky with 3 levels of matching
14:11:52 <lyxia> csd_: this is what the Monad typeclass is for
14:11:55 <del_> Axman6, MitchellSalad: Brilliant. Thanks, gents!
14:12:03 <csd_> yeah
14:12:08 <mniip> EvanR, it's slow as hell though
14:12:55 <Axman6> csd_: use the either monad?
14:24:46 <hyuke> does anyone know if there is any kind of special functions library for Haskell? Specifically, I need an exponential integral
14:25:56 <hyuke> The SLATEC library (in Fortran) contains a nice exponential integral function that I have called from C before, but I can't quite work out the quirks of calling it from Haskell
14:43:31 * hackagebot vector-sized 0.1.0.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.1.0.0 (jophish)
14:48:04 <AfC> Would you like fries with that? We have small-size, medium-size, large-size, or vector-size.
14:48:31 * hackagebot ua-parser 0.7.1 - A library for parsing User-Agent strings, official Haskell port of ua-parser  https://hackage.haskell.org/package/ua-parser-0.7.1 (OzgunAtaman)
14:50:12 <dresuer> ¿Existe algun canal de haskell en español?
14:50:52 <hpc> https://wiki.haskell.org/IRC_channel - #haskell-es
14:51:08 <hpc> er, #haskell.es
14:51:22 <dresuer> #haskell-es está vacio ,
14:51:32 <dresuer> #haskell-es nobody there
14:51:55 <hpc> #haskell.es
14:53:55 <dsicilia> test
14:54:14 <Rembane> dsicilia: We hear you, loud and clear, over.
14:58:31 * hackagebot super-user-spark 0.3.0.0 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.3.0.0 (Norfair)
15:12:24 <adas> so I have a type like "[Maybe a]" so the possible values are [Just 3, Just 4, Nothing] or [Just False, Nothing, Just True]. But I can't do [Just True, Just 1]. Is there an extension that would allow me to do that?
15:12:32 <adas> RankNTypes?
15:13:01 <shachaf> There are some extensions that would let you do something similar, but it's often the wrong thing to want.
15:13:37 <shachaf> And it wouldn't be as convenient as you were hoping for anyway.
15:14:09 <shachaf> The right question to ask is probably what you were going to do with the values in the first place.
15:15:47 <adas> shachaf: I have a type "AgentSpec a = AgentSpec { agent :: a, events :: ByteString }". i want a function with type "f :: [AgentSpec a] -> [ByteString]" that takes all AgentSpec and returns a concatentation of all their events.
15:16:29 <adas> so "f" would be implemented like so "f = concatMap events". But I cannot get it to typecheck
15:16:39 <shachaf> Well, what would the type be?
15:17:48 <adas> shachaf: the type of 'f' would be "f :: [AgentSpec a] -> [ByteString]". And the type variable 'a' could be "data Java = Java" or "data Php = Php"
15:18:18 <shachaf> I see.
15:18:32 * hackagebot endo 0.3.0.1 - Endomorphism utilities.  https://hackage.haskell.org/package/endo-0.3.0.1 (PeterTrsko)
15:18:40 <shachaf> It's probably more standard and maybe easier to just use a list of ByteStrings.
15:18:56 <shachaf> Since getting a ByteString is the only thing you can do with AgentSpec a, if you don't know what a is.
15:21:45 <adas> shachaf: but an for the problem at hand, it makes more sense to model the agentSpec as a combination of a languages and a set of events.. isn't there any other way to accomplish this elegantly? I do not mind rewriting my entire code
15:22:16 <shachaf> adas: Well, wherever you construct the list in the first place, you might as well construct the list of ByteStrings.
15:26:05 <tippeneinn> If I put all my build-depends in a library and include that library in the executable... that should take care of the deps for the exe, right?
15:26:37 <adas> shachaf: I could do that. For instance, if I have the agentspec values 'AgentSpec Java "eventj"', 'AgentSpec Php "eventp"', 'AgentSpec Ruby "eventr"' and then be like '["eventj", "eventp", "eventr"] :: [ByteString]', but I'll simply be rewriting everything. If there is an elegant way to avoid it, i will try
15:27:30 <lpaste> tippenein pasted “No title” at http://lpaste.net/153555
15:27:52 <tippeneinn> pasted the exe and library sections of my cabal
15:28:36 <hexagoxel> tippeneinn: use different hs-source-dirs, or it won't work.
15:29:15 <tippeneinn> ahhhh, gotcha. thanks
15:29:20 <hexagoxel> because executable "prefers" to take stuff from hs-source-dirs, instead of the imported library.
15:29:30 <hexagoxel> and then you need the deps.
15:38:52 * hackagebot overloaded-records 0.1.0.0 - Overloaded Records based on current GHC proposal.  https://hackage.haskell.org/package/overloaded-records-0.1.0.0 (PeterTrsko)
16:08:19 <dresuer> Can I with a computer science degree conquer the world?
16:08:38 <Rembane> Yes.
16:08:47 <mjrosenb> dresuer: I've been trying for a while now, but no luck thus far.
16:08:54 <mjrosenb> unless you count CivII
16:09:20 <dresuer> And with a Ph. D.?
16:09:29 <dresuer> hahah
16:09:53 <Rembane> You get to go to the secret moonbase.
16:12:20 <Smargelon> Hey, I don't have any issues with Haskell, I was just looking into whether I should invest time into learning it, what sort of services would you guys characterize Haskell would be optimum for? 
16:13:12 <mjrosenb> Smargelon: anything that you want to be reliable, and have native code for.
16:14:08 <Smargelon> So just a general use sort of language, mjrosenb? Alright, I'll look into it. Thanks.
16:16:03 <dresuer> mjrosenb: keep trying
16:16:09 <dresuer> someday you will
16:21:45 <carter_cloud> I've used Haskell as a tool in all kinds of jobs and projects the past 5 years
16:21:58 <carter_cloud> Most recently ... Building a new language:)
16:27:26 <catau> Hi, I have a C struct similar to https://gist.github.com/anonymous/41992ecaba691e656e18 and I'm feeling confused about how to unpack it into a Haskell datatype. Websearching suggests options (Storeable, hsc2hs, c2hs, etc) that mention preprocessing some files?
16:28:22 <hexagoxel> catau: maybe: http://hackage.haskell.org/package/storable-static-array
16:29:17 <mjrosenb> catau: you can use the FFI directly, and implement it all yourself, if you want.
16:29:27 * mjrosenb has done this in the past.
16:31:04 <catau> mjrosenb: I haven't done FFI with C before (played with GHCJS only) but in this case the bytestrings are being posted to a Servant server, so I was hoping there's a simple-ish way to describe the struct in Haskell and unpack it directly without FFI. any suggestions? I am new to this, but is Storeable what I should be targeting?
16:37:08 <Cale> catau: Given that you have a ByteString, I would say perhaps use the stuff in the binary package to write a parser.
16:38:31 <Cale> catau: http://hackage.haskell.org/package/binary-0.8.2.1/docs/Data-Binary-Get.html has a Get monad with a bunch of ways to read out numbers and chunks of various sizes
16:39:36 <catau> Cale: thanks, that's a friendly looking option. I need to figure out how to read several chars, is there a manyOf or a specificNumberOf? I will look through the docs
16:39:52 <Cale> You can use replicateM
16:40:24 <Cale> :t replicateM
16:40:25 <lambdabot> Monad m => Int -> m a -> m [a]
16:40:44 <catau> thanks Cale
16:41:58 <Cale> You'll have to know how many bytes a long is, which is at least 4...
16:54:58 <catau> Cale, looks like getBytestring can consume my strings too (instead of replicateM with getWord8)
17:06:12 <mjrosenb> :info unsafePerformIO
17:06:21 <mjrosenb> riight, that doesn't work.
17:06:46 <mjrosenb> System.IO.Unsafe
17:32:55 <dyelift> hi, does anyone know how to run a ghcjs app inside of electron (http://electron.atom.io/)
17:33:31 <dyelift> i have js + html generated by ghcjs and i'm trying to figure out how i can package it as an application for distribution
17:33:40 <benzrf> wh-why would you do that
17:33:49 <benzrf> why not just, like, compile it with ghc??
17:34:22 <gipp> so, i want to choose a typeclass instance based on other typeclass constraints. Are the methods described in https://wiki.haskell.org/GHC/AdvancedOverlap still the accepted method, or is there a cleaner way to do this with modern language extensions?
17:34:25 <dyelift> it uses a bunch of JSFFI
17:34:35 <dyelift> and i've already written the entire web app
17:34:53 <dyelift> if there was some way to package it (for corporatet users who don't have chrome or FF, basically)
17:35:12 <dyelift> i was thinking I might be able to get this done without much additional coding
17:35:21 <dyelift> benzrf: ^
17:39:10 <aerialB> Am I alone in my feeling that Haskell has a vaguely 'futuristic' syntax (aesthetically)? Disclaimer: I am not as yet a Haskeller so it could well be an effect of unfamiliarity.
17:40:52 <dyelift> aerialB: what language are you coming from?
17:41:01 <aerialB> Python
17:46:09 <benzrf> aerialB: that's a very vague description
17:46:12 <benzrf> i think i know what you mean though
17:47:38 <aerialB> benzrf: Heh, yeah I'm aware. I suppose it's the wrong way of approaching the question, as it depends on what you consider 'futuristic'.
17:52:25 <aerialB> To which I answer: I'm not sure. Well that was eventful :)
17:54:49 <shachaf> If you want a picture of the future, imagine a machine reducing a graph -- forever.
17:55:50 <aerialB> shachaf: haha. Not quite as terrifying as the original vision.
17:56:24 <shachaf> If you'd seen the graph I've seen...
18:10:45 <aniqah> Hey! I've been fooling around with trees and have a math-related CS question. Nobody's answered me in #math and I know Haskellers are fans. Would anyone mind helping me out?
18:11:32 <shachaf> I doubt anyone wants to commit to helping you with your question without even knowing what it is.
18:12:27 <shachaf> But asking your question probably won't hurt.
18:13:20 <aniqah> shachaf: Fair enough! Didn't want to be a bother if it's too out of place. :)
18:13:22 <aniqah> I've been comparing the ratio of the total depth of a binary search tree created from random permutations of [1..n] to the total depth of a red-black tree made of the same values. Running this experiment for large values of n, many times over, it seems like this ratio is converging towards a value somewhere ~1.163. Anyone understand the math behind this?
18:15:31 <aniqah> I know it sounds assignment-y, but that's because I had an assignment on RB trees and had to implement things like the total depth. This question that I have was brought about by my own curiousity.
18:15:53 <pchiusano> aniqah: have you tried just working out the expected depth of a tree created via random permutations
18:16:09 <Guest6701> mc n   | n > 100 = n-10 | otherwise = mc (mc (n+11))
18:16:26 <Guest6701> whoops
18:16:34 <Guest6701> mc n   | n > 100 = n-10
18:16:40 <Guest6701>        | otherwise = mc (mc (n+11))
18:16:55 <Guest6701> Does any one have any idea what the posted function does?
18:17:37 <aniqah> pchiusano: Of a binary search tree or red-black tree?
18:17:57 <pchiusano> aniqah:  of a BST
18:18:35 <pchiusano> I'm not totally sure what you mean by "create a BST from random permutations", but assuming you have some procedure for that, I'm just wondering if you can compute the expected depth from first principles
18:19:23 <aniqah> pchiusano: No I haven't since the ordering is random, but I suppose taking the average of a large enough sample size might do it!
18:20:35 <aniqah> I'm more curious about the mathematical reason behind it - why the relationship between these two values (total depth of a binary search tree and total depth of a red-black tree) end up converging like this.
18:20:50 <aniqah> Whoops that sentence made no sense
18:22:07 <shachaf> Well, there are relatively narrow bounds on the depth of a red-black tree.
18:22:19 <pchiusano> aniqah: my guess is that if you work out the expected depth for both, they will be within a constant factor of each other... which becomes more clear at larger N
18:23:18 <aniqah> pchiusano: Ah, that makes sense!
18:23:30 <nanoz> hi
18:23:31 <aniqah> Any idea why they end up within a constant factor of each other?
18:23:53 <aniqah> My math background is fairly poor at the moment. :P
18:24:03 <pchiusano> aniqah: my guess would be that's just how the math works out
18:24:22 <nanoz> i'm trying to learn n-gram why we need it , how to measure it
18:25:20 <nanoz> can someone say what these unigram,bigram and trigram
18:25:30 <nanoz> why we need it
18:26:14 <pchiusano> aniqah: well, if you were working from first principles - there are factorial(N) permutations
18:28:38 <pchiusano> if the items are in reverse order, the depth is...? what if they are in order? maybe write down a bunch of other concrete cases, see if you spot any patterns... if there is an easy way of characterizing the depth just based on looking at the permutation
18:28:57 * hackagebot hpdft 0.1.0.3 - A tool for looking through PDF file using Haskell  https://hackage.haskell.org/package/hpdft-0.1.0.3 (keiichiroShikano)
18:29:40 <pchiusano> if you can come up with that, you might be able to compute the frequency of each depth fairly easily...
18:29:46 <pchiusano> or maybe that won't lead anywhere
18:30:03 <pchiusano> there might be some other trick to it
18:30:32 <pchiusano> i'm guessing that somebody has worked this out before
18:31:46 <pchiusano> aniqah: here i just found this http://cs.stackexchange.com/questions/47292/average-depth-of-a-binary-search-tree-and-avl-tree
18:32:55 <pchiusano> aniqah: this one looks better http://cs.stackexchange.com/questions/6342/proof-that-a-randomly-built-binary-search-tree-has-logarithmic-height
18:34:40 <aniqah> pchiusano: Thanks! I'll take a look.
18:35:13 <pchiusano> aniqah: that second link has a full derivation
18:35:29 <pchiusano> and the math is not scary
18:38:27 <griotspeak> (I am asking this question out of hope that there is a way, not expectation. I am pretty sure that the answer is 'no'.) Is there a way to install Platform 2014.2.0.0 using stack (so that it is sandboxed)?
18:41:14 <aniqah> pchiusano: That second link is really interesting, thanks! I do know that the expected height of a BST is in O(log n), and that RBTs guarantee O(log n) height. So I guess that in practice, the difference between the total depths is a constant factor, even though both depths are in O(log n)?
18:41:53 <aniqah> I guess part of what's tripping me up is that I'm looking at the total depth (sum of the height of each node in the tree) instead of just the tree height.
18:42:19 <pchiusano> aniqah: well, the second link gives the exact value, not just the big O
18:42:44 <pchiusano> aniqah: ahhh total depth I misinterpreted sorry
18:47:38 <aniqah> pchiusano: Yeah, no worries. :) This is what makes it an interesting question to me - it doesn't seem so straightforward!
18:47:56 <ggVGc> how could I write this without repeating myself so much? https://gist.github.com/686b2c1c1c6e01ca604b
18:48:48 <pchiusano> aniqah: not sure, total depth seems like kind of an unusual metric... but perhaps you could adapt the proof technique used to compute expected total depth
18:49:14 <aniqah> pchiusano: Maybe. That's what I'm hoping for! :) Thanks for the help.
18:49:35 <andromeda-galaxy> by the way, does anyone have a good explanation of coinduction
18:49:37 <andromeda-galaxy> ?
18:50:15 <pchiusano> aniqah: not sure how helpful I was... but okay cool :)
19:08:59 * hackagebot rotating-log 0.4 - Size-limited, concurrent, automatically-rotating log writer.  https://hackage.haskell.org/package/rotating-log-0.4 (OzgunAtaman)
19:18:34 <mjrosenb> ooh, Data.Text.Text is a Monoid.
19:18:37 <mjrosenb> I like.
19:22:13 <doomrobo> mjrosenb, what is your first name, out of curiosity? I think I have the same name as you
19:24:26 <parsecChar> I'm learning Snap/Heist. Is it basically a "type-safe php" ?
19:24:38 <parsecChar> The whole templating thing with splicing seems alot like php
19:26:00 <doomrobo> mjrosenb, also is Monoid useful in that case because you can append Text like <>?
19:27:58 <mjrosenb> doomrobo: marty/martin.
19:28:36 <doomrobo> darn, no luck. My full name is here https://github.com/doomrobo
19:28:44 <mjrosenb> and yes.  text.append is far too much typing.
19:29:25 <mjrosenb> doomrobo: I think we've had this conversation before.  that's my cousin's name.
19:31:10 <doomrobo> heh, maybe, but I'm new to #haskell. It's an annoyingly common name. Every website I try to sign up for has every permutation of the name taken
19:35:51 <xyh> I have never successfully installed anything with 'cabal install'
19:35:53 <xyh> but I can always successfully install them by 'cabal sandbox init && cabal install'
19:35:54 <xyh> what is wrong with 'cabal install' without sandbox? is it true that it can not handle multi-version of a package ?
19:36:25 <parsecChar> if you only have one haskell project on your computer, in theory, it should not matter
19:36:43 <parsecChar> if you have more than one, they might cause conflicts if you have a global cabal repo
19:36:49 <doomrobo> xyh, if you don't want to install packages globally on your computer, it makes sense to compartmentalize
19:37:17 <geekosaur> ghc has serious problems dealing with multiple versions. cabal-install tries to reason with it and often fails. stack beats ghc on the head with a sledgehammer and often succeeds --- but sometimes also fails.
19:37:17 <doomrobo> it's like python virtualenv, if you're familiar with that
19:38:40 <mjrosenb> xyh: when a package failed to install, was it due to a build problem, or a permission problem?
19:38:54 <xyh> build problem
19:40:03 <xyh> painful thing is that I have to compile [on my slow machine] one package manytimes for different projects.
19:42:04 <mjrosenb> strange, I can't remember the last time I ran into one of those.
19:42:27 <refefer> is there a newtype monoid for Data.Map that doesn't use union/unions?
19:42:53 <refefer> it's not a particularly useful one in many cases
19:44:47 <refefer> unsolicited two cents: always use sandboxes, no matter the language
19:44:51 <refefer> it never ends well the other way
19:45:33 <c_wraith> no-rebuild cabal might make that unnecessary, finally.
19:45:51 <gipp> If I have some type family Foo, is there any way to have an equality contraint like `class (Foo a ~ Bar b) => Baz a`, where I can then use the type variable "b" in the class body?
19:45:56 <gipp> as written it complains that b is undefined
19:46:23 <gipp> "not in scope", rather
19:47:38 <c_wraith> gipp: I don't think so.  That doesn't appear to be enough information to figure out what the type family should resolve to.
19:48:02 <xyh> mjrosenb: for example, 'cabal install' fails here :: https://www.refheap.com/115335 , but I can successfully install it by 'cabal sandbox init && cabal install'
19:49:33 <c_wraith> gipp: for a given type `a', there might be many types `b' for which Foo a ~ Bar b
19:50:31 <c_wraith> gipp: Which would explain why that's not allowed.
19:50:33 <gipp> hmm
19:50:45 <gipp> I guess I can see htat
19:50:47 <gipp> thanks
19:53:48 <nshepperd> if Bar is a normal type (not a family) I thought that should work
19:54:48 <nshepperd> but I think there was some rule against introducing new type variables in class contexts
19:54:54 <c_wraith> nshepperd: I'm not sure it would even work in that case.
19:55:13 <c_wraith> You can introduce type variables in a context, if they're only used in the context.  Useful with MPTCs, for instance.
19:55:28 <c_wraith> (Foo a i, Bar b i) => a -> b
19:55:31 <c_wraith> That sort of thing
19:56:00 <c_wraith> Though it would require a fundep in one of those classes to ever resolve.
19:56:03 <nshepperd> yeah but in class contexts?
19:56:33 <c_wraith> Hmm.  Yeah, I can't see a use there so much.  Maybe one can exist, but I don't see it offhand.
19:56:35 <nshepperd> so maybe eg. `class (Foo a ~ Bar (Quux a)) => Baz a` would work, or `class (Foo a ~ Bar b) => Baz a b | a -> b`
20:27:25 <pikajude> is there a more idiomatic way to write this? `second (second (`divMod` 60)) . second (`divMod` 3600) . (`divMod` 86400)`
20:27:53 <c_wraith> :t second (second (`divMod` 60)) . second (`divMod` 3600) . (`divMod` 86400)
20:27:54 <lambdabot> Integral d => d -> (d, (d, (d, d)))
20:27:58 <c_wraith> eww
20:28:13 <mjrosenb> god I hope so.
20:28:19 <pikajude> c_wraith: that's (days, (hours, (minutes, seconds)))
20:28:28 <pikajude> i feel like i'm missing some Monad instance for (,) e
20:28:33 <pikajude> that would make it more sensible
20:28:34 * mjrosenb would probably bind all of those individually.
20:28:42 <c_wraith> There is one, but it doesn't make that easier.
20:28:47 <c_wraith> It's the writer monad.
20:28:58 <pikajude> Oh, writer
20:31:17 <pikajude> yeah, Writer doesn't do it
20:34:01 <wagle> any graphviz gurus available, I'm trying to get a cluster label to render
20:34:23 <wagle> the #graphviz channel is nearly empty
20:47:11 <mjrosenb> I asked in haskell-emacs, but I figured I might as well ask in here.
20:47:16 <mjrosenb> I've bound a bunch of variables in a ghc session, is it possible to re-load the file that I have loaded, then automatically re-execute all of the statements binding variables?
20:47:31 <kakos> Is there something like c2hsc for c2hs that will take a .h file and automatically generate a chs file?
20:54:02 * hackagebot zerobin 1.5.1 - Post to 0bin services  https://hackage.haskell.org/package/zerobin-1.5.1 (ip1981)
20:54:33 <geppettodivacin> What does the ~ mean when used in a type constraint, like in c_wraith's comment about Foo a ~ Bar b earlier?
20:56:02 <kadoban> geppettodivacin: It's like type equality I believe. Might be pronounced "unifies with", I'm not positive.
20:59:00 <mjrosenb> unrelatedly, is there anything like error, where show (error "blah") = "blah"
20:59:07 <Zemyla> You know, there needs to be an exception that can be thrown in code that doesn't import anything from base.
20:59:54 <kadoban> mjrosenb: That's a somewhat odd question to me. How are you attempting to use it?
21:00:19 <kadoban> mjrosenb: Or can you explain more what you're trying to do and how it should work?
21:01:42 <geppettodivacin> kadoban: Looks like it's got something to do with type families.
21:01:50 <geppettodivacin> Thanks!
21:03:07 <mjrosenb> kadoban: I have a structure where in one case, one of the fields is meaningless, so I assign it a bogus value (error "this field should not be looked at")
21:03:19 <mjrosenb> kadoban: and my code knows to ignore it
21:03:27 <mjrosenb> but if I try to show the value in a repl...
21:03:42 <mjrosenb> *boom*, and I can only see part of the structure
21:04:09 <kadoban> mjrosenb: You could define your own Show instance I guess that ignores that thing that can't be shown?
21:04:51 <mjrosenb> yeah... I'm not horribly interested in doing that.
21:25:48 <montanonic> mjrosenb: even though it's only one case, you could just define a null data structure, like, literally, "Null", or, "Bogus"
21:26:22 <montanonic> mjrosenb: hmmm, then again you'd have to add error handling for that, okay; disregard
21:26:25 <montanonic> I see the issue
21:34:03 * hackagebot purescript 0.8.1.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.1.0 (PhilFreeman)
21:47:17 <dprt> I'm looking over some Parsec examples, and seeing people use "m_" prefixes after creating token parsers, without defining any of these prefixed parsers. What is going on here? A Google search isn't turning up much.
21:49:23 <kadoban> dprt: Can you point to some examples?
21:49:48 <kadoban> dprt: Can you tell if the examples actually … work, by the way? Especially with what version they work? It's possible things have changed a lot.
21:50:14 <scshunt> which is the current "best practice" error monad?
21:50:47 <scshunt> MonadError?
21:51:43 <dprt> I'm looking at examples like this: <https://www.haskell.org/wiki/Parsing_expressions_and_statements>. When I search for terms like "m_identifier" or "m_reservedOp," I see this is a pretty common pattern and I might just be missing something really obvious.
21:58:39 <kadoban> Hmm, yeah I'm not sure what those are.
21:58:41 <verement> dprt: those parsers are returned from makeTokenParser when you pass a language definition
21:59:18 <verement> TokenParser { parens = m_parens, … } = makeTokenParser def
22:02:31 <dprt> I thought that makeTokenParser returns a TokenParser? How do the "m_" names get into scope? I'm looking over the source code, and not seeing them. It's been a while since I've used Haskell, so I might be missing something obvious here.
22:03:06 <verement> the record syntax is binding the names
22:07:02 <dprt> Huh - okay. I wasn't expecting that. I guess I'll have to read up on records again, then.
22:08:37 <mjrosenb> It looks like Data.Text doesn't have a heirarchical substring implementation?
22:09:47 <verement> > let Sum { getSum = x } = Sum { getSum = 3 } in x  -- dprt
22:09:48 <lambdabot>  3
22:11:28 <dprt> verement: Oh - now I feel dumb. The binding is made when the field is matched. That makes sense.
22:12:21 <dprt> That's a lot more convenient than making top-level bindings to the relevant parsers.
22:12:40 <verement> right on
22:14:56 <verement> although I think these *are* top-level bindings
22:16:34 <verement> since the record matching is done in a top-level equation
22:17:40 <EvanR> mniip: i implemented your algorithm and tried it on a random stream of bits, yes it seems to slow down quadratically though im not sure why
22:18:09 <dprt> verement: Yeah, I just tried it out with the Sum example. I had no idea you could do that.
22:18:24 <EvanR> mniip: also i think you can prove that it cant diverge
22:19:24 <EvanR> to diverge it would need to be asked to add 0101010... to 101010101... but when shift back into place, these numbers arent the same number. so no number could be input to cause the diverging pattern
22:25:36 <EvanR> @tell mniip http://lpaste.net/153574
22:25:36 <lambdabot> Consider it noted.
22:28:34 <saurabhnanda> I've been mulling over the Reader Monad for the two days now, and have only managed to achieve a mind-block. Referring to first snippet of code at http://passy.svbtle.com/dont-fear-the-reader , where is the Reader monad actually being created. Which line/function is calling the Reader constructor?
22:29:12 <mjrosenb> oh dear why
22:29:19 <mjrosenb> did I ever name a function (...)
22:29:31 <EvanR> saurabhnanda: computation = do is defining the reader
22:30:08 <EvanR> runReader is using it
22:30:31 <saurabhnanda> in it's de-sugared form it is this: computation = ask >>= (\greeting -> return $ ("a")) // which means that 'ask' is the data constructor?
22:30:47 <EvanR> no
22:31:03 <EvanR> you dont need a ctor, >>= takes two values if you got em
22:31:13 <EvanR> :t ask
22:31:14 <lambdabot> MonadReader r m => m r
22:31:33 <saurabhnanda> is this understanding correct: runReader :: Reader r a -> (r -> a)
22:31:48 <ahihi> ask gives you one Reader String String, binding it to (\greeting -> ...) produces another
22:31:50 <EvanR> ask :: Reader r
22:32:00 <EvanR> :t runReader
22:32:01 <lambdabot> Reader r a -> r -> a
22:32:06 <EvanR> saurabhnanda: right
22:32:35 <EvanR> the constructors are hidden behind the scenes
22:32:45 <saurabhnanda> EvanR: something somewhere in that code is contructing a Reader. I HAVE to figure out what.
22:32:48 <EvanR> this is referred to as the abstract data type 
22:32:55 <saurabhnanda> EvanR: List is a Monad, right. You can clearly construct one using []
22:32:58 <EvanR> behind the scenes ask is using a ctor
22:33:04 <EvanR> also return 
22:33:07 <saurabhnanda> EvanR: Maybe is a monad. You can construct it using Nothing OR Just 1
22:33:26 <EvanR> right those are raw data types, you have access to the constructors
22:33:38 <EvanR> IO, Reader, etc are abstract, the constructors are hidden
22:33:53 <saurabhnanda> why was Reader written in such a confusing way? What's the advantage?
22:34:04 <EvanR> well, it hides the implementation details
22:34:17 <EvanR> its even more confusing than you think ;)
22:34:20 <saurabhnanda> why can't I give a HashMap to a Reader, the HashMap representing an environment and call it a day?
22:34:27 <EvanR> you can
22:34:29 <ahihi> what's stopping you?
22:34:30 <pavonia> saurabhnanda: You can also construct a reader directly using ReaderT directly
22:34:32 <saurabhnanda> how?
22:34:40 <EvanR> runReader computation myHashMap
22:34:59 <EvanR> and use asks to access it
22:35:11 <saurabhnanda> so leaving aside the mystery of the missing ctor, what arguments are being passed to 'ask'
22:35:18 <pavonia> :t ReaderT $ \r -> return "foo"
22:35:19 <lambdabot> Monad m => ReaderT r m [Char]
22:35:19 <EvanR> none, ask isnt a function
22:35:20 <ahihi> ask doesn't take arguments
22:35:25 <ahihi> :t ask
22:35:26 <lambdabot> MonadReader r m => m r
22:35:27 <EvanR> ask :: Reader r
22:35:39 <ahihi> Reader r r, rather
22:35:42 <EvanR> Reader r r
22:35:55 <EvanR> if you run it, you get an r
22:36:30 <EvanR> pavonia: which only begs the question
22:37:14 <ahihi> ask and return are the basic building blocks defined using the constructor
22:37:51 <EvanR> saurabhnanda: you can probably understand this better by implementing a Reader yourself (in a way much simpler than the standard lib(s) way(s))
22:38:07 <EvanR> its the simplest monad besides Identity
22:38:12 <pavonia> EvanR: What question?
22:38:19 <EvanR> pavonia: like, where are the ctors
22:38:37 <saurabhnanda> EvanR: I've read all the Reader tutorials out there. I understand the motivation and how to build on my own. But I just can't understand why the standard Reader has this SUPER WEIRD API.
22:38:48 <EvanR> super weird?
22:38:51 <pavonia> EvanR: In the transformers package, I think
22:39:07 <EvanR> what do you want the api to look like?
22:39:15 <ahihi> it seems like quite an ordinary monadic api to me
22:40:42 <saurabhnanda> where's the ctor :-)
22:40:49 <saurabhnanda> and what is ask doing?
22:41:02 <EvanR> that is where implementing a simple reader yourself comes in
22:41:06 <saurabhnanda> should it be 'ask readerMonad someKey' ?
22:41:12 <EvanR> :t asks
22:41:13 <lambdabot> MonadReader r m => (r -> a) -> m a
22:41:17 <liste> saurabhnanda: where's the constructor for Text ?
22:41:23 <EvanR> saurabhnanda: no, ask is not a function
22:41:31 <EvanR> asks is
22:42:12 <liste> saurabhnanda: or Array ?
22:42:41 <EvanR> liste: you could say, but those are not monads!
22:42:57 <EvanR> and it may seem like monad examples tend to have ctors exposed
22:42:58 <saurabhnanda> liste: "abc" is an implicit literal constructor. [] is a constructor for Array. They're pretty much visible.
22:43:15 <EvanR> [] is not an Array
22:43:15 <saurabhnanda> EvanR: [] is a Monad, right?
22:43:15 <liste> saurabhnanda: you're talking about String and [] (list)
22:43:25 <saurabhnanda> hang on
22:43:29 <saurabhnanda> let me read more and come back
22:43:38 <liste> saurabhnanda: Text and Array are totally different types
22:43:40 <saurabhnanda> but I have a feeling this is more complicated than it should be
22:43:45 <EvanR> Text and Array both have no ctor visible
22:43:57 <EvanR> that is important so you dont fuck things up
22:44:02 <pavonia> saurabhnanda: You could also ask, where's the contructor in (putStrLn "hello!")
22:45:36 <pavonia> Or better:
22:45:41 <pavonia> :t getLine
22:45:42 <lambdabot> IO String
22:45:58 <kadoban> saurabhnanda: The audience of the page you linked apppears to be JavaScript programmers perhaps. How familiar with haskell are you?
22:50:12 <EvanR> im really glad that blog talking about Reader brought up "dependency injection"
22:50:32 <EvanR> the most hilariously over blow way to describe passing an argument into a function
22:52:04 <liste> EvanR: and then they build up all sorts of frameworks and run-time reflection based machinery to pass arguments to functions....
23:19:17 <jle`> ooh i used (':':) today
23:19:45 <jle`> that was fun
23:21:19 <liste> conjoined twins where one is smiling with a tear and the other is just smiling?
23:34:13 <EvanR> jle`: what the heck, type level type annotation? ;)
23:34:45 <liste> > (':':) "hello world"
23:34:47 <lambdabot>  ":hello world"
23:35:14 <jle`> :t (':':)
23:35:15 <lambdabot> [Char] -> [Char]
23:37:52 <EvanR> :k (':)
23:37:53 <lambdabot> parse error on input ‘:’
23:37:56 <saurabhnanda> EvanR: liste kadoban pavonia I'm back
23:37:56 <EvanR> dont get it
23:38:10 <saurabhnanda> :t getLine
23:38:11 <lambdabot> IO String
23:38:12 <EvanR> oh :t ':'
23:38:22 <EvanR> tricky
23:38:39 <EvanR> saurabhnanda: so getLine is like ask, basically
23:38:45 <EvanR> dont worry about how it works
23:38:45 <saurabhnanda> so, same question, where's the constructor for IO () monad
23:38:47 <EvanR> just how to use it
23:39:20 <EvanR> you dont want the constructors for IO, that would be unproductive
23:39:35 <saurabhnanda> BUT I can accept IO being given special treatment. Somehow I can't accept Reader being given this special treatment. Reader is supposed to string-along a PROGRAMMER-DEFINED environment. Why is there no clean way to define a Reader environment?
23:40:19 <pavonia> There's no special treatment of Reader
23:40:24 <saurabhnanda> EvanR: "so getLine is like ask, basically" // So, it's 'ask' which "creates" the Reader monad, right?
23:40:54 <pavonia> @srx ask
23:40:54 <lambdabot> Source not found. There are some things that I just don't know.
23:41:03 <kadoban> saurabhnanda: There is a way to define the environment. That's what runReader does. The thing you're looking at is the definition of a computation that can internally *use* the implicit Reader environment.
23:41:04 <EvanR> saurabhnanda: yes behind the scenes, somehow
23:41:14 <kadoban> saurabhnanda: The audience of the page you linked apppears to be JavaScript programmers perhaps. How familiar with haskell are you?
23:41:29 <saurabhnanda> kadoban: I belive I'm pretty familiar with HAskell now
23:42:00 <pavonia> saurabhnanda: aks = ReaderT (\r -> return r) <-- There you have the explicit constructor
23:42:03 <EvanR> saurabhnanda: this is a common pattern in haskell, "the combinator pattern" where the library gives you some primitives (ask, getLine) and ways of combining them (>>= >> runReader) and thats it. its like an embedded DSL
23:42:11 <saurabhnanda> kadoban: I've managed to write this till now -- https://github.com/vacationlabs/nightwatch/tree/master/haskell/Nightwatch
23:42:30 <kadoban> Okay, good. Because it seems to assume you're *quite* familiar with haskell already.
23:43:03 <saurabhnanda> pavonia: where did you get that definition of ask from?
23:43:22 <pavonia> saurabhnanda: I made it up from the type
23:44:19 <mauke> :t ReaderT
23:44:20 <lambdabot> (r -> m a) -> ReaderT r m a
23:44:23 <ahihi> it's also here http://hackage.haskell.org/package/transformers-0.5.1.0/docs/src/Control-Monad-Trans-Reader.html#ask
23:44:29 <mauke> :t ask
23:44:30 <lambdabot> MonadReader r m => m r
23:45:12 <pavonia> Oh, that's another ask than the one I was thinking of
23:45:48 <pavonia> The one form the link above is ask :: (Monad m) => ReaderT r m r
23:46:26 <EvanR> saurabhnanda: this is also filed under "smart constructor" pattern
23:47:10 <EvanR> instead of exposing data Reader a = Pure a | Ask | ... you get lowercase versions which protect the library against misuse
23:54:02 <saurabhnanda> so basically 'ask' is the constructor, right? If not the constructor, it implicitly calls the constructor. Without calling 'ask' one cannot start the Reader "monadic chain". Right
23:54:02 <saurabhnanda> ?
23:54:23 <saurabhnanda> if that is correct, my problem now shifts to wrapping my head around ReaderT
23:54:29 <EvanR> it somehow uses some constructor somewhere, because it returns a Reader r r
23:54:40 <EvanR> it doesnt need to be literally the constructor
23:54:58 <EvanR> so does return
23:55:13 <EvanR> return :: a -> Reader r a
23:55:29 <saurabhnanda> btw, why does ask return a 'Reader r r'
23:55:37 <saurabhnanda> why not Reader r a
23:55:37 <saurabhnanda> ?
23:55:38 <EvanR> its not returning, its not a function
23:55:48 <EvanR> its Reader r r because its required to produce your context
23:55:49 <EvanR> r = r
23:55:53 <EvanR> a = r
23:56:12 <saurabhnanda> :t ask
23:56:13 <lambdabot> MonadReader r m => m r
23:56:32 <EvanR> m = Reader r
23:56:34 <saurabhnanda> what's this new thing now? Where did MonadReader come from?
23:57:07 <EvanR> that lets you use whatever monad you make as a reader
23:57:15 <jle`> saurabhnanda: ask is an "action"
23:57:15 <EvanR> if you implement the methods, namely
23:57:16 <EvanR> :t ask
23:57:17 <lambdabot> MonadReader r m => m r
23:57:43 <EvanR> Reader r is just one instance of MonadReader
23:57:48 <jle`> saurabhnanda: 'getLine', for example, is an IO action whose result is what is received from stdin
23:57:58 <jle`> 'ask' is a `Reader r` action whose result is an 'r' -- the environment
23:59:14 <jle`> ask here is MonadReader r m => .., because it's polymorphic over all types that let you "ask" for an Environment
23:59:22 <saurabhnanda> so, what is the *real* abstraction here? Reader, MonadReader, or ReaderT?
23:59:28 <jle`> `ReaderT r m`, as well, is something that you can 'ask' for an 'r'
23:59:46 <jle`> Reader r, ReaderT r m, are all concrete types that you can "ask" for things in an action
23:59:51 <EvanR> saurabhnanda: theres a lot of stuff going on here, so whats your question. what is "ask" really?
